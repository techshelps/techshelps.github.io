<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIMPLEX.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4721"></a>SIMPLEX.C</h2>
<pre><code>/*++ <br> <br>Copyright 1994 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    simplex.c <br> <br>Abstract: <br> <br>    Simple single-threaded DLC test/example program. Need 2 instances of this <br>    app - 1 to send and 1 to receive (i.e. the typical DLC situation hence <br>    simplex, or half-duplex in old money). By default, both sides use SAP 4 <br> <br>    Receiver is started: <br> <br>        simplex <br> <br>    Transmitter is started e.g. <br> <br>        simplex /t02608c4c970e <br> <br>    in this example the node address is in canonical form (ethernet format) as <br>    displayed by "net config wksta", e.g., not the non-canonical (token-ring <br>    format) that the DLC API expects. If this test app is being run over <br>    token ring then you would supply the non-canonical address, as used by <br>    token ring, e.g. <br> <br>        simplex /t10005a7b08b4 <br> <br>    Command line options are: <br> <br>        /a# - use adapter # <br>        /b# - change the buffer pool size from the default 20K to # <br>        /o  - options: <br>            /or# - set receive READ option <br>            /ot# - set transmit READ option <br>        /r# - send to remote SAP # (transmitter only) <br>        /s# - open local SAP # <br>        /t# - send to station address # (transmitter only) <br>        /z# - transmit packets of size #, else send random sized packets <br>              (transmitter only) <br> <br>    Contents: <br>        main <br>        usage <br>        get_funky_number <br>        is_radical_digit <br>        char_to_number <br>        handle_ctrl_c <br>        terminate <br>        xtou <br>        open_adapter <br>        adapter_status <br>        close_adapter <br>        create_buffer <br>        open_sap <br>        open_station <br>        connect_station <br>        flow_control <br>        get_buffer <br>        free_buffer <br>        post_receive <br>        post_read <br>        tx_i_frame <br>        slush <br>        do_transmit <br>        do_receive <br>        check_keyboard <br>        dispatch_read_events <br>        handle_status_change <br>        handle_receive_data <br>        handle_transmit_complete <br>        handle_command_complete <br>        twiddle_bits <br>        swap_bits <br>        my_malloc <br>        my_calloc <br>        my_free <br>        nice_num <br> <br>Author: <br> <br>    Richard L Firth (rfirth) 6-Mar-1994 <br> <br>Environment: <br> <br>    Win32 app (console) <br> <br>Revision History: <br> <br>John Lee (johnlee) 22-Feb-1996 <br> <br>--*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;signal.h&gt; <br>#undef tolower <br>#include &lt;windows.h&gt; <br>#include &lt;dlcapi.h&gt; <br> <br>#include "dlcdebug.h" <br> <br>#ifndef _CRTAPI1 <br>#define _CRTAPI1 <br>#endif <br> <br>#define SIMPLEX_VERSION "1.11" <br> <br>#define RECEIVE_MODE    0 <br>#define TRANSMIT_MODE   1 <br> <br>#define DLCBUFSIZE  20000 <br>#define SAP_NUMBER  4 <br>#define RECEIVE_COMPLETE_FLAG   0x50204030 <br>#define RECEIVE_DATA_FLAG       0x50204040 <br>#define TRANSMIT_COMPLETE_FLAG  0x50404030 <br> <br>#define TX_STATE_OPENING    1 <br>#define TX_STATE_OPENED     2 <br>#define TX_STATE_TRANSMITTING   3 <br>#define TX_STATE_BUSY       4 <br> <br>#define RX_STATE_LISTENING  1 <br>#define RX_STATE_RECEIVING  2 <br>#define RX_STATE_BLOCKED    3 <br> <br>#define MAX_OUTSTANDING_TRANSMIT_THRESHOLD  100 <br>#define MIN_OUTSTANDING_TRANSMIT_THRESHOLD  10 <br> <br>#define IS_ARG(c)   (((c) == '-') || ((c) == '/')) <br>#define ZAP(thing)  memset(&amp;thing, 0, sizeof(thing)) <br>#define MALLOC      my_malloc <br>#define CALLOC      my_calloc <br>#define FREE        my_free <br> <br>typedef struct { <br>    DWORD sequence; <br>    DWORD size; <br>    DWORD signature; <br>    DWORD checksum; <br>    char data[]; <br>} TEST_PACKET, *PTEST_PACKET; <br> <br>void _CRTAPI1 main(int, char**); <br>void usage(void); <br>DWORD get_funky_number(char**); <br>BOOL is_radical_digit(char, DWORD); <br>DWORD char_to_number(char); <br>void _CRTAPI1 handle_ctrl_c(int); <br>void terminate(int); <br>unsigned char xtou(char); <br>void open_adapter(void); <br>unsigned short adapter_status(void); <br>void close_adapter(void); <br>void create_buffer(int); <br>void open_sap(int); <br>void open_station(void); <br>void connect_station(unsigned short); <br>void flow_control(int); <br>PLLC_BUFFER get_buffer(void); <br>int free_buffer(PLLC_BUFFER); <br>void post_receive(void); <br>PLLC_CCB post_read(void); <br>void tx_i_frame(void); <br>DWORD slush(char*, int); <br>void do_transmit(void); <br>void do_receive(void); <br>void check_keyboard(void); <br>void dispatch_read_events(PLLC_CCB); <br>void handle_status_change(PLLC_CCB); <br>void handle_receive_data(PLLC_CCB); <br>void handle_transmit_complete(PLLC_CCB); <br>void handle_command_complete(PLLC_CCB); <br>void twiddle_bits(LPBYTE, DWORD); <br>unsigned char swap_bits(unsigned char); <br>void* my_malloc(int); <br>void* my_calloc(int, int); <br>void my_free(void*); <br>char* nice_num(unsigned long); <br> <br>BYTE Adapter = 0; <br>DWORD BufferPoolSize = DLCBUFSIZE; <br>BYTE RemoteNode[6]; <br>WORD LocalSap = SAP_NUMBER; <br>WORD RemoteSap = SAP_NUMBER; <br>DWORD Mode = RECEIVE_MODE; <br>BOOL SwapAddressBits = 0; <br>HANDLE TheMainEvent; <br>DWORD MaxFrameSize; <br>DWORD TransmitDataLength = 0; <br>LPBYTE BufferPool; <br>HANDLE BufferHandle; <br>USHORT StationId; <br>DWORD RxState = 0; <br>DWORD TxState = 0; <br>DWORD LocalBusy = 0; <br>DWORD RemoteBusy = 0; <br>DWORD Verbose = 0; <br>DWORD JustBufferInfo = 0; <br>LONG AllocatedBytesOutstanding = 0; <br>DWORD TotalBytesAllocated = 0; <br>DWORD TotalBytesFreed = 0; <br>LONG OutstandingTransmits = 0; <br>DWORD DisplayBufferFreeInfo = 1; <br>DWORD DisplayFrameReceivedInfo = 1; <br>DWORD DisplayTransmitInfo = 0; <br>DWORD DisplayCcb = 1; <br>DWORD TotalTransmits = 0; <br>DWORD TotalTransmitCompletions = 0; <br>DWORD TransmitCompleteEvents = 0; <br>DWORD CommandCompleteEvents = 0; <br>DWORD StatusChangeEvents = 0; <br>DWORD ReceiveDataEvents = 0; <br>DWORD DataFramesReceived = 0; <br>DWORD DlcBuffersReceived = 0; <br>DWORD DlcBuffersFreed = 0; <br>DWORD TotalBytesTransmitted = 0; <br>DWORD TotalTxBytesCompleted = 0; <br>DWORD TotalPacketBytesReceived = 0; <br>DWORD TotalDlcBytesReceived = 0; <br>DWORD TotalReadsChecked = 0; <br>DWORD TotalReadEvents = 0; <br>DWORD MaxChainedReceives = 0; <br>DWORD MaxChainedTransmits = 0; <br>DWORD MinBuffersAvailable = 0; <br>DWORD MaxBuffersAvailable = 0; <br> <br>DWORD LinkLostEvents = 0; <br>DWORD DiscEvents = 0; <br>DWORD FrmrReceivedEvents = 0; <br>DWORD FrmrSentEvents = 0; <br>DWORD SabmeResetEvents = 0; <br>DWORD SabmeOpenEvents = 0; <br>DWORD RemoteBusyEnteredEvents = 0; <br>DWORD RemoteBusyLeftEvents = 0; <br>DWORD TiExpiredEvents = 0; <br>DWORD DlcCounterOverflowEvents = 0; <br>DWORD AccessPriorityLoweredEvents = 0; <br>DWORD InvalidStatusChangeEvents = 0; <br>DWORD LocalBusyEvents = 0; <br> <br>BYTE OptionChainReceiveData = 1; <br>BYTE OptionChainTransmits = 0; <br> <br>// The application ID is used on Windows 95, but not on Windows NT. <br> <br>BYTE bApplId = 0; <br> <br>void _CRTAPI1 main(int argc, char** argv) { <br> <br>    printf("\nDLC simplex test. Version " SIMPLEX_VERSION " " __DATE__ " " __TIME__ "\n\n"); <br> <br>    for (--argc, ++argv; argc; --argc, ++argv) { <br>        if (IS_ARG(**argv)) { <br>            switch (tolower(*++*argv)) { <br>            case 'a': <br>                Adapter = atoi(++*argv); <br>                break; <br> <br>            case 'b': <br>                ++*argv; <br>                BufferPoolSize = get_funky_number(argv); <br>                break; <br> <br>            case 'h': <br>            case '?': <br>                usage(); <br> <br>            case 'o': <br>                ++*argv; <br>                while (**argv) { <br>                    switch (tolower(**argv)) { <br>                    case 'r': <br>                        ++*argv; <br>                        OptionChainReceiveData = (BYTE)get_funky_number(argv); <br>                        break; <br> <br>                    case 't': <br>                        ++*argv; <br>                        OptionChainTransmits = (BYTE)get_funky_number(argv); <br>                        break; <br> <br>                    default: <br>                        printf("error: unrecognized option '%c'\n", **argv); <br>                        usage(); <br>                    } <br>                } <br>            case 'r': <br>                ++*argv; <br>                RemoteSap = (WORD)get_funky_number(argv); <br>                break; <br> <br>            case 's': <br>                ++*argv; <br>                LocalSap = (WORD)get_funky_number(argv); <br>                break; <br> <br>            case 't': { <br> <br>                int i; <br>                LPSTR p = ++*argv; <br> <br>                Mode = TRANSMIT_MODE; <br>                if (strlen(p) != 12) { <br>                    printf("incorrect remote node format (12 hex digits required)\n"); <br>                    usage(); <br>                } <br>                for (i = 0; i &lt; 6; ++i) { <br>                    RemoteNode[i] = (xtou(*p++) &lt;&lt; 4) + xtou(*p++); <br>                } <br>                break; <br>            } <br> <br>            case 'v': <br>                Verbose = 1; <br>                break; <br> <br>            case 'z': <br>                ++*argv; <br>                TransmitDataLength = get_funky_number(argv); <br>                break; <br>            } <br>        } <br>    } <br> <br>    if ((TheMainEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) { <br>        printf("CreateEvent returns %d\n", GetLastError()); <br>        exit(1); <br>    } <br> <br>    printf("Running in %s mode.\n\n", <br>            (Mode == TRANSMIT_MODE) ? "Transmit" : "Receive" <br>            ); <br> <br>    if (Mode == TRANSMIT_MODE) { <br>        printf("remote node = %02x-%02x-%02x-%02x-%02x-%02x\n", <br>            RemoteNode[0] &amp; 0xff, <br>            RemoteNode[1] &amp; 0xff, <br>            RemoteNode[2] &amp; 0xff, <br>            RemoteNode[3] &amp; 0xff, <br>            RemoteNode[4] &amp; 0xff, <br>            RemoteNode[5] &amp; 0xff <br>            ); <br>        DisplayTransmitInfo = 1; <br>    } <br>    open_adapter(); <br>    MaxFrameSize = min((1500 - (14 + 4)), MaxFrameSize); <br>    if (TransmitDataLength &amp;&amp; (TransmitDataLength &gt; MaxFrameSize)) { <br>        TransmitDataLength = MaxFrameSize; <br>    } <br>    printf("opened adapter %d. maximum frame size = %d\n", Adapter, MaxFrameSize); <br>    switch (adapter_status()) { <br>    case 0: <br>        printf("type of adapter %d is token ring: not flipping hamburgers (nor address bits)\n", Adapter); <br>        SwapAddressBits = 0; <br>        break; <br> <br>    case 1: <br>        printf("type of adapter %d is ethernet: will flip address bits\n", Adapter); <br>        SwapAddressBits = 1; <br>        break; <br> <br>    case 2: <br>        printf("type of adapter %d is PC/Network card: don't know how to handle\n", Adapter); <br>        terminate(1); <br> <br>    case 3: <br>        printf("adapter %d is &gt;&gt; UNKNOWN &lt;&lt;. Will assume FDDI and flip bits.\n" <br>               "If not correct, please fix\n", Adapter); <br>        printf("hit a key to continue... "); getch(); putchar('\n'); <br>        break; <br>    } <br>    create_buffer(BufferPoolSize); <br>    MinBuffersAvailable = free_buffer(get_buffer()); <br>    printf("created %d byte buffer pool @%x. Handle = %x. Initial buffers = %d\n", <br>        BufferPoolSize, BufferPool, BufferHandle, MinBuffersAvailable); <br>    open_sap(LocalSap); <br>    if (Verbose) { <br>        printf("opened SAP %d: StationId = %04x\n", LocalSap, StationId); <br>    } <br>    signal(SIGINT, handle_ctrl_c); <br>    if (Mode == TRANSMIT_MODE) { <br>        if (SwapAddressBits) { <br>            twiddle_bits(RemoteNode, 6); <br>        } <br>        do_transmit(); <br>    } else { <br>        do_receive(); <br>    } <br>    terminate(0); <br>} <br> <br>void usage() { <br>    printf("usage: simplex [/a#] [/b#] [/h] [/o&lt;option&gt;] [/r#] [/s#] [/t&lt;node&gt;] [/v] [/z#]\n" <br>           "\n" <br>           "       /a = adapter number. Default = 0\n" <br>           "       /b = buffer pool size\n" <br>           "       /h = this help\n" <br>           "       /o = options:\n" <br>           "       /or[#] = chain receive data\n" <br>           "           0 = do NOT chain\n" <br>           "           1 = chain on link station basis (DEFAULT)\n" <br>           "           2 = chain on SAP basis\n" <br>           "       /ot[#] = chain transmit completions\n" <br>           "           0 = chain on link station basis (DEFAULT)\n" <br>           "           1 = do NOT chain\n" <br>           "           2 = chain on SAP basis\n" <br>           "       /r = remote SAP number (transmitter)\n" <br>           "       /s = local SAP number to use\n" <br>           "       /t = transmit mode\n" <br>           "       /v = verbose\n" <br>           "       /z = transmit data length. If omitted, packet size is random\n" <br>           "\n" <br>           "&lt;node&gt; is remote node id in correct form for medium\n" <br>           "default mode is receiver\n" <br>           "The buffer pool minimum threshold is 25%% of the buffer pool size\n" <br>           "\n" <br>           ); <br>    exit(1); <br>} <br> <br>DWORD get_funky_number(char** string) { <br> <br>    DWORD radix = 10; <br>    char* p = *string; <br>    DWORD num = 0, sign=1; <br> <br>    if (!*p) { <br>        return 0; <br>    } <br> <br>    if (*p=='-') { <br>        sign = (DWORD)-1; <br>        p++; <br>    } <br> <br>    if (!strnicmp(p, "0x", 2)) { <br>        p += 2; <br>        radix = 16; <br>    } <br> <br>    while (is_radical_digit(*p, radix)) { <br>        num = num * radix + char_to_number(*p); <br>        ++p; <br>    } <br> <br>    if (toupper(*p) == 'K') { <br>        if (radix == 10) { <br>            ++p; <br>            num *= 1024; <br>        } else { <br>            *string = NULL; <br>            return 0; <br>        } <br>    } <br>    *string = p; <br>    return sign * num; <br>} <br> <br>BOOL is_radical_digit(char possible_digit, DWORD radix) { <br>    return (radix == 16) ? isxdigit(possible_digit) : isdigit(possible_digit); <br>} <br> <br>DWORD char_to_number(char character) { <br>    if (isdigit(character)) { <br>        return (DWORD)(character - '0'); <br>    } else { <br>        return (DWORD)(toupper(character) - 'A') + 10; <br>    } <br>} <br> <br>void _CRTAPI1 handle_ctrl_c(int sig) { <br> <br>    char ch; <br> <br>    printf("\a\n" <br>           "Interrupted from console (control-c detected)\n" <br>           "Quit program? [Y/N] " <br>           ); <br>    do { <br>        ch = tolower(getch()); <br>        if (ch != 'y' &amp;&amp; ch != 'n') { <br>            putchar('\a'); <br>        } <br>    } while ( ch != 'y' &amp;&amp; ch != 'n' ); <br>    putchar(ch); <br>    putchar('\n'); <br>    if (ch == 'y') { <br>        terminate(1); <br>    } <br>    signal(SIGINT, handle_ctrl_c); <br>} <br> <br>void terminate(int exit_code) { <br> <br>    close_adapter(); <br> <br>    printf("\nterminating %s mode\n", (Mode == TRANSMIT_MODE) ? "transmit" : "receive"); <br> <br>    printf("\n" <br>           "Memory statistics:\n"); <br>    printf("\tAllocatedBytesOutstanding    = %s\n", nice_num(AllocatedBytesOutstanding)); <br>    printf("\tTotalBytesAllocated          = %s\n", nice_num(TotalBytesAllocated)); <br>    printf("\tTotalBytesFreed              = %s\n", nice_num(TotalBytesFreed)); <br> <br>    printf("\n" <br>           "Buffer statistics:\n"); <br>    printf("\tMinBuffersAvailable          = %s\n", nice_num(MinBuffersAvailable)); <br>    printf("\tMaxBuffersAvailable          = %s\n", nice_num(MaxBuffersAvailable)); <br>    printf("\tDlcBuffersFreed              = %s\n", nice_num(DlcBuffersFreed)); <br> <br>    printf("\n" <br>           "READ statistics:\n"); <br>    printf("\tTotalReadsChecked            = %s\n", nice_num(TotalReadsChecked)); <br>    printf("\tTotalReadEvents              = %s\n", nice_num(TotalReadEvents)); <br>    printf("\tCommandCompleteEvents        = %s\n", nice_num(CommandCompleteEvents)); <br>    printf("\tTransmitCompleteEvents       = %s\n", nice_num(TransmitCompleteEvents)); <br>    printf("\tReceiveDataEvents            = %s\n", nice_num(ReceiveDataEvents)); <br>    printf("\tStatusChangeEvents           = %s\n", nice_num(StatusChangeEvents)); <br> <br>    if (Mode == TRANSMIT_MODE) { <br>        printf("\n" <br>               "Transmit statistics:\n"); <br>        printf("\tTotalTransmits               = %s\n", nice_num(TotalTransmits)); <br>        printf("\tTotalTransmitCompletions     = %s\n", nice_num(TotalTransmitCompletions)); <br>        printf("\tOutstandingTransmits         = %s\n", nice_num(OutstandingTransmits)); <br>        printf("\tTotalBytesTransmitted        = %s\n", nice_num(TotalBytesTransmitted)); <br>        printf("\tTotalTxBytesCompleted        = %s\n", nice_num(TotalTxBytesCompleted)); <br>        printf("\tMaxChainedTransmits          = %s\n", nice_num(MaxChainedTransmits)); <br>    } else { <br>        printf("\n" <br>               "Receive statistics:\n"); <br>        printf("\tDataFramesReceived           = %s\n", nice_num(DataFramesReceived)); <br>        printf("\tDlcBuffersReceived           = %s\n", nice_num(DlcBuffersReceived)); <br>        printf("\tTotalPacketBytesReceived     = %s\n", nice_num(TotalPacketBytesReceived)); <br>        printf("\tTotalDlcBytesReceived        = %s\n", nice_num(TotalDlcBytesReceived)); <br>        printf("\tMaxChainedReceives           = %s\n", nice_num(MaxChainedReceives)); <br>    } <br> <br>    printf("\n" <br>           "Status change statistics:\n"); <br>    printf("\tLinkLostEvents               = %s\n", nice_num(LinkLostEvents)); <br>    printf("\tDiscEvents                   = %s\n", nice_num(DiscEvents)); <br>    printf("\tFrmrReceivedEvents           = %s\n", nice_num(FrmrReceivedEvents)); <br>    printf("\tFrmrSentEvents               = %s\n", nice_num(FrmrSentEvents)); <br>    printf("\tSabmeResetEvents             = %s\n", nice_num(SabmeResetEvents)); <br>    printf("\tSabmeOpenEvents              = %s\n", nice_num(SabmeOpenEvents)); <br>    printf("\tRemoteBusyEnteredEvents      = %s\n", nice_num(RemoteBusyEnteredEvents)); <br>    printf("\tRemoteBusyLeftEvents         = %s\n", nice_num(RemoteBusyLeftEvents)); <br>    printf("\tTiExpiredEvents              = %s\n", nice_num(TiExpiredEvents)); <br>    printf("\tDlcCounterOverflowEvents     = %s\n", nice_num(DlcCounterOverflowEvents)); <br>    printf("\tAccessPriorityLoweredEvents  = %s\n", nice_num(AccessPriorityLoweredEvents)); <br>    printf("\tInvalidStatusChangeEvents    = %s\n", nice_num(InvalidStatusChangeEvents)); <br>    printf("\tLocalBusyEvents              = %s\n", nice_num(LocalBusyEvents)); <br> <br>    exit(exit_code); <br>} <br> <br>unsigned char xtou(char ch) { <br>    return ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')) <br>        ? (unsigned char)(ch - '0') <br>        : ((ch &gt;= 'A') &amp;&amp; (ch &lt;= 'F')) <br>            ? (unsigned char)((ch - 'A') + 10) <br>            : (unsigned char)((ch - 'a') + 10); <br>} <br> <br>void open_adapter() { <br> <br>    LLC_CCB ccb; <br>    LLC_DIR_OPEN_ADAPTER_PARMS parms; <br>    LLC_ADAPTER_OPEN_PARMS adapterParms; <br>    LLC_DLC_PARMS dlcParms; <br>    LLC_EXTENDED_ADAPTER_PARMS extendedParms; <br>    LLC_STATUS status; <br> <br>    ZAP(ccb); <br>    ZAP(adapterParms); <br>    ZAP(dlcParms); <br>    ZAP(extendedParms); <br> <br>    parms.pAdapterParms = &amp;adapterParms; <br>    parms.pExtendedParms = &amp;extendedParms; <br>    parms.pDlcParms = &amp;dlcParms; <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_DIR_OPEN_ADAPTER; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("open_adapter: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("open_adapter: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("open_adapter: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>bApplId = ccb.uchReserved2; <br>    MaxFrameSize = adapterParms.usMaxFrameSize; <br>} <br> <br>unsigned short adapter_status() { <br> <br>    LLC_CCB ccb; <br>    LLC_DIR_STATUS_PARMS parms; <br>    ACSLAN_STATUS status; <br> <br>    ZAP(ccb); <br>    ZAP(parms); <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_DIR_STATUS; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("adapter_status: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("adapter_status: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("adapter_status: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    switch (parms.usAdapterType) { <br>    case 0x0001:    // Token Ring Network PC Adapter <br>    case 0x0002:    // Token Ring Network PC Adapter II <br>    case 0x0004:    // Token Ring Network Adapter/A <br>    case 0x0008:    // Token Ring Network PC Adapter II <br>    case 0x0020:    // Token Ring Network 16/4 Adapter <br>    case 0x0040:    // Token Ring Network 16/4 Adapter/A <br>    case 0x0080:    // Token Ring Network Adapter/A <br>        return 0; <br> <br>    case 0x0100:    // Ethernet Adapter <br>        return 1; <br> <br>    case 0x4000:    // PC Network Adapter <br>    case 0x8000:    // PC Network Adapter/A <br>        return 2; <br>    } <br>    return 3;   // unknown <br>} <br> <br>void close_adapter() { <br> <br>    LLC_CCB ccb; <br>    ACSLAN_STATUS status; <br> <br>    ZAP(ccb); <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_DIR_CLOSE_ADAPTER; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("close_adapter: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("close_adapter: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("close_adapter: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>} <br> <br>void create_buffer(int buflen) { <br> <br>    LLC_CCB ccb; <br>    LLC_BUFFER_CREATE_PARMS parms; <br>    LPBYTE buffer; <br>    LLC_STATUS status; <br> <br>    ZAP(ccb); <br>    ZAP(parms); <br> <br>    buffer = MALLOC(buflen); <br> <br>    parms.pBuffer = buffer; <br>    parms.cbBufferSize = buflen; <br>    parms.cbMinimumSizeThreshold = buflen / 4; <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_BUFFER_CREATE; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED || ccb.uchDlcStatus) { <br>        printf("create_buffer: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("create_buffer: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("create_buffer: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    BufferHandle = parms.hBufferPool; <br>    BufferPool = buffer; <br>} <br> <br>void open_sap(int sap) { <br> <br>    LLC_CCB ccb; <br>    LLC_DLC_OPEN_SAP_PARMS parms; <br>    LLC_STATUS status; <br> <br>    ZAP(ccb); <br>    ZAP(parms); <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_DLC_OPEN_SAP; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br> <br>    parms.uchSapValue = (UCHAR)sap; <br>    parms.uchOptionsPriority = LLC_INDIVIDUAL_SAP; <br>    parms.uchcStationCount = 1; <br>// Set this to non-0 so event will be signalled. <br>// The ibm specs mandate that. <br>parms.DlcStatusFlags = 1; // non-0 to get signalled - johnlee <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED || ccb.uchDlcStatus) { <br>        printf("open_sap: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("open_sap: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("open_sap: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    StationId = parms.usStationId; <br>} <br> <br>void open_station() { <br> <br>    LLC_CCB ccb; <br>    LLC_DLC_OPEN_STATION_PARMS parms; <br>    LLC_STATUS status; <br> <br>    ZAP(ccb); <br>    ZAP(parms); <br> <br>// This should not be LocalSap. Read the specs. -- johnlee <br>    parms.usSapStationId = StationId; //(USHORT)LocalSap &lt;&lt; 8; <br>    parms.uchRemoteSap = (UCHAR)RemoteSap; <br>    parms.pRemoteNodeAddress = (PVOID)RemoteNode; <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_DLC_OPEN_STATION; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED || ccb.uchDlcStatus) { <br>        printf("open_station: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("open_station: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("open_station: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    StationId = parms.usLinkStationId; <br>} <br> <br>void connect_station(unsigned short station) { <br> <br>    LLC_CCB ccb; <br>    LLC_DLC_CONNECT_PARMS parms; <br>    ACSLAN_STATUS status; <br> <br>    ZAP(ccb); <br>    ZAP(parms); <br> <br>    parms.usStationId = station; <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_DLC_CONNECT_STATION; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("connect_station: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("connect_station: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("connect_station: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    if (Verbose) { <br>        printf("connect_station: OK\n"); <br>    } <br>} <br> <br>void flow_control(int station) { <br> <br>    LLC_CCB ccb; <br>    ACSLAN_STATUS status; <br> <br>    ZAP(ccb); <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_DLC_FLOW_CONTROL; <br>    ccb.u.dlc.usStationId = station; <br>    ccb.u.dlc.usParameter = 0xc0; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br> <br>    if (Verbose) { <br>        printf("flow_control(%04x, c0)\n", station); <br>    } <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("flow_control: AcsLan returns %d [%#.2x]\n", <br>            status, ccb.uchDlcStatus); <br>        terminate(1); <br>    } <br>    status = WaitForSingleObject(TheMainEvent, INFINITE); <br>    if (status != WAIT_OBJECT_0) { <br>        printf("flow_control: WaitForSingleObject returns %d [%d]\n", <br>            status, GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("flow_control: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    if (Verbose) { <br>        printf("flow_control: OK\n"); <br>    } <br>    LocalBusy = 0; <br>} <br> <br>PLLC_BUFFER get_buffer() { <br> <br>    LLC_CCB ccb; <br>    LLC_BUFFER_GET_PARMS parms; <br>    ACSLAN_STATUS status; <br> <br>    ZAP(ccb); <br>    ZAP(parms); <br> <br>    parms.cBuffersToGet = 1; <br>    parms.cbBufferSize = 256; <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_BUFFER_GET; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("get_buffer(): AcsLan returns %d [%#.2x]\n", status, ccb.uchDlcStatus); <br>        //terminate(1); <br>        return NULL; <br>    } <br>    if (WaitForSingleObject(TheMainEvent, INFINITE) != WAIT_OBJECT_0) { <br>        printf("get_buffer: WaitForSingleObject returns %d\n", GetLastError()); <br>        terminate(1); <br>    } </code></pre>
<p>
</p>
<pre><code>if (ccb.uchDlcStatus) { <br>        printf("get_buffer: DLC returns %#.2x\n", ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    if (parms.cBuffersLeft &lt; MinBuffersAvailable) { <br>        MinBuffersAvailable = parms.cBuffersLeft; <br>    } <br>    if (parms.cBuffersLeft &gt; MaxBuffersAvailable) { <br>        MaxBuffersAvailable = parms.cBuffersLeft; <br>    } <br>    return (PLLC_BUFFER)parms.pFirstBuffer; <br>} <br> <br>int free_buffer(PLLC_BUFFER buffer) { <br> <br>    LLC_CCB ccb; <br>    LLC_BUFFER_FREE_PARMS parms; <br>    ACSLAN_STATUS status; <br> <br>    if (!buffer) { <br> <br>        // <br>        // microhackette in case get_buffer failed <br>        // <br> <br>        return 0; <br>    } <br> <br>    ZAP(ccb); <br>    ZAP(parms); <br> <br>    parms.pFirstBuffer = (PLLC_XMIT_BUFFER)buffer; <br> <br>    ccb.uchAdapterNumber = Adapter; <br>    ccb.uchDlcCommand = LLC_BUFFER_FREE; <br>    ccb.u.pParameterTable = (PLLC_PARMS)&amp;parms; <br>    ccb.hCompletionEvent = TheMainEvent; <br>    ResetEvent(TheMainEvent); <br>ccb.uchReserved2 = bApplId; <br> <br> <br>    status = AcsLan(&amp;ccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("free_buffer(%x): AcsLan returns %d [%#.2x]\n", buffer, status, ccb.uchDlcStatus); <br>        terminate(1); <br>    } <br>    if (WaitForSingleObject(TheMainEvent, INFINITE) != WAIT_OBJECT_0) { <br>        printf("free_buffer: WaitForSingleObject returns %d\n", GetLastError()); <br>        terminate(1); <br>    } <br>    if (ccb.uchDlcStatus) { <br>        printf("free_buffer(%#x): DLC returns %#.2x\n", buffer, ccb.uchDlcStatus); <br>        puts(MapCcbRetcode(ccb.uchDlcStatus)); <br>        terminate(1); <br>    } <br>    if (DisplayBufferFreeInfo) { <br>        printf("free_buffer(%x): %u buffers left\n", buffer, parms.cBuffersLeft); <br>    } <br>    if (parms.cBuffersLeft &lt; MinBuffersAvailable) { <br>        MinBuffersAvailable = parms.cBuffersLeft; <br>    } <br>    if (parms.cBuffersLeft &gt; MaxBuffersAvailable) { <br>        MaxBuffersAvailable = parms.cBuffersLeft; <br>    } <br>    return parms.cBuffersLeft; <br>} <br> <br>void post_receive() { <br> <br>    PLLC_CCB pccb; <br>    PLLC_RECEIVE_PARMS pparms; <br>    ACSLAN_STATUS status; <br> <br>    pccb = CALLOC(1, sizeof(*pccb)); <br>    pparms = CALLOC(1, sizeof(*pparms)); <br> <br>    pparms-&gt;usStationId = StationId; <br>    pparms-&gt;ulReceiveFlag = RECEIVE_DATA_FLAG; <br>    pparms-&gt;uchRcvReadOption = OptionChainReceiveData; <br> <br>    pccb-&gt;uchAdapterNumber = Adapter; <br>    pccb-&gt;uchDlcCommand = LLC_RECEIVE; <br>    pccb-&gt;ulCompletionFlag = RECEIVE_COMPLETE_FLAG; <br>    pccb-&gt;u.pParameterTable = (PLLC_PARMS)pparms; <br>pccb-&gt;uchReserved2 = bApplId; <br> <br> <br>    status = AcsLan(pccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("post_receive: AcsLan returns %d [%#.2x]\n", status, pccb-&gt;uchDlcStatus); <br>        terminate(1); <br>    } <br>    if (pccb-&gt;uchDlcStatus != 0xFF) { <br>        printf("post_receive: CCB.RETCODE = %#.2x\n", pccb-&gt;uchDlcStatus); <br>        puts(MapCcbRetcode(pccb-&gt;uchDlcStatus)); <br>        terminate(1); <br>    } <br>    if (Verbose) { <br>        printf("receive posted on station %04x\n", StationId); <br>    } <br>} <br> <br>PLLC_CCB post_read() { <br> <br>    PLLC_CCB pccb; <br>    PLLC_READ_PARMS pparms; <br>    ACSLAN_STATUS status; <br> <br>    pccb = CALLOC(1, sizeof(*pccb)); <br>    pparms = CALLOC(1, sizeof(*pparms)); <br> <br>    pparms-&gt;usStationId = StationId; <br>    pparms-&gt;uchOptionIndicator = 2; // retrieve ALL events for this app <br>    pparms-&gt;uchEventSet = 0x7f;     // interested in ALL possible events <br> <br>    <br> pccb-&gt;uchAdapterNumber = Adapter; <br>    pccb-&gt;uchDlcCommand = LLC_READ; <br>    pccb-&gt;u.pParameterTable = (PLLC_PARMS)pparms; <br>    pccb-&gt;hCompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL); <br>    if (!pccb-&gt;hCompletionEvent) { <br>        printf("post_read: CreateEvent returns %d\n", GetLastError()); <br>        terminate(1); <br>    } <br> <br>pccb-&gt;uchReserved2 = bApplId; <br> <br>    status = AcsLan(pccb, NULL); <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("post_read: AcsLan returns %d [%#.2x]\n", status, pccb-&gt;uchDlcStatus); <br>        terminate(1); <br>    } <br>    return pccb; <br>} <br> <br>void tx_i_frame() { <br> <br>    PLLC_CCB pccb; <br>    PLLC_TRANSMIT_PARMS pparms; <br>    ACSLAN_STATUS status; <br>    int data_size; <br>    PTEST_PACKET packet; <br> <br>    static DWORD PacketSequenceNumber = 0; <br> <br>    pccb = CALLOC(1, sizeof(*pccb)); <br>    pparms = CALLOC(1, sizeof(*pparms)); <br> <br>    data_size = TransmitDataLength <br>              ? TransmitDataLength <br>              : (rand() * 600) / RAND_MAX; <br>  // since this app does not specify max i-frame <br>  // 600 will be used by windows dlc32 as specified by <br>  // the ibm dlc specs -- johnlee <br>              //: (rand() * MaxFrameSize) / RAND_MAX; <br>    data_size = max(data_size, sizeof(TEST_PACKET)); <br> <br>    packet = (PTEST_PACKET)MALLOC(data_size); <br>    packet-&gt;sequence = PacketSequenceNumber++; <br>    packet-&gt;size = data_size; <br>    packet-&gt;signature = 0x11191962; <br> <br>    packet-&gt;checksum = slush(packet-&gt;data, data_size - sizeof(TEST_PACKET)); <br> <br>    pparms-&gt;usStationId = StationId; <br>    pparms-&gt;cbBuffer1 = data_size; <br>    pparms-&gt;pBuffer1 = packet; <br>    pparms-&gt;uchXmitReadOption = OptionChainTransmits; <br> <br>    pccb-&gt;uchAdapterNumber = Adapter; <br>    pccb-&gt;uchDlcCommand = LLC_TRANSMIT_I_FRAME; <br>    pccb-&gt;ulCompletionFlag = TRANSMIT_COMPLETE_FLAG; <br>    pccb-&gt;u.pParameterTable = (PLLC_PARMS)pparms; <br> <br>pccb-&gt;uchReserved2 = bApplId; <br> <br> <br>    status = AcsLan(pccb, NULL); <br> <br>    // <br>    // this may fail with 0x69 (or maybe 0xa1) if the system is out of MDL <br>    // resources. This can happen if we have a lot of completed transmits <br>    // waiting to be deallocated. In this case just deallocate resources and <br>    // return - do_transmit should spin removing completed transmits until we <br>    // can continue <br>    // <br> <br>    if (status != ACSLAN_STATUS_COMMAND_ACCEPTED) { <br>        printf("tx_i_frame: AcsLan returns %d [%#.2x]\n", <br>               status, <br>               pccb-&gt;uchDlcStatus <br>               ); <br>        puts(MapCcbRetcode(pccb-&gt;uchDlcStatus)); <br>        printf("AllocatedBytesOutstanding = %s [%#x]\n", <br>                nice_num(AllocatedBytesOutstanding), <br>                AllocatedBytesOutstanding <br>                ); <br>        printf("TotalBytesAllocated       = %s [%#x]\n", <br>                nice_num(TotalBytesAllocated) <br>                , TotalBytesAllocated <br>                ); <br>        printf("OutstandingTransmits      = %s\n", <br>                nice_num(OutstandingTransmits) <br>                ); <br>        printf("TotalTransmits            = %s\n", <br>                nice_num(TotalTransmits) <br>                ); <br>        printf("TotalTransmitCompletions  = %s\n", <br>                nice_num(TotalTransmitCompletions) <br>                ); <br>        printf("TransmitCompleteEvents    = %s\n", <br>                nice_num(TransmitCompleteEvents) <br>                ); <br>        if (DisplayCcb) { <br>            DUMPCCB(pccb, TRUE, FALSE); <br>        } <br>        FREE(packet); <br>        FREE(pparms); <br>        FREE(pccb); <br>        --PacketSequenceNumber; // didn't tx this sequence # <br>    } else { <br>        if (Verbose) { <br>            printf("tx_i_frame: transmitted %4d bytes\n", data_size); <br>        } <br>        ++OutstandingTransmits; <br>        ++TotalTransmits; <br>        TotalBytesTransmitted += (DWORD)data_size; <br>    } <br>} <br> <br>DWORD slush(char* buffer, int length) { <br> <br>    DWORD cs = 0; <br>    unsigned char ch; <br> <br>    while (length--) { <br>        ch = (unsigned char)(rand() &amp; 0xff); <br>        *buffer++ = ch; <br>        cs += (DWORD)ch; <br>    } <br>    return cs; <br>} <br> <br>void do_transmit() { <br> <br>    PLLC_CCB read_ccb; <br>    BOOL need_read = TRUE; <br>    BOOL wait_min = FALSE; <br> <br>    TxState = TX_STATE_OPENING; <br>    open_station(); <br>    if (Verbose) { <br>        printf("opened link station. StationId = %04x\n", StationId); <br>    } <br>    connect_station(StationId); <br>    TxState = TX_STATE_OPENED; <br>    if (Verbose) { <br>        printf("connected to remote\n"); <br>    } <br> <br>    while (1) { <br>        if (need_read) { <br>            read_ccb = post_read(); <br>            need_read = FALSE; <br>        } <br>        if (WaitForSingleObject(read_ccb-&gt;hCompletionEvent, 0) == WAIT_OBJECT_0) { <br>            dispatch_read_events(read_ccb); <br>            need_read = TRUE; <br>        } <br>        if (wait_min) { <br>            if (OutstandingTransmits &lt;= MIN_OUTSTANDING_TRANSMIT_THRESHOLD) { <br>                wait_min = FALSE; <br>            } <br>        } else if (OutstandingTransmits &gt; MAX_OUTSTANDING_TRANSMIT_THRESHOLD) { <br>            if (Verbose) { <br>                printf("do_transmit: not transmitting: outstanding transmits (%d) &gt; threshold (%d)\n", <br>                    OutstandingTransmits, MAX_OUTSTANDING_TRANSMIT_THRESHOLD); <br>            } <br>            wait_min = TRUE; <br>        } else if (RemoteBusy) { <br>            if (Verbose) { <br>                printf("do_transmit: not transmitting: remote busy\n"); <br>            } <br>            Sleep(100); <br>        } else { <br>            tx_i_frame(); <br>        } <br>        check_keyboard(); <br>    } <br>} <br> <br>void do_receive() { <br> <br>    PLLC_CCB read_ccb; <br>    DWORD waitStatus; <br> <br>    post_receive(); <br> <br>    RxState = RX_STATE_LISTENING; <br>    while (1) { <br>        read_ccb = post_read(); <br>        waitStatus = WaitForSingleObject(read_ccb-&gt;hCompletionEvent, INFINITE); <br>        if (waitStatus != WAIT_OBJECT_0) { <br>            printf("do_receive: WaitForSingleObject returns %d??\n", GetLastError()); <br>            continue; <br>        } <br>        dispatch_read_events(read_ccb); <br>        check_keyboard(); <br>    } <br>} <br> <br>void check_keyboard() { <br>    if (kbhit()) { <br>        switch (tolower(getch())) { <br>        case 'b':   // just the facts ma'am <br>            JustBufferInfo = !JustBufferInfo; <br>            if (JustBufferInfo) { <br>                Verbose = 0; <br>            } <br>            break; <br> <br>        case 'd': <br>            DisplayCcb = !DisplayCcb; <br>            break; <br> <br>        case 'f': <br>            DisplayFrameReceivedInfo = !DisplayFrameReceivedInfo; <br>            break; <br> <br>        case 'i': <br>            DisplayBufferFreeInfo = !DisplayBufferFreeInfo; <br>            break; <br> <br>        case 's':   // Stop &amp; Go <br>            while (tolower(getch()) != 'g') { <br>                putchar('\a'); <br>            } <br>            break; <br> <br>        case 't': <br>            DisplayTransmitInfo = !DisplayTransmitInfo; <br>            break; <br> <br>        case 'v':   // toggle Verbose <br>            Verbose = !Verbose; <br>            break; <br> <br>        case 'x':   // eXit <br>            terminate(0); <br> <br>        default: <br>            putchar('\a'); <br>        } <br>    } <br>} <br> <br>void dispatch_read_events(PLLC_CCB read_ccb) { <br> <br>    BYTE event; <br>    BYTE comb; <br> <br>    ++TotalReadsChecked; <br> <br>    if (read_ccb-&gt;uchDlcStatus == LLC_STATUS_SUCCESS) { <br>        event = ((PLLC_READ_PARMS)read_ccb-&gt;u.pParameterTable)-&gt;uchEvent; <br>        if (Verbose) { <br>            printf("dispatch_read_events: event %02x occurred: ", event); <br>        } <br>        for (comb = 0x80; comb; comb &gt;&gt;= 1) { <br>            if (event &amp; comb) { <br>                ++TotalReadEvents; <br>            } <br>            switch (event &amp; comb) { <br>            case 0x80: <br>                if (Verbose) { <br>                    printf("RESERVED - shouldn't happen??!!\n"); <br>                } <br>                break; <br> <br>            case 0x40: <br>                if (Verbose) { <br>                    printf("SYSTEM ACTION (non-critical)?\n"); <br>                } <br>                break; <br> <br>            case 0x20: <br>                if (Verbose) { <br>                    printf("NETWORK STATUS (non-critical)?\n"); <br>                } <br>                break; <br> <br>            case 0x10: <br>                if (Verbose) { <br>                    printf("CRITICAL EXCEPTION?\n"); <br>                } <br>                break; <br> <br>            case 0x08: <br>                if (Verbose) { <br>                    printf("DLC STATUS CHANGE\n"); <br>                } <br>                handle_status_change(read_ccb); <br>                break; <br> <br>            case 0x04: <br>                if (Verbose) { <br>                    printf("RECEIVED DATA\n"); <br>                } <br>                handle_receive_data(read_ccb); <br>                break; <br> <br>            case 0x02: <br>                if (Verbose) { <br>                    printf("TRANSMIT COMPLETION\n"); <br>                } <br>                handle_transmit_complete(read_ccb); <br>                break; <br> <br>            case 0x01: <br>                if (Verbose) { <br>                    printf("COMMAND COMPLETION\n"); <br>                } <br>                handle_command_complete(read_ccb); <br>                break; <br>            } <br>        } <br>    } else { <br>        printf("dispatch_read_events: read error %#.2x\n", read_ccb-&gt;uchDlcStatus); <br>    } <br>    FREE(read_ccb-&gt;u.pParameterTable); <br>    CloseHandle(read_ccb-&gt;hCompletionEvent); <br>    FREE(read_ccb); <br>} <br> <br>void handle_status_change(PLLC_CCB read_ccb) { <br> <br>    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)read_ccb-&gt;u.pParameterTable; <br>    USHORT status = parms-&gt;Type.Status.usDlcStatusCode; <br>    USHORT comb; <br>    BOOL lost_it = FALSE; <br> <br>    for (comb = 0x8000; comb; comb &gt;&gt;= 1) { <br>        if (status &amp; comb) { <br>            ++StatusChangeEvents; <br>        } <br>        switch (status &amp; comb) { <br>        case 0x8000: <br>            printf("LINK LOST\n"); <br>            lost_it = TRUE; <br>            ++LinkLostEvents; <br>            break; <br> <br>        case 0x4000: <br>            printf("DM/DISC received or DISC acked\n"); <br>            lost_it = TRUE; <br>            ++DiscEvents; <br>            break; <br> <br>        case 0x2000: <br>            printf("FRMR received\n"); <br>            lost_it = TRUE; <br>            ++FrmrReceivedEvents; <br>            break; <br> <br>        case 0x1000: <br>            printf("FRMR sent\n"); <br>            ++FrmrSentEvents; <br>            break; <br> <br>        case 0x0800: <br>            printf("SABME received on open LINK station\n"); <br>            ++SabmeResetEvents; <br>            break; <br> <br>        case 0x0400: <br>            memcpy(RemoteNode, parms-&gt;Type.Status.uchRemoteNodeAddress, 6); <br>            if (SwapAddressBits) { <br>                twiddle_bits(RemoteNode, 6); <br>            } <br>            printf("SABME received - new link %04x. RemoteNode = %02x-%02x-%02x-%02x-%02x-%02x\n", <br>                    parms-&gt;Type.Status.usStationId, <br>                    RemoteNode[0] &amp; 0xff, <br>                    RemoteNode[1] &amp; 0xff, <br>                    RemoteNode[2] &amp; 0xff, <br>                    RemoteNode[3] &amp; 0xff, <br>                    RemoteNode[4] &amp; 0xff, <br>                    RemoteNode[5] &amp; 0xff <br>                    ); <br>            if (Mode == RECEIVE_MODE) { <br>                connect_station(parms-&gt;Type.Status.usStationId); <br>                RxState = RX_STATE_RECEIVING; <br>            } else { <br>                printf(" - ON TRANSMITTING SIDE????\n"); <br>            } <br>            ++SabmeOpenEvents; <br>            break; <br> <br>        case 0x0200: <br>            printf("REMOTE BUSY\n"); <br>            RemoteBusy = 1; <br>            ++RemoteBusyEnteredEvents; <br>            break; <br> <br>        case 0x0100: <br>            printf("REMOTE BUSY CLEARED\n"); <br>            RemoteBusy = 0; <br>            ++RemoteBusyLeftEvents; <br>            break; <br> <br>        case 0x0080: <br>            printf("Ti EXPIRED\n"); <br>            ++TiExpiredEvents; <br>            break; <br> <br>        case 0x0040: <br>            printf("DLC counter overflow\n"); <br>            ++DlcCounterOverflowEvents; <br>            break; <br> <br>        case 0x0020: <br>            printf("Access priority lowered (on ethernet????!)\n"); <br>            ++AccessPriorityLoweredEvents; <br>            break; <br> <br>        case 0x0010: <br>        case 0x0008: <br>        case 0x0004: <br>        case 0x0002: <br>            printf("\aThis status code (%04x) should be reserved!\n", status &amp; comb); <br>            ++InvalidStatusChangeEvents; <br>            break; <br> <br>        case 0x0001: { <br> <br>            int bufs_avail; <br> <br>            LocalBusy = 1; <br>            flow_control(parms-&gt;Type.Status.usStationId); <br>            ++LocalBusyEvents; <br>            bufs_avail = free_buffer(get_buffer()); <br>            printf("LOCAL BUSY: %d buffers left\n", bufs_avail); <br>            if (bufs_avail) { <br>                LocalBusy = 0; <br>                printf("LOCAL BUSY CLEARED\n"); <br>            } <br>            break; <br>        } <br>        } <br>    } <br>    if (lost_it) { <br>        printf("lost it - quitting\n"); <br>        terminate(1); <br>    } <br>} <br> <br>void handle_receive_data(PLLC_CCB read_ccb) { <br> <br>    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)read_ccb-&gt;u.pParameterTable; <br>    DWORD i; <br>    PLLC_BUFFER rx_frame; <br>    PLLC_BUFFER next_frame; <br>    DWORD nframes; <br>    DWORD bufs_left; <br>    PLLC_BUFFER pbuf; <br> <br>    ++ReceiveDataEvents; <br> <br>    nframes = parms-&gt;Type.Event.usReceivedFrameCount; <br>    if (nframes &gt; MaxChainedReceives) { <br>        MaxChainedReceives = nframes; <br>    } <br>    rx_frame = parms-&gt;Type.Event.pReceivedFrame; <br>    bufs_left = rx_frame-&gt;NotContiguous.cBuffersLeft; <br>    if (bufs_left &lt; MinBuffersAvailable) { <br>        MinBuffersAvailable = bufs_left; <br>    } <br>    if (bufs_left &gt; MaxBuffersAvailable) { <br>        MaxBuffersAvailable = bufs_left; <br>    } <br>    if (DisplayFrameReceivedInfo) { <br>        printf("handle_receive_data: %d frames received, %d buffers left\n", <br>            nframes, <br>            bufs_left <br>            ); <br>    } <br>    for (i = 0; i &lt; nframes; ++i) { <br>        ++DataFramesReceived; <br>        next_frame = rx_frame-&gt;NotContiguous.pNextFrame; <br>        if (!JustBufferInfo) { <br>            printf("Packet Sequence %08x  # bytes = %4d  %d buffers left\n", <br>                ((PTEST_PACKET)&amp;rx_frame-&gt;NotCont.auchData)-&gt;sequence, <br>                ((PTEST_PACKET)&amp;rx_frame-&gt;NotCont.auchData)-&gt;size, <br>                rx_frame-&gt;NotContiguous.cBuffersLeft <br>                ); <br>        } <br>        TotalDlcBytesReceived += rx_frame-&gt;Next.cbFrame; <br>        TotalPacketBytesReceived += ((PTEST_PACKET)&amp;rx_frame-&gt;NotCont.auchData)-&gt;size; <br>        for (pbuf = rx_frame; pbuf; pbuf = pbuf-&gt;pNext) { <br>            ++DlcBuffersReceived; <br>        } <br>        free_buffer(rx_frame); <br>        ++DlcBuffersFreed; <br>        if (!next_frame &amp;&amp; i != nframes - 1) { <br>            printf("handle_receive_data: unexpected NULL pointer terminates list @ %d\n", i); <br>            break; <br>        } <br>        rx_frame = next_frame; <br>    } <br>} <br> <br>void handle_transmit_complete(PLLC_CCB read_ccb) { <br> <br>    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)read_ccb-&gt;u.pParameterTable; <br>    DWORD i; <br>    PLLC_CCB tx_ccb; <br>    PLLC_CCB next_ccb; <br>    DWORD nframes; <br>    DWORD txlen; <br> <br>    ++TransmitCompleteEvents; <br> <br>    nframes = parms-&gt;Type.Event.usCcbCount; <br>    if (nframes &gt; MaxChainedTransmits) { <br>        MaxChainedTransmits = nframes; <br>    } <br>    if (Verbose || DisplayTransmitInfo) { <br>        printf("handle_transmit_complete: %d transmits completed\n", nframes); <br>    } <br>    tx_ccb = parms-&gt;Type.Event.pCcbCompletionList; <br>    for (i = 0; i &lt; nframes; ++i) { <br>        next_ccb = tx_ccb-&gt;pNext; <br>        txlen = ((PLLC_TRANSMIT_PARMS)tx_ccb-&gt;u.pParameterTable)-&gt;cbBuffer1; <br>        TotalTxBytesCompleted += txlen; <br>        if (tx_ccb-&gt;uchDlcStatus) { <br>            printf("\ahandle_transmit_complete: TX CCB %08x error %#.2x\n", <br>                tx_ccb, tx_ccb-&gt;uchDlcStatus); <br>            if (tx_ccb-&gt;uchDlcStatus == LLC_STATUS_INVALID_FRAME_LENGTH) { <br>                printf("data length = %d\n", txlen); <br>            } <br>        } <br>        FREE(((PLLC_TRANSMIT_PARMS)tx_ccb-&gt;u.pParameterTable)-&gt;pBuffer1); <br>        FREE(tx_ccb-&gt;u.pParameterTable); <br>        FREE(tx_ccb); <br>        --OutstandingTransmits; <br>        if (OutstandingTransmits &lt; 0) { <br>            printf("handle_transmit_complete: more transmit completions than transmits (%d)\n", <br>                OutstandingTransmits); <br>        } <br>        ++TotalTransmitCompletions; <br>        tx_ccb = next_ccb; <br>        if (!next_ccb &amp;&amp; i != nframes - 1) { <br>            printf("handle_transmit_complete: unexpected NULL pointer terminates list @ %d\n", i); <br>            break; <br>        } <br>    } <br>} <br> <br>void handle_command_complete(PLLC_CCB read_ccb) { <br> <br>    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)read_ccb-&gt;u.pParameterTable; <br> <br>    ++CommandCompleteEvents; <br> <br>    printf("handle_command_complete: %d CCBs, %d buffers, %d received frames\n", <br>        parms-&gt;Type.Event.usCcbCount, <br>        parms-&gt;Type.Event.usBufferCount, <br>        parms-&gt;Type.Event.usReceivedFrameCount <br>        ); <br>} <br> <br>void twiddle_bits(LPBYTE buffer, DWORD length) { <br> <br>    while (length--) { <br>        *buffer = swap_bits(*buffer); <br>        ++buffer; <br>    } <br>} <br> <br>unsigned char swap_bits(unsigned char b) { <br> <br>    unsigned char bb = 0; <br>    unsigned char mask; <br> <br>    for (mask = 1; mask; mask &lt;&lt;= 1) { <br>        bb &lt;&lt;= 1; <br>        bb |= ((b &amp; mask) ? 1 : 0); <br>    } <br>    return bb; <br>} <br> <br>void* my_malloc(int size) { <br> <br>    void* ptr; <br> <br>    size += 2 * sizeof(DWORD); <br>    ptr = malloc(size); <br>    if (ptr) { <br>        *((LPDWORD)ptr)++ = (DWORD)size; <br>        *((LPDWORD)ptr)++ = 0xcec171a2; <br>        AllocatedBytesOutstanding += (LONG)size; <br>        if (AllocatedBytesOutstanding &lt; 0) { <br>            printf("my_malloc: alloc overflow? AllocatedBytesOutstanding=%x\n", AllocatedBytesOutstanding); <br>        } <br>        TotalBytesAllocated += (DWORD)size; <br>    } <br>    return ptr; <br>} <br> <br>void* my_calloc(int num, int size) { <br> <br>    void* ptr; <br> <br>    size = (num * size) + 2 * sizeof(DWORD); <br>    ptr = calloc(1, size); <br>    if (ptr) { <br>        *((LPDWORD)ptr)++ = (DWORD)size; <br>        *((LPDWORD)ptr)++ = 0xcec171a2; <br>        AllocatedBytesOutstanding += (LONG)size; <br>        if (AllocatedBytesOutstanding &lt; 0) { <br>            printf("my_calloc: alloc overflow? AllocatedBytesOutstanding=%x\n", AllocatedBytesOutstanding); <br>        } <br>        TotalBytesAllocated += (DWORD)size; <br>    } <br>    return ptr; <br>} <br> <br>void my_free(void* ptr) { <br> <br>    DWORD size; <br> <br>    ((LPDWORD)ptr) -= 2; <br>    size = ((LPDWORD)ptr)[0]; <br> <br>    if (((LPDWORD)ptr)[1] != 0xcec171a2) { <br>        printf("\amy_free: bad block %x?\n", ptr); <br>    } else { <br>        AllocatedBytesOutstanding -= size; <br>        if (AllocatedBytesOutstanding &lt; 0) { <br>            printf("my_free: free underflow? AllocatedBytesOutstanding=%x\n", AllocatedBytesOutstanding); <br>        } <br>        free(ptr); <br>        TotalBytesFreed += (DWORD)size; <br>    } <br>} <br> <br>char* nice_num(unsigned long number) { <br> <br>    int fwidth = 0; <br>    int i; <br>    static char buffer[32]; <br>    char* buf = buffer; <br> <br>    if (!number) { <br>        if (!fwidth) { <br>            buf[0] = '0'; <br>            buf[1] = 0; <br>        } else { <br>            memset(buf, ' ', fwidth); <br>            buf[fwidth-1] = '0'; <br>            buf[fwidth] = 0; <br>        } <br>    } else { <br>        if (!fwidth) { <br> <br>            ULONG n = number; <br> <br>            ++fwidth; <br>            for (i = 10; i &lt;= 1000000000; i *= 10) { <br>                if (n/i) { <br>                    ++fwidth; <br>                } else { <br>                    break; <br>                } <br>            } <br>            fwidth += (fwidth / 3) - (((fwidth % 3) == 0) ? 1 : 0); <br>        } <br>        buf[fwidth] = 0; <br>        buf += fwidth; <br>        i=0; <br>        while (number &amp;&amp; fwidth) { <br>            *--buf = (char)((number%10)+'0'); <br>            --fwidth; <br>            number /= 10; <br>            if (++i == 3 &amp;&amp; fwidth) { <br>                if (number) { <br>                    *--buf = ','; <br>                    --fwidth; <br>                    i=0; <br>                } <br>            } <br>        } <br>        while (fwidth--) *--buf = ' '; <br>    } <br>    return buf; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
