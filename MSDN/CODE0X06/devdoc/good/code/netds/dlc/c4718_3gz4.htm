<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLCDEBUG.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4720"></a>DLCDEBUG.C</h2>
<pre><code>/*++ <br> <br>Copyright 1991-1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    dlcdebug.c <br> <br>Abstract: <br> <br>    CCB dump routines for NT-level CCB <br> <br>    Contents: <br>        GetAcslanDebugFlags <br>        SetAcslanDebugFlags <br>        AcslanDebugPrint <br>        AcslanDebugPrintString <br>        DumpCcb <br>        MapCcbRetcode <br>        DumpData <br>        (DefaultParameterTableDump) <br>        (DumpParameterTableHeader) <br>        (DumpBufferCreateParms) <br>        (DumpBufferFreeParms) <br>        (DumpBufferGetParms) <br>        (DumpDirInitializeParms) <br>        (DumpDirOpenAdapterParms) <br>        (MapEthernetType) <br>        (DumpDirOpenDirectParms) <br>        (DumpDirReadLogParms) <br>        (MapLogType) <br>        (DumpDirSetExceptionFlagsParms) <br>        (DumpDirSetFunctionalAddressParms) <br>        (DumpDirSetGroupAddressParms) <br>        (DumpDirStatusParms) <br>        (MapAdapterType) <br>        (DumpDirTimerCancelParms) <br>        (DumpDirTimerCancelGroupParms) <br>        (DumpDirTimerSetParms) <br>        (DumpDlcCloseSapParms) <br>        (DumpDlcCloseStationParms) <br>        (DumpDlcConnectStationParms) <br>        (DumpDlcFlowControlParms) <br>        (MapFlowControl) <br>        (DumpDlcModifyParms) <br>        (DumpDlcOpenSapParms) <br>        (DumpDlcOpenStationParms) <br>        (DumpDlcReallocateParms) <br>        (DumpDlcResetParms) <br>        (DumpDlcSetThresholdParms) <br>        (DumpDlcStatisticsParms) <br>        (DumpReadParms) <br>        (MapOptionIndicator) <br>        (MapReadEvent) <br>        (MapDlcStatus) <br>        (DumpReadCancelParms) <br>        (DumpReceiveParms) <br>        (MapRcvReadOption) <br>        (MapReceiveOptions) <br>        (DumpReceiveCancelParms) <br>        (DumpReceiveModifyParms) <br>        (DumpTransmitDirFrameParms) <br>        (DumpTransmitIFrameParms) <br>        (DumpTransmitTestCmdParms) <br>        (DumpTransmitUiFrameParms) <br>        (DumpTransmitXidCmdParms) <br>        (DumpTransmitXidRespFinalParms) <br>        (DumpTransmitXidRespNotFinalParms) <br>        (DumpTransmitFramesParms) <br>        (DumpTransmitParms) <br>        (DumpTransmitQueue) <br>        DumpReceiveDataBuffer <br>        (MapMessageType) <br> <br>Author: <br> <br>    Richard L Firth (rfirth) 28-May-1992 <br> <br>Revision History: <br> <br>--*/ <br> <br>#if DBG <br> <br>// #include &lt;nt.h&gt; <br>// #include &lt;ntrtl.h&gt;      // ASSERT, DbgPrint <br>// #include &lt;nturtl.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;dlcapi.h&gt;     // Official DLC API definition <br>#include "dlcdebug.h" <br> <br>// <br>// defines <br>// <br> <br>#define DBGDBG  0 <br>#define MyDbgPrint  puts <br> <br>// <br>// macros <br>// <br> <br>// <br>// HEX_TO_NUM - converts an ASCII hex character (0-9A-Fa-f) to corresponding <br>// number (0-15). Assumes c is hexadecimal digit on input <br>// <br> <br>#define HEX_TO_NUM(c)   ((c) - ('0' + (((c) &lt;= '9') ? 0 : ((islower(c) ? 'a' : 'A') - ('9' + 1))))) <br> <br>// <br>// local prototypes <br>// <br> <br>VOID <br>AcslanDebugPrintString( <br>    IN LPSTR String <br>    ); <br> <br>PRIVATE <br>VOID <br>DefaultParameterTableDump( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpParameterTableHeader( <br>    IN LPSTR CommandName, <br>    IN PVOID Table <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpBufferCreateParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpBufferFreeParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpBufferGetParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirInitializeParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirOpenAdapterParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapEthernetType( <br>    IN LLC_ETHERNET_TYPE EthernetType <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirOpenDirectParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirReadLogParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapLogType( <br>    IN USHORT Type <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirSetExceptionFlagsParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirSetFunctionalAddressParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirSetGroupAddressParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirStatusParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapAdapterType( <br>    IN USHORT AdapterType <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirTimerCancelParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirTimerCancelGroupParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDirTimerSetParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcCloseSapParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcCloseStationParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcConnectStationParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcFlowControlParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapFlowControl( <br>    IN BYTE FlowControl <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcModifyParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcOpenSapParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcOpenStationParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcReallocateParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcResetParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcSetThresholdParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpDlcStatisticsParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpReadParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapOptionIndicator( <br>    IN UCHAR OptionIndicator <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapReadEvent( <br>    UCHAR Event <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapDlcStatus( <br>    WORD Status <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpReadCancelParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpReceiveParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapReceiveOptions( <br>    IN UCHAR Options <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapRcvReadOption( <br>    IN UCHAR Option <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpReceiveCancelParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpReceiveModifyParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitDirFrameParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitIFrameParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitTestCmdParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitUiFrameParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitXidCmdParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitXidRespFinalParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitXidRespNotFinalParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitFramesParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitParms( <br>    IN PVOID Parameters <br>    ); <br> <br>PRIVATE <br>VOID <br>DumpTransmitQueue( <br>    IN PLLC_XMIT_BUFFER Buffer <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapXmitReadOption( <br>    IN UCHAR Option <br>    ); <br> <br>VOID <br>DumpReceiveDataBuffer( <br>    IN PVOID Buffer <br>    ); <br> <br>PRIVATE <br>LPSTR <br>MapMessageType( <br>    UCHAR MessageType <br>    ); <br> <br>// <br>// explanations of error codes returned in CCB_RETCODE fields. Explanations <br>// taken more-or-less verbatim from IBM Local Area Network Technical Reference <br>// table B-1 ppB-2 to B-5. Includes all errors <br>// <br> <br>static LPSTR CcbRetcodeExplanations[] = { <br>    "Success", <br>    "Invalid command code", <br>    "Duplicate command, one already outstanding", <br>    "Adapter open, should be closed", <br>    "Adapter closed, should be open", <br>    "Required parameter missing", <br>    "Invalid/incompatible option", <br>    "Command cancelled - unrecoverable failure", <br>    "Unauthorized access priority", <br>    "Adapter not initialized, should be", <br>    "Command cancelled by user request", <br>    "Command cancelled, adapter closed while command in progress", <br>    "Command completed Ok, adapter not open", <br>    "Invalid error code 0x0D", <br>    "Invalid error code 0x0E", <br>    "Invalid error code 0x0F", <br>    "Adapter open, NetBIOS not operational", <br>    "Error in DIR.TIMER.SET or DIR.TIMER.CANCEL", <br>    "Available work area exceeded", <br>    "Invalid LOG.ID", <br>    "Invalid shared RAM segment or size", <br>    "Lost log data, buffer too small, log reset", <br>    "Requested buffer size exceeds pool length", <br>    "Command invalid, NetBIOS operational", <br>    "Invalid SAP buffer length", <br>    "Inadequate buffers available for request", <br>    "USER_LENGTH value too large for buffer length", <br>    "The CCB_PARM_TAB pointer is invalid", <br>    "A pointer in the CCB parameter table is invalid", <br>    "Invalid CCB_ADAPTER value", <br>    "Invalid functional address", <br>    "Invalid error code 0x1F", <br>    "Lost data on receive, no buffers available", <br>    "Lost data on receive, inadequate buffer space", <br>    "Error on frame transmission, check TRANSMIT.FS data", <br>    "Error on frame transmit or strip process", <br>    "Unauthorized MAC frame", <br>    "Maximum commands exceeded", <br>    "Unrecognized command correlator", <br>    "Link not transmitting I frames, state changed from link opened", <br>    "Invalid transmit frame length", <br>    "Invalid error code 0x29", <br>    "Invalid error code 0x2a", <br>    "Invalid error code 0x2b", <br>    "Invalid error code 0x2c", <br>    "Invalid error code 0x2d", <br>    "Invalid error code 0x2e", <br>    "Invalid error code 0x2f", <br>    "Inadequate receive buffers for adapter to open", <br>    "Invalid error code 0x31", <br>    "Invalid NODE_ADDRESS", <br>    "Invalid adapter receive buffer length defined", <br>    "Invalid adapter transmit buffer length defined", <br>    "Invalid error code 0x35", <br>    "Invalid error code 0x36", <br>    "Invalid error code 0x37", <br>    "Invalid error code 0x38", <br>    "Invalid error code 0x39", <br>    "Invalid error code 0x3a", <br>    "Invalid error code 0x3b", <br>    "Invalid error code 0x3c", <br>    "Invalid error code 0x3d", <br>    "Invalid error code 0x3e", <br>    "Invalid error code 0x3f", <br>    "Invalid STATION_ID", <br>    "Protocol error, link in invalid state for command", <br>    "Parameter exceeded maximum allowed", <br>    "Invalid SAP value or value already in use", <br>    "Invalid routing information field", <br>    "Requested group membership in non-existent group SAP", <br>    "Resources not available", <br>    "Sap cannot close unless all link stations are closed", <br>    "Group SAP cannot close, individual SAPs not closed", <br>    "Group SAP has reached maximum membership", <br>    "Sequence error, incompatible command in progress", <br>    "Station closed without remote acknowledgement", <br>    "Sequence error, cannot close, DLC commands outstanding", <br>    "Unsuccessful link station connection attempted", <br>    "Member SAP not found in group SAP list", <br>    "Invalid remote address, may not be a group address", <br>    "Invalid pointer in CCB_POINTER field", <br>    "Invalid error code 0x51", <br>    "Invalid application program ID", <br>    "Invalid application program key code", <br>    "Invalid system key code", <br>    "Buffer is smaller than buffer size given in DLC.OPEN.SAP", <br>    "Adapter's system process is not installed", <br>    "Inadequate stations available", <br>    "Invalid CCB_PARAMETER_1 parameter", <br>    "Inadequate queue elements to satisfy request", <br>    "Initialization failure, cannot open adapter", <br>    "Error detected in chained READ command", <br>    "Direct stations not assigned to application program", <br>    "Dd interface not installed", <br>    "Requested adapter is not installed", <br>    "Chained CCBs must all be for same adapter", <br>    "Adapter initializing, command not accepted", <br>    "Number of allowed application programs has been exceeded", <br>    "Command cancelled by system action", <br>    "Direct stations not available", <br>    "Invalid DDNAME parameter", <br>    "Inadequate GDT selectors to satisfy request", <br>    "Invalid error code 0x66", <br>    "Command cancelled, CCB resources purged", <br>    "Application program ID not valid for interface", <br>    "Segment associated with request cannot be locked", <br>    "Invalid error code 0x6a", <br>    "Invalid error code 0x6b", <br>    "Invalid error code 0x6c", <br>    "Invalid error code 0x6d", <br>    "Invalid error code 0x6e", <br>    "Invalid error code 0x6f", <br>    "Invalid error code 0x70", <br>    "Invalid error code 0x71", <br>    "Invalid error code 0x72", <br>    "Invalid error code 0x73", <br>    "Invalid error code 0x74", <br>    "Invalid error code 0x75", <br>    "Invalid error code 0x76", <br>    "Invalid error code 0x77", <br>    "Invalid error code 0x78", <br>    "Invalid error code 0x79", <br>    "Invalid error code 0x7a", <br>    "Invalid error code 0x7b", <br>    "Invalid error code 0x7c", <br>    "Invalid error code 0x7d", <br>    "Invalid error code 0x7e", <br>    "Invalid error code 0x7f", <br>    "Invalid buffer address", <br>    "Buffer already released", <br>    "Invalid error code 0x82", <br>    "Invalid error code 0x83", <br>    "Invalid error code 0x84", <br>    "Invalid error code 0x85", <br>    "Invalid error code 0x86", <br>    "Invalid error code 0x87", <br>    "Invalid error code 0x88", <br>    "Invalid error code 0x89", <br>    "Invalid error code 0x8a", <br>    "Invalid error code 0x8b", <br>    "Invalid error code 0x8c", <br>    "Invalid error code 0x8d", <br>    "Invalid error code 0x8e", <br>    "Invalid error code 0x8f", <br>    "Invalid error code 0x90", <br>    "Invalid error code 0x91", <br>    "Invalid error code 0x92", <br>    "Invalid error code 0x93", <br>    "Invalid error code 0x94", <br>    "Invalid error code 0x95", <br>    "Invalid error code 0x96", <br>    "Invalid error code 0x97", <br>    "Invalid error code 0x98", <br>    "Invalid error code 0x99", <br>    "Invalid error code 0x9a", <br>    "Invalid error code 0x9b", <br>    "Invalid error code 0x9c", <br>    "Invalid error code 0x9d", <br>    "Invalid error code 0x9e", <br>    "Invalid error code 0x9f", <br>    "BIND error", <br>    "Invalid version", <br>    "NT Error status" <br>}; <br> <br>#define NUMBER_OF_ERROR_MESSAGES    ARRAY_ELEMENTS(CcbRetcodeExplanations) <br>#define LAST_DLC_ERROR_CODE         LAST_ELEMENT(CcbRetcodeExplanations) <br> <br>// <br>// preset the debug flags to nothing, or to whatever is defined at compile-time <br>// <br> <br>DWORD   AcslanDebugFlags = ACSLAN_DEBUG_FLAGS; <br>FILE*   hDumpFile = NULL; <br>BYTE    AcslanDumpCcb[LLC_MAX_DLC_COMMAND]; <br>BOOL    HaveCcbFilter = FALSE; <br> <br>VOID <br>GetAcslanDebugFlags( <br>    VOID <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine is called whenever we have a DLL_PROCESS_ATTACH to the DLL <br> <br>    checks if there is an environment variable called ACSLAN_DEBUG_FLAGS, and <br>    loads whatever it finds (as a 32-bit hex number) into AcslanDebugFlags <br> <br>    checks if there is an environment variable called ACSLAN_DUMP_FILE. If <br>    there is, then output which otherwise would have gone to the terminal <br>    goes to the file. The file is opened in "w" mode by default - open for <br>    write. Current file is destroyed if it exists <br> <br>    If there is an environment variable called ACSLAN_DUMP_FILTER then this is <br>    loaded into the AcslanDumpCcb array. This is a string of numbers, the <br>    position of which corresponds to the CCB command. For each position, 1 <br>    means dump the CCB and 2 means dump the CCB and its parameters. This is an <br>    additional filter control over that contained in ACSLAN_DEBUG_FLAGS which <br>    allows control on a per CCB basis. Example: <br> <br>        ACSLAN_DUMP_CCB=1x0221 <br> <br>    means: <br> <br>        for CCB 0 (DIR.INTERRUPT) dump the CCB only (no parameter table anyway) <br>                1 (???) don't do anything (x==0) <br>                2 (???) don't do anything (x==0) <br>                3 (DIR.OPEN.ADAPTER) dump the CCB and parameter table <br>                4 (DIR.CLOSE.ADAPTER) dump the CCB and parameter table <br>                    (no parameter table, doesn't matter) <br>                5 (DIR.SET.MULTICAST.ADDRESS) dump the CCB <br> <br>    etc. We currently recognize up to CCB command 0x36 (54, PURGE.RESOURCES) <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    LPSTR envVar; <br>    SYSTEMTIME systemTime; <br> <br>    if (envVar = getenv(ACSLAN_DEBUG_ENV_VAR)) { <br>        if (!strnicmp(envVar, "0x", 2)) { <br>            envVar += 2; <br>        } <br>        for (AcslanDebugFlags = 0; isxdigit(*envVar); ++envVar) { <br>            AcslanDebugFlags = AcslanDebugFlags * 16 + HEX_TO_NUM(*envVar); <br>//                + (*envVar <br>//                    - ('0' + ((*envVar &lt;= '9') ? 0 <br>//                        : ((islower(*envVar) ? 'a' : 'A') - ('9' + 1))))); <br>        } <br>    } <br> <br>    if (envVar = getenv(ACSLAN_DUMP_FILE_VAR)) { <br> <br>        char* comma; <br>        static char openMode[3] = "w"; <br> <br>        if (comma = strchr(envVar, ',')) { <br>            strcpy(openMode, comma+1); <br>            *comma = 0; <br>        } <br>        if ((hDumpFile = fopen(envVar, openMode)) == NULL) { <br>            MyDbgPrint("Error: can't create dump file\n"); <br>        } else { <br>            AcslanDebugFlags |= DEBUG_TO_FILE; <br>            AcslanDebugFlags &amp;= ~DEBUG_TO_TERMINAL; <br>        } <br>    } <br> <br> <br>#if DBGDBG <br>    IF_DEBUG(DLL_INFO) { <br>        PUT(("GetAcslanDebugFlags: AcslanDebugFlags = %#x\n", AcslanDebugFlags)); <br>    } <br>#endif <br> <br>    if (envVar = getenv(ACSLAN_DUMP_FILTER_VAR)) { <br> <br>        int i, len; <br>        BYTE ch; <br> <br>        if (strlen(envVar) &gt; sizeof(AcslanDumpCcb) - 1) { <br> <br>            // <br>            // if there's too much info then inform the debugger but set up the <br>            // string anyway <br>            // <br> <br>            PUT(("GetAcslanDebugFlags: Error: ACSLAN_DUMP_CCB variable too long: \"%s\"\n", envVar)); <br>            strncpy(AcslanDumpCcb, envVar, sizeof(AcslanDumpCcb) - 1); <br>            AcslanDumpCcb[sizeof(AcslanDumpCcb) - 1] = 0; <br>        } else { <br>            strcpy(AcslanDumpCcb, envVar); <br>        } <br> <br>#if DBGDBG <br>        IF_DEBUG(DLL_INFO) { <br>            PUT(("GetAcslanDebugFlags: AcslanDumpCcb = %s\n", AcslanDumpCcb)); <br>        } <br>#endif <br> <br>        // <br>        // if there are less characters in the string than CCB commands then <br>        // default the rest of the commands <br>        // <br> <br>        len = strlen(AcslanDumpCcb); <br>        for (i = len; i &lt; sizeof(AcslanDumpCcb); ++i) { <br>            AcslanDumpCcb[i] = 0xff; <br>        } <br>        AcslanDumpCcb[i] = 0; <br> <br>        // <br>        // convert the ASCII characters to numbers <br>        // <br> <br>        for (i = 0; i &lt; len; ++i) { <br>            ch = AcslanDumpCcb[i]; <br>            if (isxdigit(ch)) { <br>                ch = HEX_TO_NUM(ch); <br>            } else { <br>                ch = (BYTE)0xff; <br>            } <br>            AcslanDumpCcb[i] = ch; <br> <br>#if DBGDBG <br>            PUT(("Command %d: filter=%02x\n", i, ch)); <br>#endif <br> <br>        } <br> <br>        HaveCcbFilter = TRUE; <br>    } <br> <br>    IF_DEBUG(DLL_INFO) { <br>        GetSystemTime(&amp;systemTime); <br>        PUT(("PROCESS STARTED @ %02d:%02d:%02d\n", <br>            systemTime.wHour, systemTime.wMinute, systemTime.wSecond <br>            )); <br>    } <br>} <br> <br>VOID <br>SetAcslanDebugFlags( <br>    IN DWORD Flags <br>    ) <br>{ <br>    AcslanDebugFlags = Flags; <br>} <br> <br>VOID <br>AcslanDebugPrint( <br>    IN LPSTR Format, <br>    IN ... <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Print the debug information to the terminal or debug terminal, depending <br>    on DEBUG_TO_TERMINAL flag (0x80000000) <br> <br>Arguments: <br> <br>    Format  - printf/DbgPrint style format string (ANSI) <br>    ...     - optional parameters <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    char printBuffer[1024]; <br>    va_list list; <br> <br>    va_start(list, Format); <br>    vsprintf(printBuffer, Format, list); <br> <br>    IF_DEBUG(TO_FILE) { <br>        fputs(printBuffer, hDumpFile); <br>    } else IF_DEBUG(TO_TERMINAL) { <br>        printf(printBuffer); <br>    } else { <br>        MyDbgPrint(printBuffer); <br>    } <br>} <br> <br>VOID <br>AcslanDebugPrintString( <br>    IN LPSTR String <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Print the debug information to the terminal or debug terminal, depending <br>    on DEBUG_TO_TERMINAL flag (0x80000000) <br> <br>Arguments: <br> <br>    String  - formatted string (ANSI) <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    IF_DEBUG(TO_FILE) { <br>        fputs(String, hDumpFile); <br>    } else IF_DEBUG(TO_TERMINAL) { <br>        printf(String); <br>    } else { <br>        MyDbgPrint(String); <br>    } <br>} <br> <br>VOID <br>DumpCcb( <br>    IN PLLC_CCB Ccb, <br>    IN BOOL DumpAll, <br>    IN BOOL CcbIsInput <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Dumps a CCB and any associated parameter table. Also displays the symbolic <br>    CCB command and an error code description if the CCB is being returned to <br>    the caller. Dumps NT format CCBs (flat 32-bit pointers) <br> <br>Arguments: <br> <br>    Ccb         - flat 32-bit pointer to CCB2 to dump <br>    DumpAll     - if TRUE, dumps parameter tables and buffers, else just CCB <br>    CcbIsInput  - if TRUE, CCB is from user: don't display error code explanation <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    LPSTR   cmdname = "UNKNOWN CCB!"; <br>    BOOL    haveParms = FALSE; <br>    VOID    (*DumpParms)(PVOID) = DefaultParameterTableDump; <br>    PVOID   parameterTable = NULL; <br>    BOOL    parmsInCcb = FALSE; <br>    BYTE    command; <br>    DWORD   numberOfTicks; <br>    BOOL    ccbIsBad = FALSE; <br>    BOOL    dumpInputParms = TRUE; <br>    BOOL    dumpOutputParms = TRUE; <br> <br>    static DWORD LastTicks; <br>    static BOOL FirstTimeFunctionCalled = TRUE; <br> <br>    try { <br>        command = Ccb-&gt;uchDlcCommand; <br>    } except(1) { <br>        ccbIsBad = TRUE; <br>    } <br> <br>    // <br>    // bomb out if we get a bad CCB address <br>    // <br> <br>    if (ccbIsBad) { <br>        PUT(("*** Error: Bad Address for CCB @ %08x ***\n", Ccb)); <br>        return; <br>    } <br> <br>#if DBGDBG <br>    PUT(("DumpCcb(%x, %d, %d)\n", Ccb, DumpAll, CcbIsInput)); <br>#endif <br> <br>    IF_DEBUG(DUMP_TIME) { <br> <br>        DWORD ticksNow = GetTickCount(); <br> <br>        if (FirstTimeFunctionCalled) { <br>            numberOfTicks = 0; <br>            FirstTimeFunctionCalled = FALSE; <br>        } else { <br>            numberOfTicks = ticksNow - LastTicks; <br>        } <br>        LastTicks = ticksNow; <br>    } <br> <br>    switch (command) { <br>    case LLC_BUFFER_CREATE: <br>        cmdname = "BUFFER.CREATE"; <br>        haveParms = TRUE; <br>        DumpParms = DumpBufferCreateParms; <br>        break; <br> <br>    case LLC_BUFFER_FREE: <br>        cmdname = "BUFFER.FREE"; <br>        haveParms = TRUE; <br>        DumpParms = DumpBufferFreeParms; <br>        break; <br> <br>    case LLC_BUFFER_GET: <br>        cmdname = "BUFFER.GET"; <br>        haveParms = TRUE; <br>        DumpParms = DumpBufferGetParms; <br>        break; <br> <br>    case LLC_DIR_CLOSE_ADAPTER: <br>        cmdname = "DIR.CLOSE.ADAPTER"; <br>        haveParms = FALSE; <br>        break; <br> <br>    case LLC_DIR_CLOSE_DIRECT: <br>        cmdname = "DIR.CLOSE.DIRECT"; <br>        haveParms = FALSE; <br>        break; <br> <br>    case LLC_DIR_INITIALIZE: <br>        cmdname = "DIR.INITIALIZE"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirInitializeParms; <br>        break; <br> <br>    case LLC_DIR_INTERRUPT: <br>        cmdname = "DIR.INTERRUPT"; <br>        haveParms = FALSE; <br>        break; <br> <br>    case LLC_DIR_OPEN_ADAPTER: <br>        cmdname = "DIR.OPEN.ADAPTER"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirOpenAdapterParms; <br>        break; <br> <br>    case LLC_DIR_OPEN_DIRECT: <br>        cmdname = "DIR.OPEN.DIRECT"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirOpenDirectParms; <br>        break; <br> <br>    case LLC_DIR_READ_LOG: <br>        cmdname = "DIR.READ.LOG"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirReadLogParms; <br>        break; <br> <br>    case LLC_DIR_SET_EXCEPTION_FLAGS: <br>        cmdname = "DIR.SET.EXCEPTION.FLAGS"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirSetExceptionFlagsParms; <br>        break; <br> <br>    case LLC_DIR_SET_FUNCTIONAL_ADDRESS: <br>        cmdname = "DIR.SET.FUNCTIONAL.ADDRESS"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirSetFunctionalAddressParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DIR_SET_GROUP_ADDRESS: <br>        cmdname = "DIR.SET.GROUP.ADDRESS"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirSetGroupAddressParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DIR_STATUS: <br>        cmdname = "DIR.STATUS"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirStatusParms; <br>        break; <br> <br>    case LLC_DIR_TIMER_CANCEL: <br>        cmdname = "DIR.TIMER.CANCEL"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirTimerCancelParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DIR_TIMER_CANCEL_GROUP: <br>        cmdname = "DIR.TIMER.CANCEL.GROUP"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirTimerCancelGroupParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DIR_TIMER_SET: <br>        cmdname = "DIR.TIMER.SET"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDirTimerSetParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DLC_CLOSE_SAP: <br>        cmdname = "DLC.CLOSE.SAP"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcCloseSapParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DLC_CLOSE_STATION: <br>        cmdname = "DLC.CLOSE.STATION"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcCloseStationParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DLC_CONNECT_STATION: <br>        cmdname = "DLC.CONNECT.STATION"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcConnectStationParms; <br>        break; <br> <br>    case LLC_DLC_FLOW_CONTROL: <br>        cmdname = "DLC.FLOW.CONTROL"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcFlowControlParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_DLC_MODIFY: <br>        cmdname = "DLC.MODIFY"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcModifyParms; <br>        break; <br> <br>    case LLC_DLC_OPEN_SAP: <br>        cmdname = "DLC.OPEN.SAP"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcOpenSapParms; <br>        break; <br> <br>    case LLC_DLC_OPEN_STATION: <br>        cmdname = "DLC.OPEN.STATION"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcOpenStationParms; <br>        break; <br> <br>    case LLC_DLC_REALLOCATE_STATIONS: <br>        cmdname = "DLC.REALLOCATE"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcReallocateParms; <br>        break; <br> <br>    case LLC_DLC_RESET: <br>        cmdname = "DLC.RESET"; <br>        break; <br> <br>    case LLC_DLC_SET_THRESHOLD: <br>        cmdname = "DLC.SET.THRESHOLD"; <br>        haveParms = TRUE; <br>        break; <br> <br>    case LLC_DLC_STATISTICS: <br>        cmdname = "DLC.STATISTICS"; <br>        haveParms = TRUE; <br>        DumpParms = DumpDlcStatisticsParms; <br>        break; <br> <br>    case 0x25: <br> <br>        // <br>        // not supported ! <br>        // <br> <br>        cmdname = "PDT.TRACE.OFF"; <br>        break; <br> <br>    case 0x24: <br> <br>        // <br>        // not supported ! <br>        // <br> <br>        cmdname = "PDT.TRACE.ON"; <br>        break; <br> <br>    case LLC_READ: <br>        cmdname = "READ"; <br>        haveParms = !CcbIsInput; <br>        DumpParms = DumpReadParms; <br>        dumpInputParms = FALSE; <br>        dumpOutputParms = !CcbIsInput &amp;&amp; Ccb-&gt;uchDlcStatus == LLC_STATUS_SUCCESS; <br>        break; <br> <br>    case LLC_READ_CANCEL: <br>        cmdname = "READ.CANCEL"; <br>        break; <br> <br>    case LLC_RECEIVE: <br>        cmdname = "RECEIVE"; <br>        haveParms = TRUE; <br>        DumpParms = DumpReceiveParms; <br>        break; <br> <br>    case LLC_RECEIVE_CANCEL: <br>        cmdname = "RECEIVE.CANCEL"; <br>        haveParms = TRUE; <br>        DumpParms = DumpReceiveCancelParms; <br>        parmsInCcb = TRUE; <br>        break; <br> <br>    case LLC_RECEIVE_MODIFY: <br>        cmdname = "RECEIVE.MODIFY"; <br>        haveParms = TRUE; <br>        break; <br> <br>    case LLC_TRANSMIT_FRAMES: <br>        cmdname = "TRANSMIT.FRAMES"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitFramesParms; <br>        dumpOutputParms = FALSE; <br>        break; <br> <br>    case LLC_TRANSMIT_DIR_FRAME: <br>        cmdname = "TRANSMIT.DIR.FRAME"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitDirFrameParms; <br>        dumpOutputParms = FALSE; <br>        break; <br> <br>    case LLC_TRANSMIT_I_FRAME: <br>        cmdname = "TRANSMIT.I.FRAME"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitIFrameParms; <br>        dumpOutputParms = FALSE; <br>        break; <br> <br>    case LLC_TRANSMIT_TEST_CMD: <br>        cmdname = "TRANSMIT.TEST.CMD"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitTestCmdParms; <br>        dumpOutputParms = FALSE; <br>        break; <br> <br>    case LLC_TRANSMIT_UI_FRAME: <br>        cmdname = "TRANSMIT.UI.FRAME"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitUiFrameParms; <br>        break; <br> <br>    case LLC_TRANSMIT_XID_CMD: <br>        cmdname = "TRANSMIT.XID.CMD"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitXidCmdParms; <br>        dumpOutputParms = FALSE; <br>        break; <br> <br>    case LLC_TRANSMIT_XID_RESP_FINAL: <br>        cmdname = "TRANSMIT.XID.RESP.FINAL"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitXidRespFinalParms; <br>        dumpOutputParms = FALSE; </code></pre>
<p>
</p>
<pre><code>break; <br> <br>    case LLC_TRANSMIT_XID_RESP_NOT_FINAL: <br>        cmdname = "TRANSMIT.XID.RESP.NOT.FINAL"; <br>        haveParms = TRUE; <br>        DumpParms = DumpTransmitXidRespNotFinalParms; <br>        dumpOutputParms = FALSE; <br>        break; <br> <br>    } <br> <br>    if (HaveCcbFilter) { <br> <br>        BYTE filter = AcslanDumpCcb[command]; <br> <br>#if DBGDBG <br>        PUT(("filter = %02x\n", filter)); <br>#endif <br> <br>        if (filter == 0xff) { <br> <br>            // <br>            // do nothing - 0xff means use default in ACSLAN_DEBUG_FLAGS <br>            // <br> <br>        } else { <br>            if (CcbIsInput) { <br>                if (!(filter &amp; CF_DUMP_CCB_IN)) { <br> <br>                    // <br>                    // not interested in this input CCB <br>                    // <br> <br>                    return; <br>                } <br>                DumpAll = filter &amp; CF_DUMP_PARMS_IN; <br>            } else { <br>                if (!(filter &amp; CF_DUMP_CCB_OUT)) { <br> <br>                    // <br>                    // not interested in this output CCB <br>                    // <br> <br>                    return; <br>                } <br>                DumpAll = filter &amp; CF_DUMP_PARMS_OUT; <br>            } <br>        } <br>    } <br> <br>    PUT(("\n==============================================================================\n")); <br> <br>    IF_DEBUG(DUMP_TIME) { <br>        PUT(("%sPUT CCB @ 0x%08x +%d mSec\n", <br>            CcbIsInput ? "IN" : "OUT", <br>            Ccb, <br>            numberOfTicks <br>            )); <br>    } else { <br>        PUT(("%sPUT CCB @ 0x%08x\n", <br>            CcbIsInput ? "IN" : "OUT", <br>            Ccb <br>            )); <br>    } <br> <br>    PUT(("Adapter . . . . %02x\n" <br>        "Command . . . . %02x [%s]\n" <br>        "Status. . . . . %02x [%s]\n" <br>        "Reserved. . . . %02x\n" <br>        "Next. . . . . . %08x\n" <br>        "CompletionFlag. %08x\n", <br>        Ccb-&gt;uchAdapterNumber, <br>        Ccb-&gt;uchDlcCommand, <br>        cmdname, <br>        Ccb-&gt;uchDlcStatus, <br>        CcbIsInput ? "" : MapCcbRetcode(Ccb-&gt;uchDlcStatus), <br>        Ccb-&gt;uchReserved1, <br>        Ccb-&gt;pNext, <br>        Ccb-&gt;ulCompletionFlag <br>        )); <br> <br>    if (haveParms) { <br>        if (parmsInCcb) { <br>            DumpParms(Ccb-&gt;u.pParameterTable); <br>        } else { <br>            parameterTable = Ccb-&gt;u.pParameterTable; <br>            PUT(("Parameters. . . %08x\n", parameterTable)); <br>        } <br>    } else { <br>        PUT(("Parameters. . . %08x\n", Ccb-&gt;u.pParameterTable)); <br>    } <br> <br>    PUT(("CompletionEvent %08x\n" <br>        "Reserved. . . . %02x\n" <br>        "ReadFlag. . . . %02x\n" <br>        "Reserved. . . . %04x\n", <br>        Ccb-&gt;hCompletionEvent, <br>        Ccb-&gt;uchReserved2, <br>        Ccb-&gt;uchReadFlag, <br>        Ccb-&gt;usReserved3 <br>        )); <br> <br>    if (parameterTable &amp;&amp; DumpAll) { <br>        if ((CcbIsInput &amp;&amp; dumpInputParms) || (!CcbIsInput &amp;&amp; dumpOutputParms)) { <br>            DumpParms(parameterTable); <br>        } <br>    } <br>} <br> <br>LPSTR <br>MapCcbRetcode( <br>    IN  BYTE    Retcode <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Returns string describing error code <br> <br>Arguments: <br> <br>    Retcode - CCB_RETCODE <br> <br>Return Value: <br> <br>    LPSTR <br> <br>--*/ <br> <br>{ <br>    static char errbuf[128]; <br> <br>    if (Retcode == LLC_STATUS_PENDING) { <br>        return "Command in progress"; <br>    } else if (Retcode &gt; NUMBER_OF_ERROR_MESSAGES) { <br>        sprintf(errbuf, "*** Invalid error code 0x%2x ***", Retcode); <br>        return errbuf; <br>    } <br>    return CcbRetcodeExplanations[Retcode]; <br>} <br> <br>VOID <br>DumpData( <br>    IN LPSTR Title, <br>    IN PBYTE Address, <br>    IN DWORD Length, <br>    IN DWORD Options, <br>    IN DWORD Indent <br>    ) <br>{ <br>    char dumpBuf[80]; <br>    char* bufptr; <br>    int i, n, iterations; <br>    char* hexptr; <br> <br>    // <br>    // the usual dump style: 16 columns of hex bytes, followed by 16 columns <br>    // of corresponding ASCII characters, or '.' where the character is &lt; 0x20 <br>    // (space) or &gt; 0x7f (del?) <br>    // <br> <br>    if (Options &amp; DD_LINE_BEFORE) { <br>        AcslanDebugPrintString("\n"); <br>    } <br> <br>    try { <br>        iterations = 0; <br>        while (Length) { <br>            bufptr = dumpBuf; <br>            if (Title &amp;&amp; !iterations) { <br>                strcpy(bufptr, Title); <br>                bufptr = strchr(bufptr, 0); <br>            } <br> <br>            if (Indent &amp;&amp; ((Options &amp; DD_INDENT_ALL) || iterations)) { <br> <br>                int indentLen = (!iterations &amp;&amp; Title) <br>                                    ? (Indent - strlen(Title) &lt; 0) <br>                                        ? 1 <br>                                        : Indent - strlen(Title) <br>                                    : Indent; <br> <br>                memset(bufptr, ' ', indentLen); <br>                bufptr += indentLen; <br>            } <br> <br>            if (!(Options &amp; DD_NO_ADDRESS)) { <br>                bufptr += sprintf(bufptr, "%08x: ", Address); <br>            } <br> <br>            n = (Length &lt; 16) ? Length : 16; <br>            hexptr = bufptr; <br>            for (i = 0; i &lt; n; ++i) { <br>                bufptr += sprintf(bufptr, "%02x", Address[i]); <br>                *bufptr++ = (i == 7) ? '-' : ' '; <br>            } <br> <br>            if (Options &amp; DD_UPPER_CASE) { <br>                strupr(hexptr); <br>            } <br> <br>            if (!(Options &amp; DD_NO_ASCII)) { <br>                if (n &lt; 16) { <br>                    for (i = 0; i &lt; 16-n; ++i) { <br>                        bufptr += sprintf(bufptr, Options &amp; DD_DOT_DOT_SPACE ? ".. " : "   "); <br>                    } <br>                } <br>                bufptr += sprintf(bufptr, "  "); <br>                for (i = 0; i &lt; n; ++i) { <br>                    *bufptr++ = (Address[i] &lt; 0x20 || Address[i] &gt; 0x7f) ? '.' : Address[i]; <br>                } <br>            } <br> <br>            *bufptr++ = '\n'; <br>            *bufptr = 0; <br>            AcslanDebugPrintString(dumpBuf); <br>            Length -= n; <br>            Address += n; <br>            ++iterations; <br>        } <br> <br>        if (Options &amp; DD_LINE_AFTER) { <br>            AcslanDebugPrintString("\n"); <br>        } <br>    } except(1) { <br>        PUT(("*** Error: Bad Data @ %x, length %d ***\n", Address, Length)); <br>    } <br>} <br> <br>PRIVATE <br>VOID <br>DefaultParameterTableDump( <br>    IN  PVOID   Parameters <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Displays default message for CCBs which have parameter tables that don't <br>    have a dump routine yet <br> <br>Arguments: <br> <br>    Parameters  - pointer to parameter table <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PUT(("Parameter table dump not implemented for this CCB\n")); <br>} <br> <br>PRIVATE <br>VOID <br>DumpParameterTableHeader( <br>    IN  LPSTR   CommandName, <br>    IN  PVOID   Table <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Displays header for parameter table dump <br> <br>Arguments: <br> <br>    CommandName - name of command which owns parameter table <br>    Table       - flat 32-bit address of parameter table <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PUT(("\n%s parameter table @ 0x%08x\n", CommandName, Table)); <br>} <br> <br>PRIVATE <br>VOID <br>DumpBufferCreateParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_BUFFER_CREATE_PARMS parms = (PLLC_BUFFER_CREATE_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("BUFFER.CREATE", Parameters); <br> <br>    PUT(("Buf Pool Handle %08x\n" <br>        "Buf Pool Addr . %08x\n" <br>        "Buffer Size . . %08x\n" <br>        "Minimum Size. . %08x\n", <br>        parms-&gt;hBufferPool, <br>        parms-&gt;pBuffer, <br>        parms-&gt;cbBufferSize, <br>        parms-&gt;cbMinimumSizeThreshold <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpBufferFreeParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_BUFFER_FREE_PARMS parms = (PLLC_BUFFER_FREE_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("BUFFER.FREE", Parameters); <br> <br>    PUT(("reserved. . . . %04x\n" <br>        "buffers left. . %04x\n" <br>        "reserved. . . . %02x %02x %02x %02x\n" <br>        "first buffer. . %08x\n", <br>        parms-&gt;usReserved1, <br>        parms-&gt;cBuffersLeft, <br>        ((PBYTE)&amp;(parms-&gt;ulReserved))[0], <br>        ((PBYTE)&amp;(parms-&gt;ulReserved))[1], <br>        ((PBYTE)&amp;(parms-&gt;ulReserved))[2], <br>        ((PBYTE)&amp;(parms-&gt;ulReserved))[3], <br>        parms-&gt;pFirstBuffer <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpBufferGetParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_BUFFER_GET_PARMS parms = (PLLC_BUFFER_GET_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("BUFFER.GET", Parameters); <br> <br>    PUT(("reserved. . . . %04x\n" <br>        "buffers left. . %04x\n" <br>        "buffers to get. %04x\n" <br>        "buffer size . . %04x\n" <br>        "first buffer. . %08x\n", <br>        parms-&gt;usReserved1, <br>        parms-&gt;cBuffersLeft, <br>        parms-&gt;cBuffersToGet, <br>        parms-&gt;cbBufferSize, <br>        parms-&gt;pFirstBuffer <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirInitializeParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_DIR_INITIALIZE_PARMS parms = (PLLC_DIR_INITIALIZE_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DIR.INITIALIZE", Parameters); <br> <br>    PUT(("Bring Ups . . . %04x\n" <br>        "Reserved. . . . %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n" <br>        "                %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n" <br>        "                %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", <br>        parms-&gt;usBringUps, <br>        parms-&gt;Reserved[ 0], <br>        parms-&gt;Reserved[ 1], <br>        parms-&gt;Reserved[ 2], <br>        parms-&gt;Reserved[ 3], <br>        parms-&gt;Reserved[ 4], <br>        parms-&gt;Reserved[ 5], <br>        parms-&gt;Reserved[ 6], <br>        parms-&gt;Reserved[ 7], <br>        parms-&gt;Reserved[ 8], <br>        parms-&gt;Reserved[ 9], <br>        parms-&gt;Reserved[10], <br>        parms-&gt;Reserved[11], <br>        parms-&gt;Reserved[12], <br>        parms-&gt;Reserved[13], <br>        parms-&gt;Reserved[14], <br>        parms-&gt;Reserved[15], <br>        parms-&gt;Reserved[16], <br>        parms-&gt;Reserved[17], <br>        parms-&gt;Reserved[18], <br>        parms-&gt;Reserved[19], <br>        parms-&gt;Reserved[20], <br>        parms-&gt;Reserved[21], <br>        parms-&gt;Reserved[22], <br>        parms-&gt;Reserved[23], <br>        parms-&gt;Reserved[24], <br>        parms-&gt;Reserved[25], <br>        parms-&gt;Reserved[26], <br>        parms-&gt;Reserved[27], <br>        parms-&gt;Reserved[28], <br>        parms-&gt;Reserved[29] <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirOpenAdapterParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_DIR_OPEN_ADAPTER_PARMS parms = (PLLC_DIR_OPEN_ADAPTER_PARMS)Parameters; <br>    PLLC_ADAPTER_OPEN_PARMS pAdapterParms = parms-&gt;pAdapterParms; <br>    PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms = parms-&gt;pExtendedParms; <br>    PLLC_DLC_PARMS pDlcParms = parms-&gt;pDlcParms; <br> <br>    DumpParameterTableHeader("DIR.OPEN.ADAPTER", Parameters); <br> <br>    PUT(("adapter parms . %08x\n" <br>        "extended parms. %08x\n" <br>        "DLC parms . . . %08x\n" <br>        "reserved. . . . %08x\n", <br>        pAdapterParms, <br>        pExtendedParms, <br>        pDlcParms, <br>        parms-&gt;pReserved1 <br>        )); <br> <br>    if (pAdapterParms) { <br>        PUT(("\n" <br>            "Adapter Parms @ %08x\n" <br>            "open error. . . %04x\n" <br>            "open options. . %04x\n" <br>            "node address. . %02x-%02x-%02x-%02x-%02x-%02x\n" <br>            "group address . %08x\n" <br>            "func. address . %08x\n" <br>            "Reserved 1. . . %04x\n" <br>            "Reserved 2. . . %04x\n" <br>            "max frame size  %04x\n" <br>            "Reserved 3. . . %04x %04x %04x %04x\n" <br>            "bring ups . . . %04x\n" <br>            "init warnings . %04x\n" <br>            "Reserved 4. . . %04x %04x %04x\n", <br>            pAdapterParms, <br>            pAdapterParms-&gt;usOpenErrorCode, <br>            pAdapterParms-&gt;usOpenOptions, <br>            pAdapterParms-&gt;auchNodeAddress[0], <br>            pAdapterParms-&gt;auchNodeAddress[1], <br>            pAdapterParms-&gt;auchNodeAddress[2], <br>            pAdapterParms-&gt;auchNodeAddress[3], <br>            pAdapterParms-&gt;auchNodeAddress[4], <br>            pAdapterParms-&gt;auchNodeAddress[5], <br>            *(LPDWORD)(&amp;pAdapterParms-&gt;auchGroupAddress), <br>            *(LPDWORD)(&amp;pAdapterParms-&gt;auchFunctionalAddress), <br>            pAdapterParms-&gt;usReserved1, <br>            pAdapterParms-&gt;usReserved2, <br>            pAdapterParms-&gt;usMaxFrameSize, <br>            pAdapterParms-&gt;usReserved3[0], <br>            pAdapterParms-&gt;usReserved3[1], <br>            pAdapterParms-&gt;usReserved3[2], <br>            pAdapterParms-&gt;usReserved3[3], <br>            pAdapterParms-&gt;usBringUps,  // blooargh <br>            pAdapterParms-&gt;InitWarnings, <br>            pAdapterParms-&gt;usReserved4[0], <br>            pAdapterParms-&gt;usReserved4[1], <br>            pAdapterParms-&gt;usReserved4[2] <br>            )); <br>    } <br> <br>    if (pExtendedParms) { <br>        PUT(("\n" <br>            "Extended Parms @ %08x\n" <br>            "hBufferPool . . %08x\n" <br>            "pSecurityDesc . %08x\n" <br>            "EthernetType. . %08x [%s]\n", <br>            pExtendedParms, <br>            pExtendedParms-&gt;hBufferPool, <br>            pExtendedParms-&gt;pSecurityDescriptor, <br>            pExtendedParms-&gt;LlcEthernetType, <br>            MapEthernetType(pExtendedParms-&gt;LlcEthernetType) <br>            )); <br>    } <br> <br>    if (pDlcParms) { <br>        PUT(("\n" <br>            "DLC Parms @ %08x\n" <br>            "max SAPs. . . . %02x\n" <br>            "max links . . . %02x\n" <br>            "max group SAPs. %02x\n" <br>            "max group membs %02x\n" <br>            "T1 Tick 1 . . . %02x\n" <br>            "T2 Tick 1 . . . %02x\n" <br>            "Ti Tick 1 . . . %02x\n" <br>            "T1 Tick 2 . . . %02x\n" <br>            "T2 Tick 2 . . . %02x\n" <br>            "Ti Tick 2 . . . %02x\n", <br>            pDlcParms, <br>            pDlcParms-&gt;uchDlcMaxSaps, <br>            pDlcParms-&gt;uchDlcMaxStations, <br>            pDlcParms-&gt;uchDlcMaxGroupSaps, <br>            pDlcParms-&gt;uchDlcMaxGroupMembers, <br>            pDlcParms-&gt;uchT1_TickOne, <br>            pDlcParms-&gt;uchT2_TickOne, <br>            pDlcParms-&gt;uchTi_TickOne, <br>            pDlcParms-&gt;uchT1_TickTwo, <br>            pDlcParms-&gt;uchT2_TickTwo, <br>            pDlcParms-&gt;uchTi_TickTwo <br>            )); <br>    } <br>} <br> <br>PRIVATE <br>LPSTR <br>MapEthernetType( <br>    IN LLC_ETHERNET_TYPE EthernetType <br>    ) <br>{ <br>    switch (EthernetType) { <br>    case LLC_ETHERNET_TYPE_DEFAULT: <br>        return "DEFAULT"; <br> <br>    case LLC_ETHERNET_TYPE_AUTO: <br>        return "AUTO"; <br> <br>    case LLC_ETHERNET_TYPE_802_3: <br>        return "802.3"; <br> <br>    case LLC_ETHERNET_TYPE_DIX: <br>        return "DIX"; <br>    } <br>    return "*** Unknown Ethernet Type ***"; <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirOpenDirectParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_DIR_OPEN_DIRECT_PARMS parms = (PLLC_DIR_OPEN_DIRECT_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DIR.OPEN.DIRECT", Parameters); <br> <br>    PUT(("reserved. . . . %04x %04x %04x %04x\n" <br>        "open options. . %04x\n" <br>        "ethernet type . %04x\n" <br>        "protocol mask . %08x\n" <br>        "protocol match. %08x\n" <br>        "protocol offset %04x\n", <br>        parms-&gt;Reserved[0], <br>        parms-&gt;Reserved[1], <br>        parms-&gt;Reserved[2], <br>        parms-&gt;Reserved[3], <br>        parms-&gt;usOpenOptions, <br>        parms-&gt;usEthernetType, <br>        parms-&gt;ulProtocolTypeMask, <br>        parms-&gt;ulProtocolTypeMatch, <br>        parms-&gt;usProtocolTypeOffset <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirReadLogParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_DIR_READ_LOG_PARMS parms = (PLLC_DIR_READ_LOG_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DIR.READ.LOG", Parameters); <br> <br>    PUT(("type id . . . . %04x [%s]\n" <br>        "log buf len . . %04x\n" <br>        "log buf ptr . . %08x\n" <br>        "act. log. len.. %04x\n", <br>        parms-&gt;usTypeId, <br>        MapLogType(parms-&gt;usTypeId), <br>        parms-&gt;cbLogBuffer, <br>        parms-&gt;pLogBuffer, <br>        parms-&gt;cbActualLength <br>        )); <br>} <br> <br>PRIVATE <br>LPSTR <br>MapLogType( <br>    IN USHORT Type <br>    ) <br>{ <br>    switch (Type) { <br>    case 0: <br>        return "Adapter Error Log"; <br> <br>    case 1: <br>        return "Direct Interface Error Log"; <br> <br>    case 2: <br>        return "Adapter &amp; Direct Interface Error Logs"; <br>    } <br>    return "*** Unknown Log Type ***"; <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirSetExceptionFlagsParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_DIR_SET_EFLAG_PARMS parms = (PLLC_DIR_SET_EFLAG_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DIR.SET.EXCEPTION.FLAGS", Parameters); <br> <br>    PUT(("Adapter Check Flag. %08x\n" <br>        "Network Status Flag %08x\n" <br>        "PC Error Flag . . . %08x\n" <br>        "System Action Flag. %08x\n", <br>        parms-&gt;ulAdapterCheckFlag, <br>        parms-&gt;ulNetworkStatusFlag, <br>        parms-&gt;ulPcErrorFlag, <br>        parms-&gt;ulSystemActionFlag <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirSetFunctionalAddressParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("Functional addr %08x\n", Parameters)); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirSetGroupAddressParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("Group addr. . . %08x\n", Parameters)); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirStatusParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_DIR_STATUS_PARMS parms = (PLLC_DIR_STATUS_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DIR.STATUS", Parameters); <br> <br>    PUT(("perm node addr. %02x-%02x-%02x-%02x-%02x-%02x\n" <br>        "local node addr %02x-%02x-%02x-%02x-%02x-%02x\n" <br>        "group addr. . . %08lx\n" <br>        "functional addr %08lx\n" <br>        "max SAPs. . . . %02x\n" <br>        "open SAPs . . . %02x\n" <br>        "max stations. . %02x\n" <br>        "open stations . %02x\n" <br>        "avail stations. %02x\n" <br>        "adapter config. %02x\n" <br>        "reserved 1. . . %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x\n" <br>        "reserved 2. . . %08x\n" <br>        "reserved 3. . . %08x\n" <br>        "max frame len . %08x\n" <br>        "last NW status. %04x\n" <br>        "adapter type. . %04x [%s]\n", <br>        parms-&gt;auchPermanentAddress[0], <br>        parms-&gt;auchPermanentAddress[1], <br>        parms-&gt;auchPermanentAddress[2], <br>        parms-&gt;auchPermanentAddress[3], <br>        parms-&gt;auchPermanentAddress[4], <br>        parms-&gt;auchPermanentAddress[5], <br>        parms-&gt;auchNodeAddress[0], <br>        parms-&gt;auchNodeAddress[1], <br>        parms-&gt;auchNodeAddress[2], <br>        parms-&gt;auchNodeAddress[3], <br>        parms-&gt;auchNodeAddress[4], <br>        parms-&gt;auchNodeAddress[5], <br>        *(LPDWORD)(&amp;parms-&gt;auchGroupAddress), <br>        *(LPDWORD)(&amp;parms-&gt;auchFunctAddr), <br>        parms-&gt;uchMaxSap, <br>        parms-&gt;uchOpenSaps, <br>        parms-&gt;uchMaxStations, <br>        parms-&gt;uchOpenStation, <br>        parms-&gt;uchAvailStations, <br>        parms-&gt;uchAdapterConfig, <br>        parms-&gt;auchReserved1[0], <br>        parms-&gt;auchReserved1[1], <br>        parms-&gt;auchReserved1[2], <br>        parms-&gt;auchReserved1[3], <br>        parms-&gt;auchReserved1[4], <br>        parms-&gt;auchReserved1[5], <br>        parms-&gt;auchReserved1[6], <br>        parms-&gt;auchReserved1[7], <br>        parms-&gt;auchReserved1[8], <br>        parms-&gt;auchReserved1[9], <br>        parms-&gt;ulReserved1, <br>        parms-&gt;ulReserved2, <br>        parms-&gt;ulMaxFrameLength, <br>        parms-&gt;usLastNetworkStatus, <br>        parms-&gt;usAdapterType, <br>        MapAdapterType(parms-&gt;usAdapterType) <br>        )); <br>} <br> <br>PRIVATE <br>LPSTR <br>MapAdapterType( <br>    IN USHORT AdapterType <br>    ) <br>{ <br>    switch (AdapterType) { <br>    case 0x0001: <br>        return "Token Ring Network PC Adapter"; <br> <br>    case 0x0002: <br>        return "Token Ring Network PC Adapter II"; <br> <br>    case 0x0004: <br>        return "Token Ring Network Adapter/A"; <br> <br>    case 0x0008: <br>        return "Token Ring Network PC Adapter II"; <br> <br>    case 0x0020: <br>        return "Token Ring Network 16/4 Adapter"; <br> <br>    case 0x0040: <br>        return "Token Ring Network 16/4 Adapter/A"; <br> <br>    case 0x0080: <br>        return "Token Ring Network Adapter/A"; <br> <br>    case 0x0100: <br>        return "Ethernet Adapter"; <br> <br>    case 0x4000: <br>        return "PC Network Adapter"; <br> <br>    case 0x8000: <br>        return "PC Network Adapter/A"; <br>    } <br>    return "*** Unknown Adapter Type ***"; <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirTimerCancelParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("timer addr. . . %08x\n", Parameters)); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirTimerCancelGroupParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("timer cmpl flag %08x\n", Parameters)); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDirTimerSetParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("time value. . . %04x\n", HIWORD(Parameters))); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcCloseSapParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("station id      %04x\n" <br>        "reserved. . . . %02x %02x\n", <br>        HIWORD(Parameters), <br>        HIBYTE(LOWORD(Parameters)), <br>        LOBYTE(LOWORD(Parameters)) <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcCloseStationParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("station id. . . %04x\n" <br>        "reserved. . . . %02x %02x\n", <br>        HIWORD(Parameters), <br>        HIBYTE(LOWORD(Parameters)), <br>        LOBYTE(LOWORD(Parameters)) <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcConnectStationParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_DLC_CONNECT_PARMS parms = (PLLC_DLC_CONNECT_PARMS)Parameters; <br>    LPBYTE routing = parms-&gt;pRoutingInfo; <br>    int i, n; <br> <br>    DumpParameterTableHeader("DLC.CONNECT.STATION", Parameters); <br> <br>    PUT(("station id. . . %04x\n" <br>        "reserved. . . . %04x\n" <br>        "routing addr. . %08x [", <br>        parms-&gt;usStationId, <br>        parms-&gt;usReserved, <br>        routing <br>        )); <br>    if (routing) { <br>        n = (int)(routing[0] &amp; 0x1f); <br>        for (i=0; i&lt;n-1; ++i) { <br>            PUT(("%02x ", routing[i])); <br>        } <br>        PUT(("%02x", routing[i])); <br>    } <br>    PUT(("]\n")); <br>    if (routing) { <br>        char broadcastIndicators = routing[0] &amp; 0xe0; <br>        char length = routing[0] &amp; 0x1f; <br>        char direction = routing[1] &amp; 0x80; <br>        char largestFrame = routing[1] &amp; 0x70; <br>        PUT(("Routing Info Description: ")); <br>        if (broadcastIndicators &amp; 0x80 == 0) { <br>            PUT(("Non Broadcast ")); <br>        } else if (broadcastIndicators &amp; 0xc0 == 0x80) { <br>            PUT(("All Routes Broadcast ")); <br>        } else if (broadcastIndicators &amp; 0xc0 == 0xc0) { <br>            PUT(("Single Route Broadcast ")); <br>        } <br>        PUT(("Length = %d ", length)); <br>        if (direction) { <br>            PUT(("interpret right-to-left ")); <br>        } else { <br>            PUT(("interpret left-to-right ")); <br>        } <br>        switch (largestFrame) { <br>        case 0x00: <br>            PUT(("&lt;= 516 bytes in I-field ")); <br>            break; <br> <br>        case 0x10: <br>            PUT(("&lt;= 1500 bytes in I-field ")); <br>            break; <br> <br>        case 0x20: <br>            PUT(("&lt;= 2052 bytes in I-field ")); <br>            break; <br> <br>        case 0x30: <br>            PUT(("&lt;= 4472 bytes in I-field ")); <br>            break; <br> <br>        case 0x40: <br>            PUT(("&lt;= 8144 bytes in I-field ")); <br>            break; <br> <br>        case 0x50: <br>            PUT(("&lt;= 11407 bytes in I-field ")); <br>            break; <br> <br>        case 0x60: <br>            PUT(("&lt;= 17800 bytes in I-field ")); <br>            break; <br> <br>        case 0x70: <br>            PUT(("All-Routes Broadcast Frame ")); <br>            break; <br> <br>        } <br>        PUT(("\n")); <br>    } <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcFlowControlParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("station id. . . %04x\n" <br>        "flow control. . %02x [%s]\n", <br>        HIWORD(Parameters), <br>        HIBYTE(LOWORD(Parameters)), <br>        MapFlowControl(HIBYTE(LOWORD(Parameters))) <br>        )); <br>} <br> <br>PRIVATE <br>LPSTR <br>MapFlowControl( <br>    IN BYTE FlowControl <br>    ) <br>{ <br>    if (FlowControl &amp; 0x80) { <br>        if (FlowControl &amp; 0x40) { <br>            return "RESET LOCAL BUSY - BUFFER"; <br>        } else { <br>            return "RESET LOCAL BUSY - USER"; <br>        } <br>    } else { <br>        return "Enter LOCAL BUSY state"; <br>    } <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcModifyParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_DLC_MODIFY_PARMS parms = (PLLC_DLC_MODIFY_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DLC.MODIFY", Parameters); <br> <br>    PUT(("reserved. . . . %04x\n" <br>        "station id. . . %04x\n" <br>        "timer T1. . . . %02x\n" <br>        "timer T2. . . . %02x\n" <br>        "timer Ti. . . . %02x\n" <br>        "maxout. . . . . %02x\n" <br>        "maxin . . . . . %02x\n" <br>        "maxout incr . . %02x\n" <br>        "max retry count %02x\n" <br>        "reserved. . . . %02x\n" <br>        "max info field. %02x\n" <br>        "access priority %02x\n" <br>        "reserved. . . . %02x %02x %02x %02x\n" <br>        "group count . . %02x\n" <br>        "group list. . . %08x ", <br>        parms-&gt;usRes, <br>        parms-&gt;usStationId, <br>        parms-&gt;uchT1, <br>        parms-&gt;uchT2, <br>        parms-&gt;uchTi, <br>        parms-&gt;uchMaxOut, <br>        parms-&gt;uchMaxIn, <br>        parms-&gt;uchMaxOutIncr, <br>        parms-&gt;uchMaxRetryCnt, <br>        parms-&gt;uchReserved1, <br>        parms-&gt;usMaxInfoFieldLength, <br>        parms-&gt;uchAccessPriority, <br>        parms-&gt;auchReserved3[0], <br>        parms-&gt;auchReserved3[1], <br>        parms-&gt;auchReserved3[2], <br>        parms-&gt;auchReserved3[3], <br>        parms-&gt;cGroupCount, <br>        parms-&gt;pGroupList <br>        )); <br> <br>    if (parms-&gt;pGroupList) { <br>        DumpData(NULL, <br>                 parms-&gt;pGroupList, <br>                 parms-&gt;cGroupCount, <br>                 DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE, <br>                 DEFAULT_FIELD_WIDTH + 8 + 1 <br>                 ); <br>    } <br> <br>    PUT(("\n")); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcOpenSapParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_DLC_OPEN_SAP_PARMS parms = (PLLC_DLC_OPEN_SAP_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DLC.OPEN.SAP", Parameters); <br> <br>    PUT(("station id. . . %04x\n" <br>        "user stat . . . %04x\n" <br>        "T1. . . . . . . %02x\n" <br>        "T2. . . . . . . %02x\n" <br>        "Ti. . . . . . . %02x\n" <br>        "max out . . . . %02x\n" <br>        "max in  . . . . %02x\n" <br>        "max out incr. . %02x\n" <br>        "max retry count %02x\n" <br>        "max members . . %02x\n" <br>        "max I field . . %04x\n" <br>        "SAP value . . . %02x\n" <br>        "options/pri . . %02x\n" <br>        "link count. . . %02x\n" <br>        "reserved. . . . %02x %02x\n" <br>        "group count . . %02x\n" <br>        "group list. . . %08x\n" <br>        "status flags. . %08x\n" <br>        "reserved. . . . %02x %02x %02x %02x %02x %02x %02x %02x\n" <br>        "links available %02x\n", <br>        parms-&gt;usStationId, <br>        parms-&gt;usUserStatValue, <br>        parms-&gt;uchT1, <br>        parms-&gt;uchT2, <br>        parms-&gt;uchTi, <br>        parms-&gt;uchMaxOut, <br>        parms-&gt;uchMaxIn, <br>        parms-&gt;uchMaxOutIncr, <br>        parms-&gt;uchMaxRetryCnt, <br>        parms-&gt;uchMaxMembers, <br>        parms-&gt;usMaxI_Field, <br>        parms-&gt;uchSapValue, <br>        parms-&gt;uchOptionsPriority, <br>        parms-&gt;uchcStationCount, <br>        parms-&gt;uchReserved2[0], <br>        parms-&gt;uchReserved2[1], <br>        parms-&gt;cGroupCount, <br>        parms-&gt;pGroupList, <br>        parms-&gt;DlcStatusFlags, <br>        parms-&gt;uchReserved3[0], <br>        parms-&gt;uchReserved3[1], <br>        parms-&gt;uchReserved3[2], <br>        parms-&gt;uchReserved3[3], <br>        parms-&gt;uchReserved3[4], <br>        parms-&gt;uchReserved3[5], <br>        parms-&gt;uchReserved3[6], <br>        parms-&gt;uchReserved3[7], <br>        parms-&gt;cLinkStationsAvail <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcOpenStationParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_DLC_OPEN_STATION_PARMS parms = (PLLC_DLC_OPEN_STATION_PARMS)Parameters; <br>    LPBYTE dest = parms-&gt;pRemoteNodeAddress; <br>    char destAddr[19]; <br> <br>    DumpParameterTableHeader("DLC.OPEN.STATION", Parameters); <br> <br>    destAddr[0] = 0; <br>    if (dest) { <br>        sprintf(destAddr, "%02x-%02x-%02x-%02x-%02x-%02x", <br>                dest[0], <br>                dest[1], <br>                dest[2], <br>                dest[3], <br>                dest[4], <br>                dest[5] <br>                ); <br>    } <br>    PUT(("SAP station . . %04x\n" <br>        "link station. . %04x\n" <br>        "T1. . . . . . . %02x\n" <br>        "T2. . . . . . . %02x\n" <br>        "Ti. . . . . . . %02x\n" <br>        "max out . . . . %02x\n" <br>        "max in. . . . . %02x\n" <br>        "max out incr. . %02x\n" <br>        "max retry count %02x\n" <br>        "remote SAP. . . %02x\n" <br>        "max I field . . %04x\n" <br>        "access priority %02x\n" <br>        "remote node . . %08x [%s]\n", <br>        parms-&gt;usSapStationId, <br>        parms-&gt;usLinkStationId, <br>        parms-&gt;uchT1, <br>        parms-&gt;uchT2, <br>        parms-&gt;uchTi, <br>        parms-&gt;uchMaxOut, <br>        parms-&gt;uchMaxIn, <br>        parms-&gt;uchMaxOutIncr, <br>        parms-&gt;uchMaxRetryCnt, <br>        parms-&gt;uchRemoteSap, <br>        parms-&gt;usMaxI_Field, <br>        parms-&gt;uchAccessPriority, <br>        dest, <br>        destAddr <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcReallocateParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_DLC_REALLOCATE_PARMS parms = (PLLC_DLC_REALLOCATE_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DLC.REALLOCATE", Parameters); <br> <br>    PUT(("station id. . . %04x\n" <br>        "option. . . . . %02x [%screase link stations]\n" <br>        "station count . %02x\n" <br>        "adapter stns. . %02x\n" </code></pre>
<p>
</p>
<pre><code>"SAP stations. . %02x\n" <br>        "adapter total . %02x\n" <br>        "SAP total . . . %02x\n", <br>        parms-&gt;usStationId, <br>        parms-&gt;uchOption, <br>        parms-&gt;uchOption &amp; 0x80 ? "De" : "In", <br>        parms-&gt;uchStationCount, <br>        parms-&gt;uchStationsAvailOnAdapter, <br>        parms-&gt;uchStationsAvailOnSap, <br>        parms-&gt;uchTotalStationsOnAdapter, <br>        parms-&gt;uchTotalStationsOnSap <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcResetParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("station id. . . %04x\n", HIWORD(Parameters))); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcSetThresholdParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_DLC_SET_THRESHOLD_PARMS parms = (PLLC_DLC_SET_THRESHOLD_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DLC.SET.THRESHOLD", Parameters); <br> <br>    PUT(("station id. . . %04x\n" <br>        "buf threshold . %04x\n" <br>        "event . . . . . %08x\n", <br>        parms-&gt;usStationId, <br>        parms-&gt;cBufferThreshold, <br>        parms-&gt;AlertEvent <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpDlcStatisticsParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_DLC_STATISTICS_PARMS parms = (PLLC_DLC_STATISTICS_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("DLC.STATISTICS", Parameters); <br> <br>    PUT(("station id. . . %04x\n" <br>        "log buf size. . %04x\n" <br>        "log buffer. . . %08x\n" <br>        "actual log len. %04x\n" <br>        "options . . . . %02x [%s]\n", <br>        parms-&gt;usStationId, <br>        parms-&gt;cbLogBufSize, <br>        parms-&gt;pLogBuf, <br>        parms-&gt;usActLogLength, <br>        parms-&gt;uchOptions, <br>        parms-&gt;uchOptions &amp; 0x80 ? "Reset counters" : "" <br>        )); <br>} <br> <br>PRIVATE <br>VOID <br>DumpReadParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("READ", Parameters); <br> <br>    try { <br>        PUT(("station id. . . %04x\n" <br>            "option ind. . . %02x [%s]\n" <br>            "event set . . . %02x\n" <br>            "event . . . . . %02x [%s]\n" <br>            "crit. subset. . %02x\n" <br>            "notify flag . . %08x\n", <br>            parms-&gt;usStationId, <br>            parms-&gt;uchOptionIndicator, <br>            MapOptionIndicator(parms-&gt;uchOptionIndicator), <br>            parms-&gt;uchEventSet, <br>            parms-&gt;uchEvent, <br>            MapReadEvent(parms-&gt;uchEvent), <br>            parms-&gt;uchCriticalSubset, <br>            parms-&gt;ulNotificationFlag <br>            )); <br> <br>        // <br>        // rest of table interpreted differently depending on whether status change <br>        // <br> <br>        if (parms-&gt;uchEvent &amp; 0x38) { <br>            PUT(("station id. . . %04x\n" <br>                "status code . . %04x [%s]\n" <br>                "FRMR data . . . %02x %02x %02x %02x %02x\n" <br>                "access pri. . . %02x\n" <br>                "remote addr . . %02x-%02x-%02x-%02x-%02x-%02x\n" <br>                "remote SAP. . . %02x\n" <br>                "reserved. . . . %02x\n" <br>                "user stat . . . %04x\n", <br>                parms-&gt;Type.Status.usStationId, <br>                parms-&gt;Type.Status.usDlcStatusCode, <br>                MapDlcStatus(parms-&gt;Type.Status.usDlcStatusCode), <br>                parms-&gt;Type.Status.uchFrmrData[0], <br>                parms-&gt;Type.Status.uchFrmrData[1], <br>                parms-&gt;Type.Status.uchFrmrData[2], <br>                parms-&gt;Type.Status.uchFrmrData[3], <br>                parms-&gt;Type.Status.uchFrmrData[4], <br>                parms-&gt;Type.Status.uchAccessPritority, <br>                parms-&gt;Type.Status.uchRemoteNodeAddress[0], <br>                parms-&gt;Type.Status.uchRemoteNodeAddress[1], <br>                parms-&gt;Type.Status.uchRemoteNodeAddress[2], <br>                parms-&gt;Type.Status.uchRemoteNodeAddress[3], <br>                parms-&gt;Type.Status.uchRemoteNodeAddress[4], <br>                parms-&gt;Type.Status.uchRemoteNodeAddress[5], <br>                parms-&gt;Type.Status.uchRemoteSap, <br>                parms-&gt;Type.Status.uchReserved, <br>                parms-&gt;Type.Status.usUserStatusValue <br>                )); <br>        } else { <br>            PUT(("CCB count . . . %04x\n" <br>                "CCB list. . . . %08x\n" <br>                "buffer count. . %04x\n" <br>                "buffer list . . %08x\n" <br>                "frame count . . %04x\n" <br>                "frame list. . . %08x\n" <br>                "error code. . . %04x\n" <br>                "error data. . . %04x %04x %04x\n", <br>                parms-&gt;Type.Event.usCcbCount, <br>                parms-&gt;Type.Event.pCcbCompletionList, <br>                parms-&gt;Type.Event.usBufferCount, <br>                parms-&gt;Type.Event.pFirstBuffer, <br>                parms-&gt;Type.Event.usReceivedFrameCount, <br>                parms-&gt;Type.Event.pReceivedFrame, <br>                parms-&gt;Type.Event.usEventErrorCode, <br>                parms-&gt;Type.Event.usEventErrorData[0], <br>                parms-&gt;Type.Event.usEventErrorData[1], <br>                parms-&gt;Type.Event.usEventErrorData[2] <br>                )); <br> <br>            IF_DEBUG(DUMP_ASYNC_CCBS) { <br>                if (parms-&gt;Type.Event.usCcbCount) { <br>                    DumpCcb(parms-&gt;Type.Event.pCcbCompletionList, <br>                            TRUE,   // DumpAll <br>                            FALSE   // CcbIsInput <br>                            ); <br>                } <br>            } <br> <br>            IF_DEBUG(DUMP_RX_INFO) { <br>                if (parms-&gt;Type.Event.usReceivedFrameCount) { <br>                    DumpReceiveDataBuffer(parms-&gt;Type.Event.pReceivedFrame); <br>                } <br>            } <br>        } <br>    } except(1) { <br>        PUT(("*** Error: Bad READ Parameter Table @ %x ***\n", parms)); <br>    } <br>} <br> <br>PRIVATE <br>LPSTR <br>MapOptionIndicator( <br>    IN UCHAR OptionIndicator <br>    ) <br>{ <br>    switch (OptionIndicator) { <br>    case 0: <br>        return "Match READ command using station id nnss"; <br> <br>    case 1: <br>        return "Match READ command using SAP number nn00"; <br> <br>    case 2: <br>        return "Match READ command using all events"; <br>    } <br>    return "*** Unknown READ Option Indicator ***"; <br>} <br> <br>PRIVATE LPSTR MapReadEvent(UCHAR Event) { <br>    switch (Event) { <br>    case 0x80: <br>        return "Reserved Event!"; <br> <br>    case 0x40: <br>        return "System Action (non-critical)"; <br> <br>    case 0x20: <br>        return "Network Status (non-critical)"; <br> <br>    case 0x10: <br>        return "Critical Exception"; <br> <br>    case 0x8: <br>        return "DLC Status Change"; <br> <br>    case 0x4: <br>        return "Receive Data"; <br> <br>    case 0x2: <br>        return "Transmit Completion"; <br> <br>    case 0x1: <br>        return "Command Completion"; <br>    } <br>    return "*** Unknown READ Event ***"; <br>} <br> <br>PRIVATE LPSTR MapDlcStatus(WORD Status) { <br>    if (Status &amp; 0x8000) { <br>        return "Link lost"; <br>    } else if (Status &amp; 0x4000) { <br>        return "DM/DISC Received -or- DISC ack'd"; <br>    } else if (Status &amp; 0x2000) { <br>        return "FRMR Received"; <br>    } else if (Status &amp; 0x1000) { <br>        return "FRMR Sent"; <br>    } else if (Status &amp; 0x0800) { <br>        return "SABME Received for open link station"; <br>    } else if (Status &amp; 0x0400) { <br>        return "SABME Received - link station opened"; <br>    } else if (Status &amp; 0x0200) { <br>        return "REMOTE Busy Entered"; <br>    } else if (Status &amp; 0x0100) { <br>        return "REMOTE Busy Left"; <br>    } else if (Status &amp; 0x0080) { <br>        return "Ti EXPIRED"; <br>    } else if (Status &amp; 0x0040) { <br>        return "DLC counter overflow - issue DLC.STATISTICS"; <br>    } else if (Status &amp; 0x0020) { <br>        return "Access Priority lowered"; <br>    } else if (Status &amp; 0x001e) { <br>        return "*** ERROR - INVALID STATUS ***"; <br>    } else if (Status &amp; 0x0001) { <br>        return "Entered LOCAL Busy"; <br>    } <br>    return "*** Unknown DLC Status ***"; <br>} <br> <br>PRIVATE <br>VOID <br>DumpReadCancelParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>} <br> <br>PRIVATE <br>VOID <br>DumpReceiveParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    PLLC_RECEIVE_PARMS parms = (PLLC_RECEIVE_PARMS)Parameters; <br> <br>    DumpParameterTableHeader("RECEIVE", Parameters); <br> <br>    PUT(("station id. . . %04x\n" <br>        "user length . . %04x\n" <br>        "receive flag. . %08x\n" <br>        "first buffer. . %08x\n" <br>        "options . . . . %02x [%s]\n" <br>        "reserved. . . . %02x %02x %02x\n" <br>        "rcv read optns. %02x [%s]\n", <br>        parms-&gt;usStationId, <br>        parms-&gt;usUserLength, <br>        parms-&gt;ulReceiveFlag, <br>        parms-&gt;pFirstBuffer, <br>        parms-&gt;uchOptions, <br>        MapReceiveOptions(parms-&gt;uchOptions), <br>        parms-&gt;auchReserved1[0], <br>        parms-&gt;auchReserved1[1], <br>        parms-&gt;auchReserved1[2], <br>        parms-&gt;uchRcvReadOption, <br>        MapRcvReadOption(parms-&gt;uchRcvReadOption) <br>        )); <br>} <br> <br>PRIVATE <br>LPSTR <br>MapReceiveOptions( <br>    IN UCHAR Options <br>    ) <br>{ <br>    static char buf[80]; <br>    BOOL space = FALSE; <br> <br>    buf[0] = 0; <br>    if (Options &amp; 0x80) { <br>        strcat(buf, "Contiguous MAC"); <br>        Options &amp;= 0x7f; <br>        space = TRUE; <br>    } <br>    if (Options &amp; 0x40) { <br>        if (space) { <br>            strcat(buf, " "); <br>        } <br>        strcat(buf, "Contiguous DATA"); <br>        Options &amp;= 0xbf; <br>        space = TRUE; <br>    } <br>    if (Options &amp; 0x20) { <br>        if (space) { <br>            strcat(buf, " "); <br>        } <br>        strcat(buf, "Break"); <br>        Options &amp;= 0xdf; <br>        space = TRUE; <br>    } <br>    if (Options) { <br>        if (space) { <br>            strcat(buf, " "); <br>        } <br>        strcat(buf, "*** Invalid options ***"); <br>    } <br>    return buf; <br>} <br> <br>PRIVATE <br>LPSTR <br>MapRcvReadOption( <br>    IN UCHAR Option <br>    ) <br>{ <br>    switch (Option) { <br>    case 0: <br>        return "Receive frames not chained"; <br> <br>    case 1: <br>        return "Chain receive frames for link station"; <br> <br>    case 2: <br>        return "Chain receive frames for SAP"; <br>    } <br>    return "*** Unknown option ***"; <br>} <br> <br>PRIVATE <br>VOID <br>DumpReceiveCancelParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PUT(("station id. . . %04x\n", HIWORD(Parameters))); <br>} <br> <br>PRIVATE <br>VOID <br>DumpReceiveModifyParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitDirFrameParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.DIR.FRAME", Parameters); <br>    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitIFrameParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.I.FRAME", Parameters); <br>    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitTestCmdParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.TEST.CMD", Parameters); <br>    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitUiFrameParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.UI.FRAME", Parameters); <br>    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitXidCmdParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.XID.CMD", Parameters); <br>    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitXidRespFinalParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.XID.RESP.FINAL", Parameters); <br>    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitXidRespNotFinalParms( <br>    IN  PVOID   Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.XID.RESP.NOT.FINAL", Parameters); <br>    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitFramesParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    DumpParameterTableHeader("TRANSMIT.FRAMES", Parameters); <br>//    DumpTransmitParms(Parameters); <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitParms( <br>    IN PVOID Parameters <br>    ) <br>{ <br>    PLLC_TRANSMIT_PARMS parms = (PLLC_TRANSMIT_PARMS)Parameters; <br> <br>    try { <br>        PUT(("StationId . . . %04x\n" <br>            "Transmit FS . . %02x\n" <br>            "Remote SAP. . . %02x\n" <br>            "Xmit Queue 1. . %08x\n" <br>            "Xmit Queue 2. . %08x\n" <br>            "Buffer Length 1 %02x\n" <br>            "Buffer Length 2 %02x\n" <br>            "Buffer 1. . . . %08x\n" <br>            "Buffer 2. . . . %08x\n" <br>            "Xmt Read Option %02x [%s]\n" <br>            "\n", <br>            parms-&gt;usStationId, <br>            parms-&gt;uchTransmitFs, <br>            parms-&gt;uchRemoteSap, <br>            parms-&gt;pXmitQueue1, <br>            parms-&gt;pXmitQueue2, <br>            parms-&gt;cbBuffer1, <br>            parms-&gt;cbBuffer2, <br>            parms-&gt;pBuffer1, <br>            parms-&gt;pBuffer2, <br>            parms-&gt;uchXmitReadOption, <br>            MapXmitReadOption(parms-&gt;uchXmitReadOption) <br>            )); <br> <br>        IF_DEBUG(DUMP_TX_INFO) { <br>            if (parms-&gt;pXmitQueue1) { <br>                PUT(("XMIT_QUEUE_ONE:\n")); <br>                DumpTransmitQueue(parms-&gt;pXmitQueue1); <br>            } <br> <br>            if (parms-&gt;pXmitQueue2) { <br>                PUT(("XMIT_QUEUE_TWO:\n")); <br>                DumpTransmitQueue(parms-&gt;pXmitQueue2); <br>            } <br>        } <br> <br>        IF_DEBUG(DUMP_TX_DATA) { <br>            if (parms-&gt;cbBuffer1) { <br>                DumpData("BUFFER_ONE. . . ", <br>                        (PBYTE)parms-&gt;pBuffer1, <br>                        (DWORD)parms-&gt;cbBuffer1, <br>                        DD_NO_ADDRESS <br>                        | DD_LINE_AFTER <br>                        | DD_INDENT_ALL <br>                        | DD_UPPER_CASE <br>                        | DD_DOT_DOT_SPACE, <br>                        DEFAULT_FIELD_WIDTH <br>                        ); <br>            } <br> <br>            if (parms-&gt;cbBuffer2) { <br>                DumpData("BUFFER_TWO. . . ", <br>                        (PBYTE)parms-&gt;pBuffer2, <br>                        (DWORD)parms-&gt;cbBuffer2, <br>                        DD_NO_ADDRESS <br>                        | DD_LINE_AFTER <br>                        | DD_INDENT_ALL <br>                        | DD_UPPER_CASE <br>                        | DD_DOT_DOT_SPACE, <br>                        DEFAULT_FIELD_WIDTH <br>                        ); <br>            } <br>        } <br>    } except(1) { <br>        PUT(("*** Error: Bad Transmit Parameter Table @ %x ***\n", parms)); <br>    } <br>} <br> <br>PRIVATE <br>VOID <br>DumpTransmitQueue( <br>    IN PLLC_XMIT_BUFFER Buffer <br>    ) <br>{ <br>    try { <br>        while (Buffer) { <br>            PUT(("Next. . . . . . %08x\n" <br>                "Reserved. . . . %04x\n" <br>                "Data In Buffer. %04x\n" <br>                "User Data . . . %04x\n" <br>                "User Length . . %04x\n" <br>                "\n", <br>                Buffer-&gt;pNext, <br>                Buffer-&gt;usReserved1, <br>                Buffer-&gt;cbBuffer, <br>                Buffer-&gt;usReserved2, <br>                Buffer-&gt;cbUserData <br>                )); <br> <br>            IF_DEBUG(DUMP_TX_DATA) { <br>                DumpData(NULL, <br>                        (PBYTE)Buffer-&gt;auchData, <br>                        (DWORD)Buffer-&gt;cbBuffer + (DWORD)Buffer-&gt;cbUserData, <br>                        DD_DEFAULT_OPTIONS, <br>                        DEFAULT_FIELD_WIDTH <br>                        ); <br>            } <br>            Buffer = Buffer-&gt;pNext; <br>        } <br>    } except(1) { <br>        PUT(("*** Error: Bad Transmit Queue/Buffer @ %x ***\n", Buffer)); <br>    } <br>} <br> <br>PRIVATE <br>LPSTR <br>MapXmitReadOption( <br>    IN UCHAR Option <br>    ) <br>{ <br>    switch (Option) { <br>    case 0: <br>        return "Chain this Transmit on Link station basis"; <br> <br>    case 1: <br>        return "Do not chain this Transmit completion"; <br> <br>    case 2: <br>        return "Chain this Transmit on SAP station basis"; <br>    } <br>    return "*** Unknown XMIT_READ_OPTION ***"; <br>} <br> <br>VOID <br>DumpReceiveDataBuffer( <br>    IN PVOID Buffer <br>    ) <br>{ <br>    PLLC_BUFFER pBuf = (PLLC_BUFFER)Buffer; <br>    BOOL contiguous; <br>    WORD userLength; <br>    WORD dataLength; <br>    WORD userOffset; <br> <br>    try { <br>        contiguous = pBuf-&gt;Contiguous.uchOptions &amp; 0xc0; <br>        userLength = pBuf-&gt;Next.cbUserData; <br>        dataLength = pBuf-&gt;Next.cbBuffer; <br>        userOffset = pBuf-&gt;Next.offUserData; <br>    } except(1) { <br>        PUT(("*** Error: Bad received data buffer address %x ***\n", pBuf)); <br>        return; <br>    } <br> <br>    // <br>    // Buffer 1: [not] contiguous MAC/DATA <br>    // <br> <br>    try { <br>        PUT(("\n" <br>            "%sContiguous MAC/DATA frame @%08x\n" <br>            "next buffer . . %08x\n" <br>            "frame length. . %04x\n" <br>            "data length . . %04x\n" <br>            "user offset . . %04x\n" <br>            "user length . . %04x\n" <br>            "station id. . . %04x\n" <br>            "options . . . . %02x\n" <br>            "message type. . %02x [%s]\n" <br>            "buffers left. . %04x\n" <br>            "rcv FS. . . . . %02x\n" <br>            "adapter num . . %02x\n" <br>            "next frame. . . %08x\n", <br>            contiguous ? "" : "Not", <br>            pBuf, <br>            pBuf-&gt;Contiguous.pNextBuffer, <br>            pBuf-&gt;Contiguous.cbFrame, <br>            pBuf-&gt;Contiguous.cbBuffer, <br>            pBuf-&gt;Contiguous.offUserData, <br>            pBuf-&gt;Contiguous.cbUserData, <br>            pBuf-&gt;Contiguous.usStationId, <br>            pBuf-&gt;Contiguous.uchOptions, <br>            pBuf-&gt;Contiguous.uchMsgType, <br>            MapMessageType(pBuf-&gt;Contiguous.uchMsgType), <br>            pBuf-&gt;Contiguous.cBuffersLeft, <br>            pBuf-&gt;Contiguous.uchRcvFS, <br>            pBuf-&gt;Contiguous.uchAdapterNumber, <br>            pBuf-&gt;Contiguous.pNextFrame <br>            )); <br> <br>        if (!contiguous) { <br> <br>            // <br>            // dump NotContiguous header <br>            // <br> <br>            DWORD cbLanHeader = (DWORD)pBuf-&gt;NotContiguous.cbLanHeader; <br>            DWORD cbDlcHeader = (DWORD)pBuf-&gt;NotContiguous.cbDlcHeader; <br> <br>            PUT(("LAN hdr len . . %02x\n" <br>                "DLC hdr len . . %02x\n", <br>                cbLanHeader, <br>                cbDlcHeader <br>                )); <br>            DumpData("LAN header. . . ", <br>                    pBuf-&gt;NotContiguous.auchLanHeader, <br>                    cbLanHeader, <br>                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL, <br>                    DEFAULT_FIELD_WIDTH <br>                    ); <br>            DumpData("DLC header. . . ", <br>                    pBuf-&gt;NotContiguous.auchDlcHeader, <br>                    cbDlcHeader, <br>                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL, <br>                    DEFAULT_FIELD_WIDTH <br>                    ); <br> <br>            if (userLength) { <br>                DumpData("user space. . . ", <br>                        (PBYTE)pBuf + userOffset, <br>                        userLength, <br>                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL, <br>                        DEFAULT_FIELD_WIDTH <br>                        ); <br>            } else { <br>                PUT(("user space. . . \n")); <br>            } <br> <br>            IF_DEBUG(DUMP_RX_DATA) { <br> <br>                if (dataLength) { <br>                    DumpData("rcvd data . . . ", <br>                            (PBYTE)pBuf + userOffset + userLength, <br>                            dataLength, <br>                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE, <br>                            DEFAULT_FIELD_WIDTH <br>                            ); <br>                } else { <br>                    PUT(("rcvd data . . . \n")); <br>                } <br>            } <br>        } else { <br> <br>            // <br>            // dump Contiguous header <br>            // <br>            // data length is size of frame in contiguous buffer? <br>            // <br> <br>            if (userLength) { <br>                DumpData("user space. . . ", <br>                        (PBYTE)pBuf + userOffset, <br>                        userLength, <br>                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE, <br>                        DEFAULT_FIELD_WIDTH <br>                        ); <br>            } else { <br>                PUT(("user space. . . \n")); <br>            } <br> <br>            IF_DEBUG(DUMP_RX_DATA) { <br> <br>                dataLength = pBuf-&gt;Contiguous.cbFrame; <br> <br>                if (dataLength) { <br>                    DumpData("rcvd data . . . ", <br>                            (PBYTE)pBuf + userOffset + userLength, <br>                            dataLength, <br>                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE, <br>                            DEFAULT_FIELD_WIDTH <br>                            ); <br>                } else { <br>                    PUT(("rcvd data . . . \n")); <br>                } <br>            } <br>        } <br> <br>        // <br>        // dump second &amp; subsequent buffers <br>        // <br> <br>        IF_DEBUG(DUMP_DATA_CHAIN) { <br> <br>            for (pBuf = pBuf-&gt;pNext; pBuf; pBuf = pBuf-&gt;pNext) { <br> <br>                userLength = pBuf-&gt;Next.cbUserData; <br>                dataLength = pBuf-&gt;Next.cbBuffer; <br> <br>                PUT(("\n" <br>                    "Buffer 2/Subsequent @%08x\n" <br>                    "next buffer . . %08x\n" <br>                    "frame length. . %04x\n" <br>                    "data length . . %04x\n" <br>                    "user offset . . %04x\n" <br>                    "user length . . %04x\n", <br>                    pBuf, <br>                    pBuf-&gt;pNext, <br>                    pBuf-&gt;Next.cbFrame, <br>                    dataLength, <br>                    pBuf-&gt;Next.offUserData, <br>                    userLength <br>                    )); <br> <br>                if (userLength) { <br>                    DumpData("user space. . . ", <br>                            (PBYTE)&amp;pBuf + pBuf-&gt;Next.offUserData, <br>                            userLength, <br>                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE, <br>                            DEFAULT_FIELD_WIDTH <br>                            ); <br>                } else { <br>                    PUT(("user space. . . \n")); <br>                } <br> <br>                IF_DEBUG(DUMP_RX_DATA) { <br> <br>                    // <br>                    // there must be received data <br>                    // <br> <br>                    DumpData("rcvd data . . . ", <br>                            (PBYTE)pBuf + pBuf-&gt;Next.offUserData + userLength, <br>                            dataLength, <br>                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE, <br>                            DEFAULT_FIELD_WIDTH <br>                            ); <br>                } <br>            } <br>        } <br> <br>        if (((PLLC_BUFFER)Buffer)-&gt;Contiguous.pNextFrame) { <br>            DumpReceiveDataBuffer(((PLLC_BUFFER)Buffer)-&gt;Contiguous.pNextFrame); <br>        } <br> <br>    } except(1) { <br>        PUT(("*** Error: Bad Receive Data Buffer @ %x ***\n", Buffer)); <br>    } <br>} <br> <br>PRIVATE <br>LPSTR <br>MapMessageType( <br>    IN UCHAR MessageType <br>    ) <br>{ <br>    switch (MessageType) { <br>    case 0x00: <br>        return "Direct Transmit Frame"; <br> <br>    case 0x02: <br>        return "MAC Frame (Direct Station on Token Ring only)"; <br> <br>    case 0x04: <br>        return "I-Frame"; <br> <br>    case 0x06: <br>        return "UI-Frame"; <br> <br>    case 0x08: <br>        return "XID Command (POLL)"; <br> <br>    case 0x0a: <br>        return "XID Command (not POLL)"; <br> <br>    case 0x0c: <br>        return "XID Response (FINAL)"; <br> <br>    case 0x0e: <br>        return "XID Response (not FINAL)"; <br> <br>    case 0x10: <br>        return "TEST Response (FINAL)"; <br> <br>    case 0x12: <br>        return "TEST Response (not FINAL)"; <br> <br>    case 0x14: <br>        return "Direct 802.2/OTHER - non-MAC frame (Direct Station only)"; <br> <br>    case 0x16: <br>        return "TEST Command (POLL)"; <br> <br>    case 0x18: <br>        return "Direct Ethernet Frame"; <br> <br>    case 0x1a: <br>        return "Last Frame Type"; <br> <br>//    case 0x5dd: <br>//        return "First Ethernet Frame Type"; <br> <br>    default: <br>        return "*** BAD FRAME TYPE ***"; <br>    } <br>} <br> <br>//PRIVATE <br>//VOID <br>//DumpData( <br>//    IN PBYTE Address, <br>//    IN DWORD Length <br>//    ) <br>//{ <br>//    char dumpBuf[80]; <br>//    char* bufptr; <br>//    int i, n; <br>// <br>//    // <br>//    // the usual dump style: 16 columns of hex bytes, followed by 16 columns <br>//    // of corresponding ASCII characters, or '.' where the character is &lt; 0x20 <br>//    // (space) or &gt; 0x7f (del?) <br>//    // <br>// <br>//    while (Length) { <br>//        bufptr = dumpBuf; <br>//        bufptr += sprintf(bufptr, "%08x: ", Address); <br>//        if (Length &lt; 16) { <br>//            n = Length; <br>//        } else { <br>//            n = 16; <br>//        } <br>//        for (i = 0; i &lt; n; ++i) { <br>//            bufptr += sprintf(bufptr, "%02x", Address[i]); <br>//            if (i == 7) { <br>//                *bufptr = '-'; <br>//            } else { <br>//                *bufptr = ' '; <br>//            } <br>//            ++bufptr; <br>//        } <br>//        if (n &lt; 16) { <br>//            for (i = 0; i &lt; 16-n; ++i) { <br>//                bufptr += sprintf(bufptr, "   "); <br>//            } <br>//        } <br>//        bufptr += sprintf(bufptr, "  "); <br>//        for (i = 0; i &lt; n; ++i) { <br>//            if (Address[i] &lt; 0x20 || Address[i] &gt; 0x7f) { <br>//                *bufptr++ = '.'; <br>//            } else { <br>//                *bufptr++ = Address[i]; <br>//            } <br>//        } <br>//        *bufptr++ = '\n'; <br>//        *bufptr = 0; <br>//        PUT((dumpBuf)); <br>//        Length -= n; <br>//        Address += n; <br>//    } <br>//    PUT(("\n")); <br>//} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
