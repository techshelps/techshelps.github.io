<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHATDLG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5372"></a>CHATDLG.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995 Intel Corp <br> <br>Module Name: <br> <br>    dialog.c <br> <br>Abstract: <br> <br>    Contains dialog-box procedures for the WinSock2 Chat sample <br>    application.  See ws2chat.rc for the actual resource script. <br> <br>--*/ <br> <br>#include "nowarn.h"  /* turn off benign warnings */ <br>#ifndef _WINSOCKAPI_ <br>#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */ <br>#endif <br> <br>#include &lt;windows.h&gt; <br>#include "nowarn.h"  /* some warnings may have been turned back on */ <br>#include &lt;ws2atm.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;assert.h&gt; <br>#include "ws2chat.h" <br>#include "chatsock.h" <br>#include "chatdlg.h" <br>#include "resource.h" <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>ChooseFamilyDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the 'Choose <br>    Family' dialog box. <br> <br>Implementation <br> <br>    This dialog box is used to query the user as to which supported <br>    protocol he wishes to use for the chat connection he wishes to <br>    make.  The available protocols are listed in the IDC_FAM_LB <br>    listbox via the FillInFamilies function in socket.c. <br> <br>    It is expected that this dialog box gets the WM_INITDIALOG <br>    message with a LParam that is a pointer to the CONNDATA structure <br>    for the impending connection.  The result of this function is that <br>    the ProtocolInfo field of the ConnData struct is filled with a <br>    pointer to the protocol information structure the user chose in <br>    the listbox. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message. <br> <br>--*/ <br>{ <br>    int              LBIndex;         // index of the item chosen <br>    static PCONNDATA ConnData = NULL; // connection-specific data <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and fill in the listbox with the <br>        // available protocols. <br>        ConnData = (PCONNDATA)LParam; <br>        assert(ConnData != NULL); <br>        if (!FillInFamilies(DialogWindow, IDC_FAM_LB)) { <br>            MessageBox(DialogWindow, "FillInFamilies failed.", "Error.", <br>                        MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            EndDialog(DialogWindow, FALSE); <br>        } <br> <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the index of the listbox item the user has chosen. <br>            LBIndex = (int)SendMessage(GetDlgItem(DialogWindow, IDC_FAM_LB), <br>                                  LB_GETCURSEL, 0, 0); <br>            if (LBIndex == LB_ERR) { <br> <br>                // Nothing was selected. <br>                MessageBox(DialogWindow, "Choose an item, or hit cancel.", <br>                           "No Selection?", <br>                           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                return(TRUE); <br>            } <br> <br>            // Get the protocol associated with the listbox item the <br>            // user selected. <br>            ConnData-&gt;ProtocolInfo = GetProtoFromIndex(LBIndex); <br>            assert(ConnData-&gt;ProtocolInfo != NULL); <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            return(FALSE); <br>        } // switch (WParam) <br> <br>    default: <br> <br>        return(FALSE); <br>    } // switch (Message) <br> <br>} // ChooseFamilyDlgProc() <br> <br> <br> <br> <br>BOOL APIENTRY <br>InetConnDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the internet <br>    connection info dialog box. <br> <br>Implementation <br> <br>    This dialog box gets two strings from the user: the internet <br>    address and port to which she wants to make a chat connection. <br>    When the user clicks on the OK button, these two strings are <br>    converted into a sockaddr_in structure and a pointer to this <br>    structure is saved in the connection window's CONNDATA structure. <br> <br>    NOTE: No name resolution takes place here!  The address edit <br>    control expects up to 15 characters, and this string is expected <br>    to be in.dotted.decimal.notation.  When RNR is available, this is <br>    where it would be called upon to provide the appropriate <br>    sockaddr_in structure.  Actually, this dialog box would be <br>    replaced with a protocol independent name dialog box; RNR would do <br>    all the rest... <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br> <br>{ <br>    char               PortText[INET_PORT_LEN + 1];   // holds port string <br>    char               AddressText[INET_ADDR_LEN + 1];// holds addr string <br>    static PCONNDATA   ConnData = NULL;               // conn-specific data <br>    struct sockaddr_in *SockAddrInet;                 // Inet socket address <br>    u_long             InetAddr;                      // Inet-style address <br>    u_short            InetPort;                      // Inet-style port <br>    int                Port;                          // intermediate var. <br>    BOOL               PortStringTranslated;          // for GetDlgItemInt <br>    struct hostent *host; <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the connection data pointer, initialize the dialog box. <br>        ConnData = (PCONNDATA)LParam; <br>        assert(ConnData != NULL); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_INET_ADDRESS), <br>                    EM_LIMITTEXT, (WPARAM)INET_ADDR_LEN, 0); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_INET_PORT), <br>                    EM_LIMITTEXT, (WPARAM)INET_PORT_LEN, 0); <br>        wsprintf(PortText,"%d", INET_DEFAULT_PORT); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_INET_PORT), <br>                    WM_SETTEXT, 0, (LPARAM)PortText); <br>        SetFocus(GetDlgItem(DialogWindow, IDC_INET_ADDRESS)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // The user has pressed the 'OK' button.  Extract the <br>            // internet address into a buffer and check the value the <br>            // user typed for the port. <br>            GetDlgItemText(DialogWindow, <br>                           IDC_INET_ADDRESS, <br>                           AddressText, <br>                           INET_ADDR_LEN); <br>            strcpy(ConnData-&gt;PeerAddress, AddressText); <br>            Port = (int)GetDlgItemInt(DialogWindow, <br>                                      IDC_INET_PORT, <br>                                      &amp;PortStringTranslated, <br>                                      TRUE); <br>            if ((Port &lt; 0) || (Port &gt; 65535) || !PortStringTranslated) { <br>              MessageBox(DialogWindow, <br>                         "Please choose a port between 0 and 65535.", <br>                         "Bad Port.", <br>                         MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                return(TRUE); <br>            } <br> <br>            // Convert the address string to an unsigned long, and <br>            // convert the port integer to an unsigned short.  If all <br>            // goes well, fill in the fields and end the dialog box. <br>            // If not, inform the user and *don't* kill the dialog box. <br>            InetAddr = inet_addr(AddressText); <br>            if (InetAddr == INADDR_NONE) { <br>                host = gethostbyname(AddressText); <br>                if (host) { <br>                    InetAddr = *((u_long *)host-&gt;h_addr_list[0]); <br>                } <br>            } <br>            InetPort = (u_short)Port; <br>            if ((InetAddr != INADDR_NONE) &amp;&amp; (InetAddr != 0)) { <br> <br>                // Allocate memory for an internet-style socket address; <br>                // point ConnData-&gt;SockAddr at this memory, and <br>                // use a local pointer to a struct sockaddr_in to <br>                // reference the fields. <br>                ConnData-&gt;RemoteSockAddr.len = sizeof(struct sockaddr_in); <br>                ConnData-&gt;RemoteSockAddr.buf = <br>                  malloc(ConnData-&gt;RemoteSockAddr.len); <br>                if (ConnData-&gt;RemoteSockAddr.buf == NULL) { <br>                    ChatSysError("malloc()", <br>                                 "InetConnDlgProc()", <br>                                 TRUE); <br>                } <br> <br>                SockAddrInet = <br>                  (struct sockaddr_in *)ConnData-&gt;RemoteSockAddr.buf; <br>                SockAddrInet-&gt;sin_family = AF_INET; <br>                SockAddrInet-&gt;sin_port = htons(InetPort); <br>                SockAddrInet-&gt;sin_addr.S_un.S_addr = InetAddr; <br>                EndDialog(DialogWindow, TRUE); <br>                return(TRUE); <br> <br>            } <br> <br>            MessageBox(DialogWindow, <br>                       "Invalid Internet address. Try again or cancel.", <br>                       "Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // The user has pressed cancel.  Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            break; <br>        } // switch (WParam) <br> <br>        break; <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // InetConnDlgProc() <br> <br> <br>VOID ShowMessage( <br>    HWND hWnd, <br>    PSTR pMsg) <br>    /* <br>    Routine Description: <br>            Just pop up an error message box. <br>    */ <br>{ <br>    MessageBox(NULL, pMsg, "WS2Test", MB_OK); <br>} // ShowMessage <br> <br> <br>BOOL ScanAtmAddress( <br>    HWND        hWndDlg, <br>    ATM_ADDRESS *pAtmAddr) <br>    /* <br>        Routine Description: <br>            Scanner of ATM Address af a field of ATM socket address. <br>    */ <br>{ <br>    UCHAR textBuf[MAX_ADDRESS_TEXT]; <br>    UINT value[ATM_ADDR_LENGTH];     // for sscanf <br>    DWORD length; <br>    int scanResult; <br>    UINT i; <br>    HWND hWndControl; <br>    UINT selection; <br> <br>    hWndControl = GetDlgItem(hWndDlg, IDC_ADDR_TYPE); <br>    selection = ListBox_GetCurSel(hWndControl); <br>    pAtmAddr-&gt;AddressType = AtmAddrTypeValue[selection]; <br> <br>    length = GetDlgItemText(hWndDlg, IDC_ATM_ADDR, textBuf, sizeof(textBuf)); <br>    if (pAtmAddr-&gt;AddressType == ATM_E164) <br>    { <br>        memcpy(pAtmAddr-&gt;Addr, textBuf, length); <br>        pAtmAddr-&gt;NumofDigits = length; <br>    } <br>    else if (pAtmAddr-&gt;AddressType != SAP_FIELD_ANY) <br>    { <br>        scanResult = sscanf( <br>            textBuf, <br>            "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x", <br>            &amp;value[0], &amp;value[1], &amp;value[2], &amp;value[3], &amp;value[4], <br>            &amp;value[5], &amp;value[6], &amp;value[7], &amp;value[8], &amp;value[9], <br>            &amp;value[10], &amp;value[11], &amp;value[12], &amp;value[13], &amp;value[14], <br>            &amp;value[15], &amp;value[16], &amp;value[17], &amp;value[18], &amp;value[19]); <br>        if (scanResult != ATM_ADDR_LENGTH) <br>        { <br>            ShowMessage(hWndDlg, "Invalid value for ATM address."); <br>            return FALSE; <br>        } // if <br>        for (i = 0; i &lt; ATM_ADDR_LENGTH; i++) <br>        { <br>            pAtmAddr-&gt;Addr[i] = value[i]; <br>        } <br>        pAtmAddr-&gt;NumofDigits = ATM_ADDR_LENGTH; <br>    } <br> <br>    return TRUE; <br> <br>} // ScanAtmAddress <br> <br> <br> <br>BOOL ScanAtmBlli( <br>    HWND hWndDlg, <br>    ATM_BLLI *pBLLI) <br>    /* <br>        Routine Description: <br>            Scanner of BLLI af a field of ATM socket address. <br>    */ <br>{ <br>    UCHAR textBuf[MAX_PARSE_TEXT]; <br>    UINT value[ATM_SNAP_ID_LENGTH]; <br>    HWND hWndControl; <br>    UINT selection; <br>    UINT length; <br>    int scanResult; <br>    UINT i; <br> <br>    hWndControl = GetDlgItem(hWndDlg, IDC_L2PROTO); <br>    selection = ListBox_GetCurSel(hWndControl); <br>    pBLLI-&gt;Layer2Protocol = AtmBlliL2ProtoValue[selection]; <br> <br>    length = GetDlgItemText(hWndDlg, IDC_L2USER_PROTO, textBuf, sizeof(textBuf)); <br>    if (length != 0) <br>    { <br>        if (sscanf(textBuf, "%u", &amp;value[0]) != 1) <br>        { <br>            ShowMessage(hWndDlg, "Invalid value for user specified layer 2 protocol info."); <br>            return FALSE; <br>        } // if <br>        else <br>        { <br>            pBLLI-&gt;Layer2UserSpecifiedProtocol = value[0]; <br>        } <br>    } <br>    else <br>    { <br>        pBLLI-&gt;Layer2UserSpecifiedProtocol = SAP_FIELD_ABSENT; <br>    } <br> <br>    hWndControl = GetDlgItem(hWndDlg, IDC_L3PROTO); <br>    selection = ListBox_GetCurSel(hWndControl); <br>    pBLLI-&gt;Layer3Protocol = AtmBlliL3ProtoValue[selection]; <br> <br>    length = GetDlgItemText(hWndDlg, IDC_L3USER_PROTO, textBuf, sizeof(textBuf)); <br>    if (length != 0) <br>    { <br>        if (sscanf(textBuf, "%u", &amp;value[0]) != 1) <br>        { <br>            ShowMessage(hWndDlg, "Invalid value for user specified layer 3 protocol info."); <br>            return FALSE; <br>        } // if <br>        else <br>        { <br>            pBLLI-&gt;Layer3UserSpecifiedProtocol = value[0]; <br>        } <br>    } <br>    else <br>    { <br>        pBLLI-&gt;Layer3UserSpecifiedProtocol = SAP_FIELD_ABSENT; <br>    } <br> <br>    hWndControl = GetDlgItem(hWndDlg, IDC_L3IPI); <br>    selection = ListBox_GetCurSel(hWndControl); <br>    pBLLI-&gt;Layer3IPI = AtmBlliL3IpiValue[selection]; <br> <br>    length = GetDlgItemText(hWndDlg, IDC_SNAP_ID, textBuf, sizeof(textBuf)); <br>    if (length &gt; 0) <br>    { <br>        scanResult = sscanf( <br>            textBuf, <br>            "%x.%x.%x.%x.%x", <br>            &amp;value[0], &amp;value[1], &amp;value[2], &amp;value[3], &amp;value[4]); <br>        if (scanResult != ATM_SNAP_ID_LENGTH) <br>        { <br>            ShowMessage(hWndDlg, "Invalid value for SNAP ID."); <br>            return FALSE; <br>        } // if <br>        for (i = 0; i &lt; ATM_SNAP_ID_LENGTH; i++) <br>        { <br>            pBLLI-&gt;SnapID[i] = value[i]; <br>        } <br>    } <br>    else <br>    { <br>        memset(pBLLI-&gt;SnapID, 0, ATM_SNAP_ID_LENGTH); <br>    } <br> <br>    return TRUE; <br> <br>} // ScanBlli <br> <br> <br> <br>BOOL ScanAtmBhli( <br>    HWND hWndDlg, <br>    ATM_BHLI *pBHLI) <br>    /* <br>        Routine Description: <br>            Scanner of BHLI af a field of ATM socket address. <br>    */ <br>{ <br>    UCHAR textBuf[MAX_PARSE_TEXT]; <br>    UCHAR value[ATM_HL_INFO_LENGTH]; <br>    HWND hWndControl; <br>    UINT selection; <br>    UINT length; <br>    UINT i; <br>    int scanResult; <br> <br>    hWndControl = GetDlgItem(hWndDlg, IDC_BHLI_TYPE); <br>    selection = ListBox_GetCurSel(hWndControl); <br>    pBHLI-&gt;HighLayerInfoType = AtmBhliTypeValue[selection]; <br>    if (pBHLI-&gt;HighLayerInfoType != BHLI_UserSpecific) { <br>        ShowMessage(hWndDlg, "Please choose user specific for BHLI type."); <br>        return FALSE; <br>    } <br> <br>    length = GetDlgItemText(hWndDlg, IDC_BHLI, textBuf, sizeof(textBuf)); <br>    if (length != 0) <br>    { <br>        scanResult = sscanf( <br>            textBuf, <br>            "%c%c%c%c%c%c%c%c", <br>            &amp;value[0], &amp;value[1], &amp;value[2], &amp;value[3], <br>            &amp;value[4], &amp;value[5], &amp;value[6], &amp;value[7]); <br> <br>        if ((scanResult != ATM_HL_INFO_LENGTH)) <br>        { <br>            ShowMessage(hWndDlg, "High Layer Information is a string of 8 chars."); <br>            return FALSE; <br>        } // if <br>        pBHLI-&gt;HighLayerInfoLength = (DWORD)scanResult; <br>        for (i = 0; i &lt; pBHLI-&gt;HighLayerInfoLength; i++) <br>        { <br>            pBHLI-&gt;HighLayerInfo[i] = value[i]; <br>        } <br>    } <br>    else <br>    { <br>        pBHLI-&gt;HighLayerInfoLength = 0; <br>        memset(pBHLI-&gt;HighLayerInfo, 0, ATM_HL_INFO_LENGTH); <br>    } <br> <br>    return TRUE; <br>} // ScanAtmBhli <br> <br> <br>int InitSelection( <br>    DWORD   InitValue, <br>    int     NumOfValues, <br>    DWORD * ValueList) <br>{ <br>    int i; <br>    for (i=0; i&lt;NumOfValues; i++) { <br>        if (InitValue == ValueList[i]) { <br>            return i; <br>        } <br>    } <br>    return -1; <br> <br>} <br> <br> <br>BOOL APIENTRY <br>ATMSockAddrProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the native ATM <br>    connection info dialog box. <br> <br>Implementation <br> <br>    This dialog box gets the ATM socket address for connection party. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br> <br>{ <br> <br>    static PCONNDATA   ConnData = NULL;               // conn-specific data <br>    HWND hListBox; <br>    int i; <br>    UCHAR textBuf[MAX_ERROR_TEXT]; <br>    static struct sockaddr_atm * pATMSockAddr; <br>    UINT selection; <br> <br>    switch (Message) { <br> <br>        case WM_INITDIALOG: <br> <br>            // Get the connection data pointer, initialize the dialog box. <br>            pATMSockAddr = (struct sockaddr_atm *)LParam; <br>            assert(pATMSockAddr != NULL); <br> <br>            //Initialize ATM address type list box <br>            hListBox = GetDlgItem(DialogWindow, IDC_ADDR_TYPE); <br>            for (i = 0; i &lt; NUM_ATM_ADDR_TYPES; i++) <br>            { <br>                ListBox_AddString(hListBox, AtmAddrTypeName[i]); <br>            } <br>            i = InitSelection(pATMSockAddr-&gt;satm_number.AddressType, <br>                                 NUM_ATM_ADDR_TYPES, <br>                                 AtmAddrTypeValue); <br>            if (i&gt;=0) { <br>                ListBox_SetCurSel(hListBox, i); <br>            } <br> <br>            if(AtmAddrTypeValue[i] == SAP_FIELD_ANY) { <br>                EnableWindow(GetDlgItem(DialogWindow, IDC_ATM_ADDR), FALSE); <br>            } <br>            else { <br>                //Initialize ATM address edit box <br>                sprintf(textBuf, <br>                    "%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x.%02x", <br>                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0); <br>                SetDlgItemText(DialogWindow, IDC_ATM_ADDR, textBuf); <br>            } <br> <br>            //Initialize Layer 2 protocol list box <br>            hListBox = GetDlgItem(DialogWindow, IDC_L2PROTO); <br>            for (i = 0; i &lt; NUM_BLLI_L2PROTO; i++) <br>            { <br>                ListBox_AddString(hListBox, AtmBlliL2ProtoName[i]); <br>            } <br>            i = InitSelection(pATMSockAddr-&gt;satm_blli.Layer2Protocol, <br>                              NUM_BLLI_L2PROTO, <br>                              AtmBlliL2ProtoValue); <br>            if (i&gt;=0) { <br>                ListBox_SetCurSel(hListBox, i); <br>            } <br>            if (AtmBlliL2ProtoValue[i] != BLLI_L2_USER_SPECIFIED) { <br>                EnableWindow(GetDlgItem(DialogWindow, IDC_L2USER_PROTO), FALSE); <br>            } <br> <br>            //Initialize Layer 3 protocol list box <br>            hListBox = GetDlgItem(DialogWindow, IDC_L3PROTO); <br>            for (i = 0; i &lt; NUM_BLLI_L3PROTO; i++) <br>            { <br>                ListBox_AddString(hListBox, AtmBlliL3ProtoName[i]); <br>            } <br>            i = InitSelection(pATMSockAddr-&gt;satm_blli.Layer3Protocol, <br>                              NUM_BLLI_L3PROTO, <br>                              AtmBlliL3ProtoValue); <br>            if (i&gt;=0) { <br>                ListBox_SetCurSel(hListBox, i); <br>            } <br> <br>            if (AtmBlliL3ProtoValue[i] != BLLI_L3_USER_SPECIFIED) { <br>                EnableWindow(GetDlgItem(DialogWindow, IDC_L3USER_PROTO), FALSE); <br>            } <br> <br>            //Initialize Layer 3 IPI list box <br>            hListBox = GetDlgItem(DialogWindow, IDC_L3IPI); <br>            for (i = 0; i &lt; NUM_BLLI_L3IPI; i++) <br>            { <br>                ListBox_AddString(hListBox, AtmBlliL3IpiName[i]); <br>            } <br>            i = InitSelection(pATMSockAddr-&gt;satm_blli.Layer3IPI, <br>                              NUM_BLLI_L3IPI, <br>                              AtmBlliL3IpiValue); <br>            if (i&gt;=0) { <br>                ListBox_SetCurSel(hListBox, i); <br>            } <br> <br>            if (AtmBlliL3IpiValue[i] != BLLI_L3_IPI_SNAP) { <br>                EnableWindow(GetDlgItem(DialogWindow, IDC_SNAP_ID), FALSE); <br>            } <br>            else { <br>                //Initialize SnapID edit control <br>                sprintf(textBuf, "%02x.%02x.%02x.%02x.%02x", 0,0,0,0,0); <br>                SetDlgItemText(DialogWindow, IDC_SNAP_ID, textBuf); <br>            } <br> <br>            if (AtmBlliL3ProtoValue[i] != BLLI_L3_ISO_TR9577) { <br>                EnableWindow(GetDlgItem(DialogWindow, IDC_L3IPI), FALSE); <br>                EnableWindow(GetDlgItem(DialogWindow, IDC_SNAP_ID), FALSE); <br>            } <br> <br>            //Initialize high layer info type list box <br>            hListBox = GetDlgItem(DialogWindow, IDC_BHLI_TYPE); <br>            for (i = 0; i &lt; NUM_BHLI_TYPES; i++) <br>            { <br>                ListBox_AddString(hListBox, AtmBhliTypeName[i]); <br>            } <br>            i = InitSelection(pATMSockAddr-&gt;satm_bhli.HighLayerInfoType, <br>                              NUM_BHLI_TYPES, <br>                              AtmBhliTypeValue); <br>            if (i&gt;=0) { <br>                ListBox_SetCurSel(hListBox, i); <br>            } <br> <br>            if (AtmBhliTypeValue[i] == SAP_FIELD_ABSENT || <br>                AtmBhliTypeValue[i] == SAP_FIELD_ANY) { <br>                EnableWindow(GetDlgItem(DialogWindow, IDC_BHLI), FALSE); <br>            } <br>            else { <br>                //Initialize high layer info edit control <br>                if (pATMSockAddr-&gt;satm_bhli.HighLayerInfoType == BHLI_UserSpecific) { <br>                    SetDlgItemText(DialogWindow, IDC_BHLI, ATM_DEFAULT_BHLI_INFO); <br>                } <br>            } <br> <br>            return(FALSE); <br> <br>        case WM_COMMAND: <br> <br>            switch ((USHORT)WParam) { <br> <br>                case IDC_ADDR_TYPE: <br>                    hListBox = GetDlgItem(DialogWindow, IDC_ADDR_TYPE); <br>                    selection = ListBox_GetCurSel(hListBox); <br>                    if (AtmAddrTypeValue[selection] != SAP_FIELD_ANY) { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_ATM_ADDR), TRUE); <br>                    } <br>                    else { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_ATM_ADDR), FALSE); <br>                    } <br>                    break; <br> <br>                case IDC_L2PROTO: <br>                    hListBox = GetDlgItem(DialogWindow, IDC_L2PROTO); <br>                    selection = ListBox_GetCurSel(hListBox); <br>                    if (AtmBlliL2ProtoValue[selection] == BLLI_L2_USER_SPECIFIED) { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_L2USER_PROTO), TRUE); <br>                    } <br>                    else { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_L2USER_PROTO), FALSE); <br>                    } <br>                    break; <br> <br>                case IDC_L3PROTO: <br>                    hListBox = GetDlgItem(DialogWindow, IDC_L3PROTO); <br>                    selection = ListBox_GetCurSel(hListBox); <br>                    if (AtmBlliL3ProtoValue[selection] == BLLI_L3_USER_SPECIFIED) { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_L3USER_PROTO), TRUE); <br>                    } <br>                    else { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_L3USER_PROTO), FALSE); <br>                    } <br>                    if (AtmBlliL3ProtoValue[selection] == BLLI_L3_ISO_TR9577) { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_L3IPI), TRUE); <br>                        hListBox = GetDlgItem(DialogWindow, IDC_L3IPI); <br>                        selection = ListBox_GetCurSel(hListBox); <br>                        if (AtmBlliL3IpiValue[selection] == BLLI_L3_IPI_SNAP) { <br>                            EnableWindow(GetDlgItem(DialogWindow, IDC_SNAP_ID), TRUE); <br>                        } <br>                        else { <br>                            EnableWindow(GetDlgItem(DialogWindow, IDC_SNAP_ID), FALSE); <br>                        } <br>                    } <br>                    else { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_L3IPI), FALSE); <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_SNAP_ID), FALSE); <br>                    } <br>                    break; <br> <br>                case IDC_L3IPI: <br>                    hListBox = GetDlgItem(DialogWindow, IDC_L3IPI); <br>                    selection = ListBox_GetCurSel(hListBox); <br>                    if (AtmBlliL3IpiValue[selection] == BLLI_L3_IPI_SNAP) { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_SNAP_ID), TRUE); <br>                    } <br>                    else { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_SNAP_ID), FALSE); <br>                    } <br>                    break; <br> <br>                case IDC_BHLI_TYPE: <br>                    hListBox = GetDlgItem(DialogWindow, IDC_BHLI_TYPE); <br>                    selection = ListBox_GetCurSel(hListBox); <br>                    if (AtmBhliTypeValue[selection] == SAP_FIELD_ABSENT || <br>                        AtmBhliTypeValue[selection] == SAP_FIELD_ANY) { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_BHLI), FALSE); <br>                    } <br>                    else { <br>                        EnableWindow(GetDlgItem(DialogWindow, IDC_BHLI), TRUE); <br>                    } <br>                    break; <br> <br>                case IDOK: <br>                    if ((ScanAtmAddress(DialogWindow, &amp;pATMSockAddr-&gt;satm_number)) &amp;&amp; <br>                        (ScanAtmBlli(DialogWindow, &amp;pATMSockAddr-&gt;satm_blli)) &amp;&amp; <br>                        (ScanAtmBhli(DialogWindow, &amp;pATMSockAddr-&gt;satm_bhli))) <br>                    { <br>                        pATMSockAddr-&gt;satm_family = AF_ATM; <br>                        EndDialog(DialogWindow, TRUE); <br>                        return TRUE; <br>                    } <br> <br>                    return FALSE; <br> <br>                case IDCANCEL: <br> <br>                    // The user has pressed cancel.  Kill the dialog box. <br>                    EndDialog(DialogWindow, FALSE); <br>                    return(TRUE); <br> <br>            default: <br> <br>                break; <br>            } // switch (WParam) <br> <br>            break; <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // ATMSockAddrProc() <br> <br> <br> <br>  <br>BOOL APIENTRY <br>DefaultConnDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the default <br>    connection info dialog box. <br> <br>Implementation <br> <br>    This dialog box is the default when chat doesn't recognize a <br>    particular address family.  The user enters actual hex digits and <br>    the hex value is stored in the SocketAddress associated with the <br>    connection. Obviously, this requires the user to know how to <br>    interpret the structure of the socket address for this address <br>    family. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message. <br> <br>--*/ <br>{ <br> <br>    static PCONNDATA ConnData = NULL;                // connection data <br>    static int       AddrLen;                        // length of addresses <br>    char             AddrText[MAX_SOCKADDR_LEN * 2]; // address string <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and figure out how long addresses for <br>        // this protocol may be. <br>        ConnData = (PCONNDATA)LParam; <br>        assert(ConnData != NULL); <br> <br>        AddrLen = ConnData-&gt;ProtocolInfo-&gt;iMaxSockAddr; <br> <br>        if (AddrLen &gt; MAX_SOCKADDR_LEN) { <br>            MessageBox(DialogWindow, <br>                       "Sorry, socket addresses are too big. Aborting.", <br>                       "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            EndDialog(DialogWindow, FALSE); <br>        } <br> <br>        // Limit the amount of text in the edit control to twice <br>        // AddrLen, i.e. 2 hex characters per byte. <br>        SendMessage(GetDlgItem(DialogWindow, IDC_ADDRESS), EM_LIMITTEXT, <br>                    (WPARAM)(AddrLen * 2), 0); <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // The user clicked 'OK'.  Get the text from the edit <br>            // control, and convert the hex string into bytes and put <br>            // the bytes into the socket address for this connection. <br>            GetDlgItemText(DialogWindow, IDC_ADDRESS, AddrText, <br>                           MAX_SOCKADDR_LEN * 2); <br>            ConnData-&gt;RemoteSockAddr.len = AddrLen; <br>            ConnData-&gt;RemoteSockAddr.buf = <br>              malloc(ConnData-&gt;RemoteSockAddr.len); <br>            if (ConnData-&gt;RemoteSockAddr.buf == NULL) { <br>                ChatSysError("malloc()", </code></pre>
<p>
</p>
<pre><code>"DefaultConnDlgProc()", <br>                             TRUE); <br>            } <br> <br>            if (TranslateHex(ConnData-&gt;RemoteSockAddr.buf, <br>                             ConnData-&gt;RemoteSockAddr.len, <br>                             AddrText, <br>                             DialogWindow)) { <br>                EndDialog(DialogWindow, TRUE); <br>            } <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            return(FALSE); <br>        } // switch (WParam) <br> <br>    default: <br> <br>        return(FALSE); <br>    } // switch (Message) <br> <br>} // DefaultConnDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>NameAndSubjectDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the name and <br>    subject dialog box. <br> <br>Implementation <br> <br>    This dialog box is brought up in MakeConnection (see socket.c) <br>    only if the protocol for the connection to be made supports <br>    connection-time data transfer.  The user fills in the two fields <br>    and this data is packed the WSABUF which is referenced through a <br>    pointer passed in during WM_INITDIALOG processing. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br>{ <br> <br>    static LPWSABUF CallerBuffer;            // caller user data <br>    char            NameText[NAME_LEN + 1];  // name string <br>    char            SubjectText[SUB_LEN + 1];// subject string <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and initialize the dialog box. <br>        CallerBuffer = (LPWSABUF)LParam; <br>        assert(CallerBuffer != NULL); <br> <br>        SendMessage(GetDlgItem(DialogWindow, IDC_CALLERNAME), <br>                    EM_LIMITTEXT, (WPARAM)NAME_LEN, 0); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_SUBJECT), <br>                    EM_LIMITTEXT, (WPARAM)SUB_LEN, 0); <br>        SetFocus(GetDlgItem(DialogWindow, IDC_CALLERNAME)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the strings the user has typed. <br>            GetDlgItemText(DialogWindow, <br>                           IDC_CALLERNAME, <br>                           NameText, <br>                           NAME_LEN); <br>            GetDlgItemText(DialogWindow, <br>                           IDC_SUBJECT, <br>                           SubjectText, <br>                           SUB_LEN); <br> <br>            CallerBuffer-&gt;len = strlen(NameText) + strlen(SubjectText) + 2; <br>            CallerBuffer-&gt;buf = (char *)malloc(CallerBuffer-&gt;len); <br>            if (CallerBuffer-&gt;buf == NULL) { <br>                ChatSysError("malloc()", <br>                             "NameAndSubjectDlgProc()", <br>                             TRUE); <br>            } <br> <br>            if (!PackTwoStrings(CallerBuffer-&gt;buf, <br>                                CallerBuffer-&gt;len, <br>                                NameText, <br>                                SubjectText)) { <br>                MessageBox(DialogWindow, "PackTwoStrings failed. Aborting.", <br>                           "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                EndDialog(DialogWindow, FALSE); <br>            } <br> <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            return(FALSE); <br>        } // switch (WParam) <br> <br>    default: <br> <br>        return(FALSE); <br>    } // switch (Message) <br> <br>} // NameAndSubjectDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>AcceptConnectionDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the <br>    AcceptConnection dialog box.  Get's the callee's name and copies <br>    it into the CalleeBuffer, which is passed in as a parameter to the <br>    WM_INITDIALOG message. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the AcceptConnection dialog box <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br> <br>{ <br>    static LPWSABUF CalleeData; // callee user data <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        CalleeData = (LPWSABUF)LParam; <br>        assert(CalleeData != NULL); <br> <br>        // Determine how much room there is in the user data buffer. <br>        // Limit the text to NAME_LEN characters, or less if we <br>        // don't have room for that many. <br>        if (CalleeData-&gt;len &lt; (NAME_LEN + 1)) { <br>            SendMessage(GetDlgItem(DialogWindow, IDC_CALLERNAME), <br>                        EM_LIMITTEXT, (WPARAM)(CalleeData-&gt;len - 1), <br>                        0); <br>        } else { <br>            SendMessage(GetDlgItem(DialogWindow, IDC_CALLERNAME), <br>                        EM_LIMITTEXT, (WPARAM)NAME_LEN, 0); <br>        } <br>        SetFocus(GetDlgItem(DialogWindow, IDC_CALLEENAME)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the name from the control and but it in CalleeData. <br>            GetDlgItemText(DialogWindow, <br>                           IDC_CALLEENAME, <br>                           CalleeData-&gt;buf, <br>                           NAME_LEN); <br>            CalleeData-&gt;len = strlen(CalleeData-&gt;buf + 1); <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            break; <br> <br>        } <br> <br>        break; <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // AcceptConnectionDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>InetListenPortDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the <br>    listening port dialog box. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the AcceptConnection dialog box <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br>{ <br> <br>    static struct sockaddr_in *SockAddrInet;             // Inet sockaddress <br>    int                       Port;                      // Inet port <br>    BOOL                      PortStringTranslated;      // for GetDlgItemInt <br>    char                      PortText[INET_PORT_LEN+1]; // Inet port string <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and initialize the dialog box. <br>        SockAddrInet = (struct sockaddr_in *)LParam; <br>        assert(SockAddrInet != NULL); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_LISTEN_PORT), <br>                    EM_LIMITTEXT, (WPARAM)INET_PORT_LEN, 0); <br>        wsprintf(PortText,"%d", INET_DEFAULT_PORT); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_LISTEN_PORT), <br>                    WM_SETTEXT, 0, (LPARAM)PortText); <br>        SetFocus(GetDlgItem(DialogWindow, IDC_LISTEN_PORT)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the port. <br>            Port = (int)GetDlgItemInt(DialogWindow, <br>                                      IDC_LISTEN_PORT, <br>                                      &amp;PortStringTranslated, <br>                                      TRUE); <br>            if ((Port &lt; 0) || (Port &gt; 65535) || !PortStringTranslated) { <br>                MessageBox(DialogWindow, <br>                           "Please choose a port between 0 and 65535.", <br>                           "Bad Port.", <br>                           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                return(TRUE); <br>            } <br> <br>            SockAddrInet-&gt;sin_port = htons((u_short)Port); <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br>            break; <br>        } <br>        break; <br> <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // InetListenPortDlgProc() </code></pre>
<p>&nbsp;</p></body>
</HTML>
