<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WS2CHAT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5374"></a>WS2CHAT.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995 Intel Corp <br> <br>Module Name: <br> <br>    ws2chat.c <br> <br>Abstract: <br> <br>    Contains WinMain and other user interface code for the WinSock2 <br>    Chat sample application. <br> <br>--*/ <br> <br> <br>#include "nowarn.h"  /* turn off benign warnings */ <br>#ifndef _WINSOCKAPI_ <br>#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */ <br>#endif <br>#include &lt;windows.h&gt; <br> <br>#include "nowarn.h"  /* some warnings may have been turned back on */ <br>#include &lt;stdlib.h&gt; <br>#include "ws2chat.h" <br>#include "chatsock.h" <br>#include "chatdlg.h" <br>#include "queue.h" <br> <br> <br>// <br>// Forward References -- internal functions. <br>// <br> <br>// Startup/Initialization Functions <br>int PASCAL <br>WinMain( <br>    IN HINSTANCE InstanceHandle, <br>    IN HINSTANCE PrevInstanceHandle, <br>    IN LPSTR  CmdLine, <br>    IN int    CmdShow); <br> <br>BOOL <br>InitUI( <br>    IN HINSTANCE InstanceHandle, <br>    IN HINSTANCE PrevInstanceHandle); <br> <br>long CALLBACK <br>MainWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam); <br> <br>long CALLBACK <br>ConnWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam); <br> <br>long CALLBACK <br>SendEditSubClass( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam); <br> <br>long CALLBACK <br>RecvEditSubClass( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam); <br> <br>BOOL CALLBACK <br>CloseEnumProc( <br>    IN HWND WindowHandle, <br>    IN LONG LParam); <br> <br>BOOL <br>GetConnectionInfo( <br>    IN HWND ConnectionWindow); <br> <br>void <br>QueryAndMaximize(void); <br> <br> <br>// <br>// Static Global Variables <br>// <br> <br>static HMENU   MainMenu;       // the main MDI menu <br>static HMENU   MainMenuWindow; // the window associated with the above <br>static FARPROC OldEditWndProc; // edit control WndProc before subclassing <br> <br> <br> <br>// <br>// Externally-Visible Global Variables <br>// <br> <br>HANDLE  GlobalInstance;                  // ientifies the instance of chat <br>char    ConnClassStr[] = "ConnChild";    // string to register window class <br>char    ChatClassStr[] = "WS2ChatFrame"; // string to register window class <br>HWND    GlobalFrameWindow;               // Chat's main (frame) window <br> <br> <br> <br>// <br>// Function Definitions <br>// <br> <br>  <br>int CALLBACK <br>WinMain( <br>    IN HINSTANCE InstanceHandle, <br>    IN HINSTANCE PrevInstanceHandle, <br>    IN LPSTR  CmdLine, <br>    IN int    CmdShow) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    WinMain is the main entry point for WinSock 2 Chat.  This function <br>    calls initialization functions and goes into a message loop. <br> <br>Arguments: <br> <br>    InstanceHandle -- Supplies the current instance handle. <br> <br>    PrevInstanceHandle -- Supplies the previous instance handle. <br> <br>    CmdLine -- Supplies the address of the command line. <br> <br>    CmdShow -- Supplies the show state of the window. <br> <br>Return Value: <br> <br>    0 -- Initialization failure <br> <br>    !0 -- Returns the Message.wParam of the WM_QUIT message that ended <br>    the message loop. <br> <br>--*/ <br>{ <br>    HANDLE   AccelTable;   // handle to the accelerator table <br>    HWND     ClientWindow; // MDI Client window <br>    MSG      Message;      // holds the message <br>    int      ReturnValue;  // return value <br> <br>    ReturnValue = 0; <br>    GlobalInstance = InstanceHandle; <br> <br>    // Initialize Chat. <br>    if (!InitUI(InstanceHandle, PrevInstanceHandle)) { <br>        MessageBox(NULL, "Couldn't Initialize Chat!", "Error", <br>                   MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        goto Done; <br>    } <br> <br>    // Create the frame window. <br>    GlobalFrameWindow = CreateWindow(ChatClassStr, <br>                                     "WinSock 2 Chat", <br>                                     WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>                                     CW_USEDEFAULT, <br>                                     CW_USEDEFAULT, <br>                                     CW_USEDEFAULT, <br>                                     CW_USEDEFAULT, <br>                                     NULL, <br>                                     (HMENU)MainMenu, <br>                                     InstanceHandle, <br>                                     NULL); <br> <br>    if (GlobalFrameWindow == NULL) { <br>        ChatSysError("CreateWindow()", <br>                     "WinMain()", <br>                     TRUE); <br>    } <br> <br>    // Startup WinSock 2. <br>    if (!InitWS2()) { <br>        goto Done; <br>    } <br> <br>    // Find out about protocols installed. <br>    if (!FindProtocols()) { <br>        goto Done; <br>    } <br> <br>    // Listen on a local address for all installed protocols. <br>    if (!ListenAll()) { <br>        goto Done; <br>    } <br> <br>    // Load some handles, update the application window, and enter the <br>    // main message loop. <br>    ClientWindow = GetWindow(GlobalFrameWindow, GW_CHILD); <br>    AccelTable = LoadAccelerators(InstanceHandle, "MdiAccel"); <br>    if (AccelTable == NULL) { <br>        ChatSysError("LoadAccelerators()", <br>                     "WinMain()", <br>                     FALSE); <br>    } <br>    ShowWindow(GlobalFrameWindow, CmdShow); <br>    UpdateWindow(GlobalFrameWindow); <br> <br>    // Enter the GetMessage loop. <br>    while (GetMessage(&amp;Message, NULL, 0, 0)) { <br>        if (!TranslateMDISysAccel(ClientWindow, &amp;Message) &amp;&amp; <br>            !TranslateAccelerator(GlobalFrameWindow, AccelTable, &amp;Message)) { <br>             TranslateMessage(&amp;Message); <br>             DispatchMessage(&amp;Message); <br>        } <br>    } <br> <br>    // WM_QUIT was received.  Cleanup and return. <br>    WSACleanup(); <br>    ReturnValue = Message.wParam; <br> <br> Done: <br> <br>    return(ReturnValue); <br> <br>} // WinMain() <br> <br> <br> <br> <br>  <br>BOOL <br>InitUI( <br>    IN HINSTANCE InstanceHandle, <br>    IN HINSTANCE PrevInstanceHandle) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Initializes chat's user interface.  Registers the window classes <br>    used by chat and obtains handles to chat's menus. <br> <br>Arguments: <br> <br>    InstanceHandle - Supplies the current instance handle. <br> <br>    PrevInstanceHandle - Supplies the previous instance handle. <br> <br>Return Value: <br> <br>    TRUE - Chat successfully initialized <br> <br>    FALSE - Failure during chat initialization <br> <br>--*/ <br>{ <br>    WNDCLASS WndClass;           // window class structure <br>    BOOL     ReturnValue = TRUE; // holds return value <br> <br>    // If this is the first instance of chat, register the window <br>    // classes. <br>    if (!PrevInstanceHandle) { <br>        WndClass.style         = CS_HREDRAW | CS_VREDRAW; <br>        WndClass.lpfnWndProc   = MainWndProc; <br>        WndClass.cbClsExtra    = 0; <br>        WndClass.cbWndExtra    = 0; <br>        WndClass.hInstance     = InstanceHandle; <br>        WndClass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); <br>        WndClass.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>        WndClass.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>        WndClass.lpszMenuName  = NULL; <br>        WndClass.lpszClassName = ChatClassStr; <br>        if (!RegisterClass(&amp;WndClass)) { <br>            ReturnValue = FALSE; <br>            goto Done; <br>        } <br> <br>        WndClass.style         = CS_HREDRAW | CS_VREDRAW; <br>        WndClass.lpfnWndProc   = ConnWndProc; <br>        WndClass.cbClsExtra    = 0; <br>        WndClass.cbWndExtra    = CONN_WND_EXTRA; <br>        WndClass.hInstance     = InstanceHandle; <br>        WndClass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); <br>        WndClass.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>        WndClass.lpszMenuName  = NULL; <br>        WndClass.lpszClassName = ConnClassStr; <br>        if (!RegisterClass(&amp;WndClass)) { <br>            ReturnValue = FALSE; <br>            goto Done; <br>        } <br>    } <br> <br>    // Obtain handles to the menus &amp; submenus. <br>    MainMenu  = LoadMenu(GlobalInstance, "MdiMenuMain"); <br>    if (MainMenu == NULL) { <br>        ChatSysError("LoadMenu()", <br>                     "InitUI()", <br>                     TRUE); <br>    } <br>    MainMenuWindow  = GetSubMenu(MainMenu, MAIN_MENU_POS); <br> <br> Done: <br> <br>    return(ReturnValue); <br> <br>} // InitUI() <br> <br> <br> <br> <br>  <br>long CALLBACK <br>MainWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    WinSock 2 chat's main window procedure. <br> <br>Arguments: <br> <br>    WindowHandle - Supplies the window handle for chat's frame window. <br> <br>    Message - Supplies the message identifier. <br> <br>    WParam - Supplies the first message parameter. <br> <br>    LParam - Supplies the second message parameter. <br> <br>Return Value: <br> <br>    Return value depends on the message sent. <br> <br>--*/ <br>{ <br>    static HWND        ClientWindow; // the MDI client window <br>    CLIENTCREATESTRUCT ClientCreate; // MDI Client window creation data <br>    HWND               ChildWindow;  // gets handle to child conn. windows <br>    MDICREATESTRUCT    MdiCreate;    // MDI Child window creation data <br> <br>    switch (Message) { <br> <br>    case WM_CREATE: <br> <br>        // Create the client window. <br>        ClientCreate.hWindowMenu  = MainMenuWindow; <br>        ClientCreate.idFirstChild = IDM_FIRSTCHILD; <br>        ClientWindow = CreateWindow("MDICLIENT", <br>                                    NULL, <br>                                    WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE, <br>                                    0, 0, 0, 0, <br>                                    WindowHandle, <br>                                    (HMENU)CLIENT_WINDOW_ID, <br>                                    GlobalInstance, <br>                                    (LPSTR)&amp;ClientCreate); <br>        if (ClientWindow == NULL) { <br>            ChatSysError("CreateWindow()", <br>                         "MainWndProc()", <br>                         TRUE); <br> <br>        } <br> <br>        return (0); <br> <br>    case WM_COMMAND: <br> <br>        // We know the wm_command is coming from a menu item, so we <br>        // can safely assume that the high-order word of WParam is <br>        // zero. <br>        switch (WParam) { <br> <br>        case IDM_CONNECT: <br> <br>            // Create a Connection child window. <br>            MdiCreate.szClass = ConnClassStr; <br>            MdiCreate.szTitle = "Connecting..."; <br>            MdiCreate.hOwner  = GlobalInstance; <br>            MdiCreate.x       = CW_USEDEFAULT; <br>            MdiCreate.y       = CW_USEDEFAULT; <br>            MdiCreate.cx      = CW_USEDEFAULT; <br>            MdiCreate.cy      = CW_USEDEFAULT; <br>            MdiCreate.style   = 0; <br>            MdiCreate.lParam  = 0; <br>            ChildWindow = <br>              (HWND) SendMessage(ClientWindow, WM_MDICREATE, 0, <br>                                 (LPARAM)(LPMDICREATESTRUCT)&amp;MdiCreate); <br> <br>            if (ChildWindow == NULL) { <br>                ChatSysError("SendMessage(WM_MDICREATE)", <br>                             "MainWndProc()", <br>                             TRUE); <br>            } <br> <br>            // Get the connection information from the caller and <br>            // attempt to make a connection... <br>            if (!GetConnectionInfo(ChildWindow) || <br>                !MakeConnection(ChildWindow)) { <br>                DestroyWindow(ChildWindow); <br>            } <br> <br>            break; <br> <br>        case IDM_CLOSE: <br> <br>            // Close the active window. <br>            ChildWindow = (HWND)SendMessage(ClientWindow, WM_MDIGETACTIVE, 0, <br>                                            0); <br>            SendMessage(ClientWindow, WM_MDIDESTROY, (WPARAM)ChildWindow, 0); <br>            break; <br> <br> <br>        case IDM_EXIT: <br> <br>            // Exit the program. <br>            SendMessage(WindowHandle, WM_CLOSE, 0, 0); <br>            break; <br> <br>        case IDM_TILE: <br> <br>            SendMessage(ClientWindow, WM_MDITILE, 0, 0); <br>            break; <br> <br>        case IDM_CASCADE: <br> <br>            SendMessage(ClientWindow, WM_MDICASCADE, 0, 0); <br>            break; <br> <br>        case IDM_ARRANGE: <br> <br>            SendMessage(ClientWindow, WM_MDIICONARRANGE, 0, 0); <br>            break; <br> <br>        case IDM_CLOSEALL: <br> <br>            // Close all child windows. <br>            EnumChildWindows(ClientWindow, CloseEnumProc, 0); <br>            break; <br> <br>        default: <br> <br>            // Pass to active child. <br>            ChildWindow = (HWND)SendMessage(ClientWindow, WM_MDIGETACTIVE, <br>                                            0, 0); <br> <br>            if (IsWindow(ChildWindow)) { <br>                SendMessage(ChildWindow, WM_COMMAND, WParam, LParam); <br>            } <br> <br>            // This causes us to drop out of the switch and to pass <br>            // the message on to DefFrameProc(). <br>            break; <br> <br>        } // switch (WParam) <br>        break; <br> <br>    case WM_CLOSE: <br> <br>        // Close all child windows. <br>        SendMessage(WindowHandle, WM_COMMAND, IDM_CLOSEALL, 0); <br>        if (GetWindow(ClientWindow, GW_CHILD) != NULL) { <br>            return (0); <br>        } <br>        break; <br> <br>    case USMSG_ACCEPT: <br> <br>        // Create a MDI Child connection window (even though we aren't <br>        // yet sure if we will accept the connection -- if we don't, <br>        // it will be immediately destroyed.) <br>        MdiCreate.szClass = ConnClassStr; <br>        MdiCreate.szTitle = "Connection Request..."; <br>        MdiCreate.hOwner  = GlobalInstance; <br>        MdiCreate.x       = CW_USEDEFAULT; <br>        MdiCreate.y       = CW_USEDEFAULT; <br>        MdiCreate.cx      = CW_USEDEFAULT; <br>        MdiCreate.cy      = CW_USEDEFAULT; <br>        MdiCreate.style   = 0; <br>        ChildWindow = (HWND)SendMessage(ClientWindow, WM_MDICREATE, 0, <br>                                        (LPARAM)(LPMDICREATESTRUCT)&amp;MdiCreate); <br>        if (ChildWindow == NULL) { <br>            ChatSysError("SendMessage(WM_MDICREATE)", <br>                         "MainWndProc()", <br>                         TRUE); <br>        } <br> <br>        // Service the incoming connection request. <br>        HandleAcceptMessage(ChildWindow, (SOCKET)WParam, LParam); <br>        break; <br> <br>    case WM_DESTROY: <br> <br>        // Clean up the listening sockets and kill the application. <br>        CleanUpSockets(); <br>        PostQuitMessage(0); <br>        break; <br> <br>    } // switch(Message) <br> <br>    // Pass unprocessed messages to DefFrameProc. <br>    return (DefFrameProc(WindowHandle, <br>                         ClientWindow, <br>                         Message, <br>                         WParam, <br>                         LParam)); <br> <br>} // MainWndProc() <br> <br> <br> <br> <br>  <br>long CALLBACK <br>ConnWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Windows procedure for each connection window. <br> <br>Arguments: <br> <br>    WindowHandle - Supplies the handle to the connection window which <br>    is to receive the message. <br> <br>    Message - Supplies the message identifier. <br> <br>    WParam - Supplies the first message parameter. <br> <br>    LParam - Supplies the second message parameter. <br> <br>Return Value: <br> <br>    Return value depends on the message sent. <br> <br>--*/ <br>{ <br>    PCONNDATA         ConnData;    // pointer to data for this connection <br>    RECT              Rect;        // used for painting the window <br>    HDC               Hdc;         // device context for painting <br> <br>    switch (Message) { <br> <br>    case WM_CREATE: <br> <br>        // Allocate memory for private window data. <br>        ConnData = (PCONNDATA)malloc(sizeof(CONNDATA)); <br>        if (ConnData == NULL) { <br>            ChatSysError("malloc()", <br>                         "ConnWndProc()", <br>                         TRUE); <br>        } <br>        memset((char *)ConnData, 0, sizeof(CONNDATA)); <br>        // Let this to be filled by a getsockopt call later <br>        ConnData-&gt;MaxMsgSize = 0x01; <br> <br>        // Zero is a valid socket ID so set the socket member to INVALID_SOCKET <br>        ConnData-&gt;Socket = INVALID_SOCKET; <br> <br>        GetClientRect(WindowHandle, &amp;Rect); <br> <br>        // Create Send/Recv edit controls. <br>        ConnData-&gt;SendWindow = <br>          CreateWindow("EDIT", <br>                       NULL, <br>                       WS_CHILD | WS_VISIBLE   | WS_VSCROLL | <br>                       ES_LEFT  | ES_MULTILINE | ES_AUTOVSCROLL, <br>                       0, <br>                       0, <br>                       Rect.right, <br>                       Rect.bottom/2, <br>                       WindowHandle, <br>                       (HMENU)EC_SEND_CHILD, <br>                       GlobalInstance, <br>                       NULL); <br> <br>        ConnData-&gt;RecvWindow = <br>          CreateWindow("EDIT", <br>                       NULL, <br>                       WS_CHILD | WS_VISIBLE   | WS_VSCROLL | <br>                       ES_LEFT  | ES_MULTILINE | ES_AUTOVSCROLL, <br>                       0, <br>                       Rect.bottom/2 + 1, <br>                       Rect.right, <br>                       Rect.bottom - Rect.bottom/2 - 1, <br>                       WindowHandle, <br>                       (HMENU)EC_RECV_CHILD, <br>                       GlobalInstance, <br>                       NULL); <br> <br>        if (!ConnData-&gt;SendWindow || !ConnData-&gt;RecvWindow) { <br>            ChatSysError("CreateWindow()", <br>                         "ConnWndProc()", <br>                         TRUE); <br>        } <br> <br>        // Fill in some connection-specific data. <br>        ConnData-&gt;SocketEventObject = CreateEvent(NULL, <br>                                                  FALSE, <br>                                                  FALSE, <br>                                                  NULL); <br>        ConnData-&gt;OutputEventObject = CreateEvent(NULL, <br>                                                  FALSE, <br>                                                  FALSE, <br>                                                  NULL); <br>        ConnData-&gt;OutputQueue = QCreate(); <br>        if (!ConnData-&gt;SocketEventObject || !ConnData-&gt;OutputEventObject || <br>            !ConnData-&gt;OutputQueue) { <br>            ChatSysError("CreateEvent() or QCreate()", <br>                         "ConnWndProc()", <br>                         TRUE); <br>        } <br>        ConnData-&gt;ConnectionWindow = WindowHandle; <br>        ConnData-&gt;WriteOk = FALSE; <br> <br>        // Subclass the edit controls. Both functions necessarily <br>        // return the same FARPROC... <br>        OldEditWndProc = (FARPROC)SetWindowLong(ConnData-&gt;SendWindow, <br>                                                GWL_WNDPROC, <br>                                                (DWORD)SendEditSubClass); <br>        SetWindowLong(ConnData-&gt;RecvWindow, <br>                      GWL_WNDPROC, <br>                      (DWORD)RecvEditSubClass); <br> <br>        // Split the connection window in half. <br>        Hdc = GetDC(WindowHandle); <br>        MoveToEx(Hdc, 0, Rect.bottom/2, NULL); <br>        LineTo(Hdc, Rect.right, Rect.bottom/2); <br>        ReleaseDC(WindowHandle, Hdc); <br> <br>        // Set the private window data to be a pointer to ConnData. <br>        SetWindowLong(WindowHandle, GWL_CONNINFO, (LONG)ConnData); <br> <br>        return (0); <br> <br>    case WM_COMMAND: <br> <br>        switch (HIWORD(WParam)) { <br> <br>        case 0: <br> <br>            // If the high-order word is zero, this message is being <br>            // sent from a menu-item (hopefully it was passed to us <br>            // from the frame window, since the mdi child connection <br>            // windows, of course, have no menus). <br>            switch (LOWORD(WParam)) { <br> <br>            case IDM_CLEAR_SENDBUFFER: <br> <br>                // Clear the send buffer. <br>                ConnData = GetConnData(WindowHandle); <br>                PostMessage(ConnData-&gt;SendWindow, EM_SETSEL, 0, -1); <br>                PostMessage(ConnData-&gt;SendWindow, WM_CLEAR, 0, 0); <br>                return (0); <br> <br>            case IDM_CLEAR_RECVBUFFER: <br> <br>                // Clear the receive buffer. <br>                ConnData = GetConnData(WindowHandle); <br>                PostMessage(ConnData-&gt;RecvWindow, EM_SETSEL, 0, -1); <br>                PostMessage(ConnData-&gt;RecvWindow, WM_CLEAR, 0, 0); <br>                return (0); <br> <br>            default: <br> <br>                // An unknown menu item... just return. <br>                return (0); <br> <br>            } // switch (LOWORD(WParam)) <br> <br>        case 1: <br> <br>            // The high-order word is 1, so thus the wm_command <br>            // message is coming from an accelerator. Ignore it. <br>            return(0); <br> <br>        default: <br> <br>            // Let the default window procedure handle it (below). <br>            break; <br> <br>        } // switch (HIWORD(WParam)) <br>        break; <br> <br> <br>    case WM_PAINT: <br> <br>        // Window needs to be painted, split the connection window in <br>        // half. <br>        GetClientRect(WindowHandle, &amp;Rect); <br>        Hdc = GetDC(WindowHandle); <br>        MoveToEx(Hdc, 0, Rect.bottom/2, NULL); <br>        LineTo(Hdc, Rect.right, Rect.bottom/2); <br>        ReleaseDC(WindowHandle, Hdc); <br> <br>        return (DefMDIChildProc(WindowHandle, <br>                                Message, <br>                                WParam, <br>                                LParam)); <br> <br>    case WM_SIZE: <br> <br>        ConnData = GetConnData(WindowHandle); <br> <br>        // Resize the edit control windows. <br>        MoveWindow(ConnData-&gt;SendWindow, <br>                   0, <br>                   0, <br>                   LOWORD(LParam), <br>                   HIWORD(LParam)/2, <br>                   TRUE); <br> <br>        MoveWindow(ConnData-&gt;RecvWindow, <br>                   0, <br>                   HIWORD(LParam)/2 + 1, <br>                   LOWORD(LParam), <br>                   HIWORD(LParam) - HIWORD(LParam)/2 - 1, <br>                   TRUE); <br> <br>        return (DefMDIChildProc(WindowHandle, <br>                                Message, <br>                                WParam, <br>                                LParam)); <br> <br>    case USMSG_CONNECT: <br> <br>        // Handle the new connection. <br>        HandleConnectMessage(WindowHandle, LParam); <br>        return(0); <br> <br>    case WM_DESTROY: <br> <br>        ConnData = GetConnData(WindowHandle); <br>        CleanupConnection(ConnData); <br> <br>        return(DefMDIChildProc(WindowHandle, <br>                               Message, <br>                               WParam, <br>                               LParam)); <br> <br>    } // switch (Message) <br> <br>    // Pass unprocessed message to DefMDIChildProc. <br>    return(DefMDIChildProc(WindowHandle, <br>                           Message, <br>                           WParam, <br>                           LParam)); <br> <br>} // ConnWndProc() <br> <br> <br> <br> <br>  <br>long CALLBACK <br>SendEditSubClass( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Window procedure used to subclass the edit control for the sending <br>    window. <br> <br>Implementation: <br> <br>    Text is only allowed to be appended to or deleted from the end of <br>    an edit control's text buffer.  When text is either typed or <br>    paste, Chat creates an output request data structure and sticks it <br>    on the output thread for this connection. <br> <br>Arguments: <br> <br>    WindowHandle - Supplies the handle to the edit control's window <br> <br>    Message - Supplies the message identifier. <br> <br>    WParam - Supplies the first message parameter. <br> <br>    LParam - Supplies the second message parameter. <br> <br>Return Value: <br> <br>    ReturnValue - Depends of the message sent. <br> <br>--*/ <br>{ <br>    int             Index;        // an index into the edit control's text <br>    HANDLE          CBDataHandle; // handle to the clipboard data <br>    LPSTR           CBDataPtr;    // pointer to data to send <br>    PCONNDATA       ConnData;     // pointer to connection-specific data <br>    POUTPUT_REQUEST OutReq;       // output request data <br>    int             TextSize;     // number of bytes of text to send <br>    DWORD           BytesLeft;    // number of bytes left to send <br> <br>    ConnData = GetConnData(GetParent(WindowHandle)); <br> <br>    switch (Message) { <br> <br>    case WM_CHAR: <br> <br>        // If the character is sendable, enqueue the character on the <br>        // output queue, and signal the output event. <br>        if (IsSendable((char)WParam)) { <br> <br>            OutReq = (POUTPUT_REQUEST) malloc(sizeof(OUTPUT_REQUEST)); <br>            if (OutReq == NULL) { <br>                ChatSysError("malloc()", <br>                             "SendEditSubClass()", <br>                             TRUE); <br>            } <br> <br>            // Rather than malloc a one-character buffer, just point <br>            // Buffer into the already-allocated Char field of the <br>            // OutReq structure.  This gets rid of a heavy-weight <br>            // malloc for each character typed. <br>            OutReq-&gt;Buffer.len = sizeof(char); <br>            OutReq-&gt;Buffer.buf = &amp;OutReq-&gt;Character; <br> <br>            // Fill in the OutReq structure. <br>            *(OutReq-&gt;Buffer.buf) = (char)WParam; <br>            OutReq-&gt;Type = NON_OVERLAPPED_IO; <br>            OutReq-&gt;ConnData = ConnData; <br> <br>            QInsert(ConnData-&gt;OutputQueue, (LPVOID)OutReq); <br>            SetEvent(ConnData-&gt;OutputEventObject); <br>        } <br> <br>        // Move the cursor to the end of the text buffer. <br>        Index = GetWindowTextLength(WindowHandle); <br>        CallWindowProc((WNDPROC)OldEditWndProc, <br>                       WindowHandle, <br>                       EM_SETSEL, <br>                       Index, <br>                       Index); <br> <br>        // Make room for the new text in the edit control. <br>        MakeRoom(WindowHandle, 1); <br> <br>        // Pass on the message to the original Edit Window Procedure. <br>        return (CallWindowProc((WNDPROC)OldEditWndProc, <br>                               WindowHandle, <br>                               Message, <br>                               WParam, <br>                               LParam)); <br> <br>    case WM_PASTE: <br> <br>        // Get the buffer from the edit control and send it over the <br>        // socket. <br>        if (IsClipboardFormatAvailable(CF_TEXT)) { <br> <br>            if (OpenClipboard(WindowHandle)) { <br>                CBDataHandle = GetClipboardData(CF_TEXT); <br> <br>                if (CBDataHandle) { <br> <br>                    CBDataPtr = GlobalLock(CBDataHandle); <br>                    TextSize = strlen(CBDataPtr); <br> <br>                    // Make room in the edit control for the new text; if <br>                    // this is impossible, just return because MakeRoom <br>                    // notifies the user internally. <br>                    if (!MakeRoom(WindowHandle, TextSize)) { <br>                        GlobalUnlock(CBDataHandle); <br>                        CloseClipboard(); <br>                        return(0); <br>                    } <br> <br>                    // If the text is longer than the maximum message <br>                    // size, we need to split it into bite-size pieces <br>                    // for consumption by the transport layer. <br>                    BytesLeft = TextSize; <br>                    while (BytesLeft != 0) { <br> <br>                        // Create a new output request. <br>                        OutReq = <br>                          (POUTPUT_REQUEST)malloc(sizeof(OUTPUT_REQUEST)); <br>                        if (OutReq == NULL) { <br>                            ChatSysError("malloc()", <br>                                         "SendEditSubClass", <br>                                         TRUE); <br>                        } <br> <br>                        // Determine how much data to send with this <br>                        // request, and allocate a buffer that size. <br>                        if (BytesLeft &gt; ConnData-&gt;MaxMsgSize) { <br>                            OutReq-&gt;Buffer.len = ConnData-&gt;MaxMsgSize; <br>                        } else { <br>                            OutReq-&gt;Buffer.len = BytesLeft; <br>                        } <br>                        OutReq-&gt;Buffer.buf = <br>                          (char *)malloc(OutReq-&gt;Buffer.len); <br>                        if (OutReq-&gt;Buffer.buf == NULL) { <br>                            ChatSysError("malloc()", <br>                                         "SendEditSubClass", <br>                                         TRUE); <br>                        } <br> <br>                        // Fill in the rest of the OutReq structure <br>                        // and put it in the output queue. <br>                        OutReq-&gt;Type = OVERLAPPED_IO; <br>                        OutReq-&gt;ConnData = ConnData; <br>                        memcpy(OutReq-&gt;Buffer.buf, CBDataPtr, <br>                               OutReq-&gt;Buffer.len); <br>                        QInsert(ConnData-&gt;OutputQueue, (LPVOID)OutReq); <br> <br>                        // Update the number of bytes left to send and <br>                        // the pointer to the rest of the data. <br>                        BytesLeft -= OutReq-&gt;Buffer.len; <br>                        CBDataPtr += OutReq-&gt;Buffer.len; <br>                    } <br> <br>                    // Signal the ouput event. <br>                    SetEvent(ConnData-&gt;OutputEventObject); <br>                    GlobalUnlock(CBDataHandle); <br> <br>                } else { <br> <br>                    MessageBox(WindowHandle, <br>                               "Sorry, couldn't retrieve the clipoard data.", <br>                               "Error.", <br>                               MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                } <br> <br>                CloseClipboard(); <br> <br>            } // if (OpenClipboard(WindowHandle)) <br>            else { <br> <br>                MessageBox(WindowHandle, <br>                           "Couldn't open the clipboard!!", <br>                           "Try again.", <br>                           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            } <br> <br>        } // if (IsClipboardFormatAvailable(CF_TEXT)) <br>        else { <br> <br>            MessageBox(WindowHandle, <br>                       "Sorry, the CF_TEXT format not available.", </code></pre>
<p>
</p>
<pre><code>"Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        } <br>        // Move the cursor to the end of the text buffer. <br>        Index = GetWindowTextLength(WindowHandle); <br>        CallWindowProc((WNDPROC)OldEditWndProc, <br>                       WindowHandle, <br>                       EM_SETSEL, <br>                       Index, <br>                       Index); <br> <br>        // Call the real edit control window procedure. <br>        return (CallWindowProc((WNDPROC)OldEditWndProc, <br>                               WindowHandle, <br>                               Message, <br>                               WParam, <br>                               LParam)); <br> <br>    case WM_KEYDOWN: <br> <br>        // Capture the delete key. nVirtKey: 46 = 'Del'. <br>        if (WParam == 46) { <br>            return(0); <br>        } else { <br>            return (CallWindowProc((WNDPROC)OldEditWndProc, WindowHandle, <br>                                   Message, WParam, LParam)); <br>        } <br> <br>    case WM_CUT:  // Flow through <br>    case WM_UNDO: <br> <br>        return (0); <br> <br>    default: <br> <br>        return (CallWindowProc((WNDPROC)OldEditWndProc, <br>                               WindowHandle, <br>                               Message, <br>                               WParam, <br>                               LParam)); <br> <br>    } // switch (Message) <br> <br>} // SendEditSubClass() <br> <br> <br> <br> <br>  <br>long CALLBACK <br>RecvEditSubClass( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Window procedure used to subclass the edit control for the <br>    receiving window. <br> <br>Implementation: <br> <br>    The user cannot modify any of the text displayed in the receiving <br>    edit control. All text received from the socket associated with <br>    this edit control is displayed. <br> <br>Arguments: <br> <br>    WindowHandle - Supplies the handle to the edit control's window <br> <br>    Message - Supplies the message identifier. <br> <br>    WParam - Supplies the first message parameter. <br> <br>    LParam - Supplies the second message parameter. <br> <br>Return Value: <br> <br>    ReturnValue - Depends of the message sent. <br> <br>--*/ <br>{ <br>    switch (Message) { <br> <br>    case WM_CHAR:       // Flow through <br>    case WM_KEYDOWN:    // Flow through <br>    case WM_UNDO:       // Flow through <br>    case WM_PASTE:      // Flow through <br>    case WM_CUT: <br> <br>        return (0);     // Effectively disables the above messages. <br> <br>    default: <br> <br>        return (CallWindowProc((WNDPROC)OldEditWndProc, <br>                               WindowHandle, <br>                               Message, <br>                               WParam, <br>                               LParam)); <br>    } <br> <br>} // RecvEditSubClass() <br> <br> <br> <br> <br>  <br>BOOL CALLBACK <br>CloseEnumProc( <br>    IN HWND WindowHandle, <br>    IN LONG LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    A callback function used to destroy all of chat's connection <br>    windows. <br> <br>Arguments: <br> <br>    WindowHandle - Supplies the handle to the child's window which <br>                   is to be closed. <br> <br>    LParam - Not Used. <br> <br>Return Value: <br> <br>    TRUE - Returns true in order to continue enumeration. <br> <br>--*/ <br>{ <br>    if (!GetWindow(WindowHandle, GW_OWNER)) { <br> <br>        SendMessage(GetParent(WindowHandle), WM_MDIRESTORE, <br>                    (WPARAM)WindowHandle, 0); <br> <br>        if (SendMessage(WindowHandle, WM_QUERYENDSESSION, 0, 0)) { <br>            SendMessage(GetParent(WindowHandle), WM_MDIDESTROY, <br>                        (WPARAM)WindowHandle, 0); <br>        } <br>    } <br>    return (TRUE); <br> <br>} // CloseEnumProc() <br> <br> <br> <br> <br>  <br>void <br>OutputString( <br>    IN HWND RecvWindow, <br>    IN char *String) <br>/*++ <br> <br>Routine Description: <br> <br>    This function sends the string received over the socket to the <br>    edit window given by RecvWindow. <br> <br>Implementation: <br> <br>    This function treats certain non-printable characters specially so <br>    that they mean the same thing on this end as they did on the end <br>    that sent them. <br> <br>Arguments: <br> <br>    RecvWindow -- Handle to the edit control window which is to <br>    receive the text. <br> <br>    String -- Points to the NULL-terminated string to be output. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br> <br>    int  Index;         // indices into the edit control text <br>    char *Current = String;     // the character we are examining <br>    char *First = String;       // the first character we have not output <br>    int  NumChars;              // how many characters we put in Buffer <br> <br>    // Make room for the string in the edit control. <br>    MakeRoom(RecvWindow, strlen(String)); <br> <br>    // This loop goes through the whole string we have been instructed <br>    // to print in the edit control; when it encounters certain <br>    // characters in the string, it sends certain messages to the edit <br>    // control to simulate the right behavior. <br>    while (*Current) { <br> <br>        switch (*Current) { <br> <br>        case '\b': <br> <br>            // The current character is a backspace.  Print out the <br>            // string we have so far, and then manually erase a <br>            // character. <br>            *Current = '\0'; <br> <br>            // Output the string at 'First'... <br>            Index = GetWindowTextLength(RecvWindow); <br>            SendMessage(RecvWindow, EM_SETSEL, Index, Index); <br>            SendMessage(RecvWindow, EM_REPLACESEL, 0, (LPARAM)First); <br> <br>            // Get the number of chars in the last line. <br>            Index = GetWindowTextLength(RecvWindow); <br>            NumChars = SendMessage(RecvWindow, EM_LINELENGTH, Index, 0); <br> <br>            // If the line had no characters in it, then it's the <br>            // beginning of a new line, and we should erase two <br>            // characters (the preceding \r\n) rather than just one. <br>            if (NumChars == 0) { <br>                SendMessage(RecvWindow, EM_SETSEL, Index - 2, Index); <br>                SendMessage(RecvWindow, EM_REPLACESEL, 0, (LPARAM)""); <br>            } else { <br>                SendMessage(RecvWindow, EM_SETSEL, Index - 1, Index); <br>                SendMessage(RecvWindow, EM_REPLACESEL, 0, (LPARAM)""); <br>            } <br> <br>            First = Current + 1; <br>            break; <br> <br>        case '\r': <br> <br>            // A newline.  If the Chat window is minimized, ask the <br>            // user if they want it maximized. <br>            QueryAndMaximize(); <br> <br>            // If a remote user typed a newline, we'll receive '\r', <br>            // but if the remote user pasted it in, we'll get '\r\n'. <br>            if (*(Current + 1) != '\n') { <br> <br>                // The newline was typed in...output the string up to <br>                // the newline, then "\r\n". <br>                *Current = '\0'; <br> <br>                Index = GetWindowTextLength(RecvWindow); <br>                SendMessage(RecvWindow, EM_SETSEL, Index, Index); <br>                SendMessage(RecvWindow, EM_REPLACESEL, 0, (LPARAM)First); <br> <br>                Index = GetWindowTextLength(RecvWindow); <br>                SendMessage(RecvWindow, EM_SETSEL, Index, Index); <br>                SendMessage(RecvWindow, EM_REPLACESEL, 0, (LPARAM)"\r\n"); <br> <br>                First = Current + 1; <br>            } <br> <br>            break; <br> <br>        default: <br> <br>            break; <br> <br>        } // switch (*Current) <br>        Current++; <br> <br>    } // while (*Current) <br> <br>    // Ouptut any string leftover in First <br>    Index = GetWindowTextLength(RecvWindow); <br>    SendMessage(RecvWindow, EM_SETSEL, Index, Index); <br>    SendMessage(RecvWindow, EM_REPLACESEL, 0, (LPARAM)First); <br>} <br> <br> <br> <br> <br>  <br>void <br>QueryAndMaximize(void) <br>/*++ <br> <br>Routine Description: <br> <br>    If Chat's main frame window is minimized, this function asks the <br>    user if they want to activate and display Chat, and acts <br>    accordingly. <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br>    WINDOWPLACEMENT WinPlace; // holds window placement data <br> <br>    WinPlace.length = sizeof(WINDOWPLACEMENT); <br> <br>    // Get chat's main window's state. <br>    GetWindowPlacement(GlobalFrameWindow, &amp;WinPlace); <br> <br>    // If it's minimized, ask the user if they want to maximize. <br>    if (WinPlace.showCmd == SW_SHOWMINIMIZED) { <br> <br>        if (MessageBox(GlobalFrameWindow, <br>                       "There is activity on a Chat connection.  Maximize?", <br>                       "Chat has data.", <br>                       MB_ICONQUESTION | MB_YESNO | MB_SETFOREGROUND) <br>            == IDYES) { <br> <br>            // Maximize chat's main window. <br>            WinPlace.showCmd = SW_RESTORE; <br>            SetWindowPlacement(GlobalFrameWindow, &amp;WinPlace); <br>        } <br>    } <br>} // QueryAndMaximize() <br> <br> <br> <br> <br>  <br>BOOL <br>GetConnectionInfo( <br>    IN HWND ConnectionWindow) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Queries the user as to what sort of connection (i.e. what address <br>    family/protocol) she wants to make. <br> <br>Implementation: <br> <br>    After popping up a listbox, filling it in with all the available <br>    protocol choices, and getting the user's choice, this function <br>    uses it to determine what kind of dialog box to pop up to get the <br>    actual connection parameters, which are stored in the CONNDATA <br>    associated with the given ConnectionWindow. <br> <br>Arguments: <br> <br>    ConnectionWindow -- Handle to the connection window associated <br>    with this connection. <br> <br>Return Value: <br> <br>    TRUE - The user closed a dialog box by clicking the 'Ok' button. <br> <br>    FALSE - The user closed a dialog box by clicking the 'Cancel' <br>            button. <br> <br>--*/ <br> <br>{ <br>    PCONNDATA ConnData;           // connection-specific data <br>    BOOL      ReturnValue = TRUE; // holds the return value <br>    struct sockaddr_atm * pATMSockAddr; <br> <br>    ConnData = GetConnData(ConnectionWindow); <br> <br>    // Pop up a dialog box from which the user chooses the protocol; a <br>    // pointer to a protocol info struct is stored in ConnData. <br>    if (!DialogBoxParam(GlobalInstance, <br>                        "ChooseFamilyDlg", <br>                        ConnectionWindow, <br>                        ChooseFamilyDlgProc, <br>                        (LPARAM)ConnData)) { <br>        ReturnValue = FALSE; <br>        goto Done; <br>    } <br> <br>    // The user has selected a protocol; now pop up an address family <br>    // specific dialog box to get the address to which we want to make <br>    // a chat connection, a pointer to which is stored in <br>    // ConnData-&gt;SockAddr (see InetConnDlg, for example). <br>    switch (ConnData-&gt;ProtocolInfo-&gt;iAddressFamily) { <br> <br>        case AF_INET: <br> <br>            ReturnValue = DialogBoxParam(GlobalInstance, <br>                                         "InetConnDlg", <br>                                         ConnectionWindow, <br>                                         InetConnDlgProc, <br>                                         (LPARAM)ConnData); <br>            goto Done; <br> <br>        case AF_ATM: <br>            ConnData-&gt;RemoteSockAddr.len = sizeof(struct sockaddr_atm); <br>            ConnData-&gt;RemoteSockAddr.buf = <br>                        (char FAR *)malloc(ConnData-&gt;RemoteSockAddr.len); <br> <br>            pATMSockAddr = (struct sockaddr_atm *)ConnData-&gt;RemoteSockAddr.buf; <br>            pATMSockAddr-&gt;satm_number.AddressType  = ATM_NSAP; <br>            pATMSockAddr-&gt;satm_blli.Layer2Protocol = SAP_FIELD_ABSENT; <br>            pATMSockAddr-&gt;satm_blli.Layer3Protocol = SAP_FIELD_ABSENT; <br>            pATMSockAddr-&gt;satm_bhli.HighLayerInfoType = BHLI_UserSpecific; <br> <br>            ReturnValue = DialogBoxParam(GlobalInstance, <br>                                         "ATMSOCKADDRDLG", <br>                                         ConnectionWindow, <br>                                         ATMSockAddrProc, <br>                                         (LPARAM)pATMSockAddr); <br>            goto Done; <br> <br>        default: <br> <br>            ReturnValue = DialogBoxParam(GlobalInstance, <br>                                   "DefaultConnDlg", <br>                                   ConnectionWindow, <br>                                   DefaultConnDlgProc, <br>                                   (LPARAM)ConnData); <br>            goto Done; <br>    } <br> <br> Done: <br> <br>    return(ReturnValue); <br> <br>} // GetConnectionInfo() <br> <br> <br> <br> <br>  <br>BOOL <br>TranslateHex( <br>    OUT LPVOID Buffer, <br>    IN  int    BufferLen, <br>    IN  char   *HexString, <br>    IN  HWND   WindowHandle) <br>/*++ <br> <br>Routine Description: <br> <br>    This function converts an arbitrarily long string of hexidecimal <br>    digits into a binary representation. <br> <br>    Example -- if the string "0fbf" is passed in, then two bytes will <br>    be written into Buffer -- 15 and 191. <br> <br>Arguments: <br> <br>    Buffer -- Points to a buffer where we want the data stored. <br> <br>    BufferLen -- The length, in bytes, of Buffer. <br> <br>    HexString -- A null-terminated string of digits with values in the <br>    ASCII range of 0-9 and a-f. <br> <br>    WindowHandle -- Window handle needed in case we pop up a dialog <br>    box. <br> <br>Return Value: <br> <br>    TRUE -- HexString was successfully translated. <br> <br>    FALSE -- One of the characters does not represent a hex digit, or <br>    the HexString is too long to be translated into BufferLen bytes. <br> <br>--*/ <br>{ <br> <br>    int  HexStringLen;       // the length of the HexString, in bytes <br>    int  i;                  // counting variable <br>    char TwoCharString[3];   // stores two hex characters + a NULL char <br>    char *NextByte;          // next free byte in the buffer <br>    BOOL ReturnValue = TRUE; // return value <br> <br>    HexStringLen  = strlen(HexString); <br>    NextByte = (char *)Buffer; <br>    TwoCharString[2] = '\0'; <br> <br>    // Zero out the output buffer. <br>    memset(NextByte, 0, BufferLen); <br> <br>    // If the hex string in more than twice as long as the buffer, we <br>    // don't have a big enough buffer. <br>    if ((HexStringLen / 2) &gt; BufferLen) { <br>        ReturnValue = FALSE; <br>    } else { <br> <br>        // Go through the hex string two characters at a time... <br>        for (i = 0; i &lt; HexStringLen; i += 2) { <br> <br>            // Copy the next two bytes of the hex string into <br>            // TwoCharString; then check to make sure they are both <br>            // hexidecimal digits. <br>            memcpy(TwoCharString, HexString + i, 2); <br>            if (!isxdigit(TwoCharString[0]) || !isxdigit(TwoCharString[1])) { <br>                MessageBox(WindowHandle, "Type a hexidecimal number, please", <br>                           "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                ReturnValue = FALSE; <br>                break; <br>            } <br>            *NextByte++ = (char)strtol(TwoCharString, NULL, 16); <br> <br>        } // for <br>    } // else <br>    return(ReturnValue); <br> <br>} // TranslateHex() <br> <br> <br> <br> <br>  <br>BOOL <br>PackTwoStrings( <br>    OUT char  *Buffer, <br>    IN  int   BufferLen, <br>    IN  char  *String1, <br>    IN  char  *String2) <br>/*++ <br> <br>Routine Description: <br> <br>    Packs two strings into one buffer.  Useful for packing caller data <br>    into a buffer for connection-time data transfer.  It is not an <br>    error if either string is of zero length, i.e. just the '\0' <br>    character. <br> <br>Arguments: <br> <br>    Buffer -- Pointer to a buffer into which the two strings will be <br>    packed. <br> <br>    BufferLen -- The length, in bytes, of Buffer. <br> <br>    String1 - Address of the first NULL terminated string. <br> <br>    String2 - Address of the second NULL terminated string. <br> <br>Return Value: <br> <br>    TRUE -- The strings were successfully packed into the buffer. <br> <br>    FALSE -- The passed in buffer was NULL, one or both of the strings <br>    were NULL, or Buffer is too small. <br> <br>--*/ <br> <br>{ <br>    int Length1, Length2;    // holds the length of the strings <br>    BOOL ReturnValue = TRUE; // holds the return value <br> <br>    if (!Buffer || !String1 || !String2) { <br>        ReturnValue = FALSE; <br>        goto Done; <br>    } <br> <br>    Length1 = strlen(String1); <br>    Length2 = strlen(String2); <br> <br>    if (BufferLen &lt; (Length1 + Length2 + 2)) { <br>        ReturnValue = FALSE; <br>        goto Done; <br>    } <br> <br>    strcpy(Buffer, String1); <br>    strcpy(Buffer + Length1 + 1, String2); <br> <br> Done: <br> <br>    return(ReturnValue); <br> <br>} // PackTwoStrings() <br> <br> <br> <br> <br>  <br>BOOL <br>ExtractTwoStrings( <br>    IN  char *Buffer, <br>    OUT char *String1, <br>    IN  char Length1, <br>    OUT char *String2, <br>    IN  int  Length2) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Extracts two strings from a buffer, expecting them to be packed as <br>    PackTwoStrings does it. <br> <br>Arguments: <br> <br>    Buffer -- The buffer which contains two strings. <br> <br>    String1 -- A pointer to a buffer of size Length1. <br> <br>    Length1 -- The length, in bytes, of String1. <br> <br>    String2 -- A pointer to a buffer of size Length2. <br> <br>    Length2 -- The length, in bytes, of String2. <br> <br>Return Value: <br> <br>    TRUE -- The strings were successfully extracted. <br> <br>    FALSE -- One of the pointers was NULL, or a packed string was too <br>    big to be extracted out into a buffer. <br> <br>--*/ <br> <br>{ <br>    int BufStrLen1, BufStrLen2; // the length of the packed strings <br>    char *BufStr2;              // points to the second packed string <br>    BOOL ReturnValue = TRUE;    // holds the return value <br> <br>    if (!Buffer || !String1 || !String2) { <br>        ReturnValue = FALSE; <br>        goto Done; <br>    } <br> <br>    BufStrLen1 = strlen(Buffer); <br>    BufStr2 = Buffer + BufStrLen1 + 1; <br>    BufStrLen2 = strlen(BufStr2); <br> <br>    if ((BufStrLen1 &gt; Length1) || (BufStrLen2 &gt; Length2)) { <br>        ReturnValue = FALSE; <br>        goto Done; <br>    } <br> <br>    strcpy(String1, Buffer); <br>    strcpy(String2, BufStr2); <br> <br> Done: <br> <br>   return(ReturnValue); <br> <br>} // ExtractTwoStrings() <br> <br> <br> <br> <br>  <br>void <br>ChatSysError( <br>    IN char *FailedFunction, <br>    IN char *InFunction, <br>    IN BOOL Fatal) <br>/*++ <br> <br>Routine Description: <br> <br>    Pops up a standard message box to display fatal system errors; if <br>    the error is fatal, the process is ended and this function does <br>    not return. <br> <br>Arguments: <br> <br>    FailedFunction -- Pointer to a string that contains the name of <br>    the system function that failed. <br> <br>    InFunction -- Pointer to a string that contains the name of the <br>    chat function in which the failure occurred. <br> <br>    Fatal -- Boolean indicating whether the error is fatal to the <br>    process or not. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br> <br>    char MsgText[MSG_LEN]; // holds message strings <br> <br>    wsprintf(MsgText, <br>             "System call %s failed in chat function %s. Error code: %d", <br>             FailedFunction, InFunction, GetLastError()); <br>    MessageBox(GlobalFrameWindow, <br>               MsgText, <br>               Fatal ? "Fatal Error." : "Non-Fatal Error.", <br>               MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br> <br>    if (Fatal) { <br>        ExitProcess(CHAT_ERROR); <br>    } <br> <br>} // ChatSysError() <br> <br> <br> <br> <br>  <br>BOOL <br>MakeRoom( <br>    IN HWND EditControl, <br>    IN int  HowMuch) <br>/*++ <br> <br>Routine Description: <br> <br>    This function makes room in an edit control for more text, if <br>    necessary. <br> <br>Arguments: <br> <br>    EditControl -- The edit control in question. <br> <br>    HowMuch -- How many characters do we want to put into the edit <br>    control? <br> <br>Return Value: <br> <br>    TRUE -- If there was not enough room in the edit control, MakeRoom <br>    successfully chopped off some text from the beginning, and there <br>    is now enough room. <br> <br>    FALSE -- The requested amount can not fit in the edit control, <br>    period; a message box has informed the user. <br> <br>--*/ <br>{ <br> <br>    int  TextLength;  // how much text is in the edit control <br>    int  CharIndex1; <br>    int  CharIndex2; <br>    int  LineIndex;   // index variables <br>    BOOL ReturnValue; // return value <br> <br>    if (HowMuch &gt; MAX_EC_TEXT) { <br> <br>        MessageBox(EditControl, <br>                   "Clipboard too long. Try pasting a smaller amount.", <br>                   "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        ReturnValue = FALSE; <br> <br>    } else { <br> <br>        TextLength = GetWindowTextLength(EditControl); <br> <br>        if (TextLength + HowMuch &gt; MAX_EC_TEXT) { <br> <br>            // Inserting the text would exceed our limit.  This code <br>            // chops off roughly the first half of the edit control's <br>            // text. <br>            CharIndex1 = TextLength / 2; <br>            LineIndex = SendMessage(EditControl, EM_LINEFROMCHAR, <br>                                    (WPARAM)CharIndex1, 0); <br>            CharIndex2 = SendMessage(EditControl, EM_LINEINDEX, <br>                                     (WPARAM)LineIndex, 0); <br> <br>            SendMessage(EditControl, EM_SETSEL, 0, CharIndex2); <br>            SendMessage(EditControl, EM_REPLACESEL, 0, <br>                        (LPARAM)""); <br>        } <br> <br>        ReturnValue = TRUE; <br>    } // else <br> <br>    return(ReturnValue); <br>} // MakeRoom() </code></pre>
<p>&nbsp;</p></body>
</HTML>
