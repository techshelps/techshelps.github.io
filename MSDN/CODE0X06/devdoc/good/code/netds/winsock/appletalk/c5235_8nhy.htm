<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRPERF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5236"></a>PRPERF.C</h2>
<pre><code>/*++ <br> <br>Copyright 1994 - 1998 Microsoft Corporation <br> <br>Module Name: prperf.c <br> <br> <br>Abstract: This Sample Windows Socket Application demonstrates use of <br>          the AppleTalk PAP Protocol. Both a server and a client <br>          application are included in this source file. The client <br>          app reads a file and sends the contents to the server. The <br>          server writes out the received bytes to another file. <br> <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;time.h&gt; <br> <br>// <br>// the following header contains appletalk specific definitions. <br>// should be included for AppleTalk Windows Socket Applications <br>// <br>#include &lt;atalkwsh.h&gt; <br>#include "prsamp.h" <br> <br>#define SOCKET_COUNT                    32 <br> <br>#define DEF_SERVER_NAME                 "Windows Adsp" <br>#define DEF_SERVER_TYPE                 "Windows Sockets" <br>#define DEF_SERVER_ZONE                 "*" <br>#define BLOCKSIZE                       4096 <br> <br>#define DEF_QUEUE_LEN                   5 <br>#define ENTITY_LEN                      32 <br> <br>CHAR    gServerName[ENTITY_LEN]         = DEF_SERVER_NAME; <br>CHAR    gServerType[ENTITY_LEN]         = DEF_SERVER_TYPE; <br>CHAR    gServerZone[ENTITY_LEN]         = DEF_SERVER_ZONE; <br>CHAR    gProtocolName[10]               = "ADSP"; <br>INT     NumTimes                        = 5; <br>CHAR    gFileName[256]; <br> <br>LPSTR   pServerName   = gServerName; <br>LPSTR   pServerType   = gServerType; <br>LPSTR   pServerZone   = gServerZone; <br>LPSTR   pProtocolName = gProtocolName; <br>LPSTR   pFileName     = gFileName; <br> <br> <br>HANDLE  gFileHandle; <br>WSADATA WsaData; <br> <br>SYSTEMTIME    SystemStartTime; <br>SYSTEMTIME    SystemEndTime; <br>FILETIME      FileTime; <br> <br>BOOL fFileSpecified = FALSE; <br>BOOL fVerify = FALSE; <br>BOOL fRandom = FALSE; <br>BOOL fRDM    = FALSE; <br> <br>int loop = 1, looptot; <br>double Throughput, AvgThroughPut, MinThroughPut, MaxThroughPut; <br> <br>CHAR DataString[] = {"0123456789abcdefghijklmnopqrstuvwxyz~!@#$%^&amp;*()_+"}; <br> <br>#define NANOPOWER    1000000000 <br> <br>//#define DEBUG   <br> <br>typedef struct Sock_Info { <br>   int     sock_typ; <br>   int     prototyp; <br>   SOCKET  nsock; <br>} *PTEST_INFO, test_info; <br> <br>_cdecl main (IN SHORT argc, IN PSZ argv[]) <br>{ <br> <br>   register char p; <br>   register char *ptr; <br>   int i, r; <br>   BOOL fClient = FALSE; <br>   BOOL fServer = FALSE; <br> <br>   for(i = 1; i &lt; argc; i++) <br>   { <br>       p = argv[i][0]; <br> <br>       if (p == '/' || p == '-')          // option string <br>       { <br>           p = argv[i][1]; <br> <br>           switch(tolower(p)) <br>           { <br>               case 'n': <br>                   ptr = argv[i]+2; <br>                   if(*ptr == '\0') <br>                       usage(); <br>                   while(*pServerName++ = *ptr++); <br>                   break; <br>               case 't': <br>                   ptr = argv[i]+2; <br>                   if(*ptr == '\0') <br>                       usage(); <br>                   while(*pServerType++ = *ptr++); <br>                   break; <br>               case 'z': <br>                   ptr = argv[i]+2; <br>                   if(*ptr == '\0') <br>                       usage(); <br>                   while(*pServerZone++ = *ptr++); <br>                   break; <br>               case 's': <br>                   ptr = argv[i]+2; <br>                   if(*ptr != '\0') <br>                       usage(); <br>                   if(fClient == TRUE) <br>                       usage(); <br>                   fServer = TRUE; <br>                   break; <br>               case 'c': <br>                   ptr = argv[i]+2; <br>                   if(*ptr != '\0') <br>                       usage(); <br>                   if(fServer == TRUE) <br>                       usage(); <br>                   fClient = TRUE; <br>                   break; <br>               case 'p': <br>                   ptr = argv[i]+2; <br>                   if(*ptr == '\0') <br>                       usage(); <br>                   while(*pProtocolName++ = *ptr++); <br>                   break; <br>               case 'b': <br>                   ptr=argv[i]+2; <br>                   if(*ptr == '\0') <br>                       usage(); <br>                   NumTimes = atoi(ptr); <br>                   break; <br>               case 'f': <br>                   ptr = argv[i]+2; <br>                   if(*ptr == '\0') <br>                       usage(); <br>                   while(*pFileName++ = *ptr++); <br>                   fFileSpecified = TRUE; <br>                   break; <br>               case 'l': <br>                   ptr = argv[i]+2; <br>                   if(*ptr == '\0') <br>                       usage(); <br>                   loop = atoi(ptr); <br>                   break; <br>               case 'v': <br>                   ptr = argv[i]+2; <br>                   if(*ptr != '\0') <br>                       usage(); <br>                   fVerify = TRUE; <br>                   break; <br>               case 'r': <br>                   ptr = argv[i]+2; <br>                   if(*ptr != '\0') <br>                       usage(); <br>                   fRandom = TRUE; <br>                   break; <br>               case 'y': <br>                   ptr = argv[i]+2; <br>                   if(*ptr != '\0') <br>                       usage(); <br>                   fRDM = TRUE; <br>                   break; <br>               case '?': <br>               default: <br>                   usage(); <br> <br>           } <br>       } <br>       else <br>       { <br>           usage(); <br>       } <br> <br>   } <br> <br>#ifdef DEBUG <br>   printf("Server Name %s\n", gServerName); <br>   printf("Server Type %s\n", gServerType); <br>   printf("Server Zone %s\n", gServerZone); <br>#endif <br>   printf("%s throughput measurement\n", gProtocolName); <br> <br>   if(stricmp(gProtocolName, "ADSP") &amp;&amp; stricmp(gProtocolName, "PAP")) <br>   { <br>       printf("Invalid Protocol Specified\n"); <br>       exit(1); <br>   } <br> <br> <br>   if(!(fClient || fServer)) <br>       usage(); <br> <br>   r = WSAStartup(0x0101, &amp;WsaData); <br>   if (r == SOCKET_ERROR) <br>   { <br>       printf("Startup failed!\n"); <br>       WSACleanup(); <br>       return(0); <br>   } <br> <br>   if(fClient) <br>   { <br>       BOOL DClnt; <br> <br>       looptot = 0; <br>       MaxThroughPut = 0; <br>       AvgThroughPut = 0; <br>       if(fFileSpecified) <br>           printf("Ignoring -f option for client.\n"); <br>       while (looptot &lt; loop) <br>       { <br>           DClnt = DoClient(); <br>           if(DClnt) <br>           { <br>               if ((looptot == 0) || (MinThroughPut &gt; Throughput)) <br>                   MinThroughPut = Throughput; <br> <br>               if (MaxThroughPut &lt; Throughput) <br>                   MaxThroughPut = Throughput; <br> <br>               AvgThroughPut = ((AvgThroughPut * looptot) + Throughput) <br>                               / (looptot+1); <br>               printf("Loop %2d/%d Throughput Cur/Min/Max/Ave :", ++looptot, loop); <br>               printf(" %6.2f/%6.2f/%6.2f/%6.2f\n\n\n", Throughput, <br>                                                        MinThroughPut, <br>                                                        MaxThroughPut, <br>                                                        AvgThroughPut); <br>               Throughput = 0.0; <br>           } <br>           else <br>               break; <br>       } <br>   } <br> <br>   if(fServer) <br>       DoServer(); <br> <br>   WSACleanup(); <br>   return(0); <br>} <br> <br> <br>/****************************************************************************** <br>  <br> Function - DoServer() <br> <br> Calling Function - main(); <br> <br> Comments - This section of code calls the Server side of the application. <br>             <br>******************************************************************************/ <br> <br> <br>BOOL DoServer() <br>{ <br>   BOOL   fRet = FALSE; <br> <br>   do <br>   { <br> <br>// <br>// register the name specified on the command line  or use the <br>// defaults. <br>// <br> <br>       fRet = OpenSocketRegisterAndListen(); <br> <br> <br>   }while(FALSE); <br> <br>   return(fRet); <br> <br>} <br> <br> <br>/****************************************************************************** <br>  <br> Function - OpenSocketRegisterAndListen() <br> <br> Calling Function - DoServer(); <br> <br> Comments - This section of code controls the Server side of the application. <br>             <br>******************************************************************************/ <br> <br>BOOL OpenSocketRegisterAndListen() <br>{ <br> <br>   int                  r = 0;         // return from socket calls <br>   int                  pass_no = 1; <br>   BOOL                 fRet = TRUE; <br>   SOCKET               sock, newsock; // SOCKET descriptor <br>   SOCKADDR_AT          atalkaddr;     // See atalkwsh.h <br>   WSH_REGISTER_NAME    nbpname;       // structure for registering NBP name <br>                                       // see atalkwsh.h <br>   fd_set               readfds;       // fd_set strutture for select call <br>   int                  addrlen; <br>   PTEST_INFO           test; <br>   int                  sockettype = SOCK_STREAM; <br>   int                  protocoltype = ATPROTO_ADSP; <br>   int                  NumBytesRecvd = 0; <br>   unsigned long        ThreadId; <br> <br> <br> <br> <br> <br>// <br>// open a appletalk socket. The protocol family should be AF_APPLETALK, <br>// the socket type can be SOCK_STREAM or SOCK_RDM, and the ProtocolType <br>// for PAP socket must be ATPROTO_PAP. Note that opening a socket does <br>// not yet create an endpoint on the AppleTalk Protocol. A bind must <br>// happen before this socket can be used with AppleTalk; <br>// <br> <br>   do <br>   { <br>       if(!stricmp(gProtocolName, "PAP")) <br>       { <br>           sockettype = SOCK_RDM; <br>           protocoltype = ATPROTO_PAP; <br>       } <br>       else if (fRDM) <br>           sockettype = SOCK_RDM; <br> <br> <br>       sock = socket(AF_APPLETALK, sockettype, protocoltype); <br> <br>       if(sock == INVALID_SOCKET) <br>       { <br>           printf("Open Socket: Error = %ld\n", WSAGetLastError()); <br>           r = -1; <br>           break; <br>       } <br> <br>       atalkaddr.sat_socket = 0; <br>       atalkaddr.sat_family = AF_APPLETALK; <br> <br>       r = bind(sock, (struct sockaddr *)&amp;atalkaddr, sizeof(SOCKADDR_AT)); <br> <br>       if(r &lt; 0) <br>       { <br>           printf("Bind:Error = %d\n", WSAGetLastError()); <br>           break; <br>       } <br> <br>       // <br>       // end point has now been created on the AppleTalk Protocol <br>       // now register the name that the client will look up. <br>       // <br> <br>       strcpy(nbpname.ObjectName, gServerName); <br>       nbpname.ObjectNameLen = strlen(gServerName); <br> <br>       strcpy(nbpname.TypeName, gServerType); <br>       nbpname.TypeNameLen = strlen(gServerType); <br> <br>       strcpy(nbpname.ZoneName, "*"); <br>       nbpname.ZoneNameLen = strlen("*"); <br> <br>       printf("Registering %s:%s@%s\n", nbpname.ObjectName, <br>                                        nbpname.TypeName, <br>                                        nbpname.ZoneName); <br> <br> <br>       r = setsockopt(sock,                         // socket descriptor <br>                     SOL_APPLETALK,                 // socket level - always SOL_APPLETALK <br>                     SO_REGISTER_NAME,              // socket option <br>                     (char *)&amp;nbpname,              // nbp name structure <br>                     sizeof(WSH_NBP_NAME));         // size of nbp name structure <br> <br> <br>       if(r &lt; 0) <br>       { <br>           printf("Register Name: Error = %d\n", WSAGetLastError()); <br>           break; <br>       } <br> <br>   }while(FALSE); <br> <br>   if(r == SOCKET_ERROR) <br>   { <br>       closesocket(sock); <br>       return(FALSE); <br>   } <br> <br>// <br>// Post a listen on this socket. The default queue length is 5 <br>// <br> <br>   r =  listen(sock, DEF_QUEUE_LEN); <br> <br>   if(r &lt; 0) <br>   { <br>       printf("Listen:Error = %d\n", WSAGetLastError()); <br>       return FALSE; <br>   } <br> <br> <br>// <br>// listen is successful. select the socket for reading <br>// <br> <br>   do <br>   { <br> <br>       FD_ZERO(&amp;readfds);            // clear set <br>       FD_SET(sock, &amp;readfds);       // add sock to set <br> <br>// <br>// this is a blocking select. Select will complete when <br>// a client connects. <br>// <br> <br>       r = select(0, &amp;readfds, NULL, NULL, NULL); <br> <br>       if(r == SOCKET_ERROR) <br>       { <br>           printf("Select: Error = %d\n", WSAGetLastError()); <br>           fRet = FALSE; <br>           break; <br>       } <br> <br>       if ( r == 0) <br>       { <br>           printf("Select: no sockets available\n"); <br>           fRet = FALSE; <br>           break; <br>       } <br> <br>// <br>// Accept an incoming request. <br>// <br> <br>       addrlen = sizeof(SOCKADDR_AT); <br>       newsock = accept(sock, (struct sockaddr *)&amp;atalkaddr, &amp;addrlen); <br> <br>       if(newsock == INVALID_SOCKET) <br>       { <br>           printf("Accept: Socket Error = %d\n", WSAGetLastError()); <br> <br>           fRet = FALSE; <br>           break; <br>       } <br> <br>#ifdef DEBUG <br>//       printf("Accept Succeeded\n"); <br>#endif <br> <br> <br>       if(r == SOCKET_ERROR) <br>       { <br>           fRet = FALSE; <br>           break; <br>       } <br> <br> <br>       test = (PTEST_INFO) LocalAlloc(LPTR, sizeof(test_info));   <br>       test-&gt;sock_typ = sockettype; <br>       test-&gt;prototyp = protocoltype; <br>       test-&gt;nsock = newsock; <br>          <br>       if( ! CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PerfThread, <br>                            (PTEST_INFO) test, 0, &amp; ThreadId ) ) <br>       { <br>           fprintf(stderr,"CreateThread NULL 0 PerfThread %d 0 %d 0 %lx", <br>                        test-&gt;sock_typ, test-&gt;prototyp, (unsigned long) &amp; ThreadId); <br>           exit(1); <br>        } <br> <br>       if (fRet == FALSE) <br>           break; <br> <br>   }while (TRUE); <br> <br> <br>   closesocket(sock); <br> <br>   // <br>   // send all done <br>   // <br> <br>   return(TRUE); <br> <br>} <br> <br> <br>/****************************************************************************** <br>  <br> Function - PerfThread() <br> <br> Calling Function - OpenSocketRegisterAndListen(); <br> <br> Comments - This section of code controls the Server side Recieve and Verification <br>            for the application. <br>             <br>******************************************************************************/ <br> <br> <br>unsigned long PerfThread( PTEST_INFO lpvTest ) <br>{ <br>   int     r;                          // return from socket calls <br>   int     recvflags = 0;              // see WSARecvEx call <br>   CHAR    recvbuf[4096];              // recv buffer <br>   long    blockmode = 1;              // see ioctlsocket call <br>   BOOL    fRet = TRUE; <br>   int     NumBytesRecvd = 0, pass_no = 1; <br>   SOCKET  newsock = lpvTest-&gt;nsock;   // SOCKET descriptor <br>   int     sockettype = lpvTest-&gt;sock_typ; <br>   int     protocoltype = lpvTest-&gt;prototyp; <br> <br>   // <br>   // make socket non blocking. As far as possible, use non <br>   // blocking sockets to improve performance of app. <br>   // <br>   // <br> <br>   r = ioctlsocket(newsock, FIONBIO, &amp;blockmode); <br> <br>   if( r == SOCKET_ERROR) <br>   { <br>       printf("ioctlsocket: error = %d\n", WSAGetLastError()); <br>       fRet = FALSE; <br>       return(FALSE); <br>   } <br> <br>   do <br>   { <br> <br> <br>       // <br>       // Prime a Read here. This will enable the receive to complete <br>       // This is PAP specific. For other AppleTalk protocols - <br>       // ADSP and DDP a recv can be posted directly <br>       // <br> <br>       if(!stricmp(gProtocolName, "PAP")) <br>       { <br> <br>           r = setsockopt(newsock, <br>                          SOL_APPLETALK, <br>                          SO_PAP_PRIME_READ, <br>                          recvbuf, <br>                          sizeof(recvbuf)); <br> <br>           if( r &lt; 0) <br>           { <br>               printf("primeread: error = %d\n", WSAGetLastError()); <br>               fRet = FALSE; <br>               break; <br> <br>           } <br>       } <br> <br>       fRet = CheckForRecv(newsock); <br> <br>       if(fRet == FALSE) <br>           break; <br> <br>       r = WSARecvEx(newsock,recvbuf,sizeof(recvbuf), &amp;recvflags); <br> <br> <br>       if ((sockettype == SOCK_RDM) &amp;&amp; (r &lt; sizeof(recvbuf))) <br>       { <br>           printf("Did not receive entire message\n"); <br>           fRet = FALSE; <br>           break; <br>       } <br> <br>       if( r == SOCKET_ERROR) <br>       { <br> <br>           if (WSAGetLastError() == WSAEWOULDBLOCK) <br>               continue; <br>           else <br>           { <br>               if(WSAGetLastError() == WSAENOTCONN || WSAGetLastError() == WSAEFAULT) <br>                   break; <br>               printf("recv: error = %d\n", WSAGetLastError()); <br>               fRet = FALSE; <br>               break; <br>           } <br> <br>       } <br> <br>#ifdef DEBUG <br>//       printf("Recvd %d bytes\n", r); <br>#endif <br> <br>       if (fVerify) <br>       { <br>           int rr, pos = 0; <br> <br> <br>           do <br>           { <br>               fRet = CheckForSend(newsock); <br> <br>               if (fRet == FALSE) <br>               { <br>                   printf("send select error\n"); <br>                   break; <br>               } <br> <br>               rr = send(newsock, &amp;recvbuf[pos], r-pos, 0);    <br>                <br>               if ( rr &lt; 0 ) <br>               { <br>                   if(WSAGetLastError() == WSAEWOULDBLOCK) <br>                   {   <br>                       printf("Send: error = WSAEWOULDBLOCK\n"); <br>                       continue; <br>                   } <br>                   else <br>                   { <br>                       printf("send: error = %d\n", WSAGetLastError()); <br>                       break; <br>                   } <br> <br>               } <br> <br>#ifdef DEBUG <br>//           printf("Bytes Sent %d\n", rr); <br>#endif <br> <br>               pos += rr; <br> <br>               if (pos &gt;= r) <br>                   break; <br> <br>           } while(TRUE); <br> <br>       }  // endif Verify <br> <br> <br>       NumBytesRecvd += r; <br> <br>       // <br>       // reset the recv flags for the next WSARecvEx <br>       // <br>       recvflags = 0; <br> <br>   }while(TRUE); <br> <br>   printf("Total Number of Bytes Received = %d \n",NumBytesRecvd); <br> <br>   closesocket(newsock); <br>   LocalFree(lpvTest); <br> <br>   return(TRUE); <br>} <br> <br>/****************************************************************************** <br>  <br> Function - DoClient() <br> <br> Calling Function - main(); <br> <br> Comments - This section of code controls the Client side of the application. <br>             <br>******************************************************************************/ <br> <br>BOOL DoClient() <br>{ <br>   int                  r = 0;             // return code <br>   BOOL                 fRet = FALSE;      // <br>   int                  charcnt;           // count of bytes read from file <br>   CHAR                 LookupBuffer[512]; // LookUp results return buffer <br>   PCHAR                ptupleBuffer; <br>   PWSH_LOOKUP_NAME     pLookup; <br>   PWSH_NBP_TUPLE       pTempTuple; <br>   SOCKADDR_AT          ataddress; <br>   DWORD                WrittenSize; <br>   SOCKET               clntsock; <br>   long                 blockmode = 1;          // for ioctlsocket <br>   int                  BytesTransferred = 0; <br>   HLOCAL               memhandle; <br>   LPSTR                DataPtr, DataStartPtr, DataEndPtr; <br>   DWORD                hourdiff;          //, minutediff, seconddiff; <br>   double               StartSecond, EndSecond,ElapsedSeconds; <br>   int                  sockettype = SOCK_STREAM; <br>   int                  prototype = ATPROTO_ADSP; <br>   int                  i, rndbuf; <br> <br>   if(!stricmp(gProtocolName, "PAP")) <br>   { <br>       sockettype = SOCK_RDM; <br>       prototype = ATPROTO_PAP; <br>   } <br>   else if (fRDM) <br>       sockettype = SOCK_RDM; <br> <br>   if (fRandom) <br>       rndbuf = rand() % strlen(DataString) + 1; <br>   else <br>       rndbuf = strlen(DataString); <br> <br>   do <br>   { <br>       // <br>       // See socket call in OpenSocketRegisterAndListen for desc <br>       // <br>       clntsock = socket(AF_APPLETALK, sockettype, prototype); <br> <br>       if(clntsock == INVALID_SOCKET) <br>       { <br>           printf("Open Socket: Error = %ld\n", WSAGetLastError()); <br>           r = -1; <br>           break; <br> <br>       } <br> <br>       ataddress.sat_socket = 0; <br>       ataddress.sat_family = AF_APPLETALK; <br> <br> <br>       r = bind(clntsock, (struct sockaddr *)&amp;ataddress, sizeof(SOCKADDR_AT)); <br> <br>       if(r &lt; 0) <br>       { <br>           printf("Bind:Error = %d\n", WSAGetLastError()); <br>           break; <br>       } <br> <br>       // <br>       // end point has now been created on the AppleTalk Protocol. <br>       // lookup the server name. <br>       // <br> <br> <br>       pLookup = (PWSH_LOOKUP_NAME)LookupBuffer; <br> <br>       strcpy(pLookup-&gt;LookupTuple.NbpName.ObjectName, gServerName); <br>       pLookup-&gt;LookupTuple.NbpName.ObjectNameLen = strlen(gServerName); <br> <br>       strcpy(pLookup-&gt;LookupTuple.NbpName.TypeName,  gServerType); <br>       pLookup-&gt;LookupTuple.NbpName.TypeNameLen = strlen(gServerType); <br> <br>       strcpy(pLookup-&gt;LookupTuple.NbpName.ZoneName, gServerZone); <br>       pLookup-&gt;LookupTuple.NbpName.ZoneNameLen = strlen(gServerZone); <br> <br>#ifdef DEBUG <br>       printf("Looking up %s:%s@%s\n",pLookup-&gt;LookupTuple.NbpName.ObjectName, <br>                                      pLookup-&gt;LookupTuple.NbpName.TypeName, <br>                                      pLookup-&gt;LookupTuple.NbpName.ZoneName); <br>#endif <br> <br>       WrittenSize = sizeof(LookupBuffer); <br> <br>       r = getsockopt(clntsock, SOL_APPLETALK, SO_LOOKUP_NAME, <br>                      (char*)LookupBuffer, <br>                      &amp;WrittenSize); <br> <br>       if(r != NO_ERROR) <br>       { <br>           printf("getsockopt:error = %d\n", WSAGetLastError()); <br>           break; <br> <br>       } <br> <br>       if (pLookup-&gt;NoTuples &lt;= 0) <br>       { <br>           printf("LookupName failed - no tuples found\n"); <br>           r=-1; <br>           break; <br>       } <br> <br>       ptupleBuffer = (char *)pLookup+sizeof(WSH_LOOKUP_NAME); <br>       pTempTuple = (PWSH_NBP_TUPLE)ptupleBuffer; <br> <br>       ataddress.sat_family = AF_APPLETALK; <br>       ataddress.sat_net = pTempTuple[0].Address.Network; <br>       ataddress.sat_node = pTempTuple[0].Address.Node; <br>       ataddress.sat_socket = pTempTuple[0].Address.Socket; <br> <br>#ifdef DEBUG <br>       printf("server address = %lx.%lx.%lx.\n", ataddress.sat_net, <br>                                                 ataddress.sat_node, <br>                                                 ataddress.sat_socket); <br>#endif <br> <br> <br>       // <br>       // lookup succeeded. Use the address in ataddress to connect to the <br>       // server <br>       // <br> <br>       r =  connect(clntsock, (struct sockaddr *)&amp;ataddress, sizeof(SOCKADDR_AT)); <br> <br>       if(r &lt; 0) <br>       { <br>           printf("connect: error = %d\n", WSAGetLastError()); <br>           break; <br>       } <br> <br>#ifdef DEBUG <br>//       printf("Connect Succeeded\n"); <br>#endif <br> <br> <br>   }while(FALSE); <br> <br>   if(r &lt; 0) <br>   { <br>       closesocket(clntsock); <br>       return(FALSE); <br>   } <br> <br>   // <br>   //  Set Socket to non blocking mode <br>   // <br> <br>   r = ioctlsocket(clntsock, FIONBIO, &amp;blockmode); <br> <br>#ifdef DEBUG <br>//       printf("ioctlsocket Succeeded\n"); <br>#endif <br> <br>   if( r == SOCKET_ERROR) <br>   { <br>       printf("ioctlsocket: error = %d\n", WSAGetLastError()); <br>       return FALSE; <br>   } <br> <br>   // <br>   // Fill Up Send Buffer with Data <br>   // <br>   memhandle = LocalAlloc(LPTR, BLOCKSIZE); <br>   if(memhandle == NULL) <br>   { <br>       printf("LocalAlloc Failed %d\n", GetLastError()); <br>       return(FALSE); <br>   } <br>   DataPtr = LocalLock(memhandle); <br>   DataStartPtr = DataPtr; <br>   DataEndPtr = DataPtr + LocalSize(memhandle); <br> <br>   // <br>   // fill the buffer with Data <br>   // <br>   while((DataStartPtr + rndbuf) &lt;= DataEndPtr) <br>   { <br>       memcpy(DataStartPtr, DataString,rndbuf); <br>       DataStartPtr+= rndbuf; <br>   } <br> <br>   if(DataStartPtr != DataEndPtr) <br>       memcpy(DataStartPtr, DataString, DataEndPtr-DataStartPtr-1); <br> <br>   *DataEndPtr = '\0'; <br> <br>   fRet = CheckForSend(clntsock); <br> <br>   if(fRet == FALSE) <br>       return FALSE; <br> <br>   GetLocalTime(&amp;SystemStartTime); <br> <br>#ifdef DEBUG <br>   printf("Data Size = %d\n", lstrlen(DataPtr)); <br>//   printf("Base Data sent: %s\n",DataStartPtr); <br>   printf("Start Time:%d:%2d:%2d:%2d\t", SystemStartTime.wHour, <br>                                         SystemStartTime.wMinute, <br>                                         SystemStartTime.wSecond, <br>                                         SystemStartTime.wMilliseconds); <br>#endif <br> <br>   for( i= 0; i &lt; NumTimes; i++) <br>   { <br>       // <br>       // Can I send - CheckForSend calls select to find if we can send <br>       // without blocking <br>       // <br>       DataStartPtr = DataPtr; <br> <br>       do <br>       { <br>           fRet = CheckForSend(clntsock); <br> <br>           if(fRet == FALSE) <br>           { <br>               printf("send select error\n"); <br>               break; <br>           } <br> <br>           charcnt = DataEndPtr - DataStartPtr; <br> <br>           if(charcnt == 0) <br>               break; <br> <br>           r = send(clntsock, DataStartPtr, charcnt, 0); <br> <br> <br>           if ( r &lt; 0 ) <br>           { <br> <br>               if(WSAGetLastError() == WSAEWOULDBLOCK) <br>               { <br>                   printf("send: wouldblock\n"); <br>                   continue; <br>               } <br>               else <br>               { <br>                   printf("send: error = %d\n", WSAGetLastError()); <br>                   fRet = FALSE; <br>                   break; <br>               } <br> <br>           } <br>           else <br>           {  <br>            <br>#ifdef DEBUG <br>//               printf("Sent %d bytes\n",r); <br>#endif <br> <br>               if ((fVerify) &amp;&amp; (DataStartPtr + r == DataEndPtr)) <br>               { <br>                   CHAR buffer[4096]; <br>                   int recvflag = 0; <br>                   int rr, pos = 0; <br> <br>           // <br>           // Prime a Read here. This will enable the receive to complete <br>           // This is PAP specific. For other AppleTalk protocols - <br>           // ADSP and DDP a recv can be posted directly <br>           // <br> <br>                   if(!stricmp(gProtocolName, "PAP")) <br>                   { <br> <br>                       rr = setsockopt(clntsock, <br>                                      SOL_APPLETALK, <br>                                      SO_PAP_PRIME_READ, <br>                                      buffer, <br>                                      sizeof(buffer)); <br> <br>                       if( rr &lt; 0) <br>                       { <br>                           printf("primeread: error = %d\n", WSAGetLastError()); <br>                           fRet = FALSE; <br>                           break; <br>                       } <br>                   } <br> <br>                   do <br>                   { <br> <br>                       fRet = CheckForRecv(clntsock); <br> <br>                       if(fRet == FALSE) <br>                           break; <br> <br>                       rr = WSARecvEx(clntsock, &amp;buffer[pos], sizeof(buffer)-pos, &amp;recvflag); <br> <br>                       if( rr == SOCKET_ERROR) <br>                       { <br>                           if (WSAGetLastError() == WSAEWOULDBLOCK) <br>                               continue; <br>                           else <br>                           { <br>                               printf("recv: error = %d\n", WSAGetLastError()); <br>                               fRet = FALSE; <br>                               break; <br>                           } <br>                       } <br> <br>                       pos += rr; <br> <br>#ifdef DEBUG <br>//                       printf("Recv'd %d bytes\n",rr); <br>#endif <br> <br>                       if ((recvflag == 0) || (sockettype == SOCK_RDM) ||  <br>                           (pos == sizeof(buffer))) <br>                           break; <br>                       recvflag = 0; <br> <br>                   } while(TRUE); <br> <br> <br>                   if ((memcmp(DataPtr, buffer, 4096) != 0) &amp;&amp; (fRet != FALSE)) <br>                   { <br>                       printf("Strings do not compare\n"); <br>#ifdef DEBUG <br>//                       printf("Data sent: \n%s\n",DataPtr); <br>//                       printf("Data recv'd: \n%s\n",buffer); <br>#endif <br> <br>                   } <br> <br> <br>               } // IF (fVerify) <br> <br>               BytesTransferred += r; <br>               DataStartPtr += r; <br> <br>               if(DataStartPtr == DataEndPtr) <br>                   break; <br> <br>           } // IF send() PASSED <br> <br>       }while(TRUE); <br> <br>       if(fRet == FALSE) <br>           break; <br> <br>   } // FOR <br> <br>   GetLocalTime(&amp;SystemEndTime); <br> <br>#ifdef DEBUG <br>   printf("End Time:%d:%2d:%2d:%2d\t", SystemEndTime.wHour, <br>                                       SystemEndTime.wMinute, <br>                                       SystemEndTime.wSecond, <br>                                       SystemEndTime.wMilliseconds); <br>#endif <br> <br>   // <br>   // calculate the difference <br>   // <br> <br>   hourdiff = SystemEndTime.wHour - SystemStartTime.wHour; <br> <br>   StartSecond = (SystemStartTime.wHour * 3600) + <br>                 (SystemStartTime.wMinute * 60) + <br>                 SystemStartTime.wSecond + <br>                 (SystemStartTime.wMilliseconds * 0.001); <br> <br>   EndSecond = 0; <br> <br>   if(SystemEndTime.wMonth != SystemStartTime.wMonth) <br>   { <br>       EndSecond = (SystemEndTime.wDay * 24) * 3600; <br>       switch (SystemStartTime.wMonth) <br>       { <br>           case 1: <br>           case 3: <br>           case 5: <br>           case 7: <br>           case 8: <br>           case 10: <br>           case 12: <br>                   EndSecond = ((31 - SystemStartTime.wDay) * 24) + EndSecond; <br>                   break; <br>           case 4: <br>           case 6: <br>           case 9: <br>           case 11: <br>                   EndSecond = ((30 - SystemStartTime.wDay) * 24) + EndSecond; <br>                   break; <br>           case 2: <br>                   if((SystemStartTime.wYear % 400 == 0) ||  </code></pre>
<p>
</p>
<pre><code>((SystemStartTime.wYear % 4 == 0) &amp;&amp; <br>                       (SystemStartTime.wYear % 100 != 0))) <br>                       EndSecond = ((29 - SystemStartTime.wDay) * <br>                                     24) + EndSecond; <br>                   else <br>                       EndSecond = ((28 - SystemStartTime.wDay) * <br>                                     24) + EndSecond; <br>                   break; <br>       } <br>   } <br>   else <br>       if(SystemEndTime.wDay &gt; SystemStartTime.wDay) <br>       { <br>           EndSecond = ((SystemEndTime.wDay - SystemStartTime.wDay) * 24) * 3600; <br>       } <br> <br>   EndSecond = EndSecond + (SystemEndTime.wHour * 3600) + <br>               (SystemEndTime.wMinute * 60) + SystemEndTime.wSecond + <br>               (SystemEndTime.wMilliseconds * 0.001); <br> <br>   ElapsedSeconds = EndSecond-StartSecond; <br> <br>#ifdef DEBUG <br>   printf("Elapsed Time (secs) = %6.3f\n", ElapsedSeconds); <br>   printf("Bytes Transferred = %ld\n", BytesTransferred); <br>   printf("Send All Done\n"); <br>#endif <br> <br> <br>   if(ElapsedSeconds !=0) <br>   { <br>       Throughput = (BytesTransferred)/(ElapsedSeconds) ; <br> <br>#ifdef DEBUG <br>       printf("Throughput (bytes/sec) = %6.2f\n", Throughput); <br>#endif <br> <br>   } <br> <br>   printf("\n"); <br> <br>   closesocket(clntsock); <br> <br>   LocalFree(memhandle); <br>   return(TRUE); <br> <br>}   <br> <br> <br> <br>BOOL CheckForSend(SOCKET s) <br>{ <br> <br>   fd_set writefds; <br>   int r; <br> <br> <br>#ifdef DEBUG <br>   printf("\t\tChecking for Send..\n"); <br>#endif <br> <br>   FD_ZERO(&amp;writefds); <br>   FD_SET(s, &amp;writefds); <br> <br>   // <br>   // indefinite wait select <br>   // <br>   r =  select(0, NULL, &amp;writefds, NULL, NULL); <br> <br>   if( r != 1) <br>   { <br>       printf("select:error = %d\n", WSAGetLastError()); <br>       return(FALSE); <br>   } <br>   return(TRUE); <br>} <br>   <br>   <br>   <br>BOOL CheckForRecv(SOCKET s) <br>{ <br> <br>   fd_set readfds; <br>   int r; <br> <br>   FD_ZERO(&amp;readfds); <br>   FD_SET(s, &amp;readfds); <br> <br>#ifdef DEBUG <br>   printf("\t\tChecking for Recv..\n"); <br>#endif <br> <br>   r =  select(0, &amp;readfds, NULL, NULL, NULL); <br> <br>   if( r != 1) <br>   { <br>       printf("select:error = %d\n", WSAGetLastError()); <br>       return(FALSE); <br>   } <br>   return(TRUE); <br>} <br> <br>void usage() <br>{ <br> <br>   printf("prperf -s/c &lt;options&gt;\n"); <br>   printf("\t-s/c\t Server/Client\n"); <br>   printf("\t-n\t Server Name\n"); <br>   printf("\t-t\t Server Type \n"); <br>   printf("\t-z\t Server Zone \n"); <br>   printf("\t-p\t Protocol Name (ADSP/PAP)\n"); <br>   printf("\t-f\t File Name for data to be saved (server only) \n"); <br>   printf("\t-b\t Number of times to send a 4k buffer (Default = 5) \n"); <br>   printf("\t-l\t Number of times to re-start prperf (Default = 1) (Client only)\n"); <br>   printf("\t-v\t Verify Integraty of data transmission. \n"); <br>   printf("\t-r\t Randomize the size of the base data string. \n"); <br>   printf("\t-y\t Change ADSP to use SOCK_RDM instead of SOCK_STREAM. \n"); <br>   printf("\n"); <br>   exit(1); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
