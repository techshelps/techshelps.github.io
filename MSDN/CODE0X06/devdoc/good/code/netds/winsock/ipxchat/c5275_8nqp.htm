<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LISTEN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5281"></a>LISTEN.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   listen.c <br>// <br>//  PURPOSE:   Displays the "Listen" dialog box <br>// <br>//  FUNCTIONS: <br>//    CmdListen          - Displays the "Listen" dialog box. <br>//    Listen             - Processes messages for "Listen" dialog box. <br>//    MsgListenInit      - Centers dialog and initializes edit controls. <br>//    MsgListenConnected - Handles Connected message when socket is connected. <br>//    MsgListenCommand   - Process WM_COMMAND message sent to the listen box. <br>//    CmdListenDone      - Free the listen box and related data. <br>//    CmdListenNow       - Sets up listen on specified socket <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>#include &lt;windows.h&gt;            // required for all Windows applications <br>#include &lt;windowsx.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "globals.h"            // prototypes specific to this application <br> <br>LRESULT CALLBACK Listen(HWND, UINT, WPARAM, LPARAM); <br>LRESULT MsgListenInit(HWND, UINT, WPARAM, LPARAM); <br>LRESULT MsgListenCommand(HWND, UINT, WPARAM, LPARAM); <br>LRESULT MsgListenConnected(HWND, UINT, WPARAM, LPARAM); <br>LRESULT CmdListenNow(HWND, WORD, WORD, HWND); <br>LRESULT CmdListenDone(HWND, WORD, WORD, HWND); <br> <br>// Listen dialog message table definition. <br>MSD rgmsdListen[] = <br>{ <br>    {WM_COMMAND,    MsgListenCommand}, <br>    {WM_INITDIALOG, MsgListenInit}, <br>    {LDM_CONNECTED, MsgListenConnected} <br>}; <br> <br>MSDI msdiListen = <br>{ <br>    sizeof(rgmsdListen) / sizeof(MSD), <br>    rgmsdListen, <br>    edwpNone <br>}; <br> <br>// Listen dialog command table definition. <br>CMD rgcmdListen[] = <br>{ <br>    {IDOK,     CmdListenNow}, <br>    {IDCANCEL, CmdListenDone} <br>}; <br> <br>CMDI cmdiListen = <br>{ <br>    sizeof(rgcmdListen) / sizeof(CMD), <br>    rgcmdListen, <br>    edwpNone <br>}; <br> <br>// Module specific "globals"  Used when a variable needs to be <br>// accessed in more than one handler function. <br> <br>HFONT hfontDlg; <br> <br>// <br>//  FUNCTION: CmdListen(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Displays the "Listen" dialog box <br>// <br>//  PARAMETERS: <br>//    hwnd      - Window handle <br>//    wCommand  - IDM_LISTEN          (unused) <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl  - NULL                (unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>//    To process the IDM_LISTEN message, call DialogBox() to display the <br>//    Listen dialog box. <br> <br>LRESULT CmdListen(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    HMENU hmenu; <br> <br>    SetWindowText(hwnd, "IPX Chat Server");     // Change title bar text <br>     <br>    // Start Dialog <br>    if(DialogBox(hInst, "ListenBox", hwnd, (DLGPROC)Listen)) <br>    { <br> <br>        // Dialog got a connection!  Set Message to indicate <br>        // when we have data to read, or if the connection is <br>        // closed on us. <br>        if (WSAAsyncSelect(sock, <br>                           hwnd, <br>                           MW_DATAREADY, <br>                           FD_READ | FD_CLOSE) == SOCKET_ERROR)  <br>        { <br>            MessageBox(hwnd, "WSAAsyncSelect Failed!", NULL, MB_OK); <br>            CleanUp(); <br>            return 0; <br>        } <br> <br>        // Fix menus <br>        hmenu = GetMenu(hwnd); <br>        EnableMenuItem(hmenu, IDM_CONNECT, MF_GRAYED); <br>        EnableMenuItem(hmenu, IDM_LISTEN, MF_GRAYED); <br>        EnableMenuItem(hmenu, IDM_DISCONNECT, MF_ENABLED); <br>        return 0; <br>    } <br> <br>    // Listen Failed <br>    SetWindowText(hwnd, szTitle); <br>    return 0; <br>} <br> <br> <br>// <br>//  FUNCTION: Listen(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE:  Processes messages for "Listen" dialog box. <br>// <br>//  PARAMETERS: <br>//    hdlg - window handle of the dialog box <br>//    wMessage - type of message <br>//    wparam - message-specific information <br>//    lparam - message-specific information <br>// <br>//  RETURN VALUE: <br>//    TRUE - message handled <br>//    FALSE - message not handled <br>// <br>//  COMMENTS: <br>// <br>//     Gets port information from user and then listens <br>// <br>//     Listen when user clicks on the OK button.  Kill Dialog when connection <br>//     established. <br>// <br> <br>LRESULT CALLBACK Listen(HWND hdlg, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    return DispMessage(&amp;msdiListen, hdlg, uMessage, wparam, lparam); <br>} <br> <br> <br>// <br>//  FUNCTION: MsgListenInit(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: To center dialog and limit size of edit controls and initialize <br>// <br>//  PARAMETERS: <br>//    hdlg - The window handing the message. <br>//    uMessage - The message number. (unused). <br>//    wparam - Message specific data (unused). <br>//    lparam - Message specific data (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - message handled. <br>// <br>//  COMMENTS: <br>//    Set size of edit controls for the following <br>//           Socket   4  chars (2 2-digit hex numbers) <br>// <br> <br>LRESULT MsgListenInit(HWND hdlg, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br> <br>    // Create a font to use <br>    hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0,  <br>                          VARIABLE_PITCH | FF_SWISS, ""); <br> <br>    // Center the dialog over the application window <br>    CenterWindow (hdlg, GetWindow (hdlg, GW_OWNER)); <br>      <br>    // Initialize Socket Addresses <br>    SetDlgItemText(hdlg, LD_SOCKET, szListenSocket); <br> <br>    // Limit input to proper size strings <br>    SendDlgItemMessage(hdlg, LD_SOCKET, EM_LIMITTEXT, 4, 0); <br> <br>    return (TRUE); <br>} <br> <br>// <br>//  FUNCTION: MsgListenConnected(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: To handle connected message when socket is connected <br>// <br>//  PARAMETERS: <br>//    hdlg - The window handing the message. <br>//    uMessage - The message number. (unused). <br>//    wparam - Message specific data (unused). <br>//    lparam - Message specific data (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - message handled. <br>// <br>//  COMMENTS: <br>//    Performs accept() on incoming socket <br>// <br> <br>LRESULT MsgListenConnected(HWND hdlg, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    char outtext[128]; <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "Client Connected!"); <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "Calling accept()"); <br> <br>    pRemAddr = (PSOCKADDR_IPX)&amp;addr; <br>    addrlen = sizeof(addr); <br> <br>    // Accept connection <br>    if ((sock = accept(SrvSock, (struct sockaddr *)pRemAddr, &amp;addrlen)) == INVALID_SOCKET) <br>    { <br>        // accept() failed -- show status and clean up dialog <br>        sprintf(outtext, "Accept() failed, error %u",WSAGetLastError()); <br>        SetDlgItemText(hdlg, <br>                       LD_STATUS, <br>                       outtext); <br>        closesocket(SrvSock); <br>        WSACleanup(); <br>        EnableWindow(GetDlgItem(hdlg, IDOK), TRUE); <br>        EnableWindow(GetDlgItem(hdlg, LD_SOCKET), TRUE); <br>        SetFocus(GetDlgItem(hdlg, LD_SOCKET)); <br>        return(TRUE); <br>    } <br> <br>    // We're connected! <br>    GetAddrString(pRemAddr, outtext); <br>    lstrcat(outtext, " connected!"); <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   outtext); <br>           <br>    EndDialog(hdlg, TRUE);          // Exit the dialog <br>    DeleteObject (hfontDlg);        // Drop font <br>    return (TRUE); <br>} <br> <br>// <br>//  FUNCTION: MsgListenCommand(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Process WM_COMMAND message sent to the Listen box. <br>// <br>//  PARAMETERS: <br>//    hwnd - The window handing the message. <br>//    uMessage - The message number. (unused). <br>//    wparam - Message specific data (unused). <br>//    lparam - Message specific data (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - message handled. <br>// <br>//  COMMENTS: <br>//    Uses this DispCommand function defined in wndproc.c combined <br>//    with the cmdiListen structure defined in this file to handle <br>//    the command messages for the Listen dialog box. <br>// <br> <br>LRESULT MsgListenCommand(HWND   hwnd,  <br>                        UINT   uMessage,  <br>                        WPARAM wparam,  <br>                        LPARAM lparam) <br>{ <br>    return DispCommand(&amp;cmdiListen, hwnd, wparam, lparam); <br>} <br> <br>// <br>//  FUNCTION: CmdListenDone(HWND, WORD, HWND) <br>// <br>//  PURPOSE: Free the Listen box and related data. <br>// <br>//  PARAMETERS: <br>//    hdlg - The window handling the command. <br>//    wCommand - The command to be handled (unused). <br>//    wNotify   - Notification number      (unused) <br>//    hwndCtrl - NULL                      (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns TRUE. <br>// <br>//  COMMENTS: <br>//    Cleans up sockets then calls EndDialog to finish the dialog session. <br>// <br> <br>LRESULT CmdListenDone(HWND hdlg, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br> <br>    closesocket(SrvSock);    // Free any aborted socket resources <br>    WSACleanup(); <br>    DeleteObject (hfontDlg); // Drop the font <br>    EndDialog(hdlg, FALSE);  // Exit Dialog -- rtrn false since no connection <br>    return TRUE; <br>} <br> <br>// <br>//  FUNCTION: CmdListenNow(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Handles ID_OK message and listens on the specified socket <br>// <br>//  PARAMETERS: <br>//    hwnd - The window handling the command. <br>//    wCommand - The command to be handled (unused). <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl - NULL (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns TRUE. <br>// <br>//  COMMENTS: <br>//    Shows Listening address on status bar when listen is successful. <br>// <br> <br>LRESULT CmdListenNow(HWND hdlg, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    char szXferBuffer[5]; <br>    WORD wVersionRequested; <br>    WSADATA wsaData; <br>    char outtext[80]; <br> <br>    // Get Socket Address <br>    GetDlgItemText(hdlg, <br>         LD_SOCKET, <br>         szXferBuffer, <br>         13); <br>    wVersionRequested = MAKEWORD(1, 1); <br> <br>    SetDlgItemText(hdlg, <br>                  LD_STATUS, <br>                  "Calling WSAStartup"); <br> <br>    // Initializes winsock dll <br>    if(WSAStartup(wVersionRequested, &amp;wsaData) == SOCKET_ERROR) <br>    { <br> <br>        SetDlgItemText(hdlg, <br>                       LD_STATUS, <br>                       "WSAStartup failed"); <br>        return (TRUE); <br>    } <br> <br>    SetDlgItemText(hdlg, <br>          LD_STATUS, <br>          "WSAStartup Succeeded"); <br> <br>    SetDlgItemText(hdlg, <br>          LD_STATUS, <br>          "Calling socket()"); <br> <br>    // Allocate socket handle <br>    SrvSock = socket(AF_IPX,         // IPX Family <br>                     SOCK_SEQPACKET, // Gives message mode transfers <br>                     NSPROTO_SPX);   // SPX is connection oriented transport <br> <br>    if(SrvSock == INVALID_SOCKET) { <br>        SetDlgItemText(hdlg, <br>                       LD_STATUS, <br>                       "ERROR on socket()"); <br>        WSACleanup(); <br>        return(TRUE); <br>    } <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "socket() Succeeded"); <br> <br>    // Set up socket address to bind to <br>    memset(&amp;addr, 0, sizeof(addr));    // Clear address <br>    pSockAddr = (PSOCKADDR_IPX)&amp;addr;  // Set pointer <br>    pSockAddr-&gt;sa_family = AF_IPX;     // IPX Family <br>    // Make sure socket number is in network order <br>    AtoH(szXferBuffer, (char *)&amp;pSockAddr-&gt;sa_socket, 2); <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "Calling bind()"); <br> <br>    // Bind to socket address <br>    if(bind(SrvSock,  <br>            (PSOCKADDR) pSockAddr,  <br>            sizeof(SOCKADDR_IPX)) == SOCKET_ERROR) <br>    { <br>        SetDlgItemText(hdlg, <br>                       LD_STATUS, <br>                       "Error on bind()"); <br>        closesocket(SrvSock); <br>        WSACleanup(); <br>        return(TRUE); <br>    } <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "bind() Succeeded"); <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "Calling listen()"); <br> <br>    // Set up listen queue - this app only supports one connection so <br>    // queue length is set to 1. <br>    if (listen(SrvSock, 1) == SOCKET_ERROR) <br>    { <br>        sprintf(outtext, "FAILURE: listen() returned %u", WSAGetLastError()); <br>        SetDlgItemText(hdlg,                        <br>                       LD_STATUS, <br>                       outtext); <br>        closesocket(SrvSock); <br>        WSACleanup(); <br>        return(TRUE); <br>    } <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "listen() succeeded"); <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "Calling WSAAsyncSelect()"); <br> <br>    // Specify message to be posted when client connects <br>    if(WSAAsyncSelect(SrvSock,  <br>                      hdlg,  <br>                      LDM_CONNECTED,  <br>                      FD_ACCEPT) == SOCKET_ERROR) <br>    { <br>        SetDlgItemText(hdlg, <br>                       LD_STATUS, <br>                       "WSAAsyncSelect() failed"); <br>        closesocket(SrvSock); <br>        WSACleanup(); <br>        return(TRUE); <br>    } <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   "WSAAsyncSelect() succeeded"); <br> <br>    addrlen = sizeof(addr); <br> <br>    // Get full network.number.socket address <br>    if(getsockname(SrvSock,&amp;addr,&amp;addrlen) == SOCKET_ERROR) <br>    { <br>        lstrcpy(outtext, "ERROR getsocketname()"); <br>    } <br>    else <br>    { <br>        lstrcpy(outtext, "Listening on "); <br>        GetAddrString((PSOCKADDR_IPX)&amp;addr, outtext + lstrlen(outtext)); <br>    } <br> <br>    SetDlgItemText(hdlg, <br>                   LD_STATUS, <br>                   outtext); <br> <br>     <br>    SetFocus(GetDlgItem(hdlg, IDCANCEL));             // Give Cancel Button focus <br>    EnableWindow(GetDlgItem(hdlg, IDOK), FALSE);      // Grey OK button <br>    EnableWindow(GetDlgItem(hdlg, LD_SOCKET), FALSE); // Grey Socket Edit control <br>    return (TRUE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
