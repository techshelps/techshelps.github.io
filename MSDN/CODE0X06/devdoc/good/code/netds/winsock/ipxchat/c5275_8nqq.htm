<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MISC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5282"></a>MISC.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   misc.c <br>// <br>//  PURPOSE:  Contains all helper functions "global" to the application. <br>// <br>//  FUNCTIONS: <br>//    CenterWindow - Center one window over another. <br>//    ReceiveInBox - Reads incoming socket data. <br>//    SendOutBox   - Writes outgoing socket data. <br>//    AtoH         - Converts ascii string to network order hex <br>//    BtoH         - Converts ascii byte to hex <br>//    CleanUp      - closes sockets and detaches winsock dll <br>//    GetAddrString - Puts IPX address into &lt;network&gt;.&lt;node&gt;.&lt;socket&gt; string format <br>//    HtoA          - Converts network order hex to ascii string <br>//    HtoB          - Converts hex byte to asci string <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>#include &lt;windows.h&gt;            // required for all Windows applications <br>#include &lt;windowsx.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include "globals.h"            // prototypes specific to this application <br> <br> <br> <br>// <br>//  FUNCTION: CenterWindow(HWND, HWND) <br>// <br>//  PURPOSE:  Center one window over another. <br>// <br>//  PARAMETERS: <br>//    hwndChild - The handle of the window to be centered. <br>//    hwndParent- The handle of the window to center on. <br>// <br>//  RETURN VALUE: <br>// <br>//    TRUE  - Success <br>//    FALSE - Failure <br>// <br>//  COMMENTS: <br>// <br>//    Dialog boxes take on the screen position that they were designed <br>//    at, which is not always appropriate. Centering the dialog over a <br>//    particular window usually results in a better position. <br>// <br> <br>BOOL CenterWindow(HWND hwndChild, HWND hwndParent) <br>{ <br>    RECT    rcChild, rcParent; <br>    int     cxChild, cyChild, cxParent, cyParent; <br>    int     cxScreen, cyScreen, xNew, yNew; <br>    HDC     hdc; <br> <br>    // Get the Height and Width of the child window <br>    GetWindowRect(hwndChild, &amp;rcChild); <br>    cxChild = rcChild.right - rcChild.left; <br>    cyChild = rcChild.bottom - rcChild.top; <br> <br>    // Get the Height and Width of the parent window <br>    GetWindowRect(hwndParent, &amp;rcParent); <br>    cxParent = rcParent.right - rcParent.left; <br>    cyParent = rcParent.bottom - rcParent.top; <br> <br>    // Get the display limits <br>    hdc = GetDC(hwndChild); <br>    cxScreen = GetDeviceCaps(hdc, HORZRES); <br>    cyScreen = GetDeviceCaps(hdc, VERTRES); <br>    ReleaseDC(hwndChild, hdc); <br> <br>    // Calculate new X position, then adjust for screen <br>    xNew = rcParent.left + ((cxParent - cxChild) / 2); <br>    if (xNew &lt; 0) <br>    { <br>        xNew = 0; <br>    } <br>    else if ((xNew + cxChild) &gt; cxScreen) <br>    { <br>        xNew = cxScreen - cxChild; <br>    } <br> <br>    // Calculate new Y position, then adjust for screen <br>    yNew = rcParent.top  + ((cyParent - cyChild) / 2); <br>    if (yNew &lt; 0) <br>    { <br>        yNew = 0; <br>    } <br>    else if ((yNew + cyChild) &gt; cyScreen) <br>    { <br>        yNew = cyScreen - cyChild; <br>    } <br> <br>    // Set it, and return <br>    return SetWindowPos(hwndChild, <br>                        NULL, <br>                        xNew, yNew, <br>                        0, 0, <br>                        SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br>// <br>//  FUNCTION: ReceiveInBox(HWND, WPARAM, LPARAM, char *, int) <br>// <br>//  PURPOSE:  Reads incoming data from socket <br>// <br>//  PARAMETERS: <br>//    hWnd      - Handle to current window <br>//    uParam    - WPARAM (unused) <br>//    lParam    - LPARAM contains event (FD_READ or FD_CLOSE). <br>//    szRBuf    - Receive Buffer <br>//    cRBufLen  - size of Receive Buffer <br>// <br>//  RETURN VALUE: <br>// <br>//    TRUE  - Data Read <br>//    FALSE - If FD_CLOSE message <br>// <br>//  COMMENTS: <br>// <br>//    Called if socket has data OR if it is closed.  If closed post <br>//    WM_DISCONNECTED message.  Else read data and make sure it is <br>//    NULL terminated. <br>// <br> <br>BOOL ReceiveInBox(HWND hWnd, WPARAM uParam, LPARAM lParam, char * szRBuf, int cRBufLen) <br>{ <br>    char * pRBuf;     // temp buf pointer <br>    int cBytesRead;   // count of bytes actually read <br> <br>     <br>    if (LOWORD(lParam) == FD_CLOSE)                   // Is this a FD_CLOSE event? <br>    { <br>        SendMessage(hWnd, MW_DISCONNECTED, 0, 0);     // Yes, post message <br>        return(FALSE); <br>    } <br> <br>    pRBuf = szRBuf;   // Set temp pointer <br>    cRBufLen--;       // Save room for null terminator <br>           <br>    // read socket <br>    if((cBytesRead = recv(sock, pRBuf, cRBufLen, 0)) != SOCKET_ERROR) <br>        pRBuf += cBytesRead;    // Move temp pointer to end of buffer <br>               <br>    *pRBuf = 0;   // Null terminate - if recv() failed, then prBuf will  <br>                  // point to first byte of the buffer <br>     <br>    return (TRUE);   // We've got a buffer to display <br>} <br> <br>// <br>//  FUNCTION: SendOutBox(char *, int) <br>// <br>//  PURPOSE:  Reads incoming data from socket <br>// <br>//  PARAMETERS: <br>//    szSBuf    - Send Buffer <br>//    cSBufLen  - size of Send Buffer <br>// <br>//  COMMENTS: <br>// <br>//    Writes send buffer to socket -- repeats until all data is sent. <br>// <br> <br>void SendOutBox(char * szSBuf, int cSBufLen) <br>{ <br>    char * pSBuf; <br>    int cBytesSent; <br> <br>    pSBuf = szSBuf; // Set temp pointer <br>     <br>    while((cBytesSent = send(sock, <br>                             pSBuf, <br>                             cSBufLen, <br>                             0)) != SOCKET_ERROR) <br>    { <br>        pSBuf += cBytesSent; <br>        cSBufLen -= cBytesSent; <br>        if(!cSBufLen) return; <br>    } <br>} <br> <br>// <br>//  FUNCTION: AtoH(char *, char *, int) <br>// <br>//  PURPOSE:  Converts ascii string to network order hex <br>// <br>//  PARAMETERS: <br>//    src    - pointer to input ascii string <br>//    dest   - pointer to output hex <br>//    destlen - size of dest <br>// <br>//  COMMENTS: <br>// <br>//    2 ascii bytes make a hex byte so must put 1st ascii byte of pair <br>//    into upper nibble and 2nd ascii byte of pair into lower nibble. <br>// <br> <br>void AtoH(char * src, char * dest, int destlen) <br>{ <br>    char * srcptr; <br> <br>    srcptr = src; <br> <br>    while(destlen--) <br>    { <br>    *dest = BtoH(*srcptr++) &lt;&lt; 4;    // Put 1st ascii byte in upper nibble. <br>    *dest++ += BtoH(*srcptr++);      // Add 2nd ascii byte to above. <br>    } <br>} <br> <br>// <br>//  FUNCTION: BtoH(char *, char *, int) <br>// <br>//  PURPOSE:  Converts ascii byte to numeric <br>// <br>//  PARAMETERS: <br>//    ch - ascii byte to convert <br>// <br>//  RETURNS: <br>//    associated numeric value <br>// <br>//  COMMENTS: <br>// <br>//    Will convert any hex ascii digit to its numeric counterpart. <br>//    Puts in 0xff if not a valid hex digit. <br>// <br> <br>unsigned char BtoH(char ch) <br>{ <br>    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') return (ch - '0');        // Handle numerals <br>    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') return (ch - 'A' + 0xA);  // Handle capitol hex digits <br>    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') return (ch - 'a' + 0xA);  // Handle small hex digits <br>    return(255); <br>} <br> <br>// <br>//  FUNCTION: CleanUp(void) <br>// <br>//  PURPOSE:  Protocol specific cleanup function <br>// <br>//  COMMENTS: <br>// <br>//    Deletes our two possible sockets (they might not exist which <br>//    just means closesocket might return an error -- we don't care). <br>// <br> <br>void CleanUp(void) <br>{ <br>    closesocket(SrvSock);  // Close our server side socket <br>    closesocket(sock);     // Close our connection specific socket <br>    WSACleanup();          // Nix the DLL <br>} <br> <br>// <br>//  FUNCTION: GetAddrString(PSOCKADDR_IPX, char *) <br>// <br>//  PURPOSE:  Converts IPX address to ascii string for displaying <br>// <br>//  PARAMETERS: <br>//    pSAddr - pointer to socket address struc <br>//    dest   - pointer to destination string <br>// <br>//  COMMENTS: <br>// <br>//    Address is in network order to use HtoA to convert to ascii. <br>//     <br>//    Final format is  <br>//      &lt;8 char network address&gt;.&lt;12 char node address&gt;.&lt;4 char sock address&gt; <br>// <br> <br>void GetAddrString(PSOCKADDR_IPX pSAddr, char * dest) <br>{ <br>    char abuf[15];                                // temp buffer <br>    char * currptr;                               // temp destination pointer <br>    int saddrlen = sizeof(struct sockaddr_ipx);   // sizeof address struc <br> <br>    currptr = dest; // initialize destination pointer <br> <br>    HtoA((char *)&amp;pSAddr-&gt;sa_netnum, abuf, 4);    // convert network number <br>    lstrcpy(currptr, abuf); <br>    currptr += 8; <br>    lstrcat(currptr, ".");                        // don't forget seperator <br>    currptr++; <br>     <br>    HtoA((char *)&amp;pSAddr-&gt;sa_nodenum, abuf, 6);   // convert node number <br>    lstrcat(currptr, abuf); <br>    currptr += 12; <br>    lstrcat(currptr, ".");                        // seperator <br>    currptr++; <br> <br>    HtoA((char *)&amp;pSAddr-&gt;sa_socket, abuf, 2);    // convert socket number <br>    lstrcat(currptr, abuf); <br>    <br>} <br> <br>// <br>//  FUNCTION: HtoA(char *, char *, int) <br>// <br>//  PURPOSE:  Converts network ordered hex to ascii string <br>// <br>//  PARAMETERS: <br>//    src     - pointer to network ordered hex <br>//    dest    - pointer to ascii string <br>//    srclen  - size of hex number in bytes <br>// <br>//  COMMENTS: <br>// <br>//    1 byte hex = 2 bytes ascii so convert high order nibble with HtoB() <br>//    then convert low order nibble. dest buffer better be 2*srclen + 1. <br>// <br> <br>void HtoA(char * src, char * dest, int srclen) <br>{ <br>    char * destptr; // temp pointers <br>    UCHAR * srcptr; <br>         <br>    srcptr = (UCHAR *)src; <br>    destptr = dest; <br> <br>    while(srclen--) <br>    { <br>    *destptr++ = HtoB((UCHAR)(*srcptr &gt;&gt; 4));      // Convert high order nibble <br>    *destptr++ = HtoB((UCHAR)(*srcptr++ &amp; 0x0F));  // Convert low order nibble <br>    } <br>    *destptr = 0;  // Null terminator <br>} <br> <br>// <br>//  FUNCTION: HtoB(UCHAR) <br>// <br>//  PURPOSE:  Converts hex byte to ascii byte <br>// <br>//  PARAMETERS: <br>//    ch - Hex byte <br>//                  <br>//  RETURNS: <br>//    ascii byte <br>// <br>//  COMMENTS: <br>// <br>//    We actually only convert a nibble since 1 byte hex = 2 bytes ascii. <br>//    So if ch &gt; 0xf we just return 'X'. <br>// <br> <br>char HtoB(UCHAR ch) <br>{ <br>    if (ch &lt;= 9) return ('0' + ch);             // handle decimal values <br>    if (ch &lt;= 0xf) return ('A' + ch - 10);      // handle hexidecimal specific values <br>    return('X');                                // Someone screwed up <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
