<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIMPLEC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5358"></a>SIMPLEC.C</h2>
<pre><code>/******************************************************************************\ <br>* simplec.c - Simple TCP/UDP client using Winsock 1.1 <br>*  <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;winsock2.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#define DEFAULT_PORT 5001 <br>#define DEFAULT_PROTO SOCK_STREAM // TCP <br> <br>void Usage(char *progname) { <br>fprintf(stderr,"Usage\n%s -p [protocol] -n [server] -e [endpoint] \ <br>-l [iterations]\n", <br>progname); <br>fprintf(stderr,"Where:\n\tprotocol is one of TCP or UDP\n"); <br>fprintf(stderr,"\tserver is the IP address or name of server\n"); <br>fprintf(stderr,"\tendpoint is the port to listen on\n"); <br>fprintf(stderr,"\titerations is the number of loops to execute\n"); <br>fprintf(stderr,"\t(-l by itself makes client run in an infinite loop,"); <br>fprintf(stderr," Hit Ctrl-C to terminate it)\n"); <br>fprintf(stderr,"Defaults are TCP , localhost and 5001\n"); <br>WSACleanup(); <br>exit(1); <br>} <br>int main(int argc, char **argv) { <br> <br>char Buffer[128]; <br>char *server_name= "localhost"; <br>unsigned short port = DEFAULT_PORT; <br>int retval, loopflag=0; <br>int i, loopcount,maxloop=-1; <br>unsigned int addr; <br>int socket_type = DEFAULT_PROTO; <br>struct sockaddr_in server; <br>struct hostent *hp; <br>WSADATA wsaData; <br>SOCKET  conn_socket; <br> <br>if (argc &gt;1) { <br>for(i=1;i &lt;argc;i++) { <br>if ( (argv[i][0] == '-') || (argv[i][0] == '/') ) { <br>switch(tolower(argv[i][1])) { <br>case 'p': <br>if (!stricmp(argv[i+1], "TCP") ) <br>socket_type = SOCK_STREAM; <br>else if (!stricmp(argv[i+1], "UDP") ) <br>socket_type = SOCK_DGRAM; <br>else <br>Usage(argv[0]); <br>i++; <br>break; <br> <br>case 'n': <br>server_name = argv[++i]; <br>break; <br>case 'e': <br>port = atoi(argv[++i]); <br>break; <br>case 'l': <br>loopflag =1; <br>if (argv[i+1]) { <br>if (argv[i+1][0] != '-')  <br>maxloop = atoi(argv[i+1]); <br>} <br>else <br>maxloop = -1; <br>i++; <br>break; <br>default: <br>Usage(argv[0]); <br>break; <br>} <br>} <br>else <br>Usage(argv[0]); <br>} <br>} <br> <br>if (WSAStartup(0x202,&amp;wsaData) == SOCKET_ERROR) { <br>fprintf(stderr,"WSAStartup failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>if (port == 0){ <br>Usage(argv[0]); <br>} <br> <br>// <br>// Attempt to detect if we should call gethostbyname() or <br>// gethostbyaddr() <br> <br>if (isalpha(server_name[0])) {   /* server address is a name */ <br>hp = gethostbyname(server_name); <br>} <br>else  { /* Convert nnn.nnn address to a usable one */ <br>addr = inet_addr(server_name); <br>hp = gethostbyaddr((char *)&amp;addr,4,AF_INET); <br>} <br>if (hp == NULL ) { <br>fprintf(stderr,"Client: Cannot resolve address [%s]: Error %d\n", <br>server_name,WSAGetLastError()); <br>WSACleanup(); <br>exit(1); <br>} <br> <br>// <br>// Copy the resolved information into the sockaddr_in structure <br>// <br>memset(&amp;server,0,sizeof(server)); <br>memcpy(&amp;(server.sin_addr),hp-&gt;h_addr,hp-&gt;h_length); <br>server.sin_family = hp-&gt;h_addrtype; <br>server.sin_port = htons(port); <br> <br>conn_socket = socket(AF_INET,socket_type,0); /* Open a socket */ <br>if (conn_socket &lt;0 ) { <br>fprintf(stderr,"Client: Error Opening socket: Error %d\n", <br>WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>// <br>// Notice that nothing in this code is specific to whether we  <br>// are using UDP or TCP. <br>// We achieve this by using a simple trick. <br>//    When connect() is called on a datagram socket, it does not  <br>//    actually establish the connection as a stream (TCP) socket <br>//    would. Instead, TCP/IP establishes the remote half of the <br>//    ( LocalIPAddress, LocalPort, RemoteIP, RemotePort) mapping. <br>//    This enables us to use send() and recv() on datagram sockets, <br>//    instead of recvfrom() and sendto() <br> <br> <br>printf("Client connecting to: %s\n",hp-&gt;h_name); <br>if (connect(conn_socket,(struct sockaddr*)&amp;server,sizeof(server)) <br>== SOCKET_ERROR) { <br>fprintf(stderr,"connect() failed: %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>// cook up a string to send <br>// <br>loopcount =0; <br>while(1) { <br>wsprintf(Buffer,"This is a small test message [number %d]",loopcount++); <br>retval = send(conn_socket,Buffer,sizeof(Buffer),0); <br>if (retval == SOCKET_ERROR) { <br>fprintf(stderr,"send() failed: error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>printf("Sent Data [%s]\n",Buffer); <br>retval = recv(conn_socket,Buffer,sizeof (Buffer),0 ); <br>if (retval == SOCKET_ERROR) { <br>fprintf(stderr,"recv() failed: error %d\n",WSAGetLastError()); <br>closesocket(conn_socket); <br>WSACleanup(); <br>return -1; <br>} <br>// <br>// We are not likely to see this with UDP, since there is no <br>// 'connection' established.  <br>// <br>if (retval == 0) { <br>printf("Server closed connection\n"); <br>closesocket(conn_socket); <br>WSACleanup(); <br>return -1; <br>} <br>printf("Received %d bytes, data [%s] from server\n",retval,Buffer); <br>if (!loopflag){ <br>printf("Terminating connection\n"); <br>break; <br>} <br>else { <br>if ( (loopcount &gt;= maxloop) &amp;&amp; (maxloop &gt;0) ) <br>break; <br>} <br>} <br>closesocket(conn_socket); <br>WSACleanup(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
