<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IOCTL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5357"></a>IOCTL.C</h2>
<pre><code>/******************************************************************************\ <br>* ioctl.c - TCP server <br>* <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;winsock2.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#define DEFAULT_PORT 5001 <br> <br>int ReadAndEcho(SOCKET , char *,int ) ; <br>int WriteMessage(SOCKET , char *,int ) ; <br> <br>void Usage(char *progname) { <br>fprintf(stderr,"Usage\n%s -e [endpoint] -i [interface]\n", <br>progname); <br>fprintf(stderr,"Where:\n"); <br>fprintf(stderr,"\tendpoint is the port to listen on\n"); <br>fprintf(stderr,"\tinterface is the ipaddr (in dotted decimal notation)"); <br>fprintf(stderr," to bind to\n"); <br>fprintf(stderr,"Defaults are 5001 and INADDR_ANY\n"); <br>WSACleanup(); <br>exit(1); <br>} <br>int main(int argc, char **argv) { <br> <br>char Buffer[128]; <br>char *interface= NULL; <br>unsigned short port=DEFAULT_PORT; <br>int fromlen; <br>int i, ioctl_opt =1; <br>struct sockaddr_in local, from; <br>WSADATA wsaData; <br>SOCKET listen_socket, msgsock; <br>fd_set readfds, writefds, exceptfds; <br> <br>/* Parse arguments */ <br>if (argc &gt;1) { <br>for(i=1;i &lt;argc;i++) { <br>if ( (argv[i][0] == '-') || (argv[i][0] == '/') ) { <br>switch(tolower(argv[i][1])) { <br>case 'i': <br>interface = argv[++i]; <br>break; <br>case 'e': <br>port = atoi(argv[++i]); <br>break; <br>default: <br>Usage(argv[0]); <br>break; <br>} <br>} <br>else <br>Usage(argv[0]); <br>} <br>} <br> <br>if (WSAStartup(0x202,&amp;wsaData) == SOCKET_ERROR) { <br>fprintf(stderr,"WSAStartup failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>if (port == 0){ <br>Usage(argv[0]); <br>} <br> <br>// <br>// The fd sets should be zeroed out before using them to prevent errors. <br>FD_ZERO(&amp;readfds); <br>FD_ZERO(&amp;writefds); <br>FD_ZERO(&amp;exceptfds); <br>memset(Buffer,0,sizeof(Buffer)); <br> <br>local.sin_family = AF_INET; <br> <br>// <br>// bind to specific interface if desired. <br> <br>local.sin_addr.s_addr = (!interface)?INADDR_ANY:inet_addr(interface);  <br> <br>/*  <br> * Port MUST be in Network Byte Order <br> */ <br>local.sin_port = htons(port); <br> <br>listen_socket = socket(AF_INET, SOCK_STREAM,0); // TCP socket <br>if (listen_socket == INVALID_SOCKET){ <br>fprintf(stderr,"socket() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>// <br>// bind() associates a local address and port combination with the <br>// socket just created.  <br> <br>if (bind(listen_socket,(struct sockaddr*)&amp;local,sizeof(local) )  <br>== SOCKET_ERROR) { <br>fprintf(stderr,"bind() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>// <br>// start listening on the socket for incoming connections <br>// <br>if (listen(listen_socket,5) == SOCKET_ERROR) { <br>fprintf(stderr,"listen() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>printf("%s: Listening on port %d\n",argv[0],port); <br> <br>// <br>// Set the socket to non-blocking mode. <br>// <br>if (ioctlsocket(listen_socket,FIONBIO,&amp;ioctl_opt) == SOCKET_ERROR) { <br>fprintf(stderr,"ioctlsocket failed %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>// <br>// The structure of the loop below is very simple. We only accept one <br>// connection at a time. As soon as another client connects, we <br>// disconnect the first one, and start talking to the new client. <br>// All this server does is to echo the data received on the socket <br>// back to the client. <br>// <br>// This is not a very realistic server, but it does serve to show that <br>// select() does not scale very well on win32. If we were dealing <br>// with more than one client, we would have to have a list of sockets <br>// that are in each fdset to be able to check them when select() <br>// returns. <br>// <br>while(1) { <br> <br>// <br>// A socket in the listen() state becomes ready to read when a <br>// client connects to it. An accept() will complete without <br>// blocking. <br>// Since select sets the sockets that are ready to be read from or <br>// written to, we have to include listen_socket in the fdset each time <br>// through the loop. <br>// <br> <br>FD_SET(listen_socket,&amp;readfds); <br> <br>i = select(0,&amp;readfds,&amp;writefds,&amp;exceptfds,NULL); <br>if (i == SOCKET_ERROR) { <br>fprintf(stderr,"select failed %d\n",WSAGetLastError()); <br>} <br>if (i==0){ <br>fprintf(stderr,"Select returned no fds ready\n"); <br>} <br> <br>if (FD_ISSET(listen_socket, &amp;readfds)){ <br>// <br>// close the previous client socket.  <br>// We must also clear it from the fdset to prevent select() <br>// from failing. <br>// <br>closesocket(msgsock); <br>FD_CLR(msgsock,&amp;readfds); <br>FD_CLR(msgsock,&amp;writefds); <br>fromlen = sizeof(from); <br>msgsock= accept(listen_socket,(struct sockaddr*)&amp;from,&amp;fromlen); <br>if (msgsock == INVALID_SOCKET) { <br>fprintf(stderr,"accept failed %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>FD_SET(msgsock,&amp;writefds); <br>FD_SET(msgsock,&amp;readfds); <br>continue; <br>} <br>if (FD_ISSET(msgsock,&amp;readfds) ) { <br>// <br>// socket is ready to read, i.e., there is data on the socket. <br>// <br>if (ReadAndEcho(msgsock,Buffer,sizeof(Buffer))&lt;0) { <br>fprintf(stderr,"terminating connection\n"); <br>FD_CLR(msgsock,&amp;readfds); <br>FD_CLR(msgsock,&amp;writefds); <br>closesocket(msgsock); <br>continue; <br>} <br>} <br>if (FD_ISSET(msgsock,&amp;writefds) ){ <br>if (WriteMessage(msgsock,Buffer,sizeof(Buffer)) &lt;=0) { <br>fprintf(stderr,"terminating connection\n"); <br>FD_CLR(msgsock,&amp;readfds); <br>FD_CLR(msgsock,&amp;writefds); <br>closesocket(msgsock); <br>continue; <br>} <br>} <br>FD_SET(msgsock,&amp;writefds); <br>FD_SET(msgsock,&amp;readfds); <br>} <br>} <br>int ReadAndEcho(SOCKET insock, char *Buffer,int size) { <br>int rc; <br> <br>rc = recv(insock,Buffer,size,0); <br> <br>if (rc == SOCKET_ERROR) { <br>fprintf(stderr,"recv() failed with error %d\n",WSAGetLastError()); <br>return -1; <br>} <br>if (rc ==0) { <br>fprintf(stderr,"Connection closed by client\n"); <br>return 0; <br>} <br>printf("Received [%s] from client\n",Buffer); <br>return rc; <br>} <br>int WriteMessage(SOCKET outsock, char *Buffer,int size) { <br>int rc; <br>int lasterr; <br> <br>printf("Sending [%s] to client\n",Buffer); <br>rc = send(outsock,Buffer,size, 0); <br> <br>if (rc == SOCKET_ERROR) { <br>  lasterr = WSAGetLastError(); <br>  if (lasterr == WSAEWOULDBLOCK) <br>return 0; <br>  else { <br>fprintf(stderr,"send() failed with error %d\n",lasterr); <br>return -1; <br>  } <br>} <br>if (rc ==0) { <br>fprintf(stderr,"Connection closed by client\n"); <br>} <br>return rc; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
