<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIMPLES.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5359"></a>SIMPLES.C</h2>
<pre><code>/******************************************************************************\ <br>* simples.c - Simple TCP/UDP server using Winsock 1.1 <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;winsock2.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#define DEFAULT_PORT 5001 <br>#define DEFAULT_PROTO SOCK_STREAM // TCP <br> <br>void Usage(char *progname) { <br>fprintf(stderr,"Usage\n%s -p [protocol] -e [endpoint] -i [interface]\n", <br>progname); <br>fprintf(stderr,"Where:\n\tprotocol is one of TCP or UDP\n"); <br>fprintf(stderr,"\tendpoint is the port to listen on\n"); <br>fprintf(stderr,"\tinterface is the ipaddr (in dotted decimal notation)"); <br>fprintf(stderr," to bind to\n"); <br>fprintf(stderr,"Defaults are TCP,5001 and INADDR_ANY\n"); <br>WSACleanup(); <br>exit(1); <br>} <br>int main(int argc, char **argv) { <br> <br>char Buffer[128]; <br>char *interface= NULL; <br>unsigned short port=DEFAULT_PORT; <br>int retval; <br>int fromlen; <br>int i; <br>int socket_type = DEFAULT_PROTO; <br>struct sockaddr_in local, from; <br>WSADATA wsaData; <br>SOCKET listen_socket, msgsock; <br> <br>/* Parse arguments */ <br>if (argc &gt;1) { <br>for(i=1;i &lt;argc;i++) { <br>if ( (argv[i][0] == '-') || (argv[i][0] == '/') ) { <br>switch(tolower(argv[i][1])) { <br>case 'p': <br>if (!stricmp(argv[i+1], "TCP") ) <br>socket_type = SOCK_STREAM; <br>else if (!stricmp(argv[i+1], "UDP") ) <br>socket_type = SOCK_DGRAM; <br>else <br>Usage(argv[0]); <br>i++; <br>break; <br> <br>case 'i': <br>interface = argv[++i]; <br>break; <br>case 'e': <br>port = atoi(argv[++i]); <br>break; <br>default: <br>Usage(argv[0]); <br>break; <br>} <br>} <br>else <br>Usage(argv[0]); <br>} <br>} <br> <br>if (WSAStartup(0x202,&amp;wsaData) == SOCKET_ERROR) { <br>fprintf(stderr,"WSAStartup failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>if (port == 0){ <br>Usage(argv[0]); <br>} <br> <br>local.sin_family = AF_INET; <br>local.sin_addr.s_addr = (!interface)?INADDR_ANY:inet_addr(interface);  <br> <br>/*  <br> * Port MUST be in Network Byte Order <br> */ <br>local.sin_port = htons(port); <br> <br>listen_socket = socket(AF_INET, socket_type,0); // TCP socket <br> <br>if (listen_socket == INVALID_SOCKET){ <br>fprintf(stderr,"socket() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>// <br>// bind() associates a local address and port combination with the <br>// socket just created. This is most useful when the application is a  <br>// server that has a well-known port that clients know about in advance. <br>// <br> <br>if (bind(listen_socket,(struct sockaddr*)&amp;local,sizeof(local) )  <br>== SOCKET_ERROR) { <br>fprintf(stderr,"bind() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>// <br>// So far, everything we did was applicable to TCP as well as UDP. <br>// However, there are certain steps that do not work when the server is <br>// using UDP. <br>// <br> <br>// We cannot listen() on a UDP socket. <br> <br>if (socket_type != SOCK_DGRAM) { <br>if (listen(listen_socket,5) == SOCKET_ERROR) { <br>fprintf(stderr,"listen() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>} <br>printf("%s: 'Listening' on port %d, protocol %s\n",argv[0],port, <br>(socket_type == SOCK_STREAM)?"TCP":"UDP"); <br>while(1) { <br>fromlen =sizeof(from); <br>// <br>// accept() doesn't make sense on UDP, since we do not listen() <br>// <br>if (socket_type != SOCK_DGRAM) { <br>msgsock = accept(listen_socket,(struct sockaddr*)&amp;from, &amp;fromlen); <br>if (msgsock == INVALID_SOCKET) { <br>fprintf(stderr,"accept() error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>printf("accepted connection from %s, port %d\n",  <br>inet_ntoa(from.sin_addr), <br>htons(from.sin_port)) ; <br> <br>} <br>else <br>msgsock = listen_socket; <br> <br>// <br>// In the case of SOCK_STREAM, the server can do recv() and  <br>// send() on the accepted socket and then close it. <br> <br>// However, for SOCK_DGRAM (UDP), the server will do <br>// recvfrom() and sendto()  in a loop. <br> <br>if (socket_type != SOCK_DGRAM) <br>retval = recv(msgsock,Buffer,sizeof (Buffer),0 ); <br>else { <br>retval = recvfrom(msgsock,Buffer,sizeof (Buffer),0, <br>(struct sockaddr *)&amp;from,&amp;fromlen); <br>printf("Received datagram from %s\n",inet_ntoa(from.sin_addr)); <br>} <br> <br>if (retval == SOCKET_ERROR) { <br>fprintf(stderr,"recv() failed: error %d\n",WSAGetLastError()); <br>closesocket(msgsock); <br>continue; <br>} <br>if (retval == 0) { <br>printf("Client closed connection\n"); <br>closesocket(msgsock); <br>continue; <br>} <br>printf("Received %d bytes, data [%s] from client\n",retval,Buffer); <br> <br>printf("Echoing same data back to client\n"); <br>if (socket_type != SOCK_DGRAM) <br>retval = send(msgsock,Buffer,sizeof(Buffer),0); <br>else <br>retval = sendto(msgsock,Buffer,sizeof (Buffer),0, <br>(struct sockaddr *)&amp;from,fromlen); <br>if (retval == SOCKET_ERROR) { <br>fprintf(stderr,"send() failed: error %d\n",WSAGetLastError()); <br>} <br>if (socket_type != SOCK_DGRAM){ <br>printf("Terminating connection\n"); <br>closesocket(msgsock); <br>} <br>else  <br>printf("UDP server looping back for more requests\n"); <br>continue; <br>} <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
