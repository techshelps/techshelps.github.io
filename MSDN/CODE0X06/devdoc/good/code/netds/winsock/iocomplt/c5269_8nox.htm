<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SOCKCLI.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5271"></a>SOCKCLI.C</h2>
<pre><code><br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   sockcli.c <br>// <br>//  PURPOSE:  Generate a simulated load for a sockets server. <br>// <br>//  FUNCTIONS: <br>// main   - Entry point for the program. <br>// CompleteBenchmark - Work routine for communication with server. <br>// ShowUsage   - Display usage help. <br>// ParseSwitch   - Process a command line argument. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>#include "sockcli.h" <br> <br> <br>int _CRTAPI1 <br>main ( <br>        int argc, <br>        char *argv[], <br>        char *envp[] <br>) <br>{ <br> <br>   char chChar, *pchChar; <br>   INT err; <br>   WSADATA WsaData; <br> <br>   fVerbose = FALSE; <br>   dwIterations = 1000; <br>   dwTransferSize = 512; <br>   fRandom = FALSE; <br> <br>   // <br>   // Initialize Windows Sockets and request version 1.1 <br>   // <br>   err = WSAStartup (0x0101, &amp;WsaData); <br>   if (err == SOCKET_ERROR) <br>   { <br>      fprintf (stdout, "WSAStartup() failed: %ld\n", GetLastError ()); <br>      return 1; <br>   } <br> <br>   // <br>   // Default to the loopback address for the Benchmark <br>   // <br>   RemoteIpAddress.s_addr = htonl (INADDR_LOOPBACK); <br> <br>   while (--argc) <br>   { <br>      pchChar = *++argv; <br>      if (*pchChar == '/' || *pchChar == '-') <br>      { <br>         while (chChar = *++pchChar) <br>         { <br>            ParseSwitch (chChar, &amp;argc, &amp;argv); <br>         } <br>      } <br>   } <br> <br>   CompleteBenchmark (); <br> <br>   return 1; <br>} <br> <br> <br>VOID <br>WINAPI <br>CompleteBenchmark ( <br>                     VOID <br>) <br>{ <br>   SOCKET s; <br>   SOCKADDR_IN remoteAddr; <br>   INT err; <br>   INT bytesReceived; <br>   DWORD i; <br>   DWORD startTime; <br>   DWORD endTime; <br>   DWORD totalTime; <br>   DWORD thisTransferSize; <br>   DWORD bytesTransferred = 0; <br>   INT ReceiveBufferSize; <br>   INT SendBufferSize; <br> <br>   ReceiveBufferSize = CLIENT_OUTBOUND_BUFFER_MAX; <br>   SendBufferSize = sizeof (CLIENT_IO_BUFFER); <br> <br>   // <br>   // Open a socket using the Internet Address family and TCP <br>   // <br>   s = socket (AF_INET, SOCK_STREAM, 0); <br>   if (s == INVALID_SOCKET) <br>   { <br>      printf ("DoEcho: socket failed: %ld\n", GetLastError ()); <br>   } <br> <br>   // <br>   // Set the receive buffer size... <br>   // <br>   err = setsockopt (s, SOL_SOCKET, SO_RCVBUF, (char *) &amp;ReceiveBufferSize, sizeof (ReceiveBufferSize)); <br>   if (err == SOCKET_ERROR) <br>   { <br>      printf ("DoEcho: setsockopt( SO_RCVBUF ) failed: %ld\n", GetLastError ()); <br>      closesocket (s); <br>      return; <br>   } <br> <br>   // <br>   // ...and the send buffer size for our new socket <br>   // <br>   err = setsockopt (s, SOL_SOCKET, SO_SNDBUF, (char *) &amp;SendBufferSize, sizeof (SendBufferSize)); <br>   if (err == SOCKET_ERROR) <br>   { <br>      printf ("DoEcho: setsockopt( SO_SNDBUF ) failed: %ld\n", GetLastError ()); <br>      closesocket (s); <br>      return; <br>   } <br> <br> <br>   // <br>   // Connect to an agreed upon port on the host.  See the <br>   // commdef.h file for the actual port number <br>   // <br>   ZeroMemory (&amp;remoteAddr, sizeof (remoteAddr)); <br> <br>   remoteAddr.sin_family = AF_INET; <br>   remoteAddr.sin_port = htons (SERVPORT); <br>   remoteAddr.sin_addr = RemoteIpAddress; <br> <br>   err = connect (s, (PSOCKADDR) &amp; remoteAddr, sizeof (remoteAddr)); <br>   if (err == SOCKET_ERROR) <br>   { <br>      printf ("DoEcho: connect failed: %ld\n", GetLastError ()); <br>      closesocket (s); <br>      return; <br>   } <br> <br> <br>   for (i = 0; i &lt; dwIterations; i++) <br>   { <br> <br>      if (fRandom) <br>      { <br>         thisTransferSize = (rand () * dwTransferSize) / RAND_MAX; <br>      } <br>      else <br>      { <br>         thisTransferSize = dwTransferSize; <br>      } <br> <br> <br>      SendBuffer.MessageType = CLIENT_IO_MT_RETURN_DATA; <br>      SendBuffer.u.ReturnData.ByteCount = thisTransferSize; <br> <br>      // <br>      // Send "echo request" to remote host <br>      // <br>      err = send (s, (CHAR *) &amp; SendBuffer, sizeof (SendBuffer), 0); <br>      if (err != sizeof (SendBuffer)) <br>      { <br>         printf ("send didn't work, ret = %ld, error = %ld\n", err, GetLastError ()); <br>         closesocket (s); <br>         return; <br>      } <br> <br>      // <br>      // Read as much as the remote host should echo <br>      // <br>      bytesReceived = 0; <br>      do <br>      { <br>         err = recv (s, ReceiveBuffer, thisTransferSize, 0); <br>         if (i == 0) <br>         { <br>            startTime = GetTickCount (); <br>         } <br>         if (err == SOCKET_ERROR) <br>         { <br>            printf ("recv failed: %ld\n", GetLastError ()); <br>            closesocket (s); <br>            return; <br>         } <br>         else if (err == 0 &amp;&amp; thisTransferSize != 0) <br>         { <br>            printf ("socket closed prematurely by remote.\n"); <br>            return; <br>         } <br>         bytesReceived += err; <br>      } <br>      while (bytesReceived &lt; (INT) thisTransferSize); <br> <br>      bytesTransferred += thisTransferSize; <br>   } <br> <br>   endTime = GetTickCount (); <br>   totalTime = endTime - startTime; <br> <br>   // <br>   // Send final packet to remote host <br>   // <br>   SendBuffer.MessageType = CLIENT_IO_MT_I_AM_DONE; <br>   SendBuffer.u.IAmDone.TotalTicks = totalTime; <br>   SendBuffer.u.IAmDone.TotalIterations = dwIterations; <br>   SendBuffer.u.IAmDone.TotalBytesTransferred = bytesTransferred; <br> <br>   send (s, (CHAR *) &amp; SendBuffer, sizeof (SendBuffer), 0); <br> <br>   // <br>   // Display benchmark summary <br>   // <br>   printf ("\n%ld bytes transferred in %ld iterations, time = %ld ms\n", <br>           bytesTransferred, dwIterations, totalTime); <br>   printf ("Rate = %ld KB/s, %ld T/S, %ld ms/iteration\n", <br>           (bytesTransferred / totalTime) * 2, <br>           (dwIterations * 1000) / totalTime, <br>           totalTime / dwIterations); <br> <br>   // <br>   // Close connection to remote host <br>   // <br>   err = closesocket (s); <br>   if (err == SOCKET_ERROR) <br>   { <br>      printf ("closesocket failed: %ld\n", GetLastError ()); <br>      return; <br>   } <br> <br>   return; <br>} <br> <br> <br> <br>VOID <br>WINAPI <br>ShowUsage ( <br>             VOID <br>) <br>{ <br>   fputs ("usage: SOCKCLI [switches]\n" <br>  "               [-?] show this message\n" <br>  "               [-r] use random transfer sizes\n" <br>  "               [-i number-of-iterations] specify the number of iterations\n" <br>  "               [-s transfer-size] specify the fixed transfer size\n" <br>  "               [-h hostname] specify the remote server\n" <br>          ,stderr); <br> <br>   exit (1); <br>} <br> <br> <br> <br>VOID <br>WINAPI <br>ParseSwitch ( <br>               CHAR chSwitch, <br>               int *pArgc, <br>               char **pArgv[] <br>) <br>{ <br>   PHOSTENT host; <br> <br>   switch (toupper (chSwitch)) <br>   { <br> <br>   case '?': <br>      ShowUsage (); <br>      break; <br> <br>   case 'R': <br>      fRandom = TRUE; <br>      srand (22); <br>      break; <br> <br> <br>   case 'I': <br>      if (!--(*pArgc)) <br>      { <br>         ShowUsage (); <br>      } <br>      (*pArgv)++; <br>      dwIterations = strtoul (*(*pArgv), NULL, 10); <br>      break; <br> <br>   case 'S': <br>      if (!--(*pArgc)) <br>      { <br>         ShowUsage (); <br>      } <br>      (*pArgv)++; <br>      dwTransferSize = strtoul (*(*pArgv), NULL, 10); <br>      if (dwTransferSize &gt; CLIENT_OUTBOUND_BUFFER_MAX) <br>      { <br>         dwTransferSize = CLIENT_OUTBOUND_BUFFER_MAX; <br>      } <br>      fRandom = FALSE; <br>      break; <br> <br>   case 'H': <br>      if (!--(*pArgc)) <br>      { <br>         ShowUsage (); <br>      } <br>      (*pArgv)++; <br> <br>      // <br>      // Assumed host is specified by name <br>      // <br>      host = gethostbyname (*(*pArgv)); <br>      if (host == NULL) <br>      { <br>         // <br>         // See if the host is specified in "dot address" form <br>         // <br>         RemoteIpAddress.s_addr = inet_addr (*(*pArgv)); <br>         if (RemoteIpAddress.s_addr == -1) <br>         { <br>            fprintf (stdout, "Unknown remote host: %s\n", *(*pArgv)); <br>            exit (1); <br>         } <br>      } <br>      else <br>      { <br>         CopyMemory ((char *) &amp;RemoteIpAddress, host-&gt;h_addr, host-&gt;h_length); <br>      } <br>      break; <br> <br>   default: <br>      fprintf (stderr, "SOCKCLI: Invalid switch - /%c\n", chSwitch); <br>      ShowUsage (); <br>      break; <br> <br>   } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
