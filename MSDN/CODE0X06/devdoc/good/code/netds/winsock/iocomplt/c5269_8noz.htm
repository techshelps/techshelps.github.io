<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SOCKSRV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5273"></a>SOCKSRV.C</h2>
<pre><code><br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   socksrv.c <br>// <br>//  PURPOSE:  Handle and Benchmark client transactions. <br>// <br>//  FUNCTIONS: <br>//     main      - SockSrv entry point <br>//     SortTheBuffer      - Create a sorted copy of a buffer <br>//     CompleteBenchmark      - Time the client transactions <br>//     WorkerThread      - Process client requests <br>//     CreateWorkers      - Create worker threads <br>//     CreateNetConnections   - Establish client connections <br>//     ParseSwitch      - Process command line option <br>//     ShowUsage      - Display usage help <br>//     Random      - Generate a random # within a given range <br>// <br>// <br> <br>#include "socksrv.h" <br> <br>int _CRTAPI1 <br>main ( <br>        int argc, <br>        char *argv[], <br>        char *envp[] <br>) <br>{ <br> <br>   char chChar, *pchChar; <br>   DWORD lc; <br>   BOOL b; <br>   int WriteCount; <br> <br>   // <br>   // try to get timing more accurate... Avoid context <br>   // switch that could occur when threads are released <br>   // <br> <br>   SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL); <br> <br>   // <br>   // Figure out how many processors we have to size the minimum <br>   // number of worker threads and concurrency <br>   // <br> <br>   GetSystemInfo (&amp;SystemInfo); <br> <br>   fVerbose = FALSE; <br>   dwNumberOfClients = 1; <br>   dwNumberOfWorkers = 2 * SystemInfo.dwNumberOfProcessors; <br>   dwConcurrency = SystemInfo.dwNumberOfProcessors; <br>   fTcp = TRUE; <br>   dwWorkIndex = 4; <br> <br>   while (--argc) <br>   { <br>      pchChar = *++argv; <br>      if (*pchChar == '/' || *pchChar == '-') <br>      { <br>         while (chChar = *++pchChar) <br>         { <br>            ParseSwitch (chChar, &amp;argc, &amp;argv); <br>         } <br>      } <br>   } <br> <br>   // <br>   // If we are doing file I/O, then create a large file that clients <br>   // can randomly seek and read from <br>   // <br> <br>   srand (1); <br> <br>   // <br>   // Create a new file and make it the correct size <br>   // <br> <br>   DeleteFile ("socksrv.dat"); <br> <br>   hFile = CreateFile ( <br>                         "socksrv.dat", <br>                         GENERIC_READ | GENERIC_WRITE, <br>                         FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                         NULL, <br>                         OPEN_ALWAYS, <br>   FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <br>                         NULL <br>      ); <br>   if (hFile == INVALID_HANDLE_VALUE) <br>   { <br>      fprintf (stderr, "SOCKSRV: Error opening file %d\n", GetLastError ()); <br>      exit (1); <br>   } <br> <br>   // <br>   // Initialize the file with random data <br>   // <br> <br>   ClientData[0].Overlapped.Offset = 0; <br>   for (WriteCount = 0; WriteCount &lt; NUMBER_OF_WRITES; WriteCount++) <br>   { <br> <br>      for (lc = 0; lc &lt; SIXTEEN_K; lc++) <br>      { <br>         InitialBuffer[lc] = (DWORD) rand (); <br>      } <br> <br>      b = WriteFile (hFile, InitialBuffer, sizeof (InitialBuffer), &amp;lc, &amp;ClientData[0].Overlapped); <br> <br>      if (!b &amp;&amp; GetLastError () != ERROR_IO_PENDING) <br>      { <br>         fprintf (stderr, "SOCKSRV: Error in pre-write %d\n", GetLastError ()); <br>         exit (1); <br>      } <br>      b = GetOverlappedResult ( <br>                                 hFile, <br>                                 &amp;ClientData[0].Overlapped, <br>                                 &amp;lc, <br>                                 TRUE <br>         ); <br>      if (!b || lc != sizeof (InitialBuffer)) <br>      { <br>         fprintf (stderr, "SOCKSRV: Wait for pre-write failed %d\n", GetLastError ()); <br>         exit (1); <br>      } <br>      ClientData[0].Overlapped.Offset += lc; <br>   } <br> <br>   srand (1); <br>   fprintf (stdout, "SOCKSRV: %2d Clients %2d Workers Concurrency %d Using %s WorkIndex %d\n", <br>            dwNumberOfClients, <br>            dwNumberOfWorkers, <br>            dwConcurrency, <br>            fTcp ? "TCP" : "IPX", <br>            dwWorkIndex <br>      ); <br> <br>   if (!CreateNetConnections ()) <br>   { <br>      exit (1); <br>   } <br> <br>   if (!CreateWorkers ()) <br>   { <br>      exit (1); <br>   } <br> <br>   if (fVerbose) <br>   { <br>      fprintf (stdout, "Workers Created, Waiting for Clients to complete\n"); <br>   } <br> <br>   CompleteBenchmark (); <br> <br>   exit (1); <br>   return 1; <br>} <br> <br>VOID <br>WINAPI <br>CompleteBenchmark ( <br>                     VOID <br>) <br>{ <br>   DWORD LowestTicks; <br>   DWORD HighestTicks; <br>   DWORD TotalTicks; <br>   DWORD TotalIterations; <br>   DWORD TotalBytesTransferred; <br>   DWORD i; <br> <br>   StartTime = GetTickCount (); <br>   SetEvent (hBenchmarkStart); <br>   WaitForSingleObject (hBenchmarkComplete, INFINITE); <br>   EndTime = GetTickCount (); <br> <br>   LowestTicks = ClientData[0].IoBuffer.u.IAmDone.TotalTicks; <br>   HighestTicks = ClientData[0].IoBuffer.u.IAmDone.TotalTicks; <br>   TotalTicks = EndTime - StartTime; <br>   TotalIterations = 0; <br>   TotalBytesTransferred = 0; <br> <br>   for (i = 0; i &lt; dwNumberOfClients; i++) <br>   { <br>      TotalIterations += ClientData[i].IoBuffer.u.IAmDone.TotalIterations; <br>      TotalBytesTransferred += ClientData[i].IoBuffer.u.IAmDone.TotalBytesTransferred; <br> <br>      // <br>      // find fastest client <br>      // <br>      if (LowestTicks &gt; ClientData[i].IoBuffer.u.IAmDone.TotalTicks) <br>      { <br>         LowestTicks = ClientData[i].IoBuffer.u.IAmDone.TotalTicks; <br>      } <br> <br>      // <br>      // find slowest client <br>      // <br>      if (HighestTicks &lt; ClientData[i].IoBuffer.u.IAmDone.TotalTicks) <br>      { <br>         HighestTicks = ClientData[i].IoBuffer.u.IAmDone.TotalTicks; <br>      } <br>   } <br> <br>   fprintf (stdout, "\nSOCKSRV:TPS, %ld (Fastest Client %dms Slowest Client %dms)\n", <br>            (TotalIterations * 1000) / TotalTicks, <br>            LowestTicks, <br>            HighestTicks <br>      ); <br> <br>   if (fVerbose) <br>   { <br>      fprintf (stdout, "\n%ld bytes transferred in %ld iterations, time = %ld ms\n", <br>               TotalBytesTransferred, <br>               TotalIterations, <br>               TotalTicks <br>         ); <br> <br>      for (i = 0; i &lt; dwNumberOfWorkers; i++) <br>      { <br>         fprintf (stdout, "Thread[%2d] %d Transactions %d Bytes\n", <br>                  i, <br>                  ThreadData[i].TotalTransactions, <br>                  ThreadData[i].TotalBytesTransferred <br>            ); <br>      } <br>   } <br>} <br> <br>BOOL <br>WINAPI <br>CreateNetConnections ( <br>                        void <br>) <br>{ <br>   DWORD i; <br>   SOCKET listener; <br>   INT err; <br>   WSADATA WsaData; <br>   DWORD nbytes; <br>   BOOL b; <br> <br>   err = WSAStartup (0x0101, &amp;WsaData); <br>   if (err == SOCKET_ERROR) <br>   { <br>      fprintf (stdout, "WSAStartup Failed\n"); <br>      return FALSE; <br>   } <br> <br>   // <br>   // Open a socket to listen for incoming connections. <br>   // <br> <br>   if (fTcp) <br>   { <br> <br>      SOCKADDR_IN localAddr; <br> <br>      listener = socket (AF_INET, SOCK_STREAM, 0); <br>      if (listener == INVALID_SOCKET) <br>      { <br>         fprintf (stdout, "Socket Create Failed\n"); <br>         return FALSE; <br>      } <br> <br>      // <br>      // Bind our server to the agreed upon port number.  See <br>      // commdef.h for the actual port number. <br>      // <br>      ZeroMemory (&amp;localAddr, sizeof (localAddr)); <br>      localAddr.sin_port = htons (SERVPORT); <br>      localAddr.sin_family = AF_INET; <br> <br>      err = bind (listener, (PSOCKADDR) &amp; localAddr, sizeof (localAddr)); <br>      if (err == SOCKET_ERROR) <br>      { <br>         fprintf (stdout, "Socket Bind Failed\n"); <br>         if (WSAGetLastError () == WSAEADDRINUSE) <br>            fprintf (stdout, "The port number may already be in use.\n"); <br>         return FALSE; <br>      } <br> <br>   } <br>   else <br>   { <br> <br>      SOCKADDR_IPX localAddr; <br> <br>      listener = socket (AF_IPX, SOCK_STREAM, NSPROTO_SPX); <br>      if (listener == INVALID_SOCKET) <br>      { <br>         fprintf (stdout, "Socket Create Failed\n"); <br>         return FALSE; <br>      } <br> <br>      ZeroMemory (&amp;localAddr, sizeof (localAddr)); <br>      localAddr.sa_socket = htons (7); <br>      localAddr.sa_family = AF_IPX; <br> <br>      err = bind (listener, (PSOCKADDR) &amp; localAddr, sizeof (localAddr)); <br>      if (err == SOCKET_ERROR) <br>      { <br>         fprintf (stdout, "Socket Bind Failed\n"); <br>         return FALSE; <br>      } <br>   } <br> <br>   // <br>   // Prepare to accept client connections.  Allow up to 5 pending <br>   // connections. <br>   // <br>   err = listen (listener, 5); <br>   if (err == SOCKET_ERROR) <br>   { <br>      fprintf (stdout, "Socket Listen Failed\n"); <br>      return FALSE; <br>   } <br> <br> <br>   // <br>   // Only Handle a single Queue <br>   // <br> <br>   for (i = 0; i &lt; dwNumberOfClients; i++) <br>   { <br> <br>      // <br>      // Accept incoming connect requests and create wait events for each. <br>      // <br> <br>      // <br>      // If we are doing file I/O, each client will need its own event <br>      // to use for async file I/O <br>      // <br> <br>      if (hFile) <br>      { <br>         ClientData[i].hEvent = CreateEvent (NULL, TRUE, FALSE, NULL); <br>         if (!ClientData[i].hEvent) <br>         { <br>            fprintf (stdout, "Client Event Create Failed\n"); <br>            return FALSE; <br>         } <br>      } <br> <br>      ClientData[i].Socket = accept (listener, NULL, NULL); <br>      if (ClientData[i].Socket == INVALID_SOCKET) <br>      { <br>         fprintf (stdout, "Accept Failed\n"); <br>         return FALSE; <br>      } <br> <br>      if (fVerbose) <br>      { <br>         fprintf (stdout, "Client Connection Accepted\n"); <br>      } <br> <br>      // <br>      // note the 16 says how many concurrent cpu bound threads to allow thru <br>      // this should be tunable based on the requests. CPU bound requests will <br>      // really really honor this. <br>      // <br> <br>      CompletionPort = CreateIoCompletionPort ( <br>                                              (HANDLE) ClientData[i].Socket, <br>                                                 CompletionPort, <br>                                                 (DWORD) i, <br>                                                 dwConcurrency <br>         ); <br> <br>      if (!CompletionPort) <br>      { <br>         fprintf (stdout, "CompletionPort Create Failed\n"); <br>         return FALSE; <br>      } <br> <br>      ClientData[i].Flags = CLIENT_CONNECTED; <br> <br>      // <br>      // Start off an asynchronous read on the socket. <br>      // <br> <br>      ClientData[i].Overlapped.hEvent = NULL; <br> <br>      b = ReadFile ( <br>                      (HANDLE) ClientData[i].Socket, <br>                      &amp;ClientData[i].IoBuffer, <br>                      sizeof (CLIENT_IO_BUFFER), <br>                      &amp;nbytes, <br>                      &amp;ClientData[i].Overlapped <br>         ); <br> <br>      if (!b &amp;&amp; GetLastError () != ERROR_IO_PENDING) <br>      { <br>         fprintf (stdout, "ReadFile Failed\n"); <br>         return FALSE; <br>      } <br>   } <br> <br>   dwActiveClientCount = dwNumberOfClients; <br>   hBenchmarkComplete = CreateEvent (NULL, TRUE, FALSE, NULL); <br>   if (!hBenchmarkComplete) <br>   { <br>      fprintf (stdout, "Create Benchmark Complete Event Failed\n"); <br>      return FALSE; <br>   } <br>   hBenchmarkStart = CreateEvent (NULL, TRUE, FALSE, NULL); <br>   if (!hBenchmarkStart) <br>   { <br>      fprintf (stdout, "Create Benchmark Start Event Failed\n"); <br>      return FALSE; <br>   } <br> <br>   return TRUE; <br>} <br> <br>BOOL <br>WINAPI <br>CreateWorkers ( <br>                 void <br>) <br>{ <br>   DWORD ThreadId; <br>   HANDLE ThreadHandle; <br>   DWORD i; <br> <br>   for (i = 0; i &lt; dwNumberOfWorkers; i++) <br>   { <br> <br>      ThreadHandle = CreateThread ( <br>                                     NULL, <br>                                     0, <br>                                     WorkerThread, <br>                                     &amp;ThreadData[i], <br>                                     0, <br>                                     &amp;ThreadId <br>         ); <br>      if (!ThreadHandle) <br>      { <br>         fprintf (stdout, "Create Worker Thread Failed\n"); <br>         return FALSE; <br>      } <br> <br>      CloseHandle (ThreadHandle); <br>   } <br> <br>   return TRUE; <br>} <br> <br>DWORD <br>WINAPI <br>WorkerThread ( <br>                LPVOID WorkContext <br>) <br>{ <br>   PPER_THREAD_DATA Me; <br>   DWORD WorkIndex; <br>   INT err; <br>   DWORD ResponseLength; <br>   BOOL b; <br>   LPOVERLAPPED lpo; <br>   DWORD nbytes; <br>   PPER_CLIENT_DATA CurrentClient; <br>   CHAR ReadBuffer[CLIENT_OUTBOUND_BUFFER_MAX]; <br> <br>   WaitForSingleObject (hBenchmarkStart, INFINITE); <br> <br>   Me = (PPER_THREAD_DATA) WorkContext; <br> <br>   for (;;) <br>   { <br> <br>      b = GetQueuedCompletionStatus ( <br>                                       CompletionPort, <br>                                       &amp;nbytes, <br>                                       &amp;WorkIndex, <br>                                       &amp;lpo, <br>                                       INFINITE <br>         ); <br> <br>      if (b || lpo) <br>      { <br> <br> <br>         if (b) <br>         { <br> <br>            CurrentClient = &amp;ClientData[WorkIndex]; <br> <br>            switch (CurrentClient-&gt;IoBuffer.MessageType) <br>            { <br>            case CLIENT_IO_MT_RETURN_DATA: <br> <br>               // <br>               // Determine how long a response was desired by the client. <br>               // <br> <br>               ResponseLength = CurrentClient-&gt;IoBuffer.u.ReturnData.ByteCount; <br>               if (ResponseLength &gt; CLIENT_OUTBOUND_BUFFER_MAX) <br>               { <br>                  ResponseLength = CLIENT_OUTBOUND_BUFFER_MAX; <br>               } <br> <br>               // <br>               // If we are running in I/O mode, do a random read <br>               // Otherwise, use fill memory to supply the data <br>               // <br>               if (hFile) <br>               { <br> <br> <br>                  CurrentClient-&gt;Overlapped.Offset = Random (FILE_SIZE / CLIENT_OUTBOUND_BUFFER_MAX) * CLIENT_OUTBOUND_BUFFER_MAX; <br>                  CurrentClient-&gt;Overlapped.hEvent = CurrentClient-&gt;hEvent; <br>                  b = ReadFile ( <br>                                  hFile, <br>                                  ReadBuffer, <br>                                  ResponseLength, <br>                                  &amp;nbytes, <br>                                  &amp;CurrentClient-&gt;Overlapped <br>                     ); <br>                  if (!b &amp;&amp; GetLastError () != ERROR_IO_PENDING) <br>                  { <br>                     fprintf (stderr, "SOCKSRV: Error in client read %d\n", GetLastError ()); <br>                     exit (1); <br>                  } <br>                  b = GetOverlappedResult ( <br>                                             hFile, <br>                                             &amp;CurrentClient-&gt;Overlapped, <br>                                             &amp;nbytes, <br>                                             TRUE <br>                     ); <br>                  if (!b) <br>                  { <br>                     fprintf (stderr, "SOCKSRV: Wait for pre-write failed %d\n", GetLastError ()); <br>                     exit (1); <br>                  } <br>                  CurrentClient-&gt;Overlapped.hEvent = NULL; <br>               } <br>               else <br>               { <br>                  FillMemory (CurrentClient-&gt;OutboundBuffer, ResponseLength, 0xfe); <br>               } <br> <br>               // <br>               // Simulate a small compute bound workload <br>               // <br>               SortTheBuffer ((LPDWORD) CurrentClient-&gt;OutboundBuffer, (LPDWORD) ReadBuffer, nbytes &gt;&gt; 2); <br> <br>               // <br>               // Send a response and post another asynchronous read on the <br>               // socket. <br>               // <br> <br>               err = send (CurrentClient-&gt;Socket, <br>                           CurrentClient-&gt;OutboundBuffer, <br>                           ResponseLength, <br>                           0 <br>                  ); <br> <br>               if (err == SOCKET_ERROR) <br>               { <br>                  fprintf (stdout, "Send Failed\n"); <br>                  exit (1); <br>               } <br> <br>               Me-&gt;TotalTransactions++; <br>               Me-&gt;TotalBytesTransferred += ResponseLength; <br> <br>               // <br>               // reprime this client by posting another asynch read <br>               // <br> <br>               b = ReadFile ( <br>                               (HANDLE) CurrentClient-&gt;Socket, <br>                               &amp;CurrentClient-&gt;IoBuffer, <br>                               sizeof (CLIENT_IO_BUFFER), <br>                               &amp;nbytes, <br>                               &amp;CurrentClient-&gt;Overlapped <br>                  ); <br> <br>               if (!b &amp;&amp; GetLastError () != ERROR_IO_PENDING) <br>               { <br>                  fprintf (stdout, "ReadFile Failed\n"); <br>                  exit (1); <br>               } <br>               break; <br> <br>            case CLIENT_IO_MT_I_AM_DONE: <br>               CurrentClient-&gt;Flags |= CLIENT_DONE; <br>               if (fVerbose) <br>               { <br>                  fprintf (stdout, "Client Has Completed\n"); <br>               } <br>               if (!InterlockedDecrement (&amp;dwActiveClientCount)) <br>               { <br>                  SetEvent (hBenchmarkComplete); <br>               } <br>               break; <br> <br>            default: <br>               fprintf (stdout, "Invalid MessageType %x\n", CurrentClient-&gt;IoBuffer.MessageType); <br>               exit (1); <br>            } <br>         } <br>      } <br>      else <br>      { <br>         fprintf (stdout, "WorkThread Wait Failed\n"); <br>         exit (1); <br>      } <br>   } <br>   return 1; <br>} <br> <br>VOID <br>WINAPI <br>ShowUsage ( <br>             VOID <br>) <br>{ <br>   fputs ("usage: SOCKSRV [switches]\n" <br>          "               [-?] show this message\n" <br>          "               [-v] verbose output\n" <br>          "               [-t number-of-threads] specify the number of worker threads\n" <br>     "               [-c number-of-clients] specify the number of clients\n" <br>          "               [-p concurrency-value] specify the concurrency\n" <br>          "               [-i ] use IPX instead of TCP\n" <br>          "               [-w work-index] specify how much compute to do\n" <br>          ,stderr); <br> <br>   exit (1); <br>} <br> <br> <br>VOID <br>WINAPI <br>ParseSwitch ( <br>               CHAR chSwitch, <br>               int *pArgc, <br>               char **pArgv[] <br>) <br>{ <br> <br>   switch (toupper (chSwitch)) <br>   { <br> <br>   case '?': <br>      ShowUsage (); <br>      break; <br> <br>   case 'T': <br>      if (!--(*pArgc)) <br>      { <br>         ShowUsage (); <br>      } <br>      (*pArgv)++; <br>      dwNumberOfWorkers = strtoul (*(*pArgv), NULL, 10); <br>      if (dwNumberOfWorkers &gt; MAXIMUM_NUMBER_OF_WORKERS) <br>      { <br>         dwNumberOfWorkers = MAXIMUM_NUMBER_OF_WORKERS; <br>      } <br>      break; <br> <br>   case 'C': <br>      if (!--(*pArgc)) <br>      { <br>         ShowUsage (); <br>      } <br>      (*pArgv)++; <br>      dwNumberOfClients = strtoul (*(*pArgv), NULL, 10); <br>      if (dwNumberOfClients &gt; MAXIMUM_NUMBER_OF_CLIENTS) <br>      { <br>         dwNumberOfClients = MAXIMUM_NUMBER_OF_CLIENTS; <br>      } <br>      break; <br> <br>   case 'P': <br>      if (!--(*pArgc)) <br>      { <br>         ShowUsage (); <br>      } <br>      (*pArgv)++; <br>      dwConcurrency = strtoul (*(*pArgv), NULL, 10); <br>      break; <br> <br>   case 'W': <br>      if (!--(*pArgc)) <br>      { <br>         ShowUsage (); <br>      } <br>      (*pArgv)++; <br>      dwWorkIndex = strtoul (*(*pArgv), NULL, 10); <br>      break; <br> <br>   case 'V': <br>      fVerbose = TRUE; <br>      break; <br> <br>   case 'I': <br>      fTcp = FALSE; <br>      break; <br> <br>   default: <br>      fprintf (stderr, "SOCKSRV: Invalid switch - /%c\n", chSwitch); <br>      ShowUsage (); <br>      break; <br> <br>   } <br>} <br> <br>DWORD <br>WINAPI <br>Random ( <br>          DWORD nMaxValue <br>) <br>{ <br>   return (((2 * rand () * nMaxValue + RAND_MAX) / RAND_MAX - 1) / 2); <br>} <br> <br>int _CRTAPI1 <br>DwordComp (const void *e1, const void *e2) <br>{ <br>   PULONG p1; <br>   PULONG p2; <br> <br>   p1 = (PULONG) e1; <br>   p2 = (PULONG) e2; <br> <br>   return (*p1 - *p2); <br>} <br> <br>VOID <br>WINAPI <br>SortTheBuffer ( <br>                 LPDWORD Destination, <br>                 LPDWORD Source, <br>                 int DwordCount <br>) <br> <br>{ <br>   DWORD i; <br> <br>   for (i = 0; i &lt; 2 * dwWorkIndex; i++) <br>   { <br>      CopyMemory (Destination, Source, DwordCount &lt;&lt; 2); <br>      qsort ((void *) Destination, (size_t) DwordCount, (size_t) sizeof (DWORD), DwordComp); <br>   } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
