<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BCAST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5239"></a>BCAST.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br>Module Name: <br> <br>    bcast.c <br> <br>Abstract: <br> <br>    This module illustrates the Win32 Winsock and Mailslot APIs to do a generic <br>    broadcast over IPX, UDP and Mailslot protocols. <br> <br>    This example implements a client and a server. The example has a number of <br>    command line options. For example, <br> <br>    -s To run the example as a server(default role). <br> <br>-c To run the example as a client. <br>    <br>-p &lt;i or m or u&gt; To specify the protocol to be used. <br> i - IPX. <br> m - Mailslots. <br> u - UDP(default protocol). <br> <br>    -e &lt;Endpoint&gt; To specify an end point of your choice. This is a mandatory <br>parameter. Servers create this endpoint and read broadcast messages. An  <br>endpoint in case Mailslot protocol is a Mailslot name.(default is 5005).  <br> <br>    -d &lt;DomainName&gt; - To specify a domain name or a workgroup name. This is  <br>useful for Mailslot clients, only. <br> <br>To run the application as a server, the following command lines can be  <br>specified: <br>     <br>bcast -s -e 8000 -p u <br>bcast -s -e 8000 -p i <br>bcast -s -e MAILSLOT1 -p m <br> <br>To run the application as a client, the following command lines can be <br>specified: <br> <br>bcast -c -e 8000 -p u <br>bcast -c -e 8000 -p i <br>bcast -c -e MAILSLOT1 -p m -d DOMAIN1 <br>bcast -c -e MAILSLOT1 -p m -d WORKGROUP1 <br> <br>Author: <br> <br>    Rajesh Dadhia (rajeshd) 02-Mar-96 <br> <br>Revision History: <br> <br>*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;winsock.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnwlink.h&gt; <br> <br>#define MAX_MSGLEN 80 <br>#define MAX_ADDLEN 80 <br>#define MAX_MSLOTNAME 80 <br> <br>typedef enum _MODE { CLIENT=0, SERVER } MODE; <br>typedef enum _PROTOCOL { UDP=0, IPX, MAILSLOT } PROTOCOL; <br> <br>BOOL __stdcall <br>CtrlCHandler ( <br>    DWORD dwEvent <br>    ); <br> <br>void __stdcall <br>DoMailSlot ( <br>    MODE mRole, <br>    LPSTR lpsEndPoint, <br>    LPSTR lpsDomainName <br>    ); <br> <br>void __stdcall <br>DoIpx ( <br>    MODE mRole, <br>    USHORT usEndPoint <br>    ); <br> <br>void __stdcall <br>DoUdp ( <br>    MODE mRole, <br>    USHORT usEndPoint <br>    ); <br> <br>void __stdcall <br>DoMailSlotServer ( <br>    LPSTR lpsEndPoint <br>    ); <br> <br>void __stdcall <br>DoMailSlotClient ( <br>    LPSTR lpsEndPoint, <br>    LPSTR lpsDomainName <br>    ); <br> <br>void __stdcall <br>DoUdpServer ( <br>    USHORT usEndPoint <br>    ); <br> <br>void __stdcall <br>DoUdpClient ( <br>    USHORT usEndPoint <br>    ); <br> <br>void __stdcall  <br>DoIpxServer ( <br>    USHORT usEndPoint <br>    ); <br> <br>void __stdcall <br>DoIpxClient ( <br>    USHORT usEndPoint <br>    ); <br> <br>void __stdcall <br>Usage ( <br>    CHAR *pszProgramName <br>    ); <br> <br>void __stdcall <br>PrintError ( <br>    LPSTR lpszRoutine, <br>    LPSTR lpszCallName, <br>    DWORD dwError <br>    ); <br> <br>CHAR * __stdcall <br>IpxnetAddr ( <br>    CHAR *lpBuffer, <br>CHAR *lpsNetnum,  <br>CHAR *lpsNodenum  <br>); <br> <br>void __stdcall <br>DoStartup ( void ); <br> <br>void __stdcall <br>DoCleanup ( void ); <br> <br>// <br>// Global Variables <br>// <br> <br>// If Startup was successful, fStarted is used to keep track. <br>BOOL fStarted = FALSE; <br> <br>// Global socket descriptor <br>SOCKET sock = INVALID_SOCKET; <br> <br>void __cdecl <br>main ( <br>    INT argc, <br>    CHAR **argv <br>    ) <br>{ <br> <br>  // Default role of the application is SERVER, which means receiver of <br>  // the broadcast messages. <br>  MODE mRole = SERVER; <br>   <br>  // Deafult protocol used is UDP. <br>  PROTOCOL pProto = UDP; <br>   <br>  // Default Endpoint. <br>  USHORT usEndPoint = 5005; <br>   <br>  // Strings pointing to Endpoint and DomainName(necessary for Mailslots). <br>  LPSTR lpsEndPoint, lpsDomainName; <br>  INT  i; <br>  CHAR chProto; <br> <br>    // <br>    // Install the CTRL+BREAK Handler <br>    // <br>    if ( FALSE == SetConsoleCtrlHandler ( (PHANDLER_ROUTINE) CtrlCHandler, <br>  TRUE  <br>  ) )  <br>    { <br>PrintError ( "main", "SetConsoleCtrlHandler", GetLastError ( ) ); <br>    }   <br>   <br>    // <br>    // allow the user to override settings with command line switches <br>    // <br>    for ( i = 1; i &lt; argc; i++ )  <br>    { <br>if ( ( *argv[i] == '-' ) || ( *argv[i] == '/' ) )  <br>{ <br>    switch ( tolower ( *( argv[i]+1 ) ) )  <br>    { <br>// <br>// Role of the application (Client - Sender of broadcasts). <br>// <br>case 'c':   <br>    mRole = CLIENT; <br>    break; <br> <br>// <br>// Role of the application (Server - Receiver of broadcasts) <br>// <br>case 's':   <br>    mRole = SERVER; <br>    break; <br> <br>// <br>// Network protocol (Mailslots, IPX or UDP). <br>// <br>case 'p': <br>    chProto = tolower ( *argv[++i] ); <br>    if ( 'm' == chProto ) <br>    { <br>pProto = MAILSLOT; <br>    } <br>    else if ( 'i' == chProto ) <br>    { <br>pProto = IPX; <br>    } <br>    else <br>pProto = UDP; <br>    break; <br> <br>// <br>// EndPoint. <br>// <br>case 'e':  <br>    lpsEndPoint = argv[++i]; <br>    break; <br> <br>// <br>// DomainName (Important for Mailslot broadcasts, only). <br>// <br>case 'd': <br>    lpsDomainName = argv[++i]; <br>    break; <br> <br>// <br>// Help. <br>// <br>case 'h': <br>case '?': <br>default: <br>    Usage ( argv[0] ); <br>    } <br>} <br>else <br>    // <br>    // Help. <br>    // <br>    Usage ( argv[0] ); <br>    } <br> <br>     <br>    // <br>    // If the protocol specified is not MAILSLOT, convert the endpoint <br>    // information to integer format from the string format. <br>    // <br>    if ( MAILSLOT != pProto ) <br>    { <br>usEndPoint = atoi ( lpsEndPoint ); <br>    } <br> <br>    // <br>    // Print a Summary of the switches specfied  <br>    // Helpful for debugging <br>    // <br>    fprintf ( stdout, "SUMMARY:\n" ); <br>    fprintf ( stdout, "\tRole-&gt; %s\n", (CLIENT == mRole)?"Client":"Server" ); <br>    fprintf ( stdout, "\tProtocol-&gt; %s\n",  <br>      ( MAILSLOT == pProto ) ? "MAILSLOT" :  <br>      ( IPX == pProto ) ? "IPX" : "UDP" ); <br>    fprintf ( stdout, "\tEndpoint-&gt; %s\n", lpsEndPoint ); <br>     <br>    // <br>    // Check the protocol specified. <br>    // Call the appropriate handler rouine. By default the protocol <br>    // is UDP. <br>    // <br>    switch ( pProto ) <br>    { <br>case MAILSLOT : <br>    DoMailSlot ( mRole, lpsEndPoint, lpsDomainName ); <br>    break; <br> <br>case IPX: <br>    DoStartup ( ); <br>    DoIpx ( mRole, usEndPoint ); <br>    break; <br> <br>default: <br>    DoStartup ( ); <br>    DoUdp ( mRole, usEndPoint ); <br>    break; <br>    } <br> <br>    return; <br>} <br> <br>// <br>// CtrlCHandler () intercepts the CTRL+BREAK or CTRL+C events and calls the <br>// cleanup routines. <br>// <br>BOOL __stdcall <br>CtrlCHandler ( <br>    DWORD dwEvent <br>) <br>{ <br>    if ( ( CTRL_C_EVENT == dwEvent ) || ( CTRL_BREAK_EVENT == dwEvent ) ) <br>    { <br>DoCleanup ( );     <br>    } <br> <br>    return FALSE; <br>} <br> <br>// <br>// DoMailSlot () function calls appropriate handler function (client/server), <br>// if protocol=MAILSLOT is specified. By default, the role of the application <br>// is - SERVER. <br>// <br>void __stdcall <br>DoMailSlot ( <br>    MODE mRole, <br>    LPSTR lpsEndPoint, <br>    LPSTR lpsDomainName <br>    ) <br>{ <br>    switch ( mRole ) <br>    { <br>case CLIENT: <br>    DoMailSlotClient ( lpsEndPoint, lpsDomainName ); <br>    break; <br> <br>default: <br>    DoMailSlotServer ( lpsEndPoint ); <br>    } <br>return; <br>} <br> <br>// <br>// DoIpx () function calls appropriate handler function (client/server), <br>// if protocol=IPX  is specified. By default, the role of the application <br>// is - SERVER. <br>// <br>void __stdcall <br>DoIpx ( <br>    MODE mRole, <br>    USHORT usEndPoint <br>    ) <br>{ <br>    // <br>    // Initialize the global socket descriptor. <br>    // <br>    sock = socket ( AF_IPX, SOCK_DGRAM, NSPROTO_IPX ); <br> <br>    if ( INVALID_SOCKET ==  sock ) <br>    { <br>PrintError( "DoIpx", "socket", WSAGetLastError ( ) ); <br>    } <br> <br>    switch ( mRole ) <br>    { <br>case CLIENT: <br>    DoIpxClient ( usEndPoint ); <br>    break; <br> <br>default: <br>    DoIpxServer ( usEndPoint ); <br>    } <br>return; <br>} <br> <br> <br>// <br>// DoUdp () function calls appropriate handler function (client/server), <br>// if protocol=UDP  is specified. By default, the role of the application <br>// is - SERVER. <br>// <br>void __stdcall <br>DoUdp ( <br>    MODE mRole, <br>    USHORT usEndPoint <br>    ) <br>{ <br>    // <br>    // Initialize the global socket descriptor. <br>    // <br>    sock = socket ( AF_INET, SOCK_DGRAM, 0 ); <br> <br>    if ( INVALID_SOCKET ==  sock) <br>    { <br>PrintError ( "DoUdp", "socket", WSAGetLastError() ); <br>    } <br>     <br>    switch ( mRole ) <br>    { <br>case CLIENT: <br>    DoUdpClient ( usEndPoint ); <br>    break; <br> <br>default: <br>    DoUdpServer ( usEndPoint ); <br>    } <br>    return; <br>} <br> <br>// <br>// DoMailSlotServer () function receives a mailslot message on a particular <br>// mailslot. The function creates a mailslot, posts a ReadFile () to receive <br>// the message. The function then checks the first four bytes of the message <br>// for the message ID, and discards all the messages with same ID, in future. <br>// <br>void __stdcall <br>DoMailSlotServer ( <br>    LPSTR lpsEndPoint <br>    ) <br>{ <br>  HANDLE hSlot; <br>    <br>  // Variables that store MessageID, previous messageID, number of bytes to  <br>  // read/read, size of next available message and the number of messages. <br>  DWORD dwMessageID, <br>dwPrevID, <br>cbMessage, <br>cbRead,  <br>cbToRead,  <br>nMessages; <br>   <br>  BOOL fResult; <br>   <br>  CHAR achMailSlotName[MAX_MSLOTNAME],  <br>       achBuffer[MAX_MSGLEN + sizeof ( DWORD )]; <br>   <br>  // Variable that points past the message ID part in the message. <br>  LPSTR lpsMessage; <br> <br>    // <br>    // Create a string for the mailslot name. <br>    // <br>    wsprintf ( achMailSlotName, "\\\\.\\mailslot\\%s", lpsEndPoint ); <br> <br>    // <br>    // Create the mailslot. <br>    // <br>    hSlot = CreateMailslot ( achMailSlotName, <br>     0, <br>     MAILSLOT_WAIT_FOREVER, <br>     (LPSECURITY_ATTRIBUTES) NULL <br>     ); <br> <br>    if ( INVALID_HANDLE_VALUE == hSlot ) <br>    { <br>PrintError ( "DoMailSlotServer",  "CreateMailSlot", GetLastError() ); <br>    } <br> <br>    // <br>    // Post ReadFile() and read a message. <br>    // <br>    cbToRead = MAX_MSGLEN + sizeof (DWORD); <br> <br>    fResult = ReadFile ( hSlot, <br> achBuffer, <br> cbToRead, <br> &amp;cbRead, <br> (LPOVERLAPPED) NULL <br> ); <br>     <br>    if ( TRUE != fResult ) <br>    { <br>PrintError ( "DoMailSlotServer", "ReadFile", GetLastError() ); <br>    } <br> <br>    achBuffer[cbRead] = '\0'; <br> <br>    // <br>    // Get the message ID part from the message. <br>    // <br>    memcpy ( &amp;dwMessageID, achBuffer, sizeof ( DWORD ) ); <br> <br>    // <br>    // Adjust the actual message pointer. <br>    // <br>    lpsMessage = achBuffer + sizeof ( DWORD ); <br>     <br>    // <br>    // Print the message <br>    // <br>    fprintf ( stdout,  <br>      "A MailSlot Message of %d bytes received with ID %d\n",  <br>              strlen (lpsMessage ),  <br>              dwMessageID  <br>              ); <br> <br>    fprintf ( stdout, "MessageText-&gt;%s\n", lpsMessage ); <br> <br>    // <br>    // Check for duplicate messages. <br>    // <br>    dwPrevID = dwMessageID; <br>     <br>    while ( 1 ) <br>    { <br>// <br>// get information on pending messages. <br>// <br>fResult = GetMailslotInfo ( hSlot, <br>    (LPDWORD) NULL, <br>    &amp;cbMessage,  <br>    &amp;nMessages, <br>    (LPDWORD) NULL <br>    ); <br>if ( TRUE != fResult ) <br>{  <br>    PrintError ( "DoMailSlotServer",  <br> "GetMailSlotInfo",  <br> GetLastError ( )  <br> ); <br>} <br> <br>// <br>// Break if no more messages. <br>// <br>if ( MAILSLOT_NO_MESSAGE == cbMessage ) <br>break; <br> <br>// <br>// We now know how much to read. <br>// <br>cbToRead = cbMessage; <br>fResult = ReadFile ( hSlot, <br>     achBuffer, <br>     cbToRead, <br>     &amp;cbRead, <br>     (LPOVERLAPPED) NULL <br>     ); <br> <br>if ( TRUE != fResult ) <br>{ <br>    PrintError ( "DoMailSlotServer", <br> "ReadFile",  <br> GetLastError ( )  <br> ); <br>} <br>     <br>achBuffer[cbRead] = '\0'; <br>memcpy ( &amp;dwMessageID, achBuffer, sizeof (DWORD) ); <br> <br>// <br>// print the message only if it is not a duplicate. <br>// <br>lpsMessage = achBuffer + sizeof (DWORD); <br>if ( dwMessageID != dwPrevID )     <br>{ <br>    fprintf ( stdout,  <br>      "A MailSlot Message of %d bytes received with ID %d\n",  <br>      strlen (lpsMessage ),  <br>      dwMessageID  <br>      ); <br> <br>    fprintf ( stdout, "MessageText-&gt;%s\n", achBuffer ); <br>} <br> <br>dwPrevID = dwMessageID; <br>    } <br>     <br>    // <br>    // Close the handle to our mailslot. <br>    // <br>    fResult = CloseHandle ( hSlot ); <br> <br>    if ( TRUE != fResult ) <br>    { <br>PrintError ( "DoMailSlotServer", "CloseHandle", GetLastError() ); <br>    } <br>    return; <br>} <br> <br>// <br>// DoMailSlotClient () function implements the broadcast routine for a <br>// Mailslot client. The function opens handle to the mailslot using  <br>// CreateFile (). CreateFile will fail on Windows NT for local mailslots, <br>// if the mailslot is not already created using CreateMailSlot () API.  <br>//   <br>// The function appends a message number to the message which the server uses <br>// to discard duplicate messages. In the event of a client runnig on a system <br>// with multiple transport protocols loaded, a mailsot message is sent over <br>// each protocol. <br>// <br>// This routine broadcasts a mailslot message to everyone on a Windows NT <br>// domain, it can also be used to send a mailslot message to a particular <br>// host or a workgroup. <br>// <br>void __stdcall <br>DoMailSlotClient ( <br>    LPSTR lpsEndPoint, <br>    LPSTR lpsDomainName <br>    ) <br>{ <br>  HANDLE hFile; <br>   <br>  // Variables that store MessageID, number of bytes to write/written. <br>  DWORD dwMessageID,  <br>cbWritten, <br>cbToWrite; <br>   <br>  BOOL fResult; <br>   <br>  CHAR achMailSlotName[MAX_MSLOTNAME], <br>       achBuffer[MAX_MSGLEN + sizeof ( DWORD ) ]; <br>  <br>    if ( NULL == lpsDomainName ) <br>    { <br>fprintf ( stdout,  <br>  "Domain/Workgroup name must be specified....Exiting\n" <br>  ); <br>exit ( 1 ); <br>    } <br>   <br>    // <br>    // Create a string for the mailslot name. <br>    // <br>    wsprintf ( achMailSlotName, <br>       "\\\\%s\\mailslot\\%s", <br>       lpsDomainName, <br>       lpsEndPoint  <br>       ); <br> <br>    // <br>    // Open a handle to the mailslot. <br>    // <br>    hFile = CreateFile ( achMailSlotName, <br> GENERIC_WRITE, <br> FILE_SHARE_READ, <br> (LPSECURITY_ATTRIBUTES) NULL, <br> OPEN_EXISTING, <br> FILE_ATTRIBUTE_NORMAL, <br> (HANDLE) NULL  <br> ); <br>     <br>    if ( INVALID_HANDLE_VALUE == hFile) <br>    { <br>PrintError ( "DoMailSlotClient", "CreateFile", GetLastError ( ) ); <br>    } <br>     <br>    // <br>    // Generate a Message ID. <br>    // <br>    srand ( (UINT) time ( NULL) ); <br>    dwMessageID = rand ( ); <br> <br>    memcpy ( achBuffer, &amp;dwMessageID, sizeof ( DWORD ) ); <br>    lstrcpy ( achBuffer + sizeof (DWORD), "A MailSlot Broadcast Message" ); <br> <br>    // <br>    // Total number of bytes to write. <br>    // <br>    cbToWrite = sizeof ( DWORD ) + strlen ( achBuffer + sizeof ( DWORD ) ); <br> <br>    // <br>    // Send a mailslot message. <br>    // <br>    fResult = WriteFile ( hFile, <br>  achBuffer, <br>  cbToWrite, <br>  &amp;cbWritten, <br>  (LPOVERLAPPED) NULL <br>  ); <br> <br>    if ( TRUE != fResult ) <br>    { <br>PrintError ( "DoMailSlotClient", "WriteFile", GetLastError ( ) ); <br>    } <br> <br>    fprintf ( stdout,  <br>      "%d bytes of MailSlot data broadcasted with ID %d\n",  <br>      cbWritten,  <br>      dwMessageID <br>      ); <br>     <br>    // <br>    // Close the mailslot handle. <br>    // <br>    fResult = CloseHandle ( hFile ); <br> <br>    if ( TRUE != fResult ) <br>    { <br>PrintError ( "DoMailSlotClient", "CloseHandle", GetLastError() ); <br>    } <br>    return; <br>} <br> <br>// <br>// DoUdpServer () function receives the broadcast on a specified port. The <br>// server will have to post a recv (), before the client sends the broadcast. <br>//  <br>void __stdcall <br>DoUdpServer ( <br>    USHORT usEndPoint <br>    ) <br>{ <br>   <br>  // IP address structures needed to bind to a local port and get the sender's <br>  // information. <br>  SOCKADDR_IN saUdpServ, saUdpCli; <br>   <br>  INT err, nSize; <br>   <br>  CHAR achBuffer[MAX_MSGLEN]; <br> <br>    // <br>    // bind to the specified port. <br>    // <br>    saUdpServ.sin_family = AF_INET; <br>    saUdpServ.sin_addr.s_addr = htonl ( INADDR_ANY ); <br>    saUdpServ.sin_port = htons ( usEndPoint ); <br> <br>    err = bind ( sock, (SOCKADDR FAR *)&amp;saUdpServ, sizeof ( SOCKADDR_IN ) ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoUdpServer", "bind", WSAGetLastError ( ) ); <br>    } <br> <br>    // <br>    // receive a datagram on the bound port number. <br>    // <br>    nSize = sizeof ( SOCKADDR_IN ); <br>    err = recvfrom ( sock, <br>     achBuffer, <br>     MAX_MSGLEN, <br>     0, <br>     (SOCKADDR FAR *) &amp;saUdpCli, <br>     &amp;nSize <br>     ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoUdpServer", "recvfrom", WSAGetLastError ( ) ); <br>    } <br>      <br>    // <br>    // print the sender's information. <br>    // <br>    achBuffer[err] = '\0'; <br>    fprintf ( stdout, "A Udp Datagram of length %d bytes received from ", err ); <br>    fprintf ( stdout, "\n\tIP Adress-&gt;%s ", inet_ntoa ( saUdpCli.sin_addr ) ); <br>    fprintf ( stdout, "\n\tPort Number-&gt;%d\n", ntohs ( saUdpCli.sin_port ) ); <br>    fprintf ( stdout, "MessageText-&gt;%s\n", achBuffer ); <br> <br>    // <br>    // Call the cleanup routine <br>    // <br>    DoCleanup ( ); <br>       <br>    return; <br>} <br> <br>// <br>// DoUdpClient () function implements the broadcast routine for an UDP <br>// client. The function sets the SO_BROADCAST option with the global socket. <br>// Calling this API is important. After binding to a local port, it sends an  <br>// UDP boradcasts to the IP address INADDR_BROADCAST, with a particular <br>// port number. <br>// <br>void __stdcall <br>DoUdpClient ( <br>    USHORT usEndPoint <br>    ) <br>{ <br>   <br>  // IP address structures needed to fill the source and destination  <br>  // addresses. <br>  SOCKADDR_IN saUdpServ, saUdpCli; <br>   <br>  INT err; <br>   <br>  CHAR achMessage[MAX_MSGLEN]; <br>   <br>  // Variable to set the broadcast option with setsockopt (). <br>  BOOL fBroadcast = TRUE; <br> <br>     <br>    err = setsockopt ( sock,  <br>       SOL_SOCKET, <br>       SO_BROADCAST, <br>       (CHAR *) &amp;fBroadcast, <br>       sizeof ( BOOL ) <br>       ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoUdpClient", "setsockopt", WSAGetLastError ( )  ); <br>    } <br> <br>    // <br>    // bind to a local socket and an interface. <br>    // <br>    saUdpCli.sin_family = AF_INET; <br>    saUdpCli.sin_addr.s_addr = htonl ( INADDR_ANY ); <br>    saUdpCli.sin_port = htons ( 0 ); <br> <br>    err = bind ( sock, (SOCKADDR *) &amp;saUdpCli, sizeof (SOCKADDR_IN) ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoUdpClient", "bind", WSAGetLastError ( ) ); <br>    } <br> <br>    // <br>    // Fill an IP address structure, to send an IP broadcast. The  <br>    // packet will be broadcasted to the specified port. <br>    // <br>    saUdpServ.sin_family = AF_INET; <br>    saUdpServ.sin_addr.s_addr = htonl ( INADDR_BROADCAST ); <br>    saUdpServ.sin_port = htons ( usEndPoint ); <br> <br>    lstrcpy ( achMessage, "A Broadcast Datagram" ); <br>   <br>    err = sendto ( sock, <br>   achMessage, <br>   lstrlen ( achMessage ), <br>   0, <br>   (SOCKADDR *) &amp;saUdpServ, <br>   sizeof ( SOCKADDR_IN ) <br>   ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoUdpClient", "sendto", WSAGetLastError ( ) ); <br>    } <br> <br>    fprintf ( stdout, "%d bytes of data broadcasted\n", err ); <br> <br>    // <br>    // Call the cleanup routine. <br>    // <br>    DoCleanup ( ); <br> <br>    return; <br>} <br> <br> <br>// <br>// DoIpxServer () function receives the broadcast on a specified socket. The <br>// server will have to post a recv (), before the client sends the broadcast.  <br>// It is necessary call setsockopt () with SO_BROADCAST flag set, in order to <br>// receive IPX broadcasts on Windows 95. <br>// <br>void __stdcall  <br>DoIpxServer ( <br>    USHORT usEndPoint <br>    ) <br>{ <br>    <br>  // IPX address structures needed to bind to a local socket and get the <br>  // sender's information. <br>  SOCKADDR_IPX saIpxServ, saIpxCli; <br>   <br>  INT err, nSize; <br>   <br>  CHAR achBuffer[MAX_MSGLEN],  <br>   achAddress[MAX_ADDLEN]; <br>   <br>  OSVERSIONINFO osVer; <br>   <br>  // Variable to set the broadcast option with setsockopt (). <br>  BOOL fResult, fBroadcast = TRUE; <br> <br>    // <br>    // Check the platform. <br>    // <br>    osVer.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO ); <br>    fResult  = GetVersionEx ( &amp;osVer); <br> <br>    if ( FALSE == fResult) <br>    { <br>        PrintError ( "DoIpxServer", "GetVersionEx", GetLastError ( ) ); <br>    } <br> <br>    // <br>    // If the platform is Windows 95, call setsockopt (). <br>    // <br>    if ( VER_PLATFORM_WIN32_WINDOWS == osVer.dwPlatformId ) <br>    {    <br>err = setsockopt ( sock,  <br>   SOL_SOCKET,  <br>   SO_BROADCAST,  <br>   (CHAR *) &amp;fBroadcast,  <br>   sizeof ( BOOL )  <br>   ); <br> <br>if ( SOCKET_ERROR == err ) <br>{ <br>    PrintError ( "DoIpxServer", "setsockopt", WSAGetLastError() ); <br>} <br>    } <br> <br>    // <br>    // bind to the specified socket. <br>    // <br>    saIpxServ.sa_family = AF_IPX; <br>    saIpxServ.sa_socket = usEndPoint; <br>    memset ( saIpxServ.sa_netnum, 0, sizeof (saIpxServ.sa_netnum ) ); <br>    memset ( saIpxServ.sa_nodenum, 0, sizeof (saIpxServ.sa_nodenum ) ); <br> <br>    err = bind ( sock, (SOCKADDR *) &amp;saIpxServ, sizeof (SOCKADDR_IPX) ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoIpxServer", "bind", WSAGetLastError ( ) ); <br>    } <br> <br>    // <br>    // receive a datagram on the bound socket number. <br>    // <br>    nSize = sizeof ( SOCKADDR_IPX ); <br>    err = recvfrom ( sock, <br>     achBuffer, <br>     MAX_MSGLEN, <br>     0, <br>     (SOCKADDR *) &amp;saIpxCli, <br>     &amp;nSize  <br>     ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoIpxServer", "recvfrom", WSAGetLastError ( ) ); <br>    } <br>     <br>    // <br>    // print the sender's information. <br>    // <br>    achBuffer[err] = '\0'; <br>    fprintf ( stdout,  <br>      "An Ipx Datagram of length %d bytes received from ",  <br>      err ); <br>    fprintf ( stdout,  <br>      "\n\tIPX Adress-&gt;%s ",  <br>      IpxnetAddr ( achAddress,  <br>   saIpxCli.sa_netnum,  <br>   saIpxCli.sa_nodenum  <br>   )  <br>      ); <br>    fprintf ( stdout, "\n\tSocket Number-&gt;%d\n", saIpxCli.sa_socket ); <br>    fprintf ( stdout, "MessageText-&gt;%s\n", achBuffer ); <br>     <br>    // <br>    // Call the cleanup routine. <br>    // <br>    DoCleanup ( ); <br>    return;               <br> <br>} <br> <br>// <br>// DoIpxClient () function implements the broadcast routine for a an IPX <br>// client. The fucntion sets the SO_BROADCAST option with the gloabal socket. <br>// Calling this API is important. After binding to a local port, it sends an IPX <br>// packet to the address with node number as all 1's and net number as all 0's, <br>// with a particuler socket number. <br>// <br>void __stdcall <br>DoIpxClient ( <br>    USHORT usEndPoint <br>) <br>{ <br>    <br>  // IPX address structures needed to fill the source and destination  <br>  // addresses. <br>  SOCKADDR_IPX saIpxServ, saIpxCli; <br>   <br>  INT err; <br>   <br>  CHAR achMessage[MAX_MSGLEN]; <br>   <br>  // Variable to set the broadcast option with setsockopt (). <br>  BOOL fBroadcast = TRUE; <br>     <br>  err = setsockopt ( sock,  <br>     SOL_SOCKET,  <br>     SO_BROADCAST, <br>     (CHAR *) &amp;fBroadcast,  <br>     sizeof ( BOOL )  <br>     ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoIpxClient", "setsockopt", WSAGetLastError ( ) ); <br>    } <br> <br>    // <br>    // bind to a local socket and an interface. <br>    // <br>    saIpxCli.sa_family = AF_IPX; <br>    saIpxCli.sa_socket = (USHORT) 0; <br>    memset ( saIpxCli.sa_netnum, 0, sizeof ( saIpxCli.sa_netnum ) ); <br>    memset ( saIpxCli.sa_nodenum, 0, sizeof ( saIpxCli.sa_nodenum ) ); <br> <br>    err = bind ( sock, (SOCKADDR  *) &amp;saIpxCli, sizeof ( SOCKADDR_IPX ) ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoIpxClient", "bind", WSAGetLastError() ); <br>    } <br> <br>    // <br>    // Fill an IPX address structure, to send an IPX broadcast. The  <br>    // packet will be broadcasted to the specified socket. <br>    //  <br>    saIpxServ.sa_family = AF_IPX; <br>    saIpxServ.sa_socket = usEndPoint; <br>    memset ( saIpxServ.sa_netnum, 0, sizeof ( saIpxServ.sa_netnum ) ); <br>    memset ( saIpxServ.sa_nodenum, 0xFF, sizeof ( saIpxServ.sa_nodenum ) ); <br> <br>    lstrcpy ( achMessage, "A Broadcast Datagram" ); <br>   <br>    err = sendto ( sock, <br>   achMessage, <br>   lstrlen ( achMessage ), <br>   0, <br>   (SOCKADDR *) &amp;saIpxServ, <br>   sizeof ( SOCKADDR_IPX ) <br>   ); <br> <br>    if ( SOCKET_ERROR == err ) <br>    { <br>PrintError ( "DoIpxClient", "sendto", WSAGetLastError ( ) ); <br>    } <br> <br>    fprintf ( stdout, "%d bytes of data broadcasted\n", err); <br> <br>    // <br>    // Call the cleanup routine. <br>    // <br>    DoCleanup ( ); <br> <br>    return; <br>} <br> <br>// <br>// Usage () lists the available command line options. <br>// <br>void __stdcall <br>Usage ( <br>    CHAR *pszProgramName <br>) <br>{ <br>    fprintf ( stderr, "Usage:  %s\n", pszProgramName ); <br>    fprintf ( stderr,  <br>"\t-s or -c (s - server, c - client, default - server)\n" ); <br>    fprintf ( stderr,  <br>"\t-p &lt;i or m or u&gt; (i - IPX, m - Mailslots, u - UDP)\n" ); <br>    fprintf ( stderr, "\t-e &lt;Endpoint&gt;\n" ); <br>    fprintf ( stderr,  <br>"\t-d &lt;DomainName&gt; - needed only for a Mailslot client\n" ); <br>    fprintf ( stderr,  <br>"\n\tDefault Values-&gt; Role:Server, Protocol:UDP, EndPoint:5005\n" ); <br>     <br>exit ( 1 ); <br>} <br> <br> <br>// <br>// PrintError () is a function available globally for printing the error and  <br>// doing the cleanup. <br>// <br>void __stdcall <br>PrintError ( <br>    LPSTR lpszRoutine, <br>LPSTR lpszCallName, <br>DWORD dwError <br>) <br>{ <br> <br>    fprintf ( stderr,  <br>      "The Call to %s() in routine() %s failed with error %d\n",  <br>      lpszCallName,  <br>      lpszRoutine, <br>      dwError  <br>      ); <br> <br>    DoCleanup ( ); <br> <br>    exit ( 1 ); <br>} <br> <br>// <br>// IpxnetAddr () function converts an IPX address address in the binary form <br>// to ascii format, it fills the input buffer with the address and returns a <br>// pointer to it. <br>// <br>CHAR * __stdcall <br>IpxnetAddr ( <br>    CHAR *lpBuffer, <br>    CHAR *lpsNetnum,  <br>    CHAR *lpsNodenum  <br>    ) <br>{ <br>    wsprintf ( lpBuffer,  <br>       "%02X%02X%02X%02X.%02X%02X%02X%02X%02X%02X", <br>       (UCHAR) lpsNetnum[0], (UCHAR) lpsNetnum[1],  <br>       (UCHAR) lpsNetnum[2], (UCHAR) lpsNetnum[3], <br>       (UCHAR) lpsNodenum[0], (UCHAR) lpsNodenum[1], <br>       (UCHAR) lpsNodenum[2], (UCHAR) lpsNodenum[3], <br>       (UCHAR) lpsNodenum[4], (USHORT) lpsNodenum[5] <br>       ); <br> <br>    return ( lpBuffer); <br>} <br> <br>// <br>// DoStartup () initializes the Winsock DLL with Winsock version 1.1 <br>// <br>void __stdcall <br>DoStartup ( void ) <br>{ <br>  WSADATA wsaData; <br>   <br>  INT iRetVal; <br> <br>    iRetVal = WSAStartup ( MAKEWORD ( 1,1 ), &amp;wsaData ); <br> <br>    if ( 0 != iRetVal) <br>    { <br>PrintError ( "DoStartup", "WSAStartup", iRetVal ); <br>    } <br>     <br>    // <br>    // Set the global flag. <br>    // <br>    fStarted = TRUE; <br>  <br>    return; <br>} <br> <br>// <br>// DoCleanup () will close the global socket which was opened successfully by <br>// a call to socket (). Additionally, it will call WSACleanup (), if a call <br>// to WSAStartup () was made successfully. <br>// <br>void __stdcall <br>DoCleanup ( void ) <br>{ <br>    if ( INVALID_SOCKET != sock ) <br>    { <br>closesocket ( sock ); <br>    } <br> <br>    if ( TRUE == fStarted ) <br>    { <br>WSACleanup ( ); <br>    } <br> <br>    fprintf ( stdout, "DONE\n" ); <br> <br>    return; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
