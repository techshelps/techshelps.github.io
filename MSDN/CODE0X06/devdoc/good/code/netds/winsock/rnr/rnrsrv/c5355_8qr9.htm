<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RNRSRV.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5355"></a>RNRSRV.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1994 Microsoft Corporation <br> <br>Module Name: <br> <br>    RnrSrv.c <br> <br>Abstract: <br> <br>    Test and demonstration service for the RNR (service Registration and <br>    Name Resolution) APIs.  This is a simple service designed to show <br>    the basic principles involved in using the RNR APIs to _write a <br>    protocol-independent Windows Sockets service. <br> <br>    This service opens a number of listening sockets, waits for an <br>    incoming connection from a client, accepts the connection, then <br>    echos data back to the client until the client terminates the <br>    virtual circuit.  This service is single-threaded and can handle <br>    only a single client at a time. <br> <br>    The OpenListeners() routine implemented herein is intended to be a <br>    demonstration of RNR functionality commonly used in <br>    protocol-independent services.  Service writers are encouraged to <br>    leverage this code to assist them in writing protocol-independent <br>    services on top of the Windows Sockets API. <br> <br>--*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;winsock2.h&gt; <br>#include &lt;nspapi.h&gt; <br> <br>WSADATA WsaData; <br> <br>PSTR ServiceTypeName = "EchoExample"; <br>PSTR ServiceName = "EchoServer"; <br> <br>#define MAX_SOCKETS    20 <br> <br>INT <br>OpenListeners ( <br>    IN PTSTR ServiceName, <br>    IN LPGUID ServiceType, <br>    IN BOOL Reliable, <br>    IN BOOL MessageOriented, <br>    IN BOOL StreamOriented, <br>    IN BOOL Connectionless, <br>    OUT SOCKET SocketHandles[], <br>    OUT INT ProtocolsUsed[] <br>    ); <br> <br>INT <br>AdvertiseService( <br>    IN PTSTR ServiceName, <br>    IN LPGUID ServiceType, <br>    IN SOCKET SocketHandles[], <br>    IN INT SocketCount <br>    ); <br> <br> <br>void _CRTAPI1 <br>main ( <br>    int argc, <br>    char *argv[] <br>    ) <br>{ <br>    INT count, err, i ; <br>    DWORD tmpProtocol[2]; <br>    BYTE buffer[1024]; <br>    DWORD bytesRequired; <br>    PPROTOCOL_INFO protocolInfo; <br>    GUID serviceType; <br>    FD_SET readfds; <br>    SOCKET listenSockets[MAX_SOCKETS+1]; <br>    INT protocols[MAX_SOCKETS+1]; <br>    SOCKET s; <br> <br>    // <br>    // Initialize the Windows Sockets DLL. <br>    // <br> <br>    err = WSAStartup( 0x0202, &amp;WsaData ); <br> <br>    if ( err == SOCKET_ERROR ) <br>    { <br>        printf( "WSAStartup() failed: %ld\n", GetLastError( ) ); <br>        return; <br>    } <br> <br>    // <br>    // Determine the value of our GUID.  The GUID uniquely identifies <br>    // the type of service we provide. <br>    // <br> <br>    err = GetTypeByName( ServiceTypeName, &amp;serviceType ); <br> <br>    if ( err == SOCKET_ERROR ) <br>    { <br>        printf( "GetTypeByName for \"%s\" failed: %ld\n", <br>                    ServiceTypeName, GetLastError( ) ); <br>        exit( 1 ); <br>    } <br> <br>    // <br>    // Open listening sockets for this service. <br>    // <br> <br>    count = OpenListeners( <br>                ServiceName, <br>                &amp;serviceType, <br>                TRUE, <br>                FALSE, <br>                FALSE, <br>                FALSE, <br>                listenSockets, <br>                protocols <br>                ); <br> <br>    if ( count &lt;= 0 ) <br>    { <br>        printf( "failed to open listenSockets for name \"%s\" type \"%s\"\n", <br>                    ServiceName, ServiceTypeName ); <br>        exit( 1 ); <br>    } <br> <br>    // <br>    // We successfully opened some listening sockets.  Display some <br>    // information on each protocol in use. <br>    // <br> <br>    tmpProtocol[1] = 0; <br> <br>    for ( i = 0; i &lt; count; i++ ) <br>    { <br>        tmpProtocol[0] = protocols[i]; <br> <br>        bytesRequired = sizeof(buffer); <br>        err = EnumProtocols( tmpProtocol, buffer, &amp;bytesRequired ); <br> <br>        if ( err &lt; 1 ) <br>        { <br>            printf( "EnumProtocols failed for protocol %ld: %ld\n", <br>                        tmpProtocol[0], GetLastError( ) ); <br>            exit( 1 ); <br>        } <br> <br>        protocolInfo = (PPROTOCOL_INFO)buffer; <br>        printf( "Socket %lx listening on protocol \"%s\" (%ld)\n", <br>                    listenSockets[i], <br>                    protocolInfo-&gt;lpProtocol, <br>                    protocolInfo-&gt;iProtocol ); <br> <br>    } <br> <br>    // <br>    // Advertise the service so thet it can be found. <br>    // <br>    printf( "Going to advertise the service.\n" ) ; <br> <br>    err = AdvertiseService( <br>                ServiceName, <br>                &amp;serviceType, <br>                listenSockets, <br>                count) ; <br> <br>    if (err == SOCKET_ERROR) <br>    { <br>        printf( "Failed to advertise the service. Error %d\n", GetLastError()) ; <br>        exit( 1 ) ; <br>    } <br> <br>    printf( "Successfully advertised the service.\n" ) ; <br> <br>    // <br>    // Loop accepting connections and servicing them. <br>    // <br> <br>    FD_ZERO( &amp;readfds ); <br> <br>    while ( TRUE ) <br>    { <br>        // <br>        // Add the listening sockets to the FD_SET we'll pass to select. <br>        // <br> <br>        for ( i = 0; i &lt; count; i++ ) <br>        { <br>            FD_SET( listenSockets[i], &amp;readfds ); <br>        } <br> <br>        // <br>        // Wait for one of the listenSockets to receive an incoming connection. <br>        // <br> <br>        err = select( count, &amp;readfds, NULL, NULL, NULL ); <br> <br>        if ( err &lt; 1 ) <br>        { <br>            printf( "select() returned %ld, error %ld\n", err, GetLastError( ) ); <br>            exit( 1 ); <br>        } <br> <br>        // <br>        // Find the socket that received an incoming connection and accept <br>        // the connection. <br>        // <br> <br>        for ( i = 0; i &lt; count; i++ ) <br>        { <br>            if ( FD_ISSET( listenSockets[i], &amp;readfds ) ) <br>                break; <br>        } <br> <br>        // <br>        // Accept the connection from the client.  We ignore the client's <br>        // address here. <br>        // <br> <br>        s = accept( listenSockets[i], NULL, NULL ); <br> <br>        if ( s == INVALID_SOCKET ) <br>        { <br>            printf( "accept() failed, error %ld\n", GetLastError( ) ); <br>            exit( 1 ); <br>        } <br> <br>        printf( "Accepted incoming connection on socket %lx\n", <br>                listenSockets[i] ); <br> <br>        // <br>        // Loop echoing data back to the client.  Note that this <br>        // single-threaded service can handle only a single client at a <br>        // time.  A more sophisticated service would service multiple <br>        // clients simultaneously by using multiple threads or <br>        // asynchronous I/O. <br>        // <br> <br>        while ( TRUE ) <br>        { <br>            err = recv( s, buffer, sizeof(buffer), 0 ); <br>            if ( err == 0 ) <br>            { <br>                printf( "Connection terminated gracefully.\n" ); <br>                break; <br>            } <br>            else if ( err &lt; 0 ) <br>            { <br>                err = GetLastError(); <br> <br>                if ( err == WSAEDISCON ) <br>                { <br>                    printf( "Connection disconnected.\n" ); <br>                } <br>                else <br>                { <br>                    printf( "recv() failed, error %ld.\n", err ); <br>                } <br> <br>                break; <br>            } <br> <br>            err = send( s, buffer, err, 0 ); <br> <br>            if ( err &lt; 0 ) <br>            { <br>                printf( "send() failed, error %ld\n", GetLastError( ) ); <br>                break; <br>            } <br>        } <br> <br>        // <br>        // Close the connected socket and continue accepting connections. <br>        // <br> <br>        closesocket( s ); <br>    } <br> <br>} // main <br> <br> <br>  <br>INT <br>OpenListeners ( <br>    IN PTSTR ServiceName, <br>    IN LPGUID ServiceType, <br>    IN BOOL Reliable, <br>    IN BOOL MessageOriented, <br>    IN BOOL StreamOriented, <br>    IN BOOL Connectionless, <br>    OUT SOCKET SocketHandles[], <br>    OUT INT ProtocolsUsed[] <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Examines the Windows Sockets transport protocols loaded on a machine <br>    and opens listening sockets on all the protocols which support the <br>    characteristics requested by the caller. <br> <br>Arguments: <br> <br>    ServiceName - a friendly name which identifies this service.  On <br>        name spaces which support name resolution at the service level <br>        (e.g.  SAP) this is the name clients will use to connect to this <br>        service.  On name spaces which support name resolution at the <br>        host level (e.g.  DNS) this name is ignored and applications <br>        must use the host name to establish communication with this <br>        service. <br> <br>    ServiceType - the GUID value which uniquely identifies the type of <br>        service we provide.  A GUID is created with the UUIDGEN program. <br> <br>    Reliable - if TRUE, the caller requests that only transport protocols <br>        which support reliable data delivery be used.  If FALSE, both <br>        reliable and unreliable protocols may be used. <br> <br>    MessageOriented - if TRUE, only message-oriented transport protocols <br>        should be used.  If FALSE, the caller either does not care <br>        whether the protocols used are message oriented or desires only <br>        stream-oriented protocols. <br> <br>    StreamOriented - if TRUE, only stream-oriented transport protocols <br>        should be used.  If FALSE, the caller either does not care <br>        whether the protocols used are stream oriented or desires only <br>        message-oriented protocols. <br> <br>    Connectionless - if TRUE, only connectionless protocols should be <br>        used.  If FALSE, both connection-oriented and connectionless <br>        protocols may be used. <br> <br>    SocketHandles - an array of size MAX_SOCKETS which receives listening <br>        socket handles. <br> <br>    ProtocolsUsed - an array of size MAX_SOCKETS which receives the <br>        protocol values for each of the socket handles in the <br>        SocketHandles array. <br> <br>Return Value: <br> <br>    The count of listening sockets successfully opened, or -1 if no <br>    sockets could be successfully opened that met the desired <br>    characteristics. <br> <br>--*/ <br> <br>{ <br>    INT            protocols[MAX_SOCKETS+1]; <br>    BYTE           buffer[2048]; <br>    DWORD          bytesRequired; <br>    INT            err; <br>    PPROTOCOL_INFO protocolInfo; <br>    PCSADDR_INFO   csaddrInfo; <br>    INT            protocolCount; <br>    INT            addressCount; <br>    INT            i; <br>    DWORD          protocolIndex; <br>    SOCKET         s; <br>    DWORD          index = 0; <br> <br>    // <br>    // First look up the protocols installed on this machine.  The <br>    // EnumProtocols() API returns about all the Windows Sockets <br>    // protocols loaded on this machine, and we'll use this information <br>    // to identify the protocols which provide the necessary semantics. <br>    // <br> <br>    bytesRequired = sizeof(buffer); <br> <br>    err = EnumProtocols( NULL, buffer, &amp;bytesRequired ); <br> <br>    if ( err &lt;= 0 ) <br>    { <br>        return 0; <br>    } <br> <br>    // <br>    // Walk through the available protocols and pick out the ones which <br>    // support the desired characteristics. <br>    // <br> <br>    protocolCount = err; <br>    protocolInfo = (PPROTOCOL_INFO)buffer; <br> <br>    for ( i = 0, protocolIndex = 0; <br>          i &lt; protocolCount &amp;&amp; protocolIndex &lt; MAX_SOCKETS; <br>          i++, protocolInfo++ ) <br>    { <br>        // <br>        // If "reliable" support is requested, then check if supported <br>        // by this protocol.  Reliable support means that the protocol <br>        // guarantees delivery of data in the order in which it is sent. <br>        // Note that we assume here that if the caller requested reliable <br>        // service then they do not want a connectionless protocol. <br>        // <br> <br>        if ( Reliable ) <br>        { <br>            // <br>            // Check to see if the protocol is reliable.  It must <br>            // guarantee both delivery of all data and the order in <br>            // which the data arrives.  Also, it must not be a <br>            // connectionless protocol. <br>            // <br> <br>            if ( (protocolInfo-&gt;dwServiceFlags &amp; <br>                      XP_GUARANTEED_DELIVERY) == 0 || <br>                 (protocolInfo-&gt;dwServiceFlags &amp; <br>                      XP_GUARANTEED_ORDER) == 0 ) <br>            { <br>                continue; <br>            } <br> <br>            if ( (protocolInfo-&gt;dwServiceFlags &amp; XP_CONNECTIONLESS) != 0 ) <br>            { <br>                continue; <br>            } <br> <br>            // <br>            // Check to see that the protocol matches the stream/message <br>            // characteristics requested.  A stream oriented protocol <br>            // either has the XP_MESSAGE_ORIENTED bit turned off, or <br>            // else supports "pseudo stream" capability.  Pseudo stream <br>            // means that although the underlying protocol is message <br>            // oriented, the application may open a socket of type <br>            // SOCK_STREAM and the protocol will hide message boundaries <br>            // from the application. <br>            // <br> <br>            if ( StreamOriented &amp;&amp; <br>                 (protocolInfo-&gt;dwServiceFlags &amp; XP_MESSAGE_ORIENTED) != 0 &amp;&amp; <br>                 (protocolInfo-&gt;dwServiceFlags &amp; XP_PSEUDO_STREAM) == 0 ) <br>            { <br>                continue; <br>            } <br> <br>            if ( MessageOriented &amp;&amp; <br>                 (protocolInfo-&gt;dwServiceFlags &amp; XP_MESSAGE_ORIENTED) == 0 ) <br>            { <br>                continue; <br>            } <br> <br>        } <br>        else if ( Connectionless ) <br>        { <br>            // <br>            // Make sure that this is a connectionless protocol.  In a <br>            // connectionless protocol, data is sent as discrete <br>            // datagrams with no connection establishment required. <br>            // Connectionless protocols typically have no reliability <br>            // guarantees. <br>            // <br> <br>            if ( (protocolInfo-&gt;dwServiceFlags &amp; XP_CONNECTIONLESS) != 0 ) <br>            { <br>                continue; <br>            } <br>        } <br> <br>        // <br>        // This protocol fits all the criteria.  Add it to the list of <br>        // protocols in which we're interested. <br>        // <br> <br>        protocols[protocolIndex++] = protocolInfo-&gt;iProtocol; <br>    } <br> <br>    // <br>    // Make sure that we found at least one acceptable protocol.  If <br>    // there no protocols on this machine which meet the caller's <br>    // requirements then fail here. <br>    // <br> <br>    if ( protocolIndex == 0 ) <br>    { <br>        return 0; <br>    } <br> <br>    protocols[protocolIndex] = 0; <br> <br>    // <br>    // Now attempt to find the socket addresses to which we need to <br>    // bind.  Note that we restrict the scope of the search to those <br>    // protocols of interest by passing the protocol array we generated <br>    // above to GetAddressByName().  This forces GetAddressByName() to <br>    // return socket addresses for only the protocols we specify, <br>    // ignoring possible addresses for protocols we cannot support <br>    // because of the caller's constraints. <br>    // <br> <br>    bytesRequired = sizeof(buffer); <br> <br>    err = GetAddressByName( <br>               NS_DEFAULT, <br>               ServiceType, <br>               ServiceName, <br>               protocols, <br>               RES_SERVICE | RES_FIND_MULTIPLE, <br>               NULL,                     // lpServiceAsyncInfo <br>               buffer, <br>               &amp;bytesRequired, <br>               NULL,                     // lpAliasBuffer <br>               NULL                      // lpdwAliasBufferLength <br>               ); <br> <br>    if ( err &lt;= 0 ) <br>    { <br>        return 0; <br>    } <br> <br>    // <br>    // For each address, open a socket and attempt to listen. Note <br>    // that if anything fails for a particular protocol we just skip on <br>    // to the next protocol. As long as we can successfully listen on <br>    // one protocol we are satisfied here. <br>    // <br> <br>    addressCount = err; <br>    csaddrInfo = (PCSADDR_INFO)buffer; <br> <br>    for ( i = 0; i &lt; addressCount; i++, csaddrInfo++ ) <br>    { <br>        // <br>        // Open the socket. Note that we manually specify stream type <br>        // if so requested in case the protocol is natively a message <br>        // protocol but supports stream semantics. <br>        // <br> <br>        s = socket( csaddrInfo-&gt;LocalAddr.lpSockaddr-&gt;sa_family, <br>                    StreamOriented ? SOCK_STREAM : csaddrInfo-&gt;iSocketType, <br>                    csaddrInfo-&gt;iProtocol ); <br> <br>        if ( s == INVALID_SOCKET ) <br>        { <br>            continue; <br>        } <br> <br>        // <br>        // Bind the socket to the local address specified. <br>        // <br> <br>        err = bind( s, csaddrInfo-&gt;LocalAddr.lpSockaddr, <br>                    csaddrInfo-&gt;LocalAddr.iSockaddrLength ); <br> <br>        if ( err != NO_ERROR ) <br>        { <br>            closesocket( s ); <br>            continue; <br>        } <br> <br>        // <br>        // Start listening for incoming sockets on the socket if this is <br>        // not a datagram socket.  If this is a datagram socket, then <br>        // the listen() API doesn't make sense; doing a bind() is <br>        // sufficient to listen for incoming datagrams on a <br>        // connectionless protocol. <br>        // <br> <br>        if ( csaddrInfo-&gt;iSocketType != SOCK_DGRAM ) <br>        { <br>            err = listen( s, 5 ); <br> <br>            if ( err != NO_ERROR ) <br>            { <br>                closesocket( s ); <br>                continue; <br>            } <br>        } <br> <br>        // <br>        // The socket was successfully opened and we're listening on it. <br>        // Remember the protocol used and the socket handle and continue <br>        // listening on other protocols. <br>        // <br> <br>        ProtocolsUsed[index] = csaddrInfo-&gt;iProtocol; <br>        SocketHandles[index] = s; <br> <br>        index++; <br>        if ( index == MAX_SOCKETS ) <br>        { <br>            return index; <br>        } <br>    } <br> <br>    (void) LocalFree( (HLOCAL) csaddrInfo ); <br> <br>    // <br>    // Return the count of sockets that we're sucecssfully listening on. <br>    // <br> <br>    return index; <br> <br>} // OpenListeners <br> <br> <br>INT <br>AdvertiseService( <br>    IN PTSTR ServiceName, <br>    IN LPGUID ServiceType, <br>    IN SOCKET SocketHandles[], <br>    IN INT SocketCount <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Advertises this service on all the default name spaces. <br> <br>Arguments: <br> <br>    ServiceName - the name of the service. <br> <br>    ServiceType - the GUID value which uniquely the service. <br> <br>    SocketHandles - array of sockets that we have opened. For each socket, <br>        we do a getsockname() to discover the actual local address. <br> <br>    SocketCount - number of sockets in SockHandles[] <br> <br>Return Value: <br> <br>    0 if success. SOCK_ERROR otherwise. <br> <br>--*/ <br> <br>{ <br> <br>    WSAVERSION          Version; <br>    WSAQUERYSET         QuerySet; <br>    LPCSADDR_INFO       lpCSAddrInfo; <br>    PSOCKADDR           sockAddr ; <br>    BYTE *              addressBuffer; <br>    DWORD               addressBufferSize ; <br>    DWORD               successCount = 0 ; <br>    INT                 i, err ; <br> <br>    // <br>    // Allocate some memory for the CSADDR_INFO structures. <br>    // <br> <br>    lpCSAddrInfo = (LPCSADDR_INFO) malloc( sizeof(CSADDR_INFO) * SocketCount ); <br> <br>    if (!lpCSAddrInfo) <br>    { <br>        SetLastError(ERROR_NOT_ENOUGH_MEMORY) ; <br>        return SOCKET_ERROR ; <br>    } <br> <br>    // <br>    // Allocate some memory for the SOCKADDR addresses returned <br>    // by getsockname(). <br>    // <br> <br>    addressBufferSize = SocketCount * sizeof(SOCKADDR); <br>    addressBuffer = malloc( addressBufferSize ) ; <br> <br>    if (!addressBuffer) <br>    { <br>        free(lpCSAddrInfo) ; <br>        SetLastError(ERROR_NOT_ENOUGH_MEMORY) ; <br>        return SOCKET_ERROR ; <br>    } <br> <br>    RtlZeroMemory( &amp;QuerySet, sizeof( WSAQUERYSET ) ); <br> <br>    // <br>    // For each socket, get its local association. <br>    // <br> <br>    sockAddr = (PSOCKADDR) addressBuffer ; <br> <br>    for (i = 0; i &lt; SocketCount; i++) <br>    { <br>        int size = (int) addressBufferSize ; <br> <br>        // <br>        // Call getsockname() to get the local association for the socket. <br>        // <br> <br>        err = getsockname( <br>                  SocketHandles[i], <br>                  sockAddr, <br>                  &amp;size) ; <br> <br>        if (err == SOCKET_ERROR) <br>        { <br>            continue ; <br>        } <br> <br>        // <br>        // Now setup the Addressing information for this socket. <br>        // Only the dwAddressType, dwAddressLength and lpAddress <br>        // is of any interest in this example. <br>        // <br> <br>        lpCSAddrInfo[i].LocalAddr.iSockaddrLength = size; <br>        lpCSAddrInfo[i].LocalAddr.lpSockaddr = sockAddr; <br>        lpCSAddrInfo[i].RemoteAddr.iSockaddrLength = size; <br>        lpCSAddrInfo[i].RemoteAddr.lpSockaddr = sockAddr; <br>        lpCSAddrInfo[i].iSocketType = SOCK_RDM; // Reliable <br>        lpCSAddrInfo[i].iProtocol = sockAddr-&gt;sa_family; <br> <br>        // <br>        // Advance pointer and adjust buffer size. Assumes that <br>        // the structures are aligned. <br>        // <br> <br>        addressBufferSize -= size ; <br>        sockAddr = (PSOCKADDR) ((BYTE*)sockAddr + size)  ; <br> <br>        successCount++ ; <br>    } <br> <br>    // <br>    // If we got at least one address, go ahead and advertise it. <br>    // <br> <br>    if (successCount) <br>    { <br>        QuerySet.dwSize = sizeof( WSAQUERYSET ); <br>        QuerySet.lpServiceClassId = ServiceType; <br>        QuerySet.lpszServiceInstanceName = ServiceName; <br>        QuerySet.lpszComment = "D/C/M's Example Echo Service"; <br>        QuerySet.lpVersion = &amp;Version; <br>        QuerySet.lpVersion-&gt;dwVersion = 1; <br>        QuerySet.lpVersion-&gt;ecHow = COMP_NOTLESS; <br>        QuerySet.dwNameSpace = NS_ALL; <br>        QuerySet.dwNumberOfCsAddrs = successCount; <br>        QuerySet.lpcsaBuffer = lpCSAddrInfo; <br> <br>        err = WSASetService( &amp;QuerySet, <br>                             RNRSERVICE_REGISTER, <br>                             SERVICE_MULTIPLE ); <br> <br>        if ( err ) <br>            err = SOCKET_ERROR; <br>    } <br>    else <br>        err = SOCKET_ERROR ; <br> <br>    free (addressBuffer) ; <br> <br>    return (err) ; <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
