<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RNRCLNT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5353"></a>RNRCLNT.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1992 Microsoft Corporation <br> <br>Module Name: <br> <br>    RnrClnt.c <br> <br>Abstract: <br> <br>    Test and demonstration client for the RNR (service Registration and <br>    Name Resolution) APIs.  This is a simple client application designed <br>    to show the basic principles involved in using the RNR APIs to _write <br>    a protocol-independent Windows Sockets client application. <br> <br>    This client works by examining the protocols loaded on the machine, <br>    looking for protocols which are reliable and stream-oriented.  Then <br>    it attempts to locate and connect to the service on these protocols. <br>    When is has successfully connected to the service, it sends <br>    exchanges several messages with the service and then terminates the <br>    connection. <br> <br>    The OpenConnection() routine implemented herein is intended to be a <br>    demonstration of RNR functionality commonly used in <br>    protocol-independent clients.  Application writers are encouraged to <br>    leverage this code to assist them in writing protocol-independent <br>    applications on top of the Windows Sockets API. <br> <br> <br>--*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;winsock2.h&gt; <br>#include &lt;nspapi.h&gt; <br> <br>#define DEFAULT_TRANSFER_SIZE    512 <br>#define DEFAULT_TRANSFER_COUNT   0x10 <br>#define DEFAULT_CONNECTION_COUNT 1 <br>#define DEFAULT_DELAY            0 <br> <br>#define DEFAULT_RECEIVE_BUFFER_SIZE 4096 <br>#define DEFAULT_SEND_BUFFER_SIZE    4096 <br> <br>#define MAX_PROTOCOLS  10 <br>#define MAX_HOST_NAMES 16 <br> <br>WSADATA WsaData; <br>DWORD TransferSize = DEFAULT_TRANSFER_SIZE; <br>DWORD TransferCount = DEFAULT_TRANSFER_COUNT; <br>PCHAR IoBuffer; <br>DWORD RepeatCount = 1; <br>INT ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE; <br>INT SendBufferSize = DEFAULT_SEND_BUFFER_SIZE; <br> <br>PCHAR RemoteName = "localhost"; <br>PCHAR ServiceTypeName = "EchoExample"; <br> <br>VOID <br>DoEcho( <br>    IN SOCKET s ); <br> <br>SOCKET <br>OpenConnection( <br>    IN  PTSTR  ServiceName, <br>    IN  LPGUID ServiceType, <br>    IN  BOOL   Reliable, <br>    IN  BOOL   MessageOriented, <br>    IN  BOOL   StreamOriented, <br>    IN  BOOL   Connectionless, <br>    OUT PINT   ProtocolUsed ); <br> <br>INT <br>Rnr20_GetAddressByName( <br>    IN     PTSTR         ServiceName, <br>    IN     LPGUID        ServiceType, <br>    IN     DWORD         dwNameSpace, <br>    IN     DWORD         dwNumberOfProtocols, <br>    IN     LPAFPROTOCOLS lpAfpProtocols, <br>    IN OUT LPVOID        lpCSAddrInfo, <br>    IN OUT LPDWORD       lpdwBufferLength ); <br> <br>void _CRTAPI1 <br>main( <br>    int argc, <br>    char *argv[] ) <br>{ <br>    INT err; <br>    DWORD i; <br>    DWORD protocol[2]; <br>    SOCKET s; <br>    BYTE buffer[1024]; <br>    BYTE buffer2[1024]; <br>    DWORD bytesRequired; <br>    PPROTOCOL_INFO protocolInfo; <br>    GUID serviceType; <br> <br>    // <br>    // Initialize the Windows Sockets DLL. <br>    // <br> <br>    err = WSAStartup( 0x0202, &amp;WsaData ); <br>    if ( err == SOCKET_ERROR ) <br>    { <br>        printf( "WSAStartup() failed: %ld\n", GetLastError( ) ); <br>        return; <br>    } <br> <br>    // <br>    // Parse command-line arguments. <br>    // <br> <br>    for ( i = 1; i &lt; (ULONG)argc != 0; i++ ) <br>    { <br>        if ( _strnicmp( argv[i], "/name:", 6 ) == 0 ) <br>        { <br>            RemoteName = argv[i] + 6; <br>        } <br>        else if ( _strnicmp( argv[i], "/type:", 6 ) == 0 ) <br>        { <br>            ServiceTypeName = argv[i] + 6; <br>        } <br>        else if ( _strnicmp( argv[i], "/size:", 6 ) == 0 ) <br>        { <br>            TransferSize = atoi( argv[i] + 6 ); <br>        } <br>        else if ( _strnicmp( argv[i], "/count:", 7 ) == 0 ) <br>        { <br>            TransferCount = atoi( argv[i] + 7 ); <br>        } <br>        else if ( _strnicmp( argv[i], "/rcvbuf:", 8 ) == 0 ) <br>        { <br>            ReceiveBufferSize = atoi( argv[i] + 8 ); <br>        } <br>        else if ( _strnicmp( argv[i], "/sndbuf:", 8 ) == 0 ) <br>        { <br>            SendBufferSize = atoi( argv[i] + 8 ); <br>        } <br>        else <br>        { <br>            printf( "Usage: rnrclnt [/name:SVCNAME] [/type:TYPENAME] [/size:N]\n" ); <br>            printf( "               [/count:N] [/rcvbuf:N] [/sndbuf:N]\n" ); <br>            exit( 0 ); <br>        } <br>    } <br> <br>    // <br>    // Allocate memory to hold the network I/O buffer. <br>    // <br> <br>    IoBuffer = malloc( TransferSize + 1 ); <br>    if ( IoBuffer == NULL ) <br>    { <br>        printf( "Failed to allocate I/O buffer.\n" ); <br>        exit( 0 ); <br>    } <br> <br>    // <br>    // Determine the type (GUID) of the service we are interested in <br>    // connecting to. <br>    // <br> <br>    err = GetTypeByName( ServiceTypeName, &amp;serviceType ); <br>    if ( err == SOCKET_ERROR ) <br>    { <br>        printf( "GetTypeByName for \"%s\" failed: %ld\n", <br>                    ServiceTypeName, GetLastError( ) ); <br>        exit( 0 ); <br>    } <br> <br>    // <br>    // Open a connected socket to the service. <br>    // <br> <br>    s = OpenConnection( <br>            RemoteName, <br>            &amp;serviceType, <br>            TRUE, <br>            FALSE, <br>            FALSE, <br>            FALSE, <br>            &amp;protocol[0] <br>            ); <br> <br>    if ( s == INVALID_SOCKET ) <br>    { <br>        printf( "Failed to open connection to name \"%s\" type \"%s\"\n", <br>                    RemoteName, ServiceTypeName ); <br>        exit( 0 ); <br>    } <br> <br>    // <br>    // The connection succeeded.  Display some information on the <br>    // protocol which was used. <br>    // <br> <br>    bytesRequired = sizeof(buffer); <br>    protocol[1] = 0; <br> <br>    err = EnumProtocols( protocol, buffer, &amp;bytesRequired ); <br> <br>    if ( err &lt; 1 ) <br>    { <br>        printf( "EnumProtocols failed for protocol %ld: %ld\n", <br>                protocol[0], GetLastError( ) ); <br>        exit( 0 ); <br>    } <br> <br>    err = GetNameByType( &amp;serviceType, buffer2, sizeof(buffer2) ); <br> <br>    if ( err != NO_ERROR ) <br>    { <br>        printf( "GetNameByType failed: %ld\n", GetLastError( ) ); <br>        exit ( 0 ); <br>    } <br> <br>    protocolInfo = (PPROTOCOL_INFO)buffer; <br>    printf( "Connected to %s/%s with protocol \"%s\" (%ld)\n", <br>            RemoteName, buffer2, <br>            protocolInfo-&gt;lpProtocol, <br>            protocolInfo-&gt;iProtocol ); <br> <br>    // <br>    // Send data to and from the service. <br>    // <br> <br>    DoEcho( s ); <br> <br>} // main <br> <br>  <br>VOID <br>DoEcho( <br>    IN SOCKET s ) <br>{ <br>    INT err; <br>    INT bytesReceived; <br>    DWORD i; <br>    DWORD startTime; <br>    DWORD endTime; <br>    DWORD transferStartTime; <br>    DWORD transferEndTime; <br>    DWORD totalTime; <br>    INT thisTransferSize; <br>    DWORD bytesTransferred = 0; <br> <br>    startTime = GetTickCount( ); <br> <br>    for ( i = 0; i &lt; TransferCount; i++ ) <br>    { <br>        thisTransferSize = TransferSize; <br> <br>        transferStartTime = GetTickCount( ); <br> <br>        err = send( s, IoBuffer, thisTransferSize, 0 ); <br> <br>        if ( err != thisTransferSize ) <br>        { <br>            printf( "send didn't work, ret = %ld, error = %ld\n", <br>                    err, GetLastError( ) ); <br>            closesocket( s ); <br>            return; <br>        } <br> <br>        bytesReceived = 0; <br>        do { <br>            err = recv( s, IoBuffer, thisTransferSize, 0 ); <br> <br>            if ( err == SOCKET_ERROR ) <br>            { <br>                printf( "recv failed: %ld\n", GetLastError( ) ); <br>                closesocket( s ); <br>                return; <br>            } <br>            else if ( err == 0 &amp;&amp; thisTransferSize != 0 ) <br>            { <br>                printf( "socket closed prematurely by remote.\n" ); <br>                return; <br>            } <br> <br>            bytesReceived += err; <br>        } while ( bytesReceived &lt; thisTransferSize ); <br> <br>        transferEndTime = GetTickCount( ); <br>        printf( "%5ld bytes sent and received in %ld ms\n", <br>                thisTransferSize, transferEndTime - transferStartTime ); <br> <br>        bytesTransferred += thisTransferSize; <br>    } <br> <br>    endTime = GetTickCount( ); <br>    totalTime = endTime - startTime; <br> <br>    printf( "\n%ld bytes transferred in %ld iterations, time = %ld ms\n", <br>            bytesTransferred, TransferCount, totalTime ); <br>    printf( "Rate = %ld KB/s, %ld T/S, %ld ms/iteration\n", <br>            (bytesTransferred / totalTime) * 2, <br>            (TransferCount*1000) / totalTime, <br>            totalTime / TransferCount ); <br> <br>    err = closesocket( s ); <br> <br>    if ( err == SOCKET_ERROR ) <br>    { <br>        printf( "closesocket failed: %ld\n", GetLastError( ) ); <br>        return; <br>    } <br> <br>    return; <br> <br>} // DoEcho <br> <br>  <br>SOCKET <br>OpenConnection( <br>    IN  PTSTR  ServiceName, <br>    IN  LPGUID ServiceType, <br>    IN  BOOL   Reliable, <br>    IN  BOOL   MessageOriented, <br>    IN  BOOL   StreamOriented, <br>    IN  BOOL   Connectionless, <br>    OUT PINT   ProtocolUsed ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Examines the Windows Sockets transport protocols loaded on a machine <br>    and determines those which support the characteristics requested by <br>    the caller.  Attempts to locate and connect to the specified service <br>    on these protocols. <br> <br>Arguments: <br> <br>    ServiceName - a friendly name which identifies the service we want <br>        to connect to.  On name spaces which support name resolution at <br>        the service level (e.g.  SAP) this is the name clients will use <br>        to connect to this service.  On name spaces which support name <br>        resolution at the host level (e.g.  DNS) this name is ignored <br>        and applications must use the host name to establish <br>        communication with this service. <br> <br>    ServiceType - the GUID value which uniquely identifies the type of <br>        service we provide.  A GUID is created with the UUIDGEN program. <br> <br>    Reliable - if TRUE, the caller requests that only transport protocols <br>        which support reliable data delivery be used.  If FALSE, both <br>        reliable and unreliable protocols may be used. <br> <br>    MessageOriented - if TRUE, only message-oriented transport protocols <br>        should be used.  If FALSE, the caller either does not care <br>        whether the protocols used are message oriented or desires only <br>        stream-oriented protocols. <br> <br>    StreamOriented - if TRUE, only stream-oriented transport protocols <br>        should be used.  If FALSE, the caller either does not care <br>        whether the protocols used are stream oriented or desires only <br>        message-oriented protocols. <br> <br>    Connectionless - if TRUE, only connectionless protocols should be <br>        used.  If FALSE, both connection-oriented and connectionless <br>        protocols may be used. <br> <br>    ProtocolUsed - if a connection is opened successfully, this <br>        parameter receives the protocol ID of the protocol used to <br>        establish the connection. <br> <br>Return Value: <br> <br>    A connected socket handle, or INVALID_SOCKET if the connection <br>    could not be established. <br> <br>--*/ <br> <br>{ <br>    INT protocols[MAX_PROTOCOLS+1]; <br>    AFPROTOCOLS afProtocols[MAX_PROTOCOLS+1]; <br>    BYTE buffer[2048]; <br>    DWORD bytesRequired; <br>    INT err; <br>    PPROTOCOL_INFO protocolInfo; <br>    PCSADDR_INFO csaddrInfo = NULL; <br>    INT protocolCount; <br>    INT addressCount; <br>    INT i; <br>    DWORD protocolIndex; <br>    SOCKET s; <br> <br>    // <br>    // First look up the protocols installed on this machine.  The <br>    // EnumProtocols() API returns about all the Windows Sockets <br>    // protocols loaded on this machine, and we'll use this information <br>    // to identify the protocols which provide the necessary semantics. <br>    // <br> <br>    bytesRequired = sizeof(buffer); <br> <br>    err = EnumProtocols( NULL, buffer, &amp;bytesRequired ); <br> <br>    if ( err &lt;= 0 ) <br>    { <br>        return INVALID_SOCKET; <br>    } <br> <br>    // <br>    // Walk through the available protocols and pick out the ones which <br>    // support the desired characteristics. <br>    // <br> <br>    protocolCount = err; <br>    protocolInfo = (PPROTOCOL_INFO)buffer; <br> <br>    for ( i = 0, protocolIndex = 0; <br>          i &lt; protocolCount &amp;&amp; protocolIndex &lt; MAX_PROTOCOLS; <br>          i++, protocolInfo++ ) <br>    { <br>        // <br>        // If "reliable" support is requested, then check if supported <br>        // by this protocol.  Reliable support means that the protocol <br>        // guarantees delivery of data in the order in which it is sent. <br>        // Note that we assume here that if the caller requested reliable <br>        // service then they do not want a connectionless protocol. <br>        // <br> <br>        if ( Reliable ) <br>        { <br>            // <br>            // Check to see if the protocol is reliable.  It must <br>            // guarantee both delivery of all data and the order in <br>            // which the data arrives.  Also, it must not be a <br>            // connectionless protocol. <br>            // <br> <br>            if ( (protocolInfo-&gt;dwServiceFlags &amp; <br>                      XP_GUARANTEED_DELIVERY) == 0 || <br>                 (protocolInfo-&gt;dwServiceFlags &amp; <br>                      XP_GUARANTEED_ORDER) == 0 ) <br>            { <br>                continue; <br>            } <br> <br>            if ( (protocolInfo-&gt;dwServiceFlags &amp; XP_CONNECTIONLESS) != 0 ) <br>            { <br>                continue; <br>            } <br> <br>            // <br>            // Check to see that the protocol matches the stream/message <br>            // characteristics requested.  A stream oriented protocol <br>            // either has the XP_MESSAGE_ORIENTED bit turned off, or <br>            // else supports "pseudo stream" capability.  Pseudo stream <br>            // means that although the underlying protocol is message <br>            // oriented, the application may open a socket of type <br>            // SOCK_STREAM and the protocol will hide message boundaries <br>            // from the application. <br>            // <br> <br>            if ( StreamOriented &amp;&amp; <br>                 (protocolInfo-&gt;dwServiceFlags &amp; XP_MESSAGE_ORIENTED) != 0 &amp;&amp; <br>                 (protocolInfo-&gt;dwServiceFlags &amp; XP_PSEUDO_STREAM) == 0 ) <br>            { <br>                continue; <br>            } <br> <br>            if ( MessageOriented &amp;&amp; <br>                 (protocolInfo-&gt;dwServiceFlags &amp; XP_MESSAGE_ORIENTED) == 0 ) <br>            { <br>                continue; <br>            } <br>        } <br>        else if ( Connectionless ) <br>        { <br>            // <br>            // Make sure that this is a connectionless protocol.  In a <br>            // connectionless protocol, data is sent as discrete <br>            // datagrams with no connection establishment required. <br>            // Connectionless protocols typically have no reliability <br>            // guarantees. <br>            // <br> <br>            if ( (protocolInfo-&gt;dwServiceFlags &amp; XP_CONNECTIONLESS) != 0 ) <br>            { <br>                continue; <br>            } <br>        } <br> <br>        // <br>        // This protocol fits all the criteria.  Add it to the list of <br>        // protocols in which we're interested. <br>        // <br>        afProtocols[protocolIndex].iProtocol = protocolInfo-&gt;iProtocol; <br>        afProtocols[protocolIndex].iAddressFamily = AF_UNSPEC; <br> <br>        protocols[protocolIndex++] = protocolInfo-&gt;iProtocol; <br>    } <br> <br>    // <br>    // Make sure that we found at least one acceptable protocol.  If <br>    // there no protocols on this machine which meet the caller's <br>    // requirements then fail here. <br>    // <br> <br>    if ( protocolIndex == 0 ) <br>    { <br>        return INVALID_SOCKET; <br>    } <br> <br>    afProtocols[protocolIndex].iProtocol = 0; <br>    afProtocols[protocolIndex].iAddressFamily = 0; <br> <br>    protocols[protocolIndex] = 0; <br> <br>    // <br>    // Now attempt to find the address of the service to which we're <br>    // connecting.  Note that we restrict the scope of the search to <br>    // those protocols of interest by passing the protocol array we <br>    // generated above to RnrGetAddressFromName() or GetAddressByName() <br>    // depending on whether we are running the client on the same machine <br>    // as the server rnrsrv.exe is running on.  This forces <br>    // RnrGetAddressFromName() or GetAddressByName() to return socket <br>    // addresses for only the protocols we specify, ignoring possible <br>    // addresses for protocols we cannot support because of the caller's <br>    // constraints. <br>    // <br> <br>    bytesRequired = sizeof( buffer ); <br> <br>    if ( !strcmp( ServiceName, "localhost" ) ) <br>    { <br>        // <br>        // This is a Winsock 1.0 call . . . <br>        // <br>        err = GetAddressByName( NS_DEFAULT, <br>                                ServiceType, <br>                                ServiceName, <br>                                protocols, <br>                                0, <br>                                NULL, <br>                                buffer, <br>                                &amp;bytesRequired, <br>                                NULL, <br>                                NULL ); <br>    } <br>    else <br>    { <br>        // <br>        // This calls into Winsock 2.0 . . . <br>        // <br>        err = Rnr20_GetAddressByName( ServiceName, <br>                                      ServiceType, <br>                                      NS_ALL, <br>                                      protocolIndex, <br>                                      afProtocols, <br>                                      buffer, <br>                                      &amp;bytesRequired ); <br>    } <br> <br>    if ( err &lt;= 0 ) <br>    { <br>        return INVALID_SOCKET; <br>    } <br> <br>    addressCount = err; <br>    csaddrInfo = (PCSADDR_INFO) buffer; <br> <br>    // <br>    // For each address, open a socket and attempt to connect.  Note that <br>    // if anything fails for a particular protocol we just skip on to <br>    // the next protocol.  As soon as we have established a connection, <br>    // quit trying. <br>    // <br> <br>    for ( i = 0; i &lt; addressCount; i++, csaddrInfo++ ) <br>    { <br>        // <br>        // Open the socket.  Note that we manually specify stream type <br>        // if so requested in case the protocol is natively a message <br>        // protocol but supports stream semantics. <br>        // <br> <br>        s = socket( csaddrInfo-&gt;LocalAddr.lpSockaddr-&gt;sa_family, <br>                    StreamOriented ? SOCK_STREAM : csaddrInfo-&gt;iSocketType, <br>                    csaddrInfo-&gt;iProtocol ); <br> <br>        if ( s == INVALID_SOCKET ) <br>        { <br>            continue; <br>        } <br> <br>        // <br>        // Bind the socket to the local address specified. <br>        // <br> <br>        err = bind( s, csaddrInfo-&gt;LocalAddr.lpSockaddr, <br>                    csaddrInfo-&gt;LocalAddr.iSockaddrLength ); <br> <br>        if ( err != NO_ERROR ) <br>        { <br>            closesocket( s ); <br>            continue; <br>        } <br> <br>        // <br>        // Attempt to connect the socket to the service.  If this fails, <br>        // keep trying on other protocols. <br>        // <br> <br>        err = connect( s, csaddrInfo-&gt;RemoteAddr.lpSockaddr, <br>                       csaddrInfo-&gt;RemoteAddr.iSockaddrLength ); <br> <br>        if ( err != NO_ERROR ) <br>        { <br>            closesocket( s ); <br>            continue; <br>        } <br> <br>        // <br>        // The socket was successfully connected.  Remember the protocol <br>        // used and return the socket handle to the caller. <br>        // <br> <br>        *ProtocolUsed = csaddrInfo-&gt;iProtocol; <br>        return s; <br>    } <br> <br>    if ( csaddrInfo ) <br>    { <br>        (void) LocalFree( (HLOCAL) csaddrInfo ); <br>    } <br> <br>    // <br>    // We failed to connect to the service. <br>    // <br> <br>    return INVALID_SOCKET; <br> <br>} // OpenConnection <br> <br> <br>INT <br>Rnr20_GetAddressByName( <br>    IN     PTSTR         szServiceName, <br>    IN     LPGUID        lpServiceType, <br>    IN     DWORD         dwNameSpace, <br>    IN     DWORD         dwNumberOfProtocols, <br>    IN     LPAFPROTOCOLS lpAfpProtocols, <br>    IN OUT LPVOID        lpCSAddrInfos, <br>    IN OUT LPDWORD       lpdwBufferLength ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Calls Winsock 2.0 service lookup routines to find service addresses. <br> <br>Arguments: <br> <br>    szServiceName - a friendly name which identifies the service we want <br>        to find the address of. <br> <br>    lpServiceType - a GUID that identifies the type of service we want <br>        to find the address of. <br> <br>    dwNameSpace - The Winsock2 Name Space to get address from (i.e. NS_ALL) <br> <br>    dwNumberOfProtocols - Size of the protocol constraint array, may be zero. <br> <br>    lpAftProtocols -  (Optional) References an array of AFPROTOCOLS structure. <br>        Only services that utilize these protocols will be returned. <br> <br>    lpCSAddrInfos - On successful return, this will point to an array of <br>        CSADDR_INFO structures that contains the host address(es). Memory <br>        is passed in by callee and the length of the buffer is provided by <br>        lpdwBufferLength. <br> <br>    lpdwBufferLength - On input provides the length in bytes of the buffer <br>        lpCSAddrInfos. On output returns the length of the buffer used or <br>        what length the buffer needs to be to store the address. <br> <br>Return Value: <br> <br>    The number of CSADDR_INFO structures returned in lpCSAddrInfos, or <br>    (INVALID_SOCKET) with a WIN32 error in GetLastError. <br> <br>--*/ <br> <br>{ <br>    ULONG            dwLength = 2048;      // Guess at buffer size <br>    PWSAQUERYSETA    pwsaQuerySet; <br>    ULONG            err; <br>    HANDLE           hRnR; <br>    DWORD            tempSize; <br>    DWORD            entries = 0; <br>    DWORD            dwNumberOfCsAddrs; <br> <br>    RtlZeroMemory( lpCSAddrInfos, *lpdwBufferLength ); <br> <br>    pwsaQuerySet = (PWSAQUERYSETA) LocalAlloc( LMEM_ZEROINIT, dwLength ); <br> <br>    if ( pwsaQuerySet == NULL ) <br>    { <br>        // <br>        // Unsuccessful. <br>        // <br>        return ERROR_NOT_ENOUGH_MEMORY; <br>    } <br> <br>    RtlZeroMemory( pwsaQuerySet, dwLength ); <br> <br>    // <br>    // Do a lookup using RNRr. <br>    // <br>    pwsaQuerySet-&gt;dwSize = sizeof( WSAQUERYSETA ); <br>    pwsaQuerySet-&gt;lpszServiceInstanceName = szServiceName; <br>    pwsaQuerySet-&gt;lpServiceClassId = lpServiceType; <br>    pwsaQuerySet-&gt;lpVersion = 0; <br>    pwsaQuerySet-&gt;lpszComment = 0; <br>    pwsaQuerySet-&gt;dwNameSpace = dwNameSpace; <br>    pwsaQuerySet-&gt;lpNSProviderId = 0; <br>    pwsaQuerySet-&gt;lpszContext = 0; <br>    pwsaQuerySet-&gt;dwNumberOfProtocols = dwNumberOfProtocols; <br>    pwsaQuerySet-&gt;lpafpProtocols = lpAfpProtocols; <br> <br>    err = WSALookupServiceBegin( pwsaQuerySet, <br>                                 LUP_RETURN_NAME | <br>                                 LUP_RETURN_ADDR, <br>                                 &amp;hRnR ); <br> <br>    if ( err != NO_ERROR ) <br>    { <br>        err = WSAGetLastError(); <br> <br>        // <br>        // Free memory before returning. <br>        // <br>        (void) LocalFree( (HLOCAL) pwsaQuerySet ); <br> <br>        // <br>        // Unsuccessful. <br>        // <br>        return (DWORD) err; <br>    } <br> <br>    // <br>    // The query was accepted, so execute it via the Next call. <br>    // <br>    tempSize = dwLength; <br> <br>    err = WSALookupServiceNext( hRnR, <br>                                0, <br>                                &amp;tempSize, <br>                                pwsaQuerySet ); <br> <br>    if ( err != NO_ERROR ) <br>    { <br>        err = WSAGetLastError(); <br> <br>        if ( err == WSA_E_NO_MORE ) <br>        { <br>            err = 0; <br>        } <br> <br>        if ( err == WSASERVICE_NOT_FOUND ) <br>        { <br>            err = WSAHOST_NOT_FOUND; <br>        } <br> <br>        (void) LocalFree( (HLOCAL) pwsaQuerySet ); <br> <br>        // <br>        // Unsuccessful. <br>        // <br>        return (DWORD) err; <br> <br>    } <br> <br>    dwNumberOfCsAddrs = pwsaQuerySet-&gt;dwNumberOfCsAddrs; <br> <br>    if ( dwNumberOfCsAddrs &gt; 0 ) <br>    { <br>        // <br>        // Make a copy of the CSAddrInfos returned from WSALookupServiceNext() <br>        // <br>        DWORD dwCSAddrInfoLen = dwNumberOfCsAddrs * sizeof( CSADDR_INFO ); <br> <br>        if ( *lpdwBufferLength &gt; dwCSAddrInfoLen ) <br>        { <br>            RtlCopyMemory( lpCSAddrInfos, <br>                           pwsaQuerySet-&gt;lpcsaBuffer, <br>                           dwCSAddrInfoLen ); <br>        } <br>        else <br>        { <br>            *lpdwBufferLength = dwCSAddrInfoLen; <br>            SetLastError( ERROR_NOT_ENOUGH_MEMORY ); <br>            dwNumberOfCsAddrs = INVALID_SOCKET; <br>        } <br>    } <br> <br>    // <br>    // Close lookup service handle. <br>    // <br>    (VOID) WSALookupServiceEnd( hRnR ); <br> <br>    // <br>    // Free memory used for query set info. <br>    // <br>    (void) LocalFree( (HLOCAL) pwsaQuerySet ); <br> <br>    return dwNumberOfCsAddrs; <br> <br>} // RnrGetHostFromName <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
