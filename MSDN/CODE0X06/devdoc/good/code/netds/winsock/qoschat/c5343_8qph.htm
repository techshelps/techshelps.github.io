<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHATSOCK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5345"></a>CHATSOCK.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995 Intel Corp <br> <br>Module Name: <br> <br>    chatsock.c <br> <br>Abstract: <br> <br>    Socket-related functions for the WinSock2 Chat sample application. <br> <br>--*/ <br> <br>#include "nowarn.h"  /* turn off benign warnings */ <br>#ifndef _WINSOCKAPI_ <br>#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */ <br>#endif <br>#include &lt;windows.h&gt; <br>#include "nowarn.h"  /* some warnings may have been turned back on */ <br>#include &lt;winsock2.h&gt; <br>#include &lt;qos.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;assert.h&gt; <br>#include "qoschat.h" <br>#include "chatsock.h" <br>#include "chatdlg.h" <br> <br> <br> <br>// <br>// Static Globals <br>// <br> <br>// points to an array of WSAPROTOCOL_INFO structs <br>static LPWSAPROTOCOL_INFO InstalledProtocols = NULL; <br> <br>// number of WSAPROTOCOL_INFO structs in the InstalledProtocols buffer <br>static int NumProtocols = 0; <br> <br>// static array of sockets, one for each listening socket <br>static LISTENDATA ListeningSockets[MAX_LISTENING_SOCKETS]; <br> <br>// number of meaningful entries in ListeningSockets <br>static int NumFound = 0; <br> <br> <br> <br> <br>// <br>// Function Prototypes -- Internal Functions <br>// <br> <br>DWORD <br>IOThreadFunc( <br>    IN LPVOID ParamPtr); <br> <br> <br>BOOL <br>HandleOutputEvent( <br>    IN OUT PCONNDATA); <br> <br>BOOL <br>HandleOtherEvent( <br>    IN     DWORD     WaitStatus, <br>    IN OUT PCONNDATA ConnData); <br> <br> <br>BOOL <br>FillLocalAddress( <br>    IN LPVOID          SockAddr); <br> <br>int <br>DoRecv( <br>    IN PCONNDATA ConnData); <br> <br>int <br>DoOverlappedCallbackSend( <br>    IN POUTPUT_REQUEST OutReq, <br>    IN PCONNDATA       ConnData); <br> <br>int <br>DoOverlappedEventSend( <br>    IN POUTPUT_REQUEST OutReq, <br>    IN PCONNDATA       ConnData); <br> <br>int <br>DoSend( <br>    IN POUTPUT_REQUEST OutReq, <br>    IN PCONNDATA       ConnData); <br> <br>void CALLBACK <br>SendCompFunc( <br>    IN DWORD           Error, <br>    IN DWORD           BytesTransferred, <br>    IN LPWSAOVERLAPPED OverlappedPtr, <br>    IN DWORD           Flags); <br> <br>int CALLBACK <br>AcceptCondFunc( <br>    IN LPWSABUF    CallerId, <br>    IN LPWSABUF    CallerData, <br>    IN LPQOS       CallerSQos, <br>    IN LPQOS       CallerGQos, <br>    IN LPWSABUF    CalleeId, <br>    OUT LPWSABUF   CalleeData, <br>    OUT GROUP FAR  *Group, <br>    IN DWORD   CallbackData); <br> <br>LPWSAPROTOCOL_INFO <br>GetProtoFromSocket( <br>    IN SOCKET Socket); <br> <br>BOOL <br>GetMaxMsgSize( <br>    IN OUT PCONNDATA ConnData); <br> <br> <br> <br> <br>// <br>// Function Definitions <br>// <br> <br>  <br>BOOL <br>InitWS2(void) <br>/*++ <br> <br>Routine Description: <br> <br>    Calls WSAStartup, makes sure we have a good version of WinSock2 <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    TRUE - WinSock 2 DLL successfully started up <br> <br>    FALSE - Error starting up WinSock 2 DLL. <br> <br>--*/ <br> <br>{ <br>    int           Error;              // catches return value of WSAStartup <br>    WORD          VersionRequested;   // passed to WSAStartup <br>    WSADATA       WsaData;            // receives data from WSAStartup <br>    BOOL          ReturnValue = TRUE; // return value <br> <br>    // Start WinSock 2.  If it fails, we don't need to call <br>    // WSACleanup(). <br>    VersionRequested = MAKEWORD(VERSION_MAJOR, VERSION_MINOR); <br>    Error = WSAStartup(VersionRequested, &amp;WsaData); <br>    if (Error) { <br>        MessageBox(GlobalFrameWindow, <br>                   "Could not find high enough version of WinSock", <br>                   "Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        ReturnValue = FALSE; <br>    } else { <br> <br>        // Now confirm that the WinSock 2 DLL supports the exact version <br>        // we want. If not, make sure to call WSACleanup(). <br>        if (LOBYTE(WsaData.wVersion) != VERSION_MAJOR || <br>            HIBYTE(WsaData.wVersion) != VERSION_MINOR) { <br>            MessageBox(GlobalFrameWindow, <br>                       "Could not find the correct version of WinSock", <br>                       "Error",  MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            WSACleanup(); <br>            ReturnValue = FALSE; <br>        } <br>    } <br>    return(ReturnValue); <br> <br>} // InitWS2() <br> <br> <br> <br> <br>  <br>BOOL <br>FindProtocols(void) <br>/*++ <br> <br>Routine Description: <br> <br>    Finds out about all transport protocols installed on the local <br>    machine and saves the information into global variables. <br> <br>Implementation: <br> <br>    This function uses WSAEnumProtocols to find out about all <br>    installed protocols on the local machine.  It stores this <br>    information in two variables which are global to this file; <br>    InstalledProtocols is a pointer to a buffer of WSAPROTOCOL_INFO <br>    structs, while NumProtocols is the number of protocols in that <br>    buffer.  This function is the only function in the file allowed to <br>    touch these variables. <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    TRUE - Successfully initialized the protocol buffer. <br> <br>    FALSE - Some kind of problem arose.  The user is informed of the <br>    error. <br> <br>--*/ <br>{ <br> <br>    DWORD BufferSize = 0;       // size of InstalledProtocols buffer <br>    char  MsgText[MSG_LEN];     // holds message strings <br> <br>    // Call WSAEnumProtocols to figure out how big of a buffer we need. <br>    NumProtocols = WSAEnumProtocols(NULL, <br>                                    NULL, <br>                                    &amp;BufferSize); <br> <br>    if ((NumProtocols != SOCKET_ERROR) &amp;&amp; (WSAGetLastError() != WSAENOBUFS)) { <br>        // We're in trouble!! <br>        MessageBox(GlobalFrameWindow, "WSAEnumProtocols is broken.", "Error", <br>                   MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        goto Fail; <br>    } <br> <br>    // <br>    // Allocate a buffer, call WSAEnumProtocols to get an array of <br>    // WSAPROTOCOL_INFO structs. <br>    // <br>    InstalledProtocols = (LPWSAPROTOCOL_INFO)malloc(BufferSize); <br>    if (InstalledProtocols == NULL) { <br>        MessageBox(GlobalFrameWindow, "malloc failed.", "Error", <br>                   MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        goto Fail; <br>    } <br> <br>    NumProtocols = WSAEnumProtocols(NULL, <br>                                    (LPVOID)InstalledProtocols, <br>                                    &amp;BufferSize); <br>    if (NumProtocols == SOCKET_ERROR) { <br>        // uh-oh <br>        wsprintf(MsgText, "WSAEnumProtocols failed.  Error Code: %d", <br>                 WSAGetLastError()); <br>        MessageBox(GlobalFrameWindow, MsgText, "Error", <br>                   MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        goto Fail; <br>    } <br>    return(TRUE); <br> <br> Fail: <br> <br>    WSACleanup(); <br>    return(FALSE); <br> <br>} // FindProtocols() <br> <br> <br> <br> <br>  <br>BOOL <br>FillLocalAddress( <br>    IN LPWSABUF SockAddrBuf) <br>/*++ <br> <br>Routine Description: <br> <br>    Takes the buffer passed in, and fills it in with a local address, <br>    as given by the user, on which a socket may listen.  The buffer <br>    can be of any length, but the first two bytes must be the address <br>    family of the protocol, and this value is used to pop up an <br>    appropriate dialog box.  For address families chat doesn't <br>    recognize, a default dialog box is shown and the user may fill in <br>    the address by hand. <br> <br>Arguments: <br> <br>    SockAddrBuf -- A buffer that will receive the local address for <br>    listening as chosen by the user.  The first two bytes should <br>    indicate the address family. <br> <br>Return Value: <br> <br>    TRUE -- FillLocalAddress recognized the address family and <br>    successfully filled in the struct sockaddr.  This structure is <br>    ready to be passed to a bind() call. <br> <br>    FALSE -- FillLocalAddress didn't touch the struct sockaddr, <br>    probably because the user cancelled the dialog box. <br> <br>--*/ <br>{ <br> <br>    struct sockaddr_in *SockAddrInet; // used to cast SockAddr to an <br>                                      // Internet-style address <br>    BOOL ReturnValue = TRUE;          // holds the return value <br> <br>    switch (((struct sockaddr *)SockAddrBuf-&gt;buf)-&gt;sa_family) { <br> <br>    case AF_INET: <br> <br>        // Bring up the dialog box that lets the user pick an internet <br>        // port to listen on.  Cast the pointer so we can now access <br>        // it's fields as a struct sockaddr_in, the address structure <br>        // for internet addresses. <br> <br>        SockAddrInet = (struct sockaddr_in *)SockAddrBuf-&gt;buf; <br>        if (LocalPort == 0) { <br>            if (!DialogBoxParam(GlobalInstance, <br>                                "InetListenPortDlg", <br>                                GlobalFrameWindow, <br>                                InetListenPortDlgProc, <br>                                (LPARAM)SockAddrInet)) { <br>                ReturnValue = FALSE; <br>            } <br>        } else { <br>            SockAddrInet-&gt;sin_port = (u_short)LocalPort; <br>        } <br>        break; <br> <br>    default: <br> <br>        // Bring up the default dialog box to let the user pick an <br>        // address to listen on, regardless of the address family. <br>        if (!DialogBoxParam(GlobalInstance, <br>                            "DefaultListenAddrDlg", <br>                            GlobalFrameWindow, <br>                            DefaultListenAddrDlgProc, <br>                            (LPARAM)SockAddrBuf)) { <br>            ReturnValue = FALSE; <br>        } <br>        break; <br> <br>    } <br>    return(ReturnValue); <br> <br>} // FillLocalAddress() <br> <br> <br> <br> <br>  <br>BOOL <br>ListenAll(void) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    For each installed, connection-oriented protocol, this function <br>    creates a socket, binds to a local address, and listens on the <br>    created socket.  The socket is set up for Windows message <br>    notification for any connection attempts. <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    TRUE - Successfully listened on all installed protocols. <br> <br>    FALSE - Error listening on all installed protocols.  It is not an <br>    error if there are more connection-oriented protocols than <br>    MAX_LISTENING_SOCKETS installed; in this case we just ignore any <br>    extra protocols. <br> <br>--*/ <br> <br>{ <br>    LPWSAPROTOCOL_INFO COProtocolInfo; // current protocol info to examine <br>    int             i;                // counting variable <br>    char            MsgText[MSG_LEN]; // holds message strings <br>    int             Error;            // holds return values <br>    int             Index;            // indexes into text messages <br>    WSABUF          SockAddrBuf;      // to pass to FillLocalAddress <br> <br>    // Find all protocols that support connection-oriented data <br>    // transfer; create a socket, bind to a local address and listen <br>    // for connections on that socket for each such protocol found. <br>    // Also fill in an entry in the ListeningSockets array. <br>    for (i = 0; i &lt; NumProtocols; i++) { <br> <br>        COProtocolInfo = &amp;InstalledProtocols[i]; <br>        assert(COProtocolInfo != NULL); <br>        if (UseProtocol(COProtocolInfo)) { <br> <br>            // We've found a suitable protocol.  Create a socket, fill <br>            // in the next entry in ListeningSockets <br>            ListeningSockets[NumFound].Socket = WSASocket(0, <br>                                                          0, <br>                                                          0, <br>                                                          COProtocolInfo, <br>                                                          0, <br>                                                          WSA_FLAG_OVERLAPPED); <br>            if (ListeningSockets[NumFound].Socket == INVALID_SOCKET) { <br>                MessageBox(GlobalFrameWindow, "Could not open a socket.", <br>                           "Non-fatal error.", <br>                           MB_OK | MB_SETFOREGROUND); <br>                continue; <br>            } <br>            ListeningSockets[NumFound].ProtocolInfo = COProtocolInfo; <br> <br>            // Allocate a block of memory for the socket address and <br>            // zero it out. <br>            SockAddrBuf.len = COProtocolInfo-&gt;iMaxSockAddr; <br>            SockAddrBuf.buf = (char *)malloc(SockAddrBuf.len); <br>            if (!SockAddrBuf.buf) { <br>                ChatSysError("malloc()", <br>                             "ListenAll()", <br>                             TRUE); <br>            } <br>            memset(SockAddrBuf.buf, 0, SockAddrBuf.len); <br> <br>            // Fill in the address family of the socket address. The <br>            // garbage on the left-hand side of this assignment is to <br>            // make the generic SockAddrBuf.buf look like a struct <br>            // sockaddr pointer for the purposes of assigning the <br>            // first two bytes to be the appropriate address family. <br>            ((struct sockaddr *)SockAddrBuf.buf)-&gt;sa_family = <br>              (u_short)COProtocolInfo-&gt;iAddressFamily; <br> <br>            // Get a local address to bind the socket to <br>            FillLocalAddress(&amp;SockAddrBuf); <br> <br>            // Bind the socket to SockAddr. <br>            Error = bind(ListeningSockets[NumFound].Socket, <br>                         (struct sockaddr *)SockAddrBuf.buf, <br>                         SockAddrBuf.len); <br>            if (Error == SOCKET_ERROR) { <br> <br>                // bind() failed <br>                MessageBox(GlobalFrameWindow, "Could not bind the socket.", <br>                           "Non-fatal error", MB_OK | MB_SETFOREGROUND); <br>                free(SockAddrBuf.buf); <br>                continue; <br>            } <br>            free(SockAddrBuf.buf); <br> <br>            // Set up the socket for windows message event notification. <br>            // Note that this call automatically puts the socket into <br>            // non-blocking mode, as if we had called WSAIoctl with <br>            // the FIONBIO flag. <br>            Error = WSAAsyncSelect(ListeningSockets[NumFound].Socket, <br>                                   GlobalFrameWindow, <br>                                   USMSG_ACCEPT, <br>                                   FD_ACCEPT ); <br>            if (Error == SOCKET_ERROR) { <br>                MessageBox(GlobalFrameWindow, "Error: WSAAsyncSelect()", <br>                           "Non-fatal error", MB_OK | MB_SETFOREGROUND); <br>                continue; <br>            } <br> <br>            // Listen for incoming connection requests on the socket. <br>            Error = listen(ListeningSockets[NumFound].Socket, <br>                           SOMAXCONN); <br>            if (Error == SOCKET_ERROR) { <br>                MessageBox(GlobalFrameWindow, "Error: listen()", <br>                           "Non-fatal error", <br>                           MB_OK | MB_SETFOREGROUND); <br>                continue; <br>            } <br> <br>            // Looks good -- increase the count, check for overflow of <br>            // the max amount, re-iterate if we're ok. <br>            if (++NumFound == MAX_LISTENING_SOCKETS) { <br>                wsprintf(MsgText, <br>                         "More than %d useable protocols. Ignoring extras.", <br>                         MAX_LISTENING_SOCKETS); <br>                MessageBox(GlobalFrameWindow, MsgText, "Alert", <br>                           MB_OK | MB_SETFOREGROUND); <br>                break; <br>            } <br> <br>        } // if (UseProtocol(COProtocolInfo)) <br>    } // for(; ; ;) <br> <br>    if (NumFound == 0) { <br> <br>        Index = wsprintf(MsgText, <br>                         "Couldn't find a suitable protocol "); <br>        Index += wsprintf(MsgText + Index, <br>                          "and/or no listening sockets could be opened.\r\n"); <br>        wsprintf(MsgText + Index, "Shall we continue anyway?"); <br> <br>        if (MessageBox(GlobalFrameWindow, MsgText, "No protocols.", <br>                       MB_ICONQUESTION | MB_YESNO | MB_SETFOREGROUND) <br>            == IDNO) { <br> <br>            WSACleanup(); <br>            return(FALSE); <br>        } <br>    } <br> <br>    return(TRUE); <br> <br>} // ListenAll() <br> <br> <br> <br> <br>  <br>BOOL <br>UseProtocol( <br>    IN LPWSAPROTOCOL_INFO Proto) <br>/*++ <br> <br>Routine Description: <br> <br>    Returns true if Proto is suitable for use by Chat. <br> <br>Arguments: <br> <br>    Proto -- Points to a protocol information struct. <br> <br>Return Value: <br> <br>    TRUE -- Chat likes it. <br> <br>    FALSE -- Get this chintzy protocol out of here! <br> <br>--*/ <br>{ <br> <br>    if ((!(Proto-&gt;dwServiceFlags1 &amp; XP1_CONNECTIONLESS)) &amp;&amp; <br>        (Proto-&gt;dwServiceFlags1 &amp; XP1_GUARANTEED_DELIVERY) &amp;&amp; <br>        (Proto-&gt;dwServiceFlags1 &amp; XP1_QOS_SUPPORTED) &amp;&amp; <br>        (Proto-&gt;dwServiceFlags1 &amp; XP1_GUARANTEED_ORDER) &amp;&amp; <br>        (Proto-&gt;iAddressFamily == AF_INET)) { <br> <br>        return(TRUE); <br> <br>    } else { <br> <br>        return(FALSE); <br>    } <br>} // UseProtocol <br> <br> <br> <br> <br>  <br>void <br>CleanUpSockets(void) <br>/*++ <br> <br>Routine Description: <br> <br>    This function closes all listening sockets. <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br> <br>    int i; // counting variable <br> <br>    for (i = 0; i &lt; NumFound; i++) { <br>        closesocket(ListeningSockets[i].Socket); <br>    } <br>} // CleanUpSockets() <br> <br> <br> <br> <br>  <br>int CALLBACK <br>AcceptCondFunc( <br>    IN LPWSABUF   CallerId, <br>    IN LPWSABUF   CallerData, <br>    IN LPQOS      CallerSQos, <br>    IN LPQOS      CallerGQos, <br>    IN LPWSABUF   CalleeId, <br>    OUT LPWSABUF  CalleeData, <br>    OUT GROUP FAR *Group, <br>    IN DWORD  CallbackData) <br>/*++ <br> <br>Routine Description: <br> <br>    Condition function called when an incoming connection request is <br>    handled. <br> <br>Implementation: <br> <br>    This function allows the user to accept or reject an incoming <br>    connection request after examining the caller's name and the <br>    subject of the call. If the call is accepted, and <br>    connection-time data transfer is supported by the particular <br>    protocol on which the connection is made, a dialog box comes up <br>    which prompts the user for his/her name. <br> <br>Arguments: <br> <br>    CallerId -- Supplies the address of the caller. <br> <br>    CallerData -- Supplies the caller's user data.  Chat uses this <br>    parameter to send the caller's name and the subject of the call. <br> <br>    CallerSQos -- Supplies the forward and backward QOS. <br> <br>    CallerGQos -- Supplies the forward and backward flow specs for the <br>    socket group the caller is to create.  Not used by chat. <br> <br>    CalleeId -- Supplies the local address. <br> <br>    CalleeData -- Returns user data back to the caller (Chat uses this <br>    parameter to return the callee's name) <br> <br>    Group -- Returns the appropriate group action to take on the <br>    connecting socket.  Not used by chat.  Always returns NULL. <br> <br>    CallbackData -- Supplies a pointer the CONNDATA structure <br>    associated with this connection. <br> <br>Return Value: <br> <br>    CF_ACCEPT - Accept the connection request from the caller. <br> <br>    CF_REJECT - Reject the connection request from the caller. <br> <br>--*/ <br> <br>{ <br>    PCONNDATA  ConnData;    // connection-specific data <br>    int           ReturnValue = CF_ACCEPT;  // return value <br>    LPFLOWSPEC    FlowSpec; <br> <br>    ConnData = (PCONNDATA)CallbackData; <br> <br>    FlowSpec = &amp;CallerSQos-&gt;SendingFlowspec; <br>    FlowSpec-&gt;TokenRate = TOKENRATE; <br>    FlowSpec-&gt;TokenBucketSize = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;PeakBandwidth = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;Latency = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;DelayVariation = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;ServiceType = SERVICETYPE_CONTROLLEDLOAD; <br>    FlowSpec-&gt;MaxSduSize = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;MinimumPolicedSize = QOS_NOT_SPECIFIED; <br> <br>    FlowSpec = &amp;CallerSQos-&gt;ReceivingFlowspec; <br>    FlowSpec-&gt;TokenRate = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;TokenBucketSize = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;PeakBandwidth = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;Latency = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;DelayVariation = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;ServiceType = SERVICETYPE_CONTROLLEDLOAD; <br>    FlowSpec-&gt;MaxSduSize = QOS_NOT_SPECIFIED; <br>    FlowSpec-&gt;MinimumPolicedSize = QOS_NOT_SPECIFIED; <br> <br> <br>#if 0 <br>    // CallerId contains the socket address of the connecting entity. <br>    // Copy this into the connection-specific data. <br>    ConnData-&gt;RemoteSockAddr.len = CallerId-&gt;len; <br>    ConnData-&gt;RemoteSockAddr.buf = malloc(ConnData-&gt;RemoteSockAddr.len); <br>    if (ConnData-&gt;RemoteSockAddr.buf == NULL) { <br>        ChatSysError("malloc()", <br>                     "AcceptCondFunc()", <br>                     TRUE); <br>    } <br>    memcpy((char *)ConnData-&gt;RemoteSockAddr.buf, (char *)CallerId-&gt;buf, <br>           CallerId-&gt;len); <br> <br>    // Translate the RemoteSockAddr into a human readable form, and <br>    // store it in ConnData-&gt;PeerAddress <br>    GetAddressString(ConnData-&gt;PeerAddress, <br>                     ConnData-&gt;RemoteSockAddr.buf, <br>                     ConnData-&gt;RemoteSockAddr.len, <br>                     ConnData-&gt;ProtocolInfo); <br> <br>    Index = wsprintf(MsgText, "Someone is attempting a chat connection.\r\n"); <br> <br>    if (CallerData != NULL) { <br> <br>        // The connection request has come with some caller data.  Use <br>        // it to inform the user of who is trying to connect <br>        ExtractTwoStrings(CallerData-&gt;buf, <br>                          ConnData-&gt;PeerName, <br>                          NAME_LEN + 1, <br>                          ConnData-&gt;Subject, <br>                          SUB_LEN + 1); <br> <br>        // Build the strings for the message box and the title of the <br>        // connection window <br>        Index += wsprintf(MsgText + Index, <br>                 "From: %s\r\nSubject: %s\r\n", ConnData-&gt;PeerName, <br>                          ConnData-&gt;Subject); <br>        wsprintf(TitleText, "Connected to: %s @ %s", ConnData-&gt;PeerName, <br>                 ConnData-&gt;PeerAddress); <br> <br>    } else { <br> <br>        // There is no caller data...build a string for the title. <br>        wsprintf(TitleText, "Connected to: %s", ConnData-&gt;PeerAddress); <br>    } <br> <br>    // Continue building MsgText. <br>    Index += wsprintf(MsgText + Index, "Address: %s\r\n", <br>                      ConnData-&gt;PeerAddress); <br>    Index += wsprintf(MsgText + Index, "Would you like to accept it?"); <br> <br>    // Prompt the user to accept or reject the connection. <br>    // <br>    // ****NOTE**** <br>    // This is NOT the right way to do this.  The application should <br>    // not hold up this thread by putting up this message box, or the <br>    // dialog box below.  As mentioned in the API spec, this function <br>    // should  return "as soon as possible", and clearly this is not <br>    // what's being done here.  Please look to future versions of chat <br>    // for a fix.  Thanks. <br>    if (MessageBox(ConnData-&gt;ConnectionWindow, MsgText, <br>                   "Connection Request", <br>                   MB_ICONQUESTION | MB_YESNO | MB_SETFOREGROUND) == IDYES) { <br> <br>        // The user has accepted the connection request. <br>        SetWindowText(ConnData-&gt;ConnectionWindow, TitleText); <br>        if (CalleeData != NULL) { <br> <br>            // We can try to pass user data back. Call up a dialog box <br>            // to get a name string and put it into CalleeData. <br>            if (!DialogBoxParam(GlobalInstance, <br>                                "AcceptConnectionDlg", <br>                                ConnData-&gt;ConnectionWindow, <br>                                AcceptConnectionDlgProc, <br>                                (LPARAM)CalleeData)) { <br> <br>                CalleeData-&gt;len = 0; <br>            } <br>        } <br>        ReturnValue = CF_ACCEPT; <br> <br>    } // if (MessageBox(...)) <br>    else { <br> <br>        // The user has rejected the connection request. <br>        ReturnValue = CF_REJECT; <br>    } <br>#endif <br> <br>    return(ReturnValue); <br> <br>} // AcceptCondFunc() <br> <br> <br> <br> <br>  <br>BOOL <br>GetAddressString( <br>    OUT char            *String, <br>    IN  LPVOID          SockAddr, <br>    IN  int             SockAddrLen, <br>    IN  LPWSAPROTOCOL_INFO ProtocolInfo) <br>/*++ <br> <br>Routine Description: <br> <br>    This function translates the SockAddr into a human-readable <br>    string, if possible.  If chat doesn't recognize the protocol, then <br>    the string "(unknown)" is returned in String. <br> <br>Arguments: <br> <br>    String -- Returns the string representing the SockAddr in a <br>    human-readable form. <br> <br>    SockAddr -- An address. <br> <br>    SockAddrLen -- The length, in bytes, of SockAddr. <br> <br>    ProtocolInfo -- Pointer to the protocol information structure. <br> <br>Return Value: <br> <br>    TRUE -- Chat recognized the protocol family and successfully <br>    translated the address. <br> <br>    FALSE -- Chat did not recognize the protocol family and returned <br>    the string "(unknown)". <br> <br>--*/ <br>{ <br> <br>    char               *TempString;   // string returned by inet_ntoa <br>    struct sockaddr_in *SockAddrInet; // casts the address to a sockaddr_in <br>    BOOL               ReturnValue;   // holds the return value <br> <br>    ReturnValue = TRUE; <br> <br>    switch (ProtocolInfo-&gt;iAddressFamily) { <br> <br>    case AF_INET: <br> <br>        // It's an Internet-style address. <br>        SockAddrInet = (struct sockaddr_in *)SockAddr; <br>        TempString = inet_ntoa(SockAddrInet-&gt;sin_addr); <br>        if (TempString == NULL) { <br>            MessageBox(NULL, "inet_ntoa() failed.", "Error.", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        } else { <br>            strcpy(String, TempString); <br>        } <br>        ReturnValue = TRUE; <br>        break; <br> <br>    default: <br> <br>        strcpy(String, "(unknown)"); <br>        ReturnValue = FALSE; <br>        break; <br>    } <br>    return(ReturnValue); <br> <br>} // GetAddressString() <br> <br> <br> <br> <br>  <br>int <br>HandleEvents( <br>    IN PCONNDATA          ConnData, <br>    IN LPWSANETWORKEVENTS NetworkEvents) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Handles network events that may occur on a connected socket. <br>    The events handled by this function are FD_CLOSE, FD_READ, and <br>    FD_WRITE. <br> <br>Arguments: <br> <br>    ConnData - Supplies a pointer to data for the connection on which <br>    the event happened. <br> <br>    NetworkEvents - Supplies a WSANETWORKEVENT structure, which is a <br>    record of the network events that have occurred as well as any <br>    accompanying error-codes. <br> <br>Return Value: <br> <br>    CHAT_OK -- The network event was successfully handled. <br> <br>    CHAT_ERROR -- Some kind of error occurred while handling the <br>    event, and the connection should be closed. <br> <br>    CHAT_CLOSED -- The connection has been gracefully closed. <br> <br>--*/ <br> <br>{ <br>    int Result;                // holds the result of DoRecv <br>    int ReturnValue = CHAT_OK; // return value <br> <br>    // The following three if statements all execute unless one gets <br>    // an error or closed socket, in which case we return immediately. <br>    if (NetworkEvents-&gt;lNetworkEvents &amp; FD_READ) { <br> <br>        // An FD_READ event has occurred on the connected socket. <br>        if (NetworkEvents-&gt;iErrorCode[FD_READ_BIT] == WSAENETDOWN) { <br> <br>            // There is an error. <br>            ReturnValue = CHAT_ERROR; <br>            goto Done; <br> <br>        } else { <br> <br>            // Read data off the socket... <br>            Result = DoRecv(ConnData); <br>            if ((Result == CHAT_ERROR) || (Result == CHAT_CLOSED)) { <br>                ReturnValue = Result; <br>                goto Done; <br>            } <br>        } <br>    } <br> <br>    if (NetworkEvents-&gt;lNetworkEvents &amp; FD_WRITE) { <br> <br>        // An FD_WRITE event has occurred on the connected socket. <br>        if (NetworkEvents-&gt;iErrorCode[FD_WRITE_BIT] == WSAENETDOWN) { <br> <br>            // There is an error. <br>            ReturnValue = CHAT_ERROR; <br>            goto Done; <br> <br>        } else { <br> <br>            // Allow chat to send on this socket, and signal the <br>            // OuputEventObject in case there is pending output that is <br>            // not completed due to WSAEWOULDBLOCK. <br>            ConnData-&gt;WriteOk = TRUE; <br>            SetEvent(ConnData-&gt;OutputEventObject); <br>        } <br>    } <br> <br>    if (NetworkEvents-&gt;lNetworkEvents &amp; FD_CLOSE) { <br> <br>        if (NetworkEvents-&gt;iErrorCode[FD_CLOSE_BIT] == 0) { <br> <br>            // A graceful shutdown has occurred... <br>            ReturnValue = CHAT_CLOSED; <br>            goto Done; <br> <br>        } else { <br> <br>            // This is some other type of abortive close or failure... <br>            ReturnValue = CHAT_ABORTED; <br>            goto Done; <br>        } <br> <br>    } <br> <br>    if (NetworkEvents-&gt;lNetworkEvents &amp; FD_QOS) { <br> <br>        DWORD   BytesReturned; <br>        UCHAR   QosBuffer[ sizeof( QOS ) + sizeof( RSVP_STATUS_INFO )]; <br>        LPQOS   Qos; <br>        DWORD   status; <br>        LPRSVP_STATUS_INFO  RsvpStatus; <br> <br> <br>        // <br>        // get all of the QOS that may be queued up in the service provider, because we <br>        // just get one indication that there is QOS there, even though there could be more than <br>        // one QOS event queued. <br>        // <br>        status = NO_ERROR; <br>        while (status == NO_ERROR) { <br>            Qos = (LPQOS)QosBuffer; <br>            Qos-&gt;ProviderSpecific.len = sizeof( RSVP_STATUS_INFO ); <br>            Qos-&gt;ProviderSpecific.buf = (PUCHAR)(Qos +1); <br> <br> <br>            status = WSAIoctl( ConnData-&gt;Socket, <br>                               SIO_GET_QOS, <br>                               NULL, <br>                               0, <br>                               QosBuffer, <br>                               sizeof( QosBuffer ), <br>                               &amp;BytesReturned, <br>                               NULL, <br>                               NULL ); <br> <br> <br>            if (status == NO_ERROR) { <br>                LPFLOWSPEC  Flow; <br> <br>                RsvpStatus = (LPRSVP_STATUS_INFO)Qos-&gt;ProviderSpecific.buf; <br>                if (Qos-&gt;SendingFlowspec.ServiceType == SERVICETYPE_NOTRAFFIC) { <br>                    Flow = &amp;Qos-&gt;ReceivingFlowspec; <br>                } else { <br>                    Flow = &amp;Qos-&gt;SendingFlowspec; <br>                } <br>#if 0 <br>                wsprintf(MsgText, "QOS code = %d, Rate = %d Bucket = %d \n", <br>                         RsvpStatus-&gt;StatusCode, <br>                         Flow-&gt;TokenRate, <br>                         Flow-&gt;TokenBucketSize); </code></pre>
<p>
</p>
<pre><code><br>                // <br>                // Output the received text into the receive edit control. <br>                // <br>OutputString(ConnData-&gt;RecvWindow, MsgText); <br>#endif <br>            } <br>        } <br> <br> <br>    } <br> <br> Done: <br>    return(ReturnValue); <br> <br>} // HandleEvents() <br> <br> <br> <br> <br>  <br>DWORD <br>IOThreadFunc( <br>    IN LPVOID ParamPtr) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine is invoked as a separate thread to handle all input <br>    and output for a connection. <br> <br>Implementation: <br> <br>    This thread sits in a loop, waiting for one of several things to <br>    occur.  These can be: <br> <br>        1. The user interface thread has some input ready to be sent, <br>        and has signaled the ouput event object. <br> <br>        2. WinSock 2 has indicated there is a network event associated <br>        with the socket. <br> <br>        3. Callback notification.  This can be via an event or via a <br>        queued callback function, depending on whether or not we've <br>        compiled with the CALLBACK_NOTIFICATION flag. <br> <br>    The return value from the wait indicates what has <br>    happened, and a switch statement handles all the possible cases. <br>    When there is an error or the connection is being closed, the loop <br>    is broken and the thread will exit and the connection window will <br>    be closed (and sent a WM_DESTROY message). <br> <br>Arguments: <br> <br>    ParamPtr - Supplies a pointer to a ConnData structure that holds <br>    data specific to this connection. <br> <br>Return Value: <br> <br>    0 - Always returns 0.  The return value is not needed. <br> <br>--*/ <br>{ <br>    char             MsgText[MSG_LEN]; // holds message strings <br>    DWORD            WaitStatus;       // holds return value of the wait <br>    PCONNDATA        ConnData;         // connection-specific data <br>    BOOL             KeepGoing = TRUE; // keep processing output requests? <br>    BOOL             Forever = TRUE;   // constant to avoid warning <br> <br>    ConnData =  (PCONNDATA)ParamPtr; <br> <br>    // Initialize the EventArray.  The only two events in it, for now, <br>    // are the Socket and Ouput events; if this is the event <br>    // notification version of chat, then there will be an additional <br>    // event for each overlapped send waiting for a completion <br>    // notification. <br>    ConnData-&gt;NumEvents = 3; <br>    ConnData-&gt;EventArray[0] = ConnData-&gt;SocketEventObject; <br>    ConnData-&gt;EventArray[1] = ConnData-&gt;OutputEventObject; <br>    ConnData-&gt;EventArray[2] = ConnData-&gt;ThreadTerminationEvent; <br> <br>    // Initialize the array of output requests, which is indexed in <br>    // parallel to the above event array.  When an event is signaled, <br>    // we can figure out which output request and overlapped <br>    // structures to free by indexing into this array. <br>    // These first two entries should never be referenced, because <br>    // their parallel entries in EventArray (see above) are for the <br>    // permanent Socket and Output event objects. <br>    ConnData-&gt;OutReqArray[0] = ConnData-&gt;OutReqArray[1] = NULL; <br> <br>    while (Forever) { <br> <br>        // Wait for an event (or a queued callback function) to wake <br>        // us up.  This is an alertable wait state (fAlertable == TRUE). <br>        WaitStatus = WSAWaitForMultipleEvents(ConnData-&gt;NumEvents, <br>                                              ConnData-&gt;EventArray, <br>                                              FALSE,        // fWaitAll <br>                                              WSA_INFINITE, // dwTimeout <br>                                              TRUE);        // fAlertable <br> <br>        // Determine why we woke up and act accordingly.  Note that <br>        // breaking out of the switch causes us to break out of the <br>        // while loop as well.  When we don't want to break out of the <br>        // loop, case statements end with the continue statement. <br>        switch (WaitStatus) { <br> <br>        case WSA_WAIT_FAILED: <br> <br>            // A fatal error.  Pop up a message box and break out of <br>            // the while loop to end the thread. <br> <br>            wsprintf(MsgText, <br>                     "WSAWaitForMultipleEvents() failed.  Error code: %d", <br>                     WSAGetLastError()); <br>            MessageBox(ConnData-&gt;ConnectionWindow, MsgText, "Fatal Error", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            break; <br> <br>        case WAIT_IO_COMPLETION: <br> <br>            // An I/O completion routine has been executed.  Cleanup <br>            // has already occurred in SendCompFunc, so there is <br>            // nothing left to do.  Just reiterate through the loop. <br> <br>            continue; <br> <br>        case WSA_WAIT_EVENT_0: <br> <br>            // <br>            // the socket is closing if the socketevent is null <br>            // <br>            if (ConnData-&gt;SocketEventObject == NULL) { <br>                break; <br>            } <br>            // The SocketEventObject has been signaled.  Handle it in <br>            // a separate function.  Break out of the thread if <br>            // HandleSocketEvent returns FALSE, indicating error. <br>            if (HandleSocketEvent(ConnData)) { <br>                continue; <br>            } else { <br>                break; <br>            } <br> <br>        // Please note: WSA_WAIT_EVENT_[1,2,3] are defined in <br>        // chatsock.h, not winsock2.h like WSA_WAIT_EVENT_0 <br> <br>        case WSA_WAIT_EVENT_1: <br> <br>            // The OuputEventObject has been signaled.  Handle it in a <br>            // separate function, and break out of the thread if it <br>            // returns FALSE <br>            if (HandleOutputEvent(ConnData)) { <br>                continue; <br>            } else { <br>                break; <br>            } <br> <br>        case WSA_WAIT_EVENT_2: <br>            CloseHandle( ConnData-&gt;ThreadTerminationEvent ); <br>            if (InterlockedDecrement( &amp;ConnData-&gt;RefCount ) == 0) { <br>                free( ConnData ); <br>            } <br>            return( 0 ); <br>            break; <br> <br>        default: <br> <br>            // Some other event has been signaled.  Handle it in a <br>            // separate function, and break out of the thread if it <br>            // returns FALSE. <br>            if (HandleOtherEvent(WaitStatus, ConnData)) { <br>                continue; <br>            } else { <br>                break; <br>            } <br> <br>        } // switch (WaitStatus) <br> <br>        // Break out of the while loop. <br>        break; <br> <br>    } // while (1) <br> <br>    // Thread is ending because the connection was closed or an error <br>    // occurred <br>    PostMessage(ConnData-&gt;ConnectionWindow, <br>                WM_CLOSE, <br>                0, <br>                0); <br> <br>    CloseHandle( ConnData-&gt;ThreadTerminationEvent ); <br> <br>    ConnData-&gt;ThreadTerminationEvent = NULL; <br> <br>    if (InterlockedDecrement( &amp;ConnData-&gt;RefCount ) == 0) { <br>        free( ConnData ); <br>    } <br> <br>    return(0); <br> <br>} // IOThreadFunc() <br> <br> <br> <br> <br>  <br>BOOL <br>HandleSocketEvent( <br>    IN OUT PCONNDATA ConnData) <br>/*++ <br> <br>Routine Description: <br> <br>    Handles the case in IOThreadFunc where the thread is woken up by a <br>    signal to the socket event object. <br> <br>Arguments: <br> <br>    ConnData - Supplies a pointer to data for the connection on which <br>    the event happened. <br> <br>Return Value: <br> <br>    TRUE -- Chat successfully handled the event and the thread should <br>    continue on. <br> <br>    FALSE -- An error occurred and Chat should kill the thread and the <br>    connection. <br> <br>--*/ <br>{ <br>    int              Result;           // holds return values <br>    WSANETWORKEVENTS NetworkEvents;    // tells us what events happened <br>    char             MsgText[MSG_LEN]; // holds text strings <br>    BOOL             ReturnValue;      // holds the return value <br> <br>    // Find out what happened and act accordingly. <br>    Result = WSAEnumNetworkEvents(ConnData-&gt;Socket, <br>                                  ConnData-&gt;SocketEventObject, <br>                                  &amp;NetworkEvents); <br>    if (Result == SOCKET_ERROR) { <br> <br>        // Handle the fatal error. <br>        wsprintf(MsgText, <br>                 "WSAEnumNetworkEvents failed.  Error code: %d", <br>                 WSAGetLastError()); <br>        MessageBox(GlobalFrameWindow, MsgText, "Fatal Error", <br>                   MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        ReturnValue = FALSE; <br> <br>    } else { <br> <br>        // Handle all of the network events on the given socket <br>        Result = HandleEvents(ConnData, &amp;NetworkEvents); <br> <br>        if (Result == CHAT_CLOSED) { <br> <br>            // <br>            // don't put up a pop up if we are running with command line args since we <br>            // want it to be automated in that case <br>            // <br>            if (LocalPort == 0) { <br>                // HandleEvents() has determined that the remote party <br>                // has terminated the connection.  Inform the user, and <br>                // return. <br>                if (ConnData-&gt;PeerName[0] != 0) { <br>                    wsprintf(MsgText, <br>                             "%s @ %s has terminated the connection.", <br>                             ConnData-&gt;PeerName, ConnData-&gt;PeerAddress); <br>                } else { <br>                    wsprintf(MsgText, <br>                             "The party at %s has terminated the connection.", <br>                             ConnData-&gt;PeerAddress); <br>                } <br>                MessageBox(ConnData-&gt;ConnectionWindow, MsgText, "Sorry!", <br>                           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            } <br>            ReturnValue = FALSE; <br> <br>        } else if (Result == CHAT_ABORTED) { <br> <br>            // HandleEvents has determined that the connection has <br>            // been aborted due to an undetermined error. <br>            MessageBox(ConnData-&gt;ConnectionWindow, <br>                       "The connection has been broken.", <br>                       "Connection aborted.", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            ReturnValue = FALSE; <br> <br>        } else if (Result == CHAT_ERROR) { <br> <br>            // HandleEvents() has returned an error.  Inform the <br>            // user and break to exit the thread and kill the window. <br>            MessageBox(ConnData-&gt;ConnectionWindow, <br>                       "An unidentified network or system error occurred.", <br>                       "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            ReturnValue = FALSE; <br> <br>        } else if (Result == CHAT_OK) { <br> <br>            // Inform the caller that everything went fine. <br>            ReturnValue = TRUE; <br> <br> <br>        } else { <br> <br>            // This case should only occur if there is a <br>            // programming error.  Break out of the while loop to <br>            // kill the thread, the window, and therefore the <br>            // connection. <br>            MessageBox(ConnData-&gt;ConnectionWindow, <br>                       "HandleEvents() returned an unexpected value.", <br>                       "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            ReturnValue = FALSE; <br>        } <br>    } <br> <br>    return(ReturnValue); <br> <br>} // HandleSocketEvent() <br> <br> <br> <br> <br>  <br>BOOL <br>HandleOutputEvent( <br>    IN OUT PCONNDATA ConnData) <br>/*++ <br> <br>Routine Description: <br> <br>    Handles the case in IOThreadFunc where the thread is woken up by a <br>    signal to the output event object. <br> <br>Arguments: <br> <br>    ConnData - Supplies a pointer to data for the connection on which <br>    the event happened. <br> <br>Return Value: <br> <br>    TRUE -- Chat successfully handled the event and the thread should <br>    continue on. <br> <br>    FALSE -- An error occurred and Chat should kill the thread and the <br>    connection. <br> <br>--*/ <br>{ <br>    BOOL            ReturnValue; // holds the return value <br>    BOOL            KeepGoing;   // keep pulling requests off the queue? <br>    POUTPUT_REQUEST OutReq;      // pointer to the output request <br>    int             Result;      // holds results of functions <br> <br>    ReturnValue = TRUE; <br> <br>    // First we check to see if a previous send attempt failed with <br>    // WSAEWOULDBLOCK; if so, we don't have to bother trying to send <br>    // data until we get an FD_WRITE network event, so just return <br>    // with TRUE to indicate that the thread should wait again. <br>    if (ConnData-&gt;WriteOk) { <br> <br>        // This loop pulls output requests off the queue and hands <br>        // them to DoSend. <br>        KeepGoing = TRUE; <br>        while (KeepGoing) { <br> <br>            OutReq = (POUTPUT_REQUEST)QRemove(ConnData-&gt;OutputQueue); <br>            if (OutReq == NULL) { <br> <br>                // Nothing is left on the queue. <br>                KeepGoing = FALSE; <br>                ReturnValue = TRUE; <br> <br>            } else { <br> <br>                // Do the output <br>                Result = DoSend(OutReq, ConnData); <br>                if (Result == CHAT_WOULD_BLOCK) { <br> <br>                    // The send would have blocked; we need to <br>                    // requeue the output request and wait for an <br>                    // FD_WRITE network event. <br>                    KeepGoing = FALSE; <br>                    QInsertAtHead(ConnData-&gt;OutputQueue, (LPVOID)OutReq); <br>                    ReturnValue = TRUE; <br> <br>                } else if (Result == CHAT_ERROR) { <br> <br>                    // An error occurred in DoSend.  Set KeepGoing to <br>                    // FALSE in order to get us out of the loop. <br>                    KeepGoing = FALSE; <br>                    ReturnValue = FALSE; <br>                    MessageBox(ConnData-&gt;ConnectionWindow, <br>                               "Error sending data.", <br>                               "Error.", <br>                               MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br> <br>                } else { <br> <br>                    // DoSend returned CHAT_OK.  Keep looping. <br>                    continue; <br>                } <br>            } <br>        } // while (KeepGoing) <br>    } // if (ConnData-&gt;WriteOk) <br> <br>    return(ReturnValue); <br> <br>} // HandleOutputEvent() <br> <br> <br> <br> <br>  <br>BOOL <br>HandleOtherEvent( <br>    IN     DWORD     WaitStatus, <br>    IN OUT PCONNDATA ConnData) <br>/*++ <br> <br>Routine Description: <br> <br>    Handles the case in IOThreadFunc where the thread is woken up by <br>    an event that is either an overlapped I/O event or was not <br>    specified in the event array (which is an error!). <br> <br>Arguments: <br> <br>    WaitStatus -- Supplies the value returned by <br>    WSAWaitForMultipleEvents. <br> <br>    ConnData - Supplies a pointer to data for the connection on which <br>    the event happened. <br> <br>Return Value: <br> <br>    TRUE -- Chat successfully handled the event and the thread should <br>    continue on. <br> <br>    FALSE -- An error occurred and Chat should kill the thread and the <br>    connection. <br> <br>--*/ <br>{ <br>    POUTPUT_REQUEST OutReq;           // points to an output request <br>    BOOL            ReturnValue;      // holds the return value <br>    DWORD           Count;            // counting variable <br>    char            MsgText[MSG_LEN]; // holds message strings <br> <br>    // First do a sanity check to make sure the index returned is <br>    // within the bounds of what WE think is the event array. <br>    if ((WaitStatus &gt;= WSA_WAIT_EVENT_0) &amp;&amp; <br>        (WaitStatus &lt;= (WSA_WAIT_EVENT_0  + ConnData-&gt;NumEvents - 1))) { <br> <br>        // Free the data buffer, the overlapped structure, the output <br>        // request itself, and the event <br>        OutReq = ConnData-&gt;OutReqArray[WaitStatus - WSA_WAIT_EVENT_0]; <br>        free(OutReq-&gt;Buffer.buf); <br>        free(OutReq-&gt;Overlapped); <br>        free(OutReq); <br>        CloseHandle(ConnData-&gt;EventArray[WaitStatus - WSA_WAIT_EVENT_0]); <br> <br>        // Update all our event and output request arrays to <br>        // reflect that the overlapped send has completed. <br>        ConnData-&gt;NumEvents--; <br>        for (Count = (WaitStatus - WSA_WAIT_EVENT_0); <br>             Count &lt; ConnData-&gt;NumEvents; <br>             Count++) { <br>            ConnData-&gt;EventArray[Count] = ConnData-&gt;EventArray[Count + 1]; <br>            ConnData-&gt;OutReqArray[Count] = ConnData-&gt;OutReqArray[Count + 1]; <br>        } <br>        ReturnValue = TRUE; <br> <br>    } else { <br> <br>        // WSAWaitForMultipleEvents returned an unexpected <br>        // value... <br>        wsprintf(MsgText, "WSAWaitForMultipleEvents() returned %d.", <br>                 WaitStatus); <br>        MessageBox(GlobalFrameWindow, MsgText, "Error.", <br>                   MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        ReturnValue = FALSE; <br>    } <br> <br>    return(ReturnValue); <br> <br>} // HandleOtherEvent() <br> <br> <br> <br> <br>  <br>void <br>HandleAcceptMessage( <br>    IN HWND   ConnectionWindow, <br>    IN SOCKET Socket, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Handles the reception of a USMSG_ACCEPT message, which indicates a <br>    connection attempt is incoming. <br> <br>Implementation: <br> <br>    This function lets the user decide whether to accept the <br>    connection; if he or she does, the function  initializes <br>    connection-specific data, calls WSAEventSelect to register <br>    interest in certain network events, and starts a network event <br>    handling thread. <br> <br>Arguments: <br> <br>    ConnectionWindow -- Handle to the connection window associated <br>    with this connection request. <br> <br>    Socket -- Contains the handle to the listening socket to which the <br>    connection request has been made. <br> <br>    LParam -- The LParam that was delivered with the USMSG_ACCEPT <br>    message; contains the error code. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br> <br>    int       Error;            // gets error code if necessary <br>    char      MsgText[MSG_LEN]; // holds message strings <br>    DWORD     ThreadId;         // needed for CreateThread <br>    PCONNDATA ConnData;         // connection-specific data <br> <br>    ConnData = GetConnData(ConnectionWindow); <br> <br>    Error = WSAGETSELECTERROR(LParam); <br> <br>    // Check to see if there was an error on the connection attempt. <br>    if (Error) { <br> <br>        // Some kind of error occurred. <br>        if (Error == WSAENETDOWN) { <br>            MessageBox(ConnectionWindow, <br>                       "The network is down!", "Uh-oh", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        } else { <br>            MessageBox(ConnectionWindow, <br>                       "Unknown error on FD_ACCEPT", "Error", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        } <br>        goto Fail; <br>    } <br> <br>    // Get a pointer to the associated protocol information structure <br>    // for the socket we are listening on (Socket). This will be the <br>    // same as the protocol info for the new socket.  Note that we <br>    // could have allocated a new buffer and called getsockopt with <br>    // the SO_PROTOCOL_INFO option.  But since we've already allocated <br>    // the memory, this way is more efficient. <br>    ConnData-&gt;ProtocolInfo = GetProtoFromSocket(Socket); <br>    assert(ConnData-&gt;ProtocolInfo != NULL); <br> <br>    // Accept the connection (this calls AcceptCondFunc, of course, <br>    // before actually accepting the connection). <br>    { <br>        WSABUF SockAddrBuf; <br> <br>        SockAddrBuf.len = ConnData-&gt;ProtocolInfo-&gt;iMaxSockAddr; <br>        SockAddrBuf.buf = (char *)malloc(SockAddrBuf.len); <br>#if 0 <br>        ConnData-&gt;Socket = WSAAccept(Socket, <br>                                     (struct sockaddr *)SockAddrBuf.buf, <br>                                     &amp;SockAddrBuf.len, <br>                                     NULL, <br>                                     (DWORD)NULL); <br>#endif <br>         ConnData-&gt;Socket = WSAAccept(Socket, <br>                                      NULL, <br>                                      NULL, <br>                                      AcceptCondFunc, <br>                                      (DWORD)ConnData); <br>    } <br> <br>    if (ConnData-&gt;Socket == INVALID_SOCKET) { <br> <br>        // WSAAccept failed -- inform the user and that's all. <br>        Error = WSAGetLastError(); <br>        if (Error != WSAECONNREFUSED) { <br> <br>            // An unexpected error code. <br>            wsprintf(MsgText, "WSAAccept failed.  Error code: %d", <br>                     Error); <br>            MessageBox(ConnectionWindow, MsgText, "Error", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            goto Fail; <br> <br>        } else { <br> <br>            // AcceptCondFunc returned CF_REJECT... <br>            MessageBox(GlobalFrameWindow, <br>                       "The connection attempt has been refused.", <br>                       "Connection refused.", MB_OK | MB_SETFOREGROUND); <br>            goto Fail; <br>        } <br>    } <br> <br>    if (!UseAsyncSelect) { <br>        // Put Connection in Event Object Notification Mode. <br>        WSAEventSelect(ConnData-&gt;Socket, <br>                       ConnData-&gt;SocketEventObject, <br>                       FD_READ | FD_WRITE | FD_CLOSE | FD_QOS); <br>    } else { <br>        // Put Connection in Event Object Notification Mode. <br>        WSAAsyncSelect(ConnData-&gt;Socket, <br>                       ConnectionWindow, <br>                       USMSG_QOS, <br>                       FD_READ | FD_WRITE | FD_CLOSE | FD_QOS); <br> <br>    } <br> <br>    // Determine the maximum message size, if any. <br>    if (!GetMaxMsgSize(ConnData)) { <br>        goto Fail; <br>    } <br> <br>    // Start the I/O thread, and save the thread handle. <br>    ConnData-&gt;IOThreadHandle = <br>      CreateThread(NULL, <br>                   0, <br>                   (LPTHREAD_START_ROUTINE)IOThreadFunc, <br>                   ConnData, <br>                   0, <br>                   &amp;ThreadId); <br>    if (ConnData-&gt;IOThreadHandle == NULL) { <br>        ChatSysError("CreateThread()", <br>                     "HandleAcceptMessage()", <br>                     TRUE); <br>    } <br> <br>    return; <br> <br> Fail: <br> <br>    DestroyWindow(ConnectionWindow); <br>    return; <br> <br>} // HandleAcceptMessage() <br> <br> <br> <br> <br>  <br>void <br>HandleConnectMessage( <br>    IN HWND   ConnectionWindow, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Handles the reception of a USMSG_CONNECT message, which indicates <br>    a connection attempt is complete (though not necessarily <br>    successful). <br> <br>Implementation: <br> <br>    As with HandleAcceptMessages, this function initializes <br>    connection-specific data, calls WSAEventSelect to register <br>    interest in certain network events, and starts a network event <br>    handling thread. <br> <br>Arguments: <br> <br>    ConnectionWindow -- Handle to the connection window associated <br>    with this connection request. <br> <br>    LParam -- Contains the LParam that was a parameter of the <br>    USMSG_CONNECT message. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br> <br>    PCONNDATA ConnData;               // connection-specific data <br>    char      TitleText[TITLE_LEN];   // text buffer for window title <br>    DWORD     ThreadId;               // needed for CreateThread() <br>    int       Error;                  // holds error codes <br> <br>    Error = WSAGETSELECTERROR(LParam); <br> <br>    // Check to see if there was an error on the connection attempt. <br>    if (Error) { <br> <br>        // Some kind of error occurred. <br>        if (Error == WSAECONNREFUSED) { <br> <br>            MessageBox(ConnectionWindow, <br>                       "Your connection attempt has been refused", <br>                       "Connection Refused", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        } else { <br> <br>            MessageBox(ConnectionWindow, <br>                       "Couldn't connect", <br>                       "Error", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        } <br> <br>        goto Fail; <br> <br>    } <br> <br>    // Connection has been accepted.  Change the title of the <br>    // connection window to reflect who the user has connected to <br>    ConnData = GetConnData(ConnectionWindow); <br> <br>    if (ConnData-&gt;CalleeBuffer.len != 0) { <br> <br>        // The callee buffer contains the connection-time data <br>        // sent by the callee. -- a string containing the name of <br>        // the callee. <br>        wsprintf(TitleText, "Connected To: %s @ %s", <br>                 ConnData-&gt;CalleeBuffer.buf, ConnData-&gt;PeerAddress); <br>    } else { <br> <br>        // ConnData-&gt;PeerAddress just contains the address that <br>        // the user typed in before the connection attempt. <br>        wsprintf(TitleText, "Connected To: %s", ConnData-&gt;PeerAddress); <br>    } <br>    SetWindowText(ConnectionWindow, TitleText); <br> <br>    // Put Connection in Event Object Notification Mode. <br>    WSAEventSelect(ConnData-&gt;Socket, <br>                   ConnData-&gt;SocketEventObject, <br>                   FD_READ | FD_WRITE | FD_CLOSE | FD_QOS); <br> <br>    // Determine the maximum message size, if any. <br>    if (!GetMaxMsgSize(ConnData)) { <br>        goto Fail; <br>    } <br> <br>    // Start the I/O thread, and save the thread handle. <br>    ConnData-&gt;IOThreadHandle = <br>      CreateThread(NULL, <br>                   0, <br>                   (LPTHREAD_START_ROUTINE)IOThreadFunc, <br>                   ConnData, <br>                   0, <br>                   &amp;ThreadId); <br>    if (ConnData-&gt;IOThreadHandle == NULL) { <br>        ChatSysError("CreateThread()", <br>                     "HandleConnectMessage()", <br>                     TRUE); <br>    } <br> <br>    return; <br> <br> Fail: <br> <br>    DestroyWindow(ConnectionWindow); <br>    return; <br> <br>} // HandleConnectMessage() <br> <br> <br> <br> <br>  <br>BOOL <br>GetMaxMsgSize( <br>    IN OUT PCONNDATA ConnData) <br>/*++ <br> <br>Routine Description: <br> <br>    Determines the maximum message size (if any) of a connected <br>    socket.  The connection must already be established, i.e. the <br>    socket must be bound to a local address, for this function to <br>    work.  Fills the correct value into a field of the <br>    connection-specific data. <br> <br>Arguments: <br> <br>    ConnData -- Connection data for a connected socket. <br> <br>Return Value: <br> <br>    TRUE -- The maximum message size was succesfully determined and <br>    stored in ConnData-&gt;MaxMsgSize. <br> <br>    FALSE -- There was an error calling getsockopt to get the maximum <br>    message size. <br> <br>--*/ <br>{ <br>    BOOL ReturnValue = TRUE;       // return value <br>    int  DwordLen = sizeof(DWORD); // sizeof a DWORD! <br>    int  Error;                    // return value of getsockopt <br> <br>    if ((ConnData-&gt;ProtocolInfo-&gt;dwMessageSize == 0) || <br>        (ConnData-&gt;ProtocolInfo-&gt;dwMessageSize == 0xffffffff)) { <br> <br>        // Either the protocol isn't message-oriented, or there is no <br>        // maximum message size. <br>        ConnData-&gt;MaxMsgSize = NO_MAX_MSG_SIZE; <br> <br>    } else { <br> <br>        // There is a maximum message size.  Note it. <br>        if (ConnData-&gt;MaxMsgSize == 0x1) { <br> <br>            // The actual maximum message size was not stored in the <br>            // protocol information structure -- rather, we need to <br>            // get it using getsockopt(). <br>            Error = getsockopt(ConnData-&gt;Socket, <br>                               SOL_SOCKET, <br>                               SO_MAX_MSG_SIZE, <br>                               (char *)&amp;ConnData-&gt;MaxMsgSize, <br>                               &amp;DwordLen); <br>            if (Error) { <br>                ReturnValue = FALSE; <br>            } <br> <br>        } // if (ConnData-&gt;MaxMsgSize == 0x1) <br>        else { <br> <br>            // The message size is stored in the protocol information <br>            // structure.  Use it. <br>            ConnData-&gt;MaxMsgSize = ConnData-&gt;ProtocolInfo-&gt;dwMessageSize; <br>        } <br> <br> <br>    } // else <br> <br>    return(ReturnValue); <br> <br>} // GetMaxMsgSize() <br> <br> <br> <br> <br>  <br>BOOL <br>IsSendable( <br>    char Char) <br>/*++ <br> <br>Routine Description: <br> <br>    Determines whether a certain character value is ok to send over <br>    the socket to the far end.  Eliminates most non-printable <br>    characters except for newline and backspace. <br> <br>Arguments: <br> <br>    Char -- Supplies the character to be tested. <br> <br>Return Value: <br> <br>    TRUE -- The character should be sent as is. <br> <br>    FALSE -- The character should not be sent. <br> <br>--*/ <br>{ <br> <br>    if (isprint(Char) || (Char == '\b') || (Char == '\r')) { <br>        return(TRUE); <br>    } else { <br>        return(FALSE); <br>    } <br> <br>} // IsSendable() <br> <br> <br> <br> <br>  <br>int <br>DoRecv( <br>    IN PCONNDATA ConnData) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Receives as much available data as possible up to the size of the <br>    receive buffer-1 (BUFFER_LENGTH-1).  A single byte is reserved at <br>    the end of the receive buffer to append a terminating NULL. <br> <br>Arguments: <br> <br>    ConnData -- Points to the data for the connection that is ready to <br>    receive data. <br> <br>Return Value: <br> <br>    CHAT_OK -- Received data was successfully sent to the receive edit <br>           control. <br> <br>    CHAT_ERROR -- Error receiving data. <br> <br>    CHAT_CLOSED -- The socket was gracefully closed. <br> <br>--*/ <br> <br>{ <br>    DWORD  NumBytes;               // stores how many bytes we received <br>    int    Error;                  // gets error values <br>    int    Result;                 // gets return value from WSARecv <br>    char   Buf[BUFFER_LENGTH];     // buffer to receive data <br>    int    ReturnValue = CHAT_OK;  // returnValue <br>    WSABUF RecvBuffer;             // WSABuf to pass to WSARecv <br>    DWORD  Flags = 0;              // flags for WSARecv <br> <br>    RecvBuffer.buf = Buf; <br>    RecvBuffer.len = BUFFER_LENGTH - 1; <br> <br>    // Do the receive <br>    Result = WSARecv(ConnData-&gt;Socket, <br>                     &amp;RecvBuffer, <br>                     1, <br>                     &amp;NumBytes, <br>                     &amp;Flags, <br>                     NULL, <br>                     NULL); <br> <br>    // Check for errors. <br>    if (Result == SOCKET_ERROR) { <br> <br>        Error = WSAGetLastError(); <br> <br>        switch (Error) { <br> <br>        case WSAENETRESET:  // flow through <br>        case WSAECONNRESET: <br> <br>            // The remote party has reset the connection. <br>            ReturnValue = CHAT_CLOSED; </code></pre>
<p>
</p>
<pre><code>goto Done; <br> <br>        case WSAEWOULDBLOCK: <br> <br>            // No data received; return to wait for another read event. <br>            ReturnValue = CHAT_OK; <br> <br>        default: <br> <br>            // Some other error...hit the panic button. <br>            ReturnValue = CHAT_ERROR; <br>            goto Done; <br>        } <br> <br>    } <br> <br>    // Append a NULL to the text buffer. <br>    RecvBuffer.buf[NumBytes] = '\0'; <br> <br>    // Output the received text into the receive edit control. <br>    OutputString(ConnData-&gt;RecvWindow, RecvBuffer.buf); <br> <br> Done: <br>    return(ReturnValue); <br> <br>} // DoRecv() <br> <br> <br> <br> <br>  <br>int <br>DoOverlappedCallbackSend( <br>    IN POUTPUT_REQUEST OutReq, <br>    IN PCONNDATA       ConnData) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Sends a buffer of data over a connected socket using overlapped <br>    I/O with callback function completion notification. <br> <br>Implementation: <br> <br>    This function just does an overlapped send, giving WinSock 2 a <br>    completion function which will be called when the operation has <br>    finished, and within which cleanup will occur. <br> <br>Arguments: <br> <br>    OutReq -- Points to a OUTPUT_REQUEST structure, which specifies an <br>    output request. <br> <br>    ConnData -- Supplies a pointer to a CONNDATA structure, which <br>    identifies a Chat connection. <br> <br>Return Value: <br> <br>    CHAT_WOULD_BLOCK -- The send operation failed with WSAEWOULDBLOCK. <br> <br>    CHAT_ERROR -- A unexpected error occurred. <br> <br>    CHAT_OK -- The send was successfully initiated. WinSock 2 will <br>    execute the callback function when the send has completed. <br> <br>--*/ <br> <br>{ <br>    int             Size = 0;      // how many bytes we send <br>    int             Error;         // return value of WSASend <br>    int             Errno;         // result of WSAGetLastError <br>    LPWSABUF        Buffers;       // points to an array of WSABUFs <br>    DWORD           BytesSent;     // needed in WSASend <br>    int             ReturnValue;   // the return value <br> <br>    ReturnValue = CHAT_OK; <br> <br>    // Allocate an OVERLAPPED structure. <br>    OutReq-&gt;Overlapped = (LPWSAOVERLAPPED)malloc(sizeof(WSAOVERLAPPED)); <br>    if (OutReq-&gt;Overlapped == NULL) { <br>        ChatSysError("malloc()", <br>                     "DoOverlappedCallbackSend()", <br>                     TRUE); <br>    } <br>    Buffers = &amp;OutReq-&gt;Buffer; <br> <br>    // The hEvent field of the Overlapped structure is not used <br>    // for callback notification...thus we can use it any way we <br>    // want to pass information to the callback routine.  We use <br>    // it to store a pointer to the OutReq associated with this <br>    // overlapped send operation, so the callback function can <br>    // free the memory. <br>    OutReq-&gt;Overlapped-&gt;hEvent = (WSAEVENT)OutReq; <br> <br>    Error = WSASend(ConnData-&gt;Socket, <br>                    Buffers, <br>                    1, <br>                    &amp;BytesSent, <br>                    0, <br>                    OutReq-&gt;Overlapped, <br>                    SendCompFunc); <br> <br>    if (Error == SOCKET_ERROR) { <br> <br>        // There is an error... <br>        Errno = WSAGetLastError(); <br>        if (Errno == WSAEWOULDBLOCK) { <br> <br>            // WSAEWOULDBLOCK means we have to wait for an FD_WRITE <br>            // before we can send. <br>            ConnData-&gt;WriteOk = FALSE; <br>            ReturnValue = CHAT_WOULD_BLOCK; <br> <br>        } else if (Errno == WSA_IO_PENDING) { <br> <br>            // Overlapped send successfully initiated. <br>            ReturnValue = CHAT_OK; <br>        } <br>        else { <br> <br>            // An unexpected error occurred. <br>            ReturnValue = CHAT_ERROR; <br>        } <br> <br>    } <br> <br>    // No error -- the I/O request was completed immediately... <br>    return(ReturnValue); <br> <br>} // DoOverlappedCallbackSend() <br> <br> <br> <br> <br>  <br>int <br>DoOverlappedEventSend( <br>    IN POUTPUT_REQUEST OutReq, <br>    IN PCONNDATA       ConnData) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Sends a buffer of data over a connected socket using overlapped <br>    I/O with event notification. <br> <br>Implementation: <br> <br>    If the overlapped send is succesfully initiated, this function <br>    increases the event count and adds an entry to the event array of <br>    the associated connection.  During IOThreadFunc, the thread will <br>    thus wait on the new event as well, and will perform the <br>    appropriate cleanup action when awoken. <br> <br>Arguments: <br> <br>    OutReq -- Points to a OUTPUT_REQUEST structure, which specifies an <br>    output request. <br> <br>    ConnData -- Supplies a pointer to a CONNDATA structure, which <br>    identifies a Chat connection. <br> <br>Return Value: <br> <br>    CHAT_WOULD_BLOCK -- The send operation failed with WSAEWOULDBLOCK. <br> <br>    CHAT_ERROR -- A unexpected error occurred. <br> <br>    CHAT_OK -- The send was successfully initiated and the new event <br>    placed in the event array; it will be signaled by WinSock 2 when <br>    the send operation has completed. <br> <br>--*/ <br> <br>{ <br>    int             Size = 0;      // how many bytes we send <br>    int             Error;         // return value of WSASend <br>    int             Errno;         // result of WSAGetLastError <br>    LPWSABUF        Buffers;       // points to an array of WSABUFs <br>    DWORD           BytesSent;     // needed in WSASend <br>    int             ReturnValue;   // the return value <br> <br>    ReturnValue = CHAT_OK; <br> <br>    // Allocate an OVERLAPPED structure. <br> <br>    // Note that the pointer to an overlapped structure is kept in <br>    // OutReq.  We use an array of OutReq pointers that is parallel to <br>    // the event array.  With that one pointer, then, we can find the <br>    // associated Overlapped structure and free it, and then free the <br>    // OutReq structure itself. <br>    OutReq-&gt;Overlapped = (LPWSAOVERLAPPED)malloc(sizeof(WSAOVERLAPPED)); <br>    if (OutReq-&gt;Overlapped == NULL) { <br>        ChatSysError("malloc()", <br>                     "DoOverlappedEventSend()", <br>                     TRUE); <br>    } <br>    Buffers = &amp;OutReq-&gt;Buffer; <br> <br>    OutReq-&gt;Overlapped-&gt;hEvent = <br>      (WSAEVENT)CreateEvent(NULL, <br>                            FALSE, <br>                            FALSE, <br>                            NULL); <br>    if (OutReq-&gt;Overlapped-&gt;hEvent == NULL) { <br>        ChatSysError("CreateEvent()", <br>                     "DoOverlappedEventSend()", <br>                     TRUE); <br>    } <br> <br>    // Do the send. <br>    Error = WSASend(ConnData-&gt;Socket, <br>                    Buffers, <br>                    1, <br>                    &amp;BytesSent, <br>                    0, <br>                    OutReq-&gt;Overlapped, <br>                    NULL); <br> <br>    if (Error == SOCKET_ERROR) { <br> <br>        // There is an error... <br>        Errno = WSAGetLastError(); <br>        if (Errno == WSAEWOULDBLOCK) { <br> <br>            // WSAEWOULDBLOCK means we have to wait for an FD_WRITE <br>            // before we can send. <br>            ConnData-&gt;WriteOk = FALSE; <br>            ReturnValue = CHAT_WOULD_BLOCK; <br> <br>        } else if (Errno == WSA_IO_PENDING) { <br> <br>            // Overlapped send successfully initiated. <br>            // Increase the event count, and update the event and <br>            // output request arrays to hold the entries for this <br>            // overlapped send. <br>            ConnData-&gt;NumEvents++; <br>            if (ConnData-&gt;NumEvents &gt; WSA_MAXIMUM_WAIT_EVENTS) { <br> <br>                // We're trying to wait on too many events at <br>                // once.  It's very unlikely this could happen -- <br>                // you'd have to get about 62 overlapped sends, in <br>                // row, before one of them is completed and <br>                // signaled.  So just return CHAT_ERROR which will <br>                // break the connection. <br>                ReturnValue = CHAT_ERROR; <br> <br>            } else { <br> <br>                ConnData-&gt;EventArray[ConnData-&gt;NumEvents - 1] = <br>                  OutReq-&gt;Overlapped-&gt;hEvent; <br> <br>                ConnData-&gt;OutReqArray[ConnData-&gt;NumEvents - 1] = OutReq; <br>                ReturnValue = CHAT_OK; <br>            } <br>        } // else if (...) <br>        else { <br> <br>            // An unexpected error occurred. <br>            ReturnValue = CHAT_ERROR; <br>        } <br> <br>    } // if (Error == SOCKET_ERROR) <br> <br>    // No error -- the I/O request was completed immediately... <br>    ReturnValue = CHAT_OK; <br> <br>    return(ReturnValue); <br> <br>} // DoOverlappedEventSend() <br> <br> <br> <br> <br>  <br>int <br>DoSend( <br>    IN POUTPUT_REQUEST OutReq, <br>    IN PCONNDATA       ConnData) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Sends a buffer of data over a connected socket. <br> <br>Implementation: <br> <br>    This function uses the information contained in the output request <br>    structure to determine whether to use overlapped or non-overlapped <br>    I/O.  If using overlapped I/O, it calls an appropriate function <br>    depending on whether the symbol CALLBACK_NOTIFICATION has been <br>    defined. Otherwise, the non-overlapped send in performed <br>    immediately. <br> <br>Arguments: <br> <br>    OutReq -- Points to a OUTPUT_REQUEST structure, which specifies an <br>    output request. <br> <br>    ConnData -- Supplies a pointer to a CONNDATA structure, which <br>    identifies a Chat connection. <br> <br>Return Value: <br> <br>    CHAT_WOULD_BLOCK -- The send operation failed with WSAEWOULDBLOCK. <br> <br>    CHAT_ERROR -- A unexpected error occurred. <br> <br>    CHAT_OK -- The send was successfully initiated.  If the send was <br>    overlapped, either a callback function is forthcoming or another <br>    event was placed in the ConnData-&gt;EventArray for IOThreadFunc to <br>    wait on until it's signaled by WinSock 2. <br> <br>--*/ <br> <br>{ <br>    int             Size = 0;      // how many bytes we send <br>    int             Error;         // return value of WSASend <br>    int             Errno;         // result of WSAGetLastError <br>    WSABUF          Buffers[1];    // points to the data to be sent <br>    DWORD           BytesSent;     // needed in WSASend <br>    int             ReturnValue;   // the return value <br> <br>    if (OutReq-&gt;Type == NON_OVERLAPPED_IO) { <br> <br>        // Do a non-overlapped send by setting lpOverlapped and <br>        // lpCompletionRoutine to NULL. <br>        Buffers[0].len = OutReq-&gt;Buffer.len; <br>        Buffers[0].buf = OutReq-&gt;Buffer.buf; <br>        Error = WSASend(ConnData-&gt;Socket, <br>                        Buffers, <br>                        1, <br>                        &amp;BytesSent, <br>                        0, <br>                        NULL, <br>                        NULL); <br> <br>        if (Error == SOCKET_ERROR) { <br> <br>            // There's an error... <br>            Errno = WSAGetLastError(); <br>            if (Errno == WSAEWOULDBLOCK) { <br> <br>                //  WSAEWOULDBLOCK means we have to wait for an FD_WRITE <br>                //  before we can send. <br>                ConnData-&gt;WriteOk = FALSE; <br>                ReturnValue = CHAT_WOULD_BLOCK; <br> <br>            } else { <br> <br>                // It's an unexpected error. <br>                ReturnValue = CHAT_ERROR; <br>            } <br>        } else { <br> <br>            // There's no error. <br>            ReturnValue = CHAT_OK; <br>            free(OutReq); <br>        } <br> <br>    } else if (OutReq-&gt;Type == OVERLAPPED_IO) { <br> <br>#ifdef CALLBACK_NOTIFICATION <br> <br>        ReturnValue = DoOverlappedCallbackSend(OutReq, ConnData); <br> <br>#else <br> <br>        ReturnValue = DoOverlappedEventSend(OutReq, ConnData); <br> <br>#endif <br> <br>    } else { <br> <br>        // Unknown output type... <br>        MessageBox(ConnData-&gt;ConnectionWindow, <br>                   "Unknown output type given to IOThread. Aborting.", <br>                   "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        ReturnValue = CHAT_ERROR; <br>    } <br> <br>    return(ReturnValue); <br> <br>} // DoSend() <br> <br> <br> <br> <br>  <br>void CALLBACK <br>SendCompFunc( <br>    IN DWORD           Error, <br>    IN DWORD           BytesTransferred, <br>    IN LPWSAOVERLAPPED Overlapped, <br>    IN DWORD           Flags) <br>/*++ <br> <br>Routine Description: <br> <br>    Completion routine called after a successfully initiated overlapped <br>    send operation completes; cleans up data structures associated <br>    with the send. <br> <br>Arguments: <br> <br>    Error -- Supplies the completion status for the overlapped <br>    operation. <br> <br>    BytesTransferred -- Supplies the actual number of bytes sent. <br> <br>    Overlapped -- Supplies a pointer to a WSAOVERLAPPED structure. <br>    The hEvent field in the structure contains a pointer to the <br>    OUTPUT_REQUEST structure associated with this send operation. <br> <br>    Flags -- Not yet used. <br> <br>Return Value: <br> <br>    None <br> <br>--*/ <br> <br>{ <br>    POUTPUT_REQUEST OutReq; // The output request <br> <br>    OutReq = (POUTPUT_REQUEST)(Overlapped-&gt;hEvent); <br> <br>    if (Error) { <br>        MessageBox(NULL, <br>                   "Error during overlapped send.", <br>                   "Error", <br>                   MB_OK | MB_SETFOREGROUND); <br>    } <br> <br>    // Free the data buffer, the output request structure,  and the <br>    // overlapped I/O structure. <br>    free(OutReq-&gt;Buffer.buf); <br>    free(OutReq); <br>    free(Overlapped); <br> <br>} // SendCompFunc() <br> <br> <br> <br> <br>  <br>PCONNDATA <br>GetConnData( <br>    IN HWND ConnectionWindow <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Retrieves a pointer to the PCONNDATA data structure associated <br>    with a connection window <br> <br>Arguments: <br> <br>    ConnectionWindow - Supplies the handle to a connection window. <br> <br>Return Value: <br> <br>    Returns the PCONNDATA associated with the given connection window <br>    handle. <br> <br>--*/ <br> <br>{ <br>    return((PCONNDATA)GetWindowLong(ConnectionWindow, GWL_CONNINFO)); <br> <br>} // GetConnData() <br> <br> <br> <br> <br>  <br>BOOL <br>MakeConnection( <br>    IN HWND ConnectionWindow) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Initiates a call to another instance of chat. <br>    1) Creates a socket <br>    2) Set the socket up for windows message notification of FD_CONNECT <br>       events. <br>    3) Allocate a buffer for caller name &amp; subject, and fill it in. <br>    4) Allocate a buffer to receive callee name. <br>    5) Set up quality of service for the connection. <br>    6) Attempt a connection <br> <br>Arguments: <br> <br>    ConnectionWindow - Handle to the window that receives <br>    notification when an FD_CONNECT event occurs. <br> <br>Return Value: <br> <br>    TRUE - A connection attempt was successfully initiated. <br> <br>    FALSE - Error occurred while attempting to initiate a connection. <br> <br>--*/ <br> <br>{ <br>    int             ConnectStatus;    // the return value of WSAConnect <br>    int             Error;            // gets error values <br>    BOOL            ReturnValue;      // holds the return value <br>    PCONNDATA       ConnData;         // connection-specific data <br>    LPWSABUF        CallerBuffer;     // user data we will send <br>    LPWSABUF        CalleeBuffer;     // user data we will receive <br>    QOS             QualityOfService; // QOS structure, used by WSAConnect <br>    LPFLOWSPEC      FlowSpec;         // dummy pointer for code readability <br>    char            MsgText[MSG_LEN]; // holds message strings <br>    BOOL            QOSSupported;     // does the protocol support QOS? <br>    BOOL            CTDTSupported;    // support for conn-time data xfer? <br>    struct sockaddr *SockAddr;        // socket address for WSAConnect <br>    int             SockAddrLen;      // the length of the above <br> <br>    ReturnValue = TRUE; <br>    ConnData = GetConnData(ConnectionWindow); <br>    QOSSupported = (ConnData-&gt;ProtocolInfo-&gt;dwServiceFlags1 &amp; <br>                    XP1_QOS_SUPPORTED); <br>    CTDTSupported = (ConnData-&gt;ProtocolInfo-&gt;dwServiceFlags1 &amp; <br>                      XP1_CONNECT_DATA); <br>    if (CTDTSupported) { <br> <br>        // CallerBuffer and CallerBuffer-&gt;buf (allocated within the <br>        // NameAndSubject dialog box procedure) both get freed by the <br>        // end of this function.  CalleeBuffer.buf gets freed upon <br>        // connection shutdown -- it needs to be valid after this <br>        // function has exited. <br>        CallerBuffer = (LPWSABUF)malloc(sizeof(WSABUF)); <br>        if (CallerBuffer == NULL) { <br>            ChatSysError("malloc()", <br>                         "MakeConnection()", <br>                         TRUE); <br>        } <br>        CalleeBuffer = &amp;ConnData-&gt;CalleeBuffer; <br> <br>        // The connection-time data sent back when/if this connection <br>        // is accepted will just contain the callee's name. <br>        CalleeBuffer-&gt;len = NAME_LEN + 1; <br>        CalleeBuffer-&gt;buf = (char *)malloc(CalleeBuffer-&gt;len); <br>        if (CallerBuffer-&gt;buf == NULL) { <br>            ChatSysError("malloc()", <br>                         "MakeConnection()", <br>                         TRUE); <br>        } <br> <br>        // Prompt the user for his name and the subject of the call. <br>        // a pointer to the CallerBuffer is passed to the dialog box <br>        // procedure and the data is packed into this memory. <br>        if (!DialogBoxParam(GlobalInstance, <br>                            "NameAndSubjectDlg", <br>                            ConnectionWindow, <br>                            NameAndSubjectDlgProc, <br>                            (LPARAM)CallerBuffer)) { <br>            ReturnValue = FALSE; <br>            goto Done; <br>        } <br>    } // if (CTDTSupported) <br> <br>    // Create a socket for this connection. <br>    ConnData-&gt;Socket = WSASocket(0, <br>                                 0, <br>                                 0, <br>                                 ConnData-&gt;ProtocolInfo, <br>                                 0, <br>                                 WSA_FLAG_OVERLAPPED); <br> <br>    if (ConnData-&gt;Socket == INVALID_SOCKET) { <br> <br>        MessageBox(ConnectionWindow, "Could not open a socket.", "Error", <br>                   MB_OK | MB_SETFOREGROUND); <br>        ReturnValue = FALSE; <br>        goto Done; <br> <br>    } else { <br> <br>        // Set up socket for windows message event notification. <br>        WSAAsyncSelect(ConnData-&gt;Socket, <br>                       ConnectionWindow, <br>                       USMSG_CONNECT, <br>                       FD_CONNECT ); <br>    } <br> <br>    if (QOSSupported) { <br> <br>        // Set  up  quality  of  service  info  we  want.   Do  not include any <br>        // provider-specific information. <br>        QualityOfService.ProviderSpecific.len = 0; <br>        QualityOfService.ProviderSpecific.buf = NULL; <br> <br>        FlowSpec = &amp;QualityOfService.SendingFlowspec; <br>        FlowSpec-&gt;TokenRate = TOKENRATE; <br>        FlowSpec-&gt;TokenBucketSize = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;PeakBandwidth = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;Latency = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;DelayVariation = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;ServiceType = SERVICETYPE_CONTROLLEDLOAD; <br>        FlowSpec-&gt;MaxSduSize = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;MinimumPolicedSize = QOS_NOT_SPECIFIED; <br> <br>        FlowSpec = &amp;QualityOfService.ReceivingFlowspec; <br>        FlowSpec-&gt;TokenRate = TOKENRATE; <br>        FlowSpec-&gt;TokenBucketSize = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;PeakBandwidth = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;Latency = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;DelayVariation = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;ServiceType = SERVICETYPE_CONTROLLEDLOAD; <br>        FlowSpec-&gt;MaxSduSize = QOS_NOT_SPECIFIED; <br>        FlowSpec-&gt;MinimumPolicedSize = QOS_NOT_SPECIFIED; <br>    } <br> <br>    // Reminder: WinSock 2 requires that we pass a struct sockaddr * <br>    // to WSAConnect; however, the service provider is free to <br>    // interpret the pointer as an arbitrary chunk of data of size <br>    // SockAddrLen. <br> <br>    SockAddr = (struct sockaddr *)ConnData-&gt;RemoteSockAddr.buf; <br>    SockAddrLen = ConnData-&gt;RemoteSockAddr.len; <br> <br>    // Try to connect; depending on whether QOS or Connection Time <br>    // Data Transfer are supported, pass the appropriate data. <br>    if (QOSSupported &amp;&amp; CTDTSupported) { <br> <br>        // Both are supported... <br>        ConnectStatus = WSAConnect(ConnData-&gt;Socket, <br>                                   SockAddr, <br>                                   SockAddrLen, <br>                                   CallerBuffer, <br>                                   CalleeBuffer, <br>                                   &amp;QualityOfService, <br>                                   NULL); <br>    } else if (!QOSSupported &amp;&amp; CTDTSupported) { <br> <br>        // Only CTDT is supported... <br>        ConnectStatus = WSAConnect(ConnData-&gt;Socket, <br>                                   SockAddr, <br>                                   SockAddrLen, <br>                                   CallerBuffer, <br>                                   CalleeBuffer, <br>                                   NULL, <br>                                   NULL); <br> <br>    } else if (QOSSupported &amp;&amp; !CTDTSupported) { <br> <br>        // Only QOS is supported... <br>        ConnectStatus = WSAConnect(ConnData-&gt;Socket, <br>                                   SockAddr, <br>                                   SockAddrLen, <br>                                   NULL, <br>                                   NULL, <br>                                   &amp;QualityOfService, <br>                                   NULL); <br> <br>    } else { <br> <br>        // Neither is supported... <br>        ConnectStatus = WSAConnect(ConnData-&gt;Socket, <br>                                   SockAddr, <br>                                   SockAddrLen, <br>                                   NULL, <br>                                   NULL, <br>                                   NULL, <br>                                   NULL); <br>    } <br> <br>    // Check for errors. <br>    if (ConnectStatus == SOCKET_ERROR) { <br> <br>        Error = WSAGetLastError(); <br>        if (Error != WSAEWOULDBLOCK) { <br>            wsprintf(MsgText, "WSAConnect failed.  Error code: %d", <br>                     Error); <br>            MessageBox(ConnectionWindow, MsgText, "Error", <br>                       MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            ReturnValue = FALSE; <br>        } <br> <br>    } else { <br> <br>        MessageBox(ConnectionWindow, <br>                   "WSAConnect should have returned SOCKET_ERROR.", <br>                   "Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>        ReturnValue = FALSE; <br>    } <br> <br> Done: <br> <br>    // Free allocated memory, except CalleeBuffer which will be <br>    // freed when connection window is destroyed. <br>    if (CTDTSupported) { <br>        free(CallerBuffer-&gt;buf); <br>        free(CallerBuffer); <br>    } <br>    return(ReturnValue); <br> <br>} // MakeConnection() <br> <br> <br> <br> <br>  <br>BOOL <br>FillInFamilies( <br>    IN HWND  DialogWindow, <br>    IN DWORD FamilyLB) <br>/*++ <br> <br>Routine Description: <br> <br>    Fills in the listbox with a string for each protocol on which Chat <br>    has a listening socket. <br> <br>Implementation: <br> <br>    For each socket in the ListeningSockets array, this function: <br> <br>        1. Gets the associated protocol information structure. <br> <br>        2. If Chat recognizes the address family, it prints it in a <br>        string; if not, it prints "unknown". <br> <br>        3. In the second half of the string, prints out the <br>        human-readable string contained in the protocol information. <br> <br>        4. Sends the string to be an entry in the listbox identified <br>        by FamilyLB. <br> <br>Arguments: <br> <br>    DialogWindow -- Window handle for the dialog box. <br> <br>    FamilyLB -- Integer identifier for a listbox in the dialog box. <br> <br>Return Value: <br> <br>    TRUE - All messages were successfully sent to the listbox. <br> <br>    FALSE - An LB_ADDSTRING message failed. <br> <br>--*/ <br> <br>{ <br> <br>    int     i;                 // counting variable <br>    LRESULT Result;            // result of SendMessage calls <br>    char    LBString[MSG_LEN]; // string to send to the listbox <br>    int     Offset;             // index into the string <br> <br>    // Iterate through all members of the ListeningSockets array. <br>    for (i = 0; i &lt; NumFound; i++){ <br> <br>        // We are prepending a number to the list box string to be displayed <br>        // since the list box does us the favor of alphabetizing the <br>        // the sting and we are depending on the list entries appearing in the <br>        // list box in the order that we added them to the list. <br> <br>        Offset = wsprintf(LBString, "%03i",i); <br> <br>        switch (ListeningSockets[i].ProtocolInfo-&gt;iAddressFamily) { <br> <br>        case AF_INET: <br> <br>            Offset += wsprintf(LBString+ Offset, "AF_INET/"); <br>            wsprintf(LBString + Offset, "%s", <br>                     ListeningSockets[i].ProtocolInfo-&gt;szProtocol); <br>            Result = SendMessage(GetDlgItem(DialogWindow, FamilyLB), <br>                                 LB_ADDSTRING, 0, (LPARAM)LBString); <br>            break; <br> <br>        default: <br> <br>            Offset += wsprintf(LBString+ Offset, "(unknown)/"); <br>            wsprintf(LBString + Offset, "%s", <br>                     ListeningSockets[i].ProtocolInfo-&gt;szProtocol); <br>            Result = SendMessage(GetDlgItem(DialogWindow, FamilyLB), <br>                                 LB_ADDSTRING, 0, (LPARAM)LBString); <br>            break; <br> <br>        } <br>        if ((Result == LB_ERR) || (Result == LB_ERRSPACE)) { <br>            return(FALSE); <br>        } <br>    } <br>    return(TRUE); <br> <br>} // FillInFamilies() <br> <br> <br> <br> <br>  <br>LPWSAPROTOCOL_INFO <br>GetProtoFromIndex( <br>    IN int LBIndex) <br>/*++ <br> <br>Routine Description: <br> <br>    Takes an index into the ChooseFamily dialog box and returns the <br>    protocol associated with that index. This works because when the <br>    dialog box is set up, the strings representing the protocols are <br>    added to the listbox in the order they fall in ListeningSockets. <br> <br>Arguments: <br> <br>    LBIndex -- The index of the user's selection. <br> <br>Return Value: <br> <br>    NULL -- The index doesn't correspond to an element in the <br>    ListeningSockets array. <br> <br>    LPWSAPROTOCOL_INFO -- A pointer to the protocol information struct <br>    corresponding to LBIndex. <br> <br>--*/ <br>{ <br>    if (LBIndex &gt; (NumFound - 1)) { <br>        return(NULL); <br>    } <br>    return(ListeningSockets[LBIndex].ProtocolInfo); <br> <br>} // GetProtoFromIndex() <br> <br> <br> <br> <br>  <br>LPWSAPROTOCOL_INFO <br>GetProtoFromSocket( <br>    IN SOCKET Socket) <br>/*++ <br> <br>Routine Description: <br> <br>    Searches the ListeningSockets array for the first entry with a <br>    Socket field equal to the Socket parameter.  When found, it <br>    returns a pointer to the associated protocol information <br>    structure.  If not found, return NULL. <br> <br>Arguments: <br> <br>    Socket -- The socket who's associated WSAPROTOCOL_INFO struct we are <br>    looking for. <br> <br>Return Value: <br> <br>    NULL -- The socket was not found in the ListeningSockets array. <br> <br>    LPWSAPROTOCOL_INFO -- A pointer to the protocol information struct <br>    for the socket. <br> <br>--*/ <br>{ <br> <br>    int i; // counting variable <br> <br>    for (i = 0; i &lt; NumFound; i++) { <br>        if (ListeningSockets[i].Socket == Socket) { <br>            return(ListeningSockets[i].ProtocolInfo); <br>        } <br>    } <br>    return(NULL); <br> <br>} // GetProtoFromSocket() <br> <br> <br> <br> <br>  <br>void <br>CleanupConnection( <br>    IN PCONNDATA ConnData) <br>/*++ <br> <br>Routine Description: <br> <br>    Frees all memory and objects allocated for this connection. <br> <br>Arguments: <br> <br>    ConnData -- Pointer to the connection-specific data structure. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br> <br>    // Clean up connection-specific data.  To keep this code <br>    // readable, we ignore any errors. <br>    if (ConnData-&gt;SocketEventObject != NULL) { <br>        CloseHandle(ConnData-&gt;SocketEventObject); <br>        ConnData-&gt;SocketEventObject = NULL; <br>    } <br>    if (ConnData-&gt;OutputEventObject != NULL) { <br>        CloseHandle(ConnData-&gt;OutputEventObject); <br>        ConnData-&gt;SocketEventObject = NULL; <br>    } <br>    if (ConnData-&gt;OutputQueue != NULL) { <br>        QFree(ConnData-&gt;OutputQueue); <br>        ConnData-&gt;OutputQueue = NULL; <br>    } <br>    if (ConnData-&gt;IOThreadHandle != NULL) { <br>        CloseHandle(ConnData-&gt;IOThreadHandle); <br>        ConnData-&gt;IOThreadHandle = NULL; <br>        if (ConnData-&gt;ThreadTerminationEvent) { <br>            SetEvent( ConnData-&gt;ThreadTerminationEvent ); <br>        } <br>    } <br>    if (ConnData-&gt;Socket != INVALID_SOCKET) { <br>        closesocket(ConnData-&gt;Socket); <br>    } <br>    if (ConnData-&gt;RemoteSockAddr.buf != NULL) { <br>        free(ConnData-&gt;RemoteSockAddr.buf); <br>        ConnData-&gt;RemoteSockAddr.buf = NULL; <br>    } <br>    if (ConnData-&gt;CalleeBuffer.buf != NULL) { <br>        free(ConnData-&gt;CalleeBuffer.buf); <br>        ConnData-&gt;CalleeBuffer.buf = NULL; <br>    } <br> <br>    if (InterlockedDecrement( &amp;ConnData-&gt;RefCount ) == 0) { <br>        free( ConnData ); <br>    } <br> <br> <br>} // CleanupConnection() </code></pre>
<p>&nbsp;</p></body>
</HTML>
