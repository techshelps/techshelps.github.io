<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHATDLG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5352"></a>CHATDLG.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995 Intel Corp <br> <br>Module Name: <br> <br>    chatdlg.c <br> <br>Abstract: <br> <br>    Contains dialog-box procedures for the WinSock2 Chat sample <br>    application.  See qoschat.rc for the actual resource script. <br> <br>--*/ <br> <br>#include "nowarn.h"  /* turn off benign warnings */ <br>#ifndef _WINSOCKAPI_ <br>#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */ <br>#endif <br>#include &lt;windows.h&gt; <br>#include "nowarn.h"  /* some warnings may have been turned back on */ <br>#include &lt;winsock2.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;assert.h&gt; <br>#include "qoschat.h" <br>#include "chatsock.h" <br>#include "chatdlg.h" <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>ChooseFamilyDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the 'Choose <br>    Family' dialog box. <br> <br>Implementation <br> <br>    This dialog box is used to query the user as to which supported <br>    protocol he wishes to use for the chat connection he wishes to <br>    make.  The available protocols are listed in the IDC_FAM_LB <br>    listbox via the FillInFamilies function in socket.c. <br> <br>    It is expected that this dialog box gets the WM_INITDIALOG <br>    message with a LParam that is a pointer to the CONNDATA structure <br>    for the impending connection.  The result of this function is that <br>    the ProtocolInfo field of the ConnData struct is filled with a <br>    pointer to the protocol information structure the user chose in <br>    the listbox. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message. <br> <br>--*/ <br>{ <br>    int              LBIndex;         // index of the item chosen <br>    static PCONNDATA ConnData = NULL; // connection-specific data <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and fill in the listbox with the <br>        // available protocols. <br>        ConnData = (PCONNDATA)LParam; <br>        assert(ConnData != NULL); <br>        if (!FillInFamilies(DialogWindow, IDC_FAM_LB)) { <br>            MessageBox(DialogWindow, "FillInFamilies failed.", "Error.", <br>                        MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            EndDialog(DialogWindow, FALSE); <br>        } <br> <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the index of the listbox item the user has chosen. <br>            LBIndex = (int)SendMessage(GetDlgItem(DialogWindow, IDC_FAM_LB), <br>                                  LB_GETCURSEL, 0, 0); <br>            if (LBIndex == LB_ERR) { <br> <br>                // Nothing was selected. <br>                MessageBox(DialogWindow, "Choose an item, or hit cancel.", <br>                           "No Selection?", <br>                           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                return(TRUE); <br>            } <br> <br>            // Get the protocol associated with the listbox item the <br>            // user selected. <br>            ConnData-&gt;ProtocolInfo = GetProtoFromIndex(LBIndex); <br>            assert(ConnData-&gt;ProtocolInfo != NULL); <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            return(FALSE); <br>        } // switch (WParam) <br> <br>    default: <br> <br>        return(FALSE); <br>    } // switch (Message) <br> <br>} // ChooseFamilyDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>InetConnDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the internet <br>    connection info dialog box. <br> <br>Implementation <br> <br>    This dialog box gets two strings from the user: the internet <br>    address and port to which she wants to make a chat connection. <br>    When the user clicks on the OK button, these two strings are <br>    converted into a sockaddr_in structure and a pointer to this <br>    structure is saved in the connection window's CONNDATA structure. <br> <br>    NOTE: No name resolution takes place here!  The address edit <br>    control expects up to 15 characters, and this string is expected <br>    to be in.dotted.decimal.notation.  When RNR is available, this is <br>    where it would be called upon to provide the appropriate <br>    sockaddr_in structure.  Actually, this dialog box would be <br>    replaced with a protocol independent name dialog box; RNR would do <br>    all the rest... <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br> <br>{ <br>    char               PortText[INET_PORT_LEN + 1];   // holds port string <br>    char               AddressText[INET_ADDR_LEN + 1];// holds addr string <br>    static PCONNDATA   ConnData = NULL;               // conn-specific data <br>    struct sockaddr_in *SockAddrInet;                 // Inet socket address <br>    u_long             InetAddr;                      // Inet-style address <br>    u_short            InetPort;                      // Inet-style port <br>    int                Port;                          // intermediate var. <br>    BOOL               PortStringTranslated;          // for GetDlgItemInt <br>    struct hostent *host; <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the connection data pointer, initialize the dialog box. <br>        ConnData = (PCONNDATA)LParam; <br>        assert(ConnData != NULL); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_INET_ADDRESS), <br>                    EM_LIMITTEXT, (WPARAM)INET_ADDR_LEN, 0); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_INET_PORT), <br>                    EM_LIMITTEXT, (WPARAM)INET_PORT_LEN, 0); <br>        wsprintf(PortText,"%d", INET_DEFAULT_PORT); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_INET_PORT), <br>                    WM_SETTEXT, 0, (LPARAM)PortText); <br>        SetFocus(GetDlgItem(DialogWindow, IDC_INET_ADDRESS)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // The user has pressed the 'OK' button.  Extract the <br>            // internet address into a buffer and check the value the <br>            // user typed for the port. <br>            GetDlgItemText(DialogWindow, <br>                           IDC_INET_ADDRESS, <br>                           AddressText, <br>                           INET_ADDR_LEN); <br>            strcpy(ConnData-&gt;PeerAddress, AddressText); <br>            Port = (int)GetDlgItemInt(DialogWindow, <br>                                      IDC_INET_PORT, <br>                                      &amp;PortStringTranslated, <br>                                      TRUE); <br>            if ((Port &lt; 0) || (Port &gt; 65535) || !PortStringTranslated) { <br>              MessageBox(DialogWindow, <br>                         "Please choose a port between 0 and 65535.", <br>                         "Bad Port.", <br>                         MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                return(TRUE); <br>            } <br> <br>            // Convert the address string to an unsigned long, and <br>            // convert the port integer to an unsigned short.  If all <br>            // goes well, fill in the fields and end the dialog box. <br>            // If not, inform the user and *don't* kill the dialog box. <br>            InetAddr = inet_addr(AddressText); <br>            if (InetAddr == INADDR_NONE) { <br>                host = gethostbyname(AddressText); <br>                if (host) { <br>                    InetAddr = *((u_long *)host-&gt;h_addr_list[0]); <br>                } <br>            } <br>            InetPort = (u_short)Port; <br>            if ((InetAddr != INADDR_NONE) &amp;&amp; (InetAddr != 0)) { <br> <br>                // Allocate memory for an internet-style socket address; <br>                // point ConnData-&gt;SockAddr at this memory, and <br>                // use a local pointer to a struct sockaddr_in to <br>                // reference the fields. <br>                ConnData-&gt;RemoteSockAddr.len = sizeof(struct sockaddr_in); <br>                ConnData-&gt;RemoteSockAddr.buf = <br>                  malloc(ConnData-&gt;RemoteSockAddr.len); <br>                if (ConnData-&gt;RemoteSockAddr.buf == NULL) { <br>                    ChatSysError("malloc()", <br>                                 "InetConnDlgProc()", <br>                                 TRUE); <br>                } <br> <br>                SockAddrInet = <br>                  (struct sockaddr_in *)ConnData-&gt;RemoteSockAddr.buf; <br>                SockAddrInet-&gt;sin_family = AF_INET; <br>                SockAddrInet-&gt;sin_port = InetPort; <br>                SockAddrInet-&gt;sin_addr.S_un.S_addr = InetAddr; <br>                EndDialog(DialogWindow, TRUE); <br>                return(TRUE); <br> <br>            } <br> <br>            MessageBox(DialogWindow, <br>                       "Invalid Internet address. Try again or cancel.", <br>                       "Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // The user has pressed cancel.  Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            break; <br>        } // switch (WParam) <br> <br>        break; <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // InetConnDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>DefaultConnDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the default <br>    connection info dialog box. <br> <br>Implementation <br> <br>    This dialog box is the default when chat doesn't recognize a <br>    particular address family.  The user enters actual hex digits and <br>    the hex value is stored in the SocketAddress associated with the <br>    connection. Obviously, this requires the user to know how to <br>    interpret the structure of the socket address for this address <br>    family. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message. <br> <br>--*/ <br>{ <br> <br>    static PCONNDATA ConnData = NULL;                // connection data <br>    static int       AddrLen;                        // length of addresses <br>    char             AddrText[MAX_SOCKADDR_LEN * 2]; // address string <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and figure out how long addresses for <br>        // this protocol may be. <br>        ConnData = (PCONNDATA)LParam; <br>        assert(ConnData != NULL); <br> <br>        AddrLen = ConnData-&gt;ProtocolInfo-&gt;iMaxSockAddr; <br> <br>        if (AddrLen &gt; MAX_SOCKADDR_LEN) { <br>            MessageBox(DialogWindow, <br>                       "Sorry, socket addresses are too big. Aborting.", <br>                       "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>            EndDialog(DialogWindow, FALSE); <br>        } <br> <br>        // Limit the amount of text in the edit control to twice <br>        // AddrLen, i.e. 2 hex characters per byte. <br>        SendMessage(GetDlgItem(DialogWindow, IDC_ADDRESS), EM_LIMITTEXT, <br>                    (WPARAM)(AddrLen * 2), 0); <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // The user clicked 'OK'.  Get the text from the edit <br>            // control, and convert the hex string into bytes and put <br>            // the bytes into the socket address for this connection. <br>            GetDlgItemText(DialogWindow, IDC_ADDRESS, AddrText, <br>                           MAX_SOCKADDR_LEN * 2); <br>            ConnData-&gt;RemoteSockAddr.len = AddrLen; <br>            ConnData-&gt;RemoteSockAddr.buf = <br>              malloc(ConnData-&gt;RemoteSockAddr.len); <br>            if (ConnData-&gt;RemoteSockAddr.buf == NULL) { <br>                ChatSysError("malloc()", <br>                             "DefaultConnDlgProc()", <br>                             TRUE); <br>            } <br> <br>            if (TranslateHex(ConnData-&gt;RemoteSockAddr.buf, <br>                             ConnData-&gt;RemoteSockAddr.len, <br>                             AddrText, <br>                             DialogWindow)) { <br>                EndDialog(DialogWindow, TRUE); <br>            } <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            return(FALSE); <br>        } // switch (WParam) <br> <br>    default: <br> <br>        return(FALSE); <br>    } // switch (Message) <br> <br>} // DefaultConnDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>NameAndSubjectDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the name and <br>    subject dialog box. <br> <br>Implementation <br> <br>    This dialog box is brought up in MakeConnection (see socket.c) <br>    only if the protocol for the connection to be made supports <br>    connection-time data transfer.  The user fills in the two fields <br>    and this data is packed the WSABUF which is referenced through a <br>    pointer passed in during WM_INITDIALOG processing. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the dialog box. <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br>{ <br> <br>    static LPWSABUF CallerBuffer;            // caller user data <br>    char            NameText[NAME_LEN + 1];  // name string <br>    char            SubjectText[SUB_LEN + 1];// subject string <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and initialize the dialog box. <br>        CallerBuffer = (LPWSABUF)LParam; <br>        assert(CallerBuffer != NULL); <br> <br>        SendMessage(GetDlgItem(DialogWindow, IDC_CALLERNAME), <br>                    EM_LIMITTEXT, (WPARAM)NAME_LEN, 0); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_SUBJECT), <br>                    EM_LIMITTEXT, (WPARAM)SUB_LEN, 0); <br>        SetFocus(GetDlgItem(DialogWindow, IDC_CALLERNAME)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the strings the user has typed. <br>            GetDlgItemText(DialogWindow, <br>                           IDC_CALLERNAME, <br>                           NameText, <br>                           NAME_LEN); <br>            GetDlgItemText(DialogWindow, <br>                           IDC_SUBJECT, <br>                           SubjectText, <br>                           SUB_LEN); <br> <br>            CallerBuffer-&gt;len = strlen(NameText) + strlen(SubjectText) + 2; <br>            CallerBuffer-&gt;buf = (char *)malloc(CallerBuffer-&gt;len); <br>            if (CallerBuffer-&gt;buf == NULL) { <br>                ChatSysError("malloc()", <br>                             "NameAndSubjectDlgProc()", <br>                             TRUE); <br>            } <br> <br>            if (!PackTwoStrings(CallerBuffer-&gt;buf, <br>                                CallerBuffer-&gt;len, <br>                                NameText, <br>                                SubjectText)) { <br>                MessageBox(DialogWindow, "PackTwoStrings failed. Aborting.", <br>                           "Error.", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                EndDialog(DialogWindow, FALSE); <br>            } <br> <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            return(FALSE); <br>        } // switch (WParam) <br> <br>    default: <br> <br>        return(FALSE); <br>    } // switch (Message) <br> <br>} // NameAndSubjectDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>AcceptConnectionDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the <br>    AcceptConnection dialog box.  Get's the callee's name and copies <br>    it into the CalleeBuffer, which is passed in as a parameter to the <br>    WM_INITDIALOG message. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the AcceptConnection dialog box <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br> <br>{ <br>    static LPWSABUF CalleeData; // callee user data <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        CalleeData = (LPWSABUF)LParam; <br>        assert(CalleeData != NULL); <br> <br>        // Determine how much room there is in the user data buffer. <br>        // Limit the text to NAME_LEN characters, or less if we <br>        // don't have room for that many. <br>        if (CalleeData-&gt;len &lt; (NAME_LEN + 1)) { <br>            SendMessage(GetDlgItem(DialogWindow, IDC_CALLERNAME), <br>                        EM_LIMITTEXT, (WPARAM)(CalleeData-&gt;len - 1), <br>                        0); <br>        } else { <br>            SendMessage(GetDlgItem(DialogWindow, IDC_CALLERNAME), <br>                        EM_LIMITTEXT, (WPARAM)NAME_LEN, 0); <br>        } <br>        SetFocus(GetDlgItem(DialogWindow, IDC_CALLEENAME)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the name from the control and but it in CalleeData. <br>            GetDlgItemText(DialogWindow, <br>                           IDC_CALLEENAME, <br>                           CalleeData-&gt;buf, <br>                           NAME_LEN); <br>            CalleeData-&gt;len = strlen(CalleeData-&gt;buf + 1); <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br> <br>            break; <br> <br>        } <br> <br>        break; <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // AcceptConnectionDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>InetListenPortDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the <br>    listening port dialog box. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the AcceptConnection dialog box <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br>{ <br> <br>    static struct sockaddr_in *SockAddrInet;             // Inet sockaddress <br>    int                       Port;                      // Inet port <br>    BOOL                      PortStringTranslated;      // for GetDlgItemInt <br>    char                      PortText[INET_PORT_LEN+1]; // Inet port string <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and initialize the dialog box. <br>        SockAddrInet = (struct sockaddr_in *)LParam; <br>        assert(SockAddrInet != NULL); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_LISTEN_PORT), <br>                    EM_LIMITTEXT, (WPARAM)INET_PORT_LEN, 0); <br>        wsprintf(PortText,"%d", INET_DEFAULT_PORT); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_LISTEN_PORT), <br>                    WM_SETTEXT, 0, (LPARAM)PortText); <br>        SetFocus(GetDlgItem(DialogWindow, IDC_LISTEN_PORT)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // Get the port. <br>            Port = (int)GetDlgItemInt(DialogWindow, <br>                                      IDC_LISTEN_PORT, <br>                                      &amp;PortStringTranslated, <br>                                      TRUE); <br>            if ((Port &lt; 0) || (Port &gt; 65535) || !PortStringTranslated) { <br>                MessageBox(DialogWindow, <br>                           "Please choose a port between 0 and 65535.", <br>                           "Bad Port.", <br>                           MB_OK | MB_ICONSTOP | MB_SETFOREGROUND); <br>                return(TRUE); <br>            } <br> <br>            SockAddrInet-&gt;sin_port = (u_short)Port; <br>            EndDialog(DialogWindow, TRUE); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            return(TRUE); <br> <br>        default: <br>            break; <br>        } <br>        break; <br> <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // InetListenPortDlgProc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>DefaultListenAddrDlgProc( <br>    IN HWND DialogWindow, <br>    IN UINT Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function that processes messages sent to the default <br>    listening address dialog box. <br> <br>Arguments: <br> <br>    DialogWindow - Supplies handle of the AcceptConnection dialog box <br> <br>    Message - Supplies the message identifier <br> <br>    WParam - Supplies the first message parameter <br> <br>    LParam - Supplies the second message parameter <br> <br>Return Value: <br> <br>    TRUE -- This function handled the message. <br> <br>    FALSE -- This function did not handle the message; or the message <br>    was WM_INITDIALOG and we set the focus. <br> <br>--*/ <br>{ <br> <br>    static LPWSABUF SockAddrBuf; <br>    static char     *AddrText; <br>    static int      AddrTextLen; <br> <br>    switch (Message) { <br> <br>    case WM_INITDIALOG: <br> <br>        // Get the parameter and initialize the dialog box. <br>        SockAddrBuf = (LPWSABUF)LParam; <br>        assert(SockAddrBuf != NULL); <br> <br>        AddrTextLen = SockAddrBuf-&gt;len * 2 + 1; <br>        AddrText = (char *)malloc(AddrTextLen); <br> <br>        SendMessage(GetDlgItem(DialogWindow, IDC_LISTEN_ADDR), <br>                    EM_LIMITTEXT, AddrTextLen - 1, 0); <br>        wsprintf(AddrText,"%X", <br>                 ((struct sockaddr *)SockAddrBuf-&gt;buf)-&gt;sa_family); <br>        SendMessage(GetDlgItem(DialogWindow, IDC_LISTEN_ADDR), <br>                    WM_SETTEXT, 0, (LPARAM)AddrText); <br>        SetFocus(GetDlgItem(DialogWindow, IDC_LISTEN_ADDR)); <br>        return(FALSE); <br> <br>    case WM_COMMAND: <br> <br>        switch (WParam) { <br> <br>        case IDOK: <br> <br>            // The user clicked 'OK'.  Get the text from the edit <br>            // control, and convert the hex string into bytes and put <br>            // the bytes into the socket address for this connection. <br>            GetDlgItemText(DialogWindow, IDC_LISTEN_ADDR, AddrText, <br>                           AddrTextLen); <br>            if (TranslateHex(SockAddrBuf-&gt;buf, <br>                             SockAddrBuf-&gt;len, <br>                             AddrText, <br>                             DialogWindow)) { <br>                EndDialog(DialogWindow, TRUE); <br>            } <br> <br>            EndDialog(DialogWindow, TRUE); <br>            free(AddrText); <br>            return(TRUE); <br> <br>        case IDCANCEL: <br> <br>            // Kill the dialog box. <br>            EndDialog(DialogWindow, FALSE); <br>            free(AddrText); <br>            return(TRUE); <br> <br>        default: <br>            break; <br>        } <br>        break; <br> <br>    } // switch (Message) <br> <br>    return(FALSE); <br>} // DefaultListenAddrDlgProc() <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
