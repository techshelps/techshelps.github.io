<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QUEUE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5350"></a>QUEUE.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995 Intel Corp <br> <br>Module Name: <br> <br>    queue.h <br> <br>Abstract: <br> <br>    Implementation of functions supplied by this queue manager module. <br> <br>--*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;malloc.h&gt; <br>#include "queue.h" <br> <br> <br> <br>  <br>PQUEUE  <br>QCreate(void) <br>/*++ <br> <br>Routine Description: <br> <br>    Creates a new QUEUE, initializes it, and returns it. Returns NULL <br>    if memory cannot be allocated in the heap.    <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    NULL if memory allocation fails; else a pointer to a new queue. <br> <br>--*/ <br>{ <br> <br>    PQUEUE Queue; // points to the new queue <br> <br>    // Allocate space for a new queue. <br>    Queue = (PQUEUE)malloc(sizeof(QUEUE)); <br>    if (Queue != NULL){ <br>         <br>        // Initialize the new queue. <br>        Queue-&gt;Head = Q_NULL; <br>        Queue-&gt;Tail = Q_NULL; <br>        InitializeCriticalSection(&amp;Queue-&gt;CrSec); <br>    } <br>    return(Queue); <br>} <br> <br> <br> <br>  <br>void  <br>QFree(PQUEUE Queue) <br>/*++ <br> <br>Routine Description: <br> <br>    This function removes any items left on the queue, frees them, and <br>    then frees the queue itself. <br> <br>Arguments: <br> <br>    Queue -- Pointer to the queue to free. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br>{ <br>   <br>    LPVOID Object; // points to objects we pull off the queue <br> <br>    EnterCriticalSection(&amp;Queue-&gt;CrSec); <br> <br>    // Free everything on the queue. <br>    Object = QRemove(Queue); <br>    while (Object) { <br>        free(Object); <br>        Object = QRemove(Queue); <br>    } <br> <br>    LeaveCriticalSection(&amp;Queue-&gt;CrSec); <br> <br>    // Free the queue itself. <br>    free(Queue); <br>} <br> <br> <br> <br>  <br>LPVOID  <br>QRemove(PQUEUE Queue) <br>/*++ <br> <br>Routine Description: <br> <br>    This function dequeues one object from Queue and returns a generic <br>    pointer to the object.  It is up to the calling function to know <br>    the size and type of the object dequeued. <br> <br>Arguments: <br> <br>    Queue -- The queue from which to dequeue the object. <br> <br>Return Value: <br> <br>    NULL if the queue is empty; else, a pointer to the dequeued object. <br> <br>--*/ <br>{ <br> <br>    LPVOID Data;    // points to the object we pull off the queue <br>         <br>    EnterCriticalSection(&amp;Queue-&gt;CrSec); <br>     <br>    if (Queue-&gt;Head == Q_NULL){ <br>         <br>        // If the queue is empty, we will return NULL.  <br>        Data = NULL; <br>         <br>    } else { <br>         <br>        // Get the pointer, NULL it in the QueueArray. <br>        Data = Queue-&gt;QueueArray[Queue-&gt;Head]; <br>        Queue-&gt;QueueArray[Queue-&gt;Head] = NULL; <br> <br>        // Check to see if we've just emptied the queue; if so, set <br>        // the Head and Tail indices to Q_NULL.  If not, set the Head <br>        // index to the right value. <br>        if (Queue-&gt;Head == Queue-&gt;Tail) { <br>            Queue-&gt;Head = Queue-&gt;Tail = Q_NULL; <br>        } else { <br>            Queue-&gt;Head = (Queue-&gt;Head + 1) % MAX_QUEUE_SIZE; <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;Queue-&gt;CrSec); <br>    return(Data); <br>} <br> <br> <br> <br> <br>  <br>BOOL <br>QInsert( <br>    PQUEUE Queue, <br>    LPVOID Object) <br>/*++ <br> <br>Routine Description: <br> <br>    This function enqueues one item into Queue, if there is room for <br>    it.  <br> <br>Arguments: <br> <br>    Queue -- The queue onto which to enqueue Object. <br> <br>    Object -- A void pointer to the object being enqueued. <br> <br>Return Value: <br> <br>    TRUE -- The object was successfully enqueued. <br> <br>    FALSE -- There were too many items already in the queue; one item <br>    must be removed in order to insert another. <br> <br>--*/ <br>{ <br>    BOOL ReturnValue; // holds the return value <br> <br>    EnterCriticalSection(&amp;Queue-&gt;CrSec); <br>     <br>    // If the queue is full, set the return value to FALSE and do <br>    // nothing; if not, update the indices appropriately and set the <br>    // return value to TRUE.  <br>    if(((Queue-&gt;Tail + 1) % MAX_QUEUE_SIZE == Queue-&gt;Head) <br>       &amp;&amp; (Queue-&gt;Head != Q_NULL)) { <br> <br>        ReturnValue = FALSE; <br> <br>    } else { <br> <br>        Queue-&gt;Tail = (Queue-&gt;Tail + 1) % MAX_QUEUE_SIZE; <br>        Queue-&gt;QueueArray[Queue-&gt;Tail] = Object; <br>        if (Queue-&gt;Head == Q_NULL){ <br>            Queue-&gt;Head = 0; <br>        } <br>        ReturnValue = TRUE; <br>    } <br> <br>    LeaveCriticalSection(&amp;Queue-&gt;CrSec); <br>    return(ReturnValue); <br>} <br> <br> <br> <br>  <br>BOOL <br>QInsertAtHead( <br>    PQUEUE Queue,  <br>    LPVOID Object) <br>/*++ <br> <br>Routine Description: <br> <br>    This function inserts one item at the HEAD of the queue.  Of <br>    course, this violates queue semantics...but this can be useful at <br>    times.  <br> <br>Arguments: <br> <br>    Queue -- The queue into which to insert Object. <br> <br>    Object -- A void pointer to the object being inserted. <br> <br>Return Value: <br> <br>    TRUE -- The object was successfully inserted at the head of the <br>    queue.  <br> <br>    FALSE -- There were too many items already in the queue; one item <br>    must be removed in order to insert another. <br> <br>--*/ <br>{ <br>  <br>    BOOL ReturnValue; // holds the return value <br> <br>    EnterCriticalSection(&amp;Queue-&gt;CrSec); <br> <br>    // If the queue is full, set the return value to FALSE and do <br>    // nothing; if not, update the indices appropriately and set the <br>    // return value to TRUE.  <br>    if(((Queue-&gt;Tail + 1) % MAX_QUEUE_SIZE == Queue-&gt;Head) <br>       &amp;&amp; (Queue-&gt;Head != Q_NULL)) { <br>         <br>        ReturnValue = FALSE; <br>         <br>    } else { <br>   <br>        if (Queue-&gt;Head == Q_NULL) { <br> <br>            // The queue was empty, so just use QInsert. <br>            QInsert(Queue, Object); <br>        } <br> <br>        if (Queue-&gt;Head == 0) { <br>            Queue-&gt;Head = MAX_QUEUE_SIZE - 1; <br>        } else { <br>            Queue-&gt;Head = Queue-&gt;Head - 1; <br>        } <br>     <br>        Queue-&gt;QueueArray[Queue-&gt;Head] = Object; <br>        ReturnValue = TRUE; <br>    } <br> <br>    LeaveCriticalSection(&amp;Queue-&gt;CrSec);     <br>    return(ReturnValue); <br>} <br> <br> <br> <br>  <br>BOOL <br>QIsEmpty(PQUEUE Queue) <br>/*++ <br> <br>Routine Description: <br> <br>    This function tells the caller if the queue in question contains <br>    any items. <br> <br>Arguments: <br> <br>    Queue -- The queue which we want to query. <br> <br>Return Value: <br> <br>    TRUE -- The queue is empty. <br> <br>    FALSE -- The queue contains at least one item. <br> <br>--*/ <br>{ <br>    return(Queue-&gt;Head == Q_NULL ? TRUE : FALSE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
