<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QOSCHAT.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5349"></a>QOSCHAT.H</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995 Intel Corp <br> <br>Module Name: <br> <br>    ws2chat.h <br> <br>Abstract: <br> <br>    This module defines the data structures and constants <br>    for the WinSock 2 sample chat application. <br> <br>--*/ <br> <br>#ifndef _ws2chat_H <br>#define _ws2chat_H <br> <br>#include "nowarn.h"  /* turn off benign warnings */ <br>#ifndef _WINSOCKAPI_ <br>#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */ <br>#endif <br>#include &lt;windows.h&gt; <br>#include "nowarn.h"  /* some warnings may have been turned back on */ <br>#include &lt;winsock2.h&gt; <br>#include "queue.h" <br> <br>// turn off "unreferenced formal parameter" warning <br>#pragma warning(disable: 4100) <br> <br> <br> <br>// <br>// Manifest Constants <br>// <br> <br> <br>// UI/MDI <br>#define MAIN_MENU_POS         1 <br>#define CLIENT_WINDOW_ID      1 <br> <br>#define EC_SEND_CHILD         0 <br>#define EC_RECV_CHILD         1 <br> <br>#define IDM_CONNECT           10 <br>#define IDM_CLOSE             12 <br>#define IDM_EXIT              13 <br>#define IDM_TILE              30 <br>#define IDM_CASCADE           31 <br>#define IDM_ARRANGE           32 <br>#define IDM_CLOSEALL          33 <br>#define IDM_CLEAR_SENDBUFFER  34 <br>#define IDM_CLEAR_RECVBUFFER  35 <br>#define IDM_FIRSTCHILD        100 <br> <br>// For some reason, 30k is the most characters you can have in an edit <br>// control at once.  This keeps us from going over. <br>#define MAX_EC_TEXT 25500 <br> <br>// resource constants <br>#define IDC_SUBJECT           1000 <br>#define IDC_CALLEENAME        1001 <br>#define IDC_CALLERNAME        1002 <br>#define IDC_FAM_LB            1003 <br>#define IDC_INET_ADDRESS      1004 <br>#define IDC_INET_PORT         1005 <br>#define IDC_ADDRESS           1006 <br>#define IDC_LISTEN_PORT       1007 <br>#define IDC_LISTEN_ADDR       1008 <br>#define IDC_STATIC            -1 <br> <br>// data lengths <br>#define NAME_LEN              20 <br>#define ADDR_LEN              40 <br>#define SUB_LEN               80 <br>#define MSG_LEN               200 <br>#define TITLE_LEN             40 <br>#define BUFFER_LENGTH         1024 <br> <br>// various stuff <br>#define MAX_SOCKADDR_LEN      512 <br>#define MAX_LISTENING_SOCKETS 64 <br>#define CONN_WND_EXTRA        8 <br>#define GWL_CONNINFO          0 <br>#define GWL_OLDEDITPROC       4 <br>#define NO_MAX_MSG_SIZE       0xffffffff <br> <br>// what kind of send? <br>#define OVERLAPPED_IO         0 <br>#define NON_OVERLAPPED_IO     1 <br> <br>// chat return values <br>#define CHAT_OK               0 <br>#define CHAT_ERROR            1 <br>#define CHAT_CLOSED           2 <br>#define CHAT_WOULD_BLOCK      3 <br>#define CHAT_ABORTED          4 <br> <br>// for Internet connections <br>#define INET_ADDR_LEN         64 <br>#define INET_PORT_LEN         5 <br>#define INET_DEFAULT_PORT     9009 <br> <br>// for LSP connections <br>#define LSP_ADDR_LEN 10 <br>#define LSP_DEFAULT_ADDR 9009 <br> <br>// user message values <br>#define USMSG_ACCEPT          WM_USER+1 <br>#define USMSG_CONNECT         WM_USER+2 <br>#define USMSG_TEXTOUT         WM_USER+3 <br>#define USMSG_QOS             WM_USER+4 <br> <br>// version of Winsock we need <br>#define VERSION_MAJOR         2 <br>#define VERSION_MINOR         0 <br> <br>// quality of Service <br>#define TOKENRATE             100 <br>#define QOS_UNSPECIFIED       (DWORD)-1 <br> <br> <br> <br>// <br>// Types and Data Structures <br>// <br> <br>typedef struct _CONNDATA CONNDATA, *PCONNDATA; <br>typedef struct _OUTPUT_REQUEST OUTPUT_REQUEST, *POUTPUT_REQUEST; <br> <br>// structure created by the user interface and passed to the <br>// input/output thread -- tells the I/O thread what to send and how to <br>// send it. <br>struct _OUTPUT_REQUEST { <br>    int             Type;       // OVERLAPPED_IO or NON_OVERLAPPED_IO <br>    WSABUF          Buffer;     // holds the buffer (pointer) and size <br>    char            Character;  // for one-character ouput events <br>    PCONNDATA       ConnData;   // data for the associated connection <br>    LPWSAOVERLAPPED Overlapped; // NULL if not an overlapped send <br>}; <br> <br>// structure for storing data unique to each connection. <br>struct _CONNDATA { <br> <br>                    // the socket for the connection <br>    SOCKET          Socket; <br> <br>    DWORD           RefCount;       // so we know when to free it <br> <br>                    // string containing the name of the user (only <br>                    // valid if user-data is supported by the protocol) <br>    char            PeerName[NAME_LEN + 1]; <br> <br>                    // string containing the subject of the chat <br>                    // session, as entered by the calling entity <br>    char            Subject[SUB_LEN + 1]; <br> <br>                    // string containing the (human-readable) address <br>                    // of the connected entity <br>    char            PeerAddress[ADDR_LEN + 1]; <br> <br>                    // handle to thread that takes care of network events <br>    HANDLE          IOThreadHandle; <br> <br>                    // handle to event signaled when a network event <br>                    // occurs <br>    HANDLE          SocketEventObject; <br> <br>                    // handle to event signaled when output is ready <br>                    // to be shipped <br>    HANDLE          OutputEventObject; <br> <br>                    // This event is signalled in CleanupConnection to tell the thread to exit <br>    HANDLE          ThreadTerminationEvent; <br> <br>                    // points to a queue used to hold output buffers <br>    PQUEUE          OutputQueue; <br> <br>                    // handle to window associated with the connection <br>    HWND            ConnectionWindow; <br> <br>                    // handle to the sending and receiving edit controls <br>    HWND            SendWindow; <br>    HWND            RecvWindow; <br> <br>                    // the remote socket address for the connection <br>    WSABUF          RemoteSockAddr; <br> <br>                    // buffer used by the connecting entity to get <br>                    // user-data back when the  USMSG_CONNECT is <br>                    // received <br>    WSABUF          CalleeBuffer; <br> <br>                    // points to a protocol information struct which <br>                    // represents the protocol for this connection <br>    LPWSAPROTOCOL_INFO ProtocolInfo; <br> <br>                    // are we waiting for an FD_WRITE? <br>    BOOL            WriteOk; <br> <br>                    // How many events the wait in the I/O thread is <br>                    // waiting on.  Once that thread starts, this will <br>                    // always be at least 2 -- the SocketEventObject <br>                    // and the OutputEventObject. <br>    DWORD           NumEvents; <br> <br>                    // The array of events which the I/O thread is <br>                    // currently waiting on.  Contains NumEvents entries. <br>    WSAEVENT        EventArray[WSA_MAXIMUM_WAIT_EVENTS]; <br> <br>                    // An array of pointers to output request <br>                    // structures, indexed in parallel to EventArray, <br>                    // above. This allows us to associate the events <br>                    // with the output requests, so we can free the <br>                    // right memory when the event is signaled. <br>    POUTPUT_REQUEST OutReqArray[WSA_MAXIMUM_WAIT_EVENTS]; <br> <br>                    // The maximum message size we can send on this <br>                    // socket. This value is either an integer or the <br>                    // manifest constant NO_MAX_MSG_SIZE. <br>    DWORD            MaxMsgSize; <br>}; <br> <br>// structure to associate listening sockets with a protocol <br>// information struct. <br>typedef struct _LISTENDATA { <br>    SOCKET             Socket;       // a listening socket <br>    LPWSAPROTOCOL_INFO ProtocolInfo; // the associated protocol info. struct <br>} LISTENDATA, *PLISTENDATA; <br> <br> <br> <br> <br>// <br>// Function prototypes for functions to be used outside of ws2chat.c <br>// <br> <br>void <br>OutputString( <br>    IN HWND RecvWindow, <br>    IN char *String); <br> <br> <br>BOOL <br>ExtractTwoStrings( <br>    IN  char *Buffer, <br>    OUT char *String1, <br>    IN  char Length1, <br>    OUT char *String2, <br>    IN  int  Length2); <br> <br>BOOL <br>TranslateHex( <br>    OUT LPVOID Buffer, <br>    IN  int    BufferLen, <br>    IN  char   *HexString, <br>    IN  HWND   WindowHandle); <br> <br>BOOL <br>PackTwoStrings( <br>    OUT char *Buffer, <br>    IN int   BufferLen, <br>    IN char  *String1, <br>    IN char  *String2); <br> <br>BOOL <br>MakeRoom( <br>    IN HWND EditControl, <br>    IN int  HowMuch); <br> <br>void <br>ChatSysError( <br>    IN char *FailedFunction, <br>    IN char *InFunction, <br>    IN BOOL Fatal); <br> <br>VOID <br>ParseCmdLine( <br>    LPSTR   CmdLine <br>    ); <br> <br>INT <br>usage(); <br> <br>DWORD <br>StartConnection( <br>    IN HWND   WindowHandle <br>    ); <br> <br>BOOL <br>HandleSocketEvent( <br>    IN OUT PCONNDATA ConnData); <br> <br>int <br>HandleEvents( <br>    IN PCONNDATA          ConnData, <br>    IN LPWSANETWORKEVENTS NetworkEvents); <br> <br>// <br>// Externally-Visible Variables <br>// <br> <br>extern HANDLE  GlobalInstance;    // Identifies the instance of chat <br>extern char    ConnClassStr[];    // String to register window class <br>extern char    ChatClassStr[];    // String to register window class <br>extern HWND    GlobalFrameWindow; // Chat's main -- or frame -- window <br> <br>extern DWORD   ThisAddr; <br>extern DWORD   OtherAddr; <br>extern DWORD   NumSockets; <br>extern DWORD   LocalPort; <br>extern BOOL    UseAsyncSelect; <br> <br>#endif // _ws2chat_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
