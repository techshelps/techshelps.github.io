<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5363"></a>CLIENT.C</h2>
<pre><code>/****************************************************************************\ <br>*  dgrecv.c -- sample program demonstrating NWLink. <br>* <br>*       Microsoft Developer Support <br>*       Copyright 1992 - 1997 Microsoft Corporation <br>* <br>*  This program is a simple example of using SPX connect. <br>* <br>****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;winsock.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include "wshisotp.h" <br> <br>typedef struct tag_error_struct{ <br>    int     errnum; <br>    LPSTR   errstr; <br>} ERROR_STRUCT; <br> <br>SOCKADDR_TP addr; <br>SOCKADDR_TP caddr; <br> <br>UCHAR ch = 0; <br> <br>char LocalNetworkAddress[22]; <br>char LocalNetworkAddressLength; <br>short   LocalTsel; <br>char RemoteNetworkAddress[22]; <br>char RemoteNetworkAddressLength; <br>short   RemoteTsel; <br> <br>int     verbose = 1; <br>int     Socket_Type = SOCK_SEQPACKET; <br>int     Protocol = ISOPROTO_TP4; <br>int     Local_Address_Family = AF_ISO; <br>int     Remote_Address_Family = AF_ISO; <br>int     Backlog = 1; <br>int     No_Broadcast = 0; <br>int     No_Loop = 0; <br>int     Sleep_Time = 1000; <br>int     Send_Length = 100; <br>int     Receive_Length = 200; <br>int     Local_Packet_Type = 0; <br> <br>#define WSAERRGAP1 28 <br>#define WSAERRGAP2 19 <br> <br>char msg_no_error[19] =      "No error occurred!"; <br>char msg_unknown_error[14] = "Unknown error"; <br> <br>ERROR_STRUCT errlist[] = { <br>    {WSAEINTR,           "WSAEINTR - Interrupted"}, <br>    {WSAEBADF,           "WSAEBADF - Bad file number"}, <br>    {WSAEFAULT,          "WSAEFAULT - Bad address"}, <br>    {WSAEINVAL,          "WSAEINVAL - Invalid argument"}, <br>    {WSAEMFILE,          "WSAEMFILE - Too many open files"}, <br> <br>/* <br>*    Windows Sockets definitions of regular Berkeley error constants <br>*/ <br> <br>    {WSAEWOULDBLOCK,     "WSAEWOULDBLOCK - Socket marked as non-blocking"}, <br>    {WSAEINPROGRESS,     "WSAEINPROGRESS - Blocking call in progress"}, <br>    {WSAEALREADY,        "WSAEALREADY - Command already completed"}, <br>    {WSAENOTSOCK,        "WSAENOTSOCK - Descriptor is not a socket"}, <br>    {WSAEDESTADDRREQ,    "WSAEDESTADDRREQ - Destination address required"}, <br>    {WSAEMSGSIZE,        "WSAEMSGSIZE - Data size too large"}, <br>    {WSAEPROTOTYPE,      "WSAEPROTOTYPE - Protocol is of wrong type for this socket"}, <br>    {WSAENOPROTOOPT,     "WSAENOPROTOOPT - Protocol option not supported for this socket type"}, <br>    {WSAEPROTONOSUPPORT, "WSAEPROTONOSUPPORT - Protocol is not supported"}, <br>    {WSAESOCKTNOSUPPORT, "WSAESOCKTNOSUPPORT - Socket type not supported by this address family"}, <br>    {WSAEOPNOTSUPP,      "WSAEOPNOTSUPP - Option not supported"}, <br>    {WSAEPFNOSUPPORT,    "WSAEPFNOSUPPORT - "}, <br>    {WSAEAFNOSUPPORT,    "WSAEAFNOSUPPORT - Address family not supported by this protocol"}, <br>    {WSAEADDRINUSE,      "WSAEADDRINUSE - Address is in use"}, <br>    {WSAEADDRNOTAVAIL,   "WSAEADDRNOTAVAIL - Address not available from local machine"}, <br>    {WSAENETDOWN,        "WSAENETDOWN - Network subsystem is down"}, <br>    {WSAENETUNREACH,     "WSAENETUNREACH - Network cannot be reached"}, <br>    {WSAENETRESET,       "WSAENETRESET - Connection has been dropped"}, <br>    {WSAECONNABORTED,    "WSAECONNABORTED - "}, <br>    {WSAECONNRESET,      "WSAECONNRESET - "}, <br>    {WSAENOBUFS,         "WSAENOBUFS - No buffer space available"}, <br>    {WSAEISCONN,         "WSAEISCONN - Socket is already connected"}, <br>    {WSAENOTCONN,        "WSAENOTCONN - Socket is not connected"}, <br>    {WSAESHUTDOWN,       "WSAESHUTDOWN - Socket has been shut down"}, <br>    {WSAETOOMANYREFS,    "WSAETOOMANYREFS - "}, <br>    {WSAETIMEDOUT,       "WSAETIMEDOUT - Command timed out"}, <br>    {WSAECONNREFUSED,    "WSAECONNREFUSED - Connection refused"}, <br>    {WSAELOOP,           "WSAELOOP - "}, <br>    {WSAENAMETOOLONG,    "WSAENAMETOOLONG - "}, <br>    {WSAEHOSTDOWN,       "WSAEHOSTDOWN - "}, <br>    {WSAEHOSTUNREACH,    "WSAEHOSTUNREACH - "}, <br>    {WSAENOTEMPTY,       "WSAENOTEMPTY - "}, <br>    {WSAEPROCLIM,        "WSAEPROCLIM - "}, <br>    {WSAEUSERS,          "WSAEUSERS - "}, <br>    {WSAEDQUOT,          "WSAEDQUOT - "}, <br>    {WSAESTALE,          "WSAESTALE - "}, <br>    {WSAEREMOTE,         "WSAEREMOTE - "}, <br> <br>/* <br>*    Extended Windows Sockets error constant definitions <br>*/ <br> <br>    {WSASYSNOTREADY,     "WSASYSNOTREADY - Network subsystem not ready"}, <br>    {WSAVERNOTSUPPORTED, "WSAVERNOTSUPPORTED - Version not supported"}, <br>    {WSANOTINITIALISED,  "WSANOTINITIALISED - WSAStartup() has not been successfully called"}, <br> <br>/* <br>*    Other error constants. <br>*/ <br> <br>    {WSAHOST_NOT_FOUND,  "WSAHOST_NOT_FOUND - Host not found"}, <br>    {WSATRY_AGAIN,       "WSATRY_AGAIN - Host not found or SERVERFAIL"}, <br>    {WSANO_RECOVERY,     "WSANO_RECOVERY - Non-recoverable error"}, <br>    {WSANO_DATA,         "WSANO_DATA - (or WSANO_ADDRESS) - No data record of requested type"}, <br>    {-1,                 NULL} <br>}; <br> <br>/* <br>*   Function Prototypes <br>*/ <br> <br>int mem_check(LPSTR, UCHAR, int); <br>extern int main(int, char **); <br>extern int net_init(SOCKET *); <br>extern int make_connection(SOCKET); <br>extern int do_send_receive(SOCKET); <br>extern void dos_net_perror(LPSTR ); <br>extern LPCSTR dos_net_strerror(LPSTR ); <br>extern LPCSTR get_error_text(int ); <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  main( int argc, char **argv ) <br>* <br>*    PURPOSE:   This is the main entry for the program <br>* <br>* <br>*    ARGUMENTS: argc = Number of arguments <br>*               argv = Array of ptrs to cmd line args <br>* <br>* <br>*        RETURNS:   Exit code for the program <br>* <br>*\***************************************************************************/ <br>int main(int argc, char **argv) <br>{ <br>    SOCKET s; <br> <br>   /* <br>   ** Read Local &amp; Remote Transport Address fields from user <br>   */ <br>   printf("LocalNetworkAddress(max. 20 chars) : "); <br>   scanf("%s", &amp;LocalNetworkAddress[0]); <br>   printf("LocalTsel : "); <br>   scanf("%d", &amp;LocalTsel); <br>   LocalNetworkAddressLength = strlen(LocalNetworkAddress) ; <br> <br>   printf("RemoteNetworkAddress(max. 20 chars) : "); <br>   scanf("%s", &amp;RemoteNetworkAddress[0]); <br>   printf("RemoteTsel : "); <br>   scanf("%d", &amp;RemoteTsel); <br>   RemoteNetworkAddressLength = strlen(RemoteNetworkAddress) ; <br> <br>printf("local Tsel(%d) Net_length(%d) Net(%s)\n", <br>        LocalTsel, LocalNetworkAddressLength, LocalNetworkAddress); <br>printf("Remote Tsel(%d) Net_length(%d) Net(%s)\n", <br>        RemoteTsel, RemoteNetworkAddressLength, RemoteNetworkAddress); <br> <br> <br>    /* <br>    *   Initialize the network and set up the socket <br>    */ <br> <br>    if (net_init(&amp;s)) <br>        return 1; <br> <br>    /* <br>    *   Try to connect to our server <br>    */ <br> <br>    if (make_connection(s)) <br>        return 1; <br> <br>    /* <br>    *   Send/receive data to/from server <br>    */ <br> <br>    do_send_receive(s); <br> <br>    /* <br>    *   All done - close up <br>    */ <br> <br>    if (verbose) <br>        printf("calling closesocket(socket = %d)\n", s); <br> <br>    closesocket(s); <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  net_init( SOCKET *skt ) <br>* <br>*    PURPOSE:   Initializes the WinSock stuff and sets up our socket. <br>* <br>* <br>*    ARGUMENTS: SOCKET * =&gt; struct to fill in with opened socket. <br>* <br>*        RETURNS:   0 if ok <br>*                               1 if error <br>* <br>*\***************************************************************************/ <br>int net_init(SOCKET *skt) <br>{ <br>    SOCKET s; <br>    int rc, addrlen; <br>    int reuse = 1; <br>    WSADATA wsdata; <br>    WORD    wVersionRequested; <br> <br>    wVersionRequested = MAKEWORD(1,1); <br> <br> <br>    /* <br>    *   Register with the socket library <br>    */ <br> <br>    rc = WSAStartup(wVersionRequested, &amp;wsdata); <br> <br>    if (verbose) <br>        printf("WSAStartup returned 0x%X\n", rc); <br> <br>    if (rc) { <br>        printf("WSAStartup failed: error = %d\n", rc); <br>        return 1; <br>    } <br> <br> <br>    /* <br>    *   Open a STREAMING socket <br>    */ <br> <br>    s = socket(Local_Address_Family, Socket_Type, Protocol); <br> <br>    if (verbose) <br>        printf("socket() returned 0x%X (%d)\n", s, s); <br> <br>    if (s == INVALID_SOCKET) { <br>        printf("socket call failed"); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Bind to any address <br>    */ <br> <br>    ISO_SET_TP_ADDR(&amp;addr, &amp;LocalTsel, sizeof(LocalTsel), <br>                        LocalNetworkAddress, LocalNetworkAddressLength); <br> <br>    rc = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char FAR *)&amp;reuse, sizeof(int)); <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("setsockopt call failed"); <br>        return 1; <br>    } <br> <br>    rc = bind(s, (const struct sockaddr *)&amp;addr, sizeof(SOCKADDR_TP)); <br> <br>    if (verbose) <br>        printf("bind() returned 0x%X\n", rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("bind call failed"); <br>        return 1; <br>    } <br> <br>    if (verbose) <br>        printf("calling getsockname(socket = %d)\n", s); <br> <br>    addrlen = sizeof(SOCKADDR_TP); <br>    rc = getsockname(s, (struct sockaddr *) &amp;addr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("getsockname() returned 0x%X\n", rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        printf("Error binding to socket"); <br>        closesocket(s); <br>        return 1; <br>    } <br>/* <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(addr.sa_netnum, "Bound address = ", "\n"); <br>    } <br>*/ <br> <br>    /* <br>    *   Build the address of the node to connect to <br>    */ <br>ISO_SET_TP_ADDR(&amp;caddr, &amp;RemoteTsel, sizeof(RemoteTsel), <br>                        RemoteNetworkAddress, RemoteNetworkAddressLength); <br> <br>/* <br>    caddr.sa_family = Remote_Address_Family; <br>    caddr.addr_type = HIERARCHICAL; <br>    caddr.taddr_len = RemoteNetworkAddressLength + RemoteTselLength; <br>    caddr.tsel_len = RemoteTselLength; <br>    memcpy(&amp;caddr.addr, RemoteTsel, RemoteTselLength); <br>    memcpy(&amp;caddr.addr[RemoteTselLength], <br>                RemoteNetworkAddress, RemoteNetworkAddressLength); <br>*/ <br> <br>    /* <br>    *   Set up socket for return <br>    */ <br> <br>    *skt = s; <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  make_connection( SOCKET s ) <br>* <br>*    PURPOSE:   Establishes a connection with our server. <br>* <br>*    ARGUMENTS: SOCKET socket to use for connection <br>* <br>*        RETURNS:   0 if ok <br>*                               1 if error <br>* <br>*\***************************************************************************/ <br>int make_connection(SOCKET s) <br>{ <br>    int rc, addrlen; <br> <br>    /* <br>    *   Connect <br>    */ <br> <br>    if (verbose) <br>        printf("calling connect(socket = %d)\n", s); <br> <br>    rc = connect(s, (const struct sockaddr FAR *)&amp;caddr, sizeof(SOCKADDR_TP)); <br> <br>    if (verbose) <br>        printf("connect() returned 0x%X\n", rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("connect call failed"); <br>        return 1; <br>    } <br> <br>    printf("Connect OK\n"); <br> <br>    /* <br>    *   Print out address we connected to <br>    */ <br> <br>    if (verbose) <br>        printf("calling getpeername(socket = %d)\n", s); <br> <br>    addrlen = sizeof(SOCKADDR_TP); <br>    rc = getpeername(s, (struct sockaddr *) &amp;caddr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("getpeername() returned 0x%X\n", rc); <br>/* <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(caddr.sa_netnum, "Remote Address = ", "\n"); <br>    } <br>*/ <br> <br>    return 0; <br>} <br>/**************************************************************************** <br>* <br>*    FUNCTION:  do_send_receive( SOCKET *s ) <br>* <br>*    PURPOSE:   Alternately sends/receives data to/from the server. <br>* <br>*    ARGUMENTS: SOCKET socket to transmit on <br>* <br>*        RETURNS:   0 if ok <br>*                               1 if error <br>* <br>*\***************************************************************************/ <br>int do_send_receive(SOCKET s) <br>{ <br>    int rc, errflag = 0; <br>    int sndpkts = 0, rcvpkts = 0; <br>    LPSTR sendbuf; <br> <br>    /* <br>    *   Allocate a send buffer <br>    */ <br> <br>    if (verbose) <br>        printf("Allocating %d bytes for send buffer \n"); <br> <br>    sendbuf = malloc(Send_Length); <br> <br>    if (!sendbuf) { <br>        printf("Error allocating %d bytes for send buffer\n"); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Send data and recv it back <br>    */ <br> <br>    while (1) { <br> <br>        /* <br>        *   Fill the buffer with our current character <br>        */ <br> <br>        memset(sendbuf, ch, Send_Length); <br> <br>        /* <br>        *   Send data <br>        */ <br> <br>        if (verbose) <br>            printf("calling send(socket = %d, length = %d)\n", s, Send_Length); <br> <br>        rc = send(s, sendbuf, Send_Length, 0); <br> <br>        if (verbose) <br>            printf("send() returned 0x%X\n", rc); <br> <br>        if (rc == SOCKET_ERROR) { <br>            printf("\nsend() call failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (verbose) <br>            printf("Sent packet %d: sent %d bytes\n", sndpkts++, rc); <br>        else <br>            printf("\rSent packet %d: sent %d bytes... ", sndpkts++, rc); <br> <br>        /* <br>        *   Receive the data back <br>        */ <br>/* <br>        if (verbose) <br>            printf("calling recv(socket = %d, length = %d)\n", s, Send_Length); <br> <br>        rc = recv(s, sendbuf, Send_Length, 0); <br> <br>        if (verbose) <br>            printf("recv() returned %d\n", rc); <br> <br>        if (rc == SOCKET_ERROR) { <br>            printf("\nrecv() call failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (!rc) { <br>            printf("connection has been lost\n"); <br>            break; <br>        } <br> <br>        printf("Received %d bytes", rc); <br>*/ <br>        if (verbose) <br>            printf("\n"); <br> <br>        /* <br>        *   See if our buffer has the same data in it <br>        */ <br> <br>        rc = mem_check(sendbuf, ch++, Send_Length); <br> <br>        if (rc) <br>            printf("Data compare error: packet = %d, offset = %d\n", (sndpkts-1), rc); <br>        else if (verbose) <br>            printf("Data compares okay\n"); <br> <br>        /* <br>        *   If we are to send just 1, break out <br>        */ <br> <br>        if (No_Loop) <br>            break; <br> <br>        /* <br>        *   Pause a little while (don't trash the network) <br>        Sleep(Sleep_Time); <br>        */ <br> <br>    } <br> <br>    if (verbose) <br>        printf("\nFreeing send buffer\n"); <br> <br>    free(sendbuf); <br> <br>    return errflag; <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  mem_check( LPSTR p, UCHAR ch, int len) <br>* <br>*    PURPOSE:   Makes sure that a buffer is filled with only the character <br>*                   specified. <br>* <br>*    ARGUMENTS: LPSTR   =&gt; buffer to scan <br>*               char    character to check for <br>*               int     length of buffer to check <br>* <br>*        RETURNS:   0 if buffer has only the specified character <br>*                               offset to non-matching character if found <br>* <br>************************************************************************/ <br>int mem_check(LPSTR p, UCHAR ch, int len) <br>{ <br>    int buflen; <br> <br>    buflen = len; <br> <br>    while (len--) { <br>        if ((UCHAR)*p++ != ch) { <br>            return (buflen - len); <br>        } <br>    } <br> <br>    return 0; <br>} <br> <br>void dos_net_perror(LPSTR p) <br>{ <br>    printf(dos_net_strerror(p)); <br>    printf("\n"); <br> <br>    return; <br>} <br> <br> <br> <br>LPCSTR dos_net_strerror(LPSTR p) <br>{ <br>    int error = 0; <br>    static char return_string[256]; <br> <br>    /* <br>    *   Get the error number from the system <br>    */ <br> <br>    error = h_errno; <br> <br>    /* <br>    *   Build the string to return <br>    */ <br> <br>    sprintf(return_string, "%s :(%d)%s", p, error, get_error_text(error)); <br> <br>    return (LPSTR)return_string; <br>} <br> <br>LPCSTR get_error_text(int error) <br>{ <br>    int search = 0; <br> <br> <br>    /* <br>    *   No error <br>    */ <br> <br>    if (!error) <br>        return (LPCSTR)msg_no_error; <br> <br>    /* <br>    *   Search through our array of error number / string pairs <br>    *   until we find a matching error number or get to the end <br>    *   of our list.  If we found a matching error number, <br>    *   return a LPSTR to the corresponding string. <br>    */ <br> <br>    while (errlist[search].errstr) { <br>        if (error == errlist[search].errnum) <br>            return errlist[search].errstr; <br>        search++; <br>    } <br> <br>    /* <br>    * If we didn't have the error in our list, return unkown <br>    */ <br> <br>    return (LPCSTR)msg_unknown_error; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
