<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SOCKSPX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5361"></a>SOCKSPX.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>/* <br>Module Name: <br> <br>    sockspx.c <br> <br>Abstract: <br> <br>    This module illustrates the Win32 Winsock APIs over IPX/SPX protocol <br>    sequence. <br> <br>    This example implements a client and a server. This example can use IPX, <br>    SPX as well as SPXII protocol sequences. The example has a number command <br>    line options. For example, <br> <br>    -s To run the example as a server. <br> <br>    -c To run the example as a client. <br>     <br>    -e &lt;Endpoint&gt; To specify an end point of your choice. This is a mandatory <br>parameter. Servers use this as the socket number to listen on, clients use <br>it as the socket number to connect to, on a specified host. <br> <br>    -n &lt;ServerIpxAddress&gt; To specify the server's IPX address. This is used by <br>clients. The address must be spcified as &lt;NetworkNumber.NodeNumber&gt;  <br>format, for example AABBCCDD.AABBCCDDEEFF. <br> <br>    -l &lt;LocalIpxAddress&gt; To specify the local IPX address. This is used by <br>clients and servers. The address must be spcified as &lt;NetworkNumber. <br>NodeNumber&gt; format, for example AABBCCDD.AABBCCDDEEFF. If an IPX address <br>is not specified the created sockets are bound to the default interface, <br>00000000.000000000000. <br> <br>    -p &lt;d or s or p&gt; To specify the protocol sequence to be used.  <br>'d' - datagram support, in this case IPX protocol sequence is used.  <br>'s' - SOCK_STREAM/SPXII protocol sequence is used(default protocol). <br>'p' - SOCK_SEQPACKET/SPXII protocol sequence isused. <br>    <br>    -m To Enumerate Local Addresses. This example can be used only to  <br>enumerate the local IPX adapters. This may be important before running the <br>client to know the server's IPX address. <br>        <br>To run the application as a server, the following command line can be  <br>specified: <br>     <br>sockspx -s -e 8000 -p s <br> <br>To run the application to act as a client, the following command line can be <br>specified: <br> <br>sockspx -c -n AABBCCDD.AABBCCDDEEFF -e 8000 -p s <br>     <br>To enumerate the local IPX adapters, the following command line will have <br>to be specified: <br> <br>sockspx -m <br>   <br>     <br>Author: <br> <br>    Rajesh Dadhia (rajeshd) 05-Mar-96 <br> <br>Revision History: <br> <br>*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;winsock.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnwlink.h&gt;  <br> <br>#define MAX_DATA_LEN 80 <br> <br>BOOL __stdcall <br>CtrlCHandler ( <br>    DWORD dwEvent <br>    ); <br> <br>void __stdcall <br>EnumerateAdapters ( void ); <br> <br>void  __stdcall <br>DoServer ( void ); <br> <br>void __stdcall  <br>DoClient ( void ); <br> <br>void __stdcall <br>DoStartup ( void ); <br> <br>void __stdcall <br>CreateSocket ( void ); <br> <br>void __stdcall <br>BindSocket (  <br>    SOCKADDR_IPX *psa,  <br>    LPSTR lpsAddress, <br>    LPSTR lpsEndpoint <br>    ); <br> <br>void _stdcall <br>FillIpxAddress (  <br>    SOCKADDR_IPX *psa,  <br>    LPSTR lpsAddress, <br>    LPSTR lpsEndpoint <br>    ); <br> <br>INT __stdcall  <br>SendData ( <br>    SOCKET s,  <br>    CHAR *pchBuffer  <br>    ); <br> <br>INT __stdcall <br>ReceiveData ( <br>    SOCKET s,  <br>    CHAR *pchBuffer <br>    ); <br> <br>INT __stdcall <br>SendDatagram ( <br>    SOCKET s,  <br>    CHAR *pchBuffer,  <br>    SOCKADDR_IPX *psa <br>    ); <br> <br>INT __stdcall <br>ReceiveDatagarm ( <br>    SOCKET s,  <br>    CHAR *pchBuffer,  <br>    SOCKADDR_IPX *psa,  <br>    INT *pcb ); <br> <br>void __stdcall <br>DoCleanup ( void ); <br> <br>void __stdcall <br>CheckParameters ( <br>    INT argc,  <br>    CHAR **argv <br>    ); <br> <br>BOOL __stdcall <br>CheckProtocol( <br>    CHAR chProtocol <br>); <br> <br>void __stdcall <br>Usage ( <br>    CHAR *pszProgramName <br>    ); <br> <br>void __stdcall  <br>PrintError ( <br>    CHAR *lpszRoutine, <br>    CHAR *lpszCallName, <br>    DWORD dwError <br>    ); <br> <br>void __stdcall <br>PrintIpxAddress( <br>    CHAR *lpsNetnum, <br>    CHAR *lpsNodenum <br>    ); <br> <br>void __stdcall <br>AtoH( <br>    CHAR *szDest,  <br>    CHAR *szSource, <br>    INT iCount <br>    ); <br> <br>UCHAR __stdcall <br>BtoH( <br>    CHAR ch <br>); <br> <br>// <br>// Global Variables <br>// <br> <br>// Role of the Application  <br>BOOL fServer = TRUE, <br> <br>// Enumerate the Local Adapters  <br>     fEnumerate = FALSE, <br> <br>// WSAStartup () was sucessfull  <br>     fStarted = FALSE; <br> <br>// Global socket handles  <br>SOCKET sock = INVALID_SOCKET, <br>       newsock = INVALID_SOCKET; <br> <br>// Server's IPX address string <br>CHAR *pszServerAddress, <br> <br>// Local IPX address string  <br>     *pszLocalAddress, <br> <br>// Server's Endpoint(socket) string  <br>     *pszServerEndpoint, <br> <br>// Protocol type (Datagram, Stream, Sequenced Packet) <br>     chProtocol = 's'; <br> <br>void __cdecl <br>main ( <br>    INT argc, <br>    CHAR **argv <br>    ) <br>{ <br>     <br>    // <br>    // Install the CTRL+BREAK Handler <br>    // <br>    if ( FALSE == SetConsoleCtrlHandler ( (PHANDLER_ROUTINE) CtrlCHandler, <br>  TRUE  <br>  ) )  <br>    { <br>PrintError ( "main", "SetConsoleCtrlHandler", GetLastError ( ) ); <br>    } <br> <br>    // <br>    // Parse the command line parameters <br>    // <br>    CheckParameters ( argc, argv ); <br> <br>    // <br>    // Check to see if the role of the application is to enumerate local  <br>    // adapters <br>    // <br>    if ( TRUE == fEnumerate ) <br>    { <br>EnumerateAdapters ( ); <br>return; <br>    } <br> <br>    // <br>    // Act as a server <br>    // <br>    if( TRUE == fServer ) <br>    { <br>DoServer ( ); <br>return; <br>    } <br> <br>    // <br>    // Act as client <br>    // <br>    else <br>    { <br>DoClient ( ); <br>return; <br>    }                                                        <br>} <br> <br>// <br>// CtrlCHandler () intercepts the CTRL+BREAK or CTRL+C events and calls the <br>// cleanup routines <br>// <br>BOOL __stdcall <br>CtrlCHandler ( <br>    DWORD dwEvent <br>) <br>{ <br>   <br>    if ( ( CTRL_C_EVENT == dwEvent ) || ( CTRL_BREAK_EVENT == dwEvent ) ) <br>    { <br>DoCleanup ( );     <br>    } <br> <br>    return FALSE; <br>} <br>   <br>// <br>// EnumerateAdapters () will enumerate the available IPX adapters and print <br>// the addresses <br>// <br>void __stdcall <br>EnumerateAdapters ( void ) <br>{ <br>  SOCKADDR_IPX sa_ipx; <br>  IPX_ADDRESS_DATA ipx_data; <br>  INT iRetVal, cb, nAdapters, i=0; <br> <br>    //         <br>    // Initialize the Winsock 1.1 DLL <br>    // <br>    DoStartup ( ); <br> <br>    // <br>    // Create a local socket <br>    // <br>    chProtocol = 'd'; <br>    CreateSocket ( ); <br> <br>    // <br>    // Bind to a local address and endpoint <br>    // <br>    BindSocket ( &amp;sa_ipx, NULL, NULL ); <br>     <br>    // <br>    // Call getsockopt() see the total number of adapters <br>    // <br>    cb = sizeof ( nAdapters ); <br>    iRetVal = getsockopt ( sock,  <br>   NSPROTO_IPX,  <br>   IPX_MAX_ADAPTER_NUM, <br>   (CHAR *) &amp;nAdapters, <br>   &amp;cb  <br>   ); <br>     <br>    if ( SOCKET_ERROR == iRetVal ) <br>    { <br>PrintError ( "EnumerateAdapters",  <br>     "getsockopt",  <br>     WSAGetLastError ( )  <br>     ); <br>    } <br>    fprintf ( stdout, "Total number of adapters -&gt; %d\n", nAdapters ); <br> <br>    // <br>    // Get the address of each adapter <br>    // <br>    while ( nAdapters &gt; 0 ) <br>    {                                                 <br>memset ( &amp;ipx_data, 0, sizeof ( ipx_data ) ); <br>ipx_data.adapternum = (nAdapters -1); <br>cb = sizeof ( ipx_data ); <br> <br>iRetVal = getsockopt ( sock, <br>       NSPROTO_IPX, <br>       IPX_ADDRESS, <br>       (CHAR *) &amp;ipx_data, <br>       &amp;cb  <br>       ); <br> <br>if ( SOCKET_ERROR == iRetVal ) <br>{ <br>    PrintError ( "EnumerateAdapters",  <br> "getsockopt",  <br> WSAGetLastError ( )  <br> ); <br>} <br>     <br>//    <br>// Print each address <br>// <br>PrintIpxAddress ( ipx_data.netnum, ipx_data.nodenum ); <br>nAdapters--;                                                          <br>    } <br>     <br>    // <br>    // Call the cleanup routine <br>    // <br>    DoCleanup ( ); <br>    return; <br>} <br> <br>// <br>// DoServer () performs the connection-less/connection-oriented server <br>// related tasks <br>// <br>void  __stdcall <br>DoServer ( void ) <br>{                         <br>  // Address structures for the client and the server <br>  SOCKADDR_IPX sa_ipx, sa_ipx_client;      <br> <br>  // Buffer for the received/sent data <br>  CHAR chBuffer[MAX_DATA_LEN]; <br> <br>  INT iRetVal, cb; <br> <br>    DoStartup ( ); <br>    <br>    CreateSocket ( ); <br> <br>    // <br>    // Bind to a local address and endpoint <br>    // <br>    BindSocket ( &amp;sa_ipx, pszLocalAddress, pszServerEndpoint); <br> <br>    // <br>    // Check the Specified protocol. Call listen(), accept() if a connection  <br>    // oriented protocol is specified <br>    // <br>    if ( 'd' != chProtocol   ) <br>    { <br>iRetVal = listen ( sock, 5 ); <br> <br>if ( SOCKET_ERROR == iRetVal ) <br>{ <br>    PrintError ( "DoServer", "listen", WSAGetLastError ( ) ); <br>} <br>     <br>fprintf ( stdout, "Waiting for a Connection...\n"); <br>fprintf ( stdout, "Press &lt;CTRL+C&gt; or &lt;CTRL+BREAK&gt; to exit\n"); <br>// <br>// Wait for a connection <br>// <br>cb = sizeof ( sa_ipx_client ); <br>newsock = accept ( sock,  <br>   (SOCKADDR *) &amp;sa_ipx_client,  <br>   &amp;cb  <br>   ); <br> <br>if ( INVALID_SOCKET == newsock ) <br>{ <br>    PrintError ( "DoServer", "accept", WSAGetLastError ( ) ); <br>} <br>     <br>// <br>// Print the address of connected client <br>// <br>fprintf ( stdout, "Connected to Client Address - " ); <br>PrintIpxAddress ( sa_ipx_client.sa_netnum, sa_ipx_client.sa_nodenum ); <br> <br>// <br>// Receive data on newly created socket <br>// <br>iRetVal = ReceiveData ( newsock, chBuffer ); <br> <br>// <br>// Print the contents of received data <br>// <br>chBuffer[iRetVal] = '\0'; <br>fprintf ( stdout,"%d bytes of data received-&gt;%s\n",iRetVal, chBuffer ); <br>strcpy ( chBuffer, "Hello SPX Client" );  <br> <br>// <br>// Send data on newly created socket <br>// <br>iRetVal = SendData ( newsock, chBuffer ); <br>fprintf ( stdout, "%d bytes of data sent\n", iRetVal ); <br>    } <br>    // <br>    // Server will receive and send datagrams <br>    // <br>    else  <br>    { <br>// <br>// Receive a datagram on the bound socket <br>// <br>cb = sizeof ( sa_ipx_client ); <br>iRetVal = ReceiveDatagarm ( sock, chBuffer, &amp;sa_ipx_client, &amp;cb ); <br> <br>// <br>// Print the contents of received datagram and the senders address <br>// <br>fprintf ( stdout, "Message Received from Client Address - " ); <br>PrintIpxAddress( sa_ipx_client.sa_netnum, sa_ipx_client.sa_nodenum ); <br>chBuffer[iRetVal] = '\0'; <br>fprintf( stdout, "Data Received-&gt;%s\n", chBuffer ); <br>fprintf( stdout,"%d bytes of data received-&gt;%s\n",iRetVal, chBuffer ); <br> <br>// <br>// Send a datagram on the bound socket to the client <br>// <br>strcpy ( chBuffer, "Hello IPX Client" );  <br>iRetVal = SendDatagram (sock, chBuffer, &amp;sa_ipx_client ); <br>fprintf( stdout, "%d bytes of data sent\n", iRetVal ); <br>    } <br> <br>    //  <br>    // Call the cleanup routine <br>    // <br>    DoCleanup ( ); <br>    return; <br>} <br> <br>// <br>// DoClient () performs the connection-less/connection-oriented client <br>// related tasks <br>// <br>void __stdcall  <br>DoClient ( void ) <br>{                                                 <br>  // Address structures for the client and the server <br>  SOCKADDR_IPX sa_ipx, sa_ipx_server;      <br>     <br>  // Buffer for the received/sent data <br>  CHAR chBuffer[MAX_DATA_LEN];             <br>  <br>  INT iRetVal, cb; <br> <br>    DoStartup ( ) ; <br> <br>    CreateSocket ( ); <br>     <br>    // <br>    // Bind to a local address and endpoint <br>    // <br>    BindSocket ( &amp;sa_ipx, pszLocalAddress, NULL); <br> <br>     <br>    if ( NULL == pszServerEndpoint ) <br>    { <br>fprintf ( stdout, "Server Endpoint must be specified....Exiting\n"); <br>DoCleanup ( ); <br>exit ( 1 ); <br>    } <br> <br>    // <br>    // Fill the sa_ipx_server address address with server address and endpoint <br>    // <br>    if ( NULL != pszServerAddress ) <br>    { <br>FillIpxAddress ( &amp;sa_ipx_server, pszServerAddress, pszServerEndpoint ); <br>    } <br>    else <br>    { <br>fprintf ( stdout, "Server Address must be specified....Exiting\n"); <br>DoCleanup ( ); <br>exit ( 1 ); <br>    } <br> <br>    // <br>    // Check the Specified protocol. Call connect() if a connection oriented  <br>    // protocol is specified <br>    // <br>    if ( chProtocol != 'd' ) <br>    { <br>fprintf(stdout, "Connecting to Server -"); <br>PrintIpxAddress ( sa_ipx_server.sa_netnum, sa_ipx_server.sa_nodenum ); <br>     <br>// <br>// Connect to the server <br>// <br>iRetVal = connect ( sock,  <br>    (SOCKADDR *) &amp;sa_ipx_server, <br>    sizeof sa_ipx_server <br>    ); <br> <br>if ( SOCKET_ERROR == iRetVal ) <br>{ <br>    PrintError ( "DoClient", "connect", WSAGetLastError ( ) ); <br>} <br>    <br>fprintf ( stdout, "Connected to Server Address - " ); <br>PrintIpxAddress( sa_ipx_server.sa_netnum, sa_ipx_server.sa_nodenum ); <br> <br>// <br>// Send data to the specfied server <br>// <br>strcpy ( chBuffer, "Hello SPX Server" );  <br>iRetVal = SendData ( sock, chBuffer ); <br>fprintf( stdout, "%d bytes of data sent\n", iRetVal ); <br> <br>// <br>// Receive data from the server <br>// <br>iRetVal = ReceiveData ( sock, chBuffer ); <br> <br>// <br>// Print the contents of received data <br>// <br>chBuffer[iRetVal] = '\0'; <br>fprintf( stdout, "%d bytes of data received-&gt;%s\n", iRetVal,chBuffer); <br>    } <br>    else <br>    { <br>// <br>// Send a datagram to the specified server <br>// <br>strcpy ( chBuffer, "Hello IPX Server" );  <br>iRetVal = SendDatagram ( sock, chBuffer, &amp;sa_ipx_server ); <br>fprintf ( stdout, "%d bytes of data sent\n", iRetVal ); <br> <br>// <br>// Receive a datagram from the server <br>// <br>cb = sizeof sa_ipx_server; <br>iRetVal = ReceiveDatagarm ( sock, chBuffer, &amp;sa_ipx_server, &amp;cb ); <br> <br>// <br>// Print the contents of received data <br>// <br>chBuffer[iRetVal] = '\0'; <br>fprintf ( stdout, "%d bytes of data received-&gt;%s\n",iRetVal,chBuffer); <br>    } <br> <br>    // <br>    // Call the cleanup routine <br>    // <br>    DoCleanup ( ); <br> <br>    return; <br>} <br> <br>// <br>// DoStartup() initializes the Winsock DLL with Winsock version 1.1 <br>// <br>void __stdcall <br>DoStartup ( void ) <br>{ <br>  WSADATA wsaData; <br>  INT iRetVal; <br> <br>    iRetVal = WSAStartup ( MAKEWORD ( 1,1 ), &amp;wsaData ); <br> <br>    if ( 0 != iRetVal) <br>    { <br>    PrintError ( "DoStartup", "WSAStartup", iRetVal ); <br>    } <br>     <br>    /* Set the global flag */ <br>    fStarted = TRUE; <br>  <br>    return; <br>} <br> <br>// <br>// CreateSocket() creates an endpoint (socket) and assigns the returned value <br>// from socket() to the global socket descriptor 'sock'. The actual protocol <br>// specified on the command line is checked, in order to make the socket() <br>// call correctly. <br>// <br>void __stdcall <br>CreateSocket ( void ) <br>{ <br>    sock = socket ( AF_IPX, <br>    chProtocol == 'd' ? SOCK_DGRAM :  <br>    ( chProtocol == 's'  ? SOCK_STREAM : SOCK_SEQPACKET), <br>    chProtocol == 'd' ? NSPROTO_IPX : NSPROTO_SPXII <br>    ); <br>     <br>    if ( INVALID_SOCKET == sock ) <br>    { <br>PrintError ( "CreateSocket", "socket", WSAGetLastError ( ) ); <br>    } <br>     <br>    return; <br>} <br> <br>// <br>// BindSocket() binds the global socket descriptor 'sock' to the specified <br>// address. If an endpoint is specified it uses that or it binds to a system  <br>// assigned port. <br>// <br>void __stdcall <br>BindSocket (  <br>    SOCKADDR_IPX *psa,  <br>LPSTR lpsAddress, <br>LPSTR lpsEndpoint <br>) <br>{ <br>  INT iRetVal; <br> <br>    // <br>    // Fill the givenSOCKADDR_IPX structure <br>    // <br>    FillIpxAddress ( psa, lpsAddress, lpsEndpoint ); <br> <br>    iRetVal = bind ( sock,  <br>     (SOCKADDR *) psa,  <br>     sizeof (SOCKADDR_IPX)  <br>     ); <br>     <br>    if ( SOCKET_ERROR == iRetVal ) <br>    { <br>PrintError ( "BindSocket", "bind", WSAGetLastError ( ) ); <br>    } <br> <br>    //  <br>    // Print the address we are bound to. If a particular interface is not <br>    // mentioned in the BindSocket() call, this may print the address as <br>    // 00000000.0000000000000000. This is because of the fact that an  <br>    // interface is picked only when the actual connection establishment  <br>    // occurs, in case of connection oriented socket. <br>    // <br>    fprintf ( stdout, "Bound to Local Address - " ); <br>    PrintIpxAddress( psa-&gt;sa_netnum, psa-&gt;sa_nodenum ); <br> <br>    return; <br>} <br> <br>// <br>// FillIpxAddress() fills a structure of type SOCKADDR_IPX with relevant <br>// address-family, network number, node number and socket (endpoint) <br>// parameters. <br>// <br>void _stdcall <br>FillIpxAddress (  <br>    SOCKADDR_IPX *psa,  <br>    LPSTR lpsAddress, <br>    LPSTR lpsEndpoint <br>    ) <br>{ <br>  // Location of the separator <br>  LPSTR pszPoint;                  <br>   <br>    ZeroMemory ( psa, sizeof ( SOCKADDR_IPX ) ); <br> <br>    psa-&gt;sa_family = AF_IPX; <br> <br>    // <br>    // Check if an address is specified <br>    // <br>    if ( NULL != lpsAddress ) <br>    { <br>// <br>// Get the offset for node number/network number separator <br>// <br>pszPoint = strchr ( lpsAddress, '.' ); <br> <br>if ( NULL == pszPoint ) <br>{ <br>    fprintf ( stderr, "IPX Address does not have a separator\n"); <br>    DoCleanup ( ); <br>    exit ( 1 ); <br>} <br> <br>// <br>// covert the address in the  string format to binary format <br>// <br>AtoH ( (CHAR *) psa-&gt;sa_netnum, lpsAddress, 4 ); <br>AtoH ( (CHAR *) psa-&gt;sa_nodenum, pszPoint + 1, 6 ); <br> <br>    } <br>     <br>    if ( NULL != lpsEndpoint ) <br>    { <br>    psa-&gt;sa_socket = (USHORT) atoi ( lpsEndpoint ); <br>    } <br> <br>    return; <br>} <br> <br>// <br>// SendData() is generic rotuine to send some data over a  <br>// connection-oriented IPX socket. <br>// <br>INT __stdcall  <br>SendData ( <br>    SOCKET s,  <br>    CHAR *pchBuffer  <br>    ) <br>{ <br>  INT iRetVal; <br> <br>    iRetVal = send ( s,  <br>     pchBuffer,   <br>     strlen ( pchBuffer ),  <br>     0 <br>     ); <br> <br>    if ( SOCKET_ERROR == iRetVal ) <br>    { <br>PrintError ( "SendData", "send", WSAGetLastError ( ) ); <br>    } <br>     <br>    // <br>    // return the total number of bytes sent <br>    // <br>    return iRetVal; <br>} <br> <br>// <br>// ReceiveData() is generic rotuine to receive some data over a  <br>// connection-oriented IPX socket. <br>// <br>INT __stdcall <br>ReceiveData ( <br>    SOCKET s,  <br>    CHAR *pchBuffer <br>    ) <br>{ <br>  INT iRetVal; <br> <br>    iRetVal = recv ( s,  <br>     pchBuffer,  <br>     MAX_DATA_LEN,  <br>     0 <br>     ); <br>     <br>    if ( SOCKET_ERROR == iRetVal ) <br>    { <br>PrintError ( "ReceiveData", "recv", WSAGetLastError ( ) ); <br>    } <br>     <br>    // <br>    // return the total number of bytes received <br>    // <br>    return iRetVal; <br>} <br> <br>// <br>// SendDatagram() is generic rotuine to send a datagram to a <br>// specifid host. <br>// <br>INT __stdcall <br>SendDatagram ( <br>    SOCKET s,  <br>    CHAR *pchBuffer,  <br>    SOCKADDR_IPX *psa <br>    ) <br>{ <br>  INT iRetVal; <br> <br>    iRetVal = sendto ( s,  <br>       pchBuffer,   <br>       strlen ( pchBuffer ),  <br>       0, <br>       (SOCKADDR *) psa, <br>       sizeof ( SOCKADDR_IPX ) <br>       ); <br>  <br>    if ( SOCKET_ERROR == iRetVal ) <br>    { <br>    PrintError ( "SendDatagram", "sendto", WSAGetLastError ( ) ); <br>    } <br> <br>    /* return the total number of bytes sent in the datagram */ <br>    return iRetVal;      <br> } <br> <br>// <br>// ReceiveDatagram() is generic rotuine to receive a datagram from a <br>// specifid host. <br>// <br>INT __stdcall <br>ReceiveDatagarm ( <br>    SOCKET s,  <br>    CHAR *pchBuffer,  <br>    SOCKADDR_IPX *psa,  <br>    INT *pcb ) <br>{ <br>  INT iRetVal; <br>     <br>    iRetVal = recvfrom ( s,  <br> pchBuffer,  <br> MAX_DATA_LEN,  <br> 0, <br> (SOCKADDR *) psa, <br> pcb <br> ); <br>     <br>    if ( SOCKET_ERROR == iRetVal ) <br>    { <br>    PrintError ( "ReceiveDatagram", "recvfrom", WSAGetLastError ( ) ); <br>    } <br> <br>    // <br>    // return the total number of bytes received in the datagram <br>    // <br>    return iRetVal; <br>} <br>  <br>// <br>// DoCleanup () will close the sockets which were opened successfully using  <br>// a call to socket (). Additionally, it will call WSACleanup (), if a call <br>// to WSAStartup () was made successfully. <br>// <br>void __stdcall <br>DoCleanup ( void ) <br>{ <br>    if ( INVALID_SOCKET != sock ) <br>    { <br>    closesocket ( sock ); <br>    } <br> <br>    if ( INVALID_SOCKET != newsock ) <br>    { <br>    closesocket ( sock ); <br>    } <br> <br>    if ( TRUE == fStarted ) <br>    { <br>    WSACleanup ( ); <br>    } <br> <br>    fprintf ( stdout, "DONE\n"); <br> <br>    return; <br>} <br> <br>// <br>// CheckParameters() parses the command line parametrs. <br>// <br>void __stdcall <br>CheckParameters ( <br>    INT argc,  <br>    CHAR **argv <br>    ) <br>{ <br>    INT i; <br> <br>    for ( i = 1; i &lt; argc; i++ )  <br>    { <br>if ( ( *argv[i] == '-') || ( *argv[i] == '/' ) )  <br>{ <br>    switch ( tolower ( *( argv[i]+1 ) ) )  <br>    { <br>     <br>// <br>// Role of the application - server <br>// <br>case 's':                             <br>    fServer = TRUE; <br>    break; <br>     <br>// <br>// Role of the application - client <br>// <br>case 'c':                             <br>    fServer = FALSE; <br>    break; <br>     <br>// <br>// Store a pointer to the server endpoint <br>// <br>case 'e': <br>    pszServerEndpoint = argv[++i];    <br>    break; <br>     <br>// <br>// Store a pointer to the server address <br>// <br>case 'n': <br>    pszServerAddress = argv[++i];     <br>    break; <br>  <br>// <br>// Store a pointer to the local address <br>// <br>case 'l': <br>    pszLocalAddress = argv[++i];      <br>    break; <br> <br>     <br>// <br>// Set the flag to indicate enumeration of local adapters <br>// <br>case 'm': <br>    fEnumerate = TRUE;                <br>    break; <br> <br>// <br>// Read and validate the protocol specified <br>// <br>case 'p': <br>    chProtocol = tolower ( *argv[++i] ); <br>    if ( FALSE == CheckProtocol ( chProtocol ) ) <br>    { <br>fprintf ( stderr, "UnKnown protcol specified\n\n"); <br>Usage ( argv[0] ); <br>    } <br>    break; <br>    // <br>    // Help <br>    // <br>    case 'h': <br>    case '?': <br>    default: <br>Usage ( argv[0] ); <br>    } <br>} <br>// <br>// Help <br>// <br>else <br>    Usage ( argv[0] ); <br>    }     <br>    return; <br>} <br> <br>// <br>// CheckProtocol() checks if a valid protocol is specified on the command <br>// line. <br>// <br>BOOL __stdcall <br>CheckProtocol( <br>    CHAR chProtocol <br>) <br>{ <br>    if ( 'd' != chProtocol &amp;&amp; 's' != chProtocol &amp;&amp; 'p' != chProtocol ) <br>    { <br>return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>// <br>// Display the usage of command line parameters. <br>// <br>void __stdcall <br>Usage ( <br>    CHAR *pszProgramName <br>    ) <br>{ <br>    fprintf ( stderr,"Usage:  %s\n", pszProgramName ); <br>    fprintf ( stderr,  <br>    "\t-s or -c (s - server, c - client, default - server)\n" ); <br>    fprintf ( stderr, "\t-e &lt;Endpoint&gt;\n" ); <br>    fprintf ( stderr, "\t-n &lt;ServerIpxAddress&gt;\n" );     <br>    fprintf ( stderr, "\t-l &lt;LocalIpxAddress&gt;\n" );     <br>    fprintf ( stderr, <br>"\t-p &lt;d or s or p&gt; ( d - datagram, s - stream, p - sequenced packet)\n" ); <br>    fprintf ( stderr, "\t-m To Enumerate Local Addresses\n" ); <br>        <br>    exit ( 1 ); <br>} <br> <br>// <br>// PrintError () is a generic routine to print the Winsock or Win32  <br>// error codes for the errors occurred during relevant calls. <br>// If an error occurs, the error code is printed, cleanup routine is  <br>// called and the application exits. <br>// <br>void __stdcall  <br>PrintError ( <br>    CHAR *lpszRoutine, <br>    CHAR *lpszCallName, <br>    DWORD dwError <br>    ) <br>{ <br>    fprintf ( stderr, <br>      "The Call to %s() in the Routine %s() failed with Error %d\n", <br>      lpszCallName,  <br>      lpszRoutine,  <br>      dwError <br>      ); <br> <br>    DoCleanup ( ); <br>    exit ( 1 ); <br>} <br> <br>// <br>// Print an IPX address. <br>//  <br>void __stdcall <br>PrintIpxAddress( <br>    CHAR *lpsNetnum, <br>    CHAR *lpsNodenum <br>    ) <br>{ <br>  INT i; <br> <br>    for ( i = 0; i &lt; 4; i++ ) <br>    { <br>fprintf ( stdout, "%02X", (UCHAR) lpsNetnum[i] ); <br>    } <br> <br>    fprintf ( stdout, "." ); <br>     <br>    for ( i = 0; i &lt; 6; i++ ) <br>    { <br>fprintf ( stdout, "%02X", (UCHAR) lpsNodenum[i] ); <br>    } <br> <br>    fprintf ( stdout, "\n" ); <br> <br>    return; <br>} <br> <br>// <br>// AtoH () coverts the IPX address specified in the string(ascii) format to  <br>// the binary(hexadecimal) format. <br>// <br>void __stdcall <br>AtoH( <br>    CHAR *szDest,  <br>    CHAR *szSource, <br>    INT iCount <br>    ) <br>{ <br>    while (iCount--) <br>    { <br>*szDest++ = ( BtoH ( *szSource++ ) &lt;&lt; 4 ) + BtoH ( *szSource++ ); <br>    } <br>    return; <br>} <br> <br>// <br>// BtoH () returns the equivalent binary value for an individual <br>// character specified in the ascii format. <br>// <br>UCHAR __stdcall <br>BtoH( <br>    CHAR ch <br>    ) <br>{ <br> <br>    if ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) <br>    { <br>    return ( ch - '0' ); <br>    } <br> <br>    if ( ch &gt;= 'A' &amp;&amp; ch &lt;= 'F' ) <br>    { <br>    return ( ch - 'A' + 0xA ); <br>    } <br> <br>    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f' ) <br>    { <br>    return ( ch - 'a' + 0xA ); <br>    } <br> <br>    // <br>    // Illegal values in the IPX address will not be excepted <br>    // <br>    fprintf( stderr,  <br>    "Illegal value specified in  one of the IPX Addresses-BtoH Failed\n" ); <br> <br>    DoCleanup ( ); <br> <br>    exit ( 1 ); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
