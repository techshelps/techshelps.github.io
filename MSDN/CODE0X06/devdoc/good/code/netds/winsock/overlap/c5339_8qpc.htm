<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OVERLAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5340"></a>OVERLAP.C</h2>
<pre><code>/******************************************************************************\ <br>* Sample demonstrating use of Events in Overlapped (Asynchronous) I/O <br>* <br>* This code uses AcceptEx() <br>* YOU MUST HAVE SERVICE PACK 3 on NT 3.51 to use it !!! <br>* <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;winsock2.h&gt; <br>#include &lt;mswsock.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#define DEFAULT_PORT 5001 <br>#define MAX_IO_PEND 10// maximum pending I/O requests <br> <br>#define OP_READ 0x10 <br>#define OP_WRITE 0x20 <br> <br>#define xmalloc(s) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,(s)) <br>#define xfree(p)   HeapFree(GetProcessHeap(),0,(p)) <br> <br>// <br>// This structure keeps some useful information <br>// <br>typedef struct _socklist { <br>SOCKET sock; <br>OVERLAPPED *overlap; <br>char Buffer[128]; <br>}Socklist; <br> <br>int curr_size; //current number of handles we are intersted in <br> <br>int DoWait(HANDLE *,Socklist *) ; <br>void HandleEvent(int , HANDLE *,Socklist *) ; <br> <br>void Usage(char *progname) { <br>fprintf(stderr,"Usage\n%s -e [endpoint] -i [interface]\n", <br>progname); <br>fprintf(stderr,"Where:\n"); <br>fprintf(stderr,"\tendpoint is the port to listen on\n"); <br>fprintf(stderr,"\tinterface is the ipaddr (in dotted decimal notation)"); <br>fprintf(stderr," to bind to\n"); <br>fprintf(stderr,"Defaults are 5001 and INADDR_ANY\n"); <br>WSACleanup(); <br>exit(1); <br>} <br> <br>int main(int argc, char **argv) { <br> <br>char *interface= NULL; <br>char *Buffer = xmalloc(256); <br>unsigned short port=DEFAULT_PORT; <br>int i; <br>struct sockaddr_in local; <br>WSADATA wsaData; <br>SOCKET listen_socket, accept_sock; <br>OVERLAPPED *Overlap; <br>DWORD bytes_read; <br>DWORD lasterror; <br>// <br>// Handles is the array that stores the Event Handles <br> <br>HANDLE Handles[MAX_IO_PEND] ; <br> <br>// <br>// socklist is a parallel array that keeps state information for <br>// each Handle. <br>Socklist socklist[MAX_IO_PEND]; <br> <br>/* Parse arguments */ <br>if (argc &gt;1) { <br>for(i=1;i &lt;argc;i++) { <br>if ( (argv[i][0] == '-') || (argv[i][0] == '/') ) { <br>switch(tolower(argv[i][1])) { <br> <br>case 'i': <br>interface = argv[++i]; <br>break; <br>case 'e': <br>port = atoi(argv[++i]); <br>break; <br>default: <br>Usage(argv[0]); <br>break; <br>} <br>} <br>else <br>Usage(argv[0]); <br>} <br>} <br> <br>if (WSAStartup(0x202,&amp;wsaData) == SOCKET_ERROR) { <br>fprintf(stderr,"WSAStartup failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br>if (port == 0){ <br>Usage(argv[0]); <br>} <br> <br>local.sin_family = AF_INET; <br>local.sin_addr.s_addr = (!interface)?INADDR_ANY:inet_addr(interface);  <br> <br>/*  <br> * Port MUST be in Network Byte Order <br> */ <br>local.sin_port = htons(port); <br> <br>listen_socket = socket(AF_INET,SOCK_STREAM,0); // TCP socket <br>if(listen_socket == INVALID_SOCKET) { <br>fprintf(stderr,"socket() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br> <br>if (bind(listen_socket,(struct sockaddr*)&amp;local,sizeof(local) )  <br>== SOCKET_ERROR) { <br>fprintf(stderr,"bind() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br> <br> <br>if (listen(listen_socket,5) == SOCKET_ERROR) { <br>fprintf(stderr,"listen() failed with error %d\n",WSAGetLastError()); <br>WSACleanup(); <br>return -1; <br>} <br>printf("%s: Listening on port %d\n",argv[0],port); <br> <br>// <br>// Add the listening socket to our state information for the handle. <br>// <br>socklist[0].sock = listen_socket; <br> <br>curr_size =1; <br> <br>for(i=1;i&lt;MAX_IO_PEND;i++) <br>Handles[i] = INVALID_HANDLE_VALUE; <br> <br>// <br>// The structure of the following loop is very similar to a situation <br>// where select() might be used.  <br>// We use WaitForSingleObject to multiplex between incoming/outgoing <br>// data on existing connections. <br>// <br>// We don't queue an AcceptEx() until someone actually connects to  <br>// the previous socket. This is to keep the code simple, not a limitation <br>// of the API itself. <br> <br>while(1) { <br> <br>// create a socket for AcceptEx() <br> <br>accept_sock = socket(AF_INET,SOCK_STREAM,0); <br> <br>// <br>// Allocate an overlapped structure. <br>// We use the Offset field to keep track of the socket handle <br>// we have accpeted a connection on, since there is no other <br>// way to pass information to GetOverlappedResult() <br>// <br>Overlap = xmalloc(sizeof(OVERLAPPED)); <br>Overlap-&gt;Offset = accept_sock; <br> <br>Overlap-&gt;hEvent = CreateEvent(NULL, <br> TRUE,//manual reset <br> FALSE, // initially non-signalled <br> NULL); <br> <br>if (!Overlap-&gt;hEvent) { <br>fprintf(stderr,"CreateEvent failed %d\n",GetLastError()); <br>return -1; <br>} <br>// <br>// Set the appropriate array members <br>// <br>Handles[0] = Overlap-&gt;hEvent; <br>socklist[0].overlap = Overlap; <br> <br>// AcceptEx() <br>if (!AcceptEx(listen_socket, <br>  accept_sock, <br>  Buffer, <br>  0, // read nothing from the socket <br>  sizeof(struct sockaddr_in) +16, <br>  sizeof(struct sockaddr_in) +16, <br>  &amp;bytes_read, <br>  Overlap)){ <br>lasterror=WSAGetLastError(); <br>if(lasterror!=ERROR_IO_PENDING){ <br>fprintf(stderr,"acceptex failed %d\n",lasterror); <br>return -1; <br>} <br>} <br>// <br>// This loop simple checks the handles to see which one is  <br>// signalled.  <br>// If error, exit.  <br>// If there is a new incoming connection, we break to the outer loop <br>// queue another AcceptEx() <br>// <br>while(1){ <br>i = DoWait(Handles,socklist); <br>if (i&lt;0) <br>break; <br>HandleEvent(i,Handles,socklist); <br>if (i ==0) <br>break; <br>}; <br>if (i &lt; 0) <br>return -1; <br> <br>} <br>} <br>/* <br> * This is the main function that handles all the events occuring on the <br> * different handles we are watching. <br> * <br> * Parameters: <br> *          index: Index into the Handles[] array. Returned by DoWait() <br> *          Handles: Array of Event Handles we are watching <br> *          socklist: Helper parallel array of state information <br> * <br> */ <br>void HandleEvent(int index, HANDLE *Handles,Socklist *socklist) { <br> <br>OVERLAPPED *Overlap; <br>SOCKET newsock; <br>DWORD bytes,overlap_err=0,lasterr; <br> <br>Overlap = socklist[index].overlap; <br>// <br>// Check the specified handle <br>// <br>// If a socket is closed by the other side, the error returned is <br>// ERROR_NETNAM_DELETED <br>// <br>if(!GetOverlappedResult(Handles[index], Overlap, &amp;bytes, TRUE) ) { <br>fprintf(stderr,"GetOverlappedResult failed with error %d\n", <br>overlap_err=GetLastError()); <br>if (overlap_err  != ERROR_NETNAME_DELETED)  <br>return; <br>} <br>newsock = Overlap-&gt;Offset; <br>// <br>// If the other side closed the connection, close our socket and  <br>// move the last element of the Handles[] array into our  <br>// index. <br>// <br>// The array compaction is done so that we only pass valid handles <br>// in the first "curr_size" elements of the array to <br>// WaitForMultipleObjects(). The function will fail otherwise. <br> <br> <br>// We should NEVER get this for our listening socket <br>if (index &amp;&amp; overlap_err == ERROR_NETNAME_DELETED) { <br>closesocket(newsock); <br>xfree(Overlap); <br>Handles[index] = Handles[curr_size-1]; <br>socklist[index] = socklist[curr_size-1]; <br>curr_size--; <br>return; <br>} <br> <br>if( (index ==0) ) { //listening socket <br>if (curr_size &gt;= MAX_IO_PEND) { <br>fprintf(stderr,"Too many pending requests\n"); <br>return; <br>} <br>// <br>// Get the event handle used to queue the AcceptEx(), <br>// and re-use it to queue a ReadFile on the socket. <br>// <br> <br>Handles[curr_size] = Overlap-&gt;hEvent; <br>socklist[curr_size].overlap = Overlap; <br> <br>// <br>// The OffsetHigh field is used to keep track of what we are doing. <br>// This enables us to alternate ReadFile and WriteFile on a  <br>// connection <br> <br>Overlap-&gt;OffsetHigh = OP_READ; <br> <br>if (!ReadFile((HANDLE)newsock, socklist[curr_size].Buffer, <br>sizeof(socklist[curr_size].Buffer), <br>&amp;bytes, <br>Overlap) ) { <br>lasterr = GetLastError(); <br> <br>// Handle ERROR_NETNAME_DELETED specially <br>// Other errors are Not Good <br>// <br>if (lasterr &amp;&amp; lasterr != ERROR_IO_PENDING &amp;&amp; <br>lasterr != ERROR_NETNAME_DELETED ) { <br>fprintf(stderr,"Inital ReadFile failed %d\n"); <br>return; <br>} <br>if (lasterr == ERROR_NETNAME_DELETED) { <br>closesocket(newsock); <br>xfree(Overlap); <br>Handles[index] = Handles[curr_size]; <br>socklist[index] = socklist[curr_size]; <br>curr_size--; <br>return; <br>} <br> <br>} <br>// <br>// Increment the last valid handle location in the Handles <br>// array. <br>curr_size++; <br>return; <br>} <br>// <br>// This possibly indicates a closed socket. <br>// <br>if (  (bytes == 0 ) &amp;&amp; (Overlap-&gt;OffsetHigh == OP_READ) ){ <br>closesocket(newsock); <br>xfree(Overlap); <br>Handles[index] = Handles[curr_size]; <br>socklist[index] = socklist[curr_size]; <br>curr_size--; <br>return; <br>} <br>// <br>//  If the previos operation was an OP_READ, queue WriteFile on the <br>//  socket <br>// <br>if (Overlap-&gt;OffsetHigh == OP_READ) { // ReadFile was queued <br>printf("Read buffer [%s]\n",socklist[index].Buffer); <br>printf("Echoing back to client\n"); <br>if (!WriteFile((HANDLE)newsock, socklist[index].Buffer, <br>sizeof(socklist[index].Buffer), <br>&amp;bytes, <br>Overlap) ) { <br>lasterr = GetLastError(); <br>if (lasterr &amp;&amp; lasterr != ERROR_IO_PENDING &amp;&amp; <br>lasterr != ERROR_NETNAME_DELETED ) { <br>fprintf(stderr,"WriteFile failed %d\n"); <br>ExitProcess(1); <br>} <br>if ( (lasterr == ERROR_NETNAME_DELETED) || (!lasterr)) { <br>closesocket(newsock); <br>xfree(Overlap); <br>Handles[index] = Handles[curr_size]; <br>socklist[index] = socklist[curr_size]; <br>curr_size--; <br>return; <br>} <br>} <br>Overlap-&gt;OffsetHigh = OP_WRITE; <br>return; <br>} <br>// <br>// If we had a WriteFile queued, now do a ReadFile <br>// <br>else if (Overlap-&gt;OffsetHigh == OP_WRITE) { // WriteFile was queued <br>printf("Wrote %d bytes\n",bytes); <br>printf("Queueing read\n"); <br>if (!ReadFile((HANDLE)newsock, socklist[index].Buffer, <br>sizeof(socklist[index].Buffer), <br>&amp;bytes, <br>Overlap) ) { <br>lasterr =GetLastError(); <br>if (lasterr &amp;&amp; lasterr != ERROR_IO_PENDING) { <br>if (lasterr == ERROR_NETNAME_DELETED) { <br>closesocket(newsock); <br>xfree(Overlap); <br>Handles[index] = Handles[curr_size]; <br>socklist[index] = socklist[curr_size]; <br>curr_size--; <br>return; <br>} <br>fprintf(stderr,"ReadFile failed %d\n",GetLastError()); <br>ExitProcess(1); <br>} <br>} <br>Overlap-&gt;OffsetHigh = OP_READ; <br>return; <br>} <br>else { <br>fprintf(stderr,"Unknown operation queued\n"); <br>} <br> <br>} <br>// <br>// This is the wait function used to keep track of events <br>// <br>int DoWait(HANDLE *Handles,Socklist *socklist ) { <br> <br>DWORD wait_rc; <br>HANDLE hTemp; <br>Socklist socklTemp; <br> <br>int i; <br> <br>// <br>// Rotate the array, beginning at index 1, by one element. <br>// This ensures that all handles get a fair chance to be serviced. <br>// <br>// There is no way to detect how many handles were signalled when <br>// WaitForMultipleObjects() returns. We simply pick the first one and  <br>// come back to this function later <br>// Without the rotation below, this has the potential for starving <br>// connections accepted later. <br>// <br>// Index 0 is avoided, since it is our listening socket.  <br>// <br>for(i=1;i&lt;curr_size-1;i++){ <br> <br>hTemp = Handles[i+1]; <br>Handles[i+1] = Handles[i]; <br>Handles[i] = hTemp; <br> <br>socklTemp = socklist[i+1]; <br>socklist[i+1] = socklist[i]; <br>socklist[i] = socklTemp; <br>} <br> <br>wait_rc = WaitForMultipleObjects(curr_size,Handles,FALSE, <br>INFINITE); <br> <br>if (wait_rc == WAIT_FAILED) { <br>fprintf(stderr,"Wait failed Error %d\n",GetLastError()); <br>return -1; <br>} <br> <br>return (wait_rc - WAIT_OBJECT_0); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
