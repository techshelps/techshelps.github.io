<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GLOBCHAT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5265"></a>GLOBCHAT.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   generic.c <br>// <br>//  PURPOSE:   Implement the windows procedure for the main application <br>//    windows.  Also implement the generic message and command dispatchers. <br>// <br>//  FUNCTIONS: <br>//    WndProc      - Processes messages for the main window. <br>//    MsgCreate    - Handles the WM_CREATE message.  Sets up Display and <br>//                   initializes listening sockets.  Also advertises the  <br>//                   service <br>//    MsgSize      - Resizes the Listboxes to fit nicely in main window. <br>//    MsgTimer     - Handles the WM_TIMER messages which alert us to the <br>//                   fact that its time to send a SAP packet <br>//    MsgConnected - Handles new connection notifications <br>//    MsgDataready - Handles recv data notifications and close socket <br>//                   notifications <br>//    MsgCommand   - Handle the WM_COMMAND messages for the main window. <br>//    MsgDestroy   - Handles the WM_DESTROY message by calling <br>//                   PostQuitMessage(). <br>//    CmdExit      - Handles the file exit command by calling destory <br>//                   window on the main window. <br>// <br>//  COMMENTS: <br>// <br> <br>#include &lt;windows.h&gt;            // required for all Windows applications <br>#include &lt;windowsx.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnetbs.h&gt; <br>#include &lt;svcguid.h&gt; <br>#include "globals.h"            // prototypes specific to this application <br> <br> <br>// Main window message table definition. <br>MSD rgmsd[] = <br>{ <br>    {WM_CREATE,    MsgCreate}, <br>    {WM_SIZE,      MsgSize}, <br>    {WM_TIMER,     MsgTimer}, <br>    {WM_COMMAND,   MsgCommand}, <br>    {WM_DESTROY,   MsgDestroy}, <br>    {MW_CONNECTED, MsgConnected}, <br>    {MW_DATAREADY, MsgDataready} <br>}; <br> <br>MSDI msdiMain = <br>{ <br>    sizeof(rgmsd) / sizeof(MSD), <br>    rgmsd, <br>    edwpWindow <br>}; <br> <br> <br>// Main window command table definition. <br>CMD rgcmd[] = <br>{ <br>    {IDM_EXIT,  CmdExit}, <br>    {IDM_ABOUT, CmdAbout} <br>}; <br> <br>CMDI cmdiMain = <br>{ <br>    sizeof(rgcmd) / sizeof(CMD), <br>    rgcmd, <br>    edwpWindow <br>}; <br> <br> <br>// <br>//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  PARAMETERS: <br>//    hwnd     - window handle <br>//    uMessage - message number <br>//    wparam   - additional information (dependant on message number) <br>//    lparam   - additional information (dependant on message number) <br>// <br>//  RETURN VALUE: <br>//    The return value depends on the message number.  If the message <br>//    is implemented in the message dispatch table, the return value is <br>//    the value returned by the message handling function.  Otherwise, <br>//    the return value is the value returned by the default window procedure. <br>// <br>//  COMMENTS: <br>//    Call the DispMessage() function with the main window's message dispatch <br>//    information (msdiMain) and the message specific information. <br>// <br> <br>LRESULT CALLBACK WndProc(HWND   hwnd, <br>                         UINT   uMessage, <br>                         WPARAM wparam, <br>                         LPARAM lparam) <br>{ <br>    return DispMessage(&amp;msdiMain, hwnd, uMessage, wparam, lparam); <br>} <br> <br>// <br>//  FUNCTION: MsgCreate(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE:  Sets up child windows, initializes listening sockets, and advertises <br>//            the existence of the service <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle <br>//    uMessage  - Message number (Unused) <br>//    wparam    - Extra data     (Unused) <br>//    lparam    - Extra data     (Unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgCreate(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    int sizeProtBuf = 0;  <br>    int cNumProt; <br>    int j, k; <br>    int GoodProts[40]; <br>    WORD wVersionRequested; <br>    WSADATA wsaData; <br>    char outtext[80]; <br>    int tabwidth[1] = {100}; <br>    BOOL bcaststat; <br>    int addrlen; <br> <br>    // Create Protocol listbox <br>    hwndProtocolList = CreateWindow("LISTBOX", <br>                                    NULL, <br>                                    WS_BORDER | WS_CHILD | WS_VISIBLE | LBS_STANDARD | LBS_USETABSTOPS, <br>                                    0, 0, 0, 0, <br>                                    hwnd, <br>                                    (HMENU)ID_PROTOCOLBOX, <br>                                    (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE), <br>                                    0); <br>    // Set tabs <br>    SendMessage(hwndProtocolList, LB_SETTABSTOPS, 1, (LPARAM)tabwidth); <br> <br>    // Create Client List listbox <br>    hwndClientList = CreateWindow("LISTBOX", <br>                                  NULL, <br>                                  WS_BORDER | WS_CHILD | WS_VISIBLE | LBS_STANDARD | LBS_USETABSTOPS | LBS_HASSTRINGS, <br>                                  0, 0, 0, 0, <br>                                  hwnd, <br>                                  (HMENU)ID_CLIENTBOX, <br>                                  (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE), <br>                                  0); <br>    // Set tab stops <br>    SendMessage(hwndClientList, LB_SETTABSTOPS, 1, (LPARAM)tabwidth); <br> <br>    // First allocate Connected Sockets Heap <br>    if((ConnectHeap = HeapCreate(0, sizeof(SOCKDATA) * 5, sizeof(SOCKDATA) * 100)) == NULL) <br>    { <br>        // ERROR - abort <br>return 0; <br>    } <br>    if(((LPVOID)ConnectedSockets = HeapAlloc(ConnectHeap,0, sizeof(SOCKDATA) * 5)) == NULL) <br>    { <br>        // ERROR - abort <br>        return 0; <br>    } <br>    NextFree = 0;  // First available SOCKDATA struct <br>    MaxConnects = 5; // Allocate only 5 structures at a time <br> <br>    // Load winsock dll <br>    wVersionRequested = MAKEWORD(1, 1); <br>    if (WSAStartup(wVersionRequested, &amp;wsaData) != 0) <br>    { <br>        // ERROR -abort <br>return 0; <br>    } <br> <br>    // Determine size of buffer needed <br>    if (EnumProtocols(NULL, NULL, &amp;sizeProtBuf) != SOCKET_ERROR) <br>    { <br>        // ERROR <br>        return 0; <br>    } <br> <br>    // Allocate buffer of appropriate size <br>    if (((LPVOID)lpProtBuf = VirtualAlloc(NULL, <br>                                          sizeProtBuf, <br>                                          MEM_COMMIT, <br>                                          PAGE_READWRITE)) == NULL) <br>    { <br>        // ERROR <br>        return 0; <br>    } <br> <br>    // Do the real EnumProtocols call--note that there is no GETNEXT mechanism here. <br>// We have to allocate a single buffer big enough to hold everything. <br>    if ((cNumProt = EnumProtocols(NULL, lpProtBuf, &amp;sizeProtBuf)) == SOCKET_ERROR) <br>    { <br>        // ERROR <br>        return 0; <br>    } <br> <br>    // Now that we know how many protocols we have, allocate array of globchat <br>// SOCKDATA structures to hold info on each. <br>    if (((LPVOID)ServerSockets = VirtualAlloc(NULL, <br>                                              cNumProt * sizeof(SOCKDATA), <br>                                              MEM_COMMIT, <br>                                              PAGE_READWRITE)) == NULL) <br>    { <br>        // ERROR <br>        return 0; <br>    } <br> <br>    // Walk through available protocols, j is index to list of all protocols, k is index to list of <br>// protocols we can use. <br>    for (j = 0, k = 0; j &lt; cNumProt; j++) <br>    { <br>        // Only want connection oriented protocols <br>        if((lpProtBuf[j].dwServiceFlags &amp; XP_CONNECTIONLESS) == 0)   <br>        { <br>// Attempt to setup listen and fill in SOCKDATA struct <br>if (MakeServSock(hwnd, &amp;ServerSockets[k], &amp;lpProtBuf[j])) <br>{ <br>            // Successfully using protocol...add it to our list box <br>            wsprintf(outtext, "%s\t%d", ServerSockets[k].lpProtocolName, ServerSockets[k].currconnects); <br>            SendMessage(hwndProtocolList, LB_ADDSTRING, 0, (LPARAM)&amp;outtext); <br> <br>            // Found a good protocol! <br>            GoodProts[k++] = j; <br>} <br>        } <br>    } <br> <br>    cNumProt = k;  // Number of good protocols <br> <br> <br> <br> <br>    // Register with Name Spaces <br> <br>    // In the future this will be done transparently, but for now must do it <br>    // manually for specific protocols.  The only NSPs we have are DNS and SAP. <br>    // Since DNS is static, that just leaves us with SAP to do. <br> <br>     <br>    if((SAPSocket = socket(AF_IPX,                // IPX family <br>                           SOCK_DGRAM,   // SAPs are broadcasted <br>                           NSPROTO_IPX + 4)  // Uses IPX packet type 4 <br>                           ) != INVALID_SOCKET) <br>    { <br>        // Find IPX address which we are bound to <br>        for(k = 0;k &lt; cNumProt; k++) <br>        { <br>            if(ServerSockets[k].protocol == NSPROTO_SPXII) <br>            { <br>        // Initialize SAP data <br>        SAPData.operation = 0x200;         // 2 = SAP response(network order) <br>        SAPData.servicetype = 0x5607;  // 0756 Assigned by Novell specifically for GLOBCHAT only!!!! <br>        strcpy(SAPData.name, "GLOBCHAT");  // My service name <br>        memcpy((void *)SAPData.network,    // Copy address into SAP body <br>               (void *)(ServerSockets[k].addr.sa_data),  <br>               12); <br>        SAPData.hops = 0;                 // Hop count starts at zero <br> <br>        SAPSockAddr.sa_family = AF_IPX;   // SAP packets sent over IPX <br>        AtoH((char *)&amp;SAPSockAddr.sa_socket, "0452", 2);  // SAP destination socket address is 0452. <br>         <br>// Bind to SAP socket <br>        if (bind(SAPSocket, (PSOCKADDR) &amp;SAPSockAddr, sizeof(SOCKADDR_IPX)) == SOCKET_ERROR) <br>        { <br>            // Error binding to SAP socket <br>return 0; <br>        } <br>        else <br>        { <br>            // build destination address for SAP's IPX header (broadcast) <br>            SAPDestSockAddr.sa_family = AF_IPX; <br>            AtoH("00000000",SAPDestSockAddr.sa_netnum, 4); <br>            AtoH("FFFFFFFFFFFF", SAPDestSockAddr.sa_nodenum, 6); <br>            AtoH("0452", (char *)&amp;SAPDestSockAddr.sa_socket, 2); <br> <br>                // Setup socket to allow broadcasts <br>                bcaststat = TRUE; <br>                addrlen = sizeof(bcaststat); <br>                setsockopt(SAPSocket, SOL_SOCKET, SO_BROADCAST, (char *)&amp;bcaststat, sizeof(bcaststat)); <br>            sendto(SAPSocket, (char *)&amp;SAPData, sizeof(SAPData), MSG_DONTROUTE, (struct sockaddr *)&amp;SAPDestSockAddr, sizeof(SAPDestSockAddr)); <br> <br>            // Set timer to remind us to send SAP packet every 60 seconds. <br>            SetTimer(hwnd, SAPTIMER, 60000, NULL); <br>        } <br>                break; <br>            } <br>        } <br>    } <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: MsgSize(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE:  Resizes child listboxes to fit nicely within parent <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle <br>//    uMessage  - Message number (Unused) <br>//    wparam    - Extra data (Unused) <br>//    lparam    - Window dimensions <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgSize(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    MoveWindow(hwndProtocolList, <br>               1, (HIWORD(lparam) / 4), <br>               (LOWORD(lparam) / 2), <br>               (HIWORD(lparam) * 3) / 4, <br>               TRUE); <br> <br>    MoveWindow(hwndClientList, <br>               LOWORD(lparam) /2, <br>               HIWORD(lparam) / 4, <br>               LOWORD(lparam) / 2, <br>               (HIWORD(lparam) * 3) / 4, <br>               TRUE); <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: MsgTimer(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Sends out SAP packet every 60 seconds <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle <br>//    uMessage  - Message number (Unused) <br>//    wparam    - Should be = SAPTIMER <br>//    lparam    - Extra data     (Unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgTimer(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    sendto(SAPSocket, (char *) &amp;SAPData, sizeof(SAPData), MSG_DONTROUTE, (struct sockaddr *)&amp;SAPDestSockAddr, sizeof(SAPDestSockAddr)); <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: MsgConnected(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Handles new connection notifications <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle <br>//    uMessage  - Message number (Unused) <br>//    wparam    - socket which has the connection <br>//    lparam    - loword = event, hiword = error code <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgConnected(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    int k, addrlen; <br>    int index; <br>    char outtext[80]; <br> <br>    // May have to increase our heap size <br>    if(NextFree &gt;= MaxConnects) <br>    { <br>        if(HeapAlloc(ConnectHeap, 0, sizeof(SOCKDATA) * 5) == NULL) <br>        { <br>           // ERROR on heap allocation...don't accept new connections <br>   return 0; <br>        } <br>        MaxConnects += 5;  // We've got five more connect entries available <br>    } <br> <br>    // find socket that connect is refering to <br>    k = 0; <br>    while(ServerSockets[k].sock != wparam) k++; <br> <br>    // Lets keep track of our progress <br>    ServerSockets[k].status = SOCKSTAT_ACCEPTING; <br> <br>    // Some address our bigger than a sockaddr struct.  I threw in some reserved bytes to cover it. <br>    addrlen = sizeof(ConnectedSockets[NextFree].addr) + sizeof(ConnectedSockets[NextFree].reserved); <br> <br>    // Accept the connect request <br>    if ((ConnectedSockets[NextFree].sock = accept(ServerSockets[k].sock, <br>                                                 &amp;ConnectedSockets[NextFree].addr, <br>                                                 &amp;addrlen)) == INVALID_SOCKET) <br>    { <br>        // ERROR clean up ConnectedSockets (that is don't increment NextFree) and go on our way <br>        return 0; <br>    } <br>    if(WSAAsyncSelect(ConnectedSockets[NextFree].sock, hwnd, MW_DATAREADY, FD_READ | FD_CLOSE) == SOCKET_ERROR) <br>    { <br>        // ERROR clean up connection <br>closesocket(ConnectedSockets[NextFree].sock); <br>        return 0; <br>    } <br>    // Fill in SOCKDATA structure for client socket <br>    ConnectedSockets[NextFree].protocol = ServerSockets[k].protocol; <br>    ConnectedSockets[NextFree].type = ServerSockets[k].type; <br>    ConnectedSockets[NextFree].servsockindex = k; <br>    ConnectedSockets[NextFree++].status = SOCKSTAT_CONNECTED; <br>// Increment protocol connection count and display <br>    ServerSockets[k].currconnects ++; <br>    index = SendMessage(hwndProtocolList, LB_FINDSTRING, (WPARAM)-1, (LPARAM)ServerSockets[k].lpProtocolName); <br>    SendMessage(hwndProtocolList, LB_DELETESTRING, index, 0); <br>    wsprintf(outtext, "%s\t%d", ServerSockets[k].lpProtocolName, ServerSockets[k].currconnects); <br>    SendMessage(hwndProtocolList, LB_ADDSTRING, 0, (LPARAM)&amp;outtext); <br> <br>    // Don't forget to set server socket status back to listening <br>    ServerSockets[k].status = SOCKSTAT_LISTENING; <br> <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: MsgDataready(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Handles incoming socket data notifications and close socket <br>//           notifications <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle <br>//    uMessage  - Message number <br>//    wparam    - socket which has the data <br>//    lparam    - loword = event, hiword = error code <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgDataready(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    int k, j, l; <br>    int totalbytesread; <br>    int index; <br>    char outtext[80]; <br> <br>    // Find the appropriate socket...allow for the reuse of a closed socket handle <br>    for (k = 0; k &lt; NextFree; k++) <br>    { <br>        if((ConnectedSockets[k].sock == wparam) &amp;&amp; (ConnectedSockets[k].status != SOCKSTAT_CLOSED)) <br>            break; <br>    } <br> <br>    if(LOWORD(lparam) == FD_CLOSE) <br>    { <br>        // Socket closed notification--cleanup! <br>        closesocket(ConnectedSockets[k].sock); <br> <br>        // Delete name from client list display <br>        UpdateClientList(ConnectedSockets[k].name, SOCKSTAT_CLOSED, NULL); <br> <br>        // Take name off of other clients' available list <br>        if (ConnectedSockets[k].status == SOCKSTAT_AVAILABLE) <br>        { <br>            deregistername(ConnectedSockets[k].name); <br>        } <br> <br>        // if this connection was in session with another peer...notify peer of disconnect <br> <br>        // First, find peer <br>        for (j = 0; j &lt; NextFree; j++) <br>        { <br>            if((ConnectedSockets[j].sock == ConnectedSockets[k].peer) &amp;&amp; <br>               (ConnectedSockets[j].status == SOCKSTAT_INSESSION)) <br>            { <br>                break; <br>            } <br>        } <br>        if (j &lt; NextFree)  // Did we find a peer? <br>        { <br>            // Yes, build message header <br>            xferbuf.hdr.signature = MYSIGNATURE; <br>            xferbuf.hdr.length = totalbytesread = HDRSIZE; <br>            xferbuf.hdr.command = SESSION_CLOSE; <br>            // Send session close message <br>            senddatamessage(ConnectedSockets[j].sock, &amp;xferbuf); <br>// Update Peer's displayed status <br>            ConnectedSockets[j].status = SOCKSTAT_AVAILABLE; <br>            UpdateClientList(ConnectedSockets[j].name, SOCKSTAT_AVAILABLE, NULL); <br>// Propagate the fact that the peer is now available for other chats <br>// and give peer list of other available clients <br>            for (l = 0; l &lt; NextFree; l++) <br>            { <br>                if ((l != j) &amp;&amp; (ConnectedSockets[l].status == SOCKSTAT_AVAILABLE)) <br>                { <br>                    xferbuf.hdr.command = REGISTER_NAME; <br>                    lstrcpy(xferbuf.data, ConnectedSockets[l].name); <br>                    xferbuf.hdr.length = REALLEN(ConnectedSockets[l].name) + HDRSIZE; <br>                    senddatamessage(ConnectedSockets[j].sock, &amp;xferbuf); <br> <br>                    lstrcpy(xferbuf.data, ConnectedSockets[j].name); <br>                    xferbuf.hdr.length = REALLEN(ConnectedSockets[j].name) + HDRSIZE; <br>                    senddatamessage(ConnectedSockets[l].sock, &amp;xferbuf); <br>                } <br>            } <br>        } <br>        // Cleanup ConnectedSockets array <br>        ConnectedSockets[k].status = SOCKSTAT_CLOSED; <br>        j = ConnectedSockets[k].servsockindex; <br>    // Fix protocol connection count display <br>    ServerSockets[j].currconnects --; <br>    index = SendMessage(hwndProtocolList, LB_FINDSTRING, (WPARAM)-1, (LPARAM)ServerSockets[j].lpProtocolName); <br>    SendMessage(hwndProtocolList, LB_DELETESTRING, index, 0); <br>    wsprintf(outtext, "%s\t%d", ServerSockets[j].lpProtocolName, ServerSockets[j].currconnects); <br>    SendMessage(hwndProtocolList, LB_ADDSTRING, 0, (LPARAM)&amp;outtext); <br>        return 0; <br>    } <br> <br>    // There's data to read...read it! <br> <br>    if(!recvdatamessage(&amp;ConnectedSockets[k], &amp;xferbuf)) <br>    { <br>        return 0; <br>    } <br> <br>    // We've got our whole message!  Now switch() on the command flag <br> <br>    switch(xferbuf.hdr.command) <br>    { <br>        case REGISTER_NAME:  // First message we should receive on a connection <br>            if(ConnectedSockets[k].status != SOCKSTAT_CONNECTED) <br>            { <br>                // ERROR -- we weren't expecting this...drop it <br>                return 0; <br>            } <br>            // Get name and add to internal structs and display <br>            lstrcpy(ConnectedSockets[k].name, xferbuf.data); <br>            ConnectedSockets[k].status = SOCKSTAT_AVAILABLE; <br>            UpdateClientList(ConnectedSockets[k].name, SOCKSTAT_AVAILABLE, NULL); <br> <br>            // Send notification to other "AVAILABLE" sockets that we have a new peer available <br>            for (j = 0; j &lt; NextFree; j++) <br>            { <br>                if((j != k) &amp;&amp; (ConnectedSockets[j].status == SOCKSTAT_AVAILABLE)) <br>                { <br>                    // message in xferbuf should be able to be sent just like it is <br>                    senddatamessage(ConnectedSockets[j].sock, &amp;xferbuf); <br>                } <br>            } <br> <br>            // Send notifications back to registering peer of all the currently available peers <br> <br>            for (j = 0; j &lt; NextFree; j++) <br>            { <br>                if((j != k) &amp;&amp; (ConnectedSockets[j].status == SOCKSTAT_AVAILABLE)) <br>                { <br>                    // found one...build message and send it <br>                    xferbuf.hdr.signature = MYSIGNATURE; <br>                    xferbuf.hdr.length = REALLEN(ConnectedSockets[j].name) + HDRSIZE; <br>                    xferbuf.hdr.command = REGISTER_NAME; <br>                    lstrcpy(xferbuf.data, ConnectedSockets[j].name); <br>                    senddatamessage(ConnectedSockets[k].sock, &amp;xferbuf); <br>                } <br>            } <br> <br>            return 0; <br> <br>        case XFER_DATA:   // For passing data between two insession peers <br>            if(ConnectedSockets[k].status != SOCKSTAT_INSESSION) <br>            { <br>                // ERROR -- we weren't expecting this...drop data <br>                return 0; <br>            } <br> <br>            // forward the message to peer...should be able transfer <br>            // message without modification <br>            senddatamessage(ConnectedSockets[k].peer, &amp;xferbuf); <br>            return 0; <br> <br>        case REQUEST_SESSION:  // Client is asking another peer for a chat <br>            if(ConnectedSockets[k].status != SOCKSTAT_AVAILABLE) <br>            { <br>                // ERROR -- we weren't expecting this...drop data <br>                return 0; <br>            } <br> <br>            ConnectedSockets[k].status = SOCKSTAT_REQSESSION; <br>            UpdateClientList(ConnectedSockets[k].name, SOCKSTAT_REQSESSION, xferbuf.data); <br> <br>            // Find the socket which corresponds to the name <br> <br>            for(j = 0; j &lt; NextFree; j++) <br>            { <br>                if(lstrcmp(ConnectedSockets[j].name, xferbuf.data) == 0) <br>                { <br>                    if(ConnectedSockets[j].status == SOCKSTAT_AVAILABLE) <br>                    { <br>                        // Found It! <br>                        break; <br>                    } <br>                } <br>            } <br> <br>            if (j == NextFree) return 0; <br> <br>            // Copy requester's name into send data buffer <br>            lstrcpy(xferbuf.data, ConnectedSockets[k].name); <br>            xferbuf.hdr.length = HDRSIZE + REALLEN(ConnectedSockets[k].name); <br>            senddatamessage(ConnectedSockets[j].sock, &amp;xferbuf); <br> <br>            // Update connected sockets structures <br>            ConnectedSockets[j].status = SOCKSTAT_REQSESSION; <br>            UpdateClientList(ConnectedSockets[j].name, SOCKSTAT_REQSESSION, ConnectedSockets[k].name); <br>            ConnectedSockets[j].peer = ConnectedSockets[k].sock; <br>            ConnectedSockets[k].peer = ConnectedSockets[j].sock; <br>            return 0; <br> <br>        case SESSION_REQUEST_RESPONSE:  // Response to session request <br> <br>            if(ConnectedSockets[k].status != SOCKSTAT_REQSESSION) <br>            { <br>                // ERROR -- not expecting this...drop packet <br>                return 0; <br>            } <br> <br>            // find peer entry <br>            for (j = 0; j &lt; NextFree; j++) <br>            { <br>                if ((ConnectedSockets[j].sock == ConnectedSockets[k].peer) &amp;&amp; <br>                    (ConnectedSockets[j].status == SOCKSTAT_REQSESSION)) <br>                { <br>                    // Found it! <br>                    break; <br>                } <br>            } <br> <br>            if (j == NextFree) <br>            { <br>                // ERROR -- couldn't find peer...drop packet <br>                return 0; <br>            } <br> <br>            // forward response to requester <br>            senddatamessage(ConnectedSockets[k].peer, &amp;xferbuf); <br> <br>            if(*(xferbuf.data) == 1) <br>            { <br>                // Session accepted, change status of sockets <br>                ConnectedSockets[k].status = SOCKSTAT_INSESSION; <br>                ConnectedSockets[j].status = SOCKSTAT_INSESSION; <br>                UpdateClientList(ConnectedSockets[k].name, SOCKSTAT_INSESSION, ConnectedSockets[j].name); <br>                UpdateClientList(ConnectedSockets[j].name, SOCKSTAT_INSESSION, ConnectedSockets[k].name); <br>                deregistername(ConnectedSockets[k].name); <br>                deregistername(ConnectedSockets[j].name); <br>            } <br>            else <br>            { <br>                // Session not accepted, make sockets available <br>                ConnectedSockets[k].status = SOCKSTAT_AVAILABLE; <br>                ConnectedSockets[j].status = SOCKSTAT_AVAILABLE; <br>                UpdateClientList(ConnectedSockets[k].name, SOCKSTAT_AVAILABLE, NULL); <br>                UpdateClientList(ConnectedSockets[j].name, SOCKSTAT_AVAILABLE, NULL); <br>            } <br> <br>            return 0; <br> <br>        case SESSION_CLOSE:  // Insession client chose "End Chat" option <br>            if (ConnectedSockets[k].status != SOCKSTAT_INSESSION) <br>            { <br>                // We weren't expecting this...drop packet <br>                return 0; <br>            } <br> <br>            // Find Peer <br>            for (j = 0; j &lt; NextFree; j++) <br>            { <br>                if((ConnectedSockets[j].sock == ConnectedSockets[k].peer) &amp;&amp; <br>                   (ConnectedSockets[j].status == SOCKSTAT_INSESSION)) <br>                { <br>                    // Found it <br>                    break; <br>                } <br>            } <br> <br>            if(j == NextFree) <br>            { <br>                // ERROR - couldn't find peer...drop message <br>                return 0; <br>            } <br> <br>            // forward message <br>            senddatamessage(ConnectedSockets[k].peer,&amp;xferbuf); <br> <br>            // Change Status <br>            ConnectedSockets[k].status = SOCKSTAT_AVAILABLE; <br>            ConnectedSockets[j].status = SOCKSTAT_AVAILABLE; <br>            UpdateClientList(ConnectedSockets[k].name, SOCKSTAT_AVAILABLE, NULL); <br>            UpdateClientList(ConnectedSockets[j].name, SOCKSTAT_AVAILABLE, NULL); <br> <br>            // register names of both peers with other available clients.  Also <br>// provide current available client names to both peers <br> <br>            for (l = 0; l &lt; NextFree; l++)  // l = index to all connected sockets <br>                                // k = index of current peer <br>// j = index of socket who generated message <br>            { <br>                if (ConnectedSockets[l].status == SOCKSTAT_AVAILABLE) <br>                { <br>                    if ( l != k) <br>                    { <br>                        xferbuf.hdr.signature = MYSIGNATURE; <br>                        xferbuf.hdr.length = REALLEN(ConnectedSockets[k].name) + HDRSIZE; <br>                        xferbuf.hdr.command = REGISTER_NAME; <br>                        lstrcpy(xferbuf.data, ConnectedSockets[k].name); <br>                        senddatamessage(ConnectedSockets[l].sock, &amp;xferbuf); <br> <br>                        if (l != j) <br>                        { <br>                            xferbuf.hdr.length = REALLEN(ConnectedSockets[l].name) + HDRSIZE; <br>                            lstrcpy(xferbuf.data, ConnectedSockets[l].name); <br>                            senddatamessage(ConnectedSockets[k].sock, &amp;xferbuf); <br>                        } <br>                    } <br>                    if (l != j) <br>                    { <br>                        xferbuf.hdr.signature = MYSIGNATURE; <br>                        xferbuf.hdr.length = REALLEN(ConnectedSockets[j].name) + HDRSIZE; <br>                        xferbuf.hdr.command = REGISTER_NAME; <br>                        lstrcpy(xferbuf.data, ConnectedSockets[j].name); <br>                        senddatamessage(ConnectedSockets[l].sock, &amp;xferbuf); <br> <br>                        if (l != k) <br>                        { <br>                            xferbuf.hdr.length = REALLEN(ConnectedSockets[l].name) + HDRSIZE; <br>                            lstrcpy(xferbuf.data, ConnectedSockets[l].name); <br>                            senddatamessage(ConnectedSockets[j].sock, &amp;xferbuf); <br>                        } <br>                    } <br>                } <br>            } <br>            return 0; <br> <br>    } // End message command switch <br> <br>    // ERROR -- If we get here, we had an invalid message... drop it <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: MsgCommand(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Handle the WM_COMMAND messages for the main window. <br>// <br>//  PARAMETERS: <br>//    hwnd     - window handle <br>//    uMessage - WM_COMMAND (Unused) <br>//    GET_WM_COMMAND_ID(wparam, lparam)   - Command identifier <br>//    GET_WM_COMMAND_HWND(wparam, lparam) - Control handle <br>// <br>//  RETURN VALUE: <br>//    The return value depends on the message number.  If the message <br>//    is implemented in the message dispatch table, the return value is <br>//    the value returned by the message handling function.  Otherwise, <br>//    the return value is the value returned by the default window procedure. <br>// <br>//  COMMENTS: <br>//    Call the DispCommand() function with the main window's command dispatch <br>//    information (cmdiMain) and the command specific information. <br>// <br> <br>LRESULT MsgCommand(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    return DispCommand(&amp;cmdiMain, hwnd, wparam, lparam); <br>} <br> <br> <br>// <br>//  FUNCTION: MsgDestroy(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Calls PostQuitMessage(). <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle  (Unused) <br>//    uMessage  - Message number (Unused) <br>//    wparam    - Extra data     (Unused) <br>//    lparam    - Extra data     (Unused) <br>// <br>//  RETURN VALUE: <br>// </code></pre>
<p>
</p>
<pre><code>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgDestroy(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    PostQuitMessage(0); <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: CmdExit(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Exit the application. <br>// <br>//  PARAMETERS: <br>//    hwnd     - The window. <br>//    wCommand - IDM_EXIT (unused) <br>//    wNotify  - Notification number (unused) <br>//    hwndCtrl - NULL (unused) <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - command handled. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT CmdExit(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    DestroyWindow(hwnd); <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
