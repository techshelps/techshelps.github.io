<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MISC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5259"></a>MISC.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   misc.c <br>// <br>//  PURPOSE:  Contains all helper functions "global" to the application. <br>// <br>//  FUNCTIONS: <br>//    CenterWindow    - Center one window over another. <br>//    ReceiveInBox    - Reads incoming socket data. <br>//    SendOutBox      - Writes outgoing socket data. <br>//    AtoH            - Converts ascii string to network order hex <br>//    BtoH            - Converts ascii byte to hex <br>//    senddatamessage - Sends a message to the server <br>//    recvdatamessage - Receives a message from the server <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>#include &lt;windows.h&gt;            // required for all Windows applications <br>#include &lt;windowsx.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnetbs.h&gt; <br>#include &lt;nspapi.h&gt; <br>#include "globals.h"            // prototypes specific to this application <br> <br> <br> <br>// <br>//  FUNCTION: CenterWindow(HWND, HWND) <br>// <br>//  PURPOSE:  Center one window over another. <br>// <br>//  PARAMETERS: <br>//    hwndChild - The handle of the window to be centered. <br>//    hwndParent- The handle of the window to center on. <br>// <br>//  RETURN VALUE: <br>// <br>//    TRUE  - Success <br>//    FALSE - Failure <br>// <br>//  COMMENTS: <br>// <br>//    Dialog boxes take on the screen position that they were designed <br>//    at, which is not always appropriate. Centering the dialog over a <br>//    particular window usually results in a better position. <br>// <br> <br>BOOL CenterWindow(HWND hwndChild, HWND hwndParent) <br>{ <br>    RECT    rcChild, rcParent; <br>    int     cxChild, cyChild, cxParent, cyParent; <br>    int     cxScreen, cyScreen, xNew, yNew; <br>    HDC     hdc; <br> <br>    // Get the Height and Width of the child window <br>    GetWindowRect(hwndChild, &amp;rcChild); <br>    cxChild = rcChild.right - rcChild.left; <br>    cyChild = rcChild.bottom - rcChild.top; <br> <br>    // Get the Height and Width of the parent window <br>    GetWindowRect(hwndParent, &amp;rcParent); <br>    cxParent = rcParent.right - rcParent.left; <br>    cyParent = rcParent.bottom - rcParent.top; <br> <br>    // Get the display limits <br>    hdc = GetDC(hwndChild); <br>    cxScreen = GetDeviceCaps(hdc, HORZRES); <br>    cyScreen = GetDeviceCaps(hdc, VERTRES); <br>    ReleaseDC(hwndChild, hdc); <br> <br>    // Calculate new X position, then adjust for screen <br>    xNew = rcParent.left + ((cxParent - cxChild) / 2); <br>    if (xNew &lt; 0) <br>    { <br>        xNew = 0; <br>    } <br>    else if ((xNew + cxChild) &gt; cxScreen) <br>    { <br>        xNew = cxScreen - cxChild; <br>    } <br> <br>    // Calculate new Y position, then adjust for screen <br>    yNew = rcParent.top  + ((cyParent - cyChild) / 2); <br>    if (yNew &lt; 0) <br>    { <br>        yNew = 0; <br>    } <br>    else if ((yNew + cyChild) &gt; cyScreen) <br>    { <br>        yNew = cyScreen - cyChild; <br>    } <br> <br>    // Set it, and return <br>    return SetWindowPos(hwndChild, <br>                        NULL, <br>                        xNew, yNew, <br>                        0, 0, <br>                        SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br>// <br>//  FUNCTION: ReceiveInBox(HWND, WPARAM, LPARAM, char *, int) <br>// <br>//  PURPOSE:  Reads incoming data from socket and process message <br>// <br>//  PARAMETERS: <br>//    hWnd      - Handle to current window <br>//    uParam    - WPARAM (unused) <br>//    lParam    - LPARAM contains event (FD_READ or FD_CLOSE). <br>//    szRBuf    - Receive Buffer <br>//    cRBufLen  - size of Receive Buffer <br>// <br>//  RETURN VALUE: <br>// <br>//    TRUE  - Data Read <br>//    FALSE - If FD_CLOSE message or recv failed <br>// <br>//  COMMENTS: <br>// <br>//    Called if socket has data OR if it is closed.  If closed post <br>//    WM_DISCONNECTED message.  Else read data and make sure it is <br>//    NULL terminated. <br>// <br> <br>BOOL ReceiveInBox(HWND hWnd, WPARAM uParam, LPARAM lParam, char * szRBuf, int cRBufLen) <br>{ <br>    char outtext[80]; <br> <br> <br>    if (LOWORD(lParam) == FD_CLOSE)                   // Is this a FD_CLOSE event? <br>    { <br>        SendMessage(hWnd, MW_DISCONNECTED, 0, 0);     // Yes, post message <br>        return(FALSE); <br>    } <br> <br>    if (!recvdatamessage(&amp;MySock, &amp;xferbuf))         // Receive data <br>    { <br>        return(TRUE); <br>    } <br> <br>    // Switch on message command <br>    switch (xferbuf.hdr.command) <br>    { <br>        case XFER_DATA:   // Chat data...put it in buffer <br>            lstrcpy(szRBuf, xferbuf.data); <br>            cRBufLen = xferbuf.hdr.length - HDRSIZE; <br>            break; <br> <br>        case SESSION_CLOSE:  // Peer killed us...cleanup <br>            MySock.status = SOCKSTAT_AVAILABLE; <br> <br>            // Clear event indicator since we need to transfer message <br>         // indications to the dialog we are about to create <br>            if (WSAAsyncSelect(MySock.sock, hWnd, 0, 0) == SOCKET_ERROR) <br>            { <br>                // oops <br>                return FALSE; <br>            } <br>            PostMessage(hWnd, WM_COMMAND, MAKELONG(IDM_SELECT, 0), 0); <br> <br>            wsprintf(outtext, GetStringRes(IDS_CHAT_AVAILABLE), MySock.name); <br>            SetWindowText(hWnd, outtext); <br>            return FALSE; <br> <br>        default: <br>            break; <br>            // unexpected meesage...drop it <br>    } <br>    return TRUE; <br>} <br> <br>// <br>//  FUNCTION: SendOutBox(char *, int) <br>// <br>//  PURPOSE:  Sends outbox text via data message <br>// <br>//  PARAMETERS: <br>//    szSBuf    - Send Buffer <br>//    cSBufLen  - size of Send Buffer <br>// <br>//  COMMENTS: <br>// <br>//    Writes send buffer to socket <br>// <br> <br>void SendOutBox(char * szSBuf, int cSBufLen) <br>{ <br>    xferbuf.hdr.signature = MYSIGNATURE; <br>    xferbuf.hdr.length = cSBufLen + HDRSIZE; <br>    xferbuf.hdr.command = XFER_DATA; <br>    lstrcpy(xferbuf.data, szSBuf); <br>    senddatamessage(MySock.sock, &amp;xferbuf); <br>    return; <br>} <br> <br>// <br>//  FUNCTION: AtoH(char *, char *, int) <br>// <br>//  PURPOSE:  Converts ascii string to network order hex <br>// <br>//  PARAMETERS: <br>//    src    - pointer to input ascii string <br>//    dest   - pointer to output hex <br>//    destlen - size of dest <br>// <br>//  COMMENTS: <br>// <br>//    2 ascii bytes make a hex byte so must put 1st ascii byte of pair <br>//    into upper nibble and 2nd ascii byte of pair into lower nibble. <br>// <br> <br>void AtoH(char * src, char * dest, int destlen) <br>{ <br>    char * srcptr; <br> <br>    srcptr = src; <br> <br>    while(destlen--) <br>    { <br>    *dest = BtoH(*srcptr++) &lt;&lt; 4;    // Put 1st ascii byte in upper nibble. <br>    *dest++ += BtoH(*srcptr++);      // Add 2nd ascii byte to above. <br>    } <br>} <br> <br>// <br>//  FUNCTION: BtoH(char *, char *, int) <br>// <br>//  PURPOSE:  Converts ascii byte to numeric <br>// <br>//  PARAMETERS: <br>//    ch - ascii byte to convert <br>// <br>//  RETURNS: <br>//    associated numeric value <br>// <br>//  COMMENTS: <br>// <br>//    Will convert any hex ascii digit to its numeric counterpart. <br>//    Puts in 0xff if not a valid hex digit. <br>// <br> <br>unsigned char BtoH(char ch) <br>{ <br>    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') return (ch - '0');        // Handle numerals <br>    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') return (ch - 'A' + 0xA);  // Handle capitol hex digits <br>    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') return (ch - 'a' + 0xA);  // Handle small hex digits <br>    return(255); <br>} <br> <br>// <br>//  FUNCTION: senddatamessage(SOCKET, LPDATAMSG) <br>// <br>//  PURPOSE:  sends a chat message to the server <br>// <br>//  PARAMETERS: <br>//    sock    - our socket handle <br>//    sendbuf - the message to send <br>// <br>//  RETURNS: <br>//    ascii byte <br>// <br>//  COMMENTS: <br>//    Send() may not be able to send entire message continue to send until <br>//    entire message is sent <br>// <br> <br>BOOL senddatamessage (SOCKET sock, LPDATAMSG sendbuf) <br>{ <br>    int totalbytes, bytessent; <br> <br>    bytessent = 0;                          // Set initial count to zero <br>    totalbytes = sendbuf-&gt;hdr.length;     // Set total bytes to send <br> <br>   // loop until entire message is sent <br>    while(bytessent &lt; totalbytes) <br>    { <br>        bytessent += send(sock, <br>                          (char *)sendbuf + bytessent, <br>                          totalbytes - bytessent, <br>                          0); <br>    } <br> <br>    return TRUE; <br>} <br> <br>// <br>//  FUNCTION: recvdatamessage(LPSOCKDATA, LPDATAMSG) <br>// <br>//  PURPOSE:  receives chat message from server <br>// <br>//  PARAMETERS: <br>//    lpSockdat - SOCKDATA structure <br>//    recvbuf   - buffer for incoming data <br>// <br>//  RETURNS: <br>//    TRUE  - Message received <br>//    FALSE - Message not received <br>// <br>//  COMMENTS: <br>//   For stream sockets we will need to make sure that we read <br>//    an entire message--no more, no less.  Find message size from <br>//    message header. <br>// <br> <br>BOOL recvdatamessage (LPSOCKDATA lpSockdat, LPDATAMSG recvbuf) <br>{ <br>    int readsize, totalbytesread, msgsize, bytesread; <br> <br>    if (lpSockdat-&gt;type == SOCK_SEQPACKET) <br>    { <br>        // Message mode protocol!!  Just post one big read. <br>        readsize = sizeof(*recvbuf); <br>    } <br>    else <br>    { <br>        // Stream mode protocol!!  Just read header...then read data (data size determined <br>        // from header) <br>        readsize = HDRSIZE; <br>    } <br>    if((totalbytesread = recv(lpSockdat-&gt;sock, (char *)recvbuf, readsize, 0)) == SOCKET_ERROR) <br>    { <br>        // ERROR  -- just return <br>        return FALSE; <br>    } <br> <br>    // Check for my signature at the beginning of the message <br>    if(recvbuf-&gt;hdr.signature != MYSIGNATURE) <br>    { <br>        // I've received some data that's in mid message--drop it <br>        return FALSE; <br>    } <br> <br>    // Read size of message <br>    msgsize = recvbuf-&gt;hdr.length; <br>    readsize = msgsize - totalbytesread; <br> <br>    while(totalbytesread &lt; msgsize) <br>    { <br>        // we should only get hear for stream sockets <br>        if((bytesread = recv(lpSockdat-&gt;sock, <br>                             (char *)recvbuf + totalbytesread, <br>                             readsize, <br>                             0)) == SOCKET_ERROR) <br>        { <br>            if (WSAGetLastError() != WSAEWOULDBLOCK) <br>            { <br>                // ERROR -- throw out message <br>                return FALSE; <br>            } <br>            // If you got a WSAWOULDBLOCK error, just keep trying...it shouldn't take <br>            // too much longer for the rest of the message to get here.  Let's hope <br>            // we don't hog the CPU so the data doesn't get to us. <br>        } <br>        totalbytesread += bytesread; <br>        readsize -= bytesread; <br>    } <br> <br>    return TRUE; <br>} <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
