<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MISC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5267"></a>MISC.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   misc.c <br>// <br>//  PURPOSE:  Contains all helper functions "global" to the application. <br>// <br>//  FUNCTIONS: <br>//    CenterWindow - Center one window over another. <br>//    AtoH - Converts ascii to network order hex <br>//    BtoH - Converts ascii byte to numeric <br>//    deregistername - Notifies "Available" peers of clients non-availability <br>//    senddatamessage - Sends a message to a client node <br>//    recvdatamessage - reads an entire message <br>//    UpdateClientList - Updates Client Status Listbox <br>//    MakeServSock - Attempts to initialize socket for listening <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>#include &lt;windows.h&gt;            // required for all Windows applications <br>#include &lt;windowsx.h&gt; <br>#include &lt;nspapi.h&gt; <br>#include &lt;svcguid.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnetbs.h&gt; <br>#include "globals.h"            // prototypes specific to this application <br> <br> <br> <br>// <br>//  FUNCTION: CenterWindow(HWND, HWND) <br>// <br>//  PURPOSE:  Center one window over another. <br>// <br>//  PARAMETERS: <br>//    hwndChild - The handle of the window to be centered. <br>//    hwndParent- The handle of the window to center on. <br>// <br>//  RETURN VALUE: <br>// <br>//    TRUE  - Success <br>//    FALSE - Failure <br>// <br>//  COMMENTS: <br>// <br>//    Dialog boxes take on the screen position that they were designed <br>//    at, which is not always appropriate. Centering the dialog over a <br>//    particular window usually results in a better position. <br>// <br> <br>BOOL CenterWindow(HWND hwndChild, HWND hwndParent) <br>{ <br>    RECT    rcChild, rcParent; <br>    int     cxChild, cyChild, cxParent, cyParent; <br>    int     cxScreen, cyScreen, xNew, yNew; <br>    HDC     hdc; <br> <br>    // Get the Height and Width of the child window <br>    GetWindowRect(hwndChild, &amp;rcChild); <br>    cxChild = rcChild.right - rcChild.left; <br>    cyChild = rcChild.bottom - rcChild.top; <br> <br>    // Get the Height and Width of the parent window <br>    GetWindowRect(hwndParent, &amp;rcParent); <br>    cxParent = rcParent.right - rcParent.left; <br>    cyParent = rcParent.bottom - rcParent.top; <br> <br>    // Get the display limits <br>    hdc = GetDC(hwndChild); <br>    cxScreen = GetDeviceCaps(hdc, HORZRES); <br>    cyScreen = GetDeviceCaps(hdc, VERTRES); <br>    ReleaseDC(hwndChild, hdc); <br> <br>    // Calculate new X position, then adjust for screen <br>    xNew = rcParent.left + ((cxParent - cxChild) / 2); <br>    if (xNew &lt; 0) <br>    { <br>        xNew = 0; <br>    } <br>    else if ((xNew + cxChild) &gt; cxScreen) <br>    { <br>        xNew = cxScreen - cxChild; <br>    } <br> <br>    // Calculate new Y position, then adjust for screen <br>    yNew = rcParent.top  + ((cyParent - cyChild) / 2); <br>    if (yNew &lt; 0) <br>    { <br>        yNew = 0; <br>    } <br>    else if ((yNew + cyChild) &gt; cyScreen) <br>    { <br>        yNew = cyScreen - cyChild; <br>    } <br> <br>    // Set it, and return <br>    return SetWindowPos(hwndChild, <br>                        NULL, <br>                        xNew, yNew, <br>                        0, 0, <br>                        SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br>// <br>//  FUNCTION: AtoH(char *, char *, int) <br>// <br>//  PURPOSE:  Converts ascii string to network order hex <br>// <br>//  PARAMETERS: <br>//    src    - pointer to input ascii string <br>//    dest   - pointer to output hex <br>//    destlen - size of dest <br>// <br>//  COMMENTS: <br>// <br>//    2 ascii bytes make a hex byte so must put 1st ascii byte of pair <br>//    into upper nibble and 2nd ascii byte of pair into lower nibble. <br>// <br> <br>void AtoH(char * src, char * dest, int destlen) <br>{ <br>    char * srcptr; <br> <br>    srcptr = src; <br> <br>    while(destlen--) <br>    { <br>    *dest = BtoH(*srcptr++) &lt;&lt; 4;    // Put 1st ascii byte in upper nibble. <br>    *dest++ += BtoH(*srcptr++);      // Add 2nd ascii byte to above. <br>    } <br>} <br> <br>// <br>//  FUNCTION: BtoH(char *, char *, int) <br>// <br>//  PURPOSE:  Converts ascii byte to numeric <br>// <br>//  PARAMETERS: <br>//    ch - ascii byte to convert <br>// <br>//  RETURNS: <br>//    associated numeric value <br>// <br>//  COMMENTS: <br>// <br>//    Will convert any hex ascii digit to its numeric counterpart. <br>//    Puts in 0xff if not a valid hex digit. <br>// <br> <br>unsigned char BtoH(char ch) <br>{ <br>    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') return (ch - '0');        // Handle numerals <br>    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') return (ch - 'A' + 0xA);  // Handle capitol hex digits <br>    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') return (ch - 'a' + 0xA);  // Handle small hex digits <br>    return(255); <br>} <br> <br>// <br>//  FUNCTION: deregistername(char *) <br>// <br>//  PURPOSE:  Removes client's availability from other "AVAILABLE" clients <br>// <br>//  PARAMETERS: <br>//    name - name to deregister <br>// <br>//  RETURNS: <br>//    nothing <br>// <br>//  COMMENTS: <br>// <br>//    Between the time when a client connects to the server and when it starts <br>//    a chat, the client is in "AVAILABLE" state.  It keeps of list of other <br>//    available peers.  deregistername removes a previously available client <br>//    from the lists of all the other available clients <br>// <br> <br>void deregistername(char * name) <br>{ <br>    int j; <br> <br>    // Set up message header <br>    xferbuf.hdr.signature = MYSIGNATURE; <br>    xferbuf.hdr.length = REALLEN(name) + HDRSIZE; <br>    xferbuf.hdr.command = DEREGISTER_NAME; <br>    // Message data is simply the name <br>    lstrcpy(xferbuf.data, name); <br> <br>    // Send to every connected client whose status is SOCKET_AVAILABLE <br>    for (j = 0; j &lt; NextFree; j++) <br>    { <br>        if (ConnectedSockets[j].status == SOCKSTAT_AVAILABLE) <br>        { <br>            senddatamessage(ConnectedSockets[j].sock, &amp;xferbuf); <br>        } <br>    } <br>    return; <br>} <br> <br>// <br>//  FUNCTION: senddatamessage(SOCKET, LPDATAMSG) <br>// <br>//  PURPOSE:  Sends a message to a client <br>// <br>//  PARAMETERS: <br>//    sock - Client socket to send data on <br>//    sendbuf - message to send <br>// <br>//  RETURNS: <br>//    TRUE - message sent <br>// <br>//  COMMENTS: <br>// <br>//    Performs send() until entire message is sent <br>// <br> <br>BOOL senddatamessage (SOCKET sock, LPDATAMSG sendbuf) <br>{ <br>    int totalbytes, bytessent; <br>   int thissendsize; <br> <br>    bytessent = 0;                    // start count of bytessent <br>    totalbytes = sendbuf-&gt;hdr.length; // read total bytes from message header <br>    while(bytessent &lt; totalbytes) <br>    { <br>        // We may not be able to send the entire message with a single <br>      // send.  Therefore continue sending until the whole thing <br>      // is gone. <br>        if ((thissendsize = send(sock, <br>                                (char *)sendbuf + bytessent, <br>                                totalbytes - bytessent, <br>                                0)) == SOCKET_ERROR) <br>      { <br>           // Error <br>          return FALSE; <br>       } <br>        bytessent += thissendsize; <br>    } <br> <br>    return TRUE; <br>} <br> <br>// <br>//  FUNCTION: recvdatamessage(LPSOCKDATA, LPDATAMSG) <br>// <br>//  PURPOSE:  Receives a message from a client <br>// <br>//  PARAMETERS: <br>//    lpSockdat - pointer to sockdata struct of socket we are receiving data on. <br>//    recvbuf - buffer to receive data into. <br>// <br>//  RETURNS: <br>//    TRUE - message received <br>//    FALSE - message not received <br>// <br>//  COMMENTS: <br>//    Performs recv() until entire message is received <br>// <br> <br>BOOL recvdatamessage (LPSOCKDATA lpSockdat, LPDATAMSG recvbuf) <br>{ <br>    int readsize, totalbytesread, msgsize, bytesread; <br> <br>    if (lpSockdat-&gt;type == SOCK_SEQPACKET) <br>    { <br>        // Message mode protocol!!  Just post one big read. <br>        readsize = sizeof(*recvbuf); <br>    } <br>    else <br>    { <br>        // Stream mode protocol!!  Just read header...then read data (data size determined <br>        // from header) <br>        readsize = HDRSIZE; <br>    } <br>    if((totalbytesread = recv(lpSockdat-&gt;sock, (char *)recvbuf, readsize, 0)) == SOCKET_ERROR) <br>    { <br>        // ERROR  -- just return dropping message <br>        return FALSE; <br>    } <br> <br>    // Check for my signature at the beginning of the message <br>    if(recvbuf-&gt;hdr.signature != MYSIGNATURE) <br>    { <br>        // I've received some data that's in mid message--drop it <br>        return FALSE; <br>    } <br> <br>    // Read size of message <br>    msgsize = recvbuf-&gt;hdr.length; <br>    readsize = msgsize - totalbytesread; <br> <br>    while(totalbytesread &lt; msgsize) <br>    { <br>        // we should only get hear for stream sockets <br>        if((bytesread = recv(lpSockdat-&gt;sock, <br>                             (char *)recvbuf + totalbytesread, <br>                             readsize, <br>                             0)) == SOCKET_ERROR) <br>        { <br>            if (WSAGetLastError() != WSAEWOULDBLOCK) <br>            { <br>                // ERROR -- throw out message <br>                return FALSE; <br>            } <br>            // If you got a WSAWOULDBLOCK error, just keep trying...it shouldn't take <br>            // too much longer for the rest of the message to get here.  Let's hope <br>            // we don't hog the CPU so the data doesn't get to us. <br>        } <br>        totalbytesread += bytesread; <br>        readsize -= bytesread; <br>    } <br> <br>    return TRUE; <br>} <br> <br>// <br>//  FUNCTION: UpdateClientList(char *, int, char *) <br>// <br>//  PURPOSE:  Updates Client Status List box <br>// <br>//  PARAMETERS: <br>//    name - name of client to update <br>//    status - status of client to display <br>//    peername - connected peer for status = IN_SESSION <br>// <br>//  RETURNS: <br>//    nothing <br>// <br>//  COMMENTS: <br>//    Finds and updates client status in listbox, or adds <br>//    it if client is new <br>// <br> <br> <br>void UpdateClientList(char * name, int status, char * peername) <br>{ <br>    int index; <br>    char outtext[80]; <br> <br>    // Find list box entry with name in it <br>    index = SendMessage(hwndClientList, <br>                        LB_FINDSTRING, <br>                        (WPARAM)-1, <br>                        (LPARAM)name); <br> <br>    // Delete the entry--we'll add a new entry below <br>    SendMessage(hwndClientList, LB_DELETESTRING, index, 0); <br> <br>    switch (status) <br>    { <br>        case SOCKSTAT_CLOSED:  // No new entry required.  Just return. <br>            return; <br> <br>       case SOCKSTAT_AVAILABLE:  // build available entry <br>            wsprintf(outtext, GetStringRes(IDS_AVAILABLE), name); <br>       break; <br> <br>       case SOCKSTAT_INSESSION:  // build in_session entry <br>            wsprintf(outtext, GetStringRes (IDS_SESSION), name, peername); <br>       break; <br> <br>       case SOCKSTAT_REQSESSION: // build reqsession entry <br>            wsprintf(outtext, GetStringRes(IDS_SESSION_SETUP), name, peername); <br>    } <br>   // Add the new list box entry to the client status list box <br>    SendMessage(hwndClientList, LB_ADDSTRING, 0, (LPARAM)&amp;outtext); <br>} <br> <br>// <br>//  FUNCTION: MakeServSock(HWND, LPSOCKDATA, LPPROTOCOL_INFO) <br>// <br>//  PURPOSE:  Attempts to initialize server side socket for listening <br>// <br>//  PARAMETERS: <br>//    hwnd - handle to main window <br>//    ServSocks - SOCKDATA struct to hold socket specific information <br>//    lpProtBuf - PROTOCOL_INFO struct describing protocol to <br>//                attempt listen on <br>// <br>//  RETURNS: <br>//    TRUE - Listen successfully posted <br>//    FALSE - Initialization failed <br>// <br>//  COMMENTS: <br>//    Given the protocol triple in the PROTOCOL_INFO struct, we call <br>//    socket(), then GetAddressByName(), then bind(), listen(), and <br>//    finally WSAAsyncSelect() to get socket it appropriate state <br>//    for listening.  If we fail at any point, then cleanup and do <br>//    not use protocol <br>// <br> <br>BOOL MakeServSock(HWND hwnd, LPSOCKDATA ServSocks, LPPROTOCOL_INFO lpProtBuf) <br>{ <br>   CSADDR_INFO CSABuf[10]; <br>   DWORD dwCSABufsize = sizeof(CSABuf); <br>   GUID guidNW =  SVCID_NETWARE(NWCHATID);  // Macro generates GUID using hard coded NetWare Service Type <br>   GUID guidDNS = SVCID_TCP(DNSCHATID);    // Macro generates GUID using hard coded port <br>   LPSOCKADDR_NB lpNBaddr; <br> <br>   // open socket using protocol defined by PROTOCOL_INFO structure <br>   if ((ServSocks-&gt;sock = socket(lpProtBuf-&gt;iAddressFamily, <br>                                       lpProtBuf-&gt;iSocketType, <br>                                       lpProtBuf-&gt;iProtocol)) == SOCKET_ERROR) <br>   { <br>       // ERROR <br>      return FALSE;  // This will reuse the current ServSocks structure <br>   } <br> <br>   // Populate SOCKDATA structure <br>   ServSocks-&gt;status = SOCKSTAT_INIT; <br>   ServSocks-&gt;type = lpProtBuf-&gt;iSocketType; <br>   ServSocks-&gt;protocol = lpProtBuf-&gt;iProtocol; <br>   ServSocks-&gt;currconnects = 0; <br>   ServSocks-&gt;lpProtocolName = lpProtBuf-&gt;lpProtocol; <br> <br>   // *********************************************************************** <br>   // <br>   //    Below we will be calling GetAddressByName with the RES_SERVICE <br>   //    option in order to find the necessary sockaddr structure to use <br>   //    for the following bind() call.  At this point, GetAddressByName() <br>   //    only supports the DNS and the SAP/Bindery name spaces.  Ultimately <br>   //    a single call to GetAddressByName will return information on <br>   //    all available protocols, but this requires a central database <br>   //    which is currently not available.  In the mean time we will make <br>   //    name space specific calls to GetAddressByName. <br>   // <br>   // *********************************************************************** <br> <br>   switch (lpProtBuf-&gt;iAddressFamily) <br>   { <br>       case AF_IPX: <br>           // Use SAP/Bindery Name Space <br>           if (GetAddressByName(0,    // Since GUID is name space specific, we don't need to specify distinct name space. <br>                                &amp;guidNW,  // GUID defined by NetWare service type. <br>                                "GLOBAL CHAT SERVER",  // This parameter is actually not used for RES_SERVICE calls. <br>                                NULL,    // Since GUID implies the protocol, we don't need to specify a distinct one. <br>                                RES_SERVICE,  // Specifies that we are just looking for local address to bind to. <br>                                NULL,   // Currently not supported <br>                                CSABuf, // Structure which will hold information for bind() call <br>                                &amp;dwCSABufsize,  // Size of CSABuf <br>                                NULL,   //  Currently not supported <br>                                NULL)   // Currently not supported <br>                                &lt; 1)    // We need at least one address returned in order to bind() <br>           { <br>               // Error--cleanup <br>            closesocket(ServSocks-&gt;sock); <br>            return FALSE; <br>           } <br> <br>         // Copy sockaddr info and addresslength <br>         memcpy(&amp;ServSocks-&gt;addr, CSABuf[0].LocalAddr.lpSockaddr, sizeof(struct sockaddr)); <br>         ServSocks-&gt;addrlen = CSABuf[0].LocalAddr.iSockaddrLength; <br>           break; <br> <br>      case AF_INET: <br>           // Use DNS Name Space <br>           if (GetAddressByName(0,   // Since GUID is name space specific, we don't need to specify <br>                                &amp;guidDNS,  // GUID defined by TCP port number <br>                                "globchat",  // This parameter is actually not used for RES_SERVICE calls <br>                                NULL,    // GUID implies protocol so no need to specify <br>                                RES_SERVICE,  // Specifies that we are trying to find local address to bind to <br>                                NULL,  // Currently not supported <br>                                CSABuf, // Results buffer <br>                                &amp;dwCSABufsize,   // Size of results buffer <br>                                NULL,    // Not supported <br>                                NULL)    // Not supported <br>                                &lt; 1)   // Need at least one address returned in order to bind() <br>           { <br>               // Error -- cleanup <br>            closesocket(ServSocks-&gt;sock); <br>            return FALSE; <br>           } <br>         // Copy sockaddr info and address length <br>         memcpy(&amp;ServSocks-&gt;addr, CSABuf[0].LocalAddr.lpSockaddr, sizeof(struct sockaddr)); <br>         ServSocks-&gt;addrlen = CSABuf[0].LocalAddr.iSockaddrLength; <br>           break; <br> <br>       case AF_NETBIOS: <br>           // no netbios name space provider so we will simulate GetAddressByName() results <br>         lpNBaddr = (LPSOCKADDR_NB)&amp;ServSocks-&gt;addr; <br>           SET_NETBIOS_SOCKADDR(lpNBaddr, <br>                                NETBIOS_GROUP_NAME, <br>                                "GLOBSERV", <br>                                0); <br>         ServSocks-&gt;addrlen = lpProtBuf-&gt;iMaxSockAddr; <br>           break; <br> <br>   } <br> <br>   // We have an address to bind() to, so do it! <br>   if (bind(ServSocks-&gt;sock, <br>            &amp;ServSocks-&gt;addr, <br>           ServSocks-&gt;addrlen) == SOCKET_ERROR) <br>   { <br>       // Error -- cleanup <br>      closesocket(ServSocks-&gt;sock); <br>      return FALSE; <br>   } <br> <br>   // Find out the specific local address <br>   if (getsockname(ServSocks-&gt;sock, <br>                   &amp;ServSocks-&gt;addr, <br>                   &amp;ServSocks-&gt;addrlen) == SOCKET_ERROR) <br>   { <br>       // Error -- better cleanup <br>       closesocket(ServSocks-&gt;sock); <br>      return FALSE; <br>   } <br> <br>   // Listen on the socket <br>   if (listen(ServSocks-&gt;sock, 5) == SOCKET_ERROR) <br>   { <br>       // Error -- cleanup <br>       closesocket(ServSocks-&gt;sock); <br>      return FALSE; <br>   } <br> <br>   // Set up window message to indicate connection <br>   if (WSAAsyncSelect(ServSocks-&gt;sock, <br>                      hwnd, <br>                     MW_CONNECTED, <br>                  FD_ACCEPT) == SOCKET_ERROR) <br>   { <br>       // Error -- cleanup <br>      closesocket(ServSocks-&gt;sock); <br>      return FALSE; <br>   } <br> <br>   // Success!!! <br>   return TRUE; <br>} <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
