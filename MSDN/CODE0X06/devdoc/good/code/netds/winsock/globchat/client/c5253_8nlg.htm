<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONNECT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5254"></a>CONNECT.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   connect.c <br>// <br>//  PURPOSE:   Displays the "Connect" dialog box <br>// <br>//  FUNCTIONS: <br>//    CmdConnect              - Displays the "Connect" dialog box <br>//    Connect                 - Processes messages for "Connect" dialog box. <br>//    MsgConnectInit          - Initializes edit controls <br>//    MsgConnectReadyForWrite - Sends name registration message when connection <br>//                              established with server <br>//    MsgConnectCommand       - Process WM_COMMAND message sent to the connect box. <br>//    CmdConnectDone          - Free the connect box and related data. <br>//    CmdConnectNow           - Establishes connection to server. <br>//    CmdConnectEnableOK      - Enables/Disables OK button when input data is <br>//                              valid/invalid <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>#include &lt;windows.h&gt;            // required for all Windows applications <br>#include &lt;windowsx.h&gt; <br>#include &lt;wsipx.h&gt;              // IPX sockets <br>#include &lt;wsnetbs.h&gt;            // NetBIOS sockets <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;nspapi.h&gt; <br>#include &lt;svcguid.h&gt; <br>#include "globals.h"            // prototypes specific to this application <br> <br>#define WSN_READYFORWRITE   700 // dlg window message indicating the connection is ready to send on <br> <br>//   Function Definitions <br> <br>LRESULT CALLBACK Connect(HWND, UINT, WPARAM, LPARAM); <br>LRESULT MsgConnectInit(HWND, UINT, WPARAM, LPARAM); <br>LRESULT MsgConnectReadyForWrite(HWND, UINT, WPARAM, LPARAM); <br>LRESULT MsgConnectCommand(HWND, UINT, WPARAM, LPARAM); <br>LRESULT CmdConnectNow(HWND, WORD, WORD, HWND); <br>LRESULT CmdConnectDone(HWND, WORD, WORD, HWND); <br>LRESULT CmdConnectEnableOK(HWND, WORD, WORD, HWND); <br> <br>// Connect dialog message table definition. <br>MSD rgmsdConnect[] = <br>{ <br>    {WM_COMMAND,        MsgConnectCommand}, <br>    {WM_INITDIALOG,     MsgConnectInit}, <br>    {WSN_READYFORWRITE,  MsgConnectReadyForWrite} <br>}; <br> <br>MSDI msdiConnect = <br>{ <br>    sizeof(rgmsdConnect) / sizeof(MSD), <br>    rgmsdConnect, <br>    edwpNone <br>}; <br> <br>// Connect dialog command table definition. <br>CMD rgcmdConnect[] = <br>{ <br>    {IDOK,        CmdConnectNow}, <br>    {IDCANCEL,    CmdConnectDone}, <br>    {CD_NAME,     CmdConnectEnableOK}, <br>    {CD_PROTOCOL, CmdConnectEnableOK}, <br>   {CD_SERVER,   CmdConnectEnableOK} <br>}; <br> <br>CMDI cmdiConnect = <br>{ <br>    sizeof(rgcmdConnect) / sizeof(CMD), <br>    rgcmdConnect, <br>    edwpNone <br>}; <br> <br>// Module specific "globals"  Used when a variable needs to be <br>// accessed in more than one handler function. <br> <br>HFONT hfontDlg; <br> <br>// <br>//  FUNCTION: CmdConnect(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Displays the "Connect" dialog box <br>// <br>//  PARAMETERS: <br>//    hwnd      - Window handle <br>//    wCommand  - IDM_CONNECT (unused) <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl  - NULL (unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>//    To process the IDM_CONNECT message, call DialogBox() to display the <br>//    Connect dialog box. <br> <br>LRESULT CmdConnect(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br> <br>    // Start dialog box <br>    if(DialogBox(hInst, "ConnectBox", hwnd, (DLGPROC)Connect)) <br>    { <br>        // We have a connection and have registered our name.  Set up Select dialog. <br>        PostMessage(hwnd, WM_COMMAND, MAKELONG(IDM_SELECT,0), 0); <br>        return 0; <br>    } <br> <br>    // Connection failed - reset window title <br>    SetWindowText(hwnd, szTitle); <br>    return 0; <br>} <br> <br> <br>// <br>//  FUNCTION: Connect(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE:  Processes messages for "Connect" dialog box. <br>// <br>//  PARAMETERS: <br>//    hdlg - window handle of the dialog box <br>//    wMessage - type of message <br>//    wparam - message-specific information <br>//    lparam - message-specific information <br>// <br>//  RETURN VALUE: <br>//    TRUE - message handled <br>//    FALSE - message not handled <br>// <br>//  COMMENTS: <br>// <br>//     Gets connection information from user and then establishes a connection. <br>// <br>//     Connect when user clicks on the OK button.  Kill Dialog when connection <br>//     established. <br>// <br> <br>LRESULT CALLBACK Connect(HWND hdlg, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    return DispMessage(&amp;msdiConnect, hdlg, uMessage, wparam, lparam); <br>} <br> <br> <br>// <br>//  FUNCTION: MsgConnectInit(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: To center dialog, limit size of edit controls, and set up available protocols <br>//           to connect with <br>// <br>//  PARAMETERS: <br>//    hdlg - The window handling the message. <br>//    uMessage - The message number. (unused). <br>//    wparam - Message specific data (unused). <br>//    lparam - Message specific data (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - message handled. <br>// <br>//  COMMENTS: <br>//    Set size of edit controls for the following <br>//           Network  8  chars (4 2-digit hex numbers) <br>//           Node     12 chars (6 2-digit hex numbers) <br>//           Socket   4  chars (2 2-digit hex numbers) <br>// <br> <br>LRESULT MsgConnectInit(HWND hdlg, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    int numStrucs; <br>    int j, k; <br>    int iProtBufSize = 0; <br>   char outtext[80]; <br> <br>    // Create a font to use <br>    hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                          VARIABLE_PITCH | FF_SWISS, ""); <br> <br>    // Center the dialog over the application window <br>    CenterWindow (hdlg, GetWindow (hdlg, GW_OWNER)); <br> <br>   // Call EnumProtocols with NULL buffer in order to determine size of buffer required <br>   EnumProtocols(NULL, NULL, &amp;iProtBufSize); <br> <br>    if (((LPVOID)lpProtBuf = VirtualAlloc(NULL, <br>                                          iProtBufSize, <br>                                          MEM_COMMIT, <br>                                          PAGE_READWRITE)) == NULL) <br>    { <br>        // ERROR -- abort <br>        return 0; <br>    } <br> <br>    // Calling EnumProtocols with large enough buffer <br>    if ((numStrucs = EnumProtocols(NULL, lpProtBuf, &amp;iProtBufSize)) == SOCKET_ERROR) <br>    { <br>        // Error -- abort <br>        return 0; <br>    } <br> <br>   // Add every connection oriented protocol to protocol combo box <br>    for (j = 0, k = 0; j &lt; numStrucs; j++) <br>    { <br>        if ((lpProtBuf[j].dwServiceFlags &amp; XP_CONNECTIONLESS) == 0) <br>        { <br>         wsprintf(outtext, "%2d: %s", k, lpProtBuf[j].lpProtocol); <br>            SendMessage(GetDlgItem(hdlg, CD_PROTOCOL), CB_ADDSTRING, 0, (LPARAM)outtext); <br>            goodprots[k++] = j; // Keep track of good protocols <br>        } <br>    } <br> <br>    // Limit size of edit controls <br>    SendDlgItemMessage(hdlg, CD_NAME, EM_LIMITTEXT, 15, 0); <br> <br>    // Initialize Edit Controls <br>    SetDlgItemText(hdlg, CD_NAME, szConnectName); <br> <br>    return (TRUE); <br>} <br> <br>// <br>//  FUNCTION: MsgConnectReadyForWrite(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Receive notification of connected socket and register name <br>// <br>//  PARAMETERS: <br>//    hwnd - The window handing the message. <br>//    uMessage - The message number. (unused). <br>//    wparam - Message specific data (unused). <br>//    lparam - Message specific data (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - message handled. <br>// <br>//  COMMENTS: <br>//    Uses this DispCommand function defined in wndproc.c combined <br>//    with the cmdiConnect structure defined in this file to handle <br>//    the command messages for the Connect dialog box. <br>// <br> <br>LRESULT MsgConnectReadyForWrite(HWND   hwnd, <br>                                UINT   uMessage, <br>                                WPARAM wparam, <br>                                LPARAM lparam) <br>{ <br>    char outtext[80]; <br> <br>    // Build our name <br>    GetDlgItemText(hwnd, CD_NAME, MySock.name, sizeof(MySock.name)); <br> <br>    // Build name registration packet <br>    xferbuf.hdr.signature = MYSIGNATURE;                 // signature <br>    xferbuf.hdr.length = REALLEN(MySock.name) + HDRSIZE; <br>    lstrcpy(xferbuf.data, MySock.name);                  // copy name <br>    xferbuf.hdr.command = REGISTER_NAME;                 // REGISTER_NAME command <br> <br>    // Lets send it <br>    senddatamessage(MySock.sock, &amp;xferbuf); <br> <br>    wsprintf(outtext, GetStringRes(IDS_CHAT_AVAIL), MySock.name); <br> <br>    SetWindowText(GetParent(hwnd), outtext); <br> <br>    EndDialog(hwnd, TRUE);          // Exit the dialog <br>    DeleteObject (hfontDlg); <br>    return (TRUE); <br>} <br> <br>// <br>//  FUNCTION: MsgConnectCommand(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Process WM_COMMAND message sent to the Connect box. <br>// <br>//  PARAMETERS: <br>//    hwnd - The window handing the message. <br>//    uMessage - The message number. (unused). <br>//    wparam - Message specific data (unused). <br>//    lparam - Message specific data (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - message handled. <br>// <br>//  COMMENTS: <br>//    Uses this DispCommand function defined in wndproc.c combined <br>//    with the cmdiConnect structure defined in this file to handle <br>//    the command messages for the Connect dialog box. <br>// <br> <br>LRESULT MsgConnectCommand(HWND   hwnd, <br>                          UINT   uMessage, <br>                          WPARAM wparam, <br>                          LPARAM lparam) <br>{ <br>    return DispCommand(&amp;cmdiConnect, hwnd, wparam, lparam); <br>} <br> <br>// <br>//  FUNCTION: CmdConnectDone(HWND, WORD, HWND) <br>// <br>//  PURPOSE: Free the Connect box and related data. <br>// <br>//  PARAMETERS: <br>//    hdlg - The window handling the command. <br>//    wCommand - The command to be handled (unused). <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl - NULL (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns TRUE. <br>// <br>//  COMMENTS: <br>//    Cleans up sockets then calls EndDialog to finish the dialog session. <br>// <br> <br>LRESULT CmdConnectDone(HWND hdlg, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br> <br>    closesocket(MySock.sock);      // Free any aborted socket resources <br>    EndDialog(hdlg, FALSE);        // Exit Dialog -- rtrn false since no connection <br>    return TRUE; <br>} <br> <br>// <br>//  FUNCTION: CmdConnectNow(HWND, WORD, HWND) <br>// <br>//  PURPOSE: Establish the connection <br>// <br>//  PARAMETERS: <br>//    hdlg - The window handling the command. <br>//    wCommand - The command to be handled (unused). <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl - NULL (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns TRUE. <br>// <br>//  COMMENTS: <br>//    Makes Connection calls <br>// <br> <br>LRESULT CmdConnectNow(HWND hdlg, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    int iIndex; <br>    char outtext[80]; <br>    int numStrucs; <br>   GUID guidNW = SVCID_NETWARE(NWCHATID); <br>   GUID guidDNS = SVCID_TCP(DNSCHATID); <br> <br>    // Get protocol selected <br>    iIndex = SendMessage(GetDlgItem(hdlg, CD_PROTOCOL), CB_GETCURSEL, 0, 0); <br> <br>   // ************************************************************************ <br>   // <br>   //    Below we will be calling GetAddressByName with the RES_FIND_MULTIPLE <br>   //    option in order to find a remote address to connect() to.  At this <br>   //    point, GetAddressByName() only supports the DNS and the SAP/Bindery <br>   //    name spaces.  Ultimately a single call to GetAddressByName will <br>   //    query all available protocols and name spaces, but this requires a <br>   //    central database which is currently not available.  In the mean time <br>   //    we will make name space specific calls to GetAddressByName. <br>   // <br>   // *********************************************************************** <br> <br>    switch (lpProtBuf[goodprots[iIndex]].iAddressFamily) <br>    { <br>        case AF_IPX: <br>          //  SAP/Bindery Name Space <br>          dwCSABufsize = sizeof(CSABuf); <br>            if (((numStrucs = GetAddressByName(0,  // GUID indicates name space so we don't need to specify <br>                                               &amp;guidNW, // GUID generated from NetWare service type <br>                                               "GLOBCHAT", // Name of service to look for <br>                                               NULL, // GUID implies IPX/SPX protocols <br>                                               RES_FIND_MULTIPLE, // We might get multiple responses <br>                                               NULL, // Not currently supported <br>                                               CSABuf, // results buffer <br>                                               &amp;dwCSABufsize,  // size of results buffer <br>                                               NULL,  // not supported <br>                                               NULL)  // not supported <br>                                               ) == SOCKET_ERROR) || (numStrucs == 0)) <br>            { <br>                // Error -- try another protocol.  We've got lots! <br> <br>                MessageBox(hdlg, GetStringRes(IDS_ERR_SERVER_NOT_FOUND), NULL, MB_OK); <br>                EnableWindow(GetDlgItem(hdlg, IDOK), FALSE); <br>                SetFocus(GetDlgItem(hdlg, CD_PROTOCOL)); <br>                return 0; <br>            } <br>            break; <br> <br>        case AF_INET: <br>            //  DNS Name Space <br> <br>            // Static Name Space requires us to specify the host name <br>            GetDlgItemText(hdlg, CD_SERVER, lpServName, sizeof(lpServName)); <br>         dwCSABufsize = sizeof(CSABuf); <br>            if (((numStrucs = GetAddressByName(0,    // GUID indicates name space so we don't need to specify <br>                                             &amp;guidDNS, // GUID generated from TCP port number <br>                                             lpServName, // Name of host to look for <br>                                             NULL, // GUID implies UDP/TCP protocols <br>                                             RES_FIND_MULTIPLE, // We might get multiple responses <br>                                             NULL, // Not currently supported <br>                                             CSABuf, // results buffer <br>                                             &amp;dwCSABufsize, // size of results buffer <br>                                             NULL, // not supported <br>                                             NULL) // not supported <br>                                             ) == SOCKET_ERROR) || (numStrucs == 0)) <br>            { <br>                // Error -- try another protocol.  We've got lots! <br> <br>                MessageBox(hdlg, GetStringRes(IDS_ERR_SERVER_NOT_FOUND), NULL, MB_OK); <br> <br>                EnableWindow(GetDlgItem(hdlg, IDOK), FALSE); <br>                SetFocus(GetDlgItem(hdlg, CD_PROTOCOL)); <br>                return 0; <br>            } <br>            break; <br> <br>        case AF_NETBIOS: <br>         // NetBIOS name space??? <br> <br>            // no netbios name space provider so fill in lpCSABuf ourselves <br>            numStrucs = 1; <br>            CSABuf[0].iSocketType = lpProtBuf[goodprots[iIndex]].iSocketType; <br>            CSABuf[0].iProtocol = lpProtBuf[goodprots[iIndex]].iProtocol; <br> <br>            SET_NETBIOS_SOCKADDR(&amp;NBAddr, <br>                                 NETBIOS_GROUP_NAME, <br>                                 "GLOBSERV", <br>                                 0); <br>           CSABuf[0].RemoteAddr.lpSockaddr = (LPSOCKADDR)&amp;NBAddr; <br>         CSABuf[0].RemoteAddr.iSockaddrLength = sizeof(NBAddr); <br>            break; <br> <br>        default: <br>          // We don't support anything else <br>            MessageBox(hdlg, <br>                       GetStringRes(IDS_ERR_NAMESPACE_NOT_SUPPORTED), <br>                       NULL, MB_OK); <br> <br>            EnableWindow(GetDlgItem(hdlg, IDOK), FALSE); <br>            SetFocus(GetDlgItem(hdlg, CD_PROTOCOL)); <br>            return 0; <br>    } <br> <br>   // Populate SOCKDATA struct <br>    MySock.type = lpProtBuf[goodprots[iIndex]].iSocketType; <br>    MySock.protocol = lpProtBuf[goodprots[iIndex]].iProtocol; <br> <br>    SetDlgItemText(hdlg, CD_HELP, GetStringRes(IDS_CALLING_SOCKET)); <br> <br>   // Call socket() using triple provided by EnumProtocols() <br>    if((MySock.sock = socket(lpProtBuf[goodprots[iIndex]].iAddressFamily, <br>                             lpProtBuf[goodprots[iIndex]].iSocketType, <br>                             lpProtBuf[goodprots[iIndex]].iProtocol)) == INVALID_SOCKET) <br>    { <br>        // ERROR <br>        wsprintf(outtext, GetStringRes(IDS_ERR_SOCKET_FAILED), WSAGetLastError()); <br>        SetDlgItemText(hdlg, CD_HELP, outtext); <br>        return 0; <br>    } <br> <br>    SetDlgItemText(hdlg, CD_HELP, GetStringRes(IDS_CALLING_CONNECT)); <br> <br>   // Call connect() using info from GetAddressByName() <br>    if (connect(MySock.sock, <br>                CSABuf[0].RemoteAddr.lpSockaddr, <br>                CSABuf[0].RemoteAddr.iSockaddrLength) == SOCKET_ERROR) <br>    { <br>        // ERROR <br>        wsprintf(outtext, <br>                 GetStringRes(IDS_ERR_CONNECT_FAILED), WSAGetLastError()); <br> <br>        SetDlgItemText(hdlg, CD_HELP, outtext); <br>        return 0; <br>    } <br> <br>    // Signal for when we are ready for writing <br> <br>    SetDlgItemText(hdlg, CD_HELP, GetStringRes(IDS_WAITING_FOR_ACCEPT)); <br> <br>   // Specify message to signal accepted socket <br>    if (WSAAsyncSelect(MySock.sock, hdlg, WSN_READYFORWRITE, FD_WRITE) == SOCKET_ERROR) <br>    { <br>        wsprintf(outtext, <br>                 GetStringRes(IDS_ERR_WSAASYNCSELECT), WSAGetLastError()); <br> <br>        SetDlgItemText(hdlg, CD_HELP, outtext); <br>        return 0; <br>    } <br>    return 0; <br> <br>} <br> <br>// <br>//  FUNCTION: CmdConnectEnableOK(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Enable/Disable OK button when input data is valid/invalid <br>// <br>//  PARAMETERS: <br>//    hdlg - The window handling the command. <br>//    wCommand - The command to be handled (unused). <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl - NULL (unused). <br>// <br>//  RETURN VALUE: <br>//    Always returns TRUE. <br>// <br>//  COMMENTS: <br>//    Checks for acceptable name and protocol.  We also need an acceptable <br>//    machine name for TCP/IP protocol since DNS name space is static <br>// <br> <br>LRESULT CmdConnectEnableOK(HWND hdlg, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    char buf[128]; <br>   int iIndex; <br> <br>    // Is message a change notification? <br>    if ((wNotify == CBN_SELCHANGE) || (wNotify == EN_CHANGE)) <br>    { <br>        // Yes!, get protocol <br>        iIndex = SendMessage(GetDlgItem(hdlg, CD_PROTOCOL), CB_GETCURSEL, 0, 0); <br>      if (iIndex == LB_ERR) <br>      { <br>          // No protocol selected...OK disabled <br>          EnableWindow(GetDlgItem(hdlg, IDOK), FALSE); <br>          return TRUE; <br>      } <br>        // Protocol selected!  Check which one... <br>        switch(lpProtBuf[goodprots[iIndex]].iAddressFamily) <br>        { <br>            case AF_IPX: <br>            case AF_NETBIOS: <br>                // For IPX and NetBIOS, we don't need the machine name <br>            // so hide that edit control <br>                ShowWindow(GetDlgItem(hdlg, CD_SERVER), SW_HIDE); <br>                ShowWindow(GetDlgItem(hdlg, CD_SERVER_TEXT), SW_HIDE); <br> <br>            // We already have a protocol selected.  Do we have a name? <br>                if(GetDlgItemText(hdlg, CD_NAME, buf, sizeof(buf)) &gt;= 1) <br>                { <br>                    // Yes, we have a name and a protocol.  Enable OK. <br>                    EnableWindow(GetDlgItem(hdlg, IDOK), TRUE); <br>                } <br>            else <br>            { <br>                // We don't have a name.  Disable OK. <br>                EnableWindow(GetDlgItem(hdlg, IDOK), FALSE); <br>            } <br>                return TRUE; <br> <br>            case AF_INET: <br>             // For TCP/IP we need a protocol, name, and machine name <br>            // in order for data to be valid <br> <br>            // Enable Machine name edit control and text <br>                ShowWindow(GetDlgItem(hdlg, CD_SERVER), SW_SHOW); <br>            ShowWindow(GetDlgItem(hdlg, CD_SERVER_TEXT), SW_SHOW); <br>            EnableWindow(GetDlgItem(hdlg, CD_SERVER), TRUE); <br>            EnableWindow(GetDlgItem(hdlg, CD_SERVER_TEXT), TRUE); <br> <br>                // We have a protocol selected.  Do we have a name and a server name <br>                if((GetDlgItemText(hdlg, CD_NAME, buf, sizeof(buf)) &gt;= 1) &amp;&amp; <br>                   (GetDlgItemText(hdlg, CD_SERVER, buf, sizeof(buf)) &gt;= 1)) <br>                { <br>                    // YES!  Enable OK. <br>                    EnableWindow(GetDlgItem(hdlg, IDOK), TRUE); <br>               SendMessage(GetDlgItem(hdlg, IDOK), BM_SETSTYLE, (WPARAM) LOWORD(BS_DEFPUSHBUTTON), MAKELPARAM(TRUE, 0)); <br>                } <br>            else <br>            { <br>                // No name or server name.  Disable OK. <br>                EnableWindow(GetDlgItem(hdlg, IDOK), FALSE); <br>            } <br>                return TRUE; <br> <br>            default: <br>                // We only support DNS, SAP/Bindery, and we simulate NetBIOS name spaces. <br> <br>                SetDlgItemText(hdlg, CD_HELP, <br>                               GetStringRes(IDS_ERR_UNSUPPORTED_PROTOCOL)); <br> <br>                EnableWindow(GetDlgItem(hdlg, IDOK), FALSE); <br>                return TRUE; <br>        } <br>    } <br> <br>    // When protocol combo box gets the focus, set help text at bottom of dialog <br>    if (wNotify == CBN_SETFOCUS) <br>    { <br>        SetDlgItemText(hdlg, CD_HELP, <br>                       GetStringRes(IDS_SELECT_PROTOCOL)); <br>    } <br> <br>    if (wNotify == EN_SETFOCUS) <br>    { <br>        if (hwndCtrl == GetDlgItem(hdlg, CD_NAME)) <br>        { <br>            // When name edit control gets the focus, set help text at bottom of dialog. <br> <br>            SetDlgItemText(hdlg, CD_HELP, GetStringRes(IDS_ENTER_NAME)); <br>        } <br>        else <br>        { <br>            // When server edit control gets the focus, set help text at bottom of dialog. <br> <br>            SetDlgItemText(hdlg, CD_HELP, GetStringRes(IDS_ENTER_MACHINE_NAME)); <br>        } <br>    } <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
