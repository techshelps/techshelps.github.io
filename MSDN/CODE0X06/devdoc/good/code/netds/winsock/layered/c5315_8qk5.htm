<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRACE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5315"></a>TRACE.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br>Module Name: <br> <br>    TRACE.CPP : <br> <br>Abstract: <br> <br>    This module implements the traceing functions used in the winsock2 layered <br>    service provider example. <br> <br> <br>--*/ <br>#define WIN32_LEAN_AND_MEAN <br>#include "nowarn.h" <br> <br>#include &lt;windows.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;malloc.h&gt; <br> <br>/* because windows.h is brain damaged and turns this one back on */ <br>#pragma warning(disable: 4001) <br> <br>#include "trace.h" <br> <br>#ifdef TRACING <br> <br>// <br>// Internal functions <br>// <br>BOOL  InitMemoryBuffers(VOID); <br> <br>// <br>// Module local variables <br>// <br> <br>// The buffers to use to format debug messages. <br>LPSTR g_CurrentMessage=NULL; <br>LPSTR g_PreviousMessage=NULL; <br> <br>// Critcal section to keep multiple thread from walking on each others output <br>CRITICAL_SECTION OutputRoutine; <br> <br>// Where should the output go? If it is a file what is the file name <br>int iTraceDestination=TRACE_TO_AUX; <br>char TraceFile[] = "trace.log"; <br> <br>// The default output level <br>DWORD debugLevel=0xFFFFFFFF; <br> <br> <br>  <br>VOID <br>PrintDebugString( <br>                 char *Format, <br>                 ... <br>                 ) <br>/*++ <br>  Routine Description: <br> <br>  This routine outputs a debug messages.  Debug messages are routed <br>  to a file or a debug window depnding on the value of a global <br>  variable defined in this module <br> <br>  Arguments: <br> <br>  Format - A "printf()" compatable format specification. <br> <br>  ... - Additional arguments to "printf()" format specification. <br> <br>  Returns: <br> <br>  NONE <br> <br>  --*/ <br>{ <br>va_list ArgumentList; // argument list for varargs processing <br>static HANDLE OutputFile =NULL; // file descriptor for file output <br>static OFSTRUCT of; // open file struct for file output <br>static int RepeatCount=0; // Count of repeated output statements <br>static BOOL LogOpened = FALSE; // have we opened the file for <br>                                     // output <br>    static BOOL TraceInited = FALSE; <br>    DWORD  BytesWritten; <br> <br>if (!TraceInited) <br>{ <br>        HANDLE InitMutex; <br>        // Create the mutex to protect the rest of the init code <br>        InitMutex = CreateMutex( <br>            NULL,  // Use default security attributes <br>            FALSE, // We don't want automatic ownership <br>            "TraceMutextName"); <br>        if (!InitMutex) <br>        { <br>            // We failed to create the mutex there is nothign else we <br>            // can do so return.  This will cause the debug output to <br>            // be silently lost. <br>            return; <br>        } //if <br> <br>        // Wait on mutex <br>        WaitForSingleObject( InitMutex, <br>                             INFINITE); <br> <br>        // Check to see if init is still needed <br>        if (!TraceInited) <br>        { <br>            // Init the critical section to be used to protect the <br>            // output portion of this routine. <br>            InitializeCriticalSection( &amp;OutputRoutine ); <br>// Note: <br>// DeleteCriticalSection will not be called on this critical section <br>// we are reling on the OS to clean this one up.  We are doing this so <br>// the user of this module does not have to Init/DeInit the module explicitly. <br> <br>            // allocate buffers to hold debug messages <br>            if (InitMemoryBuffers()) <br>            { <br>                TraceInited = TRUE; <br>            } //if <br>        } //if <br> <br>        // Signal the mutex and delete this threads handle to the mutex <br>        ReleaseMutex(InitMutex); <br>        CloseHandle(InitMutex); <br>} <br> <br> <br>    // Here is where all the heavy lifting starts <br>    EnterCriticalSection( &amp;OutputRoutine ); <br> <br>    // print the user message to our buffer <br>va_start(ArgumentList, Format); <br>vsprintf(g_CurrentMessage, Format, ArgumentList); <br>va_end(ArgumentList); <br> <br>    // Is the current debug message the same as the last debug <br>    // message?  If the two messages are the same just increment the <br>    // count of message repeats and return.  This keeps the system <br>    // from being flooded with debug messages that may be being <br>    // generated from inside a loop. <br> <br>if(lstrcmp(g_CurrentMessage, g_PreviousMessage)) <br>{ <br>if (iTraceDestination == TRACE_TO_FILE) <br>{ <br>            if (!LogOpened) <br>            { <br>                OutputFile = <br>                CreateFile( TraceFile, <br>                            GENERIC_WRITE,     // open for writing <br>                            FILE_SHARE_WRITE,  // Share the file with others <br>                            NULL,              // default security <br>                            OPEN_ALWAYS,       // Use file if it exsits <br>                            FILE_ATTRIBUTE_NORMAL, // Use a normal file <br>                            NULL);             // No template <br> <br>                if (OutputFile != INVALID_HANDLE_VALUE) <br>                { <br>                    LogOpened = TRUE; <br>                } //if <br>            } //if <br> <br>            if (LogOpened) <br>            { <br>                if (RepeatCount &gt; 0) <br>                { <br>                    wsprintf(g_PreviousMessage, <br> "Last Message Repeated &lt; %d &gt; times\n", <br> RepeatCount); <br> <br>                    WriteFile(OutputFile, <br>                              g_PreviousMessage, <br>                              lstrlen(g_PreviousMessage), <br>                              &amp;BytesWritten, <br>                              NULL); <br>                } //if <br> <br>                // Write the current message to the trace file <br>                WriteFile(OutputFile, <br>                          g_CurrentMessage, <br>                          lstrlen(g_CurrentMessage), <br>                          &amp;BytesWritten, <br>                          NULL); <br> <br>                // Flush debug output to file <br>                FlushFileBuffers( TraceFile ); <br> <br>                //reset the repeat count <br>                RepeatCount =0; <br>            } //if <br>} <br> <br>if( iTraceDestination == TRACE_TO_AUX) <br>{ <br>if(RepeatCount &gt; 0) <br>{ <br>wsprintf(g_PreviousMessage, <br> "Last Message Repeated &lt; %d &gt; times\n", <br> RepeatCount); <br>OutputDebugString(g_PreviousMessage); <br>RepeatCount = 0; <br>} <br>            // Send message to AUX device <br>OutputDebugString(g_CurrentMessage); <br>} <br>        // Store off this message <br>lstrcpy(g_PreviousMessage, g_CurrentMessage); <br>} <br>else <br>{ <br>RepeatCount++; <br>} <br>    LeaveCriticalSection( &amp;OutputRoutine ); <br>} <br> <br> <br> <br>  <br>BOOL <br>InitMemoryBuffers( <br>                  VOID <br>                  ) <br>/*++ <br>  Routine Description: <br> <br>  Initailizes the memory buffers used by this module. <br> <br>  Arguments: <br> <br>  NONE <br> <br>  Returns: <br> <br>  TRUE if all memory buffers are successfully created, Otherwise FALSE. <br> <br>  --*/ <br>{ <br>    BOOL ReturnCode=FALSE; <br> <br>    g_CurrentMessage = (LPSTR)malloc(TRACE_OUTPUT_BUFFER_SIZE); <br>    if (g_CurrentMessage) <br>    { <br>        g_PreviousMessage = (LPSTR)malloc(TRACE_OUTPUT_BUFFER_SIZE); <br>        if (g_PreviousMessage) <br>        { <br>            ReturnCode=TRUE; <br>        } //if <br>        else <br>        { <br>            free( g_CurrentMessage ); <br>        } //else <br>    } //if <br>    return(ReturnCode); <br>} <br> <br>#endif  // TRACING </code></pre>
<p>&nbsp;</p></body>
</HTML>
