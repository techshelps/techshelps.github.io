<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOVERLAP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5296"></a>DOVERLAP.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br> <br>Module Name: <br> <br>    doverlap.cpp <br> <br>Abstract: <br> <br>    This module defines the layered class dprovider along with its methods. <br> <br>--*/ <br> <br>#include "precomp.h" <br> <br>DOVERLAPPEDSTRUCTMGR::DOVERLAPPEDSTRUCTMGR() <br>/*++ <br> <br>Routine Description: <br> <br>    DOVERLAPPEDSTRUCTMGR  object  constructor.   Creates and returns a <br>    DOVERLAPPEDSTRUCTMGR object.  Note that  the  DOVERLAPPEDSTRUCTMGR object <br>    has not been fully initialized.  The "Initialize" member function must be <br>    the first member function called on the new DOVERLAPPEDSTRUCTMGR object. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br>--*/ <br>{ <br>    // Setup the free list <br>    m_overlapped_free_list.Next = NULL; <br>    m_overlapped_struct_block = NULL; <br>    InitializeCriticalSection(&amp;m_overlapped_free_list_lock); <br>} <br> <br> <br>INT <br>DOVERLAPPEDSTRUCTMGR::Initialize( <br>        ) <br>/*++ <br> <br>Routine Description: <br> <br>    The initialization routine for a DOVERLAPPEDSTRUCTMGR  object.  This <br>    procedure completes the initialzation of the object.  This procedure <br>    preforms initialization operations that may fail and must be reported since <br>    there is no way to fail the constructor. <br> <br>Arguments: <br> <br>    None <br>Return Value: <br> <br>    The  function returns NO_ERROR if successful.  Otherwise it <br>    returns an appropriate WinSock error code if the initialization <br>    cannot be completed. <br>--*/ <br>{ <br>    INT   ReturnCode; <br>    ULONG BlockSize; <br>    PBYTE CurrentBlock; <br>    ULONG BytesAvailable; <br>    ULONG StructSize; <br> <br> <br>    ReturnCode = WSAENOBUFS; <br> <br>    // <br>    // Initialize the pool of internal overlapped structs. <br>    // <br> <br>    // Get memory for our overlapped structs <br>    BlockSize = sizeof(INTERNALOVERLAPPEDSTRUCT) * <br>        OUTSTANDINGOVERLAPPEDSTRUCTS; <br>    m_overlapped_struct_block = (PBYTE) new BYTE[BlockSize]; <br> <br>    if (m_overlapped_struct_block){ <br> <br>        // Dice up the memory block into internal overlapped structs and add <br>        // them to the free list. <br>        EnterCriticalSection(&amp;m_overlapped_free_list_lock); <br> <br>        StructSize = sizeof(INTERNALOVERLAPPEDSTRUCT); <br> <br>        BytesAvailable = BlockSize; <br>        CurrentBlock   = m_overlapped_struct_block; <br> <br>        while (BytesAvailable &gt; StructSize){ <br>            PushEntryList(&amp;m_overlapped_free_list, <br>                          (PSINGLE_LIST_ENTRY) CurrentBlock); <br> <br>            BytesAvailable -= StructSize; <br>            CurrentBlock += StructSize; <br>        } //while <br>        ReturnCode = NO_ERROR; <br>        LeaveCriticalSection(&amp;m_overlapped_free_list_lock); <br>    } //if <br> <br>    return(ReturnCode); <br>} <br> <br> <br>DOVERLAPPEDSTRUCTMGR::~DOVERLAPPEDSTRUCTMGR() <br>/*++ <br> <br>Routine Description: <br> <br>    DOVERLAPPEDSTRUCTMGR object destructor.  This procedure has the <br>    responsibility to perform any required shutdown operations for the <br>    DOVERLAPPEDSTRUCTMGR object before the object memory is deallocated. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br>--*/ <br>{ <br>    // Clean up the overlapped struct pool <br>    EnterCriticalSection(&amp;m_overlapped_free_list_lock); <br>    delete(m_overlapped_struct_block); <br>    m_overlapped_free_list.Next = NULL; <br>    LeaveCriticalSection(&amp;m_overlapped_free_list_lock); <br>    DeleteCriticalSection(&amp;m_overlapped_free_list_lock); <br>} <br> <br> <br>PINTERNALOVERLAPPEDSTRUCT <br>DOVERLAPPEDSTRUCTMGR::AllocateOverlappedStruct( <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Allocates an interanl overlapped structure from the pool of available <br>    structures. <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    A pointer the a internal overlapped struct on success else NULL. <br> <br>--*/ <br>{ <br>    PINTERNALOVERLAPPEDSTRUCT ReturnValue; <br> <br>    ReturnValue = PopOverlappedStruct(); <br> <br>    if (ReturnValue){ <br>        ReturnValue-&gt;iolSignature = STRUCTSIGNATURE; <br>    } //if <br> <br>    return(ReturnValue); <br>} <br> <br> <br>VOID <br>DOVERLAPPEDSTRUCTMGR::FreeOverlappedStruct( <br>    LPWSAOVERLAPPED   OverlappedStruct <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Frees an interanl overlapped structure to the pool of available <br>    structures. <br>Arguments: <br> <br>    OverlappedStruct - A pointer to the InternalOverlappedStruct member of an <br>    interanl overlapped struct. <br> <br>Return Value: <br> <br>    NONE <br> <br>--*/ <br>{ <br>    PushOverlappedStruct(OverlappedStruct); <br>} <br> <br> <br> <br>PINTERNALOVERLAPPEDSTRUCT <br>DOVERLAPPEDSTRUCTMGR::PopOverlappedStruct() <br>/*++ <br> <br>Routine Description: <br> <br>    Pops a internal overlapped structure off of the free list and initializes <br>    the structure. <br> <br>Arguments: <br> <br>    NONE <br>Return Value: <br> <br>    A pointer to a internal overlapped structure on success else NULL <br> <br>--*/ <br>{ <br>    PINTERNALOVERLAPPEDSTRUCT ReturnValue; <br> <br>    EnterCriticalSection(&amp;m_overlapped_free_list_lock); <br> <br>    ReturnValue = <br>        (PINTERNALOVERLAPPEDSTRUCT)PopEntryList(&amp;m_overlapped_free_list); <br> <br>    LeaveCriticalSection(&amp;m_overlapped_free_list_lock); <br> <br>    if (ReturnValue){ <br> <br>        // Init the structure <br>        ZeroMemory( <br>            ReturnValue, <br>            sizeof(INTERNALOVERLAPPEDSTRUCT)); <br>        ReturnValue-&gt;iolSignature = STRUCTSIGNATURE; <br>    } //if <br> <br>    return(ReturnValue); <br>} <br> <br> <br>VOID <br>DOVERLAPPEDSTRUCTMGR::PushOverlappedStruct( <br>    LPWSAOVERLAPPED OverlappedStruct <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Pushes an internal overlapped structure onto the free list. <br> <br>Arguments: <br> <br>    A pointer to the InteranlOverlappedStruct member of an internal overlapped <br>    struct. <br>Return Value: <br> <br>    NONE <br>--*/ <br>{ <br>    PINTERNALOVERLAPPEDSTRUCT InternalOverlappedStruct; <br> <br> <br>    InternalOverlappedStruct = CONTAINING_RECORD ( <br>                            OverlappedStruct, <br>                            INTERNALOVERLAPPEDSTRUCT, <br>                            iolInternalOverlappedStruct); <br> <br>    assert(STRUCTSIGNATURE == InternalOverlappedStruct-&gt;iolSignature); <br> <br>    EnterCriticalSection(&amp;m_overlapped_free_list_lock); <br> <br> <br>    PushEntryList(&amp;m_overlapped_free_list, <br>                  (PSINGLE_LIST_ENTRY)InternalOverlappedStruct); <br> <br>    LeaveCriticalSection(&amp;m_overlapped_free_list_lock); <br> <br>} <br> <br> <br> <br> <br>PINTERNALOVERLAPPEDSTRUCT <br>DOVERLAPPEDSTRUCTMGR::GetInternalOverlappedStructure( <br>    IN  LPWSAOVERLAPPED                     pCompletedOverlappedStruct <br>    ) <br>{ <br>    PINTERNALOVERLAPPEDSTRUCT pOverlappedStruct; <br> <br> <br>    pOverlappedStruct = CONTAINING_RECORD ( <br>                            pCompletedOverlappedStruct, <br>                            INTERNALOVERLAPPEDSTRUCT, <br>                            iolInternalOverlappedStruct); <br> <br>    if (STRUCTSIGNATURE == pOverlappedStruct-&gt;iolSignature) <br>        return pOverlappedStruct; <br>else <br>return(NULL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
