<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBUFFMGR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5289"></a>DBUFFMGR.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br>Module Name: <br> <br>dbuffmgr.cpp <br> <br>Abstract: <br> <br>     This module defines and interface for a buffer manager for managing <br>     WSABUF's.  If a layered provider needs to modify application data The <br>     CopyBuffer() routine should be modifed to do so. <br> <br>--*/ <br> <br>#include "precomp.h" <br> <br> <br>  <br>DBUFFERMANAGER::DBUFFERMANAGER( <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    DBUFFERMANAGER  object  constructor.   Creates and returns a DBUFFERMANAGER <br>    object.  Note that  the  DBUFFERMANAGER object has not been fully <br>    initialized.  The "Initialize" member function must be the first member <br>    function called on the new DBUFFERMANAGER object. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br>--*/ <br>{ <br>    // Null function body.  A full implemantation would initialize member <br>    // varialbles to know values for use in Initailize(). <br>} <br> <br> <br> <br>  <br>INT <br>DBUFFERMANAGER::Initialize( <br>        ) <br>/*++ <br> <br>Routine Description: <br> <br>    The initialization routine for a buffer manager object.  This procedure <br>    completes the initialzation of the object.  This procedure preforms <br>    initialization operations that may fail and must be reported since there is <br>    no way to fail the constructor. <br> <br>Arguments: <br> <br>    None <br>Return Value: <br> <br>    The  function returns NO_ERROR if successful.  Otherwise it <br>    returns an appropriate WinSock error code if the initialization <br>    cannot be completed. <br>--*/ <br>{ <br>    return(NO_ERROR); <br>} <br> <br> <br>  <br>DBUFFERMANAGER::~DBUFFERMANAGER() <br>/*++ <br> <br>Routine Description: <br> <br>    DBUFFERMANAGER object destructor.  This procedure has the responsibility to <br>    perform any required shutdown operations for the DBUFFERMANAGER object <br>    before the object memory is deallocated. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br>--*/ <br>{ <br>    // Null function body <br>} <br> <br>INT <br>DBUFFERMANAGER::AllocBuffer( <br>    IN  LPWSABUF   UserBuffer, <br>    IN  DWORD      UserBufferCount, <br>    OUT LPWSABUF*  InternalBuffer, <br>    OUT DWORD*     InternalBufferCount <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine allocates a set of WSABUF's to pass to the underlying service <br>    provider. <br> <br>Arguments: <br> <br>    UserBuffer - A pointer to the array user WSABUFs <br>    UserBufferCount - The number of user WSABUF structs. <br>    InternalBuffer - A pointer to a pointer to a WSABUF <br>    InternalBufferCount - The pointer to a DWORD to revceive the number of <br>                          WSABUFs pointed to by InternalBuffer. <br> <br> <br>Return Value: <br> <br>    The  function returns NO_ERROR if successful.  Otherwise it <br>    returns an appropriate WinSock error code if the initialization <br>    cannot be completed. <br> <br>--*/ <br>{ <br>    // ****** <br>    // Note this procedure returns the user buffer(s) undistrubed.  This is the <br>    // wrong thing for providers that wish to modify the data stream.  The <br>    // proper buffer management policy is left to the provider developer. <br>    *InternalBuffer = UserBuffer; <br>    *InternalBufferCount = UserBufferCount; <br>    return(NO_ERROR); <br>} <br> <br> <br>VOID <br>DBUFFERMANAGER::FreeBuffer( <br>    IN LPWSABUF  InternalBuffer, <br>    IN DWORD     InternalBufferCount <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine frees a set of WSABUF's allocated by AllocBuffer(); <br> <br>Arguments: <br> <br>    InternalBuffer - A pointer to WSABUF array <br>    InternalBufferCount - The number of WSABUFs pointed to by InternalBuffer. <br> <br> <br>Return Value: <br> <br>    The  function returns NO_ERROR if successful.  Otherwise it <br>    returns an appropriate WinSock error code if the initialization <br>    cannot be completed. <br> <br>--*/ <br>{ <br>} <br> <br> <br>INT <br>DBUFFERMANAGER::CopyBuffer( <br>    IN  LPWSABUF   SourceBuffer, <br>    IN  DWORD      SourceBufferCount, <br>IN  DWORD   SourceOffset, <br>    INDWORD   BytesToCopy, <br>    IN  LPWSABUF   DestinationBuffer, <br>    IN  DWORD      DestinationBufferCount, <br>IN  DWORD   DestionationOffset <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine copies one set of WSABUFs to another. <br> <br>Arguments: <br> <br>    SourceBuffer - A pointer to an array of WSABUFs. <br> <br>    SourceBuferCount - The number of WSABUFs pointed to by SourceBuffer. <br> <br>SourceOffset  - offset to start copying from in source <br>BytesToCopy  - maximum number of bytest to copy <br>    DestinationBuffer - A pointer to an array of WSABUFs. <br> <br>    DestinationBufferCount - The number of WSABUFs pointed to by <br>                             DestinationBuffer . <br>DestinationOffset - offset to start writing to in destionation buffer <br> <br>Return Value: <br> <br>    The  function returns NO_ERROR if successful.  Otherwise it <br>    returns an appropriate WinSock error code if the initialization <br>    cannot be completed. <br> <br>--*/ <br>{ <br>    return(NO_ERROR); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
