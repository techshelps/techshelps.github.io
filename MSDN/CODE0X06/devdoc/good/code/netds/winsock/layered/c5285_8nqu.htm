<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DASYNCW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5286"></a>DASYNCW.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br> <br>Module Name: <br> <br> <br>Abstract: <br> <br> <br>--*/ <br> <br>#include "precomp.h" <br> <br>#define INVALID_ASYNC_WINDOW ((HWND)-1) <br>DWORD <br>AsyncThreadProc( <br>    DWORD  Context <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Thread procedure passed to CreatThread(). <br> <br>Arguments: <br> <br>    Context - Context value passed to CreateThread().  The context value is the <br>              async thread object. <br> <br>Return Value: <br> <br>    The Return value of the worker thread <br> <br>--*/ <br> <br>{ <br>    PDASYNCWINDOW             Thread; <br>    HINSTANCE                 HModule; <br>    MSG                       msg; <br> <br>    HModule = LoadLibraryA (gLibraryName); <br>    Thread = (PDASYNCWINDOW)Context; <br>    if (Thread-&gt;CreateAsyncWindow ()==NO_ERROR) { <br>while(GetMessage( &amp;msg, NULL, 0, 0 )== TRUE) { <br>TranslateMessage( &amp;msg ); <br>DispatchMessage( &amp;msg ); <br>} <br>} <br> <br>    DEBUGF( DBG_TRACE, <br>            ("Exiting async thread.\n")); <br>    FreeLibraryAndExitThread (HModule, 0); <br>    return 0;   // Keep compiler happy <br>} <br> <br>LRESULT <br>CALLBACK <br>AsyncWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    PDASYNCWINDOW    Thread = (PDASYNCWINDOW)GetWindowLong (hwnd, 0); <br>    if (Thread) { <br>        BOOL             ReturnCode; <br> <br>        ReturnCode = Thread-&gt;ProcessAsyncMessage (msg, (SOCKET)wParam, lParam); <br>        if (ReturnCode==TRUE) <br>            return 0; <br>        else if (ReturnCode == -1) <br>            delete Thread; <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br> <br> <br> <br>  <br>DASYNCWINDOW::DASYNCWINDOW() <br>/*++ <br>Routine Description: <br> <br>    Creates any internal state. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br> <br>--*/ <br> <br>{ <br>    m_async_thread = NULL; <br>    m_async_window = NULL; <br>m_exit_thread = FALSE; <br>} <br> <br> <br>  <br>DASYNCWINDOW::~DASYNCWINDOW() <br>/*++ <br>Routine Description: <br> <br>    destroys any internal state. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br> <br>--*/ <br>{ <br> <br>    DEBUGF( DBG_TRACE, <br>            ("Destroyed async thread object\n")); <br>} <br> <br> <br>  <br>INT <br>DASYNCWINDOW::Initialize( <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initializes the DASYNCWINDOW object. <br> <br>Arguments: <br> <br>    NONE <br> <br>Return Value: <br> <br>    If no error occurs, Initialize() returns NO_ERROR.  Otherwise the value <br>    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnCode; <br>    DWORD ThreadId; <br> <br>    DEBUGF( DBG_TRACE, <br>            ("Initializing async thread \n")); <br> <br> <br>    // <br>    // Create the worker thread and wait for the new thred to finish its <br>    // initialization. <br>    // <br>    m_async_thread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)::AsyncThreadProc, <br>        this, <br>        0, <br>        &amp;ThreadId); <br>    if (m_async_thread){ <br>while (m_async_window==NULL) <br>Sleep (0); <br>if (m_async_window!=INVALID_ASYNC_WINDOW) <br>ReturnCode = NO_ERROR; <br>else <br>ReturnCode = WSAENOBUFS; <br>    } <br>    else { <br>        ReturnCode = CreateAsyncWindow (); <br>    } <br> <br>    return ReturnCode; <br> <br>} //Initailize <br> <br>VOID <br>DASYNCWINDOW::Destroy( <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initiates destruction of the DASYNCWINDOW object. <br>    This can't be done syncronously in destructor because this <br>    will require waiting for thread object to exit which we wont <br>    to avoid. <br> <br>Arguments: <br> <br>    NONE <br> <br>Return Value: <br> <br>    NONE <br>--*/ <br>{ <br>        // Just destroy the window and it will quit the thread <br>        // if one exists <br>    if ((m_async_window!=NULL) &amp;&amp; (m_async_window!=INVALID_ASYNC_WINDOW)) { <br>m_exit_thread = TRUE; <br>        DestroyWindow (m_async_window); <br>} <br>} <br> <br> <br>DWORD <br>DASYNCWINDOW::CreateAsyncWindow ( <br>    ) <br>{ <br>    WNDCLASSA wndclass; <br> <br>    // <br>    // Register the window class if necessary. <br>    // <br> <br>    wndclass.style = CS_HREDRAW | CS_VREDRAW; <br>    wndclass.lpfnWndProc = (WNDPROC)AsyncWndProc; <br>    wndclass.cbClsExtra = 0; <br>    wndclass.cbWndExtra = sizeof(PDASYNCWINDOW); <br>    wndclass.hInstance = HDllInstance; <br>    wndclass.hIcon = LoadIcon( NULL, IDI_APPLICATION ); <br>    wndclass.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wndclass.hbrBackground = (HBRUSH)GetStockObject( WHITE_BRUSH ); <br>    wndclass.lpszMenuName = NULL; <br>    wndclass.lpszClassName = ASYNC_WINDOW_CLASS_NAME; <br> <br>    if( RegisterClass( &amp;wndclass ) == 0 ) { <br> <br>        return WSAENOBUFS; <br> <br>    } <br> <br> <br>    // <br>    // Create the window. <br>    // <br> <br>    m_async_window = CreateWindowA( <br>                                ASYNC_WINDOW_CLASS_NAME,    // lpszClassName <br>                                "",                         // lpszWindowName <br>                                WS_OVERLAPPEDWINDOW,        // dwStyle <br>                                CW_USEDEFAULT,              // x <br>                                CW_USEDEFAULT,              // y <br>                                CW_USEDEFAULT,              // nWidth <br>                                CW_USEDEFAULT,              // nHeight <br>                                NULL,                       // hwndParent <br>                                NULL,                       // hmenu <br>                                HDllInstance,               // hinst <br>                                NULL                        // lpvParam <br>                                ); <br> <br>    if( m_async_window != NULL ) { <br> <br>        // <br>        // Associate the async thread object with window. <br>        // <br>        SetWindowLong (m_async_window, 0, (DWORD)this); <br>        return NO_ERROR; <br> <br>    } <br>    else { <br>m_async_window = INVALID_ASYNC_WINDOW; <br>        return WSAENOBUFS; <br>} <br> <br>} <br> <br> <br>BOOL <br>DASYNCWINDOW::ProcessAsyncMessage ( <br>    UINT    msg, <br>    SOCKET  s, <br>    LPARAM  param <br>    ) { <br>    PDSOCKET    Socket; <br> <br>if (!m_exit_thread) { <br>switch( msg ) { <br>case WM_SELECT_MESSAGE: <br>Socket = DSOCKET::FindDSocketFromProviderSocket (s); <br>if (Socket) <br>Socket-&gt;SignalAsyncEvents (param); <br>return TRUE; <br> <br>case WM_DESTROY : <br> <br>if (m_async_thread) { <br>PostThreadMessage (NULL, WM_QUIT, 0, 0); <br>CloseHandle (m_async_thread); <br>m_async_thread = NULL; <br>DEBUGF (DBG_TRACE, ("Async thread received quit message.\n")); <br>} <br>return -1; <br>default: <br>return FALSE; <br>} <br>} <br>else { <br>if (m_async_thread) { <br>PostThreadMessage (NULL, WM_QUIT, 0, 0); <br>CloseHandle (m_async_thread); <br>m_async_thread = NULL; <br>DEBUGF (DBG_TRACE, ("Async thread exit flag set.\n")); <br>} <br>return -1; <br>} <br>} <br> <br>INT <br>DASYNCWINDOW::RegisterSocket( <br>    PDSOCKET Socket <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Register the socket with provider to receive messages for async window <br>    maintained by this async thread object <br>     <br>Arguments: <br> <br>    Socket - A pointer to a DSOCKET object for the socket that is registering. <br> <br>Return Value: <br> <br>    On success NO_ERROR else a valid winsock error code. <br> <br>--*/ <br>{ <br>    INT        ReturnCode; <br>    LONG       SocketEventMask; <br>    SOCKET     ProviderSocket; <br>    PDPROVIDER Provider; <br> <br>    // Get the info we need from the socket <br>    ProviderSocket    = Socket-&gt;GetProviderSocket(); <br>    SocketEventMask = Socket-&gt;GetAsyncEventMask(); <br>    Provider        = Socket-&gt;GetDProvider(); <br> <br>    //Add the socket to the wait array <br>    if (Provider-&gt;WSPAsyncSelect( <br>            ProviderSocket, <br>            m_async_window, <br>            WM_SELECT_MESSAGE, <br>            SocketEventMask, <br>            &amp;ReturnCode)==0) <br>        return NO_ERROR; <br>    else <br>        return ReturnCode; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
