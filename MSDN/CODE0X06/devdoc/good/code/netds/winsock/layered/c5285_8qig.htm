<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INST_LSP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5308"></a>INST_LSP.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br> <br>Module Name: <br> <br>    inst_lsp.cpp <br> <br>Abstract: <br> <br>    This module contains the installation routines for the winsock2 layered <br>    service provider sample. <br> <br>--*/ <br> <br>#define WIN32_LEAN_AND_MEAN <br> <br>#include "warnoff.h" <br>#include &lt;windows.h&gt; <br> <br>#include "ws2spi.h" <br>#include &lt;rpc.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "sporder.h" <br>#include "install.h" <br>#define LAYERED_PROVIDER_NAME L"LAYERED_PROVIDER" <br> <br>VOID <br>UninstallMyProvider() <br>{ <br>    INT Errno; <br> <br>    WSCDeinstallProvider( <br>        &amp;LayeredProviderGuid, <br>        &amp;Errno); <br>} <br> <br>INT <br>InstallMyProvider( <br>    PDWORD CatalogId <br>    ) <br>/*++ <br>--*/ <br>{ <br>    WSAPROTOCOL_INFOW  proto_info; <br>    int               install_result; <br>    int               install_error; <br> <br>    // Create a PROTOCOL_INFO to install for our provider DLL. <br>    proto_info.dwServiceFlags1 = 0; <br>    proto_info.dwServiceFlags2 = 0; <br>    proto_info.dwServiceFlags3 = 0; <br>    proto_info.dwServiceFlags4 = 0; <br>    proto_info.dwProviderFlags = PFL_HIDDEN; <br>    proto_info.ProviderId      = LayeredProviderGuid; <br>    proto_info.dwCatalogEntryId = 0;   // filled in by system <br>    proto_info.ProtocolChain.ChainLen = LAYERED_PROTOCOL; <br>        // Do  not  need  to  fill  in  chain  for LAYERED_PROTOCOL or <br>        // BASE_PROTOCOL <br>    proto_info.iVersion = 0; <br>    proto_info.iAddressFamily = AF_INET; <br>    proto_info.iMaxSockAddr = 16; <br>    proto_info.iMinSockAddr = 16; <br>    proto_info.iSocketType = SOCK_STREAM; <br>    proto_info.iProtocol = IPPROTO_TCP;   // mimic TCP/IP <br>    proto_info.iProtocolMaxOffset = 0; <br>    proto_info.iNetworkByteOrder = BIGENDIAN; <br>    proto_info.iSecurityScheme = SECURITY_PROTOCOL_NONE; <br>    proto_info.dwMessageSize = 0;  // stream-oriented <br>    proto_info.dwProviderReserved = 0; <br>    wcscpy( <br>        proto_info.szProtocol, <br>        LAYERED_PROVIDER_NAME); <br> <br>    install_result = WSCInstallProvider( <br>        &amp;LayeredProviderGuid, <br>        L"lsp.dll",                   // lpszProviderDllPath <br>        &amp; proto_info,                 // lpProtocolInfoList <br>        1,                            // dwNumberOfEntries <br>        &amp; install_error);             // lpErrno <br>    *CatalogId = proto_info.dwCatalogEntryId; <br> <br>    return(install_result); <br> <br>} // Install_My_Layer <br> <br>INT <br>InstallNewChain( <br>    LPWSAPROTOCOL_INFOW BaseProtocolInfoBuff, <br>    DWORD               LayeredProviderCatalogId, <br>    HKEY                ConfigRegisteryKey <br>    ) <br>{ <br>    WSAPROTOCOL_INFOW ProtocolChainProtoInfo; <br>    WCHAR             DebugPrefix[] = L"LAYERED "; <br>    INT               ReturnCode; <br>    INT               Errno; <br>    UUID              NewChainId; <br>    RPC_STATUS        Status; <br>    PUCHAR            GuidString; <br>    HKEY              NewKey; <br>    DWORD             KeyDisposition; <br>    BOOL              Continue; <br> <br>    ReturnCode = NO_ERROR; <br> <br>    // We are only layering on top of base providers <br> <br>    if (BaseProtocolInfoBuff-&gt;ProtocolChain.ChainLen == BASE_PROTOCOL){ <br>        Continue = FALSE; <br> <br>        // Get a new GUID for the protocol chain we are about to install <br>        Status = UuidCreate( <br>            &amp;NewChainId); <br>        if (RPC_S_OK == Status){ <br> <br>            //Get the string representaion of the GUID <br>            Status = UuidToString( <br>                &amp;NewChainId, <br>                &amp;GuidString); <br>            if (RPC_S_OK == Status){ <br>                // Write down the GUID  in the registry so we know who to <br>                // uninstall <br>                RegCreateKeyEx( <br>                    ConfigRegisteryKey,                 // hkey <br>                    (LPCSTR)GuidString,                 // lpszSubKey <br>                    0,                                  // dwReserved <br>                    NULL,                               // lpszClass <br>                    REG_OPTION_NON_VOLATILE,            // fdwOptions <br>                    KEY_ALL_ACCESS,                     // samDesired <br>                    NULL,                               // lpSecurityAttributes <br>                    &amp; NewKey,                           // phkResult <br>                    &amp; KeyDisposition                    // lpdwDisposition <br>                    ); <br>                RpcStringFree(&amp;GuidString); <br> <br>                Continue =TRUE; <br>            } //if <br>            else{ <br>                printf("UuidToString() Failed\n"); <br>            } //else <br>        } //if <br>        else{ <br>            printf("UuidCreate Failed\n"); <br>        } //else <br> <br>        if (Continue){ <br> <br>            ProtocolChainProtoInfo = *BaseProtocolInfoBuff; <br> <br>            ProtocolChainProtoInfo.ProviderId = NewChainId; <br> <br>            wcscpy( <br>                ProtocolChainProtoInfo.szProtocol, <br>                DebugPrefix); <br>            wcscat( <br>                ProtocolChainProtoInfo.szProtocol, <br>                BaseProtocolInfoBuff-&gt;szProtocol); <br> <br>            ProtocolChainProtoInfo.ProtocolChain.ChainLen = 2; <br>            ProtocolChainProtoInfo.ProtocolChain.ChainEntries[0] = <br>                LayeredProviderCatalogId; <br>            ProtocolChainProtoInfo.ProtocolChain.ChainEntries[1] = <br>                BaseProtocolInfoBuff-&gt;dwCatalogEntryId; <br> <br>            ReturnCode = WSCInstallProvider( <br>                &amp;NewChainId, <br>                L"lsp.dll", <br>                &amp;ProtocolChainProtoInfo, <br>                1, <br>                &amp;Errno); <br>            if (ReturnCode==0) <br>                printf ("Installed over %ls.\n", <br>                     BaseProtocolInfoBuff-&gt;szProtocol); <br>            else <br>                printf ("Installation over %ls failed with error %ld.\n", <br>                     BaseProtocolInfoBuff-&gt;szProtocol, Errno); <br>        } //if <br>    } //if <br>    return(ReturnCode); <br>} <br> <br>int <br>main( int argc, char** argv) <br>{ <br>    LPWSAPROTOCOL_INFOW   ProtocolInfoBuff = NULL; <br>    DWORD                ProtocolInfoBuffSize = 0; <br>    INT                  ErrorCode; <br>    INT                  EnumResult; <br>    LONG                 lresult; <br>    HKEY                 NewKey; <br>    DWORD                KeyDisposition; <br>    GUID                 ProviderID; <br>    INT                  Index; <br>    DWORD                CatalogEntryId; <br>    CHAR                 GuidStringBuffer[40]; <br>    DWORD                GuidStringBufferLen; <br>    FILETIME             FileTime; <br>    BOOL                 EntryIdFound; <br>DWORD *CatIdBuff; <br>DWORD nCatIds; <br> <br>    // See if we are installing or deinstalling <br>    lresult = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE,                     // hkey <br>        CONFIGURATION_KEY,                      // lpszSubKey <br>        0,                                      // dwReserved <br>        KEY_ALL_ACCESS,                        // samDesired <br>        &amp; NewKey                               // phkResult <br>        ); <br> <br>    if (ERROR_SUCCESS == lresult){ <br>        // The layered provider is installed so we are going uninstall. <br> <br>        // <br>        // Enumerate all the provider IDs we stored on install and deinstall <br>        // the providers <br>        // <br>        printf("Removing Installed Layered Providers\n"); <br> <br>        Index = 0; <br>        GuidStringBufferLen = sizeof(GuidStringBuffer); <br>        lresult = RegEnumKeyEx( <br>            NewKey,               //hKey <br>            Index,                // Index of subkey <br>            &amp;GuidStringBuffer[0],    // Buffer to hold key name <br>            &amp;GuidStringBufferLen,  // Length of buffer <br>            NULL,                 // Reserved <br>            NULL,                 // Class buffer <br>            NULL,                 // Class buffer length <br>            &amp;FileTime              // Last write time <br>            ); <br> <br>        printf("Removing layered provider protocol chains\n"); <br>        while (lresult != ERROR_NO_MORE_ITEMS){ <br>            UuidFromString( <br>                (PUCHAR) GuidStringBuffer, <br>                &amp;ProviderID); <br>            // Deinstall the provider chain we installed <br>            WSCDeinstallProvider( <br>                &amp;ProviderID, <br>                &amp;ErrorCode); <br>            // Delete our registry key <br>            RegDeleteKey( <br>                NewKey, <br>                &amp;GuidStringBuffer[0]); <br> <br>            GuidStringBufferLen = sizeof(GuidStringBuffer); <br>        lresult = RegEnumKeyEx( <br>            NewKey,               //hKey <br>            Index,                // Index of subkey <br>            &amp;GuidStringBuffer[0],    // Buffer to hold key name <br>            &amp;GuidStringBufferLen,  // Length of buffer <br>            NULL,                 // Reserved <br>            NULL,                 // Class buffer <br>            NULL,                 // Class buffer length <br>            &amp;FileTime              // Last write time <br>            ); <br> <br>        } //while <br> <br>        // Clen up the registry <br>        RegCloseKey( <br>            NewKey); <br>        RegDeleteKey( <br>            HKEY_LOCAL_MACHINE, <br>            CONFIGURATION_KEY); <br> <br>        // Uninstall the real provider <br>        UninstallMyProvider(); <br>    } //if <br>    else{ <br> <br>        RegCreateKeyEx( <br>            HKEY_LOCAL_MACHINE,                 // hkey <br>            CONFIGURATION_KEY,                  // lpszSubKey <br>            0,                                  // dwReserved <br>            NULL,                               // lpszClass <br>            REG_OPTION_NON_VOLATILE,            // fdwOptions <br>            KEY_ALL_ACCESS,                     // samDesired <br>            NULL,                               // lpSecurityAttributes <br>            &amp; NewKey,                           // phkResult <br>            &amp; KeyDisposition                    // lpdwDisposition <br>            ); <br>        // Install a dummy PROTOCOL_INFO for the layered provider. <br>        lresult = InstallMyProvider( <br>            &amp;CatalogEntryId); <br>        if (NO_ERROR == lresult){ <br>            // <br>            // Enumerate the installed providers and chains <br>            // <br>            printf("Scanning Installed Providers\n"); <br>            // Call WSCEnumProtocols with a zero length buffer so we know what <br>            // size to  send in to get all the installed PROTOCOL_INFO <br>            // structs. <br>            WSCEnumProtocols( <br>                NULL,                     // lpiProtocols <br>                ProtocolInfoBuff,         // lpProtocolBuffer <br>                &amp; ProtocolInfoBuffSize,   // lpdwBufferLength <br>                &amp; ErrorCode);             // lpErrno <br> <br>            ProtocolInfoBuff = (LPWSAPROTOCOL_INFOW) <br>                malloc(ProtocolInfoBuffSize); <br>            if (ProtocolInfoBuff){ <br>                printf("Installing Layered Providers\n"); <br> <br>                EnumResult = WSCEnumProtocols( <br>                    NULL,                     // lpiProtocols <br>                    ProtocolInfoBuff,         // lpProtocolBuffer <br>                    &amp; ProtocolInfoBuffSize,   // lpdwBufferLength <br>                    &amp; ErrorCode); <br> <br>                if (SOCKET_ERROR != EnumResult){ <br> <br>                    // Find our provider entry to get our catalog entry ID <br>                    EntryIdFound = FALSE; <br>                    for (Index =0; Index &lt; EnumResult; Index++){ <br>                        if (memcmp (&amp;ProtocolInfoBuff[Index].ProviderId, <br>                                &amp;LayeredProviderGuid, <br>                                sizeof (LayeredProviderGuid))==0){ <br> <br>                            CatalogEntryId = <br>                                ProtocolInfoBuff[Index].dwCatalogEntryId; <br>                            EntryIdFound = TRUE; <br>                        } //if <br>                    } //for <br>                    if (EntryIdFound){ <br>                        for (Index =0; Index &lt; EnumResult; Index++){ <br>                            InstallNewChain( <br>                                &amp;ProtocolInfoBuff[Index], <br>                                CatalogEntryId, <br>                                NewKey); <br>                        } //for <br>free (ProtocolInfoBuff); <br> <br>// <br>// Enumerate the installed providers and chains <br>// <br>printf("Preparing To Reoder Installed Chains\n"); <br>// Call WSCEnumProtocols with a zero length buffer so we know what <br>// size to  send in to get all the installed PROTOCOL_INFO <br>// structs. <br>ProtocolInfoBuffSize = 0; <br>WSCEnumProtocols( <br>NULL,                     // lpiProtocols <br>NULL,  // lpProtocolBuffer <br>&amp; ProtocolInfoBuffSize,   // lpdwBufferLength <br>&amp; ErrorCode);             // lpErrno <br> <br>ProtocolInfoBuff = (LPWSAPROTOCOL_INFOW) <br>malloc(ProtocolInfoBuffSize); <br>if (ProtocolInfoBuff){ <br>printf("Reodering Installed Chains\n"); <br> <br>EnumResult = WSCEnumProtocols( <br>NULL,                     // lpiProtocols <br>ProtocolInfoBuff,         // lpProtocolBuffer <br>&amp; ProtocolInfoBuffSize,   // lpdwBufferLength <br>&amp; ErrorCode); <br> <br>if (SOCKET_ERROR != EnumResult){ <br>// Allocate buffer to hold catalog ID array <br>CatIdBuff = (DWORD *) <br>malloc (sizeof (DWORD)*EnumResult); <br>if (CatIdBuff!=NULL) { <br>// Put our catalog chains first <br>nCatIds = 0; <br>for (Index =0; Index &lt; EnumResult; Index++){ <br>if ((ProtocolInfoBuff[Index].ProtocolChain.ChainLen&gt;1) <br>&amp;&amp; (ProtocolInfoBuff[Index].ProtocolChain.ChainEntries[0]==CatalogEntryId)) <br>CatIdBuff[nCatIds++] = ProtocolInfoBuff[Index].dwCatalogEntryId; <br>} <br> <br>// Put the rest next <br>for (Index =0; Index &lt; EnumResult; Index++){ <br>if ((ProtocolInfoBuff[Index].ProtocolChain.ChainLen&lt;=1) <br>|| (ProtocolInfoBuff[Index].ProtocolChain.ChainEntries[0]!=CatalogEntryId)) <br>CatIdBuff[nCatIds++] = ProtocolInfoBuff[Index].dwCatalogEntryId; <br>} <br>// Save new protocol order <br>printf ("Saving New Protocol Order\n"); <br>ErrorCode = WSCWriteProviderOrder (CatIdBuff, nCatIds); <br>if (ErrorCode!=NO_ERROR) <br>printf ("Reodering failed with error %ld", ErrorCode); <br>} <br>} <br>} <br>                    } //if <br>                } //if <br>            } //if <br>        } //if <br>    } //else <br>    return(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
