<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DPROVIDE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5299"></a>DPROVIDE.H</h2>
<pre><code>/*++ <br> <br> <br>     Copyright c 1996 Intel Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br> <br>Module Name: <br> <br>        dprovide.h <br> <br>Abstract: <br> <br>        This module defines the layered service provider class dprovider along <br>        with its methods. <br> <br>--*/ <br>#ifndef _DPROVIDER_ <br>#define _DPROVIDER_ <br> <br> <br>#include &lt;winsock2.h&gt; <br>#include &lt;ws2spi.h&gt; <br>#include &lt;mswsock.h&gt; <br>#include "llist.h" <br>#include "dthook.h" <br> <br> <br>BOOL <br>PASCAL FAR <br>WSPTransmitFile ( <br>IN SOCKET hSocket, <br>IN HANDLE hFile, <br>IN DWORD nNumberOfBytesToWrite, <br>IN DWORD nNumberOfBytesPerSend, <br>IN LPOVERLAPPED lpOverlapped, <br>IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, <br>IN DWORD dwReserved <br>); <br> <br>BOOL <br>PASCAL FAR <br>WSPAcceptEx ( <br>IN SOCKET sListenSocket, <br>IN SOCKET sAcceptSocket, <br>IN PVOID lpOutputBuffer, <br>IN DWORD dwReceiveDataLength, <br>IN DWORD dwLocalAddressLength, <br>IN DWORD dwRemoteAddressLength, <br>OUT LPDWORD lpdwBytesReceived, <br>IN LPOVERLAPPED lpOverlapped <br>); <br> <br> <br> <br>class DPROVIDER { <br> <br>  public: <br> <br>    DPROVIDER(); <br> <br>    ~DPROVIDER(); <br> <br>    INT <br>    Initialize( <br>        IN PWCHAR lpszLibFile, <br>        IN LPWSAPROTOCOL_INFOW lpProtocolInfo); <br> <br>    SOCKET <br>    WSPAccept( <br>        IN SOCKET s, <br>        OUT struct sockaddr FAR *addr, <br>        OUT INT FAR *addrlen, <br>        IN LPCONDITIONPROC lpfnCondition, <br>        IN DWORD dwCallbackData, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPAddressToString( <br>        IN     LPSOCKADDR lpsaAddress, <br>        IN     DWORD dwAddressLength, <br>        IN     LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>        OUT    LPWSTR lpszAddressString, <br>        IN OUT LPDWORD lpdwAddressStringLength, <br>        OUT    LPINT lpErrno ); <br> <br>    INT <br>    WSPAsyncSelect( <br>        IN SOCKET s, <br>        IN HWND hWnd, <br>        IN unsigned int wMsg, <br>        IN long lEvent, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPBind( <br>        IN SOCKET s, <br>        IN const struct sockaddr FAR *name, <br>        IN INT namelen, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPCancelBlockingCall( <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPCleanup( <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPCloseSocket( <br>        IN SOCKET s, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPConnect( <br>        IN SOCKET s, <br>        IN const struct sockaddr FAR *name, <br>        IN INT namelen, <br>        IN LPWSABUF lpCallerData, <br>        IN LPWSABUF lpCalleeData, <br>        IN LPQOS lpSQOS, <br>        IN LPQOS lpGQOS, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPDuplicateSocket( <br>        IN SOCKET s, <br>        IN DWORD dwProcessID, <br>        IN LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPEnumNetworkEvents( <br>        IN SOCKET s, <br>        OUT WSAEVENT hEventObject, <br>        OUT LPWSANETWORKEVENTS lpNetworkEvents, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPEventSelect( <br>        IN SOCKET s, <br>        IN OUT WSAEVENT hEventObject, <br>        IN long lNetworkEvents, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPGetOverlappedResult( <br>        IN SOCKET s, <br>        IN LPWSAOVERLAPPED lpOverlapped, <br>        IN LPDWORD lpcbTransfer, <br>        IN BOOL fWait, <br>        OUT LPDWORD lpdwFlags, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPGetPeerName( <br>        IN SOCKET s, <br>        OUT struct sockaddr FAR *name, <br>        OUT INT FAR *namelen, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPGetQOSByName( <br>        IN SOCKET s, <br>        IN LPWSABUF lpQOSName, <br>        IN LPQOS lpQOS, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPGetSockName( <br>        IN SOCKET s, <br>        OUT struct sockaddr FAR *name, <br>        OUT INT FAR *namelen, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPGetSockOpt( <br>        IN SOCKET s, <br>        IN INT level, <br>        IN INT optname, <br>        OUT char FAR *optval, <br>        OUT INT FAR *optlen, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPIoctl( <br>        IN SOCKET s, <br>        IN DWORD dwIoControlCode, <br>        IN LPVOID lpvInBuffer, <br>        IN DWORD cbInBuffer, <br>        IN LPVOID lpvOutBuffer, <br>        IN DWORD cbOutBuffer, <br>        IN LPDWORD lpcbBytesReturned, <br>        IN LPWSAOVERLAPPED lpOverlapped, <br>        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>        IN LPWSATHREADID lpThreadId, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPJoinLeaf( <br>        IN SOCKET s, <br>        IN const struct sockaddr FAR *name, <br>        IN INT namelen, <br>        IN LPWSABUF lpCallerData, <br>        IN LPWSABUF lpCalleeData, <br>        IN LPQOS lpSQOS, <br>        IN LPQOS lpGQOS, <br>        IN DWORD dwFlags, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPListen( <br>        IN SOCKET s, <br>        IN INT backlog, <br>        OUT INT FAR *lpErrno); <br> <br> <br>    INT <br>    WSPRecv( <br>        IN SOCKET s, <br>        IN LPWSABUF lpBuffers, <br>        IN DWORD dwBufferCount, <br>        IN LPDWORD lpNumberOfBytesRecvd, <br>        IN OUT LPDWORD lpFlags, <br>        IN LPWSAOVERLAPPED lpOverlapped, <br>        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>        IN LPWSATHREADID lpThreadId, <br>        OUT INT FAR *lpErrno); <br> <br> <br>    INT <br>    WSPRecvDisconnect( <br>        IN SOCKET s, <br>        IN LPWSABUF lpInboundDisconnectData, <br>        OUT INT FAR *lpErrno); <br> <br> <br>    INT <br>    WSPRecvFrom( <br>        IN SOCKET s, <br>        IN LPWSABUF lpBuffers, <br>        IN DWORD dwBufferCount, <br>        IN LPDWORD lpNumberOfBytesRecvd, <br>        IN OUT LPDWORD lpFlags, <br>        OUT  struct sockaddr FAR *  lpFrom, <br>        IN LPINT lpFromlen, <br>        IN LPWSAOVERLAPPED lpOverlapped, <br>        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>        IN LPWSATHREADID lpThreadId, <br>        OUT INT FAR *lpErrno); <br> <br> <br>    INT <br>    WSPSelect( <br>        IN INT nfds, <br>        IN OUT fd_set FAR *readfds, <br>        IN OUT fd_set FAR *writefds, <br>        IN OUT fd_set FAR *exceptfds, <br>        IN const struct timeval FAR *timeout, <br>        OUT INT FAR *lpErrno); <br> <br> <br>    INT <br>    WSPSend( <br>        IN SOCKET s, <br>        IN LPWSABUF lpBuffers, <br>        IN DWORD dwBufferCount, <br>        OUT LPDWORD lpNumberOfBytesSent, <br>        IN DWORD dwFlags, <br>        IN LPWSAOVERLAPPED lpOverlapped, <br>        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>        IN LPWSATHREADID lpThreadId, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPSendDisconnect( <br>        IN SOCKET s, <br>        IN LPWSABUF lpOutboundDisconnectData, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPSendTo( <br>        IN SOCKET s, <br>        IN LPWSABUF lpBuffers, <br>        IN DWORD dbBufferCount, <br>        IN LPDWORD lpNumberOfBytesSent, <br>        IN DWORD dwFlags, <br>        IN const struct sockaddr FAR * lpTo, <br>        IN INT iTolen, <br>        IN LPWSAOVERLAPPED lpOverlapped, <br>        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>        IN LPWSATHREADID lpThreadId, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPSetSockOpt( <br>        IN SOCKET s, <br>        IN INT level, <br>        IN INT optname, <br>        IN const char FAR *optval, <br>        IN INT optlen, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPShutdown( <br>        IN SOCKET s, <br>        IN INT how, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPSocket( <br>        IN int af, <br>        IN int type, <br>        IN int protocol, <br>        IN LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>        IN GROUP g, <br>        IN DWORD dwFlags, <br>        OUT INT FAR *lpErrno); <br> <br>    INT <br>    WSPStringToAddress( <br>        IN     LPWSTR AddressString, <br>        IN     INT AddressFamily, <br>        IN     LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>        OUT    LPSOCKADDR lpAddress, <br>        IN OUT LPINT lpAddressLength, <br>        IN OUT LPINT lpErrno ); <br> <br>INT <br>TransmitFile ( <br>IN SOCKET hSocket, <br>IN HANDLE hFile, <br>IN DWORD nNumberOfBytesToWrite, <br>IN DWORD nNumberOfBytesPerSend, <br>IN LPOVERLAPPED lpOverlapped, <br>IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, <br>IN DWORD dwReserved, <br>OUT LPINT lpErrno <br>); <br> <br>INT <br>AcceptEx ( <br>IN SOCKET sListenSocket, <br>IN SOCKET sAcceptSocket, <br>IN PVOID lpOutputBuffer, <br>IN DWORD dwReceiveDataLength, <br>IN DWORD dwLocalAddressLength, <br>IN DWORD dwRemoteAddressLength, <br>OUT LPDWORD lpdwBytesReceived, <br>IN LPOVERLAPPED lpOverlapped, <br>OUT LPINT lpErrno <br>); <br> <br>INT <br>InterceptExtensions ( <br>IN LPVOIDlpvInBuffer, <br>OUT LPVOIDlpvOutBuffer, <br>OUT LPINTlpErrno <br>); <br> <br>  private: <br>// Variables <br>    LPWSPPROC_TABLE  m_proctable; <br>BOOL  m_extensions_initialized; <br>LPFN_TRANSMITFILE m_transmitfile; <br>LPFN_ACCEPTEX  m_acceptex; <br>    HINSTANCE         m_library_handle; <br>    LPSTR            m_lib_name; <br>}; <br> <br> <br> <br>inline SOCKET <br>DPROVIDER::WSPAccept( <br>    IN SOCKET s, <br>    OUT struct sockaddr FAR *addr, <br>    OUT INT FAR *addrlen, <br>    IN LPCONDITIONPROC lpfnCondition, <br>    IN DWORD dwCallbackData, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Conditionally  accept a connection based on the return value of a condition <br>    function, and optionally create and/or join a socket group. <br> <br>Arguments: <br> <br>    s              - A  descriptor  identiying  a socket which is listening for <br>                     connections after a WSPListen(). <br> <br>    addr           - An optional pointer to a buffer which receives the address <br>                     of   the  connecting  entity,  as  known  to  the  service <br>                     provider.   The  exact  format  of  the  addr arguement is <br>                     determined  by  the  address  family  established when the <br>                     socket was created. <br> <br>    addrlen        - An  optional  pointer  to  an  integer  which contains the <br>                     length of the address addr. <br> <br>    lpfnCondition  - The  procedure  instance address of an optional, WinSock 2 <br>                     client  supplied  condition  function  which  will make an <br>                     accept/reject  decision  based  on  the caller information <br>                     passed  in  as  parameters,  and optionally creaetd and/or <br>                     join  a  socket group by assigning an appropriate value to <br>                     the result parameter of this function. <br> <br>    dwCallbackData - Callback data to be passed back to the WinSock 2 client as <br>                     a  condition  function  parameter.   This parameter is not <br>                     interpreted by the service provider. <br> <br>    lpErrno        - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPAccept() returns a value of type SOCKET which is a <br>    descriptor  for  the accepted socket.  Otherwise, a value of INVALID_SOCKET <br>    is returned, and a specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    SOCKET ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPAccept, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;addr, <br>                       &amp;addrlen, <br>                       &amp;lpfnCondition, <br>                       &amp;dwCallbackData, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPAccept( <br>        s, <br>        addr, <br>        addrlen, <br>        lpfnCondition, <br>        dwCallbackData, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPAccept, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;addr, <br>                    &amp;addrlen, <br>                    &amp;lpfnCondition, <br>                    &amp;dwCallbackData, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPAddressToString( <br>    IN     LPSOCKADDR lpsaAddress, <br>    IN     DWORD dwAddressLength, <br>    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    OUT    LPWSTR lpszAddressString, <br>    IN OUT LPDWORD lpdwAddressStringLength, <br>    OUT    LPINT lpErrno ) <br>/*++ <br> <br>Routine Description: <br> <br>    WSPAddressToString() converts a SOCKADDR structure into a human-readable <br>    string representation of the address.  This is intended to be used mainly <br>    for display purposes. If the caller wishes the translation to be done by a <br>    particular provider, it should supply the corresponding WSAPROTOCOL_INFO <br>    struct in the lpProtocolInfo parameter. <br> <br>Arguments: <br> <br>    lpsaAddress - points to a SOCKADDR structure to translate into a string. <br> <br>    dwAddressLength - the length of the Address SOCKADDR. <br> <br>    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular <br>                     provider. <br> <br>    lpszAddressString - a buffer which receives the human-readable address <br>                        string. <br> <br>    lpdwAddressStringLength - on input, the length of the AddressString buffer. <br>                              On output, returns the length of  the string <br>                              actually copied into the buffer. <br> <br>Return Value: <br> <br>    The return value is 0 if the operation was successful.  Otherwise the value <br>    SOCKET_ERROR is returned <br>--*/ <br>{ <br>     INT ReturnValue; <br> <br>//      if (PREAPINOTIFY(( DTCODE_WSPAddressToString, <br>//                         &amp;ReturnValue, <br>//                         m_lib_name, <br>//                         &amp;lpsaAddress, <br>//                         &amp;dwAddressLength, <br>//                         &amp;lpProtocolInfo, <br>//                         &amp;lpszAddressString, <br>//                         &amp;lpdwAddressStringLength, <br>//                         &amp;lpErrno)) ) { <br>//          return(ReturnValue); <br>//      } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPAddressToString( <br>        lpsaAddress, <br>        dwAddressLength, <br>        lpProtocolInfo, <br>        lpszAddressString, <br>        lpdwAddressStringLength, <br>        lpErrno); <br> <br> <br>//      POSTAPINOTIFY(DTCODE_WSPAddressToString, <br>//                    &amp;ReturnValue, <br>//                    m_lib_name, <br>//                    &amp;lpsaAddress, <br>//                    &amp;dwAddressLength, <br>//                    &amp;lpProtocolInfo, <br>//                    &amp;lpszAddressString, <br>//                    &amp;lpdwAddressStringLength, <br>//                    &amp;lpErrno))); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPAsyncSelect( <br>    IN SOCKET s, <br>    IN HWND hWnd, <br>    IN unsigned int wMsg, <br>    IN long lEvent, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Request  Windows  message-based  event notification of network events for a <br>    socket. <br> <br>Arguments: <br> <br>    s       - A  descriptor identiying a socket for which event notification is <br>              required. <br> <br>    hWnd    - A  handle  identifying  the window which should receive a message <br>              when a network event occurs. <br> <br>    wMsg    - The message to be sent when a network event occurs. <br> <br>    lEvent  - bitmask  which specifies a combination of network events in which <br>              the WinSock client is interested. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  return  value  is 0 if the WinSock client's declaration of interest in <br>    the  netowrk event set was successful.  Otherwise the value SOCKET_ERROR is <br>    returned, and a specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPAsyncSelect, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;hWnd, <br>                       &amp;wMsg, <br>                       &amp;lEvent, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPAsyncSelect( <br>        s, <br>        hWnd, <br>        wMsg, <br>        lEvent, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPAsyncSelect, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;hWnd, <br>                    &amp;wMsg, <br>                    &amp;lEvent, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPBind( <br>    IN SOCKET s, <br>    IN const struct sockaddr FAR *name, <br>    IN INT namelen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Associate a local address (i.e. name) with a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying an unbound socket. <br> <br>    name    - The  address  to assign to the socket.  The sockaddr structure is <br>              defined as follows: <br> <br>              struct sockaddr { <br>                  u_short sa_family; <br>                  char    sa_data[14]; <br>              }; <br> <br>              Except  for  the sa_family field, <br>sockaddr contents are epxressed <br>              in network byte order. <br> <br>    namelen - The length of the name. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If   no   erro   occurs,  WSPBind()  returns  0.   Otherwise, it  returns <br>    SOCKET_ERROR, and a specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    if (PREAPINOTIFY(( DTCODE_WSPBind, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpErrno)) ) { <br> <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPBind( <br>        s, <br>        name, <br>        namelen, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPBind, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPCancelBlockingCall(OUT INT FAR *lpErrno) <br>/*++ <br>Routine Description: <br> <br>    Cancel a blocking call which is currently in progress. <br> <br>Arguments: <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  value  returned  by  WSPCancelBlockingCall() is 0 if the operation was <br>    successfully canceled.  Otherwise the value SOCKET_ERROR is returned, <br>and a <br>    specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPCancelBlockingCall, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPCancelBlockingCall( <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPCancelBlockingCall, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPCleanup( <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Terminate use of the WinSock service provider. <br> <br>Arguments: <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  return  value  is  0 if the operation has been successfully initiated. <br>    Otherwise  the  value SOCKET_ERROR is returned, <br>and a specific error number <br>    is available in lpErrno. <br> <br>--*/ <br> <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPCleanup, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPCleanup( <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPCleanup, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPCloseSocket( <br>    IN SOCKET s, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Close a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  erro  occurs, WSPCloseSocket()  returns  0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPCloseSocket, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPCloseSocket( <br>        s, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPCloseSocket, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPConnect( <br>    IN SOCKET s, <br>    IN const struct sockaddr FAR *name, <br>    IN INT namelen, <br>    IN LPWSABUF lpCallerData, <br>    IN LPWSABUF lpCalleeData, <br>    IN LPQOS lpSQOS, <br>    IN LPQOS lpGQOS, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Establish a connection to a peer, <br>exchange connect data, <br>and specify needed <br>    quality of service based on the supplied flow spec. <br> <br>Arguments: <br> <br>    s            - A descriptor identifying an unconnected socket. <br> <br>    name         - The name of the peer to which the socket is to be connected. <br> <br>    namelen      - The length of the name. <br> <br>    lpCallerData - A  pointer to the user data that is to be transferred to the <br>                   peer during connection established. <br> <br>    lpCalleeData - A pointer to a buffer into which may be copied any user data <br>                   received from the peer during connection establishment. <br> <br>    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each <br>                   direction. <br> <br>    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if <br>                   applicable). <br> <br>    lpErrno      - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPConnect()  returns ERROR_SUCCESS.  Otherwise, it <br>    returns SOCKET_ERROR, and a specific erro rcode is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPConnect, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpCallerData, <br>                       &amp;lpCalleeData, <br>                       &amp;lpSQOS, <br>                       &amp;lpGQOS, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPConnect( <br>        s, <br>        name, <br>        namelen, <br>        lpCallerData, <br>        lpCalleeData, <br>        lpSQOS, <br>        lpGQOS, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPConnect, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpCallerData, <br>                    &amp;lpCalleeData, <br>                    &amp;lpSQOS, <br>                    &amp;lpGQOS, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPDuplicateSocket( <br>    IN SOCKET s, <br>    IN DWORD dwProcessID, <br>    IN LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    descriptor for a shared socket. <br> <br> <br>Arguments: <br> <br>    s              - Specifies the local socket descriptor. <br> <br>    dwProcessID    - Specifies  the  ID  of  the  target  process for which the <br>                     shared socket will be used. <br> <br>    lpProtocolInfo - A  pointer  to  a  buffer  allocated by the client that is <br>                     large enough to contain a WSAPROTOCOL_INFOA struct.  The <br>                     service  provider copies the protocol info struct contents <br>                     to this buffer. <br> <br>    lpErrno        - A pointer to the error code <br> <br>Return Value: <br> <br>    If  no  error  occurs, WPSDuplicateSocket()  returns zero.  Otherwise, the <br>    value of SOCKET_ERROR is returned, and a specific error number is available <br>    in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPDuplicateSocket, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;dwProcessID, <br>                       &amp;lpProtocolInfo, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPDuplicateSocket( <br>        s, <br>        dwProcessID, <br>        lpProtocolInfo, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPDuplicateSocket, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;dwProcessID, <br>                    &amp;lpProtocolInfo, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPEnumNetworkEvents( <br>    IN SOCKET s, <br>    OUT WSAEVENT hEventObject, <br>    OUT LPWSANETWORKEVENTS lpNetworkEvents, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Report occurrences of network events for the indicated socket. <br> <br>Arguments: <br> <br>    s               - A descriptor identifying the socket. <br> <br>    hEventObject    - An optional handle identifying an associated event object <br>                      to be reset. <br> <br>    lpNetworkEvents - A  pointer  to  a WSANETWORKEVENTS struct which is filled <br>                      with   a  record  of  occurred  network  events  and  any <br>                      associated error codes. <br> <br>    lpErrno         - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  return  value  is  ERROR_SUCCESS  if  the  operation  was  successful. <br>    Otherwise  the  value SOCKET_ERROR is returned, and a specific error number <br>    is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPEnumNetworkEvents, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;hEventObject, <br>                       &amp;lpNetworkEvents, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPEnumNetworkEvents( <br>        s, <br>        hEventObject, <br>        lpNetworkEvents, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPEnumNetworkEvents, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;hEventObject, <br>                    &amp;lpNetworkEvents, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPEventSelect( <br>    IN SOCKET s, <br>    IN OUT WSAEVENT hEventObject, <br>    IN long lNetworkEvents, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Specify  an  event object to be associated with the supplied set of network <br>    events. <br> <br>Arguments: <br> <br>    s              - A descriptor identifying the socket. <br> <br>    hEventObject   - A  handle  identifying  the  event object to be associated <br>                     with the supplied set of network events. <br> <br>    lNetworkEvents - A  bitmask  which  specifies  the  combination  of network <br>                     events in which the WinSock client has interest. <br> <br>    lpErrno        - A pointer to the error code. <br> <br>Return Value: <br> <br>    The return value is 0 if the WinSock client's specification of the network <br>    events and the associated event object was successful. Otherwise the value <br>    SOCKET_ERROR is returned, and a specific error number is available in <br>    lpErrno <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPEventSelect, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;hEventObject, <br>                       &amp;lNetworkEvents, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPEventSelect( <br>        s, <br>        hEventObject, <br>        lNetworkEvents, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPEventSelect, <br>                    &amp;ReturnValue, <br>                    m_lib_name, </code></pre>
<p>
</p>
<pre><code>&amp;s, <br>                    &amp;hEventObject, <br>                    &amp;lNetworkEvents, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPGetOverlappedResult( <br>    IN SOCKET s, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPDWORD lpcbTransfer, <br>    IN BOOL fWait, <br>    OUT LPDWORD lpdwFlags, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Returns the results of an overlapped operation on the specified socket. <br> <br>Arguments: <br> <br>    s            - Identifies  the  socket.   This  is the same socket that was <br>                   specified  when  the  overlapped  operation was started by a <br>                   call to WSPRecv(), WSPRecvFrom(), WSPSend(), WSPSendTo(), or <br>                   WSPIoctl(). <br> <br>    lpOverlapped - Points to a WSAOVERLAPPED structure that was specified <br>                   when the overlapped operation was started. <br> <br>    lpcbTransfer - Points to a 32-bit variable that receives the number of <br>                   bytes that were actually transferred by a send or receive <br>                   operation, or by WSPIoctl(). <br> <br>    fWait        - Specifies  whether  the function should wait for the pending <br>                   overlapped  operation  to  complete.   If TRUE, the function <br>                   does  not return until the operation has been completed.  If <br>                   FALSE  and  the  operation  is  still  pending, the function <br>                   returns FALSE and lperrno is WSA_IO_INCOMPLETE. <br> <br>    lpdwFlags    - Points  to  a  32-bit variable that will receive one or more <br>                   flags   that  supplement  the  completion  status.   If  the <br>                   overlapped   operation   was   initiated  via  WSPRecv()  or <br>                   WSPRecvFrom(), this parameter will contain the results value <br>                   for lpFlags parameter. <br> <br>    lpErrno      - A pointer to the error code. <br> <br>Return Value: <br> <br>    If WSPGetOverlappedResult() succeeds,the return value is TRUE.  This means <br>    that the overlapped operation has completed successfully and that the value <br>    pointed  to  by lpcbTransfer has been updated.  If WSPGetOverlappedResult() <br>    returns  FALSE,  this  means  that  either the overlapped operation has not <br>    completed  or  the  overlapped operation completed but with errors, or that <br>    completion  status  could  not  be  determined due to errors in one or more <br>    parameters  to  WSPGetOverlappedResult().  On failure, the value pointed to <br>    by  lpcbTransfer  will  not be updated.  lpErrno indicates the cause of the <br>    failure (either of WSPGetOverlappedResult() or of the associated overlapped <br>    operation). <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetOverlappedResult, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpOverlapped, <br>                       &amp;lpcbTransfer, <br>                       &amp;fWait, <br>                       &amp;lpdwFlags, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPGetOverlappedResult( <br>        s, <br>        lpOverlapped, <br>        lpcbTransfer, <br>        fWait, <br>        lpdwFlags, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetOverlappedResult, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpOverlapped, <br>                    &amp;lpcbTransfer, <br>                    &amp;fWait, <br>                    &amp;lpdwFlags, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPGetPeerName( <br>    IN SOCKET s, <br>    OUT struct sockaddr FAR *name, <br>    OUT INT FAR *namelen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Get the address of the peer to which a socket is connected. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a connected socket. <br> <br>    name    - A  pointer  to  the structure which is to receive the name of the <br>              peer. <br> <br>    namelen - A  pointer  to  an integer which, on input, indicates the size of <br>              the  structure  pointed  to  by name, and on output indicates the <br>              size of the returned name. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPGetPeerName() returns ERROR_SUCCESS.  Otherwise, a <br>    value  of  SOCKET_ERROR is returned, and a specific error code is available <br>    in lpErrno <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetPeerName, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPGetPeerName( <br>        s, <br>        name, <br>        namelen, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetPeerName, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPGetQOSByName( <br>    IN SOCKET s, <br>    IN LPWSABUF lpQOSName, <br>    IN LPQOS lpQOS, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initializes a QOS structure based on a named template. <br> <br>Arguments: <br> <br>    s         - A descriptor identifying a socket. <br> <br>    lpQOSName - Specifies the QOS template name. <br> <br>    lpQOS     - A pointer to the QOS structure to be filled. <br> <br>    lpErrno   - A pointer to the error code. <br> <br>Return Value: <br> <br>    If the function succeeds, the return value is TRUE.  If the function fails, <br>    the  return  value  is  FALSE, and  a  specific error code is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetQOSByName, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpQOSName, <br>                       &amp;lpQOS, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPGetQOSByName( <br>        s, <br>        lpQOSName, <br>        lpQOS, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetQOSByName, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpQOSName, <br>                    &amp;lpQOS, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPGetSockName( <br>    IN SOCKET s, <br>    OUT struct sockaddr FAR *name, <br>    OUT INT FAR *namelen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Get the local name for a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a bound socket. <br> <br>    name    - A pointer to a structure used to supply the address (name) of the <br>              socket. <br> <br>    namelen - A  pointer  to  an integer which, on input, indicates the size of <br>              the  structure  pointed  to  by name, and on output indicates the <br>              size of the returned name <br> <br>    lpErrno - A Pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPGetSockName() returns ERROR_SUCCESS.  Otherwise, a <br>    value  of  SOCKET_ERROR is returned, and a specific error code is available <br>    in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetSockName, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPGetSockName( <br>        s, <br>        name, <br>        namelen, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetSockName, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPGetSockOpt( <br>    IN SOCKET s, <br>    IN INT level, <br>    IN INT optname, <br>    OUT char FAR *optval, <br>    OUT INT FAR *optlen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Retrieve a socket option. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    level   - The  level  at  which the option is defined; the supported levels <br>              include SOL_SOCKET (See annex for more protocol-specific levels.) <br> <br>    optname - The socket option for which the value is to be retrieved. <br> <br>    optval  - A  pointer  to  the  buffer  in which the value for the requested <br>              option is to be returned. <br> <br>    optlen  - A pointer to the size of the optval buffer. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs,  WSPGetSockOpt()  returns  0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetSockOpt, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;level, <br>                       &amp;optname, <br>                       &amp;optval, <br>                       &amp;optlen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPGetSockOpt( <br>        s, <br>        level, <br>        optname, <br>        optval, <br>        optlen, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetSockOpt, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;level, <br>                    &amp;optname, <br>                    &amp;optval, <br>                    &amp;optlen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br>inline INT <br>DPROVIDER::WSPIoctl( <br>    IN SOCKET s, <br>    IN DWORD dwIoControlCode, <br>    IN LPVOID lpvInBuffer, <br>    IN DWORD cbInBuffer, <br>    IN LPVOID lpvOutBuffer, <br>    IN DWORD cbOutBuffer, <br>    IN LPDWORD lpcbBytesReturned, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Control the mode of a socket. <br> <br>Arguments: <br> <br>    s                   - Handle to a socket <br> <br>    dwIoControlCode     - Control code of operation to perform <br> <br>    lpvInBuffer         - Address of input buffer <br> <br>    cbInBuffer          - Size of input buffer <br> <br>    lpvOutBuffer        - Address of output buffer <br> <br>    cbOutBuffer         - Size of output buffer <br> <br>    lpcbBytesReturned   - A pointer to the size of output buffer's contents. <br> <br>    lpOverlapped        - Address of WSAOVERLAPPED structure <br> <br>    lpCompletionRoutine - A  pointer  to the completion routine called when the <br>                          operation has been completed. <br> <br>    lpThreadId          - A  pointer to a thread ID structure to be used by the <br>                          provider <br> <br>    lpErrno             - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no error occurs and the operation has completed immediately, WSPIoctl() <br>    returns  0.   Note  that in this case the completion routine, if specified, <br>    will  have  already  been  queued.   Otherwise, a value of SOCKET_ERROR is <br>    returned, and  a  specific  error code is available in lpErrno.  The error <br>    code  WSA_IO_PENDING  indicates  that  an  overlapped  operation  has  been <br>    successfully  initiated  and  that  conpletion will be indicated at a later <br>    time.   Any  other  error  code  indicates that no overlapped operation was <br>    initiated and no completion indication will occur. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPIoctl, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;dwIoControlCode, <br>                       &amp;lpvInBuffer, <br>                       &amp;cbInBuffer, <br>                       &amp;lpvOutBuffer, <br>                       &amp;cbOutBuffer, <br>                       &amp;lpcbBytesReturned, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPIoctl( <br>        s, <br>        dwIoControlCode, <br>        lpvInBuffer, <br>        cbInBuffer, <br>        lpvOutBuffer, <br>        cbOutBuffer, <br>        lpcbBytesReturned, <br>        lpOverlapped, <br>        lpCompletionRoutine, <br>        lpThreadId, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPIoctl, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;dwIoControlCode, <br>                    &amp;lpvInBuffer, <br>                    &amp;cbInBuffer, <br>                    &amp;lpvOutBuffer, <br>                    &amp;cbOutBuffer, <br>                    &amp;lpcbBytesReturned, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPJoinLeaf( <br>    IN SOCKET s, <br>    IN const struct sockaddr FAR *name, <br>    IN INT namelen, <br>    IN LPWSABUF lpCallerData, <br>    IN LPWSABUF lpCalleeData, <br>    IN LPQOS lpSQOS, <br>    IN LPQOS lpGQOS, <br>    IN DWORD dwFlags, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Join  a  leaf  node  into  a multipoint session, exchange connect data, and <br>    specify needed quality of service based on the supplied flow specs. <br> <br>Arguments: <br> <br>    s            - A descriptor identifying a multipoint socket. <br> <br>    name         - The name of the peer to which the socket is to be joined. <br> <br>    namelen      - The length of the name. <br> <br>    lpCallerData - A  pointer to the user data that is to be transferred to the <br>                   peer during multipoint session establishment. <br> <br>    lpCalleeData - A  pointer  to  the user data that is to be transferred back <br>                   from the peer during multipoint session establishment. <br> <br>    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each <br>                   direction. <br> <br>    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if <br>                   applicable). <br> <br>    dwFlags      - Flags  to  indicate  that  the socket is acting as a sender, <br>                   receiver, or both. <br> <br>    lpErrno      - A pointer to the error code. <br> <br>Return Value: <br> <br>    If no error occurs, <br>WSPJoinLeaf() returns a value of type SOCKET which is a <br>    descriptor  for the newly created multipoint socket.  Otherwise,a value of <br>    INVALID_SOCKET  is  returned, and  a  specific  error code is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPJoinLeaf, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpCallerData, <br>                       &amp;lpCalleeData, <br>                       &amp;lpSQOS, <br>                       &amp;lpGQOS, <br>                       &amp;dwFlags, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPJoinLeaf( <br>        s, <br>        name, <br>        namelen, <br>        lpCallerData, <br>        lpCalleeData, <br>        lpSQOS, <br>        lpGQOS, <br>        dwFlags, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPJoinLeaf, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpCallerData, <br>                    &amp;lpCalleeData, <br>                    &amp;lpSQOS, <br>                    &amp;lpGQOS, <br>                    &amp;dwFlags, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPListen( <br>    IN SOCKET s, <br>    IN INT backlog, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Establish a socket to listen for incoming connections. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a bound, <br>unconnected socket. <br> <br>    backlog - The  maximum length to which the queue of pending connections may <br>              grow.   If  this  value  is  SOMAXCONN, <br>then the service provider <br>              should set the backlog to a maximum "reasonable" value. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPListen()  returns  0.   Otherwise, a  value  of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPListen, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;backlog, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPListen( <br>        s, <br>        backlog, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPListen, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;backlog, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPRecv( <br>    IN SOCKET s, <br>    IN LPWSABUF lpBuffers, <br>    IN DWORD dwBufferCount, <br>    IN LPDWORD lpNumberOfBytesRecvd, <br>    IN OUT LPDWORD lpFlags, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Receive data on a socket. <br> <br>Arguments: <br> <br>    s                    - A descriptor identifying a connected socket. <br> <br>    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each <br>                           WSABUF  structure contains a pointer to a buffer and <br>                           the length of the buffer. <br> <br>    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers <br>                           array. <br> <br>    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this <br>                           call. <br> <br>    lpFlags              - A pointer to flags. <br> <br>    lpOverlapped         - A pointer to a WSAOVERLAPPED structure. <br> <br>    lpCompletionRoutine  - A  pointer to the completion routine called when the <br>                           receive operation has been completed. <br> <br>    lpThreadId           - A pointer to a thread ID structure to be used by the <br>                           provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno              - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and the receive operation has completed immediately, <br>    WSPRecv() returns the number of bytes received.  If the connection has been <br>    closed, it  returns  0.  Note that in this case the completion routine, if <br>    specified,  will   have  already  been  queued.   Otherwise, a  value  of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code WSA_IO_PENDING indicates that the overlapped an <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped  operations  was  initiated  and  no  completion indication will <br>    occur. <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPRecv, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;dwBufferCount, <br>                       &amp;lpNumberOfBytesRecvd, <br>                       &amp;lpFlags, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPRecv( <br>        s, <br>        lpBuffers, <br>        dwBufferCount, <br>        lpNumberOfBytesRecvd, <br>        lpFlags, <br>        lpOverlapped, <br>        lpCompletionRoutine, <br>        lpThreadId, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPRecv, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;dwBufferCount, <br>                    &amp;lpNumberOfBytesRecvd, <br>                    &amp;lpFlags, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPRecvDisconnect( <br>    IN SOCKET s, <br>    IN LPWSABUF lpInboundDisconnectData, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Terminate  reception  on  a socket, and retrieve the disconnect data if the <br>    socket is connection-oriented. <br> <br>Arguments: <br> <br>    s                       - A descriptor identifying a socket. <br> <br>    lpInboundDisconnectData - A  pointer to a buffer into which disconnect data <br>                              is to be copied. <br> <br>    lpErrno                 - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no error occurs, WSPRecvDisconnect() returns ERROR_SUCCESS.  Otherwise, <br>    a value of SOCKET_ERROR is returned, and a specific error code is available <br>    in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPRecvDisconnect, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpInboundDisconnectData, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPRecvDisconnect( <br>        s, <br>        lpInboundDisconnectData, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPRecvDisconnect, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpInboundDisconnectData, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPRecvFrom( <br>    IN  SOCKET s, <br>    IN  LPWSABUF lpBuffers, <br>    IN  DWORD dwBufferCount, <br>    IN  LPDWORD lpNumberOfBytesRecvd, <br>    IN  OUT LPDWORD lpFlags, <br>    OUT struct sockaddr FAR *  lpFrom, <br>    IN  LPINT lpFromlen, <br>    IN  LPWSAOVERLAPPED lpOverlapped, <br>    IN  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Receive a datagram and store the source address. <br> <br>Arguments: <br> <br>    s                    - A descriptor identifying a socket. <br> <br>    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each <br>                           WSABUF  structure contains a pointer to a buffer and <br>                           the length of the buffer. <br> <br>    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers <br>                           array. <br> <br>    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this <br>                           call. <br> <br>    lpFlags              - A pointer to flags. <br> <br>    lpFrom               - An  optional pointer to a buffer which will hold the <br>                           source address upon the completion of the overlapped <br>                           operation. <br> <br>    lpFromlen            - A  pointer  to the size of the from buffer, required <br>                           only if lpFrom is specified. <br> <br>    lpOverlapped         - A pointer to a WSAOVERLAPPED structure. <br> <br>    CompletionRoutine    - A  pointer to the completion routine called when the <br>                           receive operation has been completed. <br> <br>    lpThreadId           - A pointer to a thread ID structure to be used by the <br>                           provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno              - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and the receive operation has completed immediately, <br>    WSPRecvFrom()  returns the number of bytes received.  If the connection has <br>    been  closed, it returns 0.  Note that in this case the completion routine, <br>    if  specified  will  have  already  been  queued.   Otherwise,  a  value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped  operations  was  initiated  and  no  completion indication will <br>    occur. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPRecvFrom, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;dwBufferCount, <br>                       &amp;lpNumberOfBytesRecvd, <br>                       &amp;lpFlags, <br>                       &amp;lpFrom, <br>                       &amp;lpFromlen, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPRecvFrom( <br>        s, <br>        lpBuffers, <br>        dwBufferCount, <br>        lpNumberOfBytesRecvd, <br>        lpFlags, <br>        lpFrom, <br>        lpFromlen, <br>        lpOverlapped, <br>        lpCompletionRoutine, <br>        lpThreadId, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPRecvFrom, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;dwBufferCount, <br>                    &amp;lpNumberOfBytesRecvd, <br>                    &amp;lpFlags, <br>                    &amp;lpFrom, <br>                    &amp;lpFromlen, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPSelect( <br>    IN INT nfds, <br>    IN OUT fd_set FAR *readfds, <br>    IN OUT fd_set FAR *writefds, <br>    IN OUT fd_set FAR *exceptfds, <br>    IN const struct timeval FAR *timeout, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Determine the status of one or more sockets. <br> <br>Arguments: <br> <br>    nfds      - This  argument  is  ignored  and  included only for the sake of <br>                compatibility. <br> <br>    readfds   - An  optional  pointer  to  a  set  of sockets to be checked for <br>                readability. <br> <br>    writefds  - An  optional  pointer  to  a  set  of sockets to be checked for <br>                writability <br> <br>    exceptfds - An  optional  pointer  to  a  set  of sockets to be checked for <br>                errors. <br> <br>    timeout   - The  maximum  time  for  WSPSelect()  to  wait, or  NULL for a <br>                blocking operation. <br> <br>    lpErrno   - A pointer to the error code. <br> <br>Return Value: <br> <br>    WSPSelect()  returns  the  total  number of descriptors which are ready and <br>    contained  in  the  fd_set  structures, 0  if  the  time limit expired, or <br>    SOCKET_ERROR  if an error occurred.  If the return value is SOCKET_ERROR, a <br>    specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSelect, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;nfds, <br>                       &amp;readfds, <br>                       &amp;writefds, <br>                       &amp;exceptfds, <br>                       &amp;timeout, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPSelect( <br>        nfds, <br>        readfds, <br>        writefds, <br>        exceptfds, <br>        timeout, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSelect, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;nfds, <br>                    &amp;readfds, <br>                    &amp;writefds, <br>                    &amp;exceptfds, <br>                    &amp;timeout, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPSend( <br>    IN SOCKET s, <br>    IN LPWSABUF lpBuffers, <br>    IN DWORD dwBufferCount, <br>    IN LPDWORD lpNumberOfBytesSent, <br>    IN DWORD dwFlags, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ </code></pre>
<p>
</p>
<pre><code>Routine Description: <br> <br>    Send data on a connected socket. <br> <br>Arguments: <br> <br>    s                   - A descriptor identifying a connected socket. <br> <br>    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each <br>                          WSABUF  structure  contains a pointer to a buffer and <br>                          the length of the buffer. <br> <br>    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers <br>                          array. <br> <br>    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call. <br> <br>    dwFlags             - Flags. <br> <br>    lpOverlapped        - A pointer to a WSAOVERLAPPED structure. <br> <br>    lpCompletionRoutine - A  pointer  to the completion routine called when the <br>                          send operation has been completed. <br> <br>    lpThreadId          - A  pointer to a thread ID structure to be used by the <br>                          provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno             - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and  the  send  operation has completed immediately, <br>    WSPSend() returns the number of bytes received.  If the connection has been <br>    closed,  it  returns  0.  Note that in this case the completion routine, if <br>    specified, will   have  already  been  queued.   Otherwise, a  value  of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped operation was initiated and no completion indication will occur. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSend, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;dwBufferCount, <br>                       &amp;lpNumberOfBytesSent, <br>                       &amp;dwFlags, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPSend( <br>        s, <br>        lpBuffers, <br>        dwBufferCount, <br>        lpNumberOfBytesSent, <br>        dwFlags, <br>        lpOverlapped, <br>        lpCompletionRoutine, <br>        lpThreadId, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSend, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;dwBufferCount, <br>                    &amp;lpNumberOfBytesSent, <br>                    &amp;dwFlags, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPSendDisconnect( <br>    IN SOCKET s, <br>    IN LPWSABUF lpOutboundDisconnectData, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initiate  termination  of the connection for the socket and send disconnect <br>    data. <br> <br>Arguments: <br> <br>    s                        - A descriptor identifying a socket. <br> <br>    lpOutboundDisconnectData - A pointer to the outgoing disconnect data. <br> <br>    lpErrno                  - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPSendDisconnect() returns 0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSendDisconnect, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpOutboundDisconnectData, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPSendDisconnect( <br>        s, <br>        lpOutboundDisconnectData, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSendDisconnect, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpOutboundDisconnectData, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPSendTo( <br>    IN SOCKET s, <br>    IN LPWSABUF lpBuffers, <br>    IN DWORD dbBufferCount, <br>    IN LPDWORD lpNumberOfBytesSent, <br>    IN DWORD dwFlags, <br>    IN const struct sockaddr FAR *  lpTo, <br>    IN INT iTolen, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Send data to a specific destination using overlapped I/O. <br> <br>Arguments: <br> <br>    s                   - A descriptor identifying a socket. <br> <br>    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each <br>                          WSABUF  structure  contains a pointer to a buffer and <br>                          the length of the buffer. <br> <br>    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers <br>                          array. <br> <br>    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call. <br> <br>    dwFlags             - Flags. <br> <br>    lpTo                - An  optional  pointer  to  the  address of the target <br>                          socket. <br> <br>    iTolen              - The size of the address in lpTo. <br> <br>    lpOverlapped        - A pointer to a WSAOVERLAPPED structure. <br> <br>    lpCompletionRoutine - A  pointer  to the completion routine called when the <br>                          send operation has been completed. <br> <br>    lpThreadId          - A  pointer to a thread ID structure to be used by the <br>                          provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno             - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and the receive operation has completed immediately, <br>    WSPSendTo()  returns  the  number of bytes received.  If the connection has <br>    been  closed,it returns 0.  Note that in this case the completion routine, <br>    if  specified, will  have  already  been  queued.   Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped operation was initiated and no completion indication will occur. <br> <br>--*/ <br> <br> <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSendTo, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;lpNumberOfBytesSent, <br>                       &amp;dwFlags, <br>                       &amp;lpTo, <br>                       &amp;iTolen, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPSendTo( <br>        s, <br>        lpBuffers, <br>        dbBufferCount, <br>        lpNumberOfBytesSent, <br>        dwFlags, <br>        lpTo, <br>        iTolen, <br>        lpOverlapped, <br>        lpCompletionRoutine, <br>        lpThreadId, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSendTo, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;lpNumberOfBytesSent, <br>                    &amp;dwFlags, <br>                    &amp;lpTo, <br>                    &amp;iTolen, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br>inline INT <br>DPROVIDER::WSPSetSockOpt( <br>    IN SOCKET s, <br>    IN INT level, <br>    IN INT optname, <br>    IN const char FAR *optval, <br>    IN INT optlen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Set a socket option. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    level   - The  level  at  which the option is defined; the supported levels <br>              include   SOL_SOCKET.   (See  annex  for  more  protocol-specific <br>              levels.) <br> <br>    optname - The socket option for which the value is to be set. <br> <br>    optval  - A  pointer  to  the  buffer  in which the value for the requested <br>              option is supplied. <br> <br>    optlen  - The size of the optval buffer. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPSetSockOpt()  returns  0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSetSockOpt, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;level, <br>                       &amp;optname, <br>                       &amp;optval, <br>                       &amp;optlen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPSetSockOpt( <br>        s, <br>        level, <br>        optname, <br>        optval, <br>        optlen, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSetSockOpt, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;level, <br>                    &amp;optname, <br>                    &amp;optval, <br>                    &amp;optlen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPShutdown( <br>    IN SOCKET s, <br>    IN INT how, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Disable sends and/or receives on a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    how     - A  flag  that describes what types of operation will no longer be <br>              allowed. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPShutdown()  returns  0.   Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPShutdown, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;s, <br>                       &amp;how, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPShutdown( <br>        s, <br>        how, <br>        lpErrno); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPShutdown, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;s, <br>                    &amp;how, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPSocket( <br>    IN int af, <br>    IN int type, <br>    IN int protocol, <br>    IN LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    IN GROUP g, <br>    IN DWORD dwFlags, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initialize  internal  data  and  prepare sockets for usage.  Must be called <br>    before any other socket routine. <br> <br>Arguments: <br> <br>    lpProtocolInfo - Supplies  a pointer to a WSAPROTOCOL_INFOA struct that <br>                     defines  the characteristics of the socket to be created. <br> <br>    g              - Supplies  the identifier of the socket group which the new <br>                     socket is to join. <br> <br>    dwFlags        - Supplies the socket attribute specification. <br> <br>    lpErrno        - Returns the error code <br> <br>Return Value: <br> <br>    WSPSocket() returns zero if successful.  Otherwise it returns an error code <br>    as outlined in the SPI. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    // Debug/Trace stuff <br>    if (PREAPINOTIFY(( DTCODE_WSPSocket, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;af, <br>                       &amp;type, <br>                       &amp;protocol, <br>                       &amp;lpProtocolInfo, <br>                       &amp;g, <br>                       &amp;dwFlags, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br>    assert(m_proctable-&gt;lpWSPSocket); <br> <br>    // Actual code... <br>    ReturnValue = m_proctable-&gt;lpWSPSocket( <br>        af, <br>        type, <br>        protocol, <br>        lpProtocolInfo, <br>        g, <br>        dwFlags, <br>        lpErrno); <br> <br> <br>    // Debug/Trace stuff <br>    POSTAPINOTIFY(( DTCODE_WSPSocket, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;af, <br>                    &amp;type, <br>                    &amp;protocol, <br>                    &amp;lpProtocolInfo, <br>                    &amp;g, <br>                    &amp;dwFlags, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> <br>inline INT <br>DPROVIDER::WSPStringToAddress( <br>    IN     LPWSTR AddressString, <br>    IN     INT AddressFamily, <br>    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    OUT    LPSOCKADDR lpAddress, <br>    IN OUT LPINT lpAddressLength, <br>    IN OUT LPINT lpErrno ) <br>/*++ <br> <br>Routine Description: <br> <br>    WSPStringToAddress() converts a human-readable string to a socket address <br>    structure (SOCKADDR) suitable for pass to Windows Sockets routines which <br>    take such a structure.  If the caller wishes the translation to be done by <br>    a particular provider, it should supply the corresponding WSAPROTOCOL_INFO <br>    struct in the lpProtocolInfo parameter. <br> <br>Arguments: <br> <br>    AddressString - points to the zero-terminated human-readable string to <br>                    convert. <br> <br>    AddressFamily - the address family to which the string belongs. <br> <br>    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular <br>                     provider. <br> <br>    Address - a buffer which is filled with a single SOCKADDR structure. <br> <br>    lpAddressLength - The length of the Address buffer.  Returns the size of <br>                      the resultant SOCKADDR structure. <br> <br>Return Value: <br> <br>    The return value is 0 if the operation was successful.  Otherwise the value <br>    SOCKET_ERROR is returned. <br> <br>--*/ <br>{ <br>     INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPStringToAddress, <br>                       &amp;ReturnValue, <br>                       m_lib_name, <br>                       &amp;AddressString, <br>                       &amp;AddressFamily, <br>                       &amp;lpProtocolInfo, <br>                       &amp;lpAddress, <br>                       &amp;lpAddressLength, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    ReturnValue = m_proctable-&gt;lpWSPStringToAddress( <br>        AddressString, <br>        AddressFamily, <br>        lpProtocolInfo, <br>        lpAddress, <br>        lpAddressLength, <br>        lpErrno); <br> <br> <br>    POSTAPINOTIFY(( DTCODE_WSPStringToAddress, <br>                    &amp;ReturnValue, <br>                    m_lib_name, <br>                    &amp;AddressString, <br>                    &amp;AddressFamily, <br>                    &amp;lpProtocolInfo, <br>                    &amp;lpAddress, <br>                    &amp;lpAddressLength, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br>inline INT <br>DPROVIDER::TransmitFile ( <br>IN SOCKET hSocket, <br>IN HANDLE hFile, <br>IN DWORD nNumberOfBytesToWrite, <br>IN DWORD nNumberOfBytesPerSend, <br>IN LPOVERLAPPED lpOverlapped, <br>IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, <br>IN DWORD dwReserved, <br>OUT LPINT lpErrno <br>) <br>{ <br>if (m_transmitfile) { <br>if (m_transmitfile( <br>hSocket, <br>hFile, <br>nNumberOfBytesToWrite, <br>nNumberOfBytesPerSend, <br>lpOverlapped, <br>lpTransmitBuffers, <br>dwReserved)) <br>return NO_ERROR; <br>else { <br>*lpErrno = GetLastError (); <br>return SOCKET_ERROR; <br>} <br>} <br>else { <br>*lpErrno = WSAEOPNOTSUPP; <br>return SOCKET_ERROR; <br>} <br>} <br> <br>inline INT <br>DPROVIDER::AcceptEx ( <br>IN SOCKET sListenSocket, <br>IN SOCKET sAcceptSocket, <br>IN PVOID lpOutputBuffer, <br>IN DWORD dwReceiveDataLength, <br>IN DWORD dwLocalAddressLength, <br>IN DWORD dwRemoteAddressLength, <br>OUT LPDWORD lpdwBytesReceived, <br>IN LPOVERLAPPED lpOverlapped, <br>OUT LPINTlpErrno <br>) <br>{ <br>if (m_acceptex) { <br>if (m_acceptex ( <br>sListenSocket, <br>sAcceptSocket, <br>lpOutputBuffer, <br>dwReceiveDataLength, <br>dwLocalAddressLength, <br>dwRemoteAddressLength, <br>lpdwBytesReceived, <br>lpOverlapped)) <br>return NO_ERROR; <br>else { <br>*lpErrno = GetLastError (); <br>return SOCKET_ERROR; <br>} <br>} <br>else  { <br>*lpErrno = WSAEOPNOTSUPP; <br>return SOCKET_ERROR; <br>} <br>} <br> <br> <br> <br> <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
