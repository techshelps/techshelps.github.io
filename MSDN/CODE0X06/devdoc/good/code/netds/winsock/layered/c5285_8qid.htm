<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DWORKER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5305"></a>DWORKER.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br> <br>Module Name: <br> <br> <br>Abstract: <br> <br> <br>--*/ <br> <br>#include "precomp.h" <br> <br> <br>PDOVERLAPPEDSTRUCTMGR gOverlappedManager; <br> <br> <br> <br> <br>VOID <br>CALLBACK <br>APCProc( <br>    DWORD Context <br>    ) <br>/*++ <br>Routine Description: <br> <br>    This routine unpacks the context value passed to WPUQueueApc() and calls <br>    the users completion function. This function is called in the clients <br>    thread context. <br> <br>Arguments: <br> <br>    Context - The context value passed to WPUQueueApc(). <br> <br>Return Value: <br> <br>    None <br> <br>--*/ <br>{ <br>    LPOVERLAPPED                        lpOverlapped; <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE  UserCompletionRoutine; <br> <br>    lpOverlapped = (LPOVERLAPPED) Context; <br>    UserCompletionRoutine = <br>        (LPWSAOVERLAPPED_COMPLETION_ROUTINE)lpOverlapped-&gt;Internal; <br>    lpOverlapped-&gt;Internal = lpOverlapped-&gt;Offset; // To make sure it <br>                                                   // in no longer is  <br>                                                   // WSS_OPERATION_IN_PROGRESS <br>    UserCompletionRoutine ( <br>        lpOverlapped-&gt;Offset, <br>        lpOverlapped-&gt;InternalHigh, <br>        lpOverlapped, <br>        lpOverlapped-&gt;OffsetHigh <br>        ); <br> <br> <br>} <br> <br>VOID <br>CALLBACK <br>OverlappedCompletionProc( <br>    DWORD  dwError, <br>    DWORD  cbTransferred, <br>    LPWSAOVERLAPPED lpOverlapped, <br>    DWORD dwFlags <br>    ) <br>/*++ <br>Routine Description: <br> <br>    This routine is the completion routine for all overlapped operations <br>    initiated with the lower level provider. <br> <br>Arguments: <br> <br>    dwError - The error code for the overlapped operation. <br> <br>    cbTransferred - The number of bytes transfered by the overlapped <br>                    operation. <br> <br>    lpOverlapped - a pointer to the WSAOVERLAPPED struct associated with the <br>                   overlapped operation. <br> <br>    dwFlags -  Not Used must be zero. <br> <br>Return Value: <br> <br>    None <br> <br>--*/ <br>{ <br>    INT                                Errno; <br>    PINTERNALOVERLAPPEDSTRUCT   OverlappedStruct; <br>DWORD   OperationType; <br>PDPROVIDER   Provider; <br>SOCKET   ProviderSocket, Socket; <br>WSATHREADID   UserThreadId; <br>LPWSAOVERLAPPED_COMPLETION_ROUTINE UserCompletionRoutine; <br>LPWSAOVERLAPPED   UserOverlappedStruct; <br> <br> <br> <br>    // Get the stored overlapped operation parameters <br>OverlappedStruct = gOverlappedManager-&gt;GetInternalOverlappedStructure( <br>lpOverlapped); <br>    // If the completed operation was a recieve operation copy the internal <br>    // buffers into the users buffers. <br>    if (OverlappedStruct != NULL){ <br>OperationType = OverlappedStruct-&gt;iolOperationType; <br>Socket = OverlappedStruct-&gt;iolSocket; <br>Provider = OverlappedStruct-&gt;iolProvider; <br>ProviderSocket = OverlappedStruct-&gt;iolProviderSocket; <br>UserCompletionRoutine = OverlappedStruct-&gt;iolUserCompletionRoutine; <br>UserOverlappedStruct = OverlappedStruct-&gt;iolUserOverlappedStruct; <br>UserThreadId = OverlappedStruct-&gt;iolUserThreadId; <br>         <br>if (dwError==WSA_IO_PENDING) <br>            Provider-&gt;WSPGetOverlappedResult ( <br>                    ProviderSocket, <br>                    lpOverlapped, <br>                    &amp;cbTransferred, <br>                    FALSE, <br>                    &amp;dwFlags, <br>                    (int *)&amp;dwError); <br>                                 <br> <br>        switch (OperationType) { <br>case WSP_RECV: <br>        case WSP_RECVFROM: <br>            gBufferManager-&gt;CopyBuffer( <br>(OverlappedStruct-&gt;iolInternalBufferCount &lt;= MAX_FAST_BUFS) <br>? &amp;OverlappedStruct-&gt;iolInternalBuffers[0] <br>: OverlappedStruct-&gt;iolpInternalBuffers, <br>                OverlappedStruct-&gt;iolInternalBufferCount, <br>0, <br>cbTransferred, <br>(OverlappedStruct-&gt;iolUserBufferCount &lt;= MAX_FAST_BUFS) <br>? &amp;OverlappedStruct-&gt;iolUserBuffers[0] <br>: OverlappedStruct-&gt;iolpUserBuffers, <br>                OverlappedStruct-&gt;iolUserBufferCount, <br>                0); <br>            gBufferManager-&gt;FreeBuffer( <br>(OverlappedStruct-&gt;iolInternalBufferCount &lt;= MAX_FAST_BUFS) <br>? &amp;OverlappedStruct-&gt;iolInternalBuffers[0] <br>: OverlappedStruct-&gt;iolpInternalBuffers, <br>                OverlappedStruct-&gt;iolInternalBufferCount); <br>if (OverlappedStruct-&gt;iolUserBufferCount &gt; MAX_FAST_BUFS) <br>delete OverlappedStruct-&gt;iolpUserBuffers; <br>if (OverlappedStruct-&gt;iolInternalBufferCount &gt; MAX_FAST_BUFS) <br>delete OverlappedStruct-&gt;iolpInternalBuffers; <br>break; <br> <br>case WSP_SEND: <br>case WSP_SENDTO: <br>if (OverlappedStruct-&gt;iolUserBufferCount &gt; MAX_FAST_BUFS) <br>delete OverlappedStruct-&gt;iolpUserBuffers; <br>break; <br> <br>        case WSP_IOCTL: <br>if ((OverlappedStruct-&gt;iolIoControlCode==SIO_GET_EXTENSION_FUNCTION_POINTER) <br>&amp;&amp; (NO_ERROR==Errno)) { <br>Provider-&gt;InterceptExtensions ( <br>OverlappedStruct-&gt;iolInputBuffer, <br>OverlappedStruct-&gt;iolOutputBuffer, <br>&amp;Errno); <br>} <br>break; <br>} <br> <br>        gOverlappedManager-&gt;FreeOverlappedStruct (lpOverlapped); <br> <br> <br>        // If the user requested completion routine notification of the I/O <br>        // completion queue an APC to the user thread else signal the users <br>        // event. <br>        if (UserCompletionRoutine){ <br>            UserOverlappedStruct-&gt;InternalHigh = cbTransferred; <br>            UserOverlappedStruct-&gt;Offset = dwError; <br>            UserOverlappedStruct-&gt;OffsetHigh = dwFlags; <br> <br>            // Changing Internal field to anything other than <br>            // WSS_OPERATON_IN_PROGRESS indicates that operation <br>            // is completed and results can be read by WSPGetOverlappedResult, <br>            // That's why we set this field last (after updating all others) <br>            // Note that event if address of user completion routine is  <br>            // equal to WSS_OPERATON_IN_PROGRESS (numericall), we are still <br>            // safe, because we'll update it again in our completion routine <br>            // Also, generally if application specifies completion routine, <br>            // it should not use WSAGetOverlappedResult, so essentially by <br>            // doing all of this we are just making our code bullet proof <br>            UserOverlappedStruct-&gt;Internal = (DWORD)UserCompletionRoutine; <br> <br>            gUpCallTable.lpWPUQueueApc( <br>                &amp;UserThreadId, <br>                APCProc, <br>                (DWORD)UserOverlappedStruct, <br>                &amp;Errno); <br> <br>        } //if <br>        else{ <br>            UserOverlappedStruct-&gt;Offset = dwError; <br>            UserOverlappedStruct-&gt;OffsetHigh = dwFlags; <br>                // Internal and InternalHigh fields will be updated <br>                // by the WPUCompleteOverlappedRequest <br>            lpWPUCompleteOverlappedRequest ( <br>Socket, <br>                UserOverlappedStruct, <br>                dwError, <br>                cbTransferred, <br>                &amp;Errno); <br>        } //else <br>    } //if <br>} <br> <br> <br> <br>VOID <br>InitiateOverlappedOperation ( <br>    PINTERNALOVERLAPPEDSTRUCT           OverlappedStruct, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE  CompletionProc, <br>    LPWSATHREADID                       thread_id <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initiates overlapped operation with provider. <br> <br>Arguments: <br> <br>    OverlappedStruct    - packet operation parameters <br>    CompletionProc      - routine to be invoked upon completion <br>    thread_id           - id of the thread to which to post APC if any <br>Return Value: <br> <br>    NONE <br>--*/ <br>{ <br>    DWORD                     BytesTransfered; <br>    INT                       Errno; <br>    INT                       ReturnCode; <br> <br>    switch (OverlappedStruct-&gt;iolOperationType) { <br>    case WSP_RECV: <br>        ReturnCode = OverlappedStruct-&gt;iolProvider-&gt;WSPRecv( <br>            OverlappedStruct-&gt;iolProviderSocket, <br>(OverlappedStruct-&gt;iolInternalBufferCount &lt;= MAX_FAST_BUFS) <br>? &amp;OverlappedStruct-&gt;iolInternalBuffers[0] <br>: OverlappedStruct-&gt;iolpInternalBuffers, <br>            OverlappedStruct-&gt;iolInternalBufferCount, <br>            &amp;BytesTransfered, <br>            &amp;OverlappedStruct-&gt;iolFlags, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>            CompletionProc, <br>            thread_id, <br>            &amp;Errno); <br>        break; <br> <br>    case WSP_RECVFROM: <br>        ReturnCode = OverlappedStruct-&gt;iolProvider-&gt;WSPRecvFrom( <br>            OverlappedStruct-&gt;iolProviderSocket, <br>(OverlappedStruct-&gt;iolInternalBufferCount &lt;= MAX_FAST_BUFS) <br>? &amp;OverlappedStruct-&gt;iolInternalBuffers[0] <br>: OverlappedStruct-&gt;iolpInternalBuffers, <br>            OverlappedStruct-&gt;iolInternalBufferCount, <br>            &amp;BytesTransfered, <br>            &amp;OverlappedStruct-&gt;iolFlags, <br>            OverlappedStruct-&gt;iolSockAddr, <br>            OverlappedStruct-&gt;iolSockAddrLenPtr, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>            CompletionProc, <br>            thread_id, <br>            &amp;Errno); <br>        break; <br> <br>    case WSP_SEND: <br>         ReturnCode = OverlappedStruct-&gt;iolProvider-&gt;WSPSend( <br>            OverlappedStruct-&gt;iolProviderSocket, <br>(OverlappedStruct-&gt;iolUserBufferCount &lt;= MAX_FAST_BUFS) <br>? &amp;OverlappedStruct-&gt;iolUserBuffers[0] <br>: OverlappedStruct-&gt;iolpUserBuffers, <br>            OverlappedStruct-&gt;iolUserBufferCount, <br>            &amp;BytesTransfered, <br>            OverlappedStruct-&gt;iolFlags, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>            CompletionProc, <br>            thread_id, <br>            &amp;Errno); <br>        break; <br>    case WSP_SENDTO: <br>        ReturnCode = OverlappedStruct-&gt;iolProvider-&gt;WSPSendTo( <br>            OverlappedStruct-&gt;iolProviderSocket, <br>(OverlappedStruct-&gt;iolUserBufferCount &lt;= MAX_FAST_BUFS) <br>? &amp;OverlappedStruct-&gt;iolUserBuffers[0] <br>: OverlappedStruct-&gt;iolpUserBuffers, <br>            OverlappedStruct-&gt;iolUserBufferCount, <br>            &amp;BytesTransfered, <br>            OverlappedStruct-&gt;iolFlags, <br>            OverlappedStruct-&gt;iolSockAddr, <br>            OverlappedStruct-&gt;iolSockAddrLen, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>            CompletionProc, <br>            thread_id, <br>            &amp;Errno); <br>        break; <br> <br>    case WSP_IOCTL: <br>        ReturnCode = OverlappedStruct-&gt;iolProvider-&gt;WSPIoctl( <br>            OverlappedStruct-&gt;iolProviderSocket, <br>            OverlappedStruct-&gt;iolIoControlCode, <br>            OverlappedStruct-&gt;iolInputBuffer, <br>            OverlappedStruct-&gt;iolInputBufferLength, <br>            OverlappedStruct-&gt;iolOutputBuffer, <br>            OverlappedStruct-&gt;iolOutputBufferLength, <br>            &amp;BytesTransfered, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>            CompletionProc, <br>            thread_id, <br>            &amp;Errno); <br>        break; <br>case ACCEPT_EX: <br>        ReturnCode = OverlappedStruct-&gt;iolProvider-&gt;AcceptEx ( <br>            OverlappedStruct-&gt;iolListenSocket, <br>            OverlappedStruct-&gt;iolAcceptSocket, <br>            OverlappedStruct-&gt;iolOutputBuffer, <br>            OverlappedStruct-&gt;iolOutputBufferLength, <br>            OverlappedStruct-&gt;iolLocalAddressLength, <br>            OverlappedStruct-&gt;iolRemoteAddressLength, <br>            &amp;BytesTransfered, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>            &amp;Errno); <br>break; <br>case TRANSMIT_FILE: <br>        ReturnCode = OverlappedStruct-&gt;iolProvider-&gt;TransmitFile ( <br>            OverlappedStruct-&gt;iolProviderSocket, <br>            OverlappedStruct-&gt;iolFileHandle, <br>            OverlappedStruct-&gt;iolBytesToWrite, <br>            OverlappedStruct-&gt;iolBytesPerSend, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>((OverlappedStruct-&gt;iolTransmitBuffers.HeadLength!=0) <br>|| (OverlappedStruct-&gt;iolTransmitBuffers.TailLength!=0)) <br>? &amp;OverlappedStruct-&gt;iolTransmitBuffers <br>: NULL, <br>            OverlappedStruct-&gt;iolReserved, <br>            &amp;Errno); <br>break; <br>default: <br>assert (FALSE); <br>break; <br>    } //switch <br> <br>    // Complete ourselves if provider fails right away <br>    if ((ReturnCode!=NO_ERROR) &amp;&amp; (Errno!=WSA_IO_PENDING)) <br>        OverlappedCompletionProc ( <br>            Errno, <br>            0, <br>            &amp;OverlappedStruct-&gt;iolInternalOverlappedStruct, <br>            0); <br> <br>} <br> <br>DWORD <br>WorkerThreadProc( <br>    DWORD  Context <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Thread procedure passed to CreatThread(). <br> <br>Arguments: <br> <br>    Context - Context value passed to CreateThread().  The context value is the <br>              worker thread object. <br> <br>Return Value: <br> <br>    The Return value of the worker thread <br> <br>--*/ <br> <br>{ <br>    PDWORKERTHREAD            Thread; <br>    HINSTANCE                 HModule; <br>    DWORD                     ReturnCode; <br>    HModule = LoadLibraryA (gLibraryName); <br> <br> <br>    Thread = (PDWORKERTHREAD) Context; <br>    ReturnCode = Thread-&gt;WorkerThreadProc(); <br>    delete Thread; <br>     <br>    DEBUGF( DBG_TRACE, <br>            ("Exiting worker thread.\n")); <br>    FreeLibraryAndExitThread (HModule, ReturnCode); <br>    return 0;   // Keep compiler happy <br>} <br> <br> <br> <br> <br>  <br>DWORKERTHREAD::DWORKERTHREAD() <br>/*++ <br>Routine Description: <br> <br>    Creates any internal state. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br> <br>--*/ <br> <br>{ <br>    m_exit_thread = FALSE; <br>    m_thread_count = NULL; <br>    m_wakeup_semaphore = NULL; <br>    m_completion_port = NULL; <br> <br>    InitializeCriticalSection( <br>        &amp;m_overlapped_operation_queue_lock); <br> <br>    InitializeListHead( <br>        &amp;m_overlapped_operation_queue); <br>} <br> <br>VOID <br>DWORKERTHREAD::Destroy ( <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initiates destruction of the DWORKERTHREAD object. <br>    This can't be done syncronously in destructor because this <br>    will require waiting for thread object to exit which we want <br>    to avoid. <br> <br>Arguments: <br> <br>    NONE <br> <br>Return Value: <br> <br>    NONE <br>--*/ <br>{ <br>    // If we made it through Initialize. Wake up our threads tell them to exit. <br>    if (m_thread_count&gt;0){ <br>        m_exit_thread = TRUE; <br>        if (m_completion_port) { <br>            static OVERLAPPED overlapped; <br>            PostQueuedCompletionStatus (m_completion_port, <br>                                    0, <br>                                    INVALID_SOCKET, <br>                                    &amp;overlapped <br>                                    ); <br>        } <br>        else { <br>            ReleaseSemaphore (m_wakeup_semaphore, m_thread_count, NULL); <br>        } <br>        m_thread_count = 0; <br>    } <br>} <br> <br>  <br>DWORKERTHREAD::~DWORKERTHREAD() <br>/*++ <br>Routine Description: <br> <br>    destroys any internal state. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br> <br>--*/ <br>{ <br> <br>    if (m_completion_port) { <br>        CloseHandle (m_completion_port); <br>        m_completion_port = NULL; <br>    } <br>    else if (m_wakeup_semaphore){ <br>        CloseHandle(m_wakeup_semaphore); <br>        m_wakeup_semaphore = NULL; <br>    } //if <br> <br> <br>    if (gOverlappedManager) { <br>        delete(gOverlappedManager); <br>        gOverlappedManager = NULL; <br>    } <br> <br>    DeleteCriticalSection( <br>        &amp;m_overlapped_operation_queue_lock); <br> <br> <br>    DEBUGF( DBG_TRACE, <br>            ("Destroyed worker thread object\n")); <br>} <br> <br> <br>  <br>INT <br>DWORKERTHREAD::Initialize( <br> <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initializes the DWORKERTHREAD object. <br> <br>Arguments: <br> <br>    NONE <br> <br>Return Value: <br> <br>    If no error occurs, Initialize() returns NO_ERROR.  Otherwise the value <br>    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnCode =WSAENOBUFS; <br>    DWORD           ThreadId; <br>    HANDLE          hThread; <br>    SYSTEM_INFO     info; <br>DWORDmax_threads; <br> <br>    DEBUGF( DBG_TRACE, <br>            ("Initializing worker thread \n")); <br> <br>    m_completion_port = CreateIoCompletionPort ( <br>                                INVALID_HANDLE_VALUE, <br>                                NULL, <br>                                0, <br>                                0); <br>    if (m_completion_port!=NULL) { <br>        ReturnCode = NO_ERROR; <br>// Don't need extra worker threads if we use completion <br>// port -&gt; IO will be initiated/executed in the context <br>// of the original client thread and the worker thread <br>// will only be used to receive and redirect completion  <br>// notification. <br>max_threads = 1; <br>} <br>    else { <br>        // Create the semaphore we will use to communicat with the worker thread. <br>        m_wakeup_semaphore = CreateSemaphore( <br>            NULL, <br>            0, <br>            MAXLONG, <br>            NULL); <br>        if ( m_wakeup_semaphore){ <br>GetSystemInfo (&amp;info); <br>max_threads = info.dwNumberOfProcessors; <br>            ReturnCode = NO_ERROR; <br>        } //if <br>    } // if <br> <br> <br>    if (NO_ERROR == ReturnCode){ <br>        gOverlappedManager = new DOVERLAPPEDSTRUCTMGR; <br>        if (gOverlappedManager!=NULL) { <br>            ReturnCode = gOverlappedManager-&gt;Initialize(); <br>        } <br>        else <br>            ReturnCode = WSAENOBUFS; <br>    } <br> <br>    // <br>    // Create the worker threads. <br>    // <br>    if (NO_ERROR == ReturnCode){ <br>        for (m_thread_count=0; m_thread_count&lt;max_threads; m_thread_count++) { <br>            hThread = CreateThread( <br>                NULL, <br>                0, <br>                (LPTHREAD_START_ROUTINE)::WorkerThreadProc, <br>                this, <br>                0, <br>                &amp;ThreadId); <br>            if (hThread!=NULL) <br>                CloseHandle (hThread); <br>            else <br>                break; <br>        } // for <br>if (m_thread_count&gt;0) <br>ReturnCode = NO_ERROR; <br>else <br>ReturnCode = WSAENOBUFS; <br> <br>    } //if <br> <br>    if (NO_ERROR != ReturnCode){ <br>        //Cleanup any resources we may have allocated. <br>        if (m_thread_count&gt;0){ <br>            m_exit_thread = TRUE; <br>            ReleaseSemaphore(m_wakeup_semaphore, m_thread_count, NULL); <br>        } //if <br> <br>        if (gOverlappedManager) { <br>            delete gOverlappedManager; <br>            gOverlappedManager = NULL; <br>        } <br> <br>        if (m_wakeup_semaphore) { <br>            CloseHandle (m_wakeup_semaphore); <br>            m_wakeup_semaphore = NULL; <br>        } // if <br> <br>    } //if <br> <br>    return(ReturnCode); <br>} //Initailize <br> <br> <br> <br> <br>DWORD <br>DWORKERTHREAD::WorkerThreadProc() <br>/*++ <br>Routine Description: <br> <br>    The thread procedure for this object. <br> <br>Arguments: <br> <br>    NONE <br> <br>Return Value: <br> <br>    NO_ERROR <br> <br>--*/ <br>{ <br>    INT   Errno; <br> <br>    gUpCallTable.lpWPUOpenCurrentThread( <br>        &amp;m_thread_id, <br>        &amp;Errno); <br> <br>    while (!m_exit_thread){ <br>        if (m_completion_port) { <br>            BOOL            result; <br>            LPOVERLAPPED    lpOverlapped; <br>            DWORD           key, cbTransferred; <br>            result = GetQueuedCompletionStatus ( <br>                        m_completion_port, <br>                        &amp;cbTransferred, <br>                        &amp;key, <br>                        &amp;lpOverlapped, <br>                        INFINITE <br>                        ); <br>            if (m_exit_thread) { <br>                DEBUGF (DBG_TRACE, ("Worker thread received signal to exit.\n")); <br>                break; <br>            } // if <br>            else if ((key!=-1) &amp;&amp; (lpOverlapped!=NULL)) { <br>                OverlappedCompletionProc ( <br>                    WSA_IO_PENDING, <br>                    cbTransferred, <br>                    lpOverlapped, <br>                    0); <br>            } //else if <br> <br>        } // if <br>        else { <br>            DWORD                       ReturnCode; <br>            PINTERNALOVERLAPPEDSTRUCT   OverlappedStruct; <br>            ReturnCode = WaitForSingleObjectEx( <br>                m_wakeup_semaphore, <br>                INFINITE, <br>                TRUE); <br>            if (m_exit_thread) { <br>                DEBUGF (DBG_TRACE, ("Worker thread received signal to exit.\n")); <br>                break; <br>            } // if <br>            else if (ReturnCode == WAIT_OBJECT_0){ <br> <br>                // Is there a queued overlapped operation that needs to be <br>                // initiated. <br>                OverlappedStruct = NextOverlappedOperation(); <br> <br>                if (OverlappedStruct){ <br>                    InitiateOverlappedOperation ( <br>                        OverlappedStruct, <br>                        OverlappedCompletionProc, <br>                        &amp;m_thread_id); <br>                } //if <br>            } // else if <br>        } //else <br>    } //while <br> <br>    gUpCallTable.lpWPUCloseThread( <br>        &amp;m_thread_id, <br>        &amp;Errno); <br> <br>    return(NO_ERROR); <br>} <br> <br>INT <br>DWORKERTHREAD::QueueOverlappedRecv( <br>    PDSOCKET                           Socket, <br>    LPWSABUF                           UserBuffers, <br>    DWORD                              UserBufferCount, <br>    LPDWORD                            UserBytesRecvd, <br>    LPDWORD                            UserFlags, <br>    LPWSAOVERLAPPED                    UserOverlappedStruct, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE UserCompletionRoutine, <br>    LPWSATHREADID                      UserThreadId, <br>    LPWSABUF                           InternalBuffers, <br>    DWORD                              InternalBufferCount, <br>    LPINT                              Errno <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    this routine allocates an internal overlapped structure stores its <br>    arguments in the allocated structure and enqueues the structure for the <br>    worker thread to complet the I/O operation. <br> <br>Arguments: <br> <br>    Socket      - Socket object <br> <br>    UserBuffers - The pointer to the user buffer(s). <br> <br>    UserBufferCount - The number of user buffers. <br> <br>    UserBytesRecvd - The pointer to the user BytesRecvd parameter. <br> <br>    UserFlags - A pointer to the user flags argument. <br> <br>    UserOverlappedStruct - The user overlapped struct pointer. <br> <br>    UserCompletionRoutine - The user overlapped completion routine. <br> <br>    UserThreadId - The user thread ID. <br> <br>    InternalBuffers - A pointer to our internal buffer(s). <br> <br>    InternalBufferCount - The number of internal buffers. <br> <br>    Errno - A pointer to the user errno parameter. <br> <br>Return Value: <br> <br>    NO_ERROR on success else a valid winsock2 error code. <br> <br>--*/ <br>{ <br>    INT ReturnCode; <br> <br>    PINTERNALOVERLAPPEDSTRUCT OverlappedStruct; <br> <br>    ReturnCode = SOCKET_ERROR; <br>    *Errno = WSAENOBUFS; <br> <br>    OverlappedStruct = <br>        gOverlappedManager-&gt;AllocateOverlappedStruct(); <br>    if (OverlappedStruct){ <br>OverlappedStruct-&gt;iolOperationType = WSP_RECV; <br>OverlappedStruct-&gt;iolSocket = Socket-&gt;GetSocketHandle (); <br>OverlappedStruct-&gt;iolProvider = Socket-&gt;GetDProvider(); <br>OverlappedStruct-&gt;iolProviderSocket = Socket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolUserOverlappedStruct = UserOverlappedStruct; <br>OverlappedStruct-&gt;iolUserCompletionRoutine = UserCompletionRoutine; <br>OverlappedStruct-&gt;iolUserThreadId = *UserThreadId; <br>if (UserBufferCount&lt;=MAX_FAST_BUFS) <br>memcpy (OverlappedStruct-&gt;iolUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>else { <br>OverlappedStruct-&gt;iolpUserBuffers = new WSABUF[UserBufferCount]; <br>if (OverlappedStruct-&gt;iolpUserBuffers==NULL) { <br>gOverlappedManager-&gt;FreeOverlappedStruct ( <br>&amp;OverlappedStruct-&gt;iolInternalOverlappedStruct); <br>return ReturnCode; <br>} <br>memcpy (OverlappedStruct-&gt;iolpUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>} <br>OverlappedStruct-&gt;iolUserBufferCount = UserBufferCount; <br>if (InternalBufferCount&lt;=MAX_FAST_BUFS) <br>memcpy (OverlappedStruct-&gt;iolInternalBuffers, InternalBuffers, <br>sizeof (WSABUF)*InternalBufferCount); <br>else { <br>OverlappedStruct-&gt;iolpInternalBuffers = new WSABUF[InternalBufferCount]; <br>if (OverlappedStruct-&gt;iolpInternalBuffers==NULL) { <br>if (UserBufferCount&gt;MAX_FAST_BUFS) <br>delete OverlappedStruct-&gt;iolpUserBuffers; <br>gOverlappedManager-&gt;FreeOverlappedStruct ( <br>&amp;OverlappedStruct-&gt;iolInternalOverlappedStruct); <br>return ReturnCode; <br>} <br>memcpy (OverlappedStruct-&gt;iolpInternalBuffers, InternalBuffers, <br>sizeof (WSABUF)*InternalBufferCount); <br>} <br>OverlappedStruct-&gt;iolInternalBufferCount = InternalBufferCount; <br>OverlappedStruct-&gt;iolFlags = *UserFlags; <br>        AddOverlappedOperation( <br>            Socket, <br>            OverlappedStruct); <br>        *Errno = WSA_IO_PENDING; <br> <br>    } //if <br>    return(ReturnCode); <br>} <br> <br> <br>INT <br>DWORKERTHREAD::QueueOverlappedRecvFrom( <br>    PDSOCKET                           Socket, <br>    LPWSABUF                           UserBuffers, <br>    DWORD                              UserBufferCount, <br>    LPDWORD                            UserBytesRecvd, <br>    LPDWORD                            UserFlags, <br>    struct sockaddr FAR *              UserFrom, <br>    LPINT                              UserFromLen, <br>    LPWSAOVERLAPPED                    UserOverlappedStruct, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE UserCompletionRoutine, <br>    LPWSATHREADID                      UserThreadId, <br>    LPWSABUF                           InternalBuffers, <br>    DWORD                              InternalBufferCount, <br>    LPINT                              Errno <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    this routine allocates an internal overlapped structure stores its <br>    arguments in the allocated structure and enqueues the structure for the <br>    worker thread to complet the I/O operation. <br> <br>Arguments: <br> <br>    Socket      - Socket object <br> <br>    UserBuffers - The pointer to the user buffer(s). <br> <br>    UserBufferCount - The number of user buffers. <br> <br>    UserBytesRecvd - The pointer to the user BytesRecvd parameter. <br> <br>    UserFlags - A pointer to the user flags argument. <br> <br>    UserFrom  - A pinter to the user sockaddr structure, <br> <br>    UserFromLen - A pointer to the length of UserFrom. <br> <br>    UserOverlappedStruct - The user overlapped struct pointer. <br> <br>    UserCompletionRoutine - The user overlapped completion routine. <br> <br>    UserThreadId - The user thread ID. <br> <br>    InternalBuffers - A pointer to our internal buffer(s). <br> <br>    InternalBufferCount - The number of internal buffers. <br> <br>    Errno - A pointer to the user errno parameter. <br> <br>Return Value: <br> <br>    NO_ERROR on success else a valid winsock2 error code. <br> <br>--*/ <br>{ <br>    INT                       ReturnCode; <br>    PINTERNALOVERLAPPEDSTRUCT OverlappedStruct; <br> <br>    ReturnCode = SOCKET_ERROR; <br>    *Errno = WSAENOBUFS; <br> <br>    OverlappedStruct = <br>        gOverlappedManager-&gt;AllocateOverlappedStruct(); <br>    if (OverlappedStruct){ <br>OverlappedStruct-&gt;iolOperationType = WSP_RECVFROM; <br>OverlappedStruct-&gt;iolSocket = Socket-&gt;GetSocketHandle (); <br>OverlappedStruct-&gt;iolProvider = Socket-&gt;GetDProvider(); <br>OverlappedStruct-&gt;iolProviderSocket = Socket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolUserOverlappedStruct = UserOverlappedStruct; <br>OverlappedStruct-&gt;iolUserCompletionRoutine = UserCompletionRoutine; <br>OverlappedStruct-&gt;iolUserThreadId = *UserThreadId; <br>if (UserBufferCount&lt;=MAX_FAST_BUFS) <br>memcpy (OverlappedStruct-&gt;iolUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>else { <br>OverlappedStruct-&gt;iolpUserBuffers = new WSABUF[UserBufferCount]; <br>if (OverlappedStruct-&gt;iolpUserBuffers==NULL) { <br>gOverlappedManager-&gt;FreeOverlappedStruct ( <br>&amp;OverlappedStruct-&gt;iolInternalOverlappedStruct); <br>return ReturnCode; <br>} <br>memcpy (OverlappedStruct-&gt;iolpUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>} <br>OverlappedStruct-&gt;iolUserBufferCount = UserBufferCount; <br>if (InternalBufferCount&lt;=MAX_FAST_BUFS) <br>memcpy (OverlappedStruct-&gt;iolInternalBuffers, InternalBuffers, <br>sizeof (WSABUF)*InternalBufferCount); <br>else { <br>OverlappedStruct-&gt;iolpInternalBuffers = new WSABUF[InternalBufferCount]; <br>if (OverlappedStruct-&gt;iolpInternalBuffers==NULL) { <br>if (UserBufferCount&gt;MAX_FAST_BUFS) <br>delete OverlappedStruct-&gt;iolpUserBuffers; <br>gOverlappedManager-&gt;FreeOverlappedStruct ( <br>&amp;OverlappedStruct-&gt;iolInternalOverlappedStruct); <br>return ReturnCode; <br>} <br>memcpy (OverlappedStruct-&gt;iolpInternalBuffers, InternalBuffers, <br>sizeof (WSABUF)*InternalBufferCount); <br>} <br>OverlappedStruct-&gt;iolInternalBufferCount = InternalBufferCount; <br>OverlappedStruct-&gt;iolFlags = *UserFlags; <br>        OverlappedStruct-&gt;iolSockAddr = UserFrom; <br>        OverlappedStruct-&gt;iolSockAddrLenPtr = UserFromLen; <br> <br>        AddOverlappedOperation( <br>            Socket, <br>            OverlappedStruct); <br>        *Errno = WSA_IO_PENDING; <br> <br>    } //if <br>    return(ReturnCode); <br>} <br> <br>INT <br>DWORKERTHREAD::QueueOverlappedSend( <br>    PDSOCKET                           Socket, <br>    LPWSABUF                           UserBuffers, </code></pre>
<p>
</p>
<pre><code>DWORD                              UserBufferCount, <br>    LPDWORD                            UserBytesSent, <br>    DWORD                              UserFlags, <br>    LPWSAOVERLAPPED                    UserOverlappedStruct, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE UserCompletionRoutine, <br>    LPWSATHREADID                      UserThreadId, <br>    LPINT           Errno <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    this routine allocates an internal overlapped structure stores its <br>    arguments in the allocated structure and enqueues the structure for the <br>    worker thread to complet the I/O operation. <br> <br>Arguments: <br> <br>    Socket      - Socket object <br> <br>    UserBuffers - The pointer to the user buffer(s). <br> <br>    UserBufferCount - The number of user buffers. <br> <br>    UserBytesSent - The pointer to the user BytesSent parameter. <br> <br>    UserFlags - The user flags . <br> <br>    UserOverlappedStruct - The user overlapped struct pointer. <br> <br>    UserCompletionRoutine - The user overlapped completion routine. <br> <br>    UserThreadId - The user thread ID. <br> <br>    InternalBuffers - A pointer to our internal buffer(s). <br> <br>    InternalBufferCount - The number of internal buffers. <br> <br>    Errno - A pointer to the user errno parameter. <br> <br>Return Value: <br> <br>    NO_ERROR on success else a valid winsock2 error code. <br> <br>--*/ <br>{ <br>    INT                       ReturnCode; <br>    PINTERNALOVERLAPPEDSTRUCT OverlappedStruct; <br> <br>    ReturnCode = SOCKET_ERROR; <br>    *Errno = WSAENOBUFS; <br> <br>    OverlappedStruct = <br>        gOverlappedManager-&gt;AllocateOverlappedStruct(); <br>    if (OverlappedStruct){ <br>OverlappedStruct-&gt;iolOperationType = WSP_SEND; <br>OverlappedStruct-&gt;iolSocket = Socket-&gt;GetSocketHandle (); <br>OverlappedStruct-&gt;iolProvider = Socket-&gt;GetDProvider(); <br>OverlappedStruct-&gt;iolProviderSocket = Socket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolUserOverlappedStruct = UserOverlappedStruct; <br>OverlappedStruct-&gt;iolUserCompletionRoutine = UserCompletionRoutine; <br>OverlappedStruct-&gt;iolUserThreadId = *UserThreadId; <br>if (UserBufferCount&lt;=MAX_FAST_BUFS) <br>memcpy (OverlappedStruct-&gt;iolUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>else { <br>OverlappedStruct-&gt;iolpUserBuffers = new WSABUF[UserBufferCount]; <br>if (OverlappedStruct-&gt;iolpUserBuffers==NULL) { <br>gOverlappedManager-&gt;FreeOverlappedStruct ( <br>&amp;OverlappedStruct-&gt;iolInternalOverlappedStruct); <br>return ReturnCode; <br>} <br>memcpy (OverlappedStruct-&gt;iolpUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>} <br>OverlappedStruct-&gt;iolUserBufferCount = UserBufferCount; <br>OverlappedStruct-&gt;iolFlags = UserFlags; <br> <br>        AddOverlappedOperation( <br>            Socket, <br>            OverlappedStruct); <br> <br>        *Errno = WSA_IO_PENDING; <br> <br>    } //if <br>    return(ReturnCode); <br>} <br> <br> <br>INT <br>DWORKERTHREAD::QueueOverlappedSendTo( <br>    PDSOCKET                           Socket, <br>    LPWSABUF                           UserBuffers, <br>    DWORD                              UserBufferCount, <br>    LPDWORD                            UserBytesSent, <br>    DWORD                              UserFlags, <br>    const struct sockaddr FAR *        UserTo, <br>    INT                                UserToLen, <br>    LPWSAOVERLAPPED                    UserOverlappedStruct, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE UserCompletionRoutine, <br>    LPWSATHREADID                      UserThreadId, <br>    LPINT                              Errno <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    this routine allocates an internal overlapped structure stores its <br>    arguments in the allocated structure and enqueues the structure for the <br>    worker thread to complet the I/O operation. <br> <br>Arguments: <br> <br>    Socket      - Socket object <br> <br>    UserBuffers - The pointer to the user buffer(s). <br> <br>    UserBufferCount - The number of user buffers. <br> <br>    UserBytesRecvd - The pointer to the user BytesRecvd parameter. <br> <br>    UserFlags - A pointer to the user flags argument. <br> <br>    UserTo - A pointer to the user sockaddr structure. <br> <br>    UserToLen - The length of the user sockaddr structure. <br> <br>    UserOverlappedStruct - The user overlapped struct pointer. <br> <br>    UserCompletionRoutine - The user overlapped completion routine. <br> <br>    UserThreadId - The user thread ID. <br> <br>    InternalBuffers - A pointer to our internal buffer(s). <br> <br>    InternalBufferCount - The number of internal buffers. <br> <br>    Errno - A pointer to the user errno parameter. <br> <br>Return Value: <br> <br>    NO_ERROR on success else a valid winsock2 error code. <br> <br>--*/ <br>{ <br>    INT                       ReturnCode; <br>    PINTERNALOVERLAPPEDSTRUCT OverlappedStruct; <br> <br>    ReturnCode = SOCKET_ERROR; <br>    *Errno = WSAENOBUFS; <br> <br>    OverlappedStruct = <br>        gOverlappedManager-&gt;AllocateOverlappedStruct(); <br>    if (OverlappedStruct){ <br>OverlappedStruct-&gt;iolOperationType = WSP_SENDTO; <br>OverlappedStruct-&gt;iolSocket = Socket-&gt;GetSocketHandle (); <br>OverlappedStruct-&gt;iolProvider = Socket-&gt;GetDProvider(); <br>OverlappedStruct-&gt;iolProviderSocket = Socket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolUserOverlappedStruct = UserOverlappedStruct; <br>OverlappedStruct-&gt;iolUserCompletionRoutine = UserCompletionRoutine; <br>OverlappedStruct-&gt;iolUserThreadId = *UserThreadId; <br>if (UserBufferCount&lt;=MAX_FAST_BUFS) <br>memcpy (OverlappedStruct-&gt;iolUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>else { <br>OverlappedStruct-&gt;iolpUserBuffers = new WSABUF[UserBufferCount]; <br>if (OverlappedStruct-&gt;iolpUserBuffers==NULL) { <br>gOverlappedManager-&gt;FreeOverlappedStruct ( <br>&amp;OverlappedStruct-&gt;iolInternalOverlappedStruct); <br>return ReturnCode; <br>} <br>memcpy (OverlappedStruct-&gt;iolpUserBuffers, UserBuffers, <br>sizeof (WSABUF)*UserBufferCount); <br>} <br>OverlappedStruct-&gt;iolUserBufferCount = UserBufferCount; <br>OverlappedStruct-&gt;iolFlags = UserFlags; <br>        OverlappedStruct-&gt;iolSockAddr = (struct sockaddr FAR *)UserTo; <br>        OverlappedStruct-&gt;iolSockAddrLen = UserToLen; <br> <br>        AddOverlappedOperation( <br>            Socket, <br>            OverlappedStruct); <br> <br>        *Errno = WSA_IO_PENDING; <br>    } //if <br>    return(ReturnCode); <br>} <br> <br>INT <br>DWORKERTHREAD::QueueOverlappedIoctl( <br>    PDSOCKET                           Socket, <br>    DWORD                              dwIoControlCode, <br>    LPVOID                             lpvInBuffer, <br>    DWORD                              cbInBuffer, <br>    LPVOID                             lpvOutBuffer, <br>    DWORD                              cbOutBuffer, <br>    LPDWORD                            lpcbBytesReturned, <br>    LPWSAOVERLAPPED                    UserOverlappedStruct, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE UserCompletionRoutine, <br>    LPWSATHREADID                      UserThreadId, <br>    LPINT                              Errno <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    this routine allocates an internal overlapped structure stores its <br>    arguments in the allocated structure and enqueues the structure for the <br>    worker thread to complet the I/O operation. <br> <br>Arguments: <br> <br>    Socket      - Socket object <br> <br>    UserBuffers - The pointer to the user buffer(s). <br> <br>    UserBufferCount - The number of user buffers. <br> <br>    UserBytesRecvd - The pointer to the user BytesRecvd parameter. <br> <br>    UserFlags - A pointer to the user flags argument. <br> <br>    UserTo - A pointer to the user sockaddr structure. <br> <br>    UserToLen - The length of the user sockaddr structure. <br> <br>    UserOverlappedStruct - The user overlapped struct pointer. <br> <br>    UserCompletionRoutine - The user overlapped completion routine. <br> <br>    UserThreadId - The user thread ID. <br> <br>    InternalBuffers - A pointer to our internal buffer(s). <br> <br>    InternalBufferCount - The number of internal buffers. <br> <br>    Errno - A pointer to the user errno parameter. <br> <br>Return Value: <br> <br>    NO_ERROR on success else a valid winsock2 error code. <br> <br>--*/ <br>{ <br>    INT                       ReturnCode; <br>    PINTERNALOVERLAPPEDSTRUCT OverlappedStruct; <br> <br>    ReturnCode = SOCKET_ERROR; <br>    *Errno = WSAENOBUFS; <br> <br>    OverlappedStruct = <br>        gOverlappedManager-&gt;AllocateOverlappedStruct(); <br>    if (OverlappedStruct){ <br>OverlappedStruct-&gt;iolOperationType = WSP_IOCTL; <br>OverlappedStruct-&gt;iolSocket = Socket-&gt;GetSocketHandle (); <br>OverlappedStruct-&gt;iolProvider = Socket-&gt;GetDProvider(); <br>OverlappedStruct-&gt;iolProviderSocket = Socket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolUserOverlappedStruct = UserOverlappedStruct; <br>OverlappedStruct-&gt;iolUserCompletionRoutine = UserCompletionRoutine; <br>OverlappedStruct-&gt;iolUserThreadId = *UserThreadId; <br>OverlappedStruct-&gt;iolInputBuffer = lpvInBuffer; <br>OverlappedStruct-&gt;iolInputBufferLength = cbInBuffer; <br>OverlappedStruct-&gt;iolOutputBuffer = lpvOutBuffer; <br>OverlappedStruct-&gt;iolOutputBufferLength = cbOutBuffer; <br>OverlappedStruct-&gt;iolIoControlCode = dwIoControlCode; <br> <br>        AddOverlappedOperation( <br>            Socket, <br>            OverlappedStruct); <br> <br>        *Errno = WSA_IO_PENDING; <br>    } //if <br>    return(ReturnCode); <br>} <br> <br> <br> <br>INT <br>DWORKERTHREAD::QueueOverlappedAcceptEx( <br>PDSOCKET   ListenSocket, <br>PDSOCKET   AcceptSocket, <br>LPVOID   lpOutputBuffer, <br>DWORD   dwReceiveDataLength, <br>DWORD   dwLocalAddressLength, <br>DWORD   dwRemoteAddressLength, <br>LPWSAOVERLAPPED   UserOverlappedStruct, <br>LPINT   Errno <br>) { <br>    INT                       ReturnCode; <br>    PINTERNALOVERLAPPEDSTRUCT OverlappedStruct; <br> <br>    ReturnCode = SOCKET_ERROR; <br>    *Errno = WSAENOBUFS; <br> <br>    OverlappedStruct = <br>        gOverlappedManager-&gt;AllocateOverlappedStruct(); <br>    if (OverlappedStruct){ <br>OverlappedStruct-&gt;iolOperationType = ACCEPT_EX; <br>OverlappedStruct-&gt;iolSocket = ListenSocket-&gt;GetSocketHandle (); <br>OverlappedStruct-&gt;iolProvider = ListenSocket-&gt;GetDProvider(); <br>OverlappedStruct-&gt;iolListenSocket = ListenSocket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolAcceptSocket = AcceptSocket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolUserOverlappedStruct = UserOverlappedStruct; <br>OverlappedStruct-&gt;iolUserCompletionRoutine = NULL; <br>OverlappedStruct-&gt;iolOutputBuffer = lpOutputBuffer; <br>OverlappedStruct-&gt;iolOutputBufferLength = dwReceiveDataLength; <br>OverlappedStruct-&gt;iolLocalAddressLength = dwLocalAddressLength; <br>OverlappedStruct-&gt;iolRemoteAddressLength = dwRemoteAddressLength; <br> <br>        AddOverlappedOperation( <br>            ListenSocket, <br>            OverlappedStruct); <br> <br>        *Errno = WSA_IO_PENDING; <br>    } //if <br>    return(ReturnCode); <br>} <br> <br> <br>INT <br>DWORKERTHREAD::QueueOverlappedTransmitFile( <br>PDSOCKETSocket, <br>HANDLEhFile, <br>DWORDnNumberOfBytesToWrite, <br>DWORDnNumberOfBytesPerSend, <br>LPWSAOVERLAPPEDUserOverlappedStruct, <br>LPTRANSMIT_FILE_BUFFERSlpTransmitBuffers, <br>DWORDdwReserved, <br>    LPINT                               Errno <br>) <br>{ <br>    INT                       ReturnCode; <br>    PINTERNALOVERLAPPEDSTRUCT OverlappedStruct; <br> <br>    ReturnCode = SOCKET_ERROR; <br>    *Errno = WSAENOBUFS; <br> <br>    OverlappedStruct = <br>        gOverlappedManager-&gt;AllocateOverlappedStruct(); <br>    if (OverlappedStruct){ <br>OverlappedStruct-&gt;iolOperationType = TRANSMIT_FILE; <br>OverlappedStruct-&gt;iolSocket = Socket-&gt;GetSocketHandle (); <br>OverlappedStruct-&gt;iolProvider = Socket-&gt;GetDProvider(); <br>OverlappedStruct-&gt;iolProviderSocket = Socket-&gt;GetProviderSocket (); <br>OverlappedStruct-&gt;iolUserOverlappedStruct = UserOverlappedStruct; <br>OverlappedStruct-&gt;iolUserCompletionRoutine = NULL; <br>OverlappedStruct-&gt;iolFileHandle = hFile; <br>OverlappedStruct-&gt;iolBytesToWrite = nNumberOfBytesToWrite; <br>OverlappedStruct-&gt;iolBytesPerSend = nNumberOfBytesPerSend; <br>if (lpTransmitBuffers) <br>OverlappedStruct-&gt;iolTransmitBuffers = *lpTransmitBuffers; <br>else <br>OverlappedStruct-&gt;iolTransmitBuffers.HeadLength = <br>OverlappedStruct-&gt;iolTransmitBuffers.TailLength = 0; <br> <br>OverlappedStruct-&gt;iolReserved = dwReserved; <br>        AddOverlappedOperation( <br>            Socket, <br>            OverlappedStruct); <br> <br>        *Errno = WSA_IO_PENDING; <br>    } //if <br>    return(ReturnCode); <br>} <br> <br>VOID <br>DWORKERTHREAD::AddOverlappedOperation( <br>    IN PDSOCKET                  Socket, <br>    IN PINTERNALOVERLAPPEDSTRUCT OverlappedOperation <br>    ) <br>/*++ <br>Routine Description: <br> <br>    This routine adds an internal overlapped structure to the queue of requests <br>    to be completed by the worker thread. <br> <br>Arguments: <br> <br>    Socket              - A pointer to socket object <br>    OverlappedOperation - A pointer to an internal overlapped structure that <br>                          describes the operation to be performed by the worker <br>                          thread. <br> <br>Return Value: <br> <br>    NONE <br>--*/ <br>{ <br> <br>    // If we are using completion ports or user requested <br>    // completion via APC, initiate operation in the <br>    // context of the current thread <br>    if (m_completion_port!=NULL) { <br>        if (Socket-&gt;GetCompletionContext ()==INVALID_SOCKET) { <br>            CreateIoCompletionPort ( <br>                (HANDLE)OverlappedOperation-&gt;iolProviderSocket, <br>                m_completion_port, <br>                OverlappedOperation-&gt;iolSocket, <br>                0); <br>            Socket-&gt;SetCompletionContext (OverlappedOperation-&gt;iolSocket); <br>        } <br>        InitiateOverlappedOperation ( <br>            OverlappedOperation, <br>            NULL, <br>            &amp;OverlappedOperation-&gt;iolUserThreadId); <br>    } <br>    else { <br>        EnterCriticalSection(&amp;m_overlapped_operation_queue_lock); <br>        InsertTailList( <br>            &amp;m_overlapped_operation_queue, <br>            &amp;OverlappedOperation-&gt;iolListLinkage); <br>        LeaveCriticalSection(&amp;m_overlapped_operation_queue_lock); <br>        ReleaseSemaphore (m_wakeup_semaphore, 1, NULL); <br>    } <br>} <br> <br> <br>PINTERNALOVERLAPPEDSTRUCT <br>DWORKERTHREAD::NextOverlappedOperation() <br>/*++ <br>Routine Description: <br> <br>    This routine returns the first internal overlapped structure from the queue <br>    of requests to be completed by the worker thread. <br> <br>Arguments: <br> <br>    NONE <br> <br>Return Value: <br> <br>    A pointer to an internal overlapped structure or NULL <br> <br>--*/ <br>{ <br>    PINTERNALOVERLAPPEDSTRUCT ReturnValue; <br>    PLIST_ENTRY               ListEntry; <br> <br>    ReturnValue = NULL; <br> <br>    EnterCriticalSection(&amp;m_overlapped_operation_queue_lock); <br> <br>    if (!IsListEmpty(&amp;m_overlapped_operation_queue)){ <br>        ListEntry = RemoveHeadList( <br>            &amp;m_overlapped_operation_queue); <br>        ReturnValue = CONTAINING_RECORD( <br>            ListEntry, <br>            INTERNALOVERLAPPEDSTRUCT, <br>            iolListLinkage); <br>    } //if <br> <br>    LeaveCriticalSection(&amp;m_overlapped_operation_queue_lock); <br>    return(ReturnValue); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
