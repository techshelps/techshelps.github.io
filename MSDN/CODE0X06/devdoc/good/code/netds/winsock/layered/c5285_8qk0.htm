<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LLIST.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5310"></a>LLIST.H</h2>
<pre><code>/*++ <br> <br>Module Name: <br> <br>    llist.h <br> <br>Abstract: <br> <br>    This  module  is  a  standalone  collection  of  linked-list definition and <br>    manipulation  macros  originally  defined  within  the  Windows NT <br>    development. <br> <br>--*/ <br> <br>#ifndef _LLIST_ <br>#define _LLIST_ <br>#include &lt;winsock2.h&gt; <br> <br> <br> <br>#if !defined( _WINNT_ ) <br>// <br>//  From NTDEF.H. <br>// <br> <br>//  Doubly  linked  list  structure.   Can be used as either a list head, or as <br>//  link storage within a linked-list item. <br> <br>typedef struct _LIST_ENTRY { <br>   struct _LIST_ENTRY *Flink; <br>   struct _LIST_ENTRY *Blink; <br>} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; <br> <br> <br> <br>  <br>// LONG <br>// FIELD_OFFSET( <br>//     IN &lt;typename&gt;   type, <br>//     IN &lt;fieldname&gt;  field <br>//     ); <br>#define FIELD_OFFSET(type, field)    ((LONG)&amp;(((type *)0)-&gt;field)) <br>/*++ <br> <br>Routine Description: <br> <br>    Calculates  the  byte offset of a field in a structure of type "type".  The <br>    offset is from the beginning of the containing structure. <br> <br>    Note  that  since  this macro uses compile-time type knowledge, there is no <br>    equivalent C procedure for this macro. <br> <br>Arguments: <br> <br>    type  - Supplies the type name of the containing structure. <br> <br>    field - Supplies  the  field  name  of  the  field  whose  offset  is to be <br>            computed. <br> <br>Return Value: <br> <br>    Returns  the byte offset of the named field within a structure of the named <br>    type. <br>--*/ <br> <br> <br> <br>  <br>// &lt;typename&gt; FAR * <br>// CONTAINING_RECORD( <br>//     IN PVOID       address, <br>//     IN &lt;typename&gt;  type, <br>//     IN &lt;fieldname&gt; field <br>//     ); <br>#define CONTAINING_RECORD(address, type, field) ((type FAR *)( \ <br>                                          (PCHAR)(address) - \ <br>                                          (PCHAR)(&amp;((type *)0)-&gt;field))) <br>/*++ <br> <br>Routine Description: <br> <br>    Retrieves  a  typed  pointer to a linked list item given the address of the <br>    link  storage  structure  embedded in the linked list item, the type of the <br>    linked  list  item,  and  the  field  name  of  the  embedded  link storage <br>    structure. <br> <br>    Note  that  since  this macro uses compile-time type knowledge, there is no <br>    equivalent C procedure for this macro. <br> <br>Arguments: <br> <br>    address - Supplies  the  address of a LIST_ENTRY structure embedded in an a <br>              linked list item. <br> <br>    type    - Supplies  the  type  name  of  the  containing  linked  list item <br>              structure. <br> <br>    field   - Supplies  the  field  name  if  the LIST_ENTRY structure embedded <br>              within the linked list item structure. <br> <br>Return Value: <br> <br>    Returns a pointer to the linked list item. <br>--*/ <br> <br> <br>#endif  // !defined( _WINNT_ ) <br> <br> <br>// <br>//  From NTRTL.H. <br>// <br> <br>//  Doubly-linked list manipulation routines.  Implemented as macros <br>//  but logically these are procedures. <br> <br> <br> <br>  <br>// VOID <br>// InitializeListHead( <br>//     IN PLIST_ENTRY ListHead <br>//     ); <br>#define InitializeListHead(ListHead) (\ <br>    (ListHead)-&gt;Flink = (ListHead)-&gt;Blink = (ListHead)) <br>/*++ <br> <br>Routine Description: <br> <br>    Initializes  a  PLIST_ENTRY  structure to be the head of an initially empty <br>    linked list. <br> <br>Arguments: <br> <br>    ListHead - Supplies a reference to the structure to be initialized. <br> <br>Return Value: <br> <br>    None <br>--*/ <br> <br> <br> <br>  <br>// BOOLEAN <br>// IsListEmpty( <br>//     IN PLIST_ENTRY ListHead <br>//     ); <br>#define IsListEmpty(ListHead) \ <br>    ((ListHead)-&gt;Flink == (ListHead)) <br>/*++ <br> <br>Routine Description: <br> <br>    Determines whether or not a list is empty. <br> <br>Arguments: <br> <br>    ListHead - Supplies  a  reference  to  the  head  of  the linked list to be <br>               examined. <br> <br>Return Value: <br> <br>    TRUE  - The linked list is empty. <br> <br>    FALSE - The linked list contains at least one item. <br>--*/ <br> <br> <br> <br>  <br>// PLIST_ENTRY <br>// RemoveHeadList( <br>//     IN PLIST_ENTRY ListHead <br>//     ); <br>#define RemoveHeadList(ListHead) \ <br>    (ListHead)-&gt;Flink;\ <br>    {RemoveEntryList((ListHead)-&gt;Flink)} <br>/*++ <br> <br>Routine Description: <br> <br>    Removes  the  "head" (first) item from a linked list, returning the pointer <br>    to  the  removed  entry's embedded linkage structure.  Attempting to remove <br>    the  head  item  from  a  (properly  initialized)  linked  list is a no-op, <br>    returning the pointer to the head of the linked list. <br> <br>    The  caller  may  use  the  CONTAINING_RECORD macro to amplify the returned <br>    linkage structure pointer to the containing linked list item structure. <br> <br>Arguments: <br> <br>    ListHead - Supplies  a  reference  to  the  head  of  the linked list to be <br>               operated upon. <br> <br>Return Value: <br> <br>    Returns  a pointer to the newly removed linked list item's embedded linkage <br>    structure, or the linked list head in the case of an empty list. <br>--*/ <br> <br> <br> <br>  <br>// PLIST_ENTRY <br>// RemoveTailList( <br>//     IN PLIST_ENTRY ListHead <br>//     ); <br>#define RemoveTailList(ListHead) \ <br>    (ListHead)-&gt;Blink;\ <br>    {RemoveEntryList((ListHead)-&gt;Blink)} <br>/*++ <br> <br>Routine Description: <br> <br>    Removes the "tail" (last) item from a linked list, returning the pointer to <br>    the  removed  entry's embedded linkage structure.  Attempting to remove the <br>    tail  item  from a (properly initialized) linked list is a no-op, returning <br>    the pointer to the head of the linked list. <br> <br>    The  caller  may  use  the  CONTAINING_RECORD macro to amplify the returned <br>    linkage structure pointer to the containing linked list item structure. <br> <br>Arguments: <br> <br>    ListHead - Supplies  a  reference  to  the  head  of  the linked list to be <br>               operated upon. <br> <br>Return Value: <br> <br>    Returns  a pointer to the newly removed linked list item's embedded linkage <br>    structure, or the linked list head in the case of an empty list. <br>--*/ <br> <br> <br> <br>  <br>// VOID <br>// RemoveEntryList( <br>//     IN PLIST_ENTRY Entry <br>//     ); <br>#define RemoveEntryList(Entry) {\ <br>    PLIST_ENTRY _EX_Blink;\ <br>    PLIST_ENTRY _EX_Flink;\ <br>    _EX_Flink = (Entry)-&gt;Flink;\ <br>    _EX_Blink = (Entry)-&gt;Blink;\ <br>    _EX_Blink-&gt;Flink = _EX_Flink;\ <br>    _EX_Flink-&gt;Blink = _EX_Blink;\ <br>    } <br>/*++ <br> <br>Routine Description: <br> <br>    Removes  an  item  from a linked list.  Attempting to remove the head of an <br>    empty list is a no-op. <br> <br>Arguments: <br> <br>    Entry - Supplies  a reference to the linkage structure embedded in a linked <br>            list item structure. <br> <br>Return Value: <br> <br>    None <br>--*/ <br> <br> <br> <br>  <br>// VOID <br>// InsertTailList( <br>//     IN PLIST_ENTRY ListHead, <br>//     IN PLIST_ENTRY Entry <br>//     ); <br>#define InsertTailList(ListHead,Entry) {\ <br>    PLIST_ENTRY _EX_Blink;\ <br>    PLIST_ENTRY _EX_ListHead;\ <br>    _EX_ListHead = (ListHead);\ <br>    _EX_Blink = _EX_ListHead-&gt;Blink;\ <br>    (Entry)-&gt;Flink = _EX_ListHead;\ <br>    (Entry)-&gt;Blink = _EX_Blink;\ <br>    _EX_Blink-&gt;Flink = (Entry);\ <br>    _EX_ListHead-&gt;Blink = (Entry);\ <br>    } <br>/*++ <br> <br>Routine Description: <br> <br>    Inserts a new item as the "tail" (last) item of a linked list. <br> <br>Arguments: <br> <br>    ListHead - Supplies  a  reference  to  the  head  of  the linked list to be <br>               operated upon. <br> <br>    Entry    - Supplies  a  reference  to the linkage structure embedded in the <br>               linked list item to be added to the linked list. <br> <br>Return Value: <br> <br>    None <br>--*/ <br> <br> <br> <br>  <br>// VOID <br>// InsertHeadList( <br>//     IN PLIST_ENTRY ListHead, <br>//     IN PLIST_ENTRY Entry <br>//     ); <br>#define InsertHeadList(ListHead,Entry) {\ <br>    PLIST_ENTRY _EX_Flink;\ <br>    PLIST_ENTRY _EX_ListHead;\ <br>    _EX_ListHead = (ListHead);\ <br>    _EX_Flink = _EX_ListHead-&gt;Flink;\ <br>    (Entry)-&gt;Flink = _EX_Flink;\ <br>    (Entry)-&gt;Blink = _EX_ListHead;\ <br>    _EX_Flink-&gt;Blink = (Entry);\ <br>    _EX_ListHead-&gt;Flink = (Entry);\ <br>    } <br>/*++ <br> <br>Routine Description: <br> <br>    Inserts a new item as the "head" (first) item of a linked list. <br> <br>Arguments: <br> <br>    ListHead - Supplies  a  reference  to  the  head  of  the linked list to be <br>               operated upon. <br> <br>    Entry    - Supplies  a  reference  to the linkage structure embedded in the <br>               linked list item to be added to the linked list. <br> <br>Return Value: <br> <br>    None <br>--*/ <br> <br> <br> <br>// <br>// <br>//  PSINGLE_LIST_ENTRY <br>//  PopEntryList( <br>//      PSINGLE_LIST_ENTRY ListHead <br>//      ); <br>// <br> <br>#define PopEntryList(ListHead) \ <br>    (ListHead)-&gt;Next;\ <br>    {\ <br>        PSINGLE_LIST_ENTRY FirstEntry;\ <br>        FirstEntry = (ListHead)-&gt;Next;\ <br>        if (FirstEntry != NULL) {     \ <br>            (ListHead)-&gt;Next = FirstEntry-&gt;Next;\ <br>        }                             \ <br>    } <br> <br> <br>// <br>//  VOID <br>//  PushEntryList( <br>//      PSINGLE_LIST_ENTRY ListHead, <br>//      PSINGLE_LIST_ENTRY Entry <br>//      ); <br>// <br> <br>#define PushEntryList(ListHead,Entry) \ <br>    (Entry)-&gt;Next = (ListHead)-&gt;Next; \ <br>    (ListHead)-&gt;Next = (Entry) <br> <br> <br>// Samples: <br>// <br>// // <br>// //  Define a list head. <br>// // <br>// <br>// LIST_ENTRY FooList; <br>// <br>// // <br>// //  Define a structure that will be on the list. <br>// // <br>// //  NOTE:  For debugging purposes, it usually makes life simpler to make the <br>// //  LIST_ENTRY  the  first  field  of  the  structure,  but  this  is  not a <br>// //  requirement. <br>// // <br>// <br>// typedef struct _FOO <br>// { <br>//     LIST_ENTRY FooListEntry; <br>//     . <br>//     . <br>//     . <br>// <br>// } FOO, * PFOO; <br>// <br>// // <br>// //  Initialize an empty list. <br>// // <br>// <br>// InitializeListHead( &amp;FooList ); <br>// <br>// // <br>// //  Create an object, append it to the end of the list. <br>// // <br>// <br>// PFOO foo; <br>// <br>// foo = ALLOC( sizeof(FOO) ); <br>// {check for errors, initialize FOO structure} <br>// <br>// InsertTailList( &amp;FooList, &amp;foo-&gt;FooListEntry ); <br>// <br>// // <br>// //  Scan list and delete selected items. <br>// // <br>// <br>// PFOO foo; <br>// PLIST_ENTRY listEntry; <br>// <br>// listEntry = FooList.Flink; <br>// <br>// while( listEntry != &amp;FooList ) <br>// { <br>//     foo = CONTAINING_RECORD( listEntry, <br>//                              FOO, <br>//                              FooListEntry ); <br>//     listEntry = listEntry-&gt;Flink; <br>// <br>//     if( SomeFunction( foo ) ) <br>//     { <br>//         RemoveEntryList( &amp;foo-&gt;FooListEntry ); <br>//      FREE( foo ); <br>//     } <br>// } <br>// <br>// // <br>// //  Purge all items from a list. <br>// // <br>// <br>// PFOO foo; <br>// PLIST_ENTRY listEntry; <br>// <br>// while( !IsListEmpty( &amp;FooList ) ) <br>// { <br>//     listEntry = RemoveHeadList( &amp;FooList ); <br>//     foo = CONTAINING_RECORD( listEntry, <br>//                              FOO, <br>//                              FooListEntry ); <br>// <br>//     FREE( foo ); <br>// } <br> <br> <br>#endif  // _LLIST_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
