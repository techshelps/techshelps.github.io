<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPI.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5314"></a>SPI.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br>Module Name: <br> <br>    SPI.CPP : <br> <br>Abstract: <br> <br>    Contains all the entry points for the WS2SPI.  This module implements a <br>    sample WinSock2 layered service provider. <br> <br>--*/ <br> <br>#include "precomp.h" <br> <br> <br>// The WinSock2 UpcallTable. <br>WSPUPCALLTABLEgUpCallTable; <br>LPWPUCOMPLETEOVERLAPPEDREQUESTlpWPUCompleteOverlappedRequest; <br> <br>// Variables to track Startup/Cleanup Pairing. <br>CRITICAL_SECTION  gInitCriticalSection; <br>DWORD             gStartupCount=0; <br> <br> <br>// The catalog of providers <br>PDCATALOG gProviderCatalog; <br> <br>// The worker thread for overlapped functions <br>#define UNINITIALIZED_THREAD    ((PDWORKERTHREAD)-1) <br>PDWORKERTHREAD gWorkerThread=UNINITIALIZED_THREAD; <br> <br>// The window for translation of async select messages <br>#define UNINITIALIZED_WINDOW    ((PDASYNCWINDOW)-1) <br>PDASYNCWINDOW gAsyncWindow=UNINITIALIZED_WINDOW; <br> <br>// The buffer manager for providers that modify the data stream <br>PDBUFFERMANAGER gBufferManager; <br> <br>char    gLibraryName[MAX_PATH] ="LSP.DLL"; <br> <br>#define SetBlockingProvider(Provider)\ <br>(TlsIndex!=0xFFFFFFFF)\ <br>? TlsSetValue (TlsIndex, Provider)\ <br>: NULL <br> <br>#define GetBlockingProvider()\ <br>(TlsIndex!=0xFFFFFFFF)\ <br>? TlsGetValue (TlsIndex)\ <br>: NULL <br> <br>PDASYNCWINDOW <br>GetAsyncWindow ( <br>    ) <br>/*++ <br>Routine Description: <br> <br>Gets the pointer to async window object (creates and initializes <br>the object if not already created) <br>Arguments: <br>None <br>Return Value: <br>Pointer to async window object if successfull, NULL otherwise <br> <br>--*/ <br>{ <br>// Quick check if object was already initialized (it can be NULL <br>// if we failed initialization in which case we do not <br>// want to retry) <br>    if (gAsyncWindow!=UNINITIALIZED_WINDOW) <br>        ; <br>    else { <br>        EnterCriticalSection (&amp;gInitCriticalSection); <br>// Recheck under protection of the critical section <br>        if (gAsyncWindow == UNINITIALIZED_WINDOW) { <br>            PDASYNCWINDOW   asyncWindow; <br>// Attempt to create and initialize the object <br>// If creation or initialization fails, set global object <br>// pointer to NULL to prevent further initialization attepmts <br>            asyncWindow = new DASYNCWINDOW; <br>            if (asyncWindow!=NULL) { <br>                if (asyncWindow-&gt;Initialize()==NO_ERROR) { <br>                    gAsyncWindow = asyncWindow; <br>                } <br>                else { <br>                    delete asyncWindow; <br>                    gAsyncWindow = NULL; <br>                } <br>            } <br>        } <br>        LeaveCriticalSection (&amp;gInitCriticalSection); <br>    } <br>    return gAsyncWindow; <br>} <br> <br> <br>PDWORKERTHREAD <br>GetWorkerThread ( <br>    ) <br>/*++ <br>Routine Description: <br> <br>Gets the pointer to worker thread object (creates and initializes <br>the object if not already created) <br>Arguments: <br>None <br>Return Value: <br>Pointer to worker thread object if successfull, NULL otherwise <br> <br>--*/ <br>{ <br>// Quick check if object was already initialized (it can be NULL <br>// if we failed initialization in which case we do not <br>// want to retry) <br>    if (gWorkerThread!=UNINITIALIZED_THREAD) <br>        ; <br>    else { <br>        EnterCriticalSection (&amp;gInitCriticalSection); <br>// Recheck under protection of the critical section <br>        if (gWorkerThread == UNINITIALIZED_THREAD) { <br>            PDWORKERTHREAD  workerThread; <br>// Attempt to create and initialize the object <br>// If creation or initialization fails, set global object <br>// pointer to NULL to prevent further initialization attepmts <br>            workerThread = new DWORKERTHREAD; <br>            if (workerThread!=NULL) { <br>                if (workerThread-&gt;Initialize()==NO_ERROR) { <br>                    gWorkerThread = workerThread; <br>                } <br>                else { <br>                    delete workerThread; <br>                    gWorkerThread = NULL; <br>                } <br>            } <br>        } <br>        LeaveCriticalSection (&amp;gInitCriticalSection); <br>    } <br>    return gWorkerThread; <br>} <br> <br> <br>SOCKET <br>WSPAPI <br>WSPAccept( <br>    IN SOCKET s, <br>    OUT struct sockaddr FAR *addr, <br>    OUT INT FAR *addrlen, <br>    IN LPCONDITIONPROC lpfnCondition, <br>    IN DWORD dwCallbackData, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Conditionally  accept a connection based on the return value of a condition <br>    function, and optionally create and/or join a socket group. <br> <br>Arguments: <br> <br>    s              - A  descriptor  identiying  a socket which is listening for <br>                     connections after a WSPListen(). <br> <br>    addr           - An optional pointer to a buffer which receives the address <br>                     of   the  connecting  entity,  as  known  to  the  service <br>                     provider.   The  exact  format  of  the  addr arguement is <br>                     determined  by  the  address  family  established when the <br>                     socket was created. <br> <br>    addrlen        - An  optional  pointer  to  an  integer  which contains the <br>                     length of the address addr. <br> <br>    lpfnCondition  - The  procedure  instance address of an optional, WinSock 2 <br>                     client  supplied  condition  function  which  will make an <br>                     accept/reject  decision  based  on  the caller information <br>                     passed  in  as  parameters,  and optionally creaetd and/or <br>                     join  a  socket group by assigning an appropriate value to <br>                     the result parameter of this function. <br> <br>    dwCallbackData - Callback data to be passed back to the WinSock 2 client as <br>                     a  condition  function  parameter.   This parameter is not <br>                     interpreted by the service provider. <br> <br>    lpErrno        - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPAccept() returns a value of type SOCKET which is a <br>    descriptor  for  the accepted socket.  Otherwise, a value of INVALID_SOCKET <br>    is returned, and a specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT          ReturnValue; <br>    PDPROVIDER   Provider; <br>    PDSOCKET     Socket; <br>    PDSOCKET     NewSocket; <br>    SOCKET       ProviderSocket; <br>    SOCKET       NewProviderSocket; <br>DWORD ThisProviderCatalogEntryId; <br> <br> <br>    // Debug/Trace stuff <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPAccept, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;addr, <br>                       &amp;addrlen, <br>                       &amp;lpfnCondition, <br>                       &amp;dwCallbackData, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br> <br>    if (SOCKET_ERROR != ReturnValue){ <br> <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>SetBlockingProvider (Provider); <br>        NewProviderSocket = Provider-&gt;WSPAccept( <br>            ProviderSocket, <br>            addr, <br>            addrlen, <br>            lpfnCondition, <br>            dwCallbackData, <br>            lpErrno); <br>SetBlockingProvider (NULL); <br> <br>        if (INVALID_SOCKET != NewProviderSocket){ <br> <br>            // <br>            // Create a new socket object and initialize it. <br>            NewSocket = new DSOCKET; <br>            if (NewSocket){ <br>ThisProviderCatalogEntryId =  <br>gProviderCatalog-&gt;GetLocalProvider()-&gt;GetProtocolInfo()-&gt;dwCatalogEntryId; <br> <br>                ReturnValue = gUpCallTable.lpWPUCreateSocketHandle( <br>                    ThisProviderCatalogEntryId, <br>                    (DWORD) NewSocket, <br>                    lpErrno); <br>                DEBUGF( DBG_TRACE, <br>                        ("Accept Returning Socket %X\n", ReturnValue)); <br> <br>                if (INVALID_SOCKET != ReturnValue){ <br>                    NewSocket-&gt;Initialize( <br>                        Provider, <br>                        NewProviderSocket, <br>                        Socket-&gt;GetCatalogEntryId(), <br>                        ReturnValue); <br> <br>                } //if <br>                else{ <br>                    delete NewSocket; <br>Provider-&gt;WSPCloseSocket (NewProviderSocket, lpErrno); <br>                } //else <br>            } //if <br>        } //if <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPAccept, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;addr, <br>                    &amp;addrlen, <br>                    &amp;lpfnCondition, <br>                    &amp;dwCallbackData, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>BOOL <br>PASCAL FAR <br>WSPAcceptEx ( <br>IN SOCKET sListenSocket, <br>IN SOCKET sAcceptSocket, <br>IN PVOID lpOutputBuffer, <br>IN DWORD dwReceiveDataLength, <br>IN DWORD dwLocalAddressLength, <br>IN DWORD dwRemoteAddressLength, <br>OUT LPDWORD lpdwBytesReceived, <br>IN LPOVERLAPPED lpOverlapped <br>) <br>/*++ <br>Routine Description: <br>Accepts a new connection, returns the local and remote address, <br>and receives the first block of data sent by the client application. <br> <br>Arguments: <br>sListenSocket- A descriptor identifying a socket that has  <br>already been called with the listen function.  <br>A server application waits for attempts to <br>connect on this socket. <br>sAcceptSocket- A descriptor identifying a socket on which to <br>accept an incoming connection. This socket must  <br>not be bound or connected. <br>lpOutputBuffer- A pointer to a buffer that receives the first  <br>block of data sent on a new connection, <br>the local address of the server, and the remote  <br>address of the client. The receive data is  <br>written to the first part of the buffer starting  <br>at offset zero, while the addresses are written  <br>to the latter part of the buffer. This parameter  <br>must be specified. <br>dwReceiveDataLength - The number of bytes in the buffer that will be <br>used for receiving data. If this parameter is  <br>specified as zero, then no receive operation is  <br>performed in conjunction with accepting the connection. <br>Instead, the AcceptEx function completes as soon  <br>as a connection arrives without waiting for any  <br>data. <br>dwLocalAddressLength -  The number of bytes reserved for the local <br>address information. This must be at least  <br>16 bytes more than the maximum address length  <br>for the transport protocol in use. <br>dwRemoteAddressLength - The number of bytes reserved for the remote  <br>address information. This must be at least  <br>16 bytes more than the maximum address length  <br>for the transport protocol in use.  <br>lpdwBytesReceived- A pointer to a DWORD that receives the count  <br>of bytes received. This is set only if the  <br>operation completes synchronously.  <br>If it returns ERROR_IO_PENDING and is completed  <br>later, then this DWORD is never set and you must  <br>obtain the number of bytes read from the  <br>completion notification mechanism. <br>lpOverlapped- An OVERLAPPED structure that is used to process <br>the request. This parameter must be specified; <br>it cannot be NULL. <br> <br>Return Value: <br> <br>    If no error occurs, the AcceptEx function completed successfully <br>and a value of TRUE is returned.  <br>If the function fails, AcceptEx returns FALSE. The WSAGetLastError  <br>function can then be called to return extended error information. <br>If WSAGetLastError returns ERROR_IO_PENDING, then the operation  <br>was successfully initiated and is still in progress <br> <br>--*/ <br> <br>  { <br>PDSOCKETListenSocket, AcceptSocket; <br>INTErrno, ReturnValue; <br>PDPROVIDERProvider; <br>SOCKETProviderListenSocket, ProviderAcceptSocket; <br>    // <br>    // Get our DSOCKET objects <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        sListenSocket, <br>        (DWORD*)&amp;ListenSocket, <br>        &amp;Errno); <br> <br>    if (SOCKET_ERROR != ReturnValue){ <br>ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>sAcceptSocket, <br>(DWORD*)&amp;AcceptSocket, <br>&amp;Errno); <br> <br>if (SOCKET_ERROR != ReturnValue){ <br>if (lpOverlapped) { <br>if ((lpOverlapped-&gt;hEvent==NULL) <br>|| ResetEvent ((HANDLE)((DWORD)lpOverlapped-&gt;hEvent&amp;0xFFFFFFFE))) { <br>PDWORKERTHREAD  Thread = GetWorkerThread (); <br>if (Thread!=NULL) { <br>// Setup the user overlapped struct <br>lpOverlapped-&gt;Internal = WSS_OPERATION_IN_PROGRESS; <br>lpOverlapped-&gt;InternalHigh = 0; <br>ReturnValue = Thread-&gt;QueueOverlappedAcceptEx( <br>ListenSocket, <br>AcceptSocket, <br>lpOutputBuffer, <br>dwReceiveDataLength, <br>dwLocalAddressLength, <br>dwRemoteAddressLength, <br>lpOverlapped, <br>&amp;Errno); <br>} <br>else { <br>ReturnValue = SOCKET_ERROR; <br>Errno = WSAENOBUFS; <br>} <br>} <br>else { <br>ReturnValue = SOCKET_ERROR; <br>Errno = WSA_INVALID_PARAMETER; <br>} <br>} <br>else { <br>Provider = ListenSocket-&gt;GetDProvider (); <br>ProviderListenSocket = ListenSocket-&gt;GetProviderSocket (); <br>ProviderAcceptSocket = AcceptSocket-&gt;GetProviderSocket (); <br> <br>SetBlockingProvider (Provider); <br>ReturnValue = Provider-&gt;AcceptEx ( <br>ProviderListenSocket, <br>ProviderAcceptSocket, <br>lpOutputBuffer, <br>dwReceiveDataLength, <br>dwLocalAddressLength, <br>dwRemoteAddressLength, <br>lpdwBytesReceived, <br>lpOverlapped, <br>&amp;Errno); <br>SetBlockingProvider (NULL); <br>} <br>} <br>} <br>if (ReturnValue==NO_ERROR) <br>return TRUE; <br>else { <br>SetLastError (Errno); <br>return FALSE; <br>} <br>} <br> <br> <br> <br> <br>INT <br>WSPAPI <br>WSPAddressToString( <br>    IN     LPSOCKADDR lpsaAddress, <br>    IN     DWORD dwAddressLength, <br>    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    OUT    LPWSTR lpszAddressString, <br>    IN OUT LPDWORD lpdwAddressStringLength, <br>    OUT    LPINT lpErrno ) <br>/*++ <br> <br>Routine Description: <br> <br>    WSPAddressToString() converts a SOCKADDR structure into a human-readable <br>    string representation of the address.  This is intended to be used mainly <br>    for display purposes. If the caller wishes the translation to be done by a <br>    particular provider, it should supply the corresponding WSAPROTOCOL_INFO <br>    struct in the lpProtocolInfo parameter. <br> <br>Arguments: <br> <br>    lpsaAddress - points to a SOCKADDR structure to translate into a string. <br> <br>    dwAddressLength - the length of the Address SOCKADDR. <br> <br>    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular <br>                     provider. <br> <br>    lpszAddressString - a buffer which receives the human-readable address <br>                        string. <br> <br>    lpdwAddressStringLength - on input, the length of the AddressString buffer. <br>                              On output, returns the length of  the string <br>                              actually copied into the buffer. <br> <br>Return Value: <br> <br>    The return value is 0 if the operation was successful.  Otherwise the value <br>    SOCKET_ERROR is returned <br>--*/ <br>{ <br>    INT                 ReturnValue; <br>    PDPROVIDER          Provider; <br>PPROTO_CATALOG_ITEM BaseProviderCatalogEntry; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPAddressToString, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;lpsaAddress, <br>                       &amp;dwAddressLength, <br>                       &amp;lpProtocolInfo, <br>                       &amp;lpszAddressString, <br>                       &amp;lpdwAddressStringLength, <br>                       &amp;lpErrno)) ){ <br>        return(ReturnValue); <br>    } //if <br> <br>    // <br>    // Get the catlog entry for the next provider in the chain <br>    // <br>    ReturnValue = gProviderCatalog-&gt;FindNextProviderInChain( <br>        lpProtocolInfo, <br>&amp;Provider, <br>&amp;BaseProviderCatalogEntry); <br> <br>    if (NO_ERROR == ReturnValue){ <br> <br>        // <br>        ReturnValue = Provider-&gt;WSPAddressToString( <br>            lpsaAddress, <br>            dwAddressLength, <br>            BaseProviderCatalogEntry <br>? BaseProviderCatalogEntry-&gt;GetProtocolInfo() <br>: lpProtocolInfo, <br>            lpszAddressString, <br>            lpdwAddressStringLength, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPAddressToString, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;lpsaAddress, <br>                    &amp;dwAddressLength, <br>                    &amp;lpProtocolInfo, <br>                    &amp;lpszAddressString, <br>                    &amp;lpdwAddressStringLength, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> <br> <br>INT <br>WSPAPI <br>WSPAsyncSelect( <br>    IN SOCKET s, <br>    IN HWND hWnd, <br>    IN unsigned int wMsg, <br>    IN long lEvent, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Request  Windows  message-based  event notification of network events for a <br>    socket. <br> <br>Arguments: <br> <br>    s       - A  descriptor identiying a socket for which event notification is <br>              required. <br> <br>    hWnd    - A  handle  identifying  the window which should receive a message <br>              when a network event occurs. <br> <br>    wMsg    - The message to be sent when a network event occurs. <br> <br>    lEvent  - bitmask  which specifies a combination of network events in which <br>              the WinSock client is interested. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  return  value  is 0 if the WinSock client's declaration of interest in <br>    the  netowrk event set was successful.  Otherwise the value SOCKET_ERROR is <br>    returned, and a specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPAsyncSelect, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;hWnd, <br>                       &amp;wMsg, <br>                       &amp;lEvent, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        PDASYNCWINDOW   AsyncWindow = GetAsyncWindow (); <br>        if (AsyncWindow!=NULL) { <br>            Socket-&gt;RegisterAsyncOperation( <br>                hWnd, <br>                wMsg, <br>                lEvent); <br> <br>            *lpErrno = NO_ERROR; <br>            // Register this socket with the worker thread. <br>            *lpErrno = AsyncWindow-&gt;RegisterSocket(Socket); <br> <br>            if (NO_ERROR == *lpErrno){ <br>                ReturnValue = NO_ERROR; <br>            } //if <br>            else{ <br>                ReturnValue = SOCKET_ERROR; <br>            } //else <br>        } <br>        else { <br>            ReturnValue = SOCKET_ERROR; <br>            *lpErrno = WSAENOBUFS; <br>        } <br> <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPAsyncSelect, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;hWnd, <br>                    &amp;wMsg, <br>                    &amp;lEvent, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPBind( <br>    IN SOCKET s, <br>    IN const struct sockaddr FAR *name, <br>    IN INT namelen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Associate a local address (i.e. name) with a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying an unbound socket. <br> <br>    name    - The  address  to assign to the socket.  The sockaddr structure is <br>              defined as follows: <br> <br>              struct sockaddr { <br>                  u_short sa_family; <br>                  char    sa_data[14]; <br>              }; <br> <br>              Except  for  the sa_family field, <br>sockaddr contents are epxressed <br>              in network byte order. <br> <br>    namelen - The length of the name. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If   no   erro   occurs,  WSPBind()  returns  0.   Otherwise, it  returns <br>    SOCKET_ERROR, and a specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDPROVIDER   Provider; <br>    PDSOCKET     Socket; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPBind, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpErrno)) ) { <br> <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br> <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPBind( <br>            ProviderSocket, <br>            name, <br>            namelen, <br>            lpErrno); <br> <br> <br>        POSTAPINOTIFY(( DTCODE_WSPBind, <br>                        &amp;ReturnValue, <br>                        gLibraryName, <br>                        &amp;s, <br>                        &amp;name, <br>                        &amp;namelen, <br>                        &amp;lpErrno)); <br>    } <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPCancelBlockingCall(OUT INT FAR *lpErrno) <br>/*++ <br>Routine Description: <br> <br>    Cancel a blocking call which is currently in progress. <br> <br>Arguments: <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  value  returned  by  WSPCancelBlockingCall() is 0 if the operation was <br>    successfully canceled.  Otherwise the value SOCKET_ERROR is returned, <br>and a <br>    specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>      INT ReturnValue; <br>  PDPROVIDERProvider; <br> <br>      if (PREAPINOTIFY(( DTCODE_WSPCancelBlockingCall, <br>                         &amp;ReturnValue, <br>                         gLibraryName, <br>                         &amp;lpErrno)) ) { <br>          return(ReturnValue); <br>      } <br> <br>  Provider = (PDPROVIDER)TlsGetValue (TlsIndex); <br>  if (Provider!=NULL) { <br>  ReturnValue = Provider-&gt;WSPCancelBlockingCall( <br>  lpErrno); <br>  } <br>  else { <br>  ReturnValue = SOCKET_ERROR; <br>  *lpErrno = WSAEINVAL; <br>  } <br> <br>      POSTAPINOTIFY(( DTCODE_WSPCancelBlockingCall, <br>                      &amp;ReturnValue, <br>                      gLibraryName, <br>                      &amp;lpErrno)); <br> <br>      return(ReturnValue); <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPCleanup( <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Terminate use of the WinSock service provider. <br> <br>Arguments: <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  return  value  is  0 if the operation has been successfully initiated. <br>    Otherwise  the  value SOCKET_ERROR is returned, <br>and a specific error number <br>    is available in lpErrno. <br> <br>--*/ <br> <br>{ <br>    INT          ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPCleanup, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    EnterCriticalSection(&amp;gInitCriticalSection); <br>    if (gStartupCount &gt; 0){ <br>        gStartupCount--; <br>        if (gStartupCount == 0){ <br> <br>            DEBUGF( DBG_TRACE, <br>                    ("Tearing down layered provider\n")); <br> <br>            if (gAsyncWindow!=UNINITIALIZED_WINDOW) { <br>                if (gAsyncWindow!=NULL) <br>                    //Kill the worker thread <br>                    gAsyncWindow-&gt;Destroy (); <br>                gAsyncWindow = UNINITIALIZED_WINDOW; <br>            } <br> <br>            if (gWorkerThread!=UNINITIALIZED_THREAD) { <br>                if (gWorkerThread!=NULL) <br>                    //Kill the worker thread <br>                    gWorkerThread-&gt;Destroy (); <br>                gWorkerThread = UNINITIALIZED_THREAD; <br>            } <br> <br>// To let threads wake up and figure out that <br>// they being cleaned up <br>Sleep (100); <br> <br>            DSOCKET::DSocketClassCleanup (); <br> <br>            // Kill the ProviderCatalog <br>            delete(gProviderCatalog); <br> <br>            //Kill the buffer manager <br>            delete(gBufferManager); <br>            DEBUGF( DBG_TRACE, <br>                    ("Tearing down Complete\n")); <br> <br>        } //if <br>    } //if <br>    ReturnValue = NO_ERROR; <br>    *lpErrno = NO_ERROR; <br> <br>    LeaveCriticalSection(&amp;gInitCriticalSection); <br> <br>    POSTAPINOTIFY(( DTCODE_WSPCleanup, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPCloseSocket( <br>    IN SOCKET s, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Close a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  erro  occurs, WSPCloseSocket()  returns  0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPCloseSocket, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br>        DEBUGF( DBG_TRACE, <br>                ("Closing socket %X\n",s)); <br> <br>        Socket-&gt;Remove (); <br> <br>        ReturnValue = Provider-&gt;WSPCloseSocket( <br>            ProviderSocket, <br>            lpErrno); <br> <br>if (NO_ERROR==ReturnValue) { <br>gUpCallTable.lpWPUCloseSocketHandle( <br>Socket-&gt;GetSocketHandle(), <br>lpErrno); <br> <br>delete(Socket); <br> <br>ReturnValue = NO_ERROR; <br>} <br>    } //if <br> <br> <br>    POSTAPINOTIFY(( DTCODE_WSPCloseSocket, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPConnect( <br>    IN SOCKET s, <br>    IN const struct sockaddr FAR *name, <br>    IN INT namelen, <br>    IN LPWSABUF lpCallerData, <br>    IN LPWSABUF lpCalleeData, <br>    IN LPQOS lpSQOS, <br>    IN LPQOS lpGQOS, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Establish a connection to a peer, <br>exchange connect data, <br>and specify needed <br>    quality of service based on the supplied flow spec. <br> <br>Arguments: <br> <br>    s            - A descriptor identifying an unconnected socket. <br> <br>    name         - The name of the peer to which the socket is to be connected. <br> <br>    namelen      - The length of the name. <br> <br>    lpCallerData - A  pointer to the user data that is to be transferred to the <br>                   peer during connection established. <br> <br>    lpCalleeData - A pointer to a buffer into which may be copied any user data <br>                   received from the peer during connection establishment. <br> <br>    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each <br>                   direction. <br> <br>    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if <br>                   applicable). <br> <br>    lpErrno      - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPConnect()  returns NO_ERROR.  Otherwise, it <br>    returns SOCKET_ERROR, and a specific erro rcode is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPConnect, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, </code></pre>
<p>
</p>
<pre><code>&amp;lpCallerData, <br>                       &amp;lpCalleeData, <br>                       &amp;lpSQOS, <br>                       &amp;lpGQOS, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>SetBlockingProvider (Provider); <br>        ReturnValue = Provider-&gt;WSPConnect( <br>            ProviderSocket, <br>            name, <br>            namelen, <br>            lpCallerData, <br>            lpCalleeData, <br>            lpSQOS, <br>            lpGQOS, <br>            lpErrno); <br>SetBlockingProvider (NULL); <br>    }//if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPConnect, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpCallerData, <br>                    &amp;lpCalleeData, <br>                    &amp;lpSQOS, <br>                    &amp;lpGQOS, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPDuplicateSocket( <br>    IN SOCKET s, <br>    IN DWORD dwProcessID, <br>    OUT LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    descriptor for a shared socket. <br> <br> <br>Arguments: <br> <br>    s              - Specifies the local socket descriptor. <br> <br>    dwProcessID    - Specifies  the  ID  of  the  target  process for which the <br>                     shared socket will be used. <br> <br>    lpProtocolInfo - A  pointer  to  a  buffer  allocated by the client that is <br>                     large enough to contain a WSAPROTOCOL_INFOA struct.  The <br>                     service  provider copies the protocol info struct contents <br>                     to this buffer. <br> <br>    lpErrno        - A pointer to the error code <br> <br>Return Value: <br> <br>    If  no  error  occurs, WPSDuplicateSocket()  returns zero.  Otherwise, the <br>    value of SOCKET_ERROR is returned, and a specific error number is available <br>    in lpErrno. <br> <br>--*/ <br>{ <br>    INTReturnValue=SOCKET_ERROR; <br>PDPROVIDERProvider; <br>PDSOCKETSocket; <br>SOCKETProviderSocket; <br>PPROTO_CATALOG_ITEMChainCatalogItem; <br>DWORDReserved; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPDuplicateSocket, <br>                     &amp;ReturnValue, <br>                     gLibraryName, <br>                     &amp;s, <br>                     &amp;dwProcessID, <br>                     &amp;lpProtocolInfo, <br>                     &amp;lpErrno)) ) { <br>      return(ReturnValue); <br>    } <br> <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>// Get chain catalog entry  <br>ReturnValue = gProviderCatalog-&gt;GetCatalogItemFromCatalogEntryId( <br>Socket-&gt;GetCatalogEntryId(), <br>&amp;ChainCatalogItem); <br>        if (NO_ERROR==ReturnValue) { <br>// Call next provider to duplicate its socket <br>Provider = Socket-&gt;GetDProvider(); <br>ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>ReturnValue = Provider-&gt;WSPDuplicateSocket( <br>ProviderSocket, <br>dwProcessID, <br>lpProtocolInfo, <br>lpErrno); <br>if (NO_ERROR==ReturnValue) { <br>// Replace returned protocol infor <br>// with chain protocol info and <br>// carefully restore provider reserved field. <br>Reserved = lpProtocolInfo-&gt;dwProviderReserved; <br>*lpProtocolInfo = *ChainCatalogItem-&gt;GetProtocolInfo (); <br>lpProtocolInfo-&gt;dwProviderReserved = Reserved; <br>} <br> <br> <br>        } // if <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPDuplicateSocket, <br>                  &amp;ReturnValue, <br>                  gLibraryName, <br>                  &amp;s, <br>                  &amp;dwProcessID, <br>                  &amp;lpProtocolInfo, <br>                  &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPEnumNetworkEvents( <br>    IN SOCKET s, <br>    OUT WSAEVENT hEventObject, <br>    OUT LPWSANETWORKEVENTS lpNetworkEvents, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Report occurrences of network events for the indicated socket. <br> <br>Arguments: <br> <br>    s               - A descriptor identifying the socket. <br> <br>    hEventObject    - An optional handle identifying an associated event object <br>                      to be reset. <br> <br>    lpNetworkEvents - A  pointer  to  a WSANETWORKEVENTS struct which is filled <br>                      with   a  record  of  occurred  network  events  and  any <br>                      associated error codes. <br> <br>    lpErrno         - A pointer to the error code. <br> <br>Return Value: <br> <br>    The  return  value  is  NO_ERROR  if  the  operation  was  successful. <br>    Otherwise  the  value SOCKET_ERROR is returned, and a specific error number <br>    is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPEnumNetworkEvents, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;hEventObject, <br>                       &amp;lpNetworkEvents, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPEnumNetworkEvents( <br>            ProviderSocket, <br>            hEventObject, <br>            lpNetworkEvents, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPEnumNetworkEvents, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;hEventObject, <br>                    &amp;lpNetworkEvents, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPEventSelect( <br>    IN SOCKET s, <br>    IN OUT WSAEVENT hEventObject, <br>    IN long lNetworkEvents, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Specify  an  event object to be associated with the supplied set of network <br>    events. <br> <br>Arguments: <br> <br>    s              - A descriptor identifying the socket. <br> <br>    hEventObject   - A  handle  identifying  the  event object to be associated <br>                     with the supplied set of network events. <br> <br>    lNetworkEvents - A  bitmask  which  specifies  the  combination  of network <br>                     events in which the WinSock client has interest. <br> <br>    lpErrno        - A pointer to the error code. <br> <br>Return Value: <br> <br>    The return value is 0 if the WinSock client's specification of the network <br>    events and the associated event object was successful. Otherwise the value <br>    SOCKET_ERROR is returned, and a specific error number is available in <br>    lpErrno <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPEventSelect, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;hEventObject, <br>                       &amp;lNetworkEvents, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPEventSelect( <br>            ProviderSocket, <br>            hEventObject, <br>            lNetworkEvents, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPEventSelect, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;hEventObject, <br>                    &amp;lNetworkEvents, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPGetOverlappedResult( <br>    IN SOCKET s, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPDWORD lpcbTransfer, <br>    IN BOOL fWait, <br>    OUT LPDWORD lpdwFlags, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Returns the results of an overlapped operation on the specified socket. <br> <br>Arguments: <br> <br>    s            - Identifies  the  socket.   This  is the same socket that was <br>                   specified  when  the  overlapped  operation was started by a <br>                   call to WSPRecv(), WSPRecvFrom(), WSPSend(), WSPSendTo(), or <br>                   WSPIoctl(). <br> <br>    lpOverlapped - Points to a WSAOVERLAPPED structure that was specified <br>                   when the overlapped operation was started. <br> <br>    lpcbTransfer - Points to a 32-bit variable that receives the number of <br>                   bytes that were actually transferred by a send or receive <br>                   operation, or by WSPIoctl(). <br> <br>    fWait        - Specifies  whether  the function should wait for the pending <br>                   overlapped  operation  to  complete.   If TRUE, the function <br>                   does  not return until the operation has been completed.  If <br>                   FALSE  and  the  operation  is  still  pending, the function <br>                   returns FALSE and lperrno is WSA_IO_INCOMPLETE. <br> <br>    lpdwFlags    - Points  to  a  32-bit variable that will receive one or more <br>                   flags   that  supplement  the  completion  status.   If  the <br>                   overlapped   operation   was   initiated  via  WSPRecv()  or <br>                   WSPRecvFrom(), this parameter will contain the results value <br>                   for lpFlags parameter. <br> <br>    lpErrno      - A pointer to the error code. <br> <br>Return Value: <br> <br>    If WSPGetOverlappedResult() succeeds,the return value is TRUE.  This means <br>    that the overlapped operation has completed successfully and that the value <br>    pointed  to  by lpcbTransfer has been updated.  If WSPGetOverlappedResult() <br>    returns  FALSE,  this  means  that  either the overlapped operation has not <br>    completed  or  the  overlapped operation completed but with errors, or that <br>    completion  status  could  not  be  determined due to errors in one or more <br>    parameters  to  WSPGetOverlappedResult().  On failure, the value pointed to <br>    by  lpcbTransfer  will  not be updated.  lpErrno indicates the cause of the <br>    failure (either of WSPGetOverlappedResult() or of the associated overlapped <br>    operation). <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetOverlappedResult, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpOverlapped, <br>                       &amp;lpcbTransfer, <br>                       &amp;fWait, <br>                       &amp;lpdwFlags, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    if (lpOverlapped-&gt;Internal!=WSS_OPERATION_IN_PROGRESS) { <br>        *lpcbTransfer = lpOverlapped-&gt;InternalHigh; <br>        *lpdwFlags = lpOverlapped-&gt;Offset; <br>        *lpErrno = lpOverlapped-&gt;OffsetHigh; <br>        ReturnValue = lpOverlapped-&gt;OffsetHigh==0; <br>    } <br>    else if (fWait) { <br>        ReturnValue = WaitForSingleObject (lpOverlapped-&gt;hEvent, INFINITE); <br>        if ((ReturnValue==WAIT_OBJECT_0)  <br>                &amp;&amp; (lpOverlapped-&gt;Internal!=WSS_OPERATION_IN_PROGRESS)) { <br>            *lpcbTransfer = lpOverlapped-&gt;InternalHigh; <br>            *lpdwFlags = lpOverlapped-&gt;Offset; <br>            *lpErrno = lpOverlapped-&gt;OffsetHigh; <br>            ReturnValue = lpOverlapped-&gt;OffsetHigh==0; <br>        } <br>        else { <br>            ReturnValue = FALSE; <br>            *lpErrno = WSASYSCALLFAILURE; <br>        } <br>    } <br>    else { <br>        *lpErrno = WSA_IO_PENDING; <br>        ReturnValue = FALSE; <br>    } <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetOverlappedResult, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpOverlapped, <br>                    &amp;lpcbTransfer, <br>                    &amp;fWait, <br>                    &amp;lpdwFlags, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPGetPeerName( <br>    IN SOCKET s, <br>    OUT struct sockaddr FAR *name, <br>    OUT INT FAR *namelen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Get the address of the peer to which a socket is connected. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a connected socket. <br> <br>    name    - A  pointer  to  the structure which is to receive the name of the <br>              peer. <br> <br>    namelen - A  pointer  to  an integer which, on input, indicates the size of <br>              the  structure  pointed  to  by name, and on output indicates the <br>              size of the returned name. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPGetPeerName() returns NO_ERROR.  Otherwise, a <br>    value  of  SOCKET_ERROR is returned, and a specific error code is available <br>    in lpErrno <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetPeerName, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPGetPeerName( <br>        ProviderSocket, <br>        name, <br>        namelen, <br>        lpErrno); <br> <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetPeerName, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPGetQOSByName( <br>    IN SOCKET s, <br>    IN LPWSABUF lpQOSName, <br>    IN LPQOS lpQOS, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initializes a QOS structure based on a named template. <br> <br>Arguments: <br> <br>    s         - A descriptor identifying a socket. <br> <br>    lpQOSName - Specifies the QOS template name. <br> <br>    lpQOS     - A pointer to the QOS structure to be filled. <br> <br>    lpErrno   - A pointer to the error code. <br> <br>Return Value: <br> <br>    If the function succeeds, the return value is TRUE.  If the function fails, <br>    the  return  value  is  FALSE, and  a  specific error code is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetQOSByName, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpQOSName, <br>                       &amp;lpQOS, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPGetQOSByName( <br>            ProviderSocket, <br>            lpQOSName, <br>            lpQOS, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetQOSByName, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpQOSName, <br>                    &amp;lpQOS, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPGetSockName( <br>    IN SOCKET s, <br>    OUT struct sockaddr FAR *name, <br>    OUT INT FAR *namelen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Get the local name for a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a bound socket. <br> <br>    name    - A pointer to a structure used to supply the address (name) of the <br>              socket. <br> <br>    namelen - A  pointer  to  an integer which, on input, indicates the size of <br>              the  structure  pointed  to  by name, and on output indicates the <br>              size of the returned name <br> <br>    lpErrno - A Pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPGetSockName() returns NO_ERROR.  Otherwise, a <br>    value  of  SOCKET_ERROR is returned, and a specific error code is available <br>    in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetSockName, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPGetSockName( <br>            ProviderSocket, <br>            name, <br>            namelen, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetSockName, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> INT <br>WSPAPI <br>WSPGetSockOpt( <br>    IN SOCKET s, <br>    IN INT level, <br>    IN INT optname, <br>    OUT char FAR *optval, <br>    OUT INT FAR *optlen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Retrieve a socket option. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    level   - The  level  at  which the option is defined; the supported levels <br>              include SOL_SOCKET (See annex for more protocol-specific levels.) <br> <br>    optname - The socket option for which the value is to be retrieved. <br> <br>    optval  - A  pointer  to  the  buffer  in which the value for the requested <br>              option is to be returned. <br> <br>    optlen  - A pointer to the size of the optval buffer. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs,  WSPGetSockOpt()  returns  0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPGetSockOpt, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;level, <br>                       &amp;optname, <br>                       &amp;optval, <br>                       &amp;optlen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPGetSockOpt( <br>            ProviderSocket, <br>            level, <br>            optname, <br>            optval, <br>            optlen, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPGetSockOpt, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;level, <br>                    &amp;optname, <br>                    &amp;optval, <br>                    &amp;optlen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br>INT <br>WSPAPI <br>WSPIoctl( <br>    IN SOCKET s, <br>    IN DWORD dwIoControlCode, <br>    IN LPVOID lpvInBuffer, <br>    IN DWORD cbInBuffer, <br>    IN LPVOID lpvOutBuffer, <br>    IN DWORD cbOutBuffer, <br>    IN LPDWORD lpcbBytesReturned, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Control the mode of a socket. <br> <br>Arguments: <br> <br>    s                   - Handle to a socket <br> <br>    dwIoControlCode     - Control code of operation to perform <br> <br>    lpvInBuffer         - Address of input buffer <br> <br>    cbInBuffer          - Size of input buffer <br> <br>    lpvOutBuffer        - Address of output buffer <br> <br>    cbOutBuffer         - Size of output buffer <br> <br>    lpcbBytesReturned   - A pointer to the size of output buffer's contents. <br> <br>    lpOverlapped        - Address of WSAOVERLAPPED structure <br> <br>    lpCompletionRoutine - A  pointer  to the completion routine called when the <br>                          operation has been completed. <br> <br>    lpThreadId          - A  pointer to a thread ID structure to be used by the <br>                          provider <br> <br>    lpErrno             - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no error occurs and the operation has completed immediately, WSPIoctl() <br>    returns  0.   Note  that in this case the completion routine, if specified, <br>    will  have  already  been  queued.   Otherwise, a value of SOCKET_ERROR is <br>    returned, and  a  specific  error code is available in lpErrno.  The error <br>    code  WSA_IO_PENDING  indicates  that  an  overlapped  operation  has  been <br>    successfully  initiated  and  that  conpletion will be indicated at a later <br>    time.   Any  other  error  code  indicates that no overlapped operation was <br>    initiated and no completion indication will occur. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPIoctl, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;dwIoControlCode, <br>                       &amp;lpvInBuffer, <br>                       &amp;cbInBuffer, <br>                       &amp;lpvOutBuffer, <br>                       &amp;cbOutBuffer, <br>                       &amp;lpcbBytesReturned, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        if (lpOverlapped){ <br>            if (lpCompletionRoutine <br>                    || (lpOverlapped-&gt;hEvent==NULL) <br>                    || ResetEvent ((HANDLE)((DWORD)lpOverlapped-&gt;hEvent&amp;0xFFFFFFFE))) { <br>                PDWORKERTHREAD  Thread = GetWorkerThread (); <br>                if (Thread!=NULL) { <br>                    // Setup the user overlapped struct <br>                    lpOverlapped-&gt;Internal = WSS_OPERATION_IN_PROGRESS; <br>                    lpOverlapped-&gt;InternalHigh = 0; <br>                    ReturnValue = Thread-&gt;QueueOverlappedIoctl( <br>                        Socket, <br>                        dwIoControlCode, <br>                        lpvInBuffer, <br>                        cbInBuffer, <br>                        lpvOutBuffer, <br>                        cbOutBuffer, <br>                        lpcbBytesReturned, <br>                        lpOverlapped, <br>                        lpCompletionRoutine, <br>                        lpThreadId, <br>                        lpErrno); <br>                } <br>                else { <br>                    ReturnValue = SOCKET_ERROR; <br>                    *lpErrno = WSAENOBUFS; <br>                } <br>            } <br>            else { <br>                ReturnValue = SOCKET_ERROR; <br>                *lpErrno = WSA_INVALID_PARAMETER; <br>            } <br>        } <br>        else { <br>            Provider = Socket-&gt;GetDProvider (); <br>            ProviderSocket = Socket-&gt;GetProviderSocket (); <br> <br>            ReturnValue = Provider-&gt;WSPIoctl( <br>                ProviderSocket, <br>                dwIoControlCode, <br>                lpvInBuffer, <br>                cbInBuffer, <br>                lpvOutBuffer, <br>                cbOutBuffer, <br>                lpcbBytesReturned, <br>                lpOverlapped, <br>                lpCompletionRoutine, <br>                lpThreadId, <br>                lpErrno); <br>if ((dwIoControlCode==SIO_GET_EXTENSION_FUNCTION_POINTER) <br>&amp;&amp; (NO_ERROR==ReturnValue)) { <br>ReturnValue = Provider-&gt;InterceptExtensions ( <br>lpvInBuffer, <br>lpvOutBuffer, <br>lpErrno); <br>} <br>        } <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPIoctl, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;dwIoControlCode, <br>                    &amp;lpvInBuffer, <br>                    &amp;cbInBuffer, <br>                    &amp;lpvOutBuffer, <br>                    &amp;cbOutBuffer, <br>                    &amp;lpcbBytesReturned, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br>SOCKET <br>WSPAPI <br>WSPJoinLeaf( <br>    IN SOCKET s, <br>    IN const struct sockaddr FAR *name, <br>    IN INT namelen, <br>    IN LPWSABUF lpCallerData, <br>    IN LPWSABUF lpCalleeData, <br>    IN LPQOS lpSQOS, <br>    IN LPQOS lpGQOS, <br>    IN DWORD dwFlags, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Join  a  leaf  node  into  a multipoint session, exchange connect data, and <br>    specify needed quality of service based on the supplied flow specs. <br> <br>Arguments: <br> <br>    s            - A descriptor identifying a multipoint socket. <br> <br>    name         - The name of the peer to which the socket is to be joined. <br> <br>    namelen      - The length of the name. <br> <br>    lpCallerData - A  pointer to the user data that is to be transferred to the <br>                   peer during multipoint session establishment. <br> <br>    lpCalleeData - A  pointer  to  the user data that is to be transferred back <br>                   from the peer during multipoint session establishment. <br> <br>    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each <br>                   direction. <br> <br>    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if <br>                   applicable). <br> <br>    dwFlags      - Flags  to  indicate  that  the socket is acting as a sender, <br>                   receiver, or both. <br> <br>    lpErrno      - A pointer to the error code. <br> <br>Return Value: <br> <br>    If no error occurs, WSPJoinLeaf() returns a value of type SOCKET which is a <br>    descriptor  for the newly created multipoint socket.  Otherwise,a value of <br>    INVALID_SOCKET  is  returned, and  a  specific  error code is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket, NewSocket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket, NewProviderSocket; <br>DWORD ThisProviderCatalogEntryId; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPJoinLeaf, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;name, <br>                       &amp;namelen, <br>                       &amp;lpCallerData, <br>                       &amp;lpCalleeData, <br>                       &amp;lpSQOS, <br>                       &amp;lpGQOS, <br>                       &amp;dwFlags, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        NewProviderSocket = Provider-&gt;WSPJoinLeaf( <br>            ProviderSocket, <br>            name, <br>            namelen, <br>            lpCallerData, <br>            lpCalleeData, <br>            lpSQOS, <br>            lpGQOS, <br>            dwFlags, </code></pre>
<p>
</p>
<pre><code>lpErrno); <br>if (NewProviderSocket!=INVALID_SOCKET) { <br>if (NewProviderSocket!=ProviderSocket) { <br>// <br>// Create a new socket object and initialize it. <br>NewSocket = new DSOCKET; <br>if (NewSocket){ <br>ThisProviderCatalogEntryId =  <br>gProviderCatalog-&gt;GetLocalProvider()-&gt;GetProtocolInfo()-&gt;dwCatalogEntryId; <br> <br>ReturnValue = gUpCallTable.lpWPUCreateSocketHandle( <br>ThisProviderCatalogEntryId, <br>(DWORD) NewSocket, <br>lpErrno); <br>DEBUGF( DBG_TRACE, <br>("JoinLeaf Returning Socket %X\n", ReturnValue)); <br> <br>if (INVALID_SOCKET != ReturnValue){ <br>NewSocket-&gt;Initialize( <br>Provider, <br>NewProviderSocket, <br>Socket-&gt;GetCatalogEntryId(), <br>ReturnValue); <br> <br>} //if <br>else{ <br>delete NewSocket; <br>Provider-&gt;WSPCloseSocket (NewProviderSocket, lpErrno); <br>} //else <br>} <br>} <br>else <br>ReturnValue = s; <br>} <br>else <br>ReturnValue = INVALID_SOCKET; <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPJoinLeaf, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;name, <br>                    &amp;namelen, <br>                    &amp;lpCallerData, <br>                    &amp;lpCalleeData, <br>                    &amp;lpSQOS, <br>                    &amp;lpGQOS, <br>                    &amp;dwFlags, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPListen( <br>    IN SOCKET s, <br>    IN INT backlog, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Establish a socket to listen for incoming connections. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a bound, <br>unconnected socket. <br> <br>    backlog - The  maximum length to which the queue of pending connections may <br>              grow.   If  this  value  is  SOMAXCONN, <br>then the service provider <br>              should set the backlog to a maximum "reasonable" value. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPListen()  returns  0.   Otherwise, a  value  of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPListen, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;backlog, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPListen( <br>            ProviderSocket, <br>            backlog, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPListen, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;backlog, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPRecv( <br>    IN SOCKET s, <br>    IN LPWSABUF lpBuffers, <br>    IN DWORD dwBufferCount, <br>    IN LPDWORD lpNumberOfBytesRecvd, <br>    IN OUT LPDWORD lpFlags, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Receive data on a socket. <br> <br>Arguments: <br> <br>    s                    - A descriptor identifying a connected socket. <br> <br>    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each <br>                           WSABUF  structure contains a pointer to a buffer and <br>                           the length of the buffer. <br> <br>    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers <br>                           array. <br> <br>    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this <br>                           call. <br> <br>    lpFlags              - A pointer to flags. <br> <br>    lpOverlapped         - A pointer to a WSAOVERLAPPED structure. <br> <br>    lpCompletionRoutine  - A  pointer to the completion routine called when the <br>                           receive operation has been completed. <br> <br>    lpThreadId           - A pointer to a thread ID structure to be used by the <br>                           provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno              - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and the receive operation has completed immediately, <br>    WSPRecv() returns the number of bytes received.  If the connection has been <br>    closed, it  returns  0.  Note that in this case the completion routine, if <br>    specified,  will   have  already  been  queued.   Otherwise, a  value  of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code WSA_IO_PENDING indicates that the overlapped an <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped  operations  was  initiated  and  no  completion indication will <br>    occur. <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET         Socket; <br>    PDPROVIDER       Provider; <br>    SOCKET           ProviderSocket; <br>    LPWSABUF         InternalBuffers; <br>    DWORD            InternalBufferCount; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPRecv, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;dwBufferCount, <br>                       &amp;lpNumberOfBytesRecvd, <br>                       &amp;lpFlags, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br> <br>        // Get Internal buffers to send down to the lower provider. <br>        ReturnValue = gBufferManager-&gt;AllocBuffer( <br>            lpBuffers, <br>            dwBufferCount, <br>            &amp;InternalBuffers, <br>            &amp;InternalBufferCount); <br> <br>        if (NO_ERROR == ReturnValue){ <br>            //Is this a overlapped operation. <br>            if (lpOverlapped){ <br>                if (lpCompletionRoutine <br>                        || (lpOverlapped-&gt;hEvent==NULL) <br>                        || ResetEvent ((HANDLE)((DWORD)lpOverlapped-&gt;hEvent&amp;0xFFFFFFFE))) { <br>                    PDWORKERTHREAD  Thread = GetWorkerThread (); <br>                    if (Thread!=NULL) { <br>                        // Setup the user overlapped struct <br>                        lpOverlapped-&gt;Internal = WSS_OPERATION_IN_PROGRESS; <br>                        lpOverlapped-&gt;InternalHigh = 0; <br>                        ReturnValue = Thread-&gt;QueueOverlappedRecv( <br>                            Socket, <br>                            lpBuffers, <br>                            dwBufferCount, <br>                            lpNumberOfBytesRecvd, <br>                            lpFlags, <br>                            lpOverlapped, <br>                            lpCompletionRoutine, <br>                            lpThreadId, <br>                            InternalBuffers, <br>                            InternalBufferCount, <br>                            lpErrno); <br>                    } <br>                    else { <br>                        ReturnValue = SOCKET_ERROR; <br>                        *lpErrno = WSAENOBUFS; <br>                    } <br>                } <br>                else { <br>                    ReturnValue = SOCKET_ERROR; <br>                    *lpErrno = WSA_INVALID_PARAMETER; <br>                } <br>            } //if <br>            else{ <br>                Provider = Socket-&gt;GetDProvider(); <br>                ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>SetBlockingProvider (Provider); <br>                ReturnValue = Provider-&gt;WSPRecv( <br>                    ProviderSocket, <br>                    InternalBuffers, <br>                    InternalBufferCount, <br>                    lpNumberOfBytesRecvd, <br>                    lpFlags, <br>                    lpOverlapped, <br>                    lpCompletionRoutine, <br>                    lpThreadId, <br>                    lpErrno); <br>SetBlockingProvider (NULL); <br>if (ReturnValue==NO_ERROR) { <br>gBufferManager-&gt;CopyBuffer (InternalBuffers, <br>InternalBufferCount, <br>0, <br>*lpNumberOfBytesRecvd, <br>lpBuffers, <br>dwBufferCount, <br>0); <br>} <br>gBufferManager-&gt;FreeBuffer (InternalBuffers, InternalBufferCount); <br>            } //else <br>        } //if <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPRecv, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;dwBufferCount, <br>                    &amp;lpNumberOfBytesRecvd, <br>                    &amp;lpFlags, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> INT <br>WSPAPI <br>WSPRecvDisconnect( <br>    IN SOCKET s, <br>    IN LPWSABUF lpInboundDisconnectData, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Terminate  reception  on  a socket, and retrieve the disconnect data if the <br>    socket is connection-oriented. <br> <br>Arguments: <br> <br>    s                       - A descriptor identifying a socket. <br> <br>    lpInboundDisconnectData - A  pointer to a buffer into which disconnect data <br>                              is to be copied. <br> <br>    lpErrno                 - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no error occurs, WSPRecvDisconnect() returns NO_ERROR.  Otherwise, <br>    a value of SOCKET_ERROR is returned, and a specific error code is available <br>    in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPRecvDisconnect, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpInboundDisconnectData, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br> <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPRecvDisconnect( <br>            ProviderSocket, <br>            lpInboundDisconnectData, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPRecvDisconnect, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpInboundDisconnectData, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPRecvFrom( <br>    IN  SOCKET s, <br>    IN  LPWSABUF lpBuffers, <br>    IN  DWORD dwBufferCount, <br>    IN  LPDWORD lpNumberOfBytesRecvd, <br>    IN  OUT LPDWORD lpFlags, <br>    OUT struct sockaddr FAR *  lpFrom, <br>    IN  LPINT lpFromlen, <br>    IN  LPWSAOVERLAPPED lpOverlapped, <br>    IN  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Receive a datagram and store the source address. <br> <br>Arguments: <br> <br>    s                    - A descriptor identifying a socket. <br> <br>    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each <br>                           WSABUF  structure contains a pointer to a buffer and <br>                           the length of the buffer. <br> <br>    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers <br>                           array. <br> <br>    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this <br>                           call. <br> <br>    lpFlags              - A pointer to flags. <br> <br>    lpFrom               - An  optional pointer to a buffer which will hold the <br>                           source address upon the completion of the overlapped <br>                           operation. <br> <br>    lpFromlen            - A  pointer  to the size of the from buffer, required <br>                           only if lpFrom is specified. <br> <br>    lpOverlapped         - A pointer to a WSAOVERLAPPED structure. <br> <br>    CompletionRoutine    - A  pointer to the completion routine called when the <br>                           receive operation has been completed. <br> <br>    lpThreadId           - A pointer to a thread ID structure to be used by the <br>                           provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno              - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and the receive operation has completed immediately, <br>    WSPRecvFrom()  returns the number of bytes received.  If the connection has <br>    been  closed, it returns 0.  Note that in this case the completion routine, <br>    if  specified  will  have  already  been  queued.   Otherwise,  a  value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped  operations  was  initiated  and  no  completion indication will <br>    occur. <br> <br>--*/ <br>{ <br>    INT              ReturnValue; <br>    PDSOCKET         Socket; <br>    PDPROVIDER       Provider; <br>    SOCKET           ProviderSocket; <br>    LPWSABUF         InternalBuffers; <br>    DWORD            InternalBufferCount; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPRecvFrom, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;dwBufferCount, <br>                       &amp;lpNumberOfBytesRecvd, <br>                       &amp;lpFlags, <br>                       &amp;lpFrom, <br>                       &amp;lpFromlen, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br> <br>        // Get Internal buffers to send down to the lower provider. <br>        ReturnValue = gBufferManager-&gt;AllocBuffer( <br>            lpBuffers, <br>            dwBufferCount, <br>            &amp;InternalBuffers, <br>            &amp;InternalBufferCount); <br> <br>        if (NO_ERROR == ReturnValue){ <br>            //Is this a overlapped operation. <br>            if (lpOverlapped){ <br>                if (lpCompletionRoutine <br>                        || (lpOverlapped-&gt;hEvent==NULL) <br>                        || ResetEvent ((HANDLE)((DWORD)lpOverlapped-&gt;hEvent&amp;0xFFFFFFFE))) { <br>                    PDWORKERTHREAD  Thread = GetWorkerThread (); <br>                    if (Thread!=NULL) { <br>                        // Setup the user overlapped struct <br>                        lpOverlapped-&gt;Internal = WSS_OPERATION_IN_PROGRESS; <br>                        lpOverlapped-&gt;InternalHigh = 0; <br>                        ReturnValue = Thread-&gt;QueueOverlappedRecvFrom( <br>                            Socket, <br>                            InternalBuffers, <br>                            InternalBufferCount, <br>                            lpNumberOfBytesRecvd, <br>                            lpFlags, <br>                            lpFrom, <br>                            lpFromlen, <br>                            lpOverlapped, <br>                            lpCompletionRoutine, <br>                            lpThreadId, <br>                            InternalBuffers, <br>                            InternalBufferCount, <br>                            lpErrno); <br>                    } <br>                    else { <br>                        ReturnValue = SOCKET_ERROR; <br>                        *lpErrno = WSAENOBUFS; <br>                    } <br>                } <br>                else { <br>                    ReturnValue = SOCKET_ERROR; <br>                    *lpErrno = WSA_INVALID_PARAMETER; <br>                } <br>            } //if <br>            else{ <br>                Provider = Socket-&gt;GetDProvider(); <br>                ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>SetBlockingProvider (Provider); <br>                ReturnValue = Provider-&gt;WSPRecvFrom( <br>                    ProviderSocket, <br>                    lpBuffers, <br>                    dwBufferCount, <br>                    lpNumberOfBytesRecvd, <br>                    lpFlags, <br>                    lpFrom, <br>                    lpFromlen, <br>                    lpOverlapped, <br>                    lpCompletionRoutine, <br>                    lpThreadId, <br>                    lpErrno); <br>SetBlockingProvider (NULL); <br>if (ReturnValue==NO_ERROR) { <br>gBufferManager-&gt;CopyBuffer (InternalBuffers, <br>InternalBufferCount, <br>0, <br>*lpNumberOfBytesRecvd, <br>lpBuffers, <br>dwBufferCount, <br>0); <br>} <br>gBufferManager-&gt;FreeBuffer (InternalBuffers, InternalBufferCount); <br>            } //else <br>        } //if <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPRecvFrom, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;dwBufferCount, <br>                    &amp;lpNumberOfBytesRecvd, <br>                    &amp;lpFlags, <br>                    &amp;lpFrom, <br>                    &amp;lpFromlen, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br>typedef struct association <br>{ <br>    SOCKET  ProviderSocket; <br>    SOCKET  UserSocket; <br>} SOCKETASSOCIATION, *PSOCKETASSOCIATION; <br> <br>typedef struct <br>{ <br>    UINT                AssociationCount; <br>    PSOCKETASSOCIATION  Associations; <br>} SOCKETMAP, *PSOCKETMAP; <br> <br> <br> <br>INT <br>TransferUserFdSetToProviderFdSet( <br>    IN  fd_set * UserSet, <br>    OUT fd_set * ProviderSet, <br>    OUT PSOCKETMAP SocketMap, <br>    OUT LPINT    Errno) <br>{ <br>    INT ReturnCode; <br>    UINT Index; <br>    PDSOCKET Socket; <br> <br>    ReturnCode= NO_ERROR; <br>    SocketMap-&gt;AssociationCount = 0; <br>    SocketMap-&gt;Associations     = NULL; <br>    ProviderSet-&gt;fd_count       = 0; <br> <br>    if (UserSet &amp;&amp; (UserSet-&gt;fd_count &gt; 0)){ <br>        if (UserSet-&gt;fd_count &gt; FD_SETSIZE){ <br>            *Errno = WSAENOBUFS; <br>            return(SOCKET_ERROR); <br>        } //if <br>        SocketMap-&gt;Associations = (PSOCKETASSOCIATION)new BYTE[ <br>            (sizeof(SOCKETASSOCIATION) * UserSet-&gt;fd_count)]; <br>        if (SocketMap-&gt;Associations){ <br> <br>            for (Index=0;Index &lt; UserSet-&gt;fd_count  ;Index++ ){ <br> <br>                ReturnCode = gUpCallTable.lpWPUQuerySocketHandleContext( <br>                    UserSet-&gt;fd_array[Index], <br>                    (DWORD*)&amp;Socket, <br>                    Errno); <br>                if (NO_ERROR != ReturnCode){ <br>                    delete(SocketMap-&gt;Associations); <br>                    SocketMap-&gt;Associations = NULL; <br>                    *Errno = WSAEINVAL; <br>                    break; <br>                } //if <br> <br>                SocketMap-&gt;Associations[Index].ProviderSocket = <br>                    Socket-&gt;GetProviderSocket(); <br>                SocketMap-&gt;Associations[Index].UserSocket = <br>                    UserSet-&gt;fd_array[Index]; <br>                ProviderSet-&gt;fd_array[Index] = <br>                    SocketMap-&gt;Associations[Index].ProviderSocket; <br> <br>                ProviderSet-&gt;fd_count++; <br>                SocketMap-&gt;AssociationCount++; <br>            } //for <br>        } //if <br>        else{ <br>             ReturnCode =SOCKET_ERROR; <br>            *Errno = WSAENOBUFS; <br>        } //else <br>    } //if <br>    return(ReturnCode); <br>} <br> <br>INT <br>TransferProviderFdSetToUserFdSet( <br>    IN  fd_set *   UserSet, <br>    OUT fd_set *   ProviderSet, <br>    IN  PSOCKETMAP SocketMap, <br>    OUT LPINT      Errno) <br>{ <br>    INT ReturnCode; <br>    UINT ProviderIndex; <br>    UINT AssociationIndex; <br> <br>    ReturnCode= NO_ERROR; <br> <br>    if (UserSet) { <br>        UserSet-&gt;fd_count = 0; <br>        for (ProviderIndex = 0; <br>             ProviderIndex &lt; ProviderSet-&gt;fd_count; <br>             ProviderIndex++){ <br> <br>            for (AssociationIndex =0; <br>                 AssociationIndex &lt; SocketMap-&gt;AssociationCount; <br>                 AssociationIndex++){ <br> <br>                if (ProviderSet-&gt;fd_array[ProviderIndex] == <br>                    SocketMap-&gt;Associations[AssociationIndex].ProviderSocket){ <br> <br>                    UserSet-&gt;fd_array[ProviderIndex] = <br>                        SocketMap-&gt;Associations[AssociationIndex].UserSocket; <br>                    UserSet-&gt;fd_count++; <br>                } //if <br>            } //for <br>        } //for <br>        delete SocketMap-&gt;Associations; <br>    } //if <br> <br>    return(ReturnCode); <br> <br>} <br> <br>INT <br>WSPAPI <br>WSPSelect( <br>    IN INT nfds, <br>    IN OUT fd_set FAR *readfds, <br>    IN OUT fd_set FAR *writefds, <br>    IN OUT fd_set FAR *exceptfds, <br>    IN const struct timeval FAR *timeout, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Determine the status of one or more sockets. <br> <br>Arguments: <br> <br>    nfds      - This  argument  is  ignored  and  included only for the sake of <br>                compatibility. <br> <br>    readfds   - An  optional  pointer  to  a  set  of sockets to be checked for <br>                readability. <br> <br>    writefds  - An  optional  pointer  to  a  set  of sockets to be checked for <br>                writability <br> <br>    exceptfds - An  optional  pointer  to  a  set  of sockets to be checked for <br>                errors. <br> <br>    timeout   - The  maximum  time  for  WSPSelect()  to  wait, or  NULL for a <br>                blocking operation. <br> <br>    lpErrno   - A pointer to the error code. <br> <br>Return Value: <br> <br>    WSPSelect()  returns  the  total  number of descriptors which are ready and <br>    contained  in  the  fd_set  structures, 0  if  the  time limit expired, or <br>    SOCKET_ERROR  if an error occurred.  If the return value is SOCKET_ERROR, a <br>    specific error code is available in lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDPROVIDER   Provider; <br>    SOCKET       SocketHandle; <br>    BOOL         FoundSocket=FALSE; <br>    PDSOCKET     Socket; <br>    fd_set       InternalReadfds; <br>    fd_set       InternalWritefds; <br>    fd_set       InternalExceptfds; <br>    SOCKETMAP    ReadMap; <br>    SOCKETMAP    WriteMap; <br>    SOCKETMAP    ExceptMap; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSelect, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;nfds, <br>                       &amp;readfds, <br>                       &amp;writefds, <br>                       &amp;exceptfds, <br>                       &amp;timeout, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // Look for a socket in the three fd_sets handed in. The first <br>    // socket found will be used to select the service provider to <br>    // service this call <br>    if (readfds &amp;&amp; readfds-&gt;fd_count){ <br> <br>        SocketHandle = readfds-&gt;fd_array[0]; <br>        FoundSocket = TRUE; <br>    } //if <br> <br>    if (!FoundSocket &amp;&amp; writefds &amp;&amp; writefds-&gt;fd_count ){ <br> <br>        SocketHandle = writefds-&gt;fd_array[0]; <br>        FoundSocket = TRUE; <br>    } //if <br> <br>    if (!FoundSocket &amp;&amp; exceptfds &amp;&amp; exceptfds-&gt;fd_count ){ <br> <br>        SocketHandle = exceptfds-&gt;fd_array[0]; <br>        FoundSocket = TRUE; <br>    } //if <br>    if (FoundSocket){ <br>        // <br>        // Get our DSOCKET object <br>        // <br>        ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>            SocketHandle, <br>            (DWORD*)&amp;Socket, <br>            lpErrno); <br>        if (SOCKET_ERROR != ReturnValue){ <br>            Provider = Socket-&gt;GetDProvider(); <br> <br>            TransferUserFdSetToProviderFdSet( <br>                readfds, <br>                &amp;InternalReadfds, <br>                &amp;ReadMap, <br>                lpErrno); <br>            TransferUserFdSetToProviderFdSet( <br>                writefds, <br>                &amp;InternalWritefds, <br>                &amp;WriteMap, <br>                lpErrno); <br>            TransferUserFdSetToProviderFdSet( <br>                exceptfds, <br>                &amp;InternalExceptfds, <br>                &amp;ExceptMap, <br>                lpErrno); <br>            if (NO_ERROR == *lpErrno){ <br>SetBlockingProvider (Provider); <br>                ReturnValue = Provider-&gt;WSPSelect( <br>                    nfds, <br>                    &amp;InternalReadfds, <br>                    &amp;InternalWritefds, <br>                    &amp;InternalExceptfds, <br>                    timeout, <br>                    lpErrno); <br>SetBlockingProvider (NULL); <br>                TransferProviderFdSetToUserFdSet( <br>                    readfds, <br>                    &amp;InternalReadfds, <br>                    &amp;ReadMap, <br>                    lpErrno); <br>                TransferProviderFdSetToUserFdSet( <br>                    writefds, <br>                    &amp;InternalWritefds, <br>                    &amp;WriteMap, <br>                    lpErrno); <br>                TransferProviderFdSetToUserFdSet( <br>                    exceptfds, <br>                    &amp;InternalExceptfds, <br>                    &amp;ExceptMap, <br>                    lpErrno); <br>                DEBUGF( DBG_TRACE, <br>                        ("Select Returns %X\n",ReturnValue)); <br> <br>            } //if <br>            else{ <br>                DEBUGF( DBG_TRACE, <br>                        ("**Select failed**\n")); <br> <br>                ReturnValue = SOCKET_ERROR; <br>            } //else <br>        } <br>    } //if <br>    else{ <br>        ReturnValue = SOCKET_ERROR; <br>        *lpErrno    = WSAEINVAL; <br>    } //else/if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSelect, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;nfds, <br>                    &amp;readfds, <br>                    &amp;writefds, <br>                    &amp;exceptfds, <br>                    &amp;timeout, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> <br> INT <br>WSPAPI <br>WSPSend( <br>    IN SOCKET s, <br>    IN LPWSABUF lpBuffers, <br>    IN DWORD dwBufferCount, <br>    IN LPDWORD lpNumberOfBytesSent, <br>    IN DWORD dwFlags, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Send data on a connected socket. <br> <br>Arguments: <br> <br>    s                   - A descriptor identifying a connected socket. <br> <br>    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each <br>                          WSABUF  structure  contains a pointer to a buffer and <br>                          the length of the buffer. <br> <br>    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers <br>                          array. <br> <br>    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call. <br> <br>    dwFlags             - Flags. <br> <br>    lpOverlapped        - A pointer to a WSAOVERLAPPED structure. <br> <br>    lpCompletionRoutine - A  pointer  to the completion routine called when the <br>                          send operation has been completed. <br> <br>    lpThreadId          - A  pointer to a thread ID structure to be used by the <br>                          provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno             - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and  the  send  operation has completed immediately, <br>    WSPSend() returns the number of bytes received.  If the connection has been <br>    closed,  it  returns  0.  Note that in this case the completion routine, if <br>    specified, will   have  already  been  queued.   Otherwise, a  value  of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped operation was initiated and no completion indication will occur. <br> <br>--*/ <br>{ <br>    INT              ReturnValue; <br>    PDSOCKET         Socket; <br>    PDPROVIDER       Provider; <br>    SOCKET           ProviderSocket; <br>    LPWSABUF         InternalBuffers; <br>    DWORD            InternalBufferCount; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSend, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;dwBufferCount, </code></pre>
<p>
</p>
<pre><code>&amp;lpNumberOfBytesSent, <br>                       &amp;dwFlags, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br> <br>        // Get Internal buffers to send down to the lower provider. <br>        ReturnValue = gBufferManager-&gt;AllocBuffer( <br>            lpBuffers, <br>            dwBufferCount, <br>            &amp;InternalBuffers, <br>            &amp;InternalBufferCount); <br> <br>        if (NO_ERROR == ReturnValue){ <br>            // Copy the user buffers <br>            ReturnValue = gBufferManager-&gt;CopyBuffer( <br>                lpBuffers, <br>                dwBufferCount, <br>0, <br>0xFFFFFFFF,// Max bytes to copy <br>                InternalBuffers, <br>                InternalBufferCount, <br>                0); <br>        } //if <br> <br>        if (NO_ERROR == ReturnValue){ <br>            //Is this a overlapped operation. <br>            if (lpOverlapped){ <br>                if (lpCompletionRoutine <br>                        || (lpOverlapped-&gt;hEvent==NULL) <br>                        || ResetEvent ((HANDLE)((DWORD)lpOverlapped-&gt;hEvent&amp;0xFFFFFFFE))) { <br>                    PDWORKERTHREAD  Thread = GetWorkerThread (); <br>                    if (Thread!=NULL) { <br>                        // Setup the user overlapped struct <br>                        lpOverlapped-&gt;Internal = WSS_OPERATION_IN_PROGRESS; <br>                        lpOverlapped-&gt;InternalHigh = 0; <br>                        ReturnValue = Thread-&gt;QueueOverlappedSend( <br>                                Socket, <br>                                InternalBuffers, <br>                                InternalBufferCount, <br>                                lpNumberOfBytesSent, <br>                                dwFlags, <br>                                lpOverlapped, <br>                                lpCompletionRoutine, <br>                                lpThreadId, <br>                                lpErrno); <br>                    } <br>                    else { <br>                        ReturnValue = SOCKET_ERROR; <br>                        *lpErrno = WSAENOBUFS; <br>                    } <br>                } <br>                else { <br>                    ReturnValue = SOCKET_ERROR; <br>                    *lpErrno = WSA_INVALID_PARAMETER; <br>                } <br> <br>            } //if <br>            else{ <br>                Provider = Socket-&gt;GetDProvider(); <br>                ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>SetBlockingProvider (Provider); <br>                ReturnValue = Provider-&gt;WSPSend( <br>                    ProviderSocket, <br>                    InternalBuffers, <br>                    InternalBufferCount, <br>                    lpNumberOfBytesSent, <br>                    dwFlags, <br>                    lpOverlapped, <br>                    lpCompletionRoutine, <br>                    lpThreadId, <br>                    lpErrno); <br>SetBlockingProvider (NULL); <br>gBufferManager-&gt;FreeBuffer (InternalBuffers, InternalBufferCount); <br>            } //else <br>        } //if <br>    } //if <br>    POSTAPINOTIFY(( DTCODE_WSPSend, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;dwBufferCount, <br>                    &amp;lpNumberOfBytesSent, <br>                    &amp;dwFlags, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> INT <br>WSPAPI <br>WSPSendDisconnect( <br>    IN SOCKET s, <br>    IN LPWSABUF lpOutboundDisconnectData, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initiate  termination  of the connection for the socket and send disconnect <br>    data. <br> <br>Arguments: <br> <br>    s                        - A descriptor identifying a socket. <br> <br>    lpOutboundDisconnectData - A pointer to the outgoing disconnect data. <br> <br>    lpErrno                  - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error occurs, WSPSendDisconnect() returns 0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSendDisconnect, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpOutboundDisconnectData, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPSendDisconnect( <br>            ProviderSocket, <br>            lpOutboundDisconnectData, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSendDisconnect, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpOutboundDisconnectData, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPSendTo( <br>    IN SOCKET s, <br>    IN LPWSABUF lpBuffers, <br>    IN DWORD dwBufferCount, <br>    IN LPDWORD lpNumberOfBytesSent, <br>    IN DWORD dwFlags, <br>    IN const struct sockaddr FAR *  lpTo, <br>    IN INT iTolen, <br>    IN LPWSAOVERLAPPED lpOverlapped, <br>    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    IN LPWSATHREADID lpThreadId, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Send data to a specific destination using overlapped I/O. <br> <br>Arguments: <br> <br>    s                   - A descriptor identifying a socket. <br> <br>    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each <br>                          WSABUF  structure  contains a pointer to a buffer and <br>                          the length of the buffer. <br> <br>    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers <br>                          array. <br> <br>    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call. <br> <br>    dwFlags             - Flags. <br> <br>    lpTo                - An  optional  pointer  to  the  address of the target <br>                          socket. <br> <br>    iTolen              - The size of the address in lpTo. <br> <br>    lpOverlapped        - A pointer to a WSAOVERLAPPED structure. <br> <br>    lpCompletionRoutine - A  pointer  to the completion routine called when the <br>                          send operation has been completed. <br> <br>    lpThreadId          - A  pointer to a thread ID structure to be used by the <br>                          provider in a subsequent call to WPUQueueApc(). <br> <br>    lpErrno             - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs  and the receive operation has completed immediately, <br>    WSPSendTo()  returns  the  number of bytes received.  If the connection has <br>    been  closed,it returns 0.  Note that in this case the completion routine, <br>    if  specified, will  have  already  been  queued.   Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped <br>    operation  has  been  successfully  initiated  and  that completion will be <br>    indicated  at  a  later  time.   Any  other  error  code  indicates that no <br>    overlapped operation was initiated and no completion indication will occur. <br> <br>--*/ <br> <br> <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br>    LPWSABUF     InternalBuffers; <br>    DWORD        InternalBufferCount; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSendTo, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;lpBuffers, <br>                       &amp;lpNumberOfBytesSent, <br>                       &amp;dwFlags, <br>                       &amp;lpTo, <br>                       &amp;iTolen, <br>                       &amp;lpOverlapped, <br>                       &amp;lpCompletionRoutine, <br>                       &amp;lpThreadId, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        // Get Internal buffers to send down to the lower provider. <br>        ReturnValue = gBufferManager-&gt;AllocBuffer( <br>            lpBuffers, <br>            dwBufferCount, <br>            &amp;InternalBuffers, <br>            &amp;InternalBufferCount); <br> <br>        if (NO_ERROR == ReturnValue){ <br>            // Copy the user buffers <br>            ReturnValue = gBufferManager-&gt;CopyBuffer( <br>                lpBuffers, <br>                dwBufferCount, <br>0, <br>0xFFFFFFFF,// Max bytes to copy <br>                InternalBuffers, <br>                InternalBufferCount, <br>                0); <br>        } //if <br> <br>        if (NO_ERROR == ReturnValue){ <br>            //Is this a overlapped operation. <br>            if (lpOverlapped){ <br>                if (lpCompletionRoutine <br>                        || (lpOverlapped-&gt;hEvent==NULL) <br>                        || ResetEvent ((HANDLE)((DWORD)lpOverlapped-&gt;hEvent&amp;0xFFFFFFFE))) { <br>                    PDWORKERTHREAD  Thread = GetWorkerThread (); <br>                    if (Thread!=NULL) { <br>                        // Setup the user overlapped struct <br>                        lpOverlapped-&gt;Internal = WSS_OPERATION_IN_PROGRESS; <br>                        lpOverlapped-&gt;InternalHigh = 0; <br>                        ReturnValue = Thread-&gt;QueueOverlappedSendTo( <br>                            Socket, <br>                            InternalBuffers, <br>                            InternalBufferCount, <br>                            lpNumberOfBytesSent, <br>                            dwFlags, <br>                            lpTo, <br>                            iTolen, <br>                            lpOverlapped, <br>                            lpCompletionRoutine, <br>                            lpThreadId, <br>                            lpErrno); <br>                    } <br>                    else { <br>                        ReturnValue = SOCKET_ERROR; <br>                        *lpErrno = WSAENOBUFS; <br>                    } <br>                } <br>                else { <br>                    ReturnValue = SOCKET_ERROR; <br>                    *lpErrno = WSA_INVALID_PARAMETER; <br>                } <br>            } //if <br>            else{ <br>                Provider = Socket-&gt;GetDProvider(); <br>                ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>SetBlockingProvider (Provider); <br>                ReturnValue = Provider-&gt;WSPSendTo( <br>                    ProviderSocket, <br>                    lpBuffers, <br>                    dwBufferCount, <br>                    lpNumberOfBytesSent, <br>                    dwFlags, <br>                    lpTo, <br>                    iTolen, <br>                    lpOverlapped, <br>                    lpCompletionRoutine, <br>                    lpThreadId, <br>                    lpErrno); <br>SetBlockingProvider (NULL); <br>gBufferManager-&gt;FreeBuffer (InternalBuffers, InternalBufferCount); <br>            } //else <br>        } //if <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSendTo, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;lpBuffers, <br>                    &amp;lpNumberOfBytesSent, <br>                    &amp;dwFlags, <br>                    &amp;lpTo, <br>                    &amp;iTolen, <br>                    &amp;lpOverlapped, <br>                    &amp;lpCompletionRoutine, <br>                    &amp;lpThreadId, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> INT <br>WSPAPI <br>WSPSetSockOpt( <br>    IN SOCKET s, <br>    IN INT level, <br>    IN INT optname, <br>    IN const char FAR *optval, <br>    IN INT optlen, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Set a socket option. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    level   - The  level  at  which the option is defined; the supported levels <br>              include   SOL_SOCKET.   (See  annex  for  more  protocol-specific <br>              levels.) <br> <br>    optname - The socket option for which the value is to be set. <br> <br>    optval  - A  pointer  to  the  buffer  in which the value for the requested <br>              option is supplied. <br> <br>    optlen  - The size of the optval buffer. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPSetSockOpt()  returns  0.  Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPSetSockOpt, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;level, <br>                       &amp;optname, <br>                       &amp;optval, <br>                       &amp;optlen, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br> <br>        ReturnValue = Provider-&gt;WSPSetSockOpt( <br>            ProviderSocket, <br>            level, <br>            optname, <br>            optval, <br>            optlen, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPSetSockOpt, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;level, <br>                    &amp;optname, <br>                    &amp;optval, <br>                    &amp;optlen, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>INT <br>WSPAPI <br>WSPShutdown( <br>    IN SOCKET s, <br>    IN INT how, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Disable sends and/or receives on a socket. <br> <br>Arguments: <br> <br>    s       - A descriptor identifying a socket. <br> <br>    how     - A  flag  that describes what types of operation will no longer be <br>              allowed. <br> <br>    lpErrno - A pointer to the error code. <br> <br>Return Value: <br> <br>    If  no  error  occurs, WSPShutdown()  returns  0.   Otherwise, a value of <br>    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in <br>    lpErrno. <br> <br>--*/ <br>{ <br>    INT ReturnValue; <br>    PDSOCKET     Socket; <br>    PDPROVIDER   Provider; <br>    SOCKET       ProviderSocket; <br> <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPShutdown, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;s, <br>                       &amp;how, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        s, <br>        (DWORD*)&amp;Socket, <br>        lpErrno); <br>    if (SOCKET_ERROR != ReturnValue){ <br>        Provider = Socket-&gt;GetDProvider(); <br>        ProviderSocket = Socket-&gt;GetProviderSocket(); <br>        DEBUGF( DBG_TRACE, <br>                ("Shutdown socket %X\n",s)); <br> <br>        ReturnValue = Provider-&gt;WSPShutdown( <br>            ProviderSocket, <br>            how, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPShutdown, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;s, <br>                    &amp;how, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br>SOCKET <br>WSPAPI <br>WSPSocket( <br>    IN int af, <br>    IN int type, <br>    IN int protocol, <br>    IN LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    IN GROUP g, <br>    IN DWORD dwFlags, <br>    OUT INT FAR *lpErrno <br>    ) <br>/*++ <br>Routine Description: <br> <br>    Initialize  internal  data  and  prepare sockets for usage.  Must be called <br>    before any other socket routine. <br> <br>Arguments: <br> <br>    lpProtocolInfo - Supplies  a pointer to a WSAPROTOCOL_INFOA struct that <br>                     defines  the characteristics of the socket to be created. <br> <br>    g              - Supplies  the identifier of the socket group which the new <br>                     socket is to join. <br> <br>    dwFlags        - Supplies the socket attribute specification. <br> <br>    lpErrno        - Returns the error code <br> <br>Return Value: <br> <br>    WSPSocket() returns zero if successful.  Otherwise it returns an error code <br>    as outlined in the SPI. <br> <br>--*/ <br>{ <br>    INT                 ReturnValue; <br>    INT                 NextProviderSocket; <br>    PDPROVIDER          Provider; <br>    PDSOCKET            Socket; <br>DWORDThisProviderCatalogEntryId; <br>PPROTO_CATALOG_ITEMBaseProviderCatalogEntry; <br> <br>    // Debug/Trace stuff <br>    if (PREAPINOTIFY(( DTCODE_WSPSocket, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;af, <br>                       &amp;type, <br>                       &amp;protocol, <br>                       &amp;lpProtocolInfo, <br>                       &amp;g, <br>                       &amp;dwFlags, <br>                       &amp;lpErrno)) ) { <br>        return(ReturnValue); <br>    } <br> <br> <br>    // <br>    // Get the catlog entry for the next provider in the chain <br>    // <br>    ReturnValue = gProviderCatalog-&gt;FindNextProviderInChain( <br>        lpProtocolInfo, <br>        &amp;Provider, <br>&amp;BaseProviderCatalogEntry); <br> <br>if (NO_ERROR==ReturnValue) { <br>WSAPROTOCOL_INFOWProtocolInfo; <br>LPWSAPROTOCOL_INFOWlpPassedInfo; <br> <br>// If next provider is base, get it its own protocol info <br>if (BaseProviderCatalogEntry) { <br>ProtocolInfo = *BaseProviderCatalogEntry-&gt;GetProtocolInfo(); <br>// Carefully restore reserved field. <br>ProtocolInfo.dwProviderReserved = lpProtocolInfo-&gt;dwProviderReserved; <br>lpPassedInfo = &amp;ProtocolInfo; <br>} <br>else <br>lpPassedInfo = lpProtocolInfo; <br> <br>        ReturnValue = Provider-&gt;WSPSocket( <br>            af, <br>            type, <br>            protocol, <br>lpPassedInfo, <br>            g, <br>            dwFlags, <br>            lpErrno); <br> <br>if (ReturnValue != INVALID_SOCKET){ <br>NextProviderSocket = ReturnValue; <br> <br>// <br>// Create our socket object <br>// <br> <br>Socket = new DSOCKET; <br>if (Socket){ <br>ThisProviderCatalogEntryId =  <br>gProviderCatalog-&gt;GetLocalProvider()-&gt;GetProtocolInfo()-&gt;dwCatalogEntryId; <br> <br>ReturnValue = gUpCallTable.lpWPUCreateSocketHandle( <br>ThisProviderCatalogEntryId, <br>(DWORD) Socket, <br>lpErrno); <br>DEBUGF( DBG_TRACE, <br>("Socket Returning Socket %X\n", ReturnValue)); <br> <br>if (INVALID_SOCKET != ReturnValue){ <br>Socket-&gt;Initialize( <br>Provider, <br>NextProviderSocket, <br>lpProtocolInfo-&gt;dwCatalogEntryId, <br>ReturnValue); <br> <br>                } //if <br>                else{ <br>                    delete(Socket); <br>                } //else <br>            } //if <br>        } //if <br>        else{ <br>            *lpErrno = ReturnValue; <br>            ReturnValue = INVALID_SOCKET; <br>        } //else <br>    } //if <br>    else{ <br>        *lpErrno = ReturnValue; <br>        ReturnValue = INVALID_SOCKET; <br>    } //else <br> <br>    // Debug/Trace stuff <br>    POSTAPINOTIFY(( DTCODE_WSPSocket, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;af, <br>                    &amp;type, <br>                    &amp;protocol, <br>                    &amp;lpProtocolInfo, <br>                    &amp;g, <br>                    &amp;dwFlags, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br>} <br> <br> <br> <br> <br>INT <br>WSPAPI <br>WSPStringToAddress( <br>    IN     LPWSTR AddressString, <br>    IN     INT AddressFamily, <br>    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    OUT    LPSOCKADDR lpAddress, <br>    IN OUT LPINT lpAddressLength, <br>    IN OUT LPINT lpErrno ) <br>/*++ <br> <br>Routine Description: <br> <br>    WSPStringToAddress() converts a human-readable string to a socket address <br>    structure (SOCKADDR) suitable for pass to Windows Sockets routines which <br>    take such a structure.  If the caller wishes the translation to be done by <br>    a particular provider, it should supply the corresponding WSAPROTOCOL_INFO <br>    struct in the lpProtocolInfo parameter. <br> <br>Arguments: <br> <br>    AddressString - points to the zero-terminated human-readable string to <br>                    convert. <br> <br>    AddressFamily - the address family to which the string belongs. <br> <br>    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular <br>                     provider. <br> <br>    Address - a buffer which is filled with a single SOCKADDR structure. <br> <br>    lpAddressLength - The length of the Address buffer.  Returns the size of <br>                      the resultant SOCKADDR structure. <br> <br>Return Value: <br> <br>    The return value is 0 if the operation was successful.  Otherwise the value <br>    SOCKET_ERROR is returned. <br> <br>--*/ <br>{ <br>    INT                 ReturnValue; <br>    PDPROVIDER          Provider; <br>PPROTO_CATALOG_ITEMBaseProviderCatalogEntry; <br> <br>    if (PREAPINOTIFY(( DTCODE_WSPAddressToString, <br>                       &amp;ReturnValue, <br>                       gLibraryName, <br>                       &amp;AddressString, <br>                       &amp;AddressFamily, <br>                       &amp;lpProtocolInfo, <br>                       &amp;lpAddress, <br>                       &amp;lpAddressLength, <br>                       &amp;lpErrno)) ){ <br>        return(ReturnValue); <br>    } //if <br> <br>    // <br>    // Get the catlog entry for the next provider in the chain <br>    // <br>    ReturnValue = gProviderCatalog-&gt;FindNextProviderInChain( <br>        lpProtocolInfo, <br>        &amp;Provider, <br>&amp;BaseProviderCatalogEntry); <br> <br>    if (NO_ERROR == ReturnValue){ <br>        ReturnValue = Provider-&gt;WSPStringToAddress( <br>            AddressString, <br>            AddressFamily, <br>        BaseProviderCatalogEntry <br>? BaseProviderCatalogEntry-&gt;GetProtocolInfo() <br>: lpProtocolInfo, <br>            lpAddress, <br>            lpAddressLength, <br>            lpErrno); <br>    } //if <br> <br>    POSTAPINOTIFY(( DTCODE_WSPAddressToString, <br>                    &amp;ReturnValue, <br>                    gLibraryName, <br>                    &amp;AddressString, <br>                    &amp;AddressFamily, <br>                    &amp;lpProtocolInfo, <br>                    &amp;lpAddress, <br>                    &amp;lpAddressLength, <br>                    &amp;lpErrno)); <br> <br>    return(ReturnValue); <br> <br>} <br> <br> <br> <br>int <br>WSPAPI <br>WSPStartup( <br>    WORD wVersion, <br>    LPWSPDATA lpWSPData, <br>    LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    WSPUPCALLTABLE UpcallTable, <br>    LPWSPPROC_TABLE lpProcTable ) <br>/*++ <br> <br>Routine Description: <br> <br>    Initiate use of a WinSock service provider by a client. <br> <br>Arguments: <br> <br>    wVersionRequested - The highest version of WinSock SPI support that the <br>                        caller  can use. The high order byte specifies the <br>                        minor version (revision) number; the low-order byte <br>                        specifies the major version number. <br> <br>    lpWSPData - A pointer to the WSPDATA data structure that is to receive <br>                details of the WinSock service provider. <br> <br>    lpProtocolInfo - A pointer to a WSAPROTOCOL_INFO struct that defines the <br>                     characteristics of the desired protocol.  This is <br>                     especially useful when a single provider DLL is capable of <br>                     instantiating multiple different service providers. <br> <br>    UpcallTableThe WinSock 2 DLLs upcall dispatch table. <br> <br>    lpProcTable - A pointer to the table of SPI function pointers. <br> <br> <br> <br>Return Value: <br> <br> <br>--*/ <br>{ <br>HMODULEhWS2_32; <br>    INTReturnCode; <br> <br>    EnterCriticalSection(&amp;gInitCriticalSection); <br> <br>    ReturnCode = NO_ERROR; <br> <br>// Save the WinSock2 upcall table <br>gUpCallTable = UpcallTable; <br> <br>    if (gStartupCount == 0){ <br>ReturnCode = WSAVERNOTSUPPORTED; <br>        // This is the first time that WSPStartup() has been called so lets get <br>        // ourselves ready to do bussiness <br> <br>// First check for new exported function <br>hWS2_32 = GetModuleHandle (TEXT("ws2_32.dll")); <br>if (hWS2_32!=NULL) { <br>lpWPUCompleteOverlappedRequest =  <br>(LPWPUCOMPLETEOVERLAPPEDREQUEST) <br>GetProcAddress (hWS2_32, "WPUCompleteOverlappedRequest"); <br> <br> <br>if (lpWPUCompleteOverlappedRequest!=NULL) { <br>ReturnCode = WSASYSNOTREADY; <br> <br> <br>// Initialize the sockets <br>DSOCKET::DSocketClassInitialize (); <br> <br>// <br>// Init the provider catalog <br>// <br>gProviderCatalog = new DCATALOG; <br>if (gProviderCatalog){ <br>ReturnCode = gProviderCatalog-&gt;Initialize(); <br>} //if <br> <br>// <br>// Init the buffer manager <br>// <br>if (NO_ERROR == ReturnCode){ <br>gBufferManager = new DBUFFERMANAGER; <br>if (gBufferManager){ <br>ReturnCode = gBufferManager-&gt;Initialize(); <br>// If we succeded incremant the startup count <br>if (NO_ERROR == ReturnCode){ <br>gStartupCount++; <br>} //if <br>} //if <br>} //if <br>} //if <br>} // if <br>} // if <br>    LeaveCriticalSection(&amp;gInitCriticalSection); <br> <br>if (ReturnCode==NO_ERROR) { <br>// <br>// Fill in the clients proceedure table with our entry points. <br>// <br> <br>lpProcTable-&gt;lpWSPAccept = WSPAccept; <br>lpProcTable-&gt;lpWSPAddressToString = WSPAddressToString; <br>lpProcTable-&gt;lpWSPAsyncSelect = WSPAsyncSelect; <br>lpProcTable-&gt;lpWSPBind = WSPBind; <br>lpProcTable-&gt;lpWSPCancelBlockingCall = WSPCancelBlockingCall; <br>lpProcTable-&gt;lpWSPCleanup = WSPCleanup; <br>lpProcTable-&gt;lpWSPCloseSocket = WSPCloseSocket; <br>lpProcTable-&gt;lpWSPConnect = WSPConnect; <br>lpProcTable-&gt;lpWSPDuplicateSocket = WSPDuplicateSocket; <br>lpProcTable-&gt;lpWSPEnumNetworkEvents = WSPEnumNetworkEvents; <br>lpProcTable-&gt;lpWSPEventSelect = WSPEventSelect; <br>lpProcTable-&gt;lpWSPGetOverlappedResult = WSPGetOverlappedResult; <br>lpProcTable-&gt;lpWSPGetPeerName = WSPGetPeerName; <br>lpProcTable-&gt;lpWSPGetSockName = WSPGetSockName; <br>lpProcTable-&gt;lpWSPGetSockOpt = WSPGetSockOpt; <br>lpProcTable-&gt;lpWSPGetQOSByName = WSPGetQOSByName; <br>lpProcTable-&gt;lpWSPIoctl = WSPIoctl; <br>lpProcTable-&gt;lpWSPJoinLeaf = WSPJoinLeaf; <br>lpProcTable-&gt;lpWSPListen = WSPListen; <br>lpProcTable-&gt;lpWSPRecv = WSPRecv; <br>lpProcTable-&gt;lpWSPRecvDisconnect = WSPRecvDisconnect; <br>lpProcTable-&gt;lpWSPRecvFrom = WSPRecvFrom; <br>lpProcTable-&gt;lpWSPSelect = WSPSelect; <br>lpProcTable-&gt;lpWSPSend = WSPSend; <br>lpProcTable-&gt;lpWSPSendDisconnect = WSPSendDisconnect; <br>lpProcTable-&gt;lpWSPSendTo = WSPSendTo; <br>lpProcTable-&gt;lpWSPSetSockOpt = WSPSetSockOpt; <br>lpProcTable-&gt;lpWSPShutdown = WSPShutdown; <br>lpProcTable-&gt;lpWSPSocket = WSPSocket; <br>lpProcTable-&gt;lpWSPStringToAddress = WSPStringToAddress; <br> <br>} <br> <br>    // Set the version info <br>    lpWSPData-&gt;wVersion = MAKEWORD(2,2); <br>    lpWSPData-&gt;wHighVersion = MAKEWORD(2,2); <br> <br>    return(ReturnCode); <br>} <br> <br> <br>BOOL <br>PASCAL FAR <br>WSPTransmitFile ( <br>IN SOCKET hSocket, <br>IN HANDLE hFile, <br>IN DWORD nNumberOfBytesToWrite, <br>IN DWORD nNumberOfBytesPerSend, <br>IN LPOVERLAPPED lpOverlapped, <br>IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, <br>IN DWORD dwReserved <br>) { <br>PDSOCKETSocket; <br>INTErrno, ReturnValue; <br>PDPROVIDERProvider; <br>SOCKETProviderSocket; <br>    // <br>    // Get our DSOCKET object <br>    // <br>    ReturnValue = gUpCallTable.lpWPUQuerySocketHandleContext( <br>        hSocket, <br>        (DWORD*)&amp;Socket, <br>        &amp;Errno); <br> <br>if (SOCKET_ERROR != ReturnValue){ <br>if (lpOverlapped) { <br>if ((lpOverlapped-&gt;hEvent==NULL) <br>|| ResetEvent ((HANDLE)((DWORD)lpOverlapped-&gt;hEvent&amp;0xFFFFFFFE))) { <br>PDWORKERTHREAD  Thread = GetWorkerThread (); <br>if (Thread!=NULL) { <br>// Setup the user overlapped struct <br>lpOverlapped-&gt;Internal = WSS_OPERATION_IN_PROGRESS; <br>lpOverlapped-&gt;InternalHigh = 0; <br>ReturnValue = Thread-&gt;QueueOverlappedTransmitFile( <br>Socket, <br>hFile, <br>nNumberOfBytesToWrite, <br>nNumberOfBytesPerSend, <br>lpOverlapped, <br>lpTransmitBuffers, <br>dwReserved, <br>&amp;Errno); <br>} <br>else { <br>ReturnValue = SOCKET_ERROR; <br>Errno = WSAENOBUFS; <br>} <br>} <br>else { <br>ReturnValue = SOCKET_ERROR; <br>Errno = WSA_INVALID_PARAMETER; <br>} <br>} <br>else { <br>Provider = Socket-&gt;GetDProvider (); <br>ProviderSocket = Socket-&gt;GetProviderSocket (); <br>ReturnValue = Provider-&gt;TransmitFile ( <br>ProviderSocket, <br>hFile, <br>nNumberOfBytesToWrite, <br>nNumberOfBytesPerSend, <br>lpOverlapped, <br>lpTransmitBuffers, <br>dwReserved, <br>&amp;Errno); <br>} <br>} <br>if (ReturnValue==NO_ERROR) <br>return TRUE; <br>else { <br>SetLastError (Errno); <br>return FALSE; </code></pre>
<p>
</p>
<pre><code>} <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
