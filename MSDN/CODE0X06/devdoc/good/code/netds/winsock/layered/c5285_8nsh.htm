<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DCATALOG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5291"></a>DCATALOG.CPP</h2>
<pre><code>/*++ <br> <br>     Copyright (c) 1996 Intel Corporation <br>     Copyright 1996 - 1998 Microsoft Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br> <br>Module Name: <br> <br>    dcatalog.cpp <br> <br>Abstract: <br> <br>    This module contains the implementation of the dcatalog class. This class <br>    maintains a catalog of installed WinSock2 service providers. <br> <br>--*/ <br> <br>#include "precomp.h" <br>#include "install.h" <br> <br>  <br>DCATALOG::DCATALOG() <br>/*++ <br> <br>Routine Description: <br> <br>    Constructor for the DCATALOG object. Set member variables to known <br>    state. Initialization of the object is completed in Initialize(). <br> <br>Arguments: <br> <br>    NONE. <br> <br>Return Value: <br> <br>    NONE. <br> <br>--*/ <br>{ <br> <br>    m_num_items = 0; <br>    m_local_item = NULL; <br> <br>    // initialize the critical section object <br>    InitializeCriticalSection( &amp;m_catalog_lock ); <br>    InitializeListHead( &amp;m_protocol_list ); <br>} <br> <br>INT <br>DCATALOG::Initialize( <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Initialization routine for the DCATALOG object. Completes the <br>    initialization of the DCATALOG object.  This MUST be the first member <br>    fuction called after a DCATALOG object is created. <br> <br>Arguments: <br> <br>    NONE. <br> <br>Return Value: <br> <br>    NO_ERROR if the fuction succeeds else a winsock2 error code. <br> <br>--*/ <br>{ <br>    LPWSAPROTOCOL_INFOW   ProtocolInfoBuff = NULL; <br>    DWORD                ProtocolInfoBuffSize = 0; <br>    PPROTO_CATALOG_ITEM  CatalogItem; <br>    INT                  ReturnCode; <br>    INT                  ErrorCode; <br>    INT                  EnumResult; <br>    INT                  Index; <br> <br>    // Call WSCEnumProtocols with a zero length buffer so we know what size to <br>    // send in to get all the installed PROTOCOL_INFO structs. <br>    WSCEnumProtocols( <br>        NULL,                     // lpiProtocols <br>        ProtocolInfoBuff,         // lpProtocolBuffer <br>        &amp; ProtocolInfoBuffSize,   // lpdwBufferLength <br>        &amp; ErrorCode);             // lpErrno <br> <br>    ReturnCode = WSA_NOT_ENOUGH_MEMORY; <br>    ProtocolInfoBuff = (LPWSAPROTOCOL_INFOW)new char[ProtocolInfoBuffSize]; <br>    if (ProtocolInfoBuff){ <br>        EnumResult = WSCEnumProtocols( <br>            NULL,                     // lpiProtocols <br>            ProtocolInfoBuff,         // lpProtocolBuffer <br>            &amp; ProtocolInfoBuffSize,   // lpdwBufferLength <br>            &amp; ErrorCode); <br> <br>        ReturnCode = WSASYSNOTREADY; <br>        if (EnumResult != SOCKET_ERROR){ <br>            for (Index=0; Index &lt; EnumResult ; Index++){ <br> <br>                //Create a new catalog item for the PROTOCOL_INFO struct. <br>                CatalogItem = new PROTO_CATALOG_ITEM; <br>                if (CatalogItem){ <br> <br>                    ReturnCode = CatalogItem-&gt;Initialize( <br>                        &amp;ProtocolInfoBuff[Index]); <br>                    if (NO_ERROR == ReturnCode){ <br> <br>                        //Add the new catalog item to the catalog <br>                        AcquireCatalogLock(); <br>                        AppendCatalogItem( <br>                            CatalogItem); <br>                        if (memcmp (&amp;CatalogItem-&gt;GetProtocolInfo()-&gt;ProviderId, <br>                                &amp;LayeredProviderGuid, <br>sizeof (GUID))==0) <br>                            m_local_item = CatalogItem; <br>                        ReleaseCatalogLock(); <br>                    } //if <br>                    else{ <br>                        break; <br>                    } //else <br>                } //if <br>            } //for <br> <br>            if ((NO_ERROR==ReturnCode) <br>                    &amp;&amp; (m_local_item==NULL)) <br>                ReturnCode = WSASYSNOTREADY; <br>        } //if <br>        delete(ProtocolInfoBuff); <br>    } //if <br>    return(ReturnCode); <br>} <br> <br> <br> <br>  <br>DCATALOG::~DCATALOG() <br>/*++ <br> <br>Routine Description: <br> <br>    This  function  destroys the catalog object.  It takes care of removing and <br>    destroying  all  of  the  catalog  entries  in  the catalog.  This includes <br>    destroying  all  of the DPROVIDER objects referenced by the catalog.  It is <br>    the  caller's responsibility to make sure that the DPROVIDER objects are no <br>    longer referenced. <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    None <br> <br>Implementation Notes: <br> <br>    for each catalog entry <br>        remove the entry <br>        get its DPROVIDER reference <br>        if reference is non-null <br>            Set providers for all entries with matching IDs null <br>            destroy the DPROVIDER <br>        endif <br>        destroy the entry <br>    end for <br>    deallocate the list head <br>    close the catalog registry mutex <br>--*/ <br>{ <br>    PLIST_ENTRY  this_linkage; <br>    PPROTO_CATALOG_ITEM  this_item; <br>    PDPROVIDER  this_provider; <br> <br>    DEBUGF( <br>        DBG_TRACE, <br>        ("Catalog destructor\n")); <br> <br>    AcquireCatalogLock(); <br> <br>    while ((this_linkage = m_protocol_list.Flink) != &amp; m_protocol_list) { <br>        this_item = CONTAINING_RECORD( <br>            this_linkage,        // address <br>            PROTO_CATALOG_ITEM,  // type <br>            m_CatalogLinkage     // field <br>            ); <br>        RemoveCatalogItem( <br>            this_item  // CatalogItem <br>            ); <br>        this_provider = this_item-&gt;GetProvider(); <br>        if (this_provider) <br>            delete this_provider; <br>        delete this_item; <br>    }  // while (get entry linkage) <br> <br>    assert( m_num_items == 0 ); <br> <br>    ReleaseCatalogLock(); <br>    DeleteCriticalSection( &amp;m_catalog_lock ); <br> <br>}  // ~DCATALOG <br> <br> <br> <br>  <br>VOID <br>DCATALOG::EnumerateCatalogItems( <br>    IN CATALOGITERATION  Iteration, <br>    IN DWORD             PassBack <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This  procedure enumerates all of the DPROTO_CATALOG_ITEM structures in the <br>    catalog  by  calling  the indicated iteration procedure once for each item. <br>    The called procedure can stop the iteration early by returning FALSE. <br> <br>    Note  that  the DPROVIDER associated with an enumerated DPROTO_CATALOG_ITEM <br>    may  be  NULL.   To retrieve DPROTO_CATALOG_ITEM structure that has had its <br>    DPROVIDER      loaded      and      initialized,      you      can      use <br>    GetCatalogItemFromCatalogEntryId. <br> <br>Arguments: <br> <br>    Iteration - Supplies   a  reference  to  the  catalog  iteration  procedure <br>                supplied by the client. <br> <br>    PassBack  - Supplies  a  value uninterpreted by this procedure.  This value <br>                is  passed  unmodified to the catalog iteration procedure.  The <br>                client can use this value to carry context between the original <br>                call site and the iteration procedure. <br> <br>Return Value: <br> <br>    None <br>--*/ <br>{ <br>    PLIST_ENTRY         ListMember; <br>    PPROTO_CATALOG_ITEM CatalogEntry; <br>    BOOL                enumerate_more; <br> <br>    assert(Iteration != NULL); <br> <br>    enumerate_more = TRUE; <br> <br>    AcquireCatalogLock(); <br> <br>    ListMember = m_protocol_list.Flink; <br> <br>    while (enumerate_more &amp;&amp; (ListMember != &amp; m_protocol_list)) { <br>        CatalogEntry = CONTAINING_RECORD( <br>            ListMember, <br>            PROTO_CATALOG_ITEM, <br>            m_CatalogLinkage); <br>        ListMember = ListMember-&gt;Flink; <br>        enumerate_more = (* Iteration) ( <br>            PassBack,     // PassBack <br>            CatalogEntry  // CatalogEntry <br>            ); <br>    } //while <br> <br>    ReleaseCatalogLock(); <br> <br>}  // EnumerateCatalogItems <br> <br> <br>  <br>INT <br>DCATALOG::FindNextProviderInChain( <br>        IN  LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>        OUT PDPROVIDER          *NextProvider, <br>OUT PPROTO_CATALOG_ITEM*BaseProviderCatalogEntry <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This procedure finds and loads the provider below this <br>    provider in the protocol chain. <br> <br>Arguments: <br>    lpLocalProtocolInfo - A pointer to the WSAPROTOCOL_INFO struct for the <br>                          current protocol chain. <br> <br>    NextProvider        - A pointer to DPROVIDER object pointer for the <br>                          next provider in chain <br>BaseProviderCatalogEntry - If next provider is a base provider, this <br>  pointer will contain the next provider catalog <br>  entry <br>Return Value: <br> <br>    NO_ERROR if the next provider is located else a valid winsock2 error <br>    code. <br>--*/ <br>{ <br> <br>    PLIST_ENTRY         ListMember; <br>    PPROTO_CATALOG_ITEM CatalogEntry; <br>    PPROTO_CATALOG_ITEM NextProviderCatalogEntry; <br>DWORDLocalCatalogEntryId; <br>    DWORD               NextProviderCatalogEntryId; <br>    INT                 Index; <br>    INT                 ReturnCode =WSASYSNOTREADY; <br> <br>assert (NextProvider!=NULL); <br> <br>if (m_local_item==NULL) <br>return WSASYSNOTREADY; <br> <br>LocalCatalogEntryId = m_local_item-&gt;GetProtocolInfo()-&gt;dwCatalogEntryId; <br> <br>    AcquireCatalogLock(); <br> <br>// First try to see if we have processed this chain already and <br>// thus loaded the provider that follows us in it <br>    ListMember = m_protocol_list.Flink; <br> <br>    while (ListMember != &amp; m_protocol_list) { <br> <br>        CatalogEntry = CONTAINING_RECORD( <br>            ListMember, <br>            PROTO_CATALOG_ITEM, <br>            m_CatalogLinkage); <br>        ListMember = ListMember-&gt;Flink; <br>        if (CatalogEntry-&gt;GetProtocolInfo()-&gt;dwCatalogEntryId == <br>lpProtocolInfo-&gt;dwCatalogEntryId) { <br>*NextProvider = CatalogEntry-&gt;GetProvider (); <br>if (*NextProvider!=NULL) { <br> ReturnCode = NO_ERROR; <br>} <br>else { <br>// <br>// Get the next providers CatalogEntryId from the protocol chain <br>// <br>for (Index=0; <br> Index &lt; lpProtocolInfo-&gt;ProtocolChain.ChainLen; <br> Index++){ <br>if ((LocalCatalogEntryId== <br>lpProtocolInfo-&gt;ProtocolChain.ChainEntries[Index]) <br>&amp;&amp; (lpProtocolInfo-&gt;ProtocolChain.ChainLen&gt;Index+1)) { <br>NextProviderCatalogEntryId = <br>lpProtocolInfo-&gt;ProtocolChain.ChainEntries[Index+1]; <br>break; <br>} //if <br>} // for <br>// <br>// If we found ourselves before reaching the end of the chain, <br>// go load the next guy in the chain <br>// <br>if (Index&lt;lpProtocolInfo-&gt;ProtocolChain.ChainLen) { <br>ReturnCode = GetCatalogItemFromCatalogEntryId ( <br>NextProviderCatalogEntryId, <br>&amp;NextProviderCatalogEntry); <br>if (NO_ERROR==ReturnCode) { <br>// Pass the chain protocol info if <br>// the provider we are loading is not <br>// the last in the chain (base provider) <br>if (Index==lpProtocolInfo-&gt;ProtocolChain.ChainLen-1) <br>ReturnCode = LoadProvider ( <br>NextProviderCatalogEntry, <br>NextProviderCatalogEntry-&gt;GetProtocolInfo(), <br>NextProvider); <br>else <br>ReturnCode = LoadProvider ( <br>NextProviderCatalogEntry, <br>lpProtocolInfo, <br>NextProvider); <br> <br>// Cache provider if we succeded <br>if (NO_ERROR==ReturnCode) { <br>CatalogEntry-&gt;SetProvider (*NextProvider); <br>CatalogEntry-&gt;SetProviderCatalogEntry (NextProviderCatalogEntry); <br>} <br>} //if <br>} <br>} <br>if ((NO_ERROR==ReturnCode) <br>&amp;&amp; (CatalogEntry-&gt;GetProviderCatalogEntry()-&gt;GetProtocolInfo()-&gt;ProtocolChain.ChainLen==BASE_PROTOCOL)) <br>*BaseProviderCatalogEntry = CatalogEntry-&gt;GetProviderCatalogEntry(); <br> <br>break; <br>} <br>} <br> <br>    ReleaseCatalogLock(); <br>    return(ReturnCode); <br>} <br> <br> <br>  <br>INT <br>DCATALOG::GetCatalogItemFromCatalogEntryId( <br>    IN  DWORD                     CatalogEntryId, <br>    OUT PPROTO_CATALOG_ITEM FAR * CatalogItem <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This  procedure  retrieves  a  reference  to a catalog item given a catalog <br>    entry ID to search for. <br> <br> <br>Arguments: <br> <br>    CatalogEntryId  - Supplies The ID of a catalog entry to be searched for. <br> <br>    CatalogItem     - Returns a reference to the catalog item with the matching <br>                      catalog entry ID if it is found, otherwise returns NULL. <br> <br>Return Value: <br> <br>  The  function  returns  NO_ERROR  if  successful, otherwise it returns an <br>  appropriate WinSock error code. <br>--*/ <br>{ <br>    PLIST_ENTRY         ListMember; <br>    INT                 ReturnCode=WSASYSNOTREADY; <br>    PPROTO_CATALOG_ITEM CatalogEntry; <br> <br>    assert(CatalogItem != NULL); <br> <br>    // Prepare for early error return <br>    * CatalogItem = NULL; <br> <br>    AcquireCatalogLock(); <br> <br>    ListMember = m_protocol_list.Flink; <br> <br>    while (ListMember != &amp; m_protocol_list) { <br> <br>        CatalogEntry = CONTAINING_RECORD( <br>            ListMember, <br>            PROTO_CATALOG_ITEM, <br>            m_CatalogLinkage); <br>        ListMember = ListMember-&gt;Flink; <br>        if (CatalogEntry-&gt;GetProtocolInfo()-&gt;dwCatalogEntryId == <br>CatalogEntryId) { <br>            * CatalogItem = CatalogEntry; <br>            ReturnCode = NO_ERROR; <br>break; <br>        } //if <br>    } //while <br> <br>    ReleaseCatalogLock(); <br>    return(ReturnCode); <br>}  // GetCatalogItemFromCatalogEntryId <br> <br> <br>  <br>INT <br>DCATALOG::LoadProvider( <br>    IN PPROTO_CATALOG_ITEM CatalogEntry, <br>    IN LPWSAPROTOCOL_INFOW lpProtocolInfo, <br>    OUT PDPROVIDER         *Provider <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Load   the   provider  described  by  CatalogEntry. <br> <br>Arguments: <br> <br>    CatalogEntry - Supplies  a reference to a protocol catalog entry describing <br>                   the provider to load. <br> <br>    lpProtocolInfo - Protocol info structure to pass to provider when <br>loading it <br> <br>    Provider     - Returns a reference to the newly loaded provider object. <br> <br>Return Value: <br> <br>    The  function  returns NO_ERROR if successful, otherwise it returns an <br>    appropriate WinSock error code. <br>--*/ <br>{ <br>    INT ReturnCode = WSA_NOT_ENOUGH_MEMORY; <br>    PDPROVIDER LocalProvider; <br> <br>    assert(CatalogEntry != NULL); <br>    assert(Provider != NULL); <br> <br>    *Provider = NULL; <br> <br>    LocalProvider = new(DPROVIDER); <br>    if (LocalProvider) { <br> <br>        ReturnCode = LocalProvider-&gt;Initialize( <br>            CatalogEntry-&gt;GetLibraryPath(), <br>            lpProtocolInfo <br>            ); <br>        if (NO_ERROR == ReturnCode) { <br>            *Provider = LocalProvider; <br>        } //if <br>        else { <br>            delete(LocalProvider); <br>        } //else <br>    } //if <br>    return(ReturnCode); <br>}  // LoadProvider <br> <br> <br>  <br>VOID <br>DCATALOG::AppendCatalogItem( <br>    IN  PPROTO_CATALOG_ITEM  CatalogItem <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This procedure appends a catalog item to the end of the (in-memory) catalog <br>    object.   It becomes the last item in the catalog. <br> <br>Arguments: <br> <br>    CatalogItem - Supplies a reference to the catalog item to be added. <br> <br>Return Value: <br> <br>    None <br>--*/ <br>{ <br>    assert(CatalogItem != NULL); <br> <br>    InsertTailList( <br>        &amp; m_protocol_list,               // ListHead <br>        &amp; CatalogItem-&gt;m_CatalogLinkage  // Entry <br>       ); <br>    m_num_items++; <br>}  // AppendCatalogItem <br> <br> <br>  <br>VOID <br>DCATALOG::RemoveCatalogItem( <br>    IN  PPROTO_CATALOG_ITEM  CatalogItem <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This  procedure removes a catalog item from the (in-memory) catalog object. <br>    The catalog information in the registry is NOT updated. <br> <br>Arguments: <br> <br>    CatalogItem - Supplies a reference to the catalog item to be removed. <br> <br>Return Value: <br> <br>    None <br>--*/ <br>{ <br>    assert(CatalogItem != NULL); <br> <br>    RemoveEntryList( <br>        &amp; CatalogItem-&gt;m_CatalogLinkage  // Entry <br>        ); <br>    assert(m_num_items &gt; 0); <br>    m_num_items--; <br>}  // RemoveCatalogItem </code></pre>
<p>&nbsp;</p></body>
</HTML>
