<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DWORKER.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5306"></a>DWORKER.H</h2>
<pre><code>/*++ <br> <br> <br>     Copyright c 1996 Intel Corporation <br>     All Rights Reserved <br> <br>     Permission is granted to use, copy and distribute this software and <br>     its documentation for any purpose and without fee, provided, that <br>     the above copyright notice and this statement appear in all copies. <br>     Intel makes no representations about the suitability of this <br>     software for any purpose.  This software is provided "AS IS." <br> <br>     Intel specifically disclaims all warranties, express or implied, <br>     and all liability, including consequential and other indirect <br>     damages, for the use of this software, including liability for <br>     infringement of any proprietary rights, and including the <br>     warranties of merchantability and fitness for a particular purpose. <br>     Intel does not assume any responsibility for any errors which may <br>     appear in this software nor any responsibility to update it. <br> <br> <br>Module Name: <br> <br>dworker.h <br> <br>Abstract: <br> <br>   This module contins the interface to the DWORKERTHREAD class for <br>   LSP.DLL. <br> <br>--*/ <br> <br>#ifndef _DWORKERTHREAD_ <br>#define _DWORKERTHREAD_ <br> <br> <br>#include &lt;winsock2.h&gt; <br>#include "llist.h" <br>#include "doverlap.h" <br>#include "classfwd.h" <br> <br>#define WSP_RECV       0x00000001 <br>#define WSP_RECVFROM   0x00000002 <br>#define WSP_SEND       0x00000004 <br>#define WSP_SENDTO     0x00000008 <br>#define WSP_IOCTL      0x00000010 <br>#define TRANSMIT_FILE  0x00000020 <br>#define ACCEPT_EX   0x00000040 <br> <br> <br> <br>class DWORKERTHREAD <br>{ <br>  public: <br> <br>    DWORKERTHREAD(); <br> <br>    INT <br>    Initialize(); <br> <br>    VOID <br>    Destroy (); <br> <br>    ~DWORKERTHREAD(); <br> <br>    BOOL <br>    RegisterSocketHandle ( <br>        SOCKET  socket <br>        ); <br> <br>    DWORD <br>    WorkerThreadProc(); <br> <br>    LPWSATHREADID <br>    GetThreadId(); <br> <br>    INT <br>    QueueOverlappedRecv( <br>        PDSOCKET                           Socket, <br>        LPWSABUF                           UserBuffers, <br>        DWORD                              UserBufferCount, <br>        LPDWORD                            UserBytesRecvd, <br>        LPDWORD                            UserFlags, <br>        LPWSAOVERLAPPED                    UserOverlappedStruct, <br>        LPWSAOVERLAPPED_COMPLETION_ROUTINE UserlpCompletionRoutine, <br>        LPWSATHREADID                      UserThreadId, <br>        LPWSABUF                           InternalBuffers, <br>        DWORD                              InternalBufferCount, <br>        LPINT                              Errno <br>        ); <br> <br>    INT <br>    QueueOverlappedRecvFrom( <br>        PDSOCKET                           Socket, <br>        LPWSABUF                           UserBuffers, <br>        DWORD                              UserBufferCount, <br>        LPDWORD                            UserBytesRecvd, <br>        LPDWORD                            UserFlags, <br>        struct sockaddr FAR *              UserFrom, <br>        LPINT                              UserFromlen, <br>        LPWSAOVERLAPPED                    UserOverlappedStruct, <br>        LPWSAOVERLAPPED_COMPLETION_ROUTINE UserlpCompletionRoutine, <br>        LPWSATHREADID                      UserThreadId, <br>        LPWSABUF                           InternalBuffers, <br>        DWORD                              InternalBufferCount, <br>        LPINT                              Errno <br>        ); <br>    INT <br>    QueueOverlappedSend( <br>        PDSOCKET                           Socket, <br>        LPWSABUF                           UserBuffers, <br>        DWORD                              UserBufferCount, <br>        LPDWORD                            UserBytesSent, <br>        DWORD                            UserFlags, <br>        LPWSAOVERLAPPED                    UserOverlappedStruct, <br>        LPWSAOVERLAPPED_COMPLETION_ROUTINE UserlpCompletionRoutine, <br>        LPWSATHREADID                      UserThreadId, <br>        LPINT           Errno <br>        ); <br> <br>    INT <br>    QueueOverlappedSendTo( <br>        PDSOCKET                           Socket, <br>        LPWSABUF                           UserBuffers, <br>        DWORD                              UserBufferCount, <br>        LPDWORD                            UserBytesSent, <br>        DWORD                              UserFlags, <br>        const struct sockaddr FAR *        UserTo, <br>        INT                                UserTolen, <br>        LPWSAOVERLAPPED                    UserOverlappedStruct, <br>        LPWSAOVERLAPPED_COMPLETION_ROUTINE UserlpCompletionRoutine, <br>        LPWSATHREADID                      UserThreadId, <br>        LPINT                              Errno <br>        ); <br> <br>    INT <br>    QueueOverlappedIoctl( <br>        PDSOCKET                           Socket, <br>        DWORD                              dwIoControlCode, <br>        LPVOID                             lpvInBuffer, <br>        DWORD                              cbInBuffer, <br>        LPVOID                             lpvOutBuffer, <br>        DWORD                              cbOutBuffer, <br>        LPDWORD                            lpcbBytesReturned, <br>        LPWSAOVERLAPPED                    UserOverlappedStruct, <br>        LPWSAOVERLAPPED_COMPLETION_ROUTINE UserlpCompletionRoutine, <br>        LPWSATHREADID                      UserThreadId, <br>        LPINT                              Errno <br>        ); <br> <br>INT <br>QueueOverlappedAcceptEx( <br>PDSOCKET   ListenSocket, <br>PDSOCKET   AcceptSocket, <br>LPVOID   lpOutputBuffer, <br>DWORD   dwReceiveDataLength, <br>DWORD   dwLocalAddressLength, <br>DWORD   dwRemoteAddressLength, <br>LPWSAOVERLAPPED   UserOverlappedStruct, <br>        LPINT                              Errno <br>); <br> <br>INT <br>QueueOverlappedTransmitFile( <br>PDSOCKET   Socket, <br>HANDLE   hFile, <br>DWORD   nNumberOfBytesToWrite, <br>DWORD   nNumberOfBytesPerSend, <br>LPWSAOVERLAPPED   UserOverlappedStruct, <br>LPTRANSMIT_FILE_BUFFERS   lpTransmitBuffers, <br>DWORD   dwReserved, <br>        LPINT                              Errno <br>); <br>  private: <br>    VOID <br>    AddOverlappedOperation( <br>        IN PDSOCKET                  Socket, <br>        IN PINTERNALOVERLAPPEDSTRUCT OverlappedOperation <br>        ); <br> <br>    PINTERNALOVERLAPPEDSTRUCT <br>    NextOverlappedOperation(); <br> <br>    DWORD m_thread_count; <br>    // Number of worker threads. <br> <br>    HANDLE m_completion_port; <br>    // The handle to NT completion port used for accepting of completion <br>    // indication from providers in worker thread(s) <br> <br>    HANDLE m_wakeup_semaphore; <br>    // The handle to the WIN32 semaphore used to communicate with our worker <br>    // thread(s) if completion port is not available (Win9x). <br> <br>    BOOL   m_exit_thread; <br>    // A boolean to tell our threads to exit at object destruction time. <br> <br>    LIST_ENTRY       m_overlapped_operation_queue; <br> <br>    CRITICAL_SECTION m_overlapped_operation_queue_lock; <br> <br>    WSATHREADID  m_thread_id; <br>    // The thread ID for the worker thread. <br> <br>};   // class DWORKERTHREAD <br> <br>inline <br>LPWSATHREADID <br>DWORKERTHREAD::GetThreadId() <br>{ <br>    return(&amp;m_thread_id); <br>} <br> <br>#endif // _DWORKERTHREAD_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
