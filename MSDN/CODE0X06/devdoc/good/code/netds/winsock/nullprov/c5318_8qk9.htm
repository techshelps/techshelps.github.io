<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NULLPROV.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5319"></a>NULLPROV.CPP</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1998 Microsoft Corporation <br> <br>Copyright (c) 1996 Intel Corp <br> <br>Module Name: <br> <br>    nullprov.cpp <br> <br>Abstract: <br> <br>    This  module  provides  a  "null" provider for the purpose of demonstrating <br>    what  it  takes  to  get  a  service  provider  installed and started.  The <br>    provider pretty much does nothing but pretend to send and receive data. <br> <br>--*/ <br> <br> <br>// <br>// The Service Provider Interface was widened to Unicode in version 2.2. <br>//  All of the parameters that involve strings in this module all provided <br>//  in their "transparent" form.  They are switched to the wide character <br>//  version, at compile time, by the following define: <br>// <br> <br>#define UNICODE <br> <br>#include &lt;windows.h&gt; <br>#include "ws2spi.h" <br> <br>#include "nullpdef.h" <br> <br> <br>// Global Upcall table with WinSock 2 DLL upcall entry points. <br>WSPUPCALLTABLE g_upcalls; <br> <br>// Global protocol info struct of the one protocol we support. <br>WSAPROTOCOL_INFOA  g_protoinfo; <br> <br> <br> <br> <br> <br> <br>  <br>SOCKET WSPAPI WSPAccept( <br>    SOCKET s, <br>    struct sockaddr FAR * addr, <br>    LPINT addrlen, <br>    LPCONDITIONPROC lpfnCondition, <br>    DWORD dwCallbackData, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(INVALID_SOCKET); <br>} // lpWSPAccept <br> <br> <br> <br>  <br>INT WSPAPI WSPAddressToString( <br>    LPSOCKADDR lpsaAddress, <br>    DWORD dwAddressLength, <br>    LPWSAPROTOCOL_INFO lpProtocolInfo, <br>    LPTSTR lpszAddressString, <br>    LPDWORD lpdwAddressStringLength, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPAddressToString <br> <br> <br> <br>  <br>int WSPAPI WSPAsyncSelect( <br>    SOCKET s, <br>    HWND hWnd, <br>    unsigned int wMsg, <br>    long lEvent, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPAsyncSelect <br> <br> <br> <br>  <br>int WSPAPI WSPBind( <br>    SOCKET s, <br>    const struct sockaddr FAR * name, <br>    int namelen, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation: <br> <br>    A  simple  implementation  is  supplied.  The implementation simply returns <br>    success without really doing anything. <br>--*/ <br>{ <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br> <br>} // lpWSPBind <br> <br> <br> <br>  <br>int WSPAPI WSPCancelBlockingCall( <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation: <br> <br>    A  simple  implementation  is  supplied.  The implementation simply returns <br>    success without really doing anything. <br>--*/ <br>{ <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br> <br>} // lpWSPCancelBlockingCall <br> <br> <br> <br>  <br>int WSPAPI WSPCleanup( <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple  implementation  is  supplied.  The implementation simply returns <br>    success  without  really  doing  anything.   This is technically incorrect, <br>    since  we  should really maintain an up/down count of Startup/Cleanup pairs <br>    and  return  an  error  code  if  WSPCleanup  is called when there is not a <br>    WSPStartup outstanding. <br>--*/ <br>{ <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br> <br>} // lpWSPCleanup <br> <br> <br> <br>  <br>int WSPAPI WSPCloseSocket( <br>    SOCKET s, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    Perform  an  upcall to the WinSock 2 DLL to inform it of the removal of the <br>    socket handle.  Return the result. <br>--*/ <br>{ <br>    int close_result; <br> <br>    close_result = (* g_upcalls.lpWPUCloseSocketHandle)( <br>        s,         // s <br>        lpErrno);  // lpErrno <br>    return(close_result); <br> <br>} // lpWSPCloseSocket <br> <br> <br> <br>  <br>int WSPAPI WSPConnect( <br>    SOCKET s, <br>    const struct sockaddr FAR * name, <br>    int namelen, <br>    LPWSABUF lpCallerData, <br>    LPWSABUF lpCalleeData, <br>    LPQOS lpSQOS, <br>    LPQOS lpGQOS, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple implementation is supplied.  It indicates that no callee data was <br>    retrieved and returns success. <br>--*/ <br>{ <br>    if (lpCalleeData != NULL) { <br>        lpCalleeData-&gt;len = 0; <br>    } <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br> <br>} // lpWSPConnect <br> <br> <br> <br>  <br>int WSPAPI WSPDuplicateSocket( <br>    SOCKET s, <br>    DWORD dwProcessId, <br>    LPWSAPROTOCOL_INFO lpProtocolInfo, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPDuplicateSocket <br> <br> <br> <br>  <br>int WSPAPI WSPEnumNetworkEvents( <br>    SOCKET s, <br>    WSAEVENT hEventObject, <br>    LPWSANETWORKEVENTS lpNetworkEvents, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPEnumNetworkEvents <br> <br> <br> <br>  <br>int WSPAPI WSPEventSelect( <br>    SOCKET s, <br>    WSAEVENT hEventObject, <br>    long lNetworkEvents, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPEventSelect <br> <br> <br> <br>  <br>int WSPAPI WSPGetOverlappedResult( <br>    SOCKET s, <br>    LPWSAOVERLAPPED lpOverlapped, <br>    LPDWORD lpcbTransfer, <br>    BOOL fWait, <br>    LPDWORD lpdwFlags, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(FALSE); <br>} // lpWSPGetOverlappedResult <br> <br> <br> <br>  <br>int WSPAPI WSPGetPeerName( <br>    SOCKET s, <br>    struct sockaddr FAR * name, <br>    LPINT namelen, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPGetPeerName <br> <br> <br> <br>  <br>int WSPAPI WSPGetSockName( <br>    SOCKET s, <br>    struct sockaddr FAR * name, <br>    LPINT namelen, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPGetSockName <br> <br> <br> <br>  <br>int WSPAPI WSPGetSockOpt( <br>    SOCKET s, <br>    int level, <br>    int optname, <br>    char FAR * optval, <br>    LPINT optlen, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPGetSockOpt <br> <br> <br> <br>  <br>BOOL WSPAPI WSPGetQOSByName( <br>    SOCKET s, <br>    LPWSABUF lpQOSName, <br>    LPQOS lpQOS, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(FALSE); <br>} // lpWSPGetQOSByName <br> <br> <br> <br>  <br>int WSPAPI WSPIoctl( <br>    SOCKET s, <br>    DWORD dwIoControlCode, <br>    LPVOID lpvInBuffer, <br>    DWORD cbInBuffer, <br>    LPVOID lpvOutBuffer, <br>    DWORD cbOutBuffer, <br>    LPDWORD lpcbBytesReturned, <br>    LPWSAOVERLAPPED lpOverlapped, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    LPWSATHREADID lpThreadId, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Not implemented, <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br> <br>} // lpWSPIoctl <br> <br> <br> <br>  <br>SOCKET WSPAPI WSPJoinLeaf( <br>    SOCKET s, <br>    const struct sockaddr FAR * name, <br>    int namelen, <br>    LPWSABUF lpCallerData, <br>    LPWSABUF lpCalleeData, <br>    LPQOS lpSQOS, <br>    LPQOS lpGQOS, <br>    DWORD dwFlags, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(INVALID_SOCKET); <br>} // lpWSPJoinLeaf <br> <br> <br> <br>  <br>int WSPAPI WSPListen( <br>    SOCKET s, <br>    int backlog, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPListen <br> <br> <br> <br>  <br>int WSPAPI WSPRecv( <br>    SOCKET s, <br>    LPWSABUF lpBuffers, <br>    DWORD dwBufferCount, <br>    LPDWORD lpNumberOfBytesRecvd, <br>    LPDWORD lpFlags, <br>    LPWSAOVERLAPPED lpOverlapped, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    LPWSATHREADID lpThreadId, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple  implementation  is  supplied.   The  number of bytes received is <br>    simply  filled  in as the number requested.  No actual data is deposited in <br>    the  buffers.   The  client  will  "see"  whatever data happens to be there <br>    already. <br> <br>    This  simple implementation also violates the specification in that it does <br>    not  support  overlapped  I/O.  It simply returns an error indication if an <br>    attempt is made to use overlapped I/O features. <br>--*/ <br>{ <br>    if ((lpOverlapped != NULL) || <br>        (lpCompletionRoutine != NULL)) { <br>        // Overlapped I/O and its animal friends not implemented. <br>        *lpErrno = WSAEINVAL; <br>        return(SOCKET_ERROR); <br>    } <br> <br>    // Pretend to receive some data <br>    * lpNumberOfBytesRecvd = lpBuffers[0].len; <br>    * lpFlags = 0; <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br> <br>} // lpWSPRecv <br> <br> <br> <br>  <br>int WSPAPI WSPRecvDisconnect( <br>    SOCKET s, <br>    LPWSABUF lpInboundDisconnectData, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPRecvDisconnect <br> <br> <br> <br>  <br>int WSPAPI WSPRecvFrom( <br>    SOCKET s, <br>    LPWSABUF lpBuffers, <br>    DWORD dwBufferCount, <br>    LPDWORD lpNumberOfBytesRecvd, <br>    LPDWORD lpFlags, <br>    struct sockaddr FAR * lpFrom, <br>    LPINT lpFromlen, <br>    LPWSAOVERLAPPED lpOverlapped, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    LPWSATHREADID lpThreadId, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple  implementation  is  supplied.   The  number of bytes received is <br>    simply  filled  in as the number requested.  The "received from" address is <br>    filled  in  with  a length of zero.  This might be an unexpected result, in <br>    which case it could be changed to fill in some dummy constant address. <br> <br>    This  simple implementation also violates the specification in that it does <br>    not  support  overlapped  I/O.  It simply returns an error indication if an <br>    attempt is made to use overlapped I/O features. <br>--*/ <br>{ <br>    if ((lpOverlapped != NULL) || <br>        (lpCompletionRoutine != NULL)) { <br>        // Overlapped I/O and its animal friends not implemented. <br>        *lpErrno = WSAEINVAL; <br>        return(SOCKET_ERROR); <br>    } <br> <br>    // Pretend to receive some data <br>    * lpNumberOfBytesRecvd = lpBuffers[0].len; <br>    * lpFlags = 0; <br>    if (lpFromlen != NULL) { <br>        * lpFromlen = 0; <br>    } <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br> <br>} // lpWSPRecvFrom <br> <br> <br> <br>  <br>int WSPAPI WSPSelect( <br>    int nfds, <br>    fd_set FAR * readfds, <br>    fd_set FAR * writefds, <br>    fd_set FAR * exceptfds, <br>    const struct timeval FAR * timeout, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPSelect <br> <br> <br> <br>  <br>int WSPAPI WSPSend( <br>    SOCKET s, <br>    LPWSABUF lpBuffers, <br>    DWORD dwBufferCount, <br>    LPDWORD lpNumberOfBytesSent, <br>    DWORD dwFlags, <br>    LPWSAOVERLAPPED lpOverlapped, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    LPWSATHREADID lpThreadId, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple  implementation is supplied.  This implementation simply computes <br>    the total number of bytes the client is attempting to send and fills in the <br>    result to indicate that all the requested bytes were successfully sent. <br> <br>    This  simple implementation also violates the specification in that it does <br>    not  support  overlapped  I/O.  It simply returns an error indication if an <br>    attempt is made to use overlapped I/O features. <br>--*/ <br>{ <br>    DWORD bytes_sent; <br>    DWORD buf_index; <br>     <br>    if ((lpOverlapped != NULL) || <br>        (lpCompletionRoutine != NULL)) { <br>        // Overlapped I/O and its animal friends not implemented. <br>        *lpErrno = WSAEINVAL; <br>        return(SOCKET_ERROR); <br>    } <br> <br>    bytes_sent = 0; <br>    for (buf_index = 0; buf_index &lt; dwBufferCount; buf_index++) { <br>        bytes_sent += lpBuffers[buf_index].len; <br>    } // for buf_index <br>    * lpNumberOfBytesSent = bytes_sent; <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br> <br>} // lpWSPSend <br> <br> <br> <br>  <br>int WSPAPI WSPSendDisconnect( <br>    SOCKET s, <br>    LPWSABUF lpOutboundDisconnectData, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple  implementation is supplied.  This implementation simply computes <br>    the total number of bytes the client is attempting to send and fills in the <br>    result to indicate that all the requested bytes were successfully sent. <br> <br>    This  simple implementation also violates the specification in that it does <br>    not  support  overlapped  I/O.  It simply returns an error indication if an <br>    attempt is made to use overlapped I/O features. <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPSendDisconnect <br> <br> <br> <br>  <br>int WSPAPI WSPSendTo( <br>    SOCKET s, <br>    LPWSABUF lpBuffers, <br>    DWORD dwBufferCount, <br>    LPDWORD lpNumberOfBytesSent, <br>    DWORD dwFlags, <br>    const struct sockaddr FAR * lpTo, <br>    int iTolen, <br>    LPWSAOVERLAPPED lpOverlapped, <br>    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, <br>    LPWSATHREADID lpThreadId, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    DWORD bytes_sent; <br>    DWORD buf_index; <br>     <br>    if ((lpOverlapped != NULL) || <br>        (lpCompletionRoutine != NULL)) { <br>        // Overlapped I/O and its animal friends not implemented. <br>        *lpErrno = WSAEINVAL; <br>        return(SOCKET_ERROR); <br>    } <br> <br>    bytes_sent = 0; <br>    for (buf_index = 0; buf_index &lt; dwBufferCount; buf_index++) { <br>        bytes_sent += lpBuffers[buf_index].len; <br>    } // for buf_index <br>    * lpNumberOfBytesSent = bytes_sent; <br>    * lpErrno = ERROR_SUCCESS; <br>    return(ERROR_SUCCESS); <br>     <br>} // lpWSPSendTo <br> <br> <br> <br>  <br>int WSPAPI WSPSetSockOpt( <br>    SOCKET s, <br>    int level, <br>    int optname, <br>    const char FAR * optval, <br>    int optlen, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPSetSockOpt <br> <br> <br> <br>  <br>int WSPAPI WSPShutdown( <br>    SOCKET s, <br>    int how, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPShutdown <br> <br> <br> <br>  <br>SOCKET WSPAPI WSPSocket( <br>    int af, <br>    int type, <br>    int protocol, <br>    LPWSAPROTOCOL_INFO lpProtocolInfo, <br>    GROUP g, <br>    DWORD dwFlags, <br>    LPINT lpErrno <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple  implementation  is  supplied.   The procedure simply performs an <br>    upcall  to  the  WinSock  2 DLL to allocate a socket handle.  The allocated <br>    socket handle is returned as the new socket handle. <br> <br>    Note that this implementation does not keep any state information about the <br>    "socket"  it  allocated.   Consequently,  it simply uses 0 as the "context" <br>    value  associated with the socket handle.  If it were desired to keep state <br>    information  for  the  socket,  the  implementation  would  allocate a data <br>    structure  to  store the state information, cast the data structure pointer <br>    into a DWORD, and use this value as the dwContext.  When the implementation <br>    needed    to    access    the    state    information,    it   would   call <br>    WPUQuerySocketHandleContext  and  cast  the  retrieved  DWORD  back  to the <br>    appropriate data structure pointer. <br>--*/ <br>{ <br>    SOCKET  new_socket; <br> <br>    new_socket = (* g_upcalls.lpWPUCreateSocketHandle)( <br>        g_protoinfo.dwCatalogEntryId,  // dwCatalogEntryId <br>        0,                             // dwContext <br>        lpErrno);                      // lpErrno <br> <br>    return(new_socket); <br> <br>} // lpWSPSocket <br> <br> <br> <br>  <br>INT WSPAPI WSPStringToAddress( <br>    LPTSTR AddressString, <br>    INT AddressFamily, <br>    LPWSAPROTOCOL_INFO lpProtocolInfo, <br>    LPSOCKADDR lpAddress, <br>    LPINT lpAddressLength, <br>    LPINT     lpErrno <br>    ) <br>/*++ <br>--*/ <br>{ <br>    // Not implemented <br>    return(SOCKET_ERROR); <br>} // lpWSPStringToAddress <br> <br> <br> <br>  <br>int WSPAPI WSPStartup( <br>    WORD wVersionRequested, <br>    LPWSPDATA lpWSPData, <br>    LPWSAPROTOCOL_INFO lpProtocolInfo, <br>    WSPUPCALLTABLE UpcallTable, <br>    LPWSPPROC_TABLE lpProcTable <br>    ) <br>/*++ <br>Implementation <br> <br>    A  simple implementation is provided.  This just fills in required WSPData, <br>    a  procedure  table,  and returns success.  Technically this implementation <br>    violates  the  specification  since  it should maintain an up/down count of <br>    WSPStartup/WSPCleanup pairs. <br>--*/ <br>{ <br>    // Make  sure  that  the version requested is == 2.0 because that is all we <br>    // support. <br>    // <br>    // The  low  byte  is  the  major  version  and  the high byte is the minor <br>    // version. <br> <br>    if ( LOBYTE( wVersionRequested ) &lt; 2) { <br>        return WSAVERNOTSUPPORTED; <br>    } <br> <br>    lpWSPData-&gt;wVersion = MAKEWORD( 2, 0 ); <br>    lpWSPData-&gt;wHighVersion = MAKEWORD( 2, 0 ); <br> <br>#define szDESCRIPTION "Null Provider for WinSock 2 preliminary sample source" <br>    memcpy (lpWSPData-&gt;szDescription, szDESCRIPTION, sizeof szDESCRIPTION); <br> <br>    memcpy (&amp;g_protoinfo, lpProtocolInfo, sizeof WSAPROTOCOL_INFO); <br>     <br>    g_upcalls = UpcallTable; <br> <br>    lpProcTable-&gt;lpWSPAccept = WSPAccept; <br>    lpProcTable-&gt;lpWSPAddressToString = WSPAddressToString; <br>    lpProcTable-&gt;lpWSPAsyncSelect = WSPAsyncSelect; <br>    lpProcTable-&gt;lpWSPBind = WSPBind; <br>    lpProcTable-&gt;lpWSPCancelBlockingCall = WSPCancelBlockingCall; <br>    lpProcTable-&gt;lpWSPCleanup = WSPCleanup; <br>    lpProcTable-&gt;lpWSPCloseSocket = WSPCloseSocket; <br>    lpProcTable-&gt;lpWSPConnect = WSPConnect; <br>    lpProcTable-&gt;lpWSPDuplicateSocket = WSPDuplicateSocket; <br>    lpProcTable-&gt;lpWSPEnumNetworkEvents = WSPEnumNetworkEvents; <br>    lpProcTable-&gt;lpWSPEventSelect = WSPEventSelect; <br>    lpProcTable-&gt;lpWSPGetOverlappedResult = WSPGetOverlappedResult; <br>    lpProcTable-&gt;lpWSPGetPeerName = WSPGetPeerName; <br>    lpProcTable-&gt;lpWSPGetSockName = WSPGetSockName; <br>    lpProcTable-&gt;lpWSPGetSockOpt = WSPGetSockOpt; <br>    lpProcTable-&gt;lpWSPGetQOSByName = WSPGetQOSByName; <br>    lpProcTable-&gt;lpWSPIoctl = WSPIoctl; <br>    lpProcTable-&gt;lpWSPJoinLeaf = WSPJoinLeaf; <br>    lpProcTable-&gt;lpWSPListen = WSPListen; <br>    lpProcTable-&gt;lpWSPRecv = WSPRecv; <br>    lpProcTable-&gt;lpWSPRecvDisconnect = WSPRecvDisconnect; <br>    lpProcTable-&gt;lpWSPRecvFrom = WSPRecvFrom; <br>    lpProcTable-&gt;lpWSPSelect = WSPSelect; <br>    lpProcTable-&gt;lpWSPSend = WSPSend; <br>    lpProcTable-&gt;lpWSPSendDisconnect = WSPSendDisconnect; <br>    lpProcTable-&gt;lpWSPSendTo = WSPSendTo; <br>    lpProcTable-&gt;lpWSPSetSockOpt = WSPSetSockOpt; <br>    lpProcTable-&gt;lpWSPShutdown = WSPShutdown; <br>    lpProcTable-&gt;lpWSPSocket = WSPSocket; <br>    lpProcTable-&gt;lpWSPStringToAddress = WSPStringToAddress; <br> <br>    return(ERROR_SUCCESS); <br>     <br>} // WSPStartup </code></pre>
<p>&nbsp;</p></body>
</HTML>
