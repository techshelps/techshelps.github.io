<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRTEST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5320"></a>SRTEST.CPP</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1998 Microsoft Corporation <br> <br>Copyright (c) 1996 Intel Corp <br> <br>Module Name: <br> <br>    perftest.cpp <br> <br>Abstract: <br> <br>    This  module  contains  demonstration code which illustrates how to install <br>    and  use  a  service provider.  This demonstration code is designed to work <br>    together only with the temporary sample skeleton "null" service provider. <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include "nullpdef.h" <br>#include "ws2spi.h" <br> <br> <br> <br>// <br>//  Unique GUID generated with UUIDGEN: <br>//   ba657007-d615-11cf-9f5c-08003e301875 <br>// <br>//  WARNING:  If you use this sample code, you must generate your own <br>//   GUID.  Under no circumstances should you use this GUID. <br>// <br> <br>GUID ProviderIDGuid = { 0xba657007, 0xd615, 0x11cf, 0x9f, 0x5c, <br>                     0x08, 0x00, 0x3e, 0x30, 0x18, 0x75 }; <br> <br> <br>// <br>// Dummy name as unicode string <br>// <br> <br>#define SAMPLE_NAME_WSTRING L"Null Provider protocol for sample" <br> <br>// The  nominal  size  of  send  and  receive operations.  Since we expect this <br>// sample code to be used only with a "null" provider that does not really send <br>// or receive data, the value is arbitrary and has no real effect. <br> <br>#define SEND_RECEIVE_BYTES  100 <br> <br> <br> <br>  <br>static <br>void <br>Test_Send( <br>    IN  SOCKET  SendSock, <br>    IN  DWORD   NumTries <br>    ) <br>/*++ <br>Routine Description: <br> <br>    This  procedure  performs the indicated number of send operations through a <br>    socket. <br> <br>Arguments: <br> <br>    SendSock - Supplies the socket to be used for the "send" operations. <br> <br>    NumTries - Supplies the number of tries. <br> <br>Return Value: <br> <br>    none <br> <br>Implementation: <br> <br>    We  use  an "unrolled" loop to perform a large number of calls back-to-back <br>    without  loop turnaround overhead.  Then we perform the remaining number of <br>    calls.   This  should  help  reduce  the  overall  contribution of the loop <br>    overhead,  which  might  be  relevant  if this were being used as part of a <br>    performance measurement. <br>--*/ <br>{ <br>    DWORD    unrolled_iterations; <br>    DWORD    remaining_iterations; <br>    DWORD    i; <br>    int      send_result; <br>    WSABUF   send_bufs; <br>    CHAR     data_space[SEND_RECEIVE_BYTES]; <br>    DWORD    bytes_sent; <br> <br>#define SEND_ONCE \ <br>    send_result = WSASend(                       \ <br>        SendSock,      /* s                   */ \ <br>        &amp; send_bufs,   /* lpBuffers           */ \ <br>        1,             /* dwBufferCount       */ \ <br>        &amp; bytes_sent,  /* lpNumberOfBytesSent */ \ <br>        0,             /* dwFlags             */ \ <br>        NULL,          /* lpOverlapped        */ \ <br>        NULL)          /* lpCompletionRoutine */ <br> <br>#define UNROLLED_LENGTH 50 <br> <br>    unrolled_iterations  = NumTries / UNROLLED_LENGTH; <br>    remaining_iterations = NumTries % UNROLLED_LENGTH; <br>    send_bufs.len = SEND_RECEIVE_BYTES; <br>    send_bufs.buf = data_space; <br> <br>    for (i = 0; i &lt; unrolled_iterations; i++) { <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>        SEND_ONCE; <br>    } // for i <br> <br>    for (i = 0; i &lt; remaining_iterations; i++) { <br>        SEND_ONCE; <br>    } // for i <br>     <br>} // Test_Send <br> <br> <br> <br>  <br>static <br>SOCKET <br>Create_Test_Socket( <br>    void) <br>/*++ <br>Routine Description: <br> <br>    This  procedure  creates a socket to be used for the tests through the null <br>    provider. <br> <br>Arguments: <br> <br>    none <br>     <br>Return Value: <br> <br>    The  procedure  returns  the  newly  created  socket  if  it is successful, <br>    otherwise it returns INVALID_SOCKET. <br>--*/ <br>{ <br>    SOCKET  new_socket; <br> <br>    new_socket = WSASocket( <br>        AF_SPECIAL_NULL,   // af <br>        SOCK_STREAM,       // type <br>        0,                 // protocol <br>        NULL,              // lpProtocolInfo <br>        0,                 // g <br>        0);                // dwFlags <br>    return(new_socket); <br> <br>} // Create_Test_Socket <br> <br> <br> <br>  <br>static <br>void <br>Destroy_Test_Socket( <br>    IN  SOCKET  TestSock <br>    ) <br>/*++ <br>Routine Description: <br> <br>    This  procedure  closes  a socket that was being used for tests through the <br>    null provider. <br> <br>Arguments: <br> <br>    TestSock - Supplies the socket to be closed. <br>     <br>Return Value: <br> <br>    none <br>--*/ <br>{ <br>    int    close_result; <br>    DWORD  last_error; <br> <br>    close_result = closesocket( <br>        TestSock); <br>    if (close_result != ERROR_SUCCESS) { <br>        last_error = GetLastError(); <br>        last_error = GetLastError();  // Redundant for single-step convenience. <br>    } <br>     <br>} // Destroy_Test_Socket <br> <br> <br> <br>  <br>static <br>DWORD <br>Establish_Provider( <br>    void <br>    ) <br>/*++ <br>Routine Description: <br> <br>    This procedure makes sure the null provider is installed and installs it if <br>    it is not already installed. <br> <br>    Normally  an  application  program  would  NOT actually install a provider. <br>    Installation  was  bundled into this application example simply to make the <br>    example compact. <br> <br>Arguments: <br> <br>    none <br>     <br>Return Value: <br> <br> <br>--*/ <br>{ <br>    LPWSAPROTOCOL_INFOW  proto_buf; <br>    DWORD                size_guess; <br>    BOOL                 still_trying; <br>    BOOL                 got_protos; <br>    int                  enum_result; <br>    int                  error_code; <br>    BOOL                 found_null_prov; <br> <br>    size_guess = 0; <br>    got_protos = FALSE; <br>    still_trying = TRUE; <br>    proto_buf = NULL; <br> <br>    // We  call  WSCEnumProtocols  twice.   The first call determines how big a <br>    // buffer  we will actually need for the results.  The second call actually <br>    // retrieves  the  results.  In a situation such as this, I generally write <br>    // the  sequence  of  two  calls  as  a  loop,  since this way the call and <br>    // error-check code has to be written only once. <br>    while (still_trying) { <br>        enum_result = WSCEnumProtocols( <br>            NULL,           // lpiProtocols <br>            proto_buf,      // lpProtocolBuffer <br>            &amp; size_guess,   // lpdwBufferLength <br>            &amp; error_code);  // lpErrno <br>        if (enum_result != SOCKET_ERROR) { <br>            got_protos = TRUE; <br>            still_trying = FALSE; <br>        } <br>        else { <br>            if (error_code == WSAENOBUFS) { <br>                delete proto_buf; <br>                proto_buf = (LPWSAPROTOCOL_INFOW) new char[size_guess]; <br>                if (proto_buf == NULL) { <br>                    still_trying = FALSE; <br>                } <br>            } <br>            else { <br>                still_trying = FALSE; <br>            } <br>        } <br>    } // while still_trying <br> <br>    found_null_prov = FALSE; <br>    if (got_protos) { <br>        int  i; <br> <br>        for (i = 0; i &lt; enum_result; i++) { <br>            if (proto_buf[i].iAddressFamily == AF_SPECIAL_NULL) { <br>                found_null_prov = TRUE; <br>                break; <br>            } <br>        } <br>    } <br>    delete proto_buf; <br> <br>    if (! found_null_prov) { <br>        WSAPROTOCOL_INFOW proto_info; <br>        int               install_result; <br>        int               install_error; <br> <br>        proto_info.dwServiceFlags1 = 0; <br>        proto_info.dwServiceFlags2 = 0; <br>        proto_info.dwServiceFlags3 = 0; <br>        proto_info.dwServiceFlags4 = 0; <br>        proto_info.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO; <br>        proto_info.dwCatalogEntryId = 0;   // filled in by system <br>        proto_info.ProtocolChain.ChainLen = BASE_PROTOCOL; <br>        proto_info.iVersion = 0; <br>        proto_info.iAddressFamily = AF_SPECIAL_NULL; <br>        proto_info.iMaxSockAddr = 16; <br>        proto_info.iMinSockAddr = 16; <br>        proto_info.iSocketType = SOCK_STREAM; <br>        proto_info.iProtocol = 0; <br>        proto_info.iProtocolMaxOffset = 0; <br>        proto_info.iNetworkByteOrder = BIGENDIAN; <br>        proto_info.iSecurityScheme = SECURITY_PROTOCOL_NONE; <br>        proto_info.dwMessageSize = 0;  // stream-oriented <br>        proto_info.dwProviderReserved = 0; <br> <br>        proto_info.ProviderId = ProviderIDGuid ; // filled in by system. <br> <br>        // copy unicode string into name parameter <br>        memcpy(proto_info.szProtocol, SAMPLE_NAME_WSTRING, sizeof SAMPLE_NAME_WSTRING); <br> <br> <br>        install_result = WSCInstallProvider( <br>            &amp;ProviderIDGuid,   // lpProviderID <br>            L"nullprov.dll",   // lpszProviderDllPath (unicode string) <br>            &amp; proto_info,      // lpProtocolInfoList <br>            1,                 // dwNumberOfEntries <br>            &amp; install_error);  // lpErrno <br>        if (install_result != ERROR_SUCCESS) { <br>            install_error = install_error; <br>            // assert(install_result == ERROR_SUCCESS); <br>        } <br>    } // if not found_null_prov <br> <br>    return(TRUE); <br>     <br>} // Establish_Provider <br>     <br> <br> <br>  <br>void <br>main( <br>    void <br>    ) <br>/*++ <br>--*/ <br>{ <br>    SOCKET   test_sock; <br>    int      start_return; <br>    WSADATA  winsock_data; <br>    DWORD    last_error; <br>    int      clean_return; <br>    DWORD    num_tries; <br> <br>    Establish_Provider(); <br> <br>    start_return = WSAStartup( <br>        MAKEWORD(2,0),    // wVersionRequested <br>        &amp; winsock_data);  // lpWSAData <br> <br>    if (start_return == ERROR_SUCCESS) { <br>        test_sock = Create_Test_Socket(); <br>        // To  keep  this  sample  simple,  this  demonstration program and the <br>        // matching  null  provider  do  not  bother  binding or connecting the <br>        // socket  before  doing  "send" operations.  With a real provider, one <br>        // should  bind  and possibly also connect the socket before proceeding <br>        // with a "send". <br>        if (test_sock != INVALID_SOCKET) { <br>            num_tries = 10; <br>            Test_Send( <br>                test_sock,   // SendSock <br>                num_tries);  // NumTries <br>            Destroy_Test_Socket( <br>                test_sock); <br>        } // if test_sock != NULL <br>        else { <br>            last_error = GetLastError(); <br>            // The  following  is  just  a  redundant executable statement that <br>            // allows   me   to   see   the   return  value  conveniently  when <br>            // single-stepping. <br>            last_error = GetLastError(); <br>        } <br>    } // if start_return == ERROR_SUCCESS <br>    else { <br>        last_error = GetLastError(); <br>        last_error = GetLastError();  // Redundant for single-step convenience. <br>    } <br> <br>    clean_return = WSACleanup(); <br>    clean_return = clean_return; // Redundant for single-step convenience. <br>     <br>} // main <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
