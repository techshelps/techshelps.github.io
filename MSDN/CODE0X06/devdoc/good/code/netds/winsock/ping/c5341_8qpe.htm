<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PING.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5342"></a>PING.C</h2>
<pre><code>/******************************************************************************\ <br>* ping.c - Simple ping utility using SOCK_RAW <br>*  <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1996 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#pragma pack(4) <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;winsock2.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#define ICMP_ECHO 8 <br>#define ICMP_ECHOREPLY 0 <br> <br>#define ICMP_MIN 8 // minimum 8 byte icmp packet (just header) <br> <br>/* The IP header */ <br>typedef struct iphdr { <br>unsigned int h_len:4;          // length of the header <br>unsigned int version:4;        // Version of IP <br>unsigned char tos;             // Type of service <br>unsigned short total_len;      // total length of the packet <br>unsigned short ident;          // unique identifier <br>unsigned short frag_and_flags; // flags <br>unsigned char  ttl;  <br>unsigned char proto;           // protocol (TCP, UDP etc) <br>unsigned short checksum;       // IP checksum <br> <br>unsigned int sourceIP; <br>unsigned int destIP; <br> <br>}IpHeader; <br> <br>// <br>// ICMP header <br>// <br>typedef struct _ihdr { <br>  BYTE i_type; <br>  BYTE i_code; /* type sub code */ <br>  USHORT i_cksum; <br>  USHORT i_id; <br>  USHORT i_seq; <br>  /* This is not the std header, but we reserve space for time */ <br>  ULONG timestamp; <br>}IcmpHeader; <br> <br>#define STATUS_FAILED 0xFFFF <br>#define DEF_PACKET_SIZE 32 <br>#define MAX_PACKET 1024 <br> <br>#define xmalloc(s) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,(s)) <br>#define xfree(p)   HeapFree (GetProcessHeap(),0,(p)) <br> <br>void fill_icmp_data(char *, int); <br>USHORT checksum(USHORT *, int); <br>void decode_resp(char *,int ,struct sockaddr_in *); <br> <br>void Usage(char *progname){ <br>   <br>  fprintf(stderr,"Usage:\n"); <br>  fprintf(stderr,"%s &lt;host&gt; [data_size]\n",progname); <br>  fprintf(stderr,"datasize can be up to 1Kb\n"); <br>  ExitProcess(STATUS_FAILED); <br> <br>} <br>int main(int argc, char **argv){ <br> <br>  WSADATA wsaData; <br>  SOCKET sockRaw; <br>  struct sockaddr_in dest,from; <br>  struct hostent * hp; <br>  int bread,datasize; <br>  int fromlen = sizeof(from); <br>  int timeout = 1000; <br>  char *dest_ip; <br>  char *icmp_data; <br>  char *recvbuf; <br>  unsigned int addr=0; <br>  USHORT seq_no = 0; <br> <br>  if (WSAStartup(MAKEWORD(2,1),&amp;wsaData) != 0){ <br>fprintf(stderr,"WSAStartup failed: %d\n",GetLastError()); <br>ExitProcess(STATUS_FAILED); <br>  } <br> <br>  if (argc &lt;2 ) { <br>Usage(argv[0]); <br>  } <br>  sockRaw = WSASocket (AF_INET, <br>   SOCK_RAW, <br>   IPPROTO_ICMP, <br>   NULL, 0,0); <br>   <br>  if (sockRaw == INVALID_SOCKET) { <br>fprintf(stderr,"WSASocket() failed: %d\n",WSAGetLastError()); <br>ExitProcess(STATUS_FAILED); <br>  } <br>  bread = setsockopt(sockRaw,SOL_SOCKET,SO_RCVTIMEO,(char*)&amp;timeout, <br>  sizeof(timeout)); <br>  if(bread == SOCKET_ERROR) { <br>  fprintf(stderr,"failed to set recv timeout: %d\n",WSAGetLastError()); <br>ExitProcess(STATUS_FAILED); <br>  } <br>  timeout = 1000; <br>  bread = setsockopt(sockRaw,SOL_SOCKET,SO_SNDTIMEO,(char*)&amp;timeout, <br>  sizeof(timeout)); <br>  if(bread == SOCKET_ERROR) { <br>  fprintf(stderr,"failed to set send timeout: %d\n",WSAGetLastError()); <br>ExitProcess(STATUS_FAILED); <br>  } <br>  memset(&amp;dest,0,sizeof(dest)); <br> <br>  hp = gethostbyname(argv[1]); <br> <br>  if (!hp){ <br>addr = inet_addr(argv[1]); <br>  } <br>  if ((!hp)  &amp;&amp; (addr == INADDR_NONE) ) { <br>fprintf(stderr,"Unable to resolve %s\n",argv[1]); <br>ExitProcess(STATUS_FAILED); <br>  } <br> <br>  if (hp != NULL) <br>  memcpy(&amp;(dest.sin_addr),hp-&gt;h_addr,hp-&gt;h_length); <br>  else <br>  dest.sin_addr.s_addr = addr; <br> <br>  if (hp) <br>  dest.sin_family = hp-&gt;h_addrtype; <br>  else <br>  dest.sin_family = AF_INET; <br> <br>  dest_ip = inet_ntoa(dest.sin_addr); <br> <br>  if (argc &gt;2) { <br>datasize = atoi(argv[2]); <br>if (datasize == 0) <br>  datasize = DEF_PACKET_SIZE; <br> <br>  } <br>  else <br>  datasize = DEF_PACKET_SIZE; <br> <br>  datasize += sizeof(IcmpHeader);   <br> <br>  icmp_data = xmalloc(MAX_PACKET); <br>  recvbuf = xmalloc(MAX_PACKET); <br> <br>  if (!icmp_data) { <br>fprintf(stderr,"HeapAlloc failed %d\n",GetLastError()); <br>ExitProcess(STATUS_FAILED); <br>  } <br>   <br> <br>  memset(icmp_data,0,MAX_PACKET); <br>  fill_icmp_data(icmp_data,datasize); <br> <br>  while(1) { <br>int bwrote; <br> <br>((IcmpHeader*)icmp_data)-&gt;i_cksum = 0; <br>((IcmpHeader*)icmp_data)-&gt;timestamp = GetTickCount(); <br> <br>((IcmpHeader*)icmp_data)-&gt;i_seq = seq_no++; <br>((IcmpHeader*)icmp_data)-&gt;i_cksum = checksum((USHORT*)icmp_data,  <br>datasize); <br> <br>bwrote = sendto(sockRaw,icmp_data,datasize,0,(struct sockaddr*)&amp;dest, <br>sizeof(dest)); <br>if (bwrote == SOCKET_ERROR){ <br>  if (WSAGetLastError() == WSAETIMEDOUT) { <br>  printf("timed out\n"); <br>continue; <br>  } <br>  fprintf(stderr,"sendto failed: %d\n",WSAGetLastError()); <br>  ExitProcess(STATUS_FAILED); <br>} <br>if (bwrote &lt; datasize ) { <br>  fprintf(stdout,"Wrote %d bytes\n",bwrote); <br>} <br>bread = recvfrom(sockRaw,recvbuf,MAX_PACKET,0,(struct sockaddr*)&amp;from, <br> &amp;fromlen); <br>if (bread == SOCKET_ERROR){ <br>  if (WSAGetLastError() == WSAETIMEDOUT) { <br>  printf("timed out\n"); <br>continue; <br>  } <br>  fprintf(stderr,"recvfrom failed: %d\n",WSAGetLastError()); <br>  ExitProcess(STATUS_FAILED); <br>} <br>decode_resp(recvbuf,bread,&amp;from); <br>Sleep(1000); <br> <br>  } <br>  return 0; <br> <br>} <br>/*  <br>The response is an IP packet. We must decode the IP header to locate  <br>the ICMP data  <br>*/ <br>void decode_resp(char *buf, int bytes,struct sockaddr_in *from) { <br> <br>IpHeader *iphdr; <br>IcmpHeader *icmphdr; <br>unsigned short iphdrlen; <br> <br>iphdr = (IpHeader *)buf; <br> <br>iphdrlen = iphdr-&gt;h_len * 4 ; // number of 32-bit words *4 = bytes <br> <br>if (bytes  &lt; iphdrlen + ICMP_MIN) { <br>printf("Too few bytes from %s\n",inet_ntoa(from-&gt;sin_addr)); <br>} <br> <br>icmphdr = (IcmpHeader*)(buf + iphdrlen); <br> <br>if (icmphdr-&gt;i_type != ICMP_ECHOREPLY) { <br>fprintf(stderr,"non-echo type %d recvd\n",icmphdr-&gt;i_type); <br>return; <br>} <br>if (icmphdr-&gt;i_id != (USHORT)GetCurrentProcessId()) { <br>fprintf(stderr,"someone else's packet!\n"); <br>return ; <br>} <br>printf("%d bytes from %s:",bytes, inet_ntoa(from-&gt;sin_addr)); <br>printf(" icmp_seq = %d. ",icmphdr-&gt;i_seq); <br>printf(" time: %d ms ",GetTickCount()-icmphdr-&gt;timestamp); <br>printf("\n"); <br> <br>} <br> <br> <br>USHORT checksum(USHORT *buffer, int size) { <br> <br>  unsigned long cksum=0; <br> <br>  while(size &gt;1) { <br>cksum+=*buffer++; <br>size -=sizeof(USHORT); <br>  } <br>   <br>  if(size ) { <br>cksum += *(UCHAR*)buffer; <br>  } <br> <br>  cksum = (cksum &gt;&gt; 16) + (cksum &amp; 0xffff); <br>  cksum += (cksum &gt;&gt;16); <br>  return (USHORT)(~cksum); <br>} <br>/*  <br>Helper function to fill in various stuff in our ICMP request. <br>*/ <br>void fill_icmp_data(char * icmp_data, int datasize){ <br> <br>  IcmpHeader *icmp_hdr; <br>  char *datapart; <br> <br>  icmp_hdr = (IcmpHeader*)icmp_data; <br> <br>  icmp_hdr-&gt;i_type = ICMP_ECHO; <br>  icmp_hdr-&gt;i_code = 0; <br>  icmp_hdr-&gt;i_id = (USHORT)GetCurrentProcessId(); <br>  icmp_hdr-&gt;i_cksum = 0; <br>  icmp_hdr-&gt;i_seq = 0; <br>   <br>  datapart = icmp_data + sizeof(IcmpHeader); <br>  // <br>  // Place some junk in the buffer. <br>  // <br>  memset(datapart,'E', datasize - sizeof(IcmpHeader)); <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
