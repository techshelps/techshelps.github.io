<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PING.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5327"></a>PING.C</h2>
<pre><code>/****************************************************************************\ <br>*  ping.c -- sample program demonstrating NWLink. <br>* <br>*       Microsoft Developer Support <br>*       Copyright 1992 - 1998 Microsoft Corporation <br>* <br>*  This program is a simple example of opening a socket, <br>*   binding to the socket, receiving a packet and sending <br>*  that packet back to the original sender. <br>*  <br>****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnwlink.h&gt; <br>#include "../testlib/testlib.h" <br> <br>/* <br>*   Sockaddr structures  <br>*/ <br> <br>SOCKADDR_IPX addr; <br>SOCKADDR_IPX baddr; <br>SOCKADDR_IPX raddr; <br>int addrlen; <br> <br>/* <br>*   Function Prototypes  <br>*/ <br> <br>extern int main(int, char **); <br>extern int net_init(SOCKET *); <br>extern int do_ping(SOCKET); <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  main( int argc, char **argv ) <br>* <br>*    PURPOSE:   This is the main entry for the program <br>*        <br>* <br>*    ARGUMENTS:argc = Number of arguments <br>*               argv = Array of ptrs to cmd line args <br>*                 <br>* <br>* RETURNS:   Exit code for the program <br>* <br>*\***************************************************************************/ <br>int main(int argc, char **argv) <br>{ <br>    SOCKET s; <br> <br>    /* <br>    *   Set our default values before calling parse_cmd_line  <br>    */ <br> <br>    *Local_Socket_Number = 0x30; <br>    *(Local_Socket_Number+1) = 0x00; <br>    Receive_Length = 2048; <br> <br>    /* <br>    *   Get any command line options  <br>    */ <br> <br>    parse_cmd_line(argc, argv); <br> <br>    /* <br>    *   Initialize the network and set up our socket  <br>    */ <br> <br>    if (net_init(&amp;s)) <br>        return 1; <br> <br>    do_ping(s); <br> <br>    /* <br>    *   All done (We only get here on error)  <br>    */ <br> <br>    if (verbose) <br>        printf("calling closesocket()"); <br> <br>    closesocket(s); <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  net_init( SOCKET *skt ) <br>* <br>*    PURPOSE:   Initializes the WinSock stuff and sets up our socket. <br>*        <br>* <br>*    ARGUMENTS:SOCKET * =&gt; struct to receive our socket info <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int net_init(SOCKET *skt) <br>{ <br>    int rc, addrlen; <br>    WSADATA wsdata; <br>    SOCKET s; <br>    WORD    wVersionRequested; <br> <br>    /* <br>    *   Initialize with the WINSOCK library  <br>    */ <br> <br>    if (verbose) <br>        printf("calling WSAStartup(), "); <br> <br>    wVersionRequested = MAKEWORD(1,1); <br>    rc = WSAStartup(wVersionRequested, &amp;wsdata); <br> <br>    if (verbose) <br>        printf("return = 0x%X (%d)\n", rc, rc); <br> <br>    if (rc) { <br>        printf("WSAStartup failed: error code = %d\n", rc); <br>        return 1; <br>    } <br> <br>    if (verbose) { <br>        printf("contents of wsdata struct: \n"); <br>        print_wsa(&amp;wsdata); <br>    } <br> <br>    if (verbose) <br>        printf("calling socket(address family = %d, socket type = %d, protocol = %d)\n", Local_Address_Family, Socket_Type, Protocol); <br> <br>    /* <br>    *   Open a DATAGRAM socket with IPX  <br>    */ <br> <br>    s = socket(AF_NS, SOCK_DGRAM, NSPROTO_IPX); <br> <br>    if (verbose) <br>        printf("socket() returned 0x%lX\n", s); <br> <br>    if (s == INVALID_SOCKET) { <br>        dos_net_perror("Socket call failed"); <br>        exit(1); <br>    } <br> <br>    /* <br>    *   Bind to a socket.  We want to bind to a well known <br>    *   socket so that the app. that sends us a packet will <br>    *   know where to send it. <br>    */ <br> <br>    addr.sa_family = Local_Address_Family; <br> <br>    memcpy(&amp;addr.sa_netnum, Local_Network_Number, 4); <br>    memcpy(&amp;addr.sa_nodenum, Local_Node_Number, 6); <br>    memcpy(&amp;addr.sa_socket, Local_Socket_Number, 2); <br> <br>    if (verbose) { <br>        printf("calling bind():\n  "); <br>        print_saddr(&amp;addr); <br>    } <br> <br>    rc = bind(s, (const struct sockaddr *) &amp;addr, 16); <br> <br>    if (verbose) <br>        printf("bind() returned 0x%X\n", rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error binding to socket"); <br>        closesocket(s); <br>        return 1; <br>    } <br>    /* <br>    *   Set the packet type for this socket  <br>    */ <br> <br>    if (verbose) <br>        printf("Calling setsockopt for packet type %d\n", Local_Packet_Type); <br> <br>    rc = setsockopt(s, SOL_SOCKET, IPX_PTYPE, (const char *) &amp;Local_Packet_Type, 4); <br> <br>    if (rc == SOCKET_ERROR) <br>        dos_net_perror("setsockopt() call failed"); <br> <br> <br>    /* <br>    *   Get the address we bound to and print it out  <br>    */ <br> <br>    if (verbose) <br>        printf("Calling getsockname(socket = %d), "); <br> <br>    addrlen = 16; <br>    rc = getsockname(s, (struct sockaddr *) &amp;baddr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("return = 0x%X (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error getting socket name"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Print out the network address  <br>    */ <br> <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(baddr.sa_netnum, "Bound address = ", "\n"); <br>    } <br> <br>    if (verbose) <br>        printf("Allocating %d byte receive buffer\n", Receive_Length); <br> <br>    /* <br>    *   Set up socket to send back  <br>    */ <br> <br>    *skt = s; <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  do_ping( SOCKET s ) <br>* <br>*    PURPOSE:   This will receive a packet then send it back. <br>*        <br>*    ARGUMENTS:SOCKET socket we are transmitting on. <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int do_ping(SOCKET s) <br>{ <br>    LPSTR recvbuf; <br>    int nbytes, rc, errflag = 0; <br>    int rcvpkts = 0, sndpkts = 0; <br> <br>    /* <br>    *   Allocate a buffer for receives  <br>    */ <br> <br>    recvbuf = malloc(Receive_Length); <br> <br>    if (!recvbuf) { <br>        printf("Error allocating %d bytes for receive buffer\n", Receive_Length); <br>        return 1; <br>    } <br> <br>    /* <br>    *   This loop will receive a packet and then send <br>    *   it back to whoever sent it to us. <br>* <br>*      To exit the loop - hit CTRL-C. <br>    */ <br> <br>    while (1) { <br> <br>        /* <br>        *   Recv a packet  <br>        */ <br> <br>        /* <br>        *    NOTE:  If you want to know the packet type field of the <br>        *           packet you just received, look at the byte at <br>*           raddr.sa_ptype.  The addrlen returned will be <br>*           15. <br>* <br>        *           By using the addrlen field unchanged when sending <br>        *           the packet back, you will send the packet back with <br>        *           the same packet type that is was sent with originally <br>        */ <br> <br>        addrlen = 16; <br> <br>        if (verbose) <br>            printf("calling recvfrom(socket = %d, len = %d)\n", s, Receive_Length); <br> <br>        nbytes = recvfrom(s, recvbuf, Receive_Length, 0, (struct sockaddr *) &amp;raddr, &amp;addrlen); <br> <br>        /* <br>        *   If error - print it and exit  <br>        */ <br> <br>        if (nbytes == SOCKET_ERROR) { <br>            dos_net_perror("recvfrom() failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (verbose) { <br>            printf("received %d bytes, raddr = \n  ", nbytes); <br>            print_saddr(&amp;raddr); <br>        } <br> <br>        if (!verbose) <br>            printf("\rRecv packet number %d", ++rcvpkts); <br> <br>        /* <br>        *   Send the data back  <br>        */ <br> <br>        if (verbose) <br>            printf("calling sendto(socket = %d, len = %d\n", s, nbytes); <br> <br>addrlen = 16; <br>        rc = sendto(s, recvbuf, nbytes, 0, (const struct sockaddr *) &amp;raddr, addrlen); <br> <br>        if (verbose) <br>            printf("sendto() returned 0x%X\n", rc); <br> <br>        if (rc == SOCKET_ERROR) { <br>            dos_net_perror("sendto() failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (!verbose) <br>            printf(" : Send packet number %d", ++sndpkts); <br> <br>    } <br> <br>    if (verbose) <br>        printf("Freeing receive buffer\n"); <br> <br>    free(recvbuf); <br> <br>    return errflag; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
