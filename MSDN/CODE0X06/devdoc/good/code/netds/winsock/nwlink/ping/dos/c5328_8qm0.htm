<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOSPING.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5328"></a>DOSPING.C</h2>
<pre><code>/*===================================================================== <br>P I N G . C <br> <br>This is the DOS side ping program.  It uses Novell's IPX/SPX APIs, <br>requiring their SDK. It will send/receive 1-n IPX packets. <br>======================================================================*/ <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;nxtdos.h&gt; <br> <br>#define TIMER (unsigned long far *) 0x0000046cL <br> <br>char *progname; <br>IPXHeader *ipx; <br>int send_socket=0; <br>int recv_socket; <br>int datasize = 1; <br>ECB send_ecb;  <br>ECB recv_ecb[10]; <br>char mynodeaddr[6]; <br>char sendb[2048]; <br>char recvb[2048]; <br> <br>int ptype = 4; <br>int niters = 1; <br> <br>/** <br>    This is the address we try to send to.  When <br>    we find a server, this address is replaced by the address <br>    of the exact server.  The address is made up of: <br>    bytes 1-4    = network number <br>    bytes 5-10   = node number <br>    bytes 11-12  = socket address <br> <br>**/ <br> <br>char destaddr[12] = { <br>    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x00 <br>}; <br> <br>/** Function Prototypes **/ <br> <br>void   hang_recvs(void); <br>void   cancel_recvs(void); <br>void   do_recv(int); <br>int    get_recv(void); <br>void   find_a_server(void); <br>void   print_address(char *); <br>void   print_network(char *); <br>void   print_nodeaddr(char *); <br>void   parse_cmd_line(int, char **); <br>void   swap_dwf(char *); <br>char * get_node_number(char * cmd); <br>char * get_network_number(char * cmd); <br>/******************************************************************** <br>m a i n <br>*********************************************************************/ <br>int main(int argc, char **argv) <br>{ <br>    char *p; <br>    unsigned long start = *TIMER; <br>    unsigned long end; <br>    int cnt = 0; <br>    long sendpkt = 0L; <br>    long recvpkt = 0L; <br>    int ttime; <br>    float total = 0; <br> <br>    progname = *argv; <br>    for (p = progname; *p; p++) { <br>    if (*p == '\\') <br>progname = p + 1; <br>    } <br> <br>    /** Make sure IPX is loaded **/ <br> <br>    if (IPXInitialize()) { <br>printf("%s: IPX IS NOT LOADED\n", progname); <br>    exit(1); <br>    } <br>    recv_socket = *(short *)(destaddr + 10); <br>    parse_cmd_line(argc, argv); <br>    print_network(destaddr); <br>    print_nodeaddr(destaddr + 4); <br>    printf("packet type:    %d\n",ptype); <br>    printf("datasize:       %d\n", datasize); <br>    printf("n iterations:   %d\n", niters);     <br>     <br> <br> <br>    if (IPXOpenSocket(&amp;send_socket, 0)) { <br>printf("%s: ERROR: unable to open socket\n", progname); <br>exit(1); <br>    } <br>    recv_socket = send_socket; <br>    if (IPXGetLocalTarget(destaddr, send_ecb.immediateAddress, &amp;ttime)) { <br>printf("%s: ERROR: unable to get local target\n", progname); <br>exit(1); <br>    } <br> <br>    memcpy(mynodeaddr, send_ecb.immediateAddress, 6); <br> <br>    /** Go find a server **/ <br> <br>    find_a_server();  <br>hang_recvs(); <br> <br> <br>    /** Do # iterations (default = 1) **/ <br>while (cnt &lt; niters) { <br>    int rcv; <br>/** send a packet **/ <br>*(sendb + 5) = ptype; <br>    memcpy(sendb + 6, destaddr, 12); <br>    memcpy(send_ecb.immediateAddress, mynodeaddr, 6); <br>    send_ecb.socketNumber = send_socket; <br>    send_ecb.fragmentCount = 1; <br>    send_ecb.fragmentDescriptor[0].address = sendb; <br>    send_ecb.fragmentDescriptor[0].size = 30 + datasize; <br> <br>IPXSendPacket(&amp;send_ecb); <br> <br>while (send_ecb.inUseFlag) /* wait for it to finish */ <br>; <br> <br>if (send_ecb.completionCode) { <br>cancel_recvs(); <br>IPXCloseSocket(send_socket); <br>printf("%s: Error sending packet: %d\n", progname, send_ecb.completionCode); <br>exit(1); <br>} <br> <br>    sendpkt++; <br>    total += 30 + datasize;     /* Count the bytes */ <br>    printf("\rSend packet Number %d ", sendpkt); <br> <br>    if ((rcv = get_recv()) == -1) <br>goto EXIT; <br> <br>    do_recv(rcv); <br>    total += 30 + datasize;     /* Count the bytes */ <br> <br>    cnt++; <br>    recvpkt++; <br>    printf(": Recv packet Number %d ", recvpkt); <br>} <br> <br>/** We did 1000 packets - print KB per second **/ <br>EXIT: <br>end = *TIMER; <br>end = (end - start) / 18.2; /* Num seconds it took */ <br> <br>total = (float)((total / 1024.0) / end); <br> <br>    /** All done - cancel recvs and exit **/ <br>    cancel_recvs(); <br>    IPXCloseSocket(send_socket); <br>    printf("\n%ld packets \n", recvpkt); <br>    if (recvpkt) <br>printf("Average time per iteration: %5.3f\n",total/recvpkt); <br>    exit(0); <br>} <br> <br>/*page************************************************************** <br>h a n g _ r e c v s <br> <br>Arguments - None <br> <br>Returns - nothing <br>*******************************************************************/ <br>void hang_recvs(void) <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; 10; i++) { <br> <br>/** Don't hang recv on one that is already hung **/ <br> <br>if (recv_ecb[i].inUseFlag) <br>    continue; <br> <br>/** Hang a recv **/ <br> <br>memset(&amp;recv_ecb[i], 0, sizeof(ECB)); <br>recv_ecb[i].socketNumber = recv_socket; <br>recv_ecb[i].fragmentCount = 1; <br>recv_ecb[i].fragmentDescriptor[0].address = recvb; <br>recv_ecb[i].fragmentDescriptor[0].size = 2048; <br>IPXListenForPacket(&amp;recv_ecb[i]); <br>    } <br> <br>    /** All done **/ <br> <br>    return; <br>} <br> <br>/*page************************************************************** <br>c a n c e l _ r e c v s <br> <br>Arguments - None <br> <br>Returns - nothing <br>*******************************************************************/ <br>void cancel_recvs(void) <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; 10; i++) { <br> <br>/** If recv not in use - skip it **/ <br> <br>if (!recv_ecb[i].inUseFlag) <br>    continue; <br> <br>/** Cancel the recv **/ <br> <br>IPXCancelEvent(&amp;recv_ecb[i]); <br>    } <br> <br>    /** All done **/ <br> <br>    return; <br>} <br> <br>/*page************************************************************** <br>d o _ r e c v <br> <br>Arguments - i = recv index to hang <br> <br>Returns - nothing <br>*******************************************************************/ <br>void do_recv(int i) <br>{ <br>    memset(&amp;recv_ecb[i], 0, sizeof(ECB)); <br>    recv_ecb[i].socketNumber = recv_socket; <br>    recv_ecb[i].fragmentCount = 1; <br>    recv_ecb[i].fragmentDescriptor[0].address = recvb; <br>    recv_ecb[i].fragmentDescriptor[0].size = 2048; <br>    IPXListenForPacket(&amp;recv_ecb[i]); <br>    return; <br>} <br> <br>/*page************************************************************** <br>g e t _ r e c v <br> <br>Arguments - none <br> <br>Returns - -1 = User hit a key <br>  else = recv index that was hit <br>*******************************************************************/ <br>int get_recv(void) <br>{ <br>    int i; <br> <br>    /** **/ <br> <br>    while (!kbhit()) { <br>for (i = 0; i &lt; 10; i++) { <br>if (!recv_ecb[i].inUseFlag) <br>return i; <br>}                         <br>//      try resending the bugger...maybe we be out of synch?..bug,bug,bug???     <br>    IPXSendPacket(&amp;send_ecb);            <br>    } <br> <br>    /** Return that user hit a key **/ <br> <br>    return -1; <br>} <br> <br>/******************************************************************* <br>function name:      f i n d _ a _ s e r v e r <br>    Description:    make sure can find the machine we want to send to <br>    Arguments:      none <br>    Returns:        none <br>*********************************************************************/ <br>void find_a_server(void) <br>{ <br>    long start; <br>    long end; <br>    ECB send_ecb; <br>    ECB recv_ecb; <br> <br>    /** Setup the recv ecb and listen for a packet **/ <br> <br>    memset(&amp;recv_ecb, 0, sizeof(ECB)); <br>    recv_ecb.socketNumber = recv_socket; <br>    recv_ecb.fragmentCount = 1; <br>    recv_ecb.fragmentDescriptor[0].address = recvb; <br>    recv_ecb.fragmentDescriptor[0].size = 31; <br>    IPXListenForPacket(&amp;recv_ecb); <br> <br>    memset(&amp;send_ecb, 0, sizeof(ECB)); <br>    memcpy(sendb + 6, destaddr, 12); <br>    send_ecb.socketNumber = send_socket; <br>    memcpy(send_ecb.immediateAddress, mynodeaddr, 6); <br>    send_ecb.fragmentCount = 1; <br>    send_ecb.fragmentDescriptor[0].address = sendb; <br>    send_ecb.fragmentDescriptor[0].size = 31; <br> <br>    IPXSendPacket(&amp;send_ecb); <br> <br>    while (send_ecb.inUseFlag &amp;&amp; !kbhit()) <br>; <br> <br>    if (send_ecb.completionCode) { <br>printf("%s: ERROR: send completion code 0x%02x\n", progname, send_ecb.completionCode); <br>exit(1); <br>    } <br> <br>    /** Wait awhile for the recv to pay off **/ <br> <br>    start = *TIMER; <br> <br>    while (recv_ecb.inUseFlag &amp;&amp; !kbhit() &amp;&amp; (*TIMER - start) &lt; 180L) <br>; <br>    end = *TIMER; <br> <br>    /** If we timed out - then we couldn't find a server **/ <br> <br>    if (end - start &gt;= 180L) { <br>IPXCancelEvent(&amp;recv_ecb); <br>IPXCloseSocket(send_socket); <br>printf("%s: Unable to find a server\n", progname); <br>exit(1); <br>    } <br> <br>    /** If recv still in use - error **/ <br> <br>    if (recv_ecb.inUseFlag) { <br>IPXCancelEvent(&amp;recv_ecb); <br>IPXCloseSocket(send_socket); <br>printf("%s: Program terminated by a keystroke\n", progname); <br>exit(1); <br>    } <br> <br>    /** If recv error - clean up and exit **/ <br> <br>    if (recv_ecb.completionCode) { <br>IPXCancelEvent(&amp;recv_ecb); <br>IPXCloseSocket(send_socket); <br>printf("%s: Error receiving packet: %d\n", progname, recv_ecb.completionCode); <br>exit(1); <br>    } <br> <br>    /** Get the server address and print it out **/ <br> <br>    memcpy(destaddr, recvb + 18, 12);   /* Set the address to send to */ <br>    memcpy(mynodeaddr, recv_ecb.immediateAddress, 6); <br>    printf("Found server: "); <br>    print_address(destaddr); <br> <br>    /** All done **/ <br> <br>    return; <br>} <br> <br>/******************************************************************** <br>p r i n t _ a d d r e s s <br> <br>Arguments - netaddr = ptr to 14 bytes address to print <br> <br>Returns - nothing <br>*********************************************************************/ <br>void print_address(char *netaddr) <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; 12; i++) { <br>if ((i == 4) || (i == 10)) <br>    printf(" "); <br>printf("%02X", (unsigned char) *(netaddr + i)); <br>} <br>    printf("\n"); <br>    return; <br>} <br> <br>void print_network(char *p) <br>{ <br>    int i; <br>    printf("Network Number: "); <br>    for (i = 0; i &lt; 4; i++) <br>printf("%02X", (unsigned char) *p++); <br>    printf("\n"); <br>    return; <br>} <br> <br>void print_nodeaddr(char *p) <br>{ <br>    int i; <br> <br>    printf("Node Address:   "); <br>    for (i = 0; i &lt; 6; i++) <br>printf("%02X", (unsigned char) *p++); <br>    printf("\n"); <br>    return; <br>} <br> <br>/*----------------------------------------------------------------- <br>function name: parse_cmd_line <br>Description: <br>    Parse the command line for the parameters and host name. <br>Arguments:      <br>       -i &lt;number of iterations&gt; <br>       -p &lt;packet type&gt; <br>       -d &lt;data size&gt; <br>  NOTE: must be &lt; frame size - 14 (MAC length) - 30 (IPX header) <br>       -n &lt;network number&gt; <br>  NOTE: you can ignore this if on the same subnet.  Must be 4 hex <br>bytes <br>       -a &lt;destination address&gt; <br>  NOTE: must be 6 hex bytes representing the physical NIC address of <br>the remote machine. <br>       -s &lt;socket&gt; <br>  Two byte socket number <br>Returns:        Nothing <br>----------------------------------------------------------------------*/ <br>void parse_cmd_line(int argc, char **argv) <br>{ <br>    short socket; <br> <br>    argv++;                      /* skip to first arg */ <br>    while (--argc) {             /* do all args */ <br>if (**argv == '-') { <br>    ++(*argv); <br>    switch(tolower(**argv)) { <br>case 'i': <br>    niters = atoi(++(*argv)); <br>    if (niters &lt; 0)  <br>       niters = 1; <br>    break;    <br>case 'p': <br>    ptype = atoi(++(*argv)); <br>    if (ptype &lt; 0 || ptype &gt; 255) { <br>ptype = 4; <br>printf("%s: Invalid packet type.  Setting to default = %d\n", <br>progname,ptype); <br>    } <br>    break; <br>case 'd':  /*amount of data to send in a frame */ <br>    datasize = atoi(++(*argv)); <br>    if (!datasize) { <br>datasize = 1; <br>printf("%s: Datasize cannot be zero. Setting to default = 1\n", progname); <br>    } <br>    break; <br>case 's':  /* socket number, default = 0x3000 */ <br>    socket = (short)strtol(++(*argv), NULL, 16); <br>    printf("New socket = 0x%x\n", socket); <br>    *(short *)(destaddr + 10) = socket; <br>    swap_dwf(destaddr + 10); <br>    break; <br>case 'n':  /* network number, default = local net (= 0) */ <br>    ++(*argv); <br>    memcpy(destaddr, get_network_number(*argv),4); <br>    if (destaddr[0] == 'X') { <br>printf("\n****!\n%s is an incorrect net number.\n****!\n", *argv); <br>printf("%s E.G.: -nAABBCCDD (I.E.: 8 hex digits)\n"); <br>exit(1); <br>    } <br>    break; <br>case 'a': /* remote address, have to know this */ <br>    ++(*argv); <br>    memcpy(destaddr+4, get_node_number(*argv), 6); <br>    if (*(destaddr+4) == 'X') { <br>       printf("\n****!\n%s is an incorrect Node address.\n****!\n", *argv); <br>       printf("\n E.G.: -a 023C8DAADDCC (12 hex digits)\n"); <br>       exit(1); <br>    } <br>    break; <br>default: <br>    printf("%s [-p] [-d] [-nxxxxxxxx] [-axxxxxxxxxxxx] [-sx]\n", progname); <br>    printf("     -p - packet type\n"); <br>    printf("     -d - data size\n"); <br>    printf("     -n - network number (in hex)\n"); <br>    printf("     -a - address (in hex)\n"); <br>    printf("     -s - socket number (in hex)\n"); <br>    exit(0); <br>    } <br>    argv++; <br>} <br>    } <br>    return; <br>} <br>/********************************************************************** <br>    g e t _ h e x _ b y t e <br> <br>    Converts the character passed in to a hexadecimal nibble. <br> <br>    Arguments:    char    character to convert <br> <br>    Returns:      UCHAR   hex nibble <br>**************************************************************************/ <br>char get_hex_byte(char ch) <br>{ <br>    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') <br>    return (ch - '0'); <br> <br>    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') <br>    return ((ch - 'A') + 0x0A); <br> <br>    return -1; <br>} <br>/********************************************************************** <br>    g e t _ h e x _ s t r i n g <br> <br>    Reads in a character string containing hex digits and converts <br>    it to a hexadecimal number. <br> <br>    Arguments:    src   =&gt; source string to convert <br>  dest  =&gt; destination for hex number <br>  num   =&gt; number of chars to convert <br> <br>    Returns:      nothing <br>**************************************************************************/ <br>char get_hex_string(char * src, char * dest, int num) <br>{ <br>    char *   q = src; <br>    char     hexbyte1,hexbyte2; <br> <br>    strupr(q); <br>    while (num--) <br>      {hexbyte1 = get_hex_byte(*q++); <br>       hexbyte2 = get_hex_byte(*q++); <br>       if ( (hexbyte1 &lt; 0) || (hexbyte2 &lt; 0) ) <br>      return -1; <br>       *dest++ = (hexbyte1 &lt;&lt; 4) + hexbyte2; <br>      } <br> <br>    return(0); <br>} <br>/************************************************************************* <br>    g e t _ n o d e _ n u m b e r <br> <br>    Reads a node number from the given string. <br> <br>    Arguments:    cmd  =&gt; string to read from <br> <br>    Returns:      hex node number <br>**************************************************************************/ <br>char * get_node_number(char * cmd) <br>{ <br>    static char hex_num[6]; <br> <br>    memset(hex_num, 0, 6); <br> <br>    if (strlen(cmd) != 12){ <br>    hex_num[0] = 'X'; <br>    return hex_num; <br>       } <br> <br>    if (get_hex_string(cmd, hex_num, 6) &lt; 0) <br>    hex_num[0] = 'X'; <br>    return hex_num; <br>} <br>/************************************************************************** <br>    g e t _ n e t w o k _ n u m b e r <br> <br>    Reads a network number from the given string. <br> <br>    Arguments:    cmd   string to read from <br> <br>    Returns:      hex network number <br>**************************************************************************/ <br>char * get_network_number(char * cmd) <br>{ <br>    static char hex_num[4]; <br> <br>    memset(hex_num, 0, 4); <br> <br>    if (strlen(cmd) != 8) { <br>    hex_num[0] = 'X'; <br>    return(hex_num); <br>    } <br> <br>    if (get_hex_string(cmd, hex_num, 4) &lt; 0) <br>    hex_num[0] = 'X'; <br> <br>    return hex_num; <br>} <br>/******************************************************************* <br>s w a p _ d w f <br> <br>Swap the bytes pointed to by p. <br> <br>Arguments - p = ptr to word to swap <br> <br>Returns - nothing <br>********************************************************************/ <br>void swap_dwf(char *p) <br>{ <br>    char tmp; <br> <br>    tmp = *p; <br>    *p = *(p + 1); <br>    *(p + 1) = tmp; <br>    return; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
