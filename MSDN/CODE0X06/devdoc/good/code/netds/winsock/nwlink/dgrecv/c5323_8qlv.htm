<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DGRECV.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5323"></a>DGRECV.C</h2>
<pre><code>/****************************************************************************\ <br>*  dgrecv.c -- sample program demonstrating NWLink. <br>* <br>*       Microsoft Developer Support <br>*       Copyright 1992 - 1998 Microsoft Corporation <br>* <br>*  This program is a simple example of opening a socket, <br>*  binding to the socket, and waiting for a datagram packet. <br>*  <br>****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnwlink.h&gt; <br>#include "../testlib/testlib.h" <br> <br>/* <br>*   Sockaddr structures  <br>*/ <br> <br>SOCKADDR_IPX addr; <br>SOCKADDR_IPX baddr; <br>SOCKADDR_IPX raddr; <br> <br>/* <br>*   Function Prototypes  <br>*/ <br> <br>extern int main(int, char **); <br>extern int net_init(SOCKET *); <br>extern int dg_recv(SOCKET); <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  main( int argc, char **argv ) <br>* <br>*    PURPOSE:   This is the main entry for the program <br>*        <br>* <br>*    ARGUMENTS:argc = Number of arguments <br>*               argv = Array of ptrs to cmd line args <br>*                 <br>* <br>* RETURNS:   Exit code for the program <br>* <br>*\***************************************************************************/ <br>int main(int argc, char **argv) <br>{ <br>    SOCKET s; <br> <br>    /* <br>    *   Initialize our default values before checking the command line  <br>    */ <br> <br>    *Local_Socket_Number = 0x06; <br>    *(Local_Socket_Number+1) = 0x00; <br> <br>    /* <br>    *   Parse the command line to set up any command line options  <br>    */ <br> <br>    parse_cmd_line(argc, argv); <br> <br>    /* <br>    *   Initialize the network and set up our socket  <br>    */ <br> <br>    if (net_init(&amp;s)) <br>        return 1; <br> <br>    /* <br>    *   Do the receive thing  <br>    */ <br> <br>    if (dg_recv(s)) <br>        return 1; <br> <br>    /* <br>    *   All Done - Close up the socket and exit  <br>    */ <br> <br>    if (verbose) <br>printf("Calling closesocket()\n"); <br> <br>    closesocket(s); <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  net_init( SOCKET *skt ) <br>* <br>*    PURPOSE:   Initializes the WinSock stuff and sets up our socket. <br>*        <br>* <br>*    ARGUMENTS:SOCKET * =&gt; struct to receive our socket info <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int net_init(SOCKET *skt) <br>{ <br>    SOCKET s; <br>    int rc, addrlen = 16; <br>    WSADATA wsdata; <br>    WORD    wVersionRequested; <br> <br>    if (verbose) <br>        printf("Calling WSAStartup(), "); <br> <br>    /* <br>    *   Initialize with the WINSOCK library  <br>    */ <br> <br>    wVersionRequested = MAKEWORD(1,1); <br>    rc = WSAStartup(wVersionRequested, &amp;wsdata); <br> <br>    if (verbose) <br>        printf("return = 0x%X (%d)\n", rc, rc); <br> <br>    if (rc) { <br>        printf("WSAStartup failed: error code = %d\n", rc); <br>        return 1; <br>    } <br> <br>    if (verbose) { <br>        printf("Contents of wsadata struct:\n"); <br>        print_wsa(&amp;wsdata); <br>    } <br> <br>    /* <br>    *   Open a DATAGRAM socket with IPX  <br>    */ <br> <br>    if (verbose) <br>        printf("Calling socket(address family = %d, socket type = %d, protocol = %d)\n", Local_Address_Family, Socket_Type, Protocol); <br> <br>    s = socket(Local_Address_Family, Socket_Type, Protocol); <br> <br>    if (verbose) <br>printf("socket() returned 0x%X (%d)\n", s, s); <br> <br>    if (s == INVALID_SOCKET) { <br>        dos_net_perror("Socket call failed"); <br>        exit(1); <br>    } <br> <br>    /* <br>    *    Bind to a socket.  We dont care what socket we bind to, <br>    *    so we will send down all 0's <br>    */ <br> <br>    addr.sa_family = Local_Address_Family; <br> <br>    memcpy(&amp;addr.sa_netnum, Local_Network_Number, 4); <br>    memcpy(&amp;addr.sa_nodenum, Local_Node_Number, 6); <br>    memcpy(&amp;addr.sa_socket, Local_Socket_Number, 2); <br> <br>    if (verbose) { <br>        printf("calling bind(), local address =\n  "); <br>        print_saddr(&amp;addr); <br>    } <br> <br>    rc = bind(s, (struct sockaddr *) &amp;addr, 16); <br> <br>    if (verbose) <br>        printf("\nbind() returned 0x%X (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error binding to socket"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Get the address we bound to and print it out  <br>    */ <br> <br>    if (verbose) <br>        printf("calling getsockname(socket = %d), ", s); <br> <br>    rc = getsockname(s, (struct sockaddr *) &amp;baddr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("return = 0x%lX (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error getting socket name"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Set the packet type to send for this socket  <br>    */ <br> <br>    if (verbose) <br>        printf("Calling setsockopt for packet type %d\n", Local_Packet_Type); <br> <br>    rc = setsockopt(s, NSPROTO_IPX, IPX_PTYPE, (const char *) &amp;Local_Packet_Type, 4); <br> <br>    if (rc == SOCKET_ERROR) <br>        dos_net_perror("setsockopt() call failed"); <br> <br> <br>    if (Filter_Packet_Type) { <br> <br>        /* <br>        *   Set the packet type for this socket  <br>        */ <br> <br>        if (verbose) <br>            printf("Calling setsockopt to filter packet type %d\n", Filter_Packet_Type); <br> <br>rc = setsockopt(s, NSPROTO_IPX, IPX_FILTERPTYPE, (const char *) &amp;Filter_Packet_Type, sizeof(int)); <br>printf("RC from FILTER SOCKOPT = %d\n", rc); <br> <br>        if (rc == SOCKET_ERROR) <br>            dos_net_perror("setsockopt() call failed setting filter packet type"); <br>    } <br>    /* <br>    *   Print out the network address  <br>    */ <br> <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(baddr.sa_netnum, "  Bound to address ", "\n"); <br>    } <br> <br>    *skt = s; <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  dg_recv( SOCKET s ) <br>* <br>*    PURPOSE:   Receives datagrams. <br>* <br>*    ARGUMENTS:SOCKET   socket to receive on <br>* <br>* RETURNS:   0 if ok <br>*               1 if error <br>* <br>*\***************************************************************************/ <br>int dg_recv(SOCKET s) <br>{ <br>    int rc, errflag = 0; <br>    int addrlen = 16; <br>    UINT dgrams = 0; <br>    LPSTR recvbuf; <br> <br> <br>    if (verbose) <br>        printf("allocating %d bytes for receive buffer\n", Receive_Length); <br> <br>    /* <br>    *   Set up the data buffer to send  <br>    */ <br> <br>    recvbuf = (LPSTR)malloc(Send_Length); <br> <br>    if (!recvbuf) { <br>        printf("Error allocating %d bytes for receive buffer\n", Receive_Length); <br>        return 1; <br>    } <br> <br>    if (verbose) { <br>        printf("calling recvfrom(socket = %d, length = %d),\n", s, Receive_Length); <br>    } <br>    else <br>        printf("Waiting for call...\n"); <br> <br>    while (1) { <br>        /* <br>        *   Receive a packet from anyone  <br>        */ <br> <br>        rc = recvfrom(s, recvbuf, Receive_Length, 0, (struct sockaddr *)&amp;raddr, &amp;addrlen); <br> <br>        if (rc == SOCKET_ERROR) { <br>            dos_net_perror("recvfrom() failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (verbose) { <br>            printf("Received %d bytes from \n  ", rc); <br>            print_saddr(&amp;raddr); <br>            printf("\n"); <br>        } <br>        else <br>            printf("\rReceived packet %d, length = %d bytes", ++dgrams, rc); <br> <br> <br>        if (No_Loop) <br>            break; <br>    } <br> <br>    if (verbose) <br>        printf("Freeing receive buffer\n"); <br> <br>    free(recvbuf); <br> <br>    return errflag; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
