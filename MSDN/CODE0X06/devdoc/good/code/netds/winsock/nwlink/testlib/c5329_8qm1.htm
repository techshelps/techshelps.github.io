<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CMDLINE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5329"></a>CMDLINE.C</h2>
<pre><code>/****************************************************************************\ <br>*  cmdline.c -- sample program library demonstrating NWLink. <br>* <br>*       Microsoft Developer Support <br>*       Copyright 1992 - 1998 Microsoft Corporation <br>* <br>*  Demonstrates basic sockets programming with the Windows Sockets API <br>*  using the NWLink transport. <br>*  <br>****************************************************************************/ <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;ctype.h&gt; <br>#include "externs.h" <br>#include &lt;wsipx.h&gt; <br>#include "testlib.h" <br> <br>/* <br>*   Global variables that can be set on the command line  <br>*/ <br> <br>int     verbose = 0; <br>int     Socket_Type = SOCK_DGRAM; <br>int     Protocol = NSPROTO_IPX; <br>int     Backlog = 1; <br>int     No_Broadcast = 0; <br>int     No_Loop = 0; <br>int     Sleep_Time = 250; <br>int     Send_Length = 1024; <br>int     Receive_Length = 1024; <br>int     Local_Packet_Type = 0; <br>int     Send_Packet_Type = 9; <br>int     Filter_Packet_Type = 0; <br>int     Local_Address_Family = AF_NS; <br>int     Remote_Address_Family = AF_NS; <br>char    Local_Network_Number[4]  = {0x00, 0x00, 0x00, 0x00}; <br>char    Local_Node_Number[6]     = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; <br>char    Local_Socket_Number[2]   = {0x00, 0x00}; <br>char    Remote_Network_Number[4] = {0x00, 0x00, 0x00, 0x00}; <br>char    Remote_Node_Number[6]    = "\xFF\xFF\xFF\xFF\xFF\xFF"; <br>char    Remote_Socket_Number[2]  = {0x12, 0x34}; <br> <br>/* <br>*   Function prototypes for this file  <br>*/ <br> <br>void  usage(LPSTR); <br>void  dump_defaults(LPSTR); <br>void  get_hex_string(LPSTR, LPSTR, int); <br>UCHAR get_hex_byte(char); <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  parse_cmd_line( int argc, char **argv ) <br>* <br>*    DESCRIPTION:  Routine used by all of the WinSock test programs for NWLink. <br>*        Parses the command line and sets the respective global variables.  <br>* <br>*    ARGUMENTS: char **     =&gt; array of command line arguments <br>*                int         number of command line arguments <br>* <br>* RETURNS:  nothing <br>* <br>*\***************************************************************************/ <br>void parse_cmd_line(int argc, char **argv) <br>{ <br>    LPSTR p; <br>    int num = 1; <br> <br>    argc--; <br> <br>    /* <br>    *   Parse each command line parameter  <br>    */ <br> <br>    while (num &lt;= argc) { <br>        /* <br>        *   If option starts with '-' or '/', skip it  <br>        */ <br> <br>        p = strupr(argv[num++]); <br>        if (*p == '-' || *p == '/') <br>            p++; <br> <br>        /* <br>        *   Help ?  <br>        */ <br> <br>        printf("***&gt; command: %s\n:",p); <br>        if (*p == 'h' || *p == 'H' || *p == '?' || !stricmp(p, "help")) <br>    usage(argv[0]); <br> <br>        /* <br>        *   Verbose option?  <br>        */ <br> <br>        if (!stricmp(p, "v") || !stricmp(p, "verbose")) { <br>            verbose++; <br> <br>            printf("verbose is ON\n"); <br>            continue; <br>        } <br> <br>        /* <br>        *   Display default values ?  <br>        */ <br> <br>        if (!strnicmp(p, "default", 7)) { <br>            p+= 7; <br> <br>            dump_defaults(argv[0]); <br>        } <br> <br>        /* <br>        *   Local address family ?  <br>        */ <br> <br>        if (!strnicmp(p, "laf:", 4)) { <br>            p+= 4; <br> <br>            /* <br>            *   Get the address family from the option  <br>            */ <br> <br>            Local_Address_Family = atoi(p); <br> <br>            if (verbose) <br>                printf("Local_Address_Family = %d\n", Local_Address_Family); <br>            continue; <br>        } <br> <br>        /* <br>        *   Remote address family ?  <br>        */ <br> <br>        if (!strnicmp(p, "raf:", 4)) { <br>            p+= 4; <br> <br>            /* <br>            *   Get the address family from the option  <br>            */ <br> <br>            Remote_Address_Family = atoi(p); <br> <br>            if (verbose) <br>                printf("Remote_Address_Family = %d\n", Remote_Address_Family); <br>            continue; <br>        } <br> <br>        /* <br>        *   Socket type ?  <br>        */ <br> <br>        if (!strnicmp(p, "st:", 3)) { <br>            p+= 3; <br> <br>            /* <br>            *   Get the socket type from the option  <br>            */ <br> <br>            Socket_Type = atoi(p); <br>            if (verbose) <br>printf("Socket_Type = %d\n", Socket_Type); <br>            continue; <br>        } <br>#if(0) <br>        /* <br>        *   Socket family ?  <br>        */ <br> <br>        if (!strnicmp(p, "sf:", 3)) { <br>            p+= 3; <br> <br>            /* <br>            *   Get the socket family from the option  <br>            */ <br> <br>            Socket_Family = get_socket_family(p); <br>            continue; <br>        } <br>#endif <br>        /* <br>        *   Protocol ?  <br>        */ <br> <br>        if (!strnicmp(p, "proto:", 6)) { <br>            p+= 6; <br> <br>            /* <br>            *   Get the protocol from the option  <br>            */ <br> <br>            Protocol = atoi(p); <br> <br>            if (verbose) <br>        printf("Protocol = %d\n", Protocol); <br>            continue; <br>        } <br> <br>        /* <br>        *   Local network number ?  <br>        */ <br> <br>        if (!strnicmp(p, "lnet:", 5)) { <br>            p+= 5; <br> <br>            /* <br>            *   Get the local network number from the option  <br>            */ <br> <br>            memcpy(Local_Network_Number, get_network_number(p), 4); <br>            if (verbose) { <br>                printf("Local_Network_Number = "); <br>                print_network_num(Local_Network_Number); <br>                printf("\n"); <br>            } <br>            continue; <br>        } <br> <br> <br>        /* <br>        *   Local node number ?  <br>        */ <br> <br>        if (!strnicmp(p, "lnode:", 6)) { <br>            p+= 6; <br> <br>            /* <br>            *   Get the local network number from the option  <br>            */ <br> <br>            memcpy(Local_Node_Number, get_node_number(p), 6); <br>            if (verbose) { <br>                printf("Local_Node_Number = "); <br> print_node_num(Local_Node_Number); <br>                printf("\n"); <br>            } <br>            continue; <br>        } <br> <br>        /* <br>        *   Remote network number ?  <br>        */ <br> <br>        if (!strnicmp(p, "rnet:", 5)) { <br>            p+= 5; <br> <br>            /* <br>            *   Get the remote network number from the option  <br>            */ <br> <br>            memcpy(Remote_Network_Number, get_network_number(p), 4); <br>            if (verbose) { <br>                printf("Remote_Network_Number = "); <br>                print_network_num(Remote_Network_Number); <br>                printf("\n"); <br>            } <br>            continue; <br>        } <br> <br>        /* <br>        *   Remote node number ?  <br>        */ <br> <br>        if (!strnicmp(p, "rnode:", 6)) { <br>            p+= 6; <br> <br>            /* <br>            *   Get the remote network number from the option  <br>            */ <br> <br>            memcpy(Remote_Node_Number, get_node_number(p), 6); <br>            if (verbose) { <br>                printf("Remote_Node_Number = "); <br> print_node_num(Remote_Node_Number); <br>                printf("\n"); <br>            } <br>            continue; <br>        } <br> <br>        /* <br>        *   Local socket number ?  <br>        */ <br> <br>        if (!strnicmp(p, "lsock:", 6)) { <br>            p+= 6; <br> <br>            /* <br>            *   Get the local socket number from the command line  <br>            */ <br> <br>            memcpy(Local_Socket_Number, get_socket_number(p), 2); <br> <br>    if (verbose) { <br>                printf("Local_Socket_Number = "); <br>                print_socket_num(Local_Socket_Number); <br>                printf("\n"); <br>            } <br>            continue; <br>        } <br> <br>        /* <br>        *   Remote socket number ?  <br>        */ <br> <br>        if (!strnicmp(p, "rsock:", 6)) { <br>            p+= 6; <br> <br>            /* <br>            *   Get the remote socket number from the command line  <br>            */ <br> <br>            memcpy(Remote_Socket_Number, get_socket_number(p), 2); <br> <br>    if (verbose) { <br>                printf("Remote_Socket_Number = "); <br>                print_socket_num(Remote_Socket_Number); <br>                printf("\n"); <br>            } <br>            continue; <br>        } <br> <br> <br>        /* <br>        *   Send length ?  <br>        */ <br> <br>        if (!strnicmp(p, "sendlen:", 8)) { <br>            p+= 8; <br> <br>            /* <br>            *   Get the amount of data to send from the command line  <br>            */ <br> <br>            Send_Length = atoi(p); <br>            if (verbose) <br>                printf("Send length = %d\n", Send_Length); <br> <br>            continue; <br>        } <br> <br>        /* <br>        *   Receive length ?  <br>        */ <br> <br>        if (!strnicmp(p, "recvlen:", 8)) { <br>            p+= 8; <br> <br>            /* <br>            *   Get the amount of data to send from the command line  <br>            */ <br> <br>            Receive_Length = atoi(p); <br>            if (verbose) <br>                printf("Receive length = %d\n", Receive_Length); <br> <br>            continue; <br>        } <br> <br>        /* <br>        *   Send packet type ?  <br>        */ <br> <br>        if (!strnicmp(p, "sptype:", 7)) { <br>    p+= 7; <br> <br>            /* <br>            *   Get the packet type from the command line  <br>            */ <br> <br>            Send_Packet_Type = atoi(p); <br> <br>      if (verbose) <br>printf("Send_Packet_Type = %d\n", Send_Packet_Type); <br>            continue; <br>        } <br> <br>        /* <br>        *   Local packet type ?  <br>        */ <br> <br>        if (!strnicmp(p, "lptype:", 7)) { <br>    p+= 7; <br> <br>            /* <br>            *   Get the packet type from the command line  <br>            */ <br> <br>            Local_Packet_Type = atoi(p); <br> <br>      if (verbose) <br>printf("Send_Packet_Type = %d\n", Send_Packet_Type); <br>            continue; <br>        } <br> <br>        /* <br>        *   Filter packet type ?  <br>        */ <br> <br>        if (!strnicmp(p, "fptype:", 7)) { <br>    p+= 7; <br> <br>            /* <br>            *   Get the packet type from the command line  <br>            */ <br> <br>            Filter_Packet_Type = atoi(p); <br> <br>      if (verbose) <br>printf("Filter_Packet_Type = %d\n", Send_Packet_Type); <br>            continue; <br>        } <br> <br>        /* <br>        *   Backlog size ?  <br>        */ <br> <br>        if (!strnicmp(p, "backlog:", 8)) { <br>     p+= 8; <br> <br>            Backlog = atoi(p); <br> <br>            if (verbose) <br>                printf("Backlog = %d\n", Backlog); <br>            continue; <br>        } <br> <br>        /* <br>        *   No broadcast flag ?  <br>        */ <br> <br>        if (!strnicmp(p, "nobcast", 7)) { <br>            p+= 7; <br> <br>            No_Broadcast++; <br> <br>            if (verbose) <br>                printf("No broadcast flag is set\n"); <br> <br>            continue; <br>        } <br> <br>        /* <br>        *   No loop flag ?  <br>        */ <br> <br>        if (!strnicmp(p, "noloop", 6)) { <br>            p+= 6; <br> <br>            No_Loop++; <br> <br>            if (verbose) <br>                printf("No loop flag is set\n"); <br> <br>            continue; <br>        } <br> <br>        /* <br>        *   Sleep time ?  <br>        */ <br> <br>        if (!strnicmp(p, "sleep:", 6)) { <br>            p+= 6; <br> <br>            Sleep_Time = atoi(p); <br> <br>            if (verbose) <br>                printf("Sleep time = %d\n", Sleep_Time); <br> <br>            continue; <br>        } <br> <br> <br>        if (*p) <br>            printf("Unknown command line parameter: %s\n", p); <br> <br>    } /* while */ <br> <br>    if (verbose) <br>        printf("\n\n"); <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  usage( LPSTR progname ) <br>* <br>*    PURPOSE:   Displays all allowable command line parameters.  (All may not be used <br>*       by the program linking to this library, however). <br>* <br>*    ARGUMENTS:LPSTR=&gt; program name <br>* <br>* RETURNS:   exits with errorlevel 0 <br>* <br>*\***************************************************************************/ <br>void usage(LPSTR progname) <br>{ <br>    printf("\n\nUsage: %s [options]\n", progname); <br>    printf("\n"); <br>    printf("Valid options are:\n"); <br>    printf("-v               Toggles verbose mode ON\n"); <br>    printf("-laf:x           Sets local address family to x\n"); <br>    printf("-raf:x           Sets remote address family to x\n"); <br>    printf("-st:x            Sets socket type to x\n"); <br>    printf("-proto:x         Sets protocol to x\n"); <br>    printf("-sleep:x         Sets sleep time between sends to x milliseconds\n"); <br>    printf("-backlog:x       Sets listen backlog size to x indications\n"); <br>    printf("-nobcast         Sets flag so program won't set sockopt to broadcast\n"); <br>    printf("-noloop          Sets flag so program won't loop\n"); <br>    printf("-sptype:x        Sets send packet type to x\n"); <br>    printf("-lptype:x        Sets local packet type to x\n"); <br>    printf("-fptype:x        Sets filter for incoming packet type x\n"); <br>    printf("-sendlen:x       Sets amount of data to send to x bytes\n"); <br>    printf("-recvlen:x       Sets amount of data to receive to x bytes\n"); <br>    printf("-lnet:xxxx       Sets local network number to xxxx (1)\n"); <br>    printf("-lnode:xxxxxx    Sets local node number to xxxxxx (1)\n"); <br>    printf("-rnet:xxxx       Sets remote network number to xxxx (1)\n"); <br>    printf("-rnode:xxxxxx    Sets remote node number to xxxxxx (1)\n"); <br>    printf("-rsock:xx        Sets remote socket number to xx (1)\n"); <br>    printf("-default         Displays programs default values\n"); <br>    printf("-?, -help, or -h Displays this screen\n"); <br>    printf("\n"); <br>    printf("Notes:  (1) Network numbers (network, node, and socket) must\n"); <br>    printf("            be specified as a series of hexadecimal numbers,\n"); <br>    printf("            for example: -lnet:04003BFF. \n"); <br>    printf("\n"); <br>    printf("        All values must come immediately after the ':'\n"); <br>    printf("        -default and/or -v should be first\n"); <br>    printf("        Not all programs make use of all the above parameters\n"); <br> <br>    exit(0); <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  dump_defaults( LPSTR progname ) <br>* <br>*    PURPOSE:   Prints out the current values of the command line options <br>*        <br>* <br>*    ARGUMENTS:LPSTR=&gt; program name <br>* <br>* RETURNS:   nothing <br>* <br>*\***************************************************************************/ <br>void dump_defaults(LPSTR progname) <br>{ <br>    printf("Default option values for %s:\n\n", progname); <br> <br>    printf("verbose =                %d\n", verbose); <br>    printf("socket type =            %d\n", Socket_Type); <br>    printf("protocol =               %d\n", Protocol); <br>    printf("sleep time =             %d\n", Sleep_Time); <br>    printf("backlog =                %d\n", Backlog); <br>    printf("nobcast =                %d\n", No_Broadcast); <br>    printf("noloop =                 %d\n", No_Loop); <br>    printf("send length =            %d\n", Send_Length); <br>    printf("receive length =         %d\n", Receive_Length); <br>    printf("send packet type =       %d\n", Send_Packet_Type); <br>    printf("local packet type =      %d\n", Local_Packet_Type); <br>    printf("filter packet type =     %d\n", Filter_Packet_Type); <br>    printf("local address family =   %d\n", Local_Address_Family); <br>    printf("remote address family =  %d\n", Remote_Address_Family); <br>    printf("local network number =   "); <br>    print_network_num(Local_Network_Number); <br>    printf("\nlocal node number =      "); <br>    print_node_num(Local_Node_Number); <br>    printf("\nlocal socket number =    "); <br>    print_socket_num(Local_Socket_Number); <br>    printf("\nremote network number =  "); <br>    print_network_num(Remote_Network_Number); <br>    printf("\nremote node number =     "); <br>    print_node_num(Remote_Node_Number); <br>    printf("\nremote socket number =   "); <br>    print_socket_num(Remote_Socket_Number); <br>    printf("\n\n"); <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  get_network_number( LPSTR cmd ) <br>* <br>*    PURPOSE:   Reads a network number from the given string <br>* <br>* <br>*    ARGUMENTS:LPSTR  =&gt; string to read from <br>* <br>* RETURNS:   LPSTR  =&gt; hex network number <br>* <br>*\***************************************************************************/ <br>LPSTR get_network_number(LPSTR cmd) <br>{ <br>    static char hex_num[4]; <br> <br>    memset(hex_num, 0, 4); <br> <br>    if (strlen(cmd) != 8) { <br>        printf("Incorrect format for network number.\n"); <br>        exit(1); <br>    } <br> <br>    get_hex_string(cmd, hex_num, 4); <br> <br>    return hex_num; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  get_node_number( LPSTR cmd ) <br>* <br>*    PURPOSE:   Reads a node number from the given string <br>* <br>* <br>*    ARGUMENTS:LPSTR  =&gt; string to read from <br>* <br>* RETURNS:   LPSTR  =&gt; hex network number <br>* <br>*\***************************************************************************/ <br>LPSTR get_node_number(LPSTR cmd) <br>{ <br>    static char hex_num[6]; <br> <br>    memset(hex_num, 0, 6); <br> <br>    if (strlen(cmd) != 12) { <br>        printf("Incorrect format for node number.\n"); <br>        exit(1); <br>    } <br> <br>    get_hex_string(cmd, hex_num, 6); <br> <br>    return hex_num; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  get_socket_number( LPSTR cmd ) <br>* <br>*    PURPOSE:   Reads a socket number from the given string <br>* <br>* <br>*    ARGUMENTS:LPSTR  =&gt; string to read from <br>* <br>* RETURNS:   LPSTR  =&gt; hex network number <br>* <br>*\***************************************************************************/ <br>LPSTR get_socket_number(LPSTR cmd) <br>{ <br>    static char hex_num[2]; <br> <br>    memset(hex_num, 0, 2); <br> <br>    if (strlen(cmd) != 4) { <br>        printf("Incorrect format for socket number.\n"); <br>        exit(1); <br>    } <br> <br>    get_hex_string(cmd, hex_num, 2); <br> <br>    return hex_num; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  get_hex_string( LPSTR src, LPSTR dest, int num ) <br>* <br>*    PURPOSE:   Reads in a character string containing hex digits and converts <br>*it to a hexadecimal number. <br>* <br>*    ARGUMENTS:LPSTR  =&gt; source string <br>*LPSTR  =&gt; destination for hex number <br>*int    number of bytes to convert <br>* <br>* RETURNS:   nothing <br>* <br>*\***************************************************************************/ <br>void get_hex_string(LPSTR src, LPSTR dest, int num) <br>{ <br>    LPSTR q = src; <br> <br>    while (num--) <br>        *dest++ = (get_hex_byte(*q++) &lt;&lt; 4) + get_hex_byte(*q++); <br> <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  get_hex_byte( char ch ) <br>* <br>*    PURPOSE:   Converts the character passed in to a hexadecimal nibble. <br>* <br>*    ARGUMENTS:char    character to convert <br>* <br>* RETURNS:   UCHAR   hex nibble <br>* <br>*\***************************************************************************/ <br>UCHAR get_hex_byte(char ch) <br>{ <br>    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') <br>        return (ch - '0'); <br> <br>    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') <br>        return ((ch - 'A') + 0x0A); <br> <br>    printf("Illegal character %c in hex string\n", ch); <br>    exit(1); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
