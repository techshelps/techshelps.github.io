<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DGSEND.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5324"></a>DGSEND.C</h2>
<pre><code>/****************************************************************************\ <br>*  dgsend.c -- sample program demonstrating NWLink. <br>* <br>*       Microsoft Developer Support <br>*       Copyright 1992 - 1998 Microsoft Corporation <br>* <br>*  This program is a simple example of opening a socket, <br>*  binding to the socket, and sending a packet repeatedly. <br>*  <br>****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include &lt;wsnwlink.h&gt; <br>#include "..\testlib\testlib.h" <br> <br>/* <br>*   Sockaddr structures  <br>*/ <br> <br>SOCKADDR_IPX addr; <br>SOCKADDR_IPX baddr; <br>SOCKADDR_IPX saddr; <br> <br>/* <br>*   Data for sending  <br>*/ <br> <br>char send_data[] = "This is an IPX packet from NT"; <br> <br>/* <br>*   Function Prototypes  <br>*/ <br>extern int main(int, char **); <br>extern int net_init(SOCKET *); <br>extern int enable_broadcasts(SOCKET); <br>extern void build_dest_addr(SOCKET, PSOCKADDR_IPX); <br>extern int dg_send(SOCKET); <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  main( int argc, char **argv ) <br>* <br>*    PURPOSE:   This is the main entry for the program <br>*        <br>* <br>*    ARGUMENTS:argc = Number of arguments <br>*               argv = Array of ptrs to cmd line args <br>*                 <br>* <br>* RETURNS:   Exit code for the program <br>* <br>*\***************************************************************************/ <br>int main(int argc, char **argv) <br>{ <br>    SOCKET s; <br> <br>    /* <br>    *   Fill in any default values before checking the command line  <br>    */ <br> <br>    *Remote_Socket_Number = 0x06; <br>    *(Remote_Socket_Number+1) = 0x00; <br>    Sleep_Time = 500; <br> <br>    /* <br>    *   Parse the command line to set up any command line options  <br>    */ <br> <br>    parse_cmd_line(argc, argv); <br> <br>    if (net_init(&amp;s)) <br>        return 1; <br> <br>    if (!No_Broadcast) { <br>        if (enable_broadcasts(s)) <br>            return 1; <br>    } <br> <br>    build_dest_addr(s, &amp;saddr); <br> <br>    /* <br>    *   Send some datagrams  <br>    */ <br> <br>    dg_send(s); <br> <br>    /* <br>    *   All Done - Close up the socket and exit  <br>    */ <br> <br>    if (verbose) <br>printf("Calling closesocket()\n"); <br> <br>    closesocket(s); <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  net_init( SOCKET *skt ) <br>* <br>*    PURPOSE:   Initializes the WinSock stuff and sets up our socket. <br>*        <br>* <br>*    ARGUMENTS:SOCKET * =&gt; struct to receive our socket info <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int net_init(SOCKET *skt) <br>{ <br>    SOCKET s; <br>    WSADATA wsdata; <br>    WORD    wVersionRequested; <br> <br> <br>    int rc, addrlen = 16; <br> <br>    if (verbose) <br>        printf("Calling WSAStartup(), "); <br> <br>    /* <br>    *   Initialize with the WINSOCK library  <br>    */ <br> <br>    wVersionRequested = MAKEWORD(1,1); <br>    rc = WSAStartup(wVersionRequested, &amp;wsdata); <br> <br>    if (verbose) <br>        printf("return = 0x%X (%d)\n", rc, rc); <br> <br>    if (rc) { <br>        printf("WSAStartup failed: error code = %d\n", rc); <br>        return 1; <br>    } <br> <br>    if (verbose) { <br>        printf("Contents of wsadata struct:\n"); <br>        print_wsa(&amp;wsdata); <br>    } <br> <br>    /* <br>    *   Open a DATAGRAM socket with IPX  <br>    */ <br> <br>    if (verbose) <br>        printf("Calling socket(address family = %d, socket type = %d, protocol = %d)\n", Local_Address_Family, Socket_Type, Protocol); <br> <br>    s = socket(Local_Address_Family, Socket_Type, Protocol); <br> <br>    if (verbose) <br>printf("socket() returned 0x%X (%d)\n", s, s); <br> <br>    if (s == INVALID_SOCKET) { <br>        dos_net_perror("Socket call failed"); <br>        exit(1); <br>    } <br> <br>    /* <br>    *   Bind to a socket.  We dont care what socket we bind to, <br>    *   so we will send down all 0's <br>    */ <br> <br>    addr.sa_family = Local_Address_Family; <br> <br>    memcpy(&amp;addr.sa_netnum, Local_Network_Number, 4); <br>    memcpy(&amp;addr.sa_nodenum, Local_Node_Number, 6); <br>    memcpy(&amp;addr.sa_socket, Local_Socket_Number, 2); <br> <br>    if (verbose) { <br>        printf("calling bind(), local address =\n  "); <br>        print_saddr(&amp;addr); <br>    } <br> <br>    rc = bind(s, (const struct sockaddr *) &amp;addr, 16); <br> <br>    if (verbose) <br>        printf("\nbind() returned 0x%X (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error binding to socket"); <br>        printf("Socket = 0x%lx\n", s); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Get the address we bound to and print it out  <br>    */ <br> <br>    if (verbose) <br>        printf("calling getsockname(socket = %d), ", s); <br> <br>    rc = getsockname(s, (struct sockaddr *) &amp;baddr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("return = 0x%lX (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error getting socket name"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Set the packet type for this socket  <br>    */ <br> <br>    if (verbose) <br>        printf("Calling setsockopt for packet type %d\n", Local_Packet_Type); <br> <br>    rc = setsockopt(s, NSPROTO_IPX, IPX_PTYPE, (const char *) &amp;Local_Packet_Type, 4); <br> <br>    if (rc == SOCKET_ERROR) <br>        dos_net_perror("setsockopt() call failed"); <br> <br>    /* <br>    *   Print out the network address  <br>    */ <br> <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(baddr.sa_netnum, "  Bound to address ", "\n"); <br>    } <br> <br>    *skt = s; <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  enable_broadcasts( SOCKET s ) <br>* <br>*    PURPOSE:   Sets the socket option to enable broadcast sends on it. <br>*        <br>* <br>*    ARGUMENTS:SOCKET   socket to enable <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int enable_broadcasts(SOCKET s) <br>{ <br>    int rc; <br>    BOOL optval = TRUE; <br> <br>    /* <br>    *   Enable sending of broadcasts  <br>    */ <br> <br>    /* <br>    *    NOTE:  This only needs to be done if you want to SEND <br>    *           broadcast packets.  Reception of broadcast <br>    *           packets will happen automatically. <br>    */ <br> <br>    if (verbose) <br>        printf("Setting socket option to broadcast, "); <br>rc = setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&amp;optval, sizeof(int)); <br>    if (verbose) <br>        printf("return = 0x%X (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error enabling broadcast address"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  build_dest_addr( SOCKET s ) <br>* <br>*    PURPOSE:   Fills in the destination address fields and sets the packet type. <br>*        <br>* <br>*    ARGUMENTS:SOCKET       socket to set packet type for <br>*PSOCKADDR_NS =&gt; address struct to fill in <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>void build_dest_addr(SOCKET s, PSOCKADDR_IPX psaddr) <br>{ <br>    int rc; <br> <br>    /* <br>    *   Build the dest. address  <br>    */ <br> <br>    psaddr-&gt;sa_family = Remote_Address_Family; <br> <br>    /* <br>    *   Set dest. network number  <br>    */ <br> <br>    memcpy(&amp;psaddr-&gt;sa_netnum, Remote_Network_Number, 4); <br> <br>    /* <br>    *   Set dest. node address  <br>    */ <br> <br>    memcpy(&amp;psaddr-&gt;sa_nodenum, Remote_Node_Number, 6); <br> <br>    /* <br>    *   Set the dest. socket number  <br>    */ <br> <br>    memcpy(&amp;psaddr-&gt;sa_socket, Remote_Socket_Number, 2); <br> <br> <br>    /* <br>    *   Set the packet type for this socket  <br>    */ <br> <br>    if (verbose) <br>        printf("Calling setsockopt for packet type %d\n", Send_Packet_Type); <br> <br>    rc = setsockopt(s, NSPROTO_IPX, IPX_PTYPE, (const char *) &amp;Send_Packet_Type, sizeof(int)); <br> <br>    if (rc == SOCKET_ERROR) <br>        dos_net_perror("setsockopt() call failed"); <br> <br>    return; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  dg_send( SOCKET s ) <br>* <br>*    PURPOSE:   Receives datagrams. <br>* <br>*    ARGUMENTS:SOCKET socket to transmit on <br>* <br>* RETURNS:   0 if ok <br>*               1 if error <br>* <br>*\***************************************************************************/ <br>int dg_send(SOCKET s) <br>{ <br>    LPSTR sendbuf; <br>    int rc, errflag = 0; <br>    UINT dgrms = 0; <br> <br>    if (verbose) <br>        printf("allocating %d bytes for send buffer\n", Send_Length); <br> <br>    /* <br>    *   Set up the data buffer to send  <br>    */ <br> <br>    sendbuf = (LPSTR)malloc(Send_Length); <br> <br>    if (!sendbuf) { <br>        printf("Error allocating %d bytes for send buffer\n", Send_Length); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Zero the buffer and copy as much of our data to it as possible  <br>    */ <br> <br>    memset(sendbuf, 0, Send_Length); <br>    strncpy(sendbuf, send_data, Send_Length); <br> <br>    while (1) { <br>        if (verbose) { <br>            printf("calling sendto(socket = %d, length = %d),\n", s, Send_Length); <br>            printf("destination address:\n  "); <br>            print_saddr(&amp;saddr); <br>        } <br> <br>        /* <br>        *   Send a packet to everybody  <br>        */ <br> <br>        rc = sendto(s, sendbuf, Send_Length, 0, (const struct sockaddr *) &amp;saddr, 16); <br> <br>        if (verbose) <br>    printf("\nsendto() returned %d\n", rc); <br> <br>        if (rc == SOCKET_ERROR) { <br>            dos_net_perror("Sendto() failed"); <br>            errflag++; <br>            break; <br>        } <br>        else { <br>            printf("\rSent datagram %d, length = %d bytes", ++dgrms, rc); <br>            if (verbose) <br>                printf("\n"); <br>        } <br> <br>        /* <br>        *   If we are to send only one, break out  <br>        */ <br> <br>        if (No_Loop) <br>            break; <br> <br>        /* <br>        *   Sleep for a little while so we don't bombard the network  <br>        */ <br> <br>        Sleep(Sleep_Time); <br>    } <br> <br>    if (verbose) <br>        printf("Freeing send buffer\n"); <br> <br>    free(sendbuf); <br> <br>    return errflag; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
