<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONNECT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5322"></a>CONNECT.C</h2>
<pre><code>/****************************************************************************\ <br>*  dgrecv.c -- sample program demonstrating NWLink. <br>* <br>*       Microsoft Developer Support <br>*       Copyright 1992 - 1998 Microsoft Corporation <br>* <br>*  This program is a simple example of using SPX connect. <br>*  <br>****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include "../testlib/testlib.h" <br> <br>SOCKADDR_IPX addr; <br>SOCKADDR_IPX baddr; <br>SOCKADDR_IPX caddr; <br> <br>UCHAR ch = 0; <br> <br>/* <br>*   Function Prototypes  <br>*/ <br> <br>extern int main(int, char **); <br>extern int net_init(SOCKET *); <br>extern int make_connection(SOCKET); <br>extern int do_send_receive(SOCKET); <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  main( int argc, char **argv ) <br>* <br>*    PURPOSE:   This is the main entry for the program <br>*        <br>* <br>*    ARGUMENTS:argc = Number of arguments <br>*               argv = Array of ptrs to cmd line args <br>*                 <br>* <br>* RETURNS:   Exit code for the program <br>* <br>*\***************************************************************************/ <br>int main(int argc, char **argv) <br>{ <br>    SOCKET s; <br> <br>    /* <br>    *   Set up our default values before checking command line  <br>    */ <br> <br>    memcpy(Remote_Node_Number, "\x08\x00\x2B\x2E\x98\xA8", 6); <br>    memcpy(Remote_Socket_Number, "\x05\x00", 2); <br>    Socket_Type = SOCK_STREAM; <br>    Protocol = NSPROTO_SPX; <br>    Remote_Address_Family = AF_NS; <br>    Sleep_Time = 250; <br> <br>    /* <br>    *   Get any command line options  <br>    */ <br> <br>    parse_cmd_line(argc, argv); <br> <br>    /* <br>    *   Initialize the network and set up the socket  <br>    */ <br> <br>    if (net_init(&amp;s)) <br>        return 1; <br> <br>    /* <br>    *   Try to connect to our server  <br>    */ <br> <br>    if (make_connection(s)) <br>        return 1; <br> <br>    /* <br>    *   Send/receive data to/from server  <br>    */ <br> <br>    do_send_receive(s); <br> <br>    /* <br>    *   All done - close up  <br>    */ <br> <br>    if (verbose) <br>        printf("calling closesocket(socket = %d)\n", s); <br> <br>    closesocket(s); <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  net_init( SOCKET *skt ) <br>* <br>*    PURPOSE:   Initializes the WinSock stuff and sets up our socket. <br>*        <br>* <br>*    ARGUMENTS:SOCKET * =&gt; struct to fill in with opened socket. <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int net_init(SOCKET *skt) <br>{ <br>    SOCKET s; <br>    int rc, addrlen; <br>    WSADATA wsdata; <br>    WORD    wVersionRequested; <br> <br>    wVersionRequested = MAKEWORD(1,1); <br> <br> <br>    /* <br>    *   Register with the socket library  <br>    */ <br> <br>    rc = WSAStartup(wVersionRequested, &amp;wsdata); <br> <br>    if (verbose) <br>        printf("WSAStartup returned 0x%X\n", rc); <br> <br>    if (rc) { <br>        printf("WSAStartup failed: error = %d\n", rc); <br>        return 1; <br>    } <br> <br>    if (verbose) { <br>        printf("contents of wsdata structure: \n"); <br>        print_wsa(&amp;wsdata); <br>        printf("calling socket(address family = %d, socket type = %d, protocol = %d)\n", Local_Address_Family, Socket_Type, Protocol); <br>    } <br> <br>    /* <br>    *   Open a STREAMING socket  <br>    */ <br> <br>    s = socket(Local_Address_Family, Socket_Type, Protocol); <br> <br>    if (verbose) <br>        printf("socket() returned 0x%X (%d)\n", s, s); <br> <br>    if (s == INVALID_SOCKET) { <br>        dos_net_perror("socket call failed"); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Bind to any address  <br>    */ <br> <br>    addr.sa_family = Local_Address_Family; <br>    memcpy(&amp;addr.sa_netnum, Local_Network_Number, 4); <br>    memcpy(&amp;addr.sa_nodenum, Local_Node_Number, 6); <br>    memcpy(&amp;addr.sa_socket, Local_Socket_Number, 2); <br> <br>    rc = bind(s, (const struct sockaddr FAR *)&amp;addr, 16); <br> <br>    if (verbose) <br>        printf("bind() returned 0x%X\n", rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("bind call failed"); <br>        return 1; <br>    } <br> <br>    if (verbose) <br>        printf("calling getsockname(socket = %d)\n", s); <br> <br>    addrlen = 16; <br>    rc = getsockname(s, (struct sockaddr *) &amp;addr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("getsockname() returned 0x%X\n", rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error binding to socket"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(addr.sa_netnum, "Bound address = ", "\n"); <br>    } <br> <br> <br>    /* <br>    *   Build the address of the node to connect to  <br>    */ <br> <br>    memcpy(&amp;caddr.sa_netnum, Remote_Network_Number, 4); <br>    memcpy(&amp;caddr.sa_nodenum, Remote_Node_Number, 6); <br>    memcpy(&amp;caddr.sa_socket, Remote_Socket_Number, 2); <br>    caddr.sa_family = AF_NS; <br> <br>    /* <br>    *   Set up socket for return  <br>    */ <br> <br>    *skt = s; <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  make_connection( SOCKET s ) <br>* <br>*    PURPOSE:   Establishes a connection with our server. <br>* <br>*    ARGUMENTS:SOCKET socket to use for connection <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int make_connection(SOCKET s) <br>{ <br>    int rc, addrlen; <br> <br>    /* <br>    *   Connect  <br>    */ <br> <br>    if (verbose) <br>        printf("calling connect(socket = %d)\n", s); <br> <br>    rc = connect(s, (const struct sockaddr FAR *)&amp;caddr, 16); <br> <br>    if (verbose) <br>        printf("connect() returned 0x%X\n", rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("connect call failed"); <br>        return 1; <br>    } <br> <br>    printf("Connect OK\n"); <br> <br>    /* <br>    *   Print out address we connected to  <br>    */ <br> <br>    if (verbose) <br>        printf("calling getpeername(socket = %d)\n", s); <br> <br>    addrlen = 16; <br>    rc = getpeername(s, (struct sockaddr *) &amp;caddr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("getpeername() returned 0x%X\n", rc); <br> <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(caddr.sa_netnum, "Remote Address = ", "\n"); <br>    } <br> <br>    return 0; <br>} <br>/**************************************************************************** <br>* <br>*    FUNCTION:  do_send_receive( SOCKET *s ) <br>* <br>*    PURPOSE:   Alternately sends/receives data to/from the server. <br>* <br>*    ARGUMENTS:SOCKET socket to transmit on <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int do_send_receive(SOCKET s) <br>{ <br>    int rc, errflag = 0; <br>    int sndpkts = 0, rcvpkts = 0; <br>    LPSTR sendbuf; <br> <br>    /* <br>    *   Allocate a send buffer  <br>    */ <br> <br>    if (verbose) <br>        printf("Allocating %d bytes for send buffer \n"); <br> <br>    sendbuf = malloc(Send_Length); <br> <br>    if (!sendbuf) { <br>        printf("Error allocating %d bytes for send buffer\n"); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Send data and recv it back  <br>    */ <br> <br>    while (1) { <br> <br>        /* <br>        *   Fill the buffer with our current character  <br>        */ <br> <br>        memset(sendbuf, ch, Send_Length); <br> <br>        /* <br>        *   Send data  <br>        */ <br> <br>        if (verbose) <br>    printf("calling send(socket = %d, length = %d)\n", s, Send_Length); <br> <br>        rc = send(s, sendbuf, Send_Length, 0); <br> <br>        if (verbose) <br>            printf("send() returned 0x%X\n", rc); <br> <br>        if (rc == SOCKET_ERROR) { <br>            dos_net_perror("\nsend() call failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (verbose) <br>            printf("Sent packet %d: sent %d bytes\n", sndpkts++, rc); <br>        else <br>            printf("\rSent packet %d: sent %d bytes... ", sndpkts++, rc); <br> <br>        /* <br>        *   Receive the data back  <br>        */ <br> <br>        if (verbose) <br>            printf("calling recv(socket = %d, length = %d)\n", s, Send_Length); <br> <br>        rc = recv(s, sendbuf, Send_Length, 0); <br> <br>        if (verbose) <br>            printf("recv() returned %d\n", rc); <br> <br>        if (rc == SOCKET_ERROR) { <br>            dos_net_perror("\nrecv() call failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (!rc) { <br>            printf("connection has been lost\n"); <br>            break; <br>        } <br> <br>        printf("Received %d bytes", rc); <br> <br>        if (verbose) <br>            printf("\n"); <br> <br>        /* <br>        *   See if our buffer has the same data in it  <br>        */ <br> <br>        rc = mem_check(sendbuf, ch++, Send_Length); <br> <br>        if (rc) <br>            printf("Data compare error: packet = %d, offset = %d\n", (sndpkts-1), rc); <br>        else if (verbose) <br>            printf("Data compares okay\n"); <br> <br>        /* <br>        *   If we are to send just 1, break out  <br>        */ <br> <br>        if (No_Loop) <br>            break; <br> <br>        /* <br>        *   Pause a little while (don't trash the network)  <br>        */ <br> <br>        Sleep(Sleep_Time); <br>    } <br> <br>    if (verbose) <br>        printf("\nFreeing send buffer\n"); <br> <br>    free(sendbuf); <br> <br>    return errflag; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
