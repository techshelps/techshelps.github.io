<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LISTEN.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5325"></a>LISTEN.C</h2>
<pre><code>/****************************************************************************\ <br>*  listen.c -- sample program demonstrating NWLink. <br>* <br>*       Microsoft Developer Support <br>*       Copyright 1992 - 1998 Microsoft Corporation <br>* <br>*  This program is a simple example of opening a SPX socket, <br>*  binding to the socket, and listening for a connection. <br>*  <br>****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;wsipx.h&gt; <br>#include "../../testlib/testlib.h" <br> <br>/* <br>*   Sockaddr structures  <br>*/ <br> <br>SOCKADDR_IPX addr; <br>SOCKADDR_IPX baddr; <br>SOCKADDR_IPX saddr; <br> <br>/* <br>*   Function Prototypes  <br>*/ <br> <br>extern int main(int, char **); <br>extern int net_init(SOCKET *); <br>extern int do_listen(SOCKET); <br>extern int wait_for_connection(SOCKET, SOCKET *); <br>extern int do_recv_send(SOCKET); <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  main( int argc, char **argv ) <br>* <br>*    PURPOSE:   This is the main entry for the program <br>*        <br>* <br>*    ARGUMENTS:argc = Number of arguments <br>*               argv = Array of ptrs to cmd line args <br>*                 <br>* <br>* RETURNS:   Exit code for the program <br>* <br>*\***************************************************************************/ <br>int main(int argc, char **argv) <br>{ <br>    SOCKET s, s2; <br> <br>    /* <br>    *   Set any default values before calling parse_cmd_line  <br>    */ <br> <br>    *Local_Socket_Number = 0x05; <br>    *(Local_Socket_Number + 1) = 0x00; <br>    Socket_Type = SOCK_STREAM; <br>    Protocol = NSPROTO_SPX; <br> <br>    /* <br>    *   Get any options from the command line  <br>    */ <br> <br>    parse_cmd_line(argc, argv); <br> <br>    /* <br>    *   Initialize the network and set up our socket  <br>    */ <br> <br>    if (net_init(&amp;s)) <br>        return 1; <br> <br>    /* <br>    *   Go listen for a call  <br>    */ <br> <br>    if (do_listen(s)) <br>        return 1; <br> <br>    /* <br>    *   Then wait for a connection  <br>    */ <br> <br>    if (wait_for_connection(s, &amp;s2))  <br>        return 1; <br> <br>    /* <br>    *   Receive data then send it back  <br>    */ <br> <br>    if (do_recv_send(s2)) <br>        return 1; <br> <br>    /* <br>    *   All done  <br>    */ <br> <br>    if (verbose) <br>        printf("closing both sockets\n"); <br> <br>    closesocket(s2); <br>    closesocket(s); <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  net_init( SOCKET *skt ) <br>* <br>*    PURPOSE:   Initializes the WinSock stuff and sets up our socket. <br>*        <br>* <br>*    ARGUMENTS:SOCKET * =&gt; struct to receive our socket info <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int net_init(SOCKET *skt) <br>{ <br>    int rc, addrlen = 16; <br>    WSADATA wsdata; <br>    SOCKET s; <br>    WORD    wVersionRequested; <br> <br>    wVersionRequested = MAKEWORD(1,1); <br> <br>     <br>    /* <br>    *   Initialize with the WINSOCK library  <br>    */ <br> <br>    if (verbose) <br>        printf("calling WSAStartup(), "); <br> <br>    rc = WSAStartup(wVersionRequested, &amp;wsdata); <br> <br>    if (verbose) <br>        printf("return = 0x%X, (%d)\n", rc, rc); <br> <br>    if (rc) { <br>        printf("WSAStartup failed: error code = %d\n", rc); <br>        return 1; <br>    } <br> <br>    if (verbose) { <br>        printf("contents of wsdata struct: \n"); <br>        print_wsa(&amp;wsdata); <br>    } <br> <br>    /* <br>    *   Open a STREAM socket with SPX  <br>    */ <br> <br>    if (verbose) <br>        printf("calling socket(addresss family = %d, socket type = %d, protocol = %d)\n", Local_Address_Family, Socket_Type, Protocol); <br> <br>    s = socket(Local_Address_Family, Socket_Type, Protocol); <br>  <br> <br>    if (verbose) <br>        printf("socket() returned 0x%X (%d)\n", s, s); <br> <br>    if (s == INVALID_SOCKET) { <br>        dos_net_perror("Socket call failed"); <br>        exit(1); <br>    } <br> <br>    /* <br>    *   Bind to a socket.  We want to bind to a well known <br>    *   socket so that who ever calls us will be able to. <br>    */ <br> <br>    addr.sa_family = Local_Address_Family; <br>    memcpy(&amp;addr.sa_netnum, Local_Network_Number, 4); <br>    memcpy(&amp;addr.sa_nodenum, Local_Node_Number, 6); <br>    memcpy(&amp;addr.sa_socket, Local_Socket_Number, 2); <br> <br>    if (verbose) { <br>        printf("calling bind(socket = %d): \n  ", s); <br>        print_saddr(&amp;addr); <br>    } <br> <br>    rc = bind(s, (const struct sockaddr *) &amp;addr, 16); <br>     <br>    if (verbose) <br>        printf("bind() returned 0x%X (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error binding to socket"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    if (verbose) <br>        printf("calling getsockname(socket = %d), ", s); <br> <br>    /* <br>    *   Get the address we bound to and print it out  <br>    */ <br> <br>    addrlen = 16; <br>    rc = getsockname(s, (struct sockaddr *) &amp;baddr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("return = 0x%X (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("Error getting socket name"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Print out the network address  <br>    */ <br>   <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(baddr.sa_netnum, "Bound address = ", "\n"); <br>    } <br> <br>    *skt = s; <br>   <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  do_listen( SOCKET s ) <br>* <br>*    PURPOSE:   Sets the socket up for listening. <br>* <br>*    ARGUMENTS:SOCKET socket to listen on <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int do_listen(SOCKET s) <br>{ <br>    int rc; <br> <br>    /* <br>    *   Enable this socket as a listen socket that can <br>    *   take &lt;Backlog&gt; connection indication(s) at a time. <br>    */ <br> <br>    if (verbose) <br>        printf("calling listen(socket = %d, backlog = %d), ", s, Backlog); <br> <br>    rc = listen(s, Backlog); <br> <br>    if (verbose) <br>        printf("return = 0x%X (%d)\n", rc, rc); <br> <br>    if (rc == SOCKET_ERROR) { <br>        dos_net_perror("listen call failed"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Wait for a connection and get the connecting socket  <br>    */ <br>   <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  wait_for_connection( SOCKET s, SOCKET *callsock ) <br>* <br>*    PURPOSE:   Waits for someone to connect. <br>* <br>*    ARGUMENTS:SOCKET socket we are listening on <br>*SOCKET * =&gt; area to store client socket info after <br>*            connect <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int wait_for_connection(SOCKET s, SOCKET *callsock) <br>{ <br>    SOCKET s2; <br>    int addrlen = 16; <br> <br>    /* <br>    *   Go wait for somebody to connect  <br>    */ <br> <br>    if (verbose) <br>        printf("calling accept(socket = %d), ", s); <br>    else <br>        printf("Waiting for call...\n"); <br> <br>    s2 = accept(s, (struct sockaddr *) &amp;saddr, &amp;addrlen); <br> <br>    if (verbose) <br>        printf("return (socket) = 0x%X (%d)\n", s2, s2); <br> <br>    if (s2 == INVALID_SOCKET) { <br>        dos_net_perror("accept call failed"); <br>        closesocket(s); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Print out who connected to us  <br>    */ <br> <br>    if (verbose) { <br>        printf("addrlen = %d\n", addrlen); <br>        print_netaddr(saddr.sa_netnum, "Callers address = ", "\n"); <br>    } <br> <br>    *callsock = s2; <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION:  do_recv_send( SOCKET s2 ) <br>* <br>*    PURPOSE:   Waits for someone to connect. <br>* <br>*    ARGUMENTS:SOCKET socket to transmit on <br>* <br>* RETURNS:   0 if ok <br>*1 if error <br>* <br>*\***************************************************************************/ <br>int do_recv_send(SOCKET s2) <br>{ <br>    int rc, rcount = 0; <br>    int nbytes, errflag = 0; <br>    LPSTR recvbuf; <br> <br>    if (verbose) <br>        printf("allocating %d bytes for receive buffer\n", Receive_Length); <br> <br>    recvbuf = malloc(Receive_Length); <br>   <br>    if (!recvbuf) { <br>        printf("Error allocating %d bytes for receive buffer\n", Receive_Length); <br>        return 1; <br>    } <br> <br>    /* <br>    *   Recv packets and send them back  <br>    */ <br> <br>    while (1) { <br> <br>        /* <br>        *   Receive data  <br>        */ <br> <br>        if (verbose) <br>            printf("calling recv(socket = %d, receive length = %d)\n", s2, Receive_Length); <br> <br>        nbytes = recv(s2, recvbuf, Receive_Length, 0); <br> <br>        if (nbytes == SOCKET_ERROR) { <br>            dos_net_perror("recv call failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        if (verbose) <br>            printf("Received packet %d: received %d bytes\n", rcount++, nbytes); <br>        else <br>            printf("\rReceived packet %d: received %d bytes... ", rcount++, nbytes);  <br> <br>        /* <br>        *   Send the data back  <br>        */ <br> <br>        if (verbose) <br>            printf("calling send(socket = %d, send length = %d)\n", s2, nbytes); <br> <br>        rc = send(s2, recvbuf, nbytes, 0); <br> <br>        if (rc == SOCKET_ERROR) { <br>            dos_net_perror("send call failed"); <br>            errflag++; <br>            break; <br>        } <br> <br>        printf("Sent %d bytes", rc); <br> <br>        if (verbose) <br>            printf("\n"); <br> <br>        if (No_Loop) <br>            break; <br>    } <br> <br>    if (verbose) <br>        printf("freeing receive buffer\n"); <br>   <br>    free(recvbuf); <br> <br>    return errflag; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
