<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSOCK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5378"></a>WSOCK.C</h2>
<pre><code><br>//----------------------------------------------------------------------------- <br>// This is a part of the Microsoft Source Code Samples.  <br>// Copyright 1993 - 1998 Microsoft Corporation. <br>// All rights reserved.  <br>//   <br>// This source code is only intended as a supplement to  <br>// Microsoft Development Tools and/or WinHelp documentation. <br>// See these sources for detailed information regarding the  <br>// Microsoft samples programs. <br>//----------------------------------------------------------------------------- <br> <br>/****************************************************************************\ <br>*  wsock.c -- sample program demonstrating Windows Sockets APIs. <br>* <br>*  Demonstrates basic sockets programming with the Windows Sockets API. <br>*  Allows two occurances of the application to connect.  Also, displays <br>*  information about a host computer. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt;       /* required for all Windows applications */ <br>#include &lt;stdio.h&gt;         /* for sprintf                           */ <br>#include &lt;string.h&gt;        /* for strlen                            */ <br>#include &lt;memory.h&gt; <br>#include &lt;process.h&gt;       /* for _beginthread                      */ <br>#include "wsock.h"         /* specific to this program              */ <br> <br>HANDLE hInst;              /* current instance                      */ <br> <br>SOCKET sock; <br>u_short portno;            /* Which tcp port are we going to use?   */ <br> <br>char szBuff[ 80 ];         /* Temp buffer - used to pass strings    */ <br>                           /* to and from dialog boxes, etc         */ <br> <br>char gpszHelloWorld[]= "Hello World."; <br> <br>#define MAX_PENDING_CONNECTS 4  /* The backlog allowed for listen() */ <br>#define NO_FLAGS_SET         0  /* Used with recv()/send()          */ <br>#define MY_MSG_LENGTH       80  /* msg buffer sent back and forth   */ <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>* <br>*    PURPOSE: calls initialization function, processes message loop <br>* <br>*\***************************************************************************/ <br> <br>WINAPI WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br> <br>    MSG msg; <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br>    if (!hPrevInstance)                  /* Other instances of app running? */ <br>        if (!InitApplication(hInstance)) /* Initialize shared things        */ <br>            return (FALSE);              /* Exits if unable to initialize   */ <br> <br>    /* <br>    *   Perform initializations that apply to a specific instance <br>    */ <br>    if (!InitInstance(hInstance, nCmdShow)) <br>        return (FALSE); <br> <br>    /* <br>    *   Acquire and dispatch messages until a WM_QUIT message is received. <br>    */ <br>    while (GetMessage(&amp;msg,        /* message structure                      */ <br>            NULL,                  /* handle of window receiving the message */ <br>            0,             /* lowest message to examine              */ <br>            0))            /* highest message to examine             */ <br>        { <br>        TranslateMessage(&amp;msg);    /* Translates virtual key codes           */ <br>        DispatchMessage(&amp;msg);     /* Dispatches message to window           */ <br>   } <br>    return (msg.wParam);           /* Returns the value from PostQuitMessage */ <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION: InitApplication(HANDLE) <br>* <br>*    PURPOSE: Initializes window data and registers window class <br>* <br>*\***************************************************************************/ <br> <br>BOOL InitApplication(HANDLE hInstance)       /* current instance             */ <br>{ <br>    WNDCLASS  wc; <br> <br>    /* Fill in window class structure with parameters that describe the       */ <br>    /* main window.                                                           */ <br> <br>    wc.style = 0;                    /* Class style(s).                    */ <br>    wc.lpfnWndProc = (WNDPROC)MainWndProc;       /* Function to retrieve messages for  */ <br>                                        /* windows of this class.             */ <br>    wc.cbClsExtra = 0;                  /* No per-class extra data.           */ <br>    wc.cbWndExtra = 0;                  /* No per-window extra data.          */ <br>    wc.hIcon = LoadIcon (hInstance, "wsockicon"); /* Icon name from .RC        */ <br>    wc.hInstance = hInstance;          /* Application that owns the class.   */ <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>    wc.lpszMenuName =  "WSockMenu";   /* Name of menu resource in .RC file. */ <br>    wc.lpszClassName = "WSockWClass"; /* Name used in call to CreateWindow. */ <br> <br>    /* Register the window class and return success/failure code. */ <br> <br>    return (RegisterClass(&amp;wc)); <br> <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*    FUNCTION:  InitInstance(HANDLE, int) <br>* <br>*    PURPOSE:  Saves instance handle and creates main window <br>* <br>*\***************************************************************************/ <br> <br>BOOL InitInstance( <br>    HANDLE          hInstance,          /* Current instance identifier.       */ <br>    int             nCmdShow)           /* Param for first ShowWindow() call. */ <br>{ <br>    HWND            hWnd;               /* Main window handle.                */ <br> <br>    /* Save the instance handle in static variable, which will be used in  */ <br>    /* many subsequence calls from this application to Windows.            */ <br> <br>    hInst = hInstance; <br> <br>    /* Create a main window for this application instance.  */ <br> <br>    hWnd = CreateWindow( <br>        "WSockWClass",                  /* See RegisterClass() call.          */ <br>        "Windows Sockets Sample Application",   /* Text for window title bar.         */ <br>        WS_OVERLAPPEDWINDOW,            /* Window style.                      */ <br>        CW_USEDEFAULT,                  /* Default horizontal position.       */ <br>        CW_USEDEFAULT,                  /* Default vertical position.         */ <br>        CW_USEDEFAULT,                  /* Default width.                     */ <br>        CW_USEDEFAULT,                  /* Default height.                    */ <br>        NULL,                           /* Overlapped windows have no parent. */ <br>        NULL,                           /* Use the window class menu.         */ <br>        hInstance,                      /* This instance owns this window.    */ <br>        NULL                            /* Pointer not needed.                */ <br>    ); <br> <br>    /* If window could not be created, return "failure" */ <br> <br>    if (!hWnd) <br>        return (FALSE); <br> <br>    /* Make the window visible; update its client area; and return "success" */ <br> <br>    ShowWindow(hWnd, nCmdShow);  /* Show the window                        */ <br>    UpdateWindow(hWnd);          /* Sends WM_PAINT message                 */ <br>    return (TRUE);               /* Returns the value from PostQuitMessage */ <br> <br>} <br> <br>/****************************************************************************\ <br>* <br>*    FUNCTION: AcceptThreadProc(PTHREADPACK tp) <br>* <br>*    PURPOSE:  Use blocking accept() calls and display a message box when <br>*              a connection is made. <br>* <br>*\***************************************************************************/ <br> <br>void AcceptThreadProc( PTHREADPACK ptp ) <br>{ <br>   SOCKADDR_IN acc_sin;    /* Accept socket address - internet style */ <br>   int acc_sin_len;        /* Accept socket address length */ <br>   int status; <br>   char szMsg[ MY_MSG_LENGTH ]; <br> <br> <br>   acc_sin_len = sizeof(acc_sin); <br> <br>   wsprintf( szBuff, "thread #%d created.", ptp-&gt;nThread); <br>   MessageBox(ptp-&gt;hWnd, szBuff, "FYI", MB_OK); <br> <br>   sock = accept( sock,(struct sockaddr FAR *) &amp;acc_sin, <br>            (int FAR *) &amp;acc_sin_len ); <br> <br>   if (sock &lt; 0) { <br>      sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>      MessageBox(ptp-&gt;hWnd, szBuff, "accept(sock) failed", MB_OK); <br> <br>   } <br> <br>   wsprintf( szBuff, "Thread #%d accepted something\n\nCheck for incoming messages?", ptp-&gt;nThread); <br> <br>   /* <br>   *   Now have a connection -- <br>   *   SetConnectMenus() grays/enables proper menu items <br>   */ <br>   SetConnectMenus( ptp-&gt;hWnd ); <br> <br> <br>   while (1) { <br> <br>      /* <br>      *   By default sockets are created in blocking mode. <br>      *   Just keep reading until process destroyed. <br>      */ <br>      status = recv( sock, szMsg, MY_MSG_LENGTH, NO_FLAGS_SET ); <br> <br>      if (status == SOCKET_ERROR) { <br>         wsprintf( szMsg, "Error %d", WSAGetLastError() ); <br>         MessageBox( ptp-&gt;hWnd, szMsg, "Error with recv()", MB_OK); <br>         _endthread(); <br>      } <br>          szMsg[status] = '\0';  /* NULL-terminate the string */ <br> <br>      if (status) <br>         MessageBox( ptp-&gt;hWnd, szMsg, "From thread", MB_OK); <br>      else  { <br>         MessageBox( ptp-&gt;hWnd, "Connection broken", "Error", MB_OK); <br>         _endthread(); <br>      } <br> <br>   }    /* while (forever) */ <br>} <br> <br>/****************************************************************************\ <br>* <br>*    FUNCTION:  FillAddr(HWND, PSOCKADDR_IN, BOOL) <br>* <br>*    PURPOSE:  Retrieves the IP address and port number. <br>* <br>*    COMMENTS: <br>*        This function is called in two conditions. <br>*            1.) When a client is preparing to call connect(), or <br>*            2.) When a server host is going to call bind(), listen() and <br>*                accept(). <br>*        In both situations, a SOCKADDR_IN structure is filled. <br>*        However, different fields are filled depending on the condition. <br>* <br>*   ASSUMPTION: <br>*      szBuff is a global variable that contains the remote host name or NULL <br>*      if local. <br>*      bClient determines if this is being called by a client ( will be <br>*         performing a connect ) or a server ( will be listening ) <br>* <br>* <br>*\***************************************************************************/ <br> <br>BOOL FillAddr( <br>        HWND hWnd, <br>        PSOCKADDR_IN psin, <br>        BOOL bClient) <br>{ <br>   DWORD dwSize; <br>   PHOSTENT phe; <br>   PSERVENT pse; <br>   char szTemp[200]; <br>   int status; <br> <br> <br>   psin-&gt;sin_family = AF_INET; <br> <br> <br>   /* <br>   *   If we are setting up for a listen() call (bConnect = FALSE), <br>   *   fill servent with our address. <br>   */ <br>   if (bClient) { <br>      phe = gethostbyname(szBuff); <br>      if (phe == NULL) { <br>         sprintf(szTemp, "%d is the error. Make sure '%s' is listed in the hosts file.", WSAGetLastError(), szBuff); <br> <br>         MessageBox(hWnd, szTemp, "gethostbyname() failed.", MB_OK); <br>         return FALSE; <br>      } <br>      memcpy((char FAR *)&amp;(psin-&gt;sin_addr), phe-&gt;h_addr, <br>         phe-&gt;h_length); <br> <br>      } <br>   else { // server <br> <br>      /* <br>      *   Retrieve my ip address.  Assuming the hosts file in <br>      *   in %systemroot%/system/drivers/etc/hosts contains my computer name. <br>      */ <br> <br>      dwSize = sizeof(szBuff); <br>      gethostname(szBuff, dwSize); <br> <br>      psin-&gt;sin_addr.s_addr = INADDR_ANY; <br>      } <br> <br> <br>   /* <br>   *   Retrieve the Port number <br>   */ <br>   status = DialogBox(hInst,             /* current instance         */ <br>      "TCPPORTNUM",                      /* resource to use          */ <br>      hWnd,                              /* parent handle            */ <br>      GetTcpPort);                       /* instance address         */ <br> <br>   switch(status) { <br>      case 0:               /* User cancelled request from prev. dialog box */ <br>         return FALSE; <br> <br>      case 1:               /* actual port number entered */ <br>         psin-&gt;sin_port = htons(portno);        /* Convert to network ordering */ <br>         break; <br> <br>      case 2:               /* service name entereted */ <br>         /* <br>         *   Find the service name, szBuff, which is a type tcp protocol in <br>         *   the "services" file. <br>         */ <br>         pse = getservbyname(szBuff, "tcp"); <br>         if (pse == NULL)  { <br>            sprintf(szBuff, "%d is the error. Make sure this is a valid TCP service.", WSAGetLastError()); <br>            MessageBox(hWnd, szBuff, "getservbyname(sock) failed", MB_OK); <br>            return FALSE; <br>         } <br>         psin-&gt;sin_port = pse-&gt;s_port; <br>         break; <br> <br>      default: <br>         return FALSE; <br>   } <br>   return TRUE; <br>} <br> <br>/**************************************************************************** <br>* <br>*    FUNCTION: SetConnectMenus( HWND ) <br>* <br>*    PURPOSE: Gray/Enable the proper menu items after a connection has been <br>*             established. <br>* <br>*\***************************************************************************/ <br> <br>void SetConnectMenus( HWND hWnd ) <br>{ <br>   /* <br>   *   Disable/enable proper menu items. <br>   */ <br>   EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_ENABLED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_GRAYED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_GRAYED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_GRAYED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_GRAYED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_CANCEL, MF_GRAYED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_SENDTCP, MF_ENABLED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_ACCEPTEX, MF_GRAYED ); <br>   EnableMenuItem(GetMenu( hWnd ), IDM_CONNECTANDSEND, MF_GRAYED ); <br> <br>   /* <br>   *   Reflect socket connection in title bar. <br>   */ <br>   SetWindowText( hWnd, "Connected"); <br>} <br> <br>/****************************************************************************\ <br>* <br>*    FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG) <br>* <br>*    PURPOSE:  Processes main window messages <br>* <br>* MESSAGES: <br>*  WM_CREATE   - call WSAStartUp() and display description message <br>*  WSA_ACCEPT  - User-defined message used with WSAAsyncSelect().  Sent <br>*                by the Windows Sockets DLL when a socket connection is <br>*                pending. <br>* <br>*  WM_COMMAND <br>*  IDM_CONNECT - Connect to a remote host. <br>*  IDM_LISTEN  - Use the BSD-Style accept(). <br>*  IDM_ALISTEN - Use the Windows Sockets Asynchronous APIs to detect when <br>*                a connection is made. <br>*  IDM_CANCEL  - Cancel the Asynchronous call above. <br>*  IDM_TLISTEN - Uses two threads to accept network connections (using the <br>*                BSD-Style accept(). <br>*  IDM_HOSTNAME- Display information about a host. <br>*  IDM_ABOUT   - About box. <br>* <br>*  WM_DESTROY  - destroy window and call the WSACleanUp() <br>* <br>*\***************************************************************************/ <br> <br>LONG APIENTRY MainWndProc( <br>        HWND hWnd,                /* window handle                   */ <br>        UINT message,             /* type of message                 */ <br>        UINT wParam,              /* additional information          */ <br>        LONG lParam)              /* additional information          */ <br>{ <br>   int status;             /* Status Code */ <br>   SOCKADDR_IN local_sin;  /* Local socket - internet style */ <br>   SOCKADDR_IN acc_sin;    /* Accept socket address - internet style */ <br>   int acc_sin_len;        /* Accept socket address length */ <br> <br> <br>   switch (message) { <br>   case WM_CREATE: <br>   { <br>      WSADATA WSAData; <br>      char szTemp[80]; <br> <br>      if ((status = WSAStartup(MAKEWORD(1,1), &amp;WSAData)) == 0) { <br>         MessageBox( hWnd, WSAData.szDescription, WSAData.szSystemStatus, MB_OK); <br>      } <br>      else { <br>         sprintf(szTemp, "%d is the err", status); <br>         MessageBox( hWnd, szTemp, "Error", MB_OK); <br>      } <br>   } <br>   break;   /* WM_CREATE */ <br> <br>   /* <br>   *    Notification if data is waiting on a socket.  This comes <br>   *    from Windows Sockets (via WSAAsyncSelect()). <br>   */ <br>   case WSA_READ: <br>   { <br>      char szTemp[ MY_MSG_LENGTH ]; <br> <br>      if (WSAGETSELECTEVENT(lParam) == FD_READ) { <br>         status = recv((SOCKET)wParam, szTemp, MY_MSG_LENGTH, NO_FLAGS_SET ); <br> <br>         if (status) { <br>            szTemp[ status ] = '\0'; <br>            MessageBox( hWnd, szTemp, "WSA_READ", MB_OK); <br>         } <br>         else <br>            MessageBox( hWnd, "Connection broken", "Error", MB_OK); <br>      } <br>      else {    /* FD_CLOSE -- connection dropped */ <br>         MessageBox( hWnd, "Connection lost", "WSA_READ", MB_OK); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CANCEL, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_SENDTCP, MF_GRAYED); <br>      } <br> <br> <br>   } <br>   break;       /* WSA_READ*/ <br> <br>   case WSA_ACCEPT: /* Notification if a socket connection is pending. */ <br>      /* <br>      *   Disable/enable proper menu items. <br>      */ <br>      EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_ENABLED); <br>      EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_ENABLED); <br>      EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_ENABLED); <br>      EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_ENABLED); <br>      EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_ENABLED); <br>      EnableMenuItem(GetMenu( hWnd ), IDM_CANCEL, MF_GRAYED); <br> <br>      if (WSAGETSELECTERROR( lParam ) == 0) {   /* Success */ <br> <br>         /* <br>         *   Accept the incoming connection. <br>         */ <br>         acc_sin_len = sizeof( acc_sin ); <br>         sock = accept( sock,(struct sockaddr FAR *) &amp;acc_sin, <br>            (int FAR *) &amp;acc_sin_len ); <br> <br>         if (sock &lt; 0) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "accept(sock) failed", MB_OK); <br>            break; <br>         } <br> <br>         MessageBox(hWnd, "accept()", "Accepted a connection!", MB_OK); <br> <br>         /* <br>         *   Now have a connection -- <br>         *   SetConnectMenus() grays/enables proper menu items <br>         */ <br>         SetConnectMenus( hWnd ); <br> <br>         /* <br>         *   Send main window a WSA_READ when either data is pending on <br>         *   the socket (FD_READ) or the connection is closed (FD_CLOSE) <br>         */ <br>         if ((status = WSAAsyncSelect( sock, hWnd, WSA_READ, FD_READ | FD_CLOSE )) &gt; 0) { <br>            wsprintf(szBuff, "%d (0x%x)", status, status); <br>            MessageBox( hWnd, "Error on WSAAsyncSelect()", szBuff, MB_OK); <br>            closesocket( sock ); <br>         } <br>      } <br>      else { <br>         MessageBox(hWnd, "accept()", "Error occured!", MB_OK); <br> <br>         /* <br>         *   Cancel any further notifications. <br>         */ <br>         WSAAsyncSelect( sock, hWnd, 0, 0); <br>         SetWindowText( hWnd, "Async Listen call canceled"); <br>      } <br>      break;   /* WSA_ACCEPT */ <br> <br> <br> <br>   case WM_COMMAND:        /* message: command from application menu */ <br>      switch(LOWORD(wParam)) { <br>      case IDM_CONNECT: /* Client - connect to remote host */ <br>      { <br>         /* <br> <br>         When a network client wants to connect to a server, <br>         it must have: <br>            1.) a TCP port number (gotten via getservbyname()) <br>            and <br>            2.) an IP address of the remote host (gotten via gethostbyname()). <br> <br>         The following summarizes the steps used to connect. <br>         Make a dialog box (HostName) <br>         Get the name of the remote host computer in which <br>          to connect from the user (store string in "szBuff" global var) <br>       * Check to see if the hosts file knows the computer (gethostbyname) <br>       * Get the host information (hostent structure filled) <br>       * Fill in the address of the remote host into the servent structure (memcpy) <br>       * Make a dialog box (TCPPORTNUM) <br>       * Get the NAME of the port to connect to on the remote host from the <br>         user. <br>       * Get the port number (getservbyname) <br>       * Fill in the port number of the servent structure <br>         Establish a connection (connect) <br> <br>         The * prefixed steps are done in the FillAddr() procedure. <br> <br> <br>         */ <br>         SOCKADDR_IN dest_sin;  /* DESTination Socket INternet */ <br> <br> <br> <br>         /* Get the name of the remote host. Store the string in szBuff. */ <br> <br>         status = DialogBox(hInst, <br>            "HOSTNAME", <br>            hWnd, <br>            GetHostName); <br> <br>         if (!status)   /* User cancelled request from prev. dialog box */ <br>            break; <br> <br>         sock = socket( AF_INET, SOCK_STREAM, 0); <br>         if (sock == INVALID_SOCKET) { <br>            MessageBox(hWnd, "socket() failed", "Error", MB_OK); <br>            break; <br>         } <br> <br>         /* <br>         *    Retrieve the IP address and TCP Port number <br>         *    Global variable szBuff contains the remote host name. <br>         */ <br>         if (!FillAddr( hWnd, &amp;dest_sin, TRUE)) { <br>            closesocket( sock ); <br>            break; <br>         } <br> <br> <br>         if (connect( sock, (PSOCKADDR) &amp;dest_sin, sizeof( dest_sin)) &lt; 0) { <br>            closesocket( sock ); <br>            MessageBox(hWnd, "connect() failed", "Error", MB_OK); <br>            break; <br>         } <br>         MessageBox(hWnd, "connect() worked!", "Success!", MB_OK); <br> <br>         /* <br>         *   Now have a connection -- <br>         *   SetConnectMenus() grays/enables proper menu items <br>         */ <br>         SetConnectMenus( hWnd ); <br> <br>         /* <br>         *   Send main window a WSA_READ when either data is pending on <br>         *   the socket (FD_READ) or the connection is closed (FD_CLOSE) <br>         */ <br>         if ((status = WSAAsyncSelect( sock, hWnd, WSA_READ, FD_READ | FD_CLOSE )) &gt; 0) { <br>            wsprintf(szBuff, "%d (0x%x)"); <br>            MessageBox( hWnd, "Error on WSAAsyncSelect()", szBuff, MB_OK); <br>            closesocket( sock ); <br>         } <br> <br>      } <br>      break;   /* IDM_CONNECT */ <br> <br>      case IDM_CONNECTANDSEND: <br>      { <br>         // <br>         // <br>         //  In order to simulate a more typical real-world client, here <br>         //   we make the connection, and then immediately send it data. <br>         // <br>         //  See IDM_CONNECT above for full comments. <br> <br>         SOCKADDR_IN dest_sin; <br> <br>         status = DialogBox(hInst, <br>            "HOSTNAME", <br>            hWnd, <br>            GetHostName); <br> <br>         if (!status) <br>            break; <br> <br>         sock = socket( AF_INET, SOCK_STREAM, 0); <br>         if (sock == INVALID_SOCKET) { <br>            MessageBox(hWnd, "socket() failed", "Error", MB_OK); <br>            break; <br>         } <br> <br>         if (!FillAddr( hWnd, &amp;dest_sin, TRUE)) { <br>            closesocket( sock ); <br>            break; <br>         } <br> <br> <br>         if (connect( sock, (PSOCKADDR) &amp;dest_sin, sizeof( dest_sin)) &lt; 0) { <br>            MessageBox(hWnd, "connect() failed", "Error", MB_OK); <br>            closesocket( sock ); <br>            break; <br>         } <br> <br>         if (send (sock, gpszHelloWorld, lstrlen (gpszHelloWorld), 0 ) == SOCKET_ERROR) { <br>            wsprintf(szBuff, "WSAGetLastError: %d", WSAGetLastError()); <br>            MessageBox( hWnd, szBuff, "Error on send()", MB_OK); <br>            closesocket( sock ); <br>            break; <br>         } <br> <br> <br>         MessageBox(hWnd, "connect() &amp; send() worked!", "Success!", MB_OK); <br> <br>         SetConnectMenus( hWnd ); <br> <br>         if ((status = WSAAsyncSelect( sock, hWnd, WSA_READ, FD_READ | FD_CLOSE )) &gt; 0) { <br>            wsprintf(szBuff, "WSAGetLastError: %d", WSAGetLastError()); <br>            MessageBox( hWnd, "Error on WSAAsyncSelect()", szBuff, MB_OK); <br>            closesocket( sock ); <br>         } <br> <br>      } <br>      break;   // IDM_CONNECTANDSEND <br> <br> <br>      case IDM_ACCEPTEX: <br>      { <br>        // <br>        // Demonstrate the use of AcceptEx(). <br>        // <br> <br>#define MAX_BYTES        2000 <br>#define PADDED_ADDR_SIZE sizeof(SOCKADDR_IN)+16 <br>        SOCKET sListenSocket; <br>        SOCKET sAcceptSocket; <br>        char   pData [MAX_BYTES]; <br>        OVERLAPPED olResult; <br>        DWORD dwBytes; <br> <br> <br>        // <br>        // For this API, we need to create two sockets ahead of time. <br>        //  The listen socket goes through the standard bind/listen steps. <br>        // <br> <br>        sListenSocket = socket( AF_INET, SOCK_STREAM, 0); <br>        sAcceptSocket = socket( AF_INET, SOCK_STREAM, 0); <br>        if ((sListenSocket == INVALID_SOCKET) || (sAcceptSocket == INVALID_SOCKET)) { <br>           MessageBox(hWnd, "sock == INVALID_SOCKET", "socket() failed", MB_OK); <br>           closesocket(sListenSocket); <br>           closesocket(sAcceptSocket); <br>           break; <br>        } <br> <br>        // <br>        //   Retrieve the IP address and TCP Port number <br>        // <br> <br>        if (!FillAddr(hWnd, &amp;local_sin, FALSE )) <br>           break; <br> <br>        // <br>        //   Associate an address with the socket <br>        // <br> <br>        if (bind( sListenSocket, (struct sockaddr FAR *) &amp;local_sin, sizeof(local_sin)) == SOCKET_ERROR) { <br>           wsprintf(szBuff, "WSAGetLastError: %d", WSAGetLastError()); <br>           MessageBox(hWnd, szBuff, "bind(sock) failed", MB_OK); <br>           break; <br>        } <br> <br>        // <br>        //   And go into the listening state. <br>        // <br> <br>        if (listen( sListenSocket, MAX_PENDING_CONNECTS ) &lt; 0) { <br>           wsprintf(szBuff, "WSAGetLastError: %d", WSAGetLastError()); <br>           MessageBox(hWnd, szBuff, "listen(sock) failed", MB_OK); <br>           break; <br>        } <br> <br>        // <br>        //   Disable/enable proper menu items. <br>        // <br> <br>        EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_GRAYED); <br>        EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_GRAYED); <br>        EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_GRAYED); <br>        EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_GRAYED); <br>        EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_GRAYED); <br>        EnableMenuItem(GetMenu( hWnd ), IDM_ACCEPTEX, MF_GRAYED); <br>        EnableMenuItem(GetMenu( hWnd ), IDM_CONNECTANDSEND, MF_GRAYED); <br> <br>        SetWindowText( hWnd, "AcceptEx.."); <br> <br>        // <br>        //  Create an event for our overlapped structure (required). <br>        // <br> <br>        memset (&amp;olResult,  0, sizeof(olResult)); <br>        olResult.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL); <br>        dwBytes = 0; <br> <br>        // <br>        //  AcceptEx makes the most sense when used with I/O <br>        //   CompletionPorts and TransmitFile. <br>        //   We show a very basic usage here... <br>        // <br> <br>        if (AcceptEx( sListenSocket, <br>                      sAcceptSocket, <br>                      pData, <br>                      MAX_BYTES - 2*PADDED_ADDR_SIZE, <br>                      PADDED_ADDR_SIZE, <br>                      PADDED_ADDR_SIZE, <br>                      &amp;dwBytes, <br>                      &amp;olResult) == FALSE) { <br> <br>            if (WSAGetLastError() != ERROR_IO_PENDING) { <br>               wsprintf(szBuff, "WSAGetLastError: %d", WSAGetLastError()); <br>               MessageBox( hWnd, szBuff, "Error on AcceptEx()", MB_OK); <br>               break; <br>            } else { <br> <br>               // <br>               // In our contrived scenario, we expect GetLastError to be <br>               //  ERROR_IO_PENDING.  A real app would do other work. <br>               //  Since this is a simple sample, we will just block waiting <br>               //  for some input to come through the socket. <br>               // <br> <br>               GetOverlappedResult ( (HANDLE) sAcceptSocket, <br>                                     &amp;olResult, <br>                                     &amp;dwBytes, <br>                                     TRUE); <br>               pData[dwBytes] = 0; <br>               MessageBox(hWnd, pData, "AcceptEx received data", MB_OK); <br> <br>            } <br>        } <br> <br>        // <br>        //  As per the documentation, poke the new socket so that it will have <br>        //   the correct properties and can be used by other functions. <br>        // <br> <br>        if (setsockopt( sAcceptSocket, <br>                        SOL_SOCKET, <br>                        SO_UPDATE_ACCEPT_CONTEXT, <br>                        (char *)&amp;sListenSocket, <br>                        sizeof(sListenSocket) )) { <br>                wsprintf(szBuff, "WSAGetLastError: %d", WSAGetLastError()); <br>                MessageBox( hWnd, szBuff, "Error in setsockopt()", MB_OK); <br>                break; <br>        } else { <br> <br>        // <br>        //  sAcceptSocket is now OK for use by other functions. <br>        //  set it into our global socket (sock) <br>        // <br>            sock = sAcceptSocket; <br>        } <br> <br>        // <br>        //  In any case, we are done with our listen socket <br>        // <br> <br>        closesocket( sListenSocket ); <br> <br>        // <br>        //  Now have a connection -- <br>        //   SetConnectMenus() grays/enables proper menu items <br> <br>        SetConnectMenus( hWnd ); <br> <br>        // <br>        //  Send main window a WSA_READ when either data is pending on <br>        //  the socket (FD_READ) or the connection is closed (FD_CLOSE) <br> <br>        if ((status = WSAAsyncSelect( sock, hWnd, WSA_READ, FD_READ | FD_CLOSE )) &gt; 0) { <br>           wsprintf(szBuff, "%d (0x%x)"); <br>           MessageBox( hWnd, "Error on WSAAsyncSelect()", szBuff, MB_OK); <br>           closesocket( sock ); <br>        } <br>      } <br>      break;   /* IDM_ACCEPTEX */ <br> <br> <br>      case IDM_LISTEN: <br>      { <br>         sock = socket( AF_INET, SOCK_STREAM, 0); <br>         if (sock == INVALID_SOCKET) { <br>            MessageBox(hWnd, "socket() failed", "Error", MB_OK); <br>            closesocket(sock); <br>            break; <br>         } <br> <br>         /* <br>         *   Retrieve the IP address and TCP Port number <br>         */ <br> <br>         if (!FillAddr(hWnd, &amp;local_sin, FALSE )) <br>            break; </code></pre>
<p>
</p>
<pre><code><br>         /* <br>         *   Disable/enable proper menu items. <br>         */ <br>         EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ACCEPTEX, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECTANDSEND, MF_GRAYED); <br> <br>         SetWindowText( hWnd, "Waiting for connection.."); <br> <br> <br>         /* <br>         *   Associate an address with a socket. (bind) <br>         */ <br>         if (bind( sock, (struct sockaddr FAR *) &amp;local_sin, sizeof(local_sin)) == SOCKET_ERROR) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "bind(sock) failed", MB_OK); <br>            break; <br>         } <br> <br>         if (listen( sock, MAX_PENDING_CONNECTS ) &lt; 0) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "listen(sock) failed", MB_OK); <br>            break; <br>         } <br> <br>         acc_sin_len = sizeof(acc_sin); <br> <br> <br>         sock = accept( sock,(struct sockaddr FAR *) &amp;acc_sin, <br>            (int FAR *) &amp;acc_sin_len ); <br>         if (sock &lt; 0) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "accept(sock) failed", MB_OK); <br>            break; <br>         } <br> <br>         MessageBox(hWnd, "accept()", "Accepted a connection!", MB_OK); <br> <br>         /* <br>         *   Now have a connection -- <br>         *   SetConnectMenus() grays/enables proper menu items <br>         */ <br>         SetConnectMenus( hWnd ); <br> <br>         /* <br>         *   Send main window a WSA_READ when either data is pending on <br>         *   the socket (FD_READ) or the connection is closed (FD_CLOSE) <br>         */ <br>         if ((status = WSAAsyncSelect( sock, hWnd, WSA_READ, FD_READ | FD_CLOSE )) &gt; 0) { <br>            wsprintf(szBuff, "%d (0x%x)"); <br>            MessageBox( hWnd, "Error on WSAAsyncSelect()", szBuff, MB_OK); <br>            closesocket( sock ); <br>         } <br> <br>      } <br>      break;   /* IDM_LISTEN */ <br> <br>      /* <br>      *   Asynchronous Listen - Using WSA extensions. <br>      */ <br>      case IDM_ALISTEN: <br>      { <br> <br>         sock = socket( AF_INET, SOCK_STREAM, 0); <br>         if (sock == INVALID_SOCKET) { <br>            MessageBox(hWnd, "socket() failed", "Error", MB_OK); <br>            break; <br>         } <br>         /* <br>         *   Retrieve the IP address and TCP Port number <br>         */ <br> <br>         if (!FillAddr( hWnd, &amp;local_sin, FALSE)) { <br>            closesocket( sock ); <br>            break; <br>         } <br> <br>         /* <br>         *   Disable/enable proper menu items. <br>         */ <br>         EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CANCEL, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ACCEPTEX, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECTANDSEND, MF_GRAYED); <br> <br>         SetWindowText( hWnd, "Waiting for connection.. (Async)"); <br> <br> <br>         /* <br>         *   Associate an address with a socket. (bind) <br>         */ <br>         if (bind( sock, (struct sockaddr FAR *) &amp;local_sin, sizeof(local_sin)) == SOCKET_ERROR) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "bind(sock) failed", MB_OK); <br>            closesocket( sock ); <br>            break; <br>         } <br> <br>         if (listen( sock, MAX_PENDING_CONNECTS ) &lt; 0) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "listen(sock) failed", MB_OK); <br>            break; <br>         } <br> <br>         /* <br>         *   Send window a WSA_ACCEPT when something is trying to connect. <br>         */ <br>         if ((status = WSAAsyncSelect( sock, hWnd, WSA_ACCEPT, FD_ACCEPT)) &gt; 0) { <br>            wsprintf( szBuff, "%d (0x%x)"); <br>            MessageBox( hWnd, "Error on WSAAsyncSelect()", szBuff, MB_OK); <br>            SetWindowText( hWnd, "Async listen cancelled"); <br>            closesocket( sock ); <br>         } <br> <br>      } <br>      break;   /* IDM_ALISTEN */ <br> <br> <br>      /* <br>      *   Cancel an asynchronous call. <br>      */ <br>      case IDM_CANCEL: <br>         WSAAsyncSelect( sock, hWnd, 0, 0); <br>         SetWindowText( hWnd, "Async Listen cancelled.."); <br> <br>         /* <br>         *   Disable/enable proper menu items. <br>         */ <br>         EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CANCEL, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_SENDTCP, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ACCEPTEX, MF_ENABLED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECTANDSEND, MF_ENABLED); <br> <br>         break;   /* IDM_CANCEL */ <br> <br>      /* <br>      * Listen in the main thread -- spawn and accept two network <br>      *  connections inside two threads. <br>      */ <br>      case IDM_TLISTEN: <br>      { <br>         static THREADPACK tp; <br> <br>         sock = socket( AF_INET, SOCK_STREAM, 0); <br>         if (sock == INVALID_SOCKET) { <br>            MessageBox(hWnd, "socket() failed", "Error", MB_OK); <br>            closesocket(sock); <br>            break; <br>         } <br> <br>         /* <br>         *   Retrieve the IP address and TCP Port number <br>         */ <br> <br>         if (!FillAddr(hWnd, &amp;local_sin, FALSE )) <br>            break; <br> <br>         /* <br>         *   Disable/enable proper menu items. <br>         */ <br>         EnableMenuItem(GetMenu( hWnd ), IDM_HOSTNAME, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_LISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ALISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_TLISTEN, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECT, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_SENDTCP, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_ACCEPTEX, MF_GRAYED); <br>         EnableMenuItem(GetMenu( hWnd ), IDM_CONNECTANDSEND, MF_GRAYED); <br> <br>         SetWindowText( hWnd, "Waiting for connection.."); <br> <br> <br>         /* <br>         *   Associate an address with a socket. (bind) <br>         */ <br>         if (bind( sock, (struct sockaddr FAR *) &amp;local_sin, sizeof(local_sin)) == SOCKET_ERROR) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "bind(sock) failed", MB_OK); <br>            break; <br>         } <br> <br>         if (listen( sock, MAX_PENDING_CONNECTS ) &lt; 0) { <br>            sprintf(szBuff, "%d is the error", WSAGetLastError()); <br> <br>            MessageBox(hWnd, szBuff, "listen(sock) failed", MB_OK); <br>            break; <br>         } <br> <br>         tp.nThread = 0; <br>         tp.hWnd = hWnd; <br> <br>         _beginthread(AcceptThreadProc, 0, &amp;tp); <br> <br>         } <br>         break;   /* IDM_TLISTEN */ <br> <br> <br>      /* <br>      *   Display host information. <br>      */ <br>      case IDM_HOSTNAME: <br> <br>         /* <br>         *  Prompt the user and retrieve the text name of the host. <br>         */ <br>         status = DialogBox(hInst, <br>            "HOSTNAME", <br>            hWnd, <br>            GetHostName); <br> <br> <br>         if (status == TRUE) {   /* If user hit "OK" .. */ <br> <br>         /* <br>         *   Get the host information <br>         */ <br> <br>         if ((phe = gethostbyname( szBuff )) == NULL) { <br>            MessageBox(hWnd, "gethostbyname() failed", "Error", MB_OK); <br>            break; <br>         } <br>         else { <br> <br>         /* <br>         *   Display the host information .. <br>         */ <br>            DialogBox(hInst, <br>               "DISPLAYHOST", <br>               hWnd, <br>               DisplayHostEnt); <br>         } <br>      } <br>      break;   /* IDM_HOSTNAME */ <br>      /* <br>      *   Send a message to (via TCP connection) to remote host. <br>      */ <br>      case IDM_SENDTCP: <br>         DialogBox(hInst,                /* current instance         */ <br>            "GetString",                 /* resource to use          */ <br>            hWnd,                        /* parent handle            */ <br>            GetSendString);              /* instance address         */ <br> <br>        /* <br>        *   Assumption -- The GetString dialog box proc fills the global <br>        *   string buffer, szBuff, with the desired string to send. <br>        */ <br>        send(sock, szBuff, strlen(szBuff), NO_FLAGS_SET ); <br> <br>        break;   /* IDM_SENDTCP */ <br> <br> <br> <br>      case IDM_ABOUT: <br>         DialogBox(hInst,                /* current instance         */ <br>            "AboutBox",                  /* resource to use          */ <br>            hWnd,                        /* parent handle            */ <br>            About);                      /* About() instance address */ <br> <br>         break;   /* IDM_ABOUT */ <br> <br>      default: <br>         /* Lets Windows process it          */ <br>         return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         break; <br>      } <br>   break; <br> <br> <br>   /* <br>   *   Clean up.  Takes care of any open socket descriptors. <br>   */ <br>   case WM_DESTROY: <br>      WSACleanup(); <br>      PostQuitMessage(0); <br>      break; <br> <br>   default:                       /* Passes it on if unproccessed    */ <br>      return (DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>   } <br>   return (0); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
