<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DT_DLL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5242"></a>DT_DLL.CPP</h2>
<pre><code>/*++ <br> <br>  Copyright (c) 1995 Intel Corp <br> <br>  File Name: <br> <br>    dt_dll.cpp <br> <br>  Abstract: <br> <br>    Contains main and supporting functions for a Debug/Trace <br>    DLL for the WinSock2 DLL.  See the design spec <br>    for more information. <br> <br>--*/ <br> <br>// <br>// Include Files <br>// <br> <br>#include "nowarn.h"  /* turn off benign warnings */ <br>#ifndef _WINSOCKAPI_ <br>#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */ <br>#endif <br> <br>#include "nowarn.h"  /* some warnings may have been turned back on */ <br>#include &lt;winsock2.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;ws2spi.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "dt_dll.h" <br>#include "cstack.h" <br>#include "dt.h" <br>#include "handlers.h" <br> <br>// <br>// Forward References for Functions <br>// <br> <br>LRESULT APIENTRY <br>DTMainWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam); <br> <br>LRESULT APIENTRY <br>DTEditWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam); <br> <br>BOOL WINAPI <br>DllMain( <br>    HINSTANCE DllInstHandle, <br>    DWORD     Reason, <br>    LPVOID    Reserved); <br> <br>DWORD <br>WindowThreadFunc(LPDWORD TheParam); <br> <br>BOOL APIENTRY <br>DebugDlgProc( <br>    IN HWND hwndDlg, <br>    IN UINT message, <br>    IN WPARAM wParam, <br>    IN LPARAM lParam); <br> <br>BOOL <br>GetFile( <br>    IN  HWND   OwnerWindow, <br>    OUT  LPSTR Buffer, <br>    IN  DWORD  BufSize); <br> <br>void <br>AbortAndClose( <br>    IN HANDLE FileHandle, <br>    IN HWND WindowHandle); <br> <br> <br> <br> <br>// <br>// Externally Visible Global Variables <br>// <br> <br>HWND   DebugWindow;               // handle to the child edit control <br>HANDLE LogFileHandle;             // handle to the log file <br>DWORD  OutputStyle = WINDOW_ONLY; // where to put output <br>char   Buffer[TEXT_LEN];          // buffer for building output strings <br> <br> <br> <br>// <br>// Static Global Variables <br>// <br> <br>// name for my window class <br>static char             DTWndClass[] = "DTWindow"; <br> <br>static HWND             FrameWindow;   // handle to frame of debug window <br>static WNDPROC          EditWndProc;   // the edit control's window proc <br>static HINSTANCE        DllInstHandle; // handle to the dll instance <br>static DWORD            TlsIndex;      // tls index for this module <br>static CRITICAL_SECTION CrSec;         // critical section for text output <br>static HANDLE           TextOutEvent;  // set when debug window is ready <br> <br>static char             LogFileName[256]; // name of the log file <br> <br>// handle to and id of the main thread of the DLL which initializes <br>// and creates windows, etc <br>static HANDLE           WindowThread; <br>static DWORD            WindowThreadId; <br> <br>// function pointer tables for handler functions. <br>static LPFNDTHANDLER  HdlFuncTable[MAX_DTCODE + 1]; <br> <br>// static strings <br>static char ErrStr1[] = "Couldn't open file.  Debug output will go to \ <br>debug window."; <br>static char  ErrStr2[] = "An error occurred while trying to get a log \ <br>filename.  Debug output will go to the window only."; <br>static char ErrStr3[] = "Had problems writing to file.  Aborting file \ <br>ouput -- all debug output will now go to the debugging window"; <br> <br> <br> <br> <br>// <br>// Function Definitions <br>// <br> <br>  <br>BOOL WINAPI <br>DllMain( <br>    HINSTANCE InstanceHandle, <br>    DWORD     Reason, <br>    LPVOID    Reserved) <br>/*++ <br> <br>  DllMain() <br> <br>  Function Description: <br> <br>      Please see Windows documentation for DllEntryPoint. <br> <br>  Arguments: <br> <br>      Please see windows documentation. <br> <br>  Return Value: <br> <br>      Please see windows documentation. <br> <br>--*/ <br>{ <br> <br>    Cstack_c   *ThreadCstack;  // points to Cstack objects in tls <br>    PINITDATA  InitDataPtr;    // to pass to the window creation thread <br> <br>    switch(Reason) { <br> <br>    // Determine the reason for the call and act accordingly. <br> <br>    case DLL_PROCESS_ATTACH: <br> <br>        DllInstHandle = InstanceHandle; <br>        InitializeCriticalSection(&amp;CrSec); <br>        TextOutEvent = CreateEvent(NULL, TRUE, FALSE, NULL); <br> <br>        // Fill in the handler function table. <br>        DTHandlerInit(HdlFuncTable, MAX_DTCODE); <br> <br>        // Allocate a TLS index. <br>        TlsIndex = TlsAlloc(); <br> <br>        // Pop up a dialog box for the user to choose output method. <br>        DialogBox(DllInstHandle, <br>                  MAKEINTRESOURCE(IDD_DIALOG1), <br>                  NULL, <br>                  (DLGPROC)DebugDlgProc); <br> <br>        if ((OutputStyle == FILE_ONLY) || (OutputStyle == FILE_AND_WINDOW)) { <br> <br>            LogFileHandle = CreateFile(LogFileName, <br>                                       GENERIC_WRITE, <br>                                       FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                                       NULL, <br>                                       CREATE_ALWAYS, <br>                                       FILE_ATTRIBUTE_NORMAL, <br>                                       NULL); <br>            if (LogFileHandle == INVALID_HANDLE_VALUE) { <br>                OutputStyle = WINDOW_ONLY; <br>                MessageBox(NULL, ErrStr1, "Error", MB_OK | MB_ICONSTOP); <br>            } <br>        } <br> <br>        // Get some information for later output to the debug window <br>        // or file -- get the time, PID, and TID of the calling <br>        // process and put into a INITDATA struct.  This memory will <br>        // be freed by the thread it is passed to. <br>        InitDataPtr = (PINITDATA) LocalAlloc(0, sizeof(INITDATA)); <br>        GetLocalTime(&amp;(InitDataPtr-&gt;LocalTime)); <br>        InitDataPtr-&gt;TID = GetCurrentThreadId(); <br>        InitDataPtr-&gt;PID = GetCurrentProcessId(); <br> <br>        // Create the initialization/window handling thread. <br>        if ((OutputStyle == WINDOW_ONLY) || (OutputStyle == FILE_AND_WINDOW)) { <br>            WindowThread = <br>              CreateThread(NULL, <br>                           0, <br>                           (LPTHREAD_START_ROUTINE)WindowThreadFunc, <br>                           (LPVOID)InitDataPtr, <br>                           0, <br>                           &amp;WindowThreadId); <br>        } else { <br> <br>            // Normally the window thread does a DTTextOut of the time <br>            // and process info that we saved just above.  But in this <br>            // case,  there is no window thread so spit it out to the <br>            // file. <br> <br>            wsprintf(Buffer, "Log initiated: %d-%d-%d, %d:%d:%d\r\n", <br>                     InitDataPtr-&gt;LocalTime.wMonth, <br>                     InitDataPtr-&gt;LocalTime.wDay, <br>                     InitDataPtr-&gt;LocalTime.wYear, <br>                     InitDataPtr-&gt;LocalTime.wHour, <br>                     InitDataPtr-&gt;LocalTime.wMinute, <br>                     InitDataPtr-&gt;LocalTime.wSecond); <br>            DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br>            wsprintf(Buffer, "Process ID: 0x%X   Thread ID: 0x%X\r\n", <br>                     InitDataPtr-&gt;PID, <br>                     InitDataPtr-&gt;TID); <br>            DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br> <br>            // Setting this event allows {Pre|Post}ApiNotify to <br>            // proceed.  This event isn't really needed in this case <br>            // (because there is only one thread, and we know the code <br>            // above has been executed before WSAPre|PostApiNotify). <br>            SetEvent(TextOutEvent); <br>        } <br> <br>        // flow through... <br> <br>    case DLL_THREAD_ATTACH: <br> <br>        // Store a pointer to a new Cstack_c in the slot for this <br>        // thread. <br>        ThreadCstack = new Cstack_c(); <br>        TlsSetValue(TlsIndex, (LPVOID)ThreadCstack); <br> <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br> <br>        // Free up some resources.  This is like cleaning up your room <br>        // before the tornado strikes, but hey, it's good practice. <br>        TlsFree(TlsIndex); <br>        DeleteCriticalSection(&amp;CrSec); <br> <br>        if ((OutputStyle == FILE_ONLY) || (OutputStyle == FILE_AND_WINDOW)) { <br>            CloseHandle(LogFileHandle); <br>        } <br>        CloseHandle(WindowThread); <br> <br>        break; <br> <br>    case DLL_THREAD_DETACH: <br> <br>        // Get the pointer to this thread's Cstack, and delete the <br>        // object. <br>        ThreadCstack = (Cstack_c *)TlsGetValue(TlsIndex); <br>        delete ThreadCstack; <br> <br>        break; <br> <br>    default: <br> <br>        break; <br>    } // switch (Reason) <br> <br>    return TRUE; <br>} // DllMain() <br> <br> <br> <br> <br>  <br>BOOL WINAPIV <br>WSAPreApiNotify( <br>    IN  INT    NotificationCode, <br>    OUT LPVOID ReturnCode, <br>    IN  LPSTR  LibraryName, <br>    ...) <br>/*++ <br> <br>  Function Description: <br> <br>      Builds a string for output and passes it, along with information <br>      about the call, to a handler function. <br> <br>  Arguments: <br> <br>      NotificationCode -- specifies which API function called us. <br> <br>      ReturnCode -- a generic pointer to the return value of the API <br>      function.  Can be used to change the return value in the <br>      case of a short-circuit (see how the return value from <br>      PreApiNotify works for more information on short-circuiting <br>      the API function). <br> <br>      LibraryName -- a string pointing to the name of the library that <br>      called us. <br> <br>      ...    -- variable number argument list.  These are pointers <br>      to the actual parameters of the API functions. <br> <br>  Return Value: <br> <br>      Returns TRUE if we want to short-circuit the API function; <br>      in other words, returning non-zero here forces the API function <br>      to return immediately before any other actions take place. <br> <br>      Returns FALSE if we want to proceed with the API function. <br> <br>--*/ <br>{ <br>    va_list          vl;            // used for variable arg-list parsing <br>    Cstack_c         *ThreadCstack; // the Cstack_c object for this thread <br>    int              Index = 0;     // index into string we are creating <br>    BOOL             ReturnValue;   // value to return <br>    LPFNDTHANDLER    HdlFunc;       // pointer to handler function <br>    int              Counter;       // counter popped off the cstack <br>    int              OriginalError; // any pending error is saved <br>    int              HandlerError;  // the error after handler returns <br> <br>    EnterCriticalSection(&amp;CrSec); <br>    OriginalError = GetLastError(); <br> <br>    // Wait until the debug window is ready to receive text for output. <br>    WaitForSingleObject(TextOutEvent, INFINITE); <br>    va_start(vl, LibraryName); <br> <br>    // Get the Cstack_c object for this thread. <br>    ThreadCstack = (Cstack_c *)TlsGetValue(TlsIndex); <br>    if (!ThreadCstack){ <br>        ThreadCstack = new Cstack_c(); <br>        TlsSetValue(TlsIndex, (LPVOID)ThreadCstack); <br>        wsprintf(Buffer, "0x%X Foriegn thread\n", <br>                 GetCurrentThreadId()); <br>        DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br>    } //if <br> <br>    // Start building an output string with some info that's <br>    // independent of which API function called us. <br>    Index += wsprintf(Buffer, "TID: 0x%X   ", GetCurrentThreadId()); <br>    Index += wsprintf(Buffer + Index, "Function call: %d   ", <br>                      ThreadCstack-&gt;CGetCounter()); <br> <br>    // Push the counter &amp; increment. <br>    ThreadCstack-&gt;CPush(); <br> <br>    // Reset the error to what it was when the function started. <br>    SetLastError(OriginalError); <br> <br>    // Call the appropriate handling function, output the buffer. <br>    if ((NotificationCode &lt; MAX_DTCODE) &amp;&amp; HdlFuncTable[NotificationCode]) { <br>        HdlFunc = HdlFuncTable[NotificationCode]; <br>        ReturnValue = (*HdlFunc)(vl, ReturnCode, <br>                                 LibraryName, <br>                                 Buffer, <br>                                 Index, <br>                                 TEXT_LEN, <br>                                 TRUE); <br>        HandlerError = GetLastError(); <br> <br>    } else { <br> <br>        wsprintf(Buffer + Index, "Unknown function called!\r\n"); <br>        DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br>        ReturnValue = FALSE; <br>    } <br> <br>    // If we are returning TRUE, then the API/SPI function will be <br>    // short-circuited.  We must pop the thread stack, since no <br>    // corresponding WSAPostApiNotify will be called. <br>    if (ReturnValue) { <br>        ThreadCstack-&gt;CPop(Counter); <br>    } <br> <br>    // In case the error has changed since the handler returned, we <br>    // want to set it back to that.  So if the handler set the error, <br>    // the function exits with that value; if not, it exits with the <br>    // original error. <br>    SetLastError(HandlerError); <br>    LeaveCriticalSection(&amp;CrSec); <br>    return(ReturnValue); <br> <br>} // WSAPreApiNotify() <br> <br> <br> <br> <br>  <br> <br>BOOL WINAPIV <br>WSAPostApiNotify( <br>    IN  INT    NotificationCode, <br>    OUT LPVOID ReturnCode, <br>    IN  LPSTR  LibraryName, <br>    ...) <br>/*++ <br> <br>  PostApiNotify() <br> <br>  Function Description: <br> <br>      Like PreApiNotify, builds a string and passes it, along with <br>      information about the call, to a handler function. <br> <br>  Arguments: <br> <br>      NotificationCode  -- specifies which API function called us. <br> <br>      ReturnCode -- a generic pointer to the return value of the API <br>      function. <br> <br>      ...    -- variable number argument list.  These are pointers <br>      to the actual parameters of the API functions. <br> <br>  Return Value: <br> <br>      Returns value is currently meaningless. <br> <br>--*/ <br>{ <br>    va_list          vl;            // used for variable arg-list parsing <br>    Cstack_c         *ThreadCstack; // the Cstack_c object for this thread <br>    int              Index = 0;     // index into string we are creating <br>    int              Counter;       // counter we pop off the cstack <br>    LPFNDTHANDLER    HdlFunc;       // pointer to handler function <br>    int              OriginalError; // any pending error is saved <br>    int              HandlerError;  // error after the handler returns <br> <br>    // Lets hope EnterCriticalSection() doesn't change the error... <br>    EnterCriticalSection(&amp;CrSec); <br>    OriginalError = GetLastError(); <br> <br>    // Wait until it's ok to send output. <br>    WaitForSingleObject(TextOutEvent, INFINITE); <br> <br>va_start(vl, LibraryName); <br> <br>// Get the cstack object from TLS, pop the Counter. <br>    ThreadCstack = (Cstack_c *) TlsGetValue(TlsIndex); <br> <br>    if (!ThreadCstack){ <br>        ThreadCstack = new Cstack_c(); <br>        TlsSetValue(TlsIndex, (LPVOID)ThreadCstack); <br>        wsprintf(Buffer, "0x%X Foriegn thread\n", <br>                 GetCurrentThreadId()); <br>        DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br>    } //if <br> <br>    ThreadCstack-&gt;CPop(Counter); <br> <br>    // Output some info that's independent of which API called us. <br>    Index += wsprintf(Buffer, "TID: 0x%X   ", GetCurrentThreadId()); <br>    Index += wsprintf(Buffer + Index, "Function Call: %d   ", Counter); <br> <br>    // Set the error to what it originally was. <br>    SetLastError(OriginalError); <br> <br>    // Call the appropriate handling function, output the buffer. <br>    if ((NotificationCode &lt; MAX_DTCODE) &amp;&amp; HdlFuncTable[NotificationCode]) { <br>        HdlFunc = HdlFuncTable[NotificationCode]; <br>        (*HdlFunc)(vl, ReturnCode, <br>                   LibraryName, <br>                   Buffer, <br>                   Index, <br>                   TEXT_LEN, <br>                   FALSE); <br>        HandlerError = GetLastError(); <br> <br>    } else { <br> <br>        wsprintf(Buffer + Index, "Unknown function returned!\r\n"); <br>        DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br>    } <br> <br>    // In case the error has changed since the handler returned, we <br>    // want to set it back to that.  So if the handler set the error, <br>    // the function exits with that value; if not, it exits with the <br>    // original error. <br>    SetLastError(HandlerError); <br>    LeaveCriticalSection(&amp;CrSec); <br>    return(FALSE); <br> <br>} // WSAPostApiNotify() <br> <br> <br> <br> <br>  <br>LRESULT APIENTRY <br>DTMainWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>  DTMainWndProc() <br> <br>  Function Description: <br> <br>      Window procedure for the main window of the Dll.  This function <br>      processes WM_CREATE messages in order to create a child <br>      edit control, which does most of the dirty work.  Also processes <br>      WM_COMMAND to trap notification messages from the edit control, <br>      as well as WM_SIZE and WM_DESTROY messages. <br> <br>  Arguments: <br> <br>      WindowHandle -- the window. <br> <br>      Message -- the message. <br> <br>      WParam -- first parameter. <br> <br>      LParam -- second parameter. <br> <br>  Return Value: <br> <br>      Message dependent. <br> <br>--*/ <br>{ <br> <br>    HFONT      FixedFontHandle;   // self-explanatory <br>    RECT       Rect;              // specifies client area of frame window <br>    DWORD      CharIndex1; <br>    DWORD      CharIndex2; <br>    DWORD      LineIndex;         // indices into edit control text <br>    char       NullString[] = ""; // self-explanatory <br>    DWORD      OldOutputStyle;    // temporary storage for OutputStyle <br> <br>    switch (Message) { <br> <br>    case WM_CREATE: <br> <br>        // Create the debug window as a multiline edit control. <br>        GetClientRect(WindowHandle, &amp;Rect); <br>        DebugWindow = CreateWindow("EDIT", <br>                                   NULL, <br>                                   WS_CHILD | WS_VISIBLE | <br>                                   WS_VSCROLL | ES_LEFT  | <br>                                   ES_MULTILINE | ES_AUTOVSCROLL, <br>                                   0, <br>                                   0, <br>                                   Rect.right, <br>                                   Rect.bottom, <br>                                   WindowHandle, <br>                                   (HMENU)EC_CHILD, <br>                                   DllInstHandle, <br>                                   NULL); <br> <br>        // Subclass the edit control's window procedure to be <br>        // DTEditWndProc. <br>        EditWndProc = (WNDPROC) SetWindowLong(DebugWindow, <br>                                              GWL_WNDPROC, <br>                                              (DWORD)DTEditWndProc); <br> <br>        // Set the edit control's text size to the maximum. <br>        SendMessage(DebugWindow, EM_LIMITTEXT, 0, 0); <br> <br>        // Set the edit control's font <br>        FixedFontHandle = (HFONT)GetStockObject(ANSI_FIXED_FONT); <br>        SendMessage(DebugWindow, WM_SETFONT, (WPARAM)FixedFontHandle, <br>                    MAKELPARAM(TRUE, 0)); <br> <br>        return(0); <br> <br>    case WM_COMMAND: <br> <br>        if (LOWORD(WParam) == EC_CHILD) { <br> <br>            // The notification is coming from the edit-control child. <br>            // Determine which notification it is and act appropriately. <br> <br>            switch (HIWORD(WParam)) { <br> <br>            case EN_ERRSPACE: <br> <br>                // Flow through <br> <br>            case EN_MAXTEXT: <br> <br>                // There's too much text in the edit control.  This is <br>                // a hack to eliminate approximately the first half of <br>                // the text, so we can then add more... <br>                CharIndex1 = GetWindowTextLength(DebugWindow) / 2; <br>                LineIndex = SendMessage(DebugWindow, EM_LINEFROMCHAR, <br>                                        (WPARAM)CharIndex1, 0); <br>                CharIndex2 = SendMessage(DebugWindow, EM_LINEINDEX, <br>                                         (WPARAM)LineIndex, 0); <br> <br>                SendMessage(DebugWindow, EM_SETSEL, 0, CharIndex2); <br>                SendMessage(DebugWindow, EM_REPLACESEL, 0, <br>                            (LPARAM)NullString); <br> <br>                // send this text to the window only... <br>                OldOutputStyle = OutputStyle; <br>                OutputStyle = WINDOW_ONLY; <br>                DTTextOut(DebugWindow, LogFileHandle, <br>                          "----Buffer Overflow...Resetting----\r\n", <br>                          OutputStyle); <br>                OutputStyle = OldOutputStyle; <br>                break; <br> <br>            case EN_CHANGE: <br>            case EN_UPDATE: <br> <br>                // Ignore these notification codes <br>                return 0; <br>                break; <br> <br>            default: <br> <br>                // Let the default window procedure handle it. <br>                return DefWindowProc(WindowHandle, Message, WParam, <br>                                 LParam); <br>            } // switch (HIWORD(WParam)) <br> <br>        } // if (LOWORD(WParam) == EC_CHILD) <br>        else { <br> <br>            // The notification is coming from somewhere else!!! <br>            return DefWindowProc(WindowHandle, Message, WParam, <br>                                 LParam); <br>        } <br> <br>        return(0); <br>        break; <br> <br>    case WM_DESTROY: <br> <br>        PostQuitMessage(0); <br>        return(0); <br> <br>    case WM_SIZE: <br> <br> <br>        // Make the edit control the size of the window's client area. <br>        MoveWindow(DebugWindow, 0, 0, LOWORD(LParam), HIWORD(LParam), TRUE); <br>        return(0); <br> <br>    default: <br> <br>        // All other messages are taken care of by the default. <br>        return(DefWindowProc(WindowHandle, Message, WParam, LParam)); <br> <br>    } // switch <br> <br>} // DTMainWndProc() <br> <br> <br> <br> <br>  <br>LRESULT APIENTRY <br>DTEditWndProc( <br>    IN HWND   WindowHandle, <br>    IN UINT   Message, <br>    IN WPARAM WParam, <br>    IN LPARAM LParam) <br>/*++ <br> <br>  DTEditWndProc() <br> <br>  Function Description: <br> <br>      Subclassed window procedure for the debug window.  This function <br>      disables some edit control functionality, and also responds to a <br>      user-defined message to print out text in the window. <br> <br>  Arguments: <br> <br>      WindowHandle -- the window. <br> <br>      Message -- the message. <br> <br>      WParam -- first parameter. <br> <br>      LParam -- second parameter. <br> <br>  Return Value: <br> <br>      Message dependent. <br> <br>--*/ <br>{ <br>    switch (Message) { <br> <br>    case WM_CHAR: <br> <br>        // Handle control-c so that copy works.  Sorry about the magic <br>        // number! <br>        if (WParam == 3) { <br>            return (CallWindowProc((WNDPROC)EditWndProc, WindowHandle, Message, <br>                                   WParam, LParam)); <br>        } // else flows through <br> <br>    case WM_KEYDOWN:    // Flow through <br>    case WM_UNDO:       // Flow through <br>    case WM_PASTE:      // Flow through <br>    case WM_CUT: <br> <br>        return (0);     // Effectively disables the above messages <br> <br>    default: <br> <br>        return (CallWindowProc(EditWndProc, WindowHandle, Message, <br>                               WParam, LParam)); <br>    } // switch <br> <br>} // DTEditWndProc() <br> <br> <br> <br> <br>  <br>DWORD <br>WindowThreadFunc( <br>    LPDWORD TheParam) <br>/*++ <br> <br>  WindowThreadFunc() <br> <br>  Function Description: <br> <br>      Thread function for WindowThread created in DllMain during <br>      process attachment.  Registers a window class, creates an <br>      instance of that class, and goes into a message loop to retrieve <br>      messages for that window or it's child edit control. <br> <br>  Arguments: <br> <br>      TheParam -- Pointer to the parameter passed in by the function <br>      that called CreateThread. <br> <br>  Return Value: <br> <br>      Returns the wParam of the quit message that forced us out of the <br>      message loop. <br> <br>--*/ <br>{ <br> <br>    WNDCLASS  wnd_class;    // window class structure to register <br>    MSG       msg;          // retrieved message <br>    PINITDATA InitDataPtr;  // casts TheParam into a INITDATA pointer <br> <br>    // Register a window class for the frame window. <br>    wnd_class.style         = CS_HREDRAW | CS_VREDRAW; <br>    wnd_class.lpfnWndProc   = DTMainWndProc; <br>    wnd_class.cbClsExtra    = 0; <br>    wnd_class.cbWndExtra    = 0; <br>    wnd_class.hInstance     = DllInstHandle; <br>    wnd_class.hIcon         = LoadIcon(NULL, IDI_APPLICATION); <br>    wnd_class.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wnd_class.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wnd_class.lpszMenuName  = NULL; <br>    wnd_class.lpszClassName = DTWndClass; <br>    RegisterClass(&amp;wnd_class); <br> <br>    // Create a frame window <br>    FrameWindow = CreateWindow(DTWndClass, <br>                               "Debug Window", <br>                               WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | <br>                               WS_VISIBLE, <br>                               CW_USEDEFAULT, <br>                               CW_USEDEFAULT, <br>                               CW_USEDEFAULT, <br>                               CW_USEDEFAULT, <br>                               NULL, <br>                               NULL, <br>                               DllInstHandle, <br>                               NULL); <br> <br>    // Send the initialization data to the debug window and/or file. <br>    InitDataPtr = (PINITDATA)TheParam; <br>    wsprintf(Buffer, "Log initiated: %d-%d-%d, %d:%d:%d\r\n", <br>             InitDataPtr-&gt;LocalTime.wMonth, <br>             InitDataPtr-&gt;LocalTime.wDay, <br>             InitDataPtr-&gt;LocalTime.wYear, <br>             InitDataPtr-&gt;LocalTime.wHour, <br>             InitDataPtr-&gt;LocalTime.wMinute, <br>             InitDataPtr-&gt;LocalTime.wSecond); <br>    DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br>    wsprintf(Buffer, "Process ID: 0x%X   Thread ID: 0x%X\r\n", <br>             InitDataPtr-&gt;PID, <br>             InitDataPtr-&gt;TID); <br>    DTTextOut(DebugWindow, LogFileHandle, Buffer, OutputStyle); <br>    LocalFree(InitDataPtr); <br> <br>    // Setting this event allows {Pre|Post}ApiNotify to proceed.  This <br>    // insures (ensures?  what's the difference) that any debugging <br>    // output by other threads is held up until after this statement. <br>    SetEvent(TextOutEvent); <br> <br>    // Go into a message loop. <br>    while (GetMessage(&amp;msg, NULL, 0 , 0)) { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    return(msg.wParam); <br> <br>} // WindowThreadFunc() <br> <br> <br> <br> <br>  <br>BOOL APIENTRY <br>DebugDlgProc( <br>    HWND DialogWindow, <br>    UINT Message, <br>    WPARAM WParam, <br>    LPARAM LParam) <br>/*++ <br> <br>  DebugDlgProc() <br> <br>  Function Description: <br> <br>      Window function for the dialog box IDC_DIALOG1, the dialog box <br>      that pops up when the dll is loaded and prompts the user for the <br>      output style of his/her choice. <br> <br>  Arguments: <br> <br>      DialogWindow -- handle to the dialog box window. <br> <br>      Message -- the message being received. <br> <br>      WParam -- first parameter. <br> <br>      LParam -- second parameter. <br> <br>  Return Value: <br> <br>      Returns TRUE to indicate message was handled, FALSE otherwise. <br> <br>--*/ <br>{ <br> <br>    DWORD LogFNSize = sizeof(LogFileName); // size of the file name buffer <br> <br>    switch (Message) { <br> <br>    case WM_COMMAND: <br> <br>        switch (LOWORD(WParam)) { <br> <br>        case IDOK: <br> <br>            // The user clicked the OK button...figure out his choice <br>            // and act appropriately. <br>            if (IsDlgButtonChecked(DialogWindow, IDC_RADIO5)) { <br> <br>                // Radio Button 1 was clicked. <br>                if (!GetFile(DialogWindow, LogFileName, LogFNSize)) { <br> <br>                    // Error -- OutputStyle stays WINDOW_ONLY. <br>                    MessageBox(DialogWindow, ErrStr2, "Error.", <br>                               MB_OK | MB_ICONSTOP); <br>                } else { <br>                    OutputStyle = FILE_ONLY; <br>                } <br> <br>            } else if (IsDlgButtonChecked(DialogWindow, IDC_RADIO6)) { <br> <br>                // Radio Button 2 was clicked. <br>                OutputStyle = WINDOW_ONLY; <br> <br>            } else if (IsDlgButtonChecked(DialogWindow, IDC_RADIO7)) { <br> <br>                // Radio Button 3 was clicked. <br>                if (!GetFile(DialogWindow, LogFileName, LogFNSize)) { <br> <br>                    // Error -- OutputStyle stays WINDOW_ONLY. <br>                    MessageBox(DialogWindow, ErrStr2, "Error", <br>                               MB_OK | MB_ICONSTOP); <br>                } else { <br>                    OutputStyle = FILE_AND_WINDOW; <br>                } <br> <br>            } else if (IsDlgButtonChecked(DialogWindow, IDC_RADIO8)) { <br> <br>                // Radio Button 4 was clicked. <br>                OutputStyle = DEBUGGER; <br> <br>            } else { <br> <br>                // No radio buttons were clicked -- pop up a Message <br>                // box. <br>                MessageBox(DialogWindow, "You must choose one output method.", <br>                           "Choose or Die.", MB_OK | MB_ICONSTOP); <br>                break; <br> <br>            } <br> <br>            // flow through <br> <br>        case IDCANCEL: <br> <br>            EndDialog(DialogWindow, WParam); <br>            return TRUE; <br> <br>        } <br> <br>    case WM_INITDIALOG: <br> <br>        return TRUE; <br> <br>    } <br>    return FALSE; <br> <br>} // DebugDlgProc() <br> <br> <br> <br> <br>  <br>BOOL <br>DTTextOut( <br>    IN HWND   WindowHandle, <br>    IN HANDLE FileHandle, <br>    IN char   *String, <br>    DWORD     Style) <br>/*++ <br> <br>  DTTextOut() <br> <br>  Function Description: <br> <br>      This function outputs a string to a debug window and/or file. <br> <br>  Arguments: <br> <br>      WindowHandle -- handle to an edit control for debug output. <br> <br>      FileHandle -- handle to an open file for debug output. <br> <br>      String -- the string to output. <br> <br>      Style -- specifies whether the output should go to the window, <br>      the file, or both. <br> <br>  Return Value: <br> <br>      Returns TRUE if the output succeeds, FALSE otherwise. <br> <br>--*/ <br>{ <br> <br>    DWORD NumWritten;           // WriteFile takes an address to this <br>    DWORD Index;                // index of end of edit control text <br>    BOOL  Result;               // result of WriteFile <br>    char  Output[TEXT_LEN];     // scratch buffer <br> <br>    static DWORD LineCount = 0; // text output line number <br>    DWORD  BufIndex = 0;        // index into output string <br> <br>    // Build a new string with the line-number in front. </code></pre>
<p>
</p>
<pre><code>BufIndex += wsprintf(Output, "(%d) ", LineCount++); <br>    strcpy(Output + BufIndex, String); <br> <br>    switch (Style) { <br> <br>    case WINDOW_ONLY: <br> <br>        Index = GetWindowTextLength(WindowHandle); <br>        SendMessage(WindowHandle, EM_SETSEL, Index, Index); <br>        SendMessage(WindowHandle, EM_REPLACESEL, 0, (LPARAM)Output); <br> <br>        break; <br> <br>    case FILE_ONLY: <br> <br>        Result = WriteFile(FileHandle, (LPCVOID)Output, strlen(Output), <br>                           &amp;NumWritten, NULL); <br>        if (!Result) { <br> <br>            AbortAndClose(FileHandle, WindowHandle); <br>            return FALSE; <br>        } <br>        break; <br> <br>    case FILE_AND_WINDOW: <br> <br>        Index = GetWindowTextLength(WindowHandle); <br>        SendMessage(WindowHandle, EM_SETSEL, Index, Index); <br>        SendMessage(WindowHandle, EM_REPLACESEL, 0, (LPARAM)Output); <br>        Result = WriteFile(FileHandle, (LPCVOID)Output, strlen(Output), <br>                           &amp;NumWritten, NULL); <br>        if (!Result) { <br> <br>            AbortAndClose(FileHandle, WindowHandle); <br>            return FALSE; <br>        } <br>        break; <br> <br>    case DEBUGGER: <br> <br>        OutputDebugString(Output); <br>    } <br>    return TRUE; <br> <br>} // DTTextOut() <br> <br> <br> <br> <br>  <br>void <br>AbortAndClose( <br>    IN HANDLE FileHandle, <br>    IN HWND WindowHandle) <br>/*++ <br> <br>  AbortAndClose() <br> <br>  Function Description: <br> <br>      Closes a file handle, informs the user via a message box, and <br>      changes the global variable OutputStyle to WINDOW_ONLY <br> <br>  Arguments: <br> <br>      FileHandle -- handle to a file that caused the error. <br> <br>      WindowHandle -- handle to a window to be the parent of the <br>      Message Box. <br> <br>  Return Value: <br> <br>      Void. <br> <br>--*/ <br>{ <br>    CloseHandle(FileHandle); <br>    MessageBox(WindowHandle, ErrStr3, "Error", MB_OK | MB_ICONSTOP); <br>    OutputStyle = WINDOW_ONLY; <br> <br>} // AbortAndClose() <br> <br> <br> <br> <br>  <br>BOOL <br>GetFile( <br>    IN  HWND   OwnerWindow, <br>    OUT LPSTR  FileName, <br>    IN  DWORD  FileNameSize) <br>/*++ <br> <br>  GetFile() <br> <br>  Function Description: <br> <br>      Uses the predefined "Save As" dialog box style to retrieve a <br>      file name from the user.  The file name the user selects is <br>      stored in LogFileName. <br> <br>  Arguments: <br> <br>      OwnerWindow -- window which will own the dialog box. <br> <br>      FileName -- address of a buffer in which to store the string. <br> <br>      FileNameSize -- size of the FileName buffer. <br> <br>  Return Value: <br> <br>      Returns whatever GetSaveFileName returns; see documentation for <br>      that function. <br> <br>--*/ <br>{ <br> <br>    OPENFILENAME OpenFileName;  // common dialog box structure <br>    char DirName[256];          // directory string <br>    char FileTitle[256];        // file-title string <br> <br>    FileName[0] = '\0'; <br> <br>    FillMemory((PVOID)&amp;OpenFileName, sizeof(OPENFILENAME), 0); <br> <br>    // Retrieve the system directory name and store it in DirName. <br>    GetCurrentDirectory(sizeof(DirName), DirName); <br> <br>    // Set the members of the OPENFILENAME structure. <br>    OpenFileName.lStructSize = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner = OwnerWindow; <br>    OpenFileName.lpstrFilter = OpenFileName.lpstrCustomFilter = NULL; <br>    OpenFileName.nFilterIndex = 0; <br>    OpenFileName.lpstrFile = FileName; <br>    OpenFileName.nMaxFile = FileNameSize; <br>    OpenFileName.lpstrFileTitle = FileTitle; <br>    OpenFileName.nMaxFileTitle = sizeof(FileTitle); <br>    OpenFileName.lpstrInitialDir = DirName; <br>    OpenFileName.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT; <br> <br>    // Pop up the dialog box to get the file name. <br>    return GetSaveFileName(&amp;OpenFileName); <br> <br>} // GetFile() </code></pre>
<p>&nbsp;</p></body>
</HTML>
