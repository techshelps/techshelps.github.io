<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EDITCTLS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5185"></a>EDITCTLS.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE: EditCtls.c <br>// <br>//  PURPOSE: Handles the UI Edit controls to get data from user and display <br>//    data recieved from the COMM port. <br>// <br>//  EXPORTED FUNCTIONS:  These functions are for use by other modules. <br>//    InitEditCtls              - Initialize the edit controls. <br>//    SizeEditCtls              - Size and resize the edit controls. <br>//    SetFocusEditCtls          - Set the focus to the correct edit control. <br>//    WriteToDisplayCtl         - Write a string to the Display edit control. <br>//    PostWriteToDisplayCtl     - Posts a message to the UI thread <br>//                                with data to write. <br>// <br>//  INTERNAL FUNCTIONS:  These functions are for this module only. <br>//    SubclassInputEditProc     - Subclass proc to catch the 'enter' keystroke. <br>// <br>// COMMENTS: <br>//   This sample uses exceptionally simple terminal emulation: none. <br>//   There are two edit controls involved.  One for the user to type the <br>//   outgoing strings (called the InputCtl) and another to display both <br>//   transmitted and received strings (called the DisplayCtl).  There is <br>//   absolutely *no* translation of incoming strings, and the only <br>//   modifications to outgoing strings is to append "/r/n" to it. <br>// <br>//   This sample only emulates line mode transmission.  The string is only <br>//   read from the InputCtl when the 'Enter' key is typed. <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "globals.h" <br>#include "EditCtls.h" <br>#include "CommCode.h" <br>#include "toolbar.h" <br>#include "statbar.h" <br> <br>// Maximum size of Edit control buffers <br> <br>#define MAXDISPLAYSIZE 0xF000  // Almost 64K <br>#define MAXINPUTSIZE 0x400      // 1K <br> <br>#define PWM_WRITESTRING WM_USER + 741 // Arbitrary number <br> <br>HWND hWndInputCtl;      // Edit control to get input from user <br>HWND hWndDisplayCtl;    // Edit control to display all output <br>HWND hWndParent;        // Parent window of edit controls <br> <br>WNDPROC lpfnInputEdit;  // Storage for subclassed edit control function <br> <br> <br>// Prototype for the subclassed procedure. <br>LRESULT CALLBACK SubclassInputEditProc( <br>    HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); <br> <br> <br>// <br>//  FUNCTION: InitEditCtls(HWND) <br>// <br>//  PURPOSE: Initialize the UI edit controls. <br>// <br>//  PARAMETERS: <br>//    hWndMain - The window that is to contain the edit controls. <br>// <br>//  RETURN VALUE: <br>//    TRUE if the edit controls are successfully initialized. <br>// <br>//  COMMENTS: <br>//    This function should only need to be called once, when <br>//    creating the main window.  The only reason it could fail <br>//    is if the edit controls couldn't be created. <br>// <br> <br>BOOL InitEditCtls(HWND hWndMain) <br>{ <br>    hWndParent = hWndMain; <br> <br>    if (!hWndMain) <br>    { <br>        OutputDebugString("Invalid parent hWnd for EditCtls!\n"); <br>        return FALSE; <br>    } <br> <br>    hWndDisplayCtl = CreateWindowEx( <br>        WS_EX_CLIENTEDGE, <br>        "EDIT","", <br>        WS_CHILD | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE <br>        | ES_OEMCONVERT | WS_VISIBLE | WS_BORDER, <br>        0, 0, 0, 0, hWndParent, <br>        NULL, hInst, NULL); <br> <br>    hWndInputCtl = CreateWindowEx( <br>        WS_EX_CLIENTEDGE, <br>        "EDIT","", <br>        WS_CHILD | ES_AUTOHSCROLL | WS_VISIBLE | WS_BORDER, <br>        0, 0, 0, 0, hWndParent, <br>        NULL, hInst, NULL); <br> <br>    if (!hWndDisplayCtl || !hWndInputCtl) <br>    { <br>        OutputDebugString("Unable to create EditCtls.\n"); <br>        return FALSE; <br>    } <br> <br>    SendMessage(hWndInputCtl, EM_LIMITTEXT, MAXINPUTSIZE, 0); <br>    SendMessage(hWndDisplayCtl, EM_LIMITTEXT, MAXDISPLAYSIZE, 0); <br> <br>        // This is where we subclass the input edit control <br>        // so we can catch the 'enter' keystroke <br>    lpfnInputEdit = (WNDPROC) <br>        SetWindowLong(hWndInputCtl, GWL_WNDPROC, (long) SubclassInputEditProc); <br> <br>    return TRUE; <br>} <br> <br> <br>// <br>//  FUNCTION: SizeEditCtls <br>// <br>//  PURPOSE: Sizes, resizes and positions the edit controls. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    Anytime the parent window is resized, it needs to signal <br>//    the edit controls to also resize.  The size of the edit <br>//    controls assumes that the edit controls are going to  <br>//    contain the full client area of the parent, allowing for <br>//    the toolbar and statusbar. <br>// <br> <br>void SizeEditCtls() <br>{ <br>    RECT rectParent, rectTemp; <br>    LONG HeightToolbar, HeightStatusbar; <br>    LONG HeightDisplayCtl, HeightInputCtl; <br>    LONG WidthCtls; <br>    LONG yposTopInputCtl, yposTopDisplayCtl; <br>    HDC hdc; <br>    TEXTMETRIC tm; <br> <br>    // Get the client area of the parent. <br>    if (!GetClientRect(hWndParent, &amp;rectParent)) <br>    { <br>        OutputDebugString("GetClientRect on EditCtls parent failed\n"); <br>        return; <br>    } <br> <br>    // leave a pixel on each side <br>    WidthCtls = rectParent.right - 2; <br>     <br>    // Allow for the toolbar at the top. <br>    GetWindowRect(hWndToolbar, &amp;rectTemp); <br>    HeightToolbar = rectTemp.bottom - rectTemp.top; <br> <br>    // Allow for the statusbar at the bottom. <br>    GetWindowRect(hWndStatusbar, &amp;rectTemp); <br>    HeightStatusbar = rectTemp.bottom - rectTemp.top; <br> <br>    // How high should the input control be? <br>    hdc = GetDC(hWndInputCtl); <br>    GetTextMetrics(hdc, &amp;tm); <br>    ReleaseDC(hWndInputCtl, hdc); <br>    HeightInputCtl = tm.tmHeight + tm.tmExternalLeading + 6; <br>        // 6 == 3 extra pixels between text and edit control vertical borders. <br> <br>    // Position Input control. <br>    yposTopInputCtl = rectParent.bottom - HeightStatusbar - HeightInputCtl - 1; <br> <br>    // Position Display control. <br>    yposTopDisplayCtl = rectParent.top + HeightToolbar + 2; <br>    HeightDisplayCtl = yposTopInputCtl - yposTopDisplayCtl - 1; <br> <br>    // Move them both. <br>    MoveWindow( <br>        hWndInputCtl, <br>        1, yposTopInputCtl, <br>        WidthCtls, HeightInputCtl, <br>        TRUE); <br> <br>    MoveWindow( <br>        hWndDisplayCtl, <br>        1, yposTopDisplayCtl, <br>        WidthCtls, HeightDisplayCtl, <br>        TRUE); <br>} <br> <br> <br>// <br>//  FUNCTION: SetFocusEditCtls <br>// <br>//  PURPOSE: Sets the focus to the correct edit control. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    Everytime the parent window gets focus, it needs to signal <br>//    the edit controls to set focus also.  This very simple <br>//    algorythm always sets focus to the Input control. <br>// <br> <br>void SetFocusEditCtls() <br>{ <br>    DefWindowProc(hWndParent, WM_SETFOCUS, (WPARAM) NULL, (LPARAM) NULL); <br> <br>    if (GetFocus() == hWndParent) <br>        SetFocus(hWndInputCtl); <br> <br>    return; <br>} <br> <br> <br>// <br>//  FUNCTION: SubclassInputEditProc <br>// <br>//  PURPOSE: Subclass proceedure of Input control. <br>// <br>//  PARAMETERS: <br>//    Standard WNDPROC parameters. <br>// <br>//  RETURN VALUE: <br>//    Standard WNDPROC return value. <br>// <br>//  COMMENTS: <br>//    We subclass the Input edit control so that we can catch the 'Enter' <br>//    keystroke (VK_RETURN).  This is how we know when the user wants to <br>//    transmit something to the COMM port.  This indeed means that only <br>//    line based terminal emulation is supported by this sample.  However, <br>//    it makes editing the outgoing text much easier. <br>// <br>//    WriteCommString is the call that writes a string to the COMM port. <br>//    However, the string that is written *must* be allocated with <br>//    LocalAlloc, and if WriteCommString succeeds, then it will also <br>//    LocalFree the string.  If WriteCommString fails, then it refused <br>//    the string and its our job to free it. <br>// <br> <br>LRESULT CALLBACK SubclassInputEditProc( <br>    HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(message) <br>    { <br>        case WM_CHAR: <br> <br>            // Found a RETURN keystroke! <br>            if ((TCHAR) wParam == VK_RETURN) <br>            { <br>                 <br>                LPSTR pszString; <br>                long lSizeofString; <br> <br>                // Get the size of the string to send. <br>                lSizeofString =  <br>                    SendMessage(hWndInputCtl, WM_GETTEXTLENGTH, 0, 0); <br> <br>                // Allocate enough space for the string and "\r\0" <br>                pszString = (LPSTR) LocalAlloc(LPTR, lSizeofString +2); <br> <br>                // Get the string <br>                SendMessage(hWndInputCtl, WM_GETTEXT, <br>                    lSizeofString + 1, (LPARAM) pszString); <br> <br>                // Terminate it. <br>                strcat(pszString, "\r"); <br>                lSizeofString += 1; <br> <br>                // If the write to Comm failed, its probably because <br>                // a connection isn't made yet. <br>                if (WriteCommString(pszString, lSizeofString)) <br>                { <br>                    // This is what we'd do to local echo user input <br>                    // Unnecessary usually. <br>                    //WriteToOutputEdit(pszString, lSizeofString); <br>                    ; <br>                } <br>                else <br>                { <br>                    WriteToDisplayCtl("Not yet connected\r", 20); <br> <br>                    // The comm code refused the string, so we must free it. <br>                    LocalFree(pszString); <br>                } <br> <br>                // Clear the Input control. <br>                SendMessage(hWndInputCtl, WM_SETTEXT, 0, (LPARAM) ""); <br> <br>                // Don't let default processing handle the RETURN key. <br>                return 0; <br>            } <br> <br>            break; <br> <br>        case PWM_WRITESTRING: <br>            WriteToDisplayCtl((LPSTR) lParam, (DWORD) wParam); <br>            LocalFree((LPSTR) lParam); <br>            break; <br> <br>        default: <br>            break; <br>    } <br>    return CallWindowProc(lpfnInputEdit, hWnd, message, wParam, lParam); <br>} <br> <br> <br>// <br>//  FUNCTION: WriteToDisplayCtl(LPSTR, DWORD) <br>// <br>//  PURPOSE: Writes a string to the Display control. <br>// <br>//  PARAMETERS: <br>//    lpNewString       - The string to display. <br>//    dwSizeofNewString - The length of the string. <br>// <br>//  RETURN VALUE: <br>//    none. <br>// <br>//  COMMENTS: <br>// <br> <br>void WriteToDisplayCtl(LPSTR lpNewString, DWORD dwSizeofNewString) <br>{ <br>    DWORD dwSizeofEdit; <br> <br>    dwSizeofEdit = SendMessage(hWndDisplayCtl, WM_GETTEXTLENGTH, 0, 0); <br> <br>    if ((dwSizeofEdit + dwSizeofNewString) &gt; MAXDISPLAYSIZE) <br>    { <br>        // Suggestion for future additions: <br>        // Handle edit control overflow by deleting from top of edit control <br>    } <br> <br>    // Actually place the string into the Display control. <br>    SendMessage(hWndDisplayCtl, EM_SETSEL, dwSizeofEdit, dwSizeofEdit); <br>    SendMessage(hWndDisplayCtl, EM_REPLACESEL, 0, (LPARAM) lpNewString); <br>    SendMessage(hWndDisplayCtl, EM_SETSEL,  <br>        dwSizeofEdit+dwSizeofNewString, dwSizeofEdit+dwSizeofNewString); <br>} <br> <br> <br>// <br>//  FUNCTION: PostWriteToDisplayCtl(LPSTR, DWORD) <br>// <br>//  PURPOSE: Writes a string to the Display control. <br>// <br>//  PARAMETERS: <br>//    lpNewString       - The string to display. <br>//    dwSizeofNewString - The length of the string. <br>// <br>//  RETURN VALUE: <br>//    none. <br>// <br>//  COMMENTS: <br>// <br>//    Its very important that when data is recieved from the comm port, <br>//    the thread reading the comm port doesn't have to wait for the <br>//    data to be interpreted.  Instead, it posts the data to the main UI <br>//    thread to be handled when it is convenient.  This is the API to <br>//    wrap up the PostMessage. <br>// <br>//    Note that the string posted must be LocalAlloc()d, and its the job <br>//    of the window recieving the message to LocalFree it. <br>// <br> <br>BOOL PostWriteToDisplayCtl(LPSTR lpNewString, DWORD dwSizeofNewString) <br>{ <br>    return PostMessage(hWndInputCtl, PWM_WRITESTRING,  <br>        (WPARAM)dwSizeofNewString, (LPARAM) lpNewString); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
