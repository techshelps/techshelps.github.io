<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TAPIINFO.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5197"></a>TAPIINFO.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE: TapiInfo.c <br>// <br>//  PURPOSE: Handles all Pretty Printing functions for the TapiComm sample.  <br>// <br>//  EXPORTED FUNCTIONS:  These functions are for use by other modules. <br>// <br>//      All of these pretty print to the debugging output. <br>//    OutputDebugLineCallback       - Calls FormatLineCallback. <br>//    OutputDebugLineError          - Calls OutputDebugLineErrorFileLine. <br>//    OutputDebugLastError          - Calls OutputDebugLineErrorFileLine. <br>//    OutputDebugPrintf             - Calls wsprintf <br>//    OutputDebugLineErrorFileLine  - Calls FormatLineError <br>//    OutputDebugLastErrorFileLine  - Calls FormatLastError <br>// <br>//      All of these functions pretty print to a string buffer. <br>//    FormatLineError               - Prints a LINEERR <br>//    FormatLastError               - Prints a GetLastError error. <br>//    FormatLineCallback            - Prints a lineCallbackFunc message. <br>// <br>//  INTERNAL FUNCTION:  These functions are for this module only. <br>//    strBinaryArrayAppend          - prints a binary flag array to a buffer. <br> <br>#include &lt;windows.h&gt; <br>#include &lt;tapi.h&gt; <br>#include "TapiInfo.h" <br> <br>// Maximum length of all internal string buffers. <br>#define MAXOUTPUTSTRINGLENGTH 4096 <br> <br>// define to make accessing arrays easy. <br>#define sizeofArray(pArray) (sizeof(pArray) / sizeof((pArray)[0])) <br> <br> <br>//***************************************** <br>// Internal prototypes. <br>//***************************************** <br> <br>static long strBinaryArrayAppend(LPSTR pszOutputBuffer, DWORD dwFlags, <br>     LPSTR szStringArray[], DWORD dwSizeofStringArray); <br> <br> <br> <br>//***************************************** <br>// Global arrays for interpreting TAPI constants. <br>//***************************************** <br> <br>LPSTR pszLineErrorNameArray[] =  <br>{ <br>"", <br>"LINEERR_ALLOCATED", <br>"LINEERR_BADDEVICEID", <br>"LINEERR_BEARERMODEUNAVAIL", <br>"LINEERR Unused constant, ERROR!!", <br>"LINEERR_CALLUNAVAIL", <br>"LINEERR_COMPLETIONOVERRUN", <br>"LINEERR_CONFERENCEFULL", <br>"LINEERR_DIALBILLING", <br>"LINEERR_DIALDIALTONE", <br>"LINEERR_DIALPROMPT", <br>"LINEERR_DIALQUIET", <br>"LINEERR_INCOMPATIBLEAPIVERSION", <br>"LINEERR_INCOMPATIBLEEXTVERSION", <br>"LINEERR_INIFILECORRUPT", <br>"LINEERR_INUSE", <br>"LINEERR_INVALADDRESS", <br>"LINEERR_INVALADDRESSID", <br>"LINEERR_INVALADDRESSMODE", <br>"LINEERR_INVALADDRESSSTATE", <br>"LINEERR_INVALAPPHANDLE", <br>"LINEERR_INVALAPPNAME", <br>"LINEERR_INVALBEARERMODE", <br>"LINEERR_INVALCALLCOMPLMODE", <br>"LINEERR_INVALCALLHANDLE", <br>"LINEERR_INVALCALLPARAMS", <br>"LINEERR_INVALCALLPRIVILEGE", <br>"LINEERR_INVALCALLSELECT", <br>"LINEERR_INVALCALLSTATE", <br>"LINEERR_INVALCALLSTATELIST", <br>"LINEERR_INVALCARD", <br>"LINEERR_INVALCOMPLETIONID", <br>"LINEERR_INVALCONFCALLHANDLE", <br>"LINEERR_INVALCONSULTCALLHANDLE", <br>"LINEERR_INVALCOUNTRYCODE", <br>"LINEERR_INVALDEVICECLASS", <br>"LINEERR_INVALDEVICEHANDLE", <br>"LINEERR_INVALDIALPARAMS", <br>"LINEERR_INVALDIGITLIST", <br>"LINEERR_INVALDIGITMODE", <br>"LINEERR_INVALDIGITS", <br>"LINEERR_INVALEXTVERSION", <br>"LINEERR_INVALGROUPID", <br>"LINEERR_INVALLINEHANDLE", <br>"LINEERR_INVALLINESTATE", <br>"LINEERR_INVALLOCATION", <br>"LINEERR_INVALMEDIALIST", <br>"LINEERR_INVALMEDIAMODE", <br>"LINEERR_INVALMESSAGEID", <br>"LINEERR Unused constant, ERROR!!", <br>"LINEERR_INVALPARAM", <br>"LINEERR_INVALPARKID", <br>"LINEERR_INVALPARKMODE", <br>"LINEERR_INVALPOINTER", <br>"LINEERR_INVALPRIVSELECT", <br>"LINEERR_INVALRATE", <br>"LINEERR_INVALREQUESTMODE", <br>"LINEERR_INVALTERMINALID", <br>"LINEERR_INVALTERMINALMODE", <br>"LINEERR_INVALTIMEOUT", <br>"LINEERR_INVALTONE", <br>"LINEERR_INVALTONELIST", <br>"LINEERR_INVALTONEMODE", <br>"LINEERR_INVALTRANSFERMODE", <br>"LINEERR_LINEMAPPERFAILED", <br>"LINEERR_NOCONFERENCE", <br>"LINEERR_NODEVICE", <br>"LINEERR_NODRIVER", <br>"LINEERR_NOMEM", <br>"LINEERR_NOREQUEST", <br>"LINEERR_NOTOWNER", <br>"LINEERR_NOTREGISTERED", <br>"LINEERR_OPERATIONFAILED", <br>"LINEERR_OPERATIONUNAVAIL", <br>"LINEERR_RATEUNAVAIL", <br>"LINEERR_RESOURCEUNAVAIL", <br>"LINEERR_REQUESTOVERRUN", <br>"LINEERR_STRUCTURETOOSMALL", <br>"LINEERR_TARGETNOTFOUND", <br>"LINEERR_TARGETSELF", <br>"LINEERR_UNINITIALIZED", <br>"LINEERR_USERUSERINFOTOOBIG", <br>"LINEERR_REINIT", <br>"LINEERR_ADDRESSBLOCKED", <br>"LINEERR_BILLINGREJECTED", <br>"LINEERR_INVALFEATURE", <br>"LINEERR_NOMULTIPLEINSTANCE" <br>}; <br> <br> <br>LPSTR psz_dwMsg[] = { <br>    "LINE_ADDRESSSTATE", <br>    "LINE_CALLINFO", <br>    "LINE_CALLSTATE", <br>    "LINE_CLOSE", <br>    "LINE_DEVSPECIFIC", <br>    "LINE_DEVSPECIFICFEATURE", <br>    "LINE_GATHERDIGITS", <br>    "LINE_GENERATE", <br>    "LINE_LINEDEVSTATE", <br>    "LINE_MONITORDIGITS", <br>    "LINE_MONITORMEDIA", <br>    "LINE_MONITORTONE", <br>    "LINE_REPLY", <br>    "LINE_REQUEST", <br>    "PHONE_BUTTON", <br>    "PHONE_CLOSE", <br>    "PHONE_DEVSPECIFIC", <br>    "PHONE_REPLY", <br>    "PHONE_STATE", <br>    "LINE_CREATE", <br>    "PHONE_CREATE" <br>}; <br> <br> <br>LPSTR pszfLINEADDRESSSTATE[] =  <br>{ <br>    "Unknown LINEADDRESSSTATE information", <br>    "LINEADDRESSSTATE_OTHER", <br>    "LINEADDRESSSTATE_DEVSPECIFIC", <br>    "LINEADDRESSSTATE_INUSEZERO", <br>    "LINEADDRESSSTATE_INUSEONE", <br>    "LINEADDRESSSTATE_INUSEMANY", <br>    "LINEADDRESSSTATE_NUMCALLS", <br>    "LINEADDRESSSTATE_FORWARD", <br>    "LINEADDRESSSTATE_TERMINALS", <br>    "LINEADDRESSSTATE_CAPSCHANGE" <br>}; <br> <br> <br>LPSTR pszfLINECALLINFOSTATE[] =  <br>{ <br>    "Unknown LINECALLINFOSTATE state", <br>    "LINECALLINFOSTATE_OTHER", <br>    "LINECALLINFOSTATE_DEVSPECIFIC", <br>    "LINECALLINFOSTATE_BEARERMODE", <br>    "LINECALLINFOSTATE_RATE", <br>    "LINECALLINFOSTATE_MEDIAMODE", <br>    "LINECALLINFOSTATE_APPSPECIFIC", <br>    "LINECALLINFOSTATE_CALLID", <br>    "LINECALLINFOSTATE_RELATEDCALLID", <br>    "LINECALLINFOSTATE_ORIGIN", <br>    "LINECALLINFOSTATE_REASON", <br>    "LINECALLINFOSTATE_COMPLETIONID", <br>    "LINECALLINFOSTATE_NUMOWNERINCR", <br>    "LINECALLINFOSTATE_NUMOWNERDECR", <br>    "LINECALLINFOSTATE_NUMMONITORS", <br>    "LINECALLINFOSTATE_TRUNK", <br>    "LINECALLINFOSTATE_CALLERID", <br>    "LINECALLINFOSTATE_CALLEDID", <br>    "LINECALLINFOSTATE_CONNECTEDID", <br>    "LINECALLINFOSTATE_REDIRECTIONID", <br>    "LINECALLINFOSTATE_REDIRECTINGID", <br>    "LINECALLINFOSTATE_DISPLAY", <br>    "LINECALLINFOSTATE_USERUSERINFO", <br>    "LINECALLINFOSTATE_HIGHLEVELCOMP", <br>    "LINECALLINFOSTATE_LOWLEVELCOMP", <br>    "LINECALLINFOSTATE_CHARGINGINFO", <br>    "LINECALLINFOSTATE_TERMINAL", <br>    "LINECALLINFOSTATE_DIALPARAMS", <br>    "LINECALLINFOSTATE_MONITORMODES" <br>}; <br> <br> <br>LPSTR pszfLINECALLSTATE[] =  <br>{ <br>    "Unknown LINECALLSTATE state", <br>    "LINECALLSTATE_IDLE", <br>    "LINECALLSTATE_OFFERING", <br>    "LINECALLSTATE_ACCEPTED", <br>    "LINECALLSTATE_DIALTONE", <br>    "LINECALLSTATE_DIALING", <br>    "LINECALLSTATE_RINGBACK", <br>    "LINECALLSTATE_BUSY", <br>    "LINECALLSTATE_SPECIALINFO", <br>    "LINECALLSTATE_CONNECTED", <br>    "LINECALLSTATE_PROCEEDING", <br>    "LINECALLSTATE_ONHOLD", <br>    "LINECALLSTATE_CONFERENCED", <br>    "LINECALLSTATE_ONHOLDPENDCONF", <br>    "LINECALLSTATE_ONHOLDPENDTRANSFER", <br>    "LINECALLSTATE_DISCONNECTED", <br>    "LINECALLSTATE_UNKNOWN" <br>}; <br> <br> <br>LPSTR pszfLINEDIALTONEMODE[] = <br>{ <br>    "Unknown LINEDIALTONE information", <br>    "LINEDIALTONEMODE_NORMAL", <br>    "LINEDIALTONEMODE_SPECIAL", <br>    "LINEDIALTONEMODE_INTERNAL", <br>    "LINEDIALTONEMODE_EXTERNAL", <br>    "LINEDIALTONEMODE_UNKNOWN", <br>    "LINEDIALTONEMODE_UNAVAIL" <br>}; <br> <br> <br>LPSTR pszfLINEBUSYMODE[] = <br>{ <br>    "Unknown LINEBUSYMODE information", <br>    "LINEBUSYMODE_STATION", <br>    "LINEBUSYMODE_TRUNK", <br>    "LINEBUSYMODE_UNKNOWN", <br>    "LINEBUSYMODE_UNAVAIL" <br>}; <br> <br> <br>LPSTR pszfLINESPECIALINFO[] = <br>{ <br>    "Unknown LINESPECIALINFO information", <br>    "LINESPECIALINFO_NOCIRCUIT", <br>    "LINESPECIALINFO_CUSTIRREG", <br>    "LINESPECIALINFO_REORDER", <br>    "LINESPECIALINFO_UNKNOWN", <br>    "LINESPECIALINFO_UNAVAIL" <br>}; <br> <br> <br>LPSTR pszfLINEDISCONNECTED[] = <br>{ <br>    "Unknown LINEDISCONNECTED information", <br>    "LINEDISCONNECTMODE_NORMAL", <br>    "LINEDISCONNECTMODE_UNKNOWN", <br>    "LINEDISCONNECTMODE_REJECT", <br>    "LINEDISCONNECTMODE_PICKUP", <br>    "LINEDISCONNECTMODE_FORWARDED", <br>    "LINEDISCONNECTMODE_BUSY", <br>    "LINEDISCONNECTMODE_NOANSWER", <br>    "LINEDISCONNECTMODE_BADADDRESS", <br>    "LINEDISCONNECTMODE_UNREACHABLE", <br>    "LINEDISCONNECTMODE_CONGESTION", <br>    "LINEDISCONNECTMODE_INCOMPATIBLE", <br>    "LINEDISCONNECTMODE_UNAVAIL", <br>    "LINEDISCONNECTMODE_NODIALTONE" <br>}; <br> <br> <br>LPSTR pszfLINECALLPRIVILEGE[] = <br>{ <br>    "No change to LINECALLPRIVILEGE", <br>    "LINECALLPRIVILEGE_NONE", <br>    "LINECALLPRIVILEGE_MONITOR", <br>    "LINECALLPRIVILEGE_OWNER" <br>}; <br> <br> <br>LPSTR pszfLINEGATHERTERM[] = <br>{ <br>    "Unknown LINEGATHERTERM message", <br>    "LINEGATHERTERM_BUFFERFULL", <br>    "LINEGATHERTERM_TERMDIGIT", <br>    "LINEGATHERTERM_FIRSTTIMEOUT", <br>    "LINEGATHERTERM_INTERTIMEOUT", <br>    "LINEGATHERTERM_CANCEL" <br>}; <br> <br> <br>LPSTR pszfLINEGENERATETERM[] =  <br>{ <br>    "Unknown LINEGENERATETERM message", <br>    "LINEGENERATETERM_DONE", <br>    "LINEGENERATETERM_CANCEL" <br>}; <br> <br> <br>LPSTR pszfLINEDEVSTATE[] = <br>{     <br>    "Unknown LINEDEVESTATE state", <br>    "LINEDEVSTATE_OTHER", <br>    "LINEDEVSTATE_RINGING", <br>    "LINEDEVSTATE_CONNECTED", <br>    "LINEDEVSTATE_DISCONNECTED", <br>    "LINEDEVSTATE_MSGWAITON", <br>    "LINEDEVSTATE_MSGWAITOFF", <br>    "LINEDEVSTATE_INSERVICE", <br>    "LINEDEVSTATE_OUTOFSERVICE", <br>    "LINEDEVSTATE_MAINTENANCE", <br>    "LINEDEVSTATE_OPEN", <br>    "LINEDEVSTATE_CLOSE", <br>    "LINEDEVSTATE_NUMCALLS", <br>    "LINEDEVSTATE_NUMCOMPLETIONS", <br>    "LINEDEVSTATE_TERMINALS", <br>    "LINEDEVSTATE_ROAMMODE", <br>    "LINEDEVSTATE_BATTERY", <br>    "LINEDEVSTATE_SIGNAL", <br>    "LINEDEVSTATE_DEVSPECIFIC", <br>    "LINEDEVSTATE_REINIT", <br>    "LINEDEVSTATE_LOCK", <br>    "LINEDEVSTATE_CAPSCHANGE", <br>    "LINEDEVSTATE_CONFIGCHANGE", <br>    "LINEDEVSTATE_TRANSLATECHANGE", <br>    "LINEDEVSTATE_COMPLCANCEL", <br>    "LINEDEVSTATE_REMOVED" <br>}; <br> <br> <br>LPSTR pszfLINEDIGITMODE[] = <br>{ <br>    "Unknown LINEDIGITMODE mode", <br>    "LINEDIGITMODE_PULSE", <br>    "LINEDIGITMODE_DTMF", <br>    "LINEDIGITMODE_DTMFEND" <br>}; <br>     <br> <br>LPSTR pszfLINEMEDIAMODE[] = <br>{ <br>    "Unknown LINEMEDIAMODE mode", <br>    "UnUsed LINEMEDIAMODE mode, ERROR!!", <br>    "LINEMEDIAMODE_UNKNOWN", <br>    "LINEMEDIAMODE_INTERACTIVEVOICE", <br>    "LINEMEDIAMODE_AUTOMATEDVOICE", <br>    "LINEMEDIAMODE_DATAMODEM", <br>    "LINEMEDIAMODE_G3FAX", <br>    "LINEMEDIAMODE_TDD", <br>    "LINEMEDIAMODE_G4FAX", <br>    "LINEMEDIAMODE_DIGITALDATA", <br>    "LINEMEDIAMODE_TELETEX", <br>    "LINEMEDIAMODE_VIDEOTEX", <br>    "LINEMEDIAMODE_TELEX", <br>    "LINEMEDIAMODE_MIXED", <br>    "LINEMEDIAMODE_ADSI", <br>    "LINEMEDIAMODE_VOICEVIEW" <br>}; <br> <br> <br>LPSTR pszfLINEREQUESTMODE[] = <br>{ <br>    "Unknown LINEREQUESTMODE message", <br>    "LINEREQUESTMODE_MAKECALL", <br>    "LINEREQUESTMODE_MEDIACALL", <br>    "LINEREQUESTMODE_DROP" <br>}; <br> <br> <br>// <br>//  MACRO: OutputDebugLineError(long, LPSTR) <br>// <br>//  PURPOSE: Pretty print a line error to the debugging output. <br>// <br>//  PARAMETERS: <br>//    lLineError - Actual error code to decipher. <br>//    pszPrefix  - String to prepend to the printed message. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    This macro is actually defined in the .h file. <br>//    It will take a LINEERR error, turn it into a human <br>//    readable string, prepend pszPrefix (so you <br>//    can tag your errors), append __FILE__ and __LINE__ <br>//    and print it to the debugging output. <br> <br>//    This macro is just a wrapper around OutputDebugLineErrorFileLine <br>//    that is necessary to get proper values for __FILE__ and __LINE__. <br>// <br>// <br> <br> <br>/* <br>#define OuputDebugLineError(lLineError, pszPrefix) \ <br>    OutputDebugLineErrorFileLine(lLineError, pszPrefix,\ <br>        __FILE__, __LINE__) <br>*/ <br> <br>// <br>//  FUNCTION: OutputDebugLineErrorFileLine(..) <br>// <br>//  PURPOSE: Pretty print a line error to the debugging output. <br>// <br>//  PARAMETERS: <br>//    lLineError  - Actual error code to decipher. <br>//    pszPrefix   - String to prepend to the printed message. <br>//    szFileName  - Filename the error occured in. <br>//    nLineNumber - Line number the error occured at. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    This is the actual function that OutputDebugLineError <br>//    expands to.  Its not likely to be usefull except <br>//    through the OutputDebugLineError macro, or to print <br>//    errors without line and file information. <br>// <br>//    If szFileName == NULL, then the File and Line are not printed. <br>//    <br>//    Note that there is an internal string length limit of <br>//    MAXOUTPUTSTRINGLENGTH.  If this length is exceeded, <br>//    the behavior will be the same as wsprintf, although <br>//    it will be undetectable.  *KEEP szPrefix SHORT!* <br>// <br>// <br> <br>void OutputDebugLineErrorFileLine( <br>    long lLineError, LPSTR szPrefix,  <br>    LPSTR szFileName, DWORD nLineNumber) <br>{ <br>    LPSTR szLineError; <br>    char szOutputLineError[MAXOUTPUTSTRINGLENGTH]; <br> <br>    if (szPrefix == NULL) <br>        szPrefix = ""; <br> <br>    // Pretty print the error message. <br>    szLineError = FormatLineError(lLineError, NULL, 0); <br> <br>    // The only reason FormatLineError should fail is "Out of memory". <br>    if (szLineError == NULL) <br>    { <br>        if (szFileName == NULL) <br>            wsprintf(szOutputLineError, "%sOut of memory", szPrefix); <br>        else <br>            wsprintf(szOutputLineError,  <br>                "%sOut of memory in file %s, line %d\r\n", <br>                szPrefix, szFileName, nLineNumber); <br> <br>        OutputDebugString(szOutputLineError); <br> <br>        return; <br>    } <br> <br>    // If szFileName, then use it; else don't. <br>    if (szFileName != NULL) <br>    { <br>        wsprintf(szOutputLineError, <br>            "%sTapi Line Error: \"%s\" in File \"%s\", Line %d\r\n", <br>            szPrefix, szLineError, szFileName, nLineNumber); <br>    } <br>    else <br>    { <br>        wsprintf(szOutputLineError, <br>            "%sTapi Line Error: \"%s\"\r\n", <br>            szPrefix, szLineError); <br>    } <br> <br>    // Pointer returned from FormatLineError *must* be freed! <br>    LocalFree(szLineError); <br> <br>    // Print it! <br>    OutputDebugString(szOutputLineError); <br> <br>    return; <br>} <br> <br> <br>// <br>//  FUNCTION: FormatLineError(long, LPSTR, DWORD) <br>// <br>//  PURPOSE: Pretty print a line error to a string. <br>// <br>//  PARAMETERS: <br>//    lLineError           - Actual error code to decipher. <br>//    szOutputBuffer       - String buffer to pretty print to. <br>//    dwSizeofOutputBuffer - Size of String buffer. <br>// <br>//  RETURN VALUE: <br>//    Returns the buffer printed to. <br>// <br>//  COMMENTS: <br>//    If szOutputBuffer isn't big enough to hold the whole string, <br>//    then the string gets truncated to fit the buffer. <br>// <br>//    If szOutputBuffer == NULL, then dwSizeofOutputBuffer <br>//    is ignored, a buffer 'big enough' is LocalAlloc()d and <br>//    a pointer to it is returned.  However, its *very* important <br>//    that this pointer be LocalFree()d by the calling application. <br>// <br>// <br> <br>LPSTR FormatLineError(long lLineError, <br>    LPSTR szOutputBuffer, DWORD dwSizeofOutputBuffer) <br>{ <br>    char szUnknownLineError[256]; <br>    LPSTR szLineError; <br>    int nSizeofLineError; <br>    long lErrorIndex; <br>    DWORD * pdwLineError; <br> <br>    // Strip off the high bit to make the error code positive. <br>    pdwLineError = &amp;lLineError; <br>    lErrorIndex = (long) (0x7FFFFFFF &amp; *pdwLineError); <br> <br>    // Is it an unknown error? <br>    if ((lErrorIndex &gt;= sizeofArray(pszLineErrorNameArray)) || <br>        (lErrorIndex &lt; 0)) <br>    { <br>        nSizeofLineError =  <br>            wsprintf(szUnknownLineError, "Unknown TAPI line error code: 0x%lx", <br>                lLineError); <br>        szLineError = szUnknownLineError; <br>    } <br>    else <br>    { <br>        szLineError = pszLineErrorNameArray[lErrorIndex]; <br>        nSizeofLineError = strlen(szLineError); <br>    } <br> <br>    // allocate a buffer if necessary <br>    if (szOutputBuffer == NULL) <br>    { <br>        szOutputBuffer = (LPSTR) LocalAlloc(LPTR, nSizeofLineError + 1); <br>        if (szOutputBuffer == NULL) <br>            return NULL; <br>    } <br>    else // truncate string if it won't fit in the specified buffer. <br>    { <br>        if ((DWORD) nSizeofLineError &gt;= dwSizeofOutputBuffer) <br>            nSizeofLineError = dwSizeofOutputBuffer - 1; <br>    } <br> <br>    // Put the string into the buffer and null terminate. <br>    memcpy(szOutputBuffer, szLineError, nSizeofLineError); <br>    szOutputBuffer[nSizeofLineError] = '\0'; <br> <br>    return szOutputBuffer; <br>} <br> <br> <br>// <br>//  MACRO: OutputDebugLastError(DWORD, LPSTR) <br>// <br>//  PURPOSE: Pretty print a system error to the debugging output. <br>// <br>//  PARAMETERS: <br>//    dwLastError - Actual error code to decipher. <br>//    pszPrefix   - String to prepend to the printed message. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    This macro is actually defined in the .h file. <br>//    It will take an error that was retrieved by GetLastError(), <br>//    turn it into a human readable string, prepend pszPrefix <br>//    (so you can tag your errors), append __FILE__ and __LINE__ <br>//    and print it to the debugging output. <br>// <br>//    This macro is just a wrapper around OutputDebugLastErrorFileLine <br>//    that is necessary to get proper values for __FILE__ and __LINE__. <br>// <br>// <br> <br>/* <br>#define OuputDebugLastError(dwLastError, pszPrefix) \ <br>    OutputDebugLastErrorFileLine(dwLastError, pszPrefix,\ <br>        __FILE__, __LINE__) <br>*/ <br> <br> <br>// <br>//  FUNCTION: OutputDebugLastErrorFileLine(..) <br>// <br>//  PURPOSE: Pretty print a line error to the debugging output. <br>// <br>//  PARAMETERS: <br>//    dwLastError - Actual error code to decipher. <br>//    pszPrefix   - String to prepend to the printed message. <br>//    szFileName  - Filename the error occured in. <br>//    nLineNumber - Line number the error occured at. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    This is the actual function that OutputDebugLastError <br>//    expands to.  Its not likely to be usefull except <br>//    through the OutputDebugLastError macro or to print <br>//    errors without line and file information. <br>// <br>//    If szFileName == NULL, then the File and Line are not printed. <br>//    <br>//    Note that there is an internal string length limit of <br>//    MAXOUTPUTSTRINGLENGTH.  If this length is exceeded, <br>//    the behavior will be the same as wsprintf, although <br>//    it will be undetectable.  *KEEP szPrefix SHORT!* <br>// <br>// <br> <br>void OutputDebugLastErrorFileLine( <br>    DWORD dwLastError, LPSTR szPrefix,  <br>    LPSTR szFileName, DWORD nLineNumber) <br>{ <br>    LPSTR szLastError; <br>    char szOutputLastError[MAXOUTPUTSTRINGLENGTH]; <br> <br>    if (szPrefix == NULL) <br>        szPrefix = ""; <br> <br>    // Pretty print the error. <br>    szLastError = FormatLastError(dwLastError, NULL, 0); <br> <br>    // The only reason FormatLastError should fail is "Out of memory". <br>    if (szLastError == NULL) <br>    { <br>        if (szFileName == NULL) <br>            wsprintf(szOutputLastError, "%sOut of memory\r\n", szPrefix); <br>        else <br>            wsprintf(szOutputLastError, "%sOut of memory in file %s, line %d\r\n", <br>                szPrefix, szFileName, nLineNumber); <br> <br>        OutputDebugString(szOutputLastError); <br> <br>        return; <br>    } <br> <br>    // If szFileName, then use it; else don't. <br>    if (szFileName != NULL) <br>    { <br>        wsprintf(szOutputLastError, <br>            "%sGetLastError returned: \"%s\" in File \"%s\", Line %d\r\n", <br>            szPrefix, szLastError, szFileName, nLineNumber); <br>    } <br>    else <br>    { <br>        wsprintf(szOutputLastError, <br>            "%sGetLastError returned: \"%s\"\r\n", <br>            szPrefix, szLastError); <br>    } <br> <br>    // Pointer returned from FormatLineError *must* be freed! <br>    LocalFree(szLastError); <br> <br>    // Print it! <br>    OutputDebugString(szOutputLastError); <br>    return; <br>} <br> <br> <br>// <br>//  FUNCTION: FormatLastError(DWORD, LPSTR, DWORD) <br>// <br>//  PURPOSE: Pretty print a system error to a string. <br>// <br>//  PARAMETERS: <br>//    dwLastError          - Actual error code to decipher. <br>//    szOutputBuffer       - String buffer to pretty print to. <br>//    dwSizeofOutputBuffer - Size of String buffer. <br>// <br>//  RETURN VALUE: <br>//    Returns the buffer printed to. <br>// <br>//  COMMENTS: <br>//    If szOutputBuffer isn't big enough to hold the whole string, <br>//    then the string gets truncated to fit the buffer. <br>// <br>//    If szOutputBuffer == NULL, then dwSizeofOutputBuffer <br>//    is ignored, a buffer 'big enough' is LocalAlloc()d and <br>//    a pointer to it is returned.  However, its *very* important <br>//    that this pointer be LocalFree()d by the calling application. <br>// <br>// <br> <br>LPSTR FormatLastError(DWORD dwLastError, <br>    LPSTR szOutputBuffer, DWORD dwSizeofOutputBuffer) <br>{ <br>    DWORD dwRetFM; <br>    DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM; <br> <br>    // Should we allocate a buffer? <br>    if (szOutputBuffer == NULL) <br>    { <br>        // Actually, we make FormatMessage allocate the buffer, if needed. <br>        dwFlags |= FORMAT_MESSAGE_ALLOCATE_BUFFER; <br> <br>        // minimum size FormatMessage should allocate. <br>        dwSizeofOutputBuffer = 1;   <br>    } <br> <br>    // Make FormatMessage pretty print the system error. <br>    dwRetFM = FormatMessage( <br>        dwFlags, NULL, dwLastError, <br>        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), <br>        (LPTSTR) &amp;szOutputBuffer, dwSizeofOutputBuffer, <br>        NULL); <br> <br>    // FormatMessage failed to print the error. <br>    if (dwRetFM == 0) <br>    { <br>        DWORD dwGetLastError; <br>        LPSTR szFormatMessageError; <br> <br>        dwGetLastError = GetLastError(); <br> <br>        // If we asked FormatMessage to allocate a buffer, then it <br>        // might have allocated one.  Lets be safe and LocalFree it. <br>        if (dwFlags &amp; FORMAT_MESSAGE_ALLOCATE_BUFFER) <br>        { <br>            __try <br>            { <br>                LocalFree(szOutputBuffer); <br>            } <br>            __except(EXCEPTION_EXECUTE_HANDLER) <br>            { <br>                // Actually, we do nothing for this fault.  If <br>                // there was a fault, it meant the buffer wasn't <br>                // allocated, and the LocalFree was unnecessary. <br>                ; <br>            } <br> <br>            szOutputBuffer = LocalAlloc(LPTR, MAXOUTPUTSTRINGLENGTH); <br>            dwSizeofOutputBuffer = MAXOUTPUTSTRINGLENGTH; <br> <br>            if (szOutputBuffer == NULL) <br>            { <br>                OutputDebugString("Out of memory trying to FormatLastError\r\n"); <br>                return NULL; <br>            } <br>        } <br> <br>        szFormatMessageError =  <br>            FormatLastError(dwGetLastError, NULL, 0); <br> <br>        if (szFormatMessageError == NULL) <br>            return NULL; <br> <br>        wsprintf(szOutputBuffer,  <br>            "FormatMessage failed on error 0x%lx for the following reason: %s", <br>            dwLastError, szFormatMessageError); <br> <br>        LocalFree(szFormatMessageError); <br>    } <br> <br>    return szOutputBuffer; <br>} <br> <br> <br>// <br>//  FUNCTION: OutputDebugLineCallback(...) <br>// <br>//  PURPOSE: Pretty print a message passed into a lineCallbackFunc. <br>// <br>//  PARAMETERS: <br>//    Standard lineCallbackFunc parameters. <br>// <br>//  RETURN VALUE: <br>//    none. <br>// <br>//  COMMENTS: <br>// <br>//    This function takes all of the parameters passed into a <br>//    lineCallbackFunc callback function, and pretty prints the <br>//    meaning of the message.  It then prints the result to <br>//    the debugging output. <br>// <br>// <br> <br>void OutputDebugLineCallback( <br>    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance,  <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br>    char szOutputBuff[MAXOUTPUTSTRINGLENGTH]; <br> <br>    FormatLineCallback(szOutputBuff,  <br>        dwDevice, dwMsg, dwCallbackInstance,  <br>        dwParam1, dwParam2, dwParam3); <br> <br>    strcat(szOutputBuff,"\r\n"); <br> <br>    OutputDebugString(szOutputBuff); <br>} <br> <br> <br>// <br>//  FUNCTION: FormatLineCallback(...) <br>// <br>//  PURPOSE: Pretty prints into a buffer a lineCallbackFunc message. <br>// <br>//  PARAMETERS: <br>//    Standard lineCallbackFunc parameters. <br>// <br>//  RETURN VALUE: <br>//    The pointer to the buffer that has the resulting string. <br>// <br>//  COMMENTS: <br>// <br>//    This function takes all of the parameters passed into a <br>//    lineCallbackFunc callback function, and pretty prints the <br>//    meaning of the message.  It then returns the pointer to <br>//    the buffer containing this string. <br>// <br>//    If szOutputBuffer == NULL, then a buffer is LocalAlloc()d <br>//    and returned.  However, it is *very* important that this buffer <br>//    is LocalFree()d. <br>// <br> <br>LPSTR FormatLineCallback(LPSTR szOutputBuffer, <br>    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance,  <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br>    long lBufferIndex = 0; <br> <br>    // Allocate the buffer if necessary. <br>    if (szOutputBuffer == NULL) <br>    { <br>        szOutputBuffer = (LPSTR) LocalAlloc(LPTR, MAXOUTPUTSTRINGLENGTH); <br> <br>        if (szOutputBuffer == NULL) <br>            return NULL; <br>    } <br> <br>    // Is this a known message? <br>    if (dwMsg &gt;= sizeofArray(psz_dwMsg)) <br>    { <br>        wsprintf(szOutputBuffer, "lineCallback: Unknown dwMsg: '0x%lx', " <br>            "dwDevice: '0x%lx', dwCallbackInstance: '0x%lx', " <br>            "dwParam1: '0x%lx', dwParam2: '0x%lx', dwParam3: '0x%lx'", dwMsg,  <br>            dwDevice, dwCallbackInstance, dwParam1, dwParam2, dwParam3); <br>        return szOutputBuffer; <br>    } <br> <br>    // Lets start pretty printing. <br>    lBufferIndex += <br>        wsprintf(szOutputBuffer, "lineCallback: %s; dwDevice: '0x%lx'; ", <br>            psz_dwMsg[dwMsg], dwDevice); <br> <br>    // Which message was it?  And start decoding it! <br>    // How the message is decoded depends entirely on the message. <br>    // READ THE HELP FILES if you more information on this. <br>    switch(dwMsg) <br>    { <br>        case LINE_ADDRESSSTATE: <br>        { <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    "Address ID: 0x%lx, Address State: ", dwParam1); <br> <br>            lBufferIndex += <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam2, <br>                    pszfLINEADDRESSSTATE, sizeofArray(pszfLINEADDRESSSTATE)); <br> <br>            break; <br>        } <br> <br>        case LINE_CALLINFO: <br>        { <br>            lBufferIndex += <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam1, <br>                    pszfLINECALLINFOSTATE, sizeofArray(pszfLINECALLINFOSTATE)); <br> <br>            break; <br>        } <br> <br>        case LINE_CALLSTATE: <br>        { <br> <br>            lBufferIndex += <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam3, <br>                    pszfLINECALLPRIVILEGE, sizeofArray(pszfLINECALLPRIVILEGE)); <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    "; "); <br> <br>            lBufferIndex +=  <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam1, <br>                    pszfLINECALLSTATE, sizeofArray(pszfLINECALLSTATE)); <br>     <br>            switch(dwParam1) <br>            { <br>                case LINECALLSTATE_DIALTONE: <br>                { <br>                    lBufferIndex += <br>                        wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                            ": "); <br> <br>                    lBufferIndex +=  <br>                        strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                        dwParam2, <br>                        pszfLINEDIALTONEMODE, sizeofArray(pszfLINEDIALTONEMODE)); <br> <br>                    break; <br>                } <br> <br>                case LINECALLSTATE_BUSY: <br>                { <br>                    lBufferIndex += <br>                        wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                            ": "); <br> <br>                    lBufferIndex +=  <br>                        strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                        dwParam2, <br>                        pszfLINEBUSYMODE, sizeofArray(pszfLINEBUSYMODE)); <br> <br>                    break; <br>                } <br> <br>                case LINECALLSTATE_SPECIALINFO: <br>                { <br>                    lBufferIndex += <br>                        wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                            ": "); <br> <br>                    lBufferIndex +=  <br>                        strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                        dwParam2, <br>                        pszfLINESPECIALINFO, sizeofArray(pszfLINESPECIALINFO)); <br> <br>                    break; <br>                } <br> <br>                case LINECALLSTATE_DISCONNECTED: <br>                { <br>                    lBufferIndex += <br>                        wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                            ": "); <br> <br>                    lBufferIndex +=  <br>                        strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                        dwParam2, <br>                        pszfLINEDISCONNECTED, sizeofArray(pszfLINEDISCONNECTED)); <br> <br>                    break; <br>                } <br> <br>                case LINECALLSTATE_CONFERENCED: <br>                { <br>                    lBufferIndex += <br>                        wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                            ": Parent conference call handle: 0x%lx", dwParam2); <br> <br>                    break; <br>                } <br>            } <br> <br>            break; </code></pre>
<p>
</p>
<pre><code>} <br> <br>        case LINE_CLOSE: <br>            break; <br> <br>        case LINE_DEVSPECIFIC: <br>            break; <br> <br>        case LINE_DEVSPECIFICFEATURE: <br>            break; <br> <br>        case LINE_GATHERDIGITS: <br>        { <br>            lBufferIndex += <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam1, <br>                    pszfLINEGATHERTERM, sizeofArray(pszfLINEGATHERTERM)); <br> <br>            break; <br>        } <br> <br>        case LINE_GENERATE: <br>        { <br>            lBufferIndex += <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam1, <br>                    pszfLINEGENERATETERM, sizeofArray(pszfLINEGENERATETERM)); <br> <br>            break; <br>        } <br> <br>        case LINE_LINEDEVSTATE: <br>        { <br>            lBufferIndex += <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam1, <br>                    pszfLINEDEVSTATE, sizeofArray(pszfLINEDEVSTATE)); <br> <br>            switch(dwParam1) <br>            { <br>                case LINEDEVSTATE_RINGING: <br>                    lBufferIndex += <br>                        wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                            "; Ring Mode: 0x%lx, Ring Count: %lu" <br>                            ,dwParam2, dwParam3); <br>                    break; <br> <br>                case LINEDEVSTATE_REINIT: <br>                { <br>                    switch(dwParam2) <br>                    { <br>                        case LINE_CREATE: <br>                            lBufferIndex += <br>                                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                                    "; ReInit reason: LINE_CREATE, " <br>                                        "New Line Device ID '0x%lx'" <br>                                    , dwParam3); <br>                            break; <br>                             <br>                        case LINE_LINEDEVSTATE: <br>                            lBufferIndex += <br>                                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                                    "; ReInit reason: LINE_LINEDEVSTATE, "); <br> <br>                            lBufferIndex += <br>                                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                                    dwParam3, <br>                                    pszfLINEDEVSTATE, sizeofArray(pszfLINEDEVSTATE)); <br> <br>                            break; <br>                         <br>                        case 0: <br>                            break; <br>                        default: <br>                            lBufferIndex += <br>                                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                                    "; ReInit reason: %s, dwParam3: 0x%lx" <br>                                    ,psz_dwMsg[dwParam2], dwParam3); <br>                            break; <br> <br>                    } <br> <br>                    break; <br>                } <br> <br>                default: <br>                    break; <br>            } <br> <br>            break; <br>        } <br> <br>        case LINE_MONITORDIGITS: <br>        { <br>            lBufferIndex +=  <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                dwParam2, <br>                pszfLINEDIGITMODE, sizeofArray(pszfLINEDIGITMODE)); <br> <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    ", Received: '%c'", LOBYTE(LOWORD(dwParam1))); <br>             <br>            break; <br>        } <br> <br>        case LINE_MONITORMEDIA: <br>        { <br>            lBufferIndex += <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                    dwParam1, <br>                    pszfLINEMEDIAMODE, sizeofArray(pszfLINEMEDIAMODE)); <br> <br>            break; <br>        } <br> <br>        case LINE_MONITORTONE: <br>        { <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    "AppSpecific tone '%lu'", dwParam1); <br>            break; <br>        } <br> <br>        case LINE_REPLY: <br>        { <br>            if (dwParam2 == 0) <br>            { <br>                lBufferIndex += <br>                    wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                        "Request ID: 0x%lx; Successful reply!", dwParam1); <br>            } <br>            else <br>            { <br>                char szTmpBuff[256]; <br> <br>                FormatLineError((long) dwParam2, szTmpBuff, 255); <br> <br>                lBufferIndex += <br>                    wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                        "Request ID: 0x%lx; UnSuccessful reply; %s", <br>                        dwParam1, szTmpBuff); <br>            } <br> <br>            break; <br>        } <br> <br>        case LINE_REQUEST: <br>        { <br>            lBufferIndex +=  <br>                strBinaryArrayAppend(&amp;(szOutputBuffer[lBufferIndex]), <br>                dwParam1, <br>                pszfLINEREQUESTMODE, sizeofArray(pszfLINEREQUESTMODE)); <br> <br>            switch(dwParam1) <br>            { <br>                case LINEREQUESTMODE_DROP: <br>                { <br>                    char szHwndName[1024]; <br> <br>                    SendMessage((HWND) dwParam2, WM_GETTEXT, 1024, (long) szHwndName); <br> <br>                    lBufferIndex += <br>                        wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                            ": hwnd dropping = 0x%lx, \"%s\"; wRequestID = %u", <br>                            dwParam2, szHwndName, LOWORD(dwParam3)); <br>                    break; <br>                } <br>                default: <br>                    break; <br>            } <br> <br>            break; <br>        } <br> <br>        case LINE_CREATE: <br>        { <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    "New Line Device ID '0x%lx'", dwParam1); <br>            break; <br>        } <br> <br>        case PHONE_CREATE: <br>        { <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    "New Phone Device ID '0x%lx'", dwParam1); <br>            break; <br>        } <br> <br>        default: <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    "dwParam1: 0x%lx , dwParam2: 0x%lx , dwParam3: 0x%lx", <br>                    dwParam1, dwParam2, dwParam3); <br>            break; <br> <br>    } // End switch(dwMsg) <br> <br>    // return that pointer! <br>    return szOutputBuffer; <br> <br>} <br> <br> <br>// <br>//  FUNCTION: strBinaryArrayAppend(LPSTR, DWORD, LPSTR *, DWORD) <br>// <br>//  PURPOSE: Takes a bitmapped DWORD, an array representing that <br>//    binary mapping, and pretty prints it to a buffer. <br>// <br>//  PARAMETERS: <br>//    szOutputBuffer      - Buffer to print to. <br>//    dwFlags             - Binary mapped flags to interpret. <br>//    szStringArray       - Array of strings. <br>//    dwSizeofStringArray - number of elements in szStringArray. <br> <br>// <br>//  RETURN VALUE: <br>//    The number of characters printed into szOutputBuffer. <br>// <br>//  COMMENTS: <br>// <br>//    This function takes dwFlags and checks each bit.  If the <br>//    bit is set, the appropriate string (taken from szStringArray) <br>//    is printed to the szOutputBuffer string buffer.  If there were <br>//    more bits set in the string than elements in the array, and error <br>//    is also tagged on the end. <br>// <br>//    This function is intended to be used only within the TapiInfo module. <br>// <br> <br>static long strBinaryArrayAppend(LPSTR szOutputBuffer, DWORD dwFlags, <br>     LPSTR szStringArray[], DWORD dwSizeofStringArray) <br>{ <br>    DWORD dwIndex = 1, dwPower = 1; <br>    long lBufferIndex = 0; <br>    BOOL bFirst = TRUE; <br> <br>    // The zeroth element in every bitmapped array is the "unknown" or <br>    // "unchanged" message. <br>    if (dwFlags == 0) <br>    { <br>        lBufferIndex = <br>            wsprintf(szOutputBuffer, "%s", szStringArray[0]); <br>        return lBufferIndex; <br>    } <br> <br>    // iterate through the flags and check each one. <br>    while(dwIndex &lt; dwSizeofStringArray) <br>    { <br>        // If we find one, print it. <br>        if (dwFlags &amp; dwPower) <br>            // Seporate each printing with a ", " except the first one. <br>            if (bFirst) <br>            { <br>                lBufferIndex += <br>                    wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                        "%s", szStringArray[dwIndex]); <br>                bFirst = FALSE; <br>            } <br>            else <br>                lBufferIndex += <br>                    wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                        ", %s", szStringArray[dwIndex]); <br> <br>        dwIndex ++; <br>        dwFlags &amp;= ~dwPower;  // clear it so we know we checked it. <br>        dwPower *= 2; <br>    } <br> <br>    // If there are any flags left, they were not in the array. <br>    if (dwFlags) <br>    { <br>        if (bFirst) <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    "Unknown flags '0x%lx'", dwFlags); <br>        else <br>            lBufferIndex += <br>                wsprintf(&amp;(szOutputBuffer[lBufferIndex]), <br>                    ", Unknown flags '0x%lx'", dwFlags); <br>    } <br> <br>    // how many did we print into the buffer? <br>    return lBufferIndex; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: OutputDebugPrintf(LPCSTR, ...) <br>// <br>//  PURPOSE: wsprintf to the debugging output. <br>// <br>//  PARAMETERS: <br>//    Exactly the same as wsprintf. <br>// <br>//  RETURN VALUE: <br>//    none. <br>// <br>//  COMMENTS: <br>// <br>//    This function takes exactly the same parameters as wsprintf and <br>//    prints the results to the debugging output. <br>// <br> <br>void __cdecl OutputDebugPrintf(LPCSTR lpszFormat, ...) <br>{ <br>    char szOutput[MAXOUTPUTSTRINGLENGTH]; <br>    va_list v1; <br>    DWORD dwSize; <br> <br>    va_start(v1, lpszFormat); <br> <br>    dwSize = wvsprintf(szOutput, lpszFormat, v1); <br> <br>    if (szOutput[dwSize-1] != '\n') <br>        strcat(szOutput, "\r\n"); <br> <br>    OutputDebugString(szOutput); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
