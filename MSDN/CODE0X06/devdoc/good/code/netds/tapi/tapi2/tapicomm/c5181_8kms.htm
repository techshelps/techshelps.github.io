<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TAPICODE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5194"></a>TAPICODE.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE: TapiCode.c <br>// <br>//  PURPOSE: Handles all the TAPI routines for TapiComm. <br>// <br>// <br>//  EXPORTED FUNCTIONS:  These functions are for use by other modules. <br>// <br>//    InitializeTAPI    - Initialize this app with TAPI. <br>//    ShutdownTAPI      - Shutdown this app from TAPI. <br>//    DialCall          - Dial a Call. <br>//    HangupCall        - Hangup an existing Call. <br>//    PostHangupCall    - Posts a HangupCall message to the main window. <br>// <br>//  INTERNAL FUNCTIONS:  These functions are for this module only. <br>// <br>//    DialCallInParts           - Actually Dial the call. <br>// <br>//    lineCallbackFunc          - TAPI callback for async messages. <br>// <br>//    CheckAndReAllocBuffer     - Helper function for I_ wrappers functions. <br>// <br>//    I_lineNegotiateAPIVersion - Wrapper for lineNegotiateAPIVersion. <br>//    I_lineGetDevCaps          - Wrapper for lineGetDevCaps. <br>//    I_lineGetAddressStatus    - Wrapper for lineGetAddressStatus. <br>//    I_lineTranslateAddress    - Wrapper for lineTranslateAddress. <br>//    I_lineGetCallStatus       - Wrapper for lineGetCallStatus. <br>//    I_lineGetAddressCaps      - Wrapper for lineGetAddressCaps. <br>// <br>//    WaitForCallState          - Resynchronize by Waiting for a CallState. <br>//    WaitForReply              - Resynchronize by Waiting for a LINE_REPLY. <br>// <br>//    DoLineReply               - Handle asynchronous LINE_REPLY. <br>//    DoLineClose               - Handle asynchronous LINE_CLOSE. <br>//    DoLineDevState            - Handle asynchronous LINE_LINEDEVSTATE. <br>//    DoLineCallState           - Handle asynchronous LINE_CALLSTATE. <br>//    DoLineCreate              - Handle asynchronous LINE_CREATE. <br>// <br>//    HandleLineErr             - Handler for most LINEERR errors. <br>// <br>//    HandleIniFileCorrupt      - LINEERR handler for INIFILECORRUPT. <br>//    HandleNoDriver            - LINEERR handler for NODRIVER. <br>//    HandleNoDevicesInstalled  - LINEERR handler for NODEVICE. <br>//    HandleReInit              - LINEERR handler for REINIT. <br>//    HandleNoMultipleInstance  - LINEERR handler for NOMULTIPLEINSTANCE. <br>//    HandleNoMem               - LINEERR handler for NOMEM. <br>//    HandleOperationFailed     - LINEERR handler for OPERATIONFAILED. <br>//    HandleResourceUnavail     - LINEERR handler for RESOURCEUNAVAIL. <br>// <br>//    LaunchModemControlPanelAdd - Launches the Modem Control Panel. <br>// <br>//    WarningBox                - Warn user if a line in use is removed. <br>// <br>//    GetAddressToDial          - Launches a GetAddressToDial dialog. <br>//    DialDialogProc            - Dialog Proc for the GetAddressToDial API. <br>//     <br>//    I_lineNegotiateLegacyAPIVersion - Wrapper to negoitiate with legacy TSPs <br>//    VerifyUsableLine          - Verify that a line device is usable <br>//    FillTAPILine              - Fill a combobox with TAPI Device names <br>//    VerifyAndWarnUsableLine   - Verify and warn if a line device is usable <br>//    FillCountryCodeList       - Fill a combobox with country codes <br>//    FillLocationInfo          - Fill a combobox with current TAPI locations <br>//    UseDialingRules           - Enable/Disable dialing rules controls  <br>//    DisplayPhoneNumber        - Create and display a valid phone number <br>//    PreConfigureDevice        - Preconfigure a device line <br> <br> <br>#include &lt;tapi.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "globals.h" <br>#include "TapiInfo.h" <br>#include "TapiCode.h" <br>#include "CommCode.h"    <br>#include "resource.h" <br>#include "statbar.h" <br>#include "toolbar.h" <br> <br> <br>// All TAPI line functions return 0 for SUCCESS, so define it. <br>#define SUCCESS 0 <br> <br>// Possible return error for resynchronization functions. <br>#define WAITERR_WAITABORTED  1 <br>#define WAITERR_WAITTIMEDOUT 2 <br> <br>// Reasons why a line device might not be usable by TapiComm. <br>#define LINENOTUSEABLE_ERROR            1 <br>#define LINENOTUSEABLE_NOVOICE          2 <br>#define LINENOTUSEABLE_NODATAMODEM      3 <br>#define LINENOTUSEABLE_NOMAKECALL       4 <br>#define LINENOTUSEABLE_ALLOCATED        5 <br>#define LINENOTUSEABLE_INUSE            6 <br>#define LINENOTUSEABLE_NOCOMMDATAMODEM  7 <br> <br>// Constant used in WaitForCallState when any new <br>// callstate message is acceptable. <br>#define I_LINECALLSTATE_ANY 0 <br> <br> // Wait up to 30 seconds for an async completion. <br>#define WAITTIMEOUT 30000 <br> <br>// TAPI version that this sample is designed to use. <br>#define SAMPLE_TAPI_VERSION 0x00010004 <br> <br> <br>// Global TAPI variables. <br>HWND     g_hWndMainWindow = NULL;   // Apps main window. <br>HWND     g_hDlgParentWindow = NULL; // This will be the parent of all dialogs. <br>HLINEAPP g_hLineApp = NULL; <br>DWORD    g_dwNumDevs = 0; <br> <br>// Global variable that holds the handle to a TAPI dialog <br>// that needs to be dismissed if line conditions change. <br>HWND g_hDialog = NULL; <br> <br>// Global flags to prevent re-entrancy problems. <br>BOOL g_bShuttingDown = FALSE; <br>BOOL g_bStoppingCall = FALSE; <br>BOOL g_bInitializing = FALSE; <br> <br> <br>// This sample only supports one call in progress at a time. <br>BOOL g_bTapiInUse = FALSE; <br> <br> <br>// Data needed per call.  This sample only supports one call. <br>HCALL g_hCall = NULL; <br>HLINE g_hLine = NULL; <br>DWORD g_dwDeviceID = 0; <br>DWORD g_dwAPIVersion = 0; <br>DWORD g_dwCallState = 0; <br>char  g_szDisplayableAddress[1024] = ""; <br>char  g_szDialableAddress[1024] = ""; <br>BOOL  g_bConnected = FALSE; <br>LPVOID g_lpDeviceConfig = NULL; <br>DWORD g_dwSizeDeviceConfig; <br> <br>// Global variables to allow us to do various waits. <br>BOOL  g_bReplyRecieved; <br>DWORD g_dwRequestedID; <br>long  g_lAsyncReply; <br>BOOL  g_bCallStateReceived; <br> <br>// Structures needed to handle special non-dialable characters. <br>#define g_sizeofNonDialable (sizeof(g_sNonDialable)/sizeof(g_sNonDialable[0])) <br> <br>typedef struct { <br>    LONG lError; <br>    DWORD dwDevCapFlag; <br>    LPSTR szToken; <br>    LPSTR szMsg; <br>} NONDIALTOKENS; <br> <br>NONDIALTOKENS g_sNonDialable[] = { <br>    {LINEERR_DIALBILLING,  LINEDEVCAPFLAGS_DIALBILLING,  "$",  <br>            "Wait for the credit card bong tone" }, <br>    {LINEERR_DIALDIALTONE, LINEDEVCAPFLAGS_DIALDIALTONE, "W",  <br>            "Wait for the second dial tone" }, <br>    {LINEERR_DIALDIALTONE, LINEDEVCAPFLAGS_DIALDIALTONE, "w",  <br>            "Wait for the second dial tone" }, <br>    {LINEERR_DIALQUIET,    LINEDEVCAPFLAGS_DIALQUIET,    "@",  <br>            "Wait for the remote end to answer" }, <br>    {LINEERR_DIALPROMPT,   0,                            "?",  <br>            "Press OK when you are ready to continue dialing"}, <br>}; <br> <br>// "Dial" dialog controls and their associated help page IDs <br>DWORD g_adwSampleMenuHelpIDs[] =  <br>{ <br>    IDC_COUNTRYCODE          , IDC_COUNTRYCODE, <br>    IDC_STATICCOUNTRYCODE    , IDC_COUNTRYCODE, <br>    IDC_AREACODE             , IDC_AREACODE, <br>    IDC_STATICAREACODE       , IDC_AREACODE, <br>    IDC_PHONENUMBER          , IDC_PHONENUMBER, <br>    IDC_STATICPHONENUMBER    , IDC_PHONENUMBER, <br>    IDC_USEDIALINGRULES      , IDC_USEDIALINGRULES, <br>    IDC_LOCATION             , IDC_LOCATION, <br>    IDC_STATICLOCATION       , IDC_LOCATION, <br>    IDC_CALLINGCARD          , IDC_CALLINGCARD, <br>    IDC_STATICCALLINGCARD    , IDC_CALLINGCARD, <br>    IDC_DIALINGPROPERTIES    , IDC_DIALINGPROPERTIES, <br>    IDC_TAPILINE             , IDC_TAPILINE, <br>    IDC_STATICTAPILINE       , IDC_TAPILINE, <br>    IDC_CONFIGURELINE        , IDC_CONFIGURELINE, <br>    IDC_CANONICALNUMBER      , IDC_CANONICALNUMBER, <br>    IDC_STATICCANONICAL      , IDC_CANONICALNUMBER, <br>    IDC_DIALABLENUMBER       , IDC_DIALABLENUMBER, <br>    IDC_STATICDIALABLE       , IDC_DIALABLENUMBER, <br>    IDC_DISPLAYABLENUMBER    , IDC_DISPLAYABLENUMBER, <br>    IDC_STATICDISPLAYABLE    , IDC_DISPLAYABLENUMBER, <br>    IDC_DIAL                 , IDC_DIAL, <br>    IDC_LINEICON             , IDC_LINEICON, <br>    //IDC_STATICWHERETODIAL    , IDC_STATICWHERETODIAL, <br>    //IDC_STATICHOWTODIAL      , IDC_STATICHOWTODIAL, <br>    //IDC_STATICCONNECTUSING   , IDC_STATICCONNECTUSING, <br>    //IDC_STATICPHONENUMBER    , IDC_PHONENUMBER, <br>    0,0 <br>}; <br> <br>//************************************************** <br>// Prototypes for functions used only in this module. <br>//************************************************** <br> <br>BOOL DialCallInParts ( <br>    LPLINEDEVCAPS lpLineDevCaps, <br>    LPCSTR lpszAddress, <br>    LPCSTR lpszDisplayableAddress); <br> <br>LPLINECALLPARAMS CreateCallParams ( <br>    LPLINECALLPARAMS lpCallParams, <br>    LPCSTR lpszDisplayableAddress); <br> <br>DWORD I_lineNegotiateAPIVersion ( <br>    DWORD dwDeviceID); <br> <br>LPVOID CheckAndReAllocBuffer( <br>    LPVOID lpBuffer, size_t sizeBufferMinimum,  <br>    LPCSTR szApiPhrase); <br> <br>LPLINEDEVCAPS I_lineGetDevCaps ( <br>    LPLINEDEVCAPS lpLineDevCaps, <br>    DWORD dwDeviceID, <br>    DWORD dwAPIVersion); <br> <br>LPLINEADDRESSSTATUS I_lineGetAddressStatus ( <br>    LPLINEADDRESSSTATUS lpLineAddressStatus, <br>    HLINE hLine, <br>    DWORD dwAddressID); <br> <br>LPLINETRANSLATEOUTPUT I_lineTranslateAddress ( <br>    LPLINETRANSLATEOUTPUT lpLineTranslateOutput, <br>    DWORD dwDeviceID, <br>    DWORD dwAPIVersion, <br>    LPCSTR lpszDialAddress); <br> <br>LPLINECALLSTATUS I_lineGetCallStatus ( <br>    LPLINECALLSTATUS lpLineCallStatus, <br>    HCALL hCall); <br> <br>LPLINEADDRESSCAPS I_lineGetAddressCaps ( <br>    LPLINEADDRESSCAPS lpLineAddressCaps, <br>    DWORD dwDeviceID, DWORD dwAddressID, <br>    DWORD dwAPIVersion, DWORD dwExtVersion); <br> <br>long WaitForCallState (DWORD dwNewCallState); <br> <br>long WaitForReply (long lRequestID); <br> <br>void CALLBACK lineCallbackFunc( <br>    DWORD hDevice, DWORD dwMsg, DWORD dwCallbackInstance,  <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3); <br> <br>void DoLineReply( <br>    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3); <br>void DoLineClose( <br>    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3); <br>void DoLineDevState( <br>    DWORD dwDevice, DWORD dwsg, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3); <br>void DoLineCallState( <br>    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3); <br>void DoLineCreate( <br>    DWORD dwDevice, DWORD dwMessage, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3); <br> <br>BOOL HandleLineErr(long lLineErr); <br> <br>BOOL HandleIniFileCorrupt(); <br>BOOL HandleNoDriver(); <br>BOOL HandleNoDevicesInstalled(); <br>BOOL HandleReInit(); <br>BOOL HandleNoMultipleInstance(); <br>BOOL HandleNoMem(); <br>BOOL HandleOperationFailed(); <br>BOOL HandleResourceUnavail(); <br> <br>BOOL LaunchModemControlPanelAdd(); <br> <br>void WarningBox(LPCSTR lpszMessage); <br> <br>BOOL CALLBACK DialDialogProc( <br>    HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>BOOL GetAddressToDial(); <br> <br>DWORD I_lineNegotiateLegacyAPIVersion(DWORD dwDeviceID); <br>long VerifyUsableLine(DWORD dwDeviceID); <br>void FillTAPILine(HWND hwndDlg); <br>BOOL VerifyAndWarnUsableLine(HWND hwndDlg); <br>void FillCountryCodeList(HWND hwndDlg, DWORD dwDefaultCountryID); <br>void FillLocationInfo(HWND hwndDlg, LPSTR lpszCurrentLocation,  <br>    LPDWORD lpdwCountryID, LPSTR lpszAreaCode); <br>void UseDialingRules(HWND hwndDlg); <br>void DisplayPhoneNumber(HWND hwndDlg); <br>void PreConfigureDevice(HWND hwndDlg, DWORD dwDeviceID); <br> <br> <br>//************************************************** <br>// Entry points from the UI <br>//************************************************** <br> <br> <br>// <br>//  FUNCTION: BOOL InitializeTAPI(HWND) <br>// <br>//  PURPOSE: Initializes TAPI <br>// <br>//  PARAMETERS: <br>//    hWndParent - Window to use as parent of any dialogs. <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - command handled. <br>// <br>//  COMMENTS: <br>// <br>//    This is the API that initializes the app with TAPI. <br>//    If NULL is passed for the hWndParent, then its assumed <br>//    that re-initialization has occurred and the previous hWnd <br>//    is used. <br>// <br>// <br> <br>BOOL InitializeTAPI(HWND hWndParent) <br>{ <br>    long lReturn; <br>    BOOL bTryReInit = TRUE; <br> <br>    // If we're already initialized, then initialization succeeds. <br>    if (g_hLineApp) <br>        return TRUE; <br> <br>    // If we're in the middle of initializing, then fail, we're not done. <br>    if (g_bInitializing) <br>        return FALSE; <br> <br>    g_bInitializing = TRUE; <br> <br>    // Initialize TAPI <br>    do <br>    { <br>        lReturn = lineInitialize(&amp;g_hLineApp, hInst,  <br>            lineCallbackFunc, "TapiComm", &amp;g_dwNumDevs); <br> <br>        // If we get this error, its because some other app has yet <br>        // to respond to the REINIT message.  Wait 5 seconds and try <br>        // again.  If it still doesn't respond, tell the user. <br>        if (lReturn == LINEERR_REINIT) <br>        { <br>            if (bTryReInit) <br>            { <br>                MSG msg;  <br>                DWORD dwTimeStarted; <br> <br>                dwTimeStarted = GetTickCount(); <br> <br>                while(GetTickCount() - dwTimeStarted &lt; 5000) <br>                { <br>                    if (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) <br>                    { <br>                        TranslateMessage(&amp;msg); <br>                        DispatchMessage(&amp;msg); <br>                    } <br>                } <br>             <br>                bTryReInit = FALSE; <br>                continue; <br>            } <br>            else <br>            { <br>                MessageBox(g_hDlgParentWindow, <br>                    "A change to the system configuration requires that " <br>                    "all Telephony applications relinquish their use of " <br>                    "Telephony before any can progress.  " <br>                    "Some have not yet done so." <br>                    ,"Warning",MB_OK); <br>                g_bInitializing = FALSE; <br>                return FALSE; <br>            } <br>        } <br> <br>        if (lReturn == LINEERR_NODEVICE) <br>        { <br>            if (HandleNoDevicesInstalled()) <br>                continue; <br>            else <br>            { <br>                OutputDebugString("No devices installed.\n"); <br>                g_bInitializing = FALSE; <br>                return FALSE; <br>            } <br>        } <br> <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            OutputDebugLineError(lReturn,  <br>                "lineInitialize unhandled error: "); <br>            g_bInitializing = FALSE; <br>            return FALSE; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br> <br>    // if hWndParent is a valid hWnd, we keep it as the parent for <br>    // all dialogs. <br>    if (IsWindow(hWndParent)) <br>    { <br>        g_hDlgParentWindow = g_hWndMainWindow = hWndParent; <br>    } <br>    else <br>    { <br>        // Has the old g_hWndMainWindow gone away? <br>        if (!IsWindow(g_hWndMainWindow)) <br>        { <br>            OutputDebugString("Main window unavailable.\n"); <br>            g_hDlgParentWindow = g_hWndMainWindow = NULL; <br>        } <br>    } <br> <br>    g_hCall = NULL; <br>    g_hLine = NULL; <br> <br>    OutputDebugString("Tapi initialized.\n"); <br>    g_bInitializing = FALSE; <br>    return TRUE; <br>} <br> <br> <br>// <br>//  FUNCTION: BOOL ShutdownTAPI() <br>// <br>//  PURPOSE: Shuts down all use of TAPI <br>// <br>//  PARAMETERS: <br>//    None <br>// <br>//  RETURN VALUE: <br>//    True if TAPI successfully shut down. <br>// <br>//  COMMENTS: <br>// <br>//    If ShutdownTAPI fails, then its likely either a problem <br>//    with the service provider (and might require a system <br>//    reboot to correct) or the application ran out of memory. <br>// <br>// <br> <br>BOOL ShutdownTAPI() <br>{ <br>    long lReturn; <br> <br>    // If we aren't initialized, then Shutdown is unnecessary. <br>    if (g_hLineApp == NULL) <br>        return TRUE; <br> <br>    // Prevent ShutdownTAPI re-entrancy problems. <br>    if (g_bShuttingDown) <br>        return TRUE; <br> <br>    g_bShuttingDown = TRUE; <br> <br>    HangupCall(); <br>     <br>    do <br>    { <br>        lReturn = lineShutdown(g_hLineApp); <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            OutputDebugLineError(lReturn, "lineShutdown unhandled error: "); <br>            break; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br> <br>    g_bTapiInUse = FALSE; <br>    g_bConnected = FALSE; <br>    g_hLineApp = NULL; <br>    g_hCall = NULL; <br>    g_hLine = NULL; <br>    g_bShuttingDown = FALSE; <br>    OutputDebugString("TAPI uninitialized.\n"); <br>    return TRUE; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: BOOL HangupCall() <br>// <br>//  PURPOSE: Hangup the call in progress if it exists. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE if call hung up successfully. <br>// <br>//  COMMENTS: <br>// <br>//    If HangupCall fails, then its likely either a problem <br>//    with the service provider (and might require a system <br>//    reboot to correct) or the application ran out of memory. <br>// <br>// <br> <br>BOOL HangupCall() <br>{          <br>    LPLINECALLSTATUS pLineCallStatus = NULL; <br>    long lReturn; <br> <br>    // Prevent HangupCall re-entrancy problems. <br>    if (g_bStoppingCall) <br>        return TRUE; <br> <br>    // if the 'Call' dialog is up, dismiss it. <br>    if (g_hDialog) <br>        PostMessage(g_hDialog, WM_COMMAND, IDCANCEL, 0); <br> <br>    // If Tapi is not being used right now, then the call is hung up. <br>    if (!g_bTapiInUse) <br>        return TRUE; <br> <br>    g_bStoppingCall = TRUE; <br>    OutputDebugString("Stopping Call in progress\n"); <br> <br>    // Disable the 'hangup call' user interface. <br>    EnableHangupCall(g_hWndMainWindow, FALSE); <br> <br>    // Stop any data communications on the comm port. <br>    StopComm(); <br> <br>    // If there is a call in progress, drop and deallocate it. <br>    if (g_hCall) <br>    { <br>        // I_lineGetCallStatus returns a LocalAlloc()d buffer <br>        pLineCallStatus = I_lineGetCallStatus(pLineCallStatus, g_hCall); <br>        if (pLineCallStatus == NULL) <br>        { <br>            ShutdownTAPI(); <br>            g_bStoppingCall = FALSE; <br>            return FALSE; <br>        } <br> <br>        // Only drop the call when the line is not IDLE. <br>        if (!((pLineCallStatus -&gt; dwCallState) &amp; LINECALLSTATE_IDLE)) <br>        { <br>            do <br>            { <br>                lReturn = WaitForReply(lineDrop(g_hCall, NULL, 0)); <br> <br>                if (lReturn == WAITERR_WAITTIMEDOUT) <br>                { <br>                    OutputDebugString("Call timed out in WaitForReply.\n"); <br>                    break; <br>                } <br> <br>                if (lReturn == WAITERR_WAITABORTED) <br>                { <br>                    OutputDebugString("lineDrop: WAITERR_WAITABORTED.\n"); <br>                    break; <br>                } <br> <br>                // Was the call already in IDLE? <br>                if (lReturn == LINEERR_INVALCALLSTATE) <br>                    break; <br> <br>                if (HandleLineErr(lReturn)) <br>                    continue; <br>                else <br>                { <br>                    OutputDebugLineError(lReturn,  <br>                        "lineDrop unhandled error: "); <br>                    break; <br>                } <br>            } <br>            while(lReturn != SUCCESS); <br> <br>            // Wait for the dropped call to go IDLE before continuing. <br>            lReturn = WaitForCallState(LINECALLSTATE_IDLE); <br> <br>            if (lReturn == WAITERR_WAITTIMEDOUT) <br>                OutputDebugString("Call timed out waiting for IDLE state.\n"); <br> <br>            if (lReturn == WAITERR_WAITABORTED) <br>                OutputDebugString( <br>                    "WAITERR_WAITABORTED while waiting for IDLE state.\n"); <br> <br>            OutputDebugString("Call Dropped.\n"); <br>        } <br> <br>        // The call is now idle.  Deallocate it! <br>        do <br>        { <br>            lReturn = lineDeallocateCall(g_hCall); <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                OutputDebugLineError(lReturn, <br>                    "lineDeallocateCall unhandled error: "); <br>                break; <br>            } <br>        } <br>        while(lReturn != SUCCESS); <br>             <br>        OutputDebugString("Call Deallocated.\n"); <br>    } <br> <br> <br>    // if we have a line open, close it. <br>    if (g_hLine) <br>    { <br>        do <br>        { <br>            lReturn = lineClose(g_hLine); <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                OutputDebugLineError(lReturn,  <br>                    "lineClose unhandled error: "); <br>                break; <br>            } <br>        } <br>        while(lReturn != SUCCESS); <br>         <br>        OutputDebugString("Line Closed.\n"); <br>    } <br> <br>    // Call and Line are taken care of.  Finish cleaning up. <br> <br>    // If there is device configuration information, free the memory. <br>    if (g_lpDeviceConfig) <br>        LocalFree(g_lpDeviceConfig); <br>    g_lpDeviceConfig = NULL; <br> <br>    g_hCall = NULL; <br>    g_hLine = NULL; <br>    g_bConnected = FALSE; <br> <br>    g_bTapiInUse = FALSE; <br>    g_bStoppingCall = FALSE; // allow HangupCall to be called again. <br>    OutputDebugString("Call stopped\n"); <br> <br>    // Update the user interface. <br>    UpdateStatusBar("Ready to make a call.",1,0); <br>    EnableMakeCall(g_hWndMainWindow, TRUE); <br> <br>    // Need to free LocalAlloc()d buffer returned from I_lineGetCallStatus <br>    if (pLineCallStatus) <br>        LocalFree(pLineCallStatus);   <br>         <br>    return TRUE; <br>} <br> <br> <br>// <br>//  FUNCTION: PostHangupCall() <br>// <br>//  PURPOSE: Posts a message to the main TAPI thread to hangup the call. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    TAPI is thread specific, meaning that only the thread that does the <br>//    lineInitialize can get asynchronous messages through the callback. <br>//    Since the HangupCall can potentially go into a loop waiting for  <br>//    specific events, any other threads that call HangupCall can cause <br>//    timing confusion.  Best to just have other threads 'ask' the main thread <br>//    to hangup the call. <br>// <br> <br>void PostHangupCall() <br>{ <br>    PostMessage(g_hWndMainWindow, WM_COMMAND, IDM_HANGUPCALL, 0); <br>} <br> <br> <br> <br>// <br>//  FUNCTION: DialCall() <br>// <br>//  PURPOSE: Get a number from the user and dial it. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE if able to get a number, find a line, and dial successfully. <br>// <br>//  COMMENTS: <br>// <br>//    This function makes several assumptions: <br>//    - The number dialed will always explicitly come from the user. <br>//    - There will only be one outgoing address per line. <br>// <br> <br>BOOL DialCall() <br>{ <br>    long lReturn; <br>    LPLINEADDRESSSTATUS lpLineAddressStatus = NULL; <br>    LPLINEDEVCAPS lpLineDevCaps = NULL; <br> <br>    if (g_bTapiInUse) <br>    { <br>        OutputDebugString("A call is already being handled\n"); <br>        return FALSE; <br>    } <br> <br>    // If TAPI isn't initialized, its either because we couldn't initialize <br>    // at startup (and this might have been corrected by now), or because <br>    // a REINIT event was received.  In either case, try to init now. <br> <br>    if (!g_hLineApp) <br>    { <br>        if (!InitializeTAPI(NULL)) <br>            return FALSE; <br>    } <br> <br>    // If there are no line devices installed on the machine, lets give <br>    // the user the opportunity to install one. <br>    if (g_dwNumDevs &lt; 1) <br>    { <br>        if (!HandleNoDevicesInstalled()) <br>            return FALSE; <br>    } <br> <br>    // We now have a call active.  Prevent future calls. <br>    g_bTapiInUse = TRUE; <br>    EnableMakeCall(g_hWndMainWindow, FALSE); <br> <br> <br>    // Get a phone number from the user. <br>    // Phone number will be placed in global variables if successful <br>    if (!GetAddressToDial()) <br>    { <br>        HangupCall(); <br>        goto DeleteBuffers; <br>    } <br> <br>    // Negotiate the API version to use for this device. <br>    g_dwAPIVersion = I_lineNegotiateAPIVersion(g_dwDeviceID); <br>    if (g_dwAPIVersion == 0) <br>    { <br>        MessageBox(g_hDlgParentWindow, <br>            "Line Version unsupported by this Sample", <br>            "Unable to Use Line",MB_OK); <br>        HangupCall(); <br>        goto DeleteBuffers; <br>    } <br> <br>    // Need to check the DevCaps to make sure this line is usable. <br>    // The 'Dial' dialog checks also, but better safe than sorry. <br>    lpLineDevCaps = I_lineGetDevCaps(lpLineDevCaps, <br>        g_dwDeviceID, g_dwAPIVersion); <br>    if (lpLineDevCaps == NULL) <br>    { <br>        HangupCall(); <br>        MessageBox(g_hDlgParentWindow, <br>            "Error on Requested line", <br>            "Unable to Use Line",MB_OK); <br>        goto DeleteBuffers; <br>    } <br> <br>    if (!(lpLineDevCaps-&gt;dwBearerModes &amp; LINEBEARERMODE_VOICE )) <br>    { <br>        HangupCall(); <br>        MessageBox(g_hDlgParentWindow, <br>            "Error on Requested line", <br>            "The selected line doesn't support VOICE capabilities", <br>            MB_OK); <br>        goto DeleteBuffers; <br>    } <br> <br>    if (!(lpLineDevCaps-&gt;dwMediaModes &amp; LINEMEDIAMODE_DATAMODEM)) <br>    { <br>        HangupCall(); <br>        MessageBox(g_hDlgParentWindow, <br>            "Error on Requested line", <br>            "The selected line doesn't support DATAMODEM capabilities", <br>            MB_OK); <br>        goto DeleteBuffers; <br>    } <br> <br>    // Does this line have the capability to make calls? <br>    // It is possible that some lines can't make outbound calls. <br>    if (!(lpLineDevCaps-&gt;dwLineFeatures &amp; LINEFEATURE_MAKECALL)) <br>    { <br>        HangupCall(); <br>        MessageBox(g_hDlgParentWindow, <br>            "Error on Requested line", <br>            "The selected line doesn't support MAKECALL capabilities", <br>            MB_OK); <br>        goto DeleteBuffers; <br>    } <br> <br>    // Open the Line for an outgoing DATAMODEM call. <br>    do <br>    { <br>        lReturn = lineOpen(g_hLineApp, g_dwDeviceID, &amp;g_hLine, <br>            g_dwAPIVersion, 0, 0, <br>            LINECALLPRIVILEGE_NONE, LINEMEDIAMODE_DATAMODEM, <br>            0); <br> <br>        if(lReturn == LINEERR_ALLOCATED) <br>        { <br>            HangupCall(); <br>            MessageBox(g_hDlgParentWindow, <br>                "Line is already in use by a non-TAPI application " <br>                "or by another TAPI Service Provider.", <br>                "Unable to Use Line",MB_OK); <br>            goto DeleteBuffers; <br>        } <br> <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            OutputDebugLineError(lReturn, "lineOpen unhandled error: "); <br>            MessageBox(g_hDlgParentWindow, <br>                "Error on Requested line", <br>                "Unable to Use Line",MB_OK); <br>            HangupCall(); <br>            goto DeleteBuffers; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br> <br>    // Tell the service provider that we want all notifications that <br>    // have anything to do with this line. <br>    do <br>    { <br>        // Set the messages we are interested in. <br> <br>        // Note that while most applications aren't really interested <br>        // in dealing with all of the possible messages, its interesting <br>        // to see which come through the callback for testing purposes. <br> <br>        lReturn = lineSetStatusMessages(g_hLine,  <br>            LINEDEVSTATE_OTHER          | <br>            LINEDEVSTATE_RINGING        | <br>            LINEDEVSTATE_CONNECTED      |  // Important state! <br>            LINEDEVSTATE_DISCONNECTED   |  // Important state! <br>            LINEDEVSTATE_MSGWAITON      | <br>            LINEDEVSTATE_MSGWAITOFF     | <br>            LINEDEVSTATE_INSERVICE      | <br>            LINEDEVSTATE_OUTOFSERVICE   |  // Important state! <br>            LINEDEVSTATE_MAINTENANCE    |  // Important state! <br>            LINEDEVSTATE_OPEN           | <br>            LINEDEVSTATE_CLOSE          | <br>            LINEDEVSTATE_NUMCALLS       | <br>            LINEDEVSTATE_NUMCOMPLETIONS | <br>            LINEDEVSTATE_TERMINALS      | <br>            LINEDEVSTATE_ROAMMODE       | <br>            LINEDEVSTATE_BATTERY        | <br>            LINEDEVSTATE_SIGNAL         | <br>            LINEDEVSTATE_DEVSPECIFIC    | <br>            LINEDEVSTATE_REINIT         |  // Not allowed to disable this. <br>            LINEDEVSTATE_LOCK           | <br>            LINEDEVSTATE_CAPSCHANGE     | <br>            LINEDEVSTATE_CONFIGCHANGE   | <br>            LINEDEVSTATE_COMPLCANCEL    , <br> <br>            LINEADDRESSSTATE_OTHER      | <br>            LINEADDRESSSTATE_DEVSPECIFIC| <br>            LINEADDRESSSTATE_INUSEZERO  | <br>            LINEADDRESSSTATE_INUSEONE   | <br>            LINEADDRESSSTATE_INUSEMANY  | <br>            LINEADDRESSSTATE_NUMCALLS   | <br>            LINEADDRESSSTATE_FORWARD    | <br>            LINEADDRESSSTATE_TERMINALS  | <br>            LINEADDRESSSTATE_CAPSCHANGE); <br> <br> <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            // If we do get an unhandled problem, we don't care. <br>            // We just won't get notifications. <br>            OutputDebugLineError(lReturn, <br>                "lineSetStatusMessages unhandled error: "); <br>            break; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br> <br> <br>    // Get LineAddressStatus so we can make sure the line <br>    // isn't already in use by a TAPI application. <br>    lpLineAddressStatus =  <br>        I_lineGetAddressStatus(lpLineAddressStatus, g_hLine, 0); <br>         <br>    if (lpLineAddressStatus == NULL) <br>    { <br>        HangupCall(); <br>        MessageBox(g_hDlgParentWindow, <br>            "Error on Requested line", <br>            "Unable to Use Line",MB_OK); <br>        goto DeleteBuffers; <br>    } <br> <br>    // MAKECALL will be set if there are any available call appearances <br>    if ( ! ((lpLineAddressStatus -&gt; dwAddressFeatures) &amp; <br>            LINEADDRFEATURE_MAKECALL) ) </code></pre>
<p>
</p>
<pre><code>{ <br>        OutputDebugString("This line is not available to place a call.\n"); <br>        HangupCall(); <br>        MessageBox(g_hDlgParentWindow, <br>            "Requested line is already in use", <br>            "Unable to Use Line",MB_OK); <br>        goto DeleteBuffers; <br>    } <br> <br>    // If the line was configured in the 'Dial' dialog, then <br>    // we need to actually complete the configuration. <br>    if (g_lpDeviceConfig) <br>        lineSetDevConfig(g_dwDeviceID, g_lpDeviceConfig, <br>            g_dwSizeDeviceConfig, "comm/datamodem"); <br> <br>    // Start dialing the number <br>    if (DialCallInParts(lpLineDevCaps, g_szDialableAddress, <br>            g_szDisplayableAddress)) <br>    { <br>        OutputDebugString("DialCallInParts succeeded.\n"); <br>    } <br>    else <br>    { <br>        OutputDebugString("DialCallInParts failed.\n"); <br>        HangupCall(); <br>        goto DeleteBuffers; <br>    } <br> <br>DeleteBuffers: <br> <br>    if (lpLineAddressStatus) <br>        LocalFree(lpLineAddressStatus); <br>    if (lpLineDevCaps) <br>        LocalFree(lpLineDevCaps); <br>    if (g_bTapiInUse) <br>        EnableHangupCall(g_hWndMainWindow, TRUE); <br> <br>    return g_bTapiInUse; <br>} <br> <br> <br>//************************************************** <br>// These APIs are specific to this module  <br>//************************************************** <br> <br> <br> <br>// <br>//  FUNCTION: DialCallInParts(LPLINEDEVCAPS, LPCSTR, LPCSTR) <br>// <br>//  PURPOSE: Dials the call, handling special characters. <br>// <br>//  PARAMETERS: <br>//    lpLineDevCaps - LINEDEVCAPS for the line to be used. <br>//    lpszAddress   - Address to Dial. <br>//    lpszDisplayableAddress - Displayable Address. <br>// <br>//  RETURN VALUE: <br>//    Returns TRUE if we successfully Dial. <br>// <br>//  COMMENTS: <br>// <br>//    This function dials the Address and handles any <br>//    special characters in the address that the service provider <br>//    can't handle.  It requires input from the user to handle <br>//    these characters; this can cause problems for fully automated <br>//    dialing. <br>// <br>//    Note that we can return TRUE, even if we don't reach a <br>//    CONNECTED state.  DIalCallInParts returns as soon as the <br>//    Address is fully dialed or when an error occurs. <br>// <br>// <br> <br>BOOL DialCallInParts(LPLINEDEVCAPS lpLineDevCaps, <br>    LPCSTR lpszAddress, LPCSTR lpszDisplayableAddress) <br>{ <br>    LPLINECALLPARAMS  lpCallParams = NULL; <br>    LPLINEADDRESSCAPS lpAddressCaps = NULL; <br>    LPLINECALLSTATUS  lpLineCallStatus = NULL; <br> <br>    long lReturn; <br>    int i; <br>    DWORD dwDevCapFlags; <br>    char szFilter[1+sizeof(g_sNonDialable)] = ""; <br>    BOOL bFirstDial = TRUE; <br>                                <br>    // Variables to handle Dialable Substring dialing. <br>    LPSTR lpDS; // This is just so we can free lpszDialableSubstring later. <br>    LPSTR lpszDialableSubstring; <br>    int nAddressLength = 0; <br>    int nCurrentAddress = 0; <br>    char chUnhandledCharacter; <br> <br>    // Get the capabilities for the line device we're going to use. <br>    lpAddressCaps = I_lineGetAddressCaps(lpAddressCaps, <br>        g_dwDeviceID, 0, g_dwAPIVersion, 0); <br>    if (lpAddressCaps == NULL) <br>        return FALSE; <br> <br>    // Setup our CallParams for DATAMODEM settings. <br>    lpCallParams = CreateCallParams (lpCallParams, lpszDisplayableAddress); <br>    if (lpCallParams == NULL) <br>        return FALSE; <br> <br>    // Determine which special characters the service provider <br>    // does *not* handle so we can handle them manually. <br>    // Keep list of unhandled characters in szFilter. <br>     <br>    dwDevCapFlags = lpLineDevCaps -&gt; dwDevCapFlags;  // SP handled characters. <br>    for (i = 0; i &lt; g_sizeofNonDialable ; i++) <br>    { <br>        if ((dwDevCapFlags &amp; g_sNonDialable[i].dwDevCapFlag) == 0) <br>        { <br>            strcat(szFilter, g_sNonDialable[i].szToken); <br>        } <br>    } <br> <br>    // szFilter now contains the set of tokens which delimit dialable substrings <br>     <br>    // Setup the strings for substring dialing. <br>                            <br>    nAddressLength = strlen(lpszAddress); <br>    lpDS = lpszDialableSubstring = (LPSTR) LocalAlloc(LPTR, nAddressLength + 1); <br>    if (lpszDialableSubstring == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(), "LocalAlloc failed: "); <br>        HandleNoMem(); <br>        goto errExit; <br>    } <br> <br>    // Lets start dialing substrings! <br>    while (nCurrentAddress &lt; nAddressLength) <br>    { <br>  retryAfterError: <br> <br>        // Find the next undialable character <br>        i = strcspn(&amp;lpszAddress[nCurrentAddress], szFilter); <br> <br>        // Was there one before the end of the Address string? <br>        if (i + nCurrentAddress &lt; nAddressLength) <br>        { <br>            // Make sure this device can handle partial dial. <br>            if (! (lpAddressCaps -&gt; dwAddrCapFlags &amp;  <br>                   LINEADDRCAPFLAGS_PARTIALDIAL)) <br>            { <br>                MessageBox(g_hDlgParentWindow, <br>                    "This line doesn't support partial dialing.\n", <br>                    "Warning",MB_OK); <br>                goto errExit; <br>            } <br>            // Remember what the unhandled character is so we can handle it. <br>            chUnhandledCharacter = lpszAddress[nCurrentAddress+i]; <br>             <br>            // Copy the dialable string to the Substring. <br>            memcpy(lpszDialableSubstring, &amp;lpszAddress[nCurrentAddress], i); <br> <br>            // Terminate the substring with a ';' to signify the partial dial. <br>            lpszDialableSubstring[i] = ';'; <br>            lpszDialableSubstring[i+1] = '\0'; <br>             <br>            // Increment the address for next iteration. <br>            nCurrentAddress += i + 1; <br>        } <br>        else // No more partial dials.  Dial the rest of the Address. <br>        { <br>            lpszDialableSubstring = (LPSTR) &amp;lpszAddress[nCurrentAddress]; <br>            chUnhandledCharacter = 0; <br>            nCurrentAddress = nAddressLength; <br>        } <br>         <br>        do <br>        {                    <br>            if (bFirstDial) <br>                lReturn = WaitForReply(  <br>                    lineMakeCall(g_hLine, &amp;g_hCall, lpszDialableSubstring, <br>                        0, lpCallParams) ); <br>            else <br>                lReturn = WaitForReply(  <br>                    lineDial(g_hCall, lpszDialableSubstring, 0) ); <br> <br>            switch(lReturn) <br>            { <br>                // We should not have received these errors because of the <br>                // prefiltering strategy, but there may be some ill-behaved <br>                // service providers which do not correctly set their <br>                // devcapflags.  Add the character corresponding to the error <br>                // to the filter set and retry dialing. <br>                // <br>                case LINEERR_DIALBILLING: <br>                case LINEERR_DIALDIALTONE: <br>                case LINEERR_DIALQUIET: <br>                case LINEERR_DIALPROMPT: <br>                { <br>                    OutputDebugString("Service Provider incorrectly sets dwDevCapFlags\n"); <br> <br>                    for (i = 0; i &lt; g_sizeofNonDialable; i++) <br>                        if (lReturn == g_sNonDialable[i].lError) <br>                        { <br>                            strcat(szFilter, g_sNonDialable[i].szToken); <br>                        } <br> <br>                    goto retryAfterError; <br>                } <br> <br>                case WAITERR_WAITABORTED: <br>                    OutputDebugString("While Dialing, WaitForReply aborted.\n"); <br>                    goto errExit; <br>             <br>            } <br> <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                if (bFirstDial) <br>                    OutputDebugLineError(lReturn, "lineMakeCall unhandled error: "); <br>                else <br>                    OutputDebugLineError(lReturn, "lineDial unhandled error: "); <br> <br>                goto errExit; <br>            } <br> <br>        } <br>        while (lReturn != SUCCESS); <br>         <br>        bFirstDial = FALSE; <br>                                 <br>        // The dial was successful; now handle characters the service <br>        // provider didn't (if any). <br>        if (chUnhandledCharacter) <br>        { <br>            LPSTR lpMsg = ""; <br> <br>            // First, wait until we know we can continue dialing.  While the <br>            // last string is still pending to be dialed, we can't dial another. <br> <br>            while(TRUE) <br>            { <br> <br>                lpLineCallStatus = I_lineGetCallStatus(lpLineCallStatus, g_hCall); <br>                if (lpLineCallStatus == NULL) <br>                    goto errExit; <br> <br>                // Does CallStatus say we can dial now? <br>                if ((lpLineCallStatus-&gt;dwCallFeatures) &amp; LINECALLFEATURE_DIAL) <br>                { <br>                    OutputDebugString("Ok to continue dialing.\n"); <br>                    break; <br>                } <br>                 <br>                // We can't dial yet, so wait for a CALLSTATE message <br>                OutputDebugString("Waiting for dialing to be enabled.\n"); <br> <br>                if (WaitForCallState(I_LINECALLSTATE_ANY) != SUCCESS) <br>                    goto errExit; <br>            } <br> <br>            for (i = 0; i &lt; g_sizeofNonDialable; i++) <br>                if (chUnhandledCharacter == g_sNonDialable[i].szToken[0]) <br>                    lpMsg = g_sNonDialable[i].szMsg; <br>                     <br>            MessageBox(g_hDlgParentWindow, lpMsg, "Dialing Paused", MB_OK); <br>        } <br>         <br>    } // continue dialing until we dial all Dialable Substrings. <br> <br>    LocalFree(lpCallParams); <br>    LocalFree(lpDS); <br>    LocalFree(lpAddressCaps); <br>    if (lpLineCallStatus) <br>        LocalFree(lpLineCallStatus); <br>     <br>    return TRUE; <br>     <br>  errExit: <br>        // if lineMakeCall has already been successfully called, there's a call in progress.  <br>        // let the invoking routine shut down the call. <br>        // if the invoker did not clean up the call, it should be done here. <br> <br>    if (lpLineCallStatus) <br>        LocalFree(lpLineCallStatus); <br>    if (lpDS) <br>        LocalFree(lpDS); <br>    if (lpCallParams) <br>        LocalFree(lpCallParams); <br>    if (lpAddressCaps) <br>        LocalFree(lpAddressCaps); <br> <br>    return FALSE; <br>}    <br> <br> <br>// <br>//  FUNCTION: CreateCallParams(LPLINECALLPARAMS, LPCSTR) <br>// <br>//  PURPOSE: Allocates and fills a LINECALLPARAMS structure <br>// <br>//  PARAMETERS: <br>//    lpCallParams -  <br>//    lpszDisplayableAddress -  <br>// <br>//  RETURN VALUE: <br>//    Returns a LPLINECALLPARAMS ready to use for dialing DATAMODEM calls. <br>//    Returns NULL if unable to allocate the structure. <br>// <br>//  COMMENTS: <br>// <br>//    If a non-NULL lpCallParams is passed in, it must have been allocated <br>//    with LocalAlloc, and can potentially be freed and reallocated.  It must <br>//    also have the dwTotalSize field correctly set. <br>// <br>// <br> <br>LPLINECALLPARAMS CreateCallParams ( <br>    LPLINECALLPARAMS lpCallParams, LPCSTR lpszDisplayableAddress) <br>{ <br>    size_t sizeDisplayableAddress; <br> <br>    if (lpszDisplayableAddress == NULL) <br>        lpszDisplayableAddress = ""; <br>         <br>    sizeDisplayableAddress = strlen(lpszDisplayableAddress) + 1; <br>                           <br>    lpCallParams = (LPLINECALLPARAMS) CheckAndReAllocBuffer( <br>        (LPVOID) lpCallParams,  <br>        sizeof(LINECALLPARAMS) + sizeDisplayableAddress, <br>        "CreateCallParams: "); <br> <br>    if (lpCallParams == NULL) <br>        return NULL; <br>     <br>    // This is where we configure the line for DATAMODEM usage. <br>    lpCallParams -&gt; dwBearerMode = LINEBEARERMODE_VOICE; <br>    lpCallParams -&gt; dwMediaMode  = LINEMEDIAMODE_DATAMODEM; <br> <br>    // This specifies that we want to use only IDLE calls and <br>    // don't want to cut into a call that might not be IDLE (ie, in use). <br>    lpCallParams -&gt; dwCallParamFlags = LINECALLPARAMFLAGS_IDLE; <br>                                     <br>    // if there are multiple addresses on line, use first anyway. <br>    // It will take a more complex application than a simple tty app <br>    // to use multiple addresses on a line anyway. <br>    lpCallParams -&gt; dwAddressMode = LINEADDRESSMODE_ADDRESSID; <br>    lpCallParams -&gt; dwAddressID = 0; <br> <br>    // Since we don't know where we originated, leave these blank. <br>    lpCallParams -&gt; dwOrigAddressSize = 0; <br>    lpCallParams -&gt; dwOrigAddressOffset = 0; <br>     <br>    // Unimodem ignores these values. <br>    (lpCallParams -&gt; DialParams) . dwDialSpeed = 0; <br>    (lpCallParams -&gt; DialParams) . dwDigitDuration = 0; <br>    (lpCallParams -&gt; DialParams) . dwDialPause = 0; <br>    (lpCallParams -&gt; DialParams) . dwWaitForDialtone = 0; <br>     <br>    // Address we are dialing. <br>    lpCallParams -&gt; dwDisplayableAddressOffset = sizeof(LINECALLPARAMS); <br>    lpCallParams -&gt; dwDisplayableAddressSize = sizeDisplayableAddress; <br>    strcpy((LPSTR)lpCallParams + sizeof(LINECALLPARAMS), <br>           lpszDisplayableAddress); <br> <br>    return lpCallParams; <br>} <br> <br> <br>// <br>//  FUNCTION: long WaitForReply(long) <br>// <br>//  PURPOSE: Resynchronize by waiting for a LINE_REPLY  <br>// <br>//  PARAMETERS: <br>//    lRequestID - The asynchronous request ID that we're <br>//                 on a LINE_REPLY for. <br>// <br>//  RETURN VALUE: <br>//    - 0 if LINE_REPLY responded with a success. <br>//    - LINEERR constant if LINE_REPLY responded with a LINEERR <br>//    - 1 if the line was shut down before LINE_REPLY is received. <br>// <br>//  COMMENTS: <br>// <br>//    This function allows us to resynchronize an asynchronous <br>//    TAPI line call by waiting for the LINE_REPLY message.  It <br>//    waits until a LINE_REPLY is received or the line is shut down. <br>// <br>//    Note that this could cause re-entrancy problems as <br>//    well as mess with any message preprocessing that might <br>//    occur on this thread (such as TranslateAccelerator). <br>// <br>//    This function should to be called from the thread that did <br>//    lineInitialize, or the PeekMessage is on the wrong thread <br>//    and the synchronization is not guaranteed to work.  Also note <br>//    that if another PeekMessage loop is entered while waiting, <br>//    this could also cause synchronization problems. <br>// <br>//    One more note.  This function can potentially be re-entered <br>//    if the call is dropped for any reason while waiting.  If this <br>//    happens, just drop out and assume the wait has been canceled.   <br>//    This is signaled by setting bReentered to FALSE when the function  <br>//    is entered and TRUE when it is left.  If bReentered is ever TRUE  <br>//    during the function, then the function was re-entered. <br>// <br>//    This function times out and returns WAITERR_WAITTIMEDOUT <br>//    after WAITTIMEOUT milliseconds have elapsed. <br>// <br>// <br> <br> <br>long WaitForReply (long lRequestID) <br>{ <br>    static BOOL bReentered; <br>    bReentered = FALSE; <br> <br>    if (lRequestID &gt; SUCCESS) <br>    { <br>        MSG msg;  <br>        DWORD dwTimeStarted; <br> <br>        g_bReplyRecieved = FALSE; <br>        g_dwRequestedID = (DWORD) lRequestID; <br> <br>        // Initializing this just in case there is a bug <br>        // that sets g_bReplyRecieved without setting the reply value. <br>        g_lAsyncReply = LINEERR_OPERATIONFAILED; <br> <br>        dwTimeStarted = GetTickCount(); <br> <br>        while(!g_bReplyRecieved) <br>        { <br>            if (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) <br>            { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br> <br>            // This should only occur if the line is shut down while waiting. <br>            if (!g_bTapiInUse || bReentered) <br>            { <br>                bReentered = TRUE; <br>                return WAITERR_WAITABORTED; <br>            } <br> <br>            // Its a really bad idea to timeout a wait for a LINE_REPLY. <br>            // If we are execting a LINE_REPLY, we should wait till we get <br>            // it; it might take a long time to dial (for example). <br> <br>            // If 5 seconds go by without a reply, it might be a good idea <br>            // to display a dialog box to tell the user that a <br>            // wait is in progress and to give the user the capability to <br>            // abort the wait. <br>        } <br> <br>        bReentered = TRUE; <br>        return g_lAsyncReply; <br>    } <br> <br>    bReentered = TRUE; <br>    return lRequestID; <br>} <br> <br> <br>// <br>//  FUNCTION: long WaitForCallState(DWORD) <br>// <br>//  PURPOSE: Wait for the line to reach a specific CallState. <br>// <br>//  PARAMETERS: <br>//    dwDesiredCallState - specific CallState to wait for. <br>// <br>//  RETURN VALUE: <br>//    Returns 0 (SUCCESS) when we reach the Desired CallState. <br>//    Returns WAITERR_WAITTIMEDOUT if timed out. <br>//    Returns WAITERR_WAITABORTED if call was closed while waiting. <br>// <br>//  COMMENTS: <br>// <br>//    This function allows us to synchronously wait for a line <br>//    to reach a specific LINESTATE or until the line is shut down. <br>// <br>//    Note that this could cause re-entrancy problems as <br>//    well as mess with any message preprocessing that might <br>//    occur on this thread (such as TranslateAccelerator). <br>// <br>//    One more note.  This function can potentially be re-entered <br>//    if the call is dropped for any reason while waiting.  If this <br>//    happens, just drop out and assume the wait has been canceled.   <br>//    This is signaled by setting bReentered to FALSE when the function  <br>//    is entered and TRUE when it is left.  If bReentered is ever TRUE  <br>//    during the function, then the function was re-entered. <br>// <br>//    This function should to be called from the thread that did <br>//    lineInitialize, or the PeekMessage is on the wrong thread <br>//    and the synchronization is not guaranteed to work.  Also note <br>//    that if another PeekMessage loop is entered while waiting, <br>//    this could also cause synchronization problems. <br>// <br>//    If the constant value I_LINECALLSTATE_ANY is used for the  <br>//    dwDesiredCallState, then WaitForCallState will return SUCCESS <br>//    upon receiving any CALLSTATE messages. <br>//     <br>// <br>// <br> <br>long WaitForCallState(DWORD dwDesiredCallState) <br>{ <br>    MSG msg; <br>    DWORD dwTimeStarted; <br>    static BOOL bReentered; <br> <br>    bReentered = FALSE; <br> <br>    dwTimeStarted = GetTickCount(); <br> <br>    g_bCallStateReceived = FALSE; <br> <br>    while ((dwDesiredCallState == I_LINECALLSTATE_ANY) ||  <br>           (g_dwCallState != dwDesiredCallState)) <br>    { <br>        if (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br> <br>        // If we are waiting for any call state and get one, succeed. <br>        if ((dwDesiredCallState == I_LINECALLSTATE_ANY) &amp;&amp;  <br>            g_bCallStateReceived) <br>        { <br>            break; <br>        } <br> <br>        // This should only occur if the line is shut down while waiting. <br>        if (!g_bTapiInUse || bReentered) <br>        { <br>            bReentered = TRUE; <br>            OutputDebugString("WAITABORTED\n"); <br>            return WAITERR_WAITABORTED; <br>        } <br> <br>        // If we don't get the reply in a reasonable time, we time out. <br>        if (GetTickCount() - dwTimeStarted &gt; WAITTIMEOUT) <br>        { <br>            bReentered = TRUE; <br>            OutputDebugString("WAITTIMEDOUT\n"); <br>            return WAITERR_WAITTIMEDOUT; <br>        } <br> <br>    } <br> <br>    bReentered = TRUE; <br>    return SUCCESS; <br>} <br> <br>//************************************************** <br>// lineCallback Function and Handlers. <br>//************************************************** <br> <br> <br>// <br>//  FUNCTION: lineCallbackFunc(..) <br>// <br>//  PURPOSE: Receive asynchronous TAPI events <br>// <br>//  PARAMETERS: <br>//    dwDevice  - Device associated with the event, if any <br>//    dwMsg     - TAPI event that occurred. <br>//    dwCallbackInstance - User defined data supplied when opening the line. <br>//    dwParam1  - dwMsg specific information <br>//    dwParam2  - dwMsg specific information <br>//    dwParam3  - dwMsg specific information <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    This is the function where all asynchronous events will come. <br>//    Almost all events will be specific to an open line, but a few <br>//    will be general TAPI events (such as LINE_REINIT). <br>// <br>//    Its important to note that this callback will *ALWAYS* be <br>//    called in the context of the thread that does the lineInitialize. <br>//    Even if another thread (such as the COMM threads) calls the API <br>//    that would result in the callback being called, it will be called <br>//    in the context of the main thread (since in this sample, the main <br>//    thread does the lineInitialize). <br>// <br>// <br> <br> <br>void CALLBACK lineCallbackFunc( <br>    DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance,  <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br> <br>    OutputDebugLineCallback( <br>        dwDevice, dwMsg, dwCallbackInstance,  <br>        dwParam1, dwParam2, dwParam3); <br> <br>    // All we do is dispatch the dwMsg to the correct handler. <br>    switch(dwMsg) <br>    { <br>        case LINE_CALLSTATE: <br>            DoLineCallState(dwDevice, dwMsg, dwCallbackInstance, <br>                dwParam1, dwParam2, dwParam3); <br>            break; <br> <br>        case LINE_CLOSE: <br>            DoLineClose(dwDevice, dwMsg, dwCallbackInstance, <br>                dwParam1, dwParam2, dwParam3); <br>            break; <br> <br>        case LINE_LINEDEVSTATE: <br>            DoLineDevState(dwDevice, dwMsg, dwCallbackInstance, <br>                dwParam1, dwParam2, dwParam3); <br>            break; <br> <br>        case LINE_REPLY: <br>            DoLineReply(dwDevice, dwMsg, dwCallbackInstance, <br>                dwParam1, dwParam2, dwParam3); <br>            break; <br> <br>        case LINE_CREATE: <br>            DoLineCreate(dwDevice, dwMsg, dwCallbackInstance, <br>                dwParam1, dwParam2, dwParam3); <br>            break; <br> <br>        default: <br>            OutputDebugString("lineCallbackFunc message ignored\n"); <br>            break; <br> <br>    } <br> <br>    return; <br> <br>} <br> <br> <br>// <br>//  FUNCTION: DoLineReply(..) <br>// <br>//  PURPOSE: Handle LINE_REPLY asynchronous messages. <br>// <br>//  PARAMETERS: <br>//    dwDevice  - Line Handle associated with this LINE_REPLY. <br>//    dwMsg     - Should always be LINE_REPLY. <br>//    dwCallbackInstance - Unused by this sample. <br>//    dwParam1  - Asynchronous request ID. <br>//    dwParam2  - success or LINEERR error value. <br>//    dwParam3  - Unused. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    All line API calls that return an asynchronous request ID <br>//    will eventually cause a LINE_REPLY message.  Handle it. <br>// <br>//    This sample assumes only one call at time, and that we wait <br>//    for a LINE_REPLY before making any other line API calls. <br>// <br>//    The only exception to the above is that we might shut down <br>//    the line before receiving a LINE_REPLY. <br>// <br>// <br> <br>void DoLineReply( <br>    DWORD dwDevice, DWORD dwMessage, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br>    if ((long) dwParam2 != SUCCESS) <br>        OutputDebugLineError((long) dwParam2, "LINE_REPLY error: "); <br>    else <br>        OutputDebugString("LINE_REPLY: successfully replied.\n"); <br> <br>    // If we are currently waiting for this async Request ID <br>    // then set the global variables to acknowledge it. <br>    if (g_dwRequestedID == dwParam1) <br>    { <br>        g_bReplyRecieved = TRUE; <br>        g_lAsyncReply = (long) dwParam2; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: DoLineClose(..) <br>// <br>//  PURPOSE: Handle LINE_CLOSE asynchronous messages. <br>// <br>//  PARAMETERS: <br>//    dwDevice  - Line Handle that was closed. <br>//    dwMsg     - Should always be LINE_CLOSE. <br>//    dwCallbackInstance - Unused by this sample. <br>//    dwParam1  - Unused. <br>//    dwParam2  - Unused. <br>//    dwParam3  - Unused. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    This message is sent when something outside our app shuts <br>//    down a line in use. <br>// <br>//    The hLine (and any hCall on this line) are no longer valid. <br>// <br>// <br> <br>void DoLineClose( <br>    DWORD dwDevice, DWORD dwMessage, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br>    // Line has been shut down.  Clean up our internal variables. <br>    g_hLine = NULL; <br>    g_hCall = NULL; <br>    UpdateStatusBar("Call was shut down.",1,0); <br>    MessageBox(g_hDlgParentWindow, <br>        "Call was shut down.","Warning",MB_OK); <br>    HangupCall(); <br>} <br> <br> <br>// <br>//  FUNCTION: DoLineDevState(..) <br>// <br>//  PURPOSE: Handle LINE_LINEDEVSTATE asynchronous messages. <br>// <br>//  PARAMETERS: <br>//    dwDevice  - Line Handle that was closed. <br>//    dwMsg     - Should always be LINE_LINEDEVSTATE. <br>//    dwCallbackInstance - Unused by this sample. <br>//    dwParam1  - LINEDEVSTATE constant. <br>//    dwParam2  - Depends on dwParam1. <br>//    dwParam3  - Depends on dwParam1. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    The LINE_LINEDEVSTATE message is received if the state of the line <br>//    changes.  Examples are RINGING, MAINTENANCE, MSGWAITON.  Very few of <br>//    these are relevant to this sample. <br>// <br>//    Assuming that any LINEDEVSTATE that removes the line from use by TAPI <br>//    will also send a LINE_CLOSE message. <br>// <br>// <br> <br>void DoLineDevState( <br>    DWORD dwDevice, DWORD dwMessage, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br>    switch(dwParam1) <br>    { <br>        case LINEDEVSTATE_RINGING: <br>            UpdateStatusBar("Line Ringing",1,0); <br>            OutputDebugString("Line Ringing.\n"); <br>            break; <br> <br>        case LINEDEVSTATE_REINIT: <br>        // This is an important case!  Usually means that a service provider <br>        // has changed in such a way that requires TAPI to REINIT.   <br>        // Note that there are both 'soft' REINITs and 'hard' REINITs. <br>        // Soft REINITs don't actually require a full shutdown but is instead <br>        // just an informational change that historically required a REINIT <br>        // to force the application to deal with.  TAPI API Version 1.3 apps <br>        // will still need to do a full REINIT for both hard and soft REINITs. <br> <br>            switch(dwParam2) <br>            { <br>                // This is the hard REINIT.  No reason given, just REINIT. <br>                // TAPI is waiting for everyone to shutdown. <br>                // Our response is to immediately shutdown any calls, <br>                // shutdown our use of TAPI and notify the user. <br>                case 0: <br>                    ShutdownTAPI(); <br>                    WarningBox("Tapi line configuration has changed."); <br>                    break; <br> <br>                case LINE_CREATE: <br>                    OutputDebugString("Soft REINIT: LINE_CREATE.\n"); <br>                    DoLineCreate(dwDevice, dwParam2, dwCallbackInstance, <br>                        dwParam3, 0, 0); <br>                    break; <br> <br>                case LINE_LINEDEVSTATE: <br>                    OutputDebugString("Soft REINIT: LINE_LINEDEVSTATE.\n"); <br>                    DoLineDevState(dwDevice, dwParam2, dwCallbackInstance, <br>                        dwParam3, 0, 0); <br>                    break; <br> <br>                // There might be other reasons to send a soft reinit. <br>                // No need to to shutdown for these. <br>                default: <br>                    OutputDebugString("Ignoring soft REINIT\n"); <br>                    break; <br>            } <br>            break; <br> <br>        case LINEDEVSTATE_OUTOFSERVICE: <br>            WarningBox("Line selected is now Out of Service."); <br>            HangupCall(); <br>            break; <br> <br>        case LINEDEVSTATE_DISCONNECTED: <br>            WarningBox("Line selected is now disconnected."); <br>            HangupCall(); <br>            break; <br> <br>        case LINEDEVSTATE_MAINTENANCE: <br>            WarningBox("Line selected is now out for maintenance."); <br>            HangupCall(); <br>            break; <br> <br>        case LINEDEVSTATE_TRANSLATECHANGE: <br>            if (g_hDialog) <br>                PostMessage(g_hDialog, WM_COMMAND, IDC_CONFIGURATIONCHANGED, 0); <br>            break; <br> <br>        case LINEDEVSTATE_REMOVED: <br>            OutputDebugString("A Line device has been removed;" <br>                " no action taken.\n"); <br>            break; <br> <br>        default: <br>            OutputDebugString("Unhandled LINEDEVSTATE message\n"); <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: DoLineCreate(..) <br>// <br>//  PURPOSE: Handle LINE_LINECREATE asynchronous messages. <br>// <br>//  PARAMETERS: <br>//    dwDevice  - Unused. <br>//    dwMsg     - Should always be LINE_CREATE. <br>//    dwCallbackInstance - Unused. <br>//    dwParam1  - dwDeviceID of new Line created. <br>//    dwParam2  - Unused. <br>//    dwParam3  - Unused. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    This message is new for Windows 95.  It is sent when a new line is <br>//    added to the system.  This allows us to handle new lines without having <br>//    to REINIT.  This allows for much more graceful Plug and Play. <br>// <br>//    This sample just changes the number of devices available and can use <br>//    it next time a call is made.  It also tells the "Dial" dialog. <br>// <br>// <br> <br>void DoLineCreate( <br>    DWORD dwDevice, DWORD dwMessage, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br>    // dwParam1 is the Device ID of the new line.   <br>    // Add one to get the number of total devices. <br>    if (g_dwNumDevs &lt;= dwParam1) <br>        g_dwNumDevs = dwParam1+1; <br>    if (g_hDialog) <br>        PostMessage(g_hDialog, WM_COMMAND, IDC_LINECREATE, 0); <br> <br>} <br> <br> <br>// <br>//  FUNCTION: DoLineCallState(..) <br>// <br>//  PURPOSE: Handle LINE_CALLSTATE asynchronous messages. <br>// <br>//  PARAMETERS: <br>//    dwDevice  - Handle to Call who's state is changing. <br>//    dwMsg     - Should always be LINE_CALLSTATE. <br>//    dwCallbackInstance - Unused by this sample. <br>//    dwParam1  - LINECALLSTATE constant specifying state change. </code></pre>
<p>
</p>
<pre><code>//    dwParam2  - Specific to dwParam1. <br>//    dwParam3  - LINECALLPRIVILEGE change, if any. <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    This message is received whenever a call changes state.  Lots of <br>//    things we do, ranging from notifying the user to closing the line <br>//    to actually connecting to the target of our phone call. <br>// <br>//    What we do is usually obvious based on the call state change. <br>// <br> <br>void DoLineCallState( <br>    DWORD dwDevice, DWORD dwMessage, DWORD dwCallbackInstance, <br>    DWORD dwParam1, DWORD dwParam2, DWORD dwParam3) <br>{ <br> <br>    // Error if this CALLSTATE doesn't apply to our call in progress. <br>    if ((HCALL) dwDevice != g_hCall) <br>    { <br>        OutputDebugPrintf("LINE_CALLSTATE: Unknown device ID '0x%lx'.", <br>            dwDevice); <br>        return; <br>    } <br> <br>    // This sets the global g_dwCallState variable so if we are waiting <br>    // for a specific call state change, we will know when it happens. <br>    g_dwCallState = dwParam1; <br>    g_bCallStateReceived = TRUE; <br> <br>    // dwParam3 contains changes to LINECALLPRIVILEGE, if there are any. <br>    switch (dwParam3) <br>    { <br>        case 0: <br>            break; // no change to call state <br> <br>         // close line if we are made monitor.  Shouldn't happen! <br>         case LINECALLPRIVILEGE_MONITOR: <br>            OutputDebugString("line given monitor privilege; closing\n"); <br>            HangupCall(); <br>            return; <br> <br>         // close line if we are made owner.  Shouldn't happen! <br>        case LINECALLPRIVILEGE_OWNER: <br>            OutputDebugString("line given owner privilege; closing\n"); <br>            HangupCall(); <br>            break; <br> <br>        default: // Shouldn't happen!  All cases handled. <br>            OutputDebugString("Unknown LINECALLPRIVILEGE message: closing\n"); <br>            HangupCall(); <br>            return; <br>    } <br> <br>    // dwParam1 is the specific CALLSTATE change that is occurring. <br>    switch (dwParam1) <br>    { <br>        case LINECALLSTATE_DIALTONE: <br>            UpdateStatusBar("Dial Tone",1,0); <br>            OutputDebugString("Dial Tone\n"); <br>            break; <br> <br>        case LINECALLSTATE_DIALING: <br>            UpdateStatusBar("Dialing Call",1,0); <br>            OutputDebugString("Dialing\n"); <br>            break; <br> <br>        case LINECALLSTATE_PROCEEDING: <br>            UpdateStatusBar("Call is Proceeding",1,0); <br>            OutputDebugString("Proceeding\n"); <br>            break; <br> <br>        case LINECALLSTATE_RINGBACK: <br>            UpdateStatusBar("RingBack",1,0); <br>            OutputDebugString("RingBack\n"); <br>            break; <br> <br>        case LINECALLSTATE_BUSY: <br>            UpdateStatusBar("Line is busy",1,0); <br>            OutputDebugString("Line busy, shutting down\n"); <br>            HangupCall(); <br>            break; <br> <br>        case LINECALLSTATE_IDLE: <br>            UpdateStatusBar("Line is idle",1,0); <br>            OutputDebugString("Line idle\n"); <br>            HangupCall(); <br>            break; <br> <br>        case LINECALLSTATE_SPECIALINFO: <br>            UpdateStatusBar( <br>                "Special Info, probably couldn't dial number",1,0); <br>            OutputDebugString( <br>                "Special Info, probably couldn't dial number\n"); <br>            HangupCall(); <br>            break; <br> <br>        case LINECALLSTATE_DISCONNECTED: <br>        { <br>            LPSTR pszReasonDisconnected; <br> <br>            switch (dwParam2) <br>            { <br>                case LINEDISCONNECTMODE_NORMAL: <br>                    pszReasonDisconnected = "Remote Party Disconnected"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_UNKNOWN: <br>                    pszReasonDisconnected = "Disconnected: Unknown reason"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_REJECT: <br>                    pszReasonDisconnected = "Remote Party rejected call"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_PICKUP: <br>                    pszReasonDisconnected =  <br>                        "Disconnected: Local phone picked up"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_FORWARDED: <br>                    pszReasonDisconnected = "Disconnected: Forwarded"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_BUSY: <br>                    pszReasonDisconnected = "Disconnected: Busy"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_NOANSWER: <br>                    pszReasonDisconnected = "Disconnected: No Answer"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_BADADDRESS: <br>                    pszReasonDisconnected = "Disconnected: Bad Address"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_UNREACHABLE: <br>                    pszReasonDisconnected = "Disconnected: Unreachable"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_CONGESTION: <br>                    pszReasonDisconnected = "Disconnected: Congestion"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_INCOMPATIBLE: <br>                    pszReasonDisconnected = "Disconnected: Incompatible"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_UNAVAIL: <br>                    pszReasonDisconnected = "Disconnected: Unavail"; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_NODIALTONE: <br>                    pszReasonDisconnected = "Disconnected: No Dial Tone"; <br>                    break; <br> <br>                default: <br>                    pszReasonDisconnected =  <br>                        "Disconnected: LINECALLSTATE; Bad Reason"; <br>                    break; <br> <br>            } <br> <br>            UpdateStatusBar(pszReasonDisconnected,1,0); <br>            OutputDebugString(pszReasonDisconnected); <br>            OutputDebugString("\n"); <br>            HangupCall(); <br>            break; <br>        } <br> <br>         <br>        case LINECALLSTATE_CONNECTED:  // CONNECTED!!! <br>        { <br>            LPVARSTRING lpVarString = NULL; <br>            DWORD dwSizeofVarString = sizeof(VARSTRING) + 1024; <br>            HANDLE hCommFile = NULL; <br>            long lReturn; <br> <br>            // Very first, make sure this isn't a duplicated message. <br>            // A CALLSTATE message can be sent whenever there is a <br>            // change to the capabilities of a line, meaning that it is <br>            // possible to receive multiple CONNECTED messages per call. <br>            // The CONNECTED CALLSTATE message is the only one in TapiComm <br>            // where it would cause problems if it where sent more <br>            // than once. <br> <br>            if (g_bConnected) <br>                break; <br> <br>            g_bConnected = TRUE; <br> <br>            // Get the handle to the comm port from the driver so we can start <br>            // communicating.  This is returned in a LPVARSTRING structure. <br>            do <br>            { <br>                // Allocate the VARSTRING structure <br>                lpVarString = CheckAndReAllocBuffer((LPVOID) lpVarString, <br>                    dwSizeofVarString,"lineGetID: "); <br> <br>                if (lpVarString == NULL) <br>                    goto ErrorConnecting; <br> <br>                // Fill the VARSTRING structure <br>                lReturn = lineGetID(0, 0, g_hCall, LINECALLSELECT_CALL, <br>                    lpVarString, "comm/datamodem"); <br> <br>                if (HandleLineErr(lReturn)) <br>                    ; // Still need to check if structure was big enough. <br>                else <br>                { <br>                    OutputDebugLineError(lReturn,  <br>                        "lineGetID unhandled error: "); <br>                    goto ErrorConnecting; <br>                } <br> <br>                // If the VARSTRING wasn't big enough, loop again. <br>                if ((lpVarString -&gt; dwNeededSize) &gt; (lpVarString -&gt; dwTotalSize)) <br>                { <br>                    dwSizeofVarString = lpVarString -&gt; dwNeededSize; <br>                    lReturn = -1; // Lets loop again. <br>                } <br>            } <br>            while(lReturn != SUCCESS); <br> <br>            OutputDebugString("Connected!  Starting communications!\n"); <br> <br>            // Again, the handle to the comm port is contained in a <br>            // LPVARSTRING structure.  Thus, the handle is the very first <br>            // thing after the end of the structure.  Note that the name of <br>            // the comm port is right after the handle, but I don't want it. <br>            hCommFile =  <br>                *((LPHANDLE)((LPBYTE)lpVarString + <br>                    lpVarString -&gt; dwStringOffset)); <br> <br>            // Started communications! <br>            if (StartComm(hCommFile)) <br>            { <br>                char szBuff[300]; <br> <br>                wsprintf(szBuff,"Connected to '%s'",g_szDisplayableAddress); <br>                UpdateStatusBar(szBuff, 1, 0); <br> <br>                LocalFree(lpVarString); <br>                break; <br>            } <br> <br>            // Couldn't start communications.  Clean up instead. <br>          ErrorConnecting: <br> <br>            // Its very important that we close all Win32 handles. <br>            // The CommCode module is responsible for closing the hCommFile <br>            // handle if it succeeds in starting communications. <br>            if (hCommFile) <br>                CloseHandle(hCommFile); <br> <br>            HangupCall(); <br>            { <br>                char szBuff[300]; <br>                wsprintf(szBuff,"Failed to Connect to '%s'", <br>                    g_szDisplayableAddress); <br>                UpdateStatusBar(szBuff, 1, 0); <br>            } <br> <br>            if (lpVarString) <br>                LocalFree(lpVarString); <br> <br>            break; <br>        } <br> <br>        default: <br>            OutputDebugString("Unhandled LINECALLSTATE message\n"); <br>            break; <br>    } <br>} <br> <br>//************************************************** <br>// line API Wrapper Functions. <br>//************************************************** <br> <br> <br>// <br>//  FUNCTION: LPVOID CheckAndReAllocBuffer(LPVOID, size_t, LPCSTR) <br>// <br>//  PURPOSE: Checks and ReAllocates a buffer if necessary. <br>// <br>//  PARAMETERS: <br>//    lpBuffer          - Pointer to buffer to be checked.  Can be NULL. <br>//    sizeBufferMinimum - Minimum size that lpBuffer should be. <br>//    szApiPhrase       - Phrase to print if an error occurs. <br>// <br>//  RETURN VALUE: <br>//    Returns a pointer to a valid buffer that is guarenteed to be <br>//    at least sizeBufferMinimum size. <br>//    Returns NULL if an error occured. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a helper function intended to make all of the  <br>//    line API Wrapper Functions much simplier.  It allocates (or <br>//    reallocates) a buffer of the requested size. <br>// <br>//    The returned pointer has been allocated with LocalAlloc, <br>//    so LocalFree has to be called on it when you're finished with it, <br>//    or there will be a memory leak. <br>// <br>//    Similarly, if a pointer is passed in, it *must* have been allocated <br>//    with LocalAlloc and it could potentially be LocalFree()d. <br>// <br>//    If lpBuffer == NULL, then a new buffer is allocated.  It is <br>//    normal to pass in NULL for this parameter the first time and only <br>//    pass in a pointer if the buffer needs to be reallocated. <br>// <br>//    szApiPhrase is used only for debugging purposes. <br>// <br>//    It is assumed that the buffer returned from this function will be used <br>//    to contain a variable sized structure.  Thus, the dwTotalSize field <br>//    is always filled in before returning the pointer. <br>// <br>// <br> <br>LPVOID CheckAndReAllocBuffer( <br>    LPVOID lpBuffer, size_t sizeBufferMinimum, LPCSTR szApiPhrase) <br>{ <br>    size_t sizeBuffer; <br> <br>    if (lpBuffer == NULL)  // Allocate the buffer if necessary.  <br>    { <br>        sizeBuffer = sizeBufferMinimum; <br>        lpBuffer = (LPVOID) LocalAlloc(LPTR, sizeBuffer); <br>             <br>        if (lpBuffer == NULL) <br>        { <br>            OutputDebugString(szApiPhrase); <br>            OutputDebugLastError(GetLastError(),"LocalAlloc : "); <br>            HandleNoMem(); <br>            return NULL; <br>        } <br>    } <br>    else // If the structure already exists, make sure its good. <br>    { <br>        sizeBuffer = LocalSize((HLOCAL) lpBuffer); <br> <br>        if (sizeBuffer == 0) // Bad pointer? <br>        { <br>            OutputDebugString(szApiPhrase); <br>            OutputDebugLastError(GetLastError(),"LocalSize : "); <br>            return NULL; <br>        } <br> <br>        // Was the buffer big enough for the structure? <br>        if (sizeBuffer &lt; sizeBufferMinimum) <br>        { <br>            OutputDebugString(szApiPhrase); <br>            OutputDebugString("Reallocating structure\n"); <br>            LocalFree(lpBuffer); <br>            return CheckAndReAllocBuffer(NULL, sizeBufferMinimum, szApiPhrase); <br>        } <br> <br>        // Lets zero the buffer out. <br>        memset(lpBuffer, 0, sizeBuffer); <br>    } <br>                 <br>    ((LPVARSTRING) lpBuffer ) -&gt; dwTotalSize = (DWORD) sizeBuffer; <br>    return lpBuffer; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: DWORD I_lineNegotiateAPIVersion(DWORD) <br>// <br>//  PURPOSE: Negotiate an API Version to use for a specific device. <br>// <br>//  PARAMETERS: <br>//    dwDeviceID - device to negotiate an API Version for. <br>// <br>//  RETURN VALUE: <br>//    Returns the API Version to use for this line if successful. <br>//    Returns 0 if negotiations fall through. <br>// <br>//  COMMENTS: <br>// <br>//    This wrapper function not only negotiates the API, but handles <br>//    LINEERR errors that can occur while negotiating. <br>// <br>// <br> <br>DWORD I_lineNegotiateAPIVersion(DWORD dwDeviceID) <br>{ <br>    LINEEXTENSIONID LineExtensionID; <br>    long lReturn; <br>    DWORD dwLocalAPIVersion; <br>     <br>    do <br>    { <br>        lReturn = lineNegotiateAPIVersion(g_hLineApp, dwDeviceID,  <br>            SAMPLE_TAPI_VERSION, SAMPLE_TAPI_VERSION, <br>            &amp;dwLocalAPIVersion, &amp;LineExtensionID); <br> <br>        if (lReturn == LINEERR_INCOMPATIBLEAPIVERSION) <br>        { <br>            OutputDebugString( <br>                "lineNegotiateAPIVersion, INCOMPATIBLEAPIVERSION.\n"); <br>            return 0; <br>        } <br> <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            OutputDebugLineError(lReturn,  <br>                "lineNegotiateAPIVersion unhandled error: "); <br>            return 0; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br>         <br>    return dwLocalAPIVersion; <br>} <br> <br> <br>// <br>//  FUNCTION: I_lineGetDevCaps(LPLINEDEVCAPS, DWORD , DWORD) <br>// <br>//  PURPOSE: Retrieve a LINEDEVCAPS structure for the specified line. <br>// <br>//  PARAMETERS: <br>//    lpLineDevCaps - Pointer to a LINEDEVCAPS structure to use. <br>//    dwDeviceID    - device to get the DevCaps for. <br>//    dwAPIVersion  - API Version to use while getting DevCaps. <br>// <br>//  RETURN VALUE: <br>//    Returns a pointer to a LINEDEVCAPS structure if successful. <br>//    Returns NULL if unsuccessful. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a wrapper around lineGetDevCaps to make it easy <br>//    to handle the variable sized structure and any errors received. <br>//     <br>//    The returned structure has been allocated with LocalAlloc, <br>//    so LocalFree has to be called on it when you're finished with it, <br>//    or there will be a memory leak. <br>// <br>//    Similarly, if a lpLineDevCaps structure is passed in, it *must* <br>//    have been allocated with LocalAlloc and it could potentially be  <br>//    LocalFree()d. <br>// <br>//    If lpLineDevCaps == NULL, then a new structure is allocated.  It is <br>//    normal to pass in NULL for this parameter unless you want to use a  <br>//    lpLineDevCaps that has been returned by a previous I_lineGetDevCaps <br>//    call. <br>// <br>// <br> <br>LPLINEDEVCAPS I_lineGetDevCaps( <br>    LPLINEDEVCAPS lpLineDevCaps, <br>    DWORD dwDeviceID, DWORD dwAPIVersion) <br>{ <br>    size_t sizeofLineDevCaps = sizeof(LINEDEVCAPS) + 1024; <br>    long lReturn; <br>     <br>    // Continue this loop until the structure is big enough. <br>    while(TRUE) <br>    { <br>        // Make sure the buffer exists, is valid and big enough. <br>        lpLineDevCaps =  <br>            (LPLINEDEVCAPS) CheckAndReAllocBuffer( <br>                (LPVOID) lpLineDevCaps, // Pointer to existing buffer, if any <br>                sizeofLineDevCaps,      // Minimum size the buffer should be <br>                "lineGetDevCaps");      // Phrase to tag errors, if any. <br> <br>        if (lpLineDevCaps == NULL) <br>            return NULL; <br> <br>        // Make the call to fill the structure. <br>        do <br>        {             <br>            lReturn =  <br>                lineGetDevCaps(g_hLineApp,  <br>                    dwDeviceID, dwAPIVersion, 0, lpLineDevCaps); <br> <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                OutputDebugLineError(lReturn,  <br>                    "lineGetDevCaps unhandled error: "); <br>                LocalFree(lpLineDevCaps); <br>                return NULL; <br>            } <br>        } <br>        while (lReturn != SUCCESS); <br> <br>        // If the buffer was big enough, then succeed. <br>        if ((lpLineDevCaps -&gt; dwNeededSize) &lt;= (lpLineDevCaps -&gt; dwTotalSize)) <br>            return lpLineDevCaps; <br> <br>        // Buffer wasn't big enough.  Make it bigger and try again. <br>        sizeofLineDevCaps = lpLineDevCaps -&gt; dwNeededSize; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: I_lineGetAddressStatus(LPLINEADDRESSSTATUS, HLINE, DWORD) <br>// <br>//  PURPOSE: Retrieve a LINEADDRESSSTATUS structure for the specified line. <br> <br> <br>// <br>//  PARAMETERS: <br>//    lpLineAddressStatus - Pointer to a LINEADDRESSSTATUS structure to use. <br>//    hLine       - Handle of line to get the AddressStatus of. <br>//    dwAddressID - Address ID on the hLine to be used. <br>// <br>//  RETURN VALUE: <br>//    Returns a pointer to a LINEADDRESSSTATUS structure if successful. <br>//    Returns NULL if unsuccessful. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a wrapper around lineGetAddressStatus to make it easy <br>//    to handle the variable sized structure and any errors received. <br>// <br>//    The returned structure has been allocated with LocalAlloc, <br>//    so LocalFree has to be called on it when you're finished with it, <br>//    or there will be a memory leak. <br>// <br>//    Similarly, if a lpLineAddressStatus structure is passed in, it *must* <br>//    have been allocated with LocalAlloc and it could potentially be  <br>//    LocalFree()d. <br>// <br>//    If lpLineAddressStatus == NULL, then a new structure is allocated.  It <br>//    is normal to pass in NULL for this parameter unless you want to use a <br>//    lpLineAddressStatus that has been returned by previous <br>//    I_lineGetAddressStatus call. <br>// <br>// <br> <br>LPLINEADDRESSSTATUS I_lineGetAddressStatus( <br>    LPLINEADDRESSSTATUS lpLineAddressStatus, <br>    HLINE hLine, DWORD dwAddressID) <br>{ <br>    size_t sizeofLineAddressStatus = sizeof(LINEADDRESSSTATUS) + 1024; <br>    long lReturn; <br>     <br>    // Continue this loop until the structure is big enough. <br>    while(TRUE) <br>    { <br>        // Make sure the buffer exists, is valid and big enough. <br>        lpLineAddressStatus =  <br>            (LPLINEADDRESSSTATUS) CheckAndReAllocBuffer( <br>                (LPVOID) lpLineAddressStatus, <br>                sizeofLineAddressStatus,      <br>                "lineGetAddressStatus");      <br> <br>        if (lpLineAddressStatus == NULL) <br>            return NULL; <br> <br>        // Make the call to fill the structure. <br>        do <br>        {             <br>            lReturn =  <br>                lineGetAddressStatus(hLine, dwAddressID, lpLineAddressStatus); <br> <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                OutputDebugLineError(lReturn,  <br>                    "lineGetAddressStatus unhandled error: "); <br>                LocalFree(lpLineAddressStatus); <br>                return NULL; <br>            } <br>        } <br>        while (lReturn != SUCCESS); <br> <br>        // If the buffer was big enough, then succeed. <br>        if ((lpLineAddressStatus -&gt; dwNeededSize) &lt;=  <br>            (lpLineAddressStatus -&gt; dwTotalSize)) <br>        { <br>            return lpLineAddressStatus; <br>        } <br>         <br>        // Buffer wasn't big enough.  Make it bigger and try again. <br>        sizeofLineAddressStatus = lpLineAddressStatus -&gt; dwNeededSize; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: I_lineGetCallStatus(LPLINECALLSTATUS, HCALL) <br>// <br>//  PURPOSE: Retrieve a LINECALLSTATUS structure for the specified line. <br>// <br>//  PARAMETERS: <br>//    lpLineCallStatus - Pointer to a LINECALLSTATUS structure to use. <br>//    hCall - Handle of call to get the CallStatus of. <br>// <br>//  RETURN VALUE: <br>//    Returns a pointer to a LINECALLSTATUS structure if successful. <br>//    Returns NULL if unsuccessful. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a wrapper around lineGetCallStatus to make it easy <br>//    to handle the variable sized structure and any errors received. <br>// <br>//    The returned structure has been allocated with LocalAlloc, <br>//    so LocalFree has to be called on it when you're finished with it, <br>//    or there will be a memory leak. <br>// <br>//    Similarly, if a lpLineCallStatus structure is passed in, it *must* <br>//    have been allocated with LocalAlloc and it could potentially be  <br>//    LocalFree()d. <br>// <br>//    If lpLineCallStatus == NULL, then a new structure is allocated.  It <br>//    is normal to pass in NULL for this parameter unless you want to use a <br>//    lpLineCallStatus that has been returned by previous I_lineGetCallStatus <br>//    call. <br>// <br>// <br> <br>LPLINECALLSTATUS I_lineGetCallStatus( <br>    LPLINECALLSTATUS lpLineCallStatus, <br>    HCALL hCall) <br>{ <br>    size_t sizeofLineCallStatus = sizeof(LINECALLSTATUS) + 1024; <br>    long lReturn; <br>     <br>    // Continue this loop until the structure is big enough. <br>    while(TRUE) <br>    { <br>        // Make sure the buffer exists, is valid and big enough. <br>        lpLineCallStatus =  <br>            (LPLINECALLSTATUS) CheckAndReAllocBuffer( <br>                (LPVOID) lpLineCallStatus, <br>                sizeofLineCallStatus,      <br>                "lineGetCallStatus");      <br> <br>        if (lpLineCallStatus == NULL) <br>            return NULL; <br>             <br>        // Make the call to fill the structure. <br>        do <br>        { <br>            lReturn =  <br>                lineGetCallStatus(hCall, lpLineCallStatus); <br> <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                OutputDebugLineError(lReturn,  <br>                    "lineGetCallStatus unhandled error: "); <br>                LocalFree(lpLineCallStatus); <br>                return NULL; <br>            } <br>        } <br>        while (lReturn != SUCCESS); <br> <br>        // If the buffer was big enough, then succeed. <br>        if ((lpLineCallStatus -&gt; dwNeededSize) &lt;=  <br>            (lpLineCallStatus -&gt; dwTotalSize)) <br>        { <br>            return lpLineCallStatus; <br>        } <br> <br>        // Buffer wasn't big enough.  Make it bigger and try again. <br>        sizeofLineCallStatus = lpLineCallStatus -&gt; dwNeededSize; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: I_lineTranslateAddress <br>//              (LPLINETRANSLATEOUTPUT, DWORD, DWORD, LPCSTR) <br>// <br>//  PURPOSE: Retrieve a LINECALLSTATUS structure for the specified line. <br>// <br>//  PARAMETERS: <br>//    lpLineTranslateOutput - Pointer to a LINETRANSLATEOUTPUT structure. <br>//    dwDeviceID      - Device that we're translating for. <br>//    dwAPIVersion    - API Version to use. <br>//    lpszDialAddress - pointer to the DialAddress string to translate. <br>// <br>//  RETURN VALUE: <br>//    Returns a pointer to a LINETRANSLATEOUTPUT structure if successful. <br>//    Returns NULL if unsuccessful. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a wrapper around lineGetTranslateOutput to make it <br>//    easy to handle the variable sized structure and any errors received. <br>// <br>//    The returned structure has been allocated with LocalAlloc, <br>//    so LocalFree has to be called on it when you're finished with it, <br>//    or there will be a memory leak. <br>// <br>//    Similarly, if a lpLineTranslateOutput structure is passed in, it <br>//    *must* have been allocated with LocalAlloc and it could potentially be  <br>//    LocalFree()d. <br>// <br>//    If lpLineTranslateOutput == NULL, then a new structure is allocated. <br>//    It is normal to pass in NULL for this parameter unless you want to use <br>//    a lpLineTranslateOutput that has been returned by previous  <br>//    I_lineTranslateOutput call. <br>// <br>// <br> <br>LPLINETRANSLATEOUTPUT I_lineTranslateAddress( <br>    LPLINETRANSLATEOUTPUT lpLineTranslateOutput, <br>    DWORD dwDeviceID, DWORD dwAPIVersion, <br>    LPCSTR lpszDialAddress) <br>{ <br>    size_t sizeofLineTranslateOutput = sizeof(LINETRANSLATEOUTPUT) + 1024; <br>    long lReturn; <br>     <br>    // Continue this loop until the structure is big enough. <br>    while(TRUE) <br>    { <br>        // Make sure the buffer exists, is valid and big enough. <br>        lpLineTranslateOutput =  <br>            (LPLINETRANSLATEOUTPUT) CheckAndReAllocBuffer( <br>                (LPVOID) lpLineTranslateOutput, <br>                sizeofLineTranslateOutput, <br>                "lineTranslateOutput"); <br> <br>        if (lpLineTranslateOutput == NULL) <br>            return NULL; <br> <br>        // Make the call to fill the structure. <br>        do <br>        { <br>            // Note that CALLWAITING is disabled  <br>            // (assuming the service provider can disable it) <br>            lReturn =  <br>                lineTranslateAddress(g_hLineApp, dwDeviceID, dwAPIVersion, <br>                    lpszDialAddress, 0,  <br>                    LINETRANSLATEOPTION_CANCELCALLWAITING, <br>                    lpLineTranslateOutput); <br> <br>            // If the address isn't translatable, notify the user. <br>            if (lReturn == LINEERR_INVALADDRESS) <br>                MessageBox(g_hDlgParentWindow,  <br>                    "Unable to translate phone number","Warning",MB_OK); <br> <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                OutputDebugLineError(lReturn,  <br>                    "lineTranslateOutput unhandled error: "); <br>                LocalFree(lpLineTranslateOutput); <br>                return NULL; <br>            } <br>        } <br>        while (lReturn != SUCCESS); <br> <br>        // If the buffer was big enough, then succeed. <br>        if ((lpLineTranslateOutput -&gt; dwNeededSize) &lt;=  <br>            (lpLineTranslateOutput -&gt; dwTotalSize)) <br>        { <br>            return lpLineTranslateOutput; <br>        } <br> <br>        // Buffer wasn't big enough.  Make it bigger and try again. <br>        sizeofLineTranslateOutput = lpLineTranslateOutput -&gt; dwNeededSize; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: I_lineGetAddressCaps(LPLINEADDRESSCAPS, ..) <br>// <br>//  PURPOSE: Retrieve a LINEADDRESSCAPS structure for the specified line. <br>// <br>//  PARAMETERS: <br>//    lpLineAddressCaps - Pointer to a LINEADDRESSCAPS, or NULL. <br>//    dwDeviceID        - Device to get the address caps for. <br>//    dwAddressID       - This sample always assumes the first address. <br>//    dwAPIVersion      - API version negotiated for the device. <br>//    dwExtVersion      - Always 0 for this sample. <br>// <br>//  RETURN VALUE: <br>//    Returns a pointer to a LINEADDRESSCAPS structure if successful. <br>//    Returns NULL if unsuccessful. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a wrapper around lineGetAddressCaps to make it easy <br>//    to handle the variable sized structure and any errors received. <br>// <br>//    The returned structure has been allocated with LocalAlloc, <br>//    so LocalFree has to be called on it when you're finished with it, <br>//    or there will be a memory leak. <br>// <br>//    Similarly, if a lpLineAddressCaps structure is passed in, it *must* <br>//    have been allocated with LocalAlloc and it could potentially be  <br>//    LocalFree()d.  It also *must* have the dwTotalSize field set. <br>// <br>//    If lpLineAddressCaps == NULL, then a new structure is allocated.  It <br>//    is normal to pass in NULL for this parameter unless you want to use a <br>//    lpLineCallStatus that has been returned by previous I_lineGetAddressCaps <br>//    call. <br>// <br>// <br> <br>LPLINEADDRESSCAPS I_lineGetAddressCaps ( <br>    LPLINEADDRESSCAPS lpLineAddressCaps, <br>    DWORD dwDeviceID, DWORD dwAddressID, <br>    DWORD dwAPIVersion, DWORD dwExtVersion) <br>{ <br>    size_t sizeofLineAddressCaps = sizeof(LINEADDRESSCAPS) + 1024; <br>    long lReturn; <br>     <br>    // Continue this loop until the structure is big enough. <br>    while(TRUE) <br>    { <br>        // Make sure the buffer exists, is valid and big enough. <br>        lpLineAddressCaps =  <br>            (LPLINEADDRESSCAPS) CheckAndReAllocBuffer( <br>                (LPVOID) lpLineAddressCaps, <br>                sizeofLineAddressCaps, <br>                "lineGetAddressCaps"); <br> <br>        if (lpLineAddressCaps == NULL) <br>            return NULL; <br>             <br>        // Make the call to fill the structure. <br>        do <br>        { <br>            lReturn =  <br>                lineGetAddressCaps(g_hLineApp, <br>                    dwDeviceID, dwAddressID, dwAPIVersion, dwExtVersion, <br>                    lpLineAddressCaps); <br> <br>            if (HandleLineErr(lReturn)) <br>                continue; <br>            else <br>            { <br>                OutputDebugLineError(lReturn,  <br>                    "lineGetAddressCaps unhandled error: "); <br>                LocalFree(lpLineAddressCaps); <br>                return NULL; <br>            } <br>        } <br>        while (lReturn != SUCCESS); <br> <br>        // If the buffer was big enough, then succeed. <br>        if ((lpLineAddressCaps -&gt; dwNeededSize) &lt;=  <br>            (lpLineAddressCaps -&gt; dwTotalSize)) <br>        { <br>            return lpLineAddressCaps; <br>        } <br> <br>        // Buffer wasn't big enough.  Make it bigger and try again. <br>        sizeofLineAddressCaps = lpLineAddressCaps -&gt; dwNeededSize; </code></pre>
<p>
</p>
<pre><code>} <br>} <br> <br> <br> <br>//************************************************** <br>// LINEERR Error Handlers <br>//************************************************** <br> <br> <br>// <br>//  FUNCTION: HandleLineErr(long) <br>// <br>//  PURPOSE: Handle several standard LINEERR errors <br>// <br>//  PARAMETERS: <br>//    lLineErr - Error code to be handled. <br>// <br>//  RETURN VALUE: <br>//    Return TRUE if lLineErr wasn't an error, or if the <br>//      error was successfully handled and cleared up. <br>//    Return FALSE if lLineErr was an unhandled error. <br>// <br>//  COMMENTS: <br>// <br>//    This is the main error handler for all TAPI line APIs. <br>//    It handles (by correcting or just notifying the user) <br>//    most of the errors that can occur while using TAPI line APIs. <br>// <br>//    Note that many errors still return FALSE (unhandled) even <br>//    if a dialog is displayed.  Often, the dialog is just notifying <br>//    the user why the action was canceled. <br>//     <br>// <br>// <br> <br>BOOL HandleLineErr(long lLineErr) <br>{ <br>    // lLineErr is really an async request ID, not an error. <br>    if (lLineErr &gt; SUCCESS) <br>        return FALSE; <br> <br>    // All we do is dispatch the correct error handler. <br>    switch(lLineErr) <br>    { <br>        case SUCCESS: <br>            return TRUE; <br> <br>        case LINEERR_INVALCARD: <br>        case LINEERR_INVALLOCATION: <br>        case LINEERR_INIFILECORRUPT: <br>            return HandleIniFileCorrupt(); <br> <br>        case LINEERR_NODRIVER: <br>            return HandleNoDriver(); <br> <br>        case LINEERR_REINIT: <br>            return HandleReInit(); <br> <br>        case LINEERR_NOMULTIPLEINSTANCE: <br>            return HandleNoMultipleInstance(); <br> <br>        case LINEERR_NOMEM: <br>            return HandleNoMem(); <br> <br>        case LINEERR_OPERATIONFAILED: <br>            return HandleOperationFailed(); <br> <br>        case LINEERR_RESOURCEUNAVAIL: <br>            return HandleResourceUnavail(); <br> <br>        // Unhandled errors fail. <br>        default: <br>            return FALSE; <br>    } <br>} <br> <br> <br> <br>// <br>//  FUNCTION: HandleIniFileCorrupt <br>// <br>//  PURPOSE: Handle INIFILECORRUPT error. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>// <br>//    This error shouldn't happen under Windows 95 anymore.  The TAPI.DLL <br>//    takes care of correcting this problem.  If it does happen, just <br>//    notify the user. <br>// <br> <br>BOOL HandleIniFileCorrupt() <br>{ <br>    if (IDCANCEL == MessageBox(g_hDlgParentWindow,  <br>        "Configuration information relating to Telephony " <br>        "services appears to be corrupt.\n" <br>        "This could be the first time you have used the Telephony services.\n" <br>        "Would you like to configure the Telephony services?", <br>        "Warning",MB_OKCANCEL)) <br>    { <br>        return FALSE; <br>    } <br> <br>    lineTranslateDialog(g_hLineApp, 0, SAMPLE_TAPI_VERSION,  <br>        g_hDlgParentWindow, NULL); <br> <br>    return TRUE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleNoDriver <br>// <br>//  PURPOSE: Handle NODRIVER error. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>BOOL HandleNoDriver() <br>{ <br>    int mbRet; <br>    mbRet = MessageBox(g_hDlgParentWindow,  <br>        "One of the components of the Telephony device driver is missing.\n" <br>            "Use the Control Panel to set up the driver properly.", <br>        "Warning",MB_OK); <br> <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleNoMultipleInstance <br>// <br>//  PURPOSE: Handle NOMULTIPLEINSTANCE error. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>BOOL HandleNoMultipleInstance() <br>{ <br>    MessageBox(g_hDlgParentWindow,  <br>        "You have two copies of the same Telephony driver installed.\n" <br>            "Use the Control Panel to remove one of the copies.", <br>        "Warning",MB_OK); <br>         <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleReInit <br>// <br>//  PURPOSE: Handle REINIT error. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>BOOL HandleReInit() <br>{ <br>    ShutdownTAPI(); <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleNoMem <br>// <br>//  PURPOSE: Handle NOMEM error. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>//    This is also called if I run out of memory for LocalAlloc()s <br>// <br>// <br> <br>BOOL HandleNoMem() <br>{ <br>    MessageBox(g_hDlgParentWindow, <br>        "Out of Memory error, canceling action.","Error", MB_OK); <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleOperationFailed <br>// <br>//  PURPOSE: Handle OPERATIONFAILED error. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>BOOL HandleOperationFailed() <br>{ <br>    MessageBox(g_hDlgParentWindow, <br>        "TAPI Operation Failed for unknown reasons.", <br>        "Error", MB_OK); <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleResourceUnavail <br>// <br>//  PURPOSE: Handle RESOURCEUNAVAIL error. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>BOOL HandleResourceUnavail() <br>{ <br>    int mbRet; <br> <br>    mbRet = MessageBox(g_hDlgParentWindow, <br>        "A Telephony resource is temporarily unavaiable.  " <br>        "This could mean a short wait is necessary or " <br>        "that a non-TAPI application is using the line.", <br>        "Warning",MB_RETRYCANCEL); <br> <br>    if (mbRet == IDRETRY) <br>        return TRUE; <br> <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleNoDevicesInstalled <br>// <br>//  PURPOSE: Handle cases when we know NODEVICE error <br>//    is returned because there are no devices installed. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - error was corrected. <br>//    FALSE - error was not corrected. <br>// <br>//  COMMENTS: <br>// <br>//    This function is not part of standard error handling <br>//    but is only used when we know that the NODEVICE error <br>//    means that no devices are installed. <br>// <br>// <br> <br>BOOL HandleNoDevicesInstalled() <br>{ <br>    int mbRet; <br>    mbRet = MessageBox(g_hDlgParentWindow,  <br>       "There are no devices configured for Telephony use.\n" <br>       "Would you like to run the Modem Control Panel to add a modem driver?", <br>       "Warning",MB_YESNO); <br> <br>    if (mbRet == IDYES) <br>    { <br>        if (LaunchModemControlPanelAdd()) <br>            return TRUE; <br>    } <br>         <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: LaunchModemControlPanelAdd <br>// <br>//  PURPOSE: Launch Add Modem Control Panel applet. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE  - Control Panel launched successfully. <br>//    FALSE - It didn't. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>BOOL LaunchModemControlPanelAdd() <br>{ <br>    PROCESS_INFORMATION piProcInfo; <br>    STARTUPINFO siStartupInfo; <br> <br>    siStartupInfo.cb = sizeof(STARTUPINFO); <br>    siStartupInfo.lpReserved = NULL; <br>    siStartupInfo.lpDesktop = NULL; <br>    siStartupInfo.lpTitle = NULL; <br>    siStartupInfo.dwFlags = STARTF_USESHOWWINDOW; <br>    siStartupInfo.wShowWindow = SW_SHOWNORMAL; <br>    siStartupInfo.cbReserved2 = 0; <br>    siStartupInfo.lpReserved2 = NULL; <br>     <br>    // The string to launch the modem control panel is *VERY* likely <br>    // to change on NT.  If nothing else, this is 'contrl32' on NT <br>    // instead of 'control'. <br>    if (CreateProcess( <br>            NULL, <br>            "CONTROL.EXE MODEM.CPL,,ADD", <br>            NULL, NULL, FALSE,  <br>            NORMAL_PRIORITY_CLASS, <br>            NULL, NULL,  <br>            &amp;siStartupInfo,  <br>            &amp;piProcInfo)) <br>    { <br>        CloseHandle(piProcInfo.hThread); <br> <br> <br>        // Control panel 'Add New Modem' has been launched.  Now we should <br>        // wait for it to go away before continueing. <br> <br>        // If we WaitForSingleObject for the control panel to exit, then we <br>        // get into a deadlock situation if we need to respond to any messages <br>        // from the control panel. <br>         <br>        // If we use a PeekMessage loop to wait, we run into <br>        // message re-entrancy problems.  (The user can get back to our UI <br>        // and click 'dial' again). <br> <br>        // Instead, we take the easy way out and return FALSE to abort <br>        // the current operation. <br>     <br>        CloseHandle(piProcInfo.hProcess); <br>    } <br>    else <br>    { <br>        OutputDebugLastError(GetLastError(),  <br>            "Unable to LaunchModemControlPanelAdd: "); <br>        MessageBox(g_hDlgParentWindow,  <br>            "Unable to launch the Modem Control Panel", <br>            "Warning", MB_OK); <br>    } <br>     <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: WarningBox(LPCSTR) <br>// <br>//  PURPOSE: Prints a warning box when conditions remove a line in use. <br>// <br>//  PARAMETERS: <br>//    lpszMessage - String that specifies why the line was removed form use. <br>//     <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    If there is a call in progress on the line removed, then display a message <br>//    specifying why the line was removed and that the call is being canceled. <br>// <br>// <br> <br>void WarningBox(LPCSTR lpszMessage) <br>{ <br>    char szBuff[1024]; <br> <br>    strcpy(szBuff, lpszMessage); <br> <br>    // If there is a call open, tell user we're going to close it. <br>    if (g_hCall) <br>        strcat(szBuff, "\nClosing existing call."); <br> <br>    MessageBox(g_hDlgParentWindow, szBuff, "Warning", MB_OK); <br> <br>    strcat(szBuff, "\r\n"); <br>    OutputDebugString(szBuff); <br>} <br> <br> <br>//************************************************** <br>// <br>// All the functions from this point on are used solely by the "Dial" dialog. <br>// This dialog is used to get both the 'phone number' address,  <br>// the line device to be used as well as allow the user to configure <br>// dialing properties and the line device. <br>// <br>//************************************************** <br> <br>// <br>//  FUNCTION: DWORD I_lineNegotiateLegacyAPIVersion(DWORD) <br>// <br>//  PURPOSE: Negotiate an API Version to use for a specific device. <br>// <br>//  PARAMETERS: <br>//    dwDeviceID - device to negotiate an API Version for. <br>// <br>//  RETURN VALUE: <br>//    Returns the API Version to use for this line if successful. <br>//    Returns 0 if negotiations fall through. <br>// <br>//  COMMENTS: <br>// <br>//    This wrapper is slightly different from the I_lineNegotiateAPIVersion. <br>//    This wrapper allows TapiComm to negotiate an API version between <br>//    1.3 and SAMPLE_TAPI_VERSION.  Normally, this sample is specific to  <br>//    API Version SAMPLE_TAPI_VERSION.  However, there are a few times when <br>//    TapiComm needs to get information from a service provider, but also knows <br>//    that a lower API Version would be ok.  This allows TapiComm to recognize <br>//    legacy service providers even though it can't use them.  1.3 is the <br>//    lowest API Version a legacy service provider should support. <br>// <br>// <br> <br>DWORD I_lineNegotiateLegacyAPIVersion(DWORD dwDeviceID) <br>{ <br>    LINEEXTENSIONID LineExtensionID; <br>    long lReturn; <br>    DWORD dwLocalAPIVersion; <br>     <br>    do <br>    { <br>        lReturn = lineNegotiateAPIVersion(g_hLineApp, dwDeviceID,  <br>            0x00010003, SAMPLE_TAPI_VERSION, <br>            &amp;dwLocalAPIVersion, &amp;LineExtensionID); <br> <br>        if (lReturn == LINEERR_INCOMPATIBLEAPIVERSION) <br>        { <br>            OutputDebugString("INCOMPATIBLEAPIVERSION in Dial Dialog.\n"); <br>            return 0; <br>        } <br> <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            OutputDebugLineError(lReturn,  <br>                "lineNegotiateAPIVersion in Dial Dialog unhandled error: "); <br>            return 0; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br>         <br>    return dwLocalAPIVersion; <br>} <br> <br> <br>// <br>//  FUNCTION: long VerifyUsableLine(DWORD) <br>// <br>//  PURPOSE: Verifies that a specific line device is useable by TapiComm. <br>// <br>//  PARAMETERS: <br>//    dwDeviceID - The ID of the line device to be verified <br>// <br>//  RETURN VALUE: <br>//    Returns SUCCESS if dwDeviceID is a usable line device. <br>//    Returns a LINENOTUSEABLE_ constant otherwise. <br>// <br>//  COMMENTS: <br>// <br>//    VerifyUsableLine takes the give device ID and verifies step by step <br>//    that the device supports all the features that TapiComm requires. <br>// <br>// <br> <br>long VerifyUsableLine(DWORD dwDeviceID) <br>{ <br>    LPLINEDEVCAPS lpLineDevCaps = NULL; <br>    LPLINEADDRESSSTATUS lpLineAddressStatus = NULL; <br>    LPVARSTRING lpVarString = NULL; <br>    DWORD dwAPIVersion; <br>    long lReturn; <br>    long lUsableLine = SUCCESS; <br>    HLINE hLine = 0; <br> <br>    OutputDebugPrintf("Testing Line ID '0x%lx'",dwDeviceID); <br> <br>    // The line device must support an API Version that TapiComm does. <br>    dwAPIVersion = I_lineNegotiateAPIVersion(dwDeviceID); <br>    if (dwAPIVersion == 0) <br>        return LINENOTUSEABLE_ERROR; <br> <br>    lpLineDevCaps = I_lineGetDevCaps(lpLineDevCaps, <br>        dwDeviceID, dwAPIVersion); <br> <br>    if (lpLineDevCaps == NULL) <br>        return LINENOTUSEABLE_ERROR; <br> <br>    // Must support LINEBEARERMODE_VOICE <br>    if (!(lpLineDevCaps-&gt;dwBearerModes &amp; LINEBEARERMODE_VOICE )) <br>    { <br>        lUsableLine = LINENOTUSEABLE_NOVOICE; <br>        OutputDebugString("LINEBEARERMODE_VOICE not supported\n"); <br>        goto DeleteBuffers; <br>    } <br> <br>    // Must support LINEMEDIAMODE_DATAMODEM <br>    if (!(lpLineDevCaps-&gt;dwMediaModes &amp; LINEMEDIAMODE_DATAMODEM)) <br>    { <br>        lUsableLine = LINENOTUSEABLE_NODATAMODEM; <br>        OutputDebugString("LINEMEDIAMODE_DATAMODEM not supported\n"); <br>        goto DeleteBuffers; <br>    } <br> <br>    // Must be able to make calls <br>    if (!(lpLineDevCaps-&gt;dwLineFeatures &amp; LINEFEATURE_MAKECALL)) <br>    { <br>        lUsableLine = LINENOTUSEABLE_NOMAKECALL; <br>        OutputDebugString("LINEFEATURE_MAKECALL not supported\n"); <br>        goto DeleteBuffers; <br>    } <br> <br>    // It is necessary to open the line so we can check if  <br>    // there are any call appearances available.  Other TAPI <br>    // applications could be using all call appearances. <br>    // Opening the line also checks for other possible problems. <br>    do <br>    { <br>        lReturn = lineOpen(g_hLineApp, dwDeviceID, &amp;hLine, <br>            dwAPIVersion, 0, 0, <br>            LINECALLPRIVILEGE_NONE, LINEMEDIAMODE_DATAMODEM, <br>            0); <br> <br>        if(lReturn == LINEERR_ALLOCATED) <br>        { <br>            OutputDebugString( <br>                "Line is already in use by a non-TAPI app or" <br>                " another Service Provider.\n"); <br>            lUsableLine = LINENOTUSEABLE_ALLOCATED; <br>            goto DeleteBuffers; <br>        } <br> <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            OutputDebugLineError(lReturn, "lineOpen unhandled error: "); <br>            lUsableLine = LINENOTUSEABLE_ERROR; <br>            goto DeleteBuffers; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br> <br>    // Get LineAddressStatus to make sure the line isn't already in use. <br>    lpLineAddressStatus =  <br>        I_lineGetAddressStatus(lpLineAddressStatus, hLine, 0); <br>         <br>    if (lpLineAddressStatus == NULL) <br>    { <br>        lUsableLine = LINENOTUSEABLE_ERROR; <br>        goto DeleteBuffers; <br>    } <br> <br>    // Are there any available call appearances (ie: is it in use)? <br>    if ( !((lpLineAddressStatus -&gt; dwAddressFeatures) &amp; <br>           LINEADDRFEATURE_MAKECALL) ) <br>    { <br>        OutputDebugString("LINEADDRFEATURE_MAKECALL not available\n"); <br>        lUsableLine = LINENOTUSEABLE_INUSE; <br>        goto DeleteBuffers; <br>    } <br> <br>    // Make sure the "comm/datamodem" device class is supported <br>    // Note that we don't want any of the 'extra' information <br>    // normally returned in the VARSTRING structure.  All we care <br>    // about is if lineGetID succeeds. <br>    do <br>    { <br>        lpVarString = CheckAndReAllocBuffer((LPVOID) lpVarString, <br>            sizeof(VARSTRING),"VerifyUsableLine:lineGetID: "); <br> <br>        if (lpVarString == NULL) <br>        { <br>            lUsableLine = LINENOTUSEABLE_ERROR; <br>            goto DeleteBuffers; <br>        } <br> <br>        lReturn = lineGetID(hLine, 0, 0, LINECALLSELECT_LINE, <br>            lpVarString, "comm/datamodem"); <br> <br>        if (HandleLineErr(lReturn)) <br>            continue; <br>        else <br>        { <br>            OutputDebugLineError(lReturn,  <br>                "lineGetID unhandled error: "); <br>            lUsableLine = LINENOTUSEABLE_NOCOMMDATAMODEM; <br>            goto DeleteBuffers; <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br> <br>    OutputDebugString("Line is suitable and available for use.\n"); <br> <br>  DeleteBuffers: <br> <br>    if (hLine) <br>        lineClose(hLine); <br>    if (lpLineAddressStatus) <br>        LocalFree(lpLineAddressStatus); <br>    if (lpLineDevCaps) <br>        LocalFree(lpLineDevCaps); <br>    if (lpVarString) <br>        LocalFree(lpVarString); <br> <br>    return lUsableLine; <br>} <br> <br> <br>// <br>//  FUNCTION: void FillTAPILine(HWND) <br>// <br>//  PURPOSE: Fills the 'TAPI Line' control with the available line devices. <br>// <br>//  PARAMETERS:  <br>//    hwndDlg - handle to the current "Dial" dialog  <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    This function enumerates through all the TAPI line devices and <br>//    queries each for the device name.  The device name is then put into <br>//    the 'TAPI Line' control.  These device names are kept in order rather <br>//    than sorted.  This allows "Dial" to know which device ID the user  <br>//    selected just by the knowing the index of the selected string. <br>// <br>//    There are default values if there isn't a device name, if there is <br>//    an error on the device, or if the device name is an empty string. <br>//    The device name is also checked to make sure it is null terminated. <br>// <br>//    Note that a Legacy API Version is negotiated.  Since the fields in <br>//    the LINEDEVCAPS structure that we are interested in haven't moved, we <br>//    can negotiate a lower API Version than this sample is designed for <br>//    and still be able to access the necessary structure members. <br>// <br>//    The first line that is usable by TapiComm is selected as the 'default' <br>//    line.  Also note that if there was a previously selected line, this <br>//    remains the default line.  This would likely only occur if this <br>//    function is called after the dialog has initialized once; for example, <br>//    if a new line is added. <br>// <br>// <br> <br>void FillTAPILine(HWND hwndDlg) <br>{ <br>    DWORD dwDeviceID; <br>    DWORD dwAPIVersion; <br>    LPLINEDEVCAPS lpLineDevCaps = NULL; <br>    char szLineUnavail[] = "Line Unavailable"; <br>    char szLineUnnamed[] = "Line Unnamed"; <br>    char szLineNameEmpty[] = "Line Name is Empty"; <br>    LPSTR lpszLineName; <br>    long lReturn; <br>    DWORD dwDefaultDevice = MAXDWORD; <br> <br>    // Make sure the control is empty.  If it isn't, <br>    // hold onto the currently selected ID and then reset it. <br>    if (SendDlgItemMessage(hwndDlg, IDC_TAPILINE, CB_GETCOUNT, 0, 0)) <br>    { <br>        dwDefaultDevice = SendDlgItemMessage(hwndDlg, IDC_TAPILINE,  <br>            CB_GETCURSEL, 0, 0); <br>        SendDlgItemMessage(hwndDlg, IDC_TAPILINE, CB_RESETCONTENT, 0, 0); <br>    } <br> <br>    for (dwDeviceID = 0; dwDeviceID &lt; g_dwNumDevs; dwDeviceID ++) <br>    { <br>        dwAPIVersion = I_lineNegotiateLegacyAPIVersion(dwDeviceID); <br>        if (dwAPIVersion) <br>        { <br>            lpLineDevCaps = I_lineGetDevCaps(lpLineDevCaps, <br>                dwDeviceID, dwAPIVersion); <br>            if (lpLineDevCaps) <br>            { <br>                if ((lpLineDevCaps -&gt; dwLineNameSize) &amp;&amp; <br>                    (lpLineDevCaps -&gt; dwLineNameOffset) &amp;&amp; <br>                    (lpLineDevCaps -&gt; dwStringFormat == STRINGFORMAT_ASCII)) <br>                { <br>                    // This is the name of the device. <br>                    lpszLineName = ((char *) lpLineDevCaps) +  <br>                        lpLineDevCaps -&gt; dwLineNameOffset; <br> <br>                    if (lpszLineName[0] != '\0') <br>                    { <br>        // Reverse indented to make this fit <br> <br>        // Make sure the device name is null terminated. <br>        if (lpszLineName[lpLineDevCaps-&gt;dwLineNameSize -1] != '\0') <br>        { <br>            // If the device name is not null terminated, null <br>            // terminate it.  Yes, this looses the end character. <br>            // Its a bug in the service provider. <br>            lpszLineName[lpLineDevCaps-&gt;dwLineNameSize-1] = '\0'; <br>            OutputDebugPrintf( <br>                "Device name for device 0x%lx is not null terminated.\n", <br>                dwDeviceID); <br>        } <br>                    } <br>                    else // Line name started with a NULL. <br>                        lpszLineName = szLineNameEmpty; <br>                } <br>                else  // DevCaps doesn't have a valid line name.  Unnamed. <br>                    lpszLineName = szLineUnnamed; <br>            } <br>            else  // Couldn't GetDevCaps.  Line is unavail. <br>                lpszLineName = szLineUnavail; <br>        } <br>        else  // Couldn't NegotiateAPIVersion.  Line is unavail. <br>            lpszLineName = szLineUnavail; <br> <br>        // Put the device name into the control <br>        lReturn = SendDlgItemMessage(hwndDlg, IDC_TAPILINE, <br>            CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) lpszLineName); <br> <br>        // If this line is usable and we don't have a default initial <br>        // line yet, make this the initial line. <br>        if ((lpszLineName != szLineUnavail) &amp;&amp;  <br>            (dwDefaultDevice == MAXDWORD) &amp;&amp; <br>            (VerifyUsableLine(dwDeviceID) == SUCCESS)) <br>        { <br>            dwDefaultDevice = dwDeviceID; <br>        } <br>    } <br> <br>    if (lpLineDevCaps) <br>        LocalFree(lpLineDevCaps); <br> <br>    if (dwDefaultDevice == MAXDWORD) <br>        dwDefaultDevice = 0; <br> <br>    // Set the initial default line <br>    SendDlgItemMessage(hwndDlg, IDC_TAPILINE,  <br>        CB_SETCURSEL, dwDefaultDevice, 0); <br>} <br> <br> <br>// <br>//  FUNCTION: BOOL VerifyAndWarnUsableLine(HWND) <br>// <br>//  PURPOSE: Verifies the line device selected by the user. <br>// <br>//  PARAMETERS: <br>//    hwndDlg - The handle to the current "Dial" dialog. <br>// <br>//  RETURN VALUE: <br>//    Returns TRUE if the currently selected line device is useable <br>//      by TapiComm.  Returns FALSE if it isn't. <br>// <br>//  COMMENTS: <br>// <br>//    This function is very specific to the "Dial" dialog.  It gets <br>//    the device selected by the user from the 'TAPI Line' control and <br>//    VerifyUsableLine to make sure this line device is usable.  If the <br>//    line isn't useable, it notifies the user and disables the 'Dial' <br>//    button so that the user can't initiate a call with this line. <br>// <br>//    This function is also responsible for filling in the line specific <br>//    icon found on the "Dial" dialog. <br>// <br>// <br> <br>BOOL VerifyAndWarnUsableLine(HWND hwndDlg) <br>{ <br>    DWORD dwDeviceID; <br>    long lReturn; <br>    HICON hIcon = 0; <br>    HWND hControlWnd; <br> <br>    // Get the selected line device. <br>    dwDeviceID = SendDlgItemMessage(hwndDlg, IDC_TAPILINE, <br>                        CB_GETCURSEL, 0, 0); <br> <br>    // Get the "comm" device icon associated with this line device. <br>    lReturn = lineGetIcon(dwDeviceID, "comm", &amp;hIcon); <br> <br>    if (lReturn == SUCCESS) <br>        SendDlgItemMessage(hwndDlg, IDC_LINEICON, STM_SETICON, <br>            (WPARAM) hIcon, 0); <br>    else <br>        // Any failure to get an icon makes us use the default icon. <br>        SendDlgItemMessage(hwndDlg, IDC_LINEICON, WM_SETTEXT, <br>            0, (LPARAM) (LPCTSTR) "TapiComm"); <br> <br>/*  // It turns out that TAPI will always return an icon, even if <br>    // the device class isn't supported by the TSP or even if the TSP <br>    // doesn't return any icons at all.  This code is unnecessary. <br>    // The only reason lineGetIcon would fail is due to resource problems. <br> <br>    else <br>    { <br>        // If the line doesn't have a "comm" device icon, use its default one. <br>        lReturn = lineGetIcon(dwDeviceID, NULL, &amp;hIcon); <br>        if (lReturn == SUCCESS) <br>        { <br>            OutputDebugString("Line doesn't support a \"comm\" icon.\n"); <br>            SendDlgItemMessage(hwndDlg, IDC_LINEICON, STM_SETICON, <br>                (WPARAM) hIcon, 0); <br>        } <br>        else <br>        { <br>            // If lineGetIcon fails, just use TapiComms icon. <br>            OutputDebugLineError(lReturn, "lineGetIcon: "); <br>            SendDlgItemMessage(hwndDlg, IDC_LINEICON, WM_SETTEXT, <br>                0, (LPARAM) (LPCTSTR) "TapiComm"); <br>        } <br>    } <br>*/ <br> <br>    // Verify if the device is usable by TapiComm. <br>    lReturn = VerifyUsableLine(dwDeviceID); <br> <br>    // Enable or disable the 'Dial' button, depending on if the line is ok. <br>    // Make sure there is a number to dial before enabling the button. <br>    hControlWnd = GetDlgItem(hwndDlg, IDC_DIAL); <br>    if (SendDlgItemMessage(hwndDlg, IDC_CANONICALNUMBER, <br>        WM_GETTEXTLENGTH, 0, 0) == 0) <br>    { <br>        EnableWindow(hControlWnd, FALSE); <br>    } <br>    else <br>        EnableWindow(hControlWnd, (lReturn == SUCCESS)); <br> <br>    // Any errors on this line prevent us from configuring it <br>    // or using dialing properties. <br>    if (lReturn == LINENOTUSEABLE_ERROR) <br>    { <br>        EnableWindow(GetDlgItem(hwndDlg, IDC_CONFIGURELINE), FALSE); <br>        EnableWindow(GetDlgItem(hwndDlg, IDC_DIALINGPROPERTIES), FALSE); <br>    } <br>    else <br>    { <br>        EnableWindow(GetDlgItem(hwndDlg, IDC_CONFIGURELINE), TRUE); <br>        if (SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES, BM_GETCHECK, 0, 0)) <br>            EnableWindow(GetDlgItem(hwndDlg, IDC_DIALINGPROPERTIES), TRUE); <br>    } <br> <br>    switch(lReturn) <br>    { <br>        case SUCCESS: <br>            g_dwDeviceID = dwDeviceID; <br>            return TRUE; <br> <br>        case LINENOTUSEABLE_ERROR: <br>            MessageBox(hwndDlg, <br>                "The selected line is incompatible with the TapiComm sample", <br>                "Warning",MB_OK); <br>            break; <br>        case LINENOTUSEABLE_NOVOICE: <br>            MessageBox(hwndDlg, <br>                "The selected line doesn't support VOICE capabilities", <br>                "Warning",MB_OK); <br>            break; <br>        case LINENOTUSEABLE_NODATAMODEM: <br>            MessageBox(hwndDlg, <br>                "The selected line doesn't support DATAMODEM capabilities", <br>                "Warning",MB_OK); <br>            break; <br>        case LINENOTUSEABLE_NOMAKECALL: <br>            MessageBox(hwndDlg, <br>                "The selected line doesn't support MAKECALL capabilities", <br>                "Warning",MB_OK); <br>            break; <br>        case LINENOTUSEABLE_ALLOCATED: <br>            MessageBox(hwndDlg, <br>                "The selected line is already in use by a non-TAPI application", <br>                "Warning",MB_OK); <br>            break; <br>        case LINENOTUSEABLE_INUSE: <br>            MessageBox(hwndDlg, <br>                "The selected line is already in use by a TAPI application", <br>                "Warning",MB_OK); <br>            break; <br>         <br>        case LINENOTUSEABLE_NOCOMMDATAMODEM: <br>            MessageBox(hwndDlg, <br>                "The selected line doesn't support the COMM/DATAMODEM device class", <br>                "Warning",MB_OK); <br>            break; <br>    } <br> <br>    // g_dwDeviceID == MAXDWORD mean the selected device isn't usable. <br>    g_dwDeviceID = MAXDWORD; <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: void FillCountryCodeList(HWND, DWORD) <br>// <br>//  PURPOSE: Fill the 'Country Code' control <br>// <br>//  PARAMETERS: <br>//    hwndDlg - handle to the current "Dial" dialog  <br>//    dwDefaultCountryID - ID of the 'default' country to be selected <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    This function fills the 'Country Code' control with country names. <br>//    The country code is appended to the end of the name and the names <br>//    are added to the control sorted.  Because the country code is <br>//    embedded in the string along with the country name, there is no need <br>//    for any of the country information structures to be kept around.  The  <br>//    country code can be extracted from the selected string at any time. <br>// <br>// <br> <br>void FillCountryCodeList(HWND hwndDlg, DWORD dwDefaultCountryID) <br>{ <br>    LPLINECOUNTRYLIST lpLineCountryList = NULL; <br>    DWORD dwSizeofCountryList = sizeof(LINECOUNTRYLIST); <br>    long lReturn; <br>    DWORD dwCountry; <br>    LPLINECOUNTRYENTRY lpLineCountryEntries; <br>    char szRenamedCountry[256]; <br> <br>    // Get the country information stored in TAPI <br>    do <br>    { <br>        lpLineCountryList = (LPLINECOUNTRYLIST) CheckAndReAllocBuffer( <br>            (LPVOID) lpLineCountryList, dwSizeofCountryList, <br>            "FillCountryCodeList"); <br> <br>        if (lpLineCountryList == NULL) <br>            return; <br> <br>        lReturn = lineGetCountry (0, SAMPLE_TAPI_VERSION, lpLineCountryList); <br> <br>        if (HandleLineErr(lReturn)) <br>            ; <br>        else <br>        { <br>            OutputDebugLineError(lReturn, "lineGetCountry unhandled error: "); <br>            LocalFree(lpLineCountryList); <br>            return; <br>        } <br> <br>        if ((lpLineCountryList -&gt; dwNeededSize) &gt; <br>            (lpLineCountryList -&gt; dwTotalSize)) <br>        { <br>            dwSizeofCountryList = lpLineCountryList -&gt;dwNeededSize; </code></pre>
<p>
</p>
<pre><code>lReturn = -1; // Lets loop again. <br>        } <br>    } <br>    while (lReturn != SUCCESS); <br> <br>    // Find the first country entry <br>    lpLineCountryEntries = (LPLINECOUNTRYENTRY)  <br>        (((LPBYTE) lpLineCountryList)  <br>         + lpLineCountryList -&gt; dwCountryListOffset); <br> <br>    // Now enumerate through all the countries <br>    for (dwCountry = 0;  <br>         dwCountry &lt; lpLineCountryList -&gt; dwNumCountries;  <br>         dwCountry++) <br>    { <br>        // append the country code to the country name <br>        wsprintf(szRenamedCountry,"%s (%lu)", <br>            (((LPSTR) lpLineCountryList) + <br>                lpLineCountryEntries[dwCountry].dwCountryNameOffset), <br>            lpLineCountryEntries[dwCountry].dwCountryCode); <br> <br>        // Now put this country name / code string into the combobox <br>        lReturn = SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, CB_ADDSTRING, <br>                    0, (LPARAM) (LPCTSTR) szRenamedCountry); <br> <br>        // If this country is the default country, select it. <br>        if (lpLineCountryEntries[dwCountry].dwCountryID <br>            == dwDefaultCountryID) <br>        { <br>            SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, CB_SETCURSEL, lReturn, 0); <br>        } <br>    } <br>     <br>    LocalFree(lpLineCountryList); <br>    return; <br>} <br> <br> <br>// <br>//  FUNCTION: void FillLocationInfo(HWND, LPSTR, LPDWORD, LPSTR) <br>// <br>//  PURPOSE: Fill (or refill) the 'Your Location' control <br>// <br>//  PARAMETERS: <br>//    hwndDlg - handle to the current "Dial" dialog  <br>//    lpszCurrentLocation - Name of current location, or NULL <br>//    lpdwCountryID - location to store the current country ID or NULL <br>//    lpszAreaCode - location to store the current area code or NULL <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    This function is moderately multipurpose. <br>// <br>//    If lpszCurrentLocation is NULL, then the 'Your Location' control <br>//    is filled with all the locations stored in TAPI and the TAPI 'default'  <br>//    location is selected.  This is done during initialization and <br>//    also after the 'Dialing Properties' dialog has been displayed. <br>//    This last is done because the user can change the current location <br>//    or add and delete locations while in the 'Dialing Properties' dialog. <br>//     <br>//    If lpszCurrentLocation is a valid string pointer, then it is assumed <br>//    that the 'Your Location' control is already filled and that the user <br>//    is selecting a specific location.  In this case, all of the existing <br>//    TAPI locations are enumerated until the specified location is found. <br>//    At this point, the specified location is set to the current location. <br>//     <br>//    In either case, if lpdwCountryID is not NULL, it is filled with the <br>//    country ID for the current location.  If lpszAreaCode is not NULL, it <br>//    is filled with the area code defined for the current location.  These <br>//    values can be used later to initialize other "Dial" controls. <br>// <br>//    This function also fills the 'Calling Card' control based on <br>//    the information stored in the current location. <br>// <br>// <br> <br>void FillLocationInfo(HWND hwndDlg, LPSTR lpszCurrentLocation,  <br>    LPDWORD lpdwCountryID, LPSTR lpszAreaCode) <br>{ <br>    LPLINETRANSLATECAPS lpTranslateCaps = NULL; <br>    DWORD dwSizeofTranslateCaps = sizeof(LINETRANSLATECAPS); <br>    long lReturn; <br>    DWORD dwCounter; <br>    LPLINELOCATIONENTRY lpLocationEntry; <br>    LPLINECARDENTRY lpLineCardEntry = NULL; <br>    DWORD dwPreferredCardID = MAXDWORD; <br> <br>    // First, get the TRANSLATECAPS <br>    do <br>    { <br>        lpTranslateCaps = (LPLINETRANSLATECAPS) CheckAndReAllocBuffer( <br>            (LPVOID) lpTranslateCaps, dwSizeofTranslateCaps, <br>            "FillLocationInfo"); <br> <br>        if (lpTranslateCaps == NULL) <br>            return; <br> <br>        lReturn = lineGetTranslateCaps(g_hLineApp, SAMPLE_TAPI_VERSION,  <br>                    lpTranslateCaps); <br> <br>        if (HandleLineErr(lReturn)) <br>            ; <br>        else <br>        { <br>            OutputDebugLineError(lReturn,  <br>                "lineGetTranslateCaps unhandled error: "); <br>            LocalFree(lpTranslateCaps); <br>            return; <br>        } <br> <br>        if ((lpTranslateCaps -&gt; dwNeededSize) &gt; <br>            (lpTranslateCaps -&gt; dwTotalSize)) <br>        { <br>            dwSizeofTranslateCaps = lpTranslateCaps -&gt;dwNeededSize; <br>            lReturn = -1; // Lets loop again. <br>        } <br>    } <br>    while(lReturn != SUCCESS); <br> <br>    // Find the location information in the TRANSLATECAPS <br>    lpLocationEntry = (LPLINELOCATIONENTRY) <br>        (((LPBYTE) lpTranslateCaps) + lpTranslateCaps-&gt;dwLocationListOffset); <br> <br>    // If lpszCurrentLocation, then make that location 'current' <br>    if (lpszCurrentLocation) <br>    { <br>        // loop through all locations, looking for a location match <br>        for(dwCounter = 0;  <br>            dwCounter &lt; lpTranslateCaps -&gt; dwNumLocations; <br>            dwCounter++) <br>        { <br>            if (strcmp((((LPSTR) lpTranslateCaps) +  <br>                            lpLocationEntry[dwCounter].dwLocationNameOffset), <br>                        lpszCurrentLocation) <br>                == 0) <br>            { <br>                // Found it!  Set the current location. <br>                lineSetCurrentLocation(g_hLineApp,  <br>                    lpLocationEntry[dwCounter].dwPermanentLocationID); <br> <br>                // Set the return values. <br>                if (lpdwCountryID) <br>                    *lpdwCountryID = lpLocationEntry[dwCounter].dwCountryID; <br> <br>                if (lpszAreaCode) <br>                    strcpy(lpszAreaCode, (((LPSTR) lpTranslateCaps) +  <br>                            lpLocationEntry[dwCounter].dwCityCodeOffset)); <br> <br>                // Store the preferred card ID for later use. <br>                dwPreferredCardID = lpLocationEntry[dwCounter].dwPreferredCardID; <br>                break; <br>            } <br>        } <br> <br>        // Was a match for lpszCurrentLocation found? <br>        if (dwPreferredCardID == MAXDWORD) <br>        { <br>            OutputDebugString("lpszCurrentLocation not found\n"); <br>            SendDlgItemMessage(hwndDlg, IDC_CALLINGCARD, WM_SETTEXT, 0,  <br>                (LPARAM) (LPCSTR) "Invalid Location Selected"); <br>            LocalFree(lpTranslateCaps); <br>            return; <br>        } <br>    } <br>    else // fill the combobox and use the TAPI 'current' location. <br>    { <br>        // First empty the combobox <br>        SendDlgItemMessage(hwndDlg, IDC_LOCATION, CB_RESETCONTENT, 0, 0); <br>     <br>        // enumerate all the locations <br>        for(dwCounter = 0;  <br>            dwCounter &lt; lpTranslateCaps -&gt; dwNumLocations; <br>            dwCounter++) <br>        { <br>            // Put each one into the combobox <br>            lReturn = SendDlgItemMessage(hwndDlg, IDC_LOCATION, CB_ADDSTRING, <br>                0, (LPARAM) (((LPBYTE) lpTranslateCaps) +  <br>                    lpLocationEntry[dwCounter].dwLocationNameOffset)); <br>         <br>            // Is this location the 'current' location? <br>            if (lpLocationEntry[dwCounter].dwPermanentLocationID == <br>                lpTranslateCaps-&gt;dwCurrentLocationID) <br>            { <br>                // Return the requested information <br>                if (lpdwCountryID) <br>                    *lpdwCountryID = lpLocationEntry[dwCounter].dwCountryID; <br> <br>                if (lpszAreaCode) <br>                    strcpy(lpszAreaCode, (((LPSTR) lpTranslateCaps) +  <br>                            lpLocationEntry[dwCounter].dwCityCodeOffset)); <br> <br>                // Set this to be the active location. <br>                SendDlgItemMessage(hwndDlg, IDC_LOCATION, CB_SETCURSEL, lReturn, 0); <br>                dwPreferredCardID = lpLocationEntry[dwCounter].dwPreferredCardID; <br>            } <br>        } <br>    } <br> <br>    // Now locate the prefered card and display it. <br> <br>    lpLineCardEntry = (LPLINECARDENTRY) <br>        (((LPBYTE) lpTranslateCaps) + lpTranslateCaps-&gt;dwCardListOffset); <br> <br>    for(dwCounter = 0;  <br>        dwCounter &lt; lpTranslateCaps -&gt; dwNumCards; <br>        dwCounter++) <br>    { <br>        if (lpLineCardEntry[dwCounter].dwPermanentCardID == dwPreferredCardID) <br>        { <br>            SendDlgItemMessage(hwndDlg, IDC_CALLINGCARD, WM_SETTEXT, 0,  <br>                (LPARAM) (((LPBYTE) lpTranslateCaps) +  <br>                    lpLineCardEntry[dwCounter].dwCardNameOffset)); <br>            break; <br>        } <br>    } <br> <br>    LocalFree(lpTranslateCaps); <br>} <br> <br> <br> <br>// <br>//  FUNCTION: void UseDialingRules(HWND) <br>// <br>//  PURPOSE: Enable/disable Dialing Rule controls <br>// <br>//  PARAMETERS: <br>//    hwndDlg - handle to the current "Dial" dialog  <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    The sole purpose of this function is to enable or disable <br>//    the controls that apply to dialing rules if the  <br>//    "Use Country Code and Area Code" checkbox is checked or unchecked, <br>//    as appropriate. <br>// <br>// <br> <br>void UseDialingRules(HWND hwndDlg) <br>{ <br>    HWND hControl; <br>    BOOL bEnableWindow; <br> <br>    bEnableWindow = SendDlgItemMessage(hwndDlg, <br>        IDC_USEDIALINGRULES, BM_GETCHECK, 0, 0); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_STATICCOUNTRYCODE); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_COUNTRYCODE); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_STATICAREACODE); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_AREACODE); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_STATICLOCATION); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_LOCATION); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_STATICCALLINGCARD); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    hControl = GetDlgItem(hwndDlg, IDC_CALLINGCARD); <br>    EnableWindow(hControl, bEnableWindow); <br> <br>    if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_CONFIGURELINE))) <br>    { <br>        hControl = GetDlgItem(hwndDlg, IDC_DIALINGPROPERTIES); <br>        EnableWindow(hControl, bEnableWindow); <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: void DisplayPhoneNumber(HWND) <br>// <br>//  PURPOSE: Create, Translate and Display the Phone Number <br>// <br>//  PARAMETERS: <br>//    hwndDlg - handle to the current "Dial" dialog  <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    This function uses the information stored in many other controls <br>//    to build the phone number, translate it, and display it.  Also <br>//    makes sure the Dial button is enabled or disabled, based on if the <br>//    number can be dialed or not. <br>// <br>//    There are actually three phone numbers generated during this <br>//    process:  canonical, dialable and displayable.  Normally, only the <br>//    displayable number is shown to the user; the other two numbers are <br>//    to be used by the program internally.  However, for demonstration <br>//    purposes (and because it is cool for developers to see these numbers), <br>//    all three numbers are displayed. <br>// <br> <br>void DisplayPhoneNumber(HWND hwndDlg) <br>{ <br>    char szPreTranslatedNumber[1024] = ""; <br>    int  nPreTranslatedSize = 0; <br>    char szTempBuffer[512]; <br>    int  i; <br>    DWORD dwDeviceID; <br>    LPLINETRANSLATEOUTPUT lpLineTranslateOutput = NULL; <br> <br>    // Disable the 'dial' button if there isn't a number to dial <br>    if (0 == SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER,  <br>            WM_GETTEXTLENGTH, 0, 0)) <br>    { <br>        SendDlgItemMessage(hwndDlg, IDC_CANONICALNUMBER, WM_SETTEXT, 0, <br>            (LPARAM) NULL); <br>        SendDlgItemMessage(hwndDlg, IDC_DIALABLENUMBER, WM_SETTEXT, 0, <br>            (LPARAM) NULL); <br>        SendDlgItemMessage(hwndDlg, IDC_DISPLAYABLENUMBER, WM_SETTEXT, 0, <br>            (LPARAM) (LPCTSTR) "No Phone Number"); <br> <br>        EnableWindow(GetDlgItem(hwndDlg, IDC_DIAL), FALSE); <br>        return; <br>    } <br> <br>    // If we use the dialing rules, lets make canonical format. <br>    // Canonical format is explained in the TAPI documentation and the <br>    // string format needs to be followed very strictly. <br>    if (SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES, <br>        BM_GETCHECK, 0, 0)) <br>    { <br>        // First character *has* to be the plus sign. <br>        szPreTranslatedNumber[0] = '+'; <br>        nPreTranslatedSize = 1; <br> <br>        // The country code *has* to be next. <br>        // Country code was stored in the string with the country <br>        // name and needs to be extracted at this point. <br>        i = SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, <br>                CB_GETCURSEL, 0, 0); <br>        SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, <br>            CB_GETLBTEXT, (WPARAM) i, (LPARAM) (LPCTSTR) szTempBuffer); <br> <br>        // Country code is at the end of the string, surounded by parens. <br>        // This makes it easy to identify the country code. <br>        i = strlen(szTempBuffer); <br>        while(szTempBuffer[--i] != '('); <br> <br>        while(szTempBuffer[++i] != ')')  <br>            szPreTranslatedNumber[nPreTranslatedSize++] = szTempBuffer[i]; <br> <br>        // Next is the area code. <br>        i = SendDlgItemMessage(hwndDlg, IDC_AREACODE, WM_GETTEXT, <br>                510, (LPARAM) (LPCTSTR) szTempBuffer); <br> <br>        // Note that the area code is optional.  If it is included, <br>        // then it has to be preceeded by *exactly* one space and it <br>        // *has* to be surrounded by parens. <br>        if (i) <br>            nPreTranslatedSize += <br>                wsprintf(&amp;szPreTranslatedNumber[nPreTranslatedSize], <br>                    " (%s)", szTempBuffer); <br> <br>        // There has to be *exactly* one space before the rest of the number. <br>        szPreTranslatedNumber[nPreTranslatedSize++] = ' '; <br> <br>        // At this point, the phone number is appended to the <br>        // canonical number.  The next step is the same whether canonical <br>        // format is used or not; just the prepended area code and  <br>        // country code are different. <br>    } <br> <br>    SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER, WM_GETTEXT, <br>        510, (LPARAM) (LPCTSTR) szTempBuffer); <br> <br>    strcat(&amp;szPreTranslatedNumber[nPreTranslatedSize], szTempBuffer); <br> <br>    dwDeviceID = SendDlgItemMessage(hwndDlg, IDC_TAPILINE, <br>                        CB_GETCURSEL, 0, 0); <br> <br>    // Translate the address! <br>    lpLineTranslateOutput = I_lineTranslateAddress( <br>        lpLineTranslateOutput, dwDeviceID, SAMPLE_TAPI_VERSION, <br>        szPreTranslatedNumber); <br> <br>    // Unable to translate it? <br>    if (lpLineTranslateOutput == NULL) <br>    { <br>        SendDlgItemMessage(hwndDlg, IDC_CANONICALNUMBER, WM_SETTEXT, 0, <br>            (LPARAM) NULL); <br>        SendDlgItemMessage(hwndDlg, IDC_DIALABLENUMBER, WM_SETTEXT, 0, <br>            (LPARAM) NULL); <br>        SendDlgItemMessage(hwndDlg, IDC_DISPLAYABLENUMBER, WM_SETTEXT, 0, <br>            (LPARAM) (LPCTSTR) "Invalid Phone Number or Area Code"); <br> <br>        EnableWindow(GetDlgItem(hwndDlg, IDC_DIAL), FALSE); <br>        return; <br>    } <br> <br>    // Is the selected device useable with TapiComm? <br>    if (g_dwDeviceID != MAXDWORD) <br>        EnableWindow(GetDlgItem(hwndDlg, IDC_DIAL), TRUE); <br> <br>    // Fill the appropriate phone number controls. <br>    SendDlgItemMessage(hwndDlg, IDC_CANONICALNUMBER, WM_SETTEXT, 0, <br>        (LPARAM) (LPCTSTR) szPreTranslatedNumber); <br> <br>    SendDlgItemMessage(hwndDlg, IDC_DIALABLENUMBER, WM_SETTEXT, 0, <br>        (LPARAM) ((LPSTR) lpLineTranslateOutput + <br>            lpLineTranslateOutput -&gt; dwDialableStringOffset)); <br> <br>    SendDlgItemMessage(hwndDlg, IDC_DISPLAYABLENUMBER, WM_SETTEXT, 0, <br>        (LPARAM) ((LPSTR) lpLineTranslateOutput + <br>            lpLineTranslateOutput -&gt; dwDisplayableStringOffset)); <br> <br>    LocalFree(lpLineTranslateOutput); <br> <br>} <br> <br> <br>// <br>//  FUNCTION: void PreConfigureDevice(HWND, DWORD) <br>// <br>//  PURPOSE:  <br>// <br>//  PARAMETERS: <br>//    hwndDlg - handle to the current "Dial" dialog  <br>//    dwDeviceID - line device to be configured <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    At one point, PreConfigureDevice used lineConfigDialog to <br>//    configure the device.  This has the unfortunate effect of configuring <br>//    the device immediately, even if it is in use by another TAPI app. <br>//    This can be really bad if data communications are already in <br>//    progress (like with RAS). <br>// <br>//    Now, PreConfigureDevice uses lineConfigDialogEdit to give the <br>//    user the configuration UI, but it doesn't actually do anything to <br>//    the line device.  TapiComm stores the configuration information so <br>//    that it can be set later, just before making the call. <br>// <br>// <br> <br>void PreConfigureDevice(HWND hwndDlg, DWORD dwDeviceID) <br>{ <br>    long lReturn; <br>    LPVARSTRING lpVarString = NULL; <br>    DWORD dwSizeofVarString = sizeof(VARSTRING); <br> <br>    // If there isn't already any device configuration information, <br>    // then we need to get some. <br>    if (g_lpDeviceConfig == NULL) <br>    { <br>        do <br>        { <br>            lpVarString = (LPVARSTRING) CheckAndReAllocBuffer( <br>                (LPVOID) lpVarString, dwSizeofVarString, <br>                "PreConfigureDevice - lineGetDevConfig: "); <br> <br>            if (lpVarString == NULL) <br>                return; <br> <br>            lReturn = lineGetDevConfig(dwDeviceID, lpVarString,  <br>                "comm/datamodem"); <br> <br>            if (HandleLineErr(lReturn)) <br>                ; <br>            else <br>            { <br>                OutputDebugLineError(lReturn,  <br>                    "lineGetDevCaps unhandled error: "); <br>                LocalFree(lpVarString); <br>                return; <br>            } <br> <br>            if ((lpVarString -&gt; dwNeededSize) &gt; (lpVarString -&gt; dwTotalSize)) <br>            { <br>                dwSizeofVarString = lpVarString -&gt; dwNeededSize; <br>                lReturn = -1; // Lets loop again. <br>            } <br>        } <br>        while (lReturn != SUCCESS); <br> <br>        g_dwSizeDeviceConfig = lpVarString -&gt; dwStringSize; <br> <br>        // The extra byte allocated is in case dwStringSize is 0. <br>        g_lpDeviceConfig = CheckAndReAllocBuffer( <br>                g_lpDeviceConfig, g_dwSizeDeviceConfig+1, <br>                "PreConfigureDevice - Allocate device config: "); <br> <br>        if (!g_lpDeviceConfig) <br>        { <br>            LocalFree(lpVarString); <br>            return; <br>        } <br> <br>        memcpy(g_lpDeviceConfig,  <br>            ((LPBYTE) lpVarString + lpVarString -&gt; dwStringOffset), <br>            g_dwSizeDeviceConfig); <br>    } <br> <br>    // Next make the lineConfigDialogEdit call. <br> <br>    // Note that we determine the initial size of the VARSTRING <br>    // structure based on the known size of the existing configuration <br>    // information.  I make the assumption that this configuration <br>    // information is very unlikely to grow by more than 5K or by <br>    // more than 5 times.  This is a *very* conservative number. <br>    // We do *not* want lineConfigDialogEdit to fail just because there  <br>    // wasn't enough room to stored the data.  This would require the user <br>    // to go through configuration again and that would be annoying. <br> <br>    dwSizeofVarString = 5 * g_dwSizeDeviceConfig + 5000; <br> <br>    do <br>    { <br>        lpVarString = (LPVARSTRING) CheckAndReAllocBuffer( <br>            (LPVOID) lpVarString, dwSizeofVarString, <br>            "PreConfigureDevice - lineConfigDialogEdit: "); <br> <br>        if (lpVarString == NULL) <br>            return; <br> <br>        lReturn = lineConfigDialogEdit(dwDeviceID, hwndDlg, "comm/datamodem", <br>            g_lpDeviceConfig, g_dwSizeDeviceConfig, lpVarString); <br> <br>        if (HandleLineErr(lReturn)) <br>            ; <br>        else <br>        { <br>            OutputDebugLineError(lReturn,  <br>                "lineConfigDialogEdit unhandled error: "); <br>            LocalFree(lpVarString); <br>            return; <br>        } <br> <br>        if ((lpVarString -&gt; dwNeededSize) &gt; (lpVarString -&gt; dwTotalSize)) <br>        { <br>            // We had been conservative about making sure the structure was  <br>            // big enough.  Unfortunately, not conservative enough.  Hopefully,  <br>            // this will not happen a second time because we are *DOUBLING*  <br>            // the NeededSize. <br>            MessageBox(hwndDlg,  <br>                "Internal Error: Unable to set line configuration.\n" <br>                "Please try again.", <br>                "Oops", MB_OK); <br>            dwSizeofVarString = (lpVarString -&gt; dwNeededSize) * 2; <br>            lReturn = -1; // Lets loop again. <br>        } <br>    } <br>    while (lReturn != SUCCESS); <br> <br>    // Store the configuration information into a global structure <br>    // so it can be set at a later time. <br>    g_dwSizeDeviceConfig = lpVarString -&gt; dwStringSize; <br>    g_lpDeviceConfig = CheckAndReAllocBuffer( <br>            g_lpDeviceConfig, g_dwSizeDeviceConfig+1, <br>            "PreConfigureDevice - Reallocate device config: "); <br> <br>    if (!g_lpDeviceConfig) <br>    { <br>        LocalFree(lpVarString); <br>        return; <br>    } <br> <br>    memcpy(g_lpDeviceConfig,  <br>        ((LPBYTE) lpVarString + lpVarString -&gt; dwStringOffset), <br>        g_dwSizeDeviceConfig); <br> <br>    LocalFree(lpVarString); <br>} <br> <br> <br>// <br>//  FUNCTION: BOOL GetAddressToDial <br>// <br>//  PURPOSE: Get an address to dial from the user. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    TRUE if a valid device and phone number have been entered by <br>//    the user.  FALSE if the user canceled the dialing process. <br>// <br>//  COMMENTS: <br>// <br>//    All this function does is launch the "Dial" dialog. <br>// <br>// <br> <br>BOOL GetAddressToDial() <br>{ <br>    BOOL bRet; <br> <br>    UpdateStatusBar("Getting Number to Dial",1,0); <br>    bRet = DialogBoxParam(hInst, "DialDialog", g_hDlgParentWindow,  <br>        DialDialogProc, 0); <br>    g_hDialog = NULL; <br>    g_hDlgParentWindow = g_hWndMainWindow; <br> <br>    if (bRet == FALSE) <br>        UpdateStatusBar("Dial aborted",1,0); <br> <br>    return bRet; <br>} <br> <br> <br>// <br>//  FUNCTION: DialDialogProc(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Dialog callback procedure for the dialing dialog <br>// <br>//  PARAMETERS: <br>//    hwndDlg - Dialog calling the callback. <br>//    uMsg    - Dialog message. <br>//    wParam  - uMsg specific. <br>//    lParam  - uMsg specific. <br>// <br>//  RETURN VALUE: <br>//    returns 0 - command handled. <br>//    returns non-0 - command unhandled <br>// <br>//  COMMENTS: <br>// <br>//    This is the dialog to get the phone number and line device  <br>//    from the user.  All the relavent information is stored in global <br>//    variables to be used later if the dialog returns successfully. <br>// <br>// <br> <br> <br>BOOL CALLBACK DialDialogProc( <br>    HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    // Static variables to store the information from last time the <br>    // "Dial" dialog was displayed.  That way the phone number can be <br>    // typed once but used several times. <br> <br>    static char szCountryName[512] = ""; <br>    static char szAreaCode[256] = "Not Valid"; <br>    static char szPhoneNumber[512] = "Not Valid"; <br>    static DWORD dwUsedDeviceID = MAXDWORD; <br>    static BOOL bUsedCountryAndArea = FALSE; <br>    static BOOL bHistoryValid = FALSE; <br> <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>            DWORD dwCountryID = 0; <br> <br>            // Store the Dialog Window so it can be dismissed if necessary <br>            g_hDialog = hwndDlg; <br> <br>            // This dialog should be parent to all dialogs. <br>            g_hDlgParentWindow = hwndDlg; <br> <br>            // Initialize the Dialog Box. Lots to do here. <br> <br>            FillTAPILine(hwndDlg); <br>            if (g_lpDeviceConfig) <br>            { <br>                LocalFree(g_lpDeviceConfig); <br>                g_lpDeviceConfig = NULL; <br>            } <br> <br>            // If there is a valid history, use it to initialize the controls. <br>            if (bHistoryValid) <br>            { <br>                FillLocationInfo(hwndDlg, NULL, NULL, NULL); <br>                FillCountryCodeList(hwndDlg, 0); <br> <br>                SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, CB_SELECTSTRING, <br>                    (WPARAM) -1, (LPARAM) (LPCTSTR) szCountryName); <br> <br>                SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER, WM_SETTEXT, 0, <br>                    (LPARAM) (LPCTSTR) szPhoneNumber); <br>                     <br>                SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES,  <br>                    BM_SETCHECK, (WPARAM) bUsedCountryAndArea, 0); <br> <br>                SendDlgItemMessage(hwndDlg, IDC_TAPILINE, CB_SETCURSEL, <br>                    g_dwDeviceID, 0); <br>            } <br>            else <br>            { <br>                FillLocationInfo(hwndDlg, NULL, &amp;dwCountryID, szAreaCode); <br>                FillCountryCodeList(hwndDlg, dwCountryID); <br>                SendDlgItemMessage(hwndDlg, IDC_USEDIALINGRULES, <br>                    BM_SETCHECK, 1, 0); <br>            } <br> <br>            SendDlgItemMessage(hwndDlg, IDC_AREACODE, WM_SETTEXT,  <br>                0, (LPARAM) (LPCTSTR) szAreaCode); <br> <br>            UseDialingRules(hwndDlg); <br>            DisplayPhoneNumber(hwndDlg); <br>            VerifyAndWarnUsableLine(hwndDlg); <br> <br>            return TRUE; <br>        } <br> <br>        case WM_COMMAND: <br>        { <br>            switch(LOWORD(wParam)) <br>            { <br>                case IDC_TAPILINE: <br>                    if (HIWORD(wParam) == CBN_SELENDOK) <br>                    { <br>                        if (g_lpDeviceConfig) <br>                        { <br>                            LocalFree(g_lpDeviceConfig); <br>                            g_lpDeviceConfig = NULL; <br>                        } <br>                        DisplayPhoneNumber(hwndDlg); <br>                        VerifyAndWarnUsableLine(hwndDlg); <br>                    } <br>                    return TRUE; <br> <br>                case IDC_CONFIGURELINE: <br>                { <br>                    DWORD dwDeviceID; <br>                    dwDeviceID = SendDlgItemMessage(hwndDlg, IDC_TAPILINE, <br>                        CB_GETCURSEL, 0, 0); <br>                    PreConfigureDevice(hwndDlg, dwDeviceID); <br>                    DisplayPhoneNumber(hwndDlg); <br>                    return TRUE; <br>                } <br> <br>                case IDC_COUNTRYCODE: <br>                    if (HIWORD(wParam) == CBN_SELENDOK) <br>                        DisplayPhoneNumber(hwndDlg); <br>                    return TRUE; <br> <br>                case IDC_AREACODE: <br>                case IDC_PHONENUMBER: <br>                    if (HIWORD(wParam) == EN_CHANGE) <br>                        DisplayPhoneNumber(hwndDlg); <br>                    return TRUE; <br> <br>                case IDC_USEDIALINGRULES: <br>                    if (HIWORD(wParam) == BN_CLICKED) <br>                    { <br>                        UseDialingRules(hwndDlg); <br>                        DisplayPhoneNumber(hwndDlg); <br>                    } <br>                    return TRUE; <br> <br>                case IDC_LOCATION: <br>                    if (HIWORD(wParam) == CBN_CLOSEUP) <br>                    { <br>                        char szCurrentLocation[1024]; <br>                        int nCurrentSelection; <br> <br>                        nCurrentSelection = SendDlgItemMessage(hwndDlg,  <br>                            IDC_LOCATION, CB_GETCURSEL, 0, 0); <br>                        SendDlgItemMessage(hwndDlg, IDC_LOCATION, <br>                            CB_GETLBTEXT, nCurrentSelection,  <br>                            (LPARAM) (LPCTSTR) szCurrentLocation); <br> <br>                        // If the user selected a 'location', make it current. <br>                        FillLocationInfo(hwndDlg, szCurrentLocation, NULL, NULL); <br>                        DisplayPhoneNumber(hwndDlg); <br>                    } <br>                    return TRUE; <br> <br>                case IDC_DIALINGPROPERTIES: <br>                { <br>                    char szAddress[1024]; <br>                    DWORD dwDeviceID; <br>                    long lReturn; <br> <br>                    dwDeviceID = SendDlgItemMessage(hwndDlg, IDC_TAPILINE, <br>                            CB_GETCURSEL, 0, 0); <br> <br>                    SendDlgItemMessage(hwndDlg, IDC_CANONICALNUMBER, <br>                        WM_GETTEXT, 1023, (LPARAM) (LPCTSTR) szAddress); <br>                       <br>                    lReturn = lineTranslateDialog(g_hLineApp, dwDeviceID, <br>                        SAMPLE_TAPI_VERSION, hwndDlg, szAddress); <br> <br>                    if (lReturn != SUCCESS) <br>                        OutputDebugLineError(lReturn,"lineTranslateDialog: "); <br> <br>                    // The user could have changed the default location, or <br>                    // added or removed a location while in the 'Dialing <br>                    // Properties' dialog.  Refill the Location Info. <br>                    FillLocationInfo(hwndDlg, NULL, NULL, NULL); <br>                    DisplayPhoneNumber(hwndDlg); <br> <br>                    return TRUE; <br>                } <br> <br>                case IDCANCEL: <br>                    EndDialog(hwndDlg, FALSE); <br>                    return TRUE; <br> <br>                case IDC_DIAL: <br>                { <br>                    // The Dial button has to be enabled and the line has <br>                    // to be currently usable to continue. <br>                    if (!(IsWindowEnabled((HWND)lParam) &amp;&amp; <br>                          VerifyAndWarnUsableLine(hwndDlg))) <br>                        return TRUE; <br> <br>                    DisplayPhoneNumber(hwndDlg); <br> <br>                    // Get the displayable and dialable numbers and store <br>                    // them in global variables to be used while dialing. <br>                    SendDlgItemMessage(hwndDlg, IDC_DISPLAYABLENUMBER, <br>                        WM_GETTEXT, 1023, (LPARAM) (LPCTSTR) g_szDisplayableAddress); <br> <br>                    SendDlgItemMessage(hwndDlg, IDC_DIALABLENUMBER, <br>                        WM_GETTEXT, 1023, (LPARAM) (LPCTSTR) g_szDialableAddress); <br> <br>                    // Store all the relavent information in static </code></pre>
<p>
</p>
<pre><code>// variables so they will be available the next time a <br>                    // number is dialed. <br>                    SendDlgItemMessage(hwndDlg, IDC_COUNTRYCODE, <br>                        WM_GETTEXT, 511, (LPARAM) (LPCTSTR) szCountryName); <br> <br>                    SendDlgItemMessage(hwndDlg, IDC_AREACODE, <br>                        WM_GETTEXT, 255, (LPARAM) (LPCTSTR) szAreaCode); <br> <br>                    SendDlgItemMessage(hwndDlg, IDC_PHONENUMBER, <br>                        WM_GETTEXT, 511, (LPARAM) (LPCTSTR) szPhoneNumber); <br> <br>                    bUsedCountryAndArea = (BOOL) SendDlgItemMessage(hwndDlg, <br>                        IDC_USEDIALINGRULES, BM_GETCHECK, 0, 0); <br> <br>                    bHistoryValid = TRUE; <br> <br>                    EndDialog(hwndDlg, TRUE); <br>                    return TRUE; <br>                } <br> <br> <br>                // This message is actually posted to the dialog from the <br>                // lineCallbackFunc when it receives a  <br>                // LINEDEVSTATE_TRANSLATECHANGE message.  Notify the user and <br>                // retranslate the number.  Also refill the Location Info <br>                // since this could have been generated by a location change. <br>                case IDC_CONFIGURATIONCHANGED: <br>                { <br>                    FillLocationInfo(hwndDlg, NULL, NULL, NULL); <br>                    DisplayPhoneNumber(hwndDlg); <br> <br>                    MessageBox(hwndDlg,  <br>                        "Location Configuration has been changed.", <br>                        "Warning",MB_OK); <br> <br>                    return TRUE; <br>                } <br> <br>                // If we get a LINE_CREATE message, all that needs to be done <br>                // is to reset this controls contents.  The selected line <br>                // won't change and no lines will be removed. <br>                case IDC_LINECREATE: <br>                { <br>                    FillTAPILine(hwndDlg); <br>                    return TRUE; <br>                } <br> <br>                default: <br>                    break; <br>            } <br> <br>            break; <br>        } <br> <br>        // This dialog has the DS_CONTEXTMENU flag so that the right mouse  <br>        // button will send this message.  Bring up the appropriate help page. <br>        case WM_CONTEXTMENU: <br>        { <br> <br>            if (hwndDlg != (HWND) wParam) <br>                WinHelp ((HWND)wParam, <br>                    "TAPICOMM.HLP", <br>                     HELP_CONTEXTMENU, <br>                    (DWORD)(LPVOID) g_adwSampleMenuHelpIDs); <br>            break; <br>        } <br> <br>        // Bring up the appropriate help page. <br>        case WM_HELP: <br>        { <br>            LPHELPINFO lphi; <br> <br>            lphi = (LPHELPINFO)lParam; <br>            if ((lphi-&gt;iContextType == HELPINFO_WINDOW) &amp;&amp; <br>                (hwndDlg != lphi-&gt;hItemHandle) &amp;&amp; <br>                (lphi-&gt;iCtrlId &lt; IDC_NOHELPCONTROLS)) <br>            { <br>                WinHelp (lphi-&gt;hItemHandle, <br>                    "TAPICOMM.HLP", <br>                    HELP_WM_HELP, <br>                    (DWORD)(LPVOID) g_adwSampleMenuHelpIDs); <br>            } <br> <br>        return TRUE;  <br>        } <br> <br>        default: <br>            break; <br>    } <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
