<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATSP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5173"></a>ATSP.C</h2>
<pre><code>/*++ <br> <br>Copyright 1995 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    atsp.c <br> <br>Notes: <br> <br>--*/ <br> <br> <br>#include "atsp.h" <br> <br> <br>BOOL <br>WINAPI <br>DllMain( <br>    HANDLE  hDLL, <br>    DWORD   dwReason, <br>    LPVOID  lpReserved <br>    ) <br>{ <br>    if (dwReason ==  DLL_PROCESS_ATTACH) <br>    { <br>        ghInst = hDLL; <br> <br>#if DBG <br>        { <br>            HKEY    hKey; <br>            DWORD   dwDataSize, dwDataType; <br>            char    szAtsp32DebugLevel[] = "Atsp32DebugLevel"; <br> <br> <br>            RegOpenKeyExA( <br>                HKEY_LOCAL_MACHINE, <br>                gszAtspKey, <br>                0, <br>                KEY_ALL_ACCESS, <br>                &amp;hKey <br>                ); <br> <br>            dwDataSize = sizeof (DWORD); <br>            gdwDebugLevel=0; <br> <br>            RegQueryValueEx( <br>                hKey, <br>                szAtsp32DebugLevel, <br>                0, <br>                &amp;dwDataType, <br>                (LPBYTE) &amp;gdwDebugLevel, <br>                &amp;dwDataSize <br>                ); <br> <br>            RegCloseKey (hKey); <br>        } <br>#endif <br> <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>void <br>CommThread( <br>    PDRVLINE    pLine <br>    ) <br>{ <br>    char            buf[4]; <br>    DWORD           dwThreadID = GetCurrentThreadId(), dwNumBytes; <br>    HANDLE          hComm = pLine-&gt;hComm, hEvent; <br>    LPOVERLAPPED    pOverlapped = &amp;pLine-&gt;Overlapped; <br> <br> <br>    DBGOUT(( <br>        3, <br>        "CommThread (id=%d): enter, port=%s", <br>        dwThreadID, <br>        pLine-&gt;szComm <br>        )); <br> <br>    hEvent = pOverlapped-&gt;hEvent; <br>    buf[0] = buf[1] = '.'; <br> <br> <br>    // <br>    // Loop waiting for i/o to complete (either the Write done in <br>    // TSPI_lineMakeCall or the Reads done to retrieve status info). <br>    // Note that TSPI_lineDrop or TSPI_lineCloseCall may set the <br>    // event to alert us that they're tearing down the call, in <br>    // which case we just exit. <br>    // <br> <br>    for (;;) <br>    { <br>        if (WaitForSingleObject (hEvent, ATSP_TIMEOUT) == WAIT_OBJECT_0) <br>        { <br>            if (pLine-&gt;bDropInProgress == TRUE) <br>            { <br>                DBGOUT((2, "CommThread (id=%d): drop in progress")); <br>                goto CommThread_exit; <br>            } <br> <br>            GetOverlappedResult (hComm, pOverlapped, &amp;dwNumBytes, FALSE); <br>            ResetEvent (hEvent); <br>        } <br>        else <br>        { <br>            DBGOUT((2, "CommThread (id=%d): wait timeout")); <br>            SetCallState (pLine, LINECALLSTATE_IDLE, 0); <br>            goto CommThread_exit; <br>        } <br> <br>        buf[1] &amp;= 0x7f; // nuke the parity bit <br> <br>        DBGOUT(( <br>            3, <br>            "CommThread (id=%d): read '%c'", <br>            dwThreadID, <br>            (buf[1] == '\r' ? '.' : buf[1]) <br>            )); <br> <br>        switch ((buf[0] &lt;&lt; 8) + buf[1]) <br>        { <br>        case 'CT':  // "CONNECT" <br>        case 'OK':  // "OK" <br> <br>            SetCallState (pLine, LINECALLSTATE_CONNECTED, 0); <br>            goto CommThread_exit; <br> <br>        case 'SY':  // "BUSY" <br>        case 'OR':  // "ERROR" <br>        case 'NO':  // "NO ANSWER", "NO DIALTONE", "NO CARRIER" <br> <br>            SetCallState (pLine, LINECALLSTATE_IDLE, 0); <br>            goto CommThread_exit; <br> <br>        default: <br> <br>            break; <br>        } <br> <br>        buf[0] = buf[1]; <br> <br>        ZeroMemory (pOverlapped, sizeof (OVERLAPPED) - sizeof (HANDLE)); <br>        ReadFile (hComm, &amp;buf[1], 1, &amp;dwNumBytes, pOverlapped); <br>    } <br> <br>CommThread_exit: <br> <br>    CloseHandle (hEvent); <br>    DBGOUT((3, "CommThread (id=%d): exit", dwThreadID)); <br>    ExitThread (0); <br>} <br> <br> <br>// <br>// We get a slough of C4047 (different levels of indrection) warnings down <br>// below in the initialization of FUNC_PARAM structs as a result of the <br>// real func prototypes having params that are types other than DWORDs, <br>// so since these are known non-interesting warnings just turn them off <br>// <br> <br>#pragma warning (disable:4047) <br> <br> <br>// <br>// --------------------------- TAPI_lineXxx funcs ----------------------------- <br>// <br> <br>LONG <br>TSPIAPI <br>TSPI_lineClose( <br>    HDRVLINE    hdLine <br>    ) <br>{ <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdLine, hdLine } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineClose", <br>        1, <br>        params, <br>    }; <br>#endif <br> <br>    Prolog (&amp;info); <br>    DrvFree ((PDRVLINE) hdLine); <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineCloseCall( <br>    HDRVCALL    hdCall <br>    ) <br>{ <br>    PDRVLINE    pLine = (PDRVLINE) hdCall; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdCall, hdCall  } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineCloseCall", <br>        1, <br>        params <br>    }; <br>#endif <br> <br> <br>    // <br>    // Note that in TAPI 2.0 TSPI_lineCloseCall can get called <br>    // without TSPI_lineDrop ever being called, so we need to <br>    // be prepared for either case. <br>    // <br> <br>    Prolog (&amp;info); <br>    DropActiveCall (pLine); <br>    pLine-&gt;htCall = NULL; <br>    return (Epilog (&amp;info, 0)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineConditionalMediaDetection( <br>    HDRVLINE            hdLine, <br>    DWORD               dwMediaModes, <br>    LPLINECALLPARAMS    const lpCallParams <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdLine,        hdLine       }, <br>        { "dwMediaModes",   dwMediaModes }, <br>        { gszlpCallParams,  lpCallParams } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineConditionalMediaDetection", <br>        3, <br>        params <br>    }; <br>#endif <br> <br> <br>    // <br>    // This func is really a no-op for us, since we don't look <br>    // for incoming calls (though we do say we support them to <br>    // make apps happy) <br>    // <br> <br>    Prolog (&amp;info); <br>    return (Epilog (&amp;info, 0)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineDrop( <br>    DRV_REQUESTID   dwRequestID, <br>    HDRVCALL        hdCall, <br>    LPCSTR          lpsUserUserInfo, <br>    DWORD           dwSize <br>    ) <br>{ <br>    PDRVLINE    pLine = (PDRVLINE) hdCall; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszdwRequestID,        dwRequestID     }, <br>        { gszhdCall,             hdCall          }, <br>        { "lpsUserUserInfo",    lpsUserUserInfo }, <br>        { gszdwSize,             dwSize          } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineDrop", <br>        4, <br>        params <br>    }; <br>#endif <br> <br> <br>    Prolog (&amp;info); <br>    DropActiveCall (pLine); <br>    SetCallState (pLine, LINECALLSTATE_IDLE, 0); <br>    (*gpfnCompletionProc)(dwRequestID, 0); <br>    return (Epilog (&amp;info, dwRequestID)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetAddressCaps( <br>    DWORD              dwDeviceID, <br>    DWORD              dwAddressID, <br>    DWORD              dwTSPIVersion, <br>    DWORD              dwExtVersion, <br>    LPLINEADDRESSCAPS  lpAddressCaps <br>    ) <br>{ <br> <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszdwDeviceID,     dwDeviceID      }, <br>        { "dwAddressID",    dwAddressID     }, <br>        { "dwTSPIVersion",  dwTSPIVersion   }, <br>        { "dwExtVersion",   dwExtVersion    }, <br>        { "lpAddressCaps",  lpAddressCaps   } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetAddressCaps", <br>        5, <br>        params <br>    }; <br>#endif <br> <br>    LONG        lResult = 0; <br> <br> <br>    Prolog (&amp;info); <br> <br>    if (dwAddressID != 0) <br>    { <br>        lResult = LINEERR_INVALADDRESSID; <br>    } <br> <br>    lpAddressCaps-&gt;dwNeededSize = <br>    lpAddressCaps-&gt;dwUsedSize   = sizeof(LINEADDRESSCAPS); <br> <br>    lpAddressCaps-&gt;dwLineDeviceID       = dwDeviceID; <br>    lpAddressCaps-&gt;dwAddressSharing     = LINEADDRESSSHARING_PRIVATE; <br>    lpAddressCaps-&gt;dwCallInfoStates     = LINECALLINFOSTATE_MEDIAMODE | <br>                                          LINECALLINFOSTATE_APPSPECIFIC; <br>    lpAddressCaps-&gt;dwCallerIDFlags      = <br>    lpAddressCaps-&gt;dwCalledIDFlags      = <br>    lpAddressCaps-&gt;dwRedirectionIDFlags = <br>    lpAddressCaps-&gt;dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL; <br>    lpAddressCaps-&gt;dwCallStates         = LINECALLSTATE_IDLE | <br>                                          LINECALLSTATE_OFFERING | <br>                                          LINECALLSTATE_ACCEPTED | <br>                                          LINECALLSTATE_DIALTONE | <br>                                          LINECALLSTATE_DIALING | <br>                                          LINECALLSTATE_CONNECTED | <br>                                          LINECALLSTATE_PROCEEDING | <br>                                          LINECALLSTATE_DISCONNECTED | <br>                                          LINECALLSTATE_UNKNOWN; <br>    lpAddressCaps-&gt;dwDialToneModes      = LINEDIALTONEMODE_UNAVAIL; <br>    lpAddressCaps-&gt;dwBusyModes          = LINEBUSYMODE_UNAVAIL; <br>    lpAddressCaps-&gt;dwSpecialInfo        = LINESPECIALINFO_UNAVAIL; <br>    lpAddressCaps-&gt;dwDisconnectModes    = LINEDISCONNECTMODE_NORMAL | <br>                                          LINEDISCONNECTMODE_BUSY | <br>                                          LINEDISCONNECTMODE_NOANSWER | <br>                                          LINEDISCONNECTMODE_UNAVAIL | <br>                                          LINEDISCONNECTMODE_NODIALTONE; <br>    lpAddressCaps-&gt;dwMaxNumActiveCalls  = 1; <br>    lpAddressCaps-&gt;dwAddrCapFlags       = LINEADDRCAPFLAGS_DIALED; <br>    lpAddressCaps-&gt;dwCallFeatures       = LINECALLFEATURE_ACCEPT | <br>                                          LINECALLFEATURE_ANSWER | <br>                                          LINECALLFEATURE_DROP | <br>                                          LINECALLFEATURE_SETCALLPARAMS; <br>    lpAddressCaps-&gt;dwAddressFeatures    = LINEADDRFEATURE_MAKECALL; <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetAddressStatus( <br>    HDRVLINE            hdLine, <br>    DWORD               dwAddressID, <br>    LPLINEADDRESSSTATUS lpAddressStatus <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdLine,             hdLine         }, <br>        { "dwAddressID",        dwAddressID     }, <br>        { "lpAddressStatus",    lpAddressStatus } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetAddressStatus", <br>        3, <br>        params <br>    }; <br>#endif <br> <br>    LONG        lResult = 0; <br>    PDRVLINE    pLine = (PDRVLINE) hdLine; <br> <br> <br>    Prolog (&amp;info); <br> <br>    lpAddressStatus-&gt;dwNeededSize = <br>    lpAddressStatus-&gt;dwUsedSize   = sizeof(LINEADDRESSSTATUS); <br> <br>    lpAddressStatus-&gt;dwNumActiveCalls  = (pLine-&gt;htCall ? 1 : 0); <br>    lpAddressStatus-&gt;dwAddressFeatures = LINEADDRFEATURE_MAKECALL; <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetCallAddressID( <br>    HDRVCALL            hdCall, <br>    LPDWORD             lpdwAddressID <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdCall,        hdCall          }, <br>        { "lpdwAddressID",  lpdwAddressID   } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetCallAddressID", <br>        2, <br>        params <br>    }; <br>#endif <br> <br> <br>    // <br>    // We only support 1 address (id=0) <br>    // <br> <br>    Prolog (&amp;info); <br>    *lpdwAddressID = 0; <br>    return (Epilog (&amp;info, 0)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetCallInfo( <br>    HDRVCALL        hdCall, <br>    LPLINECALLINFO  lpLineInfo <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdCall,     hdCall      }, <br>        { "lpLineInfo", lpLineInfo  } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetCallInfo", <br>        2, <br>        params <br>    }; <br>#endif <br>    LONG        lResult = 0; <br>    PDRVLINE    pLine = (PDRVLINE) hdCall; <br> <br> <br>    Prolog (&amp;info); <br> <br>    lpLineInfo-&gt;dwNeededSize = <br>    lpLineInfo-&gt;dwUsedSize   = sizeof(LINECALLINFO); <br> <br>    lpLineInfo-&gt;dwBearerMode         = LINEBEARERMODE_VOICE; <br>    lpLineInfo-&gt;dwMediaMode          = pLine-&gt;dwMediaMode; <br>    lpLineInfo-&gt;dwCallStates         = LINECALLSTATE_IDLE | <br>                                       LINECALLSTATE_DIALTONE | <br>                                       LINECALLSTATE_DIALING | <br>                                       LINECALLSTATE_CONNECTED | <br>                                       LINECALLSTATE_PROCEEDING | <br>                                       LINECALLSTATE_DISCONNECTED | <br>                                       LINECALLSTATE_UNKNOWN; <br>    lpLineInfo-&gt;dwOrigin             = LINECALLORIGIN_OUTBOUND; <br>    lpLineInfo-&gt;dwReason             = LINECALLREASON_DIRECT; <br>    lpLineInfo-&gt;dwCallerIDFlags      = <br>    lpLineInfo-&gt;dwCalledIDFlags      = <br>    lpLineInfo-&gt;dwConnectedIDFlags   = <br>    lpLineInfo-&gt;dwRedirectionIDFlags = <br>    lpLineInfo-&gt;dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL; <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetCallStatus( <br>    HDRVCALL            hdCall, <br>    LPLINECALLSTATUS    lpLineStatus <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdCall,         hdCall          }, <br>        { "lpLineStatus",   lpLineStatus    } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetCallStatus", <br>        2, <br>        params <br>    }; <br>#endif <br>    LONG        lResult = 0; <br>    PDRVLINE    pLine = (PDRVLINE) hdCall; <br> <br> <br>    Prolog (&amp;info); <br> <br>    lpLineStatus-&gt;dwNeededSize = <br>    lpLineStatus-&gt;dwUsedSize   = sizeof(LINECALLSTATUS); <br> <br>    lpLineStatus-&gt;dwCallState  = pLine-&gt;dwCallState; <br> <br>    if (pLine-&gt;dwCallState != LINECALLSTATE_IDLE) <br>    { <br>        lpLineStatus-&gt;dwCallFeatures = LINECALLFEATURE_DROP; <br>    } <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetDevCaps( <br>    DWORD           dwDeviceID, <br>    DWORD           dwTSPIVersion, <br>    DWORD           dwExtVersion, <br>    LPLINEDEVCAPS   lpLineDevCaps <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszdwDeviceID,     dwDeviceID      }, <br>        { "dwTSPIVersion",  dwTSPIVersion   }, <br>        { "dwExtVersion",   dwExtVersion    }, <br>        { "lpLineDevCaps",  lpLineDevCaps   } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetDevCaps", <br>        4, <br>        params <br>    }; <br>#endif <br> <br>    LONG            lResult = 0; <br>    static WCHAR    szProviderInfo[] = L"AT-compatible modem service provider"; <br> <br>    #define PROVIDER_INFO_SIZE (37 * sizeof (WCHAR)) <br> <br>    Prolog (&amp;info); <br> <br>    lpLineDevCaps-&gt;dwNeededSize = sizeof (LINEDEVCAPS) + PROVIDER_INFO_SIZE + <br>        (MAX_DEV_NAME_LENGTH + 1) * sizeof (WCHAR); <br> <br>    if (lpLineDevCaps-&gt;dwTotalSize &gt;= lpLineDevCaps-&gt;dwNeededSize) <br>    { <br>        #define LINECONFIG_SIZE   (2 * (MAX_DEV_NAME_LENGTH + 1) + 40) <br> <br>        char    szLineConfig[LINECONFIG_SIZE], szLineN[16], *p; <br>        HKEY    hKey; <br>        DWORD   dwDataSize, dwDataType; <br> <br> <br>        lpLineDevCaps-&gt;dwUsedSize = lpLineDevCaps-&gt;dwNeededSize; <br> <br>        lpLineDevCaps-&gt;dwProviderInfoSize   = PROVIDER_INFO_SIZE; <br>        lpLineDevCaps-&gt;dwProviderInfoOffset = sizeof(LINEDEVCAPS); <br> <br>        My_lstrcpyW ((WCHAR *)(lpLineDevCaps + 1), szProviderInfo); <br> <br>        RegOpenKeyEx( <br>            HKEY_LOCAL_MACHINE, <br>            gszAtspKey, <br>            0, <br>            KEY_ALL_ACCESS, <br>            &amp;hKey <br>            ); <br> <br>        dwDataSize = LINECONFIG_SIZE; <br>        wsprintf (szLineN, "Line%d", dwDeviceID - gdwLineDeviceIDBase); <br>        lstrcpy (szLineConfig, gszDefLineConfigParams); <br> <br>        RegQueryValueEx( <br>            hKey, <br>            szLineN, <br>            0, <br>            &amp;dwDataType, <br>            (LPBYTE) szLineConfig, <br>            &amp;dwDataSize <br>            ); <br> <br>        RegCloseKey (hKey); <br> <br>        for (p = szLineConfig; *p != ','; p++); <br>        *p = 0; <br> <br>        lpLineDevCaps-&gt;dwLineNameSize   = (lstrlen (szLineConfig) + 1) * <br>            sizeof (WCHAR); <br>        lpLineDevCaps-&gt;dwLineNameOffset = sizeof(LINEDEVCAPS) + <br>            PROVIDER_INFO_SIZE; <br> <br>        MultiByteToWideChar( <br>            CP_ACP, <br>            MB_PRECOMPOSED, <br>            szLineConfig, <br>            -1, <br>            (WCHAR *) ((LPBYTE) (lpLineDevCaps + 1) + PROVIDER_INFO_SIZE), <br>            lpLineDevCaps-&gt;dwLineNameSize <br>            ); <br>    } <br>    else <br>    { <br>        lpLineDevCaps-&gt;dwUsedSize = sizeof(LINEDEVCAPS); <br>    } <br> <br>    lpLineDevCaps-&gt;dwStringFormat      = STRINGFORMAT_ASCII; <br>    lpLineDevCaps-&gt;dwAddressModes      = LINEADDRESSMODE_ADDRESSID; <br>    lpLineDevCaps-&gt;dwNumAddresses      = 1; <br>    lpLineDevCaps-&gt;dwBearerModes       = LINEBEARERMODE_VOICE; <br>    lpLineDevCaps-&gt;dwMaxRate           = 9600; <br>    lpLineDevCaps-&gt;dwMediaModes        = LINEMEDIAMODE_INTERACTIVEVOICE | <br>                                         LINEMEDIAMODE_DATAMODEM; <br>    lpLineDevCaps-&gt;dwDevCapFlags       = LINEDEVCAPFLAGS_CLOSEDROP | <br>                                         LINEDEVCAPFLAGS_DIALBILLING | <br>                                         LINEDEVCAPFLAGS_DIALQUIET | <br>                                         LINEDEVCAPFLAGS_DIALDIALTONE; <br>    lpLineDevCaps-&gt;dwMaxNumActiveCalls = 1; <br>    lpLineDevCaps-&gt;dwRingModes         = 1; <br>    lpLineDevCaps-&gt;dwLineFeatures      = LINEFEATURE_MAKECALL; <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetID( <br>    HDRVLINE    hdLine, <br>    DWORD       dwAddressID, <br>    HDRVCALL    hdCall, <br>    DWORD       dwSelect, <br>    LPVARSTRING lpDeviceID, <br>    LPCWSTR     lpszDeviceClass, <br>    HANDLE      hTargetProcess <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdLine,             hdLine          }, <br>        { "dwAddressID",        dwAddressID     }, <br>        { gszhdCall,             hdCall          }, <br>        { "dwSelect",           dwSelect        }, <br>        { "lpDeviceID",         lpDeviceID      }, <br>        { "lpszDeviceClass",    lpszDeviceClass }, <br>        { "hTargetProcess",     hTargetProcess  } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetID", <br>        7, <br>        params <br>    }; <br>#endif <br> <br>    DWORD       dwNeededSize = sizeof(VARSTRING) + sizeof (DWORD); <br>    LONG        lResult = 0; <br>    PDRVLINE    pLine = (dwSelect == LINECALLSELECT_CALL ? <br>                    (PDRVLINE) hdCall : (PDRVLINE) hdLine); <br> <br> <br>    Prolog (&amp;info); <br> <br>    if (lstrcmpiW (lpszDeviceClass, L"tapi/line") == 0) <br>    { <br>        if (lpDeviceID-&gt;dwTotalSize &lt; dwNeededSize) <br>        { <br>            lpDeviceID-&gt;dwUsedSize = 3*sizeof(DWORD); <br>        } <br>        else <br>        { <br>            lpDeviceID-&gt;dwUsedSize = dwNeededSize; <br> <br>            lpDeviceID-&gt;dwStringFormat = STRINGFORMAT_BINARY; <br>            lpDeviceID-&gt;dwStringSize   = sizeof(DWORD); <br>            lpDeviceID-&gt;dwStringOffset = sizeof(VARSTRING); <br> <br>            *((LPDWORD)(lpDeviceID + 1)) = pLine-&gt;dwDeviceID; <br>        } <br> <br>        lpDeviceID-&gt;dwNeededSize = dwNeededSize; <br>    } <br>    else if (lstrcmpiW (lpszDeviceClass, L"comm/datamodem") == 0) <br>    { <br>        dwNeededSize += (strlen (pLine-&gt;szComm) + 1) * sizeof (WCHAR); <br> <br>        if (lpDeviceID-&gt;dwTotalSize &lt; dwNeededSize) <br>        { <br>            lpDeviceID-&gt;dwUsedSize = 3 * sizeof(DWORD); <br>        } <br>        else <br>        { <br>            HANDLE hCommDup = NULL; <br> <br> <br>            if (!pLine-&gt;htCall) <br>            { <br>                DBGOUT((1, "TSPI_lineGetID32: error, no active call")); <br> <br>                lResult = LINEERR_OPERATIONFAILED; <br> <br>                goto TSPI_lineGetID_epilog; <br>            } <br> <br>            if (!DuplicateHandle( <br>                    GetCurrentProcess(), <br>                    pLine-&gt;hComm, <br>                    hTargetProcess, <br>                    &amp;hCommDup, <br>                    0, <br>                    TRUE, <br>                    DUPLICATE_SAME_ACCESS <br>                    )) <br>            { <br>                DBGOUT(( <br>                    1, <br>                    "TSPI_lineGetID: DupHandle failed, err=%ld", <br>                    GetLastError() <br>                    )); <br> <br>                lResult = LINEERR_OPERATIONFAILED; <br> <br>                goto TSPI_lineGetID_epilog; <br>            } <br> <br>            lpDeviceID-&gt;dwUsedSize = dwNeededSize; <br> <br>            lpDeviceID-&gt;dwStringFormat = STRINGFORMAT_BINARY; <br>            lpDeviceID-&gt;dwStringSize   = dwNeededSize - sizeof(VARSTRING); <br>            lpDeviceID-&gt;dwStringOffset = sizeof(VARSTRING); <br> <br>            *((HANDLE *)(lpDeviceID + 1)) = hCommDup; <br> <br>            lstrcpy( <br>                ((char *)(lpDeviceID + 1)) + sizeof (HANDLE), <br>                pLine-&gt;szComm <br>                ); <br> <br>            MultiByteToWideChar( <br>                CP_ACP, <br>                0, <br>                pLine-&gt;szComm, <br>                -1, <br>                ((WCHAR *)(lpDeviceID + 1)) + sizeof (HANDLE), <br>                256 <br>                ); <br>        } <br> <br>        lpDeviceID-&gt;dwNeededSize = dwNeededSize; <br>    } <br>    else <br>    { <br>        lResult = LINEERR_NODEVICE; <br>    } <br> <br>TSPI_lineGetID_epilog: <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetLineDevStatus( <br>    HDRVLINE        hdLine, <br>    LPLINEDEVSTATUS lpLineDevStatus <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdLine,            hdLine          }, <br>        { "lpLineDevStatus",    lpLineDevStatus } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetLineDevStatus", <br>        2, <br>        params <br>    }; <br>#endif <br> <br>    LONG        lResult = 0; <br>    PDRVLINE    pLine = (PDRVLINE) hdLine; <br> <br> <br>    Prolog (&amp;info); <br> <br>    lpLineDevStatus-&gt;dwUsedSize = <br>    lpLineDevStatus-&gt;dwNeededSize = sizeof (LINEDEVSTATUS); <br> <br>    lpLineDevStatus-&gt;dwNumActiveCalls = (pLine-&gt;htCall ? 1 : 0); <br>    //lpLineDevStatus-&gt;dwLineFeatures = <br>    lpLineDevStatus-&gt;dwDevStatusFlags = LINEDEVSTATUSFLAGS_CONNECTED | <br>                                        LINEDEVSTATUSFLAGS_INSERVICE; <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineGetNumAddressIDs( <br>    HDRVLINE    hdLine, <br>    LPDWORD     lpdwNumAddressIDs <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdLine,            hdLine            }, <br>        { "lpdwNumAddressIDs",  lpdwNumAddressIDs } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineGetNumAddressIDs", <br>        2, <br>        params <br>    }; <br>#endif <br> <br>    LONG        lResult = 0; <br>    PDRVLINE    pLine = (PDRVLINE) hdLine; <br> <br> <br>    // <br>    // We only support 1 address (id=0) <br>    // <br> <br>    Prolog (&amp;info); <br>    *lpdwNumAddressIDs = 1; <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineMakeCall( <br>    DRV_REQUESTID       dwRequestID, <br>    HDRVLINE            hdLine, <br>    HTAPICALL           htCall, <br>    LPHDRVCALL          lphdCall, <br>    LPCWSTR             lpszDestAddress, <br>    DWORD               dwCountryCode, <br>    LPLINECALLPARAMS    const lpCallParams <br>    ) <br>{ <br>    char        szCommands[64], szCommand[64], szDestAddress[128]; <br>    DWORD       dwThreadID, dwNumBytes, dwError; <br>    PDRVLINE    pLine = (PDRVLINE) hdLine; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszdwRequestID,       dwRequestID     }, <br>        { gszhdLine,            hdLine          }, <br>        { "htCall",             htCall          }, <br>        { "lphdCall",           lphdCall        }, <br>        { "lpszDestAddress",    szDestAddress   }, <br>        { "dwCountryCode",      dwCountryCode   }, <br>        { gszlpCallParams,      lpCallParams    } <br>    }; <br>    FUNC_INFO info = <br>    { <br>        "TSPI_lineMakeCall", <br>        7, <br>        params <br>    }; <br>#endif <br> <br> <br>    if (lpszDestAddress) <br>    { <br>        WideCharToMultiByte( <br>            CP_ACP, <br>            0, <br>            lpszDestAddress, <br>            -1, <br>            (LPSTR) szDestAddress, <br>            128, <br>            NULL, <br>            NULL <br>            ); <br>    } <br> <br>    Prolog (&amp;info); <br> <br> <br>    // <br>    // Check to see if there's already another call <br>    // <br> <br>    if (pLine-&gt;htCall) <br>    { <br>        (*gpfnCompletionProc)(dwRequestID, LINEERR_CALLUNAVAIL); <br>        goto TSPI_lineMakeCall_return; <br>    } <br> <br> <br>    // <br>    // Since we don't support TSPI_lineDial, fail if app tries <br>    // to pass a NULL lpszDestAddress (implying that app just <br>    // wants to go offhook) <br>    // <br> <br>    if (lpszDestAddress == NULL) <br>    { <br>        (*gpfnCompletionProc)(dwRequestID, LINEERR_INVALADDRESS); <br>        goto TSPI_lineMakeCall_return; <br>    } <br> <br> <br>    // <br>    // Get the line's config info <br>    // <br> <br>    { <br>        HKEY    hKey; <br>        DWORD   dwDataSize, dwDataType; <br>        char    szLineN[8], *pszConfig, *p, *p2; <br> <br> <br>        wsprintf( <br>            szLineN, <br>            "Line%d", <br>            ((PDRVLINE) hdLine)-&gt;dwDeviceID - gdwLineDeviceIDBase <br>            ); <br> <br>        dwDataSize = 256; <br> <br>        pszConfig = DrvAlloc (dwDataSize); <br> <br>        RegOpenKeyEx( <br>            HKEY_LOCAL_MACHINE, <br>            gszAtspKey, <br>            0, <br>            KEY_ALL_ACCESS, <br>            &amp;hKey <br>            ); <br> <br>        RegQueryValueEx( <br>            hKey, <br>            szLineN, <br>            0, <br>            &amp;dwDataType, <br>            (LPBYTE) pszConfig, <br>            &amp;dwDataSize <br>            ); <br> <br>        pszConfig[dwDataSize] = '\0';       // *pszConfig = "MyLine,COM1,L0" <br> <br>        RegCloseKey (hKey); <br> <br> <br>        // <br>        // szComm <br>        // <br> <br>        for (p = pszConfig; *p != ','; p++); <br>        p++;                                // *p = "COM1,L0" <br>        for (p2 = p; *p2 != ','; p2++); <br>        *p2 = 0;                            // *p = "COM1" <br> <br>        lstrcpy (pLine-&gt;szComm, p); <br> <br> <br>        // <br>        // szCommands <br>        // <br> <br>        p2++;                               // *p2 = "L0" <br>        lstrcpy (szCommands, p2); <br> <br>        DrvFree (pszConfig); <br>    } <br> <br> <br>    // <br>    // Open the port <br>    // <br> <br>    if ((pLine-&gt;hComm = CreateFile( <br>            pLine-&gt;szComm, <br>            GENERIC_READ | GENERIC_WRITE, <br>            0, //FILE_SHARE_READ | FILE_SHARE_WRITE,  // BUGBUG <br>            NULL, // no security attrs <br>            OPEN_EXISTING, <br>            FILE_FLAG_OVERLAPPED, <br>            NULL  // no template file <br> <br>            )) == INVALID_HANDLE_VALUE) <br>    { <br>        DBGOUT(( <br>            3, <br>            "TSPI_lineMakeCall: CreateFile(%s) failed, err=%ld", <br>            pLine-&gt;szComm, <br>            GetLastError() <br>            )); <br> <br>        (*gpfnCompletionProc)(dwRequestID, LINEERR_RESOURCEUNAVAIL); <br>        goto TSPI_lineMakeCall_return; <br>    } <br> <br> <br>    // <br>    // Setup up the modem command string.  If there's an initial 'T' <br>    // or 'P' (for Tone or Pulse) in the dest address then disregard <br>    // it.  Also if it's a voice call add the semi colon so we return <br>    // to cmd mode. <br>    // <br> <br>    { <br>        char *p = (char *) szDestAddress; <br> <br> <br>        if (*p == 'T'  ||  *p == 'P') <br>        { <br>            p++; <br>        } <br> <br>        if (lpCallParams &amp;&amp; <br>            lpCallParams-&gt;dwMediaMode != LINEMEDIAMODE_INTERACTIVEVOICE) <br>        { <br>            wsprintf (szCommand, "AT%sDT%s\r", szCommands, p); <br>        } <br>        else <br>        { <br>            wsprintf (szCommand, "AT%sDT%s;\r", szCommands, p); <br>        } <br>    } <br> <br> <br>    // <br>    // Init the data structure &amp; tell tapi our handle to the call <br>    // <br> <br>    pLine-&gt;htCall          = htCall; <br>    pLine-&gt;bDropInProgress = FALSE; <br>    pLine-&gt;dwMediaMode     = (lpCallParams ? lpCallParams-&gt;dwMediaMode : <br>        LINEMEDIAMODE_INTERACTIVEVOICE); <br> <br>    *lphdCall = (HDRVCALL) pLine; <br> <br> <br>    // <br>    // Do an overlapped write, the comm thread will deal with the results <br>    // <br> <br>    pLine-&gt;Overlapped.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL); <br> <br>    if (!WriteFile( <br>            pLine-&gt;hComm, <br>            szCommand, <br>            lstrlen (szCommand), <br>            &amp;dwNumBytes, <br>            &amp;pLine-&gt;Overlapped <br>            ) <br> <br>        &amp;&amp; (dwError = GetLastError()) != ERROR_IO_PENDING) <br>    { <br>        DBGOUT(( <br>            1, <br>            "TSPI_lineMakeCall: WriteFile(%s) failed, error=%d", <br>            pLine-&gt;szComm, <br>            dwError <br>            )); <br> <br>        pLine-&gt;htCall = NULL; <br>        CloseHandle (pLine-&gt;hComm); <br>        CloseHandle (pLine-&gt;Overlapped.hEvent); <br>        (*gpfnCompletionProc)(dwRequestID, LINEERR_OPERATIONFAILED); <br>        goto TSPI_lineMakeCall_return; <br>    } <br> <br> <br>    // <br>    // Complete the requests &amp; set the initial call state <br>    // <br> <br>    (*gpfnCompletionProc)(dwRequestID, 0); <br>    SetCallState (pLine, LINECALLSTATE_DIALING, 0); <br> <br> <br>    // <br>    // Spin the comm thread to handle the results of the Write above <br>    // <br> <br>    { <br>        HANDLE hCommThread; <br> <br> <br>        if (!(hCommThread = CreateThread( <br>                (LPSECURITY_ATTRIBUTES) NULL, <br>                0, <br>                (LPTHREAD_START_ROUTINE) CommThread, <br>                pLine, <br>                0, <br>                &amp;dwThreadID <br>                ))) <br>        { <br>            DBGOUT(( <br>                1, <br>                "TSPI_lineMakeCall: CreateThread failed, err=%ld", <br>                GetLastError() <br>                )); <br> <br>            GetOverlappedResult( <br>                pLine-&gt;hComm, </code></pre>
<p>
</p>
<pre><code>&amp;pLine-&gt;Overlapped, <br>                &amp;dwNumBytes, <br>                TRUE <br>                ); <br> <br>            SetCallState (pLine, LINECALLSTATE_IDLE, 0); <br>            CloseHandle (pLine-&gt;hComm); <br>            CloseHandle (pLine-&gt;Overlapped.hEvent); <br>            goto TSPI_lineMakeCall_return; <br>        } <br> <br>        CloseHandle (hCommThread); <br>    } <br> <br> <br>TSPI_lineMakeCall_return: <br> <br>    return (Epilog (&amp;info, dwRequestID)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineNegotiateTSPIVersion( <br>    DWORD   dwDeviceID, <br>    DWORD   dwLowVersion, <br>    DWORD   dwHighVersion, <br>    LPDWORD lpdwTSPIVersion <br>    ) <br>{ <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszdwDeviceID,        dwDeviceID      }, <br>        { "dwLowVersion",       dwLowVersion    }, <br>        { "dwHighVersion",      dwHighVersion   }, <br>        { "lpdwTSPIVersion",    lpdwTSPIVersion } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineNegotiateTSPIVersion", <br>        4, <br>        params <br>    }; <br>#endif <br> <br>    Prolog (&amp;info); <br>    *lpdwTSPIVersion = 0x00020000; <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineOpen( <br>    DWORD       dwDeviceID, <br>    HTAPILINE   htLine, <br>    LPHDRVLINE  lphdLine, <br>    DWORD       dwTSPIVersion, <br>    LINEEVENT   lpfnEventProc <br>    ) <br>{ <br>    LONG        lResult; <br>    PDRVLINE    pLine; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszdwDeviceID,    dwDeviceID      }, <br>        { "htLine",         htLine          }, <br>        { "lphdLine",       lphdLine        }, <br>        { "dwTSPIVersion",  dwTSPIVersion   }, <br>        { "lpfnEventProc",  lpfnEventProc   } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineOpen", <br>        5, <br>        params <br>    }; <br>#endif <br> <br> <br>    Prolog (&amp;info); <br> <br>    if ((pLine = DrvAlloc (sizeof (DRVLINE)))) <br>    { <br>        pLine-&gt;htLine       = htLine; <br>        pLine-&gt;pfnEventProc = lpfnEventProc; <br>        pLine-&gt;dwDeviceID   = dwDeviceID; <br> <br>        *lphdLine = (HDRVLINE) pLine; <br> <br>        lResult = 0; <br>    } <br>    else <br>    { <br>        lResult = LINEERR_NOMEM; <br>    } <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_lineSetDefaultMediaDetection( <br>    HDRVLINE    hdLine, <br>    DWORD       dwMediaModes <br>    ) <br>{ <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { gszhdLine,        hdLine       }, <br>        { "dwMediaModes",   dwMediaModes } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_lineSetDefaultMediaDetection", <br>        2, <br>        params <br>    }; <br>#endif <br> <br> <br>    // <br>    // This func is really a no-op for us, since we don't look <br>    // for incoming calls (though we do say we support them to <br>    // make apps happy) <br>    // <br> <br>    Prolog (&amp;info); <br>    return (Epilog (&amp;info, 0)); <br>} <br> <br> <br>// <br>// ------------------------- TSPI_providerXxx funcs --------------------------- <br>// <br> <br>LONG <br>TSPIAPI <br>TSPI_providerConfig( <br>    HWND    hwndOwner, <br>    DWORD   dwPermanentProviderID <br>    ) <br>{ <br>    // <br>    // Although this func is never called by TAPI v2.0, we export <br>    // it so that the Telephony Control Panel Applet knows that it <br>    // can configure this provider via lineConfigProvider(), <br>    // otherwise Telephon.cpl will not consider it configurable <br>    // <br> <br>    return 0; <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_providerGenericDialogData( <br>    DWORD               dwObjectID, <br>    DWORD               dwObjectType, <br>    LPVOID              lpParams, <br>    DWORD               dwSize <br>    ) <br>{ <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { "dwObjectID",     dwObjectID      }, <br>        { "dwObjectType",   dwObjectType    }, <br>        { "lpParams",       lpParams        }, <br>        { "dwSize",         dwSize          } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_providerGenericDialogData", <br>        4, <br>        params <br>    }; <br>#endif <br> <br> <br>    Prolog (&amp;info); <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_providerInit( <br>    DWORD               dwTSPIVersion, <br>    DWORD               dwPermanentProviderID, <br>    DWORD               dwLineDeviceIDBase, <br>    DWORD               dwPhoneDeviceIDBase, <br>    DWORD               dwNumLines, <br>    DWORD               dwNumPhones, <br>    ASYNC_COMPLETION    lpfnCompletionProc, <br>    LPDWORD             lpdwTSPIOptions <br>    ) <br>{ <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { "dwTSPIVersion",          dwTSPIVersion           }, <br>        { gszdwPermanentProviderID, dwPermanentProviderID   }, <br>        { "dwLineDeviceIDBase",     dwLineDeviceIDBase      }, <br>        { "dwPhoneDeviceIDBase",    dwPhoneDeviceIDBase     }, <br>        { "dwNumLines",             dwNumLines              }, <br>        { "dwNumPhones",            dwNumPhones             }, <br>        { "lpfnCompletionProc",     lpfnCompletionProc      } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_providerInit", <br>        7, <br>        params <br>    }; <br>#endif <br> <br>    Prolog (&amp;info); <br>    gdwLineDeviceIDBase = dwLineDeviceIDBase; <br>    gpfnCompletionProc  = lpfnCompletionProc; <br>    *lpdwTSPIOptions = LINETSPIOPTION_NONREENTRANT; <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_providerInstall( <br>    HWND    hwndOwner, <br>    DWORD   dwPermanentProviderID <br>    ) <br>{ <br>    // <br>    // Although this func is never called by TAPI v2.0, we export <br>    // it so that the Telephony Control Panel Applet knows that it <br>    // can add this provider via lineAddProvider(), otherwise <br>    // Telephon.cpl will not consider it installable <br>    // <br>    // <br> <br>    return 0; <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_providerRemove( <br>    HWND    hwndOwner, <br>    DWORD   dwPermanentProviderID <br>    ) <br>{ <br>    // <br>    // Although this func is never called by TAPI v2.0, we export <br>    // it so that the Telephony Control Panel Applet knows that it <br>    // can remove this provider via lineRemoveProvider(), otherwise <br>    // Telephon.cpl will not consider it removable <br>    // <br> <br>    return 0; <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_providerShutdown( <br>    DWORD   dwTSPIVersion, <br>    DWORD   dwPermanentProviderID <br>    ) <br>{ <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { "dwTSPIVersion",          dwTSPIVersion }, <br>        { gszdwPermanentProviderID, dwPermanentProviderID   } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_providerShutdown", <br>        2, <br>        params <br>    }; <br>#endif <br> <br> <br>    Prolog (&amp;info); <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_providerEnumDevices( <br>    DWORD       dwPermanentProviderID, <br>    LPDWORD     lpdwNumLines, <br>    LPDWORD     lpdwNumPhones, <br>    HPROVIDER   hProvider, <br>    LINEEVENT   lpfnLineCreateProc, <br>    PHONEEVENT  lpfnPhoneCreateProc <br>    ) <br>{ <br>   HKEY     hKey; <br>   DWORD    dwNumLines, dwDataType, dwDataSize; <br> <br> <br>   // <br>   // Retrieve the number of devices we're <br>   // configured for from our registry section <br>   // <br> <br>   RegOpenKeyEx( <br>       HKEY_LOCAL_MACHINE, <br>       gszAtspKey, <br>       0, <br>       KEY_ALL_ACCESS, <br>       &amp;hKey <br>       ); <br> <br>   dwDataSize = sizeof(dwNumLines); <br>   dwNumLines = 0; <br> <br>   RegQueryValueEx( <br>       hKey, <br>       gszNumLines, <br>       0, <br>       &amp;dwDataType, <br>       (LPBYTE) &amp;dwNumLines, <br>       &amp;dwDataSize <br>       ); <br> <br>   RegCloseKey (hKey); <br> <br>   *lpdwNumLines  = dwNumLines; <br>   *lpdwNumPhones = 0; <br>   return 0; <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TSPI_providerUIIdentify( <br>    LPWSTR   lpszUIDLLName <br>    ) <br>{ <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { "lpsUIDLLName",  lpszUIDLLName } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TSPI_providerUIIdentify", <br>        1, <br>        params <br>    }; <br>#endif <br> <br> <br>    Prolog (&amp;info); <br>    My_lstrcpyW(lpszUIDLLName, L"atsp32.tsp"); <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>// <br>// ---------------------------- TUISPI_xxx funcs ------------------------------ <br>// <br> <br>LONG <br>TSPIAPI <br>TUISPI_lineConfigDialog( <br>    TUISPIDLLCALLBACK   lpfnUIDLLCallback, <br>    DWORD               dwDeviceID, <br>    HWND                hwndOwner, <br>    LPCWSTR             lpszDeviceClass <br>    ) <br>{ <br>    char        szDeviceClass[128]; <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { "lpfnUIDLLCallback",   lpfnUIDLLCallback }, <br>        { gszdwDeviceID,         dwDeviceID        }, <br>        { gszhwndOwner,          hwndOwner         }, <br>        { "lpszDeviceClass",     szDeviceClass     } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TUISPI_lineConfigDialog", <br>        4, <br>        params <br>    }; <br>#endif <br> <br> <br>    if (lpszDeviceClass) <br>    { <br>        WideCharToMultiByte( <br>            CP_ACP, <br>            0, <br>            lpszDeviceClass, <br>            -1, <br>            (LPSTR) szDeviceClass, <br>            128, <br>            NULL, <br>            NULL <br>            ); <br>    } <br> <br>    Prolog (&amp;info); <br> <br>    DialogBoxParam( <br>        ghInst, <br>        MAKEINTRESOURCE(IDD_DIALOG1), <br>        hwndOwner, <br>        (DLGPROC) ConfigDlgProc, <br>        0 <br>        ); <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TUISPI_providerConfig( <br>    TUISPIDLLCALLBACK   lpfnUIDLLCallback, <br>    HWND                hwndOwner, <br>    DWORD               dwPermanentProviderID <br>    ) <br>{ <br>    LONG        lResult = 0; <br>#if DBG <br>    FUNC_PARAM  params[] = <br>    { <br>        { "lpfnUIDLLCallback",      lpfnUIDLLCallback }, <br>        { gszhwndOwner,             hwndOwner    }, <br>        { gszdwPermanentProviderID, dwPermanentProviderID   } <br>    }; <br>    FUNC_INFO   info = <br>    { <br>        "TUISPI_providerConfig", <br>        3, <br>        params <br>    }; <br>#endif <br> <br> <br>    Prolog (&amp;info); <br> <br>    DialogBoxParam( <br>        ghInst, <br>        MAKEINTRESOURCE(IDD_DIALOG1), <br>        hwndOwner, <br>        (DLGPROC) ConfigDlgProc, <br>        0 <br>        ); <br> <br>    return (Epilog (&amp;info, lResult)); <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TUISPI_providerInstall( <br>    TUISPIDLLCALLBACK   lpfnUIDLLCallback, <br>    HWND                hwndOwner, <br>    DWORD               dwPermanentProviderID <br>    ) <br>{ <br>    LONG    lResult; <br> <br> <br>    if ((lResult = ProviderInstall ("atsp32.tsp", TRUE)) == 0) <br>    { <br>        DialogBoxParam( <br>            ghInst, <br>            MAKEINTRESOURCE(IDD_DIALOG1), <br>            hwndOwner, <br>            (DLGPROC) ConfigDlgProc, <br>            0 <br>            ); <br>    } <br> <br>    return lResult; <br>} <br> <br> <br>LONG <br>TSPIAPI <br>TUISPI_providerRemove( <br>    TUISPIDLLCALLBACK   lpfnUIDLLCallback, <br>    HWND                hwndOwner, <br>    DWORD               dwPermanentProviderID <br>    ) <br>{ <br>    HKEY    hKey; <br>    char    szSoftwareMsft[] = "Software\\Microsoft", szATSP[] = "ATSP"; <br> <br> <br>    // <br>    // Clean up our registry section <br>    // <br> <br>    RegOpenKeyExA( <br>        HKEY_LOCAL_MACHINE, <br>        szSoftwareMsft, <br>        0, <br>        KEY_ALL_ACCESS, <br>        &amp;hKey <br>        ); <br> <br>    RegDeleteKeyA (hKey, szATSP); <br>    RegCloseKey (hKey); <br>    return 0; <br>} <br> <br> <br>#pragma warning (default:4047) <br> <br> <br>// <br>// ---------------------- Misc private support routines ----------------------- <br>// <br> <br>LPWSTR <br>PASCAL <br>My_lstrcpyW( <br>    WCHAR   *pString1, <br>    WCHAR   *pString2 <br>    ) <br>{ <br>    WCHAR *p = pString1; <br> <br> <br>    for (; (*p = *pString2); p++, pString2++); <br>    return pString1; <br>} <br> <br> <br>void <br>PASCAL <br>EnableChildren( <br>    HWND    hwnd, <br>    BOOL    bEnable <br>    ) <br>{ <br>    int i; <br>    static int aiControlIDs[] = <br>    { <br>        IDC_DEVICES, <br>        IDC_NAME, <br>        IDC_PORT, <br>        IDC_COMMANDS, <br>        IDC_REMOVE, <br>        0 <br>    }; <br> <br> <br>    for (i = 0; aiControlIDs[i]; i++) <br>    { <br>        EnableWindow (GetDlgItem (hwnd, aiControlIDs[i]), bEnable); <br>    } <br>} <br> <br> <br>void <br>PASCAL <br>SelectDevice( <br>    HWND    hwnd, <br>    int     iDevice <br>    ) <br>{ <br>    SendDlgItemMessage (hwnd, IDC_DEVICES, LB_SETCURSEL, iDevice, 0); <br>    PostMessage(hwnd, WM_COMMAND, IDC_DEVICES | (LBN_SELCHANGE &lt;&lt; 16), 0); <br>} <br> <br> <br>BOOL <br>CALLBACK <br>ConfigDlgProc( <br>    HWND    hwnd, <br>    UINT    msg, <br>    WPARAM  wParam, <br>    LPARAM  lParam <br>    ) <br>{ <br>    static  HKEY    hAtspKey; <br> <br>    DWORD   dwDataSize; <br>    DWORD   dwDataType; <br> <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>    { <br>        char   *pBuf; <br>        DWORD   i, iNumLines; <br> <br> <br>        // <br>        // Create or open our configuration key in the registry.  If the <br>        // create fails it may well be that the current user does not <br>        // have write access to this portion of the registry, so we'll <br>        // just show a "read only" dialog and not allow user to make any <br>        // changes <br>        // <br> <br>        { <br>            LONG    lResult; <br>            DWORD   dwDisposition; <br> <br> <br>            if ((lResult = RegCreateKeyEx( <br>                    HKEY_LOCAL_MACHINE, <br>                    gszAtspKey, <br>                    0, <br>                    "", <br>                    REG_OPTION_NON_VOLATILE, <br>                    KEY_ALL_ACCESS, <br>                    (LPSECURITY_ATTRIBUTES) NULL, <br>                    &amp;hAtspKey, <br>                    &amp;dwDisposition <br> <br>                    )) != ERROR_SUCCESS) <br>            { <br>                DBGOUT(( <br>                    3, <br>                    "RegCreateKeyEx(%s,ALL_ACCESS) failed, err=%d", <br>                    gszAtspKey, <br>                    lResult <br>                    )); <br> <br>                if ((lResult = RegOpenKeyEx( <br>                        HKEY_LOCAL_MACHINE, <br>                        gszAtspKey, <br>                        0, <br>                        KEY_QUERY_VALUE, <br>                        &amp;hAtspKey <br> <br>                        )) != ERROR_SUCCESS) <br>                { <br>                    DBGOUT(( <br>                        3, <br>                        "RegOpenKeyEx(%s,ALL_ACCESS) failed, err=%d", <br>                        gszAtspKey, <br>                        lResult <br>                        )); <br> <br>                    EndDialog (hwnd, 0); <br>                    return FALSE; <br>                } <br> <br>                { <br>                    int i; <br>                    static int aiControlIDs[] = <br>                    { <br>                        IDC_NAME, <br>                        IDC_PORT, <br>                        IDC_COMMANDS, <br>                        IDC_ADD, <br>                        IDC_REMOVE, <br>                        IDOK, <br>                        0 <br>                    }; <br> <br> <br>                    for (i = 0; aiControlIDs[i]; i++) <br>                    { <br>                        EnableWindow( <br>                            GetDlgItem (hwnd, aiControlIDs[i]), <br>                            FALSE <br>                            ); <br>                    } <br>                } <br>            } <br>        } <br> <br> <br>        // <br>        // Retrieve our configuration info from the registry <br>        // <br> <br>        dwDataSize = sizeof(iNumLines); <br>        iNumLines = 0; <br> <br>        RegQueryValueEx( <br>            hAtspKey, <br>            gszNumLines, <br>            0, <br>            &amp;dwDataType, <br>            (LPBYTE) &amp;iNumLines, <br>            &amp;dwDataSize <br>            ); <br> <br>        SendDlgItemMessage( <br>            hwnd, <br>            IDC_NAME, <br>            EM_LIMITTEXT, <br>            MAX_DEV_NAME_LENGTH, <br>            0 <br>            ); <br> <br>        SendDlgItemMessage( <br>            hwnd, <br>            IDC_COMMANDS, <br>            EM_LIMITTEXT, <br>            MAX_DEV_NAME_LENGTH, <br>            0 <br>            ); <br> <br>        pBuf = DrvAlloc (256); <br> <br>        for (i = 0; i &lt; iNumLines; i++) <br>        { <br>            char           *p, *p2, szLineN[8]; <br>            PDRVLINECONFIG  pLineConfig = DrvAlloc (sizeof(DRVLINECONFIG)); <br>            LONG            lResult; <br> <br> <br>            wsprintf (szLineN, "Line%d", i); <br> <br>            dwDataSize = 256; <br> <br>            lResult = RegQueryValueEx( <br>                hAtspKey, <br>                szLineN, <br>                0, <br>                &amp;dwDataType, <br>                (LPBYTE) pBuf, <br>                &amp;dwDataSize <br>                ); <br> <br> <br>            // <br>            // If there was a problem, use the default config <br>            // <br> <br>            if (0 != lResult) <br>            { <br>               lstrcpy (pBuf, gszDefLineConfigParams); <br>            } <br> <br>            for (p = pBuf; *p != ','; p++); <br>            *p = 0; <br> <br>            SendDlgItemMessage( <br>                hwnd, <br>                IDC_DEVICES, <br>                LB_ADDSTRING, <br>                0, <br>                (LPARAM) pBuf <br>                ); <br> <br>            SendDlgItemMessage( <br>                hwnd, <br>                IDC_DEVICES, <br>                LB_SETITEMDATA, <br>                i, <br>                (LPARAM) pLineConfig <br>                ); <br> <br>            p++; <br>            for (p2 = p; *p2 != ','; p2++); <br>            *p2 = 0; <br> <br>            lstrcpy (pLineConfig-&gt;szPort, p); <br> <br>            p = p2 + 1; <br> <br>            lstrcpy (pLineConfig-&gt;szCommands, p); <br>        } <br> <br>        DrvFree (pBuf); <br> <br> <br>        // <br>        // Fill up the various controls with configuration options <br>        // <br> <br>        { <br>            static char *aszPorts[] = { "COM1","COM2","COM3",NULL }; <br> <br>            for (i = 0; aszPorts[i]; i++) <br>            { <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_PORT, <br>                    LB_ADDSTRING, <br>                    0, <br>                    (LPARAM) aszPorts[i] <br>                    ); <br>            } <br>        } <br> <br>        if (iNumLines == 0) <br>        { <br>            EnableChildren (hwnd, FALSE); <br>        } <br>        else <br>        { <br>            SelectDevice (hwnd, 0); <br>        } <br> <br>        break; <br>    } <br>    case WM_COMMAND: <br>    { <br>        int             iSelection; <br>        PDRVLINECONFIG  pLineConfig; <br> <br> <br>        iSelection = SendDlgItemMessage( <br>            hwnd, <br>            IDC_DEVICES, <br>            LB_GETCURSEL, <br>            0, <br>            0 <br>            ); <br> <br>        pLineConfig = (PDRVLINECONFIG) SendDlgItemMessage( <br>            hwnd, <br>            IDC_DEVICES, <br>            LB_GETITEMDATA, <br>            (WPARAM) iSelection, <br>            0 <br>            ); <br> <br>        switch (LOWORD((DWORD)wParam)) <br>        { <br>        case IDC_DEVICES: <br> <br>            if (HIWORD(wParam) == LBN_SELCHANGE) <br>            { <br>                char buf[MAX_DEV_NAME_LENGTH + 1]; <br> <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_GETTEXT, <br>                    iSelection, <br>                    (LPARAM) buf <br>                    ); <br> <br>                SetDlgItemText (hwnd, IDC_NAME, buf); <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_PORT, <br>                    LB_SELECTSTRING, <br>                    (WPARAM) -1, <br>                    (LPARAM) pLineConfig-&gt;szPort <br>                    ); <br> <br>                SetDlgItemText (hwnd, IDC_COMMANDS, pLineConfig-&gt;szCommands); <br>            } <br> <br>            break; <br> <br>        case IDC_NAME: <br> <br>            if ((HIWORD(wParam) == EN_CHANGE) &amp;&amp; (iSelection != LB_ERR)) <br>            { <br>                char    buf[MAX_DEV_NAME_LENGTH + 1]; <br> <br> <br>                GetDlgItemText (hwnd, IDC_NAME, buf, MAX_DEV_NAME_LENGTH); <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_DELETESTRING, <br>                    iSelection, <br>                    0 <br>                    ); <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_INSERTSTRING, <br>                    iSelection, <br>                    (LPARAM) buf <br>                    ); <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_SETCURSEL, <br>                    iSelection, <br>                    0 <br>                    ); <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_SETITEMDATA, <br>                    iSelection, <br>                    (LPARAM) pLineConfig <br>                    ); <br>            } <br> <br>            break; <br> <br>        case IDC_PORT: <br> <br>            if (HIWORD(wParam) == LBN_SELCHANGE) <br>            { <br>                iSelection = SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_PORT, <br>                    LB_GETCURSEL, <br>                    0, <br>                    0 <br>                    ); <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_PORT, <br>                    LB_GETTEXT, <br>                    iSelection, <br>                    (LPARAM) pLineConfig-&gt;szPort <br>                    ); <br>            } <br> <br>            break; <br> <br>        case IDC_COMMANDS: <br> <br>            if ((HIWORD(wParam) == EN_CHANGE) &amp;&amp; (iSelection != LB_ERR)) <br>            { <br>                GetDlgItemText( <br>                    hwnd, <br>                    IDC_COMMANDS, <br>                    pLineConfig-&gt;szCommands, <br>                    63 <br>                    ); <br>            } <br> <br>            break; <br> <br>        case IDC_ADD: <br>        { <br>            int             iNumLines, i = 2; <br>            char            szLineName[32]; <br>            PDRVLINECONFIG  pLineConfig = DrvAlloc (sizeof(DRVLINECONFIG)); <br> <br> <br>            iNumLines = SendDlgItemMessage( <br>                hwnd, <br>                IDC_DEVICES, <br>                LB_GETCOUNT, <br>                0, <br>                0 <br>                ); <br> <br>            lstrcpy (pLineConfig-&gt;szPort, "COM1"); <br> <br>            lstrcpy (szLineName, "my new line"); <br> <br>find_unique_line_name: <br> <br>            if (SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_FINDSTRING, <br>                    (WPARAM) -1, <br>                    (LPARAM) szLineName <br> <br>                    ) != LB_ERR) <br>            { <br>                wsprintf (szLineName, "my new line%d", i++); <br>                goto find_unique_line_name; <br>            } <br> <br>            SendDlgItemMessage( <br>                hwnd, <br>                IDC_DEVICES, <br>                LB_ADDSTRING, <br>                0, <br>                (LPARAM) szLineName <br>                ); <br> <br>            SendDlgItemMessage( <br>                hwnd, <br>                IDC_DEVICES, <br>                LB_SETITEMDATA, <br>                iNumLines, <br>                (LPARAM) pLineConfig <br>                ); <br> <br>            EnableChildren (hwnd, TRUE); <br> <br>            SelectDevice (hwnd, iNumLines); <br> <br>            SetFocus (GetDlgItem (hwnd, IDC_NAME)); <br> <br>            SendDlgItemMessage( <br>                hwnd, <br>                IDC_NAME, <br>                EM_SETSEL, <br>                0, <br>                (LPARAM) -1 <br>                ); <br> <br>            break; <br>        } <br>        case IDC_REMOVE: <br>        { <br>            int iNumLines; <br> <br> <br>            DrvFree (pLineConfig); <br> <br>            iNumLines = SendDlgItemMessage( <br>                hwnd, <br>                IDC_DEVICES, <br>                LB_DELETESTRING, <br>                iSelection, <br>                0 <br>                ); <br> <br>            if (iNumLines == 0) <br>            { <br>                SetDlgItemText (hwnd, IDC_NAME, ""); <br>                SetDlgItemText (hwnd, IDC_COMMANDS, ""); <br> <br>                EnableChildren (hwnd, FALSE); <br>            } <br>            else <br>            { <br>                SelectDevice (hwnd, 0); <br>            } <br> <br>            break; <br>        } <br>        case IDOK: <br>        { <br>            int     i, iNumLines; <br>            char   *pBuf; <br> <br> <br>            // <br>            // Update the num lines &amp; num phones values <br>            // <br> <br>            pBuf = DrvAlloc (256); <br> <br>            iNumLines = SendDlgItemMessage( <br>                hwnd, <br>                IDC_DEVICES, <br>                LB_GETCOUNT, <br>                0, <br>                0 <br>                ); <br> <br>            RegSetValueEx( <br>                hAtspKey, <br>                gszNumLines, <br>                0, <br>                REG_DWORD, <br>                (LPBYTE) &amp;iNumLines, <br>                sizeof(DWORD) <br>                ); <br> <br> <br>            // <br>            // For each installed device save it's config info <br>            // <br> <br>            for (i = 0; i &lt; iNumLines; i++) <br>            { <br>                char szLineN[8]; <br>                PDRVLINECONFIG pLineConfig; <br> <br> <br>                SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_GETTEXT, <br>                    i, <br>                    (LPARAM) pBuf <br>                    ); <br> <br>                pLineConfig = (PDRVLINECONFIG) SendDlgItemMessage( <br>                    hwnd, <br>                    IDC_DEVICES, <br>                    LB_GETITEMDATA, <br>                    i, <br>                    0 <br>                    ); <br> <br>                wsprintf( <br>                    pBuf + strlen (pBuf), <br>                    ",%s,%s", <br>                    pLineConfig-&gt;szPort, <br>                    pLineConfig-&gt;szCommands <br>                    ); <br> <br>                wsprintf (szLineN, "Line%d", i); <br> <br>                RegSetValueEx( <br>                    hAtspKey, <br>                    szLineN, <br>                    0, <br>                    REG_SZ, <br>                    (LPBYTE) pBuf, <br>                    lstrlen (pBuf) + 1 <br>                    ); <br> <br>                DrvFree (pLineConfig); <br>            } <br> <br>            DrvFree (pBuf); <br> <br>            // fall thru to EndDialog... <br>        } <br>        case IDCANCEL: <br> <br>            RegCloseKey (hAtspKey); <br>            EndDialog (hwnd, 0); <br>            break; <br> <br>        } // switch (LOWORD((DWORD)wParam)) <br> <br>        break; <br>    } <br>    } // switch (msg) <br> <br>    return FALSE; <br>} <br> <br> <br>LPVOID <br>PASCAL <br>DrvAlloc( <br>    DWORD dwSize <br>    ) <br>{ <br>    return (LocalAlloc (LPTR, dwSize)); <br>} <br> <br> <br>VOID <br>PASCAL <br>DrvFree( <br>    LPVOID lp <br>    ) <br>{ <br>    LocalFree (lp); <br>} <br> <br> <br>void <br>PASCAL <br>SetCallState( <br>    PDRVLINE    pLine, <br>    DWORD       dwCallState, <br>    DWORD       dwCallStateMode <br>    ) <br>{ <br>    if (dwCallState != pLine-&gt;dwCallState) <br>    { <br>        pLine-&gt;dwCallState     = dwCallState; <br>        pLine-&gt;dwCallStateMode = dwCallStateMode; <br> <br>        (*pLine-&gt;pfnEventProc)( <br>            pLine-&gt;htLine, <br>            pLine-&gt;htCall, <br>            LINE_CALLSTATE, <br>            dwCallState, <br>            dwCallStateMode, <br>            pLine-&gt;dwMediaMode <br>            ); <br>    } <br>} <br> <br> <br>#if DBG <br> <br>void <br>PASCAL <br>Prolog( <br>    PFUNC_INFO  pInfo <br>    ) <br>{ <br>    DWORD i; <br> <br> <br>    DBGOUT((3, "%s: enter", pInfo-&gt;lpszFuncName)); <br> <br>    for (i = 0; i &lt; pInfo-&gt;dwNumParams; i++) <br>    { <br>        if (pInfo-&gt;aParams[i].dwVal &amp;&amp; <br>            pInfo-&gt;aParams[i].lpszVal[3] == 'z') // lpszVal = "lpsz..." <br>        { <br>            DBGOUT(( <br>                3, <br>                "%s%s=x%lx, '%s'", <br>                gszTab, <br>                pInfo-&gt;aParams[i].lpszVal, <br>                pInfo-&gt;aParams[i].dwVal, <br>                pInfo-&gt;aParams[i].dwVal <br>                )); <br>        } <br>        else <br>        { <br>            DBGOUT(( <br>                3, <br>                "%s%s=x%lx", <br>                gszTab, <br>                pInfo-&gt;aParams[i].lpszVal, <br>                pInfo-&gt;aParams[i].dwVal <br>                )); <br>        } <br>    } <br>} <br> <br> <br>LONG <br>PASCAL <br>Epilog( <br>    PFUNC_INFO  pInfo, <br>    LONG        lResult <br>    ) <br>{ <br>    DBGOUT((3, "%s: returning x%x", pInfo-&gt;lpszFuncName, lResult)); <br> <br>    return lResult; <br>} <br> <br> <br>void <br>CDECL <br>DebugOutput( <br>    DWORD   dwDbgLevel, <br>    LPCSTR  lpszFormat, <br>    ... <br>    ) <br>{ <br>    if (dwDbgLevel &lt;= gdwDebugLevel) <br>    { <br>        char    buf[128] = "ATSP32: "; <br>        va_list ap; <br> <br> <br>        va_start(ap, lpszFormat); <br> <br>        wvsprintf (&amp;buf[8], lpszFormat, ap); <br> <br>        lstrcat (buf, "\n"); <br> <br>        OutputDebugString (buf); <br> <br>        va_end(ap); <br>    } <br>} <br> <br>#endif <br> <br> <br>LONG <br>PASCAL <br>ProviderInstall( <br>    char   *pszProviderName, <br>    BOOL    bNoMultipleInstance <br>    ) <br>{ <br>    LONG    lResult; <br> <br> <br>    // <br>    // If only one installation instance of this provider is <br>    // allowed then we want to check the provider list to see <br>    // if the provider is already installed <br>    // <br> <br>    if (bNoMultipleInstance) <br>    { <br>        LONG                (WINAPI *pfnGetProviderList)(); <br>        DWORD               dwTotalSize, i; <br>        HINSTANCE           hTapi32; </code></pre>
<p>
</p>
<pre><code>LPLINEPROVIDERLIST  pProviderList; <br>        LPLINEPROVIDERENTRY pProviderEntry; <br> <br> <br>        // <br>        // Load Tapi32.dll &amp; get a pointer to the lineGetProviderList <br>        // func.  We don't want to statically link because this module <br>        // plays the part of both core SP &amp; UI DLL, and we don't want <br>        // to incur the performance hit of automatically loading <br>        // Tapi32.dll when running as a core SP within Tapisrv.exe's <br>        // context. <br>        // <br> <br>        if (!(hTapi32 = LoadLibrary ("tapi32.dll"))) <br>        { <br>            DBGOUT(( <br>                1, <br>                "LoadLibrary(tapi32.dll) failed, err=%d", <br>                GetLastError() <br>                )); <br> <br>            lResult = LINEERR_OPERATIONFAILED; <br>            goto ProviderInstall_return; <br>        } <br> <br>        if (!((FARPROC) pfnGetProviderList = GetProcAddress( <br>                hTapi32, <br>                (LPCSTR) "lineGetProviderList" <br>                ))) <br>        { <br>            DBGOUT(( <br>                1, <br>                "GetProcAddr(lineGetProviderList) failed, err=%d", <br>                GetLastError() <br>                )); <br> <br>            lResult = LINEERR_OPERATIONFAILED; <br>            goto ProviderInstall_unloadTapi32; <br>        } <br> <br> <br>        // <br>        // Loop until we get the full provider list <br>        // <br> <br>        dwTotalSize = sizeof (LINEPROVIDERLIST); <br> <br>        goto ProviderInstall_allocProviderList; <br> <br>ProviderInstall_getProviderList: <br> <br>        if ((lResult = (*pfnGetProviderList)(0x00020000, pProviderList)) != 0) <br>        { <br>            goto ProviderInstall_freeProviderList; <br>        } <br> <br>        if (pProviderList-&gt;dwNeededSize &gt; pProviderList-&gt;dwTotalSize) <br>        { <br>            dwTotalSize = pProviderList-&gt;dwNeededSize; <br> <br>            LocalFree (pProviderList); <br> <br>ProviderInstall_allocProviderList: <br> <br>            if (!(pProviderList = LocalAlloc (LPTR, dwTotalSize))) <br>            { <br>                lResult = LINEERR_NOMEM; <br>                goto ProviderInstall_unloadTapi32; <br>            } <br> <br>            pProviderList-&gt;dwTotalSize = dwTotalSize; <br> <br>            goto ProviderInstall_getProviderList; <br>        } <br> <br> <br>        // <br>        // Inspect the provider list entries to see if this provider <br>        // is already installed <br>        // <br> <br>        pProviderEntry = (LPLINEPROVIDERENTRY) (((LPBYTE) pProviderList) + <br>            pProviderList-&gt;dwProviderListOffset); <br> <br>        for (i = 0; i &lt; pProviderList-&gt;dwNumProviders; i++) <br>        { <br>            char   *pszInstalledProviderName = ((char *) pProviderList) + <br>                        pProviderEntry-&gt;dwProviderFilenameOffset, <br>                   *p; <br> <br> <br>            // <br>            // Make sure pszInstalledProviderName points at &lt;filename&gt; <br>            // and not &lt;path&gt;\filename by walking backeards thru the <br>            // string searching for last '\\' <br>            // <br> <br>            p = pszInstalledProviderName + <br>                lstrlen (pszInstalledProviderName) - 1; <br> <br>            for (; *p != '\\'  &amp;&amp;  p != pszInstalledProviderName; p--); <br> <br>            pszInstalledProviderName = <br>                (p == pszInstalledProviderName ? p : p + 1); <br> <br>            if (lstrcmpiA (pszInstalledProviderName, pszProviderName) == 0) <br>            { <br>                lResult = LINEERR_NOMULTIPLEINSTANCE; <br>                goto ProviderInstall_freeProviderList; <br>            } <br> <br>            pProviderEntry++; <br>        } <br> <br> <br>        // <br>        // If here then the provider isn't currently installed, <br>        // so do whatever configuration stuff is necessary and <br>        // indicate SUCCESS <br>        // <br> <br>        lResult = 0; <br> <br> <br>ProviderInstall_freeProviderList: <br> <br>        LocalFree (pProviderList); <br> <br>ProviderInstall_unloadTapi32: <br> <br>        FreeLibrary (hTapi32); <br>    } <br>    else <br>    { <br>        // <br>        // Do whatever configuration stuff is necessary and return SUCCESS <br>        // <br> <br>        lResult = 0; <br>    } <br> <br>ProviderInstall_return: <br> <br>    return lResult; <br>} <br> <br> <br>void <br>PASCAL <br>DropActiveCall( <br>    PDRVLINE    pLine <br>    ) <br>{ <br>    if (pLine-&gt;hComm) <br>    { <br>        DWORD       dwNumBytes, dwError; <br>        OVERLAPPED  overlapped; <br> <br> <br>        pLine-&gt;bDropInProgress = TRUE; <br> <br>        SetEvent (pLine-&gt;Overlapped.hEvent); <br> <br>        ZeroMemory (&amp;overlapped, sizeof (OVERLAPPED)); <br> <br>        overlapped.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL); <br> <br>        if (pLine-&gt;dwMediaMode != LINEMEDIAMODE_INTERACTIVEVOICE) <br>        { <br>            if (!WriteFile( <br>                    pLine-&gt;hComm, <br>                    "+++\r", 4, <br>                    &amp;dwNumBytes, <br>                    &amp;overlapped <br>                    )) <br>            { <br>                if ((dwError = GetLastError()) == ERROR_IO_PENDING) <br>                { <br>                    GetOverlappedResult( <br>                        pLine-&gt;hComm, <br>                        &amp;overlapped, <br>                        &amp;dwNumBytes, <br>                        TRUE <br>                        ); <br> <br>                    ResetEvent (overlapped.hEvent); <br>                } <br>                else <br>                { <br>                } <br>            } <br>        } <br> <br>        if (!WriteFile (pLine-&gt;hComm, "ATH\r", 4, &amp;dwNumBytes, &amp;overlapped)) <br>        { <br>            if ((dwError = GetLastError()) == ERROR_IO_PENDING) <br>            { <br>                GetOverlappedResult( <br>                    pLine-&gt;hComm, <br>                    &amp;overlapped, <br>                    &amp;dwNumBytes, <br>                    TRUE <br>                    ); <br>            } <br>            else <br>            { <br>            } <br>        } <br> <br>        CloseHandle (overlapped.hEvent); <br>        CloseHandle (pLine-&gt;hComm); <br>        pLine-&gt;hComm = NULL; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
