<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALER.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5179"></a>DIALER.C</h2>
<pre><code>/*++  <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    dialer.c <br> <br>--*/ <br> <br> <br>#include "dialer.h" <br>#include "string.h" <br>#include "stdlib.h" <br>#include "shellapi.h" <br> <br> <br>#defineISDIGIT(x)(((x) - '0') &gt;= 0) &amp;&amp; (((x) - '0') &lt;= 9) <br>enum NumberTypes  <br>{ <br>LOCAL_NUMBER = 7, <br>EXTENDED_LOCAL_NUMBER, <br>LONG_DISTANCE_NUMBER = 10, <br>EXTENDED_LONG_DISTANCE_NUMBER <br>}; <br> <br> <br>// structs <br>typedef struct tagLINEINFO <br>{ <br>    DWORD nAddr;                    // Number of avail. addresses on the line <br>    BOOL  fVoiceLine;               // Is this a voice line? <br>    DWORD dwAPIVersion;             // API version which the line supports <br>    HLINE hLine;                    // line handle returned by lineOpen <br>    DWORD dwPermanentLineID;        // Permanent line ID retreived from devcaps <br>    char  szLineName[MAXBUFSIZE];   // the line's name <br> <br>} LINEINFO, *LPLINEINFO; <br> <br> <br>// Global variables <br> <br>// window/instance variables <br>HWND        ghWndMain; <br>HWND        ghWndDialing = NULL; <br>HINSTANCE   ghInst = 0; <br> <br>// file name vars. <br>static TCHAR gszAppName[64]; <br>static TCHAR gszINIfilename [] = "DIALER.INI"; <br>static TCHAR gszHELPfilename [] = "DIALER.HLP"; <br>static TCHAR gszDialerClassName[] = "DialerClass"; <br>TCHAR const gszNULL[] = ""; <br> <br>// window item variables <br>HFONT       ghFontBtn;               // handle to 1, 2, ..., 0's font <br>HFONT       ghFontBtnText;           // handle to number button's text font <br>HFONT       ghFontBtnStar;           // handle to * and # button's font <br>HLINEAPP    ghLineApp = NULL;        // Dialer's usage handle (regist. w/TAPI) <br>HCALL       ghCall = NULL;           // call handle for Dialer's call <br> <br>LPSTR       gszCurrentNumber = NULL; // number of destination of current call <br>LPSTR       gszCurrentName = NULL; // name of destination of current call <br> <br>BOOL        gfRegistered;            // was lineRegisterRequestRecipient() <br>                                     // successful? <br> <br>//BOOL        gfDropping = FALSE;      // is Dialer currently dropping a call? <br>BOOL        gfNeedToReinit = FALSE;  // does Dialer need to re-initialize? <br> <br>BOOL        gfCallRequest = FALSE;   // Does a Simple TAPI app want a call? <br>BOOL        gfCurrentLineAvail = TRUE; // Simple TAPI requests are only carried <br>                                       // out if the current chosen line is avail. <br>BOOLgfMakeCallReplyPending = FALSE; <br> <br>LONG        gMakeCallRequestID = 0;      // request ID returned by async TAPI fns. <br>LONG        gDropCallRequestID = 0;      // request ID returned by async TAPI fns. <br> <br>DWORD       gnAvailDevices = 0;      // # of line devices avail. to Dialer <br>LINEINFO    gCurrentLineInfo; <br>DWORD       * gnAddr; <br> <br>// global to remember where the cursor is in the edit control <br>DWORD       gdwStartSel; <br>DWORD       gdwEndSel; <br> <br>DWORD       * gdwPLID;               // current line's permanent line ID <br>DWORD       giCurrentLine = (DWORD)-1;       // the line selected by the user <br>DWORD       giCurrentAddress = 0;    // the address selected by the user <br> <br>// + 1 so we can work 1-based rather than 0-based (for convenience only) <br>// global varibles to hold the names and address of the  <br>TCHAR       gszSDNumber[ NSPEEDDIALS + 1 ][ TAPIMAXDESTADDRESSSIZE ]; <br> <br> <br>// Function declarations <br> <br>// button related functions <br>VOID ButtonFontSetup(VOID); <br>VOID DrawButton(HDC hdc, RECT rcBtn, BOOL fHighlighted); <br>VOID DrawButtonText(HDC hdc, RECT rcBtn, BOOL fHighlighted, UINT IDD_Btn); <br>VOID DisableDialButtons(BOOL fDisable); <br>VOID FitTextToButton( HWND, INT, LPSTR ); <br> <br>// Callback functions <br>BOOL CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK DialingProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK AboutProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK ConnectUsingProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK LineInUseProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK SpeedDial1Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK SpeedDial2Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>VOID CALLBACK tapiCallback (  <br>DWORD hDevice, DWORD dwMsg, <br>DWORD dwCallbackInstance,  <br>DWORD dwParam1, DWORD dwParam2,  <br>DWORD dwParam3 <br>    ); <br> <br>// tapi related functions <br>VOID ManageAssistedTelephony(VOID); <br>VOID InitiateCall(LPCSTR szNumber, LPCSTR szName); <br> <br>VOID DialerLineClose(VOID);  <br>VOID DialerCleanup(VOID); <br>VOID CloseTAPI(VOID); <br> <br>DWORD GetLineInfo(DWORD iLine, LPLINEINFO lpLineInfo); <br>VOID GetLineInfoFailed ( <br>DWORD iLine, LPLINEDEVCAPS lpDevCaps,  <br>LPLINEINFO lpLineInfo <br>    ); <br>LPSTR GetAddressName(DWORD iLine, DWORD iAddress); <br>BOOL MakeCanonicalNumber( LPCSTR szName, LPSTR szCanNumber ); <br> <br>// misc. helper functions <br>VOID ReadINI(VOID); <br>int errString(HWND hWnd, UINT errCode, UINT uFlags); <br>VOID AddToRedialList(LPCSTR szNumber); <br>BOOL InitializeLineBox(HWND hwndLineBox); <br>BOOL InitializeAddressBox(HWND hwndLineBox, HWND hwndAddressBox); <br>BOOL Is911 ( LPLINETRANSLATEOUTPUT lpTransOut ); <br>VOID AmpersandCompensate( LPCSTR lpszSrc, LPSTR lpszDst ); <br>VOID AmpersandDeCompensate( LPCSTR lpszSrc, LPSTR lpszDst ); <br> <br>// Dialer memory management functions <br>LPVOID DialerAlloc(size_t cbToAlloc); <br>LPVOID DialerFree(LPVOID lpMem); <br> <br> <br>// Function definitions <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>DWORD InitializeTAPI (VOID) <br>{ <br>INT cvLine; <br> <br>DWORD iLine; <br>DWORD dwPreferredPLID, dwID = (DWORD) -1; <br> <br>MSG msg; <br> <br>LPLINEINFO lpLineInfo = NULL;// LINEINFO for each available line <br> <br>    DWORD errCode; <br>    DWORD tc = GetTickCount(); <br>    DWORD dwReturn = ERR_NONE; <br> <br>char szBuffer[MAXBUFSIZE];// to read in dwPreferredPLID as a string first <br> <br> <br> <br>errCode = lineInitialize ( <br>&amp;ghLineApp, <br>ghInst, <br>(LINECALLBACK) tapiCallback, <br>gszAppName, <br>&amp;gnAvailDevices <br> ); <br>if ( errCode == LINEERR_REINIT ) <br>{ <br>// take away dialer functionality <br>EnableWindow( ghWndMain, FALSE ); <br>DisableDialButtons(TRUE); <br> <br>// keep trying until the user cancels <br>// or we stop getting LINEERR_REINIT <br>while ( ( errCode = lineInitialize (  <br>&amp;ghLineApp,               <br>ghInst, <br>(LINECALLBACK)tapiCallback, <br>gszAppName, <br>&amp;gnAvailDevices <br>    ) )  <br> == LINEERR_REINIT ) <br>{ <br>// flush queue &amp; yield <br>while ( PeekMessage( &amp;msg, 0, 0, 0, PM_REMOVE ) )  <br>{ <br>TranslateMessage( &amp;msg ); <br>DispatchMessage( &amp;msg ); <br>} <br> <br>// bring up the box if 5 seconds have passed since <br>if(GetTickCount() &gt; 5000 + tc) <br>{ <br>if ( errString( ghWndMain, ikszWarningTapiReInit, MB_RETRYCANCEL ) <br> == IDCANCEL ) <br>{ <br>break; <br>} <br>// reset the relative counter <br>tc = GetTickCount();  <br>}             <br>} <br> <br>// give back dialer functionality <br>DisableDialButtons( FALSE ); <br>EnableWindow( ghWndMain, TRUE ); <br>} <br> <br>if ( errCode ) <br>    { <br>        dwReturn = errCode; <br>        goto tapiinit_exit; <br>    } <br> <br>// retrieve preferred line info from INI file <br>GetPrivateProfileString ( <br>"Preference", <br>"Preferred Line", <br>gszNULL,  <br>szBuffer, <br>MAXBUFSIZE, <br>gszINIfilename <br>); <br> <br>// if szBuffer is not empty. <br>if ( lstrcmp ( gszNULL, szBuffer ) ) <br>{ <br>dwPreferredPLID = (DWORD) atoi( szBuffer ); <br>} <br>else <br>{ <br>dwPreferredPLID = (DWORD) -1; <br>} <br> <br>// -1 default - tells us if it ever gets set <br>giCurrentLine = (DWORD) -1; <br> <br>// allocate buffer for storing LINEINFO for all of the available lines <br>// always allocate space for at least one line <br>if ( gnAvailDevices == 0 ) <br>{ <br>gnAddr = (DWORD *) DialerAlloc( sizeof( DWORD ) ); <br>gdwPLID = (DWORD *) DialerAlloc( sizeof( DWORD ) ); <br>lpLineInfo = (LPLINEINFO) DialerAlloc( sizeof( LINEINFO ) ); <br>} <br>else <br>{ <br>gnAddr = (DWORD *) DialerAlloc( sizeof( DWORD ) * (int)gnAvailDevices); <br>gdwPLID = (DWORD *) DialerAlloc( sizeof( DWORD ) * (int)gnAvailDevices); <br>lpLineInfo = (LPLINEINFO) DialerAlloc( sizeof( LINEINFO ) * (int)gnAvailDevices ); <br>} <br> <br>// if no space was set aside... <br>if ( lpLineInfo == NULL || gnAddr == NULL ) <br>    { <br>        dwReturn = LINEERR_NOMEM; <br>        goto tapiinit_exit; <br>    } <br> <br>// fill lpLineInfo[] and open each line <br>for ( iLine = 0, cvLine = 0; iLine &lt; gnAvailDevices; ++iLine ) <br>{ <br>// skip remaining processing for this if it didn't open <br>if ( GetLineInfo( iLine, &amp;lpLineInfo[iLine] ) != ERR_NONE ) <br>continue;  <br> <br>gnAddr [ iLine ] = lpLineInfo[iLine].nAddr; <br>gdwPLID[ iLine ] = lpLineInfo[iLine].dwPermanentLineID; <br> <br>if ( lpLineInfo[iLine].dwPermanentLineID == dwPreferredPLID ) <br>giCurrentLine = iLine; <br> <br>// note number of lines with Interactive voice caps. <br>// used to select a preferred line by default <br>if ( lpLineInfo [ iLine ].fVoiceLine ) <br>{ <br>cvLine++; <br>dwID = iLine; <br>} <br>} <br> <br>// if we couldn't find the preferred line,  <br>// try and assign one by default  <br>// else bring up connect using dialog <br>if (  giCurrentLine == (DWORD)-1 )  <br>{ <br>// check if there is only one line <br>// that has interactive voice caps,  <br>// make it default line <br>if ( cvLine == 1 )  <br>{ <br>giCurrentLine = dwID; <br> <br>// if the preferred address read from the INI file <br>// was different i.e we are changing setting, inform <br>// the user <br>if ( dwPreferredPLID != -1 ) <br>{ <br>errString( ghWndMain, ERR_NEWDEFAULT, MB_ICONEXCLAMATION | MB_OK ); <br>} <br>} <br>else <br>{ <br>gCurrentLineInfo = lpLineInfo[0]; <br>if ( DialogBoxParam ( <br>ghInst, <br>MAKEINTRESOURCE(IDD_CONNECTUSING), <br>ghWndMain, <br>(DLGPROC)ConnectUsingProc, <br>INVALID_LINE <br>) <br> == -1) <br>{ <br>                dwReturn = (DWORD) -1; <br>} <br>else <br>{ <br>                dwReturn = ERR_NONE; <br>} <br> <br>            goto tapiinit_exit; <br>} <br>} <br>gCurrentLineInfo = lpLineInfo[ giCurrentLine ]; <br> <br> <br>// select default address <br>giCurrentAddress = 0; <br> <br>// get the name of the preferred address from ini file <br>GetPrivateProfileString ( <br>"Preference", <br>"Preferred Address", <br>gszNULL,  <br>szBuffer, <br>MAXBUFSIZE, <br>gszINIfilename <br>); <br> <br>// if preferred address read from INI file <br>if ( lstrcmp( gszNULL, szBuffer ) ) <br>{ <br>giCurrentAddress = (DWORD) atoi( szBuffer ); <br> <br>// if the address is invalid, set default <br>if ( giCurrentAddress &gt;= gCurrentLineInfo.nAddr ) <br>giCurrentAddress = 0; <br>} <br> <br> <br>tapiinit_exit: <br>     <br>    if (lpLineInfo) <br>    { <br>        DialerFree(lpLineInfo); <br>    } <br>     <br>return dwReturn;; <br>} <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>int WINAPI WinMain ( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, <br>int nCmdShow <br>   ) <br>{ <br>HACCEL hAccel; <br>MSG msg; <br>DWORD errCode; <br>HANDLE hImHere; <br> <br> <br>ghInst = GetModuleHandle( NULL ); <br>LoadString( ghInst, ikszAppFriendlyName, gszAppName, sizeof(gszAppName)/sizeof(TCHAR) ); <br> <br>// <br>// Now, let's see if we've already got an instance of ourself <br>hImHere = CreateMutex(NULL, TRUE, "DialersIveBeenStartedMutex"); <br> <br>// <br>// Is there another one of us already here? <br>if ( ERROR_ALREADY_EXISTS == GetLastError() ) <br>{ <br>        HWND        hDialerWnd; <br> <br>        hDialerWnd = FindWindow(gszDialerClassName, <br>                                NULL); <br> <br>        SetForegroundWindow(hDialerWnd); <br>         <br>   CloseHandle( hImHere ); <br>   return 0; <br>} <br> <br> <br>{ <br>WNDCLASS wc; <br>wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW; <br>wc.lpfnWndProc = DefDlgProc; <br>wc.cbClsExtra = 0; <br>wc.cbWndExtra = DLGWINDOWEXTRA; <br>wc.hInstance = ghInst; <br>wc.hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_DIALER) ); <br>wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>wc.hbrBackground = GetStockObject (COLOR_WINDOW + 1); <br>wc.lpszMenuName = NULL; <br>wc.lpszClassName = gszDialerClassName; <br>RegisterClass(&amp;wc); <br>} <br> <br> <br>// create the dialog box and set it with info <br>// from the .INI file <br>ghWndMain = CreateDialog ( <br>ghInst, <br>(LPCSTR)MAKEINTRESOURCE(IDD_DIALER), <br>(HWND)NULL, <br>MainWndProc <br> ); <br> <br>ReadINI(); <br>ButtonFontSetup(); <br> <br>ShowWindow(ghWndMain, SW_SHOW); <br>UpdateWindow(ghWndMain); <br> <br>// limit text in Number field to TAPIMAXDESTADDRESSSIZE <br>SendDlgItemMessage ( <br>ghWndMain, <br>IDD_DCOMBO, <br>CB_LIMITTEXT, <br>(WPARAM)TAPIMAXDESTADDRESSSIZE, <br>0 <br>   ); <br> <br>// 0 (ERR_NONE) error code registers success - otherwise terminate <br>errCode = InitializeTAPI(); <br>if(errCode) <br>{ <br>errString(ghWndMain, errCode, MB_APPLMODAL | MB_ICONEXCLAMATION ); <br> <br>DialerCleanup(); <br>return errCode; <br>} <br> <br>errCode = lineRegisterRequestRecipient ( <br>ghLineApp, <br>0, // registration instance <br>LINEREQUESTMODE_MAKECALL, <br>TRUE <br>   ); <br> <br>if(errCode) <br>{ <br>gfRegistered = FALSE; <br>errString(ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK ); <br>} <br>else <br>{ <br>gfRegistered = TRUE; <br>} <br> <br> <br>hAccel = LoadAccelerators(ghInst, gszAppName); <br> <br>while ( GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>{ <br>if ( ghWndMain == NULL || !IsDialogMessage( ghWndMain, &amp;msg ) ) <br>{ <br>if(!TranslateAccelerator(ghWndMain, hAccel, &amp;msg)) <br>{ <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>} <br>} <br> <br>// If: 1) Dialer is a call manager (if not, ignore requests) <br>//     2) the currently chosen line is available <br>//     3) there is a Simple TAPI request <br>// Then: process the request <br>if ( gfCurrentLineAvail &amp;&amp; gfCallRequest ) <br>{ <br>ManageAssistedTelephony(); <br>} <br>} <br> <br> <br>     <br>DialerCleanup(); <br> <br>CloseHandle( hImHere ); <br> <br>return msg.wParam; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>LPVOID DialerAlloc(size_t cbToAlloc) <br>{ <br>return LocalAlloc(LPTR, cbToAlloc); <br>} <br> <br> <br>LPVOID DialerFree(LPVOID lpMem) <br>{ <br>return LocalFree( lpMem ); <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID ReadINI( VOID )  <br>{ <br>    WORD cSDEntry, cLastDialed; <br>    DWORD cComma;  <br> <br>    POINT ptLeftTop; <br> <br>    char szName[ TAPIMAXCALLEDPARTYSIZE ]; <br>    char szTemp[ TAPIMAXCALLEDPARTYSIZE ]; <br> <br>    char szNum[MAXBUFSIZE]; <br>    char szFieldName[MAXBUFSIZE]; <br>    char szPt[MAXBUFSIZE]; <br>                   <br> <br>    // get speed dial settings from INI file <br>    for(cSDEntry = 1; cSDEntry &lt;= NSPEEDDIALS; ++cSDEntry) <br>    { <br> <br>        wsprintf(szFieldName, "Name%d", cSDEntry); <br>        GetPrivateProfileString ( <br>"Speed Dial Settings", <br>szFieldName, <br>gszNULL, <br>szName, <br>TAPIMAXCALLEDPARTYSIZE - 1, <br>gszINIfilename <br>); <br> <br>        wsprintf(szFieldName, "Number%d", cSDEntry); <br>        GetPrivateProfileString (  <br>"Speed Dial Settings", <br>szFieldName, <br>gszNULL, <br>gszSDNumber[cSDEntry], <br>TAPIMAXDESTADDRESSSIZE - 1, <br>gszINIfilename <br>);         <br> <br>if ( !lstrcmp( gszNULL, szName ) ) <br>{ <br>lstrcpy( szName, gszSDNumber[ cSDEntry ] ); <br>} <br> <br>FitTextToButton( ghWndMain, IDD_DSPEEDDIAL1 + cSDEntry - 1, szName ); <br> <br>AmpersandCompensate( szName, szTemp ); <br>SetDlgItemText ( <br>ghWndMain, <br>IDD_DSPEEDDIAL1 + cSDEntry - 1, <br>(LPCSTR)szTemp <br>   ); // Label the speed dial button <br>} <br> <br>     <br>// set up last dialed numbers in combo box (read from INI) <br>for(cLastDialed = 1; cLastDialed &lt;= NLASTDIALED; ++cLastDialed) <br>{ <br>wsprintf(szFieldName, "Last dialed %d", cLastDialed); <br>GetPrivateProfileString ( <br>"Last dialed numbers", <br>szFieldName, <br>gszNULL, <br>szNum, <br>MAXBUFSIZE - 1, <br>gszINIfilename <br>); <br>if ( szNum[0] ) // i.e. if szNum isn't simply "" - if we read something <br>// from the INI - put it in the combo box <br>SendDlgItemMessage( <br>ghWndMain, <br>IDD_DCOMBO, <br>CB_ADDSTRING, <br>0, <br>(LPARAM)(LPCSTR)szNum <br>  ); <br>} <br> <br>// set defaults <br>ptLeftTop.x = 100;  <br>ptLeftTop.y = 100; <br> <br>// set the window position based on the INI data <br>GetPrivateProfileString ( <br>"Preference", <br>"Main Window Left/Top", <br>gszNULL, <br>szPt, <br>MAXBUFSIZE - 1, <br>gszINIfilename <br>); <br> <br>if ( szPt[0] )  <br>{ <br>cComma = strcspn(szPt, ","); <br>szPt[cComma] = 0; <br>ptLeftTop.x = atoi(szPt); <br> <br>// a possibly absurd check to see that the string <br>// wasn't akin to "320," with no second entry <br>if ( *(szPt + cComma + 1 ) )  <br>ptLeftTop.y = atoi( szPt + cComma + 1 ); <br> <br>// check to see that the box is on the screen - the upper left <br>// must be on the screen, along with a 50x50 box below and to <br>// the right of it <br>if ( ptLeftTop.x &lt; 0 <br>|| ptLeftTop.x + 50 &gt;= GetSystemMetrics(SM_CXSCREEN) <br>|| ptLeftTop.y &lt; 0 <br>|| ptLeftTop.y + 50 &gt;= GetSystemMetrics(SM_CYSCREEN)             <br>   ) <br>{ <br>ptLeftTop.x = 100; // set defaults if the box is off of the screen <br>ptLeftTop.y = 100; // set defaults if the box is off of the screen <br>} <br>} <br> <br>SetWindowPos ( <br>ghWndMain, <br>NULL, <br>ptLeftTop.x, <br>ptLeftTop.y, <br>0, <br>0, <br>SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOREDRAW | SWP_NOZORDER <br> ); <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID ButtonFontSetup(VOID) <br>    { <br>    HDC hdc; <br>    int IDD; <br> <br>    // define the fonts for the buttons <br>    hdc = GetDC(GetDesktopWindow()); <br> <br>    ghFontBtn = CreateFont( <br>        (-10)*GetDeviceCaps(hdc, LOGPIXELSY)/72, <br>        0, <br>        0, <br>        0, <br>        FW_BOLD, <br>        FALSE, <br>        FALSE, <br>        FALSE, <br>        ANSI_CHARSET, <br>        OUT_DEFAULT_PRECIS, <br>        CLIP_DEFAULT_PRECIS, <br>        PROOF_QUALITY, <br>        VARIABLE_PITCH | FF_SWISS, <br>        (LPSTR)"Arial" <br>        ); <br> <br>    ghFontBtnText = CreateFont( <br>        (-6)*GetDeviceCaps(hdc, LOGPIXELSY)/72, <br>        0, <br>        0, <br>        0, <br>        FW_NORMAL, <br>        FALSE, <br>        FALSE, <br>        FALSE, <br>        ANSI_CHARSET, <br>        OUT_DEFAULT_PRECIS, <br>        CLIP_DEFAULT_PRECIS, <br>        PROOF_QUALITY, <br>        VARIABLE_PITCH | FF_SWISS, <br>        NULL <br>        ); <br> <br>    ghFontBtnStar = CreateFont( <br>        (-18)*GetDeviceCaps(hdc, LOGPIXELSY)/72, <br>        0, <br>        0, <br>        0, <br>        FW_BOLD, <br>        FALSE, <br>        FALSE, <br>        FALSE, <br>        SYMBOL_CHARSET, <br>        OUT_TT_PRECIS, <br>        CLIP_DEFAULT_PRECIS, <br>        PROOF_QUALITY, <br>        VARIABLE_PITCH | FF_DONTCARE, <br>        (LPSTR)"Symbol" <br>        ); <br> <br>    ReleaseDC(GetDesktopWindow(), hdc); <br> <br> <br>    // set the fonts for the buttons <br>    if(ghFontBtn) <br>        { <br>        // set fonts on number buttons <br>            for(IDD = IDD_DBUTTON1; IDD &lt;= IDD_DBUTTON0; ++IDD) <br>            // the order is IDD_DBUTTON1, 2, 3, ..., 0 (thus from 1 to 0) <br>            SendMessage( <br>                GetDlgItem(ghWndMain, IDD), <br>                WM_SETFONT, <br>                (WPARAM)ghFontBtn, <br>                0L <br>                ); <br>         <br>        // set fonts on * and # buttons <br>        SendMessage( <br>            GetDlgItem(ghWndMain, IDD_DBUTTONSTAR), <br>            WM_SETFONT, <br>            (WPARAM)ghFontBtnStar, <br>            0L <br>            ); <br>        SendMessage( <br>                    GetDlgItem(ghWndMain, IDD_DBUTTONPOUND), <br>            WM_SETFONT, <br>            (WPARAM)ghFontBtnStar, <br>            0L <br>            ); <br>        } <br>    } <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>// Draws a 3D button within rcBtn on hDC <br>VOID DrawButton(HDC hDC, RECT rcBtn, BOOL fHighlighted) <br>    { <br>    HPEN hPenPrev, hPenShadow, hPenHighlight, hPenBlack; <br>    HBRUSH hBrushPrev, hBrushFace; <br>    int RopPrev; <br> <br>    --rcBtn.right; <br>    --rcBtn.bottom; <br> <br>    // set up pens/brush <br>    hPenShadow = CreatePen(PS_SOLID,0,GetSysColor(COLOR_3DSHADOW)); <br>    hPenHighlight = CreatePen(PS_SOLID,0,GetSysColor(COLOR_3DHILIGHT)); <br>    hPenBlack = GetStockObject(BLACK_PEN); <br>    hBrushFace = GetSysColorBrush(COLOR_3DFACE); <br>     <br>    // get current state so we can put it back at the end of DrawButton <br>    hPenPrev = SelectObject(hDC, hPenBlack); <br>    RopPrev = SetROP2(hDC, R2_COPYPEN); <br>    hBrushPrev = SelectObject(hDC, hBrushFace); <br> <br>    PatBlt( <br>        hDC, <br>        rcBtn.left + 1, <br>        rcBtn.top + 1, <br>        rcBtn.right - rcBtn.left - 1, <br>        rcBtn.bottom - rcBtn.top - 1, <br>        PATCOPY <br>        ); <br>     <br>    if(fHighlighted) <br>        { <br>        SelectObject(hDC, hPenBlack); <br>        MoveToEx(hDC, rcBtn.left, rcBtn.bottom - 1, NULL); <br>        LineTo(hDC, rcBtn.left, rcBtn.top);  //  _ <br>        LineTo(hDC, rcBtn.right, rcBtn.top); // | <br> <br>        SelectObject(hDC, hPenHighlight); <br>        MoveToEx(hDC, rcBtn.right, rcBtn.top, NULL); <br>        LineTo(hDC, rcBtn.right, rcBtn.bottom); <br>        LineTo(hDC, rcBtn.left - 1, rcBtn.bottom); // _| <br> <br>        SelectObject(hDC, hPenShadow); <br>        MoveToEx(hDC, rcBtn.left + 1, rcBtn.bottom - 2, NULL); <br>        LineTo(hDC, rcBtn.left + 1, rcBtn.top + 1); <br>        LineTo(hDC, rcBtn.right - 1, rcBtn.top + 1); <br>        } <br>    else <br>        { <br>        SelectObject(hDC, hPenHighlight); <br>        MoveToEx(hDC, rcBtn.left, rcBtn.bottom - 1, NULL); <br>        LineTo(hDC, rcBtn.left, rcBtn.top);  //  _ <br>        LineTo(hDC, rcBtn.right, rcBtn.top); // | <br> <br>        SelectObject(hDC, hPenBlack); <br>        MoveToEx(hDC, rcBtn.right, rcBtn.top, NULL); <br>        LineTo(hDC, rcBtn.right, rcBtn.bottom); <br>        LineTo(hDC, rcBtn.left - 1, rcBtn.bottom); // _| <br> <br>        SelectObject(hDC, hPenShadow); <br>        MoveToEx(hDC, rcBtn.left + 1, rcBtn.bottom - 1, NULL); <br>        LineTo(hDC, rcBtn.right - 1, rcBtn.bottom - 1); <br>        LineTo(hDC, rcBtn.right - 1, rcBtn.top); <br>        } <br> <br>    // put everything back how it was <br>    SetROP2(hDC, RopPrev); <br>    SelectObject(hDC, hBrushPrev); <br>    SelectObject(hDC, hPenPrev); <br> <br>    DeleteObject(hPenBlack); <br>    DeleteObject(hPenShadow); <br>    DeleteObject(hPenHighlight);     <br>    DeleteObject(hBrushFace); <br>    } <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID DrawButtonText(HDC hDC, RECT rcBtn, BOOL fHighlighted, UINT IDD_Btn) <br>    {     <br>    char szLine1[MAXBUFSIZE]; // text in button up to '\n' <br>    LPSTR pszLine2; // text in button after '\n' <br>    int BkModePrev; <br>    HFONT hFontPrev = NULL; <br>    TEXTMETRIC tm; <br>    RECT rcText = rcBtn; <br>            <br>    BkModePrev = SetBkMode(hDC, TRANSPARENT); <br> <br>    GetDlgItemText(ghWndMain, IDD_Btn, szLine1, MAXBUFSIZE); <br>    pszLine2 = strstr(szLine1, "\n"); <br>    if(pszLine2) <br>        { <br>        *pszLine2 = 0; // 1 -&gt; "TEST1 \n TEST2" becomes "TEST 1 \0" <br>        ++pszLine2; // now 2 -&gt; " TEST 2" <br>        } <br> <br>    // now szLine1 points to the null terminated first string and <br>    // pszLine2 points to either the null terminated second string or NULL <br>    // if there was no second string <br> <br>    if(szLine1[0]) <br>        { <br>        if(ghFontBtnText &amp;&amp; pszLine2) <br>            hFontPrev = SelectObject(hDC, ghFontBtnText); <br>         <br>        GetTextMetrics(hDC, &amp;tm); <br>        rcText.bottom = (rcBtn.bottom + rcBtn.top)/2 - 2; <br>        rcText.top = rcText.bottom - (tm.tmHeight - 1); <br> <br>        if(pszLine2 == NULL) <br>            OffsetRect(&amp;rcText, 0, (rcText.bottom - rcText.top)/2); <br> <br>        if(fHighlighted) <br>            OffsetRect(&amp;rcText, 1, 1); <br> <br>        DrawText(hDC, szLine1, -1, &amp;rcText, DT_SINGLELINE | DT_CENTER); <br> <br>        if(hFontPrev) <br>            SelectObject(hDC, hFontPrev); <br>        } <br>    if(pszLine2) // recall that pszLine2 == NULL to represent no second string <br>        { <br>        GetTextMetrics(hDC, &amp;tm); <br>        if(IDD_Btn == IDD_DBUTTONSTAR || IDD_Btn == IDD_DBUTTONPOUND) <br>            rcText.top = (rcBtn.bottom + rcBtn.top)/2 - (tm.tmHeight)/2; <br>        else <br>            rcText.top = (rcBtn.bottom + rcBtn.top)/2 - 2; <br>        rcText.bottom = rcText.top + tm.tmHeight; <br> <br>        if(fHighlighted) <br>            OffsetRect(&amp;rcText, 1, 1); <br> <br>        DrawText(hDC, pszLine2, -1, &amp;rcText, DT_SINGLELINE | DT_CENTER); <br>        } <br> <br>    SetBkMode(hDC, BkModePrev); <br>    } <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID DisableDialButtons(BOOL fDisable) <br>{ <br>int IDD; <br> <br>// Disable/enable Dial button <br>EnableWindow( GetDlgItem( ghWndMain, IDD_DDIAL ),!fDisable) ; <br> <br>// Disable/enable Speed dial buttons <br>for ( IDD = IDD_DSPEEDDIAL1; IDD &lt;= IDD_DSPEEDDIAL8; ++IDD ) <br>{ <br>EnableWindow(GetDlgItem(ghWndMain, IDD),!fDisable); <br>} <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID DialerCleanup(VOID) <br>    { <br>    RECT rc; <br>    WORD cItem; // count of numbers in combo box <br>    DWORD cLastDialed; <br>    char szPt[MAXBUFSIZE]; <br>    char szNumber[TAPIMAXDESTADDRESSSIZE]; <br>    char szFieldName[MAXBUFSIZE]; <br> <br>    CloseTAPI(); // unregister and line close <br> <br>    if(!IsIconic(ghWndMain)) // if the window is not minimized, record position <br>        { <br>        GetWindowRect(ghWndMain, &amp;rc); <br>        wsprintf(szPt, "%ld, %ld", rc.left, rc.top); <br>        WritePrivateProfileString( <br>            "Preference", <br>            "Main Window Left/Top", <br>            szPt, <br>            gszINIfilename <br>            ); <br>        } <br> <br>    cItem = (WORD)SendDlgItemMessage(ghWndMain, IDD_DCOMBO, CB_GETCOUNT, 0, 0); <br> <br>    // write out last dialed numbers from combo box (write to INI) <br>    for(cLastDialed = 1; cLastDialed &lt;= NLASTDIALED; ++cLastDialed) <br>        { <br>        if(cLastDialed &lt;= cItem) <br>            SendDlgItemMessage( <br>                ghWndMain, <br>                IDD_DCOMBO, <br>                CB_GETLBTEXT, <br>                cLastDialed - 1, // it's a zero-based count <br>                (LPARAM)(LPCSTR)szNumber); <br> <br>        else <br>            szNumber[0] = 0; <br> <br>        wsprintf(szFieldName, "Last dialed %d", cLastDialed); <br>        WritePrivateProfileString( <br>            "Last dialed numbers", <br>            szFieldName, <br>            szNumber,             <br>            gszINIfilename <br>            ); <br> <br>        } <br> <br>    WinHelp(ghWndMain, gszHELPfilename, HELP_QUIT, 0); // unload help <br> <br>    DestroyWindow(ghWndMain); <br>    ghWndMain = NULL; <br> <br>    DeleteObject(ghFontBtn); <br>    DeleteObject(ghFontBtnText); <br>    DeleteObject(ghFontBtnStar); <br>    } <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>// unregister and line close <br>VOID CloseTAPI(VOID)  <br>{ <br> <br>// unregister as call manager <br>lineRegisterRequestRecipient ( <br>ghLineApp, <br>0, // registration instance <br>LINEREQUESTMODE_MAKECALL, <br>FALSE <br> ); <br> <br>if ( gCurrentLineInfo.hLine ) <br>{ <br>lineClose ( gCurrentLineInfo.hLine ); <br>gfCurrentLineAvail = FALSE; <br>gCurrentLineInfo.hLine = NULL; <br>} <br> <br>lineShutdown(ghLineApp); <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) </code></pre>
<p>
</p>
<pre><code>{ <br>static HICON hIcon; <br>static const DWORD aMenuHelpIDs[] =  <br>{ <br>        IDD_DSPEEDDIALGRP,   (DWORD)-1, <br>IDD_DNUMTODIAL,      IDH_DIALER_DIAL_NUMBER, <br>IDD_DCOMBO,          IDH_DIALER_DIAL_NUMBER, <br>IDD_DDIAL,           IDH_DIALER_DIAL_BUTTON, <br>IDD_DSPEEDDIAL1,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIAL2,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIAL3,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIAL4,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIAL5,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIAL6,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIAL7,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIAL8,     IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT1, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT2, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT3, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT4, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT5, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT6, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT7, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DSPEEDDIALTEXT8, IDH_DIALER_DIAL_SPEED_CHOOSE, <br>IDD_DBUTTON1,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON2,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON3,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON4,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON5,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON6,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON7,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON8,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON9,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTONSTAR,     IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTON0,        IDH_DIALER_DIAL_KEYPAD, <br>IDD_DBUTTONPOUND,    IDH_DIALER_DIAL_KEYPAD, <br>0,                   0 <br>}; <br> <br>        switch (msg) <br>        { <br>            case WM_INITDIALOG: <br>                hIcon = LoadIcon( ghInst, (LPCSTR) MAKEINTRESOURCE( IDI_DIALER ) ); <br>                return TRUE; <br> <br>            case WM_SYSCOMMAND: <br>                switch( (DWORD) wParam ) <br>                { <br>                    case SC_CLOSE:                     <br>                        PostQuitMessage(0); <br>                } <br>                break; <br> <br>                // processes clicks on controls when <br>                // context mode help is selected <br>            case WM_HELP:  <br>                WinHelp ( <br>                         ( (LPHELPINFO) lParam)-&gt;hItemHandle, <br>                         gszHELPfilename, <br>                         HELP_WM_HELP, <br>                         (DWORD)(LPVOID) aMenuHelpIDs <br>                        ); <br>                return TRUE; <br> <br>                // processes right-clicks on controls <br>            case WM_CONTEXTMENU: <br>                WinHelp ( <br>                         (HWND)wParam, <br>                         gszHELPfilename, <br>                         HELP_CONTEXTMENU, <br>                         (DWORD)(LPVOID)aMenuHelpIDs <br>                        ); <br>                return TRUE; <br> <br>            case WM_INITMENUPOPUP: <br>                // if edit menu <br>                if ( LOWORD(lParam) == 1 )  <br>                { <br>                    UINT wEnable; <br> <br>                    if ( GetParent( GetFocus() ) != GetDlgItem( ghWndMain, IDD_DCOMBO ) ) <br>                    { <br>                        wEnable = MF_GRAYED; <br>                    } <br>                    else <br>                    { <br>                        LONG lSelect = SendDlgItemMessage ( <br>                            ghWndMain, <br>                            IDD_DCOMBO, <br>                            CB_GETEDITSEL, <br>                            0, <br>                            0 <br>                            ); <br> <br>                        if ( HIWORD( lSelect ) != LOWORD( lSelect ) ) <br>                            wEnable = MF_ENABLED; <br>                        else <br>                            wEnable = MF_GRAYED; <br>                    } <br> <br>                    EnableMenuItem((HMENU)wParam, IDM_EDIT_CUT, wEnable); <br>                    EnableMenuItem((HMENU)wParam, IDM_EDIT_COPY, wEnable); <br>                    EnableMenuItem((HMENU)wParam, IDM_EDIT_DELETE, wEnable); <br> <br>                    // enable paste option is there is data  <br>                    // in the clipboard <br>                    if ( IsClipboardFormatAvailable( CF_TEXT ) ) <br>                    { <br>                        if ( GetClipboardData ( CF_TEXT ) ) <br>                        { <br>                            wEnable = MF_ENABLED; <br>                        } <br>                        else <br>                        { <br>                            wEnable = MF_GRAYED; <br>                        } <br>                    } <br>                    else <br>                    { <br>                        wEnable = MF_GRAYED; <br>                    } <br> <br>                } <br>                break; <br> <br> <br>            case WM_COMMAND: <br>            { <br>                char szName[TAPIMAXCALLEDPARTYSIZE] = {'\0'}; <br>                char szNumber[TAPIMAXDESTADDRESSSIZE] = {'\0'}; <br> <br>                switch( LOWORD( (DWORD)wParam ) ) <br>                { <br>                    // FILE menu <br>                    case IDM_EXIT: <br>                        PostQuitMessage(0);                     <br>                        return TRUE; <br> <br> <br>                        // EDIT menu <br>                    case IDM_EDIT_CUT: <br>                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_CUT, 0, 0); <br>                        return TRUE; <br> <br>                    case IDM_EDIT_COPY: <br>                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_COPY, 0, 0); <br>                        return TRUE; <br> <br>                    case IDM_EDIT_PASTE: <br>                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_PASTE, 0, 0); <br>                        return TRUE; <br> <br>                    case IDM_EDIT_DELETE: <br>                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_CLEAR, 0, 0); <br>                        return TRUE; <br> <br>                    case IDM_EDIT_SPEEDDIAL: <br>                        DialogBoxParam ( <br>                                        ghInst, <br>                                        MAKEINTRESOURCE(IDD_SD1), <br>                                        ghWndMain, <br>                                        (DLGPROC)SpeedDial1Proc, <br>                                        0 <br>                                       ); <br>                        SetFocus(GetDlgItem(ghWndMain, IDD_DDIAL)); <br>                        return TRUE; <br> <br>                        // TOOLS menu <br>                    case IDM_CONNECTUSING: <br>                        DialogBoxParam ( <br>                                        ghInst, <br>                                        MAKEINTRESOURCE(IDD_CONNECTUSING), <br>                                        ghWndMain, <br>                                        (DLGPROC)ConnectUsingProc, <br>                                        MENU_CHOICE <br>                                       ); <br>                        return TRUE; <br> <br>                    case IDM_LOCATION: <br>                    { <br>                        char szCanNumber[ TAPIMAXDESTADDRESSSIZE ] = ""; <br> <br>                        // fetch the number to be dialed <br>                        if ( GetDlgItemText (  <br>                                              ghWndMain, <br>                                              IDD_DCOMBO, <br>                                              szNumber, <br>                                              TAPIMAXDESTADDRESSSIZE <br>                                            ) <br>                           ) <br>                        { <br>                            // if a number exists, convert it to  <br>                            // its canonical form. <br>                            if ( !MakeCanonicalNumber ( szNumber, szCanNumber ) ) <br>                            { <br>                                lstrcpy( szCanNumber, szNumber ); <br>                            } <br>                        } <br> <br>                        lineTranslateDialog ( <br>                                             ghLineApp, <br>                                             0, <br>                                             TAPI_CURRENT_VERSION, <br>                                             ghWndMain, <br>                                             szCanNumber <br>                                            ); <br>                        return TRUE; <br> <br>                    } <br>                    // HELP menu <br>                    case IDM_HELP_CONTENTS: <br>                        WinHelp(ghWndMain, gszHELPfilename, HELP_CONTENTS, 0); <br>                        return TRUE; <br> <br>                    case IDM_HELP_WHATSTHIS: <br>                        PostMessage(ghWndMain, WM_SYSCOMMAND, SC_CONTEXTHELP, 0); <br>                        return TRUE; <br> <br>                    case IDM_ABOUT: <br>                        DialogBoxParam( <br>                                       ghInst, <br>                                       MAKEINTRESOURCE(IDD_ABOUT), <br>                                       ghWndMain, <br>                                       (DLGPROC)AboutProc, <br>                                       0 <br>                                      ); <br> <br>                        return TRUE; <br> <br> <br>                        // Accelerator processing <br>                    case IDM_ACCEL_NUMTODIAL: <br>                        if(GetActiveWindow() == ghWndMain) <br>                            SetFocus(GetDlgItem(ghWndMain, IDD_DCOMBO)); <br>                        return TRUE; <br> <br> <br>                        // Buttons <br>                    case IDD_DDIAL: <br> <br>                    { <br>                        DWORD cSDEntry; <br>                        char szSDNumber[TAPIMAXDESTADDRESSSIZE]; <br>                        char szFieldName[MAXBUFSIZE]; <br> <br>                        // check if number entered is dialable <br>                        if ( SendMessage ( <br>                                          GetDlgItem(ghWndMain, IDD_DCOMBO), <br>                                          WM_GETTEXTLENGTH, <br>                                          0, <br>                                          0 <br>                                         ) &gt; 0  <br>                           ) <br>                        { <br>                            // get the number to be dialed <br>                            GetDlgItemText ( <br>                                            ghWndMain, <br>                                            IDD_DCOMBO, <br>                                            (LPSTR)szNumber, <br>                                            TAPIMAXDESTADDRESSSIZE <br>                                           ); <br> <br>                            // check if it is a speed dial number.   <br>                            // If so choose the name to be displayed. <br>                            for( cSDEntry = 1; cSDEntry &lt;= NSPEEDDIALS; ++cSDEntry) <br>                            { <br>                                wsprintf(szFieldName, "Number%d", cSDEntry); <br>                                GetPrivateProfileString ( <br>                                    "Speed Dial Settings", <br>                                    szFieldName, <br>                                    gszNULL, <br>                                    szSDNumber, <br>                                    TAPIMAXCALLEDPARTYSIZE - 1, <br>                                    gszINIfilename <br>                                    ); <br> <br>                                // if the number matches, get the name <br>                                if ( lstrcmp(szSDNumber, szNumber) == 0 ) <br>                                { <br>                                    wsprintf( szFieldName, "Name%d", cSDEntry); <br>                                    GetPrivateProfileString ( <br>                                        "Speed Dial Settings", <br>                                        szFieldName, <br>                                        gszNULL, <br>                                        szName, <br>                                        TAPIMAXCALLEDPARTYSIZE - 1, <br>                                        gszINIfilename <br>                                        ); <br>                                    break; <br>                                } <br>                            } <br> <br>                            SetFocus( GetDlgItem( ghWndMain, IDD_DDIAL ) ); <br> <br>                            // once the currentline has been set <br>                            // using the connect proc <br>                            // the user must hit dial again  <br>                            if ( giCurrentLine == (DWORD)-1 ) <br>                            { <br>                                DialogBoxParam ( <br>                                                ghInst, <br>                                                MAKEINTRESOURCE(IDD_CONNECTUSING), <br>                                                ghWndMain, <br>                                                (DLGPROC)ConnectUsingProc, <br>                                                INVALID_LINE <br>                                               ); <br>                            } <br>                            else <br>                            { <br>                                AddToRedialList(szNumber); <br>                                InitiateCall(szNumber, szName); <br>                            } <br>                        } <br>                        return TRUE; <br>                    } <br> <br> <br>                    case IDD_DBUTTON1: <br>                    case IDD_DBUTTON2: <br>                    case IDD_DBUTTON3: <br>                    case IDD_DBUTTON4: <br>                    case IDD_DBUTTON5: <br>                    case IDD_DBUTTON6: <br>                    case IDD_DBUTTON7: <br>                    case IDD_DBUTTON8: <br>                    case IDD_DBUTTON9: <br>                    case IDD_DBUTTON0: <br>                    case IDD_DBUTTONSTAR: <br>                    case IDD_DBUTTONPOUND: <br>                    { <br>                        int     i; <br>                        TCHAR   szBuffer[TAPIMAXDESTADDRESSSIZE+1]; <br> <br>                        static const char digits[] = { '1', '2', '3', '4', <br>                        '5', '6', '7', '8', <br>                        '9', '0', '*', '#' }; <br> <br>                        i = SendDlgItemMessage(ghWndMain, <br>                                               IDD_DCOMBO, <br>                                               WM_GETTEXT, <br>                                               (WPARAM)TAPIMAXDESTADDRESSSIZE+1, <br>                                               (LPARAM)szBuffer); <br> <br>                        if (i &lt; TAPIMAXDESTADDRESSSIZE) <br>                        { <br>                            MoveMemory(szBuffer+gdwStartSel+1, <br>                                       szBuffer+gdwEndSel, <br>                                       i - ( gdwEndSel ) + 1 ); <br> <br>                            szBuffer[gdwStartSel] = digits[LOWORD(wParam) - IDD_DBUTTON1]; <br> <br>                            SendDlgItemMessage(ghWndMain, <br>                                               IDD_DCOMBO, <br>                                               WM_SETTEXT, <br>                                               0, <br>                                               (LPARAM)szBuffer); <br> <br>                            gdwStartSel++; <br>                            gdwEndSel = gdwStartSel; <br>                        } <br> <br>                        SetFocus(GetDlgItem(ghWndMain, IDD_DDIAL)); <br>                        EnableWindow(GetDlgItem(ghWndMain, IDD_DDIAL), TRUE); <br> <br>                        return TRUE; <br>                    } <br> <br> <br>                    case IDD_DCOMBO: <br> <br>                        if (HIWORD(wParam) == CBN_SELENDOK) <br>                        { <br>                            EnableWindow( GetDlgItem(ghWndMain, IDD_DDIAL), TRUE ); <br>                        } <br> <br>                        if ((HIWORD(wParam) == CBN_SELENDOK) || <br>                            (HIWORD(wParam) == CBN_SELENDCANCEL)) <br>                        { <br> <br>                            (DWORD)SendDlgItemMessage(ghWndMain, <br>                                IDD_DCOMBO, <br>                                CB_GETEDITSEL, <br>                                (WPARAM)&amp;gdwStartSel, <br>                                (LPARAM)&amp;gdwEndSel); <br>                            return FALSE; <br>                        } <br> <br>                        if ( HIWORD( wParam ) == CBN_EDITCHANGE ) <br>                        { <br>                            EnableWindow ( <br>                                          GetDlgItem( ghWndMain, IDD_DDIAL ), <br>                                          (BOOL) GetWindowTextLength ( <br>                                GetDlgItem ( <br>                                            ghWndMain, <br>                                            IDD_DCOMBO <br>                                           ) <br>                                ) <br>                                         ); <br>                            return TRUE; <br>                        } <br> <br>                        break; <br> <br>                    case IDD_DSPEEDDIAL1: <br>                    case IDD_DSPEEDDIAL2: <br>                    case IDD_DSPEEDDIAL3: <br>                    case IDD_DSPEEDDIAL4: <br>                    case IDD_DSPEEDDIAL5: <br>                    case IDD_DSPEEDDIAL6: <br>                    case IDD_DSPEEDDIAL7: <br>                    case IDD_DSPEEDDIAL8: <br>                    { <br>                        DWORD cSDEntry = LOWORD( (DWORD) wParam)  - IDD_DSPEEDDIAL1 + 1; <br>                        char szFieldName [MAXBUFSIZE]; <br> <br>                        // get information for the speed dial button <br>                        // from the INI file <br>                        wsprintf(szFieldName, "Name%d", cSDEntry);                     <br>                        GetPrivateProfileString ( <br>                            "Speed Dial Settings", <br>                            szFieldName, <br>                            gszNULL, <br>                            szName, <br>                            TAPIMAXCALLEDPARTYSIZE - 1, <br>                            gszINIfilename <br>                                                ); <br> <br>                        wsprintf(szFieldName, "%s%d", "Number", cSDEntry); <br>                        GetPrivateProfileString ( <br>                            "Speed Dial Settings", <br>                            szFieldName, <br>                            gszNULL, <br>                            gszSDNumber[cSDEntry], <br>                            TAPIMAXDESTADDRESSSIZE - 1, <br>                            gszINIfilename <br>                                                ); <br> <br>                        // entry not set yet <br>                        if( gszSDNumber[cSDEntry][0] == 0 ) <br>                        { <br>                            DialogBoxParam ( <br>                                            ghInst, <br>                                            MAKEINTRESOURCE(IDD_SD2), <br>                                            ghWndMain, <br>                                            (DLGPROC)SpeedDial2Proc, <br>                                            MAKELPARAM(wParam,0) <br>                                           ); <br>                        } <br>                         <br>                        // no line open <br>                        // once the currentline has been set <br>                        // using the connect proc <br>                        // the user must hit dial again  <br>                        else if ( giCurrentLine == (DWORD)-1) <br>                        { <br>                            DialogBoxParam ( <br>                                            ghInst, <br>                                            MAKEINTRESOURCE(IDD_CONNECTUSING), <br>                                            ghWndMain, <br>                                            (DLGPROC)ConnectUsingProc, <br>                                            INVALID_LINE <br>                                           ); <br>                        } <br>                        // entry is set and valid voice line is open <br>                        else <br>                        { <br>                            // add number to list box combo. <br>                            AddToRedialList( gszSDNumber[cSDEntry] ); <br>                            InitiateCall( gszSDNumber[cSDEntry], szName ); <br>                        } <br>                        break; <br>                    } <br>                           } // end switch (LOWORD((DWORD)wParam)) { ... } <br> <br>                            break; // end case WM_COMMAND <br>                            } <br> <br> <br>                                            case WM_PAINT: <br>                                            { <br>                                                PAINTSTRUCT ps; <br> <br> <br>                                                BeginPaint(ghWndMain, &amp;ps); <br> <br>                                                if(IsIconic(ghWndMain)) <br>                                                    DrawIcon(ps.hdc, 0, 0, hIcon); <br>                                                else <br>                                                { <br>                                                    HBRUSH hBrush; <br> <br>                                                    hBrush = GetSysColorBrush( COLOR_3DFACE ); <br>                                                    //                FillRect(ps.hdc, &amp;ps.rcPaint, GetStockObject(LTGRAY_BRUSH)); <br>                                                    FillRect(ps.hdc, &amp;ps.rcPaint, hBrush); <br>                                                } <br> <br>                                                EndPaint(ghWndMain, &amp;ps); <br> <br>                                                return TRUE; <br>                                            } <br> <br> <br>                                            case WM_DRAWITEM: <br>                                            { <br>                                                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam; <br>                                                BOOL fHighlighted = (SendDlgItemMessage( <br>                                                    ghWndMain, <br>                                                    lpdis-&gt;CtlID, <br>                                                    BM_GETSTATE, <br>                                                    0, <br>                                                    0 <br>                                                    ) &amp; 0x0004); <br> <br>                                                DrawButton(lpdis-&gt;hDC, lpdis-&gt;rcItem, fHighlighted); <br>                                                DrawButtonText( <br>                                                    lpdis-&gt;hDC, <br>                                                    lpdis-&gt;rcItem, <br>                                                    fHighlighted, <br>                                                    lpdis-&gt;CtlID <br>                                                    ); <br>                                                return TRUE; <br>                                            } <br> <br> <br>                                            case WM_CTLCOLORLISTBOX: <br>                                            case WM_CTLCOLORBTN: <br>                                            case WM_CTLCOLORSTATIC: <br>                                                SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE)); <br>                                                return (BOOL)GetSysColorBrush( COLOR_3DFACE ); <br> <br> <br>                                            default: <br>                                                ; <br>                                                //            return DefDlgProc( hwnd, msg, wParam, lParam ); <br>                                                //            return DefWindowProc( hwnd, msg, wParam, lParam ); <br> <br> <br>                    } // switch (msg) { ... } <br> <br>return FALSE; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID AddToRedialList( LPCSTR szNumber ) <br>{ <br>// NLASTDIALED == 10 <br>WORD cNum; <br>HWND hWndCombo = GetDlgItem(ghWndMain, IDD_DCOMBO); <br>DWORD nMatch; <br> <br>// if valid number <br>if ( szNumber[0] )  <br>{ <br>// if list box has entries, check if this number <br>// is already present.  If so delete old entry <br>cNum = (WORD) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0); <br>if ( cNum != 0 ) <br>{ <br>nMatch = SendMessage ( hWndCombo, CB_FINDSTRING, 0, (LPARAM)szNumber ); <br>if ( nMatch != CB_ERR ) <br>{ <br>SendMessage(hWndCombo, CB_DELETESTRING, nMatch, 0); <br>} <br>else  <br>{ <br>// if the list is full, remove oldest <br>if ( cNum == NLASTDIALED ) <br>{ <br>SendMessage( hWndCombo, CB_DELETESTRING, NLASTDIALED - 1, 0 ); <br>} <br>} <br>} <br>SendMessage(hWndCombo, CB_INSERTSTRING, 0, (LPARAM)szNumber); <br>SendMessage(hWndCombo, CB_SETCURSEL, 0, 0L); <br>EnableWindow ( GetDlgItem( ghWndMain, IDD_DDIAL ), TRUE );  <br>} <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID InitiateCall ( LPCSTR szNumber, LPCSTR szName ) <br>{ <br>HLINE hLine = NULL; <br> <br>DWORD errCode; <br> <br>// struct size info <br>DWORD dwLTPSize= sizeof ( LINETRANSLATEOUTPUT ); <br>DWORD dwNameLen= lstrlen( szName ) + 1; <br>DWORD dwLCPSize= sizeof( LINECALLPARAMS ); <br> <br>LPLINETRANSLATEOUTPUT lpTransOut = NULL; <br>LPLINECALLPARAMS lpLineCallParams = NULL; <br> <br>char szCanNumber[ TAPIMAXDESTADDRESSSIZE ]; <br> <br>// Open a line <br>errCode = lineOpen ( <br>ghLineApp, <br>giCurrentLine, <br>&amp;hLine, <br>gCurrentLineInfo.dwAPIVersion, <br>0, <br>0,  <br>LINECALLPRIVILEGE_NONE, <br>0, <br>NULL <br>   ); <br>if (errCode) <br>{ <br>errString ( ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK ); <br>goto error; <br>} <br> <br> <br>// call translate address before dialing <br>do <br>{ <br>lpTransOut = (LPLINETRANSLATEOUTPUT) DialerAlloc( dwLTPSize ); <br>if ( !lpTransOut ) <br>{ <br>errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br>lpTransOut-&gt; dwTotalSize = dwLTPSize; <br> <br> <br>if ( !MakeCanonicalNumber( szNumber, szCanNumber ) ) <br>{ <br>lstrcpy( szCanNumber, szNumber ); <br>} <br> <br>errCode = lineTranslateAddress ( <br>ghLineApp, <br>giCurrentLine, <br>gCurrentLineInfo.dwAPIVersion, <br>szCanNumber, <br>0, <br>0, <br>lpTransOut <br>   ); <br>if ( ((LONG)errCode) &lt; 0 ) <br>{ <br>errString( ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK ); <br>goto error; <br>} <br> <br>if ( lpTransOut-&gt; dwNeededSize &lt;= lpTransOut-&gt;dwTotalSize  ) <br>{ <br>// ok we are done <br>break; <br>} <br>else <br>{ <br>dwLTPSize = lpTransOut-&gt; dwNeededSize; <br>DialerFree ( lpTransOut ); <br>lpTransOut = NULL; <br>} <br> <br>} while ( TRUE ); <br> <br> <br>// if number dialed is 911, bring up a warning <br>if ( Is911( lpTransOut) ) <br>{ <br>INT nRes = errString ( ghWndMain, ERR_911WARN, MB_ICONSTOP | MB_YESNO ); <br>if ( nRes == IDNO ) <br>{ <br>goto error; <br>} <br>} <br> <br> <br>// set call parameters <br>dwLCPSize += dwNameLen + lpTransOut-&gt; dwDisplayableStringSize; <br> <br>lpLineCallParams = (LPLINECALLPARAMS) DialerAlloc( dwLCPSize ); <br>if ( !lpLineCallParams ) <br>{ <br>errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br> <br>lpLineCallParams-&gt;dwTotalSize = dwLCPSize; <br>lpLineCallParams-&gt;dwBearerMode = LINEBEARERMODE_VOICE; <br>lpLineCallParams-&gt;dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE; <br>lpLineCallParams-&gt;dwCallParamFlags = LINECALLPARAMFLAGS_IDLE; <br>lpLineCallParams-&gt;dwAddressMode = LINEADDRESSMODE_ADDRESSID; <br>lpLineCallParams-&gt;dwAddressID = giCurrentAddress; <br> <br>if ( szName[ 0 ] ) <br>{ <br>lpLineCallParams-&gt;dwCalledPartySize = dwNameLen; <br>lpLineCallParams-&gt;dwCalledPartyOffset = sizeof( LINECALLPARAMS ); <br>lstrcpy (  <br>(LPSTR) lpLineCallParams + sizeof(LINECALLPARAMS),  <br>szName  <br>    ); <br>} <br> <br>lpLineCallParams-&gt; dwDisplayableAddressSize = lpTransOut-&gt; dwDisplayableStringSize; <br>lpLineCallParams-&gt; dwDisplayableAddressOffset = sizeof( LINECALLPARAMS ) + dwNameLen; <br> <br>lstrcpy ( <br>(LPSTR) lpLineCallParams + sizeof(LINECALLPARAMS) + dwNameLen, <br>(LPSTR) lpTransOut + lpTransOut-&gt; dwDisplayableStringOffset <br>); <br> <br> <br>// save dialing information <br>// Free old allocs. <br>if ( gszCurrentName ) <br>{ <br>DialerFree ( gszCurrentName ); <br>} <br> <br>if ( gszCurrentNumber ) <br>{ <br>DialerFree ( gszCurrentNumber ); <br>} <br> <br>// save new stuff <br>gszCurrentName = (LPSTR) DialerAlloc( dwNameLen ); <br>if ( !gszCurrentName ) <br>{ <br>errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br>lstrcpy ( gszCurrentName, szName );  <br> <br>gszCurrentNumber = (LPSTR) DialerAlloc( lpTransOut-&gt; dwDisplayableStringSize ); <br>if ( !gszCurrentNumber ) <br>{ <br>errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br>lstrcpy (  <br> gszCurrentNumber,  <br> (LPSTR) lpTransOut + lpTransOut-&gt; dwDisplayableStringOffset   <br>); <br> <br>gCurrentLineInfo.hLine = hLine; <br>ghCall = NULL; <br> <br> <br>// finally make the call. <br>gMakeCallRequestID = 0; <br> <br>gMakeCallRequestID = lineMakeCall (  <br>hLine,  <br>&amp;ghCall,  <br>(LPSTR) lpTransOut + lpTransOut-&gt; dwDialableStringOffset,  <br>0,  <br>lpLineCallParams  <br>  ); <br> <br>// async request ID  <br>// - the call is going out <br>if ( (LONG) gMakeCallRequestID &gt; 0 )  <br>{ <br>gfCurrentLineAvail = FALSE; <br>gfMakeCallReplyPending = TRUE; <br>DialogBoxParam ( <br>ghInst, <br>MAKEINTRESOURCE(IDD_DIALING), <br>ghWndMain, <br>(DLGPROC)DialingProc, <br>0 <br>   ); <br> <br>} <br> <br>else  <br>{ <br>if ( gMakeCallRequestID == LINEERR_CALLUNAVAIL )  <br>{ <br>DialogBoxParam ( <br>ghInst, <br>MAKEINTRESOURCE(IDD_CALLFAILED), <br>ghWndMain, </code></pre>
<p>
</p>
<pre><code>(DLGPROC)LineInUseProc, <br>0 <br>   ); <br>} <br> <br>else <br>{ <br>errString( ghWndMain, gMakeCallRequestID, MB_ICONEXCLAMATION | MB_OK ); <br>} <br> <br>DialerLineClose(); <br>gfCurrentLineAvail = TRUE; <br>} <br> <br>error : <br>if ( lpLineCallParams ) <br>{ <br>DialerFree( lpLineCallParams ); <br>} <br> <br>if ( lpTransOut ) <br>{ <br>DialerFree( lpTransOut ); <br>} <br> <br>// if makecall did not succeed but line <br>// was opened, close it. <br>if ( ( gMakeCallRequestID &lt;= 0 ) &amp;&amp; ( gCurrentLineInfo.hLine ) ) <br>{ <br>DialerLineClose (); <br>gfCurrentLineAvail = TRUE; <br>} <br> <br>SetFocus( GetDlgItem( ghWndMain, IDD_DCOMBO ) ); <br> <br>return; <br> <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>DWORD GetLineInfo ( DWORD iLine, LPLINEINFO lpLineInfo ) <br>{ <br>DWORD errCode = 0; <br>DWORD dwNeededSize = 0;  <br>LINEEXTENSIONID ExtensionID; <br> <br>LPSTR pszLineName = NULL;  <br>LPLINEDEVCAPS lpDevCaps = NULL; <br> <br> <br>errCode = lineNegotiateAPIVersion ( <br>ghLineApp, <br>iLine, <br>TAPI_VERSION_1_0, <br>TAPI_CURRENT_VERSION, <br>&amp;( lpLineInfo-&gt;dwAPIVersion ), <br>&amp;ExtensionID <br>  ); <br>if ( errCode ) <br>{ <br>GetLineInfoFailed( iLine, lpDevCaps, lpLineInfo ); <br>goto error; <br>} <br> <br>dwNeededSize = sizeof( LINEDEVCAPS ); <br>do <br>{ <br>lpDevCaps = ( LPLINEDEVCAPS ) DialerAlloc( dwNeededSize ); <br>if ( !lpDevCaps ) <br>{ <br>GetLineInfoFailed( iLine, lpDevCaps, lpLineInfo ); <br>errCode = LINEERR_NOMEM; <br>goto error; <br>} <br> <br>lpDevCaps-&gt;dwTotalSize = dwNeededSize; <br>errCode = lineGetDevCaps ( <br>ghLineApp, <br>iLine, <br>lpLineInfo-&gt;dwAPIVersion, <br>0, <br>lpDevCaps <br> ); <br>if ( errCode ) <br>{ <br>GetLineInfoFailed( iLine, lpDevCaps, lpLineInfo ); <br>goto error; <br>} <br> <br>if ( lpDevCaps-&gt; dwNeededSize &lt;= lpDevCaps-&gt; dwTotalSize ) <br>{ <br>break; <br>} <br> <br>dwNeededSize = lpDevCaps-&gt;dwNeededSize; <br>DialerFree( lpDevCaps ); <br>lpDevCaps = NULL; <br> <br>} while ( TRUE ); <br> <br> <br>lpLineInfo-&gt;nAddr = lpDevCaps-&gt;dwNumAddresses; <br>lpLineInfo-&gt;fVoiceLine = <br>( (lpDevCaps-&gt;dwMediaModes &amp; LINEMEDIAMODE_INTERACTIVEVOICE) != 0 ); <br> <br>pszLineName = (LPSTR) DialerAlloc( MAXBUFSIZE ); <br>if ( !pszLineName ) <br>{ <br>errCode = LINEERR_NOMEM; <br>goto error; <br>} <br> <br>if ( lpDevCaps-&gt;dwLineNameSize &gt; 0 ) <br>{ <br>if ( lpDevCaps-&gt; dwLineNameSize &gt; (MAXBUFSIZE - 1) ) <br>{ <br>strncpy (  <br> pszLineName,  <br> (LPSTR) lpDevCaps + lpDevCaps-&gt;dwLineNameOffset, <br> MAXBUFSIZE - 1 <br>); <br>pszLineName[ MAXBUFSIZE - 1 ] = '\0'; <br>} <br>else <br>{ <br>lstrcpy( pszLineName, (LPSTR) lpDevCaps + lpDevCaps-&gt; dwLineNameOffset ); <br>} <br>} <br>else  <br>{ <br>wsprintf ( pszLineName, "Line %d", iLine ); <br>} <br> <br> <br>lstrcpy( lpLineInfo-&gt;szLineName, pszLineName ); <br>lpLineInfo-&gt;dwPermanentLineID = lpDevCaps-&gt;dwPermanentLineID; <br> <br> <br>error: <br>if ( lpDevCaps ) <br>DialerFree( lpDevCaps ); <br> <br>if ( pszLineName ) <br>DialerFree( pszLineName ); <br> <br>return errCode;  <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID GetLineInfoFailed ( DWORD iLine, LPLINEDEVCAPS lpDevCaps, LPLINEINFO lpLineInfo ) <br>{ <br>if ( lpDevCaps )  <br>DialerFree(lpDevCaps); <br> <br>lpLineInfo-&gt;nAddr = 0; <br>lpLineInfo-&gt;fVoiceLine = FALSE; <br>lpLineInfo-&gt;dwAPIVersion = 0;  <br>lpLineInfo-&gt;hLine = (HLINE)0; <br>lpLineInfo-&gt;dwPermanentLineID = 0; <br>lpLineInfo-&gt;szLineName[0] = 0; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>LPSTR GetAddressName(DWORD iLine, DWORD iAddress) <br>{ <br>DWORD errCode = 0; <br>DWORD dwNeededSize = 0;        <br>LPSTR pszAddressName = NULL; <br>LPLINEADDRESSCAPS lpAddressCaps = NULL; <br> <br>// allocate space for lineGetAddressCaps data <br>dwNeededSize = sizeof( LINEADDRESSCAPS ); <br> <br>do <br>{ <br>lpAddressCaps = ( LPLINEADDRESSCAPS )DialerAlloc( dwNeededSize ); <br>if ( !lpAddressCaps ) <br>{ <br>goto error; <br>} <br> <br>lpAddressCaps-&gt;dwTotalSize = dwNeededSize; <br>errCode = lineGetAddressCaps ( <br>ghLineApp, <br>iLine, <br>iAddress, <br>gCurrentLineInfo.dwAPIVersion, <br>0, <br>lpAddressCaps <br> ); <br>if ( errCode ) <br>{ <br>errString( ghWndMain, errCode, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br> <br>if ( lpAddressCaps-&gt; dwNeededSize &lt;= lpAddressCaps-&gt; dwTotalSize ) <br>{ <br>break; <br>} <br> <br>dwNeededSize = lpAddressCaps-&gt;dwNeededSize; <br>DialerFree( lpAddressCaps ); <br>lpAddressCaps = NULL; <br> <br>} while( TRUE ); <br> <br> <br>// get the address name <br>pszAddressName = DialerAlloc( MAXBUFSIZE ); <br>if ( !pszAddressName ) <br>{ <br>goto error; <br>} <br> <br>if ( lpAddressCaps-&gt; dwAddressSize &gt; 0 ) <br>{ <br>// keep string length bounded <br>if ( lpAddressCaps-&gt; dwAddressSize &gt; (MAXBUFSIZE - 1 ) ) <br>{ <br>strncpy(  <br>pszAddressName,  <br>(LPSTR) lpAddressCaps + lpAddressCaps-&gt;dwAddressOffset, <br>MAXBUFSIZE - 1 <br>   ); <br>pszAddressName[ MAXBUFSIZE - 1] = '\0'; <br>} <br>else <br>{ <br>lstrcpy (  <br> pszAddressName, <br> (LPSTR) lpAddressCaps + lpAddressCaps-&gt;dwAddressOffset <br>    ); <br>} <br>} <br>else  <br>// use default name <br>{ <br>wsprintf(pszAddressName, "Address %d", iAddress); <br>} <br> <br>error: <br>if ( lpAddressCaps ) <br>{ <br>DialerFree( lpAddressCaps ); <br>} <br> <br>return pszAddressName; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL CALLBACK DialingProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>switch(msg) <br>{ <br>char szTemp[ TAPIMAXCALLEDPARTYSIZE ]; <br> <br>case WM_INITDIALOG: <br>// set global handle to window <br>ghWndDialing = hwnd; <br> <br>AmpersandCompensate( gszCurrentName, szTemp ); <br>             <br>SetDlgItemText(hwnd, IDD_DGNUMBERTEXT, gszCurrentNumber); <br>SetDlgItemText(hwnd, IDD_DGNAMETEXT, szTemp ); <br>break; <br> <br>case WM_COMMAND: <br>switch ( LOWORD( (DWORD)wParam ) ) <br>{ <br>// hang up <br>case IDCANCEL:  <br>//gfDropping = TRUE; <br> <br>// if lineMakeCall has completed <br>// only then drop call. <br>if ( !gfMakeCallReplyPending &amp;&amp; ghCall ) <br>{ <br>if ( ( gDropCallRequestID = lineDrop ( ghCall, NULL, 0 ) ) &lt; 0 ) <br>{ <br>errString ( ghWndDialing, gDropCallRequestID, MB_ICONSTOP | MB_OK ); <br>} <br>} <br>else <br>{ <br>DialerLineClose(); <br>gfCurrentLineAvail = TRUE; <br>gfMakeCallReplyPending = FALSE; <br>} <br> <br>ghWndDialing = NULL; <br>EndDialog(hwnd, FALSE); <br> <br>return TRUE; <br> <br> <br>// something else terminated the call <br>// all we have to do is terminate this dialog box <br>case IDOK:  <br>ghWndDialing = NULL; <br>EndDialog(hwnd, TRUE); <br> <br>return TRUE; <br>} <br>break; <br> <br>default: <br>  ; <br>} <br>return FALSE; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL CALLBACK AboutProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(msg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>            return TRUE; <br>        } <br> <br>        case WM_CLOSE: <br>            EndDialog(hwnd, TRUE); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            if(LOWORD((DWORD)wParam) == IDOK) <br>            { <br>                EndDialog(hwnd, TRUE); <br>                return TRUE; <br>            } <br> <br>            break; <br>    } <br> <br>    return FALSE; <br>     <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL CALLBACK ConnectUsingProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>static const DWORD aMenuHelpIDs[] =  <br>{ <br>IDD_CUTEXTLINE,         IDH_DIALER_OPTIONS_LINE, <br>IDD_CULISTLINE,         IDH_DIALER_OPTIONS_LINE, <br>IDD_CUTEXTADDRESS,      IDH_DIALER_OPTIONS_ADDRESS, <br>IDD_CULISTADDRESS,      IDH_DIALER_OPTIONS_ADDRESS, <br>IDD_CUSIMPLETAPICHKBOX, IDH_DIALER_OPTIONS_VOICE, <br>IDD_CUPROPERTIES,       IDH_DIALER_OPTIONS_PROPERTIES, <br>0,                      0 <br>}; <br> <br>switch(msg) <br>{ <br>case WM_HELP:  <br>// processes clicks on controls when <br>// context mode help is selected <br>WinHelp ( <br>((LPHELPINFO)lParam)-&gt;hItemHandle, <br>gszHELPfilename, <br>HELP_WM_HELP, <br>(DWORD)(LPVOID)aMenuHelpIDs <br>); <br>return TRUE; <br> <br>case WM_CONTEXTMENU: <br>// processes right-clicks on controls <br>WinHelp ( <br>(HWND)wParam, <br>gszHELPfilename, <br>HELP_CONTEXTMENU, <br>(DWORD)(LPVOID)aMenuHelpIDs <br>); <br>return TRUE; <br> <br>case WM_INITDIALOG: <br>{ <br>BOOL fEnable; <br>DWORD dwPriority; <br> <br>// <br>// Is there any point in even showing this dialog box? <br>if ( gnAvailDevices == 0 ) <br>{ <br>// Nope.  Let's tell the user what we don't like. <br>errString ( ghWndMain, ERR_NOLINES, MB_ICONEXCLAMATION | MB_OK ); <br> <br>EndDialog(hwnd, FALSE); <br>return TRUE; <br>} <br> <br>// if not brought up by InitializeTAPI() <br>if ( lParam != INVALID_LINE )  <br>{ <br>// hide error text <br>EnableWindow( GetDlgItem( hwnd, IDD_CUERRORTEXT ), FALSE ); <br>} <br> <br>// get list of lines into the line list box. <br>fEnable = InitializeLineBox( GetDlgItem(hwnd, IDD_CULISTLINE) ); <br>EnableWindow( GetDlgItem( hwnd, IDD_CULISTLINE ), fEnable); <br> <br>// get list of addresses into the address list box. <br>fEnable =fEnable &amp;&amp;  <br>InitializeAddressBox ( <br>GetDlgItem(hwnd, IDD_CULISTLINE), <br>GetDlgItem(hwnd, IDD_CULISTADDRESS) <br> ); <br>EnableWindow( GetDlgItem( hwnd, IDD_CULISTADDRESS ), fEnable ); <br>EnableWindow( GetDlgItem( hwnd, IDOK ), fEnable ); <br> <br>EnableWindow( GetDlgItem( hwnd, IDD_CUPROPERTIES ), fEnable ); <br> <br>lineGetAppPriority ( <br>"DIALER.EXE", <br>0, // checking app priority for Assisted Telephony requests <br>NULL, <br>LINEREQUESTMODE_MAKECALL, <br>NULL, <br>&amp;dwPriority <br>   ); <br>CheckDlgButton(hwnd, IDD_CUSIMPLETAPICHKBOX, (dwPriority == 1)); <br> <br>// if dwPriority == 1, we're supporting Assisted Telephony AND <br>// have the highest priority. <br>EnableWindow ( <br>GetDlgItem(hwnd, IDD_CUSIMPLETAPICHKBOX), <br>gfRegistered <br> ); <br> <br>return FALSE; <br>} <br> <br>case WM_COMMAND: <br>{ <br>switch ( LOWORD( (DWORD)wParam ) ) <br>{ <br>case IDD_CULISTLINE: <br>if ( HIWORD( wParam ) == CBN_SELENDOK ) <br>// update address box <br>InitializeAddressBox ( <br>GetDlgItem(hwnd, IDD_CULISTLINE), <br>GetDlgItem(hwnd, IDD_CULISTADDRESS) <br> );  <br>break; <br> <br>case IDD_CUPROPERTIES: <br>{ <br>HWND hW = GetDlgItem(hwnd, IDD_CULISTLINE); <br> <br>lineConfigDialog ( <br>// device ID <br>(DWORD) SendMessage ( <br>hW, <br>CB_GETITEMDATA, <br>(WORD) SendMessage(hW, CB_GETCURSEL, 0, 0), <br>0 <br>    ),  <br>hwnd, <br>NULL <br> ); <br>break; <br>} <br> <br>case IDOK: <br>{ <br>HWND hwndBox; <br>char szBuffer[MAXBUFSIZE]; <br>DWORD dwPriority; <br> <br>// Update line <br>hwndBox = GetDlgItem( hwnd, IDD_CULISTLINE ); <br>giCurrentLine = SendMessage ( <br>hwndBox, <br>CB_GETITEMDATA, <br>SendMessage( hwndBox, CB_GETCURSEL, 0, 0 ), <br>0 <br>); <br> <br>// base 10 <br>itoa( gdwPLID[giCurrentLine], szBuffer, 10 );  <br>WritePrivateProfileString (   <br>"Preference", <br>"Preferred Line", <br>szBuffer, <br>gszINIfilename <br>  ); <br> <br> <br>// Update address <br>hwndBox = GetDlgItem( hwnd, IDD_CULISTADDRESS ); <br>giCurrentAddress = SendMessage ( <br>hwndBox, <br>CB_GETITEMDATA, <br>SendMessage(hwndBox, CB_GETCURSEL, 0, 0), <br>0 <br>   ); <br> <br>itoa( giCurrentAddress, szBuffer, 10 );  <br>WritePrivateProfileString (  <br>"Preference", <br>"Preferred Address", <br>szBuffer, <br>gszINIfilename <br>  ); <br> <br> <br>// Update application priority <br>if ( SendDlgItemMessage ( <br>hwnd, <br>IDD_CUSIMPLETAPICHKBOX, <br>BM_GETCHECK, <br>0, <br>0L <br>) <br>  == 0) <br>{ <br>dwPriority = 0; <br>} <br>else    <br>{ <br>dwPriority = 1; <br>} <br> <br>lineSetAppPriority ( <br>"DIALER.EXE", <br>0, <br>NULL, <br>LINEREQUESTMODE_MAKECALL, <br>NULL, <br>dwPriority <br>   ); <br> <br>EndDialog(hwnd, TRUE); <br>return TRUE; <br>} <br> <br>case IDCANCEL: <br>EndDialog(hwnd, FALSE); <br>return TRUE; <br>} <br>} <br> <br>default: <br>  ; <br> <br>} <br> <br>return FALSE; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL CALLBACK LineInUseProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>    { <br>    LPARAM lNewParam = lParam; <br>    PTSTR  ptStr; <br> <br> <br>    switch(msg) <br>        { <br>        case WM_INITDIALOG: <br>            { <br>            switch(lParam) <br>                { <br>                case LINEDISCONNECTMODE_REJECT: <br>                    lNewParam = ikszDisconnectedReject; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_BUSY: <br>                    lNewParam = ikszDisconnectedBusy; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_NOANSWER: <br>                    lNewParam = ikszDisconnectedNoAnswer; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_CONGESTION: <br>                    lNewParam = ikszDisconnectedNetwork; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_INCOMPATIBLE: <br>                    lNewParam = ikszDisconnectedIncompatible; <br>                    break; <br> <br>                case LINEDISCONNECTMODE_NODIALTONE: <br>                    lNewParam = ikszDisconnectedNoDialTone; <br>                    break; <br> <br>                default: <br>                    lNewParam = ikszDisconnectedCantDo; <br>                    break; <br>                } <br>            return TRUE; <br>            } <br> <br>        case WM_COMMAND: <br>            if(LOWORD((DWORD)wParam) == IDOK) <br>                { <br>                EndDialog(hwnd, TRUE); <br>                return TRUE; <br>                } <br>            break; <br> <br>        default: <br>              ; <br>//            return DefDlgProc( hwnd, msg, wParam, lParam ); <br> <br>        }     <br> <br> <br>    ptStr = DialerAlloc( MAXBUFSIZE ); <br> <br>    LoadString( ghInst, lNewParam, ptStr, MAXBUFSIZE ); <br> <br>    SetDlgItemText( <br>        hwnd, <br>        IDD_CFTEXT, <br>        ptStr <br>        ); <br> <br>    DialerFree( ptStr ); <br> <br> <br>    return FALSE; <br>    } <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL CALLBACK SpeedDial1Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>static DWORD nCurrentSpeedDial; <br> <br>static const DWORD aMenuHelpIDs[] =  <br>{ <br>IDOK,                   IDH_DIALER_SPEED_SAVE, <br>IDD_SD1SPEEDDIAL1,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIAL2,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIAL3,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIAL4,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIAL5,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIAL6,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIAL7,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIAL8,      IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT1,  IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT2,  IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT3,  IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT4,  IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT5,  IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT6,  IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT7,  IDH_DIALER_BUTTONS, <br>IDD_SD1SPEEDDIALTEXT8,  IDH_DIALER_BUTTONS, <br>IDD_SD1TEXTNAME,        IDH_DIALER_SPEED_NAME, <br>IDD_SD1EDITNAME,        IDH_DIALER_SPEED_NAME, <br>IDD_SD1TEXTNUMBER,      IDH_DIALER_SPEED_NUMBER, <br>IDD_SD1EDITNUMBER,      IDH_DIALER_SPEED_NUMBER, <br>IDD_SD1TEXTCHOOSE,      (DWORD)-1, <br>IDD_SD1TEXTENTER,       (DWORD)-1, <br>0,                      0 <br>}; <br> <br>// buffer to store speed dial names till they are saved. <br>static TCHAR szSDName[NSPEEDDIALS + 1][TAPIMAXDESTADDRESSSIZE]; <br> <br>switch(msg) <br>{ <br>case WM_HELP: <br>// processes clicks on controls when <br>// context mode help is selected <br>WinHelp( <br>((LPHELPINFO)lParam)-&gt;hItemHandle, <br>gszHELPfilename, <br>HELP_WM_HELP, <br>(DWORD)(LPVOID)aMenuHelpIDs <br>); <br>return TRUE; <br> <br>case WM_CONTEXTMENU: // processes right-clicks on controls <br>WinHelp( <br>(HWND)wParam, <br>gszHELPfilename, <br>HELP_CONTEXTMENU, <br>(DWORD)(LPVOID)aMenuHelpIDs <br>); <br>return TRUE; <br> <br>case WM_INITDIALOG: <br>{ <br>DWORD cSDEntry; <br>DWORD idFirstEmpty = (DWORD) -1; <br> <br>char szName[TAPIMAXCALLEDPARTYSIZE]; <br>char szTemp[TAPIMAXCALLEDPARTYSIZE]; <br>char szFieldName[MAXBUFSIZE]; <br> <br>// Retrieve speed dial info from INI file <br>for(cSDEntry = 1; cSDEntry &lt;= NSPEEDDIALS; ++cSDEntry) <br>{ <br>wsprintf(szFieldName, "Name%d", cSDEntry);         <br>GetPrivateProfileString ( <br>"Speed Dial Settings", <br>szFieldName, <br>gszNULL, <br>szSDName[ cSDEntry ], <br>TAPIMAXCALLEDPARTYSIZE - 1, <br>gszINIfilename <br>); <br> <br>// set the first empty speed dial button <br>if ( idFirstEmpty == -1 &amp;&amp;  <br> szSDName[ cSDEntry ][0] == '\0' &amp;&amp; <br> gszSDNumber[ cSDEntry ][ 0 ] == '\0' ) <br>idFirstEmpty = cSDEntry; <br> <br>wsprintf(szFieldName, "Number%d", cSDEntry); <br>GetPrivateProfileString ( <br>"Speed Dial Settings", <br>szFieldName, <br>gszNULL, <br>gszSDNumber[cSDEntry], <br>MAXBUFSIZE - 1, <br>gszINIfilename <br>); <br> <br>// get a copy of the name for editing <br>// if name is empty, use the number as the <br>// name. <br>if ( lstrcmp( gszNULL, szSDName[ cSDEntry ] ) ) <br>{ <br>lstrcpy( szName, szSDName[ cSDEntry] ); <br>} <br>else <br>{ <br>lstrcpy( szName, gszSDNumber[ cSDEntry ] ); <br>} <br> <br>FitTextToButton( hwnd, IDD_SD1SPEEDDIAL1 + cSDEntry - 1, szName ); <br>AmpersandCompensate( szName, szTemp ); <br> <br>SetDlgItemText ( <br>hwnd, <br>IDD_SD1SPEEDDIAL1 + cSDEntry - 1, <br>(LPCSTR) szTemp <br>   );  <br> <br>} <br> <br>// for the edit speed dial dialog <br>// limit the lengths of text <br>SendDlgItemMessage ( <br>hwnd, <br>IDD_SD1EDITNAME, <br>EM_LIMITTEXT, <br>(WPARAM)(TAPIMAXCALLEDPARTYSIZE - 1), <br>0 <br>   ); <br> <br>SendDlgItemMessage ( <br>hwnd, <br>IDD_SD1EDITNUMBER, <br>EM_LIMITTEXT, <br>(WPARAM)(TAPIMAXDESTADDRESSSIZE - 1), <br>0 <br>   ); <br> <br>// select the first empty button <br>// nothing empty, then edit #1 <br>if ( -1 == idFirstEmpty )  <br>{ <br>nCurrentSpeedDial = 1; <br>SetDlgItemText( <br>hwnd, <br>IDD_SD1EDITNAME, <br>(LPCSTR) szSDName[ 1 ] <br>  ); <br> <br>SetDlgItemText( <br>hwnd, <br>IDD_SD1EDITNUMBER, <br>(LPCSTR) gszSDNumber[ 1 ] <br>  ); <br>} <br>else <br>{ <br>nCurrentSpeedDial = idFirstEmpty; <br>} <br> <br>SetFocus( GetDlgItem( hwnd, IDD_SD1EDITNAME ) ); <br>return FALSE; <br>} <br> <br>case WM_COMMAND: <br>{ <br>char szName[TAPIMAXCALLEDPARTYSIZE]; <br>char szTemp[ TAPIMAXCALLEDPARTYSIZE ]; <br> <br>switch( LOWORD( (DWORD) wParam ) ) <br>{ <br>case IDOK: <br>{ <br>DWORD cSDEntry; <br>char szFieldName[MAXBUFSIZE]; <br> <br>// save new speed dial settings <br>for ( cSDEntry = 1; cSDEntry &lt;= NSPEEDDIALS; ++cSDEntry ) <br>{ <br>wsprintf(szFieldName, "Name%d", cSDEntry); <br>WritePrivateProfileString (  <br>"Speed Dial Settings", <br>szFieldName, <br>szSDName [cSDEntry], <br>gszINIfilename <br>  ); <br> <br>wsprintf(szFieldName, "Number%d", cSDEntry); <br>WritePrivateProfileString (  <br>"Speed Dial Settings", <br>szFieldName, <br>gszSDNumber[cSDEntry], <br>gszINIfilename <br>  ); <br> <br>// set the text for the corresponding  <br>// main window button <br>if ( szSDName[ cSDEntry ][ 0 ] == '\0' ) <br>{ <br>lstrcpy( szName, gszSDNumber[ cSDEntry ] ); <br>} <br>else <br>{ <br>lstrcpy( szName, szSDName[ cSDEntry ] ); <br>} <br> <br>FitTextToButton(  <br>ghWndMain,  <br>IDD_DSPEEDDIAL1 + cSDEntry - 1,  <br>szName  <br>   ); <br> <br>AmpersandCompensate( szName, szTemp ); <br>SetDlgItemText (  <br>ghWndMain, <br>IDD_DSPEEDDIAL1 + cSDEntry - 1, <br>(LPCSTR) szTemp <br>   ); <br>} <br> <br>EndDialog(hwnd, TRUE); <br>return TRUE; <br>} <br> <br>case IDCANCEL: <br>EndDialog(hwnd, FALSE); <br>return TRUE; <br> <br>case IDD_SD1SPEEDDIAL1: <br>case IDD_SD1SPEEDDIAL2: <br>case IDD_SD1SPEEDDIAL3: <br>case IDD_SD1SPEEDDIAL4: <br>case IDD_SD1SPEEDDIAL5: <br>case IDD_SD1SPEEDDIAL6: <br>case IDD_SD1SPEEDDIAL7: <br>case IDD_SD1SPEEDDIAL8: <br> <br>nCurrentSpeedDial =LOWORD( (DWORD) wParam ) - IDD_SD1SPEEDDIAL1 + 1; <br> <br>SetDlgItemText ( <br>hwnd, <br>IDD_SD1EDITNAME, <br>szSDName [ nCurrentSpeedDial ] <br>   ); <br>SetDlgItemText ( <br>hwnd, <br>IDD_SD1EDITNUMBER, <br>gszSDNumber[nCurrentSpeedDial] <br>   ); <br> <br>SetFocus( GetDlgItem( hwnd, IDD_SD1EDITNAME ) ); <br>SendDlgItemMessage( <br>hwnd, <br>IDD_SD1EDITNAME, <br>EM_SETSEL, <br>0, <br>MAKELPARAM(0, -1) <br>); <br>break; <br> <br>case IDD_SD1EDITNAME: <br>if ( HIWORD( wParam ) == EN_CHANGE ) <br>{ <br> <br>GetDlgItemText ( <br>hwnd, <br>IDD_SD1EDITNAME, <br>szName, <br>TAPIMAXCALLEDPARTYSIZE <br>   ); <br> <br>// if there is no name, label the button with <br>// the number <br>if ( szName[ 0 ] == '\0' ) <br>{ <br>szSDName[ nCurrentSpeedDial ][ 0 ] = '\0'; <br>lstrcpy( szName, gszSDNumber[ nCurrentSpeedDial ] ); <br>} <br>else <br>{ <br>lstrcpy( szSDName[ nCurrentSpeedDial ], szName ); <br>} <br> <br>FitTextToButton (  <br>hwnd,  <br>IDD_SD1SPEEDDIAL1 + nCurrentSpeedDial - 1, <br>szName <br>); <br>AmpersandCompensate( szName, szTemp ); <br> <br>SetDlgItemText ( <br>hwnd, <br>IDD_SD1SPEEDDIAL1 + nCurrentSpeedDial - 1, <br>szTemp <br>   ); <br>} <br>break; <br> <br>case IDD_SD1EDITNUMBER: <br>if ( HIWORD( wParam ) == EN_CHANGE ) <br>{ <br>GetDlgItemText ( <br>hwnd, <br>IDD_SD1EDITNUMBER, <br>gszSDNumber[nCurrentSpeedDial], <br>TAPIMAXDESTADDRESSSIZE <br>   ); <br> <br>if ( gszSDNumber[ nCurrentSpeedDial ][ 0 ] == '\0' ) <br>{ <br>GetDlgItemText ( <br>hwnd, <br>IDD_SD1EDITNAME, <br>szName, <br>TAPIMAXDESTADDRESSSIZE <br>   ); <br> <br>if ( szName[ 0 ] == '\0' ) <br>{ <br>SetDlgItemText (  <br>hwnd, <br>IDD_SD1SPEEDDIAL1 + nCurrentSpeedDial - 1, <br>szName <br>   ); <br> <br>} <br>} <br>} <br>break; <br>} // switch(LOWORD((DWORD)wParam)) <br>break; <br> <br>} // case WM_COMMAND: <br> <br>default: <br>  ; <br> <br>} // switch(msg) <br> <br>return FALSE; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL CALLBACK SpeedDial2Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>static DWORD nCurrentSpeedDial; <br> <br>static const DWORD aMenuHelpIDs[] =  <br>{ <br>IDOK,                   IDH_DIALER_SPEED_SAVE, <br>IDD_SD2SAVEANDDIAL,     IDH_DIALER_SPEED_SAVE_DIAL, <br>IDD_SD2TEXTNAME,        IDH_DIALER_SPEED_NAME, <br>IDD_SD2EDITNAME,        IDH_DIALER_SPEED_NAME, <br>IDD_SD2TEXTNUMBER,      IDH_DIALER_SPEED_NUMBER, <br>IDD_SD2EDITNUMBER,      IDH_DIALER_SPEED_NUMBER, <br>0,                      0 <br>}; <br> <br>switch(msg) <br>{ <br>case WM_HELP:  <br>// processes clicks on controls when <br>// context mode help is selected <br>WinHelp ( <br>((LPHELPINFO)lParam)-&gt;hItemHandle, <br>gszHELPfilename, <br>HELP_WM_HELP, <br>(DWORD)(LPVOID)aMenuHelpIDs <br>); <br>return TRUE; <br> <br>case WM_CONTEXTMENU:  <br>// processes right-clicks on controls <br>WinHelp ( <br>(HWND)wParam, <br>gszHELPfilename, <br>HELP_CONTEXTMENU, <br>(DWORD)(LPVOID)aMenuHelpIDs <br>); <br>return TRUE; <br> <br>case WM_INITDIALOG: <br>{ <br>char szFieldName [MAXBUFSIZE]; <br>char szName [TAPIMAXCALLEDPARTYSIZE]; <br> <br>nCurrentSpeedDial = LOWORD( lParam ) - IDD_DSPEEDDIAL1 + 1; <br> <br>// retrieve speed dial button info <br>wsprintf(szFieldName, "Name%d", nCurrentSpeedDial); <br>GetPrivateProfileString ( <br>"Speed Dial Settings", <br>szFieldName, <br>gszNULL, <br>szName, <br>TAPIMAXCALLEDPARTYSIZE - 1, <br>gszINIfilename <br>); <br>SetDlgItemText ( <br>hwnd, <br>IDD_SD2EDITNAME, <br>szName <br>   ); <br> <br>SetDlgItemText ( <br>hwnd, <br>IDD_SD2EDITNUMBER, <br>gszSDNumber[nCurrentSpeedDial] <br>   ); <br> <br>// limit the lengths of the texts <br>SendDlgItemMessage ( <br>hwnd, <br>IDD_SD2EDITNAME, <br>EM_LIMITTEXT, <br>(WPARAM)(TAPIMAXCALLEDPARTYSIZE - 1), <br>0 <br>   ); <br> <br>SendDlgItemMessage ( <br>hwnd, <br>IDD_SD2EDITNUMBER, <br>EM_LIMITTEXT, <br>(WPARAM)(TAPIMAXDESTADDRESSSIZE - 1), <br>0 <br>   ); <br> <br> <br>SetFocus( GetDlgItem( hwnd, IDD_SD2EDITNAME ) ); <br>SendDlgItemMessage ( <br>hwnd, <br>IDD_SD2EDITNAME, <br>EM_SETSEL, <br>0, <br>MAKELPARAM(0, -1) <br>   ); <br> <br>return FALSE; <br>} <br> <br>case WM_COMMAND: <br>{ <br>char szName[ TAPIMAXCALLEDPARTYSIZE ]; <br>char szTemp[ TAPIMAXCALLEDPARTYSIZE ]; <br>char szFieldName[MAXBUFSIZE]; <br> <br>switch ( LOWORD( (DWORD) wParam ) ) <br>{ <br>case IDOK: <br>case IDD_SD2SAVEANDDIAL: <br>{ <br>GetDlgItemText ( <br>hwnd, <br>IDD_SD2EDITNAME, <br>(LPTSTR) szName, <br>TAPIMAXCALLEDPARTYSIZE <br>   ); <br> <br>GetDlgItemText ( <br>hwnd, <br>IDD_SD2EDITNUMBER, <br>(LPTSTR) gszSDNumber[nCurrentSpeedDial], <br>TAPIMAXCALLEDPARTYSIZE <br>   ); <br> <br>wsprintf ( szFieldName, "Name%d", nCurrentSpeedDial ); <br> <br>WritePrivateProfileString (  <br>"Speed Dial Settings", <br>szFieldName, <br>szName, <br>gszINIfilename <br>  ); <br> <br>wsprintf ( szFieldName, "Number%d", nCurrentSpeedDial ); <br>WritePrivateProfileString (  <br>"Speed Dial Settings", <br>szFieldName, <br>gszSDNumber[nCurrentSpeedDial], <br>gszINIfilename <br>  ); <br> <br>// update main window buttons <br>// is only number has been entered, label button with it. <br>if ( szName[ 0 ] == '\0' ) <br>{ <br>lstrcpy( szName, gszSDNumber[ nCurrentSpeedDial ] ); <br>} <br> <br>FitTextToButton (  <br>ghWndMain,  <br>IDD_DSPEEDDIAL1 + nCurrentSpeedDial - 1,  <br>(LPSTR) szName <br>); <br> <br>AmpersandCompensate( szName, szTemp ); <br> <br>SetDlgItemText (  <br>ghWndMain, <br>IDD_DSPEEDDIAL1 + nCurrentSpeedDial - 1, <br>(LPCSTR)szTemp <br>   ); <br> <br>// if save and dial, then post dial message to main window <br>if ( LOWORD( (DWORD) wParam ) == IDD_SD2SAVEANDDIAL ) <br>{ <br>PostMessage ( </code></pre>
<p>
</p>
<pre><code>ghWndMain, <br>WM_COMMAND, <br>MAKEWPARAM ( <br>nCurrentSpeedDial + IDD_DSPEEDDIAL1 - 1, <br>BN_CLICKED <br>   ), <br>(LPARAM) GetDlgItem ( <br>ghWndMain, <br>nCurrentSpeedDial + IDD_DSPEEDDIAL1 - 1 <br>) <br>); <br>} <br>EndDialog(hwnd, TRUE); <br>return TRUE; <br>} <br> <br>case IDCANCEL: <br>EndDialog(hwnd, FALSE); <br>return TRUE; <br> <br>case IDD_SD2EDITNAME: <br>case IDD_SD2EDITNUMBER: <br>if ( HIWORD( wParam ) == EN_CHANGE) <br>{ <br>EnableWindow ( <br>GetDlgItem( hwnd, IDD_SD2SAVEANDDIAL ), <br>GetWindowTextLength ( GetDlgItem( hwnd, IDD_SD2EDITNUMBER ) ) &gt; 0 <br> ); <br>} <br>break; <br> <br>} // switch(LOWORD((DWORD)wParam)) <br>break; <br>} <br> <br> <br>default: <br>  ; <br> <br>} // switch(msg) <br> <br>return FALSE; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID CALLBACK <br>tapiCallback ( <br>DWORD   hDevice, <br>DWORD   dwMsg, <br>DWORD   dwCBInstance, <br>DWORD   dwParam1, <br>DWORD   dwParam2, <br>DWORD   dwParam3 <br>    ) <br>{ <br>switch (dwMsg) <br>{ <br>INT errCode; <br> <br>case LINE_ADDRESSSTATE: <br>break; <br> <br>case LINE_CALLINFO: <br>break; <br> <br>case LINE_CALLSTATE: <br>if ( (HCALL)hDevice != ghCall ) <br>return; <br> <br>switch ( dwParam1 ) // new state <br>{ <br>case LINECALLSTATE_IDLE: <br> <br>// tell "Dialing" window to terminate <br>if ( ghWndDialing ) <br>{ <br>SendMessage (  <br>ghWndDialing, <br>WM_COMMAND, <br>MAKEWPARAM( IDOK, 0 ), <br>0 <br>); <br>} <br> <br>// tapi call cleanup <br>if ( !gfMakeCallReplyPending &amp;&amp; ghCall ) <br>{ <br>if ( ( errCode = lineDeallocateCall( ghCall ) ) &lt; 0 ) <br>{ <br>errString ( ghWndMain, errCode, MB_ICONSTOP | MB_OK ); <br>} <br>ghCall = NULL; <br>} <br>DialerLineClose(); <br>gfCurrentLineAvail = TRUE; <br> <br>// update main window <br>DisableDialButtons( FALSE ); <br>break; <br> <br>case LINECALLSTATE_BUSY: <br>tapiCallback ( <br>hDevice, <br>dwMsg, <br>dwCBInstance, <br>LINECALLSTATE_DISCONNECTED, <br>LINEDISCONNECTMODE_BUSY, <br>dwParam3 <br> ); <br>break; <br> <br>case LINECALLSTATE_SPECIALINFO: <br>tapiCallback ( <br>hDevice, <br>dwMsg, <br>dwCBInstance, <br>LINECALLSTATE_DISCONNECTED, <br>LINEDISCONNECTMODE_UNREACHABLE, <br>dwParam3 <br> ); <br>break; <br> <br>case LINECALLSTATE_DISCONNECTED: <br>{ <br>BOOL fCallOK; <br>DWORD LineDisconnectMode; <br> <br> <br>if ( dwParam2 == 0 ) <br>LineDisconnectMode = LINEDISCONNECTMODE_NORMAL; <br>else <br>LineDisconnectMode = dwParam2; <br> <br>fCallOK = ( LineDisconnectMode == LINEDISCONNECTMODE_NORMAL|| <br>LineDisconnectMode == LINEDISCONNECTMODE_UNKNOWN|| <br>LineDisconnectMode == LINEDISCONNECTMODE_PICKUP|| <br>LineDisconnectMode == LINEDISCONNECTMODE_FORWARDED|| <br>LineDisconnectMode == LINEDISCONNECTMODE_UNAVAIL <br>  ); <br> <br> <br>if ( !gfMakeCallReplyPending &amp;&amp; ghCall ) <br>{ <br>//gfDropping = TRUE; <br>if ( ( gDropCallRequestID = lineDrop ( ghCall, NULL, 0 ) ) &lt; 0 ) <br>{ <br>errString ( ghWndMain, gDropCallRequestID, MB_ICONSTOP | MB_OK ); <br>} <br>} <br> <br>if ( !fCallOK ) <br>DialogBoxParam ( <br>ghInst, <br>MAKEINTRESOURCE(IDD_CALLFAILED), <br>ghWndMain, <br>(DLGPROC)LineInUseProc, <br>LineDisconnectMode <br>   ); <br>break; <br>} <br>} <br>break; <br> <br> <br>case LINE_CLOSE: <br>if ( gCurrentLineInfo.hLine == (HLINE)hDevice ) <br>{ <br>errString(ghWndMain, ERR_LINECLOSE, MB_ICONEXCLAMATION | MB_OK ); <br>gCurrentLineInfo.hLine = NULL; <br>gfCurrentLineAvail = FALSE; <br>DisableDialButtons(FALSE);                 <br>} <br>break; <br> <br>case LINE_CREATE: <br>// dwParam1 is the new device's ID <br>if ( dwParam1 &gt;= gnAvailDevices )  <br>{ <br>DWORD* gnAddrTemp; <br>DWORD iLine; <br>LINEINFO LineInfo; <br> <br>// we record new device's address count. <br> <br>                // we are assuming here that we're just adding a new <br>                // line and it's sequential and it's the last one <br> <br>                gnAvailDevices = dwParam1 + 1; <br>                 <br>gnAddrTemp = (DWORD *) DialerAlloc ( sizeof(DWORD) * (int)(gnAvailDevices) ); <br> <br>for ( iLine = 0; iLine &lt; (gnAvailDevices-1); ++iLine ) <br>gnAddrTemp[iLine] = gnAddr[iLine]; <br> <br>DialerFree( gnAddr ); <br> <br>// we have effectively added one more <br>// space in the gnAddr array <br>gnAddr = gnAddrTemp;  <br> <br>if ( GetLineInfo( dwParam1, &amp;LineInfo ) != ERR_NONE ) <br>break; <br> <br> gnAddr[dwParam1] = LineInfo.nAddr; <br>} <br>break; <br> <br>case LINE_DEVSPECIFIC: <br>break; <br> <br>case LINE_DEVSPECIFICFEATURE: <br>break; <br> <br>case LINE_GATHERDIGITS: <br>break; <br> <br>case LINE_GENERATE: <br>break; <br> <br>case LINE_LINEDEVSTATE: <br>if ( dwParam1 &amp; LINEDEVSTATE_REINIT ) <br>{ <br>if(dwParam2 != 0)  <br>{ <br>// this is another msg translated into REINIT <br>tapiCallback( hDevice, dwParam2, dwCBInstance, dwParam3, 0, 0 ); <br>} <br>else  <br>{ <br>// Re-initialize TAPI <br>gfNeedToReinit = TRUE; <br>} <br>} <br> <br>if ( dwParam1 &amp; LINEDEVSTATE_REMOVED ) <br>{ <br>DialerLineClose(); <br>tapiCallback(hDevice, LINE_CLOSE, dwCBInstance, 0, 0, 0); // is this needed? <br>} <br>break; <br> <br>case LINE_MONITORDIGITS: <br>break; <br> <br>case LINE_MONITORMEDIA: <br>break; <br> <br>case LINE_MONITORTONE: <br>break; <br> <br>// async reply from lineMakeCall() or lineDrop() <br>case LINE_REPLY: <br> <br>// reply for lineMakeCall  <br>if ( (LONG) dwParam1 == gMakeCallRequestID ) <br>{ <br>// error on make call <br>if ( dwParam2 != ERR_NONE ) <br>{ <br>// Get rid of the Dialing Dialog box if it's up <br>if ( ghWndDialing ) <br>{ <br>   SendMessage( <br>ghWndDialing, <br>WM_COMMAND, <br>MAKEWPARAM(IDOK,0), <br>0 <br>  ); <br>} <br> <br>if ( dwParam2 == LINEERR_CALLUNAVAIL ) <br>{ <br>DialogBoxParam ( <br>ghInst, <br>MAKEINTRESOURCE(IDD_CALLFAILED), <br>ghWndMain, <br>(DLGPROC)LineInUseProc, <br>0 <br>   ); <br>} <br>else <br>{ <br>errString ( ghWndMain, dwParam2, MB_ICONEXCLAMATION | MB_OK ); <br>} <br> <br>ghCall = NULL; <br>DialerLineClose(); <br>gfCurrentLineAvail = TRUE; <br>} <br> <br>gfMakeCallReplyPending = FALSE; <br>} <br> <br>// reply from lineDrop() <br>if ( (LONG) dwParam1 == gDropCallRequestID ) <br>{ <br>//gfDropping = FALSE; <br> <br>// tell "Dialing" window to terminate <br>if ( ghWndDialing ) <br>{ <br>SendMessage (  <br>ghWndDialing, <br>WM_COMMAND, <br>MAKEWPARAM( IDOK,0 ), <br>0 <br>); <br>} <br> <br>// tapi call cleanup <br>if ( dwParam2 == ERR_NONE ) <br>{ <br>if ( !gfMakeCallReplyPending &amp;&amp; ghCall ) <br>{ <br>if ( ( errCode = lineDeallocateCall( ghCall ) ) &lt; 0 ) <br>{ <br>errString ( ghWndMain, errCode, MB_ICONSTOP | MB_OK ); <br>} <br>ghCall = NULL; <br>} <br>} <br>DialerLineClose (); <br>gfCurrentLineAvail = TRUE; <br>} <br> <br>break; <br> <br>case LINE_REQUEST: <br>// Simple TAPI request <br>if ( dwParam1 == LINEREQUESTMODE_MAKECALL ) <br>{ <br>gfCallRequest = TRUE; <br>} <br>break; <br>} <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL InitializeLineBox(HWND hwndLineBox) <br>{ <br> <br>DWORD iLine, iItem, iItemCurrent = (DWORD)-1; <br>DWORD errCode; <br> <br>LPLINEINFO lpLineInfo = NULL; <br> <br>// allocate buffer for storing LINEINFO for all of  <br>// the available lines.  Always allocate space for  <br>// at least one line <br>if ( gnAvailDevices == 0 ) <br>{ <br>lpLineInfo = (LPLINEINFO) DialerAlloc( sizeof(LINEINFO) ); <br>} <br>else <br>{ <br>lpLineInfo = (LPLINEINFO) DialerAlloc ( sizeof(LINEINFO) * (int)gnAvailDevices ); <br>} <br> <br>// if no space was set aside... <br>if ( lpLineInfo == NULL )  <br>return LINEERR_NOMEM; <br> <br>// fill lpLineInfo[] and open each line <br>for ( iLine = 0; iLine &lt; gnAvailDevices; ++iLine ) <br>{ <br>// skip remaining processing for this line if it didn't open <br>if ( GetLineInfo( iLine, &amp;lpLineInfo[iLine] ) != ERR_NONE ) <br>{ <br>continue; <br>} <br> <br>iItem = SendMessage ( <br>hwndLineBox, <br>CB_ADDSTRING, <br>0, <br>(LPARAM)(LPCSTR)(lpLineInfo[iLine].szLineName) <br>); <br> <br>// error, bail out. <br>if ( iItem == CB_ERR || iItem == CB_ERRSPACE ) <br>{ <br>            if (lpLineInfo) <br>            { <br>                DialerFree(lpLineInfo); <br>            } <br>             <br>return FALSE;  <br>} <br> <br>errCode = SendMessage ( <br>hwndLineBox, <br>CB_SETITEMDATA, <br>(WPARAM)iItem, <br>(LPARAM)iLine <br>  ); <br> <br>if ( iLine == giCurrentLine ) <br>{ <br>iItemCurrent = iItem; <br>} <br>else if ( iItemCurrent != -1 &amp;&amp; iItem &lt;= iItemCurrent ) <br>{ <br>// if the item we are putting is before the <br>// "current" item, we must increment iItemCurrent <br>// to reflect that something is being placed before <br>// it, due to sorting <br>++iItemCurrent; <br>} <br>} <br> <br>if ( iItemCurrent == (DWORD)-1 ) <br>iItemCurrent = 0; <br> <br>if ( SendMessage( hwndLineBox, CB_GETCOUNT, 0, 0) != 0 ) <br>{ <br>SendMessage( hwndLineBox, CB_SETCURSEL, (WPARAM)iItemCurrent, 0 ); <br>return TRUE; <br>} <br> <br>    DialerFree(lpLineInfo); <br>return FALSE; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>BOOL InitializeAddressBox( HWND hwndLineBox, HWND hwndAddressBox ) <br>{ <br>DWORD errCode; <br>DWORD iAddress, iItem, iItemCurrent = (DWORD)-1; <br>DWORD iLineBoxCurrent; <br>LPSTR pszAddressName; <br> <br>if ( SendMessage( hwndLineBox, CB_GETCOUNT, 0, 0 ) == 0 ) <br>{ <br>return FALSE; <br>} <br> <br>// select current entry in line box <br>iLineBoxCurrent = SendMessage (  <br>hwndLineBox, <br>CB_GETITEMDATA, <br>SendMessage( hwndLineBox, CB_GETCURSEL, 0, 0 ), <br>0 <br>  ); <br>// empty address list box <br>SendMessage ( hwndAddressBox, CB_RESETCONTENT, 0, 0);  <br> <br>// get all the address for this line <br>for ( iAddress = 0; iAddress &lt; gnAddr[iLineBoxCurrent]; ++iAddress ) <br>{ <br>pszAddressName = GetAddressName( iLineBoxCurrent, iAddress ); <br> <br>// if this address if fails, try the next one <br>if ( !pszAddressName ) <br>continue;  <br> <br>iItem = SendMessage ( <br>hwndAddressBox, <br>CB_ADDSTRING, <br>0, <br>(LPARAM) (LPCSTR) (pszAddressName) <br>); <br> <br>// error, bail out <br>if ( iItem == CB_ERR || iItem == CB_ERRSPACE ) <br>return FALSE;  <br> <br>errCode = SendMessage ( <br>hwndAddressBox, <br>CB_SETITEMDATA, <br>(WPARAM) iItem, <br>(LPARAM) iAddress <br>  ); <br> <br>if ( iLineBoxCurrent == giCurrentLine ) <br>{ <br>if(iAddress == giCurrentAddress) <br>{ <br>iItemCurrent = iItem; <br>} <br>else  <br>{ <br>// if the item we are putting is before the <br>// "current" item, we must increment iItemCur <br>// to reflect that something is being placed <br>// before it, due to sorting <br>if ( iItemCurrent != -1 &amp;&amp; iItem &lt;= iItemCurrent ) <br>{ <br>++iItemCurrent;  <br>} <br>} <br>} <br> <br>DialerFree( pszAddressName ); <br>} <br> <br>if ( iLineBoxCurrent != giCurrentLine ) <br>{ <br>// if we're not looking at the current line <br>// then highlight address 0 <br>iItemCurrent = 0; <br>} <br> <br>SendMessage ( <br>hwndAddressBox, <br>CB_SETCURSEL, <br>iItemCurrent, <br>0 <br>); <br>return TRUE; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID ManageAssistedTelephony(VOID) <br>{ <br>DWORD errCode; <br>LPLINEREQMAKECALL lpRequestBuffer; <br> <br>lpRequestBuffer = (LPLINEREQMAKECALL) DialerAlloc( sizeof( LINEREQMAKECALL ) ); <br>if ( !lpRequestBuffer )  <br>{ <br>goto error; <br>} <br> <br>    // bring window to front <br>    SetForegroundWindow(ghWndMain); <br>     <br>// get next queued request. <br>errCode = lineGetRequest ( <br>ghLineApp, <br>LINEREQUESTMODE_MAKECALL, <br>lpRequestBuffer <br> <br> ); <br>if ( errCode ) <br>{ <br>// if no more call requests pending, reset flag. <br>if ( errCode == LINEERR_NOREQUEST ) <br>{ <br>gfCallRequest = FALSE; <br>} <br>else <br>{ <br>errString ( ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK ); <br>} <br>goto error; <br>} <br> <br> <br>// if a line has not been selected <br>if ( giCurrentLine == (DWORD)-1 ) <br>{ <br>if (!DialogBoxParam ( <br>ghInst, <br>MAKEINTRESOURCE(IDD_CONNECTUSING), <br>ghWndMain, <br>(DLGPROC) ConnectUsingProc, <br>INVALID_LINE <br>  )) <br>        { <br>            // failed to get a line <br>            goto error; <br>        } <br>} <br> <br>// make the reuested call. <br>InitiateCall ( <br>lpRequestBuffer-&gt;szDestAddress, <br>lpRequestBuffer-&gt;szCalledParty <br> ); <br> <br>error : <br>if ( lpRequestBuffer ) <br>{ <br>DialerFree( lpRequestBuffer ); <br>} <br>return; <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>VOID DialerLineClose() <br>{ <br>DWORD errCode; <br> <br>if ( gCurrentLineInfo.hLine ) <br>{ <br>if ( errCode = lineClose ( gCurrentLineInfo.hLine ) ) <br>{ <br>errString ( ghWndMain, errCode, MB_ICONSTOP | MB_OK ); <br>} <br>gCurrentLineInfo.hLine = NULL; <br>} <br> <br> <br>// re-initialize TAPI if it needs to be re-initialized <br>if ( gfNeedToReinit )  <br>{ <br>CloseTAPI(); <br> <br>errCode = InitializeTAPI(); <br>if(errCode) <br>{ <br>errString(ghWndMain, errCode, MB_APPLMODAL | MB_ICONEXCLAMATION ); <br>DialerCleanup(); // terminate program if we can't init <br>return; <br>} <br> <br>errCode = lineRegisterRequestRecipient ( <br>ghLineApp, <br>0,  <br>LINEREQUESTMODE_MAKECALL, <br>TRUE <br>   ); <br>if (errCode) <br>{ <br>errString(ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK ); <br>} <br> <br>gfNeedToReinit = FALSE; <br>} <br>} <br> <br> <br> <br>//*************************************************************************** <br>//*************************************************************************** <br>//*************************************************************************** <br>int errString( HWND hWndOwner, UINT errCode, UINT uFlags ) <br>{ <br>PTSTR ptStrTitle; <br>PTSTR ptStrError; <br>int   nResult; <br>    BOOL  bDefault = FALSE; <br> <br>ptStrTitle = DialerAlloc( MAXBUFSIZE ); <br>if ( NULL == ptStrTitle ) <br>{ <br>   // Now, _this_ is a problem. <br>   return 0; <br>} <br> <br>ptStrError = DialerAlloc( MAXBUFSIZE ); <br>if ( NULL == ptStrError ) <br>{ <br>   // Now, _this_ is a problem. <br>   DialerFree( ptStrTitle); <br>   return 0; <br>} <br> <br>switch(errCode) <br>{ <br>case ERR_NOLINES: <br>errCode = ikszErrNoVoiceLine; <br>break; <br> <br>case ERR_NOVOICELINE: <br>errCode = ikszErrNoVoiceLine; <br>break; <br>     <br>case ERR_LINECLOSE: <br>errCode = ikszErrLineClose; <br>break; <br> <br>case ERR_911WARN: <br>errCode = ikszWarningFor911; <br>break; <br>     <br>case ERR_NEWDEFAULT: <br>errCode = ikszWarningNewDefault; <br>break; <br> <br>case LINEERR_NODRIVER: <br>errCode = ikszErrLineInitNoDriver; <br>break; <br>     <br>case LINEERR_NODEVICE: <br>errCode = ikszErrLineInitNoDevice; <br>break; <br>     <br>case LINEERR_INIFILECORRUPT: <br>errCode = ikszErrLineInitBadIniFile ; <br>break; <br>     <br>case LINEERR_NOMEM: <br>errCode = ikszErrOOM; <br>break; <br>     <br>case LINEERR_INCOMPATIBLEAPIVERSION: <br>errCode = ikszErrLineInitWrongDrivers ; <br>break; <br>     <br>case LINEERR_OPERATIONFAILED: <br>errCode = ikszErrTAPI; <br>break; <br>     <br>case LINEERR_INVALADDRESS: <br>errCode = ikszErrInvalAddress; <br>break; <br>     <br>case LINEERR_ADDRESSBLOCKED: <br>errCode = ikszErrAddrBlocked; <br>break; <br>     <br>case LINEERR_BILLINGREJECTED: <br>errCode = ikszErrBillingRejected; <br>break; <br>     <br>case LINEERR_RESOURCEUNAVAIL: <br>case LINEERR_ALLOCATED: <br>case LINEERR_INUSE: <br>errCode = ikszErrResUnavail; <br>break; <br>     <br>case LINEERR_NOMULTIPLEINSTANCE: <br>errCode = ikszErrNoMultipleInstance; <br>break; <br>     <br>case LINEERR_INVALCALLSTATE: <br>errCode = ikszErrInvalCallState; <br>break; <br> <br>        case LINEERR_INVALCOUNTRYCODE: <br>            errCode = ikszErrInvalidCountryCode; <br>            break; <br>     <br>default: <br>            bDefault = TRUE; <br>            break; <br> <br>} <br> <br> <br>    if (bDefault) <br>    { <br>        // if using default error, get TAPI's <br>        // error message from FormatError() <br>        if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, <br>                           (LPCVOID)GetModuleHandle(TEXT("TAPI32.DLL")), <br>                           (DWORD)TAPIERROR_FORMATMESSAGE(errCode), <br>                           0, <br>                           (LPTSTR)ptStrError, <br>                           MAXBUFSIZE, <br>                           NULL)) <br>        { <br>            // if this fails, fall back on default <br>            LoadString( ghInst, ikszErrDefault, ptStrError, MAXBUFSIZE); <br>        } <br> <br>    } <br>    else    // not the default error message <br>    { <br> <br>        if ( 0 == LoadString( ghInst, errCode, ptStrError, MAXBUFSIZE ) ) <br>        { <br>#if DBG <br>            TCHAR buf[200]; <br>            wsprintf( buf, "Cannot load string: hinst:0x%08lx errcode: %ld", (DWORD)ghInst,(DWORD)errCode); <br>            OutputDebugString( buf ); <br>            MessageBox( NULL, buf, "Dialer", MB_OK); <br>#endif <br> <br>            LoadString( ghInst, ikszErrDefault, ptStrError, MAXBUFSIZE ); <br>        } <br>    } <br> <br>    LoadString( ghInst, ikszWarningTitle, ptStrTitle, MAXBUFSIZE ); <br> <br>nResult = MessageBox( hWndOwner, ptStrError, ptStrTitle, uFlags ); <br> <br> <br>DialerFree( ptStrTitle ); <br>DialerFree( ptStrError ); <br> <br> <br>return nResult; <br>} <br> <br> <br>/* <br> *Name : <br> *FitTextToButton  <br> * <br> *Arguements : <br> *hDlg handle for the dialog in which this button is embedded <br> *nButtonID button id of this button <br> *szNameName to fit on the button. Max size TAPIMAXCALLEDPARTYSIZE <br> * <br> *Return : <br> *None <br> * <br> *Comments : <br> *Function first checks to see if the button text specified fits in the <br> *button.  If it does not it truncates it appropriately and adds trailing <br> *ellipses.   <br> */ <br>VOID FitTextToButton ( HWND hDlg, INT nButtonID, LPSTR szName ) <br>{ <br> <br>HDC hDC; <br>HFONT hFont, hOldFont; <br>HWND hWnd; <br> <br>do <br>{ <br>// calculate number of chars. that can fit on  <br>// the button <br>intnLen; <br>RECT rect; <br>SIZE size; <br>POINT pt; <br>char buf [TAPIMAXCALLEDPARTYSIZE + 1]; <br> <br>// get button dimensions <br>hWnd = GetDlgItem( hDlg, nButtonID ); <br>if ( hWnd == NULL ) <br>break; <br> <br>if ( !GetClientRect( hWnd, &amp;rect ) ) <br>break; <br> <br>// get character dimensions <br>hDC = GetDC( hWnd ); <br>if ( hDC == NULL ) <br>break; <br> <br>hFont = (HFONT) SendMessage( hWnd, WM_GETFONT, 0, 0 ); <br>if ( hFont == NULL ) <br>hOldFont = SelectObject( hDC, GetStockObject( SYSTEM_FONT ) ); <br>else <br>hOldFont = SelectObject( hDC, hFont ); <br> <br>// add an extra char at the end to compensate for <br>// leading space, <br>lstrcpy ( buf, szName ); <br>nLen = lstrlen( buf ); <br>buf [ nLen ] = 'X'; <br>buf [ nLen + 1 ] = '\0'; <br> <br>if ( !GetTextExtentPoint32( hDC, buf, nLen + 1, &amp;size ) ) <br>break; <br> <br>pt.x = size.cx; <br>if ( !LPtoDP( hDC, &amp;pt, 1 ) ) <br>break; <br> <br>// check if name fits on button <br>if (  pt.x &gt; rect.right ) <br>{ <br>// find how much of the name fits  <br>int i = 0; <br> <br>nLen = lstrlen( szName ); <br>for ( i = 0; i &lt; nLen; i++ ) <br>{ <br>buf[ i ] = szName[ i ]; <br>// an extra char is stuffed to compensate for the <br>// leading space left by the left alignment <br>buf [ i + 1 ] = 'X'; <br>buf [ i + 2 ] = '\0'; <br> <br>// break out in cases of error condition <br>if ( !GetTextExtentPoint32( hDC, buf, i + 2, &amp;size ) ) <br>{ <br>i = nLen; <br>break; <br>} <br> <br>pt.x = size.cx; <br>if ( !LPtoDP( hDC, &amp;pt, 1 ) ) <br>{ <br>i = nLen; <br>break; <br>} <br> <br>if ( pt.x &gt; rect.right )  <br>break; <br>} <br> <br>            // error <br>if ( i &gt;= nLen ) <br>break; <br> <br>// name is too long. truncate and add ellipses <br>szName [i - 3] = '\0'; <br>lstrcat( szName, "..." ); <br>} <br> <br>} while( FALSE ); <br> <br>if ( hDC ) <br>{ <br>SelectObject( hDC, hOldFont ); <br>ReleaseDC( hWnd, hDC ); <br>} <br> <br>return; <br>} <br> <br> <br> <br>/* <br> *Name : <br> *Is911 <br> * <br> *Arguements : <br> *lpTransOut -Translated address contained the dialable string <br> * <br> *Returns <br> *TRUE -If number to be dialed (in the US) is prefixed by 911  <br> *FALSE -Otherwise <br> * <br> * Comments <br> * <br> */ <br>BOOL Is911 ( LPLINETRANSLATEOUTPUT lpTransOut ) <br>{ <br> <br>DWORD i = 0, j = 0; <br>LPSTR lpDialDigits = (LPSTR)lpTransOut + lpTransOut-&gt; dwDialableStringOffset; <br>char sz3Pref [ 4 ] = ""; <br> <br> <br>// if this is not the US <br>if ( lpTransOut-&gt; dwCurrentCountry != 1 ) <br>return FALSE; <br> <br>// skip non digit characters and extract <br>// the first 3 digits in the dialable number <br>for ( i = 0, j = 0; i &lt; lpTransOut-&gt; dwDialableStringSize ; i++ ) <br>{ <br>if ( ISDIGIT( lpDialDigits[i] ) ) <br>{ <br>sz3Pref[ j++ ] = lpDialDigits [ i ]; <br>sz3Pref[ j ] = '\0';  <br>if ( j == 3 ) <br>break; <br>} <br>} <br> <br>if ( !lstrcmp( sz3Pref, "911" ) ) <br>{ <br>return TRUE; <br>} <br> <br>return FALSE; <br>} <br> <br> <br>/* <br> *Name : <br> *MakeCanonicalNumber <br> * <br> *Arguements : <br> *szNumber Number to convert into canonical form. Max size TAPIMAXDESTADDRESSSIZE <br> *szCanNumberCanonical representation of number specified in szNumber <br> * <br> *Return : <br> *TRUEIf the conversion was successful. <br> *FALSEotherwise <br> * <br> *Comments : <br> *Function first checks if given number is already in canonical form. <br> *If it is, it returns.  If it is not, then it performs the conversion. <br> */ <br>  <br>BOOL MakeCanonicalNumber ( LPCSTR szNumber, LPSTR szCanNumber ) <br>{ <br>char szDigits [ TAPIMAXDESTADDRESSSIZE ]; <br>char szPref [ TAPIMAXDESTADDRESSSIZE ]; <br> <br>BOOL bRes = FALSE; <br> <br>INT errCode = -1; <br>INT nLenPref, nLenDigits, cPos, i; <br> <br>DWORD dwSize = 0; <br>DWORD dwInd = 0; <br> <br>LPLINETRANSLATEOUTPUT lpTransOut = NULL; <br>LPLINETRANSLATECAPS lpTransCaps = NULL; <br> <br> <br>dwSize = sizeof ( LINETRANSLATEOUTPUT ); <br>do <br>{ <br>lpTransOut = ( LPLINETRANSLATEOUTPUT ) DialerAlloc ( dwSize ); <br>if ( !lpTransOut ) <br>{ <br>errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br> <br>lpTransOut-&gt; dwTotalSize = dwSize; <br>errCode = lineTranslateAddress ( <br>ghLineApp, <br>giCurrentLine, <br>gCurrentLineInfo.dwAPIVersion, <br>szNumber, <br>0, <br>0, <br>lpTransOut <br>   ); <br>if ( errCode ) <br>{ <br>goto error; <br>} <br> <br>if ( lpTransOut-&gt; dwNeededSize &lt;= lpTransOut-&gt; dwTotalSize ) <br>break; <br> <br>dwSize = lpTransOut-&gt; dwNeededSize; <br>DialerFree( lpTransOut ); <br> <br>} while( TRUE ); <br> <br> <br>// check if input number is already in  <br>// canonical form. <br>if ( lpTransOut-&gt; dwTranslateResults &amp; LINETRANSLATERESULT_CANONICAL ) <br>goto error; <br> <br>// ensure country is the USA. <br>if ( lpTransOut-&gt; dwCurrentCountry != 1 ) <br>goto error; <br> <br> <br>// Extract the digits from given string <br>// allowed formatting characters that are ignored are <br>// space, (, ), -, .  <br>// presence of other characters will render the string invalid. <br> <br>// find the prefix of the address upto the | mark. <br>// the rest of the string can be ignored <br>nLenPref = strcspn ( szNumber, "|" ); <br>strncpy( szPref, szNumber, nLenPref ); <br>szPref[ nLenPref ] = '\0'; <br> <br>// if string is not composed entirely of digits <br>// and allowable formating characters, quit conversion <br>if ( strspn( szPref, " 0123456789()-." ) != (size_t) nLenPref ) <br>goto error; <br> <br>// collect digits ignoring formating characters. <br>szDigits[ 0 ] = '\0'; <br>for ( i = 0, nLenDigits = 0; i &lt; nLenPref; i++ ) <br>{ <br>if ( ISDIGIT( szNumber[ i ] ) ) <br>{ <br>szDigits[ nLenDigits++ ] = szNumber[ i ]; <br>} <br>} <br>szDigits[ nLenDigits ] = '\0'; <br> <br>// if "internal" number <br>if ( nLenDigits &lt; LOCAL_NUMBER ) <br>goto error; <br> <br>switch ( nLenDigits ) <br>{ <br>// Local number ( 7 digits) preceeded by a 0/1 <br>// Strip leading 0/1 and treat as a local number <br>case EXTENDED_LOCAL_NUMBER: <br>if ( szDigits[ 0 ] == '0' || szDigits[ 0 ] == '1' ) <br>{ <br>nLenDigits--; <br>memmove( szDigits, &amp;(szDigits[1]), nLenDigits ); <br>szDigits[ nLenDigits ] = '\0'; <br> <br>cPos = strcspn( szPref, "01" ); <br>nLenPref--; <br>memmove( &amp;(szPref[ cPos ]), &amp;(szPref[ cPos + 1 ]), nLenPref - cPos ); <br>szPref[ nLenPref ] = '\0'; <br>} <br>else <br>{ <br>goto error; <br>} <br> <br>case LOCAL_NUMBER : <br>{ <br>LPLINELOCATIONENTRY lpLocLst; <br> <br>// if leading digit is 0 or 1, it is  <br>// illegal in the US <br>if ( szDigits[ 0 ] == '0' || szDigits[ 0 ] == '1' ) <br>{ <br>goto error; <br>} <br> <br>// get area code nformation for local number <br>dwSize = sizeof( LINETRANSLATECAPS ); <br>do <br>{ <br>lpTransCaps = (LPLINETRANSLATECAPS) DialerAlloc( dwSize ); <br>if ( !lpTransCaps ) <br>{ <br>errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br> <br>lpTransCaps-&gt; dwTotalSize = dwSize; <br>errCode = lineGetTranslateCaps ( <br>ghLineApp, <br>gCurrentLineInfo.dwAPIVersion, <br>lpTransCaps <br>   ); <br>if ( errCode ) <br>{ <br>errString( ghWndMain, errCode, MB_ICONSTOP | MB_OK ); <br>goto error; <br>} <br> <br>if ( lpTransCaps-&gt; dwNeededSize &lt;= lpTransCaps-&gt; dwTotalSize ) <br>{ <br>break; <br>} <br> <br>dwSize = lpTransCaps-&gt; dwNeededSize; <br>DialerFree( lpTransCaps ); <br> <br>} while ( TRUE ); <br> <br>// skip entries till you locate information for current location <br>dwSize = sizeof( LINELOCATIONENTRY ); <br>lpLocLst = (LPLINELOCATIONENTRY) ( (LPSTR) lpTransCaps +  <br>lpTransCaps-&gt; dwLocationListOffset ); <br> <br>for ( dwInd = 0; dwInd &lt; lpTransCaps-&gt; dwNumLocations ; dwInd++ ) <br>{ <br>if ( lpLocLst[ dwInd ].dwPermanentLocationID == lpTransCaps-&gt; dwCurrentLocationID ) <br>break; <br>} <br> <br>// current location no found ????? <br>// login error <br>if ( dwInd == lpTransCaps-&gt; dwNumLocations ) <br>{ <br>goto error; <br>} <br> <br>// construct canonical form as <br>szCanNumber[ 0 ]= '\0'; <br>lstrcat( szCanNumber, "+1 (" ); <br>lstrcat( szCanNumber, (LPSTR) lpTransCaps + lpLocLst[ dwInd ].dwCityCodeOffset ); <br>lstrcat( szCanNumber, ") " ); <br>lstrcat( szCanNumber, szDigits ); <br> <br>cPos = strcspn( szNumber, "|" ); <br>if ( cPos != lstrlen( szNumber ) ) <br>{ <br>lstrcat( szCanNumber, &amp;(szNumber[ cPos ]) ); <br>} <br> <br>bRes = TRUE; <br>break; <br>} <br> <br>case EXTENDED_LONG_DISTANCE_NUMBER: <br>{ <br>// Long distance number ( 10 digits) preceeded by a 0/1 <br>// Strip leading 0/1 and treat as a long distance number <br>if ( szDigits[ 0 ] == '0' || szDigits[ 0 ] == '1' ) <br>{ <br>nLenDigits--; <br>memmove( szDigits, &amp;(szDigits[1]), nLenDigits ); <br>szDigits[ nLenDigits ] = '\0'; <br> <br>cPos = strcspn( szPref, "01" ); <br>nLenPref--; <br>memmove( &amp;(szPref[ cPos ]), &amp;(szPref[ cPos + 1 ]), nLenPref - cPos ); <br>szPref[ nLenPref ] = '\0'; <br>} <br>else <br>{ <br>goto error; <br>} <br> <br>} <br> <br>case LONG_DISTANCE_NUMBER: <br>{ <br>// if first or fourth digit is 0/1, illegal number <br>if ( szDigits[ 0 ] == '0' || szDigits[ 0 ] == '1' || <br> szDigits[ 3 ] == '0' || szDigits[ 3 ] == '1' ) <br>{ <br>goto error; <br>} <br> <br>szCanNumber[ 0 ] = '\0'; <br>lstrcat( szCanNumber, "+1 (" ); <br>strncat( szCanNumber, szDigits, 3 ); <br>lstrcat( szCanNumber, ") " ); <br> <br>lstrcat( szCanNumber, &amp;(szDigits[ 3 ]) ); <br> <br>bRes = TRUE; <br>} <br>break; <br> <br>default : <br>goto error; <br>} <br> <br>error: <br>if ( lpTransOut ) <br>DialerFree( lpTransOut ); <br> <br>if ( lpTransCaps ) <br>DialerFree( lpTransCaps ); <br> <br>return bRes; <br>} <br> <br> <br>/* <br> *Name : <br> *AmpersandCompensate <br> * <br> *Arguements : <br> *lpszSrc:Src string containing &amp;s </code></pre>
<p>
</p>
<pre><code>*lpszDst:Dest string    <br> * <br> *Return : <br> * <br> *Comments : <br> *Copies string pointed to by lpszSrc to lpszDst character by <br> *character.  If an &amp; is encountered in this process in lpszSrc <br> *it is copied as &amp;&amp; into lpszDst. <br> *Assumes lpszDst and lpszSrc are of size TAPIMAXCALLEDPARTYSIZE <br> */ <br>VOID AmpersandCompensate ( LPCSTR lpszSrc, LPSTR lpszDst ) <br>{ <br>// check if the name has an &amp; in it.  If so replace <br>// it with &amp;&amp;. <br>INT cCnt, cInd; <br> <br>for ( cCnt = 0, cInd = 0;  <br>  cInd &lt; TAPIMAXCALLEDPARTYSIZE;  <br>  cInd++, cCnt++ ) <br>{ <br>if ( lpszSrc[ cCnt ] == '&amp;' ) <br>{ <br>lpszDst[ cInd++ ] = '&amp;'; <br>} <br>lpszDst[ cInd ] = lpszSrc[ cCnt ]; <br> <br>if ( lpszSrc[ cCnt ] == '\0' ) <br>break; <br>} <br> <br>// make sure string is null terminated. <br>lpszDst[ TAPIMAXCALLEDPARTYSIZE - 1 ] = '\0'; <br> <br>return; <br>} <br> <br> <br> /* <br> *Name : <br> *AmpersandDeCompensate <br> * <br> *Arguements : <br> *lpszSrc:Src string containing &amp;s <br> *lpszDst:Dest string    <br> * <br> *Return : <br> * <br> *Comments : <br> *Copies string pointed to by lpszSrc to lpszDst character by <br> *character.  If an &amp;&amp; is encountered in this process in lpszSrc <br> *it is copied as &amp; into lpszDst. <br> *Assumes lpszDst and lpszSrc are of size TAPIMAXCALLEDPARTYSIZE <br> */ <br> VOID AmpersandDeCompensate ( LPCSTR lpszSrc, LPSTR lpszDst ) <br> { <br>// check if the name has an &amp; in it.  If so replace <br>// it with &amp;&amp;. <br>INT cCnt, cInd; <br> <br>for ( cCnt = 0, cInd = 0;  <br>  cInd &lt; TAPIMAXCALLEDPARTYSIZE;  <br>  cInd++, cCnt++ ) <br>{ <br>if  ( ( lpszSrc[ cInd ] == '&amp;' ) &amp;&amp; <br>  ( lpszSrc[ cInd + 1 ] == '&amp;' ) ) <br>{ <br>cInd++; <br>} <br>lpszDst[ cCnt ] = lpszSrc[ cInd ] ; <br> <br>if ( lpszSrc [ cInd ] == '\0' ) <br>{ <br>break; <br>} <br>} <br> <br>lpszDst[ TAPIMAXCALLEDPARTYSIZE - 1 ] = '\0'; <br> <br>return; <br> } </code></pre>
<p>&nbsp;</p></body>
</HTML>
