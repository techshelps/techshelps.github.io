<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACDUTILS.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5171"></a>ACDUTILS.C</h2>
<pre><code>////////////////////////////////////////////////////////////////// <br>// <br>//  ACDUTILS.C <br>// <br>//  Some utility functions used in ACDSMPL <br>// <br>////////////////////////////////////////////////////////////////// <br> <br> <br> <br>#include &lt;windows.h&gt; <br>#include "acdsmpl.h" <br> <br>extern ACDGLOBALS   g; <br> <br>////////////////////////////////////////////////////////////////// <br>// <br>//  LPVOID ACDAlloc(DWORD dwSize) <br>// <br>////////////////////////////////////////////////////////////////// <br>LPVOID ACDAlloc(DWORD dwSize) <br>{ <br>    LPVOID  pBuf; <br> <br>    pBuf = GlobalAlloc(GPTR, dwSize); <br> <br>    return pBuf; <br>} <br> <br>/////////////////////////////////////////////////////////////////// <br>// <br>//  void ACDFree(LPVOID pBuf) <br>// <br>/////////////////////////////////////////////////////////////////// <br>void ACDFree(LPVOID pBuf) <br>{ <br>    if (pBuf) <br>        GlobalFree(pBuf); <br>} <br> <br>/////////////////////////////////////////////////////////////////// <br>// <br>// LPVOID ACDReAlloc() <br>// <br>/////////////////////////////////////////////////////////////////// <br>LPVOID ACDReAlloc(LPVOID pBuf, <br>                  DWORD dwSize) <br>{ <br>    if (pBuf) <br>    { <br>        pBuf = GlobalReAlloc(pBuf, <br>                             dwSize, <br>                             GMEM_MOVEABLE); <br>    } <br> <br>    return pBuf; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL InsertStruct(PGENERICSTRUCT * ppRoot, <br>//                    PGENERICSTRUCT pStruct) <br>// <br>//    Adds a structure to the end of a linked list <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>BOOL InsertStruct(PGENERICSTRUCT * ppRoot, <br>                  PGENERICSTRUCT pStruct) <br>{ <br>    PGENERICSTRUCT      pHold = NULL; <br>     <br>    if (!*ppRoot) <br>    { <br>        *ppRoot = pStruct; <br>    } <br>    else <br>    { <br>        pHold = *ppRoot; <br>    } <br> <br>    if (pHold) <br>    { <br>        while (pHold-&gt;pNext) <br>        { <br>            pHold = pHold-&gt;pNext; <br>        } <br> <br>        pHold-&gt;pNext = pStruct; <br>        pStruct-&gt;pPrev = pHold; <br>    } <br> <br>    return TRUE; <br>} <br> <br>////////////////////////////////////////////////////////////// <br>// <br>//  BOOL DeleteStruct <br>//      Delete structure <br>// <br>//   Delete a structure from a linked list and <br>//   frees memory associated with it. <br>// <br>////////////////////////////////////////////////////////////// <br>BOOL DeleteStruct(PGENERICSTRUCT * ppRoot, <br>                  PGENERICSTRUCT pStruct) <br>{ <br>    if (pStruct-&gt;pPrev) <br>    { <br>        pStruct-&gt;pPrev-&gt;pNext = pStruct-&gt;pNext; <br>    } <br>    else <br>    { <br>        *ppRoot = pStruct-&gt;pNext; <br>    } <br>     <br>    if (pStruct-&gt;pNext) <br>    { <br>        pStruct-&gt;pNext-&gt;pPrev = pStruct-&gt;pPrev; <br>    } <br> <br>    ACDFree(pStruct); <br> <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////// <br>// <br>//  PGROUP AddGroup <br>// <br>//  Adds a group to the global group list <br>//  <br>////////////////////////////////////////////////////////////// <br>PGROUP AddGroup(LPTSTR lpszName, <br>                 DWORD dwDeviceID, <br>                 DWORD dwAddress) <br>{ <br>    PGROUP                  pGroup, pHold = NULL; <br>    LONG                    lResult; <br>     <br>    // alloc memory <br>    pGroup = (PGROUP)ACDAlloc(sizeof(GROUP)); <br> <br>    if (!pGroup) <br>    { <br>        return NULL; <br>    } <br> <br>    pGroup-&gt;lpszName = (LPTSTR)ACDAlloc((lstrlen(lpszName) + 1) * sizeof(TCHAR)); <br> <br>    // bail if there is a problem <br>    if (!pGroup-&gt;lpszName) <br>    { <br>        ACDFree(pGroup); <br>        return NULL; <br>    } <br> <br>    // init stuff <br>    lstrcpy(pGroup-&gt;lpszName, lpszName); <br>     <br>    pGroup-&gt;dwKey = GROUPKEY; <br>    pGroup-&gt;dwSize = sizeof(GROUP); <br>    pGroup-&gt;dwDeviceID = dwDeviceID; <br> <br> <br>    // open the line in owner mode, so we can <br>    // get the incoming calls <br>    lResult = lineOpen(g.hLineApp, <br>                       dwDeviceID, <br>                       &amp;pGroup-&gt;hLine, <br>                       TAPI_CURRENT_VERSION, <br>                       0, <br>                       0, <br>                       LINECALLPRIVILEGE_OWNER, <br>                       LINEMEDIAMODE_INTERACTIVEVOICE, <br>                       NULL); <br>     <br>    if (lResult &lt; 0) <br>    { <br>//      LogTapiError(lResult, "lineOpen line %lu", dwDeviceID); <br>        ACDFree(pGroup-&gt;lpszName); <br>        ACDFree(pGroup); <br> <br>        return NULL; <br>    } <br> <br>    // insert into global list <br>    InsertStruct((PGENERICSTRUCT *)&amp;g.pGroups, <br>                 (PGENERICSTRUCT)pGroup); <br> <br>    // increment <br>    g.dwNumGroups++; <br> <br>    return pGroup; <br>} <br> <br>////////////////////////////////////////////////////////////// <br>// <br>// PAGENT AddAgent <br>// <br>//  Adds an agent to the global agent list <br>// <br>//  NOTE:  There is a ton of verification type stuff that can <br>//  be put in here for a real implementation.   For example, <br>//  might want to restrict a user to a single line, or restrict <br>//  a single line to have one person. <br>//    <br>////////////////////////////////////////////////////////////// <br>PAGENT AddAgent(LPTSTR lpszName, <br>                LPTSTR lpszNumber, <br>                DWORD dwDeviceID) <br>{ <br>    PAGENT              pAgent, pHold = NULL; <br>    LPLINEDEVCAPS       pLDC; <br>    LPLINECALLPARAMS    pLCP; <br>    LONG                lResult; <br>    LPDWORD             pdwProxyRequests; <br> <br>    // alloc memory <br>    pAgent = (PAGENT)ACDAlloc(sizeof(AGENT)); <br> <br>    if (!pAgent) <br>    { <br>        return NULL; <br>    } <br> <br>    pAgent-&gt;lpszName = (LPTSTR)ACDAlloc((lstrlen(lpszName) + 1) * sizeof(TCHAR)); <br>    pAgent-&gt;lpszNumber = (LPTSTR)ACDAlloc((lstrlen(lpszNumber) + 1) * sizeof(TCHAR));     <br> <br>    // bail if there is a problem <br>    if (!pAgent-&gt;lpszName || !pAgent-&gt;lpszNumber) <br>    { <br>        ACDFree(pAgent); <br>        return NULL; <br>    } <br> <br> <br>    // init stuff <br>    lstrcpy(pAgent-&gt;lpszName, lpszName); <br>    lstrcpy(pAgent-&gt;lpszNumber, lpszNumber); <br>     <br>    pAgent-&gt;dwKey       = AGENTKEY; <br>    pAgent-&gt;dwSize      = sizeof(AGENT); <br>    pAgent-&gt;dwDeviceID  = dwDeviceID; <br>    pAgent-&gt;dwPermID    = g.pdwPermIDs[dwDeviceID]; <br> <br>    // insert into global agent list <br>    InsertStruct((PGENERICSTRUCT *)&amp;g.pAgents, <br>                 (PGENERICSTRUCT)pAgent); <br> <br>    // lineOpen is where the application lets TAPI know that it is a Proxy Request handler <br>    // for this line.  The LINEOPENOPTION_PROXY is added to the privileges.  Also, <br>    // the dev specific portion of LINECALLPARAMS contains the proxy request constants <br>    // that indicate which requests this app can handle <br> <br>    // This sample handles 7 types of proxy requests - all the ones that are defined <br>    // except for AGENTSPECIFIC <br>    pLCP = (LPLINECALLPARAMS)ACDAlloc(sizeof(LINECALLPARAMS) + 7*sizeof(DWORD)); <br> <br>    pLCP-&gt;dwTotalSize           = sizeof(LINECALLPARAMS) + 7*sizeof(DWORD); <br>    pLCP-&gt;dwDevSpecificOffset   = sizeof(LINECALLPARAMS); <br>    pLCP-&gt;dwDevSpecificSize     = sizeof(DWORD) * 7; <br> <br>    pdwProxyRequests = (LPDWORD)((LPBYTE)pLCP + sizeof(LINECALLPARAMS)); <br>    // each constant is in a DWORD at the end of LINECALLPARAMS <br>    *pdwProxyRequests++ = LINEPROXYREQUEST_SETAGENTGROUP; <br>    *pdwProxyRequests++ = LINEPROXYREQUEST_SETAGENTSTATE; <br>    *pdwProxyRequests++ = LINEPROXYREQUEST_SETAGENTACTIVITY; <br>    *pdwProxyRequests++ = LINEPROXYREQUEST_GETAGENTSTATUS; <br>    *pdwProxyRequests++ = LINEPROXYREQUEST_GETAGENTCAPS; <br>    *pdwProxyRequests++ = LINEPROXYREQUEST_GETAGENTACTIVITYLIST; <br>    *pdwProxyRequests   = LINEPROXYREQUEST_GETAGENTGROUPLIST;         <br>         <br>    lResult = lineOpen(g.hLineApp, <br>                       dwDeviceID, <br>                       &amp;pAgent-&gt;hLine, <br>                       TAPI_CURRENT_VERSION, <br>                       0, <br>                       0, <br>                       LINEOPENOPTION_PROXY | LINECALLPRIVILEGE_MONITOR, <br>                       LINEMEDIAMODE_INTERACTIVEVOICE, <br>                       pLCP); <br>     <br>    ACDFree(pLCP); <br>     <br>    if (lResult) <br>    { <br>        // <br>        ACDFree(pAgent-&gt;lpszName); <br>        ACDFree(pAgent); <br>         <br>    } <br> <br>    pLDC = LineGetDevCaps(g.hLineApp, <br>                          pAgent-&gt;dwDeviceID); <br> <br>    if (!pLDC) <br>    { <br>        return FALSE; <br>    } <br> <br>    // alloc memory for address specific info <br>    pAgent-&gt;pAddressInfo = (PADDRESSINFO)ACDAlloc(sizeof(ADDRESSINFO) * pLDC-&gt;dwNumAddresses); <br>    pAgent-&gt;dwNumAddresses = pLDC-&gt;dwNumAddresses; <br> <br>    ACDFree(pLDC); <br> <br>    // increment number of agents <br>    g.dwNumAgents++; <br> <br>    return pAgent; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>// BOOL DeleteAgent(PAGENT pAgent) <br>// <br>//  Frees all memory associated with pAgent, removes <br>//  agent from group lists, and remove pAgent from <br>//  global agent list <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL DeleteAgent(PAGENT pAgent) <br>{ <br>    PGROUP      pGroup; <br> <br>     <br>    lineClose(pAgent-&gt;hLine); <br>     <br>    // free name <br>    ACDFree(pAgent-&gt;lpszName); <br>    ACDFree(pAgent-&gt;lpszNumber); <br> <br>    // free address info <br>    ACDFree(pAgent-&gt;pAddressInfo); <br> <br>    pGroup = g.pGroups; <br> <br>    // walk through groups and remove from <br>    // group list if in group list <br>    while (pGroup) <br>    { <br>        if (IsAgentInList(pGroup-&gt;pAgentList, <br>                          pAgent)) <br>        { <br>            RemoveFromGroupList(pGroup, <br>                                pAgent); <br>        } <br> <br>        pGroup = pGroup-&gt;pNext; <br>         <br>    } <br> <br>    // finally, remove pAgent from global list <br>    DeleteStruct((PGENERICSTRUCT *)&amp;g.pAgents, <br>                 (PGENERICSTRUCT)pAgent); <br> <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>// BOOL DeleteGroup(PGROUP pGroup) <br>// <br>//  Frees memory assocated with pGroup, and removes the structure from <br>//  the global list <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL DeleteGroup(PGROUP pGroup) <br>{ <br>    PLISTITEM       pList, pListNext; <br> <br>    lineClose(pGroup-&gt;hLine); <br>     <br>    ACDFree(pGroup-&gt;lpszName); <br> <br>    pList = pGroup-&gt;pAgentList; <br> <br>    while (pList) <br>    { <br>        pListNext = pList-&gt;pNext; <br>        ACDFree(pList); <br>        pList = pListNext; <br>    } <br> <br>    DeleteStruct((PGENERICSTRUCT *)&amp;g.pGroups, <br>                 (PGENERICSTRUCT)pGroup); <br> <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>// BOOL InsertIntoGroupList(PGROUP pGroup, <br>//                          PAGENT pAgent) <br>// <br>//  Insert an agent in a group <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL InsertIntoGroupList(PGROUP pGroup, <br>                         PAGENT pAgent) <br>{ <br>    PLISTITEM       pListItem; <br> <br>    pListItem = (PLISTITEM)ACDAlloc(sizeof(LISTITEM)); <br> <br>    pListItem-&gt;dwKey = LISTKEY; <br>    pListItem-&gt;dwSize = sizeof(LISTITEM); <br>    pListItem-&gt;pAgent = pAgent; <br> <br>    InsertStruct((PGENERICSTRUCT *)&amp;pGroup-&gt;pAgentList, <br>                 (PGENERICSTRUCT)pListItem); <br>     <br>    return TRUE; <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>// BOOL RemoveFromGroupList(PGROUP pGroup, <br>// <br>//  remove an agent from a group's list <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL RemoveFromGroupList(PGROUP pGroup, <br>                         PAGENT pAgent) <br>{ <br>    PLISTITEM       pList; <br> <br>    pList = pGroup-&gt;pAgentList; <br> <br>    while (pList) <br>    { <br>        if (pList-&gt;pAgent == pAgent) <br>        { <br>            break; <br>        } <br> <br>        pList = pList-&gt;pNext; <br>    } <br> <br>    if (!pList) <br>    { <br>        return FALSE; <br>    } <br>     <br>    DeleteStruct((PGENERICSTRUCT *)&amp;pGroup-&gt;pAgentList, <br>                 (PGENERICSTRUCT)pList); <br> <br>    return TRUE; <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//PLISTITEM IsAgentInList(PLISTITEM pList, <br>//                        PAGENT pAgent) <br>// <br>//////////////////////////////////////////////////////////////////////////////// <br>PLISTITEM IsAgentInList(PLISTITEM pList, <br>                        PAGENT pAgent) <br>{ <br>    while (pList) <br>    { <br>        if (pList-&gt;pAgent == pAgent) <br>        { <br>            return pList; <br>        } <br> <br>        pList = pList-&gt;pNext; <br>    } <br> <br>    return NULL; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>// PAGENT GetAgentFromName(LPTSTR lpszName) <br>// <br>//////////////////////////////////////////////////////////////////////////////// <br>PAGENT GetAgentFromName(LPTSTR lpszName) <br>{ <br>    PAGENT   pHold; <br> <br>    pHold = g.pAgents; <br> <br>    while (pHold) <br>    { <br>        if (!lstrcmpi(pHold-&gt;lpszName, <br>                     lpszName)) <br>        { <br>            return pHold; <br>        } <br> <br>        pHold = pHold-&gt;pNext; <br>    } <br> <br>    return NULL; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// PAGENT GetAgentFromhLine(HLINE hLine) <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>PAGENT GetAgentFromhLine(HLINE hLine) <br>{ <br>    PAGENT pAgent; <br> <br>    pAgent = g.pAgents; <br> <br>    while (pAgent) <br>    { <br>        if (pAgent-&gt;hLine == hLine) <br>        { <br>            return pAgent; <br>        } <br>         <br>        pAgent = pAgent-&gt;pNext; <br>    } <br> <br>    return NULL; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  DWORD GetDeviceID(DWORD dwPermID) <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>DWORD GetDeviceID(DWORD dwPermID) <br>{ <br>    DWORD   dwCount; <br> <br>    for (dwCount = 0; dwCount &lt; g.dwNumDevs; dwCount++) <br>    { <br>        if (g.pdwPermIDs[dwCount] == dwPermID) <br>        { <br>            return dwCount; <br>        } <br>    } <br> <br>    return (DWORD)-1; <br>} <br>     <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//      **************TAPI WRAPPER FUNCTIONS************** <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetAddressCaps() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINEADDRESSCAPS * LineGetAddressCaps (HLINEAPP hLineApp, <br>                                      DWORD    dwDeviceID, <br>                                      DWORD    dwAddressID) <br>{ <br>    LONG              lRetVal; <br>    LINEADDRESSCAPS * pLineAddressCaps; <br>    static DWORD      dwMaxNeededSize = sizeof(LINEADDRESSCAPS); <br> <br>    // Allocate an initial block of memory for the LINEADDRESSCAPS structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineAddressCaps = ACDAlloc(dwMaxNeededSize); <br> <br>    for (;;) <br>    { <br>        if (pLineAddressCaps == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineAddressCaps-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINEADDRESSCAPS information <br>        // <br>        lRetVal = lineGetAddressCaps(hLineApp, <br>                                     dwDeviceID, <br>                                     dwAddressID, <br>                                     TAPI_CURRENT_VERSION, <br>                                     0, <br>                                     pLineAddressCaps); <br>        if (lRetVal &lt; 0) <br>        { <br>            ACDFree((HLOCAL)pLineAddressCaps); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINEADDRESSCAPS memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineAddressCaps-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineAddressCaps; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineAddressCaps-&gt;dwNeededSize; <br>            pLineAddressCaps = ACDReAlloc((HLOCAL)pLineAddressCaps, <br>                                            dwMaxNeededSize); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetCallInfo() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINECALLINFO * LineGetCallInfo (HCALL hCall) <br>{ <br>    LONG           lRetVal; <br>    LINECALLINFO * pLineCallInfo; <br>    static DWORD   dwMaxNeededSize = sizeof(LINECALLINFO); <br> <br>    // Allocate an initial block of memory for the LINECALLINFO structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineCallInfo = ACDAlloc(dwMaxNeededSize); <br> <br>    for (;;) <br>    { <br>        if (pLineCallInfo == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineCallInfo-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINECALLINFO information <br>        // <br>        lRetVal = lineGetCallInfo(hCall, <br>                                  pLineCallInfo); <br>        if (lRetVal &lt; 0) <br>        { <br>            ACDFree((HLOCAL)pLineCallInfo); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINECALLINFO memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineCallInfo-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineCallInfo; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineCallInfo-&gt;dwNeededSize; <br>            pLineCallInfo = ACDReAlloc((HLOCAL)pLineCallInfo, <br>                                         dwMaxNeededSize); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetDevCaps() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINEDEVCAPS * LineGetDevCaps (HLINEAPP hLineApp, <br>                              DWORD    dwDeviceID) <br>{ <br>    LONG           lRetVal; <br>    LINEDEVCAPS  * pLineDevCaps; <br>    static DWORD   dwMaxNeededSize = sizeof(LINEDEVCAPS); <br> <br>    pLineDevCaps = ACDAlloc(dwMaxNeededSize); <br>    for (;;) <br>    { <br>        if (pLineDevCaps == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineDevCaps-&gt;dwTotalSize = dwMaxNeededSize; <br>        lRetVal = lineGetDevCaps(hLineApp, <br>                                 dwDeviceID, <br>                                 TAPI_CURRENT_VERSION, <br>                                 0, <br>                                 pLineDevCaps); <br>        if (lRetVal &lt; 0) <br>        { <br>            ACDFree((HLOCAL)pLineDevCaps); <br>            return NULL; <br>        } <br>        if (pLineDevCaps-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineDevCaps; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineDevCaps-&gt;dwNeededSize; <br>            pLineDevCaps = ACDReAlloc((HLOCAL)pLineDevCaps, <br>                                        dwMaxNeededSize); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetID() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>VARSTRING * LineGetID (HLINE  hLine, <br>                       DWORD  dwAddressID, <br>                       HCALL  hCall, <br>                       DWORD  dwSelect, <br>                       LPCTSTR lpszDeviceClass) <br>{ <br>    LONG           lRetVal; <br>    VARSTRING    * pVarString; <br>    static DWORD   dwMaxNeededSize = sizeof(VARSTRING); <br> <br>    // Allocate an initial block of memory for the VARSTRING structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pVarString = ACDAlloc(dwMaxNeededSize); <br> <br>    for (;;) <br>    { <br>        if (pVarString == NULL) <br>        { <br>            return NULL; <br>        } <br>        pVarString-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the VARSTRING information <br>        // <br>        lRetVal = lineGetID(hLine, <br>                            dwAddressID, <br>                            hCall, <br>                            dwSelect, <br>                            pVarString, <br>                            lpszDeviceClass); <br>        if (lRetVal &lt; 0) <br>        { <br>            ACDFree(pVarString); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated VARSTRING memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pVarString-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pVarString; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pVarString-&gt;dwNeededSize; <br>            pVarString = ACDReAlloc((HLOCAL)pVarString, <br>                                      dwMaxNeededSize); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetCallStatus() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINECALLSTATUS * LineGetCallStatus (HCALL hCall) <br>{ <br>    LONG                lRetVal; <br>    LINECALLSTATUS    * pLineCallStatus; <br>    static DWORD        dwMaxNeededSize = sizeof(LINECALLSTATUS); <br> <br>    // Allocate an initial block of memory for the LINECALLSTATUS structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineCallStatus = ACDAlloc(dwMaxNeededSize); <br> <br>    while (TRUE) <br>    { <br>        if (pLineCallStatus == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineCallStatus-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINECALLSTATUS information <br>        // <br>        lRetVal = lineGetCallStatus(hCall, <br>                                    pLineCallStatus); <br>        if (lRetVal &lt; 0) <br>        { <br>            ACDFree((HLOCAL)pLineCallStatus); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINECALLSTATUS memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineCallStatus-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineCallStatus; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineCallStatus-&gt;dwNeededSize; <br>            pLineCallStatus = ACDReAlloc((HLOCAL)pLineCallStatus, <br>                                         dwMaxNeededSize); <br>        } <br>    } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
