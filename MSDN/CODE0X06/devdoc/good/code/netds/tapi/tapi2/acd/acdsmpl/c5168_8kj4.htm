<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACDTAPI.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5170"></a>ACDTAPI.C</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////////// <br>// <br>//  ACDTAPI.C <br>// <br>//  This file handles all tapi functionality in the ACD sample <br>// <br>// <br>// <br>//////////////////////////////////////////////////////////////////////////////////// <br>#include &lt;windows.h&gt; <br>#include &lt;tapi.h&gt; <br>#include "acdsmpl.h" <br> <br>VOID CALLBACK LineCallback (DWORD hDevice, <br>                            DWORD dwMsg, <br>                            DWORD dwCallbackInstance,  <br>                            DWORD dwParam1, <br>                            DWORD dwParam2,  <br>                            DWORD dwParam3); <br> <br> <br>#define LogTapiError(__lResult__, __szString__) <br>#define LogError(__szString__) <br> <br>extern ACDGLOBALS       g; <br> <br> <br>//////////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL InitializeTapi() <br>// <br>//    Whatever is needed to init TAPI for the application.  This is called <br>//    before the main window is created. <br>// <br>//////////////////////////////////////////////////////////////////////////////////// <br>BOOL InitializeTapi() <br>{ <br>    DWORD                       dwAPIVersion; <br>    LINEINITIALIZEEXPARAMS      exparams; <br>    LONG                        lResult; <br>    DWORD                       i; <br>    LPLINEDEVCAPS               pLDC; <br> <br> <br>    // fill in lineinitex parameters <br>    exparams.dwTotalSize             = sizeof(LINEINITIALIZEEXPARAMS); <br>    exparams.dwOptions               = LINEINITIALIZEEXOPTION_USEHIDDENWINDOW; <br>     <br>    dwAPIVersion = TAPI_CURRENT_VERSION; <br> <br>    // line init <br>    if ((lResult = lineInitializeEx(&amp;g.hLineApp, <br>                                    g.hInstance, <br>                                    LineCallback, <br>                                    SZAPPNAME, <br>                                    &amp;g.dwNumDevs, <br>                                    &amp;dwAPIVersion, <br>                                    &amp;exparams)) &lt; 0) <br>    { <br>        LogTapiError(lResult, "lineInitializeEx"); <br>        return FALSE; <br>    } <br> <br>    // if there are no tapi devices, should probably <br>    // not continue <br>    if (g.dwNumDevs == 0) <br>    { <br>        LogError("No TAPI devices installed"); <br>        lineShutdown(g.hLineApp); <br>        return FALSE; <br>    } <br> <br>    // need to get the permanent device IDs to map from <br>    // an .ini file being read in <br>    g.pdwPermIDs = (LPDWORD)ACDAlloc(g.dwNumDevs * sizeof(DWORD)); <br> <br>    if (!g.pdwPermIDs) <br>    { <br>        return FALSE; <br>    } <br>     <br>    for (i = 0; i &lt; g.dwNumDevs; i++) <br>    { <br>        pLDC = LineGetDevCaps(g.hLineApp, <br>                              i); <br> <br>        if (pLDC) <br>        { <br>            g.pdwPermIDs[i] = pLDC-&gt;dwPermanentLineID; <br>            ACDFree(pLDC); <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL CleanUp() <br>// <br>//  Called while shutting down.  free memory, close down tapi <br>// <br>////////////////////////////////////////////////////////////////////// <br>BOOL CleanUp() <br>{ <br>    PAGENT      pAgent, pAgentNext; <br>    PGROUP      pGroup, pGroupNext; <br> <br>    // remove agents <br>    pAgent = g.pAgents; <br>    while(pAgent) <br>    { <br>        pAgentNext = pAgent-&gt;pNext; <br>        DeleteAgent(pAgent); <br>        pAgent = pAgentNext; <br>    } <br> <br>    // remove groups <br>    pGroup = g.pGroups; <br>    while (pGroup) <br>    { <br>        pGroupNext = pGroup-&gt;pNext; <br>        DeleteGroup(pGroup); <br>        pGroup = pGroupNext; <br>    } <br> <br>    // free id array <br>    ACDFree(g.pdwPermIDs); <br> <br>    // shutdown <br>    lineShutdown(g.hLineApp); <br> <br>    return TRUE; <br>     <br>} <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT MakeGroupList(PAGENT pAgent, <br>//                        LPLINEAGENTGROUPLIST pGroupList) <br>// <br>//    Creates a LINEAGENTGROUPLIST for pAgent - group that the agent <br>//      is allowed to log into <br>//    Assumption:  don't care about address for group list <br>// <br>//////////////////////////////////////////////////////////////////////////////// <br>LRESULT MakeGroupList(PAGENT pAgent, <br>                      LPLINEAGENTGROUPLIST pGroupList) <br>{ <br>    PGROUP                  pGroup; <br>    DWORD                   dwTotalSizeNeeded, dwNameOffset, dwNumEntries; <br>    LPLINEAGENTGROUPENTRY   pEntry; <br>    LPTSTR                  pName; <br> <br> <br>    pGroup = g.pGroups; <br>    dwTotalSizeNeeded = sizeof(LINEAGENTGROUPLIST); <br>    pGroupList-&gt;dwNumEntries = 0; <br>    dwNumEntries = 0; <br> <br>    // walk list of groups <br>    while (pGroup) <br>    { <br>        if (IsAgentInList(pGroup-&gt;pAgentList, <br>                          pAgent)) <br>        // if found the agent, add the group to the group list <br>        { <br>            // incrememt number of entries <br>            dwNumEntries++; <br> <br>            // add to total size needed <br>            dwTotalSizeNeeded += sizeof(LINEAGENTGROUPENTRY); <br>            dwTotalSizeNeeded += (lstrlen(pGroup-&gt;lpszName) + 1) * sizeof(TCHAR); <br>        } <br> <br>        pGroup = pGroup-&gt;pNext; <br>    } <br> <br>    pGroupList-&gt;dwNeededSize = dwTotalSizeNeeded; <br>     <br>    if (pGroupList-&gt;dwTotalSize &lt; dwTotalSizeNeeded) <br>    { <br>        pGroupList-&gt;dwUsedSize = sizeof(LINEAGENTGROUPLIST); <br> <br>        return 0; <br>//        return LINEERR_STRUCTURETOOSMALL; <br>    } <br> <br>    pGroupList-&gt;dwNumEntries = dwNumEntries; <br> <br>    // set the list info <br>    pGroupList-&gt;dwListSize = sizeof(LINEAGENTGROUPENTRY) * pGroupList-&gt;dwNumEntries; <br>    pGroupList-&gt;dwListOffset = sizeof(LINEAGENTGROUPLIST); <br> <br>    // get the first agentgroup entry struct <br>    pEntry = (LPLINEAGENTGROUPENTRY)(((LPBYTE)pGroupList) + pGroupList-&gt;dwListOffset); <br> <br>    dwNameOffset = pGroupList-&gt;dwListOffset + pGroupList-&gt;dwListSize; <br>    pGroup = g.pGroups; <br> <br>    // loop through the groups again, and fill in the structure <br>    while (pGroup) <br>    { <br>        if (IsAgentInList(pGroup-&gt;pAgentList, <br>                          pAgent)) <br>        { <br>            // ID is just PGROUP <br>            pEntry-&gt;GroupID.dwGroupID1 = (DWORD)pGroup; <br>            pEntry-&gt;GroupID.dwGroupID2 = 0; <br>            pEntry-&gt;GroupID.dwGroupID3 = 0; <br>            pEntry-&gt;GroupID.dwGroupID4 = 0; <br> <br>            // set name of group <br>            pName = (LPTSTR)(((LPBYTE)pGroupList) + dwNameOffset); <br>                 <br>            pEntry-&gt;dwNameSize = (lstrlen(pGroup-&gt;lpszName) + 1) * sizeof(TCHAR); <br>            pEntry-&gt;dwNameOffset = dwNameOffset; <br>            lstrcpy(pName, <br>                    pGroup-&gt;lpszName); <br> <br>            dwNameOffset += pEntry-&gt;dwNameSize; <br> <br>            // get next entry <br>            pEntry++; <br>        } <br> <br>        pGroup = pGroup-&gt;pNext; <br>    } <br> <br>    pGroupList-&gt;dwUsedSize = dwTotalSizeNeeded; <br>     <br>    return 0; <br>} <br> <br> <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT SetGroupList() <br>// <br>//   Sets the groups that the agent is logged into. <br>//     This does not change the groups that the agent _can_ log into <br>// <br>//////////////////////////////////////////////////////////////////////////// <br>LRESULT SetGroupList(PAGENT pAgent, <br>                     DWORD dwAddress, <br>                     LPLINEAGENTGROUPLIST pGroupList) <br>{ <br>    LPLINEAGENTGROUPENTRY   pGroupEntry; <br>    PLISTITEM               pListEntry; <br>    DWORD                   i; <br>    PGROUP  *               ppGroups = NULL; <br>    PGROUP                  pGroup; <br> <br>    ppGroups = (PGROUP*)ACDAlloc(sizeof(PGROUP) * pGroupList-&gt;dwNumEntries); <br>     <br>    // get to the group entry struct <br>    pGroupEntry = (LPLINEAGENTGROUPENTRY)(((LPBYTE)pGroupList) + pGroupList-&gt;dwListOffset); <br> <br>    // loop through all entries <br>    for (i = 0; i &lt; pGroupList-&gt;dwNumEntries; i++) <br>    { <br>        // get the group in entry <br>        // NOTE! NOTE! NOTE! <br>        // should protect here against bad pointers !!! <br>        pGroup = (PGROUP)pGroupEntry-&gt;GroupID.dwGroupID1; <br> <br>        if (pGroup-&gt;dwKey != GROUPKEY) <br>        { <br>            return LINEERR_INVALAGENTGROUP; <br>        } <br>         <br>        pListEntry = pGroup-&gt;pAgentList; <br> <br>        // walk list of agents in that group <br>        if (!IsAgentInList(pGroup-&gt;pAgentList, <br>                           pAgent)) <br>        { <br>            ACDFree(ppGroups); <br>            return LINEERR_INVALAGENTGROUP; <br>        } <br> <br>        // save group for easy access <br>        ppGroups[i] = pGroup; <br>         <br>        // get the next entry (after the variable portion of <br>        // the previous entry struct) <br>        pGroupEntry++; <br>    } <br> <br>    // now we know that the groups to be set are valid <br>    // walk through the list of groups again, and <br>    // set the status to logged in/ not logged in <br>    // for every group that the agent is a member of <br> <br>    pGroup = g.pGroups; <br>     <br>    // walk list of all groups <br>    while (pGroup) <br>    { <br>        if (pListEntry = IsAgentInList(pGroup-&gt;pAgentList, <br>                                       pAgent)) <br>        { <br>            // default to not logged in <br>            pListEntry-&gt;bLoggedIn = FALSE; <br> <br>            // loop through groups being set <br>            for (i = 0; i &lt; pGroupList-&gt;dwNumEntries; i++) <br>            { <br>                // if this group is in list, set agent to logged in <br>                if (pGroup == ppGroups[i]) <br>                { <br>                    pListEntry-&gt;bLoggedIn = TRUE; <br>                    // assumption:  agent can only log into a group on one address. <br>                    pListEntry-&gt;dwAddress = dwAddress; <br>                    break; <br>                } <br>                 <br>            } // for <br>             <br>        }  // agent in list <br> <br>        // next group <br>        pGroup = pGroup-&gt;pNext; <br>         <br>    } // while <br> <br> <br>    ACDFree(ppGroups); <br>     <br>    return 0; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL MakeAgentActivityList() <br>// <br>//    Creates a LINEAGENTACTIVITYLIST for pAgent <br>// <br>//    for the sample, just generic names are used <br>//    "Activity 1", "Activity 2".... <br>// <br>///////////////////////////////////////////////////////////////////////// <br>LRESULT MakeAgentActivityList(PAGENT pAgent, <br>                              LPLINEAGENTACTIVITYLIST pActivityList) <br>{ <br>    TCHAR                       szBuffer[64]; <br>    DWORD                       dwTotalSize, dwNameOffset, i, dwNumEntries; <br>    LPTSTR                      pName; <br>    LPLINEAGENTACTIVITYENTRY    pEntry; <br> <br>    // init <br>    dwTotalSize = sizeof(LINEAGENTACTIVITYLIST); <br>    pActivityList-&gt;dwNumEntries = 0; <br>    dwNumEntries = 0; <br>     <br>    // just a static list of activities <br>    for (i = 0; i &lt; TOTALACTIVITIES; i++) <br>    { <br>        dwNumEntries++; <br> <br>        // create a name <br>        wsprintf(szBuffer, TEXT("Activity %lu"), i); <br> <br>        // determine size of this entry <br>        dwTotalSize += sizeof(LINEAGENTACTIVITYENTRY); <br>        dwTotalSize += (lstrlen(szBuffer) + 1) * sizeof(TCHAR); <br>    } <br> <br>    pActivityList-&gt;dwNeededSize = dwTotalSize; <br>     <br>    // verify size <br>    if (pActivityList-&gt;dwTotalSize &lt; dwTotalSize) <br>    { <br>        pActivityList-&gt;dwUsedSize = sizeof(LINEAGENTACTIVITYLIST); <br> <br>        return 0; <br>//        return LINEERR_STRUCTURETOOSMALL; <br>    } <br> <br>    pActivityList-&gt;dwNumEntries = dwNumEntries; <br>     <br>    // set list stuff <br>    pActivityList-&gt;dwListSize = sizeof(LINEAGENTACTIVITYENTRY) * pActivityList-&gt;dwNumEntries; <br>    pActivityList-&gt;dwListOffset = sizeof(LINEAGENTACTIVITYLIST); <br> <br>    // get first activityentry <br>    pEntry = (LPLINEAGENTACTIVITYENTRY)(((LPBYTE)pActivityList) + pActivityList-&gt;dwListOffset); <br>    dwNameOffset = pActivityList-&gt;dwListOffset + pActivityList-&gt;dwListSize; <br> <br>    // loop through activities again <br>    for (i = 0; i &lt; TOTALACTIVITIES; i++) <br>    { <br>        // fill in members <br>        pEntry-&gt;dwID = i; <br> <br>        // create a name <br>        wsprintf(szBuffer, TEXT("Activity %lu"), i); <br> <br>        pName = (LPTSTR)(((LPBYTE)pActivityList) + dwNameOffset); <br>         <br>        pEntry-&gt;dwNameSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR); <br>        pEntry-&gt;dwNameOffset = dwNameOffset; <br>        lstrcpy(pName, <br>                szBuffer); <br> <br>        dwNameOffset += pEntry-&gt;dwNameSize; <br>         <br>        pEntry++; <br> <br>    } // for <br> <br>    // fill in used size <br>    pActivityList-&gt;dwUsedSize = dwTotalSize; <br>     <br>    return 0; <br>} <br> <br> <br>#define DWAGENTFEATURES         LINEAGENTFEATURE_SETAGENTGROUP | \ <br>                                LINEAGENTFEATURE_SETAGENTSTATE | \ <br>                                LINEAGENTFEATURE_SETAGENTACTIVITY | \ <br>                                LINEAGENTFEATURE_GETAGENTACTIVITYLIST | \ <br>                                LINEAGENTFEATURE_GETAGENTGROUP <br> <br>#define DWSTATES                LINEAGENTSTATE_LOGGEDOFF | \ <br>                                LINEAGENTSTATE_NOTREADY | \ <br>                                LINEAGENTSTATE_READY | \ <br>                                LINEAGENTSTATE_BUSYACD | \ <br>                                LINEAGENTSTATE_BUSYINCOMING | \ <br>                                LINEAGENTSTATE_BUSYOUTBOUND | \ <br>                                LINEAGENTSTATE_BUSYOTHER | \ <br>                                LINEAGENTSTATE_WORKINGAFTERCALL | \ <br>                                LINEAGENTSTATE_UNKNOWN | \ <br>                                LINEAGENTSTATE_UNAVAIL <br> <br>#define DWNEXTSTATES            LINEAGENTSTATE_LOGGEDOFF | \ <br>                                LINEAGENTSTATE_NOTREADY | \ <br>                                LINEAGENTSTATE_READY | \ <br>                                LINEAGENTSTATE_BUSYACD | \ <br>                                LINEAGENTSTATE_BUSYINCOMING | \ <br>                                LINEAGENTSTATE_BUSYOUTBOUND | \ <br>                                LINEAGENTSTATE_BUSYOTHER | \ <br>                                LINEAGENTSTATE_WORKINGAFTERCALL | \ <br>                                LINEAGENTSTATE_UNKNOWN | \ <br>                                LINEAGENTSTATE_UNAVAIL <br> <br>#define DWSTATUSMESSAGES        LINEAGENTSTATUS_GROUP | \ <br>                                LINEAGENTSTATUS_STATE | \ <br>                                LINEAGENTSTATUS_NEXTSTATE | \ <br>                                LINEAGENTSTATUS_ACTIVITY | \ <br>                                LINEAGENTSTATUS_ACTIVITYLIST | \ <br>                                LINEAGENTSTATUS_GROUPLIST | \ <br>                                LINEAGENTSTATUS_CAPSCHANGE | \ <br>                                LINEAGENTSTATUS_VALIDSTATES | \ <br>                                LINEAGENTSTATUS_VALIDNEXTSTATES <br> <br> <br>//////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL IsValidState(DWORD dwState) <br>// <br>//////////////////////////////////////////////////////////////////// <br>BOOL IsValidState(DWORD dwState) <br>{ <br>    if (!dwState) <br>    { <br>        return TRUE; <br>    } <br> <br>    if ((dwState) &amp; (dwState - 1)) <br>    { <br>        // more than one bit set <br>        return FALSE; <br>    } <br> <br>    // make sure it's one of the valid states <br>    return (dwState &amp; DWSTATES); <br> <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL IsValidNextState(DWORD dwState) <br>// <br>//////////////////////////////////////////////////////////////////// <br>BOOL IsValidNextState(DWORD dwState) <br>{ <br>    if (!dwState) <br>    { <br>        return TRUE; <br>    } <br> <br>    if ((dwState) &amp; (dwState - 1)) <br>    { <br>        // more than one bit set <br>        return FALSE; <br>    } <br> <br>    // make sure it's one of the valid states <br>    return (dwState &amp; DWNEXTSTATES); <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL IsValidActivityID(DWORD dwActivityID) <br>// <br>/////////////////////////////////////////////////////////////////////// <br>BOOL IsValidActivityID(DWORD dwActivityID) <br>{ <br>    return (dwActivityID &lt;= TOTALACTIVITIES); <br>} <br> <br> <br> <br>//////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT MakeAgentCaps(PAGENT pAgent, <br>//                        LPLINEAGENTCAPS pAgentCaps) <br>// <br>//    Creates a LINEAGENTCAPS for pAgent <br>//    Features/states/messages are hardcoded <br>//     for this example <br>// <br>//////////////////////////////////////////////////////////////////////// <br>LRESULT MakeAgentCaps(PAGENT pAgent, <br>                      LPLINEAGENTCAPS pAgentCaps) <br>{ <br>    DWORD       dwStringSize; <br>     <br>    dwStringSize = (lstrlen(SZAPPNAME) + 1) * sizeof(TCHAR); <br> <br>    pAgentCaps-&gt;dwNeededSize = sizeof(LINEAGENTCAPS) + dwStringSize; <br> <br>    if (pAgentCaps-&gt;dwTotalSize &lt; pAgentCaps-&gt;dwNeededSize) <br>    { <br>        pAgentCaps-&gt;dwUsedSize = sizeof(LINEAGENTCAPS); <br>        return 0; <br>//        return LINEERR_STRUCTURETOOSMALL; <br>    } <br> <br>     <br>    pAgentCaps-&gt;dwAgentHandlerInfoSize = dwStringSize; <br>    pAgentCaps-&gt;dwAgentHandlerInfoOffset = sizeof(LINEAGENTCAPS); <br> <br>    pAgentCaps-&gt;dwCapsVersion = TAPI_CURRENT_VERSION; <br> <br>    // these features are hardcoded here. <br>    // a real implementation may set specific features <br>    // per agent or line or address <br>    pAgentCaps-&gt;dwFeatures              = DWAGENTFEATURES; <br>    pAgentCaps-&gt;dwStates                = DWSTATES; <br>    pAgentCaps-&gt;dwNextStates            = DWNEXTSTATES; <br>    pAgentCaps-&gt;dwMaxNumGroupEntries    = NUMGROUPENTRIES; <br>    pAgentCaps-&gt;dwAgentStatusMessages   = DWSTATUSMESSAGES; <br> <br>    // no extensions <br>    pAgentCaps-&gt;dwNumAgentExtensionIDs = 0; <br>    pAgentCaps-&gt;dwAgentExtensionIDListSize = 0; <br>    pAgentCaps-&gt;dwAgentExtensionIDListOffset = 0; <br> <br> <br>    pAgentCaps-&gt;dwUsedSize = pAgentCaps-&gt;dwNeededSize; <br>     <br>    return 0; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT GetAgentStatus() <br>// <br>//  Creates a LINEAGENTSTATUS for pAgent <br>// <br>////////////////////////////////////////////////////////////////////////// <br>LRESULT GetAgentStatus(PAGENT pAgent, <br>                       DWORD dwAddress, <br>                       LPLINEAGENTSTATUS pAgentStatus) <br>{ <br>    PGROUP                  pGroup; <br>    LPLINEAGENTGROUPENTRY   pGroupEntry; <br>    DWORD                   dwTotalSize, dwNameOffset, dwCount; <br>    TCHAR                   szActivityName[NAMESIZE]; <br>    PGROUP *                ppGroups; <br>    PLISTITEM               pEntry; <br> <br>    // init total size <br>    dwTotalSize = sizeof(LINEAGENTSTATUS); <br> <br>    if (dwAddress &gt;= pAgent-&gt;dwNumAddresses) <br>    { <br>        return LINEERR_INVALADDRESSID; <br>    } <br>     <br>    // set know members <br>    // for valid states / next states / agent features, just setting it to <br>    // generic stuff.  a real implementation may want to set these <br>    // field depending on current state / agent / hline <br>    pAgentStatus-&gt;dwState           = pAgent-&gt;pAddressInfo[dwAddress].dwState; <br>    pAgentStatus-&gt;dwNextState       = pAgent-&gt;pAddressInfo[dwAddress].dwNextState; <br>    pAgentStatus-&gt;dwActivityID      = pAgent-&gt;pAddressInfo[dwAddress].dwActivity; <br>    pAgentStatus-&gt;dwAgentFeatures   = DWAGENTFEATURES; <br>    pAgentStatus-&gt;dwValidStates     = DWSTATES; <br>    pAgentStatus-&gt;dwValidNextStates = DWNEXTSTATES; <br> <br>    // create the activity name <br>    wsprintf(szActivityName, TEXT("Activity %lu"), pAgent-&gt;pAddressInfo[dwAddress].dwActivity); <br>    dwTotalSize += (lstrlen(szActivityName) + 1) * sizeof(TCHAR); <br> <br>    ppGroups = (PGROUP *)ACDAlloc(sizeof(PGROUP) * g.dwNumGroups); <br> <br>    pGroup = g.pGroups; <br> <br>    pAgentStatus-&gt;dwNumEntries = 0; <br> <br>    // walk list of groups <br>    while (pGroup) <br>    { <br>        pEntry = pGroup-&gt;pAgentList; <br> <br>        // walk each agent in each group <br>        while (pEntry) <br>        { <br>            if (pEntry-&gt;pAgent == pAgent) <br>            { <br>                if ((!pEntry-&gt;bLoggedIn) || <br>                    (pEntry-&gt;dwAddress != dwAddress)) <br>                { <br>                    break; <br>                } <br> <br>                // save group <br>                ppGroups[pAgentStatus-&gt;dwNumEntries] = pGroup; <br> <br>                // adjust total size / entries <br>                pAgentStatus-&gt;dwNumEntries++; <br>                dwTotalSize += sizeof(LINEAGENTGROUPENTRY); <br>                dwTotalSize += (lstrlen(pGroup-&gt;lpszName) + 1) * sizeof(TCHAR); <br> <br>                break; <br>            } <br> <br>            pEntry = pEntry-&gt;pNext; <br>             <br>        }  // while (pEntry) <br> <br>        pGroup = pGroup-&gt;pNext; <br>         <br>    } // while (pGroup) <br> <br>    // set needed size <br>    pAgentStatus-&gt;dwNeededSize = dwTotalSize; <br> <br>    // do we have enough room? <br>    if (pAgentStatus-&gt;dwTotalSize &lt; dwTotalSize) <br>    { <br>        // if not, return <br>        pAgentStatus-&gt;dwUsedSize = sizeof(LINEAGENTSTATUS); <br>        ACDFree(ppGroups); <br> <br>        return 0; <br>//        return LINEERR_STRUCTURETOOSMALL; <br>    } <br> <br> <br>    // set the group entries... <br> <br>    // first get the offset to the first entry <br>    pGroupEntry = (LPLINEAGENTGROUPENTRY)(((LPBYTE)pAgentStatus) + sizeof(LINEAGENTSTATUS)); <br>    pAgentStatus-&gt;dwGroupListOffset = sizeof(LINEAGENTSTATUS); <br> <br>    // figure out where the names can go (after all the fixed structures) <br>    dwNameOffset = sizeof(LINEAGENTSTATUS) + <br>                   sizeof(LINEAGENTGROUPENTRY) * pAgentStatus-&gt;dwNumEntries; <br> <br>    // loop through all the group that the agent is logged into <br>    for (dwCount = 0; dwCount &lt; pAgentStatus-&gt;dwNumEntries; dwCount++) <br>    { <br>        // set the it (just the pGroup) <br>        pGroupEntry-&gt;GroupID.dwGroupID1 = (DWORD)ppGroups[dwCount]; <br>        pGroupEntry-&gt;GroupID.dwGroupID2 = 0; <br>        pGroupEntry-&gt;GroupID.dwGroupID3 = 0; <br>        pGroupEntry-&gt;GroupID.dwGroupID4 = 0; <br> <br>        // set name size and offset <br>        pGroupEntry-&gt;dwNameSize = (lstrlen(ppGroups[dwCount]-&gt;lpszName) + 1) * sizeof(TCHAR); <br>        pGroupEntry-&gt;dwNameOffset = dwNameOffset; <br> <br>        // copy name <br>        lstrcpy((LPTSTR)(((LPBYTE)pAgentStatus) + dwNameOffset), <br>                ppGroups[dwCount]-&gt;lpszName); <br> <br>        // fix the name offset <br>        dwNameOffset += pGroupEntry-&gt;dwNameSize; <br> <br>        // next entry <br>        pGroupEntry++; <br>         <br>    } <br> <br>    pAgentStatus-&gt;dwGroupListSize = dwNameOffset - pAgentStatus-&gt;dwGroupListOffset; <br>     <br>    // put the activity name at the end <br>    pAgentStatus-&gt;dwActivitySize = (lstrlen(szActivityName) + 1) * sizeof(TCHAR); <br>    pAgentStatus-&gt;dwActivityOffset = dwNameOffset; <br> <br>    lstrcpy((LPTSTR)(((LPBYTE)pAgentStatus) + dwNameOffset), <br>            szActivityName); <br> <br>     <br>    ACDFree(ppGroups); <br> <br>    pAgentStatus-&gt;dwUsedSize = pAgentStatus-&gt;dwNeededSize; <br>    // return success <br>    return 0; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT SetAgentState() <br>// <br>//    Sets the current and next state for pAgent <br>//    on that specific address <br>// <br>// <br>///////////////////////////////////////////////////////////////////// <br>LRESULT SetAgentState(PAGENT pAgent, <br>                      DWORD dwAddress, <br>                      DWORD dwState, <br>                      DWORD dwNextState) <br>{ <br>    // make sure valid <br>    if ((!IsValidState(dwState)) || <br>        (!IsValidNextState(dwNextState))) <br>    { <br>        return LINEERR_INVALAGENTSTATE; <br>    } <br> <br>    // check address <br>    if (dwAddress &gt;= pAgent-&gt;dwNumAddresses) <br>    { <br>        return LINEERR_INVALADDRESSID; <br>    } <br> <br>    // set the state if specified <br>    if (dwState) <br>    { <br>        pAgent-&gt;pAddressInfo[dwAddress].dwState = dwState; <br>    } <br> <br>    if (dwNextState) <br>    { <br>        pAgent-&gt;pAddressInfo[dwAddress].dwNextState = dwNextState; <br>    } <br>     <br>    return 0; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT SetAgentActivity() <br>// <br>//   Sets the activity for pAgent <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LRESULT SetAgentActivity(PAGENT pAgent, <br>                         DWORD dwAddress, <br>                         DWORD dwActivityID) <br>{ <br>    if (dwAddress &gt;= pAgent-&gt;dwNumAddresses) <br>    { <br>        return LINEERR_INVALADDRESSID; <br>    } <br> <br>    if (!IsValidActivityID(dwActivityID)) <br>    { <br>        return LINEERR_INVALAGENTACTIVITY; <br>    } <br> <br>    pAgent-&gt;pAddressInfo[dwAddress].dwActivity = dwActivityID; <br>     <br>    return 0; <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL HandleOffering(HCALL hCall) <br>// <br>//    Handles a LINECALLSTATE_OFFERING message <br>//      Determines the group associated with the address <br>//      that the call came in on, finds an available <br>//      agent in that group, and transfers the call to that <br>//      agent. <br>// <br>//////////////////////////////////////////////////////////////////////////////// <br>BOOL HandleOffering(HCALL hCall) <br>{ <br>    LPLINECALLINFO      pLCI; <br>    PGROUP              pGroup; <br>    PLISTITEM           pEntry; <br>    LONG                lResult; <br>     <br>    pLCI = LineGetCallInfo(hCall); <br> <br>    if (!pLCI) <br>    { <br>        return FALSE; <br>    } <br> <br>    pGroup = g.pGroups; <br> <br>    // find the group that this call came in on <br>    // walk all the groups <br>    while (pGroup) <br>    { <br>        // if the line and address match, it's the <br>        // correct address <br>        if ((pGroup-&gt;hLine == pLCI-&gt;hLine) &amp;&amp; <br>            (pGroup-&gt;dwAddress == pLCI-&gt;dwAddressID)) <br>        { <br>            break; <br>        } <br> <br>        pGroup = pGroup-&gt;pNext; <br>    } <br> <br>    // couldn't find the group <br>    if (!pGroup) <br>    { <br>        // error! <br>        ACDFree(pLCI); <br>        return FALSE; <br>    } <br> <br>    // OK - found the group that this call is for.  Now transfer to <br>    // an agent that is available. <br>    pEntry = pGroup-&gt;pAgentList; <br> <br>    while (pEntry) <br>    { <br>        if (pEntry-&gt;bLoggedIn &amp;&amp; <br>            (pEntry-&gt;pAgent-&gt;pAddressInfo[pEntry-&gt;dwAddress].dwState == <br>                LINEAGENTSTATE_READY)) <br>        { <br>            // found someone <br>            // doing a blind transfer here <br>            // other implementations may need to <br>            // do lineSetupTransfer / lineDial / lineCompleteTransfer <br>            if (lResult = lineBlindTransfer(hCall, <br>                                            (LPCWSTR)pEntry-&gt;pAgent-&gt;lpszNumber, <br>                                            0)) <br>            { <br>                //LogTapiError(TEXT("lineBlindTransfer"), lResult); <br>                // don't break - try the next agent <br>            } <br>            else <br>            { <br>                // set the state to reflect that <br>                // a call is being handled <br>                SetAgentState(pEntry-&gt;pAgent, <br>                              pEntry-&gt;dwAddress, <br>                              LINEAGENTSTATE_BUSYACD, <br>                              LINEAGENTSTATE_READY); <br> <br>                break; <br>            } <br> <br>        } <br>         <br>        pEntry = pEntry-&gt;pNext; <br>    } <br> <br>    if (!pEntry) <br>    { <br>        // couldn't find an available agent <br> <br>        // NOTE! NOTE! NOTE! NOTE! NOTE! <br>        // something should be done here with this call.  put into <br>        // a queue on hold or something.  For this sample, we are just <br>        // ignoring it <br>    } <br> <br>    ACDFree(pLCI); <br> <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL HandleIdle(HCALL hCall) <br>// <br>//    Handles LINECALLSTATE_IDLE <br>//     Should always always always deallocate when <br>//     getting an IDLE message.  Also, determine if this is a call <br>//     that we know about and set the agent state appropriatly <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL HandleIdle(HCALL hCall) <br>{ <br>    LPLINECALLINFO      pLCI; <br>    PAGENT              pAgent; <br> <br>    pLCI = LineGetCallInfo(hCall); <br> <br>    // always deallocate the call <br>    lineDeallocateCall(hCall); <br> <br>    if (!pLCI) <br>    { <br>        return FALSE; <br>    } <br> <br>    // get the agent associated with the line <br>    pAgent = GetAgentFromhLine(pLCI-&gt;hLine); <br> <br>    if (!pAgent) <br>    { <br>        ACDFree(pLCI); <br>        return FALSE; <br>    } <br>               <br> <br>    // set that agent to their next state <br>    // Assumption:  only calls that the ACD app know about <br>    // occur.  For example, if an agent made an outgoing call <br>    // and it transitioned to idle, this code would still be executed. <br>    // May make more sense to not handle NextState in the ACD app, and let <br>    // the client app handle it. <br>    SetAgentState(pAgent, <br>                  pLCI-&gt;dwAddressID, <br>                  pAgent-&gt;pAddressInfo[pLCI-&gt;dwAddressID].dwNextState, <br>                  0); <br> <br>    ACDFree(pLCI); <br>     <br>    return TRUE; <br>     <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>//  void HandleLineProxyRequest(HLINE hLine, <br>//                              LPLINEPROXYREQUEST pProxyRequest) <br>// <br>//    Handles LINE_PROXYREQUEST message <br>//     Just dispatches to appropriate functions <br>// <br>//////////////////////////////////////////////////////////////////////////// <br>void HandleLineProxyRequest(HLINE hLine, <br>                            LPLINEPROXYREQUEST pProxyRequest) <br>{ <br>    PAGENT       pAgent; <br>    LRESULT      lResult; <br> <br>    pAgent = GetAgentFromName((LPTSTR)(((LPBYTE)pProxyRequest) + <br>                                       pProxyRequest-&gt;dwClientUserNameOffset)); <br>     <br>    if (!pAgent) <br>    { <br>        lineProxyResponse(hLine, <br>                          pProxyRequest, </code></pre>
<p>
</p>
<pre><code>LINEERR_INVALAGENTID); <br> <br>        return; <br>    } <br>     <br>    switch (pProxyRequest-&gt;dwRequestType) <br>    { <br>        case LINEPROXYREQUEST_SETAGENTGROUP: <br> <br>            lResult = SetGroupList(pAgent, <br>                                   pProxyRequest-&gt;SetAgentGroup.dwAddressID, <br>                                   &amp;pProxyRequest-&gt;SetAgentGroup.GroupList); <br> <br>            lineProxyResponse(hLine, <br>                              pProxyRequest, <br>                              lResult); <br> <br>            return; <br>             <br>        case LINEPROXYREQUEST_SETAGENTSTATE: <br> <br>            lResult = SetAgentState(pAgent, <br>                                    pProxyRequest-&gt;SetAgentState.dwAddressID, <br>                                    pProxyRequest-&gt;SetAgentState.dwAgentState, <br>                                    pProxyRequest-&gt;SetAgentState.dwNextAgentState); <br> <br>            lineProxyResponse(hLine, <br>                              pProxyRequest, <br>                              lResult); <br>             <br>            break; <br>             <br>        case LINEPROXYREQUEST_SETAGENTACTIVITY: <br> <br>            lResult = SetAgentActivity(pAgent, <br>                                       pProxyRequest-&gt;SetAgentActivity.dwAddressID, <br>                                       pProxyRequest-&gt;SetAgentActivity.dwActivityID); <br> <br>            lineProxyResponse(hLine, <br>                              pProxyRequest, <br>                              lResult); <br>             <br>            break; <br>             <br>        case LINEPROXYREQUEST_GETAGENTSTATUS: <br> <br>            lResult = GetAgentStatus(pAgent, <br>                                     pProxyRequest-&gt;GetAgentStatus.dwAddressID, <br>                                     &amp;pProxyRequest-&gt;GetAgentStatus.AgentStatus); <br> <br>            lineProxyResponse(hLine, <br>                              pProxyRequest, <br>                              lResult); <br>             <br>            break; <br>             <br>        case LINEPROXYREQUEST_GETAGENTCAPS: <br> <br>            if ((hLine == pAgent-&gt;hLine) &amp;&amp; <br>                (pProxyRequest-&gt;GetAgentCaps.dwAddressID &lt; pAgent-&gt;dwNumAddresses)) <br>            { <br>                lResult = MakeAgentCaps(pAgent, <br>                                        &amp;pProxyRequest-&gt;GetAgentCaps.AgentCaps); <br>            } <br>            else <br>            { <br>                lResult = LINEERR_BADDEVICEID; <br>            } <br> <br>            lineProxyResponse(hLine, <br>                              pProxyRequest, <br>                              lResult); <br>            break; <br>             <br>        case LINEPROXYREQUEST_GETAGENTACTIVITYLIST: <br> <br>            lResult = MakeAgentActivityList(pAgent, <br>                                            &amp;pProxyRequest-&gt;GetAgentActivityList.ActivityList); <br> <br>            lineProxyResponse(hLine, <br>                              pProxyRequest, <br>                              lResult); <br>             <br>            break; <br>             <br>        case LINEPROXYREQUEST_GETAGENTGROUPLIST: <br> <br>            lResult = MakeGroupList(pAgent, <br>                                    &amp;pProxyRequest-&gt;GetAgentGroupList.GroupList); <br> <br>            lineProxyResponse(hLine, <br>                              pProxyRequest, <br>                              lResult); <br>            return; <br>             <br> <br>    } <br>    return; <br>} <br> <br>///////////////////////////////////////////////////////////// <br>// <br>//  void HandleLineCallState(DWORD dwDevice, <br>// <br>//  Handles callstate messages we are interested in <br>// <br>///////////////////////////////////////////////////////////// <br>void HandleLineCallState(DWORD dwDevice, <br>                         DWORD dwParam1, <br>                         DWORD dwParam2, <br>                         DWORD dwParam3) <br>{ <br>    switch (dwParam1) <br>    { <br>    case LINECALLSTATE_OFFERING: <br>    { <br>        LPLINECALLSTATUS        pLCS; <br> <br>        // get the call privilege. <br>        // NOTE:  the new LINE_APPNEWCALL message notifies applications <br>        // of their priv for new calls not created by app <br>        pLCS = LineGetCallStatus((HCALL)dwDevice); <br>        if (!pLCS) <br>        { <br>            break; <br>        } <br>         <br>        if (pLCS-&gt;dwCallPrivilege &amp; LINECALLPRIVILEGE_OWNER) <br>        { <br>            HandleOffering((HCALL)dwDevice); <br>        } <br> <br>        ACDFree(pLCS); <br>         <br>        break; <br>    } <br>    case LINECALLSTATE_CONNECTED: <br>        break; <br> <br>    case LINECALLSTATE_DISCONNECTED: <br>        break; <br> <br>    case LINECALLSTATE_IDLE: <br> <br>        HandleIdle((HCALL)dwDevice); <br>         <br>        break; <br> <br>    case LINECALLSTATE_BUSY: <br>        break; <br> <br>    default: <br>        break; <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// TAPI message handlers.  For this sample, they don't <br>// do anything <br>/////////////////////////////////////////////////////////////////////// <br>void HandleLineDevState(DWORD dwParam1, <br>                        DWORD dwParam2, <br>                        DWORD dwParam3) <br>{ <br>} <br> <br> <br>void HandleLineReply(DWORD dwParam1, <br>                     DWORD dwParam2, <br>                     DWORD dwParam3) <br>{ <br>} <br>void HandleLineCallInfo(DWORD dwParam1, <br>                             DWORD dwParam2, <br>                             DWORD dwParam3) <br>{ <br>} <br> <br>void HandleLineClose(DWORD dwParam1, <br>                          DWORD dwParam2, <br>                          DWORD dwParam3) <br>{ <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineCallback() - TAPI callback function <br>// <br>////////////////////////////////////////////////////////////////////////////////// <br>VOID CALLBACK LineCallback (DWORD hDevice, <br>                            DWORD dwMsg, <br>                            DWORD dwCallbackInstance,  <br>                            DWORD dwParam1, <br>                            DWORD dwParam2,  <br>                            DWORD dwParam3) <br>{ <br>    switch(dwMsg) <br>    { <br>      case LINE_PROXYREQUEST: <br>           HandleLineProxyRequest((HLINE) hDevice, <br>                                  (LPLINEPROXYREQUEST)dwParam1); <br>           return; <br>            <br>      case LINE_LINEDEVSTATE: <br>          HandleLineDevState(dwParam1, <br>                             dwParam2, <br>                             dwParam3); <br>          return; <br>      case LINE_REPLY: <br>          HandleLineReply(dwParam1, <br>                          dwParam2, <br>                          dwParam3); <br>          return; <br>      case LINE_CALLSTATE: <br>          HandleLineCallState(hDevice, <br>                              dwParam1, <br>                              dwParam2, <br>                              dwParam3); <br>          return;  <br>      case LINE_CALLINFO: <br>          HandleLineCallInfo(dwParam1, <br>                             dwParam2, <br>                             dwParam3); <br>          return; <br>      case LINE_CLOSE: <br>          HandleLineClose(dwParam1, <br>                          dwParam2, <br>                          dwParam3); <br>          return; <br> <br>      default: <br>          return; <br>   } <br>} <br> <br>    </code></pre>
<p>&nbsp;</p></body>
</HTML>
