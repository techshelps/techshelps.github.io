<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACDCLNT.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5165"></a>ACDCLNT.C</h2>
<pre><code>////////////////////////////////////////////////////////////////////////////// <br>// <br>//  ACDCLNT.C <br>// <br>//  ACDClient app <br>// <br>////////////////////////////////////////////////////////////////////////////// <br>#include &lt;windows.h&gt; <br>#include &lt;tapi.h&gt; <br>#include "acdclnt.h" <br>#include "resource.h" <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//  PROTOTYPES <br>////////////////////////////////////////////////////////////////////////////// <br>static BOOL CreateMainWindow (int nCmdShow); <br> <br>static LRESULT CALLBACK MainWndProc (HWND   hwnd, <br>                                     UINT   uMsg, <br>                                     WPARAM wParam, <br>                                     LPARAM lParam); <br> <br>LRESULT CALLBACK AgentStateDlgProc (HWND   hwnd, <br>                                    UINT   uMsg, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam); <br> <br>VOID CALLBACK LineCallback (DWORD hDevice, <br>                            DWORD dwMsg, <br>                            DWORD dwCallbackInstance,  <br>                            DWORD dwParam1, <br>                            DWORD dwParam2,  <br>                            DWORD dwParam3); <br>BOOL InitTapi(); <br> <br>BOOL CloseTapi(); <br> <br>BOOL RedoWindow(); <br> <br>BOOL SetStatusMessage(LPTSTR lpszMessage); <br> <br>BOOL SetButton(DWORD dwAddress, <br>               BOOL bAnswer, <br>               BOOL bEnable); <br> <br>LRESULT WaitForLineReply(); <br> <br>LONG ThreadRoutine(LPVOID lpv); <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>//  GLOBALS <br>// <br>////////////////////////////////////////////////////////////////////////////// <br>HINSTANCE       ghInstance;                 // main instance <br>HWND            ghMainWnd;                  // main window <br>PADDRESSINFO    pAddressInfo = NULL;        // array of info about each address <br>HLINEAPP        ghLineApp;                  // hlineapp <br>DWORD           gdwAddresses;               // number of addresses on our line <br>DWORD           gdwDeviceID;                // our device <br>HLINE           ghLine;                     // our line <br> <br>HANDLE          ghCompletionPort;           // tapi message completionport <br>CRITICAL_SECTION csLineReply; <br>    <br>// using global variables to keep track of line <br>// replies, since the main thread will only have at most one outstanding <br>// line reply at a time <br>BOOL            gbReply; <br>LONG            glResult; <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// WinMain() <br>// <br>////////////////////////////////////////////////////////////////////////////// <br>int WINAPI WinMain (HINSTANCE hInstance, <br>                    HINSTANCE hPrevInstance, <br>                    LPSTR     lpszCmdLine, <br>                    int       nCmdShow) <br>{ <br>    MSG msg; <br> <br>    ghInstance = hInstance; <br> <br>    if(!InitTapi()) <br>    { <br>        MessageBox(NULL, <br>                   TEXT("Failed to initialize TAPI"), <br>                   TEXT("Cannot start ACDClient"), <br>                   MB_OK); <br> <br>        return 0; <br>    } <br> <br>    if (!CreateMainWindow(nCmdShow)) <br>    { <br>        return 0; <br>    } <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    return 1; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// CreateMainWindow() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>BOOL CreateMainWindow (int nCmdShow) <br>{ <br> <br>    // main window <br>    ghMainWnd = CreateDialog(ghInstance, <br>                             MAKEINTRESOURCE(IDD_MAINDLG), <br>                             NULL, <br>                             MainWndProc); <br> <br>    if (ghMainWnd == NULL) <br>    { <br>        return FALSE; <br>    } <br> <br>    SetStatusMessage(TEXT("Waiting for call")); <br> <br>    // create buttons <br>    RedoWindow(); <br> <br>    ShowWindow(ghMainWnd, nCmdShow); <br> <br>    UpdateWindow(ghMainWnd); <br>     <br>    return TRUE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL SetStatusMessage(LPTSTR lpszMessage) <br>// <br>//  Sets text in the static control at the bottom of the main window to <br>//  lpszMessage <br>// <br>///////////////////////////////////////////////////////////////////////////////// <br>BOOL SetStatusMessage(LPTSTR lpszMessage) <br>{ <br>    return (SetWindowText(GetDlgItem(ghMainWnd, <br>                                     IDC_STATIC1), <br>                          lpszMessage)); <br> <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL ClearCall(HCALL hCall) <br>// <br>//  Called when a CALLSTATE_IDLE message is recieved.  Looks for the call in the <br>//  global pAddressInfo array.  If it finds it, is clears the appropriate members <br>//  of the structure <br>// <br>///////////////////////////////////////////////////////////////////////////////// <br>BOOL ClearCall(HCALL hCall) <br>{ <br>    DWORD       dwCount; <br> <br>    for (dwCount = 0; dwCount &lt; gdwAddresses; dwCount++) <br>    { <br>        if (pAddressInfo[dwCount].hCall == hCall) <br>        { <br>            pAddressInfo[dwCount].hCall = NULL; <br>            pAddressInfo[dwCount].bCall = FALSE; <br>            SetButton(dwCount, <br>                      TRUE, <br>                      FALSE); <br>            return TRUE; <br>        } <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL SetButton() <br>// <br>//  Sets the status and text of the answer/drop button for a specific address <br>// <br>////////////////////////////////////////////////////////////////////////////////// <br>BOOL SetButton(DWORD dwAddress, <br>               BOOL bAnswer, <br>               BOOL bEnable) <br>{ <br>    if (dwAddress &gt;= gdwAddresses) <br>        return FALSE; <br>     <br>    if (bAnswer) <br>    { <br>        SetWindowText(pAddressInfo[dwAddress].hAnswer, <br>                      TEXT("Answer")); <br>    } <br>    else <br>    { <br>        SetWindowText(pAddressInfo[dwAddress].hAnswer, <br>                      TEXT("Hang Up")); <br>    } <br> <br>    EnableWindow(pAddressInfo[dwAddress].hAnswer, <br>                 bEnable); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  VOID CALLBACK LineCallback () <br>// <br>//  TAPI callback function.  Handles all tapi messages <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>VOID CALLBACK LineCallback (DWORD hDevice, <br>                            DWORD dwMsg, <br>                            DWORD dwCallbackInstance,  <br>                            DWORD dwParam1, <br>                            DWORD dwParam2,  <br>                            DWORD dwParam3) <br>{ <br>    LPLINECALLINFO          pLCI; <br>    LPLINECALLSTATUS        pLCS; <br>    TCHAR                   szBuffer[64]; <br>     <br>    switch (dwMsg) <br>    { <br>        case LINE_REPLY: <br>        { <br>            EnterCriticalSection(&amp;csLineReply); <br>            if (dwParam1 == (DWORD)glResult) <br>            { <br>                gbReply = TRUE; <br>                glResult = dwParam2; <br>            } <br>            LeaveCriticalSection(&amp;csLineReply); <br>        } <br>        break; <br> <br>        case LINE_CALLSTATE: <br>        { <br>            if (dwParam1 == LINECALLSTATE_OFFERING) <br>            { <br>                // get the call privilege <br>                // note note note the new LINE_APPNEWCALL <br>                // give call privilege <br>                pLCS = LineGetCallStatus((HCALL)hDevice); <br> <br>                if (!pLCS) <br>                    return; <br> <br>                if (!(pLCS-&gt;dwCallPrivilege &amp; LINECALLPRIVILEGE_OWNER)) <br>                { <br>                    // not our call <br>                    GlobalFree(pLCS); <br>                    return; <br>                } <br> <br>                GlobalFree(pLCS); <br>                 <br>                // we're getting offered a call <br>                // first get the address <br>                pLCI = LineGetCallInfo((HCALL)hDevice); <br> <br>                if (!pLCI) <br>                { <br>                    // error <br>                    return; <br>                } <br> <br>                // set the status message text <br>                wsprintf(szBuffer, <br>                         TEXT("Incoming call on address %lu"), <br>                         pLCI-&gt;dwAddressID); <br> <br>                pAddressInfo[pLCI-&gt;dwAddressID].hCall = (HCALL)hDevice; <br>                 <br>                SetStatusMessage(szBuffer); <br> <br>                // set the button to answer <br>                SetButton(pLCI-&gt;dwAddressID, <br>                          TRUE, <br>                          TRUE); <br> <br>                GlobalFree(pLCI); <br> <br>                break; <br>            } <br> <br>            if (dwParam1 == LINECALLSTATE_IDLE) <br>            { <br>                // see if we have this call <br>                ClearCall((HCALL)hDevice); <br>                // dealloc no matter what <br>                lineDeallocateCall((HCALL)hDevice); <br>                 <br>                break; <br>            } <br>        } <br>         <br>        break; <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL GetAddressFromhWnd() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>BOOL GetAddressFromhWnd(HWND hWnd, <br>                        LPDWORD pdwAddress, <br>                        LPBOOL pbStatus) <br>{ <br>    DWORD       dwAddress; <br> <br>    // go through the array of addressinfo and see <br>    // if the hwnd matches <br>    for (dwAddress = 0; dwAddress &lt; gdwAddresses; dwAddress++) <br>    { <br>        if (pAddressInfo[dwAddress].hStatus == hWnd) <br>        { <br>            *pdwAddress = dwAddress; <br>            *pbStatus = TRUE; <br> <br>            return TRUE; <br>        } <br>        if (pAddressInfo[dwAddress].hAnswer == hWnd) <br>        { <br>            *pdwAddress = dwAddress; <br>            *pbStatus = FALSE; <br> <br>            return TRUE; <br>        } <br>    } <br> <br>    return FALSE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL DoLineAnswerDrop(DWORD dwAddress) <br>// <br>//  Handles what happens when the answer/drop button is pressed <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL DoLineAnswerDrop(DWORD dwAddress) <br>{ <br>    // if we have a call, then we want to drop it <br>    if (pAddressInfo[dwAddress].bCall) <br>    { <br> <br>        SetStatusMessage(TEXT("Hanging up call ...")); <br> <br>        EnterCriticalSection(&amp;csLineReply); <br>        glResult = lineDrop(pAddressInfo[dwAddress].hCall, <br>                           NULL, <br>                           0); <br> <br>        if (glResult &lt; 0) <br>        { <br>            LeaveCriticalSection(&amp;csLineReply); <br>            // error <br>        } <br> <br>        else if (WaitForLineReply()) <br>        { <br>            // error <br>        } <br> <br>        // error or not, deallocate and set button <br>        lineDeallocateCall(pAddressInfo[dwAddress].hCall); <br>         <br>        SetButton(dwAddress, <br>                  TRUE, <br>                  FALSE); <br>         <br>        pAddressInfo[dwAddress].hCall = NULL; <br>        pAddressInfo[dwAddress].bCall = FALSE; <br>         <br>        SetStatusMessage(TEXT("Waiting for a call")); <br> <br>    } <br>    else <br>    { <br>        BOOL bError = FALSE; <br> <br>         <br>        // answer <br>        SetStatusMessage(TEXT("Answering call...")); <br> <br>        EnterCriticalSection(&amp;csLineReply); <br>        glResult = lineAnswer(pAddressInfo[dwAddress].hCall, <br>                             NULL, <br>                             0); <br> <br>        if (glResult &lt; 0) <br>        { <br>            LeaveCriticalSection(&amp;csLineReply); <br>            bError = TRUE; <br>            //error <br>        } <br>        else if (WaitForLineReply()) <br>        { <br>            bError = TRUE; <br>            // error <br>        } <br> <br>        if (bError) <br>        { <br>            SetStatusMessage(TEXT("Hanging up call ...")); <br>            lineDeallocateCall(pAddressInfo[dwAddress].hCall); <br>            pAddressInfo[dwAddress].hCall = NULL; <br>            SetButton(dwAddress, <br>                      TRUE, <br>                      FALSE); <br> <br>            SetStatusMessage(TEXT("Waiting for a call")); <br>            return FALSE; <br>        } <br> <br>        SetStatusMessage(TEXT("On a call")); <br>         <br>        pAddressInfo[dwAddress].bCall = TRUE; <br> <br>        SetButton(dwAddress, <br>                  FALSE, <br>                  TRUE); <br>    } <br>     <br>    return TRUE; <br>} <br> <br>////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT DoCommand(WPARAM wParam, <br>//                    LPARAM lParam) <br>// <br>//  Handles WM_COMMAND messages for the main window <br>// <br>////////////////////////////////////////////////////////////////////// <br>LRESULT DoCommand(WPARAM wParam, <br>                  LPARAM lParam) <br>{ <br>    DWORD       dwAddress; <br>    BOOL        bStatus; <br> <br>    // check to see if a button is being clicked <br>    if (HIWORD(wParam) == BN_CLICKED) <br>    { <br>        // check to see if it is a button we care about <br>        if (GetAddressFromhWnd((HWND)lParam, <br>                               &amp;dwAddress, <br>                               &amp;bStatus)) <br>        { <br> <br>            // if it's the status button, display the status <br>            // dialog <br>            if (bStatus) <br>            { <br>                DialogBoxParam(ghInstance, <br>                               MAKEINTRESOURCE(IDD_AGENTSTATE), <br>                               ghMainWnd, <br>                               AgentStateDlgProc, <br>                               (LPARAM)dwAddress); <br>            } <br>            // else it's the answer/drop button <br>            else <br>            { <br>                DoLineAnswerDrop(dwAddress); <br>            } <br>        } <br> <br>        return 1; <br>                   <br>    } <br> <br> <br>    return 0; <br>} <br> <br> <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// <br>// MainWndProc() <br>// <br>//////////////////////////////////////////////////////////////////////////////// <br>LRESULT CALLBACK MainWndProc (HWND   hwnd, <br>                              UINT   uMsg, <br>                              WPARAM wParam, <br>                              LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>    case WM_INITDIALOG: <br> <br>        return 1; <br> <br>    case WM_COMMAND: <br> <br>        return DoCommand(wParam, <br>                         lParam); <br> <br>        break; <br> <br>    case WM_CLOSE: <br>    case WM_DESTROY: <br>        CloseTapi(); <br>        PostQuitMessage(0); <br>        return 1; <br>    } <br>     <br>    return 0; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL InitTapi() <br>// <br>//  Initializes TAPI.  For this sample, we assume that the "agent" (the person <br>//  logged on) can only have access to _one_ hLine.  Also, they have access to <br>//  every address on that line.  This may not be true for many ACD situations. <br>// <br>//  As soon as we find a device that the agent has access to, we quit <br>//  looking, and use that device <br>// <br>/////////////////////////////////////////////////////////////////////// <br>BOOL InitTapi() <br>{ <br>    LONG                    lResult; <br>    LINEINITIALIZEEXPARAMS  exparams; <br>    LPLINEAGENTCAPS         pLAC; <br>    LPLINEDEVCAPS           pLDC; <br>    DWORD                   dwDeviceID, dwNumDevs, dwAPIVersion, dwThreadID; <br> <br>    // initialize completion port to receive TAPI notifications <br>    ghCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <br>                                               NULL, <br>                                               0, <br>                                               0); <br> <br>    InitializeCriticalSection(&amp;csLineReply); <br> <br>    // fill in lineinitex parameters <br>    exparams.dwTotalSize             = sizeof(LINEINITIALIZEEXPARAMS); <br>    exparams.dwOptions               = LINEINITIALIZEEXOPTION_USECOMPLETIONPORT; <br>    exparams.Handles.hCompletionPort = ghCompletionPort; <br> <br>    dwAPIVersion = TAPI_CURRENT_VERSION; <br>     <br>    lResult = lineInitializeEx(&amp;ghLineApp, <br>                               ghInstance, <br>                               NULL, <br>                               SZAPPNAME, <br>                               &amp;dwNumDevs, <br>                               &amp;dwAPIVersion, <br>                               &amp;exparams); <br> <br>    if (lResult) <br>    { <br>        return FALSE; <br>    } <br> <br>    // if no devices, don't continue <br>    if (dwNumDevs == 0) <br>    { <br>        lineShutdown(ghLineApp); <br>        return FALSE; <br>    } <br> <br>    // kick off completion port thread <br>    CreateThread(NULL, <br>                 0, <br>                 (LPTHREAD_START_ROUTINE)ThreadRoutine, <br>                 NULL, <br>                 0, <br>                 &amp;dwThreadID); <br> <br>     <br>    // loop through all devices <br>    for (dwDeviceID = 0; dwDeviceID &lt; dwNumDevs; dwDeviceID++) <br>    { <br>        // Get the Agent Caps.  If this succeedes, this is <br>        // a device we can use <br>        pLAC = LineGetAgentCaps(ghLineApp, <br>                                dwDeviceID, <br>                                0); <br> <br>        if (pLAC) <br>        { <br>            // this is a device we can use <br>            gdwDeviceID = dwDeviceID; <br> <br>            // get the number of addresses <br>            pLDC = LineGetDevCaps(ghLineApp, <br>                                  dwDeviceID); <br> <br>            if (pLDC) <br>            { <br>                gdwAddresses = pLDC-&gt;dwNumAddresses; <br>                GlobalFree(pLDC); <br>            } <br>             <br>            GlobalFree(pLAC); <br>            break; <br>        } <br>    } <br> <br>    // open the line in owner mode <br>    lResult = lineOpen(ghLineApp, <br>                       gdwDeviceID, <br>                       &amp;ghLine, <br>                       TAPI_CURRENT_VERSION, <br>                       0, <br>                       0, <br>                       LINECALLPRIVILEGE_OWNER, <br>                       LINEMEDIAMODE_INTERACTIVEVOICE, <br>                       NULL); <br> <br>    // if line failed, don't continue <br>    if (lResult) <br>    { <br>        lineShutdown(ghLineApp); <br>        return FALSE; <br>    } <br> <br>     <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////// <br>// <br>//  ThreadRoutine <br>// <br>//  Thread dedicated to checking completion port for TAPI events <br>// <br>////////////////////////////////////////////////////////////////////// <br>LONG ThreadRoutine(LPVOID lpv) <br>{ <br>    LPLINEMESSAGE       pMsg; <br>    DWORD               dwNumBytesTransfered, dwCompletionKey; <br> <br> <br>    // just wait for tapi notifications <br>    while (GetQueuedCompletionStatus(ghCompletionPort, <br>                                     &amp;dwNumBytesTransfered, <br>                                     &amp;dwCompletionKey, <br>                                     (LPOVERLAPPED *) &amp;pMsg, <br>                                     INFINITE)) <br>    { <br>        if (pMsg) <br>        { <br>            // when we get one, call the handling function <br>            LineCallback(pMsg-&gt;hDevice, <br>                         pMsg-&gt;dwMessageID, <br>                         pMsg-&gt;dwCallbackInstance, <br>                         pMsg-&gt;dwParam1, <br>                         pMsg-&gt;dwParam2, <br>                         pMsg-&gt;dwParam3); <br> <br>            LocalFree (pMsg); <br>        } <br>        else <br>        { <br>            break; <br>        } <br>    } <br> <br>    ExitThread(0); <br>    return 0; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL CloseTapi() <br>// <br>//  Close tapi and free resources <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>BOOL CloseTapi() <br>{ <br>    GlobalFree(pAddressInfo); <br> <br>    CloseHandle(ghCompletionPort); <br>     <br>    lineClose(ghLine); <br>    lineShutdown(ghLineApp); <br>     <br>    return TRUE; <br>} <br> <br>// static information for the status dialog <br>static DWORD dwAgentStates[] = <br>        { <br>            LINEAGENTSTATE_LOGGEDOFF, <br>            LINEAGENTSTATE_NOTREADY, <br>            LINEAGENTSTATE_READY, <br>            LINEAGENTSTATE_BUSYACD, <br>            LINEAGENTSTATE_BUSYINCOMING, <br>            LINEAGENTSTATE_BUSYOUTBOUND, <br>            LINEAGENTSTATE_BUSYOTHER, <br>            LINEAGENTSTATE_WORKINGAFTERCALL, <br>            LINEAGENTSTATE_UNKNOWN, <br>            LINEAGENTSTATE_UNAVAIL, <br>            0 <br>        }; <br> <br>static LPTSTR lpszStates[] = <br>        { <br>            TEXT("Logged Off"), <br>            TEXT("Not Ready"), <br>            TEXT("Ready"), <br>            TEXT("Busy ACD"), <br>            TEXT("Busy Incoming"), <br>            TEXT("Busy Outbound"), <br>            TEXT("Busy Other"), <br>            TEXT("Working after call"), <br>            TEXT("Unknown"), <br>            TEXT("Unavail"), <br>            NULL <br>        }; <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL InitAgentDlg() <br>// <br>//  Handles initialization of the status dialog <br>// <br>//  Gets the group list and puts groups in multiselect list box <br>//      these are the groups that the agent _can_ log into <br>//      the groups they are logged into will be selected <br>//  Creates comboboxes of states and nextstates, and select <br>//      the agent's current state/nextstate <br>//  Gets the activity list and puts each item into a combobox <br>//      the current activity will be selected <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>BOOL InitAgentDlg(HWND hwnd, <br>                  DWORD dwAddress, <br>                  LPLINEAGENTGROUPLIST * ppLAG) <br>{ <br>    LPLINEAGENTCAPS         pLAC; <br>    LPLINEAGENTSTATUS       pLAS; <br>    LPLINEAGENTACTIVITYLIST pLAA; <br>    LPLINEAGENTGROUPENTRY   pEntry, pLoggedInEntry; <br>    LPLINEAGENTACTIVITYENTRY     pActivityEntry; <br>    DWORD                   dwEntries, dwCount; <br>    LONG                    item; <br> <br>    // first, get the status <br>    // this information will be used to know which items to select <br>    // in each of the listbox/comboboxes <br>    pLAS = LineGetAgentStatus(ghLine, <br>                              dwAddress); <br> <br>    if (!pLAS) <br>    { <br>        return FALSE; <br>    } <br> <br>    // get the group list <br>    if (!(*ppLAG = LineGetAgentGroupList(ghLine, <br>                                         dwAddress))) <br>    { <br>        return FALSE; <br>    } <br> <br>    // get the first groupentry <br>    pEntry = (LPLINEAGENTGROUPENTRY)(((LPBYTE)*ppLAG)+(*ppLAG)-&gt;dwListOffset); <br> <br>    // loop through the group entries <br>    for (dwEntries = 0; dwEntries &lt; (*ppLAG)-&gt;dwNumEntries; dwEntries++) <br>    { <br>        // add group to list box <br>        item = SendDlgItemMessage(hwnd, <br>                                  IDC_GROUPS, <br>                                  LB_ADDSTRING, <br>                                  0, <br>                                  (LPARAM)(LPTSTR)(((LPBYTE)*ppLAG) + pEntry-&gt;dwNameOffset)); <br> <br>        // save the entry <br>        SendDlgItemMessage(hwnd, <br>                           IDC_GROUPS, <br>                           LB_SETITEMDATA, <br>                           (WPARAM)item, <br>                           (LPARAM)pEntry); <br> <br>        // now get list of groups currently logged into from the agent status structure <br>        // loop through them.  if any of them match the group we are currently adding <br>        // select that group <br>        pLoggedInEntry = (LPLINEAGENTGROUPENTRY)(((LPBYTE)pLAS) + pLAS-&gt;dwGroupListOffset); <br>        for (dwCount = 0; dwCount &lt; pLAS-&gt;dwNumEntries; dwCount++) <br>        { <br>            if ((pLoggedInEntry-&gt;GroupID.dwGroupID1 == pEntry-&gt;GroupID.dwGroupID1) &amp;&amp; <br>                (pLoggedInEntry-&gt;GroupID.dwGroupID2 == pEntry-&gt;GroupID.dwGroupID2) &amp;&amp; <br>                (pLoggedInEntry-&gt;GroupID.dwGroupID3 == pEntry-&gt;GroupID.dwGroupID3) &amp;&amp; <br>                (pLoggedInEntry-&gt;GroupID.dwGroupID4 == pEntry-&gt;GroupID.dwGroupID4)) <br>            { <br>                SendDlgItemMessage(hwnd, <br>                                   IDC_GROUPS, <br>                                   LB_SETSEL, <br>                                   (WPARAM)TRUE, <br>                                   (LPARAM)item); <br>            } <br>             <br>            pLoggedInEntry++; <br>        } <br> <br>        pEntry++; <br>    } <br> <br>    // get the agent caps <br>    if (pLAC = LineGetAgentCaps(ghLineApp, <br>                                gdwDeviceID, <br>                                dwAddress)) <br>    { <br>        dwCount = 0; <br>        // loop through all possbile agent states.  if the agent state <br>        // is selected in the agent caps, add that state to the list box <br>        while (dwAgentStates[dwCount]) <br>        { <br>            if (dwAgentStates[dwCount] &amp; pLAC-&gt;dwStates) <br>            { <br>                item = SendDlgItemMessage(hwnd, <br>                                   IDC_STATE, <br>                                   CB_ADDSTRING, <br>                                   0, <br>                                   (LPARAM)lpszStates[dwCount]); <br>                SendDlgItemMessage(hwnd, <br>                                   IDC_STATE, <br>                                   CB_SETITEMDATA, <br>                                   (WPARAM)item, <br>                                   (LPARAM)dwAgentStates[dwCount]); <br> <br>                // if the state matches the current one from the agent status <br>                // select it <br>                if (pLAS-&gt;dwState == dwAgentStates[dwCount]) <br>                { <br>                    SendDlgItemMessage(hwnd, <br>                                       IDC_STATE, <br>                                       CB_SETCURSEL, <br>                                       (WPARAM)item, <br>                                       0); <br>                } <br>            } <br>             <br>            dwCount ++; <br>        } <br> <br>        dwCount = 0; <br>        // now do the same for the next states <br>        while (dwAgentStates[dwCount]) <br>        { <br>            if (dwAgentStates[dwCount] &amp; pLAC-&gt;dwNextStates) <br>            { <br>                item = SendDlgItemMessage(hwnd, <br>                                          IDC_NEXTSTATE, <br>                                          CB_ADDSTRING, <br>                                          0, <br>                                          (LPARAM)lpszStates[dwCount]); <br>                SendDlgItemMessage(hwnd, <br>                                   IDC_NEXTSTATE, <br>                                   CB_SETITEMDATA, <br>                                   (WPARAM)item, <br>                                   dwAgentStates[dwCount]); <br> <br>                if (pLAS-&gt;dwNextState == dwAgentStates[dwCount]) <br>                { <br>                    SendDlgItemMessage(hwnd, <br>                                       IDC_NEXTSTATE, <br>                                       CB_SETCURSEL, <br>                                       (WPARAM)item, <br>                                       0); <br>                } <br>            } <br> <br>            dwCount++; <br>        } <br> <br>        GlobalFree(pLAC); <br>    } <br> <br>    // get the activity list <br>    pLAA = LineGetAgentActivityList(ghLine, <br>                                    gdwDeviceID, <br>                                    dwAddress); <br>    if (pLAA) <br>    { <br>        dwCount = pLAA-&gt;dwNumEntries; <br>        pActivityEntry = (LPLINEAGENTACTIVITYENTRY)(((LPBYTE)pLAA) + pLAA-&gt;dwListOffset); <br> <br>        // go through all the possible activities and add them to the list <br>        while (dwCount) <br>        { <br>            item = SendDlgItemMessage(hwnd, <br>                                      IDC_ACTIVITY, <br>                                      CB_ADDSTRING, <br>                                      0, <br>                                      (LPARAM)(LPTSTR)(((LPBYTE)pLAA) + pActivityEntry-&gt;dwNameOffset)); <br> <br>            SendDlgItemMessage(hwnd, <br>                               IDC_ACTIVITY, <br>                               CB_SETITEMDATA, <br>                               (WPARAM)item, <br>                               (LPARAM)pActivityEntry-&gt;dwID); <br> <br>            // if this is the current activity (from agent status) <br>            // select it <br>            if (pLAS-&gt;dwActivityID == pActivityEntry-&gt;dwID) <br>            { <br>                SendDlgItemMessage(hwnd, <br>                                   IDC_ACTIVITY, <br>                                   CB_SETCURSEL, <br>                                   (WPARAM)item, <br>                                   0); <br>            } <br> <br>            dwCount--; <br>            pActivityEntry++; <br>        } <br> <br>        GlobalFree(pLAA); <br>             <br>    } <br> <br>} <br> <br>////////////////////////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL SaveAgentStatus(HWND hwnd) <br>// <br>//  Saves information from the status dialog <br>// <br>////////////////////////////////////////////////////////////////////////////////////////////// <br>BOOL SaveAgentStatus(HWND hwnd, <br>                     DWORD dwAddress) <br>{ <br>    LPLINEAGENTGROUPENTRY              pGroupEntry, pNewGroupEntry; <br>    LPLINEAGENTGROUPLIST               pNewLAG; <br>    DWORD                              dwCount; <br>    LPINT                              pItems; <br>    DWORD                              item; <br>    DWORD                              dwState, dwNextState, dwActivity; <br> <br>    // get the number of groups selected in the group <br>    // list box.  each selected group is a group this <br>    // agent will be logged into <br>    dwCount = SendDlgItemMessage(hwnd, <br>                                 IDC_GROUPS, <br>                                 LB_GETSELCOUNT, <br>                                 0, </code></pre>
<p>
</p>
<pre><code>0); <br> <br>    // allocate an array to hold the selected item's indexes <br>    pItems = (LPINT)GlobalAlloc(GPTR, sizeof(int) * dwCount); <br> <br>    // get the item's indexes <br>    SendDlgItemMessage(hwnd, <br>                       IDC_GROUPS, <br>                       LB_GETSELITEMS, <br>                       dwCount, <br>                       (LPARAM)pItems); <br> <br>    // alloc a LINEAGENTGROUP array for groups <br>    pNewLAG = (LPLINEAGENTGROUPLIST)GlobalAlloc(GPTR, <br>                                                sizeof(LINEAGENTGROUPLIST) + <br>                                                dwCount * sizeof(LINEAGENTGROUPENTRY)); <br> <br>    // fill in sizes <br>    pNewLAG-&gt;dwTotalSize = sizeof(LINEAGENTGROUPLIST) + dwCount * sizeof(LINEAGENTGROUPENTRY); <br>    pNewLAG-&gt;dwUsedSize = pNewLAG-&gt;dwTotalSize; <br>    pNewLAG-&gt;dwNeededSize = pNewLAG-&gt;dwTotalSize; <br>    pNewLAG-&gt;dwListSize = sizeof(LINEAGENTGROUPENTRY) * dwCount; <br>    pNewLAG-&gt;dwListOffset = sizeof(LINEAGENTGROUPLIST); <br> <br>    // count <br>    pNewLAG-&gt;dwNumEntries = dwCount; <br> <br>    // get pointer to first entry in array <br>    pNewGroupEntry = (LPLINEAGENTGROUPENTRY)(((LPBYTE)pNewLAG) + pNewLAG-&gt;dwListOffset); <br>    // loop though all selected item <br>    while (dwCount) <br>    { <br>        // get the item data associated with the item.  this data <br>        // is a group entry struct <br>        pGroupEntry = (LPLINEAGENTGROUPENTRY)SendDlgItemMessage(hwnd, <br>            IDC_GROUPS, <br>            LB_GETITEMDATA, <br>            (WPARAM)pItems[dwCount-1], <br>            0); <br> <br>        // copy the GroupID to the new array <br>        CopyMemory(&amp;pNewGroupEntry-&gt;GroupID, <br>                   &amp;pGroupEntry-&gt;GroupID, <br>                   sizeof(pGroupEntry-&gt;GroupID)); <br> <br>        // these fields are not used <br>        pNewGroupEntry-&gt;dwNameSize = 0; <br>        pNewGroupEntry-&gt;dwNameOffset = 0; <br> <br>        // next entry <br>        pNewGroupEntry++; <br> <br>        dwCount--; <br>    } <br> <br>    // now that we've created the AGENTGROUPLIST, set it <br>    EnterCriticalSection(&amp;csLineReply); <br>    glResult = lineSetAgentGroup(ghLine, <br>                                dwAddress, <br>                                pNewLAG); <br> <br>    if (glResult &lt; 0) <br>    { <br>        LeaveCriticalSection(&amp;csLineReply); <br>        //error <br>    } <br>    else if (WaitForLineReply()) <br>    { <br>        //error <br>    } <br> <br>    GlobalFree(pNewLAG); <br> <br>    // now get the current state <br>    item = SendDlgItemMessage(hwnd, <br>                              IDC_STATE, <br>                              CB_GETCURSEL, <br>                              0, <br>                              0); <br> <br>    // get item data.  this is the state flag <br>    dwState = SendDlgItemMessage(hwnd, <br>                                 IDC_STATE, <br>                                 CB_GETITEMDATA, <br>                                 (WPARAM)item, <br>                                 0); <br> <br>    // same for next state <br>    item = SendDlgItemMessage(hwnd, <br>                              IDC_NEXTSTATE, <br>                              CB_GETCURSEL, <br>                              0, <br>                              0); <br> <br>    dwNextState = SendDlgItemMessage(hwnd, <br>                                     IDC_NEXTSTATE, <br>                                     CB_GETITEMDATA, <br>                                     (WPARAM)item, <br>                                     0); <br> <br>    // set it <br>    EnterCriticalSection(&amp;csLineReply); <br>    glResult = lineSetAgentState(ghLine, <br>                                dwAddress, <br>                                dwState, <br>                                dwNextState); <br> <br>    if (glResult &lt; 0) <br>    { <br>        LeaveCriticalSection(&amp;csLineReply); <br>        //error <br>    } <br>    else if (WaitForLineReply()) <br>    { <br>        //error <br>    } <br> <br>    // get the activity selected <br>    item = SendDlgItemMessage(hwnd, <br>                              IDC_ACTIVITY, <br>                              CB_GETCURSEL, <br>                              0, <br>                              0); <br> <br>    // get the item data.  this is the activity ID <br>    dwActivity = SendDlgItemMessage(hwnd, <br>                                    IDC_ACTIVITY, <br>                                    CB_GETITEMDATA, <br>                                    (WPARAM)item, <br>                                    0); <br> <br>    // set it <br>    EnterCriticalSection(&amp;csLineReply); <br>    glResult = lineSetAgentActivity(ghLine, <br>                                   dwAddress, <br>                                   dwActivity); <br> <br> <br>     <br>    if (glResult &lt; 0) <br>    { <br>        LeaveCriticalSection(&amp;csLineReply); <br>        //error <br>    } <br>    else if (WaitForLineReply()) <br>    { <br>        //error <br>    } <br> <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT WaitForLineReply() <br>// <br>//  waiting for a line reply. <br>// <br>//  2 issues: <br>//      - using global variables for line reply information.  only recommended <br>//        in the most simple situations <br>// <br>//      - using completion ports to demonstrate the completion port mechanism. <br>//        since this app has ui, the wait loop has a message loop and a sleep()!! <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LRESULT WaitForLineReply() <br>{ <br>    MSG     msg; <br>     <br>    gbReply = FALSE; <br> <br>    LeaveCriticalSection(&amp;csLineReply); <br>     <br>    while (!gbReply) <br>    { <br>        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>         <br>        Sleep(5); <br>    } <br> <br>    return glResult; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////// <br>// <br>//  LRESULT CALLBACK AgentStateDlgProc () <br>// <br>//  Dialog proc for the agent status dialog <br>// <br>/////////////////////////////////////////////////////////////////////////////////// <br>LRESULT CALLBACK AgentStateDlgProc (HWND   hwnd, <br>                                    UINT   uMsg, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br>    static DWORD                   dwAddress; <br>    static LPLINEAGENTGROUPLIST    pLAG; <br>     <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br> <br>            dwAddress = (DWORD)lParam; <br>             <br>            InitAgentDlg(hwnd, <br>                         dwAddress, <br>                         &amp;pLAG); <br> <br>            SetFocus(GetDlgItem(hwnd, <br>                                IDC_GROUPS)); <br>            return 1; <br> <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK) <br>            { <br>                SaveAgentStatus(hwnd, <br>                                dwAddress); <br>                GlobalFree(pLAG); <br>                EndDialog(hwnd, <br>                          1); <br>                return 1; <br>            } <br>             <br>            if (LOWORD(wParam) == IDCANCEL) <br>            { <br>                GlobalFree(pLAG); <br>                EndDialog(hwnd, <br>                         1); <br> <br>                return 1; <br>            } <br>    } <br> <br>    return 0; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//      **************TAPI WRAPPER FUNCTIONS************** <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetAgentGroupList() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINEAGENTGROUPLIST * LineGetAgentGroupList (HLINE    hLine, <br>                                            DWORD    dwAddressID) <br>{ <br>    LINEAGENTGROUPLIST *    pLineAgentGroupList; <br>    static DWORD            dwMaxNeededSize = sizeof(LINEAGENTGROUPLIST); <br> <br>    // Allocate an initial block of memory for the LINEAGENTGROUPLIST structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineAgentGroupList = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    while (TRUE) <br>    { <br>        BOOL        bError = FALSE; <br> <br>         <br>        if (pLineAgentGroupList == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineAgentGroupList-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINEAGENTGROUPLIST information <br>        // <br>        EnterCriticalSection(&amp;csLineReply);         <br>        glResult = lineGetAgentGroupList(hLine, <br>                                        dwAddressID, <br>                                        pLineAgentGroupList); <br> <br>        if (glResult &lt; 0) <br>        { <br>            LeaveCriticalSection(&amp;csLineReply); <br>            bError = TRUE; <br>            //error <br>        } <br>        else if (WaitForLineReply()) <br>        { <br>            bError = TRUE; <br>            //error <br>        } <br> <br> <br>        if (bError) <br>        { <br>            GlobalFree((HLOCAL)pLineAgentGroupList); <br>            return NULL; <br>        } <br>         <br>        // If the currently allocated LINEAGENTGROUPLIST memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineAgentGroupList-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineAgentGroupList; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineAgentGroupList-&gt;dwNeededSize; <br>            pLineAgentGroupList = GlobalReAlloc((HLOCAL)pLineAgentGroupList, <br>                                           dwMaxNeededSize, <br>                                           GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetAgentStatus() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINEAGENTSTATUS * LineGetAgentStatus (HLINE    hLine, <br>                                      DWORD    dwAddressID) <br>{ <br>    LINEAGENTSTATUS *   pLineAgentStatus; <br>    static DWORD        dwMaxNeededSize = sizeof(LINEAGENTSTATUS); <br> <br>    // Allocate an initial block of memory for the LINEAGENTSTATUS structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineAgentStatus = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    while (TRUE) <br>    { <br>        BOOL        bError = FALSE; <br>        if (pLineAgentStatus == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineAgentStatus-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINEAGENTSTATUS information <br>        // <br>        EnterCriticalSection(&amp;csLineReply);         <br>        glResult = lineGetAgentStatus(hLine, <br>                                     dwAddressID, <br>                                     pLineAgentStatus); <br> <br>        if (glResult &lt; 0) <br>        { <br>            LeaveCriticalSection(&amp;csLineReply); <br>            bError = TRUE; <br>            //error <br>        } <br>        else if (WaitForLineReply()) <br>        { <br>            bError = TRUE; <br>            //error <br>        } <br> <br>        if (bError) <br>        { <br>            GlobalFree((HLOCAL)pLineAgentStatus); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINEAGENTSTATUS memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineAgentStatus-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineAgentStatus; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineAgentStatus-&gt;dwNeededSize; <br>            pLineAgentStatus = GlobalReAlloc((HLOCAL)pLineAgentStatus, <br>                                           dwMaxNeededSize, <br>                                           GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetAgentCaps() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINEAGENTCAPS * LineGetAgentCaps (HLINEAPP hLineApp, <br>                                  DWORD    dwDeviceID, <br>                                  DWORD    dwAddressID) <br>{ <br>    LINEAGENTCAPS *   pLineAgentCaps; <br>    static DWORD      dwMaxNeededSize = sizeof(LINEAGENTCAPS); <br> <br>    // Allocate an initial block of memory for the LINEAGENTCAPS structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineAgentCaps = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    while (TRUE) <br>    { <br>        BOOL            bError = FALSE; <br>         <br>        if (pLineAgentCaps == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineAgentCaps-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINEAGENTCAPS information <br>        // <br>        EnterCriticalSection(&amp;csLineReply);         <br>        glResult = lineGetAgentCaps(hLineApp, <br>                                   dwDeviceID, <br>                                   dwAddressID, <br>                                   TAPI_CURRENT_VERSION, <br>                                   pLineAgentCaps); <br> <br>        if (glResult &lt; 0) <br>        { <br>            bError = TRUE; <br>            LeaveCriticalSection(&amp;csLineReply); <br>            //error <br>        } <br>        else if (WaitForLineReply()) <br>        { <br>            bError = TRUE; <br>            //error <br>        } <br> <br> <br>        if (bError) <br>        { <br>            GlobalFree((HLOCAL)pLineAgentCaps); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINEAGENTCAPS memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineAgentCaps-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineAgentCaps; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineAgentCaps-&gt;dwNeededSize; <br>            pLineAgentCaps = GlobalReAlloc((HLOCAL)pLineAgentCaps, <br>                                           dwMaxNeededSize, <br>                                           GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetAgentActivityList() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LPLINEAGENTACTIVITYLIST LineGetAgentActivityList (HLINE    hLine, <br>                                                  DWORD    dwDeviceID, <br>                                                  DWORD    dwAddressID) <br>{ <br>    LINEAGENTACTIVITYLIST * pLineAgentActivityList; <br>    static DWORD            dwMaxNeededSize = sizeof(LINEAGENTACTIVITYLIST); <br> <br>    // Allocate an initial block of memory for the LINEAGENTACTIVITYLIST structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineAgentActivityList = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    for (;;) <br>    { <br>        BOOL        bError = FALSE; <br>        if (pLineAgentActivityList == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineAgentActivityList-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINEAGENTACTIVITYLIST information <br>        // <br>        EnterCriticalSection(&amp;csLineReply);         <br>        glResult = lineGetAgentActivityList(hLine, <br>                                           dwAddressID, <br>                                           pLineAgentActivityList); <br> <br>        if (glResult &lt; 0) <br>        { <br>            LeaveCriticalSection(&amp;csLineReply); <br>            bError = TRUE; <br>            //error <br>        } <br>        else if (WaitForLineReply()) <br>        { <br>            bError = TRUE; <br>            //error <br>        } <br> <br> <br>        if (bError) <br>        { <br>            GlobalFree((HLOCAL)pLineAgentActivityList); <br>            return NULL; <br>        } <br> <br> <br>        // If the currently allocated LINEAGENTACTIVITYLIST memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineAgentActivityList-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineAgentActivityList; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineAgentActivityList-&gt;dwNeededSize; <br>            pLineAgentActivityList = GlobalReAlloc((HLOCAL)pLineAgentActivityList, <br>                                            dwMaxNeededSize, <br>                                            GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetAddressCaps() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINEADDRESSCAPS * LineGetAddressCaps (HLINEAPP hLineApp, <br>                                      DWORD    dwDeviceID, <br>                                      DWORD    dwAddressID) <br>{ <br>    LONG              lRetVal; <br>    LINEADDRESSCAPS * pLineAddressCaps; <br>    static DWORD      dwMaxNeededSize = sizeof(LINEADDRESSCAPS); <br> <br>    // Allocate an initial block of memory for the LINEADDRESSCAPS structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineAddressCaps = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    for (;;) <br>    { <br>        if (pLineAddressCaps == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineAddressCaps-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINEADDRESSCAPS information <br>        // <br>        lRetVal = lineGetAddressCaps(hLineApp, <br>                                     dwDeviceID, <br>                                     dwAddressID, <br>                                     TAPI_CURRENT_VERSION, <br>                                     0, <br>                                     pLineAddressCaps); <br>        if (lRetVal &lt; 0) <br>        { <br>            GlobalFree((HLOCAL)pLineAddressCaps); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINEADDRESSCAPS memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineAddressCaps-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineAddressCaps; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineAddressCaps-&gt;dwNeededSize; <br>            pLineAddressCaps = GlobalReAlloc((HLOCAL)pLineAddressCaps, <br>                                             dwMaxNeededSize, <br>                                             GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetCallInfo() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINECALLINFO * LineGetCallInfo (HCALL hCall) <br>{ <br>    LONG           lRetVal; <br>    LINECALLINFO * pLineCallInfo; <br>    static DWORD   dwMaxNeededSize = sizeof(LINECALLINFO); <br> <br>    // Allocate an initial block of memory for the LINECALLINFO structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineCallInfo = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    for (;;) <br>    { <br>        if (pLineCallInfo == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineCallInfo-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINECALLINFO information <br>        // <br>        lRetVal = lineGetCallInfo(hCall, <br>                                  pLineCallInfo); <br>        if (lRetVal &lt; 0) <br>        { <br>            GlobalFree((HLOCAL)pLineCallInfo); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINECALLINFO memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineCallInfo-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineCallInfo; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineCallInfo-&gt;dwNeededSize; <br>            pLineCallInfo = GlobalReAlloc((HLOCAL)pLineCallInfo, <br>                                         dwMaxNeededSize, <br>                                         GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetDevCaps() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINEDEVCAPS * LineGetDevCaps (HLINEAPP hLineApp, <br>                              DWORD    dwDeviceID) <br>{ <br>    LONG           lRetVal; <br>    LINEDEVCAPS  * pLineDevCaps; <br>    static DWORD   dwMaxNeededSize = sizeof(LINEDEVCAPS); <br> <br>    pLineDevCaps = GlobalAlloc(GPTR, dwMaxNeededSize); <br>    for (;;) <br>    { <br>        if (pLineDevCaps == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineDevCaps-&gt;dwTotalSize = dwMaxNeededSize; <br>        lRetVal = lineGetDevCaps(hLineApp, <br>                                 dwDeviceID, <br>                                 TAPI_CURRENT_VERSION, <br>                                 0, <br>                                 pLineDevCaps); <br>        if (lRetVal &lt; 0) <br>        { <br>            GlobalFree((HLOCAL)pLineDevCaps); <br>            return NULL; <br>        } <br>        if (pLineDevCaps-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineDevCaps; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineDevCaps-&gt;dwNeededSize; <br>            pLineDevCaps = GlobalReAlloc((HLOCAL)pLineDevCaps, <br>                                        dwMaxNeededSize, <br>                                        GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetID() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>VARSTRING * LineGetID (HLINE  hLine, <br>                       DWORD  dwAddressID, <br>                       HCALL  hCall, <br>                       DWORD  dwSelect, <br>                       LPCTSTR lpszDeviceClass) <br>{ <br>    LONG           lRetVal; <br>    VARSTRING    * pVarString; <br>    static DWORD   dwMaxNeededSize = sizeof(VARSTRING); <br> <br>    // Allocate an initial block of memory for the VARSTRING structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pVarString = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    for (;;) <br>    { <br>        if (pVarString == NULL) <br>        { <br>            return NULL; <br>        } <br>        pVarString-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the VARSTRING information <br>        // <br>        lRetVal = lineGetID(hLine, <br>                            dwAddressID, <br>                            hCall, <br>                            dwSelect, <br>                            pVarString, <br>                            lpszDeviceClass); <br>        if (lRetVal &lt; 0) <br>        { <br>            GlobalFree((HLOCAL)pVarString); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated VARSTRING memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pVarString-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pVarString; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pVarString-&gt;dwNeededSize; <br>            pVarString = GlobalReAlloc((HLOCAL)pVarString, <br>                                      dwMaxNeededSize, <br>                                      GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// LineGetCallStatus() <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>LINECALLSTATUS * LineGetCallStatus (HCALL hCall) <br>{ <br>    LONG                lRetVal; <br>    LINECALLSTATUS    * pLineCallStatus; <br>    static DWORD        dwMaxNeededSize = sizeof(LINECALLSTATUS); <br> <br>    // Allocate an initial block of memory for the LINECALLSTATUS structure, <br>    // which may or may not be big enough to hold all of the information. <br>    // <br>    pLineCallStatus = GlobalAlloc(GPTR, dwMaxNeededSize); <br> <br>    while (TRUE) <br>    { <br>        if (pLineCallStatus == NULL) <br>        { <br>            return NULL; <br>        } <br>        pLineCallStatus-&gt;dwTotalSize = dwMaxNeededSize; <br> <br>        // Try (or retry) to get the LINECALLSTATUS information <br>        // <br>        lRetVal = lineGetCallStatus(hCall, <br>                                    pLineCallStatus); <br>        if (lRetVal &lt; 0) <br>        { <br>            GlobalFree((HLOCAL)pLineCallStatus); <br>            return NULL; <br>        } <br> <br>        // If the currently allocated LINECALLSTATUS memory block was big <br>        // enough, we're all done, else we need to realloc the memory block <br>        // and try again. <br>        // <br>        if (pLineCallStatus-&gt;dwNeededSize &lt;= dwMaxNeededSize) <br>        { <br>            return pLineCallStatus; <br>        } <br>        else <br>        { <br>            dwMaxNeededSize = pLineCallStatus-&gt;dwNeededSize; <br>            pLineCallStatus = GlobalReAlloc((HLOCAL)pLineCallStatus, <br>                                            dwMaxNeededSize, <br>                                            GMEM_MOVEABLE); <br>        } <br>    } <br>} <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// constants for creating buttons in the main window <br>// <br>#define YSTART              8 <br>#define XSTART              8 <br>#define STATICX             57 <br>#define BUTTONX             50 <br>#define BUTTONGAP           20 <br>#define BUTTONY             14 <br>#define LINEGAP             8 <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>//  BOOL RedoWindow() <br>// <br>//  Creates the buttons and static controls in the main window <br>//  For each address on the line, create a static control with the name off <br>//  the address, a button to get/set status, and a button to answer/drop <br>// <br>//  Right now, this should only be done when the app is starting.  It does <br>//  not check to see if pAddressInfo has already been allocated <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL RedoWindow() <br>{ <br>    DWORD                   dwAddress; <br>    LPLINEADDRESSCAPS       pLAC; <br>    TCHAR                   szBuffer[64]; <br>    LONG                    lBaseUnits, lxbase, lybase; <br>    HFONT                   hFont; <br>    HWND                    hWnd; <br> <br>    int         x,y,w,h,xstart,ystart,buttonx,buttony,staticx,buttongap,linegap; <br> <br> <br>    // alloc for address info <br>    pAddressInfo = (PADDRESSINFO)GlobalAlloc(GPTR, sizeof(ADDRESSINFO) * gdwAddresses); <br> <br>    if (!pAddressInfo) <br>    { <br>        return FALSE; <br>    } <br> <br>    // get conversions <br>    lBaseUnits = GetDialogBaseUnits(); <br>    lxbase = (LONG)LOWORD(lBaseUnits); <br>    lybase = (LONG)HIWORD(lBaseUnits); <br> <br>    // convert dialog units to pixels <br>    xstart = (XSTART * lxbase) / 4; <br>    ystart = (YSTART * lybase) / 8; <br>    buttonx = (BUTTONX * lxbase) / 4; <br>    buttony = (BUTTONY * lybase) / 8; <br>    staticx = (STATICX * lxbase) / 4; <br>    buttongap = (BUTTONGAP * lxbase) / 4; <br>    linegap = (LINEGAP * lybase) / 8; <br> <br>    // init <br>    x = xstart; <br>    y = ystart; <br>    w = buttonx; <br>    h = buttony; <br> <br>    // get the font used by the static control  <br>    hFont = (HFONT)SendDlgItemMessage(ghMainWnd, <br>                                      IDC_STATIC1, <br>                                      WM_GETFONT, <br>                                      0, <br>                                      0); <br> <br>    // loop through all addressed <br>    for (dwAddress = 0; dwAddress &lt; gdwAddresses; dwAddress++) <br>    { <br>        // get the name of the address <br>        pLAC = LineGetAddressCaps(ghLineApp, <br>                                  gdwDeviceID, <br>                                  dwAddress); <br> <br>        if (!pLAC || !pLAC-&gt;dwAddressSize) <br>        { <br>            wsprintf(szBuffer, <br>                     TEXT("Address %lu"), <br>                     dwAddress); <br>        } <br>        else <br>        { <br>            lstrcpy(szBuffer, <br>                    (LPTSTR)(((LPBYTE)pLAC)+pLAC-&gt;dwAddressOffset)); <br>        } <br> <br>        if (pLAC) <br>        { <br>            GlobalFree(pLAC); <br>        } <br> <br>        w = staticx; <br>        x = xstart; <br>        // create the static control <br>        hWnd = CreateWindow(TEXT("STATIC"), <br>                     szBuffer, <br>                     WS_CHILD | SS_LEFT | WS_VISIBLE, <br>                     x,y+(buttony/3),w,h, <br>                     ghMainWnd, <br>                     NULL, <br>                     ghInstance, <br>                     NULL); <br> <br>        // set the font <br>        SendMessage(hWnd, <br>                    WM_SETFONT, <br>                    (WPARAM)hFont, <br>                    0); <br> <br>        x += staticx; <br>        w = buttonx; <br>        // create the status button <br>        pAddressInfo[dwAddress].hStatus = CreateWindow(TEXT("BUTTON"), <br>                     TEXT("Set Status..."), <br>                     WS_CHILD | BS_PUSHBUTTON | WS_VISIBLE, <br>                     x,y,w,h, <br>                     ghMainWnd, <br>                     NULL, <br>                     ghInstance, <br>                     NULL); <br> <br>        // set the font <br>        SendMessage(pAddressInfo[dwAddress].hStatus, <br>                    WM_SETFONT, <br>                    (WPARAM)hFont, </code></pre>
<p>
</p>
<pre><code>0); <br> <br>        x += buttonx + buttongap; <br> <br>        // create the answer/drop button <br>        pAddressInfo[dwAddress].hAnswer = CreateWindow(TEXT("BUTTON"), <br>                     TEXT("Answer"), <br>                     WS_CHILD | WS_DISABLED | BS_PUSHBUTTON  | WS_VISIBLE, <br>                     x,y,w,h, <br>                     ghMainWnd, <br>                     NULL, <br>                     ghInstance, <br>                     NULL); <br> <br>        // set the font <br>        SendMessage(pAddressInfo[dwAddress].hAnswer, <br>                    WM_SETFONT, <br>                    (WPARAM)hFont, <br>                    0); <br> <br>        y += buttony + linegap; <br>    } <br> <br> <br>    // adjust position of message static control <br>    SetWindowPos(GetDlgItem(ghMainWnd, <br>                            IDC_STATIC1), <br>                  NULL, <br>                  xstart,y,0,0, <br>                  SWP_NOZORDER | SWP_NOSIZE); <br> <br>    // adjust the size of th main window <br>    SetWindowPos(ghMainWnd, <br>                 NULL, <br>                 0,0,xstart+staticx+buttonx+buttonx+buttongap+50,y+50, <br>                 SWP_NOZORDER | SWP_NOMOVE); <br> <br>    return TRUE; <br>                <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
