<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMMCODE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5182"></a>COMMCODE.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE: CommCode.c <br>// <br>//  PURPOSE: Handles all the COMM routines for TapiComm. <br>// <br>//  EXPORTED FUNCTIONS:  These functions are for use by other modules. <br>//    StartComm        - Start communications.   <br>//    StopComm         - Stop Communications. <br>//    WriteCommString  - Write a string to the Comm port. <br>// <br>//  INTERNAL FUNCTION:  These functions are for this module only. <br>//    CloseReadThread  - Close the Read Thread. <br>//    CloseWriteThread - Close the Write Thread. <br>// <br>//    StartReadThreadProc    - Starting function for the Read Thread. <br>//    StartWriteThreadProc   - Starting function for the Write Thread. <br>// <br>//    - Write Thread helper function <br>//    HandleWriteData - Actually does the work of writing a string to comm. <br>// <br>//    - Read Thread helper functions <br>//    SetupReadEvent  - Sets up the overlapped ReadFile <br>//    HandleReadEvent - Gets the results from the overlapped ReadFile <br>//    HandleReadData  - Handles data returned from the ReadFile <br>// <br>//    HandleCommEvent - Sets up the CommEvent event. <br>//    SetupCommEvent  - Handles CommEvent events (if they occur). <br>// <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "TapiCode.h" <br>#include "CommCode.h" <br>#include "globals.h" <br>#include "TapiInfo.h" <br>#include "EditCtls.h" <br> <br>// This is the message posted to the WriteThread <br>// When we have something to write. <br>#define PWM_COMMWRITE   WM_USER+1 <br> <br>// Default size of the Input Buffer used by this code. <br>#define INPUTBUFFERSIZE 2048 <br> <br>//***************************************** <br>// Global variables. <br>//***************************************** <br> <br>HANDLE g_hCommFile = NULL; <br> <br>DWORD g_dwReadThreadID  = 0; <br>DWORD g_dwWriteThreadID = 0; <br>HANDLE g_hReadThread  = NULL; <br>HANDLE g_hWriteThread = NULL; <br> <br>HANDLE g_hCloseEvent = NULL; <br> <br>//***************************************** <br>// CommCode internal Function Prototypes <br>//***************************************** <br> <br>void CloseReadThread(); <br>void CloseWriteThread(); <br> <br>DWORD WINAPI StartReadThreadProc(LPVOID lpvParam); <br>DWORD WINAPI StartWriteThreadProc(LPVOID lpvParam); <br> <br> <br>BOOL HandleWriteData(LPOVERLAPPED lpOverlappedWrite, <br>        LPCSTR lpszStringToWrite, DWORD dwNumberOfBytesToWrite); <br> <br> <br>BOOL SetupReadEvent(LPOVERLAPPED lpOverlappedRead, <br>        LPSTR lpszInputBuffer, DWORD dwSizeofBuffer, <br>        LPDWORD lpnNumberOfBytesRead); <br>BOOL HandleReadEvent(LPOVERLAPPED lpOverlappedRead, <br>        LPSTR lpszInputBuffer, DWORD dwSizeofBuffer, <br>        LPDWORD lpnNumberOfBytesRead); <br>BOOL HandleReadData(LPCSTR lpszInputBuffer, DWORD dwSizeofBuffer); <br> <br> <br>BOOL HandleCommEvent(LPOVERLAPPED lpOverlappedCommEvent, <br>        LPDWORD lpfdwEvtMask, BOOL fRetrieveEvent); <br>BOOL SetupCommEvent(LPOVERLAPPED lpOverlappedCommEvent, <br>        LPDWORD lpfdwEvtMask); <br> <br> <br> <br>//***************************************** <br>// Functions exported for use by other modules <br>//***************************************** <br> <br> <br> <br>// <br>//  FUNCTION: StartComm(HANDLE) <br>// <br>//  PURPOSE: Starts communications over the comm port. <br>// <br>//  PARAMETERS: <br>//    hNewCommFile - This is the COMM File handle to communicate with. <br>//                   This handle is obtained from TAPI. <br>// <br>//  RETURN VALUE: <br>//    TRUE if able to setup the communications. <br>// <br>//  COMMENTS: <br>// <br>//    StartComm makes sure there isn't communication in progress already, <br>//    the hNewCommFile is valid, and all the threads can be created.  It <br>//    also configures the hNewCommFile for the appropriate COMM settings. <br>// <br>//    If StartComm fails for any reason, it's up to the calling application <br>//    to close the Comm file handle. <br>// <br>// <br> <br>BOOL StartComm(HANDLE hNewCommFile) <br>{ <br>    // Is this a valid comm handle? <br>    if (GetFileType(hNewCommFile) != FILE_TYPE_CHAR) <br>    { <br>        OutputDebugString("File handle is not a comm handle.\n"); <br>        return FALSE; <br>    } <br> <br>    // Are we already doing comm? <br>    if (g_hCommFile != NULL) <br>    { <br>        OutputDebugString("Already have a comm file open\n"); <br>        return FALSE; <br>    } <br> <br>    // Its ok to continue. <br> <br>    g_hCommFile = hNewCommFile; <br> <br>    // Setting and querying the comm port configurations. <br> <br>    { // Configure the comm settings. <br>        COMMTIMEOUTS commtimeouts; <br>        DCB dcb; <br>        COMMPROP commprop; <br>        DWORD fdwEvtMask; <br> <br>        // These are here just so you can set a breakpoint <br>        // and see what the comm settings are.  Most Comm settings <br>        // are already set through TAPI. <br>        GetCommState(hNewCommFile, &amp;dcb); <br>        GetCommProperties(hNewCommFile, &amp;commprop); <br>        GetCommMask(g_hCommFile, &amp;fdwEvtMask); <br>        GetCommTimeouts(g_hCommFile, &amp;commtimeouts); <br> <br> <br>        // The CommTimeout numbers will very likely change if you are <br>        // coding to meet some kind of specification where <br>        // you need to reply within a certain amount of time after <br>        // recieving the last byte.  However,  If 1/4th of a second <br>        // goes by between recieving two characters, its a good  <br>        // indication that the transmitting end has finished, even <br>        // assuming a 1200 baud modem. <br> <br>        commtimeouts.ReadIntervalTimeout         = 250; <br>        commtimeouts.ReadTotalTimeoutMultiplier  = 0; <br>        commtimeouts.ReadTotalTimeoutConstant    = 0; <br>        commtimeouts.WriteTotalTimeoutMultiplier = 0; <br>        commtimeouts.WriteTotalTimeoutConstant   = 0; <br> <br>        SetCommTimeouts(g_hCommFile, &amp;commtimeouts); <br> <br>        // fAbortOnError is the only DCB dependancy in TapiComm. <br>        // Can't guarentee that the SP will set this to what we expect. <br>        dcb.fAbortOnError = FALSE; <br>        SetCommState(hNewCommFile, &amp;dcb); <br>    } <br> <br>    // Create the event that will signal the threads to close. <br>    g_hCloseEvent = CreateEvent(NULL, TRUE, FALSE, NULL); <br> <br>    if (g_hCloseEvent == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(), "Unable to CreateEvent: "); <br>        g_hCommFile = NULL; <br>        return FALSE; <br>    } <br> <br>    // Create the Read thread. <br>    g_hReadThread = <br>        CreateThread(NULL, 0, StartReadThreadProc, 0, 0, &amp;g_dwReadThreadID); <br>         <br>    if (g_hReadThread == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(),"Unable to create Read thread"); <br> <br>        g_dwReadThreadID = 0; <br>        g_hCommFile = 0; <br>        return FALSE; <br>    } <br>     <br>    // Comm threads should to have a higher base priority than the UI thread. <br>    // If they don't, then any temporary priority boost the UI thread gains <br>    // could cause the COMM threads to loose data. <br>    SetThreadPriority(g_hReadThread, THREAD_PRIORITY_HIGHEST); <br> <br>    // Create the Write thread. <br>    g_hWriteThread =  <br>        CreateThread(NULL, 0, StartWriteThreadProc, 0, 0, &amp;g_dwWriteThreadID); <br>         <br>    if (g_hWriteThread == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(),"Unable to create Write thread"); <br> <br>        CloseReadThread(); <br>        g_dwWriteThreadID = 0; <br>        g_hCommFile = 0; <br>        return FALSE; <br>    } <br>     <br>    SetThreadPriority(g_hWriteThread, THREAD_PRIORITY_ABOVE_NORMAL); <br> <br>    // Everything was created ok.  Ready to go! <br>    return TRUE; <br>} <br> <br> <br>// <br>//  FUNCTION: StopComm <br>// <br>//  PURPOSE: Stop and end all communication threads. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    Tries to gracefully signal all communication threads to <br>//    close, but terminates them if it has to. <br>// <br>// <br> <br>void StopComm() <br>{ <br>    // No need to continue if we're not communicating. <br>    if (g_hCommFile == NULL) <br>        return; <br> <br>    OutputDebugString("Stopping the Comm\n"); <br> <br>    // Close the threads. <br>    CloseReadThread(); <br>    CloseWriteThread(); <br> <br>    // Not needed anymore. <br>    CloseHandle(g_hCloseEvent); <br> <br>    // Now close the comm port handle. <br>    CloseHandle(g_hCommFile); <br>    g_hCommFile = NULL; <br>} <br> <br> <br>// <br>//  FUNCTION: WriteCommString(LPCSTR, DWORD) <br>// <br>//  PURPOSE: Send a String to the Write Thread to be written to the Comm. <br>// <br>//  PARAMETERS: <br>//    pszStringToWrite     - String to Write to Comm port.  <br>//    nSizeofStringToWrite - length of pszStringToWrite. <br>// <br>//  RETURN VALUE: <br>//    Returns TRUE if the PostMessage is successful. <br>//    Returns FALSE if PostMessage fails or Write thread doesn't exist. <br>// <br>//  COMMENTS: <br>// <br>//    This is a wrapper function so that other modules don't care that <br>//    Comm writing is done via PostMessage to a Write thread.  Note that <br>//    using PostMessage speeds up response to the UI (very little delay to <br>//    'write' a string) and provides a natural buffer if the comm is slow <br>//    (ie:  the messages just pile up in the message queue). <br>// <br>//    Note that it is assumed that pszStringToWrite is allocated with <br>//    LocalAlloc, and that if WriteCommString succeeds, its the job of the <br>//    Write thread to LocalFree it.  If WriteCommString fails, then its <br>//    the job of the calling function to free the string. <br>// <br>// <br> <br>BOOL WriteCommString(LPCSTR lpszStringToWrite, DWORD dwSizeofStringToWrite) <br>{ <br>    if (g_hWriteThread) <br>    { <br>        if (PostThreadMessage(g_dwWriteThreadID, PWM_COMMWRITE,  <br>                (WPARAM) dwSizeofStringToWrite, (LPARAM) lpszStringToWrite)) <br>        { <br>            return TRUE; <br>        } <br>        else <br>            OutputDebugString("Failed to Post to Write thread.\n"); <br>    } <br>    else <br>        OutputDebugString("Write thread not created\n"); <br> <br>    return FALSE; <br>} <br> <br> <br> <br>//***************************************** <br>// The rest of the functions are intended for use <br>// only within the CommCode module. <br>//***************************************** <br> <br> <br> <br>// <br>//  FUNCTION: CloseReadThread <br>// <br>//  PURPOSE: Close the Read Thread. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    Closes the Read thread by signaling the CloseEvent. <br>//    Purges any outstanding reads on the comm port. <br>// <br>//    Note that terminating a thread leaks memory (read the docs). <br>//    Besides the normal leak incurred, there is an event object <br>//    that doesn't get closed.  This isn't worth worrying about  <br>//    since it shouldn't happen anyway. <br>// <br>// <br> <br>void CloseReadThread() <br>{ <br>    // If it exists... <br>    if (g_hReadThread) <br>    { <br>        OutputDebugString("Closing Read Thread\n"); <br> <br>        // Signal the event to close the worker threads. <br>        SetEvent(g_hCloseEvent); <br> <br>        // Purge all outstanding reads <br>        PurgeComm(g_hCommFile, PURGE_RXABORT | PURGE_RXCLEAR); <br> <br>        // Wait 10 seconds for it to exit.  Shouldn't happen. <br>        if (WaitForSingleObject(g_hReadThread, 10000) == WAIT_TIMEOUT) <br>        { <br>            OutputDebugString("Read thread not exiting.  Terminating it.\n"); <br> <br>            TerminateThread(g_hReadThread, 0); <br> <br>            // The ReadThread cleans up these itself if it terminates <br>            // normally. <br>            CloseHandle(g_hReadThread); <br>            g_hReadThread = 0; <br>            g_dwReadThreadID = 0; <br>        } <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: CloseWriteThread <br>// <br>//  PURPOSE: Closes the Write Thread. <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>//    Closes the write thread by signaling the CloseEvent. <br>//    Purges any outstanding writes on the comm port. <br>// <br>//    Note that terminating a thread leaks memory (read the docs). <br>//    Besides the normal leak incurred, there is an event object <br>//    that doesn't get closed.  This isn't worth worrying about  <br>//    since it shouldn't happen anyway. <br>// <br>// <br> <br>void CloseWriteThread() <br>{ <br>    // If it exists... <br>    if (g_hWriteThread) <br>    { <br>        OutputDebugString("Closing Write Thread\n"); <br> <br>        // Signal the event to close the worker threads. <br>        SetEvent(g_hCloseEvent); <br> <br>        // Purge all outstanding writes. <br>        PurgeComm(g_hCommFile, PURGE_TXABORT | PURGE_TXCLEAR); <br> <br>        // Wait 10 seconds for it to exit.  Shouldn't happen. <br>        if (WaitForSingleObject(g_hWriteThread, 10000) == WAIT_TIMEOUT) <br>        { <br>            OutputDebugString("Write thread not exiting.  Terminating it.\n"); <br> <br>            TerminateThread(g_hWriteThread, 0); <br> <br>            // The WriteThread cleans up these itself if it terminates <br>            // normally. <br>            CloseHandle(g_hWriteThread); <br>            g_hWriteThread = 0; <br>            g_dwWriteThreadID = 0; <br> <br>        } <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: StartWriteThreadProc(LPVOID) <br>// <br>//  PURPOSE: The starting point for the Write thread. <br>// <br>//  PARAMETERS: <br>//    lpvParam - unused. <br>// <br>//  RETURN VALUE: <br>//    DWORD - unused. <br>// <br>//  COMMENTS: <br>// <br>//    The Write thread uses a PeekMessage loop to wait for a string to write, <br>//    and when it gets one, it writes it to the Comm port.  If the CloseEvent <br>//    object is signaled, then it exits.  The use of messages to tell the <br>//    Write thread what to write provides a natural desynchronization between <br>//    the UI and the Write thread. <br>// <br>// <br> <br>DWORD WINAPI StartWriteThreadProc(LPVOID lpvParam) <br>{ <br>    MSG msg; <br>    DWORD dwHandleSignaled; <br> <br>    // Needed for overlapped I/O. <br>    OVERLAPPED overlappedWrite = {0, 0, 0, 0, NULL}; <br> <br>    overlappedWrite.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL); <br>    if (overlappedWrite.hEvent == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(), "Unable to CreateEvent: "); <br>        PostHangupCall(); <br>        goto EndWriteThread; <br>    } <br> <br>    // This is the main loop.  Loop until we break out. <br>    while (TRUE) <br>    { <br>        if (!PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>            // If there are no messages pending, wait for a message or  <br>            // the CloseEvent. <br>            dwHandleSignaled =  <br>                MsgWaitForMultipleObjects(1, &amp;g_hCloseEvent, FALSE, <br>                    INFINITE, QS_ALLINPUT); <br> <br>            switch(dwHandleSignaled) <br>            { <br>                case WAIT_OBJECT_0:     // CloseEvent signaled! <br>                { <br>                    // Time to exit. <br>                    goto EndWriteThread; <br>                } <br> <br>                case WAIT_OBJECT_0 + 1: // New message was received. <br>                { <br>                    // Get the message that woke us up by looping again. <br>                    continue; <br>                } <br> <br>                case WAIT_FAILED:       // Wait failed.  Shouldn't happen. <br>                { <br>                    OutputDebugLastError(GetLastError(),"Write WAIT_FAILED: "); <br>                    PostHangupCall(); <br>                    goto EndWriteThread; <br>                } <br> <br>                default:                // This case should never occur. <br>                { <br>                    OutputDebugPrintf("Unexpected Wait return value '%lx'", <br>                        dwHandleSignaled); <br>                    PostHangupCall(); <br>                    goto EndWriteThread; <br>                } <br> <br>            } <br>        } <br> <br>        // Make sure the CloseEvent isn't signaled while retrieving messages. <br>        if (WAIT_TIMEOUT != WaitForSingleObject(g_hCloseEvent,0)) <br>            goto EndWriteThread; <br> <br>        // Process the message. <br> <br>        // This could happen if a dialog is created on this thread. <br>        // This doesn't occur in this sample, but might if modified. <br>        if (msg.hwnd != NULL) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br> <br>            continue; <br>        } <br> <br>        // Handle the message. <br>        switch(msg.message) <br>        { <br>            case PWM_COMMWRITE:  // New string to write to Comm port. <br>            { <br>                OutputDebugString("Writing to comm port\n"); <br> <br>                // Write the string to the comm port.  HandleWriteData <br>                // does not return until the whole string has been written, <br>                // an error occurs or until the CloseEvent is signaled. <br>                if (!HandleWriteData(&amp;overlappedWrite, <br>                        (LPSTR) msg.lParam, (DWORD) msg.wParam)) <br>                { <br>                    // If it failed, either we got a signal to end or there <br>                    // really was a failure. <br> <br>                    LocalFree((HLOCAL) msg.lParam);  <br>                    goto EndWriteThread; <br>                } <br> <br>                // Data was sent in a LocalAlloc()d buffer.  Must free it. <br>                LocalFree((HLOCAL) msg.lParam);  <br>                break; <br>            } <br>     <br> <br>            // What other messages could the thread get? <br>            default: <br>            { <br>                char Output[256]; <br>     <br>                wsprintf(Output, <br>                    "Unexpected message posted to Write thread: %ui\n", <br>                    msg.message ); <br>                     <br>                OutputDebugString(Output); <br>                break; <br>            } <br>        } // End of switch(message) <br> <br>    } // End of main loop. <br> <br>    // Thats the end.  Now clean up. <br>  EndWriteThread: <br> <br>    OutputDebugString("Write thread shutting down\n"); <br> <br>    PurgeComm(g_hCommFile, PURGE_TXABORT | PURGE_TXCLEAR); <br> <br>    CloseHandle(overlappedWrite.hEvent); <br> <br>    g_dwWriteThreadID = 0; <br>    CloseHandle(g_hWriteThread); <br>    g_hWriteThread = 0; <br> <br>    return 0; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleWriteData(LPOVERLAPPED, LPCSTR, DWORD) <br>// <br>//  PURPOSE: Writes a given string to the comm file handle. <br>// <br>//  PARAMETERS: <br>//    lpOverlappedWrite      - Overlapped structure to use in WriteFile <br>//    lpszStringToWrite      - String to write. <br>//    dwNumberOfBytesToWrite - Length of String to write. <br>// <br>//  RETURN VALUE: <br>//    TRUE if all bytes were written.  False if there was a failure to <br>//    write the whole string. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a helper function for the Write Thread.  It <br>//    is this call that actually writes a string to the comm file. <br>//    Note that this call blocks and waits for the Write to complete <br>//    or for the CloseEvent object to signal that the thread should end. <br>//    Another possible reason for returning FALSE is if the comm port <br>//    is closed by the service provider. <br>// <br>// <br> <br>BOOL HandleWriteData(LPOVERLAPPED lpOverlappedWrite, <br>    LPCSTR lpszStringToWrite, DWORD dwNumberOfBytesToWrite) <br>{ <br>    DWORD dwLastError; <br> <br>    DWORD dwNumberOfBytesWritten = 0; <br>    DWORD dwWhereToStartWriting = 0; // Start at the beginning. <br> <br>    DWORD dwHandleSignaled; <br>    HANDLE HandlesToWaitFor[2]; <br> <br>    HandlesToWaitFor[0] = g_hCloseEvent; <br>    HandlesToWaitFor[1] = lpOverlappedWrite -&gt; hEvent; <br> <br>    // Keep looping until all characters have been written. <br>    do <br>    { <br>        // Start the overlapped I/O. <br>        if (!WriteFile(g_hCommFile,  <br>                &amp;lpszStringToWrite[ dwWhereToStartWriting ],  <br>                dwNumberOfBytesToWrite, &amp;dwNumberOfBytesWritten, <br>                lpOverlappedWrite)) <br>        { <br>            // WriteFile failed.  Expected; lets handle it. <br>            dwLastError = GetLastError(); <br> <br>            // Its possible for this error to occur if the  <br>            // service provider has closed the port.  Time to end. <br>            if (dwLastError == ERROR_INVALID_HANDLE) <br>            { <br>                OutputDebugString("ERROR_INVALID_HANDLE, " <br>                    "Likely that the Service Provider has closed the port.\n"); <br>                return FALSE; <br>            } <br> <br>            // Unexpected error.  No idea what. <br>            if (dwLastError != ERROR_IO_PENDING) <br>            { <br>                OutputDebugLastError(dwLastError, <br>                    "Error to writing to CommFile"); <br>                 <br>                OutputDebugString("Closing TAPI\n"); <br>                PostHangupCall(); <br>                return FALSE; <br>            } <br> <br>            // This is the expected ERROR_IO_PENDING case. <br> <br> <br>            // Wait for either overlapped I/O completion, <br>            // or for the CloseEvent to get signaled. <br>            dwHandleSignaled =  <br>                WaitForMultipleObjects(2, HandlesToWaitFor,  <br>                    FALSE, INFINITE); <br> <br>            switch(dwHandleSignaled) <br>            { <br>                case WAIT_OBJECT_0:     // CloseEvent signaled! <br>                { <br>                    // Time to exit. <br>                    return FALSE; <br>                } <br> <br>                case WAIT_OBJECT_0 + 1: // Wait finished. <br>                { <br>                    // Time to get the results of the WriteFile <br>                    break; <br>                } <br> <br>                case WAIT_FAILED: // Wait failed.  Shouldn't happen. <br>                { <br>                    OutputDebugLastError(GetLastError(),  <br>                        "Write WAIT_FAILED: "); <br>                    PostHangupCall(); <br>                    return FALSE; <br>                } <br> <br>                default: // This case should never occur. <br>                { <br>                    OutputDebugPrintf( <br>                        "Unexpected Wait return value '%lx'", <br>                        dwHandleSignaled); <br>                    PostHangupCall(); <br>                    return FALSE; <br>                } <br>            } <br> <br>            if (!GetOverlappedResult(g_hCommFile, <br>                     lpOverlappedWrite, <br>                     &amp;dwNumberOfBytesWritten, TRUE)) <br>            { <br>                dwLastError = GetLastError(); <br> <br>                // Its possible for this error to occur if the  <br>                // service provider has closed the port. <br>                if (dwLastError == ERROR_INVALID_HANDLE) <br>                { <br>                    OutputDebugString("ERROR_INVALID_HANDLE, " <br>                        "Likely that the Service Provider has closed the port.\n"); <br>                    return FALSE; <br>                } <br> <br>                // No idea what could cause another error. <br>                OutputDebugLastError(dwLastError, <br>                    "Error writing to CommFile while waiting"); <br>                OutputDebugString("Closing TAPI\n"); <br>                PostHangupCall(); <br>                return FALSE; <br>            } <br>        } <br> <br>        // Some data was written.  Make sure it all got written. <br> <br>        dwNumberOfBytesToWrite -= dwNumberOfBytesWritten; <br>        dwWhereToStartWriting += dwNumberOfBytesWritten; <br>    } <br>    while(dwNumberOfBytesToWrite &gt; 0);  // Write the whole thing! <br> <br>    // Wrote the whole string. <br>    return TRUE; <br>} <br> <br> <br>// <br>//  FUNCTION: StartReadThreadProc(LPVOID) <br>// <br>//  PURPOSE: This is the starting point for the Read Thread. <br>// <br>//  PARAMETERS: <br>//    lpvParam - unused. <br>// <br>//  RETURN VALUE: <br>//    DWORD - unused. <br>// <br>//  COMMENTS: <br>// <br>//    The Read Thread uses overlapped ReadFile and sends any strings <br>//    read from the comm port to the UI to be printed.  This is <br>//    eventually done through a PostMessage so that the Read Thread <br>//    is never away from the comm port very long.  This also provides <br>//    natural desynchronization between the Read thread and the UI. <br>// <br>//    If the CloseEvent object is signaled, the Read Thread exits. <br>// <br>//    Note that there is absolutely *no* interpretation of the data, <br>//    which means no terminal emulation.  It basically means that this <br>//    sample is pretty useless as a TTY program. <br>// <br>//  Separating the Read and Write threads is natural for a application <br>//    like this sample where there is no need for synchronization between <br>//    reading and writing.  However, if there is such a need (for example, <br>//    most file transfer algorithms synchronize the reading and writing), <br>//    then it would make a lot more sense to have a single thread to handle <br>//    both reading and writing. <br>// <br>// <br> <br>DWORD WINAPI StartReadThreadProc(LPVOID lpvParam) <br>{ <br>    char szInputBuffer[INPUTBUFFERSIZE]; <br>    DWORD nNumberOfBytesRead; <br> <br>    HANDLE HandlesToWaitFor[3]; <br>    DWORD dwHandleSignaled; <br> <br>    DWORD fdwEvtMask; <br> <br>    // Needed for overlapped I/O (ReadFile) <br>    OVERLAPPED overlappedRead  = {0, 0, 0, 0, NULL}; <br> <br>    // Needed for overlapped Comm Event handling. <br>    OVERLAPPED overlappedCommEvent = {0, 0, 0, 0, NULL}; <br> <br>    // Lets put an event in the Read overlapped structure. <br>    overlappedRead.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL); <br>    if (overlappedRead.hEvent == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(), "Unable to CreateEvent: "); <br>        PostHangupCall(); <br>        goto EndReadThread; <br>    } <br> <br>    // And an event for the CommEvent overlapped structure. <br>    overlappedCommEvent.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL); <br>    if (overlappedCommEvent.hEvent == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(), "Unable to CreateEvent: "); <br>        PostHangupCall(); <br>        goto EndReadThread; <br>    } <br> <br>    // We will be waiting on these objects. <br>    HandlesToWaitFor[0] = g_hCloseEvent; <br>    HandlesToWaitFor[1] = overlappedCommEvent.hEvent; <br>    HandlesToWaitFor[2] = overlappedRead.hEvent; <br> <br> <br>    // Setup CommEvent handling. <br> <br>    // Set the comm mask so we receive error signals. <br>    if (!SetCommMask(g_hCommFile, EV_ERR)) <br>    { <br>        OutputDebugLastError(GetLastError(),"Unable to SetCommMask: "); <br>        PostHangupCall(); <br>        goto EndReadThread; <br>    } <br> <br>    // Start waiting for CommEvents (Errors) <br>    if (!SetupCommEvent(&amp;overlappedCommEvent, &amp;fdwEvtMask)) <br>    { <br>        PostHangupCall(); <br>        goto EndReadThread; <br>    } <br> <br>    // Start waiting for Read events. <br>    if (!SetupReadEvent(&amp;overlappedRead, <br>                szInputBuffer, INPUTBUFFERSIZE, <br>                &amp;nNumberOfBytesRead)) <br>    { <br>        PostHangupCall(); <br>        goto EndReadThread; <br>    } <br> <br>    // Keep looping until we break out. <br>    while (TRUE) <br>    { <br>        // Wait until some event occurs (data to read; error; stopping). <br>        dwHandleSignaled =  <br>            WaitForMultipleObjects(3, HandlesToWaitFor, <br>                FALSE, INFINITE); <br> <br>        // Which event occured? <br>        switch(dwHandleSignaled) <br>        { <br>            case WAIT_OBJECT_0:     // Signal to end the thread. <br>            { <br>                // Time to exit. <br>                goto EndReadThread; <br>            } <br> <br>            case WAIT_OBJECT_0 + 1: // CommEvent signaled. <br>            { <br>                // Handle the CommEvent. <br>                if (!HandleCommEvent(&amp;overlappedCommEvent, &amp;fdwEvtMask, TRUE)) <br>                { <br>                    PostHangupCall(); <br>                    goto EndReadThread; <br>                } <br> <br>                // Start waiting for the next CommEvent. <br>                if (!SetupCommEvent(&amp;overlappedCommEvent, &amp;fdwEvtMask)) <br>                { <br>                    PostHangupCall(); <br>                    goto EndReadThread; <br>                } <br>                break; <br>            } <br> <br>            case WAIT_OBJECT_0 + 2: // Read Event signaled. <br>            { <br>                // Get the new data! <br>                if (!HandleReadEvent(&amp;overlappedRead, <br>                            szInputBuffer, INPUTBUFFERSIZE, <br>                            &amp;nNumberOfBytesRead)) <br>                { <br>                    PostHangupCall(); <br>                    goto EndReadThread; <br>                } <br> <br>                // Wait for more new data. <br>                if (!SetupReadEvent(&amp;overlappedRead, <br>                            szInputBuffer, INPUTBUFFERSIZE, <br>                            &amp;nNumberOfBytesRead)) <br>                { <br>                    PostHangupCall(); <br>                    goto EndReadThread; <br>                } <br>                break; <br>            } <br> <br>            case WAIT_FAILED:       // Wait failed.  Shouldn't happen. <br>            { <br>                OutputDebugLastError(GetLastError(),"Read WAIT_FAILED: "); <br>                PostHangupCall(); <br>                goto EndReadThread; <br>            } <br> <br>            default:    // This case should never occur. <br>            { <br>                OutputDebugPrintf("Unexpected Wait return value '%lx'", <br>                    dwHandleSignaled); <br>                PostHangupCall(); <br>                goto EndReadThread; <br>            } <br>        } // End of switch(dwHandleSignaled). <br> <br>    } // End of while(TRUE) loop. <br> <br> <br>    // Time to clean up Read Thread. <br>  EndReadThread: <br> <br>    OutputDebugString("Read thread shutting down\n"); <br>    PurgeComm(g_hCommFile, PURGE_RXABORT | PURGE_RXCLEAR); <br>    CloseHandle(overlappedRead.hEvent); <br>    CloseHandle(overlappedCommEvent.hEvent); <br>    g_dwReadThreadID = 0; <br>    CloseHandle(g_hReadThread); <br>    g_hReadThread = 0; <br>    return 0; <br>} <br> <br> <br>// <br>//  FUNCTION: SetupReadEvent(LPOVERLAPPED, LPSTR, DWORD, LPDWORD) <br>// <br>//  PURPOSE: Sets up an overlapped ReadFile <br>// <br>//  PARAMETERS: <br>//    lpOverlappedRead      - address of overlapped structure to use. <br>//    lpszInputBuffer       - Buffer to place incoming bytes. <br>//    dwSizeofBuffer        - size of lpszInputBuffer. </code></pre>
<p>
</p>
<pre><code>//    lpnNumberOfBytesRead  - address of DWORD to place the number of read bytes. <br>// <br>//  RETURN VALUE: <br>//    TRUE if able to successfully setup the ReadFile.  FALSE if there <br>//    was a failure setting up or if the CloseEvent object was signaled. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a helper function for the Read Thread.  This <br>//    function sets up the overlapped ReadFile so that it can later <br>//    be waited on (or more appropriatly, so the event in the overlapped <br>//    structure can be waited upon).  If there is data waiting, it is <br>//    handled and the next ReadFile is initiated. <br>//    Another possible reason for returning FALSE is if the comm port <br>//    is closed by the service provider. <br>//     <br>// <br>// <br> <br>BOOL SetupReadEvent(LPOVERLAPPED lpOverlappedRead, <br>    LPSTR lpszInputBuffer, DWORD dwSizeofBuffer, <br>    LPDWORD lpnNumberOfBytesRead) <br>{ <br>    DWORD dwLastError; <br> <br>  StartSetupReadEvent: <br> <br>    // Make sure the CloseEvent hasn't been signaled yet. <br>    // Check is needed because this function is potentially recursive. <br>    if (WAIT_TIMEOUT != WaitForSingleObject(g_hCloseEvent,0)) <br>        return FALSE; <br>     <br>    // Start the overlapped ReadFile. <br>    if (ReadFile(g_hCommFile,  <br>            lpszInputBuffer, dwSizeofBuffer, <br>            lpnNumberOfBytesRead, lpOverlappedRead)) <br>    { <br>        // This would only happen if there was data waiting to be read. <br> <br>        OutputDebugString("Data waiting for ReadFile.\n"); <br>         <br>        // Handle the data. <br>        if (!HandleReadData(lpszInputBuffer, *lpnNumberOfBytesRead)) <br>        { <br>            return FALSE; <br>        } <br> <br>        // Start waiting for more data. <br>        goto StartSetupReadEvent; <br>    } <br> <br>    // ReadFile failed.  Expected because of overlapped I/O. <br>    dwLastError = GetLastError(); <br> <br> <br>    // LastError was ERROR_IO_PENDING, as expected. <br>    if (dwLastError == ERROR_IO_PENDING) <br>    { <br>        OutputDebugString("Waiting for data from comm connection.\n"); <br>        return TRUE; <br>    } <br> <br>    // Its possible for this error to occur if the  <br>    // service provider has closed the port.  Time to end. <br>    if (dwLastError == ERROR_INVALID_HANDLE) <br>    { <br>        OutputDebugString("ERROR_INVALID_HANDLE, " <br>            "Likely that the Service Provider has closed the port.\n"); <br>        return FALSE; <br>    } <br> <br>    // Unexpected error. No idea what could cause this to happen. <br>    OutputDebugLastError(dwLastError,"Unexpected ReadFile error: "); <br>     <br>    PostHangupCall(); <br>    return FALSE; <br>} <br>  <br>  <br>// <br>//  FUNCTION: HandleReadEvent(LPOVERLAPPED, LPSTR, DWORD, LPDWORD) <br>// <br>//  PURPOSE: Retrieves and handles data when there is data ready. <br>// <br>//  PARAMETERS: <br>//    lpOverlappedRead      - address of overlapped structure to use. <br>//    lpszInputBuffer       - Buffer to place incoming bytes. <br>//    dwSizeofBuffer        - size of lpszInputBuffer. <br>//    lpnNumberOfBytesRead  - address of DWORD to place the number of read bytes. <br>// <br>//  RETURN VALUE: <br>//    TRUE if able to successfully retrieve and handle the available data. <br>//    FALSE if unable to retrieve or handle the data. <br>// <br>//  COMMENTS: <br>// <br>//    This function is another helper function for the Read Thread.  This <br>//    is the function that is called when there is data available after <br>//    an overlapped ReadFile has been setup.  It retrieves the data and <br>//    handles it. <br>// <br>// <br> <br>BOOL HandleReadEvent(LPOVERLAPPED lpOverlappedRead, <br>    LPSTR lpszInputBuffer, DWORD dwSizeofBuffer, <br>    LPDWORD lpnNumberOfBytesRead) <br>{ <br>    DWORD dwLastError; <br> <br>    if (GetOverlappedResult(g_hCommFile, <br>            lpOverlappedRead, lpnNumberOfBytesRead, FALSE)) <br>    { <br>        return HandleReadData(lpszInputBuffer, *lpnNumberOfBytesRead); <br>    } <br> <br>    // Error in GetOverlappedResult; handle it. <br> <br>    dwLastError = GetLastError(); <br> <br>    // Its possible for this error to occur if the  <br>    // service provider has closed the port.  Time to end. <br>    if (dwLastError == ERROR_INVALID_HANDLE) <br>    { <br>        OutputDebugString("ERROR_INVALID_HANDLE, " <br>            "Likely that the Service Provider has closed the port.\n"); <br>        return FALSE; <br>    } <br> <br>    OutputDebugLastError(dwLastError,  <br>        "Unexpected GetOverlappedResult Read Error: "); <br> <br>    PostHangupCall(); <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleReadData(LPCSTR, DWORD) <br>// <br>//  PURPOSE: Deals with data after its been read from the comm file. <br>// <br>//  PARAMETERS: <br>//    lpszInputBuffer  - Buffer to place incoming bytes. <br>//    dwSizeofBuffer   - size of lpszInputBuffer. <br>// <br>//  RETURN VALUE: <br>//    TRUE if able to successfully handle the data. <br>//    FALSE if unable to allocate memory or handle the data. <br>// <br>//  COMMENTS: <br>// <br>//    This function is yet another helper function for the Read Thread. <br>//    It LocalAlloc()s a buffer, copies the new data to this buffer and <br>//    calls PostWriteToDisplayCtl to let the EditCtls module deal with <br>//    the data.  Its assumed that PostWriteToDisplayCtl posts the message <br>//    rather than dealing with it right away so that the Read Thread <br>//    is free to get right back to waiting for data.  Its also assumed <br>//    that the EditCtls module is responsible for LocalFree()ing the <br>//    pointer that is passed on. <br>// <br>// <br> <br>BOOL HandleReadData(LPCSTR lpszInputBuffer, DWORD dwSizeofBuffer) <br>{ <br>    // If we got data and didn't just time out empty... <br>    if (dwSizeofBuffer) <br>    { <br>        LPSTR lpszPostedBytes; <br> <br>        // Do something with the bytes read. <br>        OutputDebugString("Got something from Comm port!!!\n"); <br> <br>        lpszPostedBytes = LocalAlloc(LPTR,dwSizeofBuffer+1); <br>        if (lpszPostedBytes == NULL) <br>        { <br>            OutputDebugLastError(GetLastError(), "LocalAlloc: "); <br>            return FALSE; <br>        } <br> <br>        memcpy(lpszPostedBytes, lpszInputBuffer, dwSizeofBuffer); <br>        lpszPostedBytes[dwSizeofBuffer] = '\0'; <br> <br>        return PostWriteToDisplayCtl(lpszPostedBytes, dwSizeofBuffer); <br>    } <br> <br>} <br> <br> <br>// <br>//  FUNCTION: SetupCommEvent(LPOVERLAPPED, LPDWORD) <br>// <br>//  PURPOSE: Sets up the overlapped WaitCommEvent call. <br>// <br>//  PARAMETERS: <br>//    lpOverlappedCommEvent - Pointer to the overlapped structure to use. <br>//    lpfdwEvtMask          - Pointer to DWORD to received Event data. <br>// <br>//  RETURN VALUE: <br>//    TRUE if able to successfully setup the WaitCommEvent. <br>//    FALSE if unable to setup WaitCommEvent, unable to handle <br>//    an existing outstanding event or if the CloseEvent has been signaled. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a helper function for the Read Thread that sets up <br>//    the WaitCommEvent so we can deal with comm events (like Comm errors) <br>//    if they occur. <br>// <br>// <br> <br>BOOL SetupCommEvent(LPOVERLAPPED lpOverlappedCommEvent, <br>    LPDWORD lpfdwEvtMask) <br>{ <br>    DWORD dwLastError; <br> <br>  StartSetupCommEvent: <br> <br>    // Make sure the CloseEvent hasn't been signaled yet. <br>    // Check is needed because this function is potentially recursive. <br>    if (WAIT_TIMEOUT != WaitForSingleObject(g_hCloseEvent,0)) <br>        return FALSE; <br> <br>    // Start waiting for Comm Errors. <br>    if (WaitCommEvent(g_hCommFile, lpfdwEvtMask, lpOverlappedCommEvent)) <br>    { <br>        // This could happen if there was an error waiting on the <br>        // comm port.  Lets try and handle it. <br> <br>        OutputDebugString("Event (Error) waiting before WaitCommEvent.\n"); <br> <br>        if (!HandleCommEvent(NULL, lpfdwEvtMask, FALSE)) <br>            return FALSE; <br> <br>        // What could cause infinite recursion at this point? <br>        goto StartSetupCommEvent; <br>    } <br> <br>    // We expect ERROR_IO_PENDING returned from WaitCommEvent <br>    // because we are waiting with an overlapped structure. <br> <br>    dwLastError = GetLastError(); <br> <br>    // LastError was ERROR_IO_PENDING, as expected. <br>    if (dwLastError == ERROR_IO_PENDING) <br>    { <br>        OutputDebugString("Waiting for a CommEvent (Error) to occur.\n"); <br>        return TRUE; <br>    } <br> <br>    // Its possible for this error to occur if the  <br>    // service provider has closed the port.  Time to end. <br>    if (dwLastError == ERROR_INVALID_HANDLE) <br>    { <br>        OutputDebugString("ERROR_INVALID_HANDLE, " <br>            "Likely that the Service Provider has closed the port.\n"); <br>        return FALSE; <br>    } <br> <br>    // Unexpected error. No idea what could cause this to happen. <br>    OutputDebugLastError(dwLastError, "Unexpected WaitCommEvent error: "); <br>    return FALSE; <br>} <br> <br> <br>// <br>//  FUNCTION: HandleCommEvent(LPOVERLAPPED, LPDWORD, BOOL) <br>// <br>//  PURPOSE: Handle an outstanding Comm Event. <br>// <br>//  PARAMETERS: <br>//    lpOverlappedCommEvent - Pointer to the overlapped structure to use. <br>//    lpfdwEvtMask          - Pointer to DWORD to received Event data. <br>//     fRetrieveEvent       - Flag to signal if the event needs to be <br>//                            retrieved, or has already been retrieved. <br>// <br>//  RETURN VALUE: <br>//    TRUE if able to handle a Comm Event. <br>//    FALSE if unable to setup WaitCommEvent, unable to handle <br>//    an existing outstanding event or if the CloseEvent has been signaled. <br>// <br>//  COMMENTS: <br>// <br>//    This function is a helper function for the Read Thread that (if <br>//    fRetrieveEvent == TRUE) retrieves an outstanding CommEvent and <br>//    deals with it.  The only event that should occur is an EV_ERR event, <br>//    signalling that there has been an error on the comm port. <br>// <br>//    Normally, comm errors would not be put into the normal data stream <br>//    as this sample is demonstrating.  Putting it in a status bar would <br>//    be more appropriate for a real application. <br>// <br>// <br> <br>BOOL HandleCommEvent(LPOVERLAPPED lpOverlappedCommEvent,  <br>    LPDWORD lpfdwEvtMask, BOOL fRetrieveEvent) <br>{ <br>    DWORD dwDummy; <br>    LPSTR lpszOutput; <br>    char szError[128] = ""; <br>    DWORD dwErrors; <br>    DWORD nOutput; <br>    DWORD dwLastError; <br> <br> <br>    lpszOutput = LocalAlloc(LPTR,256); <br>    if (lpszOutput == NULL) <br>    { <br>        OutputDebugLastError(GetLastError(), "LocalAlloc: "); <br>        return FALSE; <br>    } <br> <br>    // If this fails, it could be because the file was closed (and I/O is <br>    // finished) or because the overlapped I/O is still in progress.  In <br>    // either case (or any others) its a bug and return FALSE. <br>    if (fRetrieveEvent) <br>        if (!GetOverlappedResult(g_hCommFile,  <br>                lpOverlappedCommEvent, &amp;dwDummy, FALSE)) <br>        { <br>            dwLastError = GetLastError(); <br> <br>            // Its possible for this error to occur if the  <br>            // service provider has closed the port.  Time to end. <br>            if (dwLastError == ERROR_INVALID_HANDLE) <br>            { <br>                OutputDebugString("ERROR_INVALID_HANDLE, " <br>                    "Likely that the Service Provider has closed the port.\n"); <br>                return FALSE; <br>            } <br> <br>            OutputDebugLastError(dwLastError, <br>                "Unexpected GetOverlappedResult for WaitCommEvent: "); <br>            return FALSE; <br>        } <br> <br>    // Was the event an error? <br>    if (*lpfdwEvtMask &amp; EV_ERR) <br>    { <br>        // Which error was it? <br>        if (!ClearCommError(g_hCommFile, &amp;dwErrors, NULL)) <br>        { <br>            dwLastError = GetLastError(); <br> <br>            // Its possible for this error to occur if the  <br>            // service provider has closed the port.  Time to end. <br>            if (dwLastError == ERROR_INVALID_HANDLE) <br>            { <br>                OutputDebugString("ERROR_INVALID_HANDLE, " <br>                    "Likely that the Service Provider has closed the port.\n"); <br>                return FALSE; <br>            } <br> <br>            OutputDebugLastError(GetLastError(),"ClearCommError: "); <br>            return FALSE; <br>        } <br> <br>        // Its possible that multiple errors occured and were handled <br>        // in the last ClearCommError.  Because all errors were signaled <br>        // individually, but cleared all at once, pending comm events  <br>        // can yield EV_ERR while dwErrors equals 0.  Ignore this event. <br>        if (dwErrors == 0) <br>        { <br>            strcat(szError, "NULL Error"); <br>        } <br>        <br>        if (dwErrors &amp; CE_FRAME) <br>        { <br>            if (szError[0]) <br>                strcat(szError," and "); <br> <br>            strcat(szError,"CE_FRAME"); <br>        } <br> <br>        if (dwErrors &amp; CE_OVERRUN) <br>        { <br>            if (szError[0]) <br>                strcat(szError," and "); <br> <br>            strcat(szError,"CE_OVERRUN"); <br>        } <br> <br>        if (dwErrors &amp; CE_RXPARITY) <br>        { <br>            if (szError[0]) <br>                strcat(szError," and "); <br> <br>            strcat(szError,"CE_RXPARITY"); <br>        } <br> <br>        if (dwErrors &amp; ~ (CE_FRAME | CE_OVERRUN | CE_RXPARITY)) <br>        { <br>            if (szError[0]) <br>                strcat(szError," and "); <br> <br>            strcat(szError,"EV_ERR Unknown EvtMask"); <br>        } <br> <br> <br>        nOutput = wsprintf(lpszOutput, <br>            "Comm Event: '%s', EvtMask = '%lx'\n", <br>            szError, dwErrors); <br> <br>        PostWriteToDisplayCtl(lpszOutput, nOutput); <br>        return TRUE; <br> <br>    } <br> <br>    // Should not have gotten here.  Only interested in ERR conditions. <br> <br>    OutputDebugPrintf("Unexpected comm event %lx",*lpfdwEvtMask); <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
