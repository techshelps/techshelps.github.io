<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTGOING.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5208"></a>OUTGOING.CPP</h2>
<pre><code>#define UNICODE <br>#include &lt;windows.h&gt; <br>#include &lt;tapi3.h&gt; <br>#include "resource.h" <br> <br>////////////////////////////////////////////////////////// <br>// T3OUT.EXE <br>// <br>// Example of making an outgoing call with TAPI 3.0 <br>// <br>// This application will allow a user to make a call <br>// by using TAPI 3.0.  The application will simply look <br>// for the first TAPI line that support Audio, and can <br>// dial a phone number.  It will then use that line to <br>// make calls. <br>// <br>// This application does not handle incoming calls, and <br>// does not process incoming messages. <br>// <br>////////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////////// <br>// Constants <br>////////////////////////////////////////////////////////// <br> <br>const DWORD ADDRESSLENGTH   = 128; <br>const DWORD MAXTERMINALS    = 5; <br> <br>const WCHAR * const gszTapi30           = L"TAPI 3.0 Outgoing Call Sample"; <br> <br>const WCHAR * const gszConferenceName   = L"Conference Name"; <br>const WCHAR * const gszEmailName        = L"Email Name"; <br>const WCHAR * const gszMachineName      = L"Machine Name"; <br>const WCHAR * const gszPhoneNumber      = L"Phone Number"; <br>const WCHAR * const gszIPAddress        = L"IP Address"; <br> <br>////////////////////////////////////////////////////////// <br>// GLOBALS <br>////////////////////////////////////////////////////////// <br>HINSTANCE               ghInst; <br>HWND                    ghDlg = NULL; <br>ITTAPI *                gpTapi; <br>ITAddress *             gpAddress; <br>ITBasicCallControl *    gpCall; <br> <br>BSTR                    gbstrAudioIn; <br>BSTR                    gbstrAudioOut; <br>BSTR                    gbstrVideoIn; <br>BSTR                    gbstrVideoOut; <br> <br> <br>////////////////////////////////////////////////////////// <br>// PROTOTYPES <br>////////////////////////////////////////////////////////// <br>BOOL <br>CALLBACK <br>MainDialogProc( <br>               HWND hDlg, <br>               UINT uMsg, <br>               WPARAM wParam, <br>               LPARAM lParam <br>              ); <br> <br>HRESULT <br>FindAnAddress( <br>              DWORD dwAddressType <br>             ); <br> <br>HRESULT <br>GetMediaTerminal( <br>                 BSTR bstrMedia, <br>                 ITMediaTerminal ** ppMediaTerminal <br>                ); <br> <br>HRESULT <br>GetVideoInMediaTerminal( <br>                 ITMediaTerminal ** ppMediaTerminal <br>                ); <br> <br>HRESULT <br>MakeTheCall( <br>            DWORD dwAddressType, <br>            PWCHAR szAddressToCall <br>           ); <br> <br>HRESULT <br>DisconnectTheCall(); <br> <br>void <br>DoMessage( <br>          LPWSTR pszMessage <br>         ); <br> <br>HRESULT <br>InitializeTapi(); <br> <br>void <br>ShutdownTapi(); <br> <br>void <br>EnableButton( <br>             HWND hDlg, <br>             int ID <br>            ); <br>void <br>DisableButton( <br>              HWND hDlg, <br>              int ID <br>             ); <br> <br>////////////////////////////////////////////////////////// <br>// WinMain <br>////////////////////////////////////////////////////////// <br>int <br>WINAPI <br>WinMain( <br>        HINSTANCE hInst, <br>        HINSTANCE hPrevInst, <br>        LPSTR lpCmdLine, <br>        int nCmdShow <br>       ) <br>{ <br>    ghInst = hInst; <br> <br>     <br>    // need to coinit <br>    if (!SUCCEEDED(CoInitialize(NULL))) <br>    { <br>        return 0; <br>    } <br> <br>    if (S_OK != InitializeTapi()) <br>    { <br>        return 0; <br>    } <br>     <br>    // everything is initialized, so <br>    // start the main dialog box <br>    DialogBox( <br>              ghInst, <br>              MAKEINTRESOURCE(IDD_MAINDLG), <br>              NULL, <br>              MainDialogProc <br>             ); <br> <br> <br>    ShutdownTapi(); <br>     <br>    CoUninitialize(); <br> <br>    return 1; <br>} <br> <br> <br>////////////////////////////////////////////////////////////// <br>// InitializeTapi <br>// <br>// Various initializations <br>/////////////////////////////////////////////////////////////// <br>HRESULT <br>InitializeTapi() <br>{ <br>    HRESULT         hr; <br>    LPWSTR          psz; <br> <br>     <br>    // cocreate the TAPI object <br>    hr = CoCreateInstance( <br>                          CLSID_TAPI, <br>                          NULL, <br>                          CLSCTX_INPROC_SERVER, <br>                          IID_ITTAPI, <br>                          (LPVOID *)&amp;gpTapi <br>                         ); <br> <br>    if (hr != S_OK) <br>    { <br>        DoMessage(L"CoCreateInstance on TAPI failed"); <br>        return hr; <br>    } <br> <br>    // call initialize.  this must be called before <br>    // any other tapi functions are called. <br>    hr = gpTapi-&gt;Initialize(); <br> <br>    if (S_OK != hr) <br>    { <br>        DoMessage(L"TAPI failed to initialize"); <br> <br>        gpTapi-&gt;Release(); <br>        gpTapi = NULL; <br>         <br>        return hr; <br>    } <br> <br> <br>    // convert the TAPIMEDIATYPEs to BSTRs for <br>    // convenience throughout the program <br>    StringFromIID( <br>                  TAPIMEDIATYPE_AudioIn, <br>                  &amp;psz <br>                 ); <br> <br>    gbstrAudioIn = SysAllocString( psz ); <br> <br>    CoTaskMemFree( psz ); <br> <br>    StringFromIID( <br>                  TAPIMEDIATYPE_AudioOut, <br>                  &amp;psz <br>                 ); <br> <br>    gbstrAudioOut = SysAllocString( psz ); <br> <br>    CoTaskMemFree( psz ); <br> <br>    StringFromIID( <br>                  TAPIMEDIATYPE_VideoIn, <br>                  &amp;psz <br>                 ); <br> <br>    gbstrVideoIn = SysAllocString( psz ); <br> <br>    CoTaskMemFree( psz ); <br> <br>    StringFromIID( <br>                  TAPIMEDIATYPE_VideoOut, <br>                  &amp;psz <br>                 ); <br> <br>    gbstrVideoOut = SysAllocString( psz ); <br> <br>    CoTaskMemFree( psz ); <br> <br>    return S_OK; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////// <br>// ShutdownTapi <br>/////////////////////////////////////////////////////////////// <br>void <br>ShutdownTapi() <br>{ <br>    // if there is still a call, <br>    // release it <br>    if (NULL != gpCall) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>    } <br> <br>    // if we have an address object <br>    // release it <br>    if (NULL != gpAddress) <br>    { <br>        gpAddress-&gt;Release(); <br>    } <br>     <br>    // release main object. <br>    if (NULL != gpTapi) <br>    { <br>        gpTapi-&gt;Shutdown(); <br>        gpTapi-&gt;Release(); <br>    } <br> <br>    SysFreeString( gbstrAudioIn ); <br>    SysFreeString( gbstrAudioOut ); <br>    SysFreeString( gbstrVideoIn ); <br>    SysFreeString( gbstrVideoOut ); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// InitAddressTypeComboBox <br>// <br>// Put address type string in the combo box <br>// and save the addresstype with the string <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>void <br>InitAddressTypeComboBox( <br>    HWND hComboBox <br>    ) <br>{ <br>    int i; <br> <br>    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszConferenceName ); <br>     <br>    SendMessage( <br>                hComboBox, <br>                CB_SETITEMDATA ,  <br>                i, <br>                (long)T3_ADDRESSTYPE_CONFERENCENAME <br>               ); <br> <br>     <br>    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszEmailName ); <br>     <br>    SendMessage( <br>                hComboBox, <br>                CB_SETITEMDATA ,  <br>                i, <br>                (long)T3_ADDRESSTYPE_EMAILNAME <br>               ); <br> <br>     <br>    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszMachineName ); <br>     <br>    SendMessage( <br>                hComboBox, <br>                CB_SETITEMDATA ,  <br>                i, <br>                (long)T3_ADDRESSTYPE_DOMAINNAME <br>               ); <br> <br>     <br>    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszPhoneNumber ); <br>     <br>    SendMessage( <br>                hComboBox, <br>                CB_SETITEMDATA ,  <br>                i, <br>                (long)T3_ADDRESSTYPE_PHONENUMBER <br>               ); <br> <br>     <br>    SendMessage( hComboBox, CB_SETCURSEL, i, 0 ); <br> <br>    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszIPAddress ); <br>     <br>    SendMessage( <br>                hComboBox, <br>                CB_SETITEMDATA ,  <br>                i, <br>                (long)T3_ADDRESSTYPE_IPADDRESS <br>               ); <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// MainDlgProc <br>/////////////////////////////////////////////////////////////////////////// <br>BOOL <br>CALLBACK <br>MainDialogProc( <br>               HWND hDlg, <br>               UINT uMsg, <br>               WPARAM wParam, <br>               LPARAM lParam <br>              ) <br>{ <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>            HWND hComboBox; <br> <br>             <br>            // set up dialog <br>            ghDlg = hDlg; <br>             <br>            EnableButton( hDlg, IDOK ); <br>            DisableButton( hDlg, IDC_DISCONNECT ); <br> <br>            hComboBox = GetDlgItem( hDlg, IDC_ADDRESSTYPE ); <br> <br>            InitAddressTypeComboBox(hComboBox); <br> <br>            SetFocus( hComboBox ); <br> <br>            return 0; <br>        } <br> <br>        case WM_COMMAND: <br>        { <br>            if ( LOWORD(wParam) == IDCANCEL ) <br>            { <br>                // quit <br>                EndDialog( hDlg, 0 ); <br> <br>                return 1; <br>            } <br> <br>            // dial request <br>            if ( LOWORD(wParam) == IDOK ) <br>            { <br>                HWND hComboBox; <br>                DWORD dwIndex; <br>                DWORD dwAddressType; <br>                WCHAR szAddressToCall[ADDRESSLENGTH]; <br> <br>                 <br>                // get the address type the user selected. <br>                hComboBox = GetDlgItem( hDlg, IDC_ADDRESSTYPE ); <br>                dwIndex = SendMessage( hComboBox, CB_GETCURSEL, 0, 0 ); <br> <br>                dwAddressType = SendMessage(  <br>                                             hComboBox, <br>                                             CB_GETITEMDATA, <br>                                             dwIndex, <br>                                             0 <br>                                           ); <br> <br>                // get the address the user wants to call <br>                GetDlgItemText( <br>                               hDlg, <br>                               IDC_ADDRESS, <br>                               szAddressToCall, <br>                               ADDRESSLENGTH <br>                              ); <br> <br>                // make the call <br>                if ( S_OK == MakeTheCall(dwAddressType, szAddressToCall) ) <br>                { <br>                    EnableButton( hDlg, IDC_DISCONNECT ); <br>                    DisableButton( hDlg, IDOK ); <br>                } <br>                else <br>                { <br>                    DoMessage(L"The call failed to connect"); <br>                } <br> <br>                return 1; <br>            } <br> <br>            // disconnect requestion <br>            if ( LOWORD( wParam ) == IDC_DISCONNECT ) <br>            { <br>                // disconnect <br>                if (S_OK == DisconnectTheCall()) <br>                { <br>                    EnableButton( hDlg, IDOK ); <br>                    DisableButton( hDlg, IDC_DISCONNECT ); <br>                } <br>                else <br>                { <br>                    DoMessage(L"The call failed to disconnect"); <br>                } <br> <br>                return 1; <br>            } <br> <br>            return 0; <br>        } <br>        default: <br> <br>            return 0; <br>    } <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////////// <br>// FindAnAddress <br>// <br>// Finds an address object that this application will use to make calls on. <br>// <br>// This function finds an address that supports the addresstype passed <br>// in, as well as the audioin and audioout media types. <br>// <br>// Return Value <br>//          S_OK if it finds an address <br>//          S_FALSE if it does not find an address <br>//////////////////////////////////////////////////////////////////////// <br>HRESULT <br>FindAnAddress( <br>              DWORD dwAddressType <br>             ) <br>{ <br>    HRESULT             hr = S_OK; <br>    BOOL                bFoundAddress = FALSE; <br>    IEnumAddress *      pEnumAddress; <br>    ITAddress *         pAddress; <br>    IEnumAddressType *  pEnumAddressTypes; <br>    DWORD               dwType; <br> <br>    // if we have an address object <br>    // release it <br>    if (NULL != gpAddress) <br>    { <br>        gpAddress-&gt;Release(); <br>        gpAddress = NULL; <br>    } <br> <br>    // enumerate the addresses <br>    hr = gpTapi-&gt;_EnumerateAddresses( &amp;pEnumAddress ); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    while ( !bFoundAddress ) <br>    { <br>        // get the next address <br>        hr = pEnumAddress-&gt;Next( 1, &amp;pAddress, NULL ); <br> <br>        if (S_OK != hr) <br>        { <br>            break; <br>        } <br> <br>        // enumerate the address types that <br>        // this address supports <br>        hr = pAddress-&gt;_EnumerateAddressType( &amp;pEnumAddressTypes ); <br> <br>        if (S_OK != hr) <br>        { <br>            pAddress-&gt;Release(); <br>         <br>            continue; <br>        } <br> <br>        while (TRUE) <br>        { <br>            ITMediaSupport * pMediaSupport; <br>            VARIANT_BOOL     bSupport; <br>             <br>            // get the next address type <br>            hr = pEnumAddressTypes-&gt;Next( 1, &amp;dwType, NULL ); <br> <br>            if (S_OK != hr) <br>            { <br>                break; <br>            } <br> <br>            // is the type we are looking for? <br>            if ( dwAddressType == dwType ) <br>            { <br>                // yes <br>                pAddress-&gt;QueryInterface( IID_ITMediaSupport, (void **)&amp;pMediaSupport ); <br> <br>                // does it support AudioIn? <br>                pMediaSupport-&gt;QueryMediaType( <br>                                              gbstrAudioIn, <br>                                              &amp;bSupport <br>                                             ); <br> <br>                if (bSupport) <br>                { <br>                    // does it also support AudioOut? <br>                    pMediaSupport-&gt;QueryMediaType( <br>                        gbstrAudioOut, <br>                        &amp;bSupport <br>                        ); <br> <br>                    if (bSupport) <br>                    { <br>                        // save <br>                        pMediaSupport-&gt;Release(); <br>                         <br>                        gpAddress = pAddress; <br>                        gpAddress-&gt;AddRef(); <br> <br>                        bFoundAddress = TRUE; <br>                        break; <br>                    } <br>                } <br> <br>                pMediaSupport-&gt;Release(); <br>            } <br>        } <br> <br>        pAddress-&gt;Release(); <br>        pEnumAddressTypes-&gt;Release(); <br>    } <br> <br>    pEnumAddress-&gt;Release(); <br>     <br>    if (!bFoundAddress) <br>    { <br>        return S_FALSE; <br>    } <br> <br>    return S_OK; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// CreateMediaTerminals <br>// <br>// Create audioin and audioout terminals. <br>// <br>// If the address also supports video, create <br>// Videoin and videoout terminals, too. <br>// <br>// This function assumes that ppMediaTerminals has a size no less than four. <br>///////////////////////////////////////////////////////////////// <br>HRESULT <br>CreateMediaTerminals( <br>                     ITMediaTerminal ** ppMediaTerminals, <br>                     PLONG pNumMediaTerminals <br>                    ) <br>{ <br>    int count = 0; <br>    HRESULT hr; <br> <br>    // get the mediaterminal for audioin <br>    hr = GetMediaTerminal( <br>                          gbstrAudioIn, <br>                          &amp;ppMediaTerminals[count] <br>                         ); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br>     <br>    count ++; <br> <br>    // get the mediaterminal for audioout <br>    hr = GetMediaTerminal( <br>                          gbstrAudioOut, <br>                          &amp;ppMediaTerminals[count] <br>                         ); <br> <br>    if (S_OK != hr) <br>    { <br>        ppMediaTerminals[0]-&gt;Release(); <br>        return hr; <br>    } <br> <br>    count ++; <br>     <br>    // Find out if the address supports video. <br>    ITMediaSupport * pMediaSupport; <br>    VARIANT_BOOL     bSupport; <br>             <br>    gpAddress-&gt;QueryInterface( IID_ITMediaSupport, (void **)&amp;pMediaSupport ); <br> <br>    // does it support VideoIn? <br>    pMediaSupport-&gt;QueryMediaType( <br>                                  gbstrVideoIn, <br>                                  &amp;bSupport <br>                                 ); <br> <br>    if (bSupport) <br>    { <br>        // get the mediaterminal for VideoIn <br>        hr = GetVideoInMediaTerminal( <br>                                  &amp;ppMediaTerminals[count] <br>                                 ); <br> <br>        if (S_OK == hr) <br>        { <br>            count ++; <br>        } <br> <br>        // does it also support VideoOut? <br>        pMediaSupport-&gt;QueryMediaType( <br>            gbstrVideoOut, <br>            &amp;bSupport <br>            ); <br> <br>        if (bSupport) <br>        { <br>            // get the mediaterminal for Videoout <br>            hr = GetMediaTerminal( <br>                                  gbstrVideoOut, <br>                                  &amp;ppMediaTerminals[count] <br>                                 ); <br>     <br>            if (S_OK == hr) <br>            { <br>                count ++; <br>            } <br>        } <br>    } <br> <br>    pMediaSupport-&gt;Release(); <br>     <br>    *pNumMediaTerminals = count; <br> <br>    return S_OK; <br>} <br> <br>///////////////////////////////////////////////////////////////// <br>// CreateMediaTerminalSafeArray <br>// <br>///////////////////////////////////////////////////////////////// <br>SAFEARRAY * <br>CreateMediaTerminalSafeArray( <br>                             ITMediaTerminal ** ppMediaTerminals, <br>                             LONG nNumMediaTerminals <br>                            ) <br>{ <br>    SAFEARRAY *             psa; <br>    SAFEARRAYBOUND          sabound[1]; <br> <br>    // create a safearray with two elements <br>    // to pass the mediaterminals to tapi <br>    sabound[0].lLbound = 0; <br>    sabound[0].cElements = nNumMediaTerminals; <br> <br>    psa = SafeArrayCreate( <br>                          VT_UNKNOWN, <br>                          1, <br>                          sabound <br>                         ); <br> <br>    if (NULL != psa) <br>    { <br>        // save them in the safearray <br>        for (long i = 0; i &lt; nNumMediaTerminals; i ++) <br>        { <br>            SafeArrayPutElement( <br>                            psa, <br>                            &amp;i, <br>                            ppMediaTerminals[i] <br>                           ); <br>        } <br>    } <br>    return psa; <br>} <br> <br>///////////////////////////////////////////////////////////////// <br>// ReleaseMediaTerminals <br>// <br>///////////////////////////////////////////////////////////////// <br>void <br>ReleaseMediaTerminals( <br>                      ITMediaTerminal ** ppMediaTerminals, <br>                      LONG nNumMediaTerminals <br>                     ) <br>{ <br>    for (long i = 0; i &lt; nNumMediaTerminals; i ++) <br>    { <br>        if (ppMediaTerminals[i]) <br>        { <br>            ppMediaTerminals[i]-&gt;Release(); <br>        } <br>    } <br>} <br> <br>///////////////////////////////////////////////////////////////// <br>// MakeTheCall <br>// <br>// Sets up and makes a call <br>///////////////////////////////////////////////////////////////// <br>HRESULT <br>MakeTheCall( <br>            DWORD dwAddressType, <br>            PWCHAR szAddressToCall <br>           ) <br>{ <br>    HRESULT                 hr = S_OK; <br>    ITMediaTerminal *       ppMediaTerminals[MAXTERMINALS]; <br>    long                    nNumMediaTerminals = MAXTERMINALS; <br>    SAFEARRAY *             psa; <br>    VARIANT                 var; <br>    BSTR                    bstrAddressToCall; <br> <br>    // find an address object that <br>    // we will use to make calls on <br>    hr = FindAnAddress(dwAddressType); <br> <br>    if (S_OK != hr) <br>    { <br>        DoMessage(L"Could not find an address to make a phone call on"); <br> <br>        return hr; <br>    } <br> <br>    bstrAddressToCall = SysAllocString( szAddressToCall ); <br> <br>    hr = gpAddress-&gt;CreateCall( bstrAddressToCall, &amp;gpCall ); <br> <br>    SysFreeString ( bstrAddressToCall ); <br>     <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br>                                <br>    hr = CreateMediaTerminals(ppMediaTerminals, &amp;nNumMediaTerminals); <br> <br>    if (S_OK != hr) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>        return hr; <br>    } <br> <br>    psa = CreateMediaTerminalSafeArray(ppMediaTerminals, nNumMediaTerminals); <br> <br>    if (S_OK != hr) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>        ReleaseMediaTerminals(ppMediaTerminals, nNumMediaTerminals); <br>        return hr; <br>    } <br> <br> <br>    // put the safearray in a variant <br>    VariantInit(&amp;var); <br>    var.vt = VT_ARRAY; <br>    var.parray = psa; <br> <br>    // call SelectMediaTerminals <br>    hr = gpCall-&gt;SelectMediaTerminals( var ); <br> <br>    ReleaseMediaTerminals(ppMediaTerminals, nNumMediaTerminals); <br> <br>    SafeArrayDestroy( psa ); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    // We're now ready to call connect. <br>    // <br>    // the TRUE parameter indicates that this <br>    // call is sychronous - that is, it won't <br>    // return until the call is in the connected <br>    // state (or fails to connect) <br>    // Since this is called in the UI thread, <br>    // this means that the app will appear <br>    // to hang until this function returns. <br>    // Some TAPI service providers may take a long <br>    // time for a call to reach the connected state. <br>    hr = gpCall-&gt;Connect( TRUE ); <br> <br>    if (S_OK != hr) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>        return hr; <br>    } <br>     <br>    return hr; <br>} <br> <br> <br>///////////////////////////////////////////////////////// <br>// GetMediaTerminal <br>// <br>// Creates a MediaTerminal for the bstrMediaType passed <br>// in, using the default terminal for the bstrMediaType <br>// <br>///////////////////////////////////////////////////////// <br>HRESULT <br>GetMediaTerminal( <br>                 BSTR bstrMediaType, <br>                 ITMediaTerminal ** ppMediaTerminal <br>                ) <br>{ <br>    HRESULT             hr = S_OK; <br>    ITTerminalSupport * pTerminalSupport; <br>    ITTerminal *        pTerminal; <br> <br>    // get the terminal support interface <br>    gpAddress-&gt;QueryInterface( IID_ITTerminalSupport, (void **)&amp;pTerminalSupport ); <br>     <br>    // get the default terminal for MediaType <br>    hr = pTerminalSupport-&gt;GetDefaultTerminal( <br>                                              bstrMediaType, <br>                                              &amp;pTerminal <br>                                             ); <br> <br> <br>    pTerminalSupport-&gt;Release(); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    // Create a media terminal for MediaType <br>    // Use the default terminal we just got <br>    hr = gpTapi-&gt;CreateMediaTerminal( <br>                                     bstrMediaType, <br>                                     pTerminal, <br>                                     ppMediaTerminal <br>                                    ); <br> <br>    pTerminal-&gt;Release(); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    return S_OK; <br> <br>} <br> <br>///////////////////////////////////////////////////////// <br>// GetVideoInMediaTerminal <br>// <br>// Creates a MediaTerminal for the VideoIn mediatype  <br>// This is a dynamic terminal type. <br>// <br>///////////////////////////////////////////////////////// <br>HRESULT <br>GetVideoInMediaTerminal( <br>                 ITMediaTerminal ** ppMediaTerminal <br>                ) <br>{ <br>    HRESULT             hr = S_OK; <br>    ITTerminalSupport * pTerminalSupport; <br>    ITTerminal *        pTerminal; <br> <br>    // get the terminal support interface <br>    gpAddress-&gt;QueryInterface( IID_ITTerminalSupport, (void **)&amp;pTerminalSupport ); <br>     <br>    BSTR bstrTerminalClass; <br>    LPOLESTR lpTerminalClass; <br> <br>    StringFromIID( <br>                CLSID_VideoWindowTerm, <br>                &amp;lpTerminalClass <br>                ); <br> <br>    bstrTerminalClass = SysAllocString ( lpTerminalClass ); <br> <br>    CoTaskMemFree( lpTerminalClass ); <br> <br>    hr = pTerminalSupport-&gt;CreateTerminal( <br>        bstrTerminalClass, <br>        &amp;pTerminal <br>        ); <br> <br>    SysFreeString( bstrTerminalClass ); <br>    pTerminalSupport-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>    { <br>        return hr; <br>    } <br> <br>    // Create a media terminal for MediaType <br>    // Use the default terminal we just got <br>    hr = gpTapi-&gt;CreateMediaTerminal( <br>                                     gbstrVideoIn, <br>                                     pTerminal, <br>                                     ppMediaTerminal <br>                                    ); <br> <br>    pTerminal-&gt;Release(); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    return S_OK; <br> <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////// <br>// DisconnectTheCall <br>// <br>// Disconnects the call <br>////////////////////////////////////////////////////////////////////// <br>HRESULT <br>DisconnectTheCall() <br>{ <br>    HRESULT         hr = S_OK; <br> <br>    if (NULL != gpCall) <br>    { <br>        hr = gpCall-&gt;Disconnect( DC_NORMAL ); <br> <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>     <br>        return hr; <br>    } <br> <br>    return S_FALSE; <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>// <br>// HELPER FUNCTIONS <br>// <br>/////////////////////////////////////////////////////////////////// <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>// DoMessage <br>/////////////////////////////////////////////////////////////////// <br>void <br>DoMessage( <br>          LPWSTR pszMessage <br>         ) <br>{ <br>    MessageBox( <br>               ghDlg, <br>               pszMessage, <br>               gszTapi30, <br>               MB_OK <br>              ); <br>} <br> <br>/////////////////////////////////////////////////////////////// <br>// EnableButton <br>// <br>// Enable, make default, and setfocus to a button <br>/////////////////////////////////////////////////////////////// <br>void <br>EnableButton( <br>             HWND hDlg, <br>             int ID <br>            ) <br>{ <br>    SendDlgItemMessage( <br>                       hDlg, <br>                       ID, <br>                       BM_SETSTYLE, <br>                       BS_DEFPUSHBUTTON, <br>                       0 <br>                      ); <br>    EnableWindow( <br>                 GetDlgItem( hDlg, ID ), <br>                 TRUE <br>                ); <br>    SetFocus( <br>             GetDlgItem( hDlg, ID ) <br>            ); <br>} <br> <br>////////////////////////////////////////////////////////////// <br>// DisableButton <br>// <br>// Disable a button <br>////////////////////////////////////////////////////////////// <br>void <br>DisableButton( <br>              HWND hDlg, <br>              int ID <br>             ) <br>{ <br>    SendDlgItemMessage( <br>                       hDlg, <br>                       ID, <br>                       BM_SETSTYLE, <br>                       BS_PUSHBUTTON, <br>                       0 <br>                      ); <br>    EnableWindow( <br>                 GetDlgItem( hDlg, ID ), <br>                 FALSE <br>                ); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
