<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INCOMING.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5204"></a>INCOMING.CPP</h2>
<pre><code>#define UNICODE <br>#include &lt;list&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;tapi3.h&gt; <br>#include "callnot.h" <br>#include "resource.h" <br> <br>////////////////////////////////////////////////////////// <br>// T3IN.EXE <br>// <br>// Sample application that handling incoming TAPI calls. <br>// In order to receive incoming calls, the application must <br>// implement and register the outgoing ITCallNotification <br>// interface. <br>// <br>// This application will register to recieve calls on <br>// all addresses that support at least audioin and audioout. <br>// <br>// NOTE:  This application is limited to working with one call at <br>// at time, and will not work correctly if multiple calls <br>// are present at the same time. <br>////////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////////// <br>// constants <br>////////////////////////////////////////////////////////// <br> <br>const DWORD MAXTERMINALS    = 5; <br> <br>////////////////////////////////////////////////////////// <br>// TYPEDEFS <br>////////////////////////////////////////////////////////// <br> <br>using namespace std; <br>typedef list&lt;CCallNotification *&gt; CCallNotificationPtrList; <br> <br> <br>////////////////////////////////////////////////////////// <br>// GLOBALS <br>////////////////////////////////////////////////////////// <br> <br>HINSTANCE               ghInst; <br>ITTAPI *                gpTapi; <br>ITBasicCallControl *    gpCall; <br>HWND                    ghDlg = NULL; <br> <br>BSTR                    gbstrAudioIn; <br>BSTR                    gbstrAudioOut; <br>BSTR                    gbstrVideoIn; <br>BSTR                    gbstrVideoOut; <br> <br>WCHAR gszTapi30[] = L"TAPI 3.0 Incoming Call Sample"; <br> <br>// list of outgoing interface objects we have registered <br>CCallNotificationPtrList gpCallNotificationList; <br> <br>////////////////////////////////////////////////////////// <br>// PROTOTYPES <br>////////////////////////////////////////////////////////// <br>BOOL <br>CALLBACK <br>MainDialogProc( <br>               HWND hDlg, <br>               UINT uMsg, <br>               WPARAM wParam, <br>               LPARAM lParam <br>              ); <br> <br>HRESULT <br>GetMediaTerminal( <br>                 ITAddress *, <br>                 BSTR bstrMedia, <br>                 ITMediaTerminal ** ppMediaTerminal <br>                ); <br>HRESULT <br>ListenOnAddresses(); <br> <br>HRESULT <br>ListenOnThisAddress( <br>                    ITAddress * pAddress <br>                   ); <br> <br>HRESULT <br>AnswerTheCall(); <br> <br>HRESULT <br>DisconnectTheCall(); <br> <br>void <br>ReleaseTheCall(); <br> <br>void <br>DoMessage( <br>          LPWSTR pszMessage <br>         ); <br> <br>void <br>SetStatusMessage( <br>                 LPWSTR pszMessage <br>                ); <br> <br>HRESULT <br>InitializeTapi(); <br> <br>void <br>ShutdownTapi(); <br> <br>void <br>EnableButton( <br>             int ID <br>            ); <br>void <br>DisableButton( <br>              int ID <br>             ); <br> <br>////////////////////////////////////////////////////////// <br>// <br>//              FUNCTIONS <br>// <br>////////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////////// <br>// WinMain <br>////////////////////////////////////////////////////////// <br>int <br>WINAPI <br>WinMain( <br>        HINSTANCE hInst, <br>        HINSTANCE hPrevInst, <br>        LPSTR lpCmdLine, <br>        int nCmdShow <br>       ) <br>{ <br>    ghInst = hInst; <br> <br>     <br>    // need to coinit <br>    if (!SUCCEEDED(CoInitialize(NULL))) <br>    { <br>        return 0; <br>    } <br> <br>    // do all tapi initialization <br>    if (S_OK != InitializeTapi()) <br>    { <br>        return 0; <br>    } <br>     <br>    // everything is initialized, so <br>    // start the main dialog box <br>    DialogBox( <br>              ghInst, <br>              MAKEINTRESOURCE(IDD_MAINDLG), <br>              NULL, <br>              MainDialogProc <br>             ); <br> <br> <br>    // clean up <br>    ShutdownTapi(); <br>     <br>    CoUninitialize(); <br> <br>    return 1; <br>} <br> <br> <br>////////////////////////////////////////////////////////////// <br>// InitializeTapi <br>// <br>// Various initializations <br>/////////////////////////////////////////////////////////////// <br>HRESULT <br>InitializeTapi() <br>{ <br>    HRESULT         hr; <br>    LPWSTR          psz; <br> <br>     <br>    // cocreate the TAPI object <br>    hr = CoCreateInstance( <br>                          CLSID_TAPI, <br>                          NULL, <br>                          CLSCTX_INPROC_SERVER, <br>                          IID_ITTAPI, <br>                          (LPVOID *)&amp;gpTapi <br>                         ); <br> <br>    if (hr != S_OK) <br>    { <br>        DoMessage(L"CoCreateInstance on TAPI failed"); <br>        return hr; <br>    } <br> <br>    // call initialize.  this must be called before <br>    // any other tapi functions are called. <br>    hr = gpTapi-&gt;Initialize(); <br> <br>    if (S_OK != hr) <br>    { <br>        DoMessage(L"TAPI failed to initialize"); <br> <br>        gpTapi-&gt;Release(); <br>        gpTapi = NULL; <br>         <br>        return hr; <br>    } <br> <br> <br>    // convert the TAPIMEDIATYPEs to BSTRs for <br>    // convenience throughout the program <br> <br>    StringFromIID( TAPIMEDIATYPE_AudioIn, &amp;psz ); <br>    gbstrAudioIn = SysAllocString( psz ); <br>    CoTaskMemFree( psz ); <br> <br>    StringFromIID( TAPIMEDIATYPE_AudioOut, &amp;psz ); <br>    gbstrAudioOut = SysAllocString( psz ); <br>    CoTaskMemFree( psz ); <br> <br>    StringFromIID( TAPIMEDIATYPE_VideoIn, &amp;psz ); <br>    gbstrVideoIn = SysAllocString( psz ); <br>    CoTaskMemFree( psz ); <br> <br>    StringFromIID( TAPIMEDIATYPE_VideoOut, &amp;psz ); <br>    gbstrVideoOut = SysAllocString( psz ); <br>    CoTaskMemFree( psz ); <br> <br>    // find all address objects that <br>    // we will use to listen for calls on <br>    hr = ListenOnAddresses(); <br> <br>    if (S_OK != hr) <br>    { <br>        DoMessage(L"Could not find any addresses to listen on"); <br> <br>        gpTapi-&gt;Release(); <br>        gpTapi = NULL; <br> <br>        return hr; <br>    } <br> <br>    return S_OK; <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////// <br>// ShutdownTapi <br>/////////////////////////////////////////////////////////////// <br>void <br>ShutdownTapi() <br>{ <br>    CCallNotificationPtrList::iterator i; <br>    // if there is still a call, <br>    // release it <br>    if (NULL != gpCall) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>    } <br> <br> <br>    // Release all CallNotification objects <br>    for ( <br>         i = gpCallNotificationList.begin(); <br>         i != gpCallNotificationList.end(); <br>         i++ <br>        ) <br>    { <br>         <br>        (*i)-&gt;Shutdown(); <br>         <br>        // At this point, we should call Unadvise on <br>        // the ConnectionPoint.  However, TAPI 3.0 <br>        // does not support Unadvise for the ITCallNotification <br>        // interface.  So, here we just release the object <br>        (*i)-&gt;Release(); <br>    } <br>     <br>    // release main object. <br>    if (NULL != gpTapi) <br>    { <br>        gpTapi-&gt;Shutdown(); <br>        gpTapi-&gt;Release(); <br>    } <br> <br>    // free the BSTRs <br>    SysFreeString( gbstrAudioIn ); <br>    SysFreeString( gbstrAudioOut ); <br>    SysFreeString( gbstrVideoIn ); <br>    SysFreeString( gbstrVideoOut ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// MainDlgProc <br>/////////////////////////////////////////////////////////////////////////// <br>BOOL <br>CALLBACK <br>MainDialogProc( <br>               HWND hDlg, <br>               UINT uMsg, <br>               WPARAM wParam, <br>               LPARAM lParam <br>              ) <br>{ <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>            // set up dialog <br>            ghDlg = hDlg; <br>             <br>            DisableButton( IDC_ANSWER ); <br>            DisableButton( IDC_DISCONNECT ); <br> <br>            SetStatusMessage( L"Waiting for a call..." ); <br> <br>            return 0; <br>        } <br> <br>        case WM_COMMAND: <br>        { <br>            if ( LOWORD(wParam) == IDCANCEL ) <br>            { <br>                // quit <br>                EndDialog( hDlg, 0 ); <br> <br>                return 1; <br>            } <br> <br>            switch ( LOWORD(wParam) ) <br>            { <br>                // dial request <br>                case IDC_ANSWER: <br>                { <br>                    SetStatusMessage(L"Answering..."); <br>                    // answer the call <br>                    if ( S_OK == AnswerTheCall() ) <br>                    { <br>                        SetStatusMessage(L"Connected"); <br> <br>                        EnableButton( IDC_DISCONNECT ); <br>                        DisableButton( IDC_ANSWER ); <br>                    } <br>                    else <br>                    { <br>                        DisableButton( IDC_ANSWER ); <br>                        DoMessage(L"Answer failed"); <br>                        SetStatusMessage(L"Waiting for a call..."); <br>                    } <br> <br>                    return 1; <br>                } <br> <br>                // disconnect request <br>                case IDC_DISCONNECT: <br>                { <br>                    SetStatusMessage(L"Disconnecting..."); <br>                    // disconnect <br>                    if (S_OK != DisconnectTheCall()) <br>                    { <br>                        DoMessage(L"Disconnect failed"); <br>                    } <br> <br>                    return 1; <br>                } <br> <br>                // disconnected notification <br>                case IDC_DISCONNECTED: <br>                { <br>                    // release <br>                    ReleaseTheCall(); <br> <br>                    EnableButton( IDOK ); <br>                    DisableButton( IDC_DISCONNECT ); <br> <br>                    SetStatusMessage(L"Waiting for a call..."); <br>                     <br>                    return 1; <br>                } <br>                default: <br> <br>                    return 0; <br>            } <br>        } <br>        default: <br> <br>            return 0; <br>    } <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////////// <br>// ListenOnAddresses <br>// <br>// This procedure will find all addresses that support audioin and audioout <br>// and will call ListenOnThisAddress to start listening on it. <br>//////////////////////////////////////////////////////////////////////// <br>HRESULT <br>ListenOnAddresses() <br>{ <br>    HRESULT             hr = S_OK; <br>    IEnumAddress *      pEnumAddress; <br>    ITAddress *         pAddress; <br>    ITMediaSupport *    pMediaSupport; <br>    VARIANT_BOOL        bSupport; <br> <br>    // enumerate the addresses <br>    hr = gpTapi-&gt;_EnumerateAddresses( &amp;pEnumAddress ); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    while ( TRUE ) <br>    { <br>        // get the next address <br>        hr = pEnumAddress-&gt;Next( 1, &amp;pAddress, NULL ); <br> <br>        if (S_OK != hr) <br>        { <br>            break; <br>        } <br> <br>        pAddress-&gt;QueryInterface( IID_ITMediaSupport, (void **)&amp;pMediaSupport ); <br> <br>        // does it support AudioIn? <br>        pMediaSupport-&gt;QueryMediaType( <br>                                      gbstrAudioIn, <br>                                      &amp;bSupport <br>                                     ); <br> <br>        if (bSupport) <br>        { <br>            // does it also support AudioOut? <br>            pMediaSupport-&gt;QueryMediaType( <br>                                          gbstrAudioOut, <br>                                          &amp;bSupport <br>                                         ); <br> <br>            if (bSupport) <br>            { <br>                // listen <br>                hr = ListenOnThisAddress( pAddress ); <br>                if (S_OK != hr) <br>                { <br>                    DoMessage(L"Listen failed on an address"); <br>                } <br>            } <br>        } <br> <br>        pMediaSupport-&gt;Release(); <br>        pAddress-&gt;Release(); <br>    } <br> <br>    pEnumAddress-&gt;Release(); <br>     <br>    return S_OK; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>// ListenOnThisAddress <br>// <br>// Perform the steps involved in setting up an address to listen <br>// for calls.  Setting up an application to listen for calls is a two <br>// step process. <br>// <br>// First, the app must call RegisterCallTypes <br>// on the address that it wants calls on <br>// <br>// Second, it must register it's implementation of ITCallNotification <br>// with the address.  Registration is done via COM's ConnectionPoint <br>// methods.  See the COM documentation for more informations on <br>// ConnectionPoints <br>//     <br>/////////////////////////////////////////////////////////////////// <br>HRESULT <br>ListenOnThisAddress( <br>                    ITAddress * pAddress <br>                   ) <br>{ <br>    HRESULT hr = S_OK; <br>    IConnectionPointContainer * pCPC; <br>    IConnectionPoint *          pCP; <br>    CCallNotification *         pCallNotification; <br>    DWORD                       dwCookie; <br>    VARIANT var; <br> <br>    // RegisterCallTypes takes an array (in a variant) of <br>    // MediaTypes for the address to listen for. <br>    // If NULL is specified for the array, that means to listen <br>    // for all the media types that the address supports. <br>    // <br>    // Since we already know the address supports audioin/audioout, <br>    // just tell it to listen for all types.  Also, we will tell <br>    // it that we are only interested in being the owner of calls, <br>    // not monitoring <br> <br>    VariantInit( &amp;var ); <br>    var.vt = VT_ARRAY; <br>    var.parray = NULL; <br> <br>    hr = pAddress-&gt;RegisterCallTypes( <br>                                     FALSE, <br>                                     TRUE,  // Want to be owner <br>                                     FALSE, // Don't want to be monitor <br>                                     var    // mediatypes <br>                                    ); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    // now we need to register our outgoing interface through <br>    // the ConnectionPoint methods. <br>     <br>    // First we create our CCallNotification object <br>    pCallNotification = new CCallNotification; <br> <br>    if (NULL == pCallNotification) <br>    { <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    // initialize the object <br>    hr = pCallNotification-&gt;Initialize( pAddress ); <br> <br>    if (S_OK != hr) <br>    { <br>        pCallNotification-&gt;Release(); <br>        return hr; <br>    } <br>     <br>    // get the IConnectionPointContainer interface <br>    // from the address object <br>    hr = pAddress-&gt;QueryInterface(  <br>                                  IID_IConnectionPointContainer,  <br>                                  (void **)&amp;pCPC  <br>                                 ); <br> <br>    if (S_OK != hr) <br>    { <br>        pCallNotification-&gt;Release(); <br>        pCallNotification = NULL; <br>        return hr; <br>    } <br> <br>    // find the ConnectionPoint we are interested in <br>    hr = pCPC-&gt;FindConnectionPoint( IID_ITCallNotification, &amp;pCP ); <br> <br>    pCPC-&gt;Release(); <br> <br>    if (S_OK != hr) <br>    { <br>        pCallNotification-&gt;Release(); <br>        pCallNotification = NULL; <br>        return hr; <br>    } <br> <br>    // call the advise function <br>    // <br>    // if this function succeeds, the address will start <br>    // listening for calls. <br>    hr = pCP-&gt;Advise( <br>                     (IUnknown *)pCallNotification, <br>                     &amp;dwCookie <br>                    ); <br> <br>    pCP-&gt;Release(); <br>     <br>    if (S_OK != hr) <br>    { <br>        pCallNotification-&gt;Release(); <br>        pCallNotification = NULL; <br>        return hr; <br>    } <br> <br>    // save the notification object <br>    // note that normally you would want <br>    // to save the dwCookie as well.  Refer <br>    // to the COM ConnectionPoint documentation <br>    // for more details. <br>    gpCallNotificationList.push_back( pCallNotification ); <br>     <br>    return S_OK; <br>} <br>                     <br>///////////////////////////////////////////////////////// <br>// GetMediaTerminal <br>// <br>// Creates a MediaTerminal for the bstrMediaType passed <br>// in, using the default terminal for the bstrMediaType <br>// <br>///////////////////////////////////////////////////////// <br>HRESULT <br>GetMediaTerminal( <br>                 ITAddress * pAddress, <br>                 BSTR bstrMediaType, <br>                 ITMediaTerminal ** ppMediaTerminal <br>                ) <br>{ <br>    HRESULT             hr = S_OK; <br>    ITTerminalSupport * pTerminalSupport; <br>    ITTerminal *        pTerminal; <br> <br>    // get the terminal support interface <br>    pAddress-&gt;QueryInterface( IID_ITTerminalSupport, (void **)&amp;pTerminalSupport ); <br>     <br>    // get the default terminal for MediaType <br>    hr = pTerminalSupport-&gt;GetDefaultTerminal( <br>                                              bstrMediaType, <br>                                              &amp;pTerminal <br>                                             ); <br> <br> <br>    pTerminalSupport-&gt;Release(); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    // Create a media terminal for MediaType <br>    // Use the default terminal we just got <br>    hr = gpTapi-&gt;CreateMediaTerminal( <br>                                     bstrMediaType, <br>                                     pTerminal, <br>                                     ppMediaTerminal <br>                                    ); <br> <br>    pTerminal-&gt;Release(); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    return S_OK; <br> <br>} <br> <br>///////////////////////////////////////////////////////// <br>// GetVideoInMediaTerminal <br>// <br>// Creates a MediaTerminal for the VideoIn mediatype  <br>// This is a dynamic terminal type. <br>// <br>///////////////////////////////////////////////////////// <br>HRESULT <br>GetVideoInMediaTerminal( <br>                 ITAddress * pAddress, <br>                 ITMediaTerminal ** ppMediaTerminal <br>                ) <br>{ <br>    HRESULT             hr = S_OK; <br>    ITTerminalSupport * pTerminalSupport; <br>    ITTerminal *        pTerminal; <br> <br>    // get the terminal support interface <br>    pAddress-&gt;QueryInterface( IID_ITTerminalSupport, (void **)&amp;pTerminalSupport ); <br>     <br>    BSTR bstrTerminalClass; <br>    LPOLESTR lpTerminalClass; <br> <br>    StringFromIID( <br>                CLSID_VideoWindowTerm, <br>                &amp;lpTerminalClass <br>                ); <br> <br>    bstrTerminalClass = SysAllocString ( lpTerminalClass ); <br> <br>    CoTaskMemFree( lpTerminalClass ); <br> <br>    hr = pTerminalSupport-&gt;CreateTerminal( <br>        bstrTerminalClass, <br>        &amp;pTerminal <br>        ); <br> <br>    SysFreeString( bstrTerminalClass ); <br>    pTerminalSupport-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>    { <br>        return hr; <br>    } <br> <br>    // Create a media terminal for MediaType <br>    // Use the default terminal we just got <br>    hr = gpTapi-&gt;CreateMediaTerminal( <br>                                     gbstrVideoIn, <br>                                     pTerminal, <br>                                     ppMediaTerminal <br>                                    ); <br> <br>    pTerminal-&gt;Release(); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br> <br>    return S_OK; <br> <br>} <br> <br>///////////////////////////////////////////////////////////////// <br>// CreateMediaTerminals <br>// <br>// Create audioin and audioout terminals. Videoin and videoout terminals <br>// are created only when the address supports them. <br>// <br>// This function assumes that ppMediaTerminals has a size no less than four. <br>///////////////////////////////////////////////////////////////// <br>HRESULT <br>CreateMediaTerminals( <br>                     ITAddress *pAddress, <br>                     ITMediaTerminal ** ppMediaTerminals, <br>                     PLONG pNumMediaTerminals <br>                    ) <br>{ <br>    int count = 0; <br>    HRESULT hr; <br> <br>    // get the mediaterminal for audioin <br>    hr = GetMediaTerminal( <br>                          pAddress, <br>                          gbstrAudioIn, <br>                          &amp;ppMediaTerminals[count] <br>                         ); <br> <br>    if (S_OK != hr) <br>    { <br>        return hr; <br>    } <br>     <br>    count ++; <br> <br>    // get the mediaterminal for audioout <br>    hr = GetMediaTerminal( <br>                          pAddress, <br>                          gbstrAudioOut, <br>                          &amp;ppMediaTerminals[count] <br>                         ); <br> <br>    if (S_OK != hr) <br>    { <br>        ppMediaTerminals[0]-&gt;Release(); <br>        return hr; <br>    } <br> <br>    count ++; <br>     <br>    // Find out if the address supports video. <br>    ITMediaSupport *pMediaSupport; <br>    VARIANT_BOOL    bSupport; <br> <br>    pAddress-&gt;QueryInterface( IID_ITMediaSupport, (void **)&amp;pMediaSupport ); <br> <br>    // does it support VideoIn? <br>    pMediaSupport-&gt;QueryMediaType( <br>                                  gbstrVideoIn, <br>                                  &amp;bSupport <br>                                 ); <br> <br>    if (bSupport) <br>    { <br>        // get the mediaterminal for VideoIn <br>        hr = GetVideoInMediaTerminal( <br>                                     pAddress, <br>                                     &amp;ppMediaTerminals[count] <br>                                    ); <br> <br>        if (S_OK == hr) <br>        { <br>            count ++; <br>        } <br> <br>        // does it also support VideoOut? <br>        pMediaSupport-&gt;QueryMediaType( <br>            gbstrVideoOut, <br>            &amp;bSupport <br>            ); <br> <br>        if (bSupport) <br>        { <br>            // get the mediaterminal for Videoout <br>            hr = GetMediaTerminal( <br>                                  pAddress, <br>                                  gbstrVideoOut, <br>                                  &amp;ppMediaTerminals[count] <br>                                 ); <br>     <br>            if (S_OK == hr) <br>            { <br>                count ++; <br>            } <br>        } <br>    } <br> <br>    pMediaSupport-&gt;Release(); <br> <br>    *pNumMediaTerminals = count; <br> <br>    return S_OK; <br>} <br> <br>///////////////////////////////////////////////////////////////// <br>// CreateMediaTerminalSafeArray <br>// <br>///////////////////////////////////////////////////////////////// <br>SAFEARRAY * <br>CreateMediaTerminalSafeArray( <br>                             ITMediaTerminal ** ppMediaTerminals, <br>                             LONG nNumMediaTerminals <br>                            ) <br>{ <br>    SAFEARRAY *             psa; <br>    SAFEARRAYBOUND          sabound[1]; <br> <br>    // create a safearray with two elements <br>    // to pass the mediaterminals to tapi <br>    sabound[0].lLbound = 0; <br>    sabound[0].cElements = nNumMediaTerminals; <br> <br>    psa = SafeArrayCreate( <br>                          VT_UNKNOWN, <br>                          1, <br>                          sabound <br>                         ); <br> <br>    if (NULL != psa) <br>    { <br>        // save them in the safearray <br>        for (long i = 0; i &lt; nNumMediaTerminals; i ++) <br>        { <br>            SafeArrayPutElement( <br>                            psa, <br>                            &amp;i, <br>                            ppMediaTerminals[i] <br>                           ); <br>        } <br>    } <br>    return psa; <br>} <br> <br>///////////////////////////////////////////////////////////////// <br>// ReleaseMediaTerminals <br>// <br>///////////////////////////////////////////////////////////////// <br>void <br>ReleaseMediaTerminals( <br>                      ITMediaTerminal ** ppMediaTerminals, <br>                      LONG nNumMediaTerminals <br>                     ) <br>{ <br>    for (long i = 0; i &lt; nNumMediaTerminals; i ++) <br>    { <br>        if (ppMediaTerminals[i]) <br>        { <br>            ppMediaTerminals[i]-&gt;Release(); <br>        } <br>    } <br>} <br> <br>///////////////////////////////////////////////////////////////////// <br>// Answer the call <br>///////////////////////////////////////////////////////////////////// <br>HRESULT <br>AnswerTheCall() <br>{ <br>    HRESULT                 hr; <br>    ITCallInfo *            pCallInfo; <br>    ITAddress *             pAddress; <br>    ITMediaTerminal *       ppMediaTerminals[MAXTERMINALS]; <br>    long                    nNumMediaTerminals = MAXTERMINALS; <br>    SAFEARRAY *             psa; <br> <br> <br>     <br>    if (NULL == gpCall) <br>    { <br>        return E_UNEXPECTED; <br>    } <br> <br> <br>    // get the address object of this call <br>    gpCall-&gt;QueryInterface( IID_ITCallInfo, (void**)&amp;pCallInfo ); <br>    pCallInfo-&gt;get_Address( &amp;pAddress ); <br>    pCallInfo-&gt;Release(); <br> <br> <br>    // create the media terminals for this call <br>    hr = CreateMediaTerminals(  <br>        pAddress,  <br>        ppMediaTerminals,  <br>        &amp;nNumMediaTerminals <br>        ); <br> <br> <br>    // release the address <br>    pAddress-&gt;Release(); <br> <br>     <br>    if (S_OK != hr) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>        return hr; <br>    } <br> <br>    psa = CreateMediaTerminalSafeArray(ppMediaTerminals, nNumMediaTerminals); <br> <br>    if (S_OK != hr) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>        ReleaseMediaTerminals(ppMediaTerminals, nNumMediaTerminals); <br>        return hr; <br>    } <br> <br>    // put the safearray in a variant <br>    VARIANT                 var; <br>    VariantInit(&amp;var); <br>    var.vt = VT_ARRAY; <br>    var.parray = psa; <br> <br>    // call SelectMediaTerminals <br>    hr = gpCall-&gt;SelectMediaTerminals( <br>                                      var <br>                                     ); <br> <br>    ReleaseMediaTerminals(ppMediaTerminals, nNumMediaTerminals); <br> <br>    SafeArrayDestroy( psa ); <br> <br>    if (S_OK != hr) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>        return hr; <br>    } <br>     <br>    // answer the call <br>    hr = gpCall-&gt;Answer(); <br> <br>    return hr; <br>} <br> <br>////////////////////////////////////////////////////////////////////// <br>// DisconnectTheCall <br>// <br>// Disconnects the call <br>////////////////////////////////////////////////////////////////////// <br>HRESULT <br>DisconnectTheCall() <br>{ <br>    HRESULT         hr = S_OK; <br> <br>    if (NULL != gpCall) <br>    { <br>        hr = gpCall-&gt;Disconnect( DC_NORMAL ); <br> <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>     <br>        return hr; <br>    } <br> <br>    return S_FALSE; <br>} <br> <br>////////////////////////////////////////////////////////////////////// <br>// ReleaseTheCall <br>// <br>// Releases the call <br>////////////////////////////////////////////////////////////////////// <br>void <br>ReleaseTheCall() <br>{ <br>    if (NULL != gpCall) <br>    { <br>        gpCall-&gt;Release(); <br>        gpCall = NULL; <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>// <br>// HELPER FUNCTIONS <br>// <br>/////////////////////////////////////////////////////////////////// <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>// DoMessage <br>/////////////////////////////////////////////////////////////////// <br>void <br>DoMessage( <br>          LPWSTR pszMessage <br>         ) <br>{ <br>    MessageBox( <br>               ghDlg, <br>               pszMessage, <br>               gszTapi30, <br>               MB_OK <br>              ); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// SetStatusMessage <br>////////////////////////////////////////////////////////////////// <br>void <br>SetStatusMessage( <br>                 LPWSTR pszMessage <br>                ) <br>{ <br>    SetDlgItemText( <br>                   ghDlg, <br>                   IDC_STATUS, <br>                   pszMessage <br>                  ); <br>} <br> <br>/////////////////////////////////////////////////////////////// <br>// EnableButton <br>// <br>// Enable, make default, and setfocus to a button <br>/////////////////////////////////////////////////////////////// <br>void <br>EnableButton( <br>             int ID <br>            ) <br>{ <br>    SendDlgItemMessage( <br>                       ghDlg, <br>                       ID, <br>                       BM_SETSTYLE, <br>                       BS_DEFPUSHBUTTON, <br>                       0 <br>                      ); <br>    EnableWindow( <br>                 GetDlgItem( ghDlg, ID ), <br>                 TRUE <br>                ); <br>    SetFocus( <br>             GetDlgItem( ghDlg, ID ) <br>            ); <br>} <br> <br>////////////////////////////////////////////////////////////// <br>// DisableButton <br>// <br>// Disable a button <br>////////////////////////////////////////////////////////////// <br>void <br>DisableButton( <br>              int ID <br>             ) <br>{ <br>    SendDlgItemMessage( <br>                       ghDlg, <br>                       ID, <br>                       BM_SETSTYLE, <br>                       BS_PUSHBUTTON, <br>                       0 <br>                      ); <br>    EnableWindow( <br>                 GetDlgItem( ghDlg, ID ), <br>                 FALSE <br>                ); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
