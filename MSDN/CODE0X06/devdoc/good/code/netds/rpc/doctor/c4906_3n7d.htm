<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCTORP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4909"></a>DOCTORP.C</h2>
<pre><code>/**************************************************************************** <br>                   Microsoft RPC Version 2.0 <br>           Copyright Microsoft Corp. 1992, 1993, 1994- 1996 <br>                        Doctor Example <br> <br>    FILE:       Doctorp.c <br> <br>    PURPOSE:    Procedures that can be linked with the client side <br>                to form a standalone application, or linked with <br>                the server side to form a distributed RPC application <br> <br>    DATA:       Pattern   - array of strings; input patterns and responses <br>                Substring - substrings within user input <br> <br>    FUNCTIONS:  Analyze(*pszInOut) - top level function <br>                Match(*string, *pattern) - compare input to patterns <br>                Respond(*string, *response) - replace substrings in response <br>                Synonyms(*ps1, *ps2) - replace synonyms in user input <br> <br>****************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br>#include "doctor.h"     // header file generated by MIDL compiler <br> <br>#define TRUE  1 <br>#define FALSE 0 <br> <br> <br>char *Pattern[] = <br>    { <br>    "0COMPUTER 1", <br>    "0COMPUTERS 1", <br>    "=DO 11S WORRY YOU?",    // string 11 = "computer" or "machine" <br>    "=WHY DO YOU MENTION 11S?", <br>    "=WHAT DO YOU THINK 11S HAVE TO DO WITH YOUR PROBLEM?", <br>    "=WHAT DO YOU THINK ABOUT 11S?", <br> <br>    "0RPC0", <br>    "=WHY DO YOU MENTION RPC?", <br>    "=DO YOU MENTION RPC BECAUSE YOU ARE FEELING REMOTE RIGHT NOW?", <br>    "=WHAT FEELINGS DO YOU HAVE ABOUT RPC?", <br> <br>    "0SORRY0", <br>    "=PLEASE DON'T APOLOGIZE.", <br>    "=APOLOGIES ARE NOT NECESSARY.", <br>    "=WHAT FEELINGS DO YOU HAVE WHEN YOU APOLOGIZE?", <br>    "=I'VE TOLD YOU THAT APOLOGIES ARE NOT REQUIRED.", <br>    "=APOLOGIES ARE NOT NECESSARY, PLEASE GO ON", <br> <br>    "0I AM SAD1", <br>    "=I AM SORRY TO HEAR YOU ARE 14.",    // string 14 = "sad", "sick", etc. <br>    "=DO YOU THINK COMING HERE WILL HELP YOU NOT TO BE 14?", <br>    "=I'M SURE IT'S NOT PLEASANT TO BE 14.", <br>    "=CAN YOU EXPLAIN WHAT MADE YOU 14?", <br> <br>    "0I AM HAPPY1", <br>    "=HOW HAVE I HELPED YOU TO BE 15?",    // string 15 = "happy", etc. <br>    "=HAS YOUR TREATMENT MADE YOU 15?", <br>    "=WHAT MAKES YOU 15 JUST NOW?", <br>    "=CAN YOU EXPLAIN WHY YOU ARE SUDDENLY 15?", <br> <br>    "0NAME0", <br>    "=I AM NOT INTERESTED IN NAMES.", <br>    "=I'VE TOLD YOU BEFORE I DON'T CARE ABOUT NAMES.  PLEASE CONTINUE.", <br> <br>    "0 FAMILY1", <br>    "=TELL ME MORE ABOUT YOUR 12.",    // string 12 = "mother", "brother", etc. <br>    "=WHO ELSE IN YOUR FAMILY?", <br>    "=YOUR 12?", <br>    "=WHAT ELSE COMES TO MIND WHEN YOU THINK OF YOUR 12?", <br> <br>    "0I REMEMBER 1", <br>    "=DO YOU OFTEN THINK OF 1?", <br>    "=WHAT IN THE PRESENT SITUATION REMINDS YOU OF 1?", <br> <br>    "0SAME0", <br>    "0ALIKE0", <br>    "0IS 0LIKE0", <br>    "=IN WHAT WAY?", <br>    "=WHAT RESEMBLANCE DO YOU SEE?", <br>    "=WHAT DOES THAT SIMILARITY SUGGEST TO YOU?", <br>    "=WHAT OTHER CONNECTIONS DO YOU SEE?", <br>    "=WHAT DO YOU SUPPOSE THAT RESEMBLANCE MEANS?", <br>    "=WHAT IS THE CONNECTION, DO YOU SUPPOSE?", <br>    "=COULD THERE REALLY BE SOME CONNECTION?", <br>    "=HOW?", <br> <br>    "0I REMEMBER 1", <br>    "=DO YOU OFTEN THINK OF 1?", <br>    "=DOES THINKING OF 1 BRING ANYTHING ELSE TO MIND?", <br>    "=WHAT ELSE DO YOU REMEMBER?", <br>    "=WHY DO YOU REMEMBER 1 JUST NOW?", <br>    "=WHAT IN THE PRESENT SITUATION REMINDS YOU OF 1?", <br>    "=WHAT IS THE CONNECTION BETWEEN ME AND 1?", <br> <br>    "0DO YOU REMEMBER 1", <br>    "=DID YOU THINK I WOULD FORGET 1?", <br>    "=WHY DO YOU THINK I SHOULD RECALL 1 NOW?", <br>    "=WHAT ABOUT 1?", <br>    "=YOU MENTIONED 1?", <br> <br>    "1 IS MY PROBLEM0", <br>    "=1 13 YOUR PROBLEM?",    // string 13 = "is" or "are" <br>    "=ARE YOU SURE 13 1 YOUR PROBLEM?", <br>    "=PERHAPS 13 1 NOT YOUR REAL PROBLEM.", <br>    "=YOU THINK YOU HAVE PROBLEMS?", <br>    "=DO YOU OFTEN THINK ABOUT 1?", <br> <br>    "0PROBLEM0", <br>    "=PLEASE CONTINUE, THIS MAY BE INTERESTING.", <br>    "=HAVE YOU ANY OTHER PROBLEMS YOU WISH TO DISCUSS?", <br>    "=PERHAPS YOU'D RATHER CHANGE THE SUBJECT.", <br>    "=YOU SEEM A BIT UNEASY.", <br> <br>    "0I DREAMT 1", <br>    "0I DREAMED 1", <br>    "=REALLY 1?", <br>    "=HAVE YOU EVER FANTASIZED 1 WHILE YOU WERE AWAKE?", <br>    "=HAVE YOU DREAMT 1 BEFORE?", <br>    "=WHAT DOES THAT DREAM SUGGEST TO YOU?", <br>    "=DO YOU DREAM OFTEN?", <br>    "=WHAT PERSONS APPEAR IN YOUR DREAMS?", <br>    "=DON'T YOU BELIEVE THAT DREAM HAS SOMETHING TO DO WITH YOUR PROBLEM?", <br>    "=DO YOU EVER WISH YOU COULD FLEE FROM REALITY?", <br> <br>    "0DREAM0", <br>    "=WHAT DOES THAT DREAM SUGGEST TO YOU?", <br>    "=DO YOU DREAM OFTEN?", <br>    "=WHAT PERSONS APPEAR IN YOUR DREAMS?", <br>    "=DON'T YOU BELIEVE THAT DREAM HAS SOMETHING TO DO WITH YOUR PROBLEM?", <br>    "=DO YOU EVER WISH YOU COULD FLEE FROM REALITY?", <br> <br>    "0IF 1 HAD 2", <br>    "=DO YOU THINK IT'S LIKELY THAT 1 MIGHT HAVE 2?", <br>    "=DO YOU WISH THAT 1 HAD 2?", <br>    "=REALLY, IF 1 HAD 2?", <br> <br>    "0IF 1", <br>    "=DO YOU THINK IT'S LIKELY THAT 1?", <br>    "=DO YOU WISH THAT 1?", <br>    "=WHAT DO YOU THINK ABOUT 1?", <br>    "=REALLY, IF 1?", <br> <br>    "WAS I 1", <br>    "=WHAT IF YOU WERE 1?", <br>    "=DO YOU THINK YOU WERE 1?", <br>    "=WERE YOU 1?", <br>    "=WHAT WOULD IT MEAN IF YOU WERE 1?", <br>    "=WHAT DOES \"1\" SUGGEST TO YOU?", <br>    "=WHY DO YOU ASK?", <br>    "=DOES THAT QUESTION INTERST YOU?", <br>    "=WHAT IS IT YOU REALLY WANT TO KNOW?", <br>    "=ARE SUCH QUESTIONS MUCH ON YOUR MIND?", <br>    "=WHAT ANSWER WOULD PLEASE YOU MOST?", <br>    "=WHAT DO YOU THINK?", <br>    "=WHAT COMES TO YOUR MIND WHEN YOU ASK THAT?", <br>    "=HAVE YOU ASKED SUCH QUESTIONS BEFORE?", <br>    "=HAVE YOU ASKED ANYONE ELSE?", <br> <br>    "0I WAS 1", <br>    "=WERE YOU REALLY?", <br>    "=WHY DO YOU TELL ME YOU WERE 1 NOW?", <br>    "=PERHAPS I ALREADY KNEW YOU WERE 1.", <br> <br>    "WERE YOU 1", <br>    "=WOULD YOU LIKE TO BELIEVE THAT I WAS 1?", <br>    "=WHAT SUGGESTS THAT I WAS 1?", <br>    "=WHAT DO YOU THINK?", <br>    "=PERHAPS I WAS 1.", <br>    "=WHAT IF I HAD BEEN 1.", <br> <br>    "0 MY 1", <br>    "MY 1", <br>    "=YOUR 1?", <br>    "=WHY DO YOU SAY YOUR 1?", <br>    "=DOES THAT SUGGEST ANYTHING ELSE WHICH BELONGS TO YOU?", <br>    "=IS IT IMPORTANT TO YOU THAT 1?", <br> <br>    "0EVERYONE0", <br>    "0EVERYBODY0", <br>    "=REALLY, EVERYONE?", <br>    "=SURELY NOT EVERYONE.", <br>    "=CAN YOU THINK OF ANYONE IN PARTICULAR?", <br>    "=WHO, FOR EXAMPLE?", <br>    "=YOU ARE THINKING OF A VERY SPECIAL PERSON.", <br>    "=WHO, MAY I ASK?", <br>    "=SOMEONE SPECIAL, PERHAPS.", <br>    "=YOU HAVE A PARTICULAR PERSON IN MIND, DON'T YOU?", <br>    "=WHO DO YOU THINK YOU'RE TALKING ABOUT?", <br>    "=I SUSPECT YOU'RE EXAGGERATING A LITTLE.", <br> <br>    "NO ONE0", <br>    "0 NO ONE0", <br>    "0NOBODY0", <br>    "=REALLY, NO ONE?", <br>    "=SURELY SOMEONE.", <br>    "=CAN YOU THINK OF ANYONE IN PARTICULAR?", <br>    "=WHO, FOR EXAMPLE?", <br>    "=YOU ARE THINKING OF A VERY SPECIAL PERSON.", <br>    "=WHO, MAY I ASK?", <br>    "=SOMEONE SPECIAL, PERHAPS.", <br>    "=YOU HAVE A PARTICULAR PERSON IN MIND, DON'T YOU?", <br>    "=WHO DO YOU THINK YOU'RE TALKING ABOUT?", <br>    "=I SUSPECT YOU'RE EXAGGERATING A LITTLE.", <br> <br>    "0ALWAYS0", <br>    "=CAN YOU THINK OF A SPECIFIC EXAMPLE?", <br>    "=WHEN?", <br>    "=WHAT INCIDENT ARE YOU THINKING OF?", <br>    "=REALLY, ALWAYS?", <br>    "=WHAT IF THIS NEVER HAPPENED?", <br> <br>    "0HOW 0", <br>    "0WHERE 0", <br>    "=WHY DO YOU ASK?", <br>    "=DOES THAT QUESTION INTERST YOU?", <br>    "=WHAT IS IT YOU REALLY WANT TO KNOW?", <br>    "=ARE SUCH QUESTIONS MUCH ON YOUR MIND?", <br>    "=WHAT ANWSER WOULD PLEASE YOU MOST?", <br>    "=WHAT DO YOU THINK?", <br>    "=WHAT COMES TO YOUR MIND WHEN YOU ASK THAT?", <br>    "=HAVE YOU ASKED SUCH QUESTIONS BEFORE?", <br>    "=HAVE YOU ASKED ANYONE ELSE?", <br> <br>    /* "there is no" strings must precede "there is" strings */ <br>    "0THERE IS NO 1", <br>    "0THERE IS NOT 1", <br>    "=WHAT IF THERE WERE 1", <br>    "=DID YOU THINK THERE MIGHT BE 1", <br>    "=HOW 13 1 RELATED TO YOU?", <br>    /* these must follow "there is no" strings */ <br>    "0THERE IS 1", <br>    "=13 THERE REALLY 1?", <br>    "=HOW 13 1 RELATED TO YOU?", <br> <br>    "0SEX 1", <br>    "=DO YOU REALLY WANT TO DISCUSS SEX?", <br>    "=DO YOU EVER DREAM ABOUT SEX?", <br>    "=WHY DO YOU MENTION SEX?", <br>    "=COULD SEX BE PART OF YOUR PROBLEM?", <br> <br>    "0HECK1",    // checks for strong language <br>    "0DARN1", <br>    "=ARE SUCH OBSCENITIES FREQUENTLY ON YOUR MIND?", <br>    "=YOU ARE BEING A BIT CHILDISH.", <br>    "=REALLY NOW", <br>    "=DEAR ME", <br>    "=I REALLY SHOULDN'T TOLERATE SUCH LANGUAGE.", <br> <br>    "0MY FRIEND 1", <br>    "=WHAT ELSE CAN YOU TELL ME ABOUT YOUR FRIEND?", <br>    "=WHAT MIGHT YOUR FRIEND HAVE TO DO WITH THE PROBLEM?", <br> <br>    "0",    // last resort: match anything <br>    "=PLEASE GO ON.", <br>    "=I AM NOT SURE I UNDERSTAND YOU FULLY.", <br>    "=WHAT DOES THAT SUGGEST TO YOU?", <br>    "=DO YOU FEEL STRONGLY ABOUT DISCUSSING SUCH THINGS?", <br>    NULL    // special end of list character <br>}; <br> <br> <br>int iLastIndex = 0;     // don't send same response twice in a row <br>                        // note: this requires 2 responses for each pattern <br> <br>char Substring[20][STRSIZE] = { <br>  "", "", "", "", "", "", "", "", "", "", <br>  "REMEMBER",  /* 10 */ <br>  "COMPUTER",  /* 11 */ <br>  "FAMILY",    /* 12 */ <br>  "IS",        /* 13 */ <br>  "", "", "", "", "", ""        }; <br> <br> <br>/* Compare user input to patterns */ <br> <br>int Match (char *str, char *pat) <br>{ <br>    char * pStr;             // backup ptr to the user input string <br>    char * pPat;             // backup ptr to the pattern <br>    char *pSubstr = NULL;    // possible substrings within pattern <br>    int index = 0;           // index to substring <br> <br>    while (TRUE) {  // exit routine from within this loop <br> <br>        if (isdigit(*pat)) {  // replaceable pattern number <br>            index = atoi(pat);       // extract pattern number <br>            while (isdigit(*pat))    // skip number in pattern <br>                pat++; <br> <br>            pSubstr = Substring[index]; // pointer to current substring <br> <br>            if (*pat == '\0') {  // if end of pattern, everything will match <br>                strcpy(pSubstr, str);   // copy rest of input into substring <br>                return(TRUE); <br>            } <br> <br>            else <br>                while (*pat != *str) {  // match all to specific char in pattern <br>                    *pSubstr++ = *str++; // fill substring <br>                    if (*str == '\0')    // stuff left to match, but no input <br>                        return(FALSE); <br>                    *pSubstr = '\0';     // can overwrite if there's more... <br>                } <br> <br>            pStr = str;  // keep track; it may still be * <br>            pPat = pat;  // keep track; it may still be * <br>        } <br> <br>        if (*str == *pat) {  // matches the specific pattern <br>            str++;  // skip to next character of input string <br>            pat++;  // skip to next character of pattern <br>            if ((*str == '\0') &amp;&amp; (*pat == '\0'))  // both at end? <br>                return(TRUE); <br>        } <br> <br>        else if (pSubstr != NULL) {  // didn't match specific, so still * substring <br>            pat = pPat;              // restore ptr to input pattern <br>            while (pStr &lt; str)       // catch up to current input character <br>                *pSubstr++ = *pStr++; <br>            while (*pat != *str) {   // match to next possible match in pattern <br>                *pSubstr++ = *str++; // fill substring with more characters <br>                if (*str == '\0')    // stuff left to match, but no input <br>                    return(FALSE); <br>            } <br>            *pSubstr = '\0';         // can overwrite if there's more... <br>            pStr = str;              // keep track; it may still be * <br>            pPat = pat;              // keep track; it may still be * <br>        } <br> <br>        else <br>            return(FALSE);           // no match <br> <br>    }  // end while (TRUE) loop <br> <br>}  // end function Match <br> <br> <br>/* Add possible substrings to the response string */ <br> <br>void Respond(char *str, char *finalstr) <br>{ <br>    char copy[STRSIZE];  // copy of the substring to process token at a time <br>    char *token; <br>    char *word; <br>    int index;           // index to substring (string converted to number) <br>    int len = 0;         // index to output string for sprintf <br> <br>    while (*str) { <br> <br>        if (! isdigit(*str)) <br>            len += sprintf(finalstr + len, "%c", *str++); <br> <br>        else {  // check for pattern number <br> <br>            index = atoi(str);     // extract pattern number <br>            while (isdigit(*str))  // skip number in pattern <br>                str++; <br> <br>            strcpy(copy, Substring[index]);  // process substring <br>            token = strtok(copy, " ");       // skip blanks <br> <br>            while (token) { <br>                word = token; <br> <br>                if (! strcmp(token,"I") || ! strcmp(token,"ME")) <br>                    word = "YOU"; <br>                else if (! strcmp(token,"YOU")) <br>                    word = "I"; <br>                else if (! strcmp(token,"MY")) <br>                    word = "YOUR"; <br>                else if (! strcmp(token,"YOUR")) <br>                    word = "MY"; <br>                else if (! strcmp(token,"MINE")) <br>                    word = "YOURS"; <br>                else if (! strcmp(token,"YOURS")) <br>                    word = "MINE"; <br>                else if (! strcmp(token,"MYSELF")) <br>                    word = "YOURSELF"; <br>                else if (! strcmp(token,"YOURSELF")) <br>                    word = "MYSELF"; <br>                else if (! strcmp(token,"I'M")) <br>                    word = "YOU'RE"; <br>                else if (! strcmp(token,"YOU'RE")) <br>                    word = "I'M"; <br>                else if (! strcmp(token,"AM")) <br>                    word = "ARE"; <br>                else if (! strcmp(token,"WAS")) <br>                    word = "WERE"; <br> <br>                len += sprintf(finalstr + len, "%s", word); <br> <br>                // get next token from Substring <br>                if ((token = strtok(NULL, " ")) != NULL) <br>                    len += sprintf(finalstr + len, " "); <br> <br>            }  // end while token <br> <br>        }  // end else (if isdigit) <br> <br>    }  // end while str <br> <br>    len += sprintf(finalstr + len, "\n"); <br> <br>}  // end function Respond <br> <br> <br>/* Replace synonyms in user input */ <br> <br>void Synonyms(char *input, char *output) <br>{ <br>    char *ps1 = input; <br>    char *ps2 = output; <br>    char *token; <br>    char *word; <br> <br>    static char *synonym10[] = {"RECALL", "RECOLLECT", ""}; <br>    static char *synonym11[] = {"MACHINE", ""}; <br>    static char *synonym12[] = {"MOTHER", "MOMMY", "FATHER", "DADDY", <br>                                "SISTER", "BROTHER", "AUNT", "UNCLE", ""}; <br>    static char *synonym13[] = {"ARE", "AM", ""}; <br>    static char *synonym14[] = {"SAD", "UNHAPPY", "DEPRESSED", "SICK", ""}; <br>    static char *synonym15[] = {"HAPPY", "ELATED", "GLAD", "BETTER", ""}; <br> <br>    short StrMember(); <br> <br>    // preprocessing...convert to uppercase and check for special chars <br> <br>    while (*ps1) { <br>        *ps1 = toupper(*ps1); <br>        if (*ps1 == '.' || *ps1 == ',' || *ps1 == '!' || <br>            *ps1 == '?' || *ps1 == ';' || *ps1 == ':' || <br>            ! isprint(*ps1)) { <br>            *ps1 = '\0'; <br>            break; <br>        } <br>        ps1++; <br>    } <br> <br>    // ok, it's preprocessed now...let's check for pattern matches <br> <br>    ps1 = input;               // back to the beginning... <br>    strcpy(ps2, ""); <br>    token = strtok(ps1, " ");  // search for tokens deliminated by space <br> <br>    while (token) { <br> <br>        word = token; <br> <br>        if (StrMember(token, synonym10)) { <br>            word = "REMEMBER";  // use this synonym for pattern-matching <br>        } <br>        else if (StrMember(token, synonym11)) { <br>            strcpy(Substring[11], token);  // 11 is hardcoded into response <br>            word = "COMPUTER"; <br>        } <br>        else if (StrMember(token, synonym12)) { <br>            strcpy(Substring[12], token);  // 12 <br>            word = "FAMILY"; <br>        } <br>        else if (StrMember(token, synonym13)) { <br>            strcpy(Substring[13], token);  // 13 <br>            word = "IS"; <br>        } <br>        else if (StrMember(token, synonym14)) { <br>            strcpy(Substring[14], token);  // 14 <br>            word = "SAD"; <br>        } <br>        else if (StrMember(token, synonym15)) { <br>            strcpy(Substring[15], token);  // 15 <br>            word = "HAPPY"; <br>        } <br> <br>        strcat(ps2, word);          // append the token to the output string <br>        strcat(ps2, " ");           // restore space <br>        token = strtok(NULL, " ");  // search for the next token <br> <br>    }  // end while token <br> <br>}  // end function Synonyms <br> <br> <br>short StrMember(char *str, char **list) <br>{ <br>    while (strcmp(*list, "")) {    // not end of the list <br>        if (!strcmp(str, *list)) <br>            return 1; <br>        else <br>            list++; <br>    } <br> <br>    return 0; <br>} <br> <br> <br>/* Top-level routine */ <br> <br>void Analyze(unsigned char *str) <br>{ <br>    int i = 0;      // index to entry within Pattern <br>    int j;          // index to first possible response string <br>    int index;      // index of the actual response string used <br>    int count = 0;  // count of all possible response strings (must be &gt; 2) <br>    char *response; <br>    char synstr[STRSIZE]; <br> <br>    Synonyms(str, synstr); <br> <br>    while (Pattern[i] != NULL) {  // check against all patterns <br> <br>        if (Pattern[i][0] != '=') {  // if a patient pattern <br> <br>            if (Match(synstr, Pattern[i]) == TRUE) { <br> <br>                // skip past patient input to doctor responses <br>                while (Pattern[i] &amp;&amp; Pattern[i][0] != '=') <br>                    i++; <br> <br>                // count the number of possible responses, and <br>                // point index to beginning of doctor responses <br>                if (Pattern[i] &amp;&amp; Pattern[i][0] == '=') { <br>                    count = 1; <br>                    j = i++; <br>                } <br> <br>                // count all possible doctor responses <br>                while (Pattern[i] &amp;&amp; Pattern[i][0] == '=') { <br>                    count++; <br>                    i++; <br>                } <br> <br>                // pick a different doctor response from last time <br>                do { <br>                    index = j + (rand() % count); <br>                } while (index == iLastIndex); <br> <br>                // process the doctor respose, and <br>                // keep track of the response used last <br>                response = &amp;Pattern[index][1]; <br>                iLastIndex = index; <br>                Respond(response, str); <br>                return; <br> <br>            }  // end if match <br> <br>        }  // end if patient pattern <br> <br>        i++;  // next pattern <br> <br>    }  // end while pattern <br> <br>}  // end function Analyze <br> <br> <br>/* Shutdown the server by calling RPC API functions */ <br> <br>void Shutdown(void) <br>{ <br>    RPC_STATUS status; <br> <br>    printf("Calling RpcMgmtStopServerListening\n"); <br>    status = RpcMgmtStopServerListening(NULL); <br>    printf("RpcMgmtStopServerListening returned: 0x%x\n", status); <br>    if (status) { <br>        exit(status); <br>    } <br> <br>    printf("Calling RpcServerUnregisterIf\n"); <br>    status = RpcServerUnregisterIf(NULL, NULL, FALSE); <br>    printf("RpcServerUnregisterIf returned 0x%x\n", status); <br>    if (status) { <br>        exit(status); <br>    } <br>} <br> <br>/* end file doctorp.c */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
