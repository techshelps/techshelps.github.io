<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REMOTE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4962"></a>REMOTE.C</h2>
<pre><code>/**************************************************************************** <br>                   Microsoft RPC Version 2.0 <br>           Copyright Microsoft Corp. 1992, 1993, 1994- 1996 <br>                        mandel Example <br> <br>    FILE:      remote.c <br> <br>    PURPOSE:   Client side of the RPC distributed application Mandel <br> <br>    COMMENTS:  Code to do the remote calculations for the Windows <br>               Mandelbrot Set distributed drawing program. <br> <br>               Information coming into this module (via API calls) is <br>               based on upper-left being (0,0) (the Windows standard). <br>               We translate that to lower-left is (0,0) before we ship <br>               it out onto the net, and we do reverse translations <br>               accordingly. <br> <br>               The iteration data is passed back to the main window <br>               procedure (by means of a WM_PAINTLINE message) which <br>               draws the picture. <br> <br>               A word about the shared buffer: multiple buffers could <br>               be used, but a single one is used. The buffer is requested <br>               in this code, and then released after the data has been <br>               drawn (in PaintLine() in mandel.c). So long as the painting <br>               is done quickly, this is efficient. <br> <br>****************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#ifdef RPC <br>#include "mdlrpc.h" <br>#endif <br>#include "mandel.h" <br> <br> <br>/* <br> * External variables <br> */ <br>extern int          fBound; <br>extern svr_table    SvrTable;    // the server table <br>extern int          iLines; <br>extern double       dPrec; <br>extern int          fContinueZoom; <br>extern int          fZoomIn; <br>extern int          iHistMaxI; <br>extern int          iHistMaxJ; <br>extern RECT         rcZoom; <br>extern BOOL         fRectDefined; <br> <br> <br>/* <br> * Picture information <br> */ <br>int             cPictureID = 0;    // picture id, in case we reset in the middle <br>static CPOINT   cptLL;             // upper-left <br>static double   dPrecision;        // precision of draw <br>static LONGRECT rclPicture;        // rectangle defining client window <br>static DWORD    dwCurrentLine;     // next line to be drawn <br>static DWORD    dwThreshold;       // threshold for iterations <br> <br>/* <br> * Function prototypes for local procs <br> */ <br>DWORD CalcThreshold(double); <br> <br> <br>/* <br> *  InitRemote -- <br> * <br> *  This function initializes everything for our remote connections. <br> *  It gets the local wksta name (making sure the wksta is started) <br> *  and it creates the mailslot with which to collect replies to our poll. <br> * <br> *  RETURNS <br> *      TRUE    - initialization succeeded <br> *      FALSE   - initialization failed, can't go on <br> */ <br> <br>BOOL InitRemote(HWND hWnd) <br>{ <br> <br>#ifndef RPC <br>    UNREFERENCED_PARAMETER(hWnd); <br>#endif <br> <br>    // set up our local entry <br>    strcpy(SvrTable.name, "Local machine"); <br>    SvrTable.iStatus = SS_LOCAL; <br> <br>    // good, we succeeded <br>    return(TRUE); <br>} <br> <br> <br>/* <br> *  CheckDrawStatus -- <br> * <br> *  This function does a check of all buffers being drawn. <br> * <br> *  If it finds an idle pipe, and there is work to be done, it assigns <br> *      a line, and writes out the request. <br> *  If it finds a read-pending pipe, it checks if the read has completed. <br> *      If it has, it is read and a message is sent so the read data can <br> *      be processed. <br> * <br> *  RETURNS <br> *      TRUE    - we did a piece of work <br> *      FALSE   - we could not find any work to do. <br> */ <br> <br>BOOL CheckDrawStatus(HWND hwnd) <br>{ <br>    CALCBUF     cb; <br>    LPVOID      pbBuf; <br> <br>    while(TRUE) { <br> <br>        // Check the status <br>        switch(SvrTable.iStatus) { <br> <br>        case SS_PAINTING: <br>            break; <br> <br>        case SS_IDLE: <br>            break; <br> <br>        case SS_LOCAL: <br>            // Do a chunk of work locally <br> <br>#ifdef RPC <br>            if (fBound == FALSE) <br>                break; <br>#endif <br> <br>            if ((long) dwCurrentLine &gt; rclPicture.xRight) { <br>                if (fContinueZoom == TRUE) { <br>                    if ((fZoomIn == TRUE) &amp;&amp; (dPrec &lt; (double)MINPREC)) <br>                        fZoomIn = FALSE;  // start zooming out <br>                    if ((fZoomIn == FALSE) &amp;&amp; (dPrec &gt; (double)MAXPREC)) <br>                        fZoomIn = TRUE; <br>                    if (fZoomIn) { <br>                        CountHistogram(); <br>                        rcZoom.top    = iHistMaxJ * (WIDTH/4); <br>                        rcZoom.bottom = rcZoom.top + (WIDTH/4) - 1; <br>                        rcZoom.left   = iHistMaxI * (HEIGHT/4); <br>                        rcZoom.right  = rcZoom.left + (HEIGHT/4) - 1; <br>                        fRectDefined = TRUE; <br>                        PostMessage(hwnd, WM_COMMAND, IDM_ZOOMIN, 0L); <br>                    } <br>                    else <br>                        PostMessage(hwnd, WM_COMMAND, IDM_ZOOMOUT, 0L); <br>                } <br>                break; <br>            } <br> <br>            if (TakeDrawBuffer() == FALSE) <br>                break; <br> <br>            pbBuf = LockDrawBuffer(); <br> <br>            cb.rclDraw.xLeft = dwCurrentLine; <br>            cb.rclDraw.xRight = dwCurrentLine + iLines - 1; <br>            cb.rclDraw.yTop = rclPicture.yTop; <br>            cb.rclDraw.yBottom = rclPicture.yBottom; <br> <br>            RpcTryExcept { <br>                MandelCalc(&amp;cptLL, <br>                           &amp;(cb.rclDraw), <br>                           dPrecision, <br>                           dwThreshold, <br>                           (LINEBUF *) pbBuf); <br>            } <br>            RpcExcept(1) { <br>                char szFail[MSGLEN]; <br> <br>                sprintf (szFail, "%s (0x%x)\n", EXCEPT_MSG, RpcExceptionCode()); <br>                MessageBox(hwnd, <br>                           szFail, <br>                           "Remote Procedure Call", <br>                           MB_ICONINFORMATION); <br>                        KillTimer(hwnd, 1);  // stop timer for polls <br>                    EnableMenuItem(GetMenu(hwnd), IDM_GO, MF_ENABLED);  // enable GO <br>                    UnlockDrawBuffer(); <br> <br>                            ReturnDrawBuffer(); <br>                        return(FALSE); <br>            } <br>            RpcEndExcept <br> <br>            UnlockDrawBuffer(); <br> <br>            SvrTable.cPicture = cPictureID; <br>            SvrTable.dwLine = dwCurrentLine; <br>            SvrTable.cLines = iLines; <br> <br>            PostMessage(hwnd, WM_PAINTLINE, 0, 0L); <br>            dwCurrentLine += iLines; <br> <br>            return(TRUE); <br>        } <br> <br>        return(FALSE); <br>    } <br>} <br> <br> <br>/* <br> *  SetNewCalc -- <br> * <br> *  This sets up new information for a drawing and <br> *  updates the drawing ID so any calculations in progress will not <br> *  be mixed in. <br> */ <br> <br>void SetNewCalc(CPOINT cptUL, double dPrec, RECT rc) <br>{ <br>    // First, translate from upper left to lower left <br>    cptLL.real = cptUL.real; <br>    cptLL.imag = cptUL.imag - (dPrec * (rc.bottom - rc.top)); <br> <br>    // Now the precision <br>    dPrecision = dPrec; <br> <br>    // The rectangle. Once again, translate. <br>    rclPicture.xLeft = (long) rc.left; <br>    rclPicture.xRight = (long) rc.right; <br>    rclPicture.yBottom = (long) rc.top; <br>    rclPicture.yTop = (long) rc.bottom; <br> <br>    // Current line, start of drawing <br>    dwCurrentLine = rclPicture.xLeft; <br> <br>    dwThreshold = CalcThreshold(dPrecision); <br>} <br> <br> <br>void IncPictureID(void) <br>{ <br>    cPictureID++; <br>} <br> <br> <br>void ResetPictureID(void) <br>{ <br>    cPictureID = 0; <br>} <br> <br> <br>/* <br> *  CheckDrawing -- <br> * <br> *  Just a sanity check here -- a function to check to make sure that we're <br> *  on the right drawing <br> */ <br> <br>BOOL CheckDrawingID(int id) <br>{ <br>    return((id == cPictureID) ? TRUE : FALSE); <br>} <br> <br> <br>/* <br> *  TakeDrawBuffer ensures only one pipe read at a time. <br> *  LockDrawBuffer locks the handle and returns a pointer. <br> *  UnlockDrawBuffer unlocks the handle. <br> *  ReturnDrawBuffer lets another pipe read go. <br> *  FreeDrawBuffer ensures the allocated buffer is freed upon exit. <br> */ <br> <br>static BOOL fBufferTaken = FALSE; <br>static HANDLE hSharedBuf = (HANDLE) NULL; <br> <br> <br>BOOL TakeDrawBuffer(void) <br>{ <br>    if (fBufferTaken) { <br>        return(FALSE); <br>    } <br> <br>    if (hSharedBuf == (HANDLE) NULL) { <br>        hSharedBuf = LocalAlloc(LMEM_MOVEABLE, MAX_BUFSIZE); <br>        if (hSharedBuf == (HANDLE) NULL) <br>            return(FALSE); <br>    } <br> <br>    fBufferTaken = TRUE; <br>    return(TRUE); <br>} <br> <br> <br>LPVOID LockDrawBuffer(void) <br>{ <br>    if (hSharedBuf == (HANDLE) NULL) <br>        return(NULL); <br> <br>    return(LocalLock(hSharedBuf)); <br>} <br> <br> <br>void UnlockDrawBuffer(void) <br>{ <br>    LocalUnlock(hSharedBuf); <br>} <br> <br> <br>void ReturnDrawBuffer(void) <br>{ <br>    fBufferTaken = FALSE; <br>} <br> <br> <br>void FreeDrawBuffer(void) <br>{ <br>    if (hSharedBuf != (HANDLE) NULL) <br>        LocalFree(hSharedBuf); <br>} <br> <br> <br>/* <br> *  CalcThreshold -- <br> * <br> *  We need an iteration threshold beyond which we give up. We want it to <br> *  increase the farther we zoom in. This code generates a threshold value <br> *  based on the precision of drawing. <br> * <br> *  RETURNS <br> *      threshold calculated based on precision <br> */ <br> <br>DWORD CalcThreshold(double precision) <br>{ <br>    DWORD   thres = 25; <br>    double  multiplier = (double) 100.0; <br> <br>    /* for every 100, multiply by 2 */ <br>    while ((precision *= multiplier) &lt; (double)1.0) <br>        thres *= 2; <br> <br>    return(thres); <br>} <br> <br> <br>/* <br> *  QueryThreshold -- <br> * <br> *  Callback for finding out what the current drawing's threshold is. <br> */ <br> <br>DWORD QueryThreshold(void) <br>{ <br>    return(dwThreshold); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
