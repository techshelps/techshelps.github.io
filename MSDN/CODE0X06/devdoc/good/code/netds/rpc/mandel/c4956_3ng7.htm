<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MANDEL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4957"></a>MANDEL.C</h2>
<pre><code><br>/**************************************************************************** <br>                   Microsoft RPC Version 2.0 <br>           Copyright Microsoft Corp. 1992, 1993, 1994- 1996 <br>                        mandel Example <br> <br>    FILE:       mandel.c <br> <br>    PURPOSE:    Client side of the RPC distributed application <br> <br>    COMMENTS:   Main code for the Windows Mandelbrot Set distributed <br>                drawing program. <br> <br>****************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt;      // Required for all Windows applications <br>#include &lt;windowsx.h&gt;     // Allow portability from Win16, Win32 <br> <br>#ifdef RPC <br>#include "mdlrpc.h"       // header file generated by the MIDL compiler <br>#endif <br>#include "mandel.h" <br> <br> <br>/* data structures */ <br> <br>#ifdef RPC <br>char szTitle[] = "Mandelbrot RPC"; <br>#else <br>char szTitle[] = "Mandelbrot Standalone"; <br>#endif <br> <br>CPOINT      cptUL = { (double) -2.05, (double) 1.4 }; <br>double      dPrec = (double) .01; <br> <br>HANDLE      hInst;         // current instance <br>HWND        hWND;          // Main window handle <br> <br>svr_table   SvrTable; <br>int         iLines = LINES; <br> <br>int         fContinueZoom = TRUE; <br>int         fZoomIn       = TRUE; <br> <br>// split current picture into 16 regions <br>// zoom on most complex region;  region with most colors represented <br>int         Histogram[4][4][NCOLORS+1] = {0}; <br>int         ColorCount[4][4] = {0}; <br>int         Max[4][4] = {0}; <br> <br>int         iHistMaxI = 2; <br>int         iHistMaxJ = 3; <br> <br>RECT        rcZoom; <br>BOOL        fRectDefined = FALSE; <br> <br>#ifdef RPC <br>int             fBound = FALSE;     // flag indicates whether bound to svr <br>unsigned char * pszUuid             = NULL; <br>unsigned char pszProtocolSequence[MAXPROTSEQ] = "ncacn_np"; <br>unsigned char pszEndpoint[PATHLEN]            = "\\pipe\\mandel"; <br>unsigned char * pszOptions          = NULL; <br>unsigned char * pszStringBinding; <br>unsigned char   pszNetworkAddress[UNCLEN+1] = {'\0'}; <br>#endif <br> <br>/* function prototypes */ <br> <br>void     DoSomeWork(HWND, BOOL); <br>void     InitHistogram(void); <br>void     CalcHistogram(int, int, DWORD, DWORD); <br>void     PaintLine(HWND, svr_table *, HDC, int); <br>void     DrawRect(HWND, PRECT, BOOL, HDC); <br>COLORREF MapColor(DWORD, DWORD); <br> <br> <br>/* <br> *  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br> * <br> *  PURPOSE: Calls initialization function, processes message loop <br> * <br> *  COMMENTS: <br> * <br> *      Windows recognizes this function by name as the initial entry point <br> *      for the program.  This function calls the application initialization <br> *      routine, if no other instance of the program is running, and always <br> *      calls the instance initialization routine.  It then executes a message <br> *      retrieval and dispatch loop that is the top-level control structure <br> *      for the remainder of execution.  The loop is terminated when a WM_QUIT <br> *      message is received, at which time this function exits the application <br> *      instance by returning the value passed by PostQuitMessage(). <br> * <br> *      If this function must abort before entering the message loop, it <br> *      returns the conventional value NULL. <br> */ <br> <br>int WINAPI WinMain( <br>    HINSTANCE hInstance,            /* current instance         */ <br>    HINSTANCE hPrevInstance,        /* previous instance        */ <br>    LPSTR lpCmdLine,                /* command line             */ <br>    int nCmdShow)                   /* show-window type (open/icon) */ <br>{ <br> <br>    MSG msg; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br> <br>    if (!hPrevInstance)  /* Other instances of app running? */ <br>        if (!InitApplication(hInstance))  /* Initialize shared things */ <br>            return(FALSE);  /* Exits if unable to initialize */ <br> <br>    /* Perform initializations that apply to a specific instance */ <br>    if (!InitInstance(hInstance, nCmdShow)) <br>        return(FALSE); <br> <br>    /* Acquire and dispatch messages until a WM_QUIT message is received. */ <br>    while (GetMessage(&amp;msg,        /* message structure              */ <br>                      (HWND)NULL,  /* handle of window receiving the message */ <br>                      0,           /* lowest message to examine      */ <br>                      0))          /* highest message to examine     */ <br>    { <br>        TranslateMessage(&amp;msg);    /* Translates virtual key codes   */ <br>        DispatchMessage(&amp;msg);     /* Dispatches message to window   */ <br>    } <br> <br>    return(msg.wParam);  /* Returns the value from PostQuitMessage */ <br> <br>} <br> <br> <br>/* <br> *  FUNCTION: InitApplication(HANDLE) <br> * <br> *  PURPOSE: Initializes window data and registers window class <br> * <br> *  COMMENTS: <br> * <br> *      This function is called at initialization time only if no other <br> *      instances of the application are running.  This function performs <br> *      initialization tasks that can be done once for any number of running <br> *      instances. <br> * <br> *      In this case, we initialize a window class by filling out a data <br> *      structure of type WNDCLASS and calling the Windows RegisterClass() <br> *      function.  Since all instances of this application use the same window <br> *      class, we only need to do this when the first instance is initialized. <br> */ <br> <br>BOOL InitApplication(HANDLE hInstance)    /* current instance */ <br>{ <br> <br>    WNDCLASS  wc; <br> <br>    /* Fill in window class structure with parameters that describe the       */ <br>    /* main window.                                                           */ <br>    wc.style = 0;                       /* Class style(s).                    */ <br>    wc.lpfnWndProc = (WNDPROC)MainWndProc; <br>                                        /* Function to retrieve messages for  */ <br>                                        /* windows of this class.             */ <br>    wc.cbClsExtra = 0;                  /* No per-class extra data.           */ <br>    wc.cbWndExtra = 0;                  /* No per-window extra data.          */ <br>    wc.hInstance = hInstance;           /* Application that owns the class.   */ <br>    wc.hIcon = LoadIcon(hInstance, "RPC_ICON"); <br>    wc.hCursor = LoadCursor(0, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>    wc.lpszMenuName =  "MandelMenu";    /* Name of menu resource in .RC file. */ <br>    wc.lpszClassName = "MandelClass";   /* Name used in call to CreateWindow. */ <br> <br>    /* Register the window class and return success/failure code. */ <br>    return(RegisterClass(&amp;wc)); <br> <br>} <br> <br> <br>/* <br> *  FUNCTION:  InitInstance(HANDLE, int) <br> * <br> *  PURPOSE:  Saves instance handle and creates main window. <br> * <br> *  COMMENTS: <br> * <br> *      This function is called at initialization time for every instance of <br> *      this application.  This function performs initialization tasks that <br> *      cannot be shared by multiple instances. <br> * <br> *      In this case, we save the instance handle in a static variable and <br> *      create and display the main program window. <br> */ <br> <br>BOOL InitInstance(HANDLE   hInstance,   /* Current instance identifier.       */ <br>                  int      nCmdShow)    /* Param for first ShowWindow() call. */ <br>{ <br>    HMENU           hMenu; <br>    RECT            rc; <br> <br>    /* Save the instance handle in static variable, which will be used in  */ <br>    /* many subsequence calls from this application to Windows.            */ <br>    hInst = hInstance; <br> <br>    /* Create a main window for this application instance.  */ <br>    hWND = CreateWindow( <br>               "MandelClass",        /* See RegisterClass() call.          */ <br>               szTitle,              /* Text for window title bar.         */ <br>               WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_MINIMIZEBOX, <br>               CW_USEDEFAULT,        /* Default horizontal position.       */ <br>               CW_USEDEFAULT,        /* Default vertical position.         */ <br>               WIDTH,                /* Default width.                     */ <br>               HEIGHT,               /* Default height.                    */ <br>               (HWND) NULL,          /* Overlapped windows have no parent. */ <br>               (HMENU) NULL,         /* Use the window class menu.         */ <br>               hInstance,            /* This instance owns this window.    */ <br>               (LPVOID) NULL         /* Pointer not needed.                */ <br>           ); <br> <br>    /* If window could not be created, return "failure" */ <br>    if (!hWND) <br>        return(FALSE); <br> <br>    /* Make the window visible; update its client area; and return "success" */ <br>    ShowWindow(hWND, nCmdShow);  /* Show the window                */ <br>    UpdateWindow(hWND);          /* Sends WM_PAINT message         */ <br>    rc.top = rc.left = 0; <br>    rc.bottom = HEIGHT-1; <br>    rc.right = WIDTH-1; <br> <br>    SetNewCalc(cptUL, dPrec, rc); <br>    hMenu = GetMenu(hWND); <br> <br>#ifndef RPC <br>    EnableMenuItem(hMenu, IDM_SERVER, MF_GRAYED);  /* disable option */ <br>#endif <br> <br>    return(TRUE);               /* Returns the value from PostQuitMessage */ <br>} <br> <br> <br>/* <br> *  FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG) <br> * <br> *  PURPOSE:  Processes messages <br> * <br> *  MESSAGES: <br> *      WM_COMMAND    - application menu <br> *      WM_DESTROY    - destroy window <br> * <br> *  COMMENTS: <br> */ <br> <br>LONG APIENTRY MainWndProc( <br>    HWND hWnd,               /* window handle               */ <br>    UINT message,            /* type of message             */ <br>    UINT wParam,             /* additional information      */ <br>    LONG lParam)             /* additional information      */ <br>{ <br>    DLGPROC lpProc;          /* pointer to the dialog box function */ <br>    PAINTSTRUCT ps; <br>    HDC hdc; <br>    static HDC     hdcMem; <br>    static HBITMAP hbmMem; <br>    static int     width; <br>    static int     height; <br>    RECT           rc; <br>    static BOOL    fButtonDown = FALSE; <br>    static POINT   pSelected; <br>    POINT          pMove; <br>    int            iWidthNew; <br>    int            iHeightNew; <br>    static int     miOldLines; <br>    double         scaling; <br> <br>    switch (message) { <br> <br>    case WM_CREATE: <br> <br>#ifdef WIN16 <br>        RpcWinSetYieldInfo (hWnd, FALSE, 0, 0L); // To make TCP/IP happy <br>#else <br>        PostMessage(hWnd, WM_COMMAND, IDM_BIND, 0L);    // bind to server <br>#endif <br> <br>        if (!InitRemote(hWnd)) <br>            return(FALSE); <br> <br>        InitHistogram(); <br> <br>        hdc = GetDC(hWnd); <br>        hdcMem = CreateCompatibleDC(hdc); <br>        GetWindowRect(hWnd, &amp;rc); <br>        width = rc.right - rc.left; <br>        height = rc.bottom - rc.top; <br>        hbmMem = CreateCompatibleBitmap(hdc, width, height); <br>        SelectObject(hdcMem, hbmMem); <br> <br>        ReleaseDC(hWnd,hdc); <br> <br>        rc.left = rc.top = 0; <br>        rc.right = width+1; <br>        rc.bottom = height + 1; <br>        FillRect(hdcMem, &amp;rc, GetStockObject(WHITE_BRUSH)); <br> <br>        CheckMenuItem(GetMenu(hWnd), IDM_4LINES, MF_CHECKED); <br>        CheckMenuItem(GetMenu(hWnd), IDM_CONTINUOUS, MF_CHECKED); <br>        miOldLines = IDM_4LINES;  // save to uncheck <br>        break; <br> <br>    case WM_PAINT: <br>        hdc = BeginPaint(hWnd, &amp;ps); <br>        BitBlt(hdc, <br>               ps.rcPaint.left, <br>               ps.rcPaint.top, <br>               ps.rcPaint.right - ps.rcPaint.left, <br>               ps.rcPaint.bottom - ps.rcPaint.top, <br>               hdcMem, <br>               ps.rcPaint.left, <br>               ps.rcPaint.top, <br>               SRCCOPY); <br>        EndPaint(hWnd, &amp;ps); <br>        break; <br> <br>    case WM_COMMAND:  // message: command from application menu <br>        switch(wParam) { <br> <br>        case IDM_BIND: <br> <br>#ifdef RPC <br>            if (Bind(hWnd) != RPC_S_OK) <br>                PostMessage(hWnd, WM_DESTROY, 0, 0L); <br>#endif <br>            break; <br> <br>        case IDM_ABOUT: <br>            lpProc = MakeProcInstance(About, hInst); <br> <br>            DialogBox(hInst,       // current instance <br>                      "AboutBox",  // resource to use <br>                      hWnd,        // parent handle <br>                      lpProc);     // About() instance address <br> <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_ZOOMOUT: <br>            if (dPrec &gt; (double)MAXPREC)  // don't allow the zoom out <br>                break; <br> <br>            rcZoom.left = WIDTH/4 + (WIDTH/8);  // center square <br>            rcZoom.top   = HEIGHT/4 + (HEIGHT/8); <br>            rcZoom.right = rcZoom.left + (WIDTH/4); <br>            rcZoom.bottom = rcZoom.top + (HEIGHT/4); <br> <br>            cptUL.real -= (rcZoom.left * dPrec); // inverse of zoom in <br>            cptUL.imag += (rcZoom.top * dPrec); <br>            iWidthNew = (rcZoom.right - rcZoom.left + 1); <br>            iHeightNew = (rcZoom.bottom - rcZoom.top + 1); <br>            scaling = ((double) ((iWidthNew &gt; iHeightNew) ? iWidthNew : iHeightNew) / (double) width); <br>            dPrec /= scaling; <br> <br>            rc.left = rc.top = 0; <br>            rc.bottom = height - 1; <br>            rc.right = width - 1; <br> <br>            SetNewCalc(cptUL, dPrec, rc); <br>            fRectDefined = FALSE; <br>            DoSomeWork(hWnd, FALSE); <br>            break; <br> <br>        case IDM_ZOOMIN:  // zoom in on selected rectangle <br>            // if no rectangle, don't zoom in <br>            if (!fRectDefined) <br>                break; <br> <br>            if (dPrec &lt; (double)MINPREC)  // don't allow zoom in <br>                break; <br> <br>            DrawRect(hWnd, &amp;rcZoom, TRUE, hdcMem);  // draw new rect <br> <br>            // calculate new upper-left <br>            cptUL.real += (rcZoom.left * dPrec); <br>            cptUL.imag -= (rcZoom.top * dPrec); <br> <br>            iWidthNew = (rcZoom.right - rcZoom.left + 1); <br>            iHeightNew = (rcZoom.bottom - rcZoom.top + 1); <br>            scaling = ((double) ((iWidthNew &gt; iHeightNew) ? iWidthNew : iHeightNew) / (double) width); <br> <br>            dPrec *= scaling; <br> <br>            rc.left = rc.top = 0; <br>            rc.bottom = height - 1; <br>            rc.right = width - 1; <br> <br>            SetNewCalc(cptUL, dPrec, rc); <br>            IncPictureID(); <br> <br>            fRectDefined = FALSE; <br>            DoSomeWork(hWnd, FALSE); <br>            break; <br> <br>        case IDM_CONTINUOUS:  // continuous zoom in <br>            if (fContinueZoom == TRUE) { <br>                CheckMenuItem(GetMenu(hWnd), IDM_CONTINUOUS, MF_UNCHECKED); <br>                fContinueZoom = FALSE; <br>            } <br>            else { <br>                CheckMenuItem(GetMenu(hWnd), IDM_CONTINUOUS, MF_CHECKED); <br>                fContinueZoom = TRUE; <br>            } <br>            break; <br> <br>        case IDM_REDRAW: <br>            if (fContinueZoom == TRUE) <br>                InitHistogram(); <br> <br>            rc.left = rc.top = 0; <br>            rc.right = width+1; <br>            rc.bottom = height + 1; <br>            FillRect(hdcMem, &amp;rc, GetStockObject(WHITE_BRUSH)); <br>            InvalidateRect(hWnd, NULL, TRUE); <br> <br>            rc.left = rc.top = 0; <br>            rc.bottom = height - 1; <br>            rc.right = width - 1; <br>            SetNewCalc( cptUL, dPrec, rc); <br> <br>            fRectDefined = FALSE; <br>            DoSomeWork(hWnd, FALSE); <br>            break; <br> <br>        case IDM_EXIT: <br>            DestroyWindow(hWnd); <br>            FreeDrawBuffer(); <br>            break; <br> <br>        case IDM_TOP: <br>            cptUL.real = (double) -2.05; <br>            cptUL.imag = (double) 1.4; <br>            dPrec = .01; <br> <br>            rc.left = rc.top = 0; <br>            rc.bottom = height - 1; <br>            rc.right = width - 1; <br> <br>            SetNewCalc(cptUL, dPrec, rc); <br>            ResetPictureID();  // incremented past original <br> <br>            fRectDefined = FALSE; <br>            DoSomeWork(hWnd, FALSE); <br>            break; <br> <br>        case IDM_1LINE: <br> <br>        case IDM_2LINES: <br> <br>        case IDM_4LINES: <br> <br>            CheckMenuItem(GetMenu(hWnd), miOldLines, MF_UNCHECKED); <br>            miOldLines = wParam; <br>            switch(wParam) { <br> <br>            case IDM_1LINE: <br>                iLines = 1; <br>                break; <br>            case IDM_2LINES: <br>                iLines = 2; <br>                break; <br>            case IDM_4LINES: <br>                iLines = 4; <br>                break; <br>            } <br> <br>            CheckMenuItem(GetMenu(hWnd), miOldLines, MF_CHECKED); <br>            break; <br> <br>#ifdef RPC <br>        case IDM_PROTSEQ: <br>            lpProc = MakeProcInstance(Protseq, hInst); <br>            DialogBox(hInst,        // current instance <br>                      "ProtseqBox", // resource to use <br>                      hWnd,         // parent handle <br>                      lpProc);      // Server instance address <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_SERVER: <br>            lpProc = MakeProcInstance(Server, hInst); <br>            DialogBox(hInst,         // current instance <br>                      "ServerBox",   // resource to use <br>                      hWnd,          // parent handle <br>                      lpProc);       // Server  instance address <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_ENDPOINT: <br>            lpProc = MakeProcInstance(Endpoint, hInst); <br>            DialogBox(hInst,        // current instance <br>                      "EndpointBox",// resource to use <br>                      hWnd,         // parent handle <br>                      lpProc);      // Server instance address <br>            FreeProcInstance(lpProc); <br>            break; <br>#endif <br>        case IDM_GO: <br>                SetTimer(hWnd, 1, POLL_TIME, NULL);  // set timer for polls <br>            EnableMenuItem(GetMenu(hWnd), IDM_GO, MF_GRAYED);   // disable GO <br>            break; <br> <br> <br>        default:  // Lets Windows process it <br>            return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>        } <br> <br>        break; <br> <br>    case WM_DESTROY:  // message: window being destroyed <br>        PostQuitMessage(0); <br>        DeleteDC(hdcMem); <br>        DeleteObject(hbmMem); <br>        break; <br> <br>    case WM_DOSOMEWORK:  // do another slice of calculation work <br>        DoSomeWork(hWnd, FALSE); <br>        break; <br> <br>    case WM_PAINTLINE:  // The shared buffer contains a line of data; draw it <br>        PaintLine(hWnd, <br>                  &amp;SvrTable, <br>                  hdcMem, <br>                  height); <br>        break; <br> <br>    case WM_TIMER:  // timer means we should do another slice of work <br>        DoSomeWork(hWnd, TRUE); <br>        break; <br> <br>    case WM_LBUTTONDOWN:  // left button down; start to define a zoom rectangle <br>        if (fRectDefined) <br>            DrawRect(hWnd, &amp;rcZoom, FALSE, hdcMem);  // undraw old rectangle <br> <br>        // initialize rectangle <br>        rcZoom.left = rcZoom.right = pSelected.x = LOWORD(lParam); <br>        rcZoom.top = rcZoom.bottom = pSelected.y = HIWORD(lParam); <br> <br>        // draw the new rectangle <br>        DrawRect(hWnd, &amp;rcZoom, TRUE, hdcMem); <br> <br>        fRectDefined = TRUE; <br>        fButtonDown = TRUE; <br>        SetCapture(hWnd);  // capture all mouse events <br>        break; <br> <br>    case WM_MOUSEMOVE:  // mouse move <br>        // if the button is down, change the rect <br>        if (!fButtonDown) <br>            break; <br> <br>        DrawRect(hWnd, &amp;rcZoom, FALSE, hdcMem);  // undraw old rect <br> <br>        pMove.x = LOWORD(lParam); <br>        pMove.y = HIWORD(lParam); <br> <br>        // update the selection rectangle <br>        if (pMove.x &lt;= pSelected.x) <br>            rcZoom.left = pMove.x; <br>        if (pMove.x &gt;= pSelected.x) <br>            rcZoom.right = pMove.x; <br>        if (pMove.y &lt;= pSelected.y) <br>            rcZoom.top = pMove.y; <br>        if (pMove.y &gt;= pSelected.y) <br>            rcZoom.bottom = pMove.y; <br> <br>        DrawRect(hWnd, &amp;rcZoom, TRUE, hdcMem);  // draw new rect <br>        break; <br> <br>    case WM_LBUTTONUP:  // button up; end selection <br>        fButtonDown = FALSE; <br>        ReleaseCapture(); <br>        break; <br> <br>    default:  // Passes it on if unproccessed <br>        return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>    } <br> <br>    return(0L); <br>} <br> <br> <br>/* <br> *  FUNCTION: About(HWND, unsigned, WORD, LONG) <br> * <br> *  PURPOSE:  Processes messages for "About" dialog box <br> * <br> *  MESSAGES: <br> * <br> *      WM_INITDIALOG - initialize dialog box <br> *      WM_COMMAND    - Input received <br> * <br> *  COMMENTS: <br> * <br> *      No initialization is needed for this particular dialog box, but TRUE <br> *      must be returned to Windows. <br> * <br> *      Wait for user to click on "Ok" button, then close the dialog box. <br> */ <br> <br>BOOL APIENTRY About( <br>    HWND hDlg,              /* window handle of the dialog box */ <br>    UINT message,           /* type of message                 */ <br>    UINT wParam,            /* message-specific information    */ <br>    LONG lParam) <br>{ <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:     /* message: initialize dialog box  */ <br>        return(TRUE); <br> <br>    case WM_COMMAND:        /* message: received a command     */ <br>        if (wParam == IDOK || wParam == IDCANCEL) <br>        { <br>            EndDialog(hDlg, TRUE);    /* Exits the dialog box  */ <br>            return(TRUE); <br>        } <br>        break; <br>    } <br> <br>    return(FALSE);          /* Didn't process a message        */ <br>} <br> <br> <br> <br>/* <br> *  FUNCTION: Protseq(HWND, unsigned, WORD, LONG) <br> * <br> *  PURPOSE:  Processes messages for "Protseq" dialog box <br> * <br> *  MESSAGES: <br> * <br> *      WM_INITDIALOG - initialize dialog box <br> *      WM_COMMAND    - Input received <br> * <br> *  COMMENTS: <br> * <br> *      No initialization is needed for this particular dialog box, but TRUE <br> *      must be returned to Windows. <br> * <br> *      Wait for user to click on "Ok" button, then close the dialog box. <br> */ <br>BOOL APIENTRY Protseq( <br>    HWND hDlg,               /* window handle of the dialog box */ <br>    UINT message,            /* type of message             */ <br>    UINT wParam,             /* message-specific information    */ <br>    LONG lParam) <br>{ <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>#ifdef RPC <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:    // message: initialize dialog box <br>        SetDlgItemText((HANDLE)hDlg, IDD_PROTSEQNAME, pszProtocolSequence); <br>        return(TRUE); <br> <br>    case WM_COMMAND:       // message: received a command <br>        switch(wParam) { <br> <br>        case IDCANCEL:     // System menu close command? <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK:         // "OK" box selected? <br>            GetDlgItemText(hDlg, IDD_PROTSEQNAME, pszProtocolSequence, MAXPROTSEQ); <br> <br>            if (Bind(hDlg) != RPC_S_OK) { <br>                EndDialog(hDlg, FALSE); <br>                return(FALSE); <br>            } <br>                KillTimer(hWND, 1);  // stop timer for polls <br>            EnableMenuItem(GetMenu(hWND), IDM_GO, MF_ENABLED);  // enable GO <br> <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br> <br>        } <br> <br>    } <br> <br>#endif <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>/* <br> *  FUNCTION: Server(HWND, unsigned, WORD, LONG) <br> * <br> *  PURPOSE:  Processes messages for "Server" dialog box <br> * <br> *  MESSAGES: <br> * <br> *      WM_INITDIALOG - initialize dialog box <br> *      WM_COMMAND    - Input received <br> * <br> *  COMMENTS: <br> * <br> *      No initialization is needed for this particular dialog box, but TRUE <br> *      must be returned to Windows. <br> * <br> *      Wait for user to click on "Ok" button, then close the dialog box. <br> */ <br> <br>BOOL APIENTRY Server( <br>    HWND hDlg,               /* window handle of the dialog box */ <br>    UINT message,            /* type of message             */ <br>    UINT wParam,             /* message-specific information    */ <br>    LONG lParam) <br>{ <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>#ifdef RPC <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:      /* message: initialize dialog box */ <br>        SetDlgItemText(hDlg, IDD_SERVERNAME, pszNetworkAddress); <br>        return(TRUE); <br> <br>    case WM_COMMAND:         /* message: received a command    */ <br>        switch(wParam) { <br> <br>        case IDCANCEL:       /* System menu close command?     */ <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK:            /* "OK" box selected?            */ <br>            GetDlgItemText( hDlg, IDD_SERVERNAME, pszNetworkAddress, UNCLEN); <br> <br>            if (Bind(hDlg) != RPC_S_OK) { <br>                EndDialog(hDlg, FALSE); <br>                return(FALSE); <br>            } <br>                KillTimer(hWND, 1);  // stop timer for polls <br>            EnableMenuItem(GetMenu(hWND), IDM_GO, MF_ENABLED);  // enable GO <br> <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br>        } <br> <br>    } <br> <br>#endif <br> <br>    return(FALSE);           /* Didn't process a message      */ <br> <br>} <br> <br>/* <br> *  FUNCTION: Endpoint(HWND, unsigned, WORD, LONG) <br> * <br> *  PURPOSE:  Processes messages for "Endpoint" dialog box <br> * <br> *  MESSAGES: <br> * <br> *      WM_INITDIALOG - initialize dialog box <br> *      WM_COMMAND    - Input received <br> * <br> *  COMMENTS: <br> * <br> *      No initialization is needed for this particular dialog box, but TRUE <br> *      must be returned to Windows. <br> * <br> *      Wait for user to click on "Ok" button, then close the dialog box. <br> */ <br> <br>BOOL APIENTRY Endpoint( <br>    HWND hDlg,               /* window handle of the dialog box */ <br>    UINT message,            /* type of message             */ <br>    UINT wParam,             /* message-specific information    */ <br>    LONG lParam) <br>{ <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>#ifdef RPC <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:    // message: initialize dialog box <br>        SetDlgItemText(hDlg, IDD_ENDPOINTNAME, pszEndpoint); <br>        return(TRUE); <br> <br>    case WM_COMMAND:       // message: received a command <br>        switch(wParam) { <br> <br>        case IDCANCEL: <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK: <br>            GetDlgItemText(hDlg, IDD_ENDPOINTNAME, pszEndpoint, PATHLEN); <br> <br>            if (Bind(hDlg) != RPC_S_OK) { <br>                EndDialog(hDlg, FALSE); <br>                return(FALSE); <br>            } <br>                KillTimer(hWND, 1);  // stop timer for polls <br>            EnableMenuItem(GetMenu(hWND), IDM_GO, MF_ENABLED);  // enable GO <br> <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br> <br>        } <br> <br>    } <br> <br>#endif <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>/* <br> *  DoSomeWork -- <br> * <br> *  This function does our work for us. It does it in little pieces, and <br> *  will schedule itself as it sees fit. <br> */ <br> <br>void <br>DoSomeWork(HWND    hwnd, <br>           BOOL    fTimer) <br>{ <br>    static WORD   wIteration = 0; <br> <br>    if (fTimer) { <br>        wIteration++; <br> <br>        // on every nth tick, we send out a poll <br>        if (wIteration == 120) {  // tune this? <br>            wIteration = 0; <br>            return; <br>        } <br> <br>        // on the half-poll, we check for responses <br>        if ((wIteration == 2) || (wIteration == 10)) { <br>            return; <br>        } <br>    } <br> <br>    if (CheckDrawStatus(hwnd)) <br>        SendMessage(hwnd, WM_DOSOMEWORK, 0, 0L); <br> <br>    return; <br>} <br> <br> <br>/* <br> *  DrawRect -- <br> * <br> *  This function draws (or undraws) the zoom rectangle. <br> */ <br> <br>void <br>DrawRect(HWND      hwnd, <br>         PRECT     prc, <br>         BOOL      fDrawIt, <br>         HDC       hdcBM) <br>{ <br>    HDC     hdc; <br>    DWORD   dwRop; <br> <br>    hdc = GetDC(hwnd); <br> <br>    if (fDrawIt) <br>        dwRop = NOTSRCCOPY; <br>    else <br>        dwRop = SRCCOPY; <br> <br>    // top side <br>    BitBlt(hdc, prc-&gt;left, prc-&gt;top, (prc-&gt;right - prc-&gt;left) + 1, <br>           1, hdcBM, prc-&gt;left, prc-&gt;top, dwRop); <br> <br>    // bottom side <br>    BitBlt(hdc, prc-&gt;left, prc-&gt;bottom, (prc-&gt;right - prc-&gt;left) + 1, <br>           1, hdcBM, prc-&gt;left, prc-&gt;bottom, dwRop); <br> <br>    // left side <br>    BitBlt(hdc,prc-&gt;left, prc-&gt;top, 1, (prc-&gt;bottom - prc-&gt;top) + 1, <br>           hdcBM, prc-&gt;left, prc-&gt;top, dwRop); <br> <br>    // right side <br>    BitBlt(hdc,prc-&gt;right, prc-&gt;top, 1, (prc-&gt;bottom - prc-&gt;top) + 1, <br>           hdcBM, prc-&gt;right, prc-&gt;top, dwRop); <br> <br>    ReleaseDC(hwnd, hdc); <br>} <br> <br> <br>/* <br> *  PaintLine -- <br> * <br> *  This function paints a buffer of data into the bitmap. <br> */ <br> <br>void <br>PaintLine(HWND        hwnd, <br>          svr_table * pst, <br>          HDC         hdcBM, <br>          int         cHeight) <br>{ <br>    LPWORD  pwDrawData; <br>    int     y; <br>    int     x; <br>    DWORD   dwThreshold; <br>    RECT    rc; <br>    WORD    lines; <br> <br>    lines  = (WORD) pst-&gt;cLines; <br> <br>    // picture ID had better match, or else we skip it <br>    if (CheckDrawingID(pst-&gt;cPicture)) <br>    { <br>        // figure out our threshold <br>        dwThreshold = QueryThreshold(); <br> <br>        // get a pointer to the draw buffer <br>        pwDrawData = (LPWORD) LockDrawBuffer(); <br>        if (pwDrawData == NULL) { <br>            ReturnDrawBuffer(); <br>            return; <br>        } <br> <br>        // starting x coordinate <br>        x = (int) pst-&gt;dwLine; <br> <br>        // now loop through the rectangle <br>        while (lines-- &gt; 0) <br>        { <br>            // bottom to top, since that's the order of the data in the buffer <br>            y = (int) cHeight-1; <br> <br>            while (y &gt;= 0) <br>            { <br>                // draw a pixel <br>                SetPixel(hdcBM, x,y, MapColor(*pwDrawData, dwThreshold)); <br> <br>                if (fContinueZoom == TRUE) <br>                    CalcHistogram(x, y, *pwDrawData, dwThreshold); <br> <br>                // now increment buffer pointer and y coord </code></pre>
<p>
</p>
<pre><code>y--; <br>                pwDrawData++; <br>            } <br> <br>            // increment X coordinate <br>            x++; <br>        } <br> <br>        // figure out the rectangle to invalidate <br>        rc.top = 0; <br>        rc.bottom = cHeight; <br>        rc.left = (int)(pst-&gt;dwLine); <br>        rc.right = (int)(pst-&gt;dwLine) + pst-&gt;cLines; <br> <br>        UnlockDrawBuffer(); <br> <br>        // and invalidate it on the screen so we redraw it <br>        InvalidateRect(hwnd, &amp;rc, FALSE); <br>    } <br> <br>    // free this for someone else to use <br>    ReturnDrawBuffer(); <br> <br>    // and change the pipe state, if necessary <br>    if (pst-&gt;iStatus == SS_PAINTING) <br>        pst-&gt;iStatus = SS_IDLE; <br> <br>} <br> <br> <br>#define CLR_BLACK       RGB(0,0,0) <br>#define CLR_DARKBLUE    RGB(0,0,127) <br>#define CLR_BLUE        RGB(0,0,255) <br>#define CLR_CYAN        RGB(0,255,255) <br>#define CLR_DARKGREEN   RGB(0,127,0) <br>#define CLR_GREEN       RGB(0,255,0) <br>#define CLR_YELLOW      RGB(255,255,0) <br>#define CLR_RED         RGB(255,0,0) <br>#define CLR_DARKRED     RGB(127,0,0) <br>#define CLR_WHITE       RGB(255,255,255) <br>#define CLR_PALEGRAY    RGB(194,194,194) <br>#define CLR_DARKGRAY    RGB(127,127,127) <br> <br> <br>static COLORREF ColorMapTable[] = {     // size = NCOLORS <br>    CLR_DARKBLUE, <br>    CLR_BLUE, <br>    CLR_CYAN, <br>    CLR_DARKGREEN, <br>    CLR_GREEN, <br>    CLR_YELLOW, <br>    CLR_RED, <br>    CLR_DARKRED, <br>    CLR_WHITE, <br>    CLR_PALEGRAY, <br>    CLR_DARKGRAY}; <br> <br> <br>/* <br> *  MapColor -- <br> * <br> *  This function maps an iteration count into a corresponding RGB color. <br> */ <br> <br>COLORREF <br>MapColor(DWORD  dwIter, <br>         DWORD  dwThreshold) <br>{ <br> <br>    /* if it's beyond the threshold, call it black */ <br>    if (dwIter &gt;= dwThreshold) { <br>        return(CLR_BLACK); <br>    } <br> <br>    /* get a modulus based on the number of colors */ <br>    dwIter = (dwIter / 3) % NCOLORS; // 11; <br> <br>    /* and return the appropriate color */ <br>    return(ColorMapTable[dwIter]); <br> <br>} <br> <br> <br>/* <br> * CalcHistogram -- <br> * <br> * This function is used to select the region that is the <br> * most complex and will be used to zoom in for the next picture; <br> * it contains the most colors.  The number of colors are counted. <br> */ <br> <br>void <br>CalcHistogram(int    x, <br>              int    y, <br>              DWORD  dwIter, <br>              DWORD  dwThreshold) <br>{ <br> <br>    /* if it's beyond the threshold, call it black */ <br>    if (dwIter &gt;= dwThreshold) { <br>        Histogram[x/(WIDTH/4)][y/(HEIGHT/4)][NCOLORS]++; <br>        return; <br>    } <br> <br>    /* get a modulus based on the number of colors */ <br>    dwIter = (dwIter / 3) % NCOLORS; // 11; <br> <br>    /* and bump the count for the appropriate color */ <br>    Histogram[x/(WIDTH/4)][y/(HEIGHT/4)][dwIter]++;  // region of map <br> <br>    return; <br> <br>} <br> <br> <br>/* <br> * InitHistogram -- <br> * <br> * This function initializes the histogram data structures. <br> */ <br> <br>void InitHistogram(void) <br>{ <br>    int i, j, k; <br> <br>    for (i = 0; i &lt; 4; i++) <br>        for (j = 0; j &lt; 4; j++) <br>            for (k = 0; k &lt;= NCOLORS; k++) <br>                Histogram[i][j][k] = 0;  // count of colors <br>} <br> <br> <br>/* <br> * CountHistogram -- <br> * <br> * This function determines the number of colors represented <br> * within a region.  The region with the most colors is <br> * selected using the maxi and maxj values.  X and Y coordinates <br> * corresponding to these regions are stored in the HistRegion <br> * table and are used for the next picture. <br> */ <br> <br>void CountHistogram(void) <br>{ <br> <br>    int i, j, k; <br> <br>    /* count the number of colors in each region */ <br>    /* find the color that dominates each region */ <br>    for (i = 0; i &lt; 4; i++) { <br>        for (j = 0; j &lt; 4; j++) { <br>            ColorCount[i][j] = 0; <br>            Max[i][j] = 0; <br>            for (k = 0; k &lt;= NCOLORS; k++) { <br>                if (Histogram[i][j][k] &gt; Max[i][j]) <br>                    Max[i][j] = Histogram[i][j][k]; <br>                if (Histogram[i][j][k] != 0)  // count of colors <br>                    ColorCount[i][j]++; <br>            } <br>        } <br>    } <br> <br>    iHistMaxI = 0; <br>    iHistMaxJ = 0; <br> <br>    /* if several regions have the same number of colors,        */ <br>    /* select the region with the most variety: the smallest max */ <br>    for (i = 0; i &lt; 4; i++) { <br>        for (j = 0; j &lt; 4; j++) { <br>            if (   (ColorCount[i][j] &gt;= ColorCount[iHistMaxI][iHistMaxJ]) <br>                &amp;&amp; (Max[i][j] &lt; Max[iHistMaxI][iHistMaxJ]) ) { <br>                iHistMaxI = i; <br>                iHistMaxJ = j; <br>            } <br>        } <br>    } <br> <br>    InitHistogram();  // initialize for next time <br> <br>} <br> <br> <br>#ifdef RPC <br> <br>void __RPC_FAR * __RPC_API midl_user_allocate(size_t len) <br>{ <br>    UNREFERENCED_PARAMETER(len); <br>    return(NULL); <br>} <br> <br> <br>void __RPC_API midl_user_free(void __RPC_FAR * ptr) <br>{ <br>    UNREFERENCED_PARAMETER(ptr); <br>    return; <br>} <br> <br> <br>/* <br> *  FUNCTION: Bind(HWND) <br> * <br> *  PURPOSE:  Make RPC API calls to bind to the server application <br> * <br> *  COMMENTS: <br> * <br> *      The binding calls are made from InitInstance() and whenever <br> *      the user changes the server name or endpoint. If the bind <br> *      operation is successful, the global flag fBound is set to TRUE. <br> * <br> *      The global flag fBound is used to determine whether to call <br> *      the RPC API function RpcBindingFree. <br> */ <br> <br>RPC_STATUS Bind(HWND hWnd) <br>{ <br>    RPC_STATUS status; <br>    char pszFail[MSGLEN]; <br> <br>    if (fBound == TRUE) {  // unbind only if bound <br>        status = RpcStringFree(&amp;pszStringBinding); <br>        if (status) { <br>            sprintf(pszFail, "RpcStringFree failed 0x%x", status); <br>            MessageBox(hWnd, <br>                       pszFail, <br>                       "RPC Sample Application", <br>                       MB_ICONSTOP); <br>            return(status); <br>        } <br> <br>        status = RpcBindingFree(&amp;hMandel); <br>        if (status) { <br>            sprintf(pszFail, "RpcBindingFree failed 0x%x", status); <br>            MessageBox(hWnd, <br>                       pszFail, <br>                       "RPC Sample Application", <br>                       MB_ICONSTOP); <br>            return(status); <br>        } <br> <br>        fBound = FALSE;  // unbind successful; reset flag <br>    } <br> <br>    status = RpcStringBindingCompose(pszUuid, <br>                                     pszProtocolSequence, <br>                                     pszNetworkAddress, <br>                                     pszEndpoint, <br>                                     pszOptions, <br>                                     &amp;pszStringBinding); <br>    if (status) { <br>        sprintf(pszFail, "RpcStringBindingCompose returned: (0x%x)\nNetwork Address = %s\n", <br>              status, pszNetworkAddress); <br>        MessageBox(hWnd, pszFail, "RPC Sample Application", MB_ICONINFORMATION); <br>        return(status); <br>    } <br> <br>    status = RpcBindingFromStringBinding(pszStringBinding, <br>                                         &amp;hMandel); <br>    if (status) { <br>        sprintf(pszFail, "RpcBindingFromStringBinding returned: (0x%x)\nString = %s\n", <br>             status, pszStringBinding); <br>        MessageBox(hWnd, pszFail, "RPC Sample Application", MB_ICONINFORMATION); <br>        return(status); <br>    } <br> <br>    fBound = TRUE;  // bind successful; reset flag <br> <br>    return(status); <br>} <br> <br>#endif <br> <br> <br>/* end mandel.c */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
