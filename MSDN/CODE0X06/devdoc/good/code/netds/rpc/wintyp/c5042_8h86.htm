<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5046"></a>CLIENT.C</h2>
<pre><code>/************************************************************************* <br>                        Copyright Microsoft Corp. 1992-1996 <br>                            Remote Machine WinType sample <br> <br>    FILE        :   CLIENT.C <br> <br>    PURPOSE     :   Client side of the RPC distributed application wintyp <br> <br>    COMMENTS    :   This program shows the client side an application that <br>                    transfers a Windows datatype (HBITMAP) from the client <br>                    to the server, using Remote Procedure Calls. When the <br>                    Bitmap is received on the server end, it modifies the <br>                    bitmap, and sends it back. <br> <br>                    Since this program uses the implicit binding method,  <br>                    some of the binding handling must be done at the  <br>                    client side. <br> <br>*************************************************************************/ <br>#include &lt;windows.h&gt;            // Required for all Windows programs <br>#include &lt;commdlg.h&gt;            // Support for the common dialogboxes <br> <br>#include "common.h"             // Common headerfile for client and server <br>#include "client.h"             // Header file for the client <br>#include "clires.h"             // Definitions for the resource file <br>#include "wintyp.h"             // Generated by the MIDL compiler <br> <br>TCHAR   szBuffer[200];          // Buffer used for printing messages <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>//  Procedure   :   WinMain() <br>//  Desc.       :   Windows main procedure. Calls up the initialization  <br>//                  of the program , and starts up the message pump <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>int WINAPI WinMain  (HINSTANCE  hInstance, <br>                     HINSTANCE  hPrevInstance, <br>                     LPSTR      lpszCmdLine, <br>                     int        nCmdShow) <br>{ <br>    MSG         uMsg;           // The message struct <br>    HACCEL      hAccels;        // Handle to the accelerators <br> <br>    // Set the global instance <br>    g_hInstance = hInstance; <br> <br>    // Perform registration of the class and create the window <br>    if(!Init()) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Display the window <br>    ShowWindow(g_hWnd, nCmdShow); <br> <br>    // Load the accelerators <br>    hAccels = LoadAccelerators(hInstance, <br>        MAKEINTRESOURCE(IDR_ACCELERATOR1)); <br> <br>    // Add a message pump to take care of messages <br>    while (GetMessage(&amp;uMsg, NULL, 0, 0))    // NULL only for WM_QUIT msg. <br>    { <br>        if(!TranslateAccelerator(g_hWnd, hAccels, &amp;uMsg)) <br>        { <br>            TranslateMessage(&amp;uMsg); <br>            DispatchMessage(&amp;uMsg); <br>        } <br>    } <br>     <br>    return uMsg.wParam; <br>} <br> <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Function :   Init() <br>// Purpose  :   This function is called once from the start of the program  <br>//              It will register the window class, create the window, and  <br>//              perform the binding to the server. <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>BOOL Init() <br>{ <br>    WNDCLASS    sWC;                        // The window class <br>     <br>    // Fill in the fields of the window class struct <br>    sWC.style = 0;                          // Style info <br>    sWC.lpfnWndProc  = (WNDPROC) ClientProc;// Proc. to handle messsages <br>    sWC.cbClsExtra   = 0;                   // Extra bytes for class <br>    sWC.cbWndExtra   = 0;                   // Extra bytes for window <br>    sWC.hInstance    = g_hInstance;         // Handle to current instance <br>    sWC.hIcon        = LoadIcon(g_hInstance,// Handle to icon for class <br>        MAKEINTRESOURCE(IDI_CLIENT_ICON));       <br>    sWC.hCursor      = LoadCursor(NULL, IDC_ARROW); // Handle to cursor  <br>    sWC.hbrBackground= GetStockObject(GRAY_BRUSH);  // Brush for backgr. <br>    sWC.lpszMenuName = <br>        MAKEINTRESOURCE(IDR_CLIENT_MENU);           // Name of menu to use <br>    sWC.lpszClassName= g_szClassName;               // Class name <br>     <br>    // Register the window class <br>    if(!RegisterClass(&amp;sWC)) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Create the window <br>    g_hWnd = CreateWindowEx( <br>        0,                      // Style <br>        g_szClassName,          // The class name <br>        g_szWindowCaption,      // Caption showed at top of window <br>        WS_OVERLAPPEDWINDOW,    // The window style <br>        CW_USEDEFAULT,          // x-coordinate <br>        CW_USEDEFAULT,          // y-coordinate <br>        CW_USEDEFAULT,          // Width of window <br>        CW_USEDEFAULT,          // Height of window <br>        NULL,                   // Parent window <br>        NULL,                   // Menu <br>        g_hInstance,            // Handle to current instance    <br>        NULL);                  // lpvParam <br> <br>    // Return false if creation failed <br>    if(g_hWnd == NULL) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Initialize the binding address <br>    pszNetworkAddress[0] = 0; <br>    _tcscpy(pszEndpoint, END_POINT); <br>    _tcscpy(pszProtocolSequence, PROTOCOL_SEQUENCE); <br> <br>    // Create the binding <br>    if(Bind(g_hWnd) != RPC_S_OK) <br>    { <br>        return FALSE; <br>    } <br> <br>    return TRUE;                // Initialization OK <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   ClientWindowProc() <br>// Desc.        :   This procedure takes care of all the message handling  <br>//                  from the client main program <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>LRESULT CALLBACK    ClientProc(HWND   hWnd, <br>                               UINT    uMsg, <br>                               WPARAM  wParam, <br>                               LPARAM  lParam) <br>{ <br>    PAINTSTRUCT sPS;                        // The paintstructure <br>    HDC         hDC = GetDC(g_hWnd);        // Handle to the screen <br>    HMENU       hMenu = GetMenu(g_hWnd);    // Handle to the menu <br>    RECT        sRect; <br> <br>    switch(uMsg) <br>    { <br>        case WM_COMMAND : <br>    switch(LOWORD(wParam)) <br>            { <br>                case    IDM_MENU_FILE_OPEN  :       // File open was chosen <br>                    // Get the filename to read <br>                    if(GetBitmapFileName()) <br>                    { <br>                        // Read the data from the file. This call will fill <br>                        // out the global variables g_hBitmap and g_Bitmap <br>                        if(!ReadBitmapFromFile()) <br>                        { <br>                            break; <br>                        } <br>             <br>                        // Resize the client area to fit the image <br>                        GetWindowRect(g_hWnd, &amp;sRect); <br>                        MoveWindow(g_hWnd,          // Handle to the window <br>                            sRect.left,             // New X position <br>                            sRect.top,              // New Y position <br>                            g_Bitmap.bmWidth +      // New width <br>                            GetSystemMetrics(SM_CXSIZEFRAME) * 2, <br>                            g_Bitmap.bmHeight +     // The new height <br>                            GetSystemMetrics(SM_CYSIZEFRAME) * 2 + <br>                            GetSystemMetrics(SM_CYMENUSIZE) +    <br>                            GetSystemMetrics(SM_CYCAPTION),      <br>                            TRUE);                  // Make a repaint <br> <br>                        // Force an update of the screen <br>                        GetClientRect(g_hWnd, &amp;sRect); <br>                        InvalidateRect(g_hWnd, &amp;sRect, TRUE); <br>                        UpdateWindow(g_hWnd); <br> <br>                        // Enable the rest of the menu options <br>                        EnableMenuItem(hMenu, IDM_MENU_FILE_CLOSE,  <br>                            MF_ENABLED); <br>                        if(GetDeviceCaps(hDC, BITSPIXEL) == 8) <br>                        { <br>                            EnableMenuItem(hMenu, IDM_MENU_TOOLS_EDGE,  <br>                                MF_ENABLED); <br>                        } <br>                        EnableMenuItem(hMenu, IDM_MENU_TOOLS_FLIP,  <br>                            MF_ENABLED); <br>                    }   // if(GetBitmapFileName()) <br>                    break; <br> <br>                case    IDM_MENU_FILE_CLOSE :   // File close was chosen <br>                    // If a bitmap has been read in, redraw the client  <br>                    // area to the background color. <br>                    if(BITMAP_READ) <br>                    { <br>                        // Reset the BITMAP_READ indicator <br>                        BITMAP_READ = FALSE; <br> <br>                        // Rewrite the screen <br>                        RedrawClientArea(hDC); <br> <br>                        // Disable the menu options <br>                        EnableMenuItem(hMenu, IDM_MENU_FILE_CLOSE, <br>                            MF_GRAYED); <br>                        EnableMenuItem(hMenu, IDM_MENU_TOOLS_EDGE, <br>                            MF_GRAYED); <br>                        EnableMenuItem(hMenu, IDM_MENU_TOOLS_FLIP, <br>                            MF_GRAYED); <br> <br>                        // Delete the bitmap object <br>                        DeleteObject(g_hBitmap); <br>                    } <br>                    break; <br> <br>                case    IDM_MENU_FILE_EXIT  :   // Exit program was chosen <br>                    PostMessage(g_hWnd, WM_CLOSE, 0, 0); <br>                    break; <br> <br>                case    IDM_MENU_TOOLS_EDGE :   // Want to find edges  <br>                    if (!EDGE_FOUND) <br>                    { <br>                        ChangeBitmapRemote(FINDEDGE, &amp;g_hBitmap); <br>                        RedrawClientArea(hDC); <br>                        EDGE_FOUND = TRUE; <br>                    } <br>                    break; <br> <br>                case    IDM_MENU_TOOLS_FLIP :   // Want to flip the bitmap <br>                    ChangeBitmapRemote(FLIPIMAGE, &amp;g_hBitmap); <br>                    RedrawClientArea(hDC); <br>                    break; <br> <br>                case    IDM_MENU_FILE_BINDING:      // Binding dialog box <br>                    DialogBox(g_hInstance, <br>                        MAKEINTRESOURCE(IDD_BINDING_DIALOG), <br>                        hWnd, <br>                        (DLGPROC) BindingDlgProc); <br>                    break; <br> <br>                case    IDM_MENU_ABOUT      :       // About dialog box <br>                    DialogBox(g_hInstance, <br>                        MAKEINTRESOURCE(IDD_ABOUT_DIALOG), <br>                        hWnd, <br>                        (DLGPROC) AboutDlgProc); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_PAINT : <br>            BeginPaint(g_hWnd, &amp;sPS);    // Gets a device context <br>            RedrawClientArea(sPS.hdc);   // Redraws the screen <br>            EndPaint(g_hWnd, &amp;sPS);      // Releases a device context <br>            break; <br> <br>        case WM_CLOSE   :               // User requests windows closure <br>            ShutDown();                 // Shut down the server <br>            CleanUp();                  // Deallocate some memory <br>            DestroyWindow(hWnd);        // Generates the WM_DESTROY message <br>            break; <br> <br>        case WM_DESTROY : <br>            PostQuitMessage(0);         // Puts a WM_QUIT in the queue <br>            break;                      // =&gt; GetMessage returns NULL <br> <br>        default : <br>            ReleaseDC(g_hWnd, hDC); <br>            return DefWindowProc(hWnd, uMsg, wParam, lParam); <br>    } <br> <br>    ReleaseDC(g_hWnd, hDC); <br>    return (0L); <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   void GetBitMapFileName(void) <br>// Desc.        :   This procedure calls the common dialog box  <br>//                  GetFileNameOpen to get the filename of a bitmap file <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>BOOL GetBitmapFileName(void) <br>{ <br>OPENFILENAME    sOfn;       // The OPENFILENAME struct <br> <br>// Variable used to filter out only the files needed <br>LPCTSTR szFilter[] = {TEXT("Windows Bitmaps (*.bmp)"), TEXT("*.bmp"), <br>                         TEXT("")}; <br> <br>// Fill in the OPENFILENAME Structure <br>sOfn.lStructSize         = sizeof(OPENFILENAME); <br>sOfn.hwndOwner           = g_hWnd; <br>sOfn.hInstance           = g_hInstance; <br>sOfn.lpstrFilter         = *szFilter; <br>sOfn.lpstrCustomFilter   = NULL; <br>sOfn.nMaxCustFilter      = 0; <br>sOfn.nFilterIndex        = 0;             <br>sOfn.lpstrFile           = g_szFileName;  <br>sOfn.nMaxFile            = _MAX_PATH;     <br>sOfn.lpstrFileTitle      = NULL; <br>sOfn.nMaxFileTitle       = _MAX_FNAME + _MAX_EXT; <br>sOfn.lpstrInitialDir     = NULL;          <br>sOfn.lpstrTitle          = NULL; <br>sOfn.Flags               = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br>sOfn.nFileOffset         = 0; <br>sOfn.nFileExtension      = 0; <br>sOfn.lpstrDefExt         = TEXT("bmp"); <br>sOfn.lCustData           = 0L; <br>sOfn.lpfnHook            = NULL; <br>sOfn.lpTemplateName      = NULL; <br>     <br>    // This function call will display a Open File dialog box, and read  <br>    // the name into the the global varaible g_szFileName. It will return <br>    // TRUE if a filename was chosen, and OK button clicked, else it will  <br>    // return FALSE <br>    return GetOpenFileName(&amp;sOfn); <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   ReadBitmapFromFile() <br>// Desc.        :   This procedure reads a bitmap from a file and sets the <br>//                  global variables g_Bitmap and g_hBitmap. <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>BOOL ReadBitmapFromFile(void) <br>{ <br>    UINT    uLoadFlags; <br>    HDC     hDC = GetDC(g_hWnd); <br> <br>    // Read in the palette from the file. Must do this first, because this <br>    // procedure checks for valid fileformats <br>    g_hPalette = LoadPaletteFromFile(g_szFileName); <br> <br>    // If a file has already been read, get rid of that bitmap <br>    if (BITMAP_READ) <br>    { <br>        DeleteObject(g_hBitmap); <br>        BITMAP_READ = FALSE; <br>    } <br> <br>    // Load image as a DIB image if its a 256 color image and the screen <br>    // resolution is in 256 colors <br>    if(g_BitsPerPixel == 8 &amp;&amp; GetDeviceCaps(hDC, BITSPIXEL) == 8) <br>    { <br>        uLoadFlags = LR_LOADFROMFILE | LR_CREATEDIBSECTION; <br>    } <br>    else <br>    { <br>        uLoadFlags = LR_LOADFROMFILE; <br>    } <br> <br>    // Load the bitmap image in from the global filename found with the <br>    // GetFileNameOpen common dialogbox <br>    g_hBitmap = (HBITMAP) LoadImage( <br>        NULL,                   // Want to load bitmap from file <br>        g_szFileName,           // Filename where bitmap is stored <br>        IMAGE_BITMAP,           // Type of image to be loaded <br>        0, 0,                   // The desired width and height <br>        uLoadFlags); <br>     <br>    // If the reading failed <br>    if (g_hBitmap == 0) <br>    { <br>        return FALSE; <br>    } <br>     <br>    // Obtain the infornation about the bitmap, from the handle returned <br>    // by the LoadImage function. Must delete this object before quitting <br>    GetObject(g_hBitmap, sizeof(BITMAP),(LPVOID) &amp;g_Bitmap); <br> <br>    BITMAP_READ = TRUE;         // Let PAINT know what to repaint <br>    EDGE_FOUND = FALSE;         // Not found the edges in this image yet <br> <br>    return TRUE; <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   BOOL CALLBACK AboutDlgProc() <br>// Desc.        :   This procedure is called when the user chooses the <br>//                  About menu. It displays a Dialogbox defined in the  <br>//                  client.rc file and returns when the user clicks on the  <br>//                  OK button <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>BOOL CALLBACK AboutDlgProc(HWND hDlg,  <br>                           UINT uMsg,  <br>                           WPARAM wParam,  <br>                           LPARAM lParam) <br>{ <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG :            // Return TRUE, windows sets the <br>            return TRUE;                // focus on the OK button <br> <br>        case WM_COMMAND : <br>            switch(LOWORD(wParam)) <br>            { <br>                case IDOK:              // If the user clicks the OK button <br>                    EndDialog(hDlg, 0); // Take the dialogbox away <br>                    return TRUE; <br>            } <br>        default: <br>            return FALSE;           // Windows should handle the message <br>  } <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   BOOL CALLBACK BindingDlgProc() <br>// Desc.        :   This procedure is called when the user chooses Server  <br>//                  from the File menu. It displays a dialogbox defined in <br>//                  the client.rc file. Here the user can enter a specific <br>//                  binding to a remote server by specifying the network -  <br>//                  protocol and the endpoint to use, and the name of the  <br>//                  machine that runs the server program. <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>BOOL CALLBACK BindingDlgProc(HWND hDlg,  <br>                             UINT uMsg,  <br>                             WPARAM wParam,  <br>                             LPARAM lParam) <br>{ <br>    switch (uMsg)  <br>    { <br>        case WM_INITDIALOG: <br>            // Fill in the edit boxes with the current values <br>            SetDlgItemText((HANDLE)hDlg, IDC_PROTSEQ_NAME,  <br>                pszProtocolSequence); <br>            SetDlgItemText((HANDLE)hDlg, IDC_ENDPOINT_NAME, pszEndpoint); <br>            SetDlgItemText((HANDLE)hDlg, IDC_SERVER_NAME,  <br>                pszNetworkAddress); <br>            return(TRUE); <br> <br>        case WM_COMMAND:    <br>            switch(LOWORD(wParam))  <br>            { <br>                case IDCANCEL:     // Cancel button clicked <br>                    EndDialog(hDlg, FALSE); <br>                    return(TRUE); <br> <br>                case IDOK:         // OK button clicked <br>                    GetDlgItemText(hDlg, IDC_PROTSEQ_NAME,  <br>                        pszProtocolSequence, 30); <br>                    GetDlgItemText(hDlg, IDC_SERVER_NAME,  <br>                        pszNetworkAddress, 30); <br>                    GetDlgItemText(hDlg, IDC_ENDPOINT_NAME,  <br>                        pszEndpoint, 30); <br> <br>                    // If we get a binding, all is OK <br>                    if (Bind(hDlg) == RPC_S_OK)  <br>                    { <br>                        EndDialog(hDlg, FALSE); <br>                        return(TRUE); <br>                    } <br>                    // If we couldn't bind, just keep asking for new input <br>            }   // switch((LOWORD(WPARAM)) <br>    }   // switch(uMsg) <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   RedrawClientArea(HDC) <br>// Desc.        :   This procedure redraw the client area by either  <br>//                  displaying the bitmap, or simply drawing a gray  <br>//                  background. <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>void RedrawClientArea(HDC hDC)                // Handle to the screen <br>{ <br>    HDC     hDCMem;         // A memory device context <br>    RECT    sRect;          // Rectangle containing the entire client area <br> <br>    // Do a check to see if the bitmap has been read in. If it hasn't, we  <br>    // leave the screen blank <br>    if(BITMAP_READ) <br>    { <br>        if(g_BitsPerPixel == 8 &amp;&amp; g_hPalette != 0) <br>        { <br>            // Select and realize the palette to use <br>            SelectPalette(hDC, g_hPalette, TRUE); <br>            RealizePalette(hDC); <br>        } <br> <br>        hDCMem = CreateCompatibleDC(hDC); <br>        SelectObject (hDCMem, g_hBitmap); <br>        SetMapMode (hDCMem, GetMapMode(hDC)); <br> <br>        // Draw the bitmap using the BitBlt function <br>        if(BitBlt( <br>            hDC,                // The destination device context <br>            0, 0,               // Coordinates of the destination rectangle <br>            g_Bitmap.bmWidth,   // Width of the dest. and source rectangle <br>            g_Bitmap.bmHeight,// Height of the dest. and source rectangle <br>            hDCMem, <br>            0, 0, <br>            SRCCOPY)) <br>        { <br>            DeleteDC(hDCMem); <br>        } <br>    } <br>    else        // We want to wipe the screen with the background color <br>    { <br>        GetClientRect(g_hWnd,  &amp;sRect); <br>        FillRect(hDC, &amp;sRect, GetStockObject(GRAY_BRUSH)); <br>    } <br>    return; <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Funciton     :   LoadPaletteFromFile <br>// Desc.        :   This procedure loads a palette froma dib-file. It  <br>//                  checks to see that this is a 256-color image, and <br>//                  then reads in the palette, and returns a handle <br>//                  to it <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>HPALETTE LoadPaletteFromFile(LPTSTR lpszFileName) <br>{ <br>    HANDLE              hFile;          // Bitmap filename <br>    HPALETTE            hPalette;       // Handle to the palette <br>    HANDLE              hMem,           // A handle to a memory location <br>                        hCore;          // Handle to memory <br>    DWORD               dwBitmapType,   // The type of the bitmap <br>                        dwSize;         // A size of memory to allocate <br>    int                 nIdx,           // Index in loops <br>                        nPalEntries;    // # of entries in the palette <br>    LPSTR               lpCore;         // Pointer to memory bytes <br>    LPLOGPALETTE        lpMem;          // A mem pointer to the LOGPALETTE <br>    BITMAPFILEHEADER    sBFH;           // This is always filled in <br>    BITMAPINFOHEADER    sBIH;           // Used if this is a Windows bitmap <br>    BITMAPCOREHEADER    sBCH;           // Used if this is a OS/2 bitmap <br>    DWORD               dwDummy; <br> <br>    // Initialize the palette handle to NULL <br>    hPalette = NULL; <br> <br>    // Open the file where the bitmap is stored <br>    hFile = CreateFile( <br>        lpszFileName,  <br>        GENERIC_READ,  <br>        FILE_SHARE_READ, <br>        NULL, <br>        OPEN_EXISTING, <br>        FILE_ATTRIBUTE_NORMAL, <br>        0); <br>    if(hFile != 0) <br>    { <br>        // Read the BITMAPFILEHEADER from the file <br>        if (ReadFile(hFile, &amp;sBFH,sizeof(BITMAPFILEHEADER),  <br>            &amp;dwDummy, NULL)) <br>        { <br>            // Any valid bitmap file should have filetype = 'BM' <br>            if(sBFH.bfType == (UINT)0x4D42) <br>            { <br>                // Determine type of bitmap. <br>                // The next WORD (4 bytes) in the file (offset 14) will be <br>                // either 40 - indicating that this is a Windows Bitmap,  <br>                // and therefore will be using a BITMAPINFOHEADER, or it  <br>                // will be 14 - indicating that this is a OS/2 1.x bitmap, <br>                // and therefore will be using a BITMAPCOREHEADER. 14 and  <br>                // 40 are the respective sizes of the HEADERS <br>                ReadFile(hFile, &amp;dwBitmapType, sizeof(DWORD),  <br>                    &amp;dwDummy, NULL); <br>                SetFilePointer(hFile,sizeof(BITMAPFILEHEADER), <br>                    NULL, FILE_BEGIN); <br> <br>                // Load up INFO header.  If bitmap is a CORE <br>                // header, then we need to convert to INFO header. <br>                if(dwBitmapType == sizeof(BITMAPCOREHEADER)) <br>                { <br>                    // Read in the COREHEADER <br>                    ReadFile(hFile, &amp;sBCH,sizeof(BITMAPCOREHEADER),  <br>                        &amp;dwDummy, NULL); <br>                 <br>                    // Fill out the missing parts of the INFOHEADER <br>                    sBIH.biSize          = sizeof(BITMAPINFOHEADER); <br>                    sBIH.biWidth         = sBCH.bcWidth; <br>                    sBIH.biHeight        = sBCH.bcHeight; <br>                    sBIH.biPlanes        = sBCH.bcPlanes; <br>                    sBIH.biBitCount      = sBCH.bcBitCount; <br>                    sBIH.biCompression   = BI_RGB; <br>                    sBIH.biSizeImage     = 0; <br>                    sBIH.biXPelsPerMeter = 0; <br>                    sBIH.biYPelsPerMeter = 0; <br>                    sBIH.biClrUsed       = 0; <br>                    sBIH.biClrImportant  = 0; <br>                } <br>                else <br>                { <br>                    // Read in the INFOHEADER <br>                    ReadFile(hFile, &amp;sBIH,sizeof(BITMAPINFOHEADER),  <br>                        &amp;dwDummy, NULL); <br>                } <br> <br>                //------------------------- <br>                // Palette creation <br>                //------------------------- <br> <br>                // Figure out the number of entries in the palette <br>                // i.e. if the number of Bits per pixel (biBitCount) is 8, <br>                // the number of palette entries will be 1 &lt;&lt; 8 = 256 <br>                nPalEntries = ((UINT)1 &lt;&lt; sBIH.biBitCount); <br>                g_BitsPerPixel = sBIH.biBitCount; <br>        <br>                // Determine the size of the memory to allocate  <br>                // (The size of all mem needed for the palette) <br>                dwSize   = sizeof(LOGPALETTE) +  <br>                    (nPalEntries * sizeof(PALETTEENTRY)); <br> <br>                // Aloocate space for the palette. this just returns a  <br>                // handle to the memory. We must use the function  <br>                // GlobalLock to get a pointer to the memory <br>                if(hMem = GlobalAlloc(GHND,dwSize)) <br>                { <br>                    // Extract a pointer to the memory just allocated, and <br>                    // cast it as a pointer to a LOGPALETTE struct <br>                    if(lpMem = (LPLOGPALETTE)GlobalLock(hMem)) <br>                    { <br>                        // Set LogPalette structure. <br>                        lpMem-&gt;palVersion    = 0x0300; <br>                        lpMem-&gt;palNumEntries = nPalEntries; <br> <br>                        // Read in ColorTable. COREHEADER files uses the  <br>                        // RGB triplet to store the values of the palette <br>                        if(dwBitmapType == sizeof(BITMAPCOREHEADER)) <br>                        { <br>                            // Calculate the size of color map <br>                            dwSize = (nPalEntries * sizeof(RGBTRIPLE)); <br> <br>                            // Allocate memory to store this in <br>                            if(hCore = GlobalAlloc(GHND,dwSize)) <br>                            { <br>                                // Get a pointer to the memory,and LOCK it <br>                                if(lpCore = GlobalLock(hCore)) <br>                                { <br>                                    // Read the palette data into memory <br>                                    ReadFile(hFile, lpCore, dwSize,  <br>                                        &amp;dwDummy, NULL); <br>     <br>                                    // Put the palette data into the  <br>                                    // palette struct <br>                                    for(nIdx=0; nIdx &lt; nPalEntries; nIdx++) <br>                                    { <br>                                        lpMem-&gt;palPalEntry[nIdx].peBlue  =  <br>                                            (((RGBTRIPLE FAR * )lpCore) + nIdx)-&gt;rgbtBlue; <br>                                        lpMem-&gt;palPalEntry[nIdx].peGreen =  <br>                                            (((RGBTRIPLE FAR * )lpCore)+nIdx)-&gt;rgbtGreen; <br>                                        lpMem-&gt;palPalEntry[nIdx].peRed   =  <br>                                            (((RGBTRIPLE FAR * )lpCore)+nIdx)-&gt;rgbtRed; <br>                                        lpMem-&gt;palPalEntry[nIdx].peFlags = 0; <br>                                    } <br> <br>                                    // Unlock the memory used <br>                                    GlobalUnlock(hCore); <br>                                } <br> <br>                                // Free up the memory used <br>                                GlobalFree(hCore); <br>                            } <br>                        } <br>                        else <br>                        { <br>                            // The INFOHEADER version of a bitmap file uses <br>                            // RGB Quads to store the color map <br>                            dwSize = (nPalEntries * sizeof(RGBQUAD)); <br> <br>                            // Allocate memory to store this in <br>                            if(hCore = GlobalAlloc(GHND,dwSize)) <br>                            { <br>                                // Get a pointer to the memory,and LOCK it <br>                                if(lpCore = GlobalLock(hCore)) <br>                                { <br>                                    // Read the palette data into memory <br>                                    ReadFile(hFile, lpCore,dwSize,  <br>                                        &amp;dwDummy, NULL); <br> <br>                                    // Put the palette data into the  <br>                                    // palette struct <br>                                    for(nIdx=0; nIdx &lt; nPalEntries; nIdx++) <br>                                    { <br>                                        lpMem-&gt;palPalEntry[nIdx].peBlue  =  <br>                                            (((LPRGBQUAD)lpCore)+nIdx)-&gt;rgbBlue; <br>                                        lpMem-&gt;palPalEntry[nIdx].peGreen =  <br>                                            (((LPRGBQUAD)lpCore)+nIdx)-&gt;rgbGreen; <br>                                        lpMem-&gt;palPalEntry[nIdx].peRed   =  <br>                                            (((LPRGBQUAD)lpCore)+nIdx)-&gt;rgbRed; <br>                                        lpMem-&gt;palPalEntry[nIdx].peFlags = 0; <br>                                    } <br> <br>                                    // UNLOCK the data just used <br>                                    GlobalUnlock(hCore); </code></pre>
<p>
</p>
<pre><code>} <br> <br>                                // Free up the memory used to store the  <br>                                // palette data <br>                                GlobalFree(hCore); <br>                            } <br>                        } <br> <br>                        // Create a handle to the palette <br>                        hPalette = CreatePalette(lpMem); <br> <br>                        // Unlock the memory used for storing the data to <br>                        // the LOGPALETTE <br>                        GlobalUnlock(hMem); <br>                    } <br> <br>                    // Free up the memory used by the LOGPALETTE structure <br>                    GlobalFree(hMem); <br>                } <br>            } <br>        } <br>        else// This is NOT a bitmap file <br>        { <br>            PRINT(TEXT("This is not a BITMAP file"),  <br>                TEXT("Invalid Fileformat")); <br>            return FALSE; <br>        } <br> <br> <br>        // Close the file we have been reading from <br>        CloseHandle(hFile); <br>    } <br> <br>    // Return the handle to the palette to the calling structure <br>    return(hPalette); <br>} <br> <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   RPC_STATUS Bind(HWND) <br>// Desc.        :   This procedure will make RPC API calls to bind to the  <br>//                  server application. <br>//                  The binding calls are made from Init() and whenever <br>//                  the user changes the server name or endpoint. If the  <br>//                  bind operation is successful, the global flag fBound  <br>//                  is set to TRUE. The global flag fBound is used to  <br>//                  determine whether to call the RPC API function  <br>//                  RpcBindingFree. <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>RPC_STATUS Bind(HWND hWnd) <br>{ <br>    RPC_STATUS nStatus; <br>     <br>    if (g_bBound == TRUE)     // unbind only if bound <br>    {   <br>        nStatus = RpcStringFree(&amp;pszStringBinding); <br>        if (nStatus)  <br>        { <br>            _stprintf(szBuffer,TEXT("RpcStringFree failed 0x%x"), nStatus); <br>            MessageBox(hWnd, <br>                       szBuffer, <br>                       TEXT("RPC Sample Application"), <br>                       MB_ICONSTOP); <br>            return(nStatus); <br>        } <br> <br>        nStatus = RpcBindingFree(&amp;global_wintyp_sample_handle); <br>        if (nStatus)  <br>        { <br>            _stprintf(szBuffer,TEXT("RpcBindingFree failed 0x%x"), nStatus); <br>            MessageBox(hWnd, <br>                       szBuffer, <br>                       TEXT("RPC Sample Application"), <br>                       MB_ICONSTOP); <br>            return(nStatus); <br>        } <br> <br>        g_bBound = FALSE;  // unbind successful; reset flag <br>    } <br> <br>    nStatus = RpcStringBindingCompose(pszUuid, <br>                                     pszProtocolSequence, <br>                                     pszNetworkAddress, <br>                                     pszEndpoint, <br>                                     pszOptions, <br>                                     &amp;pszStringBinding); <br>    if (nStatus)  <br>    { <br>        _stprintf(szBuffer,  <br>            TEXT("RpcStringBindingCompose returned : (0x%x)\nNetwork Address = %s\n"), <br>            nStatus, pszNetworkAddress); <br>        MessageBox(hWnd, szBuffer, TEXT("RPC Sample Application"),  <br>            MB_ICONINFORMATION); <br>        return(nStatus); <br>    } <br> <br>    nStatus = RpcBindingFromStringBinding(pszStringBinding, <br>                            &amp;global_wintyp_sample_handle); <br>    if (nStatus)  <br>    { <br>        _stprintf(szBuffer,  <br>            TEXT("RpcBindingFromStringBinding returned: (0x%x)\nString = %s\n"), <br>             nStatus, pszStringBinding); <br>        MessageBox(hWnd, szBuffer, TEXT("RPC Sample Application"),  <br>            MB_ICONINFORMATION); <br>        return(nStatus); <br>    } <br> <br>    g_bBound = TRUE;  // bind successful; reset flag <br> <br>    return(nStatus); <br>} <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   CleanUp() <br>// Desc.        :   This procedure deletes the object, and the memory used <br>//                  in the program. <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>void CleanUp(void) <br>{ <br>    // Destroy the object used for the bitmap <br>    DeleteObject(g_hBitmap); <br> <br>    // Delete the space taken up by the binding  <br>    if (g_bBound) <br>    { <br>        status = RpcStringFree(&amp;pszStringBinding); <br>        if (status)  <br>        { <br>            _stprintf(szBuffer,TEXT("RpcStringFree failed 0x%x"), status); <br>            MessageBox(g_hWnd, <br>                       szBuffer, <br>                       TEXT("RPC Sample Application"), <br>                       MB_ICONSTOP); <br>            exit(EXECUTION_FAILED); <br>        } <br> <br>        status = RpcBindingFree(&amp;global_wintyp_sample_handle); <br>        if (status)  <br>        { <br>            _stprintf(szBuffer,TEXT("RpcBindingFree failed 0x%x"), status); <br>            MessageBox(g_hWnd, <br>                       szBuffer, <br>                       TEXT("RPC Sample Application"), <br>                       MB_ICONSTOP); <br>            exit(EXECUTION_FAILED); <br>        } <br>    } <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Procedure    :   midl_user_allocate() and midl_user_free()            <br>// Desc.        :   These procedure are declared in the header file      <br>//                  generated by the midl compiler. These procedures     <br>//                  should be used for all memory allocation and         <br>//                  deallocation.                                        <br>//                  These procedures are also called by the stub code to <br>//                  allocate and free memory.                            <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>void __RPC_FAR * __RPC_API midl_user_allocate(size_t nLen) <br>{ <br>    return (malloc(nLen)); <br>} <br> <br>void __RPC_API midl_user_free(void __RPC_FAR * lpvPointer) <br>{ <br>    if(NULL != lpvPointer) <br>        free (lpvPointer); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
