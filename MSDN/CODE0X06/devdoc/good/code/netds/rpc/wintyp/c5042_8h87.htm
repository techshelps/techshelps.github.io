<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REMOTE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5047"></a>REMOTE.C</h2>
<pre><code>/************************************************************************* <br>                Copyright Microsoft Corp. 1992-1996 <br>                    Remote Machine WinType sample <br> <br>    FILE        :   REMOTE.C <br> <br>    PURPOSE     :   The actual functions on the server side of the RPC  <br>                    distributed application wintyp that are called from  <br>                    the client side. <br> <br>    COMMENTS    :   This sample is made to demonstrate the passing of a  <br>                    Window Type from the client to the server. The  <br>                    colordepth in the edge detection funciton is limited <br>                    to 256 color because of the simpler algorithm <br> <br>*************************************************************************/ <br>#include "wintyp.h"         // Generated by the MIDL compiler <br>#include "common.h"         // Common definitions for all files <br>#include &lt;windows.h&gt;        // All windows programs must include this file <br> <br>#define THRESHOLD   75      // Threshold value in findedges function <br> <br>// Local procedures used only within this file <br>BYTE **Get2DPointer(BYTE *, LONG, LONG); <br>void FindEdges(BYTE **, BYTE **, LONG, int, int); <br>void FlipImage(BYTE **, BYTE **, LONG, int, int); <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Function     :   BOOL ChangeBitmapRemote () <br>// Desc.        :   This function is called from the client side. First it  <br>//                  allocates space for the data in the image passed from  <br>//                  the client. Then it will analyze the function call,  <br>//                  and perform a findedge, or flipimage operation on the  <br>//                  bitmap passed from the client. <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>BOOL ChangeBitmapRemote(unsigned short nAction, HBITMAP *hBM) <br>{ <br>    BITMAP sBM;              // A structure to load the bitmap data into <br>    BOOL   bRetValue;        // The value to return from this function <br>    BYTE   *pbOldBitmapBits, // Buffer to hold the old values of the bitmap <br>           *pbNewBitmapBits, // Buffer to hold the new values of the bitmap <br>           **pbOldImage,     // 2D-pointer to the old image  <br>           **pbNewImage;     // 2D-pointer to the new image <br>    long   nImageSize;       // The size of the image in bytes <br> <br> <br>    _tprintf(TEXT("In the remote procedure \'ChangeBitmapRemote\'\n")); <br>    // Obtain information about the BITMAP from the handle to the bitmap <br>    GetObject(*hBM, sizeof(BITMAP), (LPVOID) &amp;sBM); <br> <br>    // Calculate the total number of bytes the image occupies <br>    nImageSize = sBM.bmHeight * sBM.bmWidthBytes; <br> <br>    // Allocate memory for the buffers to store the image data in <br>    if (NULL == (pbOldBitmapBits = (BYTE *) malloc (nImageSize))) <br>    { <br>        _tprintf(TEXT("Memory allocation error")); <br>        return FALSE; <br>    } <br>     <br>    if (NULL == (pbNewBitmapBits = (BYTE *) malloc (nImageSize))) <br>    { <br>        _tprintf(TEXT("Memory allocation error")); <br>        return FALSE; <br>    } <br>     <br>    // Get the data from the image, and fill into the old image buffer <br>    GetBitmapBits(*hBM, nImageSize, (LPVOID) pbOldBitmapBits); <br>     <br>    // Create 2D-array pointers to the image data for easier acces <br>    if(NULL == (pbOldImage = Get2DPointer(pbOldBitmapBits,  <br>        sBM.bmHeight, sBM.bmWidthBytes))) <br>    { <br>        return FALSE; <br>    } <br>    if(NULL == (pbNewImage = Get2DPointer(pbNewBitmapBits,  <br>        sBM.bmHeight, sBM.bmWidthBytes))) <br>    { <br>        return FALSE; <br>    } <br> <br> <br>    switch(nAction) <br>    { <br>        case FINDEDGE : <br>            FindEdges(pbOldImage,  <br>                    pbNewImage,  <br>                    nImageSize,  <br>                    sBM.bmWidth,  <br>                    sBM.bmHeight); <br> <br>            // Copy the new image data into the bitmap to return to client <br>            SetBitmapBits(*hBM, nImageSize, (const void *) pbNewBitmapBits); <br>            bRetValue = TRUE; <br>            break; <br> <br>        case FLIPIMAGE: <br>            FlipImage(pbOldImage,  <br>                    pbNewImage,  <br>                    nImageSize,  <br>                    sBM.bmWidthBytes,  <br>                    sBM.bmHeight); <br> <br>            // Copy the new image data into the bitmap to return to client <br>            SetBitmapBits(*hBM, nImageSize,  <br>                (const void *) pbNewBitmapBits); <br>            bRetValue = TRUE; <br>            break; <br> <br>        default : <br>            bRetValue = FALSE; <br>    } <br> <br>    // Deallocate the memory used for the imagebuffers and the 2D-pointers <br>    free(pbOldBitmapBits); <br>    free(pbNewBitmapBits); <br>    free(pbOldImage); <br>    free(pbNewImage); <br> <br>    _tprintf(TEXT("Leaving the remote procedure \'ChangeBitmapRemote\'\n")); <br>     <br>    return bRetValue; <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Function     :   void FindEdges () <br>// Desc.        :   This function finds the edges in a given image by  <br>//                  using the Sobel edge operators. The image will be  <br>//                  changed to the edges corresponding to the boundaries  <br>//                  in it                                   <br>// Comments     :   The algorithm used works best on grayscale images, but  <br>//                  it should produce acceptable results on a 256-color  <br>//                  image as well <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>void FindEdges(BYTE **pbOldImage,       // 2D-pointer to existing image <br>               BYTE **pbNewImage,       // 2D-pointer to the new image <br>               LONG nImageSize,         // The size of the image in bytes <br>               int nWidth,              // The width of the image <br>               int nHeight)             // The Height of the image <br>{ <br>    int <br>        nIdx1, nIdx2,   // Counters in loops  <br>        nGx, nGy,       // Values found by applying the masks Gx and Gy  <br>        nMax = 0;       // Max value for the edge <br> <br> <br> <br> <br>    // Go through every pixel in the image, and find the edges  <br>    for (nIdx1 = 1; nIdx1 &lt; (nHeight - 1); nIdx1++) <br>    { <br>        for (nIdx2 = 1; nIdx2 &lt; (nWidth - 1); nIdx2++) <br>        { <br>            // Find Gx  <br>            nGx =(( (int)pbOldImage[nIdx1+1][nIdx2-1] +  <br>                  2*(int)pbOldImage[nIdx1+1][nIdx2]   +  <br>                    (int)pbOldImage[nIdx1+1][nIdx2+1]  ) <br>                    -    <br>                 (  (int)pbOldImage[nIdx1-1][nIdx2-1] +  <br>                  2*(int)pbOldImage[nIdx1-1][nIdx2]   +  <br>                    (int)pbOldImage[nIdx1-1][nIdx2+1]  ))  / 8; <br> <br>            // Find Gy  <br>            nGy =(( (int)pbOldImage[nIdx1-1][nIdx2+1] +  <br>                  2*(int)pbOldImage[nIdx1][nIdx2+1]   +  <br>                    (int)pbOldImage[nIdx1+1][nIdx2+1]  ) <br>                    - <br>                 (  (int)pbOldImage[nIdx1-1][nIdx2-1] +  <br>                  2*(int)pbOldImage[nIdx1][nIdx2-1]   +  <br>                    (int)pbOldImage[nIdx1+1][nIdx2-1]  ))  / 8; <br> <br>            // Enter value into the new image <br>            pbNewImage[nIdx1][nIdx2] = (BYTE)((abs(nGx) + abs(nGy))/2); <br>        } <br>    } <br> <br> <br>// Find the max value  <br>    for (nIdx1 = 1; nIdx1 &lt; (nHeight-1); nIdx1++) <br>    { <br>        for (nIdx2 = 0; nIdx2 &lt; nWidth; nIdx2++) <br>        { <br>            if (pbNewImage[nIdx1][nIdx2] &gt; nMax) <br>            { <br>                nMax = pbNewImage[nIdx1][nIdx2]; <br>            } <br>        } <br>    } <br> <br>    // Normalize every point in the image  <br>    for (nIdx1 = 1; nIdx1 &lt; (nHeight-1); nIdx1++) <br>    { <br>        for (nIdx2 = 0; nIdx2 &lt; nWidth; nIdx2++) <br>        { <br>            pbNewImage[nIdx1][nIdx2]=(pbNewImage[nIdx1][nIdx2] * 255)/nMax; <br>        } <br>    } <br>     <br>    // Now set every pixel value that is less than a threshold to 0, and <br>    // the rest to 255 <br>    for (nIdx1 = 1; nIdx1 &lt; (nHeight-1); nIdx1++) <br>    { <br>        for (nIdx2 = 0; nIdx2 &lt; nWidth; nIdx2++) <br>        { <br>            if(pbNewImage[nIdx1][nIdx2] &gt; THRESHOLD) <br>            { <br>                pbNewImage[nIdx1][nIdx2] = 255; <br>            } <br>            else  <br>            { <br>                pbNewImage[nIdx1][nIdx2] = 0; <br>            } <br>        } <br>    } <br> <br>} <br> <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Function     :   void FlipImage () <br>// Desc.        :   This function will flip the image upside down <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>void FlipImage(BYTE **pbOldImage,   // 2D-pointer to existing image <br>               BYTE **pbNewImage,   // 2D-pointer to the new image <br>               LONG nImageSize,     // The size of the image in bytes <br>               int nWidth,          // The width of the image <br>               int nHeight)         // The Height of the image <br>{ <br>    int     nIdx1, nIdx2;                   // Counters in loops  <br> <br>    // Copy the old image, line by line, into the new image <br>    for (nIdx1 = 0; nIdx1 &lt; nHeight; nIdx1++) <br>    { <br>        for (nIdx2 = 0; nIdx2 &lt; nWidth; nIdx2++) <br>        { <br>            pbNewImage[nHeight - nIdx1 - 1][nIdx2] =  <br>                pbOldImage[nIdx1][nIdx2]; <br>        } <br>    } <br> <br>} <br> <br>//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>// Function :   Get2DPointer(BITMAP *) <br>// Purpose  :   This procedure will get a 2D-pointer to the data in the  <br>//              bitmap, which is much easier to work with than a single  <br>//              pointer. <br>//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br>BYTE **Get2DPointer(BYTE *pbBuffer, LONG nHeight, LONG nWidthBytes) <br>{ <br>    BYTE **pbRetValue;        // The return value <br>    int nIdx; <br> <br>    if (NULL == (pbRetValue = (BYTE **) malloc (nHeight * sizeof(BYTE *)))) <br>    { <br>        _tprintf(TEXT("Memory allocation error")); <br>        return NULL; <br>    } <br>     <br> <br>    for (nIdx = 0; nIdx &lt; nHeight; nIdx++) <br>        pbRetValue[nIdx] = pbBuffer + (nIdx * nWidthBytes); <br> <br>    return pbRetValue; <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* Procedure    :   void ShutDown(void)                                 */ <br>/* Desc.        :   This procedure send a message to the server that it */ <br>/*                  can stop listening for remote procedure calls       */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void ShutDown(void) <br>{ <br>    RPC_STATUS nStatus; <br> <br>    /* Tell the server to stop listening for remote procedure calls */ <br>    _tprintf(TEXT("Shutting down the server\n")); <br>    nStatus = RpcMgmtStopServerListening(NULL); <br>    EXIT_IF_FAIL(nStatus, "RpcMgmtStopServerListening"); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
