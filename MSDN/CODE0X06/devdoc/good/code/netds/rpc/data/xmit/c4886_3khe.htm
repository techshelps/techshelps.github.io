<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XMITU.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4892"></a>XMITU.C</h2>
<pre><code>/**************************************************************************** <br>                   Microsoft RPC Version 2.0 <br>           Copyright Microsoft Corp. 1992, 1993, 1994- 1996 <br>                        xmit Example <br> <br>    FILE:       xmitu.c <br> <br>    PURPOSE:    Utility functions used by both client and server <br>                sides of the RPC distributed application. <br>                This sample demonstrates the transmit_as example. <br>                A doubly-linked list is transmitted over the network <br>                as a sized array. <br> <br>    RELATED:    xmits.c - server main <br>                xmitp.c - remote procedures <br>                xmitc.c - client main <br> <br>    FUNCTIONS:  DOUBLE_LINK_TYPE_to_xmit - convert list to array <br>                DOUBLE_LINK_TYPE_from_xmit - convert array to list <br>                DOUBLE_LINK_TYPE_free_inst - free linked list memory <br>                DOUBLE_LINK_TYPE_free_xmit - free array memory <br>                midl_user_allocate - user-supplied memory allocator <br>                midl_user_free - user-supplied routine to free memory <br> <br>                ArrayWalkProc - utility to display the array <br>                ListWalkProc - utility to display the linked list <br>                InsertNewNode - utility to add a node to the list <br> <br>    COMMENTS:   This sample program generates a linked list to <br>                demonstrate how a list with aliasing can be transmitted <br>                using the transmit_as attribute as a sized array. <br>                The pointers are rebuilt on the server side. <br> <br>****************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "xmit.h"    // header file generated by MIDL compiler <br>#include "xmitu.h" <br> <br> <br>/***************************************************************************/ <br> <br>void ArrayWalkProc(DOUBLE_XMIT_TYPE * pArray) <br>{ <br>    int i; <br> <br>    printf("Display contents of transmitted array:\n"); <br>    for (i = 0; i &lt; pArray-&gt;sSize; i++) <br>        printf("pArray-&gt;asNumber[%d] = %d\n", i, pArray-&gt;asNumber[i]); <br>} <br> <br>void ListWalkProc(DOUBLE_LINK_TYPE * pList) <br>{ <br>    printf("Display contents of doubly linked list:\n"); <br>    while (pList != NULL) { <br>        printf("pList @0x%lx = %d, Next = 0x%lx\n", <br>               pList, pList-&gt;sNumber, pList-&gt;pNext); <br>        pList = pList-&gt;pNext; <br>    } <br>} <br> <br>DOUBLE_LINK_TYPE * InsertNewNode(short sValue, DOUBLE_LINK_TYPE * pPrevious) <br>{ <br>    DOUBLE_LINK_TYPE * pNew; <br> <br>    do { <br>        pNew = (DOUBLE_LINK_TYPE *)midl_user_allocate(sizeof(DOUBLE_LINK_TYPE)); <br>    } while (pNew == pPrevious); <br> <br>    pNew-&gt;pNext = NULL;      // initialize <br>    pNew-&gt;pPrevious = NULL;  // initialize <br>    pNew-&gt;sNumber = sValue;  // insert b between a and c <br> <br>    pNew-&gt;pPrevious = pPrevious;             // prev(b) = a <br>    if (pPrevious == NULL) <br>        pNew-&gt;pNext = NULL; <br>    else { <br>        pNew-&gt;pNext = pPrevious-&gt;pNext;      // next(b) = c <br>        pPrevious-&gt;pNext = pNew;             // next(a) = b <br>        if (pNew-&gt;pNext != NULL) <br>            (pNew-&gt;pNext)-&gt;pPrevious = pNew; // prev(c) = b <br>    } <br> <br>    return(pNew); <br>} <br> <br> <br>/***************************************************************************/ <br> <br>void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len) <br>{ <br>    return(malloc(len)); <br>} <br> <br>void __RPC_USER midl_user_free(void __RPC_FAR * ptr) <br>{ <br>    free(ptr); <br>} <br> <br> <br>/***************************************************************************/ <br> <br>/* convert from linked list to array */ <br>void __RPC_USER <br>DOUBLE_LINK_TYPE_to_xmit( <br>    DOUBLE_LINK_TYPE __RPC_FAR * pList, <br>    DOUBLE_XMIT_TYPE __RPC_FAR * __RPC_FAR * ppArray) <br>{ <br>    short cCount = 0; <br>    DOUBLE_LINK_TYPE * pHead = pList;  // save pointer to start <br>    DOUBLE_XMIT_TYPE * pArray; <br> <br>    /* count the number of elements to allocate memory */ <br>    for (; pList != NULL; pList = pList-&gt;pNext) <br>        cCount++; <br> <br>    /* allocate the memory for the array */ <br>    pArray = (DOUBLE_XMIT_TYPE *) midl_user_allocate <br>             (sizeof(DOUBLE_XMIT_TYPE) + (cCount * sizeof(short))); <br>    pArray-&gt;sSize = cCount; <br> <br>    /* copy the linked list contents into the array */ <br>    for (cCount = 0, pList = pHead; pList != NULL; pList = pList-&gt;pNext) <br>        pArray-&gt;asNumber[cCount++] = pList-&gt;sNumber; <br> <br>    /* return the address of the pointer to the array */ <br>    *ppArray = pArray; <br>} <br> <br>/* convert from array to linked list */ <br>void __RPC_USER <br>DOUBLE_LINK_TYPE_from_xmit( <br>    DOUBLE_XMIT_TYPE __RPC_FAR * pArray, <br>    DOUBLE_LINK_TYPE __RPC_FAR * pList) <br>{ <br>    DOUBLE_LINK_TYPE *pCurrent; <br>    int i; <br> <br>    if (pArray-&gt;sSize &lt;= 0) {  // error checking <br>        pList = NULL; <br>        return; <br>    } <br> <br>    if (pList == NULL) <br>        pList = InsertNewNode(pArray-&gt;asNumber[0], NULL); <br>    else { <br>        DOUBLE_LINK_TYPE_free_inst(pList);  // free all other nodes <br>        pList-&gt;sNumber = pArray-&gt;asNumber[0]; <br>        pList-&gt;pNext = NULL; <br>    } <br> <br>    pCurrent = pList; <br>    for (i = 1; i &lt; pArray-&gt;sSize; i++)  // write new values <br>        pCurrent = InsertNewNode(pArray-&gt;asNumber[i], pCurrent); <br>} <br> <br> <br>/* free the doubly linked list */ <br>/* move forward through list, freeing the previous entry */ <br>void __RPC_USER <br>DOUBLE_LINK_TYPE_free_inst( <br>    DOUBLE_LINK_TYPE __RPC_FAR * pList) <br>{ <br>    while (pList-&gt;pNext != NULL)  // go to end of list <br>        pList = pList-&gt;pNext; <br> <br>    pList = pList-&gt;pPrevious; <br>    while (pList != NULL) {  // back through list <br>        midl_user_free(pList-&gt;pNext); <br>        pList = pList-&gt;pPrevious; <br>    } <br>} <br> <br>/* free the array structure */ <br>void __RPC_USER <br>DOUBLE_LINK_TYPE_free_xmit( <br>    DOUBLE_XMIT_TYPE __RPC_FAR * pArray) <br>{ <br>    midl_user_free(pArray); <br>} <br> <br>/* end file xmitu.c */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
