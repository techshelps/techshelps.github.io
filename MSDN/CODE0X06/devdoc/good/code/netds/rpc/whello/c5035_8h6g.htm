<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WHELLOC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5038"></a>WHELLOC.C</h2>
<pre><code>/**************************************************************************** <br>                   Microsoft RPC Version 2.0 <br>           Copyright Microsoft Corp. 1992, 1993, 1994- 1996 <br>                        whello Example <br> <br>    FILE:       whelloc.c <br> <br>    PURPOSE:    RPC sample Windows client <br>                Based on Win 3.x SDK Generic template for Windows applications <br> <br>    FUNCTIONS:  WinMain()         - call initialization function, <br>                                    process message loop <br>                InitApplication() - initializ window data and register window <br>                InitInstance()    - save instance handle and create main window <br>                MainWndProc()     - process messages <br> <br>                About()    - process messages for "About" dialog box <br>                Server()   - process messages for "Server" dialog box <br>                Endpoint() - process messages for "Endpoint" dialog box <br>                Send()     - process messages for "Send" dialog box; <br>                             sends on OK <br> <br>                midl_user_allocate() - memory allocation function needed by RPC <br>                midl_user_free()     - memory free function needed by RPC <br> <br>    COMMENTS:   Windows version of the "Hello, world" example. <br> <br>                Windows can have several copies of your application <br>                running at the same time.  The variable hInst keeps <br>                track of which instance the application is so that <br>                processing will be to the correct window. <br> <br>****************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt;       // select between win16 or win32 <br>#include &lt;string.h&gt; <br>#include "whello.h"         // header file generated by MIDL compiler <br>#include "whelloc.h"        // client-specific header file <br> <br>/* global data */ <br> <br>unsigned char   pszProtocolSequence[MAXPROTSEQ]; <br>unsigned char   pszNetworkAddress[UNCLEN+1]; <br>unsigned char   pszEndpoint[PATHLEN+1]; <br>unsigned char * pszUuid            = NULL; <br>unsigned char * pszOptions         = NULL; <br>unsigned char * pszStringBinding   = NULL; <br>unsigned char   pszString[MSGLEN]; <br> <br>int fBound = FALSE;     // flag indicates whether client bound to server <br> <br>HANDLE hInst;           // current instance <br>HCURSOR hHourGlass;     // during calls to RPC API functions <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int) <br> <br>    PURPOSE:  calls initialization function, processes message loop <br> <br>    COMMENTS: Windows recognizes this function by name as the initial <br>              entry point for the program.  This function calls the <br>              application initialization routine, if no other instance <br>              of the program is running, and always calls the instance <br>              initialization routine.  It then executes a message <br>              retrieval and dispatch loop that is the top-level control <br>              structure for the remainder of execution.  The loop is <br>              terminated when a WM_QUIT message is received, at which <br>              time this function exits the application instance by <br>              returning the value passed by PostQuitMessage(). <br> <br>              If this function must abort before entering the message <br>              loop, it returns the conventional value NULL. <br> <br>****************************************************************************/ <br> <br>int WINAPI WinMain(HINSTANCE hInstance,     // current instance <br>                   HINSTANCE hPrevInstance, // previous instance <br>                   LPSTR     lpCmdLine,     // command line <br>                   int       nCmdShow)      // show-window type (open/icon) <br>{ <br>    MSG msg; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br> <br>    if (!hPrevInstance)                   // Other instances of app running? <br>        if (!InitApplication(hInstance))  // Initialize shared things <br>            return(FALSE);               // Exits if unable to initialize <br> <br>    /* Perform initializations that apply to a specific instance */ <br>    if (!InitInstance(hInstance, nCmdShow)) <br>        return(FALSE); <br> <br>    /* Acquire and dispatch messages until a WM_QUIT message is received. */ <br>    while (GetMessage(&amp;msg,        // message structure <br>                      (HWND)NULL,  // handle of window receiving the message <br>                      0,           // lowest message to examine <br>                      0))          // highest message to examine <br>    { <br>        TranslateMessage(&amp;msg);    // Translates virtual key codes <br>        DispatchMessage(&amp;msg);     // Dispatches message to window <br>    } <br> <br>    return(msg.wParam);            // Returns the value from PostQuitMessage <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: InitApplication(HANDLE) <br> <br>    PURPOSE:  Initializes window data and registers window class <br> <br>    COMMENTS: This function is called at initialization time only if <br>              no other instances of the application are running.  This <br>              function performs initialization tasks that can be done <br>              once for any number of running instances. <br> <br>              In this case, we initialize a window class by filling out <br>              a data structure of type WNDCLASS and calling the Windows <br>              RegisterClass() function.  Since all instances of this <br>              application use the same window class, we only need to do <br>              this when the first instance is initialized. <br> <br>****************************************************************************/ <br> <br>BOOL InitApplication(HANDLE hInstance)    // current instance <br>{ <br>    WNDCLASS  wc; <br> <br>    /* Fill in window class structure with parameters that */ <br>    /* describe the main window.                           */ <br>    wc.style = 0; <br>    wc.lpfnWndProc = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon(hInstance, "HelloIcon"); <br>    wc.hCursor = LoadCursor(0, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>    wc.lpszMenuName =  "GenericMenu"; <br>    wc.lpszClassName = "GenericWClass"; <br> <br>    /* Register the window class and return success/failure code. */ <br>    return(RegisterClass(&amp;wc)); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: InitInstance(HANDLE, int) <br> <br>    PURPOSE:  Saves instance handle and creates main window <br> <br>    COMMENTS: This function is called at initialization time for every <br>              instance of this application.  This function performs <br>              initialization tasks that cannot be shared by multiple <br>              instances. <br> <br>              In this case, we save the instance handle in a static <br>              variable and create and display the main program window. <br> <br>****************************************************************************/ <br> <br>BOOL InitInstance(HANDLE hInstance,    // Current instance identifier. <br>                  int    nCmdShow)     // Param for first ShowWindow() call. <br>{ <br>    HWND hWnd;    // Main window handle. <br> <br>    /* Save the instance handle in static variable, which will be used in  */ <br>    /* many subsequence calls from this application to Windows.            */ <br>    hInst = hInstance; <br>    hHourGlass = LoadCursor(0, IDC_WAIT); <br> <br>    /* Create a main window for this application instance.  */ <br>    hWnd = CreateWindow("GenericWClass",           // See RegisterClass() call. <br>                        "RPC Sample Application",  // Text for window title bar. <br>                        WS_OVERLAPPEDWINDOW,       // Window style. <br>                        CW_USEDEFAULT,    // Default horizontal position. <br>                        CW_USEDEFAULT,    // Default vertical position. <br>                        CW_USEDEFAULT,    // Default width. <br>                        CW_USEDEFAULT,    // Default height. <br>                        (HWND) NULL,      // Overlapped windows have no parent. <br>                        (HMENU) NULL,     // Use the window class menu. <br>                        hInstance,        // This instance owns this window. <br>                        (LPVOID) NULL     // Pointer not needed. <br>                        ); <br> <br>    /* If window could not be created, return "failure" */ <br>    if (!hWnd) <br>        return(FALSE); <br> <br>    /* Initialize RPC binding data */ <br>    strcpy(pszProtocolSequence, DEFAULT_PROT_SEQ); <br>    strcpy(pszEndpoint, DEFAULT_ENDPOINT); <br>    pszNetworkAddress[0] = '\0'; <br>    strcpy(pszString, DEFAULT_MESSAGE); <br> <br>    /* Make the window visible; update its client area; and return "success" */ <br>    ShowWindow(hWnd, nCmdShow);  // Show the window <br>    UpdateWindow(hWnd);          // Send WM_PAINT message <br> <br>    return(TRUE);                // Return the value from PostQuitMessage <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LPARAM) <br> <br>    PURPOSE:  Processes messages <br> <br>    MESSAGES: WM_COMMAND  - application menu (About dialog box) <br>              WM_DESTROY  - destroy window <br> <br>    COMMENTS: To process the IDM_ABOUT message, call MakeProcInstance() <br>              to get the current instance address of the About() function. <br>              Then call Dialog box which will create the box according to <br>              the information in your generic.rc file and turn control <br>              over to the About() function.  When it returns, free the <br>              intance address. <br> <br>****************************************************************************/ <br> <br>long APIENTRY MainWndProc(HWND   hWnd,       // window handle <br>                          UINT   message,    // type of message <br>                          WPARAM wParam,     // additional information <br>                          LPARAM lParam)     // additional information <br>{ <br>    DLGPROC lpProc;     // pointer to the dialog box function <br> <br>    switch (message) { <br> <br>    case WM_CREATE: <br> <br>#ifdef WIN16 <br>        RpcWinSetYieldInfo (hWnd, FALSE, 0, 0L); // To make TCP/IP happy <br>#else <br>        PostMessage(hWnd, WM_COMMAND, IDM_BIND, 0L);    // bind to server <br>#endif <br>        break; <br> <br>    case WM_COMMAND:    // message: command from application menu <br>        switch (wParam) { <br> <br>        case IDM_BIND: <br>            if (Bind(hWnd) != RPC_S_OK) <br>                PostMessage(hWnd, WM_DESTROY, 0, 0L); <br>            break; <br> <br>        case IDM_ABOUT: <br>            lpProc = MakeProcInstance(About, hInst); <br>            DialogBox(hInst,        // current instance <br>                      "AboutBox",   // resource to use <br>                      hWnd,         // parent handle <br>                      lpProc);      // About() instance address <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_PROTSEQ: <br>            lpProc = MakeProcInstance(Protseq, hInst); <br>            DialogBox(hInst,        // current instance <br>                      "ProtseqBox", // resource to use <br>                      hWnd,         // parent handle <br>                      lpProc);      // Server instance address <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_SERVER: <br>            lpProc = MakeProcInstance(Server, hInst); <br>            DialogBox(hInst,        // current instance <br>                      "ServerBox",  // resource to use <br>                      hWnd,         // parent handle <br>                      lpProc);      // Server instance address <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_ENDPOINT: <br>            lpProc = MakeProcInstance(Endpoint, hInst); <br>            DialogBox(hInst,        // current instance <br>                      "EndpointBox",// resource to use <br>                      hWnd,         // parent handle <br>                      lpProc);      // Server instance address <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_SEND: <br>            lpProc = MakeProcInstance(Send, hInst); <br>            DialogBox(hInst,        // current instance <br>                      "SendBox",    // resource to use <br>                      hWnd,         // parent handle <br>                      lpProc);      // Server instance address <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_EXIT: <br>            DestroyWindow(hWnd); <br>            if (fBound == TRUE) { <br>                RpcTryExcept { <br>                    Shutdown();     // shut down the server <br>                } <br>                RpcExcept(1) { <br>                    MessageBox(hWnd, <br>                               EXCEPT_MSG, <br>                               "Remote Procedure Call", <br>                               MB_ICONINFORMATION); <br>                } <br>                RpcEndExcept <br>            } <br>            break; <br> <br>        default:        // Let Windows process it <br>            return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>        } <br>        break; <br> <br>    case WM_DESTROY:    // message: window being destroyed <br>        PostQuitMessage(0); <br>        break; <br> <br>    default:            // Passes it on if unprocessed <br>        return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>    } <br> <br>    return(0); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: Protseq(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages for "Protseq" dialog box <br> <br>    MESSAGES: WM_INITDIALOG - initialize dialog box <br>              WM_COMMAND    - Input received <br> <br>    COMMENTS: No initialization is needed for this particular dialog box, <br>              but TRUE must be returned to Windows. <br> <br>              Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br>BOOL APIENTRY Protseq(HWND hDlg,       // window handle of the dialog box <br>                     UINT message,     // type of message <br>                     UINT wParam,      // message-specific information <br>                     LONG lParam) <br>{ <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:    // message: initialize dialog box <br>        SetDlgItemText((HANDLE)hDlg, IDD_PROTSEQNAME, pszProtocolSequence); <br>        return(TRUE); <br> <br>    case WM_COMMAND:       // message: received a command <br>        switch(wParam) { <br> <br>        case IDCANCEL:     // System menu close command? <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK:         // "OK" box selected? <br>            GetDlgItemText(hDlg, IDD_PROTSEQNAME, pszProtocolSequence, MAXPROTSEQ); <br> <br>            if (Bind(hDlg) != RPC_S_OK) { <br>                EndDialog(hDlg, FALSE); <br>                return(FALSE); <br>            } <br> <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br> <br>        } <br> <br>    } <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: Server(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages for "Server" dialog box <br> <br>    MESSAGES: WM_INITDIALOG - initialize dialog box <br>              WM_COMMAND    - Input received <br> <br>    COMMENTS: No initialization is needed for this particular dialog box, <br>              but TRUE must be returned to Windows. <br> <br>              Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY Server(HWND hDlg,        // window handle of the dialog box <br>                     UINT message,     // type of message <br>                     UINT wParam,      // message-specific information <br>                     LONG lParam) <br>{ <br>    HCURSOR hOld; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:    // message: initialize dialog box <br>        SetDlgItemText((HANDLE)hDlg, IDD_SERVERNAME, pszNetworkAddress); <br>        return(TRUE); <br> <br>    case WM_COMMAND:       // message: received a command <br>        switch(wParam) { <br> <br>        case IDCANCEL:     // System menu close command? <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK:         // "OK" box selected? <br>            GetDlgItemText(hDlg, IDD_SERVERNAME, pszNetworkAddress, UNCLEN); <br> <br>            hOld = SetCursor(hHourGlass); <br>            if (Bind(hDlg) != RPC_S_OK) { <br>                EndDialog(hDlg, FALSE); <br>                return(FALSE); <br>            } <br> <br>            SetCursor(hOld); <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br> <br>        } <br> <br>    } <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: About(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages for "About" dialog box <br> <br>    MESSAGES: WM_INITDIALOG - initialize dialog box <br>              WM_COMMAND    - Input received <br> <br>    COMMENTS: No initialization is needed for this particular dialog box, <br>              but TRUE must be returned to Windows. <br> <br>              Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY About(HWND hDlg,         // window handle of the dialog box <br>                    UINT message,      // type of message <br>                    UINT wParam,       // message-specific information <br>                    LONG lParam) <br>{ <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:    // message: initialize dialog box <br>        return(TRUE); <br> <br>    case WM_COMMAND:       // message: received a command <br>        if (wParam == IDOK || wParam == IDCANCEL) { <br>           EndDialog(hDlg, TRUE); <br>           return(TRUE); <br>        } <br>        break; <br> <br>    } <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: Endpoint(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages for "Endpoint" dialog box <br> <br>    MESSAGES: WM_INITDIALOG - initialize dialog box <br>              WM_COMMAND    - Input received <br> <br>    COMMENTS: No initialization is needed for this particular dialog box, <br>              but TRUE must be returned to Windows. <br> <br>              Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY Endpoint(HWND hDlg,        // window handle of the dialog box <br>                       UINT message,     // type of message <br>                       UINT wParam,      // message-specific information <br>                       LONG lParam) <br>{ <br>    HCURSOR hOld; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:    // message: initialize dialog box <br>        SetDlgItemText(hDlg, IDD_ENDPOINTNAME, pszEndpoint); <br>        return(TRUE); <br> <br>    case WM_COMMAND:       // message: received a command <br>        switch(wParam) { <br> <br>        case IDCANCEL: <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK: <br>            GetDlgItemText(hDlg, IDD_ENDPOINTNAME, pszEndpoint, PATHLEN); <br> <br>            hOld = SetCursor(hHourGlass); <br>            if (Bind(hDlg) != RPC_S_OK) { <br>                EndDialog(hDlg, FALSE); <br>                return(FALSE); <br>            } <br> <br>            SetCursor(hOld); <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br> <br>        } <br> <br>    } <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: Send(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages for "Send" dialog box <br> <br>    MESSAGES: WM_INITDIALOG - initialize dialog box <br>              WM_COMMAND    - Input received <br> <br>    COMMENTS: No initialization is needed for this particular dialog box, <br>              but TRUE must be returned to Windows. <br> <br>              Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY Send(HWND hDlg,        // window handle of the dialog box <br>                   UINT message,     // type of message <br>                   UINT wParam,      // message-specific information <br>                   LONG lParam) <br>{ <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:    // message: initialize dialog box <br>        SetDlgItemText(hDlg, IDD_MESSAGE, pszString); <br>        return(TRUE); <br> <br>    case WM_COMMAND:       // message: received a command <br>        switch(wParam) { <br> <br>        case IDCANCEL: <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK: <br>            GetDlgItemText(hDlg, IDD_MESSAGE, pszString, MSGLEN); <br> <br>            RpcTryExcept { <br>                HelloProc(pszString);  // make call with user message <br>            } <br>            RpcExcept(1) { <br>                char pszFail[MSGLEN]; <br> <br>                sprintf(pszFail, "%s (0x%x)\n", EXCEPT_MSG, RpcExceptionCode()); <br>                MessageBox(hDlg, <br>                           pszFail, <br>                           "Remote Procedure Call", <br>                           MB_ICONINFORMATION); <br>            } <br>            RpcEndExcept <br> <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br> <br>        } <br> <br>    } <br> <br>    return(FALSE);  // Didn't process a message <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: midl_user_allocate(size_t) <br> <br>    PURPOSE:  Allocate memory as needed by the RPC runtime library <br> <br>    COMMENTS: The stubs or runtime libraries may need to allocate memory. <br>              By convention, they call a user-specified function named <br>              midl_user_allocate.  In this application, no memory <br>              management is needed, so a dummy function is provided. <br> <br>****************************************************************************/ <br> <br>void __RPC_FAR * __RPC_API midl_user_allocate(size_t len) <br>{ <br>    UNREFERENCED_PARAMETER(len); <br>    return(NULL);  // no memory management required <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: midl_user_free(void *) <br> <br>    PURPOSE:  Free memory as needed by the RPC runtime library <br> <br>    COMMENTS: The stubs or runtime libraries may need to free memory. <br>              By convention, they call a user-specified function named <br>              midl_user_free.  In this application, no memory allocation <br>              is needed so a dummy function is provided. <br> <br>****************************************************************************/ <br> <br>void __RPC_API midl_user_free(void __RPC_FAR * ptr) <br>{ <br>    UNREFERENCED_PARAMETER(ptr); <br>    return;    // no memory management required <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: Bind(HWND) <br> <br>    PURPOSE:  Make RPC API calls to bind to the server application <br> <br>    COMMENTS: The binding calls are made from InitInstance() and <br>              whenever the user changes the server name or endpoint. <br>              If the bind operation is successful, the global flag <br>              fBound is set to TRUE. <br> <br>              The global flag fBound is used to determine whether to <br>              call the RPC API function RpcBindingFree. <br> <br>****************************************************************************/ <br> <br>RPC_STATUS Bind(HWND hWnd) <br>{ <br>    RPC_STATUS status; <br>    char pszFail[MSGLEN]; <br> <br>    if (fBound == TRUE) {  // unbind only if bound <br>        status = RpcStringFree(&amp;pszStringBinding); <br>        if (status) { <br>            MessageBox(hWnd, "RpcStringFree failed", "RPC Error", MB_ICONSTOP); <br>            return(status); <br>        } <br> <br>        status = RpcBindingFree(&amp;hWHello); <br>        if (status) { <br>            MessageBox(hWnd, "RpcBindingFree failed", "RPC Error", MB_ICONSTOP); <br>            return(status); <br>        } <br> <br>        fBound = FALSE;  // unbind successful; reset flag <br>    } <br> <br>    status = RpcStringBindingCompose(pszUuid, <br>                                     pszProtocolSequence, <br>                                     pszNetworkAddress, <br>                                     pszEndpoint, <br>                                     pszOptions, <br>                                     &amp;pszStringBinding); <br>    if (status) { <br>        sprintf(pszFail, "RpcStringBindingCompose failed: (0x%x)\nNetwork Address = %s\n", <br>                status, pszNetworkAddress); <br>        MessageBox(hWnd, <br>                   pszFail, <br>                   "RPC Runtime Error", <br>                   MB_ICONEXCLAMATION); <br>        return(status); <br>    } <br> <br>    status = RpcBindingFromStringBinding(pszStringBinding, <br>                                         &amp;hWHello); <br>    if (status) { <br>        sprintf(pszFail, "RpcBindingFromStringBinding failed: (0x%x)\nString = %s\n", <br>                status, pszStringBinding); <br>        MessageBox(hWnd, <br>                   pszFail, <br>                   "RPC Runtime Error", <br>                   MB_ICONEXCLAMATION); <br>        return(status); <br>    } <br> <br>    fBound = TRUE;  // bind successful; reset flag <br> <br>    return(status); <br>} <br> <br>/**** end whelloc.c ****/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
