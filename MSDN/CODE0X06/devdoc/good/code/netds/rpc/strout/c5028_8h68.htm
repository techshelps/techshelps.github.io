<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5030"></a>CLIENT.C</h2>
<pre><code>/************************************************************************* <br>                    Copyright Microsoft Corp. 1992-1996 <br>                        Remote Machine strout sample <br> <br>  FILE      :   client.c <br> <br>  USAGE     :   client  -n network_address <br>                        -p protocol_sequence <br>                        -e endpoint <br>                        -o options <br> <br>  PURPOSE   :   Client side of the RPC distributed application strout. <br> <br>  COMMENTS  :   This program shows how to call remote procedures that <br>                allocate memory for a two dimensional array (an array of <br>                character pointers). It calls the server that allocates  <br>                memory to store all the environment strings in, and copies <br>                the environment variables to this memory. The client then  <br>                displays all the data on the client machine. <br> <br>                Since this program uses the implicit binding method, some  <br>                of the binding handling must be done at the client side <br>*************************************************************************/ <br> <br>#include "strout.h"     /* Generated by the midl compiler               */ <br>#include "common.h"     /* Definitions that are common to all files    */ <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/*  Procedure   :   void Usage(_TUCHAR *)                               */ <br>/*  Desc        :   This procedure prints out an error message if the   */ <br>/*                  command line arguments are wrong                    */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void Usage(_TUCHAR * pszProgramName) <br>{ <br>    _tprintf(TEXT("USAGE : %s [-option]\n"), pszProgramName); <br>    _tprintf(TEXT("Options : -n Network Address\n")); <br>    _tprintf(TEXT("          -p Protocol Sequence\n"));   <br>    _tprintf(TEXT("          -e Endpoint\n"));   <br>    _tprintf(TEXT("          -o Options\n"));   <br>    exit(EXECUTION_FAILED); <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* The client main program                                              */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>int main(int argc, char *argv[]) <br>{ <br>    RPC_STATUS nStatus;     /* Return value from the RPC calls          */ <br>    unsigned int <br>        nIdx,               /* Counter in loops                         */ <br>        nNumArgs;           /* Number of commandline arguments          */ <br>    unsigned long  <br>        nNumLines = 0;      /* Number of lines in the environment block */ <br>    str*pEnvBlock;         /* Pointer to an array of string pointers   */ <br>     <br>    // These variables are used for the implicit binding <br>    _TUCHAR*pszUuid            = NULL; <br>    _TUCHAR*pszProtocolSequence= PROTOCOL_SEQUENCE; <br>    _TUCHAR*pszNetworkAddress  = NULL; <br>    _TUCHAR*pszEndpoint        = END_POINT; <br>    _TUCHAR*pszOptions         = NULL; <br>    _TUCHAR*pszStringBinding   = NULL; <br> <br>    /* Get a common handle on the command line arguments for both       */ <br>    /* UNICODE and ASCII                                                */ <br>#ifdef _UNICODE <br>    LPWSTR*szArglist = CommandLineToArgvW(GetCommandLine(), &amp;nNumArgs); <br>    if (NULL == szArglist) <br>    { <br>        _tprintf(TEXT("SERVER.C : CommandLineToArgW failed")); <br>        exit(EXECUTION_FAILED); <br>    } <br>#else <br>    char **szArglist= argv; <br>    nNumArgs = argc; <br>#endif <br> <br>    /* Allow the user to override settings with commandline switches    */ <br>    for (nIdx = 1; nIdx &lt; nNumArgs; nIdx++)  <br>    { <br>        if ((_tcscmp(szArglist[nIdx], TEXT("-n")) == 0) ||  <br>            (_tcscmp(szArglist[nIdx], TEXT("-N")) == 0)) <br>        { <br>            pszNetworkAddress = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-p")) == 0) ||  <br>            (_tcscmp(szArglist[nIdx], TEXT("-P")) == 0)) <br>        { <br>            pszProtocolSequence = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-e")) == 0) ||  <br>                (_tcscmp(szArglist[nIdx], TEXT("-e")) == 0)) <br>        { <br>            pszEndpoint = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-o")) == 0) ||  <br>                (_tcscmp(szArglist[nIdx], TEXT("-O")) == 0)) <br>        { <br>            pszOptions = szArglist[++nIdx]; <br>        } <br>        else  <br>        { <br>            Usage(szArglist[0]); <br>        } <br>    } <br>             <br> <br>    /* Since we are using implicit binding, we need to do some binding  */ <br>    /* from the client side as well.                                    */ <br>    /* Use a function to concatenate the elements of the string         */ <br>    /* binding into the proper sequence                                 */ <br>    nStatus = RpcStringBindingCompose( <br>        pszUuid, <br>        pszProtocolSequence, <br>        pszNetworkAddress, <br>        pszEndpoint, <br>        pszOptions, <br>        &amp;pszStringBinding); <br>    EXIT_IF_FAIL(nStatus, "RpcStringBindingCompose"); <br> <br>    /* Set the binding handle that will be used to bind to the server   */ <br>    nStatus = RpcBindingFromStringBinding( <br>        pszStringBinding, <br>        &amp;global_strout_sample_handle);      /* The global handle used   */ <br>    EXIT_IF_FAIL(nStatus, "RpcBindingFromStringBinding"); <br> <br>    /* Initialize the pointer to NULL */ <br>    pEnvBlock = NULL; <br> <br>    RpcTryExcept                /* Catch any exception that occurs      */ <br>    { <br>        /* Call the remote procedure */ <br>        _tprintf(TEXT("Calling the remote procedure \'GetRemoteEnv\' \n")); <br>        GetRemoteEnv(&amp;nNumLines, &amp;pEnvBlock); <br>    } <br>    RpcExcept(DO_EXCEPTION) <br>    { <br>        _tprintf(TEXT("Run-time exception %08X = %d in %s\n"),  <br>            RpcExceptionCode(), RpcExceptionCode(), TEXT(__FILE__)); <br>        exit(EXECUTION_FAILED); <br>    } <br>    RpcEndExcept <br> <br> <br>    /* Print out the result */ <br>    _tprintf(TEXT("There are %d environment variables\n"), nNumLines); <br>    _tprintf(TEXT("They are:\n")); <br>    for (nIdx = 0; nIdx &lt; nNumLines; nIdx++) <br>    { <br>        _tprintf(TEXT("\t%s\n"), pEnvBlock[nIdx]); <br>    } <br> <br> <br>    // Deallocate all the memory used for the EnvBlock <br>    for (nIdx = 0; nIdx &lt; nNumLines; nIdx++) <br>    { <br>        midl_user_free(pEnvBlock[nIdx]); <br>    } <br>    midl_user_free(pEnvBlock); <br> <br>    // Deallocate the memory used for the ARGLIST if using UNICODE <br>#ifdef _UNICODE <br>    if (NULL != szArglist) <br>        free(szArglist); <br>#endif <br> <br>    /* When the call is done, shut down the server application */ <br>    ShutDown(); <br> <br>    return (EXECUTION_OK); <br>} <br> <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* Procedure    :   midl_user_allocate() and midl_user_free()           */ <br>/* Desc.        :   These procedure are declared in the header file     */ <br>/*                  generated by the midl compiler. These procedures    */ <br>/*                  should be used for all memory allocation and        */ <br>/*                  deallocation.                                       */ <br>/*                  These procedures are also called by the stub code to*/ <br>/*                  allocate and free memory.                           */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void __RPC_FAR * __RPC_API midl_user_allocate(size_t nLen) <br>{ <br>    return (malloc(nLen)); <br>} <br> <br>void __RPC_API midl_user_free(void __RPC_FAR * lpvPointer) <br>{ <br>    if (lpvPointer != NULL) <br>        free (lpvPointer); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
