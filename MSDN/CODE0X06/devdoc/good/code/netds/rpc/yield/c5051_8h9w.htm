<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>YIELDC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5054"></a>YIELDC.C</h2>
<pre><code><br>/**************************************************************************** <br>                   Microsoft RPC Version 2.0 <br>           Copyright Microsoft Corp. 1992, 1993, 1994- 1996 <br>                       yield Example <br> <br>    FILE:       yieldp.c <br> <br>    PURPOSE:    RPC sample Windows client <br>                Based on Win 3.x SDK Generic template for Windows applications <br> <br>    FUNCTIONS:  WinMain()         - same as Windows generic example <br>                InitApplication() - same as Windows generic example <br>                InitInstance()    - same as Windows generic example <br>                MainWndProc()     - processes messages <br> <br>                About()     - processes messages for "About" dialog box <br>                BindInfo()  - processes messages for "Bind" dialog box <br>                WaitInfo()  - processes messages for "Wait" dialog box <br>                YieldInfo() - processes messages for "Yield" dialog box <br> <br>                Bind()               - calls the RPC API functions <br>                midl_user_allocate() - memory allocation function needed by RPC <br>                midl_user_free()     - memory free function needed by RPC <br> <br>    COMMENTS:   This sample application demonstrates the yield capability <br>                of the Microsoft RPC for Microsoft Windows 3.x using the <br>                RpcWinSetYieldInfo API function. <br> <br>                By yielding, you can prevent your distributed application <br>                from blocking during lengthy remote procedure calls. <br> <br>                This sample is based on the Win 3.x generic example. To focus <br>                attention on the RPC-related aspects of this application, <br>                many comments from the Windows-only version are removed. <br> <br>****************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include "yield.h"     // header file generated by MIDL compiler <br>#include "yieldc.h"    // client-specific header file <br> <br>/* global data */ <br> <br>unsigned char   pszProtocolSequence[MAXPROTSEQ+1]; <br>unsigned char   pszNetworkAddress[NETLEN+1]; <br>unsigned char   pszEndpoint[PATHLEN+1]; <br>unsigned char * pszUuid           = NULL; <br>unsigned char * pszOptions        = NULL; <br>unsigned char * pszStringBinding  = NULL; <br> <br>int fBound = FALSE;    // flag indicates whether client is bound to server <br>int fCancel = FALSE;   // flag indicates whether the user has chosen CANCEL <br> <br>unsigned int cWaitSec; // parameter to remote procedure Sleep() <br> <br>int   fCustomYield;    // TRUE = custom yield, FALSE = standard yield <br>DWORD dwOtherInfo;     // depends on the value of fCustomYield <br> <br>HANDLE  hInst;         // current instance <br>HCURSOR hHourGlass;    // during calls to RPC API functions <br>HWND    hWndMain;      // main handle <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int) <br> <br>    PURPOSE:  Calls initialization function, processes message loop <br> <br>    COMMENTS: Windows recognizes this function by name as the initial <br>              entry point for the program.  This function calls the <br>              application initialization routine, if no other instance <br>              of the program is running, and always calls the instance <br>              initialization routine.  It then executes a message <br>              retrieval and dispatch loop that is the top-level control <br>              structure for the remainder of execution.  The loop is <br>              terminated when a WM_QUIT message is received, at which <br>              time this function exits the application instance by <br>              returning the value passed by PostQuitMessage(). <br> <br>              If this function must abort before entering the message <br>              loop, it returns the conventional value NULL. <br> <br>****************************************************************************/ <br> <br>int WINAPI WinMain(HINSTANCE hInstance,      // current instance <br>                   HINSTANCE hPrevInstance,  // previous instance <br>                   LPSTR     lpCmdLine,      // command line <br>                   int       nCmdShow)       // show-window type <br>{ <br>    MSG msg; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br> <br>    if (! hPrevInstance)                   // no other instances of app running <br>        if (! InitApplication(hInstance))  // initialize shared things <br>            return(FALSE);                 // exit if unable to initialize <br> <br>    /* Perform initializations that apply to a specific instance */ <br>    if (! InitInstance(hInstance, nCmdShow)) <br>        return(FALSE); <br> <br>    /* Acquire and dispatch messages until a WM_QUIT message is received */ <br>    while (GetMessage(&amp;msg,        // message structure <br>                      (HWND)NULL,  // handle of window receiving the message <br>                      0,           // lowest message to examine <br>                      0))          // highest message to examine <br>    { <br>        TranslateMessage(&amp;msg);    // translate virtual key codes <br>        DispatchMessage(&amp;msg);     // dispatche message to window <br>    } <br> <br>    return(msg.wParam);  // return the value from PostQuitMessage <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: InitApplication(HANDLE) <br> <br>    PURPOSE:  Initializes window data and registers window class <br> <br>    COMMENTS: This function is called at initialization time only if <br>              no other instances of the application are running.  This <br>              function performs initialization tasks that can be done <br>              once for any number of running instances. <br> <br>              In this case, we initialize a window class by filling out <br>              a data structure of type WNDCLASS and calling the Windows <br>              RegisterClass() function.  Since all instances of this <br>              application use the same window class, we only need to do <br>              this when the first instance is initialized. <br> <br>****************************************************************************/ <br> <br>BOOL InitApplication(HANDLE hInstance)    // current instance <br>{ <br>    WNDCLASS wc; <br> <br>    /* Fill in the window class structure with parameters that   */ <br>    /* describe the main window                                  */ <br>    wc.style         = 0; <br>    wc.lpfnWndProc   = (WNDPROC) MainWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon         = LoadIcon(hInstance, "YieldIcon"); <br>    wc.hCursor       = LoadCursor((HANDLE) NULL, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>    wc.lpszMenuName  = "GenericMenu"; <br>    wc.lpszClassName = "GenericWClass"; <br> <br>    /* Register the window class and return success/failure code */ <br>    return(RegisterClass(&amp;wc)); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION:  InitInstance(HANDLE, int) <br> <br>    PURPOSE:   Saves instance handle and creates main window <br> <br>    COMMENTS:  This function is called at initialization time for every <br>               instance of this application.  This function performs <br>               initialization tasks that cannot be shared by multiple <br>               instances. <br> <br>               In this case, we save the instance handle in a global <br>               variable and create and display the main program window. <br> <br>****************************************************************************/ <br> <br>BOOL InitInstance(HANDLE  hInstance,    // current instance <br>                  int     nCmdShow)     // param for first ShowWindow() call <br>{ <br>    HWND hWnd; <br> <br> <br>    /* Save the instance handle in global variable, which will be used */ <br>    /* in many subsequence calls from this application to Windows      */ <br>    hInst = hInstance; <br>    hHourGlass = LoadCursor((HANDLE) NULL, IDC_WAIT); <br> <br>    /* Create a main window for this application instance */ <br>    hWnd = CreateWindow("GenericWClass", <br>                        "RPC Sample Application", <br>                        WS_OVERLAPPEDWINDOW, <br>                        CW_USEDEFAULT, <br>                        CW_USEDEFAULT, <br>                        CW_USEDEFAULT, <br>                        CW_USEDEFAULT, <br>                        (HWND) NULL, <br>                        (HMENU) NULL, <br>                        hInstance, <br>                        (LPVOID) NULL <br>                        ); <br> <br>    /* If the window cannot be created, return "failure" */ <br>    if (!hWnd) <br>        return(FALSE); <br> <br>    /* Initialize RPC binding data */ <br>    strcpy(pszProtocolSequence, DEFAULT_PROT_SEQ); <br>    strcpy(pszEndpoint, DEFAULT_ENDPOINT); <br>    pszNetworkAddress[0] = '\0'; <br> <br>    /* Bind client to server */ <br>    fBound = FALSE; <br> <br>    /* Initialize the parameter to the remote procedure Sleep() */ <br>    cWaitSec = DEFAULT_WAIT; <br> <br>    /* Initialize the parameters to RpcWinSetYieldInfo() */ <br>    fCustomYield = FALSE;         // FALSE = std yield <br>    dwOtherInfo = (DWORD) NULL;   // NULL = RPC-supplied dialog box <br> <br>    RpcWinSetYieldInfo(hWnd,                  // handle <br>                       fCustomYield,          // standard or custom yield? <br>                       WM_RPC_YIELD_MESSAGE,  // 0 = no message is posted <br>                       dwOtherInfo);          // depends on fCustomYield value <br> <br>    /* Make the window visible, update its client area, and return "success" */ <br>    ShowWindow(hWnd, nCmdShow); <br>    UpdateWindow(hWnd); <br> <br>    return(TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LPARAM) <br> <br>    PURPOSE:  Processes messages <br> <br>    MESSAGES: WM_COMMAND  - application menu (About dialog box) <br>              WM_DESTROY  - destroy window <br> <br>    COMMENTS: Based on the Windows generic sample. <br>              Several new menu items are added to demonstrate the <br>              RpcWinSetYieldInfo function. <br> <br>              The "Bind" menu is associated with the "GetBindInfo" <br>              dialog box function.  GetBindInfo allows the user to <br>              set the parameters for the RpcStringBindingCompose and <br>              RpcBindingFromStringBinding functions.  A flag, fBound, <br>              keeps track of whether the client application is bound <br>              to a remote server.  If this flag indicates that the <br>              client application is not bound to the server, it calls <br>              the "Bind" utility function to call the <br>              RPC API functions that establish the binding. <br> <br>              The "Yield" menu is associated with the "GetYieldInfo" <br>              dialog box function. GetYieldInfo allows the user to <br>              select the yielding model:  standard yield with an <br>              RPC run-time library-supplied dialog box; standard <br>              yield with a user-supplied dialog box; or custom yield. <br>              These methods are described in detail in the documentation <br>              for the RpcWinSetYieldInfo function. <br> <br>****************************************************************************/ <br> <br>long APIENTRY MainWndProc(HWND hWnd,       // window handle <br>                          UINT message,    // type of message <br>                          WPARAM wParam,   // additional information <br>                          LPARAM lParam    // additional information <br>                          ) <br>{ <br>    DLGPROC lpProc;    // pointer to the dialog box function <br> <br>    /* copy the window handle for CustomYield() */ <br>    hWndMain = hWnd; <br> <br>    switch (message) { <br> <br>    case WM_CREATE: <br>        /* Win 3.x is client-only; force user to specify server */ <br>        PostMessage(hWnd, WM_COMMAND, IDM_BIND, 0L); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (wParam) { <br> <br>        case IDM_ABOUT: <br>            lpProc = MakeProcInstance(About, hInst); <br>            DialogBox(hInst, <br>                      "AboutBox", <br>                      hWnd, <br>                      lpProc); <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_BIND: <br>            lpProc = MakeProcInstance(GetBindInfo, hInst); <br>            DialogBox(hInst, <br>                      "BindBox", <br>                      hWnd, <br>                      lpProc); <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_WAIT: <br>            lpProc = MakeProcInstance(GetWaitInfo, hInst); <br>            DialogBox(hInst, <br>                      "WaitBox", <br>                      hWnd, <br>                      lpProc); <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_YIELD: <br>            lpProc = MakeProcInstance(GetYieldInfo, hInst); <br>            DialogBox(hInst, <br>                      "YieldBox", <br>                      hWnd, <br>                      lpProc); <br>            FreeProcInstance(lpProc); <br>            break; <br> <br>        case IDM_EXIT: <br>            DestroyWindow(hWnd); <br>            if (fBound == TRUE) { <br>                RpcTryExcept { <br>                    Shutdown();     // shut down the server <br>                } <br>                RpcExcept(1) { <br>                    MessageBox(hWnd, <br>                               EXCEPT_MSG, <br>                               "Remote Procedure Call", <br>                               MB_ICONINFORMATION); <br>                } <br>                RpcEndExcept <br>            } <br>            break; <br> <br>        default: <br>            return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>        } <br>        break; <br> <br>    case WM_RPC_YIELD_MESSAGE:   // signals beginning or end of yield period <br>        if (wParam == 0) <br>            SetWindowText(hWnd, YIELD_END_MSG); <br>        else if (wParam == 1) <br>            SetWindowText(hWnd, YIELD_START_MSG); <br>        break; <br> <br>    case WM_DESTROY: <br>        PostQuitMessage(0); <br>        break; <br> <br>    default:  // passes it on if unprocessed <br>        return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>    } <br> <br>    return(0L); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: About(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  "About" dialog box <br> <br>    COMMENTS: <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY About(HWND hDlg, <br>                    UINT message, <br>                    UINT wParam, <br>                    LONG lParam) <br>{ <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        if (wParam == IDOK || wParam == IDCANCEL) { <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br>        } <br>        break; <br> <br>    } <br> <br>    return(FALSE); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: GetBindInfo(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Collect components of string binding; <br>              protocol sequence, network address, endpoint <br> <br>    COMMENTS: <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY GetBindInfo(HWND hDlg, <br>                          UINT message, <br>                          UINT wParam, <br>                          LONG lParam) <br>{ <br>    HCURSOR hOld; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:  // fill in dialog's edit boxes <br>        SetDlgItemText(hDlg, IDD_ENDPOINT, pszEndpoint); <br>        SetDlgItemText(hDlg, IDD_PROT_SEQ, pszProtocolSequence); <br>        SetDlgItemText(hDlg, IDD_NET_ADDR, pszNetworkAddress); <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        switch(wParam) { <br> <br>        case IDCANCEL: <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK: <br>            GetDlgItemText(hDlg, IDD_PROT_SEQ, pszProtocolSequence, MAXPROTSEQ); <br>            GetDlgItemText(hDlg, IDD_ENDPOINT, pszEndpoint, PATHLEN); <br>            GetDlgItemText(hDlg, IDD_NET_ADDR, pszNetworkAddress, NETLEN); <br> <br>            hOld = SetCursor(hHourGlass); <br>            if (Bind(hDlg) != RPC_S_OK) {  // bind to server <br>                EndDialog(hDlg, FALSE); <br>                return(FALSE); <br>            } <br> <br>            SetCursor(hOld); <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br>       } <br>    } <br> <br>    return(FALSE); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: GetWaitInfo(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Prompt user for the parameter to the remote call, <br>              then make the remote procedure call. <br> <br>    COMMENTS: <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY GetWaitInfo(HWND hDlg,     // window handle of the dialog box <br>                          UINT message,  // type of message <br>                          UINT wParam,   // message-specific information <br>                          LONG lParam) <br>{ <br>    int fError; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        SetDlgItemInt(hDlg, IDD_WAITTIME, cWaitSec, FALSE); <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        switch(wParam) { <br> <br>        case IDCANCEL: <br>            EndDialog(hDlg, FALSE); <br>            fCancel = TRUE; <br>            return(TRUE); <br> <br>        case IDOK: <br>            cWaitSec = GetDlgItemInt(hDlg, IDD_WAITTIME, &amp;fError, FALSE); <br>            if (cWaitSec &lt;= 0)            // check for valid entry <br>                cWaitSec = DEFAULT_WAIT;  // set an appropriate value <br> <br>            RpcTryExcept { <br>                YieldProc(cWaitSec);      // make the remote procedure call <br>            } <br>            RpcExcept(1) { <br>                unsigned long ulCode; <br>                char pszFail[MSGLEN]; <br> <br>                ulCode = RpcExceptionCode(); <br>                if (ulCode != RPC_S_CALL_FAILED) { <br>                    sprintf(pszFail, "%s (0x%x)\n", EXCEPT_MSG, ulCode); <br>                    MessageBox(hDlg, <br>                               pszFail, <br>                               "Remote Procedure Call", <br>                               MB_ICONINFORMATION); <br>                } <br>            } <br>            RpcEndExcept <br> <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br>        } <br>    } <br> <br>    return(FALSE); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: CustomYield(void) <br> <br>    PURPOSE:  Message handler during custom yield <br> <br>    MESSAGES: WM_RPC_YIELD_MESSAGE - end of yield message <br>              WM_COMMAND           - Input received <br> <br>    COMMENTS: The callback function must retrieve messages from the <br>              message queue. <br> <br>              The function must return TRUE when the RPC operation <br>              has completed. The function must return FALSE when the <br>              user cancels the RPC operation. <br> <br>****************************************************************************/ <br> <br>BOOL FAR PASCAL __export CustomYield(void) <br>{ <br>    MSG msg; <br> <br>    fCancel = FALSE; <br> <br>    while (TRUE) {  // message processing <br>        GetMessage(&amp;msg, (HWND)NULL, 0, 0); <br> <br>        if (msg.message == WM_RPC_YIELD_MESSAGE) <br>            return(TRUE);  // RPC operation is complete <br> <br>        if (fCancel == TRUE) <br>            return(FALSE); <br> <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    return(TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: GetYieldInfo(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Check radio buttons to see which yield method <br>              was selected by the user, then set the parameters <br>              to RpcWinSetYieldInfo and call RpcWinSetYieldInfo. <br> <br>    COMMENTS: <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY GetYieldInfo(HWND hDlg,     // window handle of the dialog box <br>                           UINT message,  // type of message <br>                           UINT wParam,   // message-specific information <br>                           LONG lParam) <br>{ <br>    int fCheck; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG:  // message: initialize dialog box <br>        if (fCustomYield) <br>            CheckRadioButton(hDlg, IDD_STD_RPC, IDD_CUSTOM, IDD_CUSTOM); <br>        else if (dwOtherInfo != (DWORD) NULL) <br>            CheckRadioButton(hDlg, IDD_STD_RPC, IDD_CUSTOM, IDD_STD_USER); <br>        else <br>            CheckRadioButton(hDlg, IDD_STD_RPC, IDD_CUSTOM, IDD_STD_RPC); <br>        return(TRUE); <br> <br>    case WM_COMMAND:     // message: received a command <br>        switch(wParam) { <br> <br>            case IDCANCEL:   // System menu close command? <br>                EndDialog(hDlg, FALSE); <br>                return(TRUE); <br> <br>            case IDOK: <br>                /* which radio button is checked: Custom yield? */ <br>                fCheck = (int) SendDlgItemMessage(hDlg, <br>                                                  IDD_CUSTOM, <br>                                                  BM_GETCHECK, <br>                                                  0, <br>                                                  0); <br>                if (fCheck == TRUE) { <br>                    fCustomYield = TRUE; <br>                    dwOtherInfo = (DWORD) MakeProcInstance(CustomYield, hInst); <br>                } <br>                else { <br>                    fCustomYield = FALSE; <br> <br>                    /* Standard yield, user-supplied dialog? */ <br>                    fCheck = (int) SendDlgItemMessage(hDlg, <br>                                                      IDD_STD_USER, <br>                                                      BM_GETCHECK, <br>                                                      0, <br>                                                      0); <br>                    if (fCheck == TRUE) { <br>                        HRSRC hrsrc; <br> <br>                        hrsrc = FindResource(hInst, <br>                                             "USERYIELDBOX", <br>                                             RT_DIALOG); <br>                        dwOtherInfo = LoadResource(hInst, hrsrc); <br>                    } <br>                    else { <br>                        /* Assume standard-yield, rpc-supplied dialog box */ <br>                        dwOtherInfo = (DWORD) NULL; <br>                    } <br>                } <br> <br>                RpcWinSetYieldInfo(hWndMain, <br>                                   fCustomYield, <br>                                   WM_RPC_YIELD_MESSAGE, <br>                                   dwOtherInfo); <br> <br>                EndDialog(hDlg, TRUE); <br>                return(TRUE); <br>        } <br>    } <br> <br>    return(FALSE); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: midl_user_allocate(size_t) <br> <br>    PURPOSE:  Allocate memory as needed by the RPC runtime library <br> <br>    COMMENTS: The stubs or runtime libraries may need to allocate memory. <br>              By convention, they call a user-specified function named <br>              midl_user_allocate.  In this application, no memory <br>              management is needed, so a dummy function is provided. <br> <br>****************************************************************************/ <br> <br>void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len) <br>{ <br>    UNREFERENCED_PARAMETER(len); <br>    return(NULL);  // no memory management required <br>} <br> <br>/**************************************************************************** <br> <br>    FUNCTION: midl_user_free(void *) <br> <br>    PURPOSE:  Free memory as needed by the RPC runtime library <br> <br>    COMMENTS: The stubs or runtime libraries may need to free memory. <br>              By convention, they call a user-specified function named <br>              midl_user_free.  In this application, no memory allocation <br>              is needed so a dummy function is provided. <br> <br>****************************************************************************/ <br> <br>void __RPC_USER midl_user_free(void __RPC_FAR * ptr) <br>{ <br>    UNREFERENCED_PARAMETER(ptr); <br>    return;    // no memory management required <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: Bind(HWND) <br> <br>    PURPOSE:  Make RPC API calls to bind to the server application <br> <br>    COMMENTS: The binding calls are made from InitInstance() and whenever <br>              the user changes the protocol sequence, network address, or <br>              endpoint. If the bind operation is successful, the global <br>              flag fBound is set to TRUE. <br> <br>              The global flag fBound is used to determine whether to call <br>              the RPC API function RpcBindingFree. <br> <br>****************************************************************************/ <br> <br>RPC_STATUS Bind(HWND hWnd) <br>{ <br>    RPC_STATUS status; <br>    char pszFail[MSGLEN]; <br> <br>    if (fBound == TRUE) {  // unbind only if bound <br>        status = RpcStringFree(&amp;pszStringBinding);  // remote calls done; unbind <br>        if (status) { <br>            MessageBox(hWnd, "RpcStringFree failed", "RPC Error", MB_ICONSTOP); <br>            return(status); <br>        } <br> <br>        status = RpcBindingFree(&amp;hYield);  // remote calls done; unbind <br>        if (status) { <br>            MessageBox(hWnd, "RpcBindingFree failed", "RPC Error", MB_ICONSTOP); <br>            return(status); <br>        } <br> <br>        fBound = FALSE;  // unbind successful; reset flag <br>    } <br> <br>    status = RpcStringBindingCompose(pszUuid, <br>                                     pszProtocolSequence, <br>                                     pszNetworkAddress, <br>                                     pszEndpoint, <br>                                     pszOptions, <br>                                     &amp;pszStringBinding); <br>    if (status) { <br>        sprintf(pszFail, "RpcStringBindingCompose failed: (0x%x)\nNetwork Address = %s\n", <br>                status, pszNetworkAddress); <br>        MessageBox(hWnd, <br>                   pszFail, <br>                   "RPC Runtime Error", <br>                   MB_ICONEXCLAMATION); <br>        return(status); <br>    } <br> <br>    status = RpcBindingFromStringBinding(pszStringBinding, <br>                                         &amp;hYield); <br>    if (status) { <br>        sprintf(pszFail, "RpcBindingFromStringBinding failed: (0x%x)\nString = %s\n", <br>                status, pszStringBinding); <br>        MessageBox(hWnd, <br>                   pszFail, <br>                   "RPC Runtime Error", <br>                   MB_ICONEXCLAMATION); <br>        return(status); <br>    } <br> <br>    fBound = TRUE;  // bind successful; reset flag <br> <br>    return(status); <br>} <br> <br> <br>/**** end yieldc.c ****/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
