<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVICE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5027"></a>SERVICE.H</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE: service.h <br>// <br>//  AUTHOR: Craig Link <br>// <br>// <br>//  Comments:  The use of this header file and the accompanying service.c <br>//  file simplifies the process of writting a service.  You as a developer <br>//  simply need to follow the TODO's outlined in this header file, and  <br>//  implement the ServiceStart() and ServiceStop() functions. <br>//   <br>//  There is no need to modify the code in service.c.  Just add service.c <br>//  to your project and link with the following libraries... <br>// <br>//  libcmt.lib kernel32.lib advapi.lib shell32.lib <br>// <br>//  This code also supports unicode.  Be sure to compile both service.c and <br>//  and code #include "service.h" with the same Unicode setting. <br>// <br>//  Upon completion, your code will have the following command line interface <br>// <br>//  &lt;service exe&gt; -?                to display this list <br>//  &lt;service exe&gt; -install          to install the service <br>//  &lt;service exe&gt; -remove           to remove the service <br>//  &lt;service exe&gt; -debug &lt;params&gt;   to run as a console app for debugging <br>// <br>//  Note: This code also implements Ctrl+C and Ctrl+Break handlers <br>//        when using the debug option.  These console events cause <br>//        your ServiceStop routine to be called <br>// <br>//        Also, this code only handles the OWN_SERVICE service type <br>//        running in the LOCAL_SYSTEM security context. <br>// <br>//        To control your service ( start, stop, etc ) you may use the <br>//        Services control panel applet or the NET.EXE program. <br>// <br>//        To aid in writing/debugging service, the <br>//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that <br>//        can be used to control, configure, or obtain service status. <br>//        SC displays complete status for any service/driver <br>//        in the service database, and allows any of the configuration <br>//        parameters to be easily changed at the command line. <br>//        For more information on SC.EXE, type SC at the command line. <br>// <br> <br>#ifndef _SERVICE_H <br>#define _SERVICE_H <br> <br> <br>#ifdef __cplusplus <br>extern "C" { <br>#endif <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//// todo: change to desired strings <br>//// <br>// name of the executable <br>#define SZAPPNAME            "RpcSvc" <br>// internal name of the service <br>#define SZSERVICENAME        "SimpleRpcService" <br>// displayed name of the service <br>#define SZSERVICEDISPLAYNAME "Simple RPC Service" <br>// list of service dependencies - "dep1\0dep2\0\0" <br>#define SZDEPENDENCIES       "RPCSS\0\0" <br>////////////////////////////////////////////////////////////////////////////// <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//// todo: ServiceStart()must be defined by in your code. <br>////       The service should use ReportStatusToSCMgr to indicate <br>////       progress.  This routine must also be used by StartService() <br>////       to report to the SCM when the service is running. <br>//// <br>////       If a ServiceStop procedure is going to take longer than <br>////       3 seconds to execute, it should spawn a thread to <br>////       execute the stop code, and return.  Otherwise, the <br>////       ServiceControlManager will believe that the service has <br>////       stopped responding <br>//// <br>VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv); <br>VOID ServiceStop(); <br>////////////////////////////////////////////////////////////////////////////// <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//// The following are procedures which <br>//// may be useful to call within the above procedures, <br>//// but require no implementation by the user. <br>//// They are implemented in service.c <br> <br>// <br>//  FUNCTION: ReportStatusToSCMgr() <br>// <br>//  PURPOSE: Sets the current status of the service and <br>//           reports it to the Service Control Manager <br>// <br>//  PARAMETERS: <br>//    dwCurrentState - the state of the service <br>//    dwWin32ExitCode - error code to report <br>//    dwWaitHint - worst case estimate to next checkpoint <br>// <br>//  RETURN VALUE: <br>//    TRUE  - success  <br>//    FALSE - failure <br>// <br>BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint); <br> <br> <br>// <br>//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg) <br>// <br>//  PURPOSE: Allows any thread to log an error message <br>// <br>//  PARAMETERS: <br>//    lpszMsg - text for message <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>void AddToMessageLog(LPTSTR lpszMsg); <br>////////////////////////////////////////////////////////////////////////////// <br> <br> <br>#ifdef __cplusplus <br>} <br>#endif <br> <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
