<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5022"></a>CLIENT.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   client.c <br>// <br>//  PURPOSE:  This program is a command line oriented <br>//            demonstration of the Simple RPC service sample. <br>// <br>//  FUNCTIONS: <br>//    main(int argc, char **argv); <br>//    StartTime() <br>//    EndTime(); <br>//    DoTimings(); <br>// <br>//  COMMENTS: <br>// <br>//  AUTHOR: <br>//      Mario Goertzel - RPC Development <br>// <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;rpc.h&gt; <br>#include "rpcsvc.h" <br> <br>void Usage(void) <br>{ <br>    printf("Usage:\n" <br>        "\t-n &lt;server addr&gt;  - Defaults to local machine\n" <br>        "\t-t &lt;protseq&gt;      - Defaults to ncalrpc (fast, local only)\n" <br>        "\t-i &lt;iterations&gt;   - Defaults to 100\n" <br>        "\t-s &lt;security lvl&gt; - Default none, range none (1) to privacy (6)\n" <br>        ); <br>    return; <br>} <br> <br> <br>// <br>//  FUNCTIONS: StartTime() <br>//             EndTime() <br>// <br>//  USAGE: <br>//      StartTime(); <br>//        // Do some work. <br>//      mseconds = EndTime(); <br>// <br>//  RETURN VALUE: <br>//      Milliseconds between StartTime() and EndTime() calls. <br> <br>LARGE_INTEGER Time; <br> <br>void StartTime(void) <br>{ <br>    QueryPerformanceCounter(&amp;Time); <br>} <br> <br>ULONG EndTime() <br>{ <br>    LARGE_INTEGER liDiff; <br>    LARGE_INTEGER liFreq; <br> <br>    QueryPerformanceCounter(&amp;liDiff); <br> <br>    liDiff.QuadPart -= Time.QuadPart; <br>    liDiff.QuadPart *= 1000; // Adjust to milliseconds, shouldn't overflow... <br> <br>    (void)QueryPerformanceFrequency(&amp;liFreq); <br> <br>    return ((ULONG)(liDiff.QuadPart / liFreq.QuadPart)); <br>} <br> <br>// <br>//  FUNCTION: DoTimings <br>// <br>//  PURPOSE: Calls and times various RPC calls. <br>//           (Avoid cluttering up main()) <br>// <br>//  PARAMETERS: <br>//    Binding     - Binding to the server. <br>//    iIterations - Number of times to make each call. <br>// <br>//  RETURN VALUE: <br>//    n/a <br>// <br>// <br>void DoTimings(RPC_BINDING_HANDLE Binding, <br>               UINT iIterations) <br>{ <br>    ULONG mseconds; <br>    UINT i; <br>    RPC_STATUS status; <br>    byte bBuffer[4096]; <br>    ULONG lBufferLength; <br>    ULONG lBufferSize; <br> <br>    // Time Pings() (void calls) <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = Ping(Binding); <br>        if (status != RPC_S_OK) <br>            goto Cleanup; <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - void calls.\n", iIterations, mseconds); <br> <br>    // Time [in] buffer's <br>    // <br> <br>    lBufferLength = BUFFER_SIZE; <br>    lBufferSize   = BUFFER_SIZE; <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = BufferIn1(Binding, bBuffer, lBufferLength, lBufferSize); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 100 byte buffer in (1).\n", iIterations, mseconds); <br> <br>    lBufferLength = BUFFER_SIZE; <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = BufferIn3(Binding, bBuffer, lBufferLength); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 100 byte buffer in (2).\n", iIterations, mseconds); <br> <br>    lBufferLength = BUFFER_SIZE; <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = BufferIn3(Binding, bBuffer, lBufferLength); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 100 byte buffer in (3).\n", iIterations, mseconds); <br> <br>    // Time [out] buffer's <br> <br>    lBufferLength = BUFFER_SIZE; <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = BufferOut1(Binding, bBuffer, &amp;lBufferLength); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 100 byte buffer out (1).\n", iIterations, mseconds); <br> <br>    lBufferLength = BUFFER_SIZE; <br>    lBufferSize   = BUFFER_SIZE; <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = BufferOut2(Binding, bBuffer, lBufferSize, &amp;lBufferLength); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 100 byte buffer out (2).\n", iIterations, mseconds); <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        BUFFER Buffer; <br>        Buffer.BufferLength = 0; <br>        Buffer.Buffer = 0; <br> <br>        status = BufferOut3(Binding, &amp;Buffer); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        MIDL_user_free(Buffer.Buffer); <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 100 byte buffer out (3).\n", iIterations, mseconds); <br> <br>    lBufferLength = BUFFER_SIZE; <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = BufferOut4(Binding, bBuffer, &amp;lBufferLength); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 100 byte buffer out (4).\n", iIterations, mseconds); <br> <br>    // Time arrays of structures <br> <br>    { <br>    struct BAD1 abad1[50]; <br>    struct BAD2 abad2[50]; <br>    struct GOOD agood[50]; <br> <br>    for (i = 0; i &lt; 50; i++) <br>        { <br>        abad2[i].e = (BAD_ENUM)i % 4 + 1; <br>        agood[i].e = (GOOD_ENUM)i % 4 + 5; <br>        } <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = StructsIn1(Binding, &amp;abad1[0]); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - 2 mod 4 aligned structs.\n", iIterations, mseconds); <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = StructsIn2(Binding, &amp;abad2[0]); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - structs with an enum.\n", iIterations, mseconds); <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = StructsIn3(Binding, &amp;agood[0]); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - structs with v1_enum.\n", iIterations, mseconds); <br>    } <br> <br>    // Linked lists <br> <br>    { <br>    LIST list; <br>    PLIST plist = &amp;list; <br>    for (i = 0; i &lt; LIST_SIZE - 1; i++) <br>        { <br>        plist-&gt;pNext = MIDL_user_allocate(sizeof(LIST)); <br>        plist-&gt;data = i; <br>        if (plist-&gt;pNext == 0) <br>            { <br>            status = RPC_S_OUT_OF_MEMORY; <br>            goto Cleanup; <br>            } <br>        plist = plist-&gt;pNext; <br>        } <br>    plist-&gt;data = i; <br>    plist-&gt;pNext = 0; <br>     <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = ListIn(Binding, &amp;list); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - [in] linked list.\n", iIterations, mseconds); <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = ListOut1(Binding, &amp;list); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        // Freeing the list here would cause all the elements <br>        // to be allocated again on the next call. <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - [out] linked list (1).\n", iIterations, mseconds); <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = ListOut2(Binding, &amp;list); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        // Freeing the list here would cause all the elements <br>        // to be allocated again on the next call. <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - [out] linked list (2).\n", iIterations, mseconds); <br> <br>    // Free allocated elements of the list. <br>    plist = list.pNext; <br>    while(plist) <br>        { <br>        PLIST tmp = plist; <br>        plist = plist-&gt;pNext; <br>        MIDL_user_free(tmp); <br>        } <br>    } <br> <br>    // Unions <br> <br>    { <br>    BAD_UNION badunionArray[UNION_ARRAY_LEN]; <br>    GOOD_UNION goodunion; <br>    ARM_ONE armone; <br>    ULONG ulArray[UNION_ARRAY_LEN]; <br> <br>    goodunion.Tag = 1; <br>    goodunion.u.pOne = &amp;armone; <br>    armone.DataLength = UNION_ARRAY_LEN; <br>    armone.Data = ulArray; <br> <br>    for(i = 0; i &lt; UNION_ARRAY_LEN; i++) <br>        { <br>        ulArray[i] = i; <br>        badunionArray[i].Tag = 1; <br>        badunionArray[i].u.ulData = i; <br>        } <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = UnionCall1(Binding, UNION_ARRAY_LEN, badunionArray); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - [in] array of unions.\n", iIterations, mseconds); <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br>        status = UnionCall2(Binding, &amp;goodunion); <br>        if (status != RPC_S_OK) <br>            { <br>            goto Cleanup; <br>            } <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - [in] union of arrays.\n", iIterations, mseconds); <br> <br>    } <br> <br>    // Time pings() (null calls) which impersonate the client. <br> <br>    StartTime(); <br>    for(i = iIterations; i; i--) <br>        { <br> <br>        status = CheckSecurity(Binding); <br> <br>        if (status != RPC_S_OK) <br>            { <br>            if (status == RPC_S_ACCESS_DENIED) <br>                { <br>                printf("Access denied, try -s 2 or higher.\n"); <br>                return; <br>                } <br>            goto Cleanup; <br>            } <br> <br>        } <br>    mseconds = EndTime(); <br> <br>    printf("%4d calls in %8d milliseconds - void call w/ impersonation\n", iIterations, mseconds); <br> <br>Cleanup: <br> <br>    if (status != RPC_S_OK) <br>        { <br>        printf("Call failed - %d\n", status); <br>        } <br> <br>    return; <br>} <br> <br>// <br>//  FUNCTION: main <br>// <br>//  PURPOSE: Parses arguments and binds to the server. <br>// <br>//  PARAMETERS: <br>//    argc - number of command line arguments <br>//    argv - array of command line arguments <br>// <br>//  RETURN VALUE: <br>//    Program exit code. <br>// <br>// <br>int main(int argc, char *argv[]) <br>{ <br>    char *serverAddress = NULL; <br>    char *protocol = "ncalrpc"; <br>    UINT iIterations = 100; <br>    unsigned char *stringBinding; <br>    RPC_BINDING_HANDLE Binding; <br>    RPC_STATUS status; <br>    ULONG SecurityLevel = RPC_C_AUTHN_LEVEL_NONE; <br> <br>    argc--; <br>    argv++; <br>    while(argc) <br>        { <br>        if (   argv[0][0] != '-' <br>            &amp;&amp; argv[0][0] != '/') <br>            { <br>            Usage(); <br>            return(1); <br>            } <br> <br>        switch(argv[0][1]) <br>            { <br>            case 'n': <br>                if (argc &lt; 2) <br>                    { <br>                    Usage(); <br>                    return(1); <br>                    } <br>                serverAddress = argv[1]; <br>                argc--; <br>                argv++; <br>                break; <br>            case 't': <br>                if (argc &lt; 2) <br>                    { <br>                    Usage(); <br>                    return(1); <br>                    } <br>                protocol = argv[1]; <br>                argc--; <br>                argv++; <br>                break; <br>            case 'i': <br>                if (argc &lt; 2) <br>                    { <br>                    Usage(); <br>                    return(1); <br>                    } <br>                iIterations = atoi(argv[1]); <br>                argc--; <br>                argv++; <br>                break; <br>            case 's': <br>                if (argc &lt; 2) <br>                    { <br>                    Usage(); <br>                    return(1); <br>                    } <br>                SecurityLevel = atoi(argv[1]); <br>                if (SecurityLevel &gt; RPC_C_AUTHN_LEVEL_PKT_PRIVACY) <br>                    { <br>                    Usage(); <br>                    return(1); <br>                    } <br>                argc--; <br>                argv++; <br>                break; <br>            default: <br>                Usage(); <br>                return(1); <br>                break; <br>            } <br> <br>        argc--; <br>        argv++; <br>        } <br> <br>    status = RpcStringBindingCompose(0, <br>                                     protocol, <br>                                     serverAddress, <br>                                     0, <br>                                     0, <br>                                     &amp;stringBinding); <br>    if (status != RPC_S_OK) <br>        { <br>        printf("RpcStringBindingCompose failed - %d\n", status); <br>        return(1); <br>        } <br> <br>    status = RpcBindingFromStringBinding(stringBinding, &amp;Binding); <br> <br>    if (status != RPC_S_OK) <br>        { <br>        printf("RpcBindingFromStringBinding failed - %d\n", status); <br>        return(1); <br>        } <br> <br>    status = <br>    RpcBindingSetAuthInfo(Binding, <br>                          0, <br>                          SecurityLevel, <br>                          RPC_C_AUTHN_WINNT, <br>                          0, <br>                          0 <br>                         ); <br> <br>    if (status != RPC_S_OK) <br>        { <br>        printf("RpcBindingSetAuthInfo failed - %d\n", status); <br>        return(1); <br>        } <br> <br>    status = Ping(Binding); <br> <br>    if (status != RPC_S_OK) <br>        { <br>        printf("Ping failed - %d\n", status); <br>        } <br> <br>    printf("Connected.\n"); <br> <br>    // <br>    // Call and time various RPC calls. <br>    // <br> <br>    DoTimings(Binding, iIterations); <br> <br>    // Cleanup <br> <br>    status = RpcBindingFree(&amp;Binding); <br> <br>    // ASSERT(status == RPC_S_OK): <br> <br>    status = RpcStringFree(&amp;stringBinding); <br> <br>    // ASSERT(status == RPC_S_OK); <br> <br>    return(0); <br>} <br> <br>void * __RPC_USER MIDL_user_allocate(size_t size) <br>{ <br>    return(HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size)); <br>} <br> <br>void __RPC_USER MIDL_user_free( void *pointer) <br>{ <br>    HeapFree(GetProcessHeap(), 0, pointer); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
