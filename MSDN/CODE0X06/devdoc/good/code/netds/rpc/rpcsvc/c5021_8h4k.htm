<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RPCSVC.IDL</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5024"></a>RPCSVC.IDL</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   rpcsvc.idl <br>// <br>//  PURPOSE:  Simple RPC service .idl file.  This defines the wire <br>//            "contract" between a client and server using this <br>//            interface.  All data types and functions (methods, <br>//            operations) that go over the wire must be defined here. <br>// <br>// <br>[ <br>uuid(15cd3850-28ca-11ce-a4e8-00aa006116cb), <br>version(1.0) <br>] <br>interface RpcServiceSample <br>{ <br> <br>    error_status_t <br>Ping( <br>    [in] handle_t Binding <br>    ); <br> <br> <br>    error_status_t <br>CheckSecurity( <br>    [in] handle_t Binding <br>    ); <br> <br> <br>// Sending a buffer (writing) to the server. <br> <br>// <br>// BufferIn1 and BufferIn2 both use length_is() and size_is(). <br>// This slows performance, because a larger buffer must be <br>// allocated on the sever and the data copied into this larger <br>// buffer. <br>// <br>// BufferIn2 has the most problems because it forces a 16K <br>// allocation which may be much larger then needed and requires <br>    // and extra data copy.  It also limits clients to writing 16K <br>    // at a time. <br>// <br>// The BufferIn3() function saves the allocation and copy <br>    // and gives the client complete control of the size. <br>    // <br>// Notes: Avoid length_is() on [in] parameters.  Usually <br>    //        size_is() is all that is really needed. <br> <br>    const unsigned long BUFFER_SIZE = 100; <br> <br>error_status_t <br>BufferIn1( <br>         [in] handle_t Binding, <br>         [length_is(BufferLength), size_is(BufferSize), <br>      in ] byte Buffer[], <br>         [in] unsigned long BufferLength, <br>             [in] unsigned long BufferSize <br>         ); <br> <br>    error_status_t <br>BufferIn2( <br>         [in] handle_t Binding, <br>         [length_is(BufferLength), in ] byte Buffer[16*1024], <br>             [in] unsigned long BufferLength <br>             ); <br> <br>    error_status_t <br>    BufferIn3( <br>         [in] handle_t Binding, <br>         [size_is(BufferLength), in ] byte Buffer[], <br>         [in] unsigned long BufferLength <br>             ); <br> <br>    // Getting a buffer (reading) from the server. <br>    // <br>    // In BufferOut1 the size of the output is limited to 16K, <br>    // which will force extra round trips when more then 16K <br>    // is being returned. This requires the client to supply a <br>    // 16K buffer and the stub to allocate 16K on the server side. <br>    // <br>    // In BufferOut2 the client decides how big the buffer <br>    // should be and only as much as the client wants is <br>    // allocated in the server.  Similar to BufferOut4 <br>    // which is better. <br>    // <br>    // In BufferOut3 the server allocates a buffer exactly <br>    // as large as it wants.  This results in two allocations, <br>    // one in the server manager and one in the client.  This <br>    // is best if the clients have no idea how much data the <br>    // server will give them. <br>    // <br>    // In BufferOut4 the client decides how big the buffer <br>    // should be.  The server can shorten (this should <br>    // be uncommon) the buffer if needed. <br>    // <br>    // Notes: Consider how the client and server interact <br>    //   in your application when choosing a "read" style <br>    //   interface. <br> <br> <br>    error_status_t <br>    BufferOut1( <br>              [in] handle_t Binding, <br>              [length_is(*pBufferLength)] byte Buffer[16*1024], <br>              [out] unsigned long *pBufferLength <br>              ); <br> <br>    error_status_t <br>    BufferOut2( <br>              [in] handle_t Binding, <br>              [size_is(BufferSize), length_is(*pBufferLength), <br>               out] byte Buffer[], <br>              [in] unsigned long BufferSize, <br>              [out] unsigned long *pBufferLength <br>              ); <br> <br>    typedef struct { <br>        unsigned long BufferLength; <br>        [unique, size_is(BufferLength)] byte *Buffer; <br>        } BUFFER; <br> <br>    error_status_t <br>    BufferOut3( <br>              [in] handle_t Binding, <br>              [out] BUFFER *pBuffer <br>              ); <br> <br>    error_status_t <br>    BufferOut4( <br>              [in] handle_t Binding, <br>              [out, size_is(*pBufferLength)] byte Buffer[], <br>              [in, out] unsigned long *pBufferLength <br>              ); <br> <br>    // Structures and Enums. <br>    // <br>    // Use -Zp8 (or higher). (Default on Win32 platforms) <br>    // <br>    // Make sure the structure ends on a 0 mod 4 address. <br>    // <br>    // Use [v1_enum] on all enumerated types. <br>    // <br>    // Following these rules will result in structures (and <br>    // arrays of structures) which can be memcpy()'ed to and from <br>    // the wire.  Otherwise the structures will be copied <br>    // member-by-member. (ouch!) <br>    //  <br> <br>    typedef enum { <br>        A = 1, <br>        B, <br>        C, <br>        D <br>        } BAD_ENUM; <br> <br>    typedef [v1_enum] enum { <br>        E = 5, <br>        F, <br>        G, <br>        H <br>        } GOOD_ENUM; <br> <br>    struct BAD1 { <br>        long l; <br>        short s;  // Ends on 6 % 4 = 2 byte address. <br>        }; <br> <br>    struct BAD2 { <br>        BAD_ENUM e;  // 16bits on the wire, 32bits in memory! <br>        long l;      // How big is it? <br>        }; <br> <br>    struct GOOD { <br>        GOOD_ENUM e;  // v1_enum 32bits on wire and in memory. <br>        long l; <br>        long l2;      // Ends on 12 % 4 = 0 byte address. <br>        }; <br> <br>    error_status_t <br>    StructsIn1( <br>              [in] handle_t Binding, <br>              [in] struct BAD1 array[50] <br>              ); <br> <br>    error_status_t <br>    StructsIn2( <br>              [in] handle_t Binding, <br>              [in] struct BAD2 array[50] <br>              ); <br> <br>    error_status_t <br>    StructsIn3( <br>              [in] handle_t Binding, <br>              [in] struct GOOD array[50] <br>              ); <br>    // Linked list examples <br>    // <br>    // Follow the rules for structs when defining your linked <br>    // list nodes. <br>    // <br>    // ListIn and ListOut1 are the basic linked list functions, <br>    // ListOut1 is more expensive because each node must be copied <br>    // into nodes on the client.  (In ListIn the list pointers <br>    // are fixed up in one big buffer.) <br>    // <br>    // ListOut2 is identical to ListOut1 except that it turns <br>    // on the RPC allocator in the server. <br>    // <br>    // Linked lists are not very efficient for RPC because the <br>    // often require many memory allocations.  When possible, <br>    // replace linked lists with variably sized arrays of structures. <br>    // <br> <br>    const unsigned long LIST_SIZE = 50; <br> <br>    typedef struct LIST { <br>        [unique] struct LIST *pNext; <br>        unsigned long data; <br>        } LIST; <br> <br>    typedef [unique] LIST *PLIST; <br> <br>    error_status_t <br>    ListIn( <br>          [in] handle_t Binding, <br>          [in] PLIST pList <br>          ); <br> <br>    error_status_t <br>    ListOut1( <br>            [in] handle_t Binding, <br>            [out] LIST *pListHead <br>            ); <br> <br>    // [enable_allocate] in .acf. <br>    error_status_t <br>    ListOut2( <br>            [in] handle_t Binding, <br>            [out] LIST *pListHead <br>            ); <br> <br>    // Unions <br>    // <br>    // Avoid using very many unions. For example, don't pass an array in <br>    // which each element contains a union with several arms.  Instead, <br>    // define several different structures and define a union with several <br>    // arms each being an array of one of the different types of structures. <br>    //  <br>    // Do NOT define a [default] arm for your unions.  This way a future <br>    // version of the union can include new arms and still interoperate <br>    // with older versions of the interface. <br>    // <br>    // Avoid passing unions by value. <br>    // <br> <br>    const unsigned long UNION_ARRAY_LEN = 50; <br> <br>    typedef struct BAD_UNION { <br>        unsigned long Tag; <br>        [switch_is(Tag)] union <br>            { <br>            [case(1)] <br>                unsigned long ulData; <br>            [case(2)] <br>                unsigned hyper uhData; <br>            [default] <br>                // The default arm here prevents the addition of <br>                // another case in future versions. <br>                ; <br>            } u; <br>        } BAD_UNION; <br> <br>    typedef struct ONE { <br>        unsigned long DataLength; <br>        [size_is(DataLength)] unsigned long *Data; <br>        } ARM_ONE; <br> <br>    typedef struct TWO { <br>        unsigned long DataLength; <br>        [size_is(DataLength)] unsigned hyper *Data; <br>        } ARM_TWO; <br> <br>    typedef struct { <br>        unsigned long Tag; <br>        [switch_is(Tag)] union <br>            { <br>            [case (1)] <br>                [unique] ARM_ONE *pOne; <br>            [case (2)] <br>                [unique] ARM_TWO *pTwo; <br> <br>            // May add [case(3)] in a future version. <br>            // <br>            // When calling a down level server with Tag == 3 the <br>            // error RPC_S_INVALID_TAG will get returned.  Values <br>            // 1 and 2 will continue to work. <br>            // <br>            // If there was a [default] arm this wouldn't work. <br> <br>            } u; <br>        } GOOD_UNION; <br> <br>        error_status_t <br>        UnionCall1( <br>                  [in] handle_t Binding, <br>                  [in] unsigned long Length, <br>                  [in, size_is(Length)] BAD_UNION ArrayOfUnions[] <br>                  ); <br>     <br>        error_status_t <br>        UnionCall2( <br>                  [in] handle_t Binding, <br>                  [in] GOOD_UNION *pUnionContainingArrays <br>                  ); <br>  <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
