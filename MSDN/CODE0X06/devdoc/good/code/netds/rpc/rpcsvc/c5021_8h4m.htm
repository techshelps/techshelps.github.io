<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVICE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5026"></a>SERVICE.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   service.c <br>// <br>//  PURPOSE:  Implements functions required by all services <br>//            windows. <br>// <br>//  FUNCTIONS: <br>//    main(int argc, char **argv); <br>//    service_ctrl(DWORD dwCtrlCode); <br>//    service_main(DWORD dwArgc, LPTSTR *lpszArgv); <br>//    CmdInstallService(); <br>//    CmdRemoveService(); <br>//    CmdDebugService(int argc, char **argv); <br>//    ControlHandler ( DWORD dwCtrlType ); <br>//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize ); <br>// <br>//  COMMENTS: <br>// <br>//  AUTHOR: Craig Link - Microsoft Developer Support <br>// <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>#include "service.h" <br> <br> <br> <br>// internal variables <br>SERVICE_STATUS          ssStatus;       // current status of the service <br>SERVICE_STATUS_HANDLE   sshStatusHandle; <br>DWORD                   dwErr = 0; <br>BOOL                    bDebug = FALSE; <br>TCHAR                   szErr[256]; <br> <br>// internal function prototypes <br>VOID WINAPI service_ctrl(DWORD dwCtrlCode); <br>VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv); <br>VOID CmdInstallService(); <br>VOID CmdRemoveService(); <br>VOID CmdDebugService(int argc, char **argv); <br>BOOL WINAPI ControlHandler ( DWORD dwCtrlType ); <br>LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize ); <br> <br>// <br>//  FUNCTION: main <br>// <br>//  PURPOSE: entrypoint for service <br>// <br>//  PARAMETERS: <br>//    argc - number of command line arguments <br>//    argv - array of command line arguments <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    main() either performs the command line task, or <br>//    call StartServiceCtrlDispatcher to register the <br>//    main service thread.  When the this call returns, <br>//    the service has stopped, so exit. <br>// <br>void main(int argc, char **argv) <br>{ <br>    SERVICE_TABLE_ENTRY dispatchTable[] = <br>    { <br>        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main }, <br>        { NULL, NULL } <br>    }; <br> <br>    if ( (argc &gt; 1) &amp;&amp; <br>         ((*argv[1] == '-') || (*argv[1] == '/')) ) <br>    { <br>        if ( _stricmp( "install", argv[1]+1 ) == 0 ) <br>        { <br>            CmdInstallService(); <br>        } <br>        else if ( _stricmp( "remove", argv[1]+1 ) == 0 ) <br>        { <br>            CmdRemoveService(); <br>        } <br>        else if ( _stricmp( "debug", argv[1]+1 ) == 0 ) <br>        { <br>            bDebug = TRUE; <br>            CmdDebugService(argc, argv); <br>        } <br>        else <br>        { <br>            goto dispatch; <br>        } <br>        exit(0); <br>    } <br> <br>    // if it doesn't match any of the above parameters <br>    // the service control manager may be starting the service <br>    // so we must call StartServiceCtrlDispatcher <br>    dispatch: <br>        // this is just to be friendly <br>        printf( "%s -install          to install the service\n", SZAPPNAME ); <br>        printf( "%s -remove           to remove the service\n", SZAPPNAME ); <br>        printf( "%s -debug &lt;params&gt;   to run as a console app for debugging\n", SZAPPNAME ); <br>        printf( "\nStartServiceCtrlDispatcher being called.\n" ); <br>        printf( "This may take several seconds.  Please wait.\n" ); <br> <br>        if (!StartServiceCtrlDispatcher(dispatchTable)) <br>            AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed.")); <br>} <br> <br> <br> <br>// <br>//  FUNCTION: service_main <br>// <br>//  PURPOSE: To perform actual initialization of the service <br>// <br>//  PARAMETERS: <br>//    dwArgc   - number of command line arguments <br>//    lpszArgv - array of command line arguments <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>//    This routine performs the service initialization and then calls <br>//    the user defined ServiceStart() routine to perform majority <br>//    of the work. <br>// <br>void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv) <br>{ <br> <br>    // register our service control handler: <br>    // <br>    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl); <br> <br>    if (!sshStatusHandle) <br>        goto cleanup; <br> <br>    // SERVICE_STATUS members that don't change in example <br>    // <br>    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; <br>    ssStatus.dwServiceSpecificExitCode = 0; <br> <br> <br>    // report the status to the service control manager. <br>    // <br>    if (!ReportStatusToSCMgr( <br>        SERVICE_START_PENDING, // service state <br>        NO_ERROR,              // exit code <br>        3000))                 // wait hint <br>        goto cleanup; <br> <br> <br>    ServiceStart( dwArgc, lpszArgv ); <br> <br>cleanup: <br> <br>    // try to report the stopped status to the service control manager. <br>    // <br>    if (sshStatusHandle) <br>        (VOID)ReportStatusToSCMgr( <br>                            SERVICE_STOPPED, <br>                            dwErr, <br>                            0); <br> <br>    return; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: service_ctrl <br>// <br>//  PURPOSE: This function is called by the SCM whenever <br>//           ControlService() is called on this service. <br>// <br>//  PARAMETERS: <br>//    dwCtrlCode - type of control requested <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>VOID WINAPI service_ctrl(DWORD dwCtrlCode) <br>{ <br>    // Handle the requested control code. <br>    // <br>    switch(dwCtrlCode) <br>    { <br>        // Stop the service. <br>        // <br>        case SERVICE_CONTROL_STOP: <br>            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0); <br>            ServiceStop(); <br>            return; <br> <br>        // Update the service status. <br>        // <br>        case SERVICE_CONTROL_INTERROGATE: <br>            break; <br> <br>        // invalid control code <br>        // <br>        default: <br>            break; <br> <br>    } <br> <br>    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0); <br> <br>} <br> <br> <br> <br>// <br>//  FUNCTION: ReportStatusToSCMgr() <br>// <br>//  PURPOSE: Sets the current status of the service and <br>//           reports it to the Service Control Manager <br>// <br>//  PARAMETERS: <br>//    dwCurrentState - the state of the service <br>//    dwWin32ExitCode - error code to report <br>//    dwWaitHint - worst case estimate to next checkpoint <br>// <br>//  RETURN VALUE: <br>//    TRUE  - success <br>//    FALSE - failure <br>// <br>//  COMMENTS: <br>// <br>BOOL ReportStatusToSCMgr(DWORD dwCurrentState, <br>                         DWORD dwWin32ExitCode, <br>                         DWORD dwWaitHint) <br>{ <br>    static DWORD dwCheckPoint = 1; <br>    BOOL fResult = TRUE; <br> <br> <br>    if ( !bDebug ) // when debugging we don't report to the SCM <br>    { <br>        if (dwCurrentState == SERVICE_START_PENDING) <br>            ssStatus.dwControlsAccepted = 0; <br>        else <br>            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP; <br> <br>        ssStatus.dwCurrentState = dwCurrentState; <br>        ssStatus.dwWin32ExitCode = dwWin32ExitCode; <br>        ssStatus.dwWaitHint = dwWaitHint; <br> <br>        if ( ( dwCurrentState == SERVICE_RUNNING ) || <br>             ( dwCurrentState == SERVICE_STOPPED ) ) <br>            ssStatus.dwCheckPoint = 0; <br>        else <br>            ssStatus.dwCheckPoint = dwCheckPoint++; <br> <br> <br>        // Report the status of the service to the service control manager. <br>        // <br>        if (!(fResult = SetServiceStatus( sshStatusHandle, &amp;ssStatus))) { <br>            AddToMessageLog(TEXT("SetServiceStatus")); <br>        } <br>    } <br>    return fResult; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg) <br>// <br>//  PURPOSE: Allows any thread to log an error message <br>// <br>//  PARAMETERS: <br>//    lpszMsg - text for message <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>VOID AddToMessageLog(LPTSTR lpszMsg) <br>{ <br>    TCHAR   szMsg[256]; <br>    HANDLE  hEventSource; <br>    LPTSTR  lpszStrings[2]; <br> <br> <br>    if ( !bDebug ) <br>    { <br>        dwErr = GetLastError(); <br> <br>        // Use event logging to log the error. <br>        // <br>        hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME)); <br> <br>        _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr); <br>        lpszStrings[0] = szMsg; <br>        lpszStrings[1] = lpszMsg; <br> <br>        if (hEventSource != NULL) { <br>            ReportEvent(hEventSource, // handle of event source <br>                EVENTLOG_ERROR_TYPE,  // event type <br>                0,                    // event category <br>                0,                    // event ID <br>                NULL,                 // current user's SID <br>                2,                    // strings in lpszStrings <br>                0,                    // no bytes of raw data <br>                lpszStrings,          // array of error strings <br>                NULL);                // no raw data <br> <br>            (VOID) DeregisterEventSource(hEventSource); <br>        } <br>    } <br>} <br> <br> <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>// <br>//  The following code handles service installation and removal <br>// <br> <br> <br>// <br>//  FUNCTION: CmdInstallService() <br>// <br>//  PURPOSE: Installs the service <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>void CmdInstallService() <br>{ <br>    SC_HANDLE   schService; <br>    SC_HANDLE   schSCManager; <br> <br>    TCHAR szPath[512]; <br> <br>    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 ) <br>    { <br>        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256)); <br>        return; <br>    } <br> <br>    schSCManager = OpenSCManager( <br>                        NULL,                   // machine (NULL == local) <br>                        NULL,                   // database (NULL == default) <br>                        SC_MANAGER_ALL_ACCESS   // access required <br>                        ); <br>    if ( schSCManager ) <br>    { <br>        schService = CreateService( <br>            schSCManager,               // SCManager database <br>            TEXT(SZSERVICENAME),        // name of service <br>            TEXT(SZSERVICEDISPLAYNAME), // name to display <br>            SERVICE_ALL_ACCESS,         // desired access <br>            SERVICE_WIN32_OWN_PROCESS,  // service type <br>            SERVICE_DEMAND_START,       // start type <br>            SERVICE_ERROR_NORMAL,       // error control type <br>            szPath,                     // service's binary <br>            NULL,                       // no load ordering group <br>            NULL,                       // no tag identifier <br>            TEXT(SZDEPENDENCIES),       // dependencies <br>            NULL,                       // LocalSystem account <br>            NULL);                      // no password <br> <br>        if ( schService ) <br>        { <br>            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) ); <br>            CloseServiceHandle(schService); <br>        } <br>        else <br>        { <br>            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256)); <br>        } <br> <br>        CloseServiceHandle(schSCManager); <br>    } <br>    else <br>        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256)); <br>} <br> <br> <br> <br>// <br>//  FUNCTION: CmdRemoveService() <br>// <br>//  PURPOSE: Stops and removes the service <br>// <br>//  PARAMETERS: <br>//    none <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>void CmdRemoveService() <br>{ <br>    SC_HANDLE   schService; <br>    SC_HANDLE   schSCManager; <br> <br>    schSCManager = OpenSCManager( <br>                        NULL,                   // machine (NULL == local) <br>                        NULL,                   // database (NULL == default) <br>                        SC_MANAGER_ALL_ACCESS   // access required <br>                        ); <br>    if ( schSCManager ) <br>    { <br>        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS); <br> <br>        if (schService) <br>        { <br>            // try to stop the service <br>            if ( ControlService( schService, SERVICE_CONTROL_STOP, &amp;ssStatus ) ) <br>            { <br>                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME)); <br>                Sleep( 1000 ); <br> <br>                while( QueryServiceStatus( schService, &amp;ssStatus ) ) <br>                { <br>                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING ) <br>                    { <br>                        _tprintf(TEXT(".")); <br>                        Sleep( 1000 ); <br>                    } <br>                    else <br>                        break; <br>                } <br> <br>                if ( ssStatus.dwCurrentState == SERVICE_STOPPED ) <br>                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) ); <br>                else <br>                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) ); <br> <br>            } <br> <br>            // now remove the service <br>            if( DeleteService(schService) ) <br>                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) ); <br>            else <br>                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256)); <br> <br> <br>            CloseServiceHandle(schService); <br>        } <br>        else <br>            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256)); <br> <br>        CloseServiceHandle(schSCManager); <br>    } <br>    else <br>        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256)); <br>} <br> <br> <br> <br> <br>/////////////////////////////////////////////////////////////////// <br>// <br>//  The following code is for running the service as a console app <br>// <br> <br> <br>// <br>//  FUNCTION: CmdDebugService(int argc, char ** argv) <br>// <br>//  PURPOSE: Runs the service as a console application <br>// <br>//  PARAMETERS: <br>//    argc - number of command line arguments <br>//    argv - array of command line arguments <br>// <br>//  RETURN VALUE: <br>//    none <br>// <br>//  COMMENTS: <br>// <br>void CmdDebugService(int argc, char ** argv) <br>{ <br>    DWORD dwArgc; <br>    LPTSTR *lpszArgv; <br> <br>#ifdef UNICODE <br>    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &amp;(dwArgc) ); <br>#else <br>    dwArgc   = (DWORD) argc; <br>    lpszArgv = argv; <br>#endif <br> <br>    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME)); <br> <br>    SetConsoleCtrlHandler( ControlHandler, TRUE ); <br> <br>    ServiceStart( dwArgc, lpszArgv ); <br>} <br> <br> <br>// <br>//  FUNCTION: ControlHandler ( DWORD dwCtrlType ) <br>// <br>//  PURPOSE: Handled console control events <br>// <br>//  PARAMETERS: <br>//    dwCtrlType - type of control event <br>// <br>//  RETURN VALUE: <br>//    True - handled <br>//    False - unhandled <br>// <br>//  COMMENTS: <br>// <br>BOOL WINAPI ControlHandler ( DWORD dwCtrlType ) <br>{ <br>    switch( dwCtrlType ) <br>    { <br>        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate <br>        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode <br>            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME)); <br>            ServiceStop(); <br>            return TRUE; <br>            break; <br> <br>    } <br>    return FALSE; <br>} <br> <br>// <br>//  FUNCTION: GetLastErrorText <br>// <br>//  PURPOSE: copies error message text to string <br>// <br>//  PARAMETERS: <br>//    lpszBuf - destination buffer <br>//    dwSize - size of buffer <br>// <br>//  RETURN VALUE: <br>//    destination buffer <br>// <br>//  COMMENTS: <br>// <br>LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize ) <br>{ <br>    DWORD dwRet; <br>    LPTSTR lpszTemp = NULL; <br> <br>    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY, <br>                           NULL, <br>                           GetLastError(), <br>                           LANG_NEUTRAL, <br>                           (LPTSTR)&amp;lpszTemp, <br>                           0, <br>                           NULL ); <br> <br>    // supplied buffer is not long enough <br>    if ( !dwRet || ( (long)dwSize &lt; (long)dwRet+14 ) ) <br>        lpszBuf[0] = TEXT('\0'); <br>    else <br>    { <br>        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character <br>        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() ); <br>    } <br> <br>    if ( lpszTemp ) <br>        LocalFree((HLOCAL) lpszTemp ); <br> <br>    return lpszBuf; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
