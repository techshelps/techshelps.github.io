<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PIPES.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5013"></a>PIPES.C</h2>
<pre><code>/************************************************************************* <br>                    Copyright Microsoft Corp. 1992-1996 <br>                        Remote Machine pipe sample <br> <br>  FILE      :   pipes.c <br> <br>  USAGE     :   server  -p protocol_sequence <br>                        -e endpoint <br> <br>  PURPOSE   :   Server side of the RPC distributed application pipe. <br>   <br>  COMMENTS  :   This application uses the implicit binding method. <br> <br>*************************************************************************/ <br>#include "pipe.h"       // Generated by the MIDL compiler <br>#include "common.h"     // Common definitions is locataed in  this file <br> <br>// Local Procedures  <br>void CleanUpServer();   // Unregisters the interface <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/*  Procedure   :   void Usage(_TUCHAR *)                               */ <br>/*  Desc        :   This procedure prints out an error message if the   */ <br>/*                  command line arguments are wrong                    */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void Usage(_TUCHAR * pszProgramName) <br>{ <br>    _tprintf(TEXT("USAGE : %s [-option]\n"), pszProgramName); <br>    _tprintf(TEXT("Options : -p Protocol Sequence\n"));   <br>    _tprintf(TEXT("          -e Endpoint\n"));   <br>    exit(EXECUTION_FAILED); <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* The server main program                                              */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>int _CRTAPI1 main(int argc, char *argv[]) <br>{ <br>    RPC_STATUS      nStatus;        // Error status returned <br>    int             nNumArgs;       // Number of command line arguments <br>    int             nIdx;           // Counter in loops <br>     <br>    // Variabels used for selecting the protocol and the endpoint <br>    _TUCHAR *pszProtocolSequence    = PROTOCOL_SEQUENCE; <br>    _TUCHAR *pszEndpoint            = END_POINT; <br>    _TUCHAR *pszSecurity            = NULL; <br> <br> <br>// Get a common handle on the command line arguments for both UNICODE <br>// and ASCII <br>#ifdef _UNICODE <br>    LPWSTR*szArglist = CommandLineToArgvW(GetCommandLine(), &amp;nNumArgs); <br>    if (NULL == szArglist) <br>    { <br>        _tprintf(TEXT("SERVER.C : CommandLineToArgW failed")); <br>        exit(EXECUTION_FAILED); <br>    } <br>#else <br>    char **szArglist= argv; <br>    nNumArgs = argc; <br>#endif <br> <br>    /* Allow the user to override settings with commandline switches    */ <br>    for (nIdx = 1; nIdx &lt; nNumArgs; nIdx++)  <br>    { <br>        if((_tcscmp(szArglist[nIdx], TEXT("-p")) == 0) ||  <br>           (_tcscmp(szArglist[nIdx], TEXT("-P")) == 0)) <br>        { <br>            pszProtocolSequence = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-e")) == 0) ||  <br>                (_tcscmp(szArglist[nIdx], TEXT("-e")) == 0)) <br>        { <br>            pszEndpoint = szArglist[++nIdx]; <br>        } <br>        else  <br>        { <br>            Usage(szArglist[0]);   <br>        } <br>    } <br>     <br>     <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    /* Register the interface with the RPC run-time library             */ <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    _tprintf(TEXT("Registering the interface\n")); <br>    nStatus = RpcServerRegisterIf( <br>        pipe_sample_v1_0_s_ifspec,  // Interface specification <br>        NULL,                       // UUID to associate with MgrEnv arg. <br>        NULL);                      // Managers entry point vector. (None) <br>    EXIT_IF_FAIL(nStatus, "RpcServerRegisterIf"); <br> <br> <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    /* Select Protocal sequence : This sample uses namedpipes as the    */ <br>    /* default protocol. The RpcServerUseProtseqEp function tells the   */ <br>    /* RPC run-time library to use the specified protocol sequence      */ <br>    /* combined with the specified endpoint for receiving remote        */ <br>    /* procedure calls                                                  */ <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    _tprintf(TEXT("Selecting the protocol sequence to use.\t\"%s\"\n"), <br>            pszProtocolSequence); <br>    nStatus = RpcServerUseProtseqEp( <br>        pszProtocolSequence,            // String with the protocol in <br>        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // Max number of calls <br>        pszEndpoint,                    // Endpoint addres information <br>        pszSecurity);                   // Security  <br>    EXIT_IF_FAIL(nStatus, "RpcServerUseProtseqsEp"); <br> <br> <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    /* Now start listening for remote procedure calls from the client   */ <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    RpcTryExcept <br>    { <br>        _tprintf(TEXT("Listening for remote calls...\n")); <br>        nStatus = RpcServerListen( <br>            1,                              // The minimum number of calls <br>            RPC_C_LISTEN_MAX_CALLS_DEFAULT, // The maximum number of calls <br>            FALSE);                         // Continue until stopped <br>        EXIT_IF_FAIL(nStatus, "RpcServerListen"); <br>    } <br>    RpcExcept(DO_EXCEPTION) <br>    { <br>        // Print out the exception code  <br>        _tprintf(TEXT("Run-time exception %u in %s at line %d\n"),  <br>                RpcExceptionCode(), TEXT(__FILE__), __LINE__); <br>        exit(EXECUTION_FAILED); <br>    } <br>    RpcEndExcept <br> <br>    // If no exceptions occured, clean up the server and exit <br>    CleanUpServer(); <br> <br>    // Deallocate the memory used for the ARGLIST if using UNICODE <br>#ifdef _UNICODE <br>    if (NULL != szArglist) <br>        free(szArglist); <br>#endif <br> <br>    return (EXECUTION_OK); <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* Procedure    : void CleanUpServer(RPC_BINDING_VECTOR);               */ <br>/* Desc.        : This procedure will unregister the interface          */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void CleanUpServer(void) <br>{ <br>    RPC_STATUS nStatus;          // Error status returned from RPC calls  <br> <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    /* Unregister the interface from the RPC run-time library           */ <br>    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>    _tprintf(TEXT("Unregistering the Interface")); <br>    nStatus = RpcServerUnregisterIf( <br>        NULL, NULL, // Prevents server from receiving any new remote calls <br>        FALSE);    // Wait until all the active calls are complete <br>    EXIT_IF_FAIL(nStatus, "RpcServerUnRegisterIf"); <br>} <br> <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* Procedure    :   midl_user_allocate() and midl_user_free()           */ <br>/* Desc.        :   These procedure are declared in the header file     */ <br>/*                  generated by the midl compiler. These procedures    */ <br>/*                  should be used for all memory allocation and        */ <br>/*                  deallocation.                                       */ <br>/*                  These procedures are also called by the stub code to*/ <br>/*                  allocate and free memory.                           */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void __RPC_FAR * __RPC_API midl_user_allocate(size_t len) <br>{ <br>    return (malloc(len)); <br>} <br> <br>void __RPC_API midl_user_free(void __RPC_FAR * ptr) <br>{ <br>    if(NULL != ptr) <br>        free (ptr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
