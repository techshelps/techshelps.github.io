<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PIPEC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5011"></a>PIPEC.C</h2>
<pre><code>/************************************************************************* <br>                    Copyright Microsoft Corp. 1992-1996 <br>                        Remote Machine pipe sample <br>   <br>    FILE        :   pipec.c <br> <br>    USAGE       :   client  &lt;local file&gt; &lt;new file&gt; [options] <br>                        -s Scramble file <br>                        -u Unscramble the file <br>                        -n network_address <br>                        -p protocol_sequence <br>                        -e endpoint <br>                        -o options <br> <br>    PURPOSE     :   Client side of the RPC distributed application pipes. <br>   <br>    COMMENTS    :   This program shows the client side an application that <br>                    transfers a file from the client to the server, using  <br>                    pipes. When the file is received at the server it  <br>                    "encodes" the data by incrementing all the characters,  <br>                    and sends the "encoded" file back to the client. <br> <br>                    Since this program uses the implicit binding method,  <br>                    some of the binding handling must be done at the client  <br>                    side <br>*************************************************************************/ <br>#include "pipe.h"                   // Generated by the MIDL compiler <br>#include "common.h"                 // Common definitions  <br> <br>#define CLIENT_BUFFER_SIZE  500     // Can send or recieve 500 elements  <br> <br>// Client side global variables <br>pipe_state  in_out_pipe_state;      // Pipe state on the client side <br>_TUCHAR     pcClientBuffer[CLIENT_BUFFER_SIZE];  // Buffer used in PipeAlloc <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/*  Procedure   :   void Usage(_TUCHAR *)                               */ <br>/*  Desc        :   This procedure prints out an error message if the   */ <br>/*                  command line arguments are wrong                    */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void Usage(_TUCHAR * pszProgramName) <br>{ <br>    _tprintf(TEXT("USAGE : %s &lt;local_file&gt; &lt;new_file&gt; [-option]\n"),  <br>        pszProgramName); <br>    _tprintf(TEXT("Options : -s\tTo encode the file\n")); <br>    _tprintf(TEXT("          -u\tTo Decode the file\n")); <br>    _tprintf(TEXT("          -n\t&lt;Network Address&gt;\n")); <br>    _tprintf(TEXT("          -p\t&lt;Protocol Sequence&gt;\n"));   <br>    _tprintf(TEXT("          -e\t&lt;Endpoint&gt;\n"));   <br>    _tprintf(TEXT("          -o\t&lt;Options&gt;\n"));   <br>    exit(EXECUTION_FAILED); <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/*  Procedure   :   PipeAlloc                                           */ <br>/*  Desc        :   This procedure allocates a chunck of memory and     */ <br>/*                  returns a pointer to it.                            */ <br>/*                  In this sample the Alloc routine returns a pointer  */ <br>/*                  to the same global allocated memory every time.     */ <br>/*                  This can be done since after each Pull/Push, data   */ <br>/*                  is read/written to file.                            */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void PipeAlloc( <br>    char            *pcStateInfo,       // The state structure <br>    unsigned long   nReqSize,           // Req. size of buffer in bytes <br>    _TUCHAR         **pcAllocatedBuffer,// Pointer to the allocated buffer <br>    unsigned long   *pnAllocatedSize)   // Size of allocated buf. in bytes <br>{ <br>    // Since the memory is already allocated, just return a pointer to it <br>    if(nReqSize &gt; (CLIENT_BUFFER_SIZE * sizeof(_TUCHAR))) <br>    { <br>        *pnAllocatedSize = CLIENT_BUFFER_SIZE * sizeof(_TUCHAR); <br>    } <br>    else <br>    { <br>        *pnAllocatedSize = nReqSize; <br>    } <br>    *pcAllocatedBuffer = pcClientBuffer; <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/*  Procedure   :   PipePull                                            */ <br>/*  Desc        :   This procedure is called by the stub when its ready */ <br>/*                  to send a chunck of the pipe to the server.         */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void PipePull( <br>    char            *pcStateInfo,   // The state struct on client side <br>    _TUCHAR         *pcBuffer,      // Pointer to the buffer  <br>    unsigned long   nMaxBufferSize, // Size of buffer in elements <br>    unsigned long   *pnSizeToSend)  // Number of elements put in buffer <br>{ <br>    // Declare a state variable  <br>    pipe_state*psState = (pipe_state *) pcStateInfo; <br> <br>    // Open the local file, if it is not already opened  <br>    if(psState-&gt;hOld == NULL) <br>    { <br>        if(NULL == (psState-&gt;hOld =  <br>            _tfopen(psState-&gt;pszOldName, TEXT("rt")))) <br>        { <br>            _tprintf(TEXT("Could not open the file %s\n"), <br>                psState-&gt;pszOldName); <br>            exit(EXECUTION_FAILED); <br>        } <br>    } <br> <br>    // Read max_buffer_size into the buffer <br>    *pnSizeToSend = fread( <br>        pcBuffer,  <br>        sizeof(_TUCHAR),  <br>        nMaxBufferSize, <br>        psState-&gt;hOld); <br> <br>    if(*pnSizeToSend == 0)      // When end of the data is reached <br>    {                           // cleanup the application <br>        fclose(psState-&gt;hOld); <br>        psState-&gt;hOld = NULL; <br>    } <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/*  Procedure   :   PipePush                                            */ <br>/*  Desc        :   This procedure is called by the stub when a chunck  */ <br>/*                  of data is received from the server.                */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void PipePush( <br>    char            *nStateInfo,        // State structure on client side <br>    _TUCHAR         *pcBuffer,          // Ptr to the buffer with the data <br>    unsigned long   nNumberOfElements)  // Number of elements in the buffer <br>{ <br>    // Declare a state variable  <br>    pipe_state*psState = (pipe_state *) nStateInfo; <br> <br>    // Open the New file, if it is not already opened  <br>    if(psState-&gt;hNew == NULL) <br>    { <br>        if(NULL == (psState-&gt;hNew =  <br>            _tfopen(psState-&gt;pszNewName, TEXT("w")))) <br>        { <br>            _tprintf( TEXT("Unable to create the file %s\n"),  <br>                    psState-&gt;pszNewName); <br>            exit(EXECUTION_FAILED); <br>        } <br>    } <br> <br> <br>    // When number of elements received is 0, this is the end of the pipe <br>    if(nNumberOfElements == 0) <br>    { <br>        // Clean up by closing the opened file  <br>        fclose (psState-&gt;hNew); <br>        psState-&gt;hNew = NULL; <br>    } <br>    else <br>    { <br>        // Write the buffer to the file  <br>        fwrite(pcBuffer, sizeof(_TUCHAR), nNumberOfElements, psState-&gt;hNew); <br>    } <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/*  Client side main program                                            */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>int _CRTAPI1 main(int argc, char *argv[]) <br>{ <br>    RPC_STATUS      nStatus;        // Status returned from RPC-calls <br>    CHAR_PIPE_TYPE  in_out_pipe;    // Pipe structure used for the pipe <br>    TCHAR <br>        *pszOldFileName,        // Name of the input file <br>        *pszNewFileName;        // Name of the output file <br>    unsigned long <br>        nAction = SCRAMBLE,     // Scramble / Unscramble file <br>        nIdx,                   // Counter in loops <br>        nNumArgs;               // The number of args from the command line <br> <br>    // These variables are used for the implicit binding <br>    _TUCHAR*pszUuid= NULL; <br>    _TUCHAR*pszProtocolSequence= PROTOCOL_SEQUENCE; <br>    _TUCHAR*pszNetworkAddress= NULL; <br>    _TUCHAR*pszEndpoint= END_POINT; <br>    _TUCHAR*pszOptions= NULL; <br>    _TUCHAR*pszStringBinding= NULL; <br> <br> <br>    // Get a common handle on the command line arguments for both  <br>    // UNICODE and ASCII <br>#ifdef _UNICODE <br>    LPWSTR*szArglist= CommandLineToArgvW(GetCommandLine(), &amp;nNumArgs); <br>    if (NULL == szArglist) <br>    { <br>        _tprintf(TEXT("SERVER.C : CommandLineToArgW failed")); <br>        exit(EXECUTION_FAILED); <br>    } <br>#else <br>    char **szArglist= argv; <br>    nNumArgs = argc; <br>#endif <br> <br>    // Check to see that the call was correct <br>    if (nNumArgs &lt; 3) <br>    { <br>        Usage(szArglist[0]); <br>    } <br>     <br>    // Allow the user to override settings with commandline switches     <br>    for (nIdx = 3; nIdx &lt; nNumArgs; nIdx++)  <br>    { <br>        if ((_tcscmp(szArglist[nIdx], TEXT("-n")) == 0) ||    <br>            (_tcscmp(szArglist[nIdx], TEXT("-N")) == 0)) <br>        { <br>            pszNetworkAddress = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-p")) == 0) ||  <br>            (_tcscmp(szArglist[nIdx], TEXT("-P")) == 0)) <br>        { <br>            pszProtocolSequence = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-e")) == 0) ||  <br>                (_tcscmp(szArglist[nIdx], TEXT("-e")) == 0)) <br>        { <br>            pszEndpoint = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-o")) == 0) ||  <br>               (_tcscmp(szArglist[nIdx], TEXT("-O")) == 0)) <br>        { <br>            pszOptions = szArglist[++nIdx]; <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-s")) == 0) ||  <br>                (_tcscmp(szArglist[nIdx], TEXT("-S")) == 0)) <br>        { <br>            nAction = SCRAMBLE;     <br>        } <br>        else if((_tcscmp(szArglist[nIdx], TEXT("-u")) == 0) ||  <br>                (_tcscmp(szArglist[nIdx], TEXT("-U")) == 0)) <br>        { <br>            nAction = UNSCRAMBLE; <br>        } <br>        else   <br>        { <br>            Usage(szArglist[0]); <br>        } <br>    } <br>     <br>    // Allocate space for the filenames <br>    if(NULL == (pszOldFileName= (TCHAR *) midl_user_allocate( <br>        sizeof(TCHAR) * (_tcsclen(szArglist[1]) + 1)))) <br>    { <br>        _tprintf(TEXT("Memory allocation error\n")); <br>        exit(EXECUTION_FAILED); <br>    } <br>    if(NULL == (pszNewFileName= (TCHAR *) midl_user_allocate( <br>        sizeof(TCHAR) * (_tcsclen(szArglist[2]) + 1)))) <br>    { <br>        _tprintf(TEXT("Memory allocation error\n")); <br>        exit(EXECUTION_FAILED); <br>    } <br> <br>    // Initialize the state variables for the in pipe  <br>    _tcscpy(pszOldFileName, szArglist[1]); <br>    _tcscpy(pszNewFileName, szArglist[2]); <br> <br>    // Since we are doing implicit binding, we need to initialize the  <br>    // global varaible global_pipe_sample_handle from the client. <br>    // Use a function to concatenate the elements of the string          <br>    // binding into the proper sequence                                  <br>    nStatus = RpcStringBindingCompose(  <br>        pszUuid, <br>        pszProtocolSequence, <br>        pszNetworkAddress, <br>        pszEndpoint, <br>        pszOptions, <br>        &amp;pszStringBinding);  <br>    EXIT_IF_FAIL(nStatus, "RpcStringBindingCompose"); <br> <br>    // Set the binding handle that will be used to bind to the server <br>    nStatus = RpcBindingFromStringBinding(    <br>        pszStringBinding,      <br>        &amp;global_pipe_sample_handle);        // The global handle <br>    EXIT_IF_FAIL(nStatus, "RpcBindingFromStringBinding"); <br> <br> <br>    /* Initialize pipestructure */ <br>    in_out_pipe_state.hOld = NULL; <br>    in_out_pipe_state.hNew = NULL; <br>    in_out_pipe_state.pszOldName = pszOldFileName; <br>    in_out_pipe_state.pszNewName = pszNewFileName;     <br> <br>    in_out_pipe.state= (char *) &amp;in_out_pipe_state; <br>    in_out_pipe.alloc= PipeAlloc; <br>    in_out_pipe.pull= PipePull; <br>    in_out_pipe.push= PipePush; <br> <br>    RpcTryExcept <br>    { <br>        // Call the remote procedure to send the file to remote machine <br>        _tprintf(TEXT("Calling the remote procedure ScrambleFile()\n")); <br>        ScrambleFile(nAction, &amp;in_out_pipe); <br>        _tprintf(TEXT("Call to ScrambleFile() returned\n")); <br>    } <br>    RpcExcept(DO_EXCEPTION) <br>    { <br>        _tprintf(TEXT("Run-time exception %08X = %d in %s\n"),  <br>                RpcExceptionCode(), RpcExceptionCode(), TEXT(__FILE__)); <br>        exit(EXECUTION_FAILED); <br>    } <br>    RpcEndExcept <br> <br> <br>    // Deallocate the memory used for the names in the state variable <br>    midl_user_free(pszOldFileName); <br>    midl_user_free(pszNewFileName); <br> <br>    // Deallocate the memory used for the ARGLIST if using UNICODE <br>#ifdef _UNICODE <br>    if (NULL != szArglist) <br>        free(szArglist); <br>#endif <br> <br>    // Shut down the server  <br>    ShutDown(); <br> <br>    return (EXECUTION_OK); <br>} <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* Procedure    :   midl_user_allocate() and midl_user_free()           */ <br>/* Desc.        :   These procedure are declared in the header file     */ <br>/*                  generated by the midl compiler. These procedures    */ <br>/*                  should be used for all memory allocation and        */ <br>/*                  deallocation.                                       */ <br>/*                  These procedures are also called by the stub code to*/ <br>/*                  allocate and free memory.                           */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void __RPC_FAR * __RPC_API midl_user_allocate(size_t nLen) <br>{ <br>    return (malloc(nLen)); <br>} <br> <br>void __RPC_API midl_user_free(void __RPC_FAR * lpvPointer) <br>{ <br>    if(NULL == lpvPointer) <br>    { <br>        free (lpvPointer); <br>    } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
