<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PIPEPROC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5012"></a>PIPEPROC.C</h2>
<pre><code>/************************************************************************* <br>                    Copyright Microsoft Corp. 1992-1996 <br>                        Remote Machine pipe sample <br> <br>  FILE      :   pipeproc.c <br> <br>  PURPOSE   :Remote procedures used in the RPC distributed application  <br>                pipe sample <br> <br>  COMMENTS  :   This file is linked together with the server side of the  <br>                application. <br> <br>*************************************************************************/ <br>#include "pipe.h"       // Generated by the MIDL compiler <br>#include "common.h"     // Common definitions is locataed in  this file <br> <br>#define MAX_BUFFER_SIZE 1000       // Buffer used on the server side <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* Procedure    :   void ScrambleFile(unsigned long, CHAR_PIPE_TYPE *)  */ <br>/* Desc.        :   This procedure receives a file from the client, and */ <br>/*                  then "encodes" the file by adding 1 to every        */ <br>/*                  character, and then sends the file back to the      */ <br>/*                  client. The file is sent back and forth using pipes */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void ScrambleFile(unsigned long nAction, CHAR_PIPE_TYPE *in_out_pipe) <br>{ <br>    FILE    *fpTemp;                    // Pointer to the temporary file <br>    _TUCHAR pcBuffer[MAX_BUFFER_SIZE];  // Buffer to store the elements in <br> <br>    unsigned long    <br>        nActualTransferCount,   // Actual number of elements received  <br>        nIdx,                   // Counter in loop  <br>        nElementsToSend;        // Number of elements to send to the client <br>    BOOL bDone = FALSE;         // Inidicates when the pipe is done <br>     <br> <br>    // Open up a file to temporary store the pulled data in <br>    fpTemp = _tfopen(TEXT("tempfile.oak"), TEXT("w+")); <br> <br>    _tprintf(TEXT("Retrieving data from the client...\n")); <br>    // First process the entire pull. Input pipes must be transmitted first <br>    while(FALSE == bDone) <br>    { <br>        in_out_pipe-&gt;pull(      // Grab a chunck of data from the client <br>            in_out_pipe-&gt;state, // Pointer to the state  <br>            pcBuffer,           // Buffer to put data in <br>            MAX_BUFFER_SIZE,    // Max number of elements to receive <br>            &amp;nActualTransferCount); // Actual number of elements received <br> <br>        // A data transfer count of 0 means the end of the pipe <br>        if(nActualTransferCount == 0) <br>        { <br>            bDone = TRUE; <br>        } <br>        else        // Save the data to an intermediate file <br>        { <br>            fwrite(pcBuffer, sizeof(_TUCHAR), nActualTransferCount, fpTemp); <br>        } <br>    } <br> <br>    // Reset the flag <br>    bDone = FALSE; <br> <br>    // Reset the filehandle to point at start of file <br>    fseek(fpTemp, 0, SEEK_SET); <br> <br>    _tprintf(TEXT("Sending the data back to the client...\n")); <br>    // Now we can send the data back  <br>    while(FALSE == bDone) <br>    { <br>        // Read a number of bytes from the file, into the buffer <br>        nElementsToSend = fread(pcBuffer,  <br>                                 sizeof(_TUCHAR),  <br>                                 MAX_BUFFER_SIZE,  <br>                                 fpTemp); <br> <br>        // If no more elements to send, we are done. Must send 0 to the  <br>        // client to notify that the pipe is empty <br>        if(nElementsToSend == 0) <br>        { <br>            bDone = TRUE; <br>        } <br> <br>        // According to the action, scramble or descramble the data  <br>        for (nIdx = 0; nIdx &lt; nElementsToSend; nIdx++) <br>        { <br>            if(nAction == SCRAMBLE) <br>            { <br>                pcBuffer[nIdx]++; <br>            } <br>            else <br>            { <br>                pcBuffer[nIdx]--; <br>            } <br>        } <br> <br>        // Send the buffer to the client <br>        in_out_pipe-&gt;push(      // Send a chunck of data to the client <br>            in_out_pipe-&gt;state, // Pointer to the state <br>            pcBuffer,             // Date to send is in this buffer <br>            nElementsToSend);  // The number of elements to send <br>    }// End while (!done) <br> <br>    // Close the file  <br>    fclose(fpTemp); <br>} <br> <br> <br> <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>/* Procedure    :   void ShutDown(void);                                */ <br>/* Desc.        :   This procedure send a message to the server that it */ <br>/*                  canstop listening for remote procedure calls       */ <br>/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ <br>void ShutDown(void) <br>{ <br>    RPC_STATUS nStatus; <br> <br>    // Tell the server to stop listening for remote procedure calls  <br>    _tprintf(TEXT("Shutting down the server\n")); <br>    nStatus = RpcMgmtStopServerListening(NULL); <br>    EXIT_IF_FAIL(nStatus, "RpcMgmtStopServerListening"); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
