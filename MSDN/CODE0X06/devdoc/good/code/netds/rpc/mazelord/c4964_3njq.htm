<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BITMAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4976"></a>BITMAP.C</h2>
<pre><code>/*********************************************************************** <br>File:   BitMap.c <br>Date:   5-23-92 <br> <br> <br>Abstract: <br> <br>    This file contains functions pertaining to drawing a bitmap on the screen. <br> <br>Contents: <br> <br>    FadePic() -- Slowly fade a picture on the screen to the background <br>    DrawClippedPic() -- Draw a picture, clipped to a specified rectangle <br>    NewFullPic() -- Create a record of type FullPicType <br>    DeleteFullPic() -- Delete a record of type FullPicType <br>    AddPic() -- Load a new picture bitmap set <br>    DelPic() -- Remove a picture bitmap set from memory. <br> <br> <br>Revision History: <br> <br> <br>************************************************************************/ <br>#include "winmaze.h" <br>#include "mazproto.h" <br> <br>#define MASKROP(fore,back) (DWORD)(((back &lt;&lt; 8)&amp;0xFF000000) | fore) <br>#define MASKROP2(black,white) (DWORD)(((black &lt;&lt; 8)&amp;0xFF000000) | white) &amp; 0xFFFF0000 <br> <br> <br> <br> <br>// <br>// PicSpec goes: <br>//      Base BM filename, iPicNum for the picture, offsets for each facing: <br>//              {width, depth, left offset, top offset} <br>// <br>PicSpecType PicSpec[] = { <br>   {"FISH", PIC_FISH, <br>        { <br>            {35,41,30,42}, <br>            {62,35,15,49}, <br>            {21,31,36,51}, <br>            {62,31,21,53} <br>        }}, <br>   {"ROBO", PIC_ROBOT, <br>        { <br>            {40,107,19,43}, <br>            {50,107,13,43}, <br>            {43,106,23,44}, <br>            {48,107,30,43} <br>        }}, <br>   {"SMIL", PIC_SMILEY, <br>        { <br>            {62,62,17,40}, <br>            {68,62,17,40}, <br>            {62,62,17,40}, <br>            {70,62,9,40} <br>        }}, <br>   {"REAP", PIC_REAPER, <br>        { <br>            {90,114,5,26}, <br>            {85,114,8,26}, <br>            {90,114,5,26}, <br>            {85,114,8,26} <br>        }} <br>   }; <br> <br>int iNumPicSpecs = sizeof(PicSpec) / sizeof(PicSpecType); <br> <br> <br> <br> <br> <br>/*===================================================================== <br>Function: FadePic() <br> <br>Inputs: Picture #, facing, and clipping rectangle to fade. <br> <br>Outputs:none <br> <br>Abstract: <br>    Fade will fade out a given bitmap by XORing its bitmap with a 50% grey tone. <br>======================================================================*/ <br> <br>void FadePic( <br>    int iPicNum, <br>    BYTE bFacing, <br>    HDC hDC, <br>    LPRECT lprFrom, <br>    LPRECT lprDRect <br>    ) <br>{ <br>    FullPicType FAR *fptTrav; <br>    BOOL bFound; <br>    HDC hFadeDC,hMaskDC,hbmFadeDC; <br>    HBITMAP hbmFade; <br>    int DestWidth,DestHeight,SrcWidth,SrcHeight; <br>    int iRelDirIndex,i,j; <br> <br> <br>    fptTrav = &amp;fptPic; <br>    bFound = FALSE; <br> <br>    iRelDirIndex=2; <br>    while(bFacing != ptSelf.Pos.Facing) { <br>        iRelDirIndex = (iRelDirIndex+1)%4; <br>        bFacing = LEFT_TO_ABS(bFacing); <br>        } <br> <br>    while(fptTrav-&gt;next != NULL) { <br>        fptTrav = fptTrav-&gt;next; <br>        if (fptTrav-&gt;iPicNum == iPicNum) { <br>            bFound = TRUE; <br>            break; <br>            } <br>        } <br> <br>    if (bFound) { <br>        hMaskDC = CreateCompatibleDC(hDC); <br>        hFadeDC = CreateCompatibleDC(hDC); <br>        hbmFadeDC = CreateCompatibleDC(hFadeDC); <br>        SrcWidth = lprFrom-&gt;right-lprFrom-&gt;left+1; <br>        SrcHeight = lprFrom-&gt;bottom-lprFrom-&gt;top+1; <br>        DestWidth = lprDRect-&gt;right-lprDRect-&gt;left+1; <br>        DestHeight = lprDRect-&gt;bottom-lprDRect-&gt;top+1; <br>        hbmFade = CreateCompatibleBitmap(hFadeDC,DestWidth,DestHeight); <br>        SelectObject(hbmFadeDC,hbmFade); <br>        SelectObject(hFadeDC,hFadeBM[0]); <br>        SelectObject(hMaskDC,fptTrav-&gt;M[iRelDirIndex].hBitmap); <br> <br>        // <br>        // Copy the Fade pattern into the Fade Bitmap <br>        // <br>        for(i=0;i&lt;DestWidth;i+=PIC_X) { <br>            for(j=0;j&lt;DestHeight;j+=PIC_Y) { <br>                BitBlt(hbmFadeDC,i,j, <br>                       ((i+PIC_X)&lt;=DestWidth) ? PIC_X : DestWidth, <br>                       ((j+PIC_Y)&lt;=DestHeight) ? PIC_Y : DestHeight, <br>                       hFadeDC,0,0, <br>                       SRCCOPY); <br>                } <br>            } <br> <br>        // <br>        // StretchBlt the mask onto the fade <br>        // <br>        StretchBlt(hbmFadeDC,0,0,DestWidth,DestHeight, <br>                   hMaskDC,0,0,SrcWidth,SrcHeight, <br>                   NOTSRCERASE); <br> <br>        // <br>        // BitBlt the result onto the screen. <br>        // <br>        BitBlt(hDC,lprDRect-&gt;left,lprDRect-&gt;top,DestWidth,DestHeight, <br>               hbmFadeDC,0,0, <br>               SRCPAINT); <br> <br>        DeleteDC(hFadeDC); <br>        DeleteDC(hMaskDC); <br>        DeleteDC(hbmFadeDC); <br>        DeleteObject(hbmFade); <br>        DeleteObject(hFadeBM[0]); <br>        hFadeBM[0] = LoadBitmap(hInst,(LPCTSTR)((0)?"FADE2":"FADE1")); <br> <br>        } <br> <br>    return; <br> <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: DrawClippedPic() <br> <br>Inputs: Picture #, Relative facing, clip/dest rectangles, <br> <br>Outputs:none <br> <br>Abstract: <br>    DrawClippedPic will draw the portions of picture # iPicNum visible through <br>    the clipping window.  Player bitmaps smaller than a full panel in size <br>    Will need to be scaled. <br>======================================================================*/ <br> <br>void DrawClippedPic( <br>    int iPicNum, <br>    BYTE bFacingIndex, <br>    HDC hDC, <br>    LPRECT lprDRect, <br>    LPRECT lprClip, <br>    LPRECT lprFrom, <br>    int iRelx, <br>    int iRely <br>    ) <br> <br>{ <br>    RECT rSrc; <br>    FullPicType FAR *fptTrav; <br>    BOOL bFound; <br>    HDC hPicDC,hMaskDC; <br>    int DestWidth,DestHeight; <br>    POINT pBlt[3]; <br>    // <br>    // the floats are offset ratio's, ie percentage of the total <br>    // width/depth to add to each side of the source rect. <br>    // <br>    float sWidth,sDepth,dWidth,dDepth; <br>    float fRelScaling; <br> <br>    if (lprClip-&gt;right &lt; lprClip-&gt;left+2) { <br>        return; <br>        } <br> <br>    fptTrav = &amp;fptPic; <br>    bFound = FALSE; <br> <br>    // <br>    // Check to see if the Picture we're supposed to draw has been loaded. <br>    // <br>    AddPic(iPicNum); <br> <br>    while(fptTrav-&gt;next != NULL) { <br>        fptTrav = fptTrav-&gt;next; <br>        if (fptTrav-&gt;iPicNum == iPicNum) { <br>            bFound = TRUE; <br>            break; <br>            } <br>        } <br> <br>    if (bFound) { <br> <br>        // <br>        // bFound will now indicates whether the picture has been pre-stretched <br>        // <br> <br>        bFound = (PreStretch[iPicNum][iRely].P[bFacingIndex].hBitmap != (HANDLE) NULL); <br>        bFound = bFound &amp;&amp; (PreStretch[iPicNum][iRely].M[bFacingIndex].hBitmap != (HANDLE) NULL); <br> <br>        // <br>        // We'll need the source dimensions whether it's prestretched or not. <br>        // <br>        if (bFound) { <br>            sWidth = (float) PreStretch[iPicNum][iRely].P[bFacingIndex].xSize; <br>            sDepth = (float) PreStretch[iPicNum][iRely].P[bFacingIndex].ySize; <br>            } <br>        else { <br>            sWidth = (float) fptTrav-&gt;P[bFacingIndex].xSize; <br>            sDepth = (float) fptTrav-&gt;P[bFacingIndex].ySize; <br>            } <br> <br>        // <br>        // Assume that we want the ENTIRE source bitmap. <br>        // <br>        rSrc.left = 0; <br>        rSrc.top = 0; <br>        rSrc.right = (INT) sWidth-1; <br>        rSrc.bottom = (INT) sDepth-1; <br> <br>        // <br>        // fRelScaling*an offset gives # of pixels of REAL offset. <br>        // <br>        fRelScaling = ((float) (lprDRect-&gt;bottom - lprDRect-&gt;top))/(float)PIC_Y; <br> <br>        if (bFound) { <br>            lprDRect-&gt;left += PreStretch[iPicNum][iRely].P[bFacingIndex].xOrg; <br>            lprDRect-&gt;top += PreStretch[iPicNum][iRely].P[bFacingIndex].yOrg; <br>            lprDRect-&gt;right = lprDRect-&gt;left + (int) sWidth; <br>            lprDRect-&gt;bottom = lprDRect-&gt;top + (int) sDepth; <br>            } <br>        else { <br>            lprDRect-&gt;left += (int) (fRelScaling*fptTrav-&gt;P[bFacingIndex].xOrg); <br>            lprDRect-&gt;top += (int) (fRelScaling*fptTrav-&gt;P[bFacingIndex].yOrg); <br>            lprDRect-&gt;right = lprDRect-&gt;left + (int) (fRelScaling*sWidth); <br>            lprDRect-&gt;bottom = lprDRect-&gt;top + (int) (fRelScaling*sDepth); <br>            } <br> <br>        dWidth = (float) lprDRect-&gt;right - lprDRect-&gt;left; <br>        dDepth = (float) lprDRect-&gt;bottom - lprDRect-&gt;top; <br> <br>        // <br>        // Rather than doing a clipped bitblt, we just modify the source <br>        // rectangle to be the parts which are visible. <br>        // <br>        if (lprDRect-&gt;left &lt; lprClip-&gt;left) { <br>            rSrc.left += (LONG) (sWidth*((float) (lprClip-&gt;left - lprDRect-&gt;left))/dWidth); <br>            lprDRect-&gt;left = lprClip-&gt;left; <br>            } <br>        if (lprDRect-&gt;top &lt; lprClip-&gt;top) { <br>            rSrc.top += (LONG) (sDepth*((float) lprClip-&gt;top - lprDRect-&gt;top)/dDepth); <br>            lprDRect-&gt;top = lprClip-&gt;top; <br>            } <br>        if (lprDRect-&gt;right &gt; lprClip-&gt;right) { <br>            rSrc.right += (LONG) (sWidth*((float) lprClip-&gt;right - lprDRect-&gt;right)/dWidth); <br>            lprDRect-&gt;right = lprClip-&gt;right; <br>            } <br>        if (lprDRect-&gt;bottom &gt; lprClip-&gt;bottom) { <br>            rSrc.bottom += (LONG) (sDepth*((float) lprClip-&gt;bottom - lprDRect-&gt;bottom)/dDepth); <br>            lprDRect-&gt;bottom = lprClip-&gt;bottom; <br>            } <br>        // <br>        // Set the Dest variables to the TRUE physical dest width/depth <br>        // <br>        DestWidth = lprDRect-&gt;right - lprDRect-&gt;left; <br>        DestHeight = lprDRect-&gt;bottom - lprDRect-&gt;top+1; <br> <br>        if ((DestWidth &lt; 1)||(DestHeight &lt; 1)) { <br>            return; <br>            } <br> <br>        hPicDC = CreateCompatibleDC(hDC); <br>        hMaskDC = CreateCompatibleDC(hPicDC); <br> <br>        if (bFound) { <br>            // <br>            // If the bitmaps are pre-stretched... <br>            // <br> <br>            SelectObject(hPicDC,PreStretch[iPicNum][iRely].P[bFacingIndex].hBitmap); <br>            SelectObject(hMaskDC,PreStretch[iPicNum][iRely].M[bFacingIndex].hBitmap); <br> <br>            BitBlt(hDC,lprDRect-&gt;left,lprDRect-&gt;top,DestWidth,DestHeight, <br>                   hMaskDC,rSrc.left,rSrc.top, <br>                   SRCAND); <br>            BitBlt(hDC,lprDRect-&gt;left,lprDRect-&gt;top,DestWidth,DestHeight, <br>                   hPicDC,rSrc.left,rSrc.top, <br>                   SRCPAINT); <br>            } <br>        else { <br>            // <br>            // If the bitmaps are NOT pre-stretched. <br>            // <br>            SelectObject(hPicDC,fptTrav-&gt;P[bFacingIndex].hBitmap); <br>            SelectObject(hMaskDC,fptTrav-&gt;M[bFacingIndex].hBitmap); <br>            // <br>            // stretch the mask onto the screen <br>            // <br>            pBlt[0].x = lprDRect-&gt;left; <br>            pBlt[0].y = lprDRect-&gt;top; <br>            pBlt[1].x = lprDRect-&gt;right; <br>            pBlt[1].y = lprDRect-&gt;top; <br>            pBlt[2].x = lprDRect-&gt;left; <br>            pBlt[2].y = lprDRect-&gt;bottom; <br> <br>            StretchBlt(hDC,lprDRect-&gt;left,lprDRect-&gt;top,DestWidth,DestHeight, <br>                       hMaskDC,rSrc.left,rSrc.top,rSrc.right-rSrc.left+1,rSrc.bottom-rSrc.top+1, <br>                       SRCAND); <br>            // <br>            // then the picture as well <br>            // <br>            StretchBlt(hDC,lprDRect-&gt;left,lprDRect-&gt;top,DestWidth,DestHeight, <br>                       hPicDC,rSrc.left,rSrc.top,rSrc.right-rSrc.left+1,rSrc.bottom-rSrc.top+1, <br>                       SRCPAINT); <br>            } <br> <br>        DeleteDC(hPicDC); <br>        DeleteDC(hMaskDC); <br>        } <br>    else { <br>        MessageBox(NULL,"Unknown Picture Draw Requested","DrawClippedPic", <br>                   MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        } <br> <br>    *lprFrom = rSrc; <br> <br>    return; <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: NewFullPic() <br> <br>Inputs: Picture # to load, pointer to next <br> <br>Outputs:Returns a pointer to an initialized FullPicType data structure <br> <br>Abstract: <br>======================================================================*/ <br> <br>FullPicType FAR *NewFullPic( <br>    int iPicNum, <br>    FullPicType FAR *next <br>    ) <br>{ <br>    FullPicType FAR *fptTemp; <br>    int i; <br>    HANDLE hMem; <br> <br>    hMem = GlobalAlloc(GHND,sizeof(FullPicType)); <br>    fptTemp = (FullPicType FAR *) GlobalLock(hMem); <br>    if (fptTemp == NULL) { <br>        MessageBox((HANDLE)NULL,"Out of memory: unable to create NewFullPic.","NewFullPic", <br>               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        } <br>    else { <br>        for(i=0;i&lt;4;i++) { <br>            fptTemp-&gt;P[i].hBitmap = (HANDLE) NULL; <br>            fptTemp-&gt;P[i].xSize = PicSpec[iPicNum].PicPos[i].xSize; <br>            fptTemp-&gt;P[i].ySize = PicSpec[iPicNum].PicPos[i].ySize; <br>            fptTemp-&gt;P[i].xOrg = PicSpec[iPicNum].PicPos[i].xOrg; <br>            fptTemp-&gt;P[i].yOrg = PicSpec[iPicNum].PicPos[i].yOrg; <br>            fptTemp-&gt;M[i].hBitmap = (HANDLE) NULL; <br>            fptTemp-&gt;M[i].xSize = PicSpec[iPicNum].PicPos[i].xSize; <br>            fptTemp-&gt;M[i].ySize = PicSpec[iPicNum].PicPos[i].ySize; <br>            fptTemp-&gt;M[i].xOrg = PicSpec[iPicNum].PicPos[i].xOrg; <br>            fptTemp-&gt;M[i].yOrg = PicSpec[iPicNum].PicPos[i].yOrg; <br>            } <br>        fptTemp-&gt;iPicNum = iPicNum; <br>        fptTemp-&gt;next = next; <br>        } <br> <br>    return(fptTemp); <br> <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: DeleteFullPic() <br> <br>Inputs: pointer to FullPicType to free <br> <br>Outputs:Returns pointer to -&gt;next element of deleted pic. <br> <br>Abstract: <br>======================================================================*/ <br> <br>FullPicType FAR *DeleteFullPic( <br>    FullPicType FAR *fptTrav <br>    ) <br>{ <br>    int i; <br>    FullPicType FAR *fptTemp; <br>    HANDLE hMem; <br> <br>    if (fptTrav == NULL) { <br>        fptTemp = fptTrav; <br>        } <br>    else { <br>        fptTemp = fptTrav-&gt;next; <br> <br>        for (i=0;i&lt;4;i++) { <br>            if (fptTrav-&gt;P[i].hBitmap != (HANDLE) NULL) { <br>                DeleteObject(fptTrav-&gt;P[i].hBitmap); <br>                } <br>            if (fptTrav-&gt;M[i].hBitmap != (HANDLE) NULL) { <br>                DeleteObject(fptTrav-&gt;M[i].hBitmap); <br>                } <br>            } <br> <br>        hMem = (HGLOBAL) GlobalHandle(SELECTOROF(fptTrav)); <br>        GlobalUnlock(hMem); <br>        GlobalFree(hMem); <br>        } <br> <br>    return(fptTemp); <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: AddPic() <br> <br>Inputs: Picture # to load <br> <br>Outputs:Returns success/failure. <br> <br>Abstract: <br>    AddPic will take care of loading in a given picture's bitmap, if it isn't <br>    already in the fptPic list. If the specified type of picture can't be found, <br>    FALSE is returned.  Note that when we load a picture, we also make sure <br>    that it is restricted to the confines of its mask by turning everything <br>    outside the mask BLACK. This is necessary for drawing as well. <br>======================================================================*/ <br> <br>BOOL AddPic( <br>    int iPicNum <br>    ) <br>{ <br>    char cDirs[4] = {'F','L','B','R'}; <br>    FullPicType FAR *fptTrav; <br>    BOOL bFound; <br>    int i,j; <br>    char cBitmapName[32]; <br>    HDC hDC,hPicDC,hMaskDC; <br> <br>    fptTrav = &amp;fptPic; <br>    bFound = FALSE; <br> <br>    // <br>    // Look to see if the picture's already been loaded into memory. If <br>    // it has, we won't have to load it. <br>    // <br>    while (fptTrav-&gt;next != NULL) { <br>        fptTrav = fptTrav-&gt;next; <br> <br>        if (fptTrav-&gt;iPicNum == iPicNum) { <br>            bFound = TRUE; <br>            break; <br>            } <br>        } <br> <br>    // <br>    // If we didn't find the bitmap, we really DO need to load it. <br>    // <br>    if (!bFound) { <br> <br>        // <br>        // We can only load the requested picture if it's in our list of <br>        // known pics. Check to make sure it is. <br>        // <br>        for(i=0;i&lt;iNumPicSpecs;i++) { <br>            if (PicSpec[i].iPicNum == iPicNum) { <br>                bFound = TRUE; <br>                break; <br>                } <br>            } <br> <br>        if (bFound) { <br>            hDC = GetDC(hWndMaze); <br>            hPicDC = CreateCompatibleDC(hDC); <br>            hMaskDC = CreateCompatibleDC(hPicDC); <br>            ReleaseDC(hWndMaze,hDC); <br> <br>            fptTrav-&gt;next = NewFullPic(iPicNum,fptTrav-&gt;next); <br>            fptTrav = fptTrav-&gt;next; <br>            strcpy(cBitmapName,PicSpec[i].cBase); <br>            cBitmapName[5]='\0'; <br> <br>            // <br>            // Load in the bitmaps <br>            // <br>            for(j=0;j&lt;4;j++) { <br>                cBitmapName[4]=cDirs[j]; <br>                if (fptTrav-&gt;P[j].hBitmap != NULL) { <br>                    DeleteObject(fptTrav-&gt;P[j].hBitmap); <br>                } <br>                fptTrav-&gt;P[j].hBitmap = LoadBitmap(hInst,(LPCTSTR)cBitmapName); <br>                if (fptTrav-&gt;P[j].hBitmap == (HANDLE) NULL) { <br>                    MessageBox((HANDLE) NULL,"Unable to load bitmap","AddPic", <br>                               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                    bFound = FALSE; <br>                    } <br>                // <br>                // Copy stats for the Bitmap's size/origin into the struct <br>                // <br>                fptTrav-&gt;P[j].xSize = PicSpec[i].PicPos[j].xSize; <br>                fptTrav-&gt;P[j].ySize = PicSpec[i].PicPos[j].ySize; <br>                fptTrav-&gt;P[j].xOrg = PicSpec[i].PicPos[j].xOrg; <br>                fptTrav-&gt;P[j].yOrg = PicSpec[i].PicPos[j].yOrg; <br>                } <br> <br>            cBitmapName[5]='M'; <br>            cBitmapName[6]='\0'; <br> <br>            // <br>            // Load in the masks for the bitmaps <br>            // <br>            for(j=0;j&lt;4;j++) { <br>                cBitmapName[4]=cDirs[j]; <br>                if (fptTrav-&gt;M[j].hBitmap != NULL) { <br>                    DeleteObject(fptTrav-&gt;M[j].hBitmap); <br>                } <br>                fptTrav-&gt;M[j].hBitmap = LoadBitmap(hInst,(LPCTSTR)cBitmapName); <br>                if (fptTrav-&gt;M[j].hBitmap == (HANDLE) NULL) { <br>                    MessageBox((HANDLE) NULL,"Unable to load bitmap mask","AddPic", <br>                                MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                    bFound = FALSE; <br>                    } <br>                // <br>                // Copy stats for the Mask's size/origin into the struct <br>                // <br>                fptTrav-&gt;M[j].xSize = PicSpec[i].PicPos[j].xSize; <br>                fptTrav-&gt;M[j].ySize = PicSpec[i].PicPos[j].ySize; <br>                fptTrav-&gt;M[j].xOrg = PicSpec[i].PicPos[j].xOrg; <br>                fptTrav-&gt;M[j].yOrg = PicSpec[i].PicPos[j].yOrg; <br>                } <br>/***********BUGBUG <br>            // <br>            // Invert the background of the bitmaps from white to black <br>            // <br>            for(j=0;j&lt;4;j++) { <br>                SelectObject(hPicDC,fptTrav-&gt;P[j].hBitmap); <br>                SelectObject(hMaskDC,fptTrav-&gt;M[j].hBitmap); <br>                BitBlt(hPicDC,0,0, <br>                                 PicSpec[iPicNum].PicPos[i].xSize, <br>                                 PicSpec[iPicNum].PicPos[i].ySize, <br>                       hMaskDC,0,0,SRCINVERT); <br>                } <br>*************/ <br> <br>            DeleteDC(hPicDC); <br>            DeleteDC(hMaskDC); <br>            } <br>        } <br> <br>    return(bFound); <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: DelPic() <br> <br>Inputs: Picture # to Delete from pic list <br> <br>Outputs:Returns success/failure. <br> <br>Abstract: <br>    DelPic will remove a picture, assuming that it is not being used by anyone <br>    in ptDrones and ptPlayers, and it isn't of type PIC_DEFAULT. <br>======================================================================*/ <br> <br>BOOL DelPic( <br>    int iPicNum <br>    ) <br>{ <br>    FullPicType FAR *fptTrav; <br>    BOOL bFound,bStillUsed; <br>    PlayerType FAR *ptTrav; <br> <br> <br>    if (iPicNum == PIC_DEFAULT) { <br>        return(TRUE); <br>        } <br> <br>    fptTrav = &amp;fptPic; <br>    bFound = FALSE; <br> <br>    while (fptTrav-&gt;next != NULL) { <br>        if (fptTrav-&gt;next-&gt;iPicNum == iPicNum) { <br>            bFound = TRUE; <br>            bStillUsed = FALSE; <br> <br>            ptTrav = &amp;ptPlayers; <br>            while (ptTrav-&gt;next != NULL) { <br>            ptTrav = ptTrav-&gt;next; <br>            if (ptTrav-&gt;iPicNum == iPicNum) { <br>                bStillUsed = TRUE; <br>                break; <br>                } <br>            } <br> <br>            ptTrav = &amp;ptDrones; <br>            while (ptTrav-&gt;next != NULL) { <br>            ptTrav = ptTrav-&gt;next; <br>            if (ptTrav-&gt;iPicNum == iPicNum) { <br>                bStillUsed = TRUE; <br>                break; <br>                } <br>            } <br> <br>            if (!bStillUsed) { <br>                fptTrav-&gt;next = DeleteFullPic(fptTrav-&gt;next); <br>                } <br> <br>            break; <br>            } <br> <br>        fptTrav = fptTrav-&gt;next; <br>        } <br> <br>    return(bFound); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
