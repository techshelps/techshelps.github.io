<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAZEWND.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4972"></a>MAZEWND.C</h2>
<pre><code>/*********************************************************************** <br>File:   MazeWnd.c <br> <br> <br>Abstract: <br> <br>    This module contains the windows procedure responsible for drawing the 3-d <br>    maze. <br> <br> <br>Contents: <br> <br>    StretchBitmaps() --Prestretches loaded pictures to bitmap size. <br>    KillSelf() -- Takes care of hassles associated with dying <br>    MazeWndProc() -- Main entrypoint for drawing 3-d maze <br> <br>************************************************************************/ <br> <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include "net.h" <br>#include &lt;mmsystem.h&gt; <br> <br> <br>/*===================================================================== <br>Function:   StretchBitmaps() <br> <br>Inputs:     none <br> <br>Outputs:    none <br> <br>Abstract: <br>    StretchBitmaps() will take care of stretching the appropriate bitmaps <br>    to their correct dimensions. <br>======================================================================*/ <br> <br>void StretchBitmaps( <br>    void <br>    ) <br>{ <br>    float xSize,ySize,xOrg,yOrg,x,y,z; <br>    int iPicNum,iRely,iFacing; <br>    HDC hDC,hSrcDC,hDestDC,hMemDC; <br>    FullPicType FAR *fptTrav; <br>    HBITMAP hBM; <br>    HCURSOR hCursor; <br> <br>    // <br>    // Set the cursor to an hourglass since this takes time... <br>    // <br>    hCursor = SetCursor(LoadCursor((HINSTANCE)NULL,IDC_WAIT)); <br> <br>    hDC = GetDC(hWndMaze); <br>    hSrcDC = CreateCompatibleDC(hDC); <br>    hDestDC = CreateCompatibleDC(hDC); <br>    hMemDC = CreateCompatibleDC(hDestDC); <br> <br>    GetClientRect(hWndMaze,(LPRECT) &amp;rMaze); <br> <br>    // <br>    // Set x and y to logical panel origin. <br>    // <br>    y = (float) (-PANEL_HEIGHT/2); <br>    x = (float) (-PANEL_WIDTH/2); <br> <br>    // <br>    // Loop through all of the pictures we know about. <br>    // <br>    for(iPicNum=0;iPicNum &lt; NUM_PICS;iPicNum++) { <br> <br>        AddPic(iPicNum); <br> <br>        // <br>        // Find the fptPic entry for Picture # iPicNum <br>        // <br>        fptTrav = &amp;fptPic; <br>        while (fptTrav-&gt;next != NULL) { <br>            fptTrav = fptTrav-&gt;next; <br>            if (fptTrav-&gt;iPicNum == iPicNum) { <br>                break; <br>                } <br>            } <br>        // <br>        // Loop from closest to us to furthest away from us for stretching <br>        // <br>        for (iRely = 0;iRely &lt; MAX_DRAW_DIST;iRely++) { <br>            PreStretch[iPicNum][iRely].next = NULL; <br>            PreStretch[iPicNum][iRely].iPicNum = iPicNum; <br> <br>            // <br>            // We need to stretch once per facing <br>            // <br>            for (iFacing=0;iFacing&lt;4;iFacing++) { <br> <br>#if ( _ALPHA_ == 1 )  <br>                z = (float) (iRely ? iRely*PANEL_WIDTH:PANEL_WIDTH/4); <br>#else <br>                z = (float) (iRely-1)*PANEL_WIDTH; //- PANEL_WIDTH/2; <br>#endif <br> <br>                xSize = MC_TO_SC(fptTrav-&gt;P[iFacing].xSize,z); <br>                ySize = MC_TO_SC(fptTrav-&gt;P[iFacing].ySize,z); <br>                xOrg = MC_TO_SC(fptTrav-&gt;P[iFacing].xOrg,z); <br>                yOrg = MC_TO_SC(fptTrav-&gt;P[iFacing].yOrg,z); <br> <br>                PreStretch[iPicNum][iRely].P[iFacing].xSize = (int) xSize; <br>                PreStretch[iPicNum][iRely].P[iFacing].ySize = (int) ySize; <br>                PreStretch[iPicNum][iRely].P[iFacing].xOrg = (int) xOrg; <br>                PreStretch[iPicNum][iRely].P[iFacing].yOrg = (int) yOrg; <br>                PreStretch[iPicNum][iRely].M[iFacing].xSize = (int) xSize; <br>                PreStretch[iPicNum][iRely].M[iFacing].ySize = (int) ySize; <br>                PreStretch[iPicNum][iRely].M[iFacing].xOrg = (int) xOrg; <br>                PreStretch[iPicNum][iRely].M[iFacing].yOrg = (int) yOrg; <br> <br>                // <br>                // If we're supposed to prestretch this bitmap, do so <br>                // <br>                if (((iPicNum == PIC_DRONE)&amp;&amp;bDronePrestretch)|| <br>                     (bPlayerPrestretch) <br>                   ) { <br>                    // <br>                    // If there were already stretched bitmaps, delete them. <br>                    // <br>                    if (PreStretch[iPicNum][iRely].P[iFacing].hBitmap != <br>                        (HBITMAP)NULL) { <br>                        DeleteObject(PreStretch[iPicNum][iRely].P[iFacing].hBitmap); <br>                        } <br>                    if (PreStretch[iPicNum][iRely].M[iFacing].hBitmap != <br>                        (HBITMAP)NULL) { <br>                        DeleteObject(PreStretch[iPicNum][iRely].M[iFacing].hBitmap); <br>                        } <br> <br>                    // <br>                    // Stretch the bitmap <br>                    // <br>                    hBM = CreateCompatibleBitmap(hDC,(int)xSize,(int)ySize); <br> <br>                    SelectObject(hSrcDC,fptTrav-&gt;P[iFacing].hBitmap); <br>                    SelectObject(hDestDC,hBM); <br>                    StretchBlt(hDestDC,0,0,(int)xSize,(int)ySize, <br>                               hSrcDC,0,0, <br>                               fptTrav-&gt;P[iFacing].xSize, <br>                               fptTrav-&gt;P[iFacing].ySize, <br>                               SRCCOPY); <br>                    PreStretch[iPicNum][iRely].P[iFacing].hBitmap = hBM; <br> <br>                    // <br>                    // Now stretch the mask <br>                    // <br>                    hBM = CreateCompatibleBitmap(hMemDC,(int)xSize,(int)ySize); <br> <br>                    SelectObject(hSrcDC,fptTrav-&gt;M[iFacing].hBitmap); <br>                    SelectObject(hMemDC,hBM); <br>                    StretchBlt(hMemDC,0,0,(int)xSize,(int)ySize, <br>                               hSrcDC,0,0, <br>                               fptTrav-&gt;M[iFacing].xSize, <br>                               fptTrav-&gt;M[iFacing].ySize, <br>                               SRCCOPY); <br>                    PreStretch[iPicNum][iRely].M[iFacing].hBitmap = hBM; <br> <br>                    } <br>                else { <br>                    // <br>                    // If we're not stretching bitmaps, we should delete <br>                    // any we don't need anymore to free memory. <br>                    // <br>                    if (PreStretch[iPicNum][iRely].P[iFacing].hBitmap != <br>                        (HBITMAP)NULL) { <br>                        DeleteObject(PreStretch[iPicNum][iRely].P[iFacing].hBitmap); <br>                        } <br>                    if (PreStretch[iPicNum][iRely].M[iFacing].hBitmap != <br>                        (HBITMAP)NULL) { <br>                        DeleteObject(PreStretch[iPicNum][iRely].M[iFacing].hBitmap); <br>                        } <br>                    PreStretch[iPicNum][iRely].P[iFacing].hBitmap = (HBITMAP)NULL; <br>                    PreStretch[iPicNum][iRely].M[iFacing].hBitmap = (HBITMAP)NULL; <br>                    } <br>                } <br>            } <br>        } <br> <br>    DeleteDC(hMemDC); <br>    DeleteDC(hSrcDC); <br>    DeleteDC(hDestDC); <br>    ReleaseDC(hWndMaze,hDC); <br> <br>    // <br>    // Return the cursor. <br>    // <br>    SetCursor(hCursor); <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:   KillSelf() <br> <br>Inputs:     none <br> <br>Outputs:    none <br> <br>Abstract: <br>    KillSelf() takes care of playing the teleport sound, teleporting us back to <br>    the sanctuary, and notifying the network that we've died... <br>======================================================================*/ <br> <br>void KillSelf(void) <br>{ <br>    RECT rScratch; <br> <br>    if (!sndPlaySound("tele.wav",SND_ASYNC)) { <br>        MessageBeep((UINT) -1); <br>        MessageBeep((UINT) -1); <br>        MessageBeep((UINT) -1); <br>        } <br>    // <br>    // these are from initmaze.c <br>    // <br> <br>    if (bDemoMode) { <br>        ptSelf.Pos.ix = RandRange(5*X_CELLS_PER_SUBGRID,8*X_CELLS_PER_SUBGRID-1); <br>        ptSelf.Pos.iy = RandRange(7*Y_CELLS_PER_SUBGRID,8*Y_CELLS_PER_SUBGRID-1); <br>        PrintTextLine(GetStringRes(IDS_TELEPORT)); <br>        } <br>    else { <br>        ptSelf.Pos.ix = 6*X_CELLS_PER_SUBGRID+1; <br>        ptSelf.Pos.iy = 7*Y_CELLS_PER_SUBGRID+1; <br>        } <br>    ptSelf.Pos.Facing = NORTH; <br>    ptLastPos = ptSelf.Pos; <br> <br>    bSelfInSanct=TRUE; <br>    PrintTextLine(GetStringRes(IDS_SANCTUARY)); <br> <br>    if (!SendNetMessage(0,0,&amp;ptSelf.Pos,NP_MOVETO)) { <br>        MessageBox((HWND)NULL,GetStringRes(IDS_SNDPCKTFAIL),"MazeWndProc", <br>               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        } <br>    if (bBitmapDraw) { <br>        PostMessage(hWndMaze,WM_COMMAND,IDM_REDRAW,(DWORD)NULL); <br>        } <br>    else { <br>        InvalidateRect(hWndMaze,&amp;rMaze,TRUE); <br>        } <br> <br>    GetClientRect(hWndTopView,&amp;rScratch); <br>    InvalidateRect(hWndTopView,&amp;rScratch,TRUE); <br> <br>    PostMessage(hWndScore,WM_COMMAND,WC_UPDATESCORE,ptSelf.ulID); <br>    PostMessage(hWndScore,WM_COMMAND,WC_UPDATEDIRECTION,0); <br>    iTimesKilled++; <br> <br> <br>    return; <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function:   MazeWndProc() <br> <br>Inputs:     Standard windows procedure inputs <br> <br>Outputs:    returns success/failure <br> <br>Abstract: <br>    MazeWndProc is the process responsible for drawing the maze 3-d view <br>    perspective window. It has the corresponding controls. <br>======================================================================*/ <br> <br>LONG FAR PASCAL MazeWndProc( <br>    HWND hWnd, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    HDC     hDC,hBMDC; <br>    int     nRc=0,i,ix,iy; <br>    BYTE bSquare1,bSquare2,Facing; <br>    PlayerType FAR *ptTrav; <br>    BOOL bKilled,bNewSelfInSanct,bHitSomething; <br>    PositionType ptPos; <br>    char cBuff[132]; <br>    LPRECT rTemp,rPtr; <br>    HGLOBAL hMem; <br> <br> <br>    switch (Message) { <br> <br>        case WM_CREATE: <br>            if (uiTimer != (UINT) NULL) { <br>                KillTimer((HWND)NULL,uiTimer); <br>                } <br> <br>            if ((iNumDrones)&amp;&amp;(iDroneSpeed != 0)) { <br>                if (! (uiTimer = SetTimer((HWND) NULL,0,ONE_SECOND/iDroneSpeed,MoveDrone))) { <br>                    MessageBox(NULL,GetStringRes(IDS_CRETMRFAIL), <br>GetStringRes2(IDS_FATALERR), MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                    PostMessage(hWndMain,WM_CLOSE,0,0); <br>                    } <br>                } <br> <br>            InitDrones(); <br> <br>            if ((bBitmapDraw)&amp;&amp;(((HWND)hMaze3DBM) == ((HWND)NULL))) { <br>                hDC = GetDC(hWnd); <br>                GetClientRect(hWnd,&amp;rMaze); <br>                hMazeDC = CreateCompatibleDC(hDC); <br>                hMaze3DBM = CreateCompatibleBitmap(hDC,rMaze.right-rMaze.left, <br>                                                  rMaze.bottom-rMaze.top); <br>                SelectObject(hMazeDC,hMaze3DBM); <br>                ReleaseDC(hWnd,hDC); <br>                } <br>            else { <br>                hMazeDC = GetDC(hWnd); <br>                } <br> <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(wParam) { <br> <br>                case IDM_DRAWPLAYERS: <br>                    DrawPlayers(hMazeDC,&amp;ptPlayers,NULL); <br>                    break; <br> <br>                case IDM_DRAWDRONES: <br>                    DrawPlayers(hMazeDC,&amp;ptDrones,(LPRECT) lParam); <br>//                    if (lParam != (LPARAM) NULL) { <br>//                        hMem = (HGLOBAL) GlobalHandle(SELECTOROF( (LPRECT) lParam)); <br>//                        GlobalUnlock(hMem); <br>//                        GlobalFree(hMem); <br>//                    } <br>                    break; <br> <br>                case IDM_REDRAW: <br>                    hDC = GetDC(hWnd); <br>                    if (lParam != (LPARAM)NULL) { <br>                        rTemp = (LPRECT)lParam; <br>                        } <br>                    else { <br>                        hMem = GlobalAlloc(GHND,sizeof(RECT)); <br>                        rTemp = (LPRECT) GlobalLock(hMem); <br>                        if (rTemp == NULL) { <br>                            MessageBox((HWND)NULL,GetStringRes(IDS_MALLOCFAIL),"MazeWnd", <br>                                       MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                            PostMessage(hWndMain,WM_CLOSE,0,0); <br>                            } <br>                        GetClientRect(hWnd,rTemp); <br>                        } <br> <br>                    DrawMaze(hMazeDC,rTemp); <br> <br>                    if (bBitmapDraw) { <br>                        BitBlt(hDC,rTemp-&gt;left, rTemp-&gt;top, <br>                               RECTWIDTH(*rTemp), <br>                               RECTDEPTH(*rTemp), <br>                               hMazeDC,rTemp-&gt;left,rTemp-&gt;top,SRCCOPY); <br>                        } <br> <br>                    ReleaseDC(hWnd,hDC); <br>                    hMem = (HGLOBAL) GlobalHandle(SELECTOROF( rTemp)); <br>                    GlobalUnlock(hMem); <br>                    GlobalFree(hMem); <br> <br>                default: <br>                    break; <br>                } <br> <br>            break; <br> <br>        case WM_KEYDOWN: <br>            bSquare1 = bMaze[ptSelf.Pos.ix][ptSelf.Pos.iy]; <br> <br>            if ((! GamePaused)&amp;&amp;(GameStarted)) { <br> <br>                switch(wParam) { <br>                    // <br>                    // Space = Fire straight ahead <br>                    // <br>                    case VK_SPACE: <br>                        if (InSanctuary(&amp;ptSelf.Pos)) { <br>                            // <br>                            //If we shoot while in the Sanctuary, we get chastized. <br>                            // <br>                            sprintf(cBuff,GetStringRes(IDS_NOVIOLENCE)); <br>                            PrintTextLine(cBuff); <br>                            sndPlaySound("sanctu.wav",SND_SYNC); <br>                            } <br>                        else { <br>                            // <br>                            // Otherwise, fine, shoot. <br>                            // <br>                            hDC=GetDC(hWndMaze); <br>                            hBMDC = CreateCompatibleDC(hDC); <br>                            SelectObject(hBMDC,hShotBM[1]); <br>                            BitBlt(hDC,(rMaze.left+rMaze.right)/2 - 12, <br>                                    (rMaze.top+rMaze.bottom)/2 - 12, <br>                                    24,24, <br>                                    hBMDC,0,0,SRCINVERT); <br> <br>                            if (!sndPlaySound("laser.wav",SND_ASYNC)) { <br>                                MessageBeep((UINT)-1); <br>                                } <br> <br>                            // <br>                            // Tell everyone else we're firing */ <br>                            // <br>                            if (!SendNetMessage(0,0,&amp;ptSelf.Pos,NP_SHOTFIRED)) { <br>                                MessageBox((HWND)NULL,GetStringRes(IDS_SNDPCKTFAIL),"WndProc", <br>                                           MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                                } <br> <br>                            bHitSomething = FALSE; <br> <br>                            // <br>                            // Check to see if we hit any drones <br>                            // <br>                            ix = ptSelf.Pos.ix; <br>                            iy = ptSelf.Pos.iy; <br>                            Facing = ptSelf.Pos.Facing; <br> <br>                            bSquare2 = bMaze[ix][iy]; <br> <br>                            // <br>                            // for each square until the next wall, */ <br>                            // <br>                            do { <br>                                ptTrav = &amp;ptDrones; <br>                                        /* Loop through all drones to see if it's there */ <br>                                while (ptTrav-&gt;next != NULL) { <br>                                    ptTrav = ptTrav-&gt;next; <br> <br>                                    if ((ix == ptTrav-&gt;Pos.ix)&amp;&amp;(iy == ptTrav-&gt;Pos.iy)) { <br>                                        if (!sndPlaySound("squish.wav",SND_ASYNC)) { <br>                                            MessageBeep((UINT)-1); <br>                                            } <br> <br>                                        FadePic(ptTrav-&gt;iPicNum, <br>                                                ptTrav-&gt;Pos.Facing, <br>                                                hMazeDC, <br>                                                &amp;ptTrav-&gt;rFrom, <br>                                                &amp;ptTrav-&gt;rDrawn); <br>                                        ptTrav-&gt;Pos.ix = RandRange(5*X_CELLS_PER_SUBGRID,8*X_CELLS_PER_SUBGRID-1); <br>                                        ptTrav-&gt;Pos.iy = RandRange(7*Y_CELLS_PER_SUBGRID,8*Y_CELLS_PER_SUBGRID-1); <br>                                        i = RandRange(1,4); <br>                                        ptTrav-&gt;Pos.Facing = ((i == 1) ? NORTH : <br>                                                      ((i == 2) ? WEST : <br>                                                      ((i == 3) ? SOUTH : <br>                                                      EAST))); <br>                                        if (bBitmapDraw) { <br>                                            hMem = GlobalAlloc(GHND,sizeof(RECT)); <br>                                            rPtr = (LPRECT)GlobalLock(hMem); <br>                                            *rPtr = ptTrav-&gt;rDrawn; <br>                                            PostMessage(hWndMaze,WM_COMMAND,IDM_REDRAW,(DWORD)rPtr); <br>                                            } <br>                                        ptSelf.iScore += iDronesKilled*iDroneSpeed*iDroneSpeed*iNumDrones/20; <br>                                        SendNetMessage(0,0,NULL,NP_SCORE); <br>                                        iDronesKilled++; <br>                                        PostMessage(hWndScore,WM_COMMAND,WC_UPDATESCORE,ptSelf.ulID); <br>                                        bHitSomething = TRUE; <br>                                        sprintf(cBuff,GetStringRes(IDS_FMT_YOUZAPPED),ptTrav-&gt;cUserName); <br>                                        PrintTextLine(cBuff); <br>                                        } <br>                                    } <br> <br>                                bSquare1 = bSquare2; <br>                                bSquare2 = bMaze[ix = ADJ_X(ix,Facing)][iy = ADJ_Y(iy,Facing)]; <br> <br>                                } while (!(bHitSomething|| <br>                                         ((bSquare1 &amp; Facing)||(bSquare2 &amp; BACK_TO_ABS(Facing))))); <br> <br>                            if (!bHitSomething) { <br>                                Sleep(100); <br>                                BitBlt(hDC,(rMaze.left+rMaze.right)/2 - 12, <br>                                       (rMaze.top+rMaze.bottom)/2 - 12, <br>                                       24,24, <br>                                       hBMDC,0,0,SRCINVERT); <br>                                SelectObject(hBMDC,(HGDIOBJ)NULL); <br>                                } <br> <br> <br>                            DeleteDC(hBMDC); <br>                            ReleaseDC(hWndMaze,hDC); <br>                            } <br> <br>                        break; <br> <br> <br>                    case VK_UP: <br>                        bSquare2 = bMaze[ADJ_X(ptSelf.Pos.ix,ptSelf.Pos.Facing)] <br>                                    [ADJ_Y(ptSelf.Pos.iy,ptSelf.Pos.Facing)]; <br>                        if ((bSquare1 &amp; ptSelf.Pos.Facing)||(bSquare2&amp;BACK_TO_ABS(ptSelf.Pos.Facing))) { <br>                            if (!sndPlaySound("blocks.wav",SND_ASYNC)) { <br>                                MessageBeep((UINT) -1); <br>                                } <br>                            } <br>                        else { <br>                            ptLastPos = ptSelf.Pos; <br>                            ptSelf.Pos.ix = ADJ_X(ptSelf.Pos.ix,ptSelf.Pos.Facing); <br>                            ptSelf.Pos.iy = ADJ_Y(ptSelf.Pos.iy,ptSelf.Pos.Facing); <br>                            ptTrav = &amp;ptDrones; <br>                            bKilled = FALSE; <br>                            while (ptTrav-&gt;next != NULL) { <br>                                ptTrav = ptTrav-&gt;next; <br>                                ptPos = ptTrav-&gt;Pos; <br>                                if ((!InSanctuary(&amp;ptSelf.Pos))&amp;&amp; <br>                                    (ptSelf.Pos.ix == ptPos.ix)&amp;&amp; <br>                                    (ptSelf.Pos.iy == ptPos.iy) <br>                                   ) { <br>                                    sprintf(cBuff,GetStringRes(IDS_FMT_SLEW),ptTrav-&gt;cUserName); <br>                                    PrintTextLine(cBuff); <br>                                    iKilledByDrones++; <br>                                    ptSelf.iScore -= (iDroneSpeed) ?    36/iDroneSpeed/iDroneSpeed : 72; <br>                                    KillSelf(); <br>                                    SendNetMessage(0,0,NULL,NP_SCORE); <br> <br>                                    bKilled = TRUE; <br>                                    break; <br>                                    } <br>                                } <br> <br>                            if (!bKilled) { <br>                                if (!SendNetMessage(0,0,&amp;ptSelf.Pos,NP_MOVETO)) { <br>                                    MessageBox((HWND)NULL,GetStringRes(IDS_SNDPCKTFAIL),"MazeWndProc", <br>                                               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                                    } <br>                                bNewSelfInSanct = InSanctuary(&amp;ptSelf.Pos); <br>                                if (bSelfInSanct != bNewSelfInSanct) { <br>                                    sprintf(cBuff, GetStringRes(IDS_FMT_SANCTUARY), <br>                                            GetStringRes2(bNewSelfInSanct ? IDS_ENTERED : IDS_LEFT)); <br>                                    PrintTextLine(cBuff); <br>                                    bSelfInSanct = bNewSelfInSanct; <br>                                    } <br> <br>                                PostMessage(hWnd,WM_COMMAND,IDM_REDRAW,(LPARAM)NULL); <br>                                hDC = GetDC(hWndTopView); <br>                                DrawTopView(hDC,FALSE); <br>                                ReleaseDC(hWndTopView,hDC); <br>                                PostMessage(hWndScore,WM_COMMAND,WC_UPDATEDIRECTION,0); <br>                                } <br>                            } <br>                        break; <br> <br>                    case VK_LEFT: <br>                        ptLastPos = ptSelf.Pos; <br>                        ptSelf.Pos.Facing = LEFT_TO_ABS(ptSelf.Pos.Facing); <br>                        PostMessage(hWnd,WM_COMMAND,IDM_REDRAW,(LPARAM)NULL); <br>                        if (!SendNetMessage(0,0,&amp;ptSelf.Pos,NP_MOVETO)) { <br>                            MessageBox((HWND)NULL,GetStringRes(IDS_SNDPCKTFAIL),"MazeWndProc", <br>                                        MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                            } <br>                        hDC = GetDC(hWndTopView); <br>                        DrawTopView(hDC,FALSE); <br>                        ReleaseDC(hWndTopView,hDC); <br>                        PostMessage(hWndScore,WM_COMMAND,WC_UPDATEDIRECTION,0); <br>                        break; <br> <br>                    case VK_RIGHT: <br>                        ptLastPos = ptSelf.Pos; <br>                        ptSelf.Pos.Facing = RIGHT_TO_ABS(ptSelf.Pos.Facing); <br>                        PostMessage(hWnd,WM_COMMAND,IDM_REDRAW,(LPARAM)NULL); <br>                        if (!SendNetMessage(0,0,&amp;ptSelf.Pos,NP_MOVETO)) { <br>                            MessageBox((HWND)NULL,GetStringRes(IDS_SNDPCKTFAIL),"MazeWndProc", <br>                                             MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                            } <br>                        hDC = GetDC(hWndTopView); <br>                        DrawTopView(hDC,FALSE); <br>                        ReleaseDC(hWndTopView,hDC); <br>                        PostMessage(hWndScore,WM_COMMAND,WC_UPDATEDIRECTION,0); <br>                        break; <br> <br>                    case VK_DOWN: <br>                        bSquare2 = bMaze[ADJ_X(ptSelf.Pos.ix,BACK_TO_ABS(ptSelf.Pos.Facing))] <br>                                    [ADJ_Y(ptSelf.Pos.iy,BACK_TO_ABS(ptSelf.Pos.Facing))]; <br>                        if ((bSquare2 &amp; ptSelf.Pos.Facing)||(bSquare1&amp;BACK_TO_ABS(ptSelf.Pos.Facing))) { <br>                            if (!sndPlaySound("blocks.wav",SND_ASYNC)) { <br>                                MessageBeep((UINT) -1); <br>                                } <br>                            } <br>                        else { <br>                            ptLastPos = ptSelf.Pos; <br> <br>                            ptSelf.Pos.ix = ADJ_X(ptSelf.Pos.ix,BACK_TO_ABS(ptSelf.Pos.Facing)); <br>                            ptSelf.Pos.iy = ADJ_Y(ptSelf.Pos.iy,BACK_TO_ABS(ptSelf.Pos.Facing)); <br>                            ptTrav = &amp;ptDrones; <br>                            bKilled = FALSE; <br>                            while (ptTrav-&gt;next != NULL) { <br>                                ptTrav = ptTrav-&gt;next; <br>                                ptPos = ptTrav-&gt;Pos; <br>                                if ((!InSanctuary(&amp;ptSelf.Pos))&amp;&amp; <br>                                    (ptSelf.Pos.ix == ptPos.ix)&amp;&amp; <br>                                    (ptSelf.Pos.iy == ptPos.iy) <br>                                   ) { <br>                                    sprintf(cBuff,GetStringRes(IDS_FMT_SLEW),ptTrav-&gt;cUserName); <br>                                    PrintTextLine(cBuff); <br>                                    ptSelf.iScore -= (iDroneSpeed) ? 36/iDroneSpeed/iDroneSpeed : 72; <br>                                    SendNetMessage(0,0,NULL,NP_SCORE); <br> <br>                                    iKilledByDrones++; <br>                                    KillSelf(); <br>                                    bKilled = TRUE; <br>                                    break; <br>                                    } <br>                                } <br>                            if (!bKilled) { <br>                                if (!SendNetMessage(0,0,&amp;ptSelf.Pos,NP_MOVETO)) { <br>                                    MessageBox((HWND)NULL,GetStringRes(IDS_SNDPCKTFAIL),"MazeWndProc", <br>                                               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                                    } <br>                                bNewSelfInSanct = InSanctuary(&amp;ptSelf.Pos); <br>                                if (bSelfInSanct != bNewSelfInSanct) { <br>                                    sprintf(cBuff, GetStringRes(IDS_FMT_SANCTUARY), <br>                                            GetStringRes2(bNewSelfInSanct ? IDS_ENTERED : IDS_LEFT)); <br>                                    PrintTextLine(cBuff); <br>                                    bSelfInSanct = bNewSelfInSanct; <br>                                    } <br>                                PostMessage(hWnd,WM_COMMAND,IDM_REDRAW,(LPARAM)NULL); <br>                                hDC = GetDC(hWndTopView); <br>                                DrawTopView(hDC,FALSE); <br>                                ReleaseDC(hWndTopView,hDC); <br>                                PostMessage(hWndScore,WM_COMMAND,WC_UPDATEDIRECTION,0); <br>                                } <br>                            } <br>                        break; <br> <br>                    // <br>                    // Whisper something <br>                    // <br>                    case 'W': <br>                    case 'w': <br>                        iLoudness = iWhisperDist; <br>                        DialogBox(hInst,"INTONE_DLG", hWnd, IntoneDlg); <br>                        iWhisperDist = iLoudness; <br>                        break; <br>                    // <br>                    // Shout something <br>                    // <br>                    case 'S': <br>                    case 's': <br>                        iLoudness = iShoutDist; <br>                        DialogBox(hInst,"INTONE_DLG", hWnd, IntoneDlg); <br>                        iShoutDist = iLoudness; <br>                        break; <br>                    default: <br>                        SendMessage(hWnd,WM_KEYDOWN,wParam,lParam); <br>                        break; <br>                    } <br>                } <br>            break; <br> <br>        case WM_MOVE: <br>            break; <br> <br>        case WM_SIZE: <br>            GetClientRect(hWnd,&amp;rMaze); <br>            Calc3DMaze(); <br>            StretchBitmaps(); <br>            if (bBitmapDraw) { <br>                if (((HWND)hMaze3DBM) != (HWND)NULL) { <br>                    DeleteObject(hMaze3DBM); <br>                    } <br>                hDC = GetDC(hWnd); <br>                if (hMaze3DBM != NULL) { <br>                    DeleteObject(hMaze3DBM); <br>                } <br>                hMaze3DBM = CreateCompatibleBitmap(hDC,rMaze.right-rMaze.left, <br>                                                   rMaze.bottom-rMaze.top); <br>                SelectObject(hMazeDC,hMaze3DBM); <br>                ReleaseDC(hWnd,hDC); <br>                } <br>            break; <br> <br>        case WM_PAINT: <br>            hMem = GlobalAlloc(GHND,sizeof(RECT)); <br>            rTemp = (LPRECT) GlobalLock(hMem); <br>            if (rTemp == NULL) { <br>                MessageBox((HWND)NULL,GetStringRes(IDS_MALLOCFAIL),"MazeWnd", <br>                           MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                PostMessage(hWndMain,WM_CLOSE,0,0); <br>                } <br>            GetUpdateRect(hWnd,rTemp,FALSE); <br>            ValidateRect(hWnd,rTemp); <br>            PostMessage(hWnd,WM_COMMAND,IDM_REDRAW,(LPARAM)rTemp); <br>            break; <br> <br>        case WM_CLOSE: <br>            KillTimer((HWND)NULL,uiTimer); <br>#ifdef WIN32 <br>            // <br>            // Destroy the mailslot. <br>            // <br>            if (hMailSlot != (HANDLE)NULL) { <br>                CloseHandle(hMailSlot); <br>                } <br>#endif <br>            DestroyWindow(hWnd); <br>            if (((HWND)hMaze3DBM) != (HWND)NULL) { <br>                DeleteObject(hMaze3DBM); <br>                DeleteDC(hMazeDC); <br>                } <br>            if (hWnd == hWndMain) { <br>                PostQuitMessage(0); <br>                } <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, Message, wParam, lParam); <br>            break; <br>        } <br> <br>    return(0); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
