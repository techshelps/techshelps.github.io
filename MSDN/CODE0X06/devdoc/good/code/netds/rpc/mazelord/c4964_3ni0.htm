<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INITMAZE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4968"></a>INITMAZE.C</h2>
<pre><code>/*********************************************************************** <br>File:   InitMaze.c <br> <br> <br>Abstract: <br> <br>    This module contains code to initialize the full maze, as well as the <br>    data structures associated with it. <br> <br>Contents: <br> <br>    InitMaze() -- Inserts subgrids into the Maze array, sets player position <br>    Calc3DMaze() -- Calculates posts used for drawing 3-d view <br>    InsertSubGrid() -- copies a sub-grid into the maze <br> <br> <br>************************************************************************/ <br> <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include "math.h" <br> <br> <br>/*===================================================================== <br>Function: InitMaze() <br> <br>Inputs: none <br> <br>Outputs: none <br> <br>Abstract: <br>    InitMaze is responsible for initializing the full maze to blocked <br>    characters, and setting up the temple space. <br>======================================================================*/ <br> <br>void InitMaze( <br>    void <br>    ) <br>{ <br>    int i,j; <br>    BYTE b; <br> <br>    // <br>    // Initialize the entire maze to being filled already. <br>    // we'll leave the outer subgrid ring as a buffer. <br>    // <br>    b = NORTH | WEST | SOUTH | EAST; <br> <br>    for(i=0;i&lt;X_SIZE;i++) { <br>        for (j=0;j&lt;Y_SIZE;j++) { <br>            bMaze[i][j] = b; <br>            } <br>        } <br> <br>    InsertSubGrid(NUM_PLAYER_SUBGRIDS,6,6); <br>    InsertSubGrid(NUM_PLAYER_SUBGRIDS+1,7,6); <br>    InsertSubGrid(NUM_PLAYER_SUBGRIDS+2,5,7); <br>    InsertSubGrid(NUM_PLAYER_SUBGRIDS+3,6,7); <br>    InsertSubGrid(NUM_PLAYER_SUBGRIDS+4,7,7); <br>    InsertSubGrid(NUM_PLAYER_SUBGRIDS+5,6,8); <br>    InsertSubGrid(NUM_PLAYER_SUBGRIDS+6,7,8); <br> <br>    // <br>    // Kludge to start new players out in the sanctuary <br>    // <br>    ptSelf.Pos.ix = 6*X_CELLS_PER_SUBGRID+1; <br>    ptSelf.Pos.iy = 7*Y_CELLS_PER_SUBGRID+1; <br>    ptSelf.Pos.Facing = NORTH; <br>    ptLastPos = ptSelf.Pos; <br> <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: Calc3DMaze() <br> <br>Inputs: none <br> <br>Outputs: none <br> <br>Abstract: <br>    Calc maze is responsible for recalculating the maze drawing info. <br>    3-d transformations are done only when the window is resized. The <br>    results are stored in a table (giving the polygons for each panel, from <br>    left to right in 2-d coordinates. <br>======================================================================*/ <br> <br>void Calc3DMaze( <br>     ) <br>{ <br>    int i,j,k,width,depth; <br>    float pw, ph,x[3],y[3], dx, dyh, dyl, dz, dist; <br>    POINT pCenter; <br>    float m,b; <br> <br> <br>    SetCursor(LoadCursor((HINSTANCE)NULL,IDC_WAIT)); <br> <br>    pw = (float) PANEL_WIDTH; <br>    ph = (float) PANEL_HEIGHT; <br> <br>    // <br>    // establish the scale. Should be sufficient to allow the end of the panel <br>    // we're in to show.  A full panel displayed 1/2 panel away should be 2/3 <br>    // of the screen wide. <br>    // <br>    width = (rMaze.right - rMaze.left); <br>    depth = (rMaze.bottom - rMaze.top); <br> <br>    // <br>    // Since scale is used in MC_TO_SC, we need to nullify its effect to set it <br>    // <br>    scale = (float) 1.0; <br>    scale = (float) (.9 * depth/((float)MC_TO_SC(ph,-pw/2))); <br> <br> <br>    pCenter.x = rMaze.left + width/2; <br>    pCenter.y = rMaze.top + depth/2; <br> <br>    // <br>    // x and y center <br>    // <br>    dyl = ph /2; <br>    dyh = - dyl; <br> <br>    for(i=0;i&lt;(MAX_DRAW_DIST*2+2);i++) { <br>        for (j=1;j&lt;(MAX_DRAW_DIST+2);j++) { <br> <br>            // <br>            // Calculate post in left position <br>            // <br> <br>            dx = (i - (MAX_DRAW_DIST+1)) * pw - pw /2; <br>            dz = (j-1)*pw - pw/2; <br> <br>            // <br>            // left top <br>            // <br>            dist = dz; <br> <br>            pPost[i][j][0].x = pCenter.x + (int) MC_TO_SC(dx,dist); <br>            pPost[i][j][0].y = pCenter.y + (int) MC_TO_SC(dyh,dist); <br> <br>            // <br>            // left bottom <br>            // <br>            dist = dz; <br>            pPost[i][j][1].x = pCenter.x + (int) MC_TO_SC(dx,dist); <br>            pPost[i][j][1].y = pCenter.y + (int) MC_TO_SC(dyl,dist); <br> <br>            } <br>        } <br> <br>    // <br>    // Clip as necessary, using line equation: y=mx + b. <br>    // <br>    for (i=0,j=0;i&lt;(MAX_DRAW_DIST*2+2);i++) { <br>        for (k=0;k&lt;2;k++) { <br>            x[1] = (float) pPost[i][1][k].x; <br>            x[2] = (float) pPost[i][2][k].x; <br>            y[1] = (float) pPost[i][1][k].y; <br>            y[2] = (float) pPost[i][2][k].y; <br>            m = (y[2] - y[1])/(x[2]-x[1]); <br>            b = y[1] - m*x[1]; <br>            if (i &lt; MAX_DRAW_DIST+2) { <br>                pPost[i][0][k].x = rMaze.left; <br>                } <br>            else { <br>                pPost[i][0][k].x = rMaze.right; <br>                } <br>            pPost[i][0][k].y = (int)(m*((float)pPost[i][0][k].x) + b); <br>            } <br>        } <br> <br>    SetCursor(LoadCursor((HINSTANCE)NULL,IDC_ARROW)); <br> <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: InsertSubGrid() <br> <br>Inputs: # of subgrid, x and y position in maze to insert the subgrid <br> <br>Outputs: none <br> <br>Abstract: <br>    Insert Subgrid will copy the specified subgrid into bMaze, with its upper <br>    left corner at iXPos*X_CELLS_PER_SUBGRID, iYPos*Y_CELLS_PER_SUBGRID. <br>======================================================================*/ <br> <br>void InsertSubGrid( <br>    int SubGridNo, <br>    int iXPos, <br>    int iYPos <br>    ) <br>{ <br>    int i,j; <br> <br>    iXPos = iXPos*X_CELLS_PER_SUBGRID; <br>    iYPos = iYPos*Y_CELLS_PER_SUBGRID; <br> <br> <br>    for (i=0;i&lt;X_CELLS_PER_SUBGRID;i++) { <br>        for (j=0;j&lt;Y_CELLS_PER_SUBGRID;j++) { <br>            bMaze[i+iXPos][j+iYPos] = SubGrids[SubGridNo].Cell[i][j]; <br>            } <br>        } <br> <br>    return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
