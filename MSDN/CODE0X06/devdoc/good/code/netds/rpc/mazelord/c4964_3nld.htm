<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINMAZE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4981"></a>WINMAZE.H</h2>
<pre><code>/************************************************* <br>MODULE: WinMaze.h <br> <br>This module contains typedefs, etc for Maze Lords. <br>Prototypes are contained in MazProto.h. <br>*************************************************/ <br> <br>#ifndef _WINMAZE_H_INC_ <br>#define _WINMAZE_H_INC_ <br> <br>#ifndef _IN_RC_ <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#endif <br>#include &lt;windows.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include "net.h" <br>#include "MAZEDLG.h" <br> <br>#ifdef WIN16 <br> <br>#define Sleep(x)                // Sleep doesn't exist. <br>#define PT_MOVETO 1 <br>#define PT_LINETO 2 <br>#define GET_WM_COMMAND_ID(wp, lp)                   (wp) <br>#define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp) <br>#define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp) <br>typedef long INT; <br>typedef LPCSTR LPCTSTR; <br> <br>#else  // Else if it's win32 <br> <br>#define SELECTOROF(a) a <br>#define GET_WM_COMMAND_ID(wp, lp)               LOWORD(wp) <br>#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(lp) <br>#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(wp) <br>#undef INT <br>#define INT int <br> <br>#endif <br> <br> <br>#define PIC_X           100     // Bitmaps are 100 pixels wide. <br>#define PIC_Y           150     // Bitmaps are 150 pixels tall. <br> <br>#define PIC_FISH        0 <br>#define PIC_ROBOT       1 <br>#define PIC_SMILEY      2 <br>#define PIC_REAPER      3 <br>#define NUM_PICS        4 <br> <br>#define PIC_DRONE       PIC_ROBOT <br>#define PIC_DEFAULT     PIC_FISH <br> <br> <br>#define IDM_FILE                  1000 <br>#define IDM_F_HIGHSCORES               1050 <br>#define IDM_F_NEWGAME                  1100 <br>#define IDM_F_EXIT                     1200 <br>#define IDM_OPTIONS               2000 <br>#define IDM_O_PLAYERSTRETCH            2040 <br>#define IDM_O_DRONESTRETCH             2041 <br>#define IDM_O_DRONES                   2050 <br>#define IDM_O_NET                      2055 <br>#define IDM_O_LOCAL                    2085 <br>#define IDM_O_PAUSE                    2100 <br>#define IDM_O_PLAYERSET                2105 <br>#define IDM_F_STOP                     2110 <br>#define IDM_O_BITMAP                   2115 <br>#define IDM_ABOUT                 3000 <br>#define IDM_DRAWPLAYERS           1001 <br>#define IDM_DRAWDRONES            1002 <br>#define IDT_NEWMAIL               4001 <br>#define IDM_REDRAW                5001 <br> <br> <br>// Resource String Definitions <br>#define IDS_ERR_REGISTER_CLASS   1 <br>#define IDS_ERR_CREATE_WINDOW    2 <br> <br>#define IDS_MALLOCQUIT         16 <br>#define IDS_MALLOCFAIL         17 <br>#define IDS_RECTALLOCFAIL      18 <br>#define IDS_HSCONOTIMPL        19 <br>#define IDS_SAFEZONE           20 <br>#define IDS_CRETMRFAIL         21 <br>#define IDS_SNDPCKTFAIL        22 <br>#define IDS_RDSGRDTXTFLFAIL    23 <br>#define IDS_GETUSRNMFAIL       24 <br>#define IDS_SNDQUITPCKTFAIL    25 <br>#define IDS_DEMOMODE           26 <br> <br>#define IDS_MDFYSCO            28 <br>#define IDS_GETTXTMTRCSFAIL    29 <br>#define IDS_SCOADD0FAIL        30 <br>#define IDS_CHGSCOFAIL         31 <br>#define IDS_CHGDIRFAIL         32 <br>#define IDS_DELSCOFAIL         33 <br>#define IDS_BADMSG             34 <br>#define IDS_MALLOCFAILABT      35 <br>#define IDS_FMT_DRONE          36 <br> <br>#define IDS_FMT_RUNDOWN        38 <br>#define IDS_BADPCKTXMITFAIL    39 <br>#define IDS_CREMSLOTFAIL       40 <br>#define IDS_CREMWATCHTHRFAIL   41 <br>#define IDS_RDMSLOTFAIL        42 <br>#define IDS_FMT_JOIN           43 <br>#define IDS_FMT_ZAPPEDYOU      44 <br>#define IDS_FMT_LEFT           45 <br>#define IDS_FMT_HIT            46 <br>#define IDS_BADCOMMSG             47 <br>#define IDS_LDSGRIDRESFAIL     48 <br>#define IDS_FMT_BADNUMDRONES   49 <br>#define IDS_ERRINPUT           50 <br>#define IDS_FMT_BADMOVESPERSEC 51 <br> <br>#define IDS_TELEPORT           54 <br>#define IDS_SANCTUARY          55 <br> <br>#define IDS_NOVIOLENCE         58 <br>#define IDS_FMT_YOUZAPPED      59 <br>#define IDS_FMT_SLEW           60 <br>#define IDS_HSCO               61 <br>#define IDS_FATALERR           62 <br>#define IDS_ASKSTOP            63 <br>#define IDS_STOP               64 <br>#define IDS_INITFAIL           65 <br>#define IDS_NETINIT            66 <br>#define IDS_FMT_SANCTUARY      67 <br>#define IDS_ENTERED            68 <br>#define IDS_LEFT               69 <br>#define IDS_FMT_BADPICNUM      70 <br> <br>#define WC_UPDATESCORE           1000 <br>#define WC_UPDATEDIRECTION       1010 <br>#define WC_DELETESCORE           1020 <br>#define WC_ADDSCORE              1030 <br> <br> <br>                    // we can see up to 10 squares ahead or to either side <br>                    // (not including our current square) <br>#define MAX_DRAW_DIST 10 <br> <br>#define MAX_DRONES 100 <br>#define MAX_DRONE_SPEED 5 <br> <br>#define ONE_SECOND 1000 <br> <br>#define PANEL_WIDTH 100 <br>#define PANEL_HEIGHT 150 <br> <br>        // Flags for walls in a Cell <br>#define NORTH ((BYTE)0x01) <br>#define WEST  ((BYTE)0x02) <br>#define SOUTH ((BYTE)0x04) <br>#define EAST  ((BYTE)0x08) <br> <br>#define AWAY        0 <br>#define TOWARD      2 <br> <br>#define FORWARD     0 <br>#define LEFT        1 <br>#define BACK        2 <br>#define RIGHT       3 <br> <br>        // # of Cells in a subgrid <br>#define X_CELLS_PER_SUBGRID 5 <br>#define Y_CELLS_PER_SUBGRID 5 <br>        // # of Subgrids in the Grid <br>#define X_SUBGRIDS_PER_GRID 10 <br>#define Y_SUBGRIDS_PER_GRID 10 <br> <br>#define X_SIZE (X_CELLS_PER_SUBGRID * (X_SUBGRIDS_PER_GRID+2)) <br>#define Y_SIZE (Y_CELLS_PER_SUBGRID * (Y_SUBGRIDS_PER_GRID+2)) <br>        // We have SUBGRI00.TXT through SUBGRI06.TXT for players, <br>#define NUM_PLAYER_SUBGRIDS 7 <br>        // And SUBGRI07.TXT through SUBGRI13.TXT for the palace <br>#define NUM_PALACE_SUBGRIDS 7 <br>        // SUBGRI14.TXT is completely closed, for unused grids <br> <br>#define NUM_SUBGRIDS (NUM_PLAYER_SUBGRIDS + NUM_PALACE_SUBGRIDS + 1) <br>#define SUBGRID_DEFAULT 1 <br> <br> <br>// A maze is an array of characters, with each character being a combination <br>// of the NORTH, SOUTH, EAST, and WEST bit flags.  If the flag is set, there <br>// is a wall there. If not, there isn't. Note that both the flag of the <br>// current cell and of the adjacent cell in that direction must be checked. <br> <br> <br>        // Adjacent returns the coordinates of the cell in that direction <br>        // This applies to both Grid and Maze coordinates. <br>#define ADJ_X(x,dir) ((((BYTE)(dir)) &amp; EAST) ? ((x)+1) : \ <br>              ((((BYTE)(dir)) &amp; WEST) ? ((x)-1) : (x))) <br>#define ADJ_Y(y,dir) ((((BYTE)(dir)) &amp; SOUTH) ? ((y)+1) : \ <br>              ((((BYTE)(dir)) &amp; NORTH) ? ((y)-1) : (y))) <br>        // To calculate SubGrid # from a coordinate <br>#define X_TO_SUBGRID(x) ((int) (x) / X_CELLS_PER_SUBGRID) <br>#define Y_TO_SUBGRID(y) ((int) (y) / Y_CELLS_PER_SUBGRID) <br>        // To get origin of a subgrid in coordinates from subgrid #'s <br>#define SUBGRID_TO_X(x) ((int) (x) * X_CELLS_PER_SUBGRID) <br>#define SUBGRID_TO_Y(y) ((int) (y) * Y_CELLS_PER_SUBGRID) <br> <br>        // Convert relative direction to absolute <br>#define LEFT_TO_ABS(dir) (((((BYTE)dir)) &amp; EAST) ? NORTH : ((BYTE)(((BYTE) (dir))&lt;&lt;1))) <br>#define RIGHT_TO_ABS(dir) ((((BYTE)(dir)) &amp; NORTH) ? EAST : ((BYTE)(((BYTE) (dir))&gt;&gt;1))) <br>#define BACK_TO_ABS(dir)  (LEFT_TO_ABS(LEFT_TO_ABS(dir))) <br> <br> <br>#define RECTWIDTH(r) ((r).right - (r).left) <br>#define RECTDEPTH(r) ((r).bottom - (r).top) <br>#define GREATEROF(a,b) (((a)&gt;(b))?(a):(b)) <br>#define LESSEROF(a,b) (((a)&lt;(b))?(a):(b)) <br> <br>struct S_BitMapPicType { <br>    HBITMAP hBitmap; <br>    int xSize,ySize; <br>    int xOrg,yOrg; <br>    }; <br>typedef struct S_BitMapPicType BitMapPicType; <br> <br>struct S_PicType { <br>    BitMapPicType P[4]; <br>    }; <br>typedef struct S_PicType PicType; <br> <br>struct S_FullPicType { <br>    BitMapPicType P[4];     // BitMap <br>    BitMapPicType M[4];     // Black and white Mask <br>    int     iPicNum; <br>    struct S_FullPicType FAR *next; <br>    }; <br>typedef struct S_FullPicType FullPicType; <br> <br> <br>struct _SLineType { <br>   int x[2],y[2]; <br>   }; <br> <br>typedef struct _SLineType LineType; <br> <br> <br> <br>        // A cell is a single square in a sub-grid <br>typedef BYTE CellType; <br> <br>        // SubGridCellsType is the array of characters that make up a sub-grid <br>struct S_SubGridCellsType { <br>    CellType Cell[X_CELLS_PER_SUBGRID][Y_CELLS_PER_SUBGRID]; <br>    }; <br>typedef struct S_SubGridCellsType SubGridCellsType; <br> <br>typedef struct { <br>  int ix, iy; <br>  BYTE Facing; <br>  } PositionType; <br> <br> <br>struct _s_PlayerType { <br>  unsigned long ulID; <br>  DWORD dwPID; <br>  char cUserName[MAX_USERNAME_LENGTH]; <br>  char cComputerName[MAX_COMPUTERNAME_LENGTH]; <br>  PositionType Pos; <br>  BOOL Drawn; <br>  RECT rDrawn; <br>  RECT rFrom; <br>  int iScore; <br>  int iPicNum; <br>  int iGridNum; <br>  POINT pGridLoc; <br>  BYTE dwDirectShown; <br>  struct _s_PlayerType FAR *next; <br>  }; <br>typedef struct _s_PlayerType PlayerType; <br> <br> <br>struct _s_PlayerDrawType { <br>  PlayerType FAR *p;            // Pointer to the player to draw <br>  RECT rDraw,                   // Rectangle the FULL bitmap would be drawn in <br>       rClip;                   // Rectangle available for drawing in. <br>  int iRelx,iRely; <br>  struct _s_PlayerDrawType FAR *next; <br>  }; <br> <br>typedef struct _s_PlayerDrawType PlayerDrawType; <br> <br> <br> <br>        // SubGridType is a full description of a SubGrid. <br>struct S_SubGridType { <br>    unsigned long ulOwnerID; <br>    POINT Pos; <br>        // Since there are a limited # of subgrids, we might share them. <br>    SubGridCellsType *SubGrid; <br>    }; <br> <br>typedef struct S_SubGridType SubGridType; <br> <br>struct _SObjectType { <br>    DWORD Class; <br>    DWORD ObjectID; <br>    POINT MazePos; <br>    BYTE Facing; <br>    struct _SObjectType * next; <br>}; <br> <br>typedef struct _SObjectType ObjectType; <br> <br>struct _SHoleType { <br>    int x[2]; <br>    struct _SHoleType FAR *next; <br>    }; <br> <br>typedef struct _SHoleType HoleType; <br> <br>struct _S_ScoreType { <br>    unsigned long ulID; <br>    int ix,iy;          // Upper left corner of score entry <br>    int iScore; <br>    BYTE bDir; <br>    struct _S_ScoreType FAR *next; <br>    }; <br> <br>typedef struct _S_ScoreType ScoreType; <br> <br>typedef struct { <br>    int iLoudness; <br>    PositionType Pos; <br>    DWORD dwLen; <br>    char cBuff[132]; <br>    } IntoneType; <br> <br> <br>typedef struct { <br>    int xSize,ySize; <br>    int xOrg,yOrg; <br>    } PicPosType; <br> <br>typedef struct { <br>   char cBase[5]; <br>   int iPicNum; <br>   PicPosType PicPos[4]; <br>   } PicSpecType; <br> <br> <br> <br> <br> <br> <br> <br>//////////////////////////////////////////////////////////////////////////// <br> <br>/**********************Function definitions***************************/ <br> <br>int ReadSubGrids(VOID); <br>int InitGrid(VOID); <br> <br>LPTSTR   GetStringRes(int id); <br>LPTSTR   GetStringRes2(int id); <br> <br>/**********************GLOBAL VARIABLES ****************************/ <br>                // If we're in the main function, the globals <br>                // will be declared. Otherwise they'll just <br>                // be given as externs. <br>#ifndef IN_MAIN <br>#define EXT_DECL extern <br>#else <br>#define EXT_DECL <br>#endif <br> <br>EXT_DECL SubGridType FAR  * FAR *Grid; <br>EXT_DECL SubGridCellsType FAR *SubGrids; <br>EXT_DECL FILE  *hFile; <br>EXT_DECL int xc,yc,xscale,yscale; <br>EXT_DECL RECT CurView; <br>EXT_DECL char szString[128];   /* variable to load resource strings         */ <br> <br>EXT_DECL char szAppName[20];   /* class name for the window               */ <br>EXT_DECL HINSTANCE hInst; <br>EXT_DECL HWND hWndMain,hWndMaze,hWndTopView,hWndText,hWndScore; <br>EXT_DECL RECT rMain,rMaze,rTopView,rText,rScore; <br>EXT_DECL BYTE FAR * FAR *bMaze; <br>EXT_DECL LPPOINT FAR * FAR *pPost; <br>EXT_DECL int iNumDrones,iDroneSpeed,iDroneMoveAlg; <br>EXT_DECL UINT uiTimer; <br>EXT_DECL HBITMAP hFishBitmap[4],hFishMask[4]; <br>EXT_DECL HBITMAP hRoboBitmap[4],hRoboMask[4]; <br>EXT_DECL int ViewEnd;           // This is how many squares ahead we can see <br>EXT_DECL BOOL GamePaused,GameStarted,bNetworked,bSelfInSanct; <br> <br>EXT_DECL FullPicType fptPic; <br>EXT_DECL HBITMAP hbScratch; <br>EXT_DECL float scale; <br> <br>EXT_DECL PlayerType ptSelf; <br>EXT_DECL PlayerType ptPlayers; <br>EXT_DECL PlayerType ptDrones; <br>EXT_DECL HANDLE hMailSlot; <br> <br>EXT_DECL PositionType ptLastPos; <br> <br>EXT_DECL int iPlayersKilled,iDronesKilled; <br>EXT_DECL int iTimesKilled,iKilledByDrones; <br>EXT_DECL ScoreType Scores; <br>EXT_DECL int iWhisperDist, iShoutDist,iLoudness; <br> <br>EXT_DECL HBITMAP hShotBM[2],hFadeBM[2]; <br> <br>EXT_DECL HBITMAP hMaze3DBM; <br>EXT_DECL HDC     hMazeDC; <br>EXT_DECL BOOL    bBitmapDraw; <br>EXT_DECL BOOL    bPlayerPrestretch,bDronePrestretch; <br>EXT_DECL FullPicType FAR * FAR *PreStretch; <br> <br>EXT_DECL BOOL    bDemoMode; <br>EXT_DECL BOOL    bDemoEnable; <br>EXT_DECL INT     UserIntCount; <br> <br> <br>extern PicSpecType PicSpec[]; <br>extern int iNumPicSpecs; <br> <br>/*******************END GLOBALS *************************************/ <br> <br>#define VIEWER_DIST              (PANEL_WIDTH) <br>#define MC_TO_SC(x,z) (scale*(VIEWER_DIST * (x)/((z)+(VIEWER_DIST)))) <br> <br> <br> <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
