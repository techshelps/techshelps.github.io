<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4966"></a>DRAW.C</h2>
<pre><code>/********************************************************************** <br>File:   InitMaze.c <br> <br> <br>Abstract: <br> <br>    This module contains drawing routines for MazeLords. <br> <br>Contents: <br> <br>    DelHole() -- <br>    NewHole() -- <br>    DrawRect() -- <br>    NewPlayerDraw() -- <br>    DelPlayerDraw() -- <br>    CheckForPlayers() -- <br>    DrawFoundPlayers() -- <br>    DrawMaze() -- <br>    DrawTopView() -- <br>    DrawPlayers() -- <br> <br> <br>Revision History: <br> <br>************************************************************************/ <br> <br>#include "winmaze.h" <br>#include "mazproto.h" <br> <br>LPPOINT pDraw; <br>LPBYTE pType; <br>int PointCount; <br> <br>/********************************************************************** <br> *                                                                    * <br> * FUNCTION:  PolyDraw95(HDC, LPPOINT, LPBYTE, int)                   * <br> *                                                                    * <br> * PURPOSE:   Draws the points returned from a call to GetPath()      * <br> *            to an HDC                                               * <br> *                                                                    * <br> * NOTES:     This function is similar to the Windows NT PolyDraw     * <br> *            function, which draws a set of line segments and Bezier * <br> *            curves. Because PolyDraw is not supported in Windows 95 * <br> *            this PolyDraw95 function is used instead.               * <br> *                                                                    * <br> * MODS:      Added this function in order to provide support for     * <br> *            Windows 95.                                             * <br> *                                                                    * <br> *********************************************************************/ <br>BOOL PolyDraw95(HDC  hdc,              // handle of a device context <br>                CONST LPPOINT lppt,      // array of points <br>                CONST LPBYTE lpbTypes, // line and curve identifiers <br>                int  cCount)             // count of points <br>{ <br>  int i; <br> <br>  for (i=0; i&lt;cCount; i++) <br>    switch (lpbTypes[i]) { <br>      case PT_MOVETO : <br>         MoveToEx(hdc, lppt[i].x, lppt[i].y, NULL); <br>         break; <br> <br>      case PT_LINETO | PT_CLOSEFIGURE: <br>      case PT_LINETO : <br>         LineTo(hdc, lppt[i].x, lppt[i].y); <br>         break; <br> <br>      case PT_BEZIERTO | PT_CLOSEFIGURE: <br>      case PT_BEZIERTO : <br>        PolyBezierTo(hdc, &amp;lppt[i], 3); <br>       i+=2; <br>         break; <br>    } <br> <br>   return TRUE; <br>} <br> <br> <br>// <br>// convert an offset to an increment to add. <br>// <br>#define ABS2OFFX(x,y,Facing) (((Facing)&amp;NORTH) ? (x) : \ <br>                              ((Facing)&amp;SOUTH) ? -(x) : \ <br>                              ((Facing)&amp;EAST) ? (y) : -(y)) <br>#define ABS2OFFY(x,y,Facing) (((Facing)&amp;NORTH) ? -(y) : \ <br>                              ((Facing)&amp;SOUTH) ? (y) : \ <br>                              ((Facing)&amp;EAST) ? (x) : -(x)) <br> <br> <br>/*===================================================================== <br>Function: DelHole() <br> <br>Inputs: Pointer to HoleType record to delete <br> <br>Outputs: Returns -&gt;next field of deleted record <br> <br>Abstract: <br>    Deletes a record of type HoleType, returns -&gt;next pointer to <br>    facilitate list maintenance <br>======================================================================*/ <br> <br>HoleType FAR *DelHole( <br>    HoleType FAR *h <br>    ) <br>{ <br>    HoleType FAR *t; <br>    HANDLE hMem; <br> <br>    if (h == NULL) { <br>        return((HoleType FAR *) NULL); <br>        } <br>    else { <br>        hMem = (HGLOBAL) GlobalHandle(SELECTOROF( h)); <br>        t = h-&gt;next; <br>        GlobalUnlock(hMem); <br>        GlobalFree(hMem); <br>        return(t); <br>        } <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: NewHole() <br> <br>Inputs: HoleType element values <br> <br>Outputs:Returns a pointer to a new initialized HoleType record <br> <br>Abstract: <br>    No explanation needed <br>======================================================================*/ <br> <br>HoleType FAR *NewHole( <br>    int x1, <br>    int x2, <br>    HoleType FAR *next <br>    ) <br> <br>{ <br>    HoleType FAR *h; <br>    HANDLE hMem; <br> <br>    hMem =  GlobalAlloc(GHND,sizeof(HoleType)); <br>    h = (HoleType FAR *) GlobalLock(hMem); <br>    if (h == (HoleType FAR *) NULL) { <br>        MessageBox((HANDLE) NULL,GetStringRes(IDS_MALLOCQUIT), NULL ,MB_ICONEXCLAMATION); <br>        exit(0); <br>        } <br>    h-&gt;x[0] = x1; <br>    h-&gt;x[1] = x2; <br>    h-&gt;next = next; <br> <br>    return(h); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: DrawRect() <br> <br>Inputs: Hole List (determining what is visible), <br>    relative x and y coordinates of wall to draw, <br>    relative facing of wall to draw <br> <br>Outputs: Modifies hole list, returns a pointer to where hole processing <br>    should resume from <br> <br>Abstract: <br>    DrawRect expects to draw a wall for the coordinate (iRelX,iRelY) relative <br>    facing bRelDir. <br> <br>    For clipping, suppose we have <br> <br>          xr <br>          | <br>      p1|--- <br>        |   ---    xs <br>        |      --- | <br>        |         --- p4 <br>        |            | <br>        |            | <br>        |            | <br>        |         --- p3 <br>        |      --- <br>        |   --- <br>      p2|--- <br> <br>    where (p1 to p4) are known endpoints for a panel, and xr and xs are <br>    vertical clipping lines (fortunately we're restricted to these. <br>    The new dimensions for p1-p4 are easy to calculate, since, it is a matter <br>    of similar triangles: <br> <br>        |         ---. p3 <br>        |      --- ; . <br>        |   ---    ; . <br>      p2|---.......... <br>                   ; <br>                   xs <br> <br>    We need to recalculate p3, since it is past the clipping boundary. By <br>    similar triangles, we know  (p3.y-p2.y)/(p3.x-p2.x) = (xs.y-p2.y)/(xs.x-p2.x). <br>    This in turn gives us xs.y = (p3.y-p2.y)*(xs.x-p2.x)/(p3.x-p2.x) + p2.y. This <br>    can be applied to all four endpoints. <br>======================================================================*/ <br> <br>HoleType FAR *DrawRect( <br>    HoleType FAR *htTrav, <br>    int iRelX, <br>    int iRelY, <br>    BYTE bRelDir <br>    ) <br>{ <br>    POINT p[4]; <br>    int i,rb; <br>    int ihLeft,ihRight; <br>    BOOL bIsLeftSide; <br> <br> <br>    bIsLeftSide = (iRelX &lt; 0); <br> <br> <br>    if ((htTrav == NULL)||(htTrav-&gt;next == NULL)) { <br>        return(NULL); <br>        } <br> <br>    ihLeft = htTrav-&gt;next-&gt;x[0]; <br>    ihRight= htTrav-&gt;next-&gt;x[1]; <br> <br>    if (ihLeft &gt;= ihRight) { <br>        return(htTrav-&gt;next); <br>        } <br> <br>    // <br>    //p1=p[0],p2=p[1],p4=p[2],p3=p[3] from diagram above. <br>    // <br>    switch(bRelDir) { <br> <br>        // <br>        // Wall furthest away from us <br>        // <br>        case NORTH: <br>            for(i=0;i&lt;2;i++) { <br>                p[i] = pPost[iRelX+MAX_DRAW_DIST+1][iRelY+1][i]; <br>                p[i+2] = pPost[iRelX+MAX_DRAW_DIST+2][iRelY+1][i]; <br>                } <br>            break; <br> <br>        // <br>        // Wall closest to us <br>        // <br>        case SOUTH: <br>            for(i=0;i&lt;2;i++) { <br>                p[i] = pPost[iRelX+MAX_DRAW_DIST+1][iRelY][i]; <br>                p[i+2] = pPost[iRelX+MAX_DRAW_DIST+2][iRelY][i]; <br>                } <br>            break; <br> <br>        // <br>        // West ==&gt; we're working on the left side of the screen <br>        // <br>        case WEST: <br>            for(i=0;i&lt;2;i++) { <br>                p[i] = pPost[iRelX+MAX_DRAW_DIST+1][iRelY][i]; <br>                p[i+2] = pPost[iRelX+MAX_DRAW_DIST+1][iRelY+1][i]; <br>                } <br>            break; <br> <br>        // <br>        // East ==&gt; we're working on the right side of the screen <br>        // <br>        case EAST: <br>            for(i=0;i&lt;2;i++) { <br>                p[i] = pPost[iRelX+MAX_DRAW_DIST+2][iRelY+1][i]; <br>                p[i+2] = pPost[iRelX+MAX_DRAW_DIST+2][iRelY][i]; <br>                } <br>            break; <br>        } <br> <br>    // <br>    // If we can see any of the panel through the hole, <br>    // go ahead and draw it! <br>    // <br>    if ((p[0].x &lt; ihRight)&amp;&amp;(p[2].x &gt; ihLeft)) { <br>        for(i=0;i&lt;2;i++) { <br>            // <br>            // Clip the left side, if needed. <br>            // <br>            if (p[i].x &lt; ihLeft ) { <br>                p[i].y = ((p[i].y-p[i+2].y)*(ihLeft-p[i+2].x)/ <br>                            (p[i].x-p[i+2].x)) + p[i+2].y; <br>                p[i].x = ihLeft; <br>                } <br> <br>            // <br>            // and the right side... <br>            // <br>            if (p[3-i].x &gt; ihRight) { <br>                p[3-i].y = ((p[3-i].y-p[1-i].y)*(ihRight-p[1-i].x)/ <br>                            (p[3-i].x-p[1-i].x)) + p[1-i].y; <br>                p[3-i].x = ihRight; <br>                } <br>            } <br> <br>        // <br>        // Now we need to add these points into the draw list. <br>        // <br>        pType[PointCount]=PT_MOVETO; <br>        pDraw[PointCount++]=p[0]; <br>        pType[PointCount]=PT_LINETO; <br>        pDraw[PointCount++]=p[1]; <br>        pType[PointCount]=PT_LINETO; <br>        pDraw[PointCount++]=p[3]; <br>        pType[PointCount]=PT_LINETO; <br>        pDraw[PointCount++]=p[2]; <br>        pType[PointCount]=PT_LINETO; <br>        pDraw[PointCount++]=p[0]; <br> <br>        if (p[0].x == ihLeft) { <br>            if (p[2].x == ihRight) { <br>                // <br>                // If left and right match exactly, delete hole. <br>                // <br>                htTrav-&gt;next = DelHole(htTrav-&gt;next); <br>                } <br>            else { <br>                // <br>                // if left matches, but right doesn't, set hole to rt,rt <br>                // <br>                htTrav-&gt;next-&gt;x[0] = p[2].x; <br>                } <br>            } <br>        else { <br>            // <br>            // if the left doesn't match, at the very least we need <br>            // to keep the left to the current spot. <br>            // <br>            rb = htTrav-&gt;next-&gt;x[1]; <br>            htTrav-&gt;next-&gt;x[1] = p[0].x; <br> <br>            if (p[2].x != rb) { <br>                // <br>                // Also, if the right side didn't match up, we need to <br>                // create a new hole. <br> <br>                // <br>                // need to make sure the hole won't get skipped as we <br>                // continue processing inside to outside... <br>                // <br>                if (bIsLeftSide) { <br>                    htTrav-&gt;next = NewHole(p[2].x,rb,htTrav-&gt;next); <br>                    } <br>                else { <br>                    htTrav-&gt;next-&gt;next = NewHole(p[2].x,rb,htTrav-&gt;next-&gt;next); <br>                    } <br>                } <br>            } <br>        } <br> <br>    return(htTrav); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: NewPlayerDraw() <br> <br>Inputs: PlayerDrawType record element values <br> <br>Outputs: Pointer to a new, initialized record of type PlayerDrawType <br> <br>Abstract: <br>    No explanation needed. <br>======================================================================*/ <br> <br>PlayerDrawType FAR *NewPlayerDraw( <br>    PlayerType FAR *p, <br>    LPRECT rDraw, <br>    LPRECT rClip, <br>    int iRelx, <br>    int iRely, <br>    PlayerDrawType FAR *next <br>    ) <br>{ <br>    PlayerDrawType FAR *pdtRet; <br>    HGLOBAL hMem; <br> <br>    hMem = GlobalAlloc(GHND,(sizeof(PlayerDrawType))); <br>    pdtRet = (PlayerDrawType FAR *) GlobalLock(hMem); <br>    if (pdtRet == NULL) { <br>        MessageBox((HWND) NULL,GetStringRes(IDS_MALLOCFAIL),"NewPlayerDraw", <br>                   MB_APPLMODAL|MB_ICONEXCLAMATION); <br>        } <br>    else { <br>        pdtRet-&gt;p = p; <br>        pdtRet-&gt;rDraw = *rDraw; <br>        pdtRet-&gt;rClip = *rClip; <br>        pdtRet-&gt;iRelx = iRelx; <br>        pdtRet-&gt;iRely = iRely; <br>        pdtRet-&gt;next = next; <br>        } <br> <br>    return(pdtRet); <br>} <br> <br> <br>/*===================================================================== <br>Function: DelPlayerDraw() <br> <br>Inputs: Pointer to PlayerDrawType record to delete <br> <br>Outputs: Pointer to -&gt;next field value of deleted record <br> <br>Abstract: <br>    returns the -&gt;next field for linked list maintenance <br>======================================================================*/ <br> <br>PlayerDrawType FAR *DelPlayerDraw( <br>    PlayerDrawType FAR *pdtP <br>    ) <br>{ <br>    PlayerDrawType FAR *pdtRet; <br>    HGLOBAL hMem; <br> <br>    pdtRet = NULL; <br>    if (pdtP != NULL) { <br>        pdtRet = pdtP-&gt;next; <br>        hMem = (HGLOBAL) GlobalHandle(SELECTOROF(pdtP)); <br>        GlobalFree(hMem); <br>        } <br> <br>    return(pdtRet); <br>} <br> <br> <br>/*===================================================================== <br>Function: CheckForPlayers() <br> <br>Inputs: List of players, holes in view, positions to check <br> <br>Outputs: <br> <br>Abstract: <br>    This routine checks for players on a single square, given the relative <br>    and absolute coordinates of that square. If a player IS on that square, <br>    then we check the hole we're looking through to see if any of the <br>    destination rectangle is visible. If it is, we make a note of the player <br>    by adding them to the pdtTD = 'Players To Draw' list. <br>======================================================================*/ <br> <br>void CheckForPlayers( <br>    PlayerDrawType FAR *pdtTD, <br>    PlayerType FAR *ptObj, <br>    HoleType FAR *htHole, <br>    int iRelx, <br>    int iRely, <br>    int iAbsx, <br>    int iAbsy <br>    ) <br>{ <br>    PlayerType FAR *ptTrav; <br>    RECT rDraw,rClip; <br>    float x,y,z; <br>    int xSize,ySize; <br>    POINT pCenter; <br> <br>    if (htHole == NULL) { <br>        return; <br>        } <br> <br>    GetClientRect(hWndMaze,&amp;rMaze); <br> <br>    pCenter.x = rMaze.left + (rMaze.right-rMaze.left)/2; <br>    pCenter.y = rMaze.top + (rMaze.bottom-rMaze.top)/2; <br> <br>    // <br>    // Set x/y/z to screen coordinate upper left corner of panel <br>    // <br>    x = (float) ((iRelx*PANEL_WIDTH) - PANEL_WIDTH/2); <br>    y = (float) (-PANEL_HEIGHT/2); <br>#if ( _ALPHA_ == 1 ) <br>    z = (float) iRely*PANEL_WIDTH - (PANEL_WIDTH/2); <br>#else <br>    z = (float) (iRely-1)*PANEL_WIDTH; <br>#endif <br> <br>    // <br>    // Calculate the physical width and depth of a panel placed at the bitmap <br>    // location, since this is the maximum possible size for a player bitmap. <br>    // PIC_X and PIC_Y are the pixel values for this. <br>    // <br>    xSize = (int) MC_TO_SC(PIC_X,z); <br>    ySize = (int) MC_TO_SC(PIC_Y,z); <br> <br>    // <br>    // Calculate the physical rectangle to contain the player bitmap <br>    // <br>    rDraw.left = pCenter.x + (int) MC_TO_SC(x,z); <br>    rDraw.top  = pCenter.y + (int) MC_TO_SC(y,z); <br>    rDraw.right = rDraw.left + xSize-1; <br>    rDraw.bottom = rDraw.top + ySize-1; <br> <br>    // <br>    // Set the clipping rectangle to the visible screen <br>    // <br>    rClip.left = GREATEROF(rDraw.left,0); <br>    rClip.top = GREATEROF(rDraw.top,0); <br>    rClip.right = LESSEROF(rDraw.right,rMaze.right); <br>    rClip.bottom = LESSEROF(rDraw.bottom,rMaze.bottom); <br> <br>    // <br>    // Adjust the clipping rectangle's left and right by the hole <br>    // which we're constrained by (Holes are horizontal coordinates only) <br>    // <br>    if (htHole != (HoleType FAR *) -1) { <br>        rClip.left = GREATEROF(rClip.left,htHole-&gt;x[0]); <br>        rClip.right = LESSEROF(rClip.right,htHole-&gt;x[1]); <br>        } <br> <br>    // <br>    // If The whole picture is clipped, don't bother drawing it. <br>    // <br>    if (rClip.left &gt;= rClip.right) { <br>        return; <br>        } <br> <br>    ptTrav=ptObj; <br>    while (ptTrav-&gt;next != NULL) { <br>        ptTrav = ptTrav-&gt;next; <br>        if ((ptTrav-&gt;Pos.ix == iAbsx)&amp;&amp;(ptTrav-&gt;Pos.iy == iAbsy)) { <br>            // <br>            // We need to adjust the drawing coordinates according to this <br>            // player's picture. <br>            // <br>            pdtTD-&gt;next = NewPlayerDraw(ptTrav,&amp;rDraw,&amp;rClip,iRelx,iRely,pdtTD-&gt;next); <br>            } <br>        } <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: DrawFoundPlayers() <br> <br>Inputs: List of players <br> <br>Outputs: modifies rBounds to contain rectangle saying where player is. <br> <br>Abstract: <br>    BUGBUG -- needs abstract <br>======================================================================*/ <br> <br>void DrawFoundPlayers( <br>    HDC hDC, <br>    PlayerDrawType FAR *pdtTrav, <br>    LPRECT rBounds <br>    ) <br>{ <br>    BYTE dBackward,b1,b2; <br> <br>    dBackward = BACK_TO_ABS(ptSelf.Pos.Facing); <br> <br>    while (pdtTrav-&gt;next != NULL) { <br>        b1 = BACK; <br>        b2 = ptSelf.Pos.Facing; <br>        while (b2 != pdtTrav-&gt;next-&gt;p-&gt;Pos.Facing) { <br>            b1 = (BYTE) ((b1+1)%4); <br>            b2 = RIGHT_TO_ABS(b2); <br>            } <br> <br>        pdtTrav-&gt;next-&gt;p-&gt;rDrawn = pdtTrav-&gt;next-&gt;rDraw; <br>        if (rBounds != NULL) { <br>            rBounds-&gt;left = LESSEROF(rBounds-&gt;left, <br>                               GREATEROF(pdtTrav-&gt;next-&gt;rDraw.left, <br>                                         pdtTrav-&gt;next-&gt;rClip.left)); <br>            rBounds-&gt;top = LESSEROF(rBounds-&gt;top, <br>                               GREATEROF(pdtTrav-&gt;next-&gt;rDraw.top, <br>                                         pdtTrav-&gt;next-&gt;rClip.top)); <br>            rBounds-&gt;right = GREATEROF(rBounds-&gt;right, <br>                               LESSEROF(pdtTrav-&gt;next-&gt;rDraw.right, <br>                                         pdtTrav-&gt;next-&gt;rClip.right)); <br>            rBounds-&gt;bottom = GREATEROF(rBounds-&gt;bottom, <br>                               LESSEROF(pdtTrav-&gt;next-&gt;rDraw.bottom, <br>                                         pdtTrav-&gt;next-&gt;rClip.bottom)); <br>            } <br> <br>        DrawClippedPic(pdtTrav-&gt;next-&gt;p-&gt;iPicNum,b1,hDC, <br>                       &amp;pdtTrav-&gt;next-&gt;p-&gt;rDrawn, <br>                       &amp;pdtTrav-&gt;next-&gt;rClip, <br>                       &amp;pdtTrav-&gt;next-&gt;p-&gt;rFrom, <br>                       pdtTrav-&gt;next-&gt;iRelx, <br>                       pdtTrav-&gt;next-&gt;iRely); <br>        pdtTrav-&gt;next-&gt;p-&gt;Drawn = TRUE; <br>        pdtTrav-&gt;next-&gt;p-&gt;rDrawn.right++; <br>        pdtTrav-&gt;next-&gt;p-&gt;rDrawn.bottom++; <br> <br>        pdtTrav-&gt;next = DelPlayerDraw(pdtTrav-&gt;next); <br>        } <br> <br>    return; <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: DrawMaze() <br> <br>Inputs: DC, rectangle that needs to be redrawn <br> <br>Outputs: none <br> <br>Abstract: <br>    This entrypoint takes care of drawing the 3-d maze. It loops from <br>    front to back, inside to outside, Checking for panels. It keeps a list <br>    of all the 'holes' in panels in terms of physical coordinates. For <br>    instance, if I've found the wall in front of me, but no others, and <br>    I can see to the left and to the right of the wall, I would have two <br>    holes in my hole-list. The first would be from the left of the view <br>    window to the left side of the wall, and the second would be from the <br>    right side of the wall to the right side of the view window. <br>======================================================================*/ <br> <br>void DrawMaze(HDC hDC,LPRECT rUpd) <br>{ <br>    int i,j,tx,ty,iEndl,iEndr; <br>    BYTE dLeft,dRight,dForward,dBackward,b1,b2,b3; <br>    HoleType htLeft,htRight,FAR *htTrav, FAR *htHold; <br>    BOOL bFound; <br>    PlayerDrawType pdtToDraw; <br>    HBRUSH hOldBrush,hWhiteBrush; <br>    HPEN hOldPen,hWhitePen,hBlackPen; <br>    HGLOBAL hMem; <br> <br>    if ((rUpd-&gt;left &gt;= rUpd-&gt;right)||(rUpd-&gt;top &gt;= rUpd-&gt;bottom)) { <br>        return; <br>        } <br> <br>    hMem = GlobalAlloc(GHND,10000*sizeof(POINT)); <br>    pDraw = (LPPOINT) GlobalLock(hMem); <br>    hMem = GlobalAlloc(GHND,10000*sizeof(BYTE)); <br>    pType = (LPBYTE) GlobalLock(hMem); <br> <br>    GetClientRect(hWndMaze,&amp;rMaze); <br>    pdtToDraw.next = NULL; <br> <br>    // <br>    // Clear out the space to be drawn into <br>    // <br>    hWhiteBrush = GetStockObject(WHITE_BRUSH); <br>    hWhitePen = GetStockObject(WHITE_PEN); <br>    hBlackPen = GetStockObject(BLACK_PEN); <br>    hOldBrush = SelectObject(hDC,hWhiteBrush); <br>    hOldPen = SelectObject(hDC,hWhitePen); <br> <br>    PointCount = 0; <br> <br>    dForward = ptSelf.Pos.Facing; <br>    dBackward = BACK_TO_ABS(ptSelf.Pos.Facing); <br>    dLeft = LEFT_TO_ABS(ptSelf.Pos.Facing); <br>    dRight = RIGHT_TO_ABS(ptSelf.Pos.Facing); <br> <br>    tx = ptSelf.Pos.ix; <br>    ty = ptSelf.Pos.iy; <br> <br>    Rectangle(hDC,rUpd-&gt;left,rUpd-&gt;top,rUpd-&gt;right,rUpd-&gt;bottom); <br> <br>    SelectObject(hDC,hOldBrush); <br>    SelectObject(hDC,hBlackPen); <br> <br>    // <br>    // Find the End which lies straight before us, else default <br>    // it to MAX_DRAW_DIST. <br>    // <br>    b2 = bMaze[tx][ty]; <br>    bFound = FALSE; <br>    for(j=0,ViewEnd=MAX_DRAW_DIST-1;j&lt;MAX_DRAW_DIST;j++) { <br>        b1 = b2; <br>        tx = ADJ_X(tx,ptSelf.Pos.Facing); <br>        ty = ADJ_Y(ty,ptSelf.Pos.Facing); <br>        b2 = bMaze[tx][ty]; <br>        if ((b1&amp;dForward)||(b2&amp;dBackward)) { <br>            ViewEnd = j; <br>            bFound = TRUE; <br>            break; <br>            } <br>        } <br> <br>    PointCount = 0; <br>    iEndl = iEndr = (rMaze.right - rMaze.left) / 2; <br> <br>    // <br>    // Draw the end rectangle. <br>    // <br>    if (bFound) { <br>        // <br>        // Only bother with the draw if the end is to be updated <br>        // <br>        iEndl = pPost[MAX_DRAW_DIST+1][ViewEnd+1][0].x; <br>        iEndr = pPost[MAX_DRAW_DIST+2][ViewEnd+1][0].x; <br> <br>        // <br>        // Left Post <br>        // <br>        pDraw[0].x = pPost[MAX_DRAW_DIST+1][ViewEnd+1][0].x; <br>        pDraw[0].y = pPost[MAX_DRAW_DIST+1][ViewEnd+1][0].y; <br>        pType[0] = PT_MOVETO; <br>        pDraw[1].x = pPost[MAX_DRAW_DIST+1][ViewEnd+1][1].x; <br>        pDraw[1].y = pPost[MAX_DRAW_DIST+1][ViewEnd+1][1].y; <br>        pType[1] = PT_LINETO; <br> <br>        // <br>        // Right Post <br>        // <br>        pDraw[2].x = pPost[MAX_DRAW_DIST+2][ViewEnd+1][1].x; <br>        pDraw[2].y = pPost[MAX_DRAW_DIST+2][ViewEnd+1][1].y; <br>        pType[2] = PT_LINETO; <br>        pDraw[3].x = pPost[MAX_DRAW_DIST+2][ViewEnd+1][0].x; <br>        pDraw[3].y = pPost[MAX_DRAW_DIST+2][ViewEnd+1][0].y; <br>        pType[3] = PT_LINETO; <br>        pDraw[4].x = pPost[MAX_DRAW_DIST+1][ViewEnd+1][0].x; <br>        pDraw[4].y = pPost[MAX_DRAW_DIST+1][ViewEnd+1][0].y; <br>        pType[4] = PT_LINETO; <br>        PointCount = 5; <br>        } <br> <br>    // <br>    // Make LeftHoles and RightHoles accordingly <br>    // <br>    htLeft.next = NewHole(0,iEndl,NULL); <br>    htRight.next = NewHole(iEndr,rMaze.right-rMaze.left,NULL); <br> <br>    // <br>    // For the left side, loop from front to back, right to <br>    // left, checking the rEAST and rNORTH walls, in that <br>    // order. Eventually we'll need to put the check for players <br>    // in between the two. As a wall is found, draw it. <br>    // <br> <br>    // <br>    // j is the relative y-offset into the maze. <br>    // <br>    for(j=0;j&lt;MAX_DRAW_DIST;j++) { <br>        // <br>        // Check for players/drones directly in front of us, <br>        // make note of them to draw them later. <br>        // <br>        if (j &lt; ViewEnd+1) { <br>            CheckForPlayers(&amp;pdtToDraw,&amp;ptPlayers,(HoleType FAR *) -1,0,j, <br>                      ptSelf.Pos.ix + ABS2OFFX(0,j,dForward), <br>                      ptSelf.Pos.iy + ABS2OFFY(0,j,dForward)); <br>            CheckForPlayers(&amp;pdtToDraw,&amp;ptDrones,(HoleType FAR *) -1,0,j, <br>                      ptSelf.Pos.ix + ABS2OFFX(0,j,dForward), <br>                      ptSelf.Pos.iy + ABS2OFFY(0,j,dForward)); <br>            } <br> <br>        // <br>        // b1 is the square we're in, b2 the square we want to <br>        // see if there's a wall EAST/WEST between. b3 is the <br>        // square we want to see if there is a NORTH/SOUTH wall <br>        // from b2 to.  Then we move to b2 and try it again. <br>        // <br>        htTrav=&amp;htLeft; <br> <br>        while((htTrav != (HoleType FAR *) NULL)&amp;&amp;(htTrav-&gt;next != (HoleType FAR *)NULL)) { <br>            // i will loop from the 0th relative column to the far left. <br>            // This will be done for each and every hole, or even some <br>            // holes more than once, depending upon how they are filled. <br>            // set (tx,ty) to spot in our x-pos with relative y j. <br>            tx = ptSelf.Pos.ix + ABS2OFFX(0,j,dForward); <br>            ty = ptSelf.Pos.iy + ABS2OFFY(0,j,dForward); <br>            b2 = bMaze[tx][ty]; <br> <br>            htHold = htTrav-&gt;next; <br>            for (i=0;(i&gt;= -MAX_DRAW_DIST)&amp;&amp;(htTrav != (HoleType FAR *)NULL)&amp;&amp;(htTrav-&gt;next != (HoleType FAR *)NULL);i--) { <br>                // <br>                // if we're not in the hole yet, continue <br>                // <br>                if (htTrav-&gt;next-&gt;x[1] &lt; pPost[MAX_DRAW_DIST+i][j+1][0].x) { <br>                   continue; <br>                   } <br> <br>                // <br>                // if we're past the outside of the hole, go to next hole. <br>                // <br>                if (htTrav-&gt;next-&gt;x[0] &gt; pPost[MAX_DRAW_DIST+1+i][j+1][0].x) { <br>                    break; <br>                    } <br> <br>                // <br>                // b1, b2, and b3 correspond to the square to the inside of the one <br>                // we're checking, the square we're checking, and the square <br>                // forward past the square we're checking. <br>                // <br>                b1 = b2; <br> <br>                // <br>                // set (tx,ty) one square to the 'left'. <br>                // <br>                tx = ADJ_X(tx,dLeft); <br>                ty = ADJ_Y(ty,dLeft); <br> <br>                b2 = bMaze[tx][ty]; <br> <br>                b3 = bMaze[ADJ_X(tx,dForward)][ADJ_Y(ty,dForward)]; <br> <br>                if ((b1&amp;dLeft)||(b2&amp;dRight)) { <br>                    htTrav = DrawRect(htTrav,i,j,WEST); <br>                    } <br> <br>                CheckForPlayers(&amp;pdtToDraw,&amp;ptPlayers,htTrav-&gt;next,i-1,j,tx,ty); <br>                CheckForPlayers(&amp;pdtToDraw,&amp;ptDrones,htTrav-&gt;next,i-1,j,tx,ty); <br> <br>                if ((b2&amp;dForward)||(b3&amp;dBackward)) { <br>                    htTrav = DrawRect(htTrav,i-1,j,NORTH); <br>                    } <br>                } <br> <br>            if ((htTrav!= (HoleType FAR *)NULL)&amp;&amp;(htHold == htTrav-&gt;next)) { <br>                htTrav = htTrav-&gt;next; <br>                } <br>            } <br>         } <br> <br>    // <br>    // Same as above, except this time for the RIGHT side. <br>    // <br>    for(j=0;j&lt;MAX_DRAW_DIST;j++) { <br>        htTrav=&amp;htRight; <br> <br>        while((htTrav != (HoleType FAR *)NULL)&amp;&amp;(htTrav-&gt;next != (HoleType FAR *)NULL)) { <br>            tx = ptSelf.Pos.ix + ABS2OFFX(0,j,dForward); <br>            ty = ptSelf.Pos.iy + ABS2OFFY(0,j,dForward); <br> <br>            b2 = bMaze[tx][ty]; <br> <br>            htHold = htTrav-&gt;next; <br>            for (i=0;(i&lt;MAX_DRAW_DIST)&amp;&amp;(htTrav != (HoleType FAR *)NULL)&amp;&amp;(htTrav-&gt;next != (HoleType FAR *)NULL);i++) { <br>                // <br>                // if we're before the hole, continue <br>                // <br>                if (htTrav-&gt;next-&gt;x[0] &gt; pPost[MAX_DRAW_DIST+i+3][j+1][0].x) { <br>                    continue; <br>                    } <br> <br>                // <br>                // if we're outside the hole, go to next hole. <br>                // <br>                if (htTrav-&gt;next-&gt;x[1] &lt; pPost[MAX_DRAW_DIST+i+2][j+1][0].x) { <br>                    break; <br>                    } <br> <br>                b1 = b2; <br> <br>                // <br>                // set (tx,ty) one square to the 'right'. <br>                // <br>                tx = ADJ_X(tx,dRight); <br>                ty = ADJ_Y(ty,dRight); <br> <br>                b2 = bMaze[tx][ty]; <br> <br>                b3 = bMaze[ADJ_X(tx,dForward)][ADJ_Y(ty,dForward)]; <br> <br>                if ((b1&amp;dRight)||(b2&amp;dLeft)) { <br>                    htTrav = DrawRect(htTrav,i,j,EAST); <br>                    } <br> <br>                CheckForPlayers(&amp;pdtToDraw,&amp;ptPlayers,htTrav-&gt;next,i+1,j,tx,ty); <br>                CheckForPlayers(&amp;pdtToDraw,&amp;ptDrones,htTrav-&gt;next,i+1,j,tx,ty); <br> <br> <br>                if ((b2&amp;dForward)||(b3&amp;dBackward)) { <br>                    htTrav = DrawRect(htTrav,i+1,j,NORTH); <br>                    } <br>                } <br> <br>            if ((htTrav != (HoleType FAR *)NULL)&amp;&amp;(htHold == htTrav-&gt;next)) { <br>                htTrav = htTrav-&gt;next; <br>                } <br>            } <br>        } <br> <br> <br>    // <br>    // Draw the maze itself <br>    // <br> <br>    PolyDraw95(hDC,pDraw,pType,PointCount); <br> <br>    // <br>    // We were looking for players as we went along. Draw all the ones we <br>    // found <br>    // <br>    DrawFoundPlayers(hDC,&amp;pdtToDraw,rUpd); <br> <br>    // <br>    // Clean up. <br>    // <br> <br>    htTrav = &amp;htLeft; <br>    while (htTrav-&gt;next != NULL) { <br>        htTrav-&gt;next = DelHole(htTrav-&gt;next); <br>    } <br> <br>    htTrav = &amp;htRight; <br>    while (htTrav-&gt;next != NULL) { <br>        htTrav-&gt;next = DelHole(htTrav-&gt;next); <br>    } <br> <br> <br> <br>    DeleteObject(hWhiteBrush); <br>    DeleteObject(hWhitePen); <br>    DeleteObject(hBlackPen); <br>    hMem = (HGLOBAL) GlobalHandle(SELECTOROF(pType)); <br>    GlobalUnlock(hMem); <br>    GlobalFree(hMem); <br>    hMem = (HGLOBAL) GlobalHandle(SELECTOROF(pDraw)); <br>    GlobalUnlock(hMem); <br>    GlobalFree(hMem); <br>    SelectObject(hDC,hOldPen); <br> <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: DrawTopView() <br> <br>Inputs: DC, whether or not it's a total redraw <br> <br>Outputs: none <br> <br>Abstract: <br>    This routine takes care of the top maze view window. It draws white <br>    lines over black and vice versa to get the window drawn in the shortest <br>    possible time. A triangle is drawn in the middle of the window to <br>    represent the player and his current facing. <br>======================================================================*/ <br>void DrawTopView( <br>    HDC hDC, <br>    BOOL bRedraw <br>    ) <br>{ <br>    int i,j,Step; <br>// <br>//BUGBUG -- these can be fixed after we have square pens <br>// <br>    // POINT p[5*5*4*2+5]; <br>    // BYTE bType[5*5*4*2+5]; <br>    LPPOINT p; <br>    //[3*5*5*4*2+5]; <br>    LPBYTE bType; <br>    //[3*5*5*4*2+5]; <br>    int cPoint,iPenWidth; <br>    int x,y; <br>    HPEN hBlackPen,hWhitePen,hPenOld; <br>    HGLOBAL hPMem,hBMem; <br> <br>    hPMem = GlobalAlloc(GHND,(3*5*5*4*2 + 5)*sizeof(POINT)); </code></pre>
<p>
</p>
<pre><code>p = (LPPOINT) GlobalLock(hPMem); <br>    hBMem = GlobalAlloc(GHND,(3*5*5*4*2 + 5)*sizeof(BYTE)); <br>    bType = (LPBYTE) GlobalLock(hBMem); <br> <br>    cPoint = 0; <br> <br>    Step = (rTopView.right - rTopView.left)/5; <br> <br>    iPenWidth = Step/10+1; <br>    hBlackPen = CreatePen(PS_SOLID,iPenWidth,0); <br> <br>    hWhitePen = CreatePen(PS_SOLID,iPenWidth,0x00FFFFFF); <br> <br>    // <br>    // First, we need to draw black lines for all the missing lines in <br>    // the current map <br>    // <br>    hPenOld = SelectObject(hDC,hBlackPen); <br> <br>    for (i =-3;i&lt;=2; i++) { <br>        for (j= -3; j&lt;=2; j++) { <br>            if (bRedraw || <br>                (!((bMaze[ptLastPos.ix + i][ptLastPos.iy + j]&amp;SOUTH)|| <br>                (bMaze[ptLastPos.ix + i][ptLastPos.iy + j+1]&amp;NORTH))) <br>               ) { <br> <br>                if ((bMaze[ptSelf.Pos.ix + i][ptSelf.Pos.iy + j]&amp;SOUTH)|| <br>                    (bMaze[ptSelf.Pos.ix + i][ptSelf.Pos.iy + j+1]&amp;NORTH) <br>                   ) { <br> <br>                    p[cPoint].x = (i+2)*Step; <br>                    p[cPoint].y = (j+3)*Step; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+3)*Step; <br>                    p[cPoint].y = (j+3)*Step; <br>                    bType[cPoint++] = PT_LINETO; <br>                    } <br>                } <br>            if (bRedraw || <br>                (!((bMaze[ptLastPos.ix + i][ptLastPos.iy + j]&amp;EAST)|| <br>                 (bMaze[ptLastPos.ix + i+1][ptLastPos.iy + j]&amp;WEST))) <br>               ) { <br> <br>                if ((bMaze[ptSelf.Pos.ix + i][ptSelf.Pos.iy + j]&amp;EAST)|| <br>                    (bMaze[ptSelf.Pos.ix + i+1][ptSelf.Pos.iy + j]&amp;WEST) <br>                   ) { <br> <br>                    p[cPoint].x = (i+3)*Step; <br>                    p[cPoint].y = (j+2)*Step; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+3)*Step; <br>                    p[cPoint].y = (j+3)*Step; <br>                    bType[cPoint++] = PT_LINETO; <br>                    } <br>                } <br>            } <br>        } <br> <br>    PolyDraw95(hDC,p,bType,cPoint); <br> <br>    // <br>    // next, we draw white lines over BLACK lines drawn but no longer <br>    // needed. <br>    // <br>    SelectObject(hDC,hWhitePen); <br>    cPoint = 0; <br> <br>    for (i =-3;i&lt;=2; i++) { <br>        for (j= -3; j&lt;=2; j++) { <br>            if ((!bRedraw) &amp;&amp; <br>               ((bMaze[ptLastPos.ix + i][ptLastPos.iy + j]&amp;SOUTH)|| <br>               (bMaze[ptLastPos.ix + i][ptLastPos.iy + j+1]&amp;NORTH)) <br>              ) { <br> <br>                if (!((bMaze[ptSelf.Pos.ix + i][ptSelf.Pos.iy + j]&amp;SOUTH)|| <br>                   (bMaze[ptSelf.Pos.ix + i][ptSelf.Pos.iy + j+1]&amp;NORTH)) <br>                  ) { <br> <br>                    p[cPoint].x = (i+2)*Step+iPenWidth; <br>                    p[cPoint].y = (j+3)*Step; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+3)*Step-iPenWidth; <br>                    p[cPoint].y = (j+3)*Step; <br>                    bType[cPoint++] = PT_LINETO; <br>                    // <br>                    // We also need to kludge to clean up until we get a square pen. <br>                    // <br>                    p[cPoint].x = (i+2)*Step+iPenWidth; <br>                    p[cPoint].y = (j+3)*Step-iPenWidth; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+2)*Step+iPenWidth; <br>                    p[cPoint].y = (j+3)*Step+iPenWidth; <br>                    bType[cPoint++] = PT_LINETO; <br>                    p[cPoint].x = (i+3)*Step-iPenWidth; <br>                    p[cPoint].y = (j+3)*Step-iPenWidth; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+3)*Step-iPenWidth; <br>                    p[cPoint].y = (j+3)*Step+iPenWidth; <br>                    bType[cPoint++] = PT_LINETO; <br>                    // <br>                    // End kludge BUGBUG <br>                    // <br>                    } <br>                } <br>            if ((!bRedraw) &amp;&amp; <br>                ((bMaze[ptLastPos.ix + i][ptLastPos.iy + j]&amp;EAST)|| <br>                (bMaze[ptLastPos.ix + i+1][ptLastPos.iy + j]&amp;WEST)) <br>               ) { <br> <br>                if (!((bMaze[ptSelf.Pos.ix + i][ptSelf.Pos.iy + j]&amp;EAST)|| <br>                    (bMaze[ptSelf.Pos.ix + i+1][ptSelf.Pos.iy + j]&amp;WEST)) <br>                   ) { <br> <br>                    p[cPoint].x = (i+3)*Step; <br>                    p[cPoint].y = (j+2)*Step+iPenWidth; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+3)*Step; <br>                    p[cPoint].y = (j+3)*Step-iPenWidth; <br>                    bType[cPoint++] = PT_LINETO; <br>                    // <br>                    // We also need to kludge to clean up until we get a square pen. <br>                    // <br>                    p[cPoint].x = (i+3)*Step-iPenWidth; <br>                    p[cPoint].y = (j+2)*Step+iPenWidth; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+3)*Step+iPenWidth; <br>                    p[cPoint].y = (j+2)*Step+iPenWidth; <br>                    bType[cPoint++] = PT_LINETO; <br>                    p[cPoint].x = (i+3)*Step-iPenWidth; <br>                    p[cPoint].y = (j+3)*Step-iPenWidth; <br>                    bType[cPoint++] = PT_MOVETO; <br>                    p[cPoint].x = (i+3)*Step+iPenWidth; <br>                    p[cPoint].y = (j+3)*Step-iPenWidth; <br>                    bType[cPoint++] = PT_LINETO; <br>                    // <br>                    // End kludge BUGBUG <br>                    // <br>                    } <br>                } <br>            }; <br>        } <br> <br>    PolyDraw95(hDC,p,bType,cPoint); <br> <br> <br> <br>    SelectObject(hDC,hPenOld); <br>    DeleteObject(hBlackPen); <br>    DeleteObject(hWhitePen); <br> <br>    // <br>    // And drawn an arrow for our ptSelf.Pos.Facing <br>    // <br>    x = y = (Step * 10) / 4;    // the center <br>    Step /= 4; <br> <br>    if (ptLastPos.Facing != ptSelf.Pos.Facing) { <br>        if (hWhitePen != NULL) { <br>            DeleteObject(hWhitePen); <br>        } <br>        hWhitePen = CreatePen(PS_SOLID,1,0x00FFFFFF); <br>        hPenOld = SelectObject(hDC,hWhitePen); <br>        cPoint = 0; <br> <br>        p[cPoint].x = p[cPoint+4].x = x; <br>        p[cPoint].y = p[cPoint+4].y = y; <br>        bType[cPoint+4] = PT_LINETO; <br>        bType[cPoint++] = PT_MOVETO; <br> <br>        switch (ptLastPos.Facing) { <br>            case NORTH: <br>                p[cPoint].x = x+Step; <br>                p[cPoint].y = y; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x; <br>                p[cPoint].y = y-Step; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x-Step; <br>                p[cPoint].y = y; <br>                bType[cPoint++] = PT_LINETO; <br>                break; <br>            case SOUTH: <br>                p[cPoint].x = x+Step; <br>                p[cPoint].y = y; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x; <br>                p[cPoint].y = y+Step; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x-Step; <br>                p[cPoint].y = y; <br>                bType[cPoint++] = PT_LINETO; <br>                break; <br>            case EAST: <br>                p[cPoint].x = x; <br>                p[cPoint].y = y+Step; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x+Step; <br>                p[cPoint].y = y; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x; <br>                p[cPoint].y = y-Step; <br>                bType[cPoint++] = PT_LINETO; <br>                break; <br>            case WEST: <br>                p[cPoint].x = x; <br>                p[cPoint].y = y+Step; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x-Step; <br>                p[cPoint].y = y; <br>                bType[cPoint++] = PT_LINETO; <br>                p[cPoint].x = x; <br>                p[cPoint].y = y-Step; <br>                bType[cPoint++] = PT_LINETO; <br>                break; <br>            } <br> <br>        cPoint++; <br>        PolyDraw95(hDC,p,bType,cPoint); <br>        SelectObject(hDC,hPenOld); <br>        DeleteObject(hWhitePen); <br>        } <br> <br>    cPoint = 0; <br> <br>    p[cPoint].x = p[cPoint+4].x = x; <br>    p[cPoint].y = p[cPoint+4].y = y; <br>    bType[cPoint+4] = PT_LINETO; <br>    bType[cPoint++] = PT_MOVETO; <br> <br> <br>    switch (ptSelf.Pos.Facing) { <br>        case NORTH: <br>            p[cPoint].x = x+Step; <br>            p[cPoint].y = y; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x; <br>            p[cPoint].y = y-Step; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x-Step; <br>            p[cPoint].y = y; <br>            bType[cPoint++] = PT_LINETO; <br>            break; <br>        case SOUTH: <br>            p[cPoint].x = x+Step; <br>            p[cPoint].y = y; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x; <br>            p[cPoint].y = y+Step; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x-Step; <br>            p[cPoint].y = y; <br>            bType[cPoint++] = PT_LINETO; <br>            break; <br>        case EAST: <br>            p[cPoint].x = x; <br>            p[cPoint].y = y+Step; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x+Step; <br>            p[cPoint].y = y; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x; <br>            p[cPoint].y = y-Step; <br>            bType[cPoint++] = PT_LINETO; <br>            break; <br>        case WEST: <br>            p[cPoint].x = x; <br>            p[cPoint].y = y+Step; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x-Step; <br>            p[cPoint].y = y; <br>            bType[cPoint++] = PT_LINETO; <br>            p[cPoint].x = x; <br>            p[cPoint].y = y-Step; <br>            bType[cPoint++] = PT_LINETO; <br>            break; <br>        } <br> <br>    cPoint++; <br>    PolyDraw95(hDC,p,bType,cPoint); <br> <br>    GlobalUnlock(hBMem); <br>    GlobalUnlock(hPMem); <br>    GlobalFree(hBMem); <br>    GlobalFree(hPMem); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: DrawPlayers() <br> <br>Inputs: DC, pointer to list of players, rectangle being updated on scrn <br> <br>Outputs: none <br> <br>Abstract: <br>    BUGBUG -- make an abstract for this. <br>======================================================================*/ <br> <br>void DrawPlayers( <br>    HDC hDC, <br>    PlayerType FAR *ptPlyr, <br>    LPRECT rUpd <br>    ) <br>{ <br>    LPRECT rHld; <br>    PlayerType FAR *ptTrav; <br>    HGLOBAL hMem; <br> <br>    if (rUpd == NULL) { <br>        hMem = GlobalAlloc(GHND,sizeof(RECT)); <br>        rHld = (LPRECT) GlobalLock(hMem); <br>        if (rHld == NULL) { <br>            MessageBox((HWND) NULL,GetStringRes(IDS_RECTALLOCFAIL),"DrawPlayers",MB_APPLMODAL); <br>            } <br>/****** <br>        rHld-&gt;right = rMaze.left; <br>        rHld-&gt;left = rMaze.right; <br>        rHld-&gt;top = rMaze.bottom; <br>        rHld-&gt;bottom = rMaze.top; <br>******/ <br>*rHld = rMaze; <br>        } <br>    else { <br>        rHld = rUpd; <br>        } <br> <br> <br>    ptTrav = ptPlyr; <br>    while (ptTrav-&gt;next != NULL) { <br>        ptTrav = ptTrav-&gt;next; <br>        if (ptTrav-&gt;Drawn) { <br>            rHld-&gt;left = LESSEROF(rHld-&gt;left,ptTrav-&gt;rDrawn.left); <br>            rHld-&gt;right = GREATEROF(rHld-&gt;right,ptTrav-&gt;rDrawn.right); <br>            rHld-&gt;top = LESSEROF(rHld-&gt;top,ptTrav-&gt;rDrawn.top); <br>            rHld-&gt;bottom = GREATEROF(rHld-&gt;bottom,ptTrav-&gt;rDrawn.bottom); <br>            } <br>        } <br> <br>    PostMessage(hWndMaze,WM_COMMAND,IDM_REDRAW,(DWORD) rHld); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
