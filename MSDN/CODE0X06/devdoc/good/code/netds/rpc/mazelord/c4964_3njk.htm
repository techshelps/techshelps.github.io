<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAZEDLG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4970"></a>MAZEDLG.C</h2>
<pre><code>/*********************************************************************** <br>File:   MazeDlg.c <br> <br> <br>Abstract: <br> <br>    This module contains dialog boxes for Maze Lords. <br> <br> <br>Contents: <br> <br>    DroneDlg() -- Drone Dialog Box winproc <br>    AboutDlg() -- About Box <br>    IntoneDlg() -- Dialog box for spoken messages <br>    PlayerDlg() -- Dialog box for selecting player picture/maze <br>    cwCenter() -- Center a given dialog box in the window <br> <br> <br>Revision History: <br> <br>************************************************************************/ <br> <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include "mazedlg.h" <br> <br> <br> <br>int iCurPic,iCurMaze; <br> <br> <br>/*===================================================================== <br>Function:   DroneDlg() <br> <br>Inputs:     Standard Dialog inputs <br> <br>Outputs:    Returns close status <br> <br>Abstract: <br>    This dialog box allows the user to input # of drones and their movement <br>    speed. <br>======================================================================*/ <br> <br>BOOL FAR PASCAL DroneDlg( <br>    HWND hWndDlg, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    BOOL bRet;  // holding variable only. <br>    UINT uCmdId,uCmdCmd; <br>    HWND hCmd; <br>    static INT iOldNumDrones,iOldDroneSpeed; <br>    int i; <br>    char c[132]; <br> <br> <br>    switch(Message) { <br>        case WM_INITDIALOG: <br>            cwCenter(hWndDlg, 0); <br>            iOldNumDrones = iNumDrones; <br>            iOldDroneSpeed = iDroneSpeed; <br>            SetDlgItemInt(hWndDlg,DLG_NUMDRONES,iNumDrones,TRUE); <br>            SetDlgItemInt(hWndDlg,DLG_MOVESPEED,iDroneSpeed,TRUE); <br>            break; <br> <br>        case WM_CLOSE: <br>            PostMessage(hWndDlg, WM_COMMAND, IDCANCEL, 0L); <br>            break; <br> <br>        case WM_COMMAND: <br>            uCmdId = GET_WM_COMMAND_ID(wParam,lParam); <br>            uCmdCmd = GET_WM_COMMAND_CMD(wParam,lParam); <br>            hCmd = GET_WM_COMMAND_HWND(wParam,lParam); <br>            switch(uCmdId) { <br>                case DLG_NUMDRONES: <br>                    if (uCmdCmd == EN_CHANGE) { <br>                        i = GetDlgItemInt(hWndDlg,DLG_NUMDRONES,&amp;bRet,TRUE); <br>                        if ((i &lt; 0)||(i &gt; MAX_DRONES)) { <br>                            MessageBeep(MB_ICONHAND); <br>                            sprintf(c,GetStringRes(IDS_FMT_BADNUMDRONES), <br>                                    MAX_DRONES); <br>                            MessageBox(hWndDlg,c,GetStringRes(IDS_ERRINPUT),MB_APPLMODAL|MB_ICONHAND); <br>                            SetDlgItemInt(hWndDlg,DLG_NUMDRONES,iOldNumDrones,TRUE); <br>                        } <br> <br>                    } <br>                    break; <br> <br>                case DLG_MOVESPEED: <br>                    if (uCmdCmd == EN_CHANGE) { <br>                        i = GetDlgItemInt(hWndDlg,DLG_MOVESPEED,&amp;bRet,TRUE); <br>                        if ((i &lt; 0)||(i &gt; MAX_DRONE_SPEED)) { <br>                            MessageBeep(MB_ICONHAND); <br>                            sprintf(c,GetStringRes(IDS_FMT_BADMOVESPERSEC), <br>                                    MAX_DRONE_SPEED); <br>                            MessageBox(hWndDlg,c,GetStringRes(IDS_ERRINPUT),MB_APPLMODAL|MB_ICONHAND); <br>                            SetDlgItemInt(hWndDlg,DLG_MOVESPEED,iOldDroneSpeed,TRUE); <br>                        } <br> <br>                    } <br>                    break; <br> <br>                case IDOK: <br>                    iNumDrones = GetDlgItemInt(hWndDlg,DLG_NUMDRONES,&amp;bRet,TRUE); <br>                    iDroneSpeed = GetDlgItemInt(hWndDlg,DLG_MOVESPEED,&amp;bRet,TRUE); <br>                    if ((iOldNumDrones != iNumDrones)&amp;&amp;GameStarted) { <br>                        PostMessage(hWndMaze,WM_COMMAND,IDM_REDRAW,(DWORD)NULL); <br>                        } <br> <br>                    EndDialog(hWndDlg, TRUE); <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hWndDlg, FALSE); <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br> <br>    return(TRUE); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:   AboutDlg() <br> <br>Inputs:     Standard Dialog box parms <br> <br>Outputs:    Returns close status <br> <br>Abstract: <br>    This procedure displays the About dialog box. <br>======================================================================*/ <br> <br>BOOL FAR PASCAL AboutDlg( <br>    HWND hWndDlg, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    UINT uCmdId,uCmdCmd; <br>    HWND hCmd; <br> <br>    switch(Message) { <br> <br>        case WM_INITDIALOG: <br>            cwCenter(hWndDlg, 0); <br>            break; <br> <br>        case WM_CLOSE: <br>            PostMessage(hWndDlg, WM_COMMAND, IDCANCEL, 0L); <br>            break; <br> <br>        case WM_COMMAND: <br>            uCmdId = GET_WM_COMMAND_ID(wParam,lParam); <br>            uCmdCmd = GET_WM_COMMAND_CMD(wParam,lParam); <br>            hCmd = GET_WM_COMMAND_HWND(wParam,lParam); <br>            switch(uCmdId) { <br>                case IDOK: <br>                    EndDialog(hWndDlg, TRUE); <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br> <br>    return(TRUE); <br>} <br> <br> <br>/*===================================================================== <br>Function:   IntoneDlg() <br> <br>Inputs:     Standard Dialog Box Parms <br> <br>Outputs:    Returns dialog close conditions <br> <br>Abstract: <br>    This dialog allows the user to type a message to whisper or shout. <br>    It is called by both commands, with the loudness having been set <br>    before the dialog was invoked by the method it was invoked, either <br>    whispering or shouting. <br>======================================================================*/ <br> <br>BOOL FAR PASCAL IntoneDlg( <br>    HWND hWndDlg, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    IntoneType itTemp; <br>    BOOL bScratch; <br>    UINT uCmdId; <br> <br>    switch(Message) { <br> <br>        case WM_INITDIALOG: <br>            cwCenter(hWndDlg, 0); <br>            SetDlgItemInt(hWndDlg,DLG_INT_LOUDNESS,iLoudness,TRUE); <br>            SetDlgItemText(hWndDlg,DLG_INT_SAY,""); <br>            break; <br> <br>        case WM_CLOSE: <br>            PostMessage(hWndDlg, WM_COMMAND, IDCANCEL, 0L); <br>            break; <br> <br>        case WM_COMMAND: <br>            uCmdId = GET_WM_COMMAND_ID(wParam,lParam); <br>            switch(uCmdId) { <br> <br>                case DLG_INT_LOUDNESS: <br>                    break; <br> <br>                case DLG_INT_SAY: <br>                    break; <br> <br>                case IDOK: <br>                    GetDlgItemText(hWndDlg,DLG_INT_SAY,itTemp.cBuff,131); <br>                    itTemp.dwLen=lstrlen(itTemp.cBuff); <br>                    iLoudness = GetDlgItemInt(hWndDlg,DLG_INT_LOUDNESS,&amp;bScratch,FALSE); <br>                    itTemp.iLoudness= iLoudness; <br>                    itTemp.Pos = ptSelf.Pos; <br>                    SendNetMessage(0,0,&amp;itTemp,NP_INTONE); <br>                    EndDialog(hWndDlg, TRUE); <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hWndDlg, FALSE); <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br> <br> <br>    return(TRUE); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:   PlayerDlg() <br> <br>Inputs:     Standard Dialog box parms <br> <br>Outputs:    returns dialog termination condition <br> <br>Abstract: <br>    This dialog box uses two custom list-boxes to allow the player to <br>    select options. The first contains all possible player bitmaps. The <br>    second contains all possible player sub-grids to choose from. <br>======================================================================*/ <br> <br>BOOL FAR PASCAL PlayerDlg( <br>    HWND hWndDlg, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    int i,j,k,x,y; <br>    MEASUREITEMSTRUCT FAR *miInfo; <br>    DRAWITEMSTRUCT FAR *diInfo; <br>    HDC hDC,hPicDC; <br>    FullPicType FAR *fptTrav; <br>    BOOL bFound; <br>    LPPOINT p; <br>//[5*5*5*2+2]; <br>    LPBYTE bType; <br>//[5*5*5*2+2], <br>    BYTE b; <br>    int iNumPts,Step; <br>    HGLOBAL hPMem,hBMem; <br>    float fAspect; <br> <br> <br>    switch(Message) { <br> <br>        case WM_INITDIALOG: <br>            cwCenter(hWndDlg, 0); <br> <br>            iCurPic = iCurMaze = 0; <br>            if (PIC_DRONE == 0) { <br>                iCurPic = 1; <br>                } <br>            for (i=0;i&lt;NUM_PICS;i++) { <br>                if (i != PIC_DRONE) { <br>                    AddPic(i); <br>                    SendDlgItemMessage(hWndDlg,PC_DLG_PIC,LB_ADDSTRING,0,i); <br>                    } <br>                } <br>            for (i=1;i&lt;NUM_SUBGRIDS-1;i++) { <br>                SendDlgItemMessage(hWndDlg,PC_DLG_MAZE,LB_ADDSTRING,0,i); <br>                } <br>            break; <br> <br>        case WM_MEASUREITEM: <br>            miInfo = (MEASUREITEMSTRUCT FAR *) lParam; <br>            miInfo-&gt;CtlType = ODT_LISTBOX; <br>            miInfo-&gt;itemID = 0;     // Not used <br> <br>            if (wParam == PC_DLG_PIC) { <br>                miInfo-&gt;CtlID = PC_DLG_PIC; <br>                miInfo-&gt;itemWidth = 20; <br>                miInfo-&gt;itemHeight = 45; <br>                miInfo-&gt;itemData = 0; <br>                } <br>            else { <br>                miInfo-&gt;CtlID = PC_DLG_MAZE; <br>                miInfo-&gt;itemWidth = 30; <br>                miInfo-&gt;itemHeight = 45; <br>                miInfo-&gt;itemData = 0; <br>                } <br>            break; <br> <br>        case WM_DRAWITEM: <br> <br>            diInfo = (DRAWITEMSTRUCT FAR *) lParam; <br>            hDC = diInfo-&gt;hDC; <br>            switch(diInfo-&gt;CtlID) { <br> <br>                case PC_DLG_PIC: <br>                    if (diInfo-&gt;itemAction == ODA_DRAWENTIRE) { <br>                        hPicDC = CreateCompatibleDC(hDC); <br>                        fptTrav = &amp;fptPic; <br>                        bFound = FALSE; <br>                        while (fptTrav-&gt;next != (FullPicType FAR *)NULL) { <br>                            fptTrav = fptTrav-&gt;next; <br>                            if (fptTrav-&gt;iPicNum == (int)diInfo-&gt;itemData) { <br>                                bFound = TRUE; <br>                                break; <br>                                } <br>                            } <br> <br>                        if (bFound) { <br>                            iCurPic = (int)diInfo-&gt;itemData; <br>                            SelectObject(hPicDC,fptTrav-&gt;P[1].hBitmap); <br>                            x = diInfo-&gt;rcItem.right - diInfo-&gt;rcItem.left; <br>                            y = diInfo-&gt;rcItem.bottom - diInfo-&gt;rcItem.top; <br>                            fAspect=((float) fptTrav-&gt;P[1].ySize)/ <br>                                    ((float) fptTrav-&gt;P[1].xSize); <br> <br>                            StretchBlt(hDC,diInfo-&gt;rcItem.left,diInfo-&gt;rcItem.top, <br>                                       (int) ((x &lt; (y/fAspect))? x : y/fAspect), <br>                                       (int) ((y &lt; (x*fAspect))? y : x*fAspect), <br>                                       hPicDC,0,0, <br>                                       fptTrav-&gt;P[1].xSize, <br>                                       fptTrav-&gt;P[1].ySize, <br>                                       SRCCOPY); <br>                            } <br> <br>                        DeleteDC(hPicDC); <br>                        } <br> <br>                    break; <br> <br>                case PC_DLG_MAZE: <br>                    hPMem = GlobalAlloc(GHND,(3*5*5*4*2 + 5)*sizeof(POINT)); <br>                    p = (LPPOINT) GlobalLock(hPMem); <br>                    hBMem = GlobalAlloc(GHND,(3*5*5*4*2 + 5)*sizeof(BYTE)); <br>                    bType = (LPBYTE) GlobalLock(hBMem); <br> <br>                    if (diInfo-&gt;itemAction == ODA_DRAWENTIRE) { <br>                        x = diInfo-&gt;rcItem.left; <br>                        y = diInfo-&gt;rcItem.top; <br>                        k = (int)diInfo-&gt;itemData; <br>                        iNumPts = 0; <br>                        Step = 9; <br>                        iCurMaze = (int)diInfo-&gt;itemData; <br> <br>                        for (i = 0;i&lt;5; i++) { <br>                            for (j= 0; j&lt;5; j++) { <br>                                b = SubGrids[k].Cell[i][j]; <br>                                if (b&amp;NORTH) { <br>                                    p[iNumPts].x = i*Step; <br>                                    p[iNumPts].y = j*Step; <br>                                    bType[iNumPts++] = PT_MOVETO; <br>                                    p[iNumPts].x = (i+1)*Step; <br>                                    p[iNumPts].y = j*Step; <br>                                    bType[iNumPts++] = PT_LINETO; <br>                                    } <br>                                if (b&amp;SOUTH) { <br>                                    p[iNumPts].x = i*Step; <br>                                    p[iNumPts].y = (j+1)*Step; <br>                                    bType[iNumPts++] = PT_MOVETO; <br>                                    p[iNumPts].x = (i+1)*Step; <br>                                    p[iNumPts].y = (j+1)*Step; <br>                                    bType[iNumPts++] = PT_LINETO; <br>                                    } <br>                                if (b&amp;WEST) { <br>                                    p[iNumPts].x = i*Step; <br>                                    p[iNumPts].y = j*Step; <br>                                    bType[iNumPts++] = PT_MOVETO; <br>                                    p[iNumPts].x = i*Step; <br>                                    p[iNumPts].y = (j+1)*Step; <br>                                    bType[iNumPts++] = PT_LINETO; <br>                                    } <br>                                if (b&amp;EAST) { <br>                                    p[iNumPts].x = (i+1)*Step; <br>                                    p[iNumPts].y = j*Step; <br>                                    bType[iNumPts++] = PT_MOVETO; <br>                                    p[iNumPts].x = (i+1)*Step; <br>                                    p[iNumPts].y = (j+1)*Step; <br>                                    bType[iNumPts++] = PT_LINETO; <br>                                    } <br>                                } <br>                            } <br>                        PolyDraw95(hDC,p,bType,iNumPts); <br>                        } <br> <br>                    GlobalUnlock(hBMem); <br>                    GlobalUnlock(hPMem); <br>                    GlobalFree(hBMem); <br>                    GlobalFree(hPMem); <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>//BUGBUG -- shouldn't it be hWindow,hDC??? <br>            ReleaseDC((HWND) diInfo-&gt;hDC,hDC); <br>            break; <br> <br>        case WM_CLOSE: <br>            for(i=0;i&lt;NUM_PICS;i++) { <br>                if (ptSelf.iPicNum != i) { <br>                    DelPic(i); <br>                    } <br>                } <br>            PostMessage(hWndDlg, WM_COMMAND, IDCANCEL, 0L); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(wParam) { <br>                case IDOK: <br>                    ptSelf.iGridNum = iCurMaze; <br>                    ptSelf.iPicNum = iCurPic; <br>                    EndDialog(hWndDlg, TRUE); <br>                    break; <br>                case IDCANCEL: <br>                    EndDialog(hWndDlg, FALSE); <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br> <br>    return(TRUE); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:   cwCenter() <br> <br>Inputs:     Handle to window to center, top of window <br> <br>Outputs:    none <br> <br>Abstract: <br>    Does a MoveWindow to center the window in question. <br>======================================================================*/ <br> <br>void cwCenter( <br>    HWND hWnd, <br>    int top <br>    ) <br>{ <br>    POINT    pt; <br>    RECT     swp; <br>    RECT     rParent; <br>    int      iwidth; <br>    int      iheight; <br> <br>    GetWindowRect(hWnd, &amp;swp); <br>    GetClientRect(hWndMain, &amp;rParent); <br> <br>    iwidth = swp.right - swp.left; <br>    iheight = swp.bottom - swp.top; <br> <br>    pt.x = (rParent.right - rParent.left) / 2; <br>    pt.y = (rParent.bottom - rParent.top) / 2; <br>    ClientToScreen(hWndMain, &amp;pt); <br> <br>    pt.x -= (iwidth / 2); <br>    pt.y -= (iheight / 2); <br> <br>    if (top) { <br>        pt.y += top; <br>        } <br> <br>    MoveWindow(hWnd, pt.x, pt.y, iwidth, iheight, FALSE); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
