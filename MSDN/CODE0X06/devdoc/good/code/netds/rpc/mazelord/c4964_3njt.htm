<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TEXTWND.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4979"></a>TEXTWND.C</h2>
<pre><code>/*********************************************************************** <br>File:   TextWnd.c <br> <br>Abstract: <br>    This module contains functions which deal with the Text window. This <br>    includes a function to print to said window, and scroll. <br> <br> <br> <br>Contents: <br> <br>    RefreshText() -- Redraws text in the bottom of the Text message window <br>    lstrdup() -- same as strdup() but for LPSTR's <br>    PrintTextLine() -- Prints a string to the text message window, scrolls <br>    TextWndProc() -- Windows message processing loop for text message window <br> <br> <br>************************************************************************/ <br> <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include "net.h" <br>#include &lt;mmsystem.h&gt; <br>#include &lt;string.h&gt; <br> <br> <br>#define MAX_TEXT_LINES 80 <br> <br>LPSTR cText[MAX_TEXT_LINES]; <br>TEXTMETRIC tmTextInfo; <br>int iMaxNumLines,       // Number of lines that will fit in the TextWnd display. <br>    iCurLine,           // Line # in the text display we're on. <br>    iTextLines;         // # of lines of text which are valid in cText. <br> <br> <br>/*===================================================================== <br>Function: RefreshText() <br> <br>Inputs: none <br> <br>Outputs: none <br> <br>Abstract: <br>    RefreshText() is responsible for drawing the bottom n lines of the <br>    display, however many can fit into it. This should only be called when <br>    a clipping region is in effect and has already been cleared. <br>======================================================================*/ <br> <br>void RefreshText( <br>    ) <br>{ <br>    HDC hDC; <br>    int i; <br> <br>    hDC = GetDC(hWndText); <br>    iCurLine = 0; <br>    for(i=0;i&lt;iMaxNumLines;i++) { <br>        if ((iTextLines -(iMaxNumLines-i)) &gt;= 0) { <br>            TextOut(hDC,10,iCurLine * tmTextInfo.tmHeight + 2, <br>                    cText[iTextLines-(iMaxNumLines-i)], <br>                    lstrlen(cText[iTextLines-(iMaxNumLines-i)])); <br>            iCurLine++; <br>            } <br>        } <br> <br>    ReleaseDC(hWndText,hDC); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: lstrdup() <br> <br>Inputs: String to duplicate <br> <br>Outputs:Returns a copy of the string. <br> <br>Abstract: <br>    Same as strdup, but works with LPSTR's <br>======================================================================*/ <br> <br>LPSTR lstrdup( <br>    LPSTR s <br>    ) <br>{ <br>    HGLOBAL hMem; <br>    LPSTR lpRet; <br> <br>    hMem = GlobalAlloc(GHND,lstrlen(s)+1); <br>    lpRet = GlobalLock(hMem); <br>    lstrcpy(lpRet,s); <br> <br>    return(lpRet); <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: PrintTextLine() <br> <br>Inputs: Line of text to print <br> <br>Outputs: none <br> <br>Abstract: <br>    PrintTextLine will print a line of text to the text display window, and <br>    scroll as necessary. <br>======================================================================*/ <br> <br>void PrintTextLine( <br>    LPSTR cLine <br>    ) <br>{ <br>    HDC hDC; <br>    int i; <br>    RECT rScroll; <br>    HGLOBAL hMem; <br> <br>    hDC = GetDC(hWndText); <br> <br>    // <br>    // If we already have MAX_TEXT_LINES of text remembered, <br>    // we need to zap one to make room for the new line. <br>    // <br>    if (iTextLines == MAX_TEXT_LINES) { <br>        hMem = (HGLOBAL) GlobalHandle(SELECTOROF(cText[0])); <br>        GlobalUnlock(hMem); <br>        GlobalFree(hMem); <br>        for(i=0;i&lt;MAX_TEXT_LINES-1;i++) { <br>            cText[i] = cText[i+1]; <br>            } <br>        iTextLines--; <br>        } <br> <br>    // <br>    // Copy the line to be displayed into our buffer <br>    // <br>    cText[iTextLines++] = lstrdup(cLine); <br> <br>    // <br>    // Scroll if necessary <br>    // <br>    if (iCurLine &gt;= iMaxNumLines) { <br>        GetClientRect(hWndText,&amp;rScroll); <br>        rScroll.top += 2; <br>        ScrollWindow(hWndText,0,-tmTextInfo.tmHeight,&amp;rScroll,&amp;rScroll); <br>        UpdateWindow(hWndText); <br>        iCurLine--; <br>        } <br> <br>    TextOut(hDC,10,iCurLine * tmTextInfo.tmHeight + 2, <br>            cText[iTextLines-1], <br>            lstrlen(cText[iTextLines-1])); <br> <br>    iCurLine++; <br> <br>    ReleaseDC(hWndText,hDC); <br> <br>    return; <br>} <br> <br> <br>/*===================================================================== <br>Function: TextWndProc() <br> <br>Inputs: Standard windows entrypoint parms <br> <br>Outputs: success <br> <br>Abstract: <br>    This is the main procedure to take care of drawing, resizing etc. <br>    the text message window. <br>======================================================================*/ <br> <br> <br>LONG FAR PASCAL TextWndProc( <br>    HWND hWnd, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hDC; <br>    int i; <br>    HGLOBAL hMem; <br> <br>    switch (Message) { <br> <br>        case WM_CREATE: <br>            for(i=0;i&lt;MAX_TEXT_LINES;i++) { <br>                cText[i] = (LPSTR) NULL; <br>//                hMem = GlobalAlloc(GHND,sizeof(char)); <br>//                cText[i] = GlobalLock(hMem); <br>//                cText[i][0] = '\0'; <br>                } <br> <br>            iTextLines = iCurLine = 0; <br>            hDC = GetDC(hWnd); <br>            if(!GetTextMetrics(hDC,&amp;tmTextInfo)) { <br>                MessageBox((HWND)NULL,GetStringRes(IDS_GETTXTMTRCSFAIL), <br>                           "TextWndProc",MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                } <br>            ReleaseDC(hWnd,hDC); <br>            GetClientRect(hWnd,&amp;rText); <br>            iMaxNumLines = (rText.bottom - rText.top-5)/tmTextInfo.tmHeight; <br>            break; <br> <br>        case WM_KEYDOWN: <br>            SendMessage(hWndMaze,WM_KEYDOWN,wParam,lParam); <br>            break; <br> <br>        case WM_MOVE: <br>            break; <br> <br>        case WM_SIZE: <br>            GetClientRect(hWnd,&amp;rText); <br>            iMaxNumLines = (rText.bottom - rText.top - 5)/tmTextInfo.tmHeight; <br>            RefreshText(); <br>            break; <br> <br>        case WM_PAINT: <br>            GetClientRect(hWnd,&amp;rText); <br>            hDC = BeginPaint(hWnd, &amp;ps); <br>            SetBkMode(hDC, OPAQUE); <br>            RefreshText(); <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        case WM_CLOSE: <br>            for (i=0; i&lt;iTextLines ; i++) { <br>                if (cText[i] != NULL) { <br>                    hMem = (HGLOBAL) GlobalHandle(SELECTOROF(cText[i])); <br>                    GlobalUnlock(hMem); <br>                    GlobalFree(hMem); <br>                } <br>            } <br>            DestroyWindow(hWnd); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, Message, wParam, lParam); <br>        } <br> <br>    return(0); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
