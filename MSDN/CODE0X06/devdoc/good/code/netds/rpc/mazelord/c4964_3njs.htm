<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCOREWND.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4978"></a>SCOREWND.C</h2>
<pre><code>/*********************************************************************** <br>File:   ScoreWnd.c <br> <br>Abstract: <br> <br>    This module contains functions to maintain the Score window. <br> <br> <br>Contents: <br> <br>    DelScoreType() -- Delete a record of type ScoreType <br>    NewScoreType() -- Create &amp; initialize a record of type ScoreType <br>    DrawScore() -- Draws a score entry with parametric update selection <br>    ScoreWndProc() -- Main windows entrypoint for window with scores <br> <br> <br>************************************************************************/ <br> <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include "net.h" <br>#include &lt;mmsystem.h&gt; <br>#include &lt;string.h&gt; <br> <br> <br>TEXTMETRIC tmScoreInfo; <br>RECT rDirRect[4],rBitmapRect; // These will need ix and iy added to be right. <br> <br>int iTextYPos; <br> <br>#define SC_PIC    0x1 <br>#define SC_NAME   0x2 <br>#define SC_SCORE  0x4 <br>#define SC_DIRECT 0x8 <br>#define SC_REDRAW 0x10 <br> <br> <br> <br> <br>/*===================================================================== <br>Function:   DelScoreType() <br> <br>Inputs:     Pointer to record of ScoreType to delete <br> <br>Outputs:    returns -&gt;next field of deleted record <br> <br>Abstract: <br>    Returns -&gt;next field to facilitate linked list maintenance <br>======================================================================*/ <br> <br>ScoreType FAR *DelScoreType( <br>    ScoreType FAR *stTrav <br>    ) <br>{ <br>    ScoreType FAR *stHold; <br>    HGLOBAL hMem; <br> <br>    if (stTrav == (ScoreType FAR *) NULL) { <br>        stHold = (ScoreType FAR *) NULL; <br>        } <br>    else { <br>        stHold = stTrav-&gt;next; <br>        hMem = (HGLOBAL) GlobalHandle(SELECTOROF(stTrav)); <br>        GlobalUnlock(hMem); <br>        GlobalFree(hMem); <br>        } <br> <br>    return(stHold); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:   NewScoreType() <br> <br>Inputs:     Values for ScoreType member elements <br> <br>Outputs:    Returns pointer to a newly allocated &amp; Init'd record <br> <br>Abstract: <br>    Needs no explanation <br>======================================================================*/ <br> <br>ScoreType FAR *NewScoreType( <br>    unsigned long ulID, <br>    int ix, <br>    int iy, <br>    int iScore, <br>    BYTE bDir, <br>    ScoreType FAR *next <br>    ) <br>{ <br>    ScoreType FAR *stTrav; <br>    HGLOBAL hMem; <br> <br>    hMem = GlobalAlloc(GHND,sizeof(ScoreType)); <br>    stTrav = (ScoreType FAR *) GlobalLock(hMem); <br>    if (stTrav == (ScoreType FAR *)NULL) { <br>        MessageBox((HWND)NULL,GetStringRes(IDS_MALLOCFAIL),"NewScoreType", <br>               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        } <br>    else { <br>        stTrav-&gt;ulID = ulID; <br>        stTrav-&gt;ix = ix; <br>        stTrav-&gt;iy = iy; <br>        stTrav-&gt;iScore = iScore; <br>        stTrav-&gt;bDir = bDir; <br>        stTrav-&gt;next = next; <br>        } <br> <br>    return(stTrav); <br>} <br> <br> <br> <br> <br> <br> <br>/*===================================================================== <br>Function:   DrawScore() <br> <br>Inputs:     Pointer to score structure for to draw, flags for what to update <br> <br>Outputs:    none <br> <br>Abstract: <br>    DrawScore is the workhorse routine for drawing score entries. <br>======================================================================*/ <br> <br>void DrawScore( <br>    ScoreType FAR *stTrav, <br>    DWORD dwSCFlags <br>    ) <br>{ <br>    char Buff[132]; <br>    UINT uiAlign; <br>    int x,y,px,py; <br>    PlayerType FAR *ptTrav; <br>    FullPicType FAR *fptTrav; <br>    HBRUSH hWhiteBrush,hBlackBrush,hOld; <br>    HPEN hWhitePen, hOldPen; <br>    HDC hDC,hPicDC; <br>    RECT rScratch; <br>    BOOL bFound,bIsSelf,bFound2; <br>    BYTE bDir,bNewDir,bB; <br>    float fAspect; <br> <br> <br>    bFound = FALSE; <br>    ptTrav = &amp;ptPlayers; <br> <br>    hWhiteBrush = GetStockObject(WHITE_BRUSH); <br>    hWhitePen = GetStockObject(WHITE_PEN); <br> <br>    // <br>    // Find the player structure associated with the score we're updating <br>    // <br>    while (ptTrav-&gt;next != NULL) { <br>        ptTrav = ptTrav-&gt;next; <br>        if (ptTrav-&gt;ulID == stTrav-&gt;ulID) { <br>            bFound = TRUE; <br>            break; <br>            } <br>        } <br> <br>    if (!bFound) { <br>        bIsSelf = (stTrav-&gt;ulID == ptSelf.ulID); <br>        } <br>    else { <br>        bIsSelf = FALSE; <br>        } <br> <br> <br>    hDC = GetDC(hWndScore); <br> <br>    // <br>    // Play the dog-being-kicked sound if the player is doing bad. <br>    // <br>    if (stTrav-&gt;ulID == ptSelf.ulID) { <br>        if (iKilledByDrones&amp;&amp;(!(iKilledByDrones%5))&amp;&amp;(stTrav-&gt;iScore &gt; ptSelf.iScore)) { <br>            sndPlaySound("dog.wav",SND_ASYNC); <br>            } <br>        } <br> <br>    // <br>    // Draw a profile of the player if appropriate <br>    // <br>    if ((dwSCFlags&amp;SC_PIC)&amp;&amp;(dwSCFlags&amp;SC_REDRAW)) { <br>        rScratch.left = rBitmapRect.left + stTrav-&gt;ix; <br>        rScratch.right = rBitmapRect.right + stTrav-&gt;ix; <br>        rScratch.top = rBitmapRect.top + stTrav-&gt;iy; <br>        rScratch.bottom = rBitmapRect.bottom + stTrav-&gt;iy; <br> <br>        hPicDC = CreateCompatibleDC(hDC); <br>        fptTrav = &amp;fptPic; <br>        bFound2 = FALSE; <br>        while (fptTrav-&gt;next != (FullPicType FAR *)NULL) { <br>            fptTrav = fptTrav-&gt;next; <br>            if (fptTrav-&gt;iPicNum == ((bIsSelf) ? ptSelf.iPicNum : ptTrav-&gt;iPicNum)) { <br>                bFound2 = TRUE; <br>                break; <br>                } <br>            } <br> <br>        if (bFound2) { <br>            SelectObject(hPicDC,fptTrav-&gt;P[1].hBitmap); <br>            x = rScratch.right - rScratch.left; <br>            y = rScratch.bottom - rScratch.top; <br>            fAspect=((float) fptTrav-&gt;P[1].ySize)/ <br>                     ((float) fptTrav-&gt;P[1].xSize); <br> <br>            StretchBlt(hDC,rScratch.left, <br>                       rScratch.top+fptTrav-&gt;P[1].yOrg*y/PIC_Y, <br>                       (int) ((x &lt; (y/fAspect))? x : y/fAspect), <br>                       (int) ((y &lt; (x*fAspect))? y : (int) x*fAspect), <br>                       hPicDC,0,0, <br>                       fptTrav-&gt;P[1].xSize, <br>                       fptTrav-&gt;P[1].ySize, <br>                       SRCCOPY); <br>            } <br> <br>        DeleteDC(hPicDC); <br>        } <br> <br>    // <br>    // Print the User &amp; computer name of the player if appropriate <br>    // <br>    if ((dwSCFlags&amp;SC_NAME)&amp;&amp;(dwSCFlags&amp;SC_REDRAW)) { <br>        if (bIsSelf) { <br>            sprintf(Buff,"%s@%s",ptSelf.cUserName,ptSelf.cComputerName); <br>            } <br>        else { <br>           if (bFound) { <br>               sprintf(Buff,"%s@%s",ptTrav-&gt;cUserName,ptTrav-&gt;cComputerName); <br>               } <br>           } <br>        TextOut(hDC,80,iTextYPos+stTrav-&gt;iy,Buff,lstrlen(Buff)); <br>        } <br> <br>    // <br>    // Print the current score of the player if appropriate <br>    // <br>    if ((dwSCFlags&amp;SC_SCORE)&amp;&amp; <br>        ((dwSCFlags&amp;SC_REDRAW)|| <br>        (bFound&amp;&amp;(ptTrav-&gt;iScore != stTrav-&gt;iScore)) || <br>        (bIsSelf&amp;&amp;(ptSelf.iScore != stTrav-&gt;iScore))) <br>       ) { <br> <br>        hOldPen = SelectObject(hDC,hWhitePen); <br>        hOld = SelectObject(hDC,hWhiteBrush); <br>        sprintf(Buff,"%ld",stTrav-&gt;iScore); <br> <br>        Rectangle(hDC,rScore.right-5-((strlen(Buff)+1)* tmScoreInfo.tmAveCharWidth), <br>                  iTextYPos+stTrav-&gt;iy,rScore.right-5, <br>                  iTextYPos+stTrav-&gt;iy + tmScoreInfo.tmHeight); <br>        SelectObject(hDC,hOldPen); <br>        SelectObject(hDC,hOld); <br> <br>        if (bIsSelf) { <br>            sprintf(Buff,"%ld",ptSelf.iScore); <br>            stTrav-&gt;iScore = ptSelf.iScore; <br>            } <br>        else { <br>            if (bFound) { <br>                sprintf(Buff,"%ld",ptTrav-&gt;iScore); <br>                stTrav-&gt;iScore = ptTrav-&gt;iScore; <br>                } <br>            else { <br>                MessageBox((HWND)NULL,GetStringRes(IDS_MDFYSCO),"DrawScore", <br>                           MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                } <br>            } <br> <br>        uiAlign = SetTextAlign(hDC,TA_TOP | TA_RIGHT); <br>        TextOut(hDC,rScore.right-5,iTextYPos+stTrav-&gt;iy,Buff,lstrlen(Buff)); <br>        SetTextAlign(hDC,uiAlign); <br>        } <br> <br>    // <br>    // Modify the squares which say which direction to go to find this <br>    // particular player, if appropriate. <br>    // <br>    if (bFound&amp;&amp;(dwSCFlags&amp;SC_DIRECT)) { <br>        x = ptSelf.Pos.ix; <br>        y = ptSelf.Pos.iy; <br> <br>        hBlackBrush = GetStockObject(BLACK_BRUSH); <br> <br>        px = ptTrav-&gt;Pos.ix; <br>        py = ptTrav-&gt;Pos.iy; <br>        bDir = stTrav-&gt;bDir; <br> <br>        bNewDir = (py &lt;= y) ? NORTH : (BYTE)0; <br>        bNewDir |= (py &gt;= y) ? SOUTH : (BYTE)0; <br>        bNewDir |= (px &gt;= x) ? EAST : (BYTE)0; <br>        bNewDir |= (px &lt;= x) ? WEST : (BYTE)0; <br> <br>        // <br>        // Now that we have the ABSOLUTE directions, we need to rotate it for <br>        // our offset from true north. <br>        // <br> <br>        bB = ptSelf.Pos.Facing; <br> <br>        while (bB /=2 ) { <br>            if (bNewDir &amp; 1) { <br>                bNewDir = bNewDir / 2 + 8; <br>                } <br>            else { <br>                bNewDir /= 2; <br>                } <br>/**** <br>            if (bNewDir &amp; 16) { <br>                bNewDir = (bNewDir &amp; 15) + 1; <br>                } <br>****/ <br>            } <br> <br>        // <br>        // Draw square #0 <br>        // <br>        if ((dwSCFlags&amp;SC_REDRAW)|| <br>            ((bNewDir&amp;(NORTH|WEST)) != (bDir&amp;(NORTH|WEST))) <br>           ) { <br>            if ((bNewDir&amp;NORTH)&amp;&amp;(bNewDir&amp;WEST)) { <br>                hOld = SelectObject(hDC,hBlackBrush); <br>                } <br>            else { <br>                hOld = SelectObject(hDC,hWhiteBrush); <br>                } <br> <br>            Rectangle(hDC,rDirRect[0].left+stTrav-&gt;ix,rDirRect[0].top+stTrav-&gt;iy, <br>                      rDirRect[0].right+stTrav-&gt;ix,rDirRect[0].bottom+stTrav-&gt;iy); <br>            SelectObject(hDC,hOld); <br>            } <br> <br>        // <br>        // Draw square #1 <br>        // <br>        if ((dwSCFlags&amp;SC_REDRAW)|| <br>            ((bNewDir&amp;(NORTH|EAST)) != (bDir&amp;(NORTH|EAST))) <br>           ) { <br>            if ((bNewDir&amp;NORTH)&amp;&amp;(bNewDir&amp;EAST)) { <br>                hOld = SelectObject(hDC,hBlackBrush); <br>                } <br>            else { <br>                hOld = SelectObject(hDC,hWhiteBrush); <br>                } <br> <br>            Rectangle(hDC,rDirRect[1].left+stTrav-&gt;ix,rDirRect[1].top+stTrav-&gt;iy, <br>                      rDirRect[1].right+stTrav-&gt;ix,rDirRect[1].bottom+stTrav-&gt;iy); <br>            SelectObject(hDC,hOld); <br>            } <br> <br>        // <br>        // Draw square #2 <br>        // <br>        if ((dwSCFlags&amp;SC_REDRAW)|| <br>            ((bNewDir&amp;(SOUTH|WEST)) != (bDir&amp;(SOUTH|WEST))) <br>           ) { <br>            if ((bNewDir&amp;SOUTH)&amp;&amp;(bNewDir&amp;WEST)) { <br>                hOld = SelectObject(hDC,hBlackBrush); <br>                } <br>            else { <br>                hOld = SelectObject(hDC,hWhiteBrush); <br>                } <br> <br>            Rectangle(hDC,rDirRect[2].left+stTrav-&gt;ix,rDirRect[2].top+stTrav-&gt;iy, <br>                      rDirRect[2].right+stTrav-&gt;ix,rDirRect[2].bottom+stTrav-&gt;iy); <br>            SelectObject(hDC,hOld); <br>            } <br> <br>        // <br>        // Draw square #1 <br>        // <br>        if ((dwSCFlags&amp;SC_REDRAW)|| <br>            ((bNewDir&amp;(SOUTH|EAST)) != (bDir&amp;(SOUTH|EAST))) <br>           ) { <br>            if ((bNewDir&amp;SOUTH)&amp;&amp;(bNewDir&amp;EAST)) { <br>                hOld = SelectObject(hDC,hBlackBrush); <br>                } <br>            else { <br>                hOld = SelectObject(hDC,hWhiteBrush); <br>                } <br> <br>            Rectangle(hDC,rDirRect[3].left+stTrav-&gt;ix,rDirRect[3].top+stTrav-&gt;iy, <br>                      rDirRect[3].right+stTrav-&gt;ix,rDirRect[3].bottom+stTrav-&gt;iy); <br>            SelectObject(hDC,hOld); <br>            } <br> <br>        stTrav-&gt;bDir = bNewDir; <br> <br>        DeleteObject(hBlackBrush); <br>        } <br> <br>    DeleteObject(hWhiteBrush); <br>    DeleteObject(hWhitePen); <br>    ReleaseDC(hWndScore,hDC); <br> <br>    return; <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function:   ScoreWndProc() <br> <br>Inputs:     Standard Windows Proc parms <br> <br>Outputs:    returns success/failure <br> <br>Abstract: <br>    Handles updating/controlling the score child window <br>======================================================================*/ <br> <br>LONG FAR PASCAL ScoreWndProc( <br>    HWND hWnd, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hDC; <br>    ScoreType FAR *stTrav,FAR *stTrav2; <br>    BOOL bFound,bFoundpt,bIsSelf; <br>    PlayerType FAR *ptTrav; <br>    RECT rScratch; <br>    HPEN hWhitePen,hOldPen; <br> <br> <br>    bIsSelf = (lParam == (LPARAM) ptSelf.ulID); <br>    bFoundpt = FALSE; <br>    ptTrav=&amp;ptPlayers; <br>    while(ptTrav-&gt;next != NULL) { <br>        ptTrav = ptTrav-&gt;next; <br>        if (ptTrav-&gt;ulID == (UINT) lParam) { <br>            bFoundpt = TRUE; <br>            break; <br>            } <br>        } <br> <br>    switch (Message) { <br>        case WM_CREATE: <br>            GetClientRect(hWnd,&amp;rScore); <br>            hDC = GetDC(hWnd); <br> <br>            // <br>            // Kludge: fill out scores with our own entry <br>            // <br>            Scores.ulID = ptSelf.ulID; <br>            Scores.ix = 0; <br>            Scores.iy = 0; <br>            Scores.iScore = ptSelf.iScore; <br>            Scores.bDir = 0xFF; <br>            Scores.next=NULL; <br> <br>            if(!GetTextMetrics(hDC,&amp;tmScoreInfo)) { <br>                MessageBox((HWND)NULL,GetStringRes(IDS_GETTXTMTRCSFAIL), <br>                           "ScoreWndProc",MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                } <br> <br>            rBitmapRect.left = 40; <br>            rBitmapRect.right = rBitmapRect.left + 19; <br>            rBitmapRect.top = 5; <br>            rBitmapRect.bottom = rBitmapRect.top+29; <br> <br>            // <br>            // 01 <br>            // 23 <br>            // <br>            rDirRect[0].left = rDirRect[2].left = 5; <br>            rDirRect[1].left = rDirRect[3].left = rDirRect[0].right = rDirRect[2].right = 20; <br>            rDirRect[1].right = rDirRect[3].right = 35; <br>            rDirRect[0].top     = rDirRect[1].top = 5; <br>            rDirRect[2].top     = rDirRect[3].top = rDirRect[0].bottom = rDirRect[1].bottom = 20; <br>            rDirRect[2].bottom = rDirRect[3].bottom = 35; <br> <br>            iTextYPos = rBitmapRect.top + (rBitmapRect.bottom - tmScoreInfo.tmHeight - rBitmapRect.top)/2; <br> <br>            ReleaseDC(hWnd,hDC); <br>            break; <br> <br>        case WM_COMMAND: <br>            // <br>            // Note -- we use lParam because we pass WM_COMMAND msg's ourselves. <br>            // <br>            bFound = FALSE; <br>            stTrav = &amp;Scores; <br>            while (stTrav-&gt;next != NULL) { <br>                if (stTrav-&gt;next-&gt;ulID == (unsigned long)lParam) { <br>                    bFound = TRUE; <br>                    break; <br>                    } <br>                stTrav = stTrav-&gt;next; <br>                } <br> <br>            switch (wParam) { <br> <br>                case WC_ADDSCORE: <br>                    if (!bFound) { <br>                        if ((lParam != 0)&amp;&amp;bFoundpt) { <br>                            stTrav-&gt;next = NewScoreType(ptTrav-&gt;ulID,stTrav-&gt;ix, <br>                                                        stTrav-&gt;iy+35,ptTrav-&gt;iScore,0,stTrav-&gt;next); <br>                            DrawScore(stTrav-&gt;next,SC_PIC|SC_NAME|SC_SCORE|SC_DIRECT|SC_REDRAW); <br>                            } <br>                        else { <br>                            MessageBox((HWND)NULL,GetStringRes(IDS_SCOADD0FAIL),"ScoreDlg", <br>                                       MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                            } <br>                        } <br>                    break; <br> <br>                case WC_UPDATESCORE: <br>                    if (bFound&amp;&amp;bFoundpt) { <br>                        DrawScore(stTrav-&gt;next,SC_SCORE); <br>                        } <br>                    else { <br>                        if (bIsSelf) { <br>                            DrawScore(&amp;Scores,SC_SCORE); <br>                            } <br>                        else { <br>                            MessageBox((HWND)NULL,GetStringRes(IDS_CHGSCOFAIL),"ScoreDlg", <br>                                       MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                            } <br>                        } <br>                    break; <br> <br>                case WC_UPDATEDIRECTION: <br>                    // <br>                    // if it's a global update <br>                    // <br>                    if (lParam == 0) { <br>                        stTrav = &amp;Scores; <br>                        while (stTrav-&gt;next != NULL) { <br>                            stTrav = stTrav-&gt;next; <br>                            DrawScore(stTrav,SC_DIRECT); <br>                            } <br>                        } <br>                    else { <br>                        if (bFound&amp;&amp;bFoundpt) { <br>                            // <br>                            // must be updated in routine <br>                            // <br>                            DrawScore(stTrav-&gt;next,SC_DIRECT); <br>                            } <br>                        else { <br>                            MessageBox((HWND)NULL,GetStringRes(IDS_CHGDIRFAIL),"ScoreDlg", <br>                                       MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                            } <br>                        } <br>                    break; <br> <br>                case WC_DELETESCORE: <br>                    if (bFound) { <br>                        stTrav2 = stTrav; <br>                        stTrav-&gt;next = DelScoreType(stTrav-&gt;next); <br>                        while (stTrav2-&gt;next != NULL) { <br>                            DrawScore(stTrav2-&gt;next,SC_PIC|SC_NAME|SC_SCORE|SC_DIRECT|SC_REDRAW); <br>                            stTrav2 = stTrav2-&gt;next; <br>                            } <br>                        rScratch.top = rDirRect[0].top + stTrav-&gt;iy + 35; <br>                        rScratch.bottom = rDirRect[2].bottom + stTrav-&gt;iy + 35; <br>                        rScratch.left = 5; <br>                        rScratch.right = rScore.right - 5; <br>                        hDC = GetDC(hWndScore); <br>                        hWhitePen = GetStockObject(WHITE_PEN); <br>                        hOldPen = SelectObject(hDC,hWhitePen); <br>                        Rectangle(hDC,rScratch.left,rScratch.top, <br>                                  rScratch.right,rScratch.bottom); <br>                        SelectObject(hDC,hOldPen); <br>                        DeleteObject(hWhitePen); <br>                        ReleaseDC(hWndScore,hDC); <br>                        } <br>                    else { <br>                        MessageBox((HWND)NULL,GetStringRes(IDS_DELSCOFAIL),"ScoreDlg", <br>                                   MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                        } <br>                    break; <br> <br>                default: <br>                    MessageBox((HWND)NULL,GetStringRes(IDS_BADMSG),"ScoreDlg", <br>                               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                    break; <br>                } <br>            break; <br> <br>        case WM_KEYDOWN: <br>            SendMessage(hWndMaze,WM_KEYDOWN,wParam,lParam); <br>            break; <br> <br>        case WM_MOVE: <br>            break; <br> <br>        case WM_SIZE: <br>// <br>// BUGBUG -- eventually we'll want to soft-code the now hard-coded rects. <br>// <br>            break; <br> <br>        case WM_PAINT: <br>            GetClientRect(hWnd,&amp;rScore); <br>            hDC = BeginPaint(hWnd, &amp;ps); <br>// <br>// OPTIMIZE -- this can be set to loop through only visible portions <br>// <br>            stTrav = &amp;Scores; <br>            SetBkMode(hDC, TRANSPARENT); <br>            do { <br>                DrawScore(stTrav,SC_PIC|SC_NAME|SC_SCORE|SC_DIRECT|SC_REDRAW); <br>                stTrav = stTrav-&gt;next; <br>                } while (stTrav != NULL); <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        case WM_CLOSE: <br>            stTrav = &amp;Scores; <br>            while (stTrav-&gt;next != NULL) { <br>                stTrav-&gt;next = DelScoreType(stTrav-&gt;next); <br>            } <br>            DestroyWindow(hWnd); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, Message, wParam, lParam); <br>        } <br> <br>    return(0); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
