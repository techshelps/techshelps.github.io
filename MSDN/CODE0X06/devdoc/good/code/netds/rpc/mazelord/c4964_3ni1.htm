<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAZE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4969"></a>MAZE.C</h2>
<pre><code>/*********************************************************************** <br>File:   Maze.c <br> <br>Abstract: <br> <br>    This is the main module for MazeLords. It Contains WinMain, as well as the <br>    WndProcs for the main modules. <br> <br> <br>Contents: <br> <br>    InSanctuary() -- determines whether a maze position is in the Sanctuary <br>    WinMain() -- Main windows entrypoint <br>    WndProc() -- Main window processing entrypoint <br>    RegisterClasses() -- Register different window classes <br>    OneTimeInit() -- Initialization done first time window created <br>    EachTimeInit() -- Initialization done each new game <br>    OneTimeShutdown() -- cleanup done last time window destroyed <br>    EachTimeShutdown() -- cleanup done each time the game is STOPped. <br> <br>Revision History: <br> <br>************************************************************************/ <br> <br>#define FULL_REDRAW 200 <br>#define IN_MAIN <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include "net.h" <br> <br>int ngCmdShow; <br>HDC hHoldDC; <br> <br> <br> <br>/*===================================================================== <br>Function: InSanctuary() <br> <br>Inputs: Position <br> <br>Outputs: TRUE if position in Sanctuary, else FALSE <br> <br>Abstract: <br>    This function is used to determine if a given position is inside <br>    the sanctuary. If it is, then combat isn't allowed from/to that <br>    position, with the exception of shooting drones from outside the <br>    sanctuary. <br>======================================================================*/ <br> <br>BOOL InSanctuary( <br>    PositionType FAR *Pos <br>    ) <br>{ <br>    BOOL bRet; <br>    int iLeft,iTop; <br> <br>    iLeft = 6*X_CELLS_PER_SUBGRID+1; <br>    iTop = 7*Y_CELLS_PER_SUBGRID+1; <br> <br> <br>    bRet = ((Pos-&gt;ix &gt;= iLeft)&amp;&amp;(Pos-&gt;ix &lt;= iLeft+2)); <br>    bRet = bRet&amp;&amp;((Pos-&gt;iy &gt;= iTop)&amp;&amp;(Pos-&gt;iy &lt;= iTop+2)); <br> <br>    return(bRet); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: WinMain() <br> <br>Inputs: Standard winmain inputs <br> <br>Outputs:success <br> <br>Abstract: <br>    This is the WinMain for MazeLords. It is responsible for, among <br>    other things, registering the windows classes, and allocating some <br>    of the larger dynamic data structures. <br>======================================================================*/ <br> <br>int PASCAL WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpszCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br>    MSG     msg; <br>    int     i,j,nRc; <br>    HGLOBAL hMem; <br> <br>    // <br>    // DYNAMIC ALLOCATION OF GLOBAL VARS <br>    // <br>    hMem = GlobalAlloc(GHND,(MAX_DRAW_DIST*2+2+1) * sizeof(LPPOINT FAR *)); <br>    pPost = (LPPOINT FAR * FAR *) GlobalLock(hMem); <br>    for(i=0;i&lt;(MAX_DRAW_DIST*2+2+1);i++) { <br>        hMem = GlobalAlloc(GHND,(MAX_DRAW_DIST+2+1)*sizeof(LPPOINT)); <br>        pPost[i] = (LPPOINT FAR *) GlobalLock(hMem); <br>        for(j=0;j&lt;(MAX_DRAW_DIST+2+1);j++) { <br>            hMem = GlobalAlloc(GHND,2*sizeof(POINT)); <br>            pPost[i][j] = (LPPOINT) GlobalLock(hMem); <br>            } <br>        } <br> <br>    hMem = GlobalAlloc(GHND,NUM_PICS * sizeof(FullPicType FAR *)); <br>    PreStretch = (FullPicType FAR * FAR *) GlobalLock(hMem); <br>    for(i=0;i&lt;NUM_PICS;i++) { <br>        hMem = GlobalAlloc(GHND,MAX_DRAW_DIST * sizeof(FullPicType)); <br>        PreStretch[i] = (FullPicType FAR *) GlobalLock(hMem); <br>        } <br> <br>    hMem = GlobalAlloc(GHND,X_SIZE * sizeof(BYTE FAR *)); <br>    bMaze = (BYTE FAR * FAR *) GlobalLock(hMem); <br>    for(i=0;i&lt;X_SIZE;i++) { <br>        hMem = GlobalAlloc(GHND,Y_SIZE * sizeof(BYTE)); <br>        bMaze[i] = (LPBYTE) GlobalLock(hMem); <br>        } <br> <br>    hMem = GlobalAlloc(GHND,X_SUBGRIDS_PER_GRID * sizeof(SubGridType FAR *)); <br>    Grid = (SubGridType FAR * FAR *) GlobalLock(hMem); <br>    for(i=0;i&lt;X_SUBGRIDS_PER_GRID;i++) { <br>        hMem = GlobalAlloc(GHND,Y_SUBGRIDS_PER_GRID * sizeof(SubGridType)); <br>        Grid[i] = (SubGridType FAR *) GlobalLock(hMem); <br>        } <br> <br>    hMem = GlobalAlloc(GHND,NUM_SUBGRIDS * sizeof(SubGridCellsType)); <br>    SubGrids = (SubGridCellsType FAR *) GlobalLock(hMem); <br> <br> <br> <br>    lstrcpy(szAppName, "MAZE"); <br>    hInst = hInstance; <br> <br>    // <br>    // We need to register the different windows and child <br>    // windows we'll be using if this is the first instance <br>    // of MazeLords. <br>    // <br>    if(!hPrevInstance) { <br>      if ((nRc = RegisterClasses()) == -1) { <br>        LoadString(hInst, IDS_ERR_REGISTER_CLASS, szString, sizeof(szString)); <br>        MessageBox((HWND)NULL, szString, (LPSTR)NULL, MB_ICONEXCLAMATION); <br>        return nRc; <br>        } <br>      } <br> <br>    // <br>    // Display the Main window for MazeLords <br>    // <br>    hWndMain = CreateWindow( <br>                  szAppName, <br>                  "Maze Lords", <br>                  WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX | <br>                             WS_THICKFRAME|WS_CLIPCHILDREN|WS_OVERLAPPED, <br>                  CW_USEDEFAULT, 0, <br>                  CW_USEDEFAULT, 0, <br>                  (HWND)NULL, <br>                  (HMENU)NULL, <br>                  hInst, <br>                  NULL); <br> <br>    OneTimeInit(); <br> <br>    if(hWndMain == (HWND)NULL){ <br>        LoadString(hInst, IDS_ERR_CREATE_WINDOW, szString, sizeof(szString)); <br>        MessageBox((HWND)NULL, szString, "WinMain", MB_ICONEXCLAMATION); <br>        return IDS_ERR_CREATE_WINDOW; <br>        } <br> <br> <br>    ShowWindow(hWndMain, nCmdShow); <br>    ngCmdShow = nCmdShow; <br> <br> <br> <br>    while(GetMessage(&amp;msg, (HWND)NULL, 0, 0)) { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>        } <br> <br>    UnRegisterClasses(); <br>    return msg.wParam; <br>} <br> <br> <br>/*===================================================================== <br>Function: Wndproc() <br> <br>Inputs: Standard windows message processing entrypoint parms <br> <br>Outputs:returns Success <br> <br>Abstract: <br>    This is the window procedure for the main window. It takes care of <br>    spawning and destroying child windows, interpreting menu-item <br>    command messages, and most of the none-movement keystrokes. <br>======================================================================*/ <br> <br>LONG FAR PASCAL WndProc( <br>    HWND hWnd, <br>    UINT Message, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    HMENU           hMenu=0; <br>    HBITMAP         hBitmap=0; <br>    HDC             hDC,hBMDC; <br>    PAINTSTRUCT     ps; <br>    int             nRc=0; <br>    INT             i,j,MazexDim,MazeyDim,TopxDim,TopyDim; <br>    UINT            uCmdId,uCmdCmd; <br>    HWND            hCmd; <br> <br> <br>    switch (Message) { <br> <br> <br>        case WM_TIMER: <br>            if ((!UserIntCount)&amp;&amp;(!bDemoMode)&amp;&amp;(bDemoEnable)) { <br>                StartDemo(); <br>                } <br>            UserIntCount = 0; <br>            break; <br> <br> <br>        case WM_INITMENU: <br>            if (bDemoMode) { <br>                StopDemo(); <br>                } <br>            UserIntCount++; <br>            return DefWindowProc(hWnd, Message, wParam, lParam); <br> <br>        case WM_COMMAND: <br>            uCmdId = GET_WM_COMMAND_ID(wParam,lParam); <br>            uCmdCmd = GET_WM_COMMAND_CMD(wParam,lParam); <br>            hCmd = GET_WM_COMMAND_HWND(wParam,lParam); <br>            hMenu = GetMenu(hWnd); <br> <br>            switch (uCmdId) { <br> <br>                case IDT_NEWMAIL: <br>                    ProcessNewMail(); <br>                    break; <br> <br>                case IDM_F_HIGHSCORES: <br>                    bDemoEnable = FALSE; <br>                    MessageBox((HWND)NULL,GetStringRes(IDS_HSCONOTIMPL), <br>GetStringRes2(IDS_HSCO),  MB_ICONHAND | MB_APPLMODAL); <br>                    bDemoEnable = TRUE; <br>                    break; <br> <br>                case IDM_F_NEWGAME: <br> <br>                    bDemoEnable = FALSE; <br> <br>                    SetCursor(LoadCursor((HINSTANCE)NULL,IDC_WAIT)); <br> <br>                    EachTimeInit(); <br> <br>                    GetClientRect(hWndMain,&amp;rMain); <br> <br> <br>                    MazexDim = (rMain.right - rMain.left)/2; <br>                    MazeyDim = (rMain.bottom - rMain.top)*2/3; <br>                    MazexDim = MazeyDim = (MazexDim &lt; MazeyDim) ? MazexDim : MazeyDim; <br> <br>                    TopxDim = (rMain.right - rMain.left)/4; <br>                    TopyDim = (rMain.bottom - rMain.top)/3; <br>                    TopxDim = TopyDim = (TopxDim &lt; TopyDim) ? TopxDim : TopyDim; <br>                    rTopView.right = rMain.right - 10; <br>                    rTopView.bottom = rMain.bottom - 10; <br>                    rTopView.left = rTopView.right - TopxDim; <br>                    rTopView.top = rTopView.bottom - TopyDim; <br> <br>                    rText.left = rMain.left + 10; <br>                    rText.right = rMain.right - 10 - TopxDim - 10; <br>                    rText.top = rMain.top + 10 + MazeyDim + 10; <br>                    rText.bottom = rMain.bottom-10; <br> <br>                    rScore.left = rMain.left + 10 + MazexDim +10; <br>                    rScore.right = rMain.right - 10; <br>                    rScore.top = rMain.top + 10; <br>                    rScore.bottom = rMain.bottom - 10 - TopyDim - 10; <br> <br>                    // <br>                    // create the 3-d view window <br>                    // <br>                    rMaze.left = 0;rMaze.right = 0; <br>                    rMaze.right = MazexDim; <br>                    rMaze.bottom = MazeyDim; <br> <br>                    InitMaze(); <br>                    Calc3DMaze(); <br>                    InitNetwork(); <br> <br>                    rMaze.left = rMain.left+10; <br>                    rMaze.top = rMain.top +10; <br>                    rMaze.right = rMaze.left + MazexDim; <br>                    rMaze.bottom = rMaze.top + MazeyDim; <br> <br>                    hWndMaze = CreateWindow((LPSTR) "MazeDrawWindow", <br>                                            (LPSTR) "", <br>                                            WS_CHILD | WS_DLGFRAME, <br>                                            rMaze.left,rMaze.top, <br>                                            rMaze.right - rMaze.left, <br>                                            rMaze.bottom - rMaze.top, <br>                                            hWndMain, <br>                                            (HMENU) NULL, <br>                                            hInst, <br>                                            NULL); <br> <br>                    if(hWndMaze == (HWND)NULL) { <br>                        return IDS_ERR_CREATE_WINDOW; <br>                        } <br> <br>                    StretchBitmaps(); <br> <br>                    GetClientRect(hWndMaze,&amp;rMaze); <br>                    ShowWindow(hWndMaze, ngCmdShow); <br> <br>                    // <br>                    // Create the top-view window <br>                    // <br>                    hWndTopView = CreateWindow((LPSTR) "TopViewWindow", <br>                                               NULL, <br>                                               WS_CHILD | WS_DLGFRAME, <br>                                               rTopView.left,rTopView.top, <br>                                               rTopView.right - rTopView.left, <br>                                               rTopView.bottom - rTopView.top, <br>                                               hWndMain, <br>                                               (HMENU)NULL, <br>                                               hInst, <br>                                               NULL); <br> <br>                    if(hWndTopView == (HWND)NULL) { <br>                        LoadString(hInst, IDS_ERR_CREATE_WINDOW, szString, sizeof(szString)); <br>                        MessageBox((HWND)NULL, szString, "Main", MB_ICONEXCLAMATION); <br>                        return IDS_ERR_CREATE_WINDOW; <br>                        } <br> <br>                    GetClientRect(hWndTopView,&amp;rTopView); <br>                    ShowWindow(hWndTopView, ngCmdShow); <br> <br>                    // <br>                    // Create the Text window <br>                    // <br>                    hWndText = CreateWindow((LPSTR) "TextWindow", <br>                                            NULL, <br>                                            WS_CHILD | WS_DLGFRAME, <br>                                            rText.left,rText.top, <br>                                            rText.right - rText.left, <br>                                            rText.bottom - rText.top, <br>                                            hWndMain, <br>                                            (HMENU)NULL, <br>                                            hInst, <br>                                            NULL); <br> <br>                    if(hWndText == (HWND)NULL) { <br>                        LoadString(hInst, IDS_ERR_CREATE_WINDOW, szString, sizeof(szString)); <br>                        MessageBox((HWND)NULL, szString, "Main", MB_ICONEXCLAMATION); <br>                        return IDS_ERR_CREATE_WINDOW; <br>                        } <br> <br>                    GetClientRect(hWndText,&amp;rText); <br>                    ShowWindow(hWndText, ngCmdShow); <br>                    PrintTextLine(GetStringRes(IDS_SANCTUARY)); <br>                    PrintTextLine(GetStringRes(IDS_SAFEZONE)); <br> <br> <br>                    // <br>                    // Create the Score window <br>                    // <br>                    hWndScore = CreateWindow((LPSTR) "ScoreWindow", <br>                                             NULL, <br>                                             WS_CHILD | WS_DLGFRAME, <br>                                             rScore.left,rScore.top, <br>                                             rScore.right - rScore.left, <br>                                             rScore.bottom - rScore.top, <br>                                             hWndMain, <br>                                             (HMENU) NULL, <br>                                             hInst, <br>                                             NULL); <br> <br>                    if(hWndScore == (HWND)NULL) { <br>                        LoadString(hInst, IDS_ERR_CREATE_WINDOW, szString, sizeof(szString)); <br>                        MessageBox((HWND)NULL, szString, "Main", MB_ICONEXCLAMATION); <br>                        return IDS_ERR_CREATE_WINDOW; <br>                        } <br> <br>                    GetClientRect(hWndScore,&amp;rScore); <br>                    ShowWindow(hWndScore, ngCmdShow); <br> <br>                    // <br>                    // The game is started. reset the cursor as well. <br>                    // <br>                    GameStarted = TRUE; <br>                    SetCursor(LoadCursor((HINSTANCE)NULL,IDC_ARROW)); <br>                    break; <br> <br>                case IDM_F_EXIT: <br>                    SendMessage(hWnd,WM_CLOSE,0,0); <br>                    break; <br> <br>                case IDM_O_NET: <br>                    bNetworked = TRUE; <br>                    CheckMenuItem(hMenu,IDM_O_NET,MF_CHECKED); <br>                    CheckMenuItem(hMenu,IDM_O_LOCAL,MF_UNCHECKED); <br>                    break; <br> <br>                case IDM_O_LOCAL: <br>                    bNetworked = FALSE; <br>                    CheckMenuItem(hMenu,IDM_O_NET,MF_UNCHECKED); <br>                    CheckMenuItem(hMenu,IDM_O_LOCAL,MF_CHECKED); <br>                    break; <br> <br>                case IDM_O_PLAYERSTRETCH: <br>                    bPlayerPrestretch = !bPlayerPrestretch; <br>                    CheckMenuItem(hMenu,IDM_O_PLAYERSTRETCH, <br>                    bPlayerPrestretch?MF_CHECKED:MF_UNCHECKED); <br>                    if (bPlayerPrestretch) { <br>                        bDronePrestretch = TRUE; <br>                        CheckMenuItem(hMenu,IDM_O_DRONESTRETCH,MF_CHECKED); <br>                        } <br>                    if (GameStarted) { <br>                        StretchBitmaps(); <br>                        } <br>                    break; <br> <br>                case IDM_O_DRONESTRETCH: <br>                    bDronePrestretch = !bDronePrestretch; <br>                    CheckMenuItem(hMenu,IDM_O_DRONESTRETCH, <br>                              bDronePrestretch?MF_CHECKED:MF_UNCHECKED); <br>                    if (bPlayerPrestretch) { <br>                        bDronePrestretch = TRUE; <br>                        CheckMenuItem(hMenu,IDM_O_DRONESTRETCH,MF_CHECKED); <br>                        } <br>                    if (GameStarted) { <br>                        StretchBitmaps(); <br>                        } <br>                    break; <br> <br>                case IDM_O_BITMAP: <br>                    if (bBitmapDraw) { <br>                        CheckMenuItem(hMenu,IDM_O_BITMAP,MF_UNCHECKED); <br>                        bBitmapDraw = FALSE; <br>                        hDC = hHoldDC; <br>                        hHoldDC = hMazeDC; <br>                        hMazeDC = hDC; <br>                        } <br>                    else { <br>                        CheckMenuItem(hMenu,IDM_O_BITMAP,MF_CHECKED); <br>                        bBitmapDraw = TRUE; <br>                        if ((((HWND)hMaze3DBM) == (HWND)NULL)&amp;&amp;(GameStarted)) { <br>                            hHoldDC = hMazeDC; <br>                            GetClientRect(hWnd,&amp;rMaze); <br>                            hDC = GetDC(hWnd); <br>                            if (hMazeDC != NULL) { <br>                                DeleteDC(hMazeDC); <br>                            } <br>                            hMazeDC = CreateCompatibleDC(hDC); <br>                            if (hMaze3DBM != NULL) { <br>                                DeleteObject(hMaze3DBM); <br>                            } <br>                            hMaze3DBM = CreateCompatibleBitmap(hDC,rMaze.right-rMaze.left, <br>                                                               rMaze.bottom-rMaze.top); <br>                            SelectObject(hMazeDC,hMaze3DBM); <br>                            ReleaseDC(hWnd,hDC); <br>                            } <br>                        else { <br>                            hDC = hHoldDC; <br>                            hHoldDC = hMazeDC; <br>                            hMazeDC = hDC; <br>                            } <br>                        } <br>                    break; <br> <br>                case IDM_O_PLAYERSET: <br>                    bDemoEnable = FALSE; <br>                    nRc = DialogBox(hInst,"PLAY_CONF_DLG",hWnd,PlayerDlg); <br>                    bDemoEnable = TRUE; <br>                    break; <br> <br>                case IDM_O_DRONES: <br>                    bDemoEnable = FALSE; <br>                    nRc = DialogBox(hInst,"DRONE_DLG", hWnd, DroneDlg); <br>                    if (GameStarted) { <br>                        if (uiTimer != (UINT) NULL) { <br>                            KillTimer((HWND)NULL,uiTimer); <br>                            } <br> <br>                        if ((iNumDrones)&amp;&amp;(iDroneSpeed != 0)) { <br>                            if (! (uiTimer = SetTimer((HWND)NULL,0,ONE_SECOND/iDroneSpeed,MoveDrone))) { <br>                                MessageBox((HWND)NULL,GetStringRes(IDS_CRETMRFAIL),GetStringRes(IDS_FATALERR), <br>                                           MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                                SendMessage(hWndMain,WM_CLOSE,0,0); <br>                                } <br>                            } <br> <br>                        InitDrones(); <br>                        } <br>                    bDemoEnable = TRUE; <br>                    break; <br> <br>                case IDM_O_PAUSE: <br>                    GamePaused = ! GamePaused; <br>                    break; <br> <br>                case IDM_F_STOP: <br>                    if (GameStarted) { <br>                        nRc = MessageBox((HWND)NULL, GetStringRes(IDS_ASKSTOP), <br>                                         GetStringRes(IDS_STOP), MB_YESNO); <br>                        // <br>                        // If they really want to stop the game, do it... <br>                        // <br>                        if (nRc == IDYES) { <br>                            SendMessage(hWndScore,WM_CLOSE,0,0); <br>                            SendMessage(hWndText,WM_CLOSE,0,0); <br>                            SendMessage(hWndTopView,WM_CLOSE,0,0); <br>                            SendMessage(hWndMaze,WM_CLOSE,0,0); <br>                            EachTimeShutdown(); <br>                            bDemoEnable = TRUE; <br>                            } <br>                        } <br> <br>                    break; <br> <br>                case IDM_ABOUT: <br>                    bDemoEnable = FALSE; <br>                    nRc = DialogBox(hInst,"MDLG_ABOUT", hWnd, AboutDlg); <br>                    bDemoEnable = TRUE; <br>                    break; <br> <br>                default: <br>                    return DefWindowProc(hWnd, Message, wParam, lParam); <br>                } <br>            break; <br> <br> <br>        case WM_KEYDOWN: <br> <br>            if (bDemoMode) { <br>                StopDemo(); <br>                } <br>            UserIntCount++; <br> <br>            switch(wParam) { <br> <br>                // <br>                // X = Quit the game <br>                // <br>                case 'X': <br>                    if (!SendNetMessage(0,0,NULL,NP_LEAVINGGAME)) { <br>                        MessageBox((HWND)NULL,GetStringRes(IDS_SNDPCKTFAIL),"WndProc", <br>                                     MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                        } <br> <br>                    SendMessage(hWndMain,WM_CLOSE,0,0); <br>                    return(0); <br>                    break; <br> <br>                // <br>                // movement messages go to the MazeWindow <br>                // <br>                case VK_SPACE: <br>                case VK_UP: <br>                case VK_LEFT: <br>                case VK_RIGHT: <br>                case VK_DOWN: <br>                case 'w': <br>                case 'W': <br>                case 's': <br>                case 'S': <br>                    SendMessage(hWndMaze,WM_KEYDOWN,wParam,lParam); <br>                    break; <br>                } <br>            break; <br> <br>        case WM_CREATE: <br>            // <br>            // Set timer for 30-second intervals to go into demo-mode. <br>            // <br>            SetTimer(hWnd,(UINT) NULL, (UINT) (30*1000),(TIMERPROC) NULL); <br>            // <br>            // We decide on the basis of user interaction whether to <br>            // start demo-mode or not. <br>            // <br>            UserIntCount = 0; <br>            bDemoMode = FALSE; <br>            CheckMenuItem(hMenu,IDM_O_NET,MF_CHECKED); <br>            CheckMenuItem(hMenu,IDM_O_LOCAL,MF_UNCHECKED); <br>            bNetworked = TRUE; <br>            break; <br> <br>        case WM_MOVE: <br>            break; <br> <br>        case WM_SIZE: <br>            GetClientRect(hWndMain,&amp;rMain); <br> <br>            MazexDim = (rMain.right - rMain.left)/2; <br>            MazeyDim = (rMain.bottom - rMain.top)*2/3; <br>            MazexDim = MazeyDim = (MazexDim &lt; MazeyDim) ? MazexDim : MazeyDim; <br> <br>            rMaze.left = rMain.left+10; <br>            rMaze.top = rMain.top +10; <br>            rMaze.right = rMaze.left + MazexDim; <br>            rMaze.bottom = rMaze.top + MazeyDim; <br>            MoveWindow(hWndMaze,rMaze.left,rMaze.top, <br>                       rMaze.right-rMaze.left,rMaze.bottom-rMaze.top,TRUE); <br> <br>            TopxDim = (rMain.right - rMain.left)/4; <br>            TopyDim = (rMain.bottom - rMain.top)/3; <br>            TopxDim = TopyDim = (TopxDim &lt; TopyDim) ? TopxDim : TopyDim; <br>            rTopView.right = rMain.right - 10; <br>            rTopView.bottom = rMain.bottom - 10; <br>            rTopView.left = rTopView.right - TopxDim; <br>            rTopView.top = rTopView.bottom - TopyDim; <br>            MoveWindow(hWndTopView,rTopView.left,rTopView.top, <br>                       rTopView.right - rTopView.left, <br>                       rTopView.bottom - rTopView.top,TRUE); <br> <br>            rText.left = rMain.left + 10; <br>            rText.right = rMain.right - 10 - TopxDim - 10; <br>            rText.top = rMain.top + 10 + MazeyDim + 10; <br>            rText.bottom = rMain.bottom-10; <br> <br>            MoveWindow(hWndText,rText.left,rText.top, <br>                       rText.right - rText.left, <br>                       rText.bottom - rText.top,TRUE); <br> <br>            rScore.left = rMain.left + 10 + MazexDim +10; <br>            rScore.right = rMain.right - 10; <br>            rScore.top = rMain.top + 10; <br>            rScore.bottom = rMain.bottom - 10 - TopyDim - 10; <br> <br>            MoveWindow(hWndScore,rScore.left,rScore.top, <br>                    rScore.right - rScore.left, <br>                    rScore.bottom - rScore.top,TRUE); <br>            break; <br> <br>        case WM_PAINT: <br>            memset(&amp;ps, 0x00, sizeof(PAINTSTRUCT)); <br>            hDC = BeginPaint(hWnd, &amp;ps); <br> <br>            SetBkMode(hDC, TRANSPARENT); <br>            hBitmap = LoadBitmap(hInst,"MAZE"); <br>            hBMDC = CreateCompatibleDC(hDC); <br>            SelectObject(hBMDC,hBitmap); <br>            GetClientRect(hWndMain,&amp;rMain); <br>            // <br>            // Fill the destination with the bitmap <br>            // <br>            for(i=rMain.left;i&lt;rMain.right;i+=54) { <br>                for(j=rMain.top;j&lt;rMain.bottom;j+=42) { <br>                    BitBlt(hDC,i,j,54,42, <br>                           hBMDC,0,0, <br>                           SRCCOPY <br>                          ); <br>                    } <br>                } <br>            DeleteDC(hBMDC); <br>            DeleteObject(hBitmap); <br> <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        case WM_CLOSE: <br>            DestroyWindow(hWnd); <br>            if (hWnd == hWndMain) { <br>                PostQuitMessage(0); <br>                EachTimeShutdown(); <br>                OneTimeShutdown(); <br>                } <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, Message, wParam, lParam); <br>        } <br> <br>    return(0); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:RegisterClasses() <br> <br>Inputs: None <br> <br>Outputs:returns Success/failure <br> <br>Abstract: <br>    This is responsible for registering the main window class and the <br>    child window classes as well. <br>======================================================================*/ <br> <br>int RegisterClasses( <br>    void <br>    ) <br>{ <br>    WNDCLASS   wndclass; <br> <br> <br>    memset(&amp;wndclass, 0x00, sizeof(WNDCLASS)); <br>    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNWINDOW; <br>    wndclass.lpfnWndProc = WndProc; <br>    wndclass.cbClsExtra = 0; <br>    wndclass.cbWndExtra = 0; <br>    wndclass.hInstance = hInst; <br>    wndclass.hIcon = LoadIcon(hInst, "MAZE"); <br>    wndclass.hCursor = LoadCursor((HINSTANCE)NULL, IDC_ARROW); <br>    wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wndclass.lpszMenuName = szAppName; <br>    wndclass.lpszClassName = szAppName; <br> <br>    if(!RegisterClass(&amp;wndclass)) { <br>        return(-1); <br>        } <br> <br>    // <br>    // Register the 3-d window class <br>    // <br>    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_NOCLOSE | CS_OWNDC | CS_BYTEALIGNWINDOW; <br>    wndclass.lpfnWndProc = MazeWndProc; <br>    wndclass.hIcon = (HICON)NULL; <br>    wndclass.lpszMenuName = NULL; <br>    wndclass.lpszClassName = (LPSTR) "MazeDrawWindow"; <br> <br>    if(!RegisterClass(&amp;wndclass)) { <br>        return(-1); <br>        } <br> <br>    // <br>    // Register the top view window class <br>    // <br>    wndclass.lpfnWndProc = TopViewWndProc; <br>    wndclass.lpszClassName = (LPSTR) "TopViewWindow"; <br> <br>    if(!RegisterClass(&amp;wndclass)) { <br>        return(-1); <br>        } <br> <br>    // <br>    // Register the text window class <br>    // <br>    wndclass.lpfnWndProc = TextWndProc; <br>    wndclass.lpszClassName = (LPSTR) "TextWindow"; <br> <br>    if(!RegisterClass(&amp;wndclass)) { <br>        return(-1); <br>        } <br> <br>    // <br>    // Register the Score window class <br>    // <br>    wndclass.lpfnWndProc = ScoreWndProc; <br>    wndclass.lpszClassName = (LPSTR) "ScoreWindow"; <br> <br>    if(!RegisterClass(&amp;wndclass)) { <br>        return(-1); <br>        } <br> <br>    return(0); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: UnRegisterClasses <br> <br>Inputs: none <br> <br>Outputs:none <br> <br>Abstract: <br>    This deletes the windows classes we registered for MazeLords. <br>======================================================================*/ <br> <br>void UnRegisterClasses( <br>    void <br>    ) <br>{ <br>    WNDCLASS   wndclass; <br>    memset(&amp;wndclass, 0x00, sizeof(WNDCLASS)); <br> <br>    UnregisterClass(szAppName, hInst); <br>    UnregisterClass((LPSTR) "MazeDrawWindow",hInst); <br>    UnregisterClass((LPSTR) "TopViewWindow",hInst); <br>    UnregisterClass((LPSTR) "TextWindow",hInst); <br>    UnregisterClass((LPSTR) "ScoreWindow",hInst); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: OneTimeInit() <br> <br>Inputs: none <br> <br>Outputs:none <br> <br>Abstract: <br>    This initialization routine is called the first time a game is started. <br>    It reads in the subgrids, initializes the network, makes a mailslot, <br>    and sets many of the global variables. <br>======================================================================*/ <br> <br>void OneTimeInit() <br>{ <br>    DWORD dwScratch,dwSize,dwType; <br>    HMENU hMenu; <br>    BOOL bRet; <br>    int i,j,k; <br>#ifdef WIN32 <br>    HKEY hKey; <br>#endif <br> <br>    if (!ReadSubGrids()) { <br>        MessageBox((HWND)NULL,GetStringRes(IDS_RDSGRDTXTFLFAIL), <br>GetStringRes2(IDS_INITFAIL), MB_ICONEXCLAMATION); <br>        } <br> <br> <br>    dwScratch = MAX_USERNAME_LENGTH; <br>    strcpy(ptSelf.cUserName,"&lt;A Player&gt;"); <br>    strcpy(ptSelf.cComputerName,"MachineName"); <br>    dwSize =MAX_COMPUTERNAME_LENGTH; <br>    ptSelf.ulID = 0; <br>    ptSelf.iPicNum = PIC_DEFAULT; <br>    ptSelf.iGridNum = SUBGRID_DEFAULT; <br> <br>    hMenu = GetMenu(hWndMain); <br>    EnableMenuItem(hMenu,IDM_F_STOP,MF_GRAYED); <br>    EnableMenuItem(hMenu,IDM_O_PAUSE,MF_GRAYED); <br> <br>#ifdef WIN32 <br>    if (!(bRet = GetUserName(ptSelf.cUserName,&amp;dwScratch))) { <br>        MessageBox((HWND)NULL,GetStringRes(IDS_GETUSRNMFAIL), <br>GetStringRes2(IDS_NETINIT), MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        } <br>    dwType = REG_SZ; <br>    RegOpenKeyEx(HKEY_LOCAL_MACHINE, <br>                 "SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName", <br>                 0, <br>                 KEY_READ, <br>                 &amp;hKey); <br>    RegQueryValueEx(hKey,"ComputerName",NULL,&amp;dwType, </code></pre>
<p>
</p>
<pre><code>ptSelf.cComputerName,&amp;dwSize); <br>    ptSelf.dwPID = GetCurrentProcessId(); <br>#endif <br>    ptSelf.ulID = MemCRC((LPSTR) &amp;ptSelf.ulID,(int) sizeof(ptSelf)); <br>    bDemoMode = FALSE; <br>    bDemoEnable = TRUE; <br>    iNumDrones = 10; <br>    iDroneSpeed = 2; <br>    iDroneMoveAlg = 1; <br>    bBitmapDraw = FALSE; <br>    bPlayerPrestretch = FALSE; <br>    bDronePrestretch = FALSE; <br>    for(i=0;i&lt;NUM_PICS;i++) { <br>        for (j=0;j&lt;MAX_DRAW_DIST;j++) { <br>            for(k=0;k&lt;4;k++) { <br>                PreStretch[i][j].P[k].hBitmap = (HBITMAP)NULL; <br>                PreStretch[i][j].M[k].hBitmap = (HBITMAP)NULL; <br>                } <br>            } <br>        } <br> <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: EachTimeInit() <br> <br>Inputs: none <br> <br>Outputs:none <br> <br>Abstract: <br>    This function is called each time a new game is started (initially, <br>    and any time after a STOP selection from the menu) This loads some <br>    bitmaps, changes the state on menu-items whose validity is changed by <br>    a game in progress, and resets some global variables. <br>======================================================================*/ <br> <br>void EachTimeInit( <br>    void <br>    ) <br>{ <br>    HMENU hMenu; <br> <br>    hMenu = GetMenu(hWndMain); <br> <br>    EnableMenuItem(hMenu,IDM_O_NET,MF_GRAYED); <br>    EnableMenuItem(hMenu,IDM_O_LOCAL,MF_GRAYED); <br>    EnableMenuItem(hMenu,IDM_O_PLAYERSET,MF_GRAYED); <br>    EnableMenuItem(hMenu,IDM_F_NEWGAME,MF_GRAYED); <br>    EnableMenuItem(hMenu,IDM_F_STOP,MF_ENABLED); <br>    EnableMenuItem(hMenu,IDM_O_PAUSE,MF_ENABLED); <br>    uiTimer = (UINT) NULL; <br>    ptDrones.next = NULL; <br>    fptPic.next = NULL; <br>    bSelfInSanct = TRUE; <br> <br>    hShotBM[0]=LoadBitmap(hInst,"SHOT1"); <br>    hShotBM[1]=LoadBitmap(hInst,"SHOT2"); <br>    hFadeBM[0]=LoadBitmap(hInst,"FADE1"); <br>    hFadeBM[1]=LoadBitmap(hInst,"FADE2"); <br> <br>    hMaze3DBM = (HBITMAP)NULL; <br>    hMazeDC = (HDC)NULL; <br>    iWhisperDist = 2; <br>    iShoutDist = 10; <br>    iPlayersKilled = iTimesKilled = iDronesKilled = 0; <br>    ptSelf.iScore = iKilledByDrones = 0; <br>    GamePaused = GameStarted = FALSE; <br>    Scores.next = NULL; <br> <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: OneTimeShutdown() <br> <br>Inputs: none <br> <br>Outputs:none <br> <br>Abstract: <br>    This function does NOTHING right now. It'll be called at the very <br>    end of everything. <br>======================================================================*/ <br> <br>void OneTimeShutdown( <br>    void <br>    ) <br>{ <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: EachTimeShutdown() <br> <br>Inputs: none <br> <br>Outputs:none <br> <br>Abstract: <br>    This function is called each time a STOP command is selected and <br>    approved. It changes menu items to the correct state, changes some <br>    global state variables, and notifies the network that we're quitting <br>    the game. <br>======================================================================*/ <br> <br>void EachTimeShutdown( <br>    void <br>    ) <br>{ <br>    HMENU hMenu; <br> <br>    hMenu = GetMenu(hWndMain); <br> <br>    DeleteObject(hShotBM[0]); <br>    DeleteObject(hShotBM[1]); <br>    DeleteObject(hFadeBM[0]); <br>    DeleteObject(hFadeBM[1]); <br>    DeleteObject(hMaze3DBM); <br>    DeleteDC(hMazeDC); <br> <br> <br>    EnableMenuItem(hMenu,IDM_O_NET,MF_ENABLED); <br>    EnableMenuItem(hMenu,IDM_O_LOCAL,MF_ENABLED); <br>    EnableMenuItem(hMenu,IDM_O_PLAYERSET,MF_ENABLED); <br>    EnableMenuItem(hMenu,IDM_F_STOP,MF_GRAYED); <br>    EnableMenuItem(hMenu,IDM_O_PAUSE,MF_GRAYED); <br>    EnableMenuItem(hMenu,IDM_F_NEWGAME,MF_ENABLED); <br> <br> <br>    if (!SendNetMessage(0,0,NULL,NP_LEAVINGGAME)) { <br>        MessageBox((HWND)NULL,GetStringRes(IDS_SNDQUITPCKTFAIL),"EachTimeShutDown", <br>                   MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        } <br> <br>    bNetworked = TRUE; <br>    GameStarted = FALSE; <br> <br>    iNumDrones = 0; <br>    iDroneSpeed = 0; <br>    iDroneMoveAlg = 1; <br>    bBitmapDraw = FALSE; <br> <br>    return; <br>} <br> <br> <br> <br> <br>/*===================================================================== <br>Function: StartDemo() <br> <br>Inputs: none <br> <br>Outputs:none <br> <br>Abstract: <br>    This function is responsible for causing MazeLords to enter Demo <br>    mode. <br>======================================================================*/ <br> <br>void StartDemo( <br>    void <br>    ) <br>{ <br>    bDemoMode = TRUE; <br>    SetWindowText(hWndMain,GetStringRes(IDS_DEMOMODE)); <br>    SendMessage(hWndMain,WM_COMMAND,MAKELONG(IDM_F_NEWGAME,0),(LPARAM)NULL); <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: StopDemo() <br> <br>Inputs: none <br> <br>Outputs:none <br> <br>Abstract: <br>    This function is responsible for ending the mazelords demo and <br>    putting it into a state that the user can interact with. <br>======================================================================*/ <br> <br> <br>void StopDemo( <br>    void <br>    ) <br>{ <br>    bDemoMode = FALSE; <br>    SendMessage(hWndScore,WM_CLOSE,0,0); <br>    SendMessage(hWndText,WM_CLOSE,0,0); <br>    SendMessage(hWndTopView,WM_CLOSE,0,0); <br>    SendMessage(hWndMaze,WM_CLOSE,0,0); <br>    EachTimeShutdown(); <br>    iNumDrones  = 10; <br>    iDroneSpeed = 2; <br>    bDemoEnable = TRUE; <br>    UserIntCount++; <br>    SetWindowText(hWndMain,"Maze Lords"); <br>    return; <br>} <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Load the resource string with the ID given, and return a <br>*               pointer to it.  Notice that the buffer is common memory so <br>*               the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> <br>LPTSTR   GetStringRes2 (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
