<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRONES.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4967"></a>DRONES.C</h2>
<pre><code>/*********************************************************************** <br>File:   Drones.c <br> <br> <br>Abstract: <br> <br>    This file contains the functions which are associated with moving and <br>    drawing drones. <br> <br> <br>Contents: <br> <br>    DeletePlayer() -- Free a record of type PlayerType <br>    NewPlayer() -- Create &amp; initialize a record of type PlayerType <br>    RandRange() -- return a random number in a given range <br>    InitDrones() -- Add/remove drone entries from the list of drones <br>    MoveDrone() -- Timer callback to change drone positions in data struct <br> <br> <br>************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include &lt;mmsystem.h&gt; <br> <br> <br> <br>/*===================================================================== <br>Function: DeletePlayer() <br> <br>Inputs: Pointer to record to delete <br> <br>Outputs: Returns pointer to next record in list <br> <br>Abstract: <br>    Returns pointer to next element to facilitate maintenance of <br>    linked lists <br>======================================================================*/ <br> <br>PlayerType FAR *DeletePlayer( <br>    PlayerType FAR *ptTrav <br>    ) <br>{ <br>    PlayerType FAR *ptHold; <br>    HGLOBAL hMem; <br> <br>    ptHold = NULL; <br>    if (ptTrav != NULL) { <br>        ptHold = ptTrav-&gt;next; <br>        hMem = (HGLOBAL) GlobalHandle(SELECTOROF( ptTrav)); <br>        GlobalUnlock(hMem); <br>        GlobalFree(hMem); <br>        } <br> <br>    return(ptHold); <br>} <br> <br> <br>/*===================================================================== <br>Function: NewPlayer() <br> <br>Inputs: Data elements of PlayerType element to be created <br> <br>Outputs: Pointer to newly created &amp; initialize PlayerType record <br> <br>Abstract: <br>    Needs no explanation <br>======================================================================*/ <br> <br>PlayerType FAR *NewPlayer( <br>    unsigned long ulID,     // Unique identifier for this player struct <br>    DWORD dwPID,            // process id of window <br>    LPSTR cUserName,        // Name of the player <br>    LPSTR cComputerName,    // Name of the computer player is on <br>    int ix,                 // Maze X- coordinate of player <br>    int iy,                 // Maze Y- coordinate of player <br>    BYTE Facing,            // Facing of player in maze <br>    int iScore,             // Points player is reporting <br>    int iPicNum,            // Picture number to use for player <br>    int iGridNum,           // Home grid # <br>    int iGridxPos,          // Home grid x-position (in grid coordinates <br>    int iGridyPos,          // Home grid y-position (in grid coordinates <br>    PlayerType FAR *next    // for linked list maintenance <br>    ) <br>{ <br>    PlayerType FAR *ptRet; <br>    HGLOBAL hMem; <br> <br>    hMem = GlobalAlloc(GHND,sizeof(PlayerType)); <br>    ptRet = (PlayerType FAR *) GlobalLock(hMem); <br> <br>    if (ptRet == NULL) { <br>        MessageBox((HWND) NULL,GetStringRes(IDS_MALLOCFAILABT),"NewPlayer", <br>               MB_APPLMODAL|MB_ICONEXCLAMATION); <br>        PostMessage(hWndMain,WM_CLOSE,0,0); <br>        } <br>    else { <br>        ptRet-&gt;ulID = ulID; <br>        ptRet-&gt;dwPID = dwPID; <br>        lstrcpy(ptRet-&gt;cUserName,cUserName); <br>        lstrcpy(ptRet-&gt;cComputerName,cComputerName); <br>        ptRet-&gt;Pos.ix = ix; <br>        ptRet-&gt;Pos.iy = iy; <br>        ptRet-&gt;Pos.Facing = Facing; <br>        ptRet-&gt;Drawn = FALSE; <br>        ptRet-&gt;iScore = iScore; <br>        ptRet-&gt;iPicNum = iPicNum; <br>        ptRet-&gt;iGridNum = iGridNum; <br>        ptRet-&gt;pGridLoc.x = iGridxPos; <br>        ptRet-&gt;pGridLoc.y = iGridyPos; <br> <br>        ptRet-&gt;next = next; <br>        } <br> <br>    return(ptRet); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: RandRange() <br> <br>Inputs: Low, high end of range return value should be in <br> <br>Outputs: returns number between iLow and iHigh inclusive <br> <br>Abstract: <br>    Since this is using rand() it is not so random for a new process. <br>======================================================================*/ <br> <br>int RandRange( <br>    int iLow, <br>    int iHigh <br>    ) <br>{ <br>    float f; <br> <br>    f = ((float) rand())/((float) RAND_MAX); <br> <br>    return((int) (iLow+f*(iHigh - iLow + 1))); <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: InitDrones() <br> <br>Inputs: Globals only <br> <br>Outputs: none <br> <br>Abstract: <br>    Performs PART of drone initialization whenever # of drones or their <br>    speed is changed. This will add or delete drones from the drone list, <br>    as required. <br>======================================================================*/ <br> <br>void InitDrones( <br>    ) <br>{ <br>    int i,iCurNumDrones; <br>    BYTE b; <br>    PlayerType FAR *ptTrav; <br>    char buff[20]; <br> <br> <br>    b = NORTH; <br> <br>    // <br>    // If the number of drones has changed, but drones were <br>    // already active, we need to take a different course of <br>    // action, ie add or delete drones from active drones, <br>    // rather than creating completely new ones. <br>    // <br> <br>    // <br>    // Find number of drones currently active. <br>    // <br>    iCurNumDrones = 0; <br>    ptTrav = &amp;ptDrones; <br>    while (ptTrav-&gt;next != NULL) { <br>        iCurNumDrones++; <br>        ptTrav = ptTrav-&gt;next; <br>        } <br> <br>    // <br>    // read in/ remove the drone bitmaps, as necessary <br>    // <br>    if (iNumDrones &gt; 0) { <br>        AddPic(PIC_DRONE); <br>        } <br>    else { <br>        DelPic(PIC_DRONE); <br>        } <br> <br>    // <br>    // If more drones have been added, we need to create them <br>    // <br>    for(i=iCurNumDrones;i&lt;iNumDrones;i++) { <br>        sprintf(buff,GetStringRes(IDS_FMT_DRONE),i+1); <br>        ptTrav-&gt;next = NewPlayer(i,i,buff,ptSelf.cComputerName, <br>                    RandRange(5*X_CELLS_PER_SUBGRID,8*X_CELLS_PER_SUBGRID-1), <br>                    RandRange(7*Y_CELLS_PER_SUBGRID,8*Y_CELLS_PER_SUBGRID-1), <br>                    b,0,PIC_DRONE,0,0,0,ptTrav-&gt;next); <br>        b = (BYTE) ((b*2 &gt; 0x8) ? 0x1 : b*2); <br>        } <br> <br>    // <br>    // Or, delete drones as needed <br>    // <br>    for(i=iNumDrones; i &lt; iCurNumDrones;i++) { <br>        ptDrones.next = DeletePlayer(ptDrones.next); <br>        } <br> <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function: MoveDrone() <br> <br>Inputs: Ignored except for hWnd, handle to current window <br> <br>Outputs:returns success/failure <br> <br>Abstract: <br>    This is a timer callback function which modifies the position of the <br>    drones in their data structures. After their positions have been changed <br>    in their record, a message is sent to the 3-d window telling it that <br>    drones need to be redrawn. <br>======================================================================*/ <br> <br>LRESULT CALLBACK MoveDrone( <br>    HWND hWnd, <br>    UINT wMsg, <br>    UINT idTimer, <br>    DWORD dwTime <br>    ) <br>{ <br>    int x,y; <br>    BYTE b1,b2,dForward,dBack,dLeft,dRight; <br>    BOOL blocked; <br>    PlayerType FAR *ptTrav; <br>    PositionType ptPos; <br>    char cBuff[132]; <br>    LPRECT rUpd; <br>    HANDLE hMem; <br>    static DWORD dwCallCount=0; <br> <br>    dwCallCount++; <br> <br>    // <br>    // If we're in demo mode, use this callback to move US! <br>    // <br>    if (bDemoMode) { <br> <br>        x=ptSelf.Pos.ix; <br>        y=ptSelf.Pos.iy; <br>        dForward = ptSelf.Pos.Facing; <br>        dBack = BACK_TO_ABS(dForward); <br>        dLeft = LEFT_TO_ABS(dForward); <br>        dRight = RIGHT_TO_ABS(dForward); <br>        b1 = bMaze[x][y]; <br>        b2 = bMaze[ADJ_X(x,dForward)][ADJ_Y(y,dForward)]; <br>        blocked = FALSE; <br>        if ((b1&amp;dForward)||(b2&amp;dBack)) { <br>            blocked = TRUE; <br>            b2 = bMaze[ADJ_X(x,dRight)][ADJ_Y(y,dRight)]; <br>            if ((b1&amp;dLeft)||(b2&amp;dRight)) { <br>                b2 = bMaze[ADJ_X(x,dLeft)][ADJ_Y(y,dLeft)]; <br>                if ((b1&amp;dLeft)||(b2&amp;dRight)) { <br>                    x = RIGHT; <br>                    } <br>                else { <br>                    x = LEFT; <br>                    } <br>                } <br>            else { <br>                x = RIGHT; <br>                } <br>            } <br>        else { <br>            x = FORWARD; <br>            } <br> <br>        y = RandRange(1,11); <br> <br>        switch (y) { <br>            case 8: <br>                x = LEFT; <br>                break; <br>            case 9: <br>                x = RIGHT; <br>                break; <br>            case 10: <br>                x = FORWARD; <br>                break; <br>            case 11: <br>                x = BACK; <br>                break; <br>            } <br> <br>        switch (x) { <br>            case LEFT: <br>                PostMessage(hWndMaze,WM_KEYDOWN,VK_LEFT,0); <br>                break; <br>            case RIGHT: <br>                PostMessage(hWndMaze,WM_KEYDOWN,VK_RIGHT,0); <br>                break; <br>            case FORWARD: <br>                PostMessage(hWndMaze,WM_KEYDOWN,VK_UP,0); <br>                break; <br>            } <br> <br>        if ((RandRange(1,3) == 3)&amp;&amp;(!blocked)) { <br>            PostMessage(hWndMaze,WM_KEYDOWN,VK_SPACE,0); <br>            } <br>        } <br> <br>    hMem = GlobalAlloc(GHND,sizeof(RECT)); <br>    rUpd = (LPRECT) GlobalLock(hMem); <br>    if (rUpd == NULL) { <br>        MessageBox((HWND)NULL,GetStringRes(IDS_RECTALLOCFAIL),"MoveDrone", <br>               MB_APPLMODAL); <br>        PostMessage(hWndMain,WM_CLOSE,0,0); <br>        } <br> <br>    rUpd-&gt;right = rMaze.left; <br>    rUpd-&gt;left = rMaze.right; <br>    rUpd-&gt;top = rMaze.bottom; <br>    rUpd-&gt;bottom = rMaze.top; <br> <br>    ptTrav = &amp;ptDrones; <br>    while ((ptTrav-&gt;next != NULL)&amp;&amp;(!GamePaused)) { <br>        // <br>        // Only use every 2nd drone move in demo mode <br>        // <br>        if (bDemoMode &amp;&amp; (dwCallCount % 2)) { <br>            break; <br>            } <br> <br>        ptTrav = ptTrav-&gt;next; <br> <br>        if (ptTrav-&gt;Drawn) { <br>            rUpd-&gt;right = (rUpd-&gt;right &gt; ptTrav-&gt;rDrawn.right) ? rUpd-&gt;right : ptTrav-&gt;rDrawn.right; <br>            rUpd-&gt;left = (rUpd-&gt;left &lt; ptTrav-&gt;rDrawn.left) ? rUpd-&gt;left : ptTrav-&gt;rDrawn.left; <br>            rUpd-&gt;top = (rUpd-&gt;top &lt; ptTrav-&gt;rDrawn.top) ? rUpd-&gt;top : ptTrav-&gt;rDrawn.top; <br>            rUpd-&gt;bottom = (rUpd-&gt;bottom &gt; ptTrav-&gt;rDrawn.bottom) ? rUpd-&gt;bottom : ptTrav-&gt;rDrawn.bottom; <br>            ptTrav-&gt;Drawn=FALSE; <br>            } <br>        x=ptTrav-&gt;Pos.ix; <br>        y=ptTrav-&gt;Pos.iy; <br>        dForward = ptTrav-&gt;Pos.Facing; <br>        dBack = BACK_TO_ABS(dForward); <br>        dLeft = LEFT_TO_ABS(dForward); <br>        dRight = RIGHT_TO_ABS(dForward); <br>        ptPos.ix = x; <br>        ptPos.iy = y; <br>        ptPos.Facing = dForward; <br>        b1 = bMaze[x][y]; <br>        b2 = bMaze[ADJ_X(x,dForward)][ADJ_Y(y,dForward)]; <br>        if ((b1&amp;dForward)||(b2&amp;dBack)) { <br>            b2 = bMaze[ADJ_X(x,dLeft)][ADJ_Y(y,dLeft)]; <br>            if ((b1&amp;dLeft)||(b2&amp;dRight)) { <br>                b2 = bMaze[ADJ_X(x,dRight)][ADJ_Y(y,dRight)]; <br>                if ((b1&amp;dRight)||(b2&amp;dLeft)) { <br>                    ptPos.Facing = LEFT_TO_ABS(ptTrav-&gt;Pos.Facing); <br>                    } <br>                else { <br>                    ptPos.Facing = RIGHT_TO_ABS(ptTrav-&gt;Pos.Facing); <br>                    } <br>                } <br>            else { <br>                ptPos.Facing = LEFT_TO_ABS(ptTrav-&gt;Pos.Facing); <br>                } <br>            } <br>        else { <br>            if (RandRange(1,10) == 1) { <br>                ptPos.Facing = LEFT_TO_ABS(ptTrav-&gt;Pos.Facing); <br>                } <br>            else { <br>                if (RandRange(1,10) == 1) { <br>                    ptPos.Facing = RIGHT_TO_ABS(ptTrav-&gt;Pos.Facing); <br>                    } <br>                else { <br>                    ptPos.ix = ADJ_X(ptTrav-&gt;Pos.ix,dForward); <br>                    ptPos.iy = ADJ_Y(ptTrav-&gt;Pos.iy,dForward); <br>                    } <br>                } <br>            } <br> <br>        ptTrav-&gt;Pos = ptPos; <br> <br>        // <br>        // If the drone has homed in on us, we are dead! <br>        // <br>        if ((!InSanctuary(&amp;ptSelf.Pos))&amp;&amp; <br>            (ptSelf.Pos.ix == ptPos.ix)&amp;&amp;(ptSelf.Pos.iy == ptPos.iy) <br>           ) { <br>            sprintf(cBuff,GetStringRes(IDS_FMT_RUNDOWN),ptTrav-&gt;cUserName); <br>            PrintTextLine(cBuff); <br>            ptSelf.iScore -=(iDroneSpeed) ? 36/iDroneSpeed/iDroneSpeed : 72; <br>            KillSelf(); <br>            SendNetMessage(0,0,NULL,NP_SCORE); <br>            iKilledByDrones++; <br>            break; <br>            } <br>        } <br> <br>    PostMessage(hWndMaze,WM_COMMAND,IDM_DRAWDRONES,(DWORD) rUpd); <br> <br>    return(0); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
