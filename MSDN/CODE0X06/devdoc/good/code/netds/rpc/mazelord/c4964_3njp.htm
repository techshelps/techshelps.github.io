<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NETWORK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4975"></a>NETWORK.C</h2>
<pre><code>/*********************************************************************** <br>File:   Network.c <br> <br>Abstract: <br> <br>    This is the network communications module for MazeLords. It contains functions <br>    to implement mailslots, as well as the various protocols and so-on required <br>    for communications. <br> <br> <br>Contents: <br> <br>    MemCRC() -- Generates a 'unique' LONG for different data structures <br>    SendNetMessage() -- Transmit a pre-made structure to other players <br>    MailWatchThread() -- Thread process to watch for new mail <br>    InitNetwork() -- Create mailslot, Send out ID message to network. <br>    ProcessNewMail() -- Process newly recieved data packets <br> <br> <br>************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include "winmaze.h" <br>#include "mazproto.h" <br>#include "net.h" <br>#include "crctable.h" <br> <br> <br> <br>/*===================================================================== <br>Function:   MemCRC() <br> <br>Inputs:     Buffer &amp; buffer length to CRC <br> <br>Outputs:    Returns single Long corresponding to CRC for structure <br> <br>Abstract: <br>    The CRC should provide a unique ID for each player, provided ANY <br>    information in their data structures is unique. Each player is <br>    responsible for generating their ID &amp; transmitting it to the other <br>    players. <br>======================================================================*/ <br> <br>unsigned long MemCRC( <br>    LPSTR buffer, <br>    int bytes <br>    ) <br>{ <br>    unsigned long crc = 0xFFFFFFFF; <br>    LPSTR p; <br> <br>    for ( p = buffer; bytes &gt; 0; bytes-- ) { <br>        crc = ( crc &gt;&gt; 8 ) ^ CRCtable[(unsigned char) ((unsigned char) crc ^ *p++ ) ]; <br>        } <br> <br>    return ( crc ^ 0xFFFFFFFF ); <br>} <br> <br> <br>/*===================================================================== <br>Function:   SendNetMessage() <br> <br>Inputs:     Source, destination, structure to send, packet type <br> <br>Outputs:    Returns success/failure <br> <br>Abstract: <br>    SendNetMessage will send a message to all mazelords mailslots in the <br>    current domain.  Note that this message is broadcast once. It is up <br>    to the individual recipients to decide whether it is addressed to them, <br>    or a general message (sent to -1). <br>======================================================================*/ <br> <br>BOOL SendNetMessage( <br>    unsigned long ulSender, <br>    unsigned long ulDest, <br>    LPVOID lpStruct, <br>    DWORD dwPacketType <br>    ) <br>{ <br>    BOOL bResult=TRUE; <br>    HANDLE hFile; <br>    DWORD dwScratch,dwLength; <br>    char cBuff[MAX_PACKET_SIZE]; <br>    LPSTR lpStr; <br>    NetPacketType FAR *lpN; <br>    PlayerInfoType FAR *lppiInfo,FAR *lppiInfo2; <br>    PositionType FAR *lpptPos,FAR *lpptPos2; <br>    int FAR *iScore; <br>    IntoneType FAR *itIntone; <br> <br>    if (!bNetworked) { <br>        return(TRUE); <br>        } <br> <br>    lpN = (NetPacketType FAR *) cBuff; <br>    lpN-&gt;ulSender = (ulSender)? ulSender : ptSelf.ulID; <br>    lpN-&gt;ulDest = ulDest; <br>    lpN-&gt;dwPacketType = dwPacketType; <br>    dwLength = sizeof(NetPacketType); <br> <br>    // <br>    // determine size, type of packet and fill out info accordingly. <br>    // <br>    lpStr = (LPSTR) &amp;lpN-&gt;cData; <br> <br>    switch(dwPacketType) { <br> <br>        case NP_NEWPLAYER: <br>            lppiInfo = (PlayerInfoType FAR *) lpStr; <br>            lppiInfo2 = (PlayerInfoType FAR *) lpStruct; <br>            *lppiInfo = *lppiInfo2; <br>            dwLength += sizeof(PlayerInfoType); <br>            break; <br> <br>        case NP_REQUESTIDENTITY: <br>        case NP_LEAVINGGAME: <br>        case NP_HITCONFIRM: <br>            break; <br> <br>        case NP_MOVETO: <br>        case NP_SHOTFIRED: <br>            lpptPos = (PositionType FAR *) lpStr; <br>            lpptPos2 = (PositionType FAR *) lpStruct; <br>            *lpptPos = *lpptPos2; <br>            dwLength += sizeof(PositionType); <br>            break; <br> <br>        case NP_SCORE: <br>            iScore = (int FAR *) lpStr; <br>            *iScore = ptSelf.iScore; <br>            dwLength += sizeof(int); <br>            break; <br> <br>        case NP_INTONE: <br>            itIntone = (IntoneType FAR *) lpStr; <br>            *itIntone = *((IntoneType FAR *) lpStruct); <br>            dwLength += sizeof(IntoneType); <br>            dwLength -= (131 - itIntone-&gt;dwLen); <br>            break; <br> <br>        default: <br>            MessageBox((HWND)NULL,GetStringRes(IDS_BADPCKTXMITFAIL),"SendNetMessage", <br>                       MB_ICONEXCLAMATION|MB_APPLMODAL); <br>            break; <br>        } <br> <br>#ifdef WIN32 <br>    hFile = CreateFile("\\\\*\\mailslot\\mazemslt", <br>                     GENERIC_WRITE, <br>                     FILE_SHARE_READ, <br>                     NULL, <br>                     OPEN_EXISTING, <br>                     FILE_ATTRIBUTE_NORMAL, <br>                     NULL); <br> <br>    bResult = (hFile != INVALID_HANDLE_VALUE); <br> <br>    bResult = bResult &amp;&amp; <br>              WriteFile(hFile,cBuff,dwLength+1,&amp;dwScratch,NULL); <br> <br>    return(bResult &amp;&amp; CloseHandle(hFile)); <br>#else // else it's any operating system except WIN32 <br>    return(TRUE); <br>#endif <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:   MailWatchThread() <br> <br>Inputs:     Handle to mailslot to watch <br> <br>Outputs:    none <br> <br>Abstract: <br>    This is a thread which is spawned. As soon as it sees a mail message <br>    is queued up, it sends a message to the main window notifying Maze <br>    Lords that new mail has been received.  This is done 5 times a second. <br>======================================================================*/ <br> <br>void MailWatchThread( <br>    HANDLE hMailSlot <br>    ) <br>{ <br>    DWORD cbMaxMsg,cbNextMsg,cMsg,dwReadTimeout; <br>#ifdef WIN32 <br>    while(TRUE) { <br> <br>        Sleep(200); <br>        if (GetMailslotInfo(hMailSlot,&amp;cbMaxMsg,&amp;cbNextMsg,&amp;cMsg,&amp;dwReadTimeout)) { <br>            if (cMsg &gt; 0) { <br>                PostMessage(hWndMain,WM_COMMAND,IDT_NEWMAIL,0); <br>                } <br>            } <br>        } <br>#endif <br> <br>    // <br>    // We shouldn't ever get here. <br>    // <br>    return; <br>} <br> <br> <br> <br>/*===================================================================== <br>Function:   InitNetwork() <br> <br>Inputs:     none <br> <br>Outputs:    returns success/failure <br> <br>Abstract: <br>    InitNetwork takes care of creating a mailslot for this user, and <br>    sending out a packet saying that we're joining the game. <br>    FALSE indicates that there was a fatal error starting the network. <br>======================================================================*/ <br> <br>BOOL InitNetwork( <br>    void <br>    ) <br>{ <br>    DWORD dwScratch; <br>    BOOL bRet; <br>    PlayerInfoType ptPlayScr; <br> <br>    bRet = TRUE; <br> <br>    // <br>    // initialize player list <br>    // <br>    ptPlayers.next = (PlayerType FAR *)NULL; <br> <br>    if (!bNetworked) { <br>        hMailSlot = NULL; <br>        return(TRUE); <br>        } <br> <br>#ifdef WIN32 <br>    hMailSlot = CreateMailslot("\\\\.\\mailslot\\mazemslt",0,0,NULL); <br>    if (hMailSlot == INVALID_HANDLE_VALUE) { <br>        MessageBox(NULL,GetStringRes(IDS_CREMSLOTFAIL), <br>GetStringRes2(IDS_NETINIT), MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        bRet = FALSE; <br>        } <br> <br>    if (! CreateThread((LPSECURITY_ATTRIBUTES) NULL, <br>                       0, <br>                       (LPTHREAD_START_ROUTINE)MailWatchThread, <br>                       (LPVOID)hMailSlot, <br>                       0,&amp;dwScratch)) { <br>        MessageBox(NULL,GetStringRes(IDS_CREMWATCHTHRFAIL), <br>GetStringRes2(IDS_NETINIT), MB_ICONEXCLAMATION|MB_APPLMODAL); <br>        bRet = FALSE; <br>        } <br>#endif <br>    ptPlayScr.ulID = ptSelf.ulID; <br>    ptPlayScr.dwPID = ptSelf.dwPID; <br>    lstrcpy(ptPlayScr.cUserName,ptSelf.cUserName); <br>    lstrcpy(ptPlayScr.cComputerName,ptSelf.cComputerName); <br>    ptPlayScr.ix = ptSelf.Pos.ix; <br>    ptPlayScr.iy = ptSelf.Pos.iy; <br>    ptPlayScr.bFacing = ptSelf.Pos.Facing; <br>    ptPlayScr.iScore = ptSelf.iScore; <br>    ptPlayScr.iPicNum = ptSelf.iPicNum; <br>    ptPlayScr.iGridNum = ptSelf.iGridNum; <br>    ptPlayScr.pGridLoc = ptSelf.pGridLoc; <br> <br>    return(bRet&amp;&amp;SendNetMessage(0,0,(LPVOID) &amp;ptPlayScr,NP_NEWPLAYER)); <br>} <br> <br> <br>/*===================================================================== <br>Function:   ProcessNewMail() <br> <br>Inputs:     none <br> <br>Outputs:    none <br> <br>Abstract: <br>    ProcessNewMail is responsible for updating character positions, asking <br>    for more information, etc. <br>======================================================================*/ <br> <br>void ProcessNewMail( <br>    void <br>    ) <br>{ <br>    DWORD cbMaxMsg,cbNextMsg,cMsg,dwReadTimeout; <br>    NetPacketType FAR *NPkt; <br>    PlayerInfoType FAR *piPlayerPacket,piScratch; <br>    PlayerType FAR *ptTrav; <br>    PositionType FAR *ptPosPacket; <br>    BOOL bFound,bDrawMessageSent; <br>    int ix,iy; <br>    BYTE bSquare1, bSquare2,Facing; <br>    char cBuff[257],cNetMessBuff[400]; <br>    int FAR *iScore; <br>    IntoneType FAR *itIntone; <br> <br>#ifdef WIN32 <br>    GetMailslotInfo(hMailSlot,&amp;cbMaxMsg,&amp;cbNextMsg,&amp;cMsg,&amp;dwReadTimeout); <br>    bDrawMessageSent = FALSE; <br> <br>    while (cMsg) { <br>        if (!ReadFile(hMailSlot,cNetMessBuff,cbNextMsg,&amp;cbMaxMsg,(LPOVERLAPPED) NULL)) { <br>            MessageBox(NULL,GetStringRes(IDS_RDMSLOTFAIL),"ProcessNewMail", <br>                       MB_ICONEXCLAMATION|MB_APPLMODAL); <br>            } <br> <br>        NPkt = (NetPacketType FAR *) cNetMessBuff; <br> <br>        // <br>        // Don't process the message if it's one of our own <br>        // <br>        if ((NPkt-&gt;ulSender != ptSelf.ulID)&amp;&amp; <br>            ((NPkt-&gt;ulDest == ptSelf.ulID)||(NPkt-&gt;ulDest == 0)) <br>           ) { <br> <br>            piPlayerPacket = (PlayerInfoType FAR *) &amp;(NPkt-&gt;cData); <br>            ptPosPacket = (PositionType FAR *) &amp;(NPkt-&gt;cData); <br>            iScore = (int FAR *) &amp;(NPkt-&gt;cData); <br>            itIntone = (IntoneType FAR *) &amp;(NPkt-&gt;cData); <br> <br>            bFound = FALSE; <br>            ptTrav = &amp;ptPlayers; <br> <br>            while (ptTrav-&gt;next != NULL) { <br>                if (ptTrav-&gt;next-&gt;ulID == NPkt-&gt;ulSender) { <br>                    bFound = TRUE; <br>                    break; <br>                    } <br>                ptTrav = ptTrav-&gt;next; <br>                } <br> <br>            if ((!bFound)&amp;&amp;(NPkt-&gt;dwPacketType != NP_NEWPLAYER)) { <br>                if(!SendNetMessage(0,NPkt-&gt;ulSender,NULL,NP_REQUESTIDENTITY)) { <br>                    MessageBox(NULL,GetStringRes(IDS_SNDPCKTFAIL),"ProcessNewMail", <br>                               MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                    } <br>                } <br> <br>            switch (NPkt-&gt;dwPacketType) { <br> <br>                case (NP_NEWPLAYER): <br>                    if (!bFound) { <br>                        ptTrav-&gt;next = NewPlayer(piPlayerPacket-&gt;ulID, <br>                                     piPlayerPacket-&gt;dwPID, <br>                                     piPlayerPacket-&gt;cUserName, <br>                                     piPlayerPacket-&gt;cComputerName, <br>                                     piPlayerPacket-&gt;ix, <br>                                     piPlayerPacket-&gt;iy, <br>                                     piPlayerPacket-&gt;bFacing, <br>                                     piPlayerPacket-&gt;iScore, <br>                                     piPlayerPacket-&gt;iPicNum, <br>                                     piPlayerPacket-&gt;iGridNum, <br>                                     piPlayerPacket-&gt;pGridLoc.x, <br>                                     piPlayerPacket-&gt;pGridLoc.y, <br>                                     ptTrav-&gt;next); <br>                        if (!AddPic(piPlayerPacket-&gt;iPicNum)) { <br>                            ptTrav-&gt;next-&gt;iPicNum = PIC_DEFAULT; <br>                            sprintf(cBuff, GetStringRes(IDS_FMT_BADPICNUM), <br>                                    piPlayerPacket-&gt;iPicNum,piPlayerPacket-&gt;cComputerName); <br>                            PrintTextLine(cBuff); <br>                            AddPic(PIC_DEFAULT); <br>                            } <br> <br>                        // <br>                        // After we add the user to our own database, <br>                        // let him know we exist. <br>                        // <br>                        sprintf(cBuff,GetStringRes(IDS_FMT_JOIN),ptTrav-&gt;next-&gt;cUserName); <br>                        PrintTextLine(cBuff); <br> <br>                        piScratch.ulID = ptSelf.ulID; <br>                        piScratch.dwPID = ptSelf.dwPID; <br>                        strcpy(piScratch.cUserName,ptSelf.cUserName); <br>                        strcpy(piScratch.cComputerName,ptSelf.cComputerName); <br>                        piScratch.ix = ptSelf.Pos.ix; <br>                        piScratch.iy = ptSelf.Pos.iy; <br>                        piScratch.bFacing = ptSelf.Pos.Facing; <br>                        piScratch.iScore = ptSelf.iScore; <br>                        piScratch.iPicNum = ptSelf.iPicNum; <br>                        piScratch.iGridNum = ptSelf.iGridNum; <br>                        piScratch.pGridLoc = ptSelf.pGridLoc; <br>                        if (!SendNetMessage(0,NPkt-&gt;ulSender,&amp;piScratch,NP_NEWPLAYER)) { <br>                            MessageBox(NULL,GetStringRes(IDS_SNDPCKTFAIL),"ProcessNewMail", <br>                                             MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                            } <br> <br>                        // <br>                        // Finally, do a redraw to make sure if he's in <br>                        // line of sight we see him. */ <br>                        // <br>                        PostMessage(hWndMaze,WM_COMMAND,IDM_DRAWPLAYERS,0); <br>                        PostMessage(hWndScore,WM_COMMAND,WC_ADDSCORE,ptTrav-&gt;next-&gt;ulID); <br>                        } <br>                    break; <br> <br>                case (NP_REQUESTIDENTITY): <br>                    piScratch.ulID = ptSelf.ulID; <br>                    piScratch.dwPID = ptSelf.dwPID; <br>                    strcpy(piScratch.cUserName,ptSelf.cUserName); <br>                    strcpy(piScratch.cComputerName,ptSelf.cComputerName); <br>                    piScratch.ix = ptSelf.Pos.ix; <br>                    piScratch.iy = ptSelf.Pos.iy; <br>                    piScratch.bFacing = ptSelf.Pos.Facing; <br>                    piScratch.iScore = ptSelf.iScore; <br>                    piScratch.iPicNum = ptSelf.iPicNum; <br>                    piScratch.iGridNum = ptSelf.iGridNum; <br>                    piScratch.pGridLoc = ptSelf.pGridLoc; <br>                    if (!SendNetMessage(0,NPkt-&gt;ulSender,&amp;piScratch,NP_NEWPLAYER)) { <br>                        MessageBox(NULL,GetStringRes(IDS_SNDPCKTFAIL),"ProcessNewMail", <br>                                             MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                        } <br> <br>                    break; <br> <br>                case (NP_MOVETO): <br>                    if (bFound) { <br>                        ptTrav-&gt;next-&gt;Pos = *ptPosPacket; <br>                        if (ptTrav-&gt;next-&gt;Drawn) { <br>                            if (!bBitmapDraw) { <br>                                InvalidateRect(hWndMaze,&amp;ptTrav-&gt;next-&gt;rDrawn,TRUE); <br>                                } <br>// <br>//BUGBUG -- drawing problem for bitmaps <br>// <br>                            ptTrav-&gt;next-&gt;Drawn=FALSE; <br>                            } <br>                        else { <br>                            if (!bDrawMessageSent) { <br>                                PostMessage(hWndMaze,WM_COMMAND,IDM_DRAWPLAYERS,0); <br>                                bDrawMessageSent = TRUE; <br>                                } <br>                            } <br>                        PostMessage(hWndScore,WM_COMMAND,WC_UPDATEDIRECTION,ptTrav-&gt;next-&gt;ulID); <br>                        } <br>                    break; <br> <br>                case (NP_SHOTFIRED): <br>                    if (bFound) { <br> <br>                        PlaySound("othrlasr.wav",NULL,SND_FILENAME|SND_ASYNC); <br> <br>                        // <br>                        // if the shot was fired in the same 'x' or 'y' <br>                        // plane, we may have been hit! <br>                        // <br>                        if ((ptPosPacket-&gt;ix == ptSelf.Pos.ix)|| <br>                            (ptPosPacket-&gt;iy == ptSelf.Pos.iy) <br>                           ) { <br> <br>                            ix = ptPosPacket-&gt;ix; <br>                            iy = ptPosPacket-&gt;iy; <br>                            Facing = ptPosPacket-&gt;Facing; <br> <br>                            bSquare2 = bMaze[ix][iy]; <br> <br>                            do { <br>                                // <br>                                // if we're hit, handle it! <br>                                // <br>                                if ((!InSanctuary(&amp;ptSelf.Pos))&amp;&amp;(ptSelf.Pos.ix == ix)&amp;&amp;(ptSelf.Pos.iy == iy)) { <br>                                    if (!SendNetMessage(0,NPkt-&gt;ulSender,NULL,NP_HITCONFIRM)) { <br>                                        MessageBox(NULL,GetStringRes(IDS_SNDPCKTFAIL),"MazeWndProc", <br>                                             MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                                        } <br>                                    sprintf(cBuff,GetStringRes(IDS_FMT_ZAPPEDYOU),ptTrav-&gt;next-&gt;cUserName); <br>                                    PrintTextLine(cBuff); <br>                                    KillSelf(); <br>                                    break; <br>                                    } <br>                                // <br>                                // otherwise, keep checking. <br>                                // <br>                                bSquare1 = bSquare2; <br>                                bSquare2 = bMaze[ix = ADJ_X(ix,Facing)][iy = ADJ_Y(iy,Facing)]; <br>                                } while (!((bSquare1 &amp; Facing)||(bSquare2 &amp; BACK_TO_ABS(Facing)))); <br>                            } <br>                        } <br> <br>                    break; <br> <br>                case (NP_LEAVINGGAME): <br>// <br>// ***BUGBUG*** Might cause problems if character leaving is on screen <br>// <br>                    if (bFound) { <br>                        sprintf(cBuff,GetStringRes(IDS_FMT_LEFT),ptTrav-&gt;next-&gt;cUserName); <br>                        PrintTextLine(cBuff); <br>                        PostMessage(hWndScore,WM_COMMAND,WC_DELETESCORE,ptTrav-&gt;next-&gt;ulID); <br>                        ptTrav-&gt;next = DeletePlayer(ptTrav-&gt;next); <br>                        PostMessage(hWndMaze,WM_COMMAND,IDM_DRAWPLAYERS,0); <br>                        } <br>                    break; <br> <br>                case (NP_HITCONFIRM): <br>                    PlaySound("squish.wav",NULL,SND_FILENAME|SND_ASYNC); <br>                    if (bFound) { <br>                        FadePic(ptTrav-&gt;next-&gt;iPicNum, <br>                                ptTrav-&gt;next-&gt;Pos.Facing, <br>                                hMazeDC, <br>                                &amp;ptTrav-&gt;next-&gt;rFrom, <br>                                &amp;ptTrav-&gt;next-&gt;rDrawn); <br>                        sprintf(cBuff,GetStringRes(IDS_FMT_HIT),ptTrav-&gt;next-&gt;cUserName); <br>                        PrintTextLine(cBuff); <br>                        } <br>                    ptSelf.iScore += 50; <br>                    iPlayersKilled++; <br> <br>                    SendNetMessage(0,0,NULL,NP_SCORE); <br>                    PostMessage(hWndScore,WM_COMMAND,WC_UPDATESCORE,ptSelf.ulID); <br>                    break; <br> <br>                case (NP_SCORE): <br>                    if (bFound) { <br>                        ptTrav-&gt;next-&gt;iScore = *iScore; <br>                        PostMessage(hWndScore,WM_COMMAND,WC_UPDATESCORE,ptTrav-&gt;next-&gt;ulID); <br>                        } <br>                    break; <br> <br>                case NP_INTONE: <br>                    if (bFound) { <br>                        ix = ptSelf.Pos.ix - itIntone-&gt;Pos.ix; <br>                        iy = ptSelf.Pos.iy - itIntone-&gt;Pos.iy; <br>                        if ((ix*ix + iy*iy) &lt;= (itIntone-&gt;iLoudness * itIntone-&gt;iLoudness)) { <br>                            sprintf(cBuff,"[%s] - \"%s\"",ptTrav-&gt;next-&gt;cUserName, <br>                                    itIntone-&gt;cBuff); <br>                            PrintTextLine(cBuff); <br>                            } <br>                        } <br>                    break; <br> <br>                default: <br>                    MessageBox(NULL,GetStringRes(IDS_BADMSG),"ProcessNewMail", <br>                                MB_ICONEXCLAMATION|MB_APPLMODAL); <br>                    break; <br>                } <br>            } <br> <br>        GetMailslotInfo(hMailSlot,&amp;cbMaxMsg,&amp;cbNextMsg,&amp;cMsg,&amp;dwReadTimeout); <br>        } <br> <br>#endif // end if WIN32. This whole function is not present for WIN16. <br> <br>    return; <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
