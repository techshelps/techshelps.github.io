<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PLAY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4897"></a>PLAY.C</h2>
<pre><code>/*************************************************************/ <br>/**                                                         **/ <br>/**                 Microsoft RPC Examples                  **/ <br>/**                 Dictionary Application                  **/ <br>/**        Copyright 1992 - 1998 Microsoft Corporation      **/ <br>/**                                                         **/ <br>/*************************************************************/ <br> <br>/* <br> ************************************************************************* <br> *                                                                       * <br> * Local dictionary :play" example                                       * <br> *                                                                       * <br> * Description:                                                          * <br> * This file contains a simple interactive loop of calls to the          * <br> * dictionary.  The interface is identical to the remote dictionary      * <br> * program described in the readme file.                                 * <br> *                                                                       * <br> ************************************************************************* <br>*/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>#include "dict0.h" <br>#include "play.h" <br>#include "util0.h" <br> <br>#define TAB_STOPS 3 <br> <br> <br>void Usage() <br>{ <br>  printf("Usage : play \n\n"); <br>  exit(1); <br>} <br> <br>/*************************************************************************/ <br>/***                     Remote Dictionary Test Loop                   ***/ <br>/*************************************************************************/ <br> <br>void <br>Usage_Msg() <br>{ <br>    printf("\nUsage: \nType a single character, followed by an optional key as follows:\n\n"); <br>    printf("    i &lt;key&gt; :: Insert &lt;key&gt; into dictionary\n"); <br>    printf("    d &lt;key&gt; :: Delete &lt;key&gt; from dictionary\n"); <br>    printf("    f &lt;key&gt; :: Find &lt;key&gt; in dictionary\n"); <br>    printf("    n       :: Next of local current item in dictionary\n"); <br>    printf("    p       :: Previous of local current item in dictionary\n"); <br>    printf("    h       :: Head (first item) of dictionary\n"); <br>    printf("    t       :: Tail (last item) of dictionary\n"); <br>    printf("    ?       :: Print this message\n"); <br>    printf("    q       :: Quit\n\n"); <br>    printf("where &lt;key&gt; is &lt;integer&gt; &lt;string&gt;\n"); <br>} <br> <br>/*************************************************************************/ <br>/***    Minimal Dictionary Operations:                                 ***/ <br>/***                                                                   ***/ <br>/***    Dictionary *Dict_New(Cmp_rec*, Splay*, print_rec*)             ***/ <br>/***                                                                   ***/ <br>/***    Dict_Status Dict_Find(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Next(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Prev(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Insert(Dictionary*, Item*)                    ***/ <br>/***    Dict_Status Dict_Delete(Dictionary*, Item**)                   ***/ <br>/***                                                                   ***/ <br>/***    Item* DICT_CURR_ITEM(Dict*)                                    ***/ <br>/*************************************************************************/ <br> <br>void <br>TestLoop( Dictionary * pdict ) <br>{ <br>    char currName[80]; <br>    char name[80]; <br>    char op = 0; <br>    char buffer[80]; <br> <br>    Record r, currRecord; <br>    Record *pcurrRecord = &amp;currRecord; <br>    Record *pr = &amp;r; <br> <br>    Dict_Status status; <br>    short i; <br> <br>    pcurrRecord-&gt;name = currName; <br>    pr-&gt;name = name; <br> <br>    Usage_Msg(); <br> <br>    while ( op != 'q' ) { <br> <br>        printf("\nnext op (i d x f n p h t ? q): "); <br>        gets(buffer); <br>        op = buffer[0]; <br> <br>        if (op == 'i' || op == 'd' || op == 'f' || <br>            op == '+' || op == '-' || op == 'I') <br>              sscanf(buffer+1, "%d %s", &amp;pr-&gt;key, pr-&gt;name); <br> <br>        switch (op) { <br>            case 'h': <br>                // get Head of list (first record); <br> <br>                status = Dict_Next(pdict, NULL); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pcurrRecord); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pr); <br>                break; <br> <br>            case 't': <br>                // get Tail of list (last record) <br> <br>                status = Dict_Prev(pdict, NULL); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pcurrRecord); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pr); <br>                break; <br> <br>            case 'n': <br>                // get Next record <br> <br>                status = Dict_Next(pdict, pcurrRecord); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pcurrRecord); <br>                break; <br> <br>            case 'p': <br>                // get Previous record <br> <br>                status = Dict_Prev(pdict, pcurrRecord); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pcurrRecord); <br>                break; <br> <br>            case 'N': <br>                // get Next record <br> <br>                status = Dict_Next(pdict, pr); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pr); <br>                break; <br> <br>            case 'P': <br>                // get Previous record <br> <br>                status = Dict_Prev(pdict, pr); <br>                ItemCopy(DICT_CURR_ITEM(pdict), pr); <br>                break; <br> <br>            case 'r': <br>                ItemCopy(DICT_CURR_ITEM(pdict), pcurrRecord); <br>                break; <br> <br> <br>            case '+': <br>                // get Next record <br> <br>                status = Dict_Next(pdict, pr); <br>                break; <br> <br>            case '-': <br>                // get Previous record <br> <br>                status = Dict_Prev(pdict, pr); <br>                break; <br> <br>            case 'f': <br>                // Find &lt;key&gt; <br> <br>                status = Dict_Find(pdict, pr); <br>                break; <br> <br>            case 'i': <br>                // Insert &lt;key&gt; <br> <br>                status = Dict_Insert(pdict, <br>                                     makeRecord(pr-&gt;key, pr-&gt;name) ); <br>                break; <br> <br>            case 'I': <br>                // Insert (&lt;num'&gt;,&lt;name&gt;) for all num': 3 &lt; num' &lt; num <br> <br>                for (i = 3; i &lt; pr-&gt;key; i++) { <br>                    status = Dict_Insert(pdict, <br>                                         makeRecord(i, pr-&gt;name) ); <br>                } <br>                break; <br> <br>            case 'd': <br>                // Delete &lt;key&gt; <br> <br>                if (pdict != NULL) { <br>                    status = Dict_Delete(pdict, (void **)&amp;pr); <br>                    freeRecord(pr); <br>                    pr = &amp;r; <br>                } <br>                break; <br> <br>            case 'x': <br>                // Delete DICT_CURR_ITEM <br> <br>                if ((pdict != NULL) &amp;&amp; (pdict-&gt;root != NULL)) { <br>                    pr = DICT_CURR_ITEM(pdict); <br>                    status = Dict_Delete(pdict, (void **) &amp;pr); <br>                    freeRecord(pr); <br>                    pr = &amp;r; <br>                } <br>                break; <br> <br>            case 'X': <br>                // Empty the whole dictionary <br> <br>                RecordTreeNodeFree((RecordTreeNode*)pdict-&gt;root); <br>                pdict-&gt;root = NULL; <br>                pr = &amp;r; <br>                break; <br> <br>            case '?': <br>                Usage_Msg(); <br>                break; <br>        } <br> <br>        if (op != '?' &amp;&amp; op != 'q') <br>            Dict_Print(pdict, TAB_STOPS); <br>    } <br>} <br> <br>Dict_Status <br>Dict_New_Dict(OUT Dictionary ** ppdict) <br>{ <br>    static Dictionary * pdict; <br> <br>    pdict = Dict_New(comp, tdSplay, printRecord); <br>    Init_dict(pdict); <br> <br>    *ppdict = pdict; <br>    return(DICT_SUCCESS); <br>} <br> <br>void <br>Init_dict(Dictionary * dp) <br>{ <br>    Record* rp; <br> <br>    rp = makeRecord((short)0, "jack_smith"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "john_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "jean_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "joana_smith"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "michael_jones"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "mike_jacobs"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)2, "bill_jackson"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "jane_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "dianne_jackson"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "james_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "steve_johnson"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)2, "debbie_jones"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "jacob_jacobson"); Dict_Insert(dp, rp); <br> <br>    Dict_Print(dp, TAB_STOPS); <br>} <br> <br>/*************************************************************************/ <br>/***                             Main Loop                             ***/ <br>/*************************************************************************/ <br> <br>void <br>main_dict () <br>{ <br>    Dictionary * pdict; <br>    Dictionary ** ppdict = &amp;pdict; <br> <br>    printf("getting a new dict\n"); <br>    Dict_New_Dict(ppdict); <br>    printf("gotten a new dict in main_dict\n"); <br>    TestLoop(pdict); <br>} <br> <br>void _CRTAPI1 <br>main(int argc, char *argv[]) <br>{ <br>    main_dict(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
