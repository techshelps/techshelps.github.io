<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4894"></a>README.TXT</h2>
<pre><code>DICT <br> <br> <br>The DICT program demonstrates use of the implicit_handle, context_handle,  <br>in, and out attributes. <br> <br>SUMMARY <br>======= <br> <br>This sample program is an example of a non-trivial local application  <br>converted to a distributed RPC application. <br> <br>The local program is a character-oriented "play" program, which lets a <br>user insert, delete, and iterate over a dictionary. The dictionary is <br>based on splay trees, which are printed out in a format described below. <br> <br>We remoted the basic program by taking the interface to the dictionary <br>(given in dict0.h) and creating an interface to a remote dictionary, <br>(given in replay.idl) which is remoted using RPC. <br> <br>Following the local dictionary interface, which is minimal and uniform, <br>the remote interface is also uniform. However, since the local dictionary <br>is generic (can store any item type, using void* pointers to items), <br>the interface needed to change to deal with predefined (Record) type <br>items in order to be remoted using the Microsoft RPC system. Also, <br>since the local implementation allows a "peek" at the root of the tree <br>using a DICT_CURR_ITEM macro, the whole interface needed to change. <br> <br>Remote dictionaries are represented by context handles to demonstrate <br>the use of [context_handle]. Context handles are currently initialized <br>using a global primitive handle [implicit_handle]. <br> <br>State was added to remote dictionaries in order to allow sharing them, <br>and maintain reference counts. At this time, however, access to shared <br>dictionaries is *not* serialized! By default each client gets his own <br>copy of the dictionaries. To use shared dictionaries, start the client <br>using the -s switch. <br> <br>The use of context to maintain state is also demonstrated by <br>differentiating between a private iterator, activated by "n" for "next" <br>and "p" for "previous", and a global shared iterator, activated by "N" <br>for "Next" and "P" for previous. To start iterators, use "h" - go to <br>the "head" of the dictionary, or "t" - go to the "tail" of the dictionary. <br>The private iterator can be reset to DICT_CURR_ITEM using "r". <br> <br>FILES <br>===== <br> <br>The directory samples\rpc\dict contains the following files for building <br>the DICT distributed application: <br> <br>File          Description <br> <br>README.TXT    Readme file for the DICT sample <br>REPLAY.IDL    Interface definition language file <br>REPLAY.ACF    Attribute configuration file <br>CLIENT.C      Client main program <br>SERVER.C      Server main program <br>PLAY.C <br>PLAY.H <br>UTIL0.C <br>UTIL0.H <br>DICT0.C <br>DICT0.H <br>REPLAY.C <br>MAKEFILE      Nmake file to build for Windows NT or Windows 95 <br>MAKEFILE.DOS  Nmake file to build for MS-DOS <br> <br>------------------------------------ <br>Building on Windows NT or Windows 95 <br>------------------------------------ <br> <br>The following environment variables should be already set for you: <br> <br>  set CPU=i386 <br>  set INCLUDE=%SDKROOT%\h <br>  set LIB=%SDKROOT%\lib <br>  set PATH=%SDKROOT%\system32;%SDKROOT%\bin <br> <br>where %SDKROOT% is the root directory for the 32-bit Windows SDK. <br> <br>For mips, set CPU=mips <br>For alpha, set CPU=alpha <br> <br>Build the sample distributed application: <br> <br>  nmake cleanall <br>  nmake <br> <br>------------------------------------------ <br>Building the client application for MS-DOS <br>------------------------------------------ <br> <br>After installing the Microsoft Visual C/C++ version 1.50 development <br>environment and the 16-bit RPC SDK on a Windows NT or Windows 95 <br>computer, you can build the sample client application from Windows NT <br>or Windows 95: <br> <br>  nmake -f makefile.dos cleanall <br>  nmake -f makefile.dos <br> <br>This builds the client application client.exe. <br> <br>You may also execute the Microsoft Visual C/C++ compiler under MS-DOS. <br>This requires a two-step build process. <br> <br>  Step One: Compile the .IDL files under Windows NT or Windows 95: <br> <br>     nmake -a -f makefile.dos replay.h <br> <br>  Step Two: Compile the C sources (stub and application) under MS-DOS: <br> <br>     nmake -f makefile.dos <br> <br>Using the program: <br>------------------ <br> <br>To use the local dictionary example, type "play". <br> <br>To use the remote versiom, type "server" on the server side. On the client  <br>side, for each client use "client" for a fresh,private copy of the  <br>dictionary, or "client -s" for a shared copy of the dictionary. The  <br>following command line options are available on the client side. <br> <br>Options: <br>-------- <br> <br>The -? displays the following message: <br> <br>Usage : client [-s] [-n &lt;server&gt;] [-v &lt;view_option&gt;] <br> <br>The -s option is used for using a shared version of the dictionary. <br>    If none exist, a fresh shared version is created. <br> <br>The -v&lt;option&gt; is used for getting different views of the dictionary: <br>    -v normal (default) - default view of the dictionary <br>    (see explanation below) <br>    -v flat - Flat printout <br>    -v rev (or -v reverse) - reverses the tree to print left subtree first <br>    followed by the node, followed by the right subtree, at every level <br> <br>The -n &lt;server_name&gt; is used for specifying a server machine.  Without it <br>    the server is assumed to run on the same machine. <br> <br>    If you use the -n option you have to make sure that the server is <br>    ready to receive calls; that is you have to start the server, by typing: <br> <br>    -&gt; server <br> <br>    to the console, even if the server is your own machine. <br> <br>Program structure: <br>================== <br> <br>Basic application: <br>------------------ <br> <br>  dict0.h + dict0.c - These files contain a basic generic dictionary <br>    implementation, based on Self Adjusting Trees (Splay trees), <br>    invented by Sleator and Tarjan. In the remote dictionary <br>    application (replay) the generic dictionary code runs on the server, <br>    which maintains a data base to be shared by clients. <br> <br>    Note that the generic dictionary data structures contain untyped <br>    pointers ((void)*), and thus require a special layer of typed trees <br>    (strongly typed tree nodes) containing items of RPC-able types <br>    in order to convert the local dictionary package and distribute it <br>    using the Microsoft RPC system, and particularly the MIDL compiler. <br> <br>    If you are interested in RPC (as opposed to splay trees) treat <br>    the generic dictionary as a "black box", and ignore the implementation <br>    details. Otherwise, you are probably looking at the wrong README <br>    file (and should read Tarjan and Sleators paper first anyhow...) <br> <br>Local dictionary: <br>----------------- <br> <br>  play.h + play.c - These files contain a simple character-oriented <br>    interactive demo / test program for the dictionary. <br> <br>Remote dictionary: <br>------------------ <br> <br>  replay.idl - The Interface Definition Language (IDL) file contains: <br> <br>    o type definitions for the remotable objects required (such as the <br>      Record item type, RecordTreeNode, etc) <br> <br>    o the context handle definition (a (void)* in this case) providing <br>      a handle on a remote dictionary <br> <br>    o the signatures for the remote dictionary operations <br> <br>  replay.acf - An Attribute Configuration File (ACF), used here to <br>    specify the initial binding method. We use implicit_binding to <br>    bind to the server initially, and to initialize the context handle. <br> <br>  replay.c - This file contains the implementation of the remote, or <br>    virtual, dictionary (VDict_...) operations. These are required <br>    only on the server side, and are replaced by caller stubs <br>    (in replay_c.c) on the client side. <br> <br>Utlities: <br>--------- <br> <br>  util0.h + util0.c - These files contain utility routines used by both <br>    the client and server applications to allocate and to free dictionaries <br>    and trees, as well as pretty-print routines, used to print trees on <br>    both sides. See description of the user interface portion below for <br>    further discussion of the tree printing format. <br> <br>Client side: <br>------------ <br> <br>  client.c - This file contains the driver of the client side program. <br>    The client binds to the server, initializes a dictionary, and activates <br>    a context handle for the dictionary on the server side. It then goes <br>    into a test loop which prints the dictionary tree and prompts the user <br>    for additional input by printing the following usage message: <br> <br>Usage: <br>Type a single character, followed by an optional key as follows: <br> <br>    i &lt;key&gt; :: Insert &lt;key&gt; into dictionary <br>    d &lt;key&gt; :: Delete &lt;key&gt; from dictionary <br>    f &lt;key&gt; :: Find &lt;key&gt; in dictionary <br>    N       :: next of current item in dictionary <br>    P       :: previous of current item in dictionary <br>    n       :: Next of local current item in dictionary <br>    p       :: Previous of local current item in dictionary <br>    h       :: Head (first item) of dictionary <br>    t       :: Tail (last item) of dictionary <br>    ?       :: Print this message <br>    q       :: Quit <br> <br>where &lt;key&gt; is &lt;integer&gt; &lt;string&gt; <br> <br>next op (i d x f n N p P h t ? q): <br> <br>Server side: <br>------------ <br> <br>  server.c - This file contains a pretty standard server main loop for <br>    the remote dictionary "replay" demo. <br> <br>Tree print format: <br>------------------ <br> <br>The tree printing routine prints the keys in a binary search tree using <br>the following "prinTree" recursive algorithm: <br> <br>    prinTree (right subtree, with current indentation + one "tab"); <br>    print the key at the root (with current indentation); <br>    prinTree (left subtree, with current indentation + one "tab"); <br> <br>Keys are a pair of the form &lt;integer, string&gt;.  Assume the following tree: <br> <br> <br>                           ----------- <br>                           |0 : jack | <br>                           ----------- <br>                          /           \ <br>                     ----------      ----------- <br>                     |0 : don |      |0 : jane | <br>                     ----------      ----------- <br>                     /       \ <br>                    /         \ <br>               -----------  ---------- <br>               |0 : adam |  |0 : eve | <br>               -----------  ---------- <br> <br>The above print algorithm would print it as follows: <br> <br> <br>        0 : jane <br>    0 : jack <br>            0 : eve <br>        0 : don <br>            0 : adam <br> <br>The left child of a node is printed on the first line following the node <br>which is indented by one more tab then the given node. <br>The right child of a node is printed on the last line preceding the node <br>which is indented by one more tab then the given node. <br>If you tilt your hand to the left while examining the printed tree format, <br>it closely resembles the "traditional" format of a rooted binary tree. <br> <br>Known Limitations: <br>------------------ <br> <br>Shared dictionaries are unprotected, so serialized access to the <br>dictionary is assumed. Use at your own risk. </code></pre>
<p>&nbsp;</p></body>
</HTML>
