<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4899"></a>CLIENT.C</h2>
<pre><code>/*************************************************************/ <br>/**                                                         **/ <br>/**                 Microsoft RPC Examples                  **/ <br>/**                 Dictionary Application                  **/ <br>/**        Copyright 1992 - 1998 Microsoft Corporation      **/ <br>/**                                                         **/ <br>/*************************************************************/ <br> <br>/************************************************************************* <br> *                                                                       * <br> * Remote dictionary example: client side                                * <br> *                                                                       * <br> * Description:                                                          * <br> * This is the driver for the client side remote dictionary              * <br> * (splay trees based) demo.  This works as follows:                     * <br> *                                                                       * <br> *  o in main we bind to the dict interface, and call main_dict;         * <br> *                                                                       * <br> *  o in dict_main we call VDict_New to initialize the dictionary        * <br> *    on the server side, and then call TestLoop.                        * <br> *                                                                       * <br> *  o in TestLoop we loop responding to user input of the form:          * <br> *    &lt;one_letter_opcode&gt; [&lt;optional_arg&gt;],                              * <br> *    where &lt;optional_arg&gt; is a an integer constant followed by a        * <br> *    string.  Type "?" for a detailed usage message.                    * <br> *                                                                       * <br> ************************************************************************* <br>*/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>#include "replay.h"  // header file generated by MIDL compiler <br>#include "dict0.h" <br>#include "util0.h" <br> <br>#define TAB_STOPS 4 <br> <br>#define RDICT_CURR_RECORD(dict) (((DictState*)dict-&gt;state)-&gt;curr_record) <br> <br> <br>char * view = "normal"; <br> <br> <br>void Usage() <br>{ <br>  printf("Usage : client -s\n"); <br>  printf("               -n &lt;server_name&gt;\n"); <br>  printf("               -v &lt;view_option&gt;\n"); <br>  exit(1); <br>} <br> <br>/*************************************************************************/ <br>/***                     Remote Dictionary Print                       ***/ <br>/*************************************************************************/ <br> <br>void <br>RevPrinTree( <br>    int lmargin,             /* indentation of the root of the tree     */ <br>    int indent,              /* indentation of subsequent levels        */ <br>    TreeNode *np,            /* pointer to the root node                */ <br>    PrintFun print)          /* short, one line, record print routine   */ <br>{ <br>    static char lspaces[] = <br>"                                                                                                                                                                                                                                                       "; <br> <br> <br> <br>    if (np == NULL) <br>        return; <br> <br>    RevPrinTree(lmargin+indent, indent, np-&gt;left, print); <br> <br>    if (lmargin &gt; sizeof(lspaces)) <br>        lmargin = sizeof(lspaces); <br> <br>    lspaces[lmargin] = 0; <br>    printf(lspaces); <br>    lspaces[lmargin] = ' '; <br> <br>    (*print)(np-&gt;item); <br> <br>    RevPrinTree(lmargin+indent, indent, np-&gt;right, print); <br>} <br> <br>void <br>LinPrinTree( <br>    TreeNode *np,           /* pointer to the root node                */ <br>    PrintFun print,         /* short, one line, record print routine   */ <br>    Record * local,         /* local iterator point                    */ <br>    Record * global         /* global iterator point                   */ <br>    ) <br>{ <br>    if (np == NULL) <br>        return; <br> <br>    LinPrinTree(np-&gt;left, print, local, global); <br> <br>    if (comp(np-&gt;item, local) == 0) { <br>        if (comp(np-&gt;item, global) == 0) <br>            printf(" ==&gt;&gt; "); <br>        else <br>            printf("   &gt;&gt; "); <br>    } <br>    else if (comp(np-&gt;item, global) == 0) <br>        printf(" ==   "); <br>    else <br>        printf("      "); <br> <br>    (*print)(np-&gt;item); <br> <br>    LinPrinTree(np-&gt;right, print, local, global); <br>} <br> <br>void <br>Clnt_Dict_Print( <br>    VDict * pvd, <br>    int indent, <br>    Record * local, <br>    Record * global <br>    ) <br>{ <br>    RDict DictT = {0, 0}; <br>    RDict *prd = &amp;DictT; <br> <br>    // first: get a new copy a from the server <br>    VDict_Get_Dict(*pvd, &amp;prd); <br> <br>    if ( !strcmp(view, "normal") ) <br>        prinTree(0, <br>                 TAB_STOPS, <br>                 (TreeNode *) prd-&gt;root, <br>                 printRecord); <br>    else if ( !strcmp(view, "reverse") || !strcmp(view, "rev") ) <br>        RevPrinTree(0, <br>                    TAB_STOPS, <br>                    (TreeNode *) prd-&gt;root, <br>                    printRecord); <br>    else if ( !strcmp(view, "flat") ) <br>        LinPrinTree((TreeNode *) prd-&gt;root, <br>                    printRecord, <br>                    local, <br>                    RDICT_CURR_RECORD(prd)); <br> <br>    RDict_Free_Dict(prd); <br>} <br> <br>/*************************************************************************/ <br>/***                     Remote Dictionary Test Loop                   ***/ <br>/*************************************************************************/ <br> <br>void <br>Usage_Msg() <br>{ <br>    printf("\nUsage: \nType a single character, followed by an optional key as follows:\n\n"); <br>    printf("    i &lt;key&gt; :: Insert &lt;key&gt; into dictionary\n"); <br>    printf("    d &lt;key&gt; :: Delete &lt;key&gt; from dictionary\n"); <br>    printf("    f &lt;key&gt; :: Find &lt;key&gt; in dictionary\n"); <br>    printf("    N       :: next of current item in dictionary\n"); <br>    printf("    P       :: previous of current item in dictionary\n"); <br>    printf("    n       :: Next of local current item in dictionary\n"); <br>    printf("    p       :: Previous of local current item in dictionary\n"); <br>    printf("    h       :: Head (first item) of dictionary\n"); <br>    printf("    t       :: Tail (last item) of dictionary\n"); <br>    printf("    ?       :: Print this message\n"); <br>    printf("    q       :: Quit\n\n"); <br>    printf("where &lt;key&gt; is &lt;integer&gt; &lt;string&gt;\n"); <br>} <br> <br>void <br>TestLoop( VDict * pvd ) <br>{ <br>    char currName[80]; <br>    char name[80]; <br>    char op = 0; <br>    char buffer[80]; <br> <br>    Record r, currRecord; <br>    Record *pcurrRecord = &amp;currRecord; <br>    Record *pr = &amp;r; <br>    Record * pNullRecord = NULL; <br> <br>    Dict_Status status; <br> <br>    pcurrRecord-&gt;name = currName; <br>    pr-&gt;name = name; <br> <br>    VDict_Curr_Item(*pvd, &amp;pcurrRecord); <br>    ItemCopy(pcurrRecord, pr); <br> <br>    Clnt_Dict_Print(pvd, TAB_STOPS, pcurrRecord, pr); <br>    Usage_Msg(); <br> <br>    while ( op != 'q' ) { <br> <br>        printf("\nnext op (i d x f n N p P h t ? q): "); <br>        gets(buffer); <br>        op = buffer[0]; <br> <br>        if (op == 'i' || op == 'd' || op == 'f' || op == 'I') <br>            sscanf(buffer+1, "%d %s", &amp;pr-&gt;key, pr-&gt;name); <br> <br>        switch (op) { <br>            case 'h': <br>                // get Head of list (first record); <br> <br>                status = VDict_Next(*pvd, &amp;pNullRecord); <br>                if (pNullRecord != NULL) { <br>                    ItemCopy(pNullRecord, pcurrRecord); <br>                    freeRecord(pNullRecord); <br>                    pNullRecord = NULL; <br>                } <br>                break; <br> <br>            case 't': <br>                // get Tail of list (last record) <br> <br>                status = VDict_Prev(*pvd, &amp;pNullRecord); <br>                if (pNullRecord != NULL) { <br>                    ItemCopy(pNullRecord, pcurrRecord); <br>                    freeRecord(pNullRecord); <br>                    pNullRecord = NULL; <br>                } <br>                break; <br> <br>            case 'n': <br>                // get next record (advance private (local) iterator) <br> <br>                status = VDict_Next(*pvd, &amp;pcurrRecord); <br>                break; <br> <br>            case 'p': <br>                // get previous record (retreat private (local) iterator) <br> <br>                status = VDict_Prev(*pvd, &amp;pcurrRecord); <br>                break; <br> <br>            case 'r': <br>                // Reset local iterator to global "current item" <br> <br>                status = VDict_Curr_Item(*pvd, &amp;pcurrRecord); <br>                break; <br> <br>            case 'N': <br>                // get Next record (advance global iterator) <br> <br>                status = VDict_Curr_Next(*pvd, &amp;pr); <br>                pr = &amp;r; <br>                break; <br> <br>            case 'P': <br>                // get Previous record (retreat global iterator) <br> <br>                status = VDict_Curr_Prev(*pvd, &amp;pr); <br>                pr = &amp;r; <br>                break; <br> <br>            case 'f': <br>                // Find &lt;key&gt; <br> <br>                status = VDict_Find(*pvd, &amp;pr); <br>                pr = &amp;r; <br>                break; <br> <br>            case 'i': <br>                // Insert &lt;key&gt; <br> <br>                status = VDict_Insert(*pvd, pr); <br>                break; <br> <br>            case 'I': <br>                // Insert (&lt;num'&gt;,"") for all num' s.t. 3 &lt; num' &lt; num <br> <br>                status = VDict_I_Dict(*pvd, pr-&gt;key); <br>                break; <br> <br>            case 'd': <br>                // Delete &lt;key&gt; <br> <br>                status = VDict_Delete(*pvd, &amp;pr); <br>                if (status != ITEM_NOT_FOUND &amp;&amp; status != EMPTY_DICTIONARY) { <br>                    pr = &amp;r; <br>                } <br>                break; <br> <br>            case 'x': <br>                // Delete DICT_CURR_ITEM <br> <br>                status = VDict_Curr_Delete(*pvd, &amp;pr); <br>                if (pr == NULL) { <br>                    pr = &amp;r; <br>                } <br>                break; <br> <br>            case 'X': <br>                // Empty the dictionary <br> <br>                status = VDict_X_Dict(*pvd); <br>                break; <br> <br>            case '?': <br>                Usage_Msg(); <br>                break; <br>        } <br> <br>        if (op != '?' &amp;&amp; op != 'q') <br>            Clnt_Dict_Print(pvd, TAB_STOPS, pcurrRecord, pr); <br>    } <br>} <br> <br> <br>/*************************************************************************/ <br>/***                             Main Loop                             ***/ <br>/*************************************************************************/ <br> <br>void main_dict (short SharedDict) <br>{ <br>    VDict v_dict = (VDict)0; <br>    VDict * pvdict; <br> <br>    pvdict = &amp;v_dict; <br> <br>    printf ("Getting a new dict..."); <br>    VDict_New( SharedDict, pvdict ); <br> <br>    printf ("Done.\n"); <br>    TestLoop(pvdict); <br>} <br> <br>int _CRTAPI1 <br>main(int argc, char *argv[]) <br>{ <br>    RPC_STATUS status; <br>    unsigned char * pszUuid             = NULL; <br>    unsigned char * pszProtocolSequence = "ncacn_np"; <br>    unsigned char * pszNetworkAddress   = NULL; <br>    unsigned char * pszEndpoint         = "\\pipe\\dict"; <br>    unsigned char * pszOptions          = NULL; <br>    unsigned char * pszStringBinding    = NULL; <br>    short Shared_Dictionary = 0;  // Share an existing dictionary? <br>    int i; <br> <br>    printf ("Microsoft RPC demo Client - Splay (Binary) Tree DataBase\n"); <br> <br>    for (i = 1; i &lt; argc; i++) { <br>        if ((*argv[i] == '-') || (*argv[i] == '/')) { <br>            switch (tolower(*(argv[i]+1))) { <br>            case 'n':  // network address <br>                pszNetworkAddress = argv[++i]; <br>                break; <br>            case 's': <br>                Shared_Dictionary = 1; <br>                break; <br>            case 'v': <br>                view = argv[++i]; <br>                break; <br>            case 'h': <br>            case '?': <br>            default: <br>                Usage(); <br>            } <br>        } <br>        else <br>            Usage(); <br>    } <br> <br>    /* The dict_ProtocolStack contains a partially initialized <br>     * protocol stack for the dict interface.  Fill in the <br>     * remaining fields: <br>     */ <br> <br>    status = RpcStringBindingCompose(pszUuid, <br>                                     pszProtocolSequence, <br>                                     pszNetworkAddress, <br>                                     pszEndpoint, <br>                                     pszOptions, <br>                                     &amp;pszStringBinding); <br>    if (status) { <br>        printf("RpcStringBindingCompose returned 0x%x\n", status); <br>        return(status); <br>    } <br> <br>    status = RpcBindingFromStringBinding(pszStringBinding, <br>                                         &amp;dict_IfHandle); <br>    if (status) { <br>        printf("RpcBindingFromStringBinding returned 0x%x\n", status); <br>        return(status); <br>    } <br> <br>    status = RpcStringFree(&amp;pszStringBinding);  // remote calls done; unbind <br>    if (status) { <br>        printf("RpcStringFree returned 0x%x\n", status); <br>        return(status); <br>    } <br> <br>    RpcTryExcept { <br>       main_dict(Shared_Dictionary); <br>    } <br>    RpcExcept(1) { <br>       printf("RPC runtime raised exception 0x%x\n", RpcExceptionCode()); <br>    } <br>    RpcEndExcept <br> <br>    status = RpcBindingFree(&amp;dict_IfHandle);  // remote calls done; unbind <br>    if (status) { <br>        printf("RpcBindingFree returned 0x%x\n", status); <br>        return(status); <br>    } <br> <br>    return(0); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
