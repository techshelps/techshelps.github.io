<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REPLAY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4901"></a>REPLAY.C</h2>
<pre><code>/*************************************************************/ <br>/**                                                         **/ <br>/**                 Microsoft RPC Examples                  **/ <br>/**                 Dictionary Application                  **/ <br>/**         Copyright 1992 - 1998 Microsoft Corporation     **/ <br>/**                                                         **/ <br>/*************************************************************/ <br> <br>/*************************************************************************/ <br>/***                                                                   ***/ <br>/***  Example dictionary using splay trees:                            ***/ <br>/***                                                                   ***/ <br>/*************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "replay.h"    // header file generated by MIDL compiler <br>#include "dict0.h" <br>#include "util0.h" <br> <br>#define TAB_STOPS 3 <br> <br>/*************************************************************************/ <br>/***                   Declarations (from replay.h)                    ***/ <br>/*************************************************************************/ <br> <br>/* <br>typedef struct _Record { <br>    short key;                      // RPC "generation" <br>    [string] char* name;            // contributor <br>} Record; <br> <br>typedef struct _RecordTreeNode RecordTreeNode; <br> <br>typedef struct _RecordTreeNode { <br>    RecordTreeNode *left;           // left child pointer <br>    RecordTreeNode *right;          // right child pointer <br>    Record *item;                   // pointer to a Record structure <br>} RecordTreeNode; <br> <br>typedef struct _RDict { <br>    RecordTreeNode *root;           // pointer to the root of a SAT <br>    long size;                      // number of records in dictionary <br>} RDict; <br> <br>// RDict is used for marshalling a complete dictionary. <br> <br>typedef enum { <br>    DICT_SUCCESS, <br>    DICT_ITEM_ALREADY_PRESENT, <br>    DICT_ITEM_NOT_FOUND, <br>    DICT_FIRST_ITEM, <br>    DICT_LAST_ITEM, <br>    DICT_EMPTY_DICTIONARY, <br>    DICT_NULL_ITEM <br>} VDict_Status; <br> <br>typedef struct _DictState { <br>    short ref_count;               // for shared dictionaries <br>    Record * curr_record;          // for global iterators <br>} DictState; <br>*/ <br> <br>/*************************************************************************/ <br>/***                   Internal state access methods                   ***/ <br>/*************************************************************************/ <br> <br>#define RDICT_CURR_RECORD(dict) (((DictState*)dict-&gt;state)-&gt;curr_record) <br> <br>#define RDICT_REF_COUNT(dict)   (((DictState*)dict-&gt;state)-&gt;ref_count) <br> <br>#define RDICT_STATE(dict)       (((RDict*)dict)-&gt;state) <br> <br>static int active_dictionary = 0; <br> <br>/*************************************************************************/ <br>/***    Generic Dictionary Operations: (From dict0.h)                  ***/ <br>/***                                                                   ***/ <br>/***    Dictionary *Dict_New(Cmp_rec*, Splay*, print_rec*)             ***/ <br>/***                                                                   ***/ <br>/***    Dict_Status Dict_Find(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Next(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Prev(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Insert(Dictionary*, Item*)                    ***/ <br>/***    Dict_Status Dict_Delete(Dictionary*, Item**)                   ***/ <br>/***                                                                   ***/ <br>/***    Item* DICT_CURR_ITEM(Dict*)                                    ***/ <br>/*************************************************************************/ <br> <br>/*************************************************************************/ <br>/***    Virtual Dictionary Operations: (From replay.h)                 ***/ <br>/***                                                                   ***/ <br>/***    VDict_Status VDict_New(OUT VDict **)                           ***/ <br>/***                                                                   ***/ <br>/***    VDict_Status VDict_Find(IN VDict*, IN OUT Record**)            ***/ <br>/***    VDict_Status VDict_Next(IN VDict*, IN OUT Record**)            ***/ <br>/***    VDict_Status VDict_Prev(IN VDict*, IN OUT Record**)            ***/ <br>/***    VDict_Status VDict_Insert(IN VDict*, IN Record*)               ***/ <br>/***    VDict_Status VDict_Delete(IN VDict*, IN OUT Record**)          ***/ <br>/***                                                                   ***/ <br>/***    VDict_Status VDict_Curr_Item(IN VDict*, OUT Record**);         ***/ <br>/***    VDict_Status VDict_Curr_Delete(IN VDict*, OUT Record**);       ***/ <br>/***    VDict_Status VDict_Curr_Next(IN VDict*, OUT Record**);         ***/ <br>/***    VDict_Status VDict_Curr_Prev(IN VDict*, OUT Record**);         ***/ <br>/***                                                                   ***/ <br>/***    VDict_Status VDict_Get_Dict(IN VDict*, OUT RDict**)            ***/ <br>/*************************************************************************/ <br> <br>/*************************************************************************/ <br>/***                   context rundown routine                         ***/ <br>/*************************************************************************/ <br> <br>void __RPC_USER VDict_rundown (VDict v_dict) <br>{ <br>    Dictionary * pdict = (Dictionary*) v_dict; <br>    short count = --RDICT_REF_COUNT(pdict); <br> <br>    printf("# of remaining users of context: %d\n\n", <br>           RDICT_REF_COUNT(pdict) ); <br> <br>    if (RDICT_REF_COUNT(pdict) &lt;= 0) { <br>        printf("CLOSING CONTEXT\n\n"); <br> <br>        // free the splay tree <br>        RDict_Free_Dict(v_dict); <br> <br>        // free the dictionary object <br>        free_state((DictState*) pdict-&gt;state); <br>        MIDL_user_free(v_dict); <br>        if (count == 0) <br>            active_dictionary = 0; <br>    } <br>} <br> <br>//  For now: need to allocate a new item record prior to operation, <br>//  for all OUT and IN OUT arguments, as the callee stub will free <br>//  storage allocated for such pointer parameters. <br>// <br>//  Will be fixed by the introduction of [allocate(dont_free)] <br>//  ACF pointer type and parameter attribute. <br> <br>/************************************************************************** <br> * VDict_New initializes a new dictionary if (1) a non shared dictionary <br> * was requested, or (2) a shared dictionary was requested, but no shared <br> * dictionary is currently active.  There is at most one shared dictionary <br> * at any point in time. <br> * <br> * BUGBUG: shared dictionaries are *NOT* locked (by semaphore, to <br> * serialize access to them.  They *should be, though... <br> ************************************************************************** <br>*/ <br> <br>VDict_Status <br>VDict_New( <br>  IN short shared_dict, <br>  OUT VDict * v_dict <br>  ) <br>{ <br>    Dictionary * pdict0; <br>    static Dictionary * pdict; <br> <br>    if (!active_dictionary  || !shared_dict) { <br>        // server side dictionary initialization <br>        pdict0 = Dict_New(comp, tdSplay, printRecord); <br> <br>        // Initializes RDICT_CURR_RECORD(pdict0) to <br>        // "minus infinity" in the order <br>        ((RDict*)pdict0)-&gt;state = allocate_state(); <br> <br>        Init_dict(pdict0); <br>        *v_dict = (VDict)pdict0; <br> <br>        if (shared_dict) { <br>            printf("OPENING SHARED DICTIONARY CONTEXT!\n\n"); <br>            active_dictionary = 1; <br>            pdict = pdict0; <br>            RDICT_REF_COUNT(pdict)++; <br>        } // else RDICT_REF_COUNT(pdict0) = 0; <br>    } <br>    else { <br>        RDICT_REF_COUNT(pdict)++; <br>        printf("# of users of shared context: %d\n\n", RDICT_REF_COUNT(pdict)); <br>        *v_dict = (VDict)pdict; <br>    } <br> <br>    return(DICT_SUCCESS); <br>} <br> <br>VDict_Status <br>VDict_Find( <br>    IN VDict  v_dict, <br>    IN OUT Record ** item <br>    ) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    status = Dict_Find(pdict, *item); <br>    if ( (pdict == NULL) || DICT_EMPTY(pdict) ) { <br>        *item = NULL; <br>    } <br>    else { <br>        *item = DICT_CURR_ITEM(pdict); <br>        *item = ItemDuplicate(*item); <br>    } <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Next( <br>    IN VDict  v_dict, <br>    IN OUT Record ** item <br>    ) <br>// get successor of *item, and update *item to point to it <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    status = Dict_Next(pdict, *item); <br>    if ( (pdict == NULL) || DICT_EMPTY(pdict) ) { <br>        *item = NULL; <br>    } <br>    else { <br>        if (*item == NULL) <br>            ItemCopy(DICT_CURR_ITEM(pdict), RDICT_CURR_RECORD(pdict)); <br>        *item = DICT_CURR_ITEM(pdict); <br>    } <br>    *item = ItemDuplicate(*item); <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Prev( <br>    IN VDict  v_dict, <br>    IN OUT Record ** item <br>    ) <br>// get predecessor of *item, and update *item to point to it <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    status = Dict_Prev(pdict, *item); <br>    if ( (pdict == NULL) || DICT_EMPTY(pdict) ) { <br>        *item = NULL; <br>    } <br>    else { <br>        if (*item == NULL) <br>            ItemCopy(DICT_CURR_ITEM(pdict), RDICT_CURR_RECORD(pdict)); <br>        *item = DICT_CURR_ITEM(pdict); <br>    } <br>    *item = ItemDuplicate(*item); <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Curr_Next( <br>    IN VDict  v_dict, <br>    OUT Record ** item <br>    ) <br>// get successor of RDICT_CURR_RECORD(v_dict), <br>// and update *item to point to it (global iterator prev) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    if ( (pdict == NULL) || DICT_EMPTY(pdict) ) { <br>        status = EMPTY_DICTIONARY; <br>        *item = NULL; <br>    } <br>    else { <br>        status = Dict_Next(pdict, RDICT_CURR_RECORD(pdict)); <br>        ItemCopy(DICT_CURR_ITEM(pdict), RDICT_CURR_RECORD(pdict)); <br>        *item = DICT_CURR_ITEM(pdict); <br>    } <br>    *item = ItemDuplicate(*item); <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Curr_Prev( <br>    IN VDict  v_dict, <br>    OUT Record ** item <br>    ) <br>// get predecessor of RDICT_CURR_RECORD(v_dict), <br>// and update *item to point to it (global iterator prev) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    if ( (pdict == NULL) || DICT_EMPTY(pdict) ) { <br>        status = EMPTY_DICTIONARY; <br>        *item = NULL; <br>    } <br>    else { <br>        // update RDICT_CURR_RECORD(pdict) <br>        status = Dict_Prev(pdict, RDICT_CURR_RECORD(pdict)); <br>        ItemCopy(DICT_CURR_ITEM(pdict), RDICT_CURR_RECORD(pdict)); <br>        *item = DICT_CURR_ITEM(pdict); <br>    } <br>    *item = ItemDuplicate(*item); <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Insert( <br>    IN VDict  v_dict, <br>    IN Record * item <br>    ) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br>    Record * rp = makeRecord(item-&gt;key, item-&gt;name); <br> <br>    status = Dict_Insert(pdict, rp); // No return value required. <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Delete( <br>    IN VDict  v_dict, <br>    IN OUT Record ** item <br>    ) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    status = Dict_Delete(pdict, (void **)item); <br>                                    // (*item) is returned by Dict_Delete! <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Curr_Item( <br>    IN VDict  v_dict, <br>    OUT Record ** item <br>    ) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    if ( (pdict == NULL) || DICT_EMPTY(pdict) ) { <br>        status = EMPTY_DICTIONARY; <br>        *item = NULL; <br>    } <br>    else { <br>        status = SUCCESS; <br>        *item = DICT_CURR_ITEM(pdict); <br>    } <br>    *item = ItemDuplicate(*item); <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Curr_Delete( <br>    IN VDict  v_dict, <br>    OUT Record ** item <br>    ) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br>    Dict_Status status; <br> <br>    if ( (pdict == NULL) || DICT_EMPTY(pdict) ) { <br>        status = EMPTY_DICTIONARY; <br>        *item = NULL; <br>    } <br>    else { <br>        *item = DICT_CURR_ITEM(pdict); <br>        status = Dict_Delete( pdict, (void **)item ); <br>    } <br>    return( (VDict_Status)status ); <br>} <br> <br>VDict_Status <br>VDict_Get_Dict( <br>    IN VDict  v_dict, <br>    OUT RDict ** r_dict <br>    ) <br>//  used to transmit the dictionary back to the callee <br>//  (In this demo program - for printing on the client side) <br>{ <br>    Dictionary * pdict = (Dictionary*) (v_dict); <br> <br>    if (pdict == NULL) { <br>        return(DICT_EMPTY_DICTIONARY); <br>    } <br>    else { <br>        prinTree(0, 3, pdict-&gt;root, printRecord); <br> <br>        *r_dict = RDict_Duplicate((RDict*)pdict); <br>            // Duplication is done to avoid freeing the tree by <br>            // the callee stub.  This is a temporary fix, until we <br>            // implement [allocate(dont_free)]! <br> <br>        return(DICT_SUCCESS); <br>    } <br>} <br> <br>/*************************************************************************/ <br>/***                        Server Utility Functions                   ***/ <br>/*************************************************************************/ <br> <br>void <br>Init_dict(Dictionary * dp) <br>{ <br>    Record* rp; <br> <br>    rp = makeRecord((short)0, "jack_smith"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "john_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "steve_johnson"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)2, "debbie_jones"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "mike_jacobs"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)2, "bill_jackson"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "jane_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "james_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "jean_doe"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "joana_smith"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)1, "michael_jones"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "dianne_jackson"); Dict_Insert(dp, rp); <br>    rp = makeRecord((short)0, "jacob_jacobson"); Dict_Insert(dp, rp); <br> <br>    Dict_Print(dp, TAB_STOPS); <br>} <br> <br>/*************************************************************************/ <br>/***                        Play oriented Functions ...                ***/ <br>/*** (used to empty the tree and replace it by a tree of integers      ***/ <br>/*************************************************************************/ <br> <br>VDict_Status <br>VDict_X_Dict( <br>    IN VDict  v_dict <br>    ) <br>// Empty the dictionary <br>{ <br>    RDict * prdict = (RDict*)v_dict; <br> <br>    if (DICT_EMPTY(prdict)) <br>        return(DICT_EMPTY_DICTIONARY); <br> <br>    RecordTreeNodeFree(prdict-&gt;root); <br>    prdict-&gt;root = NULL; <br>    return(DICT_SUCCESS); <br>} <br> <br>VDict_Status <br>VDict_I_Dict( <br>    IN VDict  v_dict, <br>    IN short  size <br>    ) <br>// Insert integers from 3 to a specified upper bound into the tree <br>{ <br>    RDict * prdict = (RDict*)v_dict; <br>    Dict_Status status; <br>    short i; <br> <br>    // Insert (&lt;num'&gt;, "") for all num' s.t. 3 &lt; num' &lt; num <br>    for (i=3; i &lt; size; i++) { <br>        status = VDict_Insert(prdict, <br>                              makeRecord(i, "&lt;")); <br>    } <br>    return( (VDict_Status)status ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
