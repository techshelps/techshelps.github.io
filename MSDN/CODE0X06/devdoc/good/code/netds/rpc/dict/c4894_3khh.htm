<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DICT0.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4895"></a>DICT0.C</h2>
<pre><code>/*************************************************************/ <br>/**                                                         **/ <br>/**                 Microsoft RPC Examples                  **/ <br>/**                 Dictionary Application                  **/ <br>/**           Copyright 1992 - 1998 Microsoft Corporation   **/ <br>/**                                                         **/ <br>/*************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>#include &lt;rpc.h&gt; <br>#include &lt;rpcndr.h&gt; <br>#include "dict0.h" <br> <br>/************************************************************************/ <br>TreeNode Dumbo; <br>// volatile <br>TreeNode *Dummy = &amp;Dumbo;   // a global dummy node <br> <br>#define ROTATELEFT  tmp=t-&gt;right; t-&gt;right=tmp-&gt;left; tmp-&gt;left=t; t=tmp <br>#define ROTATERIGHT tmp=t-&gt;left; t-&gt;left=tmp-&gt;right; tmp-&gt;right=t; t=tmp <br>#define LINKLEFT    tmp=t; t=t-&gt;right; l=l-&gt;right=tmp <br>#define LINKRIGHT   tmp=t; t=t-&gt;left; r=r-&gt;left=tmp <br>#define ASSEMBLE    r-&gt;left=t-&gt;right; l-&gt;right=t-&gt;left; \ <br>                    t-&gt;left=Dummy-&gt;right; t-&gt;right=Dummy-&gt;left <br>/************************************************************************/ <br> <br>/************************************************************************ <br> Basic structure declarations from dict0.h: <br> <br>typedef struct tnode { <br>    struct tnode *left;             // left child pointer <br>    struct tnode *right;            // right child pointer <br>    void *item;                     // pointer to some structure <br>} TreeNode; <br> <br>typedef struct dictnode { <br>    TreeNode *root;                 // pointer to the root of a SAT <br>    long size;                      // number of records in dictionary <br>    void * state;                   // reserved for state info <br>    cmp_rec_func cmp_rec;           // pointer to a comparison function <br>    TreeNode* (*splay)(TreeNode *, void *, cmp_rec_func); <br>                                    // pointer to a splay function <br>    void (*print_rec)(void *);      // one line print function <br>} Dictionary; <br> <br>#define DICT_CURR_ITEM(pDict)       pDict-&gt;root-&gt;item <br> <br>typedef enum { <br>    SUCCESS, <br>    ITEM_ALREADY_PRESENT, <br>    ITEM_NOT_FOUND, <br>    FIRST_ITEM, <br>    LAST_ITEM, <br>    EMPTY_DICTIONARY, <br>    NULL_ITEM <br>} Dict_Status; <br>**************************************************************************/ <br> <br> <br>/*************************************************************************/ <br>/***    Minimal Dictionary Operations:                                 ***/ <br>/***                                                                   ***/ <br>/***    Dictionary *Dict_New(Cmp_rec*, Splay*, print_rec*)             ***/ <br>/***                                                                   ***/ <br>/***    Dict_Status Dict_Find(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Next(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Prev(Dictionary*, Item*)                      ***/ <br>/***    Dict_Status Dict_Insert(Dictionary*, Item*)                    ***/ <br>/***    Dict_Status Dict_Delete(Dictionary*, Item**)                   ***/ <br>/***                                                                   ***/ <br>/***    Item* DICT_CURR_ITEM(Dict*)                                    ***/ <br>/*************************************************************************/ <br> <br>#define TreeNode_New(pnode, pitem) pnode = \ <br>    (TreeNode*) MIDL_user_allocate (sizeof(TreeNode)); \ <br>    pnode-&gt;left = pnode-&gt;right = NULL; pnode-&gt;item = pitem; <br> <br>Dictionary* <br>Dict_New(                    // returns a new dictionary node <br>    int (*cmp_rec)           // pointer to item comparison function <br>        (void *, void *), <br>    TreeNode* (*splay)       // pointer to a splay function <br>        (TreeNode *, void *, cmp_rec_func), <br>    void (*print_rec)        // pointer to one line item print routine <br>        (void *) ) <br>{ <br>    Dictionary* dp; <br> <br>    dp = (Dictionary*) MIDL_user_allocate(sizeof(Dictionary)); <br>    dp-&gt;root = NULL; <br>    dp-&gt;size = 0; <br>    dp-&gt;state = NULL; <br>    dp-&gt;print_rec = print_rec; <br>    dp-&gt;splay = splay; <br>    dp-&gt;cmp_rec = cmp_rec; <br>    return(dp); <br>} <br> <br>Dict_Status <br>Dict_Find( <br>    Dictionary* dp,     // Dictionary to be searched. <br>    void* item)         // Item searched for. <br>{ <br>    int keycmp; <br>    TreeNode* t; <br> <br>    if (dp-&gt;root == NULL) <br>        return (EMPTY_DICTIONARY); <br>    if (item == NULL) <br>        return(NULL_ITEM); <br>    t = dp-&gt;root = dp-&gt;splay(dp-&gt;root, item, dp-&gt;cmp_rec); <br>    keycmp = (dp-&gt;cmp_rec)( t-&gt;item, item ); <br>    if (keycmp != 0) <br>        return(ITEM_NOT_FOUND); <br>    else return(SUCCESS); <br>} <br> <br>Dict_Status <br>Dict_Next( <br>    Dictionary* dp,     // Dictionary to be searched. <br>    void* item)         // A Key item.  Advance to successor of item in dp. <br>{ <br>    TreeNode* t; <br>    int keycmp; <br> <br>    if (dp-&gt;root == NULL) <br>        return (EMPTY_DICTIONARY); <br>    if (item == NULL) { <br>        dp-&gt;root = tdSplayLeft(dp-&gt;root); <br>        return(SUCCESS); <br>    } <br>    if (item == DICT_CURR_ITEM(dp)) { <br>        t = dp-&gt;root; <br>        keycmp = 0; <br>    } <br>    else { <br>        dp-&gt;root = t = dp-&gt;splay(dp-&gt;root, item, dp-&gt;cmp_rec); <br>        keycmp = (dp-&gt;cmp_rec) (item, t-&gt;item); <br>    } <br>    if (keycmp &lt; 0) <br>        return(SUCCESS); <br>    else if (t-&gt;right == NULL) { <br>        return(LAST_ITEM); <br>    } <br>    else { <br>        t = dp-&gt;root; <br>        dp-&gt;root = tdSplayLeft(t-&gt;right); <br>        dp-&gt;root-&gt;left = t; <br>        t-&gt;right = NULL; <br>        return(SUCCESS); <br>    } <br>} <br> <br>Dict_Status <br>Dict_Prev( <br>    Dictionary* dp,     // Dictionary to be searched. <br>    void* item)         // A Key item.  Retreat to predecessor of item in dp. <br>{ <br>    TreeNode* t; <br>    int keycmp; <br> <br>    if (dp-&gt;root == NULL) <br>        return (EMPTY_DICTIONARY); <br>    if (item == NULL) { <br>        dp-&gt;root = tdSplayRight(dp-&gt;root); <br>        return(SUCCESS); <br>    } <br>    if (item == DICT_CURR_ITEM(dp)) { <br>        t = dp-&gt;root; <br>        keycmp = 0; <br>    } <br>    else { <br>        dp-&gt;root = t = dp-&gt;splay(dp-&gt;root, item, dp-&gt;cmp_rec); <br>        keycmp = (dp-&gt;cmp_rec) (item, t-&gt;item); <br>    } <br>    if (keycmp &gt; 0) <br>        return(SUCCESS); <br>    else if (t-&gt;left == NULL) { <br>        return(FIRST_ITEM); <br>    } <br>    else { <br>        t = dp-&gt;root; <br>        dp-&gt;root = tdSplayRight(t-&gt;left); <br>        dp-&gt;root-&gt;right = t; <br>        t-&gt;left = NULL; <br>        return(SUCCESS); <br>    } <br>} <br> <br>Dict_Status <br>Dict_Insert(            // insert the given item into the tree <br>    Dictionary* dp,     // the modified dictionary <br>    void* item)         // the item to be inserted <br>{ <br>    int keycmp; <br>    TreeNode *t, *newNode; <br> <br>    if (item == NULL) <br>        return(NULL_ITEM); <br>    if (dp-&gt;root == NULL) { <br>        TreeNode_New(newNode, item); <br>        dp-&gt;root = newNode; <br>        dp-&gt;size++; <br>        return(SUCCESS); <br>    } <br>    t = dp-&gt;root = dp-&gt;splay(dp-&gt;root, item, dp-&gt;cmp_rec); <br>    keycmp = (dp-&gt;cmp_rec)( t-&gt;item, item ); <br>    if (keycmp == 0) <br>        return(ITEM_ALREADY_PRESENT); <br> <br>    TreeNode_New(newNode, item); <br>    if (keycmp &lt; 0) {   // t-&gt;item &lt; item <br>        newNode-&gt;right = t-&gt;right; <br>        t-&gt;right = NULL; <br>        newNode-&gt;left = t; <br>    } <br>    else { <br>        newNode-&gt;left = t-&gt;left; <br>        t-&gt;left = NULL; <br>        newNode-&gt;right = t; <br>    } <br>    dp-&gt;root = newNode; <br>    dp-&gt;size++; <br>    return(SUCCESS); <br>} <br> <br> <br>Dict_Status <br>Dict_Delete(            // delete the given item into from the tree <br>    Dictionary* dp,     // the modified dictionary <br>    void** pItem)       // IN: points to the (key) item to be deleted <br>                        // OUT: points to the item just deleted <br>{ <br>    TreeNode *t, *r; <br>    int keycmp; <br>    void* item = *pItem; <br>    t = dp-&gt;root; <br> <br>    if (item == NULL) <br>        return(NULL_ITEM); <br>    if (dp-&gt;root == NULL) <br>        return (EMPTY_DICTIONARY); <br>    if (item == DICT_CURR_ITEM(dp)) <br>        keycmp = 0; <br>    else { <br>        dp-&gt;root = t = dp-&gt;splay(dp-&gt;root, item, dp-&gt;cmp_rec); <br>        keycmp = (dp-&gt;cmp_rec)( item, t-&gt;item ); <br>    } <br>    if (keycmp != 0) <br>        return(ITEM_NOT_FOUND); <br>    *pItem = DICT_CURR_ITEM(dp); <br> <br>    if (t-&gt;left == NULL) { <br>        dp-&gt;root = t-&gt;right; <br>    } <br>    else if ((r = t-&gt;right) == NULL) { <br>        dp-&gt;root = t-&gt;left; <br>    } <br>    else  { <br>        r = tdSplayLeft(r); <br>        // at this point r-&gt;left == NULL <br>        r-&gt;left = t-&gt;left; <br>        dp-&gt;root = r; <br>    } <br>    t-&gt;left = t-&gt;right = t-&gt;item = NULL; <br>    MIDL_user_free(t); <br>    dp-&gt;size--; <br>    return(SUCCESS); <br>} <br> <br> <br>/*************************************************************************/ <br>/*****              Core functions (internal)                        *****/ <br>/*************************************************************************/ <br> <br>TreeNode *              // returns the new root <br>tdSplay(                // general top down splay <br>    TreeNode *root,     // the current root of the tree <br>    void *keyItem,      // pointer to a "key item" searched for <br>    int (*cmp)(void *, void *) ) <br>                        // pointer to a comparison function <br>{ <br>    TreeNode* t=root;   // current search point <br>    TreeNode* l;        // root of "left subtree" &lt; keyItem <br>    TreeNode* r;        // root of "right subtree" &gt; keyItem <br>    int kcmpt, kcmpleft, kcmpright; <br>                        // cash comparison results <br>    TreeNode* tmp; <br> <br>/***/ <br>    Dummy = &amp;Dumbo; <br>    l = Dummy; <br>    r = Dummy; <br>/***/ <br> <br>    if ( (root == NULL) || ((*cmp)(keyItem, root-&gt;item) == 0) ) <br>        return(root); <br>    Dummy-&gt;left = Dummy-&gt;right = NULL; <br>    while ( (kcmpt = (*cmp)(keyItem, t-&gt;item)) != 0 ) { <br>        if ( kcmpt &lt; 0 ) { <br>            if ( t-&gt;left == NULL ) <br>                break; <br>            if ( (kcmpleft = (*cmp)(keyItem, t-&gt;left-&gt;item)) == 0 ) { <br>                LINKRIGHT; <br>            } <br>            else if ( kcmpleft &lt; 0 ) { <br>                ROTATERIGHT; <br>                if ( t-&gt;left != NULL ) { <br>                    LINKRIGHT; <br>                } <br>            } <br>            else { // keyItem &gt; t-&gt;left-&gt;item <br>                LINKRIGHT; <br>                if ( t-&gt;right != NULL ) { <br>                    LINKLEFT; <br>                } <br>            } <br>        } <br>        else { // keyItem &gt; t-&gt;item <br>            if ( t-&gt;right == NULL ) <br>                break; <br>            if ( (kcmpright = (*cmp)(keyItem, t-&gt;right-&gt;item)) == 0 ) { <br>                LINKLEFT; <br>            } <br>            else if ( kcmpright &gt; 0 ) { <br>                ROTATELEFT; <br>                if ( t-&gt;right != NULL ) { <br>                    LINKLEFT; <br>                } <br>            } <br>            else { // keyItem &lt; t-&gt;right-&gt;item <br>                LINKLEFT; <br>                if ( t-&gt;left != NULL ) { <br>                    LINKRIGHT; <br>                } <br>            } <br>        } <br>    } <br> <br>    ASSEMBLE; <br>    return(t); <br>} <br> <br>TreeNode* <br>tdSplayLeft(TreeNode* root) <br>{ <br>    TreeNode* t=root;   // current "search" point <br>    TreeNode* l=Dummy;  // root of "left subtree" &lt; keyItem <br>    TreeNode* r=Dummy;  // root of "right subtree" &gt; keyItem <br>    TreeNode* tmp; <br> <br>    if ( (t == NULL) || (t-&gt;left == NULL) ) <br>        return(t); <br>    if ( t-&gt;left-&gt;left == NULL ) { <br>        ROTATERIGHT; <br>        return(t); <br>    } <br>    Dummy-&gt;left = Dummy-&gt;right = NULL; <br>    while ( t-&gt;left != NULL ) { <br>        ROTATERIGHT; <br>        if ( t-&gt;left != NULL ) { <br>            LINKRIGHT; <br>        } <br>    } <br> <br>    ASSEMBLE; <br>    return(t); <br>} <br> <br>TreeNode* <br>tdSplayRight(TreeNode* root) <br>{ <br>    TreeNode* t=root;   // current "search" point <br>    TreeNode* l=Dummy;  // root of "left subtree" &lt; keyItem <br>    TreeNode* r=Dummy;  // root of "right subtree" &gt; keyItem <br>    TreeNode* tmp; <br> <br>    if ( (t == NULL) || (t-&gt;right == NULL) ) <br>        return(t); <br>    Dummy-&gt;left = Dummy-&gt;right = NULL; <br>    while ( t-&gt;right != NULL ) { <br>        ROTATELEFT; <br>        if ( t-&gt;right != NULL ) { <br>            LINKLEFT; <br>        } <br>    } <br> <br>    ASSEMBLE; <br>    return(t); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
