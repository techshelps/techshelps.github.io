<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PICKLTC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5007"></a>PICKLTC.C</h2>
<pre><code>/**************************************************************************** <br>                   Microsoft RPC Version 2.0 <br>           Copyright Microsoft Corp. 1992, 1993, 1994- 1996 <br>                      picklt Example <br> <br>    FILE:       pickltc.c <br> <br>    USAGE:      pickltc  -f filename  (file to write to/read from) <br>                         -d           (serialization direction: decode) <br>                         -e           (serialization direction: encode) <br>                         -i           (incremental serialization on) <br> <br>    PURPOSE:    The only side of RPC application <br> <br>    FUNCTIONS:  main() - serializes data to or from a file <br> <br>    COMMENTS:   Data type serialization is demonstrated here <br> <br>****************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "picklt.h"    // header file generated by MIDL compiler <br> <br>#define PURPOSE \ <br>"This Microsoft RPC Version 2.0 sample program demonstrates\n\ <br>the use of the [encode,decode] attributes. For more information\n\ <br>about the attributes and RPC API functions, see the RPC programming\n\ <br>guide and reference.\n\n" <br> <br>/*  ------------------------------------------------------------------------ */ <br>/*  Used for incremental style only. */ <br> <br>void __RPC_USER PicAlloc( void * pState, char ** ppBuf, unsigned int * pCount); <br>void __RPC_USER PicWrite( void * pState, char *  pBuf,  unsigned int Count); <br>void __RPC_USER PicRead ( void * pState, char ** pBuf,  unsigned int * pCount); <br> <br>typedef struct PickleControlBlock <br>{ <br>    unsigned char *         pMemBuffer; <br>    unsigned char *         pBufferStart; <br>    unsigned long           LastSize; <br>} PickleControlBlock; <br> <br>static PickleControlBlock                 UserState; <br>static PickleControlBlock * pUserState = &amp;UserState; <br>/*  ------------------------------------------------------------------------ */ <br> <br>void Usage(char * pszProgramName) <br>{ <br>    fprintf(stderr, "%s", PURPOSE); <br>    fprintf(stderr, "Usage:  %s\n", pszProgramName); <br>    fprintf(stderr, " -d\n"); <br>    fprintf(stderr, " -e\n"); <br>    fprintf(stderr, " -ffilename\n"); <br>    fprintf(stderr, " -i \n"); <br>    exit(1); <br>} <br> <br>void DumpData( <br>    char * pszComment, <br>    OBJECT2 * pObject2 ) <br>{ <br>    int i; <br> <br>    printf( "\n%s\n", pszComment ); <br> <br>    printf( "\tObject2"); <br>    printf( "\n\t\t%x", pObject2-&gt;sData ); <br>    printf( "\n\t\t%p", pObject2-&gt;pObject1 ); <br> <br>    if ( pObject2-&gt;pObject1 ) <br>        { <br>        OBJECT1 * pObject1 = pObject2-&gt;pObject1; <br> <br>        printf( "\n\tObject1"); <br>        for (i=0; i &lt; ARR_SIZE; i++) <br>            { <br>            if ( (i % 5) == 0 ) <br>                printf( "\n\t\t"); <br>            printf( "%08xl  ", pObject1-&gt;al[i] ); <br>            } <br>        printf( "\n\t\t%x\n", pObject1-&gt;s ); <br>        } <br> <br>    printf( "\n" ); <br>} <br> <br>void WriteDataToFile( <br>    char *          pszFileName, <br>    char *          pbBuffer, <br>    unsigned long   ulSizeToWrite ) <br>{ <br>    FILE *      pFile; <br>    size_t      Count; <br> <br>    if ( pszFileName ) { <br> <br>        pFile = fopen( pszFileName, "w+b" ); <br>        if ( pFile == NULL ) { <br>            printf("Cannot open the file for writing\n"); <br>            exit(1); <br>            } <br> <br>        Count = sizeof(long); <br>        if ( fwrite( &amp;ulSizeToWrite, sizeof(byte), Count, pFile) != Count ) { <br>            printf("Cannot write1 to the file\n"); <br>            exit(1); <br>            } <br> <br>        Count = (size_t) ulSizeToWrite; <br>        if ( fwrite( pbBuffer, sizeof(byte), Count, pFile) != Count ) { <br>            printf("Cannot write2 to the file\n"); <br>            exit(1); <br>            } <br> <br>        if ( fclose( pFile ) != 0) { <br>            printf("Failed to close the file\n"); <br>            exit(1); <br>            } <br>        } <br>} <br> <br>void ReadDataFromFile( <br>    char *          pszFileName, <br>    char *          pbBuffer, <br>    unsigned long   ulBufferSize ) <br>{ <br>    FILE *          pFile; <br>    size_t          Count; <br>    unsigned long   ulWrittenSize; <br> <br> <br>    if ( pszFileName ) { <br> <br>        pFile = fopen( pszFileName, "r+b" ); <br>        if ( pFile == NULL ) { <br>            printf("Cannot open the file for reading\n"); <br>            exit(1); <br>            } <br> <br>        Count = sizeof(long); <br>        if ( fread( &amp;ulWrittenSize, sizeof(byte), Count, pFile) != Count ) { <br>            printf("Cannot read1 from the file\n"); <br>            exit(1); <br>            } <br> <br>        Count = (size_t)ulWrittenSize; <br>        if ( fread( pbBuffer, sizeof(byte), Count, pFile) != Count ) { <br>            printf("Cannot read2 from the file\n"); <br>            exit(1); <br>            } <br> <br>        if ( fclose( pFile ) != 0) { <br>            printf("Failed to close the file\n"); <br>            exit(1); <br>            } <br>        } <br>} <br> <br>void _CRTAPI1 main(int argc, char **argv) <br>{ <br>    RPC_STATUS status; <br> <br>    unsigned char * pbPicklingBuffer = NULL; <br> <br>    char * pszStyle      = NULL; <br>    char * pszFileName   = "pickle.dat"; <br>    int i; <br>    int fEncode = 1; <br>    int fFixedStyle = 1; <br> <br>    /* allow the user to override settings with command line switches */ <br>    for (i = 1; i &lt; argc; i++) { <br>        if ((*argv[i] == '-') || (*argv[i] == '/')) { <br>            switch (tolower(*(argv[i]+1))) { <br>            case 'd': <br>                fEncode = 0; <br>                break; <br>            case 'e': <br>                fEncode = 1; <br>                break; <br>            case 'i': <br>                fFixedStyle = 0; <br>                break; <br>            case 'f': <br>                pszFileName = argv[i] + 2; <br>                break; <br>            case 'h': <br>            case '?': <br>            default: <br>                Usage(argv[0]); <br>            } <br>        } <br>        else <br>            Usage(argv[0]); <br>    } <br> <br>    /* Fixed buffer style: the buffer should be big enough. <br>       Please note that a pickling buffer has to be aligned at 8. <br> <br>       Also note, the buffer doesn't have to be allocated with <br>       the standard midl_user_allocate - this may be any allocator <br>       that alignes at 8. <br>       In general, midl_user_allocate is not required to return <br>       a buffer aligned at 8. <br>    */ <br> <br>    pbPicklingBuffer = (unsigned char *) <br>            midl_user_allocate( BUFSIZE * sizeof(unsigned char)); <br> <br>    if ( pbPicklingBuffer == NULL ) { <br>        printf("Cannot allocate the pickling buffer\n"); <br>        exit(1); <br>        } <br>    else <br>        memset( pbPicklingBuffer, 0xdd, BUFSIZE ); <br> <br>    /* <br>        Set the pickling handle that will be used for data serialization. <br>        The global ImplicitPicHandle is used, but it has to be set up. <br>    */ <br> <br>    if ( fEncode ) { <br> <br>        unsigned char * pszNameId; <br>        OBJECT1         Object1; <br>        OBJECT2         Object2a,  *pObject2b; <br> <br>        unsigned long   ulEncodedSize = 0; /* this is a cumulative size */ <br> <br>        printf("\nEncoding run: use -d for decoding\n\n"); <br> <br>        if ( fFixedStyle ) { <br> <br>            printf("Creating a fixed buffer encoding handle\n"); <br>            status = MesEncodeFixedBufferHandleCreate( pbPicklingBuffer, <br>                                                       BUFSIZE, <br>                                                       &amp; ulEncodedSize, <br>                                                       &amp; ImplicitPicHandle ); <br>            printf("MesEncodeFixedBufferHandleCreate returned 0x%x\n", status); <br>            if (status) { <br>                exit(status); <br>            } <br>        } <br>        else { <br>            /* Incremental style */ <br> <br>            pUserState-&gt;LastSize = 0; <br>            pUserState-&gt;pMemBuffer = (char *)pbPicklingBuffer; <br>            pUserState-&gt;pBufferStart = (char *)pbPicklingBuffer; <br> <br>            printf("Creating an incremental encoding handle\n"); <br>            status = MesEncodeIncrementalHandleCreate( pUserState, <br>                                                       PicAlloc, <br>                                                       PicWrite, <br>                                                       &amp; ImplicitPicHandle ); <br>            printf("MesEncodeIncrementalHandleCreate returned 0x%x\n", status); <br>            if (status) { <br>                exit(status); <br>            } <br>        } <br> <br>        /* Creating objects to manipulate */ <br> <br>        pszNameId = "Pickling sample"; <br> <br>        for (i = 0; i &lt; ARR_SIZE; i++) <br>            Object1.al[i] = 0x73730000 + i; <br>        Object1.s = 0x6464; <br> <br>        Object2a.sData = 0xa9a9; <br>        Object2a.pObject1 = NULL; <br> <br>        pObject2b = midl_user_allocate( sizeof(OBJECT2) ); <br>        if (pObject2b == NULL ) { <br>            printf("Out of memory for Object2b\n"); <br>            exit(1); <br>        } <br>        pObject2b-&gt;sData = 0xb8b8; <br>        pObject2b-&gt;pObject1 = &amp; Object1; <br> <br>        DumpData( "Data to be encoded", &amp;Object2a ); <br>        printf("\nEncoding Object2a data to the buffer\n"); <br>        OBJECT2_Encode( &amp;Object2a ); <br> <br>        /* The second object is encoded to the same buffer, <br>           the size used below is cumulative. <br>           Note that using procedure pickling instead of type pickling, <br>           both objects could be encoded with one call. <br>        */ <br> <br>        DumpData( "Data to be encoded", pObject2b ); <br>        printf("\nEncoding Object2b data to the buffer\n\n"); <br>        OBJECT2_Encode( pObject2b ); <br> <br>        printf("Writing the data to the file: %s\n", pszFileName); <br>        WriteDataToFile( pszFileName, <br>                         pbPicklingBuffer, <br>                         fFixedStyle  ? ulEncodedSize <br>                                      : pUserState-&gt;LastSize); <br> <br>        midl_user_free( pObject2b ); <br>    } <br>    else { <br>        OBJECT2      Object2c, Object2d; <br> <br>        printf("\nDecoding run: use -e for encoding\n\n"); <br> <br>        printf("Reading the data from the file: %s\n\n", pszFileName ); <br>        ReadDataFromFile( pszFileName, <br>                          pbPicklingBuffer, <br>                          BUFSIZE ); <br> <br>        if ( fFixedStyle ) { <br> <br>            printf("Creating a decoding handle\n"); <br>            status = MesDecodeBufferHandleCreate( pbPicklingBuffer, <br>                                                  BUFSIZE, <br>                                                  &amp; ImplicitPicHandle ); <br>            printf("MesDecodeFixedBufferHandleCreate returned 0x%x\n", status); <br>            if (status) { <br>                exit(status); <br>            } <br>        } <br>        else { <br> <br>            pUserState-&gt;LastSize = 0; <br>            pUserState-&gt;pMemBuffer = (char *)pbPicklingBuffer; <br>            pUserState-&gt;pBufferStart = (char *)pbPicklingBuffer; <br> <br>            printf("Creating an incremental decoding handle\n"); <br>            status = MesDecodeIncrementalHandleCreate( pUserState, <br>                                                       PicRead, <br>                                                       &amp; ImplicitPicHandle ); <br>            printf("MesDecodeIncrementalHandleCreate returned 0x%x\n", status); <br>            if (status) { <br>                exit(status); <br>            } <br>        } <br> <br>        /* Creating objects to manipulate */ <br> <br>        Object2c.pObject1 = NULL; <br>        Object2d.pObject1 = NULL; <br> <br>        printf("\nDecoding Object2c data from the buffer\n"); <br>        OBJECT2_Decode( &amp; Object2c ); <br>        DumpData( "Decoded data",  &amp;Object2c ); <br> <br>        printf("\nDecoding Object2d data from the buffer\n"); <br>        OBJECT2_Decode( &amp; Object2d ); <br>        DumpData( "Decoded data",  &amp;Object2d ); <br> <br>        /* Need to free Object1 objects as they may have been allocated <br>           when unmarshalling data. <br>        */ <br> <br>        if ( Object2c.pObject1 ) <br>            midl_user_free( Object2c.pObject1 ); <br>        if ( Object2d.pObject1 ) <br>            midl_user_free( Object2d.pObject1 ); <br>    } <br> <br>    printf("\nData serialization done.\n"); <br> <br>    midl_user_free( pbPicklingBuffer ); <br> <br>    printf("\nFreeing the serialization handle.\n"); <br>    status = MesHandleFree( ImplicitPicHandle ); <br>    printf("MesHandleFree returned 0x%x\n", status); <br> <br>    exit(0); <br> <br>}  // end main() <br> <br>/*********************************************************************/ <br>/*                 MIDL allocate and free                            */ <br>/*********************************************************************/ <br> <br>/* A pickling buffer has to be aligned at 8. <br>   malloc() doesn't guarantee that, so some gimmick has to be done. <br>*/ <br> <br>#define ALIGN_TO8( p)   (char *)((unsigned long)((char *)p + 7) &amp; ~7) <br> <br>void __RPC_FAR * __RPC_USER  MIDL_user_allocate(size_t s) <br>{ <br>    unsigned char * pcAllocated; <br>    unsigned char * pcUserPtr; <br> <br>    pcAllocated = (unsigned char *) malloc( s + 15 ); <br>    pcUserPtr =  ALIGN_TO8( pcAllocated ); <br>    if ( pcUserPtr == pcAllocated ) <br>        pcUserPtr = pcAllocated + 8; <br> <br>    *(pcUserPtr - 1) = pcUserPtr - pcAllocated; <br> <br>    return( pcUserPtr ); <br>} <br> <br>void __RPC_USER  MIDL_user_free(void __RPC_FAR *f) <br>{ <br>    unsigned char * pcAllocated; <br>    unsigned char * pcUserPtr; <br> <br>    pcUserPtr = (unsigned char *) f; <br>    pcAllocated = pcUserPtr - *(pcUserPtr - 1); <br> <br>    free( pcAllocated ); <br>} <br> <br>/*********************************************************************/ <br>/*                 Incremental style helper routines                 */ <br>/*********************************************************************/ <br> <br>void  __RPC_USER <br>PicAlloc( <br>    void *          pState, <br>    char **         ppBuf, <br>    unsigned int  * pCount ) <br>{ <br>    /* This routines "allocates" the next part from the preallocated <br>       buffer. It could call midl_user_allocate, too. <br>    */ <br> <br>    PickleControlBlock * pPic = (PickleControlBlock *)pState; <br> <br>    if ( (pPic-&gt;pMemBuffer - pPic-&gt;pBufferStart) + *pCount &lt;= BUFSIZE ) <br>        *ppBuf = (char *)pPic-&gt;pMemBuffer; <br>    else { <br>        printf(" Buffer too small\n"); <br>        exit(1); <br>    } <br>} <br> <br>void __RPC_USER <br>PicWrite( <br>    void *          pState, <br>    char *          pBuf, <br>    unsigned int    Count ) <br>{ <br>    /* This routine just marks how much of the preallocated buffer is used. <br>    */ <br> <br>    PickleControlBlock * pPic = (PickleControlBlock *)pState; <br> <br> <br>    if ( pPic-&gt;pMemBuffer != pBuf ) { <br>        printf(" Buffer poiner corrupted\n"); <br>        exit(1); <br>    } <br>    pPic-&gt;pMemBuffer += Count; <br>    pPic-&gt;LastSize += Count; <br>} <br> <br>void __RPC_USER <br>PicRead( <br>    void *          pState, <br>    char **         ppBuf, <br>    unsigned int  * pCount ) <br>{ <br>    /* This routine returns another portion of the preread buffer. */ <br> <br>    PickleControlBlock * pPic = (PickleControlBlock *)pState; <br> <br>    *ppBuf = (char *)pPic-&gt;pMemBuffer; <br>    pPic-&gt;pMemBuffer += *pCount; <br>} <br> <br>/* end pickltc.c */ <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
