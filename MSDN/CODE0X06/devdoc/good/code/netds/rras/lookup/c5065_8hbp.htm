<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ALGO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5065"></a>ALGO.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995  Microsoft Corporation <br> <br>Module Name: <br> <br>    net\ip\lookup\algo.c <br> <br>Abstract: <br> <br> <br>Revision History: <br> <br> <br> <br>--*/ <br> <br>DWORD g_dwBitMask = {0x00000001, <br>                     0x00000002, <br>                     0x00000004, <br>                     0x00000008, <br>                     0x00000010, <br>                     0x00000020, <br>                     0x00000040, <br>                     0x00000080, <br>                     0x00000100, <br>                     0x00000200, <br>                     0x00000400, <br>                     0x00000800, <br>                     0x00001000, <br>                     0x00002000, <br>                     0x00004000, <br>                     0x00008000, <br>                     0x00010000, <br>                     0x00020000, <br>                     0x00040000, <br>                     0x00080000, <br>                     0x00100000, <br>                     0x00200000, <br>                     0x00400000, <br>                     0x00800000, <br>                     0x01000000, <br>                     0x02000000, <br>                     0x04000000, <br>                     0x08000000, <br>                     0x10000000, <br>                     0x20000000, <br>                     0x40000000, <br>                     0x80000000}; <br> <br> <br>DWORD g_dwPrefixMask = {0x00000001, <br>                        0x00000003, <br>                        0x00000007, <br>                        0x0000000F, <br>                        0x0000001F, <br>                        0x0000003F, <br>                        0x0000007F, <br>                        0x000000FF, <br>                        0x000001FF, <br>                        0x000003FF, <br>                        0x000007FF, <br>                        0x00000FFF, <br>                        0x00001FFF, <br>                        0x00003FFF, <br>                        0x00007FFF, <br>                        0x0000FFFF, <br>                        0x0001FFFF, <br>                        0x0003FFFF, <br>                        0x0007FFFF, <br>                        0x000FFFFF, <br>                        0x001FFFFF, <br>                        0x003FFFFF, <br>                        0x007FFFFF, <br>                        0x00FFFFFF, <br>                        0x01FFFFFF, <br>                        0x03FFFFFF, <br>                        0x07FFFFFF, <br>                        0x0FFFFFFF, <br>                        0x1FFFFFFF, <br>                        0x3FFFFFFF, <br>                        0x7FFFFFFF, <br>                        0xFFFFFFFF} <br> <br> <br> <br>BYTE <br>DistPos( <br>    IN  PTRIE_KEY   ptkKey1, <br>    IN  PTRIE_KEY   ptkKey2 <br>    ) <br>/*++ <br>  Routine Description <br>      Returns the position of the distinguishing bit for two keys. This is <br>      the first bit that differs between the two keys.  If one key is a prefix <br>      of another (strict or non strict), then the dist bit is 1+width of the smaller <br>      key (== length of smaller key) <br>       <br>      Notationally: <br>      DistBit(K1, K2) = Min{i|K1[i] != K2[i]} <br>      DistBit(K1, K2) = Length(K1) iff K1 is a prefix of K2 <br>       <br>       <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    BYTE    byLength; <br>     <br>    byLength = MAX(Length(ptkKey1), <br>                   Length(ptkKey2)); <br>     <br>    for(i = 0; i &lt; byLength; i++) <br>    { <br>        if(ptkKey1-&gt;dwAddr &amp; g_dwBitMask[i] isnot <br>           ptkKey2-&gt;dwAddr &amp; g_dwBitMask[i]) <br>        { <br>            break; <br>        } <br>    } <br>     <br>    return i; <br>} <br> <br> <br> <br> <br> <br>     <br>PTRIE_KEY <br>GetKey( <br>    IN  PTRIE_NODE  ptnNode, <br>    IN  PTRIE_KEY   ptkKey, <br>    OUT PBYTE       pbyPosition <br>    ) <br>/*++ <br>  Routine Description <br>      Given a input key and node, returns the stored key in the node <br>      whose index bit matches with the input key <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>     <br>    if(Width(ptkKey) &lt; Index(ptnNode)) <br>    { <br>        return NULL; <br>    } <br> <br>    *pbyPosition = GetRelevantBit(ptkKey-&gt;dwAddr, Index(ptnNode)); <br>     <br>#if DBG <br> <br>    // <br>    // A little consistency check here <br>    // <br>     <br>    if(LeftKey(ptnNode)) <br>    { <br>        ASSERT(ptnNode-&gt;byPosition is LEFT); <br>    } <br> <br>    if(RightKey(ptnNode)) <br>    { <br>        ASSERT(ptnNode-&gt;byPosition is RIGHT); <br>    } <br>     <br>#endif <br>     <br>    return GetKeyByPosition(ptnNode, <br>                            *pbyPosition); <br>} <br> <br>PTRIE_NODE <br>GetSubTrie( <br>    IN  PTRIE_NODE  ptnNode, <br>    IN  PTRIE_KEY   ptkKey, <br>    OUT PBYTE       pbyPosition <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>     <br>    if(Width(ptkKey) &lt; Index(ptnNode)) <br>    { <br>        return NULL; <br>    } <br> <br>    *pbyPosition = GetRelevantBit(ptkKey-&gt;dwAddr, Index(ptnNode)); <br> <br>#if DBG <br> <br>    // <br>    // A little consistency check here <br>    // <br>     <br>    if(LeftSubTrie(ptnNode)) <br>    { <br>        ASSERT(ptnNode-&gt;ptnTrie[LEFT]-&gt;byPosition is LEFT); <br>    } <br> <br>    if(RightSubTrie(ptnNode)) <br>    { <br>        ASSERT(ptnNode-&gt;ptnTrie[RIGHT]-&gt;byPosition is RIGHT); <br>    } <br>     <br>#endif <br> <br>    return GetSubTrieByPosition(ptnNode, <br>                                *pbyPosition); <br>     <br>} <br> <br>PTRIE_KEY <br>GetClosestKey( <br>    PTRIE_NODE  ptnNode, <br>    PTRIE_KEY   ptkKey <br>    ) <br>/*++ <br>  Routine Description <br>      If the length of the key is greater than or equal to the index, return <br>      any Key. <br>      else <br>         If a key with matching relevant bit is found, return that, else <br>         return the other key <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PTRIE_KEY   ptkTemp; <br>    BYTE        byPos; <br>     <br>    if(Width(ptkKey) &gt;= Index(ptnNode)) <br>    { <br>        ptkTemp = GetKey(ptnNode, <br>                         ptkKey, <br>                         &amp;byPos); <br>         <br>        if(ptkTemp isnot NULL) <br>        { <br>            return ptkTemp; <br>        } <br>        else <br>        { <br>            return GetKeyByPosition(ptnNode, <br>                                    ComplementPosition(byPos)) <br>        } <br>    } <br>    else <br>    { <br>        // <br>        // For now we return the left key first <br>        // <br> <br>        ptkTemp = GetKeyByPosition(ptnNode, <br>                                   LEFT); <br>         <br>        if(ptkTemp) <br>        { <br>            return ptkTemp; <br>        } <br>        else <br>        { <br>            return GetKeyByPosition(ptnNode, <br>                                    RIGHT); <br>        } <br>    } <br>} <br> <br>PTRIE_NODE <br>GetClosestSubTrie( <br>    PTRIE_NODE  ptnNode, <br>    PTRIE_KEY   ptkKey <br>    ) <br>/*++ <br>  Routine Description <br>      If the length of the key is greater than or equal to the index, return <br>      any sub trie. <br>      else <br>         If a trie with matching relevant bit is found, return that, else <br>         return the other trie <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PTRIE_NODE  ptnTemp; <br>    BYTE        byPos; <br> <br>     <br>    if(Width(ptkKey) &gt;= Index(ptnNode)) <br>    { <br>        ptnTemp = GetSubTrie(ptnNode, <br>                             ptkKey, <br>                             &amp;byPos); <br>         <br>        if(ptnTemp isnot NULL) <br>        { <br>            return ptnTemp; <br>        } <br>        else <br>        { <br>            return GetSubTrieByPosition(ptnNode, <br>                                        ComplementPosition(byPos)) <br>        } <br>    } <br>    else <br>    { <br>        // <br>        // For now we return the left trie first <br>        // <br> <br>        ptkTemp = GetSubTrieByPosition(ptnNode, <br>                                       LEFT); <br>         <br>        if(ptkTemp) <br>        { <br>            return ptkTemp; <br>        } <br>        else <br>        { <br>            return GetSubTrieByPosition(ptnNode, <br>                                        RIGHT); <br>        } <br>    } <br>} <br> <br>PTRIE_NODE <br>CreateNode( <br>    IN  BYTE        byIndex, <br>    IN  PTRIE_KEY   ptkKey <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PTRIE_NODE  ptnNode; <br> <br>    ptnNode = HeapAlloc(g_hPrivateHeap, <br>                        0, <br>                        sizeof(TRIE_NODE)); <br> <br>    if(ptnNode is NULL) <br>    { <br>        printf("Unable to allocate node. Error %d\n", <br>               GetLastError()); <br> <br>        return NULL; <br>    } <br>     <br>    ptnNode-&gt;ptnTrie[LEFT]  = NULL; <br>    ptnNode-&gt;ptnTrie[RIGHT] = NULL; <br>     <br>    ptnNode-&gt;ptnParent      = NULL; <br> <br>    ptnNode-&gt;byIndex        = byIndex; <br> <br>    // <br>    // See where the key would go into the allocated node <br>    // <br>     <br>    GetKey(ptnNode, <br>           ptkKey, <br>           &amp;byPos); <br> <br>    // <br>    // Since we are going to be inserting the key here, set <br>    // its position field also <br>    // <br> <br>    ptkKey-&gt;byPos = byPos; <br>     <br>    ptnNode-&gt;rgptkKey[byPos]  = ptkKey; <br>     <br>    ptnNode-&gt;rgptkKey[ComplementPosition(byPos)] = NULL; <br> <br>    return ptnNode; <br>} <br> <br>DWORD <br>InsertKey( <br>    PTRIE_NODE  *pptnRoot, <br>    PTRIE_KEY   ptkKey <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PTRIE_NODE  ptnTempNode; <br> <br>    if(*pptnRoot is NULL) <br>    { <br>        *pptnRoot = AllocateNode(Width(ptkKey), <br>                                 ptkKey); <br> <br>        if(*pptnRoot is NULL) <br>        { <br>            return ERROR_NOT_ENOUGH_MEMORY; <br>        } <br> <br>        return NO_ERROR; <br>    } <br> <br>    ptnTempNode = *pptnRoot; <br> <br>    // <br>    // Descend the tree, branching according to the Index bit <br>    // Stop when the node is a leaf OR <br>    // when the index is greater than the width of the key OR <br>    // when the prefix of the node is not the same as the key <br>    // <br>    // The prefix is found by (ptkKey-&gt;dwAddr &amp; g_dwPrefixMask[Index]) <br>    // <br>     <br>    while(!IsLeafNode(ptnTempNode) and <br>          (Width(ptkKey) &gt; Index(ptnTempNode)) and <br>          (ptnTempNode-&gt;rgptkKey[ptnTempNode-&gt;byNonNullKey] &amp; g_dwPrefixMask[Index(ptnTempNode)] is <br>           ptkKey[ <br>    { <br>        ptnTempNode = ClosestSubTrie(ptnTempNode, <br>                                     ptkKey); <br>    } <br> <br>    byDistPost = DistPos(key, <br>                         ClosestKey(ptnNode,ptkKey)); <br> <br>    byIndex = MIN(Lenght(Key), byDistPos); <br> <br>    if(ptnTempNode is *pptnRoot) <br>    { <br>        InsertInOrAbove(pptnRoot, <br>                        ptnTempNode, <br>                        ptkKey, <br>                        byDistPos); <br>    } <br>    else <br>    { <br>        if(GetSubTrie(ptnNode, ptkKey) is NULL) <br>        { <br>            InsertWithEmptySubTrie(ptnNode, <br>                                   ptkKey, <br>                                   byDistPos); <br>        } <br>        else <br>        { <br>            InsertWithNonEmptySubTrie(ptnNode, <br>                                      ptkKey, <br>                                      byDistPos); <br>        } <br>    } <br> <br>    return NO_ERROR; <br>} <br>     <br>DWORD <br>InsertInOrAbove( <br>    PTRIE_NODE  *pptnRoot, <br>    PTRIE_NODE  ptnNode, <br>    PTRIE_KEY   ptkKey, <br>    BYTE        byDistPos <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    if( </code></pre>
<p>&nbsp;</p></body>
</HTML>
