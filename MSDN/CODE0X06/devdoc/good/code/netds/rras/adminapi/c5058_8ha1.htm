<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMAPIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5059"></a>ADMAPIT.C</h2>
<pre><code>/****************************************************************************** <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This sample source code is only intended as a supplement to <br>*       MprAdmin API usage and is meant to help users with the <br>*       MprAdmin API calling convention. Use this code at your own risk. <br>*       Microsoft disclaims any implied warranty. This sample code can <br>*       be copied and distributed. <br> <br>******************************************************************************/ <br> <br>/******************************************************************** <br>*  admapit.c -- Sample program demonstrating the use of different <br>*                     MprAdmin API <br>* <br>*  Comments: <br>* <br>* This program expects \\Servername  as its arguments. <br>* <br>* MprAdminGetErrorString API returns error string. However <br>* this API may return an Error 87 (Invalid Parameter) for the non <br>* RAS error codes. This API is designed for only RAS related error codes. <br>* For more Info. check the documentation. I am using this API for all the <br>* errors but I print the error codes before calling this API <br>* <br>*****************************************************************************/ <br>/*************************************************************************** <br>*  Functions: <br>*      Init2(void); <br>*      Init1(void); <br>*      PrintGetStringError(DWORD dwResult); <br>*      UserPrivilege(WCHAR *DomainName, WCHAR *UserName); <br>*      PrintPriv(WCHAR *DomainName, WCHAR *UserName); <br>*      PrintClearStats(WCHAR * RasSrv, WCHAR *wszPortName); <br>*      WINAPI RasAdminClearDisc(LPVOID param); <br>*      IsServiceRunning(WCHAR *RasSrv); <br>*      Debug_Print_Connection0(RAS_CONNECTION_0 *pRasConnection0); <br>*      Debug_Print_Connection1(RAS_CONNECTION_1 *pRasConnection1); <br>*      Debug_Print_RAS_PORT0(RAS_PORT_0 *pRasPort0); <br>*      Debug_Print_RAS_PORT1(RAS_PORT_1 *pRasPort1); <br>*      File_Print_Connection0(RAS_CONNECTION_0 *pRasConnection0); <br>*      File_Print_Connection1(RAS_CONNECTION_1 *pRasConnection1); <br>*      File_Print_RAS_PORT0(RAS_PORT_0 *pRasPort0); <br>*      File_Print_RAS_PORT1(RAS_PORT_1 *pRasPort1); <br>*      ProcPortClearStat(HANDLE hPort); <br>*      ProcConnectionClearStat(HANDLE hConnection); <br>*      ProcPortReset(HANDLE hPort); <br>*      ProcPortDisconnect(HANDLE hPort); <br>*      ProcConnectionGetInfo(HANDLE hConnection); <br>*      ProcPortGetInfo(HANDLE hPort); <br>*****************************************************************************/ <br> <br> <br>#define  sleeptime 10000 <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;lm.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;mprapi.h&gt; <br>#include &lt;memory.h&gt; <br> <br>//Function Definitions <br>VOID Init2(void); <br>VOID Init1(void); <br>VOID PrintGetStringError(DWORD dwResult); <br>VOID UserPrivilege(WCHAR *DomainName, WCHAR *UserName); <br>VOID PrintPriv(WCHAR *DomainName, WCHAR *UserName); <br>VOID PrintClearStats(WCHAR * RasSrv, WCHAR *wszPortName); <br>DWORD WINAPI RasAdminClearDisc(LPVOID param); <br>INT IsServiceRunning(WCHAR *RasSrv); <br>VOID Debug_Print_Connection0(RAS_CONNECTION_0 *pRasConnection0); <br>VOID Debug_Print_Connection1(RAS_CONNECTION_1 *pRasConnection1); <br>VOID Debug_Print_RAS_PORT0(RAS_PORT_0 *pRasPort0); <br>VOID Debug_Print_RAS_PORT1(RAS_PORT_1 *pRasPort1); <br>VOID File_Print_Connection0(RAS_CONNECTION_0 *pRasConnection0); <br>VOID File_Print_Connection1(RAS_CONNECTION_1 *pRasConnection1); <br>VOID File_Print_RAS_PORT0(RAS_PORT_0 *pRasPort0); <br>VOID File_Print_RAS_PORT1(RAS_PORT_1 *pRasPort1); <br>VOID ProcPortClearStat(HANDLE hPort); <br>VOID ProcConnectionClearStat(HANDLE hConnection); <br>VOID ProcPortReset(HANDLE hPort); <br>VOID ProcPortDisconnect(HANDLE hPort); <br>VOID ProcConnectionGetInfo(HANDLE hConnection); <br>VOID ProcPortGetInfo(HANDLE hPort); <br> <br> <br>// Global Variables <br>WCHAR* <br>StrDupWFromA( <br>    CHAR* psz ); <br> <br> <br>#define Number_Of_Flags 6 <br> <br>HANDLE LogFile  = NULL; <br>HANDLE cLogFile = NULL; <br>HANDLE ErrLogFile = NULL; <br> <br>CHAR buf[120]; <br>BOOL First_Call = TRUE; <br>DWORD Status = 0; <br>DWORD dwResult = 0; <br>DWORD dwBytesWritten = 0; <br>CHAR szBuf[120]; <br>BOOL ErrLogInValid = FALSE; <br>BOOL cErrLogInValid = FALSE; <br>BOOL LogInValid = TRUE; <br>WCHAR szUserAccountServer[UNLEN+1]; <br>PRAS_USER_0 ppRasUser0; <br>RAS_USER_0 RasUser0; <br>WCHAR lpszServerName[50]; <br>WCHAR RasSrv[64]; <br>BOOL Quit=FALSE; <br> <br>RAS_SERVER_HANDLE  phRasServer; <br> <br> <br>// Function Starts <br>WCHAR* <br>StrDupWFromA( <br>    CHAR* psz ) <br> <br>    /* Returns heap block containing a copy of 0-terminated string 'psz' or <br>    ** NULL on error or if 'psz' is NULL.  The output string is converted to <br>    ** UNICODE.  It is caller's responsibility to Free the returned string. <br>    */ <br>{ <br>   WCHAR* pszNew = NULL; <br> <br>   if (psz) <br>   { <br>      DWORD cb; <br> <br>      cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, NULL, 0 ); <br> <br>      pszNew = malloc( cb * sizeof(TCHAR) ); <br>      if (!pszNew) <br>      { <br>         return NULL; <br>      } <br> <br>      cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, pszNew, cb ); <br>      if (cb == 0) <br>      { <br>         free( pszNew ); <br>         return NULL; <br>      } <br>   } <br>   return pszNew; <br>} <br> <br> <br>// <br>// Format and write debug information to OutputDebugString <br>// <br>ULONG <br>_cdecl <br>DbgPrint( <br>    PCH Format, <br>    ... <br>    ) <br>{ <br>   CHAR szbuffer[255]; <br>   WCHAR buffer[255]; <br>   WCHAR *temp = NULL; <br>   LPINT lpResult=0; <br>   va_list marker; <br>   va_start (marker,Format); <br>   if (IsTextUnicode(marker, sizeof(marker),lpResult)) <br>   { <br>      temp = StrDupWFromA(Format); <br>      wvsprintfW (buffer,temp, marker); <br>      OutputDebugString (buffer); <br>      free(temp); <br>   } <br>   else <br>   { <br>      wvsprintfA (szbuffer,Format, marker); <br>      temp=StrDupWFromA(szbuffer); <br>      OutputDebugString (temp); <br>      free(temp); <br>   } <br>   return TRUE; <br>} <br> <br> <br> <br> <br>// <br>// Init Functions to setup logfiles <br>// <br> <br>VOID Init1(void) <br>{ <br>   //Store port  information in this file <br>   LogInValid = FALSE; <br>   LogFile = CreateFile(TEXT("Admin.log"), <br>                        GENERIC_READ|GENERIC_WRITE, <br>                        FILE_SHARE_READ, <br>                        (LPSECURITY_ATTRIBUTES) NULL, <br>                        CREATE_ALWAYS, <br>                        0, <br>                        (HANDLE) NULL); <br> <br>   if (LogFile== INVALID_HANDLE_VALUE) <br>   { <br>      LogInValid = TRUE; <br>   } <br> <br>} <br> <br> <br>VOID Init2(void) <br>{ <br>   cErrLogInValid = FALSE; <br>   ErrLogInValid = FALSE; <br>   //Stores Statistics and port disconnect information in this file <br>   cLogFile = CreateFile(TEXT("AdminStats.log"), <br>                         GENERIC_READ|GENERIC_WRITE, <br>                         FILE_SHARE_READ, <br>                         (LPSECURITY_ATTRIBUTES) NULL, <br>                         CREATE_ALWAYS, <br>                         0, <br>                         (HANDLE) NULL); <br>   if (cLogFile== INVALID_HANDLE_VALUE) <br>   { <br>      cErrLogInValid = TRUE; <br>   } <br> <br>   //Stores user privilege information in this file <br>   ErrLogFile = CreateFile(TEXT("AdminUser.log"), <br>                           GENERIC_READ|GENERIC_WRITE, <br>                           FILE_SHARE_READ, <br>                           (LPSECURITY_ATTRIBUTES) NULL, <br>                           CREATE_ALWAYS, <br>                           0, <br>                           (HANDLE) NULL); <br> <br>   if (ErrLogFile== INVALID_HANDLE_VALUE) <br>   { <br>      ErrLogInValid = TRUE; <br>   } <br> <br>} <br> <br> <br>// <br>// Function to print error strings <br>// <br>VOID PrintGetStringError(DWORD dwResult) <br>{ <br>CHAR  szBuf[120]; <br>DWORD dwBytesWritten = 0; <br> <br>   DbgPrint("ERROR  MprAdminGetErrorString      %d\n",dwResult); <br>   sprintf(szBuf, "ERROR  MprAdminGetErrorString      %d\n",dwResult); <br>   WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>} <br> <br> <br>// <br>// Function to see if the service running <br>// <br>INT IsServiceRunning(WCHAR *RasSrv) <br>{ <br>DWORD dwResult; <br>CHAR  szBuf[120]; <br>DWORD dwBytesWritten = 0; <br> <br>   //Calling MprAdminIsServiceRunning <br>   // Parameters: <br>   // IN LPWSTR   * RasSrv <br>   dwResult = MprAdminIsServiceRunning(RasSrv); <br>   if (dwResult) <br>   { <br>      DbgPrint("Ras AND Router Serivce running on the Server\n"); <br>      sprintf(szBuf, "Ras AND Router Serivce running on the Server\n"); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      //Calling MprAdminServerConnect <br>      // Parameters <br>      // IN LPWSTR    * RasSrv <br>      // OUT RAS_SERVER_HANDLE * phRasServer <br>      dwResult = MprAdminServerConnect(RasSrv, &amp;phRasServer); <br>      if (dwResult != NO_ERROR) <br>      { <br>         DbgPrint("Failed to Connect to Server\n"); <br>         sprintf(szBuf, "Failed to Connect to Server\n"); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>         return 0; <br>      } <br>   } <br>   else <br>   { <br>      DbgPrint("Ras AND Router Serivce is NOT running on the Server\n"); <br>      sprintf(szBuf, "Ras AND Router Serivce is NOT running on the Server\n"); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      return 0; <br>   } <br>   return 1; <br>} <br> <br> <br>// <br>// Function to print user privileges to logfile <br>// <br>VOID PrintPriv(WCHAR *DomainName, WCHAR *UserName) <br>{ <br>//DWORD Permission; <br>DWORD dwBytesWritten = 0; <br>CHAR  szBuf[120]; <br> <br>     /*********** from mprapi.h ****************************************************/ <br>     // <br>     // Note: Bit 0 MUST represent NoCallback due to a quirk of the "userparms" <br>     //       storage method.  When a new LAN Manager user is created, bit 0 of the <br>     //       userparms field is set to 1 and all other bits are 0.  These bits are <br>     //       arranged so this "no Dial-In info" state maps to the "default Dial-In <br>     //       privilege" state. <br>     // <br>     // #define RASPRIV_NoCallback        0x01 <br>     // #define RASPRIV_AdminSetCallback  0x02 <br>     // #define RASPRIV_CallerSetCallback 0x04 <br>     // #define RASPRIV_DialinPrivilege   0x08 <br>     // <br>     // #define RASPRIV_CallbackType (RASPRIV_AdminSetCallback \ <br>     //                             | RASPRIV_CallerSetCallback \ <br>     //                             | RASPRIV_NoCallback) <br>     /*****************************************************************************/ <br> <br>     sprintf(szBuf,"\nDomainName =  %ws\nUserName = %ws\n",DomainName, UserName); <br>     WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br> <br>     sprintf(szBuf,"ppRasUser0-&gt;bfPrivilege = 0x%x\n",ppRasUser0-&gt;bfPrivilege); <br>     WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br> <br>     // <br>     // display the privilege flags <br>     // <br>     if ((ppRasUser0-&gt;bfPrivilege) &amp; (RASPRIV_NoCallback)) <br>     { <br>        sprintf(szBuf, "\t\tRASPRIV_NoCallback        = 0x%x\n", (ppRasUser0-&gt;bfPrivilege &amp; (RASPRIV_NoCallback))); <br>        WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>     } <br>     if ((ppRasUser0-&gt;bfPrivilege) &amp; (RASPRIV_AdminSetCallback)) <br>     { <br>        sprintf(szBuf, "\t\tRASPRIV_AdminSetCallback  = 0x%x\n", (ppRasUser0-&gt;bfPrivilege &amp; (RASPRIV_AdminSetCallback))); <br>        WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>     } <br>     if ((ppRasUser0-&gt;bfPrivilege) &amp; (RASPRIV_CallerSetCallback)) <br>     { <br>        sprintf(szBuf, "\t\tRASPRIV_CallerSetCallback = 0x%x\n", (ppRasUser0-&gt;bfPrivilege &amp; (RASPRIV_CallerSetCallback))); <br>        WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>     } <br>     if ((ppRasUser0-&gt;bfPrivilege) &amp; (RASPRIV_DialinPrivilege)) <br>     { <br>        sprintf(szBuf, "\t\tRASPRIV_DialinPrivilege   = 0x%x\n", (ppRasUser0-&gt;bfPrivilege &amp; (RASPRIV_DialinPrivilege))); <br>        WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>     } <br>} <br> <br> <br>// <br>// Function to get and change User Dialin Privileges. <br>// It goes through all the Dialin Privileges for a user. <br>// <br>VOID UserPrivilege(WCHAR *DomainName, WCHAR *UserName) <br>{ <br> <br>DWORD dwResult; <br>CHAR  szBuf[120]; <br>DWORD dwBytesWritten = 0; <br>WCHAR Buf[512]; <br>WCHAR *lpszString; <br>static DWORD LoopPriv = 0; <br>static BYTE Dialin = 1; <br>lpszString = &amp;Buf[0]; <br>ppRasUser0 = &amp;RasUser0; <br> <br>   // API Called:     MprAdminGetPDCServer <br>   // Parameters: <br>   //  IN WCHAR * lpwsDomainName <br>   //  IN WCHAR * lpwsServerName <br>   //  OUT WCHAR * lpwsPDCServer <br>   dwResult = MprAdminGetPDCServer(DomainName, NULL, &amp;szUserAccountServer[0]); <br>   if (dwResult == NO_ERROR) <br>   { <br>      // API Called:     MprAdminUserGetInfo <br>      // Parameters: <br>      // IN WCHAR * lpwsServerName <br>      // IN WCHAR * lpwsUserName <br>      // IN DWORD dwLevel <br>      // OUT LPBYTE *lpbBuffer <br>      dwResult = MprAdminUserGetInfo(szUserAccountServer, UserName,(DWORD) 0, (LPBYTE) ppRasUser0); <br>      if (dwResult != NO_ERROR) <br>      { <br>         sprintf(szBuf,"ERROR MprAdminUserGetInfo     %d\n",dwResult); <br>         WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>         sprintf(szBuf,"Parameters in:\n\tlpszServer=%ws\n\tlpszUser=%ws\n\tdwLevel=0,\n\tlpbBuffer)\n", <br>                        szUserAccountServer, UserName); <br>         WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br> <br>         dwResult = MprAdminGetErrorString( dwResult, &amp;lpszString); <br>         if (dwResult == NO_ERROR) <br>         { <br>            sprintf(szBuf, "ERROR  MprAdminUserGetInfo: string from MprAdminGetErrorString:  %ws\n",lpszString); <br>            WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>         } <br>         else <br>            PrintGetStringError(dwResult); <br>      } <br>      else //MprAdminUserGetInfo returned success <br>      { <br>         PrintPriv(szUserAccountServer, UserName); <br>         // <br>         // cycle thru various privilege values <br>         // <br>         if (LoopPriv &gt; 3) <br>         { <br>            LoopPriv = 0; <br>            Dialin = 1; <br>         } <br>         if (LoopPriv &lt; 4) <br>         { <br>            if (LoopPriv == 3) //invalid value - never true <br>               wcscpy(ppRasUser0-&gt;wszPhoneNumber, TEXT("99999999")); <br> <br>            if (LoopPriv == 0) <br>            { <br>               ppRasUser0-&gt;bfPrivilege =  Dialin; <br>               Dialin = Dialin * 2; <br>               LoopPriv++; <br>            } <br>            else <br>            { <br>               ppRasUser0-&gt;bfPrivilege = (RASPRIV_DialinPrivilege | Dialin  ); <br>               Dialin = Dialin * 2 ; <br>               LoopPriv++; <br>            } <br>         } <br>         // API Called:     MprAdminUserSetInfo <br>         // Parameters: <br>         // IN WCHAR * lpwsServerName <br>         // IN WCHAR * lpwsUserName <br>         // IN DWORD dwLevel <br>         // IN LPBYTE lpbBuffer <br>         dwResult = MprAdminUserSetInfo(szUserAccountServer, UserName, 0, (LPBYTE)ppRasUser0); <br>         if (dwResult != NO_ERROR) <br>         { <br>            sprintf(szBuf,"ERROR: MprAdminUserSetInfo     %d\n",dwResult); <br>            WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br> <br>            sprintf(szBuf,"Parameters in:\n\tlpszServer=%ws\n\tlpszUser=%ws\n\tdwLevel=0,\n\tlpbBuffer)\n", <br>                           szUserAccountServer, UserName); <br>            WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>            // dump this out to see what privileges were passed in UserSetInfo call <br>            PrintPriv(szUserAccountServer, UserName); <br> <br>            dwResult = MprAdminGetErrorString( dwResult, &amp;lpszString); <br>            if (dwResult == ERROR_SUCCESS) <br>            { <br>               sprintf(szBuf, "ERROR  MprAdminUserSetInfo: string from MprAdminGetErrorString:  %ws\n",lpszString); <br>               WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>            } <br>            else <br>               PrintGetStringError(dwResult); <br>         } <br>         // API Called:     MprAdminUserSetInfo <br>         // Parameters: <br>         // IN WCHAR * lpwsServerName <br>         // IN WCHAR * lpwsUserName <br>         // IN DWORD dwLevel <br>         // IN LPBYTE lpbBuffer <br>         if (LoopPriv == 0) <br>         { <br>            ppRasUser0-&gt;bfPrivilege = (ppRasUser0-&gt;bfPrivilege | RASPRIV_DialinPrivilege); <br>            dwResult = MprAdminUserSetInfo(szUserAccountServer, UserName,0,(LPBYTE) ppRasUser0); <br>            if (dwResult == ERROR_SUCCESS) <br>            { <br>               PrintPriv(DomainName,UserName); <br>            } <br>            else //MprAdminUserSetInfo failed <br>            { <br>               sprintf(szBuf,"ERROR  MprAdminUserSetInfo     %d\n",dwResult); <br>               WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>               sprintf(szBuf,"Parameters in:\n\tlpszServer=%ws\n\tlpszUser=%ws\n\tdwLevel=0,\n\tlpbBuffer)\n", <br>                              szUserAccountServer, UserName); <br>               WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>               // dump this out to see what privileges were passed in UserSetInfo call <br>               PrintPriv(szUserAccountServer, UserName); <br> <br>               dwResult = MprAdminGetErrorString(dwResult, &amp;lpszString); <br>               if (dwResult == NO_ERROR) <br>               { <br>                  sprintf(szBuf, "ERROR  MprAdminUserSetInfo: error string from MprAdminGetErrorString:  %ws\n",lpszString); <br>                  WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>               } <br>               else <br>                  PrintGetStringError(dwResult); <br>            } <br>         } <br> <br>         //Free up the buffer from previous MprAdminUserGetInfo <br>         //dwResult=MprAdminBufferFree(ppRasUser0); <br> <br>         // API Called:     RasAdmimUserGetInfo <br>         // Parameters: <br>         // IN WCHAR * lpwsServerName <br>         // IN WCHAR * lpwsUserName <br>         // IN DWORD dwLevel <br>         // OUT LPBYTE *lpbBuffer <br>         dwResult = MprAdminUserGetInfo(szUserAccountServer, UserName,0,(LPBYTE) ppRasUser0); <br>         if (dwResult != NO_ERROR) <br>         { <br>            sprintf(szBuf,"ERROR: MprAdminUserGetInfo     %d\n",dwResult); <br>            WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>            sprintf(szBuf,"Parameters in:\n\tlpszServer=%ws\n\tlpszUser=%ws\n\tdwLevel=0,\n\tlpbBuffer)\n", <br>                           szUserAccountServer, UserName); <br>            WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>            dwResult = MprAdminGetErrorString( dwResult, &amp;lpszString); <br>            if (dwResult == ERROR_SUCCESS) <br>            { <br>               sprintf(szBuf, "ERROR  MprAdminUserGetInfo: error string from MprAdminGetErrorString:  %ws\n",lpszString); <br>               WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>            } <br>            else <br>               PrintGetStringError(dwResult); <br>         } <br> <br>      } // end of loop for MprAdminUserGetInfo returning success <br> <br>   } <br>   else //MprAdminGetPDCServer returned an error <br>   { <br>      DbgPrint("ERROR  MprAdminGetPDCServer     %d\n",dwResult); <br>      sprintf(szBuf,"ERROR  MprAdminGetPDCServer     %d\n",dwResult); <br>      WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      sprintf(szBuf,"Parameters in:\n\tlpszDomain=%ws\n\tlpszServer=NULL\n", DomainName); <br>      WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br> <br>      dwResult = MprAdminGetErrorString(dwResult, &amp;lpszString); <br>      if (dwResult == NO_ERROR) <br>      { <br>         sprintf(szBuf, "ERROR  MprAdminGetPDCServer      %ws\n",lpszString); <br>         WriteFile(ErrLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br> <br>}  //end UserPrivilege() <br> <br> <br> <br>// <br>// dump connection0 struct to debug output <br>// <br>VOID Debug_Print_Connection0(RAS_CONNECTION_0 *pRasConnection0) <br>{ <br>WCHAR *Interface_Type[] = <br>   { <br>   TEXT("ROUTER_IF_TYPE_CLIENT"), <br>   TEXT("ROUTER_IF_TYPE_HOME_ROUTER"), <br>   TEXT("ROUTER_IF_TYPE_FULL_ROUTER"), <br>   TEXT("ROUTER_IF_TYPE_DEDICATED"), <br>   TEXT("ROUTER_IF_TYPE_INTERNAL"), <br>   TEXT("ROUTER_IF_TYPE_INTERNAL") <br>   }; <br> <br>   //dumping pRasConnection0 <br>   DbgPrint("pRasConnection0-&gt;hConnection  0x%x\n",pRasConnection0-&gt;hConnection); <br>   DbgPrint("pRasConnection0-&gt;hInterface   0x%x\n",pRasConnection0-&gt;hInterface); <br>   DbgPrint("pRasConnection0-&gt;dwConnectDuration  %d\n",pRasConnection0-&gt;dwConnectDuration); <br>   DbgPrint("pRasConnection0-&gt;dwInterfaceType  %ws\n",Interface_Type[pRasConnection0-&gt;dwInterfaceType]); <br>   DbgPrint("pRasConnection0-&gt;dwConnectionFlags  %d\n",pRasConnection0-&gt;dwConnectionFlags); <br>   DbgPrint("pRasConnection0-&gt;wszInterfaceName  %ws\n",pRasConnection0-&gt;wszInterfaceName); <br>   DbgPrint("pRasConnection0-&gt;wszUserName  %ws\n",pRasConnection0-&gt;wszUserName); <br>   DbgPrint("pRasConnection0-&gt;wszLogonDomain  %ws\n",pRasConnection0-&gt;wszLogonDomain); <br>   DbgPrint("pRasConnection0-&gt;wszRemoteComputer  %ws\n",pRasConnection0-&gt;wszRemoteComputer); <br> <br>} <br> <br> <br>// <br>// dump connection1 struct to debug output <br>// <br>VOID Debug_Print_Connection1(RAS_CONNECTION_1 *pRasConnection1) <br>{ <br>    //dumping pRasConnection1 <br>    DbgPrint( "\n\npRasConnection1-&gt;hConnection  0x%x\n",pRasConnection1-&gt;hConnection); <br>    DbgPrint( "pRasConnection1-&gt;hInterface   0x%x\n",pRasConnection1-&gt;hInterface); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.nbf.dwError %d\n",pRasConnection1-&gt;PppInfo.nbf.dwError); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.nbf.wszWksta %ws\n",pRasConnection1-&gt;PppInfo.nbf.wszWksta); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.ip.dwError %d\n",pRasConnection1-&gt;PppInfo.ip.dwError); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.ip.wszAddress %ws\n",pRasConnection1-&gt;PppInfo.ip.wszAddress); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.ip.wszRemoteAddress %ws\n",pRasConnection1-&gt;PppInfo.ip.wszRemoteAddress); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.ipx.dwError %d\n",pRasConnection1-&gt;PppInfo.ipx.dwError); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.ipx.wszAddress %ws\n",pRasConnection1-&gt;PppInfo.ipx.wszAddress); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.at.dwError  %d\n",pRasConnection1-&gt;PppInfo.at.dwError ); <br>    DbgPrint( "pRasConnection1-&gt;PppInfo.at.wszAddress %ws\n",pRasConnection1-&gt;PppInfo.at.wszAddress); <br> <br>    //connection stats <br>    DbgPrint( "pRasConnection1-&gt;dwBytesXmited=%d\n", pRasConnection1-&gt;dwBytesXmited ); <br>    DbgPrint( "pRasConnection1-&gt;dwBytesRcved=%d\n", pRasConnection1-&gt;dwBytesRcved ); <br>    DbgPrint( "pRasConnection1-&gt;dwFramesXmited=%d\n", pRasConnection1-&gt;dwFramesXmited ); <br>    DbgPrint( "pRasConnection1-&gt;dwFramesRcved=%d\n", pRasConnection1-&gt;dwFramesRcved); <br>    DbgPrint( "pRasConnection1-&gt;dwCrcErr=%d\n", pRasConnection1-&gt;dwCrcErr); <br>    DbgPrint( "pRasConnection1-&gt;dwTimeoutErr=%d\n", pRasConnection1-&gt;dwTimeoutErr); <br>    DbgPrint( "pRasConnection1-&gt;dwAlignmentErr=%d\n", pRasConnection1-&gt;dwAlignmentErr); <br>    DbgPrint( "pRasConnection1-&gt;dwHardwareOverrunErr=%d\n", pRasConnection1-&gt;dwHardwareOverrunErr); <br>    DbgPrint( "pRasConnection1-&gt;dwFramingErr=%d\n", pRasConnection1-&gt;dwFramingErr); <br>    DbgPrint( "pRasConnection1-&gt;dwBufferOverrunErr=%d\n", pRasConnection1-&gt;dwBufferOverrunErr); <br>} <br> <br> <br> <br>// <br>// dump port0 struct to debug output <br>// <br>VOID Debug_Print_RAS_PORT0(RAS_PORT_0 *pRasPort0) <br>{ <br>WCHAR *Line_Condition[] = <br>   { <br>   TEXT("RAS_PORT_NON_OPERATIONAL"), <br>   TEXT("RAS_PORT_DISCONNECTED"), <br>   TEXT("RAS_PORT_CALLING_BACK"), <br>   TEXT("RAS_PORT_LISTENING"), <br>   TEXT("RAS_PORT_AUTHENTICATING"), <br>   TEXT("RAS_PORT_AUTHENTICATED"), <br>   TEXT("RAS_PORT_INITIALIZING") <br>   }; <br> <br>WCHAR *Hdw_Error[] = <br>   { <br>   TEXT("RAS_HARDWARE_OPERATIONAL"), <br>   TEXT("RAS_HARDWARE_FAILURE") <br>   }; <br> <br>   //dumping pRasPort0 <br>   DbgPrint("pRasPort0-&gt;hPort  %d\n",pRasPort0-&gt;hPort); <br>   DbgPrint("pRasPort0-&gt;hConnection   0x%x\n",pRasPort0-&gt;hConnection); <br>   DbgPrint("pRasPort0-&gt;dwPortCondition  %ws\n",Line_Condition[pRasPort0-&gt;dwPortCondition-1]); <br>   DbgPrint("pRasPort0-&gt;dwTotalNumberOfCalls  %d\n",pRasPort0-&gt;dwTotalNumberOfCalls); <br>   DbgPrint("pRasPort0-&gt;dwConnectDuration  %d\n",pRasPort0-&gt;dwConnectDuration); <br>   DbgPrint("pRasPort0-&gt;wszPortName  %ws\n",pRasPort0-&gt;wszPortName); <br>   DbgPrint("pRasPort0-&gt;wszMediaName  %ws\n",pRasPort0-&gt;wszMediaName); <br>   DbgPrint("pRasPort0-&gt;wszDeviceName  %ws\n",pRasPort0-&gt;wszDeviceName); <br>   DbgPrint("pRasPort0-&gt;wszDeviceType  %ws\n",pRasPort0-&gt;wszDeviceType); <br> <br>} <br> <br> <br> <br>// <br>// dump port1 struct to debug output <br>// <br>VOID Debug_Print_RAS_PORT1(RAS_PORT_1 *pRasPort1) <br>{ <br>WCHAR *Line_Condition[] = <br>   { <br>   TEXT("RAS_PORT_NON_OPERATIONAL"), <br>   TEXT("RAS_PORT_DISCONNECTED"), <br>   TEXT("RAS_PORT_CALLING_BACK"), <br>   TEXT("RAS_PORT_LISTENING"), <br>   TEXT("RAS_PORT_AUTHENTICATING"), <br>   TEXT("RAS_PORT_AUTHENTICATED"), <br>   TEXT("RAS_PORT_INITIALIZING") <br>   }; <br> <br>WCHAR *Hdw_Error[] = <br>   { <br>   TEXT("RAS_HARDWARE_OPERATIONAL"), <br>   TEXT("RAS_HARDWARE_FAILURE") <br>   }; <br> <br>   //dumping pRasPort1 <br>   DbgPrint("pRasPort1-&gt;hPort  %d\n",pRasPort1-&gt;hPort); <br>   DbgPrint("pRasPort1-&gt;hConnection   0x%x\n",pRasPort1-&gt;hConnection); <br>   DbgPrint("pRasPort1-&gt;dwHardwareCondition  %ws\n",Hdw_Error[pRasPort1-&gt;dwHardwareCondition]); <br> <br>   //connection stats <br>   DbgPrint( "pRasPort1-&gt;dwLineSpeed=%d\n", pRasPort1-&gt;dwLineSpeed ); <br>   DbgPrint( "pRasPort1-&gt;dwBytesXmited=%d\n", pRasPort1-&gt;dwBytesXmited ); <br>   DbgPrint( "pRasPort1-&gt;dwBytesRcved=%d\n", pRasPort1-&gt;dwBytesRcved ); <br>   DbgPrint( "pRasPort1-&gt;dwFramesXmited=%d\n", pRasPort1-&gt;dwFramesXmited ); <br>   DbgPrint( "pRasPort1-&gt;dwFramesRcved=%d\n", pRasPort1-&gt;dwFramesRcved); <br>   DbgPrint( "pRasPort1-&gt;dwCrcErr=%d\n", pRasPort1-&gt;dwCrcErr); <br>   DbgPrint( "pRasPort1-&gt;dwTimeoutErr=%d\n", pRasPort1-&gt;dwTimeoutErr); <br>   DbgPrint( "pRasPort1-&gt;dwAlignmentErr=%d\n", pRasPort1-&gt;dwAlignmentErr); <br>   DbgPrint( "pRasPort1-&gt;dwHardwareOverrunErr=%d\n", pRasPort1-&gt;dwHardwareOverrunErr); <br>   DbgPrint( "pRasPort1-&gt;dwFramingErr=%d\n", pRasPort1-&gt;dwFramingErr); <br>   DbgPrint( "pRasPort1-&gt;dwBufferOverrunErr=%d\n", pRasPort1-&gt;dwBufferOverrunErr); <br>} <br> <br> <br>// <br>// dump connection0 struct to logfile <br>// <br>VOID File_Print_Connection0(RAS_CONNECTION_0 *pRasConnection0) <br>{ <br>WCHAR *Interface_Type[] = <br>   { <br>   TEXT("ROUTER_IF_TYPE_CLIENT"), <br>   TEXT("ROUTER_IF_TYPE_HOME_ROUTER"), <br>   TEXT("ROUTER_IF_TYPE_FULL_ROUTER"), <br>   TEXT("ROUTER_IF_TYPE_DEDICATED"), <br>   TEXT("ROUTER_IF_TYPE_INTERNAL"), <br>   TEXT("ROUTER_IF_TYPE_INTERNAL") <br>   }; <br> <br>   //dumping pRasConnection0 <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"dumping pRasConnection0\n\n"); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;hConnection  0x%x\n",pRasConnection0-&gt;hConnection); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;hInterface   0x%x\n",pRasConnection0-&gt;hInterface); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;dwConnectDuration  %d\n",pRasConnection0-&gt;dwConnectDuration); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;dwInterfaceType  %ws\n",Interface_Type[pRasConnection0-&gt;dwInterfaceType]); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;dwConnectionFlags  %d\n",pRasConnection0-&gt;dwConnectionFlags); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;wszInterfaceName  %ws\n",pRasConnection0-&gt;wszInterfaceName); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;wszUserName  %ws\n",pRasConnection0-&gt;wszUserName); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;wszLogonDomain  %ws\n",pRasConnection0-&gt;wszLogonDomain); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasConnection0-&gt;wszRemoteComputer  %ws\n",pRasConnection0-&gt;wszRemoteComputer); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br> <br>} <br> <br> <br>// <br>// dump connection1 info to logfile <br>// <br>VOID File_Print_Connection1(RAS_CONNECTION_1 *pRasConnection1) <br>{ <br> <br>   //dumping pRasConnection1 <br>   sprintf(buf,"dumping pRasConnection1\n"); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "\n\npRasConnection1-&gt;hConnection  0x%x\n",pRasConnection1-&gt;hConnection); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;hInterface   0x%x\n",pRasConnection1-&gt;hInterface); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.nbf.dwError %d\n",pRasConnection1-&gt;PppInfo.nbf.dwError); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.nbf.wszWksta %ws\n",pRasConnection1-&gt;PppInfo.nbf.wszWksta); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.ip.dwError %d\n",pRasConnection1-&gt;PppInfo.ip.dwError); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.ip.wszAddress %ws\n",pRasConnection1-&gt;PppInfo.ip.wszAddress); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.ip.wszRemoteAddress %ws\n",pRasConnection1-&gt;PppInfo.ip.wszRemoteAddress); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); </code></pre>
<p>
</p>
<pre><code>sprintf(buf, "pRasConnection1-&gt;PppInfo.ipx.dwError %d\n",pRasConnection1-&gt;PppInfo.ipx.dwError); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.ipx.wszAddress %ws\n",pRasConnection1-&gt;PppInfo.ipx.wszAddress); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.at.dwError  %d\n",pRasConnection1-&gt;PppInfo.at.dwError ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;PppInfo.at.wszAddress %ws\n",pRasConnection1-&gt;PppInfo.at.wszAddress); <br> <br>   //connection stats <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwBytesXmited=%d\n", pRasConnection1-&gt;dwBytesXmited ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwBytesRcved=%d\n", pRasConnection1-&gt;dwBytesRcved ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwFramesXmited=%d\n", pRasConnection1-&gt;dwFramesXmited ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwFramesRcved=%d\n", pRasConnection1-&gt;dwFramesRcved); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwCrcErr=%d\n", pRasConnection1-&gt;dwCrcErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwTimeoutErr=%d\n", pRasConnection1-&gt;dwTimeoutErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwAlignmentErr=%d\n", pRasConnection1-&gt;dwAlignmentErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwHardwareOverrunErr=%d\n", pRasConnection1-&gt;dwHardwareOverrunErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwFramingErr=%d\n", pRasConnection1-&gt;dwFramingErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasConnection1-&gt;dwBufferOverrunErr=%d\n", pRasConnection1-&gt;dwBufferOverrunErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>} <br> <br> <br> <br>// <br>// dump port0 info to logfile <br>// <br>VOID File_Print_RAS_PORT0(RAS_PORT_0 *pRasPort0) <br>{ <br>WCHAR *Line_Condition[] = <br>   { <br>   TEXT("RAS_PORT_NON_OPERATIONAL"), <br>   TEXT("RAS_PORT_DISCONNECTED"), <br>   TEXT("RAS_PORT_CALLING_BACK"), <br>   TEXT("RAS_PORT_LISTENING"), <br>   TEXT("RAS_PORT_AUTHENTICATING"), <br>   TEXT("RAS_PORT_AUTHENTICATED"), <br>   TEXT("RAS_PORT_INITIALIZING") <br>   }; <br> <br>WCHAR *Hdw_Error[] = <br>   { <br>   TEXT("RAS_HARDWARE_OPERATIONAL"), <br>   TEXT("RAS_HARDWARE_FAILURE") <br>   }; <br> <br>   //dumping pRasPort0 to a file <br>   sprintf(buf,"dumping pRasPort0 to file\n"); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;hPort  %d\n",pRasPort0-&gt;hPort); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;hConnection   0x%x\n",pRasPort0-&gt;hConnection); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;dwPortCondition  %ws\n",Line_Condition[pRasPort0-&gt;dwPortCondition-1]); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;dwTotalNumberOfCalls  %d\n",pRasPort0-&gt;dwTotalNumberOfCalls); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;dwConnectDuration  %d\n",pRasPort0-&gt;dwConnectDuration); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;wszPortName  %ws\n",pRasPort0-&gt;wszPortName); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;wszMediaName  %ws\n",pRasPort0-&gt;wszMediaName); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;wszDeviceName  %ws\n",pRasPort0-&gt;wszDeviceName); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort0-&gt;wszDeviceType  %ws\n",pRasPort0-&gt;wszDeviceType); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br> <br>} <br> <br> <br> <br>// <br>// dump port1 info to logfile <br>// <br>VOID File_Print_RAS_PORT1(RAS_PORT_1 *pRasPort1) <br>{ <br>WCHAR *Line_Condition[] = <br>   { <br>   TEXT("RAS_PORT_NON_OPERATIONAL"), <br>   TEXT("RAS_PORT_DISCONNECTED"), <br>   TEXT("RAS_PORT_CALLING_BACK"), <br>   TEXT("RAS_PORT_LISTENING"), <br>   TEXT("RAS_PORT_AUTHENTICATING"), <br>   TEXT("RAS_PORT_AUTHENTICATED"), <br>   TEXT("RAS_PORT_INITIALIZING") <br>   }; <br> <br>WCHAR *Hdw_Error[] = <br>   { <br>   TEXT("RAS_HARDWARE_OPERATIONAL"), <br>   TEXT("RAS_HARDWARE_FAILURE") <br>   }; <br> <br> <br>   //dumping pRasPort1 <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"\n dumping pRasPort1\n"); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort1-&gt;hPort  %d\n",pRasPort1-&gt;hPort); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort1-&gt;hConnection   0x%x\n",pRasPort1-&gt;hConnection); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf,"pRasPort1-&gt;dwHardwareCondition  %ws\n",Hdw_Error[pRasPort1-&gt;dwHardwareCondition]); <br> <br>   //connection stats <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwLineSpeed=%d\n", pRasPort1-&gt;dwLineSpeed ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwBytesXmited=%d\n", pRasPort1-&gt;dwBytesXmited ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwBytesRcved=%d\n", pRasPort1-&gt;dwBytesRcved ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwFramesXmited=%d\n", pRasPort1-&gt;dwFramesXmited ); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwFramesRcved=%d\n", pRasPort1-&gt;dwFramesRcved); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwCrcErr=%d\n", pRasPort1-&gt;dwCrcErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwTimeoutErr=%d\n", pRasPort1-&gt;dwTimeoutErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwAlignmentErr=%d\n", pRasPort1-&gt;dwAlignmentErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwHardwareOverrunErr=%d\n", pRasPort1-&gt;dwHardwareOverrunErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwFramingErr=%d\n", pRasPort1-&gt;dwFramingErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br>   sprintf(buf, "pRasPort1-&gt;dwBufferOverrunErr=%d\n", pRasPort1-&gt;dwBufferOverrunErr); <br>   WriteFile(cLogFile, (LPSTR)buf, strlen(buf), &amp;dwBytesWritten, NULL); <br> <br>} <br> <br> <br>// <br>// Function to clear port statistics. <br>// <br>VOID ProcPortClearStat(HANDLE hPort) <br>{ <br>DWORD dwBytesWritten = 0; <br>CHAR szBuf[120]; <br>WCHAR Buf[512]; <br>WCHAR *lpszString; <br>lpszString = &amp;Buf[0]; <br> <br>   // API Called:     MprAdminPortClearStats <br>   // Parameters: <br>   // IN RAS_SERVER_HANDLE phRasServer <br>   // IN HANDLE  hPort <br>   Status = MprAdminPortClearStats(phRasServer, hPort); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminPortClearStats   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString(Status,&amp;lpszString); <br>      if (dwResult == ERROR_SUCCESS) <br>      { <br>         DbgPrint("ERROR  MprAdminPortClearStats      %ws\n",lpszString); <br>         sprintf(szBuf, "ERROR  MprAdminPortClearStats      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      DbgPrint("\n\nMprAdminPortClearStats Called From ProcPortClearStat, Now dumping structs \n"); <br>      sprintf(szBuf, "\n\nMprAdminPortClearStats Called From ProcPortClearStat, Now dumping structs\n"); <br>      WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      ProcPortGetInfo(hPort); <br>   } <br> <br>} <br> <br> <br> <br>// <br>// Function to clear connection statistics. <br>// <br>VOID ProcConnectionClearStat(HANDLE hConnection) <br>{ <br>DWORD dwBytesWritten = 0; <br>CHAR szBuf[120]; <br>WCHAR Buf[512]; <br>WCHAR *lpszString; <br>lpszString = &amp;Buf[0]; <br> <br>   // API Called:     MprAdminConnectionClearStats <br>   // Parameters: <br>   // IN RAS_SERVER_HANDLE  phRasServer <br>   // IN HANDLE  hConnection <br>   Status = MprAdminConnectionClearStats(phRasServer, hConnection); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminConnectionClearStats   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString(Status, &amp;lpszString); <br>      if (dwResult == ERROR_SUCCESS) <br>      { <br>         DbgPrint("ERROR  MprAdminConnectionClearStats      %ws\n",lpszString); <br>         sprintf(szBuf, "ERROR  MprAdminConnectionClearStats      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      DbgPrint("\n\nMprAdminConnectionClearStats Called From ProcConnectionClearStat, Now dumping structs \n"); <br>      sprintf(szBuf, "\n\nMprAdminConnectionClearStats Called From ProcConnectionClearStat, Now dumping structs\n"); <br>      WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      ProcConnectionGetInfo(hConnection); <br>   } <br>} <br> <br> <br>// <br>// Function to reset port. <br>// <br>VOID ProcPortReset(HANDLE hPort) <br>{ <br>DWORD dwBytesWritten = 0; <br>CHAR szBuf[120]; <br>WCHAR Buf[512]; <br>WCHAR *lpszString; <br>lpszString = &amp;Buf[0]; <br> <br>   // API Called:     MprAdminPortReset <br>   // Parameters: <br>   // IN RAS_SERVER_HANDLE  phRasServer <br>   // IN HANDLE  hPort <br>   Status = MprAdminPortReset(phRasServer, hPort); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminPortReset   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString(Status, &amp;lpszString); <br>      if (dwResult == ERROR_SUCCESS) <br>      { <br>         DbgPrint("ERROR  MprAdminPortReset      %ws\n",lpszString); <br>         sprintf(szBuf, "ERROR  MprAdminPortReset      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      DbgPrint("\n\nMprAdminPortReset Called From ProcPortReset, Now dumping structs \n"); <br>      sprintf(szBuf, "\n\nMprAdminPortReset Called From ProcPortReset, Now dumping structs\n"); <br>      WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      ProcPortGetInfo(hPort); <br>   } <br>} <br> <br> <br>// <br>// Function to disconnect port. <br>// <br>VOID ProcPortDisconnect(HANDLE hPort) <br>{ <br>DWORD dwBytesWritten = 0; <br>CHAR szBuf[120]; <br>WCHAR Buf[512]; <br>WCHAR *lpszString; <br>lpszString = &amp;Buf[0]; <br> <br>   // API Called:     MprAdminPortDisconnect <br>   // Parameters: <br>   // IN RAS_SERVER_HANDLE  phRasServer <br>   // IN HANDLE  hPort <br>   Status = MprAdminPortDisconnect(phRasServer, hPort); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminPortDisconnect   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString( Status, &amp;lpszString); <br>      if (dwResult == ERROR_SUCCESS) <br>      { <br>         DbgPrint("ERROR  MprAdminPortDisconnect      %ws\n",lpszString); <br>         sprintf(szBuf, "ERROR  MprAdminPortDisconnect      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>} <br> <br> <br> <br>// <br>// Function to reset port statistics <br>// <br>DWORD WINAPI RasAdminClearDisc(LPVOID param) <br>{ <br>CHAR option= ' '; <br>WORD i = 0; <br>INT  k = 0; <br> <br>   while (!Quit) <br>   { <br>      // If the user hits q or Q then this will exit gracefully. <br>      // It may take some time to exit though. <br>      printf("Select to Q - Quit\n"); <br>      do <br>      { <br>         option=_getch(); <br>         option =toupper(option); <br>         printf("%c\n",option); <br>      } while (((option) != 'q')&amp;&amp; ((option) != 'Q')); <br> <br>      if (option == 'Q') <br>      { <br>         Quit = TRUE; <br>      } <br>   } <br>   return(0); <br>} <br> <br>VOID ProcConnectionGetInfo(HANDLE hConnection) <br>{ <br>RAS_CONNECTION_0 *pRasConnection0; <br>RAS_CONNECTION_1 *pRasConnection1; <br>LPBYTE lplpbBuffer; <br>DWORD dwBytesWritten = 0; <br>CHAR  szBuf[120]; <br>WCHAR *lpszString; <br>WCHAR Buf[512]; <br>lpszString = &amp;Buf[0]; <br> <br>   // API Called: MprAdminConnectionGetInfo <br>   // Parameters: <br>   // IN  RAS_SERVER_HANDLE phRasServer <br>   // IN DWORD    dwLevel <br>   // IN HANDLE   hConnection <br>   // OUT LPBYTE * lplpbBuffer <br>   Status = MprAdminConnectionGetInfo(phRasServer,0,hConnection,&amp;lplpbBuffer); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminConnectionGetInfo   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString( Status, &amp;lpszString); <br>      if (dwResult == NO_ERROR) <br>      { <br>         sprintf(szBuf,"ERROR  MprAdminConnectionGetInfo      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      pRasConnection0 = (RAS_CONNECTION_0 *) lplpbBuffer; <br>      sprintf(szBuf, "\n\nDumping RpRasConnection0::Called from ProcConnectionGetinfo:-&gt;MprAdminConnectionGetInfo\n"); <br>              WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      File_Print_Connection0(pRasConnection0); <br>      DbgPrint("\n\nDumping RpRasConnection0::Called from ProcConnectionGetinfo:-&gt;MprAdminConnectionGetInfo\n"); <br>      Debug_Print_Connection0(pRasConnection0); <br>      MprAdminBufferFree(pRasConnection0); <br>   } <br> <br>   Status = MprAdminConnectionGetInfo(phRasServer,1,hConnection,&amp;lplpbBuffer); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminConnectionGetInfo   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString( Status, &amp;lpszString); <br>      if (dwResult == NO_ERROR) <br>      { <br>         sprintf(szBuf,"ERROR  MprAdminConnectionGetInfo      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      pRasConnection1 = (RAS_CONNECTION_1 *) lplpbBuffer; <br>      sprintf(szBuf, "\n\nDumping RpRasConnection1::Called from ProcConnectionGetinfo:-&gt;MprAdminConnectionGetInfo\n"); <br>      WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      File_Print_Connection1(pRasConnection1); <br>      DbgPrint("\n\nDumping RpRasConnection1::Called from ProcConnectionGetinfo:-&gt;MprAdminConnectionGetInfo\n"); <br>      Debug_Print_Connection1(pRasConnection1); <br>      MprAdminBufferFree(pRasConnection1); <br>   } <br>} <br> <br> <br>// <br>// get port info <br>// <br>VOID ProcPortGetInfo(HANDLE hPort) <br>{ <br>RAS_PORT_0 *pRasPort0; <br>RAS_PORT_1 *pRasPort1; <br>LPBYTE lplpbBuffer; <br>DWORD dwBytesWritten = 0; <br>CHAR  szBuf[120]; <br>WCHAR *lpszString; <br>WCHAR Buf[512]; <br>lpszString = &amp;Buf[0]; <br> <br>   // API Called: MprAdminPortGetInfo <br>   // Parameters: <br>   // IN  RAS_SERVER_HANDLE phRasServer <br>   // IN DWORD    dwLevel <br>   // IN HANDLE   hPort <br>   // OUT LPBYTE * lplpbBuffer <br>   Status = MprAdminPortGetInfo(phRasServer,0,hPort,&amp;lplpbBuffer); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminPortGetInfo   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString( Status, &amp;lpszString); <br>      if (dwResult == NO_ERROR) <br>      { <br>         sprintf(szBuf,"ERROR  MprAdminPortGetInfo      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      pRasPort0 = (RAS_PORT_0 *) lplpbBuffer; <br>      sprintf(szBuf, "\n\nDumping RpRasPort0::Called from ProcPortGetInfo:-&gt; MprAdminPortGetInfo\n"); <br>      WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      File_Print_RAS_PORT0(pRasPort0); <br>      DbgPrint("\n\nDumping RpRasPort0::Called from ProcPortGetInfo:-&gt;MprAdminPortGetInfo\n"); <br>      Debug_Print_RAS_PORT0(pRasPort0); <br>      MprAdminBufferFree(pRasPort0); <br>   } <br> <br>   Status = MprAdminPortGetInfo(phRasServer,1,hPort,&amp;lplpbBuffer); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminPortGetInfo   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString( Status, &amp;lpszString); <br>      if (dwResult == NO_ERROR) <br>      { <br>         sprintf(szBuf,"ERROR  MprAdminPortGetInfo      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      pRasPort1 = (RAS_PORT_1 *) lplpbBuffer; <br>      sprintf(szBuf, "\n\nDumping pRasPort1::Called from ProcPortGetInfo:-&gt;MprAdminPortGetInfo\n"); <br>      WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      File_Print_RAS_PORT1(pRasPort1); <br>      DbgPrint("\n\nDumping RpRasConnection1::Called from ProcPortGetInfo:-&gt;MprAdminPortGetInfo\n"); <br>      Debug_Print_RAS_PORT1(pRasPort1); <br>      MprAdminBufferFree(pRasPort1); <br>   } <br>} <br> <br> <br>/*************************************************************************/ <br>/***************** Start Main ********************************************/ <br>/*************************************************************************/ <br> <br>void _cdecl main(int argc, char **argv) <br>{ <br>INT LoopPriv = 0; <br>INT Error = 0; <br>CHAR szBuf[120]; <br>DWORD dwBytesWritten = 0; <br>DWORD Dialin = 1; <br>WORD i = 0; <br>DWORD id = 0; <br>WCHAR *lpszString; <br>WCHAR Buf[512]; <br>HANDLE ConnectDiscThread; <br>LPBYTE lplpbBuffer; <br>DWORD lpdwEntriesRead = 0; <br>DWORD lpdwTotalEntries = 0; <br>LPDWORD lpdwResumeHandle=NULL; <br>RAS_CONNECTION_0 *pRasConnection0; <br>LPBYTE plplpbBuffer; <br>DWORD plpdwPrefMaxLen = 0; <br>DWORD plpdwEntriesRead = 0; <br>DWORD plpdwTotalEntries = 0; <br>DWORD plpdwResumeHandle = 0; <br>RAS_PORT_0 *pRasPort0; <br>HANDLE hConnection = 0; <br>lpszString = &amp;Buf[0]; <br> <br> if (argc &gt; 1) <br> { <br>    mbstowcs(RasSrv, argv[1], 32) ; <br> } <br> Init1(); <br> Init2(); <br> Error=IsServiceRunning(RasSrv); <br> if (!Error) <br> { <br>    printf ("Ras Server is not started on the system"); <br>    exit(0); <br> } <br> ConnectDiscThread = CreateThread (NULL, <br>                                  0, <br>                                  &amp;RasAdminClearDisc, <br>                                  (LPVOID) id, <br>                                  0, <br>                                  &amp;id); <br> printf("Quit %d\n",Quit); <br> while (!Quit) <br> { <br> // API Called:     MprAdminConnectionEnum <br> // Parameters: <br> //  IN RAS_SERVER_HANDLE phRasServer <br> //  IN DWORD dwLevel <br> //  OUT LPBYTE * lplpbBuffer    (RAS_CONNECTION_0 array) <br> //  IN DWORD dwPrefMaxLen <br> //  OUT LPDWORD lpdwEntriesRead <br> //  OUT LPDWORD lpdwdTotalEntries <br> //  IN  LPDWORD lpdwResumeHandle  OPTIONAL <br> <br> // Free up lplpbBuffer by calling MprAdminFreeBuffer API <br> <br>   Status = MprAdminConnectionEnum(phRasServer,(DWORD) 0,&amp;lplpbBuffer,(DWORD)-1, <br>                                   &amp;lpdwEntriesRead,&amp;lpdwTotalEntries,lpdwResumeHandle); <br>   if (Status != NO_ERROR) <br>   { <br>      sprintf(szBuf, "ERROR MprAdminConnectionEnum   %d\n",Status); <br>      WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      dwResult = MprAdminGetErrorString( Status, &amp;lpszString); <br>      if (dwResult == NO_ERROR) <br>      { <br>         sprintf(szBuf,"ERROR  MprAdminConnectionEnum      %ws\n",lpszString); <br>         WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>      } <br>      else <br>         PrintGetStringError(dwResult); <br>   } <br>   else <br>   { <br>      if (lpdwEntriesRead == lpdwTotalEntries) <br>      { <br>         pRasConnection0 = (RAS_CONNECTION_0 *) lplpbBuffer; <br>         for (i=0; i &lt; (DWORD)lpdwTotalEntries;i++) <br>         { <br>            sprintf(szBuf, "\n\nDumping RpRasConnection0::Called from MprAdminConnectionEnum\n"); <br>            WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>            File_Print_Connection0(&amp;pRasConnection0[i]); <br>            DbgPrint("\n\nDumping RpRasConnection0::Called from MprAdminConnectionEnum\n"); <br>            Debug_Print_Connection0(&amp;pRasConnection0[i]); <br>            ProcConnectionGetInfo(pRasConnection0[i].hConnection); <br>            // pass hConnection = handle from MprAdminConnectionEnum <br>            hConnection = pRasConnection0[i].hConnection; <br>            //alternatively, could pass hConnection = INVALID_HANDLE_VALUE; <br>            Sleep (500); <br>            // A good idea is to call UserPrivilege outside the loop. It doesn't really <br>            // make sense to go through the privilege change for every iteration. <br>            // However, this code is just intended to demonstrate the usage. <br>            UserPrivilege(pRasConnection0[i].wszLogonDomain,pRasConnection0[i].wszUserName); <br> <br>            ProcConnectionClearStat(pRasConnection0[i].hConnection); <br>            // API Called:     MprAdminPortEnum <br>            // Parameters: <br>            //  IN RAS_SERVER_HANDLE phRasServer <br>            //  IN DWORD pdwLevel <br>            //  HANDLE hConnection <br>            //  OUT LPBYTE * plplpbBuffer    (RAS_PORT_0 array) <br>            //  IN DWORD pdwPrefMaxLen <br>            //  OUT LPDWORD plpdwEntriesRead <br>            //  OUT LPDWORD plpdwdTotalEntries <br>            //  IN  LPDWORD plpdwResumeHandle  OPTIONAL <br> <br>            // Free up lplpbBuffer by calling MprAdminFreeBuffer API <br>            Status = MprAdminPortEnum(phRasServer,(DWORD) 0,hConnection, &amp;plplpbBuffer, <br>                        (DWORD) -1, &amp;plpdwEntriesRead, &amp;plpdwTotalEntries, &amp;plpdwResumeHandle); <br>            if (Status != NO_ERROR) <br>            { <br>               sprintf(szBuf, "ERROR MprAdminPortEnum   %d\n",Status); <br>               WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>               dwResult = MprAdminGetErrorString( Status, &amp;lpszString); <br>               if (dwResult == NO_ERROR) <br>               { <br>                  sprintf(szBuf,"ERROR  MprAdminPortEnum      %ws\n",lpszString); <br>                  WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>               } <br>               else <br>                  PrintGetStringError(dwResult); <br>            } <br>            else <br>            { <br>               if (plpdwEntriesRead == plpdwTotalEntries) <br>               { <br>                  pRasPort0 = (RAS_PORT_0 *) plplpbBuffer; <br>                  for (i=0; i &lt; (DWORD)plpdwTotalEntries;i++) <br>                  { <br>                     sprintf(szBuf, "\n\nDumping pRasPort0::Called from MprAdminPortEnum\n"); <br>                     WriteFile(cLogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br>                     File_Print_RAS_PORT0(&amp;pRasPort0[i]); <br>                     DbgPrint("\n\nDumping RpRasPort0::Called from MprAdminPortEnum\n"); <br>                     Debug_Print_RAS_PORT0(&amp;pRasPort0[i]); <br>                     ProcPortGetInfo(pRasPort0[i].hPort); <br>                     Sleep (500); <br>                     ProcPortClearStat(pRasPort0[i].hPort); <br>                     Sleep (500); <br>                     ProcPortReset(pRasPort0[i].hPort); <br>                     Sleep (500); <br>                     ProcPortDisconnect(pRasPort0[i].hPort); <br>                  } <br>               } <br>               MprAdminBufferFree(pRasPort0); <br>            } <br>         } <br>      } <br>      MprAdminBufferFree(pRasConnection0); <br>   } <br> <br>   CloseHandle(LogFile); <br>   Sleep(sleeptime); <br>   Init1(); <br> <br> } //end of loop: while (!Quit) <br> <br> <br> WaitForSingleObject(ConnectDiscThread,INFINITE); <br> <br> <br> //Calling MprAdminServerDisconnect (type VOID, returns nothing) <br> // Parameters <br> // IN RAS_SERVER_HANDLE * phRasServer <br> MprAdminServerDisconnect(phRasServer); <br> DbgPrint("info: called MprAdminServerDisconnect(hRasServer=0x%x)\n", phRasServer); <br> sprintf(szBuf, "info: called MprAdminServerDisconnect(hRasServer=0x%x)\n", phRasServer); <br> WriteFile(LogFile, (LPSTR)szBuf, strlen(szBuf), &amp;dwBytesWritten, NULL); <br> <br> // <br> // close logfiles <br> // <br> CloseHandle(LogFile); <br> CloseHandle(cLogFile); <br> CloseHandle(ErrLogFile); <br> <br> <br>} // Main End <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
