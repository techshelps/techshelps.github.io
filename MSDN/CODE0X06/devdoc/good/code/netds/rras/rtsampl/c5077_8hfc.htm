<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>THREAD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5088"></a>THREAD.C</h2>
<pre><code>/*++ <br> <br>Copyright 1997 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    sample\ip\thread.c <br> <br>Abstract: <br>    Functions related to the main processing thread <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#include "sampinc.h" <br> <br>VOID <br>Shutdown(); <br> <br>VOID <br>ProcessRouteChange(); <br> <br>VOID <br>ProcessReadNotification(); <br> <br>VOID <br>CleanupProtocol( <br>    BOOL bWinsockLoaded <br>    ); <br> <br>DWORD WINAPI <br>MainThread( <br>    PVOID   pvContext <br>    ) <br>/*++ <br>  Routine Description <br>      This is the main thread created by the protocol.  In general, an <br>      implementor should avoid creating too many threads.  A dedicated <br>      thread should only be created if there is regular work that the <br>      protocol needs to be doing.  If the protocol is more "interrupt driven", <br>      it is much better to use the WorkerFunction routines provided in <br>      rtutils.h <br>      The  <br> <br>  Arguments <br>      pvContext     Unused <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    DWORD   dwRet, dwTimeOut; <br>    ULONG   ulPoll; <br>    HANDLE  hOwnModule; <br>    HANDLE  rgWaitObjects[NUM_WAIT_EVENTS] = {g_hStopProtocolEvent, <br>                                              g_hRtmEvent, <br>                                              g_hSocketEvent}; <br> <br> <br>    // <br>    // The parameter is never used. The following macro <br>    // kills lint/compiler warnings <br>    // <br>     <br>    UNREFERENCED_PARAMETER(pvContext); <br>     <br>    // <br>    // We dont need to EnterProtocolApi() for this thread <br>    // since this is the thread that shuts the DLL down <br>    // <br> <br>    // <br>    // Now we try and load ourself. This is an NT trick to stop the OS loader <br>    // from cleaning out the DLL from under you after you have SetEvent() <br>    // Doing SetEvent() may cause another thread to execute which may then <br>    // unload you. However you still have some epilogue code after the SetEvent() <br>    // that needs to be executed.  Putting a ref count on your DLL is a <br>    // way of stopping this from happening <br>    // <br>     <br>    hOwnModule  = NULL; <br> <br>    hOwnModule  = LoadLibraryEx("IPRTSAMP.DLL", <br>                                NULL, <br>                                0); <br> <br>    if(hOwnModule == NULL) <br>    { <br>        Trace1(ERR, <br>               "MainThread: Unable to load itself. May cause problems at stop. Error %d", <br>               GetLastError()); <br>    } <br> <br>    // <br>    // We initially block on the wait call. When we are told <br>    // to stop, we go into a polling mode <br>    // <br>     <br>    dwTimeOut = INFINITE; <br>    ulPoll    = 0; <br>     <br>    while(TRUE) <br>    { <br>        dwRet = WaitForMultipleObjectsEx(NUM_WAIT_EVENTS, <br>                                        rgWaitObjects, <br>                                        FALSE, <br>                                        dwTimeOut, <br>                                        TRUE); <br> <br>        switch(dwRet) <br>        { <br>            case WAIT_IO_COMPLETION: <br>            { <br>                break; <br>            } <br>             <br>            case WAIT_OBJECT_0: // Stop Protocol Event <br>            { <br>                // <br>                // See if the number of threads in the DLL are down to 0 <br>                // <br> <br>                EnterCriticalSection(&amp;g_csProtocolStateLock); <br> <br>                if(g_dwProtocolRefCount &gt; 0) <br>                { <br>                    // <br>                    // There is someone other than us in the DLL. <br>                    // We go into polling mode <br>                    // <br> <br>                    dwTimeOut = 1000; <br> <br>                    LeaveCriticalSection(&amp;g_csProtocolStateLock); <br>                     <br>                    break; <br>                } <br>                 <br>                Shutdown(); <br> <br>                LeaveCriticalSection(&amp;g_csProtocolStateLock); <br>                 <br>                break; <br>            } <br>             <br>            case (WAIT_OBJECT_0 + 1): // RTM Event <br>            { <br>                ProcessRouteChange(); <br>                 <br>                break; <br>            } <br>             <br>            case (WAIT_OBJECT_0 + 2): // Socket Event <br>            { <br>                ProcessReadNotification(); <br>                 <br>                break; <br>            } <br>             <br>            case WAIT_TIMEOUT: <br>            { <br>                EnterCriticalSection(&amp;g_csProtocolStateLock); <br> <br>                if(g_dwProtocolRefCount &gt; 0) <br>                { <br>                    ulPoll++; <br>                     <br>                    if(ulPoll &gt; 5) <br>                    { <br>                        // <br>                        // 5 seconds have gone by but there are still <br>                        // threads executing in our DLL. This is usually <br>                        // a sign of deadlock, or infinite looping <br>                        // <br>                         <br>                        Trace1(ERR, <br>                               "MainThread: Ref count is not decreasing. Count is %d", <br>                               g_dwProtocolRefCount); <br>                    } <br>                     <br>                    LeaveCriticalSection(&amp;g_csProtocolStateLock); <br>                     <br>                    break; <br>                } <br> <br>                Shutdown(); <br> <br>                LeaveCriticalSection(&amp;g_csProtocolStateLock); <br> <br>                break; <br>            } <br>        } <br>    } <br> <br>    if(hOwnModule) <br>    { <br>        // <br>        // This is an atomic call that frees the library and <br>        // returns from the thread. <br>        // <br>         <br>        FreeLibraryAndExitThread(hOwnModule, <br>                                 NO_ERROR); <br>    } <br>     <br>    return NO_ERROR; <br>} <br> <br>VOID <br>Shutdown() <br>/*++ <br>  Routine Description <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>     <br>    TraceEnter("Shutdown"); <br> <br>    CleanupProtocol(TRUE); <br>                 <br> <br>    g_pmmStopMsg-&gt;rreEvent = ROUTER_STOPPED; <br>     <br>    EnterCriticalSection(&amp;g_csQueueLock); <br> <br>    InsertHeadList(&amp;g_leMsgQueue, <br>                   &amp;g_pmmStopMsg-&gt;leMsgLink); <br> <br>    LeaveCriticalSection(&amp;g_csQueueLock); <br> <br>     <br>    g_dwProtocolState = PROTOCOL_STATE_STOPPED; <br>     <br>    SetEvent(g_hMgrNotifyEvent); <br>     <br>    TraceLeave("ShutDown"); <br>} <br> <br> <br>VOID <br>ProcessRouteChange() <br>{ <br>    DWORD   dwResult, dwFlags; <br>     <br>    RTM_IP_ROUTE ripCurr, ripPrev; <br> <br>    dwResult = RtmDequeueRouteChangeMessage(g_hRtmHandle, <br>                                            &amp;dwFlags, <br>                                            &amp;ripCurr, <br>                                            &amp;ripPrev); <br> <br>    if(dwResult != NO_ERROR) <br>    { <br>        Trace1(ERR, <br>               "ProcessRouteChange: Error %d dequeueing message from RTM", <br>               dwResult); <br> <br>        return; <br>    } <br> <br>    switch(dwFlags) <br>    { <br>        case RTM_ROUTE_ADDED: <br>        { <br>            Trace0(ROUTE, <br>                   "ProcessRouteChange: New route was added"); <br> <br>            PrintRoute(ROUTE, &amp;ripCurr); <br> <br>            break; <br>        } <br> <br>        case RTM_ROUTE_DELETED: <br>        { <br>            Trace0(ROUTE, <br>                   "ProcessRouteChange: Old route was deleted"); <br> <br>            PrintRoute(ROUTE, &amp;ripPrev); <br> <br>            break; <br>        } <br> <br>        case RTM_ROUTE_CHANGED: <br>        { <br>            Trace0(ROUTE, <br>                   "ProcessRouteChange: A best route was changed"); <br> <br>            Trace0(ROUTE, <br>                   "Old route--"); <br> <br>            PrintRoute(ROUTE, &amp;ripPrev); <br> <br>            Trace0(ROUTE, <br>                   "New route--"); <br> <br>            PrintRoute(ROUTE, &amp;ripCurr); <br> <br>            break; <br>        } <br>    } <br>} <br> <br>VOID <br>ProcessReadNotification() <br>{ <br>    PNT_IF          pIf; <br>    PINTRNL_IF      pBind; <br>    PRECEIVE_BUFFER prbBuffer; <br>    DWORD           dwFlags,dwBytesRead; <br>    INT             iRecvAddrLen; <br>    PLIST_ENTRY     pleNode1, pleNode2; <br>     <br>    WSANETWORKEVENTS    wsaNetworkEvents; <br>    struct sockaddr_in  siFrom; <br>     <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    for(pleNode1  = g_leIfListHead.Flink; <br>        pleNode1 != &amp;g_leIfListHead; <br>        pleNode1  = pleNode1-&gt;Flink) <br>    { <br>        pIf = CONTAINING_RECORD(pleNode1, <br>                                NT_IF, <br>                                leNtIfLink); <br> <br> <br>        if(!IsNtEnabledAndBound(pIf)) <br>        { <br>            continue; <br>        } <br>         <br>        for(pleNode2  = pIf-&gt;leInternalIfHead.Flink; <br>            pleNode2 != &amp;pIf-&gt;leInternalIfHead; <br>            pleNode2  = pleNode2-&gt;Flink) <br>        { <br>            pBind = CONTAINING_RECORD(pleNode2, INTRNL_IF, leInternalIfLink); <br> <br>            if(pBind-&gt;sSocket == INVALID_SOCKET) <br>            { <br>                ASSERT(pBind-&gt;dwState != BINDING_UP); <br> <br>                continue; <br>            } <br>        } <br> <br>         <br>        if(WSAEnumNetworkEvents(pBind-&gt;sSocket, <br>                                (WSAEVENT)NULL, <br>                                &amp;wsaNetworkEvents) == SOCKET_ERROR) <br>        { <br>            Trace1(ERR, <br>                   "ProcessRead: WSAEnumNetworkEvents() returned %d", <br>                   WSAGetLastError()); <br>                 <br>            continue; <br>        } <br>             <br>        if(!(wsaNetworkEvents.lNetworkEvents &amp; FD_READ)) <br>        { <br>            // <br>            // Read bit isnot set and we arent interested in  <br>            // anything else <br>            // <br>             <br>            continue; <br>        } <br>         <br>        if(wsaNetworkEvents.iErrorCode[FD_READ_BIT] != NO_ERROR) <br>        { <br>            Trace2(ERR, <br>                   "ProcessRead: Error %d associated with socket %d.%d.%d.%d for FD_READ", <br>                   wsaNetworkEvents.iErrorCode[FD_READ_BIT], <br>                   PRINT_ADDRESS(pBind-&gt;dwAddress)); <br>             <br>            continue; <br>        } <br>         <br>         <br>        // <br>        // Create a buffer to receive data <br>        // <br> <br>        prbBuffer = HeapAlloc(g_hPrivateHeap, <br>                              0, <br>                              sizeof(RECEIVE_BUFFER)); <br> <br>         <br>        if(prbBuffer == NULL) <br>        {    <br>            Trace1(ERR, <br>                   "ProcessRead: Error %d allocating memory for read buffer", <br>                   GetLastError()); <br>             <br>            continue; <br>        } <br> <br>        prbBuffer-&gt;wbBuffer.buf = prbBuffer-&gt;rgbyData; <br>         <br>        iRecvAddrLen = sizeof(struct sockaddr_in); <br>         <br>        if(WSARecvFrom(pBind-&gt;sSocket, <br>                       &amp;(prbBuffer-&gt;wbBuffer), <br>                       1, <br>                       &amp;dwBytesRead, <br>                       &amp;dwFlags, <br>                       (struct sockaddr *)&amp;siFrom, <br>                       &amp;iRecvAddrLen, <br>                       NULL, <br>                       NULL) != NO_ERROR) <br>        { <br>            Trace1(ERR, <br>                   "ProcessRead. Error %d reading data", <br>                   WSAGetLastError()); <br>             <br>            HeapFree(g_hPrivateHeap, <br>                     0, <br>                     prbBuffer); <br>             <br>             <br>            continue; <br>        } <br> <br>        //ValidateAndQueuePacket(); <br>         <br>         <br>    } <br>         <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
