<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5084"></a>MIB.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    sample\ip\mib.c <br> <br>Abstract: <br>    MIB Functions exported by the Sample Routing Protocol DLL and related code <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#include "sampinc.h" <br> <br> <br> <br>DWORD <br>LocateInterface( <br>    DWORD               dwQueryType, <br>    PPROTO_MIB_QUERY    pQuery, <br>    ULONG               ulNumIndices, <br>    PPROTO_MIB_RESPONSE pResponse, <br>    PDWORD              pdwOutputSize <br>    ); <br> <br> <br>// <br>// As mentioned in saminfo.h we do not support Creates, Sets or Deletes <br>// <br> <br> <br>DWORD <br>APIENTRY <br>MibCreate( <br>    IN DWORD dwInputSize, <br>    IN PVOID pInputData <br>    ) <br>/*++ <br>  Routine Description <br>     <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    // <br>    // Not supported <br>    // <br>     <br>    return NO_ERROR; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>MibDelete( <br>    IN DWORD dwInputSize, <br>    IN PVOID pInputData <br>    ) <br>/*++ <br>  Routine Description <br> <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    // <br>    // Not supported <br>    // <br>     <br>    return NO_ERROR; <br>} <br> <br>DWORD <br>APIENTRY <br>MibSet( <br>    IN DWORD dwInputSize, <br>    IN PVOID pInputData <br>    ) <br>/*++ <br>  Routine Description <br> <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    // <br>    // Not supported <br>    // <br>     <br>    return NO_ERROR; <br>} <br> <br>DWORD <br>APIENTRY <br>MibGet( <br>    IN     DWORD  dwInputSize, <br>    IN     PVOID  pInputData, <br>    IN OUT PDWORD pdwOutputSize, <br>       OUT PVOID  pOutputData <br>    ) <br>/*++ <br>  Routine Description <br>      Called by an admin (SNMP) utility.  It actually passes through the <br>      IP Router Manager, but all that does is demux the call to the <br>      desired routing protocol <br>      We verify the parameters and return the information if we can <br>       <br>  Arguments <br> <br> <br>  Return Value <br>      ERROR_INSUFFICIENT_BUFFER <br>      ERROR_INVALID_PARAMETER <br>      ERROR_NO_DATA <br>      ERROR_NO_MORE_ITEMS <br>      ERROR_INVALID_INDEX <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PPROTO_MIB_QUERY    pQuery; <br>    PPROTO_MIB_RESPONSE pResponse; <br>    ULONG               ulNumIndices; <br>    DWORD               dwResult; <br>     <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("MibGet"); <br> <br>    if(dwInputSize &lt; sizeof(DWORD)) <br>    { <br>        // <br>        // Need atleas the OID to do the get <br>        // <br> <br>        TraceLeave("MibGet"); <br> <br>        ExitProtocolApi(); <br>         <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    // <br>    // The input to the function is the query <br>    // <br>     <br>    pQuery      = (PPROTO_MIB_QUERY)pInputData; <br>    pResponse   = (PPROTO_MIB_RESPONSE)pOutputData; <br>     <br>    // <br>    // It would be really bad if someone messed the sizes up <br>    // <br>     <br>    ASSERT(dwInputSize%sizeof(DWORD) == 0); <br>     <br>    ulNumIndices = NUM_INDICES(dwInputSize); <br> <br>    dwResult = NO_ERROR; <br>     <br>    switch(pQuery-&gt;dwOid) <br>    { <br>        case PROTO_MIB_GLOBAL_ID: <br>        { <br>            // <br>            // The output size needed is the PROTO_MIB_RESPONSE + just enough for <br>            // the structure we need. We dont need space for the whole union <br>            // <br>             <br>            if(*pdwOutputSize &lt; FIELD_OFFSET(PROTO_MIB_RESPONSE, mgGlobal) + sizeof(PROTO_MIB_GLOBAL)) <br>            { <br>                *pdwOutputSize = FIELD_OFFSET(PROTO_MIB_RESPONSE, mgGlobal) + sizeof(PROTO_MIB_GLOBAL); <br>                 <br>                dwResult = ERROR_INSUFFICIENT_BUFFER; <br> <br>                break; <br>            } <br> <br>            *pdwOutputSize = FIELD_OFFSET(PROTO_MIB_RESPONSE, mgGlobal) + sizeof(PROTO_MIB_GLOBAL); <br>             <br>            pResponse-&gt;dwOid = PROTO_MIB_GLOBAL_ID; <br> <br>            EnterCriticalSection(&amp;g_csGlobalInfoLock); <br>             <br>            pResponse-&gt;mgGlobal.dwLogLevel = g_dwLogLevel; <br> <br>            LeaveCriticalSection(&amp;g_csGlobalInfoLock); <br>             <br>            break; <br>        } <br>        case PROTO_MIB_INTF_ID: <br>        { <br>            EnterCriticalSection(&amp;g_csIfListLock); <br> <br>            dwResult = LocateInterface(QUERY_TYPE_GET, <br>                                       pQuery, <br>                                       ulNumIndices, <br>                                       pResponse, <br>                                       pdwOutputSize); <br>             <br> <br>            LeaveCriticalSection(&amp;g_csIfListLock); <br>             <br>            break; <br>        } <br>        default: <br>        { <br>            dwResult = ERROR_INVALID_PARAMETER; <br> <br>            break; <br>        } <br>    } <br> <br>    TraceLeave("MibGet"); <br> <br>    ExitProtocolApi(); <br>         <br>    return dwResult; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>MibGetFirst( <br>    IN     DWORD  dwInputSize, <br>    IN     PVOID  pInputData, <br>    IN OUT PDWORD pdwOutputSize, <br>       OUT PVOID  pOutputData <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PPROTO_MIB_QUERY    pQuery; <br>    PPROTO_MIB_RESPONSE pResponse; <br>    ULONG               ulNumIndices; <br>    DWORD               dwResult; <br>     <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("MibGet"); <br> <br>    if(dwInputSize &lt; sizeof(DWORD)) <br>    { <br>        // <br>        // Need atleas the OID to do the get <br>        // <br> <br>        TraceLeave("MibGet"); <br> <br>        ExitProtocolApi(); <br>         <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    // <br>    // The input to the function is the query <br>    // <br>     <br>    pQuery      = (PPROTO_MIB_QUERY)pInputData; <br>    pResponse   = (PPROTO_MIB_RESPONSE)pOutputData; <br>     <br>    // <br>    // It would be really bad if someone messed the sizes up <br>    // <br>     <br>    ASSERT(dwInputSize%sizeof(DWORD) == 0); <br>     <br>    ulNumIndices = NUM_INDICES(dwInputSize); <br> <br>    dwResult = NO_ERROR; <br>     <br>    switch(pQuery-&gt;dwOid) <br>    { <br>        case PROTO_MIB_GLOBAL_ID: <br>        { <br>            // <br>            // Only support GET_FIRST for tables <br>            // <br> <br>            dwResult = ERROR_INVALID_PARAMETER; <br>             <br>            break; <br>        } <br>        case PROTO_MIB_INTF_ID: <br>        { <br>            EnterCriticalSection(&amp;g_csIfListLock); <br> <br>            dwResult = LocateInterface(QUERY_TYPE_GET_FIRST, <br>                                       pQuery, <br>                                       ulNumIndices, <br>                                       pResponse, <br>                                       pdwOutputSize); <br>             <br> <br>            LeaveCriticalSection(&amp;g_csIfListLock); <br>             <br>            break; <br>        } <br>    } <br> <br>    TraceLeave("MibGet"); <br> <br>    ExitProtocolApi(); <br>         <br>    return dwResult; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>MibGetNext( <br>    IN     DWORD  dwInputSize, <br>    IN     PVOID  pInputData, <br>    IN OUT PDWORD pdwOutputSize, <br>       OUT PVOID  pOutputData <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PPROTO_MIB_QUERY    pQuery; <br>    PPROTO_MIB_RESPONSE pResponse; <br>    ULONG               ulNumIndices; <br>    DWORD               dwResult; <br>     <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("MibGet"); <br> <br>    if(dwInputSize &lt; sizeof(DWORD)) <br>    { <br>        // <br>        // Need atleas the OID to do the get <br>        // <br> <br>        TraceLeave("MibGet"); <br> <br>        ExitProtocolApi(); <br>         <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    // <br>    // The input to the function is the query <br>    // <br>     <br>    pQuery      = (PPROTO_MIB_QUERY)pInputData; <br>    pResponse   = (PPROTO_MIB_RESPONSE)pOutputData; <br>     <br>    // <br>    // It would be really bad if someone messed the sizes up <br>    // <br>     <br>    ASSERT(dwInputSize%sizeof(DWORD) == 0); <br>     <br>    ulNumIndices = NUM_INDICES(dwInputSize); <br> <br>    dwResult = NO_ERROR; <br>     <br>    switch(pQuery-&gt;dwOid) <br>    { <br>        case PROTO_MIB_GLOBAL_ID: <br>        { <br>            // <br>            // Only support GET_NEXT for tables <br>            // <br> <br>            dwResult = ERROR_INVALID_PARAMETER; <br>             <br>            break; <br>        } <br>        case PROTO_MIB_INTF_ID: <br>        { <br>            EnterCriticalSection(&amp;g_csIfListLock); <br> <br>            dwResult = LocateInterface(QUERY_TYPE_GET_FIRST, <br>                                       pQuery, <br>                                       ulNumIndices, <br>                                       pResponse, <br>                                       pdwOutputSize); <br>             <br> <br>            LeaveCriticalSection(&amp;g_csIfListLock); <br>             <br>            break; <br>        } <br>    } <br> <br>    TraceLeave("MibGet"); <br> <br>    ExitProtocolApi(); <br>         <br>    return dwResult; <br>} <br> <br>DWORD <br>LocateInterface( <br>    DWORD               dwQueryType, <br>    PPROTO_MIB_QUERY    pQuery, <br>    ULONG               ulNumIndices, <br>    PPROTO_MIB_RESPONSE pResponse, <br>    PDWORD              pdwOutputSize <br>    ) <br>/*++ <br>  Routine Description <br>      This locates the correct interface for the MIB query <br> <br>  Locks <br>      The IF List lock should be held <br> <br>  Arguments <br>      dwQueryType <br>      pQuery <br>      ulNumIndices <br>      pResponse <br>      pdwOutputSize <br> <br>  Return Value <br>      ERROR_NO_DATA             If there are no interfaces <br>      ERROR_INVALID_PARAMETER   If the index is bad <br>      ERROR_INVALID_INDEX       If the index does not exist <br>      ERROR_NO_MORE_ITEMS       If there are no more interfaces. Unlike SNMP <br>                                we dont walk to the next variable. This keeps <br>                                our code easy, and doesnt take away any functionality <br>                                since the NT SNMP agent will try the next variable <br>                                automatically on getting this error <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF          pIf, pRetIf; <br>    PINTRNL_IF      pBind; <br>    BOOL            bModified,bNext; <br>    PLIST_ENTRY     pleNode; <br>    DWORD           dwResult,dwIndex,i; <br>    PPROTO_MIB_INTF pMibIf; <br>     <br>    TraceEnter("LocateInterface"); <br>     <br>    if(IsListEmpty(&amp;g_leIfListHead)) <br>    { <br>        TraceLeave("LocateInterface"); <br> <br>        return ERROR_NO_DATA; <br>    } <br> <br>     <br>    if((ulNumIndices &lt; 1) &amp;&amp; (dwQueryType == QUERY_TYPE_GET)) <br>    { <br>        // <br>        // For a get we need the index <br>        // <br> <br>        TraceLeave("LocateInterface"); <br>         <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    if(dwQueryType == QUERY_TYPE_GET_FIRST) <br>    { <br>        // <br>        // Since the list is ordered <br>        // <br> <br>        pIf = CONTAINING_RECORD(g_leIfListHead.Flink, NT_IF, leNtIfLink); <br>         <br>        if(*pdwOutputSize &lt; FIELD_OFFSET(PROTO_MIB_RESPONSE,miIntf) + <br>                             SIZEOF_MIB_INTF_INFO(pIf-&gt;ulNumBindings)) <br>        { <br>             <br>            *pdwOutputSize = FIELD_OFFSET(PROTO_MIB_RESPONSE,miIntf) +  <br>                SIZEOF_MIB_INTF_INFO(pIf-&gt;ulNumBindings); <br> <br>            TraceLeave("LocateInterface"); <br>         <br>            return ERROR_INSUFFICIENT_BUFFER; <br>        } <br>    } <br> <br>    // <br>    // Now a little magic to figure out which interface to return. <br>    // We initialize the index to 0. If we have not gotten an index we <br>    // set th bModified to TRUE, meaning the index has been initialized <br>    // and we have not actually got a 0. <br>    // <br>     <br>    if(ulNumIndices &gt; 0) <br>    { <br>        dwIndex     = pQuery-&gt;rgdwIndex[0]; <br>        bModified   = FALSE; <br>    } <br>    else <br>    { <br>        dwIndex     = 0; <br>        bModified   = TRUE; <br>    } <br> <br>    // <br>    // Now we will take the next interface if the query type is GET_NEXT <br>    // and the index was not modified. Otherwise we will pick the interface <br>    // == dwIndex <br>    // <br> <br>    bNext = ((dwQueryType == QUERY_TYPE_GET_NEXT) &amp;&amp; (bModified == FALSE)); <br> <br>    pRetIf   = NULL; <br>    dwResult = ERROR_NO_MORE_ITEMS; <br>     <br>    for(pleNode  = g_leIfListHead.Flink; <br>        pleNode != &amp;g_leIfListHead; <br>        pleNode  = pleNode-&gt;Flink) <br>    { <br>        pIf = CONTAINING_RECORD(pleNode, <br>                                NT_IF, <br>                                leNtIfLink); <br> <br>        if((dwIndex == pIf-&gt;dwNtIndex) &amp;&amp; !bNext) <br>        { <br>            // <br>            // Found an if with matchin index and we were not <br>            // meant to get the "next" one <br>            // <br> <br>            pRetIf = pIf; <br> <br>            break; <br>        } <br> <br>        if(dwIndex &lt; pIf-&gt;dwNtIndex) <br>        { <br>            if(dwQueryType == QUERY_TYPE_GET_NEXT) <br>            { <br>                // <br>                // Found the first one greater than the given <br>                // and the query type is GET_NEXT <br>                // <br> <br>                pRetIf = pIf; <br>                 <br>                break; <br>            } <br>            else <br>            { <br>                // <br>                // We were meant to get an exact match but <br>                // since the list is ordered, we wont find it now <br>                // <br> <br>                dwResult = ERROR_INVALID_INDEX; <br>            } <br>        } <br>    }    <br> <br>    if(pRetIf != NULL) <br>    { <br>        // <br>        // So we did find an interface <br>        // <br> <br>        if(*pdwOutputSize &lt; FIELD_OFFSET(PROTO_MIB_RESPONSE,miIntf) + <br>                             SIZEOF_MIB_INTF_INFO(pRetIf-&gt;ulNumBindings)) <br>        { <br>             <br>            *pdwOutputSize = FIELD_OFFSET(PROTO_MIB_RESPONSE,miIntf) +  <br>                SIZEOF_MIB_INTF_INFO(pRetIf-&gt;ulNumBindings); <br> <br>            dwResult = ERROR_INSUFFICIENT_BUFFER; <br>        } <br>        else <br>        { <br>            // <br>            // So we found the interface AND have the space <br>            // <br> <br>            *pdwOutputSize = FIELD_OFFSET(PROTO_MIB_RESPONSE,miIntf) +  <br>                SIZEOF_MIB_INTF_INFO(pRetIf-&gt;ulNumBindings); <br> <br>            pResponse-&gt;dwOid = PROTO_MIB_INTF_ID; <br> <br>            pMibIf = (PPROTO_MIB_INTF)(&amp;(pResponse-&gt;miIntf)); <br>             <br>            pMibIf-&gt;dwIfIndex     = pRetIf-&gt;dwNtIndex; <br>            pMibIf-&gt;ulNumAddress  = pRetIf-&gt;ulNumBindings; <br>             <br>            for(pleNode  = pRetIf-&gt;leInternalIfHead.Flink, i = 0; <br>                pleNode != &amp;pIf-&gt;leInternalIfHead; <br>                pleNode  = pleNode-&gt;Flink, i++) <br>            { <br>                pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br> <br>                pMibIf-&gt;rgmbBindInfo[i].dwAddress = pBind-&gt;dwAddress; <br>                pMibIf-&gt;rgmbBindInfo[i].dwMask    = pBind-&gt;dwMask; <br>                pMibIf-&gt;rgmbBindInfo[i].bEnabled  = pBind-&gt;bEnabled; <br>            } <br> <br>            ASSERT(i == pRetIf-&gt;ulNumBindings); <br> <br>            dwResult = NO_ERROR; <br>        } <br>    } <br>     <br>    TraceLeave("LocateInterface"); <br> <br>    return dwResult; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
