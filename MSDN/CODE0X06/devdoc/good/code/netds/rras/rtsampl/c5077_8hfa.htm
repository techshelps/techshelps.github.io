<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMINFO.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5086"></a>SAMINFO.H</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    sample\saminfo.h <br> <br>Abstract: <br>    Public defines and structures exposed by the Sample Routing Protocol DLL <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#ifndef __SAMPLE_INFO_H__ <br>#define __SAMPLE_INFO_H__ <br> <br>#define ANY_SIZE    1 <br> <br>#define SAMPLE_PROTOCOL_NAME        "Sample IP Routing Protocol" <br> <br>// <br>// The IP Protocol number for this protocol. This is assuming that this  <br>// protocol runs over Raw IP <br>// <br> <br>#define SAMPLE_PROTOCOL_ROUTE_ID    100 <br> <br>// <br>// Assuming this is an IETF protocol with protocol ID 200 <br>// <br> <br>#define SAMPLE_PROTOCOL_IP_ID   \ <br>    PROTOCOL_ID(PROTO_TYPE_UNICAST, 0, 0, 200) <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// It is highly recommended that implementors provide their own versioning  // <br>// scheme.  This sample uses information structures whose first DWORD is    // <br>// the version number.  This allows extensibility in the future             // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>#define SAMPLE_PROTOCOL_VERSION     0x00000001 <br> <br>#define SAMPLE_PROTOCOL_MULTICAST_GROUP1    ((DWORD)0x640000E0) // 224.0.0.100 <br>#define SAMPLE_PROTOCOL_MULTICAST_GROUP2    ((DWORD)0x650000E0) // 224.0.0.101 <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// The Global Info                                                          // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>#define PROTO_LOGGING_NONE  ((DWORD) 0) <br>#define PROTO_LOGGING_ERROR ((DWORD) 1) <br>#define PROTO_LOGGING_WARN  ((DWORD) 2) <br>#define PROTO_LOGGING_INFO  ((DWORD) 3) <br> <br>typedef struct _SAMPLE_PROTOCOL_GLOBAL_INFO <br>{ <br>    DWORD   dwVersion; <br>    DWORD   dwLogLevel; <br>}SAMPLE_PROTOCOL_GLOBAL_INFO, *PSAMPLE_PROTOCOL_GLOBAL_INFO; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// An interface an have mutliple addresses. The Sample Routing Protocol     // <br>// allows the admin. to configure parameters for each address.              // <br>// Each Address (or rather &lt;address,mask&gt;) is called a BINDING - for        // <br>// reasons that will be obvious in the code.  When there are multiple       // <br>// bindings on an interface, then the IP Addresses are known before         // <br>// hand and do not change while the router is running.  If there is         // <br>// only one address, it may or may not be known before the router           // <br>// starts, hence is assumed to be 0.0.0.0. The actual address only          // <br>// becomes available when the IP Router Manager calls the protocol's        // <br>// BindInterface() function.  Also such address MAY be dynamic - we         // <br>// say MAY because if the interface has a single static IP Address,         // <br>// it will not change while the router is running. On the other hand,       // <br>// if the interface has a DHCP address (which can only be a SINGLE          // <br>// address) then an ipconfig /release /renew could change the address       // <br>// while the router is running. Since by looking at a single IP address     // <br>// we can not say whether it is dynamic or not, we say that it MAY          // <br>// change.                                                                  // <br>// This fact (that address's change) has a bearing on SNMP MIB indices.     // <br>// If the interface has a single IP address, your protocol should be        // <br>// able to handle the information being indexed via the actual address      // <br>// or via 0.0.0.0.  This means that the ADDRESS BY ITSELF CAN NOT BE        // <br>// AN INDEX.  That is, the interface index MUST be one of the indices       // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// The only information per binding is whether it is enabled or not         // <br>// Hey, this is a SAMPLE, what did you expect - OSPF?                       // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br>  <br>typedef struct _BINDING_INFO <br>{ <br>    DWORD   dwAddress; <br>    DWORD   dwMask;  <br>    BOOL    bEnabled; <br>}BINDING_INFO, *PBINDING_INFO; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// So the per interface information consists of the information             // <br>// that applies across bindings and information for each binding            // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>typedef struct _SAMPLE_PROTOCOL_INTERFACE_INFO <br>{ <br>    DWORD           dwVersion; <br>    ULONG           ulNumBindings; <br>    BINDING_INFO    rgbiInfo[ANY_SIZE]; <br>}SAMPLE_PROTOCOL_INTERFACE_INFO, *PSAMPLE_PROTOCOL_INTERFACE_INFO; <br> <br>#define SIZEOF_PROTO_IF_INFO(X)                                     \ <br>    (FIELD_OFFSET(SAMPLE_PROTOCOL_INTERFACE_INFO, rgbiInfo[0])  +   \ <br>     ((X) * sizeof(BINDING_INFO))) <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// MIB related information                                                  // <br>//                                                                          // <br>// The Sample Routing Protocol only supports queries (Get/GetFirst/GetNext) // <br>// via the MIB calls. No Sets/Deletes/Creates are supported.  The           // <br>// SetInterface/GlobalInfo() calls should be used for that.  The reason     // <br>// is to avoid exposing two different interfaces for sets since keeping     // <br>// those in synch is generally difficult. This is a VERY GOOD guideline to  // <br>// follow.  EITHER DONT ALLOW ANY SETS THROUGH MIB CALLS OR ONLY ALLOW      // <br>// THOSE VARIABLES TO BE SET THAT ARE NOT SET VIA INTERFACE/GLOBAL INFO     // <br>// CALLS.  A case in point being the TTL field exposed via MIB-II. The      // <br>// IP Router Manager allows this field to be set since it is not exposed    // <br>// via the other calls.  IN GENERAL USE THE MIB CALLS FOR STATISTICS.       // <br>// This will make coding the admin DLL for the protocol a lot easier.       // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>#define PROTO_MIB_GLOBAL_ID     0 <br>#define PROTO_MIB_INTF_ID       PROTO_MIB_GLOBAL_ID + 1 <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// The following structure is used to query the MIB. The Oid field is       // <br>// one of the IDs #defined above.  The index is stored in a variable        // <br>// sized array.  All the indices are DWORDs for this protocol.  This is     // <br>// generally a good thing.  It wouldn't be the brightest thing to have      // <br>// a string as an index.                                                    // <br>// The number of indices are calculated from the size of the query          // <br>// structure that is passed in to the MibXXX calls.                         // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>typedef struct _PROTO_MIB_QUERY <br>{ <br>    DWORD   dwOid; <br>    DWORD   rgdwIndex[ANY_SIZE]; <br>}PROTO_MIB_QUERY, *PPROTO_MIB_QUERY; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// Macro to figure out the number of indices given the query size           // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>#define NUM_INDICES(X)  ((X)/sizeof(DWORD) - 1) <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// The following structures are the information returned by the protocol in // <br>// response to a MIB query.  Currently they are the same as the             // <br>// Interface/Global structures. However if this were a real protocol, the   // <br>// statistics would go in here and would not be present in the other        // <br>// structures.                                                              // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// The Global info is a scalar and has no index.  Unlike SNMP we dont       // <br>// expect a scalar to be indexed by 0                                       // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>typedef struct _PROTO_MIB_GLOBAL <br>{ <br>    DWORD   dwLogLevel; <br>}PROTO_MIB_GLOBAL, *PPROTO_MIB_GLOBAL; <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//                                                                          // <br>// The Interface info is indexed by the ifIndex                             // <br>//                                                                          // <br>////////////////////////////////////////////////////////////////////////////// <br> <br>typedef struct _MIB_BIND <br>{ <br>    DWORD   dwAddress; <br>    DWORD   dwMask; <br>    BOOL    bEnabled; <br>}MIB_BIND, *PMIB_BIND; <br> <br>typedef struct _PROTO_MIB_INTF <br>{ <br>    DWORD       dwIfIndex; <br>    ULONG       ulNumAddress; <br>    MIB_BIND    rgmbBindInfo[ANY_SIZE]; <br>}PROTO_MIB_INTF, *PPROTO_MIB_INTF; <br> <br>#define SIZEOF_MIB_INTF_INFO(X)     \ <br>    (FIELD_OFFSET(PROTO_MIB_INTF, rgmbBindInfo[0])  + \ <br>     ((X) * sizeof(MIB_BIND))) <br> <br> <br>typedef struct _PROTO_MIB_RESPONSE <br>{ <br>    DWORD   dwOid; <br>    union <br>    { <br>        PROTO_MIB_GLOBAL    mgGlobal; <br>        PROTO_MIB_INTF      miIntf; <br>    }; <br>}PROTO_MIB_RESPONSE, *PPROTO_MIB_RESPONSE; <br> <br>#endif // __SAMPLE_INFO_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
