<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GLOBAL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5080"></a>GLOBAL.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    sample\ip\global.c <br> <br>Abstract: <br>    Start/Stop and Global Info related functions exported by the <br>    Sample Routing Protocol DLL. <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#include "sampinc.h" <br> <br>BOOL <br>DllStartup(); <br>BOOL <br>DllCleanup(); <br>VOID <br>InitializeProtocolState(); <br>VOID <br>DeleteProtocolState(); <br>BOOL <br>ValidateGlobalInfo( <br>    PSAMPLE_PROTOCOL_GLOBAL_INFO pInfo <br>    ); <br>DWORD WINAPI <br>MainThread( <br>    PVOID   pvContext <br>    ); <br> <br>PNT_IF <br>GetIfBlockGivenIndex( <br>    DWORD   dwIndex <br>    ); <br> <br>VOID <br>APIENTRY <br>UpdateRoutes( <br>    PVOID   pvContext <br>    ); <br>VOID <br>InitializeCriticalSections(); <br>VOID <br>DeleteCriticalSections(); <br>DWORD <br>CreateEvents(); <br>VOID <br>DestroyEvents(); <br>DWORD <br>CreateHeaps(); <br>DWORD <br>DestroyHeaps(); <br>VOID <br>CleanupProtocol( <br>    BOOL bWinsockLoaded <br>    ); <br> <br> <br> <br>DWORD  g_dwLogLevel; <br>DWORD  g_dwNumIf; <br>DWORD  g_dwTrace; <br>HANDLE g_hLogHandle; <br>HANDLE g_hPrivateHeap; <br>HANDLE g_hRtmHandle; <br>HANDLE g_hRtmEvent; <br>HANDLE g_hMgrNotifyEvent; <br>HANDLE g_hStopProtocolEvent; <br>HANDLE g_hSocketEvent; <br>DWORD  g_dwProtocolState; <br>DWORD  g_dwProtocolRefCount; <br>PCHAR  g_ppszStateStrings[NUM_STATES]; <br> <br>LIST_ENTRY  g_leIfListHead; <br>LIST_ENTRY  g_leMsgQueue; <br>PMGR_MSG    g_pmmStopMsg; <br> <br>PSUPPORT_FUNCTIONS  g_psfnSupportFunctions; <br>CRITICAL_SECTION    g_csIfListLock; <br>CRITICAL_SECTION    g_csProtocolStateLock; <br>CRITICAL_SECTION    g_csGlobalInfoLock; <br>CRITICAL_SECTION    g_csQueueLock; <br> <br> <br>DWORD <br>QueueAsyncFunction( <br>    WORKERFUNCTION  pfnFunction, <br>    PVOID           pvContext, <br>    BOOL            bAlertable <br>    ) <br>/*++ <br>  Routine Description <br>      Wrapper around function that queues work to a thread <br> <br>  Arguments <br>       <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    DWORD   dwResult; <br>     <br>    EnterCriticalSection(&amp;g_csProtocolStateLock); <br>     <br>    if (g_dwProtocolState == PROTOCOL_STATE_RUNNING) <br>    { <br>        g_dwProtocolRefCount++; <br> <br>        LeaveCriticalSection(&amp;g_csProtocolStateLock); <br>    } <br>    else <br>    {                                     <br>        LeaveCriticalSection(&amp;g_csProtocolStateLock); <br>         <br>        return ERROR_CAN_NOT_COMPLETE; <br>    }                   <br> <br>    dwResult = QueueWorkItem(pfnFunction, <br>                             pvContext, <br>                             bAlertable); <br> <br>    // <br>    // If we successfully queued the item, dont decrement the count <br>    // <br>     <br>    if(dwResult != NO_ERROR) <br>    { <br>        EnterCriticalSection(&amp;g_csProtocolStateLock); <br>     <br>        g_dwProtocolRefCount--; <br>         <br>        LeaveCriticalSection(&amp;g_csProtocolStateLock); <br>    } <br>         <br>    return dwResult; <br>} <br> <br>BOOL <br>WINAPI <br>DLLMain( <br>    IN HINSTANCE   hInstance, <br>    IN DWORD       dwReason, <br>    IN PVOID       pvUnused <br>    ) <br>/*++ <br>  Routine Description <br>      This is the DLL entrypoint handler. It calls DllStartup <br>      to initialize all data structures that need to be present <br>      even before the StartProtocol() function is called <br>      It calls DllCleanup to free resources that are not freed when <br>      StopProtocol() is called <br>   <br>  Arguments <br>      hInstance     Handle of the DLL <br>      dwReason      Reason why the function is being invoked <br> <br>  Return Value <br>      TRUE      If the function succeeds <br>      FALSE     otherwise <br> <br>--*/ <br>{ <br>    BOOL bErr; <br>     <br>    bErr = FALSE; <br> <br>    switch(dwReason) <br>    { <br>        case DLL_PROCESS_ATTACH: <br>        { <br>            // <br>            // Since we dont need to handle the THREAD_ATTACH and THREAD_DETACH <br>            // reasons, we ask the loader not to invoke our function when a <br>            // thread is created or destroyed in the process. This can be a <br>            // significant performance improvement <br>            // <br>             <br>            DisableThreadLibraryCalls(hInstance); <br> <br>            g_dwTrace    = INVALID_TRACEID; <br>            g_hLogHandle = NULL; <br>             <br>            bErr = DllStartup(); <br>             <br>            break; <br>        } <br>         <br>        case DLL_PROCESS_DETACH: <br>        { <br>            bErr = DllCleanup(); <br>             <br>            break; <br>        } <br>         <br>        default: <br>        { <br>            bErr = TRUE; <br> <br>            break; <br>        } <br>    } <br> <br>    return bErr; <br>} <br> <br>BOOL <br>DllStartup() <br>/*++ <br>  Routine Description <br>      Initializes the tracing and event logging handles. <br>      Initializes the state of the protocol to begin tracking threads that <br>      are executing code in the DLL <br>       <br>  Arguments <br>      None <br> <br>  Return Value <br>      TRUE  if function succeeds <br>      FALSE otherwise <br>       <br>--*/ <br>{ <br>    g_dwTrace    = TraceRegister(SAMPLE_PROTOCOL_NAME); <br>    g_hLogHandle = RouterLogRegister(SAMPLE_PROTOCOL_NAME); <br>     <br>     <br>    InitializeProtocolState(); <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>DllCleanup() <br>/*++ <br>  Routine Description <br>      Deletes the tracing and event handles <br>      Frees resources used to track threads in the DLL <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      TRUE <br> <br>--*/ <br>{ <br>    DeleteProtocolState(); <br> <br>    if(g_hLogHandle) <br>    { <br>        RouterLogDeregister(g_hLogHandle); <br>    } <br> <br>    if(g_dwTrace != INVALID_TRACEID) <br>    { <br>        TraceDeregister(g_dwTrace); <br>    } <br> <br>    return TRUE; <br>} <br> <br>VOID <br>InitializeProtocolState() <br>/*++ <br>  Routine Description <br>      Since the routing protocol is a DLL that may be unloaded, we need <br>      to track all activity occuring in the DLL <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    InitializeCriticalSection(&amp;g_csProtocolStateLock); <br> <br>    InitializeCriticalSection(&amp;g_csQueueLock); <br> <br>    g_dwProtocolState    = PROTOCOL_STATE_STOPPED; <br>    g_dwProtocolRefCount = 0; <br>    g_dwLogLevel         = PROTO_LOGGING_ERROR; <br>} <br> <br>VOID <br>DeleteProtocolState() <br>/*++ <br>  Routine Description <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    ASSERT(g_dwProtocolState == PROTOCOL_STATE_STOPPED); <br>    ASSERT(g_dwProtocolRefCount == 0); <br> <br>    DeleteCriticalSection(&amp;g_csQueueLock); <br> <br>    DeleteCriticalSection(&amp;g_csProtocolStateLock); <br>} <br> <br> <br>DWORD <br>APIENTRY <br>RegisterProtocol( <br>    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar, <br>    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar <br>    ) <br>/*++ <br>Routine Description <br>    This is the first function called by the IP Router Manager.   <br>    The Router Manager tells the routing protocol it version and capabilities <br>    It also tells the our DLL, the ID of the protocol it expects us to  <br>    register.  This allows one DLL to support multiple routing protocols. <br>    We return the functionality we support and a pointer to our functions. <br>     <br>Arguments <br>   <br> <br>Return Value <br>    NO_ERROR <br> <br>--*/ <br>{ <br>    // <br>    // The Router Manager should be calling us to register our protocol. <br>    // The Router Manager must be atleast the version we are compiled with <br>    // The Router Manager must support routing and demand update <br>    // <br> <br>    if(pRoutingChar-&gt;dwProtocolId != SAMPLE_PROTOCOL_ROUTE_ID) <br>    { <br>        return ERROR_NOT_SUPPORTED; <br>    } <br> <br>    if(pRoutingChar-&gt;dwVersion &lt; MS_ROUTER_VERSION) <br>    { <br>        return ERROR_NOT_SUPPORTED; <br>    } <br> <br>    if(pRoutingChar-&gt;fSupportedFunctionality != (ROUTING | DEMAND_UPDATE_ROUTES)) <br>    { <br>        return ERROR_NOT_SUPPORTED; <br>    } <br> <br>    // <br>    // Since we are not a service advertiser (an IPX thing) <br>    // <br> <br>    // <br>    // We setup our characteristics and function pointers <br>    // <br> <br>    pServiceChar-&gt;fSupportedFunctionality = 0; <br> <br>    pRoutingChar-&gt;fSupportedFunctionality = (ROUTING | DEMAND_UPDATE_ROUTES); <br> <br>    pRoutingChar-&gt;pfnStartProtocol    = StartProtocol; <br>    pRoutingChar-&gt;pfnStopProtocol     = StopProtocol; <br>    pRoutingChar-&gt;pfnAddInterface     = AddInterface; <br>    pRoutingChar-&gt;pfnDeleteInterface  = DeleteInterface; <br>    pRoutingChar-&gt;pfnGetEventMessage  = GetEventMessage; <br>    pRoutingChar-&gt;pfnGetInterfaceInfo = GetInterfaceConfigInfo; <br>    pRoutingChar-&gt;pfnSetInterfaceInfo = SetInterfaceConfigInfo; <br>    pRoutingChar-&gt;pfnBindInterface    = BindInterface; <br>    pRoutingChar-&gt;pfnUnbindInterface  = UnBindInterface; <br>    pRoutingChar-&gt;pfnEnableInterface  = EnableInterface; <br>    pRoutingChar-&gt;pfnDisableInterface = DisableInterface; <br>    pRoutingChar-&gt;pfnGetGlobalInfo    = GetGlobalInfo; <br>    pRoutingChar-&gt;pfnSetGlobalInfo    = SetGlobalInfo; <br>    pRoutingChar-&gt;pfnMibCreateEntry   = MibCreate; <br>    pRoutingChar-&gt;pfnMibDeleteEntry   = MibDelete; <br>    pRoutingChar-&gt;pfnMibGetEntry      = MibGet; <br>    pRoutingChar-&gt;pfnMibSetEntry      = MibSet; <br>    pRoutingChar-&gt;pfnMibGetFirstEntry = MibGetFirst; <br>    pRoutingChar-&gt;pfnMibGetNextEntry  = MibGetNext; <br>    pRoutingChar-&gt;pfnUpdateRoutes     = DoUpdateRoutes; <br> <br>    return NO_ERROR; <br>} <br> <br> <br> <br>DWORD <br>APIENTRY <br>StartProtocol( <br>    IN HANDLE               hMgrNotifyEvent, <br>    IN PSUPPORT_FUNCTIONS   pSupportFunctions, <br>    IN PVOID                pvConfig <br>    ) <br>/*++ <br>  Routine Description <br>      After the protocol has been registered, the IP Router Manager calls <br>      this function to tell the protocol to start. Most of the startup <br>      code is executed here <br>       <br>  Arguments <br>      hMgrNotifyEvent   Event to Set if the IP Router Manager needs to <br>                        be notified to take any action on our behalf <br>      pSupportFunctions Some functions exported by IP Router Manager <br>      pvConfig          Our global configuration which was setup by our <br>                        setup/admin DLL <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    WSADATA wsaData; <br>    DWORD   dwResult, dwThread; <br>    HANDLE  hThread; <br>    BOOL    bWinsockLoaded; <br>     <br>    PSAMPLE_PROTOCOL_GLOBAL_INFO    pGlobalInfo; <br>     <br>    EnterProtocolApi(); <br>     <br>    TraceEnter("StartProtocol"); <br> <br>    if(pvConfig == NULL) <br>    { <br>        Trace0(ERR, <br>               "StartProtocol: Called with NULL config"); <br> <br>        TraceLeave("StartProtocol"); <br>     <br>        ExitProtocolApi(); <br>     <br>        return ERROR_INVALID_PARAMETER; <br>    } <br>     <br>    pGlobalInfo = (PSAMPLE_PROTOCOL_GLOBAL_INFO)pvConfig; <br>     <br>    if(!ValidateGlobalInfo(pGlobalInfo)) <br>    { <br>        TraceLeave("StartProtocol"); <br>     <br>        ExitProtocolApi(); <br>     <br>        return ERROR_INVALID_DATA; <br>    } <br> <br>    g_hPrivateHeap       = NULL; <br>    g_hRtmEvent          = NULL; <br>    g_hMgrNotifyEvent    = NULL; <br>    g_hRtmHandle         = NULL; <br>    g_hStopProtocolEvent = NULL; <br>    g_hSocketEvent       = NULL; <br>    g_pmmStopMsg         = NULL; <br>    bWinsockLoaded       = FALSE; <br> <br> <br>    g_psfnSupportFunctions = pSupportFunctions; <br>     <br>    do <br>    { <br>        InitializeCriticalSections(); <br> <br>         <br>        // <br>        // We need Winsock2.0 or better <br>        // <br> <br>        dwResult = (DWORD)WSAStartup(MAKEWORD(2,0), &amp;wsaData); <br> <br>        if(dwResult != 0) <br>        { <br>         <br>            Trace1(ERR, <br>                   "StartProtocol: Error %d starting WinSock.", dwResult); <br> <br>            LogErr0(WINSOCK_FAIL, <br>                    dwResult); <br>            break; <br>        } <br> <br>        bWinsockLoaded = TRUE; <br> <br>        dwResult = CreateHeaps(); <br> <br>        if(dwResult != NO_ERROR) <br>        { <br>            break; <br>        } <br> <br>        dwResult = CreateEvents(); <br> <br>        if(dwResult != NO_ERROR) <br>        { <br>            break; <br>        } <br> <br> <br> <br>        // <br>        // The message that will be used to notify the stopping <br>        // of this protocol. If we cant create this, we wont be <br>        // able to stop <br>        // <br>         <br>        g_pmmStopMsg = HeapAlloc(g_hPrivateHeap, <br>                                 0, <br>                                 sizeof(MGR_MSG)); <br> <br> <br>        if(g_pmmStopMsg == NULL) <br>        { <br>            dwResult = GetLastError(); <br>             <br>            Trace1(ERR, <br>                   "StartProtocol: Couldnt allocate stop message. Error %d", <br>                   dwResult); <br> <br>            break; <br>        } <br> <br>         <br>        // <br>        // Register as an RTM client. We will not keep multiple routes <br>        // to one destination so we set the flags to denote this <br>        // <br>     <br>        g_hRtmHandle = RtmRegisterClient(RTM_PROTOCOL_FAMILY_IP, <br>                                         SAMPLE_PROTOCOL_ROUTE_ID, <br>                                         g_hRtmEvent, <br>                                         RTM_PROTOCOL_SINGLE_ROUTE); <br> <br>        if(g_hRtmHandle == NULL) <br>        { <br>            dwResult = GetLastError(); <br> <br>            Trace1(ERR, <br>                   "StartProtocol: Error %d registering with RTM", <br>                   dwResult); <br>             <br>            LogErr0(RTM_REGISTER_FAILED, <br>                    dwResult); <br> <br>            break; <br>        } <br> <br>        // <br>        // Create the main thread. This executes the MainThread() function <br>        // <br>         <br>        hThread = CreateThread(NULL, 0, <br>                               MainThread, <br>                               NULL, <br>                               0, <br>                               &amp;dwThread); <br> <br>        if (hThread == NULL) <br>        { <br>            dwResult = GetLastError(); <br>             <br>            Trace1(ERR, <br>                   "StartProtocol: Error %d starting main thread", <br>                   dwResult); <br>             <br>            LogErr0(CREATE_THREAD_FAILED, <br>                    dwResult); <br> <br>            break; <br>        } <br> <br>        // <br>        // We will never refer to the thread using the handle <br>        // so close it and avoid a leak <br>        // <br>         <br>        CloseHandle(hThread); <br>         <br>    }while(FALSE); <br> <br>    if(dwResult != NO_ERROR) <br>    { <br>        // <br>        // Something bad happened <br>        // <br> <br>        if(g_pmmStopMsg) <br>        { <br>            HeapFree(g_hPrivateHeap, <br>                     0, <br>                     g_pmmStopMsg); <br>        } <br>         <br>        CleanupProtocol(bWinsockLoaded); <br> <br>    } <br>    else <br>    { <br>        g_hMgrNotifyEvent = hMgrNotifyEvent; <br>         <br>        g_dwProtocolState = PROTOCOL_STATE_RUNNING; <br>    } <br> <br>    TraceLeave("StartProtocol"); <br>     <br>    ExitProtocolApi(); <br>     <br>    return NO_ERROR; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>StopProtocol() <br>/*++ <br>  Routine Description <br>     This function is called by the IP Router Manager to tell the protocol <br>     to stop.  We set the protocol state to prevent us from servicing <br>     any more requests. Then we notify the MainThread to stop and <br>     return PENDING to the IP Router Manager. If we had no thread and no <br>     work functions in our implementation, we could have stopped <br>     synchronously. <br>      <br>  Arguments <br> <br> <br>  Return Value <br>     PENDING <br> <br>--*/ <br>{    <br>    EnterCriticalSection(&amp;g_csProtocolStateLock); <br> <br>    TraceEnter("StopProtocol"); <br>     <br>    // <br>    // Cannot stop if already stopped <br>    // <br> <br>    if(g_dwProtocolState != PROTOCOL_STATE_RUNNING) <br>    { <br>        Trace1(GLOBAL, <br>               "StopProtocol: Protocol state is %s", <br>               g_ppszStateStrings[g_dwProtocolState]); <br>         <br>        TraceLeave("StopProtocol"); <br>         <br>        LeaveCriticalSection(&amp;g_csProtocolStateLock); <br> <br>        ExitProtocolApi(); <br>         <br>        return ERROR_CAN_NOT_COMPLETE; <br>    } <br> <br>    // <br>    // Dont release the state lock, so that the other threads <br>    // won't cleanup under us <br>    // <br>     <br>    // <br>    // Tell the main thread to stop. That will clean out everything <br>    // <br> <br>    Trace0(GLOBAL, <br>           "StopProtocol: Signalling main thread to stop"); <br> <br>    SetEvent(g_hStopProtocolEvent); <br>     <br>    // <br>    // Set state to STOPPING; <br>    // <br> <br>    g_dwProtocolState = PROTOCOL_STATE_STOPPING; <br> <br>    Trace1(GLOBAL, <br>           "StopProtocol: %d threads are still active", <br>           g_dwProtocolRefCount); <br> <br> <br>    TraceLeave("StopProtocol"); <br>     <br>    LeaveCriticalSection(&amp;g_csProtocolStateLock); <br> <br>    return ERROR_PROTOCOL_STOP_PENDING; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>GetGlobalInfo( <br>    IN OUT PVOID    pvConfig, <br>    IN OUT PDWORD   pdwSize <br>    ) <br>/*++ <br>  Routine Description <br>      The function is called by the IP Router Manager, usually in because of <br>      a query by the admin utility.  We see if we have space enough to <br>      return our global config. If we do we return it, otherwise we return the <br>      size needed <br> <br>  Arguments <br>      pvConfig  Pointer to allocated buffer to store our config <br>      pdwSize   Size of config.  <br> <br>  Return Value <br>      ERROR_INSUFFICIENT_BUFFER If the size of the buffer is too small <br>      ERROR_INVALID_PARAMETER <br>      ERROR_INVALID_DATA <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PSAMPLE_PROTOCOL_GLOBAL_INFO    pGlobalInfo; <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("GetGlobalInfo"); <br> <br>    if(pdwSize == NULL) <br>    { <br>        Trace0(ERR, <br>               "GetGlobalInfo: Router Manager called us with NULL size"); <br>         <br>        TraceLeave("GetGlobalInfo"); <br> <br>        ExitProtocolApi(); <br>         <br>        return ERROR_INVALID_PARAMETER; <br>    } <br>     <br>     <br>    if((*pdwSize &lt; sizeof(SAMPLE_PROTOCOL_GLOBAL_INFO))|| <br>       (pvConfig == NULL)) <br>    { <br>        // <br>        // Either the size was too small or there was no <br>        // storage <br>        // <br>         <br>        *pdwSize = sizeof(SAMPLE_PROTOCOL_GLOBAL_INFO); <br> <br>        Trace3(GLOBAL, <br>               "GetGlobalInfo: Router Manager called us with size %d and info %x. Info size should be %d", <br>               *pdwSize, <br>               pvConfig, <br>               sizeof(SAMPLE_PROTOCOL_GLOBAL_INFO)); <br> <br>        TraceLeave("GetGlobalInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INSUFFICIENT_BUFFER; <br>    } <br> <br>    *pdwSize = sizeof(SAMPLE_PROTOCOL_GLOBAL_INFO); <br>     <br>    // <br>    // Ok, so we have a good buffer to write our info into <br>    // <br> <br>    pGlobalInfo = (PSAMPLE_PROTOCOL_GLOBAL_INFO)pvConfig; <br> <br>    // <br>    // Currently that is all the info we have <br>    // <br> <br>    EnterCriticalSection(&amp;g_csGlobalInfoLock); <br>     <br>    pGlobalInfo-&gt;dwLogLevel = g_dwLogLevel; <br> <br>    LeaveCriticalSection(&amp;g_csGlobalInfoLock); <br>     <br>    TraceLeave("GetGlobalInfo"); <br> <br>    ExitProtocolApi(); <br> <br>    return NO_ERROR; <br>} <br> <br> <br> <br>DWORD <br>APIENTRY <br>SetGlobalInfo( <br>    IN PVOID pvConfig <br>    ) <br>/*++ <br>  Routine Description <br>      Called by the IP Router Manager usually in response to an admin <br>      utility changing the config.  We verify the parameters and the <br>      info and set it <br> <br>  Arguments <br> <br> <br>  Return Value <br>      ERROR_INVALID_PARAMETER <br>      ERROR_INVALID_DATA <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PSAMPLE_PROTOCOL_GLOBAL_INFO    pGlobalInfo; <br> <br>    EnterProtocolApi(); <br> <br>    TraceEnter("SetGlobalInfo"); <br> <br>    if(pvConfig == NULL) <br>    { <br>        Trace0(ERR, <br>               "SetGlobalInfo: Router Manager called us with NULL info"); <br> <br>        TraceLeave("SetGlobalInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br>     <br> <br>    pGlobalInfo = (PSAMPLE_PROTOCOL_GLOBAL_INFO)pvConfig; <br>     <br>    if(!ValidateGlobalInfo(pGlobalInfo)) <br>    { <br>        // <br>        // Bad global info <br>        // <br> <br>        TraceLeave("SetGlobalInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_DATA; <br>    } <br> <br>    // <br>    // Good info <br>    // <br> <br>    EnterCriticalSection(&amp;g_csGlobalInfoLock); <br> <br>    g_dwLogLevel = pGlobalInfo-&gt;dwLogLevel; <br> <br>    LeaveCriticalSection(&amp;g_csGlobalInfoLock); <br>     <br>    TraceLeave("SetGlobalInfo"); <br> <br>    ExitProtocolApi(); <br> <br>    return ERROR_INVALID_DATA; <br> <br>} <br> <br>DWORD <br>APIENTRY <br>DoUpdateRoutes( <br>    IN DWORD dwIndex <br>    ) <br>/*++ <br>  Routine Description <br>      This function is called by the IP Router Manger to ask us to <br>      update routes over a Demand Dial link.  The link has already been <br>      brought up so should be in ENABLED-BOUND state.  After we are done <br>      we need to set the g_hMgrNotifyEvent to inform the Router Manager <br>      that we have a message in our queue to be delivered to it. The <br>      Router Manager will call our GetEventMessage() function in which <br>      we will inform it that we are done with update routes (and the routes <br>      have been stored in RTM). The Router Manager will "freeze" these routes <br>      by converting them to AUTOSTATIC. <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR/PENDING  For Success <br> <br>--*/ <br>{ <br>    DWORD   dwResult; <br>     <br>    // <br>    // We will fire off a worker function to do the "real work" <br>    // That will set the event <br>    // <br> <br>    dwResult = QueueAsyncFunction(UpdateRoutes, <br>                                  (PVOID)dwIndex, <br>                                  TRUE); <br>     <br>     <br>    return dwResult; <br>} <br> <br> <br>BOOL <br>ValidateGlobalInfo( <br>    PSAMPLE_PROTOCOL_GLOBAL_INFO pInfo <br>    ) <br>/*++ <br>  Routine Description <br>      Checks to see if the global info is OK. It is good practice to do this <br>      because a corrupt registry can change configuration causing all sorts of <br>      debugging headaches if it is not found early <br>   <br>  Arguments <br>      pInfo     The Global Info to check <br> <br>  Return Value <br>      TRUE      If the info is good <br>      FALSE     otherwise <br> <br>--*/ <br>{ <br>    // <br>    // Ensure that the logging level is within bounds <br>    // <br>     <br>    if((pInfo-&gt;dwLogLevel &lt;= PROTO_LOGGING_INFO) &amp;&amp; <br>       (pInfo-&gt;dwLogLevel &gt;= PROTO_LOGGING_NONE)) <br>    { <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>DWORD <br>APIENTRY <br>GetEventMessage( <br>    OUT ROUTING_PROTOCOL_EVENTS *pEvent, <br>    OUT PMESSAGE                pResult <br>    ) <br>/*++ <br>  Routine Description <br>      This is called by the IP Router Manager if we indicate that we have <br>      a message in our queue to be delivered to it (by setting the <br>      g_hMgrNotifyEvent) <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PLIST_ENTRY pleNode; <br>    PMGR_MSG    pmmMsg; <br>     <br>    // <br>    // IMPORTANT: This can be called after the protocol is stopped <br>    // so we dont do ref counting for this API. <br>    // <br> <br>    EnterCriticalSection(&amp;g_csQueueLock); <br> <br>    if(IsListEmpty(&amp;g_leMsgQueue)) <br>    { <br>        LeaveCriticalSection(&amp;g_csQueueLock); <br> <br>        return ERROR_NO_MORE_ITEMS; <br>    } <br> <br>    pleNode = RemoveHeadList(&amp;g_leMsgQueue); <br> <br>    LeaveCriticalSection(&amp;g_csQueueLock); <br>     <br>    pmmMsg = CONTAINING_RECORD(pleNode, <br>                               MGR_MSG, <br>                               leMsgLink); <br> <br>    *pEvent  = pmmMsg-&gt;rreEvent; <br>    *pResult = pmmMsg-&gt;mResult; <br> <br> <br>    HeapFree(g_hPrivateHeap, <br>             0, <br>             pmmMsg); <br>     <br>    return NO_ERROR; <br>} <br> <br> <br> <br>VOID <br>APIENTRY <br>UpdateRoutes( <br>    PVOID   pvContext <br>    ) <br>/*++ <br>  Routine Description <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    DWORD       dwIndex; <br>    PNT_IF      pIf; <br>    PMGR_MSG    pmmMsg; <br> <br>     <br>    // <br>    // We dont EnterProtocolApi() here since it has been done for us <br>    // when we were queued for execution <br>    // <br>     <br>    TraceEnter("UpdateRoutes"); <br>     <br>    dwIndex = (DWORD)pvContext; <br> <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br> <br>    if(pIf == NULL) <br>    { <br>        // <br>        // This can happen because the interface could have been deleted <br>        // between the now and the time this function was queued for <br>        // execution <br>        // <br> <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        TraceLeave("UpdateRoutes"); <br> <br>        // <br>        // We must decrement the ref count for the protocol <br>        // though <br>        // <br> <br>        ExitProtocolApi(); <br>         <br>        return; <br>    } <br> <br>    // <br>    // Here we do the protocol processing stuff <br>    // In the sample we wont do anything <br>    // <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br> <br>    // <br>    // We allocate the memory for a message here and free it in <br>    // GetEventMessage() <br>    // <br>     <br>    pmmMsg = HeapAlloc(g_hPrivateHeap, <br>                       0, <br>                       sizeof(MGR_MSG)); <br> <br>    if(pmmMsg == NULL) <br>    { <br>        Trace1(ERR, <br>               "UpdateRoutes: Unable to allocate memory for message. Error %d", <br>               GetLastError()); <br> <br>        TraceLeave("UpdateRoutes"); <br> <br>        ExitProtocolApi(); <br>         <br>        return; <br>    } <br> <br> <br>    pmmMsg-&gt;rreEvent = UPDATE_COMPLETE; <br> <br>    pmmMsg-&gt;mResult.UpdateCompleteMessage.InterfaceIndex = dwIndex; <br>    pmmMsg-&gt;mResult.UpdateCompleteMessage.UpdateType     = DEMAND_UPDATE_ROUTES; <br>    pmmMsg-&gt;mResult.UpdateCompleteMessage.UpdateStatus   = NO_ERROR; <br> <br>    EnterCriticalSection(&amp;g_csQueueLock); <br> <br>    InsertHeadList(&amp;g_leMsgQueue, <br>                   &amp;pmmMsg-&gt;leMsgLink); <br> <br>    LeaveCriticalSection(&amp;g_csQueueLock); <br>     <br>    SetEvent(g_hMgrNotifyEvent); <br>     <br>    TraceLeave("UpdateRoutes"); <br> <br>    ExitProtocolApi(); <br>     <br>    return; <br>} <br> <br>VOID <br>InitializeCriticalSections() <br>/*++ <br>  Routine Description <br> <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    InitializeCriticalSection(&amp;g_csIfListLock); <br>    InitializeCriticalSection(&amp;g_csProtocolStateLock); <br>    InitializeCriticalSection(&amp;g_csGlobalInfoLock); <br>} <br> <br>VOID <br>DeleteCriticalSections() <br>/*++ <br>  Routine Description <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    DeleteCriticalSection(&amp;g_csIfListLock); <br>    DeleteCriticalSection(&amp;g_csProtocolStateLock); <br>    DeleteCriticalSection(&amp;g_csGlobalInfoLock); <br>} <br> <br>DWORD <br>CreateEvents() <br>/*++ <br>  Routine Description <br>      Create all the events necessary <br>       <br>  Arguments <br> <br> <br>  Return Value <br>      None <br> <br>--*/ <br>{ <br>    DWORD   dwResult; <br>     <br>             <br>    // <br>    // Create the event used to get notifications from RTM about new routes <br>    // It has default security, is auto reset since only one thread will wait <br>    // on it. Initially set to FALSE. For debug versions we name the event <br>    // This helps in detecting leaks <br>    // <br> <br>     <br>#if DBG <br>#define EVENT_NAME  "RtmEventForSampleProtocol" <br>#else <br>#define EVENT_NAME  NULL <br>#endif     <br>     <br>    g_hRtmEvent = CreateEvent(NULL, <br>                              FALSE, <br>                              FALSE, <br>                              EVENT_NAME); <br> <br>#undef EVENT_NAME <br> <br>    if(g_hRtmEvent == NULL) <br>    { <br>        dwResult = GetLastError(); <br>         <br>        Trace1(ERR, <br>               "CreateEvents: Error %d creating RTM Event", <br>               dwResult); <br>         <br>        LogErr0(EVENT_FAIL,dwResult); <br>             <br>        return dwResult; <br>    } <br> <br>#if DBG <br>#define EVENT_NAME  "SocketEventForSampleProtocol" <br>#else <br>#define EVENT_NAME  NULL <br>#endif     <br>     <br>    g_hSocketEvent = CreateEvent(NULL, <br>                                 FALSE, <br>                                 FALSE, <br>                                 EVENT_NAME); <br> <br>#undef EVENT_NAME <br> <br>    if(g_hSocketEvent == NULL) <br>    { <br>        dwResult = GetLastError(); <br>         <br>        Trace1(ERR, <br>               "CreateEvents: Error %d creating Socket Event", <br>               dwResult); <br>         <br>        LogErr0(EVENT_FAIL,dwResult); <br>             <br>        return dwResult; <br>    } <br> <br>#if DBG <br>#define EVENT_NAME  "StopEventForSampleProtocol" <br>#else <br>#define EVENT_NAME  NULL <br>#endif     <br>     <br>    g_hStopProtocolEvent = CreateEvent(NULL, <br>                                       FALSE, <br>                                       FALSE, <br>                                       EVENT_NAME); <br> <br>#undef EVENT_NAME <br> <br>    if(g_hStopProtocolEvent == NULL) <br>    { <br>        dwResult = GetLastError(); <br>         <br>        Trace1(ERR, <br>               "CreateEvents: Error %d creating Stop Protocol Event", <br>               dwResult); <br>         <br>        LogErr0(EVENT_FAIL,dwResult); <br>             <br>        return dwResult; <br>    } <br> <br>    return NO_ERROR; <br>} <br> <br>VOID <br>DestroyEvents() <br>/*++ <br>  Routine Description <br>      Close all the event handles <br>       <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    if(g_hRtmEvent != NULL) <br>    { <br>        CloseHandle(g_hRtmEvent); <br>    } <br>     <br>    if(g_hStopProtocolEvent != NULL) <br>    { <br>        CloseHandle(g_hStopProtocolEvent); <br>    } <br>     <br>    if(g_hSocketEvent != NULL) <br>    { <br>        CloseHandle(g_hSocketEvent); <br>    } <br>} <br> <br>DWORD <br>CreateHeaps() <br>/*++ <br>  Routine Description <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    DWORD dwResult; <br>     <br>    g_hPrivateHeap = HeapCreate(0,0,0); <br>     <br>    if(g_hPrivateHeap == NULL) </code></pre>
<p>
</p>
<pre><code>{ <br>        dwResult = GetLastError(); <br>         <br>        Trace1(ERR, <br>               "CreateHeaps: Error %d creating heap", <br>               dwResult); <br> <br>        return dwResult; <br>    } <br> <br>    return NO_ERROR; <br>} <br> <br>DWORD <br>DestroyHeaps() <br>/*++ <br>  Routine Description <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    if(g_hPrivateHeap != NULL) <br>    { <br>        HeapDestroy(g_hPrivateHeap); <br>    } <br> <br>    return NO_ERROR; <br>} <br> <br> <br>VOID <br>CleanupProtocol( <br>    BOOL bWinsockLoaded <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>             <br>    if(bWinsockLoaded) <br>    { <br>        if(WSACleanup() != NO_ERROR) <br>        { <br>            Trace1(ERR, <br>                   "CleanupProtocol: Error %d cleaning up WinSock", <br>                   WSAGetLastError()); <br>        }    <br>    } <br> <br>    if(g_hRtmHandle) <br>    { <br>        RtmDeregisterClient(g_hRtmHandle); <br>    } <br>         <br>     <br>    DestroyEvents(); <br>    DeleteCriticalSections(); <br>    DestroyHeaps(); <br> <br>    return; <br>} <br> <br>     </code></pre>
<p>&nbsp;</p></body>
</HTML>
