<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5081"></a>IF.C</h2>
<pre><code>/*++ <br> <br>Copyright 1997 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    sample\ip\if.c <br> <br>Abstract: <br>    Interface related functions exported by the Sample Routing Protocol DLL and <br>    other code dealing with interfaces <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#include "sampinc.h" <br> <br> <br> <br>BOOL <br>ValidateInterfaceInfo( <br>    PSAMPLE_PROTOCOL_INTERFACE_INFO pInfo <br>    ); <br>DWORD <br>ActivateBinding( <br>    PINTRNL_IF  pBind <br>    ); <br>DWORD <br>DeactivateBinding( <br>    PINTRNL_IF  pBind <br>    ); <br>PNT_IF <br>GetIfBlockGivenIndex( <br>    DWORD   dwIndex <br>    ); <br>PINTRNL_IF <br>GetBindingGivenAddress( <br>    PNT_IF pIf, <br>    DWORD dwAddress <br>    ); <br>DWORD <br>CreateSocket( <br>    IN  DWORD  dwAddress, <br>    OUT SOCKET *psSocket  <br>    ); <br> <br> <br>DWORD <br>APIENTRY <br>AddInterface( <br>    IN PWCHAR               pwszInterfaceName, <br>    IN DWORD                dwIndex, <br>    IN NET_INTERFACE_TYPE   dwIfType, <br>    IN PVOID                pvConfig <br>    ) <br>/*++ <br>  Routine Description <br>      Called by the IP Router Manager to add an interface when <br>      it finds our information block (header) within the interface's <br>      configuration. <br>      We verify the information and create the structure for the <br>      interface.  Then we see all the configured addresses for <br>      the interface and create a binding structure for each address <br>      The interface comes up as UNBOUND-DISABLED <br>       <br>  Arguments <br>      pwszInterfaceName The name of the interface. We store it for logging <br>      dwIndex           The positive integer this interface will be referred to by <br>      dwIfType          The type of the interface (WAN/LAN etc) <br>      pvConfig          Our config for this interface <br> <br>  Return Value <br>      ERROR_INVALID_PARAMETER <br>      ERROR_INVALID_DATA <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    ULONG       ulNameLen,i; <br>    DWORD       dwResult; <br>    PWCHAR      pwszName; <br>    PINTRNL_IF  pBind; <br>    PNT_IF      pIf,pPrev; <br>    PLIST_ENTRY pleNode; <br>     <br>     <br>    PSAMPLE_PROTOCOL_INTERFACE_INFO pIfInfo; <br> <br> <br>    EnterProtocolApi(); <br> <br>    TraceEnter("AddInterface"); <br>     <br>    Trace3(INTF, "AddInterface called for: %S %d %d ", <br>           pwszInterfaceName, <br>           dwIndex, <br>           dwIfType); <br> <br>    ulNameLen = wcslen(pwszInterfaceName); <br>     <br>    if((pwszInterfaceName == NULL) || <br>       (pvConfig == NULL) || <br>       (ulNameLen == 0)) <br>    { <br>        Trace0(ERR, <br>               "AddInterface: Router Manager called us with NULL info"); <br>         <br>        TraceLeave("AddInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    pIfInfo = (PSAMPLE_PROTOCOL_INTERFACE_INFO)pvConfig; <br>     <br>    if(!ValidateInterfaceInfo(pIfInfo)) <br>    { <br>        TraceLeave("AddInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_DATA; <br>    } <br>     <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    // <br>    // Create the interface block and the blocks for the binding <br>    // <br> <br>    dwResult = NO_ERROR; <br>     <br>    __try <br>    { <br>        pIf = HeapAlloc(g_hPrivateHeap, <br>                        HEAP_ZERO_MEMORY, <br>                        sizeof(NT_IF)); <br> <br>        if(pIf == NULL) <br>        { <br>            dwResult = GetLastError(); <br>             <br>            Trace1(ERR, <br>                   "AddInterface: Error %d allocating memory for i/f", <br>                   dwResult); <br>             <br>            __leave; <br>        } <br> <br>        InitializeListHead(&amp;pIf-&gt;leInternalIfHead); <br>         <br>        pwszName = HeapAlloc(g_hPrivateHeap, <br>                             HEAP_ZERO_MEMORY, <br>                             (ulNameLen + 1)*sizeof(WCHAR)); <br> <br>        if(pwszName == NULL) <br>        { <br>            dwResult = GetLastError(); <br> <br>            Trace1(ERR, <br>                   "AddInterface: Error %d allocating memory for name", <br>                   dwResult); <br> <br>            __leave; <br>        } <br> <br>        wcscpy(pwszName, <br>               pwszInterfaceName); <br> <br>        pIf-&gt;pwszIfName = pwszName; <br> <br>        ClearNtState(pIf); <br> <br>        pIf-&gt;dwType = dwIfType; <br>         <br>        pIf-&gt;ulNumBindings = pIfInfo-&gt;ulNumBindings; <br>         <br>        for(i = 0; i &lt; pIfInfo-&gt;ulNumBindings; i++) <br>        { <br>            pBind = HeapAlloc(g_hPrivateHeap, <br>                                HEAP_ZERO_MEMORY, <br>                                sizeof(INTRNL_IF)); <br> <br>            if(pBind == NULL) <br>            { <br>                dwResult = GetLastError(); <br> <br>                Trace1(ERR, <br>                       "AddInterface: Error %d allocating memory for internal i/f", <br>                       dwResult); <br> <br>                __leave; <br>            } <br> <br>            InsertHeadList(&amp;(pIf-&gt;leInternalIfHead), <br>                           &amp;(pBind-&gt;leInternalIfLink)); <br> <br>            // <br>            // Copy out binding info <br>            // <br>             <br>            pBind-&gt;dwAddress    = pIfInfo-&gt;rgbiInfo[i].dwAddress; <br>            pBind-&gt;dwMask       = pIfInfo-&gt;rgbiInfo[i].dwMask; <br>            pBind-&gt;bEnabled     = pIfInfo-&gt;rgbiInfo[i].bEnabled; <br>            pBind-&gt;dwState      = BINDING_DOWN; <br>            pBind-&gt;sSocket      = INVALID_SOCKET; <br>             <br>            if(pIfInfo-&gt;ulNumBindings == 1) <br>            { <br>                // <br>                // If we have only one address, we set that to 0.0.0.0 <br>                // for now even if our config has screwed up <br>                // <br> <br>                pBind-&gt;dwAddress    = 0x00000000; <br>                pBind-&gt;dwMask       = 0x00000000; <br>            } <br>        } <br>    } <br>    __finally <br>    { <br>        if(dwResult != NO_ERROR) <br>        { <br>            // <br>            // Clean up all resources <br>            // <br> <br>            if(pIf) <br>            { <br>                if(pIf-&gt;pwszIfName) <br>                { <br>                    HeapFree(g_hPrivateHeap, <br>                             0, <br>                             pIf-&gt;pwszIfName); <br>                } <br> <br>                pleNode  = pIf-&gt;leInternalIfHead.Flink; <br> <br>                while(pleNode != &amp;pIf-&gt;leInternalIfHead) <br>                { <br>                    pBind = CONTAINING_RECORD(pleNode, <br>                                              INTRNL_IF, <br>                                              leInternalIfLink); <br> <br>                    pleNode = pleNode-&gt;Flink; <br> <br>                    HeapFree(g_hPrivateHeap, <br>                             0, <br>                             pBind); <br>                } <br>            } <br>        } <br>        else <br>        { <br>            // <br>            // Insert the interface into our link <br>            // <br> <br>            for(pleNode  = g_leIfListHead.Flink; <br>                pleNode != &amp;g_leIfListHead; <br>                pleNode  = pleNode-&gt;Flink) <br>            { <br>                pPrev = CONTAINING_RECORD(pleNode, <br>                                          NT_IF, <br>                                          leNtIfLink); <br> <br>                if(pPrev-&gt;dwNtIndex &gt; dwIndex) <br>                { <br>                    break; <br>                } <br>            } <br> <br>            // <br>            // pPrev now points to the interface with a higher index <br>            // pPrev-&gt;Blink &lt; dwIndex so put our interface after <br>            // pPrev-&gt;Blink. This way we get an ordered list <br>            // <br>             <br>            InsertHeadList(pPrev-&gt;leNtIfLink.Blink, <br>                           &amp;(pIf-&gt;leNtIfLink)); <br>             <br>        } <br>    } <br> <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br> <br>    TraceLeave("AddInterface"); <br> <br>    ExitProtocolApi(); <br>         <br>    return dwResult; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>DeleteInterface( <br>    IN DWORD dwIndex <br>    ) <br>/*++ <br>  Routine Description <br>      Called by the IP Router Manager to delete an interface. If the interface is <br>      running we shut it down and free all the resources used by it <br> <br>  Arguments <br>      dwIndex   The index of the interface to be deleted <br> <br>  Return Value <br>      ERROR_INVALID_PARAMETER   If an interface with the given index was not found <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF      pIf; <br>    PLIST_ENTRY pleNode; <br>    PINTRNL_IF  pBind; <br> <br>     <br>    EnterProtocolApi(); <br>     <br>    TraceEnter("DeleteInterface"); <br>     <br>    Trace1(ERR, <br>           "DeleteInterface: Called for interface %d", <br>           dwIndex); <br>     <br>    EnterCriticalSection(&amp;g_csIfListLock); <br>     <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br>     <br>    if(pIf == NULL) <br>    { <br>        // <br>        // Did not have an interface corresponding to <br>        // this index <br>        // <br> <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        Trace1(ERR, <br>               "DeleteInterface: Interface %d does not exist", <br>               dwIndex); <br> <br>        TraceLeave("DeleteInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    // <br>    // Remove it from the list of NT Interfaces <br>    // <br>     <br>    RemoveEntryList(&amp;(pIf-&gt;leNtIfLink)); <br>     <br>    ASSERT(pIf-&gt;dwNtIndex == dwIndex); <br>    ASSERT(pIf-&gt;pwszIfName); <br>     <br>    // <br>    // Shut down each binding on the interface. We may have already <br>    // gotten Unbind() calls so they may have already been shut down <br>    // <br> <br>    pleNode = pIf-&gt;leInternalIfHead.Flink; <br>     <br>    while(pleNode != &amp;(pIf-&gt;leInternalIfHead)) <br>    { <br>        pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br> <br>        pleNode = pleNode-&gt;Flink; <br>         <br>        if(pBind-&gt;dwState == BINDING_UP) <br>        { <br>            // <br>            // So we did not get an unbind or disable for this <br>            // <br> <br>            ASSERT(pBind-&gt;sSocket != INVALID_SOCKET); <br> <br>            if(closesocket(pBind-&gt;sSocket) != NO_ERROR) <br>            { <br>                Trace3(ERR, <br>                       "DeleteInterface: Error %d closing socket %d on interface %S", <br>                       WSAGetLastError(), <br>                       pBind-&gt;sSocket, <br>                       pIf-&gt;pwszIfName); <br>            } <br>        } <br> <br>        HeapFree(g_hPrivateHeap, <br>                 0, <br>                 pBind); <br>    } <br>             <br>    // <br>    // Free other resources <br>    // <br> <br>    HeapFree(g_hPrivateHeap, <br>             0, <br>             pIf-&gt;pwszIfName); <br> <br> <br>    // <br>    // Lastly free the interface itself <br>    // <br>     <br>    HeapFree(g_hPrivateHeap, <br>             0, <br>             pIf); <br>     <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br> <br>    TraceLeave("AddInterface"); <br> <br>    ExitProtocolApi(); <br>         <br>    return NO_ERROR; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>GetInterfaceConfigInfo( <br>    IN     DWORD  dwIndex, <br>    IN OUT PVOID  pvConfig, <br>    IN OUT PDWORD pdwSize <br>    ) <br>/*++ <br>  Routine Description <br>      Called by the IP Router Manager to retrieve an interface's configuration. <br>      Usually this is because an admin utility is displaying this information. <br>      The Router Manager calls us with a NULL config and ZERO size. We return <br>      the required size to it.  It then allocates the needed memory and calls <br>      us a second time with a valid buffer.  We validate parameters each time <br>      and copy out our config if we can <br> <br>  Arguments <br>      dwIndex   Index of the interface being queried <br>      pvConfig  Pointer to buffer to store the config <br>      pdwSize   Size of the buffer <br> <br>  Return Value <br>      ERROR_INSUFFICIENT_BUFFER If the size of the buffer is too small <br>      ERROR_INVALID_PARAMETER <br>      ERROR_INVALID_DATA <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF      pIf; <br>    PLIST_ENTRY pleNode; <br>    PINTRNL_IF  pBind; <br>    ULONG       i; <br>     <br>    PSAMPLE_PROTOCOL_INTERFACE_INFO pIfInfo; <br> <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("GetInterfaceConfigInfo"); <br>     <br>    if(pdwSize == NULL) <br>    { <br>        Trace0(ERR, <br>               "GetInterfaceConfigInfo: Router Manager called us with NULL size"); <br> <br>        TraceLeave("GetInterfaceConfigInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br> <br>    if(pIf == NULL) <br>    { <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        Trace1(ERR, <br>               "GetInterfaceConfigInfo: Interface %d does not exist", <br>               dwIndex); <br> <br>        TraceLeave("GetInterfaceConfigInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    if(*pdwSize &lt; SIZEOF_PROTO_IF_INFO(pIf-&gt;ulNumBindings)) <br>    { <br>        *pdwSize = SIZEOF_PROTO_IF_INFO(pIf-&gt;ulNumBindings); <br> <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br> <br>        TraceLeave("GetInterfaceConfigInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INSUFFICIENT_BUFFER; <br>    } <br> <br>    *pdwSize = SIZEOF_PROTO_IF_INFO(pIf-&gt;ulNumBindings); <br>     <br>    if(pvConfig == NULL) <br>    { <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        Trace0(ERR, <br>               "GetInterfaceConfigInfo: Router Manager called us with NULL config buffer"); <br> <br>        TraceLeave("GetInterfaceConfigInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    // <br>    // So we have a good buffer of the right size <br>    // Copy out the info <br>    // <br> <br>             <br>    pIfInfo = (PSAMPLE_PROTOCOL_INTERFACE_INFO)pvConfig; <br> <br>    pIfInfo-&gt;ulNumBindings = pIf-&gt;ulNumBindings; <br> <br>    for(pleNode  = pIf-&gt;leInternalIfHead.Flink, i = 0; <br>        pleNode != &amp;pIf-&gt;leInternalIfHead; <br>        pleNode  = pleNode-&gt;Flink, i++) <br>    { <br>        pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br> <br>        pIfInfo-&gt;rgbiInfo[i].dwAddress  = pBind-&gt;dwAddress; <br>        pIfInfo-&gt;rgbiInfo[i].dwMask     = pBind-&gt;dwMask; <br>        pIfInfo-&gt;rgbiInfo[i].bEnabled   = pBind-&gt;bEnabled; <br>    } <br> <br>    ASSERT(i == pIf-&gt;ulNumBindings); <br> <br>    // <br>    // If we had only one address we will return 0.0.0.0 as the address <br>    // even if we know what the current address is <br>    // <br>     <br>    if(pIf-&gt;ulNumBindings == 1) <br>    { <br>        pIfInfo-&gt;rgbiInfo[0].dwAddress  = 0x00000000; <br>        pIfInfo-&gt;rgbiInfo[0].dwMask     = 0x00000000; <br>    } <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br> <br>    TraceLeave("GetInterfaceConfigInfo"); <br> <br>    ExitProtocolApi(); <br> <br>    return NO_ERROR; <br>} <br> <br>DWORD <br>APIENTRY <br>SetInterfaceConfigInfo( <br>    IN DWORD dwIndex, <br>    IN PVOID pvConfig <br>    ) <br>/*++ <br>  Routine Description <br> <br>   <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF      pIf; <br>     <br>    PSAMPLE_PROTOCOL_INTERFACE_INFO pIfInfo; <br> <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("SetInterfaceConfigInfo"); <br>     <br>    if(pvConfig == NULL) <br>    { <br>        // <br>        // A NULL config means no change <br>        // <br>         <br>        TraceLeave("SetInterfaceConfigInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return NO_ERROR; <br>    } <br> <br>    pIfInfo = (PSAMPLE_PROTOCOL_INTERFACE_INFO)pvConfig; <br> <br>    if(!ValidateInterfaceInfo(pIfInfo)) <br>    { <br>        TraceLeave("SetInterfaceConfigInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_DATA; <br>    } <br> <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br> <br>    if(pIf == NULL) <br>    { <br>        Trace1(ERR, <br>               "SetInterfaceConfigInfo: Interface %d does not exist", <br>               dwIndex); <br> <br>        TraceLeave("SetInterfaceConfigInfo"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    // <br>    // Do what needs to be done with the info <br>    // <br>     <br> <br>    return NO_ERROR; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>BindInterface( <br>    IN DWORD dwIndex, <br>    IN PVOID pBinding <br>    ) <br>/*++ <br>  Routine Description <br>      Called by the IP Router Manager once it learns the address(es) on an <br>      interface.  This may happen as soon as the router starts (after the <br>      interface is added, ofcourse) when the interface has a static address <br>      or may happen when an interface acquires a DHCP address or may happen <br>      when IPCP acquire the address for a dial up link <br>      The binding may consist of one or more addresses.  We walk the addresses <br>      given and find the corresponding block in our config.  We then update <br>      any information and if the interface has been enabled, we activate the <br>      binding, i.e. begin running on it. <br> <br>  Arguments <br>      dwIndex   Index of the interface in question <br>      pBinding  Pointer to IP_ADAPTER_BINDING_INFO containing info about <br>                the addresses on the interface <br> <br>  Return Value <br>      ERROR_INVALID_PARAMETER <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF      pIf; <br>    PLIST_ENTRY pleNode; <br>    PINTRNL_IF  pBind; <br>    ULONG       i; <br>    DWORD       dwResult; <br>     <br>    PIP_ADAPTER_BINDING_INFO pBindingInfo; <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("BindInterface"); <br>     <br>    if(pBinding == NULL) <br>    { <br>        Trace0(ERR, <br>               "BindInterface: Router Manager called us with NULL binding"); <br> <br>        TraceLeave("BindInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    pBindingInfo = (PIP_ADAPTER_BINDING_INFO)pBinding; <br> <br>    if(pBindingInfo-&gt;NumAddresses &lt; 1) <br>    { <br>        Trace0(ERR, <br>               "BindInterface: Router Manager called us with NO binding"); <br> <br>        TraceLeave("BindInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br> <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br> <br>    if(pIf == NULL) <br>    { <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        Trace1(ERR, <br>               "BindInterface: Interface %d does not exist", <br>               dwIndex); <br> <br>        TraceLeave("BindInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    if(IsNtBound(pIf)) <br>    { <br>        // <br>        // Can not receive two bind notifications without an <br>        // Unbind in the middle <br>        // <br> <br>        Trace1(ERR, <br>               "BindInterface: Interface %S is already bound", <br>               pIf-&gt;pwszIfName); <br> <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br> <br>        TraceLeave("BindInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br>         <br>    SetNtBound(pIf); <br>     <br>    for(i = 0; i &lt; pBindingInfo-&gt;NumAddresses; i++) <br>    { <br>        pBind = GetBindingGivenAddress(pIf, <br>                                       pBindingInfo-&gt;Address[i].IPAddress); <br> <br>        if(pBind == NULL) <br>        { <br>            // <br>            // Our config is bad, we will try and go through all the blocks <br>            // and see if we can atleast bind on the others. <br>            // <br> <br>            Trace3(ERR, <br>                   "BindInterface: Couldnt find config block for %d.%d.%d.%d/%d.%d.%d.%d over %S", <br>                   PRINT_ADDRESS(pBindingInfo-&gt;Address[i].IPAddress), <br>                   PRINT_ADDRESS(pBindingInfo-&gt;Address[i].Mask), <br>                   pIf-&gt;pwszIfName); <br> <br>            continue; <br>        } <br> <br>        if(pBindingInfo-&gt;NumAddresses == 1) <br>        { <br>            // <br>            // If we have only one address, then the addresses <br>            // may not match, so update them <br>            // <br>             <br>            pBind-&gt;dwAddress = pBindingInfo-&gt;Address[i].IPAddress; <br>            pBind-&gt;dwMask    = pBindingInfo-&gt;Address[i].Mask; <br>        } <br>    } <br> <br>#if DBG <br> <br>    // <br>    // Check to make sure we got bindings for all the configured addresses <br>    // <br> <br>    if(pIf-&gt;ulNumBindings &gt; 1) <br>    { <br>        for(pleNode  = pIf-&gt;leInternalIfHead.Flink; <br>            pleNode != &amp;pIf-&gt;leInternalIfHead; <br>            pleNode  = pleNode-&gt;Flink) <br>        { <br>            bFound = FALSE; <br> <br>            pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br>             <br>            for(i = 0; i &lt; pBindingInfo-&gt;NumAddresses; i++) <br>            { <br>                if(pBind-&gt;dwAddress == pBindingInfo-&gt;Address[i].IPAddress) <br>                { <br>                    ASSERT(pBind-&gt;dwMask == pBindingInfo-&gt;Address[i].Mask); <br> <br>                    bFound = TRUE; <br>                    break; <br>                } <br>            } <br> <br>            if(!bFound) <br>            { <br>                Trace3(ERR, <br>                       "BindInterface: Binding not indicated for %d.%d.%d.%d/%d.%d.%d.%d over %S", <br>                       PRINT_ADDRESS(pBind-&gt;dwAddress), <br>                       PRINT_ADDRESS(pBind-&gt;dwMask), <br>                       pIf-&gt;pwszIfName); <br>            } <br>        } <br>    } <br>     <br>#endif // DBG <br>     <br> <br>    // <br>    // OK now we have the bindings all set up <br>    // <br> <br>    if(IsNtEnabled(pIf)) <br>    { <br>        // <br>        // So the interface is bound and enabled =&gt; we are all set <br>        // to go <br>        // <br>         <br>        for(pleNode  = pIf-&gt;leInternalIfHead.Flink; <br>            pleNode != &amp;pIf-&gt;leInternalIfHead; <br>            pleNode  = pleNode-&gt;Flink) <br>        { <br>            pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br> <br>            if(pBind-&gt;bEnabled) <br>            { <br>                // <br>                // Our config tells us that we are enabled for this address <br>                // <br> <br>                ASSERT(pBind-&gt;dwState != BINDING_UP); <br>                 <br>                // <br>                // This will set the state to BINDING_UP <br>                // <br> <br>                dwResult = ActivateBinding(pBind); <br>                 <br>                if(dwResult != NO_ERROR) <br>                { <br>                    Trace2(ERR, <br>                           "BindInterface: Unable to activate %d.%d.%d.%d over %S", <br>                           PRINT_ADDRESS(pBind-&gt;dwAddress), <br>                           pIf-&gt;pwszIfName); <br>                } <br>            } <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br>     <br>    TraceLeave("BindInterface"); <br> <br>    ExitProtocolApi(); <br> <br>    return NO_ERROR; <br>} <br> <br>DWORD <br>APIENTRY <br>UnBindInterface( <br>    IN DWORD dwIndex <br>    ) <br>/*++ <br>  Routine Description <br>      Called when the interface loses its IP Address(es). This may <br>      happen when the interface is shutting down. It may be because an <br>      admin Disabled the interface with IP (as opposed to just disabling <br>      or protocol on the interface). It can happen when the admin releases <br>      a DHCP acquired interface or when a dial up link disconnects <br>      We see if we were running on the binding and if so, we shut it down. <br>      We dont release any memory associated with the binding because <br>      we can get bound again <br> <br>  Arguments <br>      dwIndex   The index of the interface being unbound <br> <br>  Return Value <br>      ERROR_INVALID_PARAMETER <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF      pIf; <br>    PLIST_ENTRY pleNode; <br>    PINTRNL_IF  pBind; <br>    DWORD       dwResult; <br>     <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("UnbindInterface"); <br>     <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br> <br>    if(pIf == NULL) <br>    { <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        Trace1(ERR, <br>               "UnbindInterface: Interface %d does not exist", <br>               dwIndex); <br> <br>        TraceLeave("UnbindInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    if(!IsNtBound(pIf)) <br>    { <br>        // <br>        // Nothing new happening <br>        // <br>         <br>        Trace1(INTF, <br>               "UnbindInterface: Unbind received for %S which was never bound", <br>               pIf-&gt;pwszIfName); <br> <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        TraceLeave("UnbindInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return NO_ERROR; <br>    } <br>     <br>    ClearNtBound(pIf); <br> <br>    if(IsNtEnabled(pIf)) <br>    { <br>        // <br>        // Since it is enabled and was bound, deactivate the <br>        // bindings <br>        // <br>         <br>        for(pleNode  = pIf-&gt;leInternalIfHead.Flink; <br>            pleNode != &amp;pIf-&gt;leInternalIfHead; <br>            pleNode  = pleNode-&gt;Flink) <br>        { <br>            pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br> <br>            if(pBind-&gt;dwState == BINDING_UP) <br>            { <br>                // <br>                // This binding had been successfully activated <br>                // <br>                 <br>                dwResult = DeactivateBinding(pBind); <br>                 <br>                if(dwResult != NO_ERROR) <br>                { <br>                    Trace2(ERR, <br>                           "UnbindInterface: Unable to deactivate %d.%d.%d.%d over %S", <br>                           PRINT_ADDRESS(pBind-&gt;dwAddress), <br>                           pIf-&gt;pwszIfName); <br>                } <br>            } <br>        } <br> <br>        if(pIf-&gt;ulNumBindings == 1) <br>        { <br>            // <br>            // Clear out the old address <br>            // <br> <br>            pBind = CONTAINING_RECORD(pIf-&gt;leInternalIfHead.Flink, <br>                                      INTRNL_IF, <br>                                      leInternalIfLink); <br> <br>            pBind-&gt;dwAddress = 0x00000000; <br>            pBind-&gt;dwMask    = 0x00000000; <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br>     <br>    TraceLeave("UnbindInterface"); <br> <br>    ExitProtocolApi(); <br> <br>    return NO_ERROR; <br>     <br>} <br> <br> <br>DWORD <br>APIENTRY <br>EnableInterface( <br>    IN DWORD dwIndex <br>    ) <br>/*++ <br>  Routine Description <br>      An interface comes up in a DISABLED state. This function is <br>      called by the router manager to enable the interface.  It can also <br>      be called when the interface is being reenabled after being disabled <br>      by the admin <br>      The bindings on an interface are kept across and Enable-Disable, so <br>      we heck to see if we were already bound, and if so we activate the <br>      protocol over the bindings. <br> <br>  Arguments <br>      dwIndex   Interface to be enabled <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF      pIf; <br>    PLIST_ENTRY pleNode; <br>    PINTRNL_IF  pBind; <br>    DWORD       dwResult; <br>     <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("EnableInterface"); <br>     <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br> <br>    if(pIf == NULL) <br>    { <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        Trace1(ERR, <br>               "EnableInterface: Interface %d does not exist", <br>               dwIndex); <br> <br>        TraceLeave("EnableInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    if(IsNtEnabled(pIf)) <br>    { <br>        // <br>        // Nothing new happening <br>        // <br>         <br>        Trace1(INTF, <br>               "EnableInterface: Enable received for %S which is already enabled", <br>               pIf-&gt;pwszIfName); <br> <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        TraceLeave("EnableInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return NO_ERROR; <br>    } <br>     <br>    SetNtEnabled(pIf); <br> <br>    if(IsNtBound(pIf)) <br>    { <br>        // <br>        // Since it is enabled and bound, activate the bindings <br>        // <br>         <br>        for(pleNode  = pIf-&gt;leInternalIfHead.Flink; <br>            pleNode != &amp;pIf-&gt;leInternalIfHead; <br>            pleNode  = pleNode-&gt;Flink) <br>        { <br>            pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br> <br>            ASSERT(pBind-&gt;dwState == BINDING_DOWN); <br>             <br>            if(pBind-&gt;bEnabled) <br>            { <br>                dwResult = ActivateBinding(pBind); <br>                 <br>                if(dwResult != NO_ERROR) <br>                { <br>                    Trace2(ERR, <br>                           "EnableInterface: Unable to activate %d.%d.%d.%d over %S", <br>                           PRINT_ADDRESS(pBind-&gt;dwAddress), <br>                           pIf-&gt;pwszIfName); <br>                } <br>            } <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>    TraceLeave("EnableInterface"); <br>     <br>    ExitProtocolApi(); <br>     <br>    return NO_ERROR; <br>} <br> <br> <br>DWORD <br>APIENTRY <br>DisableInterface( <br>    IN DWORD dwIndex <br>    ) <br>/*++ <br>  Routine Description <br>      Called by the IP Router Manger to disable an interface.  This is <br>      usually in response to an admin setting the AdminStatus in IP to DOWN. <br>      This is different from an admin just disabling the bEnabled flag in our <br>      config because that is opaque to IP. That is a routing protocol specific <br>      disable and is conveyed to us via SetInterfaceConfig() calls.  THIS IS <br>      AN IMPORTANT DISTINCTION. A ROUTING PROTOCOL NEEDS TO MANTAIN TWO STATES - <br>      AN NT STATE AND A PROTOCOL SPECIFIC STATE. <br>       <br> <br>  Arguments <br>      dwIndex   The index of the interface to disable <br> <br>  Return Value <br>      ERROR_INVALID_PARAMETER <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PNT_IF      pIf; <br>    PLIST_ENTRY pleNode; </code></pre>
<p>
</p>
<pre><code>PINTRNL_IF  pBind; <br>    DWORD       dwResult; <br>     <br>     <br>    EnterProtocolApi(); <br> <br>    TraceEnter("DisableInterface"); <br>     <br>    EnterCriticalSection(&amp;g_csIfListLock); <br> <br>    pIf = GetIfBlockGivenIndex(dwIndex); <br> <br>    if(pIf == NULL) <br>    { <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        Trace1(ERR, <br>               "DisableInterface: Interface %d does not exist", <br>               dwIndex); <br> <br>        TraceLeave("DisableInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    if(!IsNtEnabled(pIf)) <br>    { <br>        // <br>        // Nothing new happening <br>        // <br>         <br>        Trace1(INTF, <br>               "DisableInterface: Disable received for %S which was never enabled", <br>               pIf-&gt;pwszIfName); <br> <br>        LeaveCriticalSection(&amp;g_csIfListLock); <br>         <br>        TraceLeave("DisableInterface"); <br> <br>        ExitProtocolApi(); <br> <br>        return NO_ERROR; <br>    } <br>     <br>    ClearNtEnabled(pIf); <br> <br>    if(IsNtBound(pIf)) <br>    { <br>        // <br>        // Since it was enabled and is bound, it must have been <br>        // activated, so deactivate the bindings now <br>        // <br>         <br>        for(pleNode  = pIf-&gt;leInternalIfHead.Flink; <br>            pleNode != &amp;pIf-&gt;leInternalIfHead; <br>            pleNode  = pleNode-&gt;Flink) <br>        { <br>            pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink); <br> <br>            if(pBind-&gt;dwState == BINDING_UP) <br>            { <br>                // <br>                // This binding had been successfully activated <br>                // <br>                 <br>                dwResult = DeactivateBinding(pBind); <br>                 <br>                if(dwResult != NO_ERROR) <br>                { <br>                    Trace2(ERR, <br>                           "DisableInterface: Unable to deactivate %d.%d.%d.%d over %S", <br>                           PRINT_ADDRESS(pBind-&gt;dwAddress), <br>                           pIf-&gt;pwszIfName); <br>                } <br>            } <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;g_csIfListLock); <br>     <br>    TraceLeave("DisableInterface"); <br> <br>    ExitProtocolApi(); <br> <br>    return NO_ERROR; <br>     <br>} <br> <br> <br>BOOL <br>ValidateInterfaceInfo( <br>    PSAMPLE_PROTOCOL_INTERFACE_INFO pInfo <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br> <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    return TRUE; <br>} <br> <br>PNT_IF <br>GetIfBlockGivenIndex( <br>    DWORD   dwIndex <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br>      Assumes the IF List lock is held <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    PLIST_ENTRY pleNode; <br>    PNT_IF      pIf; <br> <br>     <br>    for(pleNode  = g_leIfListHead.Flink; <br>        pleNode != &amp;g_leIfListHead; <br>        pleNode  = pleNode-&gt;Flink) <br>    { <br>        pIf = CONTAINING_RECORD(pleNode, <br>                                NT_IF, <br>                                leNtIfLink); <br> <br>        if(pIf-&gt;dwNtIndex == dwIndex) <br>        { <br>            return pIf; <br>        } <br> <br>        if(pIf-&gt;dwNtIndex &gt; dwIndex) <br>        { <br>            // <br>            // Since the list is ordered, we wont find this further on <br>            // <br> <br>            return NULL; <br>        } <br>    } <br> <br>    return NULL; <br>} <br> <br>PINTRNL_IF <br>GetBindingGivenAddress( <br>    PNT_IF pIf, <br>    DWORD dwAddress <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br>      Assumes the IF List lock is held <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>     <br>    return NULL; <br>} <br> <br>DWORD <br>ActivateBinding( <br>    PINTRNL_IF  pBind <br>    ) <br>/*++ <br>  Routine Description <br>      Called when the interface needs to be brought up on this Address <br>      We create a socket and fire it off <br>       <br>  Locks <br>      Assumes the IF List lock is held <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    DWORD   dwResult; <br>     <br>    ASSERT(pBind-&gt;dwState == BINDING_DOWN); <br>    ASSERT(pBind-&gt;sSocket == INVALID_SOCKET); <br> <br>    ASSERT(pBind-&gt;dwAddress != 0x00000000); <br>    ASSERT(pBind-&gt;dwMask    != 0x00000000); <br> <br>    dwResult = CreateSocket(pBind-&gt;dwAddress, <br>                            &amp;pBind-&gt;sSocket); <br> <br>    if(dwResult == NO_ERROR) <br>    { <br>        pBind-&gt;dwState = BINDING_UP; <br>    } <br>     <br>    return dwResult; <br>} <br> <br>DWORD <br>DeactivateBinding( <br>    PINTRNL_IF  pBind <br>    ) <br>/*++ <br>  Routine Description <br> <br> <br>  Locks <br>      Assumes the IF List lock is held <br> <br>  Arguments <br> <br> <br>  Return Value <br>      NO_ERROR <br> <br>--*/ <br>{ <br>    ASSERT(pBind-&gt;dwState == BINDING_UP); <br>    ASSERT(pBind-&gt;sSocket != INVALID_SOCKET); <br> <br>    ASSERT(pBind-&gt;dwAddress != 0x00000000); <br>    ASSERT(pBind-&gt;dwMask    != 0x00000000); <br> <br>    if(WSAEventSelect(pBind-&gt;sSocket, <br>                      (WSAEVENT)NULL, <br>                      0) == SOCKET_ERROR) <br>    { <br>        Trace2(ERR, <br>               "DeactivateBinding: Error %d clearing socket (%d.%d.%d.%d) association with event", <br>               WSAGetLastError(), <br>               PRINT_ADDRESS(pBind-&gt;dwAddress)); <br> <br>    } <br>     <br>    closesocket(pBind-&gt;sSocket); <br> <br>    pBind-&gt;sSocket = INVALID_SOCKET; <br> <br>    return NO_ERROR; <br>} <br> <br> <br>DWORD <br>CreateSocket( <br>    IN  DWORD   dwAddress, <br>    OUT SOCKET  *psSocket  <br>    ) <br>/*++ <br>  Routine Description <br>     Activates router discovery messages on an interface. The interface must already <br>     be bound <br> <br>  Locks    <br>     ICB_LIST lock must be held as WRITER <br> <br>  Arguments <br>      picb          The ICB of the interface to activate <br> <br>  Return Value <br>      NO_ERROR or some error code  <br>--*/ <br>{ <br>    DWORD           dwResult, dwBytesReturned; <br>    LINGER          lLinger; <br>    BOOL            bOption, bLoopback; <br>    SOCKADDR_IN     sinSockAddr; <br>    INT             iScope; <br>     <br>    TraceEnter("CreateSocket"); <br>     <br>    // <br>    // Create the sockets for the interface <br>    // <br>     <br>    *psSocket = INVALID_SOCKET; <br>     <br>    do <br>    { <br>        *psSocket = WSASocket(AF_INET, <br>                              SOCK_RAW, <br>                              SAMPLE_PROTOCOL_IP_ID, <br>                              NULL, <br>                              0, <br>                              WSA_FLAG_MULTIPOINT_C_LEAF|WSA_FLAG_MULTIPOINT_D_LEAF); <br>         <br>        if(*psSocket == INVALID_SOCKET) <br>        { <br>            dwResult = WSAGetLastError(); <br>         <br>            Trace2(ERR, <br>                   "CreateSocket Couldnt create socket on %d.%d.%d.%d . Error %d", <br>                   PRINT_ADDRESS(dwAddress), <br>                   dwResult); <br>             <br>            break; <br>        } <br> <br>        // <br>        // Set SO_LINGER to off <br>        // <br> <br>        lLinger.l_onoff  = 0; <br>        lLinger.l_linger = 0; <br>         <br>        if(setsockopt(*psSocket, <br>                      SOL_SOCKET, <br>                      SO_LINGER,    <br>                      (const char *)&amp;lLinger, <br>                      sizeof(LINGER)) == SOCKET_ERROR) <br>        { <br>            Trace2(ERR, <br>                   "CreateSocket: Couldnt set linger option on %d.%d.%d.%d - continuing. Error %d", <br>                   PRINT_ADDRESS(dwAddress), <br>                   WSAGetLastError()); <br>        } <br> <br>         <br>        // <br>        // Set to SO_REUSEADDR <br>        // <br>         <br>        bOption = TRUE; <br>         <br>        if(setsockopt(*psSocket, <br>                      SOL_SOCKET, <br>                      SO_REUSEADDR, <br>                      (const char FAR*)&amp;bOption, <br>                      sizeof(BOOL)) == SOCKET_ERROR) <br>        { <br>            Trace2(ERR, <br>                   "CreateSocket: Couldnt set reuse option on %d.%d.%d.%d - continuing. Error %d", <br>                   PRINT_ADDRESS(dwAddress), <br>                   WSAGetLastError()); <br>        } <br>         <br>        if(WSAEventSelect(*psSocket, <br>                          (WSAEVENT)g_hSocketEvent, <br>                          FD_READ) == SOCKET_ERROR) <br>        { <br>            dwResult = WSAGetLastError(); <br>             <br>            Trace2(ERR, <br>                   "CreateSocket: WSAEventSelect() failed for socket on %d.%d.%d.%d.Error %d", <br>                   PRINT_ADDRESS(dwAddress), <br>                   dwResult); <br>             <br>            closesocket(*psSocket); <br> <br>            *psSocket = INVALID_SOCKET; <br>             <br>            break; <br>        } <br>             <br>        // <br>        // Bind to the addresses on the interface <br>        // <br>         <br>        sinSockAddr.sin_family      = AF_INET; <br>        sinSockAddr.sin_addr.s_addr = dwAddress; <br>        sinSockAddr.sin_port        = 0; <br>         <br>        if(bind(*psSocket, <br>                (const struct sockaddr FAR*)&amp;sinSockAddr, <br>                sizeof(SOCKADDR_IN)) == SOCKET_ERROR) <br>        { <br>            dwResult = WSAGetLastError(); <br>             <br>            Trace2(ERR, <br>                   "CreateSocket: Couldnt bind to %d.%d.%d.%d.  Error %d", <br>                   PRINT_ADDRESS(dwAddress), <br>                   dwResult); <br>             <br>            closesocket(*psSocket); <br> <br>            *psSocket = INVALID_SOCKET; <br>             <br>            break; <br>        } <br>         <br>        // <br>        // Set scope/TTL to 1 since we always multicast the responses <br>        // Also set Loopback to ignore self generated packets. Loopback <br>        // d==card doesnt work currently on NT, so we still have code to <br>        // filter our own multicasts in the receive path <br>        // <br>         <br>        bLoopback   = FALSE; <br>         <br>        dwResult = WSAIoctl(*psSocket, <br>                            SIO_MULTIPOINT_LOOPBACK, <br>                            (PVOID)&amp;bLoopback, <br>                            sizeof(BOOL), <br>                            NULL, <br>                            0, <br>                            &amp;dwBytesReturned, <br>                            NULL, <br>                            NULL); <br> <br>        if(dwResult == SOCKET_ERROR) <br>        { <br>            Trace2(ERR, <br>                   "CreateSocket: Error %d setting loopback to FALSE on %d.%d.%d.%d", <br>                   WSAGetLastError(), <br>                   PRINT_ADDRESS(dwAddress)); <br>        } <br> <br>        iScope  = 1; <br>         <br>        dwResult = WSAIoctl(*psSocket, <br>                            SIO_MULTICAST_SCOPE, <br>                            (PVOID)&amp;iScope, <br>                            sizeof(INT), <br>                            NULL, <br>                            0, <br>                            &amp;dwBytesReturned, <br>                            NULL, <br>                            NULL); <br> <br>        if(dwResult == SOCKET_ERROR) <br>        { <br>            Trace2(ERR, <br>                   "CreateSocket: Error %d setting multicast scope to 1 on %d.%d.%d.%d", <br>                   WSAGetLastError(), <br>                   PRINT_ADDRESS(dwAddress)); <br>        } <br>         <br> <br>        // <br>        // Join the multicast session on SAMPLE_PROTOCOL_MULTICAST_GROUP1 <br>        // <br> <br>        sinSockAddr.sin_family      = AF_INET; <br>        sinSockAddr.sin_addr.s_addr = SAMPLE_PROTOCOL_MULTICAST_GROUP1; <br>        sinSockAddr.sin_port        = 0; <br>         <br>        if(WSAJoinLeaf(*psSocket, <br>                       (const struct sockaddr FAR*)&amp;sinSockAddr, <br>                       sizeof(SOCKADDR_IN), <br>                       NULL, <br>                       NULL, <br>                       NULL, <br>                       NULL, <br>                       JL_BOTH) == INVALID_SOCKET) <br>        { <br>            dwResult = WSAGetLastError(); <br>             <br>            Trace2(ERR, <br>                   "CreateSocket: Couldnt join multicast group1 on socket for %d.%d.%d.%d. Error %d", <br>                   PRINT_ADDRESS(dwAddress), <br>                   dwResult); <br>             <br>            closesocket(*psSocket); <br> <br>            *psSocket = INVALID_SOCKET; <br>             <br>            break; <br>        } <br> <br>        // <br>        // Join the multicast session on SAMPLE_PROTOCOL_MULTICAST_GROUP2 <br>        // <br> <br>        sinSockAddr.sin_family      = AF_INET; <br>        sinSockAddr.sin_addr.s_addr = SAMPLE_PROTOCOL_MULTICAST_GROUP2; <br>        sinSockAddr.sin_port        = 0; <br>         <br>        if(WSAJoinLeaf(*psSocket, <br>                       (const struct sockaddr FAR*)&amp;sinSockAddr, <br>                       sizeof(SOCKADDR_IN), <br>                       NULL, <br>                       NULL, <br>                       NULL, <br>                       NULL, <br>                       JL_BOTH) == INVALID_SOCKET) <br>        { <br>            dwResult = WSAGetLastError(); <br>             <br>            Trace2(ERR, <br>                   "CreateSocket: Couldnt join multicast group2 on socket on %d.%d.%d.%d. Error %d", <br>                   PRINT_ADDRESS(dwAddress), <br>                   dwResult); <br> <br>            closesocket(*psSocket); <br> <br>            *psSocket = INVALID_SOCKET; <br>             <br>            break; <br>        } <br>         <br>    }while(FALSE); <br>     <br>    TraceLeave("CreateSocket"); <br>         <br>    return dwResult; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
