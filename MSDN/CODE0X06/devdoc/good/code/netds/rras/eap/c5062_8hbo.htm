<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5064"></a>EAP.C</h2>
<pre><code>/********************************************************************/ <br>/**          Copyright(c) 1985-1997 Microsoft Corporation.         **/ <br>/********************************************************************/ <br> <br>//*** <br>// <br>// Filename:    eap.c <br>// <br>// Description: Sample Extensible Authentication Protocol. <br>//              Here is a graphic of the EAP sample protocol: <br>// <br>// <br>//      Authenticator                       Authenticatee <br>//      -------------                       ------------- <br>// <br>//                      "Send Password" <br>//                  ----------------------&gt; <br>//                        EAP Request <br>// <br>//                        &lt;password&gt; <br>//                  &lt;---------------------- <br>//                        EAP Response <br>// <br>//   <br>//                  -----------------------&gt; <br>//                       Success/Failure <br>// <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winuser.h&gt; <br>#include &lt;lmcons.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;rasauth.h&gt; <br>#include &lt;raseapif.h&gt; <br>#include &lt;raserror.h&gt; <br>#define SDEBUGGLOBALS <br>#define RASEAPGLOBALS <br>#include "eap.h" <br> <br>/*--------------------------------------------------------------------------- <br>** External entry points <br>**--------------------------------------------------------------------------- <br>*/ <br> <br>BOOL <br>RasEapDllEntry( <br>    IN HANDLE hinstDll, <br>    IN DWORD  fdwReason, <br>    IN LPVOID lpReserved  <br>) <br>    // <br>    // This routine is called by the system on various events such as the <br>    // process attachment and detachment.  See Win32 DllEntryPoint <br>    // documentation. <br>    // <br>    // Returns TRUE if successful, FALSE otherwise. <br>    // <br>{ <br>    switch ( fdwReason ) <br>    { <br>        case DLL_PROCESS_ATTACH: <br>        { <br>            DisableThreadLibraryCalls( hinstDll ); <br> <br>            break; <br>        } <br> <br>        case DLL_PROCESS_DETACH: <br>        { <br>            break; <br>        } <br>    } <br> <br>    return( TRUE ); <br>} <br> <br> <br>DWORD APIENTRY <br>RasEapGetInfo ( <br>    IN  DWORD         dwEapTypeId, <br>    OUT PPP_EAP_INFO* pInfo  <br>) <br>    // <br>    // RasEapGetInfo entry point called by the EAP-PPP engine by name.   <br>    // <br>{ <br>    if ( dwEapTypeId != PPP_EAP_PROTOCOL_ID ) <br>    { <br>        // <br>        // We only support PPP_EAP_PROTOCOL_ID eap type <br>        // <br> <br>        return( ERROR_NOT_SUPPORTED ); <br>    } <br> <br>    ZeroMemory( pInfo, sizeof( PPP_EAP_INFO ) ); <br> <br>    // <br>    // Fill in the required information <br>    // <br> <br>    pInfo-&gt;dwEapTypeId       = PPP_EAP_PROTOCOL_ID; <br>    pInfo-&gt;RasEapBegin       = EapBegin; <br>    pInfo-&gt;RasEapEnd         = EapEnd; <br>    pInfo-&gt;RasEapMakeMessage = EapMakeMessage; <br> <br>    return( NO_ERROR ); <br>} <br> <br> <br>DWORD APIENTRY <br>EapBegin( <br>    OUT VOID** ppWorkBuf, <br>    IN  VOID*  pInfo  <br>) <br>    // <br>    // EapBegin entry point called by the EAP PPP engine thru the passed <br>    // address. <br>    // <br>{ <br>    PPP_EAP_INPUT* pInput = (PPP_EAP_INPUT* )pInfo; <br>    EAPCB*         pwb; <br> <br>    // <br>    // Allocate work buffer. <br>    // <br> <br>    if ( ( pwb = (EAPCB* )LocalAlloc( LPTR, sizeof( EAPCB ) ) ) == NULL ) <br>    { <br>        return( ERROR_NOT_ENOUGH_MEMORY ); <br>    } <br> <br>    // <br>    // Save information passed in, will be used later <br>    // <br> <br>    pwb-&gt;fAuthenticator     = pInput-&gt;fAuthenticator; <br>    pwb-&gt;EapState           = MYSTATE_Initial; <br>    pwb-&gt;hPort              = pInput-&gt;hPort; <br>    FpRasAuthenticateClient = pInput-&gt;RasAuthenticateClient; <br> <br>    // <br>    // Save the identity. On the authenticatee side, this is obtained by user <br>    // input, on the authenticator side this was obtained by the Identity <br>    // request message. <br>    // <br> <br>    strcpy( pwb-&gt;szIdentity, pInput-&gt;pszIdentity ); <br> <br>    // <br>    // If we are an authenticatee, then use the password passed in <br>    // <br> <br>    if ( !pwb-&gt;fAuthenticator ) <br>    { <br>        strcpy( pwb-&gt;szPassword, pInput-&gt;pszPassword ); <br>    } <br> <br>    // <br>    // Register work buffer with engine. <br>    // <br> <br>    *ppWorkBuf = pwb; <br> <br>    return( NO_ERROR ); <br>} <br> <br> <br>DWORD APIENTRY <br>EapEnd( <br>    IN VOID* pWorkBuf  <br>) <br>    // <br>    // EapEnd entry point called by the PPP engine thru the passed address. <br>    // See EAP interface documentation. <br>    // <br>{ <br>    if ( pWorkBuf != NULL ) <br>    { <br>        // <br>        // Release all resources used by this authentication session. <br>        // <br> <br>        EAPCB * pwb = ( EAPCB *)pWorkBuf; <br> <br>        if ( pwb-&gt;pUIContext != NULL ) <br>        { <br>            LocalFree( pwb-&gt;pUIContext ); <br>        } <br> <br>        ZeroMemory( pWorkBuf, sizeof(EAPCB) ); <br> <br>        LocalFree( pWorkBuf ); <br>    } <br> <br>    return( NO_ERROR ); <br>} <br> <br>DWORD APIENTRY <br>EapMakeMessage( <br>    IN  VOID*               pWorkBuf, <br>    IN  PPP_EAP_PACKET*     pReceiveBuf, <br>    OUT PPP_EAP_PACKET*     pSendBuf, <br>    IN  DWORD               cbSendBuf, <br>    OUT PPP_EAP_OUTPUT*     pResult, <br>    IN  PPP_EAP_INPUT*      pInput  <br>) <br>    // <br>    // RasEapMakeMessage entry point called by the PPP engine thru the passed <br>    // address.   <br>    // <br>{ <br>    EAPCB * pwb = (EAPCB* )pWorkBuf; <br> <br>    // <br>    // Call the appropriate routine to process the event. <br>    // <br> <br>    if ( pwb-&gt;fAuthenticator ) <br>    { <br>        return( AuthenticatorMakeMessage( pwb,  <br>                                          pReceiveBuf,   <br>                                          pSendBuf,  <br>                                          cbSendBuf,  <br>                                          pInput,  <br>                                          pResult ) ); <br>    } <br>    else <br>    { <br>        return( AuthenticateeMakeMessage( pwb,  <br>                                          pReceiveBuf,  <br>                                          pSendBuf,  <br>                                          cbSendBuf,  <br>                                          pInput,  <br>                                          pResult ) ); <br>    } <br>} <br> <br> <br>/*--------------------------------------------------------------------------- <br>** Internal routines  <br>**--------------------------------------------------------------------------- <br>*/ <br> <br>VOID <br>HostToWireFormat16( <br>    IN     WORD  wHostFormat, <br>    IN OUT PBYTE pWireFormat <br>) <br>{ <br>    // <br>    // Will convert a 16 bit integer from host format to wire format <br>    // <br> <br>    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(wHostFormat) &gt;&gt;  8); <br>    *((PBYTE)(pWireFormat)+1) = (BYTE) (wHostFormat); <br>} <br> <br>WORD <br>WireToHostFormat16( <br>    IN PBYTE pWireFormat <br>) <br>{ <br>    // <br>    // Will convert a 16 bit integer from wire format to host format <br>    // <br> <br>    WORD wHostFormat = ((*((PBYTE)(pWireFormat)+0) &lt;&lt; 8) + <br>                        (*((PBYTE)(pWireFormat)+1))); <br> <br>    return( wHostFormat ); <br>} <br> <br>DWORD <br>AuthenticateeMakeMessage( <br>    IN  EAPCB*            pwb, <br>    IN  PPP_EAP_PACKET*   pReceiveBuf, <br>    OUT PPP_EAP_PACKET*   pSendBuf, <br>    IN  DWORD             cbSendBuf, <br>    IN  PPP_EAP_INPUT*    pInput, <br>    OUT PPP_EAP_OUTPUT*   pResult <br>) <br>    // <br>    // Authenticatee side event handler <br>    // <br>{ <br>    DWORD dwRetCode = NO_ERROR; <br> <br>    switch( pwb-&gt;EapState ) <br>    { <br>        case MYSTATE_Initial: <br> <br>            // <br>            // Bring up interactive UI to notify user that he/she is being <br>            // authenticated via the sample EAP <br>            // <br> <br>            pResult-&gt;fInvokeInteractiveUI = TRUE; <br> <br>            pResult-&gt;dwSizeOfUIContextData = <br>                       strlen("You are being authenticated by a Sample EAP" )+1; <br> <br>            pResult-&gt;pUIContextData = LocalAlloc( <br>                                              LPTR, <br>                                              pResult-&gt;dwSizeOfUIContextData); <br> <br>            if ( pResult-&gt;pUIContextData == NULL ) <br>            { <br>                return( ERROR_NOT_ENOUGH_MEMORY ); <br>            } <br> <br>            strcpy( pResult-&gt;pUIContextData, <br>                    "You are being authenticated by a Sample EAP"  ); <br> <br>            pwb-&gt;pUIContext = pResult-&gt;pUIContextData; <br> <br>            pwb-&gt;EapState = MYSTATE_WaitForUserOK; <br> <br>            break; <br> <br>        case MYSTATE_WaitForUserOK: <br> <br>            // <br>            // Wait for response from user <br>            // <br> <br>            if ( pInput-&gt;fDataReceivedFromInteractiveUI ) <br>            { <br>                if ( pwb-&gt;pUIContext != NULL ) <br>                { <br>                    LocalFree( pwb-&gt;pUIContext ); <br> <br>                    pwb-&gt;pUIContext = NULL; <br>                } <br> <br>                // <br>                // If user doesn't like this, then we hangup the line <br>                // <br> <br>                if ( pInput-&gt;dwSizeOfDataFromInteractiveUI != (strlen("OK")+1) ) <br>                { <br>                    dwRetCode = ERROR_ACCESS_DENIED; <br> <br>                    break; <br>                } <br> <br>                if (  strcmp( pInput-&gt;pDataFromInteractiveUI, "OK" ) != 0 ) <br>                { <br>                    dwRetCode = ERROR_ACCESS_DENIED; <br> <br>                    break; <br>                } <br> <br>                pwb-&gt;EapState = MYSTATE_WaitForRequest; <br>            } <br>            else <br>            { <br>                // <br>                // Ignore all other events. <br>                // <br> <br>                pResult-&gt;Action = EAPACTION_NoAction; <br>            } <br> <br>            break; <br> <br>        case MYSTATE_WaitForRequest: <br> <br>            if ( pReceiveBuf != NULL ) <br>            { <br>                // <br>                // If we received a request packet from the server then we <br>                // process it. <br>                // <br> <br>                if ( pReceiveBuf-&gt;Code == EAPCODE_Request ) <br>                { <br>                    // <br>                    // Build the response packet <br>                    // <br> <br>                    MakeResponseMessage(pwb, pReceiveBuf, pSendBuf, cbSendBuf); <br>                     <br>                    // <br>                    // Response packets should not be sent with any timeout <br>                    // <br> <br>                    pResult-&gt;Action = EAPACTION_Send; <br> <br>                    // <br>                    // We are done so we change to MYSTATE_Done <br>                    // <br> <br>                    pwb-&gt;EapState = MYSTATE_Done; <br> <br>                    break; <br>                } <br>                else <br>                { <br>                    // <br>                    // We shouldn't get any other packet in this state so <br>                    // we simply drop this invalid packet <br>                    // <br> <br>                    pResult-&gt;Action = EAPACTION_NoAction; <br> <br>                    dwRetCode = ERROR_PPP_INVALID_PACKET; <br> <br>                    break; <br>                } <br>            } <br> <br>            break; <br> <br>        case MYSTATE_Done: <br>        { <br>            if ( pReceiveBuf == NULL ) <br>            { <br>                //   <br>                // If we did not receive a packet then we check to see if <br>                // the fSuccessPacketReceived flag is set <br>                // <br> <br>                if ( ( pInput != NULL ) &amp;&amp; ( pInput-&gt;fSuccessPacketReceived ) ) <br>                { <br>                    // <br>                    // We are done <br>                    // <br> <br>                    pResult-&gt;Action = EAPACTION_Done; <br>                    pwb-&gt;EapState   = MYSTATE_Done; <br>                } <br>                else <br>                { <br>                    // <br>                    // Otherwise we ignore this event <br>                    // <br> <br>                    pResult-&gt;Action = EAPACTION_NoAction; <br>                } <br> <br>                break; <br>            } <br> <br>            if ( ( pReceiveBuf-&gt;Code == EAPCODE_Success ) || <br>                 ( pReceiveBuf-&gt;Code == EAPCODE_Failure ) ) <br>            { <br>                // <br>                // If we received success or failure, we are done <br>                // <br> <br>                if ( pReceiveBuf-&gt;Id != pwb-&gt;dwIdExpected ) <br>                { <br>                    // <br>                    // But first make sure the the Success/Failure packet ID <br>                    // matches that of the last response sent. <br>                    // If not silently discard the packet. <br>                    // <br> <br>                    pResult-&gt;Action = EAPACTION_NoAction; <br>                    dwRetCode       = ERROR_PPP_INVALID_PACKET; <br>                } <br>                else <br>                { <br> <br>                    pResult-&gt;Action = EAPACTION_Done; <br>                    pwb-&gt;EapState   = MYSTATE_Done; <br>                } <br> <br>                break; <br>            } <br>            else if ( pReceiveBuf-&gt;Code == EAPCODE_Request )   <br>            { <br>                // <br>                // We must always respond to requests <br>                // <br> <br>                MakeResponseMessage(pwb, pReceiveBuf, pSendBuf, cbSendBuf); <br> <br>                // <br>                // Response packets should not be sent with any timeout <br>                // <br> <br>                pResult-&gt;Action = EAPACTION_Send; <br>            } <br>            else <br>            { <br>                // <br>                // Otherwise we received an illegal packet, wrong code set <br>                // So simply drop the packet. <br>                // <br> <br>                pResult-&gt;Action = EAPACTION_NoAction; <br>                dwRetCode       = ERROR_PPP_INVALID_PACKET; <br>            } <br>        } <br>    } <br> <br>    return( dwRetCode ); <br>} <br> <br> <br>VOID <br>MakeResponseMessage( <br>    IN  EAPCB*           pwb, <br>    IN  PPP_EAP_PACKET * pReceiveBuf, <br>    OUT PPP_EAP_PACKET * pSendBuf, <br>    IN  DWORD            cbSendBuf <br>) <br>    // <br>    // Builds a response packet.  'pwb' is the address of the work <br>    // buffer associated with the port. <br>    // <br>{ <br>    BYTE* pcbPassword; <br>    CHAR* pchPassword; <br> <br>    (void )cbSendBuf; <br> <br>    // <br>    // Fill in the password. <br>    // <br> <br>    pcbPassword = pSendBuf-&gt;Data + 1;  <br> <br>    *pcbPassword = (BYTE )strlen( pwb-&gt;szPassword ); <br> <br>    pchPassword = pcbPassword + 1; <br> <br>    strcpy( pchPassword, pwb-&gt;szPassword ); <br> <br>    // <br>    // Set the response code <br>    // <br> <br>    pSendBuf-&gt;Code = (BYTE )EAPCODE_Response; <br> <br>    // <br>    // The Reponse packet Id MUST match the Request packet Id. <br>    // <br> <br>    pSendBuf-&gt;Id = pReceiveBuf-&gt;Id; <br> <br>    // <br>    // The Success/Failure packet that we get must match the ID of the last  <br>    // response sent <br>    // <br> <br>    pwb-&gt;dwIdExpected = pSendBuf-&gt;Id; <br> <br>    // <br>    // Set the EAP type ID <br>    // <br> <br>    pSendBuf-&gt;Data[0] = (BYTE )PPP_EAP_PROTOCOL_ID; <br> <br>    // <br>    // Set the length of the packet <br>    // <br> <br>    HostToWireFormat16((WORD )(PPP_EAP_PACKET_HDR_LEN+1+*pcbPassword+1), <br>                       pSendBuf-&gt;Length ); <br>} <br>    <br> <br>VOID <br>MakeResultMessage( <br>    IN  DWORD           dwError, <br>    IN  BYTE            bId, <br>    OUT PPP_EAP_PACKET* pSendBuf, <br>    IN  DWORD           cbSendBuf  <br>) <br> <br>    // <br>    // Builds a result packet (Success or Failure) in caller's 'pSendBuf'  <br>    // buffer. 'cbSendBuf' is the length of caller's buffer.   <br>    // 'dwError' indicates whether an Success or Failure should be generated,  <br>    // 'bId' is the Id of the Success of Failure packet. <br>    // <br>{ <br>    (void )cbSendBuf; <br> <br>    // <br>    // If there was no error then we send a Success packet, otherwise we send <br>    // a failure message <br>    // <br> <br>    if ( dwError == NO_ERROR ) <br>    { <br>        pSendBuf-&gt;Code = EAPCODE_Success; <br>    } <br>    else <br>    { <br>        pSendBuf-&gt;Code = EAPCODE_Failure; <br>    } <br> <br>    // <br>    // Id must match the last response received <br>    // <br> <br>    pSendBuf-&gt;Id = bId; <br> <br>    // <br>    // Set the length <br>    // <br> <br>    HostToWireFormat16((WORD)PPP_EAP_PACKET_HDR_LEN, (PBYTE )pSendBuf-&gt;Length); <br>} <br> <br>VOID <br>MakeRequestMessage( <br>    IN  EAPCB*           pwb, <br>    OUT PPP_EAP_PACKET * pSendBuf, <br>    IN DWORD             cbSendBuf <br>) <br> <br>    // <br>    // Will build a request packet <br>    // <br>{ <br>    BYTE *pcbPeerMessage; <br>    CHAR *pchPeerMessage; <br> <br>    pcbPeerMessage  = pSendBuf-&gt;Data + 1; <br> <br>    *pcbPeerMessage = (BYTE)strlen("send password"); <br> <br>    pchPeerMessage  = pcbPeerMessage + 1; <br> <br>    strcpy (pchPeerMessage,"send password"); <br> <br>    // <br>    // Set the Request Code <br>    //  <br> <br>    pSendBuf-&gt;Code = EAPCODE_Request; <br> <br>    // <br>    // Set the Identifier <br>    // <br> <br>    pSendBuf-&gt;Id = (BYTE) dwNextId++; <br> <br>    // <br>    // Remember this Id since we need to send the Success/Failure packet with <br>    // this Id <br>    // <br> <br>    pwb-&gt;dwIdExpected = pSendBuf-&gt;Id;  <br> <br>    // <br>    // Set the length <br>    // <br> <br>    HostToWireFormat16((WORD)(PPP_EAP_PACKET_HDR_LEN+1+*pcbPeerMessage+1),   <br>                              pSendBuf-&gt;Length ); <br> <br>    // <br>    // Set the EAP Type Id <br>    // <br> <br>    pSendBuf-&gt;Data[0] = PPP_EAP_PROTOCOL_ID; <br> <br>} <br> <br>DWORD <br>AuthenticatorMakeMessage( <br>    IN  EAPCB*              pwb, <br>    IN  PPP_EAP_PACKET*     pReceiveBuf, <br>    OUT PPP_EAP_PACKET*     pSendBuf, <br>    IN  DWORD               cbSendBuf, <br>    IN  PPP_EAP_INPUT*      pInput, <br>    OUT PPP_EAP_OUTPUT*     pResult  <br>) <br>    // <br>    // Authenticator side event handler <br>    // <br>{ <br>    DWORD dwRetCode = NO_ERROR; <br> <br>    switch( pwb-&gt;EapState ) <br>    { <br>        case MYSTATE_ReqSent: <br> <br>            if ( pReceiveBuf != NULL ) <br>            { <br>                // <br>                // If we received a packet <br>                // <br> <br>                if ( pReceiveBuf-&gt;Code == EAPCODE_Response ) <br>                { <br>                    CHAR szPassword[PWLEN + 1]; <br> <br>                    // <br>                    // If we received a response to our identity request,  <br>                    // then process it. There is no need to check the Id     <br>                    // here since the PPP engine will only pass on packets <br>                    // whose Id matches those set with the  <br>                    // EAPACTION_SendWithTimeout action. <br>                    // <br> <br>                    dwRetCode = GetPasswordFromResponse( pReceiveBuf,  <br>                                                         szPassword ); <br> <br>                    if ( dwRetCode != NO_ERROR ) <br>                    {     <br>                        if ( dwRetCode != ERROR_PPP_INVALID_PACKET ) <br>                        { <br>                            // <br>                            // Fatal error, we fail the connection.  <br>                            // <br> <br>                            return( dwRetCode ); <br>                        } <br>                         <br>                        // <br>                        // Otherwise the packet is most likely corrupt.   <br>                        // Fall thru to the initial state to resend the <br>                        // request with the same Id. <br>                        // <br> <br>                        dwNextId = pwb-&gt;dwIdExpected; <br>                    } <br>                    else <br>                    { <br> <br>                        // <br>                        // Request authentication provider to authenticate  <br>                        // this user. <br>                        // <br> <br>                        dwRetCode = AuthenticateUser( pwb-&gt;szIdentity,  <br>                                                      szPassword,    <br>                                                      pwb ); <br> <br>                        if ( dwRetCode != NO_ERROR ) <br>                        { <br>                            return( dwRetCode ); <br>                        } <br>                        else <br>                        { <br>                            // <br>                            // Authentication request completed successfully. <br>                            // This is an asynchronous call so we change state <br>                            // and wait for the provider to complete the  <br>                            // authentication.   <br>                            // <br> <br>                            pwb-&gt;EapState =  <br>                                    MYSTATE_WaitForAuthenticationToComplete; <br> <br>                            pResult-&gt;Action = EAPACTION_NoAction; <br>                        }         <br>                    } <br> <br>                    break; <br>                } <br>                else <br>                { <br>                    // <br>                    // Otherwise silently drop the packet.  <br>                    // We should only get requests <br>                    // <br> <br>                    pResult-&gt;Action = EAPACTION_NoAction; <br> <br>                    break; <br>                } <br>            } <br>            else <br>            { <br>                // <br>                // If in this state we get called with a NULL pReceiveBuf, this <br>                // means that we timed out waiting for a response from the <br>                // the authenticatee, we need to resend with the same Id.  <br>                //  <br> <br>                dwNextId = pwb-&gt;dwIdExpected; <br> <br>                // <br>                // Fall thru to resend the request packet <br>                // <br>            } <br> <br>        case MYSTATE_Initial: <br> <br>            // <br>            // Create Request packet <br>            // <br> <br>            MakeRequestMessage( pwb, pSendBuf, cbSendBuf ); <br> <br>            // <br>            // Tell the PPP engine to drop all responses that do not mactch <br>            // this Id <br>            // <br> <br>            pResult-&gt;dwIdExpected = (BYTE)pwb-&gt;dwIdExpected; <br> <br>            // <br>            // Request messages must be sent with a timeout <br>            // <br> <br>            pResult-&gt;Action = EAPACTION_SendWithTimeoutInteractive; <br> <br>            // <br>            // Send we have sent a Request we change to the ReqSent state <br>            // where we will wait for a response <br>            // <br> <br>            pwb-&gt;EapState = MYSTATE_ReqSent; <br> <br>            break; <br> <br>        case MYSTATE_WaitForAuthenticationToComplete: <br>        { <br>            if ( pInput != NULL ) <br>            { <br>                // <br>                // Did the authentication provider complete the authentication? <br>                // <br> <br>                if ( pInput-&gt;fAuthenticationComplete ) <br>                { <br>                    // <br>                    // If there was a processing error, simply return this  <br>                    // error. <br>                    // <br> <br>                    if ( pInput-&gt;dwAuthError != NO_ERROR ) <br>                    { <br>                        return( pInput-&gt;dwAuthError ); <br>                    } <br> <br>                    // <br>                    // If the authentication process completed successfully but <br>                    // the user failed to authenticate, save the failure code. <br>                    // <br> <br>                    if ( pInput-&gt;dwAuthResultCode != NO_ERROR ) <br>                    { <br>                        pwb-&gt;dwResult = pInput-&gt;dwAuthResultCode; <br>                    } <br> <br>                    pResult-&gt;Action = EAPACTION_SendAndDone; <br>                    pwb-&gt;EapState   = MYSTATE_Done; <br> <br>                    // <br>                    // fall thru to the MYSTATE_Done state where we will <br>                    // send a Success or Failure packet <br>                    // <br>                } <br>            } <br> <br>            if ( ( pInput == NULL ) || ( !pInput-&gt;fAuthenticationComplete ) ) <br>            { <br>                // <br>                // Ignore everything if authentication is not complete <br>                // <br> <br>                pResult-&gt;Action = EAPACTION_NoAction; <br> <br>                break; <br>            } <br> <br>            // <br>            // ...fall thru to the MYSTATE_Done state where we will <br>            // send a Success or Failure packet <br>            // <br>        } <br> <br>        case MYSTATE_Done: <br>        { <br>            // <br>            // Make Success or Failure packet.   <br>            // <br> <br>            MakeResultMessage( pwb-&gt;dwResult,     <br>                               (BYTE)pwb-&gt;dwIdExpected,    <br>                               pSendBuf,   <br>                               cbSendBuf);      <br> <br>            strcpy( pResult-&gt;szIdentity, pwb-&gt;szIdentity ); <br> <br>            pResult-&gt;Action = EAPACTION_SendAndDone; <br> <br>            pResult-&gt;dwAuthResultCode = pwb-&gt;dwResult; <br> <br>            break; <br>        } <br> <br>        default: <br> <br>            break; <br>    } <br> <br>    return( dwRetCode ); <br> <br>} <br> <br>DWORD <br>GetPasswordFromResponse( <br>    IN  PPP_EAP_PACKET* pReceiveBuf, <br>    OUT CHAR*           pszPassword <br>) <br>    // <br>    // Fill caller's pszPassword' buffer with the password, in the request  <br>    // packet. <br>    // <br>    // Returns NO_ERROR if successful., or ERROR_PPP_INVALID_PACKET if the  <br>    // packet is misformatted in any way. <br>    // <br>{ <br>    BYTE* pcbPassword; <br>    CHAR* pchPassword; <br>    WORD  cbPacket; <br> <br>    cbPacket = WireToHostFormat16( pReceiveBuf-&gt;Length ); <br> <br>    // <br>    // Extract the password <br>    // <br> <br>    if ( cbPacket &lt; ( PPP_EAP_PACKET_HDR_LEN + 1 + 1 ) ) <br>    { <br>        return( ERROR_PPP_INVALID_PACKET ); <br>    } <br> <br>    pcbPassword = pReceiveBuf-&gt;Data + 1; <br>    pchPassword = pcbPassword + 1; <br> <br>    if (cbPacket &lt; PPP_EAP_PACKET_HDR_LEN + 1 + 1 + *pcbPassword) <br>    { <br>        return ERROR_PPP_INVALID_PACKET; <br>    } <br> <br>    CopyMemory( pszPassword, pchPassword, *pcbPassword ); <br> <br>    // <br>    // NULL terminate the password <br>    // <br> <br>    pszPassword[ *pcbPassword ] = '\0'; <br> <br>    return( NO_ERROR ); <br>} <br> <br>DWORD  <br>AuthenticateUser( <br>    IN CHAR *szUserName,     <br>    IN CHAR *szPassword,     <br>    IN EAPCB *pwb <br>) <br>    // <br>    // Will build user attributes and send them to the authentication provider <br>    // for authentication. <br>    // <br>{ <br> <br>    RAS_AUTH_ATTRIBUTE *pAttributes = NULL; <br>    DWORD dwRetCode; <br> <br>    pAttributes = (RAS_AUTH_ATTRIBUTE *) <br>                 LocalAlloc(LPTR, sizeof (RAS_AUTH_ATTRIBUTE) * 3); <br> <br>    if (pAttributes == NULL)  <br>    { <br>        return (GetLastError()); <br>    } <br> <br>    // <br>    // for user name <br>    // <br> <br>    pAttributes[0].raaType = raatUserName; <br>    pAttributes[0].dwLength =strlen(szUserName); <br>    pAttributes[0].Value = LocalAlloc(LPTR, (strlen(szUserName)+1)); <br> <br>    if (pAttributes == NULL)  <br>    {  <br>        LocalFree (pAttributes);  <br>        return (GetLastError()); <br>    } <br> <br>    CopyMemory (pAttributes[0].Value,szUserName, strlen(szUserName)); <br> <br>    // <br>    // for password <br>    // <br> <br>    pAttributes[1].raaType = raatUserPassword; <br>    pAttributes[1].dwLength =strlen(szPassword); <br>    pAttributes[1].Value = LocalAlloc(LPTR, (strlen(szPassword)+1)); <br> <br>    if (pAttributes == NULL)  <br>    {  <br>        LocalFree (pAttributes[0].Value); <br>        LocalFree (pAttributes);  <br>        return (GetLastError()); <br>    } <br> <br>    CopyMemory (pAttributes[1].Value,szPassword, strlen(szPassword)); <br>   <br>    // <br>    // For Termination <br>    // <br> <br>    pAttributes[2].raaType  = raatMinimum; <br>    pAttributes[2].dwLength = 0; <br>    pAttributes[2].Value    = NULL; <br> <br> <br>    // <br>    // Call the authentication provider <br>    // <br> <br>    dwRetCode = (*FpRasAuthenticateClient)( pwb-&gt;hPort, pAttributes ); <br> <br>    // <br>    // Free up Attributes <br>    // <br> <br>    LocalFree (pAttributes[0].Value); <br>    LocalFree (pAttributes[1].Value); <br> <br>    return( dwRetCode ); <br>} <br> <br>DWORD APIENTRY <br>RasEapInvokeInteractiveUI( <br>    IN  HWND            hWndParent, <br>    IN  PBYTE           pUIContextData, <br>    IN  DWORD           dwSizeofUIContextData, <br>    OUT PBYTE *         ppUserData              OPTIONAL, <br>    OUT DWORD *         lpdwSizeOfUserData <br>) <br>{ <br>    if ( MessageBoxA( hWndParent,  <br>                      pUIContextData,  <br>                      "EAP sample",  <br>                      MB_OKCANCEL ) == IDOK ) <br>    { <br>        *lpdwSizeOfUserData = strlen( "OK" )+ 1; <br> <br>        if ( ( *ppUserData = LocalAlloc( LPTR, strlen( "OK" )+ 1 ) ) == NULL ) <br>        { <br>            return( ERROR_NOT_ENOUGH_MEMORY ); <br>        } <br> <br>        strcpy( *ppUserData, "OK" ); <br>    } <br>    else <br>    { <br>        *ppUserData         = NULL; <br>        *lpdwSizeOfUserData = 0; <br>    } <br>     <br>    return( NO_ERROR ); <br>} <br> <br>DWORD APIENTRY <br>RasEapFreeUserData( <br>    IN  PBYTE           pUserData <br>) <br>{ <br>    if ( pUserData != NULL ) <br>    { <br>        LocalFree( pUserData ); <br>    } <br> <br>    return( NO_ERROR ); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
