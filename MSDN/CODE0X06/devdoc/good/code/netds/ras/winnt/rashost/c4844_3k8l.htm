<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RASHOST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4845"></a>RASHOST.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      RASHOST.CPP <br>// <br>//  Description <br>//      This file contains the initialization functions for the DLL library <br>//      and for the Security Host protocol. The NT RAS manager will call into <br>//      our DLL when a dialing user needs to be validated. <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.1 <br>// <br>// Written for Microsoft Developer Support <br>// Copyright 1995 - 1998 Microsoft Corporation. All rights reserved. <br>// <br>#include "RASHOST.H" <br> <br>HINSTANCE                       ghLibHandle = NULL; <br>RASSECURITYDIALOGSENDPROC       gpfnSendProc = NULL; <br>RASSECURITYDIALOGRECEIVEPROC    gpfnReceiveProc = NULL; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    LibMain() <br>// <br>//    Parameters <br>//      { Refer to the Win32 SDK documentation for DLL entry points } <br>// <br>//    Purpose <br>//      Entry point of this DLL <br>// <br>//    Return Value <br>//      TRUE if the DLL should proceed with the dwReason case, FALSE otherwise. <br>// <br>BOOL APIENTRY LibMain (HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved) <br>{ <br>    if (DLL_PROCESS_DETACH == dwReason &amp;&amp; ghLibHandle) <br>    { <br>        FreeLibrary (ghLibHandle); <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RasSecurityDialogBegin() <br>// <br>//    Parameters <br>//      hPort       Handle to the COM port where the user is logging in <br>//                  (A RAS handle, not a standard handle) <br>//      pSendBuf    Pointer to a buffer where we can copy stuff to be sent <br>//                  over the wire <br>//      SendBufSize Size of the outgoing buffer <br>//      pRecvBuf    Pointer a buffer where stuff is received from the <br>//                  remote client machine <br>//      RecvBufSize Size of the incoming buffer <br>//      RasSecurityDialogComplete   Pointer to a callback function we must <br>//                  call after we have completed our validation, indicating <br>//                  the RAS manager weather or not we granted access to the <br>//                  caller. <br>// <br>//    Purpose <br>//      This is the entry point for our security DLL. When the RAS manager <br>//      receives a call from a user, after it does its user validation, it <br>//      will call into us at this entry point to allow us to do extra <br>//      validation. <br>//      NOTE: It is very important that this function does not BLOCK. If <br>//            it does, the RAS manager will be block and no other calls <br>//            will be accepted. That is why we copy the incoming <br>//            parameters into a private structure and then spawn a thread <br>//            to do the actual validation work. <br>//            The passed parameters will be valid until we call the <br>//            ending function. <br>// <br>//    Return Value <br>//      ERROR_SUCCESS is we were able to start the validation. Otherwise <br>//      return and error from WINERROR.H or RASERROR.H <br>// <br>DWORD WINAPI RasSecurityDialogBegin (HPORT hPort, <br>                                     PBYTE pSendBuf, <br>                                     DWORD SendBufSize, <br>                                     PBYTE pRecvBuf, <br>                                     DWORD RecvBufSize, <br>                                     VOID  (WINAPI *RasSecurityDialogComplete)(SECURITY_MESSAGE*)) <br>{ <br>    // Initialize the global pointer to the entry points in the RAS manager <br>    // DLL. I use these entry points to send and receive data to the remote <br>    // client machine. These functions will send and receive RAW buffers of <br>    // data to the other machine just before PPP-framing starts. <br>    // These functions have not been exported in any publish import library <br>    // so we must do a dynamic binding to them. <br>    if (NULL == ghLibHandle) <br>    { <br>        ghLibHandle = LoadLibrary ("RASMAN.DLL"); <br>        if (NULL == ghLibHandle) <br>        { <br>            return ERROR_DLL_NOT_FOUND; <br>        } <br>    } <br>    // Obtain the send and received entry points from the RAS manager DLL. <br>    if (NULL == gpfnSendProc) <br>    { <br>        gpfnSendProc = (RASSECURITYDIALOGSENDPROC)GetProcAddress (ghLibHandle, TEXT("RasSecurityDialogSend")); <br>        if (NULL == gpfnSendProc) <br>        { <br>            return ERROR_PROC_NOT_FOUND; <br>        } <br>    } <br>    if (NULL == gpfnReceiveProc) <br>    { <br>        gpfnReceiveProc = (RASSECURITYDIALOGRECEIVEPROC)GetProcAddress (ghLibHandle, TEXT("RasSecurityDialogReceive")); <br>        if (NULL == gpfnReceiveProc) <br>        { <br>            return ERROR_PROC_NOT_FOUND; <br>        } <br>    } <br>     <br>    // Save the parameters passed and give them to the working thread <br>    // that will handle the authentication of the caller. The thread <br>    // should release this memory. <br>    // The parameters passed to use should be valid until we call the <br>    // dialog end function or until we get call in the termination <br>    // dialog entry point by the RAS system supervisor (the RAS manager) <br>    PWORK_THREAD_DATA pCallData = (PWORK_THREAD_DATA)HeapAlloc (GetProcessHeap(), <br>                                                                HEAP_ZERO_MEMORY, <br>                                                                sizeof(WORK_THREAD_DATA)); <br>    if (NULL == pCallData) <br>    { <br>        return ERROR_OUTOFMEMORY; <br>    } <br>    // Initialize the members. <br>    pCallData-&gt;hPort = hPort; <br>    pCallData-&gt;pSendBuf = pSendBuf; <br>    pCallData-&gt;SendBufSize = SendBufSize; <br>    pCallData-&gt;pRecvBuf = pRecvBuf; <br>    pCallData-&gt;RecvBufSize = RecvBufSize; <br>    pCallData-&gt;pfnSecurityDialogEnd = RasSecurityDialogComplete; <br> <br>    // For each call, spawn a working thread that will make the neccesary <br>    // authentication of the dial-up caller. We should never block the call <br>    // to RasSecurityDialogBegin(). If we do so, RAS will also block and no <br>    // more call would be accepted. <br>    DWORD dwThreadID; <br>    HANDLE hThread = CreateThread (NULL, <br>                                   0, <br>                                   (LPTHREAD_START_ROUTINE)CallWorkerThread, <br>                                   (LPVOID)pCallData, <br>                                   0, <br>                                   &amp;dwThreadID); <br>    if (NULL == hThread) <br>    { <br>        // Call GetLastError() before calling HeapFree(). <br>        DWORD dwError = GetLastError(); <br>        HeapFree (GetProcessHeap(), 0, pCallData); <br>        return dwError; <br>    } <br>    return ERROR_SUCCESS; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RasSecurityDialogEnd() <br>// <br>//    Parameters <br>//      hPort   Handle to the COM port (A RAS handle, not a standard handle) <br>// <br>//    Purpose <br>//      Stub function. Need to export this by the security DLL even if <br>//      not needed. We need to return non-zero to indicate RAS we are no <br>//      longer responsible for the port connection. It will take care <br>//      of the rest. <br>// <br>//    Return Value <br>//      ERROR_PORT_DISCONNECTED always <br>// <br>DWORD WINAPI RasSecurityDialogEnd (HPORT hPort) <br>{ <br>    return ERROR_PORT_DISCONNECTED; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CallWorkerThread() <br>// <br>//    Parameters <br>//      pCallData   Pointer to the data structure with the data for the <br>//                  instance we are handling. <br>// <br>//    Purpose <br>//      This is the function for the thread that interacts with a dialing RAS <br>//      user. Here we query the user for its identity and based on it we <br>//      compute a challenge to for it. Once the response from the client <br>//      is received, we validate it and decide wether or not we allow access. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CallWorkerThread (PWORK_THREAD_DATA pCallData) <br>{ <br>    // Initialize the appropiate structures <br>    SECURITY_MESSAGE smResult = { 0 }; <br>    smResult.hPort = pCallData-&gt;hPort; <br>    lstrcpy (smResult.UserName, TEXT("(RASHOST - Unknown)")); <br> <br>    DWORD dwBytes = pCallData-&gt;RecvBufSize; <br>    ZeroMemory (pCallData-&gt;pRecvBuf, dwBytes); <br>    dwBytes = sizeof(RASHOST_DATA); <br> <br>    // Initialize the structure that we'll send to the caller <br>    RASHOST_DATA HostData = { 0 }; <br>    HostData.dwSize = sizeof(RASHOST_DATA); <br>     <br>    // Create an event to wait for client responses <br>    HANDLE hEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br> <br>    // We must copy the data from the structure to the buffer RAS <br>    // manager uses to transmit the information. This buffer <br>    // cannot be larger than 1500 bytes <br>    CopyMemory (pCallData-&gt;pSendBuf, &amp;HostData, sizeof(RASHOST_DATA)); <br>    DWORD dwError = 0; <br> <br>    gpfnSendProc (pCallData-&gt;hPort, <br>                  pCallData-&gt;pSendBuf, <br>                  (WORD)sizeof(RASHOST_DATA)); <br> <br>    // Wait for an answer from the client responder <br>    gpfnReceiveProc (pCallData-&gt;hPort, <br>                     pCallData-&gt;pRecvBuf, <br>                     (WORD *)&amp;dwBytes, <br>                     0, <br>                     hEvent); <br>    DWORD dwWait; <br>    dwWait = WaitForSingleObject (hEvent, CLIENT_RESPONSE_TIMEOUT); <br>    if (WAIT_OBJECT_0 != dwWait) <br>    { <br>        dwError = ERROR_SMM_TIMEOUT; <br>        goto ErrorExit; <br>    } <br> <br>    // Copy the client data from the incoming buffer to the data structure <br>    CopyMemory (&amp;HostData, pCallData-&gt;pRecvBuf, sizeof(RASHOST_DATA)); <br>     <br>    // Save this information for RAS authentication with the NT RAS manager. <br>    // The user name must be the same as the one in the NT account database <br>    // on the domain where the user is granted access. <br>    lstrcpy (smResult.UserName, HostData.szUserName); <br>    lstrcpy (smResult.Domain, HostData.szUserDomain); <br> <br>    //lstrcpy (smResult.UserName, "IrvingD"); <br> <br>    BOOL fAccessGranted; // Weather or not access was granted <br>    // With the received client response, validate the access for the client <br>    dwError = ValidateCallingUser (&amp;HostData, &amp;fAccessGranted); <br>    if (dwError) <br>    { <br>        goto ErrorExit; <br>    } <br>     <br>    if (fAccessGranted) <br>    { <br>        // Access has been granted <br>        smResult.dwMsgId = SECURITYMSG_SUCCESS; <br>    } <br>    else <br>    { <br>        // The caller did not respond correctly <br>        smResult.dwMsgId = SECURITYMSG_FAILURE; <br>    } <br> <br>ErrorExit: <br>    if (dwError) <br>    { <br>        // There was an error, deny access. <br>        if (ERROR_SMM_TIMEOUT == dwError) <br>        { <br>            smResult.dwMsgId = SECURITYMSG_FAILURE; <br>        } <br>        else <br>        { <br>            smResult.dwMsgId = SECURITYMSG_ERROR; <br>            smResult.dwError = dwError; <br>        } <br>    } <br>    // Release the synchronization objects <br>    CloseHandle (hEvent); <br>    // Tell the RAS manager we are finished by calling the END dialog funcition. <br>    pCallData-&gt;pfnSecurityDialogEnd (&amp;smResult); <br>    // Free the memory of this call instance before exiting the thread <br>    HeapFree (GetProcessHeap(), 0, pCallData); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ValidateCallingUser() <br>// <br>//    Parameters <br>//      pData               Pointer to the host data structure <br>//      pfAccessGranted     We return TRUE here is access is granted. <br>//                          FALSE otherwise. <br>// <br>//    Purpose <br>//      Here we validate the answer to the challenge sent to the client. <br>// <br>//    Return Value <br>//      ERROR_SUCCESS if successful. Otherwiser an error code from WINERROR.H <br>//      or RASERROR.H <br>// <br>DWORD WINAPI ValidateCallingUser (PRASHOST_DATA       pData, <br>                                  BOOL *              pfAccessGranted) <br>{ <br>    DWORD dwResult = ERROR_SUCCESS; <br>    *pfAccessGranted = FALSE; <br>     <br>    // Do stuff here <br> <br>    return dwResult; <br>} <br> <br>// End of file for RASHOST.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
