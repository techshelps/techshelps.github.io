<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SECHOST.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4848"></a>SECHOST.H</h2>
<pre><code>/********************************************************************/ <br>/**               Copyright(c) 1989 Microsoft Corporation.   **/ <br>/********************************************************************/ <br> <br>//*** <br>// <br>// Filename:    sechost.h <br>// <br>// Description: This header defines the interface between third party security <br>//              DLLs and the supervisor.  <br>// <br>// History: <br>//Nov 11,1994.NarenGCreated original version. <br>// <br> <br>#ifndef _SECHOST_ <br>#define _SECHOST_ <br> <br>#include &lt;lmcons.h&gt;                 // Defines for DNLEN and UNLEN <br> <br>#define DEVICE_NAME_LEN             32 <br> <br>typedef DWORD  HPORT; <br> <br>typedef struct _SECURITY_MESSAGE <br>{ <br>    DWORD dwMsgId; <br> <br>    HPORT hPort; <br>     <br>    DWORD dwError;                  // Should be non-zero only if error <br>                                    // occurred during the security dialog. <br>                                    // Should contain errors from winerror.h <br>                                    // or raserror.h <br>    CHAR  UserName[UNLEN+1];        // Should always contain username if  <br>                                    // dwMsgId is SUCCESS/FAILURE <br> <br>    CHAR  Domain[DNLEN+1];          // Should always contain domain if  <br>                                    // dwMsgId is SUCCESS/FAILURE <br> <br>} SECURITY_MESSAGE, *PSECURITY_MESSAGE; <br> <br> <br>// Values for dwMsgId in SECURITY_MESSAGE structure <br> <br>#define SECURITYMSG_SUCCESS     1 <br>#define SECURITYMSG_FAILURE     2 <br>#define SECURITYMSG_ERROR       3 <br> <br>// Used by RasSecurityGetInfo call <br> <br>typedef struct _RAS_SECURITY_INFO <br>{ <br> <br>    DWORD LastError;                    // SUCCESS = receive completed <br>                                        // PENDING = receive pending <br>                                        // else completed with error <br> <br>    DWORD BytesReceived;                // only valid if LastError == SUCCESS <br> <br>    CHAR  DeviceName[DEVICE_NAME_LEN+1];         <br>    <br> <br>}RAS_SECURITY_INFO,*PRAS_SECURITY_INFO; <br> <br>typedef DWORD (WINAPI *RASSECURITYPROC)(); <br> <br>// <br>// Called by third party DLL to notify the supervisor of termination of  <br>// the security dialog <br>// <br> <br>VOID WINAPI <br>RasSecurityDialogComplete( <br>    IN SECURITY_MESSAGE * pSecMsg       // Pointer to the above info. structure <br>); <br> <br>// <br>// Called by supervisor into the security DLL to notify it to begin the  <br>// security dialog for a client. <br>// <br>// Should return errors from winerror.h or raserror.h <br>// <br> <br>DWORD WINAPI <br>RasSecurityDialogBegin( <br>    IN HPORT  hPort,        // RAS handle to port <br>    IN PBYTE  pSendBuf,     // Pointer to the buffer used in  <br>                            // RasSecurityDialogSend <br>    IN DWORD  SendBufSize,  // Size of above bufer in bytes <br>    IN PBYTE  pRecvBuf,     // Pointer to the buffer used in  <br>                            // RasSecurityDialogReceive <br>    IN DWORD  RecvBufSize,  // Size of above buffer <br>    IN VOID  (WINAPI *RasSecurityDialogComplete)( SECURITY_MESSAGE* ) <br>                            // Pointer to function RasSecurityDialogComplete.    <br>                            // Guaranteed to be the same on every call. <br>); <br> <br>// <br>// Called by supervisor into the security DLL to notify it to stop the  <br>// security dialog for a client. If this call returns an error, then it is not <br>// neccesary for the dll to call RasSecurityDialogComplete. Otherwise the DLL <br>// must call RasSecurityDialogComplete. <br>// <br>// Should return errors from winerror.h or raserror.h <br>// <br> <br>DWORD WINAPI <br>RasSecurityDialogEnd( <br>    IN HPORT    hPort           // RAS handle to port. <br>); <br> <br>// <br>// Called to send data to remote host <br>// Will return errors from winerror.h or raserror.h <br>// <br> <br>DWORD WINAPI <br>RasSecurityDialogSend( <br>    IN HPORT    hPort,          // RAS handle to port. <br>    IN PBYTE    pBuffer,        // Pointer to buffer containing data to send <br>    IN WORD     BufferLength    // Length of above buffer. <br>); <br> <br>// <br>// Called to receive data from remote host <br>// Will return errors from winerror.h or raserror.h <br>// <br> <br>DWORD WINAPI <br>RasSecurityDialogReceive( <br>    IN HPORT    hPort,          // RAS handle to port. <br>    IN PBYTE    pBuffer,        // Pointer to buffer to receive data <br>    IN PWORD    pBufferLength,  // length of data received in bytes. <br>    IN DWORD    Timeout,        // in seconds <br>    IN HANDLE   hEvent          // Event to set when receive completes or  <br>                                // timeouts <br>); <br> <br>// <br>// Called to get Information about port. <br>// Will return errors from winerror.h or raserror.h <br>// <br> <br>DWORD WINAPI <br>RasSecurityDialogGetInfo( <br>    IN HPORT                hPort,      // RAS handle to port. <br>    IN RAS_SECURITY_INFO*   pBuffer     // Pointer to get info structure. <br>); <br> <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
