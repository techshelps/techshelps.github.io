<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RASBERRY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4836"></a>RASBERRY.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   rasberry.c <br>// <br>//  PURPOSE:  Implement the windows procedure for the main application <br>//            windows.   <br>// <br>//  FUNCTIONS: <br>//    WndProc      - Processes messages for the main window. <br>//    MsgCreate    - Handle the WM_CREATE messages for the main window. <br>//    MsgSize      - Handle the WM_SIZE messages for the main window. <br>//    MsgCommand   - Handle the WM_COMMAND messages for the main window. <br>//    MsgDestroy   - Handles the WM_DESTROY message by calling  <br>//                   PostQuitMessage(). <br>//    CmdPhbkDlg   - Displays entries in default phonebook. <br>//    CmdStatDlg   - Displays status of the selected connection. <br>//    CmdRefresh   - Refreshes list of connections in listbox.          <br>//    CmdHangup    - Hangs up the selected connection. <br>//    CmdConnNotify- Handles notification messages for connection listbox. <br>//    CmdExit      - Handles the file exit command by calling destory  <br>//                   window on the main window. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>#include &lt;windows.h&gt;            // required for all Windows applications <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16 <br>#include "win16ext.h"           // required only for win16 applications <br>#endif <br> <br>#include "globals.h"            // prototypes specific to this application <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;ras.h&gt; <br>#include &lt;raserror.h&gt; <br>#include "rasutil.h" <br>#include "phbkdlg.h" <br>#include "statdlg.h" <br> <br>// Main window message table definition. <br>MSD rgmsd[] = <br>{ <br>    {WM_CREATE,   MsgCreate}, <br>    {WM_SIZE,     MsgSize}, <br>    {WM_COMMAND,  MsgCommand}, <br>    {WM_DESTROY,  MsgDestroy} <br>}; <br> <br>MSDI msdiMain = <br>{ <br>    sizeof(rgmsd) / sizeof(MSD), <br>    rgmsd, <br>    edwpWindow <br>}; <br> <br> <br>// Main window command table definition. <br>CMD rgcmd[] = <br>{ <br>    {IDM_PHONEBOOK, CmdPhbkDlg}, <br>    {IDM_STATUS,    CmdStatDlg}, <br>    {IDM_EXIT,      CmdExit}, <br>    {IDM_REFRESH,   CmdRefresh}, <br>    {IDM_HANGUP,    CmdHangUp}, <br>    {IDM_ABOUT,     CmdAbout}, <br>    {IDL_CONN,      CmdConnNotify} <br>}; <br> <br>CMDI cmdiMain = <br>{ <br>    sizeof(rgcmd) / sizeof(CMD), <br>    rgcmd, <br>    edwpWindow <br>}; <br> <br>// Application "globals" <br>char g_szUserName[UNLEN+1]; <br>char g_szPassword[PWLEN+1]; <br>char g_szDomain[DNLEN+1]; <br> <br>LPHRASCONN g_lphRasConn = NULL; <br> <br>// Module specific "globals"  Used when a variable needs to be <br>// accessed in more than on handler function. <br> <br>HWND hwndConn;  // handle of listbox of connections <br> <br>// <br>//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  PARAMETERS: <br>//    hwnd     - window handle <br>//    uMessage - message number <br>//    wparam   - additional information (dependant on message number) <br>//    lparam   - additional information (dependant on message number) <br>// <br>//  RETURN VALUE: <br>//    The return value depends on the message number.  If the message <br>//    is implemented in the message dispatch table, the return value is <br>//    the value returned by the message handling function.  Otherwise, <br>//    the return value is the value returned by the default window procedure. <br>// <br>//  COMMENTS: <br>//    Call the DispMessage() function with the main window's message dispatch <br>//    information (msdiMain) and the message specific information. <br>// <br> <br>LRESULT CALLBACK WndProc(HWND   hwnd,  <br>                         UINT   uMessage,  <br>                         WPARAM wparam,  <br>                         LPARAM lparam) <br>{ <br>    return DispMessage(&amp;msdiMain, hwnd, uMessage, wparam, lparam); <br>} <br> <br> <br>// <br>//  FUNCTION: MsgCreate(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Initialized main window <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle <br>//    uMessage  - Message number (Unused) <br>//    wparam    - Extra data     (Unused) <br>//    lparam    - Extra data     (Unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>//    Creates a listbox the size of the window and fills it <br>//    with a list of RAS connections.   <br>// <br> <br>LRESULT MsgCreate(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    RECT rc; <br>     <br>    GetClientRect( hwnd, &amp;rc ); <br>     <br>    hwndConn  = CreateWindow( "LISTBOX", <br>                             "Connections", <br>                             WS_CHILD | WS_VISIBLE | WS_HSCROLL | <br>                             WS_VSCROLL | LBS_USETABSTOPS | LBS_NOINTEGRALHEIGHT | LBS_SORT, <br>                             0,    <br>                             0, <br>                             rc.right, <br>                             rc.bottom, <br>                             hwnd, <br>                             (HMENU) IDL_CONN, <br>                             hInst, <br>                             NULL ); <br> <br>    SendMessage( hwnd, WM_COMMAND, IDM_REFRESH, 0L ); <br> <br>    // initialize global variables    <br>    g_szUserName[0] = '\0'; <br>    g_szPassword[0] = '\0'; <br>    g_szDomain[0] = '*'; <br>    g_szDomain[1] = '\0'; <br>     <br>    return 0; <br>} <br> <br> <br>// <br>//  FUNCTION: MsgSize(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Resize listbox to client area size <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle <br>//    uMessage  - Message number (Unused) <br>//    wparam    - Extra data     (Unused) <br>//    lparam    - Extra data     (Unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgSize(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    MoveWindow(hwndConn, 0, 0, LOWORD(lparam), HIWORD(lparam), TRUE); <br>    return 0; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: MsgCommand(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Handle the WM_COMMAND messages for the main window. <br>// <br>//  PARAMETERS: <br>//    hwnd     - window handle <br>//    uMessage - WM_COMMAND (Unused) <br>//    GET_WM_COMMAND_ID(wparam, lparam)   - Command identifier <br>//    GET_WM_COMMAND_HWND(wparam, lparam) - Control handle <br>// <br>//  RETURN VALUE: <br>//    The return value depends on the message number.  If the message <br>//    is implemented in the message dispatch table, the return value is <br>//    the value returned by the message handling function.  Otherwise, <br>//    the return value is the value returned by the default window procedure. <br>// <br>//  COMMENTS: <br>//    Call the DispCommand() function with the main window's command dispatch <br>//    information (cmdiMain) and the command specific information. <br>// <br> <br>LRESULT MsgCommand(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    return DispCommand(&amp;cmdiMain, hwnd, wparam, lparam); <br>} <br> <br> <br>// <br>//  FUNCTION: MsgDestroy(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Calls PostQuitMessage(). <br>// <br>//  PARAMETERS: <br>// <br>//    hwnd      - Window handle  (Unused) <br>//    uMessage  - Message number (Unused) <br>//    wparam    - Extra data     (Unused) <br>//    lparam    - Extra data     (Unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT MsgDestroy(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) <br>{ <br>    if ( g_lphRasConn != NULL ) <br>    { <br>        _ffree((LPVOID) g_lphRasConn ); <br>        g_lphRasConn = NULL; <br>    } <br> <br>    PostQuitMessage(0); <br>#ifdef WIN32 <br>    Sleep(3000);  // let RAS state machine clean up <br>#endif <br>    return 0; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: CmdPhbkDlg(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Displays the "PhbkDlg" dialog box <br>// <br>//  PARAMETERS: <br>//    hwnd      - Window handle <br>//    wCommand  - IDM_ENTRY (unused) <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl  - NULL (unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>//    To process the IDM_ENTRY message, call DialogBox() to display the <br>//    phbkdlg dialog box. <br> <br>LRESULT CmdPhbkDlg(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    DialogBox(hInst, "PhbkDlgBox", hwnd, (DLGPROC)PhbkDlg); <br>    SendMessage( hwnd, WM_COMMAND, IDM_REFRESH, 0L ); <br> <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: CmdStatDlg(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Displays the "StatDlg" dialog box <br>// <br>//  PARAMETERS: <br>//    hwnd      - Window handle <br>//    wCommand  - IDM_STATDLG (unused) <br>//    wNotify   - Notification number (unused) <br>//    hwndCtrl  - NULL (unused) <br>// <br>//  RETURN VALUE: <br>// <br>//    Always returns 0 - Message handled <br>// <br>//  COMMENTS: <br>//    To process the IDM_STATDLG message, call DialogBox() to display the <br>//    statdlg dialog box. <br> <br>LRESULT CmdStatDlg(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    DialogBox(hInst, "StatDlgBox", hwnd, (DLGPROC)StatDlg); <br>    SendMessage( hwnd, WM_COMMAND, IDM_REFRESH, 0L ); <br>    return 0; <br>} <br> <br> <br> <br>// <br>//  FUNCTION: CmdRefesh(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Refreshes the connection list <br>// <br>//  PARAMETERS: <br>//    hwnd     - The window. <br>//    wCommand - IDM_REFRESH (unused) <br>//    wNotify  - Notification number (unused) <br>//    hwndCtrl - NULL (unused) <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - command handled. <br>// <br>//  COMMENTS: <br>//     Calls RasEnumConnections to get a list of current connections <br>// <br> <br>LRESULT CmdRefresh(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    LPRASCONN  lpRasConn = NULL; <br>    LPRASCONN  lpTemp = NULL; <br>    LPHRASCONN lphTemp = NULL; <br>    DWORD cbBuf = 0; <br>    DWORD cConn = 0; <br>    DWORD dwRet = 0; <br>    UINT  ndx; <br>    char  szMessage[256]; <br>    HMENU hmenu = GetMenu( hwnd ); <br> <br>    // remove any connections currently in listbox                                  <br>    SendMessage( hwndConn, LB_RESETCONTENT, 0, 0L ); <br> <br>    if ( g_lphRasConn != NULL ) <br>    { <br>        _ffree( (LPVOID) g_lphRasConn ); <br>        g_lphRasConn = NULL; <br>    } <br> <br>    // enumerate connections <br>    cbBuf = sizeof(RASCONN); <br>    if ( ((lpRasConn = ( LPRASCONN ) _fmalloc((UINT)cbBuf)) != NULL ) &amp;&amp; <br>         ((g_lphRasConn = ( LPHRASCONN ) _fmalloc(sizeof(HRASCONN))) != NULL ) ) <br>    {             <br>        lpRasConn-&gt;dwSize = sizeof( RASCONN );                       <br>        dwRet = RasEnumConnections( lpRasConn, &amp;cbBuf, &amp;cConn ); <br>        if ( dwRet == ERROR_BUFFER_TOO_SMALL ) <br>        { <br>            if ( (lpTemp = ( LPRASCONN ) _frealloc(lpRasConn, (UINT)cbBuf) ) != NULL ) <br>            { <br>                lpRasConn = lpTemp; <br>                dwRet = RasEnumConnections( lpRasConn, &amp;cbBuf, &amp;cConn ); <br>                 <br>                if ( NULL != (lphTemp = ( LPHRASCONN ) <br>                              _frealloc((LPVOID)g_lphRasConn, (UINT)(sizeof(HRASCONN)*cConn))) ) <br>                    g_lphRasConn = lphTemp; <br>                else <br>                    dwRet = ERROR_NOT_ENOUGH_MEMORY; <br> <br>            } <br>            else <br>            { <br>                dwRet = ERROR_NOT_ENOUGH_MEMORY; <br>            } <br>        } <br>        else if ( dwRet != 0 ) // other error <br>        { <br>            if ( RasGetErrorString( (UINT)dwRet, szMessage, 256 ) != 0 ) <br>                wsprintf( (LPSTR)szMessage, (LPSTR)"Undefined RAS Dial Error." ); <br> <br>            MessageBox(hwnd, szMessage, szAppName, MB_OK | MB_ICONSTOP );                             <br>        } <br> <br>        if ( dwRet == 0 )  // No errors, so populate listbox <br>        { <br>            for ( ndx = 0; ndx &lt; cConn; ndx++ )  <br>            { <br>                g_lphRasConn[ndx] = lpRasConn[ndx].hrasconn; <br>                SendMessage( hwndConn, <br>                             LB_ADDSTRING, <br>                             0, <br>                             (LPARAM)(LPCSTR) lpRasConn[ndx].szEntryName); <br>            } <br> <br>            // update states of menu items <br>            if ( ndx &gt; 0 ) // at least one item was added <br>            {              <br>                SendMessage( hwndConn, LB_SETCURSEL, 0, 1L ); <br>                EnableMenuItem( hmenu, IDM_STATUS, MF_ENABLED ); <br>                EnableMenuItem( hmenu, IDM_HANGUP, MF_ENABLED ); <br>            } <br>            else  <br>            { <br>                EnableMenuItem( hmenu, IDM_STATUS, MF_GRAYED ); <br>                EnableMenuItem( hmenu, IDM_HANGUP, MF_GRAYED ); <br>            } <br>        } <br>        else <br>        { <br>            EnableMenuItem( hmenu, IDM_STATUS, MF_GRAYED ); <br>            EnableMenuItem( hmenu, IDM_HANGUP, MF_GRAYED ); <br>        } <br> <br>        _ffree( lpRasConn ); <br>    } <br>    else <br>    { <br>        if ( g_lphRasConn != NULL ) <br>        { <br>            _ffree((LPVOID) g_lphRasConn ); <br>            g_lphRasConn = NULL; <br>        } <br> <br>        if ( lpRasConn != NULL ) <br>        { <br>            _ffree( lpRasConn ); <br>        } <br>    }                 <br> <br> <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: CmdHangUp(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Hangs up the selected connection <br>// <br>//  PARAMETERS: <br>//    hwnd     - The window. <br>//    wCommand - IDM_HANGUP (unused) <br>//    wNotify  - Notification number (unused) <br>//    hwndCtrl - NULL (unused) <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - command handled. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT CmdHangUp(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    CHAR  szBuf[256]; <br>    CHAR  szBuf2[256]; <br>    UINT  ndx; <br> <br>    // get the connection text from previous window <br>    ndx = (UINT) SendMessage( hwndConn, LB_GETCURSEL, 0,  0L ); <br>    SendMessage( hwndConn, LB_GETTEXT, ndx, (LPARAM)(LPSTR)szBuf ); <br> <br>    wsprintf( (LPSTR) szBuf2, "HangUp %s?", (LPSTR) szBuf ); <br>    if ( IDYES == MessageBox( hwnd, (LPSTR)szBuf2, szAppName, MB_ICONQUESTION | MB_YESNO ) ) <br>    { <br>        RasHangUp( g_lphRasConn[ndx] ); <br> <br>        SendMessage( hwnd, WM_COMMAND, IDM_REFRESH, 0L ); <br>    } <br>    return 0; <br>} <br> <br>// <br>//  FUNCTION: CmdConnNotify(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: notfication from Connection Listbox <br>// <br>//  PARAMETERS: <br>//    hwnd - The window handling the command. <br>//    wCommand - The command to be handled (unused). <br>//    wNotify  - The notification code to be handled (LBN_DBLCLK). <br>//    hwndCtrl - NULL (unused). <br>// <br>//  RETURN VALUE: <br>//    0 if message is processed. <br>// <br>//  COMMENTS: <br>//    Catches DBL_CLK to cause connection status dialog to appear <br>// <br> <br>LRESULT CmdConnNotify(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    if ( wNotify == LBN_DBLCLK ) <br>    { <br>        SendMessage( hwnd, WM_COMMAND, IDM_STATUS, 0 ); <br>        return 0; <br>    } <br>    return 1; <br>} <br> <br>// <br>//  FUNCTION: CmdExit(HWND, WORD, WORD, HWND) <br>// <br>//  PURPOSE: Exit the application. <br>// <br>//  PARAMETERS: <br>//    hwnd     - The window. <br>//    wCommand - IDM_EXIT <br>//    wNotify  - Notification number (unused) <br>//    hwndCtrl - NULL (unused) <br>// <br>//  RETURN VALUE: <br>//    Always returns 0 - command handled. <br>// <br>//  COMMENTS: <br>// <br>// <br> <br>LRESULT CmdExit(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl) <br>{ <br>    DestroyWindow(hwnd); <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
