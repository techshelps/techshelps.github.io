<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NETSHARE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5229"></a>NETSHARE.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1995, 1996  Microsoft Corporation <br> <br>Module Name: <br> <br>    netshare.c <br> <br>Abstract: <br> <br>    This module illustrates how to use the Windows NT Lan Manager API <br>    in conjunction with the Win32 security API to create a new share <br>    on an arbitrary machine with permissions that grant an arbitrary <br>    user/group Full Access to the share. <br> <br>Author: <br> <br>    Scott Field (sfield)    01-Oct-95 <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;lm.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#define RTN_OK 0 <br>#define RTN_USAGE 1 <br>#define RTN_ERROR 13 <br> <br>// <br>// Note: UNICODE entry point and argv.  This way, we don't need to bother <br>// with converting commandline args to Unicode <br>// <br> <br>int <br>__cdecl <br>wmain( <br>    int argc, <br>    wchar_t *argv[] <br>    ) <br>{ <br>    LPWSTR DirectoryToShare; <br>    LPWSTR Sharename; <br>    LPWSTR Username; <br>    LPWSTR Server; <br> <br>    PSID pSid = NULL; <br>    DWORD cbSid; <br> <br>    WCHAR RefDomain[DNLEN + 1]; <br>    DWORD cchDomain = DNLEN + 1; <br>    SID_NAME_USE peUse; <br> <br>    SECURITY_DESCRIPTOR sd; <br>    PACL pDacl = NULL; <br>    DWORD dwAclSize; <br> <br>    SHARE_INFO_502 si502; <br>    NET_API_STATUS nas; <br> <br>    BOOL bSuccess = FALSE; // assume this function fails <br> <br>    if(argc &lt; 4) { <br>        printf("Usage: %ls &lt;directory&gt; &lt;sharename&gt; &lt;user/group&gt; [\\\\Server]\n", argv[0]); <br>        printf(" directory is fullpath of directory to share\n"); <br>        printf(" sharename is name of share on server\n"); <br>        printf(" user/group is an WinNT user/groupname (REDMOND\\sfield, Administrators, etc)\n"); <br>        printf(" optional Server is the name of the computer to create the share on\n"); <br>        printf("\nExample: %ls c:\\public public Everyone\n", argv[0]); <br>        printf("c:\\public shared as public granting Everyone full access\n"); <br>        printf("\nExample: %ls c:\\private cool$ REDMOND\\sfield \\\\WINBASE\n", argv[0]); <br>        printf("c:\\private on \\\\WINBASE shared as cool$ (hidden) granting REDMOND\\sfield access\n"); <br> <br>        return RTN_USAGE; <br>    } <br> <br>    // <br>    // since the commandline was Unicode, just provide pointers to <br>    // the relevant items <br>    // <br> <br>    DirectoryToShare = argv[1]; <br>    Sharename = argv[2]; <br>    Username = argv[3]; <br> <br>    if( argc &gt; 4 ) { <br>        Server = argv[4]; <br>    } else { <br>        Server = NULL; // local machine <br>    } <br> <br>    // <br>    // initial allocation attempt for Sid <br>    // <br>#define SID_SIZE 96 <br>    cbSid = SID_SIZE; <br> <br>    pSid = (PSID)HeapAlloc(GetProcessHeap(), 0, cbSid); <br>    if(pSid == NULL) { <br>        printf("HeapAlloc error!\n"); <br>        return RTN_ERROR; <br>    } <br> <br>    // <br>    // get the Sid associated with the supplied user/group name <br>    // force Unicode API since we always pass Unicode string <br>    // <br> <br>    if(!LookupAccountNameW( <br>        NULL,       // default lookup logic <br>        Username,   // user/group of interest from commandline <br>        pSid,       // Sid buffer <br>        &amp;cbSid,     // size of Sid <br>        RefDomain,  // Domain account found on (unused) <br>        &amp;cchDomain, // size of domain in chars <br>        &amp;peUse <br>        )) { <br> <br>        // <br>        // if the buffer wasn't large enough, try again <br>        // <br> <br>        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) { <br> <br>            pSid = (PSID)HeapReAlloc(GetProcessHeap(), 0, pSid, cbSid); <br> <br>            if(pSid == NULL) { <br>                printf("HeapReAlloc error!\n"); <br>                goto cleanup; <br>            } <br> <br>            cchDomain = DNLEN + 1; <br> <br>            if(!LookupAccountNameW( <br>                NULL,       // default lookup logic <br>                Username,   // user/group of interest from commandline <br>                pSid,       // Sid buffer <br>                &amp;cbSid,     // size of Sid <br>                RefDomain,  // Domain account found on (unused) <br>                &amp;cchDomain, // size of domain in chars <br>                &amp;peUse <br>                )) { <br>                    printf("LookupAccountName error! (rc=%lu)\n", GetLastError()); <br>                    goto cleanup; <br>                } <br> <br>        } else { <br>            printf("LookupAccountName error! (rc=%lu)\n", GetLastError()); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // <br>    // compute size of new acl <br>    // <br> <br>    dwAclSize = sizeof(ACL) + <br>        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) + <br>        GetLengthSid(pSid) ; <br> <br>    // <br>    // allocate storage for Acl <br>    // <br> <br>    pDacl = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize); <br>    if(pDacl == NULL) goto cleanup; <br> <br>    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) <br>        goto cleanup; <br> <br>    // <br>    // grant GENERIC_ALL (Full Control) access <br>    // <br> <br>    if(!AddAccessAllowedAce( <br>        pDacl, <br>        ACL_REVISION, <br>        GENERIC_ALL, <br>        pSid <br>        )) goto cleanup; <br> <br>    if(!InitializeSecurityDescriptor(&amp;sd, SECURITY_DESCRIPTOR_REVISION)) <br>        goto cleanup; <br> <br>    if(!SetSecurityDescriptorDacl(&amp;sd, TRUE, pDacl, FALSE)) { <br>        fprintf(stderr, "SetSecurityDescriptorDacl error! (rc=%lu)\n", <br>            GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // setup share info structure <br>    // <br> <br>    si502.shi502_netname = (LPTSTR) Sharename; <br>    si502.shi502_type = STYPE_DISKTREE; <br>    si502.shi502_remark = NULL; <br>    si502.shi502_permissions = 0; <br>    si502.shi502_max_uses = SHI_USES_UNLIMITED; <br>    si502.shi502_current_uses = 0; <br>    si502.shi502_path = (LPTSTR) DirectoryToShare; <br>    si502.shi502_passwd = NULL; <br>    si502.shi502_reserved = 0; <br>    si502.shi502_security_descriptor = &amp;sd; <br> <br>    nas = NetShareAdd( <br>        (LPTSTR) Server,         // share is on local machine <br>        502,            // info-level <br>        (LPBYTE)&amp;si502, // info-buffer <br>        NULL            // don't bother with parm <br>        ); <br> <br>    if(nas != NO_ERROR) { <br>        printf("NetShareAdd error! (rc=%lu)\n", nas); <br>        goto cleanup; <br>    } <br> <br>    bSuccess = TRUE; // indicate success <br> <br>cleanup: <br> <br>    // <br>    // free allocated resources <br>    // <br>    if(pDacl != NULL) <br>        HeapFree(GetProcessHeap(), 0, pDacl); <br> <br>    if(pSid != NULL) <br>        HeapFree(GetProcessHeap(), 0, pSid); <br> <br>    if(!bSuccess) { <br>        return RTN_ERROR; <br>    } <br> <br>    return RTN_OK; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
