<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4640"></a>MAIN.CXX</h2>
<pre><code>//---------------------------------------------------------------------------- <br>// <br>//  Microsoft Active Directory 1.1 Sample Code <br>// <br>//  Copyright (C) Microsoft Corporation, 1996 <br>// <br>//  File:       main.cxx <br>// <br>//  Contents:   Main for adsqry <br>// <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "main.hxx" <br> <br> <br>#define MAX_SIZE 10 <br>//  <br>// Globals representing the properties <br>// <br> <br>DBPROPSET          rgDBPropSet[MAX_SIZE], rgCmdPropSet[MAX_SIZE]; <br>DBPROP             rgDBProp[MAX_SIZE], rgCmdProp[MAX_SIZE]; <br> <br>ULONG              cDBPropSet, cCmdPropSet, cDBProp, cCmdProp; <br> <br>LPWSTR pszCommandText; <br> <br>GUID               rguidDialect = DBGUID_DEFAULT; <br> <br>DWORD cErr; <br> <br>int __cdecl <br>main( int argc, char ** argv) <br>{ <br> <br>    HRESULT            hr; <br>    ULONG              i, j; <br>    HROW             * phRows; <br> <br>    WCHAR              pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH]; <br>    DWORD              dwError; <br>                          <br>    OLECHAR          * szColNames = NULL; <br>    DBCOLUMNINFO     * prgColInfo = NULL; <br>    DBCOLUMNINFO     * rgInfo = NULL; <br>    WCHAR            * pStringBuffer = NULL; <br>    WCHAR            * pColInfoBuffer = NULL; <br> <br>    IMalloc          * pIMalloc = NULL; <br>    IDBInitialize    * pIDBInit = NULL; <br>    IDBCreateSession * pIDBCS = NULL; <br>    IDBCreateCommand * pIDBCreateCommand = NULL; <br>    ICommandText     * pICommandText = NULL; <br>    ICommand         * pICommand = NULL; <br>    IRowset          * pIRowset = NULL; <br>    IAccessor        * pAccessor = NULL; <br>    IColumnsInfo     * pIColsInfo = NULL; <br>    ULONG              cCol, cRowsObtained, nAttrs; <br> <br>    Data             * pMyData = NULL; <br>    DBBINDSTATUS     * pMyStatus = NULL; <br>    HACCESSOR          myAccessor = NULL; <br> <br>    ICommandProperties * pICommandProperties; <br>    IDBProperties * pIDBProperties; <br> <br> <br>    hr = ProcessArgs(argc, argv); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = CoInitialize(NULL); <br>    if (FAILED(hr)) { <br>        printf("CoInitialize failed\n"); <br>        exit(1); <br>    } <br> <br>    // <br>    // Instantiate a data source object for LDAP provider <br>    // <br>    hr = CoCreateInstance( <br>             CLSID_ADsDSOObject, <br>             0, <br>             CLSCTX_INPROC_SERVER, <br>             IID_IDBInitialize, <br>             (void **)&amp;pIDBInit <br>             ); <br>    if(FAILED(hr)) { <br>        printf("CoCreateInstance failed \n"); <br>        goto error; <br>    } <br> <br>    // <br>    // Initialize the Data Source <br>    // <br>    hr = pIDBInit-&gt;Initialize(); <br>    if(FAILED(hr)) { <br>        printf("IDBIntialize::Initialize failed \n"); <br>        goto error; <br>    } <br> <br>    if (cDBPropSet) { <br>        pIDBInit-&gt;QueryInterface( <br>            IID_IDBProperties, <br>            (void**) &amp;pIDBProperties); <br>        if(FAILED(hr)) { <br>            printf("QueryInterface for IDBProperties failed \n"); <br>            goto error; <br>        } <br>     <br>        hr = pIDBProperties-&gt;SetProperties( <br>                 cDBPropSet, <br>                 rgDBPropSet); <br>     <br>        if(FAILED(hr)) { <br>            printf("IDBProperties-&gt;SetProperties failed \n"); <br>            goto error; <br>        } <br>     <br>        FREE_INTERFACE(pIDBProperties); <br>    } <br> <br>    pIDBInit-&gt;QueryInterface( <br>        IID_IDBCreateSession, <br>        (void**) &amp;pIDBCS); <br>    if(FAILED(hr)) { <br>        printf("QueryInterface for IDBCreateSession failed \n"); <br>        goto error; <br>    } <br> <br>    FREE_INTERFACE(pIDBInit); <br> <br>    // <br>    // Create a session returning a pointer to its CreateCommand interface <br>    // <br>    hr = pIDBCS-&gt;CreateSession( <br>             NULL, <br>             IID_IDBCreateCommand, <br>             (LPUNKNOWN*) &amp;pIDBCreateCommand <br>             ); <br>    if(FAILED(hr)) { <br>        printf("IDBCreateSession::CreateSession failed \n"); <br>        goto error; <br>    } <br> <br>    FREE_INTERFACE(pIDBCS); <br> <br>    // <br>    // Create a command from the session object <br>    // <br>    hr = pIDBCreateCommand-&gt;CreateCommand( <br>             NULL, <br>             IID_ICommandText, <br>             (LPUNKNOWN*) &amp;pICommandText <br>             ); <br> <br>    if(FAILED(hr)) { <br>        printf(" IDBCreateCommand::CreateCommand failed\n"); <br>        goto error; <br>    } <br> <br>    FREE_INTERFACE(pIDBCreateCommand); <br> <br>    // <br>    // Set the CommandText for the Query <br>    // <br>    hr = pICommandText-&gt;SetCommandText( <br>             rguidDialect, <br>             pszCommandText <br>             ); <br> <br>    if(FAILED(hr)) { <br>        printf("ICommandText::SetCommandText failed \n"); <br>        goto error; <br>    } <br> <br> <br>    if (cCmdPropSet) { <br>        hr = pICommandText-&gt;QueryInterface( <br>                 IID_ICommandProperties, <br>                 (void**) &amp;pICommandProperties); <br>     <br>        if(FAILED(hr)) { <br>            printf("QueryInterface for ICommandProperties failed \n"); <br>            goto error; <br>        } <br>     <br>        hr = pICommandProperties-&gt;SetProperties( <br>                 cCmdPropSet, <br>                 rgCmdPropSet); <br>     <br>        if(FAILED(hr)) { <br>            printf("ICommandProperties:;SetProperties failed \n"); <br>            goto error; <br>        } <br>     <br>        FREE_INTERFACE(pICommandProperties); <br>    } <br> <br>    hr = pICommandText-&gt;QueryInterface( <br>             IID_ICommand, <br>             (void**) &amp;pICommand); <br> <br>    if(FAILED(hr)) { <br>        printf("QueryInterface for ICommand failed \n"); <br>        goto error; <br>    } <br> <br>    FREE_INTERFACE(pICommandText); <br> <br>    // <br>    // Do the Query and get back a rowset <br>    // <br>    hr = pICommand-&gt;Execute( <br>             NULL, <br>             IID_IRowset, <br>             NULL, <br>             NULL, <br>             (LPUNKNOWN *)&amp;pIRowset <br>             ); <br>    if(FAILED(hr)) { <br>        printf("ICommand::Execute failed \n"); <br>        goto error; <br>    } <br> <br>    FREE_INTERFACE(pICommand); <br> <br>    hr = pIRowset-&gt;QueryInterface( <br>             IID_IColumnsInfo, <br>             (void**) &amp;pIColsInfo <br>             ); <br>    if(FAILED(hr)) { <br>        printf("QueryInterface for IColumnsInfo failed \n"); <br>        goto error; <br>    } <br> <br>    hr = pIColsInfo-&gt;GetColumnInfo( <br>             &amp;cCol, <br>             &amp;prgColInfo, <br>             &amp;szColNames <br>             ); <br>    if(FAILED(hr)) { <br>        printf("IColumnsInfo::GetColumnInfo failed \n"); <br>        goto error; <br>    } <br> <br>    // <br>    // The no. of attributes is one less than the no. of columns because of <br>    // the Bookmark column <br>    // <br>    nAttrs = cCol - 1; <br> <br> <br>    pMyStatus = (DBBINDSTATUS *) LocalAlloc( <br>                                     LPTR, <br>                                     sizeof(DBBINDSTATUS) * nAttrs <br>                                     ); <br>    BAIL_ON_NULL(pMyStatus); <br> <br>    hr = CreateAccessorHelper( <br>             pIRowset, <br>             nAttrs, <br>             prgColInfo, <br>             &amp;myAccessor, <br>             pMyStatus <br>             ); <br>    if(FAILED(hr)) { <br>        printf("CreateAccessorHelper failed \n"); <br>        goto error; <br>    } <br> <br> <br>    pMyData = (Data *) LocalAlloc( <br>                           LPTR, <br>                           sizeof(Data) * nAttrs <br>                           ); <br>    if(!pMyData) { <br>        hr = E_OUTOFMEMORY; <br>        goto error; <br>    } <br> <br>    // <br>    //  Get the rows; 256 at a time <br>    // <br>    phRows = NULL; <br>    hr = pIRowset-&gt;GetNextRows( <br>             NULL, <br>             0, <br>             256, <br>             &amp;cRowsObtained, <br>             &amp;phRows <br>             ); <br>    if(FAILED(hr)) { <br>        printf("IRowset::GetNextRows failed \n"); <br>        goto error; <br>    } <br> <br>    j = cRowsObtained; <br>    while (cRowsObtained) { <br>        for (i = 0; i &lt; cRowsObtained; i++) { <br>            // <br>            // Get the data from each row <br>            // <br>            hr = pIRowset-&gt;GetData( <br>                     phRows[i], <br>                     myAccessor, <br>                     (void*)pMyData <br>                     ); <br>            if(FAILED(hr)) { <br>                printf("IRowset::GetData failed \n"); <br>                goto error; <br>            } <br>     <br>            PrintData(pMyData, nAttrs, prgColInfo); <br>        } <br> <br>        pIRowset-&gt;ReleaseRows( <br>                      cRowsObtained,  <br>                      phRows, <br>                      NULL, <br>                      NULL, <br>                      NULL <br>                      ); <br> <br>        // <br>        // Get the next 256 rows <br>        //        <br> <br>        hr = pIRowset-&gt;GetNextRows( <br>                 NULL, <br>                 0, <br>                 256, <br>                 &amp;cRowsObtained, <br>                 &amp;phRows <br>                 ); <br>        if(FAILED(hr)) { <br>            printf("IRowset::GetNextRows failed \n"); <br>            goto error; <br>        } <br>        j+=cRowsObtained; <br>    } <br> <br> <br>    printf("Rows printed = %d\n", j); <br> <br>    FREE_STRING(pszCommandText); <br> <br>    CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc); <br>    IMALLOC_FREE(pIMalloc, prgColInfo); <br>    IMALLOC_FREE(pIMalloc, szColNames); <br> <br>    FREE_INTERFACE(pIMalloc); <br>    FREE_INTERFACE(pAccessor); <br>    FREE_INTERFACE(pIColsInfo); <br>    FREE_INTERFACE(pIRowset); <br> <br>    LOCAL_FREE(pMyStatus); <br>    LOCAL_FREE(pMyData); <br> <br>    // <br>    // Uninitialize OLE. <br>    // <br>    CoUninitialize(); <br> <br>    exit(0); <br> <br>error: <br> <br> <br>    CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc); <br>    IMALLOC_FREE(pIMalloc, prgColInfo); <br>    IMALLOC_FREE(pIMalloc, szColNames); <br> <br>    FREE_STRING(pszCommandText); <br> <br>    FREE_INTERFACE(pIMalloc); <br>    FREE_INTERFACE(pIDBInit); <br>    FREE_INTERFACE(pIDBCS); <br>    FREE_INTERFACE(pIDBCreateCommand); <br>    FREE_INTERFACE(pICommandText); <br>    FREE_INTERFACE(pICommand); <br>    FREE_INTERFACE(pIRowset); <br>    FREE_INTERFACE(pIColsInfo); <br>    FREE_INTERFACE(pAccessor); <br> <br>    LOCAL_FREE(pMyStatus); <br>    LOCAL_FREE(pMyData); <br> <br>    printf("Errors stopped the Query; hr = %x", hr); <br> <br>    if(hr == ERROR_EXTENDED_ERROR) { <br>        hr = ADsGetLastError( <br>                 &amp;dwError, <br>                 pszErrorBuf, <br>                 MAX_PATH, <br>                 pszNameBuf, <br>                 MAX_PATH <br>                 ); <br>    } <br> <br>    if(SUCCEEDED(hr)) { <br>        wprintf(L"Error in %s; %s\n", pszNameBuf, pszErrorBuf); <br>    } <br> <br>    exit(1); <br>    return(0); <br>} <br> <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   ProcessArgs <br>// <br>//  Synopsis: <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT  <br>ProcessArgs( <br>    int argc, <br>    char * argv[] <br>    ) <br>{ <br>    argc--; <br>    int currArg = 1; <br>    LPWSTR pTemp = NULL; <br>    char *pszCurrPref = NULL, *pszCurrPrefValue = NULL; <br> <br>    LPWSTR pszSearchBase = NULL, pszSearchFilter = NULL, pszAttrList = NULL; <br>    LPWSTR pszUserName = NULL, pszPassword = NULL; <br>    DWORD dwAuthFlags; <br> <br>    cCmdProp = cDBProp = 0; <br> <br>    while (argc) { <br>        if (argv[currArg][0] != '/' &amp;&amp; argv[currArg][0] != '-')  <br>            BAIL_ON_FAILURE (E_FAIL); <br>        switch (argv[currArg][1]) { <br>        case 'b': <br>            argc--; <br>            currArg++; <br>            if (argc &lt;= 0) <br>                BAIL_ON_FAILURE (E_FAIL); <br>            pszSearchBase = AllocateUnicodeString(argv[currArg]); <br>            BAIL_ON_NULL(pszSearchBase); <br>            break; <br> <br>        case 'f': <br>            argc--; <br>            currArg++; <br>            if (argc &lt;= 0) <br>                BAIL_ON_FAILURE (E_FAIL); <br>            pszSearchFilter = AllocateUnicodeString(argv[currArg]); <br>            BAIL_ON_NULL(pszSearchFilter); <br>            break; <br> <br>        case 'd': <br>            argc--; <br>            currArg++; <br>            if (argc &lt;= 0) <br>                BAIL_ON_FAILURE (E_FAIL); <br> <br>            if (!_stricmp(argv[currArg], "sql"))  <br>                rguidDialect = DBGUID_SQL;      <br>            else if (!_stricmp(argv[currArg], "ldap"))  <br>                rguidDialect = DBGUID_LDAPDialect;      <br>            else if (!_stricmp(argv[currArg], "default"))  <br>                rguidDialect = DBGUID_DEFAULT;      <br>            else  <br>                BAIL_ON_FAILURE (E_FAIL); <br> <br>            break; <br> <br>        case 'a': <br>            argc--; <br>            currArg++; <br>            if (argc &lt;= 0) <br>                BAIL_ON_FAILURE (E_FAIL); <br>            pszAttrList = AllocateUnicodeString(argv[currArg]); <br>            BAIL_ON_NULL(pszAttrList); <br> <br>            break; <br> <br>        case 'u': <br>            argc--; <br>            currArg++; <br>            if (argc &lt;= 0) <br>                BAIL_ON_FAILURE (E_FAIL); <br>            pszUserName = AllocateUnicodeString(argv[currArg]); <br>            BAIL_ON_NULL(pszUserName); <br>            argc--; <br>            currArg++; <br>            if (argc &lt;= 0) <br>                BAIL_ON_FAILURE (E_FAIL); <br>            pszPassword = AllocateUnicodeString(argv[currArg]); <br>            BAIL_ON_NULL(pszPassword); <br> <br>            rgDBProp[cDBProp].dwPropertyID = DBPROP_AUTH_USERID; <br>            rgDBProp[cDBProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>            rgDBProp[cDBProp].vValue.vt = VT_BSTR; <br>            V_BSTR (&amp;rgDBProp[cDBProp].vValue) = SysAllocString(pszUserName); <br>            cDBProp++; <br> <br> <br>            rgDBProp[cDBProp].dwPropertyID = DBPROP_AUTH_PASSWORD; <br>            rgDBProp[cDBProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>            rgDBProp[cDBProp].vValue.vt = VT_BSTR; <br>            V_BSTR (&amp;rgDBProp[cDBProp].vValue) = SysAllocString(pszPassword); <br>            cDBProp++; <br> <br>            break; <br> <br>        case 'p': <br>            argc--; <br>            currArg++; <br>            if (argc &lt;= 0) <br>                BAIL_ON_FAILURE (E_FAIL); <br> <br>            pszCurrPref = strtok(argv[currArg], "="); <br>            pszCurrPrefValue = strtok(NULL, "="); <br>            if (!pszCurrPref || !pszCurrPrefValue)  <br>                BAIL_ON_FAILURE(E_FAIL); <br> <br>            if (!_stricmp(pszCurrPref, "asynchronous")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_ASYNCHRONOUS; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_BOOL; <br>                if (!_stricmp(pszCurrPrefValue, "yes" ))  <br>                    V_BOOL (&amp;rgCmdProp[cCmdProp].vValue) = VARIANT_TRUE; <br>                else if (!_stricmp(pszCurrPrefValue, "no" ))  <br>                    V_BOOL (&amp;rgCmdProp[cCmdProp].vValue) = VARIANT_FALSE; <br>                else  <br>                    BAIL_ON_FAILURE(E_FAIL); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "attrTypesOnly")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_ATTRIBTYPES_ONLY; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_BOOL; <br>                if (!_stricmp(pszCurrPrefValue, "yes" ))  <br>                    V_BOOL (&amp;rgCmdProp[cCmdProp].vValue) = VARIANT_TRUE; <br>                else if (!_stricmp(pszCurrPrefValue, "no" ))  <br>                    V_BOOL (&amp;rgCmdProp[cCmdProp].vValue) = VARIANT_FALSE; <br>                else  <br>                    BAIL_ON_FAILURE(E_FAIL); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "SecureAuth")) { <br>                if (!_stricmp(pszCurrPrefValue, "yes" ))  <br>                    dwAuthFlags |= ADS_SECURE_AUTHENTICATION; <br>                else if (!_stricmp(pszCurrPrefValue, "no" ))  <br>                    dwAuthFlags &amp;= ~ADS_SECURE_AUTHENTICATION; <br>                else  <br>                    BAIL_ON_FAILURE(E_FAIL); <br> <br>                rgDBProp[cDBProp].dwPropertyID = DBPROP_AUTH_ENCRYPT_PASSWORD; <br>                rgDBProp[cDBProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgDBProp[cDBProp].vValue.vt = VT_BSTR; <br>                V_BSTR (&amp;rgDBProp[cDBProp].vValue) = SysAllocString(pszPassword); <br>                cDBProp++; <br>     <br>            } <br>            else if (!_stricmp(pszCurrPref, "derefAliases")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_DEREF_ALIASES; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_BOOL; <br>                if (!_stricmp(pszCurrPrefValue, "yes" ))  <br>                    V_BOOL (&amp;rgCmdProp[cCmdProp].vValue) = VARIANT_TRUE; <br>                else if (!_stricmp(pszCurrPrefValue, "no" ))  <br>                    V_BOOL (&amp;rgCmdProp[cCmdProp].vValue) = VARIANT_FALSE; <br>                else  <br>                    BAIL_ON_FAILURE(E_FAIL); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "timeOut")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_TIMEOUT; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_I4; <br>                V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue); <br>                cCmdProp++; <br>            }                                          <br>            else if (!_stricmp(pszCurrPref, "timeLimit")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_TIME_LIMIT; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_I4; <br>                V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "sizeLimit")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_SIZE_LIMIT; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_I4; <br>                V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "PageSize")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_PAGESIZE; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_I4; <br>                V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "PagedTimeLimit")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_PAGED_TIME_LIMIT; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_I4; <br>                V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "SearchScope")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_SEARCH_SCOPE; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_I4; <br>                if (!_stricmp(pszCurrPrefValue, "Base" ))  <br>                    V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = ADS_SCOPE_BASE; <br>                else if (!_stricmp(pszCurrPrefValue, "OneLevel" ))  <br>                    V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = ADS_SCOPE_ONELEVEL; <br>                else if (!_stricmp(pszCurrPrefValue, "Subtree" ))  <br>                    V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = ADS_SCOPE_SUBTREE; <br>                else  <br>                    BAIL_ON_FAILURE(E_FAIL); <br>                cCmdProp++; <br>            } <br>            else if (!_stricmp(pszCurrPref, "ChaseReferrals")) { <br>                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_CHASE_REFERRALS; <br>                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED; <br>                rgCmdProp[cCmdProp].vValue.vt = VT_I4; <br>                if (!_stricmp(pszCurrPrefValue, "always" )) <br>                    V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_ALWAYS; <br>                else if (!_stricmp(pszCurrPrefValue, "never" )) <br>                    V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_NEVER; <br>                else if (!_stricmp(pszCurrPrefValue, "external" )) <br>                    V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_EXTERNAL; <br>                else if (!_stricmp(pszCurrPrefValue, "subordinate" )) <br>                    V_I4 (&amp;rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_SUBORDINATE; <br>                else <br>                    BAIL_ON_FAILURE(E_FAIL); <br>                cCmdProp++; <br>            } <br>            else  <br>                BAIL_ON_FAILURE(E_FAIL); <br> <br>            break; <br> <br>        default:  <br>            BAIL_ON_FAILURE(E_FAIL); <br>        } <br> <br>        argc--; <br>        currArg++; <br>    } <br> <br>    // <br>    // Check for Mandatory arguments; <br>    // <br> <br>    if (!pszSearchBase || !pszSearchFilter || !pszAttrList)  <br>        BAIL_ON_FAILURE(E_FAIL); <br> <br>    if (IsEqualGUID(rguidDialect, DBGUID_SQL) ) { <br>          <br>        pszCommandText = (LPWSTR) AllocADsMem( <br>                                      (wcslen(pszSearchBase) + <br>                                      wcslen(pszSearchFilter) + <br>                                      wcslen(pszAttrList) + <br>                                      wcslen(L"''") + <br>                                      wcslen(L"SELECT ") +  <br>                                      wcslen(L" FROM ") +  <br>                                      wcslen(L" WHERE ") +  <br>                                      1) * sizeof(WCHAR) <br>                                      ); <br>        BAIL_ON_NULL(E_FAIL); <br>     <br>        wsprintf(pszCommandText,  <br>                 L"SELECT %s FROM '%s' WHERE %s",  <br>                 pszAttrList, <br>                 pszSearchBase,  <br>                 pszSearchFilter <br>                 ); <br>     <br>    } else { <br> <br>        pszCommandText = (LPWSTR) AllocADsMem( <br>                                      (wcslen(pszSearchBase) + <br>                                      wcslen(pszSearchFilter) + <br>                                      wcslen(pszAttrList) + <br>                                      5) * sizeof(WCHAR) <br>                                      ); <br>        BAIL_ON_NULL(E_FAIL); <br>     <br>        wsprintf(pszCommandText,  <br>                 L"&lt;%s&gt;;%s;%s",  <br>                 pszSearchBase,  <br>                 pszSearchFilter, <br>                 pszAttrList <br>                 ); <br> <br>    } <br>    if (cDBProp &gt; 0) { <br>        cDBPropSet = 1; <br>        rgDBPropSet[0].rgProperties    = rgDBProp; <br>        rgDBPropSet[0].cProperties     = cDBProp; <br>        rgDBPropSet[0].guidPropertySet = DBPROPSET_DBINIT; <br>    } <br> <br>    if (cCmdProp &gt; 0) { <br>        cCmdPropSet = 1; <br>        rgCmdPropSet[0].rgProperties    = rgCmdProp; <br>        rgCmdPropSet[0].cProperties     = cCmdProp; <br>        rgCmdPropSet[0].guidPropertySet = DBPROPSET_ADSISEARCH; <br>    } <br> <br>    FreeUnicodeString(pszSearchBase) ; <br>    FreeUnicodeString(pszSearchFilter) ; <br>    FreeUnicodeString(pszAttrList) ; <br> <br>    return (S_OK); <br> <br>error: <br> <br>    FreeUnicodeString(pszSearchBase) ; <br>    FreeUnicodeString(pszSearchFilter) ; <br>    FreeUnicodeString(pszAttrList) ; <br> <br>    PrintUsage(); <br>    return E_FAIL; <br>     <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
