<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUM.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4635"></a>ENUM.CXX</h2>
<pre><code>//---------------------------------------------------------------------------- <br>// <br>//  Microsoft Active Directory 1.0 Sample Code <br>// <br>//  Copyright (C) Microsoft Corporation, 1996 <br>// <br>//  File:       enum.cxx <br>// <br>//  Contents:   Active Drectory container enumeration <br>// <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "main.hxx" <br> <br> <br>// <br>// Private defines <br>// <br> <br>#define MAX_ADS_FILTERS   10 <br>#define MAX_ADS_ENUM      100     // number of entries to read each time <br> <br> <br>// <br>// Local functions <br>// <br> <br> <br>HRESULT <br>PrintLongFormat( <br>    IADs * pObject <br>    ); <br> <br>// <br>//  List contents of a container identified by the ADsPath <br>// <br> <br>int <br>DoList(char * AnsiADsPath) <br>{ <br>    HRESULT hr; <br>    int i = 0 ; <br>    LPWSTR pszADsPath, apszTypes[MAX_ADS_FILTERS] ; <br> <br>    if (!(pszADsPath = AllocateUnicodeString(AnsiADsPath))) { <br> <br>        return(1) ; <br>    } <br> <br>    apszTypes[0] = NULL ; <br> <br>    // <br>    //  Filter may be set as follows. For example, to get users and group: <br>    // <br>    //  apszTypes[0] = L"User" ; <br>    //  apszTypes[1] = L"Group" ; <br>    //  apszTypes[2] = NULL ; <br>    // <br> <br>    hr = EnumObject( <br>             pszADsPath, <br>             apszTypes, <br>             i <br>             ); <br> <br>    return (FAILED(hr) ? 1 : 0) ; <br>} <br> <br>// <br>// Enumerates the contents of a container object. <br>// <br> <br>HRESULT <br>EnumObject( <br>    LPWSTR pszADsPath, <br>    LPWSTR * lppClassNames, <br>    DWORD dwClassNames <br>    ) <br>{ <br>    ULONG cElementFetched = 0L; <br>    IEnumVARIANT * pEnumVariant = NULL; <br>    VARIANT VarFilter, VariantArray[MAX_ADS_ENUM]; <br> <br>    HRESULT hr; <br>    IADsContainer * pADsContainer =  NULL; <br>    DWORD dwObjects = 0, dwEnumCount = 0, i = 0; <br>    BOOL  fContinue = TRUE; <br> <br> <br>    VariantInit(&amp;VarFilter); <br> <br>    hr = ADsGetObject( <br>                pszADsPath, <br>                IID_IADsContainer, <br>                (void **)&amp;pADsContainer <br>                ); <br> <br>    if (FAILED(hr)) { <br> <br>        printf("\"%S\" is not a valid container object.\n", pszADsPath) ; <br>        goto exitpoint ; <br>    } <br> <br> <br>    hr = ADsBuildVarArrayStr( <br>                lppClassNames, <br>                dwClassNames, <br>                &amp;VarFilter <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br> <br>    hr = pADsContainer-&gt;put_Filter(VarFilter); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = ADsBuildEnumerator( <br>            pADsContainer, <br>            &amp;pEnumVariant <br>            ); <br>    BAIL_ON_FAILURE(hr); <br> <br> <br> <br>    while (fContinue) { <br> <br>        IADs *pObject ; <br> <br>        hr = ADsEnumerateNext( <br>                    pEnumVariant, <br>                    MAX_ADS_ENUM, <br>                    VariantArray, <br>                    &amp;cElementFetched <br>                    ); <br> <br>        if (hr == S_FALSE) { <br>            fContinue = FALSE; <br>        } <br> <br>        dwEnumCount++; <br> <br>        for (i = 0; i &lt; cElementFetched; i++ ) { <br> <br>            IDispatch *pDispatch = NULL; <br> <br>            pDispatch = VariantArray[i].pdispVal; <br> <br>            hr = pDispatch-&gt;QueryInterface(IID_IADs, <br>                                           (VOID **) &amp;pObject) ; <br>            BAIL_ON_FAILURE(hr); <br> <br>            PrintLongFormat(pObject); <br> <br>            pObject-&gt;Release(); <br>            pDispatch-&gt;Release(); <br>        } <br> <br>        memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM); <br> <br>        dwObjects += cElementFetched; <br> <br>    } <br> <br>    printf("Total Number of Objects enumerated is %d\n", dwObjects); <br> <br>    if (pEnumVariant) { <br>        pEnumVariant-&gt;Release(); <br>    } <br> <br>    if (pADsContainer) { <br>        pADsContainer-&gt;Release(); <br>    } <br> <br>    return(S_OK); <br> <br>error: <br>    if (FAILED(hr)) { <br> <br>        printf("Unable to list contents of: %S\n", pszADsPath) ; <br>    } <br> <br>exitpoint: <br> <br>    if (pEnumVariant) { <br>        pEnumVariant-&gt;Release(); <br>    } <br> <br>    VariantClear(&amp;VarFilter); <br> <br> <br>    if (pADsContainer) { <br>        pADsContainer-&gt;Release(); <br>    } <br> <br>    return(hr); <br>} <br> <br>HRESULT <br>PrintLongFormat(IADs * pObject) <br>{ <br> <br>    HRESULT hr = S_OK; <br>    BSTR bstrName = NULL; <br>    BSTR bstrClass = NULL; <br>    BSTR bstrSchema = NULL; <br> <br>    hr = pObject-&gt;get_Name(&amp;bstrName) ; <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = pObject-&gt;get_Class(&amp;bstrClass); <br>    BAIL_ON_FAILURE(hr); <br> <br>    // hr = pObject-&gt;get_Schema(&amp;bstrSchema); <br> <br>    printf("  %S(%S)\n", bstrName, bstrClass) ; <br> <br>error: <br>    if (bstrClass) { <br>        SysFreeString(bstrClass); <br>    } <br>    if (bstrName) { <br>        SysFreeString(bstrName); <br>    } <br>    if (bstrSchema) { <br>        SysFreeString(bstrSchema); <br>    } <br>    return(hr); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
