<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4641"></a>UTIL.CXX</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// <br>//  Microsoft Active Directory 1.1 Sample Code <br>// <br>//  Copyright (C) Microsoft Corporation, 1992 - 1995 <br>// <br>//  File:  util.cxx <br>// <br>//  Contents:  Ansi to Unicode conversions and misc helper functions <br>// <br>//----------------------------------------------------------------------------//------------------------------------------------------------------------------ <br> <br>#include "main.hxx" <br> <br>void <br>PrintUsage( <br>    void <br>    ) <br>{ <br> <br>    printf("\nUsage: adsqry /b &lt;baseObject&gt; /f &lt;search_filter&gt; /a &lt;attrlist&gt; [/p &lt;preference=value&gt;] "); <br>    printf(" [/u &lt;UserName&gt; &lt;Password&gt;] /d &lt;dialect&gt; \n"); <br>    printf("\n   where:\n" ); <br>    printf("   baseObject     = ADsPath of the base of the search\n"); <br>    printf("   search_filter  = search filter string in LDAP format\n" ); <br>    printf("   attrlist       = list of the attributes to display\n" ); <br>    printf("   dialect is one of \"ldap\", \"sql\", or \"default\"\n"); <br>    printf("   preference could be one of:\n"); <br>    printf("   Asynchronous, AttrTypesOnly, DerefAliases, SizeLimit, TimeLimit,\n"); <br>    printf("   TimeOut, PageSize, SearchScope, SecureAuth and EncryptPassword\n"); <br>    printf("   value is yes/no for a Boolean and the respective integer for integers\n"); <br>    printf("   scope is one of \"Base\", \"OneLevel\", or \"Subtree\"\n"); <br> <br>    printf("\nFor Example: adsqry /b \"LDAP://server1/O=Internet/DC=COM/"); <br>    printf("DC=MyCompany/DC=MyDivision\"  /f \"(objectClass=Group)\" /a \"ADsPath, name, description\" "); <br>    printf(" /u \"CN=FooUser,CN=Users,DC=MyDivision,DC=MyCompany,DC=COM,O=INTERNET\" \"Password\" \n"); <br> <br>    printf("\nFor Example: adsqry /b \"LDAP://O=Internet/DC=COM/"); <br>    printf("DC=MyCompany/DC=MyDivision\"  /f \"objectClass='Group'\" /a \"ADsPath, name, description\" "); <br>    printf(" /d sql /u \"CN=FooUser,CN=Users,DC=MyDivision,DC=MyCompany,DC=COM,O=INTERNET\" \"Password\" \n"); <br> <br>} <br> <br> <br>// <br>// Form the bindings array to specify the way the provider has to put the <br>// data in consumer's buffers; Create the Accessor from the bindings <br>// <br>HRESULT <br>CreateAccessorHelper( <br>    IRowset *pIRowset, <br>    ULONG nAttrs, <br>    DBCOLUMNINFO *prgColInfo, <br>    HACCESSOR *phAccessor, <br>    DBBINDSTATUS *pBindStatus <br>    ) <br>{ <br> <br>    DBBINDING *prgBindings = NULL; <br>    HRESULT hr; <br>    ULONG i; <br>    IAccessor *pIAccessor = NULL; <br> <br>    if(!phAccessor || !pBindStatus) <br>        return(E_INVALIDARG); <br> <br>    prgBindings = (DBBINDING *) LocalAlloc( <br>                                   LPTR, <br>                                   sizeof(DBBINDING) * nAttrs <br>                                   ); <br>    BAIL_ON_NULL(prgBindings); <br> <br>    // <br>    // Set up rest of the attributes <br>    // <br>    for (i=0; i &lt; nAttrs; i++) { <br>        prgBindings[i].iOrdinal = i+1; <br>        prgBindings[i].wType= prgColInfo[i+1].wType; <br>        if (prgBindings[i].wType == DBTYPE_DATE || prgBindings[i].wType == DBTYPE_I8) <br>            prgBindings[i].obValue = sizeof(Data)*i + offsetof(Data, obValue2); <br>        else <br>            prgBindings[i].obValue = sizeof(Data)*i + offsetof(Data, obValue); <br>        prgBindings[i].obLength= sizeof(Data)*i + offsetof(Data, obLength); <br>        prgBindings[i].obStatus= sizeof(Data)*i + offsetof(Data, status); <br>        prgBindings[i].dwPart= DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS; <br> <br>        if(prgBindings[i].wType &amp; DBTYPE_BYREF) <br>            prgBindings[i].dwMemOwner= DBMEMOWNER_PROVIDEROWNED; <br>        else  <br>            prgBindings[i].dwMemOwner= DBMEMOWNER_CLIENTOWNED; <br> <br>        prgBindings[i].dwFlags= 0; <br>    } <br> <br> <br>    hr= pIRowset-&gt;QueryInterface( <br>           IID_IAccessor, <br>           (void**) &amp;pIAccessor <br>           ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    // <br>    // With the bindings create the accessor <br>    // <br>    hr = pIAccessor-&gt;CreateAccessor( <br>             DBACCESSOR_ROWDATA, <br>             nAttrs, <br>             prgBindings, <br>             0, <br>             phAccessor, <br>             pBindStatus <br>             ); <br> <br>    pIAccessor-&gt;Release(); <br>    LOCAL_FREE(prgBindings); <br> <br>    return(hr); <br> <br>error: <br>    LOCAL_FREE(prgBindings); <br> <br>    return(hr); <br> <br>} <br> <br>// <br>// Print the data depending on its type. <br>// <br> <br>void <br>PrintData( <br>    Data *prgData, <br>    ULONG nAttrs, <br>    DBCOLUMNINFO *prgColInfo <br>    ) <br>{ <br> <br>    ULONG i, j; <br>    HRESULT hr; <br> <br>    for (i=0; i &lt; nAttrs; i++) { <br> <br>        if(prgData[i].status == DBSTATUS_S_OK) { <br> <br>            switch(prgColInfo[i+1].wType) { <br>                case DBTYPE_I4: <br>                    wprintf( <br>                        L"%s = %d \n", <br>                        prgColInfo[i+1].pwszName, <br>                        (DWORD) prgData[i].obValue <br>                        ); <br>                    break; <br> <br>                case DBTYPE_I8: <br>                    wprintf( <br>                        L"%s = %I64d \n", <br>                        prgColInfo[i+1].pwszName, <br>                        *((__int64 *) &amp;prgData[i].obValue2) <br>                        ); <br>                    break; <br> <br>                case DBTYPE_BOOL: <br>                    wprintf( <br>                        L"%s = %s \n", <br>                        prgColInfo[i+1].pwszName, <br>                        *((VARIANT_BOOL *) &amp;(prgData[i].obValue)) == VARIANT_TRUE ?  <br>                        L"TRUE" : L"FALSE" <br>                        ); <br>                    break; <br> <br>                case DBTYPE_STR | DBTYPE_BYREF: <br>                    wprintf( <br>                        L"%s = ", <br>                        prgColInfo[i+1].pwszName <br>                        ); <br>                    printf( <br>                        "%s \n", <br>                        (char *)prgData[i].obValue <br>                        ); <br>                    break; <br> <br>                case DBTYPE_BYTES | DBTYPE_BYREF: <br>                    wprintf( <br>                        L"%s = ", <br>                        prgColInfo[i+1].pwszName <br>                        ); <br>                    for (j=0; j&lt;prgData[i].obLength; j++) { <br>                        printf( <br>                            "%x", <br>                            ((BYTE *)prgData[i].obValue)[j] <br>                            ); <br>                    } <br>                    printf("\n"); <br>                    break; <br> <br>                case DBTYPE_WSTR | DBTYPE_BYREF: <br>                    wprintf( <br>                        L"%s = %s \n", <br>                        prgColInfo[i+1].pwszName, <br>                        (WCHAR *) prgData[i].obValue <br>                        ); <br>                    break; <br> <br>                    case DBTYPE_DATE: <br>                    wprintf( <br>                        L"%s = %e \n", <br>                        prgColInfo[i+1].pwszName, <br>                        prgData[i].obValue2 <br>                        ); <br>                break; <br> <br>                case DBTYPE_VARIANT | DBTYPE_BYREF:  <br>                    wprintf( <br>                        L"%s = ", <br>                        prgColInfo[i+1].pwszName <br>                        ); <br> <br>                    ULONG dwSLBound; <br>                    ULONG dwSUBound; <br>                    void HUGEP *pArray; <br>                    VARIANT *pVariant; <br> <br>                    pArray = NULL; <br> <br>                    pVariant = (VARIANT*) prgData[i].obValue; <br>                 <br>                    if( !(pVariant-&gt;vt &amp; VT_ARRAY))  <br>                        BAIL_ON_FAILURE(hr = E_FAIL); <br>                 <br>                    hr = SafeArrayGetLBound(V_ARRAY(pVariant), <br>                                            1, <br>                                            (long FAR *) &amp;dwSLBound ); <br>                    BAIL_ON_FAILURE(hr); <br>                 <br>                    hr = SafeArrayGetUBound(V_ARRAY(pVariant), <br>                                            1, <br>                                            (long FAR *) &amp;dwSUBound ); <br>                    BAIL_ON_FAILURE(hr); <br>                 <br>                    hr = SafeArrayAccessData( V_ARRAY(pVariant), <br>                                              &amp;pArray ); <br>                    BAIL_ON_FAILURE(hr); <br> <br>                    for (j=dwSLBound; j&lt;=dwSUBound; j++) { <br>                        switch(pVariant-&gt;vt &amp; ~VT_ARRAY) { <br>                        case VT_BSTR: <br>                            wprintf( <br>                                L"%s  #  ", <br>                                ((BSTR *)pArray)[j] <br>                                ); <br>                            break; <br>                        case VT_I4: <br>                            wprintf( <br>                                L"%d #  ", <br>                                ((DWORD *) pArray)[j] <br>                                ); <br>                            break; <br>                        case VT_BOOL: <br>                            wprintf( <br>                                L"%s  #  ", <br>                                ((VARIANT_BOOL *) pArray)[j] == VARIANT_TRUE ?  <br>                                L"TRUE" : L"FALSE" <br>                                ); <br>                            break; <br>                        case VT_I8: <br>                            wprintf( <br>                                L"%I64d #  ", <br>                                ((__int64 *) pArray)[j] <br>                                ); <br>                            break; <br>         <br>                        default: <br>                            wprintf( <br>                                L"Unsupported  #  \n" <br>                                ); <br>                        } <br>                    } <br>                    printf("\n"); <br>                     <br>                    SafeArrayUnaccessData( V_ARRAY(pVariant) ); <br> <br>                    break; <br>                 <br>                default: <br>                    wprintf( <br>                        L"Unsupported type for attribute %s\n", <br>                        prgColInfo[i+1].pwszName <br>                        ); <br>                    break; <br>            } <br>        } <br> <br>    } <br> <br>    if(nAttrs != 0) <br>        wprintf(L"\n"); <br> <br>    return; <br> <br>error: <br>    wprintf( <br>        L"Error in Printing data for %s\n", <br>        prgColInfo[i+1].pwszName <br>        ); <br>    return; <br>  <br>} <br> <br> <br>int <br>AnsiToUnicodeString( <br>    LPSTR pAnsi, <br>    LPWSTR pUnicode, <br>    DWORD StringLength <br>    ) <br>{ <br>    int iReturn; <br> <br>    if( StringLength == NULL_TERMINATED ) <br>        StringLength = strlen( pAnsi ); <br> <br>    iReturn = MultiByteToWideChar(CP_ACP, <br>                                  MB_PRECOMPOSED, <br>                                  pAnsi, <br>                                  StringLength + 1, <br>                                  pUnicode, <br>                                  StringLength + 1 ); <br> <br>    // <br>    // Ensure NULL termination. <br>    // <br>    pUnicode[StringLength] = 0; <br> <br>    return iReturn; <br>} <br> <br> <br>int <br>UnicodeToAnsiString( <br>    LPWSTR pUnicode, <br>    LPSTR pAnsi, <br>    DWORD StringLength <br>    ) <br>{ <br>    LPSTR pTempBuf = NULL; <br>    INT   rc = 0; <br> <br>    if( StringLength == NULL_TERMINATED ) { <br> <br>        // <br>        // StringLength is just the <br>        // number of characters in the string <br>        // <br>        StringLength = wcslen( pUnicode ); <br>    } <br> <br>    // <br>    // WideCharToMultiByte doesn't NULL terminate if we're copying <br>    // just part of the string, so terminate here. <br>    // <br> <br>    pUnicode[StringLength] = 0; <br> <br>    // <br>    // Include one for the NULL <br>    // <br>    StringLength++; <br> <br>    // <br>    // Unfortunately, WideCharToMultiByte doesn't do conversion in place, <br>    // so allocate a temporary buffer, which we can then copy: <br>    // <br> <br>    if( pAnsi == (LPSTR)pUnicode ) <br>    { <br>#ifdef  DBCS <br>        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength * 2 ); <br>#else <br>        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength ); <br>#endif <br>        pAnsi = pTempBuf; <br>    } <br> <br>    if( pAnsi ) <br>    { <br>        rc = WideCharToMultiByte( CP_ACP, <br>                                  0, <br>                                  pUnicode, <br>                                  StringLength, <br>                                  pAnsi, <br>#ifdef  DBCS <br>                                  StringLength*2, <br>#else <br>                                  StringLength, <br>#endif <br>                                  NULL, <br>                                  NULL ); <br>    } <br> <br>    /* If pTempBuf is non-null, we must copy the resulting string <br>     * so that it looks as if we did it in place: <br>     */ <br>    if( pTempBuf &amp;&amp; ( rc &gt; 0 ) ) <br>    { <br>        pAnsi = (LPSTR)pUnicode; <br>        strcpy( pAnsi, pTempBuf ); <br>        LocalFree( pTempBuf ); <br>    } <br> <br>    return rc; <br>} <br> <br> <br>LPWSTR <br>AllocateUnicodeString( <br>    LPSTR  pAnsiString <br>    ) <br>{ <br>    LPWSTR  pUnicodeString = NULL; <br> <br>    if (!pAnsiString) <br>        return NULL; <br> <br>    pUnicodeString = (LPWSTR)LocalAlloc( <br>                        LPTR, <br>                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR) <br>                        ); <br> <br>    if (pUnicodeString) { <br> <br>        AnsiToUnicodeString( <br>            pAnsiString, <br>            pUnicodeString, <br>            NULL_TERMINATED <br>            ); <br>    } <br> <br>    return pUnicodeString; <br>} <br> <br> <br>void <br>FreeUnicodeString( <br>    LPWSTR  pUnicodeString <br>    ) <br>{ <br>    if (!pUnicodeString) <br>        return; <br> <br>    LocalFree(pUnicodeString); <br> <br>    return; <br>} <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
