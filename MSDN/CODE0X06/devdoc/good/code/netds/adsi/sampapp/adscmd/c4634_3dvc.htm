<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4638"></a>UTIL.CXX</h2>
<pre><code>//--------------------------------------------------------------------------- <br>// <br>//  Microsoft Active Directory 1.0 Sample Code <br>// <br>//  Copyright (C) Microsoft Corporation, 1992 - 1995 <br>// <br>//  File:  util.cxx <br>// <br>//  Contents:  Ansi to Unicode conversions and misc helper functions <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "main.hxx" <br> <br>// <br>// Local functions <br>// <br> <br> <br>int <br>AnsiToUnicodeString( <br>    LPSTR pAnsi, <br>    LPWSTR pUnicode, <br>    DWORD StringLength <br>    ) <br>{ <br>    int iReturn; <br> <br>    if( StringLength == 0 ) <br>        StringLength = strlen( pAnsi ); <br> <br>    iReturn = MultiByteToWideChar(CP_ACP, <br>                                  MB_PRECOMPOSED, <br>                                  pAnsi, <br>                                  StringLength + 1, <br>                                  pUnicode, <br>                                  StringLength + 1 ); <br> <br>    // <br>    // Ensure NULL termination. <br>    // <br>    pUnicode[StringLength] = 0; <br> <br>    return iReturn; <br>} <br> <br> <br>int <br>UnicodeToAnsiString( <br>    LPWSTR pUnicode, <br>    LPSTR pAnsi, <br>    DWORD StringLength <br>    ) <br>{ <br>    LPSTR pTempBuf = NULL; <br>    INT   rc = 0; <br> <br>    if( StringLength == 0 ) { <br> <br>        // <br>        // StringLength is just the <br>        // number of characters in the string <br>        // <br>        StringLength = wcslen( pUnicode ); <br>    } <br> <br>    // <br>    // WideCharToMultiByte doesn't NULL terminate if we're copying <br>    // just part of the string, so terminate here. <br>    // <br> <br>    pUnicode[StringLength] = 0; <br> <br>    // <br>    // Include one for the NULL <br>    // <br>    StringLength++; <br> <br>    // <br>    // Unfortunately, WideCharToMultiByte doesn't do conversion in place, <br>    // so allocate a temporary buffer, which we can then copy: <br>    // <br> <br>    if( pAnsi == (LPSTR)pUnicode ) <br>    { <br>        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength ); <br>        pAnsi = pTempBuf; <br>    } <br> <br>    if( pAnsi ) <br>    { <br>        rc = WideCharToMultiByte( CP_ACP, <br>                                  0, <br>                                  pUnicode, <br>                                  StringLength, <br>                                  pAnsi, <br>                                  StringLength, <br>                                  NULL, <br>                                  NULL ); <br>    } <br> <br>    /* If pTempBuf is non-null, we must copy the resulting string <br>     * so that it looks as if we did it in place: <br>     */ <br>    if( pTempBuf &amp;&amp; ( rc &gt; 0 ) ) <br>    { <br>        pAnsi = (LPSTR)pUnicode; <br>        strcpy( pAnsi, pTempBuf ); <br>        LocalFree( pTempBuf ); <br>    } <br> <br>    return rc; <br>} <br> <br> <br>LPWSTR <br>AllocateUnicodeString( <br>    LPSTR  pAnsiString <br>    ) <br>{ <br>    LPWSTR  pUnicodeString = NULL; <br> <br>    if (!pAnsiString) <br>        return NULL; <br> <br>    pUnicodeString = (LPWSTR)LocalAlloc( <br>                        LPTR, <br>                        strlen(pAnsiString)*sizeof(WCHAR) + sizeof(WCHAR) <br>                        ); <br> <br>    if (pUnicodeString) { <br> <br>        AnsiToUnicodeString( <br>            pAnsiString, <br>            pUnicodeString, <br>            0 <br>            ); <br>    } <br> <br>    return pUnicodeString; <br>} <br> <br> <br>void <br>FreeUnicodeString( <br>    LPWSTR  pUnicodeString <br>    ) <br>{ <br> <br>    LocalFree(pUnicodeString); <br> <br>    return; <br>} <br> <br> <br>// <br>// Misc helper functions for displaying data. <br>// <br> <br> <br>HRESULT <br>PrintVariant( <br>    VARIANT varPropData <br>    ) <br>{ <br>    HRESULT hr; <br>    BSTR bstrValue; <br> <br>    switch (varPropData.vt) { <br>    case VT_I4: <br>        printf("%d", varPropData.lVal); <br>        break; <br>    case VT_BSTR: <br>        printf("%S", varPropData.bstrVal); <br>        break; <br> <br>    case VT_BOOL: <br>        printf("%d", V_BOOL(&amp;varPropData)); <br>        break; <br> <br>    case (VT_ARRAY | VT_VARIANT): <br>        PrintVariantArray(varPropData); <br>        break; <br> <br>    case VT_DATE: <br>        hr = VarBstrFromDate( <br>                 varPropData.date, <br>                 LOCALE_SYSTEM_DEFAULT, <br>                 LOCALE_NOUSEROVERRIDE, <br>                 &amp;bstrValue <br>                 ); <br>        printf("%S", bstrValue); <br>        break; <br> <br>    default: <br>        printf("Data type is %d\n", varPropData.vt); <br>        break; <br> <br>    } <br>    printf("\n"); <br>    return(S_OK); <br>} <br> <br> <br>HRESULT <br>PrintVariantArray( <br>    VARIANT var <br>    ) <br>{ <br>    LONG dwSLBound = 0; <br>    LONG dwSUBound = 0; <br>    VARIANT v; <br>    LONG i; <br>    HRESULT hr = S_OK; <br> <br>    if(!((V_VT(&amp;var) &amp;  VT_VARIANT) &amp;&amp;  V_ISARRAY(&amp;var))) { <br>        return(E_FAIL); <br>    } <br> <br>    // <br>    // Check that there is only one dimension in this array <br>    // <br> <br>    if ((V_ARRAY(&amp;var))-&gt;cDims != 1) { <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br>    // <br>    // Check that there is atleast one element in this array <br>    // <br> <br>    if ((V_ARRAY(&amp;var))-&gt;rgsabound[0].cElements == 0){ <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>    // <br>    // We know that this is a valid single dimension array <br>    // <br> <br>    hr = SafeArrayGetLBound(V_ARRAY(&amp;var), <br>                            1, <br>                            (long FAR *)&amp;dwSLBound <br>                            ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SafeArrayGetUBound(V_ARRAY(&amp;var), <br>                            1, <br>                            (long FAR *)&amp;dwSUBound <br>                            ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    for (i = dwSLBound; i &lt;= dwSUBound; i++) { <br>        VariantInit(&amp;v); <br>        hr = SafeArrayGetElement(V_ARRAY(&amp;var), <br>                                (long FAR *)&amp;i, <br>                                &amp;v <br>                                ); <br>        if (FAILED(hr)) { <br>            continue; <br>        } <br>        if (i &lt; dwSUBound) { <br>            printf("%S, ", v.bstrVal); <br>        } else { <br>            printf("%S", v.bstrVal); <br>        } <br>    } <br>    return(S_OK); <br> <br>error: <br>    return(hr); <br>} <br> <br> <br>HRESULT <br>PrintProperty( <br>    BSTR bstrPropName, <br>    HRESULT hRetVal, <br>    VARIANT varPropData <br>    ) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    switch (hRetVal) { <br> <br>    case 0: <br>        printf("%-32S: ", bstrPropName); <br>        PrintVariant(varPropData); <br>        break; <br> <br>    case E_ADS_CANT_CONVERT_DATATYPE: <br>        printf("%-32S: ", bstrPropName); <br>        printf("&lt;Data could not be converted for display&gt;\n"); <br>        break; <br> <br>    default: <br>        printf("%-32S: ", bstrPropName); <br>        printf("&lt;Data not available&gt;\n"); <br>        break; <br> <br>    } <br>    return(hr); <br>} <br> <br>void <br>PrintUsage( <br>    void <br>    ) <br>{ <br>    printf("usage: adscmd [list|dump] &lt;ADsPath&gt;\n") ; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
