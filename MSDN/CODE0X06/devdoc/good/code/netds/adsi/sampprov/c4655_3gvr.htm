<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PARSE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4707"></a>PARSE.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    Parse.cpp <br> <br>Abstract: <br> <br>    DS Pathname Parser <br> <br>    The Pathname Parser is a key component in ADs providers. It checks for <br>    syntactic validity of an ADs pathname that has been passed to this <br>    provider. If the syntax is valid, then an OBJECTINFO structure is <br>    constructed. This OBJECTINFO structure contains a componentized version <br>    of the ADs pathname for this object. <br> <br>    Note all that is being done is a syntax check. Rather than special-case <br>    every single new nuance to pathnames, all path checking must conform to <br>    the grammar rules laid out by the parser. <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br>#pragma hdrstop <br> <br>//+--------------------------------------------------------------------------- <br>//  Function:   ADsObject <br>// <br>//  Synopsis:   parses an ADs pathname passed to this provider. This function <br>//              parses the following grammar rules <br>// <br>//              &lt;ADsObject&gt; -&gt; &lt;ProviderName&gt; &lt;SampleDSObject&gt; <br>// <br>// <br>//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object <br>//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure <br>// <br>//  Returns:    [HRESULT] 0 if successful, error HRESULT if not <br>// <br>//  Modifies:   pTokenizer (consumes the input buffer) <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo) <br>{ <br>    WCHAR szToken[MAX_TOKEN_LENGTH]; <br>    DWORD dwToken; <br>    HRESULT hr; <br> <br>    hr = ProviderName(pTokenizer, pObjectInfo); <br>    BAIL_IF_ERROR(hr); <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br> <br>    switch (dwToken) { <br> <br>    case TOKEN_END: <br>        RRETURN(S_OK); <br> <br>    case TOKEN_COMMA: <br>        hr = Type(pTokenizer, pObjectInfo); <br>        BAIL_IF_ERROR(hr); <br>        hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>        BAIL_IF_ERROR(hr); <br>        if (dwToken == TOKEN_END) { <br>            RRETURN(S_OK); <br>        }else { <br>            RRETURN(E_ADS_BAD_PATHNAME); <br>        } <br> <br>    default: <br>        hr = pTokenizer-&gt;PushBackToken(); <br> <br> <br>        hr = SampleDSObject(pTokenizer, pObjectInfo); <br>        BAIL_IF_ERROR(hr); <br> <br>        hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>        BAIL_IF_ERROR(hr); <br> <br>        switch (dwToken) { <br>        case TOKEN_END: <br>            RRETURN(S_OK); <br> <br>        case TOKEN_COMMA: <br>            hr = Type(pTokenizer, pObjectInfo); <br>            BAIL_IF_ERROR(hr); <br>            hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>            BAIL_IF_ERROR(hr); <br>            if (dwToken == TOKEN_END) { <br>                RRETURN(S_OK); <br>            }else { <br>                RRETURN(E_ADS_BAD_PATHNAME); <br>            } <br> <br>        default: <br>            RRETURN(E_FAIL); <br> <br>        } <br>    } <br> <br>cleanup: <br>    RRETURN(hr); <br> <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>//  Function:   SampleDSObject <br>// <br>//  Synopsis:   parses an ADs pathname passed to this provider. This function <br>//              parses the following grammar rules <br>// <br>//              &lt;SampleDSObject&gt; -&gt; "\\""identifier""\" &lt;SampleDSObject&gt; <br>// <br>// <br>//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object <br>//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure <br>// <br>//  Returns:    [HRESULT] 0 if successful, error HRESULT if not <br>// <br>//  Modifies:   pTokenizer (consumes the input buffer) <br>// <br>//  History:    11-3-95   krishnag     Created. <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>SampleDSObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo) <br>{ <br>    WCHAR szToken[MAX_TOKEN_LENGTH]; <br>    DWORD dwToken; <br>    HRESULT hr; <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br>    if ((dwToken != TOKEN_FSLASH) &amp;&amp;  (dwToken != TOKEN_BSLASH)) { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br>    if ((dwToken != TOKEN_FSLASH) &amp;&amp; (dwToken != TOKEN_BSLASH)) { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br>    if (dwToken != TOKEN_IDENTIFIER) { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br>    hr = AddRootRDN(pObjectInfo, szToken); <br>    BAIL_IF_ERROR(hr); <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br> <br>    // <br>    // If we get an TOKEN_END, then we have a tree name only \\&lt;tree_name&gt; <br>    // <br> <br>    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) { <br>        hr = pTokenizer-&gt;PushBackToken(); <br>        RRETURN(S_OK); <br>    } <br> <br>    if ((dwToken != TOKEN_BSLASH) &amp;&amp; (dwToken != TOKEN_FSLASH)) { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br>    hr = PathName(pTokenizer, pObjectInfo); <br>    BAIL_IF_ERROR(hr); <br> <br>cleanup: <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo) <br>{ <br>    WCHAR szToken[MAX_TOKEN_LENGTH]; <br>    DWORD dwToken; <br>    HRESULT hr; <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br> <br>    if (dwToken == TOKEN_ATSIGN) { <br> <br>        hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>        BAIL_IF_ERROR(hr); <br> <br>        if (dwToken != TOKEN_IDENTIFIER) { <br>            RRETURN(E_ADS_BAD_PATHNAME); <br>        } <br> <br>        hr = AddProviderName(pObjectInfo, szToken); <br> <br>        hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>        BAIL_IF_ERROR(hr); <br> <br> <br>        if (dwToken != TOKEN_EXCLAMATION) { <br>            RRETURN(E_ADS_BAD_PATHNAME); <br>        } <br> <br>    }else if (dwToken == TOKEN_IDENTIFIER) { <br> <br>        hr = AddProviderName(pObjectInfo, szToken); <br> <br>        hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>        BAIL_IF_ERROR(hr); <br> <br> <br>        if (dwToken != TOKEN_COLON) { <br>            RRETURN(E_ADS_BAD_PATHNAME); <br>        } <br> <br>    }else { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br>    RRETURN(S_OK); <br> <br>cleanup: <br> <br>    RRETURN(hr); <br>} <br> <br> <br>// PathName -&gt; Component \\ PathName <br>// PathName -&gt; Component <br>HRESULT <br>DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo) <br>{ <br>    WCHAR szToken[MAX_TOKEN_LENGTH]; <br>    DWORD dwToken; <br>    HRESULT hr; <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br>    if ((dwToken != TOKEN_FSLASH) || (dwToken != TOKEN_BSLASH)) { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br>    if ((dwToken != TOKEN_FSLASH) || (dwToken != TOKEN_BSLASH)) { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br>    hr = PathName(pTokenizer, pObjectInfo); <br>    BAIL_IF_ERROR(hr); <br> <br>    RRETURN(S_OK); <br> <br>cleanup: <br> <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo) <br>{ <br>    HRESULT hr; <br>    WCHAR szToken[MAX_TOKEN_LENGTH]; <br>    DWORD dwToken; <br> <br>    hr = Component(pTokenizer, pObjectInfo); <br>    BAIL_IF_ERROR(hr); <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br> <br>    if ((dwToken == TOKEN_BSLASH) || (dwToken == TOKEN_FSLASH)) { <br>        RRETURN (PathName(pTokenizer, pObjectInfo)); <br>    }else { <br>        hr = pTokenizer-&gt;PushBackToken(); <br>        RRETURN (S_OK); <br>    } <br>cleanup: <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo) <br>{ <br>    WCHAR szValue[MAX_TOKEN_LENGTH]; <br>    WCHAR szEqual[MAX_TOKEN_LENGTH]; <br>    WCHAR szComponent[MAX_TOKEN_LENGTH]; <br>    DWORD dwToken; <br>    HRESULT hr; <br> <br>    hr = pTokenizer-&gt;GetNextToken(szComponent, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br> <br>    if (dwToken != TOKEN_IDENTIFIER) { <br>        RRETURN(E_ADS_BAD_PATHNAME); <br>    } <br> <br>    hr = pTokenizer-&gt;GetNextToken(szEqual, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br> <br>    if (dwToken == TOKEN_EQUAL) { <br> <br>        hr = pTokenizer-&gt;GetNextToken(szValue, &amp;dwToken); <br>        BAIL_IF_ERROR(hr); <br> <br>        if (dwToken != TOKEN_IDENTIFIER) { <br>            RRETURN(E_ADS_BAD_PATHNAME); <br>        } <br> <br>        hr = AddComponent(pObjectInfo, szComponent, szValue); <br>        BAIL_IF_ERROR(hr); <br> <br>    }else { <br> <br>        hr = AddComponent(pObjectInfo, szComponent, NULL); <br>        BAIL_IF_ERROR(hr); <br> <br>        hr = pTokenizer-&gt;PushBackToken(); <br>        BAIL_IF_ERROR(hr); <br>    } <br> <br>    RRETURN(S_OK); <br> <br>cleanup: <br>    RRETURN(hr); <br>} <br> <br>CLexer::CLexer(LPWSTR szBuffer): <br>                _ptr(NULL), <br>                _Buffer(NULL), <br>                _dwLastTokenLength(0), <br>                _dwLastToken(0), <br>                _dwEndofString(0) <br>{ <br>    if (!szBuffer || !*szBuffer) { <br>        return; <br>    } <br>    _Buffer = AllocProvStr(szBuffer); <br>    _ptr = _Buffer; <br>} <br> <br>CLexer::~CLexer() <br>{ <br>    FreeProvStr(_Buffer); <br>} <br> <br>HRESULT <br>CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken) <br>{ <br>    WCHAR c; <br>    DWORD state = 0; <br>    LPWSTR pch = szToken; <br> <br>    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH); <br>    _dwLastTokenLength = 0; <br>    while (1) { <br>        c = NextChar(); <br>        switch (state) { <br>        case  0: <br>            *pch++ = c; <br>            _dwLastTokenLength++; <br> <br>            if (c == L'\\') { <br>                *pdwToken = TOKEN_BSLASH; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L'/') { <br>                *pdwToken = TOKEN_FSLASH; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L',') { <br>                *pdwToken = TOKEN_COMMA; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L'@'){ <br>                *pdwToken = TOKEN_ATSIGN; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L'='){ <br>                *pdwToken = TOKEN_EQUAL; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L'.'){ <br>                *pdwToken = TOKEN_PERIOD; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L'!'){ <br>                *pdwToken = TOKEN_EXCLAMATION; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L':'){ <br>                *pdwToken = TOKEN_COLON; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else if (c == L'\0'){ <br>                *pdwToken = TOKEN_END; <br>                _dwLastToken = *pdwToken; <br>                RRETURN(S_OK); <br>            }else { <br>                state = 1; <br>            } <br>            break; <br> <br>        case 1: <br>            if (c == L'\\' || c == L'\0' || c == L',' || <br>                    c == L'@' || c == L'!'|| c == L'=' || c == L'.' || <br>                    c == L':' || c == L'/') { <br>                PushbackChar(); <br> <br>                *pdwToken = TOKEN_IDENTIFIER; <br>                _dwLastToken = *pdwToken; <br>                RRETURN (S_OK); <br>            }else { <br>                *pch++ = c; <br>                _dwLastTokenLength++; <br>                state = 1; <br>                break; <br>            } <br>        default: <br>            RRETURN(E_FAIL); <br>        } <br>    } <br>} <br> <br>WCHAR <br>CLexer::NextChar() <br>{ <br>    if (_ptr == NULL || *_ptr == L'\0') { <br>        _dwEndofString = TRUE; <br>        return(L'\0'); <br>    } <br>    return(*_ptr++); <br>} <br> <br>HRESULT <br>CLexer::PushBackToken() <br>{ <br>    if (_dwLastToken == TOKEN_END) { <br>        RRETURN(S_OK); <br>    } <br>    _ptr -= _dwLastTokenLength; <br> <br>    RRETURN(S_OK); <br>} <br> <br> <br>void <br>CLexer::PushbackChar() <br>{ <br>    if (_dwEndofString) { <br>        return; <br>    } <br>    _ptr--; <br> <br>} <br> <br>BOOL <br>CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken) <br>{ <br>    DWORD i = 0; <br> <br>    for (i = 0; i &lt; MAX_KEYWORDS; i++) { <br>        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) { <br>            *pdwToken = KeywordList[i].dwTokenId; <br>            return(TRUE); <br>        } <br>    } <br>    *pdwToken = 0; <br>    return(FALSE); <br>} <br> <br>HRESULT <br>AddComponent(POBJECTINFO pObjectInfo, LPWSTR szComponent, LPWSTR szValue) <br>{ <br>    if (!szComponent || !*szComponent) { <br>        RRETURN(E_FAIL); <br>    } <br> <br> <br>    if (pObjectInfo-&gt;NumComponents &lt; MAXCOMPONENTS) { <br> <br>        pObjectInfo-&gt;ComponentArray[pObjectInfo-&gt;NumComponents].szComponent = <br>                        AllocProvStr(szComponent); <br> <br>        pObjectInfo-&gt;ComponentArray[pObjectInfo-&gt;NumComponents].szValue = <br>                        AllocProvStr(szValue); <br> <br>        pObjectInfo-&gt;NumComponents++; <br> <br>        RRETURN(S_OK); <br> <br>    }else { <br>        RRETURN(E_FAIL); <br>    } <br>} <br> <br>HRESULT <br>AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken) <br>{ <br>    if (!szToken || !*szToken) { <br>        RRETURN(E_FAIL); <br>    } <br> <br>    pObjectInfo-&gt;ProviderName = AllocProvStr(szToken); <br> <br>    RRETURN(S_OK); <br>} <br> <br> <br>HRESULT <br>AddRootRDN(POBJECTINFO pObjectInfo, LPWSTR szToken) <br>{ <br>    if (!szToken || !*szToken) { <br>        RRETURN(E_FAIL); <br>    } <br> <br>    pObjectInfo-&gt;RootRDN = AllocProvStr(szToken); <br> <br>    RRETURN(S_OK); <br>} <br> <br> <br>HRESULT <br>SetType(POBJECTINFO pObjectInfo, DWORD dwToken) <br>{ <br>    pObjectInfo-&gt;ObjectType = dwToken; <br>    RRETURN(S_OK); <br>} <br> <br> <br>// Type -&gt; "user", "group","printer","service", "fileservice" <br> <br>//+--------------------------------------------------------------------------- <br>// Function:    Type <br>// <br>// Synopsis:    Parses Type-&gt; "user" | "group" etc <br>// <br>// Arguments:   [CLexer * pTokenizer] <br>//              [POBJECTINFo pObjectInfo] <br>// <br>// Returns:     HRESULT <br>// <br>// Modifies:     <br>// <br>// History:     <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo) <br>{ <br>    WCHAR szToken[MAX_PATH]; <br>    DWORD dwToken; <br>    HRESULT hr; <br> <br>    hr = pTokenizer-&gt;GetNextToken(szToken, &amp;dwToken); <br>    BAIL_IF_ERROR(hr); <br> <br>    if (dwToken == TOKEN_IDENTIFIER ) { <br>        RRETURN(hr); <br>    } <br> <br>    RRETURN(E_FAIL); <br> <br>cleanup: <br>    RRETURN(hr); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
