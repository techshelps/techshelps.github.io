<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMMON.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4676"></a>COMMON.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    Common.cpp <br> <br>Abstract: <br> <br>    Contains routines and properties that are common to <br>    all tshirt objects. thsirt objects get the routines and <br>    properties through C++ inheritance. <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br>#pragma hdrstop <br> <br> <br>FILTERS Filters[] = { <br>                    {L"organizational unit", SampleDS_OU_ID}, <br>                    {L"class", SampleDS_CLASS_ID}, <br>                    {L"property", SampleDS_PROPERTY_ID} <br>                  }; <br> <br>#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS)) <br> <br>PFILTERS  gpFilters = Filters; <br>DWORD gdwMaxFilters = MAX_FILTERS; <br> <br>extern WCHAR * g_szProviderName; <br> <br>HRESULT <br>xx_put_BSTR(BSTR* lppItemName, BSTR lpName) <br>{ <br>    if (*lppItemName) { <br>        SysFreeString(*lppItemName); <br>        *lppItemName = NULL; <br>    } <br> <br>    if (!lpName) { <br>        RRETURN(S_OK); <br>    } <br> <br>    *lppItemName = SysAllocString(lpName); <br> <br>    if (!*lppItemName) { <br>        RRETURN(E_FAIL); <br>    } <br>    RRETURN(S_OK); <br>} <br> <br>HRESULT <br>xx_put_LONG(long * plnItem, long lnItem) <br>{ <br>    *plnItem = lnItem; <br>    RRETURN(S_OK); <br>} <br> <br>HRESULT <br>xx_put_DATE(DATE * pdaItem, DATE daItem) <br>{ <br>    *pdaItem = daItem; <br>    RRETURN(S_OK); <br>} <br> <br> <br>HRESULT <br>xx_put_VARIANT_BOOL(VARIANT_BOOL * pfItem, VARIANT_BOOL fItem) <br>{ <br>    *pfItem = fItem; <br>    RRETURN(S_OK); <br>} <br> <br> <br>HRESULT <br>xx_put_VARIANT(VARIANT * * ppvItem, VARIANT vItem) <br>{ <br>    if (!*ppvItem) { <br>        if (!(*ppvItem = (VARIANT *)AllocProvMem(sizeof(VARIANT)))){ <br>            RRETURN(E_OUTOFMEMORY); <br>        } <br>    } <br>    RRETURN(VariantCopy(*ppvItem, &amp;vItem)); <br>} <br> <br>HRESULT <br>BuildADsPath( <br>    BSTR Parent, <br>    BSTR Name, <br>    BSTR *pADsPath <br>    ) <br>{ <br>    WCHAR ADsPath[MAX_PATH]; <br>    WCHAR ProviderName[MAX_PATH]; <br>    HRESULT hr = S_OK; <br> <br>    // <br>    // We will assert if bad parameters are passed to us. <br>    // This is because this should never be the case. This <br>    // is an internal call <br>    // <br> <br>    ADsAssert(Parent &amp;&amp; Name); <br>    ADsAssert(pADsPath); <br> <br> <br>    // <br>    // Special case the Namespace object; if <br>    // the parent is L"ADs:", then Name = ADsPath <br>    // <br> <br>    if (!_wcsicmp(Parent, L"ADs:")) { <br>        RRETURN(xx_put_BSTR(pADsPath, Name)); <br>    } <br> <br>    // <br>    // The rest of the cases we expect valid data, <br>    // Path, Parent and Name are read-only, the end-user <br>    // cannot modify this data <br>    // <br> <br>    // <br>    // For first level objects we do not add <br>    // the first backslash; so we examine that the parent is <br>    // L"Sample:" and skip the slash otherwise we start with <br>    // the slash <br>    // <br> <br>    wsprintf(ProviderName, L"%s:", g_szProviderName); <br> <br>    wcscpy(ADsPath, Parent); <br> <br>    if (_wcsicmp(ADsPath, ProviderName)) { <br>        wcscat(ADsPath, L"/"); <br>    }else { <br>        wcscat(ADsPath, L"//"); <br>    } <br>    wcscat(ADsPath, Name); <br> <br>    hr = xx_put_BSTR(pADsPath, ADsPath); <br> <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>BuildSchemaPath( <br>    BSTR bstrADsPath, <br>    BSTR bstrClass, <br>    BSTR *pSchemaPath <br>    ) <br>{ <br>    WCHAR ADsSchema[MAX_PATH]; <br>    OBJECTINFO ObjectInfo; <br>    POBJECTINFO pObjectInfo = &amp;ObjectInfo; <br>    CLexer Lexer(bstrADsPath); <br>    HRESULT hr = S_OK; <br> <br>    wcscpy(ADsSchema, L""); <br> <br>    if (bstrClass &amp;&amp; *bstrClass) { <br>        memset(pObjectInfo, 0, sizeof(OBJECTINFO)); <br>        hr = ADsObject(&amp;Lexer, pObjectInfo); <br>        BAIL_ON_FAILURE(hr); <br> <br>        if (pObjectInfo-&gt;RootRDN) { <br> <br>            wsprintf(ADsSchema,L"%s://",pObjectInfo-&gt;ProviderName); <br>            wcscat(ADsSchema, pObjectInfo-&gt;RootRDN); <br>            wcscat(ADsSchema,L"/schema/"); <br>            wcscat(ADsSchema, bstrClass); <br> <br>        } <br>    } <br> <br>    hr = ProvAllocString( ADsSchema, pSchemaPath); <br> <br>error: <br> <br>    if (pObjectInfo) { <br> <br>        // <br>        // BugBug - KrishnaG; free up this piece of memory <br>        // <br>    } <br>    RRETURN(hr); <br>} <br> <br> <br>HRESULT <br>BuildADsGuid( <br>    REFCLSID clsid, <br>    BSTR *pADsClass <br>){ <br>    WCHAR ADsClass[MAX_PATH]; <br> <br>    StringFromGUID2(clsid, ADsClass, 256); <br> <br>    RRETURN(xx_put_BSTR(pADsClass, ADsClass)); <br>} <br> <br> <br>typedef struct _typeinfotable <br>{ <br>    GUID iid; <br>    ITypeInfo * pTypeInfo; <br>    struct _typeinfotable *pNext; <br>}TYPEINFO_TABLE, *PTYPEINFO_TABLE; <br> <br> <br>PTYPEINFO_TABLE gpTypeInfoTable = NULL; <br> <br>ITypeInfo * <br>FindTypeInfo( <br>    PTYPEINFO_TABLE pTypeInfoTable, <br>    REFIID iid <br>){ <br>    PTYPEINFO_TABLE pTemp = NULL; <br> <br>    pTemp = pTypeInfoTable; <br> <br>    while (pTemp) { <br>        if (IsEqualIID(iid, pTemp-&gt;iid)) { <br>            return(pTemp-&gt;pTypeInfo); <br>        } <br>        pTemp = pTemp-&gt;pNext; <br>    } <br>    return(NULL); <br>} <br> <br> <br>PTYPEINFO_TABLE <br>AddTypeInfo( <br>    PTYPEINFO_TABLE pTypeInfoTable, <br>    REFIID iid, <br>    ITypeInfo * pTypeInfo <br>){ <br>    PTYPEINFO_TABLE pTemp = NULL; <br> <br>    pTemp = (PTYPEINFO_TABLE)AllocProvMem( <br>                    sizeof(TYPEINFO_TABLE) <br>                    ); <br>    if (!pTemp) { <br>        return(NULL); <br>    } <br> <br>    memcpy(&amp;pTemp-&gt;iid, &amp;iid, sizeof(GUID)); <br>    pTemp-&gt;pTypeInfo = pTypeInfo; <br>    pTemp-&gt;pNext = pTypeInfoTable; <br> <br>    return(pTemp); <br>} <br> <br>HRESULT <br>LoadTypeInfoEntry( <br>    CDispatchMgr *pDispMgr, <br>    REFIID libid, <br>    REFIID iid, <br>    void * pIntf, <br>    DISPID SpecialId <br>){ <br>    ITypeInfo * pTypeInfo = NULL; <br>    HRESULT hr; <br> <br>    pTypeInfo = FindTypeInfo( <br>                    gpTypeInfoTable, <br>                    iid <br>                    ); <br>    if (!pTypeInfo) { <br> <br>        hr = LoadTypeInfo(libid, iid, &amp;pTypeInfo); <br>        BAIL_IF_ERROR(hr); <br> <br>        gpTypeInfoTable = AddTypeInfo( <br>                                gpTypeInfoTable, <br>                                iid, <br>                                pTypeInfo <br>                                ); <br>        if (!gpTypeInfoTable) { <br>            hr = HRESULT_FROM_WIN32(GetLastError()); <br>            BAIL_IF_ERROR(hr); <br>        } <br>    } <br>    pTypeInfo-&gt;AddRef(); <br> <br> <br>    hr = pDispMgr-&gt;AddTypeInfo(pTypeInfo, pIntf); <br>    BAIL_IF_ERROR(hr); <br> <br>    if (SpecialId == -4) { <br>        hr = pDispMgr-&gt;MarkAsNewEnum(pTypeInfo); <br>    } <br> <br>    RRETURN(S_OK); <br> <br>cleanup: <br> <br>   if (pTypeInfo) { <br>       pTypeInfo-&gt;Release(); <br>   } <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>ValidateOutParameter(BSTR * retval) <br>{ <br>    if (!retval) { <br>        RRETURN(E_ADS_BAD_PARAMETER); <br>    } <br>    RRETURN(S_OK); <br>} <br> <br> <br>PKEYDATA <br>CreateTokenList( <br>    LPWSTR   pKeyData, <br>    WCHAR ch <br>){ <br>    DWORD       cTokens; <br>    DWORD       cb; <br>    PKEYDATA    pResult; <br>    LPWSTR       pDest; <br>    LPWSTR       psz = pKeyData; <br>    LPWSTR      *ppToken; <br>    WCHAR szTokenList[MAX_PATH]; <br> <br> <br>    if (!psz || !*psz) <br>        return NULL; <br> <br>    wsprintf(szTokenList, L"%c", ch); <br> <br>    cTokens=1; <br> <br>    // Scan through the string looking for commas, <br>    // ensuring that each is followed by a non-NULL character: <br> <br>    while ((psz = wcschr(psz, ch)) &amp;&amp; psz[1]) { <br> <br>        cTokens++; <br>        psz++; <br>    } <br> <br>    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) + <br>         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR); <br> <br>    if (!(pResult = (PKEYDATA)AllocProvMem(cb))) <br>        return NULL; <br> <br>    // Initialise pDest to point beyond the token pointers: <br> <br>    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) + <br>                                      (cTokens-1) * sizeof(LPWSTR)); <br> <br>    // Then copy the key data buffer there: <br> <br>    wcscpy(pDest, pKeyData); <br> <br>    ppToken = pResult-&gt;pTokens; <br> <br> <br>    // Remember, wcstok has the side effect of replacing the delimiter <br>    // by NULL, which is precisely what we want: <br> <br>    psz = wcstok (pDest, szTokenList); <br> <br>    while (psz) { <br> <br>        *ppToken++ = psz; <br>        psz = wcstok (NULL, szTokenList); <br>    } <br> <br>    pResult-&gt;cTokens = cTokens; <br> <br>    return( pResult ); <br>} <br> <br>//+------------------------------------------------------------------------ <br>// <br>//  Function:   LoadTypeInfo <br>// <br>//  Synopsis:   Loads a typeinfo from a registered typelib. <br>// <br>//  Arguments:  [clsidTL] --  TypeLib GUID <br>//              [clsidTI] --  TypeInfo GUID <br>//              [ppTI]    --  Resulting typeInfo <br>// <br>//  Returns:    HRESULT <br>// <br>//------------------------------------------------------------------------- <br> <br>HRESULT <br>LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI) <br>{ <br>    HRESULT     hr; <br>    ITypeLib *  pTL; <br> <br>    ADsAssert(ppTI); <br>    *ppTI = NULL; <br>    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &amp;pTL); <br>    if (hr) <br>        RRETURN(hr); <br> <br>    hr = pTL-&gt;GetTypeInfoOfGuid(clsidTI, ppTI); <br>    pTL-&gt;Release(); <br>    RRETURN(hr); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
