<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4717"></a>UTIL.H</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    Util.h <br> <br>Abstract: <br> <br>    Definition of Utilities for use <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#ifndef _UTIL_H_ <br>#define _UTIL_H_ <br> <br>#include "formtrck.h" <br> <br>//+--------------------------------------------------------------------- <br>// <br>//   Generally useful #defines and inline functions for OLE2. <br>// <br>//------------------------------------------------------------------------ <br> <br>// These are the major and minor version returned by OleBuildVersion <br>#define OLE_MAJ_VER 0x0003 <br>#define OLE_MIN_VER 0x003A <br> <br> <br>//--------------------------------------------------------------- <br>//  SCODE and HRESULT macros <br>//--------------------------------------------------------------- <br> <br>#define OK(r)       (SUCCEEDED(r)) <br>#define NOTOK(r)    (FAILED(r)) <br> <br> <br>//--------------------------------------------------------------- <br>//  IUnknown <br>//--------------------------------------------------------------- <br> <br>#define InterlockedIncrement(plong) (++(*(plong))) <br>#define InterlockedDecrement(plong) (--(*(plong))) <br> <br>#define ADsIncrement(__ul) InterlockedIncrement((long *) &amp;__ul) <br>#define ADsDecrement(__ul) InterlockedDecrement((long *) &amp;__ul) <br> <br> <br> <br>#define DECLARE_ADs_IUNKNOWN_METHODS                              \ <br>    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);          \ <br>    STDMETHOD_(ULONG, AddRef) (void);                               \ <br>    STDMETHOD_(ULONG, Release) (void); <br> <br> <br> <br>#define DECLARE_ADs_STANDARD_IUNKNOWN(cls)                        \ <br>    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);          \ <br>    ULONG _ulRefs;                                                  \ <br>    STDMETHOD_(ULONG, AddRef) (void)                                \ <br>        {                                                           \ <br>            ADsIncrement(_ulRefs);                                \ <br>            return _ulRefs;                                         \ <br>        }                                                           \ <br>    STDMETHOD_(ULONG, Release) (void)                               \ <br>        {                                                           \ <br>            if (!ADsDecrement(_ulRefs))                           \ <br>            {                                                       \ <br>                ADsIncrement(_ulRefs);                            \ <br>                delete this;                                        \ <br>                return 0;                                           \ <br>            }                                                       \ <br>            return _ulRefs;                                         \ <br>        } <br> <br> <br> <br>#define DECLARE_ADs_DELEGATING_IUNKNOWN(cls)                      \ <br>    IUnknown * _pUnkOuter;                                          \ <br>    STDMETHOD(QueryInterface) (REFIID iid, LPVOID * ppv)            \ <br>        { return _pUnkOuter-&gt;QueryInterface(iid, ppv); }            \ <br>    STDMETHOD_(ULONG, AddRef) (void)                                \ <br>        { return _pUnkOuter-&gt;AddRef(); }                            \ <br>    STDMETHOD_(ULONG, Release) (void)                               \ <br>        { return _pUnkOuter-&gt;Release(); } <br> <br> <br>#if DBG == 0 <br>// <br>// Retail versions of these macros <br>// <br> <br>#define DECLARE_ADs_PRIVATE_IUNKNOWN(cls)                         \ <br>    class PrivateUnknown : public IUnknown                          \ <br>    {                                                               \ <br>    private:                                                        \ <br>        ULONG   _ulRefs;                                            \ <br>        cls *   My##cls(void)                                       \ <br>            { return CONTAINING_RECORD(this, cls, _PrivUnk); }      \ <br>                                                                    \ <br>    public:                                                         \ <br>        PrivateUnknown(void)                                        \ <br>            { _ulRefs = 1; }                                        \ <br>                                                                    \ <br>        DECLARE_ADs_IUNKNOWN_METHODS                              \ <br>    };                                                              \ <br>    friend class PrivateUnknown;                                    \ <br>    PrivateUnknown _PrivUnk; <br> <br> <br> <br>#define IMPLEMENT_ADs_PRIVATE_IUNKNOWN(cls)                       \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::AddRef( )             \ <br>    {                                                               \ <br>        ADsIncrement(_ulRefs);                                    \ <br>        return _ulRefs;                                             \ <br>    }                                                               \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::Release( )            \ <br>    {                                                               \ <br>        if (!ADsDecrement(_ulRefs))                               \ <br>        {                                                           \ <br>            ADsIncrement(_ulRefs);                                \ <br>            delete My##cls();                                       \ <br>            return 0;                                               \ <br>        }                                                           \ <br>        return _ulRefs;                                             \ <br>    } <br> <br> <br> <br>#define DECLARE_ADs_COMPOUND_IUNKNOWN(cls)                        \ <br>    class PrivateUnknown : public IUnknown                          \ <br>    {                                                               \ <br>        friend class cls;                                           \ <br>                                                                    \ <br>    public:                                                         \ <br>        PrivateUnknown(void)                                        \ <br>            { _ulRefs = 1; _ulAllRefs = 1; }                        \ <br>                                                                    \ <br>        DECLARE_ADs_IUNKNOWN_METHODS                              \ <br>                                                                    \ <br>    private:                                                        \ <br>        ULONG   _ulRefs;                                            \ <br>        ULONG   _ulAllRefs;                                         \ <br>                                                                    \ <br>        cls *   My##cls(void)                                       \ <br>            { return CONTAINING_RECORD(this, cls, _PrivUnk); }      \ <br>    };                                                              \ <br>    friend class PrivateUnknown;                                    \ <br>    PrivateUnknown _PrivUnk;                                        \ <br>                                                                    \ <br>    ULONG   SubAddRef(void);                                        \ <br>    ULONG   SubRelease(void); <br> <br> <br> <br>#define IMPLEMENT_ADs_COMPOUND_IUNKNOWN(cls)                      \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::AddRef( )             \ <br>    {                                                               \ <br>        ADsIncrement(_ulAllRefs);                                 \ <br>        ADsIncrement(_ulRefs);                                    \ <br>        return _ulRefs;                                             \ <br>    }                                                               \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::Release( )            \ <br>    {                                                               \ <br>        if (!ADsDecrement(_ulRefs))                               \ <br>        {                                                           \ <br>            My##cls()-&gt;Passivate();                                 \ <br>        }                                                           \ <br>        if (!ADsDecrement(_ulAllRefs))                            \ <br>        {                                                           \ <br>            ADsIncrement(_ulAllRefs);                             \ <br>            delete My##cls();                                       \ <br>            return 0;                                               \ <br>        }                                                           \ <br>        return _ulRefs;                                             \ <br>    }                                                               \ <br>    ULONG cls::SubAddRef( )                                         \ <br>    {                                                               \ <br>        return ADsIncrement(_PrivUnk._ulAllRefs);                 \ <br>    }                                                               \ <br>    ULONG cls::SubRelease( )                                        \ <br>    {                                                               \ <br>        ULONG ul;                                                   \ <br>                                                                    \ <br>        ul = ADsDecrement(_PrivUnk._ulAllRefs);                   \ <br>        if (!ul)                                                    \ <br>        {                                                           \ <br>            ADsIncrement(_PrivUnk._ulAllRefs);                    \ <br>            delete this;                                            \ <br>        }                                                           \ <br>                                                                    \ <br>        return ul;                                                  \ <br>    } <br> <br>#else  // DBG == 0 <br> <br>// <br>// Debug versions of these macros <br>// <br> <br>#define DECLARE_ADs_PRIVATE_IUNKNOWN(cls)                         \ <br>    class PrivateUnknown : protected ObjectTracker,                 \ <br>                           public IUnknown                          \ <br>    {                                                               \ <br>    private:                                                        \ <br>        cls *   My##cls(void)                                       \ <br>            { return CONTAINING_RECORD(this, cls, _PrivUnk); }      \ <br>                                                                    \ <br>    public:                                                         \ <br>        PrivateUnknown(void)                                        \ <br>            { _ulRefs = 1; TrackClassName(#cls); }                  \ <br>                                                                    \ <br>        DECLARE_ADs_IUNKNOWN_METHODS                              \ <br>    };                                                              \ <br>    friend class PrivateUnknown;                                    \ <br>    PrivateUnknown _PrivUnk; <br> <br> <br> <br>#define IMPLEMENT_ADs_PRIVATE_IUNKNOWN(cls)                       \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::AddRef( )             \ <br>    {                                                               \ <br>        StdAddRef();                                                \ <br>        return _ulRefs;                                             \ <br>    }                                                               \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::Release( )            \ <br>    {                                                               \ <br>        if (!StdRelease())                                          \ <br>        {                                                           \ <br>            ADsIncrement(_ulRefs);                                \ <br>            delete My##cls();                                       \ <br>            return 0;                                               \ <br>        }                                                           \ <br>        return _ulRefs;                                             \ <br>    } <br> <br> <br> <br>#define DECLARE_ADs_COMPOUND_IUNKNOWN(cls)                        \ <br>    class PrivateUnknown : protected ObjectTracker,                 \ <br>                           public IUnknown                          \ <br>    {                                                               \ <br>        friend class cls;                                           \ <br>                                                                    \ <br>    public:                                                         \ <br>        PrivateUnknown(void)                                        \ <br>            { _ulNRefs = 1; _ulRefs = 1; TrackClassName(#cls); }    \ <br>                                                                    \ <br>        DECLARE_ADs_IUNKNOWN_METHODS                              \ <br>                                                                    \ <br>    private:                                                        \ <br>        ULONG   _ulNRefs;                                           \ <br>                                                                    \ <br>        cls *   My##cls(void)                                       \ <br>            { return CONTAINING_RECORD(this, cls, _PrivUnk); }      \ <br>    };                                                              \ <br>    friend class PrivateUnknown;                                    \ <br>    PrivateUnknown _PrivUnk;                                        \ <br>                                                                    \ <br>    ULONG   SubAddRef(void);                                        \ <br>    ULONG   SubRelease(void); <br> <br> <br> <br>#define IMPLEMENT_ADs_COMPOUND_IUNKNOWN(cls)                      \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::AddRef( )             \ <br>    {                                                               \ <br>        StdAddRef();                                                \ <br>        ADsIncrement(_ulNRefs);                                   \ <br>        return _ulNRefs;                                            \ <br>    }                                                               \ <br>    STDMETHODIMP_(ULONG) cls::PrivateUnknown::Release( )            \ <br>    {                                                               \ <br>        if (!ADsDecrement(_ulNRefs))                              \ <br>        {                                                           \ <br>            My##cls()-&gt;Passivate();                                 \ <br>        }                                                           \ <br>        if (!StdRelease())                                          \ <br>        {                                                           \ <br>            ADsIncrement(_ulRefs);                                \ <br>            delete My##cls();                                       \ <br>            return 0;                                               \ <br>        }                                                           \ <br>        return _ulNRefs;                                            \ <br>    }                                                               \ <br>    ULONG cls::SubAddRef( )                                         \ <br>    {                                                               \ <br>        return _PrivUnk.StdAddRef();                                \ <br>    }                                                               \ <br>    ULONG cls::SubRelease( )                                        \ <br>    {                                                               \ <br>        ULONG ul;                                                   \ <br>                                                                    \ <br>        ul = _PrivUnk.StdRelease();                                 \ <br>        if (!ul)                                                    \ <br>        {                                                           \ <br>            ADsIncrement(_PrivUnk._ulRefs);                       \ <br>            delete this;                                            \ <br>        }                                                           \ <br>                                                                    \ <br>        return ul;                                                  \ <br>    } <br> <br>#endif // DBG == 0 <br> <br>#define DECLARE_ADs_SUBOBJECT_IUNKNOWN(cls, parent_cls, member)   \ <br>    DECLARE_ADs_IUNKNOWN_METHODS                                  \ <br>    parent_cls * My##parent_cls(void);                              \ <br>    void Detach(void)                                               \ <br>        { ; } <br> <br> <br>#define IMPLEMENT_ADs_SUBOBJECT_IUNKNOWN(cls, parent_cls, member) \ <br>    inline parent_cls * cls::My##parent_cls(void)                   \ <br>    {                                                               \ <br>        return CONTAINING_RECORD(this, parent_cls, member);         \ <br>    }                                                               \ <br>    STDMETHODIMP_(ULONG) cls::AddRef( )                             \ <br>        { return My##parent_cls()-&gt;SubAddRef(); }                   \ <br>    STDMETHODIMP_(ULONG) cls::Release( )                            \ <br>        { return My##parent_cls()-&gt;SubRelease(); } <br> <br> <br> <br>//+------------------------------------------------------------------------ <br>// <br>//  NO_COPY *declares* the constructors and assignment operator for copying. <br>//  By not *defining* these functions, you can prevent your class from <br>//  accidentally being copied or assigned -- you will be notified by <br>//  a linkage error. <br>// <br>//------------------------------------------------------------------------- <br> <br>#define NO_COPY(cls)    \ <br>    cls(const cls&amp;);    \ <br>    cls&amp; operator=(const cls&amp;); <br> <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Miscellaneous useful OLE helper and debugging functions <br>// <br>//---------------------------------------------------------------------- <br> <br>// <br>//  Some convenient OLE-related definitions and declarations <br>// <br> <br>typedef  unsigned short far * LPUSHORT; <br> <br>#define OLEMISC_STREAMABLE 1024 <br> <br>IsCompatibleOleVersion(WORD wMaj, WORD wMin); <br> <br> <br>//#if DBG == 1 <br>#if 0 <br>STDAPI  CheckAndReturnResult( <br>                HRESULT hr, <br>                LPSTR   lpstrFile, <br>                UINT    line, <br>                int     cSuccess, <br>                ...); <br> <br>STDAPI_(void)   CheckResult(HRESULT hr, LPSTR lpstrFile, UINT line); <br>STDAPI_(void)   PrintIID(DWORD dwFlags, REFIID riid); <br>STDAPI          PrintHRESULT(DWORD dwFlags, HRESULT hr); <br> <br>#define SRETURN(hr) \ <br>    return CheckAndReturnResult((hr), __FILE__, __LINE__, -1) <br>#define RRETURN(hr) \ <br>    return CheckAndReturnResult((hr), __FILE__, __LINE__, 0) <br>#define RRETURN1(hr, s1) \ <br>    return CheckAndReturnResult((hr), __FILE__, __LINE__, 1, (s1)) <br>#define RRETURN2(hr, s1, s2) \ <br>    return CheckAndReturnResult((hr), __FILE__, __LINE__, 2, (s1), (s2)) <br>#define RRETURN3(hr, s1, s2, s3) \ <br>    return CheckAndReturnResult((hr), __FILE__, __LINE__, 3, (s1), (s2), (s3)) <br> <br>#define WARN_ERROR(hr)  CheckResult((hr), __FILE__, __LINE__) <br> <br>#define TRETURN(hr)         return PrintHRESULT(DEB_TRACE, (hr)) <br>#define TRACEIID(iid)       PrintIID(DEB_TRACE, iid) <br>#define TRACEHRESULT(hr)    PrintHRESULT(DEB_TRACE, (hr)) <br> <br>#else   // DBG == 0 <br> <br>#define SRETURN(hr)                 return (hr) <br>#define RRETURN(hr)                 return (hr) <br>#define RRETURN1(hr, s1)            return (hr) <br>#define RRETURN2(hr, s1, s2)        return (hr) <br>#define RRETURN3(hr, s1, s2, s3)    return (hr) <br> <br>#define WARN_ERROR(hr) <br> <br>#define TRETURN(hr)     return (hr) <br>#define TRACEIID(iid) <br>#define TRACEHRESULT(hr) <br> <br>#endif  // DBG <br> <br> <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Interface wrapper for tracing method invocations <br>// <br>//---------------------------------------------------------------------- <br> <br>#if DBG == 1 <br> <br>LPVOID WatchInterface(REFIID riid, LPVOID pv, LPWSTR lpstr); <br>#define WATCHINTERFACE(iid, p, lpstr)  WatchInterface(iid, p, lpstr) <br> <br>#else   // DBG == 0 <br> <br>#define WATCHINTERFACE(iid, p, lpstr)  (p) <br> <br>#endif  // DBG <br> <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Standard IClassFactory implementation <br>// <br>//---------------------------------------------------------------------- <br> <br>//+--------------------------------------------------------------- <br>// <br>//  Class:      StdClassFactory <br>// <br>//  Purpose:    Standard implementation of a class factory object <br>// <br>//  Notes:          **************!!!!!!!!!!!!!!!!!************* <br>//              TAKE NOTE --- The implementation of Release on this <br>//              class does not perform a delete.  This is so you can <br>//              make the class factory a global static variable. <br>//              Use the CDynamicCF class below for an object <br>//              which is not global static data. <br>// <br>//              ALSO - The refcount is initialized to 0, NOT 1! <br>// <br>//--------------------------------------------------------------- <br> <br>class StdClassFactory: public IClassFactory <br>{ <br>public: <br>    StdClassFactory(void) : _ulRefs(1) {}; <br> <br>    // IUnknown methods <br>    DECLARE_ADs_IUNKNOWN_METHODS; <br> <br>    // IClassFactory methods <br>    STDMETHOD(LockServer) (BOOL fLock); <br> <br>    // CreateInstance is left pure virtual. <br> <br>protected: <br>    ULONG _ulRefs; <br>}; <br> <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Class:      CDynamicCF (DYNCF) <br>// <br>//  Purpose:    Class factory which exists on the heap, and whose Release <br>//              method does the normal thing. <br>// <br>//  Interface:  DECLARE_ADs_STANDARD_IUNKNOWN -- IUnknown methods <br>// <br>//              LockServer             -- Per IClassFactory. <br>//              CDynamicCF             -- ctor. <br>//              ~CDynamicCF            -- dtor. <br>// <br>//  History:    6-22-94   adams   Created <br>//              7-13-94   adams   Moved from ADs\inc\dyncf.hxx <br>// <br>//---------------------------------------------------------------------------- <br> <br>class CDynamicCF: public IClassFactory <br>{ <br>public: <br>    // IUnknown methods <br>    DECLARE_ADs_STANDARD_IUNKNOWN(CDynamicCF) <br> <br>    // IClassFactory methods <br>    STDMETHOD(LockServer) (BOOL fLock); <br> <br>protected: <br>            CDynamicCF(void); <br>    virtual ~CDynamicCF(void); <br>}; <br> <br> <br>#endif //__UTILS_H_ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
