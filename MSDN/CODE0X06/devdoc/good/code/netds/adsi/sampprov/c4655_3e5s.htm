<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FORMTRCK.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4690"></a>FORMTRCK.H</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright (C) 1992, Microsoft Corporation. <br>// <br>//  File:       formtrck.hxx <br>// <br>//  Contents:   This file defines facilities for a standard implementation <br>//              of reference-counted objects, incorporating mechanisms for <br>//              tracking the usage history of the objects. <br>// <br>//  Classes:    ObjectTracker <br>// <br>//  History:    6-Apr-92       MikeSe  Created <br>//              08-Aug-94      DonCl   copied from cinc, and renamed to formtrck.hxx <br>// <br>//---------------------------------------------------------------------------- <br> <br>#ifndef __FORMTRCK_HXX__ <br>#define __FORMTRCK_HXX__ <br> <br>#include &lt;windows.h&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Class:      ObjectTracker (otr) <br>// <br>//  Purpose:    Provides basis for tracking (OLE) objects (aka interface handles) <br>// <br>//  History:    6-Apr-92 MikeSe         Created <br>// <br>//  Notes:      Access to this class is only indirect, through the macros <br>//              defined later. <br>// <br>//-------------------------------------------------------------------------- <br> <br>class ObjectTracker <br>{ <br>protected: <br> <br>                     ObjectTracker (); <br> <br>//# if DBG == 1 <br>#if 0 <br>                    ~ObjectTracker(); <br>    ULONG            StdAddRef ( void ); <br>    ULONG            StdRelease ( void ); <br>    void             TrackClassName ( char * pszName ); <br>    unsigned long    GetRefCount ( void ) {return _ulRefs;}; <br> <br>private: <br> <br>    BOOL             IsClassTracking( char * pszName ); <br> <br>    struct TrackLink *  _tl; <br>    static  BOOL        _TrackAll; <br> <br>public: <br>        // dumps information on all outstanding objects <br>    static void        DumpTrackingInfo ( int fDeleteNode = 0 ); <br>    static void        TrackClass(BOOL, char * pszName ); <br> <br># endif // DBG == 1 <br> <br>protected: <br>    unsigned long      _ulRefs; <br>}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  The following macros encapsulate use of the above <br>// <br>//  INHERIT_TRACKING: <br>// <br>//      For any class which implements a Cairo interface, add this macro <br>//      in the class declaration, eg: <br>// <br>//              class CMyFoo: INHERIT_TRACKING, IFoo <br>// <br>//      Do not repeat this in any subclass. If both INHERIT_UNWIND and <br>//      INHERIT_TRACKING are used, the former should appear first. <br> <br># define INHERIT_TRACKING       protected ObjectTracker <br> <br>        // The following declarations are for non-retail builds <br> <br>//# if DBG == 1 <br>#if 0 <br>// <br>// DECLARE_STD_REFCOUNTING: <br>// <br>//      To make use of standard refcounting code, place the above <br>//      in the class declaration, in the public method section. This <br>//      macro defines the AddRef and Release methods for the class. <br>// <br> <br>#  define DECLARE_STD_REFCOUNTING                                       \ <br>        STDMETHOD_(ULONG, AddRef) ()                                    \ <br>                {                                                       \ <br>                    return StdAddRef();                                 \ <br>                };                                                      \ <br>        STDMETHOD_(ULONG, Release) ()                                   \ <br>                {                                                       \ <br>                    ULONG ul = StdRelease();                            \ <br>                    if ( ul==0 ) delete this;                           \ <br>                    return ul;                                          \ <br>                }; <br> <br>// <br>//  ENLIST_TRACKING(class name) <br>// <br>//      Place an invocation of this in each constructor, at any appropriate <br>//      point (generally immediately before returning from the constructor). <br>// <br>//              ENLIST_TRACKING(CMyFoo) <br>// <br> <br>#  define ENLIST_TRACKING(cls)  TrackClassName( #cls ) <br> <br>// <br>// NB:  In a subclass of a class which has INHERIT_TRACKING, do not <br>//      use INHERIT_TRACKING again. However, do use ENLIST_TRACKING in <br>//      in the constructor of the derived class, and use TRACK_ADDREF <br>//      and TRACK_RELEASE if the subclass overrides the AddRef and Release <br>//      methods. <br> <br>// <br>//  TRACK_CLASS(fTrack, pszClassName) <br>// <br>//      Use this to add or remove a class in the list of tracked classes. <br>//      You can turn tracking of all classes on or off by using a NULL <br>//      pszClassName.  If fTrack is TRUE, the class will be tracked, if FALSE, <br>//      the class will no longer be tracked.  The default configuration is <br>//      that all classes are tracked. <br>// <br>//      NOTE: this affects only objects created after this macro is executed. <br>// <br> <br>#  define TRACK_CLASS(fTrack, cls) \ <br>                      ObjectTracker::TrackClass( fTrack, cls ) <br> <br>// <br>//  DUMP_TRACKING_INFO() <br>// <br>//      Place this anywhere it would be useful to dump out the object <br>//      tracking database. By default, this is always issued at program <br>//      termination. <br>// <br> <br>#  define DUMP_TRACKING_INFO()        DUMP_TRACKING_INFO_KEEP() <br>#  define DUMP_TRACKING_INFO_KEEP()   ObjectTracker::DumpTrackingInfo(0) <br>#  define DUMP_TRACKING_INFO_DELETE() ObjectTracker::DumpTrackingInfo(1) <br> <br>//      Output from this is controlled by setting the following mask values <br>//      in OtInfoLevel <br> <br>#  define DEB_OT_OBJECTS        0x00000001L <br>        // display object addresses, reference count and name (Default) <br> <br>#  define DEB_OT_CALLERS        0x80000000L <br>        // display call history <br> <br>// In addition, set the following values to cause debug output during <br>// operation: <br> <br>#  define DEB_OT_ERRORS         0x00000002L <br>        // report errors during tracking operations (Default) <br> <br>#  define DEB_OT_ACTIONS        0x40000000L <br>        // report each create, addref and release <br> <br>#  define DEB_OT_DELETE         0x20000000L <br>        // display call history at object delete <br> <br># else // DBG == 0 <br> <br>inline ObjectTracker::ObjectTracker():_ulRefs(1) {}; <br> <br>#  define DECLARE_STD_REFCOUNTING                                       \ <br>        STDMETHOD_(ULONG, AddRef) ()                                    \ <br>                {                                                       \ <br>                    InterlockedIncrement((long*)&amp;_ulRefs);         \ <br>                    return _ulRefs;                                \ <br>                };                                                      \ <br>        STDMETHOD_(ULONG, Release) ()                                   \ <br>                {                                                          \ <br>                    if ( InterlockedDecrement((long*)&amp;_ulRefs) == 0 ) \ <br>                    {                                                      \ <br>                        delete this;                                       \ <br>                        return 0;                                          \ <br>                    }                                                      \ <br>                    else                                                   \ <br>                        return  _ulRefs;                              \ <br>                }; <br> <br>#  define ENLIST_TRACKING(cls) <br> <br>#  define DUMP_TRACKING_INFO() <br> <br>#  define TRACK_CLASS(fTrack, cls) <br> <br># endif // DBG == 0 <br> <br>#endif  // of ifndef __OTRACK_HXX__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
