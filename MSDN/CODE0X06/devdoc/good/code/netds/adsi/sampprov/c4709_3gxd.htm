<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REGDSAPI.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4711"></a>REGDSAPI.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    RegDSAPI.cpp <br> <br>Abstract: <br> <br>    Sample Provider Registry DS APIs <br>     <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br>#pragma hdrstop <br>#include "string.h" <br> <br>#define SAMPLEDS_REGDSPATH       L"SOFTWARE\\Microsoft\\ADs\\SampleDS\\DS" <br>#define SAMPLEDS_REGSCHEMAPATH   L"SOFTWARE\\Microsoft\\ADs\\SampleDS\\Schema" <br>#define SAMPLEDS_REG_TYPE        L"TYPE" <br>#define SAMPLEDS_REG_MANPROP     L"Mandatory Properties" <br>#define SAMPLEDS_REG_PROPERTY    L"PROPERTY" <br>#define SAMPLEDS_REG_CLASS       L"CLASS" <br>#define SAMPLEDS_REG_SYNTAX      L"Syntax" <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Open an object in the DS. Class of the object is also returned <br>    in szClass if the parameter is not NULL. <br> <br>Arguments: <br>    szClass will be used to store the object class if it is not NULL. <br>    szClass has to be a LPWSTR of length MAX_PATH. <br>     <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSOpenObject(  <br>    LPWSTR szRegPath,              <br>    HANDLE *phKey,                 <br>    LPWSTR szClass, <br>    DWORD  dwType <br>    ) <br>{ <br>    if (!szRegPath ||  <br>        !phKey) <br>        RRETURN(E_FAIL); <br> <br>    WCHAR szFullRegPath[MAX_PATH] = L""; <br>     <br>    switch (dwType) { <br>        case REG_DS: <br>            wcscpy( <br>               szFullRegPath, <br>               SAMPLEDS_REGDSPATH <br>               ); <br>            break; <br>        case REG_SCHEMA: <br>            wcscpy( <br>               szFullRegPath, <br>               SAMPLEDS_REGSCHEMAPATH <br>               ); <br>            break; <br>        default: <br>            RRETURN(E_FAIL); <br>    }; <br> <br>    if (*szRegPath != L'\0')  <br>            wcscat(szFullRegPath, <br>            szRegPath <br>            ); <br>     <br>    if (RegOpenKeyEx(  <br>            HKEY_LOCAL_MACHINE,  <br>            szFullRegPath,  <br>            0,  <br>            KEY_ALL_ACCESS,  <br>            (PHKEY)phKey <br>            ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    } <br>     <br>    if (szClass){ <br>        DWORD dwDataType; <br>        DWORD dwClass = MAX_PATH * sizeof(WCHAR); <br>        if (RegQueryValueEx( <br>                (HKEY)*phKey,  <br>                SAMPLEDS_REG_TYPE, <br>                NULL, <br>                &amp;dwDataType, <br>                (BYTE*)szClass,     <br>                &amp;dwClass <br>                ) != ERROR_SUCCESS) { <br>            goto Error; <br>        } <br>        if (dwDataType != REG_SZ) { <br>            goto Error; <br>        } <br>    } <br>    RRETURN(S_OK); <br>Error: <br>    RegCloseKey((HKEY)*phKey); <br>    RRETURN (E_FAIL); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Close an object in the DS <br>     <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSCloseObject( <br>    HANDLE hKey <br>    ) <br>{ <br>    if (RegCloseKey((HKEY)hKey <br>                    ) != ERROR_SUCCESS)  <br>        RRETURN(E_FAIL); <br>    RRETURN(S_OK); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Setup the enumeration handle of the objects in the DS <br>     <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSRDNEnum(  <br>    HANDLE *phEnum, <br>    HANDLE hContainerKey <br>    ) <br>{ <br>    if (!phEnum) <br>        RRETURN(E_FAIL); <br> <br>    LPREGDS_ENUM lprdsenum = new REGDS_ENUM; <br>    if (lprdsenum == NULL)  <br>        RRETURN(E_OUTOFMEMORY); <br>     <br>    HANDLE hKey = hContainerKey; <br>    if (hKey == NULL) {  <br>        if ( SampleDSOpenObject(L"",  <br>                                &amp;hKey,  <br>                                NULL, <br>                                REG_DS <br>                                ) != ERROR_SUCCESS) { <br>            goto Error; <br>        } <br>    } <br>     <br>    lprdsenum-&gt;dwIndex = 0; <br>    lprdsenum-&gt;hContainerKey= hKey; <br> <br>    *((LPREGDS_ENUM *) phEnum) = lprdsenum; <br>         <br>    RRETURN(S_OK); <br>Error: <br>    delete lprdsenum; <br>    *phEnum = NULL; <br>    RRETURN(E_FAIL); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get the next object in the DS using the enumeration handle created <br>    by SampleDSRDNRnum <br>     <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSNextRDN(  <br>    HANDLE hEnum,       <br>    LPWSTR *pszName,   <br>    LPWSTR *pszClass <br>    ) <br>{ <br>    HRESULT hr = E_FAIL; <br>    DWORD dwName = MAX_PATH; <br>    LRESULT lResult; <br>    FILETIME ftLastWrite; <br> <br>    if (!hEnum || !pszName) <br>        RRETURN(hr); <br> <br>    *pszName = (LPWSTR) AllocProvMem(sizeof(WCHAR)*dwName); <br>    if (*pszName == NULL)   <br>        RRETURN(E_OUTOFMEMORY); <br>     <br>    lResult = RegEnumKeyEx( <br>                   (HKEY)LPREGDS_ENUM(hEnum)-&gt;hContainerKey, <br>                    LPREGDS_ENUM(hEnum)-&gt;dwIndex, <br>                    *pszName,  <br>                    &amp;dwName, <br>                    0,  <br>                    NULL,  <br>                    NULL, <br>                    &amp;ftLastWrite <br>                    );  <br>    if (lResult != ERROR_SUCCESS) { <br>        if (lResult == ERROR_NO_MORE_ITEMS)  <br>            hr = S_FALSE;       // Not an error, no items left <br>        goto Error; <br>    } else { <br>        LPREGDS_ENUM(hEnum)-&gt;dwIndex++; <br>        if (pszClass != NULL) { <br>            DWORD dwClass = MAX_PATH; <br>            *pszClass = (LPWSTR) AllocProvMem(sizeof(WCHAR)*dwClass); <br>            if (*pszClass == NULL) { <br>                hr = E_OUTOFMEMORY; <br>                goto Error; <br>            } <br>            if (SampleDSGetTypeText( <br>                        (HKEY)LPREGDS_ENUM(hEnum)-&gt;hContainerKey, <br>                        *pszName, <br>                        *pszClass, <br>                        &amp;dwClass <br>                        ) != S_OK) { <br>                goto Error; <br>            } <br>        }  <br>    } <br>    RRETURN(S_OK); <br> <br>Error: <br>    if (*pszName) { <br>        FreeProvMem(*pszName); <br>        *pszName = NULL; <br>    } <br>    if (*pszClass) { <br>        FreeProvMem(*pszClass); <br>        *pszClass = NULL; <br>    } <br>    RRETURN(hr); <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Free the enumeration handle <br>         <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSFreeEnum(HANDLE hEnum) <br>{ <br>    if (!hEnum) <br>        RRETURN(E_FAIL); <br> <br>    LPREGDS_ENUM lprdsenum = (LPREGDS_ENUM)hEnum; <br>    if (lprdsenum-&gt;hContainerKey) { <br>        SampleDSCloseObject(lprdsenum-&gt;hContainerKey); <br>    } <br>    delete lprdsenum; <br>    RRETURN(S_OK); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Modify properties of an object in the DS <br>     <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSModifyObject(HANDLE hKey, <br>                     HANDLE hOperationData <br>                     ) <br>{ <br>    if (!hKey) <br>        RRETURN(E_FAIL); <br>     <br>    if (!hOperationData) <br>        RRETURN(S_OK); <br> <br>    LPSampleDS_ATTRS_INFO pAttrsInfo = (LPSampleDS_ATTRS_INFO)hOperationData; <br>    LPSampleDS_ATTR_INFO pInfo = pAttrsInfo-&gt;pAttrInfo; <br>    DWORD cAttrInfo = pAttrsInfo-&gt;dwAttr; <br>     <br>    BYTE* pbData; <br>    DWORD dwData; <br>    DWORD dwType; <br> <br>    for (DWORD i = 0;i &lt; cAttrInfo;i++) { <br>        switch (pInfo-&gt;dwSyntaxId) { <br>            case SampleDS_DATATYPE_1: <br>                { <br>                SampleDS_TYPE_1* pData = (SampleDS_TYPE_1*)pInfo-&gt;lpValue; <br>                pbData = (BYTE*)pData-&gt;DNString; <br>                dwData = (wcslen(pData-&gt;DNString) + 1) * sizeof(WCHAR); <br>                dwType = REG_SZ; <br>                break; <br>                } <br>            case SampleDS_DATATYPE_2: <br>                { <br>                SampleDS_TYPE_2* pData = (SampleDS_TYPE_2*)pInfo-&gt;lpValue; <br>                pbData = (BYTE*)&amp;(pData-&gt;Integer); <br>                dwData = sizeof(DWORD); <br>                dwType = REG_DWORD; <br>                break; <br>                } <br>            default: <br>                RRETURN(E_FAIL); <br>        } <br>        if (RegSetValueEx( <br>                    (HKEY)hKey,          <br>                    pInfo-&gt;lpAttributeName,     <br>                    NULL, <br>                    dwType,     <br>                    pbData, <br>                    dwData <br>                    ) != ERROR_SUCCESS) <br>            RRETURN(E_FAIL); <br>        pInfo++; <br>    } <br>     <br>    RRETURN(NO_ERROR); <br>} <br> <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Read the properties of an object in the DS <br>     <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSReadObject( <br>    HANDLE hkey,               <br>    HANDLE *phOperationData <br>    ) <br>{ <br>    DWORD cValues;                <br>    LPSampleDS_ATTR_INFO pInfo = NULL; <br>    DWORD i;  <br>    LPWSTR pszValue = NULL; <br>    BYTE*  pbData = NULL; <br>    DWORD cProp = 0; <br> <br>    if (RegQueryInfoKey( <br>                (HKEY)hkey,          <br>                NULL, <br>                NULL, <br>                NULL,                      <br>                NULL, <br>                NULL, <br>                NULL, <br>                &amp;cValues,                  <br>                NULL, <br>                NULL, <br>                NULL, <br>                NULL <br>                ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    }; <br>  <br>    if (cValues == 0) { <br>        *phOperationData = NULL; <br>        RRETURN(NO_ERROR); <br>    } <br>     <br>    DWORD dwData; <br>    DWORD dwValue; <br> <br>    pInfo = (LPSampleDS_ATTR_INFO)AllocProvMem( <br>                                      sizeof(SampleDS_ATTR_INFO)*cValues <br>                                      ); <br>    if (!pInfo) <br>        RRETURN(E_OUTOFMEMORY); <br> <br>    for (i = 0; i &lt; cValues; i++) {  <br>        DWORD dwType; <br>        pszValue = (LPWSTR)AllocProvMem(sizeof(WCHAR)*MAX_PATH); <br>        pbData = (BYTE*)AllocProvMem(sizeof(WCHAR)*MAX_PATH); <br>        if (pbData == NULL || pszValue == NULL)  <br>            goto Error; <br>                <br>        dwData = sizeof(WCHAR) * MAX_PATH; <br>        dwValue = sizeof(WCHAR) * MAX_PATH; <br> <br>        if (RegEnumValue( <br>                (HKEY)hkey,  <br>                i,  <br>                pszValue,  <br>                &amp;dwValue,  <br>                NULL,  <br>                &amp;dwType,      <br>                pbData,      <br>                &amp;dwData <br>                ) != ERROR_SUCCESS) <br>            goto Error; <br> <br>      <br>         <br>        if (!_wcsicmp( <br>                pszValue, <br>                SAMPLEDS_REG_TYPE)) { <br>            FreeProvMem(pszValue); <br>            FreeProvMem(pbData); <br>            continue; <br>        }; <br>         <br>        switch (dwType) { <br>            case REG_DWORD: <br>                { <br>                SampleDS_TYPE_2 *pData = NULL; <br>                pData = (SampleDS_TYPE_2*)AllocProvMem( <br>                                               sizeof(SampleDS_TYPE_2)); <br>                if (pData == NULL) <br>                    goto Error; <br>                pInfo[cProp].lpValue = (BYTE*)pData; <br>                pData-&gt;Integer = *(DWORD*)pbData; <br>                pInfo[cProp].dwSyntaxId = SampleDS_DATATYPE_2; <br>                FreeProvMem(pbData); <br>                pbData = NULL; <br>                break; <br>                } <br>            case REG_SZ: <br>                { <br>                SampleDS_TYPE_1 *pData = NULL; <br>                pData = (SampleDS_TYPE_1*)AllocProvMem( <br>                                               sizeof(SampleDS_TYPE_1)); <br>                if (pData == NULL) <br>                    goto Error; <br>                pInfo[cProp].lpValue = (BYTE*)pData; <br>                pData-&gt;DNString = (LPWSTR)pbData; <br>                pInfo[cProp].dwSyntaxId = SampleDS_DATATYPE_1; <br>                break; <br>                } <br>            default: <br>                goto Error; <br>        } <br>        pInfo[cProp].lpAttributeName = pszValue; <br>        pInfo[cProp].dwNumberOfValues = 1; <br>        cProp++; <br>    } <br>     <br>    // Ownership has already been passed <br>    pbData = NULL; <br>    pszValue = NULL; <br> <br>    LPSampleDS_ATTRS_INFO pAttrsInfo; <br>    pAttrsInfo = (LPSampleDS_ATTRS_INFO)AllocProvMem(sizeof(SampleDS_ATTRS_INFO)); <br>    if (!pAttrsInfo) <br>        goto Error; <br>     <br>    pAttrsInfo-&gt;pAttrInfo = pInfo; <br>    pAttrsInfo-&gt;dwAttr = cProp; <br>    *phOperationData = pAttrsInfo; <br>     <br>    RRETURN(NO_ERROR); <br> <br>Error:  <br>    for (DWORD j=0; j&lt;cProp; j++) { <br>        if (pInfo[j].lpAttributeName) <br>            FreeProvMem(pInfo[j].lpAttributeName); <br>        if (pInfo[j].lpValue) { <br>            if (pInfo[j].dwSyntaxId == SampleDS_DATATYPE_1) { <br>                if (((SampleDS_TYPE_1*)(pInfo[j].lpValue))-&gt;DNString) <br>                    FreeProvMem(((SampleDS_TYPE_1*) <br>                                    (pInfo[j].lpValue))-&gt;DNString); <br>            } <br>            FreeProvMem(pInfo[j].lpValue); <br>        } <br>    } <br>    if (pszValue) <br>        FreeProvMem(pszValue); <br>    if (pbData) <br>        FreeProvMem(pbData); <br>    FreeProvMem(pInfo); <br>    RRETURN(E_FAIL); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get all the property defintions from the Schema <br>     <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetPropertyDefinition(  <br>    LPSampleDS_ATTR_DEF* ppAttrDefsReturn, <br>    DWORD *pnumObject) <br>{                            <br>    WCHAR szRegPath[MAX_PATH] = SAMPLEDS_REGSCHEMAPATH; <br>    DWORD numEntries; <br>    HKEY hKey; <br>    LPSampleDS_ATTR_DEF pAttrDefsCurrent;  <br>    LPSampleDS_ATTR_DEF pAttrDefsStart;  <br>    LPWSTR szPropNameCur; <br>    DWORD dwPropNameCur = MAX_PATH; <br>    DWORD numProperties = 0; <br>     <br>    if( RegOpenKeyEx(  <br>            HKEY_LOCAL_MACHINE,  <br>            szRegPath,  <br>            0,  <br>            KEY_ALL_ACCESS,  <br>            &amp;hKey <br>            ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    } <br>     <br>    if( RegQueryInfoKey( <br>                hKey, <br>                NULL, <br>                NULL, <br>                NULL, <br>                &amp;numEntries, <br>                NULL, <br>                NULL, <br>                NULL, <br>                NULL, <br>                NULL, <br>                NULL, <br>                NULL <br>                ) != ERROR_SUCCESS) { <br>        goto Error; <br>    } <br>     <br>    pAttrDefsStart = (LPSampleDS_ATTR_DEF)AllocProvMem( <br>                                    sizeof(SampleDS_ATTR_DEF)*numEntries); <br>    if (!pAttrDefsStart) <br>        goto Error; <br>    pAttrDefsCurrent = pAttrDefsStart; <br>    DWORD i; <br>    for (i=0; i&lt;numEntries; i++) { <br>        szPropNameCur = (LPWSTR)AllocProvMem(sizeof(WCHAR)*dwPropNameCur); <br>        if (!szPropNameCur) <br>            goto Error; <br> <br>        if (RegEnumKey( <br>                hKey, <br>                i, <br>                szPropNameCur, <br>                dwPropNameCur <br>                ) != ERROR_SUCCESS) <br>            goto Error; <br> <br>        if (SampleDSGetPropertyInfo(  <br>                hKey, <br>                szPropNameCur, <br>                pAttrDefsCurrent <br>                ) != ERROR_SUCCESS) { <br>            FreeProvMem(szPropNameCur); <br>            continue; <br>        } <br>        pAttrDefsCurrent-&gt;lpAttributeName = szPropNameCur; <br>        numProperties++; <br>        pAttrDefsCurrent++; <br>    } <br> <br>    // Ownership has been passed <br>    szPropNameCur = NULL; <br> <br>    if (numProperties != numEntries) { <br>        LPSampleDS_ATTR_DEF pAttrDefsFinal;  <br>        pAttrDefsFinal = (LPSampleDS_ATTR_DEF)AllocProvMem( <br>                                    sizeof(SampleDS_ATTR_DEF)*numProperties); <br>        if (!pAttrDefsFinal) <br>            goto Error; <br>        memcpy(  <br>            (void*)pAttrDefsFinal, <br>            (void*)pAttrDefsStart, <br>            sizeof(SampleDS_ATTR_DEF)*numProperties <br>            ); <br>        *ppAttrDefsReturn = pAttrDefsFinal;     <br>        FreeProvMem(pAttrDefsStart); <br>    } <br>    else { <br>        *ppAttrDefsReturn = pAttrDefsStart;  <br>    } <br>    *pnumObject = numProperties; <br>    RegCloseKey(hKey); <br>    RRETURN(S_OK); <br> <br>Error: <br>    RegCloseKey(hKey); <br>    LPSampleDS_ATTR_DEF pAttrDefsDelete = pAttrDefsStart;  <br>    for (DWORD j=0; j&lt;numProperties; j++) { <br>        if (pAttrDefsDelete-&gt;lpAttributeName) <br>            FreeProvMem(pAttrDefsDelete-&gt;lpAttributeName); <br>        pAttrDefsDelete++; <br>    } <br>    if (szPropNameCur) <br>        FreeProvMem(szPropNameCur); <br>    if (pAttrDefsStart) <br>        FreeProvMem(pAttrDefsStart); <br>    RRETURN(E_FAIL); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get a particular property defintion from the schema <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetPropertyDefinition(  <br>    LPSampleDS_ATTR_DEF* ppAttrDefReturn, <br>    LPWSTR szPropName) <br>{                            <br>    WCHAR szRegPath[MAX_PATH] = SAMPLEDS_REGSCHEMAPATH; <br>    DWORD numEntries; <br>    HKEY hKey; <br>    LPSampleDS_ATTR_DEF pAttrDefCurrent;  <br>    LPWSTR szPropNameCur; <br>    DWORD i; <br>     <br>    if( RegOpenKeyEx(  <br>            HKEY_LOCAL_MACHINE,  <br>            szRegPath,  <br>            0,  <br>            KEY_ALL_ACCESS,  <br>            &amp;hKey <br>            ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    } <br>     <br>    if( RegQueryInfoKey( <br>            hKey, <br>            NULL, <br>            NULL, <br>            NULL, <br>            &amp;numEntries, <br>            NULL, <br>            NULL, <br>            NULL, <br>            NULL, <br>            NULL, <br>            NULL, <br>            NULL <br>            ) != ERROR_SUCCESS) { <br>        goto Error; <br>    } <br>     <br>    pAttrDefCurrent= (LPSampleDS_ATTR_DEF)AllocProvMem( <br>                                               sizeof(SampleDS_ATTR_DEF)); <br>    if (!pAttrDefCurrent) <br>        goto Error; <br>    szPropNameCur = (LPWSTR)AllocProvMem(sizeof(WCHAR)*MAX_PATH); <br>    if (!szPropNameCur) <br>        goto Error; <br> <br>    for (i=0; i&lt;numEntries; i++) { <br>        if (RegEnumKey(hKey, <br>            i, <br>            szPropNameCur, <br>            MAX_PATH) != ERROR_SUCCESS) <br>            goto Error; <br> <br>        if (!_wcsicmp( <br>                szPropNameCur, <br>                szPropName)) { <br>            if (SampleDSGetPropertyInfo(  <br>                                hKey, <br>                                szPropNameCur, <br>                                pAttrDefCurrent <br>                                ) != ERROR_SUCCESS)  <br>                goto Error; <br>            pAttrDefCurrent-&gt;lpAttributeName = szPropNameCur; <br>            *ppAttrDefReturn = pAttrDefCurrent;  <br>            RegCloseKey(hKey); <br>            RRETURN(S_OK); <br>        } <br>    } <br>Error: <br>    RegCloseKey(hKey); <br>    if (szPropNameCur) <br>        FreeProvMem(szPropNameCur); <br>    if (pAttrDefCurrent) <br>        FreeProvMem(pAttrDefCurrent); <br>    RRETURN(E_FAIL); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Free memory allocated by GetPropertyDefinition <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT     <br>SampleDSFreePropertyDefinition(LPSampleDS_ATTR_DEF pAttrDefs, <br>                               DWORD numObject) <br>{ <br>    if (!pAttrDefs) <br>        RRETURN(E_FAIL); <br> <br>    LPSampleDS_ATTR_DEF pAttrDefCurrent = pAttrDefs; <br>    for (DWORD j=0; j&lt;numObject; j++) { <br>        if (pAttrDefCurrent-&gt;lpAttributeName) <br>            FreeProvMem(pAttrDefCurrent-&gt;lpAttributeName); <br>        pAttrDefCurrent++; <br>    } <br>    FreeProvMem(pAttrDefs); <br>    RRETURN(S_OK); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get the type of an object in text format <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetTypeText(HKEY hKey, <br>                    LPWSTR szPropertyName, <br>                    LPWSTR szClassName, <br>                    DWORD *pdwClassName)  <br>{ <br>    HKEY hKeyProperty; <br>     <br>    if (RegOpenKey( <br>            hKey, <br>            szPropertyName, <br>            &amp;hKeyProperty <br>            ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    } <br>     <br>    DWORD dwType; <br>    if (RegQueryValueEx( <br>            hKeyProperty,  <br>            SAMPLEDS_REG_TYPE, <br>            NULL, <br>            &amp;dwType, <br>            (BYTE*)szClassName,     <br>            pdwClassName <br>            ) != ERROR_SUCCESS) { <br>        goto Error; <br>    } <br> <br>    if (dwType != REG_SZ) { <br>        goto Error; <br>    } <br>    RegCloseKey(hKeyProperty); <br>    RRETURN(S_OK); <br>Error: <br>    RegCloseKey(hKeyProperty); <br>    RRETURN(E_FAIL); <br> <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get the type of an object  <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetType(HKEY hKey, <br>                LPWSTR szPropertyName, <br>                DWORD *pdwType) <br>{ <br>    HRESULT hrReturn = S_OK; <br>    LPWSTR szClassName; <br>    DWORD dwClassName = MAX_PATH * sizeof(WCHAR); <br> <br>    szClassName = (LPWSTR)AllocProvMem(dwClassName); <br>    if (!szClassName) { <br>        hrReturn = E_OUTOFMEMORY; <br>        goto Error; <br>    } <br> <br>    if (SampleDSGetTypeText( <br>                    hKey, <br>                    szPropertyName, <br>                    szClassName, <br>                    &amp;dwClassName <br>                    ) == E_FAIL) { <br>        hrReturn = E_FAIL; <br>        goto Error; <br>    } <br>        <br>    if (!_wcsicmp( <br>            szClassName, <br>            SAMPLEDS_REG_PROPERTY)) { <br>        *pdwType = SAMPLEDS_PROPERTY; <br>    } <br>    else if (!_wcsicmp( <br>                szClassName, <br>                SAMPLEDS_REG_CLASS)) { <br>        *pdwType = SAMPLEDS_CLASS; <br>    } <br>    else { <br>        *pdwType = SAMPLEDS_UNKNOWN; <br>    } <br>Error: <br>    if (szClassName) <br>        FreeProvMem(szClassName); <br>    RRETURN(hrReturn); <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get information about a property from the schema <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetPropertyInfo(HKEY hKey, <br>                        LPWSTR szPropertyName, <br>                        LPSampleDS_ATTR_DEF pAttrDef) <br>{ <br>    HKEY hKeyClass; <br>    DWORD dwSyntax; <br>    DWORD dwType; <br>    DWORD dwSyntaxSize = sizeof(DWORD); <br>    DWORD dwSchemaType; <br> <br>    if ((SampleDSGetType( <br>                    hKey, <br>                    szPropertyName, <br>                    &amp;dwSchemaType <br>                    ) == E_FAIL) ||  <br>        (dwSchemaType != SAMPLEDS_PROPERTY))  <br>        RRETURN(E_FAIL); <br>     <br>    if (RegOpenKeyEx( <br>                hKey, <br>                szPropertyName, <br>                NULL, <br>                KEY_READ, <br>                &amp;hKeyClass <br>                ) != ERROR_SUCCESS) <br>        RRETURN(E_FAIL); <br> <br>    if (RegQueryValueEx( <br>                    hKeyClass,  <br>                    SAMPLEDS_REG_SYNTAX, <br>                    NULL, <br>                    &amp;dwType, <br>                    (BYTE*)&amp;dwSyntax,     <br>                    &amp;dwSyntaxSize <br>                    ) == ERROR_SUCCESS) { <br>        pAttrDef-&gt;dwSyntaxID = dwSyntax; <br>        RegCloseKey(hKeyClass); <br>        RRETURN(S_OK); <br>    }  <br>    RegCloseKey(hKeyClass); <br>    RRETURN(E_FAIL); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Free the memory used by a LPWSTR_LIST <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>void FreeList(LPWSTR_LIST pList) <br>{ <br>    if (pList) { <br>        if (pList-&gt;lpString) { <br>            FreeProvStr(pList-&gt;lpString); <br>                } <br>        FreeList(pList-&gt;Next); <br>        FreeProvMem(pList); <br>        }; <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetClassDefinition(  <br>    LPSampleDS_CLASS_DEF* ppClassDefsReturn, <br>    DWORD *pnumObject) <br>{                            <br>    WCHAR szRegPath[MAX_PATH] = SAMPLEDS_REGSCHEMAPATH; <br>    DWORD numEntries; <br>    HKEY hKey; <br>    LPSampleDS_CLASS_DEF pClassDefsCurrent;  <br>    LPSampleDS_CLASS_DEF pClassDefsStart;  <br>    LPWSTR szClassName; <br>    DWORD dwClassName = MAX_PATH; <br>    DWORD numClass = 0; <br>     <br>    if( RegOpenKeyEx(  <br>                HKEY_LOCAL_MACHINE,  <br>                szRegPath,  <br>                0,  <br>                KEY_ALL_ACCESS,  <br>                &amp;hKey <br>                ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    } <br>     <br>    if( RegQueryInfoKey( <br>                    hKey, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    &amp;numEntries, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL <br>                    ) != ERROR_SUCCESS) { <br>        goto Error; <br>    } <br>     <br>    pClassDefsStart = (LPSampleDS_CLASS_DEF)AllocProvMem( <br>                                      sizeof(SampleDS_CLASS_DEF)*numEntries); <br>    if (!pClassDefsStart) <br>        goto Error; <br>    pClassDefsCurrent = pClassDefsStart; <br>    DWORD i; <br>    for (i=0; i&lt;numEntries; i++) { <br>        szClassName = (LPWSTR)AllocProvMem(sizeof(WCHAR)*dwClassName); <br>        if (!szClassName) <br>            goto Error; <br> <br>        if (RegEnumKey( <br>                    hKey, <br>                    i, <br>                    szClassName, <br>                    dwClassName <br>                    ) != ERROR_SUCCESS) <br>            goto Error; <br> <br>        if (SampleDSGetClassInfo( <br>                            hKey, <br>                            szClassName, <br>                            pClassDefsCurrent <br>                            ) != ERROR_SUCCESS) { <br>            FreeProvMem(szClassName); <br>            continue; <br>        } <br>        pClassDefsCurrent-&gt;lpClassName = szClassName; <br>        numClass++; <br>        pClassDefsCurrent++; <br>    } <br>    szClassName = NULL; <br> <br>    if (numClass != numEntries) { <br>        LPSampleDS_CLASS_DEF pClassDefsFinal;  <br>        pClassDefsFinal = (LPSampleDS_CLASS_DEF)AllocProvMem( <br>                                     sizeof(SampleDS_CLASS_DEF)*numClass); <br>        if (!pClassDefsFinal) <br>            goto Error; <br>        memcpy(  <br>            (void*)pClassDefsFinal, <br>            (void*)pClassDefsStart, <br>            sizeof(SampleDS_CLASS_DEF)*numClass <br>            ); <br>        *ppClassDefsReturn = pClassDefsFinal; <br>        FreeProvMem(pClassDefsStart); <br>    } <br>    else { <br>        *ppClassDefsReturn = pClassDefsStart;  <br>    } <br>    *pnumObject = numClass; <br>    RegCloseKey(hKey); <br>    RRETURN(S_OK); <br> <br>Error: <br>    RegCloseKey(hKey); <br>    LPSampleDS_CLASS_DEF pClassDefsDelete = pClassDefsStart;  <br>    DWORD j; <br>    for (j=0; j&lt;numClass; j++) { <br>        if (pClassDefsDelete-&gt;lpClassName) <br>            FreeProvMem(pClassDefsDelete-&gt;lpClassName); <br>        if (pClassDefsDelete-&gt;lpMandatoryAttributes) <br>            FreeList(pClassDefsDelete-&gt;lpMandatoryAttributes); <br>        pClassDefsDelete++; <br>    } <br>    if (szClassName) <br>        FreeProvMem(szClassName); <br>    if (pClassDefsStart) <br>        FreeProvMem(pClassDefsStart); <br>    RRETURN(E_FAIL); <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get the class defintion for a particular class  <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetClassDefinition(  <br>    LPSampleDS_CLASS_DEF* ppClassDefReturn, <br>    LPWSTR szClassName) <br>{                            <br>    WCHAR szRegPath[MAX_PATH] = SAMPLEDS_REGSCHEMAPATH; <br>    DWORD numEntries; <br>    HKEY hKey; <br>    LPSampleDS_CLASS_DEF pClassDefCurrent;  <br>    LPWSTR szClassNameCurrent; <br>    DWORD i; <br>     <br>    if( RegOpenKeyEx(  <br>                HKEY_LOCAL_MACHINE,  <br>                szRegPath,  <br>                0,  <br>                KEY_ALL_ACCESS,  <br>                &amp;hKey <br>                ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    } <br>     <br>    if( RegQueryInfoKey( <br>                    hKey, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    &amp;numEntries, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL, <br>                    NULL <br>                    ) != ERROR_SUCCESS) { <br>        goto Error; <br>    } <br>     <br>    pClassDefCurrent= (LPSampleDS_CLASS_DEF)AllocProvMem( <br>                                             sizeof(SampleDS_CLASS_DEF)); <br>    if (!pClassDefCurrent) <br>        goto Error; <br>    szClassNameCurrent = (LPWSTR)AllocProvMem(sizeof(WCHAR)*MAX_PATH); <br>    if (!szClassNameCurrent) <br>        goto Error; <br> <br>    for (i=0; i&lt;numEntries; i++) { <br>        if (RegEnumKey(hKey, <br>            i, <br>            szClassNameCurrent, <br>            MAX_PATH) != ERROR_SUCCESS) <br>            goto Error; <br> <br>        if (!_wcsicmp(szClassNameCurrent,szClassName)) { <br>            if (SampleDSGetClassInfo(  <br>                                hKey, <br>                                szClassNameCurrent, <br>                                pClassDefCurrent <br>                                ) != ERROR_SUCCESS) <br>                goto Error; <br>            pClassDefCurrent-&gt;lpClassName = szClassNameCurrent; <br>            *ppClassDefReturn = pClassDefCurrent;  <br>            RegCloseKey(hKey); <br>            RRETURN(S_OK); <br>        } <br>    } <br>Error: <br>    RegCloseKey(hKey); <br>    if (szClassNameCurrent) <br>        FreeProvMem(szClassNameCurrent); <br>    if (pClassDefCurrent) <br>        FreeProvMem(pClassDefCurrent); <br>    RRETURN(E_FAIL); <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Free memory allocated by GetClassDefinition <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT     <br>SampleDSFreeClassDefinition(LPSampleDS_CLASS_DEF pClassDefs, <br>                            DWORD numObject) <br>{ <br>    if (!pClassDefs) <br>        RRETURN(E_FAIL); <br> <br>    LPSampleDS_CLASS_DEF pClassDefCurrent = pClassDefs; <br>    for (DWORD j=0; j&lt;numObject; j++) { <br>        if (pClassDefCurrent-&gt;lpClassName) </code></pre>
<p>
</p>
<pre><code>FreeProvMem(pClassDefCurrent-&gt;lpClassName); <br>        if (pClassDefCurrent-&gt;lpMandatoryAttributes) <br>            FreeList(pClassDefCurrent-&gt;lpMandatoryAttributes); <br>        pClassDefCurrent++; <br>    } <br>    FreeProvMem(pClassDefs); <br>    RRETURN(S_OK); <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get the next token in a REG_MULTISZ string returned by the  <br>    Regsitry getvalue function  <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>LPWSTR nexttoken(LPWSTR szCurrent) <br>{ <br>    static LPWSTR szRemainder = NULL; <br>    LPWSTR szReturn = NULL; <br> <br>    if (szCurrent) { <br>        szRemainder = szCurrent; <br>    }  <br>    else if (szRemainder == NULL) { <br>        return NULL; <br>    } <br> <br>    if (*szRemainder) { <br>        szReturn = szRemainder; <br>        while (*++szRemainder); <br>        szRemainder++; <br>    } <br>    return szReturn; <br>} <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Get information about a particular class from the schema <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSGetClassInfo(HKEY hKey, <br>                     LPWSTR szClassName, <br>                     LPSampleDS_CLASS_DEF pClassDef) <br>{ <br>    HKEY hKeyClass; <br>    DWORD dwType; <br>    LPWSTR szProperties; <br>    DWORD dwProperties = MAX_PATH * 3; <br>    LPWSTR_LIST pListStart = NULL;  <br> <br>    DWORD dwManProp = 0; <br>    LPWSTR_LIST pListCurrent = NULL;  <br>    LPWSTR szPropCurrent = NULL; <br>    LPWSTR szProperty = NULL; <br>    LPWSTR szPropertyNew = NULL; <br>     <br>    DWORD dwSchemaType; <br>    if ((SampleDSGetType( <br>                    hKey, <br>                    szClassName, <br>                    &amp;dwSchemaType) == E_FAIL) ||  <br>        (dwSchemaType != SAMPLEDS_CLASS))  <br>        RRETURN(E_FAIL); <br>     <br>    if (RegOpenKeyEx( <br>                hKey, <br>                szClassName, <br>                NULL, <br>                KEY_READ, <br>                &amp;hKeyClass <br>                ) != ERROR_SUCCESS) <br>        RRETURN(E_FAIL); <br> <br>    szProperties= (LPWSTR)AllocProvMem(sizeof(WCHAR)*dwProperties); <br>    if (!szProperties) <br>        goto Error; <br> <br>    if (RegQueryValueEx( <br>                    hKeyClass,  <br>                    SAMPLEDS_REG_MANPROP, <br>                    NULL, <br>                    &amp;dwType, <br>                    (BYTE*)szProperties,     <br>                    &amp;dwProperties <br>                    ) != ERROR_SUCCESS) { <br>        goto Error; <br>    } <br>    if (dwType != REG_MULTI_SZ) { <br>        goto Error; <br>    } <br> <br>    szPropCurrent = szProperties; <br>    szProperty = nexttoken(szPropCurrent); <br>    szPropertyNew; <br>    if (szProperty) { <br>        pListStart = (LPWSTR_LIST)AllocProvMem(sizeof(WSTR_LIST)); <br>        if (!pListStart) <br>            goto Error; <br>        pListCurrent = pListStart; <br>        szPropertyNew = AllocProvStr(szProperty); <br>        if (!szPropertyNew) <br>            goto Error; <br>        pListCurrent-&gt;lpString = szPropertyNew; <br>        szProperty = nexttoken(NULL); <br>        dwManProp++; <br>        while( szProperty != NULL ) { <br>            LPWSTR_LIST pListNew = (LPWSTR_LIST)AllocProvMem( <br>                                                  sizeof(WSTR_LIST)); <br>            if (!pListNew) <br>                goto Error; <br>            pListCurrent-&gt;Next = pListNew; <br>            szPropertyNew = AllocProvStr(szProperty); <br>            if (!szPropertyNew) <br>                goto Error; <br>            pListNew-&gt;lpString = szPropertyNew; <br>            pListCurrent = pListNew; <br>            szProperty = nexttoken(NULL); <br>            dwManProp++; <br>        }                               <br>       pListCurrent-&gt;Next = NULL; <br>    } <br>    pClassDef-&gt;lpMandatoryAttributes = pListStart; <br>    pClassDef-&gt;dwNumberOfMandatoryAttributes = dwManProp; <br>    RegCloseKey(hKeyClass); <br>    RRETURN(S_OK);       <br> <br>Error: <br>    RegCloseKey(hKeyClass); <br>    if (pListStart) <br>        FreeList(pListStart); <br>    if (szProperties) <br>        FreeProvMem(szProperties); <br>    RRETURN(E_FAIL); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br>     <br>    Add an object in the DS <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSAddObject(HANDLE hKey, <br>                  LPWSTR szObject, <br>                  LPWSTR szClass, <br>                  HANDLE hOperationData <br>                  ) <br>{ <br>    if (!szObject || !szClass || !hKey) <br>        RRETURN(E_FAIL); <br> <br>    HKEY hKeyNew; <br>    if (RegCreateKey( <br>                (HKEY)hKey, <br>                szObject, <br>                &amp;hKeyNew <br>                ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    }; <br>     <br>    if (RegSetValueEx( <br>                hKeyNew, <br>                SAMPLEDS_REG_TYPE, <br>                NULL, <br>                REG_SZ, <br>                (BYTE*)szClass, <br>                (wcslen(szClass) + 1) * sizeof(WCHAR) <br>                ) != ERROR_SUCCESS) { <br>        RRETURN(E_FAIL); <br>    }; <br>    if (hOperationData) { <br>        if (SampleDSModifyObject( <br>                            hKeyNew, <br>                            hOperationData <br>                            ) != S_OK) { <br>            RRETURN(E_FAIL); <br>        }; <br>    }; <br>    RRETURN(S_OK); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Delete a registry key and all its subkeys <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>LONG RegDeleteAllKeys(HKEY hKeyDelete, <br>                      LPWSTR pszSubKey) <br>{ <br>    HKEY  hKeyChild; <br>    TCHAR szTmp[MAX_PATH]; <br>    LONG  lResult; <br>    DWORD dwTmpSize = MAX_PATH; <br> <br>    lResult = RegOpenKeyEx( <br>                       hKeyDelete, <br>                       pszSubKey, <br>                       NULL, <br>                       KEY_ALL_ACCESS, <br>                       &amp;hKeyChild <br>                       ); <br>    if (lResult != ERROR_SUCCESS) <br>        return lResult; <br>    <br>    lResult = RegEnumKey( <br>                     hKeyChild, <br>                     0, <br>                     szTmp, <br>                     dwTmpSize <br>                     ); <br> <br>    while (lResult != ERROR_NO_MORE_ITEMS) { <br>        RegDeleteAllKeys( <br>                 hKeyChild, <br>                 szTmp <br>                 ); <br> <br>        lResult = RegEnumKey( <br>                         hKeyChild, <br>                         0, <br>                         szTmp, <br>                         dwTmpSize <br>                         ); <br>    }    <br> <br>    RegCloseKey(hKeyChild); <br>    lResult = RegDeleteKey( <br>                       hKeyDelete, <br>                       pszSubKey <br>                       ); <br> <br>    return lResult; <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Remove an object from the DS <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSRemoveObject(HANDLE hKey, <br>                     LPWSTR szObject)  <br>{ <br>    if (RegDeleteAllKeys( <br>                    (HKEY)hKey, <br>                    szObject <br>                    ) == ERROR_SUCCESS) <br>        RRETURN(S_OK); <br>    else <br>        RRETURN(E_FAIL); <br>} <br> <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Create Memory Buffer for operation data <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSCreateBuffer(HANDLE *phOperationData) <br>{ <br>    LPSampleDS_ATTRS_INFO pAttrsInfo; <br>    pAttrsInfo = (LPSampleDS_ATTRS_INFO)AllocProvMem(sizeof(SampleDS_ATTRS_INFO)); <br>    if (!pAttrsInfo) <br>        RRETURN(E_OUTOFMEMORY); <br>    *phOperationData = pAttrsInfo; <br>    RRETURN(S_OK); <br>} <br> <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Free memroy pointed to by operationdata <br> <br>Arguments: <br> <br>Return Value: <br> <br>--*/ <br>HRESULT <br>SampleDSFreeBuffer(HANDLE hOperationData) <br>{ <br>    if (!hOperationData) <br>        RRETURN(E_FAIL); <br>     <br>    LPSampleDS_ATTRS_INFO pAttrsInfo; <br>    pAttrsInfo = (LPSampleDS_ATTRS_INFO)hOperationData; <br> <br>    LPSampleDS_ATTR_INFO pAttrInfo; <br>    DWORD cAttr; <br>    pAttrInfo = pAttrsInfo-&gt;pAttrInfo; <br>    cAttr = pAttrsInfo-&gt;dwAttr; <br> <br>    if (pAttrInfo) { <br>        for (DWORD i = 0;i&lt;cAttr;i++) { <br>            if (pAttrInfo-&gt;lpAttributeName) <br>                FreeProvMem(pAttrInfo-&gt;lpAttributeName); <br>            if (pAttrInfo-&gt;lpValue) { <br>                if (pAttrInfo-&gt;dwSyntaxId == SampleDS_DATATYPE_1) { <br>                    if (((SampleDS_TYPE_1*)(pAttrInfo-&gt;lpValue))-&gt;DNString) <br>                        FreeProvMem(((SampleDS_TYPE_1*) <br>                                        (pAttrInfo-&gt;lpValue))-&gt;DNString); <br>                } <br>                FreeProvMem(pAttrInfo-&gt;lpValue); <br>            } <br>            pAttrInfo++; <br>        } <br>    } <br>    FreeProvMem(pAttrsInfo-&gt;pAttrInfo); <br>    FreeProvMem(pAttrsInfo); <br>    RRETURN(S_OK); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
