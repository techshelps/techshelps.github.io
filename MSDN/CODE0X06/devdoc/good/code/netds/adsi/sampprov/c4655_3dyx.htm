<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDISPMGR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4659"></a>CDISPMGR.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    CDispMgr.c <br> <br>Abstract: <br> <br>    Dispatch Manager implementation <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br>#pragma hdrstop <br> <br>DISPID <br>CDispatchMgr::getDISPID(DISPID InputDispId) <br>{ <br>    return(InputDispId &amp; 0x0000FFFF); <br>} <br> <br>DISPID <br>CDispatchMgr::getTypeinfoID(DISPID InputDispId) <br>{ <br>    return((InputDispId &amp; 0x7fff0000) &gt;&gt; 16); <br>} <br> <br>void * <br>CDispatchMgr::getInterfacePtr(DISPID TypeinfoID <br>                                  ) <br>{ <br>    PTYPEINFOENTRY pTypeInfoEntry = NULL; <br>    pTypeInfoEntry = _pTypeInfoEntry; <br>    while (pTypeInfoEntry) { <br>        if (pTypeInfoEntry-&gt;TypeInfoId == TypeinfoID) { <br>            return(pTypeInfoEntry-&gt;pInterfacePointer); <br>        } <br>        pTypeInfoEntry = pTypeInfoEntry-&gt;pNext; <br>    } <br>    return(NULL); <br>} <br> <br>PTYPEINFOENTRY <br>CDispatchMgr::FindTypeInfoEntry(LONG TypeInfoId) <br>{ <br>    PTYPEINFOENTRY pTypeInfoEntry; <br> <br>    pTypeInfoEntry = _pTypeInfoEntry; <br>    while (pTypeInfoEntry) { <br>        if (pTypeInfoEntry-&gt;TypeInfoId == TypeInfoId) { <br>            return(pTypeInfoEntry); <br>        } <br>        pTypeInfoEntry = pTypeInfoEntry-&gt;pNext; <br>    } <br>    return(NULL); <br>} <br> <br> <br> <br>HRESULT <br>CDispatchMgr::AddTypeInfo(void FAR *ptypeinfo, <br>                               void * pIntfptr) <br>{ <br>    PTYPEINFOENTRY pTypeInfoEntry = NULL; <br>    HRESULT hr; <br> <br>    if (pTypeInfoEntry =FindTypeInfo(ptypeinfo)) { <br>        return(E_FAIL); <br>    } <br>    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY)); <br>    if (!pTypeInfoEntry) { <br>        hr = E_OUTOFMEMORY; <br>        BAIL_IF_ERROR(hr); <br>    } <br> <br>    pTypeInfoEntry-&gt;ptypeinfo = ptypeinfo; <br>    pTypeInfoEntry-&gt;TypeInfoId = gentypeinfoid(); <br>    pTypeInfoEntry-&gt;pInterfacePointer = pIntfptr; <br> <br>    pTypeInfoEntry-&gt;pNext = _pTypeInfoEntry; <br>    _pTypeInfoEntry = pTypeInfoEntry; <br> <br>    RRETURN(S_OK); <br> <br>cleanup: <br>    RRETURN(hr); <br>} <br> <br>STDMETHODIMP <br>CDispatchMgr::GetTypeInfoCount(unsigned int FAR* pctinfo) <br>{ <br>    RRETURN(E_NOTIMPL); <br>} <br> <br>STDMETHODIMP <br>CDispatchMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, <br>        ITypeInfo FAR* FAR* pptinfo) <br>{ <br>    RRETURN(E_NOTIMPL); <br>} <br> <br>STDMETHODIMP <br>CDispatchMgr::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames, <br>        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid) <br>{ <br>    PTYPEINFOENTRY pTypeInfo = NULL; <br>    HRESULT hr; <br> <br>    pTypeInfo = _pTypeInfoEntry; <br>    while (pTypeInfo) { <br>        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo-&gt;ptypeinfo), <br>                                rgszNames, <br>                                cNames, <br>                                rgdispid <br>                                ); <br>        if (SUCCEEDED(hr)) { <br>            generate_newids(pTypeInfo-&gt;TypeInfoId, <br>                            rgdispid, <br>                            cNames <br>                            ); <br>            RRETURN(hr); <br>        } <br>        pTypeInfo = pTypeInfo-&gt;pNext; <br>    } <br>    RRETURN(E_FAIL); <br>} <br> <br>STDMETHODIMP <br>CDispatchMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, <br>        unsigned short wFlags, DISPPARAMS FAR* pdispparams, <br>        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo, <br>        unsigned int FAR* puArgErr) <br>{ <br>        RRETURN(TypeInfoInvoke(dispidMember, <br>                               iid, <br>                               lcid, <br>                               wFlags, <br>                               pdispparams, <br>                               pvarResult, <br>                               pexcepinfo, <br>                               puArgErr <br>                               )); <br>} <br> <br>void <br>CDispatchMgr::generate_newids(LONG TypeInfoId, <br>        DISPID FAR* rgdispid, unsigned int cNames) <br>{ <br>    unsigned int i = 0; <br>    for (i = 0; i &lt; cNames; i++ ) { <br>        rgdispid[i] = (DISPID)(((unsigned int)TypeInfoId &lt;&lt; 16) | rgdispid[i]); <br>    } <br>} <br> <br>STDMETHODIMP <br>CDispatchMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid, <br>        unsigned short wFlags, DISPPARAMS FAR* pdispparams, <br>        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo, <br>        unsigned int FAR* puArgErr) <br>{ <br> <br>    void * pInterfacePtr = NULL; <br>    DISPID dispid; <br>    DISPID typeinfoid; <br>    ITypeInfo *pTypeInfo; <br>    HRESULT hr = S_OK; <br> <br>    if (dispidMember &lt;= 0) { <br>        dispid = dispidMember; <br>        switch (dispid) { <br>        case -4: <br>            if (_pDispidNewEnum) { <br>                pTypeInfo = (ITypeInfo *)_pDispidNewEnum-&gt;ptypeinfo; <br>                pInterfacePtr = _pDispidNewEnum-&gt;pInterfacePointer; <br>                break; <br> <br>            }else { <br>                hr = DISP_E_BADINDEX; <br>                BAIL_IF_ERROR(hr); <br> <br>            } <br>            break; <br> <br>        default: <br>             hr = DISP_E_BADINDEX; <br>             BAIL_IF_ERROR(hr); <br> <br>        } <br> <br>    }else { <br>        typeinfoid = getTypeinfoID(dispidMember); <br>        dispid = getDISPID(dispidMember); <br>        pInterfacePtr = getInterfacePtr(typeinfoid); <br>        hr = getTypeInfo(typeinfoid, &amp;pTypeInfo); <br>        BAIL_IF_ERROR(hr); <br>    } <br> <br>    hr = DispInvoke(pInterfacePtr, <br>                pTypeInfo, <br>                dispid, <br>                wFlags, <br>                pdispparams, <br>                pvarResult, <br>                pexcepinfo, <br>                puArgErr <br>                ); <br>    return hr; <br> <br>cleanup: <br> <br>    RRETURN(hr); <br>} <br> <br> <br>HRESULT <br>CDispatchMgr::getTypeInfo(DISPID typeinfoid, ITypeInfo FAR * FAR * ppTypeInfo) <br>{ <br>    PTYPEINFOENTRY pTypeInfoEntry; <br>    pTypeInfoEntry = _pTypeInfoEntry; <br>    while (pTypeInfoEntry) { <br>        if (pTypeInfoEntry-&gt;TypeInfoId == typeinfoid) { <br>            *ppTypeInfo = (ITypeInfo FAR *)pTypeInfoEntry-&gt;ptypeinfo; <br>            RRETURN(S_OK); <br>        } <br>        pTypeInfoEntry = pTypeInfoEntry-&gt;pNext; <br>    } <br>    RRETURN(E_FAIL); <br>} <br> <br>CDispatchMgr::CDispatchMgr() <br>{ <br>    _pTypeInfoEntry = NULL; <br>    _pDispidNewEnum = NULL; <br>    _dwTypeInfoId = 0; <br>} <br> <br>CDispatchMgr::~CDispatchMgr() <br>{ <br>    PTYPEINFOENTRY pTypeInfoEntry = NULL; <br>    PTYPEINFOENTRY pTemp = NULL; <br>    ITypeInfo *pTypeInfo = NULL; <br> <br>    pTypeInfoEntry = _pTypeInfoEntry; <br> <br>    while (pTypeInfoEntry) { <br> <br>        pTemp = pTypeInfoEntry; <br> <br>        pTypeInfo = (ITypeInfo *)pTypeInfoEntry-&gt;ptypeinfo; <br>        pTypeInfo-&gt;Release(); <br> <br>        pTypeInfoEntry = pTemp-&gt;pNext; <br> <br>        LocalFree(pTemp); <br>    } <br>} <br> <br>HRESULT <br>CDispatchMgr::MarkAsNewEnum(void *pTypeInfo) <br>{ <br>    PTYPEINFOENTRY pTypeInfoEntry; <br> <br>    if (!pTypeInfo) { <br>        RRETURN(E_FAIL); <br>    } <br>    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) { <br>        RRETURN(E_FAIL); <br>    } <br>    _pDispidNewEnum = pTypeInfoEntry; <br>    RRETURN(S_OK); <br>} <br> <br> <br> <br>PTYPEINFOENTRY <br>CDispatchMgr::FindTypeInfo(void *pTypeInfo) <br>{ <br>    PTYPEINFOENTRY pTypeInfoEntry; <br> <br>    pTypeInfoEntry = _pTypeInfoEntry; <br>    while (pTypeInfoEntry) { <br>        if (pTypeInfoEntry-&gt;ptypeinfo == pTypeInfo) { <br>            return(pTypeInfoEntry); <br>        } <br>        pTypeInfoEntry = pTypeInfoEntry-&gt;pNext; <br>    } <br>    return(NULL); <br>} <br> <br>LONG <br>CDispatchMgr::gentypeinfoid() <br>{ <br>    return (_dwTypeInfoId++); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
