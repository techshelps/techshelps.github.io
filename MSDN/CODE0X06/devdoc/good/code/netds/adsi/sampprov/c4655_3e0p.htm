<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CGENOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4669"></a>CGENOBJ.CPP</h2>
<pre><code>/*++  <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    CGenObj.cpp <br> <br>Abstract: <br> <br>    Microsoft ADs DS Provider Generic Object <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br>#pragma hdrstop <br> <br>DEFINE_IDispatch_Implementation(CSampleDSGenObject) <br>DEFINE_IADs_Implementation(CSampleDSGenObject) <br> <br> <br>CSampleDSGenObject::CSampleDSGenObject():_pPropertyCache(NULL) <br>{ <br>    VariantInit(&amp;_vFilter); <br>} <br> <br>HRESULT <br>CSampleDSGenObject::CreateGenericObject( <br>    BSTR Parent, <br>    BSTR CommonName, <br>    BSTR ClassName, <br>    DWORD dwObjectState, <br>    REFIID riid, <br>    void **ppvObj <br>    ) <br>{ <br>    CSampleDSGenObject FAR * pGenObject = NULL; <br>    HRESULT hr = S_OK; <br> <br>    hr = AllocateGenObject(&amp;pGenObject); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = pGenObject-&gt;InitializeCoreObject( <br>                Parent, <br>                CommonName, <br>                ClassName, <br>                L"", <br>                CLSID_SampleDSGenObject, <br>                dwObjectState <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = pGenObject-&gt;QueryInterface(riid, ppvObj); <br>    BAIL_ON_FAILURE(hr); <br> <br>    pGenObject-&gt;Release(); <br> <br>    RRETURN(hr); <br> <br>error: <br> <br>    delete pGenObject; <br> <br>    RRETURN(hr); <br>} <br> <br>CSampleDSGenObject::~CSampleDSGenObject( ) <br>{ <br> <br>    delete _pDispMgr; <br>    delete _pPropertyCache; <br> <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv) <br>{ <br>    if (IsEqualIID(iid, IID_IUnknown)) <br>    { <br>        *ppv = (IADs FAR *) this; <br>    } <br>    else if (IsEqualIID(iid, IID_IADsContainer)) <br>    { <br>        *ppv = (IADsContainer FAR *) this; <br>    } <br>    else if (IsEqualIID(iid, IID_IADs)) <br>    { <br>        *ppv = (IADs FAR *) this; <br>    } <br>    else if (IsEqualIID(iid, IID_IDispatch)) <br>    { <br>        *ppv = (IADs FAR *) this; <br>    } <br>    else <br>    { <br>        *ppv = NULL; <br>        return E_NOINTERFACE; <br>    } <br>    AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>HRESULT <br>CSampleDSGenObject::SetInfo() <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (GetObjectState() == ADS_OBJECT_UNBOUND) { <br> <br>        hr = SampleDSCreateObject(); <br>        BAIL_ON_FAILURE(hr); <br> <br>        // <br>        // If the create succeded, set the object type to bound <br>        // <br> <br>        SetObjectState(ADS_OBJECT_BOUND); <br> <br>    }else { <br> <br>        hr = SampleDSSetObject(); <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>error: <br> <br>    RRETURN(hr); <br>} <br> <br> <br>HRESULT <br>CSampleDSGenObject::SampleDSSetObject() <br>{ <br>    WCHAR szSampleDSPathName[MAX_PATH]; <br>    HANDLE hObject = NULL; <br>    HRESULT hr = S_OK; <br>    HANDLE hOperationData = NULL; <br> <br> <br>    hr = BuildDSPathFromADsPath( <br>                _ADsPath, <br>                szSampleDSPathName <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>     <br>    hr = SampleDSOpenObject( <br>                    szSampleDSPathName, <br>                    &amp;hObject, <br>                    NULL, <br>                    REG_DS <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SampleDSCreateBuffer(&amp;hOperationData); <br>    BAIL_ON_FAILURE(hr); <br>     <br>    hr = _pPropertyCache-&gt;SampleDSMarshallProperties( <br>                            hOperationData <br>                            ); <br>     <br>    BAIL_ON_FAILURE(hr); <br>    hr = SampleDSModifyObject(hObject, <br>                              hOperationData <br>                             ); <br>error: <br>    if (hObject) { <br>        hr = SampleDSCloseObject(hObject); <br>    } <br>    if (hOperationData) { <br>        SampleDSFreeBuffer(hOperationData); <br>    } <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>CSampleDSGenObject::SampleDSCreateObject() <br>{ <br>    WCHAR szSampleDSParentName[MAX_PATH]; <br>    HANDLE hOperationData = NULL; <br>    HANDLE hObject = NULL; <br>    HRESULT hr = S_OK; <br> <br>    hr = BuildDSPathFromADsPath( <br>                _Parent, <br>                szSampleDSParentName <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SampleDSOpenObject( <br>                    szSampleDSParentName, <br>                    &amp;hObject, <br>                    NULL, <br>                    REG_DS <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SampleDSCreateBuffer(&amp;hOperationData); <br>    BAIL_ON_FAILURE(hr); <br>     <br>    hr = _pPropertyCache-&gt;SampleDSMarshallProperties( <br>                            hOperationData <br>                            ); <br>    BAIL_ON_FAILURE(hr); <br>     <br>    hr = SampleDSAddObject( <br>                hObject, <br>                _Name, <br>                _ADsClass, <br>                hOperationData <br>                ); <br>     <br>error: <br>    if (hObject) { <br>        hr = SampleDSCloseObject(hObject); <br>    } <br>    if (hOperationData) { <br>        SampleDSFreeBuffer(hOperationData); <br>    } <br> <br>    RRETURN(hr); <br>} <br> <br> <br>HRESULT <br>CSampleDSGenObject::GetInfo() <br>{ <br>    RRETURN(GetInfo(TRUE)); <br>} <br> <br>HRESULT <br>CSampleDSGenObject::GetInfo( <br>    BOOL fExplicit <br>){ <br>    HANDLE hObject = NULL; <br>    HRESULT hr = S_OK; <br>    WCHAR szDSPathName[MAX_PATH]; <br>    HANDLE hOperationData = NULL; <br> <br>    if (GetObjectState() == ADS_OBJECT_UNBOUND) { <br>        hr = E_ADS_OBJECT_UNBOUND; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>    hr = BuildDSPathFromADsPath( <br>                _ADsPath, <br>                szDSPathName <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SampleDSOpenObject( <br>                    szDSPathName, <br>                    &amp;hObject, <br>                    NULL, <br>                    REG_DS <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SampleDSReadObject( <br>        hObject, <br>        &amp;hOperationData <br>    ); <br>    BAIL_ON_FAILURE(hr); <br>             <br>    hr = _pPropertyCache-&gt;SampleDSUnMarshallProperties(hOperationData, <br>                                                       fExplicit <br>                                                       ); <br>    BAIL_ON_FAILURE(hr); <br>error: <br> <br>    if (hObject) { <br>        hr = SampleDSCloseObject(hObject); <br>    } <br>    if (hOperationData) { <br>        SampleDSFreeBuffer(hOperationData); <br>    } <br> <br>    RRETURN(hr); <br>} <br> <br>/* IADsContainer methods */ <br> <br>STDMETHODIMP <br>CSampleDSGenObject::get_Count(long FAR* retval) <br>{ <br>    RRETURN(E_NOTIMPL); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::get_Filter(THIS_ VARIANT FAR* pVar) <br>{ <br>    VariantInit(pVar); <br>    RRETURN(VariantCopy(pVar, &amp;_vFilter)); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::put_Filter(THIS_ VARIANT Var) <br>{ <br>    RRETURN(VariantCopy(&amp;_vFilter, &amp;Var)); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::put_Hints(THIS_ VARIANT Var) <br>{ <br>    RRETURN( E_NOTIMPL); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::get_Hints(THIS_ VARIANT FAR* pVar) <br>{ <br>    RRETURN(E_NOTIMPL); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::GetObject( <br>    BSTR ClassName, <br>    BSTR RelativeName, <br>    IDispatch * FAR* ppObject <br>    ) <br>{ <br>    RRETURN(::RelativeGetObject(_ADsPath, <br>                                ClassName, <br>                                RelativeName, <br>                                ppObject, <br>                                FALSE)); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::get__NewEnum( <br>    THIS_ IUnknown * FAR* retval <br>    ) <br>{ <br>    HRESULT hr; <br>    IUnknown FAR* punkEnum=NULL; <br>    IEnumVARIANT * penum = NULL; <br> <br> <br>    *retval = NULL; <br> <br>    hr = CSampleDSGenObjectEnum::Create( <br>                (CSampleDSGenObjectEnum **)&amp;penum, <br>                _ADsPath, <br>                _vFilter <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = penum-&gt;QueryInterface( <br>                IID_IUnknown, <br>                (VOID FAR* FAR*)retval <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    if (penum) { <br>        penum-&gt;Release(); <br>    } <br> <br>    RRETURN(NOERROR); <br> <br>error: <br> <br>    if (penum) { <br>        delete penum; <br>    } <br> <br>    RRETURN(hr); <br>} <br> <br> <br>STDMETHODIMP <br>CSampleDSGenObject::Create( <br>    THIS_ BSTR ClassName, <br>    BSTR RelativeName, <br>    IDispatch * FAR* ppObject <br>    ) <br>{ <br>    HRESULT hr = S_OK; <br>    IADs * pADs  = NULL; <br>    WCHAR szDSTreeName[MAX_PATH]; <br>    DWORD dwSyntaxId = 0; <br> <br>    // <br>    // Get the TreeName for this object <br>    // <br> <br>    hr = BuildDSTreeNameFromADsPath( <br>                _ADsPath, <br>                szDSTreeName <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br> <br>    // <br>    // Validate if this class really exists in the schema <br>    // and validate that this object can be created in this <br>    // container <br>    // <br> <br>    hr = CSampleDSGenObject::CreateGenericObject( <br>                    _ADsPath, <br>                    RelativeName, <br>                    ClassName, <br>                    ADS_OBJECT_UNBOUND, <br>                    IID_IDispatch, <br>                    (void **)ppObject <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>error: <br> <br>    RRETURN(hr); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::Delete( <br>    THIS_ BSTR bstrClassName, <br>    BSTR bstrRelativeName <br>    ) <br>{ <br>    WCHAR szDSPathName[MAX_PATH]; <br>    HRESULT hr = S_OK; <br>    DWORD dwStatus = 0; <br>    HANDLE hParentObject = NULL; <br> <br>    hr = BuildDSPathFromADsPath( <br>                _ADsPath, <br>                szDSPathName <br>                ); <br>    BAIL_ON_FAILURE(hr); <br>     <br>    hr = SampleDSOpenObject( <br>                    szDSPathName, <br>                    &amp;hParentObject, <br>                    NULL, <br>                    REG_DS <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr= SampleDSRemoveObject( <br>                hParentObject, <br>                bstrRelativeName); <br>    BAIL_ON_FAILURE(hr); <br> <br> <br>error: <br>    if (hParentObject) { <br>        dwStatus = SampleDSCloseObject(hParentObject); <br>    } <br>    RRETURN(hr); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::CopyHere( <br>    THIS_ BSTR SourceName, <br>    BSTR NewName, <br>    IDispatch * FAR* ppObject <br>    ) <br>{ <br>    RRETURN(E_NOTIMPL); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::MoveHere( <br>    THIS_ BSTR SourceName, <br>    BSTR NewName, <br>    IDispatch * FAR* ppObject <br>    ) <br>{ <br>    RRETURN(E_NOTIMPL); <br>} <br> <br>HRESULT <br>CSampleDSGenObject::AllocateGenObject(CSampleDSGenObject ** ppGenObject) <br>{ <br>    CSampleDSGenObject FAR * pGenObject = NULL; <br>    CDispatchMgr FAR * pDispMgr = NULL; <br>    CPropertyCache FAR * pPropertyCache = NULL; <br>    HRESULT hr = S_OK; <br> <br>    pGenObject = new CSampleDSGenObject(); <br>    if (pGenObject == NULL) { <br>        hr = E_OUTOFMEMORY; <br>    } <br>    BAIL_ON_FAILURE(hr); <br> <br>    pDispMgr = new CDispatchMgr; <br>    if (pDispMgr == NULL) { <br>        hr = E_OUTOFMEMORY; <br>    } <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = LoadTypeInfoEntry(pDispMgr, <br>                           LIBID_ADs, <br>                           IID_IADs, <br>                           (IADs *)pGenObject, <br>                           DISPID_REGULAR <br>                           ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = LoadTypeInfoEntry(pDispMgr, <br>                           LIBID_ADs, <br>                           IID_IADsContainer, <br>                           (IADsContainer *)pGenObject, <br>                           DISPID_NEWENUM <br>                           ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = CPropertyCache::createpropertycache( <br>                        (CCoreADsObject FAR *)pGenObject, <br>                        &amp;pPropertyCache <br>                        ); <br>    BAIL_ON_FAILURE(hr); <br> <br> <br> <br>    pGenObject-&gt;_pPropertyCache = pPropertyCache; <br>    pGenObject-&gt;_pDispMgr = pDispMgr; <br>    *ppGenObject = pGenObject; <br>     <br>    RRETURN(hr); <br> <br>error: <br>    delete  pDispMgr; <br>    RRETURN(hr); <br>} <br> <br>STDMETHODIMP <br>CSampleDSGenObject::Get( <br>    THIS_ BSTR bstrName, <br>    VARIANT FAR* pvProp <br>    ) <br>{ <br>    HRESULT hr = S_OK; <br>    DWORD dwSyntaxId; <br>    DWORD dwNumValues; <br>    LPSampleDSOBJECT pNdsSrcObjects = NULL; <br> <br>    // <br>    // retrieve data object from cache; if one exists <br>    // <br> <br>    if (GetObjectState() == ADS_OBJECT_UNBOUND) { <br> <br>        hr = _pPropertyCache-&gt;unboundgetproperty( <br>                    bstrName, <br>                    &amp;dwSyntaxId, <br>                    &amp;dwNumValues, <br>                    &amp;pNdsSrcObjects <br>                    ); <br>        BAIL_ON_FAILURE(hr); <br> <br>    }else { <br> <br>        hr = _pPropertyCache-&gt;getproperty( <br>                    bstrName, <br>                    &amp;dwSyntaxId, <br>                    &amp;dwNumValues, <br>                    &amp;pNdsSrcObjects <br>                    ); <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br> <br>    // <br>    // translate the Nds objects to variants <br>    // <br> <br>    hr = SampleDSTypeToVarTypeCopyConstruct( <br>                pNdsSrcObjects, <br>                dwNumValues, <br>                pvProp <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>error: <br>    if (pNdsSrcObjects) { <br> <br>        SampleDSTypeFreeSampleDSObjects( <br>            pNdsSrcObjects, <br>            dwNumValues <br>            ); <br>    } <br> <br>    RRETURN(hr); <br>} <br> <br> <br>STDMETHODIMP <br>CSampleDSGenObject::Put( <br>    THIS_ BSTR bstrName, <br>    VARIANT vProp <br>    ) <br>{ <br>    HRESULT hr = S_OK; <br>    DWORD dwSyntaxId  = 0; <br>    DWORD dwIndex = 0; <br>    LPSampleDSOBJECT pNdsDestObjects = NULL; <br>    WCHAR szSampleDSTreeName[MAX_PATH]; <br>    DWORD dwNumValues = 0; <br> <br>    VARIANT * pVarArray = NULL; <br>    VARIANT * pvProp = NULL; <br> <br>    // <br>    // Issue: How do we handle multi-valued support <br>    // <br> <br>    if ((V_VT(&amp;vProp) &amp;  VT_VARIANT) &amp;&amp;  V_ISARRAY(&amp;vProp)) { <br> <br>        hr  = ConvertSafeArrayToVariantArray( <br>                    vProp, <br>                    &amp;pVarArray, <br>                    &amp;dwNumValues <br>                    ); <br>        BAIL_ON_FAILURE(hr); <br>        pvProp = pVarArray; <br> <br>    }else { <br> <br>        dwNumValues = 1; <br>        pvProp = &amp;vProp; <br>    } <br> <br>    // <br>    // Get the TreeName for this object <br>    // <br> <br>    hr = BuildDSPathFromADsPath( <br>                _ADsPath, <br>                szSampleDSTreeName <br>                ); <br>    BAIL_ON_FAILURE(hr); <br>     <br>    // <br>    // check if the variant maps to the syntax of this property <br>    // <br>    switch (vProp.vt) { <br>        case VT_BSTR: <br>                dwSyntaxId = SampleDS_DATATYPE_1; <br>                break; <br>        case VT_I4: <br>                dwSyntaxId = SampleDS_DATATYPE_2; <br>                break; <br>        default: <br>                hr = E_FAIL; <br>                goto error; <br>        } <br>                hr = VarTypeToSampleDSTypeCopyConstruct( <br>                    dwSyntaxId, <br>                    pvProp, <br>                    dwNumValues, <br>                    &amp;pNdsDestObjects <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    // <br>    // Find this property in the cache <br>    // <br> <br>    hr = _pPropertyCache-&gt;findproperty( <br>                        bstrName, <br>                        &amp;dwIndex <br>                        ); <br> <br>    // <br>    // If this property does not exist in the <br>    // cache, add this property into the cache. <br>    // <br> <br> <br>    if (FAILED(hr)) { <br>        hr = _pPropertyCache-&gt;addproperty( <br>                    bstrName, <br>                    dwSyntaxId, <br>                    dwNumValues, <br>                    pNdsDestObjects <br>                    ); <br>        // <br>        // If the operation fails for some reason <br>        // move on to the next property <br>        // <br>        BAIL_ON_FAILURE(hr); <br> <br>    } <br> <br>    // <br>    // Now update the property in the cache <br>    // <br> <br>    hr = _pPropertyCache-&gt;putproperty( <br>                    bstrName, <br>                    dwSyntaxId, <br>                    dwNumValues, <br>                    pNdsDestObjects <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>error: <br> <br>    if (pNdsDestObjects) { <br>        SampleDSTypeFreeSampleDSObjects( <br>                pNdsDestObjects, <br>                dwNumValues <br>                ); <br> <br>    } <br> <br> <br>    if (pVarArray) { <br> <br>        DWORD i = 0; <br> <br>        for (i = 0; i &lt; dwNumValues; i++) { <br>            VariantClear(pVarArray + i); <br>        } <br>        FreeProvMem(pVarArray); <br>    } <br> <br>    RRETURN(hr); <br>} <br> <br> <br>HRESULT <br>ConvertSafeArrayToVariantArray( <br>    VARIANT varSafeArray, <br>    VARIANT ** ppVarArray, <br>    PDWORD pdwNumVariants <br>    ) <br>{ <br>    HRESULT hr = S_OK; <br>    DWORD dwSLBound = 0; <br>    DWORD dwSUBound = 0; <br>    DWORD i = 0; <br>    DWORD dwNumVariants = 0; <br>    VARIANT * pVarArray = NULL; <br> <br>    *pdwNumVariants = 0; <br>    *ppVarArray  = 0; <br> <br>    if(!((V_VT(&amp;varSafeArray) &amp;  VT_VARIANT) &amp;&amp;  V_ISARRAY(&amp;varSafeArray))) { <br>        return(E_FAIL); <br>    } <br> <br>    // <br>    // Check that there is only one dimension in this array <br>    // <br> <br>    if ((V_ARRAY(&amp;varSafeArray))-&gt;cDims != 1) { <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br>    // <br>    // Check that there is atleast one element in this array <br>    // <br> <br>    if ((V_ARRAY(&amp;varSafeArray))-&gt;rgsabound[0].cElements == 0){ <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>    hr = SafeArrayGetLBound(V_ARRAY(&amp;varSafeArray), <br>                            1, <br>                            (long FAR *)&amp;dwSLBound <br>                            ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SafeArrayGetUBound(V_ARRAY(&amp;varSafeArray), <br>                            1, <br>                            (long FAR *)&amp;dwSUBound <br>                            ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    dwNumVariants = dwSUBound - dwSLBound + 1; <br>    pVarArray = (VARIANT*)AllocProvMem( <br>                                sizeof(VARIANT)*dwNumVariants <br>                                ); <br>    if (!pVarArray) { <br>        hr = E_OUTOFMEMORY; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>    for (i = dwSLBound; i &lt;= dwSUBound; i++) { <br> <br>        VariantInit(pVarArray + i); <br>        hr = SafeArrayGetElement(V_ARRAY(&amp;varSafeArray), <br>                                (long FAR *)&amp;i, <br>                                (pVarArray + i) <br>                                ); <br>        CONTINUE_ON_FAILURE(hr); <br>    } <br> <br>    *ppVarArray = pVarArray; <br>    *pdwNumVariants = dwNumVariants; <br> <br>error: <br> <br>    RRETURN(hr); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
