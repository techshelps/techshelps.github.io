<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GETOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4691"></a>GETOBJ.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    GetObj.cpp <br> <br>Abstract: <br> <br>    Sample Provider GetObject functionality <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br>#pragma hdrstop <br> <br>//+--------------------------------------------------------------------------- <br>//  Function:   RelativeGetObject <br>// <br>//  Synopsis:   Gets object relative to given OLE DS path. <br>// <br>//  Arguments:  [BSTR ADsPath] <br>//              [BSTR ClassName] <br>//              [BSTR RelativeName] <br>//              [IUnknown** ppObject] <br>//              [BOOT bNamespaceRelative] <br>// <br>//  Returns:    HRESULT <br>// <br>//  Modifies:   *ppObject <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>RelativeGetObject( <br>    BSTR ADsPath, <br>    BSTR ClassName, <br>    BSTR RelativeName, <br>    IDispatch* FAR* ppObject, <br>    BOOL bNamespaceRelative <br>    ) <br>{ <br>    WCHAR szBuffer[MAX_PATH]; <br>    HRESULT hr = S_OK; <br> <br>    *ppObject = NULL; <br> <br>    if (!RelativeName || !*RelativeName) { <br>        RRETURN(E_ADS_UNKNOWN_OBJECT); <br>    } <br> <br>    wcscpy(szBuffer, ADsPath); <br> <br>    if (bNamespaceRelative) <br>        wcscat(szBuffer, L"//"); <br>    else <br>        wcscat(szBuffer, L"/"); <br>    wcscat(szBuffer, RelativeName); <br> <br>    if (ClassName &amp;&amp; *ClassName) { <br>        wcscat(szBuffer,L","); <br>        wcscat(szBuffer, ClassName); <br>    } <br> <br>    hr = ::GetObject( <br>                szBuffer, <br>                (LPVOID *)ppObject <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>error: <br>    RRETURN(hr); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>//  Function:  GetObject <br>// <br>//  Synopsis:  Called by ResolvePathName to return an object <br>// <br>//  Arguments:  [LPWSTR szBuffer] <br>//              [LPVOID *ppObject] <br>// <br>//  Returns:    HRESULT <br>// <br> <br>//---------------------------------------------------------------------------- <br>HRESULT <br>GetObject( <br>    LPWSTR szBuffer, <br>    LPVOID * ppObject <br>    ) <br>{ <br>    HRESULT hr; <br>    DWORD dwStatus = NO_ERROR; <br>    DWORD dwNumberEntries = 0; <br>    DWORD dwModificationTime = 0; <br>    WCHAR szObjectClassName[MAX_PATH]; <br>    WCHAR szDSPath[MAX_PATH]; <br>    WCHAR szParent[MAX_PATH]; <br>    WCHAR szCommonName[MAX_PATH]; <br>    HANDLE hObject = NULL; <br> <br>    OBJECTINFO ObjectInfo; <br>    POBJECTINFO pObjectInfo = &amp;ObjectInfo; <br>    CLexer Lexer(szBuffer); <br> <br>    IADs * pADs = NULL; <br>    szObjectClassName[0]=L'\0'; <br> <br>    memset(pObjectInfo, 0, sizeof(OBJECTINFO)); <br>    hr = ADsObject(&amp;Lexer, pObjectInfo); <br>    BAIL_ON_FAILURE(hr); <br> <br>    // <br>    // Validate that this ADs pathname is to be processed by <br>    // us - as in the provider name is @Sample! <br>    // <br> <br>    hr = ValidateProvider(pObjectInfo); <br>    BAIL_ON_FAILURE(hr); <br> <br> <br> <br>    hr = ValidateObjectType(pObjectInfo); <br> <br>    switch (pObjectInfo-&gt;ObjectType) { <br> <br>    case TOKEN_NAMESPACE: <br>        // <br>        // This means that this is a namespace object; <br>        // instantiate the namespace object <br>        // <br> <br>        hr = GetNamespaceObject( <br>                pObjectInfo, <br>                ppObject <br>                ); <br>        BAIL_ON_FAILURE(hr); <br> <br>        break; <br> <br>    case TOKEN_SCHEMA: <br> <br>        hr = GetSchemaObject( <br>                pObjectInfo, <br>                ppObject <br>                ); <br>        BAIL_ON_FAILURE(hr); <br> <br>        break; <br>     <br>    default: <br>        hr = BuildDSPathFromADsPath( <br>                    szBuffer, <br>                    szDSPath <br>                    ); <br>        BAIL_ON_FAILURE(hr); <br> <br>        hr  = SampleDSOpenObject( <br>                        szDSPath, <br>                        &amp;hObject, <br>                        szObjectClassName, <br>                        REG_DS); <br>        BAIL_ON_FAILURE(hr); <br> <br>        hr = BuildADsParentPath( <br>                    szBuffer, <br>                    szParent, <br>                    szCommonName <br>                    ); <br>        BAIL_ON_FAILURE(hr); <br> <br>        hr = CSampleDSGenObject::CreateGenericObject( <br>                        szParent, <br>                        szCommonName, <br>                        szObjectClassName, <br>                        ADS_OBJECT_BOUND, <br>                        IID_IUnknown, <br>                        (void**)ppObject <br>                        ); <br>        BAIL_ON_FAILURE(hr); <br>        break; <br> <br>    } <br> <br>error: <br> <br>    if (pADs) { <br>        pADs-&gt;Release(); <br>    } <br>    if (hObject) { <br>        SampleDSCloseObject(hObject); <br>    } <br> <br>    RRETURN(hr); <br>} <br> <br> <br> <br>HRESULT <br>BuildADsPathFromDSPath( <br>    LPWSTR szDSRootRDN, <br>    LPWSTR szDSDNName, <br>    LPWSTR szADsPathName <br>    ) <br>{ <br>    PKEYDATA pKeyData = NULL; <br>    DWORD dwCount = 0; <br>    DWORD i = 0; <br> <br>    if (!szDSRootRDN || !szDSDNName) { <br>        RRETURN(E_FAIL); <br>    } <br> <br>    wsprintf(szADsPathName,L"%s:%s", g_szProviderName, szDSRootRDN); <br> <br>    pKeyData = CreateTokenList( <br>                    szDSDNName, <br>                    L'.' <br>                    ); <br> <br>    if (pKeyData) { <br> <br>        dwCount = pKeyData-&gt;cTokens; <br>        for (i = 0; i &lt; dwCount; i++) { <br>            wcscat(szADsPathName, L"/"); <br>            wcscat(szADsPathName, pKeyData-&gt;pTokens[dwCount - 1 - i]); <br>        } <br>    } <br> <br>    if (pKeyData) { <br>        FreeProvMem(pKeyData); <br>    } <br>    RRETURN(S_OK); <br>} <br> <br>HRESULT <br>BuildDSTreeNameFromADsPath( <br>    LPWSTR szBuffer, <br>    LPWSTR szSampleDSTreeName <br>    ) <br>{ <br>    OBJECTINFO ObjectInfo; <br>    POBJECTINFO pObjectInfo = &amp;ObjectInfo; <br>    CLexer Lexer(szBuffer); <br>    DWORD dwNumComponents = 0; <br>    HRESULT hr; <br> <br>    memset(pObjectInfo, 0, sizeof(OBJECTINFO)); <br>    hr = ADsObject(&amp;Lexer, pObjectInfo); <br>    BAIL_ON_FAILURE(hr); <br> <br>    dwNumComponents = pObjectInfo-&gt;NumComponents; <br> <br> <br>    if (!dwNumComponents &amp;&amp; !pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and <br>        // no tree name specified. This is the <br>        // namespace object - its parent is the <br>        // @ADs! object <br>        // <br> <br>        hr = E_FAIL; <br> <br>    } else if (!dwNumComponents &amp;&amp; pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and a tree <br>        // name has been specified. This is the root <br>        // object - its parent is the  @SampleDS! object <br> <br>        wsprintf(szSampleDSTreeName,L"\\\\%s", pObjectInfo-&gt;RootRDN); <br> <br> <br>        hr = S_OK; <br> <br>    }else { <br>        // <br>        // There are one or more CNs, a tree name has been <br>        // specified. In the worst case the parent is the <br>        // root object. In the best case a long CN. <br>        // <br> <br>        wsprintf(szSampleDSTreeName,L"\\\\%s", pObjectInfo-&gt;RootRDN); <br> <br>        hr = S_OK; <br>    } <br> <br>error: <br>    RRETURN(hr); <br> <br>} <br> <br>HRESULT <br>BuildDSPathFromADsPath( <br>    LPWSTR szADsPathName, <br>    LPWSTR szDSPathName <br>    ) <br>{ <br>    OBJECTINFO ObjectInfo; <br>    POBJECTINFO pObjectInfo = &amp;ObjectInfo; <br>    CLexer Lexer(szADsPathName); <br>    DWORD i = 0; <br>    DWORD dwNumComponents = 0; <br>    HRESULT hr; <br> <br>    memset(pObjectInfo, 0, sizeof(OBJECTINFO)); <br>    hr = ADsObject(&amp;Lexer, pObjectInfo); <br>    BAIL_ON_FAILURE(hr); <br> <br>    dwNumComponents = pObjectInfo-&gt;NumComponents; <br> <br>    wcscpy(szDSPathName, L"\\"); <br>    wcscat(szDSPathName, pObjectInfo-&gt;RootRDN); <br>     <br>    for (i = 0; i &lt; dwNumComponents; i++) { <br>        wcscat(szDSPathName, L"\\"); <br>                wcscat(szDSPathName, pObjectInfo-&gt;ComponentArray[i].szComponent); <br>    } <br> <br>error: <br> <br>    RRETURN(hr); <br> <br>} <br> <br>HRESULT <br>AppendComponent( <br>   LPWSTR szDSPathName, <br>   PCOMPONENT pComponent <br>){ <br>        DebugBreak(); <br>    RRETURN(S_OK); <br>} <br> <br> <br> <br>HRESULT <br>BuildADsParentPath( <br>    LPWSTR szBuffer, <br>    LPWSTR szParent, <br>    LPWSTR szCommonName <br>    ) <br>{ <br>    OBJECTINFO ObjectInfo; <br>    POBJECTINFO pObjectInfo = &amp;ObjectInfo; <br>    CLexer Lexer(szBuffer); <br>    DWORD i = 0; <br>    DWORD dwNumComponents = 0; <br>    HRESULT hr; <br>    LPWSTR pszComponent = NULL, pszValue = NULL; <br> <br>    memset(pObjectInfo, 0, sizeof(OBJECTINFO)); <br>    hr = ADsObject(&amp;Lexer, pObjectInfo); <br>    BAIL_ON_FAILURE(hr); <br> <br>    dwNumComponents = pObjectInfo-&gt;NumComponents; <br> <br> <br>    if (!dwNumComponents &amp;&amp; !pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and <br>        // no Root name specified. This is the <br>        // namespace object - its parent is the <br>        // @ADs! object <br>        // <br> <br>        wsprintf(szParent,L"ADs:"); <br> <br>        RRETURN(S_OK); <br> <br>    } else if (!dwNumComponents &amp;&amp; pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and a Root <br>        // name has been specified. This is the root <br>        // object - its parent is the  @Sample! object <br> <br>        wsprintf(szParent, L"%s:", pObjectInfo-&gt;ProviderName); <br> <br>        // <br>        // And the common name is the RootRDN <br>        // <br> <br>        wsprintf(szCommonName,L"%s", pObjectInfo-&gt;RootRDN); <br> <br> <br>        RRETURN(S_OK); <br> <br> <br>    }else { <br>        // <br>        // There are one or more CNs, a Root name has been <br>        // specified. In the worst case the parent is the <br>        // root object. In the best case a long CN. <br>        // <br> <br>        wsprintf( <br>            szParent, L"%s://%s", <br>            pObjectInfo-&gt;ProviderName, <br>            pObjectInfo-&gt;RootRDN <br>            ); <br> <br>        for (i = 0; i &lt; dwNumComponents - 1; i++) { <br> <br>            wcscat(szParent, L"/"); <br> <br> <br>            pszComponent =  pObjectInfo-&gt;ComponentArray[i].szComponent; <br>            pszValue = pObjectInfo-&gt;ComponentArray[i].szValue; <br> <br> <br>            if (pszComponent &amp;&amp; pszValue) { <br> <br>                wcscat( <br>                    szParent, <br>                    pObjectInfo-&gt;ComponentArray[i].szComponent <br>                    ); <br>                wcscat(szParent,L"="); <br>                wcscat( <br>                    szParent, <br>                    pObjectInfo-&gt;ComponentArray[i].szValue <br>                    ); <br>            }else if (pszComponent){ <br> <br>                wcscat( <br>                    szParent, <br>                    pObjectInfo-&gt;ComponentArray[i].szComponent <br>                    ); <br> <br>            }else { <br>                // <br>                // Error - we should never hit this case!! <br>                // <br> <br>            } <br>        } <br> <br>        // <br>        // And the common name is the last component <br>        // <br> <br>        pszComponent =  pObjectInfo-&gt;ComponentArray[dwNumComponents - 1].szComponent; <br>        pszValue = pObjectInfo-&gt;ComponentArray[dwNumComponents - 1].szValue; <br> <br> <br>        if (pszComponent &amp;&amp; pszValue) { <br> <br>            wsprintf(szCommonName, L"%s=%s",pszComponent, pszValue); <br> <br>        }else if (pszComponent){ <br> <br>            wsprintf(szCommonName, L"%s", pszComponent); <br> <br>        }else { <br>            // <br>            // Error - we should never hit this case!! <br>            // <br> <br>        } <br> <br>    } <br> <br>error: <br> <br>    RRETURN(hr); <br> <br>} <br> <br>HRESULT <br>InstantiateDerivedObject( <br>    IADs FAR * pADs, <br>    REFIID riid, <br>    void  ** ppObject <br>    ) <br>{ <br>        *ppObject = 0; <br> <br>    RRETURN(S_OK); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// Function:    GetNamespaceObject <br>// <br>// Synopsis:    called by GetObject <br>// <br>// Arguments:   [POBJECTINFO pObjectInfo] <br>//              [LPVOID * ppObject] <br>// <br>// Returns:     HRESULT <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>GetNamespaceObject( <br>    POBJECTINFO pObjectInfo, <br>    LPVOID * ppObject <br>    ) <br>{ <br>    HRESULT hr; <br> <br>    hr = ValidateNamespaceObject( <br>                pObjectInfo <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = CoCreateInstance(CLSID_SampleDSNamespace, <br>                          NULL, <br>                          CLSCTX_INPROC_SERVER, <br>                          IID_IUnknown, <br>                          (void **)ppObject <br>                          ); <br> <br>error: <br> <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>ValidateNamespaceObject( <br>    POBJECTINFO pObjectInfo <br>    ) <br>{ <br> <br>    if (!_wcsicmp(pObjectInfo-&gt;ProviderName, g_szProviderName)) { <br>    } <br>    RRETURN(S_OK); <br>} <br> <br> <br>HRESULT <br>ValidateProvider( <br>    POBJECTINFO pObjectInfo <br>    ) <br>{ <br> <br>    // <br>    // The provider name is case-sensitive.  This is a restriction that OLE <br>    // has put on us. <br>    // <br>    if (!(wcscmp(pObjectInfo-&gt;ProviderName, g_szProviderName))) { <br>        RRETURN(S_OK); <br>    } <br>    RRETURN(E_FAIL); <br>} <br> <br> <br> <br>//+--------------------------------------------------------------------------- <br>// Function:    GetSchemaObject <br>// <br>// Synopsis:    called by GetObject <br>// <br>// Arguments:   [POBJECTINFO pObjectInfo] <br>//              [LPVOID * ppObject] <br>// <br>// Returns:     HRESULT <br>// <br>// Modifies:      - <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>GetSchemaObject( <br>    POBJECTINFO pObjectInfo, <br>    LPVOID * ppObject <br>    ) <br>{ <br>    HRESULT hr = S_OK; <br>    WCHAR szParent[MAX_PATH]; <br>    WCHAR szCommonName[MAX_PATH]; <br>    WCHAR szSampleDSPathName[MAX_PATH]; <br>    DWORD dwObjectType = 0; <br>    HANDLE hObject= NULL; <br> <br>    hr = ValidateSchemaObject( <br>                pObjectInfo, <br>                &amp;dwObjectType <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = BuildADsParentPath( <br>             pObjectInfo, <br>             szParent, <br>             szCommonName <br>             ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    switch(dwObjectType) { <br>    case SampleDS_CLASS_ID: <br>    case SampleDS_PROPERTY_ID: <br>    case SampleDS_CLASSPROP_ID: <br> <br>        wcscpy(szSampleDSPathName, L"\\"); <br>        wcscat(szSampleDSPathName, szCommonName); <br>        hr = SampleDSOpenObject( <br>                        szSampleDSPathName, <br>                        &amp;hObject, <br>                        NULL, <br>                        REG_SCHEMA <br>                        ); <br>        BAIL_ON_FAILURE(hr); <br>         <br>        break; <br> <br>    default: <br>        break; <br>    } <br> <br>    // <br>    // Note: The "error:" tag is at the end of the switch statement, <br>    //       so we can simply break out. <br>    // <br> <br>    switch (dwObjectType) { <br>    case SampleDS_SCHEMA_ID: <br>        hr = CSampleDSSchema::CreateSchema( <br>                    szParent, <br>                    szCommonName, <br>                    ADS_OBJECT_BOUND, <br>                    IID_IUnknown, <br>                    ppObject <br>                    ); <br>        break; <br>    case SampleDS_CLASSPROP_ID: <br>        hr = CSampleDSClass::CreateClass( <br>                    szParent, <br>                    szCommonName, <br>                    hObject, <br>                    ADS_OBJECT_BOUND, <br>                    IID_IUnknown, <br>                    ppObject <br>                    ); <br>        if (FAILED(hr)) { <br>            hr = CSampleDSProperty::CreateProperty( <br>                                    szParent, <br>                                    szCommonName, <br>                                    hObject, <br>                                    ADS_OBJECT_BOUND, <br>                                    IID_IUnknown, <br>                                    ppObject <br>                                    ); <br>        } <br>        break; <br> <br>   default: <br>        hr = E_ADS_UNKNOWN_OBJECT; <br>        break; <br>    } <br> <br>error: <br>    if (hObject) { <br>        SampleDSCloseObject(hObject); <br>    } <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>ValidateSchemaObject( <br>    POBJECTINFO pObjectInfo, <br>    PDWORD pdwObjectType <br>    ) <br>{ <br>    DWORD dwNumComponents = 0; <br> <br>    dwNumComponents = pObjectInfo-&gt;NumComponents; <br> <br>    switch (dwNumComponents) { <br> <br>    case 1: <br>        if (!_wcsicmp(pObjectInfo-&gt;ComponentArray[0].szComponent, L"schema")) { <br>            *pdwObjectType = SampleDS_SCHEMA_ID; <br>            RRETURN(S_OK); <br>        } <br>        break; <br> <br>    case 2: <br>        *pdwObjectType = SampleDS_CLASSPROP_ID; <br>        RRETURN(S_OK); <br>     <br>    default: <br>        break; <br> <br> <br>    } <br> <br>    RRETURN(E_FAIL); <br>} <br> <br>HRESULT <br>BuildADsParentPath( <br>    POBJECTINFO pObjectInfo, <br>    LPWSTR szParent, <br>    LPWSTR szCommonName <br>    ) <br>{ <br>    DWORD i = 0; <br>    DWORD dwNumComponents = 0; <br>    LPWSTR pszComponent = NULL, pszValue = NULL; <br> <br>    dwNumComponents = pObjectInfo-&gt;NumComponents; <br> <br>    if (!dwNumComponents &amp;&amp; !pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and <br>        // no root name specified. This is the <br>        // namespace object - its parent is the <br>        // @ADs! object <br>        // <br> <br>        wsprintf(szParent,L"ADs:"); <br> <br>        RRETURN(S_OK); <br> <br>    } else if (!dwNumComponents &amp;&amp; pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and a root <br>        // name has been specified. This is the root <br>        // object - its parent is the  @Sample! object <br> <br>        wsprintf(szParent, L"%s:", pObjectInfo-&gt;ProviderName); <br> <br>        // <br>        // And the common name is the RootRDN. Remember the <br>        // "//" will be added on  when we reconstruct the full <br>        // pathname <br>        // <br> <br>        wsprintf(szCommonName,L"%s", pObjectInfo-&gt;RootRDN); <br> <br> <br>        RRETURN(S_OK); <br> <br> <br>    }else { <br>        // <br>        // There are one or more CNs, a root name has been <br>        // specified. In the worst case the parent is the <br>        // root object. In the best case a long CN. <br>        // <br> <br>        wsprintf( <br>            szParent, L"%s://%s", <br>            pObjectInfo-&gt;ProviderName, <br>            pObjectInfo-&gt;RootRDN <br>            ); <br> <br>        for (i = 0; i &lt; dwNumComponents - 1; i++) { <br> <br>            wcscat(szParent, L"/"); <br> <br> <br>            pszComponent =  pObjectInfo-&gt;ComponentArray[i].szComponent; <br>            pszValue = pObjectInfo-&gt;ComponentArray[i].szValue; <br> <br> <br>            if (pszComponent &amp;&amp; pszValue) { <br> <br>                wcscat( <br>                    szParent, <br>                    pObjectInfo-&gt;ComponentArray[i].szComponent <br>                    ); <br>                wcscat(szParent,L"="); <br>                wcscat( <br>                    szParent, <br>                    pObjectInfo-&gt;ComponentArray[i].szValue <br>                    ); <br>            }else if (pszComponent){ <br> <br>                wcscat( <br>                    szParent, <br>                    pObjectInfo-&gt;ComponentArray[i].szComponent <br>                    ); <br> <br>            }else { <br>                // <br>                // Error - we should never hit this case!! <br>                // <br> <br>            } <br>        } <br> <br>        // <br>        // And the common name is the last component <br>        // <br> <br>        pszComponent =  pObjectInfo-&gt;ComponentArray[dwNumComponents - 1].szComponent; <br>        pszValue = pObjectInfo-&gt;ComponentArray[dwNumComponents - 1].szValue; <br> <br> <br>        if (pszComponent &amp;&amp; pszValue) { <br> <br>            wsprintf(szCommonName, L"%s=%s",pszComponent, pszValue); <br> <br>        }else if (pszComponent){ <br> <br>            wsprintf(szCommonName, L"%s", pszComponent); <br> <br>        }else { <br>            // <br>            // Error - we should never hit this case!! <br>            // <br> <br>        } <br> <br>    } <br> <br>    RRETURN(S_OK); <br>} <br> <br>HRESULT <br>ValidateObjectType( <br>    POBJECTINFO pObjectInfo <br>    ) <br>{ <br> <br>    pObjectInfo-&gt;ObjectType = TOKEN_DSOBJECT; <br> <br>    if (pObjectInfo-&gt;ProviderName &amp;&amp; !pObjectInfo-&gt;RootRDN <br>            &amp;&amp; !pObjectInfo-&gt;NumComponents) { <br>        pObjectInfo-&gt;ObjectType = TOKEN_NAMESPACE; <br>    }else if (pObjectInfo-&gt;ProviderName &amp;&amp; pObjectInfo-&gt;RootRDN <br>                &amp;&amp; pObjectInfo-&gt;NumComponents) { <br> <br>        if (!_wcsicmp(pObjectInfo-&gt;ComponentArray[0].szComponent,L"schema")) { <br>            pObjectInfo-&gt;ObjectType = TOKEN_SCHEMA; <br>        } <br> <br>    } <br> <br>    RRETURN(S_OK); <br>} <br> <br>HRESULT <br>BuildSampleDSRootRDNFromADsPath( <br>    LPWSTR szBuffer, <br>    LPWSTR szDSRootRDN <br>    ) <br>{ <br>    OBJECTINFO ObjectInfo; <br>    POBJECTINFO pObjectInfo = &amp;ObjectInfo; <br>    CLexer Lexer(szBuffer); <br>    DWORD dwNumComponents = 0; <br>    HRESULT hr; <br> <br>    memset(pObjectInfo, 0, sizeof(OBJECTINFO)); <br>    hr = ADsObject(&amp;Lexer, pObjectInfo); <br>    BAIL_ON_FAILURE(hr); <br> <br>    dwNumComponents = pObjectInfo-&gt;NumComponents; <br> <br> <br>    if (!dwNumComponents &amp;&amp; !pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and <br>        // no root name specified. This is the <br>        // namespace object - its parent is the <br>        // @ADs! object <br>        // <br> <br>        hr = E_FAIL; <br> <br>    } else if (!dwNumComponents &amp;&amp; pObjectInfo-&gt;RootRDN) { <br>        // <br>        // There are no CNs in this pathname and a root  <br>        // name has been specified. This is the root <br>        // object - its parent is the  @Sample! object <br> <br>        wsprintf(szDSRootRDN,L"\\\\%s", pObjectInfo-&gt;RootRDN); <br> <br> <br>        hr = S_OK; <br> <br>    }else { <br>        // <br>        // There are one or more CNs, a root name has been <br>        // specified. In the worst case the parent is the <br>        // root object. In the best case a long CN. <br>        // <br> <br>        wsprintf(szDSRootRDN,L"\\\\%s", pObjectInfo-&gt;RootRDN); <br> <br>        hr = S_OK; <br>    } <br> <br>error: <br>    RRETURN(hr); <br> <br>} <br> <br> <br>HRESULT <br>BuildDSPathFromADsPath( <br>    LPWSTR szADsPathName, <br>    LPWSTR szDSRootRDN, <br>    LPWSTR szDSPathName <br>    ) <br>{ <br>    OBJECTINFO ObjectInfo; <br>    POBJECTINFO pObjectInfo = &amp;ObjectInfo; <br>    CLexer Lexer(szADsPathName); <br>    DWORD i = 0; <br>    DWORD dwNumComponents = 0; <br>    HRESULT hr; <br> <br>    memset(pObjectInfo, 0, sizeof(OBJECTINFO)); <br>    hr = ADsObject(&amp;Lexer, pObjectInfo); <br>    BAIL_ON_FAILURE(hr); <br> <br>    dwNumComponents = pObjectInfo-&gt;NumComponents; <br> <br>    wcscpy(szDSRootRDN, L"\\"); <br>    wcscat(szDSRootRDN, pObjectInfo-&gt;RootRDN); <br> <br>    *szDSPathName = L'\0'; <br> <br>    for (i = dwNumComponents; i &gt;  0; i--) { <br>                wcscat(szDSPathName, pObjectInfo-&gt;ComponentArray[i-1].szComponent); <br>        if (i&gt;1) wcscat(szDSPathName, L"\\"); <br>    } <br> <br>error: <br> <br>    RRETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
