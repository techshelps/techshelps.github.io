<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MEMORY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4701"></a>MEMORY.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    Memory.cpp <br> <br>Abstract: <br> <br>    This module provides all the memory management functions for all Sample <br>    provider components <br> <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br> <br>#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &amp;= ~1)) <br>#define DWORD_ALIGN_UP(size) ((size+3)&amp;~3) <br> <br> <br>LPVOID <br>AllocProvMem( <br>    DWORD cb <br>) <br>{ <br>    LPDWORD  pMem; <br>    DWORD    cbNew ; <br> <br>#if DBG <br>    cb = DWORD_ALIGN_UP(cb); <br> <br>    cbNew = cb + (sizeof(DWORD) + sizeof(LONGLONG)); <br>#else <br>    cbNew = cb ; <br>#endif <br> <br>    pMem=(LPDWORD)LocalAlloc(LPTR, cbNew); <br> <br> <br>#if DBG <br> <br>    if (!pMem) { <br>        SetLastError(ERROR_NOT_ENOUGH_MEMORY); <br>        return 0; <br>    } <br> <br>    *pMem=cb; <br>    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD))=0xdeadfeed; <br>    pMem = (LPDWORD) (((LPBYTE)pMem)+sizeof(LONGLONG)); <br>#endif <br> <br>    return (LPVOID)(pMem); <br>} <br> <br>BOOL <br>FreeProvMem( <br>   LPVOID pMem <br>) <br>{ <br>    LPBYTE   pNewMem; <br> <br>    pNewMem = (LPBYTE)pMem; <br> <br>#if DBG <br>    DWORD    cb; <br>    DWORD    cbNew = 0; <br> <br>    pNewMem -= sizeof(LONGLONG) ; <br> <br>    cb = *((LPDWORD)pNewMem); <br>    cbNew = cb + sizeof(DWORD) + sizeof(LONGLONG); <br> <br>    if (*(LPDWORD)(pNewMem + cbNew - sizeof(DWORD)) != 0xdeadbeef) { <br>        ADsAssert(!"Freeing memory not allocated by AllocProvMem") ; <br>        return FALSE; <br>    } <br> <br>    // fill freed memory with known pattern <br>    memset(pMem, 0x5C, cb); <br> <br>#endif <br> <br> <br>    return(LocalFree((LPVOID)pNewMem) == NULL); <br>} <br> <br>LPVOID <br>ReallocProvMem( <br>   LPVOID pOldMem, <br>   DWORD cbOld, <br>   DWORD cbNew <br>) <br>{ <br>    LPVOID pNewMem; <br> <br>    pNewMem=AllocProvMem(cbNew); <br> <br>    if (pOldMem &amp;&amp; pNewMem) { <br>        memcpy(pNewMem, pOldMem, min(cbNew, cbOld)); <br>        FreeProvMem(pOldMem); <br>    } <br> <br>    return pNewMem; <br>} <br> <br> <br>LPWSTR <br>AllocProvStr( <br>    LPWSTR pStr <br>) <br>{ <br>   LPWSTR pMem; <br> <br>   if (!pStr) <br>      return 0; <br> <br>   if (pMem = (LPWSTR)AllocProvMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) )) <br>      wcscpy(pMem, pStr); <br> <br>   return pMem; <br>} <br> <br>BOOL <br>FreeProvStr( <br>   LPWSTR pStr <br>) <br>{ <br>   return pStr ? FreeProvMem(pStr) <br>               : FALSE; <br>} <br> <br>BOOL <br>ReallocProvStr( <br>   LPWSTR *ppStr, <br>   LPWSTR pStr <br>) <br>{ <br>   FreeProvStr(*ppStr); <br>   *ppStr=AllocProvStr(pStr); <br> <br>   return TRUE; <br>} <br> <br>STDAPI <br>ProvAllocString(const OLECHAR * pch, BSTR * pBSTR) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    ADsAssert(pBSTR); <br>    if (!pch) <br>    { <br>        *pBSTR = NULL; <br>        return S_OK; <br>    } <br> <br>    *pBSTR = SysAllocString(pch); <br>    hr = (*pBSTR) ? S_OK : E_OUTOFMEMORY; <br>    RRETURN(hr); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
