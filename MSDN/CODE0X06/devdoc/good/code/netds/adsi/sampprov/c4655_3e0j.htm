<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CENUMOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4663"></a>CENUMOBJ.CPP</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1996 Microsoft Corporation <br> <br>Module Name: <br> <br>    CEnumObj.c <br> <br>Abstract: <br> <br>    Generic Object Enumeration CodeStandard IClassFactory implementation <br> <br>Author: <br> <br>Environment: <br> <br>    User mode <br> <br>Revision History : <br> <br>--*/ <br>#include "adssmp.h" <br>#pragma hdrstop <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   CSampleDSEnumVariant::Create <br>// <br>//  Synopsis: <br>// <br>//  Arguments:  [pCollection] <br>//              [ppEnumVariant] <br>// <br>//  Returns:    HRESULT <br>// <br>//  Modifies: <br>// <br>//  History:     <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>CSampleDSGenObjectEnum::Create( <br>    CSampleDSGenObjectEnum FAR* FAR* ppenumvariant, <br>    BSTR ADsPath, <br>    VARIANT var <br>    ) <br>{ <br>    HRESULT hr = NOERROR; <br>    CSampleDSGenObjectEnum FAR* penumvariant = NULL; <br>    WCHAR szDSPath[MAX_PATH]; <br>    DWORD dwModificationTime = 0L; <br>    DWORD dwNumberOfEntries = 0L; <br>    DWORD dwStatus = 0L; <br> <br>    *ppenumvariant = NULL; <br> <br>    penumvariant = new CSampleDSGenObjectEnum(); <br>    if (!penumvariant) { <br>        hr = E_OUTOFMEMORY; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>    hr = xx_put_BSTR(&amp;penumvariant-&gt;_ADsPath, ADsPath); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = BuildDSFilterArray( <br>                var, <br>                (LPBYTE *)&amp;penumvariant-&gt;_pDSFilterList <br>                ); <br>    if (FAILED(hr)) { <br>        penumvariant-&gt;_pDSFilterList = NULL; <br>    } <br> <br>    *ppenumvariant = penumvariant; <br> <br>    hr = BuildDSPathFromADsPath( <br>                ADsPath, <br>                szDSPath <br>                ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SampleDSOpenObject( <br>                    szDSPath, <br>                    &amp;penumvariant-&gt;_hObject, <br>                    NULL, <br>                    REG_DS <br>                    ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SampleDSRDNEnum(  <br>                 &amp;penumvariant-&gt;_hEnum,  <br>                 penumvariant-&gt;_hObject <br>                 ); <br>     <br>    RRETURN(hr); <br> <br>error: <br>    if (penumvariant-&gt;_hObject) { <br>        SampleDSCloseObject(penumvariant-&gt;_hObject); <br>    } <br>     <br>    delete penumvariant; <br> <br>    RRETURN(hr); <br>} <br> <br>CSampleDSGenObjectEnum::CSampleDSGenObjectEnum(): <br>                    _ADsPath(NULL) <br>{ <br>    _pObjList = NULL; <br>    _dwObjectReturned = 0; <br>    _dwObjectCurrentEntry = 0; <br>    _dwObjectTotal = 0; <br>    _hObject = NULL; <br>    _hEnum = NULL; <br>    _lpObjects = NULL; <br>    _pDSFilterList = NULL; <br> <br>    _bNoMore = FALSE; <br>} <br> <br> <br>CSampleDSGenObjectEnum::~CSampleDSGenObjectEnum() <br>{ <br>    if (_pDSFilterList) { <br>        FreeFilterList((LPBYTE)_pDSFilterList); <br>    } <br>} <br> <br>HRESULT <br>CSampleDSGenObjectEnum::EnumObjects( <br>    DWORD ObjectType, <br>    ULONG cElements, <br>    VARIANT FAR * pvar, <br>    ULONG FAR * pcElementFetched <br>    ) <br>{ <br> <br>    // <br>    // Multi-level detection of Objects may not be necessary for DS code <br>    // <br> <br>    RRETURN(EnumGenericObjects(cElements, pvar, pcElementFetched)); <br> <br>} <br>HRESULT <br>CSampleDSGenObjectEnum::EnumGenericObjects( <br>    ULONG cElements, <br>    VARIANT FAR* pvar, <br>    ULONG FAR* pcElementFetched <br>    ) <br>{ <br>    DWORD           i; <br>    ULONG           cRequested = 0; <br>    ULONG           cTotalFetched = 0; <br>    HRESULT         hr; <br> <br>    for (i = 0; i &lt; cElements; i++)  { <br>        VariantInit(&amp;pvar[i]); <br>    } <br>    cRequested = cElements; <br> <br>        hr = FetchObjects(cElements, pvar, &amp;cTotalFetched); <br>    <br>    if (pcElementFetched) { <br>        *pcElementFetched = cTotalFetched; <br>    } <br> <br>    RRETURN(hr); <br>} <br> <br>// <br>// Load IDispatch pointers of Next cElements Filtered Objects into pvar array <br>// <br>HRESULT <br>CSampleDSGenObjectEnum::FetchObjects( <br> <br>    ULONG cElements, <br>    VARIANT FAR* pvar, <br>    ULONG FAR* pcElementFetched <br>    ) <br>{ <br>    HRESULT hr; <br>    IDispatch *pDispatch = NULL; <br>    DWORD i = 0; <br> <br>    while (i &lt; cElements) { <br> <br>        hr = FetchNextObject(&amp;pDispatch); <br>        if (hr == S_FALSE) { <br>            break; <br>        } <br> <br>        VariantInit(&amp;pvar[i]); <br>        pvar[i].vt = VT_DISPATCH; <br>        pvar[i].pdispVal = pDispatch; <br>        (*pcElementFetched)++; <br>        i++; <br>    } <br>    return(hr); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   CSampleDSNamespaceEnum::FetchNextObject <br>// <br>//  Synopsis:   Gets IDispatch pointer of next object in namespace subject to <br>//                              filter. <br>// <br>//  Arguments:  [ppDispatch] -- Pointer to where to return IDispatch pointer. <br>// <br>//  Returns:    HRESULT -- S_OK if got the next object <br>//                      -- S_FALSE if not <br>// <br>//  Modifies:   [*ppDispatch] <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT <br>CSampleDSGenObjectEnum::FetchNextObject( <br>    IDispatch ** ppDispatch <br>    ) <br> { <br>    HRESULT hr; <br>    LPTSTR lpszObjectRDN=NULL ; <br>    LPTSTR lpszObjectClass = 0; <br>    DWORD dwClassId = 0; <br>    IADs * pADs = NULL; <br>    *ppDispatch = NULL; <br> <br>    hr = S_OK; <br>    while (hr == S_OK){ <br>        hr=SampleDSNextRDN(_hEnum, <br>                           &amp;lpszObjectRDN, <br>                           &amp;lpszObjectClass <br>                           );     <br>        if (S_OK==hr &amp;&amp;  <br>            S_OK==IsValidDSFilter(lpszObjectClass)) { <br>            break; <br>        } <br>    } <br> <br>    // <br>    // Now create and send back the current object <br>    // <br>    if (hr == S_OK) { <br>        hr = CSampleDSGenObject::CreateGenericObject(_ADsPath, <br>                                                     lpszObjectRDN, <br>                                                     lpszObjectClass, <br>                                                     ADS_OBJECT_BOUND, <br>                                                     IID_IDispatch, <br>                                                     (void **)ppDispatch <br>                                                     ); <br>        BAIL_ON_FAILURE(hr); <br>    } <br>    else { <br>        if (_hEnum) { <br>            SampleDSFreeEnum(_hEnum); <br>            _hEnum = NULL; <br>        } <br>    } <br> <br>error: <br> <br>    // <br>    // Free the intermediate pADs pointer. <br>    // <br>    if (pADs) { <br>        pADs-&gt;Release(); <br>    } <br>    if (lpszObjectRDN) <br>        FreeProvMem(lpszObjectRDN); <br>    if (lpszObjectClass) <br>        FreeProvMem(lpszObjectClass); <br>    RRETURN_ENUM_STATUS(hr);  <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   CSampleDSGenObjectEnum::Next <br>// <br>//  Synopsis:   Returns cElements number of requested NetOle objects in the <br>//              array supplied in pvar. <br>// <br>//  Arguments:  [cElements] -- The number of elements requested by client <br>//              [pvar] -- ptr to array of VARIANTs to for return objects <br>//              [pcElementFetched] -- if non-NULL, then number of elements <br>//                                 -- actually returned is placed here <br>// <br>//  Returns:    HRESULT -- S_OK if number of elements requested are returned <br>//                      -- S_FALSE if number of elements is &lt; requested <br>// <br>// <br>//---------------------------------------------------------------------------- <br>STDMETHODIMP <br>CSampleDSGenObjectEnum::Next( <br>    ULONG cElements, <br>    VARIANT FAR* pvar, <br>    ULONG FAR* pcElementFetched <br>    ) <br>{ <br>    ULONG cElementFetched = 0; <br>    HRESULT hr = S_OK; <br> <br>    hr = EnumGenericObjects( <br>            cElements, <br>            pvar, <br>            &amp;cElementFetched <br>            ); <br> <br> <br>    if (pcElementFetched) { <br>        *pcElementFetched = cElementFetched; <br>    } <br>    RRETURN(hr); <br>} <br> <br>HRESULT <br>CSampleDSGenObjectEnum::IsValidDSFilter(LPWSTR ObjectName){ <br> <br>    if (_pDSFilterList){ <br>                for (DWORD i = 0; i &lt; _pDSFilterList-&gt;dwNumberOfFilters; i++) { <br> <br>                        if ( !_wcsicmp(ObjectName,_pDSFilterList-&gt;Filters[i].lpObjectClass) ) { <br>                                RRETURN(S_OK); <br>                        } <br>                } <br>                RRETURN(E_FAIL); <br>    } <br>    RRETURN(S_OK); <br>} <br> <br>HRESULT <br>BuildDSFilterArray( <br>    VARIANT var, <br>    LPBYTE * ppContigFilter <br>    ) <br>{ <br>    LONG uDestCount = 0; <br>    LONG dwSLBound = 0; <br>    LONG dwSUBound = 0; <br>    VARIANT v; <br>    LONG i; <br>    HRESULT hr = S_OK; <br> <br>    LPDS_FILTER_LIST pDsFilterList = NULL; <br>    LPBYTE pContigFilter = NULL; <br> <br>    if(!((V_VT(&amp;var) &amp;  VT_VARIANT) &amp;&amp;  V_ISARRAY(&amp;var))) { <br>        RRETURN(E_FAIL); <br>    } <br> <br>    // <br>    // Check that there is only one dimension in this array <br>    // <br> <br>    if ((V_ARRAY(&amp;var))-&gt;cDims != 1) { <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br>    // <br>    // Check that there is atleast one element in this array <br>    // <br> <br>    if ((V_ARRAY(&amp;var))-&gt;rgsabound[0].cElements == 0){ <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>    // <br>    // We know that this is a valid single dimension array <br>    // <br> <br>    hr = SafeArrayGetLBound(V_ARRAY(&amp;var), <br>                            1, <br>                            (long FAR *)&amp;dwSLBound <br>                            ); <br>    BAIL_ON_FAILURE(hr); <br> <br>    hr = SafeArrayGetUBound(V_ARRAY(&amp;var), <br>                            1, <br>                            (long FAR *)&amp;dwSUBound <br>                            ); <br>    BAIL_ON_FAILURE(hr); <br> <br> <br>    pContigFilter = (LPBYTE)AllocProvMem( <br>                            sizeof(DS_FILTER_LIST) <br>                            - sizeof(DS_FILTER) <br>                            ); <br>    if (!pContigFilter) { <br> <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br> <br>    for (i = dwSLBound; i &lt;= dwSUBound; i++) { <br>        VariantInit(&amp;v); <br>        hr = SafeArrayGetElement(V_ARRAY(&amp;var), <br>                                (long FAR *)&amp;i, <br>                                &amp;v <br>                                ); <br>        if (FAILED(hr)) { <br>            continue; <br>        } <br> <br>        // <br>        //  Create an entry in the filter block <br>        //  Append it to the existing block <br>        // <br> <br>        pContigFilter = CreateAndAppendFilterEntry( <br>                            pContigFilter, <br>                            V_BSTR(&amp;v) <br>                            ); <br>        if (!pContigFilter) { <br> <br>            hr = E_FAIL; <br>            BAIL_ON_FAILURE(hr); <br>        } <br> <br>    } <br> <br>    pDsFilterList = (LPDS_FILTER_LIST)pContigFilter; <br> <br>    if (!pDsFilterList-&gt;dwNumberOfFilters){ <br> <br>        hr = E_FAIL; <br>        BAIL_ON_FAILURE(hr); <br>    } <br> <br>    *ppContigFilter = pContigFilter; <br> <br>    RRETURN(S_OK); <br> <br>error: <br> <br>    if (pContigFilter){ <br> <br>        FreeFilterList( <br>               pContigFilter <br>               ); <br> <br>    } <br> <br>    *ppContigFilter = NULL; <br> <br>    RRETURN(hr); <br>} <br> <br>LPBYTE <br>CreateAndAppendFilterEntry( <br>    LPBYTE pContigFilter, <br>    LPWSTR lpObjectClass <br>    ) <br>{ <br>    LPWSTR pszFilter = NULL; <br>    LPDS_FILTER_LIST pDsFilterList = NULL; <br>    DWORD dwFilterCount = 0; <br>    LPBYTE pNewContigFilter = NULL; <br>    LPDS_FILTER pNewEntry = NULL; <br> <br> <br>    pszFilter = (LPWSTR)AllocProvStr(lpObjectClass); <br>    if (!pszFilter) { <br>        return(pContigFilter); <br>    } <br> <br>    pDsFilterList = (LPDS_FILTER_LIST)pContigFilter; <br> <br>    dwFilterCount = pDsFilterList-&gt;dwNumberOfFilters; <br> <br>    pNewContigFilter = (LPBYTE)ReallocProvMem( <br>                                    pContigFilter, <br> <br>                                    sizeof(DS_FILTER_LIST) + <br>                                    (dwFilterCount - 1)* sizeof(DS_FILTER), <br> <br>                                    sizeof(DS_FILTER_LIST) <br>                                    + dwFilterCount * sizeof(DS_FILTER) <br>                                    ); <br>    if (!pNewContigFilter) { <br>        return(pContigFilter); <br>    } <br> <br>    pNewEntry = (LPDS_FILTER)(pNewContigFilter + sizeof(DS_FILTER_LIST) <br>                        + (dwFilterCount - 1)* sizeof(DS_FILTER)); <br> <br>    pNewEntry-&gt;lpObjectClass = pszFilter; <br> <br>    pDsFilterList = (LPDS_FILTER_LIST)pNewContigFilter; <br> <br>    pDsFilterList-&gt;dwNumberOfFilters = dwFilterCount + 1; <br> <br>    return(pNewContigFilter); <br>} <br> <br>void <br>FreeFilterList( <br>    LPBYTE lpContigFilter <br>    ) <br>{ <br>    LPDS_FILTER_LIST lpDsFilterList = (LPDS_FILTER_LIST)lpContigFilter; <br>    DWORD dwNumFilters = 0; <br>    LPDS_FILTER lpDsFilter = NULL; <br>    DWORD i = 0; <br> <br>    dwNumFilters = lpDsFilterList-&gt;dwNumberOfFilters; <br> <br>    if (dwNumFilters){ <br> <br>        lpDsFilter = (LPDS_FILTER)(lpContigFilter  + sizeof(DS_FILTER_LIST) <br>                                      - sizeof(DS_FILTER)); <br> <br>        for (i = 0; i &lt; dwNumFilters; i++) { <br> <br>            FreeProvStr((lpDsFilter + i)-&gt;lpObjectClass); <br>        } <br> <br>    } <br> <br>    FreeProvMem(lpContigFilter); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
