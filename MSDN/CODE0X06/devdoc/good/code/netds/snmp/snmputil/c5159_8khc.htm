<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SNMPUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5160"></a>SNMPUTIL.C</h2>
<pre><code>/*++ BUILD Version: 0001    // Increment this if a change has global effects <br> <br>Copyright 1991 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    snmputil.c <br> <br>Abstract: <br> <br>    Sample SNMP Management API usage for Windows NT. <br> <br>    This file is an example of how to code management applications using <br>    the SNMP Management API for Windows NT.  It is similar in operation to <br>    the other commonly available SNMP command line utilities. <br> <br>    Extensive comments have been included to describe its structure and <br>    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference". <br> <br>Created: <br> <br>    28-Jun-1991 <br> <br>Revision History: <br> <br>--*/ <br> <br> <br>static char *vcsid = "@(#) $Logfile:   N:/agent/mgmtapi/vcs/snmputil.c_v  $ $Revision:   1.5  $"; <br> <br> <br>// General notes: <br>//   Microsoft's SNMP Management API for Windows NT is implemented as a DLL <br>// that is linked with the developer's code.  These APIs (examples follow in <br>// this file) allow the developer's code to generate SNMP queries and receive <br>// SNMP traps.  A simple MIB compiler and related APIs are also available to <br>// allow conversions between OBJECT IDENTIFIERS and OBJECT DESCRIPTORS. <br> <br> <br>// Necessary includes. <br> <br>#include &lt;windows.h&gt; <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br> <br>#include &lt;snmp.h&gt; <br>#include &lt;mgmtapi.h&gt; <br> <br> <br>// Constants used in this example. <br> <br>#define GET     1 <br>#define GETNEXT 2 <br>#define WALK    3 <br>#define TRAP    4 <br> <br>#define TIMEOUT 6000 /* milliseconds */ <br>#define RETRIES 3 <br> <br> <br>// Main program. <br> <br>INT _CRTAPI1 main( <br>    IN int  argumentCount, <br>    IN char *argumentVector[]) <br>    { <br>    INT                operation; <br>    LPSTR              agent; <br>    LPSTR              community; <br>    RFC1157VarBindList variableBindings; <br>    LPSNMP_MGR_SESSION session; <br> <br>    INT        timeout = TIMEOUT; <br>    INT        retries = RETRIES; <br> <br>    BYTE       requestType; <br>    AsnInteger errorStatus; <br>    AsnInteger errorIndex; <br>    char        *chkPtr = NULL; <br> <br> <br>    // Parse command line arguments to determine requested operation. <br> <br>    // Verify number of arguments... <br>    if      (argumentCount &lt; 5 &amp;&amp; argumentCount != 2) <br>        { <br>        printf("Error:  Incorrect number of arguments specified.\n"); <br>        printf( <br>"\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\n"); <br>        printf( <br>  "        snmputil trap\n"); <br> <br>        return 1; <br>        } <br> <br>    // Get/verify operation... <br>    argumentVector++; <br>    argumentCount--; <br>    if      (!strcmp(*argumentVector, "get")) <br>        operation = GET; <br>    else if (!strcmp(*argumentVector, "getnext")) <br>        operation = GETNEXT; <br>    else if (!strcmp(*argumentVector, "walk")) <br>        operation = WALK; <br>    else if (!strcmp(*argumentVector, "trap")) <br>        operation = TRAP; <br>    else <br>        { <br>        printf("Error:  Invalid operation, '%s', specified.\n", <br>               *argumentVector); <br> <br>        return 1; <br>        } <br> <br>    if (operation != TRAP) <br>        { <br>        if (argumentCount &lt; 4) <br>            { <br>            printf("Error:  Incorrect number of arguments specified.\n"); <br>            printf( <br>"\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\n"); <br>            printf( <br>  "        snmputil trap\n"); <br> <br>            return 1; <br>            } <br> <br>        // Get agent address... <br>        argumentVector++; <br>        argumentCount--; <br>        agent = (LPSTR)SNMP_malloc(strlen(*argumentVector) + 1); <br>        strcpy(agent, *argumentVector); <br> <br>        // Get agent community... <br>        argumentVector++; <br>        argumentCount--; <br>        community = (LPSTR)SNMP_malloc(strlen(*argumentVector) + 1); <br>        strcpy(community, *argumentVector); <br> <br>        // Get oid's... <br>        variableBindings.list = NULL; <br>        variableBindings.len = 0; <br> <br>        while(--argumentCount) <br>            { <br>            AsnObjectIdentifier reqObject; <br> <br>            argumentVector++; <br> <br>            // Convert the string representation to an internal representation. <br>            if (!SnmpMgrStrToOid(*argumentVector, &amp;reqObject)) <br>                { <br>                printf("Error: Invalid oid, %s, specified.\n", *argumentVector); <br> <br>                return 1; <br>                } <br>            else <br>                { <br>                // Since sucessfull, add to the variable bindings list. <br>                variableBindings.len++; <br>                if ((variableBindings.list = (RFC1157VarBind *)SNMP_realloc( <br>                    variableBindings.list, sizeof(RFC1157VarBind) * <br>                    variableBindings.len)) == NULL) <br>                    { <br>                    printf("Error: Error allocating oid, %s.\n", <br>                           *argumentVector); <br> <br>                    return 1; <br>                    } <br> <br>                variableBindings.list[variableBindings.len - 1].name = <br>                    reqObject; // NOTE!  structure copy <br>                variableBindings.list[variableBindings.len - 1].value.asnType = <br>                    ASN_NULL; <br>                } <br>            } // end while() <br> <br>        // Make sure only one variable binding was specified if operation <br>        // is WALK. <br>        if (operation == WALK &amp;&amp; variableBindings.len != 1) <br>            { <br>            printf("Error: Multiple oids specified for WALK.\n"); <br> <br>            return 1; <br>            } <br> <br> <br>        // Establish a SNMP session to communicate with the remote agent.  The <br>        // community, communications timeout, and communications retry count <br>        // for the session are also required. <br> <br>        if ((session = SnmpMgrOpen(agent, community, timeout, retries)) == NULL) <br>            { <br>            printf("error on SnmpMgrOpen %d\n", GetLastError()); <br> <br>            return 1; <br>            } <br> <br>        } // end if(TRAP) <br> <br> <br>    // Determine and perform the requested operation. <br> <br>    if      (operation == GET || operation == GETNEXT) <br>        { <br>        // Get and GetNext are relatively simple operations to perform. <br>        // Simply initiate the request and process the result and/or <br>        // possible error conditions. <br> <br> <br>        if (operation == GET) <br>            requestType = ASN_RFC1157_GETREQUEST; <br>        else <br>            requestType = ASN_RFC1157_GETNEXTREQUEST; <br> <br> <br>        // Request that the API carry out the desired operation. <br> <br>        if (!SnmpMgrRequest(session, requestType, &amp;variableBindings, <br>                            &amp;errorStatus, &amp;errorIndex)) <br>            { <br>            // The API is indicating an error. <br> <br>            printf("error on SnmpMgrRequest %d\n", GetLastError()); <br>            } <br>        else <br>            { <br>            // The API succeeded, errors may be indicated from the remote <br>            // agent. <br> <br>            if (errorStatus &gt; 0) <br>                { <br>                printf("Error: errorStatus=%d, errorIndex=%d\n", <br>                       errorStatus, errorIndex); <br>                } <br>            else <br>                { <br>                // Display the resulting variable bindings. <br> <br>                UINT i; <br>                char *string = NULL; <br> <br>                for(i=0; i &lt; variableBindings.len; i++) <br>                    { <br>                    SnmpMgrOidToStr(&amp;variableBindings.list[i].name, &amp;string); <br>                    printf("Variable = %s\n", string); <br>                    if (string) SNMP_free(string); <br> <br>                    printf("Value    = "); <br>                    SnmpUtilPrintAsnAny(&amp;variableBindings.list[i].value); <br> <br>                    printf("\n"); <br>                    } // end for() <br>                } <br>            } <br> <br> <br>        // Free the variable bindings that have been allocated. <br> <br>        SnmpUtilVarBindListFree(&amp;variableBindings); <br> <br> <br>        } <br>    else if (operation == WALK) <br>        { <br>        // Walk is a common term used to indicate that all MIB variables <br>        // under a given OID are to be traversed and displayed.  This is <br>        // a more complex operation requiring tests and looping in addition <br>        // to the steps for get/getnext above. <br> <br> <br>        AsnObjectIdentifier root; <br>        AsnObjectIdentifier tempOid; <br> <br> <br>        SnmpUtilOidCpy(&amp;root, &amp;variableBindings.list[0].name); <br> <br>        requestType = ASN_RFC1157_GETNEXTREQUEST; <br> <br> <br>        while(1) <br>            { <br>            if (!SnmpMgrRequest(session, requestType, &amp;variableBindings, <br>                                &amp;errorStatus, &amp;errorIndex)) <br>                { <br>                // The API is indicating an error. <br> <br>                printf("error on SnmpMgrRequest %d\n", GetLastError()); <br> <br>                break; <br>                } <br>            else <br>                { <br>                // The API succeeded, errors may be indicated from the remote <br>                // agent. <br> <br> <br>                // Test for end of subtree or end of MIB. <br> <br>                if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME || <br>                    SnmpUtilOidNCmp(&amp;variableBindings.list[0].name, <br>                                    &amp;root, root.idLength)) <br>                    { <br>                    printf("End of MIB subtree.\n\n"); <br> <br>                    break; <br>                    } <br> <br> <br>                // Test for general error conditions or sucesss. <br> <br>                if (errorStatus &gt; 0) <br>                    { <br>                    printf("Error: errorStatus=%d, errorIndex=%d \n", <br>                           errorStatus, errorIndex); <br> <br>                    break; <br>                    } <br>                else <br>                    { <br>                    // Display resulting variable binding for this iteration. <br> <br>                    char *string = NULL; <br> <br>                    SnmpMgrOidToStr(&amp;variableBindings.list[0].name, &amp;string); <br>                    printf("Variable = %s\n", string); <br>                    if (string) SNMP_free(string); <br> <br>                    printf("Value    = "); <br>                    SnmpUtilPrintAsnAny(&amp;variableBindings.list[0].value); <br> <br>                    printf("\n"); <br>                    } <br>                } // end if() <br> <br> <br>            // Prepare for the next iteration.  Make sure returned oid is <br>            // preserved and the returned value is freed. <br> <br>            SnmpUtilOidCpy(&amp;tempOid, &amp;variableBindings.list[0].name); <br> <br>            SnmpUtilVarBindFree(&amp;variableBindings.list[0]); <br> <br>            SnmpUtilOidCpy(&amp;variableBindings.list[0].name, &amp;tempOid); <br>            variableBindings.list[0].value.asnType = ASN_NULL; <br> <br>            SnmpUtilOidFree(&amp;tempOid); <br> <br>            } // end while() <br> <br> <br>        // Free the variable bindings that have been allocated. <br> <br>        SnmpUtilVarBindListFree(&amp;variableBindings); <br> <br>        SnmpUtilOidFree(&amp;root); <br> <br> <br>        } <br>    else if (operation == TRAP) <br>        { <br>        // Trap handling can be done two different ways: event driven or <br>        // polled.  The following code illustrates the steps to use event <br>        // driven trap reception in a management application. <br> <br> <br>        HANDLE hNewTraps = NULL; <br> <br> <br>        if (!SnmpMgrTrapListen(&amp;hNewTraps)) <br>            { <br>            printf("error on SnmpMgrTrapListen %d\n", GetLastError()); <br>            } <br>        else <br>            { <br>            printf("snmputil: listening for traps...\n"); <br>            } <br> <br> <br>        while(1) <br>            { <br>            DWORD dwResult; <br> <br>            if ((dwResult = WaitForSingleObject(hNewTraps, 0xffffffff)) <br>                == 0xffffffff) <br>                { <br>                printf("error on WaitForSingleObject %d\n", <br>                       GetLastError()); <br>                } <br>            else if (!ResetEvent(hNewTraps)) <br>                { <br>                printf("error on ResetEvent %d\n", GetLastError()); <br>                } <br>            else <br>                { <br>                AsnObjectIdentifier enterprise; <br>                AsnNetworkAddress   IPAddress; <br>                AsnInteger          genericTrap; <br>                AsnInteger          specificTrap; <br>                AsnTimeticks        timeStamp; <br>                RFC1157VarBindList  variableBindings; <br> <br>                UINT i; <br>                char *string = NULL; <br> <br>                while(SnmpMgrGetTrap(&amp;enterprise, &amp;IPAddress, &amp;genericTrap, <br>                                     &amp;specificTrap, &amp;timeStamp, &amp;variableBindings)) <br>                    { <br>                    printf("snmputil: trap generic=%d specific=%d\n", <br>                           genericTrap, specificTrap); <br>                    if (IPAddress.length == 4) { <br>                        printf("  from -&gt; %d.%d.%d.%d\n", <br>                             (int)IPAddress.stream[0], (int)IPAddress.stream[1], <br>                             (int)IPAddress.stream[2], (int)IPAddress.stream[3]); <br> <br>                    } <br>                    if (IPAddress.dynamic) { <br>                        SNMP_free(IPAddress.stream); <br>                    } <br> <br>                    for(i=0; i &lt; variableBindings.len; i++) <br>                        { <br>                        SnmpMgrOidToStr(&amp;variableBindings.list[i].name, &amp;string); <br>                        printf("Variable = %s\n", string); <br>                        if (string) SNMP_free(string); <br> <br>                        printf("Value    = "); <br>                        SnmpUtilPrintAsnAny(&amp;variableBindings.list[i].value); <br>                        } // end for() <br>                    printf("\n"); <br> <br> <br>                    SnmpUtilOidFree(&amp;enterprise); <br> <br>                    SnmpUtilVarBindListFree(&amp;variableBindings); <br>                    } <br>                } <br>            } // end while() <br> <br> <br>        } // end if(operation) <br> <br> <br>    if (operation != TRAP) <br>        { <br>        // Close SNMP session with the remote agent. <br> <br>        if (!SnmpMgrClose(session)) <br>            { <br>            printf("error on SnmpMgrClose %d\n", GetLastError()); <br> <br>            return 1; <br>            } <br>        } <br> <br> <br>    // Let the command interpreter know things went ok. <br> <br>    return 0; <br> <br>    } // end main() <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
