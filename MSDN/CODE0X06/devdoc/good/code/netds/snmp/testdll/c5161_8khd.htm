<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TESTDLL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5161"></a>TESTDLL.C</h2>
<pre><code>/*++ BUILD Version: 0001    // Increment this if a change has global effects <br> <br>Copyright (c) 1992-1996  Microsoft Corporation <br> <br>Module Name: <br> <br>    testdll.c <br> <br>Abstract: <br> <br>    Sample SNMP Extension Agent for Windows NT. <br> <br>    These files (testdll.c, testmib.c, and testmib.h) provide an example of  <br>    how to structure an Extension Agent DLL which works in conjunction with  <br>    the SNMP Extendible Agent for Windows NT. <br> <br>    Extensive comments have been included to describe its structure and <br>    operation.  See also "Microsoft Windows NT SNMP Programmer's Reference". <br> <br>--*/ <br> <br> <br>// General notes: <br>// <br>//   Microsoft's Extendible Agent for Windows NT is implemented by dynamically <br>// linking to Extension Agent DLLs that implement portions of the MIB.  These <br>// Extension Agents are configured in the Windows NT Registration Database. <br>// When the Extendible Agent Service is started, it queries the registry to <br>// determine which Extension Agent DLLs have been installed and need to be <br>// loaded and initialized.  The Extendible Agent invokes various DLL entry <br>// points (examples follow in this file) to request MIB queries and obtain <br>// Extension Agent generated traps. <br> <br> <br>// Necessary includes. <br> <br>#include &lt;windows.h&gt; <br> <br>#include &lt;snmp.h&gt; <br> <br> <br>// Contains definitions for the table structure describing the MIB.  This <br>// is used in conjunction with testmib.c where the MIB requests are resolved. <br> <br>#include "testmib.h" <br> <br> <br>// Extension Agent DLLs need access to elapsed time agent has been active. <br>// This is implemented by initializing the Extension Agent with a time zero <br>// reference, and allowing the agent to compute elapsed time by subtracting <br>// the time zero reference from the current system time.  This example <br>// Extension Agent implements this reference with dwTimeZero. <br> <br>DWORD dwTimeZero = 0; <br> <br> <br>// Extension Agent DLLs that generate traps must create a Win32 Event object <br>// to communicate occurence of traps to the Extendible Agent.  The event <br>// handle is given to the Extendible Agent when the Extension Agent is  <br>// initialized, it should be NULL if traps will not be generated.  This <br>// example Extension Agent simulates the occurance of traps with hSimulateTrap. <br> <br>HANDLE hSimulateTrap = NULL; <br> <br> <br>// This is a standard Win32 DLL entry point.  See the Win32 SDK for more <br>// information on its arguments and their meanings.  This example DLL does  <br>// not perform any special actions using this mechanism. <br> <br>BOOL WINAPI DllMain( <br>    HANDLE hDll, <br>    DWORD  dwReason, <br>    LPVOID lpReserved) <br>    { <br>    switch(dwReason) <br>        { <br>        case DLL_PROCESS_ATTACH: <br>        case DLL_PROCESS_DETACH: <br>        case DLL_THREAD_ATTACH: <br>        case DLL_THREAD_DETACH: <br>        default: <br>            break; <br> <br>        } // end switch() <br> <br>    return TRUE; <br> <br>    } // end DllEntryPoint() <br> <br> <br>// Extension Agent DLLs provide the following entry point to coordinate the <br>// initializations of the Extension Agent and the Extendible Agent.  The <br>// Extendible Agent provides the Extension Agent with a time zero reference; <br>// and the Extension Agent provides the Extendible Agent with an Event handle  <br>// for communicating occurence of traps, and an object identifier representing <br>// the root of the MIB subtree that the Extension Agent supports. <br> <br>BOOL WINAPI SnmpExtensionInit( <br>    IN  DWORD               dwTimeZeroReference, <br>    OUT HANDLE              *hPollForTrapEvent, <br>    OUT AsnObjectIdentifier *supportedView) <br>    { <br> <br>    // Record the time reference provided by the Extendible Agent. <br> <br>    dwTimeZero = dwTimeZeroReference; <br> <br> <br>    // Create an Event that will be used to communicate the occurence of traps <br>    // to the Extendible Agent.  The Extension Agent will assert this Event <br>    // when a trap has occured.  This is explained further later in this file. <br> <br>    if ((*hPollForTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) <br>        { <br>        // Indicate error?, be sure that NULL is returned to Extendible Agent. <br>        } <br> <br> <br>    // Indicate the MIB view supported by this Extension Agent, an object <br>    // identifier representing the sub root of the MIB that is supported. <br> <br>    *supportedView = MIB_OidPrefix; // NOTE!  structure copy <br> <br> <br>    // Record the trap Event.  This example Extension Agent simulates traps by  <br>    // generating a trap after every given number of processed requests. <br> <br>    hSimulateTrap = *hPollForTrapEvent; <br> <br> <br>    // Indicate that Extension Agent initialization was sucessfull. <br> <br>    return TRUE; <br> <br>    } // end SnmpExtensionInit() <br> <br> <br>// Extension Agent DLLs provide the following entry point to communcate traps <br>// to the Extendible Agent.  The Extendible Agent will query this entry point <br>// when the trap Event (supplied at initialization time) is asserted, which <br>// indicates that zero or more traps may have occured.  The Extendible Agent  <br>// will repetedly call this entry point until FALSE is returned, indicating  <br>// that all outstanding traps have been processed. <br> <br>BOOL WINAPI SnmpExtensionTrap( <br>    OUT AsnObjectIdentifier *enterprise, <br>    OUT AsnInteger          *genericTrap, <br>    OUT AsnInteger          *specificTrap, <br>    OUT AsnTimeticks        *timeStamp, <br>    OUT RFC1157VarBindList  *variableBindings) <br>    { <br>    // The body of this routine is an extremely simple example/simulation of <br>    // the trap functionality.  A real implementation will be more complex. <br> <br> <br>    // The following define data inserted into the trap below.  The Lan Manager <br>    // bytesAvailAlert from the Lan Manager Alerts-2 MIB is generated with an <br>    // empty variable bindings list. <br> <br>    static UINT OidList[]  = { 1, 3, 6, 1, 4, 1, 77, 2 }; <br>    static UINT OidListLen = 8; <br> <br> <br>    // The following variable is used for the simulation, it allows a single <br>    // trap to be generated and then causes FALSE to be returned indicating <br>    // no more traps. <br> <br>    static whichTime = 0; <br> <br> <br>    // The following if/else support the simulation. <br> <br>    if (whichTime == 0) <br>        { <br>        whichTime = 1;    // Supports the simulation. <br> <br> <br>        // Communicate the trap data to the Extendible Agent. <br> <br>        enterprise-&gt;idLength = OidListLen; <br>        enterprise-&gt;ids = OidList; <br> <br>        *genericTrap      = SNMP_GENERICTRAP_ENTERSPECIFIC; <br> <br>        *specificTrap     = 1;                    // the bytesAvailAlert trap <br> <br>        *timeStamp        = GetCurrentTime() - dwTimeZero; <br> <br>        variableBindings-&gt;list = NULL; <br>        variableBindings-&gt;len  = 0; <br> <br> <br>        // Indicate that valid trap data exists in the parameters. <br> <br>        return TRUE; <br>        } <br>    else <br>        { <br>        whichTime = 0;    // Supports the simulation. <br> <br> <br>        // Indicate that no more traps are available and parameters do not <br>        // refer to any valid data. <br> <br>        return FALSE; <br>        } <br> <br>    } // end SnmpExtensionTrap() <br> <br> <br>// Extension Agent DLLs provide the following entry point to resolve queries <br>// for MIB variables in their supported MIB view (supplied at initialization <br>// time).  The requestType is Get/GetNext/Set. <br> <br>BOOL WINAPI SnmpExtensionQuery( <br>    IN BYTE                   requestType, <br>    IN OUT RFC1157VarBindList *variableBindings, <br>    OUT AsnInteger            *errorStatus, <br>    OUT AsnInteger            *errorIndex) <br>    { <br>    static unsigned long requestCount = 0;  // Supports the trap simulation. <br>    UINT    I; <br> <br> <br>    // Iterate through the variable bindings list to resolve individual <br>    // variable bindings. <br> <br>    for ( I=0;I &lt; variableBindings-&gt;len;I++ ) <br>        { <br>        *errorStatus = ResolveVarBind( &amp;variableBindings-&gt;list[I], <br>                                       requestType ); <br> <br> <br>        // Test and handle case where Get Next past end of MIB view supported <br>        // by this Extension Agent occurs.  Special processing is required to  <br>        // communicate this situation to the Extendible Agent so it can take  <br>        // appropriate action, possibly querying other Extension Agents. <br> <br>        if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &amp;&amp; <br>             requestType == MIB_ACTION_GETNEXT ) <br>           { <br>           *errorStatus = SNMP_ERRORSTATUS_NOERROR; <br> <br> <br>           // Modify variable binding of such variables so the OID points <br>           // just outside the MIB view supported by this Extension Agent. <br>           // The Extendible Agent tests for this, and takes appropriate <br>           // action. <br> <br>           SnmpUtilOidFree( &amp;variableBindings-&gt;list[I].name ); <br>           SnmpUtilOidCpy( &amp;variableBindings-&gt;list[I].name, &amp;MIB_OidPrefix ); <br>           variableBindings-&gt;list[I].name.ids[MIB_PREFIX_LEN-1] ++; <br>           } <br> <br> <br>        // If an error was indicated, communicate error status and error <br>        // index to the Extendible Agent.  The Extendible Agent will ensure <br>        // that the origional variable bindings are returned in the response <br>        // packet. <br> <br>        if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR ) <br>           { <br>   *errorIndex = I+1; <br>   goto Exit; <br>   } <br>        } <br> <br>Exit: <br> <br> <br>    // Supports the trap simulation. <br> <br>    if (++requestCount % 3 == 0 &amp;&amp; hSimulateTrap != NULL) <br>        SetEvent(hSimulateTrap); <br> <br> <br>    // Indicate that Extension Agent processing was sucessfull. <br> <br>    return SNMPAPI_NOERROR; <br> <br>    } // end SnmpExtensionQuery() <br> <br> <br>//-------------------------------- END -------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
