<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TESTMIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5162"></a>TESTMIB.C</h2>
<pre><code>/*++ BUILD Version: 0001    // Increment this if a change has global effects <br> <br>Copyright (c) 1992-1996  Microsoft Corporation <br> <br>Module Name: <br> <br>    testmib.c <br> <br>Abstract: <br> <br>    Sample SNMP Extension Agent for Windows NT. <br> <br>    These files (testdll.c, testmib.c, and testmib.h) provide an example of  <br>    how to structure an Extension Agent DLL which works in conjunction with  <br>    the SNMP Extendible Agent for Windows NT. <br> <br>    Extensive comments have been included to describe its structure and <br>    operation.  See also "Microsoft Windows NT SNMP Programmer's Reference". <br> <br>--*/ <br> <br> <br>// This Extension Agent implements the Internet toaster MIB.  It's  <br>// definition follows here: <br>// <br>// <br>//         TOASTER-MIB DEFINITIONS ::= BEGIN <br>// <br>//         IMPORTS <br>//                 enterprises <br>//                         FROM RFC1155-SMI <br>//                 OBJECT-TYPE <br>//                         FROM RFC-1212 <br>//                 DisplayString <br>//                         FROM RFC-1213; <br>// <br>//         epilogue        OBJECT IDENTIFIER ::= { enterprises 12 } <br>//         toaster         OBJECT IDENTIFIER ::= { epilogue 2 } <br>// <br>//         -- toaster MIB <br>// <br>//         toasterManufacturer OBJECT-TYPE <br>//             SYNTAX  DisplayString <br>//             ACCESS  read-only <br>//             STATUS  mandatory <br>//             DESCRIPTION <br>//                     "The name of the toaster's manufacturer. For instance, <br>//                      Sunbeam." <br>//             ::= { toaster 1 } <br>// <br>//         toasterModelNumber OBJECT-TYPE <br>//             SYNTAX  DisplayString <br>//             ACCESS  read-only <br>//             STATUS  mandatory <br>//             DESCRIPTION <br>//                     "The name of the toaster's model. For instance, <br>//                      Radiant Automatic." <br>//             ::= { toaster 2 } <br>// <br>//         toasterControl OBJECT-TYPE <br>//             SYNTAX  INTEGER  { <br>//                         up(1), <br>//                         down(2) <br>//                     } <br>//             ACCESS  read-write <br>//             STATUS  mandatory <br>//             DESCRIPTION <br>//                     "This variable controls the current state of the  <br>//                      toaster. To begin toasting, set it to down(2). To  <br>//                      abort toasting (perhaps in the event of an  <br>//                      emergency), set it to up(2)." <br>//             ::= { toaster 3 } <br>// <br>//         toasterDoneness OBJECT-TYPE <br>//             SYNTAX  INTEGER (1..10) <br>//             ACCESS  read-write <br>//             STATUS  mandatory <br>//             DESCRIPTION <br>//                     "This variable controls how well done ensuing toast  <br>//                      should be on a scale of 1 to 10. Toast made at 10  <br>//                      is generally considered unfit for human consumption;  <br>//                      toast made at 1 is lightly warmed." <br>//             ::= { toaster 4 } <br>// <br>//         toasterToastType OBJECT-TYPE <br>//             SYNTAX  INTEGER  { <br>//                         white-bread(1), <br>//                         wheat-bread(2), <br>//                         wonder-bread(3), <br>//                         frozen-waffle(4), <br>//                         frozen-bagel(5), <br>//                         hash-brown(6), <br>//                         other(7) <br>//                     } <br>//             ACCESS  read-write <br>//             STATUS  mandatory <br>//             DESCRIPTION <br>//                     "This variable informs the toaster of the type of  <br>//                      material being toasted. The toaster uses this  <br>//                      information combined with toasterToastDoneness to  <br>//                      compute how long the material must be toasted for  <br>//                      to achieve the desired doneness." <br>//             ::= { toaster 5 } <br>// <br>//         END <br> <br> <br>// Necessary includes. <br> <br>#include &lt;windows.h&gt; <br> <br>#include &lt;snmp.h&gt; <br> <br> <br>// Contains definitions for the table structure describing the MIB.  This <br>// is used in conjunction with testmib.c where the MIB requests are resolved. <br> <br>#include "testmib.h" <br> <br> <br>// If an addition or deletion to the MIB is necessary, there are several <br>// places in the code that must be checked and possibly changed. <br>// <br>// The last field in each MIB entry is used to point to the NEXT <br>// leaf variable.  If an addition or deletetion is made, these pointers <br>// may need to be updated to reflect the modification. <br> <br> <br>// The prefix to all of these MIB variables is 1.3.6.1.4.1.12 <br> <br>UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 12 }; <br>AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix }; <br> <br> <br> <br>//                         // <br>// OID definitions for MIB // <br>//                         // <br> <br> <br>// Definition of the toaster group <br> <br>UINT MIB_toaster[]  = { 2 }; <br> <br> <br>// Definition of leaf variables under the toaster group <br>// All leaf variables have a zero appended to their OID to indicate <br>// that it is the only instance of this variable and it exists. <br> <br>UINT MIB_toasterManufacturer[]     = { 2, 1, 0 }; <br>UINT MIB_toasterModelNumber[]      = { 2, 2, 0 }; <br>UINT MIB_toasterControl[]          = { 2, 3, 0 }; <br>UINT MIB_toasterDoneness[]         = { 2, 4, 0 }; <br>UINT MIB_toasterToastType[]        = { 2, 5, 0 }; <br> <br> <br> <br>//                             // <br>// Storage definitions for MIB // <br>//                             // <br> <br>char       MIB_toasterManStor[]     = "Microsoft Corporation"; <br>char       MIB_toasterModelStor[]   =  <br>               "Example SNMP Extension Agent for Windows/NT (TOASTER-MIB)."; <br>AsnInteger MIB_toasterControlStor   = 1; <br>AsnInteger MIB_toasterDonenessStor  = 2; <br>AsnInteger MIB_toasterToastTypeStor = 3; <br> <br> <br> <br>// MIB definiton <br> <br>MIB_ENTRY Mib[] = { <br>      { { OID_SIZEOF(MIB_toasterManufacturer), MIB_toasterManufacturer }, <br>        &amp;MIB_toasterManStor, ASN_RFC1213_DISPSTRING, <br>        MIB_ACCESS_READ, MIB_leaf_func, &amp;Mib[1] }, <br> <br>      { { OID_SIZEOF(MIB_toasterModelNumber), MIB_toasterModelNumber }, <br>        &amp;MIB_toasterModelStor, ASN_RFC1213_DISPSTRING, <br>        MIB_ACCESS_READ, MIB_leaf_func, &amp;Mib[2] }, <br> <br>      { { OID_SIZEOF(MIB_toasterControl), MIB_toasterControl }, <br>        &amp;MIB_toasterControlStor, ASN_INTEGER, <br>        MIB_ACCESS_READWRITE, MIB_control_func, &amp;Mib[3] }, <br> <br>      { { OID_SIZEOF(MIB_toasterDoneness), MIB_toasterDoneness }, <br>        &amp;MIB_toasterDonenessStor, ASN_INTEGER, <br>        MIB_ACCESS_READWRITE, MIB_doneness_func, &amp;Mib[4] }, <br> <br>      { { OID_SIZEOF(MIB_toasterToastType), MIB_toasterToastType }, <br>        &amp;MIB_toasterToastTypeStor, ASN_INTEGER, <br>        MIB_ACCESS_READWRITE, MIB_toasttype_func, NULL } <br>      }; <br> <br>UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY ); <br> <br> <br> <br>// <br>// ResolveVarBind <br>//    Resolves a single variable binding.  Modifies the variable on a GET <br>//    or a GET-NEXT. <br>// <br>// Notes: <br>// <br>// Return Codes: <br>//    Standard PDU error codes. <br>// <br>// Error Codes: <br>//    None. <br>// <br>UINT ResolveVarBind( <br>        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve <br>IN UINT PduAction               // Action specified in PDU <br>) <br> <br>{ <br>MIB_ENTRY            *MibPtr; <br>AsnObjectIdentifier  TempOid; <br>int                  CompResult; <br>UINT                 I; <br>UINT                 nResult; <br> <br> <br>   // Search for var bind name in the MIB <br>   I      = 0; <br>   MibPtr = NULL; <br>   while ( MibPtr == NULL &amp;&amp; I &lt; MIB_num_variables ) <br>      { <br>      // Construct OID with complete prefix for comparison purposes <br>      SnmpUtilOidCpy( &amp;TempOid, &amp;MIB_OidPrefix ); <br>      SnmpUtilOidAppend( &amp;TempOid, &amp;Mib[I].Oid ); <br> <br>      // Check for OID in MIB - On a GET-NEXT the OID does not have to exactly <br>      // match a variable in the MIB, it must only fall under the MIB root. <br>      CompResult = SnmpUtilOidCmp( &amp;VarBind-&gt;name, &amp;TempOid ); <br>      if ( 0 &gt; CompResult ) <br> { <br> // Since there is not an exact match, the only valid action is GET-NEXT <br> if ( MIB_ACTION_GETNEXT != PduAction ) <br>    { <br>    nResult = SNMP_ERRORSTATUS_NOSUCHNAME; <br>    goto Exit; <br>    } <br> <br> // Since the match was not exact, but var bind name is within MIB, <br> // we are at the NEXT MIB variable down from the one specified. <br> PduAction = MIB_ACTION_GET; <br> MibPtr = &amp;Mib[I]; <br> <br>         // Replace var bind name with new name <br>         SnmpUtilOidFree( &amp;VarBind-&gt;name ); <br>         SnmpUtilOidCpy( &amp;VarBind-&gt;name, &amp;MIB_OidPrefix ); <br>         SnmpUtilOidAppend( &amp;VarBind-&gt;name, &amp;MibPtr-&gt;Oid ); <br> } <br>      else <br>         { <br> // An exact match was found. <br>         if ( 0 == CompResult ) <br>            { <br>    MibPtr = &amp;Mib[I]; <br>    } <br> } <br> <br>      // Free OID memory before checking another variable <br>      SnmpUtilOidFree( &amp;TempOid ); <br> <br>      I++; <br>      } // while <br> <br>   // If OID not within scope of MIB, then no such name <br>   if ( MibPtr == NULL ) <br>      { <br>      nResult = SNMP_ERRORSTATUS_NOSUCHNAME; <br>      goto Exit; <br>      } <br> <br>   // Call function to process request.  Each MIB entry has a function pointer <br>   // that knows how to process its MIB variable. <br>   nResult = (*MibPtr-&gt;MibFunc)( PduAction, MibPtr, VarBind ); <br> <br>   // Free temp memory <br>   SnmpUtilOidFree( &amp;TempOid ); <br> <br>Exit: <br>   return nResult; <br>} // ResolveVarBind <br> <br> <br> <br>// <br>// MIB_leaf_func <br>//    Performs generic actions on LEAF variables in the MIB. <br>// <br>// Notes: <br>// <br>// Return Codes: <br>//    Standard PDU error codes. <br>// <br>// Error Codes: <br>//    None. <br>// <br>UINT MIB_leaf_func( <br>        IN UINT Action, <br>IN MIB_ENTRY *MibPtr, <br>IN RFC1157VarBind *VarBind <br>) <br> <br>{ <br>UINT   ErrStat; <br> <br>   switch ( Action ) <br>      { <br>      case MIB_ACTION_GETNEXT: <br> // If there is no GET-NEXT pointer, this is the end of this MIB <br> if ( MibPtr-&gt;MibNext == NULL ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME; <br>    goto Exit; <br>    } <br> <br>         // Setup var bind name of NEXT MIB variable <br>         SnmpUtilOidFree( &amp;VarBind-&gt;name ); <br>         SnmpUtilOidCpy( &amp;VarBind-&gt;name, &amp;MIB_OidPrefix ); <br>         SnmpUtilOidAppend( &amp;VarBind-&gt;name, &amp;MibPtr-&gt;MibNext-&gt;Oid ); <br> <br>         // Call function to process request.  Each MIB entry has a function <br> // pointer that knows how to process its MIB variable. <br>         ErrStat = (*MibPtr-&gt;MibNext-&gt;MibFunc)( MIB_ACTION_GET, <br>                                        MibPtr-&gt;MibNext, VarBind ); <br>         break; <br> <br>      case MIB_ACTION_GET: <br>         // Make sure that this variable's ACCESS is GET'able <br> if ( MibPtr-&gt;Access != MIB_ACCESS_READ &amp;&amp; <br>      MibPtr-&gt;Access != MIB_ACCESS_READWRITE ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME; <br>    goto Exit; <br>    } <br> <br> // Setup varbind's return value <br> VarBind-&gt;value.asnType = MibPtr-&gt;Type; <br> switch ( VarBind-&gt;value.asnType ) <br>    { <br>            case ASN_RFC1155_COUNTER: <br>            case ASN_RFC1155_GAUGE: <br>            case ASN_INTEGER: <br>               VarBind-&gt;value.asnValue.number = *(AsnInteger *)(MibPtr-&gt;Storage); <br>       break; <br> <br>            case ASN_OCTETSTRING: // This entails ASN_RFC1213_DISPSTRING also <br>       VarBind-&gt;value.asnValue.string.length = <br>                                 strlen( (LPSTR)MibPtr-&gt;Storage ); <br> <br>       if ( NULL ==  <br>                    (VarBind-&gt;value.asnValue.string.stream = <br>                    SnmpUtilMemAlloc(VarBind-&gt;value.asnValue.string.length * <br>                           sizeof(char))) ) <br>          { <br>          ErrStat = SNMP_ERRORSTATUS_GENERR; <br>          goto Exit; <br>          } <br> <br>       memcpy( VarBind-&gt;value.asnValue.string.stream, <br>               (LPSTR)MibPtr-&gt;Storage, <br>               VarBind-&gt;value.asnValue.string.length ); <br>       VarBind-&gt;value.asnValue.string.dynamic = TRUE; <br> <br>       break; <br> <br>    default: <br>       ErrStat = SNMP_ERRORSTATUS_GENERR; <br>       goto Exit; <br>    } <br> <br> break; <br> <br>      case MIB_ACTION_SET: <br>         // Make sure that this variable's ACCESS is SET'able <br> if ( MibPtr-&gt;Access != MIB_ACCESS_READWRITE &amp;&amp; <br>      MibPtr-&gt;Access != MIB_ACCESS_WRITE ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME; <br>            goto Exit; <br>    } <br> <br>         // Check for proper type before setting <br>         if ( MibPtr-&gt;Type != VarBind-&gt;value.asnType ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_BADVALUE; <br>    goto Exit; <br>    } <br> <br> // Save value in MIB <br> switch ( VarBind-&gt;value.asnType ) <br>    { <br>            case ASN_RFC1155_COUNTER: <br>            case ASN_RFC1155_GAUGE: <br>            case ASN_INTEGER: <br>               *(AsnInteger *)(MibPtr-&gt;Storage) = VarBind-&gt;value.asnValue.number; <br>       break; <br> <br>            case ASN_OCTETSTRING: // This entails ASN_RFC1213_DISPSTRING also <br>               // The storage must be adequate to contain the new string <br>               // including a NULL terminator. <br>               memcpy( (LPSTR)MibPtr-&gt;Storage, <br>                       VarBind-&gt;value.asnValue.string.stream, <br>                       VarBind-&gt;value.asnValue.string.length ); <br> <br>       ((LPSTR)MibPtr-&gt;Storage)[VarBind-&gt;value.asnValue.string.length] = <br>                                                                          '\0'; <br>       break; <br> <br>    default: <br>       ErrStat = SNMP_ERRORSTATUS_GENERR; <br>       goto Exit; <br>    } <br> <br>         break; <br> <br>      default: <br> ErrStat = SNMP_ERRORSTATUS_GENERR; <br> goto Exit; <br>      } // switch <br> <br>   // Signal no error occurred <br>   ErrStat = SNMP_ERRORSTATUS_NOERROR; <br> <br>Exit: <br>   return ErrStat; <br>} // MIB_leaf_func <br> <br> <br> <br>// <br>// MIB_control_func <br>//    Performs specific actions on the toasterControl MIB variable <br>// <br>// Notes: <br>// <br>// Return Codes: <br>//    Standard PDU error codes. <br>// <br>// Error Codes: <br>//    None. <br>// <br>UINT MIB_control_func( <br>        IN UINT Action, <br>IN MIB_ENTRY *MibPtr, <br>IN RFC1157VarBind *VarBind <br>) <br> <br>{ <br>UINT   ErrStat; <br> <br>   switch ( Action ) <br>      { <br>      case MIB_ACTION_SET: <br>         // Make sure that this variable's ACCESS is SET'able <br> if ( MibPtr-&gt;Access != MIB_ACCESS_READWRITE &amp;&amp; <br>      MibPtr-&gt;Access != MIB_ACCESS_WRITE ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME; <br>            goto Exit; <br>    } <br> <br>         // Check for proper type before setting <br>         if ( MibPtr-&gt;Type != VarBind-&gt;value.asnType ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_BADVALUE; <br>    goto Exit; <br>    } <br> <br>         // Make sure the value is valid <br>         if ( MIB_TOASTER_UP &gt; VarBind-&gt;value.asnValue.number || <br>              MIB_TOASTER_DOWN &lt; VarBind-&gt;value.asnValue.number ) <br>            { <br>    ErrStat = SNMP_ERRORSTATUS_BADVALUE; <br>    goto Exit; <br>            } <br> <br>         // Let fall through purposefully for further processing by <br>         // generic leaf function. <br> <br>      case MIB_ACTION_GETNEXT: <br>      case MIB_ACTION_GET: <br> // Call the more generic function to perform the action <br>         ErrStat = MIB_leaf_func( Action, MibPtr, VarBind ); <br>         break; <br> <br>      default: <br> ErrStat = SNMP_ERRORSTATUS_GENERR; <br> goto Exit; <br>      } // switch <br> <br>Exit: <br>   return ErrStat; <br>} // MIB_control_func <br> <br> <br> <br>// <br>// MIB_doneness_func <br>//    Performs specific actions on the toasterDoneness MIB variable <br>// <br>// Notes: <br>// <br>// Return Codes: <br>//    Standard PDU error codes. <br>// <br>// Error Codes: <br>//    None. <br>// <br>UINT MIB_doneness_func( <br>        IN UINT Action, <br>IN MIB_ENTRY *MibPtr, <br>IN RFC1157VarBind *VarBind <br>) <br> <br>{ <br>UINT   ErrStat; <br> <br>   switch ( Action ) <br>      { <br>      case MIB_ACTION_SET: <br>         // Make sure that this variable's ACCESS is SET'able <br> if ( MibPtr-&gt;Access != MIB_ACCESS_READWRITE &amp;&amp; <br>      MibPtr-&gt;Access != MIB_ACCESS_WRITE ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME; <br>            goto Exit; <br>    } <br> <br>         // Check for proper type before setting <br>         if ( MibPtr-&gt;Type != VarBind-&gt;value.asnType ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_BADVALUE; <br>    goto Exit; <br>    } <br> <br>         // Make sure the value is valid <br>         if ( MIB_TOASTER_LIGHTLYWARM &gt; VarBind-&gt;value.asnValue.number || <br>              MIB_TOASTER_BURNT &lt; VarBind-&gt;value.asnValue.number ) <br>            { <br>    ErrStat = SNMP_ERRORSTATUS_BADVALUE; <br>    goto Exit; <br>            } <br> <br>         // Let fall through purposefully for further processing by <br>         // generic leaf function. <br> <br>      case MIB_ACTION_GETNEXT: <br>      case MIB_ACTION_GET: <br> // Call the more generic function to perform the action <br>         ErrStat = MIB_leaf_func( Action, MibPtr, VarBind ); <br>         break; <br> <br>      default: <br> ErrStat = SNMP_ERRORSTATUS_GENERR; <br> goto Exit; <br>      } // switch <br> <br>Exit: <br>   return ErrStat; <br>} // MIB_doneness_func <br> <br> <br> <br>// <br>// MIB_toasttype_func <br>//    Performs specific actions on the toasterToastType MIB variable <br>// <br>// Notes: <br>// <br>// Return Codes: <br>//    Standard PDU error codes. <br>// <br>// Error Codes: <br>//    None. <br>// <br>UINT MIB_toasttype_func( <br>        IN UINT Action, <br>IN MIB_ENTRY *MibPtr, <br>IN RFC1157VarBind *VarBind <br>) <br> <br>{ <br>UINT   ErrStat; <br> <br>   switch ( Action ) <br>      { <br>      case MIB_ACTION_SET: <br>         // Make sure that this variable's ACCESS is SET'able <br> if ( MibPtr-&gt;Access != MIB_ACCESS_READWRITE &amp;&amp; <br>      MibPtr-&gt;Access != MIB_ACCESS_WRITE ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME; <br>            goto Exit; <br>    } <br> <br>         // Check for proper type before setting <br>         if ( MibPtr-&gt;Type != VarBind-&gt;value.asnType ) <br>    { <br>    ErrStat = SNMP_ERRORSTATUS_BADVALUE; <br>    goto Exit; <br>    } <br> <br>         // Make sure the value is valid <br>         if ( MIB_TOASTER_WHITEBREAD &gt; VarBind-&gt;value.asnValue.number || <br>              MIB_TOASTER_OTHERBREAD &lt; VarBind-&gt;value.asnValue.number ) <br>            { <br>    ErrStat = SNMP_ERRORSTATUS_BADVALUE; <br>    goto Exit; <br>            } <br> <br>         // Let fall through purposefully for further processing by <br>         // generic leaf function. <br> <br>      case MIB_ACTION_GETNEXT: <br>      case MIB_ACTION_GET: <br> // Call the more generic function to perform the action <br>         ErrStat = MIB_leaf_func( Action, MibPtr, VarBind ); <br>         break; <br> <br>      default: <br> ErrStat = SNMP_ERRORSTATUS_GENERR; <br> goto Exit; <br>      } // switch <br> <br>Exit: <br>   return ErrStat; <br>} // MIB_toasttype_func <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
