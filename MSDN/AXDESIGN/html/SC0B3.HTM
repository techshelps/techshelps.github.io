<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Providing Type Information</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<H4>Providing Type Information</H4><P>The <B>GetDynamicClassInfo</B> method gives the host access to dynamic type information for the objects an ActiveX designer creates. You should implement this method if you expect any changes to the type information for the visual designer.</P>
<P>The method returns two parameters: <I>ppTypeInfoOut</I>, an indirect pointer to a type information object that describes a coclass; and <I>pdwCookie</I>, a handle that the host retains and saves in its own cache along with the type information. </P>
<P>The remainder of this section steps through tasks you may need to perform to create and return a dynamic type information object. Assume that the following declarations have been made:</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">ICreateTypeInfo *pctiDispinterface = NULL;
ICreateTypeInfo *pctiCoClass = NULL;
ICreateTypeLib2 *pCreateTypeLib = NULL;
ITypeInfo *ptiEvents = NULL, *ptiDispinterface;
HREFTYPE hreftype;
HRESULT  hr;
</font></pre>
<P>Error handling has been omitted for brevity throughout this section.</P>
<P>Creating the Type Library</P>
<P>The dynamic type information object must be in a new format type library. </P>
<P>To create a new type library, you use the <B>ICreateTypeLib2</B> interface or the <B>CreateTypeLib2</B> Application Programming Interface (API), as in the following example. </P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">hr = CreateTypeLib2(SYS_WIN32, pwszFile, &amp;pCreateTypeLib);

// Set the guid, helpstring DLL and name.
hr = pCreateTypeLib-&gt;SetGuid(m_state.guidTypeLib);
hr = pCreateTypeLib-&gt;SetHelpStringDll(L"");
hr = pCreateTypeLib-&gt;SetName(L"MyDesignerTypeLib");
</font></pre>
<P>In the example, pwszFile contains a temporary name for the type library and m_state is a global structure that holds useful information for the designer, including its GUID. You must set the name for the new type library.</P>
<P>Creating the Type Information Object</P>
<P>After creating the type library, you can create the type information object. The easiest way is to use an existing static type information object as a template. If the existing static object describes a virtual function table (VTBL) interface (or a <B>dual</B> interface), you can simply copy the object. Automation handles the necessary inheritance. You can then return an indirect pointer to your copy as the type information object (see "Returning Parameters," later in this section).</P>
<P>For a dispatch interface, however, the procedure is more complicated. You must copy the entire object and set up the inheritance yourself, in code. The following code fragment shows this procedure.</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">// Get the dispatch interface to use as a template.
hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType),0,
            LANG_NEUTRAL, &amp;pTypeLibStatic);

hr = pTypeLibStatic-&gt;GetTypeInfoOfGuid(DIID_DMyDesigner,
                                           &amp;ptiDispinterface);
if (SUCCEEDED(hr)) {
    // Now get the type information of event interface.
    hr = pTypeLibStatic-&gt;GetTypeInfoOfGuid(
                        DIID_DMyDesignerEvents,ppTypeInfo);
    if (SUCCEEDED(hr)) {
        // And get the type information of control object.
        hr = pTypeLibStatic-&gt;GetTypeInfoOfGuid(CLSID_MyObject,                                     &amp;m_state.pMyObjectTI);
    }
 }
pTypeLibStatic-&gt;Release();
</font></pre>
<P>The preceding code fragment gets an existing type information object that describes a dispatch interface. The next few lines create a new dispatch type information object and set its GUID. The local function _GetIDispatchTypeInfo returns the dispatch type information for the existing object. Calls to <B>AddRefTypeInfo</B> and <B>AddImplTypeInfo</B> set up the inheritance. </P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">hr = pTypeLib-&gt;CreateTypeInfo(L"DMyDesignerObject", TKIND_DISPATCH,
                                  &amp;pctiDispinterface);
hr = pctiDispinterface-&gt;SetGuid(m_state.guidTypeInfo);

hr = _GetIDispatchTypeInfo(&amp;ptiDispatch);
hr = pctiDispinterface-&gt;AddRefTypeInfo(ptiDispatch, &amp;hreftype);
hr = pctiDispinterface-&gt;AddImplType(0, hreftype);
</font></pre>
<P>Finally, the code copies the existing type information from *ptiDispInterface to the new object, *pctiDispInterface, and lays out the type information. In this example, CopyDispInterfaceTypeInfo is a local function that copies the information.</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">hr = CopyDispinterfaceTypeInfo(ptiDispinterface, pctiDispinterface);
pctiDispinterface-&gt;LayOut();
pctiDispinterface-&gt;AddRef();
</font></pre>
<P>At this point, pctiDispInterface points to a TKIND_DISPATCH type information object to be used as a template for the new dynamic type information object. The new object must contain type information for a coclass, so you have to create a blank object of TKIND_COCLASS:</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">hr = pCreateTypeLib-&gt;CreateTypeInfo(L"MyDesigner", TKIND_COCLASS,
                                    &amp;pctiCoClass);
</font></pre>
<P>Next, you get the type information for the existing interfaces and events from the template in pctiDispinterface, add these to the new type information in ptiCoClass, and set the implementation type flags:</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">hr = pctiDispinterface-&gt;QueryInterface(IID_ITypeInfo,
                                           (void **)&amp;ptiDispinterface);
// Information on the interface.
hr = pctiCoClass-&gt;AddRefTypeInfo(ptiDispinterface, &amp;hreftype);
ptiDispinterface-&gt;Release();
hr = pctiCoClass-&gt;AddImplType(0, hreftype);

// Information on the events.
hr = pctiCoClass-&gt;AddRefTypeInfo(ptiEvents, &amp;hreftype);
hr = pctiCoClass-&gt;AddImplType(1, hreftype);

// Now set up the flags for these two items.
hr = pctiCoClass-&gt;SetImplTypeFlags(0, IMPLTYPEFLAG_FDEFAULT);
hr = pctiCoClass-&gt;SetImplTypeFlags(1, IMPLTYPEFLAG_FDEFAULT
                                   | IMPLTYPEFLAG_FSOURCE);
</font></pre>
<P>When this is done, the type information object is set up. Only two tasks remain: setting up the output parameter and incrementing the cookie.</P>
<P>Returning Parameters</P>
<P>The <I>ppTypeInfo</I> output parameter of <B>GetDynamicClassInfo</B> is an indirect pointer to an <B>ITypeInfo</B> interface. Because pctiCoClass represents an <B>ICreateTypeInfo</B> interface, you have to query for the correct interface and cast the resulting pointer:</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">pctiCoClass-&gt;QueryInterface(IID_ITypeInfo, (void **)ppTypeInfo)
</font></pre>
<P>Finally, pass the current value of the cookie, which is stored in the global variable m_dwTICookie:</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">if (pdwCookie)
        *pdwCookie = m_dwTICookie;
</font></pre>
<P>The value of *pdwCookie is initially set in the <B>InitNew</B> or <B>Load</B> method of the designer's persistence interfaces, and is incremented if an unrecoverable error occurs when the persistent data are loaded.</P>
<P>When the host is reloaded, it checks the cookie to determine whether its cached version of the type information is up-to-date. If the cached version is accurate, the host can use it without having to reload the persistent state. If the cache is outdated, the host must reload the persistent state. </P></FONT>
</BODY>
</HTML>
