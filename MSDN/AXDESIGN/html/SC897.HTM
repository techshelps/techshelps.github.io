<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Extended Objects and Aggregation</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<H2>Extended Objects and Aggregation</H2><P>This section briefly describes extended objects and focuses on their role in ActiveX designers. <I>The</I>&nbsp;<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_com_overview">
</object><a href=JavaScript:alink_1.Click()>COM Programmer's Reference</A> and a variety of other sources in the Microsoft Developer Network (MSDN) provide detailed explanations of aggregation and the controlling <B>IUnknown</B>; refer to those sources for additional information. </P>
<P>An <I>extended object</I> is an instance that has attached code (usually code that handles events) or added properties, methods, or events. For an ActiveX designer, an extended object has three parts: the ActiveX designer object; the extension, which the host adds; and the code written by the user to extend the designer. At run time, the host aggregates the parts as shown in the following diagram:</P>
<P>    <img src="abdes021.gif"></P>
<P>In the aggregate, the <I>controlling extensible object</I> determines how the object behaves and operates. It implements a special instance of the <B>IUnknown</B> interface called the <I>controlling </I><B><I>IUnknown</I></B>. The controlling <B>IUnknown</B> must always be implemented as part of the new code when the aggregate is put together. </P>
<P>For the aggregate to work correctly, both the object and its extension must be written to cooperate with the controlling extensible object. Both the object and the extension implement <B>IUnknown</B>. Instead of acting independently, however, they should forward their<B> AddRef</B>, <B>Release</B>, and <B>QueryInterface</B> calls to the controlling <B>IUnknown</B>. The controlling <B>IUnknown</B> maintains a reference count for the aggregate as a whole, so that it can be kept alive if there are references to any of the interfaces supported by the controlling extensible object, the extension, or the object itself. </P>
<P>In the figure, the lines and circles that extend beyond the bounds of the aggregate indicate interfaces that are externally available. Both the object and the extension can expose interfaces. However, the controlling <B>IUnknown</B> is exposed to the outside world, while the object and extension <B>IUnknown</B> implementations are not. Within the aggregate, the controlling extensible object holds a pointer to the object's <B>IUnknown </B>implementation, indicated by the dotted line, and vice versa. </P>
<P>When an instance of the object is created at run time, the caller receives a pointer to the controlling <B>IUnknown</B> rather than to the object's <B>IUnknown</B> interface. Calls to the object's <B>IUnknown</B> methods are delegated through the controlling <B>IUnknown</B> as necessary. This process ensures that the object's <B>IUnknown</B> interface remains private and that reference counts are accurately tracked.</P>
<P></P>
<P></P></FONT>
</BODY>
</HTML>
