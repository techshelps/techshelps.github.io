<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Adding Type Information</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<H4>Adding Type Information</H4><P>To add type information, you use the <B>AddFuncDesc </B>or<B> AddVarDesc </B>method of the <B>ICreateTypeInfo </B>interface. </P>
<P>Call <B>AddFuncDesc</B> to add a method to a dispatch interface or to add a property or method to a VTBL interface. Call <B>AddVarDesc</B> to add a property to a dispatch<B> </B>interface.</P>
<P>Each of these methods takes two parameters: an index for the new variable or function in the type description; and a pointer to a <B>FUNCDESC</B> or <B>VARDESC</B> structure that describes the new property or method. </P>
<P>The values of the fields in the function and variable descriptors depend on the type of interface you're working with and the property or method you're adding. For <B>AddFuncDesc</B>, build a function descriptor according to the values in the following table. See the &nbsp;<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_oa96_introduction">
</object><a href=JavaScript:alink_1.Click()>Automation Programmer's Reference</A> for additional details.</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="133pt" VALIGN="TOP"><COL WIDTH="133pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Field</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD><TD VALIGN="TOP"><P><B>Suggested Value</B></P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><I>memid</I></P></TD><TD VALIGN="TOP"><P>Function member identifier; same as the DISPID.</P></TD><TD VALIGN="TOP"><P>MEMBERID_NIL. The ID will be assigned later by the <B>LayOut</B> method.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>LprgScode</I></P></TD><TD VALIGN="TOP"><P>Valid return values for the function.</P></TD><TD VALIGN="TOP"><P>User-defined.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>LprgElemdescParam</I></P></TD><TD VALIGN="TOP"><P>Array of parameter types.</P></TD><TD VALIGN="TOP"><P>User-defined.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>Funckind</I></P></TD><TD VALIGN="TOP"><P>Type of function.</P></TD><TD VALIGN="TOP"><P>FUNC_PUREVIRTUAL or FUNC_DISPATCH</P></TD></TR><TR><TD VALIGN="TOP"><P><I>invkind</I></P></TD><TD VALIGN="TOP"><P>Invocation kind.</P></TD><TD VALIGN="TOP"><P>INVOKE_PROPERTYGET or INVOKE_FUNC</P></TD></TR><TR><TD VALIGN="TOP"><P><I>callconv</I></P></TD><TD VALIGN="TOP"><P>Calling convention.</P></TD><TD VALIGN="TOP"><P>CC_STDCALL</P></TD></TR><TR><TD VALIGN="TOP"><P><I>cParams</I></P></TD><TD VALIGN="TOP"><P>Total number of parameters.</P></TD><TD VALIGN="TOP"><P>User-defined.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>cParamsOpt</I></P></TD><TD VALIGN="TOP"><P>Number of optional parameters.</P></TD><TD VALIGN="TOP"><P>User-defined.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>oVft</I></P></TD><TD VALIGN="TOP"><P>Offset into virtual function table.</P></TD><TD VALIGN="TOP"><P>0. The VTBL address will be assigned later by the <B>LayOut</B> method.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>cScodes</I></P></TD><TD VALIGN="TOP"><P>Number of return values in <I>lprgScode</I>.</P></TD><TD VALIGN="TOP"><P>User-defined.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>elemdescFunc</I></P></TD><TD VALIGN="TOP"><P>ELEMDESC structure that gives the return type for the function.</P></TD><TD VALIGN="TOP"><P>User-defined.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>wFuncFlags</I></P></TD><TD VALIGN="TOP"><P>FUNCFLAG enumeration that describes function.</P></TD><TD VALIGN="TOP"><P>Use FUNCFLAG_FSOURCE if the function is a source of events.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>For <B>AddVarDesc</B>, build a variable descriptor according to the values in the following table. See the <I>Automation Programmer's Reference</I> for additional details.</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="133pt" VALIGN="TOP"><COL WIDTH="133pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Field</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD><TD VALIGN="TOP"><P><B>Suggested Value</B></P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><I>memid</I></P></TD><TD VALIGN="TOP"><P>Member identifier for the property; same as the DISPID.</P></TD><TD VALIGN="TOP"><P>MEMBERID_NIL. The ID will be assigned later by the <B>LayOut</B> method.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>ElemdescVar</I></P></TD><TD VALIGN="TOP"><P>ELEMDESC structure that contains the type information for the property.</P></TD><TD VALIGN="TOP"><P>User-defined.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>WVarFlags</I></P></TD><TD VALIGN="TOP"><P>VARFLAG enumeration that describes the property.</P></TD><TD VALIGN="TOP"><P>Use VARFLAG_FSOURCE if the property is a source of events.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>Varkind</I></P></TD><TD VALIGN="TOP"><P>VARKIND enumeration that identifies the property.</P></TD><TD VALIGN="TOP"><P>VAR_DISPATCH</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>For both a function and a variable, specify an index of 0 to place the description at the front of the type information. </P>
<P>The following example builds a variable descriptor and adds a property to a dispatch interface. In the example, the property is one of a group of subobjects that the designer can create. The variable vd is a structure of type <B>VARDESC</B> and td is a structure of type <B>TYPEDESC</B>. </P>
<P>First, the example sets up some constants in the VARDESC structure. It specifies VAR_DISPATCH to indicate that it applies to a dispatch interface, and variable flags to show that it is a source of events and is read-only. This example also specifies its own DISPIDs, rather than allowing the <B>Layout</B> method to assign them.</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">vd.memid = index + DISPID_CUSTOMOFFSET;
vd.varkind = VAR_DISPATCH;
vd.wVarFlags = VARFLAG_FSOURCE | VARFLAG_FREADONLY;
</font></pre>
<P>Next, it adds a reference to the new property's type information:</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">hr = m_state.pRuntimeDispinterface-&gt;AddRefTypeInfo(
                                    m_state.pObjectTI, &amp;href);
    </font></pre>
<P>With the handle to the referenced type information in href, the rest of the variable and type descriptors can be filled in. The variable descriptor is then passed to <B>AddVarDesc</B> to add the new type information:</P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">td.vt = VT_USERDEFINED;
td.hreftype = href;
vd.elemdescVar.tdesc.lptdesc = &amp;td;
vd.elemdescVar.tdesc.vt = VT_PTR;
hr = m_state.pRuntimeDispinterface-&gt;AddVarDesc(0, &amp;vd);
</font></pre>
<P>After adding the property, you should set its name. The code fragment below keeps the names of the subobjects in the global structure m_state, and retrieves it from there to pass to the <B>SetVarName</B> method:  </P>

<PRE><FONT FACE="COURIER, COURIER NEW" SIZE="2">bstrName = m_state.rgObjects[index].bstrName;
hr =  m_state.pRuntimeDispinterface-&gt;SetVarName(0, bstrName);
</font></pre>
<P>Finally, you must lay out the new type information. See "Laying Out the Type Information" later in this chapter.</P></FONT>
</BODY>
</HTML>
