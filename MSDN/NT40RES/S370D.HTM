<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Performance Monitor Limitations</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#FFFFFF"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Performance Monitor Limitations</H3><P CLASS="t">As you use Performance Monitor and other monitoring tools, remember their limitations. Understanding the range and resolution of your tools is essential to accurate diagnosis.</P>
<H4><A NAME="sec0"></A>Counter Limits</H4><P CLASS="t">It's important to know just what your counters are counting. In each section of this book, we try to mention <I>how</I> the counters measure as well as <I>what</I> they measure. This information is important, especially when you are interpreting suspicious data or getting inconsistent results.</P>
<H4><A NAME="sec1"></A>Update Interval</H4><P CLASS="t">The Update Interval you select on the <B>Options</B> dialog box is designed to determine how often Performance Monitor measures counter values. However, Performance Monitor is just another application contending for processor time. On a busy computer, Performance Monitor might be competing with higher priority threads for access to the processor and might not be able to update the counters as frequently as you choose.</P>
<P CLASS="t">If Performance Monitor appears to be updating less frequently, chart the Process: %&nbsp;Processor Time or Process: Priority Base counters on all processes, including the Performance Monitor process, Perfmon.exe. Look for processes with high priorities or those getting a disproportionate share of processor time. These might be preventing Performance Monitor from updating at the rate you chose. Performance Monitor runs at a elevated base priority to make sure it can monitor under most circumstances, but it can get locked out like any other process. If necessary, you can use Task Manager to increase the base priority class of Perfmon.exe. For more information, see "Changing the Base Priority Class" in Chapter 11, "Performance Monitoring Tools." </P>
<H4><A NAME="sec2"></A>Compound Problems</H4><P CLASS="t">It is difficult to detect multiple bottlenecks in a system. You might spend several days testing and retesting to identify and eliminate a bottleneck, only to find that another appears in its place. Only thorough and patient testing of all elements can assure that you have found all of the problems.</P>
<P CLASS="t">It is not unusual to trace a performance problem to multiple sources. Poor response time on a workstation is most likely to result from memory and processor problems. Servers are more susceptible to disk and network problems.</P>
<P CLASS="t">Also, problems in one component might be the <I>result</I> of problems in another component, not the cause. For example, when memory is scarce, the system begins moving pages of code and data between disks and physical memory. The memory shortage MESMESis manifest in increased disk and processor use, but the problem is memory, not the processor or disk.</P>
<P CLASS="t">Lack of memory is by far the most common cause of serious performance problems in computer systems. If you suspect other problems, check Memory: Pages/sec<B> </B>to make sure a memory shortage is not appearing in another guise.</P>
<H4><A NAME="sec3"></A>Monitoring Processes and Threads</H4><P CLASS="t">Monitoring processes and threads is an essential part of tuning software performance and understanding how applications affect your hardware. However, some Performance Monitor counter values might be invalid if the threads or processes are stopping and starting while Performance Monitor is watching. </P>
<P CLASS="t">When processes with the same name start and stop, Performance Monitor sometimes mistakes them for a single process and combines the data for different processes into a single graph or report line. Threads are even more prone to mistaken identity and combination, because Performance Monitor knows them only by their thread number, a number which only indicates the order in which the threads started. JBJB</P>
<P CLASS="t">Fortunately, you can recognize and eliminate errant values from your data:</P>
<UL><LI>Include the Process ID and Thread ID counters in graphs of your data. These are ordinal numbers assigned to processes and threads when they start, and which remain with them until they stop. If the line representing the ID is not straight, it means that data for more than one process is combined. </LI></UL><UL><LI>When monitoring processes and threads, watch for spikes in the data. These spikes sometimes appear when Performance Monitor monitors the start of a process. They are an artifact of monitoring and do not represent valid values for the Performance Monitor counters.</LI></UL><UL><LI>Always chart the data in a line graph first, even if you are preparing a report. Reports and histograms show last values and averages, which might hide a spike.</LI></UL><UL><LI>Use the Performance Monitor Time Window to eliminate spikes from your data and to separate the data for different processes or threads from a single data line. For more details, see "The Time Window" later in this chapter.</LI></UL><P></P>
<H5 CLASS="h4"><A NAME="sec4"></A>Monitoring Processes</H5><P CLASS="t">It is important to recognize when Performance Monitor has combined processes and to distinguish the values for each process from values for the others. Also, you must recognize and eliminate invalid data spikes which sometimes occur when you start a monitored process.</P>
<P CLASS="t">Data for the following graph was collected by starting Microsoft Word, stopping it, then starting it again. The thick line, representing Process ID, shows that the process ID changed (from 126 to 114). Because Process IDs do not change while a process is executing, this indicates that data from two different processes are represented in the same line. A graph of Process ID data is straight unless it represents data from more than one process.</P>
<P><img src="xwr_i07.gif"></P>
<P CLASS="t">The thin line, representing page fault rates for the Microsoft Word process, Winword.exe, has two large spikes of unusually high values, as reflected in the status bar. These spikes don't represent page faults; they happen when processes with the same name stop and start.</P>
<P CLASS="t">Performance Monitor counters that measure rates/second or percentages actually display the change in value of an ever increasing internal counter associated with each object. When a process stops, the internal counter drops to zero and the change, as reported to Performance Monitor, is the absolute value of the largest long integer the computer's memory holds. Performance Monitor politely displays a zero.</P>
<P CLASS="t">However, when a new process starts, the difference between this huge number and the new thread value is displayed, causing the high value. The next value, the average of the last two, falls back to a more reasonable number.</P>
<P CLASS="t">The high values are not valid, nor are averages that include them. You can use the Performance Monitor Time Window, described later in this chapter, to exclude them from your sample. The remaining data is valid, but you might want to separate the data for the first process from data for the second process.</P>
<H5 CLASS="h4"><A NAME="sec5"></A>Monitoring Threads</H5><P CLASS="t">Threads don't have names. They have thread numbers and Thread IDs. Performance Monitor collects and displays data on threads by process name and thread number. The thread number just indicates the order in which the threads started, beginning with 0. When a thread stops, the thread numbers of all of the threads behind it move up. For example, if a process has two threads, numbered 0 and 1, and thread 0 stops, thread 1 becomes thread 0. If Performance Monitor is watching, the counts for thread 0 now include data from both the old thread 0 and the new one.</P>
<P></P>
<P CLASS="t"><B>Note</B></P>
<P>Do not confuse the terms used to identify threads and processes. Here are some descriptions to help you distinguish among them.</P>
<UL><LI><I>Thread number</I> is an ordinal number assigned to threads in a process to show the order in which the thread started. A thread's thread number changes when threads with lower numbers stop, because the thread number of all later threads move up to fill in the gap. </LI></UL><UL><LI><I>Thread ID</I> is also an ordinal number which has no intrinsic association with a thread, but it remains with a started thread until it stops.</LI></UL><UL><LI><I>Process ID</I>, like Thread ID, is an ordinal number which has no intrinsic association with a process, but it is assigned to the process when it starts and remains with it until it stops. When the process starts again, it is just as likely to be assigned a different number.</LI></UL><P></P>
<P CLASS="t">That is what happened when data for this graph was collected.</P>
<P><img src="xwr_i08.gif"></P>
<P CLASS="t">The spikes are a warning that the context switching rates shown for the threads might be invalid. This graph also includes the system-level counter for context switches, which runs at an average of about 200 context switches per second. Since the values in the spikes of Thread #4 are higher than system totals, it is clear that the high values represent threads starting and stopping, not context switches.</P>
<P CLASS="t">A graph of Thread ID confirms this guess. Thread ID, like Process ID (but unlike thread number), is assigned to the thread by the operating system and remains with it until it stops running.</P>
<P><img src="xwr_i09.gif"></P>
<P CLASS="t">Each spike in the context switch graph coincides with a change in the thread ID. Thread 123 is the first thread identified to Performance Monitor as Thread #4. When it stops, data from Thread 143, which used to be Thread #5, is now collected as Thread 4. When Thread 143 stops, Thread 166, formerly Thread #5, now becomes thread #4.</P>
<P CLASS="t">These characteristic spikes are sufficient warning that some data is invalid, but they don't always appear. The following figure shows a different view of the same process.</P>
<P><img src="xwr_i10.gif"></P>
<P CLASS="t">This is a graph of Thread ID and context switches for Thread #5 of the same process. In this case, the Thread IDs change, indicating that data from more than one thread is combined. However, there are no large spikes, even though the values are multiplied by 10, because none of the threads stopped while they were being monitored. </P>
<P CLASS="t">Each time the thread in Thread #4 stops, the fifth thread becomes Thread #4 and Thread #5 inherits a thread from Thread #6. The little peaks show the difference in the values of two running threads.</P>
<P CLASS="t">Although there are no spikes, data from this graph should still be distinguished by Thread ID and the data surrounding the thread transitions should be discarded. For more information on selecting data, see "The Time Window" later in this chapter.</P></BODY></HTML>
