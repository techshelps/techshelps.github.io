<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Priority Bottlenecks</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#FFFFFF"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Priority Bottlenecks</H3><P CLASS="t">When a processor has excess capacity, process and thread priority do not affect performance significantly. All threads run when ready, regardless of their priority. However, when the processor is busy, lower priority applications and services might not get the processor time they need.</P>
<P CLASS="t">The following graph shows threads of different priorities contending for processor time. It demonstrates the changing distribution of processor time among processes of different priorities as demand for processor time increases. (This test was conducted by using CPU Stress, a tool on the Windows NT Resource Kit 4.0 CD that lets you set the priorities and activity levels of a process and its threads.) </P>
<P><img src="xwr_l35.gif"></P>
<P></P>
<P></P>
<P CLASS="t">This graph shows two threads of the same process running on a single-processor computer. Lines have been added to show each of the four parts of the test. The thick, gray line is System: % Total Processor Time. The white line represents processor time for Thread 1; the white line represents processor time for Thread 2.</P>
<P></P>
<P CLASS="t">The test conditions and results are represented in the following table:</P>

<TABLE COLS="6" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="82pt" VALIGN="TOP"><COL WIDTH="57pt" VALIGN="TOP"><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P CLASS="th"><B>Object</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Part 1</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Part 2</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Part 3</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Part 4</B></P></TD></TR><TR><TD COLSPAN="6" VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P><B>Processor:<BR></B>% Processor<BR>Time</P></TD><TD VALIGN="TOP"><P>58.8</P></TD><TD VALIGN="TOP"><P>54.1</P></TD><TD VALIGN="TOP"><P>100</P></TD><TD VALIGN="TOP"><P>100</P></TD></TR><TR><TD VALIGN="TOP"><P><B>Thread 1</B></P></TD><TD VALIGN="TOP"><P><B></B></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>Priority</P></TD><TD VALIGN="TOP"><P>Normal (8)</P></TD><TD VALIGN="TOP"><P>Above normal (9)</P></TD><TD VALIGN="TOP"><P>Normal (8)</P></TD><TD VALIGN="TOP"><P>Above normal (9)</P></TD></TR><TR><TD VALIGN="TOP"><P>Thread:     <BR> %Processor<BR>     Time</P></TD><TD VALIGN="TOP"><P>20.6</P></TD><TD VALIGN="TOP"><P>21.5</P></TD><TD VALIGN="TOP"><P>44.2</P></TD><TD VALIGN="TOP"><P>76.5</P></TD></TR><TR><TD VALIGN="TOP"><P><B>Thread 2</B></P></TD><TD VALIGN="TOP"><P><B></B></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>     Priority</P></TD><TD VALIGN="TOP"><P>Normal (8)</P></TD><TD VALIGN="TOP"><P>Normal (8)</P></TD><TD VALIGN="TOP"><P>Normal (8)</P></TD><TD VALIGN="TOP"><P>Normal (8.5)<BR>Varies from 8 - 14</P></TD></TR><TR><TD VALIGN="TOP"><P>     Thread:     <BR>     %Processor<BR>     Time</P></TD><TD VALIGN="TOP"><P>20.9</P></TD><TD VALIGN="TOP"><P>20.8</P></TD><TD VALIGN="TOP"><P>45.0</P></TD><TD VALIGN="TOP"><P>5.6</P></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P>
<P CLASS="t">This test demonstrates that when the processor has extra capacity, increasing the priority of one thread has little effect on the processor time allotted to each of the competing threads. (The small variation is not statistically significant.) However, when the processor is at its busiest, increasing the priority one of the threads, even by one priority level, causes the higher priority thread to get the vast majority of processor time (an average of 76.5%).</P>
<P CLASS="t">In fact, in Part 4, when all processor time is consumed, Thread 2 might not have been scheduled at all were it not for Windows&nbsp;NT's priority inversion strategy. <I>Priority inversion </I>is when the Microkernel randomly boosts the priorities of ready threads running in Idle, Normal and High priority processes so that they can execute. (It does not boost the threads of Real-Time processes.) Windows NT uses priority inversion to give processor time to lower priority ready threads which wouldn't otherwise be able to run.</P>
<P CLASS="t">The effect of priority inversion is shown in the following graph. This graph was created by using the Time Window to limit the data to Part 4 of the test. The current priority values were scaled by 10 to make them visible on the graph and the vertical maximum of the graph was increased to 150.</P>
<P><img src="xwr_l36.gif"></P>
<P></P>
<P CLASS="t">This graph compares priority with processor time during Part 4 of the test. The current priority of Thread 1 (the thick, black line) remains at 9 throughout the sample interval, and its processor time averages 76.5%. Although the priority of Thread 2 (the white line) was set to 8 by CPU Stress, it is repeatedly boosted to 14 in order to enable it to be scheduled. Despite the boost, it ran for an average of only 5.6% of the sample interval.</P></BODY></HTML>
