<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Thread State</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#FFFFFF"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Thread State</H3><P CLASS="t">A long processor queue is a warning that a bottleneck, however brief, might be developing. The Thread: Thread State counter lets you examine which threads are in the queue and how long they remain before being serviced.</P>
<P CLASS="t">By definition, all of the threads in the processor queue are Ready, but are waiting for a processor to become available. <I>Ready</I> is a dispatcher thread state, one of eight states that signal when a thread is prepared to be dispatched to the processor.</P>
<P CLASS="t">The following table lists the thread states for threads in Windows&nbsp;NT.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="276pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P CLASS="th"><B>Thread state</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Definition</B></P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>Initialized. The thread is recognized as an object by the microkernel.</P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>Ready. The thread is  prepared to run on the next free processor.</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>Running. The thread is executing.</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>Standby. The thread is assigned to a processor and about to run. Only one thread can be in Standby state at a time.</P></TD></TR><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>Terminated. The thread is finished executing.</P></TD></TR><TR><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>Waiting. The thread is not ready for the processor. When it is ready, it will have to be rescheduled.</P></TD></TR><TR><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>Transition. The thread is ready but waiting for resources other than the processor to become available.</P></TD></TR><TR><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>The  thread state is unknown.</P></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P>
<P CLASS="t">To determine which threads are contending for the processor, chart the thread states of all threads in the system. The following figure shows such a chart. The vertical maximum is reduced to 10 to show the values which range from 0 through 7.</P>
<P><img src="xwr_l15.gif"></P>
<P CLASS="t">The first, tallest bar is System: % Total Processor Time, is 100%, scaled to 0.1 to fit in the chart. The next bar is System: Processor Queue Length, which is 7. The remaining bars represent the thread states of threads in active processes.</P>
<P CLASS="t">The thread that is running on the processor, that is, at Thread State 2, is PERFMON Thread 1, a thread of the Performance Monitor executable. (It is represented by the white bar in middle of the graph.) In fact, a Performance Monitor thread always appears as the running thread when it captures data; if it weren't, it could not be capturing the data. This is an inescapable artifact of the tool.</P>
<P CLASS="t">Therefore, in Thread State charts or graphs, you need to assume that the processes getting processor time are those bouncing from Ready and in the queue (1) to Waiting (5). In this example, the bars at Ready (1) are the first few on the left, representing the processor-guzzling simulation tool, a System thread, two Services threads, and an RPC subsystem thread. (As you scroll through a running Performance Monitor graph, the thread state value appears in the value bar.)</P>
<P CLASS="t">The pattern of thread state activity is better seen in a line graph. Although it is much busier, it reveals the patterns of processor use by each thread.</P>
<P><img src="xwr_l16.gif"></P>
<P CLASS="t">To create a graph like this one, chart all running threads, then delete threads that are never ready and set the vertical maximum to 6. This is a bit hard to read in still life, but the patterns for each thread become more apparent when you highlight the selected line by pressing the backspace key.</P>
<P CLASS="t">The black line that always appears to be running (at thread state 2) is PERFMON. The lines with the most activity are those of CPU Stress, the simulation tool. The white line is a thread of the Explorer process.</P>
<P CLASS="t">Although busy, this graph highlights which threads are in the queue and reveals their scheduling patterns. On logged data, you can use the Time Window to limit a thread state graph to selected data points, so you can measure the elapsed time a thread spent in each thread state. Summing the time in the ready state in each second sampled will tell you how long, on average, the threads are waiting in the queue. This information is quite useful when tuning thread behavior.</P></BODY></HTML>
