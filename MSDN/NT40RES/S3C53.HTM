<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>System Reliability and Performance Comparison</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#FFFFFF"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>System Reliability and Performance Comparison</H3><P CLASS="t">Windows&nbsp;NT protects all of its operating system code by locating it in either kernel mode (or Ring 0 of the Intel protection model) or in protected subsystems in user mode (or Ring 3), each of which runs in its own address space. Thus, all Windows&nbsp;NT operating system code and data are protected from applications.</P>
<P CLASS="t">Applications, which run in user mode, have access only to their own address spaces. To communicate with system services, an application must utilize specific application programming interfaces (APIs) to convert their threads from user to kernel mode. In order for the application to regain control of the threads, they must be converted back to user mode. Thus, applications have no access to the memory of the subsystems and cannot interfere with the operating system or its support of other applications.</P>
<P CLASS="t">For more information about kernel and user mode, see "Kernel Mode and User Mode" in Chapter 5, "Windows&nbsp;NT 4.0 Workstation Architecture."</P>
<P CLASS="t">Windows 95 locates most of its operating system components in kernel mode, but its system services DLLs (GDI, GDI32, KERNEL, KERNEL32, USER, USER32) run in user mode for the purposes of enhanced performance as well as for backward compatibility with MS-DOS and Windows 3.<I>x</I> applications and device driver software, etc. An ill-behaved application can gain access to and write to operating system memory and crash the system. For more information about Windows 95 architecture, see <I>Windows 95 Resource Kit</I>.</P>
<H4><A NAME="sec0"></A>Running Win16 and DOS Applications</H4><P CLASS="t">Both Windows 95 and Windows&nbsp;NT run Win16 and DOS applications along with the Win32 applications developed to run on Win32 operating systems. The two systems handle Win16 applications differently, and generally Windows&nbsp;NT is the recommended operating system for computers that run both types of applications. </P>
<P></P>
<P CLASS="t">Windows 95 uses <I>cooperative multitasking</I> with Win16 applications. Cooperative multitasking allows an application to voluntarily pass CPU access to another application when the message input queue is empty. Because of this, a Win16 application that fails to check the queue can halt the system for all Win16 applications. Win32 applications that are running should not be affected because the Win16 apps are preemptively multitasked with respect to other processes. </P>
<P CLASS="t">Windows 95 runs Win16 applications as a single multithreaded process in a shared address space. Windows 95 system services DLLs (GDI, GDI32, KERNEL, KERNEL32, USER, USER32) are mapped into the address space of each process. These components, as mentioned earlier, run in user mode. This makes the operating system vulnerable to applications which might write to memory belonging to the operating system.</P>
<P CLASS="t">The system services DLLs in Windows 95 each have a Win32 and a Win16 component. The system is designed to use Win32 code wherever it improves performance without sacrificing application compatibility and uses Win16 code where Win32 code would increase memory requirements without improving performance. Consequently, in Windows 95 both Win16 and Win32 applications require some <I>thunking</I> (translation) between 16-bit and 32-bit threads. </P>
<P CLASS="t">Additionally, the Win16 code in Windows 95 is <I>nonreentrant</I>, whereas Win32 code is <I>reentrant</I>. Reentrant code can be interrupted and resume unharmed, and it can be shared by different threads executing different lines of the same code. The nonreentrant code in Windows 95 would be vulnerable to Win32 threads, except for a flag (called <I>Win16Mutex</I>) that prevent threads from accessing code another thread is using to execute. Consequently, performance of even Win32 applications is slower when Win16 applications are running.</P>
<P CLASS="t">Windows&nbsp;NT can run each Win16 and MS-DOS application in its own private address space within a Win32 application called a Virtual DOS Machine (VDM), thus protecting it from other Win16 programs. This allows Windows&nbsp;NT to preemptively multitask all operating system services and all applications. For a more detailed description of preemptive multitasking and scheduling, see Chapter 5, "Windows&nbsp;NT Workstation Architecture."</P>
<P CLASS="t">DOS applications run well on both systems, running in separate VDMs, but in Windows 95—because some memory is available to all virtual machines—DOS applications can crash the system. In Windows&nbsp;NT, no operating system memory is available to processes outside of kernel mode.</P>
<P CLASS="t">For details about how Windows&nbsp;NT handles Win16 and MS-DOS applications, see "Implementation of the Subsystem" earlier in this chapter. For details about how Windows 95 handles Win16 applications, see the <I>Windows 95 Resource Kit</I>.</P></BODY></HTML>
