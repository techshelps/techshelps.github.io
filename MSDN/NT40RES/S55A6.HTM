<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Terms and ConceptsMESMES</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#FFFFFF"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Terms and ConceptsMESMES</H3><P CLASS="t">The <I>Windows&nbsp;NT Virtual Memory Manager</I> controls how memory is allocated, reserved, committed, and paged. It includes sophisticated strategies for anticipating the code and data requirements of processes to minimizing disk access.</P>
<P CLASS="t">The code and data in physical memory are divided into units called <I>pages</I>. The size of a page varies with the processor platform. MIPS, Intel, and PowerPC platforms have 4096 bytes per page; DEC Alpha platforms have 8192 bytes per page.</P>
<P CLASS="t">The Virtual Memory Manager moves pages of code and data between disk and memory in a process called <I>paging.</I> Paging is essential to a virtual memory system, although excessive paging can monopolize processors and disks.</P>
<P CLASS="t">A <I>page fault</I> occurs when a program requests a page of code or data is not in its <I>working set</I> (the set of pages visible to the program in physical memory). </P>
<UL><LI>A <I>hard page fault</I> occurs when the requested page must be retrieved from disk. </LI></UL><UL><LI>A <I>soft page fault</I> occurs when then the requested page is found elsewhere in physical memory<I>.</I> </LI></UL><P></P>
<P CLASS="t">Soft page faults can be satisfied quickly and relatively easily by the Virtual Memory Manager, but hard faults cause paging, which can degrade performance.</P>
<P CLASS="t">Each page in memory is stored in a <I>page frame</I>. Before a page of code or data can be moved from disk into memory, the Virtual Memory Manager must find or create a free page frame or a frame filled with zeros. (Zero-filled pages are a requirement of the U.S. Government C2 security standard. Page frames must be filled with zeros to prevent the previous contents from being used by a new process.) To free a page frame, changes to a data page in the frame might need to be written to disk before the frame is reused. Code pages, which are typically not changed by a program, can be deleted.</P>
<P CLASS="t">When code or data paged into physical memory is used by a process, the system reserves space for that page on the <I>disk paging file</I>, Pagefile.sys, in case the page needs to be written back to disk. Pagefile.sys is a reserved block of disk space that is used to back up committed memory. It can be contiguous or fragmented. Because memory needs to be backed by the paging file, the size of the paging file limits the amount of data that can be stored in memory. By default, Pagefile.sys is set to the size of physical memory plus 12&nbsp;MBMESMES, but you can change it. Increasing the size of the paging file often resolves virtual memory shortages.</P>
<P CLASS="t">In Windows&nbsp;NT&nbsp;4.0 Workstation and Server, objects created and used by applications and the operating system are stored in <I>memory pools</I>. These pools are accessible only in privileged mode, the processing mode in which operating system components run, so application threads must be switched to privileged mode to see the objects stored in the pools.</P>
<UL><LI>The <I>paged pool</I> holds objects that can be paged to disk.</LI></UL><UL><LI>The <I>nonpaged pool </I>holds objects that never leave main memory, such as data structures used by interrupt routines or those which prevent multiprocessor conflicts within the operating system.</LI></UL><P></P>
<P CLASS="t">The initial size of the pools is based on the amount of physical memory available to Windows&nbsp;NT. Thereafter, the pool size is adjusted dynamically and varies widely, depending upon the applications and services that are running.</P>
<P CLASS="t">All virtual memory in Windows&nbsp;NT is either reserved, committed, or available:</P>
<UL><LI><I>Reserved memory</I> is a set of contiguous addresses that the Virtual Memory Manager sets aside for a process but doesn't count against the process's memory quota until it is used. When a process needs to write to memory, some of the reserved memory is committed to the process. If the process runs out of memory, available memory can be reserved and committed simultaneously.</LI></UL><UL><LI>Memory is <I>committed</I> when the Virtual Memory Manager saves space for it in Pagefile.sys in case it needs to be written to disk. The amount of committed memory for a process is an indication of how much memory is it really using. </LI></UL><P></P>
<P CLASS="t">Committed memory is limited by the size of the paging file. The <I>commit limit</I> is the amount of memory that can be committed without expanding the paging file. If disk space is available, the paging file can expand, and the commit limit will be increased.</P>
<P CLASS="t">Memory that is neither reserved nor committed is <I>available. </I>Available memory includes free memory, zeroed memory (which is cleared and filled with zeros), and memory on the standby list, which has been removed from a process's working set but might be reclaimed.</P></BODY></HTML>
