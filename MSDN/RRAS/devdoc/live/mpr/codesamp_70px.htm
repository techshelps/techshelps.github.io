<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>StopProtocol Sample</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_mpr_stopprotocol_sample"></a>StopProtocol Sample</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<pre><code>DWORD
APIENTRY
StopProtocol()
/*++
  Routine Description
     This function is called by the IP Router Manager to tell the
     protocol to stop.  We set the protocol state to prevent us from
     servicing any more requests. Then we notify the MainThread to stop
     and return PENDING to the IP Router Manager. If we had no thread
     and no work functions in our implementation, we could have stopped
     synchronously.
     
  Arguments


  Return Value
     PENDING

--*/
{   
    EnterCriticalSection(&amp;g_csProtocolStateLock);

    TraceEnter("StopProtocol");
    
    //
    // Cannot stop if already stopped
    //

    if(g_dwProtocolState != PROTOCOL_STATE_RUNNING)
    {
        Trace1(GLOBAL,
               "StopProtocol: Protocol state is %s",
               g_ppszStateStrings[g_dwProtocolState]);
        
        TraceLeave("StopProtocol");
        
        LeaveCriticalSection(&amp;g_csProtocolStateLock);

        ExitProtocolApi();
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Dont release the state lock, so that the other threads
    // won't cleanup under us
    //
    
    //
    // Tell the main thread to stop. That will clean out everything
    //

    Trace0(GLOBAL,
           "StopProtocol: Signalling main thread to stop");

    SetEvent(g_hStopProtocolEvent);
    
    //
    // Set state to STOPPING;
    //

    g_dwProtocolState = PROTOCOL_STATE_STOPPING;

    Trace1(GLOBAL,
           "StopProtocol: %d threads are still active",
           g_dwProtocolRefCount);


    TraceLeave("StopProtocol");
    
    LeaveCriticalSection(&amp;g_csProtocolStateLock);

    return ERROR_PROTOCOL_STOP_PENDING;
}</code></pre>
<p>&nbsp;</p></body>
</HTML>
