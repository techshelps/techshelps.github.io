<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RegisterProtocol Sample</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_mpr_registerprotocol_sample"></a>RegisterProtocol Sample</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<pre><code>DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
/*++
Routine Description
    This is the first function called by the IP Router Manager.  
    The Router Manager tells the routing protocol it version and 
    capabilities. It also tells the our DLL, the ID of the protocol
    it expects us to register.  This allows one DLL to support
    multiple routing protocols.
    We return the functionality we support and a pointer to
    our functions.
    
Arguments
  

Return Value
    NO_ERROR

--*/
{
    //
    // The Router Manager should be calling us to register
    // our protocol.
    // The Router Manager must be atleast the version we are
    // compiled with.
    // The Router Manager must support routing and demand update.
    //

    if(pRoutingChar-&gt;dwProtocolId != SAMPLE_PROTOCOL_ROUTE_ID)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if(pRoutingChar-&gt;dwVersion &lt; MS_ROUTER_VERSION)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if(pRoutingChar-&gt;fSupportedFunctionality != (ROUTING |
                                             DEMAND_UPDATE_ROUTES))
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Since we are not a service advertiser (an IPX thing)
    //

    //
    // We setup our characteristics and function pointers
    //

    pServiceChar-&gt;fSupportedFunctionality = 0;

    pRoutingChar-&gt;fSupportedFunctionality = (ROUTING |
                                             DEMAND_UPDATE_ROUTES);

    pRoutingChar-&gt;pfnStartProtocol    = StartProtocol;
    pRoutingChar-&gt;pfnStopProtocol     = StopProtocol;
    pRoutingChar-&gt;pfnAddInterface     = AddInterface;
    pRoutingChar-&gt;pfnDeleteInterface  = DeleteInterface;
    pRoutingChar-&gt;pfnGetEventMessage  = GetEventMessage;
    pRoutingChar-&gt;pfnGetInterfaceInfo = GetInterfaceConfigInfo;
    pRoutingChar-&gt;pfnSetInterfaceInfo = SetInterfaceConfigInfo;
    pRoutingChar-&gt;pfnBindInterface    = BindInterface;
    pRoutingChar-&gt;pfnUnbindInterface  = UnBindInterface;
    pRoutingChar-&gt;pfnEnableInterface  = EnableInterface;
    pRoutingChar-&gt;pfnDisableInterface = DisableInterface;
    pRoutingChar-&gt;pfnGetGlobalInfo    = GetGlobalInfo;
    pRoutingChar-&gt;pfnSetGlobalInfo    = SetGlobalInfo;
    pRoutingChar-&gt;pfnMibCreateEntry   = MibCreate;
    pRoutingChar-&gt;pfnMibDeleteEntry   = MibDelete;
    pRoutingChar-&gt;pfnMibGetEntry      = MibGet;
    pRoutingChar-&gt;pfnMibSetEntry      = MibSet;
    pRoutingChar-&gt;pfnMibGetFirstEntry = MibGetFirst;
    pRoutingChar-&gt;pfnMibGetNextEntry  = MibGetNext;
    pRoutingChar-&gt;pfnUpdateRoutes     = DoUpdateRoutes;

    return NO_ERROR;
}</code></pre>
<p>&nbsp;</p></body>
</HTML>
