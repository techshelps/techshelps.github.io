<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GetInterfaceConfigInfo Sample</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_mpr_getinterfaceconfiginfo_sample"></a>GetInterfaceConfigInfo Sample</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<pre><code>DWORD
APIENTRY
GetInterfaceConfigInfo(
    IN     DWORD  dwIndex,
    IN OUT PVOID  pvConfig,
    IN OUT PDWORD pdwSize
    )
/*++
  Routine Description
      Called by the IP Router Manager to retrieve an
      interface's configuration. Usually this is because an admin
      utility is displaying this information. The Router Manager calls
      us with a NULL config and ZERO size. We return the required size
      to it. It then allocates the needed memory and calls us a second
      time with a valid buffer.  We validate parameters each time and
      copy out our config if we can

  Arguments
      dwIndex   Index of the interface being queried
      pvConfig  Pointer to buffer to store the config
      pdwSize   Size of the buffer

  Return Value
      ERROR_INSUFFICIENT_BUFFER If the size of the buffer is too small
      ERROR_INVALID_PARAMETER
      ERROR_INVALID_DATA
      NO_ERROR

--*/
{
    PNT_IF      pIf;
    PLIST_ENTRY pleNode;
    PINTRNL_IF  pBind;
    ULONG       i;
    
    PSAMPLE_PROTOCOL_INTERFACE_INFO pIfInfo;

    
    EnterProtocolApi();

    TraceEnter("GetInterfaceConfigInfo");
    
    if(pdwSize == NULL)
    {
        Trace0(ERR,
               "GetInterfaceConfigInfo: Router Manager called us with NULL size");

        TraceLeave("GetInterfaceConfigInfo");

        ExitProtocolApi();

        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection(&amp;g_csIfListLock);

    pIf = GetIfBlockGivenIndex(dwIndex);

    if(pIf == NULL)
    {
        LeaveCriticalSection(&amp;g_csIfListLock);
        
        Trace1(ERR,
               "GetInterfaceConfigInfo: Interface %d does not exist",
               dwIndex);

        TraceLeave("GetInterfaceConfigInfo");

        ExitProtocolApi();

        return ERROR_INVALID_PARAMETER;
    }

    if(*pdwSize &lt; SIZEOF_PROTO_IF_INFO(pIf-&gt;ulNumBindings))
    {
        *pdwSize = SIZEOF_PROTO_IF_INFO(pIf-&gt;ulNumBindings);

        LeaveCriticalSection(&amp;g_csIfListLock);

        TraceLeave("GetInterfaceConfigInfo");

        ExitProtocolApi();

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pdwSize = SIZEOF_PROTO_IF_INFO(pIf-&gt;ulNumBindings);
    
    if(pvConfig == NULL)
    {
        LeaveCriticalSection(&amp;g_csIfListLock);
        
        Trace0(ERR,
               "GetInterfaceConfigInfo: Router Manager called us with NULL config buffer");

        TraceLeave("GetInterfaceConfigInfo");

        ExitProtocolApi();

        return ERROR_INVALID_PARAMETER;
    }

    //
    // So we have a good buffer of the right size
    // Copy out the info
    //

            
    pIfInfo = (PSAMPLE_PROTOCOL_INTERFACE_INFO)pvConfig;

    pIfInfo-&gt;ulNumBindings = pIf-&gt;ulNumBindings;

    for(pleNode  = pIf-&gt;leInternalIfHead.Flink, i = 0;
        pleNode != &amp;pIf-&gt;leInternalIfHead;
        pleNode  = pleNode-&gt;Flink, i++)
    {
        pBind = CONTAINING_RECORD(pleNode, INTRNL_IF, leInternalIfLink);

        pIfInfo-&gt;rgbiInfo[i].dwAddress  = pBind-&gt;dwAddress;
        pIfInfo-&gt;rgbiInfo[i].dwMask     = pBind-&gt;dwMask;
        pIfInfo-&gt;rgbiInfo[i].bEnabled   = pBind-&gt;bEnabled;
    }

    ASSERT(i == pIf-&gt;ulNumBindings);

    //
    // If we had only one address we will return 0.0.0.0 as the address
    // even if we know what the current address is
    //
    
    if(pIf-&gt;ulNumBindings == 1)
    {
        pIfInfo-&gt;rgbiInfo[0].dwAddress  = 0x00000000;
        pIfInfo-&gt;rgbiInfo[0].dwMask     = 0x00000000;
    }

    LeaveCriticalSection(&amp;g_csIfListLock);

    TraceLeave("GetInterfaceConfigInfo");

    ExitProtocolApi();

    return NO_ERROR;
}</code></pre>
<p>&nbsp;</p></body>
</HTML>
