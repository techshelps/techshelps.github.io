<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>multiset</title></head>
<body bgcolor=white>

<h2><a name="multiset">multiset</a></h2>
<META NAME="MS-HKWD" CONTENT="multiset">
<p><a href="SET_multisetCCallocator_type.htm#multiset::allocator_type"><code><b>allocator_type</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCbegin.htm#multiset::begin"><code><b>begin</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCclear.htm#multiset::clear"><code><b>clear</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCconst_iterator.htm#multiset::const_iterator"><code><b>const_iterator</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCcons
t_reference.htm#multiset::const_reference"><code><b>const_reference</b></code></a><code><b> &#183;
</b></code><a href="SET_multisetCCconst_reverse_iterator.htm#multiset::const_reverse_iterator"><code><b>const_reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCcount.htm#multiset::count"><code><b>count</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCdifference_type.htm#multiset::difference_type"><code><b>difference_type</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCempty.htm#multiset::empty"><code><b>empty</b></code></a><code><b> &#183; </b
></code><a href="SET_multisetCCend.htm#multiset::end"><code><b>end</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCequal_range.htm#multiset::equal_range"><code><b>equal_range</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCerase.htm#multiset::erase"><code><b>erase</b></code></a><code><b> &#183;
</b></code><a href="SET_multisetCCfind.htm#multiset::find"><code><b>find</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCget_allocator.htm#multiset::get_allocator"><code><b>get_allocator</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCinsert.htm#multiset::insert"><code><b>insert</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCiterator.htm#multiset::iterator"><code><b>iterator</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCkey_comp.htm#mult
iset::key_comp"><code><b>key_comp</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCkey_compare.htm#multiset::key_compare"><code><b>key_compare</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCkey_type.htm#multiset::key_type"><code><b>key_type</b></code></a><code><b> &#183;
</b></code><a href="SET_multisetCClower_bound.htm#multiset::lower_bound"><code><b>lower_bound</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCmax_size.htm#multiset::max_size"><code><b>max_size</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCmultiset.htm#multiset::multiset"><code><b>multiset</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCrbegin.htm#multiset::rbegin"><code><b>rbegin</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCreference.h
tm#multiset::reference"><code><b>reference</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCrend.htm#multiset::rend"><code><b>rend</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCreverse_iterator.htm#multiset::reverse_iterator"><code><b>reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCsize.htm#multiset::size"><code><b>size</b></code></a><code><b> &#183;
</b></code><a href="SET_multisetCCsize_type.htm#multiset::size_type"><code><b>size_type</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCswap.htm#multiset::swap"><code><b>swap</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCupper_bound.htm#multiset::upper_bound"><code><b>upper_bound</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCvalue_comp.htm#multiset::value_comp"><code><b>value_comp</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCvalue_co
mpare.htm#multiset::value_compare"><code><b>value_compare</b></code></a><code><b> &#183; </b></code><a href="SET_multisetCCvalue_type.htm#multiset::value_type"><code><b>value_type</b></code></a><code><b> </b></code></p>
<pre><code>template&lt;class Key, class Pred = less&lt;Key&gt;, class A = allocator&lt;Key&gt; &gt;
    class <b>multiset</b> {
public:
    typedef Key <a href="SET_multisetCCkey_type.htm#multiset::key_type"><b>key_type</b></a>;
    typedef Pred <a href="SET_multisetCCkey_compare.htm#multiset::key_compare"><b>key_compare</b></a>;
    typedef Key <a href="SET_multisetCCvalue_type.htm#multiset::value_type"><b>value_type</b></a>;
    typedef Pred <a href="SET_multisetCCvalue_compare.htm#multiset::value_compare"><b>value_compare</b></a>;
    typedef A <a href="SET_multisetCCallocator_type.htm#multiset::allocator_type"><b>allocator_type</b></a>;
    typedef A::size_type <a href="SET_multisetCCsize_type.htm#multiset::size_type"><b>size_type</b></a>;
    typedef A::difference_type <a href="SET_multisetCCdifference_type.htm#multiset::difference_type"><b>difference_type</b></a>;
    typedef A::rebind&lt;value_type&gt;::other::const_reference <a href="SET_multisetCCreference.htm#multiset::reference"><b>reference</b></a>;
    typedef A::rebind&lt;value_type&gt;::other::const_reference <a href="SET_multisetCCconst_reference.htm#multiset::const_reference"><b>const_reference</b></a>;
    typedef T0 <a href="SET_multisetCCiterator.htm#multiset::iterator"><b>iterator</b></a>;
    typedef T1 <a href="SET_multisetCCconst_iterator.htm#multiset::const_iterator"><b>const_iterator</b></a>;
    typedef reverse_bidirectional_iterator&lt;iterator,
        value_type, reference, A::const_pointer,
            difference_type&gt; <a href="SET_multisetCCreverse_iterator.htm#multiset::reverse_iterator"><b>reverse_iterator</b></a>;
    typedef reverse_bidirectional_iterator&lt;const_iterator,
        value_type, const_reference, A::pointer,
            difference_type&gt; <a href="SET_multisetCCconst_reverse_iterator.htm#multiset::const_reverse_iterator"><b>const_reverse_iterator</b></a>;
    explicit <a href="SET_multisetCCmultiset.htm#multiset::multiset"><b>multiset</b></a>(const Pred&amp; comp = Pred(), const A&amp; al = A());
    <a href="SET_multisetCCmultiset.htm#multiset::multiset"><b>multiset</b></a>(const multiset&amp; x);
    <a href="SET_multisetCCmultiset.htm#multiset::multiset"><b>multiset</b></a>(const value_type *first, const value_type *last,
        const Pred&amp; comp = Pred(), const A&amp; al = A());
    const_iterator <a href="SET_multisetCCbegin.htm#multiset::begin"><b>begin</b></a>() const;
    iterator <a href="SET_multisetCCend.htm#multiset::end"><b>end</b></a>() const;
    const_reverse_iterator <a href="SET_multisetCCrbegin.htm#multiset::rbegin"><b>rbegin</b></a>() const;
    const_reverse_iterator <a href="SET_multisetCCrend.htm#multiset::rend"><b>rend</b></a>() const;
    size_type <a href="SET_multisetCCsize.htm#multiset::size"><b>size</b></a>() const;
    size_type <a href="SET_multisetCCmax_size.htm#multiset::max_size"><b>max_size</b></a>() const;
    bool <a href="SET_multisetCCempty.htm#multiset::empty"><b>empty</b></a>() const;
    A <a href="SET_multisetCCget_allocator.htm#multiset::get_allocator"><b>get_allocator</b></a>() const;
    iterator <a href="SET_multisetCCinsert.htm#multiset::insert"><b>insert</b></a>(const value_type&amp; x);
    iterator <a href="SET_multisetCCinsert.htm#multiset::insert"><b>insert</b></a>(iterator it, const value_type&amp; x);
    void <a href="SET_multisetCCinsert.htm#multiset::insert"><b>insert</b></a>(const value_type *first, const value_type *last);
    iterator <a href="SET_multisetCCerase.htm#multiset::erase"><b>erase</b></a>(iterator it);
    iterator <a href="SET_multisetCCerase.htm#multiset::erase"><b>erase</b></a>(iterator first, iterator last);
    size_type <a href="SET_multisetCCerase.htm#multiset::erase"><b>erase</b></a>(const Key&amp; key);
    void <a href="SET_multisetCCclear.htm#multiset::clear"><b>clear</b></a>();
    void <a href="SET_multisetCCswap.htm#multiset::swap"><b>swap</b></a>(multiset x);
    key_compare <a href="SET_multisetCCkey_comp.htm#multiset::key_comp"><b>key_comp</b></a>() const;
    value_compare <a href="SET_multisetCCvalue_comp.htm#multiset::value_comp"><b>value_comp</b></a>() const;
    const_iterator <a href="SET_multisetCCfind.htm#multiset::find"><b>find</b></a>(const Key&amp; key) const;
    size_type <a href="SET_multisetCCcount.htm#multiset::count"><b>count</b></a>(const Key&amp; key) const;
    const_iterator <a href="SET_multisetCClower_bound.htm#multiset::lower_bound"><b>lower_bound</b></a>(const Key&amp; key) const;
    const_iterator <a href="SET_multisetCCupper_bound.htm#multiset::upper_bound"><b>upper_bound</b></a>(const Key&amp; key) const;
    pair&lt;const_iterator, const_iterator&gt;
        <a href="SET_multisetCCequal_range.htm#multiset::equal_range"><b>equal_range</b></a>(const Key&amp; key) const;
protected:
    A allocator;
    };</code></pre>
<p>The template class describes an object that controls a varying-length sequence of elements of <b>type </b><code><b>const Key</b></code>. Each
element serves as both a sort key and a value. The sequence is represented in a way that permits lookup, insertion,
and removal of an arbitrary element with a number of operations proportional to the logarithm of the number of
elements in the sequence (logarithmic time). Moreover, inserting an element invalidates no iterators, and removing an
element invalidates only those iterators that point at the removed element.</p>
<p>The object orders the sequence it controls by calling a stored function object of type <code>Pred</code>. You access this stored
object by calling the member function <a href="SET_multisetCCkey_comp.htm#multiset::key_comp"><code>key_comp</code></a><code>()</code>. Such a function object must impose a total order on sort keys. For
any element <code>x</code> that precedes <code>y</code> in the sequence, <code>key_comp()(y, x)</code> is false. (For the default function object
<a href="FUNCTIO2_less.htm#less"><code>less</code></a><code>&lt;Key&gt;</code>, sort keys never decrease in value.) Unlike template class <a href="SET_set.htm#set"><code>set</code></a>, an object of template class <code>multiset</code> does
not ensure that <code>key_comp()(x, y)</code> is true. (Keys need not be unique.)</p>
<p>The object allocates and frees storage for the sequence it controls through a protected object named <a name="multiset::allocator"><code><b>allocator</b></code></a>, of
<b>class </b><code><b>A</b></code>. Such an <a href="MEMORY_allocator.htm#allocator object">allocator object</a> must have the same external interface as an object of template class <a href="MEMORY_allocator.htm#allocator"><code>allocator</code></a>.
Note that <code>allocator</code> is not copied when the object is assigned.</p>
</body>
</html>
