<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>References to Pointers</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_references_to_pointers"></a><sup></sup>References to Pointers</h1>
<p>
References to pointers can be declared in much the same way as references to objects. Declaring a reference to a pointer yields a modifiable value that is used like a normal pointer. The following code samples illustrate the difference between using a pointer to a pointer and a reference to a pointer:</p>
<pre><code>#include &lt;iostream.h&gt;
#include &lt;string.h&gt;

// Define a binary tree structure.
struct BTree
{
 &nbsp;&nbsp; char&nbsp; *szText;
 &nbsp;&nbsp; BTree *Left;
 &nbsp;&nbsp; BTree *Right;
};
// Define a pointer to the root of the tree.
BTree *btRoot = 0;

int Add1( BTree **Root, char *szToAdd );
int Add2( BTree*&amp; Root, char *szToAdd );
void PrintTree( BTree* btRoot );

int main( int argc, char *argv[] )
{
 &nbsp;&nbsp; if( argc &lt; 2 )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "Usage: Refptr [1 | 2]" &lt;&lt; "\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "\n\twhere:\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "\t1 uses double indirection\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "\t2 uses a reference to a pointer.\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "\n\tInput is from stdin.\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; char *szBuf = new char[132];

 &nbsp;&nbsp; // Read a text file from the standard input device and
 &nbsp;&nbsp; //&nbsp; build a binary tree.
 &nbsp;&nbsp; while( !cin.eof() )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin.get( szBuf, 132, '\n' );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin.get();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( strlen( szBuf ) )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( *argv[1] )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Method 1: Use double indirection.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '1':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add1( &amp;btRoot, szBuf );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Method 2: Use reference to a pointer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '2':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add2( btRoot, szBuf );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "Illegal value '" &lt;&lt; *argv[1]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "' supplied for add method.\n"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "Choose 1 or 2.\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Display the sorted list.
 &nbsp;&nbsp; PrintTree( btRoot );
 &nbsp;&nbsp; return 0;
}

// PrintTree: Display the binary tree in order.
void PrintTree( BTree* btRoot )
{
 &nbsp;&nbsp; // Traverse the left branch of the tree recursively.
 &nbsp;&nbsp; if( btRoot-&gt;Left )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintTree( btRoot-&gt;Left );

 &nbsp;&nbsp; // Print the current node.
 &nbsp;&nbsp; cout &lt;&lt; btRoot-&gt;szText &lt;&lt; "\n";

 &nbsp;&nbsp; // Traverse the right branch of the tree recursively.
 &nbsp;&nbsp; if( btRoot-&gt;Right )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintTree( btRoot-&gt;Right );
}

// Add1: Add a node to the binary tree.
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uses double indirection.
int Add1( BTree **Root, char *szToAdd )
{
 &nbsp;&nbsp; if( (*Root) == 0 )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*Root) = new BTree;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*Root)-&gt;Left = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*Root)-&gt;Right = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*Root)-&gt;szText = new char[strlen( szToAdd ) + 1];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( (*Root)-&gt;szText, szToAdd );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if( strcmp( (*Root)-&gt;szText, szToAdd ) &gt; 0 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Add1( &amp;((*Root)-&gt;Left), szToAdd );
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Add1( &amp;((*Root)-&gt;Right), szToAdd );
}

// Add2: Add a node to the binary tree.
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uses reference to pointer
int Add2( BTree*&amp; Root, char *szToAdd )
{
 &nbsp;&nbsp; if( Root == 0 )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root = new BTree;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root-&gt;Left = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root-&gt;Right = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root-&gt;szText = new char[strlen( szToAdd ) + 1];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( Root-&gt;szText, szToAdd );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if( strcmp( Root-&gt;szText, szToAdd ) &gt; 0 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Add2( Root-&gt;Left, szToAdd );
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Add2( Root-&gt;Right, szToAdd );
}
</code></pre>
<p>
In the preceding program, functions <code>Add1</code> and <code>Add2</code> are functionally equivalent (although they are not called the same way). The difference is that <code>Add1</code> uses double indirection whereas <code>Add2</code> uses the convenience of a reference to a pointer.</p>
</font></BODY>
</HTML>
