<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Virtual Functions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_virtual_functions"></a><sup></sup>Virtual Functions</h1>
<p>
“Virtual functions” are functions that ensure that the correct function is called for an object, regardless of the expression used to make the function call.</p>
<p>
Suppose a base class contains a function declared as <b>virtual</b> and a derived class defines the same function. The function from the derived class is invoked for objects of the derived class, even if it is called using a pointer or reference to the base class. The following example shows a base class that provides an implementation of the <code>PrintBalance</code> function:</p>
<pre><code>class Account
{
public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Account( double d );&nbsp; // Constructor.
 &nbsp;&nbsp; virtual double GetBalance();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Obtain balance.
 &nbsp;&nbsp; virtual void&nbsp;&nbsp; PrintBalance();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Default implementation.
private:
 &nbsp;&nbsp; double _balance;
};

// Implementation of constructor for Account.
double Account::Account( double d )
{
 &nbsp;&nbsp; _balance = d;
}
// Implementation of GetBalance for Account.
double Account::GetBalance()
{
 &nbsp;&nbsp; return _balance;
}
// Default implementation of PrintBalance.
void Account::PrintBalance()
{
 &nbsp;&nbsp; cerr &lt;&lt; "Error. Balance not available for base type."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
}
</code></pre>
<p>
Two derived classes, <code>CheckingAccount</code> and <code>SavingsAccount</code>, can be created as follows:</p>
<pre><code>class CheckingAccount : public Account
{
public:
 &nbsp;&nbsp; void PrintBalance();
};

// Implementation of PrintBalance for CheckingAccount.
void CheckingAccount::PrintBalance()
{
 &nbsp;&nbsp; cout &lt;&lt; "Checking account balance: " &lt;&lt; GetBalance();
}

class SavingsAccount : public Account
{
public:
 &nbsp;&nbsp; void PrintBalance();
};

// Implementation of PrintBalance for SavingsAccount.
void SavingsAccount::PrintBalance()
{
 &nbsp;&nbsp; cout &lt;&lt; "Savings account balance: " &lt;&lt; GetBalance();
}
</code></pre>
<p>
The <code>PrintBalance</code> function in the derived classes is virtual because it is declared as virtual in the base class, <code>Account</code>. To call virtual functions such as <code>PrintBalance</code>, code such as the following can be used:</p>
<pre><code>// Create objects of type CheckingAccount and SavingsAccount.
CheckingAccount *pChecking = new CheckingAccount( 100.00 );
SavingsAccount&nbsp; *pSavings&nbsp; = new SavingsAccount( 1000.00 );

// Call PrintBalance using a pointer to Account.
Account *pAccount = pChecking;
pAccount-&gt;PrintBalance();

// Call PrintBalance using a pointer to Account.
pAccount = pSavings;
pAccount-&gt;PrintBalance();
</code></pre>
<p>
In the preceding code, the calls to <code>PrintBalance</code> are identical, except for the object <code>pAccount</code> points to. Because <code>PrintBalance</code> is virtual, the version of the function defined for each object is called. The <code>PrintBalance</code> function in the derived classes <code>CheckingAccount</code> and <code>SavingsAccount</code> “override” the function in the base class <code>Account</code>.</p>
<p>
If a class is declared that does not provide an overriding implementation of the <code>PrintBalance</code> function, the default implementation from the base class <code>Account</code> is used.</p>
<p>
Functions in derived classes override virtual functions in base classes only if their type is the same. A function in a derived class cannot differ from a virtual function in a base class in its return type only; the argument list must differ as well.</p>
<p>
When calling a function using pointers or references, the following rules apply:
<ul type=disc>
<li>
A call to a virtual function is resolved according to the underlying type of object for which it is called.<br><br></li>
<li>
A call to a nonvirtual function is resolved according to the type of the pointer or reference.</li>
</ul>
<p>
The following example shows how virtual and nonvirtual functions behave when called through pointers:</p>
<pre><code>#include &lt;iostream.h&gt;

// Declare a base class.
class Base
{
public:
 &nbsp;&nbsp; virtual void NameOf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Virtual function.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void InvokingClass();&nbsp;&nbsp; // Nonvirtual function.
};

// Implement the two functions.
void Base::NameOf()
{
 &nbsp;&nbsp; cout &lt;&lt; "Base::NameOf\n";
}

void Base::InvokingClass()
{
 &nbsp;&nbsp; cout &lt;&lt; "Invoked by Base\n";
}

// Declare a derived class.
class Derived : public Base
{
public:
 &nbsp;&nbsp; void NameOf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Virtual function.
 &nbsp;&nbsp; void InvokingClass();&nbsp;&nbsp; // Nonvirtual function.
};

// Implement the two functions.
void Derived::NameOf()
{
 &nbsp;&nbsp; cout &lt;&lt; "Derived::NameOf\n";
}

void Derived::InvokingClass()
{
 &nbsp;&nbsp; cout &lt;&lt; "Invoked by Derived\n";
}

void main()
{
 &nbsp;&nbsp; // Declare an object of type Derived.
 &nbsp;&nbsp; Derived aDerived;
 &nbsp;&nbsp; // Declare two pointers, one of type Derived * and the other
 &nbsp;&nbsp; //&nbsp; of type Base *, and initialize them to point to aDerived.
 &nbsp;&nbsp; Derived *pDerived = &amp;aDerived;
 &nbsp;&nbsp; Base&nbsp;&nbsp;&nbsp; *pBase&nbsp;&nbsp;&nbsp; = &amp;aDerived;
 &nbsp;&nbsp; // Call the functions.
 &nbsp;&nbsp; pBase-&gt;NameOf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Call virtual function.
 &nbsp;&nbsp; pBase-&gt;InvokingClass();&nbsp;&nbsp;&nbsp; // Call nonvirtual function.
 &nbsp;&nbsp; pDerived-&gt;NameOf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Call virtual function.
 &nbsp;&nbsp; pDerived-&gt;InvokingClass(); // Call nonvirtual function.
}
</code></pre>
<p>
The output from this program is:</p>
<pre><code>Derived::NameOf
Invoked by Base
Derived::NameOf
Invoked by Derived
</code></pre>
<p>
Note that regardless of whether the <code>NameOf</code> function is invoked through a pointer to <code>Base</code> or a pointer to <code>Derived</code>, it calls the function for <code>Derived</code>. It calls the function for <code>Derived</code> because <code>NameOf</code> is a virtual function, and both <code>pBase</code> and <code>pDerived</code> point to an object of type <code>Derived</code>.</p>
<p>
Because virtual functions are called only for objects of class types, you cannot declare global or static functions as <b>virtual</b>.</p>
<p>
The <b>virtual</b> keyword can be used when declaring overriding functions in a derived class, but it is unnecessary; overrides of virtual functions are always virtual.</p>
<p>
Virtual functions in a base class must be defined unless they are declared using the <i>pure-specifier</i>. (For more information about pure virtual functions, see <a href="_pluslang_abstract_classes.htm">Abstract Classes</a>.)</p>
<p>
The virtual function-call mechanism can be suppressed by explicitly qualifying the function name using the scope-resolution operator (<b>::</b>). Consider the preceding example. To call <code>PrintBalance</code> in the base class, use code such as the following:</p>
<pre><code>CheckingAccount *pChecking = new CheckingAccount( 100.00 );

pChecking-&gt;Account::PrintBalance();&nbsp; //&nbsp; Explicit qualification.

Account *pAccount = pChecking;&nbsp; // Call Account::PrintBalance

pAccount-&gt;Account::PrintBalance();&nbsp;&nbsp; //&nbsp; Explicit qualification.
</code></pre>
<p>
Both calls to <code>PrintBalance</code> in the preceding example suppress the virtual function-call mechanism.</p>
</font></BODY>
</HTML>
