</html>
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<html>

<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>&lt;algorithm&gt;</title>
<meta name="GENERATOR" content="Microsoft FrontPage 1.1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
</head>

<body bgcolor=white>

<h1><a name="&lt;algorithm&gt;">&lt;algorithm&gt;</a></h1>
<META NAME="MS-HKWD" CONTENT="algorithm header file">
<p><a href="ALGORITH_adjacent_find.htm#adjacent_find"><code><b>adjacent_find</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_binary_search.htm#binary_search"><code><b>binary_search</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_copy.htm#copy"><code><b>copy</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_copy_backward.htm#copy_backward"><code><b>copy_backward</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_count.htm#count"><code><b>count</b></code></a><code><b
> &#183; </b></code><a href="ALGORITH_count_if.htm#count_if"><code><b>count_if</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_equal.htm#equal"><code><b>equal</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_equal_range.htm#equal_range"><code><b>equal_range</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_fill.htm#fill"><code><b>fill</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_fill_n.htm#fill_n"><code><b>fill_n</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_find.htm#find"><code><b>find</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_find_end.htm#find_end"><code><b>find_end</b></code></a><code><b> &#183; </b></code><a href="ALGORITH
_find_first_of.htm#find_first_of"><code><b>find_first_of</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_find_if.htm#find_if"><code><b>find_if</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_for_each.htm#for_each"><code><b>for_each</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_generate.htm#generate"><code><b>generate</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_generate_n.htm#generate_n"><code><b>generate_n</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_includes.htm#includes"><code><b>includes</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_inplace_merge.htm#inplace_merge"><code><b>inplace_merge</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_iter_swap.htm#iter_swap"><code><b>iter_swap</b></code></a>
<code><b> &#183; </b></code><a href="ALGORITH_lexicographical_compare.htm#lexicographical_compare"><code><b>lexicographical_compare</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_lower_bound.htm#lower_bound"><code><b>lower_bound</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_make_heap.htm#make_heap"><code><b>make_heap</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_max.htm#max"><code><b>max</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_max_element.htm#max_element"><code><b>max_element</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_merge.htm#merge"><code><b>merge</b></code></a><code><b> &#183; </b></code
><a href="ALGORITH_min.htm#min"><code><b>min</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_min_element.htm#min_element"><code><b>min_element</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_mismatch.htm#mismatch"><code><b>mismatch</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_next_permutation.htm#next_permutation"><code><b>next_permutation</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_nth_element.htm#nth_element"><code><b>nth_element</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_partial_sort.htm#partial_sort"><code><b>partial_sort</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_partial_sort_copy.htm#partial_sort_copy"><code><b>partial_sort_copy</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_partiti
on.htm#partition"><code><b>partition</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_pop_heap.htm#pop_heap"><code><b>pop_heap</b></code></a><code><b>
&#183; </b></code><a href="ALGORITH_prev_permutation.htm#prev_permutation"><code><b>prev_permutation</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_push_heap.htm#push_heap"><code><b>push_heap</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_random_shuffle.htm#random_shuffle"><code><b>random_shuffle</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_remove.htm#remove"><code><b>remove</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_remove_copy.htm#remove_copy"><cod
e><b>remove_copy</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_remove_copy_if.htm#remove_copy_if"><code><b>remove_copy_if</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_remove_if.htm#remove_if"><code><b>remove_if</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_replace.htm#replace"><code><b>replace</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_replace_copy.htm#replace_copy"><code><b>replace_copy</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_replace_copy_if.htm#replace_copy_if"><code><b>replace_copy_if</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_replace_if.htm#replace_if"><code><b>replace_if
</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_reverse.htm#reverse"><code><b>reverse</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_reverse_copy.htm#reverse_copy"><code><b>reverse_copy</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_rotate.htm#rotate"><code><b>rotate</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_rotate_copy.htm#rotate_copy"><code><b>rotate_copy</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_search.htm#search"><code><b>search</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_search_n.htm#search_n"><code><b>search_n</b></code></a><code><b> &#183
; </b></code><a href="ALGORITH_set_difference.htm#set_difference"><code><b>set_difference</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_set_intersection.htm#set_intersection"><code><b>set_intersection</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_set_symmetric_difference.htm#set_symmetric_difference"><code><b>set_symmetric_difference</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_set_union.htm#set_union"><code><b>set_union</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_sort.htm#sort"><code><b>sort</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_sort_heap.htm#so
rt_heap"><code><b>sort_heap</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_stable_partition.htm#stable_partition"><code><b>stable_partition</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_stable_sort.htm#stable_sort"><code><b>stable_sort</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_swap.htm#swap"><code><b>swap</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_swap_ranges.htm#swap_ranges"><code><b>swap_ranges</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_transform.htm#transform"><code><b>transform</b></
code></a><code><b> &#183; </b></code><a href="ALGORITH_unique.htm#unique"><code><b>unique</b></code></a><code><b> &#183; </b></code><a href="ALGORITH_unique_copy.htm#unique_copy"><code><b>unique_copy</b></code></a><code><b> &#183;
</b></code><a href="ALGORITH_upper_bound.htm#upper_bound"><code><b>upper_bound</b></code></a><code><b> </b></code></p>
<pre><code>namespace std {
template&lt;class InIt, class Fun&gt;
    Fun <a href="ALGORITH_for_each.htm#for_each"><b>for_each</b></a>(InIt first, InIt last, Fun f);
template&lt;class InIt, class T&gt;
    InIt <a href="ALGORITH_find.htm#find"><b>find</b></a>(InIt first, InIt last, const T&amp; val);
template&lt;class InIt, class Pred&gt;
    InIt <a href="ALGORITH_find_if.htm#find_if"><b>find_if</b></a>(InIt first, InIt last, Pred pr);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt1 <a href="ALGORITH_find_end.htm#find_end"><b>find_end</b></a>(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2);
template&lt;class FwdIt1, class FwdIt2, class Pred&gt;
    FwdIt1 <a href="ALGORITH_find_end.htm#find_end"><b>find_end</b></a>(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2, Pred pr);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt1 <a href="ALGORITH_find_first_of.htm#find_first_of"><b>find_first_of</b></a>(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2);
template&lt;class FwdIt1, class FwdIt2, class Pred&gt;
    FwdIt1 <a href="ALGORITH_find_first_of.htm#find_first_of"><b>find_first_of</b></a>(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt <a href="ALGORITH_adjacent_find.htm#adjacent_find"><b>adjacent_find</b></a>(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt <a href="ALGORITH_adjacent_find.htm#adjacent_find"><b>adjacent_find</b></a>(FwdIt first, FwdIt last, Pred pr);
    size_t <a href="ALGORITH_count.htm#count"><b>count</b></a>(InIt first, InIt last,
        const T&amp; val, Dist&amp; n);
template&lt;class InIt, class Pred, class Dist&gt;
    size_t <a href="ALGORITH_count_if.htm#count_if"><b>count_if</b></a>(InIt first, InIt last,
        Pred pr);
template&lt;class InIt1, class InIt2&gt;
    pair&lt;InIt1, InIt2&gt; <a href="ALGORITH_mismatch.htm#mismatch"><b>mismatch</b></a>(InIt1 first, InIt1 last, InIt2 x);
template&lt;class InIt1, class InIt2, class Pred&gt;
    pair&lt;InIt1, InIt2&gt; <a href="ALGORITH_mismatch.htm#mismatch"><b>mismatch</b></a>(InIt1 first, InIt1 last,
        InIt2 x, Pred pr);
template&lt;class InIt1, class InIt2&gt;
    bool <a href="ALGORITH_equal.htm#equal"><b>equal</b></a>(InIt1 first, InIt1 last, InIt2 x);
template&lt;class InIt1, class InIt2, class Pred&gt;
    bool <a href="ALGORITH_equal.htm#equal"><b>equal</b></a>(InIt1 first, InIt1 last, InIt2 x, Pred pr);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt1 <a href="ALGORITH_search.htm#search"><b>search</b></a>(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2);
template&lt;class FwdIt1, class FwdIt2, class Pred&gt;
    FwdIt1 <a href="ALGORITH_search.htm#search"><b>search</b></a>(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2, Pred pr);
template&lt;class FwdIt, class Dist, class T&gt;
    FwdIt <a href="ALGORITH_search_n.htm#search_n"><b>search_n</b></a>(FwdIt first, FwdIt last,
        Dist n, const T&amp; val);
template&lt;class FwdIt, class Dist, class T, class Pred&gt;
    FwdIt <a href="ALGORITH_search_n.htm#search_n"><b>search_n</b></a>(FwdIt first, FwdIt last,
        Dist n, const T&amp; val, Pred pr);
template&lt;class InIt, class OutIt&gt;
    OutIt <a href="ALGORITH_copy.htm#copy"><b>copy</b></a>(InIt first, InIt last, OutIt x);
template&lt;class BidIt1, class BidIt2&gt;
    BidIt2 <a href="ALGORITH_copy_backward.htm#copy_backward"><b>copy_backward</b></a>(BidIt1 first, BidIt1 last, BidIt2 x);
template&lt;class T&gt;
    void <a href="ALGORITH_swap.htm#swap"><b>swap</b></a>(T&amp; x, T&amp; y);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt2 <a href="ALGORITH_swap_ranges.htm#swap_ranges"><b>swap_ranges</b></a>(FwdIt1 first, FwdIt1 last, FwdIt2 x);
template&lt;class FwdIt1, class FwdIt2&gt;
    void <a href="ALGORITH_iter_swap.htm#iter_swap"><b>iter_swap</b></a>(FwdIt1 x, FwdIt2 y);
template&lt;class InIt, class OutIt, class Unop&gt;
    OutIt <a href="ALGORITH_transform.htm#transform"><b>transform</b></a>(InIt first, InIt last, OutIt x, Unop uop);
template&lt;class InIt1, class InIt2, class OutIt, class Binop&gt;
    OutIt <a href="ALGORITH_transform.htm#transform"><b>transform</b></a>(InIt1 first1, InIt1 last1, InIt2 first2,
        OutIt x, Binop bop);
template&lt;class FwdIt, class T&gt;
    void <a href="ALGORITH_replace.htm#replace"><b>replace</b></a>(FwdIt first, FwdIt last,
        const T&amp; vold, const T&amp; vnew);
template&lt;class FwdIt, class Pred, class T&gt;
    void <a href="ALGORITH_replace_if.htm#replace_if"><b>replace_if</b></a>(FwdIt first, FwdIt last,
        Pred pr, const T&amp; val);
template&lt;class InIt, class OutIt, class T&gt;
    OutIt <a href="ALGORITH_replace_copy.htm#replace_copy"><b>replace_copy</b></a>(InIt first, InIt last, OutIt x,
        const T&amp; vold, const T&amp; vnew);
template&lt;class InIt, class OutIt, class Pred, class T&gt;
    OutIt <a href="ALGORITH_replace_copy_if.htm#replace_copy_if"><b>replace_copy_if</b></a>(InIt first, InIt last, OutIt x,
        Pred pr, const T&amp; val);
template&lt;class FwdIt, class T&gt;
    void <a href="ALGORITH_fill.htm#fill"><b>fill</b></a>(FwdIt first, FwdIt last, const T&amp; x);
template&lt;class OutIt, class Size, class T&gt;
    void <a href="ALGORITH_fill_n.htm#fill_n"><b>fill_n</b></a>(OutIt first, Size n, const T&amp; x);
template&lt;class FwdIt, class Gen&gt;
    void <a href="ALGORITH_generate.htm#generate"><b>generate</b></a>(FwdIt first, FwdIt last, Gen g);
template&lt;class OutIt, class Pred, class Gen&gt;
    void <a href="ALGORITH_generate_n.htm#generate_n"><b>generate_n</b></a>(OutIt first, Dist n, Gen g);
template&lt;class FwdIt, class T&gt;
    FwdIt <a href="ALGORITH_remove.htm#remove"><b>remove</b></a>(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class FwdIt, class Pred&gt;
    FwdIt <a href="ALGORITH_remove_if.htm#remove_if"><b>remove_if</b></a>(FwdIt first, FwdIt last, Pred pr);
template&lt;class InIt, class OutIt, class T&gt;
    OutIt <a href="ALGORITH_remove_copy.htm#remove_copy"><b>remove_copy</b></a>(InIt first, InIt last, OutIt x, const T&amp; val);
template&lt;class InIt, class OutIt, class Pred&gt;
    OutIt <a href="ALGORITH_remove_copy_if.htm#remove_copy_if"><b>remove_copy_if</b></a>(InIt first, InIt last, OutIt x, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt <a href="ALGORITH_unique.htm#unique"><b>unique</b></a>(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt <a href="ALGORITH_unique.htm#unique"><b>unique</b></a>(FwdIt first, FwdIt last, Pred pr);
template&lt;class InIt, class OutIt&gt;
    OutIt <a href="ALGORITH_unique_copy.htm#unique_copy"><b>unique_copy</b></a>(InIt first, InIt last, OutIt x);
template&lt;class InIt, class OutIt, class Pred&gt;
    OutIt <a href="ALGORITH_unique_copy.htm#unique_copy"><b>unique_copy</b></a>(InIt first, InIt last, OutIt x, Pred pr);
template&lt;class BidIt&gt;
    void <a href="ALGORITH_reverse.htm#reverse"><b>reverse</b></a>(BidIt first, BidIt last);
template&lt;class BidIt, class OutIt&gt;
    OutIt <a href="ALGORITH_reverse_copy.htm#reverse_copy"><b>reverse_copy</b></a>(BidIt first, BidIt last, OutIt x);
template&lt;class FwdIt&gt;
    void <a href="ALGORITH_rotate.htm#rotate"><b>rotate</b></a>(FwdIt first, FwdIt middle, FwdIt last);
template&lt;class FwdIt, class OutIt&gt;
    OutIt <a href="ALGORITH_rotate_copy.htm#rotate_copy"><b>rotate_copy</b></a>(FwdIt first, FwdIt middle, FwdIt last, OutIt x);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_random_shuffle.htm#random_shuffle"><b>random_shuffle</b></a>(RanIt first, RanIt last);
template&lt;class RanIt, class Fun&gt;
    void <a href="ALGORITH_random_shuffle.htm#random_shuffle"><b>random_shuffle</b></a>(RanIt first, RanIt last, Fun&amp; f);
template&lt;class BidIt, class Pred&gt;
    BidIt <a href="ALGORITH_partition.htm#partition"><b>partition</b></a>(BidIt first, BidIt last, Pred pr);
template&lt;class FwdIt, class Pred&gt;
    FwdIt <a href="ALGORITH_stable_partition.htm#stable_partition"><b>stable_partition</b></a>(FwdIt first, FwdIt last, Pred pr);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_sort.htm#sort"><b>sort</b></a>(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void <a href="ALGORITH_sort.htm#sort"><b>sort</b></a>(RanIt first, RanIt last, Pred pr);
template&lt;class BidIt&gt;
    void <a href="ALGORITH_stable_sort.htm#stable_sort"><b>stable_sort</b></a>(BidIt first, BidIt last);
template&lt;class BidIt, class Pred&gt;
    void <a href="ALGORITH_stable_sort.htm#stable_sort"><b>stable_sort</b></a>(BidIt first, BidIt last, Pred pr);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_partial_sort.htm#partial_sort"><b>partial_sort</b></a>(RanIt first, RanIt middle, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void <a href="ALGORITH_partial_sort.htm#partial_sort"><b>partial_sort</b></a>(RanIt first, RanIt middle, RanIt last, Pred pr);
template&lt;class InIt, class RanIt&gt;
    RanIt <a href="ALGORITH_partial_sort_copy.htm#partial_sort_copy"><b>partial_sort_copy</b></a>(InIt first1, InIt last1,
        RanIt first2, RanIt last2);
template&lt;class InIt, class RanIt, class Pred&gt;
    RanIt <a href="ALGORITH_partial_sort_copy.htm#partial_sort_copy"><b>partial_sort_copy</b></a>(InIt first1, InIt last1,
        RanIt first2, RanIt last2, Pred pr);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_nth_element.htm#nth_element"><b>nth_element</b></a>(RanIt first, RanIt nth, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void <a href="ALGORITH_nth_element.htm#nth_element"><b>nth_element</b></a>(RanIt first, RanIt nth, RanIt last, Pred pr);
template&lt;class FwdIt, class T&gt;
    FwdIt <a href="ALGORITH_lower_bound.htm#lower_bound"><b>lower_bound</b></a>(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    FwdIt <a href="ALGORITH_lower_bound.htm#lower_bound"><b>lower_bound</b></a>(FwdIt first, FwdIt last, const T&amp; val, Pred pr);
template&lt;class FwdIt, class T&gt;
    FwdIt <a href="ALGORITH_upper_bound.htm#upper_bound"><b>upper_bound</b></a>(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    FwdIt <a href="ALGORITH_upper_bound.htm#upper_bound"><b>upper_bound</b></a>(FwdIt first, FwdIt last, const T&amp; val, Pred pr);
template&lt;class FwdIt, class T&gt;
    pair&lt;FwdIt, FwdIt&gt; <a href="ALGORITH_equal_range.htm#equal_range"><b>equal_range</b></a>(FwdIt first, FwdIt last,
        const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    pair&lt;FwdIt, FwdIt&gt; <a href="ALGORITH_equal_range.htm#equal_range"><b>equal_range</b></a>(FwdIt first, FwdIt last,
        const T&amp; val, Pred pr);
template&lt;class FwdIt, class T&gt;
    bool <a href="ALGORITH_binary_search.htm#binary_search"><b>binary_search</b></a>(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    bool <a href="ALGORITH_binary_search.htm#binary_search"><b>binary_search</b></a>(FwdIt first, FwdIt last, const T&amp; val,
        Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt <a href="ALGORITH_merge.htm#merge"><b>merge</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;
    OutIt <a href="ALGORITH_merge.htm#merge"><b>merge</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class BidIt&gt;
    void <a href="ALGORITH_inplace_merge.htm#inplace_merge"><b>inplace_merge</b></a>(BidIt first, BidIt middle, BidIt last);
template&lt;class BidIt, class Pred&gt;
    void <a href="ALGORITH_inplace_merge.htm#inplace_merge"><b>inplace_merge</b></a>(BidIt first, BidIt middle, BidIt last, Pred pr);
template&lt;class InIt1, class InIt2&gt;
    bool <a href="ALGORITH_includes.htm#includes"><b>includes</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2);
template&lt;class InIt1, class InIt2, class Pred&gt;
    bool <a href="ALGORITH_includes.htm#includes"><b>includes</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt <a href="ALGORITH_set_union.htm#set_union"><b>set_union</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;
    OutIt <a href="ALGORITH_set_union.htm#set_union"><b>set_union</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt <a href="ALGORITH_set_intersection.htm#set_intersection"><b>set_intersection</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;
    OutIt <a href="ALGORITH_set_intersection.htm#set_intersection"><b>set_intersection</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt <a href="ALGORITH_set_difference.htm#set_difference"><b>set_difference</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;
    OutIt <a href="ALGORITH_set_difference.htm#set_difference"><b>set_difference</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt <a href="ALGORITH_set_symmetric_difference.htm#set_symmetric_difference"><b>set_symmetric_difference</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;
    OutIt <a href="ALGORITH_set_symmetric_difference.htm#set_symmetric_difference"><b>set_symmetric_difference</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_push_heap.htm#push_heap"><b>push_heap</b></a>(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void <a href="ALGORITH_push_heap.htm#push_heap"><b>push_heap</b></a>(RanIt first, RanIt last, Pred pr);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_pop_heap.htm#pop_heap"><b>pop_heap</b></a>(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void <a href="ALGORITH_pop_heap.htm#pop_heap"><b>pop_heap</b></a>(RanIt first, RanIt last, Pred pr);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_make_heap.htm#make_heap"><b>make_heap</b></a>(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void <a href="ALGORITH_make_heap.htm#make_heap"><b>make_heap</b></a>(RanIt first, RanIt last, Pred pr);
template&lt;class RanIt&gt;
    void <a href="ALGORITH_sort_heap.htm#sort_heap"><b>sort_heap</b></a>(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void <a href="ALGORITH_sort_heap.htm#sort_heap"><b>sort_heap</b></a>(RanIt first, RanIt last, Pred pr);
template&lt;class T&gt;
    const T&amp; <a href="ALGORITH_max.htm#max"><b>max</b></a>(const T&amp; x, const T&amp; y);
template&lt;class T, class Pred&gt;
    const T&amp; <a href="ALGORITH_max.htm#max"><b>max</b></a>(const T&amp;  x, const T&amp; y, Pred pr);
template&lt;class T&gt;
    const T&amp; <a href="ALGORITH_min.htm#min"><b>min</b></a>(const T&amp; x, const T&amp; y);
template&lt;class T, class Pred&gt;
    const T&amp; <a href="ALGORITH_min.htm#min"><b>min</b></a>(const T&amp; x, const T&amp; y, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt <a href="ALGORITH_max_element.htm#max_element"><b>max_element</b></a>(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt <a href="ALGORITH_max_element.htm#max_element"><b>max_element</b></a>(FwdIt first, FwdIt last, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt <a href="ALGORITH_min_element.htm#min_element"><b>min_element</b></a>(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt <a href="ALGORITH_min_element.htm#min_element"><b>min_element</b></a>(FwdIt first, FwdIt last, Pred pr);
template&lt;class InIt1, class InIt2&gt;
    bool <a href="ALGORITH_lexicographical_compare.htm#lexicographical_compare"><b>lexicographical_compare</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2);
template&lt;class InIt1, class InIt2, class Pred&gt;
    bool <a href="ALGORITH_lexicographical_compare.htm#lexicographical_compare"><b>lexicographical_compare</b></a>(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, Pred pr);
template&lt;class BidIt&gt;
    bool <a href="ALGORITH_next_permutation.htm#next_permutation"><b>next_permutation</b></a>(BidIt first, BidIt last);
template&lt;class BidIt, class Pred&gt;
    bool <a href="ALGORITH_next_permutation.htm#next_permutation"><b>next_permutation</b></a>(BidIt first, BidIt last, Pred pr);
template&lt;class BidIt&gt;
    bool <a href="ALGORITH_prev_permutation.htm#prev_permutation"><b>prev_permutation</b></a>(BidIt first, BidIt last);
template&lt;class BidIt, class Pred&gt;
    bool <a href="ALGORITH_prev_permutation.htm#prev_permutation"><b>prev_permutation</b></a>(BidIt first, BidIt last, Pred pr);
    };</code></pre>
<p>Include the <a href="INDEX_Table_of_Contents.htm#STL">STL</a> standard header <code><b>&lt;algorithm&gt;</b></code> to define numerous template functions that perform useful algorithms.
The descriptions that follow make extensive use of common template parameter names (or prefixes) to indicate the
least powerful category of iterator permitted as an actual argument type:</p>
<ul>
<li><a href="lib_stl_Iterator_Conventions.htm#OutIt"><code><b>OutIt</b></code></a> -- to indicate an output iterator</li>
<li><a href="lib_stl_Iterator_Conventions.htm#InIt"><code><b>InIt</b></code></a> -- to indicate an input iterator</li>
<li><a href="lib_stl_Iterator_Conventions.htm#FwdIt"><code><b>FwdIt</b></code></a> -- to indicate a forward iterator</li>
<li><a href="lib_stl_Iterator_Conventions.htm#BidIt"><code><b>BidIt</b></code></a> -- to indicate a bidirectional iterator</li>
<li><a href="lib_stl_Iterator_Conventions.htm#RanIt"><code><b>RanIt</b></code></a> -- to indicate a random-access iterator</li>
</ul>
<p>The descriptions of these templates employ a number of <a href="lib_stl_Algorithm_Conventions.htm#Algorithm Conventions">conventions</a> common to all algorithms.</p>

</body>
</html>
