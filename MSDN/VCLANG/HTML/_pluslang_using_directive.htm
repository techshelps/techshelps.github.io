<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>using Directive</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_using_directive"></a>using Directive</h1>
<p>
The <i>using-directive</i> allows the names in a <b>namespace</b> to be used without the <i>namespace-name</i> as an explicit qualifier. In contrast to a <b>using</b> declaration, which allows an <i>individual</i> name to be used without qualification, the <b>using</b> directive allows <i>all</i> the names in a namespace to be used without qualification. See <a href="_pluslang_using_declaration.htm">using Declaration</a> for more information. </p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>using-directive</i> :</p>
<p class=indent>
<b>using</b> <b>namespace</b> <b>::</b><sub>opt </sub> <i>nested-name-specifier</i><sub>opt </sub> <i>namespace-name</i></p>
<p>
The intent of the <i>using-directive</i> is to allow unique, descriptive names to be used when declaring functions and variables, without requiring the complete name every time access to the functions or variables is needed. Of course, the complete, qualified name can still be used to retain clarity.</p>
<p>
The unqualified names can be used from the point of the <b>using</b> directive on. If a namespace is extended after a <i>using-directive</i> is given, the additional members of the namespace can be used, without qualification, after the <i>extended-namespace-definition</i>. For example:</p>
<pre><code>namespace M
{
 &nbsp;&nbsp; int i;
}

using namespace M;

namespace N
{
 &nbsp;&nbsp; int j;
 &nbsp;&nbsp; double f() { return M::d; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: M::d does not yet exist
}

namespace M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // namespace extension
{
 &nbsp;&nbsp; double d;
}
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // now M::d can be used
</code></pre>
<p>
It is possible for a <i>using-directive</i> to introduce conflicting names when used in another namespace. For example:</p>
<pre><code>namespace M
{
 &nbsp;&nbsp; int i;
}

namespace N
{
 &nbsp;&nbsp; int i;
 &nbsp;&nbsp; using namespace M;&nbsp;&nbsp;&nbsp; // no error here
}
 &nbsp;&nbsp; .
 &nbsp;&nbsp; .
 &nbsp;&nbsp; .
void f()
{
 &nbsp;&nbsp; using namespace N;
 &nbsp;&nbsp; i = 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: ambiguous: M::i or N::i?
}
</code></pre>
<p>
In this example, bringing <code>M::i</code> into <code>namespace N</code> does not hide the declaration of <code>N::i</code>, but instead creates an ambiguity when <code>N::i</code> is used. In this manner, the <i>using-directive</i> can easily introduce unintended ambiguities. Consider the following code fragment:</p>
<pre><code>namespace D
{
 &nbsp;&nbsp; int d1;
 &nbsp;&nbsp; void f(int);
 &nbsp;&nbsp; void f(char);
}

using namespace D;

int d1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no conflict with D::d1

namespace E
{
 &nbsp;&nbsp; int e;
 &nbsp;&nbsp; void f(int);
}

namespace D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // namespace extension
{
 &nbsp;&nbsp; int d2;
 &nbsp;&nbsp; using namespace E;
 &nbsp;&nbsp; void f(int);
}

void f()
{
 &nbsp;&nbsp; d1++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: ambiguous: ::d1 or D::d1?
 &nbsp;&nbsp; ::d1++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok
 &nbsp;&nbsp; D::d1++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok
 &nbsp;&nbsp; d2++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok: D::d2
 &nbsp;&nbsp; e++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok: E::e
 &nbsp;&nbsp; f(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: ambiguous: D::f(int) or E::f(int)?
 &nbsp;&nbsp; f('a');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok D::f(char)
}
</code></pre>
<p>
When a variable is referenced after a <i>using-directive</i>, the local variable of the same name takes precedence over the one declared in the specified namespace. For example:</p>
<pre><code>namespace N {
   int data = 4;
}

void f(bool flag) {
   int data = 0;

   if (flag) {
      using namespace N;
   
      prinf(“data=%d\n”, data);
   }
}

void main() {
   f(true);
}
</code></pre>
<p>
In the above code, the variable <code>data</code> referenced in the <b>printf</b> statement is the local variable initialized to 0, instead of the variable initialized in namespace N. The output is <code>data=0</code> instead of <code>data=4</code>.</p>
<p>
In the presence of namespace <i>using-directives</i>, the way qualified names are looked up is shown in the following example:</p>
<pre><code>namespace A {
   int flag = 0;
}

namespace B {
   using namespace A;
}

namespace C {
   using namespace A;
   using namespace B;
}

void main() {
   printf(“C::flag = %d\n”, C::flag);
}
</code></pre>
<p>
The qualified name (<code>C::flag</code>) is resolved to (<code>A::flag</code>) due to the namespace <i>using-directives</i> in namespace C.</p>
</font></BODY>
</HTML>
