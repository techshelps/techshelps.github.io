<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Output File Stream Member Functions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_iostream_output_file_stream_member_functions"></a><sup></sup>Output File Stream Member Functions</h1>
<p>
Output stream member functions have three types: those that are equivalent to manipulators, those that perform unformatted write operations, and those that otherwise modify the stream state and have no equivalent manipulator or insertion operator. For sequential, formatted output, you might use only insertion operators and manipulators. For random-access binary disk output, you use other member functions, with or without insertion operators.</p>

<h2><a name="_iostream_the_open_function_for_output_streams"></a><sup></sup>The open Function for Output Streams</h2>
<p>
To use an output file stream (<a href="_iostream_ofstream.htm">ofstream</a>), you must associate that stream with a specific disk file in the constructor or the <b>open</b> function. If you use the <b>open</b> function, you can reuse the same stream object with a series of files. In either case, the arguments describing the file are the same.</p>
<p>
When you open the file associated with an output stream, you generally specify an <b>open_mode</b> flag. You can combine these flags, which are defined as enumerators in the <b>ios</b> class, with the bitwise OR ( <b>|</b> ) operator.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Flag</b></td>
<td class=label width=76%><b>Function</b></td>
</tr>
<tr valign=top>
<td width=24%><b>ios::app</b></td>
<td width=76%>Opens an output file for appending.</td>
</tr>
<tr valign=top>
<td width=24%><b>ios::ate</b></td>
<td width=76%>Opens an existing file (either input or output) and seeks the end. </td>
</tr>
<tr valign=top>
<td width=24%><b>ios::in</b></td>
<td width=76%>Opens an input file. Use <b>ios::in</b> as an <b>open_mode</b> for an <b>ofstream</b> file to prevent truncating an existing file. </td>
</tr>
<tr valign=top>
<td width=24%><b>ios::out</b></td>
<td width=76%>Opens an output file. When you use <b>ios::out</b> for an <b>ofstream</b> object without <b>ios::app</b>, <b>ios::ate</b>, or <b>ios::in</b>, <b>ios::trunc</b> is implied.</td>
</tr>
<tr valign=top>
<td width=24%><b>ios::nocreate</b></td>
<td width=76%>Opens a file only if it already exists; otherwise the operation fails.</td>
</tr>
<tr valign=top>
<td width=24%><b>ios::noreplace</b></td>
<td width=76%>Opens a file only if it does not exist; otherwise the operation fails.</td>
</tr>
<tr valign=top>
<td width=24%><b>ios::trunc</b></td>
<td width=76%>Opens a file and deletes the old file (if it already exists).</td>
</tr>
<tr valign=top>
<td width=24%><b>ios::binary</b></td>
<td width=76%>Opens a file in binary mode (default is text mode).</td>
</tr>
</table><br>
<p>
Three common output stream situations involve mode options:
<ul type=disc>
<li>
Creating a file. If the file already exists, the old version is deleted.<pre><code>ostream ofile( "FILENAME" );&nbsp; // Default is ios::out
ofstream ofile( "FILENAME", ios::out ); // Equivalent to above
</code></pre>
</li>
<li>
Appending records to an existing file or creating one if it does not exist.<pre><code>ofstream ofile( "FILENAME", ios::app );
</code></pre>
</li>
<li>
Opening two files, one at a time, on the same stream.<pre><code>ofstream ofile();
ofile.open( "FILE1", ios::in );
// Do some output
ofile.close(); // FILE1 closed
ofile.open( "FILE2", ios::in );
// Do some more output
ofile.close(); // FILE2 closed
// When ofile goes out of scope it is destroyed.
</code></pre>
</li>
</ul>

<h2><a name="_iostream_the_put_function"></a><sup></sup>The put Function</h2>
<p>
The <b>put</b> function writes one character to the output stream. The following two statements are the same by default, but the second is affected by the stream’s format arguments:</p>
<pre><code>cout.put( 'A' ); // Exactly one character written
cout &lt;&lt; 'A'; // Format arguments 'width' and 'fill' apply 
</code></pre>

<h2><a name="_iostream_the_write_function"></a><sup></sup>The write Function</h2>
<p>
The <b>write</b> function writes a block of memory to an output file stream. The length argument specifies the number of bytes written. This example creates an output file stream and writes the binary value of the <code>Date</code> structure to it: </p>
<pre><code>#include &lt;fstream.h&gt;

struct Date
{
 &nbsp; int mo, da, yr;
};

void main()
{
 &nbsp; Date dt = { 6, 10, 92 };
 &nbsp; ofstream tfile( "date.dat" , ios::binary );
 &nbsp; tfile.write( (char *) &amp;dt, sizeof dt );
}
</code></pre>
<p>
The <b>write</b> function does not stop when it reaches a null character, so the complete class structure is written. The function takes two arguments: a <b>char</b> pointer and a count of characters to write. Note the required cast to <b>char*</b> before the address of the structure object. </p>

<h2><a name="_iostream_the_seekp_and_tellp_functions"></a><sup></sup>The seekp and tellp Functions</h2>
<p>
An output file stream keeps an internal pointer that points to the position where data is to be written next. The <b>seekp</b> member function sets this pointer and thus provides random-access disk file output. The <b>tellp</b> member function returns the file position. For examples that use the input stream equivalants to <b>seekp</b> and <b>tellp</b>, see <a href="_iostream_input_stream_member_functions.htm#_iostream_the_seekg_and_tellg_functions">The seekg and tellg Functions</a>.</p>

<h2><a name="_iostream_the_close_function_for_output_streams"></a><sup></sup>The close Function for Output Streams</h2>
<p>
The <b>close</b> member function closes the disk file associated with an output file stream. The file must be closed to complete all disk output. If necessary, the <b>ofstream</b> destructor closes the file for you, but you can use the <b>close</b> function if you need to open another file for the same stream object.</p>
<p>
The output stream destructor automatically closes a stream’s file only if the constructor or the <b>open</b> member function opened the file. If you pass the constructor a file descriptor for an already-open file or use the <b>attach</b> member function, you must close the file explicitly.</p>

<h2><a name="_iostream_error_processing_functions"></a><sup></sup>Error Processing Functions</h2>
<p>
Use these member functions to test for errors while writing to a stream:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b>Function</b></td>
<td class=label width=82%><b>Return value</b></td>
</tr>
<tr valign=top>
<td width=18%><b>bad</b></td>
<td width=82%>Returns <b>TRUE</b> if there is an unrecoverable error.</td>
</tr>
<tr valign=top>
<td width=18%><b>fail</b></td>
<td width=82%>Returns <b>TRUE</b> if there is an unrecoverable error or an “expected” condition, such as a conversion error, or if the file is not found. Processing can often resume after a call to <b>clear</b> with a zero argument. </td>
</tr>
<tr valign=top>
<td width=18%><b>good</b></td>
<td width=82%>Returns <b>TRUE</b> if there is no error condition (unrecoverable or otherwise) and the end-of-file flag is not set.</td>
</tr>
<tr valign=top>
<td width=18%><b>eof</b></td>
<td width=82%>Returns <b>TRUE</b> on the end-of-file condition.</td>
</tr>
<tr valign=top>
<td width=18%><b>clear</b></td>
<td width=82%>Sets the internal error state. If called with the default arguments, it clears all error bits.</td>
</tr>
<tr valign=top>
<td width=18%><b>rdstate</b></td>
<td width=82%>Returns the current error state. For a complete description of error bits, see the <i>Class Library Reference</i>.</td>
</tr>
</table><br>
<p>
The <b>!</b> operator is overloaded to perform the same function as the <b>fail</b> function. Thus the expression</p>
<pre><code>if( !cout)...
</code></pre>
<p>
is equivalent to</p>
<pre><code>if( cout.fail() )...
</code></pre>
<p>
The <b>void*()</b> operator is overloaded to be the opposite of the <b>!</b> operator; thus the expression</p>
<pre><code>if( cout)...
</code></pre>
<p>
is equal to</p>
<pre><code>if( !cout.fail() )...
</code></pre>
<p>
The <b>void*()</b> operator is not equivalent to <b>good</b> because it doesn’t test for the end of file.</p>
</font></BODY>
</HTML>
