<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reference-Type Function Returns</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_reference.2d.type_function_returns"></a><sup></sup>Reference-Type Function Returns</h1>
<p>
Functions can be declared to return a reference type. There are two reasons to make such a declaration:
<ul type=disc>
<li>
The information being returned is a large enough object that returning a reference is more efficient than returning a copy.<br><br></li>
<li>
The type of the function must be an l-value.</li>
</ul>
<p>
Just as it can be more efficient to pass large objects <i>to</i> functions by reference, it also can be more efficient to return large objects <i>from</i> functions by reference. Reference-return protocol eliminates the necessity of copying the object to a temporary location prior to returning.</p>
<p>
Reference-return types can also be useful when the function must evaluate to an l-value. Most overloaded operators fall into this category, particularly the assignment operator. Overloaded operators are covered in <a href="_pluslang_overloaded_operators.htm">Overloaded Operators</a> in Chapter 12. Consider the <code>Point</code> example from Chapter 4:</p>
<pre><code>class Point
{
public:
 &nbsp;&nbsp; // Define "accessor" functions as
 &nbsp;&nbsp; //&nbsp; reference types.
 &nbsp;&nbsp; unsigned&amp; x();
 &nbsp;&nbsp; unsigned&amp; y();
private:
 &nbsp;&nbsp; unsigned obj_x;
 &nbsp;&nbsp; unsigned obj_y;
};

unsigned&amp; Point :: x()
{
 &nbsp;&nbsp; return obj_x;
}
unsigned&amp; Point :: y()
{
 &nbsp;&nbsp; return obj_y;
}

void main()
{
 &nbsp;&nbsp; Point ThePoint;

 &nbsp;&nbsp; // Use x() and y() as l-values.
 &nbsp;&nbsp; ThePoint.x() = 7;
 &nbsp;&nbsp; ThePoint.y() = 9;

 &nbsp;&nbsp; // Use x() and y() as r-values.
 &nbsp;&nbsp; cout &lt;&lt; "x = " &lt;&lt; ThePoint.x() &lt;&lt; "\n"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "y = " &lt;&lt; ThePoint.y() &lt;&lt; "\n";
}
</code></pre>
<p>
Notice that the functions <code>x</code> and <code>y</code> are declared as returning reference types. These functions can be used on either side of an assignment statement.</p>
<p>
Declarations of reference types must contain initializers except in the following cases:
<ul type=disc>
<li>
Explicit <b>extern</b> declaration<br><br></li>
<li>
Declaration of a class member<br><br></li>
<li>
Declaration within a class<br><br></li>
<li>
Declaration of an argument to a function or the return type for a function</li>
</ul>
</font></BODY>
</HTML>
