<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Shift Operators</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_shift_operators"></a><sup></sup>Shift Operators</h1>
<p>
The bitwise shift operators are:
<ul type=disc>
<li>
Right shift (&gt;&gt;)<br><br></li>
<li>
Left shift (&lt;&lt;)</li>
</ul>
<p>
These binary operators have left-to-right associativity.</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>shift-expression</i> :</p>
<p class=indent>
<i>additive-expression</i><br>
<i>shift-expression</i> &lt;&lt; <i>additive-expression</i><br>
<i>shift-expression</i> &gt;&gt; <i>additive-expression</i></p>
<p>
Both operands of the shift operators must be of integral types. Integral promotions are performed according to the rules described in <a href="_pluslang_integral_promotions.htm">Integral Promotions</a> in Chapter 3. The type of the result is the same as the type of the left operand. The value of a right-shift expression <i>e1</i> &gt;&gt; <i>e2</i> is <i>e1</i> / 2<sup>e2</sup>, and the value of a left-shift expression <i>e1</i> &lt;&lt; <i>e2</i> is <i>e1</i> * 2<sup>e2</sup>.</p>
<p>
The results are undefined if the right operand of a shift expression is negative or if the right operand is greater than or equal to the number of bits in the (promoted) left operand.</p>
<p>
The left-shift operator causes the bit pattern in the first operand to be shifted left the number of bits specified by the second operand. Bits vacated by the shift operation are zero-filled. This is a logical shift, as opposed to a shift-and-rotate operation.</p>
<p>
The right-shift operator causes the bit pattern in the first operand to be shifted right the number of bits specified by the second operand. Bits vacated by the shift operation are zero-filled for unsigned quantities. For signed quantities, the sign bit is propagated into the vacated bit positions. The shift is a logical shift if the left operand is an unsigned quantity; otherwise, it is an arithmetic shift.</p>
<p>
<b>Microsoft Specific </b></p>
<p>
The result of a right shift of a signed negative quantity is implementation dependent. Although Microsoft C++ propagates the most-significant bit to fill vacated bit positions, there is no guarantee that other implementations will do likewise.</p>
<p>
<b>END Microsoft Specific</b></p>
</font></BODY>
</HTML>
