<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Function Overloading</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_function_overloading"></a><sup></sup>Function Overloading</h1>
<p>
C++ allows specification of more than one function of the same name in the same scope. These are called “overloaded functions” and are described in detail in Chapter 12, Overloading. Overloaded functions enable programmers to supply different semantics for a function, depending on the types and number of arguments.</p>
<p>
For example, a <b>print</b> function that takes a string (or <b>char *</b>) argument performs very different tasks than one that takes an argument of type <b>double</b>. Overloading permits uniform naming and prevents programmers from having to invent names such as <code>print_sz</code> or <code>print_d</code>. Table 7.3 shows what parts of a function declaration C++ uses to differentiate between groups of functions with the same name in the same scope.</p>
<p class=label>
<b><a name="_pluslang_table_7..1"></a>Table 7.3&nbsp;&nbsp;&nbsp;Overloading Considerations</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Function Declaration Element</b></td>
<td class=label width=50%><b>Used for Overloading?</b></td>
</tr>
<tr valign=top>
<td width=50%>Function return type</td>
<td width=50%>No</td>
</tr>
<tr valign=top>
<td width=50%>Number of arguments</td>
<td width=50%>Yes</td>
</tr>
<tr valign=top>
<td width=50%>Type of arguments</td>
<td width=50%>Yes</td>
</tr>
<tr valign=top>
<td width=50%>Presence or absence of ellipsis</td>
<td width=50%>Yes</td>
</tr>
<tr valign=top>
<td width=50%>Use of <b>typedef</b> names</td>
<td width=50%>No</td>
</tr>
<tr valign=top>
<td width=50%>Unspecified array bounds</td>
<td width=50%>No</td>
</tr>
<tr valign=top>
<td width=50%><b>const</b> or <b>volatile</b> (in <i>cv-mod-list</i>)</td>
<td width=50%>Yes</td>
</tr>
</table><br>
<p>
Although functions can be distinguished on the basis of return type, they cannot be overloaded on this basis.</p>
<p>
The following example illustrates how overloading can be used. Another way to solve the same problem is presented in <a href="_pluslang_default_arguments.htm">Default Arguments</a>.</p>
<pre><code>#include &lt;iostream.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

// Prototype three print functions.
int print( char *s );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Print a string.
int print( double dvalue );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Print a double.
int print( double dvalue, int prec );&nbsp; // Print a double with a
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; given precision.
void main( int argc, char *argv[] )
{
 &nbsp;&nbsp; const double d = 893094.2987;

 &nbsp;&nbsp; if( argc &lt; 2 )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // These calls to print invoke print( char *s ).
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print( "This program requires one argument." );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print( "The argument specifies the number of" );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print( "digits precision for the second number" );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print( "printed." );
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Invoke print( double dvalue ).
 &nbsp;&nbsp; print( d );

 &nbsp;&nbsp; // Invoke print( double dvalue, int prec ).
 &nbsp;&nbsp; print( d, atoi( argv[1] ) );
}

// Print a string.
int print( char *s )
{
 &nbsp;&nbsp; cout &lt;&lt; s &lt;&lt; endl;
 &nbsp;&nbsp; return cout.good();
}

// Print a double in default precision.
int print( double dvalue )
{
 &nbsp;&nbsp; cout &lt;&lt; dvalue &lt;&lt; endl;
 &nbsp;&nbsp; return cout.good();
}

// Print a double in specified precision.
//&nbsp; Positive numbers for precision indicate how many digits'
//&nbsp; precision after the decimal point to show. Negative
//&nbsp; numbers for precision indicate where to round the number
//&nbsp; to the left of the decimal point.
int print( double dvalue, int prec )
{
 &nbsp;&nbsp; // Use table-lookup for rounding/truncation.
 &nbsp;&nbsp; static const double rgPow10[] = { 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10E-7, 10E-6, 10E-5, 10E-4, 10E-3, 10E-2, 10E-1, 10E0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10E1,&nbsp; 10E2,&nbsp; 10E3,&nbsp; 10E4, 10E5,&nbsp; 10E6
 &nbsp;&nbsp; };
 &nbsp;&nbsp; const int iPowZero = 6;

 &nbsp;&nbsp; // If precision out of range, just print the number.
 &nbsp;&nbsp; if( prec &lt; -6 || prec &gt; 7 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return print( dvalue );

 &nbsp;&nbsp; // Scale, truncate, then rescale.
 &nbsp;&nbsp; dvalue = floor( dvalue / rgPow10[iPowZero - prec] ) *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgPow10[iPowZero - prec];

 &nbsp;&nbsp; cout &lt;&lt; dvalue &lt;&lt; endl;
 &nbsp;&nbsp; return cout.good();
}
</code></pre>
<p>
The preceding code shows overloading of the <code>print</code> function in file scope.</p>
<p>
For restrictions on overloading and information on how overloading affects other elements of C++, see Chapter 12, <a href="_pluslang_overloading.htm">Overloading</a>. </p>
</font></BODY>
</HTML>
