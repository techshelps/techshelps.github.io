<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Template Specifications</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_template_specifications"></a>Template Specifications</h1>
<p>
The <b>template</b> declaration specifies a set of parameterized classes or functions.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For more information, see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_core_Template_Topics">
</object><a href=JavaScript:alink_1.Click()>Template Topics</a> in <i>Visual C++ Programmer’s Guides</i>.</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>template-declaration</i> :</p>
<p class=indent>
<b>template</b> <b>&lt;</b> <i>template-argument-list</i>  <b>&gt;</b> <i>declaration</i></p>
<p class=dt>
<i>template-argument-list</i> :</p>
<p class=indent>
<i>template-argument</i><br>
<i>template</i>-<i>argument-list </i><b>,</b> <i>template-argument</i></p>
<p class=dt>
<i>template-argument</i> :</p>
<p class=indent>
<i>type-argument</i><br>
<i>argument-declaration</i></p>
<p class=dt>
<i>type-argument</i> :</p>
<p class=indent>
<b>class</b> <i>identifier<br>
</i><b>typename</b><i> identifier</i></p>
<p>
The <i>declaration</i> declares a function or a class. With function templates, each <i>template-argument</i> must appear at least once in the <i>template-argument-list</i> of the function being declared.</p>
<p>
The <i>template-argument-list</i> is a list of arguments used by the template function that specifies which parts of the following code will vary. For example:</p>
<pre><code>template&lt; class T, int i &gt; class MyStack...
</code></pre>
<p>
In this case the template can receive a type (<code>class T</code>) and a constant parameter (<code>int I</code>). The template will use type <code>T</code> and the constant integer <code>i</code> upon construction. Within the body of the <code>MyStack</code> declaration, you must refer to the <code>T</code> identifier.</p>
<p>
The <b>typename</b> keyword can be used in the <i>template-argument-list</i>. The following template declarations are identical:</p>
<pre><code>template&lt; class T1, class T2 &gt; class X...
template&lt; typename T1, typename T2 &gt; class X...
</code></pre>
<p>
Template arguments of the following form are allowed:</p>
<pre><code>template&lt;typename Type&gt; class allocator {};
template&lt;typename Type, 
   typename Allocator = allocator&lt;Type&gt; &gt; class stack {
};
stack&lt;int&gt; MyStack;
</code></pre>
<p>
Visual C++ supports the reuse of template parameters in the template parameter list. For example, the following code is now legal:</p>
<pre><code>class Y {...};
template&lt;class T, T* pT&gt; class X1 {...};
template&lt;class T1, class T2 = T1&gt; class X2 {...};

Y aY;

X1&lt;Y, &amp;aY&gt; x1;
X2&lt;int&gt; x2;
</code></pre>
<p>
A template declaration itself does not generate code; it specifies a family of classes or functions, one or more of which will be generated when referenced by other code. </p>
<p>
Template declarations have global or namespace scope.</p>
<p>
Visual C++ performs syntax checking of template definitions. This version of Visual C++ can detect errors that previous versions cannot. The compiler can now detect syntax errors of templates that are defined but never instantiated. </p>
<p>
Here is a list of common errors which could compile with the Visual C++ 4.0 compiler, but not the Visual C++ 5.0 or later compiler:
<ul type=disc>
<li>
A user-defined type is used in a template declaration before it is declared, but it is declared before the first instantiation or use of the template. For example:<br>
<br>
<code>template&lt;class T&gt; class X {<br>
//...<br>
Data m_data;//Error Visual C++ 5.0 or later, Data not defined<br>
};<br>
<br>
class Data {...};<br>
<br>
void g() { X&lt;int&gt; x1; }<br>
<br>
</code>Move the declaration of <code>Data</code> before the class template <code>X</code> to fix this problem.<br><br></li>
<li>
A member function is declared outside a class template, whereas it is never declared inside the class. For example:<br>
<br>
<code>template&lt;class T&gt; class X {<br>
//no mf declared here<br>
};<br>
<br>
//This definition did not cause an error with Visual <br>
//C++ 4.0, but it will cause an error with Visual <br>
//C++ 5.0 or later<br>
//<br>
template&lt;class T&gt; void X&lt;T&gt;::mf() {...};</code><br><br></li>
<li>
A class identifier is considered to be a normal class unless declared to be a class template. For example, the following code generates an error with Visual C++ 5.0 or later but not with Visual C++ 4.0:<br>
<br>
<code>template&lt;class T&gt; class X {<br>
friend class Y&lt;T&gt;;//Parsed as Y ‘less-than’<br>
//T ‘greater-than’;<br>
Z&lt;T&gt; mf( );//Parsed as Z ‘less-than’ T <br>
//‘greater-than’;<br>
};<br>
<br>
template&lt;class T&gt; class Y {...};<br>
template&lt;class T&gt; class Z {...};<br>
<br>
X&lt;int&gt; x;<br>
</code><br>
To fix the problem, forward declare <code>Y</code> and <code>Z</code> before the definition of <code>X</code>.<br>
<br>
<code>template&lt;class T&gt; class Y {...};<br>
template&lt;class T&gt; class Z {...};<br>
<br>
template&lt;class T&gt; class X {...};</code></li>
</ul>
</font></BODY>
</HTML>
