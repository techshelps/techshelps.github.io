</html>
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<html>

<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>&lt;functional&gt;</title>
<meta name="GENERATOR" content="Microsoft FrontPage 1.1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
</head>

<body bgcolor=white>

<h1><a name="&lt;functional&gt;">&lt;functional&gt;</a></h1>
<META NAME="MS-HKWD" CONTENT="functional header file">
<p><a href="FUNCTIO2_binary_function.htm#binary_function"><code><b>binary_function</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_binary_negate.htm#binary_negate"><code><b>binary_negate</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_binder1st.htm#binder1st"><code><b>binder1st</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_binder2nd.htm#binder2nd"><code><b>binder2nd</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_divides.htm#divides"><code><b>divides</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_equal_to.htm#equal_to"><code><b>equal_to</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_greater.htm#greater"><code><b>greater</b></code></a><code><b> &#183; 
</b></code><a href="FUNCTIO2_greater_equal.htm#greater_equal"><code><b>greater_equal</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_less.htm#less"><code><b>less</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_less_equal.htm#less_equal"><code><b>less_equal</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_logical_and.htm#logical_and"><code><b>logical_and</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_logical_not.htm#logical_not"><code><b>logical_not</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_logical_or.htm#logical_or"><code><b>logical_or</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_mem_fun_t.htm#mem_fun_t"><code><b>mem_fun_t</b></code></a><code><b> &#183; 
</b></code><a href="FUNCTIO2_mem_fun_ref_t.htm#mem_fun_ref_t"><code><b>mem_fun_ref_t</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_mem_fun1_t.htm#mem_fun1_t"><code><b>mem_fun1</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_mem_fun1_ref_t.htm#mem_fun1_ref_t"><code><b>mem_fun1_ref_t</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_minus.htm#minus"><code><b>minus</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_modulus.htm#modulus"><code><b>modulus</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_multiplies.htm#multiplies"><code><b>multiplies</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_negate.htm#negate"><code><b>negate</b></code></a><code><b> &#183; 
</b></code><a href="FUNCTIO2_not_equal_to.htm#not_equal_to"><code><b>not_equal_to</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_plus.htm#plus"><code><b>plus</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_pointer_to_binary_function.htm#pointer_to_binary_function"><code><b>pointer_to_binary_function</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_pointer_to_unary_function.htm#pointer_to_unary_function"><code><b>pointer_to_unary_function</b></code></a><code><b> &#183; 
</b></code><a href="FUNCTIO2_unary_function.htm#unary_function"><code><b>unary_function</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_unary_negate.htm#unary_negate"><code><b>unary_negate</b></code></a><code><b> </b></code></p>
<p><a href="FUNCTIO2_bind1st.htm#bind1st"><code><b>bind1st</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_bind2nd.htm#bind2nd"><code><b>bind2nd</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_mem_fun.htm#mem_fun"><code><b>mem_fun</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_mem_fun_ref.htm#mem_fun_ref"><code><b>mem_fun_ref</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_mem_fun1.htm#mem_fun1"><code><b>mem_fun1</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_mem_fun1_ref.htm#mem_fun1_ref"><code><b>mem_fun1_ref</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_not1.htm#not1"><code><b>not1</b></code></a><code><b> &#183; </b></code><a href="FUNCTIO2_not2.htm#not2"><code><b>not2</b></code></a><code><b> &#183; 
</b></code><a href="FUNCTIO2_ptr_fun.htm#ptr_fun"><code><b>ptr_fun</b></code></a><code><b> </b></code></p>
<pre><code>namespace std {
//  <b>TEMPLATE CLASSES</b>
template&lt;class Arg, class Result&gt;
    struct <a href="FUNCTIO2_unary_function.htm#unary_function"><b>unary_function</b></a>;
template&lt;class Arg1, class Arg2, class Result&gt;
    struct <a href="FUNCTIO2_binary_function.htm#binary_function"><b>binary_function</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_plus.htm#plus"><b>plus</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_minus.htm#minus"><b>minus</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_multiplies.htm#multiplies"><b>multiplies</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_divides.htm#divides"><b>divides</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_modulus.htm#modulus"><b>modulus</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_negate.htm#negate"><b>negate</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_equal_to.htm#equal_to"><b>equal_to</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_not_equal_to.htm#not_equal_to"><b>not_equal_to</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_greater.htm#greater"><b>greater</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_less.htm#less"><b>less</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_greater_equal.htm#greater_equal"><b>greater_equal</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_less_equal.htm#less_equal"><b>less_equal</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_logical_and.htm#logical_and"><b>logical_and</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_logical_or.htm#logical_or"><b>logical_or</b></a>;
template&lt;class T&gt;
    struct <a href="FUNCTIO2_logical_not.htm#logical_not"><b>logical_not</b></a>;
template&lt;class Pred&gt;
    struct <a href="FUNCTIO2_unary_negate.htm#unary_negate"><b>unary_negate</b></a>;
template&lt;class Pred&gt;
    struct <a href="FUNCTIO2_binary_negate.htm#binary_negate"><b>binary_negate</b></a>;
template&lt;class Pred&gt;
    class <a href="FUNCTIO2_binder1st.htm#binder1st"><b>binder1st</b></a>;
template&lt;class Pred&gt;
    class <a href="FUNCTIO2_binder2nd.htm#binder2nd"><b>binder2nd</b></a>;
template&lt;class Arg, class Result&gt;
    class <a href="FUNCTIO2_pointer_to_unary_function.htm#pointer_to_unary_function"><b>pointer_to_unary_function</b></a>;
template&lt;class Arg1, class Arg2, class Result&gt;
    class <a href="FUNCTIO2_pointer_to_binary_function.htm#pointer_to_binary_function"><b>pointer_to_binary_function</b></a>;
template&lt;class R, class T&gt;
    struct <a href="FUNCTIO2_mem_fun_t.htm#mem_fun_t"><b>mem_fun_t</b></a>;
template&lt;class R, class T, class A&gt;
    struct <a href="FUNCTIO2_mem_fun1_t.htm#mem_fun1_t"><b>mem_fun1_t</b></a>;
template&lt;class R, class T&gt;
    struct <a href="FUNCTIO2_mem_fun_ref_t.htm#mem_fun_ref_t"><b>mem_fun_ref_t</b></a>;
template&lt;class R, class T, class A&gt;
    struct <a href="FUNCTIO2_mem_fun1_ref_t.htm#mem_fun1_ref_t"><b>mem_fun1_ref_t</b></a>;
//  <b>TEMPLATE FUNCTIONS</b>
template&lt;class Pred&gt;
    unary_negate&lt;Pred&gt; <a href="FUNCTIO2_not1.htm#not1"><b>not1</b></a>(const Pred&amp; pr);
template&lt;class Pred&gt;
    binary_negate&lt;Pred&gt; <a href="FUNCTIO2_not2.htm#not2"><b>not2</b></a>(const Pred&amp; pr);
template&lt;class Pred, class T&gt;
    binder1st&lt;Pred&gt; <a href="FUNCTIO2_bind1st.htm#bind1st"><b>bind1st</b></a>(const Pred&amp; pr, const T&amp; x);
template&lt;class Pred, class T&gt;
    binder2nd&lt;Pred&gt; <a href="FUNCTIO2_bind2nd.htm#bind2nd"><b>bind2nd</b></a>(const Pred&amp; pr, const T&amp; x);
template&lt;class Arg, class Result&gt;
    pointer_to_unary_function&lt;Arg, Result&gt;
        <a href="FUNCTIO2_ptr_fun.htm#ptr_fun"><b>ptr_fun</b></a>(Result (*)(Arg));
template&lt;class Arg1, class Arg2, class Result&gt;
    pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;
        <a href="FUNCTIO2_ptr_fun.htm#ptr_fun"><b>ptr_fun</b></a>(Result (*)(Arg1, Arg2));
template&lt;class R, class T&gt;
    mem_fun_t&lt;R, T&gt; <a href="FUNCTIO2_mem_fun.htm#mem_fun"><b>mem_fun</b></a>(R (T::*pm)());
template&lt;class R, class T, class A&gt;
    mem_fun1_t&lt;R, T, A&gt; <a href="FUNCTIO2_mem_fun1.htm#mem_fun1"><b>mem_fun1</b></a>(R (T::*pm)(A arg));
template&lt;class R, class T&gt;
    mem_fun_ref_t&lt;R, T&gt; <a href="FUNCTIO2_mem_fun_ref.htm#mem_fun_ref"><b>mem_fun_ref</b></a>(R (T::*pm)());
template&lt;class R, class T, class A&gt;
    mem_fun1_ref_t&lt;R, T, A&gt; <a href="FUNCTIO2_mem_fun1_ref.htm#mem_fun1_ref"><b>mem_fun1_ref</b></a>(R (T::*pm)(A arg));
    };</code></pre>
<p>Include the <a href="INDEX_Table_of_Contents.htm#STL">STL</a> standard header <code><b>&lt;functional&gt;</b></code> to define several templates that help construct <a name="function objects"><b>function objects</b></a>, 
objects of a class that defines <code>operator()</code>. Hence, function objects behave much like function pointers, except that 
the object can store additional information that can be used during a function call.</p>

</body>
</html>
