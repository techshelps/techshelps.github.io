<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Static Data Members</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_static_data_members"></a><sup></sup>Static Data Members</h1>
<p>
Classes can contain static member data and member functions. When a data member is declared as <b>static</b>, only one copy of the data is maintained for all objects of the class. (For more information, see <a href="_pluslang_static_member_functions.htm">Static Member Functions</a>.)</p>
<p>
Static data members are not part of objects of a given class type; they are separate objects. As a result, the declaration of a static data member is not considered a definition. The data member is declared in class scope, but definition is performed at file scope. These static members have external linkage. The following example illustrates this:</p>
<pre><code>class BufferedOutput
{
public:
 &nbsp;&nbsp; // Return number of bytes written by any object of this class.
 &nbsp;&nbsp; short BytesWritten() { return bytecount; }

 &nbsp;&nbsp; // Reset the counter.
 &nbsp;&nbsp; static void ResetCount() { bytecount = 0; }

 &nbsp;&nbsp; // Static member declaration.
 &nbsp;&nbsp; static long bytecount;
};

// Define bytecount in file scope.
long BufferedOutput::bytecount;
</code></pre>
<p>
In the preceding code, the member <code>bytecount</code> is declared in class <code>BufferedOutput</code>, but it must be defined outside the class declaration.</p>
<p>
Static data members can be referred to without referring to an object of class type. The number of bytes written using <code>BufferedOutput</code> objects can be obtained as follows:</p>
<pre><code>long nBytes = BufferedOutput::bytecount;
</code></pre>
<p>
For the static member to exist, it is not necessary that any objects of the class type exist. Static members can also be accessed using the member-selection (<b>.</b> and <b>–&gt;</b>) operators. For example:</p>
<pre><code>BufferedOutput Console;

long nBytes = Console.bytecount;
</code></pre>
<p>
In the preceding case, the reference to the object (<code>Console</code>) is not evaluated; the value returned is that of the static object <code>bytecount</code>.</p>
<p>
Static data members are subject to class-member access rules, so private access to static data members is allowed only for class-member functions and friends. These rules are described in Chapter 10, <a href="_pluslang_member.2d.access_control.htm">Member-Access Control</a>. The exception is that static data members must be defined in file scope regardless of their access restrictions. If the data member is to be explicitly initialized, an initializer must be provided with the definition.</p>
<p>
The type of a static member is not qualified by its class name. Therefore, the type of <code>BufferedOutput::bytecount</code> is <code>long</code>.</p>
</font></BODY>
</HTML>
