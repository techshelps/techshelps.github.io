<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Directly Derived Types</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_directly_derived_types"></a><sup></sup>Directly Derived Types</h1>
<p>
New types derived directly from existing types are types that point to, refer to, or (in the case of functions) transform type data to return a new type.&nbsp; 
<ul type=disc>
<li>
<a href="#_pluslang_arrays_of_variables_or_objects">Arrays of Variables or Objects</a><br><br></li>
<li>
<a href="#_pluslang_functions">Functions</a><br><br></li>
<li>
<a href="#_pluslang_pointers_of_a_given_type">Pointers of a Given Type</a><br><br></li>
<li>
<a href="#_pluslang_references_to_objects">References to Objects</a><br><br></li>
<li>
<a href="#_pluslang_c.2b2b_.constants">Constants</a><br><br></li>
<li>
<a href="#_pluslang_pointers_to_class_members">Pointers to Class Members</a></li>
</ul>
<h2><a name="_pluslang_arrays_of_variables_or_objects"></a>Arrays of Variables or Objects</h2>
<p>
Arrays of variables or objects can contain a specified number of a particular type. For example, an array derived from integers is an array of type <b>int</b>. The following code sample declares and defines an array of 10 <b>int</b> variables and an array of 5 objects of class <code>SampleClass</code>:</p>
<pre><code>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayOfInt[10];
SampleClass aSampleClass[5];
</code></pre>
<h2><a name="_pluslang_functions"></a>Functions</h2>
<p>
Functions take zero or more arguments of given types and return objects of a specified type (or return nothing, if the function has a <b>void return</b> type).</p>
<h2><a name="_pluslang_pointers_of_a_given_type"></a>Pointers of a Given Type</h2>
<p>
Pointers to variables or objects select an object in memory. The object can be global, local (or stack-frame), or dynamically allocated. Pointers to functions of a given type allow a program to defer selection of the function used on a particular object or objects until run time. The following example shows a definition of a pointer to a variable of type <b>char</b>:</p>
<pre><code>char *szPathStr;
</code></pre>

<h2><a name="_pluslang_references_to_objects"></a><sup></sup>References to Objects</h2>
<p>
References to objects provide a convenient way to access objects by reference but use the same syntax required to access objects by value. The following example demonstrates how to use references as arguments to functions and as return types of functions:</p>
<pre><code>BigClassType &amp;func( BigClassType &amp;objname )
{
 &nbsp;&nbsp; objname.DoSomething();&nbsp;&nbsp;&nbsp; // Note that member-of operator(.)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; is used.
 &nbsp;&nbsp; objname.SomeData = 7;&nbsp;&nbsp;&nbsp;&nbsp; // Data passed by non-const
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; reference is modifiable.
 &nbsp;&nbsp; return objname;
}
</code></pre>
<p>
The important points about passing objects to a function by reference are:
<ul type=disc>
<li>
The syntax for accessing members of <b>class</b>, <b>struct</b>, and <b>union</b> objects is the same as if they were passed by value: the member-of operator (<b>.</b>).<br><br></li>
<li>
The objects are not copied prior to the function call; their addresses are passed. This can reduce the overhead of the function call.</li>
</ul>
<p>
Additionally, functions that return a reference need only accept the address of the object to which they refer, instead of a copy of the whole object.</p>
<p>
Although the preceding example describes references only in the context of communication with functions, references are not constrained to this use. Consider, for example, a case where a function needs to be an l-value — a common requirement for overloaded operators:</p>
<pre><code>class Vector
{
public:
 &nbsp;&nbsp; Point &amp;operator[]( int nSubscript ); // Function returns a
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; reference type
 &nbsp;&nbsp; ...
};
</code></pre>
<p>
The preceding declaration specifies a user-defined subscript operator for class <code>Vector</code>. In an assignment statement, two possible conditions occur:</p>
<pre><code>Vector v1;
int&nbsp;&nbsp;&nbsp; i;
Point p; 
v1[7] = p;&nbsp;&nbsp; // Vector used as an l-value
p = v1[7];&nbsp;&nbsp; // Vector used as an r-value
</code></pre>
<p>
The latter case, where <code>v1[7]</code> is used as an r-value, can be implemented without use of references. However, the former case, where <code>v1[7]</code> is used as an l-value, cannot be implemented easily without functions that are of reference type. Conceptually, the last two statements in the preceding example translate to the following code:</p>
<pre><code>v1.operator[]( 7 ) = 3;&nbsp;&nbsp;&nbsp; // Vector used as an l-value
i = v1.operator[]( 7 );&nbsp;&nbsp;&nbsp; // Vector used as an r-value
</code></pre>
<p>
When viewed in this way, it is easier to see that the first statement must be an l-value to be semantically correct on the left side of the assignment statement.</p>
<p>
For more information about overloading, and about overloaded operators in particular, see <a href="_pluslang_overloaded_operators.htm">Overloaded Operators</a> in Chapter 12.</p>
<p>
You can also use references to declare a <b>const</b> reference to a variable or object. A reference declared as <b>const</b> retains the efficiency of passing an argument by reference, while preventing the called function from modifying the original object. Consider the following code:</p>
<pre><code>// IntValue is a const reference.
void PrintInt( const int &amp;IntValue )
{
 &nbsp;&nbsp; printf( "%d\n", IntValue );
}
</code></pre>
<p>
Reference initialization is different from assignment to a variable of reference type. Consider the following code:</p>
<pre><code>int i = 7;
int j = 5;

// Reference initialization
int &amp;ri = i;&nbsp; // Initialize ri to refer to i.
int &amp;rj = j;&nbsp; // Initialize rj to refer to j.

// Assignment
ri = 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i now equal to 3.
rj = 12;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // j now equal to 12.
ri = rj;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i now equals j (12).
</code></pre>
<h2><a name="_pluslang_c.2b2b_.constants"></a>C++ Constants</h2>
<p>
See <a href="_pluslang_literals.htm">Literals</a> in Chapter 1 for more information about the various kinds of constants allowed in C++.</p>
<h2><a name="_pluslang_pointers_to_class_members"></a>Pointers to Class Members</h2>
<p>
These pointers define a type that points to a class member of a particular type. Such a pointer can be used by any object of the class type or any object of a type derived from the class type.</p>
<p>
Use of pointers to class members enhances the type safety of the C++ language. Three new operators and constructs are used with pointers to members, as shown in Table 2.5.</p>
<p class=label>
<b><a name="_pluslang_table_2..5"></a>Table 2.5&nbsp; Operators and Constructs Used with Pointers to Members</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Operator or <br>
Construct</b></td>
<td class=label width=24%><b><br>
Syntax</b></td>
<td class=label width=55%><b><br>
Use</b></td>
</tr>
<tr valign=top>
<td width=21%><b>::*</b></td>
<td width=24%><i>type</i><b>::*</b><i>ptr-name</i></td>
<td width=55%>Declaration of pointer to member. The <i>type</i> specifies the class name, and <i>ptr-name</i> specifies the name of the pointer to member. Pointers to members can be initialized. For example:</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=24%></td>
<td width=55%><pre><code>MyType::*pMyType = &amp;MyType::i;</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%><b>.*</b> </td>
<td width=24%><i>obj-name</i><b>.*</b><i>ptr-name</i> </td>
<td width=55%>Dereference a pointer to a member using an object or object reference. For example:</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=24%></td>
<td width=55%><pre><code>int j = Object.*pMyType;</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%><b>–&gt;*</b> </td>
<td width=24%><i>obj-ptr</i><b>–&gt;*</b><i>ptr-name</i></td>
<td width=55%>Dereference a pointer to a member using a pointer to an object. For example:</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=24%></td>
<td width=55%><pre><code>int j = pObject-&gt;*pMyType;</code></pre>
</td>
</tr>
</table><br>
<p>
Consider this example that defines a class <code>AClass</code> and the derived type <code>pDAT</code>, which points to the member <code>I1</code>:</p>
<pre><code>#include &lt;iostream.h&gt;

// Define class AClass.
class AClass
{
public:
 &nbsp;&nbsp; int I1;
 &nbsp;&nbsp; Show() { cout &lt;&lt; I1 &lt;&lt; "\n"; }
};

// Define a derived type pDAT that points to I1 members of
// objects of type AClass.
int AClass::*pDAT = &amp;AClass::I1;

void main()
{
 &nbsp;&nbsp; AClass aClass;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Define an object of type AClass.
 &nbsp;&nbsp; AClass *paClass = &amp;aClass;&nbsp; // Define a pointer to that object.

 &nbsp;&nbsp; int i;

 &nbsp;&nbsp; aClass.*pDAT = 7777;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Assign to aClass::I1 using .* operator.
 &nbsp;&nbsp; aClass.Show();

 &nbsp;&nbsp; i = paClass-&gt;*pDAT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Dereference a pointer 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; using -&gt;* operator.
 &nbsp;&nbsp; cout &lt;&lt; i &lt;&lt; "\n";
}
</code></pre>
<p>
The pointer to member <code>pDAT</code> is a new type derived from class <code>AClass</code>. It is more strongly typed than a “plain” pointer to <b>int</b> because it points only to <b>int</b> members of class <code>AClass</code> (in this case, <code>I1</code>). Pointers to static members are plain pointers rather than pointers to class members. Consider the following example:</p>
<pre><code>class HasStaticMember
{
public:
 &nbsp;&nbsp; static int SMember;
};
int HasStaticMember::SMember = 0;

int *pSMember = &amp;HasStaticMember::SMember;
</code></pre>
<p>
Note that the type of the pointer is “pointer to <b>int</b>,” not “pointer to <code>HasStaticMember::int</code>.”</p>
<p>
Pointers to members can refer to member functions as well as member data. Consider the following code:</p>
<pre><code>#include &lt;stdio.h&gt;

// Declare a base class, A, with a virtual function, Identify.
// (Note that in this context, struct is the same as class.)
struct A
{
 &nbsp;&nbsp; virtual void Identify() = 0; // No definition for class A.
};

// Declare a pointer to the Identify member function.
void (A::*pIdentify)() = &amp;A::Identify;

// Declare class B derived from class A.
struct B : public A
{
 &nbsp;&nbsp; void Identify();
};

// Define Identify functions for classe B
void B::Identify()
{
 &nbsp;&nbsp; printf( "Identification is B::Identify\n" );
}

void main()
{
 &nbsp;&nbsp; B&nbsp; BObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Declare objects of type B
 &nbsp;&nbsp; A *pA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Declare pointer to type A.

 &nbsp;&nbsp; pA = &amp;BObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make pA point to an object of type B.
 &nbsp;&nbsp; (pA-&gt;*pIdentify)();&nbsp; // Call Identify function through pointer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; to member pIdentify.
}
</code></pre>
<p>
The output from this program is:</p>
<pre><code>Identification is B::Identify
</code></pre>
<p>
The function is called through a pointer to type <code>A</code>. However, because the function is a virtual function, the correct function for the object to which <code>pA</code> refers is called.</p>
</font></BODY>
</HTML>
