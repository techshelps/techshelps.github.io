<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>using Declaration</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_using_declaration"></a><sup></sup>using Declaration</h1>
<p>
The <b>using</b> declaration introduces a name into the declarative region in which the <b>using</b> declaration appears. The name becomes a synonym for an entity declared elsewhere. It allows an <i>individual</i> name from a specific namespace to be used without explicit qualification. This is in contrast to the <b>using</b> directive, which allows <i>all</i> the names in a namespace to be used without qualification. See <a href="_pluslang_using_directive.htm">using Directive</a> for more information.</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>using-declaration</i> :</p>
<p class=indent>
<b>using</b> <b>::</b><sub>opt </sub> <i>nested-name-specifier</i> <i>unqualified-id</i><br>
<b>using</b> <b>::</b> <i>unqualified-id</i></p>
<p>
A <i>using-declaration</i> can be used in a class definition. For example:</p>
<pre><code>class B
{
 &nbsp;&nbsp; void f(char);
 &nbsp;&nbsp; void g(char);
};

class D : B
{
 &nbsp;&nbsp; using B::f;
 &nbsp;&nbsp; void f(int) { f('c'); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls B::f(char)
 &nbsp;&nbsp; void g(int) { g('c'); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // recursively calls D::g(int)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only B::f is being used
};
</code></pre>
<p>
When used to declare a member, a <i>using-declaration</i> must refer to a member of a base class. For example:</p>
<pre><code>class C
{
 &nbsp;&nbsp; int g();
};

class D2 : public B
{
 &nbsp;&nbsp; using B::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok: B is a base of D2
 &nbsp;&nbsp; using C::g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: C isn't a base of D2
};
</code></pre>
<p>
Members declared with a <i>using-declaration</i> can be referenced using explicit qualification. The <b>::</b> prefix refers to the global namespace. For example:</p>
<pre><code>void f();

namespace A
{
 &nbsp;&nbsp; void g();
}

namespace X
{
 &nbsp;&nbsp; using ::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // global f
 &nbsp;&nbsp; using A::g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A's g
}

void h()
{
 &nbsp;&nbsp; X::f();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls ::f
 &nbsp;&nbsp; X::g();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls A::g
}
</code></pre>
<p>
Just as with any declaration, a <i>using-declaration</i> can be used repeatedly only where multiple declarations are allowed. For example:</p>
<pre><code>namespace A
{
 &nbsp;&nbsp; int i;
}

void f()
{
 &nbsp;&nbsp; using A::i;
 &nbsp;&nbsp; using A::i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok: double declaration
}

class B
{
protected:
 &nbsp;&nbsp; int i;
};

class X : public B
{
public:
 &nbsp;&nbsp; using B::i;
 &nbsp;&nbsp; using B::i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: class members cannot be multiply declared
};
</code></pre>
<p>
When a <i>using-declaration</i> is made, the synonym created by the declaration refers only to definitions that are valid at the point of the <i>using-declaration</i>. Definitions added to a namespace after the <i>using-declaration</i> are not valid synonyms. For example:</p>
<pre><code>namespace A
{
 &nbsp;&nbsp; void f(int);
}

using A::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // f is a synonym for A::f(int) only

namespace A
{
 &nbsp;&nbsp; void f(char);
}

void f()
{
 &nbsp;&nbsp; f('a');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // refers to A::f(int), even though A::f(char) exists
}

void b()
{
 &nbsp;&nbsp; using A::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // refers to A::f(int) AND A::f(char)
 &nbsp;&nbsp; f('a');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls A::f(char);
}
</code></pre>
<p>
A name defined by a <i>using-declaration</i> is an alias for its original name. It does not affect the type, linkage or other attributes of the original declaration.</p>
<p>
If a set of local declarations and <i>using-declaration</i>s for a single name are given in a declarative region, they must all refer to the same entity, or they must all refer to functions. For example:</p>
<pre><code>namespace B
{
 &nbsp;&nbsp; int i;
 &nbsp;&nbsp; void f(int);
 &nbsp;&nbsp; void f(double);
}

void g()
{
 &nbsp;&nbsp; int i;
 &nbsp;&nbsp; using B::i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: i declared twice
 &nbsp;&nbsp; void f(char);
 &nbsp;&nbsp; using B::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok: each f is a function
}
</code></pre>
<p>
In the example above, the <code>using B::i</code> statement causes a second <code>int i</code> to be declared in the <code>g()</code> function. The <code>using B::f</code> statement does not conflict with the <code>f(char)</code> function because the function names introduced by <code>B::f</code> have different parameter types.</p>
<p>
A local function declaration cannot have the same name and type as a function introduced by a <i>using-declaration</i>. For example:</p>
<pre><code>namespace B
{
 &nbsp;&nbsp; void f(int);
 &nbsp;&nbsp; void f(double);
}

namespace C
{
 &nbsp;&nbsp; void f(int);
 &nbsp;&nbsp; void f(double);
 &nbsp;&nbsp; void f(char);
}

void h()
{
 &nbsp;&nbsp; using B::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // introduces B::f(int) and B::f(double)
 &nbsp;&nbsp; using C::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // C::f(int), C::f(double), and C::f(char)
 &nbsp;&nbsp; f('h');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls C::f(char)
 &nbsp;&nbsp; f(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: ambiguous: B::f(int) or C::f(int)?
 &nbsp;&nbsp; void f(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: conflicts with B::f(int) and C::f(int)
}
</code></pre>
<p>
When a <i>using-declaration</i> introduces a name from a base class into a derived class scope, member functions in the derived class override virtual member functions with the same name and argument types in the base class. For example:</p>
<pre><code>struct B
{
 &nbsp;&nbsp; virtual void f(int);
 &nbsp;&nbsp; virtual void f(char);
 &nbsp;&nbsp; void g(int);
 &nbsp;&nbsp; void h(int);
};

struct D : B
{
 &nbsp;&nbsp;&nbsp; using B::f;
 &nbsp;&nbsp; void f(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok: D::f(int) overrides B::f(int)

 &nbsp;&nbsp; using B::g;
 &nbsp;&nbsp; void g(char);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok: there is no B::g(char)

 &nbsp;&nbsp; using B::h;
 &nbsp;&nbsp; void h(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: D::h(int) conflicts with B::h(int)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // B::h(int) is not virtual
};

void f(D* pd)
{
 &nbsp;&nbsp; pd-&gt;f(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls D::f(int)
 &nbsp;&nbsp; pd-&gt;f('a');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls B::f(char)
 &nbsp;&nbsp; pd-&gt;g(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls B::g(int)
 &nbsp;&nbsp; pd-&gt;g('a');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls D::g(char)
}
</code></pre>
<p>
All instances of a name mentioned in a <i>using-declaration</i> must be accessible. In particular, if a derived class uses a <i>using-declaration</i> to access a member of a base class, the member name must be accessible. If the name is that of an overloaded member function, then all functions named must be accessible. For example:</p>
<pre><code>class A
{
private:
 &nbsp;&nbsp; void f(char);
public:
 &nbsp;&nbsp; void f(int);
protected:
 &nbsp;&nbsp; void g();
};

class B : public A
{
 &nbsp;&nbsp; using A::f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error: A::f(char) is inaccessible
public:
 &nbsp;&nbsp; using A::g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // B::g is a public synonym for A::g
};
</code></pre>
<p>
See Chapter 10, <a href="_pluslang_member.2d.access_control.htm">Member-Access Control</a> for more information on accessibility of members.</p>
</font></BODY>
</HTML>
