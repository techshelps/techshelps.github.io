<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>static_cast Operator</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_static_cast_operator"></a><sup></sup>static_cast Operator</h1>
<p>
The expression static_cast &lt; <i>type-id</i> &gt; ( <i>expression</i> ) converts <i>expression</i> to the type of <i>type-id</i> based solely on the types present in the expression. No run-time type check is made to ensure the safety of the conversion.</p>
<p class=label>
<b>Syntax</b></p>
<p>
static_cast &lt; <i>type-id</i> &gt; ( <i>expression</i> )</p>
<p>
The static_cast operator can be used for operations such as converting a pointer to a base class to a pointer to a derived class. Such conversions are not always safe. For example:</p>
<pre><code>class B { ... };

class D : public B { ... };

void f(B* pb, D* pd)
{
 &nbsp;&nbsp; D* pd2 = static_cast&lt;D*&gt;(pb);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not safe, pb may
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // point to just B

 &nbsp;&nbsp; B* pb2 = static_cast&lt;B*&gt;(pd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // safe conversion
 &nbsp;&nbsp; ...
}
</code></pre>
<p>
In contrast to dynamic_cast, no run-time check is made on the static_cast conversion of <code>pb</code>. The object pointed to by <code>pb</code> may not be an object of type <code>D</code>, in which case the use of <code>*pd2</code> could be disastrous. For instance, calling a function that is a member of the <code>D</code> class, but not the <code>B</code> class, could result in an access violation.</p>
<p>
The dynamic_cast and static_cast operators move a pointer throughout a class hierarchy. However, static_cast relies exclusively on the information provided in the cast statement and can therefore be unsafe. For example:</p>
<pre><code>class B { ... };
class D : public B { ... };

void f(B* pb)
{
   D* pd1 = dynamic_cast&lt;D*&gt;(pb);
   D* pd2 = static_cast&lt;D*&gt;(pb);
}
</code></pre>
<p>
If <code>pb</code> really points to an object of type <code>D</code>, then <code>pd1</code> and <code>pd2</code> will get the same value. They will also get the same value if <code>pb == 0</code>. </p>
<p>
If <code>pb</code> points to an object of type <code>B</code> and not to the complete <code>D</code> class, then dynamic_cast will know enough to return zero. However, static_cast relies on the programmer’s assertion that <code>pb</code> points to an object of type <code>D</code> and simply returns a pointer to that supposed <code>D</code> object.</p>
<p>
Consequently, static_cast can do the inverse of implicit conversions, in which case the results are undefined. It is left to the programmer to ensure that the results of a static_cast conversion are safe.</p>
<p>
This behavior also applies to types other than class types. For instance, static_cast can be used to convert from an int to a char. However, the resulting char may not have enough bits to hold the entire int value. Again, it is left to the programmer to ensure that the results of a static_cast conversion are safe.</p>
<p>
The static_cast operator can also be used to perform any implicit conversion, including standard conversions and user-defined conversions. For example:</p>
<pre><code>typedef unsigned char BYTE

void f()
{
   char ch;
   int i = 65;
   float f = 2.5;
   double dbl;

   ch = static_cast&lt;char&gt;(i);         // int to char
   dbl = static_cast&lt;double&gt;(f);         // float to double
   ...
   i = static_cast&lt;BYTE&gt;(ch);
   ...
}
</code></pre>
<p>
The static_cast operator can explicitly convert an integral value to an enumeration type. If the value of the integral type does not fall within the range of enumeration values, the resulting enumeration value is undefined.</p>
<p>
The static_cast operator converts a null pointer value to the null pointer value of the destination type.</p>
<p>
Any expression can be explicitly converted to type void by the static_cast operator. The destination void type can optionally include the const, volatile, or __unaligned attribute.</p>
<p>
The static_cast operator cannot cast away the const, volatile, or __unaligned attributes. See <a href="_pluslang_const_cast_operator.htm">const_cast Operator</a> for information on removing these attributes.</p>
</font></BODY>
</HTML>
