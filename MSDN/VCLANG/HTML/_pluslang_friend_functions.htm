<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Friend Functions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_friend_functions"></a><sup></sup>Friend Functions</h1>
<p>
Friend functions are not considered class members; they are normal external functions that are given special access privileges. Friends are not in the class’s scope, and they are not called using the member-selection operators (<b>.</b> and –<b>&gt;</b>) unless they are members of another class. The following example shows a <code>Point</code> class and an overloaded operator, <code>operator+</code>. (This example primarily illustrates friends, not overloaded operators. For more information about overloaded operators, see <a href="_pluslang_overloaded_operators.htm">Overloaded Operators</a> in Chapter 12.)</p>
<pre><code>#include &lt;iostream.h&gt;

// Declare class Point.
class Point
{
public:
 &nbsp;&nbsp; // Constructors
 &nbsp;&nbsp; Point() { _x = _y = 0; }
 &nbsp;&nbsp; Point( unsigned x, unsigned y ) { _x = x; _y = y; }
 &nbsp;&nbsp; // Accessors
 &nbsp;&nbsp; unsigned x() { return _x; }
 &nbsp;&nbsp; unsigned y() { return _y; }
 &nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp; Print() { cout &lt;&lt; "Point(" &lt;&lt; _x &lt;&lt; ", " &lt;&lt; _y &lt;&lt; ")"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl; }

 &nbsp;&nbsp; // Friend function declarations
 &nbsp;&nbsp; friend Point operator+( Point&amp; pt, int nOffset );
 &nbsp;&nbsp; friend Point operator+( int nOffset, Point&amp; pt );

private:
 &nbsp;&nbsp; unsigned _x;
 &nbsp;&nbsp; unsigned _y;
};

// Friend-function definitions
//
// Handle Point + int expression.
Point operator+( Point&amp; pt, int nOffset )
{
 &nbsp;&nbsp; Point ptTemp = pt;
 &nbsp;&nbsp; // Change private members _x and _y directly.
 &nbsp;&nbsp; ptTemp._x += nOffset;
 &nbsp;&nbsp; ptTemp._y += nOffset;

 &nbsp;&nbsp; return ptTemp;
}

// Handle int + Point expression.
Point operator+( int nOffset, Point&amp; pt )
{
 &nbsp;&nbsp; Point ptTemp = pt;
 &nbsp;&nbsp; // Change private members _x and _y directly.
 &nbsp;&nbsp; ptTemp._x += nOffset;
 &nbsp;&nbsp; ptTemp._y += nOffset;

 &nbsp;&nbsp; return ptTemp;
}

// Test overloaded operator.
void main()
{
 &nbsp;&nbsp; Point pt( 10, 20 );
 &nbsp;&nbsp; pt.Print();

 &nbsp;&nbsp; pt = pt + 3;&nbsp;&nbsp;&nbsp;&nbsp; // Point + int
 &nbsp;&nbsp; pt.Print();

 &nbsp;&nbsp; pt = 3 + pt;&nbsp;&nbsp;&nbsp;&nbsp; // int + Point
 &nbsp;&nbsp; pt.Print();
}
</code></pre>
<p>
When the expression <code>pt + 3</code> is encountered in the <code>main</code> function, the compiler determines whether an appropriate user-defined <code>operator+</code> exists. In this case, the function <code>operator+( Point pt, int nOffset )</code> matches the operands, and a call to the function is issued. In the second case (the expression <code>3 + pt</code>), the function <code>operator+( Point pt, int nOffset )</code> matches the supplied operands. Therefore,&nbsp; supplying these two forms of <code>operator+</code> preserves the commutative properties of the <code>+</code> operator.</p>
<p>
A user-defined <code>operator+</code> can be written as a member function, but it takes only one explicit argument: the value to be added to the object. As a result, the commutative properties of addition cannot be correctly implemented with member functions; they must use friend functions instead.</p>
<p>
Notice that both versions of the overloaded <code>operator+</code> function are declared as friends in class <code>Point</code>. Both declarations are necessary — when <b>friend</b> declarations name overloaded functions or operators, only the particular functions specified by the argument types become friends. Suppose a third <code>operator+</code> function were declared as follows:</p>
<pre><code>Point &amp;operator+( Point &amp;pt, Point &amp;pt );
</code></pre>
<p>
The <code>operator+</code> function in the preceding example is not a friend of class <code>Point</code>, simply because it has the same name as two other functions that are declared as friends.</p>
<p>
Because <b>friend</b> declarations are unaffected by access specifiers, they can be declared in any section of the class declaration.</p>
</font></BODY>
</HTML>
