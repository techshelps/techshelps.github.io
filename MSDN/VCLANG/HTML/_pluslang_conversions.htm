<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Conversions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_conversions"></a><sup></sup>Conversions</h1>
<p>
Objects of a given class type can be converted to objects of another type. This is done by constructing an object of the target class type from the source class type and copying the result to the target object. This process is called conversion by constructor. Objects can also be converted by user-supplied conversion functions. </p>
<p>
When standard conversions (described in Chapter 3, <a href="_pluslang_standard_conversions.htm">Standard Conversions</a>) cannot completely convert from a given type to a class type, the compiler can select user-defined conversions to help complete the job. In addition to explicit type conversions, conversions take place when:
<ul type=disc>
<li>
An initializer expression is not the same type as the object being initialized.<br><br></li>
<li>
The type of argument used in a function call does not match the type of argument specified in the function declaration.<br><br></li>
<li>
The type of the object being returned from a function does not match the return type specified in the function declaration.<br><br></li>
<li>
Two expression operands must be of the same type.<br><br></li>
<li>
An expression controlling an iteration or selection statement requires a different type from the one supplied.</li>
</ul>
<p>
A user-defined conversion is applied only if it is unambiguous; otherwise, an error message is generated. Ambiguity is checked at the point of usage. Hence, if the features that cause ambiguity are not used, a class can be designated with potential ambiguities and not generate any errors. Although there are many situations in which ambiguities arise, these are two leading causes of ambiguities: 
<ul type=disc>
<li>
A class type is derived using multiple inheritance, and it is unclear from which base class to select the conversion (see <a href="_pluslang_ambiguity.htm">Ambiguity</a> in Chapter 9).<br><br></li>
<li>
An explicit type-conversion operator and a constructor for the same conversion exist (see <a href="_pluslang_conversion_functions.htm">Conversion Functions</a>).</li>
</ul>
<p>
Both conversion by constructor and conversion by conversion functions obey access control rules, as described in Chapter 10, <a href="_pluslang_member.2d.access_control.htm">Member-Access Control</a>. Access control is tested only after the conversion is found to be unambiguous.</p>
</font></BODY>
</HTML>
