<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>dynamic_cast Operator</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_dynamic_cast_operator"></a><sup></sup>dynamic_cast Operator</h1>
<p>
The expression dynamic_cast&lt;<i>type-id</i>&gt;( <i>expression </i>) converts the operand <i>expression</i> to an object of type <i>type-id</i>. The <i>type-id</i> must be a pointer or a reference to a previously defined class type or a “pointer to void”. The type of <i>expression</i> must be a pointer if <i>type-id</i> is a pointer, or an l-value if <i>type-id</i> is a reference.</p>
<p class=label>
<b>Syntax</b></p>
<p>
dynamic_cast &lt; <i>type-id</i> &gt; ( <i>expression</i> )</p>
<p>
If <i>type-id</i> is a pointer to an unambiguous accessible direct or indirect base class of <i>expression</i>, a pointer to the unique subobject of type <i>type-id</i> is the result. For example:</p>
<pre><code>class B { ... };
class C : public B { ... };
class D : public C { ... };

void f(D* pd)
{
   C* pc = dynamic_cast&lt;C*&gt;(pd);   // ok: C is a direct base class
                           // pc points to C subobject of pd 

   B* pb = dynamic_cast&lt;B*&gt;(pd);   // ok: B is an indirect base class
                           // pb points to B subobject of pd 
   ...
}
</code></pre>
<p>
This type of conversion is called an “upcast” because it moves a pointer up a class hierarchy, from a derived class to a class it is derived from. An upcast is an implicit conversion.</p>
<p>
If <i>type-id</i> is void*, a run-time check is made to determine the actual type of <i>expression</i>. The result is a pointer to the complete object pointed to by <i>expression</i>. For example:</p>
<pre><code>class A { ... };

class B { ... };

void f()
{
   A* pa = new A;
   B* pb = new B;
   void* pv = dynamic_cast&lt;void*&gt;(pa);
   // pv now points to an object of type A
   ...
   pv = dynamic_cast&lt;void*&gt;(pb);
   // pv now points to an object of type B
}
</code></pre>
<p>
If <i>type-id</i> is not void*, a run-time check is made to see if the object pointed to by <i>expression</i> can be converted to the type pointed to by <i>type-id</i>.</p>
<p>
If the type of <i>expression</i> is a base class of the type of <i>type-id</i>, a run-time check is made to see if <i>expression</i> actually points to a complete object of the type of <i>type-id</i>. If this is true, the result is a pointer to a complete object of the type of <i>type-id</i>. For example:</p>
<pre><code>class B { ... };
class D : public B { ... };

void f()
{
   B* pb = new D;               // unclear but ok
   B* pb2 = new B;

   D* pd = dynamic_cast&lt;D*&gt;(pb);      // ok: pb actually points to a D
   ...
   D* pd2 = dynamic_cast&lt;D*&gt;(pb2);   //error: pb2 points to a B, not a D
                              // pd2 == NULL
   ...
}
</code></pre>
<p>
This type of conversion is called a “downcast” because it moves a pointer down a class hierarchy, from a given class to a class derived from it.</p>
<p>
In cases of multiple inheritance, possibilities for ambiguity are introduced. Consider the class hierarchy shown in Figure 4.5:</p>
<p class=label>
<b>Figure 4.5&nbsp;&nbsp;&nbsp;Class Hierarchy Showing Multiple Inheritance</b></p>
<p>
<img src="rtti_03.gif" border=0></p>
<p>
A pointer to an object of type <code>D</code> can be safely cast to <code>B</code> or <code>C</code>. However, if <code>D</code> is cast to point to an <code>A</code> object, which instance of <code>A</code> would result? This would result in an ambiguous casting error. To get around this problem, you can perform two unambiguous casts. For example:</p>
<pre><code>void f()
{
   D* pd = new D;
   A* pa = dynamic_cast&lt;A*&gt;(pd);      // error: ambiguous
   B* pb = dynamic_cast&lt;B*&gt;(pd);      // first cast to B
   A* pa2 = dynamic_cast&lt;A*&gt;(pb);   // ok: unambiguous
}
</code></pre>
<p>
Further ambiguities can be introduced when you use virtual base classes. Consider the class hierarchy shown in Figure 4.6:</p>
<p class=label>
<b>Figure 4.6&nbsp;&nbsp;&nbsp;Class Hierarchy Showing Virtual Base Classes</b></p>
<p>
<img src="rtti_05.gif" border=0></p>
<p>
In this hierarchy, <code>A</code> is a virtual base class. See <a href="_pluslang_virtual_base_classes.htm">Virtual Base Classes</a> for the definition of a virtual base class. Given an instance of class <code>E</code> and a pointer to the <code>A</code> subobject, a dynamic_cast to a pointer to <code>B</code> will fail due to ambiguity. You must first cast back to the complete <code>E</code> object, then work your way back up the hierarchy, in an unambiguous manner, to reach the correct <code>B</code> object.</p>
<p>
Consider the class hierarchy shown in Figure 4.7:</p>
<p class=label>
<b>Figure 4.7&nbsp;&nbsp;&nbsp;Class Hierarchy Showing Duplicate Base Classes</b></p>
<p>
<img src="rtti_04.gif" border=0></p>
<p>
Given an object of type <code>E</code> and a pointer to the <code>D</code> subobject, to navigate from the <code>D</code> subobject to the left-most <code>A</code> subobject, three conversions can be made. You can perform a dynamic_cast conversion from the <code>D</code> pointer to an <code>E</code> pointer, then a conversion (either dynamic_cast or an implicit conversion) from <code>E</code> to <code>B</code>, and finally an implicit conversion from <code>B</code> to <code>A</code>. For example:</p>
<pre><code>void f(D* pd)
{
   E* pe = dynamic_cast&lt;E*&gt;(pd);
   B* pb = pe;      // upcast, implicit conversion
   A* pa = pb;      // upcast, implicit conversion
}
</code></pre>
<p>
The dynamic_cast operator can also be used to perform a “cross cast.” Using the same class hierarchy, it is possible to cast a pointer, for example, from the <code>B</code> subobject to the <code>D</code> subobject, as long as the complete object is of type <code>E</code>.</p>
<p>
Considering cross casts, it is actually possible to do the conversion from a pointer to <code>D</code> to a pointer to the left-most <code>A</code> subobject in just two steps. You can perform a cross cast from <code>D</code> to <code>B</code>, then an implicit conversion from <code>B</code> to <code>A</code>. For example:</p>
<pre><code>void f(D* pd)
{
   B* pb = dynamic_cast&lt;B*&gt;(pd);      // cross cast
   A* pa = pb;                  // upcast, implicit conversion
}
</code></pre>
<p>
A null pointer value is converted to the null pointer value of the destination type by dynamic_cast.</p>
<p>
When you use dynamic_cast &lt; <i>type-id</i> &gt; ( <i>expression</i> ), if <i>expression</i> cannot be safely converted to type <i>type-id</i>, the run-time check causes the cast to fail. For example:</p>
<pre><code>class A { ... };

class B { ... };

void f()
{
   A* pa = new A;
   B* pb = dynamic_cast&lt;B*&gt;(pa);      // fails, not safe; 
                              // B not derived from A
   ...
}
</code></pre>
<p>
The value of a failed cast to pointer type is the null pointer. A failed cast to reference type throws a bad_cast exception.</p>
</font></BODY>
</HTML>
