<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Iterator Conventions</title></head>
<body bgcolor=white>

<h2><a name="Iterator Conventions">Iterator Conventions</a></h2>
<META NAME="MS-HKWD" CONTENT="Iterator Conventions"><p>The STL facilities make widespread use of <a name="iterators"><b>iterators</b></a>, to mediate between the various algorithms and the sequences 
upon which they act. For brevity in the remainder of this document, the name of an iterator type (or its prefix) indicates 
the category of iterators required for that type. In order of increasing power, the categories are summarized here as:</p>
<ul>
<li><a name="OutIt"><code><b>OutIt</b></code></a> -- An output iterator <code>X</code> can only have a value <code>V</code> stored indirectly on it, after which it must be incremented 
before the next store, as in <code>(*X++ = V)</code>, <code>(*X = V, ++X)</code>, or <code>(*X = V, X++)</code>.</li>
<li><a name="InIt"><code><b>InIt</b></code></a> -- An input iterator  <code>X</code> can represent a singular value that indicates end-of-sequence. If such an iterator 
does not compare equal to its end-of-sequence value, it can have a value <code>V</code> accessed indirectly on it any number of 
times, as in <code>(V = *X)</code>. To progress to the next value, or end-of-sequence, you increment it, as in <code>++X</code>, <code>X++</code>, or 
<code>(V = *X++)</code>. Once you increment any copy of an input iterator, none of the other copies can safely be 
compared, dereferenced, or incremented.</li>
<li><a name="FwdIt"><code><b>FwdIt</b></code></a> -- A forward iterator  <code>X</code> can take the place of an output iterator (for writing) or an input iterator (for 
reading). You can, however, read (via <code>V = *X</code>) what you just wrote (via <code>*X = V</code>) through a forward iterator. 
And you can make multiple copies of a forward iterator, each of which can be dereferenced and incremented 
independently.</li>
<li><a name="BidIt"><code><b>BidIt</b></code></a> -- A bidirectional iterator <code>X</code> can take the place of a forward iterator. You can, however, also 
decrement a bidirectional iterator, as in <code>--X</code>, <code>X--</code>, or <code>(V = *X--)</code>.</li>
<li><a name="RanIt"><code><b>RanIt</b></code></a> -- A random-access iterator <code>X</code> can take the place of a bidirectional iterator. You can also perform 
much the same integer arithmetic on a random-access iterator that you can on an object pointer. For <code>N</code>, an integer 
object, you can write <code>x[N]</code>, <code>x + N</code>, <code>x - N</code>, and <code>N + X</code>.</li>
</ul>
<p>Note that an object pointer can take the place of a random-access iterator, or any other iterator for that matter.</p>
<p>The hierarchy of iterator categories can be summarized by showing three sequences. For write-only access to a 
sequence, you can use any of:</p>
<pre><code>output iterator -&gt;
    forward iterator -&gt;
    bidirectional iterator -&gt;
    random-access iterator</code></pre>
<p>The right arrow means "can be replaced by." So any algorithm that calls for an output iterator should work well with 
a forward iterator, for example, but not the other way around.</p>
<p>For read-only access to a sequence, you can use any of:</p>
<pre><code>input iterator -&gt;
    forward iterator -&gt;
    bidirectional iterator -&gt;
    random-access iterator</code></pre>
<p>An input iterator is the weakest of all categories, in this case.</p>
<p>Finally, for read/write access to a sequence, you can use any of:</p>
<pre><code>forward iterator -&gt;
    bidirectional iterator -&gt;
    random-access iterator</code></pre>
<p>Remember that an object pointer can always serve as a random-access iterator. Therefore, it can serve as any category of 
iterator, as long as it supports the proper read/write access to the sequence it designates.</p>
<p>This "algebra" of iterators is fundamental to practically everything else in the <a href="INDEX_Table_of_Contents.htm#Standard Template Library">Standard Template Library</a>. It is important 
to understand the capabilities, and limitations, of each iterator category to see how iterators are used by containers and 
algorithms in STL.</p>
</body>
</html>
