<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Argument Matching and Conversions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_argument_matching_and_conversions"></a><sup></sup>Argument Matching and Conversions</h1>
<p>
When the compiler tries to match actual arguments against the arguments in function declarations, it can supply standard or user-defined conversions to obtain the correct type if no exact match can be found. The application of conversions is subject to these rules:
<ul type=disc>
<li>
Sequences of conversions that contain more than one user-defined conversion are not considered.<br><br></li>
<li>
Sequences of conversions that can be shortened by removing intermediate conversions are not considered.</li>
</ul>
<p>
The resultant sequence of conversions, if any, is called the best matching sequence. There are several ways to convert an object of type <b>int</b> to type <b>unsigned long </b>using standard conversions (described in Chapter 3, <a href="_pluslang_standard_conversions.htm">Standard Conversions</a>):
<ul type=disc>
<li>
Convert from <b>int</b> to <b>long</b> and then from <b>long</b> to <b>unsigned long</b>.<br><br></li>
<li>
Convert from <b>int</b> to <b>unsigned long</b>.</li>
</ul>
<p>
The first sequence, although it achieves the desired goal, is not the best matching sequence — a shorter sequence exists.</p>
<p>
Table 12.1 shows a group of conversions, called trivial conversions, that have a limited effect on determining of which sequence is the best matching. The instances in which trivial conversions affect choice of sequence are discussed in the list following the table.</p>
<p class=label>
<b><a name="_pluslang_table_12..1"></a>Table 12.1&nbsp;&nbsp;&nbsp;Trivial Conversions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>Convert from Type</b></td>
<td class=label width=61%><b>Convert to Type</b></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name</i></td>
<td width=61%><i>type-name</i><b>&amp;</b></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name</i><b>&amp;</b></td>
<td width=61%><i>type-name</i></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name</i><b>[ ]</b></td>
<td width=61%><i>type-name*</i></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name</i><b>(</b> <i>argument-list</i> <b>)</b></td>
<td width=61%><b>(</b><i>*type-name</i><b>) (</b> <i>argument-list</i> <b>)</b></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name</i></td>
<td width=61%><b>const</b> <i>type-name</i></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name</i></td>
<td width=61%><b>volatile</b> <i>type-name</i></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name*</i></td>
<td width=61%><b>const</b> <i>type-name*</i></td>
</tr>
<tr valign=top>
<td width=39%><i>type-name*</i></td>
<td width=61%><b>volatile</b> <i>type-name*</i></td>
</tr>
</table><br>
<p>
The sequence in which conversions are attempted is as follows:
<ol>
<li>
Exact match. An exact match between the types with which the function is called and the types declared in the function prototype is always the best match. Sequences of trivial conversions are classified as exact matches. However, sequences that do not make any of these conversions are considered better than sequences that convert:<ul type=disc>
<li>
From pointer, to pointer to <b>const</b> (<i>type</i> <b>*</b> to <b>const</b> <i>type</i> <b>*</b>).<br><br></li>
<li>
From pointer, to pointer to <b>volatile</b> (<i>type</i> <b>*</b> to <b>volatile</b> <i>type</i> <b>*</b>).<br><br></li>
<li>
From reference, to reference to <b>const</b> (<i>type</i> <b>&amp;</b> to <b>const</b> <i>type</i> <b>&amp;</b>).<br><br></li>
<li>
From reference, to reference to <b>volatile</b> (<i>type</i> <b>&amp;</b> to <b>volatile</b> <i>type</i> <b>&amp;</b>).</li>
</ul>
</li>
<li>
Match using promotions. Any sequence not classified as an exact match that contains only integral promotions, conversions from <b>float</b> to <b>double</b>, and trivial conversions is classified as a match using promotions. Although not as good a match as any exact match, a match using promotions is better than a match using standard conversions.<br><br></li>
<li>
Match using standard conversions. Any sequence not classified as an exact match or a match using promotions that contains only standard conversions and trivial conversions is classified as a match using standard conversions. Within this category, the following rules are applied:<ul type=disc>
<li>
Conversion from a pointer to a derived class, to a pointer to a direct or indirect base class is preferable to converting to <b>void *</b> or <b>const void *</b>.<br><br></li>
<li>
Conversion from a pointer to a derived class, to a pointer to a base class produces a better match the closer the base class is to a direct base class. Suppose the class hierarchy is as shown in Figure 12.1.</li>
</ul>
</li>
</ol>
<p class=label>
<b>Figure 12.1&nbsp;&nbsp;&nbsp;Graph Illustrating Preferred Conversions</b></p>
<p>
<img src="l12gra1.gif" border=0></P><p class=tl>
Conversion from type <code>D*</code> to type <code>C*</code> is preferable to conversion from type <code>D*</code> to type <code>B*</code>. Similarly, conversion from type <code>D*</code> to type <code>B*</code> is preferable to conversion from type <code>D*</code> to type <code>A*</code>.</P><p class=tl>
This same rule applies to reference conversions. Conversion from type <code>D&amp;</code> to type <code>C&amp;</code> is preferable to conversion from type <code>D&amp;</code> to type <code>B&amp;</code>, and so on.</P><p class=tl>
This same rule applies to pointer-to-member conversions. Conversion from type <code>T D::*</code> to type <code>T C::*</code> is preferable to conversion from type <code>T D::*</code> to type <code>T B::*</code>, and so on (where <code>T</code> is the type of the member).</P><p class=tl>
The preceding rule applies only along a given path of derivation. Consider the graph shown in Figure 12.2.</P><p class=label>
<b>Figure 12.2&nbsp;&nbsp;&nbsp;Multiple-Inheritance Graph Illustrating Preferred Conversions</b></p>
<p>
<img src="l12gra2.gif" border=0></P><p class=tl>
Conversion from type <code>C*</code> to type <code>B*</code> is preferable to conversion from type <code>C*</code> to type <code>A*</code>. The reason is that they are on the same path, and <code>B*</code> is closer. However, conversion from type <code>C*</code> to type <code>D*</code> is not preferable to conversion to type <code>A*</code>; there is no preference because the conversions follow different paths.</P><ol start=4>
<li>
Match with user-defined conversions. This sequence cannot be classified as an exact match, a match using promotions, or a match using standard conversions. The sequence must contain only user-defined conversions, standard conversions, or trivial conversions to be classified as a match with user-defined conversions. A match with user-defined conversions is considered a better match than a match with an ellipsis but not as good a match as a match with standard conversions.<br><br></li>
<li>
Match with an ellipsis. Any sequence that matches an ellipsis in the declaration is classified as a match with an ellipsis. This is considered the weakest match.</li>
</ol>
<p>
User-defined conversions are applied if no built-in promotion or conversion exists. These conversions are selected on the basis of the type of the argument being matched. Consider the following code:</p>
<pre><code>class UDC
{
public:
 &nbsp;&nbsp; operator int();
 &nbsp;&nbsp; operator long();
};

void Print( int i );
...
UDC udc;
Print( udc );
</code></pre>
<p>
The available user-defined conversions for class <code>UDC</code> are from type <b>int</b> and type <b>long</b>. Therefore, the compiler considers conversions for the type of the object being matched: <code>UDC</code>. A conversion to <b>int</b> exists, and it is selected.</p>
<p>
During the process of matching arguments, standard conversions can be applied to both the argument and the result of a user-defined conversion. Therefore, the following code works:</p>
<pre><code>void LogToFile( long l );
...
UDC udc;
LogToFile( udc );
</code></pre>
<p>
In the preceding example, the user-defined conversion, <b>operator long</b>, is invoked to convert <code>udc</code> to type <b>long</b>. If no user-defined conversion to type <b>long</b> had been defined, the conversion would have proceeded as follows: Type <code>UDC</code> would have been converted to type <b>int</b> using the user-defined conversion. Then the standard conversion from type <b>int</b> to type <b>long</b> would have been applied to match the argument in the declaration.</p>
<p>
If any user-defined conversions are required to match an argument, the standard conversions are not used when evaluating the best match. This is true even if more than one candidate function requires a user-defined conversion; in such a case, the functions are considered equal. For example:</p>
<pre><code>class UDC1
{
public:
 &nbsp;&nbsp; UDC1( int );&nbsp; // User-defined conversion from int.
};

class UDC2
{
public:
 &nbsp;&nbsp; UDC2( long ); // User-defined conversion from long.
};

...

void Func( UDC1 );
void Func( UDC2 );

...

Func( 1 );
</code></pre>
<p>
Both versions of <code>Func</code> require a user-defined conversion to convert type <b>int</b> to the class type argument. The possible conversions are:
<ul type=disc>
<li>
Convert from type <b>int</b> to type <code>UDC1</code> (a user-defined conversion).<br><br></li>
<li>
Convert from type <b>int</b> to type <b>long</b>; then convert to type <code>UDC2</code> (a two-step conversion).</li>
</ul>
<p>
Even though the second of these requires a standard conversion, as well as the user-defined conversion, the two conversions are still considered equal.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;User-defined conversions are considered conversion by construction or conversion by initialization (conversion function). Both methods are considered equal when considering the best match.</p>
</font></BODY>
</HTML>
