<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C++ Enumeration Declarations</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_c.2b2b_.enumeration_declarations"></a><sup></sup>C++ Enumeration Declarations</h1>
<p>
An enumeration is a distinct integral type that defines named constants. Enumerations are declared using the <b>enum</b> keyword.</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>enum-name</i> :</p>
<p class=indent>
<i>identifier</i></p>
<p class=dt>
<i>enum-specifier</i> :</p>
<p class=indent>
<b>enum</b> <i>identifier</i><sub>opt </sub> <b>{</b>  <i>enum-list</i><sub>opt</sub>  <b>}</b></p>
<p class=dt>
<i>enum-list</i> :</p>
<p class=indent>
<i>enumerator</i><br>
<i>enum-list</i> <b>,</b> <i>enumerator</i></p>
<p class=dt>
<i>enumerator</i> :</p>
<p class=indent>
<i>identifier</i><br>
<i>identifier</i> <i>=</i>  <i>constant-expression</i></p>
<p>
Enumerated types are valuable when an object can assume a known and reasonably limited set of values. Consider the example of the suits from a deck of cards:</p>
<pre><code>class Card
{
public:
 &nbsp;&nbsp; enum Suit
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diamonds,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hearts,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Clubs,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spades
 &nbsp;&nbsp; };
 &nbsp;&nbsp; // Declare two constructors: a default constructor,
 &nbsp;&nbsp; //&nbsp; and a constructor that sets the cardinal and
 &nbsp;&nbsp; //&nbsp; suit value of the new card.
 &nbsp;&nbsp; Card();
 &nbsp;&nbsp; Card( int CardInit, Suit SuitInit );

 &nbsp;&nbsp; // Get and Set functions.
 &nbsp;&nbsp; int&nbsp;&nbsp; GetCardinal();&nbsp;&nbsp;&nbsp;       // Get cardinal value of card.
 &nbsp;&nbsp; int&nbsp;&nbsp; SetCardinal();&nbsp;&nbsp;&nbsp;       // Set cardinal value of card.
 &nbsp;&nbsp; Suit&nbsp; GetSuit();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       // Get suit of card.
 &nbsp;&nbsp; void&nbsp; SetSuit(Suit new_suit);&nbsp; // Set suit of card.
 &nbsp;&nbsp; char *NameOf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       // Get string representation of card.
private:
 &nbsp;&nbsp; Suit&nbsp; suit;
 &nbsp;&nbsp; int&nbsp;&nbsp; cardinalValue;
};

// Define a postfix increment operator for Suit.
inline Card::Suit operator++( Card::Suit &amp;rs, int )
{
 &nbsp;&nbsp; return rs = (Card::Suit)(rs + 1);
}
</code></pre>
<p>
The preceding example defines a class, <code>Card</code>, that contains a nested enumerated type, <code>Suit</code>. To create a pack of cards in a program, use code such as:</p>
<pre><code>Card *Deck[52];
int&nbsp;&nbsp; j = 0;

for( Card::Suit curSuit = Card::Diamonds; curSuit &lt;= Card::Spades;
 &nbsp;&nbsp;&nbsp; curSuit++ )
 &nbsp;&nbsp; for( int i = 1; i &lt;= 13; ++i )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Deck[j++] = new Card( i, curSuit );
</code></pre>
<p>
In the preceding example, the type <code>Suit</code> is nested; therefore, the class name (<code>Card</code>) must be used explicitly in public references. In member functions, however, the class name can be omitted.</p>
<p>
In the first segment of code, the postfix increment operator for <code>Card::Suit</code> is defined. Without a user-defined increment operator, <code>curSuit</code> could not be incremented. For more information about user-defined operators, see <a href="_pluslang_overloaded_operators.htm">Overloaded Operators</a> in Chapter 12.</p>
<p>
Consider the code for the <code>NameOf</code> member function (a better implementation is presented later):</p>
<pre><code>char* Card::NameOf() // Get the name of a card.
{
 &nbsp;&nbsp; static char szName[20];
 &nbsp;&nbsp; static char *Numbers[] =
 &nbsp;&nbsp; { "1", "2", "3", "4", "5", "6", "7", "8", "9",
 &nbsp;&nbsp;&nbsp;&nbsp; "10", "Jack", "Queen", "King"
 &nbsp;&nbsp; };
 &nbsp;&nbsp; static char *Suits[] =
 &nbsp;&nbsp; { "Diamonds", "Hearts", "Clubs", "Spades" };

 &nbsp;&nbsp; if( GetCardinal() &lt; 13)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( szName, Numbers[GetCardinal()] );

 &nbsp;&nbsp; strcat( szName, " of " );

 &nbsp;&nbsp; switch( GetSuit() )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Diamonds, Hearts, Clubs, and Spades do not need explicit
 &nbsp;&nbsp; //&nbsp; class qualifier.
 &nbsp;&nbsp; case Diamonds: strcat( szName, "Diamonds" ); break;
 &nbsp;&nbsp; case Hearts:&nbsp;&nbsp; strcat( szName, "Hearts" );&nbsp;&nbsp; break;
 &nbsp;&nbsp; case Clubs:&nbsp;&nbsp;&nbsp; strcat( szName, "Clubs" );&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case Spades:&nbsp;&nbsp; strcat( szName, "Spades" );&nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return szName;
}
</code></pre>
<p>
An enumerated type is an integral type. The identifiers introduced with the <b>enum</b> declaration can be used wherever constants appear. Normally, the first identifier’s value is 0 (<code>Diamonds</code>, in the preceding example), and the values increase by one for each succeeding identifier. Therefore, the value of <code>Spades</code> is 3.</p>
<p>
Any enumerator in the list, including the first one, can be initialized to a value other than its default value. Suppose the declaration of <code>Suit</code> had been the following:</p>
<pre><code>enum Suit
{
 &nbsp;&nbsp; Diamonds = 5,
 &nbsp;&nbsp; Hearts,
 &nbsp;&nbsp; Clubs = 4,
 &nbsp;&nbsp; Spades
};
</code></pre>
<p>
Then the values of <code>Diamonds</code>, <code>Hearts</code>, <code>Clubs</code>, and <code>Spades</code> would have been 5, 6, 4, and 5, respectively. Note that 5 is used more than once.</p>
<p>
The default values for these enumerators simplify implementation of the <code>NameOf</code> function:</p>
<pre><code>char* Card::NameOf() // Get the name of a card.
{
 &nbsp;&nbsp; static char szName[20];
 &nbsp;&nbsp; static char *Numbers[] =
 &nbsp;&nbsp; { "1", "2", "3", "4", "5", "6", "7", "8", "9",
 &nbsp;&nbsp;&nbsp;&nbsp; "10", "Jack", "Queen", "King"
 &nbsp;&nbsp; };
 &nbsp;&nbsp; static char *Suits[] =
 &nbsp;&nbsp; { "Diamonds", "Hearts", "Clubs", "Spades"};

 &nbsp;&nbsp; if( GetCardinal() &lt; 13)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( szName, Numbers[GetCardinal()] );

 &nbsp;&nbsp; strcat( szName, " of " );

 &nbsp;&nbsp; strcat( szName, Suits[GetSuit()] );

 &nbsp;&nbsp; return szName;
}
</code></pre>
<p>
The accessor function <code>GetSuit</code> returns type <code>Suit</code>, an enumerated type. Because enumerated types are integral types, they can be used as arguments to the array subscript operator. (For more information, see <a href="_pluslang_subscript_operator.htm">Subscript Operator</a> in Chapter 4.)</p>
</font></BODY>
</HTML>
