<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Cont</title></head>
<body bgcolor=white>

<h2><a name="Cont">Cont</a></h2>
<META NAME="MS-HKWD" CONTENT="Cont">
<p><a href="lib_cont_ContCCallocator_type.htm#Cont::allocator_type"><code><b>allocator_type</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCbegin.htm#Cont::begin"><code><b>begin</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCclear.htm#Cont::clear"><code><b>clear</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCconst_iterator.htm#Cont::const_iterator"><code><b>const_iterator</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCconst_reference.htm#Cont::const_reference"><code><b>const_reference</b></code></a><code><b> &#183; 
</b></code><a href="lib_cont_ContCCconst_reverse_iterator.htm#Cont::const_reverse_iterator"><code><b>const_reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCdifference_type.htm#Cont::difference_type"><code><b>difference_type</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCempty.htm#Cont::empty"><code><b>empty</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCend.htm#Cont::end"><code><b>end</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCerase.htm#Cont::erase"><code><b>erase</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCget_allocator.htm#Cont::get_allocator"><code><b>get_allocator</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCiterator.htm#Cont::iterator"><code><b>iterator</b></code></a><code><b> 
&#183; </b></code><a href="lib_cont_ContCCmax_size.htm#Cont::max_size"><code><b>max_size</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCrbegin.htm#Cont::rbegin"><code><b>rbegin</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCreference.htm#Cont::reference"><code><b>reference</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCrend.htm#Cont::rend"><code><b>rend</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCreverse_iterator.htm#Cont::reverse_iterator"><code><b>reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCsize.htm#Cont::size"><code><b>size</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCsize_type.htm#Cont::size_type"><code><b>size_type</b></code></a><code><b> &#183; </b></code><a href="lib_cont_ContCCswap.htm#Cont::swap"><code><b>swap</b></code></a><code><b> &#183; 
</b></code><a href="lib_cont_ContCCvalue_type.htm#Cont::value_type"><code><b>value_type</b></code></a><code><b> </b></code></p>
<pre><code>template&lt;class T, class A = allocator&lt;T&gt; &gt;
    class <b>Cont</b> {
public:
    typedef A <a href="lib_cont_ContCCallocator_type.htm#Cont::allocator_type"><b>allocator_type</b></a>;
    typedef T0 <a href="lib_cont_ContCCsize_type.htm#Cont::size_type"><b>size_type</b></a>;
    typedef T1 <a href="lib_cont_ContCCdifference_type.htm#Cont::difference_type"><b>difference_type</b></a>;
    typedef T2 <a href="lib_cont_ContCCreference.htm#Cont::reference"><b>reference</b></a>;
    typedef T3 <a href="lib_cont_ContCCconst_reference.htm#Cont::const_reference"><b>const_reference</b></a>;
    typedef T4 <a href="lib_cont_ContCCvalue_type.htm#Cont::value_type"><b>value_type</b></a>;
    typedef T5 <a href="lib_cont_ContCCiterator.htm#Cont::iterator"><b>iterator</b></a>;
    typedef T6 <a href="lib_cont_ContCCconst_iterator.htm#Cont::const_iterator"><b>const_iterator</b></a>;
    typedef T7 <a href="lib_cont_ContCCreverse_iterator.htm#Cont::reverse_iterator"><b>reverse_iterator</b></a>;
    typedef T8 <a href="lib_cont_ContCCconst_reverse_iterator.htm#Cont::const_reverse_iterator"><b>const_reverse_iterator</b></a>;
    iterator <a href="lib_cont_ContCCbegin.htm#Cont::begin"><b>begin</b></a>();
    const_iterator <a href="lib_cont_ContCCbegin.htm#Cont::begin"><b>begin</b></a>() const;
    iterator <a href="lib_cont_ContCCend.htm#Cont::end"><b>end</b></a>();
    const_iterator <a href="lib_cont_ContCCend.htm#Cont::end"><b>end</b></a>() const;
    reverse_iterator <a href="lib_cont_ContCCrbegin.htm#Cont::rbegin"><b>rbegin</b></a>();
    const_reverse_iterator <a href="lib_cont_ContCCrbegin.htm#Cont::rbegin"><b>rbegin</b></a>() const;
    reverse_iterator <a href="lib_cont_ContCCrend.htm#Cont::rend"><b>rend</b></a>();
    const_reverse_iterator <a href="lib_cont_ContCCrend.htm#Cont::rend"><b>rend</b></a>() const;
    size_type <a href="lib_cont_ContCCsize.htm#Cont::size"><b>size</b></a>() const;
    size_type <a href="lib_cont_ContCCmax_size.htm#Cont::max_size"><b>max_size</b></a>() const;
    bool <a href="lib_cont_ContCCempty.htm#Cont::empty"><b>empty</b></a>() const;
    A <a href="lib_cont_ContCCget_allocator.htm#Cont::get_allocator"><b>get_allocator</b></a>() const;
    iterator <a href="lib_cont_ContCCerase.htm#Cont::erase"><b>erase</b></a>(iterator it);
    iterator <a href="lib_cont_ContCCerase.htm#Cont::erase"><b>erase</b></a>(iterator first, iterator last);
    void <a href="lib_cont_ContCCclear.htm#Cont::clear"><b>clear</b></a>();
    void <a href="lib_cont_ContCCswap.htm#Cont::swap"><b>swap</b></a>(Cont x);
protected:
    A allocator;
    };</code></pre>
<p>The template class describes an object that controls a varying-length sequence of elements, typically of <b>type </b><code><b>T</b></code>. The 
sequence is stored in different ways, depending on the actual container.</p>
<p>The object allocates and frees storage for the sequence it controls through a protected object named <a name="Cont::allocator"><code><b>allocator</b></code></a>, of 
<b>class </b><code><b>A</b></code>. Such an <a href="MEMORY_allocator.htm#allocator object">allocator object</a> must have the same external interface as an object of template class <a href="MEMORY_allocator.htm#allocator"><code>allocator</code></a>. 
Note that <code>allocator</code> is not copied when the object is assigned. All constructors store an allocator argument (or, for 
the copy constructor, <code>x.</code><a href="lib_cont_ContCCget_allocator.htm#Cont::get_allocator"><code>get_allocator</code></a><code>()</code>) in <code>allocator</code> and initialize the controlled sequence.</p>
</body>
</html>
