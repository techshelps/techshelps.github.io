<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Simple Assignment</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="vcconsimpleassignment"></a>Simple Assignment</h1>
<p>
The simple assignment operator (=) causes the value of the second operand to be stored in the object specified by the first operand. If both objects are of arithmetic types, the right operand is converted to the type of the left, prior to storing the value.</p>
<p>
Objects of const and volatile types can be assigned to l-values of types that are just volatile or that are neither const nor volatile.</p>
<p>
Assignment to objects of class type (struct, union, and class types) is performed by a function named operator=. The default behavior of this operator function is to perform a bitwise copy; however, this behavior can be modified using overloaded operators. (See <a href="_pluslang_overloaded_operators.htm">Overloaded Operators</a> in Chapter 12 for more information.)</p>
<p>
An object of any unambiguously derived class from a given base class can be assigned to an object of the base class. The reverse is not true because there is an implicit conversion from derived class to base class but not from base class to derived class. For example:</p>
<pre><code>#include &lt;iostream.h&gt;

class ABase
{
public:
 &nbsp;&nbsp; ABase() { cout &lt;&lt; "constructing ABase\n"; }
};

class ADerived : public ABase
{
public:
 &nbsp;&nbsp; ADerived() { cout &lt;&lt; "constructing ADerived\n"; }
};

void main()
{
 &nbsp;&nbsp; ABase aBase;
 &nbsp;&nbsp; ADerived aDerived;

 &nbsp;&nbsp; aBase = aDerived; // OK
 &nbsp;&nbsp; aDerived = aBase; // Error
}
</code></pre>
<p>
Assignments to reference types behave as if the assignment were being made to the object to which the reference points.</p>
<p>
For class-type objects, assignment is different from initialization. To illustrate how different assignment and initialization can be, consider the code</p>
<pre><code>UserType1 A;
UserType2 B = A;
</code></pre>
<p>
The preceding code shows an initializer; it calls the constructor for <code>UserType1</code> that takes an argument of type <code>UserType1</code>. Given the code</p>
<pre><code>UserType1 A;
UserType2 B;

B = A;
</code></pre>
<p>
the assignment statement</p>
<pre><code>B = A; 
</code></pre>
<p>
can have one of the following effects:
<ul type=disc>
<li>
Call the function operator= for <code>UserType2</code>, provided operator=&nbsp; is provided with a <code>UserType1</code> argument.<br><br></li>
<li>
Call the explicit conversion function <code>UserType1::operator UserType2</code>, if such a function exists.<br><br></li>
<li>
Call a constructor <code>UserType2::UserType2</code>, provided such a constructor exists, that takes a <code>UserType1</code> argument and copies the result.</li>
</ul>
</font></BODY>
</HTML>
