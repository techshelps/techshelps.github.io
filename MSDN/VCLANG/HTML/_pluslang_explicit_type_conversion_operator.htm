<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Explicit Type Conversion Operator</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_explicit_type_conversion_operator"></a><sup></sup>Explicit Type Conversion Operator</h1>
<p>
C++ allows explicit type conversion using a syntax similar to the function-call syntax. A <i>simple-type-name</i> followed by an <i>expression-list</i> enclosed in parentheses constructs an object of the specified type using the specified expressions. The following example shows an explicit type conversion to type int:</p>
<pre><code>int i = int( d );
</code></pre>
<p>
The following example uses a modified version of the <code>Point</code> class defined in <a href="_pluslang_function.2d.call_results.htm">Function-Call Results</a>.</p>
<pre><code>#include &lt;iostream.h&gt;

class Point
{
public:
 &nbsp;&nbsp; // Define default constructor.
 &nbsp;&nbsp; Point() { _x = _y = 0; }
 &nbsp;&nbsp; // Define another constructor.
 &nbsp;&nbsp; Point( int X, int Y ) { _x = X; _y = Y; }

 &nbsp;&nbsp; // Define "accessor" functions as
 &nbsp;&nbsp; // reference types.
 &nbsp;&nbsp; unsigned&amp; x() { return _x; }
 &nbsp;&nbsp; unsigned&amp; y() { return _y; }
 &nbsp;&nbsp; void Show()&nbsp;&nbsp; { cout &lt;&lt; "x = " &lt;&lt; _x &lt;&lt; ", "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "y = " &lt;&lt; _y &lt;&lt; "\n"; }
private:
 &nbsp;&nbsp; unsigned _x;
 &nbsp;&nbsp; unsigned _y;
};

void main()
{
 &nbsp;&nbsp; Point Point1, Point2;

 &nbsp;&nbsp; // Assign Point1 the explicit conversion
 &nbsp;&nbsp; //&nbsp; of ( 10, 10 ).
 &nbsp;&nbsp; Point1 = Point( 10, 10 );

 &nbsp;&nbsp; // Use x() as an l-value by assigning an explicit
 &nbsp;&nbsp; //&nbsp; conversion of 20 to type unsigned.
 &nbsp;&nbsp; Point1.x() = unsigned( 20 );
 &nbsp;&nbsp; Point1.Show();

 &nbsp;&nbsp; // Assign Point2 the default Point object.
 &nbsp;&nbsp; Point2 = Point();
 &nbsp;&nbsp; Point2.Show();
}
</code></pre>
<p>
The output from this program is:</p>
<pre><code>x = 20, y = 10
x = 0, y = 0
</code></pre>
<p>
Although the preceding example demonstrates explicit type conversion using constants, the same technique works to perform these conversions on objects. The following code fragment demonstrates this:</p>
<pre><code>int i = 7;
float d;

d = float( i );
</code></pre>
<p>
Explicit type conversions can also be specified using the “cast” syntax. The previous example, rewritten using the cast syntax, is:</p>
<pre><code>d = (float)i;
</code></pre>
<p>
Both cast and function-style conversions have the same results when converting from single values. However, in the function-style syntax, you can specify more than one argument for conversion. This difference is important for user-defined types. Consider a <code>Point</code> class and its conversions:</p>
<pre><code>struct Point
{
 &nbsp;&nbsp; Point( short x, short y ) { _x = x; _y = y; }
 &nbsp;&nbsp; ...
 &nbsp;&nbsp; short _x, _y;
};
...
Point pt = Point( 3, 10 );
</code></pre>
<p>
The preceding example, which uses function-style conversion, shows how to convert two values (one for <i>x</i> and one for <i>y</i>) to the user-defined type <code>Point</code>.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Use the explicit type conversions with care, since they override the C++ compiler’s built-in type checking.</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>cast-expression</i> :</p>
<p class=indent>
<i>unary-expression</i><br>
( <i>type-name</i> ) <i>cast-expression</i></p>
<p>
The cast notation must be used for conversions to types that do not have a <i>simple-type-name</i> (pointer or reference types, for example). Conversion to types that can be expressed with a <i>simple-type-name</i> can be written in either form. See <a href="_pluslang_c.2b2b_.type_specifiers.htm">Type Specifiers</a> in Chapter 6 for more information about what constitutes a <i>simple-type-name</i>.</p>
<p>
Type definition within casts is illegal. </p>
</font></BODY>
</HTML>
