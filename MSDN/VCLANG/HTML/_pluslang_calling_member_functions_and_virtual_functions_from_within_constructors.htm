<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calling Member Functions and Virtual Functions from Within Constructors</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_calling_member_functions_and_virtual_functions_from_within_constructors"></a><sup></sup>Calling Member Functions and Virtual Functions from Within Constructors</h1>
<p>
It is usually safe to call any member function from within a constructor because the object has been completely set up (virtual tables have been initialized and so on) prior to the execution of the first line of user code. However, it is potentially unsafe for a member function to call a virtual member function for an abstract base class during construction or destruction. </p>
<p>
Constructors can call virtual functions. When virtual functions are called, the function invoked is the function defined for the constructor’s own class (or inherited from its bases). The following example shows what happens when a virtual function is called from within a constructor:</p>
<pre><code>#include &lt;iostream.h&gt;

class Base
{
public:
 &nbsp;&nbsp; Base();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Default constructor.
 &nbsp;&nbsp; virtual void f();&nbsp;&nbsp; // Virtual member function.
};

Base::Base()
{
 &nbsp;&nbsp; cout &lt;&lt; "Constructing Base sub-object\n";
 &nbsp;&nbsp; f();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Call virtual member function
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; from inside constructor.

void Base::f()
{
 &nbsp;&nbsp; cout &lt;&lt; "Called Base::f()\n";
}

class Derived : public Base
{
public:
 &nbsp;&nbsp; Derived();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Default constructor.
 &nbsp;&nbsp; void f();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Implementation of virtual
};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; function f for this class.

Derived::Derived()
{
 &nbsp;&nbsp; cout &lt;&lt; "Constructing Derived object\n";
}

void Derived::f()
{
 &nbsp;&nbsp; cout &lt;&lt; "Called Derived::f()\n";
}

void main()
{
 &nbsp;&nbsp; Derived d;
}
</code></pre>
<p>
When the preceding program is run, the declaration <code>Derived d</code> causes the following sequence of events:
<ol>
<li>
The constructor for class <code>Derived</code> (<code>Derived::Derived</code>) is called.<br><br></li>
<li>
Prior to entering the body of the <code>Derived</code> class’s constructor, the constructor for class <code>Base</code> (<code>Base::Base</code>) is called.<br><br></li>
<li>
<code>Base::Base</code> calls the function <code>f</code>, which is a virtual function. Ordinarily, <code>Derived::f</code> would be called because the object <code>d</code> is of type <code>Derived</code>. Because the <code>Base::Base</code> function is a constructor, the object is not yet of the <code>Derived</code> type, and <code>Base::f</code> is called.</li>
</ol>
</font></BODY>
</HTML>
