<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Converting Pointer Types</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_converting_pointer_types"></a><sup></sup>Converting Pointer Types</h1>
<p>
A pointer to one object type can be explicitly converted to a pointer of another object type. A pointer declared as void * is considered a pointer to any object type.</p>
<p>
A pointer to a base class can be explicitly converted to a pointer to a derived class as long as these conditions are met:
<ul type=disc>
<li>
There is an unambiguous conversion.<br><br></li>
<li>
The base class is not declared as virtual at any point.</li>
</ul>
<p>
Because conversion to type void * can change the representation of an object, there is no guarantee that the conversion <i>type1</i>*&nbsp; void *&nbsp; <i>type2</i>* is equivalent to the conversion <i>type1</i>*&nbsp; <i>type2</i>* (which is a change in value only).</p>
<p>
When such a conversion is performed, the result is a pointer to the subobject of the original object representing the base class.</p>
<p>
See Chapter 9, <a href="_pluslang_derived_classes.htm">Derived Classes</a>, for more information about ambiguity and virtual base classes.</p>
<p>
C++ allows explicit conversions of pointers to objects or functions to type void *.</p>
<p>
Pointers to object types can be explicitly converted to pointers to functions if the function pointer type has enough bits to accommodate the pointer to object type.</p>
<p>
A pointer to a const object can be explicitly converted to a pointer not of const type. The result of this conversion points to the original object. An object of const type, or a reference to an object of const type, can be cast to a reference to a type that is not const. The result is a reference to the original object. The original object was probably declared as const because it was to remain constant across the duration of the program. Therefore, an explicit conversion defeats this safeguard, allowing modification of such objects. The behavior in such cases is undefined.</p>
<p>
A pointer to an object of volatile type can be cast to a pointer to a type that is not volatile. The result of this conversion refers to the original object. Similarly, an object of volatile type can be cast to a reference to a type that is not volatile.</p>
</font></BODY>
</HTML>
