<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>vector</title></head>
<body bgcolor=white>

<h2><a name="vector">vector</a></h2>
<META NAME="MS-HKWD" CONTENT="vector">
<p><a href="VECTOR_vectorCCallocator_type.htm#vector::allocator_type"><code><b>allocator_type</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCassign.htm#vector::assign"><code><b>assign</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCat.htm#vector::at"><code><b>at</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCback.htm#vector::back"><code><b>back</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCbegin.htm#vector::begin"><code><b>begin</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCcapacity.htm#vector::capacity"><code><b>capacity</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCclear.htm#vector::clear"><code><b>clear</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCconst_iterator.htm#vector::const_iterator"><code><b>const_iterator</b></code></a><code><b> &#183; 
</b></code><a href="VECTOR_vectorCCconst_reference.htm#vector::const_reference"><code><b>const_reference</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCconst_reverse_iterator.htm#vector::const_reverse_iterator"><code><b>const_reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCdifference_type.htm#vector::difference_type"><code><b>difference_type</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCempty.htm#vector::empty"><code><b>empty</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCend.htm#vector::end"><code><b>end</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCerase.htm#vector::erase"><code><b>erase</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCfront.htm#vector::front"><code><b>front</b></code></a><code><b> 
&#183; </b></code><a href="VECTOR_vectorCCget_allocator.htm#vector::get_allocator"><code><b>get_allocator</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCinsert.htm#vector::insert"><code><b>insert</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCiterator.htm#vector::iterator"><code><b>iterator</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCmax_size.htm#vector::max_size"><code><b>max_size</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCoperatorCD.htm#vector::operator[]"><code><b>operator[]</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCpop_back.htm#vector::pop_back"><code><b>pop_back</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCpush_back.htm#vector::push_back"><code><b>push_back</b></code></a><code><b> &#183; 
</b></code><a href="VECTOR_vectorCCrbegin.htm#vector::rbegin"><code><b>rbegin</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCreference.htm#vector::reference"><code><b>reference</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCrend.htm#vector::rend"><code><b>rend</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCreserve.htm#vector::reserve"><code><b>reserve</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCresize.htm#vector::resize"><code><b>resize</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCreverse_iterator.htm#vector::reverse_iterator"><code><b>reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCsize.htm#vector::size"><code><b>size</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCsize_type.htm#vector::size_type"><code><b>size_type</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCswap.htm#vector::swap"><code><b>swap</b></code></a><code><b> 
&#183; </b></code><a href="VECTOR_vectorCCvalue_type.htm#vector::value_type"><code><b>value_type</b></code></a><code><b> &#183; </b></code><a href="VECTOR_vectorCCvector.htm#vector::vector"><code><b>vector</b></code></a><code><b> </b></code></p>
<pre><code>template&lt;class T, class A = allocator&lt;T&gt; &gt;
    class <b>vector</b> {
public:
    typedef A <a href="VECTOR_vectorCCallocator_type.htm#vector::allocator_type"><b>allocator_type</b></a>;
    typedef A::size_type <a href="VECTOR_vectorCCsize_type.htm#vector::size_type"><b>size_type</b></a>;
    typedef A::difference_type <a href="VECTOR_vectorCCdifference_type.htm#vector::difference_type"><b>difference_type</b></a>;
    typedef A::reference <a href="VECTOR_vectorCCreference.htm#vector::reference"><b>reference</b></a>;
    typedef A::const_reference <a href="VECTOR_vectorCCconst_reference.htm#vector::const_reference"><b>const_reference</b></a>;
    typedef A::value_type <a href="VECTOR_vectorCCvalue_type.htm#vector::value_type"><b>value_type</b></a>;
    typedef T0 <a href="VECTOR_vectorCCiterator.htm#vector::iterator"><b>iterator</b></a>;
    typedef T1 <a href="VECTOR_vectorCCconst_iterator.htm#vector::const_iterator"><b>const_iterator</b></a>;
    typedef reverse_iterator&lt;iterator, value_type,
        reference, A::pointer, difference_type&gt;
            <a href="VECTOR_vectorCCreverse_iterator.htm#vector::reverse_iterator"><b>reverse_iterator</b></a>;
    typedef reverse_iterator&lt;const_iterator, value_type,
        const_reference, A::const_pointer, difference_type&gt;
            <a href="VECTOR_vectorCCconst_reverse_iterator.htm#vector::const_reverse_iterator"><b>const_reverse_iterator</b></a>;
    explicit <a href="VECTOR_vectorCCvector.htm#vector::vector"><b>vector</b></a>(const A&amp; al = A());
    explicit <a href="VECTOR_vectorCCvector.htm#vector::vector"><b>vector</b></a>(size_type n, const T&amp; v = T(), const A&amp; al = A());
    <a href="VECTOR_vectorCCvector.htm#vector::vector"><b>vector</b></a>(const vector&amp; x);
    <a href="VECTOR_vectorCCvector.htm#vector::vector"><b>vector</b></a>(const_iterator first, const_iterator last,
        const A&amp; al = A());
    void <a href="VECTOR_vectorCCreserve.htm#vector::reserve"><b>reserve</b></a>(size_type n);
    size_type <a href="VECTOR_vectorCCcapacity.htm#vector::capacity"><b>capacity</b></a>() const;
    iterator <a href="VECTOR_vectorCCbegin.htm#vector::begin"><b>begin</b></a>();
    const_iterator <a href="VECTOR_vectorCCbegin.htm#vector::begin"><b>begin</b></a>() const;
    iterator <a href="VECTOR_vectorCCend.htm#vector::end"><b>end</b></a>();
    iterator <a href="VECTOR_vectorCCend.htm#vector::end"><b>end</b></a>() const;
    reverse_iterator <a href="VECTOR_vectorCCrbegin.htm#vector::rbegin"><b>rbegin</b></a>();
    const_reverse_iterator <a href="VECTOR_vectorCCrbegin.htm#vector::rbegin"><b>rbegin</b></a>() const;
    reverse_iterator <a href="VECTOR_vectorCCrend.htm#vector::rend"><b>rend</b></a>();
    const_reverse_iterator <a href="VECTOR_vectorCCrend.htm#vector::rend"><b>rend</b></a>() const;
    void <a href="VECTOR_vectorCCresize.htm#vector::resize"><b>resize</b></a>(size_type n, T x = T());
    size_type <a href="VECTOR_vectorCCsize.htm#vector::size"><b>size</b></a>() const;
    size_type <a href="VECTOR_vectorCCmax_size.htm#vector::max_size"><b>max_size</b></a>() const;
    bool <a href="VECTOR_vectorCCempty.htm#vector::empty"><b>empty</b></a>() const;
    A <a href="VECTOR_vectorCCget_allocator.htm#vector::get_allocator"><b>get_allocator</b></a>() const;
    reference <a href="VECTOR_vectorCCat.htm#vector::at"><b>at</b></a>(size_type pos);
    const_reference <a href="VECTOR_vectorCCat.htm#vector::at"><b>at</b></a>(size_type pos) const;
    reference <a href="VECTOR_vectorCCoperatorCD.htm#vector::operator[]"><b>operator[]</b></a>(size_type pos);
    const_reference <a href="VECTOR_vectorCCoperatorCD.htm#vector::operator[]"><b>operator[]</b></a>(size_type pos);
    reference <a href="VECTOR_vectorCCfront.htm#vector::front"><b>front</b></a>();
    const_reference <a href="VECTOR_vectorCCfront.htm#vector::front"><b>front</b></a>() const;
    reference <a href="VECTOR_vectorCCback.htm#vector::back"><b>back</b></a>();
    const_reference <a href="VECTOR_vectorCCback.htm#vector::back"><b>back</b></a>() const;
    void <a href="VECTOR_vectorCCpush_back.htm#vector::push_back"><b>push_back</b></a>(const T&amp; x);
    void <a href="VECTOR_vectorCCpop_back.htm#vector::pop_back"><b>pop_back</b></a>();
    void <a href="VECTOR_vectorCCassign.htm#vector::assign"><b>assign</b></a>(const_iterator first, const_iterator last);
    void <a href="VECTOR_vectorCCassign.htm#vector::assign"><b>assign</b></a>(size_type n, const T&amp; x = T());
    iterator <a href="VECTOR_vectorCCinsert.htm#vector::insert"><b>insert</b></a>(iterator it, const T&amp; x = T());
    void <a href="VECTOR_vectorCCinsert.htm#vector::insert"><b>insert</b></a>(iterator it, size_type n, const T&amp; x);
    void <a href="VECTOR_vectorCCinsert.htm#vector::insert"><b>insert</b></a>(iterator it,
        const_iterator first, const_iterator last);
    iterator <a href="VECTOR_vectorCCerase.htm#vector::erase"><b>erase</b></a>(iterator it);
    iterator <a href="VECTOR_vectorCCerase.htm#vector::erase"><b>erase</b></a>(iterator first, iterator last);
    void <a href="VECTOR_vectorCCclear.htm#vector::clear"><b>clear</b></a>();
    void <a href="VECTOR_vectorCCswap.htm#vector::swap"><b>swap</b></a>(vector x);
protected:
    A allocator;
    };</code></pre>
<p>The template class describes an object that controls a varying-length sequence of elements of <b>type </b><code><b>T</b></code>. The sequence is 
stored as an array of <code><b>T</b></code>.</p>
<p>The object allocates and frees storage for the sequence it controls through a protected object named <a name="vector::allocator"><code><b>allocator</b></code></a>, of 
<b>class </b><code><b>A</b></code>. Such an <a href="MEMORY_allocator.htm#allocator object">allocator object</a> must have the same external interface as an object of template class <a href="MEMORY_allocator.htm#allocator"><code>allocator</code></a>. 
Note that <code>allocator</code> is not copied when the object is assigned.</p>
<p><a name="vector reallocation"><b>Vector reallocation</b></a> occurs when a member function must grow the controlled sequence beyond its current storage 
<a href="VECTOR_vectorCCcapacity.htm#vector::capacity">capacity</a>. Other insertions and erasures may alter various storage addresses within the sequence. In all such cases, 
iterators or references that point at altered portions of the controlled sequence become <a name="invalid vector iterators"><b>invalid</b></a>.</p>
</body>
</html>
