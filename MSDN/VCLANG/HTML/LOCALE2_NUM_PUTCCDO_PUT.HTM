<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>num_put::do_put</title></head>
<body bgcolor=white>

<h3><a name="num_put::do_put">num_put::do_put</a></h3>
<META NAME="MS-HKWD" CONTENT="do_put">
<pre><code>virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, long val) const;
virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, unsigned long val) const;
virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, double val) const;
virtual iter_type <b>do_put</b>(iter_type nextp ios_base&amp; x,
    E fill, long double val) const;
virtual iter_type <b>do_put</b>(iter_type nextp ios_base&amp; x,
    E fill, const void *val) const;
virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, bool val) const;</code></pre>
<p>The first virtual protected member function generates sequential elements beginning at <code>next</code> to produce an <a name="integer output field"><b>integer 
output field</b></a> from the value of <code>val</code>. The function returns an iterator designating the next place to insert an element 
beyond the generated integer output field.</p>
<p>The integer output field is generated by the same rules used by the print functions for generating a series of <i>char</i> 
elements to a file. (Each such <i>char</i> element is assumed to map to an equivalent element of type <code>E</code> by a simple, 
one-to-one, mapping.) Where a print function pads a field with either spaces or the digit <code>0</code>, however, <code>do_put</code> instead 
uses <code>fill</code>. The equivalent print conversion specification is determined as follows:</p>
<ul>
<li>If <code>x.</code><a href="IOS_ios_baseCCflags.htm#ios_base::flags"><code>flags</code></a><code>() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::basefield"><code>basefield</code></a><code> == ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::oct"><code>oct</code></a>, the conversion specification is <code>lo</code>.</li>
<li>If <code>x.flags() &amp; ios_base::basefield == ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::hex"><code>hex</code></a>, the conversion specification is <code>lx</code>.</li>
<li>Otherwise, the conversion specification is <code>ld</code>.</li>
</ul>
<p>If <code>x.</code><a href="IOS_ios_baseCCwidth.htm#ios_base::width"><code>width</code></a><code>()</code> is nonzero, a field width of this value is prepended. The function then calls <code>x.width(0)</code> to reset the field 
width to zero.</p>
<p><a name="padding"><b>Padding</b></a> occurs only if the minimum number of elements <code>N</code> required to specify the output field is less than <code>x.</code><a href="IOS_ios_baseCCwidth.htm#ios_base::width"><code>width</code></a><code>()</code>. 
Such padding consists of a sequence of <code>N - width()</code> copies of <code>fill</code>. Padding then occurs as follows:</p>
<ul>
<li>If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::adjustfield"><code>adjustfield</code></a><code> == ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::left"><code>left</code></a>, the flag <code>-</code> is prepended. (Padding occurs 
after the generated text.) </li>
<li>If <code>x.flags() &amp; ios_base::adjustfield == ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::internal"><code>internal</code></a>, the flag <code>0</code> is prepended. (For a 
numeric output field, padding occurs where the print functions pad with <code>0</code>.)</li>
<li>Otherwise, no additional flag is prepended. (Padding occurs before the generated sequence.) </li>
</ul>
<p>Finally:</p>
<ul>
<li>If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::showpos"><code>showpos</code></a> is nonzero, the flag <code>+</code> is prepended to the conversion specification.</li>
<li>If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::showbase"><code>showbase</code></a> is nonzero, the flag <code>#</code> is prepended to the conversion specification.</li>
</ul>
<p>The format of an integer output field is further determined by the <a href="LOCALE2_locale.htm#locale facet">locale facet</a> <code>fac</code> returned by the call <a href="LOCALE2_use_facet.htm#use_facet"><code>use_facet</code></a><code> 
&lt;</code><a href="LOCALE2_numpunct.htm#numpunct"><code>numpunct</code></a><code>&lt;E&gt;(x. </code><a href="IOS_ios_baseCCgetloc.htm#ios_base::getloc"><code>getloc</code></a><code>())</code>. Specifically: </p>
<ul>
<li><code>fac.</code><a href="LOCALE2_numpunctCCgrouping.htm#numpunct::grouping"><code>grouping</code></a><code>()</code> determines how digits are grouped to the left of any decimal point</li>
<li><code>fac.</code><a href="LOCALE2_numpunctCCthousands_sep.htm#numpunct::thousands_sep"><code>thousands_sep</code></a><code>()</code> determines the sequence that separates groups of digits to the left of any decimal point</li>
</ul>
<p>If no grouping constraints are imposed by <code>fac.grouping()</code> (its first element has the value <code>CHAR_MAX</code>) then no 
instances of <code>fac.thousands_sep()</code> are generated in the output field. Otherwise, separators are inserted after the 
print conversion occurs.</p>
<p>The second virtual protected member function:</p>
<pre><code>virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, unsigned long val) const;</code></pre>
<p>behaves the same as the first, except that it replaces a conversion specification of <code>ld</code> with <code>lu</code>.</p>
<p>The third virtual protected member function:</p>
<pre><code>virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, double val) const;</code></pre>
<p>behaves the same as the first, except that it produces a <a name="floating-point output field"><b>floating-point output field</b></a> from the value of <code>val</code>. 
<code>fac.</code><a href="LOCALE2_numpunctCCdecimal_point.htm#numpunct::decimal_point"><code>decimal_point</code></a><code>()</code> determines the sequence that separates the integer digits from the fraction digits. The 
equivalent print conversion specifier is determined as follows:</p>
<ul>
<li>If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::floatfield"><code>floatfield</code></a><code> == ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::fixed"><code>fixed</code></a>, the conversion specification is <code>lf</code>.</li>
<li>If <code>x.flags() &amp; ios_base::floatfield == ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::scientific"><code>scientific</code></a>, the conversion specification is <code>le</code>. 
If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::uppercase"><code>uppercase</code></a> is nonzero, <code>e</code> is replaced with <code>E</code>.</li>
<li>Otherwise, the conversion specification is <code>lg</code>. If <code>x.flags() &amp; ios_base::uppercase</code> is nonzero, <code>g</code> is 
replaced with <code>G</code>.</li>
</ul>
<p>If <code>x.flags() &amp; ios_base::fixed</code> is nonzero, or if <code>x.</code><a href="IOS_ios_baseCCprecision.htm#ios_base::precision"><code>precision</code></a><code>()</code> is greater than zero, a precision with the value 
<code>x.precision()</code> is prepended to the conversion specification. Any <a href="LOCALE2_num_putCCdo_put.htm#padding">padding</a> behaves the same as for an integer output 
field. The padding character is <code>fill</code>. Finally:</p>
<ul>
<li>If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::showpos"><code>showpos</code></a> is nonzero, the flag <code>+</code> is prepended to the conversion specification.</li>
<li>If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::showpoint"><code>showpoint</code></a> is nonzero, the flag <code>#</code> is prepended to the conversion specification.</li>
</ul>
<p>The fourth virtual protected member function:</p>
<pre><code>virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, long double val) const;</code></pre>
<p>behaves the same as the third, except that the qualifier <code>l</code> in the conversion specification is replaced with <code>L</code>.</p>
<p>The fifth virtual protected member function:</p>
<pre><code>virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, const void *val) const;</code></pre>
<p>behaves the same as the first, except that the conversion specification is <code>p</code>, plus any qualifier needed to specify padding.</p>
<p>The sixth virtual protected member function:</p>
<pre><code>virtual iter_type <b>do_put</b>(iter_type next, ios_base&amp; x,
    E fill, bool val) const;</code></pre>
<p>behaves the same as the first, except that it generates a <a name="boolean output field"><b>Boolean output field</b></a> from <code>val</code>.</p>
<p>A Boolean output field takes one of two forms. If <code>x.flags() &amp; ios_base::</code><a href="IOS_ios_baseCCfmtflags.htm#ios_base::boolalpha"><code>boolalpha</code></a> is false, the generated 
sequence is either <code>0</code> (for false) or <code>1</code> (for true). Otherwise, the generated sequence is either <code>fac.</code><a href="LOCALE2_numpunctCCfalsename.htm#numpunct::falsename"><code>falsename</code></a><code>()</code> (for 
false), or <code>fac.</code><a href="LOCALE2_numpunctCCtruename.htm#numpunct::truename"><code>truename</code></a><code>()</code> (for true).</p>
</body>
</html>
