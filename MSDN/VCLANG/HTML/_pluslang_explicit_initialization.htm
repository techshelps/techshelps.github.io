<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Explicit Initialization</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_explicit_initialization"></a><sup></sup>Explicit Initialization</h1>
<p>
C++ supports two forms of explicit initialization.
<ul type=disc>
<li>
Supplying an initializer list in parentheses:<pre><code>String sFileName( "FILE.DAT" );
</code></pre>
<p class=tl>
The items in the parenthesized list are considered arguments to the class constructor. This form of initialization enables initialization of an object with more than one value and can also be used in conjunction with the <b>new</b> operator. For example:</P><pre><code>Rect *pRect = new Rect( 10, 15, 24, 97 );
</code></pre>
</li>
<li>
Supplying a single initializer using the equal-sign initialization syntax. For example:<pre><code>String sFileName = "FILE.DAT";
</code></pre>
<p class=tl>
Although the preceding example works the same way as the example shown for <code>String</code> in the first list item, the syntax is not adaptable to use with objects allocated on the free store.</P><p class=tl>
The single expression on the right of the equal sign is taken as the argument to the class’s copy constructor; therefore, it must be a type that can be converted to the class type.</P><p class=tl>
Note that because the equal sign (<b>=</b>) in the context of initialization is different from an assignment operator, overloading <b>operator=</b> has no effect on initialization.</P></li>
</ul>
<p>
The equal-sign initialization syntax is different from the function-style syntax, even though the generated code is identical in most cases. The difference is that when the equal-sign syntax is used, the compiler has to behave as if the following sequence of events were taking place:
<ul type=disc>
<li>
Creating a temporary object of the same type as the object being initialized.<br><br></li>
<li>
Copying the temporary object to the object.</li>
</ul>
<p>
The constructor must be accessible before the compiler can perform these steps. Even though the compiler can eliminate the temporary creation and copy steps in most cases, an inaccessible copy constructor causes equal-sign initialization to fail. Consider the following example:</p>
<pre><code>class anInt
{
 &nbsp;&nbsp; anInt( const anInt&amp; );&nbsp;&nbsp;&nbsp; //&nbsp; Private copy constructor.
public:
 &nbsp;&nbsp; anInt( int );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Public int constructor.
};
...
anInt myInt = 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Access-control violation. Attempt to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; reference private copy constructor.
anInt myInt( 7 );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Correct; no copy constructor called.
</code></pre>
<p>
When a function is called, class-type arguments passed by value and objects returned by value are conceptually initialized using the form:</p>
<p>
<i>type-name</i> <i>name</i> <b>=</b> <i>value</i></p>
<p>
For example:</p>
<pre><code>String s = "C++";
</code></pre>
<p>
Therefore, it follows that the argument type must be a type that can be converted to the class type being passed as an argument. The class’s copy constructor, as well as user-defined conversion operators or constructors that accept the type of the actual argument, must be public.</p>
<p>
In expressions that use the <b>new</b> operator, the objects allocated on the free store are conceptually initialized using the form:</p>
<p>
<i>type-name</i> <i>name</i><b>(</b> <i>initializer</i><sub>1</sub>, <i>initializer</i><sub>2</sub>, ... <i>initializer</i><sub>n</sub> <b>)</b></p>
<p>
For example:</p>
<pre><code>String *ps = new String( "C++" );
</code></pre>
<p>
Initializers for base-class components and member objects of a class are also conceptually initialized this way. (For more information, see <a href="_pluslang_initializing_bases_and_members.htm">Initializing Bases and Members</a>.)</p>
</font></BODY>
</HTML>
