<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Overloaded Operators</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_overloaded_operators"></a><sup></sup>Overloaded Operators</h1>
<p>
With C++, you can redefine the function of most built-in operators. These operators can be redefined, or “overloaded,” globally or on a class-by-class basis. Overloaded operators are implemented as functions and can be class-member or global functions.</p>
<p>
The name of an overloaded operator is <b>operator</b><i>x</i>, where <i>x</i> is the operator as it appears in Table 12.2. For example, to overload the addition operator, you define a function called <b>operator+</b>. Similarly, to overload the addition/assignment operator, +=, define a function called <b>operator+=</b>.</p>
<p>
Although these operators are usually called implicitly by the compiler when they are encountered in code, they can be invoked explicitly the same way as any member or nonmember function is called:</p>
<pre><code>Point pt;

pt.operator+( 3 );&nbsp; // Call addition operator to add 3 to pt.
</code></pre>
<p class=label>
<b><a name="_pluslang_table_12..2"></a>Table 12.2&nbsp;&nbsp;&nbsp;Redefinable Operators</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Operator</b></td>
<td class=label width=38%><b>Name</b></td>
<td class=label width=38%><b>Type</b></td>
</tr>
<tr valign=top>
<td width=24%><b>,</b></td>
<td width=38%>Comma</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>!</b></td>
<td width=38%>Logical NOT</td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><b>!=</b></td>
<td width=38%>Inequality</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>%</b></td>
<td width=38%>Modulus</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>%=</b></td>
<td width=38%>Modulus/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&amp;</b></td>
<td width=38%>Bitwise AND</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&amp;</b></td>
<td width=38%>Address-of</td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><b>&amp;&amp;</b></td>
<td width=38%>Logical AND</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&amp;=</b></td>
<td width=38%>Bitwise AND/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>( )</b></td>
<td width=38%>Function call</td>
<td width=38%>—</td>
</tr>
<tr valign=top>
<td width=24%><b>*</b></td>
<td width=38%>Multiplication</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>*</b></td>
<td width=38%>Pointer dereference</td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><b>*=</b></td>
<td width=38%>Multiplication/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>+</b></td>
<td width=38%>Addition</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>+</b></td>
<td width=38%>Unary Plus</td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><b>++</b></td>
<td width=38%>Increment<sup>1</sup></td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><b>+=</b></td>
<td width=38%>Addition/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>–</b></td>
<td width=38%>Subtraction</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>–</b></td>
<td width=38%>Unary negation</td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><code>––</code></td>
<td width=38%>Decrement<sup>1</sup></td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><b>–=</b></td>
<td width=38%>Subtraction/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>–&gt;</b></td>
<td width=38%>Member selection</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>–&gt;*</b></td>
<td width=38%>Pointer-to-member selection</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>/</b></td>
<td width=38%>Division</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>/=</b></td>
<td width=38%>Division/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&lt;</b></td>
<td width=38%>Less than</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&lt;&lt;</b></td>
<td width=38%>Left shift</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&lt;&lt;=</b></td>
<td width=38%>Left shift/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&lt;=</b></td>
<td width=38%>Less than or equal to</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>=</b></td>
<td width=38%>Assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>==</b></td>
<td width=38%>Equality</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&gt;</b></td>
<td width=38%>Greater than</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&gt;=</b></td>
<td width=38%>Greater than or equal to</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&gt;&gt;</b></td>
<td width=38%>Right shift</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>&gt;&gt;=</b></td>
<td width=38%>Right shift/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>[ ]</b></td>
<td width=38%>Array subscript</td>
<td width=38%>—</td>
</tr>
<tr valign=top>
<td width=24%><b>^</b></td>
<td width=38%>Exclusive OR</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>^=</b></td>
<td width=38%>Exclusive OR/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>|</b></td>
<td width=38%>Bitwise inclusive OR</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>|=</b></td>
<td width=38%>Bitwise inclusive OR/assignment</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>||</b></td>
<td width=38%>Logical OR</td>
<td width=38%>Binary</td>
</tr>
<tr valign=top>
<td width=24%><b>~</b></td>
<td width=38%>One’s complement</td>
<td width=38%>Unary</td>
</tr>
<tr valign=top>
<td width=24%><b>delete</b></td>
<td width=38%><b>delete</b></td>
<td width=38%>—</td>
</tr>
<tr valign=top>
<td width=24%><b>new</b></td>
<td width=38%><b>new</b></td>
<td width=38%>—</td>
</tr>
</table><br>
<p class=mini>
<sup>1</sup>&nbsp;&nbsp;&nbsp;Two versions of the unary increment and decrement operators exist: preincrement and postincrement.</p>
<p>
The constraints on the various categories of overloaded operators are described in <a href="_pluslang_c.2b2b_.unary_operators.htm">Unary Operators</a>, <a href="_pluslang_binary_operators.htm">Binary Operators</a>, <a href="_pluslang_assignment.htm">Assignment</a>, <a href="_pluslang_function_call.htm">Function Call</a>, <a href="_pluslang_subscripting.htm">Subscripting</a>, <a href="_pluslang_class.2d.member_access.htm">Class-Member Access</a>, and <a href="_pluslang_increment_and_decrement.htm">Increment and Decrement</a>.</p>
<p>
The operators shown in Table 12.3 cannot be overloaded.</p>
<p class=label>
<b><a name="_pluslang_table_12..3"></a>Table 12.3&nbsp;&nbsp;&nbsp;Nonredefinable Operators</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Operator</b></td>
<td class=label width=80%><b>Name</b></td>
</tr>
<tr valign=top>
<td width=20%><b>.</b></td>
<td width=80%>Member selection</td>
</tr>
<tr valign=top>
<td width=20%><b>.*</b></td>
<td width=80%>Pointer-to-member selection</td>
</tr>
<tr valign=top>
<td width=20%><b>::</b></td>
<td width=80%>Scope resolution</td>
</tr>
<tr valign=top>
<td width=20%><b>? :</b></td>
<td width=80%>Conditional</td>
</tr>
<tr valign=top>
<td width=20%><b>#</b></td>
<td width=80%>Preprocessor symbol</td>
</tr>
<tr valign=top>
<td width=20%><b>##</b></td>
<td width=80%>Preprocessor symbol</td>
</tr>
</table><br>
</font></BODY>
</HTML>
