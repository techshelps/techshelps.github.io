<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Bitwise Shift Operators</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_clang_bitwise_shift_operators"></a><sup></sup>Bitwise Shift Operators</h1>
<p>
The shift operators shift their first operand left (<b>&lt;&lt;</b>) or right (<b>&gt;&gt;</b>) by the number of positions the second operand specifies. </p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>shift-expression</i> :</p>
<p class=indent>
<i>additive-expression</i><br>
<i>shift-expression</i>  <b>&lt;&lt;</b> <i>additive-expression</i><br>
<i>shift-expression</i>  <b>&gt;&gt;</b> <i>additive-expression</i></p>
<p>
Both operands must be integral values. These operators perform the usual arithmetic conversions; the type of the result is the type of the left operand after conversion. </p>
<p>
For leftward shifts, the vacated right bits are set to 0. For rightward shifts, the vacated left bits are filled based on the type of the first operand after conversion. If the type is <b>unsigned</b>, they are set to 0. Otherwise, they are filled with copies of the sign bit. For left-shift operators without overflow, the statement</p>
<pre><code>expr1 &lt;&lt; expr2 
</code></pre>
<p>
is equivalent to multiplication by 2<sup>expr2</sup>. For right-shift operators, </p>
<pre><code>expr1 &gt;&gt; expr2 
</code></pre>
<p>
is equivalent to division by 2<sup>expr2</sup> if <code>expr1</code> is unsigned or has a nonnegative value.</p>
<p>
The result of a shift operation is undefined if the second operand is negative, or if the right operand is greater than or equal to the width in bits of the promoted left operand.</p>
<p>
Since the conversions performed by the shift operators do not provide for overflow or underflow conditions, information may be lost if the result of a shift operation cannot be represented in the type of the first operand after conversion.</p>
<pre><code>unsigned int x, y, z;

x = 0x00AA;
y = 0x5500;

z = ( x &lt;&lt; 8 ) + ( y &gt;&gt; 8 );
</code></pre>
<p>
In this example, <code>x</code> is shifted left eight positions and <code>y</code> is shifted right eight positions. The shifted values are added, giving 0xAA55, and assigned to <code>z</code>.</p>
<p>
Shifting a negative value to the right yields half the absolute value, rounded down. For example, –253 (binary 11111111 00000011) shifted right one bit produces –127 (binary 11111111 10000001). A <i>positive</i> 253 shifts right to produce +126.</p>
<p>
Right shifts preserve the sign bit. When a signed integer shifts right, the most-significant bit remains set. When an unsigned integer shifts right, the most-significant bit is cleared. </p>
<p>
If 0xF000 is unsigned, the result is 0x7800. If 0xF0000000 is signed, a right shift produces 0xF8000000. Shifting a positive number right 32 times produces 0xF0000000. Shifting a negative number right 32 times produces 0xFFFFFFFF.</p>
</font></BODY>
</HTML>
