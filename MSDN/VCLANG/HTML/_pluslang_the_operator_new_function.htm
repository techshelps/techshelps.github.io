<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The operator new Function</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_the_operator_new_function"></a>The operator new Function</h1>
<p>
When a statement such as the following is encountered in a program, it translates into a call to the function <b>operator new</b>:</p>
<pre><code>char *pch = new char[BUFFER_SIZE];
</code></pre>
<p>
If the request is for zero bytes of storage, <b>operator new </b>returns a pointer to a distinct object (that is, repeated calls to <b>operator new </b>return different pointers). If there is insufficient memory for the allocation request, by default <b>operator new </b>returns <b>NULL</b>. You can change this default behavior by writing a custom exception-handling routine and calling the <b>_set_new_handler</b> run-time library function with your function name as its argument. For more details on the recovery scheme, see the following section, <a href="_pluslang_handling_insufficient_memory_conditions.htm">Handling Insufficient Memory Conditions</a>. </p>
<p>
The two scopes for <b>operator new</b> functions are described in Table 11.4.</p>
<p class=label>
<b><a name="_pluslang_table_11..4"></a>Table 11.4&nbsp;&nbsp;&nbsp;Scope for operator new Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=41%><b>Operator</b></td>
<td class=label width=59%><b>Scope</b></td>
</tr>
<tr valign=top>
<td width=41%><b>::operator new</b></td>
<td width=59%>Global</td>
</tr>
<tr valign=top>
<td width=41%><i>class-name</i><b>::operator new</b></td>
<td width=59%>Class</td>
</tr>
</table><br>
<p>
The first argument to <b>operator new </b>must be of type <b>size_t</b> (a type defined in STDDEF.H), and the return type is always <b>void *</b>.</p>
<p>
The global <b>operator new </b>function is called when the <b>new</b> operator is used to allocate objects of built-in types, objects of class type that do not contain user-defined <b>operator new </b>functions, and arrays of any type. When the <b>new</b> operator is used to allocate objects of a class type where an <b>operator new </b>is defined, that class’s <b>operator new </b>is called.</p>
<p>
An <b>operator new </b>function defined for a class is a static member function (which cannot, therefore, be virtual) that hides the global <b>operator new </b>function for objects of that class type. Consider the case where <b>new</b> is used to allocate and set memory to a given value:</p>
<pre><code>#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;

class Blanks
{
public:
 &nbsp;&nbsp; Blanks(){}
 &nbsp;&nbsp; void *operator new( size_t stAllocateBlock, char chInit );
};
void *Blanks::operator new( size_t stAllocateBlock, char chInit )
{
 &nbsp;&nbsp; void *pvTemp = malloc( stAllocateBlock );
 &nbsp;&nbsp; if( pvTemp != 0 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset( pvTemp, chInit, stAllocateBlock );
 &nbsp;&nbsp; return pvTemp;
}
</code></pre>
<p>
For discrete objects of type <code>Blanks</code>, the global <b>operator new </b>function is hidden. Therefore, the following code allocates an object of type <code>Blanks</code> and initializes it to <code>0xa5</code>:</p>
<pre><code>int main()
{
 &nbsp;&nbsp; Blanks *a5 = new( 0xa5 ) Blanks;

 &nbsp;&nbsp; return a5 != 0;
}
</code></pre>
<p>
The argument supplied in parentheses to <b>new</b> is passed to <code>Blanks::operator new</code> as the <code>chInit</code> argument. However, the global <b>operator new </b>function is hidden, causing code such as the following to generate an error:</p>
<pre><code>Blanks *SomeBlanks = new Blanks;
</code></pre>
<p>
For previous versions of the compiler, nonclass types and all arrays (regardless of whether they were of <b>class</b> type) allocated using the <b>new</b> operator always used the global <b>operator new </b>function.</p>
<p>
Beginning with Visual C++ 5.0, the compiler supports member array <b>new</b> and <b>delete</b> operators in a class declaration. For example:</p>
<pre><code>class X {
public:
   void*   operator new[] (size_t);
   void      operator delete[] (void*);
};

void f() {
   X *pX = new X[5];
   delete [] pX;
}
</code></pre>
</font></BODY>
</HTML>
