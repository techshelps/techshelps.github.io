<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Memberwise Assignment and Initialization</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_memberwise_assignment_and_initialization"></a><sup></sup>Memberwise Assignment and Initialization</h1>
<p>
The methods for default assignment and initialization are “memberwise assignment” and “memberwise initialization,” respectively. Memberwise assignment consists of copying one object to the other, a member at a time, as if assigning each member individually. Memberwise initialization consists of copying one object to the other, a member at a time, as if initializing each member individually. The primary difference between the two is that memberwise assignment invokes each member’s assignment operator (<b>operator=</b>), whereas memberwise initialization invokes each member’s copy constructor.</p>
<p>
Memberwise assignment is performed only by the assignment operator declared in the form:</p>
<p>
<i>type</i><b>&amp;</b> <i>type</i> <b>::</b> <b>operator=(</b> [<b>const</b> | <b>volatile</b>] <i>type</i><b>&amp;</b> <b>)</b></p>
<p>
Default assignment operators for memberwise assignment cannot be generated if any of the following conditions exist:
<ul type=disc>
<li>
A member class has <b>const</b> members.<br><br></li>
<li>
A member class has reference members.<br><br></li>
<li>
A member class or its base class has a private assignment operator (<b>operator=</b>).<br><br></li>
<li>
A base class or member class has no assignment operator (<b>operator=</b>).</li>
</ul>
<p>
Default copy constructors for memberwise initialization cannot be generated if the class or one of its base classes has a private copy constructor or if any of the following conditions exist:
<ul type=disc>
<li>
A member class has <b>const</b> members.<br><br></li>
<li>
A member class has reference members.<br><br></li>
<li>
A member class or its base class has a private copy constructor.<br><br></li>
<li>
A base class or member class has no copy constructor.</li>
</ul>
<p>
The default assignment operators and copy constructors for a given class are always declared, but they are not defined unless both of the following conditions are met:
<ul type=disc>
<li>
The class does not provide a user-defined function for this copy.<br><br></li>
<li>
The program requires that the function be present. This requirement exists if an assignment or initialization is encountered that requires memberwise copying or if the address of the class’s <b>operator=</b> function is taken. </li>
</ul>
<p>
If both of these conditions are not met, the compiler is not required to generate code for the default assignment operator and copy constructor functions (elimination of such code is an optimization performed by the Microsoft C++ compiler). Specifically, if the class declares a user-defined <b>operator=</b> that takes an argument of type “reference to <i>class-name</i>,” no default assignment operator is generated. If the class declares a copy constructor, no default copy constructor is generated.</p>
<p>
Therefore, for a given class <code>A</code>, the following declarations are always present:</p>
<pre><code>//&nbsp; Implicit declarations of copy constructor
//&nbsp;&nbsp; and assignment operator.
A::A( const A&amp; );
A&amp; A::operator=( const A&amp; );
</code></pre>
<p>
The definitions are supplied only if required (according to the preceding criteria). The copy constructor functions shown in the preceding example are considered public member functions of the class.</p>
<p>
Default assignment operators allow objects of a given class to be assigned to objects of a public base-class type. Consider the following code:</p>
<pre><code>class Account
{
public:
 &nbsp;&nbsp; // Public member functions
 &nbsp;&nbsp; ...
private:
 &nbsp;&nbsp; double _balance;
};

class Checking : public Account
{
private:
 &nbsp;&nbsp; int _fOverdraftProtect;
};

...

Account account;
Checking checking;

account = checking;
</code></pre>
<p>
In the preceding example, the assignment operator chosen is <code>Account::operator=</code>. Because the default <code>operator=</code> function takes an argument of type <code>Account&amp;</code> (reference to <code>Account</code>), the <code>Account</code> subobject of <code>checking</code> is copied to <code>account</code>; <code>fOverdraftProtect</code> is not copied.</p>
</font></BODY>
</HTML>
