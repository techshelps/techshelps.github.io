<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Restrictions on Overloaded Functions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_restrictions_on_overloaded_functions"></a><sup></sup>Restrictions on Overloaded Functions</h1>
<p>
Several restrictions govern an acceptable set of overloaded functions:
<ul type=disc>
<li>
Any two functions in a set of overloaded functions must have different argument lists.<br><br></li>
<li>
Overloading functions with argument lists of the same types, based on return type alone, is an error.</li>
</ul>
<p>
<b>Microsoft Specific </b></p>
<p class=tl>
You can overload <b>operator new </b>solely on the basis of return type — specifically, on the basis of the memory-model modifier specified.</P><p>
<b>END Microsoft Specific</b>
<ul type=disc>
<li>
Member functions cannot be overloaded solely on the basis of one being static and the other nonstatic.<br><br></li>
<li>
<b>typedef</b> declarations do not define new types; they introduce synonyms for existing types. They do not affect the overloading mechanism. Consider the following code:<pre><code>typedef char * PSTR;

void Print( char *szToPrint );
void Print( PSTR szToPrint );
</code></pre>
<p class=tl>
The preceding two functions have identical argument lists. <code>PSTR</code> is a synonym for type <b>char *</b>. In member scope, this code generates an error.</P></li>
<li>
Enumerated types are distinct types and can be used to distinguish between overloaded functions.<br><br></li>
<li>
The types “array of ” and “pointer to” are considered identical for the purposes of distinguishing between overloaded functions. This is true only for singly dimensioned arrays. Therefore, the following overloaded functions conflict and generate an error message:<pre><code>void Print( char *szToPrint );
void Print( char szToPrint[] );
</code></pre>
<p class=tl>
For multiply dimensioned arrays, the second and all succeeding dimensions are considered part of the type. Therefore, they are used in distinguishing between overloaded functions:</P><pre><code>void Print( char szToPrint[] );
void Print( char szToPrint[][7] );
void Print( char szToPrint[][9][42] );
</code></pre>
</li>
</ul>
</font></BODY>
</HTML>
