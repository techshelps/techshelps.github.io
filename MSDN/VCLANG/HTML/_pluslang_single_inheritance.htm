<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Single Inheritance</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_single_inheritance"></a><sup></sup>Single Inheritance</h1>
<p>
In “single inheritance,” a common form of inheritance, classes have only one base class. Consider the relationship illustrated in Figure 9.1</p>
<p class=label>
<b>Figure 9.1&nbsp;&nbsp;&nbsp;Simple Single-Inheritance Graph</b></p>
<p>
<img src="l09inh1.gif" border=0></p>
<p>
Note the progression from general to specific in Figure 9.1. Another common attribute found in the design of most class hierarchies is that the derived class has a “kind of” relationship with the base class. In Figure 9.1, a <code>Book</code> is a kind of a <code>PrintedDocument</code>, and a <code>PaperbackBook</code> is a kind of a <code>book</code>.</p>
<p>
One other item of note in Figure 9.1: <code>Book</code> is both a derived class (from <code>PrintedDocument</code>) and a base class (<code>PaperbackBook</code> is derived from <code>Book</code>). A skeletal declaration of such a class hierarchy is shown in the following example:</p>
<pre><code>class PrintedDocument
{
 &nbsp;&nbsp; // Member list.
};

// Book is derived from PrintedDocument.
class Book : public PrintedDocument
{
 &nbsp;&nbsp; // Member list.
};

// PaperbackBook is derived from Book.
class PaperbackBook : public Book
{
 &nbsp;&nbsp; // Member list.
};
</code></pre>
<p>
<code>PrintedDocument</code> is considered a “direct base” class to <code>Book</code>; it is an “indirect base” class to <code>PaperbackBook</code>. The difference is that a direct base class appears in the base list of a class declaration and an indirect base does not.</p>
<p>
The base class from which each class is derived is declared before the declaration of the derived class. It is not sufficient to provide a forward-referencing declaration for a base class; it must be a complete declaration.</p>
<p>
In the preceding example, the access specifier <b>public</b> is used. The meaning of public, protected, and private inheritance is described in Chapter 10, <a href="_pluslang_member.2d.access_control.htm">Member-Access Control.</a></p>
<p>
A class can serve as the base class for many specific classes, as illustrated in Figure 9.2.</p>
<p class=label>
<b>Figure 9.2&nbsp;&nbsp;&nbsp;Sample of Directed Acyclic Graph</b></p>
<p>
<img src="l09gra2.gif" border=0></p>
<p>
In the diagram in Figure 9.2, called a “directed acyclic graph” (or “DAG”), some of the classes are base classes for more than one derived class. However, the reverse is not true: there is only one direct base class for any given derived class. The graph in Figure 9.2 depicts a “single inheritance” structure.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Directed acyclic graphs are not unique to single inheritance. They are also used to depict multiple-inheritance graphs. This topic is covered in <a href="_pluslang_multiple_inheritance.htm">Multiple Inheritance</a>.</p>
<p>
In inheritance, the derived class contains the members of the base class plus any new members you add. As a result, a derived class can refer to members of the base class (unless those members are redefined in the derived class). The scope-resolution operator (<b>::</b>) can be used to refer to members of direct or indirect base classes when those members have been redefined in the derived class. Consider this example:</p>
<pre><code>class Document
{
public:
 &nbsp;&nbsp; char *Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Document name.
 &nbsp;&nbsp; void&nbsp; PrintNameOf();&nbsp; // Print name.
};

// Implementation of PrintNameOf function from class Document.
void Document::PrintNameOf()
{
 &nbsp;&nbsp; cout &lt;&lt; Name &lt;&lt; endl;
}

class Book : public Document
{
public:
 &nbsp;&nbsp; Book( char *name, long pagecount );
private:
 &nbsp;&nbsp; long&nbsp; PageCount;
};

// Constructor from class Book.
Book::Book( char *name, long pagecount )
{
 &nbsp;&nbsp; Name = new char[ strlen( name ) + 1 ];
 &nbsp;&nbsp; strcpy( Name, name );
 &nbsp;&nbsp; PageCount = pagecount;
};
</code></pre>
<p>
Note that the constructor for <code>Book</code>, (<code>Book::Book</code>), has access to the data member, <code>Name</code>. In a program, an object of type <code>Book</code> can be created and used as follows:</p>
<pre><code>//&nbsp; Create a new object of type Book. This invokes the
//&nbsp;&nbsp; constructor Book::Book.
Book LibraryBook( "Programming Windows, 2nd Ed", 944 );

...

//&nbsp; Use PrintNameOf function inherited from class Document.
LibraryBook.PrintNameOf();
</code></pre>
<p>
As the preceding example demonstrates, class-member and inherited data and functions are used identically. If the implementation for class <code>Book</code> calls for a reimplementation of the <code>PrintNameOf</code> function, the function that belongs to the <code>Document</code> class can be called only by using the scope-resolution (<b>::</b>) operator:</p>
<pre><code>class Book : public Document
{
 &nbsp;&nbsp; Book( char *name, long pagecount );
 &nbsp;&nbsp; void PrintNameOf();
 &nbsp;&nbsp; long&nbsp; PageCount;
};
void Book::PrintNameOf()
{
 &nbsp;&nbsp; cout &lt;&lt; "Name of book: ";
 &nbsp;&nbsp; Document::PrintNameOf();
}
</code></pre>
<p>
Pointers and references to derived classes can be implicitly converted to pointers and references to their base classes if there is an accessible, unambiguous base class. The following code demonstrates this concept using pointers (the same principle applies to references):</p>
<pre><code>#include &lt;iostream.h&gt;

void main()
{
 &nbsp;&nbsp; Document *DocLib[10];&nbsp; // Library of ten documents.

 &nbsp;&nbsp; for( int i = 0; i &lt; 10; ++i )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Type of document: "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "P)aperback, M)agazine, H)elp File, C)BT"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char cDocType;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin &gt;&gt; cDocType;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( tolower( cDocType ) )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'p':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DocLib[i] = new PaperbackBook;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'm':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DocLib[i] = new Magazine;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'h':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DocLib[i] = new HelpFile;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'c':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DocLib[i] = new ComputerBasedTraining;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

 &nbsp;&nbsp; for( i = 0; i &lt; 10; ++i )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DocLib[i]-&gt;PrintNameOf();
}
</code></pre>
<p>
In the <code>SWITCH</code> statement in the preceding example, objects of different types are created, depending on what the user specified for <code>cDocType</code>. However, because these types are all derived from the <code>Document</code> class, there is an implicit conversion to <code>Document *</code>. As a result, <code>DocLib</code> is a “heterogeneous list” (a list in which not all objects are of the same type) containing different kinds of objects.</p>
<p>
Because the <code>Document</code> class has a <code>PrintNameOf</code> function, it can print the name of each book in the library, although it may omit some of the information specific to the type of document (page count for <code>Book</code>, number of bytes for <code>HelpFile</code>, and so on).</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Forcing the base class to implement a function such as <code>PrintNameOf</code> is often not the best design. <a href="_pluslang_virtual_functions.htm">Virtual Functions</a> offers other design alternatives.</p>
</font></BODY>
</HTML>
