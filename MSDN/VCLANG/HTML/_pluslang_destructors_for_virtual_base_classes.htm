<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Destructors for Virtual Base Classes</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_destructors_for_virtual_base_classes"></a><sup></sup>Destructors for Virtual Base Classes</h1>
<p>
Destructors for virtual base classes are called in the reverse order of their appearance in a directed acyclic graph (depth-first, left-to-right, postorder traversal). Figure 11.1 depicts an inheritance graph. </p>
<p class=label>
<b>Figure 11.1&nbsp;&nbsp;&nbsp;Inheritance Graph Showing Virtual Base Classes</b></p>
<p>
<img src="l11inh1.gif" border=0></p>
<p>
The following lists the class heads for the classes shown in Figure 11.1.</p>
<pre><code>class A
class B
class C : virtual public A, virtual public B
class D : virtual public A, virtual public B
class E : public C, public D, virtual public B
</code></pre>
<p>
To determine the order of destruction of the virtual base classes of an object of type <code>E</code>, the compiler builds a list by applying the following algorithm:
<ol>
<li>
Traverse the graph left, starting at the deepest point in the graph (in this case, <code>E</code>).<br><br></li>
<li>
Perform leftward traversals until all nodes have been visited. Note the name of the current node.<br><br></li>
<li>
Revisit the previous node (down and to the right) to find out whether the node being remembered is a virtual base class.<br><br></li>
<li>
If the remembered node is a virtual base class, scan the list to see whether it has already been entered. If it is not a virtual base class, ignore it.<br><br></li>
<li>
If the remembered node is not yet in the list, add it to the bottom of the list.<br><br></li>
<li>
Traverse the graph up and along the next path to the right.<br><br></li>
<li>
Go to step 2.<br><br></li>
<li>
When the last upward path is exhausted, note the name of the current node.<br><br></li>
<li>
Go to step 3.<br><br></li>
<li>
Continue this process until the bottom node is again the current node.</li>
</ol>
<p>
Therefore, for class <code>E</code>, the order of destruction is:
<ol>
<li>
The nonvirtual base class <code>E</code>.<br><br></li>
<li>
The nonvirtual base class <code>D</code>.<br><br></li>
<li>
The nonvirtual base class <code>C</code>.<br><br></li>
<li>
The virtual base class <code>B</code>.<br><br></li>
<li>
The virtual base class <code>A</code>.</li>
</ol>
<p>
This process produces an ordered list of unique entries. No class name appears twice. Once the list is constructed, it is walked in reverse order, and the destructor for each of the classes in the list from the last to the first is called.</p>
<p>
The order of construction or destruction is primarily important when constructors or destructors in one class rely on the other component being created first or persisting longer — for example, if the destructor for <code>A</code> (in the graph in Figure 11.1) relied on <code>B</code> still being present when its code executed, or vice versa.</p>
<p>
Such interdependencies between classes in an inheritance graph are inherently dangerous because classes derived later can alter which is the leftmost path, thereby changing the order of construction and destruction.</p>
</font></BODY>
</HTML>
