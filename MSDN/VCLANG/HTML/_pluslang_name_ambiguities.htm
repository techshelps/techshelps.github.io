<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Name Ambiguities</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_name_ambiguities"></a><sup></sup>Name Ambiguities</h1>
<p>
Multiple inheritance introduces the possibility for names to be inherited along more than one path. The class-member names along these paths are not necessarily unique. These name conflicts are called “ambiguities.”</p>
<p>
Any expression that refers to a class member must make an unambiguous reference. The following example shows how ambiguities develop:</p>
<pre><code>// Declare two base classes, A and B.
class A
{
public:
 &nbsp;&nbsp; unsigned a;
 &nbsp;&nbsp; unsigned b();
};

class B
{
public:
 &nbsp;&nbsp; unsigned a();&nbsp; // Note that class A also has a member "a"
 &nbsp;&nbsp; int b();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; and a member "b".
 &nbsp;&nbsp; char c;
};

// Define class C as derived from A and B.
class C : public A, public B
{
};
</code></pre>
<p>
Given the preceding class declarations, code such as the following is ambiguous because it is unclear whether <code>b</code> refers to the <code>b</code> in <code>A</code> or in <code>B</code>:</p>
<pre><code>C *pc = new C;

pc-&gt;b();
</code></pre>
<p>
Consider the preceding example. Because the name <code>a</code> is a member of both class <code>A</code> and class <code>B</code>, the compiler cannot discern which <code>a</code> designates the function to be called. Access to a member is ambiguous if it can refer to more than one function, object, type, or enumerator.</p>
<p>
The compiler detects ambiguities by performing tests in this order:
<ol>
<li>
If access to the name is ambiguous (as just described), an error message is generated.<br><br></li>
<li>
If overloaded functions are unambiguous, they are resolved. (For more information about function overloading ambiguity, see <a href="_pluslang_argument_matching.htm">Argument Matching</a> in Chapter 12.)<br><br></li>
<li>
If access to the name violates member-access permission, an error message is generated. (For more information, see Chapter 10, <a href="_pluslang_member.2d.access_control.htm">Member-Access Control</a>.)</li>
</ol>
<p>
When an expression produces an ambiguity through inheritance, you can manually resolve it by qualifying the name in question with its class name. To make the preceding example compile properly with no ambiguities, use code such as:</p>
<pre><code>C *pc = new C;

pc-&gt;B::a();
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When <code>C</code> is declared, it has the potential to cause errors when <code>B</code> is referenced in the scope of <code>C</code>. No error is issued, however, until an unqualified reference to <code>B</code> is actually made in <code>C</code>’s scope.</p>
</font></BODY>
</HTML>
