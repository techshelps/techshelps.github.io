<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>multimap</title></head>
<body bgcolor=white>

<h2><a name="multimap">multimap</a></h2>
<META NAME="MS-HKWD" CONTENT="multimap">
<p><a href="MAP_multimapCCallocator_type.htm#multimap::allocator_type"><code><b>allocator_type</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCbegin.htm#multimap::begin"><code><b>begin</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCclear.htm#multimap::clear"><code><b>clear</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCconst_iterator.htm#multimap::const_iterator"><code><b>const_iterator</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCconst_reference.htm#multimap::const_reference"><code><b>const_reference</b></code></a><code><b> &#183; 
</b></code><a href="MAP_multimapCCconst_reverse_iterator.htm#multimap::const_reverse_iterator"><code><b>const_reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCcount.htm#multimap::count"><code><b>count</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCdifference_type.htm#multimap::difference_type"><code><b>difference_type</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCempty.htm#multimap::empty"><code><b>empty</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCend.htm#multimap::end"><code><b>end</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCequal_range.htm#multimap::equal_range"><code><b>equal_range</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCerase.htm#multimap::erase"><code><b>erase</b></code></a><code><b> &#183; 
</b></code><a href="MAP_multimapCCfind.htm#multimap::find"><code><b>find</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCget_allocator.htm#multimap::get_allocator"><code><b>get_allocator</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCinsert.htm#multimap::insert"><code><b>insert</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCiterator.htm#multimap::iterator"><code><b>iterator</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCkey_comp.htm#multimap::key_comp"><code><b>key_comp</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCkey_compare.htm#multimap::key_compare"><code><b>key_compare</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCkey_type.htm#multimap::key_type"><code><b>key_type</b></code></a><code><b> &#183; 
</b></code><a href="MAP_multimapCClower_bound.htm#multimap::lower_bound"><code><b>lower_bound</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCmax_size.htm#multimap::max_size"><code><b>max_size</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCmultimap.htm#multimap::multimap"><code><b>multimap</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCrbegin.htm#multimap::rbegin"><code><b>rbegin</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCreference.htm#multimap::reference"><code><b>reference</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCreferent_type.htm#multimap::referent_type"><code><b>referent_type</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCrend.htm#multimap::rend"><code><b>rend</b></code></a><code><b> &#183; 
</b></code><a href="MAP_multimapCCreverse_iterator.htm#multimap::reverse_iterator"><code><b>reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCsize.htm#multimap::size"><code><b>size</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCsize_type.htm#multimap::size_type"><code><b>size_type</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCswap.htm#multimap::swap"><code><b>swap</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCupper_bound.htm#multimap::upper_bound"><code><b>upper_bound</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCvalue_comp.htm#multimap::value_comp"><code><b>value_comp</b></code></a><code><b> &#183; </b></code><a href="MAP_multimapCCvalue_compare.htm#multimap::value_compare"><code><b>value_compare</b></code></a><code><b> &#183; 
</b></code><a href="MAP_multimapCCvalue_type.htm#multimap::value_type"><code><b>value_type</b></code></a><code><b> </b></code></p>
<pre><code>template&lt;class Key, class T, class Pred = less&lt;Key&gt;, class A = allocator&lt;T&gt; &gt;
    class <b>multimap</b> {
public:
    typedef Key <a href="MAP_multimapCCkey_type.htm#multimap::key_type"><b>key_type</b></a>;
    typedef T <a href="MAP_multimapCCreferent_type.htm#multimap::referent_type"><b>referent_type</b></a>;
    typedef Pred <a href="MAP_multimapCCkey_compare.htm#multimap::key_compare"><b>key_compare</b></a>;
    typedef A <a href="MAP_multimapCCallocator_type.htm#multimap::allocator_type"><b>allocator_type</b></a>;
    typedef pair&lt;const Key, T&gt; <a href="MAP_multimapCCvalue_type.htm#multimap::value_type"><b>value_type</b></a>;
    class <a href="MAP_multimapCCvalue_compare.htm#multimap::value_compare"><b>value_compare</b></a>;
    typedef A::size_type <a href="MAP_multimapCCsize_type.htm#multimap::size_type"><b>size_type</b></a>;
    typedef A::difference_type <a href="MAP_multimapCCdifference_type.htm#multimap::difference_type"><b>difference_type</b></a>;
    typedef A::rebind&lt;value_type&gt;::other::reference <a href="MAP_multimapCCreference.htm#multimap::reference"><b>reference</b></a>;
    typedef A::rebind&lt;value_type&gt;::other::const_reference <a href="MAP_multimapCCconst_reference.htm#multimap::const_reference"><b>const_reference</b></a>;
    typedef T0 <a href="MAP_multimapCCiterator.htm#multimap::iterator"><b>iterator</b></a>;
    typedef T1 <a href="MAP_multimapCCconst_iterator.htm#multimap::const_iterator"><b>const_iterator</b></a>;
    typedef reverse_bidirectional_iterator&lt;iterator,
        value_type, reference, A::pointer,
            difference_type&gt; <a href="MAP_multimapCCreverse_iterator.htm#multimap::reverse_iterator"><b>reverse_iterator</b></a>;
    typedef reverse_bidirectional_iterator&lt;const_iterator,
        value_type, const_reference, A::const_pointer,
            difference_type&gt; <a href="MAP_multimapCCconst_reverse_iterator.htm#multimap::const_reverse_iterator"><b>const_reverse_iterator</b></a>;
    explicit <a href="MAP_multimapCCmultimap.htm#multimap::multimap"><b>multimap</b></a>(const Pred&amp; comp = Pred(), const A&amp; al = A());
    <a href="MAP_multimapCCmultimap.htm#multimap::multimap"><b>multimap</b></a>(const multimap&amp; x);
    <a href="MAP_multimapCCmultimap.htm#multimap::multimap"><b>multimap</b></a>(const value_type *first, const value_type *last,
        const Pred&amp; comp = Pred(), const A&amp; al = A());
    iterator <a href="MAP_multimapCCbegin.htm#multimap::begin"><b>begin</b></a>();
    const_iterator <a href="MAP_multimapCCbegin.htm#multimap::begin"><b>begin</b></a>() const;
    iterator <a href="MAP_multimapCCend.htm#multimap::end"><b>end</b></a>();
    iterator <a href="MAP_multimapCCend.htm#multimap::end"><b>end</b></a>() const;
    reverse_iterator <a href="MAP_multimapCCrbegin.htm#multimap::rbegin"><b>rbegin</b></a>();
    const_reverse_iterator <a href="MAP_multimapCCrbegin.htm#multimap::rbegin"><b>rbegin</b></a>() const;
    reverse_iterator <a href="MAP_multimapCCrend.htm#multimap::rend"><b>rend</b></a>();
    const_reverse_iterator <a href="MAP_multimapCCrend.htm#multimap::rend"><b>rend</b></a>() const;
    size_type <a href="MAP_multimapCCsize.htm#multimap::size"><b>size</b></a>() const;
    size_type <a href="MAP_multimapCCmax_size.htm#multimap::max_size"><b>max_size</b></a>() const;
    bool <a href="MAP_multimapCCempty.htm#multimap::empty"><b>empty</b></a>() const;
    A <a href="MAP_multimapCCget_allocator.htm#multimap::get_allocator"><b>get_allocator</b></a>() const;
    iterator <a href="MAP_multimapCCinsert.htm#multimap::insert"><b>insert</b></a>(const value_type&amp; x);
    iterator <a href="MAP_multimapCCinsert.htm#multimap::insert"><b>insert</b></a>(iterator it, const value_type&amp; x);
    void <a href="MAP_multimapCCinsert.htm#multimap::insert"><b>insert</b></a>(const value_type *first, const value_type *last);
    iterator <a href="MAP_multimapCCerase.htm#multimap::erase"><b>erase</b></a>(iterator it);
    iterator <a href="MAP_multimapCCerase.htm#multimap::erase"><b>erase</b></a>(iterator first, iterator last);
    size_type <a href="MAP_multimapCCerase.htm#multimap::erase"><b>erase</b></a>(const Key&amp; key);
    void <a href="MAP_multimapCCclear.htm#multimap::clear"><b>clear</b></a>();
    void <a href="MAP_multimapCCswap.htm#multimap::swap"><b>swap</b></a>(multimap x);
    key_compare <a href="MAP_multimapCCkey_comp.htm#multimap::key_comp"><b>key_comp</b></a>() const;
    value_compare <a href="MAP_multimapCCvalue_comp.htm#multimap::value_comp"><b>value_comp</b></a>() const;
    iterator <a href="MAP_multimapCCfind.htm#multimap::find"><b>find</b></a>(const Key&amp; key);
    const_iterator <a href="MAP_multimapCCfind.htm#multimap::find"><b>find</b></a>(const Key&amp; key) const;
    size_type <a href="MAP_multimapCCcount.htm#multimap::count"><b>count</b></a>(const Key&amp; key) const;
    iterator <a href="MAP_multimapCClower_bound.htm#multimap::lower_bound"><b>lower_bound</b></a>(const Key&amp; key);
    const_iterator <a href="MAP_multimapCClower_bound.htm#multimap::lower_bound"><b>lower_bound</b></a>(const Key&amp; key) const;
    iterator <a href="MAP_multimapCCupper_bound.htm#multimap::upper_bound"><b>upper_bound</b></a>(const Key&amp; key);
    const_iterator <a href="MAP_multimapCCupper_bound.htm#multimap::upper_bound"><b>upper_bound</b></a>(const Key&amp; key) const;
    pair&lt;iterator, iterator&gt; <a href="MAP_multimapCCequal_range.htm#multimap::equal_range"><b>equal_range</b></a>(const Key&amp; key);
    pair&lt;const_iterator, const_iterator&gt;
        <a href="MAP_multimapCCequal_range.htm#multimap::equal_range"><b>equal_range</b></a>(const Key&amp; key) const;
protected:
    A allocator;
    };</code></pre>
<p>The template class describes an object that controls a varying-length sequence of elements of <b>type </b><a href="UTILITY_pair.htm#pair"><code><b>pair</b></code></a><code><b>&lt;const Key, 
T&gt;</b></code>. The first element of each pair is the sort key and the second is its associated value. The sequence is represented 
in a way that permits lookup, insertion, and removal of an arbitrary element with a number of operations proportional to 
the logarithm of the number of elements in the sequence (logarithmic time). Moreover, inserting an element invalidates 
no iterators, and removing an element invalidates only those iterators that point at the removed element.</p>
<p>The object orders the sequence it controls by calling a stored function object of type <code>Pred</code>. You access this stored 
object by calling the member function <a href="MAP_multimapCCkey_comp.htm#multimap::key_comp"><code>key_comp</code></a><code>()</code>. Such a function object must impose a total order on sort keys. For 
any element <code>x</code> that precedes <code>y</code> in the sequence, <code>key_comp()(y.</code><a href="UTILITY_pair.htm#pair::first"><code>first</code></a><code>, x.first)</code> is false. (For the default function 
object <a href="FUNCTIO2_less.htm#less"><code>less</code></a><code>&lt;Key&gt;</code>, sort keys never decrease in value.) Unlike template class <a href="MAP_map.htm#map"><code>map</code></a>, an object of template class 
<code>multimap</code> does not ensure that <code>key_comp()(x.first, y.first)</code> is true. (Keys need not be unique.)</p>
<p>The object allocates and frees storage for the sequence it controls through a protected object named <a name="multimap::allocator"><code><b>allocator</b></code></a>, of 
<b>class </b><code><b>A</b></code>. Such an <a href="MEMORY_allocator.htm#allocator object">allocator object</a> must have the same external interface as an object of template class <a href="MEMORY_allocator.htm#allocator"><code>allocator</code></a>. 
Note that <code>allocator</code> is not copied when the object is assigned.</p>
</body>
</html>
