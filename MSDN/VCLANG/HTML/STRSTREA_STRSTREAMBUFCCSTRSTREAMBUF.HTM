<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>strstreambuf::strstreambuf</title></head>
<body bgcolor=white>

<h3><a name="strstreambuf::strstreambuf">strstreambuf::strstreambuf</a></h3>
<META NAME="MS-HKWD" CONTENT="strstreambuf">
<pre><code>explicit <b>strstreambuf</b>(streamsize n = 0);
<b>strstreambuf</b>(void (*palloc)(size_t),
    void (*pfree)(void *));
<b>strstreambuf</b>(char *gp, streamsize n,
    char *pp = 0);
<b>strstreambuf</b>(signed char *gp, streamsize n,
    signed char *pp = 0);
<b>strstreambuf</b>(unsigned char *gp, streamsize n,
    unsigned char *pp = 0);
<b>strstreambuf</b>(const char *gp, streamsize n);
<b>strstreambuf</b>(const signed char *gp, streamsize n);
<b>strstreambuf</b>(const unsigned char *gp, streamsize n);</code></pre>
<p>The first constructor stores a null pointer in all the pointers controlling the <a href="STREAMBU_basic_streambuf.htm#input buffer">input buffer</a>, the <a href="STREAMBU_basic_streambuf.htm#output buffer">output buffer</a>, and 
<a href="STRSTREA_strstreambuf.htm#strstreambuf allocation">strstreambuf allocation</a>. It sets the stored <a href="STRSTREA_strstreambuf.htm#strstreambuf mode">strstreambuf mode</a> to make the controlled sequence modifiable and 
extendable.</p>
<p>The second constructor behaves much as the first, except that it stores <code>palloc</code> as the pointer to the function to call to 
allocate storage, and <code>pfree</code> as the pointer to the function to call to free that storage.</p>
<p>The three constructors:</p>
<pre><code><b>strstreambuf</b>(char *gp, streamsize n,
    char *pp = 0);
<b>strstreambuf</b>(signed char *gp, streamsize n,
    signed char *pp = 0);
<b>strstreambuf</b>(unsigned char *gp, streamsize n,
    unsigned char *pp = 0);</code></pre>
<p>also behave much as the first, except that <code>gp</code> designates the array object used to hold the controlled sequence. (Therefore, 
it must not be a null pointer.) The number of elements <code>N</code> in the array is determined as follows:</p>
<ul>
<li>If <code>(n &gt; 0)</code>, then <code>N</code> is <code>n</code>.</li>
<li>If <code>(n == 0)</code>, then <code>N</code> is <code>strlen</code><code>((const char *)gp)</code>.</li>
<li>If <code>(n &lt; 0)</code>, then <code>N</code> is <code>INT_MAX</code>.</li>
</ul>
<p>If <code>pp</code> is a null pointer, the function establishes just an input buffer, by executing:</p>
<pre><code><a href="STREAMBU_basic_streambufCCsetg.htm#basic_streambuf::setg">setg</a>(gp, gp, gp + N);</code></pre>
<p>Otherwise, it establishes both input and output buffers, by executing:</p>
<pre><code>setg(gp, gp, pp);
<a href="STREAMBU_basic_streambufCCsetp.htm#basic_streambuf::setp">setp</a>(pp, gp + N);</code></pre>
<p>In this case, <code>pp</code> must be in the interval <code>[gp, gp + N]</code>. </p>
<p>Finally, the three constructors:</p>
<pre><code><b>strstreambuf</b>(const char *gp, streamsize n);
<b>strstreambuf</b>(const signed char *gp, streamsize n);
<b>strstreambuf</b>(const unsigned char *gp, streamsize n);</code></pre>
<p>all behave the same as:</p>
<pre><code>streambuf((char *)gp, n);</code></pre>
<p>except that the stored mode makes the controlled sequence neither modifiable nor extendable.</p>
</body>
</html>
