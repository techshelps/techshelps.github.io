<html>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>list</title></head>
<body bgcolor=white>

<h2><a name="list">list</a></h2>
<META NAME="MS-HKWD" CONTENT="list">
<p><a href="LIST_listCCallocator_type.htm#list::allocator_type"><code><b>allocator_type</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCassign.htm#list::assign"><code><b>assign</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCback.htm#list::back"><code><b>back</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCbegin.htm#list::begin"><code><b>begin</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCclear.htm#list::clear"><code><b>clear</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCconst_iterator.htm#list::const_iterator"><code><b>const_iterator</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCconst_reference.htm#list::const_reference"><code><b>const_reference</b></code></a><code><b> &#183; 
</b></code><a href="LIST_listCCconst_reverse_iterator.htm#list::const_reverse_iterator"><code><b>const_reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCdifference_type.htm#list::difference_type"><code><b>difference_type</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCempty.htm#list::empty"><code><b>empty</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCend.htm#list::end"><code><b>end</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCerase.htm#list::erase"><code><b>erase</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCfront.htm#list::front"><code><b>front</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCget_allocator.htm#list::get_allocator"><code><b>get_allocator</b></code></a><code><b> &#183; 
</b></code><a href="LIST_listCCinsert.htm#list::insert"><code><b>insert</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCiterator.htm#list::iterator"><code><b>iterator</b></code></a><code><b> &#183; </b></code><a href="LIST_listCClist.htm#list::list"><code><b>list</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCmax_size.htm#list::max_size"><code><b>max_size</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCmerge.htm#list::merge"><code><b>merge</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCpop_back.htm#list::pop_back"><code><b>pop_back</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCpop_front.htm#list::pop_front"><code><b>pop_front</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCpush_back.htm#list::push_back"><code><b>push_back</b></code></a><code><b> &#183; 
</b></code><a href="LIST_listCCpush_front.htm#list::push_front"><code><b>push_front</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCrbegin.htm#list::rbegin"><code><b>rbegin</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCreference.htm#list::reference"><code><b>reference</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCremove.htm#list::remove"><code><b>remove</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCremove_if.htm#list::remove_if"><code><b>remove_if</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCrend.htm#list::rend"><code><b>rend</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCresize.htm#list::resize"><code><b>resize</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCreverse.htm#list::reverse"><code><b>reverse</b></code></a><code><b> &#183; 
</b></code><a href="LIST_listCCreverse_iterator.htm#list::reverse_iterator"><code><b>reverse_iterator</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCsize.htm#list::size"><code><b>size</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCsize_type.htm#list::size_type"><code><b>size_type</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCsort.htm#list::sort"><code><b>sort</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCsplice.htm#list::splice"><code><b>splice</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCswap.htm#list::swap"><code><b>swap</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCunique.htm#list::unique"><code><b>unique</b></code></a><code><b> &#183; </b></code><a href="LIST_listCCvalue_type.htm#list::value_type"><code><b>value_type</b></code></a><code><b> </b></code></p>
<pre><code>template&lt;class T, class A = allocator&lt;T&gt; &gt;
    class <b>list</b> {
public:
    typedef A <a href="LIST_listCCallocator_type.htm#list::allocator_type"><b>allocator_type</b></a>;
    typedef A::size_type <a href="LIST_listCCsize_type.htm#list::size_type"><b>size_type</b></a>;
    typedef A::difference_type <a href="LIST_listCCdifference_type.htm#list::difference_type"><b>difference_type</b></a>;
    typedef A::reference <a href="LIST_listCCreference.htm#list::reference"><b>reference</b></a>;
    typedef A::const_reference <a href="LIST_listCCconst_reference.htm#list::const_reference"><b>const_reference</b></a>;
    typedef A::value_type <a href="LIST_listCCvalue_type.htm#list::value_type"><b>value_type</b></a>;
    typedef T0 <a href="LIST_listCCiterator.htm#list::iterator"><b>iterator</b></a>;
    typedef T1 <a href="LIST_listCCconst_iterator.htm#list::const_iterator"><b>const_iterator</b></a>;
    typedef reverse_bidirectional_iterator&lt;iterator,
        value_type, reference, A::pointer,
            difference_type&gt; <a href="LIST_listCCreverse_iterator.htm#list::reverse_iterator"><b>reverse_iterator</b></a>;
    typedef reverse_bidirectional_iterator&lt;const_iterator,
        value_type, const_reference, A::const_pointer,
             difference_type&gt; <a href="LIST_listCCconst_reverse_iterator.htm#list::const_reverse_iterator"><b>const_reverse_iterator</b></a>;
    explicit <a href="LIST_listCClist.htm#list::list"><b>list</b></a>(const A&amp; al = A());
    explicit <a href="LIST_listCClist.htm#list::list"><b>list</b></a>(size_type n, const T&amp; v = T(), const A&amp; al = A());
    <a href="LIST_listCClist.htm#list::list"><b>list</b></a>(const list&amp; x);
    <a href="LIST_listCClist.htm#list::list"><b>list</b></a>(const_iterator first, const_iterator last,
        const A&amp; al = A());
    iterator <a href="LIST_listCCbegin.htm#list::begin"><b>begin</b></a>();
    const_iterator <a href="LIST_listCCbegin.htm#list::begin"><b>begin</b></a>() const;
    iterator <a href="LIST_listCCend.htm#list::end"><b>end</b></a>();
    iterator <a href="LIST_listCCend.htm#list::end"><b>end</b></a>() const;
    reverse_iterator <a href="LIST_listCCrbegin.htm#list::rbegin"><b>rbegin</b></a>();
    const_reverse_iterator <a href="LIST_listCCrbegin.htm#list::rbegin"><b>rbegin</b></a>() const;
    reverse_iterator <a href="LIST_listCCrend.htm#list::rend"><b>rend</b></a>();
    const_reverse_iterator <a href="LIST_listCCrend.htm#list::rend"><b>rend</b></a>() const;
    void <a href="LIST_listCCresize.htm#list::resize"><b>resize</b></a>(size_type n, T x = T());
    size_type <a href="LIST_listCCsize.htm#list::size"><b>size</b></a>() const;
    size_type <a href="LIST_listCCmax_size.htm#list::max_size"><b>max_size</b></a>() const;
    bool <a href="LIST_listCCempty.htm#list::empty"><b>empty</b></a>() const;
    A <a href="LIST_listCCget_allocator.htm#list::get_allocator"><b>get_allocator</b></a>() const;
    reference <a href="LIST_listCCfront.htm#list::front"><b>front</b></a>();
    const_reference <a href="LIST_listCCfront.htm#list::front"><b>front</b></a>() const;
    reference <a href="LIST_listCCback.htm#list::back"><b>back</b></a>();
    const_reference <a href="LIST_listCCback.htm#list::back"><b>back</b></a>() const;
    void <a href="LIST_listCCpush_front.htm#list::push_front"><b>push_front</b></a>(const T&amp; x);
    void <a href="LIST_listCCpop_front.htm#list::pop_front"><b>pop_front</b></a>();
    void <a href="LIST_listCCpush_back.htm#list::push_back"><b>push_back</b></a>(const T&amp; x);
    void <a href="LIST_listCCpop_back.htm#list::pop_back"><b>pop_back</b></a>();
    void <a href="LIST_listCCassign.htm#list::assign"><b>assign</b></a>(const_iterator first, const_iterator last);
    void <a href="LIST_listCCassign.htm#list::assign"><b>assign</b></a>(size_type n, const T&amp; x = T());
    iterator <a href="LIST_listCCinsert.htm#list::insert"><b>insert</b></a>(iterator it, const T&amp; x = T());
    void <a href="LIST_listCCinsert.htm#list::insert"><b>insert</b></a>(iterator it, size_type n, const T&amp; x);
    void <a href="LIST_listCCinsert.htm#list::insert"><b>insert</b></a>(iterator it,
        const_iterator first, const_iterator last);
    void <a href="LIST_listCCinsert.htm#list::insert"><b>insert</b></a>(iterator it,
        const T *first, const T *last);
    iterator <a href="LIST_listCCerase.htm#list::erase"><b>erase</b></a>(iterator it);
    iterator <a href="LIST_listCCerase.htm#list::erase"><b>erase</b></a>(iterator first, iterator last);
    void <a href="LIST_listCCclear.htm#list::clear"><b>clear</b></a>();
    void <a href="LIST_listCCswap.htm#list::swap"><b>swap</b></a>(list x);
    void <a href="LIST_listCCsplice.htm#list::splice"><b>splice</b></a>(iterator it, list&amp; x);
    void <a href="LIST_listCCsplice.htm#list::splice"><b>splice</b></a>(iterator it, list&amp; x, iterator first);
    void <a href="LIST_listCCsplice.htm#list::splice"><b>splice</b></a>(iterator it, list&amp; x, iterator first, iterator last);
    void <a href="LIST_listCCremove.htm#list::remove"><b>remove</b></a>(const T&amp; x);
    void <a href="LIST_listCCremove_if.htm#list::remove_if"><b>remove_if</b></a>(binder2nd&lt;not_equal_to&lt;T&gt; &gt; pr);
    void <a href="LIST_listCCunique.htm#list::unique"><b>unique</b></a>();
    void <a href="LIST_listCCunique.htm#list::unique"><b>unique</b></a>(not_equal_to&lt;T&gt; pr);
    void <a href="LIST_listCCmerge.htm#list::merge"><b>merge</b></a>(list&amp; x);
    void <a href="LIST_listCCmerge.htm#list::merge"><b>merge</b></a>(list&amp; x, greater&lt;T&gt; pr);
    void <a href="LIST_listCCsort.htm#list::sort"><b>sort</b></a>();
    template&lt;class Pred&gt;
        void <a href="LIST_listCCsort.htm#list::sort"><b>sort</b></a>(greater&lt;T&gt; pr);
    void <a href="LIST_listCCreverse.htm#list::reverse"><b>reverse</b></a>();
protected:
    A allocator;
    };</code></pre>
<p>The template class describes an object that controls a varying-length sequence of elements of type <code><b>T</b></code>. The sequence is 
stored as a bidirectional linked list of elements, each containing a member of type <code>T</code>.</p>
<p>The object allocates and frees storage for the sequence it controls through a protected object named <a name="list::allocator"><code><b>allocator</b></code></a>, of 
<b>class </b><code><b>A</b></code>. Such an <a href="MEMORY_allocator.htm#allocator object">allocator object</a> must have the same external interface as an object of template class <a href="MEMORY_allocator.htm#allocator"><code>allocator</code></a>. 
Note that <code>allocator</code> is not copied when the object is assigned.</p>
<p><a name="list reallocation"><b>List reallocation</b></a> occurs when a member function must insert or erase elements of the controlled sequence. In all such 
cases, only iterators or references that point at erased portions of the controlled sequence become <a name="invalid list iterators"><b>invalid</b></a>.</p>
</body>
</html>
