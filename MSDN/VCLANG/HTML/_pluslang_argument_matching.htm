<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Argument Matching</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_argument_matching"></a><sup></sup>Argument Matching</h1>
<p>
Overloaded functions are selected for the best match of function declarations in the current scope to the arguments supplied in the function call. If a suitable function is found, that function is called. “Suitable” in this context means one of the following:
<ul type=disc>
<li>
An exact match was found.<br><br></li>
<li>
A trivial conversion was performed.<br><br></li>
<li>
An integral promotion was performed.<br><br></li>
<li>
A standard conversion to the desired argument type exists.<br><br></li>
<li>
A user-defined conversion (either conversion operator or constructor) to the desired argument type exists.<br><br></li>
<li>
Arguments represented by an ellipsis were found.</li>
</ul>
<p>
The compiler creates a set of candidate functions for each argument. Candidate functions are functions in which the actual argument in that position can be converted to the type of the formal argument.</p>
<p>
A set of “best matching functions” is built for each argument, and the selected function is the intersection of all the sets. If the intersection contains more than one function, the overloading is ambiguous and generates an error. The function that is eventually selected is always a better match than every other function in the group for at least one argument. If this is not the case (if there is no clear winner), the function call generates an error.</p>
<p>
Consider the following declarations (the functions are marked <code>Variant 1</code>, <code>Variant 2</code>, and <code>Variant 3</code>, for identification in the following discussion):</p>
<pre><code>Fraction &amp;Add( Fraction &amp;f, long l );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variant 1
Fraction &amp;Add( long l, Fraction &amp;f );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variant 2
Fraction &amp;Add( Fraction &amp;f, Fraction &amp;f );&nbsp; // Variant 3

Fraction F1, F2;
</code></pre>
<p>
Consider the following statement:</p>
<pre><code>F1 = Add( F2, 23 );
</code></pre>
<p>
The preceding statement builds two sets: </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>Set 1: Candidate Functions That Have First Argument of Type Fraction</b></td>
<td class=label width=54%><b>Set 2: Candidate Functions Whose Second Argument Can Be Converted to Type int</b></td>
</tr>
<tr valign=top>
<td width=46%>Variant 1</td>
<td width=54%>Variant 1 (<b>int</b> can be converted to <b>long</b> using a standard conversion)</td>
</tr>
<tr valign=top>
<td width=46%>Variant 3</td>
<td width=54%></td>
</tr>
</table><br>
<p>
Functions in Set 2 are functions for which there are implicit conversions from actual parameter type to formal parameter type, and among such functions there is a function for which the “cost” of converting the actual parameter type to its formal parameter type is the smallest. </p>
<p>
The intersection of these two sets is Variant 1. An example of an ambiguous function call is:</p>
<pre><code>F1 = Add( 3, 6 );
</code></pre>
<p>
The preceding function call builds the following sets:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Set 1: Candidate Functions That Have First Argument of Type int</b></td>
<td class=label width=50%><b>Set 2: Candidate Functions That Have Second Argument of Type int</b></td>
</tr>
<tr valign=top>
<td width=50%>Variant 2 (<b>int</b> can be converted to <b>long</b> using a standard conversion)</td>
<td width=50%>Variant 1 (<b>int</b> can be converted to <b>long</b> using a standard conversion)</td>
</tr>
</table><br>
<p>
Note that the intersection between these two sets is empty. Therefore, the compiler generates an error message.</p>
<p>
For argument matching, a function with <i>n</i> default arguments is treated as <i>n</i>+1 separate functions, each with a different number of arguments.</p>
<p>
The ellipsis (...) acts as a wildcard; it matches any actual argument. This can lead to many ambiguous sets, if you do not design your overloaded function sets with extreme care.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Ambiguity of overloaded functions cannot be determined until a function call is encountered. At that point, the sets are built for each argument in the function call, and you can determine whether an unambiguous overload exists. This means that ambiguities can remain in your code until they are evoked by a particular function call.</p>
</font></BODY>
</HTML>
