<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Conversion Functions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_conversion_functions"></a><sup></sup>Conversion Functions</h1>
<p>
In conversion by constructors, described in the previous section, objects of one type can be implicitly converted to a particular class type. This section describes a means by which you can provide explicit conversions from a given class type to another type. Conversion from a class type is often accomplished using conversion functions. Conversion functions use the following syntax:</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>conversion-function-name</i> :</p>
<p class=indent>
<b>operator</b>  <i>conversion-type-name</i>  <b>()</b></p>
<p class=dt>
<i>conversion-type-name</i> :</p>
<p class=indent>
<i>type-specifier-list</i>  <i>ptr-operator</i><sub>opt</sub></p>
<p>
The following example specifies a conversion function that converts type <code>Money</code> to type <code>double</code>:</p>
<pre><code>class Money
{
public:
 &nbsp;&nbsp; Money();
 &nbsp;&nbsp; operator double() { return _amount; }
private:
 &nbsp;&nbsp; double _amount;
};
</code></pre>
<p>
Given the preceding class declaration, the following code can be written:</p>
<pre><code>Money Account;
...
double CashOnHand = Account;
</code></pre>
<p>
The initialization of <code>CashOnHand</code> with <code>Account</code> causes a conversion from type <code>Account</code> to type <code>double</code>.</p>
<p>
Conversion functions are often called “cast operators” because they (along with constructors) are the functions called when a cast is used. The following example uses a cast, or explicit conversion, to print the current value of an object of type <code>Money</code>:</p>
<pre><code>cout &lt;&lt; (double)Account &lt;&lt; endl;
</code></pre>
<p>
Conversion functions are inherited in derived classes. Conversion operators hide only base-class conversion operators that convert to exactly the same type. Therefore, a user-defined <b>operator int </b>function does not hide a user-defined <b>operator short </b>function in a base class.</p>
<p>
Only one user-defined conversion function is applied when performing implicit conversions. If there is no explicitly defined conversion function, the compiler does not look for intermediate types into which an object can be converted.</p>
<p>
If a conversion is required that causes an ambiguity, an error is generated. Ambiguities arise when more than one user-defined conversion is available or when a user-defined conversion and a built-in conversion exist. </p>
<p>
The following example illustrates a class declaration with a potential ambiguity:</p>
<pre><code>#include &lt;string.h&gt;

class String
{
public:
 &nbsp;&nbsp; // Define constructor that converts from type char *.
 &nbsp;&nbsp; String( char *s ) { strcpy( _text, s ); }
 &nbsp;&nbsp; // Define conversion to type char *.
 &nbsp;&nbsp; operator char *() { return _text; }
 &nbsp;&nbsp; int operator==( const String &amp;s ) 
 &nbsp;&nbsp; { return !strcmp( _text, s._text ); }
private:
 &nbsp;&nbsp; char _text[80];
};

int main()
{
 &nbsp;&nbsp; String s( "abcd" );
 &nbsp;&nbsp; char&nbsp; *ch = "efgh";

 &nbsp;&nbsp; // Cause the compiler to select a conversion.
 &nbsp;&nbsp; return s == ch;
}
</code></pre>
<p>
In the expression <code>s == ch</code>, the compiler has two choices and no way of determining which is correct. It can convert <code>ch</code> to an object of type <code>String</code> using the constructor and then perform the comparison using the user-defined <code>operator==</code>. Or it can convert <code>s</code> to a pointer of type <code>char *</code> using the conversion function and then perform a comparison of the pointers.</p>
<p>
Because neither choice is “more correct” than the other, the compiler cannot determine the meaning of the comparison expression, and it generates an error.</p>
</font></BODY>
</HTML>
