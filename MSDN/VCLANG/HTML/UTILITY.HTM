</html>
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<html>

<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>&lt;utility&gt;</title>
<meta name="GENERATOR" content="Microsoft FrontPage 1.1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
</head>

<body bgcolor=white>

<h1><a name="&lt;utility&gt;">&lt;utility&gt;</a></h1>
<META NAME="MS-HKWD" CONTENT="utility header file">
<pre><code>namespace std {
//      <b>TEMPLATE CLASSES</b>
template&lt;class T, class U&gt;
    struct <a href="UTILITY_pair.htm#pair"><b>pair</b></a>;
//      <b>TEMPLATE FUNCTIONS</b>
template&lt;class T, class U&gt;
    pair&lt;T, U&gt; <a href="UTILITY_make_pair.htm#make_pair"><b>make_pair</b></a>(const T&amp; x, const U&amp; y);
template&lt;class T, class U&gt;
    bool <a href="UTILITY_operatorEE.htm#operator=="><b>operator==</b></a>(const pair&lt;T, U&gt;&amp; x, const pair&lt;T, U&gt;&amp; y);
template&lt;class T, class U&gt;
    bool <a href="UTILITY_operatorNE.htm#operator!="><b>operator!=</b></a>(const pair&lt;T, U&gt;&amp; x, const pair&lt;T, U&gt;&amp; y);
template&lt;class T, class U&gt;
    bool <a href="UTILITY_operatorL.htm#operator&lt;"><b>operator&lt;</b></a>(const pair&lt;T, U&gt;&amp; x, const pair&lt;T, U&gt;&amp; y);
template&lt;class T, class U&gt;
    bool <a href="UTILITY_operatorG.htm#operator&gt;"><b>operator&gt;</b></a>(const pair&lt;T, U&gt;&amp; x, const pair&lt;T, U&gt;&amp; y);
template&lt;class T, class U&gt;
    bool <a href="UTILITY_operatorLE.htm#operator&lt;="><b>operator&lt;=</b></a>(const pair&lt;T, U&gt;&amp; x, const pair&lt;T, U&gt;&amp; y);
template&lt;class T, class U&gt;
    bool <a href="UTILITY_operatorGE.htm#operator&gt;="><b>operator&gt;=</b></a>(const pair&lt;T, U&gt;&amp; x, const pair&lt;T, U&gt;&amp; y);
namespace rel_ops {
    template&lt;class T&gt;
        bool <a href="UTILITY_operatorNE.htm#operator!="><b>operator!=</b></a>(const T&amp; x, const T&amp; y);
    template&lt;class T&gt;
        bool <a href="UTILITY_operatorLE.htm#operator&lt;="><b>operator&lt;=</b></a>(const T&amp; x, const T&amp; y);
    template&lt;class T&gt;
        bool <a href="UTILITY_operatorG.htm#operator&gt;"><b>operator&gt;</b></a>(const T&amp; x, const T&amp; y);
    template&lt;class T&gt;
        bool <a href="UTILITY_operatorGE.htm#operator&gt;="><b>operator&gt;=</b></a>(const T&amp; x, const T&amp; y);
        };
    };</code></pre>
<p>Include the <a href="INDEX_Table_of_Contents.htm#STL">STL</a> standard header <code><b>&lt;utility&gt;</b></code> to define several templates of general use throughout the Standard 
Template Library.</p>
<p>Four template operators -- <code>operator!=</code>, <code>operator&lt;=</code>, <code>operator&gt;</code>, and <code>operator&gt;=</code> -- define a <a name="total ordering"><b>total ordering</b></a> on 
pairs of operands of the same type, given definitions of <code>operator==</code> and <code>operator&lt;</code>. </p>
<p>If an <a href="INDEX_Table_of_Contents.htm#implementation">implementation</a> supports namespaces, these template operators are defined in the <a name="rel_ops"><code><b>rel_ops</b></code></a> namespace, nested 
within the <code>std</code> namespace. If you wish to use these template operators, write the declaration:</p>
<p><code>using namespace std::rel_ops;</code></p>
<p>which promotes the template operators into the current namespace.</p>

</body>
</html>
