<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Structured Exception Handling</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_pluslang_structured_exception_handling"></a><sup></sup>Structured Exception Handling</h1>
<p>
The <b>__try</b>/<b>__except</b> and <b>__try/__finally</b> statements are a Microsoft extension to the C language that enables applications to gain control of a program after events that would normally terminate execution.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Structured exception handling works with C and C++ source files. However, it is not specifically designed for C++. Although destructors for local objects will be called if you use structured exception handling in a C++ program (if you use the /GX compiler option), you can ensure that your code is more portable by using C++ exception handling. The C++ exception handling mechanism is more flexible, in that it can handle exceptions of any type.</p>
<p class=indent>
For more information, see <a href="_clang_the_try.2d.except_statement.htm">The try-except Statement</a> and <a href="_clang_the_try.2d.finally_statement.htm">The try-finally Statement</a> in the <i>C Language Reference</i>.</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>try-except-statement</i> :</p>
<p class=indent>
<b>__try</b> <i>compound-statement</i><br>
<b>__except</b> <b>(</b> <i>expression</i> <b>)</b> <i>compound-statement</i></p>
<p class=dt>
<i>try-finally-statement</i> :</p>
<p class=indent>
<b>__try</b> <i>compound-statement</i><br>
<b>__finally</b> <i>compound-statement</i></p>
<p>
If you have C modules that use structured exception handling, they can be mixed with C++ modules that use C++ exception handling. When a C (structured) exception is raised, it can be handled by the C handler, or it can be caught by a C++ <b>catch</b> handler, whichever is dynamically closest to the exception context. One of the major differences between the two models is that when a C exception is raised, it is always of type unsigned int, whereas a C++ exception can be of any type. That is, C exceptions are identified by an unsigned integer value, whereas C++ exceptions are identified by data type. However, while a C++ <b>catch</b> handler can catch a C exception (for example, via an “ellipsis” <b>catch</b> handler), a C exception can also be handled as a typed exception by using a C exception wrapper class. By deriving from this class, each C exception can be attributed a specific derived class.</p>
<p>
To use a C exception wrapper class, you install a custom C exception translator function which is called by the internal exception handling mechanism each time a C exception is thrown. Within your translator function, you can throw any typed exception, which can be caught by an appropriate matching C++ <b>catch</b> handler. To specify a custom translation function, call the <code>_set_se_translator</code> function with the name of your translation function as its single argument.</p>
</font></BODY>
</HTML>
