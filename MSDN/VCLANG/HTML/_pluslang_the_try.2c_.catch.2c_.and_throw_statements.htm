<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The try, catch, and throw Statements</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2"><h1><a name="_pluslang_the_try.2c_.catch.2c_.and_throw_statements"></a><sup></sup>The try, catch, and throw Statements</h1>
<p>
The C++ language provides built-in support for handling anomalous situations, known as “exceptions,” which may occur during the execution of your program. The <b>try</b>, <b>throw</b>, and <b>catch</b> statements have been added to the C++ language to implement exception handling. With C++ exception handling, your program can communicate unexpected events to a higher execution context that is better able to recover from such abnormal events. These exceptions are handled by code which is outside the normal flow of control. The Microsoft C++ compiler implements the C++ exception handling model based on the ISO WG21/ANSI X3J16 working papers towards the evolving standard for C++.</p>
<p class=label>
<b>Syntax</b></p>
<p class=dt>
<i>try-block</i> :</p>
<p class=indent>
<b>try</b> <i>compound-statement handler-list</i></p>
<p class=dt>
<i>handler-list</i> :</p>
<p class=indent>
<i>handler handler-list</i><sub>opt</sub></p>
<p class=dt>
<i>handler</i> :</p>
<p class=indent>
<b>catch</b> ( <i>exception-declaration</i> <b>)</b> <i>compound-statement</i></p>
<p class=dt>
<i>exception-declaration</i> :</p>
<p class=indent>
<i>type-specifier-list declarator</i><br>
<i>type-specifier-list abstract-declarator</i><br>
<i>type-specifier-list</i><br>
<b>...</b></p>
<p class=dt>
<i>throw-expression</i> :</p>
<p class=indent>
<b>throw</b> <i>assignment-expression</i><sub>opt</sub></p>
<p>
The <i>compound-statement</i> after the <b>try</b> clause is the guarded section of code. The <i>throw-expression</i> “throws” (raises) an exception. The <i>compound-statement</i> after the <b>catch</b> clause is the exception handler, and “catches” (handles) the exception thrown by the throw-expression. The <i>exception-declaration</i> statement indicates the type of exception the clause handles. The type can be any valid data type, including a C++ class. If the exception-declaration statement is an ellipsis (<b>...</b>), the <b>catch</b> clause handles any type of exception, including a C exception. Such a handler must be the last handler for its <b>try</b> block.</p>
<p>
The operand of <b>throw</b> is syntactically similar to the operand of a <b>return</b> statement.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Microsoft C++ does not support the function <b>throw</b> signature mechanism, as described in section 15.5 of the ANSI C++ draft. In addition, it does not support <i>function-try-block</i> described in section 15 of the ANSI C++ draft.</p>
<p>
Execution proceeds as follows:
<ol>
<li>
Control reaches the <b>try</b> statement by normal sequential execution. The guarded section (within the <b>try</b> block) is executed.<br><br></li>
<li>
If no exception is thrown during execution of the guarded section, the <b>catch</b> clauses that follow the <b>try</b> block are not executed. Execution continues at the statement after the last <b>catch</b> clause following the <b>try</b> block in which the exception was thrown.<br><br></li>
<li>
If an exception is thrown during execution of the guarded section or in any routine the guarded section calls (either directly or indirectly), an exception object is created from the object created by the <b>throw</b> operand. (This implies that a copy constructor may be involved.) At this point, the compiler looks for a <b>catch</b> clause in a higher execution context that can handle an exception of the type thrown (or a <b>catch</b> handler that can handle any type of exception). The <b>catch</b> handlers are examined in order of their appearance following the <b>try</b> block. If no appropriate handler is found, the next dynamically enclosing <b>try</b> block is examined. This process continues until the outermost enclosing <b>try</b> block is examined. <br><br></li>
<li>
If a matching handler is still not found, or if an exception occurs while unwinding, but before the handler gets control, the predefined run-time function <code>terminate</code> is called. If an exception occurs after throwing the exception, but before the unwind begins, <code>terminate</code> is called. <br><br></li>
<li>
If a matching <b>catch</b> handler is found, and it catches by value, its formal parameter is initialized by copying the exception object. If it catches by reference, the parameter is initialized to refer to the exception object. After the formal parameter is initialized, the process of “unwinding the stack” begins. This involves the destruction of all automatic objects that were constructed (but not yet destructed) between the beginning of the <b>try</b> block associated with the <b>catch</b> handler and the exception’s throw site. Destruction occurs in reverse order of construction. The <b>catch</b> handler is executed and the program resumes execution following the last handler (that is, the first statement or construct which is not a <b>catch</b> handler). Control can only enter a <b>catch</b> handler through a thrown exception; never via a <code>goto</code> statement or a <code>case</code> label in a <code>switch</code> statement.</li>
</ol>
<p>
The following is a simple example of a <b>try</b> block and its associated <b>catch</b> handler. This example detects failure of a memory allocation operation using the <b>new</b> operator. If <b>new</b> is successful, the <b>catch</b> handler is never executed:</p>
<pre><code>#include &lt;iostream.h&gt;

int main()
{
 &nbsp;&nbsp; char *buf;
 &nbsp;&nbsp; try
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf = new char[512];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( buf == 0 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw "Memory allocation failure!";
 &nbsp;&nbsp; }
 &nbsp;&nbsp; catch( char * str )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Exception raised: " &lt;&lt; str &lt;&lt; '\n';
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // ...
 &nbsp;&nbsp; return 0;
}
</code></pre>
<p>
The operand of the <b>throw</b> expression specifies that an exception of type <code>char *</code> is being thrown. It is handled by a <b>catch</b> handler that expresses the ability to catch an exception of type <code>char *</code>. In the event of a memory allocation failure, this is the output from the preceding example:</p>
<pre><code>Exception raised: Memory allocation failure!
</code></pre>
<p>
The real power of C++ exception handling lies not only in its ability to deal with exceptions of varying types, but also in its ability to automatically call destructor functions during stack unwinding, for all local objects constructed before the exception was thrown.</p>
<p>
The following example demonstrates C++ exception handling using classes with destructor semantics:</p>
<pre><code>#include &lt;iostream.h&gt;

void MyFunc( void );

class CTest
{
public:
 &nbsp;&nbsp; CTest(){};
 &nbsp;&nbsp; ~CTest(){};
 &nbsp;&nbsp; const char *ShowReason() const { return "Exception in CTest class."; }

};

class CDtorDemo
{
public:
 &nbsp;&nbsp; CDtorDemo();
 &nbsp;&nbsp; ~CDtorDemo();
};

CDtorDemo::CDtorDemo()
{
 &nbsp;&nbsp; cout &lt;&lt; "Constructing CDtorDemo.\n";
}

CDtorDemo::~CDtorDemo()
{
 &nbsp;&nbsp; cout &lt;&lt; "Destructing CDtorDemo.\n";
}

void MyFunc()
{

 &nbsp;&nbsp; CDtorDemo D;
 &nbsp;&nbsp; cout&lt;&lt; "In MyFunc(). Throwing CTest exception.\n";
 &nbsp;&nbsp; throw CTest();
}

int main()
{
 &nbsp;&nbsp; cout &lt;&lt; "In main.\n";
 &nbsp;&nbsp; try
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "In try block, calling MyFunc().\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyFunc();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; catch( CTest E )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "In catch handler.\n";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Caught CTest exception type: ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; E.ShowReason() &lt;&lt; "\n";
 &nbsp;&nbsp; }
 &nbsp;&nbsp; catch( char *str )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Caught some other exception: " &lt;&lt; str &lt;&lt; "\n";
 &nbsp;&nbsp; }
 &nbsp;&nbsp; cout &lt;&lt; "Back in main. Execution resumes here.\n";
 &nbsp;&nbsp; return 0;
}
</code></pre>
<p>
This is the output from the preceding example:</p>
<pre><code>In main.
In try block, calling MyFunc().
Constructing CDtorDemo.
In MyFunc(). Throwing CTest exception.
Destructing CDtorDemo.
In catch handler.
Caught CTest exception type: Exception in CTest class.
Back in main. Execution resumes here.
</code></pre>
<p>
Note that in this example, the exception parameter (the argument to the <b>catch</b> clause) is declared in both <b>catch</b> handlers:</p>
<pre><code>catch( CTest E )
// ...
catch( char *str )
// ...
</code></pre>
<p>
You do not need to declare this parameter; in many cases it may be sufficient to notify the handler that a particular type of exception has occurred. However, if you do not declare an exception object in the exception-declaration, you will not have access to that object in the <b>catch</b> handler clause.</p>
<p>
A throw-expression with no operand re-throws the exception currently being handled. Such an expression should appear only in a <b>catch</b> handler or in a function called from within a <b>catch</b> handler. The re-thrown exception object is the original exception object (not a copy). For example:</p>
<pre><code>try
{
 &nbsp;&nbsp; throw CSomeOtherException();
}
catch(...)    &nbsp;&nbsp; // Handle all exceptions
{
 &nbsp;&nbsp; // Respond (perhaps only partially) to exception
 &nbsp;&nbsp; // ...

 &nbsp;&nbsp; throw;    &nbsp;&nbsp; // Pass exception to some other handler
}
</code></pre>
</font></BODY>
</HTML>
