<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Mutex Objects</TITLE>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_Win32_CreateMutex">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_Win32_CreateMutex">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_ReleaseMutex">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_Win32_CreateMutex">
</OBJECT>
</TD></TR></TABLE>



<H3>

<A NAME="_mutex_objects"></A>Mutex Objects</H3>

<P>A <I>mutex object</I> is a synchronization object whose state is set to signaled when it is not owned by any thread, and nonsignaled when it is owned. Its name comes from its usefulness in coordinating mutually-exclusive access to a shared resource. Only one thread at a time can own a mutex object. For example, to prevent two threads from writing to shared memory at the same time, each thread waits for ownership of a mutex object before executing the code that accesses the memory. After writing to the shared memory, the thread releases the mutex object.</P>

<P>A thread uses the <A HREF="JavaScript:hhobj_1.Click()"><B>CreateMutex</B></A> function to create a mutex object. The creating thread can request immediate ownership of the mutex object and can also specify a name for the mutex object. Threads in other processes can open a handle to an existing mutex object by specifying its name in a call to <A HREF="JavaScript:hhobj_2.Click()"><B>CreateMutex</B></A>.  For additional information about names for mutex and event objects, see <A HREF="procs_8f8u.htm">Interprocess Synchronization</A>. </P>

<P>Any thread with a handle of a mutex object can use one of the wait functions to request ownership of the mutex object. If the mutex object is owned by another thread, the wait function blocks the requesting thread until the owning thread releases the mutex object using the <A HREF="JavaScript:hhobj_3.Click()"><B>ReleaseMutex</B></A> function. The return value of the wait function indicates whether the function returned for some reason other than the state of the mutex being set to signaled. </P>

<P>Once a thread owns a mutex, it can specify the same mutex in repeated calls to one of the wait functions without blocking its execution. This prevents a thread from deadlocking itself while waiting for a mutex that it already owns. To release its ownership under such circumstances, the thread must call <B>ReleaseMutex</B> once for each time that the mutex satisfied the conditions of a wait function. </P>

<P>If a thread terminates without releasing its ownership of a mutex object, the mutex object is considered to be abandoned. A waiting thread can acquire ownership of an abandoned mutex object, but the wait function's return value indicates that the mutex object is abandoned. To be safe, assume that an abandoned mutex object indicates that an error has occurred and that any shared resource being protected by the mutex object is in an undefined state. If the thread proceeds as though the mutex object had not been abandoned, the object's abandoned flag is cleared when the thread releases its ownership. This restores typical behavior, if a handle to the mutex object is subsequently specified in a wait function. </P>

<P>In the following code examples, a process uses the <A HREF="JavaScript:hhobj_4.Click()"><B>CreateMutex</B></A> function first to create a named mutex object, and in the second piece of code, to open a handle of an existing mutex object. Additionally, it uses structured exception-handling to ensure that the thread properly releases the mutex object.</P>

<PRE><CODE>HANDLE hMutex; 


hMutex = CreateMutex
      ( 
      NULL,                             // no security attributes
      FALSE,                            // initially not owned
      "MutexToProtectDatabase");        // name of mutex

if (hMutex == NULL) 
{
                                        // Check for error.
}
</CODE></PRE>

<P>When a thread of this process writes to the database, it first requests ownership of the mutex. If it gets ownership, the thread writes to the database and then releases its ownership. </P>

<P>The example uses the <B>try</B>-<B>finally</B> structured exception-handling syntax to ensure that the thread properly releases the mutex object. To prevent the mutex object from being abandoned inadvertently, the <B>finally</B> block of code is executed no matter how the <B>try</B> block terminates — unless the <B>try</B> block includes a call to the <B>TerminateThread</B> function.</P>

<PRE><CODE>BOOL FunctionToWriteToDatabase(HANDLE hMutex) 
{ 
      DWORD dwWaitResult; 

 
      dwWaitResult = WaitForSingleObject( 
         hMutex,        // handle of mutex
         5000L);        // five-second time-out interval
 
      switch (dwWaitResult) 
      {
         case WAIT_OBJECT_0: 
            try 
            { 
                        // Write to the database.
            } 

            finally 
            { 
               if (! ReleaseMutex(hMutex)) 
               { 
                        // Deal with error.
               } 

            break; 
            } 

                        // Cannot get mutex ownership due to time-out.
        case WAIT_TIMEOUT: 
            return FALSE; 

                        // Got ownership of the abandoned mutex object.
        case WAIT_ABANDONED: 
            return FALSE; 
      }

      return TRUE; 
}
 </CODE></PRE>

</BODY>
</HTML>
