<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sample Windows-Based Application</TITLE>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">



<H1>

<A NAME="_sample_windows_based_application"></A>Sample Windows-Based Application</H1>

<P>Every Windows CE-based application must have <B>WinMain</B> as its entry point function. <B>WinMain </B>performs a number of tasks, including registering the window class for the main window and creating the main window. <B>WinMain </B>registers the main window class by calling the <B>RegisterClass</B> function and it creates the main window by calling the <B>CreateWindowEx</B> function. <B>WinMain</B> does not need to do these things itself; it can call other functions to perform any or all of these tasks.</P>

<P>The system does not automatically display the main window after creating it. Rather, the application's <B>WinMain</B> function uses the <B>ShowWindow</B> function to display the window.</P>

<P>Even the simplest Windows-based application has a message loop and a window procedure. The message loop, typically part of an application's <B>WinMain</B> function, enables your application to receive messages and to dispatch them to the appropriate window procedure. The window procedure is a function that processes the messages that the system sends to your window. The system calls your window procedure as a result of the messages that your message loop receives and dispatches. You usually do not call your window procedure directly from your application. Each window class specifies an initial window procedure. </P>

<P>This section contains a code example that is used to create a simple Windows-based application. This sample application demonstrates the basic framework common to all Windows-based applications, and begins executing with the <B>WinMain</B> function that performs the following tasks:

<OL>
	<LI><B>WinMain</B> stashes the application-instance handle in a global variable. Because this handle is used in various places throughout a program, it is common to put it in a global variable that is accessible to all functions. The smallest possible interval a timer can measure is the system-tick interval.  </LI>

	<LI><B>WinMain</B> calls the application-defined <B>InitApplication</B> function that calls the <B>RegisterClass</B> function to register the application's main window class. More complicated applications may need to register more window classes and to determine whether other instances of the application are running.</LI>

	<LI><B>WinMain</B> calls the application-defined <B>InitInstance</B> function that calls the <B>CreateWindow</B> function to create a window. <B>CreateWindow</B> returns a window handle identifying the new window. This handle is used to refer to the window in subsequent function calls.</LI>

	<LI><B>WinMain</B> creates the message loop by calling the <B>GetMessage</B>, <B>TranslateMessage</B>, and <B>DispatchMessage </B>functions in the format displayed in the sample application. This loop receives messages and dispatches them to the window procedures.</LI>
</OL>

<P>Note that the application does not directly call the window procedure, <B>MainWndProc</B>. The system calls this function as the message loop receives and dispatches messages. In this application, <B>MainWndProc</B> processes only the WM_CLOSE message that tells the window to close. When the window receives a WM_CLOSE message, it calls the <B>PostQuitMessage</B> function that causes the next call to<B> GetMessage</B> to return FALSE. This, in turn, causes the message loop to terminate and the application to exit.</P>

<P>Windows CE sends many other messages to the window besides WM_CLOSE. <B>MainWndProc</B> passes all other messages to the <B>DefWindowProc </B>function, which is the default window procedure provided by the system. You should pass all messages to <B>DefWindowProc</B> that you do not process yourself; otherwise, your window may not function correctly. </P>

<PRE><CODE>#include &lt;windows.h&gt;
#define ZeroVar(v) \ memset(&amp;v, 0, sizeof(v))

HINSTANCE g_hInstance;

const TCHAR* const pszMainWndClassName = TEXT("MainWndClass");

//Here is the application's window procedure.
LRESULT CALLBACK MainWndProc(
  HWND hwnd,
  UINT message,
  WPARAM wParam,
  LPARAM lParam
  )
{
  switch ( message )
   {
   case WM_CLOSE:
      DestroyWindow(hwnd);
      PostQuitMessage(0);
      return 0;
   }
   return DefWindowProc(hwnd, message, wParam, lParam);
}

BOOL InitInstance(void)
{
   BOOL    bRet = FALSE;
   HWND    hwndMain;

   hwndMain = CreateWindow(
         pszMainWndClassName,
         TEXT("Main"),
         WS_OVERLAPPED|WS_SYSMENU,
         CW_USEDEFAULT, CW_USEDEFAULT,
         CW_USEDEFAULT, CW_USEDEFAULT,
         NULL,
         NULL,
         g_hInstance,
         NULL
         );

   ShowWindow(hwndMain, SW_SHOW);
   UpdateWindow(hwndMain);

   bRet = TRUE;

   return bRet;
}

BOOL InitApplication(void)
{
   BOOL bRet = FALSE;
   WNDCLASS    wc;

   ZeroVar(wc);

   //    Set up information about the class.
   wc.style                 = 0;
   wc.lpfnWndProc           = MainWndProc;
   wc.cbClsExtra            = 0;
   wc.cbWndExtra            = 0;
   wc.hInstance             = g_hInstance;
   wc.hIcon                 = 0;
   wc.hCursor               = 0;
   wc.hbrBackground         = (HBRUSH)GetStockObject(WHITE_BRUSH);
   wc.lpszMenuName          = NULL;
   wc.lpszClassName         = pszMainWndClassName;

   bRet = RegisterClass(&amp;wc);
   return bRet;
}
int WINAPI WinMain (
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPTSTR     lpCmdLine,
   int nCmdShow
   )
{
   MSG msg;
   g_hInstance = hInstance;

   if ( !InitApplication() )
      { 
      goto leave;
      }

   if ( !InitInstance() )
      {
      goto leave;
   }


   while ( GetMessage(&amp;msg, NULL, 0, 0) )
      {
      TranslateMessage(&amp;msg);
      DispatchMessage(&amp;msg);
      }

leave:
   return 0;
}
</CODE></PRE>

</BODY>
</HTML>
