<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>14.3.3 Hiding of Names by Local Variables</title>
<META NAME=MS-HAID CONTENT="14_3_3">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>14.3.3	 Hiding of Names by Local Variables</h3>
<a name="32673"></a>
<p>
<a name="32716"></a>
If a name declared as a local variable is already declared as a field or type name, 
then that outer declaration is hidden throughout the scope of the local variable. 
The field or type name can almost always <a href="6_8.htm#11186">(&#167;6.8)</a> still be accessed using an appropriately qualified name. For example, the keyword <code>this</code> can be used to access a 
hidden field <code>x</code>, using the form <code>this.x</code>. Indeed, this idiom typically appears in constructors <a href="8_6.htm#41652">(&#167;8.6)</a>:
<p><pre><a name="32566"></a>
class Pair {
<a name="32567"></a>	Object first, second;
<a name="32568"></a>	public Pair(Object first, Object second) {
<a name="32569"></a>		this.first = first;
<a name="32570"></a>		this.second = second;
<a name="32571"></a>	}
<a name="32572"></a>}
</pre><p><a name="32573"></a>
In this example, the constructor takes parameters having the same names as the 
fields to be initialized. This is simpler than having to invent different names for 
the parameters and is not too confusing in this stylized context. In general, however, it is considered poor style to have local variables with the same names as 
fields.
<p>

</body></html>
