<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.1.3 Narrowing Primitive Conversions</title>
<META NAME=MS-HAID CONTENT="5_1_3">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>5.1.3	 Narrowing Primitive Conversions</h3>
<a name="175672"></a>
<p>
<a name="25363"></a>
The following 23 specific conversions on primitive types are called the <i>narrowing</i> 
<i>primitive conversions</i>:
<p><ul><a name="25257"></a>
<li><code>byte</code> to <code>char</code>
<a name="25258"></a>
<li><code>short</code> to <code>byte</code> or <code>char</code>
<a name="25259"></a>
<li><code>char</code> to <code>byte</code> or <code>short</code>
<a name="25260"></a>
<li><code>int</code> to <code>byte</code>, <code>short</code>, or <code>char</code>
<a name="25261"></a>
<li><code>long</code> to <code>byte</code>, <code>short</code>, <code>char</code>, or <code>int</code>
<a name="25262"></a>
<li><code>float</code> to <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, or <code>long</code>
<a name="25263"></a>
<li><code>double</code> to <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, or <code>float</code>
</ul><p><a name="25264"></a>
Narrowing conversions may lose information about the overall magnitude of a numeric value and may also lose precision.<p>
<a name="25265"></a>
A narrowing conversion of a signed integer to an integral type <i>T</i> simply discards all but the <i>n </i>lowest order bits, where <i>n </i>is the number of bits used to represent type <i>T</i>. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value.<p>
<a name="25266"></a>
A narrowing conversion of a character to an integral type <i>T</i> likewise simply discards all but the <i>n </i>lowest order bits, where <i>n </i>is the number of bits used to represent type <i>T</i>. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though characters represent 16-bit unsigned integer values.<p>
<a name="25267"></a>
A narrowing conversion of a floating-point number to an integral type <i>T</i><em></em> takes two steps:<p>
<ul>
<a name="25268"></a>
<li>In the first step, the floating-point number is converted either to a <code>long</code>, if <i>T</i> is <code>long</code>, or to an <code>int</code>, if <i>T</i><em></em> is <code>byte</code>, <code>short</code>, <code>char</code>, or <code>int</code>, as follows:
<ul>
<a name="25272"></a>
<li>If the floating-point number is NaN <a href="4_2_3.htm#9208">(&#167;4.2.3)</a>, the result of the first step of the conversion is an <code>int</code> or <code>long</code> <code>0</code>.
<a name="174285"></a>
<li>Otherwise, if the floating-point number is not an infinity, the floating-point value is rounded to an integer value <i>V</i>, rounding toward zero using IEEE 754 round-toward-zero mode <a href="4_2_3.htm#9208">(&#167;4.2.3)</a>. Then there are two cases:
<ul>
<a name="25277"></a>
<li>If <i>T</i><em></em> is <code>long</code>, and this integer value can be represented as a <code>long</code>, then the result of the first step is the <code>long</code> value <i>V</i>.
<a name="25278"></a>
<li>Otherwise, if this integer value can be represented as an <code>int</code>, then the result of the first step is the <code>int</code> value <i>V</i>.
</ul>
<a name="25279"></a>
<li>Otherwise, one of the following two cases must be true:
<ul>
<a name="25280"></a>
<li>The value must be too small (a negative value of large magnitude or negative infinity), and the result of the first step is the smallest representable value of type <code>int</code> or <code>long</code>.
<a name="25281"></a>
<li>The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type <code>int</code> or <code>long</code>.
</ul>
</ul>
<a name="25282"></a>
<li>In the second step:
<ul>
<a name="25283"></a>
<li>If <i>T</i> is <code>int</code> or <code>long</code>, the result of the conversion is the result of the first step.
<a name="25284"></a>
<li>If <i>T</i> is <code>byte</code>, <code>char</code>, or <code>short</code>, the result of the conversion is the result of a narrowing conversion to type <i>T</i> <a href="5_1_3.htm#175672">(&#167;5.1.3)</a> of the result of the first step.
</ul>
</ul>
<a name="176319"></a>
<p>The example:
<p><pre><a name="176320"></a>
class Test {
<a name="25290"></a>	public static void main(String[] args) {
<a name="25291"></a>		float fmin = Float.NEGATIVE_INFINITY;
<a name="25292"></a>		float fmax = Float.POSITIVE_INFINITY;
<a name="25293"></a>		System.out.println("long: " + (long)fmin +
<a name="25294"></a>								".." + (long)fmax);
<a name="25295"></a>		System.out.println("int: " + (int)fmin +
<a name="25296"></a>								".." + (int)fmax);
<a name="25297"></a>		System.out.println("short: " + (short)fmin +
<a name="25298"></a>								".." + (short)fmax);
<a name="25299"></a>		System.out.println("char: " + (int)(char)fmin +
<a name="25300"></a>								".." + (int)(char)fmax);
<a name="25301"></a>		System.out.println("byte: " + (byte)fmin +
<a name="25302"></a>								".." + (byte)fmax);
<a name="25303"></a>	}
<a name="25304"></a>}
</pre><p><a name="25305"></a>
produces the output:
<p><pre><a name="25306"></a>
long: -9223372036854775808..9223372036854775807
<a name="25307"></a>int: -2147483648..2147483647
<a name="25308"></a>short: 0..-1
<a name="25309"></a>char: 0..65535
<a name="25310"></a>byte: 0..-1
</pre><p><a name="25311"></a>
The results for <code>char</code>, <code>int</code>, and <code>long</code> are unsurprising, producing the minimum and maximum representable values of the type.<p>
<a name="25312"></a>
The results for <code>byte</code> and <code>short</code> lose information about the sign and magnitude of the numeric values and also lose precision. The results can be understood by examining the low order bits of the minimum and maximum <code>int.</code> The minimum <code>int</code> is, in hexadecimal, <code>0x80000000</code>, and the maximum <code>int</code> is <code>0x7fffffff</code>. This explains the <code>short</code> results, which are the low 16 bits of these values, namely, <code>0x0000</code> and <code>0xffff</code>; it explains the <code>char</code> results, which also are the low 16 bits of these values, namely, <code>'\u0000'</code> and <code>'\uffff'</code>; and it explains the <code>byte</code> results, which are the low 8 bits of these values, namely, <code>0x00</code> and <code>0xff</code>.<p>
<a name="25315"></a>
A narrowing conversion from <code>double</code> to <code>float</code> behaves in accordance with IEEE 754. The result is correctly rounded using IEEE 754 round-to-nearest mode. A value too small to be represented as a <code>float</code> is converted to positive or negative zero; a value too large to be represented as a <code>float</code> is converted to a (positive or negative) infinity. A <code>double</code> NaN is always converted to a <code>float</code> NaN.<p>
<a name="25316"></a>
Despite the fact that overflow, underflow, or other loss of information may occur, narrowing conversions among primitive types never result in a run-time exception <a href="chap11.htm">(&#167;11)</a>.<p>
<a name="25321"></a>
Here is a small test program that demonstrates a number of narrowing conversions that lose information:<p>
<pre><a name="25322"></a>
class Test {
<a name="25323"></a>
	public static void main(String[] args) {
<a name="25324"></a>
		// A narrowing of int to short loses high bits:
<a name="25325"></a>		System.out.println("(short)0x12345678==0x" +
<a name="25326"></a>					Integer.toHexString((short)0x12345678));
<br><a name="25328"></a>
		// A int value not fitting in byte changes sign and magnitude:
<a name="25329"></a>		System.out.println("(byte)255==" + (byte)255);
<br><a name="25331"></a>
		// A float value too big to fit gives largest int value:
<a name="25332"></a>		System.out.println("(int)1e20f==" + (int)1e20f);
<br><a name="25334"></a>
		// A NaN converted to int yields zero:
<a name="25335"></a>		System.out.println("(int)NaN==" + (int)Float.NaN);
<br><a name="25337"></a>
		// A double value too large for float yields infinity:
<a name="25338"></a>		System.out.println("(float)-1e100==" + (float)-1e100);
<br><a name="25340"></a>
		// A double value too small for float underflows to zero:
<a name="25341"></a>		System.out.println("(float)1e-50==" + (float)1e-50);
<br><a name="25342"></a>	}
<br><a name="25346"></a>}
</pre><p><a name="25347"></a>
This test program produces the following output:
<p><pre><a name="25348"></a>
(short)0x12345678==0x5678
<a name="25349"></a>(byte)255==-1
<a name="25350"></a>(int)1e20f==2147483647
<a name="25351"></a>(int)NaN==0
<a name="25352"></a>(float)-1e100==-Infinity
<a name="25353"></a>(float)1e-50==0.0
</pre><p>

</body></html>
