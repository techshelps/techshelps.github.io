<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>17.14 Wait Sets and Notification</title>
<META NAME=MS-HAID CONTENT="17_14">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>17.14	 Wait Sets and Notification</h2>
<a name="28471"></a>
<p>
<a name="29596"></a>
Every object, in addition to having an associated lock, has an associated <i>wait set</i>, 
which is a set of threads. When an object is first created, its wait set is empty.
<p><a name="29597"></a>
Wait sets are used by the methods <code>wait</code> (<a href="20_1.htm#33394">&#167;20.1.6</a>, <a href="20_1.htm#14926">&#167;20.1.7</a>, <a href="20_1.htm#32520">&#167;20.1.8</a>), <code>notify</code> <a href="20_1.htm#13789">(&#167;20.1.9)</a>, and <code>notifyAll</code> <a href="20_1.htm#13790">(&#167;20.1.10)</a> of class <code>Object</code>. These methods also interact with the scheduling mechanism for threads <a href="20_20.htm#2658">(&#167;20.20)</a>.<p>
<a name="29731"></a>
The method <code>wait</code> should be called for an object only when the current thread (call it <i>T</i>) has already locked the object's lock. Suppose that thread <i>T</i> has in fact performed <i>N lock</i> actions that have not been matched by <i>unlock</i> actions. The <code>wait</code> method then adds the current thread to the wait set for the object, disables the current thread for thread scheduling purposes, and performs <i>N</i> <i>unlock</i> actions to relinquish the lock. The thread <i>T</i> then lies dormant until one of three things happens:<p>
<ul><a name="29732"></a>
<li>Some other thread invokes the <code>notify</code> method for that object and thread <i>T</i> happens to be the one arbitrarily chosen as the one to notify.
<a name="29721"></a>
<li>Some other thread invokes the <code>notifyAll</code> method for that object.
<a name="29664"></a>
<li>If the call by thread <i>T</i> to the wait method specified a timeout interval, the specified amount of real time has elapsed.
</ul><p><a name="29669"></a>
The thread <i>T</i> is then removed from the wait set and re-enabled for thread scheduling. It then locks the object again (which may involve competing in the usual 
manner with other threads); once it has gained control of the lock, it performs 
<img src="17anc3.gif"> additional <i>lock</i> actions and then returns from the invocation of the <code>wait</code> 
method. Thus, on return from the <code>wait</code> method, the state of the object's lock is 
exactly as it was when the <code>wait</code> method was invoked.
<p><a name="29772"></a>
The <code>notify</code> method should be called for an object only when the current thread has already locked the object's lock. If the wait set for the object is not empty, then some arbitrarily chosen thread is removed from the wait set and re-enabled for thread scheduling. (Of course, that thread will not be able to proceed until the current thread relinquishes the object's lock.)<p>
<a name="29776"></a>
The <code>notifyAll</code> method should be called for an object only when the current thread has already locked the object's lock. Every thread in the wait set for the object is removed from the wait set and re-enabled for thread scheduling. (Of course, those threads will not be able to proceed until the current thread relinquishes the object's lock.)<p>
<a name="43966"></a>
<p><i>These pearls of thought in Persian gulfs were bred,<br>
Each softly lucent as a rounded moon;<br>
The diver Omar plucked them from their bed,<br>
Fitzgerald strung them on an English thread.<br>
</i>&#151;James Russell Lowell, in a copy of Omar Khayyam</p>
<p>

<hr>
<p>
<br>
</font>
</body></html>
