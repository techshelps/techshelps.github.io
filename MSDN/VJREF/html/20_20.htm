<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>20.20 The Class java.lang.Thread</title>
<META NAME=MS-HAID CONTENT="20_20">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h1>20.20	 The Class java.lang.Thread</h1>
<a name="2658"></a>
<p>
<a name="7454"></a>
A thread is a single sequential flow of control. Thread objects allow multithreaded 
Java programming; a single Java Virtual Machine can execute many threads in an 
interleaved or concurrent manner.
<p><a name="25915"></a>
In the method descriptions that follow, it is very important to distinguish among "the current thread" (the thread executing the method), "this <code>Thread</code>" (the object for which the method was invoked), and "this thread" (the thread that is represented by the <code>Thread</code> object for which the method was invoked).<p>
<pre><a name="14147"></a>
<a name="7452"></a>public class <code><b>Thread</b></code> implements Runnable {
<a name="2714"></a>	public final static int <code><b>MIN_PRIORITY</b></code> = 1;
<a name="2715"></a>	public final static int <code><b>MAX_PRIORITY</b></code> = 10;
<a name="2716"></a>	public final static int <code><b>NORM_PRIORITY</b></code> = 5;
<a name="2717"></a>	public <code><b>Thread</b></code>();
<a name="7758"></a>	public <code><b>Thread</b></code>(String name);
<a name="2718"></a>	public <code><b>Thread</b></code>(Runnable target);
<a name="2720"></a>	public <code><b>Thread</b></code>(Runnable target, String name);
<a name="7764"></a>	public <code><b>Thread</b></code>(ThreadGroup group, String name)
<a name="7869"></a>		throws SecurityException, <code>IllegalThreadStateException</code>;
<a name="7871"></a>	public <code><b>Thread</b></code>(ThreadGroup group, Runnable target)
<a name="2721"></a>		throws SecurityException, <code>IllegalThreadStateException</code>;
<a name="7876"></a>	public <code><b>Thread</b></code>(ThreadGroup group, Runnable target,
<a name="21736"></a>			String name)
<a name="27379"></a>		throws SecurityException, <code>IllegalThreadStateException</code>;
<a name="2724"></a>	public String <code><b>toString</b></code>();
<a name="8067"></a>	public void <code><b>checkAccess</b></code>();
<a name="2725"></a>	public void <code><b>run</b></code>();
<a name="2726"></a>	public void <code><b>start</b></code>()
<a name="8116"></a>		throws IllegalThreadStateException;
<a name="2727"></a>	public final void <code><b>stop</b></code>()
<a name="8377"></a>		throws SecurityException;
<a name="8379"></a>	public final void <code><b>stop</b></code>(Throwable o)
<a name="2728"></a>		throws SecurityException;
<a name="8384"></a>	public final void <code><b>suspend</b></code>()
<a name="8080"></a>		throws SecurityException;
<a name="8389"></a>	public final void <code><b>resume</b></code>()
<a name="8081"></a>		throws SecurityException;
<a name="8108"></a>	public void <code><b>destroy</b></code>();
<a name="8087"></a>	public final boolean <code><b>isAlive</b></code>();
<a name="2729"></a>	public void <code><b>interrupt</b></code>();
<a name="2730"></a>	public static boolean <code><b>interrupted</b></code>();
<a name="2731"></a>	public boolean <code><b>isInterrupted</b></code>();
<a name="8059"></a>	public final String <code><b>getName</b></code>();
<a name="8368"></a>	public final void <code><b>setName</b></code>(String name)
<a name="8060"></a>		throws SecurityException;
<a name="8061"></a>	public final ThreadGroup <code><b>getThreadGroup</b></code>();
<a name="8034"></a>	public final int <code><b>getPriority</b></code>();
<a name="2736"></a>	public final void <code><b>setPriority</b></code>(int newPriority)
<a name="8366"></a>		throws SecurityException, IllegalArgumentException;
<a name="8052"></a>	public final boolean <code><b>isDaemon</b></code>();
<a name="8373"></a>	public final void <code><b>setDaemon</b></code>(boolean on)
<a name="8053"></a>		throws SecurityException;
<a name="2743"></a>	public int <code><b>countStackFrames</b></code>();
<a name="2779"></a>	public final void <code><b>join</b></code>()
<a name="2780"></a>		throws InterruptedException;
<a name="2744"></a>	public final void <code><b>join</b></code>(long millis)
<a name="2745"></a>		throws InterruptedException;
<a name="2746"></a>	public final void <code><b>join</b></code>(long millis, int nanos)
<a name="2747"></a>		throws InterruptedException;
<a name="29186"></a>	public void <code><b>interrupt</b></code>();
<a name="29187"></a>	public boolean <code><b>isInterrupted</b></code>();
<a name="29188"></a>	public static boolean <code><b>interrupted</b></code>();
<a name="26549"></a>	public static Thread <code><b>currentThread</b></code>();
<a name="8073"></a>	public static int <code><b>activeCount</b></code>();															// deprecated
<a name="8074"></a>	public static int <code><b>enumerate</b></code>(Thread tarray[]);															// deprecated
<a name="2750"></a>	public static void <code><b>dumpStack</b></code>();
<a name="2755"></a>	public static void <code><b>yield</b></code>();
<a name="2756"></a>	public static void <code><b>sleep</b></code>(long millis)<br>
		throws InterruptedException;
<a name="2757"></a>	public static void <code><b>sleep</b></code>(long millis, int nanos)<br>
		throws InterruptedException;
<a name="7681"></a>}
</pre><p><a name="7636"></a>
When a new <code>Thread</code> object is created, the thread it represents is not yet active. It is activated when some other thread calls the <code>start</code> method <a href="20_20.htm#8093">(&#167;20.20.14)</a> of the <code>Thread</code> object. This causes the thread represented by the <code>Thread</code> object to invoke the <code>run</code> method <a href="20_20.htm#2686">(&#167;20.20.13)</a> of the <code>Thread</code> object. The newly activated thread then remains alive until it stops because one of five things occurs:<p>
<ul><a name="26078"></a>
<li>The initial invocation of the <code>run</code> method by the newly activated thread completes normally through a normal return from the <code>run</code> method.
<a name="26082"></a>
<li>The initial invocation of the <code>run</code> method by the newly activated thread completes abruptly because an exception was thrown.
<a name="26061"></a>
<li>The thread invokes the <code>stop</code> method <a href="20_20.htm#8095">(&#167;20.20.15)</a> of the <code>Thread</code> object (and the security manager <a href="20_17.htm#14109">(&#167;20.17.11)</a> approves execution of the <code>stop</code> operation).
<a name="25977"></a>
<li>Some other thread invokes the <code>stop</code> method of the <code>Thread</code> object (and the security &#32;manager <a href="20_17.htm#14109">(&#167;20.17.11)</a> approves execution of the <code>stop</code> operation).
<a name="25971"></a>
<li>Some thread invokes the <code>exit</code> method <a href="20_16.htm#34351">(&#167;20.16.2)</a> of class <code>Runtime</code> (and the security manager <a href="20_17.htm#14111">(&#167;20.17.13)</a> approves execution of the <code>exit</code> operation); this stops every thread being run by the Java Virtual Machine that is running the thread that invokes the <code>exit</code> method.
</ul><p><a name="25931"></a>
As a thread dies, the <code>notifyAll</code> method <a href="20_1.htm#13790">(&#167;20.1.10)</a> is invoked for the <code>Thread</code> object that represents it; this fact is important for the proper operation of the <code>join</code> methods (<a href="20_20.htm#2773">&#167;20.20.28</a>, <a href="20_20.htm#14183">&#167;20.20.29</a>, <a href="20_20.htm#14185">&#167;20.20.30</a>). A thread is also removed from its thread group as it dies. Once a thread has been stopped, it is no longer alive and it cannot be restarted.<p>
<a name="26148"></a>
A thread that is alive can be <i>suspended</i> and <i>resumed</i>. A suspended thread is considered to be alive, but it performs no work, makes no progress, executes no virtual machine instructions. Resumption restores a thread to the state of active execution. A thread is suspended when it or another thread calls the <code>suspend</code> method <a href="20_20.htm#8097">(&#167;20.20.17)</a> of the <code>Thread</code> object that represents it (and the security manager <a href="20_17.htm#14109">(&#167;20.17.11)</a> approves execution of the <code>suspend</code> operation). A thread is resumed when another thread calls the <code>resume</code> method <a href="20_20.htm#8098">(&#167;20.20.18)</a> of the <code>Thread</code> object that represents it (and the security manager <a href="20_17.htm#14109">(&#167;20.17.11)</a> approves execution of the <code>resume</code> operation).<p>
<a name="26144"></a>
Every thread has a <i>priority</i>. When there is competition for processing resources, threads with higher priority are generally executed in preference to threads with lower priority. Such preference is not, however, a guarantee that the highest priority thread will always be running, and thread priorities cannot be used to implement mutual exclusion. When code running in some thread creates a new <code>Thread</code> object, the newly created thread has its priority initially set equal to the priority of the creating thread. But the priority of a thread <i>T</i> may be changed at any time if some thread invokes the <code>setPriority</code> method of the <code>Thread</code> object that represents <i>T</i> (and the security manager <a href="20_17.htm#14109">(&#167;20.17.11)</a> approves execution of the <code>setPriority</code> operation).<p>
<a name="26187"></a>
Each thread may or may not be marked as a <i>daemon</i>. When code running in some thread creates a new <code>Thread</code> object, the newly created thread is a daemon thread if and only if the creating thread is a daemon. But the daemonhood of a thread <i>T</i> may be changed before it is activated if some other thread invokes the <code>setDaemon</code> method of the <code>Thread</code> object that represents <i>T</i> (and the security manager <a href="20_17.htm#14109">(&#167;20.17.11)</a> approves execution of the <code>setDaemon</code> operation).<p>
<a name="7637"></a>
When a Java Virtual Machine starts up, there is usually a single non-daemon thread, which typically begins by invoking the method <code>main</code> of some designated class. The Java Virtual Machine continues to execute threads according to the thread execution model until all threads that are not daemon threads have stopped.<p>
<a name="7649"></a>
There are two ways to create a new thread of execution. One is to declare some class to be a subclass of <code>Thread</code>; this subclass should override the <code>run</code> method of class <code>Thread</code>. An instance of the subclass can then be created and started. For example, consider code for a thread whose job is to compute primes larger than a stated value:<p>
<pre><a name="7650"></a>
class PrimeThread extends Thread {
<br><a name="7651"></a>	long minPrime;
<br><a name="7652"></a>	PrimeThread(long minPrime) {
<a name="7653"></a>		this.minPrime = minPrime;
<a name="7654"></a>	}
<br><a name="7655"></a>	public void run() {
<a name="7656"></a> 		// compute primes larger than minPrime
<a name="7657"></a>		...
<a name="7658"></a>	}
<br><a name="7659"></a>}
</pre><p><a name="7660"></a>
The following code would then create a thread and start it running:<p>
<pre><a name="7661"></a>
PrimeThread p = new PrimeThread(143);
<a name="7662"></a>p.start();
</pre><p><a name="7663"></a>
The other way to create a thread is to is to declare some class to implement the <code>Runnable</code> interface, which also requires that the class implement the <code>run</code> method. An instance of the class can then be created, used to create a <code>Thread</code>, and started. The same example in this other style looks like this:<p>
<pre><a name="7664"></a>
class PrimeRun implements Runnable {
<br><a name="7665"></a>	long minPrime;
<br><a name="7666"></a>	PrimeRun(long minPrime) {
<a name="7667"></a>		this.minPrime = minPrime;
<a name="7668"></a>	}
<br><a name="7669"></a>
	public void run() {
<a name="7670"></a> 		// compute primes larger than minPrime
<a name="7671"></a>		...
<a name="7672"></a>	}
<br><a name="7673"></a>}
</pre><p><a name="34753"></a>
The following code would then create a thread and start it running:<p>
<pre><a name="7675"></a>
PrimeRun p = new PrimeRun(143);
<a name="7676"></a>new Thread(p).start();
</pre><p><a name="7708"></a>
Every thread has a name, which is a <code>String</code>, for identification purposes. More than one thread may have the same name. If a name is not specified when a thread is created, a new name is generated for it.<p>
<a name="26328"></a>
Every thread that has not yet been stopped belongs to a thread group <a href="20_21.htm#14469">(&#167;20.21)</a>. A thread can always create a new thread in its own thread group. To create a thread in some other thread group requires the approval of the <code>checkAccess</code> method <a href="20_21.htm#27041">(&#167;20.21.4)</a> of that thread group, which forwards the decision to the security manager <a href="20_17.htm#14109">(&#167;20.17.11)</a>.<p>
<a name="14148"></a>
<p><strong>20.20.1	</strong> <code>public final static int MIN_PRIORITY = 1;</code>
<p>
<a name="7683"></a>
The constant value of this field is <code>1</code>, the smallest allowed priority for a thread.
<p><a name="2662"></a>
<p><strong>20.20.2	</strong> <code>public final static int MAX_PRIORITY = 10;</code>
<p>
<a name="7691"></a>
The constant value of this field is <code>10</code>, the largest allowed priority value for a 
thread.
<p><a name="14149"></a>
<p><strong>20.20.3	</strong> <code>public final static int NORM_PRIORITY = 5;</code>
<p>
<a name="7695"></a>
The constant value of this field is <code>5</code>, the normal priority for a thread that is not a 
daemon.
<p><a name="14157"></a>
<p><strong>20.20.4	</strong> <code>public Thread()</code>
<p>
<a name="7705"></a>
This constructor initializes a newly created <code>Thread</code> object so that it has no separate run object, has a newly generated name, and belongs to the same thread group 
as the thread that is creating the new thread.
<p><a name="7717"></a>
This constructor has exactly the same effect as the explicit constructor call <code>this(null, null, </code><i>gname</i><code>)</code> <a href="20_20.htm#14163">(&#167;20.20.10)</a>, where <i>gname</i> is a newly generated name. Automatically generated names are of the form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.<p>
<a name="7752"></a>
<p><strong>20.20.5	</strong> <code>public Thread(String name)</code>
<p>
<a name="7768"></a>
This constructor initializes a newly created <code>Thread</code> object so that it has no separate run object, has the specified <code>name</code> as its name, and belongs to the same thread 
group as the thread that is creating the new thread.
<p><a name="7772"></a>
This constructor has exactly the same effect as the explicit constructor call <code>this(null,</code> <code>null,</code> <code>name)</code> <a href="20_20.htm#14163">(&#167;20.20.10)</a>.<p>
<a name="14158"></a>
<p><strong>20.20.6	</strong> <code>public Thread(Runnable runObject)</code>
<p>
<a name="7731"></a>
This constructor initializes a newly created <code>Thread</code> object so that it has the given 
<code>runObject</code> as its separate run object, has a newly generated name, and belongs to 
the same thread group as the thread that is creating the new thread.
<p><a name="7735"></a>
This constructor has exactly the same effect as the explicit constructor call <code>this(null,</code> <code>runObject,</code> <i>gname</i><code>)</code> <a href="20_20.htm#14163">(&#167;20.20.10)</a> where <i>gname</i> is a newly generated name. Automatically generated names are of the form <code>"Thread-"+</code><i>n</i> where <i>n</i> is an integer.<p>
<a name="2698"></a>
<p><strong>20.20.7	</strong> <code>public Thread(Runnable runObject, String name)</code>
<p>
<a name="7781"></a>
This constructor initializes a newly created <code>Thread</code> object so that it has the given 
<code>runObject</code> as its separate run object, has the specified <code>name</code> as its name, and 
belongs to the same thread group as the thread that is creating the new thread.
<p><a name="7785"></a>
This constructor has exactly the same effect as the explicit constructor call <code>this(null,</code> <code>runObject,</code> <code>name)</code> <a href="20_20.htm#14163">(&#167;20.20.10)</a>.<p>
<a name="7746"></a>
<p><strong>20.20.8	</strong> <code>public Thread(ThreadGroup group, String name)<br>throws SecurityException, IllegalThreadStateException</code>
<p>
<a name="7887"></a>
First, if group is not <code>null</code>, the <code>checkAccess</code> method <a href="20_21.htm#27041">(&#167;20.21.4)</a> of that thread 
group is called with no arguments.
<p><a name="7796"></a>
This constructor initializes a newly created <code>Thread</code> object so that it has no separate run object, has the specified <code>name</code> as its name, and belongs to the thread group referred to by <code>group</code> (but if <code>group</code> is <code>null</code>, then the new thread will belong to the same thread group as the thread that is creating the new thread).<p>
<a name="27327"></a>
If <code>group</code> is a <code>ThreadGroup</code> that has been destroyed by method <code>destroy</code> <a href="20_21.htm#2888">(&#167;20.21.11)</a>, then an <code>IllegalThreadStateException</code> is thrown.<p>
<a name="27331"></a>
This constructor has exactly the same effect as the explicit constructor call <code>Thread(group,</code> <code>null,</code> <code>name)</code> <a href="20_20.htm#14163">(&#167;20.20.10)</a>.<p>
<a name="14159"></a>
<p><strong>20.20.9	</strong> <code>public Thread(ThreadGroup group, Runnable runObject)<br>throws SecurityException, IllegalThreadStateException</code>
<p>
<a name="7904"></a>
First, if group is not <code>null</code>, the <code>checkAccess</code> method <a href="20_21.htm#27041">(&#167;20.21.4)</a> of that thread 
group is called with no arguments.
<p><a name="7812"></a>
This constructor initializes a newly created <code>Thread</code> object so that it has the given <code>runObject</code> as its separate run object, has a newly generated name, and belongs to the thread group referred to by <code>group</code> (but if <code>group</code> is <code>null</code>, then the new thread will belong to the same thread group as the thread that is creating the new thread).<p>
<a name="27338"></a>
If <code>group</code> is a <code>ThreadGroup</code> that has been destroyed by method <code>destroy</code> <a href="20_21.htm#2888">(&#167;20.21.11)</a>, then an <code>IllegalThreadStateException</code> is thrown.<p>
<a name="7816"></a>
This constructor has exactly the same effect as the explicit constructor call <code>this(group,</code> <code>runObject,</code> <i>gname</i><code>)</code> <a href="20_20.htm#14163">(&#167;20.20.10)</a> where <i>gname</i> is a newly generated name. Automatically generated names are of the form <code>"Thread-"+</code><i>n</i> where <i>n</i> is an integer.<p>
<a name="14163"></a>
<p><strong>20.20.10	</strong> <code>public Thread(ThreadGroup group, Runnable target,<br> &#32; &#32; &#32;String name)<br>throws SecurityException, IllegalThreadStateException</code>
<p>
<a name="7911"></a>
First, if group is not <code>null</code>, the <code>checkAccess</code> method <a href="20_21.htm#27041">(&#167;20.21.4)</a> of that thread 
group is called with no arguments; this may result in a <code>SecurityException</code> 
being thrown.
<p><a name="7848"></a>
This constructor initializes a newly created <code>Thread</code> object so that it has the given <code>runObject</code> as its separate run object, has the specified <code>name</code> as its name, and belongs to the thread group referred to by <code>group</code> (but if <code>group</code> is <code>null</code>, then the new thread will belong to the same thread group as the thread that is creating the new thread).<p>
<a name="27345"></a>
If <code>group</code> is a <code>ThreadGroup</code> that has been destroyed by method <code>destroy</code> <a href="20_21.htm#2888">(&#167;20.21.11)</a>, then an <code>IllegalThreadStateException</code> is thrown.<p>
<a name="7914"></a>
The priority of the newly created thread is set equal to the priority of the creating thread-that is, the currently running thread. The method <code>setPriority</code> <a href="20_20.htm#14175">(&#167;20.20.23)</a> may be used to change the priority to a new value.<p>
<a name="7919"></a>
The newly created thread is initially marked as being a daemon thread if and only if the thread creating it is a daemon thread. The method <code>setDaemon </code><a href="20_20.htm#2861">(&#167;20.20.25)</a> may be used to change whether or not a thread is a daemon.<p>
<a name="2680"></a>
<p><strong>20.20.11	</strong> <code>public String toString()</code>
<p>
<a name="7934"></a>
The returned value is a concatenation of the following seven strings:
<p><ul><a name="7935"></a>
<li><code>"Thread["</code>
<a name="7936"></a>
<li>The current name of the thread <a href="20_20.htm#2868">(&#167;20.20.19)</a>
<a name="7943"></a>
<li><code>","</code>
<a name="7947"></a>
<li>The current priority of the thread <a href="20_20.htm#2819">(&#167;20.20.22)</a>, as a decimal numeral
<a name="7963"></a>
<li><code>","</code>
<a name="26807"></a>
<li>The name <a href="20_21.htm#2882">(&#167;20.21.5)</a> of the thread group <a href="20_20.htm#2870">(&#167;20.20.21)</a> that contains this thread
<a name="7989"></a>
<li><code>"]"</code>
</ul><p><a name="26770"></a>
All literal characters mentioned above are from the ACSII subset of Unicode.
<p><a name="26754"></a>
Overrides the <code>toString</code> method of <code>Object</code> <a href="20_1.htm#14865">(&#167;20.1.3)</a>.<p>
<a name="8265"></a>
<p><strong>20.20.12	</strong> <code>public void checkAccess() throws SecurityException</code>
<p>
<a name="8272"></a>
If there is a security manager, its <code>checkAccess</code> method <a href="20_17.htm#14109">(&#167;20.17.11)</a> is called with 
this <code>Thread</code> object as its argument. This may result in a <code>SecurityException</code> 
being thrown in the current thread,.
<p><a name="8288"></a>
This method is called by methods <code>stop</code> of no arguments <a href="20_20.htm#8095">(&#167;20.20.15)</a>, <code>stop</code> of one argument <a href="20_20.htm#8096">(&#167;20.20.16)</a>, <code>suspend</code> <a href="20_20.htm#8097">(&#167;20.20.17)</a>, <code>resume</code> <a href="20_20.htm#8098">(&#167;20.20.18)</a>, <code>setName</code> <a href="20_20.htm#2869">(&#167;20.20.20)</a>, <code>setPriority</code> <a href="20_20.htm#14175">(&#167;20.20.23)</a>, and <code>setDaemon</code> <a href="20_20.htm#2861">(&#167;20.20.25)</a>.<p>
<a name="2686"></a>
<p><strong>20.20.13	</strong> <code>public void run()</code>
<p>
<a name="8016"></a>
The general contract of this method is that it should perform the intended action of 
the thread.
<p><a name="8017"></a>
The <code>run</code> method of class <code>Thread</code> simply calls the <code>run</code> method of the separate run object, if there is one; otherwise, it does nothing.<p>
<a name="8093"></a>
<p><strong>20.20.14	</strong> <code>public void start()<br>throws IllegalThreadStateException</code>
<p>
<a name="8111"></a>
Invoking this method causes this thread to begin execution; this thread calls the 
<code>run</code> method of this <code>Thread</code> object. The result is that two threads are running concurrently: the current thread (which returns from the call to the <code>start</code> method) 
and the thread represented by this <code>Thread</code> object (which executes its <code>run</code> method).
<p><a name="8095"></a>
<p><strong>20.20.15	</strong> <code>public final void stop()<br>throws SecurityException</code>
<p>
<a name="34904"></a>
<p>
<a name="8132"></a>
First, the <code>checkAccess</code> method <a href="20_20.htm#8265">(&#167;20.20.12)</a> of this <code>Thread</code> object is called with 
no arguments. This may result in throwing a <code>SecurityException</code> (in the current 
thread).
<p><a name="8155"></a>
This thread is forced to complete abnormally whatever it was doing and to throw a <code>ThreadDeath</code> object as an exception. For this purpose, this thread is resumed if it had been suspended, and is awakened if it had been asleep.<p>
<a name="8228"></a>
It is permitted to stop a thread that has not yet been started. If the thread is eventually started, it will immediately terminate.<p>
<a name="8162"></a>
User code should not normally try to catch <code>ThreadDeath</code> unless some extraordinary cleanup operation is necessary (note that the process of throwing a <code>ThreadDeath</code> exception <i>will</i> cause <code>finally</code> clauses of <code>try</code> statements to be executed before the thread officially dies). If a <code>catch</code> clause does catch a <code>ThreadDeath</code> object, it is important to rethrow the object so that the thread will actually die. The top-level error handler that reacts to otherwise uncaught exceptions will not print a message or otherwise signal or notify the user if the uncaught exception is an instance of <code>ThreadDeath</code>.<p>
<a name="8096"></a>
<p><strong>20.20.16	</strong> <code>public final void stop(Throwable thr)<br>throws SecurityException, NullPointerException</code>
<p>
<a name="8139"></a>
First, the <code>checkAccess</code> method <a href="20_20.htm#8265">(&#167;20.20.12)</a> of this <code>Thread</code> object is called with 
no arguments. This may result in throwing a <code>SecurityException</code> (in the current 
thread).
<p><a name="8151"></a>
If the argument <code>thr</code> is null, then a <code>NullPointerException</code> is thrown (in the current thread).<p>
<a name="26383"></a>
This thread is forced to complete abnormally whatever it was doing and to throw the <code>Throwable</code> object <code>thr</code> as an exception. For this purpose, this thread is resumed if it had been suspended, and is awakened if it had been asleep. This is an unusual action to take; normally, the <code>stop</code> method that takes no arguments <a href="20_20.htm#8095">(&#167;20.20.15)</a> should be used.<p>
<a name="8233"></a>
It is permitted to stop a thread that has not yet been started. If the thread is eventually started, it will immediately terminate.<p>
<a name="8097"></a>
<p><strong>20.20.17	</strong> <code>public final void suspend()<br>throws SecurityException</code>
<p>
<a name="8198"></a>
First, the <code>checkAccess</code> method <a href="20_20.htm#8265">(&#167;20.20.12)</a> of this <code>Thread</code> object is called with 
no arguments. This may result in throwing a <code>SecurityException</code> (in the current 
thread).
<p><a name="8238"></a>
If this thread is alive <a href="20_20.htm#8259">(&#167;20.20.26)</a>, it is suspended and makes no further progress unless and until it is resumed. It is permitted to suspend a thread that is already in a suspended state; it remains suspended. Suspensions are not tallied; even if a thread is suspended more than once, only one call to <code>resume</code> is required to resume it.<p>
<a name="8098"></a>
<p><strong>20.20.18	</strong> <code>public final void resume()<br>throws SecurityException</code>
<p>
<a name="8205"></a>
First, the <code>checkAccess</code> method <a href="20_20.htm#8265">(&#167;20.20.12)</a> of this <code>Thread</code> object is called with 
no arguments. This may result in throwing a <code>SecurityException</code> (in the current 
thread).
<p><a name="8247"></a>
If this thread is alive <a href="20_20.htm#8259">(&#167;20.20.26)</a> but suspended, it is resumed and is permitted to make progress in its execution. It is permitted to resume a thread that has never been suspended or has already been resumed; it continues to make progress in its execution. Resumptions are not tallied; even if a thread is resumed more than once, only one call to <code>suspend</code> is required to suspend it.<p>
<a name="2868"></a>
<p><strong>20.20.19	</strong> <code>public final String getName()</code>
<p>
<a name="8018"></a>
The current name of this <code>Thread</code> object is returned as a <code>String</code>.
<p><a name="2869"></a>
<p><strong>20.20.20	</strong> <code>public final void setName(String name)<br>throws SecurityException</code>
<p>
<a name="8023"></a>
First, the <code>checkAccess</code> method <a href="20_20.htm#8265">(&#167;20.20.12)</a> of this <code>Thread</code> object is called with 
no arguments. This may result in throwing a <code>SecurityException</code> (in the current 
thread).
<p><a name="8338"></a>
The name of this <code>Thread</code> object is changed to be equal to the argument <code>name</code>.<p>
<a name="2870"></a>
<p><strong>20.20.21	</strong> <code>public final ThreadGroup getThreadGroup()</code>
<p>
<a name="26407"></a>
If this thread is alive, this method returns a reference to the <code>ThreadGroup</code> object 
that represents the thread group to which this thread belongs. If this thread has 
died (has been stopped), this method returns <code>null</code>.
<p><a name="2819"></a>
<p><strong>20.20.22	</strong> <code>public final int getPriority()</code>
<p>
<a name="8340"></a>
The current priority of this <code>Thread</code> object is returned.
<p><a name="14175"></a>
<p><strong>20.20.23	</strong> <code>public final void setPriority(int newPriority)<br>throws SecurityException, IllegalArgumentException</code>
<p>
<a name="8352"></a>
First, the <code>checkAccess</code> method <a href="20_20.htm#8265">(&#167;20.20.12)</a> of this <code>Thread</code> object is called with 
no arguments. This may result in throwing a <code>SecurityException</code> (in the current 
thread).
<p><a name="8393"></a>
If the <code>newPriority</code> argument is less than <code>MIN_PRIORITY</code> <a href="20_20.htm#14148">(&#167;20.20.1)</a> or greater than <code>MAX_PRIORITY</code> <a href="20_20.htm#2662">(&#167;20.20.2)</a>, then an <code>IllegalArgumentException</code> is thrown.<p>
<a name="8398"></a>
Otherwise, the priority of this <code>Thread</code> object is set to the smaller of the specified <code>newPriority</code> and the maximum permitted priority <a href="20_21.htm#27398">(&#167;20.21.12)</a> of the thread's thread group <a href="20_20.htm#2870">(&#167;20.20.21)</a>.<p>
<a name="2860"></a>
<p><strong>20.20.24	</strong> <code>public final boolean isDaemon()</code>
<p>
<a name="8429"></a>
The result is <code>true</code> if and only if this thread is marked as a daemon thread.
<p><a name="2861"></a>
<p><strong>20.20.25	</strong> <code>public final void setDaemon(boolean on)<br>throws SecurityException, IllegalThreadStateException</code>
<p>
<a name="8359"></a>
First, the <code>checkAccess</code> method <a href="20_20.htm#8265">(&#167;20.20.12)</a> of this <code>Thread</code> object is called with 
no arguments. This may result in throwing a <code>SecurityException</code> (in the current 
thread).
<p><a name="8436"></a>
If this thread is alive, an <code>IllegalThreadStateException</code> is thrown. Otherwise, this thread is marked as being a daemon thread if the argument is <code>true</code>, and as not being a daemon thread if the argument is <code>false</code>.<p>
<a name="8259"></a>
<p><strong>20.20.26	</strong> <code>public final boolean isAlive()</code>
<p>
<a name="8441"></a>
The result is <code>true</code> if and only if this thread is alive (it has been started and has not 
yet died).
<p><a name="14182"></a>
<p><strong>20.20.27	</strong> <code>public int countStackFrames()</code>
<p>
<a name="26530"></a>
This method returns the number of Java Virtual Machine stack frames currently 
active for this thread.
<p><a name="2773"></a>
<p><strong>20.20.28	</strong> <code>public final void join() 	throws InterruptedException</code>
<p>
<a name="26418"></a>
This method causes the current thread to wait (using the <code>wait</code> method <a href="20_1.htm#33394">(&#167;20.1.6)</a> of 
class <code>Object</code>) until this thread is no longer alive.
<p><a name="29128"></a>
If the current thread is interrupted <a href="20_20.htm#29179">(&#167;20.20.31)</a> by another thread while it is waiting, then the wait is ended and an <code>InterruptedException</code> is thrown.<p>
<a name="14183"></a>
<p><strong>20.20.29	</strong> <code>public final void join(long millis)<br>	throws InterruptedException</code>
<p>
<a name="26423"></a>
This method causes the current thread to wait (using the <code>wait</code> method <a href="20_1.htm#14926">(&#167;20.1.7)</a> of 
class <code>Object</code>) until either this thread is no longer alive or a certain amount of real 
time has elapsed, more or less.
<p><a name="26603"></a>
The amount of real time, measured in milliseconds, is given by <code>millis</code>. If <code>millis</code> is zero, however, then real time is not taken into consideration and this method simply waits until this thread is no longer alive.<p>
<a name="29141"></a>
If the current thread is interrupted <a href="20_20.htm#29179">(&#167;20.20.31)</a> by another thread while it is waiting, then the wait is ended and an <code>InterruptedException</code> is thrown.<p>
<a name="14185"></a>
<p><strong>20.20.30	</strong> <code>public final void join(long millis, int nanos)<br>	throws InterruptedException</code>
<p>
<a name="26522"></a>
This method causes the current thread to wait (using the <code>wait</code> method <a href="20_1.htm#32520">(&#167;20.1.8)</a> of 
class <code>Object</code>) until either this thread is no longer alive or a certain amount of real 
time has elapsed, more or less.
<p><a name="26604"></a>
The amount of real time, measured in nanoseconds, is given by:<p>
<pre><a name="26525"></a><code>1000000*millis+nanos
</code></pre><p><a name="29145"></a>
In all other respects, this method does the same thing as the method <code>join</code> of one 
argument <a href="20_20.htm#14183">(&#167;20.20.29)</a>. In particular, <code>join(0,</code> <code>0)</code> means the same thing as 
<code>join(0)</code>.
<p><a name="31401"></a>
If the current thread is interrupted <a href="20_20.htm#29179">(&#167;20.20.31)</a> by another thread while it is waiting, then the wait is ended and an <code>InterruptedException</code> is thrown.<p>
<a name="29179"></a>
<p><strong>20.20.31	</strong> <code>public void interrupt()</code>
<p>
<a name="29191"></a>
An interrupt request is posted for this thread. This thread does not necessarily 
react immediately to the interrupt, however. If this thread is waiting, it is awakened and it then throws an <code>InterruptedException</code>.
<p><a name="29217"></a>
[This method is scheduled for introduction in Java version 1.1.]<p>
<a name="29183"></a>
<p><strong>20.20.32	</strong> <code>public boolean isInterrupted()</code>
<p>
<a name="29196"></a>
The result is <code>true</code> if and only if an interrupt request has been posted for this 
thread.
<p><a name="29223"></a>
[This method is scheduled for introduction in Java version 1.1.]<p>
<a name="29184"></a>
<p><strong>20.20.33	</strong> <code>public static boolean interrupted()</code>
<p>
<a name="29198"></a>
The result is <code>true</code> if and only if an interrupt request has been posted for the current thread.
<p><a name="29227"></a>
[This method is scheduled for introduction in Java version 1.1.]<p>
<a name="26543"></a>
<p><strong>20.20.34	</strong> <code>public static Thread currentThread()</code>
<p>
<a name="26552"></a>
The <code>Thread</code> object that represents the current thread is returned.
<p><a name="26411"></a>
<p><strong>20.20.35	</strong> <code>public static int activeCount()</code>
<p>
<a name="26533"></a>
This method returns the number of active threads in the thread group to which the 
current thread belongs. This count includes threads in subgroups of that thread 
group. This is the same as the value of the expression:
<p><pre><a name="26534"></a>Threads.currentThread().getThreadGroup().activeCount()
</pre><p><a name="29232"></a>
[This method is deprecated for use in new code after Java version 1.1 becomes available. Instead, an expression equivalent to:<p>
<pre><a name="29252"></a>Threads.currentThread().getThreadGroup().allThreadsCount()
</pre><p><a name="29250"></a>
should be used. See the method <code>allThreadsCount</code> of class <code>ThreadGroup</code>.]
<p><a name="26412"></a>
<p><strong>20.20.36	</strong> <code>public static int enumerate(Thread tarray[])</code>
<p>
<a name="26556"></a>
The active threads in the thread group to which the current thread belongs, including threads in subgroups of that thread group, are enumerated and their Thread 
objects are put into the array <code>tarray</code>. The number of threads actually put into the 
array is returned. Call this value <i>n</i>; then the threads have been put into elements <code>0</code> 
through <i>n</i><code>-1</code> of <code>tarray</code>. If the number of threads exceeds the length of <code>tarray</code>, 
then some of the threads, <code>tarray.length</code> of them, are chosen arbitrarily and 
used to fill the array <code>tarray</code>.
<p><a name="29267"></a>
[This method is deprecated for use in new code after Java version 1.1 becomes available. Instead, an expression equivalent to:<p>
<pre><a name="29268"></a>Threads.currentThread().getThreadGroup().allThreads()
</pre><p><a name="29269"></a>
should be used. See the method <code>allThreads</code> of class <code>ThreadGroup</code>.]
<p><a name="14189"></a>
<p><strong>20.20.37	</strong> <code>public static void dumpStack()</code>
<p>
<a name="26581"></a>
This is a utility method that makes it easy to print a stack dump for the current 
thread. It is equivalent in effect to:
<p><pre><a name="26582"></a>new Exception("Stack trace").printStackTrace()
</pre><p><a name="26587"></a>
See the <code>printStackTrace</code> method <a href="20_22.htm#10058">(&#167;20.22.6)</a> of class <code>Throwable</code>.
<p><a name="2706"></a>
<p><strong>20.20.38	</strong> <code>public static void yield()</code>
<p>
<a name="26594"></a>
This method causes the current thread to yield, allowing the thread scheduler to 
choose another runnable thread for execution.
<p><a name="2707"></a>
<p><strong>20.20.39	</strong> <code>public static void sleep(long millis)<br>throws InterruptedException</code>
<p>
<a name="26610"></a>
This method causes the current thread to yield and not to be scheduled for further 
execution until a certain amount of real time has elapsed, more or less.
<p><a name="26611"></a>
The amount of real time, measured in milliseconds, is given by <code>millis</code>.<p>
<a name="29149"></a>
If the current thread is interrupted <a href="20_20.htm#29179">(&#167;20.20.31)</a> by another thread while it is waiting, then the sleep is ended and an <code>InterruptedException</code> is thrown.<p>
<a name="2708"></a>
<p><strong>20.20.40	</strong> <code>public static void sleep(long millis, int nanos)<br>throws InterruptedException</code>
<p>
<a name="26625"></a>
This method causes the current thread to yield and not to be scheduled for further 
execution until a certain amount of real time has elapsed, more or less.
<p><a name="31430"></a>
The amount of real time, measured in nanoseconds, is given by:<p>
<pre><a name="31431"></a><code>1000000*millis+nanos
</code></pre><p><a name="32781"></a>
In all other respects, this method does the same thing as the method <code>sleep</code> of one 
argument <a href="20_20.htm#2707">(&#167;20.20.39)</a>. In particular, <code>sleep(0,</code> <code>0)</code> means the same thing as 
<code>sleep(0)</code>.
<p><a name="29157"></a>
If the current thread is interrupted <a href="20_20.htm#29179">(&#167;20.20.31)</a> by another thread while it is waiting, then the sleep is ended and an <code>InterruptedException</code> is thrown.<p>


</body></html>
