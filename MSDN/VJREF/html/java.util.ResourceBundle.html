<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<A NAME="_top_"></A>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Class ResourceBundle</TITLE>
<H1>
  Class java.util.ResourceBundle
</H1>
<A HREF="java.util.ResourceBundle001.html">Class Members</A> | 
  <A HREF="Package-java.util.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=3><PRE>
<A HREF="java.lang.Object.html">java.lang.Object</A>
   |
   +----java.util.ResourceBundle
</PRE></FONT>

<P><B> public abstract class <B>ResourceBundle</B>
  <BR>
 extends <A HREF="java.lang.Object.html">Object</A>
<BR>
</B>
<P>

Resource bundles contain locale-specific objects.
 When your program needs a locale-specific resource, 
 a <B>String</B> for example, your program can load it
 from the resource bundle that is appropriate for the
 current user's locale. In this way, you can write 
 program code that is largely independent of the user's
 locale isolating most, if not all, of the locale-specific
 information in resource bundles.
 <P>
 This allows you to write programs that can:
 <UL TYPE=SQUARE>
 <LI> be easily localized, or translated, into different languages
 <LI> handle multiple locales at once
 <LI> be easily modified later to support even more locales
 </UL>
 <P>
 One resource bundle is, conceptually, a set of related classes that 
 inherit from <B>ResourceBundle</B>. Each related subclass of
 <B>ResourceBundle</B> has the same base name plus an additional
 component that identifies its locale. For example, suppose your resource
 bundle is named <B>MyResources</B>. The first class you are likely
 to write is the default resource bundle which simply has the same name as
 its family--<B>MyResources</B>. You can also provide as
 many related locale-specific classes as you need: for example, perhaps
 you would provide a German one named <B>MyResources_de</B>.
 <P>
 Each related subclass of <B>ResourceBundle</B> contains the same
 items, but the items have been translated for the locale represented by that
 <B>ResourceBundle</B> subclass. For example, both <B>MyResources</B>
 and <B>MyResources_de</B> may have a <B>String</B> that's used
 on a button for confirming operations. In <B>MyResources</B> the
 <B>String</B> may contain <B>OK</B> and in
 <B>MyResources_de</B> it may contain <B>Gut</B>.
 <P>
 If there are different resources for different countries, you
 can make specializations: for example, <B>MyResources_de_CH</B>
 for Switzerland. If you want to only modify some of the resources
 in the specialization, you can do so.
 <P>
 When your program needs a locale-specific object, it loads
 the <B>ResourceBundle</B> class using the <B>getBundle</B>
 method:
 <BLOCKQUOTE>
 </FONT><PRE>
 ResourceBundle myResources = 
      ResourceBundle.getBundle("MyResources", currentLocale);
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 The first argument specifies the family name of the resource
 bundle that contains the object in question. The second argument
 indicates the desired locale. <B>getBundle</B>
 uses these two arguments to construct the name of the
 <B>ResourceBundle</B> subclass it should load as follows.
 <P>
 The resource bundle lookup searches for classes with various suffixes
 on the basis of (1) the desired locale and (2) the default locale (baseclass),
 in the following order from lower-level (more specific) to parent-level
 (less specific):
 <P> baseclass + "_" + language1 + "_" + country1 + "_" + variant1
 <BR> baseclass + "_" + language1 + "_" + country1
 <BR> baseclass + "_" + language1
 <BR> baseclass
 <BR> baseclass + "_" + language2 + "_" + country2 + "_" + variant2
 <BR> baseclass + "_" + language2 + "_" + country2
 <BR> baseclass + "_" + language2
 <P>
 The result of the lookup is a class, but that class may be
 backed by a property file on disk. If a lookup fails,
 <B>getBundle()</B> throws a <B>MissingResourceException</B>.
 <P>
 The baseclass <STRONG>must</STRONG> be fully
 qualified (for example, <B>myPackage.MyResources</B>, not just
 <B>MyResources</B>). It must
 also be accessable by your code; it cannot be a class that is private
 to the package where <B>ResourceBundle.getBundle</B> is called.
 <P>
 Note: <B>ResourceBundle</B> are used internally in accessing 
 <B>NumberFormat</B>s, <B>Collation</B>s, and so on.
 The lookup strategy is the same.
 <P>
 Resource bundles contain key/value pairs. The keys uniquely
 identify a locale-specific object in the bundle. Here's an 
 example of a <B>ListResourceBundle</B> that contains
 two key/value pairs:
 <BLOCKQUOTE>
 </FONT><PRE>
 class MyResource extends ListResourceBundle {
      public Object[][] getContents() {
              return contents;
      }
      static final Object[][] contents = {
      // LOCALIZE THIS
              {"OkKey", "OK"},
              {"CancelKey", "Cancel"},
      // END OF MATERIAL TO LOCALIZE
      };
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Keys are always <B>String</B>s.
 In this example, the keys are <B>OkKey</B> and <B>CancelKey</B>.
 In the above example, the values
 are also <B>String</B>s--<B>OK</B> and <B>Cancel</B>--but
 they don't have to be. The values can be any type of object.
 <P>
 You retrieve an object from resource bundle using the appropriate
 getter method. Because <B>OkKey</B> and <B>CancelKey</B>
 are both strings, you would use <B>getString</B> to retrieve them:
 <BLOCKQUOTE>
 </FONT><PRE>
 button1 = new Button(myResourceBundle.getString("OkKey"));
 button2 = new Button(myResourceBundle.getString("CancelKey"));
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 The getter methods all require the key as an argument and return
 the object if found. If the object is not found, the getter method
 throws a <B>MissingResourceException</B>.
 <P>
 Besides <B>getString</B>; ResourceBundle supports a number
 of other methods for getting different types of objects such as
 <B>getStringArray</B>. If you don't have an object that
 matches one of these methods, you can use <B>getObject</B>
 and cast the result to the appropriate type. For example:
 <BLOCKQUOTE>
 </FONT><PRE>
 int[] myIntegers = (int[]) myResources.getObject("intList");
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 <P>
 <STRONG>NOTE:</STRONG> You should always supply a baseclass with
 no suffixes. This will be the class of "last resort", if a locale
 is requested that does not exist. For example, below we have a class
 <B>MyResources</B>. It happens to contain US strings,
 so we don't have to have an explicit <B>MyResource_en</B> or
 <B>MyResource_en_US</B>.
 <P>
 The JDK provides two subclasses of <B>ResourceBundle</B>,
 <B>ListResourceBundle</B> and <B>PropertyResourceBundle</B>,
 that provide a fairly simple way to create resources. (Once serialization
 is fully integrated, we will provide another
 way.) As you saw briefly in a prevous example, <B>ListResourceBundle</B>
 manages its resource as a List of key/value pairs.
 <B>PropertyResourceBundle</B> uses a properties file to manage
 its resources.
 <P>
 If <B>ListResourceBundle</B> or <B>PropertyResourceBundle</B>
 do not suit your needs, you can write your own <B>ResourceBundle</B>
 subclass.  Your subclasses must overrde two methods: <B>handleGetObject</B>
 and <B>getKeys()</B>.
 <P>
 The following is a very simple example of a <B>ResourceBundle</B> subclass
 that manages only a few resources (for a larger number of resources
 you would probably use a <B>Hashtable</B>). Notice that if the key
 is not found, <B>handleGetObject</B> must return null. Notice also
 that you don't need to supply a value if a "parent-level"
 <B>ResourceBundle</B> handles the same
 key with the same value (look at uk below).
 <STRONG><P>Example:</STRONG>
 <BLOCKQUOTE>
 </FONT><PRE>
 abstract class MyResources extends ResourceBundle {
     public Object handleGetObject(String key) {
         if (key.equals("okKey")) return "Ok";
         if (key.equals("cancelKey")) return "Cancel";
 	   return null;
     }
 }
 abstract class MyResources_de extends MyResources {
     public Object handleGetObject(String key) {
         if (key.equals("okKey")) return "Gut";
         if (key.equals("cancelKey")) return "Vernichten";
         return null;
     }
 }
 abstract class MyResources_uk extends MyResources {
     public Object handleGetObject(String key) {
         // don't need okKey, since parent level handles it.
         if (key.equals("cancelKey")) return "Dispose";
     	   return null;
     }
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 You do not have to restrict yourself to using a single family of
 <B>ResourceBundle</B>s. For example, you could have a set of bundles for
 exception messages, <B>ExceptionResources</B>
 (<B>ExceptionResources_fr</B>, <B>ExceptionResources_de</B>, ...),
 and one for widgets, <B>WidgetResource</B> (<B>WidgetResources_fr</B>,
 <B>WidgetResources_de</B>, ...); breaking up the resources however you like.
<P>
<DL>
    <DT> <B>See Also:</B>
    <DD> <A HREF="java.util.ListResourceBundle.html">ListResourceBundle</A>, <A HREF="java.util.PropertyResourceBundle.html">PropertyResourceBundle</A>, <A HREF="java.util.MissingResourceException.html">MissingResourceException</A>
</DL>
<HR>

</BODY>
</HTML>
