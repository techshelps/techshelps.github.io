<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.4.22 Method and Constructor Overloading</title>
<META NAME=MS-HAID CONTENT="13_4_22">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>13.4.22	 Method and Constructor Overloading</h3>
<a name="45274"></a>
<p>
<a name="45275"></a>
Adding new methods that overload existing method names does not break compatibility with pre-existing binaries. The method signature to be used for each 
method invocation was determined when these existing binaries were compiled; 
therefore newly added methods will not be used, even if their signatures are both 
applicable and more specific than the method signature originally chosen.
<p><a name="45276"></a>
While adding a new overloaded method or constructor may cause a compile-time error the next time a class or interface is compiled because there is no method or constructor that is most specific <a href="15_11_2.htm#18428">(&#167;15.11.2.2)</a>, no such error occurs when a Java program is executed, because no overload resolution is done at execution time.<p>
<a name="45280"></a>
If the example program:<p>
<pre><a name="45281"></a>
class Super {
<a name="45282"></a>	static void out(float f) { System.out.println("float"); }
<a name="45283"></a>}
<a name="45284"></a>
class Test {
<a name="45285"></a>	public static void main(String[] args) {
<a name="45286"></a>		Super.out(2);
<a name="45287"></a>	}
<a name="45288"></a>}
</pre><p><a name="45289"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45290"></a>float
</pre><p><a name="45291"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45292"></a>
class Super {
<a name="45293"></a>	static void out(float f) { System.out.println("float"); }
<a name="45294"></a>	static void out(int i) { System.out.println("int"); }
<a name="45295"></a>}
</pre><p><a name="45296"></a>
If <code>Super</code> is recompiled but not <code>Test</code>, then running the new binary with the existing binary of <code>Test</code> still produces the output:
<p><pre><a name="45297"></a>float
</pre><p><a name="45298"></a>
However, if <code>Test</code> is then recompiled, using this new <code>Super</code>, the output is then:
<p><pre><a name="45299"></a>int
</pre><p><a name="45300"></a>
as might have been naively expected in the previous case.
<p>

</body></html>
