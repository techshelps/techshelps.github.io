<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.4.8 final Fields and Constants</title>
<META NAME=MS-HAID CONTENT="13_4_8">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>13.4.8	 final Fields and Constants</h3>
<a name="45139"></a>
<p>
<a name="45140"></a>
If a field that was not <code>final</code> is changed to be <code>final</code>, then it can break compatibility with pre-existing binaries that attempt to assign new values to the field. For 
example, if the program:
<p><pre><a name="45141"></a>class Super { static char s; }
</pre><p><pre><a name="45142"></a>
class Test extends Super {
<a name="45143"></a>	public static void main(String[] args) {
<a name="45144"></a>		s = 'a';
<a name="45145"></a>		System.out.println(s);
<a name="45146"></a>	}
<a name="45147"></a>}
</pre><p><a name="45148"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45149"></a>a
</pre><p><a name="47429"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="47321"></a>class Super { static char s; }
</pre><p><a name="45152"></a>
If <code>Super</code> is recompiled but not <code>Test</code>, then running the new binary with the existing binary of <code>Test</code> results in a <code>IncompatibleClassChangeError</code>. (In certain 
early implementations of Java this example would run without error, because of a 
flaw in the implementation.)
<p><a name="45153"></a>
We call a field that is <code>static</code>, <code>final</code>, and initialized with a compile-time constant expression a <i>primitive</i> <i>constant</i>. Note that all fields in interfaces are implicitly <code>static</code> and <code>final</code>, and they are often, but not always, constants.<p>
<a name="45154"></a>
If a field is not a primitive constant, then deleting the keyword <code>final</code> or changing the value to which the field is initialized does not break compatibility with existing binaries.<p>
<a name="45155"></a>
If a field is a primitive constant, then deleting the keyword <code>final</code> or changing its value will not break compatibility with pre-existing binaries by causing them not to run, but they will not see any new value for the constant unless they are recompiled. If the example:<p>
<pre><a name="45156"></a>class Flags { final static boolean debug = true; }
</pre><p><pre><a name="45157"></a>
class Test {
<a name="45158"></a>	public static void main(String[] args) {
<a name="45159"></a>		if (Flags.debug)
<a name="45160"></a>			System.out.println("debug is true");
<a name="45161"></a>	}
<a name="45162"></a>}
</pre><p><a name="45163"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45164"></a>debug is true
</pre><p><a name="45165"></a>
Suppose that a new version of class <code>Flags</code> is produced:
<p><pre><a name="45166"></a>class Flags { final static boolean debug = false; }
</pre><p><a name="45167"></a>
If <code>Flags</code> is recompiled but not <code>Test</code>, then running the new binary with the existing binary of <code>Test</code> produces the output:
<p><pre><a name="45168"></a>debug is true
</pre><p><a name="45169"></a>
because the value of <code>debug</code> was a compile-time primitive constant, and could have 
been used in compiling <code>Test</code> without making a reference to the class <code>Flags</code>.
<p><a name="47435"></a>
This behavior would not change if <code>Flags</code> were changed to be an interface, as in the modified example:<p>
<pre><a name="45170"></a>interface Flags { boolean debug = true; }
<a name="45171"></a>class Test {
<a name="45172"></a>	public static void main(String[] args) {
<a name="45173"></a>		if (Flags.debug)
<a name="45174"></a>			System.out.println("debug is true");
<a name="45175"></a>	}
<a name="45176"></a>}
</pre><p><a name="45177"></a>
(One reason for requiring inlining of primitive constants is that Java <code>switch</code> statements require constants on each <code>case</code>, and no two such constant values may be 
the same. Java checks for duplicate constant values in a <code>switch</code> statement at compile time; the <code>class</code> file format does not do symbolic linkage of <code>case</code> values.)
<p><a name="45178"></a>
The best way to avoid problems with "inconstant constants" in widely-distributed code is to declare as primitive constants only values which truly are unlikely ever to change. Many primitive constants in interfaces are small integer values replacing enumerated types, which Java does not support; these small values can be chosen arbitrarily, and should not need to be changed. Other than for true mathematical constants, we recommend that Java code make very sparing use of class variables that are declared <code>static</code> and <code>final</code>. If the read-only nature of <code>final</code> is required, a better choice is to declare a <code>private</code> <code>static</code> variable and a suitable accessor method to get its value. Thus we recommend:<p>
<pre><a name="45179"></a>private static int N;
<a name="45180"></a>public static int getN() { return N; }
</pre><p><a name="45181"></a>
rather than:
<p><pre><a name="45182"></a>public static final int N = ...;
</pre><p><a name="45183"></a>
There is no problem with:
<p><pre><a name="45184"></a>public static int N = ...;
</pre><p><a name="45185"></a>
if <code>N</code> need not be read-only. We also recommend, as a general rule, that only truly 
constant values be declared in interfaces. We note, but do not recommend, that if a 
field of primitive type of an interface may change, its value may be expressed idiomatically as in:
<p><pre><a name="45186"></a>
interface Flags {
<a name="45187"></a>	boolean debug = new Boolean(true).booleanValue();
<a name="45188"></a>}
</pre><p><a name="47644"></a>
insuring that this value is not a constant. Similar idioms exist for the other primitive types.
<p><a name="47645"></a>
One other thing to note is that <code>static</code> <code>final</code> fields that have constant values (whether of primitive or <code>String</code> type) must never appear to have the default initial value for their type <a href="4_5_4.htm#10931">(&#167;4.5.4)</a>. This means that all such fields appear to be initialized first during class initialization (<a href="8_3_2.htm#38010">&#167;8.3.2.1</a>, <a href="9_3_1.htm#40720">&#167;9.3.1</a>, <a href="12_4_2.htm#44630">&#167;12.4.2</a>).<p>


</body></html>
