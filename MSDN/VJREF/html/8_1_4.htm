<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.1.4 Superinterfaces</title>
<META NAME=MS-HAID CONTENT="8_1_4">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>8.1.4	 Superinterfaces</h3>
<a name="34031"></a>
<p>
<a name="18953"></a>
<meta name="MS-HKWD" content="implements">
The optional <code>implements</code> clause in a class declaration lists the names of interfaces that are <i>direct superinterfaces</i> of the class being declared:
<p><pre>
<i>Interfaces:<br>
	<code>implements </code>InterfaceTypeList
</i>
<i>InterfaceTypeList:<br>
	InterfaceType<br>
	InterfaceTypeList<code> , </code>InterfaceType
</i></pre><p><a name="229546"></a>
The following is repeated from <a href="4_3.htm#9317">&#167;4.3</a> to make the presentation here clearer:
<p><pre>
<i>InterfaceType:<br>
	TypeName
</i></pre><p><a name="34112"></a>
Each <i>InterfaceType</i> must name an accessible <a href="6_6.htm#33916">(&#167;6.6)</a> interface type, or a compile-
time error occurs. All interfaces in the current package are accessible. Interfaces 
in other packages are accessible if the host system permits access to the package 
<a href="7_4_4.htm#13194">(&#167;7.4.4)</a> and the interface is declared <code>public</code>.
<p><a name="36646"></a>
A compile-time error occurs if the same interface is mentioned two or more times in a single <code>implements</code> clause, even if the interface is named in different ways; for example, the code:<p>
<pre><a name="36651"></a>
class Redundant implements java.lang.Cloneable, Cloneable {
<a name="36652"></a>	int x;
<a name="36654"></a>}
</pre><p><a name="36655"></a>
results in a compile-time error because the names <code>java.lang.Cloneable</code> and 
<code>Cloneable</code> refer to the same interface.
<p><a name="31147"></a>
An interface type <i>I</i><i></i> is a <i>superinterface</i> of class type <i>C</i><i></i> if any of the following is true:<p>
<ul><a name="34118"></a>
<li><i>I</i><i></i> is a direct superinterface of <i>C</i>.
<a name="29862"></a>
<li><i>C</i><i></i> has some direct superinterface <i>J</i><i></i> for which <i>I</i><i></i> is a superinterface<i></i>, using the definition of "superinterface of an interface" given in <a href="9_1_3.htm#78598">&#167;9.1.3</a>.
<a name="34121"></a>
<li><i>I</i><i></i> is a superinterface of the direct superclass of <i>C</i><i></i>, using this definition recursively.
</ul><p><a name="29918"></a>
A class is said to <i>implement</i> all its superinterfaces.
<p><a name="229105"></a>
In the example:<p>
<pre><a name="29875"></a>
public interface Colorable {
<a name="29876"></a>	void setColor(int color);
<a name="29877"></a>	int getColor();
<a name="29878"></a>}
<br><a name="29879"></a>
public interface Paintable extends Colorable {
<a name="29880"></a>	int MATTE = 0, GLOSSY = 1;
<a name="29881"></a>	void setFinish(int finish);
<a name="29882"></a>	int getFinish();
<a name="29883"></a>}
<br><br><a name="29884"></a>class Point { int x, y; }
<br><a name="29885"></a>
class ColoredPoint extends Point implements Colorable {
<a name="29886"></a>	int color;
<a name="29888"></a>	public void setColor(int color) { this.color = color; }
<a name="29889"></a>	public int getColor() { return color; }
<a name="29890"></a>}
<br><a name="29891"></a>
class PaintedPoint extends ColoredPoint implements Paintable <br>
{
<a name="29892"></a>	int finish;
<a name="29893"></a>	public void setFinish(int finish) {
<a name="230320"></a>		this.finish = finish;
<a name="230321"></a>	}
<a name="29894"></a>	public int getFinish() { return finish; }
<a name="29895"></a>}
</pre><p><a name="29896"></a>
the relationships are as follows:
<p><ul><a name="29897"></a>
<li>The interface <code>Paintable</code> is a superinterface of class <code>PaintedPoint</code>.
<a name="29898"></a>
<li>The interface <code>Colorable</code> is a superinterface of class <code>ColoredPoint</code> and of class <code>PaintedPoint</code>.
<a name="29899"></a>
<li>The interface <code>Paintable</code> is a subinterface of the interface <code>Colorable</code>, and <code>Colorable</code> is a superinterface of <code>Paintable</code>, <code>a</code>s defined in <a href="9_1_3.htm#78598">&#167;9.1.3</a>.
</ul><p><a name="29912"></a>
A class can have a superinterface in more than one way. In this example, the class 
<code>PaintedPoint</code> has <code>Colorable</code> as a superinterface both because it is a superinterface of <code>ColoredPoint</code> and because it is a superinterface of <code>Paintable</code>.
<p><a name="29870"></a>
Unless the class being declared is <code>abstract</code>, the declarations of the methods defined in each direct superinterface must be implemented either by a declaration in this class or by an existing method declaration inherited from the direct superclass, because a class that is not <code>abstract</code> is not permitted to have <code>abstract</code> methods <a href="8_1_2.htm#34944">(&#167;8.1.2.1)</a>.<p>
<a name="230327"></a>
Thus, the example:<p>
<pre><a name="16122"></a>
interface Colorable {
<a name="16123"></a>	void setColor(int color);
<a name="16124"></a>	int getColor();
<a name="16125"></a>}
<br><br><a name="16126"></a>class Point { int x, y; };
<br><a name="16127"></a>
class ColoredPoint extends Point implements Colorable {
<a name="16128"></a>	int color;
<a name="16129"></a>}
</pre><p><a name="36705"></a>
causes a compile-time error, because <code>ColoredPoint</code> is not an <code>abstract</code> class but 
it fails to provide an implementation of methods <code>setColor</code> and <code>getColor</code> of the 
interface <code>Colorable</code>.
<p><a name="228059"></a>
It is permitted for a single method declaration in a class to implement methods of more than one superinterface. For example, in the code:<p>
<pre><br><a name="228063"></a>interface Fish { int getNumberOfScales(); }
<br><br><a name="228065"></a>interface Piano { int getNumberOfScales(); }
<br></pre><p><pre><a name="228061"></a>
class Tuna implements Fish, Piano {
<a name="228070"></a>	// You can tune a piano, but can you tuna fish?
<a name="228069"></a>	int getNumberOfScales() { return 91; }
<a name="228068"></a>}
</pre><p><a name="228071"></a>
the method <code>getNumberOfScales</code> in class <code>Tuna</code> has a name, signature, and return 
type that matches the method declared in interface <code>Fish</code> and also matches the 
method declared in interface <code>Piano</code>; it is considered to implement both.
<p><a name="228080"></a>
On the other hand, in a situation such as this:<p>
<pre><br><a name="228083"></a>interface Fish { int getNumberOfScales(); }
<br><br><a name="228084"></a>interface StringBass { double getNumberOfScales(); }
<br></pre><p><pre><a name="228085"></a>
class Bass implements Fish, StringBass {
<a name="228086"></a>	// This declaration cannot be correct, no matter what type is used.
<a name="228087"></a>	public ??? getNumberOfScales() { return 91; }
<a name="228088"></a>}
</pre><p><a name="228081"></a>
it is impossible to declare a method named <code>getNumberOfScales</code> with the same 
signature and return type as those of both the methods declared in interface <code>Fish</code> 
and in interface <code>StringBass</code>, because a class can have only one method with a 
given signature <a href="8_4.htm#40420">(&#167;8.4)</a>. Therefore, it is impossible for a single class to implement 
both interface <code>Fish</code> and interface <code>StringBass</code> <a href="8_4_6.htm#228745">(&#167;8.4.6)</a>.
<p>

</Font></body></html>
