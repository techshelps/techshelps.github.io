<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.10.2 Accessing Superclass Members using super</title>
<META NAME=MS-HAID CONTENT="15_10_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.10.2	 Accessing Superclass Members using super</h3>
<a name="20860"></a>
<p>
<a name="20451"></a>
<meta name="MS-HKWD" content="super">
The special form using the keyword <code>super</code> is valid only in an instance method or 
constructor, or in the initializer of an instance variable of a class; these are exactly 
the same situations in which the keyword <code>this</code> may be used <a href="15_7_2.htm#31980">(&#167;15.7.2)</a>. The form 
involving <code>super</code> may not be used anywhere in the class <code>Object</code>, since <code>Object</code> has 
no superclass; if <code>super</code> appears in class <code>Object</code>, then a compile-time error results.
<p><a name="37384"></a>
Suppose that a field access expression <code>super.</code><i>name</i> appears within class <i>C</i>, and the immediate superclass of <i>C</i> is class <i>S</i>. Then <code>super.</code><i>name</i> is treated exactly as if it had been the expression <code>((</code><i>S</i><code>)this).</code><i>name</i>; thus, it refers to the field named <i>name</i> of the current object, but with the current object viewed as an instance of the superclass. Thus it can access the field named <i>name</i> that is visible in class <i>S</i>, even if that field is hidden by a declaration of a field named <i>name</i> in class <i>C</i>.<p>
<a name="20763"></a>
The use of <code>super</code> is demonstrated by the following example:<p>
<pre><a name="20487"></a>
interface I { int x = 0; }
<a name="20490"></a>class T1 implements I { int x = 1; }
<a name="50230"></a>class T2 extends T1 { int x = 2; }
<a name="20497"></a>class T3 extends T2 {
<a name="20498"></a>	int x = 3;
<a name="20500"></a>	void test() {
<a name="20502"></a>		System.out.println("x=\t\t"+x);
<a name="20503"></a>		System.out.println("super.x=\t\t"+super.x);
<a name="20504"></a>		System.out.println("((T2)this).x=\t"+((T2)this).x);
<a name="20505"></a>		System.out.println("((T1)this).x=\t"+((T1)this).x);
<a name="20506"></a>		System.out.println("((I)this).x=\t"+((I)this).x);
<a name="20512"></a>	}
<a name="20513"></a>}
<a name="20514"></a>class Test {
<a name="20515"></a>	public static void main(String[] args) {
<a name="20516"></a>		new T3().test();
<a name="20518"></a>	}
<a name="20519"></a>}
</pre><p><a name="20520"></a>
which produces the output:
<p><pre><a name="20521"></a>
x=					3
<a name="20522"></a>super.x=					2
<a name="20523"></a>((T2)this).x=					2
<a name="20524"></a>((T1)this).x=					1
<a name="20525"></a>((I)this).x=					0
</pre><p><a name="37491"></a>
Within class <code>T3</code>, the expression <code>super.x</code> is treated exactly as if it were:
<p><pre><a name="37492"></a><code>((T2)this).x
</code></pre><p>

</body></html>
