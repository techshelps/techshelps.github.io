<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.6.3 Parentheses and Precedence Respected</title>
<META NAME=MS-HAID CONTENT="15_6_3">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.6.3	 Parentheses and Precedence Respected</h3>
<a name="23213"></a>
<p>
<a name="236501"></a>
<p><i>That is too weighty a subject to be discussed parenthetically . . .</i><br>
<a name="240887"></a>
--John Stuart Mill, <i>On Liberty</i> (1869), Chapter IV</p>
<a name="23217"></a>
<p>Java implementations must respect the order of evaluation as indicated explicitly 
by parentheses and implicitly by operator precedence. An implementation may 
not take advantage of algebraic identities such as the associative law to rewrite 
expressions into a more convenient computational order unless it can be proven 
that the replacement expression is equivalent in value and in its observable side 
effects, even in the presence of multiple threads of execution (using the thread 
execution model in <a href="chap17.htm">&#167;17</a>), for all possible computational values that might be 
involved.
<p><a name="23218"></a>
In the case of floating-point calculations, this rule applies also for infinity and not-a-number (NaN) values. For example, <code>!(x&lt;y)</code> may not be rewritten as <code>x&gt;=y</code>, because these expressions have different values if either <code>x</code> or <code>y</code> is NaN.<p>
<a name="23219"></a>
Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative. Such computations must not be naively reordered. For example, it is not correct for a Java compiler to rewrite <code>4.0*x*0.5</code> as <code>2.0*x</code>; while roundoff happens not to be an issue here, there are large values of <code>x</code> for which the first expression produces infinity (because of overflow) but the second expression produces a finite result.<p>
<a name="238102"></a>
So, for example, the test program:<p>
<pre><a name="23224"></a>
class Test {
<a name="23225"></a>
	public static void main(String[] args) {
<a name="23226"></a>		double d = 8e+307;
<a name="23227"></a>		System.out.println(4.0 * d * 0.5);
<a name="23228"></a>		System.out.println(2.0 * d);
<a name="23229"></a>	}
<a name="23230"></a>}
</pre><p><a name="23231"></a>
prints:
<p><pre><a name="23232"></a>
Infinity
<a name="23233"></a>1.6e+308
</pre><p><a name="23234"></a>
because the first expression overflows and the second does not.
<p><a name="21009"></a>
In contrast, integer addition and multiplication <i>are</i> provably associative in Java; for example <code>a+b+c</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are local variables (this simplifying assumption avoids issues involving multiple threads and <code>volatile</code> variables), will always produce the same answer whether evaluated as <code>(a+b)+c</code> or <code>a+(b+c)</code>; if the expression <code>b+c</code> occurs nearby in the code, a smart compiler may be able to use this common subexpression.<p>


</body></html>
