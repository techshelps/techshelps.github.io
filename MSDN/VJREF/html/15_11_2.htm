<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.11.2 Compile-Time Step 2: Determine Method Signature</title>
<META NAME=MS-HAID CONTENT="15_11_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.11.2	 Compile-Time Step 2: Determine Method Signature</h3>
<a name="21693"></a>
<p>
<a name="236437"></a>
<p><i>The hand-writing experts were called upon for their opinion of the signature . . .</i><br>
<a name="240891"></a>
&#151;Agatha Christie, <i>The Mysterious Affair at Styles</i> (1920), Chapter 11</p>
<a name="19915"></a>
<p>The second step searches the class or interface determined in the previous step for 
method declarations. This step uses the name of the method and the types of the 
argument expressions to locate method declarations that are both <i>applicable</i> and 
<i>accessible</i>, that is, declarations that can be correctly invoked on the given arguments. There may be more than one such method declaration, in which case the 
<i>most specific</i> one is chosen. The descriptor (signature plus return type) of the most 
specific method declaration is one used at run time to do the method dispatch.
<p><a name="18427"></a>
<h4>15.11.2.1	 Find Methods that are Applicable and Accessible</h4>
<p>
<a name="21818"></a>
A method declaration is <i>applicable</i> to a method invocation if and only if both of 
the following are true:
<p><ul><a name="37650"></a>
<li>The number of parameters in the method declaration equals the number of argument &#32;expressions in the method invocation.
<a name="37653"></a>
<li>The type of each actual argument can be converted by method invocation conversion <a href="5_3.htm#12687">(&#167;5.3)</a> to the type of the corresponding parameter. Method invocation conversion is the same as assignment conversion <a href="5_2.htm#170768">(&#167;5.2)</a>, except that constants of type <code>int</code> are never implicitly narrowed to <code>byte</code>, <code>short</code>, or <code>char</code>.
</ul><p><a name="21702"></a>
The class or interface determined by the process described in <a href="15_11_1.htm#21692">&#167;15.11.1</a> is searched for all method declarations applicable to this method invocation; method definitions inherited from superclasses and superinterfaces are included in this search.<p>
<a name="37690"></a>
Whether a method declaration is <i>accessible</i> to a method invocation depends on the access modifier (<code>public</code>, none, <code>protected</code>, or <code>private</code>) in the method declaration and on where the method invocation appears.<p>
<a name="37675"></a>
If the class or interface has no method declaration that is both applicable and accessible, then a compile-time error occurs.<p>
<a name="37720"></a>
In the example program:<p>
<pre><a name="37706"></a>
public class Doubler {
<a name="37707"></a>	static int two() { return two(1); }
<a name="37708"></a>	private static int two(int i) { return 2*i; }
<a name="37709"></a>}
<a name="37710"></a>
class Test extends Doubler {	
<a name="37733"></a>	public static long two(long j) {return j+j; }
<a name="37711"></a>
	public static void main(String[] args) {
<a name="37712"></a>		System.out.println(two(3));
<a name="37713"></a>		System.out.println(Doubler.two(3));	// compile-time error
<a name="37714"></a>	}
<a name="37715"></a>}
</pre><p><a name="37704"></a>
for the method invocation <code>two(1)</code> within class <code>Doubler</code>, there are two accessible 
methods named <code>two</code>, but only the second one is applicable, and so that is the one 
invoked at run time. For the method invocation <code>two(3)</code> within class <code>Test</code>, there 
are two applicable methods, but only the one in class <code>Test</code> is accessible, and so 
that is the one to be invoked at run time (the argument <code>3</code> is converted to type 
<code>long</code>). For the method invocation <code>Doubler.two(3)</code>, the class <code>Doubler</code>, not class 
<code>Test</code>, is searched for methods named <code>two</code>; the only applicable method is not 
accessible, and so this method invocation causes a compile-time error.
<p><a name="21942"></a>
Another example is:<p>
<pre><a name="21943"></a>
class ColoredPoint {
<a name="21949"></a>	int x, y;
<a name="21950"></a>	byte color;
<a name="21953"></a>	void setColor(byte color) { this.color = color; }
<a name="21954"></a>}
<a name="21955"></a>
class Test {
<a name="21956"></a>	public static void main(String[] args) {
<a name="21957"></a>		ColoredPoint cp = new ColoredPoint();
<a name="21958"></a>		byte color = 37;
<a name="21959"></a>		cp.setColor(color);
<a name="21960"></a>		cp.setColor(37);											// compile-time error
<a name="21961"></a>	}
<a name="21962"></a>}
</pre><p><a name="21881"></a>
Here, a compile-time error occurs for the second invocation of <code>setColor</code>, because 
no applicable method can be found at compile time. The type of the literal <code>37</code> is 
<code>int</code>, and <code>int</code> cannot be converted to <code>byte</code> by method invocation conversion. 
Assignment conversion, which is used in the initialization of the variable <code>color</code>, 
performs an implicit conversion of the constant from type <code>int</code> to <code>byte</code>, which is 
permitted because the value <code>37</code> is small enough to be represented in type <code>byte</code>; but 
such a conversion is not allowed for method invocation conversion.
<p><a name="21968"></a>
If the method <code>setColor</code> had, however, been declared to take an <code>int</code> instead of a <code>byte</code>, then both method invocations would be correct; the first invocation would be allowed because method invocation conversion does permit a widening conversion from <code>byte</code> to <code>int</code>. However, a narrowing cast would then be required in the body of <code>setColor</code>:<p>
<pre><a name="21973"></a>	void setColor(int color) { this.color = (byte)color; }
</pre><p><a name="18428"></a>
<h4>15.11.2.2	 Choose the Most Specific Method</h4>
<p>
<a name="21703"></a>
If more than one method is both accessible and applicable to a method invocation, 
it is necessary to choose one to provide the descriptor for the run-time method dispatch. Java uses the rule that the <i>most specific</i> method is chosen.
<p><a name="21708"></a>
The informal intuition is that one method declaration is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time type error.<p>
<a name="21709"></a>
The precise definition is as follows. Let <i>m</i> be a name and suppose that there are two declarations of methods named <i>m</i>, each having <i>n</i> parameters. Suppose that one declaration appears within a class or interface <i>T</i> and that the types of the parameters are <i>T1</i>,&#32;. . . ,&#32;<i>Tn</i>; suppose moreover that the other declaration appears within a class or interface <i>U</i> and that the types of the parameters are <i>U1</i>, . . . ,&#32;<i>Un</i>. Then the method <i>m</i> declared in <i>T</i> is <i>more specific</i> than the method <i>m</i> declared in <i>U</i><code></code> if and only if both of the following are true:<p>
<ul><a name="37872"></a>
<li><i>T</i> can be converted to <i>U</i><code></code> by method invocation conversion.
<a name="37876"></a>
<li><i>Tj</i> can be converted to <i>Uj</i><code></code> by method invocation conversion, for all <i>j</i> from <code>1</code> to <i>n</i>.
</ul><p><a name="37912"></a>
A method is said to be <i>maximally specific</i> for a method invocation if it is applicable and accessible and there is no other applicable and accessible method that is more specific.<p>
<a name="37937"></a>
If there is exactly one maximally specific method, then it is in fact <i>the most specific</i> method; it is necessarily more specific than any other method that is applicable and accessible. It is then subjected to some further compile-time checks as described in <a href="15_11_3.htm#23617">&#167;15.11.3</a>.<p>
<a name="37907"></a>
It is possible that no method is the most specific, because there are two or more maximally specific method declarations. In this case, we say that the method invocation is <i>ambiguous</i>, and a compile-time error occurs.<p>
<a name="21711"></a>
<h4>15.11.2.3	 Example: Overloading Ambiguity</h4>
<p>
<a name="21712"></a>
Consider the example:
<p><pre><a name="21713"></a>class Point { int x, y; }
<a name="21714"></a>class ColoredPoint extends Point { int color; }
</pre><p><pre><a name="238137"></a>
class Test {
<a name="21716"></a>
	static void test(ColoredPoint p, Point q) {
<a name="21717"></a>		System.out.println("(ColoredPoint, Point)");
<a name="50239"></a>	}
<a name="21718"></a>
	static void test(Point p, ColoredPoint q) {
<a name="21719"></a>		System.out.println("(Point, ColoredPoint)");
<a name="50241"></a>	}
<a name="21720"></a>
	public static void main(String[] args) {
<a name="21722"></a>		ColoredPoint cp = new ColoredPoint();
<a name="21723"></a>		test(cp, cp);											// compile-time error
<a name="21724"></a>	}
<a name="21725"></a>}
</pre><p><a name="21726"></a>
This example produces an error at compile time. The problem is that there are two 
declarations of <code>test</code> that are applicable and accessible, and neither is more specific than the other. Therefore, the method invocation is ambiguous.
<p><a name="38010"></a>
If a third definition of <code>test</code> were added:<p>
<pre><a name="38015"></a>
	static void test(ColoredPoint p, ColoredPoint q) {
<a name="38016"></a>		System.out.println("(ColoredPoint, ColoredPoint)");
<a name="38017"></a>	}
</pre><p><a name="38011"></a>
then it would be more specific than the other two, and the method invocation 
would no longer be ambiguous.
<p><a name="21727"></a>
<h4>15.11.2.4	 Example: Return Type Not Considered</h4>
<p>
<a name="21728"></a>
As another example, consider:
<p><pre><a name="21729"></a>class Point { int x, y; }
<a name="21730"></a>class ColoredPoint extends Point { int color; }
<a name="21731"></a>class Test {
</pre><p><pre><a name="21732"></a>
	static int test(ColoredPoint p) {
<a name="21733"></a>		return color;
<a name="21734"></a>	}
<a name="21735"></a>
	static String test(Point p) {
<a name="21736"></a>		return "Point";
<a name="21737"></a>	}
<a name="21738"></a>
	public static void main(String[] args) {
<a name="21739"></a>		ColoredPoint cp = new ColoredPoint();
<a name="21740"></a>		String s = test(cp); // compile-time error
<a name="21741"></a>	}
<a name="21742"></a>}
</pre><p><a name="21743"></a>
Here the most specific declaration of method <code>test</code> is the one taking a parameter 
of type <code>ColoredPoint</code>. Because the result type of the method is <code>int</code>, a compile-
time error occurs because an <code>int</code> cannot be converted to a <code>String</code> by assignment 
conversion. This example shows that, in Java, the result types of methods do not 
participate in resolving overloaded methods, so that the second <code>test</code> method, 
which returns a <code>String</code>, is not chosen, even though it has a result type that would 
allow the example program to compile without error.
<p><a name="29775"></a>
<h4>15.11.2.5	 Example: Compile-Time Resolution</h4>
<p>
<a name="30681"></a>
The most applicable method is chosen at compile time; its descriptor determines 
what method is actually executed at run time. If a new method is added to a class, 
then Java code that was compiled with the old definition of the class might not use 
the new method, even if a recompilation would cause this method to be chosen.
<p><a name="30687"></a>
So, for example, consider two compilation units, one for class <code>Point</code>:<p>
<pre><a name="30688"></a>package points;
<a name="30689"></a>public class Point {
<a name="30718"></a>	public int x, y;
<a name="30706"></a>	public Point(int x, int y) { this.x = x; this.y = y; }
<a name="30774"></a>	public String toString() { return toString(""); }
</pre><p><pre><a name="30777"></a>
	public String toString(String s) {
<a name="30778"></a>		return "(" + x + "," + y + s + ")";
<a name="30779"></a>	}
<a name="30717"></a>}
</pre><p><a name="30799"></a>
and one for class <code>ColoredPoint</code>:
<p><pre><a name="30800"></a>package points;
<a name="30801"></a>public class ColoredPoint extends Point {
</pre><p><pre><a name="30802"></a>
	public static final int
<a name="30803"></a>		RED = 0, GREEN = 1, BLUE = 2;
<a name="30804"></a>
	public static String[] COLORS =
<a name="30805"></a>		{ "red", "green", "blue" };
<a name="30806"></a>	public byte color;
<a name="30807"></a>
	public ColoredPoint(int x, int y, int color) {
<a name="30808"></a>		super(x, y); this.color = (byte)color;
<a name="30809"></a>	}
<a name="38090"></a>
	/** Copy all relevant fields of the argument into
<a name="38091"></a>		 &#32; &#32;this <code>ColoredPoint</code> object. */
<a name="30810"></a>	public void adopt(Point p) { x = p.x; y = p.y; }
<a name="30811"></a>
	public String toString() {
<a name="30812"></a>		String s = "," + COLORS[color];
<a name="30813"></a>		return super.toString(s);
<a name="30814"></a>	}
<a name="38076"></a>}
</pre><p><a name="30815"></a>
Now consider a third compilation unit that uses <code>ColoredPoint</code>:
<p><pre><a name="30699"></a>import points.*;
<a name="30702"></a>class Test {
<a name="30700"></a>	public static void main(String[] args) {
<a name="30701"></a>		ColoredPoint cp =
<a name="30748"></a>			new ColoredPoint(6, 6, ColoredPoint.RED);
<a name="30722"></a>		ColoredPoint cp2 =
<a name="30751"></a>			new ColoredPoint(3, 3, ColoredPoint.GREEN);
<a name="30705"></a>		cp.adopt(cp2);
<a name="30766"></a>		System.out.println("cp: " + cp);
<a name="30720"></a>	}
<a name="30721"></a>}
</pre><p><a name="30754"></a>
The output is:
<p><pre><a name="30755"></a>cp: (3,3,red)
</pre><p><a name="30756"></a>
The application programmer who coded class <code>Test</code> has expected to see the word <code>green</code>, because the actual argument, a <code>ColoredPoint</code>, has a <code>color</code> field, and <code>color</code> would seem to be a "relevant field" (of course, the documentation for the package <code>Points</code> ought to have been much more precise!).<p>
<a name="38120"></a>
Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of <code>adopt</code> has a signature that indicates a method of one parameter, and the parameter is of type <code>Point</code>. This signature becomes part of the binary representation of class <code>Test</code> produced by the compiler and is used by the method invocation at run time.<p>
<a name="38098"></a>
Suppose the programmer reported this software error and the maintainer of the <code>points</code> package decided, after due deliberation, to correct it by adding a method to class <code>ColoredPoint</code>:<p>
<pre><a name="30827"></a>
public void adopt(ColoredPoint p) {
<a name="30828"></a>	adopt((Point)p); color = p.color;
<a name="30835"></a>}
</pre><p><a name="239516"></a>
If the application programmer then runs the old binary file for <code>Test</code> with the new binary file for <code>ColoredPoint</code>, the output is still:<p>
<pre><a name="38140"></a>cp: (3,3,red)
</pre><p><a name="38138"></a>
because the old binary file for <code>Test</code> still has the descriptor "one parameter, whose 
type is <code>Point</code>; <code>void</code>" associated with the method call <code>cp.adopt(cp2)</code>. If the 
source code for <code>Test</code> is recompiled, the compiler will then discover that there are 
now two applicable <code>adopt</code> methods, and that the signature for the more specific 
one is "one parameter, whose type is <code>ColoredPoint</code>; <code>void</code>"; running the program 
will then produce the desired output:
<p><pre><a name="38149"></a>cp: (3,3,green)
</pre><p><a name="30865"></a>
With forethought about such problems, the maintainer of the <code>points</code> package could fix the <code>ColoredPoint</code> class to work with both newly compiled and old code, by adding defensive code to the old <code>adopt</code> method for the sake of old code that still invokes it on <code>ColoredPoint</code> arguments:<p>
<pre><a name="30880"></a>
public void adopt(Point p) {
<a name="30886"></a>	if (p instanceof ColoredPoint)
<a name="30887"></a>		color = ((ColoredPoint)p).color;
<a name="30888"></a>	x = p.x; y = p.y;
<a name="30889"></a>}
</pre><p><a name="30914"></a>
A similar consideration applies if a method is to be moved from a class to a superclass. In this case a forwarding method can be left behind for the sake of old code. The maintainer of the <code>points</code> package might choose to move the <code>adopt</code> method that takes a <code>Point</code> argument up to class <code>Point</code>, so that all <code>Point</code> objects may enjoy the <code>adopt</code> functionality. To avoid compatibility problems with old binary code, the maintainer should leave a forwarding method behind in class <code>ColoredPoint</code>:<p>
<pre><a name="30926"></a>
public void adopt(Point p) {
<a name="30927"></a>	if (p instanceof ColoredPoint)
<a name="30928"></a>		color = ((ColoredPoint)p).color;
<a name="30929"></a>	super.adopt(p);
<a name="30930"></a>}
</pre><p><a name="38189"></a>
Ideally, Java code should be recompiled whenever code that it depends on is changed. However, in an environment where different Java classes are maintained by different organizations, this is not always feasible. Defensive programming with careful attention to the problems of class evolution can make upgraded code much more robust. See <a href="chap13.htm">&#167;13</a> for a detailed discussion of binary compatibility and type evolution.<p>


</body></html>
