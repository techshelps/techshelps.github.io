<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.2 What Binary Compatibility Is and Is Not</title>
<META NAME=MS-HAID CONTENT="13_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>13.2	 What Binary Compatibility Is and Is Not</h2>
<a name="44952"></a>
<p>
<a name="44953"></a>
A change to a type is <i>binary compatible</i> <i>with</i> (equivalently, does not<i> break binary 
compatibility </i>with) preexisting binaries if preexisting binaries that previously 
linked without error will continue to link without error.
<p><a name="44957"></a>
As described in <a href="13_1.htm#44909">&#167;13.1</a>, symbolic references to methods and fields name the exact class or interface in which the method or field is declared. This means that binaries are compiled to rely on the accessible members and constructors of other classes and interfaces. To preserve binary compatibility, a class or interface should treat these accessible members and constructors, their existence and behavior, as a <i>contract</i> with users of the class or interface.<p>
<a name="44958"></a>
Java is designed to prevent additions to contracts and accidental name collisions from breaking binary compatibility; specifically:<p>
<ul><a name="44959"></a>
<li>Introducing a new field with the same name as an existing field, in a subclass of the class containing the existing field declaration, does not break compatibility with preexisting binaries. See the example at the beginning of <a href="13_4_5.htm#45037">&#167;13.4.5</a>.
<a name="44963"></a>
<li>Addition of more methods overloading a particular method name does not break compatibility with preexisting binaries. The method signature that the preexisting binary will use for method lookup is chosen by Java's method overload resolution algorithm at compile time <a href="15_11_2.htm#21693">(&#167;15.11.2)</a>. (If Java had been designed so that the particular method to be executed was chosen at run time, then such an ambiguity might be detected at run time. Such a rule would imply that adding an additional overloaded method so as to make ambiguity possible at a call site became possible could break compatibility with an unknown number of preexisting binaries. See <a href="13_4_22.htm#45274">&#167;13.4.22</a> for more discussion.)
</ul><p><a name="44967"></a>
Binary compatibility is not the same as source compatibility. In particular, the example in <a href="13_4_5.htm#45037">&#167;13.4.5</a> shows that a set of compatible binaries can be produced from sources that will not compile all together. This example is typical: a new declaration is added, changing the meaning of a name in an unchanged part of the source code, while the preexisting binary for that unchanged part of the source code retains the fully-qualified, previous meaning of the name. Producing a consistent set of source code requires providing a qualified name or field access expression corresponding to the previous meaning.<p>
<a name="47335"></a>
We hope to make some improvements to future versions of Java to better support both source and binary compatible evolution of types. In particular, we are considering a mechanism to allow a class to implement two interfaces that have methods with the same signature but are to be considered different or have different return types. We welcome suggestions and proposals that would help us to make additional improvements, either in managing name and signature conflicts or other sources of incompatibility.<p>


</body></html>
