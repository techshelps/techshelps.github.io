</Font></body></html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5. Conversions and Promotions</title>
<META NAME=MS-HAID CONTENT="chap05">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
</head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">  
<hr><br>
 
<a name="44342"></a>
<p><strong>
CHAPTER
 5 </strong></p>

<h1> Conversions and Promotions</h1>
<a name="27529"></a>
<p>
<a name="27530"></a>
<p><i>Thou art not for the fashion of these times,<br>Where none will sweat but for promotion.</i><br>
<a name="176957"></a>
&#151;William Shakespeare, As You Like It, Act II, scene iii</p>
<p>
<a name="25009"></a>
Every Java expression has a type that can be deduced from the structure of the 
expression and the types of the literals, variables, and methods mentioned in the 
expression. It is possible, however, to write an expression in a context where the 
type of the expression is not appropriate. In some cases, this leads to an error at 
compile time; for example, if the expression in an <code>if</code> statement <a href="14_8.htm#5991">(&#167;14.8)</a> has any 
type other than <code>boolean</code>, a compile-time error occurs. In other cases, the context 
may be able to accept a type that is related to the type of the expression; as a convenience, rather than requiring the programmer to indicate a type conversion 
explicitly, the Java language performs an implicit <i>conversion</i> from the type of the 
expression to a type acceptable for its surrounding context.
<p><a name="25037"></a>
A specific conversion from type <i>S</i> to type <i>T</i> allows an expression of type <i>S</i> to be treated at compile time as if it had type <i>T</i> instead. In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type <i>T</i>. For example:<p>
<ul><a name="25041"></a>
<li>A conversion from type <code>Object</code> <a href="20_1.htm#14533">(&#167;20.1)</a> to type <code>Thread</code> <a href="20_20.htm#2658">(&#167;20.20)</a> requires a run-time check to make sure that the run-time value is actually an instance of class <code>Thread</code> or one of its subclasses; if it is not, an exception is thrown.
<a name="25042"></a>
<li>A conversion from type <code>Thread</code> to type <code>Object</code> requires no run-time action; <code>Thread</code> is a subclass of <code>Object</code>, so any reference produced by an expression of type <code>Thread</code> is a valid reference value of type <code>Object</code>.
<a name="25043"></a>
<li>A conversion from type <code>int</code> to type <code>long</code> requires run-time sign-extension of a 32-bit integer value to the 64-bit <code>long</code> representation. No information is lost.
<a name="25044"></a>
<li>A conversion from type <code>double</code> to type <code>long</code> requires a nontrivial translation from a 64-bit floating-point value to the 64-bit integer representation. Depending on the actual run-time value, information may be lost.
</ul><p><a name="24996"></a>
In every conversion context, only certain specific conversions are permitted. The specific conversions that are possible in Java are grouped for convenience of description into several broad categories:<p>
<ul><a name="25070"></a>
<li>Identity conversions
<a name="25071"></a>
<li>Widening primitive conversions
<a name="25072"></a>
<li>Narrowing primitive conversions
<a name="25073"></a>
<li>Widening reference conversions
<a name="25086"></a>
<li>Narrowing reference conversions
<a name="25087"></a>
<li>String conversions
</ul><p><a name="24995"></a>
There are five <i>conversion contexts</i> in which conversion of Java expressions may occur. Each context allows conversions in some of the categories named above but not others. The term "conversion" is also used to describe the process of choosing a specific conversion for such a context. For example, we say that an expression that is an actual argument in a method invocation is subject to "method invocation conversion," meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the method invocation argument context.<p>
<a name="25089"></a>
One conversion context is the operand of a numeric operator such as <code>+</code> or <code>*</code>. The conversion process for such operands is called <i>numeric promotion</i>. Promotion is special in that, in the case of binary operators, the conversion chosen for one operand may depend in part on the type of the other operand expression.<p>
<a name="174138"></a>
This chapter first describes the six categories of conversions <a href="5_1.htm#170671">(&#167;5.1)</a>, including the special conversions to <code>String</code> allowed for the string concatenation operator <code>+</code>. Then the five conversion contexts are described:<p>
<ul><a name="25117"></a>
<li>Assignment conversion (<a href="5_2.htm#170768">&#167;5.2</a>, <a href="15_25.htm#5281">&#167;15.25</a>) converts the type of an expression to the type of a specified variable. The conversions permitted for assignment are limited in such a way that assignment conversion never causes an exception.
<a name="52883"></a>
<li>Method invocation conversion (<a href="5_3.htm#12687">&#167;5.3</a>, <a href="15_8.htm#41147">&#167;15.8</a>, <a href="15_11.htm#20448">&#167;15.11</a>) is applied to each argument in a method or constructor invocation and, except in one case, performs the same conversions that assignment conversion does. Method invocation conversion never causes an exception.
<a name="25151"></a>
<li>Casting conversion <a href="5_4.htm#176921">(&#167;5.4)</a> converts the type of an expression to a type explicitly specified by a cast operator <a href="15_15.htm#238146">(&#167;15.15)</a>. It is more inclusive than assignment or method invocation conversion, allowing any specific conversion other than a string conversion, but certain casts to a reference type may cause an exception at run time.
<a name="25179"></a>
<li>String conversion (<a href="5_4.htm#176921">&#167;5.4</a>, <a href="15_17_1.htm#39990">&#167;15.17.1</a>) allows any type to be converted to type <code>String</code>.
<a name="52885"></a>
<li>Numeric promotion <a href="5_6.htm#26917">(&#167;5.6)</a> brings the operands of a numeric operator to a common type so that an operation can be performed.
</ul><p><a name="27513"></a>
Here are some examples of the various contexts for conversion:<p>
<pre><a name="27514"></a>
class Test {			
<a name="174326"></a>
	public static void main(String[] args) {
<a name="26212"></a>
		// Casting conversion <a href="5_4.htm#176921">(&#167;5.4)</a> of a float literal to
<a name="26213"></a>		// type int. Without the cast operator, this would
<a name="26214"></a>		// be a compile-time error, because this is a
<a name="26218"></a>		// narrowing conversion <a href="5_1_3.htm#175672">(&#167;5.1.3)</a>:
<a name="26219"></a>		int i = (int)12.5f;
<br><a name="26266"></a>
		// String conversion <a href="5_4.htm#176921">(&#167;5.4)</a> of i's int value:
<a name="26220"></a>		System.out.println("(int)12.5f==" + i);
<br><a name="26225"></a>
		// Assignment conversion <a href="5_2.htm#170768">(&#167;5.2)</a> of i's value to type
<a name="26229"></a>		// float. This is a widening conversion <a href="5_1_2.htm#25222">(&#167;5.1.2)</a>:
<a name="26230"></a>		float f = i;
<br><a name="26272"></a>
		// String conversion of f's float value:
<a name="26231"></a>		System.out.println("after float widening: " + f);
<br><a name="26236"></a>
		// Numeric promotion <a href="5_6.htm#26917">(&#167;5.6)</a> of i's value to type
<a name="26237"></a>		// float. This is a binary numeric promotion.
<a name="26238"></a>		// After promotion, the operation is float*float:
<a name="26239"></a>		System.out.print(f);
<a name="26240"></a>		f = f * i;
<br><a name="26284"></a>
		// Two string conversions of i and f:
<a name="26241"></a>		System.out.println("*" + i + "==" + f);
<br><a name="26246"></a>
		// Method invocation conversion <a href="5_3.htm#12687">(&#167;5.3)</a> of f's value
<a name="26247"></a>		// to type double, needed because the method Math.sin
<a name="26248"></a>		// accepts only a double argument:
<a name="26249"></a>		double d = Math.sin(f);
<br><a name="26286"></a>
		// Two string conversions of f and d:
<a name="26250"></a>		System.out.println("Math.sin(" + f + ")==" + d);
<br><a name="26251"></a>	}
<br><a name="26252"></a>}
</pre><p><a name="26253"></a>
which produces the output:
<p><pre><a name="26254"></a>
(int)12.5f==12
<a name="26255"></a>after float widening: 12.0
<a name="26256"></a>12.0*12==144.0
<a name="26202"></a>Math.sin(144.0)==-0.49102159389846934
</pre><p>

</Font></body></html>
