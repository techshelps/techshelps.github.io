<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.6.1 Implementing Finalization</title>
<META NAME=MS-HAID CONTENT="12_6_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>12.6.1	 Implementing Finalization</h3>
<a name="44760"></a>
<p>
<a name="44761"></a>
Every object can be characterized by two attributes: it may be <i>reachable</i>, <i>finalizer-
reachable</i>, or <i>unreachable</i>, and it may also be <i>unfinalized</i>, <i>finalizable</i>, or <i>finalized</i>.
<p><a name="44762"></a>
A <i>reachable</i> object is any object that can be accessed in any potential continuing computation from any live thread. Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable. For example, a compiler or code generator may choose, explicitly or implicitly, to set a variable or parameter that will no longer be used to <code>null</code> to cause the storage for such an object to be potentially reclaimable sooner. A <i>finalizer-reachable</i> object can be reached from some finalizable object through some chain of references, but not from any live thread. An <i>unreachable</i> object cannot be reached by either means.<p>
<a name="44763"></a>
An <i>unfinalized</i> object has never had its finalizer automatically invoked; a <i>finalized</i> object has had its finalizer automatically invoked. A <i>finalizable</i> object has never had its finalizer automatically invoked, but the Java Virtual Machine may eventually automatically invoke its finalizer.<p>
<a name="48746"></a>
The life cycle of an object obeys the following transition diagram, where we abbreviate "finalizer-reachable" as "f-reachable":<p><img src="12anc.gif">
<a name="48817"></a>
<p>
<a name="48818"></a>
When an object is first created (A), it is reachable and unfinalized.<p>
<a name="48565"></a>
As references to an object are discarded during program execution, an object that was reachable may become finalizer-reachable (B, C, D) or unreachable (E, F). (Note that a finalizer-reachable object never becomes unreachable directly; it becomes reachable when the finalizer from which it can be reached is invoked, as explained below.)<p>
<a name="44823"></a>
If the Java Virtual Machine detects that an unfinalized object has become finalizer-reachable or unreachable, it may label the object finalizable (G, H); moreover, if the object was unreachable, it becomes finalizer-reachable (H).<p>
<a name="44824"></a>
If the Java Virtual Machine detects that a finalized object has become unreachable, it may reclaim the storage occupied by the object because the object will never again become reachable (I).<p>
<a name="44825"></a>
At any time, a Java Virtual Machine may take any finalizable object, label it finalized, and then invoke its <code>finalize</code> method in some thread. This causes the object to become finalized and reachable (J, K), and it also may cause other objects that were finalizer-reachable to become reachable again (L, M, N).<p>
<a name="44826"></a>
A finalizable object cannot also be unreachable; it can be reached because its finalizer may eventually be invoked, whereupon the thread running the finalizer will have access to the object, as <code>this</code> <a href="15_7_2.htm#31980">(&#167;15.7.2)</a>. Thus, there are actually only eight possible states for an object.<p>
<a name="44830"></a>
After an object has been finalized, no further action is taken until the automatic storage management determines that it is unreachable. Because of the way that an object progresses from the <i>unfinalized</i> state through the <i>finalizable</i> state to the <i>finalized</i> state, the <code>finalize</code> method is never automatically invoked more than once by a Java Virtual Machine for each object, even if the object is again made reachable after it has been finalized.<p>
<a name="44831"></a>
Explicit invocation of a finalizer ignores the current state of the object and does not change the state of the object from unfinalized or finalizable to finalized.<p>
<a name="44832"></a>
If a class does not override method <code>finalize</code> of class <code>Object</code> (or overrides it in only a trivial way, as described above), then if instances of such as class become unreachable, they may be discarded immediately rather than made to await a second determination that they have become unreachable. This strategy is indicated by the dashed arrow (O) in the transition diagram.<p>
<a name="44833"></a>
Java programmers should also be aware that a finalizer can be automatically invoked, even though it is reachable, during finalization-on-exit <a href="12_9.htm#44857">(&#167;12.9)</a>; moreover, a finalizer can also be invoked explicitly as an ordinary method. Therefore, we recommend that the design of <code>finalize</code> methods be kept simple and that they be programmed defensively, so that they will work in all cases.<p>


</body></html>
