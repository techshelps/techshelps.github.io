<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>14.17 The synchronized Statement</title>
<META NAME=MS-HAID CONTENT="14_17">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>14.17	 The synchronized Statement</h2>
<a name="79287"></a>
<p>
<a name="79291"></a>
<meta name="MS-HKWD" content="synchronized">
A <code>synchronized</code> statement acquires a mutual-exclusion lock <a href="17_13.htm#28460">(&#167;17.13)</a> on behalf 
of the executing thread, executes a block, then releases the lock. While the executing thread owns the lock, no other thread may acquire the lock.
<p><pre>
<i>SynchronizedStatement:<br>
	<code>synchronized ( </code><i>Expression</i><code> ) </code><i>Block
</i></i></pre><p><a name="217233"></a>
The type of <i>Expression</i> must be a reference type, or a compile-time error occurs. 
<p><a name="217245"></a>
A <code>synchronized</code> statement is executed by first evaluating the <i>Expression</i>.<p>
<a name="236514"></a>
If evaluation of the <i>Expression</i> completes abruptly for some reason, then the <code>synchronized</code> statement completes abruptly for the same reason.<p>
<a name="236515"></a>
Otherwise, if the value of the <i>Expression</i> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="79295"></a>
Otherwise, let the non-<code>null</code> value of the <i>Expression</i> be <i>V</i>. The executing thread locks the lock associated with <i>V</i>. Then the <i>Block </i>is executed. If execution of the <i>Block</i> completes normally, then the lock is unlocked and the <code>synchronized</code> statement completes normally. If execution of the <i>Block</i> completes abruptly for any reason, then the lock is unlocked and the <code>synchronized</code> statement then completes abruptly for the same reason.<p>
<a name="79305"></a>
Acquiring the lock associated with an object does not of itself prevent other threads from accessing fields of the object or invoking unsynchronized methods on the object. Other threads can also use <code>synchronized</code> methods or the <code>synchronized</code> &#32;statement in a conventional manner to achieve mutual exclusion.<p>
<a name="79306"></a>
The locks acquired by <code>synchronized</code> statements are the same as the locks that are acquired implicitly by <code>synchronized</code> methods; see <a href="8_4_3.htm#55408">&#167;8.4.3.5</a>. A single thread may hold a lock more than once. The example:<p>
<pre><a name="237226"></a>
class Test {
<a name="237227"></a>	public static void main(String[] args) {
<a name="237228"></a>		Test t = new Test();
<a name="22894"></a>		synchronized(t) {
<a name="22895"></a>			synchronized(t) {
<a name="22896"></a>				System.out.println("made it!");
<a name="22897"></a>			}
<a name="22898"></a>		}
<a name="22899"></a>	}
<a name="22900"></a>}
</pre><p><a name="22901"></a>
prints:
<p><pre><a name="22902"></a>made it!
</pre><p><a name="22903"></a>
This example would deadlock if a single thread were not permitted to lock a lock 
more than once.
<p>

</body></html>
