<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.14 Unary Operators</title>
<META NAME=MS-HAID CONTENT="15_14">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>15.14	 Unary Operators</h2>
<a name="4990"></a>
<p>
<a name="31520"></a>
The <i>unary operators</i> include <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, and cast operators. Expressions 
with unary operators group right-to-left, so that <code>-~x</code> means the same as <code>-(~x)</code>.
<p><pre>
<i>UnaryExpression<code>:<br>
	</code>PreIncrementExpression<br>
<code>	</code>PreDecrementExpression<br>
<code>	+ </code>UnaryExpression<br>
	<code>- </code>UnaryExpression<br>
	UnaryExpressionNotPlusMinus
</i>
<i>PreIncrementExpression:<br>
<code>	++ </code>UnaryExpression
</i>
<i>PreDecrementExpression:<br>
	<code>-- </code>UnaryExpression
</i>
<i>UnaryExpressionNotPlusMinus<code>:<br>
	</code>PostfixExpression<br>
<code>	~ </code>UnaryExpression<br>
	<code>! </code>UnaryExpression<br>
<code>	</code>CastExpression
</i></pre><p><a name="29719"></a>
The following productions from <a href="15_15.htm#238146">&#167;15.15</a> are repeated here for convenience:
<p><pre>
<i>CastExpression:<br>
<code>	( </code><i>PrimitiveType</i><code> ) </code><i>UnaryExpression<br>
</i><code>	( </code>ReferenceType<code> )&#32;</code>U<i>naryExpressionNotPlusMinus
</i></i></pre><p><a name="22479"></a>
This portion of the Java grammar contains some tricks to avoid two potential syntactic ambiguities.<p>
<a name="22502"></a>
The first potential ambiguity would arise in expressions such as <code>(p)+q</code>, which looks, to a C or C++ programmer, as though it could be either be a cast to type <code>p</code> of a unary <code>+</code> operating on <code>q</code>, or a binary addition of two quantities <code>p</code> and <code>q</code>. In C and C++, the parser handles this problem by performing a limited amount of semantic analysis as it parses, so that it knows whether <code>p</code> is the name of a type or the name of a variable.<p>
<a name="39495"></a>
Java takes a different approach. The result of the <code>+</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a cast of a unary expression. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a binary arithmetic operation. Similar remarks apply to the <code>-</code> operator. The grammar shown above splits <i>CastExpression</i> into two cases to make this distinction. The nonterminal <i>UnaryExpression </i>includes all unary operator, but the nonterminal <i>UnaryExpressionNotPlusMinus</i> excludes uses of all unary operators that could also be binary operators, which in Java are <code>+</code> and <code>-</code>.<p>
<a name="39551"></a>
The second potential ambiguity is that the expression <code>(p)++</code> could, to a C or C++ programmer, appear to be either a postfix increment of a parenthesized expression or the beginning of a cast, for example, in <code>(p)++q</code>. As before, parsers for C and C++ know whether <code>p</code> is the name of a type or the name of a variable. But a parser using only one-token lookahead and no semantic analysis during the parse would not be able to tell, when <code>++</code> is the lookahead token, whether <code>(p)</code> should be considered a <i>Primary</i> expression or left alone for later consideration as part of a <i>CastExpression</i>.<p>
<a name="39554"></a>
In Java, the result of the <code>++</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a cast of a prefix increment expression, and there had better be an operand such as <code>q</code> following the <code>++</code>. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a postfix increment of <code>p</code>. Similar remarks apply to the <code>--</code> operator. The nonterminal <i>UnaryExpressionNotPlusMinus</i> therefore also excludes uses of the prefix operators <code>++</code> and <code>--</code>.<p>


</body></html>
