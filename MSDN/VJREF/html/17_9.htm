<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>17.9 Discussion</title>
<META NAME=MS-HAID CONTENT="17_9">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>17.9	 Discussion</h2>
<a name="28341"></a>
<p>
<a name="28342"></a>
Any association between locks and variables is purely conventional. Locking any 
lock conceptually flushes <i>all</i> variables from a thread's working memory, and 
unlocking any lock forces the writing out to main memory of <i>all</i> variables that the 
thread has assigned. That a lock may be associated with a particular object or a 
class is purely a convention. In some applications, it may be appropriate always to 
lock an object before accessing any of its instance variables, for example; synchronized methods are a convenient way to follow this convention. In other applications, it may suffice to use a single lock to synchronize access to a large 
collection of objects.
<p><a name="28343"></a>
If a thread uses a particular shared variable only after locking a particular lock and before the corresponding unlocking of that same lock, then the thread will read the shared value of that variable from main memory after the <i>lock</i> action, if necessary, and will copy back to main memory the value most recently assigned to that variable before the <i>unlock</i> action. This, in conjunction with the mutual exclusion rules for locks, suffices to guarantee that values are correctly transmitted from one thread to another through shared variables.<p>
<a name="28344"></a>
The rules for <code>volatile</code> variables effectively require that main memory be touched exactly once for each <i>use</i> or <i>assign</i> of a <code>volatile</code> variable by a thread, and that main memory be touched in exactly the order dictated by the thread execution semantics. However, such memory actions are not ordered with respect to <i>read</i> and <i>write</i> actions on nonvolatile variables.<p>


</body></html>
