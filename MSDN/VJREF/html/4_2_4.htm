<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.2.4 Floating-Point Operations</title>
<META NAME=MS-HAID CONTENT="4_2_4">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>4.2.4	 Floating-Point Operations</h3>
<a name="9249"></a>
<p>
<a name="9981"></a>
Java provides a number of operators that act on floating-point values:
<p><ul><a name="52058"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="52062"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="15_19_1.htm#153654">(&#167;15.19.1)</a>
<a name="52066"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="15_20_1.htm#5198">(&#167;15.20.1)</a>
</ul>
<a name="52069"></a>
<li>The numerical operators, which result in a value of type <code>float</code> or <code>double</code>:
<ul>
<a name="52076"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="15_14_3.htm#24924">&#167;15.14.3</a>, <a href="15_14_4.htm#236345">&#167;15.14.4</a>)
<a name="24115"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="15_16.htm#239829">(&#167;15.16)</a>
<a name="24119"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="15_17_2.htm#13510">(&#167;15.17.2)</a>
<a name="24126"></a>
<li>The increment operator <code>++</code>, both prefix <a href="15_14_1.htm#39547">(&#167;15.14.1)</a> and postfix <a href="15_13_2.htm#39438">(&#167;15.13.2)</a>
<a name="24107"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="15_14_2.htm#239136">(&#167;15.14.2)</a> and postfix <a href="15_13_3.htm#4987">(&#167;15.13.3)</a>
</ul>
<a name="19446"></a>
<li>The conditional operator <code>? :</code> <a href="15_24.htm#5257">(&#167;15.24)</a>
<a name="11998"></a>
<li>The cast operator, which can convert from a floating-point value to a value of any specified numeric type (<a href="5_4.htm#176921">&#167;5.4</a>, <a href="15_15.htm#238146">&#167;15.15</a>)
<a name="21842"></a>
<li>The string concatenation operator <code>+</code> <a href="15_17_1.htm#39990">(&#167;15.17.1)</a>, which, when given a <code>String</code> operand and a floating-point operand, will convert the floating-point operand to a <code>String</code> representing its value in decimal form (without information loss), and then produce a newly created <code>String</code> by concatenating the two strings
</ul><p><a name="12009"></a>
Other useful constructors, methods, and constants are predefined in the classes 
<code>Float</code> <a href="20_9.htm#14394">(&#167;20.9)</a>, <code>Double</code> <a href="20_10.htm#14390">(&#167;20.10)</a>, and <code>Math</code> <a href="20_11.htm#15518">(&#167;20.11)</a>.
<p><a name="12005"></a>
If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.<p>
<a name="51262"></a>
If at least one of the operands to a numerical operator is of type <code>double</code>, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>double</code>. (If the other operand is not a <code>double</code>, it is first widened to type <code>double</code> by numeric promotion <a href="5_6.htm#26917">(&#167;5.6)</a>.) Otherwise, the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>float. </code>If the other operand is not a <code>float</code>, it is first widened to type <code>float</code> by numeric promotion.<p>
<a name="9265"></a>
Operators on floating-point numbers behave exactly as specified by IEEE 754. In particular, Java requires support of IEEE 754 <i>denormalized</i> floating-point numbers and <i>gradual underflow</i>, which make it easier to prove desirable properties of particular numerical algorithms. Floating-point operations in Java do not "flush to zero" if the calculated result is a denormalized number.<p>
<a name="9274"></a>
Java requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision. <i>Inexact</i> results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one with its least significant bit zero is chosen. This is the IEEE 754 standard's default rounding mode known as <i>round to nearest</i>.<p>
<a name="10346"></a>
Java uses <i>round toward zero</i> when converting a floating value to an integer <a href="5_1_3.htm#175672">(&#167;5.1.3)</a>, which acts, in this case, as though the number were truncated, discarding the mantissa bits. Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely precise result.<p>
<a name="9290"></a>
Java floating-point operators produce no exceptions <a href="chap11.htm">(&#167;11)</a>. An operation that overflows produces a signed infinity, an operation that underflows produces a signed zero, and an operation that has no mathematically definite result produces NaN. All numeric operations with NaN as an operand produce NaN as a result. As has already been described, NaN is unordered, so a numeric comparison operation involving one or two NaNs returns <code>false</code> and any <code>!=</code> comparison involving NaN returns <code>true</code>, including <code>x!=x</code> when <code>x</code> is NaN.<p>
<a name="9291"></a>
The example program:<p>
<pre><a name="9292"></a>
class Test {
<a name="45603"></a>
	public static void main(String[] args) {
<a name="49672"></a>
		// An example of overflow:
<a name="49673"></a>		double d = 1e308;
<a name="86539"></a>		System.out.print("overflow produces infinity: ");
<a name="86540"></a>		System.out.println(d + "*10==" + d*10);
<a name="86541"></a>
		// An example of gradual underflow:
<a name="49678"></a>		d = 1e-305 * Math.PI;
<a name="85624"></a>		System.out.print("gradual underflow: " + d + "\n &#32; &#32; &#32;");
<a name="49679"></a>		for (int i = 0; i &lt; 4; i++)
<a name="49680"></a>			System.out.print(" " + (d /= 100000));
<a name="49755"></a>		System.out.println();
<a name="49756"></a>
		// An example of NaN:
<a name="49757"></a>		System.out.print("0.0/0.0 is Not-a-Number: ");
<a name="49685"></a>		d = 0.0/0.0;
<a name="85896"></a>		System.out.println(d);
<a name="49698"></a>
		// An example of inexact results and rounding:
<a name="49701"></a>		System.out.print("inexact results with float:");
<a name="49702"></a>		for (int i = 0; i &lt; 100; i++) {
<a name="49703"></a>			float z = 1.0f / i;
<a name="49704"></a>			if (z * i != 1.0f)
<a name="49705"></a>				System.out.print(" " + i);
<a name="49706"></a>		}
<a name="20012"></a>		System.out.println();
<a name="85847"></a>
		// Another example of inexact results and rounding:
<a name="49707"></a>		System.out.print("inexact results with double:");
<a name="49708"></a>		for (int i = 0; i &lt; 100; i++) {
<a name="49709"></a>			double z = 1.0 / i;
<a name="49710"></a>			if (z * i != 1.0)
<a name="49711"></a>				System.out.print(" " + i);
<a name="49712"></a>		}
<a name="49713"></a>		System.out.println();
<a name="10212"></a>
		// An example of cast to integer rounding:
<a name="49718"></a>		System.out.print("cast to int rounds toward 0: ");
<a name="49719"></a>		d = 12345.6;
<a name="49720"></a>		System.out.println((int)d + " " + (int)(-d));
<a name="49721"></a>	}
<a name="49722"></a>}
</pre><p><a name="23297"></a>
produces the output:
<p><pre><a name="23314"></a>
overflow produces infinity: 1.0e+308*10==Infinity
<a name="23315"></a>gradual underflow: 3.141592653589793E-305
<a name="85613"></a>	3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
<a name="23316"></a>0.0/0.0 is Not-a-Number: NaN
<a name="23317"></a>inexact results with float: 0 41 47 55 61 82 83 94 97
<a name="23318"></a>inexact results with double: 0 49 98
<a name="23303"></a>cast to int rounds toward 0: 12345 -12345
</pre><p><a name="22309"></a>
This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.<p>
<a name="11717"></a>
The inexact results when <code>i</code> is <code>0</code> involve division by zero, so that <code>z</code> becomes positive infinity, and <code>z</code> <code>*</code> <code>0</code> is NaN, which is not equal to <code>1.0</code>.<p>


</body></html>
