<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.1.2 Widening Primitive Conversions</title>
<META NAME=MS-HAID CONTENT="5_1_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>5.1.2	 Widening Primitive Conversions</h3>
<a name="25222"></a>
<p>
<a name="25224"></a>
The following 19 specific conversions on primitive types are called the <i>widening 
primitive conversions</i>:
<p><ul><a name="25225"></a>
<li><code>byte</code> to <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25226"></a>
<li><code>short</code> to <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25227"></a>
<li><code>char</code> to <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25228"></a>
<li><code>int</code> to <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25229"></a>
<li><code>long</code> to <code>float</code> or <code>double</code>
<a name="25230"></a>
<li><code>float</code> to <code>double</code>
</ul><p><a name="25231"></a>
Widening primitive conversions do not lose information about the overall magnitude of a numeric value. Indeed, conversions widening from an integral type to another integral type and from <code>float</code> to <code>double</code> do not lose any information at all; the numeric value is preserved exactly. Conversion of an <code>int</code> or a <code>long</code> value to <code>float</code>, or of a <code>long</code> value to <code>double</code>, may result in <i>loss of precision</i>-that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode <a href="4_2_4.htm#9249">(&#167;4.2.4)</a>.<p>
<a name="25237"></a>
A widening conversion of a signed integer value to an integral type <i>T</i><em></em> simply sign-extends the two's-complement representation of the integer value to fill the wider format. A widening conversion of a character to an integral type <i>T</i> zero-extends the representation of the character value to fill the wider format.<p>
<a name="25238"></a>
Despite the fact that loss of precision may occur, widening conversions among primitive types never result in a run-time exception <a href="chap11.htm">(&#167;11)</a>.<p>
<a name="25242"></a>
Here is an example of a widening conversion that loses precision:<p>
<pre><a name="25243"></a>
class Test {
<a name="25244"></a>	public static void main(String[] args) {
<a name="25245"></a>		int big = 1234567890;
<a name="25246"></a>		float approx = big;
<a name="25247"></a>		System.out.println(big - (int)approx);
<a name="25248"></a>	}
<a name="25249"></a>}
</pre><p><a name="25250"></a>
which prints:
<p><pre><a name="25251"></a>-46
</pre><p><a name="175670"></a>
thus indicating that information was lost during the conversion from type <code>int</code> to 
type <code>float</code> because values of type <code>float</code> are not precise to nine significant digits.
<p>

</body></html>
