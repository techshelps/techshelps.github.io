<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<A NAME="_top_"></A>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interface CharacterIterator</TITLE>
<H1>
  Interface java.text.CharacterIterator
</H1>
<A HREF="java.text.CharacterIterator001.html">Interface Members</A> | 
  <A HREF="Package-java.text.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>
<P><B> public interface <B>CharacterIterator</B>
  <BR>
 extends <A HREF="java.lang.Cloneable.html">Cloneable</A>
<BR>
</B>
<P>

This interface defines a protocol for bidirectional iteration over text.
 The iterator iterates over a bounded sequence of characters.  Characters
 are indexed with values beginning with the value returned by getBeginIndex and
 continuing through the value returned by getEndIndex()-1.  The index of the
 current character can be retrieved by calling getIndex.  Calling setIndex
 will move the iterator to a new position within the sequence of characters.
 If at any time the iterator's current index moves outside the range of
 getBeginIndex and getEndIndex, previous() and next() will return DONE, signaling that
 the iterator has reached the end of the sequence.
 <P>Examples:<P>
 Traverse the text from start to finish
 </FONT><PRE>
 public void traverseForward(CharacterIterator iter) {
     for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {
         processChar(c);
     }
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 Traverse the text backwards, from end to start
 </FONT><PRE>
 public void traverseBackward(CharacterIterator iter) {
     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.prev()) {
         processChar(c);
     }
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 Traverse both forward and backward from a given position in the text.
 Calls to notBoundary() in this example represents some
 additional stopping criteria.
 </FONT><PRE>
 public void traverseOut(CharacterIterator iter, int pos) {
     for (char c = iter.setIndex(pos);
          c != CharacterIterator.DONE && notBoundary(c);
          c = iter.next()) {}
 int end = iter.getIndex();
 for (char c = iter.setIndex(pos);
     c != CharacterIterator.DONE && notBoundary(c);
     c = iter.prev()) {}
 int start = iter.getIndex();
 processSection(start,end);
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<P>
<DL>
    <DT> <B>See Also:</B>
    <DD> <A HREF="java.text.StringCharacterIterator.html">StringCharacterIterator</A>
</DL>
<HR>

</BODY>
</HTML>
