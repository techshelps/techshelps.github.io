<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.3.1 Field Modifiers</title>
<META NAME=MS-HAID CONTENT="8_3_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>8.3.1	 Field Modifiers</h3>
<a name="78091"></a>
<p>
<pre>
<i><i>FieldModifiers:<br>
	FieldModifier<br>
	FieldModifiers</i><code> </code><i>FieldModifier
</i></i>
<i><i>FieldModifier: one of<br>
	</i><code>public&#32;protected&#32;private<br>
	final&#32;static&#32;transient&#32;volatile
</code></i></pre><p><a name="35964"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="6_6.htm#33916">&#167;6.6</a>. A 
compile-time error occurs if the same modifier appears more than once in a field 
declaration, or if a field declaration has more than one of the access modifiers 
<code>public</code>, <code>protected</code>, and <code>private</code>. If two or more (distinct) field modifiers 
appear in a field declaration, it is customary, though not required, that they appear 
in the order consistent with that shown above in the production for <i>FieldModifier</i>.
<p><a name="37544"></a>
<h4>8.3.1.1	 static Fields</h4>
<p>
<a name="230789"></a>
<meta name="MS-HKWD" content="static">
If a field is declared <code>static</code>, there exists exactly one incarnation of the field, no 
matter how many instances (possibly zero) of the class may eventually be created. 
A <code>static</code> field, sometimes called a <i>class variable</i>, is incarnated when the class is 
initialized <a href="12_4.htm#44557">(&#167;12.4)</a>.
<p><a name="230793"></a>
A field that is not declared <code>static</code> (sometimes called a non-<code>static</code> field) is called an <i>instance variable</i>. Whenever a new instance of a class is created, a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses.<p>
<a name="38985"></a>
The example program:<p>
<pre><a name="37567"></a>
class Point {
<a name="37568"></a>	int x, y, useCount;
<a name="37569"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="37572"></a>	final static Point origin = new Point(0, 0);
<a name="37573"></a>}
<br><a name="37574"></a>
class Test {
<a name="37575"></a>	public static void main(String[] args) {
<a name="37576"></a>		Point p = new Point(1,1);
<a name="37577"></a>		Point q = new Point(2,2);
<a name="37578"></a>		p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++;
<a name="37579"></a>		System.out.println("(" + q.x + "," + q.y + ")");
<a name="37615"></a>		System.out.println(q.useCount);
<a name="37581"></a>		System.out.println(q.origin == Point.origin);
<a name="37662"></a>		System.out.println(q.origin.useCount);
<a name="37582"></a>	}
<a name="37583"></a>}
</pre><p><a name="37584"></a>
prints:
<p><pre><a name="37585"></a>
(2,2)
<a name="37618"></a>0
<a name="37587"></a>true
<a name="37667"></a>1
</pre><p><a name="37588"></a>
showing that changing the fields <code>x</code>, <code>y</code>, and <code>useCount</code> of <code>p</code> does not affect the fields 
of <code>q</code>, because these fields are instance variables in distinct objects. In this example, 
the class variable <code>origin</code> of the class <code>Point</code> is referenced both using the class 
name as a qualifier, in <code>Point.origin</code>, and using variables of the class type in 
field access expressions <a href="15_10.htm#41267">(&#167;15.10)</a>, as in <code>p.origin</code> and <code>q.origin</code>. These two ways 
of accessing the <code>origin</code> class variable access the same object, evidenced by the 
fact that the value of the reference equality expression <a href="15_20_3.htm#236163">(&#167;15.20.3)</a>:
<p><pre><a name="227823"></a><code>q.origin==Point.origin
</code></pre><p><a name="227825"></a>
is <code>true</code>. Further evidence is that the incrementation:
<p><pre><a name="37670"></a>p.origin.useCount++;
</pre><p><a name="37671"></a>
causes the value of q.origin.useCount to be <code>1</code>; this is so because <code>p.origin</code> and 
<code>q.origin</code> refer to the same variable.
<p><a name="35962"></a>
<h4>8.3.1.2	 final Fields</h4>
<p>
<a name="14727"></a>
<meta name="MS-HKWD" content="final">
A field can be declared <code>final</code>, in which case its declarator must include a variable 
initializer or a compile-time error occurs. Both class and instance variables 
(<code>static</code> and non-<code>static</code> fields) may be declared <code>final</code>.
<p><a name="37504"></a>
Any attempt to assign to a <code>final</code> field results in a compile-time error. Therefore, once a <code>final</code> field has been initialized, it always contains the same value. If a <code>final</code> field holds a reference to an object, then the state of the object may be changed by operations on the object, but the field will always refer to the same object. This applies also to arrays, because arrays are objects; if a <code>final</code> field holds a reference to an array, then the components of the array may be changed by operations on the array, but the field will always refer to the same array.<p>
<a name="14728"></a>
Declaring a field <code>final</code> can serve as useful documentation that its value will not change, can help to avoid programming errors, and can make it easier for a compiler to generate efficient code.<p>
<a name="37005"></a>
In the example:<p>
<pre><a name="37006"></a>
class Point {
<a name="37053"></a>	int x, y;
<a name="37066"></a>	int useCount;
<a name="37049"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="37058"></a>	final static Point origin = new Point(0, 0);
<a name="37056"></a>}
</pre><p><a name="37059"></a>
the class <code>Point</code> declares a <code>final</code> class variable <code>origin</code>. The <code>origin</code> variable 
holds a reference to an object that is an instance of class <code>Point</code> whose coordinates 
are (0, 0). The value of the variable <code>Point.origin</code> can never change, so it always 
refers to the same <code>Point</code> object, the one created by its initializer. However, an 
operation on this <code>Point</code> object might change its state-for example, modifying its 
<code>useCount</code> or even, misleadingly, its <code>x</code> or <code>y</code> coordinate.
<p><a name="78119"></a>
<h4>8.3.1.3	 transient Fields</h4>
<p>
<a name="37020"></a>
<meta name="MS-HKWD" content="transient">
Variables may be marked <code>transient</code> to indicate that they are not part of the persistent state of an object. If an instance of the class <code>Point</code>:
<p><pre><a name="14770"></a>
class Point {
<a name="14771"></a>	int x, y;
<a name="14772"></a>	transient float rho, theta;
<a name="14773"></a>}
</pre><p><a name="14775"></a>
were saved to persistent storage by a system service, then only the fields <code>x</code> and <code>y</code> 
would be saved. This specification does not yet specify details of such services; 
we intend to provide them in a future version of this specification.
<p><a name="36930"></a>
<h4>8.3.1.4	 volatile Fields</h4>
<p>
<a name="37715"></a>
<meta name="MS-HKWD" content="volatile">
As described in <a href="chap17.htm">&#167;17</a>, the Java language allows threads that access shared variables 
to keep private working copies of the variables; this allows a more efficient implementation of multiple threads. These working copies need be reconciled with the 
master copies in the shared main memory only at prescribed synchronization 
points, namely when objects are locked or unlocked. As a rule, to ensure that 
shared variables are consistently and reliably updated, a thread should ensure that 
it has exclusive use of such variables by obtaining a lock that, conventionally, 
enforces mutual exclusion for those shared variables.
<p><a name="37727"></a>
Java provides a second mechanism that is more convenient for some purposes: a field may be declared <code>volatile</code>, in which case a thread must reconcile its working copy of the field with the master copy every time it accesses the variable. Moreover, operations on the master copies of one or more volatile variables on behalf of a thread are performed by the main memory in exactly the order that the thread requested.<p>
<a name="14790"></a>
If, in the following example, one thread repeatedly calls the method <code>one</code> (but no more than <code>Integer.MAX_VALUE</code> <a href="20_7.htm#2391">(&#167;20.7.2)</a> times in all), and another thread repeatedly calls the method <code>two</code>:<p>
<pre><a name="14792"></a>
class Test {
<br><a name="14793"></a>	static int i = 0, j = 0;
<br><a name="14794"></a>
	static void one() { i++; j++; }
<a name="14796"></a>
	static void two() {
<a name="14797"></a>		System.out.println("i=" + i + " j=" + j);
<a name="14801"></a>	}
<br><a name="14802"></a>}
</pre><p><a name="14803"></a>
then method <code>two</code> could occasionally print a value for <code>j</code> that is greater than the 
value of <code>i</code>, because the example includes no synchronization and, under the rules 
explained in <a href="chap17.htm">&#167;17</a>, the shared values of <code>i</code> and <code>j</code> might be updated out of order.
<p><a name="37738"></a>
One way to prevent this out-or-order behavior would be to declare methods <code>one</code> and <code>two</code> to be <code>synchronized</code> <a href="8_4_3.htm#55408">(&#167;8.4.3.5)</a>:<p>
<pre><a name="37768"></a>
class Test {
<br><a name="37769"></a>	static int i = 0, j = 0;
<br><a name="37770"></a>
	static synchronized void one() { i++; j++; }
<a name="37771"></a>
	static synchronized void two() {
<a name="37772"></a>		System.out.println("i=" + i + " j=" + j);
<a name="37773"></a>	}
<br><a name="37774"></a>}
</pre><p><a name="37777"></a>
This prevents method <code>one</code> and method <code>two</code> from being executed concurrently, and 
furthermore guarantees that the shared values of <code>i</code> and <code>j</code> are both updated before 
method <code>one</code> returns. Therefore method <code>two</code> never observes a value for <code>j</code> greater 
than that for <code>i</code>; indeed, it always observes the same value for <code>i</code> and <code>j</code>.
<p><a name="37789"></a>
Another approach would be to declare <code>i</code> and <code>j</code> to be <code>volatile</code>:<p>
<pre><a name="37793"></a>
class Test {
<br><a name="37794"></a>	static volatile int i = 0, j = 0;
<br><a name="37795"></a>
	static void one() { i++; j++; }
<a name="37796"></a>
	static void two() {
<a name="37797"></a>		System.out.println("i=" + i + " j=" + j);
<a name="37798"></a>	}
<br><a name="37799"></a>}
</pre><p><a name="37800"></a>
This allows method <code>one</code> and method <code>two</code> to be executed concurrently, but guarantees that accesses to the shared values for <code>i</code> and <code>j</code> occur exactly as many times, 
and in exactly the same order, as they appear to occur during execution of the program text by each thread. Therefore, method <code>two</code> never observes a value for <code>j</code> 
greater than that for <code>i</code>, because each update to <code>i</code> must be reflected in the shared 
value for <code>i</code> before the update to <code>j</code> occurs. It is possible, however, that any given 
invocation of method <code>two</code> might observe a value for <code>j</code> that is much greater than the 
value observed for <code>i</code>, because method <code>one</code> might be executed many times between 
the moment when method <code>two</code> fetches the value of <code>i</code> and the moment when 
method <code>two</code> fetches the value of <code>j</code>.
<p><a name="14791"></a>
See <a href="chap17.htm">&#167;17</a> for more discussion and examples.<p>
<a name="24509"></a>
A compile-time error occurs if a <code>final</code> variable is also declared <code>volatile</code>.<p>


</Font></body></html>
