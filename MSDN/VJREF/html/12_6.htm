<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.6 Finalization of Class Instances</title>
<META NAME=MS-HAID CONTENT="12_6">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>12.6	 Finalization of Class Instances</h2>
<a name="44748"></a>
<p>
<a name="44752"></a>
The class <code>Object</code> has a <code>protected</code> method called <code>finalize</code> &#32;<a href="20_1.htm#23198">(&#167;20.1.11)</a>; this 
method can be overridden by other classes. The particular definition of <code>finalize</code> 
that can be invoked for an object is called the <i>finalizer</i> of that object. Before the 
storage for an object is reclaimed by the garbage collector, the Java Virtual 
Machine will invoke the finalizer<i> </i>of that object.
<p><a name="44753"></a>
Finalizers provide a chance to free up resources (such as file descriptors or operating system graphics contexts) that cannot be freed automatically by an automatic storage manager. In such situations, simply reclaiming the memory used by an object would not guarantee that the resources it held would be reclaimed.<p>
<a name="44754"></a>
The Java language does not specify how soon a finalizer will be invoked, except to say that it will happen before the storage for the object is reused. Also, the Java language does not specify which thread will invoke the finalizer for any given object. If an uncaught exception is thrown during the finalization, the exception is ignored and finalization of that object terminates.<p>
<a name="44755"></a>
The <code>finalize</code> method declared in class <code>Object</code> takes no action. However, the fact that class <code>Object</code> declares a <code>finalize</code> method means that the <code>finalize</code> method for any class can always invoke the <code>finalize</code> method for its superclass, which is usually good practice. (Unlike constructors, finalizers do not automatically invoke the finalizer for the superclass; such an invocation must be coded explicitly.)<p>
<a name="44756"></a>
For efficiency, an implementation may keep track of classes that do not override the <code>finalize</code> method of class <code>Object</code>, or override it in a trivial way, such as:<p>
<pre><a name="44757"></a>protected void finalize() throws Throwable {<br>
	super.finalize();<br>
}
</pre><p><a name="44758"></a>
We encourage implementations to treat such objects as having a finalizer that is 
not overridden, and to finalize them more efficiently, as described in <a href="12_6_1.htm#44760">&#167;12.6.1</a>.
<p><a name="44759"></a>
A finalizer may be invoked explicitly, just like any other method.<p>


</body></html>
