<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.4.3 Method Modifiers</title>
<META NAME=MS-HAID CONTENT="8_4_3">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>8.4.3	 Method Modifiers</h3>
<a name="78188"></a>
<p>
<pre>
<i><i>MethodModifiers:<br>
	MethodModifier<br>
	MethodModifiers</i><code> </code><i>MethodModifier
</i></i>
<i><i>MethodModifier: one of<br>
	</i><code>public&#32;protected&#32;private<br>
	abstract&#32;static&#32;final&#32;synchronized&#32;native
</code></i></pre><p><a name="35992"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="6_6.htm#33916">&#167;6.6</a>. 
A &#32;compile-time error occurs if the same modifier appears more than once in a 
method declaration, or if a method declaration has more than one of the access 
modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. A compile-time error occurs if a 
method declaration that contains the keyword <code>abstract</code> also contains any one of 
the keywords <code>private</code>, <code>static</code>, <code>final</code>, <code>native</code>, or <code>synchronized</code>.
<p><a name="38745"></a>
If two or more method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <i>MethodModifier</i>.<p>
<a name="34484"></a>
<h4>8.4.3.1	 abstract Methods</h4>
<p>
<a name="38742"></a>
<meta name="MS-HKWD" content="abstract">
An <code>abstract</code> method declaration introduces the method as a member, providing 
its signature (name and number and type of parameters), return type, and <code>throws</code> 
clause (if any), but does not provide an implementation. The declaration of an 
<code>abstract</code> method <i>m</i> must appear within an <code>abstract</code> class (call it <i>A</i><i></i>); otherwise a 
compile-time error results. Every subclass of <i>A</i><i> </i>that is not <code>abstract</code> must provide 
an implementation for <i>m</i>, or a compile-time error occurs. More precisely, for every 
subclass <i>C</i> of the <code>abstract</code> class <i>A</i><i></i>, if <i>C</i><i></i> is not <code>abstract</code>, then there must be some 
class <i>B</i><i></i> such that all of the following are true:
<p><ul><a name="78209"></a>
<li><i>B</i> is a superclass of <i>C</i><i> </i>or is <i>C</i><i></i> itself.
<a name="78210"></a>
<li><i>B</i> is a subclass of <i>A</i><i></i>.
<a name="78212"></a>
<li><i>B</i> provides a declaration of the method <i>m</i> that is not <code>abstract</code>, and this declaration is inherited by <i>C</i>, thereby providing an implementation of method <i>m</i> that is visible to <i>C</i><i></i>.
</ul><p><a name="227750"></a>
If there is no such class <i>B</i>, then<i></i> a compile-time error occurs.
<p><a name="230064"></a>
It is a compile-time error for a <code>private</code> method to be declared <code>abstract</code>. It would be impossible for a subclass to implement a <code>private</code> <code>abstract</code> method, because <code>private</code> methods are not visible to subclasses; therefore such a method could never be used.<p>
<a name="230065"></a>
It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="230073"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="36710"></a>
An <code>abstract</code> class can override an <code>abstract</code> method by providing another <code>abstract</code> method declaration. This can provide a place to put a documentation comment <a href="chap18.htm">(&#167;18)</a>, or to declare that the set of checked exceptions <a href="11_2.htm#44121">(&#167;11.2)</a> that can be thrown by that method, when it is implemented by its subclasses, is to be more limited. For example, consider this code:<p>
<pre><a name="36711"></a>
class BufferEmpty extends Exception {
<a name="29450"></a>	BufferEmpty() { super(); }
<a name="29451"></a>	BufferEmpty(String s) { super(s); }
<a name="29452"></a>}
<br><a name="25657"></a>
class BufferError extends Exception {
<a name="29453"></a>	BufferError() { super(); }
<a name="29454"></a>	BufferError(String s) { super(s); }
<a name="29455"></a>}
<br><a name="25660"></a>
public interface Buffer {
<a name="36714"></a>	char get() throws BufferEmpty, BufferError;
<a name="36715"></a>}
<br><a name="36716"></a>
public abstract class InfiniteBuffer implements Buffer {
<a name="36717"></a>	abstract char get() throws BufferError;
<a name="36718"></a>}
</pre><p><a name="11245"></a>
The overriding declaration of method <code>get</code> in class <code>InfiniteBuffer</code> states that 
method <code>get</code> in any subclass of <code>InfiniteBuffer</code> never throws a <code>BufferEmpty</code> 
exception, putatively because it generates the data in the buffer, and thus can never 
run out of data.
<p><a name="14765"></a>
An instance method that is not <code>abstract</code> can be overridden by an <code>abstract</code> method. For example, we can declare an <code>abstract</code> class <code>Point</code> that requires its subclasses to implement <code>toString</code> if they are to be complete, instantiable classes:<p>
<pre><a name="14908"></a>
abstract class Point {
<a name="14909"></a>	int x, y;
<a name="14910"></a>	public abstract String toString();
<a name="14911"></a>}
</pre><p><a name="14912"></a>
This <code>abstract</code> declaration of <code>toString</code> overrides the non-<code>abstract</code> <code>toString</code> 
method of class <code>Object</code> <a href="20_1.htm#1152">(&#167;20.1.2)</a>. (Class <code>Object</code> is the implicit direct superclass 
of class <code>Point</code>.) Adding the code:
<p><pre><a name="38907"></a>
class ColoredPoint extends Point {
<a name="38908"></a>	int color;
<a name="38909"></a>	public String toString() {
<a name="38919"></a>		return super.toString() + ": color " + color; // error
<a name="38920"></a>	}
<a name="38910"></a>}
</pre><p><a name="38923"></a>
results in a compile-time error because the invocation <code>super.toString()</code> refers 
to method <code>toString</code> in class <code>Point</code>, which is <code>abstract</code> and therefore cannot be 
invoked. Method <code>toString</code> of class <code>Object</code> can be made available to class 
<code>ColoredPoint</code> &#32;only if class <code>Point</code> explicitly makes it available through some 
other method, as in:
<p><pre><a name="38928"></a>
abstract class Point {
<a name="38929"></a>	int x, y;
<a name="38930"></a>	public abstract String toString();
<a name="38945"></a>	protected String objString() { return super.toString(); }
<a name="38931"></a>}
<a name="38933"></a>
class ColoredPoint extends Point {
<a name="38934"></a>	int color;
<a name="38935"></a>	public String toString() {
<a name="38936"></a>		return objString() + ": color " + color;														// correct
<a name="229125"></a>	}
<a name="229126"></a>}
</pre><p><a name="229128"></a>
<h4>8.4.3.2	 static Methods</h4>
<p>
<a name="39431"></a>
<meta name="MS-HKWD" content="static">
A method that is declared <code>static</code> is called a <i>class method</i>. A class method is 
always invoked without reference to a particular object. An attempt to reference 
the current object using the keyword <code>this</code> or the keyword <code>super</code> in the body of a 
class method results in a compile time error. It is a compile-time error for a 
<code>static</code> method to be declared <code>abstract</code>.
<p><a name="39033"></a>
A method that is not declared <code>static</code> is called an <i>instance method,</i> and sometimes called a non-<code>static</code> method). An instance method is always invoked with respect to an object, which becomes the current object to which the keywords <code>this</code> and <code>super</code> refer during execution of the method body.<p>
<a name="11246"></a>
<h4>8.4.3.3	 final Methods</h4>
<p>
<a name="30456"></a>
<meta name="MS-HKWD" content="final">
A method can be declared <code>final</code> to prevent subclasses from overriding or hiding 
it. It is a compile-time error to attempt to override or hide a <code>final</code> method.
<p><a name="38958"></a>
A <code>private</code> method and all methods declared in a <code>final</code> class <a href="8_1_2.htm#54727">(&#167;8.1.2.2)</a> are implicitly <code>final</code>, because it is impossible to override them. It is permitted but not required for the declarations of such methods to redundantly include the <code>final</code> keyword. <p>
<a name="38950"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="14844"></a>
At run-time, a machine-code generator or optimizer can easily and safely "inline" the body of a <code>final</code> method, replacing an invocation of the method with the code in its body, as in the example:<p>
<pre><a name="36655"></a>
final class Point {
<a name="36656"></a>	int x, y;
<a name="36657"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<a name="36658"></a>}
<br><a name="36659"></a>
class Test {
<a name="36660"></a>	public static void main(String[] args) {
<a name="36661"></a>		Point[] p = new Point[100];
<a name="36662"></a>		for (int i = 0; i &lt; p.length; i++) {
<a name="25669"></a>			p[i] = new Point();
<a name="36663"></a>			p[i].move(i, p.length-1-i);
<a name="25670"></a>		}
<a name="36664"></a>	}
<a name="36665"></a>}
</pre><p><a name="36666"></a>
Here, inlining the method <code>move</code> of class <code>Point</code> in method <code>main</code> would transform 
the <code>for</code> loop to the form:
<p><pre><a name="36667"></a>
		for (int i = 0; i &lt; p.length; i++) {
<a name="25671"></a>			p[i] = new Point();
<a name="36668"></a>			Point pi = p[i];
<a name="36669"></a>			pi.x += i;
<a name="36670"></a>			pi.y += p.length-1-i;
<a name="36671"></a>		}
</pre><p><a name="31122"></a>
The loop might then be subject to further optimizations.
<p><a name="31123"></a>
Such inlining cannot be done at compile time unless it can be guaranteed that <code>Test</code> and <code>Point</code> will always be recompiled together, so that whenever <code>Point</code>-and specifically its <code>move</code> method-changes, the code for <code>Test.main</code> will also be updated.<p>
<a name="31125"></a>
<h4>8.4.3.4	 native Methods</h4>
<p>
<a name="30468"></a>
<meta name="MS-HKWD" content="native">
A method that is <code>native</code> is implemented in platform-dependent code, typically 
written in another programming language such as C, C++, FORTRAN, or assembly 
language. The body of a <code>native</code> method is given as a semicolon only, indicating 
that the implementation is omitted, instead of a block.
<p><a name="38981"></a>
A compile-time error occurs if a <code>native</code> method is declared <code>abstract</code>.<p>
<a name="38035"></a>
For example, the class <code>RandomAccessFile</code> of the standard package <code>java.io</code> might declare the following <code>native</code> methods:<p>
<pre><br><a name="14929"></a>package java.io;
<br></pre><p><pre><a name="229136"></a>
public class RandomAccessFile<br>
	implements DataOutput, DataInput
<a name="14948"></a>{	. . .
<a name="14949"></a>	public native void open(String name, boolean writeable)
<a name="14930"></a>		throws IOException;
<a name="14931"></a>	public native int readBytes(byte[] b, int off, int len)
<a name="14932"></a>		throws IOException;
<a name="14933"></a>	public native void writeBytes(byte[] b, int off, int len)
<a name="14934"></a>		throws IOException;
<a name="14935"></a>	public native long getFilePointer() throws IOException;
<a name="14944"></a>	public native void seek(long pos) throws IOException;
<a name="14940"></a>	public native long length() throws IOException;
<a name="27670"></a>	public native void close() throws IOException;
<a name="14950"></a>}
</pre><p><a name="55408"></a>
<h4>8.4.3.5	 synchronized Methods</h4>
<p>
<a name="30531"></a>
<meta name="MS-HKWD" content="synchronized">
A <code>synchronized</code> method acquires a lock <a href="17_1.htm#28287">(&#167;17.1)</a> before it executes. For a class 
(<code>static)</code> method, the lock associated with the <code>Class</code> object <a href="20_3.htm#14342">(&#167;20.3)</a> for the 
method's class is used. For an instance method, the lock associated with <code>this</code> (the 
object for which the method was invoked) is used. These are the same locks that 
can be used by the <code>synchronized</code> statement <a href="14_17.htm#79287">(&#167;14.17)</a>; thus, the code:
<p><pre><a name="39079"></a>
class Test {
<a name="39082"></a>	int count;
<a name="39085"></a>	synchronized void bump() { count++; }
<a name="39095"></a>	static int classCount;
<a name="39087"></a>	static synchronized void classBump() {
<a name="39107"></a>		classCount++;
<a name="39108"></a>	}
<a name="39080"></a>}
</pre><p><a name="39096"></a>
has exactly the same effect as:
<p><pre><a name="39099"></a>
class BumpTest {
<a name="39100"></a>	int count;
<a name="39101"></a>	void bump() {
<a name="227909"></a>		synchronized (this) {
<a name="227908"></a>			count++;
<a name="227910"></a>		}
<a name="227911"></a>	}
<a name="39102"></a>	static int classCount;
<a name="39103"></a>	static void classBump() {
<a name="229768"></a>		try {
<a name="39119"></a>			synchronized (Class.forName("BumpTest")) {
<a name="39114"></a>				classCount++;
<a name="229774"></a>			}
<a name="229769"></a>		} catch (ClassNotFoundException e) {
<a name="229770"></a>				...
<a name="229771"></a>		}
<a name="39115"></a>	}
<a name="39104"></a>}
</pre><p><a name="39078"></a>
The more elaborate example:
<p><pre><a name="30532"></a>
public class Box {
<br><a name="30534"></a>
	public synchronized Object get() {
<a name="30537"></a>		return contents;
<a name="30538"></a>	}
<br><a name="30539"></a>
	public synchronized boolean put(Object contents) {
<a name="30541"></a>			return false;
<a name="30543"></a>		return true;
<a name="30544"></a>	}
<br><a name="30545"></a>}
</pre><p><a name="30546"></a>
defines a class which is designed for concurrent use. Each instance of the class 
<code>Box</code> has an instance variable <code>contents</code> that can hold a reference to any object. 
You can put an object in a <code>Box</code> by invoking <code>put</code>, which returns <code>false</code> if the box is 
already full. You can get something out of a <code>Box</code> by invoking <code>get</code>, which returns a 
null reference if the <code>box</code> is empty.
<p><a name="39151"></a>
If <code>put</code> and <code>get</code> were not <code>synchronized</code>, and two threads were executing methods for the same instance of <code>Box</code> at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to <code>put</code> occurred at the same time.<p>
<a name="39159"></a>
See <a href="chap17.htm">&#167;17</a> for more discussion of threads and locks.<p>


</Font></body></html>
