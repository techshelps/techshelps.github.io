<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.1 The Form of a Java Binary</title>
<META NAME=MS-HAID CONTENT="13_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>13.1	 The Form of a Java Binary</h2>
<a name="44909"></a>
<p>
<a name="44910"></a>
While many Java binary files are likely to be in exactly the <code>class</code> file format specified by the <i>The Java Virtual Machine Specification</i>, this specification does not 
mandate the use of any specific binary file format. Rather, it specifies properties 
that any binary format for compiled types must obey. A number of these properties are specifically chosen to support source code transformations that preserve 
binary compatibility.
<p><a name="44911"></a>
The requirements are:<p>
<ul><a name="44912"></a>
<li>Binary formats for Java programs must be defined and processed to respect the specifications of loading <a href="12_2.htm#44459">(&#167;12.2)</a>, linking <a href="12_3.htm#44487">(&#167;12.3)</a> and initialization <a href="12_4.htm#44557">(&#167;12.4)</a> of class and interface types.
<a name="44922"></a>
<li>A reference to another class or interface type must be symbolic, using the fully qualified name of the type as determined at compile time.
<a name="44923"></a>
<li>A reference to a field of another class or interface must be resolved at compile time to a symbolic reference to the class or interface in which the field is declared, plus the simple name of the field. (Including the exact class or interface in which the field is declared makes the binaries more robust, since adding another field with the same name, even in a subclass, cannot cause confusion at link time. This rule does mean, however, that moving a field to a superclass is not a binary compatible change; see <a href="13_4_5.htm#45037">&#167;13.4.5</a> for a discussion.) The reference must also include a symbolic reference to the declared type of the field so that the verifier can check that the type is as expected. References to fields that are <code>static</code>, <code>final</code>, and initialized with compile-time constant expressions are resolved at compile time to the constant value that is denoted. No reference to such a constant field should be present in the code in a binary file (except in the class or interface containing the constant field, which will have code to initialize it), and such constant fields must always appear to have been initialized; the default initial value for the type of such a field must never be observed. See <a href="13_4_8.htm#45139">&#167;13.4.8</a> for a discussion.
<a name="44930"></a>
<li>A reference to a method or constructor must be resolved at compile time to a symbolic reference to the class or interface in which the denoted method or constructor is declared, plus the signature of the method or constructor. (As for fields, this makes the binaries more robust, with the caveat that such a method cannot be moved to a superclass without leaving a forwarding method behind; see <a href="13_4_5.htm#45037">&#167;13.4.5</a> for a discussion.) A reference to a method must also include either a symbolic reference to the return type of the denoted method or an indication that the denoted method is declared <code>void</code> and does not return a value. The signature of a method must include all of the following:
<ul>
<a name="44937"></a>
<li>The simple name of the method
<a name="46201"></a>
<li>The number of parameters to the method 
<a name="46202"></a>
<li>A symbolic reference to the type of each parameter
</ul>
</ul><ul><a name="46994"></a>
<br><br>The signature of a constructor must include both:<br>
<ul>
<a name="46995"></a>
<li>The number of parameters to the constructor
<a name="46996"></a>
<li>A symbolic reference to the type of each parameter
</ul>
</ul><p><a name="46203"></a>
A Java binary representation for a class or interface must also contain all of the 
following:
<p><ul><a name="44941"></a>
<li>If it is a class and is not class <code>java.lang.Object</code>, then a symbolic reference to the direct superclass of this class
<a name="44942"></a>
<li>A symbolic reference to each direct superinterface, if any
<a name="44943"></a>
<li>A specification of each field that is not <code>private</code> declared in the class or interface, given as the simple name of the field and a symbolic reference to the type of the field
<a name="44944"></a>
<li>If it is a class, then the signature of each constructor, as described above
<a name="44945"></a>
<li>For each method that is not <code>private</code> declared in the class or interface, its signature and return type, as described above
<a name="44946"></a>
<li>The code needed to implement the class or interface:
<ul>
<a name="44947"></a>
<li>For an interface, code for the field initializers
<a name="44948"></a>
<li>For a class, code for the field initializers, the static initializers, and the implementation of each method or constructor that is not declared <code>private</code>
</ul>
</ul><p><a name="44949"></a>
If a Java system defines a binary format that represents a group of classes and interfaces comprised by an entire package, then this binary format need not expose information about fields, methods, or constructors that are declared with default (package) access.<p>
<a name="44950"></a>
The following sections specify the changes that may be made to class and interface type declarations without breaking compatibility with pre-existing binaries. The Java Virtual Machine and its standard <code>class</code> file format support these changes; other Java binary formats are required to support these changes as well.<p>


</body></html>
