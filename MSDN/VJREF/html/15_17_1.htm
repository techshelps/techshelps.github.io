<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.17.1 String Concatenation Operator +</title>
<META NAME=MS-HAID CONTENT="15_17_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.17.1	 String Concatenation Operator +</h3>
<a name="39990"></a>
<p>
<a name="7894"></a>
If only one operand expression is of type <code>String</code>, then string conversion is performed on the other operand to produce a string at run time. The result is a reference to a newly created <code>String</code> object that is the concatenation of the two 
operand strings. The characters of the left-hand operand precede the characters of 
the right-hand operand in the newly created string.
<p><a name="40220"></a>
<h4>15.17.1.1	 String Conversion</h4>
<p>
<a name="40222"></a>
Any type may be converted to type <code>String</code> by <i>string conversion</i>.
<p><a name="22621"></a>
A value <i>x</i> of primitive type <i>T</i> is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression:<p>
<ul><a name="40316"></a>
<li>If <i>T</i> is <code>boolean</code>, then use <code>new</code> <code>Boolean(</code><i>x</i><code>)</code> <a href="20_4.htm#14344">(&#167;20.4)</a>.
<a name="40320"></a>
<li>If <i>T</i> is <code>char</code>, then use <code>new</code> <code>Character(</code><i>x</i><code>)</code> <a href="20_5.htm#14345">(&#167;20.5)</a>.
<a name="40265"></a>
<li>If <i>T</i> is <code>byte</code>, <code>short</code>, or <code>int</code>, then use <code>new</code> <code>Integer(</code><i>x</i><code>)</code> <a href="20_7.htm#14348">(&#167;20.7)</a>.
<a name="40272"></a>
<li>If <i>T</i> is <code>long</code>, then use <code>new</code> <code>Long(</code><i>x</i><code>)</code> <a href="20_8.htm#13841">(&#167;20.8)</a>.
<a name="40279"></a>
<li>If <i>T</i> is <code>float</code>, then use <code>new</code> <code>Float(</code><i>x</i><code>)</code> <a href="20_9.htm#14394">(&#167;20.9)</a>.
<a name="40286"></a>
<li>If <i>T</i> is <code>double</code>, then use <code>new</code> <code>Double(</code><i>x</i><code>)</code> <a href="20_10.htm#14390">(&#167;20.10)</a>.
</ul><p><a name="40362"></a>
This reference value is then converted to type <code>String</code> by string conversion.
<p><a name="22740"></a>
Now only reference values need to be considered. If the reference is <code>null</code>, it is converted to the string "<code>null</code>" (four ASCII characters <code>n</code>, <code>u</code>, <code>l</code>, <code>l</code>). Otherwise, the conversion is performed as if by an invocation of the <code>toString</code> method of the referenced object with no arguments; but if the result of invoking the <code>toString</code> method is <code>null</code>, then the string "<code>null</code>" is used instead. The <code>toString</code> method <a href="20_1.htm#1152">(&#167;20.1.2)</a> is defined by the primordial class <code>Object</code> <a href="20_1.htm#14533">(&#167;20.1)</a>; many classes override it, notably <code>Boolean</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double,</code> and <code>String</code>.<p>
<a name="40226"></a>
<h4>15.17.1.2	 Optimization of String Concatenation</h4>
<p>
<a name="40227"></a>
An implementation may choose to perform conversion and concatenation in one 
step to avoid creating and then discarding an intermediate <code>String</code> object. To 
increase the performance of repeated string concatenation, a Java compiler may 
use the <code>StringBuffer</code> class <a href="20_13.htm#14461">(&#167;20.13)</a> or a similar technique to reduce the number 
of intermediate <code>String</code> objects that are created by evaluation of an expression.
<p><a name="22668"></a>
For primitive objects, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.<p>
<a name="40423"></a>
<h4>15.17.1.3	 Examples of String Concatenation</h4>
<p>
<a name="40221"></a>
The example expression:
<p><pre><a name="21340"></a>"The square root of 2 is " + Math.sqrt(2)
</pre><p><a name="21343"></a>
produces the result:
<p><pre><a name="40506"></a>"The square root of 2 is 1.4142135623730952"
</pre><p><a name="21344"></a>
The + operator is syntactically left-associative, no matter whether it is later determined by type analysis to represent string concatenation or addition. In some cases care is required to get the desired result. For example, the expression:<p>
<pre><a name="40517"></a>a + b + c
</pre><p><a name="40518"></a>
is always regarded as meaning:
<p><pre><a name="40519"></a>(a + b) + c
</pre><p><a name="40520"></a>
Therefore the result of the expression:
<p><pre><a name="40521"></a>1 + 2 + " fiddlers"
</pre><p><a name="40522"></a>
is:
<p><pre><a name="40523"></a>"3 fiddlers"
</pre><p><a name="40524"></a>
but the result of:
<p><pre><a name="40525"></a>"fiddlers " + 1 + 2
</pre><p><a name="40526"></a>
is:
<p><pre><a name="238151"></a>"fiddlers 12"
</pre><p><a name="238156"></a>
In this jocular little example:<p>
<pre><a name="238165"></a>
class Bottles {
<a name="40430"></a>
	static void printSong(Object stuff, int n) {
<a name="40431"></a>		String plural = "s";
<a name="40432"></a>		loop: while (true) {
<a name="40433"></a>			System.out.println(n + " bottle" + plural
<a name="40434"></a>				+ " of " + stuff + " on the wall,");
<a name="40435"></a>			System.out.println(n + " bottle" + plural
<a name="40436"></a>				+ " of " + stuff + ";");
<a name="40437"></a>			System.out.println("You take one down "
<a name="40451"></a>				+ "and pass it around:");
<a name="40438"></a>			--n;
<a name="40439"></a>			plural = (n == 1) ? "" : "s";
<a name="40440"></a>			if (n == 0)
<a name="40441"></a>				break loop;
<a name="40442"></a>			System.out.println(n + " bottle" + plural
<a name="40443"></a>				+ " of " + stuff + " on the wall!");
<a name="40444"></a>			System.out.println();
<a name="40445"></a>		}
<a name="40446"></a>		System.out.println("No bottles of " +
<a name="43970"></a>								stuff + " on the wall!");
<a name="40447"></a>	}
<br><a name="40448"></a>}
</pre><p><a name="40427"></a>
the method <code>printSong</code> will print a version of a children's song. Popular values 
for stuff include <code>"pop"</code> and <code>"beer"</code>; the most popular value for <code>n</code> is <code>100</code>. Here is 
the output that results from <code>Bottles.printSong("slime", 3)</code>:
<p><pre><a name="40461"></a>
3 bottles of slime on the wall,
<a name="40462"></a>3 bottles of slime;
<a name="40463"></a>You take one down and pass it around:
<a name="40464"></a>2 bottles of slime on the wall!
<a name="40465"></a>
<a name="40466"></a>2 bottles of slime on the wall,
<a name="40467"></a>2 bottles of slime;
<a name="40468"></a>You take one down and pass it around:
<a name="40469"></a>1 bottle of slime on the wall!
<a name="40470"></a>
<a name="40471"></a>1 bottle of slime on the wall,
<a name="40472"></a>1 bottle of slime;
<a name="40473"></a>You take one down and pass it around:
<a name="40474"></a>No bottles of slime on the wall!
</pre><p><a name="40459"></a>
In the code, note the careful conditional generation of the singular "<code>bottle</code>" when appropriate rather than the plural "<code>bottles</code>"; note also how the string concatenation operator was used to break the long constant string:<p>
<pre><a name="40479"></a>"You take one down and pass it around:"
</pre><p><a name="40485"></a>
into two pieces to avoid an inconveniently long line in the source code.
<p>

</body></html>
