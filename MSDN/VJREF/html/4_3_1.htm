<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.3.1 Objects</title>
<META NAME=MS-HAID CONTENT="4_3_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>4.3.1	 Objects</h3>
<a name="12028"></a>
<p>
<a name="86707"></a>
An <i>object</i> is a <i>class</i> <i>instance</i> or an array.
<p><a name="86710"></a>
The reference values (often just <i>references</i>) are <i>pointers </i>to these objects, and a special null reference, which refers to no object.<p>
<a name="49853"></a>
A class instance is explicitly created by a class instance creation expression <a href="15_8.htm#41147">(&#167;15.8)</a>, or by invoking the <code>newInstance</code> method of class <code>Class</code> <a href="20_3.htm#28532">(&#167;20.3.8)</a>. An array is explicitly created by an array creation expression <a href="15_8.htm#41147">(&#167;15.8)</a>.<p>
<a name="49899"></a>
A new class instance is implicitly created when the string concatenation operator + <a href="15_17_1.htm#39990">(&#167;15.17.1)</a> is used in an expression, resulting in a new object of type <code>String</code> (<a href="4_3_3.htm#26992">&#167;4.3.3</a>, <a href="20_12.htm#14460">&#167;20.12</a>). A new array object is implicitly created when an array initializer expression <a href="10_6.htm#11358">(&#167;10.6)</a> is evaluated; this can occur when a class or interface is initialized <a href="12_4.htm#44557">(&#167;12.4)</a>, when a new instance of a class is created <a href="15_8.htm#41147">(&#167;15.8)</a>, or when a local variable declaration statement is executed <a href="14_3.htm#5920">(&#167;14.3)</a>.<p>
<a name="49960"></a>
Many of these cases are illustrated in the following example:<p>
<pre><a name="49961"></a>
class Point {
<a name="51683"></a>	int x, y;
<a name="86692"></a>	Point() { System.out.println("default"); }
<a name="86696"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="51733"></a>
	// A Point instance is explicitly created at class initialization time:
<a name="51732"></a>	static Point origin = new Point(0,0);
<a name="51734"></a>
	// A String can be implicitly created by a + operator:
<a name="51682"></a>	public String toString() {<br>
		return "(" + x + "," + y + ")";<br>
	}
<a name="51684"></a>}
<br><a name="51685"></a>
class Test {
<a name="51686"></a>	public static void main(String[] args) {
<a name="51735"></a>		// A Point is explicitly created using newInstance:
<a name="23341"></a>		Point p = null;
<a name="23324"></a>		try {
<a name="51687"></a>			p = (Point)Class.forName("Point").newInstance();
<a name="23327"></a>		} catch (Exception e) {
<a name="23350"></a>			System.out.println(e);
<a name="23351"></a>		}
<br><a name="51738"></a>
		// An array is implicitly created by an array constructor:
<a name="51688"></a>		Point a[] = { new Point(0,0), new Point(1,1) };
<br><a name="51757"></a>
		// Strings are implicitly created by + operators:
<a name="51689"></a>		System.out.println("p: " + p);
<a name="51690"></a>		System.out.println("a: { " + a[0] + ", "<br>
										  &#32;+ a[1] + " }");
<br><a name="51745"></a>
		// An array is explicitly created by an array creation expression:
<a name="51693"></a>		String sa[] = new String[2];
<a name="51697"></a>		sa[0] = "he"; sa[1] = "llo";
<a name="51698"></a>		System.out.println(sa[0] + sa[1]);
<a name="51699"></a>	}
<a name="49976"></a>}
</pre><p><a name="87328"></a>
which produces the output:
<p><pre><a name="87331"></a>
default
<a name="87332"></a>p: (0,0)
<a name="87333"></a>a: { (0,0), (1,1) }
<a name="87329"></a>hello
</pre><p><a name="49965"></a>
The operators on references to objects are:<p>
<ul><a name="31321"></a>
<li>Field access, using either a qualified name <a href="6_6.htm#33916">(&#167;6.6)</a> or a field access expression <a href="15_10.htm#41267">(&#167;15.10)</a>
<a name="31328"></a>
<li>Method invocation <a href="15_11.htm#20448">(&#167;15.11)</a>
<a name="31378"></a>
<li>The cast operator (<a href="5_4.htm#176921">&#167;5.4</a>, <a href="15_15.htm#238146">&#167;15.15</a>)
<a name="31345"></a>
<li>The string concatenation operator <code>+</code> <a href="15_17_1.htm#39990">(&#167;15.17.1)</a>, which, when given a <code>String</code> operand and a reference, will convert the reference to a <code>String</code> by invoking the <code>toString</code> method <a href="20_1.htm#1152">(&#167;20.1.2)</a> of the referenced object (using <code>"null"</code> if either the reference or the result of <code>toString</code> is a null reference), and then will produce a newly created <code>String</code> that is the concatenation of the two strings
<a name="31399"></a>
<li>The <code>instanceof</code> operator <a href="15_19_2.htm#80289">(&#167;15.19.2)</a>
<a name="31306"></a>
<li>The reference equality operators <code>==</code> and <code>!=</code> <a href="15_20_3.htm#236163">(&#167;15.20.3)</a>
<a name="19595"></a>
<li>The conditional operator <code>?&#32;:</code> <a href="15_24.htm#5257">(&#167;15.24)</a>.
</ul><p><a name="28239"></a>
There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the object, and then the altered state can be observed through the reference in the other variable.<p>
<a name="87600"></a>
The example program:<p>
<pre><a name="11036"></a>class Value { int val; }
</pre><p><pre><a name="87412"></a>
class Test {
<a name="87413"></a>	public static void main(String[] args) {
<a name="87414"></a>		int i1 = 3;
<a name="52134"></a>		int i2 = i1;
<a name="52135"></a>		i2 = 4;
<a name="50355"></a>		System.out.print("i1==" + i1);
<a name="50357"></a>		System.out.println(" but i2==" + i2);
<a name="50359"></a>		Value v1 = new Value();
<a name="50361"></a>		v1.val = 5;
<a name="52142"></a>		Value v2 = v1;
<a name="52143"></a>		v2.val = 6;
<a name="50363"></a>		System.out.print("v1.val==" + v1.val);
<a name="50365"></a>		System.out.println(" and v2.val==" + v2.val);
<a name="50367"></a>	}
<a name="50369"></a>}
</pre><p><a name="11050"></a>
produces the output:
<p><pre><a name="11051"></a>
i1==3 but i2==4
<a name="45608"></a>v1.val==6 and v2.val==6
</pre><p><a name="11053"></a>
because <code>v1.val</code> and <code>v2.val</code> reference the same instance variable <a href="4_5_3.htm#28536">(&#167;4.5.3)</a> in the 
one <code>Value</code> object created by the only <code>new</code> expression, while <code>i1</code> and <code>i2</code> are different variables.
<p><a name="17783"></a>
See <a href="chap10.htm">&#167;10</a> and <a href="15_9.htm#46168">&#167;15.9</a> for examples of the creation and use of arrays.<p>
<a name="17053"></a>
Each object has an associated lock <a href="17_13.htm#28460">(&#167;17.13)</a>, which is used by <code>synchronized</code> methods <a href="8_4_3.htm#78188">(&#167;8.4.3)</a> and the <code>synchronized</code> statement <a href="14_17.htm#79287">(&#167;14.17)</a> to provide control over concurrent access to state by multiple threads (<a href="17_12.htm#28457">&#167;17.12</a>, <a href="20_20.htm#2658">&#167;20.20</a>).<p>


</body></html>
