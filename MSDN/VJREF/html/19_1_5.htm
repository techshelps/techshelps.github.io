<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>19.1.5 Problem #5: Cast versus Parenthesized Expression</title>
<META NAME=MS-HAID CONTENT="19_1_5">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>19.1.5	 Problem #5: Cast versus Parenthesized Expression</h3>
<a name="44559"></a>
<p>
<a name="44560"></a>
Consider the production:
<p><pre>
<i>CastExpression:<br>
<code>	( </code><i>PrimitiveType</i><code> ) </code><i>UnaryExpression<br>
</i><code>	( </code>ReferenceType<code> ) </code>U<i>naryExpressionNotPlusMinus
</i></i></pre><p><a name="44562"></a>
Now consider the partial input:
<p><pre><a name="44563"></a>class Problem5 { Problem5() { super((matthew)
</pre><p><a name="44564"></a>
When the parser is considering the token <code>matthew</code>, with one-token lookahead to 
symbol <code>)</code>, it cannot yet tell whether <code>(matthew)</code> will be a parenthesized expression, as in:
<p><pre><a name="44565"></a>super((matthew), 9);
</pre><p><a name="44566"></a>
or a cast, as in:
<p><pre><a name="44567"></a>super((matthew)baz, 9);
</pre><p><a name="44568"></a>
Therefore, after the parser reduces <code>matthew</code> to the nonterminal <i>Name</i>, it cannot 
tell with only one-token lookahead whether <i>Name</i> should be further reduced to 
<i>PostfixExpression</i> and ultimately to <i>Expression</i> (for a parenthesized expression) or 
to <i>ClassOrInterfaceType</i> and then to <i>ReferenceType</i> (for a cast). Therefore, the 
productions shown above result in a grammar that is not LALR(1).
<p><a name="44569"></a>
The solution is to eliminate the use of the nonterminal <i>ReferenceType</i> in the definition of <i>CastExpression</i>, which requires some reworking of both alternatives to avoid other ambiguities:<p>
<pre>
<i>CastExpression:<br>
<code>	( </code><i>PrimitiveType</i><code> </code>Dimsopt<code> ) </code><i>UnaryExpression<br>
</i><code>	( </code>Expression<code> ) </code>U<i>naryExpressionNotPlusMinus<br>
	</i><code>( </code>Name<code> </code>Dims<code> ) </code>U<i>naryExpressionNotPlusMinus
</i></i></pre><p><a name="44571"></a>
This allows the parser to reduce <code>matthew</code> to <i>Expression</i> and then leave it there, 
delaying the decision as to whether a parenthesized expression or a cast is in 
progress. Inappropriate variants such as:
<p><pre><a name="44572"></a>(int[])+3
</pre><p><a name="44573"></a>
and:
<p><pre><a name="44574"></a>(matthew+1)baz
</pre><p><a name="44575"></a>
must then be weeded out and rejected by a later stage of compiler analysis.
<p><a name="28201"></a>
The remaining sections of this chapter constitute a LALR(1) grammar for Java syntax, in which the five problems described above have been solved.<p>


</body></html>
