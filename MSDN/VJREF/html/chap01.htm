<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>1. Introduction</title>
<META NAME=MS-HAID CONTENT="chap01">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
</head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<META NAME="MS-HAID" CONTENT="Java Language Specification">
 
<hr><br>
 
<a name="22190"></a>
<p><strong>
CHAPTER
 1 </strong></p>

<h1> Introduction</h1>
<a name="22191"></a>
<p>
<a name="44558"></a>
<p><i>If I have seen further it is by standing upon the shoulders of Giants.</i><br>
<a name="237161"></a>
&#151;Sir Isaac Newton</p>
<p>
<a name="51863"></a>
Java is a general-purpose, concurrent, class-based, object-oriented language. It 
is designed to be simple enough that many programmers can achieve fluency in 
the language. Java is related to C and C++ but is organized rather differently, with 
a number of aspects of C and C++ omitted and a few ideas from other languages 
included. Java is intended to be a production language, not a research language, 
and so, as C. A. R. Hoare suggested in his classic paper on language design, the 
design of Java has avoided including new and untested features.
<p><a name="51872"></a>
Java is strongly typed. This specification clearly distinguishes between the compile-time errors 
that can and must be detected, and those that occur at run time. 
Compile time normally consists of translating Java programs into a machine-independent 
byte-code representation. Run-time activities include loading and linking of the classes 
needed to execute a program, optional machine code generation and dynamic optimization of the program, and actual program execution.<p>
<a name="27438"></a>
Java is a relatively high-level language, in that details of the machine representation are not available through the language. It includes automatic storage management, typically using a garbage collector, to avoid the safety problems of explicit deallocation (as in C's <code>free</code> or C++'s <code>delete</code>). High-performance garbage-collected implementations of Java can have bounded pauses to support systems programming and real-time applications. Java does not include any unsafe constructs, such as array accesses without index checking, since such unsafe constructs would cause a program to behave in an unspecified way.<p>
<a name="51852"></a>
Java is normally compiled to a bytecoded instruction set and binary format defined in <i>The Java Virtual Machine Specification </i>(Addison-Wesley, 1996). Most implementations of Java for general-purpose programming will support the additional packages defined in the series of books under the general title <i>The Java Application Programming Interface</i> (Addison-Wesley).<p>
<a name="26287"></a>
This Java Language Specification is organized as follows:
<p><a name="26288"></a>
Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for Java.<p>
<a name="228682"></a>
Chapter 3 describes the lexical structure of Java, which is based on C and C++. Java is written in the Unicode character set. Java supports the writing of Unicode characters on systems that support only ASCII.<p>
<a name="26538"></a>
Chapter 4 describes Java's types, values, and variables. Java's types are the primitive types and reference types.<p>
<a name="18945"></a>
The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a <code>boolean</code> type, and a Unicode character <code>char</code> type. Values of the primitive types do not share state.<p>
<a name="18946"></a>
Java's reference types are the class types, the interface types, and the array types. The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the standard class <code>Object</code>, which is the (single) root of the class hierarchy. A predefined <code>String</code> class supports Unicode character strings. Standard classes exist for wrapping primitive values inside of objects.<p>
<a name="18948"></a>
Variables are typed storage locations. A variable of a primitive type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of an array type can hold a null reference or a reference to an array. A variable of class type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array.<p>
<a name="228680"></a>
Chapter 5 describes Java's conversions and numeric promotions. Conversions change the compile-time type and, sometimes, the value of an expression. Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed. There are no loopholes in the language; casts on reference types are checked at run time to ensure type safety.<p>
<a name="228720"></a>
Chapter 6 describes declarations and names, and how to determine what names mean (denote). Java does not require types or their members to be declared before they are used. Declaration order is significant only for local variables and the order of initializers of fields in a class or interface.<p>
<a name="46378"></a>
Java provides control over the scope of names and supports limitations on external access to members of packages, classes, and interfaces. This helps in writing large programs by distinguishing the implementation of a type from its users and those who extend it. Standard naming conventions that make for more readable programs are described here.<p>
<a name="26857"></a>
Chapter 7 describes the structure of a Java program, which is organized into packages similar to the modules of Modula. The members of a package are compilation units and subpackages. Compilation units contain type declarations and can import types from other packages to give them short names. Packages have names in a hierarchical namespace, and the Internet domain name system can be used to form unique package names.<p>
<a name="26599"></a>
Chapter 8 describes Java's classes. The members of classes are fields (variables) and methods. Class variables exist once per class. Class methods operate without reference to a specific object. Instance variables are dynamically created in objects that are instances of classes. Instance methods are invoked on instances of classes; such instances become the current object <code>this</code> during their execution, supporting the object-oriented programming style.<p>
<a name="236326"></a>
Classes support single implementation inheritance, in which the implementation of each class is derived from that of a single superclass, and ultimately from the class <code>Object</code>. Variables of a class type can reference an instance of that class or of any subclass of that class, allowing new types to be used with existing methods, polymorphically.<p>
<a name="236327"></a>
Classes support concurrent programming with <code>synchronized</code> methods. Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled. Objects can declare a <code>finalize</code> method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.<p>
<a name="46499"></a>
For simplicity, Java has neither declaration "headers" separate from the implementation of a class nor separate type and class hierarchies.<p>
<a name="46502"></a>
Although Java does not include parameterized classes, the semantics of arrays are those of a parameterized class with some syntactic sugar. Like the programming language Beta, Java uses a run-time type check when storing references in arrays to ensure complete type safety.<p>
<a name="46505"></a>
Chapter 9 describes Java's interface types, which declare a set of abstract methods and constants. Classes that are otherwise unrelated can implement the same interface type. A variable of an interface type can contain a reference to any object that implements the interface. Multiple interface inheritance is supported.<p>
<a name="25607"></a>
Chapter 10 describes Java arrays. Array accesses include bounds checking. Arrays are dynamically created objects and may be assigned to variables of type <code>Object</code>. Java supports arrays of arrays, rather than multidimensional arrays.<p>
<a name="27520"></a>
Chapter 11 describes Java's exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms. There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors. The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if it declares it. This provides compile-time checking that exception handlers exist, and aids programming &#32;in the large. Most user-defined exceptions should be checked exceptions. Invalid operations in the program detected by the Java Virtual Machine result in run-time exceptions, such as <code>NullPointerException</code>. Errors result from failures detected by the virtual machine, such as <code>OutOfMemoryError</code>. Most simple programs do not try to handle errors.<p>
<a name="27521"></a>
Chapter 12 describes activities that occur during execution of a Java program. A Java program is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized.<p>
<a name="22863"></a>
After initialization, class methods and class variables may be used. Some classes may be instantiated to create new objects of the class type. Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.<p>
<a name="22864"></a>
When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded; if a class finalizer is declared, it is given a chance to clean up first. Objects and classes may be finalized on exit of the Java Virtual Machine.<p>
<a name="23448"></a>
Chapter 13 describes binary compatibility, specifying the impact of changes to types on other types that use the changed types but have not been recompiled. These considerations are of interest to developers of types that are to be widely distributed, in a continuing series of versions, often through the Internet. Good program development environments automatically recompile dependent code whenever a type is changed, so most programmers need not be concerned about these details.<p>
<a name="228758"></a>
Chapter 14 describes Java's blocks and statements, which are based on C and C++. Java has no <code>goto</code>, but includes labeled <code>break</code> and <code>continue</code> statements. Unlike C, Java requires <code>boolean</code> &#32;expressions in control-flow statements, and does not convert types to <code>boolean</code> implicitly, in the hope of catching more errors at compile time. A <code>synchronized</code> &#32;statement provides basic object-level monitor locking. A <code>try</code> statement can include <code>catch</code> and <code>finally</code> clauses to protect against non-local control transfers.<p>
<a name="236334"></a>
Chapter 15 describes Java's expressions. Java fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability. Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable. Java chooses which method or constructor by using the same basic algorithm used in languages with richer dispatching, such as CLOS and Dylan, for the future.<p>
<a name="236335"></a>
Chapter 16 describes the precise way in which Java ensures that local variables are definitely set before use. While all other variables are automatically initialized to a default value, Java does not automatically initialize local variables in order to avoid masking programming errors.<p>
<a name="56885"></a>
Chapter 17 describes the semantics of Java threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language. Java specifies a memory model for shared-memory multiprocessors that supports high-performance implementations.<p>
<a name="21132"></a>
Chapter 18 describes the facilities for automatically generating documentation from special comments in Java source code.<p>
<a name="21133"></a>
Chapter 19 presents a LALR(1) syntactic grammar for Java, and describes the differences between this grammar and the expository grammar used in the body of the language specification that precedes it.<p>
<a name="21134"></a>
Chapters 20 through 22 are the reference manual for the core of the standard Java Application Programming Interface. These packages must be included in all general purpose Java systems.<p>
<a name="21104"></a>
Chapter 20 describes the package <code>java.lang</code>. The types defined in <code>java.lang</code> are automatically imported to be available without qualification in all Java programs. They include the primordial class <code>Object</code>, which is a superclass of all other classes; classes such as <code>Integer</code> &#32;and <code>Float</code>, which wrap the primitive types inside objects; exceptions and errors defined by the language and the Java Virtual Machine; <code>Thread</code> support; metalinguistic classes such as <code>Class</code> and <code>ClassLoader</code>; and the class <code>System</code>, which abstracts the host system.<p>
<a name="11473"></a>
Chapter 21 describes the package <code>java.util</code>, which defines a few basic utility classes, such as a hashtable class and a pseudo-random number generator.<p>
<a name="11474"></a>
Chapter 22 describes the package <code>java.io</code>, which defines basic input/output facilities, including random access files and streams of values of primitive types.<p>
<a name="11476"></a>
The book concludes with two indexes: one for the types, methods, and fields defined and described in this specification, and the other a more traditional index.<p>


</Font></body></html>
