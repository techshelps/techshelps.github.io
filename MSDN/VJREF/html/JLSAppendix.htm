<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Changes for Java 1.1</title>
<META NAME=MS-HAID CONTENT="JLSAppendix">
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<a name="10425">
<hr>
Copyright &copy; 1997 Sun Microsystems, Inc. 
"Java" is a trademark of  Sun Microsystems, Inc.  
This document is covered by the full copyright and 
trademark declarations in <i>The Java Language
Specification</i>.  This document is excerpted from the
fourth printing of <i>The Java  Programming Language</i> 
by Ken Arnold and James Gosling, Addison-Wesley, 1996, ISBN 0-201-63455-4.
<hr>
<h3>Appendix D</h3>
</a><a name="10426">
<h1> Changes for Java 1.1</h1>
</a><a name="13356">
<i>
<p ALIGN=right>No unmet needs exist and...current unmet needs that are being met will continue to be met.
</p>
</i>
</a><a name="13358">
<p ALIGN=right>-- Transportation Commission on Unmet Transit Needs, California</p><p>
</a><a name="12813">
A newer version of Java has arrived since the original publication of this book. Called the Java 1.1 Platform
(hereafter simply "Java 1.1"), it adds some language features, a few packages, and many classes to existing packages. The goals of Java 1.1 are to support internationalization better, fix the incongruities of the original abstract window toolkit package (<code>java.awt</code>, or just "AWT" for short), complete functionality that was missing or impoverished, and add several useful packages. This book does not cover AWT, so we do not cover it in this appendix.<p>
</a><a name="12841">
This appendix does summarizes the other changes. For extensive changes, especially those having to do with new classes and packages, you will have to use the reference documentation shipped with your Java 1.1 system to supplement this appendix. The section titles in this appendix correspond to the chapters of this book where the new features would appear.<p>
</a><a name="11710">
<h2>D.1	 Classes</h2>
</a><a name="12429">
<h4>D.1.1	 Inner Classes</h4>
</a><a name="12430">
Classes and interfaces can be nested inside other classes. Such classes, called inner classes, should be ones that exist only to support the work of the class in which they nest. For example, the sole purpose of the <code>SortMetrics</code> class on page 75 is to return multiple values from the <code>metrics</code> method of the <code>SortDouble</code> class. It is a good candidate to be an inner class:<p>
</a>
<a SortDouble><pre>
    abstract class SortDouble {
	static final class SortMetrics implements Cloneable {
	    // ... the rest of SortMetrics (see page 75)
	}
	// ... the rest of SortDouble (see page 73)
    }
</pre></a><a name="12042">
<p>
An inner class name is qualified by its enclosing class. In this case, the proper name of <code>SortMetrics</code> is <code>SortDouble.SortMetrics</code>, and so its declaration in <code>SimpleSortDouble</code> on page 76 would be<p>
</a>
<a SortDoubleMetrics><pre>
    SortDouble.SortMetrics metrics = bsort.sort(testData);
</pre></a><a name="11726">
Inner classes and interfaces can use the same access modifiers as other members of a class. A class that was used only in internal data structures might be marked <code>private</code>; one intended only for use by subclasses would be <code>protected</code>. Inner classes can also be <code>public</code> or package accessible.<p>
</a><a name="12528">
The example above declares <code>SortMetrics</code> as <code>static</code>. An inner class that is not static has an implicit reference to its enclosing object, which is the object that created the inner class object. This reference is useful because many inner classes are strongly tied to particular objects, and need to access their fields. For example, the class <code>EnumerateWhichChars</code> on page 222 is used to implement the <code>Enumeration</code> interface for the <code>WhichChars</code> class, and could be nicely rewritten to look like this:<p>
</a>
<a WhichChars><pre>
    public class WhichChars {
	private BitSet used = new BitSet();     // in original
	private class Enumerate implements Enumeration {
	    private int pos = 0;
	    private int setSize = used.size();

	    public boolean hasMoreElements() {
		while (pos &lt; setSize &amp;&amp; !used.get(pos))
		    pos++;
		return (pos &lt; setSize);
	    }

	    public Object nextElement()
		throws NoSuchElementException
	    {
		if (hasMoreElements())
		    return new Character((char)pos++);
		else
		    throw new NoSuchElementException();
	    }
	}

	public Enumeration characters() {       // from page 223
	    return new Enumerate();
	}
    }
</pre></a><a name="11744">
<p>
We use the shorter class name <code>Enumerate</code> because the class is already nested inside <code>WhichChars</code>, so <code>EnumerateWhichChars</code> would be redundant. The class is <code>private</code> so that even other classes in the package can't use the type directly-it is purely an implementation detail of the <code>WhichChars</code> class.<p>
</a><a name="12570">
In the original code on page 222, <code>used</code> was passed as a parameter to the class's constructor, which stored the reference in a field of its own called <code>bits</code>. Here the code for <code>Enumerate</code> directly accesses the field <code>used</code> of its enclosing object. When resolving identifiers, the inner class's enclosing object (also called its enclosing instance) is searched for fields and methods after the class's own <code>this</code>. Because <code>Enumerate</code> does not have a field named <code>used</code>, the identifier <code>used</code> in the inner class refers to the enclosing object's field of that name. The enclosing object for an inner class is the <code>this</code> reference of the method that created the inner class object. In our example above, when an <code>Enumerate</code> object is created inside a particular <code>WhichChar</code> object, the <code>Enumerate</code> object's enclosing object is set to be the <code>this</code> reference of the <code>WhichChar</code> method that created it. This means you cannot create an instance of a non-static inner class in a static context (inside a static method, a static block, or as an initializer for a static field).<p>
</a><a name="12125">
You can get a reference to an enclosing object using its class name. For example, code in an <code>Enumerator</code> object could get a reference to its enclosing object using <code>WhichChar.this</code>.<p>
</a><a name="12126">
<h4>D.1.2	 New Uses for final</h4>
</a><a name="12582">
Method parameters and local variables can be declared <code>final</code>. If you do not expect to change the value of a parameter or variable inside the method, you can declare it <code>final</code> to let the compiler enforce that. The compiler can also optimize uses of a <code>final</code> parameter or variable since it knows the value will never change.<p>
</a><a name="13105">
The <code>final</code>-ness of a parameter is not part of the method signature-it is simply a detail of the implementation. A subclass can override a method and add or drop any <code>final</code> parameter modifiers you wish. You can also add or drop <code>final</code> modifiers in a method's parameters without causing any harm to existing compiled code that uses that method. The <code>final</code> declaration does not show up in the documentation generated from doc comments.<p>
</a><a name="11901">
You can defer initialization of a <code>final</code> field or variable, as long as you initialize it before it is used and assign a value to it exactly once. The compiler will check for proper assignment, as will the verifier before code is executed. Deferred initialization can be useful when the proper value can only be calculated by a loop or other code that is hard or impossible to encode in a variable initializer, such as code that throws exceptions that must be caught and handled.<p>
</a><a name="12269">
<h4>D.1.3	 Object Initializers</h4>
</a><a name="12270">
You can have arbitrary blocks of code that are executed after the superclass constructor is executed, but before the class's own constructor body is executed. Such blocks are analogous to <code>static</code> blocks described on page 44, except the keyword <code>static</code> is left off.<p>
</a><a name="11981">
<h2>D.2	 Extending Classes</h2>
</a><a name="12959">
<h4>D.2.1	 Anonymous Classes</h4>
</a><a name="12960">
When you are writing simple subclasses or implementations of interfaces, creating a bunch of classes for each trivial class can be awkward. Anonymous classes are a convenient short form of inner classes that have no name, only an implementation that is specified right along with the <code>new</code>. Suppose you want to create a simple <code>Observer</code> object (see page 233) that keeps a history of the events stored in a field of your object. The following would do this directly and simply:<p>
</a>
<a anonymous><pre>
    private Vector history = new Vector();

    public void watch(Observable o) {
	o.addObserver(new Observer() {
	    public void update(Observable o, Object arg) {
		history.addElement(arg);
	    }
	});
    }
</pre></a><a name="12971">
<p>
The <code>addObserver</code> has an embedded <code>new</code> of an anonymous class that implements the <code>Observer</code> interface, implicitly extending <code>Object</code>. This anonymous class implements <code>update</code> by adding an element to the enclosing object's <code>history</code> vector. The compiler creates an unnamed (hence "anonymous") class that overrides <code>update</code> as specified. The end of the anonymous class declaration is the end of the allocation expression started by the <code>new</code>. Here we simply close off the call to <code>addObserver</code> with a closing parenthesis.<p>
</a><a name="12607">
An anonymous class can extend a class instead of implementing an interface, in which case it is an unnamed subtype of that class. Such a <code>new</code> can invoke any superclass constructor. Anonymous classes cannot have their own constructors.<p>
</a><a name="12608">
Anonymous classes are a quick, terse subclassing tool that is useful in certain situations, such as creating several types of AWT buttons, each with its own small action, or creating simple <code>Runnable</code> objects. Unfortunately, they share a common failing of many terseness features-it is trivial to write code that is torture to read. You should use of anonymous classes only for tiny classes that override one, or at most two, methods, with a total of four lines of code or fewer. Otherwise people who read your code can become confused trying to keep track of what piece of which class's method's code they are reading, and what the outer context is. Use this tool sparingly. When it's good, it's very, very good. When it's not, it's awful.<p>
</a><a name="11860">
<h4>D.2.2	 New Hashing Method</h4>
</a><a name="11861">
The default implementation of <code>Object.hashCode</code> is to return keys that are likely to be different for different objects. As described on page 64, many classes override both <code>hashCode</code> and <code>equals</code> to provide different notions of equality. However, sometimes you need the original notion of equality, in which all objects are different, even for an object that usually is used with a broader notion. You can use <code>==</code> to test if two objects are the same, but you will need to use <code>System.identityHashCode</code> to hash the objects, since it preserves the default implementation of <code>hashCode</code> in which all objects are considered different.<p>
</a><a name="11825">
<h2>D.3	 Tokens, Operators, and Expressions</h2>
</a><a name="11998">
Documentation comments ("doc comments") contain <code>@</code> tags (such as <code>@author</code> and <code>@see</code>) that are not documented in this book. The new <code>@deprecated</code> tag has particular meaning-it marks a class, interface, field, or method as not recommended for continued use. Existing code that uses the deprecated entity will still compile and run, but the compiler will generate a warning, suggesting that you update your code to avoid that entity. You should follow that recommendation.<p>
</a><a name="13278">
To have this effect on a type or a member of a type, the <code>@deprecated</code> tag must be at the beginning of a doc comment line (ignoring white space and any <code>*</code> character). This is the only place in the entire Java language where the contents of a comment affect the generated code. The <code>@deprecated</code> tag should always refer readers to the preferred replacement(s). For example<p>
</a>
<a name="13283"><pre>
    /**
      * @deprecated	This call has been replaced with dwishm
      * @see dwishm
      */
    public void dwim() { /*...*/ }
</pre></a><a name="13279">
The <code>transient</code> keyword, marked as "unused" on page 93, now has defined meaning; see <a href="jlsappendix.htm#11996">Section D.5.2</a>.<p>
</a><a name="12273">
You can initialize the contents of an array when you <code>new</code> it. For example, the following would be a flexible way to create an array of strings:<p>
</a>
<a initializedArray><pre>
    String[] martians = new String[] {
			    "Gidney", "Cloyd"
			};
</pre></a><a name="11997">
<h2>D.4	 Threads</h2>
</a><a name="11826">
The interruption mechanism briefly described on pages 173-174 as future functionality has been implemented in Java 1.1. See those pages for more details.<p>
</a><a name="11827">
<h2>D.5	 I/O</h2>
</a><a name="11995">
<h4>D.5.1	 Internationalization</h4>
</a><a name="11909">
Many new I/O classes have been added to handle full internationalized character issues. The original classes really worked only with ISO-Latin-1 8-bit characters (notice that <code>InputStream.read</code>, for example, returned eight bits, not sixteen, in its <code>int</code>). The most specific change is that <code>PrintStream</code> is now a deprecated class, since it thinks only in terms of ISO-Latin-1. The new class is called <code>PrintWriter</code>, and provides all the methods of <code>PrintStream</code> except those for writing raw bytes. Existing code that uses the <code>print</code> and <code>println</code> methods of <code>PrintStream</code> will have the output translated to the local character set. (To prevent a massive outpouring of deprecation warnings, only the constructors of <code>PrintStream</code> are deprecated.)<p>
</a><a name="13204">
The autoflushing of <code>PrintStream</code> described on page 199 has been cleaned up. If autoflush is turned on, any newline anywhere in the output causes a flush, as does any <code>write</code> of a byte array. If autoflush is off, no automatic flushing is done.<p>
</a><a name="13205">
<code>PrintWriter</code> is a subclass of the abstract <code>Writer</code> class, which is the parallel to <code>OutputStream</code> for classes that understand internationalization. The <code>Reader</code> abstract class is the parallel to <code>InputStream</code>. There are several new <code>Reader</code> and <code>Writer</code> classes for internationalized I/O.<p>
</a><a name="12892">
The fields <code>System.in</code>, <code>System.out</code>, and <code>System.err</code> are final in Java 1.1 for security reasons, so code that modifies these fields (like that shown on page 197) will not work.<p>
</a><a name="12899">
The new package <code>java.text</code> includes many classes useful for parsing and producing internationalized text. It includes classes for date and number formatting, comparing and sorting strings in a locale-sensitive way, splitting up native language text, and other locale-related I/O.<p>
</a><a name="11996">
<h4>D.5.2	 Object Serialization</h4>
</a><a name="13375">
The streams <code>ObjectInputStream</code> and <code>ObjectOutputStream</code> help you read and write entire objects and object graphs. Objects written to an <code>ObjectOutputStream</code> using <code>writeObject</code> generate a stream of bytes that, when read by an <code>ObjectInputStream</code> with <code>readObject</code>, create a full copy of the original objects. The process of creating such a stream of bytes is called serialization. Serialized copies are deep-you can serialize an entire graph of objects, and when you deserialize the generated bytes, you will get a full copy of the original graph. If two or more objects refer to a particular object in the original graph, a deserialized copy will have copies of those two or more objects that refer to a copy of that same particular object.<p>
</a><a name="12671">
The byte stream encodes the state of the serialized object, including private fields. Therefore any serializable object can have the values of its private fields examined by someone who serializes the object and reads the generated bytes. Some programmers view <code>private</code> fields as secret, and would not be pleased to have values exposed in this way. For this reason, objects are not serializable unless they implement the <code>Serializable</code> interface. <code>Serializable</code> is an empty interface that simply marks the object as one that can be serialized. The default serialization mechanism just writes the non-static, non-transient fields of an object. You can override this by providing <code>readObject</code> and <code>writeObject</code> methods.<p>
</a><a name="11948">
A class that instead implements the interface <code>Externalizable</code>-a subinterface of <code>Serializable</code>-is serializable but must provide custom <code>readExternal</code> and <code>writeExternal</code> methods; the default serialization will not be used.<p>
</a><a name="11958">
<h2>D.6	 Utilities</h2>
</a><a name="12340">
<h4>D.6.1	 Resource Localization</h4>
</a><a name="11959">
Several new utilities have been added for localization. A new <code>Locale</code> class describes particular locales to define a user's preferred language and other properties. A <code>ResourceBundle</code> superclass is provided to customize a set of resources (such as messages that might be displayed to the user) based on the user's preferred locale. Some subtypes of <code>ResourceBundle</code> are provided: <code>ListResourceBundle</code>, an abstract class that provides a simple implementation of <code>ResourceBundle</code> to which you must simply provide the list of resources and keys for each resource, and <code>PropertyResourceBundle</code>, which uses files that contain the keyed resources.<p>
</a><a name="12341">
<h4>D.6.2	 Dates and Times</h4>
</a><a name="13181">
The functionality of the <code>Date</code> class has been split up into a richer system that can cope with varying reckonings of time. A <code>Date</code> object now only represents a particular moment in time with millisecond granularity. Its other constructors and methods previously performed two other duties: formatting strings and viewing a moment in time as year, month, day, hour, minute, and second values. All these methods are deprecated in favor of:<p>
</a><ul><a name="13182">
<li>an abstract <code>Calendar</code> class for handling various ways of marking time
</a><a name="13183">
<li>an abstract <code>TimeZone</code> class that represents time zone offsets and other adjustments, such as daylight savings time
</a><a name="12371">
<li>an abstract <code>java.text.DateFormat</code> class that defines how one can parse and format date strings
</a><a name="12339">
</ul>
<p>
These abstract classes allow flexibility, but almost everyone will need to work with Gregorian dates that are used in most of the world and in international commerce, so Java 1.1 also provides:<p>
<ul>
</a><a name="12338">
<li>a <code>GregorianCalendar</code> class
</a><a name="13232">
<li>a <code>SimpleTimeZone</code> class for use with <code>GregorianCalendar</code>
</a><a name="13233">
<li>a <code>java.text.SimpleDateFormat</code> class that parses and formats Gregorian dates
</a><a name="12375">
For example, the following program uses a <code>GregorianCalendar</code> to print out the current year:<p>
</a></ul>
<a name="12378">
<a CurrentYear><pre>
    class CurrentYear {
	public static void main(String[] args) {
	    GregorianCalendar now = new GregorianCalendar();
	    int year = now.get(Calendar.YEAR);
	    System.out.println("The year is " + year);
	}
    }
</pre></a><a name="12379">
<p>
</a><a name="11908">
<h2>D.7	 Programming with Types</h2>
</a><a name="12195">
<h4>D.7.1	 Reflection</h4>
</a><a name="12196">
The package <code>java.lang.reflect</code> provides a reflection mechanism for Java. This is a tool for examining classes fully. A <code>Class</code> object can now return a list of all the public methods and fields of the related class. You can use the <code>Method</code> objects returned to invoke methods, and the <code>Field</code> objects to get and set field values. A <code>Class</code> object can also return a list of all members, including non-public ones, but security restrictions usually prevent doing this.<p>
</a><a name="12202">
You should avoid the temptation to use reflection when other tools more natural to the language would suffice. If you are accustomed to using function pointers in another language, for example, you might think that using <code>Method</code> objects are a natural replacement, but usually an object-oriented tool-such as an interface that is implemented by objects that perform the needed action-is better. Reflection is intended for use by language tools such as debuggers and class browsers.<p>
</a><a name="12258">
<h4>D.7.2	 Wrapper Classes</h4>
</a><a name="12259">
Two new wrapper classes have been added: <code>Short</code> and <code>Byte</code>. These are subtypes of <code>Number</code>. A new <code>Void</code> class has also been added for completeness, and is used by the reflection methods to represent <code>void</code> return types.<p>
</a><a name="12263">
<h4>D.7.3	 Getting the Class Object for a Named Class</h4>
</a><a name="12264">
You can get the <code>Class</code> object for a given type with a new use of the <code>class</code> keyword:<p>
</a>
<a useClass><pre>
    Class threadClass = Thread.class;
    Class intClass = int.class;
    Class voidClass = void.class;
</pre></a><a name="12245">
<h2>D.8	 Native Methods</h2>
</a><a name="12246">
The API for writing C implementations of Java methods is now completely different. The mapping has been regularized, and is less tied to a particular implementation of the Java Virtual Machine. The general comments about native method mappings in Appendix A are still valid, but the specific details described, while still supported, are strongly deprecated. The new Java Native Interface (JNI) is much easier to learn and to use.<p>
</a><a name="12211">
<h2>D.9	 New Packages</h2>
</a><a name="12212">
Java 1.1 has several new packages:<p>
</a><ul><a name="12215">
<li><code>java.beans</code>-Java Beans are software components that allow unrelated developers to write and ship Java components that can be composed together by end-user tools.
</a><a name="12783">
<li><code>java.math</code>-This package provides tools for mathematical manipulations. Currently a <code>BigInteger</code> class provides arbitrary-precision integer arithmetic, and <code>BigDecimal</code> provides arbitrary-precision decimal arithmetic.
</a><a name="12784">
<li><code>java.rmi</code>-Remote Method Invocation (RMI) allows you to create objects whose methods can be invoked by objects running in other Virtual Machines, including Virtual Machines running on other hosts. Because Java code can be downloaded and run securely, RMI lets you pass subtypes of the declared method parameters, and return subtypes of the declared type of the remote method. This allows you to pass object behavior as well as simple values. RMI provides remote procedure calls with a Java flavor and benefits.
</a><a name="12793">
<li><code>java.security</code>-This package and its subpackages provide some basic interfaces and classes for security-related operations, such as authentication, authorization, signed data, and encryption.
</a><a name="12794">
<li><code>java.sql</code>-This package provides tools for using relational databases.
</a><a name="12795">
<li><code>java.text</code>-This package provides text internationalization tools, such as date parsing and number formatting.
</a><a name="12229">
<li><code>java.util.zip</code>-You can use these classes for handling ZIP files.
</a></ul>

<!-- This file was created with Quadralay WebWorks Publisher 3.0.4 -->
<!-- -->
<!-- For more information on how this document, and how the rest of -->
<!-- this server was created, email yourEmail@xyzcorp.com -->
<!-- -->
<!-- Last updated: 03/26/97 16:55:45 -->

</Font></body>
</html>




