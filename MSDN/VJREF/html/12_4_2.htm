<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.4.2 Detailed Initialization Procedure</title>
<META NAME=MS-HAID CONTENT="12_4_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>12.4.2	 Detailed Initialization Procedure</h3>
<a name="44630"></a>
<p>
<a name="44631"></a>
Because Java is multithreaded, initialization of a class or interface requires careful 
synchronization, since some other thread may be trying to initialize the same class 
or interface at the same time. There is also the possibility that initialization of a 
class or interface may be requested recursively as part of the initialization of that 
class or interface; for example, a variable initializer in class <i>A</i> might invoke a 
method of an unrelated class <i>B</i>, which might in turn invoke a method of class <i>A</i>. 
The implementation of the Java Virtual Machine is responsible for taking care of 
synchronization and recursive initialization by using the following procedure. It 
assumes that the <code>Class</code> object has already been verified and prepared, and that the 
<code>Class</code> object contains state that indicates one of four situations:
<p><ul><a name="44632"></a>
<li>This <code>Class</code> object is verified and prepared but not initialized.
<a name="44633"></a>
<li>This <code>Class</code> object is being initialized by some particular thread <i>T</i>.
<a name="44634"></a>
<li>This <code>Class</code> object is fully initialized and ready for use.
<a name="44635"></a>
<li>This <code>Class</code> object is in an erroneous state, perhaps because the verification or preparation step failed, or because initialization was attempted and failed.
</ul><p><a name="44636"></a>
The procedure for initializing a class or interface is then as follows:
<p><ol>
<a name="44640"></a>
<li>Synchronize <a href="14_17.htm#79287">(&#167;14.17)</a> on the <code>Class</code> object that represents the class or interface to be initialized. This involves waiting until the current thread can obtain the lock for that object <a href="17_13.htm#28460">(&#167;17.13)</a>.
<a name="44644"></a>
<li>If initialization is in progress for the class or interface by some other thread, then <code>wait</code> <a href="20_1.htm#33394">(&#167;20.1.6)</a> on this <code>Class</code> object (which temporarily releases the lock). When the current thread awakens from the <code>wait</code>, repeat this step.
<a name="44648"></a>
<li>If initialization is in progress for the class or interface by the current thread, then this must be a recursive request for initialization. Release the lock on the <code>Class</code> object and complete normally.
<a name="44649"></a>
<li>If the class or interface has already been initialized, then no further action is required. Release the lock on the <code>Class</code> object and complete normally.
<a name="44650"></a>
<li>If the <code>Class</code> object is in an erroneous state, then initialization is not possible. Release the lock on the <code>Class</code> object and throw a <code>NoClassDefFoundError</code>.
<a name="44651"></a>
<li>Otherwise, record the fact that initialization of the <code>Class</code> object is now in progress by the current thread and release the lock on the <code>Class</code> object.
<a name="44652"></a>
<li>Next, if the <code>Class</code> object represents a class rather than an interface, and the superclass of this class has not yet been initialized, then recursively perform this entire procedure for the superclass. If necessary, verify and prepare the superclass first. If the initialization of the superclass completes abruptly because of a thrown exception, then lock this <code>Class</code> object, label it erroneous, notify all waiting threads <a href="20_1.htm#13790">(&#167;20.1.10)</a>, release the lock, and complete abruptly, throwing the same exception that resulted from initializing the superclass.
<a name="44656"></a>
<li>Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block, except that <code>final</code> class variables and fields of interfaces whose values are compile-time constants are initialized first (<a href="8_3_2.htm#38010">&#167;8.3.2.1</a>, <a href="9_3_1.htm#40720">&#167;9.3.1</a>, <a href="13_4_8.htm#45139">&#167;13.4.8</a>).
<a name="44657"></a>
<li>If the execution of the initializers completes normally, then lock this <code>Class</code> object, &#32;label it fully initialized, notify all waiting threads <a href="20_1.htm#13790">(&#167;20.1.10)</a>, release the lock, and complete this procedure normally.
<a name="44661"></a>
<li>Otherwise, the initializers must have completed abruptly by throwing some exception &#32;<i>E</i>. If the class of <i>E</i> is not <code>Error</code> or one of its subclasses, then create a new instance of the class <code>ExceptionInInitializerError</code>, with <i>E</i> as the argument, and use this object in place of <i>E</i> in the following step. But if a new instance of <code>ExceptionInInitializerError</code> cannot be created because an <code>OutOfMemoryError</code> occurs, then instead use an <code>OutOfMemoryError</code> object in place of <i>E</i> in the following step.
<a name="44665"></a>
<li>Lock the <code>Class</code> object, label it erroneous, notify all waiting threads <a href="20_1.htm#13790">(&#167;20.1.10)</a>, release the lock, and complete this procedure abruptly with reason <i>E</i> or its replacement as determined in the previous step.
</ol>
<a name="44666"></a>
(Due to a flaw in some early implementations of Java, a exception during class initialization was ignored, rather than causing an <code>ExceptionInInitializerError</code> 
as described here.) 
<p>

</body></html>
