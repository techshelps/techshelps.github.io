<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.4.6 Access to Members and Constructors</title>
<META NAME=MS-HAID CONTENT="13_4_6">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>13.4.6	 Access to Members and Constructors</h3>
<a name="47259"></a>
<p>
<a name="45115"></a>
Changing the declared access of a member or constructor to permit less access 
may break compatibility with pre-existing binaries, causing a linkage error to be 
thrown when these binaries are resolved. Less access is permitted if the access 
modifier is changed from default access to <code>private</code> access; from <code>protected</code> 
access to default or <code>private</code> access; or from <code>public</code> access to <code>protected</code>, 
default, or <code>private</code> access. Changing a member or constructor to permit less 
access is therefore not recommended for widely distributed classes.
<p><a name="45116"></a>
Perhaps surprisingly, Java is defined so that changing a member or constructor to be more accessible does not cause a linkage error when a subclass (already) defines a method to have less access. So, for example, if the package <code>points</code> defines the class <code>Point</code>:<p>
<pre><a name="45715"></a><code>package points;
</code></pre><p><pre><a name="45716"></a>
<code>public class Point {
</code><a name="45721"></a>	public int x, y;
<a name="45722"></a>	protected void print() {
<a name="45723"></a>		System.out.println("(" + x + "," + y + ")");
<a name="45724"></a>	}
<a name="45725"></a>}
</pre><p><a name="45726"></a>
used by the <code>Test</code> program:
<p><pre><a name="45727"></a>
class Test extends points.Point {
<a name="45733"></a>	protected void print() { System.out.println("Test"); }
<a name="45728"></a>	public static void main(String[] args) {
<a name="45730"></a>		Test t = new Test();
<a name="45729"></a>		t.print();
<a name="45731"></a>	}
<a name="45732"></a>}
</pre><p><a name="45734"></a>
then these classes compile and <code>Test</code> executes to produce the output:
<p><pre><a name="45735"></a>Test
</pre><p><a name="45736"></a>
If the method <code>print</code> in class <code>Point</code> is changed to be <code>public</code>, and then only the 
<code>Point</code> class is recompiled, and then executed with the previously existing binary 
for <code>Test</code> then no linkage error occurs, even though it is improper, at compile time, 
for a <code>public</code> method to be overridden by a <code>protected</code> method (as shown by the 
fact that the class <code>Test</code> could not be recompiled using this new <code>Point</code> class unless 
print were changed to be <code>public</code>.)
<p><a name="47725"></a>
Allowing superclasses to change <code>protected</code> methods to be <code>public</code> without breaking binaries of preexisting subclasses helps make Java binaries less fragile. The alternative, where such a change would cause a linkage error, would create additional binary incompatibilities with no apparent benefit.<p>


</body></html>
