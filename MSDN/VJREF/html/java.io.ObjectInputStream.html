<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<A NAME="_top_"></A>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Class ObjectInputStream</TITLE>
<H1>
  Class java.io.ObjectInputStream
</H1>
<A HREF="java.io.ObjectInputStream001.html">Class Members</A> | 
  <A HREF="Package-java.io.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=3><PRE>
<A HREF="java.lang.Object.html">java.lang.Object</A>
   |
   +----<A HREF="java.io.InputStream.html">java.io.InputStream</A>
           |
           +----java.io.ObjectInputStream
</PRE></FONT>

<P><B> public class <B>ObjectInputStream</B>
  <BR>
 extends <A HREF="java.io.InputStream.html">InputStream</A>
  <BR>
 implements <A HREF="java.io.ObjectInput.html">ObjectInput</A>, ObjectStreamConstants
<BR>
</B>
<P>

An ObjectInputStream deserializes primitive data and objects previously
 written using an ObjectOutputStream.
 ObjectOutputStream and ObjectInputStream can provide an application
 with persistent storage for graphs of objects when used with a
 FileOutputStream and FileInputStream respectively.
 ObjectInputStream is used to recover those objects previously
 serialized. Other uses include passing objects between hosts using
 a socket stream or for marshaling and unmarshaling arguments and
 parameters in a remote communication system.<P>
 ObjectInputStream ensures that the types of all objects in the
 graph created from the stream match the classes present in the
 Java Virtual Machine.  Classes are loaded as required using the
 standard mechanisms. <P>
 Only objects that support the java.io.Serializable or
 java.io.Externalizable interface can be read from streams.
 The method <STRONG>readObject</STRONG> is used to read an object
 from the stream.  Java's safe casting should be used to get the
 desired type.  In Java, strings and arrays are objects and are
 treated as objects during serialization. When read they need to be
 cast to the expected type.<P>
 Primitive data types can be read from the stream using the appropriate
 method on DataInput. <P>
 The default deserialization mechanism for objects restores the
 contents of each field to the value and type it had when it was written.
 Fields declared as transient or static are ignored by the
 deserialization process.  References to other objects cause those
 objects to be read from the stream as necessary.  Graphs of objects
 are restored correctly using a reference sharing mechanism.  New
 objects are always allocated when deserializing, which prevents
 existing objects from being overwritten. <P>
 Reading an object is analogous to running the constructors of a new
 object.  Memory is allocated for the object and initialized to zero
 (NULL).  No-arg constructors are invoked for the non-serializable
 classes and then the fields of the serializable classes are
 restored from the stream starting with the serializable class closest to
 java.lang.object and finishing with the object's most specifiec
 class. <P>
 For example to read from a stream as written by the example in
 ObjectOutputStream: <BR>
 </FONT><PRE>
	FileInputStream istream = new FileInputStream("t.tmp");
	ObjectInputStream p = new ObjectInputStream(istream);
	int i = p.readInt();
	String today = (String)p.readObject();
	Date date = (Date)p.readObject();
	istream.close();
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 Classes control how they are serialized by implementing either the
 java.io.Serializable or java.io.Externalizable interfaces.<P>
 Implementing the Serializable interface allows object serialization
 to save and restore the entire state of the object and it allows
 classes to evolve between the time the stream is written and the time it is
 read.  It automatically traverses references between objects,
 saving and restoring entire graphs.
 Serializable classes that require special handling during the
 serialization and deserialization process should implement both
 of these methods:<P>
 </FONT><PRE>
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException;
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException; 
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2><P>
 The readObject method is responsible for reading and restoring the
 state of the object for its particular class using data written to
 the stream by the corresponding writeObject method.  The method
 does not need to concern itself with the state belonging to its
 superclasses or subclasses.  State is restored by reading data from
 the ObjectInputStream for the individual fields and making
 assignments to the appropriate fields of the object.  Reading
 primitive data types is supported by DataInput. <P>
 Serialization does not read or assign values to the fields of any
 object that does not implement the java.io.Serializable interface.
 Subclasses of Objects that are not serializable can be
 serializable. In this case the non-serializable class must have a
 no-arg constructor to allow its fields to be initialized.  In this
 case it is the responsibility of the subclass to save and restore
 the state of the non-serializable class. It is frequently the case that
 the fields of that class are accessible (public, package, or
 protected) or that there are get and set methods that can be used
 to restore the state. <P>
 Any exception that occurs while deserializing an object will be
 caught by the ObjectInputStream and abort the reading process. <P>
 Implementing the Externalizable interface allows the object to
 assume complete control over the contents and format of the object's
 serialized form.  The methods of the Externalizable interface,
 writeExternal and readExternal, are called to save and restore the
 objects state.  When implemented by a class they can write and read
 their own state using all of the methods of ObjectOutput and
 ObjectInput.  It is the responsibility of the objects to handle any
 versioning that occurs.
<P>
<DL>
    <DT> <B>See Also:</B>
    <DD> <A HREF="java.io.DataInput.html">DataInput</A>, <A HREF="java.io.ObjectOutputStream.html">ObjectOutputStream</A>, <A HREF="java.io.Serializable.html">Serializable</A>
</DL>
<HR>

</BODY>
</HTML>
