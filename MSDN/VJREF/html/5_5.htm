<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.5 Casting Conversion</title>
<META NAME=MS-HAID CONTENT="5_5">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>5.5	 Casting Conversion</h2>
<a name="20232"></a>
<p>
<a name="176429"></a>
<p align=right><i>Sing away sorrow, cast away care. </i></p>
<a name="176961"></a>
<p align=right>-Miguel de Cervantes (1547-1616),<br><i>Don Quixote</i> (Lockhart's translation), Chapter viii</p>
<a name="20233"></a>
<p><i>Casting conversion</i> is applied to the operand of a cast operator <a href="15_15.htm#238146">(&#167;15.15)</a>: the type 
of the operand expression must be converted to the type explicitly named by the 
cast operator. Casting contexts allow the use of an identity conversion <a href="5_1_1.htm#25209">(&#167;5.1.1)</a>, a 
widening primitive conversion <a href="5_1_2.htm#25222">(&#167;5.1.2)</a>, a narrowing primitive conversion 
<a href="5_1_3.htm#175672">(&#167;5.1.3)</a>, a widening reference conversion <a href="5_1_4.htm#25215">(&#167;5.1.4)</a>, or a narrowing reference conversion <a href="5_1_5.htm#25379">(&#167;5.1.5)</a>. Thus casting conversions are more inclusive than assignment or 
method invocation conversions: a cast can do any permitted conversion other than 
a string conversion.
<p><a name="175729"></a>
Some casts can be proven incorrect at compile time; such casts result in a compile-time error.<p>
<a name="175719"></a>
A value of a primitive type can be cast to another primitive type by identity conversion, if the types are the same, or by a widening primitive conversion or a narrowing primitive conversion.<p>
<a name="175724"></a>
A value of a primitive type cannot be cast to a reference type by casting conversion, nor can a value of a reference type be cast to a primitive type.<p>
<a name="175725"></a>
The remaining cases involve conversion between reference types. The detailed rules for compile-time correctness checking of a casting conversion of a value of compile-time reference type <i>S</i><i></i> (source) to a compile-time reference type <i>T</i><em></em> (target) are as follows:<p>
<ul><a name="27459"></a>
<li>If <i>S</i><i></i> is a class type:
<ul>
<a name="27460"></a>
<li>If <i>T</i><em></em> is a class type, then <i>S</i><i></i> and <i>T</i><em></em> must be related classes-that is, <i>S</i><em></em> and <i>T</i><em></em> must be the same class, or <i>S</i><i></i> a subclass of <i>T</i><em>,</em> or <i>T</i><em></em> a subclass of <i>S</i><em></em>; otherwise a compile-time error occurs.
<a name="27461"></a>
<li>If <i>T</i><em></em> is an interface type:
<ul>
<a name="26664"></a>
<li>If <i>S</i><i></i> is not a <code>final</code> class <a href="8_1_2.htm#21613">(&#167;8.1.2)</a>, then the cast is always correct at compile time (because even if <i>S</i><i></i> does not implement <i>T</i>, a subclass of <i>S</i><i></i> might).
<a name="26668"></a>
<li>If <i>S</i><i></i> is a <code>final</code> class <a href="8_1_2.htm#21613">(&#167;8.1.2)</a>, then <i>S</i><i></i> must implement <i>T</i>,<em></em> or a compile-time error occurs.
</ul>
<a name="27505"></a>
<li>If <i>T</i><em></em> is an array type, then <i>S</i><i></i> must be the class <code>Object</code>, or a compile-time error occurs.
</ul>
<a name="27506"></a>
<li>If <i>S</i><i></i> is an interface type:
<ul>
<a name="27507"></a>
<li>If <i>T</i><em></em> is a class type that is not <code>final</code> <a href="8_1_2.htm#21613">(&#167;8.1.2)</a>, then the cast is always correct at compile time (because even if <i>T</i><em></em> does not implement <i>S</i>, a subclass of <i>T</i><em></em> might).
<a name="27508"></a>
<li>If <i>T</i><em></em> is a class type that is <code>final</code> <a href="8_1_2.htm#21613">(&#167;8.1.2)</a>, then <i>T</i><em></em> must implement <i>S</i>,<i></i> or a compile-time error occurs.
<a name="45656"></a>
<li>If <i>T</i><em></em> is an interface type and if <i>T</i><em></em> and <i>S</i><i></i> contain methods with the same signature <a href="8_4_2.htm#38649">(&#167;8.4.2)</a> but different return types, then a compile-time error occurs.
</ul>
<a name="53974"></a>
<li>If <i>S</i><em></em> is an array type <i>SC</i><code>[]</code>, that is, an array of components of type <i>SC</i><em></em>:
<ul>
<a name="53981"></a>
<li>If <i>T</i><em></em> is a class type, then if <i>T</i><em></em> is not <code>Object</code>, then a compile-time error occurs (because <code>Object</code> is the only class type to which arrays can be assigned).
<a name="28948"></a>
<li>If <i>T</i><em></em> is an interface type, then a compile-time error occurs unless <i>T</i> is the interface type <code>Cloneable</code>, the only interface implemented by arrays.
<a name="28949"></a>
<li>If <i>T</i><em></em> is an array type <i>TC</i><code>[]</code>, that is, an array of components of type <i>TC</i>, then a compile-time error occurs unless one of the following is true:
<ul>
<a name="176094"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are the same primitive type.
<a name="176095"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are reference types and type <i>SC</i><em></em> can be cast to <i>TC</i><em></em> by a recursive application of these compile-time rules for casting.
</ul>
</ul>
</ul><p><a name="174613"></a>
See <a href="chap08.htm">&#167;8</a> for the detailed specifications of classes, <a href="chap09.htm">&#167;9</a> for interfaces, and <a href="chap10.htm">&#167;10</a> for 
arrays.
<p><a name="27456"></a>
If a cast to a reference type is not a compile-time error, there are two cases:<p>
<ul><a name="26702"></a>
<li>The cast can be determined to be correct at compile time. A cast from the compile-time type <i>S</i><i></i> to compile-time type <i>T</i><em></em> is correct at compile time if and only if <i>S</i><i></i> can be converted to <i>T</i><em></em> by assignment conversion <a href="5_2.htm#170768">(&#167;5.2)</a>.
<a name="26706"></a>
<li>The cast requires a run-time validity check. If the value at run time is <code>null</code>, then the cast is allowed. Otherwise, let <i>R</i> be the class of the object referred to by the run-time reference value, and let <i>T</i><em></em> be the type named in the cast operator. A cast conversion must check, at run time, that the class <i>R</i> is assignment compatible with the type <i>T</i>, using the algorithm specified in <a href="5_2.htm#170768">&#167;5.2</a> but using the class <i>R</i> instead of the compile-time type <i>S</i><em></em> as specified there. (Note that <i>R</i> cannot be an interface when these rules are first applied for any given cast, but <i>R</i> may be an interface if the rules are applied recursively because the run-time reference value refers to an array whose element type is an interface type.) This modified algorithm is shown here:
<ul>
<a name="29070"></a>
<li>If <i>R</i> is an ordinary class (not an array class):
<ul>
<a name="29074"></a>
<li>If <i>T</i><em></em> is a class type, then <i>R</i><em></em> must be either the same class <a href="4_3_4.htm#52197">(&#167;4.3.4)</a> as <i>T</i><em></em> or a subclass of <i>T</i>, or a run-time exception is thrown.
<a name="29084"></a>
<li>If <i>T</i><em></em> is an interface type, then <i>R</i> must implement <a href="8_1_4.htm#34031">(&#167;8.1.4)</a> interface <i>T</i>, or a run-time exception is thrown.
<a name="29085"></a>
<li>If <i>T</i><em></em> is an array type, then a run-time exception is thrown.
</ul>
<a name="174679"></a>
<li>If <i>R</i><i></i> is an interface:
<ul>
<a name="174686"></a>
<li>If <i>T</i> is a class type, then <i>T</i> must be <code>Object</code> (<a href="4_3_2.htm#11055">&#167;4.3.2</a>, <a href="20_1.htm#14533">&#167;20.1</a>), or a run-time exception is thrown.
<a name="174687"></a>
<li>If <i>T</i> is an interface type, then <i>R</i> must be either the same interface as <i>T</i> or a subinterface of <i>T</i>,<i></i> or a run-time exception is thrown.
<a name="174682"></a>
<li>If <i>T</i> is an array type, then a run-time exception is thrown.
</ul>
<a name="29102"></a>
<li>If <i>R</i> is a class representing an array type <i>RC</i><code>[]</code>-that is, an array of components of type <i>RC</i><em>:</em>
<ul>
<a name="29109"></a>
<li>If <i>T</i><em></em> is a class type, then <i>T</i><em></em> must be <code>Object</code> (<a href="4_3_2.htm#11055">&#167;4.3.2</a>, <a href="20_1.htm#14533">&#167;20.1</a>), or a run-time exception is thrown.
<a name="29110"></a>
<li>If <i>T</i><em></em> is an interface type, then a run-time exception is thrown unless <i>T</i> is the interface type <code>Cloneable</code>, the only interface implemented by arrays (this case could slip past the compile-time checking if, for example, a reference to an array were stored in a variable of type <code>Object</code>).
<a name="29114"></a>
<li>If <i>T</i><em></em> is an array type <i>TC</i><em></em><code>[]</code>, that is, an array of components of type <i>TC</i><em>,</em> then a run-time exception is thrown unless one of the following is true:
<ul>
<a name="29118"></a>
<li><i>TC</i><em></em> and <i>RC</i><em></em> are the same primitive type.
<a name="29119"></a>
<li><i>TC</i><em></em> and <i>RC</i><em></em> are reference types and type <i>RC</i><em></em> can be cast to <i>TC</i><em></em> by a recursive application of these run-time rules for casting.
</ul>
</ul>
</ul>
</ul><p><a name="13146"></a>
If a run-time exception is thrown, it is a <code>ClassCastException</code> (<a href="11_5_1.htm#44287">&#167;11.5.1.1</a>, 
<a href="20_22.htm#14470">&#167;20.22</a>).
<p><a name="176364"></a>
Here are some examples of casting conversions of reference types, similar to the example in <a href="5_2.htm#170768">&#167;5.2</a>:<p>
<pre><a name="29290"></a>
public class Point { int x, y; }
<br><a name="29434"></a>public interface Colorable { void setColor(int color); }
<br><a name="29291"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="29348"></a>	int color;
<a name="26861"></a>	public void setColor(int color) { this.color = color; }
<a name="29293"></a>}
<br><br><a name="29294"></a>final class EndPoint extends Point { }
<br><a name="29295"></a>
class Test {
<a name="29296"></a>
	public static void main(String[] args) {
<a name="29297"></a>		Point p = new Point();
<a name="29298"></a>		ColoredPoint cp = new ColoredPoint();
<a name="29299"></a>		Colorable c;
<br><a name="29301"></a>
		// The following may cause errors at run time because
<a name="29302"></a>		// we cannot be sure they will succeed; this possibility
<a name="29303"></a>		// is suggested by the casts:
<a name="29304"></a>		cp = (ColoredPoint)p;							// p might not reference an
<a name="29380"></a>									// object which is a ColoredPoint
<a name="29381"></a>									// or a subclass of ColoredPoint
<a name="29307"></a>		c = (Colorable)p;							// p might not be Colorable
<br><a name="29309"></a>
		// The following are incorrect at compile time because
<a name="29310"></a>		// they can never succeed as explained in the text:
<a name="29311"></a>		Long l = (Long)p;							// compile-time error #1
<a name="50095"></a>		EndPoint e = new EndPoint();
<a name="29316"></a>		c = (Colorable)e;							// compile-time error #2
<br><a name="29313"></a>	}
<br><a name="29314"></a>}
</pre><p><a name="29315"></a>
Here the first compile-time error occurs because the class types <code>Long</code> and <code>Point</code> 
are unrelated (that is, they are not the same, and neither is a subclass of the other), 
so a cast between them will always fail.
<p><a name="176389"></a>
The second compile-time error occurs because a variable of type <code>EndPoint</code> can never reference a value that implements the interface <code>Colorable</code>. This is because <code>EndPoint</code> is a <code>final</code> type, and a variable of a <code>final</code> type always holds a value of the same run-time type as its compile-time type. Therefore, the run-time type of variable <code>e</code> must be exactly the type <code>EndPoint</code>, and type <code>EndPoint</code> does not implement <code>Colorable</code>.<p>
<a name="176390"></a>
Here is an example involving arrays <a href="chap10.htm">(&#167;10)</a>: <p>
<pre><a name="176391"></a>
class Point {
<a name="53226"></a>
	int x, y;
<br><a name="53241"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<br><a name="53227"></a>	public String toString() { return "("+x+","+y+")"; }<br>
}
<br><a name="30080"></a>public interface Colorable { void setColor(int color); }
<br><a name="30081"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="53235"></a>
	int color;
<a name="26864"></a>
	ColoredPoint(int x, int y, int color) {
<a name="53230"></a>		super(x, y); setColor(color);
<a name="53231"></a>	}
<br><br><a name="30084"></a>	public void setColor(int color) { this.color = color; }
<br><a name="53225"></a>	public String toString() {
<a name="53228"></a>		return super.toString() + "@" + color;
<a name="53229"></a>	}
<br><a name="30085"></a>}
<br><a name="30086"></a>
class Test {
<a name="30128"></a>
	public static void main(String[] args) {
<a name="30129"></a>		Point[] pa = new ColoredPoint[4];
<a name="30135"></a>		pa[0] = new ColoredPoint(2, 2, 12);
<a name="50097"></a>		pa[1] = new ColoredPoint(4, 5, 24);
<a name="30130"></a>		ColoredPoint[] cpa = (ColoredPoint[])pa;
<a name="30143"></a>		System.out.print("cpa: {");
<a name="30140"></a>		for (int i = 0; i &lt; cpa.length; i++)
<a name="30108"></a>			System.out.print((i == 0 ? " " : ", ") + cpa[i]);
<a name="53256"></a>		System.out.println(" }");
<a name="30099"></a>	}
<br><a name="30100"></a>}
</pre><p><a name="53223"></a>
This example compiles without errors and produces the output:
<p><pre><a name="53243"></a>cpa: { (2,2)@12, (4,5)@24, null, null }
</pre><p><a name="176370"></a>
The following example uses casts to compile, but it throws exceptions at run time, because the types are incompatible:<p>
<pre><a name="175285"></a>
public class Point { int x, y; }
<br><a name="29436"></a>public interface Colorable { void setColor(int color); }
<br><a name="29438"></a>
public class ColoredPoint extends Point implements Colorable 
{
<br><a name="29439"></a>	int color;
<br><br><a name="29441"></a>	public void setColor(int color) { this.color = color; }
<br><a name="29442"></a>}
<br><a name="176415"></a>
class Test {
<a name="13438"></a>
	public static void main(String[] args) {
<br><a name="29551"></a>		Point[] pa = new Point[100];
<br><a name="29560"></a>
		// The following line will throw a ClassCastException:
<a name="29460"></a>		ColoredPoint[] cpa = (ColoredPoint[])pa;
<br><br><a name="30037"></a>		System.out.println(cpa[0]);
<br><br><a name="13452"></a>		int[] shortvec = new int[2];
<br><br><a name="13453"></a>		Object o = shortvec;
<br><a name="29468"></a>
		// The following line will throw a ClassCastException:
<a name="13454"></a>		Colorable c = (Colorable)o;
<br><br><a name="30034"></a>		c.setColor(0);
<br><a name="13456"></a>	}
<br><a name="13457"></a>}
</pre><p>

</body></html>
