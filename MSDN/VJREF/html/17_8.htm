<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>17.8 Prescient Store Actions</title>
<META NAME=MS-HAID CONTENT="17_8">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>17.8	 Prescient Store Actions</h2>
<a name="45376"></a>
<p>
<a name="45377"></a>
If a variable is not declared <code>volatile</code>, then the rules in the previous sections are 
relaxed slightly to allow <i>store</i> actions to occur earlier than would otherwise be 
permitted. The purpose of this relaxation is to allow optimizing Java compilers to 
perform certain kinds of code rearrangement that preserve the semantics of properly synchronized programs but might be caught in the act of performing memory 
actions out of order by programs that are not properly synchronized.
<p><a name="45378"></a>
Suppose that a <i>store</i> by <i>T</i> of <i>V</i> would follow a particular <i>assign</i> by <i>T</i> of <i>V</i> according to the rules of the previous sections, with no intervening <i>load</i> or <i>assign</i> by <i>T</i> of <i>V</i>. Then that <i>store</i> action would send to the main memory the value that the <i>assign</i> action put into the working memory of thread <i>T</i>. The special rule allows the <i>store</i> action to instead occur before the <i>assign</i> action, if the following restrictions are obeyed:<p>
<ul><a name="45379"></a>
<li>If the <i>store</i> action occurs, the <i>assign</i> is bound to occur. (Remember, these are restrictions on what actually happens, not on what a thread plans to do. No fair performing a <i>store</i> and then throwing an exception before the <i>assign</i> occurs!)
<a name="45380"></a>
<li>No <i>lock</i> action intervenes between the relocated <i>store</i> and the <i>assign</i>.
<a name="45381"></a>
<li>No <i>load</i> of <i>V</i> intervenes between the relocated <i>store</i> and the <i>assign</i>.
<a name="45382"></a>
<li>No other <i>store</i> of <i>V</i> intervenes between the relocated <i>store</i> and the <i>assign</i>.
<a name="45383"></a>
<li>The <i>store</i> action sends to the main memory the value that the <i>assign</i> action will put into the working memory of thread <i>T</i>. 
</ul><p><a name="45384"></a>
This last property inspires us to call such an early <i>store</i> action <i>prescient</i>: it has to 
know ahead of time, somehow, what value will be stored by the <i>assign</i> that it 
should have followed. In practice, optimized compiled code will compute such 
values early (which is permitted if, for example, the computation has no side 
effects and throws no exceptions), store them early (before entering a loop, for 
example), and keep them in working registers for later use within the loop.
<p>

</body></html>
