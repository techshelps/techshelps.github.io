<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.1.2 Class Modifiers</title>
<META NAME=MS-HAID CONTENT="8_1_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>8.1.2	 Class Modifiers</h3>
<a name="21613"></a>
<p>
<a name="54718"></a>
A class declaration may include <i>class modifiers</i>.
<p><pre>
<i><i>ClassModifiers:<br>
	ClassModifier<br>
	ClassModifiers</i><code> </code><i>ClassModifier
</i></i>
<i><i>ClassModifier: one of<br>
	</i><code>public</code><i>&#32;</i><code>abstract&#32;final
</code></i></pre><p><a name="14169"></a>
The access modifier <code>public</code> is discussed in <a href="6_6.htm#33916">&#167;6.6</a>. A compile-time error occurs if 
the same modifier appears more than once in a class declaration. If two or more 
class modifiers appear in a class declaration, then it is customary, though not 
required, that they appear in the order consistent with that shown above in the production for <i>ClassModifier</i>.
<p><a name="34944"></a>
<h4>8.1.2.1	 abstract Classes</h4>
<p>
<a name="20269"></a>
<meta name="MS-HKWD" content="abstract">
An <code>abstract</code> class is a class that is incomplete, or to be considered incomplete. 
Only <code>abstract</code> classes may have <code>abstract</code> methods (<a href="8_4_3.htm#34484">&#167;8.4.3.1</a>, <a href="9_4.htm#78651">&#167;9.4</a>), that is, 
methods that are declared but not yet implemented. If a class that is not <code>abstract</code> 
contains an <code>abstract</code> method, then a compile-time error occurs. A class has 
<code>abstract</code> methods if any of the following is true:
<p><ul><a name="36417"></a>
<li>It explicitly contains a declaration of an <code>abstract</code> method <a href="8_4_3.htm#78188">(&#167;8.4.3)</a>.
<a name="14240"></a>
<li>It inherits an <code>abstract</code> method from its direct superclass <a href="8_1_3.htm#21723">(&#167;8.1.3)</a>.
<a name="14247"></a>
<li>A direct superinterface (<a href="8_1_4.htm#34031">&#167;8.1.4</a>) of the class declares or inherits a method (which is therefore necessarily <code>abstract</code>) and the class neither declares nor inherits a method that implements it.
</ul><p><a name="54865"></a>
In the example:
<p><pre><a name="54866"></a>
abstract class Point {
<a name="54867"></a>	int x = 1, y = 1;
<a name="54868"></a>	void move(int dx, int dy) {
<a name="54869"></a>		x += dx;
<a name="54870"></a>		y += dy;
<a name="54871"></a>		alert();
<a name="54872"></a>	}
<a name="54873"></a>	abstract void alert();
<a name="54874"></a>}
<br><a name="36437"></a>
abstract class ColoredPoint extends Point {
<a name="36438"></a>	int color;
<a name="36439"></a>}
<br><a name="54875"></a>
class SimplePoint extends Point {
<a name="54876"></a>	void alert() { }
<a name="54877"></a>}
</pre><p><a name="54878"></a>
a class <code>Point</code> is declared that must be declared <code>abstract</code>, because it contains a 
declaration of an <code>abstract</code> method named <code>alert</code>. The subclass of <code>Point</code> named<code> 
ColoredPoint</code> inherits the <code>abstract</code> method <code>alert</code>, so it must also be declared 
<code>abstract</code>. On the other hand, the subclass of <code>Point</code> named <code>SimplePoint</code> provides an implementation of <code>alert</code>, so it need not be <code>abstract</code>.
<p><a name="14273"></a>
A compile-time error occurs if an attempt is made to create an instance of an <code>abstract</code> class using a class instance creation expression <a href="15_8.htm#41147">(&#167;15.8)</a>. An attempt to instantiate an <code>abstract</code> class using the <code>newInstance</code> method of class <code>Class</code> <a href="20_3.htm#15088">(&#167;20.3.6)</a> will cause an <code>InstantiationException</code> <a href="11_5_1.htm#44285">(&#167;11.5.1)</a> to be thrown. Thus, continuing the example just shown, the statement:<p>
<pre><a name="54881"></a>	Point p = new Point();
</pre><p><a name="54883"></a>
would result in a compile-time error; the class <code>Point</code> cannot be instantiated 
because it is <code>abstract</code>. However, a <code>Point</code> variable could correctly be initialized 
with a reference to any subclass of <code>Point</code>, and the class <code>SimplePoint</code> is not 
<code>abstract</code>, so the statement:
<p><pre><a name="227781"></a>	Point p = new SimplePoint();
</pre><p><a name="227782"></a>
would be correct.
<p><a name="227783"></a>
A subclass of an <code>abstract</code> class that is not itself <code>abstract</code> may be instantiated, resulting in the execution of a constructor for the <code>abstract</code> class and, therefore, the execution of the field initializers for instance variables of that class. Thus, in the example just given, instantiation of a <code>SimplePoint</code> causes the default constructor and field initializers for <code>x</code> and <code>y</code> of <code>Point</code> to be executed.<p>
<a name="54900"></a>
It is a compile-time error to declare an <code>abstract</code> class type such that it is not possible to create a subclass that implements all of its <code>abstract</code> methods. This situation can occur if the class would have as members two <code>abstract</code> methods that have the same method signature <a href="8_4_2.htm#38649">(&#167;8.4.2)</a> but different return types. As an example, the declarations:<p>
<pre><a name="54908"></a>
interface Colorable { void setColor(int color); }
<a name="54909"></a>
abstract class Colored implements Colorable {
<a name="54910"></a>	abstract int setColor(int color);
<a name="54931"></a>}
</pre><p><a name="25369"></a>
result in a compile-time error: it would be impossible for any subclass of class 
<code>Colored</code> to provide an implementation of a method named <code>setColor</code>, taking one 
argument of type <code>int</code>, that can satisfy both <code>abstract</code> method specifications, 
because the one in interface <code>Colorable</code> requires the same method to return no 
value, while the one in class <code>Colored</code> requires the same method to return a value 
of type <code>int</code> <a href="8_4.htm#40420">(&#167;8.4)</a>.
<p><a name="36521"></a>
A class type should be declared <code>abstract</code> only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor <a href="8_6_8.htm#16830">(&#167;8.6.8)</a> of no arguments, make it <code>private</code>, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class <code>java.lang.Math</code> is an example of a class that cannot be instantiated; its declaration looks like this:<p>
<pre><a name="36522"></a>
public final class Math {
<br><a name="36523"></a>	private Math() { }							// never instantiate this class
<br><br><a name="36538"></a><i>	</i><i>declarations of class variables and methods
</i><br><a name="36524"></a>}
</pre><p><a name="54727"></a>
<h4>8.1.2.2	 final Classes</h4>
<p>
<a name="54729"></a>
<meta name="MS-HKWD" content="final">
A class can be declared <code>final</code> if its definition is complete and no subclasses are 
desired or required. A compile-time error occurs if the name of a <code>final</code> class 
appears in the <code>extends</code> clause <a href="8_1_3.htm#21723">(&#167;8.1.3)</a> of another <code>class</code> declaration; this implies 
that a <code>final</code> class cannot have any subclasses. A compile-time error occurs if a 
class is declared both <code>final</code> and <code>abstract</code>, because the implementation of such a 
class could never be completed <a href="8_1_2.htm#34944">(&#167;8.1.2.1)</a>.
<p><a name="36559"></a>
Because a <code>final</code> class never has any subclasses, the methods of a <code>final</code> class are never overridden <a href="8_4_6.htm#227927">(&#167;8.4.6.1)</a>.<p>


</Font></body></html>
