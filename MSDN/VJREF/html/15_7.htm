<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.7 Primary Expressions</title>
<META NAME=MS-HAID CONTENT="15_7">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>15.7	 Primary Expressions</h2>
<a name="23302"></a>
<p>
<a name="36225"></a>
Primary expressions include most of the simplest kinds of expressions, from 
which all others are constructed: literals, field accesses, method invocations, and 
array accesses. A parenthesized expression is also treated syntactically as a primary expression.
<p><pre>
<i>Primary:<br>
	PrimaryNoNewArray<br>
	ArrayCreationExpression
</i>
<i>PrimaryNoNewArray:<br>
	Literal<br>
<code>	this<br>
</code>	<code>( </code>Expression<code> )<br>
</code>	ClassInstanceCreationExpression<br>
	FieldAccess<br>
	MethodInvocation<br>
	ArrayAccess
</i></pre><p><a name="236508"></a>
As programming language grammars go, this part of the Java grammar is unusual, in two ways. First, one might expect simple names, such as names of local variables and method parameters, to be primary expressions. For technical reasons, names are lumped together with primary expressions a little later when postfix expressions are introduced <a href="15_13.htm#36254">(&#167;15.13)</a>.<p>
<a name="19353"></a>
The technical reasons have to do with allowing left-to-right parsing of Java programs with only one-token lookahead. Consider the expressions <code>(z[3])</code> and <code>(z[])</code>. The first is a parenthesized array access <a href="15_12.htm#239587">(&#167;15.12)</a> and the second is the start of a cast <a href="15_15.htm#238146">(&#167;15.15)</a>. At the point that the look-ahead symbol is <code>[</code>, a left-to-right parse will have reduced the <code>z</code> to the nonterminal <i>Name</i>. In the context of a cast we prefer not to have to reduce the name to a <i>Primary</i>, but if <i>Name</i> were one of the alternatives for <i>Primary</i>, then we could not tell whether to do the reduction (that is, we could not determine whether the current situation would turn out to be a parenthesized array access or a cast) without looking ahead two tokens, to the token following the <code>[</code>. The Java grammar presented here avoids the problem by keeping <i>Name</i> and <i>Primary</i> separate and allowing either in certain other syntax rules (those for <i>MethodInvocation</i>, <i>ArrayAccess</i>, <i>PostfixExpression</i>, but not for <i>FieldAccess,</i> because this is covered by <i>Name</i>). This strategy effectively defers the question of whether a <i>Name</i> should be treated as a <i>Primary</i> until more context can be examined. (Other problems remain with cast expressions; see <a href="19_1_5.htm#44559">&#167;19.1.5</a>.)<p>
<a name="36318"></a>
The second unusual feature avoids a potential grammatical ambiguity in the expression:<p>
<pre><a name="36319"></a>new int[3][3]
</pre><p><a name="36320"></a>
which in Java always means a single creation of a multidimensional array, but 
which, without appropriate grammatical finesse, might also be interpreted as 
meaning the same as:
<p><pre><a name="36321"></a>(new int[3])[3]
</pre><p><a name="36322"></a>
This ambiguity is eliminated by splitting the expected definition of <i>Primary</i> into 
<i>Primary</i> and <i>PrimaryNoNewArray</i>. (This may be compared to the splitting of 
<i>Statement</i> into <i>Statement</i> and <i>StatementNoShortIf</i> <a href="14_4.htm#32584">(&#167;14.4)</a> to avoid the "dangling 
<code>else</code>" problem.)
<p>

</body></html>
