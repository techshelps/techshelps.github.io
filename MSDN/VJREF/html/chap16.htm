</Font></body></html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16. Definite Assignment</title>
<META NAME=MS-HAID CONTENT="chap16">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
</head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"> 
<hr><br>
 
<p><strong>
CHAPTER
 16 </strong></p>

<h1> Definite Assignment</h1>
<a name="25980"></a>
<p>
<a name="25979"></a>
<a name="25981"></a>
<p><i>All the evolution we know of proceeds from the vague to the definite.</i><br>
<a name="45906"></a>
&#151;Charles Pierce</p>
<p>
<a name="25986"></a>
Each local variable must have a <i>definitely assigned</i> value when any access of 
its value occurs. An access to its value consists of the simple name of the variable 
occurring anywhere in an expression except as the left-hand operand of the simple 
assignment operator <code>=</code>.
<p><a name="25987"></a>
A Java compiler must carry out a specific conservative flow analysis to make sure that, for every access of a local variable, the local variable is definitely assigned before the access; otherwise a compile-time error must occur.<p>
<a name="29500"></a>
The remainder of this chapter is devoted to a precise explanation of the words "definitely assigned before". The idea is that an assignment to the local variable must occur on every possible execution path to the access from the beginning of the constructor, method, or static initializer that contains the access. The analysis takes into account the structure of statements and expressions; it also provides a special treatment of the expression operators <code>!</code>, <code>&amp;&amp;</code>, <code>||</code>, and <code>?&#32;:</code>, the operators <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>==</code>, and <code>!=</code> with <code>boolean</code> operands, and boolean-valued constant expressions. For example, a Java compiler recognizes that <code>k</code> is definitely assigned before its access (as an argument of a method invocation) in the code:<p>
<pre><a name="25989"></a>
{
<a name="25990"></a>	int k;
<a name="25991"></a>	if (v &gt; 0 &amp;&amp; (k = System.in.read()) &gt;= 0)
<a name="25992"></a>		System.out.println(k);
<a name="25993"></a>}
</pre><p><a name="25994"></a>
because the access occurs only if the value of the expression:
<p><pre><a name="25995"></a>v &gt; 0 &amp;&amp; (k = System.in.read()) &gt;= 0
</pre><p><a name="25996"></a>
is true, and the value can be <code>true</code> only if the assignment to <code>k</code> is executed (more 
properly, evaluated). Similarly, a Java compiler will recognize that in the code:
<p><pre><a name="25997"></a>
{
<a name="25998"></a>	int k;
<a name="25999"></a>	while (true) {
<a name="26000"></a>		k = n;
<a name="26001"></a>		if (k &gt;= 5) break;
<a name="26002"></a>		n = 6;
<a name="26003"></a>	}
<a name="26004"></a>	System.out.println(k);
<a name="26005"></a>}
</pre><p><a name="26006"></a>
the variable <code>k</code> is definitely assigned by the <code>while</code> statement because the condition 
expression <code>true</code> never has the value <code>false</code>, so only the <code>break</code> statement can 
cause the <code>while</code> statement to complete normally, and <code>k</code> is definitely assigned 
before the <code>break</code> statement.
<p><a name="26007"></a>
Except for the special treatment of certain boolean operators and of boolean-valued constant expressions, the values of expressions are not taken into account in the flow analysis. For example, a Java compiler must produce a compile-time error for the code:<p>
<pre><a name="26008"></a>
{
<a name="26009"></a>	int k;
<a name="26010"></a>	int n = 5;
<a name="26011"></a>	if (n &gt; 2)
<a name="26012"></a>		k = 3;
<a name="26013"></a>	System.out.println(k); // k is not "definitely assigned" before this
<a name="26014"></a>}
</pre><p><a name="26015"></a>
even though the value of <code>n</code> is known at compile time, and in principle it can be 
known at compile time that the assignment to <code>k</code> will always be executed (more 
properly, evaluated). A Java compiler must operate according to the rules laid out 
in this section. The rules recognize only constant expressions; in this example, the 
expression <code>n</code> <code>&gt;</code> <code>2</code> is not a constant expression as defined in <a href="15_27.htm#5313">&#167;15.27</a>. 
<p><a name="26019"></a>
As another example, a Java compiler will accept the code:<p>
<pre><a name="26020"></a>
void flow(boolean flag) {
<a name="26021"></a>	int k;
<a name="26022"></a>	if (flag)
<a name="26023"></a>		k = 3;
<a name="26024"></a>	else
<a name="26025"></a>		k = 4;
<a name="26026"></a>	System.out.println(k);
<a name="26027"></a>}
</pre><p><a name="26028"></a>
as far as definite assignment of <code>k</code> is concerned, because the rules outlined in this 
section allow it to tell that <code>k</code> is assigned no matter whether the flag is <code>true</code> or 
<code>false</code>. But the rules do not accept the variation:
<p><pre><a name="26029"></a>
void flow(boolean flag) {
<a name="26030"></a>	int k;
<a name="26031"></a>	if (flag)
<a name="26032"></a>		k = 3;
<a name="26033"></a>	if (!flag)
<a name="26034"></a>		k = 4;
<a name="26035"></a>	System.out.println(k); // k is not "definitely assigned" before this
<a name="26036"></a>}
</pre><p><a name="26037"></a>
and so compiling this program must cause a compile-time error to occur.
<p><a name="26038"></a>
In order to precisely specify all the cases of definite assignment, the rules in this section define two technical terms:<p>
<ul><a name="26039"></a>
<li>whether a local variable is <i>definitely assigned before</i> a statement or expression, and
<a name="26040"></a>
<li>whether a local variable is <i>definitely assigned after </i>a statement or expression.
</ul><p><a name="26041"></a>
In order to specify boolean-valued expressions, the latter notion is refined into two cases:<p>
<ul><a name="26042"></a>
<li>whether a local variable is <i>definitely assigned after</i> the expression <i>when true</i>, and
<a name="26043"></a>
<li>whether a local variable is <i>definitely assigned after</i> the expression <i>when false</i>.
</ul><p><a name="26044"></a>
Here <i>when true</i> and <i>when false</i> refer to the value of the expression. For example, 
the local variable k is definitely assigned a value after evaluation of the expression
<p><pre><a name="26045"></a><code>a &amp;&amp; ((k=m) &gt; 5)
</code></pre><p><a name="26046"></a>
when the expression is <code>true</code> but not when the expression is <code>false</code> (because if <code>a</code> is 
<code>false</code>, then the assignment to <code>k</code> is not executed (more properly, evaluated)).
<p><a name="26047"></a>
The statement "<i>V</i><i></i> is definitely assigned after <i>X</i>" (where <i>V</i><i></i> is a local variable and <i>X</i> is a statement or expression) means "<i>V</i><i></i> is definitely assigned after <i>X</i> if <i>X</i> completes normally". If <i>X</i> completes abruptly, the assignment may not have occurred, and the rules stated here take this into account. A peculiar consequence of this definition is that "<i>V</i><i></i> is definitely assigned after <code>break;</code>" is always true! Because a <code>break</code> statement never completes normally, it is vacuously true that <i>V</i><i></i> has been assigned a value if the <code>break</code> statement completes normally.<p>
<a name="26048"></a>
To shorten the rules, the customary abbreviation "iff" is used to mean "if and only if".<p>
<a name="26049"></a>
<p>
<a name="26050"></a>
Let <i>V</i><i></i> be a local variable. Let <i>a</i>, <i>b</i>, <i>c</i>, and <i>e </i>be expressions. Let <i>S</i><i></i> and <i>T</i><em></em> be statements.<p>


</Font></body></html>
