<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.4.5 Class Body and Member Declarations</title>
<META NAME=MS-HAID CONTENT="13_4_5">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>13.4.5	 Class Body and Member Declarations</h3>
<a name="45037"></a>
<p>
<a name="45038"></a>
No incompatibility with pre-existing binaries is caused by adding a class member 
that has the same name (for fields) or same name, signature, and return type (for 
methods) as a member of a superclass or subclass. References to the original field 
or method were resolved at compile time to a symbolic reference containing the 
name of the class in which they were declared. This makes compiled Java code 
more robust against changes than it might otherwise be. No error occurs even if 
the set of classes being linked would encounter a compile-time error. As an example, if the program:
<p><pre><a name="45039"></a>class Hyper { String h = "Hyper"; }
<a name="45040"></a>class Super extends Hyper { }
<a name="45041"></a>class Test extends Super {
<a name="45042"></a>	public static void main(String[] args) {
<a name="45043"></a>		String s = new Test().h;
<a name="45044"></a>		System.out.println(s);
<a name="45045"></a>	}
<a name="45046"></a>}
</pre><p><a name="45047"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45048"></a>Hyper
</pre><p><a name="45049"></a>
Suppose that a new version of class <code>Super</code> is then compiled:
<p><pre><a name="45050"></a>class Super extends Hyper { char h = 'h'; }
</pre><p><a name="45051"></a>
If the resulting binary is used with the existing binaries for <code>Hyper</code> and <code>Test</code>, then 
the output is still:
<p><pre><a name="45052"></a>Hyper
</pre><p><a name="45053"></a>
even though compiling the source for these binaries:
<p><pre><a name="45054"></a>class Hyper { String h = "Hyper"; }
<a name="45055"></a>class Super extends Hyper { char h = 'h'; }
<a name="45056"></a>class Test extends Super {
<a name="45057"></a>	public static void main(String[] args) {
<a name="45058"></a>		String s = new Test().h;
<a name="45059"></a>		System.out.println(s);
<a name="45060"></a>	}
<a name="45061"></a>}
</pre><p><a name="45062"></a>
would result in a compile-time error, because the <code>h</code> in the source code for <code>main</code> 
would now be construed as referring to the <code>char</code> field declared in <code>Super</code>, and a 
<code>char</code> value can't be assigned to a <code>String</code>.
<p><a name="45063"></a>
Deleting a class member or constructor that is not declared <code>private</code> may cause a linkage error if the member or constructor is used by a pre-existing binary, even if the member was an instance method that was overriding a superclass method. This is because, during resolution, the linker looks only in the class that was identified at compile time. Thus, if the program:<p>
<pre><a name="45064"></a>
class Hyper {
<a name="45065"></a>	void hello() { System.out.println("hello from Hyper"); }
<a name="45066"></a>}
<a name="45067"></a>
class Super extends Hyper {
<a name="45068"></a>	void hello() { System.out.println("hello from Super"); }
<a name="45069"></a>}
<a name="45070"></a>
class Test {
<a name="45071"></a>	public static void main(String[] args) {
<a name="45072"></a>		new Super().hello();
<a name="45073"></a>	}
<a name="45074"></a>}
</pre><p><a name="45075"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45076"></a>hello from Super
</pre><p><a name="45077"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45078"></a>class Super extends Hyper { }
</pre><p><a name="45079"></a>
If <code>Super</code> and <code>Hyper</code> are recompiled but not <code>Test</code>, then a <code>NoSuchMethodError</code> 
will result at link time, because the method <code>hello</code> is no longer declared in class 
<code>Super</code>.
<p><a name="45080"></a>
To preserve binary compatibility, methods should not be deleted; instead, "forwarding methods" should be used. In our example, replacing the declaration of <code>Super</code> with:<p>
<pre><a name="45081"></a>
class Super extends Hyper {
<a name="45082"></a>	void hello() { super.hello(); }
<a name="45083"></a>}
</pre><p><a name="45084"></a>
then recompiling <code>Super</code> and <code>Hyper</code> and executing these new binaries with the 
original binary for <code>Test</code>, produces the output:
<p><pre><a name="45085"></a>hello from Hyper
</pre><p><a name="45086"></a>
as might have naively been expected from the previous example.
<p><a name="45087"></a>
The <code>super</code> keyword can be used to access a method declared in a superclass, bypassing any methods declared in the current class. The expression:<p>
<pre><a name="45088"></a><code>super.</code><i>Identifier
</i></pre><p><a name="45089"></a>
is resolved, at compile time, to a method <i>M</i> declared in a particular superclass <i>S</i>. 
The method <i>M</i> must still be declared in that class at run time or a linkage error will 
result. If the method <i>M</i> is an instance method, then the method <i>MR</i> invoked at run 
time is the method with the same signature as <i>M</i> that is a member of the direct 
superclass of the class containing the expression involving <code>super</code>. Thus, if the 
program:
<p><pre><a name="45090"></a>
class Hyper {
<a name="45091"></a>	void hello() { System.out.println("hello from Hyper"); }
<a name="45092"></a>}
<a name="45093"></a>class Super extends Hyper { }
<a name="45094"></a>class Test extends Super {
<a name="45095"></a>
	public static void main(String[] args) {
<a name="45096"></a>		new Test().hello();
<a name="45097"></a>	}
<a name="45098"></a>
	void hello() {
<a name="45099"></a>		super.hello();
<a name="45100"></a>	}
<a name="45101"></a>}
</pre><p><a name="45102"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45103"></a>hello from Hyper
</pre><p><a name="45104"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45105"></a>
class Super extends Hyper {
<a name="45106"></a>	void hello() { System.out.println("hello from Super"); }
<a name="45107"></a>}
</pre><p><a name="45108"></a>
If <code>Super</code> and <code>Hyper</code> are recompiled but not <code>Test</code>, then running the new binaries 
with the existing binary of <code>Test</code> produces the output:
<p><pre><a name="45109"></a>hello from Super
</pre><p><a name="45110"></a>
as you might expect. (A flaw in some early versions of Java caused them to print:
<p><pre><a name="45111"></a>hello from Hyper
</pre><p><a name="45114"></a>
incorrectly.)
<p>

</body></html>
