<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>17.11 Example: Out-of-Order Writes</title>
<META NAME=MS-HAID CONTENT="17_11">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>17.11	 Example: Out-of-Order Writes</h2>
<a name="29188"></a>
<p>
<a name="29191"></a>
This example is similar to that in the preceding section, except that one method 
assigns to both variables and the other method reads both variables. Consider a 
class that has class variables <code>a</code> and <code>b</code> and methods <code>to</code> and <code>fro</code>:
<p><pre><a name="29192"></a>
class Simple {
<a name="29193"></a>	int a = 1, b = 2;
<a name="29194"></a>	void to() {
<a name="29195"></a>		a = 3;
<a name="29261"></a>		b = 4;
<a name="29196"></a>	}
<a name="29197"></a>	void fro() {
<a name="29265"></a>		System.out.println("a= " + a + ", b=" + b);
<a name="29276"></a>	}
<a name="29200"></a>}
</pre><p><a name="29201"></a>
Now suppose that two threads are created, and that one thread calls <code>to</code> while the 
other thread calls <code>fro</code>. What is the required set of actions and what are the ordering constraints?
<p><a name="29202"></a>
Let us consider the thread that calls <code>to</code>. According to the rules, this thread must perform an <i>assign</i> of <code>a</code> followed by an <i>assign</i> of <code>b</code>. That is the bare minimum required to execute a call to the method <code>to</code>. Because there is no synchronization, it is at the option of the implementation whether or not to <i>store</i> the assigned values back to main memory! Therefore the thread that calls <code>fro</code> may obtain either <code>1</code> or <code>3</code> for the value of <code>a</code>, and independently may obtain either <code>2</code> or <code>4</code> for the value of <code>b</code>.<p>
<a name="29315"></a>
Now suppose that <code>to</code> is <code>synchronized</code> but <code>fro</code> is not:<p>
<pre><a name="29318"></a>
class SynchSimple {
<a name="29319"></a>	int a = 1, b = 2;
<a name="29320"></a>	synchronized void to() {
<a name="29321"></a>		a = 3;
<a name="29322"></a>		b = 4;
<a name="29323"></a>	}
<a name="29324"></a>	void fro() {
<a name="29325"></a>		System.out.println("a= " + a + ", b=" + b);
<a name="29326"></a>	}
<a name="29327"></a>}
</pre><p><a name="29316"></a>
In this case the method <code>to</code> will be forced to <i>store</i> the assigned values back to main 
memory before the <i>unlock</i> action at the end of the method. The method <code>fro</code> must, 
of course, use <code>a</code> and <code>b</code> (in that order) and so must <i>load</i> values for <code>a</code> and <code>b</code> from 
main memory.
<p><a name="29336"></a>
The total set of actions may be pictured as follows:<p><img src="17anc2.gif">
<p><a name="29234"></a>
Here an arrow from action <i>A</i> to action <i>B</i> indicates that <i>A</i> must precede <i>B</i>.
<p><a name="29235"></a>
In what order may the actions by the main memory occur? Note that the rules do not require that <i>write</i> <code>a</code> occur before <i>write</i> <code>b</code>; neither do they require that <i>read</i> <code>a</code> occur before <i>read</i> <code>b</code>. Also, even though method <code>to</code> is <code>synchronized</code>, method <code>fro</code> is not <code>synchronized</code>, so there is nothing to prevent the <i>read</i> actions from occurring between the <i>lock</i> and <i>unlock</i> actions. (The point is that declaring one method <code>synchronized</code> does not of itself make that method behave as if it were atomic.)<p>
<a name="29398"></a>
As a result, the method <code>fro</code> could still obtain either <code>1</code> or <code>3</code> for the value of <code>a</code>, and independently could obtain either <code>2</code> or <code>4</code> for the value of <code>b</code>. In particular, <code>fro</code> might observe the value <code>1</code> for <code>a</code> and <code>4</code> for <code>b</code>. Thus, even though <code>to</code> does an <i>assign</i> to <code>a</code> and then an <i>assign</i> to <code>b</code>, the <i>write</i> actions to main memory may be observed by another thread to occur as if in the opposite order.<p>
<a name="45366"></a>
<p>
<a name="45367"></a>
<p>
<a name="45368"></a>
<p>
<a name="45369"></a>
<p>
<a name="45669"></a>
<p>
<a name="45370"></a>
<p>
<a name="29431"></a>
Finally, suppose that <code>to</code> and <code>fro</code> are both <code>synchronized</code>:<p>
<pre><a name="29432"></a>
class SynchSynchSimple {
<a name="29433"></a>	int a = 1, b = 2;
<a name="29434"></a>	synchronized void to() {
<a name="29435"></a>		a = 3;
<a name="29436"></a>		b = 4;
<a name="29437"></a>	}
<a name="29438"></a>	synchronized void fro() {
<a name="29439"></a>		System.out.println("a= " + a + ", b=" + b);
<a name="29440"></a>	}
<a name="29441"></a>}
</pre><p><a name="29386"></a>
In this case, the actions of method <code>fro</code> cannot be interleaved with the actions of method <code>to</code>, and so <code>fro</code> will print either "<code>a=1, b=2</code>" or "<code>a=3, b=4</code>".<p>


</body></html>
