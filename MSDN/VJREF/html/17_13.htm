<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>17.13 Locks and Synchronization</title>
<META NAME=MS-HAID CONTENT="17_13">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>17.13	 Locks and Synchronization</h2>
<a name="28460"></a>
<p>
<a name="28461"></a>
There is a lock associated with every object. The Java language does not provide a 
way to perform separate <i>lock</i> and <i>unlock</i> actions; instead, they are implicitly performed by high-level constructs that arrange always to pair such actions correctly. 
(The Java Virtual Machine, however, provides separate <i>monitorenter</i> and <i>monitorexit</i> instructions that implement the <i>lock</i> and <i>unlock</i> actions.)
<p><a name="28465"></a>
The <code>synchronized</code> statement <a href="14_17.htm#79287">(&#167;14.17)</a> computes a reference to an object; it then attempts to perform a <i>lock</i> action on that object and does not proceed further until the <i>lock</i> action has successfully completed. (A <i>lock</i> action may be delayed because the rules about locks can prevent the main memory from participating until some other thread is ready to perform one or more <i>unlock</i> actions.) After the lock action has been performed, the body of the <code>synchronized</code> statement is executed. If execution of the body is ever completed, either normally or abruptly, an <i>unlock</i> action is automatically performed on that same lock.<p>
<a name="28469"></a>
A <code>synchronized</code> method <a href="8_4_3.htm#55408">(&#167;8.4.3.5)</a> automatically performs a <i>lock</i> action when it is invoked; its body is not executed until the <i>lock</i> action has successfully completed. If the method is an instance method, it locks the lock associated with the instance for which it was invoked (that is, the object that will be known as <code>this</code> during execution of the body of the method). If the method is <code>static</code>, it locks the lock associated with the <code>Class</code> object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an <i>unlock</i> action is automatically performed on that same lock.<p>
<a name="28470"></a>
Best practice is that if a variable is ever to be assigned by one thread and used or assigned by another, then all accesses to that variable should be enclosed in <code>synchronized</code> methods or <code>synchronized</code> statements.<p>
<a name="45472"></a>
Java does not prevent, nor require detection of, deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that don't deadlock, if necessary.<p>


</body></html>
