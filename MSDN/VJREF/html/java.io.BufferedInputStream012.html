<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BufferedInputStream.reset</TITLE></HEAD>
<H3>
<A NAME="reset">BufferedInputStream.reset</A></H3>
<P>
<A HREF="java.io.BufferedInputStream.html">Class Overview</A> | <A HREF="java.io.BufferedInputStream001.html">Class Members</A> | 
  <A HREF="Package-java.io.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>

<H5>
<A NAME="reset()">Syntax</A></H5>
<B>
 public synchronized void reset() throws <A HREF="java.io.IOException.html">IOException</A>
</B>
<H5>Description</H5>
 Repositions this stream to the position at the time the 
 <B>mark</B> method was last called on this input stream. 
 <P>
 If the stream has not been marked, or if the mark has been invalidated,
 an IOException is thrown. Stream marks are intended to be used in
 situations where you need to read ahead a little to see what's in
 the stream. Often this is most easily done by invoking some
 general parser. If the stream is of the type handled by the
 parser, it just chugs along happily. If the stream is not of
 that type, the parser should toss an exception when it fails. If an
 exception gets tossed within readlimit bytes, the parser will allow the
 outer code to reset the stream and to try another parser.
<P>
  <H5>
Exceptions</H5>
</B> <A HREF="java.io.IOException.html">IOException</A>
     if this stream has not been marked or
               if the mark has been invalidated.
    <H5>
Overrides</H5>
</B>
     <A HREF="java.io.FilterInputStream009.html#reset()">reset</A> in class <A HREF="java.io.FilterInputStream.html">FilterInputStream</A>
    <H5>
See Also</H5>
</B>
     <A HREF="java.io.BufferedInputStream011.html#mark(int)">mark</A>
  
<P>

</BODY>
</HTML>
