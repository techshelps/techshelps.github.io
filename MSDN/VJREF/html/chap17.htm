</Font></body></html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>17. Threads and Locks</title>
<META NAME=MS-HAID CONTENT="chap17">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
</head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"> 
<hr><br>
 
<p><strong>
CHAPTER
 17 </strong></p>

<h1> Threads and Locks</h1>
<a name="30206"></a>
<p>
<a name="26250"></a>
<a name="44126"></a>
<p><i>And oft-times in the most forbidding den<br>
Of solitude, with love of science strong,<br>
How patiently the yoke of thought they bear;<br>
How subtly glide its finest threads along!</i><br>
<a name="45490"></a>
&#151;William Wordsworth, Monks and Schoolmen,in Ecclesiastical Sonnets (1822)</p>
<p>
<a name="44127"></a>
While most of the discussion in the preceding chapters is concerned only with 
the behavior of Java code as executed a single statement or expression at a time, 
that is, by a single <i>thread</i>, each Java Virtual Machine can support many threads of 
execution at once. These threads independently execute Java code that operates on 
Java values and objects residing in a shared main memory. Threads may be supported by having many hardware processors, by time-slicing a single hardware 
processor, or by time-slicing many hardware processors.
<p><a name="28270"></a>
Java supports the coding of programs that, though concurrent, still exhibit deterministic behavior, by providing mechanisms for <i>synchronizing</i> the concurrent activity of threads. To synchronize threads, Java uses <i>monitors</i>, which are a high-level mechanism for allowing only one thread at a time to execute a region of code protected by the monitor. The behavior of monitors is explained in terms of <i>locks</i>; there is a lock associated with each object.<p>
<a name="29608"></a>
The <code>synchronized</code> statement <a href="14_17.htm#79287">(&#167;14.17)</a> performs two special actions relevant only to multithreaded operation: (1) after computing a reference to an object but before executing its body, it <i>locks</i> a lock associated with the object, and (2) after execution of the body has completed, either normally or abruptly, it <i>unlocks</i> that same lock. As a convenience, a method may be declared <code>synchronized</code>; such a method behaves as if its body were contained in a <code>synchronized</code> statement.<p>
<a name="29615"></a>
The methods <code>wait</code> (<a href="20_1.htm#33394">&#167;20.1.6</a>, <a href="20_1.htm#14926">&#167;20.1.7</a>, <a href="20_1.htm#32520">&#167;20.1.8</a>), <code>notify</code> <a href="20_1.htm#13789">(&#167;20.1.9)</a>, and <code>notifyAll</code> &#32;<a href="20_1.htm#13790">(&#167;20.1.10)</a> of class <code>Object</code> support an efficient transfer of control from one thread to another. Rather than simply "spinning" (repeatedly locking and unlocking an object to see whether some internal state has changed), which consumes &#32;computational effort, a thread can suspend itself using <code>wait</code> until such time as another thread awakens it using <code>notify</code>. This is especially appropriate in situations where threads have a producer-consumer relationship (actively cooperating on a common goal) rather than a mutual exclusion relationship (trying to avoid conflicts while sharing a common resource).<p>
<a name="28284"></a>
As a thread executes code, it carries out a sequence of actions. A thread may <i>use</i> the value of a variable or <i>assign</i> it a new value. (Other actions include arithmetic operations, conditional tests, and method invocations, but these do not involves variables directly.) If two or more concurrent threads act on a shared variable, there is a possibility that the actions on the variable will produce timing-dependent results. This dependence on timing is inherent in concurrent programming, producing one of the few places in Java where the result of executing a program is not determined solely by this specification.<p>
<a name="28285"></a>
Each thread has a working memory, in which it may keep copies of the values of variables from the main memory that is shared between all threads. To access a shared variable, a thread usually first obtains a lock and flushes its working memory. This guarantees that shared values will be thereafter be loaded from the shared main memory to the threads working memory. When a thread unlocks a lock it guarantees the values it holds in its working memory will be written back to the main memory.<p>
<a name="28524"></a>
This chapter explains the interaction of threads with the main memory, and thus with each other, in terms of certain low-level actions. There are rules about the order in which these actions may occur. These rules impose constraints on any implementation of Java, and a Java programmer may rely on the rules to predict the possible behaviors of a concurrent Java program. The rules do, however, intentionally give the implementor certain freedoms; the intent is to permit certain standard hardware and software techniques that can greatly improve the speed and efficiency of concurrent code.<p>
<a name="28527"></a>
Briefly put, these are the important consequences of the rules:<p>
<ul><a name="28549"></a>
<li>Proper use of synchronization constructs will allow reliable transmission of values or sets of values from one thread to another through shared variables.
<a name="28553"></a>
<li>When a thread uses the value of a variable, the value it obtains is in fact a value stored into the variable by that thread or by some other thread. This is true even if the program does not contain code for proper synchronization. For example, if two threads store references to different objects into the same reference value, the variable will subsequently contain a reference to one object or the other, not a reference to some other object or a corrupted reference value. (There is a special exception for <code>long</code> and <code>double</code> values; see <a href="17_4.htm#28733">&#167;17.4</a>.)
<a name="28556"></a>
<li>In the absence of explicit synchronization, a Java implementation is free to update the main memory in an order that may be surprising. Therefore the programmer who prefers to avoid surprises should use explicit synchronization.
</ul><p>

</Font></body></html>
