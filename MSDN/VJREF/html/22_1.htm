<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>22.1 The Interface java.io.DataInput</title>
<META NAME=MS-HAID CONTENT="22_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h1>22.1	 The Interface java.io.DataInput</h1>
<a name="28762"></a>
<p>
<a name="28763"></a>
The <code>DataInput</code> interface provides for reading bytes from a binary stream and 
reconstructing from them data in any of the Java primitive types. There is also a 
facility for reconstructing a <code>String</code> from data in Java modified UTF-8 format.
<p><a name="28767"></a>
The <code>DataOutput</code> interface <a href="22_2.htm#28931">(&#167;22.2)</a> supports the creation of binary output data suitable for reading back in through the <code>DataInput</code> interface.<p>
<a name="28768"></a>
The <code>DataInput</code> interface is implemented by classes <code>DataInputStream</code> <a href="22_11.htm#28623">(&#167;22.11)</a> and <code>RandomAccessFile</code> <a href="22_23.htm#27738">(&#167;22.23)</a>.<p>
<pre><a name="28775"></a>public interface <code><b>DataInput</b></code> {
<a name="28776"></a>	public void <code><b>readFully</b></code>(byte[] b)
<a name="32257"></a>		throws IOException, NullPointerException;
<a name="28777"></a>	public void <code><b>readFully</b></code>(byte[] b, int off, int len)
<a name="28778"></a>		throws IOException, NullPointerException,
<a name="32260"></a>			IndexOutOfBoundsException;
<a name="28779"></a>	public int <code><b>skipBytes</b></code>(int n) throws IOException;
<a name="28780"></a>	public boolean <code><b>readBoolean</b></code>() throws IOException;
<a name="28781"></a>	public byte <code><b>readByte</b></code>() throws IOException;
<a name="28782"></a>	public int <code><b>readUnsignedByte</b></code>() throws IOException;
<a name="28783"></a>	public short <code><b>readShort</b></code>() throws IOException;
<a name="28784"></a>	public int <code><b>readUnsignedShort</b></code>() throws IOException;
<a name="28785"></a>	public char <code><b>readChar</b></code>() throws IOException;
<a name="28786"></a>	public int <code><b>readInt</b></code>() throws IOException;
<a name="28787"></a>	public long <code><b>readLong</b></code>() throws IOException;
<a name="28788"></a>	public float <code><b>readFloat</b></code>() throws IOException;
<a name="28789"></a>	public double <code><b>readDouble</b></code>() throws IOException;
<a name="28790"></a>	public String <code><b>readLine</b></code>() throws IOException;
<a name="28791"></a>	public String <code><b>readUTF</b></code>() throws IOException;
<a name="28792"></a>	public final static String <code><b>readUTF</b></code>(DataInput in)
<a name="28793"></a>		throws IOException;
<a name="28794"></a>}
</pre><p><a name="30226"></a>
It is generally true of all the reading routines in this interface that if end of file is reached before the desired number of bytes has been read, an <code>EOFException</code> (which is a kind of <code>IOException</code>) is thrown. If any byte cannot be read for any reason other than end of file, an <code>IOException</code> other than <code>EOFException</code> is thrown. In particular, an <code>IOException</code> may be thrown if the input stream has been closed <a href="22_3.htm#28187">(&#167;22.3.6)</a>.<p>
<a name="28801"></a>
<p><strong>22.1.1	</strong> <code>public void readFully(byte[] b)<br>throws IOException, NullPointerException;</code>
<p>
<a name="28802"></a>
The general contract of <code>readFully(b)</code> is that it reads some bytes from an input 
stream and stores them into the buffer array <code>b</code>. The number of bytes read is equal 
to the length of <code>b</code>.
<p><a name="31275"></a>
This method blocks until one of the following conditions occurs:<p>
<ul><a name="31276"></a>
<li><code>b.length</code> bytes of input data are available, in which case a normal return is made.
<a name="31277"></a>
<li>End of file is detected, in which case an <code>EOFException</code> is thrown.
<a name="31278"></a>
<li>An I/O error occurs, in which case an <code>IOException</code> other than <code>EOFException</code> is thrown.
</ul><p><a name="28804"></a>
If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="28805"></a>
If <code>b.length</code> is zero, then no bytes are read. Otherwise, the first byte read is stored into element <code>b[0]</code>, the next one into <code>b[1]</code>, and so on.<p>
<a name="31283"></a>
If an exception is thrown from this method, then it may be that some but not all bytes of <code>b</code> have been updated with data from the input stream.<p>
<a name="28807"></a>
<p><strong>22.1.2	</strong> <code>public void readFully(byte[] b, int off, int len)<br>throws IOException, NullPointerException,<br> &#32; &#32; &#32;IndexOutOfBoundsException</code>
<p>
<a name="28808"></a>
The general contract of <code>readFully(b, off, len)</code> is that it reads <code>len</code> bytes from 
an input stream.
<p><a name="28809"></a>
This method blocks until one of the following conditions occurs:<p>
<ul><a name="31270"></a>
<li><code>len</code> bytes of input data are available, in which case a normal return is made.
<a name="31271"></a>
<li>End of file is detected, in which case an <code>EOFException</code> is thrown.
<a name="31273"></a>
<li>An I/O error occurs, in which case an <code>IOException</code> other than <code>EOFException</code> is thrown.
</ul><p><a name="28810"></a>
If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="28811"></a>
If <code>off</code> is negative, or <code>len</code> is negative, or <code>off+len</code> is greater than the length of the array <code>b</code>, then an IndexOutOfBoundsException is thrown.<p>
<a name="28812"></a>
If <code>len</code> is zero, then no bytes are read. Otherwise, the first byte read is stored into element <code>b[off]</code>, the next one into <code>b[off+1]</code>, and so on. The number of bytes read is, at most, equal to <code>len</code>.<p>
<a name="31291"></a>
If an exception is thrown from this method, then it may be that some but not all bytes of <code>b</code> in positions <code>off</code> through <code>off+len-1</code> have been updated with data from the input stream.<p>
<a name="28814"></a>
<p><strong>22.1.3	</strong> <code>public int skipBytes(int n) throws IOException</code>
<p>
<a name="28815"></a>
The general contract of <code>skipBytes</code> is that it makes an attempt to skip over <code>n</code> bytes 
of data from the input stream, discarding the skipped bytes. However, it may skip 
over some smaller number of bytes, possibly zero. This may result from any of a 
number of conditions; reaching end of file before <code>n</code> bytes have been skipped is 
only one possibility. This method never throws an <code>EOFException</code>. The actual 
number of bytes skipped is returned.
<p><a name="28817"></a>
<p><strong>22.1.4	</strong> <code>public boolean readBoolean() throws IOException;</code>
<p>
<a name="28818"></a>
The general contract of <code>readBoolean</code> is that it reads one input byte and returns 
<code>true</code> if that byte is nonzero, <code>false</code> if that byte is zero.
<p><a name="28819"></a>
This method is suitable for reading the byte written by the <code>writeBoolean</code> method of interface <code>DataOutput</code> <a href="22_2.htm#28974">(&#167;22.2.4)</a>.<p>
<a name="28824"></a>
<p><strong>22.1.5	</strong> <code>public byte readByte() throws IOException</code>
<p>
<a name="28825"></a>
The general contract of <code>readByte</code> is that it reads and returns one input byte. The 
byte is treated as a signed value in the range <code>-128</code> through <code>127</code>, inclusive.
<p><a name="28826"></a>
This method is suitable for reading the byte written by the <code>writeByte</code> method of interface <code>DataOutput</code> <a href="22_2.htm#28981">(&#167;22.2.5)</a>.<p>
<a name="28831"></a>
<p><strong>22.1.6	</strong> <code>public int readUnsignedByte() throws IOException</code>
<p>
<a name="28832"></a>
The general contract of <code>readUnsignedByte</code> is that it reads one input byte, zero-
extends it to type <code>int</code>, and returns the result, which is therefore in the range <code>0</code> 
through <code>255</code>.
<p><a name="28833"></a>
This method is suitable for reading the byte written by the <code>writeByte</code> method of interface <code>DataOutput</code> <a href="22_2.htm#28981">(&#167;22.2.5)</a> if the argument to <code>writeByte</code> was intended to be a value in the range <code>0</code> through <code>255</code>.<p>
<a name="28838"></a>
<p><strong>22.1.7	</strong> <code>public short readShort() throws IOException</code>
<p>
<a name="28839"></a>
The general contract of <code>readShort</code> is that it reads two input bytes and returns a 
<code>short</code> value. Let <code>a</code> be the first byte read and <code>b</code> be the second byte. The value 
returned is:
<p><pre><a name="31301"></a><code>(short)((a &lt;&lt; 8) | (b &amp; 0xff))
</code></pre><p><a name="28840"></a>
This method is suitable for reading the bytes written by the <code>writeShort</code> method of interface <code>DataOutput</code> <a href="22_2.htm#28988">(&#167;22.2.6)</a>.<p>
<a name="28845"></a>
<p><strong>22.1.8	</strong> <code>public int readUnsignedShort() throws IOException</code>
<p>
<a name="28846"></a>
The general contract of <code>readUnsignedShort</code> is that it reads two input bytes and 
returns an <code>int</code> value in the range <code>0</code> through <code>65535</code>. Let <code>a</code> be the first byte read and 
<code>b</code> be the second byte. The value returned is:
<p><pre><a name="28847"></a><code>(((a &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
</code></pre><p><a name="28848"></a>
This method is suitable for reading the bytes written by the <code>writeShort</code> method of interface <code>DataOutput</code> <a href="22_2.htm#28988">(&#167;22.2.6)</a> if the argument to <code>writeShort</code> was intended to be a value in the range <code>0</code> through <code>65535</code>.<p>
<a name="28853"></a>
<p><strong>22.1.9	</strong> <code>public char readChar() throws IOException</code>
<p>
<a name="28854"></a>
The general contract of <code>readChar</code> is that it reads two input bytes and returns a 
<code>char</code> value. Let <code>a</code> be the first byte read and <code>b</code> be the second byte. The value 
returned is:
<p><pre><a name="31302"></a><code>(char)((a &lt;&lt; 8) | (b &amp; 0xff))
</code></pre><p><a name="28855"></a>
This method is suitable for reading bytes written by the <code>writeChar</code> method of interface <code>DataOutput</code> <a href="22_2.htm#28997">(&#167;22.2.7)</a>.<p>
<a name="28860"></a>
<p><strong>22.1.10	</strong> <code>public int readInt() throws IOException</code>
<p>
<a name="28861"></a>
The general contract of <code>readInt</code> is that it reads four input bytes and returns an 
<code>int</code> value. Let <code>a</code> be the first byte read, <code>b</code> be the second byte, <code>c</code> be the third byte, 
and <code>d</code> be the fourth byte. The value returned is:
<p><pre><a name="28862"></a>
<code>(((a &amp; 0xff) &lt;&lt; 24) | ((b &amp; 0xff) &lt;&lt; 16) |
</code><a name="28864"></a><code> &#32;((c &amp; 0xff) &lt;&lt; &#32; &#32;8) | (d &amp; 0xff))
</code></pre><p><a name="28866"></a>
This method is suitable for reading bytes written by the <code>writeInt</code> method of interface <code>DataOutput</code> <a href="22_2.htm#29006">(&#167;22.2.8)</a>.<p>
<a name="28871"></a>
<p><strong>22.1.11	</strong> <code>public long readLong() throws IOException</code>
<p>
<a name="28872"></a>
The general contract of <code>readLong</code> is that it reads eight input bytes and returns a 
<code>long</code> value. Let <code>a</code> be the first byte read, <code>b</code> be the second byte, <code>c</code> be the third byte, <code>d</code> 
be the fourth byte, <code>e</code> be the fifth byte, <code>f</code> be the sixth byte, <code>g</code> be the seventh byte, 
and <code>h</code> be the eighth byte. The value returned is:
<p><pre><a name="28873"></a>
<code>(((long)(a &amp; 0xff) &lt;&lt; 56) |
</code><a name="28874"></a><code> &#32;((long)(b &amp; 0xff) &lt;&lt; 48) |
</code><a name="28875"></a><code> &#32;((long)(c &amp; 0xff) &lt;&lt; &#32;40) |
</code><a name="28876"></a><code> &#32;((long)(d &amp; 0xff) &lt;&lt; 32) |
</code><a name="28877"></a><code> &#32;((long)(e &amp; 0xff) &lt;&lt; &#32;24) |
</code><a name="28878"></a><code> &#32;((long)(f &amp; 0xff) &lt;&lt; 16) |
</code><a name="28879"></a><code> &#32;((long)(g &amp; 0xff) &lt;&lt; &#32; &#32;8) |
</code><a name="28880"></a><code> &#32;((long)(h &amp; 0xff)))
</code></pre><p><a name="28881"></a>
This method is suitable for reading bytes written by the <code>writeLong</code> method of interface <code>DataOutput</code> <a href="22_2.htm#29017">(&#167;22.2.9)</a>.<p>
<a name="28886"></a>
<p><strong>22.1.12	</strong> <code>public float readFloat() throws IOException</code>
<p>
<a name="28887"></a>
The general contract of <code>readFloat</code> is that it reads four input bytes and returns a 
<code>float</code> value. It does this by first constructing an <code>int</code> value in exactly the manner 
of the <code>readInt</code> method <a href="22_1.htm#28860">(&#167;22.1.10)</a>, then converting this <code>int</code> value to a <code>float</code> in 
exactly the manner of the method <code>Float.intBitsToFloat</code> <a href="20_9.htm#5683">(&#167;20.9.23)</a>.
<p><a name="28894"></a>
This method is suitable for reading bytes written by the <code>writeFloat</code> method of interface <code>DataOutput</code> <a href="22_2.htm#29032">(&#167;22.2.10)</a>.<p>
<a name="28899"></a>
<p><strong>22.1.13	</strong> <code>public double readDouble() throws IOException</code>
<p>
<a name="28900"></a>
The general contract of <code>readDouble</code> is that it reads eight input bytes and returns a 
<code>double</code> value. It does this by first constructing a <code>long</code> value in exactly the manner 
of the <code>readlong</code> method <a href="22_1.htm#28871">(&#167;22.1.11)</a>, then converting this <code>long</code> value to a <code>double</code> 
in exactly the manner of the method <code>Double.longBitsToDouble</code> <a href="20_10.htm#13864">(&#167;20.10.22)</a>.
<p><a name="28907"></a>
This method is suitable for reading bytes written by the <code>writeDouble</code> method of interface <code>DataOutput</code> <a href="22_2.htm#29045">(&#167;22.2.11)</a>.<p>
<a name="28912"></a>
<p><strong>22.1.14	</strong> <code>public String readLine() throws IOException</code>
<p>
<a name="28913"></a>
The general contract of <code>readLine</code> is that it reads successive bytes, converting 
each byte separately into a character, until it encounters a line terminator or end of 
file; the characters read are then returned as a <code>String</code>. Note that because this 
method processes bytes, it does not support input of the full Unicode character set.
<p><a name="28914"></a>
If end of file is encountered before even one byte can be read, then <code>null</code> is returned. Otherwise, each byte that is read is converted to type <code>char</code> by zero-extension. If the character <code>'\n'</code> is encountered, it is discarded and reading ceases. If the character <code>'\r'</code> is encountered, it is discarded and, if the following byte converts &#32;to the character <code>'\n'</code>, then that is discarded also; reading then ceases. If end of file is encountered before either of the characters <code>'\n'</code> and <code>'\r'</code> is encountered, reading ceases. Once reading has ceased, a <code>String</code> is returned that contains all the characters read and not discarded, taken in order. Note that every character in this string will have a value less than <code>\u0100</code>, that is, <code>(char)256</code>.<p>
<a name="28916"></a>
<p><strong>22.1.15	</strong> <code>public String readUTF() throws IOException</code>
<p>
<a name="28917"></a>
The general contract of <code>readUTF</code> is that it reads a representation of a Unicode 
character string encoded in Java modified UTF-8 format; this string of characters 
is then returned as a <code>String</code>.
<p><a name="28918"></a>
First, two bytes are read and used to construct an unsigned 16-bit integer in exactly the manner of the <code>readUnsignedShort</code> method <a href="22_22.htm#29998">(&#167;22.1.8)</a>. This integer value is called the <i>UTF length</i> and specifies the number of additional bytes to be read. These bytes are then converted to characters by considering them in groups. The length of each group is computed from the value of the first byte of the group. The byte following a group, if any, is the first byte of the next group.<p>
<a name="28922"></a>
If the first byte of a group matches the bit pattern <code>0xxxxxxx</code> (where <code>x</code> means "may be <code>0</code> or <code>1</code>"), then the group consists of just that byte. The byte is zero-extended to form a character.<p>
<a name="28923"></a>
If the first byte of a group matches the bit pattern <code>110xxxxx</code>, then the group consists of that byte <code>a</code> and a second byte <code>b</code>. If there is no byte <code>b</code> (because byte <code>a</code> was the last of the bytes to be read), or if byte <code>b</code> does not match the bit pattern <code>10xxxxxx</code>, then a <code>UTFDataFormatException</code> is thrown. Otherwise, the group is converted to the character:<p>
<pre><a name="28924"></a><code>(char)(((a &amp; 0x1F) &lt;&lt; 6) | (b &amp; 0x3F))
</code></pre><p><a name="28925"></a>
If the first byte of a group matches the bit pattern <code>1110xxxx</code>, then the group consists of that byte <code>a</code> and two more bytes <code>b</code> and <code>c</code>. If there is no byte <code>c</code> (because byte <code>a</code> was one of the last two of the bytes to be read), or either byte <code>b</code> or byte <code>c</code> does not match the bit pattern <code>10xxxxxx</code>, then a <code>UTFDataFormatException</code> is thrown. Otherwise, the group is converted to the character:<p>
<pre><a name="28926"></a><code>(char)(((a &amp; 0x0F) &lt;&lt; 12) | ((b &amp; 0x3F) &lt;&lt; 6) | (c &amp; 0x3F))
</code></pre><p><a name="28927"></a>
If the first byte of a group matches the pattern <code>1111xxxx</code> or the pattern <code>10xxxxxx</code>, then a <code>UTFDataFormatException</code> is thrown.<p>
<a name="31354"></a>
If end of file is encountered at any time during this entire process, then an <code>EOFException</code> is thrown.<p>
<a name="28928"></a>
After every group has been converted to a character by this process, the characters are gathered, in the same order in which their corresponding groups were read from the input stream, to form a <code>String</code>, which is returned.<p>
<a name="32579"></a>
The <code>writeUTF</code> method of interface <code>DataOutput</code> <a href="22_2.htm#29074">(&#167;22.2.14)</a> may be used to write data that is suitable for reading by this method.<p>


</body></html>
