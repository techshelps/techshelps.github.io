<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.4.7 Field Declarations</title>
<META NAME=MS-HAID CONTENT="13_4_7">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>13.4.7	 Field Declarations</h3>
<a name="45118"></a>
<p>
<a name="45119"></a>
Adding a field to a class will not break compatibility with any pre-existing binaries that are not recompiled, even in the case where a class could no longer be 
recompiled because a field access previously referenced a field of a superclass 
with an incompatible type. The previously compiled class with such a reference 
will continue to reference the field declared in a superclass. Thus compiling and 
executing the code:
<p><pre><a name="45120"></a>class Hyper { String h = "hyper"; }
<a name="45121"></a>class Super extends Hyper { String s = "super"; }
<a name="45122"></a>class Test {
<a name="45123"></a>	public static void main(String[] args) {
<a name="45124"></a>		System.out.println(new Super().h);
<a name="45125"></a>	}
<a name="45126"></a>}
</pre><p><a name="45127"></a>
produces the output:
<p><pre><a name="45128"></a>hyper
</pre><p><a name="47307"></a>
Changing <code>Super</code> to be defined as:
<p><pre><a name="45130"></a>
class Super extends Hyper {
<a name="45131"></a>	String s = "super";
<a name="45132"></a>	int h = 0;
<a name="45133"></a>}
</pre><p><a name="45134"></a>
recompiling <code>Hyper</code> and <code>Super</code>, and executing the resulting new binaries with the 
old binary of <code>Test</code> produces the output:
<p><pre><a name="45135"></a>hyper
</pre><p><a name="45136"></a>
The field <code>h</code> of <code>Hyper</code> is output by the original binary of <code>main</code> no matter what type 
field <code>h</code> is declared in <code>Super</code>. While this may seem surprising at first, it serves to 
reduce the number of incompatibilities that occur at run time. (In an ideal world, 
all source files that needed recompilation would be recompiled whenever any one 
of them changed, eliminating such surprises. But such a mass recompilation is 
often impractical or impossible, especially in the Internet. And, as was previously 
noted, such recompilation would sometimes require further changes to the source 
code.)
<p><a name="45137"></a>
Deleting a field from a class will break compatibility with any pre-existing binaries that reference this field, and a <code>NoSuchFieldError</code> will be thrown when such a reference from a pre-existing binary is linked. Only <code>private</code> fields may be safely deleted from a widely distributed class.<p>


</body></html>
