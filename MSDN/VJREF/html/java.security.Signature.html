<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<A NAME="_top_"></A>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Class Signature</TITLE>
<H1>
  Class java.security.Signature
</H1>
<A HREF="java.security.Signature001.html">Class Members</A> | 
  <A HREF="Package-java.security.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=3><PRE>
<A HREF="java.lang.Object.html">java.lang.Object</A>
   |
   +----java.security.Signature
</PRE></FONT>

<P><B> public abstract class <B>Signature</B>
  <BR>
 extends <A HREF="java.lang.Object.html">Object</A>
<BR>
</B>
<P>

This Signature class is used to provide the functionality of a
 digital signature algorithm, such as <TT>RSA with MD5</TT> or
 <TT>DSA</TT>. Digital signatures are used for authentication and
 integrity assurance of digital data.
 </DL> 
 <P>Like other algorithm-based classes in Java Security, the
 Signature class has two major components:
 <DL>
 <DT><B>Digital Signature API</B> (Application Program Interface)
 <DD>This is the interface of methods called by applications needing
 digital signature services. The API consists of all public methods.
 <DT><B>Digital Signature SPI</B> (Service Provider Interface)
 <DD>This is the interface implemented by providers that supply
 specific algorithms. It consists of all methods whose names are
 prefixed by <B>engine</B>. Each such method is called by a
 correspondingly-named public API method. For example, the
 <B>engineSign</B> method is called by the
 <B>sign</B> method.  The SPI methods are abstract;
 providers must supply a concrete implementation.
 </DL>
 <P>Also like other algorithm-based classes in Java Security, Signature 
 provides implementation-independent algorithms, whereby a caller 
 (application code) requests a particular signature algorithm
 and is handed back a properly initialized Signature object. It is
 also possible, if desired, to request a particular algorithm from a
 particular provider. See the <B>getInstance </B> methods.
 <P>Thus, there are two ways to request a Signature algorithm object: by
 specifying either just an algorithm name, or both an algorithm name
 and a package provider. <UL>
 <LI>If just an algorithm name is specified, the system will
 determine if there is an implementation of the algorithm requested
 available in the environment, and if there is more than one, if
 there is a preferred one.
 <LI>If both an algorithm name and a package provider are specified,
 the system will determine if there is an implementation of the
 algorithm in the package requested, and throw an exception if there
 is not.
 </UL>
 <P>A Signature object can be used to generate and verify digital
 signatures.
 <P>There are three phases to the use of a Signature object for
 either signing data or verifying a signature:<OL>
 <LI>Initialization, with either 
     <UL>
     <LI>a public key, which initializes the signature for
     verification (see <A HREF = "#initVerify">initVerify</A>), or
     <LI>a private key, which initializes the signature for
     signing (see <A HREF = "#initSign">initSign</A>).
     </UL><P>
 <LI>Updating<P>
 <P>Depending on the type of initialization, this will update the
 bytes to be signed or verified. See the <A HREF =
 "#update(byte)">update</A> methods.<P>
 <LI>Signing or Verifying 
 <P>a signature on all updated bytes. See <A
 HREF = "#sign">sign</A> and <A HREF = "#verify">verify</A>.
 </OL>
<P>
<HR>

</BODY>
</HTML>
