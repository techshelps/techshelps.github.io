<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.4.8 Examples of Method Declarations</title>
<META NAME=MS-HAID CONTENT="8_4_8">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>8.4.8	 Examples of Method Declarations</h3>
<a name="39598"></a>
<p>
<a name="39599"></a>
The following examples illustrate some (possibly subtle) points about method 
declarations.
<p><a name="39600"></a>
<h4>8.4.8.1	 Example: Overriding</h4>
<p>
<a name="39601"></a>
In the example:
<p><pre><a name="39602"></a>
class Point {
<br><a name="39603"></a>	int x = 0, y = 0;
<br><br><a name="39604"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><a name="39605"></a>}
<br><a name="39606"></a>
class SlowPoint extends Point {
<br><a name="39607"></a>	int xLimit, yLimit;
<br><a name="39608"></a>
	void move(int dx, int dy) {
<a name="39609"></a>		super.move(limit(dx, xLimit), limit(dy, yLimit));
<a name="39610"></a>	}
<br><a name="39611"></a>
	static int limit(int d, int limit) {
<a name="39612"></a>		return d &gt; limit ? limit : d &lt; -limit ? -limit : d;
<a name="39613"></a>	}
<br><a name="39614"></a>}
</pre><p><a name="39615"></a>
the class <code>SlowPoint</code> overrides the declarations of method <code>move</code> of class <code>Point</code> 
with its own <code>move</code> method, which limits the distance that the point can move on 
each invocation of the method. When the <code>move</code> method is invoked for an instance 
of class <code>SlowPoint</code>, the overriding definition in class <code>SlowPoint</code> will always be 
called, even if the reference to the <code>SlowPoint</code> object is taken from a variable 
whose type is <code>Point</code>.
<p><a name="39617"></a>
<h4>8.4.8.2	 Example: Overloading, Overriding, and Hiding</h4>
<p>
<a name="39618"></a>
In the example:
<p><pre><a name="39619"></a>
class Point {
<br><a name="39620"></a>	int x = 0, y = 0;
<br><br><a name="39621"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><br><a name="39622"></a>	int color;
<br><a name="39623"></a>}
<br><a name="39624"></a>
class RealPoint extends Point {
<br><a name="39625"></a>	float x = 0.0f, y = 0.0f;
<br><br><a name="39626"></a>	void move(int dx, int dy) { move((float)dx, (float)dy); }
<br><br><a name="39627"></a>	void move(float dx, float dy) { x += dx; y += dy; }
<br><a name="39628"></a>}
</pre><p><a name="39629"></a>
the class <code>RealPoint</code> hides the declarations of the <code>int</code> instance variables <code>x</code> and <code>y</code> 
of class <code>Point</code> with its own <code>float</code> instance variables <code>x</code> and <code>y</code>, and overrides the 
method <code>move</code> of class <code>Point</code> with its own <code>move</code> method. It also overloads the name 
<code>move</code> with another method with a different signature <a href="8_4_2.htm#38649">(&#167;8.4.2)</a>.
<p><a name="39633"></a>
In this example, the members of the class <code>RealPoint</code> include the instance variable <code>color</code> inherited from the class <code>Point</code>, the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>RealPoint</code>, and the two <code>move</code> methods declared in <code>RealPoint</code>.<p>
<a name="39634"></a>
Which of these overloaded <code>move</code> methods of class <code>RealPoint</code> will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in <a href="15_11.htm#20448">&#167;15.11</a>.<p>
<a name="39638"></a>
<h4>8.4.8.3	 Example: Incorrect Overriding</h4>
<p>
<a name="39639"></a>
This example is an extended variation of that in the preceding section:
<p><pre><a name="39640"></a>
class Point {
<br><a name="39641"></a>	int x = 0, y = 0, color;
<br><br><a name="39642"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><br><a name="39643"></a>	int getX() { return x; }
<br><br><a name="39644"></a>	int getY() { return y; }
<br><a name="39646"></a>}
<br><a name="39647"></a>
class RealPoint extends Point {
<br><a name="39648"></a>	float x = 0.0f, y = 0.0f;
<br><br><a name="39649"></a>	void move(int dx, int dy) { move((float)dx, (float)dy); }
<br><br><a name="39650"></a>	void move(float dx, float dy) { x += dx; y += dy; }
<br><br><a name="39651"></a>	float getX() { return x; }
<br><br><a name="39652"></a>	float getY() { return y; }
<br><a name="39653"></a>}
</pre><p><a name="39654"></a>
Here the class <code>Point</code> provides methods <code>getX</code> and <code>getY</code> that return the values of its 
fields <code>x</code> and <code>y</code>; the class <code>RealPoint</code> then overrides these methods by declaring 
methods with the same signature. The result is two errors at compile time, one for 
each method, because the return types do not match; the methods in class <code>Point</code> 
return values of type <code>int</code>, but the wanna-be overriding methods in class 
<code>RealPoint</code> return values of type <code>float</code>.
<p><a name="39655"></a>
<h4>8.4.8.4	 Example: Overriding versus Hiding</h4>
<p>
<a name="39656"></a>
This example corrects the errors of the example in the preceding section:
<p><pre><a name="39657"></a>
class Point {
<br><a name="39658"></a>	int x = 0, y = 0;
<br><br><a name="39659"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><br><a name="39660"></a>	int getX() { return x; }
<br><br><a name="39661"></a>	int getY() { return y; }
<br><br><a name="39662"></a>	int color;
<br><a name="39663"></a>}
<br><a name="39664"></a>
class RealPoint extends Point {
<br><a name="39665"></a>	float x = 0.0f, y = 0.0f;
<br><br><a name="39666"></a>	void move(int dx, int dy) { move((float)dx, (float)dy); }
<br><br><a name="39667"></a>	void move(float dx, float dy) { x += dx; y += dy; }
<br><br><a name="39668"></a>	int getX() { return (int)Math.floor(x); }
<br><br><a name="39669"></a>	int getY() { return (int)Math.floor(y); }
<br><a name="39670"></a>}
</pre><p><a name="39671"></a>
Here the overriding methods <code>getX</code> and <code>getY</code> in class <code>RealPoint</code> have the same 
return types as the methods of class <code>Point</code> that they override, so this code can be 
successfully compiled.
<p><a name="39672"></a>
Consider, then, this test program:<p>
<pre><a name="39673"></a>
class Test {
<a name="39674"></a>
	public static void main(String[] args) {
<a name="39675"></a>		RealPoint rp = new RealPoint();
<a name="39676"></a>		Point p = rp;
<a name="39677"></a>		rp.move(1.71828f, 4.14159f);
<a name="39678"></a>		p.move(1, -1);
<a name="39679"></a>		show(p.x, p.y);
<a name="39680"></a>		show(rp.x, rp.y);
<a name="39681"></a>		show(p.getX(), p.getY());
<a name="39682"></a>		show(rp.getX(), rp.getY());
<a name="39683"></a>	}
<br><a name="39684"></a>
	static void show(int x, int y) {
<a name="39685"></a>		System.out.println("(" + x + ", " + y + ")");
<a name="39686"></a>	}
<br><a name="39687"></a>
	static void show(float x, float y) {
<a name="39688"></a>		System.out.println("(" + x + ", " + y + ")");
<a name="39689"></a>	}
<br><a name="39690"></a>}
</pre><p><a name="39691"></a>
The output from this program is:
<p><pre><a name="39692"></a>
(0, 0)
<a name="39693"></a>(2.7182798, 3.14159)
<a name="39694"></a>(2, 3)
<a name="39695"></a>(2, 3)
</pre><p><a name="39696"></a>
The first line of output illustrates the fact that an instance of <code>RealPoint</code> actually contains the two integer fields declared in class <code>Point</code>; it is just that their names are hidden from code that occurs within the declaration of class <code>RealPoint</code> (and those of any subclasses it might have). When a reference to an instance of class <code>RealPoint</code> in a variable of type <code>Point</code> is used to access the field <code>x</code>, the integer field <code>x</code> declared in class <code>Point</code> is accessed. The fact that its value is zero indicates that the method invocation <code>p.move(1,</code> <code>-1)</code> did not invoke the method <code>move</code> of class <code>Point</code>; instead, it invoked the overriding method <code>move</code> of class <code>RealPoint</code>.<p>
<a name="39697"></a>
The second line of output shows that the field access <code>rp.x</code> refers to the field <code>x</code> declared in class <code>RealPoint</code>. This field is of type <code>float</code>, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name <code>show</code> is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.<p>
<a name="230120"></a>
The last two lines of output show that the method invocations <code>p.getX()</code> and <code>rp.getX()</code> each invoke the <code>getX</code> method declared in class <code>RealPoint</code>. Indeed, there is no way to invoke the <code>getX</code> method of class <code>Point</code> for an instance of class <code>RealPoint</code> from outside the body of <code>RealPoint</code>, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.<p>
<a name="229207"></a>
<h4>8.4.8.5	 Example: Invocation of Hidden Class Methods</h4>
<p>
<a name="229208"></a>
A hidden class (<code>static</code>) method can be invoked by using a reference whose type 
is the class that actually contains the declaration of the method. In this respect, 
hiding of static methods is different from overriding of instance methods. The 
example:
<p><a name="229226"></a>
<p>
<a name="229227"></a>
<p>
<a name="229228"></a>
<p>
<pre><a name="229209"></a>
class Super {
<a name="229210"></a>	static String greeting() { return "Goodnight"; }
<a name="229211"></a>	String name() { return "Richard"; }
<a name="229212"></a>}
<br><a name="229213"></a>
class Sub extends Super {
<a name="229214"></a>	static String greeting() { return "Hello"; }
<a name="229215"></a>	String name() { return "Dick"; }
<a name="229216"></a>}
<br><a name="229217"></a>
class Test {
<a name="229218"></a>	public static void main(String[] args) {
<a name="229219"></a>		Super s = new Sub();
<a name="229220"></a>		System.out.println(s.greeting() + ", " + s.name());
<a name="229221"></a>	}
<a name="229222"></a>}
</pre><p><a name="229223"></a>
produces the output:
<p><pre><a name="229224"></a>Goodnight, Dick
</pre><p><a name="229225"></a>
because the invocation of <code>greeting</code> uses the type of <code>s</code>, namely <code>Super</code>, to figure 
out, at compile time, which class method to invoke, whereas the invocation of 
<code>name</code> uses the class of <code>s</code>, namely <code>Sub</code>, to figure out, at run time, which instance 
method to invoke.
<p><a name="229149"></a>
<h4>8.4.8.6	 Large Example of Overriding</h4>
<p>
<a name="229150"></a>
Overriding makes it easy for subclasses to extend the behavior of an existing 
class, as shown in this example:
<p><pre><br><a name="229151"></a>import java.io.OutputStream;
<br><br><a name="229152"></a>import java.io.IOException;
<br></pre><p><pre><a name="229153"></a>
class BufferOutput {
<br><a name="229154"></a>	private OutputStream o;
<br><br><a name="229155"></a>	BufferOutput(OutputStream o) { this.o = o; }
<br><br><a name="229156"></a>	protected byte[] buf = new byte[512];
<br><br><a name="229157"></a>	protected int pos = 0;
<br><a name="229158"></a>
	public void putchar(char c) throws IOException {
<a name="229159"></a>		if (pos == buf.length)
<a name="229160"></a>			flush();
<a name="229161"></a>		buf[pos++] = (byte)c;
<a name="229162"></a>	}
<br></pre><p><pre><a name="229163"></a>
	public void putstr(String s) throws IOException {
<a name="229164"></a>		for (int i = 0; i &lt; s.length(); i++)
<a name="229165"></a>			putchar(s.charAt(i));
<a name="229166"></a>	}
<br><a name="229167"></a>
	public void flush() throws IOException {
<a name="229168"></a>		o.write(buf, 0, pos);
<a name="229169"></a>		pos = 0;
<a name="229170"></a>	}
<br><a name="229171"></a>}
<br><a name="229172"></a>
class LineBufferOutput extends BufferOutput {
<br><a name="229173"></a>	LineBufferOutput(OutputStream o) { super(o); }
<br><a name="229174"></a>
	public void putchar(char c) throws IOException {
<a name="229175"></a>		super.putchar(c);
<a name="229176"></a>		if (c == '\n')
<a name="229177"></a>			flush();
<a name="229178"></a>	}
<br><a name="229179"></a>}
<br><a name="229180"></a>
class Test {
<a name="229181"></a>	public static void main(String[] args)<br>
		throws IOException<br>
	{
<a name="229182"></a>		LineBufferOutput lbo =<br>
			new LineBufferOutput(System.out);
<a name="229183"></a>		lbo.putstr("lbo\nlbo");
<a name="229184"></a>		System.out.print("print\n");
<a name="229185"></a>		lbo.putstr("\n");
<a name="229186"></a>	}
<a name="229187"></a>}
</pre><p><a name="229188"></a>
This example produces the output:
<p><pre><a name="229189"></a>
lbo
<a name="229190"></a>print
<a name="229191"></a>lbo
</pre><p><a name="229192"></a>
The class <code>BufferOutput</code> implements a very simple buffered version of an <code>OutputStream</code>, flushing the output when the buffer is full or <code>flush</code> is invoked. The subclass <code>LineBufferOutput</code> declares only a constructor and a single method <code>putchar</code>, which overrides the method <code>putchar</code> of <code>BufferOutput</code>. It inherits the methods <code>putstr</code> and <code>flush</code> from class <code>Buffer</code>.<p>
<a name="229193"></a>
In the <code>putchar</code> method of a <code>LineBufferOutput</code> object, if the character argument is a newline, then it invokes the <code>flush</code> method. The critical point about overriding in this example is that the method <code>putstr</code>, which is declared in class <code>BufferOutput</code>, invokes the <code>putchar</code> method defined by the current object <code>this</code>, which is not necessarily the <code>putchar</code> method declared in class <code>BufferOutput</code>.<p>
<a name="229194"></a>
Thus, when <code>putstr</code> is invoked in <code>main</code> using the <code>LineBufferOutput</code> object <code>lbo</code>, the invocation of <code>putchar</code> in the body of the <code>putstr</code> method is an invocation of the <code>putchar</code> of the object <code>lbo</code>, the overriding declaration of <code>putchar</code> that checks for a newline. This allows a subclass of <code>BufferOutput</code> to change the behavior of the <code>putstr</code> method without redefining it.<p>
<a name="229195"></a>
Documentation for a class such as <code>BufferOutput</code>, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the <code>putchar</code> method in this way. The implementor of the <code>BufferOutput</code> class would not, therefore, want to change the implementation of <code>putstr</code> in a future implementation of <code>BufferOutput</code> not to use the method <code>putchar</code>, because this would break the preexisting contract with subclasses. See the further discussion of binary compatibility in <a href="chap13.htm">&#167;13</a>, especially <a href="13_2.htm#44952">&#167;13.2</a>.<p>
<a name="229203"></a>
<h4>8.4.8.7	 Example: Incorrect Overriding because of Throws</h4>
<p>
<a name="39701"></a>
This example uses the usual and conventional form for declaring a new exception 
type, in its declaration of the class <code>BadPointException</code>:
<p><pre><a name="39702"></a>
class BadPointException extends Exception {
<a name="39703"></a>	BadPointException() { super(); }
<a name="39704"></a>	BadPointException(String s) { super(s); }
<a name="39705"></a>}
<a name="39707"></a>
class Point {
<a name="39708"></a>	int x, y;
<a name="39709"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<a name="39710"></a>}
<br><a name="39711"></a>
class CheckedPoint extends Point {
<a name="39712"></a>	void move(int dx, int dy) throws BadPointException {
<a name="39713"></a>		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
<a name="39714"></a>			throw new BadPointException();
<a name="39715"></a>		x += dx; y += dy;
<a name="39716"></a>	}
<a name="39717"></a>}
</pre><p><a name="39718"></a>
This example results in a compile-time error, because the override of method 
<code>move</code> in class <code>CheckedPoint</code> declares that it will throw a checked exception that 
the <code>move</code> in class <code>Point</code> has not declared. If this were not considered an error, an 
invoker of the method <code>move</code> on a reference of type <code>Point</code> could find the contract 
between it and <code>Point</code> broken if this exception were thrown.
<p><a name="39725"></a>
Removing the <code>throws</code> clause does not help:<p>
<pre><a name="39726"></a>
class CheckedPoint extends Point {
<a name="39727"></a>	void move(int dx, int dy) {
<a name="39728"></a>		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
<a name="39729"></a>			throw new BadPointException();
<a name="39730"></a>		x += dx; y += dy;
<a name="39731"></a>	}
<a name="39732"></a>}
</pre><p><a name="41194"></a>
A different compile-time error now occurs, because the body of the method <code>move</code> 
cannot throw a checked exception, namely <code>BadPointException</code>, that does not 
appear in the <code>throws</code> clause for <code>move</code>.
<p>

</Font></body></html>
