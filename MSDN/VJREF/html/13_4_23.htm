<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.4.23 Method Overriding</title>
<META NAME=MS-HAID CONTENT="13_4_23">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>13.4.23	 Method Overriding</h3>
<a name="45301"></a>
<p>
<a name="45302"></a>
If an instance method is added to a subclass and it overrides a method in a superclass, then the subclass method will be found by method invocations in pre-existing binaries, and these binaries are not impacted. If a class method is added to a 
class, then this method will not be found, because the invocation of a class method 
is resolved at compile time to use the fully qualified name of the class where the 
method is declared. Thus if the example:
<p><pre><a name="45303"></a>
class Hyper {
<a name="45304"></a>	void hello() { System.out.print("Hello, "); }
<a name="45305"></a>	static void world() { System.out.println("world!"); }
<a name="45306"></a>}
<a name="45307"></a>class Super extends Hyper { }
<a name="45308"></a>
class Test {
<a name="45309"></a>	public static void main(String[] args) {
<a name="45310"></a>		Super s = new Super();
<a name="45311"></a>		s.hello();
<a name="45312"></a>		s.world();
<a name="45313"></a>	}
<a name="45314"></a>}
</pre><p><a name="45315"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45316"></a>Hello, world!
</pre><p><a name="45317"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45318"></a>
class Super extends Hyper {
<a name="45319"></a>	void hello() { System.out.print("Goodbye, cruel "); }
<a name="45320"></a>	static void world() { System.out.println("earth!"); }
<a name="45321"></a>}
</pre><p><a name="45322"></a>
If <code>Super</code> is recompiled but not <code>Hyper</code> or <code>Test</code>, then running the new binary with 
the existing binaries for <code>Hyper</code> and <code>Test</code> will produce the output:
<p><pre><a name="45323"></a>Goodbye, cruel world!
</pre><p><a name="45324"></a>
This example demonstrates that the invocation in:
<p><pre><a name="45325"></a>s.world();
</pre><p><a name="45326"></a>
in the method <code>main</code> is resolved, at compile time, to a symbolic reference to the 
class containing the class method <code>world</code>, as though it had been written:
<p><pre><a name="45327"></a>Hyper.world();
</pre><p><a name="45328"></a>
This is why the <code>world</code> method of <code>Hyper</code> rather than <code>Super</code> is invoked in this 
example. Of course, recompiling all the classes to produce new binaries will allow 
the output:
<p><pre><a name="45329"></a>Goodbye, cruel earth!
</pre><p><a name="45330"></a>
to be produced.
<p>

</body></html>
