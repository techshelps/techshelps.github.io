<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.3 Linking of Classes and Interfaces</title>
<META NAME=MS-HAID CONTENT="12_3">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>12.3	 Linking of Classes and Interfaces</h2>
<a name="44487"></a>
<p>
<a name="44488"></a>
<i>Linking</i> is the process of taking a binary form of a class or interface type and combining it into the runtime state of the Java Virtual Machine, so that it can be executed. A class or interface type is always loaded before it is linked. Three different 
activities are involved in linking: verification, preparation, and resolution of symbolic references.
<p><a name="46466"></a>
Java allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error.<p>
<a name="46467"></a>
For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.<p>
<a name="46201"></a>
Because linking involves the allocation of new data structures, it may fail with an <code>OutOfMemoryError</code>.<p>


</body></html>
