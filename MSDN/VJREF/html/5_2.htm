<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.2 Assignment Conversion</title>
<META NAME=MS-HAID CONTENT="5_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>5.2	 Assignment Conversion</h2>
<a name="170768"></a>
<p>
<a name="170769"></a>
<i>Assignment conversion</i> occurs when the value of an expression is assigned 
<a href="15_25.htm#5281">(&#167;15.25)</a> to a variable: the type of the expression must be converted to the type of 
the variable. Assignment contexts allow the use of an identity conversion <a href="5_1_1.htm#25209">(&#167;5.1.1)</a>, 
a widening primitive conversion <a href="5_1_2.htm#25222">(&#167;5.1.2)</a>, or a widening reference conversion 
<a href="5_1_4.htm#25215">(&#167;5.1.4)</a>. In addition, a narrowing primitive conversion may be used if all of the 
following conditions are satisfied:
<p><ul><a name="26335"></a>
<li>The expression is a constant expression of type <code>int</code>.
<a name="26336"></a>
<li>The type of the variable is <code>byte</code>, <code>short</code>, or <code>char</code>.
<a name="26337"></a>
<li>The value of the expression (which is known at compile time, because it is a constant expression) is representable in the type of the variable.
</ul><p><a name="26341"></a>
If the type of the expression cannot be converted to the type of the variable by a 
conversion permitted in an assignment context, then a compile-time error occurs.
<p><a name="22422"></a>
If the type of an expression can be converted to the type a variable by assignment conversion, we say the expression (or its value) is <i>assignable to</i> the variable or, equivalently, that the type of the expression is <i>assignment compatible with</i> the type of the variable.<p>
<a name="11334"></a>
An assignment conversion never causes an exception. (Note, however, that an assignment may result in an exception in a special case involving array elements -see <a href="10_10.htm#11430">&#167;10.10</a> and <a href="15_25_1.htm#5295">&#167;15.25.1</a>.)<p>
<a name="28552"></a>
The compile-time narrowing of constants means that code such as:<p>
<pre><a name="12645"></a>byte theAnswer = 42;
</pre><p><a name="170786"></a>
is allowed. Without the narrowing, the fact that the integer literal <code>42</code> has type <code>int</code> 
would mean that a cast to <code>byte</code> would be required:
<p><pre><a name="26372"></a>byte theAnswer = (byte)42;									// cast is permitted but not required
</pre><p><a name="12681"></a>
A value of primitive type must not be assigned to a variable of reference type; an attempt to do so will result in a compile-time error. A value of type <code>boolean</code> can be assigned only to a variable of type <code>boolean</code>.<p>
<a name="12674"></a>
The following test program contains examples of assignment conversion of primitive values:<p>
<pre><a name="12675"></a>
class Test {
<a name="12977"></a>	public static void main(String[] args) {
<a name="12978"></a>		short s = 12;							// narrow 12 to short
<a name="12979"></a>		float f = s;							// widen short to float
<a name="12983"></a>		System.out.println("f=" + f);
<a name="12980"></a>
		char c = '\u0123';
<a name="12981"></a>		long l = c;							// widen char to long
<a name="12984"></a>		System.out.println("l=0x" + Long.toString(l,16));
<a name="12985"></a>
		f = 1.23f;
<a name="12986"></a>		double d = f;							// widen float to double
<a name="12996"></a>		System.out.println("d=" + d);
<a name="12987"></a>	}
<a name="12988"></a>}
</pre><p><a name="13013"></a>
It produces the following output:
<p><pre><a name="13020"></a>
f=12.0	
<a name="13021"></a>i=0x123
<a name="13022"></a>d=1.2300000190734863
</pre><p><a name="13041"></a>
The following test, however, produces compile-time errors:
<p><pre><a name="13042"></a>
class Test {
<a name="13043"></a>	public static void main(String[] args) {
<a name="13044"></a>		short s = 123;
<a name="27506"></a>		char c = s;							// error: would require cast
<a name="27507"></a>		s = c;							// error: would require cast
<a name="27508"></a>	}
<a name="13048"></a>}
</pre><p><a name="13049"></a>
because not all <code>short</code> values are <code>char</code> values, and neither are all <code>char</code> values 
<code>short</code> values.
<p><a name="26408"></a>
A value of reference type must not be assigned to a variable of primitive type; an attempt to do so will result in a compile-time error. <p>
<a name="26412"></a>
A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.<p>
<a name="26417"></a>
Here is a sample program illustrating assignments of references:<p>
<pre><a name="24498"></a>
public class Point { int x, y; }
<br><a name="24499"></a>public class Point3D extends Point { int z; }
<br><a name="24500"></a>
public interface Colorable {
<a name="24501"></a>	void setColor(int color);
<a name="24502"></a>}
<br><a name="24503"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="24504"></a>	int color;
<a name="24506"></a>	public void setColor(int color) { this.color = color; }
<a name="24507"></a>}
<br><a name="176339"></a>

<a name="176343"></a>
<a name="176346"></a>
<a name="176347"></a>
<a name="176348"></a>
<a name="176349"></a>class Test {
<a name="24509"></a>
	public static void main(String[] args) {
<a name="176333"></a>
		// Assignments to variables of class type:
<a name="24511"></a>		Point p = new Point();
<a name="24513"></a>		p = new Point3D();							// ok: because Point3d is a
<a name="24514"></a>									// subclass of Point
<a name="24515"></a>		
<a name="24516"></a>		Point3D p3d = p;							// error: will require a cast because a 
<a name="24517"></a>									// Point might not be a Point3D
<a name="24518"></a>									// (even though it is, dynamically,
<a name="175517"></a>									// in this example.)
<a name="175518"></a>
		// Assignments to variables of type Object:
<a name="175519"></a>		Object o = p;							// ok: any object to Object
<a name="24524"></a>		int[] a = new int[3];
<a name="24525"></a>		Object o2 = a;							// ok: an array to Object
<br><a name="24527"></a>
		// Assignments to variables of interface type:
<a name="24528"></a>		ColoredPoint cp = new ColoredPoint();
<a name="24529"></a>		Colorable c = cp;							// ok: ColoredPoint implements
<a name="24530"></a>									// Colorable
<br><a name="24532"></a>
		// Assignments to variables of array type:
<a name="24533"></a>		byte[] b = new byte[4];
<a name="24534"></a>		a = b;							// error: these are not arrays
<a name="24535"></a>									// of the same primitive type
<a name="24536"></a>		Point3D[] p3da = new Point3D[3];
<a name="24537"></a>		Point[] pa = p3da;							// ok: since we can assign a
<a name="24538"></a>									// Point3D to a Point
<a name="24539"></a>		p3da = pa;							// error: (cast needed) since a Point
<a name="24540"></a>									// can't be assigned to a Point3D
<br><a name="24542"></a>	}
<br><a name="24543"></a>}
</pre><p><a name="25628"></a>
Assignment of a value of compile-time reference type <i>S</i><i></i> (source) to a variable of compile-time reference type <i>T</i><em></em> (target) is checked as follows:<p>
<ul><a name="25632"></a>
<li>If <i>S</i><i></i> is a class type:
<ul>
<a name="25636"></a>
<li>If <i>T</i> is a class type, then <i>S</i><i></i> must either be the same class as <i>T</i>, or <i>S</i><i></i> must be a subclass of <i>T</i>, or a compile-time error occurs.
<a name="25643"></a>
<li>If <i>T</i> is an interface type, then <i>S</i><i></i> must implement interface <i>T</i>, or a compile-time error occurs.
<a name="25644"></a>
<li>If <i>T</i> is an array type, then a compile-time error occurs.
</ul>
</ul><ul><a name="176327"></a>
<li>If <i>S</i><i></i> is an interface type:
<ul>
<a name="25655"></a>
<li>If <i>T</i> is a class type, then <i>T</i> must be <code>Object</code>, or a compile-time error occurs.
<a name="25659"></a>
<li>If <i>T</i> is an interface type, then <i>T</i> must be either the same interface as <i>S</i> or a superinterface of <i>S</i>,<i></i> or a compile-time error occurs.
<a name="25663"></a>
<li>If <i>T</i> is an array type, then a compile-time error occurs.
</ul>
<a name="25667"></a>
<li>If <i>S</i> is an array type <i>SC</i><code>[]</code>, that is, an array of components of type <i>SC</i><em></em>:
<ul>
<a name="25677"></a>
<li>If <i>T</i> is a class type, then <i>T</i> must be <code>Object</code>, or a compile-time error occurs.
<a name="25678"></a>
<li>If <i>T</i> is an interface type, then a compile-time error occurs unless <i>T</i> is the interface type <code>Cloneable</code>, the only interface implemented by arrays.
<a name="25679"></a>
<li>If <i>T</i> is an array type <i>TC</i><code>[]</code>, that is, an array of components of type <i>TC</i><em>,</em> then a compile-time error occurs unless one of the following is true:
<ul>
<a name="25683"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are the same primitive type.
<a name="25684"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are both reference types and type <i>SC</i><em></em> is assignable to <i>TC</i><em>,</em> as determined by a recursive application of these compile-time rules for assignability.
</ul>
</ul>
</ul><p><a name="25695"></a>
See <a href="7_7.htm#3857">&#167;8</a> for the detailed specifications for classes, <a href="8_6_8.htm#44367">&#167;9</a> for interfaces, and <a href="9_4_3.htm#27803">&#167;10</a> for 
arrays.
<p><a name="56972"></a>
The following test program illustrates assignment conversions on reference values, but fails to compile because it violates the preceding rules, as described in its comments. This example should be compared to the preceding one.<p>
<pre><a name="29474"></a>
public class Point { int x, y; }
<br><a name="29475"></a>public interface Colorable { void setColor(int color); }
<br><a name="29476"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="29477"></a>	int color;
<a name="29479"></a>	public void setColor(int color) { this.color = color; }
<a name="29480"></a>}
<br><a name="12566"></a>
class Test {
<a name="12567"></a>
	public static void main(String[] args) {
<br><a name="12568"></a>		Point p = new Point();
<br><a name="12569"></a>		ColoredPoint cp = new ColoredPoint();
<a name="17235"></a>
		// Okay because ColoredPoint is a subclass of Point:
<a name="17230"></a>		p = cp;
<br><a name="29503"></a>
		// Okay because ColoredPoint implements Colorable:
<a name="29502"></a>		Colorable c = cp;
<br><a name="12576"></a>
		// The following cause compile-time errors because
<a name="12577"></a>		// we cannot be sure they will succeed, depending on
<a name="17240"></a>		// the run-time type of p; a run-time check will be
<a name="17245"></a>		// necessary for the needed narrowing conversion and
<a name="12579"></a>		// must be indicated by including a cast:
<a name="12580"></a>		cp = p;				// p might be neither a ColoredPoint
<a name="29523"></a>						// nor a subclass of ColoredPoint
<a name="12581"></a>		c = p;				// p might not implement Colorable
<br><a name="12593"></a>	}
<br><a name="12594"></a>}
</pre><p><a name="29746"></a>
Here is another example involving assignment of array objects:
<p><pre><a name="29747"></a>
class Point { int x, y; }
<br><a name="29748"></a>class ColoredPoint extends Point { int color; }
<br><a name="29749"></a>
class Test {
<a name="29750"></a>	public static void main(String[] args) {
<a name="29751"></a>		long[] veclong = new long[100];
<a name="29752"></a>		Object o = veclong;									// okay
<a name="29753"></a>		Long l = veclong;									// compile-time error
<a name="29754"></a>		short[] vecshort = veclong;									// compile-time error
<a name="29755"></a>		Point[] pvec = new Point[100];
<a name="29756"></a>		ColoredPoint[] cpvec = new ColoredPoint[100];
<a name="29757"></a>		pvec = cpvec;									// okay
<a name="50093"></a>		pvec[0] = new Point();									// okay at compile time,
<a name="174449"></a>											// but would throw an
<a name="174450"></a>											// exception at run time
<a name="29758"></a>		cpvec = pvec;									// compile-time error
<a name="29759"></a>	}
<a name="29760"></a>}
</pre><p><a name="29761"></a>
In this example:
<p><ul><a name="12615"></a>
<li>The value of <code>veclong</code> cannot be assigned to a <code>Long</code> variable, because <code>Long</code> is a class type <a href="20_8.htm#13841">(&#167;20.8)</a> other than <code>Object</code>. An array can be assigned only to a variable of a compatible array type, or to a variable of type <code>Object</code>.
<a name="12616"></a>
<li>The value of <code>veclong</code> cannot be assigned to <code>vecshort</code>, because they are arrays of primitive type, and <code>short</code> and <code>long</code> are not the same primitive type.
<a name="12617"></a>
<li>The value of <code>cpvec</code> can be assigned to <code>pvec</code>,<code></code> because any reference that could be the value of an expression of type <code>ColoredPoint</code> can be the value of a variable of type <code>Point</code>. The subsequent assignment of the new <code>Point</code> to a component of <code>pvec</code> then would throw an <code>ArrayStoreException</code> (if the program were otherwise corrected so that it could be compiled), because a <code>ColoredPoint</code> &#32;array can't have an instance of <code>Point</code> as the value of a component.
<a name="29743"></a>
<li>The value of <code>pvec</code> cannot be assigned to <code>cpvec</code>,<code></code> because not every reference that could be the value of an expression of type <code>ColoredPoint</code> can correctly be the value of a variable of type <code>Point</code>. If the value of <code>pvec</code> at run time were a reference to an instance of <code>Point[]</code>, and the assignment to <code>cpvec</code> were allowed, a simple reference to a component of <code>cpvec</code>, say, <code>cpvec[0]</code>, could return a <code>Point</code>, and a <code>Point</code> is not a <code>ColoredPoint</code>. Thus to allow such an assignment would allow a violation of the type system. A cast may be used (<a href="5_4.htm#176921">&#167;5.4</a>, <a href="15_15.htm#238146">&#167;15.15</a>) to ensure that <code>pvec</code> references a <code>ColoredPoint[]</code>:
</ul><pre><a name="174507"></a>
		cpvec = (ColoredPoint[])pvec;										// okay, but may throw an
<a name="174508"></a>												// exception at run time
</pre><p>

</body></html>
