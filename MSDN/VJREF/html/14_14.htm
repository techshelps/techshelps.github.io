<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>14.14 The continue Statement</title>
<META NAME=MS-HAID CONTENT="14_14">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>14.14	 The continue Statement</h2>
<a name="6122"></a>
<p>
<a name="6123"></a>
<meta name="MS-HKWD" content="continue">
A <code>continue</code> statement may occur only in a <code>while</code>, <code>do</code>, or <code>for</code> statement; statements of these three kinds are called <i>iteration statements</i>. Control passes to the 
loop-continuation point of an iteration statement.
<p><pre>
<i>ContinueStatement:<br>
	<code>continue </code>Identifieropt<code> ;
</code></i></pre><p><a name="6125"></a>
A <code>continue</code> statement with no label attempts to transfer control to the innermost enclosing <code>while</code>, <code>do</code>, or <code>for</code> statement; this statement, which is called the <i>continue target</i>, then immediately ends the current iteration and begins a new one. To be precise, such a <code>continue</code> statement always completes abruptly, the reason being a <code>continue</code> with no label. If no <code>while</code>, <code>do</code>, or <code>for</code> statement encloses the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="79215"></a>
A <code>continue</code> statement with label <i>Identifier</i> attempts to transfer control to the enclosing labeled statement <a href="14_6.htm#78993">(&#167;14.6)</a> that has the same <i>Identifier</i> as its label; that statement, which is called the <i>continue target</i>, then immediately ends the current iteration and begins a new one. The continue target must be a <code>while</code>, <code>do</code>, or <code>for</code> statement or a compile-time error occurs. More precisely, a <code>continue</code> statement with label <i>Identifier</i> always completes abruptly, the reason being a <code>continue</code> with label <i>Identifier</i>. If no labeled statement with <i>Identifier</i> as its label contains the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="43498"></a>
It can be seen, then, that a <code>continue</code> statement always completes abruptly.<p>
<a name="6136"></a>
See the descriptions of the <code>while</code> statement <a href="14_10.htm#237277">(&#167;14.10)</a>, <code>do</code> statement <a href="14_11.htm#6045">(&#167;14.11)</a>, and <code>for</code> statement <a href="14_12.htm#24588">(&#167;14.12)</a> for a discussion of the handling of abrupt termination because of <code>continue</code>.<p>
<a name="43422"></a>
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="14_18.htm#79311">(&#167;14.18)</a> within the continue target whose <code>try</code> blocks contain the <code>continue</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>continue</code> statement.<p>
<a name="42935"></a>
In the <code>Graph</code> example in the preceding section, one of the <code>break</code> statements is used to finish execution of the entire body of the outermost <code>for</code> loop. This <code>break</code> can be replaced by a <code>continue</code> if the <code>for</code> loop itself is labeled:<p>
<pre><a name="42900"></a>
class Graph {
<a name="42901"></a>	. . .
<a name="42903"></a>	public Graph loseEdges(int i, int j) {
<a name="42904"></a>		int n = edges.length;
<a name="42905"></a>		int[][] newedges = new int[n][];
<a name="42906"></a>
		edgelists: for (int k = 0; k &lt; n; ++k) {
<a name="42908"></a>			int z;
<a name="42909"></a>
			search: {
<a name="42989"></a>				if (k == i) {
<a name="42990"></a>					. . .
<a name="42991"></a>				} else if (k == j) {
<a name="42916"></a>					. . .
<a name="42919"></a>				}
<a name="42921"></a>				newedges[k] = edges[k];
<a name="42922"></a>				continue edgelists;
<a name="42923"></a>			}//search
<a name="42925"></a>			. . .
<a name="42983"></a>		}//edgelists
<a name="42932"></a>		return new Graph(newedges);
<a name="42933"></a>	}
<a name="42934"></a>}
</pre><p><a name="42984"></a>
Which to use, if either, is largely a matter of programming style.
<p>

</body></html>
