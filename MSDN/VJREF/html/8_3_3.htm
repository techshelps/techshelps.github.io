<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.3.3 Examples of Field Declarations</title>
<META NAME=MS-HAID CONTENT="8_3_3">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>8.3.3	 Examples of Field Declarations</h3>
<a name="40425"></a>
<p>
<a name="40426"></a>
The following examples illustrate some (possibly subtle) points about field declarations.
<p><a name="40428"></a>
<h4>8.3.3.1	 Example: Hiding of Class Variables</h4>
<p>
<a name="40429"></a>
The example:
<p><pre><a name="40430"></a>
class Point {
<a name="40431"></a>	static int x = 2;
<a name="40432"></a>}
<br><a name="40433"></a>
class Test extends Point {
<a name="40434"></a>	static double x = 4.7;
<a name="40435"></a>	public static void main(String[] args) {<br>
		new Test().printX();
<a name="229781"></a>	}
<a name="229782"></a>	void printX() {
<a name="40436"></a>		System.out.println(x + " " + super.x);
<a name="40437"></a>	}
<a name="40438"></a>}
</pre><p><a name="40439"></a>
produces the output:
<p><pre><a name="40440"></a>4.7 2
</pre><p><a name="40441"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, 
so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. Within the 
declaration of class <code>Test</code>, the simple name <code>x</code> refers to the field declared within 
class <code>Test</code>. Code in class <code>Test</code> may refer to the field <code>x</code> of class <code>Point</code> as <code>super.x</code> 
(or, because <code>x</code> is <code>static</code>, as <code>Point.x</code>). If the declaration of <code>Test.x</code> is deleted:
<p><pre><a name="40442"></a>
class Point {
<a name="40443"></a>	static int x = 2;
<a name="40444"></a>}
<br><a name="40445"></a>
class Test extends Point {
<a name="229789"></a>	public static void main(String[] args) {
<a name="229790"></a>		new Test().printX();
<a name="229791"></a>	}
<a name="229786"></a>	void printX() {
<a name="40447"></a>		System.out.println(x + " " + super.x);
<a name="40448"></a>	}
<a name="40449"></a>}
</pre><p><a name="40450"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>; instead, the 
simple name <code>x</code> now refers to the field <code>Point.x</code>. Code in class <code>Test</code> may still refer 
to that same field as <code>super.x</code>. Therefore, the output from this variant program is:
<p><pre><a name="40451"></a>2 2
</pre><p><a name="229119"></a>
<h4>8.3.3.2	 Example: Hiding of Instance Variables</h4>
<p>
<a name="40453"></a>
This example is similar to that in the previous section, but uses instance variables 
rather than static variables. The code:
<p><pre><a name="40454"></a>
class Point {
<a name="40455"></a>	int x = 2;
<a name="40456"></a>}
<br><a name="40457"></a>
class Test extends Point {
<a name="40458"></a>	double x = 4.7;
<a name="40459"></a>	void printBoth() {
<a name="40460"></a>		System.out.println(x + " " + super.x);
<a name="40461"></a>	}
<a name="40462"></a>	public static void main(String[] args) {
<a name="40463"></a>		Test sample = new Test();
<a name="40464"></a>		sample.printBoth();
<a name="40465"></a>		System.out.println(sample.x + " " + <br>
												((Point)sample).x);
<a name="40466"></a>	}
<a name="40467"></a>}
</pre><p><a name="40468"></a>
produces the output:
<p><pre><a name="40469"></a>
4.7 2
<a name="40470"></a>4.7 2
</pre><p><a name="40471"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, 
so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. It must be 
noted, however, that while the field <code>x</code> of class <code>Point</code> is not <i>inherited</i> by class 
<code>Test</code>, it is nevertheless <i>implemented</i> by instances of class <code>Test</code>. In other words, 
every instance of class <code>Test</code> contains two fields, one of type <code>int</code> and one of type 
<code>float</code>. Both fields bear the name <code>x</code>, but within the declaration of class <code>Test</code>, the 
simple name <code>x</code> always refers to the field declared within class <code>Test</code>. Code in 
instance methods of class <code>Test</code> may refer to the instance variable <code>x</code> of class <code>Point</code> 
as <code>super.x</code>.
<p><a name="40472"></a>
Code that uses a field access expression to access field <code>x</code> will access the field named <code>x</code> in the class indicated by the type of reference expression. Thus, the expression <code>sample.x</code> accesses a <code>float</code> value, the instance variable declared in class <code>Test</code>, because the type of the variable sample is <code>Test</code>, but the expression <code>((Point)sample).x</code> accesses an <code>int</code> value, the instance variable declared in class <code>Point</code>, because of the cast to type <code>Point</code>.<p>
<a name="40473"></a>
If the declaration of <code>x</code> is deleted from class <code>Test</code>, as in the program:<p>
<pre><a name="40474"></a>
class Point {
<a name="40475"></a>	static int x = 2;
<a name="40476"></a>}
<br><a name="40477"></a>
class Test extends Point {
<a name="40478"></a>	void printBoth() {
<a name="40479"></a>		System.out.println(x + " " + super.x);
<a name="40480"></a>	}
<a name="40481"></a>	public static void main(String[] args) {
<a name="40482"></a>		Test sample = new Test();
<a name="40483"></a>		sample.printBoth();
<a name="40484"></a>		System.out.println(sample.x + " " +<br>
												((Point)sample).x);
<a name="40485"></a>	}
<a name="40486"></a>}
</pre><p><a name="40487"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>. Within 
instance methods in the declaration of class <code>Test</code>, the simple name <code>x</code> now refers to 
the field declared within class <code>Point</code>. Code in class <code>Test</code> may still refer to that 
same field as <code>super.x</code>. The expression <code>sample.x</code> still refers to the field <code>x</code> within 
type <code>Test</code>, but that field is now an inherited field, and so refers to the field <code>x</code> 
declared in class <code>Point</code>. The output from this variant program is:
<p><pre><a name="40488"></a>
2 2
<a name="40489"></a>2 2
</pre><p><a name="40491"></a>
<h4>8.3.3.3	 Example: Multiply Inherited Fields</h4>
<p>
<a name="40492"></a>
A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any 
attempt to refer to any ambiguously inherited field by its simple name. A qualified 
name or a field access expression that contains the keyword <code>super</code> <a href="15_10_2.htm#20860">(&#167;15.10.2)</a> may 
be used to access such fields unambiguously. In the example:
<p><pre><br><a name="40496"></a>interface Frob { float v = 2.0f; }
<br><br><a name="40497"></a>class SuperTest { int v = 3; }
<br></pre><p><pre><a name="40498"></a>
class Test extends SuperTest implements Frob {
<a name="40499"></a>	public static void main(String[] args) {
<a name="40500"></a>		new Test().printV();
<a name="40501"></a>	}
<a name="40502"></a>	void printV() { System.out.println(v); }
<a name="40503"></a>}
</pre><p><a name="40504"></a>
the class <code>Test</code> inherits two fields named <code>v</code>, one from its superclass <code>SuperTest</code> and 
one from its superinterface <code>Frob</code>. This in itself is permitted, but a compile-time 
error occurs because of the use of the simple name <code>v</code> in method <code>printV</code>: it cannot 
be determined which <code>v</code> is intended.
<p><a name="41191"></a>
The following variation uses the field access expression <code>super.v</code> to refer to the field named <code>v</code> declared in class <code>SuperTest</code> and uses the qualified name <code>Frob.v</code> to refer to the field named <code>v</code> declared in interface <code>Frob</code>:<p>
<pre><br><a name="40505"></a>interface Frob { float v = 2.0f; }
<br><br><a name="40506"></a>class SuperTest { int v = 3; }
<br></pre><p><pre><a name="40507"></a>
class Test extends SuperTest implements Frob {
<a name="40508"></a>	public static void main(String[] args) {
<a name="40509"></a>		new Test().printV();
<a name="40510"></a>	}
<a name="40511"></a>	void printV() {
<a name="40512"></a>		System.out.println((super.v + Frob.v)/2);
<a name="40513"></a>	}
<a name="40514"></a>}
</pre><p><a name="40515"></a>
It compiles and prints:
<p><pre><a name="40516"></a>2.5
</pre><p><a name="40518"></a>
Even if two distinct inherited fields have the same type, the same value, and are both <code>final</code>, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the example:<p>
<pre><br><a name="40519"></a>interface Color { int RED=0, GREEN=1, BLUE=2; }
<br><br><a name="40520"></a>interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
<br></pre><p><pre><a name="40521"></a>
class Test implements Color, TrafficLight {
<a name="40522"></a>	public static void main(String[] args) {
<a name="40523"></a>		System.out.println(GREEN);										// compile-time error
<a name="40524"></a>		System.out.println(RED);										// compile-time error
<a name="40525"></a>	}
<a name="40526"></a>}
</pre><p><a name="40527"></a>
it is not astonishing that the reference to <code>GREEN</code> should be considered ambiguous, 
because class <code>Test</code> inherits two different declarations for <code>GREEN</code> with different 
values. The point of this example is that the reference to <code>RED</code> is also considered 
ambiguous, because two distinct declarations are inherited. The fact that the two 
fields named <code>RED</code> happen to have the same type and the same unchanging value 
does not affect this judgment.
<p><a name="40528"></a>
<h4>8.3.3.4	 Example: Re-inheritance of Fields</h4>
<p>
<a name="40529"></a>
If the same field declaration is inherited from an interface by multiple paths, the 
field is considered to be inherited only once. It may be referred to by its simple 
name without ambiguity. For example, in the code:
<p><pre><a name="40530"></a>
public interface Colorable {
<a name="40531"></a>	int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
<a name="40532"></a>}
<br><a name="40533"></a>
public interface Paintable extends Colorable {
<a name="40534"></a>	int MATTE = 0, GLOSSY = 1;
<a name="40535"></a>}
<br><br><a name="40536"></a>class Point { int x, y; }
<br><a name="40537"></a>
class ColoredPoint extends Point implements Colorable {
<a name="40538"></a>	. . .
<a name="40539"></a>}
<br><a name="40540"></a>
class PaintedPoint extends ColoredPoint implements Paintable 
{
<a name="40541"></a>	. . .  &#32; &#32; &#32;<code>RED</code> &#32; &#32; &#32; . . .
<a name="40542"></a>}
</pre><p><a name="40423"></a>
the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by the class <code>PaintedPoint</code> both 
through its direct superclass <code>ColoredPoint</code> and through its direct superinterface 
<code>Paintable</code>. The simple names <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> may nevertheless be used 
without ambiguity within the class <code>PaintedPoint</code> to refer to the fields declared in 
interface <code>Colorable</code>.
<p>

</Font></body></html>
