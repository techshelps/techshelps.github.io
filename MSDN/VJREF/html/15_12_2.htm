<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.12.2 Examples: Array Access Evaluation Order</title>
<META NAME=MS-HAID CONTENT="15_12_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.12.2	 Examples: Array Access Evaluation Order</h3>
<a name="23902"></a>
<p>
<a name="23906"></a>
In an array access, the expression to the left of the brackets appears to be fully 
evaluated before any part of the expression within the brackets is evaluated. For 
example, in the (admittedly monstrous) expression <code>a[(a=b)[3]]</code>, the expression 
<code>a</code> is fully evaluated before the expression <code>(a=b)[3]</code>; this means that the original 
value of <code>a</code> is fetched and remembered while the expression <code>(a=b)[3]</code> is evaluated. This array referenced by the original value of <code>a</code> is then subscripted by a value 
that is element <code>3</code> of another array (possibly the same array) that was referenced by 
<code>b</code> and is now also referenced by <code>a</code>.
<p><a name="23907"></a>
Thus, the example:<p>
<pre><a name="23908"></a>
class Test {
<a name="23909"></a>	public static void main(String[] args) {
<a name="23910"></a>		int[] a = { 11, 12, 13, 14 };
<a name="23911"></a>		int[] b = { 0, 1, 2, 3 };
<a name="23912"></a>		System.out.println(a[(a=b)[3]]);
<a name="23913"></a>	}
<a name="23914"></a>}
</pre><p><a name="23915"></a>
prints:
<p><pre><a name="23916"></a>14
</pre><p><a name="23917"></a>
because the monstrous expression's value is equivalent to <code>a[b[3]]</code> or <code>a[3]</code> or <code>14</code>.
<p><a name="23918"></a>
If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated. Thus, the example:<p>
<pre><a name="23920"></a>
class Test {
<a name="23921"></a>	public static void main(String[] args) {
<a name="23922"></a>		int index = 1;
<a name="23923"></a>		try {
<a name="23924"></a>			skedaddle()[index=2]++;
<a name="23925"></a>		} catch (Exception e) {
<a name="23926"></a>			System.out.println(e + ", index=" + index);
<a name="23927"></a>		}
<a name="23928"></a>	}
<a name="23929"></a>	static int[] skedaddle() throws Exception {
<a name="50244"></a>		throw new Exception("Ciao");
<a name="50246"></a>	}
<a name="23930"></a>}
</pre><p><a name="23931"></a>
prints: 
<p><pre><a name="23932"></a>java.lang.Exception: Ciao, index=1
</pre><p><a name="23933"></a>
because the embedded assignment of <code>2</code> to <code>index</code> never occurs.
<p><a name="23937"></a>
If the array reference expression produces <code>null</code> instead of a reference to an array, then a <code>NullPointerException</code> is thrown at run time, but only after all parts of the array reference expression have been evaluated and only if these evaluations completed normally. Thus, the example:<p>
<pre><a name="23939"></a>
class Test {
<a name="23940"></a>
	public static void main(String[] args) {
<a name="23941"></a>		int index = 1;
<a name="23942"></a>		try {
<a name="23943"></a>			nada()[index=2]++;
<a name="23944"></a>		} catch (Exception e) {
<a name="23945"></a>			System.out.println(e + ", index=" + index);
<a name="23946"></a>		}
<a name="23947"></a>	}
<a name="23948"></a>	static int[] nada() { return null; }
<a name="23949"></a>}
</pre><p><a name="23950"></a>
prints:
<p><pre><a name="23951"></a>java.lang.NullPointerException, index=2
</pre><p><a name="23952"></a>
because the embedded assignment of <code>2</code> to <code>index</code> occurs before the check for a null 
pointer. As a related example, the program:
<p><pre><a name="36135"></a>
class Test {
<a name="36136"></a>
	public static void main(String[] args) {
<a name="36137"></a>		int[] a = null;
<a name="36138"></a>		try {
<a name="36139"></a>			int i = a[vamoose()];
<a name="36140"></a>			System.out.println(i);
<a name="36141"></a>		} catch (Exception e) {
<a name="36142"></a>			System.out.println(e);
<a name="36143"></a>		}
<a name="36144"></a>	}
<a name="36145"></a>
	static int vamoose() throws Exception {
<a name="36146"></a>		throw new Exception("Twenty-three skidoo!");
<a name="36147"></a>	}
<a name="36148"></a>}
</pre><p><a name="36149"></a>
always prints:
<p><pre><a name="36150"></a>java.lang.Exception: Twenty-three skidoo!
</pre><p><a name="36151"></a>
A <code>NullPointerException</code> never occurs, because the index expression must be 
completely evaluated before any part of the indexing operation occurs, and that 
includes the check as to whether the value of the left-hand operand is <code>null</code>.
<p>

</body></html>
