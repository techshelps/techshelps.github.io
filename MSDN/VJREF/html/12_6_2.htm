<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.6.2 Finalizer Invocations are Not Ordered</title>
<META NAME=MS-HAID CONTENT="12_6_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>12.6.2	 Finalizer Invocations are Not Ordered</h3>
<a name="44837"></a>
<p>
<a name="44838"></a>
Java imposes no ordering on finalize method calls. Finalizers may be called in any 
order, or even concurrently.
<p><a name="44839"></a>
As an example, if a circularly linked group of unfinalized objects becomes unreachable (or finalizer-reachable), then all the objects may become finalizable together. Eventually, the finalizers for these objects may be invoked, in any order, or even concurrently using multiple threads. If the automatic storage manager later finds that the objects are unreachable, then their storage can be reclaimed.<p>
<a name="48740"></a>
It is straightforward to implement a Java class that will cause a set of finalizer-like methods to be invoked in a specified order for a set of objects when all the objects become unreachable. Defining such a class is left as an exercise for the reader.<p>


</body></html>
