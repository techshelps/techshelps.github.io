<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.19.2 Type Comparison Operator instanceof</title>
<META NAME=MS-HAID CONTENT="15_19_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.19.2	 Type Comparison Operator instanceof</h3>
<a name="80289"></a>
<p>
<a name="80291"></a>
<meta name="MS-HKWD" content="instanceof">
The type of a <i>RelationalExpression</i> operand of the <code>instanceof</code> operator must be 
a reference type or the null type; otherwise, a compile-time error occurs. The <i>ReferenceType</i> mentioned after the <code>instanceof</code> operator must denote a reference 
type; otherwise, a compile-time error occurs.
<p><a name="240816"></a>
At run time, the result of the <code>instanceof</code> operator is <code>true</code> if the value of the <i>RelationalExpression</i> is not <code>null</code> and the reference could be cast <a href="15_15.htm#238146">(&#167;15.15)</a> to the <i>ReferenceType</i> without raising a <code>ClassCastException</code>. Otherwise the result is <code>false</code>.<p>
<a name="19920"></a>
If a cast of the <i>RelationalExpression</i> to the <i>ReferenceType</i> would be rejected as a compile-time error, then the <code>instanceof</code> relational expression likewise produces a compile-time error. In such a situation, the result of the <code>instanceof</code> expression could never be <code>true</code>.<p>
<a name="238166"></a>
Consider the example program:<p>
<pre><a name="19921"></a>class Point { int x, y; }
<a name="22799"></a>class Element { int atomicNumber; }
<a name="238077"></a>class Test {
<a name="238078"></a>	public static void main(String[] args) {
<a name="238079"></a>		Point p = new Point();
<a name="22805"></a>		Element e = new Element();
<a name="22806"></a>		if (e instanceof Point) { // compile-time error
<a name="22807"></a>			System.out.println("I get your point!");
<a name="22808"></a>			p = (Point)e; // compile-time error
<a name="22809"></a>		}
<a name="22810"></a>	}
<a name="22811"></a>}
</pre><p><a name="22819"></a>
This example results in two compile-time errors. The cast <code>(Point)e</code> is incorrect 
because no instance of <code>Element</code> or any of its possible subclasses (none are shown 
here) could possibly be an instance of any subclass of <code>Point</code>. The <code>instanceof</code> 
expression is incorrect for exactly the same reason. If, on the other hand, the class 
<code>Point</code> were a subclass of <code>Element</code> (an admittedly strange notion in this example):
<p><pre><a name="40787"></a>class Point extends Element { int x, y; }
</pre><p><a name="40785"></a>
then the cast would be possible, though it would require a run-time check, and the 
<code>instanceof</code> expression would then be sensible and valid. The cast <code>(Point)e</code> 
would never raise an exception because it would not be executed if the value of <code>e</code> 
could not correctly be cast to type <code>Point</code>.
<p>

</body></html>
