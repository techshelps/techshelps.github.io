<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.11.4 Runtime Evaluation of Method Invocation</title>
<META NAME=MS-HAID CONTENT="15_11_4">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.11.4	 Runtime Evaluation of Method Invocation</h3>
<a name="45677"></a>
<p>
<a name="45678"></a>
At run time, method invocation requires five steps. First, a <i>target reference</i> may be 
computed. Second, the argument expressions are evaluated. Third, the accessibility of the method to be invoked is checked. Fourth, the actual code for the method 
to be executed is located. Fifth, a new activation frame is created, synchronization 
is performed if necessary, and control is transferred to the method code.
<p><a name="38359"></a>
<h4>15.11.4.1	 Compute Target Reference (If Necessary)</h4>
<p>
<a name="38338"></a>
There are several cases to consider, depending on which of the three productions 
for <i>MethodInvocation</i> <a href="15_11.htm#20448">(&#167;15.11)</a> is involved:
<p><ul><a name="239420"></a>
<li>If the first production for <i>MethodInvocation</i>, which includes a <i>MethodName</i>, is involved, then there are three subcases:
<ul>
<a name="239421"></a>
<li>If the <i>MethodName</i> is a simple name, that is, just an <i>Identifier</i>, then there are two subcases:
<ul>
<a name="38362"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference.
<a name="38365"></a>
<li>Otherwise, the target reference is the value of <code>this</code>.
</ul>
<a name="38341"></a>
<li>If the <i>MethodName</i> is a qualified name of the form <i>TypeName</i> <code>.</code> <i>Identifier</i>, then there is no target reference.
<a name="38805"></a>
<li>If the <i>MethodName</i> is a qualified name of the form <i>FieldName</i> <code>.</code> <i>Identifier</i>, then there are two subcases:
<ul>
<a name="38806"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference.
<a name="38807"></a>
<li>Otherwise, the target reference is the value of the expression <i>FieldName</i>.
</ul>
</ul>
<a name="38815"></a>
<li>If the second production for <i>MethodInvocation</i>, which includes a <i>Primary</i>, is involved, then there are two subcases:
<ul>
<a name="38816"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference. The expression <i>Primary </i>is evaluated, but the result is then discarded.
<a name="38817"></a>
<li>Otherwise, the expression <i>Primary </i>is evaluated and the result is used as the target reference.
</ul>
</ul>
<p>
<a name="38346"></a>
<p>In either case, if the evaluation of the <i>Primary</i> expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason.
<p>
<ul><a name="38347"></a>
<li>If the third production for <i>MethodInvocation</i>, which includes the keyword <code>super</code>, is involved, then the target reference is the value of <code>this</code>.
</ul><p><a name="45449"></a>

<h4>15.11.4.2	 Evaluate Arguments</h4>
<p>
<a name="21593"></a>
The argument expressions are evaluated in order, from left to right. If the evaluation of any argument expression completes abruptly, then no part of any argument 
expression to its right appears to have been evaluated, and the method invocation 
completes abruptly for the same reason.
<p><a name="45453"></a>
<h4>15.11.4.3	 Check Accessibility of Type and Method</h4>
<p>
<a name="38478"></a>
Let <i>C</i> be the class containing the method invocation, and let <i>T</i> be the class or interface that contained the method being invoked, and <i>m</i> be the name of the method, 
as determined at compile time <a href="15_11_3.htm#23617">(&#167;15.11.3)</a>.
<p><a name="45463"></a>
A Java Virtual Machine must insure, as part of linkage, that the method <i>m</i> still exists in the type <i>T</i>. If this is not true, then a <code>NoSuchMethodError</code> (which is a subclass of <code>IncompatibleClassChangeError</code>) occurs. If the invocation mode is <code>interface</code>, then the virtual machine must also check that the target reference type still implements the specified interface. If the target reference type does not still implement the interface, then an <code>IncompatibleClassChangeError</code> occurs.<p>
<a name="45537"></a>
The virtual machine must also insure, during linkage, that the type <i>T</i> and the method <i>m</i> are accessible. For the type <i>T</i>:<p>
<ul><a name="45547"></a>
<li>If <i>T</i> is in the same package as <i>C</i>, then <i>T</i> is accessible.
<a name="45548"></a>
<li>If <i>T</i> is in a different package than <i>C</i>, and <i>T</i> is <code>public</code>, then <i>T</i> is accessible.
</ul><p><a name="239521"></a>
For the method <i>m</i>:
<p><ul><a name="45542"></a>
<li>If <i>m</i> is <code>public</code>, then <i>m</i> is accessible. (All members of interfaces are <code>public</code> <a href="9_2.htm#32392">(&#167;9.2)</a>).
<a name="45694"></a>
<li>If <i>m</i> is <code>protected</code>, then <i>m</i> is accessible if and only if either <i>T</i> is in the same package as <i>C</i>, or <i>C</i> is <i>T</i> or a subclass of <i>T</i>.
<a name="45695"></a>
<li>If <i>m</i> has default (package) access, then <i>m</i> is accessible if and only if <i>T</i> is in the same package as <i>C</i>.
<a name="45565"></a>
<li>If <i>m</i> is <code>private</code>, then <i>m</i> is accessible if and only if and <i>C</i> is <i>T</i>.
</ul><p><a name="45566"></a>
If either <i>T</i> or <i>m</i> is not accessible, then an <code>IllegalAccessError</code> occurs <a href="12_3.htm#44487">(&#167;12.3)</a>.
<p><a name="45606"></a>
<h4>15.11.4.4	 Locate Method to Invoke</h4>
<p>
<a name="236425"></a>
<a name="38785"></a>
<p>The strategy for method lookup depends on the invocation mode.
<p><a name="45702"></a>
If the invocation mode is <code>static</code>, no target reference is needed and overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="45395"></a>
Otherwise, an instance method is to be invoked and there is a target reference. If the target reference is <code>null</code>, a <code>NullPointerException</code> is thrown at this point. Otherwise, the target reference is said to refer to a <i>target object</i> and will be used as the value of the keyword <code>this</code> in the invoked method. The other four possibilities for the invocation mode are then considered.<p>
<a name="38856"></a>
If the invocation mode is <code>nonvirtual</code>, overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="38864"></a>
Otherwise, the invocation mode is <code>interface</code>, <code>virtual</code>, or <code>super</code>, and overriding may occur. A <i>dynamic method lookup</i> is used. The dynamic lookup process starts from a class <i>S</i>, determined as follows:<p>
<ul><a name="45402"></a>
<li>If the invocation mode is <code>interface</code> or <code>virtual</code>, then <i>S</i> is initially the actual run-time class <i>R</i> of the target object. If the target object is an array, <i>R</i> is the class <code>Object</code>. (Note that for invocation mode <code>interface</code>, <i>R</i> necessarily implements <i>T</i>; for invocation mode <code>virtual</code>, <i>R</i> is necessarily either <i>T</i> or a subclass of <i>T</i>.)
<a name="45403"></a>
<li>If the invocation mode is <code>super</code>, then <i>S</i> is initially the superclass of the class <i>C</i> that contains the method invocation.
</ul><p><a name="39033"></a>
The dynamic method lookup uses the following procedure to search class <i>S</i>, and 
then the superclasses of class <i>S</i>, as necessary, for method <i>m</i>.
<p><ul>
<a name="38917"></a>
<li>If class <i>S</i> contains a declaration for a method named <i>m</i> with the same descriptor (same number of parameters, the same parameter types, and the same return type) required by the method invocation as determined at compile time <a href="15_11_3.htm#23617">(&#167;15.11.3)</a>, then this is the method to be invoked, and the procedure terminates. (We note that as part of the loading and linking process that the virtual machine checks that an overriding method is at least as accessible as the overridden method; an &#32;<code>IncompatibleClassChangeError</code> occurs if this is not the case.)
<a name="38959"></a>
<li>Otherwise, if <i>S</i> is not <i>T</i>, this same lookup procedure is performed using the superclass of <i>S</i>; whatever it comes up with is the result of this lookup.
</ul>
<a name="45627"></a>
<p>This procedure will find a suitable method when it reaches class <code>T</code>, because otherwise an <code>IllegalAccessError</code> would have been thrown by the checks of the previous section <a href="15_11_4.htm#45453">&#167;15.11.4.3</a>.
<p><a name="45714"></a>
We note that the dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.<p>
<a name="39078"></a>
<h4>15.11.4.5	 Create Frame, Synchronize, Transfer Control</h4>
<p>
<a name="39080"></a>
A method <i>m</i> in some class <i>S</i> has been identified as the one to be invoked.
<p><a name="39084"></a>
Now a new <i>activation frame</i> is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and stack for the method to be invoked and any other bookkeeping information that may be required by the implementation (stack pointer, program counter, reference to previous activation frame, and the like). If there is not sufficient memory available to create such an activation frame, an <code>OutOfMemoryError</code> is thrown.<p>
<a name="39085"></a>
The newly created activation frame becomes the current activation frame. The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method, and to make the target reference available as <code>this</code>, if there is a target reference.<p>
<a name="42183"></a>
If the method <i>m</i> is a <code>native</code> method but the necessary native, implementation-dependent binary code has not been loaded (<a href="20_16.htm#6954">&#167;20.16.13</a>, <a href="20_16.htm#30190">&#167;20.16.14</a>) or otherwise cannot be dynamically linked, then an <code>UnsatisfiedLinkError</code> is thrown.<p>
<a name="41731"></a>
If the method <i>m</i> is not <code>synchronized</code>, control is transferred to the body of the method <i>m</i> to be invoked.<p>
<a name="240503"></a>
If the method <i>m</i> is <code>synchronized</code>, then an object must be locked before the transfer of control. No further progress can be made until the current thread can obtain the lock. If there is a target reference, then the target must be locked; otherwise the <code>Class</code> object for class <i>S</i>, the class of the method <i>m</i>, must be locked. Control is then transferred to the body of the method <i>m</i> to be invoked. The object is automatically unlocked when execution of the body of the method has completed, whether normally or abruptly. The locking and unlocking behavior is exactly as if the body of the method were embedded in a <code>synchronized</code> statement <a href="14_17.htm#79287">(&#167;14.17)</a>.<p>
<a name="239532"></a>
<h4>15.11.4.6	 Implementation Note: Combining Frames</h4>
<p>
<a name="39099"></a>
In order to allow certain kinds of code optimization, implementations are permitted some freedom to combine activation frames. Suppose that a method invocation 
within class <i>C</i> is to invoke a method <i>m</i> within class <i>S</i>. Then the current activation 
frame may be used to provide space for <i>S</i> instead of creating a new activation 
frame only if one of the following conditions is true:
<p><ul><a name="39104"></a>
<li>Class <i>C</i> and class <i>S</i> have the same class loader <a href="20_14.htm#14462">(&#167;20.14)</a> and class <i>S</i> is not <code>SecurityManager</code> or a subclass of <code>SecurityManager</code>.
<a name="39105"></a>
<li>Class <i>S</i> has no class loader (this fact indicates that it is a system class); class <i>S</i> is not <code>SecurityManager</code> or a subclass of <code>SecurityManager</code>; and method <i>m</i> is known not to call, directly or indirectly, any method of <code>SecurityManager</code> <a href="20_17.htm#14464">(&#167;20.17)</a> or any of its subclasses.
</ul><p><a name="39122"></a>
<h4>15.11.4.7	 Example: Target Reference and Static Methods</h4>
<p>
<a name="39148"></a>
When a target reference is computed and then discarded because the invocation 
mode is <code>static</code>, the reference is not examined to see whether it is <code>null</code>:
<p><pre><a name="39128"></a>
class Test {
<a name="240507"></a>	static void mountain() {<br>
		System.out.println("Monadnock");<br>
	}
<a name="39130"></a>
	static Test favorite(){
<a name="39131"></a>		System.out.print("Mount ");
<a name="39132"></a>		return null;
<a name="39133"></a>	}
<a name="39134"></a>
	public static void main(String[] args) {
<a name="39135"></a>		favorite().mountain();
<a name="39136"></a>	}
<a name="39137"></a>}
</pre><p><a name="39138"></a>
which prints:
<p><pre><a name="39139"></a>Mount Monadnock
</pre><p><a name="39140"></a>
Here <code>favorite</code> returns <code>null</code>, yet no <code>NullPointerException</code> is thrown.
<p><a name="23837"></a>
<h4>15.11.4.8	 Example: Evaluation Order</h4>
<p>
<a name="23841"></a>
As part of an instance method invocation <a href="15_11.htm#20448">(&#167;15.11)</a>, there is an expression that 
denotes the object to be invoked. This expression appears to be fully evaluated 
before any part of any argument expression to the method invocation is evaluated.
<p><a name="23842"></a>
So, for example, in:<p>
<pre><a name="23843"></a>
class Test {
<a name="45454"></a>	public static void main(String[] args) {
<a name="23844"></a>		String s = "one";
<a name="23845"></a>		if (s.startsWith(s = "two"))
<a name="23846"></a>			System.out.println("oops");
<a name="23847"></a>	}
<a name="23848"></a>}
</pre><p><a name="239641"></a>
the occurrence of <code>s</code> before "<code>.startsWith</code>" is evaluated first, before the argument 
expression <code>s="two"</code>. Therefore, a reference to the string <code>"one"</code> is remembered as 
the target reference before the local variable s is changed to refer to the string 
<code>"two"</code>. As a result, the <code>startsWith</code> method <a href="20_12.htm#2586">(&#167;20.12.20)</a> is invoked for target 
object <code>"one"</code> with argument <code>"two"</code>, so the result of the invocation is <code>false</code>, as the 
string <code>"one"</code> does not start with <code>"two"</code>. It follows that the test program does not 
print "<code>oops</code>".
<p><a name="239650"></a>
<h4>15.11.4.9	 Example: Overriding</h4>
<p>
<a name="239651"></a>
In the example:
<p><pre><a name="239652"></a>
class Point {
<a name="239653"></a>
	final int EDGE = 20;
<a name="239654"></a>	int x, y;
<a name="239655"></a>
	void move(int dx, int dy) {
<a name="239656"></a>		x += dx; y += dy;
<a name="239657"></a>		if (Math.abs(x) &gt;= EDGE || Math.abs(y) &gt;= EDGE)
<a name="239658"></a>			clear();
<a name="239659"></a>	}
<a name="239660"></a>
	void clear() {
<a name="239661"></a>		System.out.println("\tPoint clear");
<a name="239662"></a>		x = 0; y = 0;
<a name="239663"></a>	}
<a name="239664"></a>}
<a name="239665"></a>
class ColoredPoint extends Point {
<a name="239666"></a>	int color;
</pre><p><pre><a name="239667"></a>
	void clear() {
<a name="239668"></a>		System.out.println("\tColoredPoint clear");
<a name="239669"></a>		super.clear();
<a name="239670"></a>		color = 0;
<a name="239671"></a>	}
<a name="239672"></a>}
</pre><p><a name="239673"></a>
the subclass <code>ColoredPoint</code> extends the <code>clear</code> abstraction defined by its superclass <code>Point</code>. It does so by overriding the <code>clear</code> method with its own method, 
which invokes the <code>clear</code> method of its superclass, using the form <code>super.clear</code>.
<p><a name="239674"></a>
This method is then invoked whenever the target object for an invocation of <code>clear</code> is a <code>ColoredPoint</code>. Even the method <code>move</code> in <code>Point</code> invokes the <code>clear</code> method of class <code>ColoredPoint</code> when the class of <code>this</code> is <code>ColoredPoint</code>, as shown by the output of this test program:<p>
<pre><a name="239675"></a>
class Test {
<a name="239676"></a>	public static void main(String[] args) {
<a name="239677"></a>		Point p = new Point();
<a name="239678"></a>		System.out.println("p.move(20,20):");
<a name="239679"></a>		p.move(20, 20);
<a name="239680"></a>		ColoredPoint cp = new ColoredPoint();
<a name="239681"></a>		System.out.println("cp.move(20,20):");
<a name="239682"></a>		cp.move(20, 20);
<a name="239683"></a>		p = new ColoredPoint();
<a name="239684"></a>		System.out.println("p.move(20,20), p colored:");
<a name="239685"></a>		p.move(20, 20);
<a name="239686"></a>	}
<a name="239687"></a>}
</pre><p><a name="239688"></a>
which is:
<p><pre><a name="239689"></a>
p.move(20,20):
<a name="239690"></a>	Point clear
<a name="239691"></a>cp.move(20,20):
<a name="239692"></a>	ColoredPoint clear
<a name="239693"></a>	Point clear
<a name="239694"></a>p.move(20,20), p colored:
<a name="239695"></a>	ColoredPoint clear
<a name="239696"></a>	Point clear
</pre><p><a name="239749"></a>
Overriding is sometimes called "late-bound self-reference"; in this example it means that the reference to <code>clear</code> in the body of <code>Point.move</code> (which is really syntactic shorthand for <code>this.clear</code>) invokes a method chosen "late" (at run time, based on the run-time class of the object referenced by <code>this</code>) rather than a method chosen "early" (at compile time, based only on the type of <code>this</code>). This provides the Java programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.<p>
<a name="239751"></a>
<h4>15.11.4.10	 Example: Method Invocation using super</h4>
<p>
<a name="239647"></a>
An overridden instance method of a superclass may be accessed by using the keyword <code>super</code> to access the members of the immediate superclass, bypassing any 
overriding declaration in the class that contains the method invocation.
<p><a name="39225"></a>
When accessing an instance variable, <code>super</code> means the same as a cast of <code>this</code> <a href="15_10_2.htm#20860">(&#167;15.10.2)</a>, but this equivalence does not hold true for method invocation. This is demonstrated by the example:<p>
<pre><a name="42566"></a>
class T1 {
<a name="42567"></a>	String s() { return "1"; }
<a name="42568"></a>}
<a name="39239"></a>
class T2 extends T1 {
<a name="42569"></a>	String s() { return "2"; }
<a name="42570"></a>}
<a name="42571"></a>
class T3 extends T2 {
<a name="42572"></a>	String s() { return "3"; }
<a name="42573"></a>
	void test() {
<a name="42574"></a>		System.out.println("s()=\t\t"+s());
<a name="42575"></a>		System.out.println("super.s()=\t"+super.s());
<a name="42576"></a>		System.out.print("((T2)this).s()=\t");
<a name="237215"></a>			System.out.println(((T2)this).s());
<a name="42577"></a>		System.out.print("((T1)this).s()=\t");
<a name="237216"></a>			System.out.println(((T1)this).s());
<a name="42578"></a>	}
<a name="42579"></a>}
<a name="42580"></a>
class Test {
<a name="42581"></a>	public static void main(String[] args) {
<a name="42582"></a>		T3 t3 = new T3();
<a name="42583"></a>		t3.test();
<a name="42584"></a>	}
<a name="42585"></a>}
</pre><p><a name="42586"></a>
which produces the output:
<p><pre><a name="42587"></a>
s()=					3
<a name="42588"></a>super.s()=					2
<a name="42589"></a>((T2)this).s()=					3
<a name="42590"></a>((T1)this).s()=					3
</pre><p><a name="239537"></a>
The casts to types <code>T1</code> and <code>T2</code> do not change the method that is invoked, because 
the instance method to be invoked is chosen according to the run-time class of the 
object referred to be <code>this</code>. A cast does not change the class of an object; it only 
checks that the class is compatible with the specified type.
<p>

</body></html>
