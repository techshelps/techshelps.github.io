<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.10.1 Field Access Using a Primary</title>
<META NAME=MS-HAID CONTENT="15_10_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.10.1	 Field Access Using a Primary</h3>
<a name="37055"></a>
<p>
<a name="37056"></a>
The type of the <i>Primary</i> must be a reference type <i>T</i>, or a compile-time error 
occurs. The meaning of the field access expression is determined as follows:
<p><ul><a name="20394"></a>
<li>If the identifier names several accessible member fields of type <i>T</i>, then the field access is ambiguous and a compile-time error occurs.
<a name="37075"></a>
<li>If the identifier does not name an accessible member field of type <i>T</i>, then the field access is undefined and a compile-time error occurs.
<a name="20398"></a>
<li>Otherwise, the identifier names a single accessible member field of type <i>T</i> and the type of the field access expression is the declared type of the field. At run time, the result of the field access expression is computed as follows:
<ul>
<a name="37316"></a>
<li>If the field is <code>static</code>:
<ul>
<a name="37335"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified class variable in the class or interface that is the type of the <i>Primary</i> expression.
<a name="37336"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified class variable in the class that is the type of the <i>Primary</i> expression.
</ul>
<a name="37320"></a>
<li>If the field is not <code>static</code>:
<ul>
<a name="37110"></a>
<li>If the value of the <i>Primary</i> is <code>null</code>, then a <code>NullPointerException</code> is thrown.
<a name="20427"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified instance variable in the object referenced by the value of the <i>Primary</i>.
<a name="20400"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified instance variable in the object referenced by the value of the <i>Primary</i>.
</ul>
</ul>
</ul><p><a name="37135"></a>
Note, specifically, that only the type of the <i>Primary</i> expression, not the class of the 
actual object referred to at run time, is used in determining which field to use.
<p><a name="21262"></a>
Thus, the example:<p>
<pre><a name="20890"></a>class S { int x = 0; }
<a name="20893"></a>class T extends S { int x = 1; }
<a name="20896"></a>class Test {
<a name="20897"></a>	public static void main(String[] args) {
</pre><p><pre><a name="20898"></a>
		T t = new T();
<a name="20899"></a>		System.out.println("t.x=" + t.x + when("t", t));
<a name="20928"></a>
		S s = new S();
<a name="20901"></a>		System.out.println("s.x=" + s.x + when("s", s));
<a name="20902"></a>
		s = t;
<a name="20916"></a>		System.out.println("s.x=" + s.x + when("s", s));
<br><a name="20904"></a>	}
<br><a name="20930"></a>
	static String when(String name, Object t) {
<a name="20931"></a>		return " when " + name + " holds a "
<a name="20959"></a>			+ t.getClass() + " at run time.";
<a name="20932"></a>	}
<a name="20905"></a>}
</pre><p><a name="20906"></a>
produces the output:
<p><pre><a name="20961"></a>
t.x=1 when t holds a class T at run time.
<a name="20962"></a>s.x=0 when s holds a class S at run time.
<a name="45445"></a>s.x=0 when s holds a class T at run time.
</pre><p><a name="45446"></a>
The last line shows that, indeed, the field that is accessed does not depend on the 
run-time class of the referenced object; even if <code>s</code> holds a reference to an object of 
class <code>T</code>, the expression <code>s.x</code> refers to the <code>x</code> field of class <code>S</code>, because the type of the 
expression <code>s</code> is <code>S</code>. Objects of class <code>T</code> contain two fields named <code>x</code>, one for class <code>T</code> 
and one for its superclass <code>S</code>.
<p><a name="22264"></a>
This lack of dynamic lookup for field accesses allows Java to run efficiently with straightforward implementations. The power of late binding and overriding is available in Java, but only when instance methods are used. Consider the same example using instance methods to access the fields:<p>
<pre><a name="37188"></a>class S { int x = 0; int z() { return x; } }
<a name="37189"></a>class T extends S { int x = 1; int z() { return x; } }
<a name="37190"></a>class Test {
</pre><p><pre><a name="37191"></a>
	public static void main(String[] args) {
<a name="37192"></a>		T t = new T();
<a name="37193"></a>		System.out.println("t.z()=" + t.z() + when("t", t));
<a name="37194"></a>		S s = new S();
<a name="37195"></a>		System.out.println("s.z()=" + s.z() + when("s", s));
<a name="37196"></a>		s = t;
<a name="37197"></a>		System.out.println("s.z()=" + s.z() + when("s", s));
<a name="37198"></a>	}
<a name="37199"></a>
	static String when(String name, Object t) {
<a name="37200"></a>		return " when " + name + " holds a "
<a name="37201"></a>			+ t.getClass() + " at run time.";
<a name="37202"></a>	}
<a name="37203"></a>}
</pre><p><a name="238134"></a>
Now the output is:
<p><pre><a name="37243"></a>
t.z()=1 when t holds a class T at run time.
<a name="37244"></a>s.z()=0 when s holds a class S at run time.
<a name="37245"></a>s.z()=1 when s holds a class T at run time.
</pre><p><a name="37254"></a>
The last line shows that, indeed, the method that is accessed <i>does</i> depend on the 
run-time class of referenced object; when <code>s</code> holds a reference to an object of class 
<code>T</code>, the expression <code>s.z()</code> refers to the <code>z</code> method of class <code>T</code>, despite the fact that the 
type of the expression <code>s</code> is <code>S</code>. Method <code>z</code> of class <code>T</code> overrides method <code>z</code> of class <code>S</code>.
<p><a name="22234"></a>
The following example demonstrates that a null reference may be used to access a class (<code>static</code>) variable without causing an exception:<p>
<pre><a name="37293"></a>
class Test {
<a name="37294"></a>	static String mountain = "Chocorua";
<a name="37295"></a>
	static Test favorite(){
<a name="37296"></a>		System.out.print("Mount ");
<a name="37297"></a>		return null;
<a name="37298"></a>	}
<a name="37299"></a>
	public static void main(String[] args) {
<a name="37300"></a>		System.out.println(favorite().mountain);
<a name="37301"></a>	}
<a name="37302"></a>}
</pre><p><a name="22242"></a>
It compiles, executes, and prints:
<p><pre><a name="22243"></a>Mount Chocorua
</pre><p><a name="39173"></a>
Even though the result of <code>favorite()</code> is <code>null</code>, a <code>NullPointerException</code> is <i>not</i> 
thrown. That "<code>Mount </code>" is printed demonstrates that the <i>Primary</i> expression is 
indeed fully evaluated at run time, despite the fact that only its type, not its value, 
is used to determine which field to access (because the field <code>mountain</code> is <code>static</code>).
<p>

</body></html>
