<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.1 Hiding Names</title>
<META NAME=MS-HAID CONTENT="6_3_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>6.3.1	 Hiding Names</h3>
<a name="34133"></a>
<p>
<a name="34051"></a>
Some declarations may be hidden <a href="6_3_1.htm#34133">(&#167;6.3.1)</a> in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to 
the declared entity.
<p><a name="62323"></a>
The example:<p>
<pre><a name="34052"></a>
class Test {
<a name="34053"></a>	static int x = 1;
<a name="34054"></a>	public static void main(String[] args) {
<a name="34055"></a>		int x = 0;
<a name="34056"></a>		System.out.print("x=" + x);
<a name="34057"></a>		System.out.println(", Test.x=" + Test.x);
<a name="34058"></a>	}
<a name="34059"></a>}
</pre><p><a name="34060"></a>
produces the output:
<p><pre><a name="34061"></a>x=0, Test.x=1
</pre><p><a name="34062"></a>
This example declares:
<p><ul><a name="62327"></a>
<li>a class <code>Test</code>
<a name="62331"></a>
<li>a class (<code>static</code>) variable <code>x</code> that is a member of the class <code>Test</code>
<a name="62332"></a>
<li>a class method <code>main</code> that is a member of the class <code>Test</code>
<a name="62333"></a>
<li>a parameter <code>args</code> of the <code>main</code> method
<a name="62334"></a>
<li>a local variable <code>x</code> of the <code>main</code> method
</ul><p><a name="34066"></a>
Since the scope of a class variable includes the entire body of the class <a href="8_2.htm#21831">(&#167;8.2)</a> the class variable <code>x</code> would normally be available throughout the entire body of the method <code>main</code>. In this example, however, the class variable <code>x</code> is hidden within the body of the method <code>main</code> by the declaration of the local variable <code>x</code>.<p>
<a name="62312"></a>
A local variable has as its scope the rest of the block in which it is declared <a href="14_3_2.htm#32644">(&#167;14.3.2)</a>; in this case this is the rest of the body of the <code>main</code> method, namely its initializer "<code>0</code>" and the invocations of <code>print</code> and <code>println</code>.<p>
<a name="62314"></a>
This means that:<p>
<ul><a name="62313"></a>
<li>The expression "<code>x</code>" in the invocation of <code>print</code> refers to (denotes) the value of the local variable <code>x</code>.
<a name="62320"></a>
<li>The invocation of <code>println</code> uses a qualified name <a href="6_6.htm#33916">(&#167;6.6)</a> <code>Test.x</code>, which uses the class type name <code>Test</code> to access the class variable <code>x</code>, because the declaration of <code>Test.x</code> is hidden at this point and cannot be referred to by its simple name.
</ul><p><a name="62307"></a>
If the standard naming conventions <a href="6_8.htm#11186">(&#167;6.8)</a> are followed, then hiding that would make the identification of separate naming contexts matter should be rare. The following contrived example involves hiding because it does not follow the standard naming conventions:<p>
<pre><a name="34080"></a>
class Point { int x, y; }
<a name="34083"></a>
class Test {
<a name="34084"></a>
	static Point Point(int x, int y) {
<a name="34085"></a>		Point p = new Point();
<a name="34086"></a>		p.x = x; p.y = y;
<a name="34087"></a>		return p;
<a name="34088"></a>	}
<br><a name="34089"></a>
	public static void main(String[] args) {
<a name="34090"></a>		int Point;
<a name="34091"></a>		Point[] pa = new Point[2];
<a name="34092"></a>		for (Point = 0; Point &lt; 2; Point++) {
<a name="34093"></a>			pa[Point] = new Point();
<a name="34094"></a>			pa[Point].x = Point;
<a name="34095"></a>			pa[Point].y = Point;
<a name="34096"></a>		}
<a name="34097"></a>		System.out.println(pa[0].x + "," + pa[0].y);
<a name="34098"></a>		System.out.println(pa[1].x + "," + pa[1].y);
<a name="34099"></a>		Point p = Point(3, 4);
<a name="34100"></a>		System.out.println(p.x + "," + p.y);
<a name="34101"></a>	}
<br><a name="34102"></a>}
</pre><p><a name="34103"></a>
This compiles without error and executes to produce the output:
<p><pre><a name="34104"></a>
0,0
<a name="34105"></a>1,1<br>
3,4
</pre><p><a name="34106"></a>
Within the body of <code>main</code>, the lookups of <code>Point</code> find different declarations depending on the context of the use:
<p><ul><a name="34107"></a>
<li>In the expression "<code>new</code> <code>Point[2]</code>", the two occurrences of the class instance creation expression "<code>new</code> <code>Point()</code>", and at the start of three different local variable declaration statements, the <code>Point</code> is a <i>TypeName</i> <a href="6_5_4.htm#21721">(&#167;6.5.4)</a> and denotes the class type <code>Point</code> in each case.
<a name="34268"></a>
<li>In the method invocation expression "<code>Point(3,</code> <code>4)</code>" the occurrence of <code>Point</code> is a <i>MethodName </i><a href="6_5_6.htm#21652">(&#167;6.5.6)</a> and denotes the class (<code>static</code>) method <code>Point</code>.
<a name="34114"></a>
<li>All other names are <i>ExpressionName</i>s <a href="6_5_5.htm#21650">(&#167;6.5.5)</a> and refer to the local variable <code>Point</code>.
</ul><p><a name="34119"></a>
The example:
<p><pre><a name="34120"></a>import java.util.*;
</pre><p><pre><a name="34121"></a>
class Vector {
<a name="34122"></a>	int val[] = { 1 , 2 };
<a name="34123"></a>}
<br><a name="34124"></a>
class Test {
<a name="34125"></a>	public static void main(String[] args) {
<a name="34126"></a>		Vector v = new Vector();
<a name="34127"></a>		System.out.println(v.val[0]);
<a name="34128"></a>	}
<a name="34129"></a>}
</pre><p><a name="34130"></a>
compiles and prints:
<p><pre><a name="34131"></a>1
</pre><p><a name="56469"></a>
using the class <code>Vector</code> declared here in preference to class <code>java.util.Vector</code> 
that might be imported on demand.
<p>

</body></html>
