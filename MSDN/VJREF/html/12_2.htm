<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.2 Loading of Classes and Interfaces</title>
<META NAME=MS-HAID CONTENT="12_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h2>12.2	 Loading of Classes and Interfaces</h2>
<a name="44459"></a>
<p>
<a name="44460"></a>
<i>Loading</i> refers to the process of finding the binary form of a class or interface type 
with a particular name, perhaps by computing it on the fly, but more typically by 
retrieving a binary representation previously computed from source code by a 
compiler, and constructing, from that binary form, a <code>Class</code> object to represent the 
class or interface.
<p><a name="48259"></a>
The binary format of a class or interface is normally the <code>class</code> file format described in <i>The Java Virtual Machine</i>, but other formats are possible, provided they meet the requirements specified in <a href="13_1.htm#44909">&#167;13.1</a>. The method <code>defineClass</code> <a href="20_14.htm#14063">(&#167;20.14.3)</a> of class <code>ClassLoader</code> may be used to construct <code>Class</code> objects from binary representations in the <code>class</code> file format.<p>
<a name="48266"></a>
A Java Virtual Machine system should maintain an internal table of classes and interfaces that have been loaded for the sake of resolving symbolic references. Each entry in the table should consist of a fully qualified class name (as a string), a class loader, and a <code>Class</code> object. Whenever a symbolic reference to a class or interface is to be resolved, a class loader is identified that is responsible for loading the class or interface, if necessary. The table should be consulted first, however; if it already contains an entry for that class name and class loader, then the class object in that entry should be used and no method of the class loader should be invoked. If the table contains no such entry, then the method <code>loadClass</code> <a href="20_14.htm#14061">(&#167;20.14.2)</a> of the class loader should be invoked, giving it the name of the class or interface. If and when it returns, the class object that it returns should be used to make a new entry in the table for that class name and class loader.<p>
<a name="47927"></a>
The purpose of this internal table is to allow the verification process <a href="12_3_1.htm#44491">(&#167;12.3.1)</a> to assume, for its purposes, that two classes or interfaces are the same if they have the same name and the same class loader. This property allows a class to be verified without loading all the classes and interfaces that it uses, whether actively or passively. Well-behaved class loaders do maintain this property: given the same name twice, a good class loader should return the same class object each time. But without the internal table, a malicious class loader could violate this property and undermine the security of the Java type system. A basic principle of the design of the Java language is that the type system cannot be subverted by code written in Java, not even by implementations of such otherwise sensitive system classes as <code>ClassLoader</code> <a href="20_14.htm#14462">(&#167;20.14)</a> and <code>SecurityManager</code> <a href="20_17.htm#14464">(&#167;20.17)</a>.<p>
<a name="47984"></a>
An entry may be deleted from the internal table only after unloading <a href="12_8.htm#44850">(&#167;12.8)</a> the class or interface represented by the class object in the entry.<p>


</body></html>
