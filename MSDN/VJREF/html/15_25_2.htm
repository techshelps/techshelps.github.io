<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.25.2 Compound Assignment Operators</title>
<META NAME=MS-HAID CONTENT="15_25_2">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>15.25.2	 Compound Assignment Operators</h3>
<a name="5304"></a>
<p>
<a name="5305"></a>
All compound assignment operators require both operands to be of primitive type, 
except for <code>+=</code>, which allows the right-hand operand to be of any type if the left-
hand operand is of type <code>String</code>.
<p><a name="5306"></a>
A compound assignment expression of the form <i>E1</i> <i>op</i>= <i>E2</i> is equivalent to <i>E1</i> &#32;<code>=</code> &#32;<code>(</code><i>T</i><code>)((</code><i>E1</i><code>)</code> <i>op</i> <code>(</code><i>E2</i><code>))</code>, where <i>T</i> is the type of <i>E1</i>, except that <i>E1</i> is evaluated only once. Note that the implied cast to type <i>T</i> may be either an identity conversion <a href="5_1_1.htm#25209">(&#167;5.1.1)</a> or a narrowing primitive conversion <a href="5_1_3.htm#175672">(&#167;5.1.3)</a>. For example, the following code is correct:<p>
<pre><a name="236396"></a>
short x = 3;
<a name="236397"></a>x += 4.6;
</pre><p><a name="236398"></a>
and results in <code>x</code> having the value <code>7</code> because it is equivalent to:
<p><pre><a name="236400"></a>
short x = 3;
<a name="236401"></a>x = (short)(x + 4.6);
</pre><p><a name="238395"></a>
At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:<p>
<ul><a name="238396"></a>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
<a name="238397"></a>
<li>Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238433"></a>
<li>Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see <a href="15_16_2.htm#5047">&#167;15.16.2</a>), then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238398"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the left-hand variable and the result of the conversion is stored into the variable.
</ul><p><a name="238402"></a>
If the left-hand operand expression is an array access expression <a href="15_12.htm#239587">(&#167;15.12)</a>, then 
many steps are required:
<p><ul><a name="238403"></a>
<li>First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
<a name="238404"></a>
<li>Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
<a name="238449"></a>
<li>Otherwise, if the value of the array reference subexpression is <code>null</code>, then no assignment occurs and a <code>NullPointerException</code> &#32;is thrown.
</ul><ul><a name="238450"></a>
<li>Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than &#32;or equal to the length of the array, then no assignment occurs and an <code>IndexOutOfBoundsException</code> &#32;is thrown.
<a name="238405"></a>
<li>Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. The value of this component is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. (For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.)
<a name="238408"></a>
<li>Otherwise, consider the array component selected in the previous step, whose value was saved. This component is a variable; call its type <i>S</i><i></i>. Also, let <i>T</i> be the type of the left-hand operand of the assignment operator as determined at compile time.
<ul>
<a name="238409"></a>
<li>If <i>T</i> is a primitive type, then <i>S</i> is necessarily the same as <i>T</i>.
<ul>
<a name="238472"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see <a href="15_16_2.htm#5047">&#167;15.16.2</a>), then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238476"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the array component and the result of the conversion is stored into the array component.
</ul>
<a name="238410"></a>
<li>If <i>T</i> is a reference type, then it must be <code>String</code>. Because class <code>String</code> is a <code>final</code> class, <i>S</i> must also be <code>String</code>. Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.
<ul>
<a name="238488"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) indicated by the compound assignment operator (which is necessarily <code>+=</code>). If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238492"></a>
<li>Otherwise, the <code>String</code> result of the binary operation is stored into the array component.
</ul>
</ul>
</ul><p><a name="238860"></a>
The rules for compound assignment to an array component are illustrated by the 
following example program:
<p><pre><br><a name="238863"></a>class ArrayReferenceThrow extends RuntimeException { }
<br><br><a name="238864"></a>class IndexThrow extends RuntimeException { }
<br><br><a name="238865"></a>class RightHandSideThrow extends RuntimeException { }
<br><a name="238867"></a>class IllustrateCompoundArrayAssignment {
<br><a name="238868"></a>	static String[] strings = { "Simon", "Garfunkel" };
<br><br><a name="238869"></a>	static double[] doubles = { Math.E, Math.PI };
<br></pre><p><pre><a name="238870"></a>
	static String[] stringsThrow() {
<a name="238983"></a>		throw new ArrayReferenceThrow();
<a name="238984"></a>	}
<br><a name="238871"></a>
	static double[] doublesThrow() {
<a name="238985"></a>		throw new ArrayReferenceThrow();
<a name="238986"></a>	}
<br><br><a name="238872"></a>	static int indexThrow() { throw new IndexThrow(); }
<br><a name="238873"></a>
	static String stringThrow() {
<a name="238987"></a>		throw new RightHandSideThrow();
<a name="238988"></a>	}
<br><a name="238874"></a>
	static double doubleThrow() {
<a name="238989"></a>		throw new RightHandSideThrow();
<a name="238990"></a>	}
<br><a name="238875"></a>
	static String name(Object q) {
<a name="238876"></a>		String sq = q.getClass().getName();
<a name="238877"></a>		int k = sq.lastIndexOf('.');
<a name="238878"></a>		return (k &lt; 0) ? sq : sq.substring(k+1);
<a name="238879"></a>	}
<br><a name="238880"></a>
	static void testEight(String[] x, double[] z, int j) {
<a name="238881"></a>		String sx = (x == null) ? "null" : "Strings";
<a name="238882"></a>		String sz = (z == null) ? "null" : "doubles";
<a name="238883"></a>		System.out.println();
<a name="238884"></a>		try {
<a name="238885"></a>			System.out.print(sx + "[throw]+=throw =&gt; ");
<a name="238886"></a>			x[indexThrow()] += stringThrow();
<a name="238887"></a>			System.out.println("Okay!");
<a name="238888"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238889"></a>		try {
<a name="238890"></a>			System.out.print(sz + "[throw]+=throw =&gt; ");
<a name="238891"></a>			z[indexThrow()] += doubleThrow();
<a name="238892"></a>			System.out.println("Okay!");
<a name="238893"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238894"></a>
		try {
<a name="238895"></a>			System.out.print(sx + "[throw]+=\"heh\" =&gt; ");
<a name="238896"></a>			x[indexThrow()] += "heh";
<a name="238897"></a>			System.out.println("Okay!");
<a name="238898"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238899"></a>		try {
<a name="238900"></a>			System.out.print(sz + "[throw]+=12345 =&gt; ");
<a name="238901"></a>			z[indexThrow()] += 12345;
<a name="238902"></a>			System.out.println("Okay!");
<a name="238903"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238904"></a>		try {
<a name="238905"></a>			System.out.print(sx + "[" + j + "]+=throw =&gt; ");
<a name="238906"></a>			x[j] += stringThrow();
<a name="238907"></a>			System.out.println("Okay!");
<a name="238908"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238909"></a>		try {
<a name="238910"></a>			System.out.print(sz + "[" + j + "]+=throw =&gt; ");
<a name="238911"></a>			z[j] += doubleThrow();
<a name="238912"></a>			System.out.println("Okay!");
<a name="238913"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238914"></a>		try {
<a name="238915"></a>			System.out.print(sx + "[" + j + "]+=\"heh\" =&gt; ");
<a name="238916"></a>			x[j] += "heh";
<a name="238917"></a>			System.out.println("Okay!");
<a name="238918"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238919"></a>		try {
<a name="238920"></a>			System.out.print(sz + "[" + j + "]+=12345 =&gt; ");
<a name="238921"></a>			z[j] += 12345;
<a name="238922"></a>			System.out.println("Okay!");
<a name="238923"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238924"></a>	}
<br><a name="238925"></a>
	public static void main(String[] args) {
<a name="238926"></a>		try {
<a name="238927"></a>			System.out.print("throw[throw]+=throw =&gt; ");
<a name="238928"></a>			stringsThrow()[indexThrow()] += stringThrow();
<a name="238929"></a>			System.out.println("Okay!");
<a name="238930"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238931"></a>		try {
<a name="238932"></a>			System.out.print("throw[throw]+=throw =&gt; ");
<a name="238933"></a>			doublesThrow()[indexThrow()] += doubleThrow();
<a name="238934"></a>			System.out.println("Okay!");
<a name="238935"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238936"></a>		try {
<a name="238937"></a>			System.out.print("throw[throw]+=\"heh\" =&gt; ");
<a name="238938"></a>			stringsThrow()[indexThrow()] += "heh";
<a name="238939"></a>			System.out.println("Okay!");
<a name="238940"></a>		} catch (Throwable e) { System.out.println(name(e)); }
</pre><p><pre><a name="238941"></a>
		try {
<a name="238942"></a>			System.out.print("throw[throw]+=12345 =&gt; ");
<a name="238943"></a>			doublesThrow()[indexThrow()] += 12345;
<a name="238944"></a>			System.out.println("Okay!");
<a name="238945"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238946"></a>		try {
<a name="238947"></a>			System.out.print("throw[1]+=throw =&gt; ");
<a name="238948"></a>			stringsThrow()[1] += stringThrow();
<a name="238949"></a>			System.out.println("Okay!");
<a name="238950"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238951"></a>		try {
<a name="238952"></a>			System.out.print("throw[1]+=throw =&gt; ");
<a name="238953"></a>			doublesThrow()[1] += doubleThrow();
<a name="238954"></a>			System.out.println("Okay!");
<a name="238955"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238956"></a>		try {
<a name="238957"></a>			System.out.print("throw[1]+=\"heh\" =&gt; ");
<a name="238958"></a>			stringsThrow()[1] += "heh";
<a name="238959"></a>			System.out.println("Okay!");
<a name="238960"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238961"></a>		try {
<a name="238962"></a>			System.out.print("throw[1]+=12345 =&gt; ");
<a name="238963"></a>			doublesThrow()[1] += 12345;
<a name="238964"></a>			System.out.println("Okay!");
<a name="238965"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238966"></a>
		testEight(null, null, 1);
<a name="238967"></a>		testEight(null, null, 9);
<a name="238968"></a>		testEight(strings, doubles, 1);
<a name="238969"></a>		testEight(strings, doubles, 9);
<a name="238970"></a>	}
<br><a name="238971"></a>}
</pre><p><a name="238992"></a>
This program prints:
<p><pre><a name="238994"></a>
throw[throw]+=throw =&gt; ArrayReferenceThrow
<a name="238995"></a>throw[throw]+=throw =&gt; ArrayReferenceThrow
<a name="238996"></a>throw[throw]+="heh" =&gt; ArrayReferenceThrow
<a name="238997"></a>throw[throw]+=12345 =&gt; ArrayReferenceThrow
<a name="238998"></a>throw[1]+=throw =&gt; ArrayReferenceThrow
<a name="238999"></a>throw[1]+=throw =&gt; ArrayReferenceThrow
<a name="239000"></a>throw[1]+="heh" =&gt; ArrayReferenceThrow
<a name="239001"></a>throw[1]+=12345 =&gt; ArrayReferenceThrow
<br><a name="239003"></a>
null[throw]+=throw =&gt; IndexThrow
<a name="239004"></a>null[throw]+=throw =&gt; IndexThrow
<a name="239005"></a>null[throw]+="heh" =&gt; IndexThrow
<a name="239006"></a>null[throw]+=12345 =&gt; IndexThrow
<a name="239007"></a>null[1]+=throw =&gt; NullPointerException
<a name="239008"></a>null[1]+=throw =&gt; NullPointerException
<a name="239009"></a>null[1]+="heh" =&gt; NullPointerException
<a name="239010"></a>null[1]+=12345 =&gt; NullPointerException
<br><a name="239012"></a>
null[throw]+=throw =&gt; IndexThrow
<a name="239013"></a>null[throw]+=throw =&gt; IndexThrow
<a name="239014"></a>null[throw]+="heh" =&gt; IndexThrow
<a name="239015"></a>null[throw]+=12345 =&gt; IndexThrow
<a name="239016"></a>null[9]+=throw =&gt; NullPointerException
<a name="239017"></a>null[9]+=throw =&gt; NullPointerException
<a name="239018"></a>null[9]+="heh" =&gt; NullPointerException
<a name="239019"></a>null[9]+=12345 =&gt; NullPointerException
<br><a name="239021"></a>
Strings[throw]+=throw =&gt; IndexThrow
<a name="239022"></a>doubles[throw]+=throw =&gt; IndexThrow
<a name="239023"></a>Strings[throw]+="heh" =&gt; IndexThrow
<a name="239024"></a>doubles[throw]+=12345 =&gt; IndexThrow
<a name="239025"></a>Strings[1]+=throw =&gt; RightHandSideThrow
<a name="239026"></a>doubles[1]+=throw =&gt; RightHandSideThrow
<a name="239027"></a>Strings[1]+="heh" =&gt; Okay!
<a name="239028"></a>doubles[1]+=12345 =&gt; Okay!
<br><a name="239030"></a>
Strings[throw]+=throw =&gt; IndexThrow
<a name="239031"></a>doubles[throw]+=throw =&gt; IndexThrow
<a name="239032"></a>Strings[throw]+="heh" =&gt; IndexThrow
<a name="239033"></a>doubles[throw]+=12345 =&gt; IndexThrow
<a name="239034"></a>Strings[9]+=throw =&gt; IndexOutOfBoundsException
<a name="239035"></a>doubles[9]+=throw =&gt; IndexOutOfBoundsException
<a name="239036"></a>Strings[9]+="heh" =&gt; IndexOutOfBoundsException
<a name="239037"></a>doubles[9]+=12345 =&gt; IndexOutOfBoundsException
</pre><p><a name="239051"></a>
The most interesting cases of the lot are tenth and eleventh from the end:
<p><pre><a name="239058"></a>
Strings[1]+=throw =&gt; RightHandSideThrow
<a name="239059"></a>doubles[1]+=throw =&gt; RightHandSideThrow
</pre><p><a name="238861"></a>
They are the cases where a right-hand side that throws an exception actually gets 
to throw the exception; moreover, they are the only such cases in the lot. This 
demonstrates that the evaluation of the right-hand operand indeed occurs after the 
checks for a null array reference value and an out-of-bounds index value.
<p><a name="240007"></a>
The following program illustrates the fact that the value of the left-hand side of a compound assignment is saved before the right-hand side is evaluated:<p>
<pre><a name="240010"></a>
class Test {
<a name="240011"></a>	public static void main(String[] args) {
<a name="240012"></a>		int k = 1;
<a name="240013"></a>		int[] a = { 1 };
<a name="240032"></a>		k += (k = 4) * (k + 2);
<a name="240016"></a>		a[0] += (a[0] = 4) * (a[0] + 2);
<a name="240041"></a>		System.out.println("k==" + k + " and a[0]==" + a[0]);
<a name="240017"></a>	}
<a name="240018"></a>}
</pre><p><a name="240021"></a>
This program prints:
<p><pre><a name="240024"></a>k==25 and a[0]==25
</pre><p><a name="240027"></a>
The value <code>1</code> of <code>k</code> is saved by the compound assignment operator <code>+=</code> before its 
right-hand operand <code>(k</code> <code>=</code> <code>4)</code> <code>*</code> <code>(k</code> <code>+</code> <code>2)</code> is evaluated. Evaluation of this right-hand 
operand then assigns <code>4</code> to <code>k</code>, calculates the value <code>6</code> for <code>k</code> <code>+</code> <code>2</code>, and then multiplies 
<code>4</code> &#32;by &#32;<code>6</code> to get <code>24</code>. This is added to the saved value <code>1</code> to get <code>25</code>, which is then stored 
into <code>k</code> by the <code>+=</code> operator. An identical analysis applies to the case that uses <code>a[0]</code>. 
In short, the statements
<p><pre><a name="240068"></a>
k += (k = 4) * (k + 2);
<a name="240069"></a>a[0] += (a[0] = 4) * (a[0] + 2);
</pre><p><a name="240066"></a>
behave in exactly the same manner as the statements:
<p><pre><a name="240072"></a>
k = k + (k = 4) * (k + 2);
<a name="240073"></a>a[0] = a[0] + (a[0] = 4) * (a[0] + 2);
</pre><p>

</body></html>
