<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<A NAME="_top_"></A>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Class BreakIterator</TITLE>
<H1>
  Class java.text.BreakIterator
</H1>
<A HREF="java.text.BreakIterator001.html">Class Members</A> | 
  <A HREF="Package-java.text.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=3><PRE>
<A HREF="java.lang.Object.html">java.lang.Object</A>
   |
   +----java.text.BreakIterator
</PRE></FONT>

<P><B> public abstract class <B>BreakIterator</B>
  <BR>
 extends <A HREF="java.lang.Object.html">Object</A>
  <BR>
 implements <A HREF="java.lang.Cloneable.html">Cloneable</A>, <A HREF="java.io.Serializable.html">Serializable</A>
<BR>
</B>
<P>

The <B>BreakIterator</B> class implements methods for finding
 the location of boundaries in text. Instances of <B>BreakIterator</B>
 maintain a current position and scan over text
 returning the index of characters where boundaries occur.
 Internally, <B>BreakIterator</B> scans text using a
 <B>CharacterIterator</B>, and is thus able to scan text held
 by any object implementing that protocol. A <B>StringCharacterIterator</B>
 is used to scan <B>String</B> objects passed to <B>setText</B>.
 <P>
 You use the factory methods provided by this class to create
 instances of various types of break iterators. In particular,
 use <B>getWordIterator</B>, <B>getLineIterator</B>,
 <B>getSentenceIterator</B>, and <B>getCharacterIterator</B>
 to create <B>BreakIterator</B>s that perform
 word, line, sentence, and character boundary analysis respectively.
 A single <B>BreakIterator</B> can work only on one unit
 (word, line, sentence, and so on). You must use a different iterator
 for each unit boundary analysis you wish to perform.
 <P>
 Line boundary analysis determines where a text string can be
 broken when line-wrapping. The mechanism correctly handles
 punctuation and hyphenated words.
 <P>
 Sentence boundary analysis allows selection with correct interpretation
 of periods within numbers and abbreviations, and trailing punctuation
 marks such as quotation marks and parentheses.
 <P>
 Word boundary analysis is used by search and replace functions, as
 well as within text editing applications that allow the user to
 select words with a double click. Word selection provides correct
 interpretation of punctuation marks within and following
 words. Characters that are not part of a word, such as symbols
 or punctuation marks, have word-breaks on both sides.
 <P>
 Character boundary analysis allows users to interact with characters
 as they expect to, for example, when moving the cursor through a text
 string. Character boundary analysis provides correct navigation of
 through character strings, regardless of how the character is stored.
 For example, an accented character might be stored as a base character
 and a diacritical mark. What users consider to be a character can
 differ between languages.
 <P>
 <B>BreakIterator</B> is intended for use with natural
 languages only. Do not use this class to tokenize a programming language.
 <P>
 <STRONG>Examples</STRONG>:<P>
 Creating and using text boundaries
 <BLOCKQUOTE>
 </FONT><PRE>
 public static void main(String args[]) {
      if (args.length == 1) {
          String stringToExamine = args[0];
          //print each word in order
          BreakIterator boundary = BreakIterator.getWordInstance();
          boundary.setText(stringToExamine);
          printEachForward(boundary, stringToExamine);
          //print each sentence in reverse order
          boundary = BreakIterator.getSentenceInstance(Locale.US);
          boundary.setText(stringToExamine);
          printEachBackward(boundary, stringToExamine);
          printFirst(boundary, stringToExamine);
          printLast(boundary, stringToExamine);
      }
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Print each element in order
 <BLOCKQUOTE>
 </FONT><PRE>
 public static void printEachForward(BreakIterator boundary, String source) {
     int start = boundary.first();
     for (int end = boundary.next();
          end != BreakIterator.DONE;
          start = end, end = boundary.next()) {
          System.out.println(source.substring(start,end));
     }
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Print each element in reverse order
 <BLOCKQUOTE>
 </FONT><PRE>
 public static void printEachBackward(BreakIterator boundary, String source) {
     int end = boundary.last();
     for (int start = boundary.previous();
          start != BreakIterator.DONE;
          end = start, start = boundary.previous()) {
         System.out.println(source.substring(start,end));
     }
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Print first element
 <BLOCKQUOTE>
 </FONT><PRE>
 public static void printFirst(BreakIterator boundary, String source) {
     int start = boundary.first();
     int end = boundary.next();
     System.out.println(source.substring(start,end));
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Print last element
 <BLOCKQUOTE>
 </FONT><PRE>
 public static void printLast(BreakIterator boundary, String source) {
     int end = boundary.last();
     int start = boundary.previous();
     System.out.println(source.substring(start,end));
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Print the element at a specified position
 <BLOCKQUOTE>
 </FONT><PRE>
 public static void printAt(BreakIterator boundary, int pos, String source) {
     int end = boundary.following(pos);
     int start = boundary.previous();
     System.out.println(source.substring(start,end));
 }
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
<P>
<DL>
    <DT> <B>See Also:</B>
    <DD> <A HREF="java.text.CharacterIterator.html">CharacterIterator</A>
</DL>
<HR>

</BODY>
</HTML>
