<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.2.1 Examples of Inheritance</title>
<META NAME=MS-HAID CONTENT="8_2_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<h3>8.2.1	 Examples of Inheritance</h3>
<a name="30229"></a>
<p>
<a name="36776"></a>
This section illustrates inheritance of class members through several examples.
<p><a name="40830"></a>
<h4>8.2.1.1	 Example: Inheritance with Default Access</h4>
<p>
<a name="40831"></a>
Consider the example where the <code>points</code> package declares two compilation units:
<p><pre><br><a name="40832"></a>package points;
<br></pre><p><pre><a name="40833"></a>
public class Point {
<a name="40834"></a>	int x, y;<br>
	public void move(int dx, int dy) { x += dx; y += dy; }
<a name="40835"></a>}
</pre><p><a name="40836"></a>
and:
<p><pre><br><a name="40837"></a>package points;
<br></pre><p><pre><a name="40838"></a>
public class Point3d extends Point {
<a name="40839"></a>	int z;
<a name="40840"></a>	public void move(int dx, int dy, int dz) {
<a name="40841"></a>		x += dx; y += dy; z += dz;
<a name="40842"></a>	}
<a name="40843"></a>}
</pre><p><a name="40844"></a>
and a third compilation unit, in another package, is:
<p><pre><br><a name="40845"></a>import points.Point3d;
<br></pre><p><pre><a name="40846"></a>
class Point4d extends Point3d {
<a name="40847"></a>	int w;
<a name="40848"></a>	public void move(int dx, int dy, int dz, int dw) {
<a name="40849"></a>		x += dx; y += dy; z += dz; w += dw; // compile-time errors
<a name="40850"></a>	}
<a name="40851"></a>}
</pre><p><a name="40852"></a>
Here both classes in the <code>points</code> package compile. The class <code>Point3d</code> inherits the 
fields <code>x</code> and <code>y</code> of class <code>Point</code>, because it is in the same package as <code>Point</code>. The 
class <code>Point4d</code>, which is in a different package, does not inherit the fields <code>x</code> and <code>y</code> 
of class <code>Point</code> or the field <code>z</code> of class <code>Point3d</code>, and so fails to compile.
<p><a name="40853"></a>
A better way to write the third compilation unit would be:<p>
<pre><br><a name="40854"></a>import points.Point3d;
<br></pre><p><pre><a name="40855"></a>
class Point4d extends Point3d {
<a name="40856"></a>	int w;
<a name="40857"></a>	public void move(int dx, int dy, int dz, int dw) {
<a name="40858"></a>		super.move(dx, dy, dz); w += dw;
<a name="40859"></a>	}
<a name="40860"></a>}
</pre><p><a name="40861"></a>
using the <code>move</code> method of the superclass <code>Point3d</code> to process <code>dx</code>, <code>dy</code>, and <code>dz</code>. If 
<code>Point4d</code> is written in this way it will compile without errors.
<p><a name="40862"></a>
<h4>8.2.1.2	 Inheritance with public and protected</h4>
<p>
<a name="40863"></a>
Given the class <code>Point</code>:
<p><pre><br><a name="40864"></a>package points;
<br></pre><p><pre><a name="40865"></a>
public class Point {
<br><a name="40866"></a>	public int x, y;
<br><br><a name="40867"></a>	protected int useCount = 0;
<br><br><a name="40868"></a>	static protected int totalUseCount = 0;
<br><a name="36785"></a>
	public void move(int dx, int dy) {
<a name="40869"></a>		x += dx; y += dy; useCount++; totalUseCount++;
<a name="40870"></a>	}
<br><a name="40871"></a>}
</pre><p><a name="40872"></a>
the <code>public</code> and <code>protected</code> fields <code>x</code>, <code>y</code>, <code>useCount</code> and <code>totalUseCount</code> are inherited in all subclasses of <code>Point</code>. Therefore, this test program, in another package, 
can be compiled successfully:
<p><pre><a name="40873"></a>
class Test extends points.Point {
<a name="40874"></a>	public void moveBack(int dx, int dy) {
<a name="40875"></a>		x -= dx; y -= dy; useCount++; totalUseCount++;
<a name="40876"></a>	}
<a name="40877"></a>}
</pre><p><a name="40879"></a>
<h4>8.2.1.3	 Inheritance with private</h4>
<p>
<a name="40880"></a>
In the example:
<p><pre><a name="40881"></a>
class Point {
<br><a name="40882"></a>	int x, y;
<br><a name="40883"></a>
	void move(int dx, int dy) {
<a name="40884"></a>		x += dx; y += dy; totalMoves++;
<a name="40885"></a>	}
<br><br><a name="40886"></a>	private static int totalMoves;
<br><br><a name="40887"></a>	void printMoves() { System.out.println(totalMoves); }
<br><a name="40888"></a>}
<br><a name="40889"></a>
class Point3d extends Point {
<br><a name="40890"></a>	int z;
<br><a name="40891"></a>
	void move(int dx, int dy, int dz) {
<a name="40892"></a>		super.move(dx, dy); z += dz; totalMoves++;
<a name="40893"></a>	}
<br><a name="40894"></a>}
</pre><p><a name="40822"></a>
the class variable totalMoves can be used only within the class <code>Point</code>; it is not 
inherited by the subclass <code>Point3d</code>. A compile-time error occurs at the point where 
method <code>move</code> of class <code>Point3d</code> tries to increment totalMoves.
<p><a name="23530"></a>
<h4>8.2.1.4	 Accessing Members of Inaccessible Classes</h4>
<p>
<a name="23515"></a>
Even though a class might not be declared <code>public</code>, instances of the class might be 
available at run time to code outside the package in which it is declared if it has a 
<code>public</code> superclass or superinterface. An instance of the class can be assigned to a 
variable of such a <code>public</code> type. An invocation of a <code>public</code> method of the object 
referred to by such a variable may invoke a method of the class if it implements or 
overrides a method of the <code>public</code> superclass or superinterface. (In this situation, 
the method is necessarily declared <code>public</code>, even though it is declared in a class 
that is not <code>public</code>.)
<p><a name="23519"></a>
Consider the compilation unit:<p>
<pre><br><a name="36842"></a>package points;
<br></pre><p><pre><a name="36843"></a>
public class Point {
<a name="36844"></a>	public int x, y;
<a name="36847"></a>	public void move(int dx, int dy) {
<a name="36848"></a>		x += dx; y += dy;
<a name="36849"></a>	}
<a name="36850"></a>}
</pre><p><a name="36865"></a>
and another compilation unit of another package:
<p><pre><br><a name="23520"></a>package morePoints;
<br></pre><p><pre><a name="23521"></a>
class Point3d extends points.Point {
<a name="23522"></a>	public int z;
<a name="36870"></a>	public void move(int dx, int dy, int dz) {
<a name="36871"></a>		super.move(dx, dy); z += dz;
<a name="36872"></a>	}
<a name="23523"></a>}
<br><a name="23524"></a>
public class OnePoint {
<a name="23525"></a>	static points.Point getOne() { return new Point3d(); }
<a name="23526"></a>}
</pre><p><a name="23527"></a>
An invocation <code>morePoints.OnePoint.getOne()</code> in yet a third package would 
return a <code>Point3d</code> that can be used as a <code>Point</code>, even though the type <code>Point3d</code> is 
not available outside the package <code>morePoints</code>. The method <code>move</code> could then be 
invoked for that object, which is permissible because method <code>move</code> of <code>Point3d</code> is 
<code>public</code> (as it must be, for any method that overrides a <code>public</code> method must itself 
be <code>public</code>, precisely so that situations such as this will work out correctly). The 
fields <code>x</code> and <code>y</code> of that object could also be accessed from such a third package.
<p><a name="36884"></a>
While the field <code>z</code> of class <code>Point3d</code> is <code>public</code>, it is not possible to access this field from code outside the package <code>morePoints</code>, given only a reference to an instance of class <code>Point3d</code> in a variable <code>p</code> of type <code>Point</code>. This is because the expression <code>p.z</code> is not correct, as <code>p</code> has type <code>Point</code> and class <code>Point</code> has no field named <code>z</code>; also, the expression <code>((Point3d)p).z</code> is not correct, because the class type <code>Point3d</code> cannot be referred to outside package <code>morePoints</code>. The declaration of the field <code>z</code> as <code>public</code> is not useless, however. If there were to be, in package <code>morePoints</code>, a <code>public</code> subclass <code>Point4d</code> of the class <code>Point3d</code>:<p>
<pre><br><a name="36889"></a>package morePoints;
<br></pre><p><pre><a name="36890"></a>
public class Point4d extends Point3d {
<a name="36891"></a>	public int w;
<a name="36892"></a>	public void move(int dx, int dy, int dz, int dw) {
<a name="36893"></a>		super.move(dx, dy, dz); w += dw;
<a name="36894"></a>	}
<a name="36896"></a>}
<br></pre><p><a name="36887"></a>
then class <code>Point4d</code> would inherit the field <code>z</code>, which, being <code>public</code>, could then be 
accessed by code in packages other than <code>morePoints</code>, through variables and 
expressions of the <code>public</code> type <code>Point4d</code>.
<p>

</Font></body></html>
