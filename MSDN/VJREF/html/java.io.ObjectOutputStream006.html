<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ObjectOutputStream.annotateClass</TITLE></HEAD>
<H3>
<A NAME="annotateClass">ObjectOutputStream.annotateClass</A></H3>
<P>
<A HREF="java.io.ObjectOutputStream.html">Class Overview</A> | <A HREF="java.io.ObjectOutputStream001.html">Class Members</A> | 
  <A HREF="Package-java.io.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>

<H5>
<A NAME="annotateClass(java.lang.Class)">Syntax</A></H5>
<B>
 protected void annotateClass( <A HREF="java.lang.Class.html">Class</A></B><I> cl</I><B> ) throws <A HREF="java.io.IOException.html">IOException</A>
</B>
<H5>Description</H5>
 Subclasses may implement this method to allow class data to be stored
 in the stream. By default this method does nothing.
 The corresponding method in ObjectInputStream is resolveClass.
 This method is called exactly once for each unique class in the stream.
 The class name and signature will have already been written to the stream.
 This method may make free use of the ObjectOutputStream to save
 any representation of the class it deems suitable (for example,
 the bytes of the class file).  The resolveClass method in the corresponding
 subclass of ObjectInputStream must read and use any data or objects
 written by annotateClass. 
 annotateClass is called only for normal classes.  Arrays are not normal classes.
<P>
  <H5>
Exceptions</H5>
</B> <A HREF="java.io.IOException.html">IOException</A>
     Any exception thrown by the underlying OutputStream.
  
<P>

</BODY>
</HTML>
