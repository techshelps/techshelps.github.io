<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.4.1 When Initialization Occurs</title>
<META NAME=MS-HAID CONTENT="12_4_1">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>12.4.1	 When Initialization Occurs</h3>
<a name="44560"></a>
<p>
<a name="44561"></a>
A class or interface type <i>T</i> will be <i>initialized</i> at its first <i>active use</i>, which occurs if:
<p><ul><a name="44562"></a>
<li><i>T</i> is a class and a method actually declared in <i>T</i> (rather than inherited from a superclass) is invoked.
<a name="44563"></a>
<li><i>T</i> is a class and a constructor for class <i>T</i> is invoked, or <i>U</i> is an array with element type <i>T</i>, and an array of type <i>U</i> is created.
<a name="44564"></a>
<li>A non-constant field declared in <i>T</i> (rather than inherited from a superclass or superinterface) is used or assigned. A <i>constant field</i> is one that is (explicitly or implicitly) both <code>final</code> and <code>static</code>, and that is initialized with the value of a compile-time constant expression <a href="15_27.htm#5313">(&#167;15.27)</a>. Java specifies that a reference to a constant field must be resolved at compile time to a copy of the compile-time constant value, so uses of such a field are never active uses. See <a href="13_4_8.htm#45139">&#167;13.4.8</a> for a further discussion.
</ul><p><a name="44568"></a>
All other uses of a type are <i>passive uses</i>.
<p><a name="46862"></a>
The intent here is that a class or interface type has a set of initializers that put it in a consistent state, and that this state is the first state that is observed by other classes. The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope <a href="8_5.htm#39245">(&#167;8.5)</a>. This restriction is designed to detect, at compile time, most circular or otherwise malformed initializations. &#32;<p>
<a name="46874"></a>
As shown in an example in <a href="8_5.htm#39245">&#167;8.5</a>, the fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable can be observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice. (Such examples can be also constructed for instance variable initialization; see the example at the end of <a href="12_5.htm#44670">&#167;12.5</a>). Java provides the full power of the language in these initializers; programmers must exercise some care. This power places an extra burden on code generators, but this burden would arise in any case because Java is concurrent <a href="12_4_3.htm#44667">(&#167;12.4.3)</a>.<p>
<a name="44569"></a>
Before a class is initialized, its superclasses are initialized, if they have not previously been initialized.<p>
<a name="44570"></a>
Thus, the test program:<p>
<pre><a name="44571"></a>
class Super {
<a name="44572"></a>	static { System.out.print("Super "); }
<a name="44573"></a>}
<a name="44574"></a>
class One {
<a name="44575"></a>	static { System.out.print("One "); }
<a name="44576"></a>}
<a name="44577"></a>
class Two extends Super {
<a name="44578"></a>	static { System.out.print("Two "); }
<a name="44579"></a>}
<a name="44580"></a>
class Test {
<a name="44581"></a>	public static void main(String[] args) {
<a name="44582"></a>		One o = null;
<a name="44583"></a>		Two t = new Two();
<a name="44584"></a>		System.out.println((Object)o == (Object)t);
<a name="44585"></a>	}
<a name="44586"></a>}
</pre><p><a name="44587"></a>
prints:
<p><pre><a name="44588"></a>Super Two false
</pre><p><a name="44589"></a>
The class <code>One</code> is never initialized, because it not used actively and therefore is 
never linked to. The class <code>Two</code> is initialized only after its superclass <code>Super</code> has 
been initialized.
<p><a name="44590"></a>
A reference to a field is an active use of only the class or interface that actually declares it, even though it might be referred to through the name of a subclass, a subinterface, or a class that implements an interface. The test program:<p>
<pre><a name="44591"></a>
class Super { static int taxi = 1729; }
<a name="44592"></a>
class Sub extends Super {
<a name="44593"></a>	static { System.out.print("Sub "); }
<a name="44594"></a>}
<a name="44595"></a>
class Test {
<a name="44596"></a>	public static void main(String[] args) {
<a name="44597"></a>		System.out.println(Sub.taxi);
<a name="44598"></a>	}
<a name="44599"></a>}
</pre><p><a name="44600"></a>
prints only:
<p><pre><a name="44601"></a>1729
</pre><p><a name="44602"></a>
because the class <code>Sub</code> is never initialized; the reference to <code>Sub.taxi</code> is a reference 
to a field actually declared in class <code>Super</code> and is not an active use of the class <code>Sub</code>.
<p><a name="44603"></a>
Initialization of an interface does not, of itself, require initialization of any of its superinterfaces. Thus, the test program:<p>
<pre><a name="44604"></a>
interface I {
<a name="44605"></a>	int i = 1, ii = Test.out("ii", 2);
<a name="44606"></a>}
<a name="44607"></a>
interface J extends I {
<a name="44608"></a>	int j = Test.out("j", 3), jj = Test.out("jj", 4);
<a name="44609"></a>}
<a name="44610"></a>
interface K extends J {
<a name="44611"></a>	int k = Test.out("k", 5);
<a name="44612"></a>}
<a name="44613"></a>
class Test {
<a name="44614"></a>
	public static void main(String[] args) {
<a name="44615"></a>		System.out.println(J.i);
<a name="44616"></a>		System.out.println(K.j);
<a name="44617"></a>	}
<a name="44618"></a>
	static int out(String s, int i) {
<a name="44619"></a>		System.out.println(s + "=" + i);
<a name="44620"></a>		return i;
<a name="44621"></a>	}
<a name="44622"></a>}
</pre><p><a name="44623"></a>
produces the output:
<p><pre><a name="44624"></a>
1
<a name="44625"></a>j=3
<a name="44626"></a>jj=4
<a name="44627"></a>3
</pre><p><a name="44628"></a>
The reference to <code>J.i</code> is to a field that is a compile-time constant; therefore, it does 
not cause <code>I</code> to be initialized. The reference to <code>K.j</code> is a reference to a field actually 
declared in interface <code>J</code> that is not a compile-time constant; this causes initialization of the fields of interface <code>J</code>, but not those of its superinterface <code>I</code>, nor those of 
interface <code>K</code>. Despite the fact that the name <code>K</code> is used to refer to field <code>j</code> of interface 
<code>J</code>, interface <code>K</code> is not actively used.
<p>

</body></html>
