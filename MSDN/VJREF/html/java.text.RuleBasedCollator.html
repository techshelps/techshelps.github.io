<HTML>
<BODY BGCOLOR="#FFFFFF">
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
<A NAME="_top_"></A>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Class RuleBasedCollator</TITLE>
<H1>
  Class java.text.RuleBasedCollator
</H1>
<A HREF="java.text.RuleBasedCollator001.html">Class Members</A> | 
  <A HREF="Package-java.text.html">This Package</A> | 
<A HREF="javapackages.htm">All Packages</A>
<FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=3><PRE>
<A HREF="java.lang.Object.html">java.lang.Object</A>
   |
   +----<A HREF="java.text.Collator.html">java.text.Collator</A>
           |
           +----java.text.RuleBasedCollator
</PRE></FONT>

<P><B> public class <B>RuleBasedCollator</B>
  <BR>
 extends <A HREF="java.text.Collator.html">Collator</A>
<BR>
</B>
<P>

The <B>RuleBasedCollator</B> class is a concrete subclass of
 <B>Collator</B> that provides a simple, data-driven, table collator.
 With this class you can create a customized table-based <B>Collator</B>.
 <B>RuleBasedCollator</B> maps characters to sort keys.
 <P>
 <B>RuleBasedCollator</B> has the following restrictions
 for efficiency (other subclasses may be used for more complex languages) :
 <OL>
 <LI>The French secondary ordering is applied to the whole collator
     object.
 <LI>All non-mentioned Unicode characters are at the end of the
     collation order.
 <LI>Private use characters are treated as identical.  The private
     use area in Unicode is <B>0xE800</B>-<B>0xF8FF</B>.
 </OL>
 <P>
 The collation table is composed of a list of collation rules, where each
 rule is of three forms:
 </FONT><PRE>
    &lt; modifier >
    &lt; relation > &lt; text-argument >
    &lt; reset > &lt; text-argument >
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 The following demonstrates how to create your own collation rules:
 <UL TYPE=ROUND>
    <LI><STRONG>Text-Argument</STRONG>: A text-argument is any sequence of
        characters, excluding special characters (that is, whitespace
        characters and the characters used in modifier, relation and reset).
        If those characters are desired, you can put them in single quotes
        (e.g. ampersand => '&').
    <LI><STRONG>Modifier</STRONG>: There is a single modifier
        which is used to specify that all accents (secondary differences) are
        backwards.
        <P>'@' : Indicates that accents are sorted backwards, as in French.
    <LI><STRONG>Relation</STRONG>: The relations are the following:
        <UL TYPE=SQUARE>
            <LI>'&lt;' : Greater, as a letter difference (primary)
            <LI>';' : Greater, as an accent difference (secondary)
            <LI>',' : Greater, as a case difference (tertiary)
            <LI>'=' : Equal
        </UL>
    <LI><STRONG>Reset</STRONG>: There is a single reset
        which is used primarily for contractions and expansions, but which
        can also be used to add a modification at the end of a set of rules.
        <P>'&' : Indicates that the next rule follows the position to where
            the reset text-argument would be sorted.
 </UL>
 <P>
 This sounds more complicated than it is in practice. For example, the
 following are equivalent ways of expressing the same thing:
 <BLOCKQUOTE>
 </FONT><PRE>
 a &lt; b &lt; c
 a &lt; b & b &lt; c
 a &lt; c & a &lt; b
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Notice that the order is important, as the subsequent item goes immediately
 after the text-argument. The following are not equivalent:
 <BLOCKQUOTE>
 </FONT><PRE>
 a &lt; b & a &lt; c
 a &lt; c & a &lt; b
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Either the text-argument must already be present in the sequence, or some
 initial substring of the text-argument must be present. (e.g. "a &lt; b & ae &lt; e" 
 is valid since "a" is present in the sequence before "ae" is reset). In
 this latter case, "ae" is not entered and treated as a single character;
 instead, "e" is sorted as if it were expanded to two characters: "a"
 followed by an "e". This difference appears in natural languages: in
 traditional Spanish "ch" is treated as though it contracts to a single
 character (expressed as "c &lt; ch &lt; d"), while in traditional German "ä"
 (a-umlaut) is treated as though it expands to two characters (expressed as
 "a & ae ; ä &lt; b").
 <P>
 <STRONG>Ignorable Characters</STRONG>
 <P>
 For ignorable characters, the first rule must start with a relation (the
 examples we have used above are really fragments; "a &lt; b" really should be
 "&lt; a &lt; b"). If, however, the first relation is not "&lt;", then all the
 text-arguments up to the first "&lt;" are ignorable. For example, ", - &lt; a &lt; b"
 makes "-" an ignorable character, as we saw earlier in the word
 "black-birds". In the samples for different languages, you see that most
 accents are ignorable.
 <P><STRONG>Normalization and Accents</STRONG>
 <P> 
 The <B>Collator</B> object automatically normalizes text internally
 to separate accents from base characters where possible. This is done both when
 processing the rules, and when comparing two strings. <B>Collator</B>
 also uses the Unicode canonical mapping to ensure that combining sequences
 are sorted properly (for more information, see
 <A HREF="http://www.aw.com/devpress">The Unicode Standard, Version 2.0</A>.)</P>
 <P><STRONG>Errors</STRONG>
 <P>
 The following are errors:
 <UL TYPE=ROUND>
     <LI>A text-argument not preceded by either a reset or relation character
        (e.g. "a &lt; b c &lt; d").
     <LI>A relation or reset character not followed by a text-argument
        (e.g. "a &lt; , b").
     <LI>A reset where the text-argument (or an initial substring of the
         text-argument) is not already in the sequence.
         (e.g. "a &lt; b & e &lt; f")
 </UL>
 If you produce one of these errors, a <B>RuleBasedCollator</B> throws
 a <B>ParseException</B>.
 <P><STRONG>Examples</STRONG>
 <P>Simple:     "&lt; a &lt; b &lt; c &lt; d"
 <P>Norwegian:  "&lt; a,A&lt; b,B&lt; c,C&lt; d,D&lt; e,E&lt; f,F&lt; g,G&lt; h,H&lt; i,I&lt; j,J
                 &lt; k,K&lt; l,L&lt; m,M&lt; n,N&lt; o,O&lt; p,P&lt; q,Q&lt; r,R&lt; s,S&lt; t,T
                 &lt; u,U&lt; v,V&lt; w,W&lt; x,X&lt; y,Y&lt; z,Z
                 &lt; å=a?,Å=A?
                 ;aa,AA&lt; æ,Æ&lt; ø,Ø"
 <P>
 Normally, to create a rule-based Collator object, you will use
 <B>Collator</B>'s factory method <B>getInstance</B>.
 However, to create a rule-based Collator object with specialized
 rules tailored to your needs, you construct the <B>RuleBasedCollator</B>
 with the rules contained in a <B>String</B> object. For example:
 <BLOCKQUOTE>
 </FONT><PRE>
 String Simple = "&lt; a &lt; b &lt; c &lt; d";
 RuleBasedCollator mySimple = new RuleBasedCollator(Simple);
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 Or:
 <BLOCKQUOTE>
 </FONT><PRE>
 String Norwegian = "&lt; a,A&lt; b,B&lt; c,C&lt; d,D&lt; e,E&lt; f,F&lt; g,G&lt; h,H&lt; i,I&lt; j,J" +
                 "&lt; k,K&lt; l,L&lt; m,M&lt; n,N&lt; o,O&lt; p,P&lt; q,Q&lt; r,R&lt; s,S&lt; t,T" +
                 "&lt; u,U&lt; v,V&lt; w,W&lt; x,X&lt; y,Y&lt; z,Z" +
                 "&lt; å=a?,Å=A?" +
                 ";aa,AA&lt; æ,Æ&lt; ø,Ø";
 RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian);
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 <P>
 Combining <B>Collator</B>s is as simple as concatenating strings.
 Here's an example that combines two <B>Collator</B>s from two
 different locales:
 <BLOCKQUOTE>
 </FONT><PRE>
 // Create an en_US Collator object
 RuleBasedCollator en_USCollator = (RuleBasedCollator)
     Collator.getInstance(new Locale("en", "US", ""));
 // Create a da_DK Collator object
 RuleBasedCollator da_DKCollator = (RuleBasedCollator)
     Collator.getInstance(new Locale("da", "DK", ""));
 // Combine the two
 // First, get the collation rules from en_USCollator
 String en_USRules = en_USCollator.getRules();
 // Second, get the collation rules from da_DKCollator
 String da_DKRules = da_DKCollator.getRules();
 RuleBasedCollator newCollator =
     new RuleBasedCollator(en_USRules + da_DKRules);
 // newCollator has the combined rules
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 <P>
 Another more interesting example would be to make changes on an existing
 table to create a new <B>Collator</B> object.  For example, add
 "& C &lt; ch, cH, Ch, CH" to the <B>en_USCollator</B> object to create
 your own:
 <BLOCKQUOTE>
 </FONT><PRE>
 // Create a new Collator object with additional rules
 String addRules = "& C &lt; ch, cH, Ch, CH";
 RuleBasedCollator myCollator =
     new RuleBasedCollator(en_USCollator + addRules);
 // myCollator contains the new rules
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 <P>
 The following example demonstrates how to change the order of
 non-spacing accents,
 <BLOCKQUOTE>
 </FONT><PRE>
 // old rule
 String oldRules = "=?;?;?;?"    // main accents
                 + ";?;?;?;?"    // main accents
                 + ";?;?;?;?"    // main accents
                 + ";?;?;?;?"    // main accents
                 + ";?;?;?;?"    // main accents
                 + "&lt; a , A ; ae, AE ; æ , Æ"
                 + "&lt; b , B &lt; c, C &lt; e, E & C &lt; d, D";
 // change the order of accent characters
 String addOn = "& ? ; ? ; ?";
 RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
 <P>
 The last example shows how to put new primary ordering in before the
 default setting. For example, in Japanese <B>Collator</B>, you
 can either sort English characters before or after Japanese characters,
 <BLOCKQUOTE>
 </FONT><PRE>
 // get en_US Collator rules
 RuleBasedCollator en_USCollator = (RuleBasedCollator)Collator.getInstance(Locale.US);
 // add a few Japanese character to sort before English characters
 // suppose the last character before the first base letter 'a' in
 // the English collation rule is ?
 String jaString = "& ? &lt; ?, ? &lt; ?, ?";
 RuleBasedCollator myJapaneseCollator = new
     RuleBasedCollator(en_USCollator.getRules() + jaString);
 </PRE><FONT FACE=VERDANA,ARIAL,HELVETICA SIZE=2>
 </BLOCKQUOTE>
<P>
<DL>
    <DT> <B>See Also:</B>
    <DD> <A HREF="java.text.Collator.html">Collator</A>, <A HREF="java.text.CollationElementIterator.html">CollationElementIterator</A>
</DL>
<HR>

</BODY>
</HTML>
