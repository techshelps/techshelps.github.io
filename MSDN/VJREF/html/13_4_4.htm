<html>
<head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.4.4 Superclasses and Superinterfaces</title>
<META NAME=MS-HAID CONTENT="13_4_4">
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></head>
<body bgcolor=#ffffff>

<h3>13.4.4	 Superclasses and Superinterfaces</h3>
<a name="44994"></a>
<p>
<a name="44995"></a>
A <code>ClassCircularityError</code> is thrown at load time if a class would be a superclass of itself. Changes to the class hierarchy that could result in such a circularity 
when newly compiled binaries are loaded with pre-existing binaries are not recommended for widely distributed classes.
<p><a name="44996"></a>
Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.<p>
<a name="44997"></a>
Changes to the set of superclasses of a class will not break compatibility with pre-existing binaries simply because of uses of class variables and class methods. This is because uses of class variables and class methods are resolved at compile time to symbolic references to the name of the class that declares them. Such uses therefore depend only on the continuing existence of the class declaring the variable or method, not on the shape of the class hierarchy.<p>
<a name="44998"></a>
If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, then link-time errors may result if pre-existing binaries are loaded with the binary of the modified class. Such changes are not recommended for widely distributed classes. The resulting errors are detected by the verifier of the Java Virtual Machine when an operation that previously compiled would violate the type system. For example, suppose that the following test program:<p>
<pre><a name="44999"></a>class Hyper { char h = 'h'; } 
<a name="45000"></a>class Super extends Hyper { char s = 's'; }
<a name="45001"></a>class Test extends Super {
<a name="45002"></a>    public static void main(String[] args) {
<a name="45003"></a>        Hyper h = new Super();
<a name="45004"></a>        System.out.println(h.h);
<a name="45005"></a>    }
<a name="45006"></a>}
</pre><p><a name="45007"></a>
is compiled and executed, producing the output:
<p><pre><a name="45008"></a>h
</pre><p><a name="47239"></a>
Suppose that a new version of class <code>Super</code> is then compiled:
<p><pre><a name="47240"></a>class Super { char s = 's'; }
</pre><p><a name="47241"></a>
This version of class <code>Super</code> is not a subclass of <code>Hyper</code>. If we then run the existing 
binaries of <code>Hyper</code> and <code>Test</code> with the new version of <code>Super</code>, then a <code>VerifyError</code> 
is thrown at link time. The verifier objects because the result of <code>new</code> <code>Super()</code> 
cannot &#32;be assigned to a variable of type <code>Hyper</code>, because <code>Super</code> is not a subclass of 
<code>Hyper</code>.
<p><a name="45012"></a>
It is instructive to consider what might happen without the verification step: the program might run and print:<p>
<pre><a name="45013"></a>s
</pre><p><a name="45014"></a>
This demonstrates that without the verifier the type system could be defeated by 
linking inconsistent binary files, even though each was produced by a correct Java 
compiler.
<p><a name="45015"></a>
As a further example, here is an implementation of a cast from a reference type to <code>int</code>, which could be made to run in certain implementations of Java if they failed to perform the verification process. Assume an implementation that uses method dispatch tables and whose linker assigns offsets into those tables in a sequential and straightforward manner. Then suppose that the following Java code is compiled:<p>
<pre><a name="45016"></a>class Hyper { int zero(Object o) { return 0; } }
<a name="45017"></a>class Super extends Hyper { int peek(int i) { return i; }  }
</pre><p><pre><a name="45018"></a>
class Test extends Super {
<a name="45019"></a>	public static void main(String[] args) throws Throwable {
<a name="45020"></a>		Super as = new Super();
<a name="45021"></a>		System.out.println(as);
<a name="45022"></a>		System.out.println(Integer.toHexString(as.zero(as)));
<a name="45023"></a>	}
<a name="45024"></a>}
</pre><p><a name="45025"></a>
The assumed implementation determines that the class <code>Super</code> has two methods: 
the first is method <code>zero</code> inherited from class <code>Hyper</code>, and the second is the method 
<code>peek</code>. Any subclass of <code>Super</code> would also have these same two methods in the first 
two entries of its method table. (Actually, all these methods would be preceded in 
the method tables by all the methods inherited from class <code>Object</code> but, to simplify 
the discussion, we ignore that here.) For the method invocation <code>as.zero(as)</code>, the 
compiler specifies that the first method of the method table should be invoked; this 
is always correct if type safety is preserved.
<p><a name="45026"></a>
If the compiled code is then executed, it prints something like:<p>
<pre><a name="45027"></a>
Super@ee300858
<a name="45028"></a>0
</pre><p><a name="45029"></a>
which is the correct output. But if a new version of <code>Super</code> is compiled, which is 
the same except for the <code>extends</code> clause:
<p><pre><a name="47244"></a>class Super { int peek(int i) { return i; }  }
</pre><p><a name="45031"></a>
then the first method in the method table for <code>Super</code> will now be <code>peek</code>, not <code>zero</code>. 
Using the new binary code for <code>Super</code> with the old binary code for <code>Hyper</code> and 
<code>Test</code> will cause the method invocation <code>as.zero(as)</code> to dispatch to the method 
<code>peek</code> in <code>Super</code>, rather than the method <code>zero</code> in <code>Hyper</code>. This is a type violation, of 
course; the argument is of type <code>Super</code> but the parameter is of type <code>int</code>. With a few 
plausible assumptions about internal data representations and the consequences of 
the type violation, execution of this incorrect program might produce the output:
<p><pre><a name="45032"></a>
Super@ee300848
<a name="45033"></a>ee300848
</pre><p><a name="45034"></a>
A <code>poke</code> method, capable of altering any location in memory, could be concocted 
in a similar manner. This is left as an exercise for the reader.
<p><a name="45035"></a>
The lesson is that a implementation of Java that lacks a verifier or fails to use it will not maintain type safety and is, therefore, not a valid Java implementation. <p>


</body></html>
