<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DAO and the Apartment-threading Model</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="dahowapartmentthreading"></a>DAO and the Apartment-threading Model</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="dahowApartmentThreadingC">
</object></p>
<p>
DAO 3.5 can be used in several threads of a multi-tasking application to accomplish many tasks simultaneously. For example, a long running query may be performed by one thread, while the contents of a large recordset may be displayed by another thread.</p>
<p>
This is possible because DAO 3.5 is an inproc (DLL-based) server which supports the OLE Apartment-threading Model. The Apartment-threading Model defines one way interface calls are made to an OLE object and how interface pointers are passed between threads.</p>
<h1>Characteristics of the Apartment-threading Model</h1>
<p>
The Apartment-threading Model is characterized by these attributes:
<ul type=disc>
<li>
One or more threads in a process uses OLE and calls to OLE objects are synchronized by OLE. Thus, several clients may call DAO simultaneously because OLE will deliver the calls in order and one at a time.<br><br></li>
<li>
An <b>apartment</b> is a set of OLE objects associated with a particular thread. These objects are created by the thread or are proxies created as a consequence of marshaling to the thread. If the object or proxy needs to be accessed by another apartment, its interface pointer must be marshaled to that apartment where a new proxy is created.<br><br></li>
<li>
The client thread associated with an <b>apartment</b> must call <b>CoInitialize()</b> or <b>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)</b>.<br><br></li>
<li>
The client thread associated with an apartment must retrieve and dispatch window messages so the associated objects can receive incoming calls. </li>
</ul>
<h1>Client Responsibilities in the Apartment-threading Model</h1>
<p>
The client responsibilities in the Apartment-threading Model are listed below:
<ul type=disc>
<li>
Marshaling — A client that uses the apartment model must marshal interfaces of an object between apartments by using <b>CoMarshalInterThreadInterfaceInStream</b> and <b>CoGetInterfaceAndReleaseStream</b>.<br><br></li>
<li>
For example, if Apartment 1 in the client has an interface pointer, and Apartment 2 requires use of it, Apartment 1 must marshal the interface using <b>CoMarshalInterThreadInterfaceInStream</b>. The stream returned by this function is thread-safe and must be stored in a variable accessible by Apartment 2. Apartment 2 must pass this stream to <b>CoGetInterfaceAndReleaseStream</b> to unmarshal the interface and get back a pointer to a proxy through which it can access the interface.<br><br></li>
<li>
<b>CoInitialize/CoInitializeEx</b> — The thread of an apartment must initialize OLE for its use by calling <b>CoInitialize</b> or <b>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)</b>. This thread must remain alive until the client has completed all OLE work.<br><br></li>
<li>
Dispatching Messages — OLE uses window messages to synchronize the delivery of calls to an object. The thread of an apartment must use a loop containing calls to <b>PeekMessage</b>, <b>TranslateMessage</b>, and <b>DispatchMessage </b>to retrieve and dispatch window messages. In the example above, Apartment 1 implements this loop.</li>
</ul>
<h1>Only Unicode Interfaces can be Marshaled</h1>
<p>
The DAO 3.5 SDK includes several versions of its DLLs. However, DAO only supports the Unicode interfaces for multi-threading. This is because DAO relies on OLE to do marshaling and OLE is based on Unicode. This also means that because Microsoft Windows 95 does not fully support Unicode, DAO can not be used in multiple threads on Windows 95.</p>
<p>
In the example below, the DAO 3.5 client creates a shared DBEngine in one thread, and then marshals the DBEngine interface to another thread that accesses the DBEngine. The interface is acquired with the <b>GetInterface</b> DAO method (see "Using DAO Interfaces").</p>
<p>
(Error handling excluded for readability):</p>
<pre><code>UINT TestThread(LPVOID);
LPSTREAM pstmDBEngine;

UINT TestThread(LPVOID pParam)
{
CdbDBEngine *pengine;
DAODBEngine *pIdben;
   TRACE("Hello");

   CoInitialize();
   CoGetInterfaceAndReleaseStream( pstmDBEngine, 
            IID_DAODBEngine, (void **) &amp;pIdben);
   pengine = new CdbDBEngine(pIdben, TRUE);
   pengine-&gt;GetVersion();   // Now you can use DAO.
   delete pengine;
   TRACE("Goodbye");
   return 0;
}

void CEnginetestDlg::OnOK() 
{
CdbDBEngine   engine;
DAODBEngine   *pIdben;
CWinThread    *pThread;
MSG          msg;

pIdben = engine.GetInterface();
pThread = AfxBeginThread(TestThread, this, 
               THREAD_PRIORITY_NORMAL, 
               0, CREATE_SUSPENDED);
CoMarshallInterThreadInterfaceInStream(
               IID_IDAODBEngine, pIdben,
               &amp;pstmDBEngine);
pThread-&gt;ResumeThread();

// Now, go into a message loop. This is a requirement // for apartment-model threading.
for (;;)
   {
   if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
      {
      TranslateMessage(&amp;msg);
      DispatchMessage(&amp;msg);
      }
   }
}
</code></pre>
</font></BODY>
</HTML>
