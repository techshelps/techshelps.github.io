<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GetRows and GetRowsEx Methods</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="dahowgetrowsexmethods"></a>GetRows and GetRowsEx Methods</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="dahowGetRowsExMethodsC">
</object></p>
<p>
The dbDAO classes support the <b>GetRows </b>method for fetching multiple rows of data in one call. Like the Microsoft Visual Basic version, <b>GetRows </b>returns the data as variants.</p>
<p>
The <b>GetRowsEx</b> method is a performance improvement by dbDAO and Microsoft Foundation Classes (MFC) DAO to avoid the necessity to retrieve all data as variants and then convert to native types. <b>GetRowsEx</b> does not exist in Visual Basic DAO.</p>
<p class=indent>
<B><b>Important</b></B> The underlying <b>ICDAORecordset::GetRows</b> method might not be supported in future versions of DAO; however, the MFC and dbDAO classes that use this method will continue to be supported.</p>
<h1>Using the dbDAO GetRows Method</h1>
<p>
The <b>GetRows </b>method takes one parameter, the number of rows to fetch, and returns the row data as variants. Unlike in Visual Basic, you cannot simply use subscripts to indicate the array field in a variant. Rather, the data is returned as an OLE <b>SafeArray</b>. The <i>parray</i> member of the variant points to an array desciptor. Individual fields are accessed by calling <b>SafeArrayGetElement</b>. For more information on using the <b>SafeArray</b> datatype, see the OLE documentation.</p>
<p>
The following code from the GetRows sample shows how to use <b>GetRows</b>. Note that the table schema is known a priori, allowing the programmer to hard-code the display functions.</p>
<pre><code>void CGetRowsDlg::DoGetRows() 
{
   COleVariant      cRows;
   COleVariant      varField;
   CString         strLBRow;
   TCHAR            szId[16];
   LONG            lNumRecords;
   HRESULT         hResult;
   LONG            lIndex[2];
   CListBox         *pListBox = (CListBox *)GetDlgItem(IDD_GETROWSLIST);

   // Perform GetRows on Employee table. Retrieve MAX_EMP_REC rows and
   // store results as a variant in cRows.
   cRows = m_cEmpRecordSet.GetRows(MAX_EMP_REC);

   // Find out how many records were actually retrieved.
   // Note that lNumRecords is 1 based
   SafeArrayGetUBound(cRows.parray, 2, &amp;lNumRecords);

   // Clear the listbox for displaying the row values.
   pListBox-&gt;ResetContent();
   
   //Step through the returned rows.
   for (lIndex[1] = 0; lIndex[1] &lt;= lNumRecords; lIndex[1]++)
      {
      // Clear the string containing the row values.
      strLBRow.Empty();

      // Set array index to EmpID field.
      lIndex[0] = EMP_EMPLOYEE_ID;
         
      // Use OLE safe array function to access fields.
      SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);
      
      // EmpID is known to be a long integer value. Store the value in
      // a string. The type check is used because the array may
      // contain empty rows.
      if(varField.vt == VT_I4)
         {
         wsprintf(szId, "%d,&nbsp; ", varField.iVal);
         }
      else      // empty row
         {
         strcpy(szId, _T("Unexpected data type"));
         }

      strLBRow += (LPCTSTR)szId;

      // Set array index to LastName field.
      lIndex[0] = EMP_LAST_NAME;
         
      // Use OLE safe array function to access fields.
      SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);

      // Add LastName to the row string.
      strLBRow += (LPCTSTR)varField.bstrVal;

      // Display string.
      pListBox-&gt;AddString(strLBRow);
      }
}
</code></pre>
<h1>Using the dbDAO GetRowsEx Method</h1>
<p>
The <b>GetRowsEx</b> method retrieves multiple rows and allows you to specify the data types of the fields stored in your application variables. It has the following parameters:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=23%><b>Parameter</b></td>
<td class=label width=36%><b>Data Type</b></td>
<td class=label width=41%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=23%><i>pvBuffer</i></td>
<td width=36%>LPVOID</td>
<td width=41%>Pointer to buffer in which to store returned rows</td>
</tr>
<tr valign=top>
<td width=23%><i>cbRow</i></td>
<td width=36%>LONG</td>
<td width=41%>Length of row in bytes</td>
</tr>
<tr valign=top>
<td width=23%><i>prb</i></td>
<td width=36%>LPDAORSETBINDING</td>
<td width=41%>Pointer to binding structure (see below)</td>
</tr>
<tr valign=top>
<td width=23%><i>cBinding</i></td>
<td width=36%>LONG</td>
<td width=41%>Number of bindings</td>
</tr>
<tr valign=top>
<td width=23%><i>pvVarBuffer</i></td>
<td width=36%>LPVOID</td>
<td width=41%>Pointer to buffer in which to store variable-length data</td>
</tr>
<tr valign=top>
<td width=23%><i>cbVarBuffer</i></td>
<td width=36%>LONG</td>
<td width=41%>Length in bytes of <i>pvVarBuffer</i></td>
</tr>
<tr valign=top>
<td width=23%><i>lRows</i></td>
<td width=36%>LONG</td>
<td width=41%>Number of rows requested</td>
</tr>
</table><br>
<p>
The DAORSETBINDING structure specifies how data is to be copied from the rows to the memory buffer. A separate binding structure must be filled in for each field retrieved. DAORSETBINDING is defined as follows:</p>
<pre><code>typedef struct
   {
   DWORD dwBindIndexType;
   union
      {
      LONG&nbsp; i;
      LPCTSTR pstr;
      };
   DWORD dwType;
   DWORD dwOffset;
   DWORD cb;
   } DAORSETBINDING, *LPDAORSETBINDING;
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Member</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%><i>dwBindIndexType</i></td>
<td width=50%>Specifies whether field is indicated by an index number or by name (use one of the values specified in Settings)</td>
</tr>
<tr valign=top>
<td width=50%><i>dwType</i></td>
<td width=50%>Specifies the data type (use one of the values specified in Settings)</td>
</tr>
<tr valign=top>
<td width=50%><i>dwOffset</i></td>
<td width=50%>Offset in bytes in the row buffer where data is copied</td>
</tr>
<tr valign=top>
<td width=50%><i>cb</i></td>
<td width=50%>Field length in bytes</td>
</tr>
</table><br>
<h1>Settings</h1>
<p>
You can use one of the following values for <b>BindIndexType</b>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Constant</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%>dbBindIndexINT</td>
<td width=50%>index</td>
</tr>
<tr valign=top>
<td width=50%>dbBindIndexSTR</td>
<td width=50%>name</td>
</tr>
</table><br>
<p>
You can use one of the following values for <b>Type</b>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Constant</b></td>
<td class=label width=50%><b>Datatype</b></td>
</tr>
<tr valign=top>
<td width=50%>dbBindI2 </td>
<td width=50%>short</td>
</tr>
<tr valign=top>
<td width=50%>dbBindI4 </td>
<td width=50%>long</td>
</tr>
<tr valign=top>
<td width=50%>dbBindR4 </td>
<td width=50%>float</td>
</tr>
<tr valign=top>
<td width=50%>dbBindR8 </td>
<td width=50%>double</td>
</tr>
<tr valign=top>
<td width=50%>dbBindCY</td>
<td width=50%>currency</td>
</tr>
<tr valign=top>
<td width=50%>dbBindDATE</td>
<td width=50%>DATE</td>
</tr>
<tr valign=top>
<td width=50%>dbBindBOOL </td>
<td width=50%>VARIANT_BOOL</td>
</tr>
<tr valign=top>
<td width=50%>dbBindUI1 </td>
<td width=50%>unsigned char</td>
</tr>
<tr valign=top>
<td width=50%>dbBindVARIANT </td>
<td width=50%>VARIANT</td>
</tr>
<tr valign=top>
<td width=50%>dbBindWCHAR </td>
<td width=50%>wchar_t[]</td>
</tr>
<tr valign=top>
<td width=50%>dbBindSTRING </td>
<td width=50%>(same as dbBindWCHAR for Unicode, dbBindUI1for ANSI)</td>
</tr>
<tr valign=top>
<td width=50%>dbBindLPSTR</td>
<td width=50%>char_pointer </td>
</tr>
<tr valign=top>
<td width=50%>dbBindLPTSTR</td>
<td width=50%>wchar_pointer </td>
</tr>
<tr valign=top>
<td width=50%>dbBindLPSTRING </td>
<td width=50%>(dbBindLPTSTR for Unicode, dbBindLPSTR for ANSI)</td>
</tr>
<tr valign=top>
<td width=50%>dbBindBookmark</td>
<td width=50%>CdbBookmark</td>
</tr>
<tr valign=top>
<td width=50%>dbBindBlob </td>
<td width=50%>unsigned char pointer</td>
</tr>
</table><br>
<p>
The following code from the GetRows sample shows how to use <b>GetRowsEx</b>. Note that the table schema is known a priori, allowing you to predefine a structure for the data.</p>
<p>
Two different binding schemes for retrieving string data are shown. If the size of the strings is fixed, then you can retrieve them directly into the structure. If you are using variable length strings, they will be placed sequentially in a single large buffer and a pointer into that buffer will be stored in the struct.</p>
<pre><code>// User-defined structure for storing data returned by GetRowsEx.
typedef struct
// Structure for GetRowsEx
typedef struct
   {         // employee id as a long
   LONG   lEmpId;            
            // pointer into pVarBuffer to LastName
   TCHAR   *strLastName;
            // the first name (\0 terminated)
   TCHAR   strFirstName[20];   
   } EMP, *LPEMP ;

/* Employee table binding. This structure can be kept    in a header file and modified as needed (for    example, when you update the table definition).    Filling in the structure statically allows you to    define bindings once, rather than each time you    read data.
*/
DAORSETBINDING   Bindings[] = 
{
//Index Type      Column      Type         Offset            Size
{dbBindIndexINT,   EMP_ID,      dbBindI4,      offsetof(EMP,lEmpId),      sizeof(LONG)},
{dbBindIndexINT,   EMP_LNAME,   dbBindLPSTRING,   offsetof(EMP,strLastName),   sizeof(TCHAR *)},
{dbBindIndexINT,   EMP_FNAME,   dbBindSTRING,   offsetof(EMP,strFirstName),   sizeof(TCHAR) * 20}
};

// Perform dbDAO GetRowsEx against the Employee table
void CGetRowsDlg::DoGetRowsEx()
{
   LPEMP         pEmpRows = new EMP[MAX_EMP_REC];
   CListBox      *pListBox = (CListBox *)GetDlgItem(IDD_GETROWSLISTEX);
   CString         strLBRow;
   TCHAR         szId[16];
   LONG         lNumRecords;
   LONG         lCount;
   TCHAR         pBuf[MAX_EMP_REC * 15];   // allow average of 15 chars/name

   // Call GetRowsEx to fetch rows.
   lNumRecords = m_cEmpRecordSet.GetRowsEx(
         pEmpRows,         // Pointer to data buffer.
         sizeof(EMPS),      // Length of row in bytes.
         &amp;Bindings[0],      // Pointer to binding structures.
         sizeof(Bindings) / sizeof(DAORSETBINDING),   // Number of bindings.
          pBuf,            // Storage for variable-length data (lastname).
          sizeof(pBuf),   // Bytes available for variable-length data.
         MAX_EMP_REC);      // Get MAX_EMP_REC rows.
   
   //Step through the returned rows and display results.
   for (lCount = 0; lCount &lt; lNumRecords; lCount++)
      {
      strLBRow.Empty();      // Clear the string containing the row values.
      wsprintf(szId, _T("%d,&nbsp; "), pEmpRows[lCount].lEmpId);
      strLBRow += szId;
      strLBRow += pEmpRows[lCount].strLastName;
      strLBRow += _T(", ");
      strLBRow += (LPCTSTR) pEmpRows[lCount].strFirstName;
      pListBox-&gt;AddString(strLBRow);
      }

   delete [] pEmpRows;         // Free memory.
}
</code></pre>
</font></BODY>
</HTML>
