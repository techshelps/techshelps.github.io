<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the dbDAO Classes</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="dahowusingdbdaoclasses"></a>Using the dbDAO Classes</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="dahowUsingdbDAOClassesC">
</object></p>
<p>
The intent of the dbDAO classes is to make the resulting DAO C++ code as similar to equivalent Microsoft Visual Basic code as possible. Fundamental DAO concepts such as properties, methods, and collections are supported by the dbDAO classes.</p>
<p>
The following procedure, taken from the Employee example in the DAO SDK, illustrates how to call dbDAO from your application. This procedure displays a dialog box (using Microsoft Foundation Classes (MFC)) that prompts for the location of the Northwind database. After the user enters the location of Nwind.mdb, a recordset based on the Employees table is opened. If the Employees table cannot be opened, an error is displayed. (The dbDAO code is nested in a <b>try-catch</b> block.)</p>
<pre><code>BOOL CDAOEMP2Doc::ConnectToDatabase()
{
   CFileDialog   cOpenFile(
            TRUE, 
            _T("MDB"), 
            _T("employee.mdb"), 
            OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT, 
            (_T("Access Files (*.mdb) |*.mdb ||")));

   /* Get the location of database (assume it's the
      Employee example) */
   cOpenFile.DoModal();

   /* The following was declared in class CDAOEMP2Doc:
   CdbDBEngine    m_cDBEngine;
   CdbDatabase      m_cNWDatabase;
   CdbRecordset   m_cEmpRecordSet;
   */
   try
      {
      m_cNWDatabase = m_cDBEngine.OpenDatabase(
            cOpenFile.m_ofn.lpstrFile);
      m_cEmpRecordSet =
         m_cNWDatabase.OpenRecordset(_T("Employees"),
            dbOpenDynaset);
      }

   catch (CdbException e)
      {
      CdbLastOLEError exError;
      TCHAR szBuf[256];

      wsprintf(szBuf, _T("Error 0x%lx : %s\n"),
         e.m_hr, (LPCTSTR) exError.GetDescription());
      AfxMessageBox(szBuf);
      }
   
   return TRUE;
}
</code></pre>
<p>
Although the actual DAO code in this example amounts to a couple lines, this is a typical dbDAO call. The following sections examine what is going on here in greater detail.</p>
<h1>dbDAO Syntax</h1>
<p>
The table below demonstrates how syntactically similar the above dbDAO code (with lengthy argument names and macro decorations removed) is to Visual Basic.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=46%><b>dbDAO</b></td>
<td class=label width=54%><b>Visual Basic</b></td>
</tr>
<tr valign=top>
<td width=46%>CdbDBEnginee;<p>
CdbDatabased;</p>
<p>
CdbRecordsetr;</p>
<p>
d = e.OpenDatabase("nwind.mdb");</p>
<p>
r = d.OpenRecordset("Employees");</p>
</td>
<td width=54%><p>
Dim d as Database</p>
<p>
Dim r as Recordset</p>
<p>
Set d = OpenDatabase("nwind.mdb")</p>
<p>
Set r = d.OpenRecordset("Employees")</p>
</td>
</tr>
</table><br>
<p>
One notable difference is that for dbDAO, declaring a variable of class <b>CdbDBEngine </b>must be the first DAO call. This declaration calls the constructor function that creates an instance of the <b>CdbDBEngine</b> object. For more information, see <a href="davcsdk_6tid.htm">Initializing CdbDBEngine</a>.</p>
<p>
Other than language differences — regarding how to type variables, for example — there are some general differences in the way DAO properties, methods, and collections appear in code, as detailed in the following sections.</p>
<h1>Properties</h1>
<p>
Properties in the dbDAO classes are defined differently from the way they are defined in Visual Basic. The <b>PropName</b> type library property, for example, is exposed as two methods: <b>GetPropName</b> and <b>SetPropName</b>. If the property is read-only, then only the <b>Get</b> method is exposed. Likewise, if the property is write-only, then only the <b>Set</b> method is exposed. The <b>Get</b> method takes no arguments and returns the value of the property, using the appropriate C data type where possible. The <b>Set</b> method takes a single argument — the new value to which you want to set the property — again using the appropriate C data type where possible.</p>
<p>
For example, the <b>Name</b> property of an object is mapped to the <b>GetName</b> and <b>SetName</b> methods. Therefore, its C prototypes are as follows:</p>
<pre><code>CString      GetName (VOID);
VOID         SetName (LPCTSTR pstr);
</code></pre>
<h1>Variants</h1>
<p>
Some properties return data of various types. The most obvious of these are the <b>Value</b> properties of <b>Field</b> objects. These have to return variants because the data type of the return value isn’t known until run time.</p>
<h1>Default Properties</h1>
<p>
Visual Basic has <i>default properties</i>. For example, the code</p>
<pre><code>a = rs!FirstName
</code></pre>
<p>
is equivalent to</p>
<pre><code>a = rs!FirstName.Value
</code></pre>
<p>
Here, <b>Value</b> is the default property of the <b>Field</b> object. Because C++ has no equivalent syntax, you have to ask for the default property by name:</p>
<pre><code>a = rs.Fields["FirstName"].GetValue();
</code></pre>
<p>
For this particular call, note that the performance of this code could be improved by using the dbDAO <b>GetField</b> method.</p>
<h1>Methods</h1>
<p>
Visual Basic methods map directly to methods in the dbDAO classes. Visual Basic methods that take optional arguments may also omit any or all optional arguments in these classes. If you omit an optional argument, a default value is supplied for the argument.</p>
<p>
Methods take C types as arguments rather than the more common VARIANT data type used in the OLE classes and VBA. See the individual method prototypes in DBDAO.H for details.</p>
<h1>Collections</h1>
<p>
The dbDAO classes emulate Visual Basic’s collections by providing member variables that point to collections. As with default values, there is no automatic lookup syntax, which means you have to use an explicit <b>Item</b> method. This method is overloaded to allow you to specify either an ordinal or string index in the collection.</p>
<p>
Automatic construction and destruction of the these references means that statements like</p>
<pre><code>d.m_Tabledefs.Item(i).Name
</code></pre>
<p>
are legal and result in the correct allocation of the referenced <b>Item</b> (a <b>TableDef</b> object in this case), and its deallocation when the reference is complete. Of course, for repeated access, it is better to declare an explicit reference, but for one-time use, this is a convenient way to retrieve collection values.</p>
<p>
A convenient shorthand for specifying an item in a collection is to use the <b>[ ]</b> operator. The same statement would then be:</p>
<pre><code>d.m_Tabledefs[i].Name
</code></pre>
<p class=indent>
<B><b>Note</b></B> If you use reference fields by ordinal, cast the index as LONG to prevent the compiler from interpreting “0” as NULL (as shown in the <b>ConnectToDatabase</b> function in the Employee example).</p>
</font></BODY>
</HTML>
