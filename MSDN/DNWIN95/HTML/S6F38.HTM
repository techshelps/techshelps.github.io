<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Initializing Static VxDs at Startup</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" size="2">
<h3>Initializing Static VxDs at Startup</H3><P>Windows&nbsp;95 supports static VxDs that load during system startup in the same way as Windows 3.x VxDs, and it also supports dynamically loaded VxDs. VMM32.VXD includes the real-mode loader, the executable Virtual Machine Manager, and common static VxDs. Notice, however, that if a VxD file is in the Windows SYSTEM\VMM32 directory, Windows&nbsp;95 loads it in addition to the combined VxDs in MRCI2.VXD.</P>
<P></P>
<P><B>Note</B>   If you want to update a VxD that has been bound into the monolithic VMM32.VXD, place the VxD file in the SYSTEM\VMM32 directory. Windows&nbsp;95 always checks that directory and uses any individual VxDs it finds instead of loading those bound in VMM32.VXD.</P>
<P>The following list shows the VxDs typically combined to create VMM32.VXD. (A custom list is built for each computer.) These drivers used to be specified in the [386enh] section of SYSTEM.INI.</P>
<P></P>
<P><B>Typical VxDs Combined to Create VMM32.VXD</B></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="86pt" VALIGN="TOP"><COL WIDTH="87pt" VALIGN="TOP"><COL WIDTH="87pt" VALIGN="TOP"><COL WIDTH="87pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>*biosxlat<BR>*configmg<BR>*dynapage<BR>*ebios<BR>*ifsmgr<BR>*int13</P></TD><TD VALIGN="TOP"><P>*ios<BR>*parity<BR>*reboot<BR>*vcache<BR>*vcomm<BR>*vcond</P></TD><TD VALIGN="TOP"><P>*vdd<BR>*vdef<BR>*vfat<BR>*vfbackup<BR>*vkd<BR>*vmcpd</P></TD><TD VALIGN="TOP"><P>*vmouse<BR>*vmpoll<BR>*vsd<BR>*vtdapi<BR>*vwin32<BR>*vxdldr</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>VMM32 loads VxDs in three steps:</P>
<UL><LI>VMM32 loads base drivers specified in the Registry, which contains entries for every VxD not directly associated with any hardware. VxDs are located in this branch of the Registry:</LI><LI>Hkey_Local_Machine\System\CurrentControlSet\Services\VxD </LI><LI>If VMM32 finds a value <B>StaticVxD=</B> in any Registry key, it loads that VxD and runs its real-mode initialization. For example, the following entry loads *V86MMGR:</LI><LI>SYSTEM\CurrentControlSet\Services\VxD\V86MemoryManger</LI><LI>   Description=MS-DOS Virtual 8086 Memory Manager</LI><LI>   Manufacturer=Microsoft</LI><LI>   StaticVxD=*V86MMGR</LI><LI>   EMMEXCLUDE=E000-EFFF</LI><LI>VMM32 loads the static VxDs specified in the <B>device=</B>*<I>VxD</I><B> </B>lines in the [386enh] section of SYSTEM.INI. These VxDs are actually loaded from VMM32, and appear in SYSTEM.INI only for backward compatibility.</LI></UL><P>If a specific device conflicts with a device loaded from the Registry, the device specified in SYSTEM.INI takes precedence. However, if the device specified in SYSTEM.INI cannot be found, an error will occur.</P>
<P>Many Windows&nbsp;95 driver models, such as IOS (for disk drivers) and the network, support dynamically loaded device drivers. These VxDs are not loaded by the VMM32 real-mode loader, but are loaded by a device loader that is responsible for loading and initializing the drivers at the correct time and in the correct order. </P>
<P>For example, for SCSI adapter miniport drivers, the device loader is *IOS. The entries for a SCSI adapter are found in this Registry key:</P>
<P><BR></P>
<pre><code>Hkey_Local_Machine\System\CurrentControlSet\Services\Class</code></pre>
<P>Because there is no <B>StaticVxD=</B><I>xxx</I> line in this Registry entry, the VMM32 real-mode loader does nothing when Windows&nbsp;95 identifies this device. </P>
<P>Configuration Manager attempts to find any device node that has a <B>DevLoader=</B> entry in the Registry. The device loader (in the previous example, *IOS) examines the Registry, finds the <B>PortDriver=</B> entry, loads the driver and any associated support drivers, and initializes the adapter. </P></FONT></BODY></HTML>
