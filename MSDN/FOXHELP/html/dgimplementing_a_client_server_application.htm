<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing a Client/Server Application</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="dgimplementing_a_client_server_application"></a><sup></sup>Chapter 21: Implementing a Client/Server Application</h1>
<p>
Whether you’ve created and upsized a working local prototype or developed your application against remote data using remote views, you’ve gained access to the large data stores typically available in a server database. You can also take advantage of the security and transaction processing capabilities of the remote server. While remote views handle the main data management tasks, you can enhance your application by using SQL pass-through (SPT) technology to create objects on the server, run server stored procedures, and execute commands using native server syntax.</p>
<p>
This chapter discusses techniques for implementing client/server technology in a working application that uses remote views. If you want to know more about designing and creating a client/server application, see Chapter 19, <a href="dgdesigning_client_server_applications.htm">Designing Client/Server Applications</a>, and Chapter 20, <a href="dgupsizing_visual_foxpro_databases.htm">Upsizing Visual FoxPro Databases</a>. For more information on creating remote views, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>
<p>
This chapter discusses:</p>
<ul type=disc>
<li>
<a href="#dgusing_sql_pass_through_technology">Using SQL Pass-Through Technology</a></li>
<li>
<a href="#dgworking_with_remote_data_using_sql_pass_through">Working with Remote Data Using SQL Pass-Through</a></li>
<li>
<a href="#dghandling_sql_pass_through_errors">Handling SQL Pass-Through Errors</a></li>
</ul>

<h2><a name="dgusing_sql_pass_through_technology"></a>Using SQL Pass-Through Technology</h2>
<p>
Your client/server application can access server data by using:</p>
<ul type=disc>
<li>
Remote views</li>
<li>
SQL pass-through</li>
</ul>
<p>
Remote views provide the most common and easiest method for accessing and updating remote data. The upsizing wizards can automatically create remote views in your database as part of upsizing, or you can use Visual FoxPro to create remote views after upsizing. For more information on remote views, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>
<p>
SQL pass-through technology enables you to send SQL statements directly to a server. SQL pass-through statements, because they execute on the back-end server, are powerful ways to enhance the performance of your client/server applications. The following table compares remote views with SQL pass-through:</p>
<p class=label>
<b>Comparison of Remote View and SQL Pass-Through Technologies</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Remote View</b></td>
<td class=label width=52%><b>SQL Pass-Through</b></td>
</tr>
<tr valign=top>
<td width=48%>Based on a SQL SELECT statement.</td>
<td width=52%>Based on any native server SQL statement, enabling data definition statements or execution of server stored procedures.</td>
</tr>
<tr valign=top>
<td width=48%>Can be used as data source for controls at design time.</td>
<td width=52%>Can’t be used as a data source for controls.</td>
</tr>
<tr valign=top>
<td width=48%>Provides no ability to execute DDL commands on data source.</td>
<td width=52%>Provides method for using DDL commands on data source.</td>
</tr>
<tr valign=top>
<td width=48%>Fetches one result set.</td>
<td width=52%>Fetches one or multiple result sets.</td>
</tr>
<tr valign=top>
<td width=48%>Provides built-in connection management.</td>
<td width=52%>Requires explicit connection management.</td>
</tr>
<tr valign=top>
<td width=48%>Provides built-in default update information for updates, inserts, and deletes.</td>
<td width=52%>Provides no default update information.</td>
</tr>
<tr valign=top>
<td width=48%>Provides implicit SQL execution and data fetching.</td>
<td width=52%>Provides explicit SQL execution and result fetching control.</td>
</tr>
<tr valign=top>
<td width=48%>Provides no transaction handling.</td>
<td width=52%>Provides explicit transaction handling.</td>
</tr>
<tr valign=top>
<td width=48%>Stores properties persistently in database.</td>
<td width=52%>Provides temporary properties for SQL pass-through cursor, based on session properties.</td>
</tr>
<tr valign=top>
<td width=48%>Employs asynchronous progressive fetching while executing SQL.</td>
<td width=52%>Fully supports programmatic asynchronous fetching.</td>
</tr>
</table><br>
<p>
SQL pass-through technology offers the following advantages over remote views:</p>
<ul type=disc>
<li>
You can use server-specific functionality, such as stored procedures and server-based intrinsic functions.</li>
<li>
You can use extensions to SQL supported by the server, as well as data-definition, server administration, and security commands.</li>
<li>
You have more control over SQL pass-through Update, Delete, and Insert statements.</li>
<li>
You have more control over remote transactions.<p class=atl>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Visual FoxPro can handle SQL pass-through queries that return more than a single result set. For more information, see <a href="#dgprocessing_multiple_result_sets">Processing Multiple Result Sets</a> later in this chapter.</p></li>
</ul>
<p>
SQL pass-through queries also have disadvantages:</p>
<ul type=disc>
<li>
By default, a SQL pass-through query always returns a non-updatable snapshot of remote data, which is stored in an active view cursor. You can make the cursor updatable by setting properties with the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function. An updatable remote view, in contrast, usually doesn’t require that you set properties before you can update remote data, because property settings are stored in the database with the view definition.</li>
<li>
You must enter SQL commands directly into the Command window or into a program, rather than using the graphical View Designer.</li>
<li>
You create and manage the connection to the data source.</li>
</ul>
<p>
Whether you use remote views or SQL pass-through, you can query and update remote data. In many applications, you’ll use both remote views and SQL pass-through.</p>
<h3>Using SQL Pass-Through Functions</h3>
<p>
To use SQL pass-through to connect to a remote ODBC data source, you first call the Visual FoxPro function <a href="lngsqlconnectlp_rp.htm">SQLCONNECT(&nbsp;)</a> to create a connection. You then use the Visual FoxPro SQL pass-through functions to send commands to the remote data source for execution.</p>
<p class=label>
<b>To use Visual FoxPro SQL pass-through functions</b>
<ol>
<li>
Confirm your system’s ability to connect your computer to your data source. Use a utility such as ODBC Test for ODBC.<br><br></li>
<li>
Establish a connection to your data source with the <a href="lngsqlconnectlp_rp.htm">SQLCONNECT(&nbsp;)</a> or the <a href="lngsqlstringconnectlp_rp.htm">SQLSTRINGCONNECT(&nbsp;)</a> function.<p class=tl>
For example, if you’re connecting Visual FoxPro to the SQL Server data source <code>sqlremote</code>, you might log on as system administrator (user id <code>sa</code>) using the password <code>secret</code> with the following command:</P><pre><code>nConnectionHandle = SQLCONNECT('sqlremote','sa','secret')
</code></pre>
<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can also use the SQLCONNECT(&nbsp;) function to connect to a named connection.</p></li>
<li>
Use Visual FoxPro SQL pass-through functions to retrieve data into Visual FoxPro cursors and process the retrieved data with standard Visual FoxPro commands and functions.<p class=tl>
For example, you might query the <code>authors</code> table and browse the resulting cursor using this command:</P><pre><code>? SQLEXEC(nConnectionHandle,"select * from authors","mycursorname")
BROWSE
</code></pre>
</li>
<li>
Disconnect from the data source with the SQLDISCONNECT(&nbsp;) function.</li>
</ol>
<h4>Visual FoxPro SQL Pass-Through Functions</h4>
<p>
The following table lists the Visual FoxPro SQL functions that support working with remote data sources, grouped according to task.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Task</b></td>
<td class=label width=37%><b>Function</b></td>
<td class=label width=38%><b>Purpose</b></td>
</tr>
<tr valign=top>
<td width=25%>Connection management</td>
<td width=37%><a href="lngsqlconnectlp_rp.htm">SQLCONNECT(&nbsp;)</a></td>
<td width=38%>Connects to a data source for SQL pass-through operations.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqlstringconnectlp_rp.htm">SQLSTRINGCONNECT(&nbsp;)</a></td>
<td width=38%>Connects to a data source using ODBC connection string syntax.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqldisconnectlp_rp.htm">SQLDISCONNECT(&nbsp;)</a></td>
<td width=38%>Breaks a connection to an ODBC data source, making the specified connection handle obsolete.</td>
</tr>
<tr valign=top>
<td width=25%>SQL statement execution and control</td>
<td width=37%><a href="lngsqlcancellp_rp.htm">SQLCANCEL(&nbsp;)</a></td>
<td width=38%>Cancels an asynchronously executing SQL query on an active connection.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a></td>
<td width=38%>Executes a SQL pass-through query on an active connection; returns the number of result sets generated, or 0 if SQLEXEC(&nbsp;) is still executing (asynchronous processing).</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a></td>
<td width=38%>Puts another result set into a cursor. Returns 0 if the statement creating the result set is still executing.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqlpreparelp_rp.htm">SQLPREPARE(&nbsp;)</a></td>
<td width=38%>Pre-compiles the SQL statement on the data source and binds the Visual FoxPro parameters, i.e. saves the actual parameter expressions for all the parameters in the SQL statement.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqlcommitlp_rp.htm">SQLCOMMIT(&nbsp;)</a></td>
<td width=38%>Requests a transaction commitment.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqlrollbacklp_rp.htm">SQLROLLBACK(&nbsp;)</a></td>
<td width=38%>Requests a transaction rollback.</td>
</tr>
<tr valign=top>
<td width=25%>Data source information</td>
<td width=37%><a href="lngsqlcolumnslp_rp.htm">SQLCOLUMNS(&nbsp;)</a></td>
<td width=38%>Stores a list of column names and information about each to a cursor. Returns 1 if the function succeeds, or 0 if the function is still executing.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqltableslp_rp.htm">SQLTABLES(&nbsp;)</a></td>
<td width=38%>Stores the names of tables in the source into a cursor. Returns 1 if the function succeeds, or 0 if the function is still executing.</td>
</tr>
<tr valign=top>
<td width=25%>Miscellaneous control</td>
<td width=37%><a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a></td>
<td width=38%>Gets a connection property from an active connection.</td>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=37%><a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a></td>
<td width=38%>Sets a property of an active connection.</td>
</tr>
</table><br>
<p>
The SQLEXEC(&nbsp;), SQLMORERESULTS(&nbsp;), SQLTABLES(&nbsp;), and SQLCOLUMNS(&nbsp;) statements can be canceled in synchronous mode by pressing ESC if SET ESCAPE is set to ON. You can cancel these statements at any time in asynchronous mode by issuing SQLCANCEL(&nbsp;). All other SQL pass-through statements function synchronously and are not interruptible.</p>
<h4>Creating Result Sets</h4>
<p>
When you use the SQL pass-through functions <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> or <a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a> to query data, Visual FoxPro returns the data to you in one or many result sets. Result sets originate from cursors in the server data source and become cursors in Visual FoxPro. The default name for a result set is SQLRESULT.</p>
<h4>Accessing Server Stored Procedures with SQL <br>
Pass-Through Functions</h4>
<p>
You can use Visual FoxPro SQL pass-through technology to create and execute stored procedures on a remote server. Stored procedures can greatly enhance the power, efficiency, and flexibility of SQL, and dramatically improve the performance of SQL statements and batches. Many servers provide stored procedures for defining and manipulating server database objects and for performing server system and user administration.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The examples in this chapter use Microsoft SQL Server syntax unless otherwise noted.</p>
<p class=label>
<b>To call a server stored procedure</b>
<ul type=disc>
<li>
Use the <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> function with the stored procedure name.</li>
</ul>
<p>
For example, the following code displays the results of calling a stored procedure named <code>sp_who</code> on SQL Server using an active connection to the data source <code>sqlremote</code>:</p>
<pre><code>nConnectionHandle = SQLCONNECT('sqlremote')
? SQLEXEC(nConnectionHandle, 'use pubs')
? SQLEXEC(nConnectionHandle, 'sp_who')
BROWSE
</code></pre>
<p>
For more information on creating and executing server stored procedures, see your server documentation.</p>
<h4>Returning Multiple Result Sets</h4>
<p>
If you execute a stored procedure that contains native server syntax SELECT statements, each result set is returned to a separate Visual FoxPro cursor. You can use these cursors to return values or parameters from a server stored procedure to the Visual FoxPro client.</p>
<p class=label>
<b>To return multiple result sets</b>
<ul type=disc>
<li>
Use the <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> function to select multiple results sets using your native server syntax.</li>
</ul>
<p>
For example, the following code creates and executes a SQL server stored procedure, <code>my_procedure</code>, that returns three Visual FoxPro cursors: <code>sqlresult</code>, <code>sqlresult1</code>, and <code>sqlresult2</code>:</p>
<pre><code>=SQLEXEC(nConnectionHandle,'create procedure my_procedure as ;
 &nbsp;&nbsp;&nbsp;&nbsp; select * from sales; select * from authors; 
 &nbsp;&nbsp;&nbsp;&nbsp; select * from titles')
=SQLEXEC(nConnectionHandle,'execute my_procedure')
</code></pre>
<h4>How the Server Processes Result Sets and Errors</h4>
<p>
Because the server compiles each stored procedure when you create it, you receive any server syntax errors at create time. When you execute the stored procedure, the server executes the compiled SQL statements sequentially (as in a Visual FoxPro program) and Visual FoxPro fetches each result set from each SQL statement within the stored procedure separately, in the order executed.</p>
<p>
Result sets and errors are returned in the order received, and processing stops if an error is encountered. For example, if a run-time error occurs when the server executes the third statement in a four-statement stored procedure, you receive the first two result sets and then receive the error that occurred upon processing the third result set. Processing stops after the error is returned; the fourth result set is not retrieved. You can use the <a href="lngaerrorlp_rp.htm">AERROR(&nbsp;)</a> function to obtain information about the most recent error.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can execute server stored procedures from Visual FoxPro only by using Visual FoxPro SQL pass-through functions. Views don't support server stored procedures, because each view contains an explicit SQL SELECT statement in its SQL definition.</p>
<h3>Passing a SQL Statement to the Data Source</h3>
<p>
The <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> function enables you to send a SQL statement to the data source without interpretation. In the simplest case, any string you enclose in the second parameter of the SQLEXEC(&nbsp;) function is passed to your data source without interpretation. This allows you to execute any statement using your data source’s native SQL.</p>
<p>
You can also use the SQLEXEC(&nbsp;) function to create a parameterized query, or to pass ODBC extensions to SQL to the data source.</p>
<h3>Creating a Parameterized Query</h3>
<p>
Just as you can create parameterized views using the <a href="wndquery_designer.htm">View Designer</a> or the language, you can create a parameterized SQL pass-through query.</p>
<p class=label>
<b>To create a parameterized query with SQL pass-through</b>
<ul type=disc>
<li>
Precede a Visual FoxPro parameter with a question mark (<b>?</b>) symbol, and then include the parameter in a SQL string you send with <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a>.<p class=tl>
The parameter you supply is evaluated as a Visual FoxPro expression and the value is sent as part of the view’s SQL statement. If the evaluation fails, Visual FoxPro prompts for the parameter value.</P><p class=atl>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If your parameter is an expression, enclose the parameter expression in parentheses. This ensures the entire expression is evaluated as part of the parameter.</p><p class=tl>
For example, if you have the <code>customer</code> table from the Testdata database on a remote server, the following code creates a parameterized query that limits the view to those customers whose country matches the value supplied for the <code>?cCountry</code> parameter:</P></li>
</ul>
<pre><code>? SQLEXEC(1,'SELECT * FROM customer WHERE customer.country = ?cCountry')
</code></pre>
<p>
If you want to prompt the user for a parameter value, enclose the parameter expression in quotation marks. For more information on prompting for a parameter value, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>
<p>
Your ODBC data source doesn't accept parameters in the following locations:</p>
<ul type=disc>
<li>
In a SELECT fields or tables list.</li>
<li>
As both expressions in a comparison predicate.</li>
<li>
As both operands of a binary operator.</li>
</ul>
<p>
An ODBC data source will not accept parameters in the following locations in the WHERE or HAVING clause of a SELECT statement:</p>
<ul type=disc>
<li>
As both the first and second operands of a BETWEEN predicate.</li>
<li>
As both the first and third operands of a BETWEEN predicate.</li>
<li>
As both the expression and the first value of an IN predicate.</li>
<li>
As the operand of a unary + or - operator.</li>
<li>
As the argument of a SET function.</li>
</ul>
<h3>Using SQL Server Input/Output Parameters</h3>
<p>
You can use input/output parameters to pass values between Visual FoxPro and SQL Server. Input/output parameters are available only using SQL pass-through; they can’t be used in views.</p>
<p>
The following table provides an example using input/output parameters to pass values from Visual FoxPro to a SQL Server stored procedure, returning the result to a Visual FoxPro variable.</p>
<p class=label>
<b>Using Input/Output Parameters with a SQL Server Stored Procedure</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=66%><b>Code</b></td>
<td class=label width=34%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=66%><pre><code>resultCode = SQLExec(connHand,
 &nbsp; "CREATE PROCEDURE sp_test;
 &nbsp;&nbsp;&nbsp;&nbsp; @mult1 int, @mult2 int, @result int;
 &nbsp; OUTPUT AS SELECT
 &nbsp;&nbsp;&nbsp;&nbsp; @result = @mult1 * @mult2")</code></pre>
</td>
<td width=34%>Create a stored procedure, sp_test, that multiplies two variables (<code>mult1</code> and <code>mult2</code>), then stores the resulting amount in the variable <code>result</code>.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>outParam = 0</code></pre>
</td>
<td width=34%>Create a Visual FoxPro variable to receive the output parameter value when it's passed from SQL Server to Visual FoxPro.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>resultCode = SQLExec(connHand, ;
"{CALL sp_test (2, 4, ?@outParam)}")</code></pre>
</td>
<td width=34%>Execute the SQL Server stored procedure, passing the values ‘2’ and ‘4’ to be multiplied together in the stored procedure.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>? "outParam =", outParam&nbsp; &amp;&amp; the value is 8</code></pre>
</td>
<td width=34%>Display the value of the output parameter.</td>
</tr>
</table><br>
<h4>Defining Parameters</h4>
<p>
The syntax for output parameters is:</p>
<p>
?@parameter_name</p>
<p>
When you implement input/output parameters, define the Visual FoxPro variables you want to include in your SQL pass-through command before you use the variables in the SQL statement. To successfully send and receive information with input/output parameters, you must define:</p>
<ul type=disc>
<li>
A stored procedure parameter, with an output type, that returns a value.<p class=tl>
For example, if your stored procedure parameter is <code>@result</code>, you must assign an output type, such as <code>int</code>, to <code>@result</code>, and you must assign a value to <code>@result</code>.</P></li>
<li>
An output parameter (<b>@</b><i>parameter_name</i>) expression that evaluates to an existing Visual FoxPro variable.<p class=tl>
For example, if your output parameter expression is <code>?@outParam</code>, your application must have defined the Visual FoxPro variable <code>outParam</code>.</P><p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you don't use an output parameter, either in Visual FoxPro or in the stored procedure, or you don't define a Visual FoxPro variable to receive the return value, the Visual FoxPro parameter value will not change.</p></li>
</ul>
<h4>Converting Data Types</h4>
<p>
Visual FoxPro converts returned variable values using the following rules:</p>
<ul type=disc>
<li>
Floating point data type (N, F, B) variables are converted to N.<br><br></li>
<li>
The display size is set to 20.<br><br></li>
<li>
The decimal setting is set to the current session setting. The decimal setting affects only the default display format, and doesn't affect the decimal precision.</li>
<li>
Date and time variables (D, T) are converted to time (T) variables.</li>
</ul>
<p>
You can’t use Memo, General, Picture, or NULL data types in input/output parameters.</p>
<p>
If your application uses cursor fields as parameters, Visual FoxPro will attempt to convert the result back to the original field data type.</p>
<h4>Returning Parameter Values</h4>
<p>
Input/output parameters are available only after the last result set of a statement has been fetched. This means that input/output values are returned to Visual FoxPro only after:</p>
<ul type=disc>
<li>
<a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> returns (1) in batch mode<p class=tl>
-or-</P></li>
<li>
<a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a> returns (2) in non-batch mode.</li>
</ul>
<p>
If your SQLEXEC(&nbsp;) statement requests multiple result sets, the output parameters are only guaranteed to be available after the last result set has been fetched from the data source.</p>
<h3>Creating Outer Joins with Remote Data</h3>
<p>
You can use SQL pass-through to perform outer joins on remote data using native server syntax, if your server supports outer joins. An outer join combines information from one or more tables regardless of whether matching rows are found.</p>
<p class=label>
<b>To perform an outer join on a server</b>
<ul type=disc>
<li>
Use the <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> function with the server’s outer join syntax.</li>
</ul>
<p>
For example, the following code uses the Visual FoxPro SQL pass-through function SQLEXEC(&nbsp;) to display the results of an outer join on SQL Server using the active named connection <code>sqlremote</code>:</p>
<pre><code>? SQLEXEC(sqlremote, 'select au_fname, au_lname, pub_name ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from authors, publishers ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where authors.city *= publishers.city')
BROWSE
</code></pre>
<p>
For more information on outer join syntax and types of outer joins, see your server documentation. For information on creating a named connection, see “Defining a Connection” in Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>
<h3>Using ODBC Extensions to SQL</h3>
<p>
You can use <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> to execute ODBC extensions to SQL by enclosing the SQL statement with SQL Access Group standard or extended escape syntax. For more information about ODBC extensions to SQL, refer to the SQL Grammar appendix in your ODBC documentation.</p>
<h4>Creating Outer Joins Using the ODBC Escape Clause</h4>
<p>
You can use SQL pass-through to perform outer joins on remote data using the ODBC escape syntax, if your server supports outer joins. An outer join combines information from one or more tables regardless of whether matching rows are found.</p>
<p>
The syntax for outer joins using the ODBC escape clause is:</p>
<p>
{oj <i>outer-join expression</i>}</p>
<p>
The following example creates a result set of the names and departments of employees working on project 544:</p>
<pre><code>SELECT employee.name, dept.deptname;
 &nbsp; FROM {oj employee LEFT OUTER JOIN dept;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON employee.deptid = dept.deptid};
 &nbsp; WHERE employee.projid = 544
</code></pre>
<p>
For more information on outer join syntax and types of outer joins, see your server documentation. For information on creating a named connection, see “Defining a Connection” in Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>
<h3>Managing Connections with SQL Pass-Through</h3>
<p>
When you create a remote view, you choose an ODBC data source name or a connection name that is then used as a pipeline to the remote server upon activation of the view. To access remote data directly with SQL pass-through, you must have the handle for an active connection. A handle is a value that refers to an object; in this case, the handle refers to a data source connection. To obtain a handle, you request a connection to the data source using the <a href="lngsqlconnectlp_rp.htm">SQLCONNECT(&nbsp;)</a> or <a href="lngsqlstringconnectlp_rp.htm">SQLSTRINGCONNECT(&nbsp;)</a> function. If the connection is successful, your application receives a connection handle for use in subsequent Visual FoxPro calls.</p>
<p>
Your application can request multiple connections for one data source. You can also work with multiple ODBC data sources by requesting a connection to each data source you want to access. If you want to reduce the number of connections used, you can configure remote views to share the same connection. You disconnect from a data source with the SQLDISCONNECT(&nbsp;) function.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Visual FoxPro relies on the definition of the ODBC data source that's stored in your Windows Odbc.ini file or Windows NT registry to connect to a data source. If you change the name or the login information for a data source, keep in mind that these changes might affect whether an application using that data source can connect to the desired remote server.</p>
<h4>Controlling Environment and Connection Properties</h4>
<p>
The client/server environment is established each time you open Visual FoxPro. The environment exists for that session of Visual FoxPro and disappears when you close Visual FoxPro. The client/server environment contains:</p>
<ul type=disc>
<li>
Global properties that act as the prototypes for new connections.</li>
<li>
Error values for errors that occur outside a specific connection.</li>
</ul>
<p>
You can use a handle of 0, the environment handle, to refer to global property settings. You use the <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> function to control default property settings in the connection environment and properties within individual connections. The methods you use for entering SQLSETPROP(&nbsp;) values are consistent for both the environment and individual connections:</p>
<ul type=disc>
<li>
Properties specified with one of two values can use a logical value (.F. or .T.) for <i>eExpression</i>.</li>
<li>
A property name can be abbreviated to its shortest unambiguous truncation. For example, you can use “<code>Asynchronous</code>”, “<code>Asynch</code>”, or “A” to specify the Asynchronous property. Property names aren't case-sensitive.</li>
</ul>
<p>
When you initiate a connection, the connection inherits default connection property values. You can use SQLSETPROP(&nbsp;) to change these values.</p>
<h4>Setting Connection Properties</h4>
<p>
To view the current property settings for a connection, use <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a> with the respective connection handle. The following table lists the connection properties you can access with <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</p>
<p class=label>
<b>Visual FoxPro Connection Properties</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>To</b></td>
<td class=label width=32%><b>Use this property</b></td>
<td class=label width=41%><b>Purpose</b></td>
</tr>
<tr valign=top>
<td width=27%>Display the information used to create the active connection</td>
<td width=32%>ConnectString</td>
<td width=41%>The login connection string.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>DataSource</td>
<td width=41%>The name of the data source as defined by ODBC.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>Password</td>
<td width=41%>The connection password.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>UserID</td>
<td width=41%>The user identification.</td>
</tr>
<tr valign=top>
<td width=27%>Work with shared connections</td>
<td width=32%>ConnectBusy</td>
<td width=41%>True (.T.) if a shared connection is busy; false (.F.) otherwise.</td>
</tr>
<tr valign=top>
<td width=27%>Control interface display</td>
<td width=32%>DispLogin</td>
<td width=41%>Controls when the ODBC Login dialog box is displayed.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>DispWarnings</td>
<td width=41%>Controls whether non-fatal warning messages are displayed or not.</td>
</tr>
<tr valign=top>
<td width=27%>Control time intervals</td>
<td width=32%>ConnectTimeout</td>
<td width=41%>Specifies the time (in seconds) to wait before returning a connection time-out error.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>IdleTimeout</td>
<td width=41%>Specifies the idle time-out interval (in seconds). Qualifying active connections are deactivated after the specified time interval.<sup>1</sup></td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>WaitTime</td>
<td width=41%>Controls the amount of time in milliseconds that elapses before Visual FoxPro checks whether the SQL statement has completed executing.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>QueryTimeout</td>
<td width=41%>Controls the time (in seconds) to wait before returning a general time-out error.</td>
</tr>
<tr valign=top>
<td width=27%>Manage transactions</td>
<td width=32%>Transactions</td>
<td width=41%>Determines how the connection manages transactions on the remote table.</td>
</tr>
<tr valign=top>
<td width=27%>Control fetching of result sets into view cursors</td>
<td width=32%>Asynchronous</td>
<td width=41%>Specifies if result sets are returned synchronously (the default) or asynchronously.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>BatchMode</td>
<td width=41%>Specifies if SQLEXEC(&nbsp;) returns result sets all at once (the default), or individually with SQLMORERESULTS(&nbsp;).</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>PacketSize</td>
<td width=41%>Specifies the size of the network packet used by the connection.</td>
</tr>
<tr valign=top>
<td width=27%>Display internal ODBC handles</td>
<td width=32%>ODBChdbc<sup>2</sup></td>
<td width=41%>The internal ODBC connection handle that can be used by external library files (.fll files) to call the ODBC API functions.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>ODBChstmt<sup>2</sup></td>
<td width=41%>The internal ODBC statement handle that can be used by external library files (.fll files) to call the ODBC API functions.</td>
</tr>
</table><br>
<p class=mini>
1. If in manual transaction mode, the connection is not deactivated.</p>
<p class=mini>
2. If a connection is deactivated, the ODBChdbc and ODBChstmt values are no longer valid. Do not free or drop these values in a user library.</p>
<p>
For more information on connection properties and their default settings, see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</p>
<h4>Controlling Environment Property Settings</h4>
<p>
The values you set in the Visual FoxPro environment using handle 0 are used as prototypes or default values for each subsequent connection or attachment.</p>
<p class=label>
<b>To view the current environment property settings</b></p>
<ul type=disc>
<li>
Use <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a> with 0 as the value for the handle.</li>
</ul>
<p>
The following example displays the current environment’s WaitTime property setting:</p>
<pre><code>? SQLGETPROP(0, "WaitTime")
</code></pre>
<p>
If you set the DispWarnings property to true (.T.), Visual FoxPro displays any environment errors from that point on, and also sets DispWarnings to true (.T.) for newly created connections.</p>
<p>
Although the values you set for handle 0 are used as prototype values for each connection, you can also set custom properties for an individual connection by issuing <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> for that connection handle. The exceptions are the ConnectTimeout, PacketSize, and DispLogin properties, whose settings the connection inherits at connect time. If you change the setting of the ConnectTimeout, PacketSize, or DispLogin property, the new setting isn't used until you reconnect.</p>
<h4>Controlling Connection and View Objects</h4>
<p>
You can control connections and views by setting properties on the connection or view object. Properties that control databases, tables, table fields, view definitions, view fields, named connections, active connections, or active view cursors are called <i>engine properties</i>. You can display or set engine properties with one of the following Visual FoxPro functions:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=53%><b>To display engine properties use</b></td>
<td class=label width=47%><b>To set engine properties use</b></td>
</tr>
<tr valign=top>
<td width=53%><a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a></td>
<td width=47%><a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=53%><a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a></td>
<td width=47%><a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=53%><a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a></td>
<td width=47%><a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a></td>
</tr>
</table><br>
<p>
The function you use depends on whether you want to set properties on object 0 (connection 0 and cursor 0), the object definition in a database (named connection or view definition), or the active object (active connection or active view cursor). The following table lists objects and the functions you use to set properties on each object:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=34%><b>To set properties for</b></td>
<td class=label width=31%><b>Connection</b></td>
<td class=label width=35%><b>View</b></td>
</tr>
<tr valign=top>
<td width=34%>Object 0 </td>
<td width=31%><a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a></td>
<td width=35%><a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=34%>Object definition in a database</td>
<td width=31%><a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a></td>
<td width=35%><a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=34%>Active object</td>
<td width=31%><a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a></td>
<td width=35%><a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a></td>
</tr>
</table><br>
<h4>Engine Properties </h4>
<p>
The following table lists engine properties alphabetically along with the objects that use each property.</p>
<p>
<img src="protable.gif" border=0></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Engine property</b></td>
<td class=label width=70%><b>Applies to</b></td>
</tr>
<tr valign=top>
<td width=30%>Asynchronous</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Batchmode</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>BatchUpdateCount<sup>1</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Buffering</td>
<td width=70%>Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Caption</td>
<td width=70%>Fields in tables, fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Comment</td>
<td width=70%>Databases, tables, fields in tables, view definitions, fields in view definitions, connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>CompareMemo</td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ConnectBusy</td>
<td width=70%>Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ConnectHandle</td>
<td width=70%>Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ConnectName<sup>1</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ConnectString</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ConnectTimeout</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Database</td>
<td width=70%>Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>DataSource</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>DataType</td>
<td width=70%>Fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>DefaultValue</td>
<td width=70%>Fields in tables, fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>DeleteTrigger</td>
<td width=70%>Tables: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>DispLogin</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>DispWarnings</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>FetchAsNeeded</td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>FetchMemo<sup>1</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>FetchSize<sup>1</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>IdleTimeout</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>InsertTrigger</td>
<td width=70%>Tables: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>KeyField</td>
<td width=70%>Fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>KeyFieldList<sup>2</sup></td>
<td width=70%>Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>MaxRecords<sup>1</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ODBCHdbc</td>
<td width=70%>Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ODBCHstmt</td>
<td width=70%>Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Offline</td>
<td width=70%>View definitions: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;).</a></td>
</tr>
<tr valign=top>
<td width=30%>PacketSize</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ParameterList</td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Password</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Path</td>
<td width=70%>Tables: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Prepared</td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>PrimaryKey</td>
<td width=70%>Tables: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>QueryTimeOut</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>RuleExpression</td>
<td width=70%>Tables, fields in tables, view definitions, fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>RuleText</td>
<td width=70%>Tables, fields in tables, view definitions, fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>SendUpdates<sup>2</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>ShareConnection</td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>SourceName</td>
<td width=70%>Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>SourceType</td>
<td width=70%>View definitions: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>SQL</td>
<td width=70%>View definitions: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Tables<sup>2</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;).</a></td>
</tr>
<tr valign=top>
<td width=30%>Transactions</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Updatable</td>
<td width=70%>Fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>UpdatableFieldList<sup>2</sup></td>
<td width=70%>Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>UpdateName</td>
<td width=70%>Fields in view definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>UpdateNameList<sup>2</sup></td>
<td width=70%>Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>UpdateTrigger</td>
<td width=70%>Tables: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>UpdateType</td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>UseMemoSize<sup>1</sup></td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>UserID</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>Version</td>
<td width=70%>Databases: see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>WaitTime</td>
<td width=70%>Connection definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active connections: see <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=30%>WhereType</td>
<td width=70%>View definitions: see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.<br>
Active view cursors: see <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</td>
</tr>
</table><br>
<p class=mini>
1. <sup> </sup>Property primarily useful for remote views; setting has no effect on performance of local views. You can set this property on local views if you want to pre-set the property on the local view and then upsize later to create a remote view.</p>
<p class=mini>
2.&nbsp; Property must be set for updates to be sent to remote data source.</p>
<h4>Using Transactions with Remote Data</h4>
<p>
You can wrap transactions around updates, deletes, and inserts to remote data using one of two methods:</p>
<ul type=disc>
<li>
Automatic transaction mode</li>
<li>
Manual transaction mode</li>
</ul>
<p>
The transaction mode you select determines how Visual FoxPro handles transactions on your local machine.</p>
<h4>Using Automatic Transaction Mode</h4>
<p>
By default, Visual FoxPro automatically wraps every transactable command sent to the remote server in a transaction. This default automatic transaction handling is provided when the Transactions property is set to 1, or DB_TRANSAUTO.</p>
<p class=label>
<b>To use automatic transaction mode</b>
<ul type=disc>
<li>
Use the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function to set the Transactions property on the connection to 1 or DB_TRANSAUTO.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> function to set the Transactions property on the active connection to 1 or DB_TRANSAUTO.</li>
</ul>
<p>
Transaction processing for the remote table is automatically handled.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The Visual FoxPro commands <a href="lngbegin_transaction.htm">BEGIN TRANSACTION</a> and <a href="lngend_transaction.htm">END TRANSACTION</a> create a transaction for the local Visual FoxPro cursor only. They don't extend the transaction to the remote server.</p>
<h4>Controlling Transactions Manually</h4>
<p>
If you want to control transactions manually, you can set the Transactions property to 2, or DB_TRANSMANUAL. With manual transaction handling, Visual FoxPro automatically begins a transaction for you when you issue the first transactable SQL statement, but you must submit the Visual FoxPro SQLCOMMIT(&nbsp;) or SQLROLLBACK(&nbsp;) functions to end the transaction.</p>
<p class=label>
<b>To use manual transaction mode</b>
<ul type=disc>
<li>
Use the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> command to set the Transactions property on the connection to 2 or DB_TRANSMANUAL.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> command to set the Transactions property on the active connection to 2 or DB_TRANSMANUAL.</li>
</ul>
<p>
Transaction processing is handled manually through <a href="lngsqlcommitlp_rp.htm">SQLCOMMIT(&nbsp;)</a> and <a href="lngsqlrollbacklp_rp.htm">SQLROLLBACK(&nbsp;)</a>.</p>
<p>
After committing or rolling back the prior transaction, Visual FoxPro automatically begins a new transaction when you issue the next transactable SQL statement. For more information about transactions, see Chapter 17, <a href="dgprogramming_for_shared_access.htm">Programming for Shared Access</a>.</p>
<h4>Nested Transactions</h4>
<p>
Visual FoxPro supports transactions nested up to five levels for local data. A single level of transaction support is built into SQL pass-through.</p>
<p>
If your server supports multiple levels of transactions, you can use SQL pass-through to manage transaction levels explicitly. Explicit transaction management is complex, however, because it can be difficult to control the interaction between the built-in transaction and the timing of remote server transactions. For more information on explicit transaction management, see your ODBC documentation.</p>

<h2><a name="dgworking_with_remote_data_using_sql_pass_through"></a>Working with Remote Data Using SQL <br>
Pass-Through</h2>
<p>
After you retrieve a result set using SQL pass-through, you can view and control the properties of your result set cursor using the Visual FoxPro functions <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a> and <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>. These are the same functions you use to set properties on an active view cursor.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Cursors aren't objects and aren't tied to the object model. However, you can view their properties, or attributes, with CURSORGETPROP(&nbsp;) and set their properties with CURSORSETPROP(&nbsp;).</p>
<h3>Setting Cursor Properties for Remote Data</h3>
<p>
The following table lists the Visual FoxPro cursor properties that support working with views and connected result sets, grouped according to task categories.</p>
<p class=label>
<b>Visual FoxPro Cursor Properties</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Task</b></td>
<td class=label width=32%><b>Property</b></td>
<td class=label width=41%><b>Purpose</b></td>
</tr>
<tr valign=top>
<td width=27%>View cursor definition</td>
<td width=32%>SQL</td>
<td width=41%>Contains the SQL statement from which the cursor was created.</td>
</tr>
<tr valign=top>
<td width=27%>Control interactions between Visual FoxPro and ODBC</td>
<td width=32%>ConnectHandle</td>
<td width=41%>Handle to remote connection that's used by cursor.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>ConnectName</td>
<td width=41%>Name of connection used by the cursor.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>Prepare</td>
<td width=41%>Specifies whether the query for the view is prepared before it's executed.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>FetchAsNeeded</td>
<td width=41%>Specifies whether rows are fetched automatically during the idle loop or only on an as-needed basis.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>CompareMemo</td>
<td width=41%>Specifies whether Memo and General fields participate in the WHERE clause of an UPDATE statement, regardless of the setting of the UpdateType property</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>FetchMemo</td>
<td width=41%>Specifies whether Memo and General fields are fetched automatically with result sets, or fetched later, on demand, as the Memo or General field is opened.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>UseMemoSize</td>
<td width=41%>Specifies the minimum column size (1 to 255) in result sets for which columns are returned in Memo fields.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>FetchSize</td>
<td width=41%>Specifies the number of rows that are fetched at one time from the remote result set. </td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>MaxRecords</td>
<td width=41%>Specifies the maximum number of rows fetched when result sets are returned.</td>
</tr>
<tr valign=top>
<td width=27%>Update data</td>
<td width=32%>SendUpdates<sup>*</sup></td>
<td width=41%>Specifies whether updates to the cursor are sent to the tables on which the cursor is based.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>BatchUpdateCount</td>
<td width=41%>Specifies the number of update statements sent to the back end for buffered tables.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>Tables<sup>*</sup></td>
<td width=41%>Comma-delimited list of table names on the data source; used to define scope for UpdateNameList and UpdatableFieldsList properties.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>KeyFieldList<sup>*</sup></td>
<td width=41%>Comma-delimited list of Visual FoxPro fields that represent the primary key of the result set used for updates.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>UpdateNameList<sup>*</sup></td>
<td width=41%>Comma-delimited list pairing Visual FoxPro fields in the cursor with the table and column names of fields to which you want to send updates.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>UpdatableFieldList<sup>*</sup></td>
<td width=41%>Comma-delimited list of the Visual FoxPro fields for which updates are sent.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>Buffering</td>
<td width=41%>Specifies the type of buffering being performed on the cursor.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>UpdateType</td>
<td width=41%>Specifies whether updates should occur using UPDATE, or DELETE and then INSERT commands.</td>
</tr>
<tr valign=top>
<td width=27%></td>
<td width=32%>WhereType</td>
<td width=41%>Specifies what should be included in the WHERE clause for updates to table data.</td>
</tr>
</table><br>
<p class=mini>
* Properties that must be set before you can update data.</p>
<p>
You use these properties to control the way your application interacts with remote data, such as establishing the number of rows retrieved during progressive fetching, and controlling buffering and updates to remote data.</p>
<h4>Using the Remote Data Tab in the Options Dialog Box</h4>
<p>
Some cursor properties inherit their initial values from the environment; other properties only become available at the cursor level. Some properties are available to cursors representing remote views and ODBC or SQL pass-through connected tables.</p>
<p>
You can control some cursor and connection property settings through the Remote Data tab of the Options dialog box. When you display the Remote Data tab, the values in the dialog box represent the cursor settings for the current session and the Visual FoxPro global default settings for the connection. When you change values in the Remote Data tab and choose OK, the new values are saved to the cursor’s current session and the connection’s global default settings. If you choose Set As Default, the values are written to the configurable system settings on your machine. The following diagram illustrates these interactions.</p>
<p class=label>
<b>View and set global and session settings with the Options dialog box</b></p>
<p>
<img src="afd21004.gif" border=0></p>
<h4>Setting Properties with SQL Pass-Through</h4>
<p>
When you create a cursor, the cursor inherits property settings, such as UpdateType and UseMemoSize, from the environment cursor, or cursor 0 of the current session. You can change these default property settings by using the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function with 0 as the cursor number.</p>
<p>
After you create a view cursor with SQL pass-through, you can change the active cursor’s property settings by using the CURSORSETPROP(&nbsp;) function for the view cursor. Changes you make with CURSORSETPROP(&nbsp;) are temporary: the temporary settings for the active view disappear when you close the view, and the temporary settings for cursor 0 go away when you close the Visual FoxPro session.</p>
<p>
Connections inherit properties in a similar fashion. Default properties for connection 0 are inherited when you create and store a named connection in a database. You can change these default property settings for connection 0 with the <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> function. After the connection has been created and is stored in a database, you can change connection properties with the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function. When you use a connection, the property settings stored for the connection in the database are inherited by the active connection. You can change these properties on the active connection using the SQLSETPROP(&nbsp;) function for the connection handle.</p>
<p>
Both SQL pass-through view cursors and named connections can use a named ODBC data source. If you use an ODBC data source in a SQL pass-through view cursor, the connection inherits properties from the session defaults.</p>
<p>
The following diagram illustrates property inheritance for cursors and connections created with SQL pass-through. The gray lines represent the flow of property inheritance; the black lines represent Visual FoxPro commands.</p>
<p class=label>
<b>SQL pass-through (SPT) connection and cursor property inheritance</b></p>
<p>
<img src="afd21005.gif" border=0></p>
<h3>Updating Remote Data with SQL Pass-Through</h3>
<p>
When you use SQL pass-through functions to update data on a remote server, you control whether data is updated, as well as specific details about the updates, by setting properties on the result set cursor. Visual FoxPro checks these properties when an update is requested before committing the update.</p>
<p>
To update remote data you must set five properties: Tables, KeyFieldList, UpdateNameList, UpdatableFieldList, and SendUpdates. You can specify additional properties such as Buffering, UpdateType, and WhereType to best fit the requirements of your application.</p>
<p class=label>
<b>To enable updates on an active view cursor</b>
<ul type=disc>
<li>
Use the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function to specify the view cursor’s update properties: Tables, KeyFieldList, UpdateNameList, UpdatableFieldList, and SendUpdates.<p class=atl>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;SQL pass-through view cursors aren't updatable until you specify update properties for the view cursor. If you want to store update property settings persistently, create a view definition. Visual FoxPro supplies default values that prepare the view to be updatable when you create a view using the View Designer or the language. You can use the CURSORSETPROP(&nbsp;) function to add additional information to supplement or customize the default values.</p></li>
</ul>
<p>
The update properties you set on the active view cursor have slightly different names than their <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> counterparts. The following table lists the names used for both view definitions and active cursors.</p>
<p class=label>
<b>View and Cursor Update Properties</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Purpose</b></td>
<td class=label width=39%><b>View definition properties<sup>1</sup></b></td>
<td class=label width=36%><b>Active cursor properties<sup>2</sup></b></td>
</tr>
<tr valign=top>
<td width=25%>Make remote table updatable.</td>
<td width=39%>Tables</td>
<td width=36%>Tables</td>
</tr>
<tr valign=top>
<td width=25%>Specify the remote names for view fields.</td>
<td width=39%>UpdateName (field-level property)</td>
<td width=36%>UpdateNameList</td>
</tr>
<tr valign=top>
<td width=25%>Specify view fields you want to use as keys.</td>
<td width=39%>KeyField (field-level property)</td>
<td width=36%>KeyFieldList</td>
</tr>
<tr valign=top>
<td width=25%>Specify the view fields that are updatable.</td>
<td width=39%>Updatable (field-level property)</td>
<td width=36%>UpdatableFieldList</td>
</tr>
<tr valign=top>
<td width=25%>Turn updates on.</td>
<td width=39%>SendUpdates</td>
<td width=36%>SendUpdates</td>
</tr>
</table><br>
<p class=mini>
1 Set with DBSETPROP(&nbsp;).<br>
2 Set with CURSORSETPROP(&nbsp;).</p>
<p>
For more information on setting update properties, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>, or see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> or <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</p>
<h4>Controlling the Timing of Remote Updates</h4>
<p>
You control how updates to remote data are buffered by setting the cursor’s Buffering property. Of the five possible buffering property settings, two are valid for remote views:</p>
<ul type=disc>
<li>
3, or DB_BUFOPTROW, the default, which optimistically locks the row.</li>
<li>
5, or DB_BUFOPTTABLE, which optimistically locks the table.</li>
</ul>
<p>
Visual FoxPro supports only optimistic locking on remote cursors.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The pessimistic row and table buffering settings, 2 and 4, don’t apply to remote views, because Visual FoxPro doesn’t take locks on the server data. Buffering property setting 1 doesn’t apply to remote views because views are always buffered.</p>
<h4>Using Optimistic Row Buffering</h4>
<p>
The default Buffering setting, DB_BUFOPTROW, optimistically locks remote data on a row-by-row basis. For example, if you want changes to the <code>titles</code> table to be committed on a row-by-row basis, such as when using the SKIP command, you could set the Buffering property to 3:</p>
<pre><code>CURSORSETPROP('buffering', 3, 'titles')
</code></pre>
<p>
When Buffering is set to row buffering, you have two methods of sending updates to the remote server. You can:</p>
<ul type=disc>
<li>
Call the <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> function.</li>
<li>
Use a command that moves the record pointer off the row, such as <a href="lngskip.htm">SKIP</a> or <a href="lnggoslgoto.htm">GO BOTTOM</a>.</li>
</ul>
<p>
The TABLEUPDATE(&nbsp;) function updates the server without moving the record pointer. Commands that move the record pointer send updates to the remote server as a by-product of moving off the updated record.</p>
<p>
If you use row buffering and want to be able to revert changes to rows, you must wrap the changes in manual transactions using SQL pass-through transaction functions.</p>
<h4>Using Optimistic Table Buffering</h4>
<p>
If you want changes to a table to be committed a batch at a time, such as when the user clicks a Save or OK button in a form, you can set the Buffering property to 5, or DB_BUFOPTTABLE. You must call the TABLEUPDATE(&nbsp;) function to send the update to the server.</p>
<p>
In the following example, you set the Buffering property in your form’s initialization code and then commit the changes in the save code.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=77%><b>Code</b></td>
<td class=label width=23%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=77%><pre><code>CURSORSETPROP('buffering', 5, 'sqltitles')</code></pre>
</td>
<td width=23%>Set in Init code</td>
</tr>
<tr valign=top>
<td width=77%><pre><code>* Update batched changes;
* ignore changes made by others</code></pre>
</td>
<td width=23%></td>
</tr>
<tr valign=top>
<td width=77%><pre><code>TABLEUPDATE(.T., .T., 'titles')</code></pre>
</td>
<td width=23%>Set in Save code</td>
</tr>
</table><br>
<p>
To restore the original values to a table and prevent updates from being sent to the remote server, you call <a href="lngtablerevertlp_rp.htm">TABLEREVERT(&nbsp;)</a>. You can control whether a single row or all rows are reverted by combining the setting of the cursor’s Buffering property with the TABLEREVERT(&nbsp;) command. The following example reverts only the current row. You might want to invoke this code when the user clicks on a Cancel button in a form:</p>
<pre><code>= TABLEREVERT(.F., 'titles')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Revert current row
</code></pre>
<p>
If you wanted to revert all rows, such as when the user presses ESC to leave a form, you could use the same example, this time changing the settings of the Buffering property and TABLEREVERT(&nbsp;) command to revert all rows, with the entire table buffered:</p>
<pre><code>= TABLEREVERT(.T., 'titles')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Revert all rows
</code></pre>
<p>
For more information about buffering, see Chapter 17, <a href="dgprogramming_for_shared_access.htm">Programming for Shared Access</a>.</p>
<h4>Detecting Changes By Other Users</h4>
<p>
In multi-user applications, conflicts with other users’ updates are detected by the SQL Update query, which is generated when a write is attempted locally. The level of detection depends on the setting of the WhereType property. For more information on setting the WhereType property, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>
<h4>Forcing Updates</h4>
<p>
You can use the <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> function to control whether changes made to a table or cursor by another user on a network are overwritten when you send your updates. If you set the Force parameter of TABLEUPDATE(&nbsp;) to true (.T.), and the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> UpdateType property is set to the default value, 1, old data is updated with the new data you send, as long as the value in the record’s key field on the remote table hasn't been changed. If the value in the remote table’s key field has changed, or if the UpdateType property is set to 2, Visual FoxPro sends a DELETE and then an INSERT statement to the remote table.</p>
<h4>Troubleshooting Update Error Messages</h4>
<p>
The following table lists the Visual FoxPro and ODBC error messages that apply specifically to remote updates. The Action column contains the action you take to resolve the error condition.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Error Message</b></td>
<td class=label width=39%><b>Meaning</b></td>
<td class=label width=36%><b>Action</b></td>
</tr>
<tr valign=top>
<td width=25%>No update table(s) specified. Use the Tables cursor property.</td>
<td width=39%>The cursor property Tables contains no remote table names. At least one table is required to enable updates to the remote server.</td>
<td width=36%>Use the Tables property to specify at least one table for the cursor.</td>
</tr>
<tr valign=top>
<td width=25%>No key column(s) specified for the update table <i>table_name</i>. Use the KeyFieldList cursor property.</td>
<td width=39%>The primary key for the remote table specified in the error message isn't included in the KeyFieldList property for the cursor; a primary key is required for each table being updated.</td>
<td width=36%>Use the KeyFieldList property to specify the primary key for the remote table.</td>
</tr>
<tr valign=top>
<td width=25%>No valid update table specified for column <i>column_name</i>. Use the UpdateNameList and Tables cursor properties.</td>
<td width=39%>The UpdateName property for column <i>column_name</i> has an invalid table qualifier.</td>
<td width=36%>Set the table qualifier with the UpdateNameList property, or add the table qualifier to the Tables property setting, or both.</td>
</tr>
<tr valign=top>
<td width=25%>The KeyField List cursor property doesn’t define a unique key.</td>
<td width=39%>More than one remote record has the same key.</td>
<td width=36%>Use the KeyField List property to define a unique key for the remote table.</td>
</tr>
<tr valign=top>
<td width=25%>From ODBC: ODBC invalid object.</td>
<td width=39%>ODBC cannot find the remote table or column because it doesn’t exist as named. Visual FoxPro field names are validated by Visual FoxPro; remote table and column names are validated only by the remote server.</td>
<td width=36%>Check the object name.</td>
</tr>
</table><br>
<p>
For more information on error handling, see <a href="#dghandling_sql_pass_through_errors">Handling SQL Pass-Through Errors</a> later in this chapter.</p>
<h3>Choosing an Efficient SQL Pass-Through Processing Mode</h3>
<p>
Visual FoxPro provides two processing modes for retrieving and updating remote data using SQL pass-through: synchronous and asynchronous. When you use SQL pass-through functions you can choose the method you prefer. You don’t need to choose a method for remote views; Visual FoxPro automatically employs progressive fetching and manages the processing mode for you for remote views.</p>
<h4>Benefits of Synchronous Mode</h4>
<p>
By default, Visual FoxPro SQL functions are processed synchronously: Visual FoxPro doesn’t return control to an application until a function call is completed. Synchronous processing is useful when you're working with Visual FoxPro interactively.</p>
<h4>Benefits of Asynchronous Mode</h4>
<p>
Asynchronous processing provides greater flexibility than synchronous processing. For example, when your application is processing a function asynchronously, your application can build a progress indicator to display the progress of the executing statement, display movement of the mouse pointer, create loops, and set timers to allow interruption of processing that is taking too long.</p>
<h4>Using SQL Pass-Through Asynchronously</h4>
<p>
Your application can request asynchronous processing for the four functions that submit requests to a data source and retrieve data: <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a>, <a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a>, <a href="lngsqltableslp_rp.htm">SQLTABLES(&nbsp;)</a>, and <a href="lngsqlcolumnslp_rp.htm">SQLCOLUMNS(&nbsp;)</a>. You enable asynchronous processing by setting the Asynchronous property of the connection with the SQLSETPROP(&nbsp;) function. When asynchronous communication is established for the connection, all four of these functions operate asynchronously.</p>
<p class=label>
<b>To check the setting of the Asynchronous property</b>
<ul type=disc>
<li>
Use the <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a> function to view the Asynchronous property setting. In the following example, <code>nConnectionHandle</code> represents the handle number for your active connection:<pre><code>? SQLGETPROP(nConnectionHandle,'Asynchronous')
</code></pre>
</li>
</ul>
<p class=label>
<b>To enable asynchronous processing</b>
<ul type=disc>
<li>
Use the <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> function to specify the Asynchronous property:<pre><code>? SQLSETPROP(nConnectionHandle,'Asynchronous', .T.)
</code></pre>
</li>
</ul>
<p>
In Asynchronous mode, you must call each function repeatedly until it returns a value other than 0 (still executing). While the function is still executing, you can cancel processing of the function by pressing the ESC key if the SET ESCAPE property is set to true (.T.).</p>
<p>
Until the function has finished processing, the application can use a connection handle only with <a href="lngsqlcancellp_rp.htm">SQLCANCEL(&nbsp;)</a> or with the asynchronous function — <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a>, <a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a>, <a href="lngsqltableslp_rp.htm">SQLTABLES(&nbsp;)</a>, or <a href="lngsqlcolumnslp_rp.htm">SQLCOLUMNS(&nbsp;)</a> — originally associated with the handle. You can’t call any of the other three asynchronous functions or <a href="lngsqldisconnectlp_rp.htm">SQLDISCONNECT(&nbsp;)</a> with the same connection handle until the function has finished.</p>

<h3><a name="dgprocessing_multiple_result_sets"></a>Processing Multiple Result Sets</h3>
<p>
Your application retrieves multiple result sets when you use the <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> function to issue more than one SQL SELECT statement, or to execute a stored procedure that issues multiple SELECT statements. The results of each SQL SELECT statement are returned in a separate Visual FoxPro cursor.</p>
<p>
The default name SQLRESULT is used for the first cursor; subsequent cursors are assigned unique names by indexing the default name. For example, the default names for the cursors returned by a SQLEXEC(&nbsp;) statement requesting three result sets are Sqlresult, Sqlresult1, and Sqlresult2.</p>
<p>
In batch mode, if a function returns multiple result sets, the respective cursor names in Visual FoxPro have unique suffixes and can have up to 255 characters. For example, the following example sets the BatchMode property to batch mode, and then issues a SQLEXEC(&nbsp;) statement containing four SQL SELECT statements that build four result sets:</p>
<pre><code>? SQLSETPROP(nConnectionHandle,'BatchMode', .T.) 
? SQLEXEC(nConnectionHandle,'select * from authors ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select * from titles ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select * from roysched ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select * from titleauthor','ITEM')
</code></pre>
<p>
When the function above has completed processing, Visual FoxPro returns the four result sets as the Visual FoxPro cursors Item, Item1, Item2, and Item3.</p>
<p>
You can change the default name by using the <i>cCursorname</i> parameter with the <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> or <a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a> functions. If the name you specify for a result set has already been used, the new result set overwrites the existing cursor.</p>
<p>
When your application retrieves multiple result sets, you can choose between asynchronous or synchronous processing and batch or non-batch modes.</p>
<h4>Using Batch Mode Processing</h4>
<p>
The BatchMode property, set with <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>, controls how <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> returns multiple result sets. The default value is .T., for batch mode. Batch mode processing means that Visual FoxPro doesn’t return any results from a still-executing SQLEXEC(&nbsp;) call until all of the individual result sets have been retrieved.</p>
<h4>Using Non-Batch Mode Processing</h4>
<p>
If you use <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> to set the BatchMode property to .F., for non-batch mode, each result set is returned individually. The first result set is returned by the <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> function call. Your application must then call <a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a> repeatedly until a value of 2 is returned, indicating that no more results are available.</p>
<p>
In non-batch mode, the cursor name can be changed in each subsequent SQLMORERESULTS(&nbsp;) call. In the previous example, if the first cursor name in a SQLEXEC(&nbsp;) sequence is Item, and the second SQLMORERESULTS(&nbsp;) call changes the <i>cCursorName</i> parameter to Otheritem, the resulting cursors will be named Item, Item1, Otheritem, and Otheritem1.</p>
<p>
The next section describes batch mode and non-batch mode processing with synchronous and asynchronous detail added. The following diagram provides a representation of the four possible processing combinations. The numbers 0, 1, and 2 represent the values returned when you call each function.</p>
<p class=label>
<b>Visual FoxPro synchronous and asynchronous processing modes</b></p>
<p>
<img src="afd21006.gif" border=0></p>
<p>
The behavior of each type of processing is explained below: the labels A, B, C, and D reference the preceding diagram. Each explanation assumes the execution of a statement that will return three result sets, represented in the diagram by three horizontal bands.</p>
<h4>Using Synchronous Processing</h4>
<p>
In synchronous mode, control doesn't return to your application until the execution of a function is complete.</p>
<h4>A: Synchronous Batch Mode</h4>
<p>
When you execute a SQL pass-through statement synchronously in batch mode, control isn’t returned until all result sets have been retrieved. You specify the name of the first cursor by using the <i>cCursorname</i> parameter in the original function. If the cursor you specify already exists, the result set overwrites the existing cursor. When you request multiple result sets in synchronous batch mode, Visual FoxPro creates the names of additional cursors by uniquely indexing the name of the first cursor.</p>
<h4>B: Synchronous Non-Batch Mode</h4>
<p>
When you execute a SQL pass-through statement synchronously in non-batch mode, the first statement retrieves the first result set and returns a 1. You must then call the <a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a> function repeatedly, and optionally specify a new name for the cursor. If you don’t specify a new name for the cursor, multiple names for multiple result sets are created by uniquely indexing the base name. When SQLMORERESULTS(&nbsp;) returns a value of 2, there are no more results available.</p>
<h4>Using Asynchronous Processing</h4>
<p>
In asynchronous mode, your application must continue calling the same SQL pass-through function until it returns a value other than 0 (still executing). The default result set name, <code>Sqlresult</code>, can be explicitly changed with the <i>cCursorname</i> parameter the first time you call the function. If the name you specify for a result set has already been used, the new result set overwrites the information in the existing cursor.</p>
<h4>C: Asynchronous Batch Mode </h4>
<p>
When you execute asynchronously in batch mode, each repeat call of the original function returns a 0 (still executing) until all of the multiple result sets have been returned to the specified cursors. When all results have been retrieved, the return value is either the number of cursors, or a negative number indicating an error.</p>
<h4>D: Asynchronous Non-Batch Mode</h4>
<p>
When processing asynchronously in non-batch mode, <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> returns a value of 1 when it completes the retrieval of each result set. Your application must then call <a href="lngsqlmoreresultslp_rp.htm">SQLMORERESULTS(&nbsp;)</a> repeatedly until a value of 2 is returned, indicating that no more results are available.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Remote result sets are retrieved in two stages: first, the result set is prepared on the server; then the result set is fetched into a local Visual FoxPro cursor. In asynchronous mode, you can call the <a href="lngusedlp_rp.htm">USED(&nbsp;)</a> function to see whether Visual FoxPro has started fetching the cursor you requested.</p>
<h3>Controlling Data Type Conversion</h3>
<p>
When you move data between a remote server and Visual FoxPro, you may encounter differences in the richness of data types available either on your server or in Visual FoxPro, because there is rarely a one-to-one correlation between data types available on a remote data source and those available in Visual FoxPro. To handle these differences, Visual FoxPro uses ODBC data types to map remote data types to local Visual FoxPro data types. By understanding how data types are mapped between ODBC and Visual FoxPro, you can predict how your server’s remote data will be handled in your Visual FoxPro application.</p>
<p>
If you need to, you can also adjust the data types used on your server or in your application. The default Visual FoxPro field data type can be overridden by creating a view for the remote data set and then setting the DataType view field property in the database. The DataType property is a character property indicating the desired data type for each field of a remote view. For more information on the DataType property, see <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a>.</p>

<h4><a name="dgdownloading_and_uploading_remote_view_data"></a>Downloading and Uploading Remote View Data</h4>
<p>
When you retrieve data from a remote ODBC data source, Visual FoxPro converts the data type of each ODBC field into an equivalent Visual FoxPro data type in the result set cursor. The following table lists the data types available on ODBC data sources and their Visual FoxPro equivalents.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>ODBC data type of remote field</b></td>
<td class=label width=53%><b>Field data type in Visual FoxPro cursor</b></td>
</tr>
<tr valign=top>
<td width=47%>SQL_CHAR<br>
SQL_VARCHAR<br>
SQL_LONGVARCHAR</td>
<td width=53%>Character or Memo<sup>1</sup> </td>
</tr>
<tr valign=top>
<td width=47%>SQL_BINARY<br>
SQL_VARBINARY<br>
SQL_LONGVARBINARY</td>
<td width=53%>Memo</td>
</tr>
<tr valign=top>
<td width=47%>SQL_DECIMAL<br>
SQL_NUMERIC</td>
<td width=53%>Numeric or Currency<sup>2</sup> </td>
</tr>
<tr valign=top>
<td width=47%>SQL_BIT</td>
<td width=53%>Logical</td>
</tr>
<tr valign=top>
<td width=47%>SQL_TINYINT<br>
SQL_SMALLINT<br>
SQL_INTEGER</td>
<td width=53%>Integer</td>
</tr>
<tr valign=top>
<td width=47%>SQL_BIGINT</td>
<td width=53%>Character</td>
</tr>
<tr valign=top>
<td width=47%>SQL_REAL<br>
SQL_FLOAT<br>
SQL_DOUBLE</td>
<td width=53%>Double; the number of decimal places is the value of SET DECIMAL in Visual FoxPro</td>
</tr>
<tr valign=top>
<td width=47%>SQL_DATE</td>
<td width=53%>Date</td>
</tr>
<tr valign=top>
<td width=47%>SQL_TIME</td>
<td width=53%>DateTime<sup>3</sup></td>
</tr>
<tr valign=top>
<td width=47%>SQL_TIMESTAMP</td>
<td width=53%>DateTime<sup>4</sup></td>
</tr>
</table><br>
<p class=mini>
1 If the ODBC field width is less than the value of the cursor property UseMemoSize, it becomes a Character field in the Visual FoxPro cursor; otherwise, it becomes a Memo field.<br>
2 If the server field is a money data type, it becomes a Currency data type in Visual FoxPro.<br>
3 The day defaults to 1/1/1900.<br>
4 If the value in the SQL_TIMESTAMP field contains fractions of seconds, the fractions are truncated when the value is converted to a Visual FoxPro DateTime data type.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Null values in ODBC data source fields become null values in the Visual FoxPro cursor, regardless of the SET NULL setting in Visual FoxPro at the time your application retrieves remote data.</p>

<h4><a name="dgconverting_visual_foxpro_parameters_to_remote_view_data_types"></a>Converting Visual FoxPro Parameters to Remote View Data Types</h4>
<p>
If Visual FoxPro data exists in a cursor that originated from remote data, the data goes back to its original ODBC type when sent to the remote server. If you send data that originated in Visual FoxPro to the remote server via SQL pass-through, the following conversions apply.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Visual FoxPro data type</b></td>
<td class=label width=62%><b>ODBC data type</b></td>
</tr>
<tr valign=top>
<td width=38%>Character </td>
<td width=62%>SQL_CHAR or SQL_LONGVARCHAR<sup>1</sup> </td>
</tr>
<tr valign=top>
<td width=38%>Currency</td>
<td width=62%>SQL_DECIMAL</td>
</tr>
<tr valign=top>
<td width=38%>Date</td>
<td width=62%>SQL_DATE or<br>
SQL_TIMESTAMP<sup>2</sup> </td>
</tr>
<tr valign=top>
<td width=38%>DateTime</td>
<td width=62%>SQL_TIMESTAMP</td>
</tr>
<tr valign=top>
<td width=38%>Double</td>
<td width=62%>SQL_DOUBLE</td>
</tr>
<tr valign=top>
<td width=38%>Integer</td>
<td width=62%>SQL_INTEGER</td>
</tr>
<tr valign=top>
<td width=38%>General</td>
<td width=62%>SQL_LONGVARBINARY</td>
</tr>
<tr valign=top>
<td width=38%>Logical</td>
<td width=62%>SQL_BIT</td>
</tr>
<tr valign=top>
<td width=38%>Memo</td>
<td width=62%>SQL_LONGVARCHAR</td>
</tr>
<tr valign=top>
<td width=38%>Numeric</td>
<td width=62%>SQL_DOUBLE</td>
</tr>
</table><br>
<p class=mini>
1 If the Visual FoxPro variable that maps to a parameter creates an expression whose width is less than 255, it becomes a SQL_CHAR type in the ODBC data source; otherwise, it becomes a SQL_LONGVARCHAR type.<br>
2 Visual FoxPro Date data is converted to SQL_DATE for all ODBC data sources except SQL Server, where it becomes SQL_TIMESTAMP.</p>

<h4><a name="dgmapping_a_visual_foxpro_parameter_into_a_remote__data_type"></a>Mapping a Visual FoxPro Parameter Into a Remote Data Type</h4>
<p>
You can map a Visual FoxPro parameter value to a particular remote data type by formatting the parameter as a character expression that uses the syntax for the desired remote data type. For example, if your server provides a DateTime data type, you can create your Visual FoxPro parameter as a character expression in the format used by your server to represent DateTime data. When your server receives the parameter value, it attempts to map the formatted data to the DateTime data type.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When you send a parameter to the remote server, be sure the data type in the WHERE clause matches the data type that's used for the parameter expression.</p>

<h2><a name="dghandling_sql_pass_through_errors"></a>Handling SQL Pass-Through Errors</h2>
<p>
If a SQL pass-through function returns an error, Visual FoxPro stores the error message in an array. The <a href="lngaerrorlp_rp.htm">AERROR(&nbsp;)</a> function provides information about errors that are detected in any of the component levels: Visual FoxPro, the ODBC data source, or the remote server. By examining the values returned by AERROR(&nbsp;), you can determine the server error that occurred and its error message text.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;You must call AERROR(&nbsp;) immediately to obtain error information. If you generate any other error before you call AERROR(&nbsp;), the error information is lost.</p>
</BODY>
</HTML>
