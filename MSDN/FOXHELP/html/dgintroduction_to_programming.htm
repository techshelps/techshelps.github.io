<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Introduction to Programming</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="dgintroduction_to_programming"></a><sup></sup>Chapter 1: Introduction to Programming</h1>
<p>
In Visual FoxPro, procedural and object-oriented programming work together so you can create powerful, flexible applications. Conceptually, you can think of programming as writing a sequence of instructions for accomplishing specific tasks. At a structural level, programming in Visual FoxPro involves manipulating stored data.</p>
<p>
If you are new to programming, this chapter helps you get started. If you are familiar with other programming languages and want to see how Visual FoxPro compares, see <a href="refvisual_foxpro_and_other_programming_languages.htm">Visual FoxPro and Other Programming Languages</a>. For an explanation of object-oriented programming, see Chapter 3, <a href="dgobject_oriented_programming.htm">Object-Oriented Programming</a>.</p>
<p>
This chapter covers:</p>
<ul type=disc>
<li>
<a href="#dgadvantages_of_programming">Advantages of Programming</a></li>
<li>
<a href="#dgthe_mechanics_of_programming_in_visual_foxpro">The Mechanics of Programming in Visual FoxPro</a></li>
<li>
<a href="#dgbasic_programming_concepts">Basic Programming Concepts</a></li>
<li>
<a href="#dgthe_process_of_programming">The Process of Programming</a></li>
<li>
<a href="#dgusing_procedures_and_user_defined_functions">Using Procedures and User-Defined Functions</a></li>
<li>
<a href="#dgmoving_forward">Moving Forward</a></li>
</ul>

<h2><a name="dgadvantages_of_programming"></a>Advantages of Programming</h2>
<p>
Generally, anything that you can do in a program can also be done manually if you have enough time. For example, if you wanted to look at information about a single customer in a table of customers, say the Ernst Handel company, you could do it manually by following a specific sequence of instructions.</p>
<p class=label>
<b>To manually find a single order in a table</b>
<ol>
<li>
From the <b>File</b> menu, choose <b>Open</b>.<br><br></li>
<li>
From the <b>Files of type</b> box, choose <b>Table</b>.<br><br></li>
<li>
Double-click Customer.dbf in the list of files.<br><br></li>
<li>
From the <b>View</b> menu, choose <b>Browse</b>.<br><br></li>
<li>
Scroll through the table, checking the Company field of the records for “Ernst Handel.”</li>
</ol>
<p>
Programmatically, you could achieve the same results by typing the following Visual FoxPro commands in the <a href="wndcommand_window.htm">Command window</a>;</p>
<pre><code>USE Customer
LOCATE FOR Company = "Ernst Handel"
BROWSE
</code></pre>
<p>
After you locate the order for this company, you might want to increase the maximum order amount by 3 percent.</p>
<p class=label>
<b>To manually increase the maximum order amount</b>
<ol>
<li>
Tab to the <code>max_ord_amt</code> field.<br><br></li>
<li>
Multiply the value in <code>max_ord_amt</code> by 1.03 and type the new value in the field.</li>
</ol>
<p>
To achieve the same result programmatically, type the following Visual FoxPro command in the Command window:</p>
<pre><code>REPLACE max_ord_amt WITH max_ord_amt * 1.03
</code></pre>
<p>
It is relatively simple to change the maximum order amount for a single customer, either manually or by typing the instructions in the Command window. Suppose, however, that you wanted to increase the maximum order amount of every customer by 3 percent. To do this manually would be laborious and prone to mistakes. If you give the right instructions in a program file, Visual FoxPro can accomplish this task quickly and easily, without error.</p>
<p class=label>
<b>Sample Program to Increase Maximum Order Amounts For All Customers</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Code</b></td>
<td class=label width=52%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=48%><pre><code>USE customer</code></pre>
</td>
<td width=52%>Open the CUSTOMER table.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>SCAN</code></pre>
</td>
<td width=52%>Go through every record in the table and perform all the instructions between SCAN and ENDSCAN for every record.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>REPLACE max_ord_amt WITH ;
  max_ord_amt * 1.03</code></pre>
</td>
<td width=52%>Increase the maximum order amount by 3%. (The semicolon (;) indicates that the command is continued on the next line.)</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>ENDSCAN</code></pre>
</td>
<td width=52%>End of the code that is executed for every record in the table.</td>
</tr>
</table><br>
<p>
Running a program has some advantages over entering individual commands in the Command window:</p>
<ul type=disc>
<li>
Programs can be modified and run again.</li>
<li>
You can run programs from your menus, forms, and toolbars.</li>
<li>
Programs can run other programs.</li>
</ul>
<p>
The following sections detail the mechanics, concepts, and processes behind this and other Visual FoxPro programs.</p>

<h2><a name="dgthe_mechanics_of_programming_in_visual_foxpro"></a>The Mechanics of Programming <br>
in Visual FoxPro</h2>
<p>
You can program Visual FoxPro by writing code: instructions in the form of commands, functions, or operations that Visual FoxPro can understand. You can include these instructions in:</p>
<ul type=disc>
<li>
The <a href="wndcommand_window.htm">Command window</a>.</li>
<li>
Program files.</li>
<li>
Event or method code windows in the <a href="wndform_designer.htm">Form Designer</a> or <a href="wndclass_designer.htm">Class Designer</a>.</li>
<li>
Procedure code windows in the <a href="wndmenu_designer.htm">Menu Designer</a>.</li>
<li>
Procedure code windows in the <a href="wndreport_designer.htm">Report Designer</a>.</li>
</ul>
<h3>Using the Command Window</h3>
<p>
You can execute a Visual FoxPro command by typing it into the Command window and pressing ENTER. To re-execute the command, move the cursor to the line containing the command and press ENTER again.</p>
<p>
You can even run multiple lines of code from the Command window as though they were a self-contained program.</p>
<p class=label>
<b>To run multiple lines of code in the Command window</b>
<ol>
<li>
Select the lines of code.<br><br></li>
<li>
Press ENTER or choose <b>Execute Selection</b> from the <a href="glsshortcut_menu.htm">shortcut menu</a>.</li>
</ol>
<p>
Since the Command window is an editing window, you can edit commands using the editing tools available in Visual FoxPro. You can edit, insert, delete, cut, copy, or paste text in the Command window.</p>
<p>
The advantage of entering code in the Command window is that the instructions are carried out immediately. There is no need to save a file and run it as a program.</p>
<p>
In addition, choices you make from menus and dialog boxes are echoed in the Command window as commands. You can copy and paste these commands into a Visual FoxPro program, then run the program repeatedly, making it easy to execute thousands of commands again and again.</p>
<h3>Creating Programs</h3>
<p>
A Visual FoxPro program is a text file containing a series of commands. You can create a program in Visual FoxPro in one of these ways:</p>
<p class=label>
<b>To create a program</b>
<ol>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select <b>Programs</b> under the <b>Code</b> tab.<br><br></li>
<li>
Choose <b>New</b>.<p class=tl>
-or-</P></li>
<li value=1>
From the <b>File</b> menu, choose <b>New</b>.<br><br></li>
<li>
In the <b>New</b> dialog box, select <b>Program</b>.<br><br></li>
<li>
Choose <b>New File</b>.<p class=tl>
-or-</P></li>
</ol>
<ul type=disc>
<li>
In the <b>Command</b> window, type:<pre><code>MODIFY COMMAND
</code></pre>
</li>
</ul>
<p>
Visual FoxPro opens a new window named Program1. You can now type your program into this window.</p>
<h4>Saving Programs</h4>
<p>
After you create a program, be sure to save it.</p>
<p class=label>
<b>To save a program</b>
<ul type=disc>
<li>
From the <b>File</b> menu, choose <b>Save</b>.</li>
</ul>
<p>
If you try to close an unsaved program, a dialog box opens, prompting you to either save or discard the changes you made to it.</p>
<p>
If you save a program that was created from the Project Manager, the program is added to the project.</p>
<p>
If you save a program that hasn’t been named yet, the Save As dialog box opens so you can specify a name for the program. After you save your program, you can run or modify it.</p>
<h4>Modifying Programs</h4>
<p>
After you save your program, you can modify it. First, open the program in one of these ways:</p>
<p class=label>
<b>To open a program</b>
<ul type=disc>
<li>
If the program is contained in a project, select it in the <a href="wndproject_manager.htm">Project Manager</a> and choose <b>Modify</b>.<p class=tl>
-or-</P></li>
<li>
From the <b>File</b> menu, choose <b>Open</b>. A dialog box with a list of available files appears. From the <b>Files of type</b> list, choose <b>Program</b>. From the list of files, select the program you want to modify, then choose <b>Open</b>.<p class=tl>
-or-</P></li>
<li>
In the <b>Command</b> window, type the name of the program to modify:<pre><code>MODIFY COMMAND myprogrm
</code></pre>
<p class=tl>
-or-</P></li>
<li>
In the <b>Command</b> window, type:<pre><code>MODIFY COMMAND ?
</code></pre>
<p class=tl>
From the list of files, select the program you want to modify, then choose <b>Open</b>.</P></li>
</ul>
<p>
After you open the program, you can make changes. When you finish making your changes, be sure to save the program.</p>
<h4>Running Programs</h4>
<p>
After you create a program, you can run it.</p>
<p class=label>
<b>To run a program</b>
<ul type=disc>
<li>
If the program is contained in a project, select it in the <a href="wndproject_manager.htm">Project Manager</a> and choose <b>Run</b>.<p class=tl>
-or-</P></li>
<li>
From the <b>Program</b> menu, choose <b>Do</b>. From the list of programs, select the program to run, then choose <b>Do</b>.<p class=tl>
-or-</P></li>
<li>
In the <b>Command</b> window, type <code>DO</code> and the name of the program to run:<pre><code>DO myprogram
</code></pre>
</li>
</ul>
<h3>Writing Code in the Visual FoxPro Design Tools</h3>
<p>
The <a href="wndform_designer.htm">Form Designer</a>, <a href="wndclass_designer.htm">Class Designer</a>, and <a href="wndmenu_designer.htm">Menu Designer</a> allow you to easily integrate program code with the user interface so that the appropriate code executes in response to user actions. The <a href="wndreport_designer.htm">Report Designer</a> allows you to create complex and customizable reports by integrating code into the report file.</p>
<p>
To take advantage of the full power of Visual FoxPro, you need to use these design tools. For more information about the Report Designer, see Chapter 7, <a href="ugdesigning_reports_and_labels.htm">Designing Reports and Labels</a>, in the <i>User’s Guide</i>. For more information about the Class Designer, see Chapter 3, <a href="dgobject_oriented_programming.htm">Object-Oriented Programming</a>, in this book. For more information about the Form Designer, see Chapter 9, <a href="dgcreating_forms.htm">Creating Forms</a>, and for more information about the Menu Designer, see Chapter 11, <a href="dgdesigning_menus_and_toolbars.htm">Designing Menus and Toolbars</a>.</p>

<h2><a name="dgbasic_programming_concepts"></a>Basic Programming Concepts</h2>
<p>
When you program, you store data and manipulate it with a series of instructions. The data and data storage containers are the raw materials of programming. The tools you use to manipulate this raw material are commands, functions, and operators.</p>
<h3>Storing Data</h3>
<p>
The data you work with probably includes amounts of time, money and countable items, as well as dates, names, descriptions, and so on. Each piece of data is a certain type: it belongs to a category of data that you manipulate in similar ways. You could work directly with this data without storing it, but you would lose most of the flexibility and power of Visual FoxPro. Visual FoxPro provides numerous storage containers to extend your ability to easily manipulate data.</p>
<p>
Data types determine how data is stored and how it can be used. You can multiply two numbers together, but you can’t multiply characters. You can print characters in uppercase, but you can’t print numbers in uppercase. Some of the primary data types in Visual FoxPro are listed in the following table:</p>
<p class=label>
<b>Data Types</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Type</b></td>
<td class=label width=75%><b>Examples</b></td>
</tr>
<tr valign=top>
<td width=25%><a href="connumeric_data_type.htm">Numeric</a></td>
<td width=75%>123<br>
3.1415<br>
 – 7</td>
</tr>
<tr valign=top>
<td width=25%><a href="concharacter_data_type.htm">Character</a></td>
<td width=75%>“Test String”<br>
“123”<br>
“01/01/98”</td>
</tr>
<tr valign=top>
<td width=25%><a href="conlogical_data_type.htm">Logical</a></td>
<td width=75%>.T.<br>
.F.</td>
</tr>
<tr valign=top>
<td width=25%><a href="condate_data_type.htm">Date</a><p>
<a href="condatetime_data_type.htm">DateTime</a></p>
</td>
<td width=75%>{^1998-01-01}<p>
{^1998-01-01 12:30:00 p}</p>
</td>
</tr>
</table><br>
<h4>Data Containers</h4>
<p>
Data containers allow you to perform the same operations on multiple pieces of data. For example, you add the hours an employee has worked, multiply them by the hourly wage, and then deduct the taxes to determine the amount of pay the employee has earned. You’ll have to perform these operations for every employee and every pay period. If you store this information in containers, and perform the operations on the containers, you can just replace the old data with new data and run the same program again. This table lists some of the main containers for data in Visual FoxPro:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Type</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><a href="convariables.htm">Variables</a></td>
<td width=75%>Single elements of data stored in your computer’s RAM (Random Access Memory).</td>
</tr>
<tr valign=top>
<td width=25%>Table <a href="conrecords.htm">Records</a></td>
<td width=75%>Multiple rows of predetermined fields, each of which can contain a predefined piece of data. Tables are saved to disk.</td>
</tr>
<tr valign=top>
<td width=25%><a href="conarrays.htm">Arrays</a></td>
<td width=75%>Multiple elements of data stored in RAM.</td>
</tr>
</table><br>
<h3>Manipulating Data</h3>
<p>
Containers and data types give you the building blocks you need to manipulate data. The final pieces are operators, functions, and commands.</p>
<h4>Using Operators</h4>
<p>
Operators tie data together. Here are the most common operators in Visual FoxPro.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b>Operator</b></td>
<td class=label width=27%><b>Valid Data Types</b></td>
<td class=label width=30%><b>Example</b></td>
<td class=label width=26%><b>Result</b></td>
</tr>
<tr valign=top>
<td width=17%>=</td>
<td width=27%>All</td>
<td width=30%><pre><code>? n = 7</code></pre>
</td>
<td width=26%>Prints .T. if the value stored in the variable <code>n</code> is 7, .F. otherwise</td>
</tr>
<tr valign=top>
<td width=17%>+</td>
<td width=27%>Numeric, Character, Date, DateTime</td>
<td width=30%><pre><code>? "Fox" + "Pro"</code></pre>
</td>
<td width=26%>Prints “FoxPro”</td>
</tr>
<tr valign=top>
<td width=17%>! or <code>NOT</code></td>
<td width=27%>Logical</td>
<td width=30%><pre><code>? !.T.</code></pre>
</td>
<td width=26%>Prints .F.</td>
</tr>
<tr valign=top>
<td width=17%>*, /</td>
<td width=27%>Numeric</td>
<td width=30%><pre><code>? 5 * 5
? 25 / 5</code></pre>
</td>
<td width=26%>Prints 25<br>
Prints 5</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A question mark (<a href="lngy_or_yy.htm">?</a>) in front of an expression causes a new line character and the results of the expression to be printed in the active output window, which is usually the main Visual FoxPro window.</p>
<p>
Remember that you must use the same type of data with any one operator. The following statements store two numeric pieces of data to two variables. The variables have been given names that start with <code>n</code> so we can tell at a glance that they contain numeric data, but you could name them with any combination of alphanumeric characters and underscores.</p>
<pre><code>nFirst = 123
nSecond = 45
</code></pre>
<p>
The following statements store two pieces of character data to two variables. The variables have been given names that start with <code>c</code> to indicate that they contain character data.</p>
<pre><code>cFirst = "123"
cSecond = "45"
</code></pre>
<p>
The following two operations, addition and concatenation, yield different results because the type of data in the variables is different.</p>
<pre><code>? nFirst + nSecond
? cFirst + cSecond
</code></pre>
<p>
<b>Output</b></p>
<pre><code>168
12345
</code></pre>
<p>
Because <code>cFirst</code> is character data and <code>nSecond</code> is numeric data, you get a data type mismatch error if you try the following command:</p>
<pre><code>? cFirst + nSecond
</code></pre>
<p>
You can avoid this problem by using conversion functions. For example, <a href="lngstrlp_rp.htm">STR(&nbsp;)</a> returns the character equivalent of a numeric value and <a href="lngvallp_rp.htm">VAL(&nbsp;)</a> returns the numeric equivalent of a character string of numbers. These functions and <a href="lngltrimlp_rp.htm">LTRIM(&nbsp;)</a>, which removes leading spaces, enable you to perform the following operations:</p>
<pre><code>? cFirst + LTRIM(STR(nSecond))
? VAL(cFirst) + nSecond
</code></pre>
<p>
<b>Output</b></p>
<pre><code>12345
168
</code></pre>
<h4>Using Functions</h4>
<p>
Functions return a specific type of data. For example, the functions STR(&nbsp;) and VAL(&nbsp;), used in the previous section, return character and numeric values, respectively. As with all functions, these return types are documented along with the functions.</p>
<p>
There are five ways to call a Visual FoxPro function:</p>
<ul type=disc>
<li>
Assign the return value of the function to a <a href="glsvariable.htm">variable</a>. The following line of code stores the current system date to a variable named <code>dToday</code>:<pre><code>dToday = DATE(&nbsp;)
</code></pre>
</li>
<li>
Include the function call in a Visual FoxPro command. The following command sets the default directory to the value returned from the <a href="lnggetdirlp_rp.htm">GETDIR(&nbsp;)</a> function:<pre><code>CD GETDIR(&nbsp;)
</code></pre>
</li>
<li>
Print the return value in the active output window. The following line of code prints the current system time in the active output window:<pre><code>? TIME(&nbsp;)
</code></pre>
</li>
<li>
Call the function without storing the return value anywhere. The following function call turns the cursor off:<pre><code>SYS(2002)
</code></pre>
</li>
<li>
Embed the function in another function. The following line of code prints the day of the week:<pre><code>? DOW(DATE(&nbsp;))
</code></pre>
</li>
</ul>
<p>
Some other examples of functions used in this chapter are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Function</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><a href="lngisdigitlp_rp.htm">ISDIGIT(&nbsp;)</a></td>
<td width=75%>Returns true (.T.) if the leftmost character in a string is a number; otherwise, returns false (.F.).</td>
</tr>
<tr valign=top>
<td width=25%><a href="lngfieldlp_rp.htm">FIELD(&nbsp;)</a></td>
<td width=75%>Returns the name of a field.</td>
</tr>
<tr valign=top>
<td width=25%><a href="lnglenlp_rp.htm">LEN(&nbsp;)</a></td>
<td width=75%>Returns the number of characters in a character expression.</td>
</tr>
<tr valign=top>
<td width=25%><a href="lngreccountlp_rp.htm">RECCOUNT(&nbsp;)</a></td>
<td width=75%>Returns the number of records in the currently active table.</td>
</tr>
<tr valign=top>
<td width=25%><a href="lngsubstrlp_rp.htm">SUBSTR(&nbsp;)</a></td>
<td width=75%>Returns the specified number of characters from a character string, starting at a specified location in the string.</td>
</tr>
</table><br>
<h4>Using Commands</h4>
<p>
A command causes a certain action to be performed. Each command has a specific syntax which indicates what must be included in order for the command to work. There are also optional clauses associated with commands that allow you to specify in more detail what you want.</p>
<p>
For example, the <a href="lnguse.htm">USE</a> command allows you to open and close tables:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>USE Syntax</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><pre><a href="lnguse.htm"><code>USE</code></a></pre>
</td>
<td width=75%>Closes the table in the current work area.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>USE customer</code></pre>
</td>
<td width=75%>Opens the CUSTOMER table in the current work area, closing any table that was already open in the work area.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>USE customer IN 0</code></pre>
</td>
<td width=75%>Opens the CUSTOMER table in the next available work area.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>USE customer IN 0 ;</code><pre><code>&nbsp;&nbsp;ALIAS mycust</code></pre>
</pre>
</td>
<td width=75%>Opens the CUSTOMER table in the next available work area and assigns the work area an alias of <code>mycust</code>.</td>
</tr>
</table><br>
<p>
Some examples of commands used in this chapter are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Command</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><a href="lngdelete.htm">DELETE</a></td>
<td width=75%>Marks specified records in a table for deletion.</td>
</tr>
<tr valign=top>
<td width=25%><a href="lngreplace.htm">REPLACE</a></td>
<td width=75%>Replaces the value stored in record field with a new value.</td>
</tr>
<tr valign=top>
<td width=25%><a href="lnggoslgoto.htm">Go</a></td>
<td width=75%>Positions the record pointer to a specific location in the table.</td>
</tr>
</table><br>
<h3>Controlling Program Flow</h3>
<p>
Visual FoxPro includes a special category of commands that “wrap around” other commands and functions, determining when and how often the other commands and functions are executed. These commands allow <a href="glsconditional_branching.htm">conditional branching</a> and <a href="glslooping.htm">looping</a>, two very powerful programming tools. The following program illustrates conditional branches and loops. These concepts are described in more detail after the example.</p>
<p>
Suppose that you had 10,000 employees and wanted to give everybody making $30,000 or more a 3 percent raise, and everybody making under $30,000 a 6 percent raise. The following sample program accomplishes this task.</p>
<p>
This program assumes that a table with a numeric field named <code>salary</code> is open in the current work area. For information about work areas, see “Using Multiple Tables” in Chapter 7, <a href="dgworking_with_tables.htm">Working with Tables</a>.</p>
<p class=label>
<b>Sample Program to Increase Employee Salaries</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Code</b></td>
<td class=label width=52%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=48%><pre><code>SCAN</code></pre>
</td>
<td width=52%>The code between SCAN and ENDSCAN is executed as many times as there are records in the table. Each time the code is executed, the record pointer moves to the next record in the table.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>&nbsp;&nbsp;&nbsp;IF salary &gt;= 30000.00
 &nbsp;&nbsp;&nbsp;&nbsp; REPLACE salary WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; salary * 1.03</code></pre>
</td>
<td width=52%>For each record, if the salary is greater than or equal to 30,000, replace this value with a new salary that is 3% higher.<p>
The semicolon (;) after WITH indicates that the command is continued on the next line.</p>
</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>&nbsp;&nbsp;&nbsp;ELSE
 &nbsp;&nbsp;&nbsp;&nbsp; REPLACE salary WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; salary * 1.06</code></pre>
</td>
<td width=52%>For each record, if the salary is not greater than or equal to 30,000, replace this value with a new salary that is 6% higher.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>&nbsp;&nbsp;&nbsp;ENDIF</code><pre><code>ENDSCAN</code></pre>
</pre>
</td>
<td width=52%>End of the conditional IF statement.<p>
End of the code that is executed for each record in the table.</p>
</td>
</tr>
</table><br>
<p>
This example uses both conditional branching and looping commands to control the flow of the program.</p>
<h4>Conditional Branching</h4>
<p>
Conditional branching allows you to test conditions and then, depending on the results of that test, perform different operations. There are two commands in Visual FoxPro that allow conditional branching:</p>
<ul type=disc>
<li>
<a href="lngif_..._endif.htm">IF ... ELSE ... ENDIF</a></li>
<li>
<a href="lngdo_case_..._endcase.htm">DO CASE ... ENDCASE</a></li>
</ul>
<p>
The code between the initial statement and the ENDIF or ENDCASE statement is executed only if a logical condition evaluates to true (.T.). In the example program, the IF command is used to distinguish between two states: either the salary is $30,000 or more, or it isn’t. Different actions are taken depending on the state.</p>
<p>
In the following example, if the value stored in the <a href="glsvariable.htm">variable</a> <code>nWaterTemp</code> is less than 100, no action is taken:</p>
<pre><code>* set a logical variable to true if a condition is met.
IF nWaterTemp &gt;= 100
 &nbsp; lBoiling = .T.
ENDIF
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;An asterisk at the beginning of a line in a program indicates that the line is a comment. Comments help the programmer remember what each segment of code is designed to do, but are ignored by Visual FoxPro.</p>
<p>
If there are several possible conditions to check for, a DO CASE ... ENDCASE block can be more efficient and easier to keep track of than multiple IF statements.</p>
<h4>Looping</h4>
<p>
Looping allows you to execute one or more lines of code as many times as you need to. There are three commands in Visual FoxPro that allow looping:</p>
<ul type=disc>
<li>
<a href="lngscan_..._endscan.htm">SCAN ... ENDSCAN</a></li>
<li>
<a href="lngfor_..._endfor.htm">FOR ... ENDFOR</a></li>
<li>
<a href="lngdo_while_..._enddo.htm">DO WHILE ... ENDDO</a></li>
</ul>
<p>
Use SCAN when you are performing a series of actions for each record in a table, as in the example program just described. The SCAN loop enables you to write the code once and have it executed for each record as the record pointer moves through the table.</p>
<p>
Use FOR when you know how many times the section of code needs to be executed. For example, you know there are a specific number of fields in a table. Because the Visual FoxPro function FCOUNT(&nbsp;) returns this number, you can use a FOR loop to print the names of all the fields in the table:</p>
<pre><code>FOR nCnt = 1 TO FCOUNT(&nbsp;)
 &nbsp; ? FIELD(nCnt)
ENDFOR
</code></pre>
<p>
Use DO WHILE when you want to execute a section of code as long as a certain condition is met. You might not know how many times the code will have to execute, but you know when it should stop executing. For example, let’s assume you have a table with people’s names and initials, and you want to use the initials to look people up. You would have a problem the first time you tried to add a person who had the same initials as someone else already in your table.</p>
<p>
To solve the problem, you could add a number to the initials. For example, Michael Suyama’s identification code could be MS. The next person with the same initials, Margaret Sun, would be MS1. If you then added Michelle Smith to the table, her identification code would be MS2. A DO WHILE loop enables you to find the right number to append to the initials.</p>
<p class=label>
<b>Sample Program with DO WHILE to Generate a Unique ID</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Code</b></td>
<td class=label width=52%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=48%><pre><code>nHere = RECNO()</code></pre>
</td>
<td width=52%>Save the location of the record.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>cInitials = LEFT(firstname,1) + ;
 &nbsp; LEFT(lastname,1)</code><pre><code>nSuffix = 0</code></pre>
</pre>
</td>
<td width=52%>Get the person’s initials from the first letters of the <code>firstname</code> and <code>lastname</code> fields.<p>
Establish a variable to hold the number to be added to the end of a person’s initials if necessary.</p>
</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>LOCATE FOR person_id = cInitials</code></pre>
</td>
<td width=52%>See if there is another person in the table with the same initials.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>DO WHILE FOUND(&nbsp;)</code></pre>
</td>
<td width=52%>If another record in the table has a person_id value that is the same as <code>cInitials</code>, the <a href="lngfoundlp_rp.htm">FOUND(&nbsp;)</a> function returns true (.T.) and the code in the DO WHILE loop executes.<br>
If no match is found, the next line of code to be executed is the line following ENDDO.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>&nbsp;&nbsp;&nbsp;nSuffix = nSuffix + 1
 &nbsp; cInitials = ;
 &nbsp;&nbsp;&nbsp;&nbsp; LEFT(cInitials,2);
 &nbsp;&nbsp;&nbsp;&nbsp; + ALLTRIM(STR(nSuffix))</code></pre>
</td>
<td width=52%>Prepare a fresh suffix and append it to the end of the initials.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>&nbsp;&nbsp;&nbsp;CONTINUE</code></pre>
</td>
<td width=52%><a href="lngcontinue.htm">CONTINUE</a> causes the last <a href="lnglocate.htm">LOCATE</a> command to be evaluated again. The program checks to see if the new value in <code>cInitials</code> already exists in the person_id field of another record. If so, FOUND(&nbsp;) will still return .T. and the code in the DO WHILE loop will execute again. If the new value in <code>cInitials</code> is indeed unique, FOUND(&nbsp;) will return .F. and program execution continues with the line of code following ENDDO.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>ENDDO</code></pre>
</td>
<td width=52%>End of the DO WHILE loop.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>GOTO nHere
REPLACE person_id WITH cInitials</code></pre>
</td>
<td width=52%>Return to the record and store the unique identification code in the <code>person_id</code> field.</td>
</tr>
</table><br>
<p>
Because you can’t know beforehand how many times you’ll find matching identification codes already in use, you use the DO WHILE loop.</p>

<h2><a name="dgthe_process_of_programming"></a>The Process of Programming</h2>
<p>
When you understand the basic concepts, programming is an iterative process. You go through the steps many times, refining your code as you go. When you are starting out, you test frequently, using a lot of trial and error. The more familiar you become with the language, the more quickly you can program and the more preliminary testing you can do in your head.</p>
<p>
The basic programming steps include:</p>
<ul type=disc>
<li>
Stating the problem.</li>
<li>
Breaking the problem down into discrete elements.</li>
<li>
Constructing the pieces.</li>
<li>
Testing and fixing the pieces.</li>
<li>
Assembling the pieces.</li>
<li>
Testing the whole program.</li>
</ul>
<p>
Here are some things to remember when you are getting started:</p>
<ul type=disc>
<li>
Clearly delineate the problem before trying to solve it. If you don’t, you’ll end up having to make a lot of changes, throw away code, start over, or be satisfied with something that is less than what you really want.</li>
<li>
Break the problem down into manageable steps instead of trying to solve the whole problem at once.</li>
<li>
Test and debug sections of code as you develop. Test to see if the code does what you want it to do. Debugging is the process of finding and fixing the problems that prevent the code from doing what you want it to do.</li>
<li>
Refine your data and data storage to make it easier to manipulate the data through program code. This often means structuring your tables properly.</li>
</ul>
<p>
The rest of this section traces the steps in constructing a small Visual FoxPro program.</p>
<h3>Stating the Problem</h3>
<p>
Before you can solve a problem, you need to formulate it clearly. Sometimes if you adjust the way you formulate the problem, you’ll be able to see more or better options for solving it.</p>
<p>
Suppose you get a lot of data from various sources. Though most of the data is strictly numeric, some data values contain dashes and spaces in addition to numbers. You should remove all the spaces and dashes from those fields and save the numeric data.</p>
<p>
Instead of trying to remove spaces and dashes from the original data, you could formulate the goal of the program as:</p>
<p>
<B><b>Goal</b></B>&nbsp;&nbsp;&nbsp;Replace the existing values in a field with other values that contain everything from the original values except the spaces and dashes.</p>
<p>
This formulation avoids the difficulty of manipulating a string of characters whose length keeps changing as you work with it.</p>
<h3>Breaking the Problem Down</h3>
<p>
Because you have to provide specific instructions to Visual FoxPro in terms of operations, commands, and functions, you need to break the problem down into discrete steps. The most discrete task for the example problem is to look at each character in the string. Until you can look at a character individually, you can’t determine whether you want to save it.</p>
<p>
After you look at a character, you need to check to see if it is a dash or a space. At this point, you might want to refine the statement of the problem. What if you get data later that contains open and closed parentheses? What if you want to get rid of currency symbols, commas, and periods? The more generic you can make the code, the more work you can save yourself later; the whole point is to save work. Here is a formulation of the problem that works with a much greater variety of data:</p>
<p>
<B><b>Refined Goal</b></B>&nbsp;&nbsp;&nbsp;Replace the existing values in a field with other values that contain only the numeric characters from the original values.</p>
<p>
With this formulation, you can now restate the problem at the character level: if the character is numeric, save the character; if the character is not numeric, move on to the next character. When you have constructed a string that contains only the numeric elements of the initial string, you can replace the first string and move on to the next record until you have gone through all the data.</p>
<p>
To summarize, the problem breaks down into these pieces:
<ol>
<li>
Look at each character.<br><br></li>
<li>
Decide if the character is numeric or not.<br><br></li>
<li>
If it is numeric, copy it to the second string.<br><br></li>
<li>
When you have gone through every character in the original string, replace the original string with the numeric-only string.<br><br></li>
<li>
Repeat these steps for all the records in the table.</li>
</ol>
<h3>Constructing the Pieces</h3>
<p>
When you know what you need to do, you can start to formulate the pieces in terms of Visual FoxPro commands, functions, and operators.</p>
<p>
Since the commands and functions will be used to manipulate data, you need some test data to work with. You want the test data to resemble the actual data as closely as possible.</p>
<p>
For this example, you can store a test string to a variable by entering the following command in the Command window:</p>
<pre><code>cTest = "123-456-7 89 0"
</code></pre>
<h4>Look at Each Character</h4>
<p>
First, you want to look at a single character in the string. For a list of functions that can be used to manipulate strings, see <a href="catcharacter_functions.htm">Character Functions</a>.</p>
<p>
You will find three functions that return specific sections of a string: <a href="lngleftlp_rp.htm">LEFT(&nbsp;)</a>, <a href="lngrightlp_rp.htm">RIGHT(&nbsp;)</a>, and <a href="lngsubstrlp_rp.htm">SUBSTR(&nbsp;)</a>. Of the three, SUBSTR(&nbsp;) returns characters from any part of the string.</p>
<p>
SUBSTR(&nbsp;) takes three arguments or parameters: the string, the initial location in the string, and the number of characters to return from the string, starting from the initial location. To test if SUBSTR(&nbsp;) is going to do what you want, type the following commands in the Command window:</p>
<pre><code>? SUBSTR(cTest, 1, 1)
? SUBSTR(cTest, 3, 1)
? SUBSTR(cTest, 8, 1)
</code></pre>
<p>
<b>Output</b></p>
<pre><code>1
3
-
</code></pre>
<p>
You can see that the first, third, and eighth characters of the test string have been displayed in the main Visual FoxPro window.</p>
<p>
To do the same thing a number of times, use a loop. Since the test string has a specific number of characters (14), you can use a FOR loop. The counter in the FOR loop is incremented each time the code in the loop is executed, so you can use the counter in the SUBSTR(&nbsp;) function. You could test the looping constructs in the Command window, but at some point you’ll want to save your work to build on it later. Now would be a good time to create a new program.</p>
<p class=label>
<b>To create a new program</b>
<ol>
<li>
Type the following command in the <b>Command</b> window:<pre><code>MODIFY COMMAND numonly
</code></pre>
</li>
<li>
In the window that opens, type the following lines of code:<pre><code>FOR nCnt = 1 TO 14
? SUBSTR(cTest, nCnt, 1)
ENDFOR
</code></pre>
</li>
</ol>
<p>
Now that you’ve created a program, you can run it.</p>
<p class=label>
<b>To run a program</b>
<ol>
<li>
In the open program window, press CTRL+E.<br><br></li>
<li>
If a <b>Save</b> dialog box appears, choose <b>OK</b>.</li>
</ol>
<p>
When you run this program, the individual characters in the test string are printed on separate lines in the main Visual FoxPro window.</p>
<p class=label>
<b>Testing Part of the Program</b></p>
<p>
<img src="afd01001.gif" border=0></p>
<p>
The first task has been accomplished. You can now look at each character in the string.</p>
<h4>Decide if the Character is Numeric</h4>
<p>
After you have fetched a single character from the string, you need to know if it is a number. You can find this out using <a href="lngisdigitlp_rp.htm">ISDIGIT(&nbsp;)</a>.</p>
<p>
Type the following commands in the Command window:</p>
<pre><code>? ISDIGIT('2')
? ISDIGIT('-')
? ISDIGIT(SUBSTR(cTest, 3, 1))
</code></pre>
<p>
<b>Output</b></p>
<pre><code>.T.
.F.
.T.
</code></pre>
<p>
From this output, you can see that ‘2’ is a number, ‘– ’ is not a number, and the third character in <code>cTest</code>, 3, is a number.</p>
<h4>If the Character is Numeric, Copy it to the Second String</h4>
<p>
Now that you can look at the characters and determine whether they are numeric, you need a <a href="glsvariable.htm">variable</a> to hold the numeric values: <code>cNumOnly</code>.</p>
<p>
To create the variable, assign it an initial value, a zero-length string:</p>
<pre><code>cNumOnly = ""
</code></pre>
<p>
As the FOR loop moves through the string, it’s a good idea to create another variable to temporarily hold each character from the string as it is being manipulated:</p>
<pre><code>cCharacter = SUBSTR(cTest, nCnt, 1)
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;It’s often better to store the result of a calculation, evaluation, or function to a variable. You can then manipulate the variable without having to repeat the calculation or evaluation.</p>
<p>
The following line of code can be used each time a number is encountered to add the number to the second string:</p>
<pre><code>cNumOnly = cNumOnly + cCharacter
</code></pre>
<p>
The program so far is:</p>
<pre><code>cNumOnly = ""
FOR nCnt = 1 TO 14
 &nbsp; cCharacter = SUBSTR(cTest, nCnt, 1)
 &nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp;&nbsp; cNumOnly = cNumOnly + cCharacter
 &nbsp; ENDIF
ENDFOR
</code></pre>
<h3>Testing the Pieces</h3>
<p>
If you add a couple of commands to the end to display the strings, and then run the program, you can see that the program works with the test string:</p>
<pre><code>cNumOnly = ""
FOR nCnt = 1 TO 14
 &nbsp; cCharacter = SUBSTR(cTest, nCnt, 1)
 &nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp;&nbsp; cNumOnly = cNumOnly + cCharacter
 &nbsp; ENDIF
ENDFOR
? cTest
? cNumOnly
</code></pre>
<p>
<b>Output</b></p>
<pre><code>123-456-7 89 0
1234567890
</code></pre>
<p>
The output looks correct. But if you change the test string as you are testing the pieces, you can run into problems. Type the following command in the Command window and run the program again:</p>
<pre><code>cTest = "456-789 22"
</code></pre>
<p>
The program generates an error message. The FOR loop tried to execute 14 times, but there were only 10 characters in the string. You need a way to adjust for varying string lengths. Use <a href="lnglenlp_rp.htm">LEN(&nbsp;)</a> to return the number of characters in a string. If you substitute this command in the FOR loop, you’ll find that the program works correctly with both test strings:</p>
<pre><code>cNumOnly = ""
FOR nCnt = 1 TO LEN(cTest)
 &nbsp; cCharacter = SUBSTR(cTest, nCnt, 1)
 &nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp;&nbsp; cNumOnly = cNumOnly + cCharacter
 &nbsp; ENDIF
ENDFOR
? cTest
? cNumOnly
</code></pre>
<h3>Putting the Pieces Together</h3>
<p>
To complete the programming solution for this problem, you might want to switch to reading your data from a table. When you have selected a table to use, scan the records in it and apply your program code to a field in the table rather than to a variable.</p>
<p>
First, you could create a temporary table containing a variety of sample strings. Such a table could contain a single character field called <code>TestField</code> and four or five records:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>TestField Contents</b></td>
<td class=label width=51%></td>
</tr>
<tr valign=top>
<td width=49%>123-456-7 89 0</td>
<td width=51%>-9221 9220 94321 99-</td>
</tr>
<tr valign=top>
<td width=49%>456-789 22</td>
<td width=51%>000001 98-99-234</td>
</tr>
</table><br>
<p>
When you substitute the name of the field for the name of the test string, the program looks like this:</p>
<pre><code>FOR nCnt = 1 TO LEN(TestField)
 &nbsp; cCharacter = SUBSTR(TestField, nCnt, 1)
 &nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp;&nbsp; cNumOnly = cNumOnly + cCharacter
 &nbsp; ENDIF
ENDFOR
? TestField
? cNumOnly
</code></pre>
<p>
You can manually adjust the record pointer by <a href="glsbrowse.htm">browsing</a> the table and scrolling through it. When the record pointer is on each of the records, the program works the way you want it to. Or, you can now wrap table navigation code around the rest of your program:</p>
<pre><code>SCAN
 &nbsp; cNumOnly = ""
 &nbsp; FOR nCnt = 1 TO LEN(TestField)
 &nbsp;&nbsp;&nbsp;&nbsp; cCharacter = SUBSTR(TestField, nCnt, 1)
 &nbsp;&nbsp;&nbsp;&nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNumOnly = cNumOnly + cCharacter
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDFOR
? TestField
? cNumOnly
?
ENDSCAN
</code></pre>
<p>
<b>Output</b></p>
<pre><code>123-456-7 89 0
1234567890

456-789 22
45678922

 -9221 9220 94321 99-
922192209432199

000001 98-99-234
0000019899234
</code></pre>
<h3>Testing the Whole Program</h3>
<p>
Instead of printing the string at the end of the program, you want to save it in your table. Use the following line of code to do this:</p>
<pre><code>REPLACE TestField WITH cNumOnly
</code></pre>
<p>
The complete program becomes:</p>
<pre><code>SCAN
 &nbsp; cNumOnly = ""
 &nbsp; FOR nCnt = 1 TO LEN(TestField)
 &nbsp;&nbsp;&nbsp;&nbsp; cCharacter = SUBSTR(TestField, nCnt, 1)
 &nbsp;&nbsp;&nbsp;&nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNumOnly = cNumOnly + cCharacter
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDFOR
 &nbsp; REPLACE TestField WITH cNumOnly
ENDSCAN
</code></pre>
<p>
When you have finished the complete program, you need to test it on the sample data before trying it on your real data.</p>
<h3>Making the Program More Robust</h3>
<p>
A robust program does what you want it to, but it also anticipates and deals with possible things that could go wrong. The example program does what you want it to do, but it makes some assumptions that must be true if the program is to work:</p>
<ul type=disc>
<li>
A table is open in the current work area.</li>
<li>
The table has a character field named <code>TestField</code>.</li>
</ul>
<p>
If the table isn’t open in the current work area or if the table doesn’t have a character field with the expected name, the program will generate an error message and fail to accomplish the task.</p>
<p class=label>
<b>Program to Remove the Non-Numeric Characters from a Field for All Records</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Code</b></td>
<td class=label width=50%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=50%><pre><code>lFieldOK = .F.</code></pre>
</td>
<td width=50%>This <a href="glsvariable.htm">variable</a> determines if the necessary conditions exist for the program to work. Initially, set the variable to false (.F.) to assume that the necessary conditions do not exist.</td>
</tr>
<tr valign=top>
<td width=50%><pre><code>FOR nCnt = 1 TO FCOUNT(&nbsp;)
 &nbsp; IF FIELD(nCnt) = ;
 &nbsp;&nbsp;&nbsp; UPPER("TestField")
 &nbsp;&nbsp;&nbsp;&nbsp; IF TYPE("TestField") = "C"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lFieldOK = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; EXIT
 &nbsp; ENDIF
ENDFOR</code></pre>
</td>
<td width=50%>This section of code goes through every field in the current table until it finds a character field named <code>TestField</code>. As soon as the correct field is found, <code>lFieldOK</code> is set to true (.T.) and <a href="lngexit.htm">EXIT</a> ends the loop (there is no reason to keep checking after the correct field is identified). If no field matches the criteria, <code>lFieldOK</code> remains false (.F.).</td>
</tr>
<tr valign=top>
<td width=50%><pre><code>IF lFieldOK</code></pre>
</td>
<td width=50%>The conversion section of the program is executed only if a character field named <code>TestField</code> is present in the currently active table.</td>
</tr>
<tr valign=top>
<td width=50%><pre><code>SCAN
 &nbsp; cNumOnly = ""</code><pre><code>&nbsp;&nbsp;&nbsp;FOR nCnt = 1 TO LEN(TestField)
 &nbsp;&nbsp;&nbsp; cCharacter = ;
 &nbsp;&nbsp; SUBSTR(TestField, nCnt, 1)
 &nbsp;&nbsp;&nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp; cNumOnly = cNumOnly + ;
 &nbsp;&nbsp;&nbsp; cCharacter
 &nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDFOR</code></pre>
</pre>
</td>
<td width=50%>The conversion code.</td>
</tr>
<tr valign=top>
<td width=50%><pre><code>&nbsp;&nbsp;&nbsp;REPLACE TestField WITH ;</code><pre><code>&nbsp;&nbsp;cNumOnly
ENDSCAN</code></pre>
</pre>
</td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%><pre><code>ENDIF</code></pre>
</td>
<td width=50%>End of the <code>IF lFieldOK</code> condition.</td>
</tr>
</table><br>
<p>
The most limiting feature of this program is that you can use it for only one field. If you want to remove the non-numeric characters from a field other than <code>TestField</code>, you have to go through the program and change every occurrence of <code>TestField</code> to the name of the other field.</p>
<p>
Converting the program to a function, as explained in the following sections, allows you to make the code you have written more generic and more reusable, saving you work later.</p>

<h2><a name="dgusing_procedures_and_user_defined_functions"></a>Using Procedures and User-Defined Functions</h2>
<p>
Procedures and functions allow you to keep commonly-used code in a single place and call it throughout your application whenever you need it. This makes your code easier to read and easier to maintain because a change can be made once in the procedure rather than multiple times in your programs.</p>
<p>
In Visual FoxPro, procedures look like this:</p>
<pre><code>PROCEDURE myproc
  * This is a comment, but it could be executable code
ENDPROC
</code></pre>
<p>
Traditionally, procedures contain code that you write to perform an operation, and functions do some operations and return a value. In Visual FoxPro, functions are similar to procedures:</p>
<pre><code>FUNCTION myfunc
  * This is a comment, but it could be executable code
ENDFUNC
</code></pre>
<p>
You can include procedures and functions in a separate program file or at the end of a program file that contains normal program code. You cannot have normal executable program code included in a program file following procedures and functions.</p>
<p>
If you include your procedures and functions in a separate program file, you can make these procedures and functions accessible in your program by using the <a href="lngset_procedure.htm">SET PROCEDURE TO</a> command. For example, for a file called FUNPROC.PRG, use this command in the Command window:</p>
<pre><code>SET PROCEDURE TO funproc.prg
</code></pre>
<h3>Calling a Procedure or Function</h3>
<p>
There are two ways to call a procedure or function in your programs:
<ul type=disc>
<li>
Use the <a href="lngdo.htm">DO</a> command. For example:<pre><code>DO myproc
</code></pre>
<p class=tl>
-or-</P></li>
<li>
Include a set of parentheses after the function name. For example:<pre><code>myfunc(&nbsp;)
</code></pre>
</li>
</ul>
<p>
Each of these methods can be expanded by sending or receiving values from the procedure or function.</p>
<h4>Sending Values to a Procedure or Function</h4>
<p>
To send values to procedures or functions, you include <a href="glsparameter.htm">parameters</a>. The following procedure, for example, accepts a single parameter:</p>
<pre><code>PROCEDURE myproc( cString )
 &nbsp; * The following line displays a message
 &nbsp; MESSAGEBOX ("myproc" + cString)
ENDPROC
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Including the parameters inside parentheses in a procedure or function definition line, for example, <code>PROCEDURE myproc(cString)</code>, indicates that the parameter is <a href="glsscope.htm">scoped</a> locally to the procedure or function. You can also allow a function or procedure to accept locally scoped parameters with <a href="lnglparameters.htm">LPARAMETERS</a>.</p>
<p>
Parameters work identically in a function. To send a value as a parameter to this procedure or to a function, you can use a string or a <a href="glsvariable.htm">variable</a> that contains a string, as shown in the following table.</p>
<p class=label>
<b>Passing Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=52%><b>Code</b></td>
<td class=label width=48%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=52%><pre><code>DO myproc WITH cTestString
DO myproc WITH "test string"</code></pre>
</td>
<td width=48%>Calls a procedure and passes a literal string or character variable.</td>
</tr>
<tr valign=top>
<td width=52%><pre><code>myfunc("test string")
myfunc( cTestString )</code></pre>
</td>
<td width=48%>Calls a function and passes a copy of a character variable or literal string.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you call a procedure or function without using the DO command, the <a href="lngset_udfparms.htm">UDFPARMS</a> setting controls how parameters are passed. By default, UDFPARMS is set to VALUE, so copies of the parameters are passed. When you use DO, the actual parameter is used (the parameter is passed by reference), and any changes within the procedure or function are reflected in the original data, regardless of the setting of UDFPARMS.</p>
<p>
You can send multiple values to a procedure or function by separating them with commas. For example, the following procedure expects three parameters: a date, a character string, and a number.</p>
<pre><code>PROCEDURE myproc( dDate, cString, nTimesToPrint )
 &nbsp; FOR nCnt = 1 to nTimesToPrint
 &nbsp;&nbsp;&nbsp;&nbsp; ? DTOC(dDate) + " " + cString + " " + STR(nCnt)
 &nbsp; ENDFOR
ENDPROC
</code></pre>
<p>
You could call this procedure with this line of code:</p>
<pre><code>DO myproc WITH DATE(), "Hello World", 10
</code></pre>
<h4>Receiving Values from a Function</h4>
<p>
The default return value is true (.T.), but you can use the <a href="lngreturn.htm">RETURN</a> command to return any value. For example, the following function returns a date that is two weeks later than date passed to it as a parameter.</p>
<pre><code>FUNCTION plus2weeks
PARAMETERS dDate
 &nbsp; RETURN dDate + 14
ENDFUNC
</code></pre>
<p>
The following line of code stores the value returned from this function to a variable:</p>
<pre><code>dDeadLine = plus2weeks(DATE())
</code></pre>
<p>
The following table lists the ways you can store or display values returned from a function:</p>
<p class=label>
<b>Manipulating Return Values</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Code</b></td>
<td class=label width=52%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=48%><pre><code>var = myfunc(&nbsp;)</code></pre>
</td>
<td width=52%>Stores the value returned by the function to a <a href="glsvariable.htm">variable</a>.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>? myfunc(&nbsp;)</code></pre>
</td>
<td width=52%>Prints the value returned by the function in the active output window.</td>
</tr>
</table><br>
<h4>Verifying Parameters in a Procedure or Function</h4>
<p>
It’s a good idea to verify that the parameters sent to your procedure or function are what you expect to receive. You can use the <a href="lngtypelp_rp.htm">TYPE(&nbsp;)</a> and <a href="lngparameterslp_rp.htm">PARAMETERS(&nbsp;)</a> functions to verify the type and number of parameters sent to your procedure or function.</p>
<p>
The example in the previous section, for instance, needs to receive a Date type parameter. You can use the TYPE(&nbsp;) function to make sure the value your function receives is the right type.</p>
<pre><code>FUNCTION plus2weeks( dDate )
 &nbsp; IF TYPE("dDate") = "D"
 &nbsp;&nbsp;&nbsp;&nbsp; RETURN dDate + 14
 &nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp; MESSAGEBOX( "You must pass a date!" )
 &nbsp;&nbsp;&nbsp;&nbsp; RETURN { - - }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Return an empty date
 &nbsp; ENDIF
ENDFUNC
</code></pre>
<p>
If a procedure expects fewer parameters than it receives, Visual FoxPro generates an error message. For example, if you listed two parameters, but you call the procedure with three parameters, you’ll get an error message. But if a procedure expects more parameters than it receives, the additional parameters are simply initialized to false (.F.). Because there is no way to tell whether the last parameter was set to false (.F.) or omitted, the following procedure checks to make sure the appropriate number of parameters was sent:</p>
<pre><code>PROCEDURE SaveValue( cStoreTo, cNewVal, lIsInTable )
 &nbsp; IF PARAMETERS(&nbsp;) &lt; 3
 &nbsp;&nbsp;&nbsp;&nbsp; MESSAGEBOX( "Too few parameters passed." )
 &nbsp;&nbsp;&nbsp;&nbsp; RETURN .F.
 &nbsp; ENDIF
 &nbsp; IF lIsInTable
 &nbsp;&nbsp;&nbsp;&nbsp; REPLACE (cStoreTo) WITH (cNewVal)
 &nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;cStoreTo = cNewVal
 &nbsp; ENDIF
 &nbsp; RETURN .T.
ENDPROC
</code></pre>
<h3>Converting the NUMONLY Program to a Function</h3>
<p>
NUMONLY.PRG, the example program discussed earlier in <a href="#dgthe_process_of_programming">The Process of Programming</a> section, can be made more robust and useful by creating a function for the part of the program that removes the non-numeric characters from a string.</p>
<p class=label>
<b>Sample Procedure to Return Numeric Characters from a String</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Code</b></td>
<td class=label width=52%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=48%><pre><code>FUNCTION NumbersOnly( cMixedVal )</code></pre>
</td>
<td width=52%>Start of the function, which accepts a character string.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>&nbsp;&nbsp;cNumOnly = ""
  FOR nCnt = 1 TO LEN(cMixedVal)
 &nbsp; cCharacter = ;
  SUBSTR(cMixedVal, nCnt, 1)
 &nbsp;&nbsp; IF ISDIGIT(cCharacter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNumOnly = ;
 &nbsp; cNumOnly + cCharacter
 &nbsp;&nbsp; ENDIF
 &nbsp; ENDFOR</code></pre>
</td>
<td width=52%>Create a string that has only the numeric characters from the original string.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>RETURN cNumOnly</code></pre>
</td>
<td width=52%>Return the string that has only numeric characters.</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>ENDFUNC</code></pre>
</td>
<td width=52%>End of the function.</td>
</tr>
</table><br>
<p>
In addition to allowing you to use this code in multiple situations, this function makes the program easier to read:</p>
<pre><code>SCAN
 &nbsp; REPLACE FieldName WITH NumbersOnly(FieldName)
ENDSCAN
</code></pre>
<p>
Or, even more simply:</p>
<pre><code>REPLACE ALL FieldName WITH NumbersOnly(FieldName)
</code></pre>

<h2><a name="dgmoving_forward"></a>Moving Forward</h2>
<p>
Procedural programming, together with object-oriented programming and the Visual FoxPro design tools, can help you develop a versatile Visual FoxPro application. The rest of this book addresses topics you’ll encounter as you develop Visual FoxPro applications.</p>
<p>
For more information on programming with an object-oriented approach, see Chapter 3, <a href="dgobject_oriented_programming.htm">Object-Oriented Programming</a>, To learn about designing forms with the Form Designer, see Chapter 9, <a href="dgcreating_forms.htm">Creating Forms</a>.</p>
</BODY>
</HTML>
