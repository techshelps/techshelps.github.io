<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tasmanian Traders Sample</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="smptasmanian_traders_sample"></a>Tasmanian Traders Sample</h1>
<p>
The Tasmanian Traders sample is an example of an integrated Visual FoxPro application. The application is an order entry system for a fictional import and export company that sells specialty foods from around the world.</p>
<p>
Tasmanian Traders provides order entry functionality, allowing users to:
<ul type=disc>
<li>
Create new orders.<br><br></li>
<li>
Add items to orders directly.<br><br></li>
<li>
Select items from previous orders.<br><br></li>
<li>
Calculate line item extensions, subtotals, and order totals adjusted for discounts and freight.</li>
</ul>
<p>
The application also illustrates user-level security by requiring users to log onto the application before seeing or editing data.</p>
<p>
Each step in the development of the Tasmanian Traders application has been documented as follows:
<ul type=disc>
<li>
Creating the Specification<br><br></li>
<li>
Designing the Database<p class=tl>
Creating Table Structures and Relationships<br>
Security<br>
Data Integrity<br>
Database Maintenance<br>
Comments about Creating the Database</P></li>
<li>
Designing and Creating Classes<p class=tl>
Application-Level Functionality<br>
Form-Level Functionality<br>
Control-Level Functionality<br>
Comments about the Classes</P></li>
<li>
Writing, Testing, and Debugging the Application Code<p class=tl>
Forms<br>
Reports<br>
Menus and Toolbars<br>
Error Handling<br>
Debugging<br>
The Main Program<br>
Comments About the Code</P></li>
</ul>
<p class=label>
<b>To run Tasmanian Traders</b>
<ul type=disc>
<li>
Enter the following line of code in the <b>Command</b> window:<pre><code>DO (HOME(2) + 'tastrade\tastrade')
</code></pre>
<p class=tl>
-or-</P></li>
</ul>
<ol>
<li>
From the <b>Program</b> menu, choose <b>Do</b>.<br><br></li>
<li>
Choose the …\<b>Samples\Vfp98\Tastrade</b> folder.<br><br></li>
<li>
Double-click <b>Tastrade.app</b>.</li>
</ol>
<p class=label>
<b>To open the project for the Tasmanian Traders application in the Project Manager</b>
<ul type=disc>
<li>
Type the following in the <b>Command</b> window:<pre><code>MODIFY PROJECT (HOME(2) + 'tastrade\tastrade')
</code></pre>
</li>
</ul>
<h2>Creating the Specification for Tasmanian Traders</h2>
<p>
Before any code was written for Tasmanian Traders, a specification detailing the system requirements, functionality, and appearance was written, revised, and refined. The specification is over 30 pages long and includes the following required elements.</p>
<p class=dt>
<b>Functionality</b></p>
<p class=indent>
The application provides order entry functionality, which must include features that allow users to create new orders; add items to orders directly or select items from previous orders; and calculate line item extensions, subtotals, and order totals adjusted for discounts and freight. The application must provide security by requiring users to log onto the application before seeing or editing data.</p>
<p class=dt>
<b>Excluded Functionality</b></p>
<p class=indent>
The application will not manage accounts receivable, billing, or inventory.</p>
<p class=dt>
<b>Interface Requirements</b></p>
<p class=indent>
The interface must meet Windows standards. It should be as attractive and intuitive as possible. These subjective interface requirements were difficult to specify in detail. Consequently, they underwent quite a few changes through the development cycle.</p>
<p class=dt>
<b>International Requirements</b></p>
<p class=indent>
Because the application will be localized into multiple languages, coding must conform to standards required by the internal localization tools.</p>
<p class=dt>
<b>Visual FoxPro Features</b></p>
<p class=indent>
As a sample, the application must illustrate many of the new features of Visual FoxPro, demonstrate how to coordinate menus and toolbars, and provide sample reports.</p>
<p class=dt>
<b>System Requirements</b></p>
<p class=indent>
The application must run with the minimum processor and memory requirements that Visual FoxPro requires, and in a screen display of 640 x 480 pixels.</p>
<p>
In refining the specification, prototypes of the main forms in the application were developed quickly, without functional code. These prototypes were used to demonstrate several usage scenarios to clients. Client feedback about the interface and the functionality was then incorporated into the specification.</p>
<p>
As development progressed, client feedback was incorporated directly into the application without being added to the specification document first. The finished Tasmanian Traders application is noticeably different from the application described in the original specification.</p>
<h2>Designing the Tastrade Database</h2>
<p>
The key tasks in designing the database were:
<ul type=disc>
<li>
Creating table structures and relationships.<br><br></li>
<li>
Implementing security.<br><br></li>
<li>
Maintaining data integrity.</li>
</ul>
<h3>Creating Table Structures and Relationships</h3>
<p>
The process of creating table structures and relationships in Tastrade is discussed in Chapter 5, <a href="dgdesigning_databases.htm">Designing Databases</a>, in the Visual FoxPro <i>Programmer's Guide</i>. To see the tables and relationships in the Tastrade database, open the Database Designer.</p>
<p>
Because the central entity in this application is an order, the table involved in the most relationships is the Orders table. Other entities directly or indirectly support an order: 
<ul type=disc>
<li>
A customer places an order.<br><br></li>
<li>
An employee creates or "takes" an order.<br><br></li>
<li>
A shipper delivers the order.<br><br></li>
<li>
Orders contain line items which, in turn, contain products.</li>
</ul>
<p>
Two tables, Suppliers and Category, support the Products table although they do not directly supply information for an order. Suppliers are the source of the products while the Category table provides information that can be used to manage the products. In Tasmanian Traders, these entities aren't very significant. In other applications, for example, an inventory management application, they would be.</p>
<p>
In addition to the logical design of the database, security and data integrity are important when creating the database.</p>
<h3>Implementing Security</h3>
<p>
Database security involves restricting access to data. Unauthorized users should not have access to any data while other users should not have full access to certain data. For example, you might not want order-entry personnel to be able to change employee information or customer credit limits.</p>
<p>
To implement security, two fields were added to the Employee table: Group_ID and Password. To gain access to information in the database, a user must complete a login form and supply the appropriate password. When the user logs in, Tasmanian Traders can determine the access level of that user from the value in the Group_ID field.</p>
<p>
Because a login form is a common element in many applications, a class was created for the login form: Login in Login.vcx. This form class contains text boxes for a user to enter a user ID and a password. Properties of the class are used to specify the table and the field for the password. Generic code is called in the Click event of the OK command button to validate the password the user entered. A property of the form (uRetVal) is set on whether a user entered the right password.</p>
<p>
For this application, a subclass, LoginPicture, was created for the Login class. LoginPicture includes all the functionality of the Login class, plus a picture of the user, a text description of the user, and a hint for the password. None of these objects would be desirable in a login form outside the context of Tasmanian Traders.</p>
<p>
A login form provides a level of security in a stand-alone application, but because any user with a copy of Visual FoxPro can open the database and view or change data outside of the application, the data isn't really very secure. In a real-world context, network security and/or data encryption would be used to increase security. In the world of this sample application, however, all Visual FoxPro users should have access to the data from inside or outside the application. Therefore, the login user names and passwords need to be apparent to anybody logging in to the application, and the data is not encrypted by the application.</p>
<h3>Maintaining Data Integrity</h3>
<p>
Protecting data integrity involves making sure that authorized users don't add, change, or delete data that would make parts of the database invalid or inaccurate.</p>
<p>
Data integrity management at the database level applies whether a user is changing values through the forms in the application or directly in a Browse window. Thus, data integrity, in the form of referential integrity and enforcing business rules, is handled in the database.</p>
<h3>Referential Integrity</h3>
<p>
Referential integrity was implemented at the database level using the Referential Integrity Builder. For all parent tables in the database, when a key value is changed, that change is also made in the child tables (Cascade on Updating). When a user deletes a record in a parent table, the associated records in the child tables are also deleted (Cascade on Deleting). Users cannot delete records in other parent tables if there are related records in a child table (Restrict on Deleting). A user cannot insert records into child tables that don't match records in the parent tables (Restrict on Inserting).</p>
<p>
Each of the tables in Tastrade (except for Order_Line_Items) has a primary key field. Because Visual FoxPro requires a non-null and not empty value for this field and automatically prevents a duplicate value from being entered in the field, no code has to be written to prevent duplicate primary keys. To make it even easier for a user, however, NewID(&nbsp;), a stored procedure, generates a new value for the primary keys of most tables. The next primary key value for each appropriate table is stored in the Setup table. NewID returns this value and calculates a new value for the next available key. NewID(&nbsp;) is the default value (set in the Table Designer) of Orders.Order_id, Products.Product_id, and other primary key fields in the database.</p>
<p>
For the Customer table, however, it would not be worth the time and effort to generate new Customer_id values for the user. The user must supply the primary key value for a new record added in the Customer or Add Customer form. The primary key for the Customer table is Customer_id. The naming scheme for customer identification is based on the name of the company. For example, the Customer_id for the B's Beverages company is BSBEV. </p>
<h3>Business Rules</h3>
<p>
The Tastrade database needed a rule to ensure that orders couldn't be saved without at least one associated line item. The stored procedure ValOrder(&nbsp;) manages this requirement. In addition, ValOrder(&nbsp;) makes sure that the order total is not above the customer's Max_order_amt or below the customer's Min_order_amt. In Tasmanian Traders, if an order total is above the minimum or maximum order amounts for a customer, a message box gives the user the option to override the rule. In a stricter data scenario, you wouldn't allow a user to override the rule.</p>
<p>
ValOrder(&nbsp;) calls the RemainingCredit(&nbsp;) and CalcMinOrdAmount(&nbsp;) stored procedures. Because the database doesn't store information about which orders a customer has or has not paid for, it isn't possible to get information on a customer's outstanding balance. The RemainingCredit(&nbsp;) procedure assumes that all orders are outstanding.</p>
<h3>Form-Level Validation</h3>
<p>
Form-level data validation includes restricting user access to data by enabling and disabling appropriate controls. Optimistic row buffering is set at the form level for all data-bound forms. The Order Entry form has optimistic table buffering set for the table displayed in the grid. The optimistic row and table buffering is used to revert records when users decide that they don't want to save their changes.</p>
<h3>Database Maintenance</h3>
<p>
To allow a user to reindex the tables and check the validity of the database, the Rebuild form was added to the application. The Rebuild form uses the REINDEX and the VALIDATE DATABASE commands.</p>
<p>
As an alternative to using the REINDEX command, you could extract the index expressions using the TAG(&nbsp;) and KEY(&nbsp;) functions, delete all the tags with DELETE TAG ALL, and recreate all the indexes using the INDEX ON command. This method would minimize the .cdx file.</p>
<h3>Comments on Creating the Database</h3>
<p>
During development, some of the table names and field names were changed to illustrate the long name capabilities of Visual FoxPro. Consequently, views and indexes had to be recreated, and the ControlSource property of bound controls on forms and reports had to be manually changed.</p>
<p>
After login, users originally had to select an action from a menu on an otherwise blank screen. Later in the development process, the Startup_action field in the User_level table was added. Information in this field is used to specify the part of the application that should be run right after login. </p>
<p>
There are two free tables (not included in the database) in the Tastrade project: Behindsc and Repolist. Behindsc is the table used to store Behind the Scenes information, which describes how specific functionality in the application was implemented. It does not contain data for use by the application. Repolist is a table listing available reports, along with a descriptive name and a type for each report. These tables are used internally by the application; they do not constitute part of the data stored in the database by the user. Either of them could have been included in the database, but were not because they work independently of the data that is stored in the Tastrade database.</p>
<h2>Designing and Creating the Tasmanian Trader Classes</h2>
<p>
Six class libraries were created for Tasmanian Traders. Most of the Visual FoxPro base classes were subclassed so that the basic "look and feel" of the application could be easily maintained across components. As much generic functionality as possible was included at the class level so that the classes could be easily maintained and reused.</p>
<p>
In deciding what classes to create, as much consideration was given to maintenance and future projects as to the current project. The goal was to encapsulate as much generic functionality in classes as possible. As a result, the underlying classes contain a lot of built-in functionality and they are designed to be integrated, but it isn't easy for someone to open the project, look at the components, and understand how the application works. Because the components in Tasmanian Traders are integrated so closely, you can't just take one or two of them, add them to another project that is organized differently, and expect them to work. You can quickly and easily expand Tasmanian Traders, though, or other applications built around the same model, by subclassing the appropriate classes.</p>
<p>
Instead of adding the AddNew, Save, Delete, Restore and table navigation methods to the form class, the developers could have created a custom class to hold table operation methods and added an object based on that class to form classes or directly to forms. This would provide more flexibility because the functionality could be added to any form (or even container or control classes) later in the development process, regardless of its parent class. On the other hand, this would provide an additional layer of reference whenever the methods were called and, if the custom class were contained in a different .vcx file, another file would have to be opened when the forms opened. Because the class structure was clearly delineated before the forms were created and all forms bound to data were to inherit from tsBaseForm, the methods were included in tsBaseForm.</p>
<p>
In Tasmanian Traders, a toolbar provides user access to functionality that is common to all forms. An alternative would be to create a class of command buttons to provide this functionality and add an object based on the class to each form. The advantage of this would be that the user might more easily associate the buttons with the form, and a user could more easily access the command buttons with the keyboard. On the other hand, Microsoft Office standards call for toolbars, so users are familiar with them. More importantly, the toolbar didn't take up any additional space on the forms and didn't add any additional controls on forms that already had quite a few controls. Additionally, the toolbar can be customized more easily at run time based on the access level of the user. </p>
<p>
The environment settings were saved in a class so they could be set and restored in a single operation. Another benefit of saving environment settings in a class and restoring them in the code associated with the Destroy event is the fact that it is easy to recover when crashes occur in testing. Issuing RELEASE ALL causes the object Destroy events to fire, restoring the original environment settings.</p>
<h2>Writing, Testing, and Debugging Tasmanian Traders</h2>
<p>
Code in the stored procedures in the database, class methods, form methods, menus, and programs was tested and debugged as it was being written.</p>
<p>
This topic covers writing, testing, and debugging the Tastrade application in the following areas:
<ul type=disc>
<li>
Forms<br><br></li>
<li>
Reports<br><br></li>
<li>
Menus and Toolbars<br><br></li>
<li>
Error Handling<br><br></li>
<li>
Testing and Debugging</li>
</ul>
<p>
This topic also provides a synopsis of what happens when the Main Program is initially executed. At the end of the topic, there are additional Comments about the Code.</p>
<h3>Forms</h3>
<p>
Tastrade includes Form classes (stored in .vcx files) and forms (stored in .scx files) based on Form classes. See the section on Designing and Creating the Tasmanian Trader Classes for information about Form classes. The following list includes all the forms (.scx files) in Tasmanian Traders [ParentClass listed in brackets].</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=37%><b>Form Name</b></td>
<td class=label width=63%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=37%>BehindSc.scx [tsBaseForm]</td>
<td width=63%>Behind the Scenes form.</td>
</tr>
<tr valign=top>
<td width=37%>ViewCode [tsTextForm]</td>
<td width=63%>Displays the code from Behind the Scenes.</td>
</tr>
<tr valign=top>
<td width=37%>Category [tsMaintForm]</td>
<td width=63%>Maintenance form for Category.dbf.</td>
</tr>
<tr valign=top>
<td width=37%>ChngPswd [tsBaseForm]</td>
<td width=63%>Allows user to change password.</td>
</tr>
<tr valign=top>
<td width=37%>CustAdd [tsBaseForm]</td>
<td width=63%>Allows user to enter information for a new customer.</td>
</tr>
<tr valign=top>
<td width=37%>Customer [tsMaintForm]</td>
<td width=63%>Maintenance form for Customer.dbf.</td>
</tr>
<tr valign=top>
<td width=37%>Employee [tsMaintForm]</td>
<td width=63%>Maintenance form for Customer.dbf.</td>
</tr>
<tr valign=top>
<td width=37%>GetInv [form]</td>
<td width=63%>Allows user to specify a date range in the Orders report.</td>
</tr>
<tr valign=top>
<td width=37%>GetTitle [form]</td>
<td width=63%>Allows user to filter the employees to be displayed in the ListEmpl report. GetInv and GetTitle are based on the Visual FoxPro base form class so that they can be run in reports launched from Project Manager without having to open libraries.</td>
</tr>
<tr valign=top>
<td width=37%>OrdEntry [OrderEntry]</td>
<td width=63%>Order Entry form.</td>
</tr>
<tr valign=top>
<td width=37%>OrdHist [OrderEntry]</td>
<td width=63%>Order History form.</td>
</tr>
<tr valign=top>
<td width=37%>Product [tsMaintForm]</td>
<td width=63%>Maintenance form for Products.dbf.</td>
</tr>
<tr valign=top>
<td width=37%>Rebuild [tsBaseForm]</td>
<td width=63%>Allows administrative user to reindex and check validity of the database.</td>
</tr>
<tr valign=top>
<td width=37%>Reports [tsBaseForm]</td>
<td width=63%>Allows user to specify a report to run.</td>
</tr>
<tr valign=top>
<td width=37%>Shipper [tsMaintForm]</td>
<td width=63%>Maintenance form for Shipper.dbf.</td>
</tr>
<tr valign=top>
<td width=37%>Supplier [tsMaintForm]</td>
<td width=63%>Maintenance form for Supplier.dbf.</td>
</tr>
</table><br>
<p>
Most forms with controls that aren't bound to data (for example, IntroForm and About) are saved as classes in .vcx files and created with the CREATEOBJECT(&nbsp;) function. Sometimes a form that is data-bound is called directly as a class. For example, the Login class exposes properties to set the data for its controls. The default values of these properties are set to Tasmanian Traders tables and fields. The subclass, LoginPicture, is used directly in the application; there is no .scx file for these forms.</p>
<p>
The advantage to running a Form class directly is that you can create the form and show it in two separate operations:
<ul type=disc>
<li>
Form = CREATEOBJECT("IntroForm")<br><br></li>
<li>
Form.Show</li>
</ul>
<p>
If you do this, you can adjust property settings after creating the object but before displaying it.</p>
<p>
The advantage of creating a form in the <b>Form Designer</b> is access to a data environment and the properties, events, and methods associated with the data environment object. It is also more convenient to design and test forms in this way because you can run them directly from the <b>Form Designer </b>or from the <b>Project Manager</b>.</p>
<p>
Most of the data-bound forms in the application contain tables in their data environments. If the application had included a form that allowed a user to simultaneously update multiple tables, a view would have been created for that purpose.</p>
<h3>Reports</h3>
<p>
Reports can be developed any time after the database is in place. Tasmanian Traders is not a report-intensive application, so the reports were created relatively late in the development process. Each report contains a local view in its data environment. Two of the reports allow the user to specify parameters for the report:
<ul type=disc>
<li>
The Orders report prints invoices for specified date ranges.<br><br></li>
<li>
The ListEmpl report allows the user to filter the employee listing by job description.</li>
</ul>
<p>
The views in the data environments of these reports were created with parameters. When the report data environments opens the views, Visual FoxPro, by default, presents the user with a generic dialog asking for the parameters. To customize this behavior for Tasmanian Traders, the AutoOpenTables properties of the data environments were set to false (.F.). In the Init of the data environment, custom forms are run to get the parameter variables. Then the OpenTables method of the data environment is called.</p>
<p>
Queries were considered as sources for the reports, but weren't used because they would require extra files (.qpr files) to maintain and track. Views, on the other hand, were contained in the database (.dbc) file and can be conveniently displayed and modified in the Database Designer, as well as added directly to the data environment. SQL SELECT statements, however, are used as needed, as in the RemainingCredit stored procedure.</p>
<h3>Menus and Toolbars</h3>
<p>
The main menu in the application is defined in Main.mnx. The single toolbar used in the application is based on the tsToolbar class in Tsbase.vcx.</p>
<p>
Cleanup code in the menu checks the user level of the person who has logged in to the application, and releases pads and bars to which the user should not have access. Code in the procedure associated with <b>Return to Visual FoxPro </b>on the <b>File</b> menu calls the Cleanup(&nbsp;) method of the application object, which issues CLEAR EVENTS and restores the Visual FoxPro menu system. </p>
<p>
Code associated with the Click event of buttons on the toolbar calls methods of the active form for functionality. In this way, the functionality associated with a form is encapsulated with the form.</p>
<p>
To coordinate the menus and toolbars in the application, code in the menu items calls the Click event code of the command buttons on the toolbars. An expression in the Skip For clause enables or disables the menu items based on the state of the corresponding command button on the toolbar. For a detailed description of coordinating menus and toolbars, search Help for "coordinating toolbars and menus."</p>
<h3>Error Handling</h3>
<p>
The goal for error handling was to anticipate errors and prevent them from appearing in code, if possible. For example, code in Main.prg is included to adjust the relative path setting if Main.prg (in …\Samples\Vfp98\Tastrade\Progs) is run instead of Tastrade.app. Before code in a method sets or reads properties of the application object from outside the object, it first checks to make sure the application object exists:</p>
<pre><code>IF TYPE('oApp') == 'O'
 &nbsp; * do some code
ENDIF
</code></pre>
<p>
If choosing a control would cause an error in a particular situation, that control is disabled. </p>
<p>
Not all errors can be anticipated in code, however. Error handling, when necessary, is managed in the code associated with the Error event of an object.</p>
<p>
When an error occurs in method code, Visual FoxPro checks for error handling code associated with the Error event of the object. If no code has been written at the object level for the Error event, the Error event code inherited from the ParentClass, or from another class up the class hierarchy, is executed. </p>
<p>
If no code has been written for the Error event anywhere in the class hierarchy, Visual FoxPro checks for an ON ERROR routine. If no ON ERROR routine exists, Visual FoxPro displays the default Visual FoxPro error message. To see the default Visual FoxPro error messages, see <a href="tocerror_messages_a_z.htm">Error Messages</a>.</p>
<p>
Tasmanian Traders checks for three types of errors that could occur at the database level: field rule violated, primary key violated, and failed trigger. Because the forms in Tasmanian Traders have a BufferMode setting of 2 - Optimistic, the only times these errors could occur are when the user moves to a different record (causing the buffer to be flushed) or saves changes to the current record. Both of these tasks are handled through methods at the form level (inherited methods from tsBaseForm), so Visual FoxPro first checks for error handling code in the Error event of the form. For example, the following code is associated with the Error event of the Customer form:</p>
<pre><code>DO CASE
 &nbsp; CASE nError = 1884&nbsp; &amp;&amp; Primary key violated
 &nbsp; THISFORM.pageframe1.page1.cntCustomerInfo.Error(nError, cMethod, nLine)
 &nbsp; CASE nError = 1582&nbsp; &amp;&amp; Field rule violated
 &nbsp; THISFORM.pageframe1.page1.cntCustomerInfo.Error(nError, cMethod, nLine)
 &nbsp; OTHERWISE
 &nbsp;&nbsp;&nbsp;&nbsp; tsMaintForm::Error(nError, cMethod, nLine)
ENDCASE
</code></pre>
<p>
If the primary key or a field rule is violated, the error information is passed to the control it relates to, cntCustomerInfo, so that the control's error code can present a more specific error message than the Visual FoxPro default error message, restore old values as appropriate, and set the focus to the appropriate control.</p>
<p>
If another error is encountered, the Customer form passes the error to the parent class, tsMaintForm, which inherits error handling code from tsBaseForm. If the error indicates a failed trigger, code associated with the Error event of tsBaseForm displays the corresponding error message stored in the aErrorMsg[ ] property of the Customer form: "Insert trigger failed," "Update trigger failed," or "Delete trigger failed." (A custom error message unique to the each form can be created by initializing the appropriate element of the aErrorMsg[ ] array in the Init of that form.) Any other errors are handled by giving the user the option to Abort, Retry, or Ignore.</p>
<p>
There is one ON ERROR setting in Tasmanian Traders in the RestoreWindowPos(&nbsp;) method of tsBaseForm:</p>
<pre><code>ON ERROR llError = .T.
</code></pre>
<p>
The code that restores the window postions checks the value of llError. If an error occurs during the reading of the saved window positions from the .INI file, the form's default Top and Left properties determine the form's position.</p>
<h3>Testing and Debugging</h3>
<p>
Testing and debugging was an integral part of all the implementation stages of the development process. As soon as any of the components in Tasmanian Traders were somewhat functional, they were tested. As soon as any bugs were encountered, they were isolated using the Visual FoxPro debugging tools and fixed. </p>
<p>
An application-level constant defined in Tastrade.h was used in the development of Tasmanian Traders to facilitate testing and debugging:</p>
<pre><code>#DEFINE DEBUGMODE .T.
</code></pre>
<p>
Conditional code automatically logged any user in as the Applications Developer (Leverling) if DEBUGMODE is True (.T.) so that the developers didn't have to go through that process every time they ran the application to test it.</p>
<p>
The <b>Utilities</b> menu of the main Tasmanian Traders menu bar is active when a user, or a tester, logs in as an Applications Developer. This menu provides access to the Trace, View, and Debug windows, as well as the ability to cancel, resume, and suspend code. </p>
<h3>The Main Program</h3>
<p>
Code in Main.prg is the main program of the application. When you run the application, the code in Main.prg is executed first. This code:
<ul type=disc>
<li>
Declares the API functions used in reading and writing to the application .ini file.<br><br></li>
<li>
Saves some environment settings. These environment settings (CURDIR(&nbsp;), PATH, and CLASSLIB) need to be set before the application object can be created.<br><br></li>
<li>
Adjusts the path in case a user runs Main.fxp instead of Tastrade.app.<br><br></li>
<li>
Sets the class libraries to MAIN and TSGEN.<br><br></li>
<li>
Creates an application object based on Tastrade in Main.vcx:<pre><code>oApp = CREATEOBJECT('TasTrade')
</code></pre>
</li>
</ul>
<p class=label>
<b>The following actions occur as a result of this object creation:</b>
<ol>
<li>
The Init event of the parent class (APPLICATION) is invoked. Code associated with this event creates an environment object and saves other environment settings: <p class=tl>
THIS.AddObject("oEnvironment", "Environment")</P><p class=tl>
THIS.oEnvironment.Set(&nbsp;)</P></li>
<li>
The default section of the Tastrade.ini file is read with GetPrivString to determine if the Introductory Screen should be displayed.<br><br></li>
<li>
If specified in the .INI, IntroForm (Introductory Screen) is displayed.<br><br></li>
<li>
The Login(&nbsp;) method of the class is called in the Init event of Tastrade.<br><br></li>
<li>
The Login(&nbsp;) method calls the DoFormRetVal(&nbsp;) method of the class.<br><br></li>
<li>
DoFormRetVal(&nbsp;) takes the parameter from Login and creates and shows an instance of the LogInPicture class.<br><br></li>
<li>
When the user logs in, the user's access level is returned and stored as a property, cUserLevel, of the application object.<br><br></li>
<li>
Calls the Do(&nbsp;) method of the application object:<pre><code>oApp.Do(&nbsp;)
</code></pre>
</li>
</ol>
<p class=label>
<b>Code in the Do(&nbsp;) method performs the following actions:</b>
<ol>
<li>
Runs the menu program for the application:<pre><code>THIS.DoMenu(&nbsp;)
</code></pre>
</li>
<li>
Determines, based initially on the user's access level, the component of the application to run:<pre><code>lcAction = THIS.GetStartupAction(&nbsp;)
* The GetStartupAction method returns
* the value in the Action field of the User
</code></pre>
</li>
<li>
Runs that component, for example Order Entry:<pre><code>IF !EMPTY(lcAction)
&amp;lcAction
ENDIF
</code></pre>
</li>
<li>
Establishes the event wait state with READ EVENTS.</li>
</ol>
<h3>Comments about the Code</h3>
<p>
For localization purposes, all strings that will be translated into different languages have to be defined with the #DEFINE preprocessor directive. The defined constants have to end in _LOC so that localization tools can identify them for translation. These are defined in the include file Strings.h.</p>
<p>
Most of the code in the application is written in class or form methods so that it can be encapsulated with the appropriate objects. Stored procedures allow code specifically used in data maintenance or validation to be stored in the database. </p>
<p>
UTILITY.prg, the procedure library for the application, includes four functions: 
<ul type=disc>
<li>
IsTag(&nbsp;) to make sure that an index tag exists before it is referenced.<br><br></li>
<li>
NotYet(&nbsp;) used during development as features are being added.<br><br></li>
<li>
FileSize(&nbsp;) to return the size of a file passed as a parameter.<br><br></li>
<li>
FormIsObject(&nbsp;) which returns .T. if the active form is an object based on the Form base class. </li>
</ul>
<p>
One could create a class to hold these utilities, but an object created just to provide access to these procedures adds an unnecessary level of abstraction.</p>
<h2>Tasmanian Traders Class Libraries</h2>
<p>
Six class libraries were created for Tasmanian Traders. Some of the key decisions in developing Tasmanian Traders concerned the level at which certain functionality should be incorporated:
<ul type=disc>
<li>
The application level<br><br></li>
<li>
The form level<br><br></li>
<li>
The control level</li>
</ul>
<h3>Tastrade Sample: Application Class Functionality</h3>
<p>
A generic Application class, Application, was created in Tsgen.vcx with functionality generic to most applications. This class provides the following functionality:
<ul type=disc>
<li>
Save the Visual FoxPro environment.<br><br></li>
<li>
Set up the environment.<br><br></li>
<li>
Restore the original Visual FoxPro environment.<br><br></li>
<li>
Run the main menu.<br><br></li>
<li>
Manage application toolbars.<br><br></li>
<li>
Manage the user login procedure.<br><br></li>
<li>
Manage forms.</li>
</ul>
<p>
A subclass of the Application class, Tastrade, in Main.vcx provides additional functionality specific to Tasmanian Traders:
<ul type=disc>
<li>
Display the start up screen.<br><br></li>
<li>
Run the initial component.</li>
</ul>
<p>
An object, oApp, is created in Main.prg from the Tastrade class.</p>
<p>
The following sections list and describe the Application class functionality.&nbsp; </p>
<h3>Save the Visual FoxPro Environment</h3>
<p>
The Application Class saves the Visual FoxPro environment when the application runs.&nbsp; The Visual FoxPro environment includes SET command settings such as PATH, TALK, CARRY, and so on. In the Init event of the Application class, code adds a new object to Application based on the Environment class in Tsgen.vcx. In the Init event of the Environment class, code stores the existing Visual FoxPro environment settings to properties of the class so that they can be restored later. </p>
<p>
Code associated with the Init event also stores the caption of the main Visual FoxPro window to the cOldWindCaption property of the Application class. These stored settings are restored when an object based on the Application class is released.</p>
<p>
Another environment factor in Visual FoxPro is the standard toolbars that are active when an application is run. The Application method ReleaseToolbars(&nbsp;) stores the names of system toolbars as well as information about whether they were open or closed when the application was run. </p>
<p>
Code associated with the Init event of the Application class also pushes the current system menu onto the menu stack so that it can be restored later.</p>
<h3>Set Up the Environment</h3>
<p>
Other code in the Init event of the Application class establishes the run-time environment. This code:
<ul type=disc>
<li>
Calls the Set(&nbsp;) method of the Environment class, which sets the class and procedure libraries, whether deleted records are displayed (CLASSLIB, PROCEDURE, DELETED), and other application-specific environment settings. <br><br></li>
<li>
Opens the database for the application. <br><br></li>
<li>
Calls the ReleaseToolbars(&nbsp;) method to release all the system toolbars that were active when the application was run. <br><br></li>
<li>
Sets the window title of the main Visual FoxPro window to the value stored in the cMainWindCaption property of the Application class.</li>
</ul>
<h3>Restore the Original Visual FoxPro Environment</h3>
<p>
When the application quits, code in the Cleanup(&nbsp;) method of the Application class restores the original caption of the main Visual FoxPro window, closes the database, clears windows, issues CLEAR EVENTS, restores the initial menu, and calls the ShowToolbars(&nbsp;) method to reopen the Visual FoxPro system toolbars that were displayed before Tastrade.app was run.</p>
<p>
When CLEAR EVENTS is issued, program execution continues beyond the READ EVENTS command and code in Main.prg releases oApp. When the Application object is released, the Destroy event of the Environment class occurs because it is a member of the Application class. </p>
<p>
In the Destroy event of the Environment object, the Reset(&nbsp;) method of the Environment object is called to restore the Visual FoxPro environment settings that were in effect when the Environment object was created.</p>
<h3>Run the Main Menu and Establish the Event Loop</h3>
<p>
Additional code in the Application object runs the main menu associated with the application and establishes the event loop. The Do(&nbsp;) method of the Application class is called in Main.prg as soon as the Application object is created. The Do(&nbsp;) method runs the main menu program and issues READ EVENTS.</p>
<h3>Manage Application Toolbars</h3>
<p>
The Application object also keeps track of application toolbars. A property at the form level indicates the toolbar to be associated with each form. Because there is only one toolbar in this application, this property setting is the same for all the forms in the application. </p>
<p>
Forms in the application call the ShowNavToolbar(&nbsp;) method of the Application class to display the toolbar. The application knows whether the toolbar already exists and shows it only when necessary, incrementing the nFormInstanceCount property. </p>
<p>
The ReleaseNavToolbar(&nbsp;) method of the application, called in the Destroy event of the forms, decrements the nFormInstanceCount property and removes the toolbar after the last form is released.</p>
<h3>Manage the User Login Procedure</h3>
<p>
Most applications in which security is an issue provide some form of login procedure. To manage this procedure, the Login(&nbsp;) method of the Application class calls the DoFormRetVal(&nbsp;) method, passing the class name of the login screen. When the user logs in, a property of the Application class, cUserLevel, stores the user level for that user. </p>
<p>
This property is used in the menu cleanup code to remove menu items that shouldn’t be visible to a particular user.</p>
<h3>Manage Forms</h3>
<p>
Except for the forms used in reports to set ranges of values for the reports, the forms in Tasmanian Traders are displayed through methods of the Application class. The DoForm(&nbsp;) method accepts the name of a form and one parameter that can optionally be passed to the form. The DoFormRetVal(&nbsp;) method accepts the name of a form class and returns a value specified in the form.</p>
<h3>Display the Start Up Screen</h3>
<p>
The subclass of the Application class, Tastrade, in Main.vcx provides additional functionality specific to Tasmanian Traders. The Init event calls the parent class code in the Application class and, if the start up splash screen should be displayed, calls DoFormRetVal("introform" ).</p>
<h3>Run the Initial Component When a User Logs In</h3>
<p>
The subclass of the Application class, Tastrade, in MAIN.vcx provides additional functionality specific to Tasmanian Traders. Code in the Do(&nbsp;) method overrides the default behavior of the Do(&nbsp;) method of the Application class. Code in the Do(&nbsp;) method calls the GetStartupAction(&nbsp;) method, which returns the component of the application to run after a user logs in. If a default component is specified for a user, code in the Do(&nbsp;) method runs this initial component.</p>
<h3>Tastrade Sample: Form Class Functionality</h3>
<p>
Tasmanian Traders includes these types of forms:
<ul type=disc>
<li>
Modal forms that return a value (for example, the Login form).<br><br></li>
<li>
Data entry forms (for example, the Customer and Order Entry forms).<br><br></li>
<li>
Lookup forms (FindCustomer and FindOrder).<br><br></li>
<li>
General purpose forms (for example, the About and Introductory forms).</li>
</ul>
<p>
The following list depicts the form classes and their hierarchies in Tasmanian Traders.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Form Class</b></td>
<td class=label width=67%><b>Class Library</b></td>
</tr>
<tr valign=top>
<td width=33%>tsFormRetVal</td>
<td width=67%>Tsbase.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- IntroForm</td>
<td width=67%>Tsgen.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- Login</td>
<td width=67%>Login.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- LoginPicture</td>
<td width=67%>Login.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- FindCustomer</td>
<td width=67%>Tsgen.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- FindOrder</td>
<td width=67%>Tsgen.vcx</td>
</tr>
<tr valign=top>
<td width=33%>tsBaseForm</td>
<td width=67%>Tsbase.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- tsMaintForm</td>
<td width=67%>Tsbase.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- tsTextForm</td>
<td width=67%>Tsbase.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- OrderEntry</td>
<td width=67%>Orders.vcx</td>
</tr>
<tr valign=top>
<td width=33%>- About</td>
<td width=67%>About.vcx</td>
</tr>
</table><br>
<h3>Modal Forms</h3>
<p>
All forms that return a value are derived at some level from <code>tsFormRetVal</code> in Tsbase.vcx. All the data entry form classes are based on <code>tsBaseForm</code> in Tsbase.vcx. </p>
<p>
<code>tsFormRetVal</code> prevents access to other components while active.</p>
<p class=label>
<b>Property Settings</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=33%>AutoCenter =</td>
<td width=67%>.T.</td>
</tr>
<tr valign=top>
<td width=33%>BackColor =</td>
<td width=67%>Light Gray</td>
</tr>
<tr valign=top>
<td width=33%>BorderStyle =</td>
<td width=67%>2-Double wide</td>
</tr>
<tr valign=top>
<td width=33%>FontSize =</td>
<td width=67%>8</td>
</tr>
<tr valign=top>
<td width=33%>MaxButton =</td>
<td width=67%>.F.</td>
</tr>
<tr valign=top>
<td width=33%>MinButton =</td>
<td width=67%>.F.</td>
</tr>
<tr valign=top>
<td width=33%>WindowType =</td>
<td width=67%> 1-Modal</td>
</tr>
</table><br>
<p class=label>
<b>Custom Properties</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=33%>uRetVal:</td>
<td width=67%>Holds the form's return value. Can be any data type; the "u" prefix stands for "unknown." <code>uRetVal</code> is .T. by default.</td>
</tr>
</table><br>
<p>
To create an instance of a subclass, call <code>Application.DoFormRetVal</code>.</p>
<h3>Data Entry Forms</h3>
<p>
Forms for data entry are based on the tsBaseForm class and are closely integrated with the tsToolbar class. tsBaseForm is the parent class of most forms in the Tasmanian Traders application. It provides the following functionality:
<ul type=disc>
<li>
Table navigation<br><br></li>
<li>
Management of user access to data<br><br></li>
<li>
Interface coordination</li>
</ul>
<p class=label>
<b>Property Settings</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=32%>BufferMode =</td>
<td width=68%> 2-Optimistic</td>
</tr>
</table><br>
<p class=label>
<b>Custom Properties</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=33%>aerrormsg[3] =</td>
<td width=67%>An array of error messages. This allows generic error handling code to be written in the parent class and custom error messages to be defined in each subclass. The following default values are defined in the code associated with the Init event of particular forms:</td>
</tr>
<tr valign=top>
<td width=33%>aerrormsg[1] =</td>
<td width=67%>"Insert trigger failed!"</td>
</tr>
<tr valign=top>
<td width=33%>aerrormsg[2] =</td>
<td width=67%>"Update trigger failed!"</td>
</tr>
<tr valign=top>
<td width=33%>aerrormsg[3] =</td>
<td width=67%>"Delete trigger failed!"</td>
</tr>
<tr valign=top>
<td width=33%>cToolBar:</td>
<td width=67%>Holds the name of the toolbar to run when the form is run.</td>
</tr>
<tr valign=top>
<td width=33%>lAllowEdits:</td>
<td width=67%>Whether or not the current record can be edited. </td>
</tr>
<tr valign=top>
<td width=33%>lAllowDelete:</td>
<td width=67%>Whether or not the current record can be deleted.</td>
</tr>
<tr valign=top>
<td width=33%>lAllowNew:</td>
<td width=67%>Whether or not the user is allowed to add new records</td>
</tr>
</table><br>
<p class=label>
<b>Functionality Associated with Events</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=32%>Init:</td>
<td width=68%>1. Restores the previous window position.<br>
2. Adds the form's caption to the menu.<br>
3. Displays the navigation toolbar.<br>
4. Initializes the custom error message array, aerrormsg[ ].</td>
</tr>
<tr valign=top>
<td width=32%>Activate:</td>
<td width=68%>1. Selects the alias specified in the InitialSelectedAlias property of the form's data environment.<br>
2. Refreshes the navigation toolbar.<br>
3. Refreshes the menu.<br>
4. Sets the message of the status bar to the form's Caption property. </td>
</tr>
<tr valign=top>
<td width=32%>Error:</td>
<td width=68%>Defines generic error handling code for all forms. </td>
</tr>
<tr valign=top>
<td width=32%>Destroy:</td>
<td width=68%>1. Removes the form's caption from the menu.<br>
2. Saves the position of the window in the Tastrade.ini file.</td>
</tr>
<tr valign=top>
<td width=32%>QueryUnload:</td>
<td width=68%>Checks whether data has changed, and prompts the user to save changes if necessary.</td>
</tr>
<tr valign=top>
<td width=32%>Unload:</td>
<td width=68%>Clears the status bar.</td>
</tr>
</table><br>
<p class=label>
<b>Custom Methods</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=32%>First:</td>
<td width=68%>Advances the record pointer to the first record.</td>
</tr>
<tr valign=top>
<td width=32%>Next:</td>
<td width=68%>Advances the record pointer to the next record.</td>
</tr>
<tr valign=top>
<td width=32%>Prior:</td>
<td width=68%>Advances the record pointer to the previous record.</td>
</tr>
<tr valign=top>
<td width=32%>Last:</td>
<td width=68%>Advances the record pointer to the last record.</td>
</tr>
</table><br>
<p>
These four methods all share the following behavior:
<ul type=disc>
<li>
Call the form's custom DataChanged(&nbsp;) method to check for changes.<br><br></li>
<li>
Call the form's custom AskToSave(&nbsp;) method to prompt the user to save any changes.</li>
</ul>
<p class=label>
<b>Custom Methods</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=32%>Save:</td>
<td width=68%>Saves the current record.</td>
</tr>
<tr valign=top>
<td width=32%>Delete:</td>
<td width=68%>Deletes the current record.</td>
</tr>
<tr valign=top>
<td width=32%>AddNew:</td>
<td width=68%>Adds a new record.</td>
</tr>
<tr valign=top>
<td width=32%>Restore:</td>
<td width=68%>Restores original field values (cancels changes).</td>
</tr>
<tr valign=top>
<td width=32%>AddToMenu:</td>
<td width=68%>Adds the form's caption to the Window menu.</td>
</tr>
<tr valign=top>
<td width=32%>RemoveFromMenu:</td>
<td width=68%>Removes the form's caption from the Window menu.</td>
</tr>
<tr valign=top>
<td width=32%>AskToSave:</td>
<td width=68%>Prompts user to save changes, not to save changes, or to cancel the last operation.</td>
</tr>
<tr valign=top>
<td width=32%>DataChanged:</td>
<td width=68%>Returns .T. if any data on the current form has changed.</td>
</tr>
<tr valign=top>
<td width=32%>WriteBuffer:</td>
<td width=68%>Code to flush the value of the current control to the record buffer.</td>
</tr>
<tr valign=top>
<td width=32%>RefreshForm:</td>
<td width=68%>Custom refresh routine.</td>
</tr>
<tr valign=top>
<td width=32%>SaveWindowPos:</td>
<td width=68%>Writes the Top and Left properties of the form to the application's INI file.</td>
</tr>
<tr valign=top>
<td width=32%>RestoreWindowPos:</td>
<td width=68%>Reads the Top and Left properties of the form from the application's INI file and sets them.</td>
</tr>
<tr valign=top>
<td width=32%>WaitMode:</td>
<td width=68%>Changes the mouse cursor to an hourglass for all controls on a form.</td>
</tr>
</table><br>
<h3>Lookup Forms</h3>
<p>
The FindCustomer and FindOrder forms display the customer and order tables, respectively, in a grid and allow the user to change the index tag. The key value from the selected row is returned to the calling form when the user closes the form.</p>
<h3>General Purpose Forms</h3>
<p>
There are two general purpose forms:</p>
<p class=dt>
<b>AboutBox Form</b></p>
<p class=indent>
AboutBox in About.vcx accepts parameters in its Init event for caption texts and a logo bitmap. This class uses API functions to retrieve information from either the WIN.INI file for Windows 3.x, or the system registry otherwise, to display information about the user's system.</p>
<p class=dt>
<b>IntroForm</b></p>
<p class=indent>
IntroForm in Tsgen.vcx is the initial splash screen. Code associated with the Click event of chkShowAtStartUp in this class writes a value to the Tastrade.ini file to specify whether the splash screen should be displayed in the future when Tasmanian Traders is run.</p>
<h3>Tastrade Sample: Control Class Functionality</h3>
<p>
Most of the Visual FoxPro base control classes were subclassed to provide additional default functionality or a consistent appearance. Whenever groups of controls were needed in more than one place in Tasmanian Traders, a class was created. </p>
<p>
Because the application had to run in a 640 x 480 display, the default font of these controls was set to be 8 point rather than 10 point, to save space on the forms. </p>
<p>
The control classes are listed below by library.</p>
<p class=label>
<b>Tsbase.vcx Class Library</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Class</b></td>
<td class=label width=69%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=31%>ts3dShape</td>
<td width=69%>The class for shape controls, used mostly for accentuating or enclosing parts of a form</td>
</tr>
<tr valign=top>
<td width=31%>TsComboBox </td>
<td width=69%>The class for all combo boxes in the application.</td>
</tr>
<tr valign=top>
<td width=31%>TsCommandButton </td>
<td width=69%>The class for all command buttons in the application.</td>
</tr>
<tr valign=top>
<td width=31%>TsEditBox</td>
<td width=69%>The class for all edit boxes in the application.</td>
</tr>
<tr valign=top>
<td width=31%>TsGrid </td>
<td width=69%>The SumColumn method is used to automatically sum a value in a grid column. This class is added to the List page of the page frame in the tsMaintForm class.</td>
</tr>
<tr valign=top>
<td width=31%>TsLabel</td>
<td width=69%>The class for all labels in the application.</td>
</tr>
<tr valign=top>
<td width=31%>TsListBox</td>
<td width=69%>The class used for all list boxes in the application.</td>
</tr>
<tr valign=top>
<td width=31%>TsTextBox</td>
<td width=69%>The class for all text boxes in the application.</td>
</tr>
<tr valign=top>
<td width=31%>OrdTextbox</td>
<td width=69%>A subclass of tsTextbox which is used in Order Entry and Order History forms.</td>
</tr>
<tr valign=top>
<td width=31%>TsToolBarButton</td>
<td width=69%>The class for all command buttons that appear on toolbars in the application.</td>
</tr>
</table><br>
<p class=label>
<b>Tsgen.vcx Class Library</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Class</b></td>
<td class=label width=69%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=31%>CustomerInfo</td>
<td width=69%>Includes labels and text boxes for the following fields in the customer table</td>
</tr>
<tr valign=top>
<td width=31%>DateRange </td>
<td width=69%>A custom control based on the Visual FoxPro Control base class.</td>
</tr>
<tr valign=top>
<td width=31%>Splitter</td>
<td width=69%>Used in Behind the Scenes to resize the list of features and the description edit box.</td>
</tr>
<tr valign=top>
<td width=31%>TsMaintForm </td>
<td width=69%>The class for all maintenance forms in the application.</td>
</tr>
<tr valign=top>
<td width=31%>TsToolBar </td>
<td width=69%>The class for the toolbar in the application.</td>
</tr>
</table><br>
</BODY>
</HTML>
