<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Index File Structure (.idx)</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="conindex_file_structure_lp.idxrp"></a><sup></sup>Index File Structure (.idx)</h1>
<p>
<a href="conindex_file_structure_lp.idxrpsa.htm">See Also</a></p>
<p>
Index files contain one header record and one or many node records. The header record contains information about the root node, the current file size, the length of the key, index options and signature, and printable ASCII representations of the key<sup>1 </sup>and FOR expressions. The header record starts at file position zero.</p>
<p>
The remaining node records contain an attribute, number of keys present, and pointers to nodes on the left and right (on the same level) of the current node. They also contain a group of characters encompassing the key value and either a pointer to a lower level node or an actual table record number. The size of each record that is output to a file is 512 bytes.</p>
<p class=label>
<b>Index Header Record</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Byte offset</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%>00&nbsp;–&nbsp;03</td>
<td width=79%>Pointer to the root node</td>
</tr>
<tr valign=top>
<td width=21%>04&nbsp;–&nbsp;07</td>
<td width=79%>Pointer to the free node list ( -1 if not present)</td>
</tr>
<tr valign=top>
<td width=21%>08&nbsp;–&nbsp;11</td>
<td width=79%>Pointer to the end of file (file size)</td>
</tr>
<tr valign=top>
<td width=21%>12&nbsp;–&nbsp;13</td>
<td width=79%>Length of key</td>
</tr>
<tr valign=top>
<td width=21%>14 </td>
<td width=79%>Index options (any of the following numeric values or their sums):<br>
1 – a unique index <br>
8 – index has FOR clause</td>
</tr>
<tr valign=top>
<td width=21%>15</td>
<td width=79%>Index signature (for future use)</td>
</tr>
<tr valign=top>
<td width=21%>16&nbsp;–&nbsp;235</td>
<td width=79%>Key expression (uncompiled; up to 220 characters)<sup>1,3</sup></td>
</tr>
<tr valign=top>
<td width=21%>236&nbsp;–&nbsp;455</td>
<td width=79%>FOR expression (uncompiled; up to 220 characters ending with a null value byte)</td>
</tr>
<tr valign=top>
<td width=21%>456&nbsp;–&nbsp;511</td>
<td width=79%>Unused</td>
</tr>
</table><br>
<p class=label>
<b>Index Node Record</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Byte offset</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%>00&nbsp;–&nbsp;01</td>
<td width=79%>Node attributes (any of the following numeric values or their sums):<br>
0 – index node <br>
1 – root node <br>
2 – leaf node</td>
</tr>
<tr valign=top>
<td width=21%>02&nbsp;–&nbsp;03</td>
<td width=79%>Number of keys present (0, 1 or many)</td>
</tr>
<tr valign=top>
<td width=21%>04&nbsp;–&nbsp;07</td>
<td width=79%>Pointer to the node directly to left of the current node (on same level; -1 if not present)</td>
</tr>
<tr valign=top>
<td width=21%>08&nbsp;–&nbsp;11</td>
<td width=79%>Pointer to the node directly to right of the current node (on same level; -1 if not present)</td>
</tr>
<tr valign=top>
<td width=21%>12&nbsp;–&nbsp;511</td>
<td width=79%>Up to 500 characters containing the key value for the length of the key with a four-byte hexadecimal number stored in normal left-to-right format:<br>
If the node is a leaf (attribute = 02 or 03) then the four bytes contain an actual table number in hexadecimal format; otherwise, the 4 bytes contain an intra-index pointer.<sup>2</sup><p>
The key/four-byte hexadecimal number combinations will occur the number of times indicated in bytes 02&nbsp;–&nbsp;03.</p>
</td>
</tr>
</table><br>
<p class=mini>
1 The type of the key is not stored in the index. It must be determined by the key expression.<br>
2 Anything other than character strings, numbers used as key values, and the four-byte numbers in the leaf node are represented in reversed bytes (Intel 8086 format).<br>
3 Numbers are a special case when used as a key. They are converted through the following algorithm so they can be sorted using the same ASCII collating sequence as characters:
<ul type=disc>
<li class=mini>
Convert the number to IEEE floating point format.<br><br></li>
<li class=mini>
Swap the order of the bytes from Intel 8086 order to left-to-right order.<br><br></li>
<li class=mini>
If the number was negative, take the logical complement of the number (swap all 64 bits, 1 to 0 and 0 to 1); otherwise, invert only the leftmost bit.</li>
</ul>
<h3>Example of an Ordered Tree Structure</h3>
<p>
Finding a key in the structure below requires searching a single path between the root and leaf nodes. Nodes at the lowest level are leaf nodes. Because the keys are sorted, all keys in the sub-tree are less than or equal to the parent node.</p>
<p>
<img src="oh036.gif" border=0></p>
<p>
In the illustration above, the letters are used as the key values. Each key would also have a four-byte hexadecimal number. The numbers associated with the keys in the <i>leaf</i> nodes would be actual table numbers — all keys in other nodes would have intra-index pointers associated with them.</p>
<p>
Bytes 12-511 in the index node record could be viewed as follows:</p>
<p>
<img src="oh037.gif" border=0></p>
<p>
The key value/hexadecimal number combination occurs in bytes 12&nbsp;–&nbsp;511 n times where n is the number of keys present.</p>
</BODY>
</HTML>
