<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Programming for Shared Access</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="dgprogramming_for_shared_access"></a><sup></sup>Chapter 17: Programming for Shared Access</h1>
<p>
If you create an application that will run on several machines in a network environment, or if several instances of a form will access the same data, then you need to program for shared access. Shared access means providing efficient ways of using and sharing data among users, as well as restricting access when necessary.</p>
<p>
Visual FoxPro provides support for shared or exclusive access to data, locking options, data sessions, record and table buffering, and transactions. Although these features are particularly useful in shared environments, you can use them in single-user environments too.</p>
<p>
This chapter discusses:</p>
<ul type=disc>
<li>
<a href="#dgcontrolling_access_to_data">Controlling Access to Data</a></li>
<li>
<a href="#dgupdating_data">Updating Data</a></li>
<li>
<a href="#dgmanaging_conflicts">Managing Conflicts</a></li>
</ul>

<h2><a name="dgcontrolling_access_to_data"></a>Controlling Access to Data</h2>
<p>
Since you access data in files, effective data management begins with control over the environment of these files. You must choose how to access the data and how and when to limit that access.</p>
<h3>Accessing Data</h3>
<p>
In a shared environment, you can access data in two ways: from exclusive files or from shared files. If you open a table for shared access, other users also have access to the file. If you open a table for exclusive access, no other user can read or write to that file. Because exclusive use defeats many of the benefits of sharing data on a network, it should be used sparingly.</p>
<h4>Using a Table with Exclusive Access</h4>
<p>
The most restrictive way to open a file is to open it exclusively. When you open a table through the interface, it opens for exclusive use by default. You can also explicitly open a table for exclusive use by using Visual FoxPro commands.</p>
<p class=label>
<b>To open a table for exclusive use</b>
<ul type=disc>
<li>
Type the following commands in the <b>Command</b> window:<pre><code>SET EXCLUSIVE ON
USE cMyTable
</code></pre>
<p class=tl>
-or-</P></li>
<li>
Type the following command in the <b>Command</b> window:<pre><code>USE cMyTable EXCLUSIVE
</code></pre>
</li>
</ul>
<p>
The following commands require you to open a table for exclusive use:</p>
<ul type=disc>
<li>
<a href="lngalter_table___sql.htm">ALTER TABLE</a></li>
<li>
<a href="lngindex.htm">INDEX</a> when creating, adding, or deleting a compound index tag.</li>
<li>
<a href="lnginsert.htm">INSERT [BLANK]</a></li>
<li>
<a href="lngmodify_structure.htm">MODIFY STRUCTURE</a>  To use this command to change a table structure, you must open the table exclusively. You can, however, use this command in read-only mode when you open the table for shared use.</li>
<li>
<a href="lngpack.htm">PACK</a></li>
<li>
<a href="lngreindex.htm">REINDEX</a></li>
<li>
<a href="lngzap.htm">ZAP</a></li>
</ul>
<p>
Visual FoxPro returns the error, “Exclusive open of file is required,” if you try to execute one of these commands on a shared table.</p>
<p>
You can restrict access to a table by using the <a href="lngflocklp_rp.htm">FLOCK(&nbsp;)</a> function. If you use FLOCK(&nbsp;) to lock the table, other users cannot write to the table but they can read it.</p>
<h4>Using a Table with Shared Access</h4>
<p>
When you open a table for shared use, more than one workstation can use the same table at the same time. When you open a table through the interface, you can override the default ON setting for <a href="lngset_exclusive.htm">SET EXCLUSIVE</a>. You can explicitly open a table for shared use by using Visual FoxPro commands.</p>
<p class=label>
<b>To open a table for shared use</b>
<ul type=disc>
<li>
Type the following commands in the <b>Command</b> window:<pre><code>SET EXCLUSIVE OFF
USE cMyTable
</code></pre>
<p class=tl>
-or-</P></li>
<li>
Type the following command in the <b>Command</b> window:<pre><code>USE cMyTable SHARED
</code></pre>
</li>
</ul>
<p>
When you add or change data in a shared table, you must first lock the affected record or the entire table. You can lock a record or a table opened for shared use in the following ways:</p>
<ul type=disc>
<li>
Use a command that performs an automatic record or table lock. See the table of commands that perform automatic locking in the section, <a href="#dgchoosing_automatic_or_manual_locks">Choosing Automatic or Manual Locks</a>.</li>
<li>
Manually lock one or more records or an entire table with the record and table locking functions.</li>
<li>
Initiate buffering with the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function.</li>
</ul>
<p>
Associated memo and index files always open with the same share status as their table.</p>
<p>
If your application uses a table for lookup purposes only and all users of the application access it, then you can improve performance by marking the table as read-only.</p>
<h3>Locking Data</h3>
<p>
If you share access to files, you must also manage access to data by locking tables and records. Locks, unlike access permissions, can provide both long- and short-term control of data. Visual FoxPro provides both automatic and manual locking.</p>
<h4>Choosing Record or Table Locks</h4>
<p>
Record locking, whether automatic or manual, prevents one user from writing to a record that’s currently being written to by another user. Table locking prevents other users from writing to, but not reading from, an entire table. Because table locking prohibits other users from updating records in a table, it should only be used sparingly.</p>

<h4><a name="dgchoosing_automatic_or_manual_locks"></a>Choosing Automatic or Manual Locks</h4>
<p>
In addition to record or table locking, you can also choose automatic or manual locking. Many Visual FoxPro commands automatically attempt to lock a record or a table before the command is executed. If the record or table is successfully locked, the command is executed and the lock is released.</p>
<p class=label>
<b>Commands that Automatically Lock Records and Tables</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Command</b></td>
<td class=label width=62%><b>Scope of lock</b></td>
</tr>
<tr valign=top>
<td width=38%><a href="lngalter_table___sql.htm">ALTER TABLE</a></td>
<td width=62%>Entire table</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngappend.htm">APPEND</a></td>
<td width=62%>Table header</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngappend.htm">APPEND BLANK</a></td>
<td width=62%>Table header</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngappend_from.htm">APPEND FROM</a></td>
<td width=62%>Table header</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngappend_from_array.htm">APPEND FROM ARRAY</a></td>
<td width=62%>Table header</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngappend_memo.htm">APPEND MEMO</a></td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngblank.htm">BLANK</a></td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngbrowse.htm">BROWSE</a>, <a href="lngchange.htm">CHANGE</a> and <a href="lngedit.htm">EDIT</a></td>
<td width=62%>Current record and all records from aliased fields in related tables once editing of a field begins</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a></td>
<td width=62%>Depends on parameters</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngdelete.htm">DELETE</a></td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngdelete.htm">DELETE NEXT 1</a></td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngdelete.htm">DELETE RECORD n</a></td>
<td width=62%>Record <i>n</i></td>
</tr>
<tr valign=top>
<td width=38%><a href="lngdelete.htm">DELETE</a> of more than one record</td>
<td width=62%>Entire table</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngdelete___sql.htm">DELETE – SQL</a></td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lnggather.htm">GATHER</a></td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lnginsert.htm">INSERT</a></td>
<td width=62%>Entire table</td>
</tr>
<tr valign=top>
<td width=38%><a href="lnginsert___sql.htm">INSERT - SQL</a></td>
<td width=62%>Table header</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngmodify_memo.htm">MODIFY MEMO</a></td>
<td width=62%>Current record when editing begins</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngread.htm">READ</a></td>
<td width=62%>Current record and all records from aliased fields</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngrecall.htm">RECALL</a></td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngrecall.htm">RECALL</a> NEXT 1</td>
<td width=62%>Current record</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngrecall.htm">RECALL</a> RECORD <i>n</i></td>
<td width=62%>Record <i>n</i></td>
</tr>
<tr valign=top>
<td width=38%><a href="lngrecall.htm">RECALL</a> of more than one record</td>
<td width=62%>Entire table</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngreplace.htm">REPLACE</a></td>
<td width=62%>Current record and all records from aliased fields</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngreplace.htm">REPLACE</a> NEXT 1</td>
<td width=62%>Current record and all records from aliased fields</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngreplace.htm">REPLACE</a> RECORD <i>n</i></td>
<td width=62%>Record <i>n</i> and all records from aliased fields</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngreplace.htm">REPLACE</a> of more than one record</td>
<td width=62%>Entire table and all files from aliased fields</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngshow_gets.htm">SHOW GETS</a></td>
<td width=62%>Current record and all records referenced by aliased fields</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a></td>
<td width=62%>Depends on buffering</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngupdate.htm">UPDATE</a></td>
<td width=62%>Entire table</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngupdate___sql.htm">UPDATE – SQL</a></td>
<td width=62%>Entire table</td>
</tr>
</table><br>
<p>
<b>Record Lock Characteristics</b></p>
<p>
Commands that attempt record locks are less restrictive than commands that lock tables. When you lock a record, other users can still add or delete other records. If a record or table is already locked by another user, an attempted record or table lock fails. Commands that attempt to lock the current record return the error, “Record is in use by another,” if the record cannot be locked.</p>
<p>
The <a href="lngbrowse.htm">BROWSE</a>, <a href="lngchange.htm">CHANGE</a>, <a href="lngedit.htm">EDIT</a>, and <a href="lngmodify_memo.htm">MODIFY MEMO</a> commands do not lock a record until you edit the record. If you're editing fields from records in related tables, the related records are locked if possible. The lock attempt fails if the current record or any of the related records are also locked by another user. If the lock attempt is successful, you can edit the record; the lock is released when you move to another record or activate another window.</p>
<p>
<b>Header and Table Lock Characteristics</b></p>
<p>
Some Visual FoxPro commands lock an entire table while others only lock a table header. Commands that lock the entire table are more intrusive than commands that only lock the table header. When you lock the table header, other users cannot add records, but they can still change data in fields.</p>
<p>
Users can share the table without causing a conflict when you issue the <a href="lngappend.htm">APPEND BLANK</a> command, but an error can occur while another user is also appending a BLANK record to the table. You can trap for the error, “File is in use by another,” which is returned when two or more users execute APPEND BLANK simultaneously. Commands that lock an entire table return the error, “File is in use by another,” if the table cannot be locked. To cancel the attempted lock, press ESC.</p>
<p>
<b>Example: Automatic Locking</b></p>
<p>
In the following example, the user automatically locks the table header by appending records from another table, even though <code>customer</code> was opened as a shared file:</p>
<pre><code>SET EXCLUSIVE OFF
USE customer
APPEND FROM oldcust FOR status = "OPEN"
</code></pre>
<h4>Locking Manually</h4>
<p>
You can manually lock a record or a table with locking functions.</p>
<p class=label>
<b>To manually lock a record or a table</b>
<ul type=disc>
<li>
Use one of the following commands:<pre><code>RLOCK()
LOCK()
FLOCK()
</code></pre>
</li>
</ul>
<p>
<a href="lngrlocklp_rp.htm">RLOCK(&nbsp;)</a> and <a href="lnglocklp_rp.htm">LOCK(&nbsp;)</a> are identical and lock one or more records. <a href="lngflocklp_rp.htm">FLOCK(&nbsp;)</a> locks a file. The LOCK(&nbsp;) and RLOCK(&nbsp;) functions can apply to a table header. If you provide 0 as the record to LOCK(&nbsp;) or RLOCK(&nbsp;) and the test indicates the header is unlocked, the function locks the header and returns true (.T.).</p>
<p>
Once you lock a record or table, be sure to release the lock by using the <a href="lngunlock.htm">UNLOCK</a> command as soon as possible to provide access to other users.</p>
<p>
These manual locking functions perform the following actions:</p>
<ul type=disc>
<li>
Test the lock status of the record or table.</li>
<li>
If the test indicates the record is unlocked, lock the record or table and return true (.T.).</li>
<li>
If the record or table cannot be locked, attempt to lock the record or table again, depending on the current setting of <a href="lngset_reprocess.htm">SET REPROCESS</a>.</li>
<li>
Return true (.T.) or false (.F.), indicating whether the lock attempt was successful.<p class=atl>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If you want to test the lock status of a record in your session without locking the record, use the <a href="lngisrlocked.htm">ISRLOCKED(&nbsp;)</a> or <a href="lngisflocked.htm">ISFLOCKED(&nbsp;)</a> function.</p></li>
</ul>
<p>
If an attempt to lock a record or table fails, the SET REPROCESS command and your current error routine determine if the lock is attempted again. SET REPROCESS affects the result of an unsuccessful lock attempt. You can control the number of lock attempts or the length of time a lock is attempted with SET REPROCESS.</p>
<p>
<b>Example: Manual Locking</b></p>
<p>
The following example opens the <code>customer</code> table for shared access and uses FLOCK(&nbsp;) to attempt to lock the table. If the table is successfully locked, REPLACE ALL updates every record in the table. UNLOCK releases the file lock. If the file cannot be locked because another user has locked the file or a record in the file, a message is displayed.</p>
<pre><code>SET EXCLUSIVE OFF
SET REPROCESS TO 0
USE customer&nbsp;&nbsp;&nbsp; &amp;&amp; Open table shared
IF FLOCK()
 REPLACE ALL contact ;&nbsp;&nbsp;&nbsp; &amp;&amp; Replace and unlock
  WITH UPPER(contact) 
 UNLOCK&nbsp;&nbsp; 
ELSE&nbsp; &amp;&amp; Output message
 WAIT "File in use by another." WINDOW NOWAIT
ENDIF
</code></pre>

<h3><a name="dgunlocking_data"></a>Unlocking Data</h3>
<p>
After you establish a record or file lock and complete a data operation in a shared environment, you should release the lock as soon as possible. There are several ways to release locks. In some cases, simply moving to the next record is enough to unlock the data. Other situations require explicit commands.</p>
<p>
To unlock a record that's been automatically locked, you need only move the record pointer, even if you set MULTILOCKS ON. You must explicitly remove a lock from a record that you’ve manually locked; simply moving the record pointer is not enough.</p>
<p>
The following table describes the effects of commands on manual and automatic record and table locks.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Command</b></td>
<td class=label width=62%><b>Effect</b></td>
</tr>
<tr valign=top>
<td width=38%><a href="lngunlock.htm">UNLOCK</a></td>
<td width=62%>Releases record and file locks in the current work area.</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngunlock.htm">UNLOCK ALL</a></td>
<td width=62%>Releases all locks in all work areas in the current session.</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngset_multilocks.htm">SET MULTILOCKS OFF</a></td>
<td width=62%>Enables automatic release of the current lock as a new lock is secured.</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngflocklp_rp.htm">FLOCK(&nbsp;)</a></td>
<td width=62%>Releases all record locks in the affected file before locking the file.</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngclear.htm">CLEAR ALL</a>, <a href="lngclose.htm">CLOSE ALL</a>,<br>
<a href="lnguse.htm">USE</a>, <a href="lngquit.htm">QUIT</a></td>
<td width=62%>Releases all record and file locks.</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngend_transaction.htm">END&nbsp;TRANSACTION</a></td>
<td width=62%>Releases automatic locks.</td>
</tr>
<tr valign=top>
<td width=38%><a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a></td>
<td width=62%>Releases all locks after updating the table.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Caution</b></B>&nbsp;&nbsp;&nbsp;If a record was automatically locked in a user-defined function and you move the record pointer off and then back on the record, the lock will be released. Use table buffering to avoid this problem.</p>
<h3>Using Data Sessions</h3>
<p>
To ensure that each user in a shared environment has a secure, exact duplicate of the working environment, and to ensure that multiple instances of a form can operate independently, Visual FoxPro provides data sessions.</p>
<p>
A data session is a representation of the current dynamic work environment. You might think of a data session as a miniature data environment running inside one open Visual FoxPro session on one machine. Each data session contains:</p>
<ul type=disc>
<li>
A copy of the items in the form’s data environment.</li>
<li>
Cursors representing the open tables, their indexes, and relationships.</li>
</ul>
<p>
The concept of a data session is easily understood when you consider what happens when you open the same form simultaneously from separate workstations in a multi-user application. In this case, each workstation is running a separate Visual FoxPro session, and therefore has its own set of work areas: cursors representing open base tables, indexes, and relationships.</p>
<p>
However, if you open multiple instances of the same form in a single project, on one machine, within the same Visual FoxPro session, the forms share the Default data session, representing a single dynamic work environment. Each instance of the open form open in the same Visual FoxPro session uses the same set of work areas, and actions in one instance of a form that move the record pointer in a work area automatically affect other instances of the same form.</p>
<h4>Using Private Data Sessions</h4>
<p>
If you want to have more control over multiple instances of form, you can implement Private data sessions. When your form uses private data sessions, Visual FoxPro creates a new data session for each instance of the Form, FormSet, or Toolbar control your application creates. Each private data session contains:</p>
<ul type=disc>
<li>
A separate copy of each table, index, and relationship in the form’s data environment.</li>
<li>
An unlimited number of work areas.</li>
<li>
Record pointers for each copy of each table that are independent from the base tables for the form.</li>
</ul>
<p>
The number of available data sessions is limited only by available system memory and disk space.</p>
<p>
You implement private data sessions by setting the DataSession property for the form. The DataSession property has two settings:</p>
<ul type=disc>
<li>
1 – Default data session (the default setting).</li>
<li>
2 – Private data session.</li>
</ul>
<p>
By default, the DataSession property of a form is set to 1.</p>
<p class=label>
<b>To enable private data sessions</b></p>
<p>
Choose one of the following options:
<ul type=disc>
<li>
In the <a href="wndform_designer.htm">Form Designer</a>, set the DataSession property of the form to <b>2 – Private data session</b>.<p class=tl>
-or-</P></li>
<li>
In code, set the <a href="lngdatasession_property.htm">DataSession</a> property to 2.<p class=tl>
For example, type:</P><pre><code>frmFormName.DataSession = 2
</code></pre>
<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can only set the DataSession property at design time. The DataSession property is read-only at run time.</p></li>
</ul>
<p>
When a form uses private data sessions, each instance of a form open on a single machine in a single Visual FoxPro session uses its own data environment. Using private data sessions is similar to running the same form simultaneously from separate workstations.</p>
<p class=label>
<b>Equivalent multiple data sessions</b></p>
<p>
<img src="afd17006.gif" border=0></p>
<h4>Identifying Data Sessions</h4>
<p>
Each private data session is identified separately. You can see the contents of each data session in the <a href="wnddata_session_window.htm">Data Session</a> window. You can also change the data session description through commands in the Load event code.</p>
<p>
You can view the identification number for each data session by using the <a href="lngdatasessionid_property.htm">DataSessionID</a> run-time property. The following example displays the DataSessionID property of a form named <code>frmMyForm</code>:</p>
<pre><code>DO FORM frmMyForm
? frmMyForm.DataSessionID
</code></pre>
<p>
If you activate the form using the NAME clause, you can use the form’s name to access the DataSessionID property, as in the following code:</p>
<pre><code>DO FORM MyForm NAME one
? one.DataSessionID
</code></pre>
<p>
The DataSessionID property is designed only to identify a particular data session. Avoid changing the DataSessionID of a form instance because data-bound controls lose their data sources when you change the DataSessionID.</p>
<h4>Updating Data Using Multiple Form Instances</h4>
<p>
While private data sessions generate separate work areas containing separate copies of a form’s open tables, indexes, and relationships, every copy of the form references the same underlying base tables and base index files. When a user updates a record from one instance of a form, the base table referenced by the form is updated. You see the changes made from another instance of the form when you navigate to the changed record.</p>
<p>
Locks taken on records or tables in one private data session are respected by other private data sessions. For example, if the user of data session 1 takes a lock on a record, the user in data session 2 cannot lock the record. If the user in session 1 opens a table exclusively, the user in data session 2 cannot open the table. By respecting locks taken by other data sessions, Visual FoxPro protects the integrity of updates to the underlying base tables.</p>
<h4>Customizing the Environment of a Data Session</h4>
<p>
Because data sessions control the scope of certain SET commands, you can use private data sessions to establish custom SET command settings within a single session of Visual FoxPro.</p>
<p>
For example, the <a href="lngset_exact.htm">SET EXACT</a> command, which controls the rules used when comparing character strings of different lengths, is scoped to the current data session. The default setting for SET EXACT is off which specifies that, to be equivalent, expressions must match, character for character, until the end of the expressions on the right side is reached. You might want to enable “fuzzy” or equivalent searches by leaving SET EXACT set to OFF for the default data session; however, your application might contain a specific form that requires exact matches. You could set the DataSession property for the form requiring exact matches to 2, to enable private data sessions, and then SET EXACT to ON for that form. By issuing a SET command only for the form using private data sessions, you preserve the global Visual FoxPro session settings while enabling customized session settings for a specific form.</p>
<h4>Overriding Automatic Private Data Session Assignment</h4>
<p>
When private data sessions for a form are in use, changes you make to data in one form are not automatically represented in other instances of the same form. If you want all instances of a form to access the same data and to immediately reflect changes to common data, you can override automatic data session assignment.</p>
<p class=label>
<b>To override automatic data session assignment</b>
<ul type=disc>
<li>
Use one of these commands:<pre><a href="lngset_datasession.htm"><code>SET DATASESSION</code></a><code> TO 1
</code></pre>
<p class=tl>
-or-</P><pre><a href="lngset_datasession.htm"><code>SET DATASESSION</code></a><code> TO
</code></pre>
</li>
</ul>
<p>
Both commands enable the default data session to be controlled by the Command window and the Project Manager.</p>
<h3>Buffering Data</h3>
<p>
If you want to protect data during updates, use buffers. Visual FoxPro record and table buffering help you protect data update and data maintenance operations on single records and on multiple records of data in multi-user environments. Buffers can automatically test, lock, and release records or tables.</p>
<p>
With buffering, you can easily detect and resolve conflicts in data update operations: the current record is copied to a memory or disk location managed by Visual FoxPro. Other users can then still access the original record simultaneously. When you move from the record or try to update the record programmatically, Visual FoxPro attempts to lock the record, verify that no other changes have been made by other users, and then writes the edits. After you attempt to update data, you must also resolve conflicts that prevent the edits from being written to the original table.</p>
<h4>Choosing a Buffering Method</h4>
<p>
Before you enable buffering, evaluate the data environment to choose the buffering method and locking options that best suit the editing needs of your application, the record and table types and sizes, how the information is used and updated, and other factors. Once you enable buffering, it remains in effect until you disable buffering or close the table.</p>
<p>
Visual FoxPro has two types of buffering: record and table.</p>
<p class=label>
<b>Visual FoxPro record and table buffering</b></p>
<p>
<img src="afd17007.gif" border=0></p>
<ul type=disc>
<li>
To access, modify, and write a single record at a time, choose record buffering.<p class=tl>
Record buffering provides appropriate process validation with minimal impact on the data update operations of other users in a multi-user environment.</P></li>
<li>
To buffer the updates to several records, choose table buffering.<p class=tl>
Table buffering provides the most effective way to handle several records in one table or child records in a one-to-many relationship.</P></li>
<li>
To provide maximum protection for existing data, use Visual FoxPro transactions.<p class=tl>
You can use transactions alone, but you gain additional effectiveness by using transactions as wrappers for record or table buffering commands. For more details, see the section, <a href="#dgmanaging_updates_with_transactions">Managing Updates with Transactions</a>, later in this chapter.</P></li>
</ul>
<h4>Choosing a Locking Mode</h4>
<p>
Visual FoxPro provides buffering in two locking modes: pessimistic and optimistic. These choices determine when one or more records are locked, and how and when they're released.</p>
<h4>Pessimistic Buffering</h4>
<p>
Pessimistic buffering prevents other users in a multi-user environment from accessing a particular record or table while you're making changes to it. A pessimistic lock provides the most secure environment for changing individual records but it can slow user operations. This buffering mode is most similar to the standard locking mechanism in previous versions of FoxPro, with the added benefit of built-in data buffering.</p>
<h4>Optimistic Buffering</h4>
<p>
Optimistic buffering is an efficient way to update records because locks are only taken at the time the record is written, thus minimizing the time any single user monopolizes the system in a multi-user environment. When you use record or table buffering on views, Visual FoxPro imposes optimistic locking.</p>
<p>
The value of the Buffering property, set with the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function, determines the buffering and locking methods.</p>
<p>
The following table summarizes valid values for the Buffering property.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=66%><b>To enable</b></td>
<td class=label width=34%><b>Use this value</b></td>
</tr>
<tr valign=top>
<td width=66%>No buffering. The default value.</td>
<td width=34%>1</td>
</tr>
<tr valign=top>
<td width=66%>Pessimistic record locks which lock record now, update when pointer moves or upon <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a>.</td>
<td width=34%>2</td>
</tr>
<tr valign=top>
<td width=66%>Optimistic record locks which wait until pointer moves, and then lock and update.</td>
<td width=34%>3</td>
</tr>
<tr valign=top>
<td width=66%>Pessimistic table locks which lock record now, update later upon TABLEUPDATE(&nbsp;).</td>
<td width=34%>4</td>
</tr>
<tr valign=top>
<td width=66%>Optimistic table lock which wait until TABLEUPDATE(&nbsp;), and then lock and update edited records.</td>
<td width=34%>5</td>
</tr>
</table><br>
<p>
The default value for Buffering is 1 for tables and 3 for views. If you use buffering to access remote data, the Buffering property is either 3, optimistic row buffering, or 5, optimistic table buffering. For more information on accessing data in remote tables, see Chapter 6, <a href="ugquerying_and_updating_multiple_tables.htm">Querying and Updating Multiple Tables</a>, in the <i>User’s Guide</i>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Set MULTILOCKS to ON for all buffering modes above 1.</p>
<h4>Enabling Record Buffering</h4>
<p>
Enable record buffering with the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function.</p>
<p class=label>
<b>To enable pessimistic record locking in the current work area</b>
<ul type=disc>
<li>
Use this function and value:<pre><code>CURSORSETPROP("Buffering", 2)
</code></pre>
</li>
</ul>
<p>
Visual FoxPro attempts to lock the record at the pointer location. If the lock is successful, Visual FoxPro places the record in a buffer and permits editing. When you move the record pointer or issue a <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> command, Visual FoxPro writes the buffered record to the original table.</p>
<p class=label>
<b>To enable optimistic record locking in the current work area</b>
<ul type=disc>
<li>
Use this function and value:<pre><code>CURSORSETPROP("Buffering", 3) 
</code></pre>
</li>
</ul>
<p>
Visual FoxPro writes the record at the location of the pointer to a buffer and permits edits. When you move the record pointer or issue a <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> command, Visual FoxPro attempts a lock on the record. If the lock is successful, Visual FoxPro compares the current value of the record on the disk with the original buffer value. If these values are the same, the edits are written to the original table; if these values are different, Visual FoxPro generates an error.</p>
<h4>Enabling Table Buffering</h4>
<p>
Enable table buffering with the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function.</p>
<p class=label>
<b>To enable pessimistic locking of multiple records in the current work area</b>
<ul type=disc>
<li>
Use this function and value:<pre><code>CURSORSETPROP("Buffering", 4) 
</code></pre>
</li>
</ul>
<p>
Visual FoxPro attempts to lock the record at the pointer location. If the lock is successful, Visual FoxPro places the record in a buffer and permits editing. Use the <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> command to write the buffered records to the original table.</p>
<p class=label>
<b>To enable optimistic locking of multiple records in the current work area</b>
<ul type=disc>
<li>
Use this function and value:<pre><code>CURSORSETPROP("Buffering", 5)
</code></pre>
</li>
</ul>
<p>
Visual FoxPro writes the records to a buffer and permits edits until you issue a <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> command. Visual FoxPro then performs the following sequence on each record in the buffer:</p>
<ul type=disc>
<li>
Attempts a lock on each edited record.</li>
<li>
Upon a successful lock, compares the current value of each record on the disk with the original buffer value.</li>
<li>
Writes the edits to the original table if the comparison shows the values to be the same.</li>
<li>
Generates an error if the values differ.</li>
</ul>
<p>
When table buffering is enabled, Visual FoxPro attempts updates only after a TABLEUPDATE(&nbsp;) command.</p>
<h4>Appending and Deleting Records in Table Buffers</h4>
<p>
You can append and delete records while table buffering is enabled: appended records are added to the end of the buffer. To access all records in the buffer, including appended records, use the <a href="lngrecnolp_rp.htm">RECNO(&nbsp;)</a> function. The RECNO(&nbsp;) function returns sequential negative numbers on records you append to a table buffer. For instance, if you initiate table buffering, edit records 7, 8, and 9, and then append three records, the buffer will contain RECNO(&nbsp;) values of 7, 8, 9, – 1, – 2, and – 3.</p>
<p class=label>
<b>Buffer after editing and appending records</b></p>
<p>
<img src="afd17008.gif" border=0></p>
<p>
You can remove appended records from the buffer only by using the <a href="lngtablerevertlp_rp.htm">TABLEREVERT(&nbsp;)</a> command. For any appended record, both TABLEUPDATE(&nbsp;) and TABLEREVERT(&nbsp;) delete the negative RECNO(&nbsp;) value for that record while maintaining the sequence.</p>
<p class=label>
<b>Buffer after editing, deleting an appended record, and appending another</b></p>
<p>
<img src="afd17009.gif" border=0></p>
<p>
While using a table buffer, you can use the GO command with the negative RECNO(&nbsp;) value to access a specific appended record. For instance, using the previous example, you can type:</p>
<pre><code>GO 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; moves to the 1st buffered record
GO -3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; moves to the 6th buffered record (3rd appended)
</code></pre>
<p class=label>
<b>To append records to a table buffer</b>
<ul type=disc>
<li>
Use the <a href="lngappend.htm">APPEND</a> or <a href="lngappend.htm">APPEND</a> BLANK command after you enable table buffering.</li>
</ul>
<p>
Appended records have sequential ascending negative RECNO(&nbsp;) numbers.</p>
<p class=label>
<b>To remove an appended record from a table buffer</b>
<ol>
<li>
Use the <a href="lnggoslgoto.htm">GO</a> command with a negative value to position the record pointer at the record to be deleted.<br><br></li>
<li>
Use the <a href="lngdelete.htm">DELETE</a> command to mark the record for deletion.<br><br></li>
<li>
Use the <a href="lngtablerevertlp_rp.htm">TABLEREVERT(&nbsp;)</a> function to remove the record from the buffer.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The TABLEREVERT(&nbsp;) function also affects the status of deleted and changed rows.</p></li>
</ol>
<p class=label>
<b>To remove all appended records from a table buffer</b>
<ul type=disc>
<li>
Use the <a href="lngtablerevertlp_rp.htm">TABLEREVERT(&nbsp;)</a> function with a value of true (.T.).</li>
</ul>
<p>
TABLEREVERT(&nbsp;) removes appended records from a table buffer without writing the records to the table. TABLEUPDATE(&nbsp;) writes all current buffered records to a table, even if they’ve been marked for deletion.</p>

<h2><a name="dgupdating_data"></a>Updating Data</h2>
<p>
To update data, you can use buffers, transactions, or views.</p>
<h3>Performing Updates with Buffers</h3>
<p>
After choosing the buffering method and the type of locking, you can enable record or table buffering.</p>
<p class=label>
<b>To enable buffering</b></p>
<p>
Choose one of the following options:
<ul type=disc>
<li>
In the <b>Form Designer</b>, set the BufferModeOverride property of the cursor in the data environment of the form.<p class=tl>
-or-</P></li>
<li>
In code, set the Buffering property.<p class=tl>
For example, you can enable pessimistic row buffering by placing the following code in the Init procedure of a form:</P><pre><code>CURSORSETPROP('Buffering', 2)
</code></pre>
</li>
</ul>
<p>
You then place code for the update operations in the appropriate method code for your controls.</p>
<p>
To write edits to the original table, use <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a>. To cancel edits after a failed update operation in a table constrained by rules, use <a href="lngtablerevertlp_rp.htm">TABLEREVERT(&nbsp;)</a>. TABLEREVERT(&nbsp;) is valid even if explicit table buffering isn’t enabled.</p>
<p>
The following sample demonstrates how to update records when pessimistic record buffering is enabled.</p>
<p class=label>
<b>Example of Updating Using Record and Table Buffers </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Code</b></td>
<td class=label width=35%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>OPEN DATABASE testdata
USE customers
CURSORSETPROP('Buffering', 2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></pre>
</td>
<td width=35%>In the form Init code, open the table and enable pessimistic record buffering.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>lModified = .F.
FOR nFieldNum = 1 TO FCOUNT()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; IF GETFLDSTATE(nFieldNum) = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; lModified = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; EXIT
 &nbsp; ENDIF
ENDFOR</code></pre>
</td>
<td width=35%><br>
Go through fields, checking for any field that's been modified.<p>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This code might be in the Click event of a “Save” or “Update” command button.</p>
</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>IF lModified
 &nbsp; nResult = MESSAGEBOX;
 &nbsp;&nbsp;&nbsp;&nbsp; ("Record has been modified. Save?", ;
 &nbsp;&nbsp;&nbsp;&nbsp; 4+32+256, "Data Change")</code></pre>
</td>
<td width=35%>Locate the next modified record. </td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;IF nResult = 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; TABLEREVERT (.F.)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ENDIF
ENDIF</code></pre>
</td>
<td width=35%>Present the current value and give the user the option to revert the change to the current field.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>SKIP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
IF EOF()
 &nbsp; MESSAGEBOX( "already at bottom")
 &nbsp; SKIP -1
ENDIF 
THISFORM.Refresh</code></pre>
</td>
<td width=35%><br>
<br>
<br>
SKIP guarantees that the last change is written.</td>
</tr>
</table><br>

<h3><a name="dgmanaging_updates_with_transactions"></a>Managing Updates with Transactions</h3>
<p>
Even with buffering, things can go wrong. If you want to protect update operations and recover from an entire section of code as a unit, use transactions.</p>
<p>
Adding transactions to your application provides protection beyond Visual FoxPro record and table buffering by placing an entire section of code in a protected, recoverable unit. You can nest transactions and use them to protect buffered updates. Visual FoxPro transactions are available only with tables and views contained in a database.</p>
<h4>Wrapping Code Segments</h4>
<p>
A transaction acts as a wrapper that caches data update operations to memory or to disk, rather than applying those updates directly to the database. The actual database update is performed at the end of the transaction. If for any reason the system cannot perform the update operations on the database, you can roll back the entire transaction and no update operations are performed.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Buffered update operations made outside a transaction are ignored within a transaction in the same data session.</p>
<h4>Commands that Control Transactions</h4>
<p>
Visual FoxPro provides three commands and one function to manage a transaction.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>To</b></td>
<td class=label width=35%><b>Use</b></td>
</tr>
<tr valign=top>
<td width=65%>Initiate a transaction</td>
<td width=35%><a href="lngbegin_transaction.htm">BEGIN TRANSACTION</a></td>
</tr>
<tr valign=top>
<td width=65%>Determine the current transaction level</td>
<td width=35%><a href="lngtxnlevellp_rp.htm">TXNLEVEL(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=65%>Reverse all changes made since the most recent BEGIN TRANSACTION statement</td>
<td width=35%><a href="lngrollback.htm">ROLLBACK</a></td>
</tr>
<tr valign=top>
<td width=65%>Lock records, commit to disk all changes made to the tables in the database since the most recent BEGIN TRANSACTION, and then unlock the records</td>
<td width=35%><a href="lngend_transaction.htm">END TRANSACTION</a></td>
</tr>
</table><br>
<p>
You can use transactions to wrap modifications to tables, structural .cdx files, and memo files associated with tables within a database. Operations involving variables and other objects don't respect transactions; therefore, you cannot roll back or commit such operations.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When using data stored in remote tables, transaction commands control only updates to the data in the local copy of the view cursor; updates to remote base tables are not affected. To enable manual transactions on remote tables use <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a>, and then control the transaction with <a href="lngsqlcommitlp_rp.htm">SQLCOMMIT(&nbsp;)</a> and <a href="lngsqlrollbacklp_rp.htm">SQLROLLBACK(&nbsp;)</a>.</p>
<p>
In general, you should use transactions with record buffers rather than with table buffering, except to wrap TABLEUPDATE(&nbsp;) calls. If you place a <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> command in a transaction, you can roll back a failed update, address the reason for the failure, and then retry the TABLEUPDATE(&nbsp;) without losing data. This ensures the update happens as an “all-or-nothing” operation.</p>
<p>
Though simple transaction processing provides safe data update operations in normal situations, it doesn’t provide total protection against system failures. If power fails or some other system interruption occurs during processing of the <a href="lngend_transaction.htm">END TRANSACTION</a> command, the data update can still fail.</p>
<p>
Use the following code template for transactions:</p>
<pre><code>BEGIN TRANSACTION&nbsp;&nbsp; 
* Update records
IF lSuccess = .F. &amp;&amp; an error occurs
 &nbsp; ROLLBACK
ELSE &amp;&amp; commit the changes
 &nbsp; * Validate the data
 &nbsp; IF &amp;&amp; error occurs
 &nbsp;&nbsp;&nbsp;&nbsp; ROLLBACK
 &nbsp; ELSE 
 &nbsp;&nbsp;&nbsp;&nbsp; END TRANSACTION
 &nbsp; ENDIF
ENDIF
</code></pre>
<h4>Using Transactions</h4>
<p>
The following rules apply to transactions:</p>
<ul type=disc>
<li>
A transaction starts with the <a href="lngbegin_transaction.htm">BEGIN TRANSACTION</a> command and ends with the <a href="lngend_transaction.htm">END TRANSACTION</a> or <a href="lngrollback.htm">ROLLBACK</a> command. An END TRANSACTION statement without a preceding BEGIN TRANSACTION statement generates an error.</li>
<li>
A ROLLBACK statement without a preceding BEGIN TRANSACTION statement generates an error.</li>
<li>
A transaction, once begun, remains in effect until the corresponding END TRANSACTION begins (or until a ROLLBACK command is issued), even across programs and functions, unless the application terminates, which causes a rollback.</li>
<li>
Visual FoxPro uses data cached in the transaction buffer before using disk data for queries on the data involved in transactions. This ensures that the most current data is used.</li>
<li>
If the application terminates during a transaction, all operations roll back.</li>
<li>
A transaction works only in a database container.</li>
<li>
You cannot use the <a href="lngindex.htm">INDEX</a> command if it overwrites an existing index file, or if any .cdx index file is open.</li>
<li>
Transactions are scoped to data sessions.</li>
</ul>
<p>
Transactions exhibit the following locking behaviors:</p>
<ul type=disc>
<li>
Within a transaction, Visual FoxPro imposes a lock at the time a command directly or indirectly calls for it. Any system or user direct or indirect unlock commands are cached until the completion of the transaction by ROLLBACK or END TRANSACTION commands.</li>
<li>
If you use a locking command such as <a href="lngflocklp_rp.htm">FLOCK(&nbsp;)</a> or <a href="lngrlocklp_rp.htm">RLOCK(&nbsp;)</a> within a transaction, the END TRANSACTION statement will not release the lock. In that case, you must explicitly unlock any locks explicitly taken within a transaction. You should also keep transactions containing the FLOCK(&nbsp;) or RLOCK(&nbsp;) commands as brief as possible; otherwise, users could be locked out of records for a long time.</li>
</ul>
<h4>Nesting Transactions</h4>
<p>
Nested transactions provide logical groups of table update operations that are insulated from concurrent processes. BEGIN TRANSACTION...END TRANSACTION pairs need not be in the same function or procedure. The following rules apply to nested transactions:</p>
<ul type=disc>
<li>
You can nest up to five <a href="lngbegin_transaction.htm">BEGIN TRANSACTION</a>...<a href="lngend_transaction.htm">END TRANSACTION</a> pairs.</li>
<li>
Updates made in a nested transaction aren't committed until the outermost END TRANSACTION is called.</li>
<li>
In nested transactions, an END TRANSACTION only operates on the transaction initiated by the last issued BEGIN TRANSACTION.</li>
<li>
In nested transactions, a <a href="lngrollback.htm">ROLLBACK</a> statement only operates on the transaction initiated by the last issued BEGIN TRANSACTION.</li>
<li>
The innermost update in a set of nested transactions on the same data has precedence over all others in the same block of nested transactions.</li>
</ul>
<p>
Notice in the following example that because changes in a nested transaction aren't written to disk but to the transaction buffer, the inner transaction will overwrite the changes made to the same STATUS fields in the earlier transaction:</p>
<pre><code>BEGIN TRANSACTION &amp;&amp;  transaction 1
 &nbsp; UPDATE EMPLOYEE ; &amp;&amp;  first change
 &nbsp;&nbsp;&nbsp;&nbsp; SET STATUS = "Contract" ;
 &nbsp;&nbsp;&nbsp;&nbsp; WHERE EMPID BETWEEN 9001 AND 10000
 &nbsp; BEGIN TRANSACTION &amp;&amp;  transaction 2
 &nbsp;&nbsp;&nbsp;&nbsp; UPDATE EMPLOYEE ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET STATUS = "Exempt" ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE HIREDATE &gt; {^1998-01-01}&nbsp; &amp;&amp;  overwrites
 &nbsp; END TRANSACTION &amp;&amp;  transaction 2
END TRANSACTION&nbsp;&nbsp;&nbsp; &amp;&amp;  transaction 1
</code></pre>
<p>
The following nested transaction example deletes a customer record and all its related invoices. The transaction will roll back if errors occur during a <a href="lngdelete.htm">DELETE</a> command. This example demonstrates grouping table update operations to protect updates from partial completion and to avoid concurrency conflicts.</p>
<p class=label>
<b>Example of Modifying Records in Nested Transactions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Code</b></td>
<td class=label width=35%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>DO WHILE TXNLEVEL(&nbsp;) &gt; 0
 &nbsp; ROLLBACK
ENDDO</code></pre>
</td>
<td width=35%>Cleanup from other transactions.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>CLOSE ALL
SET MULTILOCKS ON
SET EXCLUSIVE OFF</code></pre>
</td>
<td width=35%>Establish environment for buffering.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>OPEN DATABASE test
USE mrgtest1
CURSORSETPROP('buffering',5)
GO TOP</code></pre>
</td>
<td width=35%><br>
<br>
Enable optimistic table buffering.<br>
</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>REPLACE fld1 WITH "changed"
SKIP
REPLACE fld1 WITH "another change"
MESSAGEBOX("modify first field of both" + ;
 &nbsp; "records on another machine")</code></pre>
</td>
<td width=35%>Change a record.<br>
<br>
Change another record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>BEGIN TRANSACTION
lSuccess = TABLEUPDATE(.T.,.F.)</code></pre>
</td>
<td width=35%>Start transaction 1 and try to update all modified records without force.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>IF lSuccess = .F.
 &nbsp; ROLLBACK
 &nbsp; AERROR(aErrors)
 &nbsp; DO CASE 
 &nbsp; CASE aErrors[1,1] = 1539&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ...
 &nbsp; CASE aErrors[1,1] = 1581&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ...
 &nbsp; CASE aErrors[1,1] = 1582&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></pre>
</td>
<td width=35%>If the update failed, roll back the transaction.<br>
Get the error from AERROR(&nbsp;).<br>
Determine the cause of the failure.<br>
If a trigger failed, handle it.<br>
<br>
If a field doesn’t accept null values, handle it.<br>
If a field rule was violated, handle it.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 1585&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; nNextModified = getnextmodified(0)
 &nbsp;&nbsp;&nbsp;&nbsp; DO WHILE nNextModified &lt;&gt; 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO nNextModified
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RLOCK()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FOR nField = 1 to FCOUNT()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cField = FIELD(nField)


 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if OLDVAL(cField) &lt;&gt; CURVAL(cField)</code></pre>
</td>
<td width=35%>If a record was changed by another user, locate the first modified record.<br>
Loop through all modified records, starting with the first record.<br>
Lock each record to guarantee that you can update.<br>
Check each field for any changes.<br>
<br>
Check the buffered value against the value on disk, and then present a dialog box to the user.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nResult = MESSAGEBOX;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Data was changed " + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "by another user—keep"+ ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "changes?", 4+48, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Modified Record")</code></pre>
</td>
<td width=35%></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF nResult = 7
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TABLEREVERT(.F.)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNLOCK record nNextModified
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</code></pre>
</td>
<td width=35%>If user responded “No,” revert the one record and unlock it.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXIT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDFOR</code></pre>
</td>
<td width=35%>Break out of the “FOR nField...” loop.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDDO</code></pre>
</td>
<td width=35%>Get the next modified record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BEGIN TRANSACTION
 &nbsp;&nbsp;&nbsp;&nbsp; TABLEUPDATE(.T.,.T.)
 &nbsp;&nbsp;&nbsp;&nbsp; END TRANSACTION
 &nbsp;&nbsp;&nbsp;&nbsp; UNLOCK</code></pre>
</td>
<td width=35%>Start transaction 2 and update all non-reverted records with force.<br>
End transaction 2.<br>
Release the lock.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 109&nbsp;&nbsp; 
 &nbsp; ...
 &nbsp; CASE aErrors[1,1] = 1583&nbsp;&nbsp;&nbsp; 
 &nbsp; ...
 &nbsp; CASE aErrors[1,1] = 1884&nbsp;&nbsp;&nbsp; 
 &nbsp; ...
 &nbsp; OTHERWISE
 &nbsp;&nbsp;&nbsp;&nbsp; MESSAGEBOX( "Unknown error "+;
 &nbsp;&nbsp;&nbsp;&nbsp; "message: " + STR(aErrors[1,1]))
 &nbsp; ENDCASE</code></pre>
</td>
<td width=35%>If the record is in use by another user, handle it.<br>
<br>
If a row rule was violated, handle it.<br>
<br>
If there was a unique index violation, handle it.<br>
<br>
Otherwise, present a dialog box to the user.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>ELSE
 &nbsp; END TRANSACTION
ENDIF</code></pre>
</td>
<td width=35%><br>
End transaction 1.</td>
</tr>
</table><br>
<h4>Protecting Remote Updates</h4>
<p>
Transactions can protect you from system-generated errors during data updates on remote tables. The following example uses a transaction to wrap data-writing operations to a remote table.</p>
<p class=label>
<b>Example of a Transaction on a Remote Table</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Code</b></td>
<td class=label width=35%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>hConnect = CURSORGETPROP('connecthandle')
SQLSETPROP(hConnect, 'transmode',
DB_TRANSMANUAL)</code></pre>
</td>
<td width=35%>Get the connect handle <br>
and enable manual transactions.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>BEGIN TRANSACTION</code></pre>
</td>
<td width=35%>Begin the manual transaction.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>lSuccess = TABLEUPDATE(.T.,.F.)
IF lSuccess = .F.
 &nbsp; SQLROLLBACK (hConnect)
 &nbsp; ROLLBACK</code></pre>
</td>
<td width=35%>Try to update all records without force.<br>
If the update failed,<br>
roll back the transaction on <br>
the connection for the cursor.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;AERROR(aErrors)
 &nbsp; DO CASE </code></pre>
</td>
<td width=35%>Get the error from AERROR(&nbsp;).</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 1539&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ...</code></pre>
</td>
<td width=35%>If a trigger failed, handle it.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 1581&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ...</code></pre>
</td>
<td width=35%>If a field doesn’t accept null values, handle it.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 1582&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ...</code></pre>
</td>
<td width=35%>If a field rule was violated, handle it.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 1585&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; nNextModified = GETNEXTMODIFIED(0)
 &nbsp;&nbsp;&nbsp;&nbsp; DO WHILE nNextModified &lt;&gt; 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO nNextModified</code></pre>
</td>
<td width=35%>If a record was changed by another user, handle it.<br>
<br>
Loop through all modified records, starting with the first record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FOR nField = 1 to FCOUNT()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cField = FIELD(nField)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF OLDVAL(cField) &lt;&gt; CURVAL(cField)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nResult = MESSAGEBOX;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Data has been changed ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by another user. ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Keep changes?",4+48,;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Modified Record")</code></pre>
</td>
<td width=35%>Check each field for any changes.<br>
<br>
Check the buffered value <br>
against the value on disk, and then present a dialog box to the user.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF nResult = 7
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TABLEREVERT(.F.)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDFOR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nNextModified = ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GETNEXTMODIFIED(nNextModified)
 &nbsp;&nbsp;&nbsp;&nbsp; ENDDO</code></pre>
</td>
<td width=35%>If user responded “No,”<br>
revert the one record.<br>
<br>
Break out of the “FOR nField...” loop.<br>
<br>
<br>
Get the next modified record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TABLEUPDATE(.T.,.T.)
 &nbsp;&nbsp;&nbsp;&nbsp; SQLCOMMIT(hConnect)</code></pre>
</td>
<td width=35%>Update all non-reverted records with force and issue a commit.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 109
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Handle the error</code></pre>
</td>
<td width=35%>Error 109 indicates that the record is in use by another user.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 1583
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Handle the error</code></pre>
</td>
<td width=35%>Error 1583 indicates that a row rule was violated.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE aErrors[1,1] = 1884
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Handle the error</code></pre>
</td>
<td width=35%>Error 1884 indicates that the uniqueness of the index was violated.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;OTHERWISE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Handle generic errors.</code></pre>
</td>
<td width=35%></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MESSAGEBOX("Unknown error message:" ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + STR(aErrors[1,1]))
 &nbsp; ENDCASE</code></pre>
</td>
<td width=35%>Present a dialog box to the user.<br>
<br>
End of error handling.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>ELSE
 &nbsp; SQLCOMMIT(hConnect)
 &nbsp; END TRANSACTION
ENDIF</code></pre>
</td>
<td width=35%><br>
If all errors were handled and the entire transaction was successful, issue a commit and end the transaction.</td>
</tr>
</table><br>
<h4>Managing Performance</h4>
<p>
Once you have a working multi-user application, you can use the following suggestions to improve performance:</p>
<ul type=disc>
<li>
Place temporary files on a local drive.</li>
<li>
Choose between sorting and indexing files.</li>
<li>
Schedule exclusive access to files.</li>
<li>
Time the locking of files.</li>
</ul>
<h4>Place Temporary Files on a Local Drive</h4>
<p>
Visual FoxPro creates its temporary files in the Windows default Temp directory. Text editing sessions can also temporarily create a backup copy of the file being edited (a .bak file).</p>
<p>
If local workstations have hard drives with plenty of free space, you can improve performance by placing these temporary work files on the local drive or in a RAM drive. Redirecting these files to a local drive or a RAM drive increases performance by reducing access to the network drive.</p>
<p>
You can specify an alternate location for these files by including the EDITWORK, SORTWORK, PROGWORK and TMPFILES statements in your Config.fpw configuration file. For more information about managing files, see Chapter 4, <a href="igoptimizing_your_system.htm">Optimizing Your System</a>, in the <i>Installation Guide</i>.</p>
<h4>Choose between Sorting and Indexing Files</h4>
<p>
When the data contained in a table is relatively static, processing sorted tables sequentially without an order set improves performance. This doesn't mean that sorted tables cannot or should not take advantage of index files — the <a href="lngseek.htm">SEEK</a> command, which requires an index, is incomparable for locating records quickly. However, once you locate a record with SEEK, you can turn ordering off.</p>
<h4>Schedule Exclusive Access to Files</h4>
<p>
Commands that run when no other users require access to the data, such as overnight updates, can benefit by opening the data files for exclusive use. When files are open for exclusive use, performance improves because Visual FoxPro doesn't need to test the status of record or file locks.</p>
<h4>Time the Locking of Files</h4>
<p>
To reduce contention between users for write access to a table or record, shorten the amount of time a record or table is locked. You can do this by locking the record only after it's edited rather than during editing. Optimistic row buffering gives you the shortest lock time.</p>
<p>
For more information on improving performance, see Chapter 4, <a href="igoptimizing_your_system.htm">Optimizing Your System</a>, in the <i>Installation Guide.</i> You can also find information on improving performance in your client/server applications in Chapter 22, <a href="dgoptimizing_client_server_performance.htm">Optimizing Client/Server Performance</a>.</p>
<h3>Managing Updates with Views </h3>
<p>
You can use the update conflict management technology built into Visual FoxPro views to handle multi-user access to data. Views control what is sent to the base tables underlying the view by using the WhereType property. You can set this property for both local and remote views. The WhereType property provides four settings:</p>
<ul type=disc>
<li>
DB_KEY</li>
<li>
DB_KEYANDUPDATABLE</li>
<li>
DB_KEYANDMODIFIED (the default)</li>
<li>
DB_KEYANDTIMESTAMP</li>
</ul>
<p>
By choosing one of these four settings, you control how Visual FoxPro builds the WHERE clause for the SQL Update statement sent to the view’s base tables. You can choose the setting you want using the <a href="cmdquery_and_view_designers_update_criteria_tab.htm">Update Criteria</a> tab of the View Designer, or you can use <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> to set the WhereType for a view definition. To change the WhereType setting for an active view cursor, use <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a>.</p>
<p>
For example, suppose you have a simple remote view based on the Customer table that includes seven fields: <code>cust_id</code>, <code>company</code>, <code>phone</code>, <code>fax</code>, <code>contact</code>, <code>title</code>, and <code>timestamp</code>. The primary key for your view is <code>cust_id</code>.</p>
<p class=label>
<b>The Update Criteria tab displays the updatable fields in your view.</b></p>
<p>
<img src="afd17010.gif" border=0></p>
<p>
You've made only two fields updatable: <code>contact_name</code> and <code>contact_title</code>. You want the user to be able to change the company contact and their title from the view. However, if other facts about the company change, such as the company address, you want the changes to go through a coordinator who’ll identify the impact of the changes on your company, such as whether the sales region for the customer will change. Now that your view has been set up to send updates, you can choose the WhereType according to your preferences.</p>
<p>
Now suppose that you change the name in the <code>contact</code> field for a customer, but you don’t change the value in the other updatable field, <code>title</code>. Given this example, the following section discusses how the WhereType setting would impact the WHERE clause that Visual FoxPro builds to send the new contact name to the base tables.</p>
<h4>Comparing the Key Field Only</h4>
<p>
The least restrictive update uses the DB_KEY setting. The WHERE Clause used to update remote tables consists of only the primary key field specified with the KeyField or KeyFieldList property. Unless the value in the primary key field has been changed or deleted in the base table since you retrieved the record, the update goes through.</p>
<p>
In the case of the previous example, Visual FoxPro would prepare an update statement with a WHERE clause that compares the value in the <code>cust_id</code> field against the <code>cust_id</code> field in the base table row:</p>
<pre><code>WHERE OLDVAL(customer.cust_id) = CURVAL(customer_remote_view.cust_id)
</code></pre>
<p>
When the update statement is sent to the base table, only the base table’s key field is verified.</p>
<p class=label>
<b>The key field in your view is compared against its base table counterpart.</b></p>
<p>
<img src="afd17001.gif" border=0></p>
<h4>Comparing the Key Field and Fields Modified in the View</h4>
<p>
The DB_KEYANDMODIFIED setting, the default, is slightly more restrictive than DB_KEY. DB_KEYANDMODIFIED compares only the key field and any updatable fields you’ve modified in the view against their base table counterparts. If you modify a field in the view, but the field isn’t updatable, the fields are not compared to the base table data.</p>
<p>
The WHERE clause used to update base tables consists of the primary fields specified with the KeyFieldList property and any other fields that are modified in the view. In the case of the previous example, Visual FoxPro would prepare an update statement that compares the values in the <code>cust_id</code> field because it is the key field, and the <code>contact</code> field because the contact name has been changed. Even though the <code>title</code> field is updatable, <code>title</code> is not included in the update statement because we haven’t modified it.</p>
<p class=label>
<b>The key and modified fields in your view are compared against their base table counterparts.</b></p>
<p>
<img src="afd17002.gif" border=0></p>
<h4>Comparing the Key Field and All Updatable Fields</h4>
<p>
The DB_KEYANDUPDATABLE setting compares the key field and any updatable fields (whether modified or not) in your view against their base table counterparts. If the field is updatable, even if you haven’t changed it in the view, if anyone else has changed that field in the base table, the update fails.</p>
<p>
The WHERE clause used to update base tables consists of the primary fields specified with the Key Field or KeyFieldList property and any other fields that are updatable. In the case of the example, Visual FoxPro would prepare an update statement that compares the values in the <code>cust_id</code>, <code>contact</code>, and <code>title</code> fields against the same fields in the base table row.</p>
<p class=label>
<b>All the updatable fields in your view are compared against their base table counterparts.</b></p>
<p>
<img src="afd17003.gif" border=0></p>
<h4>Comparing the Timestamp for All Fields in the Base Table Record</h4>
<p>
The DB_KEYANDTIMESTAMP is the most restrictive type of update, and is only available if the base table has a timestamp column. Visual FoxPro compares the current timestamp on the base table record against the timestamp at the time the data was fetched into the view. If any field in the base table’s record has changed, even if it’s not a field you're trying to change, or even a field in your view, the update fails.</p>
<p>
In the case of the example, Visual FoxPro prepares an update statement that compares the values in the <code>cust_id</code> field and the value in the <code>timestamp</code> field against those fields in the base table row.</p>
<p class=label>
<b>The timestamp for your view’s record is compared against the timestamp on the base table record.</b></p>
<p>
<img src="afd17004.gif" border=0></p>
<p>
In order to successfully update data using the DB_KEYANDTIMESTAMP setting with a multi-table view, you must include the timestamp field in your view for each table that is updatable. For example, if you have three tables in a view and want to update only two of them, and you choose the DB_KEYANDTIMESTAMP setting, you must bring down the timestamp fields from the two updatable tables into your result set. You can also use logical values in the CompareMemo property to determine whether memo fields are included in conflict detection.</p>

<h2><a name="dgmanaging_conflicts"></a>Managing Conflicts</h2>
<p>
Whether you choose buffering, transactions, or views, you must manage conflicts during the update process.</p>
<h3>Managing Buffering Conflicts</h3>
<p>
You can make data update operations more efficient by carefully choosing how and when to open, buffer, and lock data in a multi-user environment. You should limit the time a record or table is subject to access conflicts. Still, you must anticipate and manage the inevitable conflicts that result. A <i>conflict</i> occurs when one user tries to lock a record or table that’s currently locked by another user. Two users cannot lock the same record or table at the same time.</p>
<p>
Your application should contain a routine to manage these conflicts. If your application doesn't have a conflict routine, the system can lock up. A <i>deadlock</i> occurs when one user has locked a record or a table and tries to lock another record that’s locked by a second user who, in turn, is trying to lock the record that’s locked by the first user. While such occurrences are rare, the longer that a record or table is locked, the greater the chance of deadlock.</p>
<h4>Trapping Errors</h4>
<p>
Designing a multi-user application or adding network support to a single-user system requires that you deal with collisions and trap for errors. Using Visual FoxPro record and table buffers simplifies some of this work.</p>
<p>
If you attempt to lock a record or table already locked by another user, Visual FoxPro returns an error message. You can use <a href="lngset_reprocess.htm">SET REPROCESS</a> to automatically deal with unsuccessful lock attempts. This command, in combination with an <a href="lngon_error.htm">ON ERROR</a> routine and the <a href="lngretry.htm">RETRY</a> command, enables you to continue or cancel the lock attempts.</p>
<p>
The following example demonstrates automatic reprocessing of a failed operation, using SET REPROCESS.</p>
<p class=label>
<b>Using SET REPROCESS and ON ERROR to Manage User Collisions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Code</b></td>
<td class=label width=35%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>ON ERROR DO err_fix WITH ERROR(),MESSAGE()
SET EXCLUSIVE OFF&nbsp;&nbsp; 
SET REPROCESS TO AUTOMATIC
USE customer
IF !FILE('cus_copy.dbf')
 &nbsp; COPY TO cus_copy
ENDIF</code></pre>
</td>
<td width=35%>This routine runs if an error occurs.<br>
Open the files non-exclusively.<br>
Reprocessing of unsuccessful locks is automatic.<br>
Open the table.<br>
<br>
Create the APPEND FROM table if needed.<br>
</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>DO app_blank
DO rep_next
DO rep_all
DO rep_curr
DO add_recs</code></pre>
</td>
<td width=35%>The main routine starts here.<br>
These commands are examples of codes that could be executed in the course of your program.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>ON ERROR</code></pre>
</td>
<td width=35%>The main routine ends here.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>PROCEDURE app_blank&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; APPEND BLANK
RETURN
ENDPROC</code></pre>
</td>
<td width=35%>Routine to append a blank record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>PROCEDURE rep_next
 &nbsp; REPLACE NEXT 1 contact WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; PROPER(contact)
RETURN
ENDPROC</code></pre>
</td>
<td width=35%>Routine to replace data in the current record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>PROCEDURE rep_all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; REPLACE ALL contact WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; PROPER(contact)
 &nbsp; GO TOP
RETURN
ENDPROC</code></pre>
</td>
<td width=35%>Routine to replace data in all records.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>PROCEDURE rep_curr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; REPLACE contact WITH PROPER(contact)
RETURN
ENDPROC</code></pre>
</td>
<td width=35%>Routine to replace data in the current record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>PROCEDURE add_recs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; APPEND FROM cus_copy
RETURN
ENDPROC</code></pre>
</td>
<td width=35%>Routine to append records from another file.</td>
</tr>
</table><br>
<p>
The following example demonstrates an error procedure that starts when the user presses ESC.</p>
<p class=label>
<b>Error Handling Using the ESC Key</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Code</b></td>
<td class=label width=35%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>PROCEDURE err_fix
 &nbsp; PARAMETERS errnum, msg</code></pre>
</td>
<td width=35%>This program is called when an error is encountered and the user escapes from the wait process.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>DO CASE</code></pre>
</td>
<td width=35%>Figure out what kind of error this is.<br>
Is it “File is in use by another”?</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE errnum = 108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; line1 = "File cannot be locked."
 &nbsp;&nbsp;&nbsp;&nbsp; line2 = "Try again later..."</code></pre>
</td>
<td width=35%></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;CASE errnum = 109 .OR. errnum = 130
 &nbsp;&nbsp;&nbsp;&nbsp; line1 = "Record cannot be locked."
 &nbsp;&nbsp;&nbsp;&nbsp; line2 = "Try again later."</code></pre>
</td>
<td width=35%>Or “Record is in use by another”?</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;OTHERWISE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; line1 = msg + " "
 &nbsp;&nbsp;&nbsp;&nbsp; line2 = ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "See your system administrator."
ENDCASE</code></pre>
</td>
<td width=35%>Or is it unknown?<br>
<br>
<br>
</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>=MESSAGEBOX( line1 + line2, 48, "Error!" )
RETURN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></pre>
</td>
<td width=35%>Display the error message in a dialog box with an exclamation point and an OK button.</td>
</tr>
</table><br>
<h3>Detecting and Resolving Conflicts</h3>
<p>
During data update operations, especially in shared environments, you might want to determine which fields have changed or what the original or the current values are in changed fields. Visual FoxPro buffering and the <a href="lnggetfldstatelp_rp.htm">GETFLDSTATE(&nbsp;)</a>, <a href="lnggetnextmodifiedlp_rp.htm">GETNEXTMODIFIED(&nbsp;)</a>, <a href="lngoldvallp_rp.htm">OLDVAL(&nbsp;)</a> and <a href="lngcurvallp_rp.htm">CURVAL(&nbsp;)</a> functions, enable you to determine which field has changed, find the changed data, and compare the current, original, and edited values so you can decide how to handle an error or conflict.</p>
<p class=label>
<b>To detect a change in a field</b>
<ul type=disc>
<li>
After an update operation, use the <a href="lnggetfldstatelp_rp.htm">GETFLDSTATE(&nbsp;)</a> function.</li>
</ul>
<p>
GETFLDSTATE(&nbsp;) works on unbuffered data; however, this function is even more effective when you've enabled record buffering. For instance, use GETFLDSTATE(&nbsp;) in the code of a Skip button on a form. When you move the record pointer, Visual FoxPro checks the status of all fields in the record as in the following example:</p>
<pre><code>lModified = .F.
FOR nFieldNum = 1 TO FCOUNT(&nbsp;) &amp;&amp; Check all fields 
 &nbsp; if GETFLDSTATE(nFieldNum) = 2&nbsp; &amp;&amp; Modified
 &nbsp;&nbsp;&nbsp;&nbsp; lModified = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; EXIT &amp;&amp; Insert update/Save routine here.
 &nbsp; ENDIF &amp;&amp; See the next example
ENDFOR
</code></pre>
<p class=label>
<b>To detect and locate a changed record in buffered data</b>
<ul type=disc>
<li>
Use the <a href="lnggetnextmodifiedlp_rp.htm">GETNEXTMODIFIED(&nbsp;)</a> function.</li>
</ul>
<p>
GETNEXTMODIFIED(&nbsp;), with zero as a parameter, finds the first modified record. If another user makes changes to the buffered table, any changes encountered by a <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> command in your buffer will cause conflicts. You can evaluate the conflicting values and resolve them using the <a href="lngcurvallp_rp.htm">CURVAL(&nbsp;)</a>, <a href="lngoldvallp_rp.htm">OLDVAL(&nbsp;)</a>, and <a href="lngmessageboxlp_rp.htm">MESSAGEBOX(&nbsp;)</a> functions. CURVAL(&nbsp;) returns the current value of the record on disk, while OLDVAL(&nbsp;) returns the value of the record at the time it was buffered.</p>
<p class=label>
<b>To determine the original value of a buffered field</b>
<ul type=disc>
<li>
Use the <a href="lngoldvallp_rp.htm">OLDVAL(&nbsp;)</a> function.</li>
</ul>
<p>
OLDVAL(&nbsp;) returns the value of a buffered field.</p>
<p class=label>
<b>To determine the current value of a buffered field on disk</b>
<ul type=disc>
<li>
Use the <a href="lngcurvallp_rp.htm">CURVAL(&nbsp;)</a> function.</li>
</ul>
<p>
CURVAL(&nbsp;) returns the current value on disk of a buffered field before any edits were performed.</p>
<p>
You can create an error-handling procedure that compares the current and original values, enabling you to determine whether to commit the current change or to accept an earlier change to data in a shared environment.</p>
<p>
The following example uses GETNEXTMODIFIED(&nbsp;), CURVAL(&nbsp;), and OLDVAL(&nbsp;) to provide the user with an informed choice in an update operation. This example continues from detection of the first modified record and might be contained in an Update or Save button on a form.</p>
<p class=label>
<b>Click Event Code for an Update or Save Button</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Code</b></td>
<td class=label width=35%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>DO WHILE GETNEXTMODIFIED(nCurRec) &lt;&gt; 0&nbsp;&nbsp; 
 &nbsp; GO nCurRec
 &nbsp; RLOCK(&nbsp;)</code></pre>
</td>
<td width=35%>Loop through buffer.<br>
<br>
Lock the modified record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;FOR nField = 1 TO FCOUNT(cAlias)&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; cField = FIELD(nField)
 &nbsp;&nbsp;&nbsp;&nbsp; IF OLDVAL(cField) &lt;&gt; CURVAL(cField)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nResult = MESSAGEBOX("Data was ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; changed by another user. ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Keep changes?", 4+48+0, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Modified Record")</code></pre>
</td>
<td width=35%>Look for conflict.<br>
<br>
Compare the original value to the current value on the disk, and then ask the user what to do about the conflict.<br>
</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF nResult = 7&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TABLEREVERT(.F.)&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNLOCK RECORD nCurRec&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDFOR
 &nbsp; nCurRec = GETNEXTMODIFIED(nCurRec)
ENDDO</code></pre>
</td>
<td width=35%>If the user selects “No,” revert this record, and then remove the lock.<br>
<br>
<br>
<br>
<br>
Find the next modified record.</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>TABLEUPDATE(.T., .T.)&nbsp;&nbsp; </code></pre>
</td>
<td width=35%>Force update to all records.</td>
</tr>
</table><br>
<h3>Detecting Conflicts using Memo Fields</h3>
<p>
You can use the CompareMemo property to control when memo fields are used to detect update conflicts. This view and cursor property determines whether memo fields (types M or G) are included in the update WHERE clause. The default setting, True (.T.), means that memo fields are included in the WHERE clause. If you set this property to False (.F), memo fields don’t participate in the update WHERE clause, regardless of the settings of UpdateType.</p>
<p>
Optimistic conflict detection on Memo fields is disabled when CompareMemo is set to False. For conflict detection on memo values, set CompareMemo to True (.T.).</p>
<h3>Rules for Managing Conflicts</h3>
<p>
Managing conflicts encountered in multi-user environments can require extensive and repetitive code. A complete conflict management routine does the following:</p>
<ul type=disc>
<li>
Detects a conflict.</li>
<li>
Identifies the nature and location of the conflict.</li>
<li>
Provides enough information so that the user can intelligently resolve the conflict.</li>
</ul>
<p>
For an example of a conflict management routine, see the data checker class in Samples.vcx, located in the Visual Studio …\Samples\Vfp98\Classes directory. Just add the class to a form and call the CheckConflicts method before any operation that writes buffered data to the table, for example moving the record pointer if you're using row buffering, closing a table, or issuing TABLEUPDATE(&nbsp;).</p>
</BODY>
</HTML>
