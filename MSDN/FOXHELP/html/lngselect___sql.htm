<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SELECT - SQL Command</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="lngselect___sql"></a><sup></sup>SELECT - SQL Command</h1>
<p>
<a href="lngselect___sqlx.htm">Example</a> &nbsp; <a href="lngselect___sqlsa.htm">See Also</a></p>
<p>
Retrieves data from one or more tables.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SELECT [ALL | DISTINCT] [TOP <i>nExpr</i> [PERCENT]]<br>
 &nbsp; [<i>Alias</i>.] <i>Select_Item</i> [AS <i>Column_Name</i>]<br>
 &nbsp; [, [<i>Alias</i>.] <i>Select_Item</i> [AS <i>Column_Name</i>] ...]</p>
<p>
FROM [FORCE]<br>
[<i>DatabaseName</i>!]<i>Table</i> [[AS] <i>Local_Alias</i>]<br>
 &nbsp; [[INNER | LEFT [OUTER] | RIGHT [OUTER] | FULL [OUTER] JOIN<br>
 &nbsp;&nbsp;&nbsp;&nbsp; <i>DatabaseName</i>!]<i>Table</i> [[AS] <i>Local_Alias</i>]<br>
 &nbsp;&nbsp;&nbsp;&nbsp; [ON <i>JoinCondition</i> …]</p>
<p>
[[INTO <i>Destination</i>]<br>
 &nbsp; | [TO FILE <i>FileName</i> [ADDITIVE] | TO PRINTER [PROMPT] <br>
 &nbsp; | TO SCREEN]]</p>
<p>
[PREFERENCE <i>PreferenceName</i>]</p>
<p>
[NOCONSOLE]</p>
<p>
[PLAIN]</p>
<p>
[NOWAIT]</p>
<p>
[WHERE <i>JoinCondition</i> [AND <i>JoinCondition</i> ...]<br>
 &nbsp; [AND | OR <i>FilterCondition</i> [AND | OR <i>FilterCondition</i> ...]]]</p>
<p>
[GROUP BY <i>GroupColumn</i> [, <i>GroupColumn</i> ...]]</p>
<p>
[HAVING <i>FilterCondition</i>]</p>
<p>
[UNION [ALL] <i>SELECTCommand</i>]</p>
<p>
[ORDER BY <i>Order_Item</i> [ASC | DESC] [, <i>Order_Item</i> [ASC | DESC] ...]]</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
SELECT</p>
<p class=indent>
Specifies the fields, constants, and expressions that are displayed in the query results.</p>
<p class=dt>
ALL</p>
<p class=indent>
By default, displays all the rows in the query results.</p>
<p class=dt>
DISTINCT</p>
<p class=indent>
Excludes duplicates of any rows from the query results.</p>
<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can use DISTINCT only once per SELECT clause.</p><p class=dt>
TOP <i>nExpr</i> [PERCENT]</p>
<p class=indent>
Specifies that the query result contains a specific number of rows or a percentage of rows in the query result. You must include an ORDER BY clause when you include the TOP clause. The ORDER BY clause specifies the columns on which the TOP clause determines the number of rows to include in the query result.</p>
<p class=tl>
You can specify from 1 to 32,767 rows. Rows with identical values for the columns specified in the ORDER BY clause are included in the query result. Therefore, if you specify 10 for <i>nExpr</i>, the query result can contain more than 10 rows if there are more than 10 rows with identical values for the columns specified in the ORDER BY clause.</P><p class=tl>
If the PERCENT keyword is included, the number of rows returned in the result is rounded up to the next highest integer. Permissible values for <i>nExpr</i> when the PERCENT keyword is included are 0.01 to 99.99.</P><p class=dt>
<i>Alias</i>.</p>
<p class=indent>
Qualifies matching item names. Each item you specify with <i>Select_Item</i> generates one column of the query results. If two or more items have the same name, include the table alias and a period before the item name to prevent columns from being duplicated.</p>
<p class=tl>
<i>Select_Item</i> specifies an item to be included in the query results. An item can be one of the following:</P><ul type=disc>
<li>
The name of a field from a table in the FROM clause.<br><br></li>
<li>
A constant specifying that the same constant value is to appear in every row of the query results.<br><br></li>
<li>
An expression that can be the name of a user-defined function.</li>
</ul>
<p class=dt>
AS <i>Column_Name</i></p>
<p class=indent>
Specifies the heading for a column in the query output. This option is useful when <i>Select_Item</i> is an expression or contains a field function and you want to give the column a meaningful name. <i>Column_Name</i> can be an expression but cannot contain characters (for example, spaces) that aren't permitted in table field names.</p>
<p class=dt>
FROM</p>
<p class=indent>
Lists the tables containing the data that the query retrieves. If no table is open, Visual FoxPro displays the Open dialog box so you can specify the file location. Once open, the table remains open once the query is complete. </p>
<p class=indent>
FORCE specifies that tables are joined in the order in which they appear in the FROM clause. If FORCE is omitted, Visual FoxPro attempts to optimize the query. However, the query might be executed faster by including the FORCE keyword to disable the Visual FoxPro query optimization.</p>
<p class=dt>
<i>DatabaseName!</i></p>
<p class=indent>
Specifies the name of a non-current database containing the table. You must include the name of database containing the table if the database is not the current database. Include the exclamation point (!) delimiter after the database name and before the table name. </p>
<p class=dt>
[AS] <i>Local_Alias</i></p>
<p class=indent>
Specifies a temporary name for the table named in <i>Table</i>. If you specify a local alias, you must use the local alias in place of the table name throughout the SELECT statement.</p>
<p class=indent>
INNER JOIN specifies that the query result contains only rows from a table that match one or more rows in another table.</p>
<p class=indent>
LEFT [OUTER] JOIN specifies that the query result contains all rows from the table to the left of the JOIN keyword and only matching rows from the table to the right of the JOIN keyword. The OUTER keyword is optional; it can be included to emphasize that an outer join is created.</p>
<p class=indent>
RIGHT [OUTER] JOIN specifies that the query result contains all rows from the table to the right of the JOIN keyword and only matching rows from the table to the left of the JOIN keyword. The OUTER keyword is optional; it can be included to emphasize that an outer join is created.</p>
<p class=indent>
FULL [OUTER] JOIN specifies that the query result contains all matching and non matching rows from both tables. The OUTER keyword is optional; it can be included to emphasize that an outer join is created.</p>
<p class=indent>
ON <i>JoinCondition</i> specifies the conditions for which the tables are joined.</p>
<p class=dt>
INTO <i>Destination</i></p>
<p class=indent>
Specifies where to store the query results. If you include the INTO clause and the TO clause in the same query, the TO clause is ignored. If you don't include the INTO clause, query results are displayed in a Browse window. You can also use TO to direct query results to the printer or a file.</p>
<p class=tl>
<i>Destination</i> can be one of the following clauses:</P><ul type=disc>
<li>
ARRAY <i>ArrayName</i>, which stores query results in a memory variable array. The array isn't created if the query selects 0 records.<br><br></li>
<li>
CURSOR <i>CursorName </i>[NOFILTER], which stores query results in a cursor. If you specify the name of an open table, Visual FoxPro generates an error message. After SELECT is executed, the temporary cursor remains open and is active but is read-only. Once you close this temporary cursor, it is deleted. Cursors may exist as a temporary file on the drive or volume specified by SORTWORK.<p class=tl>
Include NOFILTER to create a cursor that can be used in subsequent queries. In previous versions of Visual FoxPro, it was necessary to include an extra constant or expression as a filter to create a cursor that could be used in subsequent queries. For example, adding a logical true as a filter expression created a query that could be used in subsequent queries:</P><pre><code>SELECT *, .T. FROM customers INTO CURSOR myquery
</code></pre>
<p class=tl>
Including NOFILTER can reduce query performance because a temporary table is created on disk. The temporary table is deleted from disk when the cursor is closed.</P></li>
<li>
DBF | TABLE <i>TableName</i><br>
[DATABASE <i>DatabaseName </i>[NAME <i>LongTableName</i>]] stores query results in a table. If you specify a table that is already open and SET SAFETY is set to OFF, Visual FoxPro overwrites the table without warning. If you don't specify an extension, Visual FoxPro gives the table a .DBF extension. The table remains open and active after SELECT is executed.<p class=tl>
Include DATABASE <i>DatabaseName</i> to specify a database to which the table is added. Include NAME <i>LongTableName</i> to specify a long name for the table. Long names can contain up to 128 characters and can be used in place of short file names in the database.</P></li>
</ul>
<p class=dt>
TO FILE <i>FileName</i></p>
<p class=indent>
If you include a TO clause but not an INTO clause, you can direct query results to an ASCII text file named <i>FileName</i>, to the printer, or to the main Visual FoxPro window.</p>
<p class=indent>
ADDITIVE appends query output to the existing contents of the text file specified in TO FILE <i>FileName</i>.</p>
<p class=indent>
TO PRINTER [PROMPT] directs query output to a printer. Use the optional PROMPT clause to display a dialog box before printing starts. In this dialog box, you can adjust printer settings. The printer settings that you can adjust depend on the currently installed printer driver. Place PROMPT immediately after TO PRINTER.</p>
<p class=indent>
TO SCREEN directs query output to the main Visual FoxPro window or to an active user-defined window.</p>
<p class=dt>
PREFERENCE <i>PreferenceName</i></p>
<p class=indent>
Saves the Browse window's attributes and options for later use, if query results are sent to a Browse window. PREFERENCE saves the attributes, or preferences, indefinitely in the FOXUSER resource file. Preferences can be retrieved at any time.</p>
<p class=tl>
Issuing SELECT with a PREFERENCE <i>PreferenceName</i> for the first time creates the preference. Issuing SELECT later with the same preference name restores the Browse window to that preference state. When the Browse window is closed, the preference is updated.</P><p class=tl>
If you exit a Browse window by pressing CTRL+Q+W, changes you've made to the Browse window are not saved to the resource file.</P><p class=dt>
NOCONSOLE</p>
<p class=indent>
Prevents display of query results sent to a file, the printer, or the main Visual FoxPro window.</p>
<p class=dt>
PLAIN</p>
<p class=indent>
Prevents column headings from appearing in the query output that is displayed. You can use PLAIN whether or not a TO clause is present. If an INTO clause is included, PLAIN is ignored.</p>
<p class=dt>
NOWAIT</p>
<p class=indent>
Continues program execution after the Browse window is opened and query results are directed to it. The program doesn't wait for the Browse window to be closed, but continues execution on the program line immediately following the SELECT statement.</p>
<p class=tl>
When TO SCREEN is included to direct output to the main Visual FoxPro window or to a user-defined window, output pauses when the main Visual FoxPro window or user-defined window is full of query results. Press a key to see the next set of query results. If NOWAIT is included, the query results are scrolled off the main Visual FoxPro window or the user-defined window without pausing for a key press. NOWAIT is ignored if included with the INTO clause.</P><p class=dt>
WHERE</p>
<p class=indent>
Tells Visual FoxPro to include only certain records in the query results. WHERE is required to retrieve data from multiple tables.</p>
<p class=dt>
<i>JoinCondition</i></p>
<p class=indent>
specifies fields that link the tables in the FROM clause. If you include more than one table in a query, you should specify a join condition for every table after the first.</p>
<p class=tl>
You must use the AND operator to connect multiple join conditions. Each join condition has the following form:</P><p class=tl>
<i>FieldName1</i> <i>Comparison</i> <i>FieldName2</i></P><p class=tl>
<i>FieldName1</i> is the name of a field from one table, <i>FieldName2</i> is the name of a field from another table, and <i>Comparison</i> is one of the following operators:</P><table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Operator</b></td>
<td class=label width=74%><b>Comparison</b></td>
</tr>
<tr valign=top>
<td width=26%>=</td>
<td width=74%>Equal</td>
</tr>
<tr valign=top>
<td width=26%>==</td>
<td width=74%>Exactly equal</td>
</tr>
<tr valign=top>
<td width=26%>LIKE</td>
<td width=74%>SQL LIKE</td>
</tr>
<tr valign=top>
<td width=26%>&lt;&gt;, !=, #</td>
<td width=74%>Not equal</td>
</tr>
<tr valign=top>
<td width=26%>&gt;</td>
<td width=74%>More than</td>
</tr>
<tr valign=top>
<td width=26%>&gt;=</td>
<td width=74%>More than or equal to</td>
</tr>
<tr valign=top>
<td width=26%>&lt;</td>
<td width=74%>Less than</td>
</tr>
<tr valign=top>
<td width=26%>&lt;=</td>
<td width=74%>Less than or equal to</td>
</tr>
</table><br>
<p class=tl>
When you use the = operator with strings, it acts differently depending on the setting of SET ANSI. When SET ANSI is set to OFF, Visual FoxPro treats string comparisons in a manner familiar to Xbase users. When SET ANSI is set to ON, Visual FoxPro follows ANSI standards for string comparisons. See <a href="lngset_ansi.htm">SET ANSI</a> and <a href="lngset_exact.htm">SET EXACT</a> for additional information about how Visual FoxPro performs string comparisons.</P><p class=tl>
The WHERE clause supports the ESCAPE operator for the <i>JoinCondition, </i>allowing you to perform meaningful queries on data containing the SELECT - SQL % and _ wildcard characters.</P><p class=tl>
The ESCAPE clause lets you specify that a SELECT - SQL wildcard character be treated as a literal character. In the ESCAPE clause you specify a character, which when placed immediately before the wildcard character, indicates that the wildcard character be treated as a literal character.</P><p class=dt>
<i>FilterCondition</i></p>
<p class=indent>
specifies the criteria that records must meet to be included in the query results. You can include as many filter conditions as you like in a query, connecting them with the AND or OR operator. You can also use the NOT operator to reverse the value of a logical expression, or use EMPTY(&nbsp;) to check for an empty field.</p>
<p>
<i>FilterCondition</i> can take any of the forms in the following examples:</p>
<p>
<B><b>Example 1</b></B></p>
<p>
Example 1 displays <i>FilterCondition </i>in the form of <i>FieldName1</i> <i>Comparison</i> <i>FieldName2</i></p>
<pre><code>customer.cust_id = orders.cust_id
</code></pre>
<p>
<B><b>Example 2</b></B></p>
<p>
Example 2 displays <i>FilterCondition </i>in the form of <i>FieldName</i> <i>Comparison</i> <i>Expression</i></p>
<pre><code>payments.amount &gt;= 1000
</code></pre>
<p>
<B><b>Example 3</b></B></p>
<p>
Example 3 displays <i>FilterCondition </i>in the form of <i>FieldName</i> <i>Comparison</i> ALL (<i>Subquery</i>)</p>
<p>
When the filter condition includes ALL, the field must meet the comparison condition for all values generated by the subquery before its record is included in the query results.</p>
<pre><code>company &lt; ALL ;
(SELECT company FROM customer WHERE country = "UK")
</code></pre>
<p>
<B><b>Example 4</b></B></p>
<p>
Example 4 displays <i>FilterCondition </i>in the form of <i>FieldName</i> <i>Comparison</i> ANY | SOME (<i>Subquery</i>)</p>
<p>
When the filter condition includes ANY or SOME, the field must meet the comparison condition for at least one of the values generated by the subquery.</p>
<pre><code>company &lt; ANY ;
(SELECT company FROM customer WHERE country = "UK")
</code></pre>
<p>
<B><b>Example 5</b></B></p>
<p>
Example 5 displays <i>FilterCondition </i>in the form of <i>FieldName</i> [NOT] BETWEEN <i>Start_Range</i> AND <i>End_Range</i></p>
<p>
This example checks to see whether the values in the field are within a specified range of values.</p>
<pre><code>customer.postalcode BETWEEN 90000 AND 99999
</code></pre>
<p>
<B><b>Example 6</b></B></p>
<p>
Example 6 displays <i>FilterCondition </i>in the form of [NOT] EXISTS (<i>Subquery</i>)</p>
<p>
This example checks to see whether at least one row meets the criterion in the subquery. When the filter condition includes EXISTS, the filter condition evaluates to true (.T.) unless the subquery evaluates to the empty set.</p>
<pre><code>EXISTS ; 
(SELECT * FROM orders WHERE customer.postalcode = &nbsp;&nbsp; orders.postalcode)
</code></pre>
<p>
<B><b>Example 7</b></B></p>
<p>
Example 7 displays <i>FilterCondition </i>in the form of <i>FieldName</i> [NOT] IN <i>Value_Set</i></p>
<p>
When the filter condition includes IN, the field must contain one of the values before its record is included in the query results.</p>
<pre><code>customer.postalcode NOT IN ("98052","98072","98034")
</code></pre>
<p>
<B><b>Example 8</b></B></p>
<p>
Example 8 displays <i>FilterCondition </i>in the form of <i>FieldName</i> [NOT] IN (<i>Subquery</i>)</p>
<p>
Here, the field must contain one of the values returned by the subquery before its record is included in the query results.</p>
<pre><code>customer.cust_id IN ; 
(SELECT orders.cust_id FROM orders WHERE orders.city="Seattle")
</code></pre>
<p>
<B><b>Example 9</b></B></p>
<p>
Example 9 displays <i>FilterCondition </i>in the form of <i>FieldName</i> [NOT] LIKE <i>cExpression</i></p>
<pre><code>customer.country NOT LIKE "UK"
</code></pre>
<p>
This filter condition searches for each field that matches <i>cExpression</i>.</p>
<p>
You can use the percent sign (%) and underscore (&nbsp;_&nbsp;) wildcards as part of <i>cExpression</i>. The percent sign represents any sequence of unknown characters in the string. An underscore represents a single unknown character in the string.</p>
<p class=dt>
GROUP BY <i>GroupColumn</i> [, <i>GroupColumn</i> ...]</p>
<p class=indent>
Groups rows in the query based on values in one or more columns. <i>GroupColumn</i> can be the name of a regular table field, a field that includes a SQL field function, or a numeric expression indicating the location of the column in the result table (the leftmost column number is 1).</p>
<p class=dt>
HAVING <i>FilterCondition</i></p>
<p class=indent>
Specifies a filter condition which groups must meet to be included in the query results. HAVING should be used with GROUP BY. It can include as many filter conditions as you like, connected with the AND or OR operators. You can also use NOT to reverse the value of a logical expression.</p>
<p class=tl>
<i>FilterCondition</i> cannot contain a subquery.</P><p class=tl>
A HAVING clause without a GROUP BY clause acts like a WHERE clause. You can use local aliases and field functions in the HAVING clause. Use a WHERE clause for faster performance if your HAVING clause contains no field functions. Note that the HAVING clause should appear before an INTO clause or a syntax error occurs.</P><p class=dt>
[UNION [ALL] <i>SELECTCommand</i>]</p>
<p class=indent>
Combines the final results of one SELECT with the final results of another SELECT. By default, UNION checks the combined results and eliminates duplicate rows. Use parentheses to combine multiple UNION clauses.</p>
<p class=tl>
ALL prevents UNION from eliminating duplicate rows from the combined results.</P><p class=tl>
UNION clauses follow these rules:</P><ul type=disc>
<li>
You cannot use UNION to combine subqueries.<br><br></li>
<li>
Both SELECT commands must have the same number of columns in their query output.<br><br></li>
<li>
Each column in the query results of one SELECT must have the same data type and width as the corresponding column in the other SELECT.<br><br></li>
<li>
Only the final SELECT can have an ORDER BY clause, which must refer to output columns by number. If an ORDER BY clause is included, it affects the entire result.</li>
</ul>
<p class=dt>
ORDER BY <i>Order_Item</i></p>
<p class=indent>
Sorts the query results based on the data in one or more columns. Each <i>Order_Item</i> must correspond to a column in the query results and can be one of the following:
<ul type=disc>
<li>
A field in a FROM table that is also a select item in the main SELECT clause (not in a subquery).<br><br></li>
<li>
A numeric expression indicating the location of the column in the result table. (The leftmost column is number 1.)<p class=tl>
ASC specifies an ascending order for query results, according to the order item or items, and is the default for ORDER BY.</P></li>
</ul>
<p class=indent>
DESC specifies a descending order for query results.</p>
<p class=tl>
Query results appear unordered if you don't specify an order with ORDER BY.</P><p class=label>
<b>Remarks</b></p>
<p>
SELECT is a SQL command that is built into Visual FoxPro like any other Visual FoxPro command. When you use SELECT to pose a query, Visual FoxPro interprets the query and retrieves the specified data from the tables. You can create a SELECT query from within:
<ul type=disc>
<li>
The Command window<br><br></li>
<li>
A Visual FoxPro program (as with any other Visual FoxPro command)<br><br></li>
<li>
The Query Designer</li>
</ul>
<p>
When you issue SET TALK ON and execute SELECT, Visual FoxPro displays the length of time the query took to execute and the number of records in the results. _TALLY contains the number of records in the query results.</p>
<p>
SELECT does not respect the current filter condition specified with SET FILTER.</p>
<p class=indent>
A <i>subquery</i>, referred to in the following arguments, is a SELECT within a SELECT and must be enclosed in parentheses. You can have up to two subqueries at the same level (not nested) in the WHERE clause (see that section of the arguments). Subqueries can contain multiple join conditions.</p>
<p>
When you create query output, columns are named according to the following rules:
<ul type=disc>
<li>
If a select item is a field with a unique name, the output column name is the field's name.<br><br></li>
<li>
If more than one select item has the same name, an underscore and a letter are appended to the column name. For example, if a table called Customer has a field called STREET, and a table called Employees also has a field called STREET, output columns are named <i>Extension</i>_A and <i>Extension</i>_B (STREET_A and STREET_B). For a select item with a 10-character name, the name is truncated to add the underscore and letter. For example, DEPARTMENT would become DEPARTME_A.<br><br></li>
<li>
If a select item is an expression, its output column is named EXP_A. Any other expressions are named EXP_B, EXP_C, and so on.<br><br></li>
<li>
If a select item contains a field function such as COUNT(&nbsp;), the output column is named CNT_A. If another select item contains SUM(&nbsp;), its output column is named SUM_B.<p class=tl>
<b>User-Defined Functions with SELECT</b>&nbsp;&nbsp;&nbsp;Although using user-defined functions in the SELECT clause has obvious benefits, you should also consider the following restrictions:</P></li>
<li>
The speed of operations performed with SELECT may be limited by the speed at which such user-defined functions are executed. High-volume manipulations involving user-defined functions may be better accomplished by using API and user-defined functions written in C or assembly language.<br><br></li>
<li>
You can assume nothing about the Visual FoxPro input/output (I/O) or table environment in user-defined functions invoked from SELECT. In general, you don't know which work area is selected, the name of the current table, or even the names of the fields being processed. The value of these variables depends on where precisely in the optimization process the user-defined function is invoked.<br><br></li>
<li>
It isn't safe to change the Visual FoxPro I/O or table environment in user-defined functions invoked from SELECT. In general, the results are unpredictable.<br><br></li>
<li>
The only reliable way to pass values to user-defined functions invoked from SELECT is by the argument list passed to the function when it is invoked.<br><br></li>
<li>
If you experiment and discover a supposedly forbidden manipulation that works correctly in a certain version of FoxPro, there is no guarantee it will continue to work in later versions.<p class=tl>
Apart from these restrictions, user-defined functions are acceptable in the SELECT clause. However, don't forget that using SELECT might slow performance.</P><p class=tl>
The following field functions are available for use with a select item that is a field or an expression involving a field:</P></li>
<li>
AVG(<i>Select_Item</i>), which averages a column of numeric data.<br><br></li>
<li>
COUNT(<i>Select_Item</i>), which counts the number of select items in a column. COUNT(*) counts the number of rows in the query output.<br><br></li>
<li>
MIN(<i>Select_Item</i>), which determines the smallest value of <i>Select_Item</i> in a column.<br><br></li>
<li>
MAX(<i>Select_Item</i>), which determines the largest value of <i>Select_Item</i> in a column.<br><br></li>
<li>
SUM(<i>Select_Item</i>), which totals a column of numeric data.<p class=tl>
You cannot nest field functions.</P><p class=tl>
<b>Joins</b>&nbsp;&nbsp;&nbsp;Visual FoxPro supports ANSI SQL '92 Join syntax, allowing you to create queries that link the rows in two or more tables by comparing the values in specified fields. For example, an inner join selects rows from two tables only when the values of the joined fields are equal. Visual FoxPro supports nested joins.</P><p class=tl>
Because SQL is based on mathematical set theory, each table can be represented as a circle. The ON clause that specifies the join conditions determines the point of overlap which represents the set of rows that match. For an inner join, the overlap occurs within the interior or "inner" portion of the two circles. An outer join includes not only those matched rows found in the inner cross section of the tables, but also the rows in the outer part of the circle to the left, or right, of the intersection.</P><p class=atl>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Keep the following information in mind when creating join conditions:</p></li>
<li>
If you include two tables in a query and don't specify a join condition, every record in the first table is joined with every record in the second table as long as the filter conditions are met. Such a query can produce lengthy results.<br><br></li>
<li>
Be careful when using, in join conditions, functions such as DELETED(&nbsp;), EOF(&nbsp;), FOUND(&nbsp;), RECCOUNT(&nbsp;), and RECNO(&nbsp;), which support an optional alias or work area. Including an alias or work area in these functions might yield unexpected results. SELECT doesn't use your work areas; it performs the equivalent of&nbsp; USE&nbsp;...&nbsp;AGAIN. Single-table queries that use these functions without an optional alias or work area will return proper results. However, multiple-table queries that use these functions — even without an optional alias or work area — might return unexpected results.<br><br></li>
<li>
Use caution when joining tables that contain empty fields because Visual FoxPro matches empty fields. For example, if you join on CUSTOMER.ZIP and INVOICE.ZIP, and CUSTOMER contains 100 empty zip codes and INVOICE contains 400 empty zip codes, the query output contains 40,000 extra records resulting from the empty fields. Use the EMPTY(&nbsp;) function to eliminate empty records from the query output.<p class=tl>
For additional information about joins, see "Defining and Modifying Join Conditions" in Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>, in the <i>Programmer's Guide</i>.</P></li>
</ul>
</BODY>
</HTML>
