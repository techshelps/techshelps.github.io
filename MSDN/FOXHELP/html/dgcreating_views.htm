<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Views</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="dgcreating_views"></a><sup></sup>Chapter 8: Creating Views</h1>
<p>
If you want a custom, updatable data set for your application, you can use views. Views combine the qualities of <a href="glstable.htm">tables</a> and <a href="glsquery.htm">queries</a>: like a query, you can use a view to extract a set of data from one or more related tables; like a table, you can use a view to update the information in the view and permanently store the results to disk. You can also use views to take your data offline to collect or modify data away from your main system.</p>
<p>
This chapter covers creating and updating views programmatically, as well as setting <a href="glsproperty.htm">properties</a> to optimize the performance of your views. For more information about databases, see Chapter 6, <a href="dgcreating_databases.htm">Creating Databases</a>. If you want more information about tables or indexes, see Chapter 7, <a href="dgworking_with_tables.htm">Working with Tables</a>. For more information about the View Designer, see Chapter 5, <a href="ugupdating_data_with_views.htm">Updating Data with Views</a>, in the <i>User's Guide</i>.</p>
<p>
This chapter includes:</p>
<ul type=disc>
<li>
<a href="#dgcreating_a_view">Creating a View</a></li>
<li>
<a href="#dgusing_views">Using Views</a></li>
<li>
<a href="#dgupdating_data_in_a_view">Updating Data in a View</a></li>
<li>
<a href="#dgcombining_views">Combining Views</a></li>
<li>
<a href="#dgworking_with_offline_data">Working with Offline Data</a></li>
<li>
<a href="#dgoptimizing_view_performance">Optimizing View Performance</a></li>
</ul>

<h2><a name="dgcreating_a_view"></a>Creating a View</h2>
<p>
Because views and <a href="glsquery.htm">queries</a> have much in common, your steps in creating a view are like the steps you take in creating a query. You choose the tables and fields you want to include in the view, specify the join conditions used to relate the tables, and specify <a href="glsfilter.htm">filters</a> to select specific records. Unlike in queries, in views you can also select how the changes you make to the data in a view are sent to the original, or <a href="glsbase_table.htm">base tables</a>, from which the view is built.</p>
<p>
When you create a view, Visual FoxPro stores a <a href="glsview_definition.htm">view definition</a> in the current database. The definition contains the names of the tables used in the view, and selected fields and the settings for their <a href="glsproperty.htm">properties</a>. When you use the view, the view definition is used to build a SQL statement that defines the view’s data set.</p>
<p>
For information about view properties, see <a href="#dgsetting_view_and_connection_properties">Setting View and Connection Properties</a> later in this chapter, and see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a> or <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a>.</p>
<p>
You can create two types of views: <a href="glslocal_view.htm">local</a> and <a href="glsremote_view.htm">remote</a>. Remote views use remote SQL syntax to select information from tables on a remote ODBC data source. Local views use Visual FoxPro SQL syntax to select information from tables or views. You can add one or more remote views into a local view, allowing you to access information from Visual FoxPro and remote ODBC data sources in the same view. For information on accessing local and remote data in a single view, see <a href="#dgcombining_local_and_remote_data_in_a_view">Combining Local and Remote Data in a View</a> later in this chapter.</p>
<h3>Creating a Local View</h3>
<p>
You can create a local view with the View Designer or the CREATE SQL VIEW command.</p>
<p class=label>
<b>To create a local view</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select a database, and then choose <b>Local Views</b>, and then choose <b>New</b> to open the <a href="wndquery_designer.htm">View Designer</a>.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command when a database is open to display the View Designer.<p class=tl>
-or-</P></li>
<li>
Use the CREATE SQL VIEW command with the AS clause.</li>
</ul>
<p>
For example, the following code creates a view containing all the fields in the <code>products</code> table :</p>
<pre><code>CREATE SQL VIEW product_view AS SELECT * ;
 &nbsp; FROM testdata!products
</code></pre>
<p>
The new view name appears in the Project Manager. If you open the <a href="wnddatabase_designer.htm">Database Designer</a>, the view is displayed in the same manner as a table in the <a href="glsschema.htm">schema</a>, with the view name in place of a table name.</p>
<p>
In the previous example, the table name is preceded, or <a href="glsqualified.htm">qualified</a>, by the name of the table’s database and the “!” symbol. If you qualify the table name when you create a view, Visual FoxPro searches for the table both in the open database list, including the current and any non-current databases, and in the default search path for the table.</p>
<p>
If you don’t qualify a table with a database name in a <a href="glsview_definition.htm">view definition</a>, the database must be open before you can use the view.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;When you create or use a view in the <a href="wndproject_manager.htm">Project Manager</a>, the Project Manager opens the database automatically for you. If you subsequently use a view outside the project, you must open the database or ensure the database is in scope before you can use the view.</p>
<h3>Creating Views with Stored SQL SELECT Statements</h3>
<p>
You can use <a href="glsmacro_substitution.htm">macro substitution</a> to store the SQL SELECT statement into a <a href="glsvariable.htm">variable</a> which you can call with the AS clause of the CREATE SQL VIEW command. For example, the following code stores a SQL SELECT statement into the variable <code>emp_cust_sql</code>, which is then used to create a new view:</p>
<pre><code>emp_cust_sql = "SELECT employee.emp_id, ;
 &nbsp; customer.cust_id, customer.emp_id, ;
 &nbsp; customer.contact, customer.company ;
 &nbsp; FROM employee, customer ;
 &nbsp; WHERE employee.emp_id = customer.emp_id"
CREATE SQL VIEW emp_cust_view AS &amp;emp_cust_sql
</code></pre>
<h3>Modifying Views</h3>
<p>
You can modify existing views in the View Designer using the Project Manager or the language. If you want to modify the view’s SQL string programmatically, you must create a new view. You can then save the new <a href="glsview_definition.htm">view definition</a> and overwrite the existing view name. To modify a view’s properties, see <a href="#dgsetting_view_and_connection_properties">Setting View and Connection Properties</a> later in this chapter.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;In the View Designer, you can open an existing view, and then copy the read-only SQL string and paste it in your code as a shortcut in creating a view programmatically.</p>
<p class=label>
<b>To modify a view in the View Designer</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select the name of the view, and then choose <b>Modify</b> to open the <a href="wndquery_designer.htm">View Designer</a>.<p class=tl>
-or-</P></li>
<li>
Open a database and use the <a href="lngmodify_view.htm">MODIFY VIEW</a> command with the name of the view.</li>
</ul>
<p>
In the View Designer, you can use the Query menu or the <a href="tlsview_designer_toolbar.htm">View Designer toolbar</a> to add a new table to the view. The following code displays <code>product_view</code> in the View Designer:</p>
<pre><code>OPEN DATABASE testdata
MODIFY VIEW product_view 
</code></pre>
<h3>Renaming a View</h3>
<p>
You can rename a view from the Project Manager or with the RENAME VIEW command.</p>
<p class=label>
<b>To change the name of a view</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select a database, and then select the view name, and then choose <b>Rename File</b> from the <b>Project</b> menu.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngrename_view.htm">RENAME VIEW</a> command.</li>
</ul>
<p>
For example, the following code renames <code>product_view</code> to <code>products_all_view</code> :</p>
<pre><code>RENAME VIEW product_view TO products_all_view
</code></pre>
<p>
The database containing the view must be open before you can rename the view.</p>
<h3>Deleting a View</h3>
<p>
You can delete a <a href="glsview_definition.htm">view definition</a> from a database using the Project Manager or the DELETE VIEW command. Before deleting the view, make sure the database containing the view is open and set as the current database.</p>
<p class=label>
<b>To delete a view</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select a database, and then the view name, and then choose <b>Remove</b>.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngdelete_view.htm">DELETE VIEW</a> or <a href="lngdrop_view.htm">DROP VIEW</a> command.</li>
</ul>
<p>
For example, the following code deletes <code>product_view</code>  and <code>customer_view</code> from the database:</p>
<pre><code>DELETE VIEW product_view
DROP VIEW customer_view
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;These commands have the same effect; DROP VIEW is the ANSI SQL standard syntax for deleting a SQL view.</p>
<h3>Creating a Multitable View</h3>
<p>
To access related information that is stored in separate tables, you can create a view and add two or more tables, or you can modify an existing view by adding tables. To add the tables, you can use the View Designer or the CREATE SQL VIEW command. After adding the tables, you can expand your control of the view results using the join condition you define between the tables.</p>
<p class=label>
<b>To create a multitable view</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, create a view and add the tables you want in the <a href="wndquery_designer.htm">View Designer</a>.<p class=tl>
-or-</P></li>
<li>
Open a database and use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command, adding table names to the FROM clause and join conditions.<p class=tl>
Just adding the tables to the CREATE SQL VIEW command produces a cross-product. You need to specify a <a href="glsjoin_condition.htm">join condition</a> in either the FROM clause or the WHERE clause of the statement to match related records between the tables. If <a href="glspersistent_relationship.htm">persistent relationships</a> between the tables exist, they are automatically used as join conditions.</P></li>
</ul>
<h4>Defining and Modifying Join Conditions</h4>
<p>
Typically, to define a join condition, you use the relationships established on the <a href="glsprimary_key.htm">primary</a> and <a href="glsforeign_key.htm">foreign</a> key fields between the tables. For example, you might want to find information on the orders, including information on the customer who placed the order. You can create a view using the Customer and Orders tables. You specify a join condition to compare values in the fields they have in common and, usually, return those that are equal. In the example, Customer and Orders both have a Customer ID field.</p>
<p class=label>
<b>To define join conditions in a view</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, create or modify a view, and then add the tables you want in the <a href="wndquery_designer.htm">View Designer</a>.<p class=tl>
-or-</P></li>
<li>
Open a database and use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command, adding table names to the FROM clause and join conditions to the FROM clause.</li>
</ul>
<p class=label>
<b>Inner joins specified in the View Designer and displayed in the SELECT - SQL statement</b></p>
<p>
<img src="afd08007.gif" border=0></p>
<p>
The following code creates the new view as described in the example above, using the FROM clause to specify the join conditions for the view:</p>
<pre><code>OPEN DATABASE testdata
CREATE SQL VIEW cust_orders_view AS ;
 &nbsp; SELECT * FROM testdata!customer ;
 &nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN testdata!orders ;
 &nbsp;&nbsp;&nbsp;&nbsp; ON customer.cust_id = orders.cust_id
</code></pre>
<p>
The join condition has several aspects: the type of join, the fields to join on, and the operator for comparing the fields. In this case, which is an <a href="glsinner_join.htm">inner join</a>, only rows from the <code>customer</code> table that match one or more records in the <code>orders</code> table are included in the result.</p>
<p>
To change the results of the view to meet your specific needs, you can specify:</p>
<ul type=disc>
<li>
<a href="glsfield.htm">Fields</a> in the join</li>
<li>
Comparison operators between the fields</li>
<li>
A sequence of joins, if you have two <a href="glstable.htm">tables</a> in your view</li>
<li>
The type of <a href="glsjoin.htm">join</a></li>
</ul>
<p>
Specifying joins on fields other than the <a href="glsprimary_key.htm">primary</a> and <a href="glsforeign_key.htm">foreign</a> keys can be useful in specific instances, but are not used in most views.</p>
<p>
By changing the comparison operator, you can control which records are compared and returned in a manner similar to a <a href="glsfilter.htm">filter</a>. For example, if you are using a date field in the join, you can use the comparison operator to include only records before or after a certain date.</p>
<p>
For more information about the sequence of joins, see <a href="#dgdefining_multiple_join_conditions">Defining Multiple Join Conditions</a> later in this chapter.</p>
<p>
Choosing a different <a href="glsjoin.htm">join</a> type allows you to expand your <a href="glsquery.htm">query</a> results to include both records that match the <a href="glsjoin_condition.htm">join condition</a> and those that do not. If you have more than two tables in your view, you can change your results by changing the order of joins in the FROM clause.</p>
<p>
You can modify the join types in your view using the View Designer or the language.</p>
<p class=label>
<b>To modify a join type</b>
<ul type=disc>
<li>
Select the <b>Join</b> tab.<p class=tl>
-or-</P></li>
<li>
Double-click the join line.<p class=tl>
-or-</P></li>
<li>
Open a database and use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command, adding table names and join conditions to the FROM clause.</li>
</ul>
<h4>Including Non-Matching Records in Results</h4>
<p>
If you want to include non-matching rows in your results, you can use an <a href="glsouter_join.htm">outer join</a>. For example, you might want a list of all customers and whether or not they have placed an order. In addition, for customers that have placed orders, you might want the order numbers included in the view. When you use an outer join, the empty <a href="glsfield.htm">fields</a> of the non-matching rows return <a href="glsnull_value.htm">null values</a>.</p>
<p>
You can also use the language to create this view by using the following code:</p>
<pre><code>OPEN DATABASE testdata
CREATE SQL VIEW cust_orders_view AS ;
 &nbsp; SELECT * FROM testdata!customer ;
 &nbsp;&nbsp;&nbsp;&nbsp; LEFT OUTER JOIN testdata!orders ;
 &nbsp;&nbsp;&nbsp;&nbsp; ON customer.cust_id = orders.cust_id
</code></pre>
<p>
To control which non-matching records are included in your view, you can choose from the following join types.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=63%><b>To</b></td>
<td class=label width=37%><b>Use</b></td>
</tr>
<tr valign=top>
<td width=63%>Return only records from both tables that match the comparison condition set between the two fields in the join condition.</td>
<td width=37%>Inner join</td>
</tr>
<tr valign=top>
<td width=63%>Return all records from the table to the left of the JOIN keyword and only matching records from the table to the right of the keyword.</td>
<td width=37%>Left outer join</td>
</tr>
<tr valign=top>
<td width=63%>Return all records from the table to the right of the JOIN keyword and only matching records from the table to the left of the keyword.</td>
<td width=37%>Right outer join</td>
</tr>
<tr valign=top>
<td width=63%>Return matching and non-matching records from both tables</td>
<td width=37%>Full outer join</td>
</tr>
</table><br>

<h4><a name="dgdefining_multiple_join_conditions"></a>Defining Multiple Join Conditions</h4>
<p>
If you create views or <a href="glsquery.htm">queries</a> with more than two tables, you can change the results by the order your join conditions are specified. For example, you might want to find information on the orders, including information on the employee who made the sale and the customer who placed the order. You can create a view using the <code>customer</code>, <code>orders</code>, and <code>employee</code> tables and specify inner join conditions on the fields they have in common: <code>customer</code> and <code>orders</code> both have a customer ID field; <code>orders</code> and <code>employee</code> both have an employee ID field.</p>
<p>
This view has the following underlying SQL statement:</p>
<pre><code>OPEN DATABASE testdata
CREATE SQL VIEW cust_orders_emp_view AS ;
 &nbsp; SELECT * FROM testdata!customer ;
 &nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN testdata!orders ;
 &nbsp;&nbsp;&nbsp;&nbsp; ON customer.cust_id = orders.cust_id ;
 &nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN testdata!employee ;
 &nbsp;&nbsp;&nbsp;&nbsp; ON orders.emp_id = employee.emp_id
</code></pre>
<h4>Using Joins in the WHERE Clause</h4>
<p>
You can specify your <a href="glsjoin_condition.htm">join conditions</a> in the WHERE clause; however, you cannot specify a join type as you can in joins in the FROM clause. For remote views, the join clause always appears in the WHERE clause.</p>
<p>
The following code creates the same view as the previous example, using the WHERE clause to specify the join conditions for the view:</p>
<pre><code>OPEN DATABASE testdata
CREATE SQL VIEW cust_orders_emp_view AS ;
 &nbsp; SELECT * FROM testdata!customer, ;
 &nbsp;&nbsp;&nbsp;&nbsp; testdata!orders, testdata!employee ;
 &nbsp; WHERE customer.cust_id = orders.cust_id ; 
 &nbsp; AND orders.emp_id = employee.emp_id
</code></pre>
<h3>Accessing Remote Data</h3>
<p>
When you want to use data located on a remote server, you create a <a href="glsremote_view.htm">remote view</a>. To create a remote view, you must first be able to connect to a <a href="glsdata_source.htm">data source</a>.</p>
<h4>Connecting to a Remote Data Source</h4>
<p>
A remote data source is typically a remote server for which you’ve installed an ODBC driver and set up an ODBC data source name. To have a valid <a href="glsdata_source.htm">data source</a>, you must ensure that <a href="glsopen_database_connectivity_odbc_.htm">ODBC</a> is installed. From within Visual FoxPro, you can define a data source and connections.</p>
<p>
For more information about setting up an ODBC data source, see Chapter 1, <a href="iginstalling_visual_foxpro.htm">Installing Visual FoxPro</a>, in the <i>Installation Guide</i>.</p>
<h4>Defining a Connection</h4>
<p>
In Visual FoxPro, you can create and store a <a href="glsnamed_connection.htm">named connection</a> definition in a <a href="glsdatabase.htm">database</a>, which you can then refer to by name when you create a <a href="glsremote_view.htm">remote view</a>. You can also set <a href="glsproperty.htm">properties</a> of the <a href="glsnamed_connection.htm">named connection</a> to optimize the communication between Visual FoxPro and the remote <a href="glsdata_source.htm">data source</a>. When you activate a remote view, the view’s <a href="glsconnection.htm">connection</a> becomes the pipeline to the remote data source.</p>
<p class=label>
<b>To create a named connection</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select <b>Connections</b>, and then choose <b>New</b> to open the <a href="wndconnection_designer.htm">Connection Designer</a>.<p class=tl>
-or-</P></li>
<li>
Open a database and use the <a href="lngcreate_connection.htm">CREATE CONNECTION</a> command to open the <b>Connection Designer</b>.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngcreate_connection.htm">CREATE CONNECTION</a> command with a connection name.</li>
</ul>
<p>
For example, to create a connection in the <code>testdata</code> database that stores the information needed to connect to the ODBC data source <code>sqlremote</code>, you can enter the following code:</p>
<pre><code>OPEN DATABASE testdata
CREATE CONNECTION remote_01 DATASOURCE sqlremote userid password
</code></pre>
<p>
Visual FoxPro displays <code>remote_01</code> as the name of the connection in the Project Manager.</p>
<p>
Creating a named connection in your database does not use any network or remote resources, because Visual FoxPro doesn’t activate the connection until you use the view. Until you activate the connection, the named connection merely exists as a connection definition stored as a row in the database’s .dbc file. When you use a remote view, Visual FoxPro uses the named connection referenced in the view to create a live connection to the remote data source, and then sends the request for data to the remote source using the active connection as the pipeline.</p>
<p>
You can optionally create a view that specifies only the name of the <a href="glsdata_source.htm">data source</a>, rather than a <a href="glsconnection.htm">connection</a> name. When you use the view, Visual FoxPro uses the <a href="glsopen_database_connectivity_odbc_.htm">ODBC</a> information about the data source to create and activate a connection to the data source. When you close the view, the connection is closed.</p>
<h4>Naming Precedence for Connections and Data Sources</h4>
<p>
When you use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command with the CONNECTION clause, you specify a name that represents either a <a href="glsconnection.htm">connection</a> or a <a href="glsdata_source.htm">data source</a>. Visual FoxPro first searches the current database for a connection with the name you specified. If no connection with the specified name exists in the database, then Visual FoxPro looks for an established ODBC data source with the specified name. If your current database contains a named connection with the same name as an ODBC data source on your system, Visual FoxPro will find and use the named connection.</p>
<h4>Displaying ODBC Login Prompts</h4>
<p>
When you use a view whose <a href="glsconnection.htm">connection</a> login information is not fully specified, Visual FoxPro might display a <a href="glsdata_source.htm">data source</a>-specific box that prompts you for the missing information.</p>
<p>
You can control whether Visual FoxPro prompts you for information that was left unspecified at connection time.</p>
<p class=label>
<b>To control the display of ODBC login prompts</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select the name of the connection, and then choose <b>Modify</b> to open the <a href="wndconnection_designer.htm">Connection Designer</a>.<br><br></li>
<li>
In the <b>Display ODBC login prompts</b> area, choose an option.<p class=tl>
-or-</P></li>
<li>
Use the DispLogin property of the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> or <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> functions.</li>
</ul>
<h4>Using an Existing Connection</h4>
<p>
You can use an existing <a href="glsnamed_connection.htm">named connection</a> to create a <a href="glsremote_view.htm">remote view</a>. You can see a list of the connections available in a database by using the Project Manager or the DISPLAY CONNECTIONS command.</p>
<p class=label>
<b>To determine existing connections</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select a database, and then select <b>Connections</b>.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngdisplay_connections.htm">DISPLAY CONNECTIONS</a> command.</li>
</ul>
<p>
For example, the following code displays the connections in the <code>testdata</code> database:</p>
<pre><code>OPEN DATABASE testdata
DISPLAY CONNECTIONS
</code></pre>
<h4>Creating a Remote View</h4>
<p>
Once you have a valid <a href="glsdata_source.htm">data source</a> or <a href="glsnamed_connection.htm">named connection</a>, you can create a <a href="glsremote_view.htm">remote view</a> using the Project Manager or the language. A remote view is similar to a <a href="glslocal_view.htm">local view</a>, but you add a connection or data source name when you define the view. The remote view’s SQL statement uses the native server dialect.</p>
<p class=label>
<b>To create a remote view</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select a database, select <b>Remote Views</b>, and then choose <b>New</b> to open the <a href="wndquery_designer.htm">View Designer</a>.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command with the REMOTE and/or the CONNECTION clause.</li>
</ul>
<p>
If you use the CONNECTION clause with the CREATE SQL VIEW command, you don’t need to include the REMOTE keyword. Visual FoxPro identifies the view as a remote view by the presence of the CONNECTION keyword. For example, if you have the <code>products</code> table from the Testdata database on a remote server, the following code creates a remote view of the <code>products</code> table:</p>
<pre><code>OPEN DATABASE testdata 
CREATE SQL VIEW product_remote_view ; 
 &nbsp; CONNECTION remote_01 ;
 &nbsp; AS SELECT * FROM products
</code></pre>
<p>
You can use a data source name rather than a connection name when you create a remote view. You can also choose to omit a connection or data source name when you use the CREATE SQL VIEW command with the REMOTE clause. Visual FoxPro then displays the Selection Connection or <a href="cmdselect_connection_or_datasource_dialog_box.htm">Data Source dialog box</a>, from which you can choose a valid connection or data source.</p>
<p>
After you create a view, you can open the <a href="wnddatabase_designer.htm">Database Designer</a> and see that the view is in the <a href="glsschema.htm">schema</a> displayed in the same manner as a table, with the view name and icon in place of a table name and icon.</p>
<p>
If you join two or more tables in the Remote View Designer, the Designer uses inner joins (or <a href="glsequi_join.htm">equi-joins</a>) and places the join condition in the WHERE clause. If you want to use an <a href="glsouter_join.htm">outer join</a>, the Remote View Designer provides only left outer joins, the <a href="glssyntax.htm">syntax</a> supported by ODBC. If you need right or full outer joins or just want to use a native syntax for a left outer join, create the view programmatically.</p>

<h2><a name="dgusing_views"></a>Using Views</h2>
<p>
After you’ve created a view, you can use the view to display and update data. You can also modify the <a href="glsproperty.htm">properties</a> of a view to increase view performance. You treat a view like a table:</p>
<ul type=disc>
<li>
Open the view with the <a href="lnguse.htm">USE</a> command and include the name of the view.</li>
<li>
Close the view with the USE command.</li>
<li>
Display view records in a <a href="wndbrowse_window.htm">Browse window</a>.</li>
<li>
Display open view aliases in the <a href="wnddata_session_window.htm">Data Session window</a>.</li>
<li>
Use the view as a <a href="glsdata_source.htm">data source</a>, such as in a text or Grid control, form, or report.</li>
</ul>
<p>
You can use a view through the Project Manager or the language.</p>
<p class=label>
<b>To use a view</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select a database, choose the name of the view, and then choose <b>Browse</b> to display the view in a <b>Browse</b> window.<p class=tl>
-or-</P></li>
<li>
Access the view programmatically with the <a href="lnguse.htm">USE</a> command.</li>
</ul>
<p>
The following code displays <code>product_view</code> in a Browse window:</p>
<pre><code>OPEN DATABASE testdata
USE product_view 
BROWSE
</code></pre>
<p>
When you use a view, the view is opened as a <a href="glscursor.htm">cursor</a> in its own <a href="glswork_area.htm">work area</a>. If the view is based on local tables, Visual FoxPro also opens the <a href="glsbase_table.htm">base tables</a> in separate work areas. The base tables for a view are the tables accessed by the SELECT - SQL&nbsp; statement you include in the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command when you create a view. In the previous example, using <code>product_view</code> automatically opens the <code>products</code> table as well.</p>
<p class=label>
<b>Data Session window displays the view and its base table</b></p>
<p>
<img src="afd08001.gif" border=0></p>
<p>
When a view is based on remote tables, the base tables are not opened in work areas. Only the name of the remote view appears in the Data Session window.</p>
<h3>Limiting the Scope of a View</h3>
<p>
When you access a remote <a href="glsdata_source.htm">data source</a>, you’re accessing potentially massive amounts of data. You can limit the scope of data selected into your view to be just the records you need at a given moment. This reduces network traffic and increases the performance of your view. For example, if you want to view information about customers in a particular country and their orders, you gain performance by downloading only the records for that country, rather than all customers, into your view.</p>
<p>
One method you can use to limit the scope of your view is to add a WHERE clause to your view’s SQL statement. If you want to look at the records for the customers in Sweden, you would create this SQL WHERE clause for your view:</p>
<pre><code>SELECT * FROM customer ;
 &nbsp; WHERE customer.country = 'Sweden'
</code></pre>
<p>
This code would effectively limit the scope of your view by downloading records for just the Swedish customers, but it would also require that you create a separate view for each country, because the actual value for one country’s <code>customer.country</code> is hard-coded into your view’s SELECT statement.</p>
<h4>Creating a Parameterized View</h4>
<p>
You can limit the scope of a view without creating a separate view for each subset of records by creating a parameterized view. A parameterized view creates a WHERE clause in the view’s SQL SELECT statement that limits the records downloaded to only those records that meet the conditions of the WHERE clause built using the value supplied for the parameter. This value can be supplied at run time, or passed programmatically to the view.</p>
<p>
In the case of the previous example, you can create one view that allows you to download records for any country, simply by entering the country’s name as you use the view.</p>
<p class=label>
<b>To create a parameterized view</b>
<ul type=disc>
<li>
In the <a href="wndquery_designer.htm">View Designer</a>, choose <b>View Parameters</b> from the <b>Query</b> menu.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command with a “?” symbol and a <a href="glsparameter.htm">parameter</a>.</li>
</ul>
<p>
The parameter you supply is evaluated as a Visual FoxPro <a href="glsexpression.htm">expression</a> and the value is sent as part of the view’s SQL statement. If the evaluation fails, Visual FoxPro prompts for the parameter value. For example, if you have the <code>customer</code> table from the Testdata database on a remote server, the following code creates a parameterized remote view that limits the view to those customers whose country matches the value supplied for the <code>?cCountry</code> parameter:</p>
<pre><code>OPEN DATABASE testdata
CREATE SQL VIEW customer_remote_view ;
 &nbsp; CONNECTION remote_01 ;
 &nbsp; AS SELECT * FROM customer ;
 &nbsp; WHERE customer.country = ?cCountry
</code></pre>
<p>
You can supply a value for <code>?cCountry</code> programmatically when you use the view. For example, you could type the following code:</p>
<pre><code>cCountry = 'Sweden'
USE Testdata!customer_remote_view IN 0
BROWSE
</code></pre>
<p>
Visual FoxPro displays the customer records for Swedish companies in the Browse window for <code>Customer_remote_view</code>.</p>
<p class=label>
<b>View displaying records whose country matches the supplied parameter</b></p>
<p>
<img src="afd08002.gif" border=0></p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If your <a href="glsparameter.htm">parameter</a> is an <a href="glsexpression.htm">expression</a>, enclose the parameter expression in parentheses. This allows the entire expression to be evaluated as part of the parameter.</p>
<h4>Prompting for User Input of a Parameter Value</h4>
<p>
If your <a href="glsparameter.htm">parameter</a> is not a <a href="glsvariable.htm">variable</a> or <a href="glsexpression.htm">expression</a>, you might want to prompt the user to supply the parameter value by using a quoted string as your view parameter. When you create a view parameter using a quoted string after the “?” symbol, Visual FoxPro does not interpret the string as an expression. Rather, you are prompted to enter the value for the parameter at <a href="glsrun_time.htm">run time</a>. For example, the following code creates a parameterized remote view that prompts the user to supply a value for the <code>?'my customer id'</code> parameter:</p>
<pre><code>OPEN DATABASE testdata
CREATE SQL VIEW customer_remote_view ;
 &nbsp; CONNECTION remote_01 ;
 &nbsp; AS SELECT * FROM customer ;
 &nbsp; WHERE customer.cust_id = ?'my customer id'
USE customer_remote_view
</code></pre>
<p>
When you use the view in the previous example, the View Parameter dialog box is displayed.</p>
<p class=label>
<b>View Parameter dialog box prompts for the value in quoted string</b></p>
<p>
<img src="afd08003.gif" border=0></p>
<p>
After you enter a valid customer ID, Visual FoxPro retrieves the record that matches that ID. If you enter the value “ALFKI” in the previous example and then browse <code>Customer_remote_view</code>, you see the customer record displayed in the Browse window.</p>
<p class=label>
<b>Browse window displaying record for cust_id ALFKI</b></p>
<p>
<img src="afd08004.gif" border=0></p>
<p>
By using a quoted string as a view parameter, you ensure that Visual FoxPro will always prompt the user for the parameter value.</p>
<h3>Opening Multiple Instances of a View</h3>
<p>
You can open multiple instances of a view in separate <a href="glswork_area.htm">work areas</a>, just as you can open a table in more than one work area. Unlike <a href="glstable.htm">tables</a>, views fetch a new data set by default each time you use the view.</p>
<p class=label>
<b>To open a view in multiple work areas</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, choose the name of the view, and then choose <b>Browse</b> to display the view in a <b>Browse</b> window. Repeat this process to open the view in additional work areas.<p class=tl>
-or-</P></li>
<li>
In the <a href="wnddata_session_window.htm">Data Session</a> window, choose <b>Open</b>, and then the name of the view. Repeat this process to open the view in additional work areas.<p class=tl>
-or-</P></li>
<li>
Access the view programmatically with the <a href="lnguse.htm">USE</a> command.</li>
</ul>
<p>
When you access the view programmatically with the USE command, you can choose to open another <a href="glsinstance.htm">instance</a> of a view without requerying the <a href="glsdata_source.htm">data source</a>. This is particularly useful when you want to open a remote view in multiple <a href="glswork_area.htm">work areas</a> without waiting for data to be downloaded from a remote data source.</p>
<p class=label>
<b>To use a view again without downloading data</b>
<ul type=disc>
<li>
Use the NOREQUERY clause with the USE command.<p class=tl>
-or-</P></li>
<li>
Use the AGAIN clause with the <a href="lnguse.htm">USE</a> command.</li>
</ul>
<p>
The following code uses the NOREQUERY clause to display the <a href="glscursor.htm">cursor</a> fetched from the first <a href="glsinstance.htm">instance</a> of <code>product_remote_view</code> in two Browse windows without requerying the remote <a href="glsdata_source.htm">data source</a>:</p>
<pre><code>OPEN DATABASE testdata
CREATE SQL VIEW product_remote_view ;
 &nbsp; CONNECTION remote_01 ;
 &nbsp; AS SELECT * FROM products
USE product_remote_view
BROWSE
SELECT 0
USE product_remote_view NOREQUERY
BROWSE
</code></pre>
<p>
You can specify a session number with the NOREQUERY clause. If you don’t specify a session number, Visual FoxPro searches in all <a href="glssession_visual_foxpro.htm">sessions</a>. If an opened result set is found for the view, a <a href="glscursor.htm">cursor</a> is opened again on the same result set. If no open result set is found, a new result set is fetched for the view. As is true for tables, if the view is not found, a new view cursor is opened for you.</p>
<p>
If you want Visual FoxPro to search only the current session for an opened result set for your view, you can use the AGAIN clause. The following code displays <code>product_remote_view</code> in two Browse windows:</p>
<pre><code>OPEN DATABASE testdata
USE product_remote_view
BROWSE
USE product_remote_view AGAIN in 0
BROWSE
</code></pre>
<p>
When you use the AGAIN clause, Visual FoxPro looks for an existing view <a href="glscursor.htm">cursor</a> in the current session, and opens an additional <a href="glsalias.htm">alias</a> pointing to this view cursor. Opening another instance of a view with the AGAIN clause is the equivalent of issuing a <a href="lnguse.htm">USE</a> with the NOREQUERY clause with the current session number.</p>
<h3>Displaying the Structure of a View</h3>
<p>
You can open and display just the structure of a view with the NODATA clause of the USE command. This option is particularly useful when you want to look at the structure of a <a href="glsremote_view.htm">remote view</a> without waiting to download data.</p>
<p class=label>
<b>To open a view without data</b>
<ul type=disc>
<li>
Access the view programmatically with the <a href="lnguse.htm">USE</a> command and the NODATA clause.</li>
</ul>
<p>
The following code displays <code>customer_remote_view</code> without data in a Browse window:</p>
<pre><code>OPEN DATABASE testdata
USE customer_remote_view NODATA in 0
BROWSE
</code></pre>
<p>
Using a view with the NODATA clause always opens a new view <a href="glscursor.htm">cursor</a>. The NODATA clause is the fastest way to get the view’s structure because it creates the smallest cursor possible on the remote data source. When you use the NODATA clause, Visual FoxPro creates a WHERE clause for the view that always returns a false value. Because no records on the <a href="glsdata_source.htm">data source</a> can meet the WHERE clause condition, no rows are selected into the remote data source’s cursor. Your view is retrieved quickly because you’re not waiting for the remote data source to build a potentially large cursor.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Using the NODATA clause is more efficient than using a MaxRecords property setting of 0 on your view or cursor. When you use the MaxRecords property, you must wait while the remote data source builds a cursor for the view containing all data rows that meet the view’s normal WHERE clause conditions. Rows from the full remote view cursor are then downloaded according to the setting of the MaxRecords property.</p>
<h3>Creating an Index on a View</h3>
<p>
You can create local <a href="glsindex.htm">indexes</a> on a view, just as on a table, using the <a href="lngindex.htm">INDEX</a> ON command. Unlike indexes you build on a <a href="glstable.htm">table</a>, local indexes you create on a view are not stored persistently: they vanish when you close the view.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Consider the size of your view’s result set when deciding whether to create a local index on a view. Indexing a large result set can take a long time, and slow down performance of your view.</p>
<p>
For more information on creating indexes, see Chapter 7, <a href="dgworking_with_tables.htm">Working with Tables</a>, or see <a href="lngindex.htm">INDEX</a>.</p>
<h3>Creating Temporary Relationships on Views</h3>
<p>
You can create <a href="glstemporary_relationship.htm">temporary relationships</a> between view indexes or between view indexes and table indexes with the <a href="lngset_relation.htm">SET RELATION</a> command.</p>
<p>
For better performance, when you use the SET RELATION command to relate a view and a table, make the view the parent and the table the child in the relationship. Making the table the child is more efficient because the structural index of the table is constantly maintained, quickly accessed, and can be used by the <a href="glsdata_environment.htm">data environment</a> to order the records. The index on the view must be rebuilt each time the view is activated and takes more time than the index on the table. An index on a view is not part of the view definition; so, if you use a data environment, the view cannot be the child because the index on the child has to exist as part of the definition, which views don’t support.</p>

<h3><a name="dgsetting_view_and_connection_properties"></a>Setting View and Connection Properties</h3>
<p>
When you create a view, the view inherits property settings, such as UpdateType and UseMemoSize, from the environment cursor, or cursor 0 of the current <a href="glssession_visual_foxpro.htm">session</a>. You can change these default property settings by using the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function with 0 as the cursor number. After the view has been created and is stored in a database, you can change view properties with the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function. The changes you make to view properties in a database are stored persistently in the database.</p>
<p>
When you use a view, the property settings stored for the view in the database are inherited by the active view cursor. You can change these properties on the active cursor using the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function for the view cursor. Changes you make with the CURSORSETPROP(&nbsp;) function are temporary. The temporary settings for the active view disappear when you close the view; the temporary settings for cursor 0 go away when you close the Visual FoxPro session.</p>
<p>
<a href="glsconnection.htm">Connections</a> inherit properties in a similar fashion. Default properties for connection 0 are inherited when you create and store a <a href="glsnamed_connection.htm">named connection</a> in a database. You can change these default property settings for connection 0 with the <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> function. After the connection has been created and is stored in a database, you can change connection properties with the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function. When you use a connection, the property settings stored for the connection in the database are inherited by the active connection. You can change these properties on the active connection using the <a href="lngsqlsetproplp_rp.htm">SQLSETPROP(&nbsp;)</a> function for the connection handle.</p>
<p>
Both <a href="glsview.htm">views</a> and <a href="glsconnection.htm">connections</a> can use a named ODBC <a href="glsdata_source.htm">data source</a>. If you use an ODBC data source in a view, the connection inherits properties from the <a href="glssession_visual_foxpro.htm">session</a> defaults.</p>
<p>
The following diagram illustrates property inheritance for views and connections. The gray lines represent the flow of property inheritance; the black lines represent Visual FoxPro commands.</p>
<p class=label>
<b>View and Connection properties and their inheritance</b></p>
<p>
<img src="afd08005.gif" border=0></p>

<h4><a name="dgchanging_default_data_types_when_downloading_remote_views"></a>Changing Default Data Types When Downloading Remote Views</h4>
<p>
When you create a view, the DataType property for all fields in the view is set to a default value. The value is the data type letter (D, G, I, L, M, P, T, Y) for fixed-length data types and the letter followed by precision and scale parameters in parentheses (B(<i>d</i>), C(<i>n</i>), N(<i>n,d</i>)) for variable length types. This property is read-only for local views. For a list of default data types, see “Downloading and Uploading Remote View Data” in Chapter 21, <a href="dgimplementing_a_client_server_application.htm">Implementing a Client/Server Application</a>.</p>
<p>
You can modify the setting of the DataType property for the remote view field with the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function as shown in this table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=37%><b>ODBC data type of <br>
remote field</b></td>
<td class=label width=63%><b>Possible data types in Visual FoxPro cursor</b></td>
</tr>
<tr valign=top>
<td width=37%>SQL_CHAR<br>
SQL_VARCHAR<br>
SQL_LONGVARCHAR</td>
<td width=63%>Character or Memo<sup>1</sup> (default); also General or Picture </td>
</tr>
<tr valign=top>
<td width=37%>SQL_BINARY<br>
SQL_VARBINARY<br>
SQL_LONGVARBINARY</td>
<td width=63%>Memo (default); also Character, General, or Picture</td>
</tr>
<tr valign=top>
<td width=37%>SQL_DECIMAL<br>
SQL_NUMERIC</td>
<td width=63%>Numeric or Currency<sup>2 </sup>(default); also Character, Integer, or Double</td>
</tr>
<tr valign=top>
<td width=37%>SQL_BIT</td>
<td width=63%>Logical (default); also Character</td>
</tr>
<tr valign=top>
<td width=37%>SQL_TINYINT<br>
SQL_SMALLINT<br>
SQL_INTEGER</td>
<td width=63%>Integer (default); also Character, Numeric, Double, or Currency</td>
</tr>
<tr valign=top>
<td width=37%>SQL_BIGINT</td>
<td width=63%>Character (default); also Integer, Numeric, Double, or Currency</td>
</tr>
<tr valign=top>
<td width=37%>SQL_REAL<br>
SQL_FLOAT<br>
SQL_DOUBLE</td>
<td width=63%>Double (default); the number of decimal places is the value of SET DECIMALS in Visual FoxPro; also Character, Integer, Numeric, or Currency </td>
</tr>
<tr valign=top>
<td width=37%>SQL_DATE</td>
<td width=63%>Date (default); also Character or DateTime</td>
</tr>
<tr valign=top>
<td width=37%>SQL_TIME</td>
<td width=63%>DateTime<sup>3</sup> (default); also Character</td>
</tr>
<tr valign=top>
<td width=37%>SQL_TIMESTAMP</td>
<td width=63%>DateTime<sup>4</sup> (default); also Character or Date</td>
</tr>
</table><br>
<p class=mini>
1. If the ODBC field width is less than the value of the cursor property UseMemoSize, it becomes a Character field in the Visual FoxPro cursor; otherwise, it becomes a Memo field.</p>
<p class=mini>
2. If the server field is a money data type, it becomes a Currency data type in Visual FoxPro.</p>
<p class=mini>
3. The day defaults to 1/1/1900.</p>
<p class=mini>
4. If the value in the SQL_TIMESTAMP field contains fractions of seconds, the fractions are truncated when the value is converted to a Visual FoxPro DateTime data type.</p>
<h4>Using the DataType Property</h4>
<p>
You can use the DataType property to choose a different <a href="glsdata_type.htm">data type</a> than the default. For example, you might want to download a server timestamp field to Visual FoxPro, but the default data type mapping into a Visual FoxPro DateTime field would truncate any fractions of seconds stored in the server timestamp. You might use the DataType property to map the remote timestamp field into a Visual FoxPro character field to preserve the fractions of seconds.</p>
<h3>Closing a View’s Base Tables</h3>
<p>
The local <a href="glsbase_table.htm">base tables</a> opened automatically when you use a view are not automatically closed when you close a view; you must explicitly close them. This is consistent with the SELECT - SQL command. </p>

<h2><a name="dgupdating_data_in_a_view"></a>Updating Data in a View</h2>
<p>
You update data in a view just as you would update data in a table. With a view you can also update the view’s <a href="glsbase_table.htm">base tables</a>. Views are, by default, buffered with optimistic row buffering. You can change this to table buffering; for more information on buffering, see Chapter 17, <a href="dgprogramming_for_shared_access.htm">Programming for Shared Access</a>.</p>
<p>
You can update data in a view through the interface or the language. The first step in updating view data is to make the view updatable. In most cases, the default property settings automatically prepare the view to be updatable, but updates are not sent to the data source until you instruct Visual FoxPro to do so by setting the SendUpdates property to On.</p>
<p>
A view uses five properties to control updates. These properties are listed here with their default settings:</p>
<p class=label>
<b>View Update Properties and Default Settings</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>View Property</b></td>
<td class=label width=73%><b>Default Setting</b></td>
</tr>
<tr valign=top>
<td width=27%>Tables</td>
<td width=73%>Includes all tables that have updatable fields and have at least one primary key field.</td>
</tr>
<tr valign=top>
<td width=27%>KeyField</td>
<td width=73%>Database key fields and remote <a href="glsprimary_key.htm">primary keys</a> on the table.</td>
</tr>
<tr valign=top>
<td width=27%>UpdateName</td>
<td width=73%>Table_name.column_name for all fields.</td>
</tr>
<tr valign=top>
<td width=27%>Updatable</td>
<td width=73%>All fields except the primary key fields.</td>
</tr>
<tr valign=top>
<td width=27%>SendUpdates</td>
<td width=73%>Defaults to the session default, which is originally set to false (.F.); if you change it to true (.T.), that becomes the default for all views created in the session.</td>
</tr>
<tr valign=top>
<td width=27%>CompareMemo</td>
<td width=73%>Defaults to true (.T.), means that memo fields are included in the WHERE clause and used for detecting update conflicts.</td>
</tr>
</table><br>
<p>
While all five properties are required to update data, the SendUpdates property serves as a “master switch” controlling whether or not updates are sent. As you develop your application, you might set the SendUpdates property off and then configure the other properties to enable updates to the fields you want updated. When you’re ready to test your application, you can set the SendUpdates property on to start updates flowing.</p>
<p>
In some more complex situations, the default update settings may not provide updates for a view you create through the language. To enable updates, look at the default settings for each of the update properties and adjust them as needed. You can also specify additional properties, such as UpdateType, WhereType, and so on, according to your preferences. For a complete list of view properties, see <a href="lngdbgetproplp_rp.htm">DBGETPROP(&nbsp;)</a>.</p>
<p class=label>
<b>To make a view updatable from the View Designer</b>
<ul type=disc>
<li>
In the <a href="wndquery_designer.htm">View Designer</a>, select the <b>Update Criteria</b> tab and verify the default settings.</li>
</ul>
<p>
The default settings for views you create through the View Designer usually prepare the view to be updatable; you only need to select the Send SQL Updates check box to turn updates on. You can further modify the tables, fields, SQL WHERE clause, and Update options as you desire.</p>
<p class=label>
<b>To make a view updatable by setting view update properties</b>
<ul type=disc>
<li>
Examine the current default settings with the <a href="lngdisplay_database.htm">DISPLAY DATABASE</a> command, and then modify properties for the view definition as you desire with the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function.</li>
</ul>
<p>
The following example lists the steps you would follow to specify the five view update properties programmatically:</p>
<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The default View properties may supply all the information needed to update your view.</p><ol>
<li>
Set the Tables property with at least one table name.<p class=tl>
For example, if you have a view based on the <code>customer</code> table called <code>cust_view</code> , you could set the table name with the following function:</P><pre><code>DBSETPROP('cust_view','View','Tables','customer')
</code></pre>
<p class=atl>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If a table appears as a qualifier in the UpdateName property but is not included in the default list for the Tables property, the table might not have a primary key field specified. Make the table updatable by adding the field you consider to be a key field to the KeyField property list, and then add the table to the Tables property list.</p></li>
<li>
Set the KeyField property with one or more local Visual FoxPro field names that together define a unique key for the update table.<p class=tl>
Using the same example, you could make <code>cust_id</code> the key field using the following code:</P><pre><code>DBSETPROP('cust_view.cust_id','Field','KeyField',.T.)
</code></pre>
<p class=atl>
<B><b>Caution</b></B>&nbsp;&nbsp;&nbsp;Be sure the key field(s) you specify define a unique key both in the base table you want to update and in the view.</p></li>
<li>
Map the view fields to their base table fields with the UpdateName property. This property is particularly useful when your view is based on a join of two tables with a common field name, or when the fields are aliased in the view. To update the desired base table, you map the Visual FoxPro view field name to the base table field and table name.<pre><code>DBSETPROP('cust_view.cust_id','Field','UpdateName',;
'customer.cust_id')
</code></pre>
<p class=atl>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;To avoid creating synonym fields in your view, you can qualify field names in the SQL statement you use to build your view. Then use the Visual FoxPro UpdateName property of the view to map each qualified field to the correct base table and field name.</p></li>
<li>
Specify the scope of fields you want to update with the Updatable property. You should specify only those fields also specified with the UpdateName property.<pre><code>DBSETPROP('cust_view.cust_id','Field','Updatable',;
.T.)
</code></pre>
</li>
<li>
Set the SendUpdates property to true (.T.). This is the master switch that instructs Visual FoxPro to create and send updates to any of the tables and fields you’ve specified as updatable.<pre><code>DBSETPROP('cust_view','View','SendUpdates',.T.)
</code></pre>
</li>
</ol>
<p>
When you use <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> to set properties on a view before you use the view, the settings are stored in the database and are used automatically whenever you activate the view. Once the view is active, you can use <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> to change property settings on the active view. Property settings you set on an active view with CURSORSETPROP(&nbsp;) are not saved when you close the view.</p>
<h3>Updating Multiple Tables in a View</h3>
<p>
You can update multiple base tables from a view. When your view combines two or more tables, you set properties to ensure that only the many side of the view query is updatable.</p>
<p>
Views are updated on a table-by-table basis. You must ensure that for each table accessed in a view, the key field set is a unique key for both the view result set and the base table.</p>
<p class=label>
<b>To make a multitable view updatable</b>
<ul type=disc>
<li>
In the <a href="wndquery_designer.htm">View Designer</a>, choose the <b>Update Criteria</b> tab, and then select the tables and field names you want to update.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function.</li>
</ul>
<p>
In most cases, the default values provided by Visual FoxPro prepare a multitable view to be updatable, even when you create the view programmatically. The following code example creates and explicitly sets properties to update a two-table view. You can use this example as a guide for customizing update property settings on a view.</p>
<p class=label>
<b>Updating Multiple Tables in a View</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=66%><b>Code</b></td>
<td class=label width=34%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=66%><pre><code>CREATE SQL VIEW emp_cust_view AS ;
 &nbsp; SELECT employee.emp_id, ;
 &nbsp; employee.phone, customer.cust_id, ;
 &nbsp; customer.emp_id, customer.contact, ;
 &nbsp; customer.company ;
 &nbsp; FROM employee, customer ;
 &nbsp; WHERE employee.emp_id = customer.emp_id</code></pre>
</td>
<td width=34%>Create a view that accesses fields from two tables.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>DBSETPROP('emp_cust_view', 'View', 'Tables',
'employee, customer')</code></pre>
</td>
<td width=34%>Set the tables to be updated.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>DBSETPROP('emp_cust_view.emp_id', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdateName', 'employee.emp_id')
DBSETPROP('emp_cust_view.phone', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdateName', 'employee.phone')
DBSETPROP('emp_cust_view.cust_id', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdateName', 'customer.cust_id')
DBSETPROP('emp_cust_view.emp_id1', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdateName', 'customer.emp_id')
DBSETPROP('emp_cust_view.contact', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdateName', 'customer.contact')
DBSETPROP('emp_cust_view.company', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdateName', 'customer.company')</code></pre>
</td>
<td width=34%>Set update names.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>DBSETPROP('emp_cust_view.emp_id', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'KeyField', .T.)</code></pre>
</td>
<td width=34%>Set a single-field unique key for the Employee table.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>DBSETPROP('emp_cust_view.cust_id', 'Field', ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'KeyField', .T.)</code><pre><code>DBSETPROP('emp_cust_view.emp_id1', 'Field', ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'KeyField', .T.)</code></pre>
</pre>
</td>
<td width=34%>Set a two-field unique key for the Customer table.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>DBSETPROP('emp_cust_view.phone', 'Field', ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdatableField', .T.)</code><pre><code>DBSETPROP('emp_cust_view.contact', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdatableField', .T.)
DBSETPROP('emp_cust_view.company', 'Field', ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'UpdatableField', .T.)</code></pre>
</pre>
</td>
<td width=34%>Set the updatable fields. Typically, key fields are not updatable.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>DBSETPROP('emp_cust_view', 'View', ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'SendUpdates', .T.)</code></pre>
</td>
<td width=34%>Activate the update functionality.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>GO TOP</code><pre><code>REPLACE employee.phone WITH "(206)111-2222"
REPLACE customer.contact WITH "John Doe"</code></pre>
</pre>
</td>
<td width=34%>Modify data in the view.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>TABLEUPDATE()</code></pre>
</td>
<td width=34%>Commit the changes by updating both the Employee and Customer base tables.</td>
</tr>
</table><br>
<h3>Customizing Views with the Data Dictionary</h3>
<p>
Because views are stored in a database, you can create:</p>
<ul type=disc>
<li>
<a href="glscaption.htm">Captions</a></li>
<li>
Comments for the view and view fields</li>
<li>
<a href="glsdefault_value.htm">Default values</a> for view fields</li>
<li>
Field- and row-level <a href="glsrule.htm">rules</a> and rule error messages</li>
</ul>
<p>
The data dictionary features for views are similar in function to their counterparts for database tables. However, you use the language rather than the Table Designer to create captions, comments, default values and rules for views.</p>
<h3>Creating Default Values for View Fields</h3>
<p>
Like default values for table fields, view field <a href="glsdefault_value.htm">default values</a> are stored in the database and are available each time you use the view. Visual FoxPro doesn’t compare the default values you create locally with any default values established on the remote <a href="glsdata_source.htm">data source</a>. You must create default values that are acceptable for the data source.</p>
<p class=label>
<b>To assign a default value to a view field</b>
<ul type=disc>
<li>
In the <a href="cmdquery_and_view_designers_fields_tab.htm">Fields</a> tab in the <b>View Designer</b>, select a field, and then choose <b>Properties</b> and enter the default value for the field.<p class=tl>
-or-</P></li>
<li>
Use the DefaultValue property of the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function.</li>
</ul>
<p>
For example, you may want your application to limit the amount of merchandise a new customer can order until you’ve had time to complete a credit check and determine the amount of credit you’re willing to extend to that customer. The following example creates a <code>maxordamt</code> field with a default value of 1000:</p>
<pre><code>OPEN DATABASE testdata
USE VIEW customer_view
?DBSETPROP ('Customer_view.maxordamt', 'Field', 'DefaultValue', 1000)
</code></pre>
<p>
You might also use <a href="glsdefault_value.htm">default values</a> to populate some rows automatically for the user. For example, you might add a <a href="ctlgrid_control.htm">Grid control</a> to an order entry form that is based on a remote view of an order line items table. The order_id field is the key field that maps each row of the Grid to its counterpart in the remote order line items table. Because the order ID for each row in the grid will be the same for one order, you can use a default value to save keystrokes by populating the <code>order_id</code> field automatically.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If one of your application’s business rules requires that a field contain an entry, providing a default value helps to ensure that a particular <a href="glsfield_level_rule.htm">field-level</a> or <a href="glsrecord_level_rule.htm">record-level</a> rule will not be violated.</p>
<h3>Creating Rules on View Fields and Rows</h3>
<p>
You can create local versions of remote data source rules to:</p>
<ul type=disc>
<li>
Reduce response time.</li>
<li>
Reduce impact on network resources.</li>
<li>
Test data before sending it to the remote data source.</li>
<li>
Prevent sending faulty data to the remote data source.</li>
</ul>
<p>
Visual FoxPro doesn’t compare the rules you create locally with remote rules. You must create <a href="glsrule.htm">rules</a> that are acceptable for the <a href="glsdata_source.htm">data source</a>. If remote rules change, you must change your local rules to match.</p>
<p class=label>
<b>To create a rule on a view field or row</b>
<ul type=disc>
<li>
In the <a href="cmdquery_and_view_designers_fields_tab.htm">Fields</a> tab in the <b>View Designer</b>, select a field, and then choose <b>Properties</b> and enter the rule expression and message text for the field.<p class=tl>
-or-</P></li>
<li>
Use the RuleExpression and RuleText properties of the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function.</li>
</ul>
<p>
For example, the following code creates a field-level rule on <code>orditems_view</code> that prevents entering a quantity of less than 1:</p>
<pre><code>OPEN DATABASE testdata
USE VIEW orditems_view
DBSETPROP('Orditems_view.quantity','Field', ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'RuleExpression', 'quantity &gt;= 1')
DBSETPROP('Orditems_view.quantity','Field', ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'RuleText', ;
'"Quantities must be greater than or equal to 1"')
</code></pre>
<p>
You can also use the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function to create row-level rules.</p>

<h2><a name="dgcombining_views"></a>Combining Views</h2>
<p>
You can build a view that is based on other views. You might want to do this if you need a subset of the information available in multiple other views, or if you want to combine local and remote data in a single view. A view based on other views, or on a combination of local tables and local or remote views, is called a <a href="glsmulti_tiered_view.htm">multitiered view</a>. The view that combines other views is the top-level view. You can have multiple levels of views in between the top-level view and the local or remote base tables. When you use a multitiered view, the views on which the top-level view is based and any Visual FoxPro base tables used in the top-level or intermediate-level views appear in the <a href="wnddata_session_window.htm">Data Session window</a>. Remote tables do not appear in the Data Session window.</p>

<h3><a name="dgcombining_local_and_remote_data_in_a_view"></a>Combining Local and Remote Data in a View</h3>
<p>
You can combine local and remote data in a view by creating a new local view based on a local view and a remote view.</p>
<p class=label>
<b>To create a view that combines local and remote data</b>
<ul type=disc>
<li>
In the <a href="wndproject_manager.htm">Project Manager</a>, select a database, choose <b>Local Views</b>, and choose <b>New</b> to open the <a href="wndquery_designer.htm">View Designer</a>. Add any combination of tables, local views, and remote views into your view.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command.</li>
</ul>
<p>
For example, to create a local view that combines information from the local Employee table and the remote Orders table, you can use the following code:</p>
<pre><code>OPEN DATABASE testdata 
CREATE SQL VIEW remote_orders_view ;
 &nbsp; CONNECTION remote_01 ;
 &nbsp; AS SELECT * FROM orders
CREATE SQL VIEW local_employee_remote_orders_view ;
 &nbsp; AS SELECT * FROM testdata!local_employee_view, ;
 &nbsp; testdata!remote_orders_view ;
 &nbsp; WHERE local_employee_view.emp_id = ;
 &nbsp;&nbsp;&nbsp;&nbsp; remote_orders_view.emp_id
</code></pre>
<h3>Updating Local and Remote Data in a View</h3>
<p>
When you update data in a <a href="glsmulti_tiered_view.htm">multitiered view</a>, the updates go down one level, to the view on which the top-level view is based. If you want to update the <a href="glsbase_table.htm">base tables</a> on which a multitiered view is built, you must issue a <a href="lngtableupdatelp_rp.htm">TABLEUPDATE</a> command for each view in the structure.</p>

<h2><a name="dgworking_with_offline_data"></a>Working with Offline Data</h2>
<p>
There are times when you might want to display, collect, or modify data independent of the host database. By using the offline view features in Visual FoxPro, you can use views to connect to a host database and create a subset of data for use offline. Then, working offline, you can use the view directly or through an application you create. When you are done, you can upload the changes stored in the view back to the host database.</p>
<p>
Some scenarios where offline views are useful include:</p>
<ul type=disc>
<li>
A data warehousing situation, where large databases are maintained centrally on MIS servers. If you are only interested in data pertaining to, for example, the Marketing department, you can construct a view including only the data that is relevant to you. You can then take the data offline, allow multiple users in the Marketing department to update the data, then commit the changed data to the source database.</li>
<li>
A geographically remote location which requires that you take a subset of data with you on a laptop, modify the data independently of the host database, then update the host database with the changed data at a later time.</li>
<li>
Time-sensitive data. For example, you might want to update data reflecting employee pay raises before the new pay rates actually take effect.</li>
</ul>
<p class=label>
<b>Working with offline views</b></p>
<p>
<img src="afd08006.gif" border=0></p>
<p>
To create and use view data offline, you can use the following language features:</p>
<ul type=disc>
<li>
The <a href="lngcreateofflinelp_rp.htm">CREATEOFFLINE(&nbsp;)</a> function</li>
<li>
The <a href="lnguse.htm">USE</a> <i>SQLViewName</i> command with the ADMIN and ONLINE clauses</li>
<li>
The <a href="lngtableupdatelp_rp.htm">TABLEUPDATE</a> function</li>
<li>
The <a href="lngdropofflinelp_rp.htm">DROPOFFLINE(&nbsp;)</a> function</li>
</ul>
<p>
If you plan to use the offline view on a machine other than the one on which you created the offline view, you must prepare the offline destination by creating a copy of the host database file (.dbc); making sure the ODBC data source used by the view exists on the destination machine; and analyzing your data requirements to determine the contents of the view you need.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Use the ODBC Administrator program to install data sources on a machine. You can access the ODBC Administrator program from either the Visual FoxPro program group or from Control Panel.</p>
<h3>Creating Offline Views</h3>
<p>
As with online data, analyze your requirements before creating offline views to determine the design of the views you will need in the offline database. Once you know the subset of data you want to use offline, you can start with an existing view or create a new view. If a view already exists that returns the records you want to use offline, you can use it, or you can create one programmatically. The view you take offline is stored in a .dbf file in the offline database container.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you plan to modify data in an offline view, be sure to make the view updatable before you take it offline. Once a view is offline, you can only set its update properties programmatically; you cannot modify an offline view in the <a href="wndquery_designer.htm">View Designer</a>.</p>
<p class=label>
<b>To use an existing view offline</b>
<ul type=disc>
<li>
Use the <a href="lngcreateofflinelp_rp.htm">CREATEOFFLINE(&nbsp;)</a> function and the name of the view.</li>
</ul>
<p>
For example, if you want to go to client sites to update accounts, add customers, and record new sales, you need the customer information as well as current orders and the online product descriptions. You might have a view called <code>customerinfo</code> that combines information from the Customers table, Orders table, and OrderItems table. To create the view, use this code:</p>
<pre><code>CREATEOFFLINE("customerinfo")
</code></pre>
<p class=label>
<b>To programmatically create a view offline</b>
<ul type=disc>
<li>
Use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command, followed by the <a href="lngcreateofflinelp_rp.htm">CREATEOFFLINE(&nbsp;)</a> command.</li>
</ul>
<p>
For example, the following code creates a view that displays data from the <code>Products</code> table and the <code>Inventory</code> table from the online database. Since no update criteria are specified, this view is read-only:</p>
<pre><code>CREATE SQL VIEW showproducts ;
 &nbsp; CONNECTION dsource ;
 &nbsp; AS SELECT * FROM Products INNER JOIN Inventory ;
 &nbsp; ON Products.ProductID = Inventory.ProductID ;
CREATEOFFLINE("showproducts")</code></pre>
<h3>Displaying and Modifying Offline Data</h3>
<p>
After you create the view for your offline data, you can use it as you would any view in your application: you can add, change, and delete records. Multiple users can access the offline view concurrently using the same database in shared mode. If you decide you do not want to keep any of the changes, you can revert the information to reflect the original information.</p>
<h4>Using Data Offline</h4>
<p>
Using the offline view, you can display and update data much as you do online with the same forms, reports, or applications. For example, the following code opens the view <code>Showproducts</code>:</p>
<pre><code>USE Showproducts
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If you are not getting the subset of data that you expected, check the optimization settings for the remote view. If you set the MaxRecords property using the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> function, only that many records appear in your views offline. However, if you include a Memo field in the field list of your view, it is automatically included in the result set even if FetchMemo is set to false (.F.).</p>
<h4>Administering Data Offline</h4>
<p>
In some cases — especially in a multiple-user environment where data is modified by numerous people — you might want to examine changes made to the offline view before committing the changes to the source database. With the <a href="lnguse.htm">USE</a> command and the ADMIN clause, you can see all changes that have been committed to a view since it was taken offline. You can then selectively revert changes that have been made without being connected to the data source. For example, the following code opens the view <code>Showproducts</code> in administrator mode:</p>
<pre><code>USE Showproducts ADMIN
</code></pre>
<h3>Updating to Online Data</h3>
<p>
After you're finished offline, you can update the data on the sever using the same table update transactions you usually use with online data. When working with remote data, keep in mind the following tips:</p>
<ul type=disc>
<li>
For single record updates, use automatic transactions.</li>
<li>
For batch updates, use manual transactions.</li>
<li>
As necessary, include code to detect update conflicts, create a log of conflicts, and resolve conflicts.</li>
</ul>
<p>
Before you can process your updates, you need to use the <a href="lnguse.htm">USE</a> command and the ONLINE keyword to reconnect to the host database . After you issue the command, Visual FoxPro attempts to locate the host database using the data source information stored in the view. After the connection is established, you can use <a href="lngtableupdatelp_rp.htm">TABLEUPATE(&nbsp;)</a> to process the updates stored in the offline data.</p>
<p>
To make sure the connection information is correct regardless of the location of either the host or view tables, you need to use connection string syntax rather than a named connection.</p>
<h4>Updating Batches of Records in Local Tables</h4>
<p>
To process a batch of changes against local tables, you can use manual transactions that allow you to process the entire batch of changes within a single transaction rather a series of separate transactions.</p>
<p class=label>
<b>Updating local tables with offline views</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Code</b></td>
<td class=label width=35%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=65%><pre><code>USE myofflineview ONLINE EXCLUSIVE</code></pre>
</td>
<td width=35%>Reconnect to the host and open the view</td>
</tr>
<tr valign=top>
<td width=65%><pre><code>BEGIN TRANSACTION
IF TABLEUPDATE (2, .F., "myofflineview")
 &nbsp; END TRANSACTION
ELSE
 &nbsp; MESSAGEBOX("Error Occurred: Update unsuccessful.")
 &nbsp; ROLLBACK
ENDIF</code></pre>
</td>
<td width=35%>Check for update conflicts and update as appropriate.</td>
</tr>
</table><br>
<h4>Updating Batches of Records in Remote Tables</h4>
<p>
To process a batch of changes against remote tables, use manual transactions: begin with <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> and finish processing with either <a href="lngsqlcommitlp_rp.htm">SQLCOMMIT(&nbsp;)</a> or <a href="lngsqlrollbacklp_rp.htm">SQLROLLBACK(&nbsp;)</a>.</p>
<p>
To set the connection to manage your transactions manually, you need to use <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a> on the view cursor to get the connection handle, then set the Transactions property to manual mode.</p>
<p>
In the following code, the current connection identification for the view, <code>myview</code>, is stored into <code>hConn1</code>. <code>hConn1</code> is used to set the Transactions property to “2” for manual transactions.</p>
<pre><code>hConn1 = CURSORGETPROP("CONNECTHANDLE","myview") ;
SQLSETPROP(hConn1,"TRANSACTIONS",2)
</code></pre>
<p>
After you set the connection to handle the updates, you can use <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> to handle your transactions.</p>
<p>
If the host tables reside on a remote server, such as SQL Server, you might use the following code as a guideline.</p>
<p class=label>
<b>Updating remote tables with offline views</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=66%><b>Code</b></td>
<td class=label width=34%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=66%><pre><code>USE myofflineview ONLINE EXCLUSIVE</code></pre>
</td>
<td width=34%>Reconnect to the host and open the view.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>SQLSetProp(liviewhandle,"transactions",2)
SQLSetProp(custviewhandle,"transactions",2)
SQLSetProp(ordviewhandle,"transactions",2) </code></pre>
</td>
<td width=34%>Setting the connections on the views to handle transaction manually.</td>
</tr>
<tr valign=top>
<td width=66%><pre><code>IF NOT TABLEUPDATE(.T.,.F.,"lineitemsview")
 &nbsp; =SQLROLLBACK(ordviewhandle)
 &nbsp; =MESSAGEBOX("Can't update line items table")
 &nbsp; IF NOT TableUpdate(.T.,.F.,"ordersview")
 &nbsp;&nbsp;&nbsp;&nbsp; =SQLROLLBACK(liviewhandle)
 &nbsp;&nbsp;&nbsp;&nbsp; =MESSAGEBOX("unable to update the orders table")
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT TABLEUPDATE(.T.,.F.,"customerview")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =SQLROLLBACK(custviewhandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =MESSAGEBOX("Can't update customer table")
 &nbsp;&nbsp;&nbsp;&nbsp; Else *# check out failure scenarios
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF NOT SQLCOMMIT(liviewhandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =SQLROLLBACK(liviewhandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF NOT SQLCOMMIT(ordviewhandle)&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =SQLROLLBACK(ordviewhandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF NOT SQLCOMMIT(custviewhandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =SQLROLLBACK(custviewhandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDIF
ENDIF</code></pre>
</td>
<td width=34%>Handling updates and update conflicts.</td>
</tr>
</table><br>
<h4>Updating One Record</h4>
<p>
If you are updating a single row, you can use automatic transactions. Because each statement to process an update, delete, or insert is handled as a separate transaction, rollbacks against prior transaction statements are not possible.</p>
<pre><code>USE customerview ONLINE EXCLUSIVE
GO TO 3
 &nbsp; IF TABLEUPDATE (0, .F. workarea)
 &nbsp;&nbsp;&nbsp;&nbsp; * conflict handling code
 &nbsp; ENDIF
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;To update a single record in a local table, use the <a href="lnggetnextmodifiedlp_rp.htm">GETNEXTMODIFIED(&nbsp;)</a> function.</p>
<h4>Canceling Offline Updates</h4>
<p>
If you decide you want to delete the offline data and convert the view back to an online view, you can use the <a href="lngdropofflinelp_rp.htm">DROPOFFLINE(&nbsp;)</a> function.</p>
<p class=label>
<b>To cancel offline updates</b>
<ul type=disc>
<li>
Use DROPOFFLINE(&nbsp;) with the name of the view.</li>
</ul>
<p>
Be sure to check the return values. True (.T.) indicates success and false (.F.) indicates that the view was not closed before the command was issued.</p>
<p>
The following code drops all of the changes made to the subset of data in <code>myview</code>. The view remains part of the database, but its current set of data is dropped.</p>
<pre><code>DROPOFFLINE("myview")
</code></pre>
<p>
You can delete offline records, but you can’t use the <a href="lngpack.htm">PACK</a>, <a href="lngzap.htm">ZAP</a>, or <a href="lnginsert.htm">INSERT</a> commands with an offline view.</p>

<h2><a name="dgoptimizing_view_performance"></a>Optimizing View Performance</h2>
<p>
You can optimize the performance of your views by setting view properties.</p>
<h3>Controlling Progressive Fetching Fetch Size</h3>
<p>
You can control the number of rows Visual FoxPro progressively fetches at one time from the host database with the FetchSize property of the view and active view cursor. You use <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> and <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> to set these properties.</p>
<h3>Controlling Memo Fetching</h3>
<p>
You can use the delayed memo fetching feature to speed retrieval of view data. When you choose delayed memo fetching, Visual FoxPro does not retrieve the contents of a Memo field until you choose to open and display the field. Because Visual FoxPro needs the key field and table name to locate a row on the remote data source, you must set the UpdateName or UpdatableFieldList property, the KeyField or KeyFieldList property, and the Tables property for delayed Memo fetching to work. However, you don’t have to set the SendUpdates or Updatable properties to on in order to make delayed memo fetching work.</p>
<h3>Setting the Maximum Number of Records Downloaded</h3>
<p>
You can control the amount of data downloaded when you open a view by setting the MaxRecords property. When Visual FoxPro sends a SQL statement to the data source to create a view, the data source builds and stores a result set. The MaxRecords property specifies the maximum number of rows fetched from the remote result set into your view. The default setting is –1, which downloads all rows in the result set.</p>
<p class=label>
<b>To control the number of rows downloaded into a view</b>
<ul type=disc>
<li>
From the Tools menu, choose <b>Options</b> and select the <b>Remote Data</b> tab; then in the <b>Remote view defaults</b> area, next to the <b>Maximum records to fetch</b> box, clear <b>All</b>, enter a value in the text box, and then choose <b>OK</b>.<p class=tl>
-or-</P></li>
<li>
Use the MaxRecords property of the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> or <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function.</li>
</ul>
<p>
For example, the following code alters the view definition to limit the number of rows downloaded into the view to 50, regardless of the size of the result set built on the remote data source:</p>
<pre><code>OPEN DATABASE testdata
USE VIEW remote_customer_view
?DBSETPROP ('Remote_customer_view', ;&nbsp;&nbsp;&nbsp; 'View','MaxRecords', 50)
</code></pre>
<p>
You can use the <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> function to set the MaxRecords limit for an active view.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;You can’t use the MaxRecords property to stop a runaway query, because the MaxRecords property doesn’t control the building of the result set. Use the QueryTimeOut property to control the execution time on the remote data source.</p>
<h3>Optimizing Filters and Joins</h3>
<p>
To make optimization decisions for a view or query, you might need to know the <a href="glsexecution_plan.htm">execution plan</a>: the order that <a href="glsjoin.htm">joins</a> and <a href="glsfilter.htm">filter</a> clauses will be evaluated. Using the <a href="lngsys3054.htm">SYS(3054)</a> function, you can display one of three <a href="glsrushmore_technology.htm">Rushmore</a><sup>™</sup> optimization levels. The three levels indicate the degree to which the filter conditions or join conditions were able to use Rushmore optimization. The levels are completely (Full), partially (Partial) or not at all (None).</p>
<p class=label>
<b>To display the execution plan for filters</b>
<ol>
<li>
In the <a href="wndcommand_window.htm">Command</a> window, type <b>SYS(3054,1)</b> to enable SQL ShowPlan.<br><br></li>
<li>
Type your SQL SELECT statement.<p class=tl>
For example, you might type:</P><pre><code>SELECT * FROM customer, orders ;
AND Upper(country) = "MEXICO"
</code></pre>
</li>
<li>
On the screen, read the execution plan.<p class=tl>
For this example, the screen might display:</P><pre><code>Using Index Tag Country to optimize table customer
Rushmore Optimization Level for table customer: Full
Rushmore Optimization level for table orders: none
</code></pre>
</li>
<li>
In the <b>Command</b> window, type <b>SYS(3054,0)</b> to turn off SQL ShowPlan.</li>
</ol>
<p>
You can then pass 11 to the SYS function to evaluate joins in the FROM or WHERE clauses.</p>
<p class=label>
<b>To display the execution plan for joins</b>
<ol>
<li>
In the <a href="wndcommand_window.htm">Command</a> window, type <b>SYS(3054,11)</b> to enable SQL ShowPlan.<br><br></li>
<li>
Enter your SQL SELECT statement.<p class=tl>
For example, you might type:</P><pre><code>SELECT * ;
FROM customer INNER JOIN orders ;
ON customer.cust_id = orders.cust_id ;
WHERE Upper(country) = "MEXICO"
</code></pre>
</li>
<li>
On the screen, read the execution plan.<p class=tl>
For this example, the screen might display:</P><pre><code>Using Index Tag Country to optimize table customer
Rushmore Optimization Level for table customer: Full
Rushmore Optimization level for table orders: none
Joining table customer and table orders using Cust_id
</code></pre>
</li>
<li>
In the <b>Command</b> window, type <b>SYS(3054,0)</b> to turn off SQL ShowPlan.</li>
</ol>
<h4>Controlling Join Evaluation</h4>
<p>
If the <a href="glsexecution_plan.htm">execution plan</a> for your <a href="glsjoin.htm">joins</a> does not match your specific needs, you can force your join order to execute exactly as written without optimization from the processor. To force the evaluation order of the join, you need to add the FORCE keyword and place your join conditions in the FROM clause. Join conditions placed within the WHERE clause are not included in a forced join evaluation.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can’t use the FORCE keyword in SQL pass-through statements or remote views because this keyword is a Visual FoxPro extension of the <a href="glsansi.htm">ANSI</a> standard and is not supported in other SQL dictionaries.</p>
<p class=indent>
The FORCE clause is global and therefore applies to all tables in the JOIN clause. Be sure that the order in which the join tables appear is exactly the order in which they should be joined. You can also use parentheses to control the evaluation order of joins.</p>
<p>
In this example, the first join specified is also the first join evaluated. The Customer table is joined with the Orders table first. The result of that join is then joined with the <code>OrdItems</code> table:</p>
<pre><code>SELECT * ;
 &nbsp; FROM FORCE Customers ;
 &nbsp; INNER JOIN Orders ;
 &nbsp;&nbsp;&nbsp;&nbsp; ON Orders.Company_ID = Customers.Company_ID ;
 &nbsp; INNER JOIN OrItems;
 &nbsp;&nbsp;&nbsp;&nbsp; ON OrdItems.Order_NO = Orders.Order_NO 
</code></pre>
<p>
In this example, the join within the parentheses for the table <code>Orders</code> and <code>OrdItems</code> is evaluated first. The result of that join is then used in the evaluation of the join with <code>Customers</code>:</p>
<pre><code>SELECT * ;
FROM FORCE Customers ;
 &nbsp; INNER JOIN (orders INNER JOIN OrdItems ;
 &nbsp;&nbsp;&nbsp;&nbsp; ON OrdItems.Order_No = Orders.Order_No) ;
 &nbsp;&nbsp;&nbsp;&nbsp; ON Orders.Company_ID = Customers.Company_ID
</code></pre>
<h3>Sharing Connections for Multiple Remote Views</h3>
<p>
You can use one active connection as the information pipeline for multiple remote views by sharing a <a href="glsconnection.htm">connection</a>. When you share an active connection, you:</p>
<ul type=disc>
<li>
Reduce the number of connections on a remote server.</li>
<li>
Reduce costs for connections to servers that charge on a per-connection basis.</li>
</ul>
<p>
You share connections by setting the view definition to use a shared connection upon activation. When the view is used, Visual FoxPro connects to the remote data source using the existing shared connection (if any). If a shared connection isn’t in use, Visual FoxPro creates a unique connection when the view is opened, which can then be shared with other views.</p>
<p>
Only one active instance of a named connection definition is shared during a Visual FoxPro session. If multiple instances of the same connection definition are active, the first instance to be used as a shared connection becomes the designated shared connection. All views that use that connection definition and employ connection sharing will access the remote server through the designated shared connection.</p>
<p>
Connections other than the designated shared connection are not shared. Connection sharing is not scoped to <a href="glssession_visual_foxpro.htm">sessions</a>.</p>
<p class=label>
<b>To share a connection</b>
<ul type=disc>
<li>
From the Tools menu, choose <b>Options</b> and select the <b>Remote Data</b> tab; then select <b>Share connection</b> in the <b>Remote view defaults</b> area and choose <b>OK</b>.<p class=tl>
-or-</P></li>
<li>
Use the <a href="wndquery_designer.htm">View Designer</a>.<p class=tl>
-or-</P></li>
<li>
Use the <a href="lngcreate_sql_view.htm">CREATE SQL VIEW</a> command with the SHARE clause.</li>
</ul>
<p>
The following code creates a view that, when activated with the <a href="lnguse.htm">USE</a> command, shares a connection:</p>
<pre><code>CREATE SQL VIEW product_view_remote ;
 &nbsp; CONNECTION remote_01 SHARE AS ;
 &nbsp; SELECT * FROM products
USE product_view_remote
</code></pre>
<h4>Testing a Connection for Busyness</h4>
<p>
When a connection is busy, such as when Visual FoxPro is progressively fetching data into a <a href="glscursor.htm">cursor</a>, you don’t want to start another fetch or send updates on the same connection. You can determine whether a connection is busy with the ConnectBusy property, which returns a value of true (.T.) if the connection is busy. You can use this property in your application to test a connection before sending a request over a shared connection to a remote data source.</p>
<p class=label>
<b>To determine whether a connection is busy</b>
<ul type=disc>
<li>
Use the ConnectBusy property of <a href="lngsqlgetproplp_rp.htm">SQLGETPROP(&nbsp;)</a>.</li>
</ul>
<p>
You need the connection handle to use the SQLGETPROP(&nbsp;) function. You can identify the connection handle for an active view with the ConnectHandle property of the <a href="lngcursorgetproplp_rp.htm">CURSORGETPROP(&nbsp;)</a> function. The following code identifies a connection handle and then uses the connection handle to test whether the connection is busy:</p>
<pre><code>nConnectionHandle=CURSORGETPROP('ConnectHandle')
SQLGETPROP(nConnectionHandle, "ConnectBusy")
</code></pre>
</BODY>
</HTML>
