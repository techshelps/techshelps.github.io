<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Optimizing Applications</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="dgoptimizing_applications"></a><sup></sup>Chapter 15: Optimizing Applications</h1>
<p>
When you use Visual FoxPro to design and run applications, you want to get the best performance from your operating system, from Visual FoxPro, and from your application.</p>
<p>
For information about how to optimize your computer and operating system, see Chapter 4, <a href="igoptimizing_your_system.htm">Optimizing Your System</a>, in the <i>Installation Guide</i>.</p>
<p>
This chapter describes:</p>
<ul type=disc>
<li>
<a href="#dgoptimizing_tables_and_indexes">Optimizing Tables and Indexes</a></li>
<li>
<a href="#dgusing_rushmore_to_speed_data_access">Using Rushmore to Speed Data Access</a></li>
<li>
<a href="#dgoptimizing_forms_and_controls">Optimizing Forms and Controls</a></li>
<li>
<a href="#dgoptimizing_programs">Optimizing Programs</a></li>
<li>
<a href="#dgoptimizing_activex_controls">Optimizing ActiveX Controls</a></li>
<li>
<a href="#dgoptimizing_applications_in_multiuser_environments">Optimizing Applications in Multiuser Environments</a></li>
<li>
<a href="#dgoptimizing_access_to_remote_data">Optimizing Access to Remote Data</a></li>
<li>
<a href="#dgoptimizing_international_applications">Optimizing International Applications</a></li>
</ul>

<h2><a name="dgoptimizing_tables_and_indexes"></a>Optimizing Tables and Indexes</h2>
<p>
You can speed access to data in tables by using indexes and by using buffering efficiently. In addition, you can use Rushmore technology to optimize your queries.</p>
<h3>Using Indexes</h3>
<p>
To speed access to data in a table, use indexes. Adding an index to a table speeds searches, especially if you're able to use Rushmore technology to optimize your search. Indexing also allows you to work with data in a particular order, such as viewing a customer table in order by last name.</p>
<p>
If the records in a table have unique keys, create a primary or candidate index on the field. These types of indexes allow Visual FoxPro to validate the key at a low level, resulting in best performance.</p>
<p>
In addition to indexing fields used for searching and sorting, you should also index any fields involved in a join. If you join two tables on fields that are not indexed, the join operation can take as much as hundreds of times longer.</p>
<p>
An important feature of Visual FoxPro is that you can create an index on any expression. (In some database products, you can index only on fields.) This capability allows you to use indexes to optimize searching, sorting, or joining on combinations of fields, or on expressions derived from fields. For example, you can index a name field based on an expression that uses the <a href="lngsoundexlp_rp.htm">SOUNDEX(&nbsp;)</a> function. That way, your application can provide extremely quick access to names that sound alike.</p>
<p>
When adding indexes to your tables, you must balance the benefit you get in retrieval times against a performance loss when updating the table. As you add more indexes to your table, updates and inserts to the table are slower because Visual FoxPro needs to update each index.</p>
<p>
Finally, avoid using indexes on fields that contain only a few discrete values, such as a logical field. In these cases, the index contains only a small number of entries, and the overhead of maintaining the index probably outweighs the benefit it provides when searching.</p>
<p>
For details about how to index effectively when using Rushmore technology, see <a href="#dgusing_rushmore_to_speed_data_access">Using Rushmore to Speed Data Access</a> later in this chapter.</p>
<h3>Optimizing Joins</h3>
<p>
When you create joins using <a href="lngselect___sql.htm">SELECT - SQL</a>, the following situations can degrade performance and produce unexpected results:</p>
<ul type=disc>
<li>
Joining tables on data that is not a primary or unique key in one of the tables.</li>
<li>
Joining tables containing empty fields.</li>
</ul>
<p>
To avoid these situations, create joins based on the relationship between primary keys in one table and foreign keys in the other. If you create a join based on data that is not unique, the end result can be the product of two tables. For example, the following SELECT - SQL statement creates a join which can produce a very large result:</p>
<pre><code>SELECT *;
 FROM&nbsp; tastrade!customer INNER JOIN tastrade!orders ;
 ON&nbsp; Customer.postal_code = Orders.postal_code
</code></pre>
<p>
In the example, postal code uniquely identifies a location within a city, but has little value if your intent is to match customer rows and their order rows. The postal code doesn't necessarily uniquely identify a customer or an order. Instead, create a join using a statement such as the following:</p>
<pre><code>SELECT *;
 FROM&nbsp; tastrade!customer INNER JOIN tastrade!orders ;
 ON&nbsp; Customer.customer_id = Orders.customer_id
</code></pre>
<p>
In this example, the field <code>customer_id</code> uniquely identifies a specific customer and the orders belonging to that customer, and therefore creates a result set that combines the customer row with each order row.</p>
<p>
In addition, use caution when joining tables with empty fields because Visual FoxPro will match empty fields. However, Visual FoxPro doesn't match fields containing null. When creating a join, qualify the field expressions in the join condition by testing for an empty string.</p>
<p>
For example, if you think that the customer id field in the Orders table might be empty, use a statement such as the following to filter out order records with no customer number:</p>
<pre><code>SELECT *;
 FROM&nbsp; tastrade!customer INNER JOIN tastrade!orders ;
 ON&nbsp; Customer.customer_id = Orders.customer_id; 
 WHERE tastrade!orders &lt;&gt; ""
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;You can also test for an empty string using the <a href="lngemptylp_rp.htm">EMPTY(&nbsp;)</a> function, but including a function call within the filter expression is not as fast as comparing to a constant value.</p>
<h3>Using the Project Manager</h3>
<p>
When you use the Project Manager, you can combine an unlimited number of programs and procedures into a single .app or .exe file. This can greatly increase program execution speed for a couple of reasons.</p>
<p>
First, Visual FoxPro opens a program file and leaves it open. Later, When you issue a <a href="lngdo.htm">DO</a> command on a program contained in the file, Visual FoxPro doesn't need to open an additional file.</p>
<p>
Second, an application of only one or two files reduces the number of files necessary in the working directory. The speed of all file operations increases as the operating system has fewer directory entries to examine when opening, renaming, or deleting files.</p>
<p>
For information on using the Project Manager to create applications, see Chapter 13, <a href="dgcompiling_an_application.htm">Compiling an Application</a>.</p>
<h3>General Table and Index Optimization Hints</h3>
<p>
To create the fastest possible tables and indexes, follow the recommendations listed below.</p>
<ul type=disc>
<li>
If record or table buffering is not enabled, use <a href="lnginsert___sql.htm">INSERT - SQL</a> instead of APPEND BLANK followed by REPLACE, particularly with an indexed table in a multiuser environment, because indexes only need to be updated once.</li>
<li>
If you need to append a large number of records to an indexed table, it might be faster to remove the index, append the records, and then re-create the index.</li>
<li>
In SQL statements, avoid function calls if possible, especially in statements that will return more than one record, because the statement must be reevaluated (and the functions called again) for each record. If you are creating a SQL statement with variable data, use name expressions or macro substitution in favor of the EVALUATE(&nbsp;) function. A better strategy yet is to construct the entire statement dynamically, not just individual clauses. For more information, see <a href="conusing_macros.htm">Using Macros</a> and <a href="concreating_name_expressions.htm">Creating Name Expressions</a>.</li>
<li>
If you usually use a certain index order, you can improve performance by periodically sorting the table in this order.</li>
<li>
Use .cdx instead of .idx files in multiuser environments because you can update one .cdx file faster than you can update multiple .idx files.</li>
</ul>

<h2><a name="dgusing_rushmore_to_speed_data_access"></a>Using Rushmore to Speed Data Access</h2>
<p>
To help you optimize the performance of your applications, Visual FoxPro includes Rushmore data access technology. Using Rushmore, you can run certain complex table operations hundreds or even thousands of times faster than without it.</p>
<h3>Understanding Rushmore Technology</h3>
<p>
Rushmore technology is a data access technique that uses standard Visual FoxPro indexes to optimize access to data. You can use Rushmore with any Visual FoxPro index, including FoxPro 1.<i>x</i> (.idx) indexes, compact (.idx) indexes, and compound (.cdx) indexes.</p>
<p>
Both .cdx and compact .idx indexes use a compression technique that produces indexes as small as one-sixth the size of uncompressed old-format indexes. Visual FoxPro can process a compressed index faster because it requires less disk access, and because more of the index can be buffered in memory. Although Rushmore, like other file access techniques, benefits from the smaller size of compact indexes, it also functions very well with indexes in older formats.</p>
<p>
When Visual FoxPro processes very large tables on computers with only the minimum amount of RAM, Rushmore might not find sufficient memory to operate. In that case, Visual FoxPro might display a warning message (“Not enough memory for optimization”). Although your program will function correctly and without losing any data, the query will not benefit from Rushmore optimization.</p>
<p>
In its simplest form, Rushmore speeds the performance of single-table commands using FOR clauses that specify sets of records in terms of existing indexes. Also, Rushmore can speed the operation of certain commands such as <a href="lnglocate.htm">LOCATE</a> and <a href="lngindex.htm">INDEX</a>. For a complete list of optimizable commands, see the next section, “Using Rushmore with Tables.”</p>
<p>
Visual FoxPro SQL commands use Rushmore as a basic tool in multi-table query optimization, using existing indexes and even creating new ad-hoc indexes to speed queries.</p>
<h3>Using Rushmore with Tables</h3>
<p>
Use Rushmore to optimize data access according to the number of tables involved. When you access single tables, you can take advantage of Rushmore anywhere that a FOR clause appears. When you access multiple tables, SELECT - SQL queries supersede all Rushmore optimizations. In an SQL command, Visual FoxPro decides what is needed to optimize a query and does the work for you. You don’t need to open tables or indexes. If SQL decides it needs indexes, it creates temporary indexes for its own use.</p>
<p class=label>
<b>To use Rushmore</b></p>
<p>
Choose one of the following options:
<ul type=disc>
<li>
To access data from a single table, use a FOR clause in a command such as <a href="lngaverage.htm">AVERAGE</a>, <a href="lngbrowse.htm">BROWSE</a>, or <a href="lnglocate.htm">LOCATE</a>, or use SQL commands to update tables. For a complete list of commands that use the FOR clause, refer to the table below.<p class=tl>
-or-</P></li>
<li>
To access data from more than one table, use the <a href="lngselect___sql.htm">SELECT - SQL</a> <a href="lngdelete___sql.htm">DELETE - SQL</a>, and <a href="lngupdate___sql.htm">UPDATE - SQL</a> commands.</li>
</ul>
<p>
The following table lists commands that use FOR clauses. Rushmore is designed so that its speed is proportional to the number of records retrieved.</p>
<p class=label>
<b>Potentially Optimizable Commands with FOR Clauses</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=32%><a href="lngaverage.htm">AVERAGE</a></td>
<td width=68%><a href="lngblank.htm">BLANK</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngbrowse.htm">BROWSE</a></td>
<td width=68%><a href="lngcalculate.htm">CALCULATE</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngchange.htm">CHANGE</a></td>
<td width=68%><a href="lngcopy_to.htm">COPY TO</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngcopy_to_array.htm">COPY TO ARRAY</a></td>
<td width=68%><a href="lngcount.htm">COUNT</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngdelete.htm">DELETE</a></td>
<td width=68%><a href="lngdisplay.htm">DISPLAY</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngedit.htm">EDIT</a></td>
<td width=68%><a href="lngexport.htm">EXPORT TO</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngindex.htm">INDEX</a></td>
<td width=68%><a href="lngjoin.htm">JOIN WITH</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lnglabel.htm">LABEL</a></td>
<td width=68%><a href="lnglist.htm">LIST</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lnglocate.htm">LOCATE</a></td>
<td width=68%><a href="lngrecall.htm">RECALL</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngreplace.htm">REPLACE</a></td>
<td width=68%><a href="lngreplace_from_array.htm">REPLACE FROM ARRAY</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngreport.htm">REPORT</a></td>
<td width=68%><a href="lngscan_..._endscan.htm">SCAN</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngset_deleted.htm">SET DELETED</a></td>
<td width=68%><a href="lngset_filter.htm">SET FILTER</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngsort.htm">SORT TO</a></td>
<td width=68%><a href="lngsum.htm">SUM</a></td>
</tr>
<tr valign=top>
<td width=32%><a href="lngtotal.htm">TOTAL TO</a></td>
<td width=68%></td>
</tr>
</table><br>
<p>
If you use a scope clause in addition to an optimizable FOR clause expression, the scope must be set to ALL or REST to take advantage of Rushmore. The NEXT or RECORD scope clauses disable Rushmore. Since the default scope is ALL for most commands, Rushmore works when you omit the scope clause.</p>
<p>
Rushmore can use any open indexes except for filtered and UNIQUE indexes.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For optimal performance, don’t set the order of the table.</p>
<p>
Creating index or tags automatically sets the order. If you want to take maximum advantage of Rushmore with a large data set that must be in a specific order, issue <a href="lngset_order.htm">SET ORDER TO</a> to turn off index control, then use the <a href="lngsort.htm">SORT</a> command.</p>
<h4>Indexing Effectively for Rushmore</h4>
<p>
Rushmore cannot take advantage of all indexes. If you use a FOR clause in the <a href="lngindex.htm">INDEX</a> command, Rushmore cannot use the index for optimization. For example, because it contains a FOR clause, the following statement cannot be optimized:</p>
<pre><code>INDEX ON ORDNUM FOR DISCOUNT &gt; 10 TAG ORDDISC
</code></pre>
<p>
Similarly, Rushmore cannot use an index created with a NOT <i>condition</i>. For example, the following expression can be optimized:</p>
<pre><code>INDEX ON DELETED() TAG DEL
</code></pre>
<p>
But this one cannot:</p>
<pre><code>INDEX ON NOT DELETED() TAG NOTDEL
</code></pre>
<p>
In the special case that you want to exclude delete records from a query, using an index like the first example above will speed up operations when you've set SET DELETED to ON.</p>
<h4>Operating Without Rushmore</h4>
<p>
Data retrieval operations proceed without Rushmore optimization in the following situations:</p>
<ul type=disc>
<li>
When Rushmore cannot optimize the FOR clause expressions in a potentially optimizable command. For more information on creating an optimizable FOR expression, see the section <a href="#dgcombining_basic_optimizable_expressions">Combining Basic Optimizable Expressions</a>.</li>
<li>
When a command that might benefit from Rushmore contains a WHILE clause.</li>
<li>
When memory is low. Data retrieval continues, but is not optimized.</li>
</ul>
<h3>Disabling Rushmore</h3>
<p>
Though you rarely want to, you can disable Rushmore. When you issue a command that uses Rushmore, Visual FoxPro immediately determines which records match the FOR clause expression. These records are then manipulated by the command.</p>
<p>
If a potentially optimizable command modifies the index key in the FOR clause, the record set on which Rushmore is operating can become outdated. In this case, you can disable Rushmore to ensure that you have the most current information from the table.</p>
<p class=label>
<b>To disable Rushmore for an individual command</b>
<ul type=disc>
<li>
Use the NOOPTIMIZE clause.<p class=tl>
For example, this <a href="lnglocate.htm">LOCATE</a> command is not optimized:</P><pre><code>LOCATE FOR DueDate &lt; {^1998-01-01} NOOPTIMIZE
</code></pre>
</li>
</ul>
<p>
You can globally disable or enable Rushmore for all commands that benefit from Rushmore, with the <a href="lngset_optimize.htm">SET OPTIMIZE</a> command.</p>
<p class=label>
<b>To disable Rushmore globally</b>
<ul type=disc>
<li>
Use the following code:<pre><code>SET OPTIMIZE OFF
</code></pre>
</li>
</ul>
<p class=label>
<b>To enable Rushmore globally</b>
<ul type=disc>
<li>
Use the following code:<pre><code>SET OPTIMIZE ON
</code></pre>
</li>
</ul>
<p>
The default setting of Rushmore optimization is ON.</p>
<h3>Optimizing Rushmore Expressions</h3>
<p>
Rushmore technology depends on the presence of a <i>basic optimizable expression</i> in a FOR clause or in an SQL WHERE clause. A basic optimizable expression can form an entire expression or can appear as part of an expression. You can also combine basic expressions to form a complex optimizable expression.</p>
<h4>Creating Basic Optimizable Expressions</h4>
<p>
A basic optimizable expression takes one of the two following forms:</p>
<p>
<i>eIndex&nbsp; relOp&nbsp; eExp</i></p>
<p class=tl>
-or-</P><p>
<i>eExpr&nbsp; relOp&nbsp; eIndex</i></p>
<p>
A basic optimizable expression has the following characteristics:</p>
<ul type=disc>
<li>
<i>eIndex</i> exactly matches the expression on which an index is constructed.</li>
<li>
<i>eExpr</i> is any expression and can include variables and fields from other unrelated tables.</li>
<li>
<i>relOp</i> is one of the following relational operators: &lt;, &gt;, =, &lt;=, &gt;=, &lt;&gt;, #, ==, or !=. You can also use the <a href="lngisnulllp_rp.htm">ISNULL(&nbsp;)</a>, <a href="lngbetweenlp_rp.htm">BETWEEN(&nbsp;)</a>, or <a href="lnginlistlp_rp.htm">INLIST(&nbsp;)</a> functions (or their SQL equivalents such as IS NULL, and so on).</li>
</ul>
<p>
You can use BETWEEN(&nbsp;) or INLIST(&nbsp;) in the following two forms:</p>
<p>
<i>eIndex</i> BETWEEN(<i>eIndex, eExpr, eExpr</i>)</p>
<p class=tl>
-or-</P><p>
<i>eExpr</i> INLIST(<i>eIndex, eExpr</i>)</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;ISBLANK(&nbsp;) and EMPTY(&nbsp;) are not optimizable by Rushmore.</p>
<p>
If you create the indexes <code>firstname</code>, <code>custno</code>, <code>UPPER(lastname)</code>, and <code>hiredate</code>, each of the following expressions is optimizable:</p>
<pre><code>firstname = "Fred"
custno &gt;= 1000
UPPER(lastname) = "SMITH"
hiredate &lt; {^1997-12-30}
</code></pre>
<p>
An optimizable expression can contain variables and functions that evaluate to a specific value. For example, using the index <code>addr</code>, if you issue the command <code>STORE </code>"<code>WASHINGTON AVENUE</code>"<code> TO cVar</code>, then the following statements are also basic optimizable expressions:</p>
<pre><code>ADDR = cVar
ADDR = SUBSTR(cVar,8,3)
</code></pre>
<h4>Understanding When Queries Are Optimized</h4>
<p>
It is important to understand when queries will be optimized and when they will not. Visual FoxPro optimizes search conditions by looking for an exact match between the left side of a filter expression and an index key expression. Therefore, Rushmore can optimize an expression only if you search against the exact expression used in an index.</p>
<p>
For example, imagine that you've just created a table and are adding the first index using a command such as the following:</p>
<pre><code>USE CUSTOMERS
INDEX ON UPPER(cu_name) TAG name
</code></pre>
<p>
The following command is not optimizable, because the search condition is based on the field <code>cu_name</code> only, not on an expression that is indexed:</p>
<pre><code>SELECT * FROM customers WHERE cu_name ="ACME"
</code></pre>
<p>
Instead, you should create an optimizable expression using a command such as the following, in which the expression for which you are searching exactly matches an indexed expression:</p>
<pre><code>SELECT * FROM customers WHERE UPPER(cu_name) = "ACME"
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;To determine the level of Rushmore optimization being used, call <a href="lngsys3054.htm">SYS(3054)</a>.</p>

<h4><a name="dgcombining_basic_optimizable_expressions"></a>Combining Basic Optimizable Expressions</h4>
<p>
You can combine simple or complex expressions based on the FOR clause or WHERE clause to increase data retrieval speed, if the FOR expressions have the characteristics of basic optimizable expressions.</p>
<p>
Basic expressions might be optimizable. You can combine basic expressions using the AND, OR, and NOT logical operators to form a complex FOR clause expression that might also be optimizable. An expression created with a combination of optimizable basic expressions is fully optimizable. If one or more of the basic expressions are not optimizable, the complex expression might be partially optimizable or not optimizable at all.</p>
<p>
A set of rules determines if an expression composed of basic optimizable or non-optimizable expressions is fully optimizable, partially optimizable, or not optimizable. The following table summarizes Rushmore query optimization rules.</p>
<p class=label>
<b>Combining Basic Expressions</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Basic Expression</b></td>
<td class=label width=20%><b>Operator</b></td>
<td class=label width=25%><b>Basic Expression</b></td>
<td class=label width=28%><b>Query Result</b></td>
</tr>
<tr valign=top>
<td width=27%>Optimizable</td>
<td width=20%>AND</td>
<td width=25%>Optimizable</td>
<td width=28%>Fully Optimizable</td>
</tr>
<tr valign=top>
<td width=27%>Optimizable</td>
<td width=20%>OR</td>
<td width=25%>Optimizable</td>
<td width=28%>Fully Optimizable</td>
</tr>
<tr valign=top>
<td width=27%>Optimizable</td>
<td width=20%>AND</td>
<td width=25%>Not Optimizable</td>
<td width=28%>Partially Optimizable</td>
</tr>
<tr valign=top>
<td width=27%>Optimizable</td>
<td width=20%>OR</td>
<td width=25%>Not Optimizable</td>
<td width=28%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=27%>Not Optimizable</td>
<td width=20%>AND</td>
<td width=25%>Not Optimizable</td>
<td width=28%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=27%>Not Optimizable</td>
<td width=20%>OR</td>
<td width=25%>Not Optimizable</td>
<td width=28%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=27%>—</td>
<td width=20%>NOT</td>
<td width=25%>Optimizable</td>
<td width=28%>Fully Optimizable</td>
</tr>
<tr valign=top>
<td width=27%>—</td>
<td width=20%>NOT</td>
<td width=25%>Not Optimizable</td>
<td width=28%>Not Optimizable</td>
</tr>
</table><br>
<p>
You can use the AND operator to combine two optimizable expressions into one fully optimizable expression:</p>
<pre><code>FIRSTNAME = "FRED" AND HIREDATE &lt; {^1997-12-30}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Optimizable
</code></pre>
<p>
In this example, the OR operator combines a basic optimizable expression with an expression that is not optimizable to create an expression that is not optimizable:</p>
<pre><code>FIRSTNAME = "FRED" OR "S" $ LASTNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Not optimizable
</code></pre>
<p>
Using the NOT operator on an optimizable expression creates a fully optimizable expression:</p>
<pre><code>NOT FIRSTNAME = "FRED"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Fully optimizable
</code></pre>
<p>
You can also use parentheses to group combinations of basic expressions.</p>
<h4>Combining Complex Expressions</h4>
<p>
Just as you can combine basic expressions, you can combine complex expressions to create a more complex expression that is fully optimizable, partially optimizable, or not optimizable. You can then combine these more complex expressions to create expressions that again might be fully or partially optimizable, or not optimizable at all. The following table describes the results of combining these complex expressions. These rules also apply to expressions grouped with parentheses.</p>
<p class=label>
<b>Combining Complex Expressions</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Expression</b></td>
<td class=label width=17%><b>Operator</b></td>
<td class=label width=29%><b>Expression</b></td>
<td class=label width=29%><b>Result</b></td>
</tr>
<tr valign=top>
<td width=25%>Fully Optimizable</td>
<td width=17%>AND</td>
<td width=29%>Fully Optimizable</td>
<td width=29%>Fully Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Fully Optimizable</td>
<td width=17%>OR</td>
<td width=29%>Fully Optimizable</td>
<td width=29%>Fully Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Fully Optimizable</td>
<td width=17%>AND</td>
<td width=29%>Partially Optimizable</td>
<td width=29%>Partially Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Fully Optimizable</td>
<td width=17%>OR</td>
<td width=29%>Partially Optimizable</td>
<td width=29%>Partially Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Fully Optimizable</td>
<td width=17%>AND</td>
<td width=29%>Not Optimizable</td>
<td width=29%>Partially Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Fully Optimizable</td>
<td width=17%>OR</td>
<td width=29%>Not Optimizable</td>
<td width=29%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>—</td>
<td width=17%>NOT</td>
<td width=29%>Fully Optimizable</td>
<td width=29%>Fully Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Partially Optimizable</td>
<td width=17%>AND</td>
<td width=29%>Partially Optimizable</td>
<td width=29%>Partially Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Partially Optimizable</td>
<td width=17%>OR</td>
<td width=29%>Partially Optimizable</td>
<td width=29%>Partially Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Partially Optimizable</td>
<td width=17%>AND</td>
<td width=29%>Not Optimizable</td>
<td width=29%>Partially Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Partially Optimizable</td>
<td width=17%>OR</td>
<td width=29%>Not Optimizable</td>
<td width=29%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>—</td>
<td width=17%>NOT</td>
<td width=29%>Partially Optimizable</td>
<td width=29%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Not Optimizable</td>
<td width=17%>AND</td>
<td width=29%>Not Optimizable</td>
<td width=29%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>Not Optimizable</td>
<td width=17%>OR</td>
<td width=29%>Not Optimizable</td>
<td width=29%>Not Optimizable</td>
</tr>
<tr valign=top>
<td width=25%>—</td>
<td width=17%>NOT</td>
<td width=29%>Not Optimizable</td>
<td width=29%>Not Optimizable</td>
</tr>
</table><br>
<p>
You can combine fully optimizable expressions with the OR operator to create one expression that is also fully optimizable:</p>
<pre><code>* Fully-optimizable expression
(FIRSTNAME = "FRED" AND HIREDATE &lt; {^1997-12-30}) ;
 &nbsp; OR (LASTNAME = "" AND HIREDATE &gt; {^1996-12-30})
</code></pre>
<p>
To create partially optimizable expressions, combine a fully optimizable expression with an expression that is not optimizable. In the following example, the AND operator is used to combine the expressions:</p>
<pre><code>* Partially-optimizable expression
(FIRSTNAME = "FRED" AND HIREDATE &lt; {^1997-12-30}) ;
 &nbsp; AND "S" $ LASTNAME
</code></pre>
<p>
Partially optimizable expressions can be combined to create one expression that is also partially optimizable:</p>
<pre><code>* Partially-optimizable expression
(FIRSTNAME = "FRED" AND "S" $ LASTNAME) ;
 &nbsp; OR (FIRSTNAME = "DAVE" AND "T" $ LASTNAME)
</code></pre>
<p>
Combining expressions that are not optimizable creates an expression that is also not optimizable:</p>
<pre><code>* Expression that is not optimizable
("FRED" $ FIRSTNAME OR "S" $ LASTNAME) ;&nbsp;&nbsp; 
 &nbsp; OR ("MAIN" $ STREET OR "AVE" $ STREET)
</code></pre>

<h2><a name="dgoptimizing_forms_and_controls"></a>Optimizing Forms and Controls</h2>
<p>
You can also make significant improvements in the forms and controls in your application.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;For information about setting and getting properties efficiently, see <a href="#dgreferencing_object_properties_efficiently">Referencing Object Properties Efficiently</a> later in this chapter.</p>
<h3>Using the Data Environment</h3>
<p>
If you use the data environment of the Form Designer or Report Designer, table open performance is much faster than executing <a href="lnguse.htm">USE</a>, <a href="lngset_order.htm">SET ORDER</a>, and <a href="lngset_relation.htm">SET RELATION</a> commands in the form Load event. When you use the data environment, Visual FoxPro uses low-level engine calls to open the tables and set up the indexes and relations.</p>
<h3>Limiting the Number of Forms in a Form Set</h3>
<p>
Use form sets only when it is necessary to have a group of forms share a private data session. When you use a form set, Visual FoxPro creates instances of all forms and all controls on all forms in the form set, even though the first form in the form set is the only one being displayed. This can be time consuming, and is unnecessary if the forms don’t have to share a private data session. Instead, you should execute <a href="lngdo_form.htm">DO FORM</a> for other forms when they're needed.</p>
<p>
However, if you do use a form set, you will gain some performance back when you access the forms in the form set, because the forms will already be loaded but not visible.</p>
<h3>Dynamically Loading Page Controls on a Page Frame</h3>
<p>
Page frames, like form sets, load all the controls for each page when the page frame is loaded, which can cause a noticeable delay when the page frame is loaded. Instead, you can dynamically load page controls, as needed, by creating a class out of the controls on each page, then loading them as the page is activated.</p>
<p class=label>
<b>To dynamically load page controls</b>
<ol>
<li>
Design your form as you normally would, including all controls on all pages.<br><br></li>
<li>
When your design is complete, go to the second page of your page frame, and save the controls you find there as a class.<br><br></li>
<li>
Open the class you created, and ensure the controls are still properly laid out.<br><br></li>
<li>
Repeat Steps 2 and 3 for the third and subsequent pages of the page frame.<br><br></li>
<li>
In the <a href="lngactivate_event.htm">Activate</a> event of the second and subsequent pages of the page frame, add objects and make them visible.<p class=tl>
For example, if your controls class is named <code>cnrpage1</code>, you would add the following code:</P><pre><code>IF THIS.ControlCount = 0
THIS.AddObject("cnrpage1","cnrpage1")
THIS.cnrpage1.Visible = .T.
ENDIF
</code></pre>
</li>
</ol>
<h3>Dynamically Binding Controls to Data</h3>
<p>
You can speed the load time for a form that contains many data-bound controls if you delay the binding of those controls until they're needed.</p>
<p class=label>
<b>To dynamically bind controls to data</b>
<ol>
<li>
Put the tables and views for your form in the data environment so that they're opened when the form is loaded.<br><br></li>
<li>
For each bound control, add code to its <a href="lnggotfocus_event.htm">GotFocus</a> event code that binds the control to the data value. For example, the following code binds a ComboBox control to the <code>customer.company</code> field:<pre><code>* Check to see if the control has been bound yet.
IF THIS.RecordSource = ""
* Set the record source to the right value
* and set the record source type to "fields"
THIS.RecordSource = "customer.company"
THIS.RecordSourceType = 6
THIS.Refresh
ENDIF
</code></pre>
</li>
</ol>
<h3>Delaying Screen Refresh</h3>
<p>
If you must make several changes to the screen — for example, change the values of several controls at once — you can reduce the overall time required to update the screen by delaying screen refresh until all changes are done. For example, if you make controls visible or invisible, change control colors, or move records in bound controls, it is much more efficient to delay the painting of those controls until after the changes have all been completed:</p>
<p class=label>
<b>To delay screen refresh</b>
<ol>
<li>
Set the form’s <a href="lnglockscreen_property.htm">LockScreen</a> property to true.<br><br></li>
<li>
Update the controls as required.<br><br></li>
<li>
Call the form’s <a href="lngrefresh_method.htm">Refresh</a> method.<br><br></li>
<li>
Set the form’s LockScreen property to false.</li>
</ol>
<p>
For example, the following example changes the display properties of several properties at once, moves to a new record, and only then refreshes the screen with new information. If LockScreen were not set to true, each of these operations would repaint the affected controls individually and the overall update performance would seem sluggish.</p>
<pre><code>THISFORM.LockScreen = .T.
THISFORM.MyButton.Caption = "Save"
THISFORM.MyGrid.BackColor = RGB (255, 0, 0) &amp;&amp; Red
SKIP IN customers
SKIP IN orders
THISFORM.Refresh
THISFORM.LockScreen = .F.
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;This technique doesn't provide any benefit if you're updating only a single control.</p>
<h3>Reducing Code in Frequently-Used Methods</h3>
<p>
Because the <a href="lngrefresh_method.htm">Refresh</a> method and <a href="lngpaint_event.htm">Paint</a> event are called frequently, you can improve performance in forms by reducing the amount of code in these methods. Similarly, to speed the load time for a form, you could move code from the Init event to a less frequently used event such as <a href="lngactivate_event.htm">Activate</a>, <a href="lngclick_event.htm">Click</a>, and <a href="lnggotfocus_event.htm">GotFocus</a>. Then, you use a property on the control (such as <a href="lngtag_property.htm">Tag</a> or a custom property) to keep track of whether the control has already run code that only needs to be run once.</p>

<h2><a name="dgoptimizing_programs"></a>Optimizing Programs</h2>
<p>
By writing your code carefully, you can write the fastest possible programs. There are several ways to improve program performance in Visual FoxPro:</p>
<ul type=disc>
<li>
Following the general programming performance hints provided below.</li>
<li>
Using name expressions instead of macro substitution.</li>
<li>
Referencing object properties efficiently.</li>
</ul>
<h3>General Programming Performance Hints</h3>
<p>
To write the fastest programs possible, follow the recommendations listed below.</p>
<ul type=disc>
<li>
Choose the correct data type for your data. In particular, use the Integer data type for numeric information whenever possible, as it is processed most efficiently. Wherever possible, use Integer data types for primary and foreign key values, which will result in smaller data files, smaller (and therefore faster) indexes, and faster joins.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For an example showing how to create a smaller (and therefore faster) index, run Solution.app, located in the Visual Studio …\Samples\Vfp98\Solution directory. Choose <b>View Samples by Filtered List</b>, select <b>Indexes</b> from the drop-down list, and then choose <b>Create Small Indexes Using BINTOC(&nbsp;)</b> from the list that appears.</p></li>
<li>
Avoid reopening files, which slows performance. Instead, assign files to work areas as you open them, then use the <a href="lngselect.htm">SELECT</a> command to choose a specific work area as needed.</li>
<li>
Use <a href="lngfor_..._endfor.htm">FOR … ENDFOR</a> loops rather than <a href="lngdo_while_..._enddo.htm">DO WHILE … ENDDO</a> loops when possible, because they're faster.</li>
<li>
When you copy data from multiple fields, <a href="lngscatter.htm">SCATTER</a> TO ARRAY is faster than <a href="lngscatter.htm">SCATTER</a> MEMVAR.</li>
<li>
To use memory most efficiently, avoid creating objects before you need them, and clear objects when you finish with them to free memory.<p class=atl>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;You can test how much memory each object consumes by calling the <a href="lngsyslp1016rp___user_object_memory_use.htm">SYS(1016)</a> function.</p></li>
<li>
Send output to the topmost window whenever possible; updating windows behind the top window is substantially slower. Causing output to scroll behind a window is nearly a worst-case event.</li>
<li>
Disable status display with the <a href="lngset_talk.htm">SET TALK OFF</a> command, which eliminates the overhead of screen update.</li>
<li>
Set the <a href="lngset_dohistory.htm">SET DOHISTORY</a> command to OFF to avoid updating the command window each time a program runs.</li>
</ul>
<h3>Using Name Expressions Instead of Macro Substitution</h3>
<p>
If you use name expressions instead of macro substitution, program performance will greatly improve. For example, if you assign a value to the variable <code>cFile</code>, a name expression created with <code>cFile</code> is faster than macro substitution.</p>
<pre><code>cFile = "CUST"
use &amp;cFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Macro substitution, slow
use (cFile)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Name expression: faster, preferred
</code></pre>

<h3><a name="dgreferencing_object_properties_efficiently"></a>Referencing Object Properties Efficiently</h3>
<p>
By understanding how Visual FoxPro works with properties and objects, you can make your applications run more efficiently.</p>

<h4><a name="dgoptimizing_repeated_references_to_a_property"></a>Optimizing Repeated References to a Property</h4>
<p>
When you reference an object property with the <i>object.property</i> syntax, Visual FoxPro must search for the object before it can access the property. If you must access the property repeatedly, this search strategy can slow performance.</p>
<p>
To avoid referencing the same procedure repeatedly (such as in a loop), read the property value into a variable, make changes, and then set the property once when you're through. For example, the following code fills a property array by first creating an array in memory, filling it, and then setting the property only once at the end:</p>
<pre><code>* Copy string to a local variable
lcChar = THISFORM.cCharString
LOCAL laCharArray[256]&nbsp;&nbsp; &amp;&amp; Create local array
FOR nCounter = 1 to 256
 &nbsp; laCharArray[x] = SUBSTR(laChar,x,1)
ENDFOR
* Copy the local array to the property array
ACOPY(laCharArray,THISFORM.aCharArray)
</code></pre>
<h4>Referencing Multiple Properties Efficiently</h4>
<p>
If you update more than one property for the object, Visual FoxPro must search for the object multiple times, which can affect performance. In the following example, the code causes Visual FoxPro to search through four objects (such as <code>THISFORM</code>, <code>pgfCstInfo</code>, <code>pgCstName</code>, and <code>txtName</code>) to find the property to be set. Because the code sets two properties, the fourfold search is done twice:</p>
<pre><code>THISFORM.pgfCstInfo.pgCstName.txtName.Value = ;
 "Fred Smith"
THISFORM.pgfCstInfo.pgCstName.txtName.BackColor = ;
 RGB (0,0,0)&nbsp; &amp; Dark red
</code></pre>
<p>
To avoid this overhead, use the <a href="lngwith_..._endwith.htm">WITH … ENDWITH</a> command. This method causes Visual FoxPro to find the object once. For example, the following example accomplishes the same task as the previous one, but faster:</p>
<pre><code>WITH THISFORM.pgfCstInfo.pgCstName.txtName
 &nbsp; .Value = "Fred Smith"
 &nbsp; .BackColor = RGB (0,0,0)&nbsp; &amp; Dark red
ENDWITH
</code></pre>
<p>
You can also store an object reference in a variable, then include the variable in place of the object reference:</p>
<pre><code>oControl = THISFORM.pgfCstInfo.pgCstName.txtName
oControl.Value = "Fred Smith"
oControl.BackColor = RGB (0,0,0)&nbsp; &amp; Dark red
</code></pre>

<h2><a name="dgoptimizing_activex_controls"></a>Optimizing ActiveX Controls</h2>
<p>
If you use Automation or ActiveX controls in your application, you can fine-tune the application to get the best performance out of both ActiveX controls and Automation.</p>
<h3>Using ActiveX Controls Efficiently</h3>
<p>
For best performance when using ActiveX controls in your forms, use the following suggestions:</p>
<ul type=disc>
<li>
Start Automation servers in advance. Controls bound to general fields will generally perform better when the servers for those data types (like Microsoft Excel or Word) are already running on the client’s machine.</li>
<li>
Insert objects “As Icon.” When you insert an ActiveX control into a field, insert it as an icon or placeholder rather than as an entire object. This reduces the amount of storage space required because Visual FoxPro stores a presentation image with the object, which can consume a lot of storage space. Inserting an object as an icon also increases performance for drawing the object.</li>
<li>
Use image controls. If you want to display a bitmap (such as a company logo), image controls are much faster than OLEBound controls.</li>
<li>
Use manual links whenever possible. Manual links to objects are faster because they avoid the notification time required for automatic links, and because the server doesn’t need to be started to draw the object. If you don’t need to update an object frequently, use manual links.</li>
</ul>
<h3>Optimizing Automation Performance</h3>
<p>
If your application interacts with other applications, you can get the best performance using the following techniques.</p>
<h4>Avoiding Multiple Instances of the Server</h4>
<p>
In some cases, Automation servers (such as Microsoft Excel) will always start a new instance, even if one is already running. To remedy this and improve performance, use the <a href="lnggetobjectlp_rp.htm">GetObject(&nbsp;)</a> function instead of <a href="lngcreateobjectlp_rp.htm">CreateObject(&nbsp;)</a>. For example, the following call will always use an existing instance, if it exists:</p>
<pre><code>x = GetObject(,"excel.Application")
</code></pre>
<p>
In contrast, the following call creates a new instance:</p>
<pre><code>x = CreateObject("excel.Application")
</code></pre>
<p>
If you call GetObject(&nbsp;) but the server isn't already running, you will get error 1426. In that case, you can trap for the error and call CreateObject(&nbsp;):</p>
<pre><code>ON ERROR DO oleErr WITH ERROR()
x = GetObject(,"excel.application")
ON ERROR&nbsp; &amp;&amp; restore system error handler

PROCEDURE oleErr
PARAMETER mError
IF mError = 1426 then
 x = CreateObject("excel.application")
ENDIF
</code></pre>
<h4>Referencing Objects Efficiently</h4>
<p>
Executing expressions that use objects within the Automation server can be expensive, particularly when evaluated multiple times. It is much faster to store objects’ references to variables for reference. For details, see <a href="#dgoptimizing_repeated_references_to_a_property">Optimizing Repeated References to a Property</a> earlier in this chapter.</p>

<h2><a name="dgoptimizing_applications_in_multiuser_environments"></a>Optimizing Applications in Multiuser Environments</h2>
<p>
If you're writing applications for a multiuser environment, performance is particularly important, because inefficiencies are multiplied. In addition, if multiple users are accessing data, your application must handle issues of concurrency and network access.</p>
<p>
To handle these issues, you can:</p>
<ul type=disc>
<li>
Adjust lock retry interval.</li>
<li>
Use transaction processing efficiently.</li>
</ul>
<p>
You might also benefit from the suggestions for working with data stored on remote servers. For details, see <a href="#dgoptimizing_access_to_remote_data">Optimizing Access to Remote Data</a> later in this chapter.</p>
<h4>Adjusting Lock Retry Interval</h4>
<p>
If your application attempts to lock a record or table and is unsuccessful, you can have Visual FoxPro automatically retry the lock after a small interval. However, each lock attempt results in more network traffic. If network traffic is already heavy, sending repeated lock requests adds a burden to the network, and results in overall slowdown for all users.</p>
<p>
To address this situation, you can adjust the interval between lock attempts. By using a larger interval (which results in fewer retries per second), you reduce network traffic and gain performance.</p>
<p class=label>
<b>To adjust the lock retry interval</b></p>
<ul type=disc>
<li>
Call the <a href="lngsyslp3051rp___set_lock_retry_interval.htm">SYS(3051)</a> function, passing it the number of milliseconds to wait between each lock attempt.</li>
</ul>
<h4>Using Transaction Processing Efficiently</h4>
<p>
When using transaction processing, you must design transactions to minimize the impact that they have on other users. While a transaction is open, any locks set during the transaction remain locked until the transaction is committed or rolled back. Even if you issue an explicit <a href="lngunlock.htm">UNLOCK</a> command, locks are held until the <a href="lngend_transaction.htm">END TRANSACTION</a> or <a href="lngrollback.htm">ROLLBACK</a> command.</p>
<p>
Furthermore, appending records to a table requires Visual FoxPro to lock the table header. The header remains locked for the duration of the transaction, preventing other users from also appending records.</p>
<p>
To minimize the impact of transactions, design them so that they begin and end as close to the actual data update as possible; the ideal transaction contains only data update statements.</p>
<p>
If you are adding transaction processing to data updates made in a form, don't open a transaction, run the form, and then commit the transaction when the form is closed. Instead, put the transaction processing statements in the event code for the Save button (for example):</p>
<pre><code>* Save method from the cmdSave command button
BEGIN TRANSACTION
UPDATE PRODUCTS SET reorder_amt = 0 WHERE discontinued = .T.
END TRANSACTION
</code></pre>

<h2><a name="dgoptimizing_access_to_remote_data"></a>Optimizing Access to Remote Data</h2>
<p>
Data retrieval from any remote database is expensive. In order to get data from a server database, the following steps must occur:
<ol>
<li>
The client issues the query to the remote database.<br><br></li>
<li>
The server parses and compiles the query.<br><br></li>
<li>
The server generates a result set.<br><br></li>
<li>
The server notifies the client that the result is complete.<br><br></li>
<li>
The client fetches the data over the network from the server. This step can happen all at once, or the client can request that results be sent in pieces as requested.</li>
</ol>
<p>
You can use a number of techniques to speed up the retrieval (or update) of data. The following section discusses these strategies:</p>
<ul type=disc>
<li>
Retrieving only the data you need</li>
<li>
Updating remote tables efficiently</li>
<li>
Sending statements in a batch</li>
<li>
Setting packet size</li>
<li>
Delaying retrieval of memo and binary data</li>
<li>
Storing lookup data locally</li>
<li>
Creating local rules</li>
</ul>
<h3>Retrieving Only the Data You Need</h3>
<p>
In most applications that use remote data, forms and reports don't need to access all the data from a table at once. Therefore, you can speed performance by creating remote views that fetch or update only the fields and records you want, which minimizes the amount of data that needs to be transmitted across the network.</p>
<p>
To create queries that minimize the overhead of data retrieval from remote sources, follow these suggestions:</p>
<ul type=disc>
<li>
Specify only the fields you need. Don’t use the statement <code>SELECT * FROM customers</code> unless you need all the fields from the table.</li>
<li>
Include a WHERE clause to limit the number of records downloaded. The more specific your WHERE clause, the fewer records are transmitted to your computer, and the faster the query will finish.</li>
<li>
If you cannot predict at design time what values to use in a WHERE clause, you can use parameters in the clause. When the query is executed, Visual FoxPro uses the value of a parameter variable or prompts the user for the search value. For example, this query allows the application or user to fill in the region at run time:<pre><code>SELECT cust_id, company, contact, address ;
FROM customers ;
WHERE region = ?pcRegion
</code></pre>
</li>
<li>
Set the <a href="lngnodataonload_property.htm">NoDataOnLoad</a> property of the corresponding Data Environment Cursor object. This technique is commonly used with parameterized views in which the data for the parameter comes from the value of a control on a form.</li>
</ul>
<h3>Updating Remote Tables Efficiently</h3>
<p>
When you use a view to update a table on a remote data source, Visual FoxPro must check whether the record or records you are updating have been changed. To do so, Visual FoxPro must examine the data on the server and compare it to the data being held on your computer. In some instances, this can be a time-consuming operation.</p>
<p>
To optimize the process of updating data on remote data sources, you can specify how Visual FoxPro should check for changed records. To do this, you indicate the WHERE clause that Visual FoxPro should generate in order to perform the update.</p>
<p>
For example, imagine that you are using a view based on a customer table on a remote data source. You created the view using a <a href="lngselect___sql.htm">SELECT - SQL</a> statement such as this one:</p>
<pre><code>SELECT cust_id, company, address, contact ; 
 &nbsp; FROM customers ;
 &nbsp; WHERE region = ?vpRegion
</code></pre>
<p>
You want to be able to update all four fields that you have specified in the view except the key field (<code>cust_id</code>). The following table illustrates the WHERE clause that Visual FoxPro will generate for each of the options available under the SQL WHERE clause.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The <a href="lngoldvallp_rp.htm">OLDVAL(&nbsp;)</a> function returns the pre-update version of fields you modified, and the <a href="lngcurvallp_rp.htm">CURVAL(&nbsp;)</a> function returns the current value stored on the remote data source. By comparing them, Visual FoxPro can determine whether the record has changed on the remote data source since you downloaded it to your computer.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Setting</b></td>
<td class=label width=70%><b>Resulting WHERE clause</b></td>
</tr>
<tr valign=top>
<td width=30%>Key fields only</td>
<td width=70%><pre><code>WHERE OLDVAL(cust_id) = CURVAL(cust_id)</code></pre>
</td>
</tr>
<tr valign=top>
<td width=30%>Key and updatable fields<br>
(default)</td>
<td width=70%><pre><code>WHERE OLDVAL(cust_id) = CURVAL(cust_id) AND</code><pre><code>&nbsp;&nbsp;&nbsp;OLDVAL(&lt;mod_fld1&gt;) = CURVAL(&lt;mod_fld2&gt;) AND
 &nbsp; OLDVAL(&lt;mod_fld2&gt;) = CURVAL(&lt;mod_fld2&gt;) AND
 &nbsp; ...</code></pre>
</pre>
</td>
</tr>
<tr valign=top>
<td width=30%>Key and modified fields</td>
<td width=70%><pre><code>WHERE OLDVAL(cust_id) = CURVAL(cust_id) AND</code><pre><code>&nbsp;&nbsp;&nbsp;OLDVAL(company) = CURVAL(company) AND
 &nbsp; OLDVAL(contact) = CURVAL(contact) AND
 &nbsp; OLDVAL(address) = CURVAL(address)</code></pre>
</pre>
</td>
</tr>
<tr valign=top>
<td width=30%>Key and timestamp</td>
<td width=70%><pre><code>WHERE OLDVAL(cust_id) = CURVAL(cust_id) AND</code><pre><code>&nbsp;&nbsp;&nbsp;OLDVAL(timestamp) = CURVAL(timestamp)</code></pre>
</pre>
</td>
</tr>
</table><br>
<p>
In general, you should choose an option for the SQL WHERE clause in this order of preference:
<ol>
<li>
<b>Key and timestamp</b>, if the remote database supports timstamped fields, which is the fastest way to tell if a record has changed.<br><br></li>
<li>
<b>Key and modified fields</b>, because the fields you update to the server are almost always a subset of the total number of fields that you could update.<br><br></li>
<li>
<b>Key and updatable fields</b>.<br><br></li>
<li>
<b>Key fields only</b>. Using this settings implies that the remote server will insert an entirely new record using the changed key, and will delete the old record.</li>
</ol>
<h3>Sending Statements in a Batch</h3>
<p>
Some servers (such as Microsoft SQL Server) allow you to send a batch of SQL statements in a single packet. This speeds performance because you reduce network traffic, and because the server can compile multiple statements at once.</p>
<p>
For example, if you specify a batch size of four, then update 10 records in a database, Visual FoxPro sends four statements such as the following to the server database in one batch:</p>
<pre><code>UPDATE customer SET contact = "John Jones" ; 
 &nbsp; WHERE cust_id = 1;
UPDATE customer SET contact = "Sally Park" ; 
 &nbsp; WHERE cust_id = 2;
UPDATE customer SET company = "John Jones" ;
 &nbsp; WHERE cust_id = 3;
UPDATE customer SET contact = "John Jones" ;
 &nbsp; WHERE cust_id = 4
</code></pre>
<p class=label>
<b>To send statements in a batch</b>
<ul type=disc>
<li>
In the <b>Options</b> dialog box, choose the <b>Remote Data</b> tab, and then under <b>Records to batch update</b>, specify the number of records to include in a batch.<p class=tl>
-or-</P></li>
<li>
Call the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> or <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> functions to set these properties:<ul type=disc>
<li>
Set Transaction to 2.<br><br></li>
<li>
Set BatchUpdateCount to the number of statements to send in a batch.</li>
</ul>
<p class=tl>
-or-</P></li>
</ul>
<ol>
<li>
In the <b>View Designer</b>, choose <b>Advanced Options</b> from the <b>Query</b> menu to display the <b>Advanced Options</b> dialog box.<br><br></li>
<li>
In the <b>Performance</b> area, next to <b>Number of records to batch update</b>, specify the number of statements to send in a batch.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You should experiment with different values for this property and the PacketSize property to optimize your updates.</p></li>
</ol>
<h3>Setting Packet Size</h3>
<p>
You can optimize access to remote servers by fine-tuning the size of the network packet that is sent to and retrieved from the remote database. For example, if your network supports large packet sizes (greater than 4,096 bytes), you can increase the packet size in Visual FoxPro in order to send more data each time you read or write to the network.</p>
<p class=label>
<b>To set packet size</b>
<ul type=disc>
<li>
Call the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> or <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> functions and set the PacketSize property to a positive integer value. The default value is 4,096.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Different network providers will handle this property differently, so you should consult your network service documentation. Novell NetWare, for example, has a maximum packet size of 512 bytes so setting the PacketSize property to a value greater than this will have no additional benefit.</p></li>
</ul>
<h3>Delaying Retrieval of Memo and Binary Data</h3>
<p>
If you're storing Memo or binary data on a remote server, you can improve performance by delaying the download of this data until your application actually requires it.</p>
<p class=label>
<b>To delay retrieval of memo and binary data</b>
<ul type=disc>
<li>
In the <b>Options</b> dialog box, choose the <b>Remote Data</b> tab, and then under <b>Remote view defaults</b>, set <b>Fetch memo</b>.<p class=tl>
-or-</P></li>
<li>
Call the <a href="lngdbsetproplp_rp.htm">DBSETPROP(&nbsp;)</a> or <a href="lngcursorsetproplp_rp.htm">CURSORSETPROP(&nbsp;)</a> functions to set the FetchMemo property.</li>
</ul>
<h3>Storing Lookup Data Locally</h3>
<p>
Many applications include static lookup data such as state abbreviations, postal codes, and employee titles. If your application contains this type of data, and if the table is not too large, you might be able to speed up your application by keeping copies of this information on each user’s computer, because lookups do not generate network traffic.</p>
<p>
This technique is primarily useful for data that never changes or changes very rarely. If the data does change on occasion, you must devise a strategy for downloading a new copy of the lookup table to each user’s computer.</p>
<h3>Creating Local Rules</h3>
<p>
You can gain efficiency in your application by creating local field-level and record-level rules within Visual FoxPro, rather than relying on rules defined on the server. These rules can prevent data that doesn’t conform to data or business rules from getting into the database.</p>
<p>
By defining rules in Visual FoxPro, you trap the invalid data before it's sent across the network, which is faster, and which gives you better control for handling error conditions. However, using local rules also means that you must coordinate them with rules on the remote server. For example, if there are changes to the rules on the server, you might have to change your local rules to match.</p>
<p>
For details about creating local rules, see the section <a href="dgcreating_views.htm#dgupdating_data_in_a_view">Updating Data in a View</a> in Chapter 8, “Creating Views.”</p>

<h2><a name="dgoptimizing_international_applications"></a>Optimizing International Applications</h2>
<p>
If you're developing international applications, you might need to manage the collating sequence of your data for optimal performance. This section discusses:</p>
<ul type=disc>
<li>
Using collating sequence efficiently.</li>
<li>
Using <a href="lngselect___sql.htm">SELECT - SQL</a> with multiple collating sequences.</li>
</ul>
<h3>Using Collating Sequence Efficiently</h3>
<p>
If your data doesn't include <a href="glsdiacritical_marks.htm">diacritical marks</a>, such as accents (á) or umlauts (ü), you can improve performance by using the machine collating sequence because:</p>
<ul type=disc>
<li>
Non-machine index keys are twice as large because they contain the diacritical information.</li>
<li>
Non-machine collation uses many special rules for indexing characters to return proper results.</li>
</ul>
<p>
Because the machine collate sequence is faster, it's usually preferred for joins and searching, while other collate sequences are perfect for ordering records.</p>
<p>
When you create an index, Visual FoxPro uses the current setting of <a href="lngset_collate.htm">SET COLLATE</a>. Therefore, if you want to create two indexes with two collating sequences, you can use a sequence of commands such as the following:</p>
<pre><code>SET COLLATE TO "MACHINE"
INDEX ON lastname TAG _lastname&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; join/seek index
SET COLLATE TO "GENERAL"
INDEX ON lastname TAG lastname&nbsp; &amp;&amp; sort index
</code></pre>
<p>
When you want to seek, select, or join on the field <code>lastname</code>, issue the command SET COLLATE TO “MACHINE” before performing the operation. Rushmore will then use the index created in the machine collate sequence, and the search operation will be very fast.</p>
<h3>Using SQL SELECT with Multiple Collating Sequences</h3>
<p>
When you issue a <a href="lngselect___sql.htm">SELECT - SQL</a> command, Visual FoxPro uses the current collating sequence for searching and for the ORDER BY and GROUP BY clauses. If you want to search and sort using different collating sequences, you can split your SQL commands into two steps as follows:</p>
<pre><code>* Select records using one collating sequence
SET COLLATE TO "MACHINE"
SELECT * FROM table INTO CURSOR temp1 ;
  WHERE lname = "Müller"
* Order records using a different collating sequence
SET COLLATE TO "GENERAL"
SELECT * FROM temp1 INTO TABLE output ORDER BY lastname
</code></pre>
</BODY>
</HTML>
