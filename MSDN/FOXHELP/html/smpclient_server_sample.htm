<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client/Server Sample</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="smpclient_server_sample"></a>Client/Server Sample</h1>
<p>
The Client/Server sample illustrates some of the features listed below that make Visual FoxPro an ideal front end development tool for client/server applications:
<ul type=disc>
<li>
Working with local tables, local views, and remote views.<br><br></li>
<li>
Upsizing local tables to the back end.<br><br></li>
<li>
Using 2- and 3- tier client/server models.<br><br></li>
<li>
Updating data.<br><br></li>
<li>
Managing update conflicts.<br><br></li>
<li>
Working with online and offline views.</li>
</ul>
<p class=label>
<b>To run the Client/Server sample application</b>
<ul type=disc>
<li>
Enter the following line of code in the Command window:<pre><code>DO (HOME(2) + 'csapp\sample')
</code></pre>
<p class=tl>
-or-</P></li>
</ul>
<ol>
<li>
From the <b>Program</b> menu, choose <b>Do</b>.<br><br></li>
<li>
Choose the …\<b>Samples\Vfp98\CSApp</b> folder.<br><br></li>
<li>
Double-click <b>Sample.app</b>.</li>
</ol>
<p class=label>
<b>To open the project for the Client/Server sample application in the Project Manager</b>
<ul type=disc>
<li>
Enter the following line of code in the Command window:<pre><code>MODIFY PROJECT (HOME(2) + 'csapp\sample')
</code></pre>
</li>
</ul>
<p>
Note that if you receive a “Class definition Bizrules.SalaryRule is not found” error when you select the <b>Business Rules</b> section, open the BizRules project in the CSApp folder and rebuild the .exe for the project. Building the .exe registers the class in the Windows registry and prevents this error.</p>
<p class=indent>
<b>Note</b>&nbsp;&nbsp;&nbsp;Code examples in these topics have been edited to emphasize particular lines. To see the full code, including error checking and verification, open the classes and programs in the project.</p>
<h2>Client/Server Sample Application Classes</h2>
<p>
Most of the functionality in the Client/Server sample application is built into classes. Objects based on these classes are created in response to user actions.</p>
<h3>CSEngine</h3>
<p>
When you run the application, an object is created in Csmain.prg based on the CSEngine class in csprocs.prg:</p>
<pre><code>oEngine = CREATEOBJECT('csengine')
</code></pre>
<p>
The CSEngine class provides generic environment setup and cleanup and utility method, as well as methods that manage application functionality.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b>Method</b></td>
<td class=label width=68%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=32%>DropTable</td>
<td width=68%>Deletes a table on the back end database.</td>
</tr>
<tr valign=top>
<td width=32%>ExecuteTempSPT</td>
<td width=68%>Execute SQL pass through commands and manage errors generated by the pass through.</td>
</tr>
<tr valign=top>
<td width=32%>ServerStart</td>
<td width=68%>Create the business rule object that validates employee salaries.</td>
</tr>
<tr valign=top>
<td width=32%>ServerStop</td>
<td width=68%>Releases the business rule object.</td>
</tr>
<tr valign=top>
<td width=32%>ServerValidateRow</td>
<td width=68%>Validates data using the business object.</td>
</tr>
</table><br>
<p>
For information about these and other methods in the CSEngine class, look at the code in Csprocs.prg.</p>
<h3>OpenDBC</h3>
<p>
After creating the oEngine object, code in Csmain.prg creates an object based on the OpenDBC form in Sample.vcx:</p>
<pre><code>oStartForm = CREATEOBJECT('OpenDBC')
</code></pre>
<p>
The OpenDBC form allows a user to open the sample database, exclusively or shared, to close the database, and to modify the connection to the back end database. You’ll need a connection to a back-end database to upsize the table in this sample and access it as a remote view.</p>
<p>
There is also code to create and show this form in the Click event of the <b>Database</b> button on the SampleApp form.</p>
<p>
OpenDBC is a modal form. When you choose <b>OK</b> in the OpenDBC form, the following code is executed and program execution is continued.</p>
<pre><code>RELEASE THISFORM
oEngine.Start = .T.
</code></pre>
<p>
If the OpenDBC form was created in Csmain.prg, the following code executes when OpenDBC is closed, creating an instance of the SampleApp class in Sample.vcx:</p>
<pre><code>IF oEngine.Start
 &nbsp; oCSApp = createobject('SampleApp')
 &nbsp; oCSApp.Show
ENDIF</code></pre>
<h3>SampleApp</h3>
<p>
SampleApp is the main form in the Client/Server sample application. This form contains a page frame with two pages. Controls on the first page allow you to open the table, local view, and remote view; upsize the table; restore the original data in the table; and toggle the views online and offline. Controls on the second page allow you to see and edit data in the selected table or view.</p>
<p>
Code in the SampleApp form provides access to more encapsulated functionality by creating two additional objects as needed: Salaryrule and Conflicts.</p>
<h3>SalaryRule</h3>
<p>
SalaryRule is a class in an Automation server. The project for the Automation server is Bizrules.pjx and the class is defined in Bizrules.prg:</p>
<pre><code>DEFINE CLASS salaryrule AS Custom OLEPUBLIC
</code></pre>
<p>
Code associated with the Click event of the chkRules check box makes a call to the StartServer method of CSEngine. Code in the StartServer method creates an instance of the SalaryRule class:</p>
<pre><code>this.oServer = CREATEOBJECT('Bizrules.SalaryRule')
</code></pre>
<p>
For more information, see Implementing Business Rules in the Client/Server Sample Application later in this section.</p>
<h3>Conflicts</h3>
<p>
The Conflicts form class displays current value, old value and changed values of fields in a record with a data conflict. An instance of the Conflicts class is created in the ResolveConflicts method of the SampleApp form:</p>
<pre><code>frmConflicts = createobject('Conflicts')
frmConflicts.Show
</code></pre>
<p>
For more information on conflict resolution, see Managing Data Conflicts in the Client/Server Sample Application later in this section.</p>
<h2>Client/Server Sample Application Database</h2>
<p>
The database in the Client/Server sample application is small and designed only to show the basics of client/server implementation.</p>
<h3>Selecting the Database</h3>
<p>
You can select the database for the Client/Server sample in Step 1 in the <b>Open Database</b> dialog box. The sample requires Cs.dbc, installed in the same folder that the other files in the Client/Server sample are installed. If your default folder is the Visual Studio …\Samples\Vf98\Csapp folder, or if this folder is in your path, the database is automatically selected for you.</p>
<p>
The CS database contains the following.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b>Tables</b></td>
<td class=label width=65%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=35%>Employee</td>
<td width=65%>A table with employee ids, names, addresses, and so on.</td>
</tr>
<tr valign=top>
<td width=35%>Emp_init</td>
<td width=65%>A back up table for employee. After you change the data in the employee table while trying out the options in the sample, you can restore the original data from this table by choosing the <b>Reset Initial Data</b> button in the SampleApp form.</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b>Views</b></td>
<td class=label width=65%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=35%>Emp_view_local</td>
<td width=65%>A local view containing all the fields and records from the employee table.</td>
</tr>
<tr valign=top>
<td width=35%>Emp_view_remote</td>
<td width=65%>A remote view containing all the fields and records from the employee table</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b>Connection</b></td>
<td class=label width=65%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=35%>Emp_connection</td>
<td width=65%>A connection to a data source for the emp_view_remote view. You need to establish this connection before you can open emp_view_remote.</td>
</tr>
</table><br>
<h3>Opening the Database</h3>
<p>
Step 2 in the <b>Open Database</b> dialog box allows you to open or close the database.</p>
<p>
Code associated with the Click event of the <b>Open</b> button opens the database. Before opening the database, the DatabaseIsOpened property of the Engine object is set to true (.T.), assuming that the database will be opened.</p>
<pre><code>OEngine.DatabaseIsOpened = .T.
lcExclusive = IIF(this.parent.chkExclDatabase.value = 1, 'EXCLUSIVE', 'SHARED')
OPEN DATABASE (OEngine.DatabaseFile) &amp;lcExclusive
</code></pre>
<p>
If the database cannot be opened, the Error event of the <b>Open</b> button is triggered, the DatabaseIsOpened property of the Engine object is set to false (.F.), and an error message is displayed.</p>
<h3>Modifying the Remote Connection</h3>
<p>
Step 3 in the <b>Open Database</b> dialog box allows you to open the Visual FoxPro Connection Designer to set up a remote connection. You’ll need a connection to a back-end database to upsize the table in this sample and access it as a remote view, and you’ll need to modify the connection to provide a user ID, password, and connection string.</p>
<p>
For information about setting up remote connections, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>, in the <i>Programmer's Guide</i>.</p>
<h2>Selecting a Data Cursor in the Client/Server Sample Application</h2>
<p>
The first page on the SampleApp form allows you to open the table, view, or remote view. The code associated with the Click event of cmdOpen uses the <a href="lnguse.htm">USE</a> command to open the local table, local view, or remote view, based on the Value of the opgCursorType option button group.</p>
<p>
The lblStatus label displays status information about the table or view. Code in the GetStatus method of attempts to open the table or view exclusively and updates the label caption. If the table or view could not be opened exclusively, it is opened shared. If it could not be opened shared, the Caption of lblStatus is set to indicate that the table or view is already opened exclusively.</p>
<h2>Updating Data in the Client/Server Sample Application</h2>
<p>
When you edit data in the table and the buffering is <b>No Buffering</b> (<a href="lngcursorsetproplp_rp.htm">CURSORSETPROP</a><code>(“Buffering”, 1)</code>) the changes are made directly to the table data. You cannot choose <b>Update</b> or <b>Revert</b>.</p>
<p>
<img src="afh0008.gif" border=0></p>
<p>
When you choose any other buffering option, you have the option to update or revert changes made to the data.</p>
<p>
When you are updating buffered data, locally or remotely, use the <a href="lngtableupdatelp_rp.htm">TABLEUPDATE(&nbsp;)</a> function. The arguments in this function allow you to determine the update scope and whether or not to force updates. For example, the following lines of code are executed in the Click event of the <b>Update</b> button in the SampleApp form:</p>
<pre><code>lnUpdateType = this.parent.opgUpdate.value - 1
llForce = this.parent.chkForce.value
llUpdate = TABLEUPDATE(lnUpdateType, llForce)
</code></pre>
<p>
The lnUpdateType value is determined by the option button chosen in the <b>Update Scope</b> area.</p>
<p>
<img src="afh0009.gif" border=0></p>
<p>
There are three options for the update scope.</p>
<h3>Row Update</h3>
<p>
When the first argument in the TABLEUPDATE(&nbsp;) function is 0, only the current row is updated, regardless of whether table or row buffering is enabled. Changes made in any other rows are not written to the data source.</p>
<h3>Table Update</h3>
<p>
When the first argument in the TABLEUPDATE(&nbsp;) function is 1, the rows in the table that have been changed are updated, beginning with the first updated row. If a data conflict is encountered, that is, if the <a href="lngcurvallp_rp.htm">CURVAL(&nbsp;)</a> for a field in the row is different from the <a href="lngoldvallp_rp.htm">OLDVAL(&nbsp;)</a> for that field, table updating is stopped on the row that generated the conflict.</p>
<h3>Table Update All</h3>
<p>
When the first argument in the TABLEUPDATE(&nbsp;) function is 2, the rows in the table that have been changed are updated, beginning with the first updated row. All rows without a data conflict are updated.</p>
<p>
Other options are specified in the <b>Update Options</b> area.</p>
<p>
<img src="afh0007.gif" border=0></p>
<h3>Forcing Updates</h3>
<p>
The second argument in the TABLEUPDATE(&nbsp;) function specifies whether or not to force updates. If you choose <b>Force</b> in the Update Options area, the second argument in the TABLEUPDATE(&nbsp;) function is true (.T.) and your changes will automatically override any changes that might have been made to the data after you began editing. There cannot be any conflicts to resolve if you force updates.</p>
<p class=indent>
<b>Note</b>&nbsp;&nbsp;&nbsp;If the user has changed the primary key of a record, the row cannot be updated and is deleted in you local cursor.</p>
<h3>Resolving Conflicts</h3>
<p>
If <b>Resolve Conflicts</b> is selected, the Client/Server sample application finds conflicts when they occur and allows you to see the conflicting data and decide to override the existing changes or discard your own changes. If <b>Resolve Conflicts</b> is not selected, your data will not be updated if a conflict is detected:</p>
<pre><code>IF this.parent.chkConflicts.value
 &nbsp; thisform.ResolveConflicts
ELSE
 &nbsp; wait window 'Update failed' nowait timeout 5
ENDIF
</code></pre>
<p>
For more information about resolving conflicts, see Managing Data Conflicts in the Client/Server Sample Application later in this section.</p>
<h3>Business Rules</h3>
<p>
If <b>Business Rules</b> is selected, the Client/Server sample application enforces the business rules established for this application.&nbsp; For information about the <b>Business Rules</b> option, see Implementing Business Rules in the Client/Server Sample Application later in this section.</p>
<h3>Upsizing the Employee Table</h3>
<p>
The code for upsizing the database is associated with the Click event of cmdUpsize in the Client/Server Application form. The code performs these actions:
<ol>
<li>
Connects to the backend data source.<br><br></li>
<li>
Drops the table if it already exists.<br><br></li>
<li>
Creates a character string that includes the SQL CREATE TABLE command.<br><br></li>
<li>
Executes the SQL command by calling <a href="lngsqlexeclp_rp.htm">SQLEXEC(&nbsp;)</a> with the character string as an argument.<br><br></li>
<li>
Opens the employee table.<br><br></li>
<li>
Opens the remote view in the database.<br><br></li>
<li>
Appends the records from the local table to the remote view.<br><br></li>
<li>
Updates the remote view with TABLEUPDATE(&nbsp;).</li>
</ol>
<h3>Creating an Offline View</h3>
<p>
The code to create or drop the offline view is associated with the Offline method of the SampleApp form.</p>
<pre><code>IF lcMode = 'create'
 &nbsp; =createoffline(lcView)
ELSE
 &nbsp; =dropoffline(lcView)
ENDIF
</code></pre>
<h2>Managing Data Conflicts in the Client/Server Sample Application</h2>
<p>
If the data in the source table is changed while another user is editing it, there is a possible conflict.&nbsp; You have several ways of resolving this conflict in the <b>Update Options</b> area of the Client/Server Sample form.</p>
<p class=label>
<b>Update Options Area</b></p>
<p>
<img src="afh0007.gif" border=0></p>
<p>
If you select <b>Force</b> in the <b>Update Options</b> area, any changes to the data that were made after you started editing are written over when you update the data with your changes.</p>
<p>
If you choose <b>Resolve Conflicts</b> in the <b>Update Options</b> area, the Client/Server sample application finds conflicts when they occur and allows you to see the conflicting data and decide to override the existing changes or discard your own changes. If you do not choose <b>Resolve Conflicts</b>, your data will not be updated if a conflict is detected:</p>
<pre><code>IF this.parent.chkConflicts.value
 &nbsp; thisform.ResolveConflicts
ELSE
 &nbsp; wait window 'Update failed' nowait timeout 5
ENDIF
</code></pre>
<p>
If you choose Business Rules in the Update Options area, the applications updates the data according to your business rules.&nbsp; For more information about the Business Rules option, see Implementing Business Rules later in this section.</p>
<p class=label>
<b>To generate a data conflict</b>
<ol>
<li>
Run two separate instances of Visual FoxPro to simulate multiple users accessing the database.<br><br></li>
<li>
Run the Client/Server sample application in each instance.<br><br></li>
<li>
Enable buffering in both sessions.<br><br></li>
<li>
Make sure the <b>Force</b> check box is not selected in either instance of Visual FoxPro.<br><br></li>
<li>
Make changes in each session to the same fields in the same row of the table.<br><br></li>
<li>
Update the table in one of the sessions.<br><br></li>
<li>
Update the table in the other session.</li>
</ol>
<p>
When you choose to update the table the second time, the following line of code in the Click event of cmdUpdate attempts to update the table.</p>
<pre><code>llUpdate = TABLEUPDATE(lnUpdateType, llForce)
</code></pre>
<p>
If llForce is set to true (.T.), changes made in the other session are overridden. If llForce is set to false (.F.) a data conflict is detected and the TABLEUPDATE(&nbsp;) function returns false. If llUdate is set to false, the ResolveConflicts method is called:</p>
<pre><code>IF llUpdate
 &nbsp; wait window 'Update succeded' nowait timeout 5
ELSE
 &nbsp; frmConflicts = createobject('Conflicts')
 &nbsp; frmConflicts.show
ENDIF
</code></pre>
<p>
Code in the Activate event of the Conflicts form creates a cursor with three blank records to display the current values, the old values, and the changed values of the row</p>
<pre><code>=AFIELDS('aEmployee')
SELECT 0
CREATE CURSOR CS_CONFLICTS FROM ARRAY aEmployee

APPEND BLANK
APPEND BLANK
APPEND BLANK
</code></pre>
<p>
Code associated with the Next method of the Conflicts form populates the cursor with Populate which is the conflict grid with the old, new, and changed values. For example, the following FOR loop fills a record with the old values in the table:</p>
<pre><code>FOR m.i = 1 TO ALEN(aEmployee, 1)
 &nbsp; REPLACE (aEmployee[m.i,1]) WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; OLDVAL(aEmployee[m.i,1], lcEmployee)
ENDFOR
</code></pre>
<p>
When users can see exactly what the data conflicts are, they are in a better position to decide whether to override the new values, revert the changes they made, or ignore the conflict.</p>
<p>
Code in the Click event of cmdUpdate on the Conflicts form forces the update:</p>
<pre><code>llUpdate = TABLEUPDATE(.F., .T.)
</code></pre>
<p>
Code in the Click event of cmdRevert throws away the changes the user made:</p>
<pre><code>lnRows = TABLEREVERT(.F.)
</code></pre>
<p>
If the user chooses <b>Ignore</b> in the Conflicts form, processing continues on the other conflicts in the table.</p>
<h2>Implementing Business Rules in the Client/Server Sample Application</h2>
<p>
The Client/Server sample application uses a custom Automation server to enforce business rules. This architecture, known as the three-tier model, allows implementation of business rules in the middle tier, separate from the actual data and separate from the client interface. Multiple applications and multiple databases can all use the same set of business rules, coded and maintained in a single location.</p>
<p>
The custom Automation server in the Client/Server sample application is Bizrules. The project for the Automation server is Bizrules.pjx and the class is defined in Bizrules.prg:</p>
<pre><code>DEFINE CLASS SalaryRule AS Custom OLEPUBLIC
</code></pre>
<p>
Code in the CSEngine class provides an interface to the business object with the ServerStart, ServerStop, ServerIsStarted, and ServerValidateRow methods.</p>
<p>
The ServerStart method creates an instance of the SalaryRule class. The ServerValidateRow method passes values to the server for validation: </p>
<pre><code>lcError = this.oServer.validate(m.cTitle, m.nSalary, m.dBirth, m.dHire, m.cCountry)
</code></pre>
<p>
The Validate method of the SalaryRule class enforces a common set of business rules and returns a list of error messages, one for every rule that failed. For example, the following section of code from the Validate method makes sure that the salary falls within a range specified in the Bizrules.dbf table:</p>
<pre><code>PROCEDURE validate
PARAMETERS lcTitle, lnSalary, ldBirth, ldHire, lcCountry

SELECT bizrules
LOCATE FOR lcTitle = ALLTRIM(title)
IF EOF()
 &nbsp; * Display error message
ELSE
 &nbsp; IF !BETWEEN(lnSalary, min_salary, max_salary)
 &nbsp;&nbsp;&nbsp;&nbsp; * Display error message
 &nbsp; ENDIF
ENDIF
</code></pre>
</BODY>
</HTML>
