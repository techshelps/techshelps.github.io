<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Accessing the Visual FoxPro API</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="dgaccessing_the_visual_foxpro_api"></a><sup></sup>Chapter 28: Accessing the Visual FoxPro API</h1>
<p>
If Visual FoxPro doesn't already include the features you require for your application, you can extend its capabilities by creating an ActiveX control (.ocx file) or library (.fll file) specific to Visual FoxPro, using a 32-bit compiler such as Microsoft Visual C++<sup>®</sup> version 4.0 and greater. The information in this chapter addresses both types of programs.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you're using Visual C++ version 2.x to develop an ActiveX control, you need the Control Development Kit. The procedures in this chapter assume Visual C++ version 4.0.</p>
<p>
For information about using ActiveX controls or FLLs, see Chapter 27, <a href="dgextending_visual_foxpro_with_external_libraries.htm">Extending Visual FoxPro with External Libraries</a>.</p>
<p>
This chapter discusses:</p>
<ul type=disc>
<li>
<a href="#dgcreating_a_library_or_activex_control">Creating a Library or ActiveX Object</a></li>
<li>
<a href="#dgadding_visual_foxpro_api_calls">Adding Visual FoxPro API Calls</a></li>
<li>
<a href="#dgpassing_parameters_from_and_to_visual_foxpro">Passing and Receiving Parameters</a></li>
<li>
<a href="#dgreturning_a_value_to_visual_foxpro">Returning a Value to Visual FoxPro</a></li>
<li>
<a href="#dgpassing_parameters_to_visual_foxpro_api_functions">Passing Parameters to Visual FoxPro API Functions</a></li>
<li>
<a href="#dgaccessing_visual_foxpro_variables_and_fields">Accessing Visual FoxPro Variables and Fields</a></li>
<li>
<a href="#dgmanaging_memory">Managing Memory</a></li>
<li>
<a href="#dgbuilding_and_debugging_libraries_and_activex_controls">Building and Debugging Libraries and ActiveX Controls</a></li>
</ul>

<h2><a name="dgcreating_a_library_or_activex_control"></a>Creating a Library or ActiveX Object</h2>
<p>
You can extend the capabilities of Visual FoxPro by creating programs in C or C++ that accomplish tasks required by your application. For example, if your application requires direct access to Windows facilities, you can write a C or C++ program that makes calls to the Windows API, then returns information to Visual FoxPro.</p>
<p>
You can create three types of programs to access the Visual FoxPro API:</p>
<ul type=disc>
<li>
An ActiveX control (.ocx file).</li>
<li>
A COM object.</li>
<li>
A DLL specific to Visual FoxPro. Because the DLL can be called only from Visual FoxPro, it is customary to name it with the extension .fll.</li>
</ul>
<p>
Each type of program has advantages. An ActiveX control:</p>
<ul type=disc>
<li>
Can be accessed using standard object-oriented techniques, such as setting its properties and invoking its methods.</li>
<li>
Can be subclassed, and its methods overridden.</li>
<li>
Is encapsulated, and can be called (instantiated) multiple times without complex environment management to preserve user states.</li>
<li>
Features simpler parameter passing.</li>
<li>
Can also be called from other Windows programs, if you program it with this in mind.</li>
</ul>
<p>
The advantages of COM objects:</p>
<ul type=disc>
<li>
Can be accessed using standard object-oriented techniques, such as setting its properties and invoking its methods.</li>
<li>
Its methods can be overridden.</li>
<li>
Is encapsulated, and can be called (instantiated) multiple times without complex environment management to preserve user states.</li>
<li>
Features simpler parameter passing.</li>
<li>
Can also be called from other Windows programs, if you program it with this in mind.</li>
</ul>
<p>
On the other hand, an .fll library:</p>
<ul type=disc>
<li>
Might be familiar to you if you've used previous versions of Visual FoxPro.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you want to use an .fll library from a version of Visual FoxPro earlier than 5.0, the library must be recompiled to work with Visual FoxPro 6.0.</p></li>
</ul>
<h3>Creating a Basic ActiveX Object</h3>
<p>
You can create COM objects with the ActiveX Template Library provided with Microsoft Visual C++ 5.0. For more information about creating COM objects with Visual C++ 5.0, search for “ATL” in the MSDN Library.</p>
<p>
You create ActiveX controls specific to Visual FoxPro as you would any similar control. Most C++ compilers allow you to create skeletons of the control, and they can also be created with the Microsoft Visual Basic<sup>®</sup> Control Creation Edition version 5.0.</p>
<p>
The follow sections describe the steps for creating an ActiveX control with Microsoft Visual C++for use in Visual FoxPro.</p>
<p class=label>
<b>To create a project for the ActiveX control</b>
<ol>
<li>
Start Microsoft Visual C++.<br><br></li>
<li>
From the <b>File</b> menu, choose <b>New</b>.<br><br></li>
<li>
In the <b>New</b> dialog box, choose <b>Project Workspace</b>.<br><br></li>
<li>
In the <b>New Project</b> <b>Workspace</b> dialog box, specify a project name.<br><br></li>
<li>
In the <b>Type</b> list, choose <b>OLE ControlWizard</b>.<br><br></li>
<li>
Choose <b>Create</b>, and then follow the steps in the wizard.</li>
</ol>
<p>
When the wizard is finished, you can build the ActiveX control immediately. However, you'll also need to define properties and methods for the control.</p>
<p class=label>
<b>To add properties and methods to the ActiveX control</b>
<ol>
<li>
From the <b>View</b> menu, choose <b>ClassWizard</b>.<br><br></li>
<li>
Choose the <b>OLEAutomation</b> tab.<br><br></li>
<li>
Choose <b>Add Method</b> or <b>Add Property</b>.<br><br></li>
<li>
Fill in the name, parameter, and other information required by the element you are creating, and then choose <b>OK</b>.<br><br></li>
<li>
Choose <b>Edit Code</b> to display the editor, and then enter the code that defines the property or method you're creating.</li>
</ol>
<p>
For example, to create a Version property that returns the .ocx file version as an integer (such as 101), you create the property with a return type of <code>long</code>, and add code similar to the following:</p>
<pre><code>#define VERSION 101

long CPyCtrl::GetVersion()
{
 &nbsp; // set the version number here
 &nbsp; return VERSION;
}
</code></pre>
<p>
Because the version number is ordinarily read-only, you wouldn't create a SetVersion(&nbsp;) function.</p>
<h3>Creating a Basic FLL Library</h3>
<p>
Because an FLL library is essentially a DLL with calls to the Visual FoxPro API, you create an FLL library by following the steps in your development environment for creating a DLL.</p>
<p class=label>
<b>To create a project for the FLL library</b>
<ol>
<li>
Start Microsoft Visual C/C++.<br><br></li>
<li>
From the <b>File</b> menu, choose <b>New</b>.<br><br></li>
<li>
In the <b>New</b> dialog box, choose <b>Project Workspace</b>.<br><br></li>
<li>
In the <b>New Project</b> <b>Workspace</b> dialog box, specify a project name.<br><br></li>
<li>
In the <b>Type</b> list, choose <b>Dynamic-Link Library.</b></li>
</ol>
<p>
After creating the basic DLL structure, you add the functions you want to be able to call from Visual FoxPro. The following sections provide skeletons for creating functions in both C and C++.</p>
<h4>Setting Up a Library Template</h4>
<p>
Each function library that you create has the same basic structure. By using a template for the structure, all you have to do is fill in the blanks that apply to your specific library routine.</p>
<p>
There are five elements in a Visual FoxPro library template:
<ol>
<li>
#include statement<br><br></li>
<li>
Function definition<br><br></li>
<li>
Function code<br><br></li>
<li>
FoxInfo structure<br><br></li>
<li>
FoxTable structure</li>
</ol>
<h4>A Sample C Template</h4>
<p>
You can use the following template to create libraries written in C:</p>
<pre><code>#include &lt;Pro_ext.h&gt;

void Internal_Name(ParamBlk *parm)
{
// function code goes here.
}

FoxInfo myFoxInfo[] = {
 &nbsp; {"FUNC_NAME", (FPFI) Internal_Name, 0, ""},
};

FoxTable _FoxTable = {
 &nbsp; (FoxTable *)0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
</code></pre>
<h4>A Sample C++ Template</h4>
<p>
For C++ routines, you can use the following template. This template differs from the C template because it declares the <code>FoxTable</code> structure as external:</p>
<pre><code>#include &lt;Pro_ext.h&gt;

void Internal_Name(ParamBlk&nbsp; *parm)
{
// function code goes here.
}

 &nbsp; FoxInfo myFoxInfo[] = {
 &nbsp;&nbsp;&nbsp;&nbsp; {"FUNC_NAME", (FPFI) Internal_Name, 0, ""},
 &nbsp; };

extern "C" {
 &nbsp; FoxTable _FoxTable = {
 &nbsp;&nbsp;&nbsp;&nbsp; (FoxTable *)0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
 &nbsp; };
}
</code></pre>
<h4>Using the Template</h4>
<p>
To use the header file and create a compiled library, you need:</p>
<ul type=disc>
<li>
The header file Pro_ext.h. You can print this file to see the function declarations, typedefs, and structs used in the Visual FoxPro API.</li>
<li>
The file Winapims.lib.</li>
</ul>
<p>
Both of these files are installed in the API subdirectory when you install Visual FoxPro.</p>
<p>
The function definition returns <code>void</code> and expects the following parameter: <code>ParamBlk *parm</code>. The <code>ParamBlk</code> structure is discussed under <a href="#dgpassing_parameters_from_and_to_visual_foxpro">Passing and Receiving Parameters</a> later in this chapter.</p>
<p>
Other than the files listed above, the only other required elements of a Visual FoxPro library are the FoxInfo and FoxTable structures.</p>

<h4><a name="dgusing_foxinfo_and_foxtable_structures"></a>Using FoxInfo and FoxTable Structures</h4>
<p>
Your library functions communicate with Visual FoxPro through the FoxInfo structure. From this structure, Visual FoxPro determines the function name and the number and type of parameters. The FoxTable structure is a linked list that keeps track of the FoxInfo structures. See Pro_ext.h in the Visual FoxPro API directory for the FoxInfo and FoxTable struct definitions.</p>
<h4>FoxInfo Structure</h4>
<p>
The FoxInfo structure is the vehicle used to communicate function names and parameter descriptions between Visual FoxPro and your library. A generic FoxInfo structure looks like this:</p>
<p>
FoxInfo <i>arrayname</i>[ ] = {<br>
{<i>funcName1</i>, FPFI <i>function1</i>, <i>parmCount1</i>, <i>parmTypes1</i>}<br>
{<i>funcName2</i>, FPFI <i>function2</i>, <i>parmCount2</i>, <i>parmTypes2</i>}<br>
. . .<br>
{<i>funcNameN</i>, FPFI <i>functionN</i>, <i>parmCountN</i>, <i>parmTypesN</i>}<br>
};</p>
<p>
The placeholders are defined as follows:</p>
<p class=dt>
<i>arrayname</i></p>
<p class=indent>
A variable of type FoxInfo. Note that you can include several FoxInfo structure lines in this array.</p>
<p class=dt>
<i>funcName</i></p>
<p class=indent>
Contains the name (in uppercase and no more than 10 characters) that the Visual FoxPro user calls to invoke your function.</p>
<p class=dt>
<i>function</i></p>
<p class=indent>
The address of your C language routine. This is the exact (case-sensitive) name you use to define your function.</p>
<p class=dt>
<i>parmCount</i></p>
<p class=indent>
Specifies the number of parameters described in the <i>parmTypes</i> string or one of the following flag values.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>Value</b></td>
<td class=label width=72%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=28%>INTERNAL</td>
<td width=72%>Specifies that the function cannot be called directly from Visual FoxPro.</td>
</tr>
<tr valign=top>
<td width=28%>CALLONLOAD</td>
<td width=72%>Specifies that the routine is to be called when the library is loaded. CALLONLOAD can’t call any routine that returns results to Visual FoxPro.</td>
</tr>
<tr valign=top>
<td width=28%>CALLONUNLOAD</td>
<td width=72%>Specifies that the routine is to be called when the library is unloaded or when the Visual FoxPro QUIT command is issued. CALLONUNLOAD cannot call any routine that returns results to Visual FoxPro.</td>
</tr>
</table><br>
<p class=dt>
<i>parmTypes</i></p>
<p class=indent>
Describes the data type of each parameter. The following table lists the valid values for <i>parmTypes.</i></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=13%><b>Value</b></td>
<td class=label width=87%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=13%><pre><code>""</code></pre>
</td>
<td width=87%>No parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"?"</code></pre>
</td>
<td width=87%>Any type can be passed. In the body of the function, you'll need to check the type of the passed parameter.</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"C"</code></pre>
</td>
<td width=87%>Character type parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"D"</code></pre>
</td>
<td width=87%>Date type parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"I"</code></pre>
</td>
<td width=87%>Integer type parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"L"</code></pre>
</td>
<td width=87%>Logical type parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"N"</code></pre>
</td>
<td width=87%>Numeric type parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"R"</code></pre>
</td>
<td width=87%>Reference</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"T"</code></pre>
</td>
<td width=87%>DateTime type parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"Y"</code></pre>
</td>
<td width=87%>Currency type parameter</td>
</tr>
<tr valign=top>
<td width=13%><pre><code>"O"</code></pre>
</td>
<td width=87%>Object type parameter</td>
</tr>
</table><br>
<p>
Include a type value for each parameter passed to the library. For example, if you create a function that accepts a character and a numeric parameter, substitute “CN” for <i>parmType</i>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To indicate that a parameter is optional, precede it with a period. Only trailing parameters can be omitted.</p>
<p>
The following <code>FoxInfo</code> structure defines a library with one function — internally called <code>dates</code> and externally accessed as <code>DATES</code> — that accepts one Character type parameter:</p>
<pre><code>FoxInfo myFoxInfo[] = {
 &nbsp; { "DATES", (FPFI) dates, 1, "C" }
};
</code></pre>
<p>
When you've compiled the library with this FoxInfo structure and loaded it in Visual FoxPro with the <a href="lngset_library.htm">SET LIBRARY TO</a> command, you can call this function in Visual FoxPro with the following line of code:</p>
<pre><code>=DATES("01/01/95")
</code></pre>
<h4>FoxTable Structure</h4>
<p>
The FoxTable structure is a linked list that keeps track of all the FoxInfo structures you have for a given library:</p>
<p>
FoxTable _FoxTable = {<i>nextLibrary</i>,<i> infoCount</i>,<i>infoPtr</i>};</p>
<p>
where the placeholders are defined as follows:</p>
<p class=dt>
<i>nextLibrary</i></p>
<p class=indent>
A pointer used internally by Visual FoxPro; should be initialized to 0.</p>
<p class=dt>
<i>infoCount</i></p>
<p class=indent>
The number of Visual FoxPro external routines defined in this library.</p>
<p class=dt>
<i>infoPtr</i></p>
<p class=indent>
The address of the first element of an array of FoxInfo structures. This name must match the array name listed in the FoxInfo statement.</p>
<p>
The following is an example of a FoxTable statement. If your FoxInfo array name is <code>myFoxInfo</code>, you'll never need to change this statement:</p>
<pre><code>FoxTable _FoxTable = {
 &nbsp; (FoxTable&nbsp; *) 0,
 &nbsp; sizeof( myFoxInfo) / sizeof( FoxInfo ),
 &nbsp; myFoxInfo
};
</code></pre>

<h2><a name="dgadding_visual_foxpro_api_calls"></a>Adding Visual FoxPro API Calls</h2>
<p>
To integrate your program with Visual FoxPro, you can call Visual FoxPro API routines. These API routines are functions you can call from any C or C++ program, including an .ocx or .fll file, that give you access to variables, manage database operations, and accomplish many other Visual FoxPro-specific tasks.</p>
<p>
The following table lists the general categories of API calls available in Visual FoxPro. For details about individual API functions, see <a href="tocexternal_routines_a_z.htm">API Library Routines A-Z</a> or <a href="tocexternal_routines_by_category.htm">API Library Routines by Category</a>. </p>
<p>
To use the Visual FoxPro API routines, you must include the file Pro_ext.h, available in the Visual FoxPro API directory. This file includes the prototypes for the functions and structures that allow you to share information with Visual FoxPro.</p>
<p>
If you're writing an ActiveX control, you must also add calls to initialize and clear the API.</p>
<p class=label>
<b>To add Visual FoxPro API routines to your ActiveX object</b>
<ol>
<li>
Use <code>#INCLUDE</code> to include the Pro_ext.h file along with any other required header files.<br><br></li>
<li>
In the Constructor (Init method) of the control, call _OCXAPI(&nbsp;) to initialize the interface to Visual FoxPro using this code:<pre><code>_OCXAPI(AfxGetInstanceHandle(),DLL_PROCESS_ATTACH);
</code></pre>
</li>
<li>
Include calls to the Visual FoxPro API as required in your object.<br><br></li>
<li>
In the Destructor (Destroy method) for the object, call _OCXAPI(&nbsp;) again to release the process created in the Constructor, using this code:<pre><code>_OCXAPI(AfxGetInstanceHandle(),DLL_PROCESS_DETACH);
</code></pre>
</li>
</ol>
<p>
For an example .ocx file that includes calls to the Visual FoxPro API, see <a href="lngvisual_foxpro_foxtlib_control.htm">Foxtlib.ocx</a>. For an example of an .fll library that includes calls to the Visual FoxPro API, see the sample programs in Vfp98\Api\Samples directory that have the extension C: EVENT.C, HELLO.C, and so on.</p>
<p>
If you use Visual FoxPro API calls in your ActiveX control, COM object, or .fll library, the code containing the calls is incompatible with other applications. You might therefore want to build one or more tests into the program to determine whether the object is being called from Visual FoxPro.</p>
<p>
For example, if you're creating an ActiveX control using the Microsoft Foundation Classes, you can change the control’s constructor code to include a test and then alert the user if the control has been called from a program other than Visual FoxPro:</p>
<pre><code>if (!_OCXAPI(AfxGetInstanceHandle(),DLL_PROCESS_ATTACH))
{
 &nbsp; ::MessageBox(0,"This OCX can only be hosted by Visual Foxpro","",0);
 &nbsp;&nbsp;&nbsp;&nbsp; //Here you can do whatever you want when the host isn't VFP:
 &nbsp;&nbsp;&nbsp;&nbsp; // you might want to reject loading or you 
 &nbsp;&nbsp;&nbsp;&nbsp; // might want to set a property
 &nbsp;&nbsp;&nbsp;&nbsp; // saying that the host isn't VFP and the control will use other 
 &nbsp;&nbsp;&nbsp;&nbsp; // means to achieve it's purpose.
}
</code></pre>
<p>
If you're creating an ActiveX control using the Microsoft ActiveX Template Library, use the following code:</p>
<pre><code>if (!_OCXAPI(_Module.GetModuleInstance(),DLL_PROCESS_ATTACH))
{
 &nbsp; ::MessageBox(0,"This OCX can only be hosted by Visual Foxpro","",0);
 &nbsp;&nbsp;&nbsp;&nbsp; //Here you can do whatever you want when the host isn't VFP:
 &nbsp;&nbsp;&nbsp;&nbsp; // you might want to reject loading or you 
 &nbsp;&nbsp;&nbsp;&nbsp; // might want to set a property
 &nbsp;&nbsp;&nbsp;&nbsp; // saying that the host isn't VFP and the control will use other 
 &nbsp;&nbsp;&nbsp;&nbsp; // means to achieve it's purpose.
}
</code></pre>
<p>
In this example, the control doesn't exit, and will continue running after the user has acknowledged the message. The strategy you choose depends on how you anticipate the control will be used. For example, if you detect that the control is being used outside of Visual FoxPro, you can set a flag that you test at each point in the control where you call the Visual FoxPro API. If the flag indicates that the control is outside Visual FoxPro, you can branch around the API call to an alternative means of accomplishing the same task.</p>

<h2><a name="dgpassing_parameters_from_and_to_visual_foxpro"></a>Passing and Receiving Parameters</h2>
<p>
When your program is called from Visual FoxPro, it can receive parameters. For example, an ActiveX control might receive parameters when one of its methods is invoked. Similarly, a Visual FoxPro program might call a function in your FLL library and pass parameters to it.</p>
<p>
Visual FoxPro can pass parameters to your program by value or by reference. By default, parameters respect the setting made with SET UDFPARMS. Other variables (such as arrays or fields) and expressions are passed by value.</p>
<p>
To force a parameter to be passed by reference, precede the variable reference with the @ operator. To force a parameter to be passed by value, enclose it in parentheses.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In Visual FoxPro, individual array elements are always passed by value. When SET UDFPARMS is set to VALUE and no array element is specified, the array name by itself refers to the first element of the array (unless it is prefixed with @).</p>
<p>
Because ActiveX controls and COM objects are Windows-standard programs, no special mechanism is required to pass parameters from Visual FoxPro and your program. You can write the program as if it were receiving parameters from any C or C++ program.</p>
<p>
In contrast, functions in an FLL library use the FoxInfo structure to receive data from Visual FoxPro. The FoxInfo structure lists your library functions and the number and type of parameters they expect. For example, the following <code>FoxInfo</code> structure belongs to a library with one function, internally called <code>dates</code>, that accepts one Character parameter:</p>
<pre><code>FoxInfo myFoxInfo[] = {
 &nbsp; { "DATES", (FPFI) dates, 1, "C" }
};
</code></pre>
<p>
Functions you define in your libraries actually receive only one parameter, a pointer to the parameter block. This parameter block, defined in the <code>ParamBlk</code> structure, holds all the information about the parameters that were passed from the Visual FoxPro function call. Your function declaration follows this format:</p>
<p>
void <i>function_name</i>(ParamBlk *<i>parm</i>)</p>
<p>
For example, the function definition for <code>dates</code> is:</p>
<pre><code>void dates(ParamBlk *parm)
</code></pre>
<p>
The <code>ParamBlk</code> structure consists of an integer that represents the number of parameters, immediately followed by an array of parameter unions. The structure definition is included in Pro_ext.h:</p>
<pre><code>/* A parameter list to a library function.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
typedef struct {
 &nbsp; short int pCount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of parameters passed */
 &nbsp; Parameter p[1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* pCount parameters */
} ParamBlk;
</code></pre>
<p>
The <code>Parameter</code> typedef included in the <code>ParamBlk</code> structure is a union of a Value structure and a Locator structure. Call by value is handled by a Value structure; call by reference is handled by a Locator structure. You use these structures to access the parameters passed to your function when the function is called in Visual FoxPro.</p>
<p>
The following information is extracted from the file Pro_ext.h and shows the definition of the <code>Parameter</code> type:</p>
<pre><code>/* A parameter to a library function.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
typedef union {
 &nbsp; Value val;
 &nbsp; Locator loc;
} Parameter;
</code></pre>
<h4>Value Structure Definition</h4>
<p>
If a parameter is passed to your function by value, use the Value structure to access it. The following <code>Value</code> structure definition is extracted from the Pro_ext.h file:</p>
<pre><code>// An expression’s value.
Typedef struct {
 &nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_type;
 &nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_padding;
 &nbsp; short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_width;
 &nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_length;
 &nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_long;
 &nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_real;
 &nbsp; CCY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_currency;
 &nbsp; MHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_handle;
 &nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ev_object;
} Value;
</code></pre>
<h4>Value Structure Fields</h4>
<p>
The following table is a guide to the values you can pass and receive in the Value structure for different types of data. Only the structure fields listed for a data type are used for that data type.</p>
<p class=label>
<b>Contents of Value structure for different data types</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b>Data type</b></td>
<td class=label width=29%><b>Structure field</b></td>
<td class=label width=54%><b>Value</b></td>
</tr>
<tr valign=top>
<td width=17%>Character</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘C’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_length</code></pre>
</td>
<td width=54%>string length</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_handle</code></pre>
</td>
<td width=54%>MHANDLE to string</td>
</tr>
<tr valign=top>
<td width=17%>Numeric</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘N’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_width</code></pre>
</td>
<td width=54%>Display width</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_length</code></pre>
</td>
<td width=54%>Decimal places</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_real</code></pre>
</td>
<td width=54%>Double precision</td>
</tr>
<tr valign=top>
<td width=17%>Integer</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘I’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_width</code></pre>
</td>
<td width=54%>Display width</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_long</code></pre>
</td>
<td width=54%>Long integer</td>
</tr>
<tr valign=top>
<td width=17%>Date</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘D’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_real</code></pre>
</td>
<td width=54%>Date<sup>1</sup></td>
</tr>
<tr valign=top>
<td width=17%>Date Time</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘T’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_real</code></pre>
</td>
<td width=54%>Date + (seconds/86400.0)</td>
</tr>
<tr valign=top>
<td width=17%>Currency</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘Y’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_width</code></pre>
</td>
<td width=54%>Display width</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_currency</code></pre>
</td>
<td width=54%>Currency value<sup>2</sup></td>
</tr>
<tr valign=top>
<td width=17%>Logical</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘L’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_length</code></pre>
</td>
<td width=54%>0 or 1</td>
</tr>
<tr valign=top>
<td width=17%>Memo</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘M’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_wdith</code></pre>
</td>
<td width=54%>FCHAN</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_long</code></pre>
</td>
<td width=54%>Length of memo field</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_real</code></pre>
</td>
<td width=54%>Offset of memo field</td>
</tr>
<tr valign=top>
<td width=17%>General</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘G’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_wdith</code></pre>
</td>
<td width=54%>FCHAN</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_long</code></pre>
</td>
<td width=54%>Length of general field</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_real</code></pre>
</td>
<td width=54%>Offset of general field</td>
</tr>
<tr valign=top>
<td width=17%>Object</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘O’</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_object</code></pre>
</td>
<td width=54%>Object identifier</td>
</tr>
<tr valign=top>
<td width=17%>Null</td>
<td width=29%><pre><code>ev_type</code></pre>
</td>
<td width=54%>‘0’ (zero)</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=29%><pre><code>ev_long</code></pre>
</td>
<td width=54%>Data type</td>
</tr>
</table><br>
<p class=mini>
1. The date is represented as a double-precision floating-point Julian day number calculated using Algorithm 199 from Collected Algorithms of the ACM.<br>
2. The currency value is a long integer, with an implied decimal point in front of the last four digits.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;<code>ev_length</code> is the only true indicator of a string’s length. The string can’t have a null terminator because the string can contain embedded null characters.</p>
<h4>Locator Structure Definition</h4>
<p>
Use the Locator structure to manipulate parameters passed by reference. The following <code>Locator</code> structure definition is extracted from the Pro_ext.h file: </p>
<pre><code>typedef struct {
  char&nbsp; l_type;
  short l_where, /* Database number or -1 for memory */
  l_NTI,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Variable name table offset*/
  l_offset,&nbsp; /* Index into database*/
  l_subs,&nbsp; /* # subscripts specified 0 &lt;= x &lt;= 2 */
  l_sub1, l_sub2; /* subscript integral values */
} Locator;
</code></pre>
<h4>Locator Structure Fields</h4>
<p>
The following table is a guide to the fields in the Locator structure.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Locator field</b></td>
<td class=label width=79%><b>Field use</b></td>
</tr>
<tr valign=top>
<td width=21%><pre><code>l_type</code></pre>
</td>
<td width=79%><code>'R'</code></td>
</tr>
<tr valign=top>
<td width=21%><pre><code>l_where</code></pre>
</td>
<td width=79%>The number of the table containing this field, or – 1 for a variable.</td>
</tr>
<tr valign=top>
<td width=21%><pre><code>l_NTI</code></pre>
</td>
<td width=79%>Name Table Index. Visual FoxPro internal use.</td>
</tr>
<tr valign=top>
<td width=21%><pre><code>l_offset</code></pre>
</td>
<td width=79%>Field number within table. Visual FoxPro internal use.</td>
</tr>
<tr valign=top>
<td width=21%><pre><code>l_subs</code></pre>
</td>
<td width=79%>For variables only, the number of subscripts (0 – 2).</td>
</tr>
<tr valign=top>
<td width=21%><pre><code>l_sub1</code></pre>
</td>
<td width=79%>For variables only, the first subscript if <code>l_subs</code> is not 0.</td>
</tr>
<tr valign=top>
<td width=21%><pre><code>l_sub2</code></pre>
</td>
<td width=79%>For variables only, the second subscript if <code>l_subs</code> is 2.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;It's good programming practice to check for the parameter type in <code>ev_type</code> to help determine which fields to access from the Value structure.</p>
<h4>An Example of Accessing Parameters in an FLL Library</h4>
<p>
The following example uses <code>_StrCpy( )</code> to return a Character type to Visual FoxPro that's the concatenation of its two Character parameters. Notice that although the handle of each parameter’s Value structure is used as working memory to perform the concatenation, changes to this memory allocation don't affect the Visual FoxPro argument that was passed by value.</p>
<p>
For an example that uses the Locator structure to manage a parameter passed by reference, see <a href="#dgreturning_a_value_from_an_fll_library">Returning a Value from an FLL Library</a> later in this chapter.</p>
<pre><code>#include &lt;Pro_ext.h&gt;

Example(ParamBlk *parm)
{
// make the paramBlk structure easier
// to manage by using #define shortcuts
#define p0 (parm-&gt;p[0].val)
#define p1 (parm-&gt;p[1].val)

// make sure there is enough memory
if (!_SetHandSize(p0.ev_handle, p0.ev_length + p1.ev_length))
 &nbsp; _Error(182); // "Insufficient memory"

// lock the handles
_HLock(p0.ev_handle);
_HLock(p1.ev_handle);

// convert handles to pointers and make sure the 
// strings are null-terminated
((char *)_HandToPtr(p0.ev_handle))[p0.ev_length] = '\0';
((char *)_HandToPtr(p1.ev_handle))[p1.ev_length] = '\0';

// concatenate strings using the API function _StrCpy
_StrCpy((char *)_HandToPtr(p0.ev_handle) + p0.ev_length,
_HandToPtr(p1.ev_handle));

// return the concatenated string to Visual FoxPro
_RetChar(_HandToPtr(p0.ev_handle));

// unlock the handles
_HUnLock(p0.ev_handle);
_HUnLock(p1.ev_handle);
}

FoxInfo myFoxInfo[] = {
 &nbsp; {"STRCAT", Example, 2, "CC"},
};

FoxTable _FoxTable = {
 &nbsp; (FoxTable *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
</code></pre>

<h2><a name="dgreturning_a_value_to_visual_foxpro"></a>Returning a Value to Visual FoxPro</h2>
<p>
The method you use to return a value from your program to Visual FoxPro depends on whether yo u're creating an ActiveX control or an FLL library.</p>
<h4>Returning a Value from an ActiveX Control</h4>
<p>
To return a value from the ActiveX control to Visual FoxPro, use the RETURN statement in the control, passing a single value, as in the following example:</p>
<pre><code>#define VERSION 101

// other code here

long CPyCtrl::GetVersion()
{
 &nbsp; // set the version number here in variable fVersion
 &nbsp; return VERSION;
}
</code></pre>

<h4><a name="dgreturning_a_value_from_an_fll_library"></a>Returning a Value from an FLL Library</h4>
<p>
To return values from an FLL library, use API functions, not native C or C++ commands. The following functions allow you to return values to Visual FoxPro.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Don't use the following API function to return a value from an .ocx file; use the RETURN statement. The API return functions should only be used in FLL libraries.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=51%><b>Function</b></td>
<td class=label width=49%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retcharlp_rp.htm">_RetChar(char *string)</a></td>
<td width=49%>Sets the function return value to a null-terminated string.</td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retcurrencylp_rp.htm">_RetCurrency(CCY cval, int width)</a></td>
<td width=49%>Sets the function return value to a currency value.</td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retdatestrlp_rp.htm">_RetDateStr(char *string)</a></td>
<td width=49%>Sets the function return value to a date. The date is specified in mm/dd/yy[yy] format.</td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retdatetimestrlp_rp.htm">_RetDateTimeStr(char *string)</a></td>
<td width=49%>Sets the function return value to a date and time specified in mm/dd/yy[yy] hh:mm:ss format.</td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retfloatlp_rp.htm">_RetFloat(double flt, int width, int dec)</a></td>
<td width=49%>Sets the function return value to a float value.</td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retintlp_rp.htm">_RetInt(long ival, int width)</a></td>
<td width=49%>Sets the function return value to a numeric value.</td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retlogicallp_rp.htm">_RetLogical(int flag)</a></td>
<td width=49%>Sets the function return value to a logical value. Zero is considered FALSE. Any non-zero value is considered TRUE.</td>
</tr>
<tr valign=top>
<td width=51%><a href="lng_retvallp_rp.htm">_RetVal(Value *val)</a></td>
<td width=49%>Passes a complete Visual FoxPro Value structure; any Visual FoxPro data type except for memo can be returned. You must call _RetVal(&nbsp;) to return a string that contains embedded null characters or to return a .NULL. value.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To return the value of an object data type, use the _RetVal() function, filling in the <code>ev_object</code> field in the Value structure.</p>
<p>
The following example, <code>Sum</code>, accepts a reference to a numeric field in a table and uses <code>_RetFloat</code> to return the sum of the values in the field:</p>
<pre><code>#include &lt;Pro_ext.h&gt;

Sum(ParamBlk *parm)
{
// declare variables
double tot = 0, rec_cnt;
int i = 0, workarea = -1; // -1 is current workarea
Value val;

// GO TOP
_DBRewind(workarea);

// Get RECCOUNT(&nbsp;)
rec_cnt = _DBRecCount(workarea);

// Loop through table
for(i = 0; i &lt; rec_cnt; i++)
{ 
 &nbsp; //Place value of the field into the Value structure
 &nbsp; _Load(&amp;parm-&gt;p[0].loc, &amp;val);

 &nbsp; // add the value to the cumulative total
 &nbsp; tot += val.ev_real;

 &nbsp; // SKIP 1 in the workarea
 &nbsp; _DBSkip(workarea, 1);
} 

// Return the sum value to Visual FoxPro
_RetFloat(tot, 10, 4); 
}
// The Sum function receives one Reference parameter
FoxInfo myFoxInfo[] = {
 &nbsp; {"SUM", Sum, 1,"R"} 
};
FoxTable _FoxTable = {
 &nbsp; (FoxTable *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
</code></pre>
<p>
Assuming there's a numeric field named <code>amount</code> in the currently open table, the following line of code in a Visual FoxPro program calls the function:</p>
<pre><code>? SUM(@amount)
</code></pre>

<h2><a name="dgpassing_parameters_to_visual_foxpro_api_functions"></a>Passing Parameters to Visual FoxPro API Functions</h2>
<p>
Often the Visual FoxPro API routines will require parameters of a particular Visual FoxPro data structure. The following sections provide a list of Visual FoxPro data types and additional data structures. For the actual type definitions and structure definitions, refer to the Pro_ext.h file.</p>
<h3>Visual FoxPro API Data Types</h3>
<p>
The following data types are used in Visual FoxPro API routines.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Data type</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><pre><code>EDLINE</code></pre>
</td>
<td width=75%>The number of a line in an open file in an editing window. The first line is 1.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>EDPOS</code></pre>
</td>
<td width=75%>The offset position of a character in an open file in an editing window. The offset position of the first character in the file or memo field is 0.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>FCHAN</code></pre>
</td>
<td width=75%>File channel. Every file opened by Visual FoxPro, or through the API by using <a href="lng_fcreatelp_rp.htm">_FCreate(&nbsp;)</a> and <a href="lng_fopenlp_rp.htm">_FOpen(&nbsp;)</a>, is assigned an FCHAN.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>FPFI</code></pre>
</td>
<td width=75%>A 32-bit pointer to a function returning an integer.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>ITEMID</code></pre>
</td>
<td width=75%>A unique identifier assigned to a single command on a menu.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>MENUID</code></pre>
</td>
<td width=75%>A unique identifier assigned to a menu.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>MHANDLE</code></pre>
</td>
<td width=75%>A unique identifier given to every block of memory allocated by Visual FoxPro, or allocated through the API using <a href="lng_allochandlp_rp.htm">_AllocHand(&nbsp;)</a>. It can be de-referenced to its pointer using <a href="lng_handtoptrlp_rp.htm">_HandToPtr(&nbsp;)</a>.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>NTI</code></pre>
</td>
<td width=75%>Name table index. Every variable and table field’s name has an entry in this table. </td>
</tr>
<tr valign=top>
<td width=25%><pre><code>WHANDLE</code></pre>
</td>
<td width=75%>Window handle. A unique identifier assigned to every window opened by Visual FoxPro, or opened through the API using <a href="lng_wopenlp_rp.htm">_WOpen( )</a>.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Because FAR pointers are not appropriate for 32-bit compilers, <code>#define</code> statements in Pro_ext.h redefine <code>FAR</code>, <code>_far</code>, and <code>__far</code> as null values.</p>
<h3>Visual FoxPro API Data Structures</h3>
<p>
The primary data structures used in the Visual FoxPro API library are listed in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Structure</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><pre><code>EventRec</code></pre>
</td>
<td width=75%>A structure used to describe what the system is doing at a given time.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>FoxInfo</code></pre>
</td>
<td width=75%>Used in FLL libraries for communicating between Visual FoxPro and your program; not used in .ocx files. Discussed under <a href="#dgusing_foxinfo_and_foxtable_structures">Using FoxInfo and FoxTable Structures</a> earlier in this chapter.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>FoxTable</code></pre>
</td>
<td width=75%>Used in FLL libraries for communicating between Visual FoxPro and your program; not used in .ocx files. Discussed under <a href="#dgusing_foxinfo_and_foxtable_structures">Using FoxInfo and FoxTable Structures</a> earlier in this chapter.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>Locator</code></pre>
</td>
<td width=75%>A structure used to access parameter values (FLL) or Visual FoxPro variables or fields (FLL and ocx).</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>ParamBlk</code></pre>
</td>
<td width=75%>Used in FLL libraries for communicating between Visual FoxPro and your program; not used in .ocx files. Discussed under <a href="#dgusing_foxinfo_and_foxtable_structures">Using FoxInfo and FoxTable Structures</a> earlier in this chapter.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>Parameter</code></pre>
</td>
<td width=75%>Used in FLL libraries for communicating between Visual FoxPro and your program; not used in .ocx files. Discussed under <a href="#dgusing_foxinfo_and_foxtable_structures">Using FoxInfo and FoxTable Structures</a> earlier in this chapter.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>Point</code></pre>
</td>
<td width=75%>A structure that defines the horizontal and vertical coordinates of a single point on the screen. Coordinates are specified in rows and columns.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>Rect</code></pre>
</td>
<td width=75%>A structure that defines the coordinates of a rectangle on the screen. The upper-left corner of the rectangle is defined by <code>(</code><i>top</i><code>,</code><i>left</i><code>)</code> and the lower-right corner is defined by <code>(</code><i>bottom</i><code>-1,</code><i>right</i><code>-1)</code>. Coordinates are specified in rows and columns.</td>
</tr>
<tr valign=top>
<td width=25%><pre><code>Value</code></pre>
</td>
<td width=75%>A structure used to access parameter values (FLL) or Visual FoxPro variables or fields (FLL and OCX).</td>
</tr>
</table><br>

<h2><a name="dgaccessing_visual_foxpro_variables_and_fields"></a>Accessing Visual FoxPro Variables and Fields</h2>
<p>
You can access Visual FoxPro variables or field values in your ActiveX control or FLL function, either to read them or to set them. In addition, you can create new variables that can be accessed from within Visual FoxPro.</p>
<p>
Variables and fields are made available in Visual FoxPro in a name table, which is an array containing the names of all currently-defined variables and fields. You can access an individual element in the array using a name table index (NTI). A special API function, <a href="lng_nametableindexlp_rp.htm">_NameTableIndex(&nbsp;)</a>, returns the index of an existing variable or field based on a name that you provide. After you've determined the NTI for a given variable, you can read it using the <a href="lng_loadlp_rp.htm">_Load(&nbsp;)</a> API function or set it using the <a href="lng_storelp_rp.htm">_Store(&nbsp;)</a> API function. To create a new variable, you can call the API function <a href="lng_newvarlp_rp.htm">_NewVar(&nbsp;)</a>.</p>
<p>
To access Visual FoxPro variables or fields, you use the Value and Locator structures defined in Pro_ext.h. If you're creating an FLL library, you can use the same technique you used to access parameters passed to your functions. For details about the Value and Locator structures, see <a href="#dgpassing_parameters_from_and_to_visual_foxpro">Passing and Receiving Parameters</a> earlier in this chapter.</p>
<p>
The following example, drawn from the Foxtlibctl.cpp program in the Vfp98\Api\Samples\Foxtlib directory, illustrates how you can use the Value and Locator structures in an ActiveX control to access Visual FoxPro variables:</p>
<pre><code>long CFoxtlibCtrl::TLGetTypeAttr(long pTypeInfo, LPCTSTR szArrName)
{
  int nResult = 1;
  TYPEATTR *lpTypeAttr;
  Locator loc;
  Value val;
  OLECHAR szGuid[128];
  char *szBuff;
__try {
 &nbsp; if (_FindVar(_NameTableIndex(( char *)szArrName),-1,&amp;loc)) {
 &nbsp;&nbsp;&nbsp;&nbsp; ((ITypeInfo *)pTypeInfo)-&gt;GetTypeAttr(&amp;lpTypeAttr);
 &nbsp;&nbsp;&nbsp;&nbsp; if (_ALen(loc.l_NTI, AL_ELEMENTS) &lt; 16) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Error(631); //Array argument not of proper size.
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; //1 = Guid
 &nbsp;&nbsp;&nbsp;&nbsp; StringFromGUID2(lpTypeAttr-&gt;guid, (LPOLESTR )&amp;szGuid,sizeof(szGuid));
 &nbsp;&nbsp;&nbsp;&nbsp; OLEOleToAnsiString(szGuid,&amp;szBuff);
 &nbsp;&nbsp;&nbsp;&nbsp; val.ev_type = 'C';
 &nbsp;&nbsp;&nbsp;&nbsp; val.ev_length = strlen(szBuff);
 &nbsp;&nbsp;&nbsp;&nbsp; val.ev_handle = _AllocHand(val.ev_length);
 &nbsp;&nbsp;&nbsp;&nbsp; _HLock(val.ev_handle);
 &nbsp;&nbsp;&nbsp;&nbsp; _MemMove((char *) _HandToPtr( val.ev_handle ), szBuff, val.ev_length);
 &nbsp;&nbsp;&nbsp;&nbsp; OLEFreeString((void **)&amp;szBuff);
 &nbsp;&nbsp;&nbsp;&nbsp; _HUnLock(val.ev_handle);
 &nbsp;&nbsp;&nbsp;&nbsp; loc.l_sub1 = 1;
 &nbsp;&nbsp;&nbsp;&nbsp; _Store(&amp;loc,&amp;val);
 &nbsp;&nbsp;&nbsp;&nbsp; _FreeHand(val.ev_handle);

 &nbsp;&nbsp;&nbsp;&nbsp; //2 = LCID
 &nbsp;&nbsp;&nbsp;&nbsp; loc.l_sub1 = 2;
 &nbsp;&nbsp;&nbsp;&nbsp; val.ev_type = 'I';
 &nbsp;&nbsp;&nbsp;&nbsp; val.ev_long = lpTypeAttr-&gt;lcid;
 &nbsp;&nbsp;&nbsp;&nbsp; _Store(&amp;loc,&amp;val);

 &nbsp;&nbsp;&nbsp;&nbsp; // code for values 3 - 16 here
 &nbsp;&nbsp;&nbsp;&nbsp; ((ITypeInfo *)pTypeInfo) -&gt; ReleaseTypeAttr(lpTypeAttr);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; } __except&nbsp; (EXCEPTION_EXECUTE_HANDLER) {
 &nbsp;&nbsp;&nbsp;&nbsp; nResult = 0;
 &nbsp; }
return nResult;
</code></pre>

<h2><a name="dgmanaging_memory"></a>Managing Memory</h2>
<p>
The Visual FoxPro API provides direct access to the Visual FoxPro dynamic memory manager. For API routines that request memory allocations, a memory identifier – or handle, is returned. The Visual FoxPro segment-loading architecture uses handles instead of pointers so it can manage memory more efficiently.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The techniques described in this section for managing memory using the Visual FoxPro API apply to both ActiveX controls and FLL libraries.</p>
<h3>Using Handles</h3>
<p>
A <i>handle</i> refers to a memory handle, which is essentially an index into an array of pointers. The pointers point to blocks of memory that Visual FoxPro knows about. Nearly all references to memory in the API are made through handles instead of the more traditional C pointers.</p>
<p class=label>
<b>To allocate and use memory in your library</b>
<ol>
<li>
Allocate a handle with <a href="lng_allochandlp_rp.htm">_AllocHand(&nbsp;)</a>.<br><br></li>
<li>
Lock the handle with <a href="lng_hlocklp_rp.htm">_HLock(&nbsp;)</a>.<br><br></li>
<li>
Convert the handle into a pointer with <a href="lng_handtoptrlp_rp.htm">_HandToPtr(&nbsp;)</a>.<br><br></li>
<li>
Reference the memory by using the pointer.<br><br></li>
<li>
Unlock the handle with <a href="lng_hunlocklp_rp.htm">_HUnLock(&nbsp;)</a>.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To avoid memo file corruption, don't write to a memo file before calling <a href="lng_allocmemolp_rp.htm">_AllocMemo(&nbsp;)</a>.</p></li>
</ol>
<p>
In order to address the allocated memory, your API routines must convert the handle to a pointer by calling the <a href="lng_handtoptrlp_rp.htm">_HandToPtr(&nbsp;)</a> routine. Even if the Visual FoxPro memory manager needs to reorganize memory to obtain more contiguous memory for subsequent memory requests, the handle remains the same. Routines that grow, shrink, free, and lock memory allocations are also provided.</p>
<p>
When you're creating external routines, try to minimize memory use. If you create an external routine that dynamically allocates memory, try to use the least amount of memory possible. Be especially careful about locking large memory allocations for long periods of time. Remember to unlock memory handles with <a href="lng_hunlocklp_rp.htm">_HUnLock(&nbsp;)</a> when they no longer need to be locked, because the performance of Visual FoxPro can be adversely affected by locked memory handles.</p>
<p class=indent>
<B><b>Caution</b></B>&nbsp;&nbsp;&nbsp;Excessive use of dynamic memory deprives Visual FoxPro of memory for buffers, windows, menus, and so on, and degrades performance, because the memory given to fill API requests is managed by the Visual FoxPro memory manager. Allocating large handles and retaining them could cause Visual FoxPro to run out of memory and terminate abnormally.</p>
<p class=indent>
The Visual FoxPro environment has no memory protection. The external API routine cannot provide all the validation that's inherent in a standard Visual FoxPro program. If you corrupt memory, you receive messages such as “Transgressed handle,” “Internal consistency error,” and “Transgressed node during compaction.”</p>
<p>
The following function from an FLL library illustrates memory allocation. The example uses <a href="lng_retdatestrlp_rp.htm">_RetDateStr(&nbsp;)</a> to return a Visual FoxPro Date type (assuming that the Character parameter is a proper date):</p>
<pre><code>#include &lt;Pro_ext.h&gt;

void dates(ParamBlk&nbsp; *parm)
{
 &nbsp; MHANDLE mh;
 &nbsp; char *instring;

 &nbsp; if ((mh = _AllocHand(parm-&gt;p[0].val.ev_length + 1)) == 0) {
 &nbsp;&nbsp;&nbsp;&nbsp; _Error(182); // "Insufficient memory"
 &nbsp; }
 &nbsp; _HLock(parm-&gt;p[0].val.ev_handle);
 &nbsp; instring = _HandToPtr(parm-&gt;p[0].val.ev_handle);
 &nbsp; instring[parm-&gt;p[0].val.ev_length] = '\0';
 &nbsp; _RetDateStr(instring);
 &nbsp; _HUnLock(parm-&gt;p[0].val.ev_handle);
}
FoxInfo myFoxInfo[] = {
 &nbsp; {"DATES", (FPFI) dates, 1, "C"}
};
FoxTable _FoxTable = {
 &nbsp; (FoxTable *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
</code></pre>
<h3>Understanding Stacks</h3>
<p>
The control or library you create doesn't have a stack of its own. Instead, it uses the stack of its calling program, in this case the Visual FoxPro stack. You cannot control the size of the Visual FoxPro stack or affect the amount of stack space available to an ActiveX control or .fll file.</p>
<p>
Under normal circumstances, this distinction isn't important. The Visual FoxPro stack is generally large enough to hold the automatic variables you might need to allocate in a control or library. If you run out of stack space, you can always allocate additional memory on the heap dynamically.</p>
<h3>Following Handle Rules</h3>
<p>
The following rules apply to ownership of handles and the responsibility for freeing them:</p>
<ul type=disc>
<li>
Users must free all handles they allocate, including handles allocated by functions such as <a href="lng_loadlp_rp.htm">_Load()</a>.</li>
<li>
<a href="lng_loadlp_rp.htm">_Load()</a> only creates a handle when the variable you're loading is a character string (that is, <code>ev_type = 'C'</code>). All the other data types store their values in the Value structure itself, while loading a character string puts an MHANDLE in the <code>ev_handle</code> of the Value structure.</li>
<li>
In an FLL library, Visual FoxPro assumes responsibility for freeing all handles returned with <a href="lng_retvallp_rp.htm">_RetVal(&nbsp;)</a>. Users must not free these handles, even if they allocate them.</li>
<li>
Users must not free handles passed to them in their <code>ParamBlk</code>.<p class=atl>
<B><b>Caution</b></B>&nbsp;&nbsp;&nbsp;When you write an external routine that calls functions, be careful to follow all rules and check the return results. A stray pointer or handle reference could damage the Visual FoxPro internal data structures, causing an immediate abnormal termination or delayed problems, which could result in data loss.</p></li>
</ul>

<h2><a name="dgbuilding_and_debugging_libraries_and_activex_controls"></a>Building and Debugging Libraries and ActiveX Controls</h2>
<p>
After creating a project, you're ready to build and debug it.</p>
<h3>Building the Project</h3>
<p>
Before building, you need to establish the project settings. Some of the settings you make depend on whether you want to create a debug or release version of the control or library. As a rule, you create debug versions of the program until you're satisfied that it's working correctly, and then you create a release version.</p>
<p class=label>
<b>To specify a debug or release version</b>
<ol>
<li>
From the <b>Build</b> menu, choose <b>Set Default Configuration.</b><br><br></li>
<li>
Choose whether you're creating a debug or release version of the control.<br><br></li>
<li>
Choose <b>OK</b>.</li>
</ol>
<p class=label>
<b>To establish project settings</b>
<ol>
<li>
From the <b>Build</b> menu, choose <b>Settings</b>.<br><br></li>
<li>
Under <b>Settings For</b>, choose whether you're creating a debug or release version of the program.<br><br></li>
<li>
Click the <b>C/C++</b> tab and then make these settings:<ul type=disc>
<li>
In the <b>Category</b> list, choose <b>Code Generation</b>.<br><br></li>
<li>
In the <b>Calling Convention</b> list, choose <b>_fastcall</b>.<br><br></li>
<li>
In the <b>Use run-time library</b> list, choose <b>Multithreaded DLL</b>.</li>
</ul>
</li>
<li>
Choose the <b>Link</b> tab and then in the <b>Object/Library Modules</b> text box, add one of the following libraries:<ul type=disc>
<li>
If you're building an .ocx, add <code>OCXAPI.LIB</code> from the Visual FoxPro API directory.<br><br></li>
<li>
If you're building an .fll, add <code>WINAPIMS.LIB</code> from the Visual FoxPro API directory.</li>
</ul>
</li>
<li>
Unmark <b>Ignore all default libraries</b>.<br><br></li>
<li>
Choose <b>OK</b>.</li>
</ol>
<p class=label>
<b>To make sure the compiler can find the necessary files</b>
<ol>
<li>
From the <b>Tools</b> menu, choose <b>Options</b>.<br><br></li>
<li>
Click the <b>Directories</b> tab.<br><br></li>
<li>
In the <b>Show directories for</b> list, choose <b>Include files</b>.<br><br></li>
<li>
In the <b>Directories</b> toolbar, click the <b>Add</b> button.<br><br></li>
<li>
Add the directory with Pro_ext.h.<br><br></li>
<li>
In the <b>Show directories for</b> list, choose <b>Library files</b>.<br><br></li>
<li>
In the <b>Directories</b> toolbar, click the <b>Add</b> button.<br><br></li>
<li>
Add the directory with Ocxapi.lib from the Visual FoxPro API directory (when creating a control) or add the Winapims.lib from the Visual FoxPro API directory (when creating an FLL)<br><br></li>
<li>
In the <b>Options</b> dialog box, choose <b>OK</b>.</li>
</ol>
<p>
After you’ve specified the settings, you can compile and link your program.</p>
<p class=label>
<b>To compile and link an .ocx file</b>
<ul type=disc>
<li>
From the <b>Build </b>menu, choose <b>Build</b> <i>projname</i><b>.ocx</b>.</li>
</ul>
<p>
When you compile and link the .ocx file, Visual C++ automatically registers the control on the computer on which it was built. If for any reason you must register the control manually, you can do so using the following procedure.</p>
<p class=label>
<b>To register the ActiveX control</b>
<ul type=disc>
<li>
From the <b>Tools</b> menu in the Visual C++ Developer Studio, choose <b>Register Control</b>.<p class=tl>
-or-</P></li>
<li>
Declare and call DLLRegisterServer(&nbsp;) from your program.</li>
</ul>
<h3>Debugging an ActiveX Control or FLL Library</h3>
<p>
Debugging the control or library in the context of a full Visual FoxPro application is more difficult than debugging it separately from the application. It's a good idea to create a simple test program to test the operation of your control or library.</p>
<h4>Debugging with Microsoft Visual C++</h4>
<p>
Microsoft Visual C++ version 4.0 and higher offers an integrated debugging environment that makes it easy to set break points and to step through your code. You can even run Visual FoxPro from Visual C++.</p>
<p class=label>
<b>To start debugging with Microsoft Visual C++</b>
<ol>
<li>
From the <b>Build</b> menu, choose <b>Settings</b>.<br><br></li>
<li>
In the <b>Project Settings</b> dialog box, click the <b>Debug</b> tab.<br><br></li>
<li>
In the <b>Executable for debug session</b> text box, type the path followed by Vfp6.exe.<p class=tl>
For example, type:<br>
<b>C:\Program Files\Microsoft Visual Studio\Vfp98\Vfp6.exe</b>.</P></li>
<li>
Choose <b>OK</b>.<br><br></li>
<li>
Set a break point in your library.<br><br></li>
<li>
From the <b>Build</b> menu, choose <b>Debug</b>. Then, from the submenu choose <b>Go</b>.<br><br></li>
<li>
When Developer Studio displays a message that says “Vfp6.exe doesn't contain debugging information,” choose <b>Yes</b> to continue.</li>
</ol>
<p>
For more information about debugging in Visual C++, see the Visual C++ documentation set.</p>
<h4>Debugging with Other Debuggers</h4>
<p>
You should be able to debug a control or library with any debugger that correctly handles an INT 3 (<a href="lng_breakpointlp_rp.htm">_BreakPoint( )</a>) embedded in your program. You can use any debugger for symbolic debugging as long as it can do all of the following:</p>
<ul type=disc>
<li>
Make a symbol table from a map file.</li>
<li>
Load the symbol table independent of the program.</li>
<li>
Relocate the symbols to a new address.</li>
</ul>
<p class=label>
<b>To debug a library</b>
<ol>
<li>
Add a <a href="lng_breakpointlp_rp.htm">_BreakPoint(&nbsp;)</a> call to the routine at the point where debugging will begin.<br><br></li>
<li>
Build the control or library.<br><br></li>
<li>
Invoke your debugger.<br><br></li>
<li>
If your debugger supports symbols, load the symbol table for your library.<br><br></li>
<li>
Start Visual FoxPro.<br><br></li>
<li>
Call your library routine from Visual FoxPro.<br><br></li>
<li>
When the breakpoint is reached, make adjustments to the symbol base to align your symbols with the actual location where the library was loaded.<br><br></li>
<li>
Increment the instruction pointer (IP) register by 1 to skip over the INT 3 instruction.<br><br></li>
<li>
Continue debugging as with a normal program.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Always remove any breakpoints specified in your debugger before you release your product.</p></li>
</ol>
</BODY>
</HTML>
