<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Upsizing Visual FoxPro Databases</title>
<style>
<link disabled rel=stylesheet href=/stylesheets/msdn_ie3.css>
<style type="text/css">
@import url(/stylesheets/msdn_ie4.css);
</style></HEAD>
<BODY>

<h1><a name="dgupsizing_visual_foxpro_databases"></a><sup></sup>Chapter 20: Upsizing Visual FoxPro Databases</h1>
<p>
Once you’ve designed your client/server application, you’re ready to build and upsize a local prototype. A local prototype is a working model of your application using Visual FoxPro tables, views, and databases to represent data that will eventually be accessed on a remote server. Use the upsizing wizards to move databases, tables, and views from your system to a remote SQL Server or Oracle server.</p>
<p>
This chapter discusses:</p>
<ul type=disc>
<li>
<a href="#dggoals_for_prototyping">Goals for Prototyping</a></li>
<li>
<a href="#dgbuilding_a_local_prototype_of_an_application">Building a Local Prototype of an Application</a></li>
<li>
<a href="#dgusing_the_upsizing_wizards">Using the Upsizing Wizards</a></li>
<li>
<a href="#dgupsizing_to_sql_server">Upsizing to SQL Server</a></li>
<li>
<a href="#dgupsizing_to_oracle">Upsizing to Oracle</a></li>
</ul>

<h2><a name="dggoals_for_prototyping"></a>Goals for Prototyping</h2>
<p>
When you use Visual FoxPro to build a prototype of your application, you’re leveraging the power of visual forms, wizards, builders, designers, and the Project Manager to quickly develop a working application. While your ultimate goal is to implement your application across client/server platforms, you gain a great deal by choosing to build a solid prototype.</p>
<h3>Reducing Development Time</h3>
<p>
By building a quick prototype, you can refine your application’s design and local architecture quickly and easily, without having to access the remote server to rebuild server tables and databases. You can also test and debug your application’s forms against smaller data stores, allowing you to more quickly correct and enhance your application’s user interface. Because you’re keeping architectural overhead low, you prevent wasting development time in rebuilding, reindexing, and reconnecting remote data just to test your prototype.</p>
<h3>Decreasing Development Costs While Increasing Customer Satisfaction</h3>
<p>
Because the local prototype is self-contained on your computer, you can easily demonstrate a working model of your application to the end user early in the development cycle. Being able to see your application as it progresses gives clients confidence in your ability to deliver a solution that meets their needs. It also provides you with the opportunity to get customer feedback about the user interface and reports before you’ve invested resources in implementing it against a remote server.</p>
<p>
As users see and interact with your prototype, they can begin to identify areas they’d like to change, as well as see the potential for adding additional functionality into their application. You can implement changes and redemonstrate the application in an iterative process until both you and the customer are satisfied with the design and function of the prototyped application. Your prototype then serves as a working specification for the final, implemented client/server application.</p>
<h3>Contributing to Successful Implementation</h3>
<p>
You can also potentially provide the prototyped application as a demonstration for your users, allowing them to experiment with the working model as you move forward in the implementation process of the actual application. As they gain experience with the prototype, their learning curve decreases and they become better partners with you in refining and fine-tuning the application. They're also positioned to be more productive and satisfied in the final implementation stage because they already understand the basic framework of the application.</p>
<p>
Having a working model increases the lead time the end user has to become familiar and comfortable with the application. It also provides a framework to allow staff at your company or the customer site to design and develop a training plan for the application. The prototype can even be used to train end users before the final application is delivered, thus contributing to a successful implementation of the final, implemented client/server application.</p>

<h2><a name="dgbuilding_a_local_prototype_of_an_application"></a>Building a Local Prototype of an Application</h2>
<p>
When you build a local prototype of your application, you might be starting from scratch, or you might be converting an existing Visual FoxPro application to a client/server application. The primary difference between building a local prototype of a client/server application and developing any other Visual FoxPro application is in using local views and tables to represent data that will eventually be upsized.</p>
<p class=label>
<b>To build and upsize a local prototype</b>
<ol>
<li>
Create your application using local views and local tables to represent data you want to move to a remote server.<br><br></li>
<li>
Use local views in your application’s data environment for forms and reports.<br><br></li>
<li>
Upsize local views and tables using the <a href="wizsql_server_upsizing_wizard.htm">SQL Server Upsizing Wizard</a> or <a href="wizoracle_upsizing_wizard.htm">Oracle Upsizing Wizard</a>:<ul type=disc>
<li>
In the <b>Set Upsizing Options</b> step, in the <b>Changes to make locally</b> area, select <b>Redirect views to remote data</b>.</li>
</ul>
<p class=tl>
When you select this option, the upsizing wizard copies the local tables you select to the remote server, and redirects local views to use remote data where applicable.</P></li>
</ol>
<p>
For more information on creating views, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>. For information on creating forms and using a data environment, see Chapter 9, <a href="dgcreating_forms.htm">Creating Forms</a>. For information on developing an application, see Chapter 2, <a href="dgdeveloping_an_application.htm">Developing an Application</a>.</p>

<h2><a name="dgusing_the_upsizing_wizards"></a>Using the Upsizing Wizards</h2>
<p>
Visual FoxPro provides two upsizing wizards: the <a href="wizsql_server_upsizing_wizard.htm">SQL Server Upsizing Wizard</a>, and the <a href="wizoracle_upsizing_wizard.htm">Oracle Upsizing Wizard</a>. These wizards create SQL Server or Oracle databases that duplicate, as much as possible, the functionality of a set of tables in a Visual FoxPro database. You can also choose to redirect Visual FoxPro views so that they use the newly created remote data instead of local data. You can use the upsizing wizards to:</p>
<ul type=disc>
<li>
Move local data to a remote server.</li>
<li>
Transform local base tables and local views into remote base tables and remote views.</li>
<li>
Migrate a local application to a client/server application.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Though the upsizing wizards access SQL Server or Oracle servers, you can create a client/server application for any remote ODBC data source. For servers other than SQL Server or Oracle, you can use SQL pass-through functions to create remote tables, then use Visual FoxPro to create remote views that access server tables. For more information on using SQL pass-through functions, see Chapter 21, <a href="dgimplementing_a_client_server_application.htm">Implementing a Client/Server Application</a>. For information on creating remote views, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p></li>
</ul>

<h2><a name="dgupsizing_to_sql_server"></a>Upsizing to SQL Server</h2>
<p>
Before you run the SQL Server Upsizing Wizard, you must prepare both the client and server sides.</p>
<h3>Preparing the SQL Server Side</h3>
<p>
Before upsizing, you must ensure that you have necessary permissions on the server, estimate the size of your database, and check that the server has sufficient disk space. There are also special preparations for upsizing to multiple disks or devices.</p>
<h4>Checking Free Disk Space</h4>
<p>
Make sure you have enough disk space on the server.</p>
<p class=indent>
<B><b>Caution</b></B>&nbsp;&nbsp;&nbsp;If the SQL Server Upsizing Wizard runs out of disk space on the server, it halts, leaving a partial database and any devices it created on the server. You can remove devices, databases, and tables with the SQL Server Administration tool.</p>
<h4>Setting Permissions on SQL Server Databases</h4>
<p>
In order to run the SQL Server Upsizing Wizard, you must have certain permissions on the SQL server to which you will be upsizing. The permissions you need depend on the tasks you want to accomplish.</p>
<ul type=disc>
<li>
To upsize to an existing database, you need CREATE TABLE and CREATE DEFAULT permissions.</li>
<li>
To build a new database, you need CREATE DATABASE and SELECT permissions on the system tables in the master database.</li>
<li>
To create new devices, you must be a system administrator.</li>
</ul>
<p>
For more information on granting server permissions, see your SQL Server documentation.</p>
<h4>Estimating SQL Server Database and Device Size</h4>
<p>
When you create a new database, the SQL Server Upsizing Wizard asks you to select devices for your database and log. It also asks you to set the size of the database and your devices.</p>
<h4>Estimating SQL Server Database Size</h4>
<p>
When SQL Server creates a database, it sets aside a fixed amount of space for that database on one or more devices. Not all this space is necessarily used by the database — the database size simply limits how large a database can grow before it runs out of space.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can increase the size of a SQL Server database after it’s created. For more information, see the ALTER DATABASE command in your SQL Server documentation.</p>
<p>
To estimate the space needed for your database, calculate the total size of your Visual FoxPro .dbf files for the tables you want to upsize plus the rate at which your new SQL Server database will grow. In general, every megabyte of Visual FoxPro data requires at least 1.3 to 1.5 MB in the SQL Server.</p>
<p>
If you have ample disk space on your server, multiply the size of your Visual FoxPro tables by two. This ensures that the SQL Server Upsizing Wizard has enough space to upsize your database and also leaves some room to grow. If you expect to add a lot of data to the database, increase the multiple.</p>
<h4>Estimating SQL Server Device Sizes</h4>
<p>
All SQL Server databases and logs are placed on devices. A device is both a logical location at which to put databases and logs, and a physical file. When a device is created, SQL Server creates a file, thus reserving a set amount of disk space for its own use.</p>
<p>
The SQL Server Upsizing Wizard displays the amount of free space available on the existing SQL Server devices. Select a device that has at least enough free space for your estimated database size.</p>
<p>
If no existing devices have enough free space, you can use the SQL Server Upsizing Wizard to create a new device. New devices should be at least as big as your estimated database size. If possible, make the device larger than your database size, so you can expand your database later, or place other databases or logs on the same device.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Device size cannot be changed. Make sure you create sufficiently large devices.</p>
<h4>Using Multiple SQL Server Disks or Devices</h4>
<p>
In most cases, the SQL Server Upsizing Wizard provides more than enough control over SQL Server devices. However, if your server has multiple disks or if you want to place a database or log on multiple devices, you might want to create devices before running the SQL Server Upsizing Wizard.</p>
<h4>Servers with Multiple Physical Disks</h4>
<p>
If your server has more than one physical hard disk, you might want to place your database on one disk and the database log on a different disk. In the event of a disk failure, you’ll be more likely to recover your database if the log and the database are stored on different physical disks.</p>
<p>
The SQL Server Upsizing Wizard allows you to create new devices but only on one physical disk — the same disk as the Master database device.</p>
<p>
To place a database and log on separate disks, make sure you have devices that are big enough on both disks, creating new devices if necessary. Then run the SQL Server Upsizing Wizard.</p>
<h4>Placing Databases or Logs on Multiple Devices</h4>
<p>
SQL Server allows databases and logs to span several devices. However, the SQL Server Upsizing Wizard allows you to specify only one device for your database and one device for the log.</p>
<p>
If you want to specify multiple devices for a database or log, make those devices (and no other devices) the default devices. Then run the SQL Server Upsizing Wizard and choose Default for the database or log device.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If the new SQL Server database or log sizes don’t require using all the default devices, SQL Server uses only the devices necessary to accommodate the database or log.</p>
<h3>Preparing the Client</h3>
<p>
Before upsizing, you must have access to a SQL Server through an ODBC data source or named connection. You must also have a Visual FoxPro database, which you should back up before running the SQL Server Upsizing Wizard.</p>
<h4>Creating an ODBC Data Source or Named Connection</h4>
<p>
When you create a new remote database, you select an ODBC data source or named connection in your Visual FoxPro database that accesses the SQL Server to which you want to upsize. Because you can’t proceed through the Upsizing Wizard until you select a named connection or data source, you should create the appropriate named connection or data source before you start the upsizing process.</p>
<p>
For information on creating a named connection, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>. If you want to create an ODBC data source, run the ODBC Administrator. For information on setting up ODBC data sources, see Chapter 1, <a href="iginstalling_visual_foxpro.htm">Installing Visual FoxPro</a>, in the <i>Installation Guide</i>.</p>
<h3>Backing Up Your Database</h3>
<p>
It's a good idea to create a backup copy of your database (.dbc, .dct, and .dcx files) before upsizing. While the SQL Server Upsizing Wizard doesn't modify .dbf files, it does operate on the .dbc directly by opening the .dbc as a table at times and indirectly by renaming tables and views when creating new remote views. If you back up your database, you can revert your database to its original pre-upsizing state by overwriting the upsized .dbc, .dct, and .dcx files with the original backup copies, which reverses the renaming and creation of new views.</p>
<h3>Closing Tables</h3>
<p>
The SQL Server Upsizing Wizard attempts to exclusively open all the tables in the database to be upsized; if any tables are already open and shared, the wizard closes them and reopens them exclusively. Opening tables exclusively before upsizing protects against other users attempting to modify records in the tables you're exporting during data export. If any tables can’t be opened exclusively, the SQL Server Upsizing Wizard displays a message; those tables are not available for upsizing.</p>
<h3>Starting the SQL Server Upsizing Wizard</h3>
<p>
After you create an ODBC data source and complete the necessary preparations on the client and server, you're ready to begin upsizing.</p>
<p class=label>
<b>To start the SQL Server Upsizing Wizard</b>
<ol>
<li>
From the <b>Tools</b> menu, choose <b>Wizards</b>, and then choose <b>Upsizing</b>.<br><br></li>
<li>
From the <b>Wizard Selection</b> dialog box, choose <b>SQL Server Upsizing Wizard</b>.<br><br></li>
<li>
Follow the directions in the wizard screens, as described in the following sections.<p class=tl>
You can choose <b>Cancel</b> at any time to exit the wizard; the wizard performs no actions on the server until you choose <b>Finish</b>.</P></li>
<li>
When you're ready to upsize, choose <b>Finish</b>.</li>
</ol>
<p>
After you choose Finish, the SQL Server Upsizing Wizard begins exporting the database to the server.</p>
<p>
The Finish button is available after you provide the basic information needed for upsizing. If you choose Finish before you complete all the wizard screens, the SQL Server Upsizing Wizard uses default values for the remaining screens.</p>
<h3>How the SQL Server Upsizing Wizard Works</h3>
<p>
The SQL Server Upsizing Wizard makes upsizing a Visual FoxPro database to SQL Server practically transparent. This section explains exactly what happens after you choose Finish — how the SQL Server Upsizing Wizard exports data and maps Visual FoxPro objects to SQL Server objects.</p>
<h4>Data Export Methods</h4>
<p>
The SQL Server Upsizing Wizard exports data using one of two methods. The first method creates a stored procedure that performs multiple row inserts. This method can be very fast, because stored procedures are precompiled and execute quickly.</p>
<p>
However, stored procedures can’t accept variable length binary variables as parameters. If you're exporting data that's to be stored in SQL Server tables using text or image data types, or tables with more than 250 fields, the SQL Server Upsizing Wizard uses a different exporting method. This second method creates a SQL INSERT statement for each row in the table and then executes the statement.</p>
<p>
If the SQL Server Upsizing Wizard encounters errors while exporting data using the SQL INSERT method, and the number of errors exceeds 10 percent of the number of records in the table or 100 records (whichever is larger), the wizard cancels the export for that table and saves the number of export errors for the error report. The exported server table is not dropped, however, and any records that were successfully exported are left in the server table.</p>
<h4>Overview of Object Mapping</h4>
<p>
To upsize a Visual FoxPro database to a server, the SQL Server Upsizing Wizard creates server objects that, as far as possible, do everything the Visual FoxPro database did. Mapping some Visual FoxPro objects to server objects is very straightforward: Visual FoxPro databases, tables, fields, defaults, and indexes map to SQL Server databases, tables, fields, defaults, and indexes in a direct, one-to-one mapping.</p>
<p>
However, not all local objects map directly to server objects. Validation rules and referential integrity in Visual FoxPro are part of the data dictionary and are enforced at the engine level. SQL Server validation rules and referential integrity aren't part of the data dictionary, and are enforced through code bound to a table. These differences, as well as design decisions made by the SQL Server Upsizing Wizard, mean that much of the Visual FoxPro data dictionary cannot be mapped directly to SQL Server constructs.</p>
<p>
The following table summarizes how objects are mapped from Visual FoxPro to SQL Server:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Visual FoxPro objects</b></td>
<td class=label width=56%><b>SQL Server objects</b></td>
</tr>
<tr valign=top>
<td width=44%>Database</td>
<td width=56%>Database</td>
</tr>
<tr valign=top>
<td width=44%>Table</td>
<td width=56%>Table</td>
</tr>
<tr valign=top>
<td width=44%>Indexes</td>
<td width=56%>Indexes</td>
</tr>
<tr valign=top>
<td width=44%>Field</td>
<td width=56%>Field</td>
</tr>
<tr valign=top>
<td width=44%>Default</td>
<td width=56%>Default</td>
</tr>
<tr valign=top>
<td width=44%>Table validation rule</td>
<td width=56%>SQL Server stored procedures, called from UPDATE and INSERT triggers</td>
</tr>
<tr valign=top>
<td width=44%>Field validation rule</td>
<td width=56%>SQL Server stored procedures, called from UPDATE and INSERT triggers</td>
</tr>
<tr valign=top>
<td width=44%>Persistent relationships (where used for referential integrity constraints)</td>
<td width=56%>Update, Insert, and Delete triggers or table constraints</td>
</tr>
</table><br>
<p>
The following sections discuss each Visual FoxPro object and the SQL Server object (or objects) to which it maps.</p>
<h4>Naming Conventions for Upsized Objects</h4>
<p>
As it migrates objects to a data source, the SQL Server Upsizing Wizard creates named objects on the server. The wizard uses prefixes for objects that need new names because no such stand-alone object existed in Visual FoxPro (defaults and rules, for example). Following the prefix is a table name and then a field name, if appropriate. This naming convention enables all objects of the same kind to have the same prefix and sort together when viewed with data source administration tools. Objects created on the same table also group together when viewed.</p>
<h4>Database and Table Objects</h4>
<p>
A Visual FoxPro database maps directly to a SQL Server database. A Visual FoxPro table, excluding part of its data dictionary, maps to a SQL Server table.</p>
<p>
Database, table, index, and field names might change during upsizing, if they violate SQL Server naming conventions. SQL Server names must be 30 characters or less, and the first character must be a letter or the symbol “@”. The remaining characters may be numbers, letters, or the “$”, “#”, and “_” symbols; no spaces are allowed. The SQL Server Upsizing Wizard replaces any illegal characters with the “_” symbol.</p>
<p>
Any names that are identical to SQL Server reserved words are given a suffix of “_”. For example, FROM and GROUP become FROM_ and GROUP_. The SQL Server Upsizing Wizard also places the “_” symbol in front of object names that begin with a number.</p>
<h4>Tables</h4>
<p>
The SQL Server Upsizing Wizard gives each upsized table the same name as the local table unless the table name contains a space or is a keyword for the data source.</p>
<h4>Views of New Server Tables</h4>
<p>
If you select Create Remote Views On Tables, the SQL Server Upsizing Wizard creates remote views and gives them many of the properties of the fields in the original local table.</p>
<h4>Mapping Visual FoxPro Field Names and Data Types to SQL Server Equivalents</h4>
<p>
Field names and data types are automatically translated into SQL Server fields when a Visual FoxPro table is exported by the SQL Server Upsizing Wizard.</p>
<p>
Visual FoxPro data types map to SQL Server data types as follows:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Abbreviation</b></td>
<td class=label width=39%><b>Visual FoxPro Data Type</b></td>
<td class=label width=40%><b>SQL Server Data Type</b></td>
</tr>
<tr valign=top>
<td width=21%>C</td>
<td width=39%><a href="concharacter_data_type.htm">Character</a></td>
<td width=40%><pre><code>char</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>Y</td>
<td width=39%><a href="concurrency_data_type.htm">Currency</a></td>
<td width=40%><pre><code>money</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>D</td>
<td width=39%><a href="condate_data_type.htm">Date</a></td>
<td width=40%><pre><code>datetime</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>T</td>
<td width=39%><a href="condatetime_data_type.htm">DateTime</a></td>
<td width=40%><pre><code>datetime</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>B</td>
<td width=39%><a href="condouble_field_type.htm">Double</a></td>
<td width=40%><pre><code>float</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>F</td>
<td width=39%><a href="confloat_field_type.htm">Float</a></td>
<td width=40%><pre><code>float</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>G</td>
<td width=39%><a href="congeneral_field_type.htm">General</a></td>
<td width=40%><pre><code>image</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>I</td>
<td width=39%><a href="coninteger_field_type.htm">Integer</a></td>
<td width=40%><pre><code>int</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>L</td>
<td width=39%><a href="conlogical_data_type.htm">Logical</a></td>
<td width=40%><pre><code>bit</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>M</td>
<td width=39%><a href="conmemo_field_type.htm">Memo</a></td>
<td width=40%><pre><code>text</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>M (binary)</td>
<td width=39%>Memo binary</td>
<td width=40%><pre><code>image</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>C (binary)</td>
<td width=39%>Character binary</td>
<td width=40%><pre><code>binary</code></pre>
</td>
</tr>
<tr valign=top>
<td width=21%>N</td>
<td width=39%><a href="connumeric_data_type.htm">Numeric</a></td>
<td width=40%><pre><code>float</code></pre>
</td>
</tr>
</table><br>
<h4>Timestamp and Identity Columns</h4>
<p>
Timestamp columns are created using the Transact-SQL timestamp datatype. When you select the Timestamp column checkbox for a specific table in Step 4 - Map Field Data Types, the SQL Server Upsizing Wizard creates a timestamp field for that table.</p>
<p>
If a table contains one or more memo (M) or picture (P) fields, the SQL Server Upsizing Wizard selects the Timestamp column check box for that table by default and creates a timestamp field on the upsized version of the table.</p>
<p>
Identity columns are created using the Transact-SQL IDENTITY property fields.</p>
<h4>Indexes</h4>
<p>
SQL Server and Visual FoxPro indexes are very similar. The following table shows how Visual FoxPro index types are converted to SQL Server index types:</p>
<p class=label>
<b>Index Type Conversion</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Visual FoxPro Index Type</b></td>
<td class=label width=52%><b>SQL Server Index Type</b></td>
</tr>
<tr valign=top>
<td width=48%><a href="glsprimary_index.htm">Primary</a></td>
<td width=52%>Clustered Unique</td>
</tr>
<tr valign=top>
<td width=48%><a href="glscandidate_index.htm">Candidate</a></td>
<td width=52%>Unique</td>
</tr>
<tr valign=top>
<td width=48%><a href="glsunique_index.htm">Unique</a> <a href="glsregular_index.htm">Regular</a></td>
<td width=52%>Non-unique</td>
</tr>
</table><br>
<p>
The SQL Server Upsizing Wizard uses Visual FoxPro tag names as names for indexes on SQL Server. If the tag name is a reserved word on the server, the wizard alters the tag name by appending the “_” character.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;SQL Server doesn’t support ascending or descending indexes, or permit expressions within server indexes. The SQL Server Upsizing Wizard removes Visual FoxPro expressions from index expressions as the index is upsized; only field names are sent to the server.</p>
<h4>SQL Server Defaults</h4>
<p>
A Visual FoxPro default expression maps directly to a single SQL Server default. The SQL Server Upsizing Wizard tries to create a SQL Server default based on the default expression for a Visual FoxPro field. If the default is successfully created, the SQL Server Upsizing Wizard binds it to the appropriate SQL Server field. The upsizing report on fields indicates if the SQL Server Upsizing Wizard was successful in translating the Visual FoxPro expression to SQL Server Transact-SQL. For details on translation, see <a href="#dgexpression_mapping">Expression Mapping</a> later in this chapter.</p>
<p>
While SQL Server and Visual FoxPro defaults are largely similar, there are some differences in the way defaults are created and behave in the two products. SQL Server defaults are stand-alone objects, independent of any particular field or table. Once a default has been created, it can be used by, or bound, to any number of different fields.</p>
<h4>Naming Conventions for Defaults</h4>
<p>
The SQL Server Upsizing Wizard names defaults using the prefix <code>Dflt_</code> plus the table name and field name. For example, a default value for the <code>ordamt</code> field in the Customer table might be named <code>Dflt_Customer_Ordamt</code> on the server. If combining the prefix with the table and field names causes the default name to exceed 30 characters, Visual FoxPro truncates the excess characters.</p>
<p>
Fields with a default expression of zero are bound to a default named <code>UW_ZeroDefault</code>. If two or more fields have the same non-zero default expression, the SQL Server Upsizing Wizard creates two defaults, with two different names, that are functionally identical.</p>
<h4>Default Values for Visual FoxPro Logical Fields</h4>
<p>
Logical fields in SQL Server prohibit null values; Visual FoxPro logical fields allow them. To manage this difference, the SQL Server Upsizing Wizard automatically creates and binds a default value called <code>UW_ZeroDefault</code> to each exported logical field, whether or not you chose to export defaults. This default sets the value of the server field to 0 (or false (.F.), if you look at the field in Visual FoxPro) when you don’t supply a value.</p>
<p>
If the local Visual FoxPro table contains a default value for a logical field that sets the field equal to true (.T.), the SQL Server Upsizing Wizard doesn't bind the UW_ZeroDefault default to the server table. Instead, the wizard creates a default that sets the field equal to 1, and names the default according to the naming conventions outlined earlier in this chapter.</p>
<p>
SQL Server defaults behave differently than Visual FoxPro defaults. For more information, see <a href="#dgdefault_values">Default Values</a> later in this chapter.</p>
<h4>SQL Server Triggers</h4>
<p>
A SQL Server trigger is a series of Transact-SQL statements associated with a particular SQL Server table. When you choose to upsize Validation rules and Relationships in Step 8, the SQL Server Upsizing Wizard converts Visual FoxPro field- and record-level validation rules and persistent table relationships into stored procedures that are called from SQL Server triggers. Each server trigger can contain code to emulate the functionality of several validation and referential integrity rules.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The SQL Server Upsizing Wizard does not upsize Visual FoxPro triggers.</p>
<p>
A server table can have three triggers, one for each of the commands that can modify data in the table: UPDATE, INSERT, and DELETE. The trigger is automatically executed when the associated command is carried out.</p>
<p>
The following table describes the triggers created by the SQL Server Upsizing Wizard. Any specific trigger might contain code to emulate some or all of the Visual FoxPro functionality listed.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=34%><b>Trigger</b></td>
<td class=label width=66%><b>Visual FoxPro Functionality Emulated</b></td>
</tr>
<tr valign=top>
<td width=34%>UPDATE</td>
<td width=66%>Validation rules (Field- and record-level validation)<p>
Referential integrity</p>
</td>
</tr>
<tr valign=top>
<td width=34%>INSERT</td>
<td width=66%>Validation rules (Field- and record-level validation)<p>
Referential integrity (Child table triggers only)</p>
</td>
</tr>
<tr valign=top>
<td width=34%>DELETE (Parent table only)</td>
<td width=66%>Referential integrity</td>
</tr>
</table><br>
<h4>Naming Conventions for Triggers</h4>
<p>
The SQL Server Upsizing Wizard names server triggers by combining a prefix that indicates the type of trigger being created with the table name of the SQL Server table to which the trigger belongs. The prefix (“TrigU_” for UPDATE triggers, “TrigD_” for DELETE triggers, and “TrigI_” for INSERT triggers) is placed in front of the table name. For example, the UPDATE trigger on the Customer table might be called <code>TrigU_Customer</code>.</p>
<h4>Validation Rules</h4>
<p>
The SQL Server Upsizing Wizard can export Visual FoxPro field- and record-level validation rules, which it converts to stored procedures on SQL Server. The wizard names field-level rules by combining a prefix “vrf” (for “validation rule, field”) with the names of the table and the field; an example might be <code>vrf_customer_lname</code>. Table validation rules are named with the prefix “vrt” (for “validation rule, table”) plus the name of the table, to create a name such as <code>vrt_customer</code>.</p>
<p>
The SQL Server Upsizing Wizard uses triggers that call stored procedures rather than SQL Server rules to enforce field level validation because SQL Server rules don't allow you to display custom error messages. For more information about SQL Server rules, see the CREATE RULE command in your SQL Server documentation.</p>
<h4>Referential Integrity</h4>
<p>
Your Visual FoxPro application supports referential integrity through triggers on UPDATE, DELETE, and INSERT events on persistent table relationships that are enforced at the engine level. You can choose to implement referential integrity constraints on SQL Server using either of two methods:</p>
<ul type=disc>
<li>
Trigger-based referential integrity<p class=tl>
-or-</P></li>
<li>
Declarative referential integrity</li>
</ul>
<p>
When you choose trigger-based referential integrity, the SQL Server Upsizing Wizard creates triggers that include the Transact-SQL code required to duplicate Visual FoxPro referential integrity constraints. If you choose to implement declarative referential integrity, the SQL Server Upsizing Wizard creates SQL Server constraints using the ALTER TABLE command with the CONSTRAINT keyword.</p>
<h4>Trigger-based Referential Integrity</h4>
<p>
In the trigger-based method, referential integrity is enforced on SQL Server by Transact-SQL code in triggers. You can use triggers to provide restrictions on UPDATE, DELETE, and INSERT statements, and to cascade changes resulting from DELETE and INSERT statements.</p>
<p>
The SQL Server Upsizing Wizard creates SQL Server triggers by evaluating the Visual FoxPro triggers used to enforce referential integrity on persistent relationships in your Visual FoxPro database. The following table lists the mapping between Visual FoxPro Referential Integrity constraints and the SQL Server triggers generated by the SQL Server Upsizing Wizard.</p>
<p class=label>
<b>Visual FoxPro Referential <br>
Integrity ConstraintSQL Server Trigger</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=17%>UPDATE</td>
<td width=22%>Cascade</td>
<td width=61%>Cascade UPDATE trigger</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=22%>Restrict</td>
<td width=61%>Restrict UPDATE trigger</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=22%>Ignore</td>
<td width=61%>No trigger generated</td>
</tr>
<tr valign=top>
<td width=17%>DELETE</td>
<td width=22%>Cascade</td>
<td width=61%>Cascade DELETE trigger</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=22%>Restrict</td>
<td width=61%>Restrict DELETE trigger</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=22%>Ignore</td>
<td width=61%>No trigger generated</td>
</tr>
<tr valign=top>
<td width=17%>INSERT</td>
<td width=22%>Restrict</td>
<td width=61%>Restrict INSERT trigger</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=22%>Ignore</td>
<td width=61%>No trigger generated</td>
</tr>
</table><br>
<p>
A Visual FoxPro persistent relationship that's used in a referential integrity constraint can become up to four triggers on a SQL Server data source: two for the parent table and two for the child table.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If only one of the tables in a relationship is upsized, or if referential integrity isn't enforced in Visual FoxPro, the relationship isn't exported.</p>
<p>
<b>Parent Table</b></p>
<p>
The SQL Server Upsizing Wizard creates an UPDATE trigger that either prevents the user from changing the parent table’s primary key or cascades that change through the child table, depending on the type of relationship that was created in Visual FoxPro.</p>
<p>
The SQL Server Upsizing Wizard also creates a DELETE trigger that prevents the user from deleting a record with related child records, or that deletes the child records, again depending on the type of relationship between the tables in Visual FoxPro.</p>
<p>
<b>Child Table</b></p>
<p>
The SQL Server Upsizing Wizard creates an UPDATE trigger that prevents the user from making changes to the foreign key that would orphan the record. Similarly, an INSERT trigger is created to prevent the user from adding a new record that has no parent.</p>
<p>
<b>Custom Error Values</b></p>
<p>
If, at run time, the referential integrity established by the SQL Server Upsizing Wizard-created triggers is violated, SQL Server places a custom error value into the @@ERROR variable. Potential error values are defined by the SQL Server Upsizing Wizard as a part of the trigger code. The specific error value returned at run time depends on the action the user was attempting: updating, inserting, or deleting.</p>
<p>
The following table lists the error numbers generated for each action:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=64%><b>Action</b></td>
<td class=label width=36%><b>SQL Server Error</b></td>
</tr>
<tr valign=top>
<td width=64%>Violated validation rule</td>
<td width=36%>44444</td>
</tr>
<tr valign=top>
<td width=64%>Attempted delete</td>
<td width=36%>44445</td>
</tr>
<tr valign=top>
<td width=64%>Attempted update</td>
<td width=36%>44446</td>
</tr>
<tr valign=top>
<td width=64%>Attempted insert</td>
<td width=36%>44447</td>
</tr>
<tr valign=top>
<td width=64%>Update or Delete statement affected more than one row; statement is automatically rolled back</td>
<td width=36%>44448</td>
</tr>
</table><br>
<h4>Declarative Referential Integrity</h4>
<p>
If you choose to implement declarative referential integrity, the SQL Server Upsizing Wizard creates SQL Server constraints using the ALTER TABLE command with the CONSTRAINT keyword. The parent table constraint uses the PRIMARY KEY keyword. The child table constraint uses the FOREIGN KEY and REFERENCES keywords. Declarative referential integrity is supported at the RESTRICT, RESTRICT updates, and RESTRICT deletes levels.</p>
<p>
You can use SQL Server constraints to provide restrictions on UPDATE, DELETE, and INSERT statements.</p>

<h4><a name="dgexpression_mapping"></a>Expression Mapping</h4>
<p>
Although Visual FoxPro and Transact-SQL have some functions in common, many Visual FoxPro functions aren't supported by SQL Server. The SQL Server Upsizing Wizard attempts to convert Visual FoxPro expressions in field- and record-level validation rules and default values to Transact-SQL, using the following expression mapping.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Visual FoxPro expression</b></td>
<td class=label width=52%><b>SQL Server expression</b></td>
</tr>
<tr valign=top>
<td width=48%>True (.T.)</td>
<td width=52%>1</td>
</tr>
<tr valign=top>
<td width=48%>False (.F.)</td>
<td width=52%>0</td>
</tr>
<tr valign=top>
<td width=48%>#</td>
<td width=52%>&lt;&gt;</td>
</tr>
<tr valign=top>
<td width=48%>.AND.</td>
<td width=52%>AND</td>
</tr>
<tr valign=top>
<td width=48%>.NOT.</td>
<td width=52%>NOT</td>
</tr>
<tr valign=top>
<td width=48%>.NULL.</td>
<td width=52%>NULL</td>
</tr>
<tr valign=top>
<td width=48%>.OR.</td>
<td width=52%>OR</td>
</tr>
<tr valign=top>
<td width=48%>=&lt;</td>
<td width=52%>&lt;=</td>
</tr>
<tr valign=top>
<td width=48%>=&gt;</td>
<td width=52%>&gt;=</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngasclp_rp.htm">ASC(&nbsp;)</a></td>
<td width=52%>ASCII(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngatlp_rp.htm">AT(&nbsp;)</a></td>
<td width=52%>CHARINDEX(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngcdowlp_rp.htm">CDOW(&nbsp;)</a></td>
<td width=52%>DATENAME(dw, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngchrlp_rp.htm">CHR(&nbsp;)</a></td>
<td width=52%>CHAR(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngcmonthlp_rp.htm">CMONTH(&nbsp;)</a></td>
<td width=52%>DATENAME(mm, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngctodlp_rp.htm">CTOD(&nbsp;)</a></td>
<td width=52%>CONVERT(datetime, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngctotlp_rp.htm">CTOT(&nbsp;)</a></td>
<td width=52%>CONVERT(datetime, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngdatelp_rp.htm">DATE(&nbsp;)</a></td>
<td width=52%>GETDATE(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngdatetimelp_rp.htm">DATETIME(&nbsp;)</a></td>
<td width=52%>GETDATE(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngdaylp_rp.htm">DAY(&nbsp;)</a></td>
<td width=52%>DATEPART(dd, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngdowlp_rp.htm">DOW(&nbsp;)</a></td>
<td width=52%>DATEPART(dw, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngdtoclp_rp.htm">DTOC(&nbsp;)</a></td>
<td width=52%>CONVERT(varchar, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngdtorlp_rp.htm">DTOR(&nbsp;)</a></td>
<td width=52%>RADIANS(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngdtotlp_rp.htm">DTOT(&nbsp;)</a></td>
<td width=52%>CONVERT(datetime, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lnghourlp_rp.htm">HOUR(&nbsp;)</a></td>
<td width=52%>DATEPART(hh, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lnglikelp_rp.htm">LIKE(&nbsp;)</a></td>
<td width=52%>PATINDEX(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngminutelp_rp.htm">MINUTE(&nbsp;)</a></td>
<td width=52%>DATEPART(mi, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngmonthlp_rp.htm">MONTH(&nbsp;)</a></td>
<td width=52%>DATEPART(mm, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngmtonlp_rp.htm">MTON(&nbsp;)</a></td>
<td width=52%>CONVERT(money, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngntomlp_rp.htm">NTOM(&nbsp;)</a></td>
<td width=52%>CONVERT(float, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngrtodlp_rp.htm">RTOD(&nbsp;)</a></td>
<td width=52%>DEGREES(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngsubstrlp_rp.htm">SUBSTR(&nbsp;)</a></td>
<td width=52%>SUBSTRING(&nbsp;)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngttoclp_rp.htm">TTOC(&nbsp;)</a></td>
<td width=52%>CONVERT(char, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngttodlp_rp.htm">TTOD(&nbsp;)</a></td>
<td width=52%>CONVERT(datetime, ...)</td>
</tr>
<tr valign=top>
<td width=48%><a href="lngyearlp_rp.htm">YEAR(&nbsp;)</a></td>
<td width=52%>DATEPART(yy, ...)</td>
</tr>
</table><br>
<p>
The following expressions are the same on Visual FoxPro and on SQL Server.</p>
<p class=label>
<b>Expressions that map directly from Visual FoxPro to SQL Server</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=34%><a href="lngceilinglp_rp.htm">CEILING(&nbsp;)</a></td>
<td width=33%><a href="lngloglp_rp.htm">LOG(&nbsp;)</a></td>
<td width=33%><a href="lnglowerlp_rp.htm">LOWER(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=34%><a href="lngltrimlp_rp.htm">LTRIM(&nbsp;)</a></td>
<td width=33%><a href="lngrightlp_rp.htm">RIGHT(&nbsp;)</a></td>
<td width=33%><a href="lngrtrimlp_rp.htm">RTRIM(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=34%><a href="lngsoundexlp_rp.htm">SOUNDEX(&nbsp;)</a></td>
<td width=33%><a href="lngspacelp_rp.htm">SPACE(&nbsp;)</a></td>
<td width=33%><a href="lngstrlp_rp.htm">STR(&nbsp;)</a></td>
</tr>
<tr valign=top>
<td width=34%><a href="lngstufflp_rp.htm">STUFF(&nbsp;)</a></td>
<td width=33%><a href="lngupperlp_rp.htm">UPPER(&nbsp;)</a></td>
<td width=33%></td>
</tr>
</table><br>
<h4>Files Created by the SQL Server Upsizing Wizard</h4>
<p>
The SQL Server Upsizing Wizard creates tables for its own use during the upsizing process. These files are removed from the hard disk unless:</p>
<ul type=disc>
<li>
You choose to produce an upsizing report.</li>
<li>
You want to save the generated SQL.</li>
<li>
Errors occur during upsizing and you choose to save the error information.</li>
</ul>
<p>
If any of the conditions above are true, the SQL Server Upsizing Wizard creates a project (named Report, Report1, Report2, and so on) and a database (named Upsize, Upsize1, and so on) in a subdirectory (named UPSIZE) of the defined by the SET DEFAULT command for your Visual FoxPro session. The wizard adds to the database the tables used to produce the Upsizing Report, a table to store the generated SQL, and any error tables. The following table lists the files potentially created by the upsizing process.</p>
<p class=label>
<b>Local Tables Created During Upsizing</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>File Purpose</b></td>
<td class=label width=40%><b>Table Name</b></td>
<td class=label width=39%><b>Contents</b></td>
</tr>
<tr valign=top>
<td width=21%>Report Tables</td>
<td width=40%>Errors_uw</td>
<td width=39%>Information on any error that occurred during upsizing.</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=40%>Fields_uw</td>
<td width=39%>Information about all the tables upsized.</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=40%>Indexes_uw</td>
<td width=39%>Information about all the indexes upsized.</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=40%>Misc_uw</td>
<td width=39%>Miscellaneous upsizing information.</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=40%>Relations_uw</td>
<td width=39%>Information about all the referential integrity constraints stored in the Visual FoxPro database.</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=40%>Tables_uw</td>
<td width=39%>Information on all the tables in the database you choose to upsize.</td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=40%>Views_uw</td>
<td width=39%>Information about the local views redirected to access remote data.</td>
</tr>
<tr valign=top>
<td width=21%>Script Table</td>
<td width=40%>SQL_uw</td>
<td width=39%>One memo field containing all the SQL code generated by the SQL Server Upsizing Wizard.</td>
</tr>
<tr valign=top>
<td width=21%>Data Export Error Tables</td>
<td width=40%>ExportErrors_<i>table_name</i></td>
<td width=39%>For each table that experiences a data export error during upsizing, the SQL Server Upsizing Wizard generates a table containing the records that aren't successfully exported.</td>
</tr>
</table><br>
<p>
If the wizard is canceled during processing or if the wizard halts because of an error, no tables are left on your hard disk.</p>
<h4>Using Generated SQL</h4>
<p>
The Script table stored on your hard disk contains all the SQL code generated by the SQL Server Upsizing Wizard, whether it executes without error on the server or not. If you want to use this code, the best approach is to look at the generated SQL, copy the parts of it you want to use, run the extracted pieces of code, and repeat the process to obtain the results you want. You can’t run the entire SQL script as a substitute for running the SQL Server Upsizing Wizard, because the wizard performs additional steps that aren’t reflected in the generated SQL code.</p>
<h3>Completing the SQL Server Upsizing Process</h3>
<p>
You can now take additional steps, both on your server and in your Visual FoxPro application, to ensure your application and data are secure and functioning properly.</p>
<p>
You can also use the information in this section when you build an application from remote views rather than by upsizing. Regardless of how you created remote tables, you take certain steps to ensure the server and client are prepared to work together in your client/server application.</p>
<h3>SQL Server Steps</h3>
<p>
You can complete the upsizing process on your server by:</p>
<ul type=disc>
<li>
Making sure the tables you want to edit from Visual FoxPro are updatable.</li>
<li>
Setting permissions on the database so that users can access the objects they need.</li>
<li>
Protecting your work by making your new database recoverable, in case it's damaged or lost.</li>
</ul>
<h4>Adding Unique Indexes for Updatability</h4>
<p>
A remote table should have a unique index to be updatable in Visual FoxPro. The SQL Server Upsizing Wizard can export an existing unique index, but it doesn't create one where none exists. Make sure that tables you want to edit from Visual FoxPro are updatable.</p>
<h4>Setting Permissions</h4>
<p>
The new SQL Server database and its objects receive a set of default permissions from the SQL Server. Set permissions on the remote database so that your users have access to the objects they need.</p>
<h4>Database Logon Permissions</h4>
<p>
The default permissions of a new database make it accessible only to system administrators and the database owner.</p>
<p>
You can add new users and groups by using the SQL Server Security Manager or the system procedures <code>sp_adduser</code> and <code>sp_addgroup</code>.</p>
<p>
For more information on adding users and groups, see SQL Server Security Manager Help and the documentation of the system procedures <code>sp_adduser</code> and <code>sp_addgroup</code> in the <i>Microsoft SQL Server Transact-SQL Reference.</i></p>
<h4>Object Permissions</h4>
<p>
All objects created by the Visual FoxPro-to-SQL Server Upsizing Wizard, including tables, triggers, and defaults, are accessible initially only to the database owner and system administrators. This is true whether you upsized to a new or existing database. If you overwrite existing objects, you also overwrite all object permissions.</p>
<p>
To grant permissions on tables, use SQL Enterprise Manager or the GRANT and REVOKE commands. For more information on setting object permissions, see the “Managing Object Permissions” section in the <i>Microsoft SQL Server Administrator's Companion</i>, and the GRANT and REVOKE commands in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<h4>Ensuring Recoverability</h4>
<p>
Protect your work by making your new database recoverable in case it's damaged or lost.</p>
<h4>Dumping the Master Database</h4>
<p>
When a database is created on a SQL Server, new records are added to the system tables in the Master database. Dumping the Master database also provides you with a backup copy, including all the latest changes. For more information on dumping the Master database, see “Backing Up the Master Database” in the <i>Microsoft SQL Server Administrator's Companion</i>, and the DUMP Statement and “Dumping the Master Database” in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<h4>Scheduling Backups</h4>
<p>
Schedule regular backups of your database so that you can restore your database from this backup copy in the event of a serious problem. For details on backing up SQL Server databases, see “Database Maintenance Plan Wizard” and “Backup and Recovery” in <i>What's New in SQL Server 6.5</i> and “Database Design and Backup Strategy” in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<h4>Device Mirroring</h4>
<p>
Mirroring a device continuously duplicates the information from one SQL Server device to another. In the event that one device fails, the other contains an up-to-date copy of all transactions.</p>
<p>
If you anticipate that many changes will be made to a database between backups and you can’t afford to lose those changes, consider device mirroring. Device mirroring is most effective when the devices are located on separate disks, as both devices might be lost if they're on the same disk and the disk fails.</p>
<p>
For more information on mirroring devices, see “Mirroring a Database Device,” “About SQL Server Device Mirroring,” and “Using SQL Server Mirroring” in the <i>Microsoft SQL Server Administrator's Companion</i>.</p>
<h3>Visual FoxPro Client Steps</h3>
<p>
Once you've transferred objects from Visual FoxPro to a SQL Server, you probably need to modify code in the original Visual FoxPro database so that it functions properly with the new SQL Server database.</p>
<h4>Optimizing Views</h4>
<p>
Views created by the SQL Server Upsizing Wizard aren't parameterized and therefore are not optimized. For most efficient processing, add parameters to views created by the SQL Server Upsizing Wizard to download just the data you need. For information on adding a parameter to a view, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>
<p>
Some Visual FoxPro functions aren't supported by SQL Server. If the remote view created by the SQL Server Upsizing Wizard uses functions that couldn't be mapped to Transact-SQL functions, the view will not work. For more information on mapping Visual FoxPro expressions to Transact-SQL expressions, see <a href="#dgexpression_mapping">Expression Mapping</a> earlier in this chapter.</p>
<h4>Creating Stored Procedures and Triggers</h4>
<p>
The SQL Server Upsizing Wizard doesn't upsize Visual FoxPro stored procedures and triggers. If you want to create SQL Server stored procedures or triggers, you can use Transact-SQL on the server or use SQL pass-through in Visual FoxPro. For more information on using Transact-SQL, see your SQL Server documentation. For information on using SQL pass-through, see Chapter 21, <a href="dgimplementing_a_client_server_application.htm">Implementing A Client/Server Application</a>.</p>
<h4>Comparing Event Order</h4>
<p>
In Visual FoxPro, some events occur in a different order, depending on whether your application is using SQL Server data or Visual FoxPro data. These differences might require changes to your code.</p>

<h4><a name="dgdefault_values"></a>Default Values</h4>
<p>
Visual FoxPro default field values appear when you begin editing a new record. Default values generated by SQL Server defaults appear only after a record has been inserted. You need to change any code that depends on having values before the record is committed, such as the code for lookups.</p>
<h4>Validation Rules</h4>
<p>
In Visual FoxPro, field validation occurs when the focus leaves a field. When you edit SQL Server data in attached tables, triggers and rules aren't fired until you leave the record. You might need to modify any record validation rules that rely on field validation occurring when a field is exited.</p>
<h4>Handling Unconverted Expressions</h4>
<p>
The upsizing report indicates whether each Visual FoxPro table validation rule, field validation rule, and default expression was successfully converted. If a default expression or validation rule was not translated, you should rewrite it in Transact-SQL.</p>
<p>
You can also perform validation at the form level in Visual FoxPro. However, if server data is then modified without using a particular form, the validation will not be applied and invalid data might be entered.</p>
<p>
For more information about expression conversion, see <a href="#dgexpression_mapping">Expression Mapping</a> earlier in this chapter. For more information about Transact-SQL functions, see your SQL Server documentation.</p>
<h4>Record Locking</h4>
<p>
Visual FoxPro uses optimistic locking internally when accessing tables on a SQL server. Optimistic locking means that the row is locked only when the edited value is committed and the update process occurs — usually a very brief interval.</p>
<p>
Optimistic locking is used rather than pessimistic locking on SQL Server because pessimistic locking on SQL Server is provided by page locking, potentially locking many records at a time. While page locking prevents other users from making changes to the same record you’re editing, it can also prevent users from accessing many other records in the same (locked) page. Optimistic locking provides the best multi-user access for a Visual FoxPro client/server application.</p>
<p>
You can optimize updates and control how update conflicts are handled with the SQL WhereType property. For more information on controlling update conflicts, see Chapter 8, <a href="dgcreating_views.htm">Creating Views</a>.</p>

<h2><a name="dgupsizing_to_oracle"></a>Upsizing to Oracle</h2>
<p>
The Oracle Upsizing Wizard is similar in behavior to the SQL Server Upsizing Wizard. For step-by-step instructions, see <a href="wizoracle_upsizing_wizard.htm">Oracle Upsizing Wizard</a>. For specific information on Oracle servers, see your Oracle documentation.</p>
<h3>Starting the Oracle Upsizing Wizard</h3>
<p>
After you create a named connection or ODBC data source connecting to an Oracle server, and complete the necessary preparations on the client and server, you're ready to begin upsizing.</p>
<p class=label>
<b>To start the Oracle Upsizing Wizard</b>
<ol>
<li>
From the <b>Tools</b> menu, choose <b>Wizards</b>, and then choose <b>Upsizing</b>.<br><br></li>
<li>
From the <b>Wizard Selection</b> dialog box, choose <b>Oracle Upsizing Wizard</b>.<br><br></li>
<li>
Follow the directions in the wizard screens.<p class=tl>
You can choose <b>Cancel</b> at any time to exit the wizard; the wizard performs no actions on the server until you choose <b>Finish</b>.</P></li>
<li>
When you're ready to upsize, choose <b>Finish</b>.<p class=tl>
<b>Finish</b> is available after you provide the basic information needed for upsizing. If you choose <b>Finish</b> before you complete all the wizard screens, the Oracle Upsizing Wizard uses default values for the remaining screens.</P></li>
</ol>
<p>
After you choose Finish, the Oracle Upsizing Wizard begins exporting the database to the server.</p>
</BODY>
</HTML>
