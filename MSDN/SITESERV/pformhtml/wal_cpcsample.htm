<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sample Client Payment Component</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css">
<br>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="wal_cpcsample_qwmf"></a>Sample Client Payment Component</h1>
<p>
The sample client payment component (CPC) contains sample source files and accompanying documentation that you can use to build a client payment component that is supported by the Payment Selector control. The CPC object stores instances of your payment type. Instances are added, deleted, and modified using the user interface of the Payment Selector. The Payment Selector user interface also allows the user to choose your payment type from the Payment Selector to make online purchases.</p>
<p>
The Payment Manager manages a new CPC using the member functions of the <b>IClientPaymentProvider</b> interface. Your payment option is displayed by the Payment Selector user interface when your CPC registers with the Payment Selector.</p>
<p>
The following diagram illustrates how the CPC functions within the Microsoft® Wallet architecture.</p>
<p>
<img src="wallet.gif" alt="CPC in Wallet architecture" border=0></p>
<p>
A CPC object in the Payment Selector represents a payment method such as credit cards or electronic cash debit cards. Each CPC supports one or more types of that method. For example, a type of a credit card payment method is a VISA card. Each CPC may contain zero or more instances of any type supported by that CPC. Each instance possesses a friendly name that is unique across all CPCs in the Payment Selector.</p>
<p>
The Payment Selector provides the consumer with a rich user interface for managing and selecting instances of payment types. Payment types (such as a VISA, bank, or department store card) are stored in the Payment Selector. When a user creates a new instance of an existing payment type (such as a second bank card), that instance is stored by the payment type component. These instances are locally managed according to a <i>friendly  name</i> that is assigned by the user. Note that instances of payment types are never shared between different components in the Payment Selector.</p>
<p>
After a consumer selects an instance of a payment type from the Payment Selector, a payment instruction (PI) is generated in that payment type component, routed through the Payment Selector, and sent over the browser to the server for the merchant to process payment. The PI may be encrypted and will pass through the Payment Selector as opaque data.</p>
<p>
Refer to the “Client Payment Component (CPC) Interfaces” section for a detailed description of the CPC interfaces and function syntax.</p>

<h1><a name="wal_cpcsample_rfas"></a>Required Tools</h1>
<p>
Building a CPC consists simply of building an in-process Component Object Model (COM) server that implements the appropriate interfaces. The sample included this chapter illustrates this process.</p>
<p>
To build and configure the sample CPC described in this chapter requires the following tools:
<ul>
<li>
&upsilon;Sample client payment component files</li>
<li>
&upsilon;ActiveX™ Template Library 2.1 or later.</li>
<li>
&upsilon;Microsoft® Visual C++® version 5.0</li>
<li>
&upsilon;Microsoft® CABinet Development Kit</li>
</ul>
<h5>Note</h5>
<p>
All CPCs must be in-process COM objects.</p>
<p>
The CPC sample files in the Microsoft® Wallet SDK provide the dialog boxes, registry controls, utility routines, multiple-threading support, and other source files that you need to construct your own component. With these tools and a few modifications to the provided sample code, you can build a CPC that creates and stores instances of its payment type.</p>
<p>
The Microsoft CABinet Development Kit, which you can download from http://www.microsoft.com/intdev/cab/tools.htm, provides the compression and decompression tools used to distribute your CPC in easy-to-install cabinet files. With the CABinet Development Kit tools, you can use the sample installation files to distribute your CPC from your Web page.</p>

<h1><a name="wal_cpcsample_wxbz"></a>Creating a CPC</h1>
<p>
The client payment component (CPC) sample files (located in the \SDK\Wallet\Samples\CPCs\Simple directory) give you the framework to build your CPC by providing dialog boxes, multiple thread support, source files, and installation files. The following diagram explains the process of building a CPC using these sample files.</p>
<p>
<img src="samplecpc.gif" alt="CPC flowchart" border=0></p>
<h5>Note</h5>
<p>
The Wallet SDK sample CPC, which is named <i>Internet Cash</i>, is designed for a single type of payment. A component supports multiple types, but each type must be unique. For example, the default Credit Card component in the Payment Selector contains three unique types: VISA, MasterCard, and American Express.</p>

<h1><a name="wal_cpcsample_tspu"></a>Dialog Boxes</h1>
<p>
The following dialog sample files generate the dialog boxes required by a component.</p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=18%>File name </th>
<th align=left width=82%>Function</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=18%>AddDlg.cpp</td>
<td width=82%>Provides the <b>Internet Cash Add</b> dialog box for adding new instances of the sample CPC payment type (ATL Wizard generated).</td>
</tr>
<tr valign=top>
<td width=18%>EntPass.cpp </td>
<td width=82%>Enables the <b>Internet Cash Use</b> dialog box that asks the user for a password on any modify operations on an instance of a CPC payment type.</td>
</tr>
<tr valign=top>
<td width=18%>ModDlg.cpp</td>
<td width=82%>Provides the <b>Modify Internet Cash </b>dialog box for the user to modify an instance of the CPC payment type.</td>
</tr>
<tr valign=top>
<td width=18%>NewPass.cpp</td>
<td width=82%>Adds the <b>Password</b> dialog box. The CPC uses a wizard to step the user through the process of adding a password.</td>
</tr>
<tr valign=top>
<td width=18%>PIPass.cpp</td>
<td width=82%>Enables the <b>Password</b> dialog box that prompts the user for a password before posting information. Although this dialog box is not a requirement, you should provide the consumer with some notice when money is about to be spent. You must decide how to handle this prompting; instances such as microtransactions involving a few pennies may not warrant a warning. The <b>Delete</b> operation does not require a password. If a user forgets a password, the method of payment can be deleted and a new instance added.</td>
</tr>
</table><br>
<p>
The source files that enable sample dialog boxes are standard Microsoft Developer Studio™ Wizard creations; they interact with the user to obtain information specific to the CPC, and are not very rich in sample format. The Payment Selector has a certain level of richness in its user interface that you should support when building your own dialog boxes. For example, the Add Card Wizard in the Payment Selector contains instructions for the user to explain the process of adding and using a method of payment. While building your dialog boxes, maintain the same level of richness in the dialog box user interface that the Payment Selector user interface offers.</p>

<h1><a name="wal_cpcsample_acyt"></a>Building a CPC</h1>
<p>
You can use the following sample source files (located in the \CPC\sample directory) to set up your component’s DLL, access the component <b>IClientPaymentProvider</b> and <b>IWalletCallback</b> interfaces, and make changes to the registry.</p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=19%>File name </th>
<th align=left width=81%>Function</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=19%>common.h</td>
<td width=81%>Header file that sets the macros for checking error codes. Provides entry keys for registering the CPC with the Payment Selector. </td>
</tr>
<tr valign=top>
<td width=19%>cpcinst.cpp</td>
<td width=81%>Contains all interfaces used during installation of the CPC.</td>
</tr>
<tr valign=top>
<td width=19%>CPCPlugIn.cpp</td>
<td width=81%>ATL-generated file that handles <b>DLLMain</b> integration and MFC <b>CWinApp</b> creation. This file has been modified for MFC threading support.</td>
</tr>
<tr valign=top>
<td width=19%>sdkobj.def</td>
<td width=81%>ATL Wizard–created CPC .def file.</td>
</tr>
<tr valign=top>
<td width=19%>cpcbject.mak</td>
<td width=81%>Make file generated by the CPC project.</td>
</tr>
<tr valign=top>
<td width=19%>CPCPlugIn.idl</td>
<td width=81%>File that defines the CPC object, which is read by the MIDL compiler.</td>
</tr>
<tr valign=top>
<td width=19%>CPCPlugIn.rc</td>
<td width=81%>CPC resource file.</td>
</tr>
<tr valign=top>
<td width=19%>CPCObject.cpp</td>
<td width=81%>Implements the member functions of the CPC interfaces.</td>
</tr>
<tr valign=top>
<td width=19%>regutil.cpp</td>
<td width=81%>Implements a generic registry class that registers the CPC.</td>
</tr>
<tr valign=top>
<td width=19%>utility.cpp</td>
<td width=81%>Defines simple utility routines used by the CPC object. </td>
</tr>
</table><br>

<h1><a name="wal_cpcsample_jmse"></a>Source File Modifications</h1>
<h4>common.h</h4>
<p>
This header file sets the macros for checking error codes and also provides the proper registry entry keys for registering the CPC with the Payment Selector. Use the unique name of your CPC as listed in the \CPCPlugIn directory to register the component.</p>
<p>
The file common.h contains the comment MOD TODO in each line requiring modification. Search the file for the MOD TODO string and replace the default sample name <code>Internet Cash</code> with the unique name of your CPC:</p>
<pre><code>// MOD TODO:  You must create a key in the registry that reflects your CPC name.  To do this you must
//    replace "Internet Cash" with the name of your CPC.
//
#define  RV_CCPLUGIN        TEXT("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Internet Shopper\\PlugIns\\Internet Cash")
#define  RV_CPCINSTALL        TEXT("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Internet Shopper\\Install")
#define  RK_CHANGECOUNT        TEXT("ChangeCount")
#define  RK_CPC_STATE        TEXT("State")
</code></pre>
<p>
Generate new programmatic identifiers (ProgIDs) for your CPC. The Payment Selector uses the ProgID to load the CPC. Note that the CPC ProgID must match the ProgID assigned in CPCPlugIn.cpp:</p>
<pre><code>// MOD TODO:  You must create a unque PROGID that reflects the name of the CPC.  The PROGID is used by the Wallet to load the CPC.  This PROGID must match the PROGID found in sdkplugin.cpp.
#define  RK_PLG_VAL_CCPROGID TEXT("CPCPLUGIN.CPCPlugInObject.1")
</code></pre>
<p>
Refer to the <i>OLE Programmer’s Reference</i> in the Win32® SDK for information regarding programmatic identifiers.</p>
<h4>CPCPlugIn.cpp</h4>
<p>
This key source file is generated by the ATL Wizard, and handles DLLMain integration and the MFC CWinApp creation.</p>
<p>
It is important to note that the sample file provided has been modified to address MFC threading support for the component. If you do not use the sample file, you must devise a way to handle multiple threading and multiple processes on the client payment component level.</p>
<h4>CPCPlugIn.def, CPCPlugIn.mak, and CPCPlugIn.rc</h4>
<p>
The CPCPlugIn.def file is created by the ATL Wizard, the CPCPlugIn.mak file is the make file generated by the sample CPC project, and the CPCPlugIn.rc file is the resource file used by your CPC.</p>
<h4>CPCPlugIn.idl</h4>
<p>
The CPCPlugIn.idl file defines the CPC object. The MIDL compiler reads this file and then generates the type libraries and other linker files.</p>
<p>
You should assign new globally unique identifiers (GUIDs) to configure the sample file for the CPC that you build. The file CPCPlugIn.idl contains the comment MOD TODO in each line requiring modification. Search the file for the MOD TODO comment and replace the existing GUID:</p>
<pre><code>import "oaidl.idl";
import "ocidl.idl";

#include "iWalletCB.idl"
#include "iWalletCB2.idl"
#include "icpc.idl"
#include "ipayinst.idl"

// MOD TODO: Change all occurences of MyCPC to &lt;YourCPCName&gt;
//        

// MOD TODO: you need to replace the following two uuid's with new generated
//        uuid's.  These are used to identify your object and typelib.

[
    uuid(5AC9D181-EC1A-11D0-BB19-00AA00A13794),
    version(1.0),
    helpstring("MyCPC 1.0 Type Library")
]
library MyCPCLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
        uuid(5AC9D18F-EC1A-11D0-BB19-00AA00A13794),
        helpstring("MyCPC Class")
    ]
    coclass MyCPC
    {
        [default] interface IClientPaymentProvider;
        interface IPaymentProviderInstall;
    };
};
</code></pre>
<p>
Refer to the <i>MAPI Programmer’s Reference </i>in the Win32 SDK for more information on creating new GUIDs.</p>
<h4>regutil.cpp</h4>
<p>
This source file implements a generic registry class that controls registration with the Payment Selector.</p>
<h4>CPCObject.cpp</h4>
<p>
This source file implements the member functions of the IClientPaymentProvider and ISelectorCallback interfaces that are used to create and configure payment types in the consumer’s Payment Selector.</p>
<p>
In the CPCObject.cpp file, you will need to modify most of this code to support the CPC you are creating. The file CPCObject.cpp contains the comment MOD TODO in each line requiring modification. You can search the file for the MOD TODO comment to make required changes.</p>
<p>
Change the friendly name from the default Internet Cash to the friendly name of your CPC:</p>
<pre><code>// MOD TODO:  This is the Friendly Name of the CPC type. You must change "Internet Cash" to the friendly name of your CPC.
//
#define SDK_TYPE L"Internet Cash"
static CString szType = SDK_TYPE;
</code></pre>
<p>
Modify the accepted type and short name to reflect the friendly name of your CPC:</p>
<pre><code>// MOD TODO:  This is the Accepted Type (and short name) of the type of this CPC.  You must change "ICash" to the short name of your CPC.
//
#define SDK_ACCEPT_TYPE _T("ICash")
CString szThisType = SDK_ACCEPT_TYPE;
</code></pre>
<p>
Change the fields <code>PAYMENT_TYPE</code>, <code>PAYMENT_ACCOUNT</code>, and <code>PAYMENT_AMOUNT</code> given in the sample to reflect the fields that are being posted back as part of the payment instruction:</p>
<pre><code>// MOD TODO: You should change this to reflect the fields that are being // posted back as part of the payment instruction. This defines a set of // constants and the names that are found in the post.
//
#define PAYMENT_TYPE        0
#define PAYMENT_ACCOUNT        1
#define PAYMENT_AMOUNT        2
static const cPaymentElements = 3;        // MOD TODO: Should reflect the total number

static OLECHAR *rgszFieldNames[] =
{
    L"Type",
    L"Account",
    L"Amount",
};
</code></pre>
<p>
To prevent multiple processes from accessing critical sections, you should replace the sample mutex name “ICashSamplePlugin” with the unique name of your CPC:</p>
<pre><code>// MOD TODO:  You need to change the name of the Mutex to something that // reflects the CPC name.
//
    m_hMutex = CreateMutex(
        NULL,                        // No Scurity
        FALSE,                        // initially not owned
        "ICashSamplePluginMutex");    // name of the Mutex
    if (m_hMutex == NULL)
        return;

    do {
        dwWaitResult = WaitForSingleObject(
                m_hMutex,                // handle of mutex
                1000L);                    // Wait for 1 second
</code></pre>
<p>
Change the sample mapping file name “ICashSamplePlugin” to the unique name of your CPC:</p>
<pre><code>// MOD TODO:  You need to change the name of the Mapping file to something that reflects the CPC name.
//
        if (dwWaitResult ==    WAIT_OBJECT_0) {
            m_hMapObject = CreateFileMapping(
                (HANDLE) 0xFFFFFFFF,        // Use the Paging File
                NULL,                    // No security
                PAGE_READWRITE,            // Read/Write access
                0,                        // size: high 32-bits
                sizeof(InstanceShare),    // size: low 32-bits
                "ICashSamplePluginShare");
            if (!m_hMapObject)
                return;
            fInit = (GetLastError() != ERROR_ALREADY_EXISTS);
</code></pre>
<p>
Replace the fields “PAYMENT_TYPE,” “PAYMENT_ACCOUNT”, and “PAYMENT_AMOUNT” in the sample code with the fields that will be posted back as part of the payment instruction. The <b>SAFEARRAY</b> will consist of name/value pairs whose names and values are stored as <b>BSTR</b>s:</p>
<pre><code>// MOD TODO:  This section of code will build the SAFEARRAY of name/value pairs that is posted back to the server.
//
    FillVariants(pvar, PAYMENT_TYPE, cPaymentElements, SDK_ACCEPT_TYPE);
    FillVariants(pvar, PAYMENT_ACCOUNT, cPaymentElements, m_pData-&gt;m_gData[dwIdx].Name);
    FillVariantsWide(pvar, PAYMENT_AMOUNT, cPaymentElements, bstrTotal);

    hr = S_OK;
</code></pre>
<p>
Explanation and examples of function syntax are provided in the “Client Payment Component (CPC) Interfaces” section.</p>
<h4>utility.cpp</h4>
<p>
This source file defines a simple utility routine used by the CPC object, and provides a message box. You can modify this program to perform routines on the CPC that you create.</p>

<h1><a name="wal_cpcsample_xuun"></a>Using Visual C++</h1>
<p>
After modifying the client payment component (CPC) sample source files, you are ready to build your CPC DLL. The CPCPlugIn.dsw file is a Microsoft® Visual C++® makefile that you can use to build a sample CPC. If you use this makefile to build your CPC DLL, you must change all references to “cpcplgin” to the name of the payment method that you are building. It is recommended, however, that you let Developer Studio create a makefile for you by creating a new Developer Studio project workspace.</p>
<h5>To create a new CPC</h5>
<ol>
<li>
Copy the files in the Simple directory to the directory in which you want to build your CPC.</li>
<li>
Modify the project dependencies that reference the Samples\Common directory.<ul>
<li>
&upsilon;Change the project options preprocessor includes to reference Samples\Common.</li>
<li>
&upsilon;Change the custom build for pmntBuild.idl. The /I..\..\Common should be changed to reference Samples\Common.</li>
<li>
&upsilon;Remove and re-add the regutil.cpp and regutil.h files to the project.</li>
<li>
&upsilon;Optionally, change the output file specified in the Build Settings /linker flags. If you choose to do this, you must also change the name in the .def file.</li>
</ul>
</li>
<li>
Edit the source files (including the .idl and .rgs files). Locate the places in the files that are marked <b>// MOD TODO</b>. These markers identify the places in the source files that need to be changed.</li>
<li>
Because comments are not allowed in the .rgs file, you must change the globally unique identifier (GUID) specified in that file to the coclass GUID that you specified in your .idl file. Additionally, change all references to "MyCPC" to the name of your CPC.</li>
<li>
Change the base address in the Project Settings/link options/Output.  If this is the same as another component's base address it significantly slows down the load process.</li>
</ol>
<p>
If you encounter any problems creating your own version of this sample, or if you lack experience with Visual C++ 5.0, you can create a Component Object Model (COM) object by any means with which you are familiar. This object must implement <a href="wal_paymentbuilder.htm#wal_paymentbuilder_yryg"><b>ICreditCardEncryption2</b></a><b> </b>and <a href="#wal_cpcsample_rjlz"><b>IPaymentProviderInstall</b></a>.</p>

<h1><a name="wal_cpcsample_fwjq"></a>Multiple Threading</h1>
<p>
The Payment Selector supports single processes with multiple threads and multiple processes with one or more threads. During the Add, Modify, and Delete functions, mutexes in the Payment Selector permit only one thread at a time to modify data. Each component is required to share its data among both multiple threads within a single process and multiple processes. Modifications using one instance of the control must be reflected in all instances. The SDK sample uses shared global memory to implement this requirement. You must ensure that multiple instances of the Create function are thread safe.</p>
<p>
The SDK sample uses the following elements to ensure thread safety:
<ul>
<li>
&upsilon;MFC 4.0 (installed with Visual C++ 4.1)</li>
<li>
&upsilon;thrdwrap.cpp</li>
<li>
&upsilon;thrdwrap.h</li>
<li>
&upsilon;thrdchk.h</li>
</ul>
<p>
The MFC CWinApp class captures and transforms the first thread into an MFC thread in the component data structure when the DLL is loaded. The SDK files thrdwrap.cpp and thrdchk.h create the necessary threading structures within MFC to make MFC thread safe within a single process, independent of the shared global data structure. The thrdwrap.cpp file, which includes the thrdwrap.h header file, implements a thread class and checks thread routines to ensure that MFC has the necessary information to perform thread-safe processes. The thrdchk.h header file defines the entry points to the current thread to check whether or not it exists.</p>
<p>
Although the majority of multiple-thread and multiple-process support occurs in the Payment Selector, you must provide a mutex for the Create function to ensure that new instances of the component are created in a thread-safe manner.</p>
<h5>To verify that your CPC supports multiple threading</h5>
<ol>
<li>
Start Internet Explorer version 3.0 or later.</li>
<li>
Open your local HTML page containing the Payment Selector control.</li>
<li>
On the <b>File</b> menu, click <b>New Window</b> to create a second copy of the control. The second copy of the control is run on a new thread within the original process.</li>
<li>
Test the second thread to verify multiple threading in the control.</li>
</ol>
<h5>Note</h5>
<p>
Do not modify the sample files thrdwrap.cpp and thrdchk.h, because these files support thread-safe processes in MFC.</p>
<p>
See the <i>Win32 Programmer’s Reference</i> for additional information on creating a mutex.</p>

<h1><a name="wal_cpcsample_idjc"></a>Distribution</h1>
<p>
After you have built your client payment component (CPC), users of your Web site will have to download and register the component. To accomplish this, you can customize the files located in the \CPCPlugIn\download directory.</p>
<h5>To enable users of your card to download the Other Card plug-in</h5>
<ol>
<li>
Copy the OtherCard.inf file to the directory in which you want to create the .cab file.</li>
<li>
Copy your .dll file into the directory in which you have placed the OtherCard.inf file.</li>
<li>
Edit the .inf file and BuildCab.bat and replace all references to OtherCard in these files with references to your card.</li>
<li>
Run the BuildCab.bat file to make the .cab file, and reference this .cab within the &lt;OBJECT&gt; tag that references your object. For an example of this tag's use, see SDK\Wallet\Samples\Install\OtherCard.htm.</li>
</ol>

<h3><a name="wal_cpcsample_ulgc"></a>Distribution for Microsoft Internet Explorer</h3>
<p>
For users of Microsoft® Internet Explorer version 3.0 and later, create a link on your Web page to the .cab file. When users load the Web page, the control and plug-in will be downloaded, installed, and registered automatically. For example:</p>
<pre><code>&lt;html&gt;

&lt;head&gt;
&lt;title&gt;Standard Client Payment Component Install&lt;/title&gt;
&lt;meta name="GENERATOR" content="Microsoft FrontPage 1.1"&gt;
&lt;/head&gt;

&lt;OBJECT id=paySelector classid="clsid:3B23ADA5-E00D-11CF-8EE7-00A0C9054334"
        codebase="http://example.microsoft.com/testpay/cpcplugin/cpcplugin.cab#Version=1,0,0,1135"
        width=300 height=250 &gt;
    &lt;PARAM Name="AcceptedTypes" Value="visa:clear;mastercard:clear;amex:clear;discover:clear" &gt;
    &lt;PARAM Name="Total" Value="134.50" &gt;
&lt;/OBJECT&gt;

&lt;/html&gt;
</code></pre>
<p>
You can also create a link that allows the user to explicitly download the CPC:</p>
<pre><code>&lt;BODY&gt;
&lt;h2&gt; &lt;align=center&gt;&lt;a href="cpcplugin.cab"&gt;Install Client Payment Component DLL&lt;/a&gt; &lt;/h2&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>

<h3><a name="wal_cpcsample_gzwo"></a>Distribution for Netscape Navigator</h3>
<p>
The procedure for installing the CPC DLL is somewhat different for users of Netscape Navigator. To support these users, build a self-extracting executable file for download. The program that extracts files from .cab files, EXTRACT.EXE, will automatically extract the files in that .cab file (and any subsequent .cab files) if it has been prefixed to the first .cab file.</p>
<h5>To build a self-extracting executable file</h5>
<ol>
<li>
Create a .cab file (or set of .cab files) as described previously.</li>
<li>
At a command prompt, prefix EXTRACT.EXE to the first .cab file (do not prefix EXTRACT.EXE to any other .cab files in the set).</li>
<li>
Distribute the self-extracting .cab file (and any subsequent .cab files).</li>
</ol>
<p>
For example:</p>
<pre><code>C:&gt; diamond /f cpcplugin.ddf        ; Build CAB file set cpcplugin.cab
C:&gt; copy /b extract.exe+cpcplugin.cab cpcplugin.exe        ; cpcplugin.exe is self-extracting
</code></pre>
<p>
Create a link on your Web page to the self-extracting executable for users to download. For example:</p>
<pre><code>&lt;html&gt;

&lt;head&gt;
&lt;title&gt;Standard Client Payment Component Install&lt;/title&gt;
&lt;/head&gt;

&lt;BODY&gt;
&lt;h2&gt; &lt;align=center&gt;&lt;a href="cpcplugin.exe"&gt;Install Client Payment Component DLL&lt;/a&gt; &lt;/h2&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>
Next, you must create a setup program that installs the files to their appropriate directories and registers them.</p>
<p>
For information about .cab files and self-extracting archives, see the following Web site:</p>
<p>
http://www.microsoft.com/workshop/java/cab.htm</p>

<h3><a name="wal_cpcsample_hrnq"></a>Code Signing</h3>
<p>
After you have built your CPC, you should get a digital signature for your component to provide accountability to users downloading from your Web site. Supported in Internet Explorer 3.0, Authenticode™ is Microsoft’s implementation of its code-signing proposal to the W3C. Authenticode uses documented Win32® functionality available to any Microsoft® Windows® 95–based or Microsoft® Windows NT®–based application, and works with Java applets, plug-ins, and ActiveX™ controls to provide accountability for these types of software components. Through Authenticode, end users know who published a piece of software and whether the software has been tampered with, before downloading the software to their PC. Note that Netscape Navigator 3.0 does not support Authenticode or any code-signing technology. For information about code signing, refer to http://www.microsoft.com/intdev/security.</p>

<h1><a name="wal_cpcsample_ytnx"></a>Client Payment Component (CPC) Interfaces</h1>
<p>
In addition to Credit Card component extensions, the Payment Manager supports instances of client payment components (CPCs) that offer other payment types other than credit cards (such as electronic cash). The following interfaces support a CPC and the installation of a CPC:
<ul>
<li>
&upsilon;<b>IClientPaymentProvider</b></li>
<li>
&upsilon;<b>IWalletCallback</b> (Payment Manager interface)</li>
<li>
&upsilon;<b>IPaymentInstall</b> (Payment Manager interface)</li>
<li>
&upsilon;<b>IPaymentProviderInstall</b></li>
</ul>
<p>
Use the functions in the client payment component (CPC) interfaces to offer additional payment types in the Microsoft Payment Selector. The Payment Manager calls methods on the <b>IClientPaymentProvider</b> interface to create and manage instances of a payment type in your CPC. The <b>IWalletCallback</b> interface methods guarantee that instances of payment types have unique names across all components in the Payment Selector. You can use these interfaces to present instances of your payment type (or types) as an option for Payment Selector users during online purchasing transactions. You must implement all the methods in the <b>IClientPaymentProvider</b> interface in order for the Payment Selector to fully support your CPC. In addition, call functions on the <b>IPaymentProviderInstall</b> interface in order to support the installation package for your CPC.</p>
<h5>Note</h5>
<p>
As a COM object, a CPC is responsible for its own memory allocation. When the reference count is zero, the CPC frees memory allocated to that object. All calls may return the E_OUTOFMEMORY (memory allocation failure) value.</p>
<p>
A CPC object in the Payment Selector represents a payment method such as credit cards or electronic cash debit cards. Each CPC supports one or more types of that method. For example, a type of a credit card payment method is a VISA card. Each CPC may contain zero or more instances of any type supported by that CPC. Each instance possesses a friendly name that is unique across all CPC modules in the Payment Selector.</p>
<p>
The Payment Selector provides the consumer with a rich user interface for managing and selecting instances of payment types. Payment types (such as a VISA, bank, or department store card) are stored in the Payment Selector. When a user creates a new instance of an existing payment type (such as a second bank card), that instance is stored by the payment type component. These instances are locally managed according to a <i>friendly name</i> that is assigned by the user. Note that instances of payment types are never shared between different components in the Payment Selector.</p>
<p>
After a consumer selects an instance of a payment type from the Payment Selector, a payment instruction (PI) is generated in that payment type component, routed through the Payment Selector, and sent over the browser to the server for the merchant to process payment. The PI may be encrypted and will pass through the Payment Selector as opaque data.</p>
<p>
All individual elements stored inside a CPC are retrieved by an index position. The accessor is treated as a zero-based array. There is no order imposed on the array and elements may move in the array during the lifetime of the object. For example, a delete operation will not leave a hole in the array. The index positions will change only during add or delete operations.</p>

<h1><a name="wal_cpcsample_cewn"></a>IClientPaymentProvider Interface</h1>
<p>
The <b>IClientPaymentProvider </b>interface is called from the Payment Selector and provides the following methods to create and modify instances of payment types in a CPC:
<ul>
<li>
&upsilon;<b>Create</b></li>
<li>
&upsilon;<b>ManagePaymentInstance</b></li>
<li>
&upsilon;<b>Terminate</b></li>
<li>
&upsilon;<b>GetBitmap</b></li>
<li>
&upsilon;<b>GetTypeCount</b></li>
<li>
&upsilon;<b>GetTypeBitmap</b></li>
<li>
&upsilon;<b>GetSupportType</b></li>
<li>
&upsilon;<b>Exists</b></li>
<li>
&upsilon;<b>GetInstanceCount</b></li>
<li>
&upsilon;<b>GetChangeCount</b></li>
<li>
&upsilon;<b>GetFriendlyName</b></li>
<li>
&upsilon;<b>IsValid</b></li>
<li>
&upsilon;<b>GetInstanceType</b></li>
<li>
&upsilon;<b>IsTypeValid</b></li>
<li>
&upsilon;<b>NewPaymentInstance</b></li>
<li>
&upsilon;<b>GeneratePaymentInformation</b></li>
<li>
&upsilon;<b>DeletePaymentInstance</b></li>
</ul>

<h2><a name="wal_cpcsample_nxzz"></a>IClientPaymentProvider::Create</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Create(</b><br>
<b>IWalletCallback</b> *<i>piCB</i>// in<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>Create </b>function is the initialization member function, and must be called before any other function is called. All other functions will fail if called before <b>Create</b>.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>piCB</i></dt>
<dd>
Interface pointer that permits the CPC to transfer and receive data from the Payment Manager.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
During add and modify operations, the <b>IWalletCallback::Exists</b> function must be called to verify that no instance with the same friendly name exists across Payment Selector components.</p>
<h4>Related Topics</h4>
<ul>
<li>
&upsilon;<a href="#wal_cpcsample_csjd"><b>IWalletCallback::Exists</b></a></li>
</ul>

<h2><a name="wal_cpcsample_tbou"></a>IClientPaymentProvider::Terminate</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Terminate(void);</b></p>
<h4>Description</h4>
<p>
The <b>Terminate </b>function releases resources allocated by the object (the class destructor should also free these resources).</p>
<h4>Parameters</h4>
<p>
None.</p>
<h4>Return Value</h4>
<p>
This function returns the following value. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=10%>Value</th>
<th align=left width=90%>Meaning </th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=10%>S_OK</td>
<td width=90%>Success</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_kikq"></a>IClientPaymentProvider::GetTypeCount</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetTypeCount(</b><br>
<b>long</b> *<i>pcRet</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetTypeCount</b> function returns the number of types currently enabled in the CPC. All CPCs support at least one type but may have zero or more types disabled by the Payment Manager.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>pcRet</i></dt>
<dd>
Pointer to the location where this function will return the count of the number of payment types enabled in the CPC. For example, the return value would be 2 for a Credit Card component that supports VISA and MasterCard, if both are enabled.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=10%>Value</th>
<th align=left width=90%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=10%>S_OK</td>
<td width=90%>Success</td>
</tr>
<tr valign=top>
<td width=10%>E_FAIL</td>
<td width=90%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_xyew"></a>IClientPaymentProvider::GetSupportType</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetSupportType(</b><br>
<b>long</b><i>cIndex</i>// in<i><br>
</i><b>BSTR FAR</b> *<i>pRetType</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetSupportType</b> function returns the friendly name for a payment type based on the index position. This includes only the enabled types. The friendly name for a type is the string presented to a consumer for identification (for example, “American Express”). Valid values of an index are zero through <b>GetTypeCount</b> minus one.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>cIndex</i></dt>
<dd>
Index of the payment instance in the list of instances registered by the CPC.</dd>
<dt>
<i>pRetType</i></dt>
<dd>
String containing the friendly name for the specified payment type.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success.</td>
</tr>
<tr valign=top>
<td width=25%>E_INVALIDARG</td>
<td width=75%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure.</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_qile"></a>IClientPaymentProvider::GetInstanceCount</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetInstanceCount(</b><br>
<b>long FAR </b>*<i>pcRet</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetInstanceCount </b>function returns the total count of instances stored in the CPC, for all of the enabled types. Note that there is no way to check the number of instances of each type other than counting them.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>pcRet</i></dt>
<dd>
Pointer to the location where this function will return the count of the number of payment instances created by the user in a given CPC. Any instance of any payment type known to the CPC is counted.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values.</p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=10%>Value</th>
<th align=left width=90%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=10%>S_OK</td>
<td width=90%>Success</td>
</tr>
<tr valign=top>
<td width=10%>E_FAIL</td>
<td width=90%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_sycx"></a>IClientPaymentProvider::GetFriendlyName</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetFriendlyName(</b><br>
<b>long</b><i>cIndex</i>// in<br>
<b>BSTR FAR </b>*<i>RetName</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetFriendlyName</b> function returns the friendly name for an instance based upon index position. Valid values of an index are zero through <b>GetInstanceCount</b> minus one.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>cIndex</i></dt>
<dd>
Index of the payment instance in the list of instances registered with the CPC.</dd>
<dt>
<i>RetName</i></dt>
<dd>
Pointer to the location where this function will return the friendly name of the payment instance at the specified index.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success.</td>
</tr>
<tr valign=top>
<td width=25%>E_INVALIDARG</td>
<td width=75%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure.</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_qint"></a>IClientPaymentProvider::GetInstanceType</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetInstanceType(</b><br>
<b>long</b><i>cIndex</i>// in<br>
<b>BSTR FAR </b>*<i>pRetType</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetInstanceType</b> function returns the friendly name of an instance’s type based upon the index.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>cIndex</i></dt>
<dd>
Index of the payment instance in the list of instances registered with the CPC.</dd>
<dt>
<i>pRetType</i></dt>
<dd>
Pointer to the location where this function will return the name of the type of the payment instance at the specified index.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success.</td>
</tr>
<tr valign=top>
<td width=25%>E_INVALIDARG</td>
<td width=75%>One or more arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure.</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_uqsr"></a>IClientPaymentProvider::NewPaymentInstance</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT NewPaymentInstance(</b><br>
<b>BSTR</b><i>bstrType</i>// in<br>
<b>long FAR </b>*<i>pcIdx</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>NewPaymentInstance</b> function adds a new instance to the CPC. When this function is called, the Payment Selector provides the appropriate type of the instance and the CPC returns the index position of the new instance.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrType</i></dt>
<dd>
String identifying the payment type of the new instance.</dd>
<dt>
<i>pcIdx</i></dt>
<dd>
Pointer to the location where this function will return the index to the newly created payment instance.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>E_INVALIDARG</td>
<td width=75%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure.</td>
</tr>
<tr valign=top>
<td width=25%>S_FALSE</td>
<td width=75%>Cancel by user.</td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
During add and modify operations, the <b>IWalletCallback::Exists</b> function must be called to verify that no instance with the same friendly name exists across payment modules.</p>
<h4>Related Topic</h4>
<ul>
<li>
&upsilon;<a href="#wal_cpcsample_csjd"><b>IWalletCallback::Exists</b></a></li>
</ul>

<h2><a name="wal_cpcsample_ixal"></a>IClientPaymentProvider::DeletePaymentInstance</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT DeletePaymentInstance(</b><br>
<b>BSTR</b><i>bstrFriendName</i>// in<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>DeletePaymentInstance</b> function deletes an instance from the CPC.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrFriendName</i></dt>
<dd>
Friendly name of the instance to delete.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values.</p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>E_INVALIDARG</td>
<td width=75%>One or more of the arguments is not valid.</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure.</td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success.</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_unvj"></a>IClientPaymentProvider::ManagePaymentInstance</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT ManagePaymentInstance(</b><br>
<b>BSTR</b><i>bstrFriendName</i>// in<br>
<b>long FAR </b>*<i>pcIdx</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>ManagePaymentInstance </b>function allows the user to modify an instance in the CPC. This function identifies an instance by its friendly name and returns its index position to the caller.</p>
<p>
When building the CPC, you may choose not to permit modifications to the friendly name of an instance. Note that <b>IClientPaymentProvider::Exists</b> should be called <i>only</i> when the friendly name has changed. If the friendly name has not changed, then you should not call the <b>Exists</b> function.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrFriendName</i></dt>
<dd>
Friendly name of the instance to modify.</dd>
<dt>
<i>pcIdx</i></dt>
<dd>
Index to the newly modified payment instance.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>E_VALIDARG</td>
<td width=75%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure.</td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success.</td>
</tr>
<tr valign=top>
<td width=25%>S_FALSE</td>
<td width=75%>Cancel by user.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
During add and modify operations, the <b>IWalletCallback::Exists</b> function must be called to verify that no instance with the same friendly name exists across CPCs.</p>
<h4>Related Topics</h4>
<ul>
<li>
&upsilon;<a href="#wal_cpcsample_ayst"><b>IClientPaymentProvider::Exists</b></a></li>
<li>
&upsilon;<a href="#wal_cpcsample_csjd"><b>IWalletCallback::Exists</b></a></li>
</ul>

<h2><a name="wal_cpcsample_muzz"></a>IClientPaymentProvider::GetBitmap</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetBitmap(<br>
long</b><i>cFriendIdx</i><b></b>// in<b><br>
long</b><i>fType</i>// in<br>
<b>long *</b><i>hBitMap</i>// out<b><br>
);</b></p>
<h4>Description</h4>
<p>
The <b>GetBitmap</b> function returns a bitmap handle based upon an index of an instance. Large (120 &times; 79, 16–system color) and small (30 &times; 18, 16–system color) bitmaps are defined or supported. It is valid to return zero if a bitmap does not exist. Note that this function will not return an E_OUTOFMEMORY value because bitmaps are created during the <b>Create</b> call (which may return an E_OUTOFMEMORY value).</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>cFriendIdx</i></dt>
<dd>
Index into the list of payment instances for the CPC.</dd>
<dt>
<i>fType</i></dt>
<dd>
Enumerated type indicating whether the small or large bitmap should be returned.</dd>
<dt>
<i>hBitMap</i></dt>
<dd>
Pointer to the location where this method returns a handle to a bitmap that is<i> </i>used with the friendly name to represent the payment instance.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=20%>Value</th>
<th align=left width=80%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=20%>E_INVALIDARG</td>
<td width=80%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=20%>E_FAIL</td>
<td width=80%>Failure.</td>
</tr>
<tr valign=top>
<td width=20%>S_OK</td>
<td width=80%>Success.</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_ebpg"></a>IClientPaymentProvider::GetTypeBitmap</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetTypeBitmap(</b><br>
<b>BSTR</b><i>bstrType</i>// in<br>
<b>long</b><i>fType</i>// in<br>
<b>long</b> *<i>hBitMap</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetTypeBitmap</b> function returns a bitmap handle based on a type. Large (120 &times; 79, 16–system color) and small (30 &times; 18, 16–system color) bitmaps are defined or supported. It is valid to return zero if a bitmap does not exist. Note that this function will not return an E_OUTOFMEMORY value because bitmaps are created during the <b>Create</b> call (which may return an E_OUTOFMEMORY value).</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrType</i></dt>
<dd>
Name of the type associated with the bitmap.</dd>
<dt>
<i>fType</i></dt>
<dd>
Enumerated type indicating whether the small or large bitmap should be returned.</dd>
<dt>
<i>hBitMap</i></dt>
<dd>
Pointer to the location where this method returns a handle to a bitmap that is used with the friendly name to represent the payment instance.
</dd>
</dl>
<h4>Return Values</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=20%>Value</th>
<th align=left width=80%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=20%>E_INVALIDARG</td>
<td width=80%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=20%>E_FAIL</td>
<td width=80%>Failure.</td>
</tr>
<tr valign=top>
<td width=20%>S_OK</td>
<td width=80%>Success.</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_ayst"></a>IClientPaymentProvider::Exists</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Exists(</b><br>
<b>BSTR</b><i>bstrFriendName</i>// in<br>
<b>long *</b><i>plExists</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>Exists</b> function determines whether an instance with the same friendly name as the one being created already exists in the CPC. This function ensures the uniqueness of friendly names (regardless of case) within the CPC.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrFriendName</i></dt>
<dd>
Friendly name to compare to other names of instances to determine its uniqueness within the CPC.</dd>
<dt>
<i>plExists</i></dt>
<dd>
Non-zero if the specified friendly name is already in use.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=10%>Value</th>
<th align=left width=90%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=10%>E_FAIL</td>
<td width=90%>Failure</td>
</tr>
<tr valign=top>
<td width=10%>S_OK</td>
<td width=90%>Success</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
The<b> IWalletCallback::Exists </b>function determines the uniqueness of a friendly name across all CPCs.</p>
<h4>Related Topics</h4>
<ul>
<li>
&upsilon;<a href="#wal_cpcsample_unvj"><b>IClientPaymentProvider::ManagePaymentInstance</b></a></li>
<li>
&upsilon;<a href="#wal_cpcsample_csjd"><b>IWalletCallback::Exists</b></a></li>
</ul>

<h2><a name="wal_cpcsample_nvjx"></a>IClientPaymentProvider::GetChangeCount</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetChangeCount(</b><br>
<b>long *</b><i>plCount</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetChangeCount</b> function allows the Payment Selector to test whether any data in the CPC has been changed. This function returns a change count that is a long integer that increments each time a data change (such as add, delete, or modify) is made. The count signifies to the Payment Selector that the contents of a CPC have been changed.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>plCount</i></dt>
<dd>
Pointer to the location where this method returns the count of changes made to data in the CPC.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=10%>Value</th>
<th align=left width=90%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=10%>E_FAIL</td>
<td width=90%>Failure</td>
</tr>
<tr valign=top>
<td width=10%>E_OK</td>
<td width=90%>Success</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_ufmy"></a>IClientPaymentProvider::IsValid</h2>
<h4>Description</h4>
<p>
<b>HRESULT IsValid(<br>
BSTR</b><i>bstrFriendname</i>// in<br>
<b>BSTR</b><i>bstrAcceptTypes</i><b></b>// in<b><br>
long *</b><i>plResult</i>// out<b><br>
);</b></p>
<h4>Description</h4>
<p>
The <b>IsValid</b> function determines whether the instance is valid given the accepted types string. The Payment Manager calls this function to determine whether the specified instance supports any of the payment types listed in the <i>bstrAcceptTypes</i> string. The <b>IsValid</b> function is used by the user interface to indicate whether an instance of a payment type is accepted at a merchant’s site. Instances that are not accepted at a merchant’s site appear shaded.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrFriendName</i></dt>
<dd>
Friendly name of the instance to verify as valid.</dd>
<dt>
<i>bstrAcceptTypes</i></dt>
<dd>
List of accepted types provided by the merchant. See the “Remarks” section for a description of the payment information property that returns accepted types of credit-card payment.</dd>
<dt>
<i>plResult</i></dt>
<dd>
Pointer to a <b>long</b> that is a Boolean.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=20%>Value</th>
<th align=left width=80%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=20%>E_FAIL</td>
<td width=80%>Failure.</td>
</tr>
<tr valign=top>
<td width=20%>E_INVALIDARG</td>
<td width=80%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=20%>S_OK</td>
<td width=80%>Success.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
The AcceptedTypes payment information property returns the types of credit-card payment that a merchant accepts for payment. The :clear value assigned to accepted credit card names signifies a clear text representation (no encryption).</p>
<p>
This payment information property takes as a parameter bstrTypes, which is a string containing a list of name/value pairs. Note in the following example that the type name (<code>Visa, MasterCard, Amex</code>) and the encryption value (<code>clear</code>) are separated by colons:</p>
<pre><code>"Visa:clear;MasterCard:clear;Amex:clear"
</code></pre>

<h2><a name="wal_cpcsample_elnd"></a>IClientPaymentProvider::IsTypeValid</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT IsTypeValid(<br>
BSTR</b><i>bstrType</i>// in<br>
<b>BSTR</b><i>bstrAcceptTypes</i><b></b>// in<b><br>
long *</b><i>plResult</i>// out<b><br>
);</b></p>
<h4>Description</h4>
<p>
The <b>IsTypeValid</b> function determines whether a type is valid given the accepted types string. This function is used by the user interface to indicate which payment types are accepted at a merchant’s site. Payment types that are not accepted at a merchant’s site appear shaded.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrType</i></dt>
<dd>
String identifying the payment type of the instance.</dd>
<dt>
<i>bstrAcceptTypes</i></dt>
<dd>
List of accepted types provided by the merchant. See the “Remarks” section of <b>IClientPaymentProvider::IsValid</b>.</dd>
<dt>
<i>plResult</i></dt>
<dd>
Pointer to a <b>long</b> that is a Boolean.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=20%>Value</th>
<th align=left width=80%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=20%>E_FAIL</td>
<td width=80%>Failure.</td>
</tr>
<tr valign=top>
<td width=20%>E_INVALIDARG</td>
<td width=80%>One or more of the arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=20%>S_OK</td>
<td width=80%>Success.</td>
</tr>
</table><br>
<h4>Related Topics</h4>
<ul>
<li>
&upsilon;<a href="#wal_cpcsample_ufmy"><b>IClientPaymentProvider::IsValid</b></a></li>
</ul>

<h2><a name="wal_cpcsample_pbrp"></a>IClientPaymentProvider::GeneratePaymentInformation</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GeneratePaymentInformation(<br>
BSTR</b><i>bstrFriendname</i>// in<br>
<b>BSTR</b><i>bstrTotal</i>// in<br>
<b>BSTR</b><i>bstrHashOrder</i><b></b>// in<b><br>
BSTR</b><i>bstrAcceptTypes</i>// in<br>
<b>SAFEARRAY (VARIANT) *</b><i>ppsa</i>// out<b><br>
);</b></p>
<h4>Description</h4>
<p>
The <b>GeneratePaymentInformation</b> function returns a payment instruction (PI) based upon the instance.</p>
<p>
If you are using a third-party CPC, the HTML (or .asp) page needs to handle the fields that the CPC returns from the <b>GeneratePaymentInformation</b> call. To do this, these fields need to be added to the hidden form on your HTML page in order to get posted. You should also add the lines to initialize these form fields to their appropriate values.</p>
<h5>Note</h5>
<p>
When this function is called, a dialog box should be displayed to the consumer warning that a specific instance of a payment type is being charged for a shopping transaction.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrFriendName</i></dt>
<dd>
Friendly name of the instance upon which the PI is based.</dd>
<dt>
<i>bstrTotal</i></dt>
<dd>
Total amount that the user is being asked to verify. This amount should be presented to the user for confirmation of the order.</dd>
<dt>
<i>bstrHashOrder</i></dt>
<dd>
Cryptographic hash of the contents of the order. Some protocols package this into the payment instruction. Each CPC determines what is allowed in this field.</dd>
<dt>
<i>bstrAcceptTypes</i></dt>
<dd>
List of the accepted types provided by the merchant.</dd>
<dt>
<i>ppsa</i></dt>
<dd>
Pointer to a two-dimensional safe array of name/value pairs whose names and values are stored as <b>BSTR</b>s. Name/value pairs contain the name of a field and the value assigned to that field.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure.</td>
</tr>
<tr valign=top>
<td width=25%>E_INVALIDARG</td>
<td width=75%>One or more of its arguments is invalid.</td>
</tr>
<tr valign=top>
<td width=25%>E_OUTOFMEMORY</td>
<td width=75%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success.</td>
</tr>
</table><br>

<h1><a name="wal_cpcsample_fink"></a>IWalletCallback Interface (Payment Manager)</h1>
<p>
The <b>IWalletCallback</b> interface guarantees the uniqueness of <i>friendly names</i> across all components in the Payment Selector. Friendly names are assigned by the user to each instance of a payment type to distinguish between multiple instances of a payment type. For example, if a user has two Visa credit cards, the first card might have the friendly name <i>Main Visa</i> and the second card <i>Emergency Visa</i>. </p>
<p>
The <b>IWalletCallback</b> interface is an <b>IDispatch</b> interface provided for the <b>IClientPaymentProvider::ManagePaymentInstance</b> and the <b>IClientPaymentProvider::NewPaymentInstance</b> functions. </p>
<p>
The <b>IWalletCallback</b> interface contains the following methods:
<ul>
<li>
&upsilon;<b>Exists</b></li>
<li>
&upsilon;<b>GetWindowHandle</b></li>
</ul>

<h2><a name="wal_cpcsample_csjd"></a>IWalletCallback::Exists</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Exists(<br>
BSTR</b><i>bstrFriendName</i>// in<br>
<b>long *</b><i>plExists</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>Exists</b> function must be called during add (<b>IClientPaymentProvider::NewPaymentInstance</b>) and modify (<b>IClientPaymentProvider::ManagePaymentInstance</b>) operations before an instance can be created or a friendly name modified. This function ensures that the friendly name being added or modified is unique across all components in the Payment Selector. A warning flag will be returned indicating whether the friendly name already exists. If so, this instance must not be created; the user should be prompted to enter a new friendly name.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrFriendName</i></dt>
<dd>
Friendly name of the instance that must be verified as unique across all components in the Payment Selector.</dd>
<dt>
<i>plExists</i></dt>
<dd>
Non-zero if the specified friendly name is already in use.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
Note that this interface is exposed to the CPC during the <b>IClientPaymentProvider::Create </b>function, which is called before all other functions. Therefore, the CPC must save the interface pointer to use during add and modify operations.</p>
<h4>Related Topics</h4>
<ul>
<li>
&upsilon;<b>IClientPaymentProvider::Create</b></li>
<li>
&upsilon;<b>IClientPaymentProvider::ManagePaymentInstance</b></li>
<li>
&upsilon;<b>IClientPaymentProvider::NewPaymentInstance</b></li>
</ul>

<h2><a name="wal_cpcsample_sftn"></a>IWalletCallback::GetWindowHandle</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetWindowHandle(</b><br>
<b>long *</b><i>hWind</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetWindowHandle</b> function returns the window handle of the Payment Selector's window. This handle can be used in calls to Microsoft® Windows® API functions such as <b>MessageBox</b>.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>hWind</i></dt>
<dd>
Handle to the window being called.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns the following value. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
</table><br>

<h1><a name="wal_cpcsample_zuxh"></a>CPC Installation</h1>
<p>
The methods in the following interfaces support the installation of the client payment component (CPC) with the Payment Manager:
<ul>
<li>
&upsilon;<b>IPaymentInstall</b> (Payment manager)</li>
<li>
&upsilon;<b>IPaymentProviderInstall</b> (CPC)</li>
</ul>

<h1><a name="wal_cpcsample_bqtp"></a>IPaymentInstall Interface (Payment Manager)</h1>
<p>
Use the <b>IPaymentInstall</b> interface to install and uninstall CPCs and additional payment types in the Payment Manager. This top-level install interface consists of the following methods:
<ul>
<li>
&upsilon;<b>Install</b></li>
<li>
&upsilon;<b>Uninstall</b></li>
</ul>

<h2><a name="wal_cpcsample_kogp"></a>IPaymentInstall::Install</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Install(</b><br>
<b>long</b><i>lType</i>// in<br>
<b>IPaymentProviderInstall *</b><i>ipInst</i>// in<br>
<b>);</b></p>
<h4>Description</h4>
<p>
Call the <b>Install</b> function to access the <b>IPaymentProviderInstall</b> interface that installs the CPC’s new payment type with the Payment Manager.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>lType</i></dt>
<dd>
Payment type to install in the Payment Selector. A value of 1 indicates that it is a new CPC; a value of 2 indicates that it is a new type within an existing CPC.</dd>
<dt>
<i>ipInstall</i></dt>
<dd>
Pointer to the <b>IPaymentProviderInstall</b> interface to initialize the installation process.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_xnrb"></a>IPaymentInstall::Uninstall</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Uninstall(</b><br>
<b>IPaymentProviderInstall *</b><i>ipInst</i>// in<br>
<b>);</b></p>
<h4>Description</h4>
<p>
This method is called when the <b>IPaymentProviderInstall</b> interface uninstalls a payment type. Note that removing a type from an existing CPC is not supported.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>ipInst</i></dt>
<dd>
Pointer to the <b>IPaymentProviderInstall</b> interface to initialize the uninstallation process.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h1><a name="wal_cpcsample_rjlz"></a>IPaymentProviderInstall Interface (CPC)</h1>
<p>
The <b>IPaymentProviderInstall</b> interface allows you to build an installation package that installs and registers your payment type with the Payment Manager. This interface consists of the following methods:
<ul>
<li>
&upsilon;<b>InitInstall</b></li>
<li>
&upsilon;<b>SupportInstall</b></li>
<li>
&upsilon;<b>ComponentInfo</b></li>
<li>
&upsilon;<b>GetFullTypeCount</b></li>
<li>
&upsilon;<b>GetTypeInfo</b></li>
<li>
&upsilon;<b>SetTypeActivity</b></li>
<li>
&upsilon;<b>InstanceCount</b></li>
<li>
&upsilon;<b>Install</b></li>
<li>
&upsilon;<b>Uninstall</b></li>
<li>
&upsilon;<b>SelfUninstall</b></li>
</ul>

<h2><a name="wal_cpcsample_zuhq"></a>IPaymentProviderInstall::InitInstall</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT InitInstall(void);</b></p>
<h4>Description</h4>
<p>
The <b>InitInstall</b> function initializes the installation process for a CPC that will be installed. Note that this is a new CPC to be installed.</p>
<h4>Parameters</h4>
<p>
None.</p>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_jrhc"></a>IPaymentProviderInstall::SupportInstall</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT SupportInstall(void);</b></p>
<h4>Description</h4>
<p>
The <b>SupportInstall</b> function initializes the Payment Manager to support the installation of a new CPC. The Payment Manager queries all existing CPCs to determine the status of their types before installing the new CPC.</p>
<p>
Note that <b>IPaymentProviderInstall::InitInstall</b> is called for the new CPC after <b>SupportInstall </b>is called on all existing CPCs. This interface is used both to install new CPCs and to enable or disable payment types in existing CPCs and to support the installation of new CPCs.</p>
<h4>Parameters</h4>
<p>
None.</p>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_nehh"></a>IPaymentProviderInstall::ComponentInfo</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT ComponentInfo(</b><br>
<b>long *</b><i>plCount</i>// out<br>
<b>BSTR *</b><i>pbstrName</i>// out<br>
<b>BSTR *</b><i>pbstrSource</i>// out<br>
<b>BSTR * </b><i>pbstrProgID</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>ComponentInfo</b> function returns information about the CPC being installed into the Payment Selector.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>plCount</i></dt>
<dd>
Number of payment types in the CPC. Each CPC must contain at least one payment type. This count does not reflect the enable or disable status; it is the full count.</dd>
<dt>
<i>pbstrName</i></dt>
<dd>
Name of the CPC.</dd>
<dt>
<i>pbstrSource</i></dt>
<dd>
Name of the originator of the CPC. For example, the source of an electronic cash card would be the company that holds the electronic cash accounts.</dd>
<dt>
<i>pbstrProgId</i></dt>
<dd>
Programmatic identification number of the CPC.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_orua"></a>IPaymentProviderInstall::GetFullTypeCount</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetFullTypeCount(</b><br>
<b>long *</b><i>plCount</i>// out, retval<br>
<b>);</b></p>
<h4>Description</h4>
<p>
The <b>GetFullTypeCount</b> function returns the number of payment types in the CPC. This number does not depend on what payment types are enabled or disabled.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>plCount</i></dt>
<dd>
Number of payment types in the CPC. Each CPC must contain at least one payment type.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_kgjy"></a>IPaymentProviderInstall::GetTypeInfo</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT GetTypeInfo(</b><br>
<b>long</b> <i>cIndex</i>// in<br>
<b>BSTR *</b><i>pbstrType</i>// out<br>
<b>long *</b><i>plActive</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
Call the <b>GetTypeInfo</b> function to retrieve information about the status of the payment type in the Payment Selector.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>cIndex</i></dt>
<dd>
Index of the payment type entry.</dd>
<dt>
<i>pbstrType</i></dt>
<dd>
Name of the payment type installed by the CPC.</dd>
<dt>
<i>plActive</i></dt>
<dd>
Pointer to the status of the payment type. The Payment Manager supports interfaces that turn payment types on or off and resolves type conflicts by forcing types to be turned on or off. A value of one (1) indicates that the payment type is turned on; zero (0) indicates that it is turned off.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_lcru"></a>IPaymentProviderInstall::SetTypeActivity</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT SetTypeActivity(</b><br>
<b>BSTR</b><i>bstrType</i>// in<br>
<b>long</b><i>lActive</i>// in<br>
<b>long</b><i>fPersist</i>// in<br>
<b>);</b></p>
<h4>Description</h4>
<p>
Call the <b>SetTypeActivity</b> function to set the activity status of a payment type within a CPC.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrType</i></dt>
<dd>
Payment type to set to active status.</dd>
<dt>
<i>lActive</i></dt>
<dd>
Status of the payment type. A value of one (1) indicates that the payment type is turned on; zero (0) indicates that it is turned off. If a payment type is turned <i>off</i> (inactive) by the user, the payment type bitmap disappears from the Payment Selector user interface until the payment type is turned <i>on</i> (active) again.</dd>
<dt>
<i>fPersist</i></dt>
<dd>
Flag that indicates whether or not the status change should be persistent.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_byhw"></a>IPaymentProviderInstall::InstanceCount</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT InstanceCount(</b><br>
<b>BSTR</b><i>bstrType</i>// in<br>
<b>long *</b><i>plCount</i>// out<br>
<b>);</b></p>
<h4>Description</h4>
<p>
Call the <b>InstanceCount </b>function to count the instances for a payment type in the CPC.</p>
<h4>Parameters</h4>
<dl>
<dt>
<i>bstrType</i></dt>
<dd>
Payment type of the instances to count.</dd>
<dt>
<i>plCount</i></dt>
<dd>
Pointer to the count of instances of the specified payment type.
</dd>
</dl>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_oeoh"></a>IPaymentProviderInstall::Install</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Install(void);</b></p>
<h4>Description</h4>
<p>
Call the <b>Install </b>function to install the CPC into the Payment Selector. This requires the CPC to save its state information.</p>
<h4>Parameters</h4>
<p>
None.</p>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_cdvf"></a>IPaymentProviderInstall::Uninstall</h2>
<h4>Syntax</h4>
<p>
<b>HRESULT Uninstall(void);</b></p>
<h4>Description</h4>
<p>
Call the <b>Uninstall </b>function to uninstall the CPC from the Payment Selector. This function is called from the Payment Manager when the CPC is uninstalled.</p>
<h4>Parameters</h4>
<p>
None.</p>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>

<h2><a name="wal_cpcsample_utpk"></a>IPaymentProviderInstall::SelfUninstall</h2>
<h4>Syntax</h4>
<p>
HRESULT SelfUninstall(void);</p>
<h4>Description</h4>
<p>
The CPC calls the <b>SelfUninstall</b> function to remove the CPC DLL from the Payment Selector. This function is called from the CPC DLL during the unregister process.</p>
<h4>Parameters</h4>
<p>
None.</p>
<h4>Return Value</h4>
<p>
This function returns one of the following values. </p>
<table cellspacing=4 cols=2 width=464>
<tr valign=top>
<th align=left width=25%>Value</th>
<th align=left width=75%>Meaning</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=25%>S_OK</td>
<td width=75%>Success</td>
</tr>
<tr valign=top>
<td width=25%>E_FAIL</td>
<td width=75%>Failure</td>
</tr>
</table><br>
<!-----------------------------Copyright 1997-1998 Microsoft Corporation------------------------------>
<hr>
<center><font size=-1>
<A HREF="sdklegal.htm">&copy; 1997-1998 Microsoft Corporation. All rights reserved.</A>
</font></center>
<br>
<br>
<p>&nbsp;</p></body>
</HTML>
