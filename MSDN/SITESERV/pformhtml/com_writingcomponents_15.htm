<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step Six: Describing the Component's Work</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css">
<br>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h2><a name="com_writingcomponents_rtlz"></a>Step Six: Describing the Component's Work</h2>
<p>
To enhance the usability of your component, you may choose to implement the optional <b>IPipelineComponentDescription</b> interface. This interface defines methods that return <b>SAFEARRAY</b> variables that identify the pipe context elements that a component reads, as well as the <b>OrderForm</b> or <b>Dictionary </b>elements that a component reads and writes.</p>
<p>
When a Pipeline Editor user activates the property pages for your component, the Pipeline Editor checks to see if your component implements <b>IPipelineComponentDescription</b>. If it does, the Pipeline Editor invokes your <b>IPipelineComponentDescription</b> method implementations and displays the values that the component reads and writes in a property page like this one.</p>
<p>
<img src="tut_pipecompdesc.gif" border=0></p>
<p>
When you run the Pipeline Component Wizard, the wizard adds a reference to <b>IPipelineComponentDescription</b> to your <b>CMinMaxShipping</b> derivation list, and adds the <b>IPipelineComponentDescription</b> function signatures to the class defintion.</p>
<pre><code>// IPipelineComponentDescription
    STDMETHOD (ContextValuesRead)(VARIANT *pVar);
    STDMETHOD (ValuesRead)(VARIANT *pVar);
    STDMETHOD (ValuesWritten)(VARIANT *pVar);
</code></pre>
<p>
In addition, the wizard adds stub implementations to the CMinMaxShipping implementation file. The code added by the wizard looks like this:</p>
<pre><code>//
// IPipelineComponentDescription Methods
//
STDMETHODIMP CMinMaxShipping::ContextValuesRead(VARIANT *pVarRead)
{
    // TODO: Add your own values to the array
    int cEntries = 1;
    // allocate the safearray of VARIANTs
    SAFEARRAY*    psa = SafeArrayCreateVector(VT_VARIANT, 0, cEntries);
    // Populate the safearray variants
    VARIANT* pvarT = (VARIANT*)psa-&gt;pvData;
    V_BSTR(pvarT) = SysAllocString(L"Example Context Value Read");
    V_VT(pvarT) = VT_BSTR;
    // set up the return value to point to the safearray
    V_VT(pVarRead) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarRead) = psa;
    return S_OK;
}

STDMETHODIMP CMinMaxShipping::ValuesRead(VARIANT *pVarRead)
{
    // TODO: Add your own values to the array
    int cEntries = 1;
    // allocate the safearray of VARIANTs
    SAFEARRAY*    psa = SafeArrayCreateVector(VT_VARIANT, 0, cEntries);
    // Populate the safearray variants
    VARIANT* pvarT = (VARIANT*)psa-&gt;pvData;
    V_BSTR(pvarT) = SysAllocString(L"Example Value Read");
    V_VT(pvarT) = VT_BSTR;
    // set up the return value to point to the safearray
    V_VT(pVarRead) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarRead) = psa;
    
    return S_OK;
}

STDMETHODIMP CMinMaxShipping::ValuesWritten(VARIANT *pVarWritten)
{
    // TODO: Add your own values to the array
    int cEntries = 1;
    // allocate the safearray of VARIANTs
    SAFEARRAY*    psa = SafeArrayCreateVector(VT_VARIANT, 0, cEntries);
    // Populate the safearray variants
    VARIANT* pvarT = (VARIANT*)psa-&gt;pvData;
    V_BSTR(pvarT) = SysAllocString(L"Example Value Written");
    V_VT(pvarT) = VT_BSTR;
    // set up the return value to point to the safearray
    V_VT(pVarWritten) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarWritten) = psa;
    return S_OK;
}</code></pre>
<p>
This code contains the basic instructions form implementing the interface. The following code illustrates the modifications that you make to the stub implementation to make it accurately reflect that values that the <b>MinMaxShip</b> component actually reads and writes:</p>
<pre><code>STDMETHODIMP CMinMaxShipping::ContextValuesRead(VARIANT *pVarRead)
{
    // allocate the safearray of VARIANTs
    SAFEARRAY*    psa = SafeArrayCreateVector(VT_VARIANT, 0, 0);

    // set up the return value to point to the safearray
    V_VT(pVarRead) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarRead) = psa;

    return S_OK;
}

STDMETHODIMP CMinMaxShipping::ValuesRead(VARIANT *pVarRead)
{
    // allocate the safearray of VARIANTs
    SAFEARRAY*    psa = SafeArrayCreateVector(VT_VARIANT, 0, 1);

    // Populate the safearray variants
    VARIANT* pvarT = (VARIANT*)psa-&gt;pvData;
    V_BSTR(pvarT) = SysAllocString(L"item._product_list_price");
    V_VT(pvarT) = VT_BSTR;

    // set up the return value to point to the safearray
    V_VT(pVarRead) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarRead) = psa;
    
    return S_OK;
}

STDMETHODIMP CMinMaxShipping::ValuesWritten(VARIANT *pVarWritten)
{

    int cEntries = 1;

    // allocate the safearray of VARIANTs
    SAFEARRAY*    psa = SafeArrayCreateVector(VT_VARIANT, 0, cEntries);

    // Populate the safearray variants
    VARIANT* pvarT = (VARIANT*)psa-&gt;pvData;
    V_BSTR(pvarT) = SysAllocString(L"order._shipping_total");
    V_VT(pvarT) = VT_BSTR;

    // set up the return value to point to the safearray
    V_VT(pVarWritten) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarWritten) = psa;

    return S_OK;

}</code></pre>
<h5>Note</h5>
<p>
If your component does not read or write values to the <b>OrderForm</b>, you must still return a <b>SAFEARRAY</b>, even though the <b>SAFEARRAY</b> will most likely be empty.</p>
<pre></pre>
<!-----------------------------Copyright 1997-1998 Microsoft Corporation------------------------------>
<hr>
<center><font size=-1>
<A HREF="sdklegal.htm">&copy; 1997-1998 Microsoft Corporation. All rights reserved.</A>
</font></center>
<br>
<br>
<p>&nbsp;</p></body>
</HTML>
