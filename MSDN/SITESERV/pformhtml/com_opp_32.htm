<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reducing Inventory</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css">
<br>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h3><a name="com_opp_vuhl"></a><sup></sup>Reducing Inventory</h3>
<p>
The <b>FlagInventory</b> and <b>LocalInventory</b> components, discussed in the section on Inventory and Backordering, are strictly informational components. This means that while they provide notification that a given item is out of stock, they assume that the product table column that identifies the number of items in stock has been maintained by some other process.</p>
<p>
Usually, this process involves including the <b>ReduceLocalInventory</b> or <b>SQLItem</b> components in the Accept stage of the purchase pipeline. Both of these components are designed to execute a query that you provide, and that decrements the value stored in the product table column that indicates how many of a given item are in stock.</p>
<p>
Suppose, however, that a situation arises in which two customers are contending for an item of which there is only one in stock. As the <b>OrderForm</b> of each customer passes through the plan pipeline, the Inventory components indicate to both that the product is in stock. This is correct behavior, because the number that indicates how many items of a given SKU are in stock has not yet been reduced to zero (0) by an Accept stage component.</p>
<p>
However, when the first customer runs the purchase pipeline, the <b>SQLItemADO</b> or <b>ReduceLocalInventory</b> component will reduce the in-stock value to zero (0). When the second customer runs the purchase pipeline, the <b>SQLItemADO</b> or <b>ReduceLocalInventory</b> component will reduce this value to a negative integer. In this scenario, back-ordering will effectively have been permitted, even though the site’s plan pipeline may have been configured to disallow backordering.</p>
<p>
There are several ways to address this problem.</p>
<p>
One solution to this problem is to include at the beginning of the Accept stage a <b>SQLItemADO</b> component that checks to ensure that number of items in stock for a given SKU is larger than zero (0). If no items for a given SKU are in stock, the <b>SQLItemADO</b> component can simply place the items on backorder (by initializing the _<code>inventory</code>_<code>backorder</code> name/value pair) or can raise the _<code>pur</code>_<code>out</code>_<code>of</code>_<code>stock</code> error.</p>
<p>
A second solution is simply to include an instance of the appropriate inventory component (<b>FlagInventory</b>, for example) in both the Inventory stage (plan pipeline) and in the Accept stage (purchase pipeline). Following this component, you would include a <b>ReduceLocalInventory</b> component. This component would execute the query to decrement the in-stock value for the item.</p>
<p>
The use of <b>SQLItemADO</b> is preferred in <b>MtsTxPipelines</b>. <b>SQLItemADO</b> supports transacted behavior, and <b>ReduceLocalInventory</b> does not.</p>
<!-----------------------------Copyright 1997-1998 Microsoft Corporation------------------------------>
<hr>
<center><font size=-1>
<A HREF="sdklegal.htm">&copy; 1997-1998 Microsoft Corporation. All rights reserved.</A>
</font></center>
<br>
<br>
<p>&nbsp;</p></body>
</HTML>
