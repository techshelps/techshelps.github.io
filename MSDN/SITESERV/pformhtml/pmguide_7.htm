<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Accessing the New User's Attributes</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css">
<br>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h1><a name="pm_guide_accessing_a_users_attributes"></a>Accessing a User's Attributes</h1>
<p>
This section now demonstrates how to access a user's attributes.&nbsp; We have configured the AUO system with a necessary default AUO provider so we can use the <b>UserObjects</b> and <b>SchemaObjects </b>coclasses to create objects that can be used to easily access this information.</p>
<h3>C++</h3>
<p>
C and C++ programmers can use the P&amp;M COM classes in the standard way.&nbsp; A file containing the interface definitions (IDL) is included with the SDK.&nbsp; One can elect to run the MIDL compiler on these IDL files and generate the necessary header files and GUID definitions, or simply "import" the IDL file into a project in the standard way.</p>
<p>
<b>Example</b></p>
<p>
This example demonstrates the process of creating and using the <b>UserObjects</b> coclass in a C++ program.&nbsp; This class and its COM interfaces are defined within the IDL file <code>auo.idl</code>.&nbsp; The step-by-step procedure is given below.</p>
<p>
Create the project directory for the C++ source code.&nbsp; The header files and GUID definitions are required, so we run the MIDL compiler on an appropriate interface definition language&nbsp; (IDL) file.&nbsp; One can either copy the file auo.idl from the \include directory of the SDK into the project directory, or use the OleView.exe application to bind to the type library and list the IDL definition.&nbsp; In the latter case, simply bind to the type library, which is located within the dynamic link library c:\microsoft site server\bin\p&amp;m\auo.dll.&nbsp; Once bound, click on the type library node in the tree.&nbsp; Select all the IDL text in the right pane and paste it into your favorite text editor.&nbsp; Save the text into a file named <code>auo.idl</code>.&nbsp; We now run the MIDL compiler with this file as the argument.&nbsp; This generates the necessary files:</p>
<p>
auo.h</p>
<p>
auo_i.c</p>
<p>
auo.tlb</p>
<p>
If you run MIDL on the auo.idl file that accompanies the SDK, two other files would be generated:</p>
<p>
auo_p.c</p>
<p>
dlldata.c</p>
<p>
These files are used to build a proxy dynamic link library that could be used to marshal data to and from an instance of the object.&nbsp; Since the desired interfaces are marked with the <i>dual</i> attribute, the <i>oleautomation</i> attribute is implied.&nbsp; Thus, the automation library can handle all marshalling duties using the type library within the AUO.DLL, and these files can therefore be ignored and/or discarded.</p>
<p>
The <b>UserObjects</b> coclass has multiple COM interfaces exposed, and among these are the Active Directory Service Interfaces (ADSI) <b>IADs</b> and <b>IADsContainer</b>.&nbsp; In order to provide forward declarations of these, we must either include the appropriate header files or use the type library to generate them.&nbsp; We'll use the include file that comes with the Platform SDK as it contains declarations for the low-level functions that might come in handy.&nbsp; The actual type library that will be used to provide marshalling information for the Automation system depends on the <i>namespace </i>we use to access directory information.&nbsp; For the LDAP namespace, the type library information for these interfaces is located in the dynamic link library: c:\mircosoft site server\bin\Commerce.dll.&nbsp; If you are unfamiliar with the ADSI system, see the documentation in the Platform SDK under Network and Distributed Systems.</p>
<p>
The file we will use is located in the directory <code>&lt;PlatformSDK_Install_Dir&gt;\include\iads.h</code>.&nbsp; If you do not have the Network and Distributed Services portion of the Platform SDK, this file will not be present.&nbsp; In this case, you can either download this portion from the Microsoft Developers Network (http://www.microsoft.com/msdn) or build an IDL file using the type library information and the OleView application.&nbsp; </p>
<p>
Now that we have all the necessary declarations and GUIDs defined, we can proceed to use the <b>UserObjects</b> coclass in a program.&nbsp; The example below is a simple program that will fetch some properties from the directory service.</p>
<p>
This example ignores all runtime exceptions for the sake of brevity.</p>
<pre><code>#include "iostream.h"
#include "auo.h"
#include "auo_c.h"
#include "iads.h"

int main() {
  CoInitialize(NULL);
  IUserObjects* pIUserObj = NULL;

  HRESULT hR = CoCreateInstance(
               CLSID_UserObjects,
               NULL,
               CLSCTX_ALL,
               IID_IUserObjects,
               (PVOID*)&amp;pIUserObj
               );

                     // we have the interface to the UserObjects object
                     // we now initialize the object
  BSTR bszUserName = ::SysAllocString("JohnS");
  BSTR lIISInstanceId = ::SysAllocString(L"1");

  hR = pIUserObj-&gt;Init( lIISInstanceId, bszUserName ) ;

                     // We now fetch the IADs interface on
                     // the object
  IADs* pIAds = NULL;
  hR = pIUserObj-&gt;QueryInterface( IID_IADS, (void**)&amp;pIADs ) ;

                     // we don’t need the IUserObjects interface anymore
  hR = pIUserObj-&gt;Release();

                     // Now say we want to fetch the GUID property
                     //&nbsp; of the object
  BSTR bszObjGUID = 0;
  hR = pIADs-&gt;get_GUID( &amp;bszObjGuid ) ;

                     // for simplicy, convert the BSTR to char
  char AdsPath[100];
  extern OLECHAR wszGUID[];
  wcscpy(wszGUID,bszObjGUID);
  SysFreeString(bszObjGUID);

  wsctombs(AdsPath,wszGuid);
  cout &lt;&lt; "The ADsPath is: %s\n",AdsPath) ;
</code></pre>
<h3>Java</h3>
<p>
In order to use Java to access the various COM objects provided by the P&amp;M feature, the necessary classes need to be defined and imported into the source code.&nbsp; To do this, run the <i>JactiveX</i> tool which will generate the necessary <code>.java</code> files.&nbsp; You can specify either the .idl file or the type library.&nbsp; For example: <code>JactiveX "c:\microsoft site server\bin\p&amp;m\auo.dll</code>" /d C:\myclasses.&nbsp;&nbsp;&nbsp; One then imports these classes into source code using the <code>import</code> directive. </p>
<p>
It is highly recommended that you install the latest Microsoft Java SDK, Version 2.01 and use only the classes and tools provided in that release.&nbsp; The low-level COM support from earlier Java releases can cause byte-compile and runtime errors.</p>
<p>
<b>Example</b></p>
<p>
File: <code>MyClass.java</code></p>
<pre><code>import auo.*;
import com.ms.com.Variant;
 class MyClass {
  public static void main( String args[] ) {
 &nbsp; IUserObjects pIUserObjects = (IUserObjects) new UserObjects();
 }
}
</code></pre>
<h3>Visual Basic 5.0</h3>
<p>
One can use low-level COM interface binding in Visual Basic 5.0 by adding the appropriate type library into the references in the project.&nbsp; The names of the type libraries are listed in the reference section for each COM class.&nbsp; Alternately, one can use late-binding via the dispinterfaces for each object.&nbsp; In this case, no type information is required before run-time.</p>
<p>
<b>Example </b></p>
<p>
Vtable (early) binding: (IUserObjects)</p>
<pre><code>Dim IUserObjects as UserObjects
Set IUserObjects = New UserObjects
</code></pre>
<p>
or do late binding: (IDispatch)</p>
<pre><code>Dim IUserObjects as Object
Set IUserObjects = CreateObject("Membership.UserObjects")
</code></pre>
<p>
The first example requires the reference to the type library and will do compile-time type checking.&nbsp; The second example proceeds directory through the <b>IDispatch</b> interface and type mismatch errors can only by found at runtime.</p>
<h3>Visual Basic, Scripting Edition (VBScript)</h3>
<p>
VBScript does only late binding through the <b>IDispatch </b>interface, so one can access the services of the classes by creating and instance and calling methods on the dispinterface is the standard way.&nbsp; </p>
<p>
Using VBScript requires some sort of Active Scripting Host, such as the Active Server Pages (ASP) or the Windows Scripting Host (WSH).&nbsp; Of course, any Active Scripting Host that can load the appropriate VBScript parsing engine will do.</p>
<p>
<b>Example </b></p>
<p>
<code>Set IUserObjects = CreateObject("Membership.UserObjects")<br>
Call IUserObjects.Init(1,"JohnS")</code></p>
<p>
One could then run the script in an ASP page or with the <i>Windows Scripting Host</i> using a command such as: <code>cscript myscript.vbs.</code></p>
<p>
In this case, the appropriate scripting engine is identified by the extension on the file name.</p>
<h3>JavaScript</h3>
<p>
JavaScript also does only late binding through the dispinterfaces.&nbsp; An example is shoen below.</p>
<p>
<b>Example</b></p>
<pre><code>var IUserObj = new ActiveXObject("Membership.UserObjects");
var arg1 = 1;
var arg2 = "JohnS";
IUserObj.Init(arg1,arg2);</code></pre>
<p>
One could then run the script in an ASP page or with the <i>Windows Scripting Host</i> using a command such as: <code>cscript myscript.js.</code></p>
<p>
In this case, the appropriate scripting engine is identified by the extension on the file name: <code>.js</code> loads the JavaScript engine.</p>
<!-----------------------------Copyright 1997-1998 Microsoft Corporation------------------------------>
<hr>
<center><font size=-1>
<A HREF="sdklegal.htm">&copy; 1997-1998 Microsoft Corporation. All rights reserved.</A>
</font></center>
<br>
<br>
</BODY>
</HTML>
