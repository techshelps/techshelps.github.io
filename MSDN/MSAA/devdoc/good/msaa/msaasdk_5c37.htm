<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step 3: Respond to Event Notifications</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_msaa_step_3_respond_to_event_notifications"></a>Step 3: Respond to Event Notifications</h3>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Once a WinEvent hook is successfully in place, your hook procedure will begin receiving event notifications. The following function, taken from the Babble sample application, shows an example of how a hook procedure can receive event notifications and process them. </p>
<pre><code>void CALLBACK WinEventProc(HWINEVENTHOOK hEvent, DWORD event,
    HWND hwndMsg, LONG idObject, LONG idChild, DWORD idThread, DWORD dwmsEventTime)
{
    // What type of event is coming through?
    switch (event) {
        case EVENT_OBJECT_FOCUS:
            // Focus is changing.
            OnFocusChangedEvent(event, hwndMsg, 
                                idObject, idChild,
                                dwmsEventTime);
            break;
        }
    return;
}
 </code></pre>
<p>
For simplicity, Babble's <b>WinEventProc</b> function responds only to <b>EVENT_OBJECT_FOCUS</b> events, calling another application-defined function to process them (your client application would probably respond to far more events). When the hook procedure receives an EVENT_OBJECT_FOCUS event, Babble calls the following OnFocusChangedEvent application-defined function to retrieve an interface pointer based on the information Babble received with the notification. </p>
<pre><code>BOOL OnFocusChangedEvent(DWORD event, HWND hwnd,
    LONG idObject, LONG idChild, DWORD dwmsTimeStamp)
{
    VARIANT      varChild;
    IAccessible* pIAcc;
    HRESULT      hr;
    int          cchName = 128;
    TCHAR        tszName[128];
    TCHAR        tszSpeak[1024];
    
    // Important to init variants
    VariantInit(&amp;varChild);

    hr = AccessibleObjectFromEvent(hwnd, (DWORD)idObject, (DWORD)idChild, &amp;pIAcc, &amp;varChild);
    
    // Check to see if we got a valid pointer
    if (SUCCEEDED(hr)) 
    {
        OBJINFO objCurrent;

        objCurrent.hwnd = hwnd;
        objCurrent.plObj = (long*)pIAcc;
        objCurrent.varChild = varChild;

        GetObjectName(&amp;objCurrent, tszName, cchName);

        wsprintf(tszSpeak, "Focus now %s.", tszName);
        
        SpeakString(tszSpeak);

        if (pIAcc)
             pIAcc-&gt;Release();

        return(TRUE);
     }
    
     // No object was retrieved, so send a failure value.
    return(FALSE);
}
 </code></pre>
<p>
OnFocusChangedEvent uses the <b>AccessibleObjectFromEvent</b> function to retrieve information about the object that generated the event. Note that <b>AccessibleObjectFromEvent</b> doesn't accept an event value. At first this might seem odd, but Babble already knows about what event happened; now it needs information about who generated it. Knowing this, it makes sense that <b>AccessibleObjectFromEvent</b> only needs information about the window, object, and child element associated with the event. Also note that Babble initializes the <b>VARIANT</b> structure it sends with the function call to comply with OLE Automation standards. </p>
<p>
When <b>AccessibleObjectFromEvent</b> returns, Babble tests the return value with the <b>SUCCEEDED</b> macro. <b>SUCCEEDED</b> is a macro found in the COM interface. If the call succeeded, it uses Microsoft Speech SDK API elements to vocalize the event, then releases the retrieved interface by calling its <b>IUnknown::Release</b> function. This step is required to meet COM standards. </p>
<p>&nbsp;</p></body>
</HTML>
