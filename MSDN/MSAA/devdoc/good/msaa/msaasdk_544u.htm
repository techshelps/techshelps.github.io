<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Object Navigation</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_msaa_object_navigation"></a>Object Navigation</h3>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The term "navigation," when used in the context of accessible objects, refers to the process of retrieving the address of another object's <b>IAccessible</b> or <i>IDispatch interface</i> using the methods provided by the current object. </p>
<p>
<b>Hierarchical Object Navigation</b></p>
<p>
Often, client applications must move between objects based on their parent-child relationships. For example, an accessibility aid might already have information about a toolbar control, but not yet know anything about the buttons or other controls contained within it. </p>
<p>
The <b>IAccessible</b> interface exposes the hierarchical relationships between objects through the <b>IAccessible::get_accParent</b> and <b>IAccessible::get_accChild</b> methods. Using these methods, client applications can navigate from a parent object to its children or vice versa. </p>
<p>
<b>Spatial and Logical Object Navigation</b> </p>
<p>
Applications can retrieve information about an object that is spatially or logically near the current object by using the <b>IAccessible::accNavigate</b> method. Using this method, a client can navigate to another object based on its location on the screen (spatial) or to the object that logically precedes or follows the current object, as determined by the server (logical). The client application specifies the type and direction to navigate by using <i>navigational constants</i> when calling the method. </p>
<p>
The two types of navigation are very different. Spatial navigation is simple in concept; if a client wants the object to the right of the current one, the server retrieves it and gives it to the client. However, since logical relationships between objects are subjective, logical navigation is less straightforward for both the client and server. Generally, these relationships parallel those in keyboard navigation. For example, imagine a typical dialog box that contains a few edit controls, an OK button and a Cancel button. In this case, calling the <b>IAccessible::accNavigate</b> method to move to the next or previous object in the dialog box is analogous to the user pressing <small>tab</small> or <small>shift+tab</small>. That is, when the user presses <small>tab</small>, the system moves focus to the next object, and when the user presses <small>shift+tab</small>, the system moves the focus to the previous object. </p>
<p>
When performing spatial navigation, clients must be aware of all floating objects. Because a floating object isn't clipped to its parent, you can't be sure of the hierarchical relationship between two objects near one another on the screen. </p>
<p>
The following illustration shows this example of a floating object that isn't clipped to its parent. </p>
<p>
<img src="images/floatob.gif" border=0></p>
<p>
<b>Object Navigation Through Hit Testing</b></p>
<p>
Applications can retrieve information about a child object by hit testing a point on the screen. To do this, call the current object's <b>IAccessible::accHitTest</b> method, passing the screen location to be hit tested in x- and y-coordinates. After the call, the <i>pvarChild</i> parameter points to a <b>VARIANT</b> structure that describes the hit test's result. If the call succeeds, the <b>VARIANT</b> structure's <b>ppdispVal</b> member is the address of the child object's <b>IDispatch</b> interface. </p>
<p>
If multiple child objects overlap at a specified point, the <b>accHitTest</b> method retrieves the one that visually appears to occupy the space. However, <b>accHitTest</b> does not account for overlapping windows or clipping performed by the parent. Therefore, if a window covers a child object, hit testing the covered point will successfully retrieve the child object, even though it isn't actually visible at that point. </p>
<p>
Additionally, the <b>accHitTest</b> method retrieves information about the topmost child object under the specified point. For example, if a child object displays a child of its own at the given point, only the top-level child object's information is returned. </p>
<p>
Like any on-screen graphic, accessible objects can vary in shape. This isn't usually a problem, since most on-screen entities are well represented by rectangles. Rectangles can accurately describe most applications and their components: the application window, the menu, dialog boxes, buttons, scroll bars, and other common controls. As a result, accessible objects currently provide location information in terms of rectangles (by way of the <b>IAccessible::accLocation</b> method). If an object isn't shaped like a rectangle, the <b>accLocation</b> method provides the rectangle that contains the object. </p>
<p>
Occasionally, rectangles aren't accurate enough. Accessible objects support the <b>IAccessible::accHitTest</b> method to provide access to clients on a pixel-by-pixel basis. This comes in handy when your application is tracking the location of the mouse pointer to gather information. The following illustration shows the relationship between an eccentric object's region and its bounding rectangle. </p>
<p>
<img src="images/region.gif" border=0></p>
<p>&nbsp;</p></body>
</HTML>
