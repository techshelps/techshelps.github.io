<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Appendix E - User Interface Controls</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_msaa_appendix_e_user_interface_controls"></a>Appendix E - User Interface Controls</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
These controls are provided by the system and COMCTL32 and are used throughout Windows 95 and applications written for it. </p>
<p>
<b>Note</b>  This refers only to controls exposed by COMCTL32.DLL, not 16-bit controls. At present Active Accessibility does not support the 16-bit versions (mainly status bar and toolbar). Also, keep in mind that edits, statics, titlebars, buttons, (may be others) have a limit of 4096 bytes of text they will return.</p>
<p>
<b>Animation</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events </li>
</ul>
<p>
<b>Button</b> 
<ul>
<li>
Properties and Methods <p>
DefaultAction is "Press" 
<p>
DoDefaultAction presses the button as if a user clicked on it. 
</li>
<li>
Events </li>
</ul>
<p>
<b>Check Boxes</b> 
<ul>
<li>
Properties and Methods <p>
DefaultAction is "Check" if unchecked, "Uncheck" if checked 
<p>
DoDefaultAction checks or unchecks the check box 
</li>
</ul>
<p>
<b>ComboBox</b> 
<ul>
<li>
Properties and Methods <p>
DefaultAction is "Drop down" if combo list is hidden, or "Pop up" if shown. 
<p>
DoDefaultAction shows or hides the list 
</li>
<li>
Events </li>
</ul>
<p>
<b>Edit</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events </li>
</ul>
<p>
<b>Header</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events <ul>
<li>
CREATE when header is added </li>
<li>
DESTROY when header is removed </li>
<li>
REORDER when the columns are rearranged </li>
</ul>
</li>
</ul>
<p>
<b>HotKey</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events <ul>
<li>
VALUECHANGE when the hot key changes </li>
</ul>
</li>
</ul>
<p>
<b>ListBox</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events </li>
</ul>
<p>
<b>ListView</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events <ul>
<li>
CREATE when item added </li>
<li>
DESTROY when item deleted </li>
<li>
FOCUS when the item with the caret changes </li>
<li>
NAMECHANGE when the name of an item is changed </li>
<li>
SELECTION when one item is selected </li>
<li>
SELECTIONADD for multiselect list view controls (when another item is added to the selection). </li>
<li>
SELECTIONREMOVE for multiselect list views when an item is deselected </li>
</ul>
<p>
<b>Notes</b> 
<ul>
<li>
OWNERDRAW list views might not give you back item text. </li>
<li>
On the CREATE for some list view items, you might get no text (but it will show up later), because of the LPSTR_CALLBACK option, there's no way to know when this happens. </li>
<li>
Most applications add in toolbar buttons groups at a time, in which case you'll see REORDER instead of a ton of creates. But VB and MFC do it one at a time, so we do generate a CREATE in that case. </li>
</ul>
</li>
</ul>
<p>
<b>ProgressBar</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events <ul>
<li>
VALUECHANGE when the position changes </li>
</ul>
</li>
</ul>
<p>
<b>Radio Buttons</b> 
<ul>
<li>
Properties and Methods <p>
DoDefaultAction selects the radio button, deselecting the others in a group. 
</li>
</ul>
<p>
<b>Note</b></p>
<p>
This works only when the radio buttons have the BS_AUTORADIOBUTTON style set.</p>
<p>
<b>RichEdit</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events </li>
</ul>
<p>
<b>ScrollBar</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events </li>
</ul>
<p>
<b>Slider</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Event <ul>
<li>
VALUECHANGE when the thumb moves </li>
</ul>
</li>
</ul>
<p>
<b>Spin Buttons</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events <ul>
<li>
STATECHANGE when a button is pressed, released </li>
<li>
VALUECHANGE when the position in the buddy changes </li>
</ul>
</li>
</ul>
<p>
<b>Static</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events </li>
</ul>
<p>
<b>StatusBar</b> 
<ul>
<li>
Events <ul>
<li>
NAMECHANGE when the contents of a status bar slot change </li>
</ul>
</li>
</ul>
<p>
<b>TabControl</b> 
<ul>
<li>
Properties and Methods <p>
DefaultAction is "Switch" 
<p>
DoDefaultAction selects the tab 
</li>
<li>
Events <ul>
<li>
CREATE when a tab is added to the list </li>
<li>
DESTROY when a tab is removed from the list </li>
<li>
FOCUS/SELECTION when the currently active tab changes </li>
</ul>
</li>
</ul>
<p>
<b>Toolbar</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events <ul>
<li>
CREATE or REORDER when one or several buttons are added </li>
<li>
DESTROY when a button is removed </li>
<li>
STATECHANGE for the buttons when pressed, released, enabled, disabled </li>
</ul>
<p>
Please Note : the problem with toolbars is that they aren't supposed to have children who are windows. They don't even support it very well as a hack. What someone designing an app with a toolbar has to do if they want a real window on it is to scoot all the buttons (the "real" children of the toolbar) over to the right, and then place their window. So Active Accessibility does a similar hack. When you are doing Next or Previous, it checks if you started at a child that has an HWNDID. If so, it gives back the first child (if doing NEXT) or the toolbar itself (if PREVIOUS). 
<p>
Also, if you start at the toolbar itself and are going next, it will check if there is a child window, and if so, return an IDispatch to the window in the VARIANT. If you start at the first "real" child and go previous, it will do the same thing - check for a child window and return an IDispatch to it if it is there. 
<p>
This is a major limitation in that this will only work for toolbars that have 0 or 1 children that are windows themselves. 
</li>
</ul>
<p>
<b>ToolTips</b> 
<ul>
<li>
Properties and Methods <p>
Name 
<p>
Role 
<p>
Value 
</li>
<li>
Events </li>
</ul>
<p>
<b>TreeView</b> 
<ul>
<li>
Properties and Methods </li>
<li>
Events <ul>
<li>
CREATE when item added </li>
<li>
DESTROY when item deleted </li>
<li>
FOCUS when caret changes </li>
<li>
NAMECHANGE when item renamed </li>
<li>
SELECTION when selected item changes </li>
<li>
STATECHANGE when item expanded or collapsed </li>
</ul>
</li>
<li>
<b>Notes</b> <ul>
<li>
The role of the tree view is ROLE_SYSTEM_OUTLINE; the items' roles are ROLE_SYSTEM_OUTLINEITEM. </li>
<li>
All items, regardless of their position in the hierarchy, are peer children of the tree view </li>
<li>
The value of an item is the "indent level". So, for example, the value of the "Desktop" item would be zero because it is the root. </li>
<li>
A tool can use the value to figure out which items are logically grouped under another. If you have an item, ask for the next one. If that next one's value is &lt;= the value of the start item, you are done. If the item has a value of one greater than the start, it must be a logical item directly underneath. In other words, the value is the indent level. </li>
<li>
Items that are expandable and collapsible are the only ones with default action. If an item is expanded, the default action is to collapse it. If an item is collapsed, the default action is to expand it </li>
</ul>
</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
