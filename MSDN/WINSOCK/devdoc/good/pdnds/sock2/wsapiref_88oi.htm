<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>recvfrom</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_recvfrom_2"></a>recvfrom</h1>
<p>
The Windows Sockets <b>recvfrom</b> function receives a datagram and stores the source address.</p>
<pre><code><b>int recvfrom (
  SOCKET</b><i> s</i><b>,                   </b>
<b>  char FAR*</b><i> buf</i><b>,              </b>
<b>  int</b><i> len</i><b>,                    </b>
<b>  int</b><i> flags</i><b>,                  </b>
<b>  struct sockaddr FAR*</b><i> from</i><b>,  </b>
<b>  int FAR*</b><i> fromlen            </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying a bound socket.</dd>
<dt>
<i>buf</i></dt>
<dd>
[out] A buffer for the incoming data.</dd>
<dt>
<i>len</i></dt>
<dd>
[in] The length of <i>buf</i>.</dd>
<dt>
<i>flags</i></dt>
<dd>
[in] An indicator specifying the way in which the call is made.</dd>
<dt>
<i>from</i></dt>
<dd>
[out] An optional pointer to a buffer that will hold the source address upon return.</dd>
<dt>
<i>fromlen</i></dt>
<dd>
[in/out] An optional pointer to the size of the <i>from</i> buffer.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>recvfrom</b> function reads incoming data on both connected and unconnected sockets and captures the address from which the data was sent. The socket must not be connected. The local address of the socket must be known. For server applications, this is usually done explicitly through <a href="wsapiref_6vzm.htm"><b>bind</b></a>. Explicit binding is discouraged for client applications. For client applications using this function, the socket can become bound implicitly to a local address through<b> <a href="wsapiref_4sqa.htm">sendto</a>, <a href="wsapiref_752q.htm">WSASendTo</a></b>, or <a href="wsapiref_7dv6.htm"><b>WSAJoinLeaf</b></a>.</p>
<p>
For stream oriented sockets such as those of type SOCK_STREAM, a call to <b>recvfrom</b> returns as much information as is currently available—up to the size of the buffer supplied. If the socket has been configured for in-line reception of out-of-band data (socket option SO_OOBINLINE) and out-of-band data is yet unread, only out-of-band data will be returned. The application can use the <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a> or <a href="wsapiref_6ik2.htm"><b>WSAIoctl</b></a> SIOCATMARK command to determine whether any more out-of-band data remains to be read. The <i>from</i> and <i>fromlen</i> parameters are ignored for connection-oriented sockets.</p>
<p>
For message-oriented sockets, data is extracted from the first enqueued message, up to the size of the buffer supplied. If the datagram or message is larger than the buffer supplied, the buffer is filled with the first part of the datagram, and <b>recvfrom</b> generates the error WSAEMSGSIZE. For unreliable protocols (for example, UDP) the excess data is lost.</p>
<p>
If the <i>from</i> paramter is nonzero and the socket is not connection oriented, (type SOCK_DGRAM for example), the network address of the peer that sent the data is copied to the corresponding <a href="strucetc_0d82.htm"><b>SOCKADDR</b></a> structure. The value pointed to by <i>fromlen</i> is initialized to the size of this structure and is modified, on return, to indicate the actual size of the address stored in the <b>SOCKADDR</b> structure.</p>
<p>
If no incoming data is available at the socket, the <b>recvfrom</b> function blocks and waits for data to arrive according to the blocking rules defined for <a href="wsapiref_4z1u.htm"><b>WSARecv</b></a> with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value of SOCKET_ERROR is returned with the error code set to <a href="errors_0oaa.htm#_win32_wsaewouldblock_2">WSAEWOULDBLOCK</a>. The <a href="wsapiref_1ab6.htm"><b>select</b></a>, <a href="wsapiref_6jn6.htm"><b>WSAAsyncSelect</b></a>, or <a href="wsapiref_34aa.htm"><b>WSAEventSelect</b></a> can be used to determine when more data arrives.</p>
<p>
If the socket is connection oriented and the remote side has shut down the connection gracefully, the call to <b>recvfrom</b> will complete immediately with zero bytes received. If the connection has been reset <b>recvfrom</b> will fail with the error <a href="errors_0oaa.htm#_win32_wsaeconnreset_2">WSAECONNRESET</a>.</p>
<p>
The <i>flags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the <i>flags</i> parameter. The latter is constructed by or-ing the following values:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=28%>Value</th>
<th align=left width=72%>Meaning</th>
</tr>
<tr valign=top>
<td width=28%>MSG_PEEK</td>
<td width=72%>Peek at the incoming data. The data is copied into the buffer but is not removed from the input queue, and the function returns the number of bytes currently pending to receive.</td>
</tr>
<tr valign=top>
<td width=28%>MSG_OOB</td>
<td width=72%>Process out-of-band data. (See section <a href="../../../live/pdnds/sockspi/wsanxref_9fqq.htm">DECnet Out-Of-band data</a> for a discussion of this topic.)</td>
</tr>
</table><br>
<h4>Return Values</h4>
<p>
If no error occurs, <b>recvfrom</b> returns the number of bytes received. If the connection has been gracefully closed, the return value is zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=35%>WSANOTINITIALISED</td>
<td width=65%>A successful <a href="wsapiref_1v8y.htm"><b>WSAStartup</b></a> must occur before using this function.</td>
</tr>
<tr valign=top>
<td width=35%>WSAENETDOWN</td>
<td width=65%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEFAULT</td>
<td width=65%>The <i>buf </i>or <i>from </i>parameters are not part of the user address space, or the <i>fromlen </i>parameter is too small to accommodate the peer address.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEINTR</td>
<td width=65%>The (blocking) call was canceled through <a href="wsapiref_704y.htm"><b>WSACancelBlockingCall</b></a>.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEINPROGRESS</td>
<td width=65%>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEINVAL</td>
<td width=65%>The socket has not been bound with <a href="wsapiref_6vzm.htm"><b>bind</b></a>, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled, or (for byte stream-style sockets only) <i>len</i> was zero or negative.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEISCONN</td>
<td width=65%>The socket is connected. This function is not permitted with a connected socket, whether the socket is connection-oriented or connectionless.</td>
</tr>
<tr valign=top>
<td width=35%>WSAENETRESET</td>
<td width=65%>The connection has been broken due to the "keep-alive" activity detecting a failure while the operation was in progress.</td>
</tr>
<tr valign=top>
<td width=35%>WSAENOTSOCK</td>
<td width=65%>The descriptor is not a socket.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEOPNOTSUPP</td>
<td width=65%>MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, out-of-band data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only send operations.</td>
</tr>
<tr valign=top>
<td width=35%>WSAESHUTDOWN</td>
<td width=65%>The socket has been shut down; it is not possible to <b>recvfrom</b> on a socket after <a href="wsapiref_60z6.htm"><b>shutdown</b></a> has been invoked with <i>how</i> set to SD_RECEIVE or SD_BOTH.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEWOULDBLOCK</td>
<td width=65%>The socket is marked as nonblocking and the <b>recvfrom</b> operation would block.</td>
</tr>
<tr valign=top>
<td width=35%>WSAEMSGSIZE</td>
<td width=65%>The message was too large to fit into the specified buffer and was truncated.</td>
</tr>
<tr valign=top>
<td width=35%>WSAETIMEDOUT</td>
<td width=65%>The connection has been dropped, because of a network failure or because the system on the other end went down without notice.</td>
</tr>
<tr valign=top>
<td width=35%>WSAECONNRESET</td>
<td width=65%>The virtual circuit was reset by the remote side executing a "hard" or "abortive" close. The application should close the socket as it is no longer usable. On a UDP datagram socket this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Use version 1.0 and later.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_2i9e.htm"><b>recv</b></a>, <a href="wsapiref_6quq.htm"><b>send</b></a>, <a href="wsapiref_2qr6.htm"><b>socket</b></a>, <a href="wsapiref_6jn6.htm"><b>WSAAsyncSelect</b></a>, <a href="wsapiref_34aa.htm"><b>WSAEventSelect</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
