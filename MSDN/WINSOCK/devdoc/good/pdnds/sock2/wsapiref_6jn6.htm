<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSAAsyncSelect</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsaasyncselect_2"></a>WSAAsyncSelect</h1>
<p>
The Windows Sockets <b>WSAAsyncSelect</b> function requests Windows message-based notification of network events for a socket.</p>
<pre><code><b>int WSAAsyncSelect (
  SOCKET</b><i> s</i><b>,           </b>
<b>  HWND</b><i> hWnd</i><b>,          </b>
<b>  unsigned int</b><i> wMsg</i><b>,  </b>
<b>  long</b><i> lEvent         </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying the socket for which event notification is required.</dd>
<dt>
<i>hWnd</i></dt>
<dd>
[in] A handle identifying the window that will receive a message when a network event occurs.</dd>
<dt>
<i>wMsg</i></dt>
<dd>
[in] The message to be received when a network event occurs.</dd>
<dt>
<i>lEvent</i></dt>
<dd>
[in] A bitmask that specifies a combination of network events in which the application is interested.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>WSAAsyncSelect</b> function is used to request that WS2_32.DLL should send a message to the window <i>hWnd</i> whenever it detects any of the network events specified by the <i>lEvent</i> parameter. The message that should be sent is specified by the <i>wMsg</i> parameter. The socket for which notification is required is identified by the <i>s </i>parameter.</p>
<p>
The <b>WSAAsyncSelect</b> function automatically sets socket <i>s</i> to nonblocking mode, regardless of the value of <i>lEvent</i>. See the <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a> functions for information on how to set the nonblocking socket back to blocking mode.</p>
<p>
The <i>lEvent</i> parameter is constructed by using the bitwise OR operator with any of the values specified in the following list.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%>Value</th>
<th align=left width=65%>Meaning</th>
</tr>
<tr valign=top>
<td width=35%>FD_READ</td>
<td width=65%>Want to receive notification of readiness for reading</td>
</tr>
<tr valign=top>
<td width=35%>FD_WRITE</td>
<td width=65%>Want to receive notification of readiness for writing</td>
</tr>
<tr valign=top>
<td width=35%>FD_OOB</td>
<td width=65%>Want to receive notification of the arrival of out-of-band data</td>
</tr>
<tr valign=top>
<td width=35%>FD_ACCEPT</td>
<td width=65%>Want to receive notification of incoming connections</td>
</tr>
<tr valign=top>
<td width=35%>FD_CONNECT</td>
<td width=65%>Want to receive notification of completed connection or multi-point <i>join</i> operation</td>
</tr>
<tr valign=top>
<td width=35%>FD_CLOSE</td>
<td width=65%>Want to receive notification of socket closure</td>
</tr>
<tr valign=top>
<td width=35%>FD_QOS</td>
<td width=65%>Want to receive notification of socket Quality of Service (QOS) changes</td>
</tr>
<tr valign=top>
<td width=35%>FD_GROUP_QOS</td>
<td width=65%>Want to receive notification of socket group Quality of Service (QOS) changes (reserved for future use with socket groups) </td>
</tr>
<tr valign=top>
<td width=35%>FD_ROUTING<br>
_INTERFACE_CHANGE</td>
<td width=65%>Want to receive notification of routing interface changes for the specified destination(s)</td>
</tr>
<tr valign=top>
<td width=35%>FD_ADDRESS_LIST<br>
_CHANGE</td>
<td width=65%>Want to receive notification of local address list changes for the socket's protocol family</td>
</tr>
</table><br>
<p>
Issuing a <b>WSAAsyncSelect</b> for a socket cancels any previous <b>WSAAsyncSelect</b> or <a href="wsapiref_34aa.htm"><b>WSAEventSelect</b></a> for the same socket. For example, to receive notification for both reading and writing, the application must call <b>WSAAsyncSelect</b> with both FD_READ and FD_WRITE, as follows:</p>
<pre><code>rc = WSAAsyncSelect(s, hWnd, wMsg, FD_READ|FD_WRITE);
 </code></pre>
<p>
It is not possible to specify different messages for different events. The following code will <i>not</i> work; the second call will cancel the effects of the first, and only FD_WRITE events will be reported with message wMsg2:</p>
<pre><code>rc = WSAAsyncSelect(s, hWnd, wMsg1, FD_READ);
rc = WSAAsyncSelect(s, hWnd, wMsg2, FD_WRITE);
 </code></pre>
<p>
To cancel all notification indicating that Windows Sockets should send no further messages related to network events on the socket, <i>lEvent</i> is set to zero.</p>
<pre><code>rc = WSAAsyncSelect(s, hWnd, 0, 0);
 </code></pre>
<p>
Although <b>WSAAsyncSelect</b> immediately disables event message posting for the socket in this instance, it is possible that messages could be waiting in the application's message queue. Therefore, the application must be prepared to receive network event messages even after cancellation. Closing a socket with <a href="wsapiref_714i.htm"><b>closesocket</b></a> also cancels <b>WSAAsyncSelect</b> message sending, but the same caveat about messages in the queue still applies.</p>
<p>
The socket created by the <a href="wsapiref_13aq.htm"><b>accept</b></a> function has the same properties as the listening socket used to accept it. Consequently, <b>WSAAsyncSelect</b> events set for the listening socket also apply to the accepted socket. For example, if a listening socket has <b>WSAAsyncSelect</b> events FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE events with the same <i>wMsg</i> value used for messages. If a different <i>wMsg</i> or events are desired, the application should call <b>WSAAsyncSelect</b>, passing the accepted socket and the desired new information.</p>
<p>
When one of the nominated network events occurs on the specified socket <i>s</i>, the application's window <i>hWnd</i> receives message <i>wMsg</i>. The <i>wParam</i> parameter identifies the socket on which a network event has occurred. The low word of <i>lParam</i> specifies the network event that has occurred. The high word of <i>lParam</i> contains any error code. The error code be any error as defined in WINSOCK2.H.</p>
<p>
<b>Note</b>  Upon receipt of an event notification message, the <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a> function cannot be used to check the error value because the error value returned can differ from the value in the high word of <i>lParam</i>.</p>
<p>
The error and event codes can be extracted from the <i>lParam</i> using the macros WSAGETSELECTERROR and WSAGETSELECTEVENT, defined in WINSOCK2.H as:</p>
<pre><code>#define WSAGETSELECTERROR(lParam)       HIWORD(lParam)
#define WSAGETSELECTEVENT(lParam)       LOWORD(lParam)
 </code></pre>
<p>
The use of these macros will maximize the portability of the source code for the application.</p>
<p>
The possible network event codes that can be returned are as follows:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%>Value</th>
<th align=left width=65%>Meaning</th>
</tr>
<tr valign=top>
<td width=35%>FD_READ</td>
<td width=65%>Socket <i>s</i> ready for reading</td>
</tr>
<tr valign=top>
<td width=35%>FD_WRITE</td>
<td width=65%>Socket <i>s</i> ready for writing</td>
</tr>
<tr valign=top>
<td width=35%>FD_OOB</td>
<td width=65%>Out-of-band data ready for reading on socket s</td>
</tr>
<tr valign=top>
<td width=35%>FD_ACCEPT</td>
<td width=65%>Socket <i>s</i> ready for accepting a new incoming connection</td>
</tr>
<tr valign=top>
<td width=35%>FD_CONNECT</td>
<td width=65%>Connection or multi-point <i>join</i> operation initiated on socket <i>s</i> completed</td>
</tr>
<tr valign=top>
<td width=35%>FD_CLOSE</td>
<td width=65%>Connection identified by socket <i>s</i> has been closed</td>
</tr>
<tr valign=top>
<td width=35%>FD_QOS</td>
<td width=65%>Quality of Service associated with socket <i>s</i> has changed</td>
</tr>
<tr valign=top>
<td width=35%>FD_GROUP_QOS</td>
<td width=65%>Quality of Service associated with the socket group to which <i>s</i> belongs has changed (reserved for future use with socket groups)</td>
</tr>
<tr valign=top>
<td width=35%>FD_ROUTING<br>
_INTERFACE_CHANGE</td>
<td width=65%>Local interface that should be used to send to the specified destination has changed</td>
</tr>
<tr valign=top>
<td width=35%>FD_ADDRESS_LIST<br>
_CHANGE</td>
<td width=65%>The list of addresses of the socket's protocol family to which the application client can bind has changed</td>
</tr>
</table><br>
<p>
Although <b>WSAAsyncSelect</b> can be called with interest in multiple events, the application window will receive a single message for each network event.</p>
<p>
As in the case of the <b>select</b> function, <b>WSAAsyncSelect</b> will frequently be used to determine when a data transfer operation (<b>send</b> or <b>recv</b>) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for the possibility that it can receive a message and issue a Windows Sockets 2 call that returns WSAEWOULDBLOCK immediately. For example, the following sequence of events is possible:
<ol>
<li>
data arrives on socket <b>s</b>; Windows Sockets 2 posts <b>WSAAsyncSelect</b> message</li>
<li>
application processes some other message</li>
<li>
while processing, application issues an <b>ioctlsocket(s, FIONREAD...)</b> and notices that there is data ready to be read</li>
<li>
application issues a <b>recv(s,...)</b> to read the data</li>
<li>
application loops to process next message, eventually reaching the <b>WSAAsyncSelect</b> message indicating that data is ready to read</li>
<li>
application issues <b>recv(s,...)</b>, which fails with the error WSAEWOULDBLOCK.</li>
</ol>
<p>
Other sequences are possible.</p>
<p>
The WS2_32.DLL will <i>not</i> continually flood an application with messages for a particular network event. Having successfully posted notification of a particular event to an application window, no further message(s) for that network event will be posted to the application window until the application makes the function call that implicitly re-enables notification of that network event.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%>Event</th>
<th align=left width=65%>Re-enabling function</th>
</tr>
<tr valign=top>
<td width=35%>FD_READ</td>
<td width=65%><b>recv</b>, <b>recvfrom</b>, <b>WSARecv</b>, or <b>WSARecvFrom</b></td>
</tr>
<tr valign=top>
<td width=35%>FD_WRITE</td>
<td width=65%><b>send</b>, <b>sendto</b>, <b>WSASend</b>, or <b>WSASendTo</b></td>
</tr>
<tr valign=top>
<td width=35%>FD_OOB</td>
<td width=65%><b>recv</b>, <b>recvfrom</b>, <b>WSARecv</b>, or <b>WSARecvFrom</b></td>
</tr>
<tr valign=top>
<td width=35%>FD_ACCEPT</td>
<td width=65%><b>accept</b> or <b>WSAAccept</b> unless the error code is WSATRY_AGAIN indicating that the condition function returned CF_DEFER</td>
</tr>
<tr valign=top>
<td width=35%>FD_CONNECT</td>
<td width=65%>NONE</td>
</tr>
<tr valign=top>
<td width=35%>FD_CLOSE</td>
<td width=65%>NONE</td>
</tr>
<tr valign=top>
<td width=35%>FD_QOS</td>
<td width=65%><b>WSAIoctl</b> with command SIO_GET_QOS</td>
</tr>
<tr valign=top>
<td width=35%>FD_GROUP_QOS</td>
<td width=65%><b>WSAIoctl</b> with command SIO_GET_GROUP_QOS (reserved for future use with socket groups)</td>
</tr>
<tr valign=top>
<td width=35%>FD_ROUTING<br>
_INTERFACE_CHANGE</td>
<td width=65%><b>WSAIoctl</b> with command SIO_ROUTING_INTERFACE_CHANGE</td>
</tr>
<tr valign=top>
<td width=35%>FD_ADDRESS_LIST<br>
_CHANGE</td>
<td width=65%><b>WSAIoctl</b> with command SIO_ADDRESS_LIST_CHANGE</td>
</tr>
</table><br>
<p>
Any call to the re-enabling routine, even one that fails, results in re-enabling of message posting for the relevant event.</p>
<p>
For FD_READ, FD_OOB, and FD_ACCEPT events, message posting is "level-triggered." This means that if the re-enabling routine is called and the relevant condition is still met after the call, a <b>WSAAsyncSelect</b> message is posted to the application. This allows an application to be event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following sequence:
<ol>
<li>
Network transport stack receives 100 bytes of data on socket <b>s</b> and causes Windows Sockets 2 to post an FD_READ message.</li>
<li>
The application issues <b>recv( s, buffptr, 50, 0)</b> to read 50 bytes.</li>
<li>
Another FD_READ message is posted since there is still data to be read.</li>
</ol>
<p>
With these semantics, an application need not read all available data in response to an FD_READ message—a single <b>recv</b> in response to each FD_READ message is appropriate. If an application issues multiple <b>recv</b> calls in response to a single FD_READ, it can receive multiple FD_READ messages. Such an application can need to disable FD_READ messages before starting the <b>recv</b> calls by calling <b>WSAAsyncSelect</b> with the FD_READ event not set.</p>
<p>
The FD_QOS and FD_GROUP_QOS events are considered "edge triggered." A message will be posted exactly once when a quality of service change occurs. Further messages will <i>not</i> be forthcoming until either the provider detects a further change in quality of service or the application renegotiates the quality of service for the socket.</p>
<p>
The FD_ROUTING_INTERFACE_CHANGE message is posted when the local interface that should be used to reach the destination specified in <b>WSAIoctl</b> with SIO_ROUTING_INTERFACE_CHANGE changes <i>after</i> such IOCTL has been issued.</p>
<p>
The FD_ADDRESS_LIST_CHANGE message is posted when the list of addresses to which the application can bind changes <i>after</i> <b>WSAIoctl</b> with SIO_ADDRESS_LIST_CHANGE has been issued.</p>
<p>
If any event has already happened when the application calls <b>WSAAsyncSelect</b> or when the re-enabling function is called, then a message is posted as appropriate. For example, consider the following sequence:
<ol>
<li>
an application calls <b>listen</b>,</li>
<li>
a connect request is received but not yet accepted,</li>
<li>
the application calls <b>WSAAsyncSelect</b> specifying that it wants to receive FD_ACCEPT messages for the socket. Due to the persistence of events, Windows Sockets 2 posts an FD_ACCEPT message immediately.</li>
</ol>
<p>
The FD_WRITE event is handled slightly differently. An FD_WRITE message is posted when a socket is first connected with <b>connect/WSAConnect</b> (after FD_CONNECT, if also registered) or accepted with <b>accept/WSAAccept</b>, and then after a send operation fails with WSAEWOULDBLOCK and buffer space becomes available. Therefore, an application can assume that sends are possible starting from the first FD_WRITE message and lasting until a send returns WSAEWOULDBLOCK. After such a failure the application will be notified that sends are again possible with an FD_WRITE message.</p>
<p>
The FD_OOB event is used only when a socket is configured to receive out-of-band data separately. (See section <a href="../../../live/pdnds/sockspi/wsanxref_9fqq.htm">DECnet Out-Of-band data</a> for a discussion of this topic.) If the socket is configured to receive out-of-band data in-line, the out-of-band (expedited) data is treated as normal data and the application should register an interest in, and will receive, FD_READ events, not FD_OOB events. An application can set or inspect the way in which out-of-band data is to be handled by using setsockopt or getsockopt for the SO_OOBINLINE option.</p>
<p>
The error code in an FD_CLOSE message indicates whether the socket close was graceful or abortive. If the error code is zero, then the close was graceful; if the error code is WSAECONNRESET, then the socket's virtual circuit was reset. This only applies to connection-oriented sockets such as SOCK_STREAM.</p>
<p>
The FD_CLOSE message is posted when a close indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the FD_CLOSE is posted when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the remote end performing a <b>shutdown</b> on the send side or a <b>closesocket</b>. FD_CLOSE should only be posted after all data is read from a socket, but an application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing data.</p>
<p>
Please note your application will receive ONLY an FD_CLOSE message to indicate closure of a virtual circuit, and only when all the received data has been read if this is a graceful close. It will <i>not</i> receive an FD_READ message to indicate this condition.</p>
<p>
The FD_QOS or FD_GROUP_QOS message is posted when any field in the flow specification associated with socket <i>s</i> or the socket group that <i>s</i> belongs to has changed, respectively. Applications should use <b>WSAIoctl</b> with command SIO_GET_QOS or SIO_GET_GROUP_QOS to get the current QOS for socket <i>s</i> or for the socket group <i>s</i> belongs to, respectively.</p>
<p>
The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered "edge triggered" as well. A message will be posted exactly once when a change occurs after the application has request the notification by issuing <b>WSAIoctl</b> with SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE correspondingly. Further messages will not be forthcoming until the application reissues the IOCTL AND another change is detected since the IOCTL has been issued.</p>
<p>
Here is a summary of events and conditions for each asynchronous notification message:
<ul>
<li>
<b>FD_READ</b>:<ol>
<li>
when <b>WSAAsyncSelect</b> called, if there is data currently available to receive, </li>
<li>
when data arrives, if FD_READ not already posted, </li>
<li>
after <b>recv</b> or <b>recvfrom</b> called (with or without MSG_PEEK), if data is still available to receive.<p>
<b>Note</b>  when <b>setsockopt</b> SO_OOBINLINE is enabled, "data" includes both normal data and out-of-band (OOB) data in the instances noted above.
</li>
</ol>
</li>
<li>
<b>FD_WRITE</b>:<ol>
<li>
when <b>WSAAsyncSelect</b> called, if a <b>send</b> or <b>sendto</b> is possible</li>
<li>
after <b>connect</b> or <b>accept</b> called, when connection established</li>
<li>
after <b>send</b> or <b>sendto</b> fail with WSAEWOULDBLOCK, when <b>send</b> or <b>sendto</b> are likely to succeed, </li>
<li>
after <b>bind</b> on a connectionless socket. FD_WRITE may or may not occur at this time (implementation-dependent). In any case, a connectionless socket is always writeable immediately after a <b>bind</b> operation.</li>
</ol>
</li>
<li>
<b>FD_OOB</b>: Only valid when <b>setsockopt</b> SO_OOBINLINE is disabled (default).<ol>
<li>
when <b>WSAAsyncSelect</b> called, if there is OOB data currently available to receive with the MSG_OOB flag, </li>
<li>
when OOB data arrives, if FD_OOB not already posted, </li>
<li>
after <b>recv</b> or <b>recvfrom</b> called with <i>or without</i> MSG_OOB flag, if OOB data is still available to receive.</li>
</ol>
</li>
<li>
<b>FD_ACCEPT</b>:<ol>
<li>
when <b>WSAAsyncSelect</b> called, if there is currently a connection request available to accept, </li>
<li>
when a connection request arrives, if FD_ACCEPT not already posted, </li>
<li>
after <b>accept</b> called, if there is another connection request available to accept.</li>
</ol>
</li>
<li>
<b>FD_CONNECT</b>:<ol>
<li>
when <b>WSAAsyncSelect</b> called, if there is currently a connection established, </li>
<li>
after <b>connect</b> called, when connection is established (even when <b>connect</b> succeeds immediately, as is typical with a datagram socket),</li>
<li>
after calling <a href="wsapiref_7dv6.htm"><b>WSAJoinLeaf</b></a>, when join operation completes,</li>
<li>
after <a href="wsapiref_8m7m.htm"><b>connect</b></a>, <a href="wsapiref_8kc2.htm"><b>WSAConnect</b></a>, or <b>WSAJoinLeaf</b> was called with a nonblocking, connection-oriented socket. The initial operation returned with a specific error of WSAEWOULDBLOCK, but the network operation went ahead. Whether the operation eventually succeeds or not, when the outcome has been determined, FD_CONNECT happens. The client should check the error code to determine whether the outcome was successful or failed.</li>
</ol>
</li>
<li>
<b>FD_CLOSE</b>: Only valid on connection-oriented sockets (for example, SOCK_STREAM) <ol>
<li>
when <b>WSAAsyncSelect</b> called, if socket connection has been closed,</li>
<li>
after remote system initiated graceful close, when no data currently available to receive (note: if data has been received and is waiting to be read when the remote system initiates a graceful close, the FD_CLOSE is not delivered until all pending data has been read),</li>
<li>
after local system initiates graceful close with <b>shutdown</b> and remote system has responded with "End of Data" notification (for example, TCP FIN), when no data currently available to receive, </li>
<li>
when remote system terminates connection (for example, sent TCP RST), and <i>lParam</i> will contain WSAECONNRESET error value.<p>
<b>Note</b>  FD_CLOSE is <i>not</i> posted after <b>closesocket</b> is called.
</li>
</ol>
</li>
<li>
<b>FD_QOS</b>:<ol>
<li>
when <b>WSAAsyncSelect</b> called, if the quality of service associated with the socket has been changed, </li>
<li>
after <b>WSAIoctl</b> with SIO_GET_QOS called, when the quality of service is changed.</li>
</ol>
</li>
<li>
<b>FD_GROUP_QOS</b> (Reserved for future use with socket groups):<ol>
<li>
when <b>WSAAsyncSelect</b> called, if the group quality of service associated with the socket has been changed, </li>
<li>
after <b>WSAIoctl</b> with SIO_GET_GROUP_QOS called, when the group quality of service is changed.</li>
</ol>
</li>
<li>
FD_ROUTING_INTERFACE_CHANGE: <ol>
<li>
after <b>WSAIoctl</b> with SIO_ROUTING_INTERFACE_CHANGE called, when the local interface that should be used to reach the destination specified in the IOCTL changes.</li>
</ol>
</li>
<li>
FD_ADDRESS_LIST_CHANGE<ol>
<li>
after <b>WSAIoctl</b> with SIO_ADDRESS_LIST_CHANGE called, when the list of local addresses to which the application can bind changes.</li>
</ol>
</li>
</ul>
<h4>Return Values</h4>
<p>
If the <b>WSAAsyncSelect</b> function succeeds, the return value is zero provided the application's declaration of interest in the network event set was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=41%>WSANOTINITIALISED</td>
<td width=59%>A successful <b>WSAStartup</b> must occur before using this function.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINVAL</td>
<td width=59%>Indicates that one of the specified parameters was invalid such as the window handle not referring to an existing window, or the specified socket is in an invalid state.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINPROGRESS</td>
<td width=59%>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENOTSOCK</td>
<td width=59%>The descriptor is not a socket.</td>
</tr>
</table><br>
<p>
Additional error codes can be set when an application window receives a message. This error code is extracted from the <i>lParam</i> in the reply message using the WSAGETSELECTERROR macro. Possible error codes for each network event are:</p>
<p>
<b>Event: FD_CONNECT</b></p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=41%>Error Code</th>
<th align=left width=59%>Meaning</th>
</tr>
<tr valign=top>
<td width=41%>WSAEAFNOSUPPORT</td>
<td width=59%>Addresses in the specified family cannot be used with this socket.</td>
</tr>
<tr valign=top>
<td width=41%>WSAECONNREFUSED</td>
<td width=59%>The attempt to connect was forcefully rejected.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENETUNREACH</td>
<td width=59%>The network cannot be reached from this host at this time.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEFAULT</td>
<td width=59%>The namelen parameter is incorrect.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINVAL</td>
<td width=59%>The socket is already bound to an address.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEISCONN</td>
<td width=59%>The socket is already connected.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEMFILE</td>
<td width=59%>No more file descriptors are available.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENOBUFS</td>
<td width=59%>No buffer space is available. The socket cannot be connected.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENOTCONN</td>
<td width=59%>The socket is not connected.</td>
</tr>
<tr valign=top>
<td width=41%>WSAETIMEDOUT</td>
<td width=59%>Attempt to connect timed out without establishing a connection.</td>
</tr>
</table><br>
<p>
<b>Event: FD_CLOSE</b></p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=41%>Error Code</th>
<th align=left width=59%>Meaning</th>
</tr>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=41%>WSAECONNRESET</td>
<td width=59%>The connection was reset by the remote side.</td>
</tr>
<tr valign=top>
<td width=41%>WSAECONNABORTED</td>
<td width=59%>The connection was terminated due to a time-out or other failure.</td>
</tr>
</table><br>
<p>
<b>Event: FD_READ</b></p>
<p>
<b>Event: FD_WRITE</b></p>
<p>
<b>Event: FD_OOB</b></p>
<p>
<b>Event: FD_ACCEPT</b></p>
<p>
<b>Event: FD_QOS</b></p>
<p>
<b>Event: FD_GROUP_QOS</b></p>
<p>
<b>Event: FD_ADDRESS_LIST_CHANGE</b></p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=41%>Error Code</th>
<th align=left width=59%>Meaning</th>
</tr>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
</table><br>
<p>
<b>Event: FD_ROUTING_INTERFACE_CHANGE</b></p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=41%>Error Code</th>
<th align=left width=59%>Meaning</th>
</tr>
<tr valign=top>
<td width=41%>WSAENETUNREACH</td>
<td width=59%>The specified destination is no longer reachable</td>
</tr>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_1ab6.htm"><b>select</b></a>, <a href="wsapiref_34aa.htm"><b>WSAEventSelect</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
