<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EnumProtocols</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_enumprotocols_2"></a>EnumProtocols</h1>
<p>
<b>Important</b>  The <b>EnumProtocols</b> function is a Microsoft-specific extension to the Windows Sockets 1.1 specification. This function is obsolete. For the convenience of Windows Sockets 1.1 developers, the reference material is below. </p>
<p>
The <a href="wsapiref_0f76.htm"><b>WSAEnumProtocols</b></a> function provides equivalent functionality in Windows Sockets 2.</p>
<p>
The <b>EnumProtocols</b> function obtains information about a specified set of network protocols that are active on a local host. </p>
<pre><code><b>INT EnumProtocols(
  LPINT</b><i> lpiProtocols</i><b>,       </b>// pointer to array of protocol 
                            // identifiers
<b>  LPVOID</b><i> lpProtocolBuffer</i><b>,  </b>// pointer to buffer to receive protocol 
                            // information
<b>  LPDWORD</b><i> lpdwBufferLength</i>  // pointer to variable that specifies 
                            // the size of the receiving buffer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>lpiProtocols</i></dt>
<dd>
Pointer to a null-terminated array of protocol identifiers. The <b>EnumProtocols </b>function obtains information about the protocols specified by this array.
<p>
If <i>lpiProtocols</i> is NULL, the function obtains information about all available protocols. 

<p>
The following protocol identifier values are defined:

<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%>Value</th>
<th align=left width=65%>Protocol</th>
</tr>
<tr valign=top>
<td width=35%>IPPROTO_TCP</td>
<td width=65%>TCP/IP, a connection/stream oriented protocol</td>
</tr>
<tr valign=top>
<td width=35%>IPPROTO_UDP</td>
<td width=65%>User Datagram Protocol (UDP/IP), a connectionless datagram protocol</td>
</tr>
<tr valign=top>
<td width=35%>ISOPROTO_TP4</td>
<td width=65%>ISO connection-oriented transport protocol</td>
</tr>
<tr valign=top>
<td width=35%>NSPROTO_IPX</td>
<td width=65%>IPX</td>
</tr>
<tr valign=top>
<td width=35%>NSPROTO_SPX</td>
<td width=65%>SPX</td>
</tr>
<tr valign=top>
<td width=35%>NSPROTO_SPXII</td>
<td width=65%>SPX II</td>
</tr>
</table><br>

</dd>
<dt>
<i>lpProtocolBuffer</i></dt>
<dd>
Pointer to a buffer that the function fills with an array of <a href="strucetc_1r3m.htm"><b>PROTOCOL_INFO</b></a> data structures. </dd>
<dt>
<i>lpdwBufferLength</i></dt>
<dd>
Pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpProtocolBuffer</i>.
<p>
On output, the function sets this variable to the minimum buffer size needed to retrieve all of the requested information. For the function to succeed, the buffer must be at least this size.

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is the number of <b>PROTOCOL_INFO</b> data structures written to the buffer pointed to by <i>lpProtocolBuffer</i>.</p>
<p>
If the function fails, the return value is <b>SOCKET_ERROR</b> ( – 1). To get extended error information, call <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_getlasterror">
</object><a href=JavaScript:alink_1.Click()><b>GetLastError</b></a>. <b>GetLastError</b> can return the following extended error code:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Value</th>
<th align=left width=51%>Meaning</th>
</tr>
<tr valign=top>
<td width=49%>ERROR_INSUFFICIENT_BUFFER</td>
<td width=51%>The buffer pointed to by <i>lpProtocolBuffer</i> was too small to receive all of the relevant <a href="strucetc_1r3m.htm"><b>PROTOCOL_INFO</b></a> structures. Call the function with a buffer at least as large as the value returned in *<i>lpdwBufferLength</i>.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
In the following sample code, the <b>EnumProtocols</b> function obtains information about all protocols that are available on a system. The code then examines each of the protocols in greater detail. </p>
<pre><code>SOCKET 
OpenConnection ( 
    PTSTR ServiceName, 
    PGUID ServiceType, 
    BOOL Reliable, 
    BOOL MessageOriented, 
    BOOL StreamOriented, 
    BOOL Connectionless, 
    PINT ProtocolUsed 
    ) 
{ 
    // local variables 
    INT protocols[MAX_PROTOCOLS+1]; 
    BYTE buffer[2048]; 
    DWORD bytesRequired; 
    INT err; 
    PPROTOCOL_INFO protocolInfo; 
    PCSADDR_INFO csaddrInfo; 
    INT protocolCount; 
    INT addressCount; 
    INT i; 
    DWORD protocolIndex; 
    SOCKET s; 
 
    // First look up the protocols installed on this machine. 
    // 
    bytesRequired = sizeof(buffer); 
    err = EnumProtocols( NULL, buffer, &amp;bytesRequired ); 
    if ( err &lt;= 0 ) 
        return INVALID_SOCKET; 
 
    // Walk through the available protocols and pick out the ones which 
    // support the desired characteristics. 
    // 
    protocolCount = err; 
    protocolInfo = (PPROTOCOL_INFO)buffer; 
 
    for ( i = 0, protocolIndex = 0; 
        i &lt; protocolCount &amp;&amp; protocolIndex &lt; MAX_PROTOCOLS; 
        i++, protocolInfo++ ) { 
 
        // If connection-oriented support is requested, then check if 
        // supported by this protocol.  We assume here that connection- 
        // oriented support implies fully reliable service. 
        // 
 
        if ( Reliable ) { 
            // Check to see if the protocol is reliable.  It must 
            // guarantee both delivery of all data and the order in 
            // which the data arrives. 
            // 
            if ( (protocolInfo-&gt;dwServiceFlags &amp; 
                    XP_GUARANTEED_DELIVERY) == 0 
                || 
                    (protocolInfo-&gt;dwServiceFlags &amp; 
                    XP_GUARANTEED_ORDER) == 0 ) { 
 
                continue; 
                } 
 
            // Check to see that the protocol matches the stream/message 
            // characteristics requested. 
            // 
            if ( StreamOriented &amp;&amp; 
                (protocolInfo-&gt;dwServiceFlags &amp; XP_MESSAGE_ORIENTED) 
                    != 0 &amp;&amp; 
                (protocolInfo-&gt;dwServiceFlags &amp; XP_PSEUDO_STREAM) 
                     == 0 ) { 
                continue; 
                } 
 
            if ( MessageOriented &amp;&amp; 
                    (protocolInfo-&gt;dwServiceFlags &amp; XP_MESSAGE_ORIENTED) 
                              == 0 ) { 
                continue; 
                } 
 
            } 
        else if ( Connectionless ) { 
            // Make sure that this is a connectionless protocol. 
            // 
            if ( (protocolInfo-&gt;dwServiceFlags &amp; XP_CONNECTIONLESS) 
                     != 0 ) 
                continue; 
            } 
 
        // This protocol fits all the criteria.  Add it to the list of 
        // protocols in which we're interested. 
        // 
        protocols[protocolIndex++] = protocolInfo-&gt;iProtocol; 
        } 
 </code></pre>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in nspapi.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with wsock32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_5ks2.htm"><b>GetAddressByName</b></a>, <a href="strucetc_1r3m.htm"><b>PROTOCOL_INFO</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
