<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSARecv</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsarecv_2"></a>WSARecv</h1>
<p>
The Windows Sockets <b>WSARecv</b> function receives data from a connected socket.</p>
<pre><code><b>int WSARecv (
  SOCKET</b><i> s</i><b>,                                               </b>
<b>  LPWSABUF</b><i> lpBuffers</i><b>,                                     </b>
<b>  DWORD</b><i> dwBufferCount</i><b>,                                    </b>
<b>  LPDWORD</b><i> lpNumberOfBytesRecvd</i><b>,                           </b>
<b>  LPDWORD</b><i> lpFlags</i><b>,                                        </b>
<b>  LPWSAOVERLAPPED</b><i> lpOverlapped</i><b>,                           </b>
<b>  LPWSAOVERLAPPED_COMPLETION_ROUTINE</b><i> lpCompletionROUTINE  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying a connected socket.</dd>
<dt>
<i>lpBuffers</i></dt>
<dd>
[in/out] A pointer to an array of <a href="strucetc_5ape.htm"><b>WSABUF</b></a> structures. Each <b>WSABUF</b> structure contains a pointer to a buffer and the length of the buffer.</dd>
<dt>
<i>dwBufferCount</i></dt>
<dd>
[in] The number of <a href="strucetc_5ape.htm"><b>WSABUF</b></a> structures in the <i>lpBuffers</i> array.</dd>
<dt>
<i>lpNumberOfBytesRecvd</i></dt>
<dd>
[out] A pointer to the number of bytes received by this call if the receive operation completes immediately.</dd>
<dt>
<i>lpFlags</i></dt>
<dd>
[in/out] A pointer to flags.</dd>
<dt>
<i>lpOverlapped</i></dt>
<dd>
[in] A pointer to a <a href="strucetc_0gz6.htm"><b>WSAOVERLAPPED</b></a> structure (ignored for nonoverlapped sockets).</dd>
<dt>
<i>lpCompletionRoutine</i></dt>
<dd>
[in] A pointer to the completion routine called when the receive operation has been completed (ignored for nonoverlapped sockets).
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>WSARecv</b> function provides functionality over and above the standard <a href="wsapiref_2i9e.htm"><b>recv</b></a> function in three important areas:
<ol>
<li>
It can be used in conjunction with overlapped sockets to perform overlapped receive operations.</li>
<li>
It allows multiple receive buffers to be specified making it applicable to the scatter/gather type of I/O.</li>
<li>
The <i>lpFlags </i>parameter is both an input and an output parameter, allowing applications to sense the output state of the MSG_PARTIAL flag bit. However, the MSG_PARTIAL flag bit is not supported by all protocols.</li>
</ol>
<p>
The <b>WSARecv</b> function is used on connected sockets or bound connectionless sockets specified by the <i>s</i> parameter and is used to read incoming data.The socket's local address must be known. For server applications, this is usually done explicitly through <a href="wsapiref_6vzm.htm"><b>bind</b></a> or implicitly through <a href="wsapiref_13aq.htm"><b>accept</b></a> or <a href="wsapiref_3fn6.htm"><b>WSAAccept</b></a>. Explicit binding is discouraged for client applications. For client applications the socket can become bound implicitly to a local address through <a href="wsapiref_8m7m.htm"><b>connect</b></a>, <a href="wsapiref_8kc2.htm"><b>WSAConnect</b></a>, <a href="wsapiref_4sqa.htm"><b>sendto</b></a>, <a href="wsapiref_752q.htm"><b>WSASendTo</b></a>, or <a href="wsapiref_7dv6.htm"><b>WSAJoinLeaf</b></a>.</p>
<p>
For connected, connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded.</p>
<p>
For overlapped sockets, <b>WSARecv</b> is used<i> </i>to post one or more buffers into which incoming data will be placed as it becomes available, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a>.</p>
<p>
If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are NULL, the socket in this function will be treated as a nonoverlapped socket.</p>
<p>
For nonoverlapped sockets, the blocking semantics are identical to that of the standard <a href="wsapiref_2i9e.htm"><b>recv</b></a> function and the <i>lpOverlapped</i> and <i>lpCompletionRoutine </i>parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the supplied user buffers. In the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received. Windows Socket 2 does not define any standard blocking timeout mechanism for this function. For protocols acting as byte-stream protocols the stack tries to return as much data as possible subject to the supplied buffer space and amount of received data available. However, receipt of a single byte is sufficient to unblock the caller. There is no guarantee that more than a single byte will be returned. For protocols acting as message-oriented, a full message is required to unblock the caller.</p>
<p>
Whether or not a protocol is acting as byte-stream is determined by the setting of XP1_MESSAGE_ORIENTED and XP1_PSEUDO_STREAM in its WSAPROTOCOL_INFO structure and the setting of the MSG_PARTIAL flag passed in to this function (for protocols that support it). The relevant combinations are summarized in the following table (an asterisk (*) indicates that the setting of this bit does not matter in this case).</p>
<table cellspacing=4 cols=4>
<tr valign=top>
<th align=left width=27%>XP1_MESSAGE<br>
_ORIENTED</th>
<th align=left width=25%>XP1_PSEUDO<br>
_STREAM</th>
<th align=left width=26%>MSG_PARTIAL</th>
<th align=left width=22%>Acts as</th>
</tr>
<tr valign=top>
<td width=27%>not set</td>
<td width=25%>*</td>
<td width=26%>*</td>
<td width=22%>byte-stream</td>
</tr>
<tr valign=top>
<td width=27%>*</td>
<td width=25%>set</td>
<td width=26%>*</td>
<td width=22%>byte-stream</td>
</tr>
<tr valign=top>
<td width=27%>set</td>
<td width=25%>not set</td>
<td width=26%>set</td>
<td width=22%>byte-stream</td>
</tr>
<tr valign=top>
<td width=27%>set</td>
<td width=25%>not set</td>
<td width=26%>not set</td>
<td width=22%>message-oriented</td>
</tr>
</table><br>
<p>
The supplied buffers are filled in the order in which they appear in the array pointed to by <i>lpBuffers</i>, and the buffers are packed so that no holes are created.</p>
<p>
The array of <a href="strucetc_5ape.htm"><b>WSABUF</b></a> structures pointed to by the <i>lpBuffers </i>parameter is transient. If this operation completes in an overlapped manner, it is the service provider's responsibility to capture these <b>WSABUF</b> structures before returning from this call. This enables applications to build stack-based <b>WSABUF</b> arrays.</p>
<p>
For byte stream-style sockets (for example, type SOCK_STREAM), incoming data is placed into the buffers until the buffers are filled, the connection is closed, or the internally buffered data is exhausted. Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets. </p>
<p>
For message-oriented sockets (for example, type SOCK_DGRAM), an incoming message is placed into the supplied buffers up to the total size of the buffers supplied, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers supplied, the buffers are filled with the first part of the message. If the MSG_PARTIAL feature is supported by the underlying service provider, the MSG_PARTIAL flag is set in <i>lpFlags</i> and subsequent receive operations will retrieve the rest of the message. If MSG_PARTIAL is not supported but the protocol is reliable, <b>WSARecv</b> generates the error WSAEMSGSIZE and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol is unreliable and does not support MSG_PARTIAL), the excess data is lost, and <b>WSARecv</b> generates the error WSAEMSGSIZE.</p>
<p>
For connection-oriented sockets, <b>WSARecv</b> can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is a byte stream or message oriented. For byte streams, zero bytes having been read (as indicated by zero return value to indicate success, and <i>lpNumberOfBytesRecvd</i> value of zero) indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a failure with an error code of WSAEDISCON is used to indicate graceful closure. In any case a return error code of WSAECONNRESET indicates an abortive close has occurred.</p>
<p>
The <i>lpFlags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the <i>lpFlags</i> parameter. The latter is constructed by or-ing any of the following values:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=31%>Value</th>
<th align=left width=69%>Meaning</th>
</tr>
<tr valign=top>
<td width=31%>MSG_PEEK</td>
<td width=69%>Peek at the incoming data. The data is copied into the buffer but is not removed from the input queue. This flag is valid only for nonoverlapped sockets. </td>
</tr>
<tr valign=top>
<td width=31%>MSG_OOB</td>
<td width=69%>Process out-of-band data. (See section <a href="../../../live/pdnds/sockspi/wsanxref_9fqq.htm">DECnet Out-Of-band data</a> for a discussion of this topic.)</td>
</tr>
<tr valign=top>
<td width=31%>MSG_PARTIAL</td>
<td width=69%>This flag is for message-oriented sockets only. On output, indicates that the data supplied is a portion of the message transmitted by the sender. Remaining portions of the message will be supplied in subsequent receive operations. A subsequent receive operation with MSG_PARTIAL flag cleared indicates end of sender's message.<p>
As an input parameter, this flag indicates that the receive operation should complete even if only part of a message has been received by the service provider.</p>
</td>
</tr>
</table><br>
<p>
For message-oriented sockets, the MSG_PARTIAL bit is set in the <i>lpFlags</i> parameter if a partial message is received. If a complete message is received, MSG_PARTIAL is cleared in <i>lpFlags</i>. In the case of delayed completion, the value pointed to by <i>lpFlags</i> is not updated. When completion has been indicated, the application should call <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a> and examine the flags indicated by the <i>lpdwFlags</i> parameter.</p>
<h4>Overlapped socket I/O</h4>
<p>
If an overlapped operation completes immediately, <b>WSARecv</b> returns a value of zero and the <i>lpNumberOfBytesRecvd</i> parameter is updated with the number of bytes received and the flag bits indicated by the <i>lpFlags</i> parameter are also updated. If the overlapped operation is successfully initiated and will complete later, <b>WSARecv</b> returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, <i>lpNumberOfBytesRecvd</i> and <i>lpFlags</i> are not updated. When the overlapped operation completes, the amount of data transferred is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a>. Flag values are obtained by examining the <i>lpdwFlags </i>parameter of <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a>.</p>
<p>
The <b>WSARecv</b> function can be called from within the completion routine of a previous <b>WSARecv</b>, <a href="wsapiref_4wky.htm"><b>WSARecvFrom</b></a>, <a href="wsapiref_97n6.htm"><b>WSASend</b></a> or <a href="wsapiref_752q.htm"><b>WSASendTo</b></a> function. For a given socket, I/O completion routines will <i>not</i> be nested. For a given socket, I/O completion routines will <i>not</i> be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.</p>
<p>
The <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate <a href="strucetc_0gz6.htm"><b>WSAOVERLAPPED</b></a> structure. </p>
<p>
If the <i>lpCompletionRoutine</i> parameter is NULL, the <i>hEvent</i> field of <i>lpOverlapped</i> is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a> or <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a> to wait or poll on the event object.</p>
<p>
If <i>lpCompletionRoutine</i> is not NULL, the <i>hEvent</i> field is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL <i>lpCompletionRoutine</i> and later calls <b>WSAGetOverlappedResult</b> for the same overlapped IO request may not set the <i>fWait</i> parameter for that invocation of <b>WSAGetOverlappedResult</b> to TRUE. In this case the usage of the <b>hEvent</b> field is undefined, and attempting to wait on the <i>hEvent</i> field would produce unpredictable results.</p>
<p>
The completion routine follows the same rules as stipulated for Win32 file I/O completion routines. The completion routine will <i>not</i> be invoked until the thread is in an alertable wait state such as can occur when the function <b>WSAWaitForMultipleEvents</b> with the <i>fAlertable</i> parameter set to TRUE is invoked.</p>
<p>
The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will <i>not</i> be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.</p>
<p>
The prototype of the completion routine is as follows:</p>
<pre><code><b>void CALLBACK CompletionROUTINE(
  IN DWORD </b><i>dwError</i><b>, </b>
<b>  IN DWORD </b><i>cbTransferred</i><b>, </b>
<b>  IN LPWSAOVERLAPPED </b><i>lpOverlapped</i><b>, </b>
<b>  IN DWORD </b><i>dwFlags</i>
<b>);</b>
</code></pre>
<p>
<b>CompletionRoutine</b> is a placeholder for an application-defined or library-defined function name. The <i>dwError</i> specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. The <i>cbTransferred</i> parameter specifies the number of bytes received. The <i>dwFlags</i> parameter contains information that would have appeared in <i>lpFlags </i>if the receive operation had completed immediately. This function does not return a value.</p>
<p>
Returning from this function allows invocation of another pending completion routine for this socket. When using <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a>, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order they are supplied.</p>
<h4>Return Values</h4>
<p>
If no error occurs and the receive operation has completed immediately, <b>WSARecv</b> returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=46%>WSANOTINITIALISED</td>
<td width=54%>A successful <a href="wsapiref_1v8y.htm"><b>WSAStartup</b></a> must occur before using this function.</td>
</tr>
<tr valign=top>
<td width=46%>WSAENETDOWN</td>
<td width=54%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=46%>WSAENOTCONN</td>
<td width=54%>The socket is not connected.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEINTR</td>
<td width=54%>The (blocking) call was canceled through <a href="wsapiref_704y.htm"><b>WSACancelBlockingCall</b></a>.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEINPROGRESS</td>
<td width=54%>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=46%>WSAENETRESET</td>
<td width=54%>The connection has been broken due to "keep-alive" activity detecting a failure while the operation was in progress.</td>
</tr>
<tr valign=top>
<td width=46%>WSAENOTSOCK</td>
<td width=54%>The descriptor is not a socket.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEFAULT</td>
<td width=54%>The <i>lpBuffers </i>parameter is not completely contained in a valid part of the user address space.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEOPNOTSUPP</td>
<td width=54%>MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, out-of-band data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only send operations.</td>
</tr>
<tr valign=top>
<td width=46%>WSAESHUTDOWN</td>
<td width=54%>The socket has been shut down; it is not possible to call <a href="#_win32_wsarecv_2"><b>WSARecv</b></a> on a socket after <a href="wsapiref_60z6.htm"><b>shutdown</b></a> has been invoked with <i>how</i> set to SD_RECEIVE or SD_BOTH.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEWOULDBLOCK</td>
<td width=54%>Overlapped sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as nonblocking and the receive operation cannot be completed immediately.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEMSGSIZE</td>
<td width=54%>The message was too large to fit into the specified buffer and (for unreliable protocols only) any trailing portion of the message that did not fit into the buffer has been discarded.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEINVAL</td>
<td width=54%>The socket has not been bound (for example, with <b>bind</b>).</td>
</tr>
<tr valign=top>
<td width=46%>WSAECONNABORTED</td>
<td width=54%>The virtual circuit was terminated due to a time-out or other failure.</td>
</tr>
<tr valign=top>
<td width=46%>WSAECONNRESET</td>
<td width=54%>The virtual circuit was reset by the remote side.</td>
</tr>
<tr valign=top>
<td width=46%>WSAEDISCON</td>
<td width=54%>Socket <i>s</i> is message oriented and the virtual circuit was gracefully closed by the remote side.</td>
</tr>
<tr valign=top>
<td width=46%>WSA_IO_PENDING</td>
<td width=54%>An overlapped operation was successfully initiated and completion will be indicated at a later time.</td>
</tr>
<tr valign=top>
<td width=46%>WSA_OPERATION_ABORTED</td>
<td width=54%>The overlapped operation has been canceled due to the closure of the socket.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_2bxu.htm"><b>WSACloseEvent</b></a>, <a href="wsapiref_4esz.htm"><b>WSACreateEvent</b></a>, <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a>, <a href="wsapiref_533m.htm"><b>WSASocket</b></a>, <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
