<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSAEventSelect</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsaeventselect_2"></a>WSAEventSelect</h1>
<p>
The Windows Sockets <b>WSAEventSelect</b> function specifies an event object to be associated with the supplied set of FD_XXX network events.</p>
<pre><code><b>int WSAEventSelect (
  SOCKET</b><i> s</i><b>,               </b>
<b>  WSAEVENT</b><i> hEventObject</i><b>,  </b>
<b>  long</b><i> lNetworkEvents     </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying the socket.</dd>
<dt>
<i>hEventObject</i></dt>
<dd>
[in] A handle identifying the event object to be associated with the supplied set of FD_XXX network events.</dd>
<dt>
<i>lNetworkEvents</i></dt>
<dd>
[in] A bitmask that specifies the combination of FD_XXX network events in which the application has interest.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>WSAEventSelect</b> function is used to specify an event object, <i>hEventObject</i>, to be associated with the selected FD_XXX network events, <i>lNetworkEvents</i>. The socket for which an event object is specified is identified by the <i>s </i>parameter. The event object is set when any of the nominated network events occur.</p>
<p>
The<b> WSAEventSelect</b> function operates very similarly to <a href="wsapiref_6jn6.htm"><b>WSAAsyncSelect</b></a>, the difference being in the actions taken when a nominated network event occurs. The <b>WSAAsyncSelect</b> function causes an application-specified Windows message to be posted. The <b>WSAEventSelect</b> sets the associated event object and records the occurrence of this event in an internal network event record. An application can use <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a> to wait or poll on the event object, and use <a href="wsapiref_4et0.htm"><b>WSAEnumNetworkEvents</b></a> to retrieve the contents of the internal network event record and thus determine which of the nominated network events have occurred.</p>
<p>
<b>WSAEventSelect</b> is the only function that causes network activity and errors to be recorded and retrievable through <b>WSAEnumNetworkEvents</b>.  See the descriptions of <a href="wsapiref_1ab6.htm"><b>select</b></a> and <b>WSAAsyncSelect</b> to find out how those functions report network activity and errors.</p>
<p>
The <b>WSAEventSelect</b> function automatically sets socket <i>s</i> to nonblocking mode, regardless of the value of <i>lNetworkEvents</i>. See <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a><b>/<a href="wsapiref_6ik2.htm">WSAIoctl</a></b> about how to set the socket back to blocking mode.</p>
<p>
The <i>lNetworkEvents</i> parameter is constructed by or'ing any of the values specified in the following list.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=37%>Value</th>
<th align=left width=63%>Meaning</th>
</tr>
<tr valign=top>
<td width=37%>FD_READ</td>
<td width=63%>Want to receive notification of readiness for reading</td>
</tr>
<tr valign=top>
<td width=37%>FD_WRITE</td>
<td width=63%>Want to receive notification of readiness for writing</td>
</tr>
<tr valign=top>
<td width=37%>FD_OOB</td>
<td width=63%>Want to receive notification of the arrival of out-of-band data</td>
</tr>
<tr valign=top>
<td width=37%>FD_ACCEPT</td>
<td width=63%>Want to receive notification of incoming connections</td>
</tr>
<tr valign=top>
<td width=37%>FD_CONNECT</td>
<td width=63%>Want to receive notification of completed connection or multipoint "join" operation</td>
</tr>
<tr valign=top>
<td width=37%>FD_CLOSE</td>
<td width=63%>Want to receive notification of socket closure</td>
</tr>
<tr valign=top>
<td width=37%>FD_QOS</td>
<td width=63%>Want to receive notification of socket Quality of Service (QOS) changes</td>
</tr>
<tr valign=top>
<td width=37%>FD_GROUP_QOS</td>
<td width=63%>Reserved for future use with socket groups. Want to receive notification of socket group Quality of Service (QOS) changes</td>
</tr>
<tr valign=top>
<td width=37%>FD_ROUTING<br>
_INTERFACE_CHANGE</td>
<td width=63%>Want to receive notification of routing interface changes for the specified destination</td>
</tr>
<tr valign=top>
<td width=37%>FD_ADDRESS_LIST<br>
_CHANGE</td>
<td width=63%>Want to receive notification of local address list changes for the address family of the socket</td>
</tr>
</table><br>
<p>
Issuing a <b>WSAEventSelect</b> for a socket cancels any previous <b>WSAAsyncSelect</b> or <b>WSAEventSelect</b> for the same socket and clears the internal network event record. For example, to associate an event object with both reading and writing network events, the application must call <b>WSAEventSelect</b> with both FD_READ and FD_WRITE, as follows:</p>
<pre><code>rc = WSAEventSelect(s, hEventObject, FD_READ|FD_WRITE);
 </code></pre>
<p>
It is not possible to specify different event objects for different network events. The following code will <i>not</i> work; the second call will cancel the effects of the first, and only FD_WRITE network event will be associated with <i>hEventObject2</i>:</p>
<pre><code>rc = WSAEventSelect(s, hEventObject1, FD_READ);
rc = WSAEventSelect(s, hEventObject2, FD_WRITE); //bad
 </code></pre>
<p>
To cancel the association and selection of network events on a socket, <i>lNetworkEvents</i> should be set to zero, in which case the <i>hEventObject</i> parameter will be ignored.</p>
<pre><code>rc = WSAEventSelect(s, hEventObject, 0);
 </code></pre>
<p>
Closing a socket with <a href="wsapiref_714i.htm"><b>closesocket</b></a> also cancels the association and selection of network events specified in <b>WSAEventSelect</b> for the socket. The application, however, still must call <b>WSACloseEvent</b> to explicitly close the event object and free any resources.</p>
<p>
The socket created when the <b>accept </b>function is called has the same properties as the listening socket used to accept it. Any <b>WSAEventSelect</b> association and network events selection set for the listening socket apply to the accepted socket. For example, if a listening socket has <b>WSAEventSelect</b> association of <i>hEventOject</i> with FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE network events associated with the same <i>hEventObject</i>. If a different <i>hEventObject</i> or network events are desired, the application should call <b>WSAEventSelect</b>, passing the accepted socket and the desired new information.</p>
<h4>Return Values</h4>
<p>
The return value is zero if the application's specification of the network events and the associated event object was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.</p>
<p>
As in the case of the <a href="wsapiref_1ab6.htm"><b>select</b></a> and <a href="wsapiref_6jn6.htm"><b>WSAAsyncSelect</b></a> functions, <b>WSAEventSelect</b> will frequently be used to determine when a data transfer operation (<a href="wsapiref_6quq.htm"><b>send</b></a> or <a href="wsapiref_2i9e.htm"><b>recv</b></a>) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for the possibility that the event object is set and it issues a Windows Sockets call that returns WSAEWOULDBLOCK immediately. For example, the following sequence of operations is possible:
<ol>
<li>
Data arrives on socket <i>s</i>; Windows Sockets sets the <b>WSAEventSelect</b> event object.</li>
<li>
The application does some other processing.</li>
<li>
While processing, application issues an <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a>(s, FIONREAD...) and notices that there is data ready to be read.</li>
<li>
The application issues a <b>recv</b>(s,...) to read the data.</li>
<li>
The application eventually waits on event object specified in <b>WSAEventSelect</b>, which returns immediately indicating that data is ready to read.</li>
<li>
The application issues <b>recv</b>(s,...), which fails with the error WSAEWOULDBLOCK.</li>
</ol>
<p>
Having successfully recorded the occurrence of the network event (by setting the corresponding bit in the internal network event record) and signaled the associated event object, no further actions are taken for that network event until the application makes the function call that implicitly re-enables the setting of that network event and signaling of the associated event object.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%>Network Event</th>
<th align=left width=65%>Re-enabling function</th>
</tr>
<tr valign=top>
<td width=35%>FD_READ</td>
<td width=65%><a href="wsapiref_2i9e.htm"><b>recv</b></a>, <a href="wsapiref_88oi.htm"><b>recvfrom</b></a>, <a href="wsapiref_4z1u.htm"><b>WSARecv</b></a>, or <a href="wsapiref_4wky.htm"><b>WSARecvFrom</b></a></td>
</tr>
<tr valign=top>
<td width=35%>FD_WRITE</td>
<td width=65%><a href="wsapiref_6quq.htm"><b>send</b></a>, <a href="wsapiref_4sqa.htm"><b>sendto</b></a>, <a href="wsapiref_97n6.htm"><b>WSASend</b></a>, or <a href="wsapiref_752q.htm"><b>WSASendTo</b></a></td>
</tr>
<tr valign=top>
<td width=35%>FD_OOB</td>
<td width=65%><b>recv</b>, <b>recvfrom</b>, <b>WSARecv</b>, or <b>WSARecvFrom</b></td>
</tr>
<tr valign=top>
<td width=35%>FD_ACCEPT</td>
<td width=65%><a href="wsapiref_13aq.htm"><b>accept</b></a> or <a href="wsapiref_3fn6.htm"><b>WSAAccept</b></a> unless the error code returned is WSATRY_AGAIN indicating that the condition function returned CF_DEFER</td>
</tr>
<tr valign=top>
<td width=35%>FD_CONNECT</td>
<td width=65%>NONE</td>
</tr>
<tr valign=top>
<td width=35%>FD_CLOSE</td>
<td width=65%>NONE</td>
</tr>
<tr valign=top>
<td width=35%>FD_QOS</td>
<td width=65%><a href="wsapiref_6ik2.htm"><b>WSAIoctl</b></a> with command SIO_GET_QOS </td>
</tr>
<tr valign=top>
<td width=35%>FD_GROUP_QOS</td>
<td width=65%>Reserved for future use with socket groups. <b>WSAIoctl</b> with command SIO_GET_GROUP_QOS</td>
</tr>
<tr valign=top>
<td width=35%>FD_ROUTING<br>
_INTERFACE_CHANGE</td>
<td width=65%><b>WSAIoctl</b> with command SIO_ROUTING_INTERFACE_CHANGE</td>
</tr>
<tr valign=top>
<td width=35%>FD_ADDRESS_LIST<br>
_CHANGE</td>
<td width=65%><b>WSAIoctl</b> with command SIO_ADDRESS_LIST_CHANGE</td>
</tr>
</table><br>
<p>
Any call to the re-enabling routine, even one that fails, results in re-enabling of recording and signaling for the relevant network event and event object.</p>
<p>
For FD_READ, FD_OOB, and FD_ACCEPT network events, network event recording and event object signaling are "level-triggered." This means that if the re-enabling routine is called and the relevant network condition is still valid after the call, the network event is recorded and the associated event object is set. This allows an application to be event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following sequence:
<ol>
<li>
Transport provider receives 100 bytes of data on socket <b>s</b> and causes WS2_32.DLL to record the FD_READ network event and set the associated event object.</li>
<li>
The application issues <b>recv( s, buffptr, 50, 0)</b> to read 50 bytes.</li>
<li>
The transport provider causes WS2_32.DLL to record the FD_READ network event and sets the associated event object again since there is still data to be read.</li>
</ol>
<p>
With these semantics, an application need not read all available data in response to an FD_READ network event—a single <b>recv</b> in response to each FD_READ network event is appropriate.</p>
<p>
The FD_QOS and FD_GROUP_QOS events are considered edge triggered. A message will be posted exactly once when a quality of service change occurs. Further messages will <i>not</i> be forthcoming until either the provider detects a further change in quality of service or the application renegotiates the quality of service for the socket.</p>
<p>
The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered "edge triggered" as well. A message will be posted exactly once when a change occurs AFTER the application has request the notification by issuing <b>WSAIoctl</b> with SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE correspondingly. Further messages will not be forthcoming until the application reissues the IOCTL AND another change is detected  since the IOCTL has been issued.</p>
<p>
If a network event has already happened when the application calls <b>WSAEventSelect</b> or when the re-enabling function is called, then a network event is recorded and the associated event object is set as appropriate. For example, consider the following sequence:
<ol>
<li>
an application calls <b>listen</b>,</li>
<li>
a connect request is received but not yet accepted,</li>
<li>
the application calls <b>WSAEventSelect</b> specifying that it is interested in the FD_ACCEPT network event for the socket. Due to the persistence of network events, Windows Sockets records the FD_ACCEPT network event and sets the associated event object immediately.</li>
</ol>
<p>
The FD_WRITE network event is handled slightly differently. An FD_WRITE network event is recorded when a socket is first connected with <b>connect/WSAConnect</b> or accepted with <b>accept/WSAAccept</b>, and then after a send fails with WSAEWOULDBLOCK and buffer space becomes available. Therefore, an application can assume that sends are possible starting from the first FD_WRITE network event setting and lasting until a send returns WSAEWOULDBLOCK. After such a failure the application will find out that sends are again possible when an FD_WRITE network event is recorded and the associated event object is set.</p>
<p>
The FD_OOB network event is used only when a socket is configured to receive out-of-band data separately. If the socket is configured to receive out-of-band data in-line, the out-of-band (expedited) data is treated as normal data and the application should register an interest in, and will get, FD_READ network event, not FD_OOB network event. An application can set or inspect the way in which out-of-band data is to be handled by using <b>setsockopt</b> or <b>getsockopt</b> for the SO_OOBINLINE option.</p>
<p>
The error code in an FD_CLOSE network event indicates whether the socket close was graceful or abortive. If the error code is zero, then the close was graceful; if the error code is WSAECONNRESET, then the socket's virtual circuit was reset. This only applies to connection-oriented sockets such as SOCK_STREAM.</p>
<p>
The FD_CLOSE network event is recorded when a close indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the FD_CLOSE is recorded when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the remote end performing a <b>shutdown</b> on the send side or a <b>closesocket</b>. FD_CLOSE should only be posted after all data is read from a socket, but an application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing data.</p>
<p>
Please note Windows Sockets will record ONLY an FD_CLOSE network event to indicate closure of a virtual circuit. It will <i>not</i> record an FD_READ network event to indicate this condition.</p>
<p>
The FD_QOS or FD_GROUP_QOS network event is recorded when any field in the flow specification associated with socket <i>s</i> or the socket group that <i>s</i> belongs to has changed, respectively. Applications should use <b>WSAIoctl</b> with command SIO_GET_QOS or SIO_GET_GROUP_QOS to get the current QOS for socket <i>s</i> or for the socket group <i>s</i> belongs to, respectively.</p>
<p>
The FD_ROUTING_INTERFACE_CHANGE nework event is recorded when the local interface that should be used to reach the destination specified in <b>WSAIoctl</b> with SIO_ROUTING_INTERFACE_CHANGE changes <i>after</i> such IOCTL has been issued.</p>
<p>
The FD_ADDRESS_LIST_CHANGE network event is recorded when the list of addresses of protocol family for the socket to which the application can bind changes <i>after</i> <b>WSAIoctl</b> with SIO_ADDRESS_LIST_CHANGE has been issued.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=41%>WSANOTINITIALISED</td>
<td width=59%>A successful <b>WSAStartup</b> must occur before using this function.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINVAL</td>
<td width=59%>Indicates that one of the specified parameters was invalid, or the specified socket is in an invalid state.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINPROGRESS</td>
<td width=59%>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENOTSOCK</td>
<td width=59%>The descriptor is not a socket.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_6jn6.htm"><b>WSAAsyncSelect</b></a>, <a href="wsapiref_2bxu.htm"><b>WSACloseEvent</b></a>, <a href="wsapiref_4esz.htm"><b>WSACreateEvent</b></a>, <a href="wsapiref_4et0.htm"><b>WSAEnumNetworkEvents</b></a>, <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
