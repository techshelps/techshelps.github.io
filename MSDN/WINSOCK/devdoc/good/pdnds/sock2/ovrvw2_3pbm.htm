<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Receiving Completion Indications</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_receiving_completion_indications_2"></a>Receiving Completion Indications</h3>
<p>
Several options are available for receiving completion indications, thus providing applications with appropriate levels of flexibility. These include: waiting (or blocking) on event objects, polling event objects, and socket I/O completion routines.</p>

<h4><a name="_win32_blocking_and_waiting_for_completion_indication_2"></a>Blocking and Waiting for Completion Indication</h4>
<p>
Applications can block while waiting for one or more event objects to become set using the <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a> function. In Win32 implementations, the process or thread will truly block. Since Windows Sockets 2 event objects are implemented as Win32 events, the native Win32 function, <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_waitformultipleobjects">
</object><a href=JavaScript:alink_1.Click()><b>WaitForMultipleObjects</b></a> can also be used for this purpose. This is especially useful if the thread needs to wait on both socket and nonsocket events.</p>

<h4><a name="_win32_polling_for_completion_indication_2"></a>Polling for Completion Indication </h4>
<p>
Applications that prefer not to block can use the <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a> function to poll for the completion status associated with any particular event object. This function indicates whether or not the overlapped operation has completed, and if completed, arranges for the <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a> function to retrieve the error status of the overlapped operation.</p>

<h4><a name="_win32_using_socket_i_o_completion_routines_2"></a>Using socket I/O completion routines </h4>
<p>
The functions used to initiate overlapped I/O (<a href="wsapiref_97n6.htm"><b>WSASend</b></a>, <a href="wsapiref_752q.htm"><b>WSASendTo</b></a>, <a href="wsapiref_4z1u.htm"><b>WSARecv</b></a>, <a href="wsapiref_4wky.htm"><b>WSARecvFrom</b></a>) all take <i>lpCompletionRoutine</i> as an optional input parameter. This is a pointer to an application-specific function that will be called after a successfully initiated overlapped I/O operation was completed (successfully or otherwise). The completion routine follows the same rules as stipulated for Win32 file I/O completion routines. That is, the completion routine will not be invoked until the thread is in an alertable wait state, such as when the function <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a> is invoked with the <i>fAlertable </i>flag set. An application that uses the completion routine option for a particular overlapped I/O request may not use the "wait" option of <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a> for that same overlapped I/O request.</p>
<p>
The transports allow an application to invoke send and receive operations from within the context of the socket I/O completion routine and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.</p>

<h4><a name="_win32_summary_of_overlapped_completion_indication_mechanisms_2"></a>Summary of overlapped completion indication mechanisms</h4>
<p>
The particular overlapped I/O completion indication to be used for a given overlapped operation is determined by whether the application supplies a pointer to a completion function, whether a <a href="strucetc_0gz6.htm">WSAOVERLAPPED</a> structure is referenced, and by the value of the hEvent member within the WSAOVERLAPPED structure (if supplied). The following table summarizes the completion semantics for an overlapped socket and shows the various combinations of <i>lpOverlapped</i>, <i>hEvent</i>, and <i>lpCompletionRoutine:</i></p>
<table cellspacing=4 cols=4>
<tr valign=top>
<th align=left width=20%><i>lpOverlapped</i></th>
<th align=left width=14%><i>hEvent</i></th>
<th align=left width=29%><i>lpCompletionRoutine</i></th>
<th align=left width=37%>Completion Indication</th>
</tr>
<tr valign=top>
<td width=20%>NULL</td>
<td width=14%>not applicable</td>
<td width=29%>ignored</td>
<td width=37%>Operation completes synchronously. It behaves as if it were a nonoverlapped socket.</td>
</tr>
<tr valign=top>
<td width=20%>!NULL</td>
<td width=14%>NULL</td>
<td width=29%>NULL</td>
<td width=37%>Operation completes overlapped, but there is no Windows Sockets 2-supported completion mechanism. The completion port mechanism (if supported) can be used in this case. Otherwise, there will be no completion notification.</td>
</tr>
<tr valign=top>
<td width=20%>!NULL</td>
<td width=14%>!NULL</td>
<td width=29%>NULL</td>
<td width=37%>Operation completes overlapped, notification by signaling event object.</td>
</tr>
<tr valign=top>
<td width=20%>!NULL</td>
<td width=14%>ignored</td>
<td width=29%>!NULL</td>
<td width=37%>Operation completes overlapped, notification by scheduling completion routine.</td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
