<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSALookupServiceNext</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsalookupservicenext_2"></a>WSALookupServiceNext</h1>
<p>
The Windows Sockets <b>WSALookupServiceNext</b> function is called after obtaining a handle from a previous call to <a href="wsapiref_6sfm.htm"><b>WSALookupServiceBegin</b></a> in order to retrieve the requested service information.</p>
<p>
The provider will pass back a <a href="strucetc_4y2a.htm"><b>WSAQUERYSET</b></a><b> </b>structure in the <i>lpqsResults </i>buffer. The client should continue to call this function until it returns WSA_E_NOMORE, indicating that all of <a href="strucetc_4y2a.htm"><b>WSAQUERYSET</b></a><b> </b>has been returned.</p>
<pre><code><b>INT WSALookupServiceNext (
  HANDLE</b><i> hLookup</i><b>,        </b>
<b>  DWORD</b><i> dwControlFlags</i><b>,  </b>
<b>  LPDWORD</b><i> lpdwBufferLength</i><b>,  </b>
<b>  LPWSAQUERYSET</b><i> lpqsResults  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hLookup</i></dt>
<dd>
[in] A handle returned from the previous call to <a href="wsapiref_6sfm.htm"><b>WSALookupServiceBegin</b></a>.</dd>
<dt>
<i>dwControlFlags</i></dt>
<dd>
[in] Flags to control the next operation. Currently only LUP_FLUSHPREVIOUS is defined as a means to cope with a result set which is too large. If an application does not wish to (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result set - which was too large - and move on to the next set for this call. </dd>
<dt>
<i>lpdwBufferLength</i></dt>
<dd>
[in/out] On input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the function fails and the error is WSAEFAULT, then it contains the minimum number of bytes to pass for the <i>lpqsResults</i> to retrieve the record.</dd>
<dt>
<i>lpqsResults</i></dt>
<dd>
[out] A pointer to a block of memory, which will contain one result set in a <a href="strucetc_4y2a.htm"><b>WSAQUERYSET</b></a> structure on return.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <i>dwControlFlags</i> specified in this function and the ones specified at the time of <b>WSALookupServiceBegin</b> are treated as "restrictions" for the purpose of combination. The restrictions are combined between the ones at <b>WSALookupServiceBegin</b> time and the ones at <b>WSALookupServiceNext</b> time. Therefore the flags at <b>WSALookupServiceNext</b> can never increase the amount of data returned beyond what was requested at <b>WSALookupServiceBegin</b>, although it is NOT an error to specify more or fewer flags. The flags specified at a given <b>WSALookupServiceNext</b> apply only to that call.</p>
<p>
The <i>dwControlFlags</i> LUP_FLUSHPREVIOUS and LUP_RES_SERVICE are exceptions to the "combined restrictions" rule (because they are "behavior" flags instead of "restriction" flags). If either of these flags are used in <b>WSALookupServiceNext</b> they have their defined effect regardless of the setting of the same flags at <b>WSALookupServiceBegin</b>.</p>
<p>
For example, if LUP_RETURN_VERSION is specified at <b>WSALookupServiceBegin</b> the service provider retrieves records including the "version". If LUP_RETURN_VERSION is NOT specified at <b>WSALookupServiceNext</b>, the returned information does not include the "version", even though it was available. No error is generated.</p>
<p>
Also for example, if LUP_RETURN_BLOB is NOT specified at <b>WSALookupServiceBegin</b> but is specified at <b>WSALookupServiceNext</b>, the returned information does not include the private data. No error is generated.</p>
<h4>Query Results</h4>
<p>
The following table describes how the query results are represented in the <b>WSAQUERYSET</b> structure.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=46%>WSAQUERYSET Field Name</th>
<th align=left width=54%>Result Interpretation</th>
</tr>
<tr valign=top>
<td width=46%><i>dwSize</i></td>
<td width=54%>Will be set to sizeof(<b>WSAQUERYSET</b>). This is used as a versioning mechanism.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwOuputFlags</i></td>
<td width=54%>RESULT_IS_ALIAS flag indicates this is an alias result.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszServiceInstanceName</i></td>
<td width=54%>Referenced string contains service name.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpServiceClassId</i></td>
<td width=54%>The GUID corresponding to the service class.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpVersion</i></td>
<td width=54%>References version number of the particular service instance.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszComment</i></td>
<td width=54%>Optional comment string supplied by service instance.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwNameSpace</i></td>
<td width=54%>Name space in which the service instance was found.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpNSProviderId</i></td>
<td width=54%>Identifies the specific name space provider that supplied this query result.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszContext</i></td>
<td width=54%>Specifies the context point in a hierarchical name space at which the service is located.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwNumberOfProtocols</i></td>
<td width=54%>Undefined for results.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpafpProtocols</i></td>
<td width=54%>Undefined for results, all needed protocol information is in the <a href="strucetc_4zua.htm"><b>CSADDR_INFO</b></a> structures.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszQueryString</i></td>
<td width=54%>When <i>dwControlFlags</i> includes LUP_RETURN_QUERY_STRING, this field returns the unparsed remainder of the <i>lpszServiceInstanceName</i> specified in the original query. For example, in a name space that identifies services by hierarchical names that specify a host name and a file path within that host, the address returned might be the host address and the unparsed remainder might be the file path. If the <i>lpszServiceInstanceName</i> is fully parsed and LUP_RETURN_QUERY_STRING is used, this field is NULL or points to a zero-length string.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwNumberOfCsAddrs</i></td>
<td width=54%>Indicates the number of elements in the array of <a href="strucetc_4zua.htm"><b>CSADDR_INFO</b></a> structures.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpcsaBuffer</i></td>
<td width=54%>A pointer to an array of <a href="strucetc_4zua.htm"><b>CSADDR_INFO</b></a> structures, with one complete transport address contained within each element.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpBlob</i></td>
<td width=54%><i>(Optional) </i>This is a pointer to a provider-specific entity.</td>
</tr>
</table><br>
<h4>Return Values</h4>
<p>
The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=47%>WSA_E_NO_MORE</td>
<td width=53%>There is no more data available. In Windows Sockets version 2, conflicting error codes are defined for WSAENOMORE (10102) and WSA_E_NO_MORE (10110). The error code WSAENOMORE will be removed in a future version and only WSA_E_NO_MORE will remain. For Windows Sockets version 2, however, applications should check for both WSAENOMORE and WSA_E_NO_MORE for the widest possible compatibility with Name Space Providers that use either one.</td>
</tr>
<tr valign=top>
<td width=47%>WSA_E_CANCELLED</td>
<td width=53%>A call to <b>WSALookupServiceEnd</b> was made while this call was still processing. The call has been canceled. The data in the <i>lpqsResults </i>buffer is undefined. In Windows Sockets version 2, conflicting error codes are defined for WSAECANCELLED (10103) and WSA_E_CANCELLED (10111). The error code WSAECANCELLED will be removed in a future version and only WSA_E_CANCELLED will remain.  For Windows Sockets version 2, however, applications should check for both WSAECANCELLED and WSA_E_CANCELLED for the widest possible compatibility with Name Space Providers that use either one.</td>
</tr>
<tr valign=top>
<td width=47%>WSAEFAULT</td>
<td width=53%>The <i>lpqsResults</i> buffer was too small to contain a <a href="strucetc_4y2a.htm"><b>WSAQUERYSET</b></a> set.</td>
</tr>
<tr valign=top>
<td width=47%>WSAEINVAL</td>
<td width=53%>One or more required parameters were invalid or missing.</td>
</tr>
<tr valign=top>
<td width=47%>WSA_INVALID_HANDLE</td>
<td width=53%>The specified Lookup handle is invalid.</td>
</tr>
<tr valign=top>
<td width=47%>WSANOTINITIALIZED</td>
<td width=53%>The WS2_32.DLL has not been initialized. The application must first call <a href="wsapiref_1v8y.htm"><b>WSAStartup</b></a> before calling any Windows Sockets functions.</td>
</tr>
<tr valign=top>
<td width=47%>WSANO_DATA</td>
<td width=53%>The name was ound in the database, but no data matching the given restrictions was located.</td>
</tr>
<tr valign=top>
<td width=47%>WSASERVICE_NOT_FOUND</td>
<td width=53%>No such service is known. The service cannot be found in the specified name space.</td>
</tr>
<tr valign=top>
<td width=47%>WSA NOT ENOUGH MEMORY</td>
<td width=53%>There was insufficient memory to perform the operation.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_6sfm.htm"><b>WSALookupServiceBegin</b></a>, <a href="wsapiref_88he.htm"><b>WSALookupServiceEnd</b></a></p>
<p>&nbsp;</p></body>
</HTML>
