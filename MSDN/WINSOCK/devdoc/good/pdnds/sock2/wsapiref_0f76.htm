<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSAEnumProtocols</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsaenumprotocols_2"></a>WSAEnumProtocols</h1>
<p>
The Windows Sockets <b>WSAEnumProtocols</b> function retrieves information about available transport protocols.</p>
<pre><code><b>int WSAEnumProtocols (
  LPINT</b><i> lpiProtocols</i><b>,                   </b>
<b>  LPWSAPROTOCOL_INFO</b><i> lpProtocolBuffer</i><b>,  </b>
<b>  ILPDWORD</b><i> lpdwBufferLength             </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>lpiProtocols</i></dt>
<dd>
[in] A NULL-terminated array of iProtocol values. This parameter is optional; if <i>lpiProtocols</i> is NULL, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.</dd>
<dt>
<i>lpProtocolBuffer</i></dt>
<dd>
[out] A buffer that is filled with <a href="strucetc_4cfm.htm"><b>WSAPROTOCOL_INFO</b></a> structures. </dd>
<dt>
<i>lpdwBufferLength</i></dt>
<dd>
[in/out] On input, the count of bytes in the <i>lpProtocolBuffer</i> buffer passed to <b>WSAEnumProtocols</b>. On output, the minimum buffer size that can be passed to <b>WSAEnumProtocols</b> to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a machine is typically small.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>WSAEnumProtocols </b>function is used to discover information about the collection of transport protocols and protocol chains installed on the local machine. Since layered protocols are only usable by applications when installed in protocol chains, information on layered protocols is not included in <i>lpProtocolBuffer</i>. The <i>lpiProtocols </i>parameter can be used as a filter to constrain the amount of information provided. Often, <i>lpiProtocols </i>will be supplied as a NULL pointer that will cause the function to return information on all available transport protocols and protocol chains.</p>
<p>
A <a href="strucetc_4cfm.htm"><b>WSAPROTOCOL_INFO</b></a> structure is provided in the buffer pointed to by <i>lpProtocolBuffer </i>for each requested protocol. If the supplied buffer is not large enough (as indicated by the input value of <i>lpdwBufferLength </i>), the value pointed to by <i>lpdwBufferLength </i>will be updated to indicate the required buffer size. The application should then obtain a large enough buffer and call this <b>WSAEnumProtocols </b>again.</p>
<p>
The order in which the <b>WSAPROTOCOL_INFO</b> structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider using the WS2_32.DLL, or with any subsequent re-ordering that can have occurred through the Windows Sockets applet or DLL supplied for establishing default TCP/IP providers.</p>
<h4>Return Values</h4>
<p>
If no error occurs, <b>WSAEnumProtocols</b> returns the number of protocols to be reported. Otherwise, a value of SOCKET_ERROR is returned and a specific error code can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=41%>WSANOTINITIALISED</td>
<td width=59%>A successful <a href="wsapiref_1v8y.htm"><b>WSAStartup</b></a> must occur before using this function.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINPROGRESS</td>
<td width=59%>A blocking Windows Sockets 1.1 call is in progress.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINVAL</td>
<td width=59%>Indicates that one of the specified parameters was invalid.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENOBUFS</td>
<td width=59%>The buffer length was too small to receive all the relevant <b>WSAPROTOCOL_INFO</b> structures and associated information. Pass in a buffer at least as large as the value returned in <i>lpdwBufferLength</i>.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEFAULT</td>
<td width=59%>One or more of the <i>lpiProtocols</i>, <i>lpProtocolBuffer</i>, or <i>lpdwBufferLength</i> arguments are not a valid part of the user address space.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<p>&nbsp;</p></body>
</HTML>
