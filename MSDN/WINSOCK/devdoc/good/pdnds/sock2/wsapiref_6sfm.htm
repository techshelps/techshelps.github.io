<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSALookupServiceBegin</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsalookupservicebegin_2"></a>WSALookupServiceBegin</h1>
<p>
The Windows Sockets <b>WSALookupServiceBegin </b>function initiates a client query that is constrained by the information contained within a <a href="strucetc_4y2a.htm"><b>WSAQUERYSET</b></a> structure. <b>WSALookupServiceBegin </b>only returns a handle, which should be used by subsequent calls to <a href="wsapiref_14z6.htm"><b>WSALookupServiceNext</b></a><b> </b>to get the actual results.</p>
<pre><code><b>INT WSALookupServiceBegin (
  LPWSAQUERYSET</b><i> lpqsRestrictions</i><b>,  </b>
<b>  DWORD</b><i> dwControlFlags</i><b>,            </b>
<b>  LPHANDLE</b><i> lphLookup               </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>lpqsRestrictions </i></dt>
<dd>
[in] A pointer to the search criteria. See below for details.</dd>
<dt>
<i>dwControlFlags</i></dt>
<dd>
[in] A flag that controls the depth of the search.
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=46%>LUP_DEEP</td>
<td width=54%>Query deep as opposed to just the first level.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_CONTAINERS</td>
<td width=54%>Return containers only</td>
</tr>
<tr valign=top>
<td width=46%>LUP_NOCONTAINERS</td>
<td width=54%>Do not return any containers</td>
</tr>
<tr valign=top>
<td width=46%>LUP_FLUSHCACHE</td>
<td width=54%>If the provider has been caching information, ignore the cache and go query the name space itself.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_FLUSHPREVIOUS</td>
<td width=54%>Used as a value for the <i>dwControlFlags</i> argument in <b>WSALookupServiceNext</b>. Setting this flag instructs the provider to discard the last result set, which was too large for the supplied buffer, and move on to the next result set.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_NEAREST</td>
<td width=54%>If possible, return results in the order of distance. The measure of distance is provider specific.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RES_SERVICE</td>
<td width=54%>This indicates whether prime response is in the remote or local part of <a href="strucetc_4zua.htm"><b>CSADDR_INFO</b></a> structure. The other part needs to be "usable" in either case.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_ALIASES</td>
<td width=54%>Any available alias information is to be returned in successive calls to <a href="wsapiref_14z6.htm"><b>WSALookupServiceNext</b></a>, and each alias returned will have the RESULT_IS_ALIAS flag set.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_NAME</td>
<td width=54%>Retrieve the nameas <i>lpszServiceInstanceName</i>.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_TYPE</td>
<td width=54%>Retrieve the type as <i>lpServiceClassId</i>.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_VERSION</td>
<td width=54%>Retrieve the version as <i>lpVersion.</i></td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_COMMENT</td>
<td width=54%>Retrieve the comment as <i>lpszComment</i>.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_ADDR</td>
<td width=54%>Retrieve the addresses as <i>lpcsaBuffer</i>.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_BLOB</td>
<td width=54%>Retrieve the private data as <i>lpBlob</i>.</td>
</tr>
<tr valign=top>
<td width=46%>LUP_RETURN_ALL</td>
<td width=54%>Retrieve all of the information</td>
</tr>
</table><br>

</dd>
<dt>
<i>lphLookup</i></dt>
<dd>
[out] A handle to be used when calling <a href="wsapiref_14z6.htm"><b>WSALookupServiceNext</b></a> in order to start retrieving the results set.
</dd>
</dl>
<h4>Remarks</h4>
<p>
If LUP_CONTAINERS is specified in a call, all other restriction values should be avoided. If any are supplied, it is up to the name service provider to decide if it can support this restriction over the containers. If it cannot, it should return an error. </p>
<p>
Some name service providers can have other means of finding containers. For example, containers might all be of some well-known type, or of a set of well-known types, and therefore a query restriction can be created for finding them. No matter what other means the name service provider has for locating containers, LUP_CONTAINERS and LUP_NOCONTAINERS take precedence. Hence, if a query restriction is given that includes containers, specifying LUP_NOCONTAINERS will prevent the container items from being returned. Similarly, no matter the query restriction, if LUP_CONTAINERS is given, only containers should be returned. If a name space does not support containers, and LUP_CONTAINERS is specified, it should simply return WSANO_DATA.</p>
<p>
The preferred method of obtaining the containers within another container, is the call:</p>
<pre><code>dwStatus = WSALookupServiceBegin(
      lpqsRestrictions,
      LUP_CONTAINERS,
      lphLookup);
 </code></pre>
<p>
This call is followed by the requisite number of <a href="wsapiref_14z6.htm"><b>WSALookupServiceNext</b></a> calls. This will return all containers contained immediately within the starting context; that is, it is not a deep query. With this, one can map the address space structure by walking the hierarchy, perhaps enumerating the content of selected containers. Subsequent uses of <b>WSALookupServiceBegin</b> use the containers returned from a previous call.</p>
<p>
As mentioned above, a <a href="strucetc_4y2a.htm"><b>WSAQUERYSET</b></a> structure is used as an input parameter to <b>WSALookupBegin</b> in order to qualify the query. The following table indicates how the <a href="strucetc_4y2a.htm"><b>WSAQUERYSET</b></a> is used to construct a query. When a field is marked as <i>(Optional) </i>a NULL pointer can be supplied, indicating that the field will <i>not</i> be used as a search criteria. See section <a href="ovrvw4_0yya.htm#_win32_query_related_data_structures_2">Query-Related Data Structures</a> for additional information.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=46%>WSAQUERYSET Field Name</th>
<th align=left width=54%>Query Interpretation</th>
</tr>
<tr valign=top>
<td width=46%><i>dwSize</i></td>
<td width=54%>Must be set to sizeof(<b>WSAQUERYSET</b>). This is a versioning mechanism.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwOutputflags</i></td>
<td width=54%>Ignored for queries.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszServiceInstanceName</i></td>
<td width=54%><i>(Optional) </i>Referenced string contains service name. The semantics for wildcarding within the string are not defined, but can be supported by certain name space providers.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpServiceClassId</i></td>
<td width=54%>(<i>Required) </i>The GUID corresponding to the service class.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpVersion</i></td>
<td width=54%><i>(Optional)</i> References desired version number and provides version comparison semantics (that is, version must match exactly, or version must be not less than the value supplied).</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszComment</i></td>
<td width=54%>Ignored for queries.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwNameSpace</i>1</td>
<td width=54%>Identifier of a single name space in which to constrain the search, or NS_ALL to include all name spaces.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpNSProviderId</i></td>
<td width=54%><i>(Optional) </i>References the GUID of a specific name space provider, and limits the query to this provider only.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszContext</i></td>
<td width=54%><i>(Optional) </i>Specifies the starting point of the query in a hierarchical name space.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwNumberOfProtocols</i></td>
<td width=54%>Size of the protocol constraint array, can be zero.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpafpProtocols</i></td>
<td width=54%><i>(Optional) </i>References an array of AFPROTOCOLS structure. Only services that utilize these protocols will be returned.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpszQueryString</i></td>
<td width=54%><i>(Optional) </i>Some namespaces (such as whois++) support enriched SQL like queries that are contained in a simple text string. This parameter is used to specify that string.</td>
</tr>
<tr valign=top>
<td width=46%><i>DwNumberOfCsAddrs</i></td>
<td width=54%>Ignored for queries.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpcsaBuffer</i></td>
<td width=54%>Ignored for queries.</td>
</tr>
<tr valign=top>
<td width=46%><i>LpBlob</i></td>
<td width=54%><i>(Optional) </i>This is a pointer to a provider-specific entity.</td>
</tr>
<tr valign=top>
<td colspan=2 width=100%>1&nbsp;&nbsp;&nbsp;&nbsp;See the Important note below</td>
</tr>
</table><br>
<p>
<b>Important</b>  In most instances, applications interested in only a particular transport protocol should constrain their query by address family and protocol rather than by name space. This would allow an application that needs to locate a TCP/IP service, for example, to have its query processed by all available name spaces such as the local hosts file, DNS, and NIS.</p>
<h4>Return Values</h4>
<p>
The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=46%>WSAEINVAL</td>
<td width=54%>One ormore parameters were missing or invalid for this provider.</td>
</tr>
<tr valign=top>
<td width=46%>WSANO_DATA</td>
<td width=54%>The name was found in the database but no data matching the given restrictions was located.</td>
</tr>
<tr valign=top>
<td width=46%>WSANOTINITIALIZED</td>
<td width=54%>The WS2_32.DLL has not been initialized. The application must first call <a href="wsapiref_1v8y.htm"><b>WSAStartup</b></a> before calling any Windows Sockets functions.</td>
</tr>
<tr valign=top>
<td width=46%>WSASERVICE_NOT_FOUND</td>
<td width=54%>No such service is known. The service cannot be found in the specified name space.</td>
</tr>
<tr valign=top>
<td width=46%>WSA NOT ENOUGH MEMORY</td>
<td width=54%>There was insufficient memory to perform the operation.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_88he.htm"><b>WSALookupServiceEnd</b></a>, <a href="wsapiref_14z6.htm"><b>WSALookupServiceNext</b></a></p>
<p>&nbsp;</p></body>
</HTML>
