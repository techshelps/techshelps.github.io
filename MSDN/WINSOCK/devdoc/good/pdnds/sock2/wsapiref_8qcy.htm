<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>getsockopt</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_getsockopt_2"></a>getsockopt</h1>
<p>
The Windows Sockets <b>getsockopt</b> function retrieves a socket option.</p>
<pre><code><b>int getsockopt (
  SOCKET</b><i> s</i><b>,         </b>
<b>  int</b><i> level</i><b>,        </b>
<b>  int</b><i> optname</i><b>,      </b>
<b>  char FAR*</b><i> optval</i><b>, </b>
<b>  int FAR* </b><i> optlen  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying a socket.</dd>
<dt>
<i>level</i></dt>
<dd>
[in] The level at which the option is defined; the supported levels include SOL_SOCKET and IPPROTO_TCP. See the Windows Sockets 2 Protocol-Specific Annex<i> </i>(a separate document included with the Platform SDK) for more information on protocol-specific levels.</dd>
<dt>
<i>optname</i></dt>
<dd>
[in] The socket option for which the value is to be retrieved.</dd>
<dt>
<i>optval</i></dt>
<dd>
[out] A pointer to the buffer in which the value for the requested option is to be returned.</dd>
<dt>
<i>optlen</i></dt>
<dd>
[in/out] A pointer to the size of the <i>optval</i> buffer.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>getsockopt</b> function retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in <i>optval</i>. Options can exist at multiple protocol levels, but they are always present at the uppermost "socket'' level. Options affect socket operations, such as the packet routing and out-of-band data transfer.</p>
<p>
The value associated with the selected option is returned in the buffer <i>optval</i>. The integer pointed to by <i>optlen</i> should originally contain the size of this buffer; on return, it will be set to the size of the value returned. For SO_LINGER, this will be the size of a <a href="strucetc_5roy.htm"><b>LINGER</b></a> structure. For most other options, it will be the size of an integer.</p>
<p>
The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specified.</p>
<p>
If the option was never set with <a href="wsapiref_94aa.htm"><b>setsockopt</b></a>, then <b>getsockopt</b> returns the default value for the option.</p>
<p>
The following options are supported for <b>getsockopt</b>. The Type column identifies the type of data addressed by <i>optval</i>.</p>
<p>
<b><i>level</i> = SOL_SOCKET</b></p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=31%>Value</th>
<th align=left width=32%>Type</th>
<th align=left width=37%>Meaning</th>
</tr>
<tr valign=top>
<td width=31%>SO_ACCEPTCONN</td>
<td width=32%>BOOL</td>
<td width=37%>Socket is listening.</td>
</tr>
<tr valign=top>
<td width=31%>SO_BROADCAST</td>
<td width=32%>BOOL</td>
<td width=37%>Socket is configured for the transmission of broadcast messages.</td>
</tr>
<tr valign=top>
<td width=31%>SO_DEBUG</td>
<td width=32%>BOOL</td>
<td width=37%>Debugging is enabled. </td>
</tr>
<tr valign=top>
<td width=31%>SO_DONTLINGER</td>
<td width=32%>BOOL</td>
<td width=37%>If true, the SO_LINGER option is disabled.</td>
</tr>
<tr valign=top>
<td width=31%>SO_DONTROUTE</td>
<td width=32%>BOOL</td>
<td width=37%>Routing is disabled.</td>
</tr>
<tr valign=top>
<td width=31%>SO_ERROR</td>
<td width=32%>int</td>
<td width=37%>Retrieve error status and clear.</td>
</tr>
<tr valign=top>
<td width=31%>SO_GROUP_ID</td>
<td width=32%>GROUP</td>
<td width=37%>The identifier of the group to which this socket belongs. </td>
</tr>
<tr valign=top>
<td width=31%>SO_GROUP_PRIORITY</td>
<td width=32%>int</td>
<td width=37%>The relative priority for sockets that are part of a socket group.</td>
</tr>
<tr valign=top>
<td width=31%>SO_KEEPALIVE</td>
<td width=32%>BOOL</td>
<td width=37%>Keepalives are being sent.</td>
</tr>
<tr valign=top>
<td width=31%>SO_LINGER</td>
<td width=32%>struct <a href="strucetc_5roy.htm">LINGER</a> </td>
<td width=37%>Returns the current linger options.</td>
</tr>
<tr valign=top>
<td width=31%>SO_MAX_MSG_SIZE</td>
<td width=32%>unsigned int</td>
<td width=37%>Maximum size of a message for message-oriented socket types (for example, SOCK_DGRAM). Has no meaning for stream oriented sockets.</td>
</tr>
<tr valign=top>
<td width=31%>SO_OOBINLINE</td>
<td width=32%>BOOL</td>
<td width=37%>Out-of-band data is being received in the normal data stream. (See section <a href="ovrvw3_7gfm.htm">Windows Sockets 1.1 Blocking Routines &amp; EINPROGRESS</a> for a discussion of this topic.)</td>
</tr>
<tr valign=top>
<td width=31%>SO_PROTOCOL_INFO</td>
<td width=32%><b>WSAPROTOCOL_INFO</b></td>
<td width=37%>Description of protocol info for protocol that is bound to this socket.</td>
</tr>
<tr valign=top>
<td width=31%>SO_RCVBUF</td>
<td width=32%>int</td>
<td width=37%>Buffer size for receives</td>
</tr>
<tr valign=top>
<td width=31%>SO_REUSEADDR</td>
<td width=32%>BOOL</td>
<td width=37%>The socket can be bound to an address which is already in use.</td>
</tr>
<tr valign=top>
<td width=31%>SO_SNDBUF</td>
<td width=32%>int</td>
<td width=37%>Buffer size for sends</td>
</tr>
<tr valign=top>
<td width=31%>SO_TYPE</td>
<td width=32%>int</td>
<td width=37%>The type of the socket (for example, SOCK_STREAM).</td>
</tr>
<tr valign=top>
<td width=31%>PVD_CONFIG</td>
<td width=32%>Service Provider Dependent</td>
<td width=37%>An "opaque" data structure object from the service provider associated with socket <i>s</i>. This object stores the current configuration information of the service provider. The exact format of this data structure is service provider specific.</td>
</tr>
</table><br>
<p>
<b><i>level</i> = IPPROTO_TCP</b></p>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=31%>TCP_NODELAY</td>
<td width=32%>BOOL</td>
<td width=37%>Disables the Nagle algorithm for send coalescing.</td>
</tr>
</table><br>
<p>
BSD options not supported for <b>getsockopt</b> are:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=36%>Value</th>
<th align=left width=15%>Type</th>
<th align=left width=49%>Meaning</th>
</tr>
<tr valign=top>
<td width=36%>SO_RCVLOWAT</td>
<td width=15%>int</td>
<td width=49%>Receive low water mark</td>
</tr>
<tr valign=top>
<td width=36%>SO_RCVTIMEO</td>
<td width=15%>int</td>
<td width=49%>Receive time-out</td>
</tr>
<tr valign=top>
<td width=36%>SO_SNDLOWAT</td>
<td width=15%>int</td>
<td width=49%>Send low water mark</td>
</tr>
<tr valign=top>
<td width=36%>SO_SNDTIMEO</td>
<td width=15%>int</td>
<td width=49%>Send time-out</td>
</tr>
<tr valign=top>
<td width=36%>TCP_MAXSEG</td>
<td width=15%>int</td>
<td width=49%>Get TCP maximum segment size</td>
</tr>
</table><br>
<p>
Calling <b>getsockopt</b> with an unsupported option will result in an error code of <a href="errors_0oaa.htm#_win32_wsaenoprotoopt_2">WSAENOPROTOOPT</a> being returned from <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.
<dl>
<dt>
SO_DEBUG</dt>
<dd>
Windows Sockets service providers are encouraged (but not required) to supply output debug information if the SO_DEBUG option is set by an application. The mechanism for generating the debug information and the form it takes are beyond the scope of this document.</dd>
<dt>
SO_ERROR</dt>
<dd>
The SO_ERROR option returns and resets the per-socket based error code, which is different from the per-thread based error code that is handled using the <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a> and <a href="wsapiref_7a42.htm"><b>WSASetLastError</b></a> function calls. A successful call using the socket does not reset the socket based error code returned by the SO_ERROR option.</dd>
<dt>
SO_GROUP_ID</dt>
<dd>
This option is reserved for future use with socket groups. This option is also exclusive to <b>getsockopt</b>. It indicates the identifier of the group to which this socket belongs. Socket group IDs are unique across all processes for a given service provider. If this socket is not a group socket, the value is NULL.</dd>
<dt>
SO_GROUP_PRIORITY</dt>
<dd>
This option is reserved for future use with socket groups. Group priority indicates the priority of the specified socket relative to other sockets within the socket group. Values are non-negative integers, with zero corresponding to the highest priority. Priority values represent a hint to the underlying service provider about how potentially scarce resources should be allocated. For example, whenever two or more sockets are both ready to transmit data, the highest priority socket (lowest value for SO_GROUP_PRIORITY) should be serviced first, with the remainder serviced in turn according to their relative priorities.
<p>
The WSAENOPROTOOPT error code is indicated for non group sockets or for service providers that do not support group sockets.
</dd>
<dt>
SO_KEEPALIVE</dt>
<dd>
An application can request that a TCP/IP service provider enable the use of "keep-alive" packets on TCP connections by turning on the SO_KEEPALIVE socket option. A Windows Sockets provider need not support the use of keep-alive: if it does, the precise semantics are implementation-specific but should conform to section 4.2.3.6 of RFC 1122: <i>Requirements for Internet Hosts — Communication Layers</i>. If a connection is dropped as the result of "keep-alives" the error code WSAENETRESET is returned to any calls in progress on the socket, and any subsequent calls will fail with WSAENOTCONN.</dd>
<dt>
SO_LINGER</dt>
<dd>
SO_LINGER controls the action taken when unsent data is queued on a socket and a <b>closesocket</b> is performed. See <a href="wsapiref_714i.htm"><b>closesocket</b></a> for a description of the way in which the SO_LINGER settings affect the semantics of <b>closesocket</b>. The application gets the current behavior by retrieving a <a href="strucetc_5roy.htm"><b>LINGER</b></a> structure (pointed to by the <i>optval</i> parameter).</dd>
<dt>
SO_MAX_MSG_SIZE</dt>
<dd>
This is a get-only socket option that indicates the maximum outbound (send) size of a message for message-oriented socket types (for example, SOCK_DGRAM) as implemented by a particular service provider. It has no meaning for byte stream oriented sockets. There is no provision to find out the maximum inbound message size</dd>
<dt>
SO_PROTOCOL_INFO</dt>
<dd>
This is a get-only option that supplies the <b>WSAPROTOCOL_INFO</b> structure associated with this socket. See <a href="wsapiref_0f76.htm"><b>WSAEnumProtocols</b></a> for more information about this structure.</dd>
<dt>
SO_SNDBUF</dt>
<dd>
When a Windows Sockets implementation supports the SO_RCVBUF and SO_SNDBUF options, an application can request different buffer sizes (larger or smaller). The call to <a href="wsapiref_94aa.htm"><b>setsockopt</b></a> can succeed even if the implementation did not provide the whole amount requested. An application must call this function with the same option to check the buffer size actually provided.</dd>
<dt>
SO_REUSEADDR</dt>
<dd>
By default, a socket cannot be bound (see <a href="wsapiref_6vzm.htm"><b>bind</b></a>) to a local address that is already in use. On occasion, however, it can be necessary to "re-use" an address in this way. Because every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having two sockets bound to the same local address as long as the remote addresses are different. To inform the Windows Sockets provider that a <a href="wsapiref_6vzm.htm"><b>bind</b></a> on a socket should not be disallowed because the desired address is already in use by another socket, the application should set the SO_REUSEADDR socket option for the socket before issuing the <b>bind</b>. Note that the option is interpreted only at the time of the <b>bind</b>: it is therefore unnecessary (but harmless) to set the option on a socket that is not to be bound to an existing address, and setting or resetting the option after the <b>bind</b> has no effect on this or any other socket.</dd>
<dt>
PVD_CONFIG</dt>
<dd>
This option retrieves an "opaque" data structure object from the service provider associated with socket <i>s</i>. This object stores the current configuration information of the service provider. The exact format of this data structure is service provider specific.</dd>
<dt>
TCP_NODELAY</dt>
<dd>
The TCP_NODELAY option is specific to TCP/IP service providers. The Nagle algorithm is disabled if the TCP_NODELAY option is enabled (and vice versa). The Nagle algorithm (described in RFC 896) is very effective in reducing the number of small packets sent by a host. The process involves buffering send data when there is unacknowledged data already "in flight" or buffering send data until a full-size packet can be sent. It is highly recommended that Windows Sockets implementations enable the Nagle Algorithm by default because,for the vast majority of application protocols, the Nagle Algorithm can deliver significant performance enhancements. However, for some applications this algorithm can impede performance, and <a href="wsapiref_94aa.htm"><b>setsockopt</b></a> with the same option can be used to turn it off. These are applications where many small messages are sent, and the time delays between the messages are maintained.</dd>
</dl>
<p>
<b>Windows CE:</b> For IrSockets implementation:
<ul>
<li>
The Af_irda.h file must be explicitly included.</li>
<li>
The WSAENETDOWN return value is not supported.</li>
</ul>
<p>
IrSockets supports several special socket options:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=30%>Value</th>
<th align=left width=26%>Type</th>
<th align=left width=44%>Meaning</th>
</tr>
<tr valign=top>
<td width=30%>IRLMP_ENUMDEVICES</td>
<td width=26%>* DEVICELIST</td>
<td width=44%>Describes devices in range.</td>
</tr>
<tr valign=top>
<td width=30%>IRLMP_IAS_QUERY</td>
<td width=26%>* IAS_QUERY</td>
<td width=44%>Retrieve IAS attributes.</td>
</tr>
<tr valign=top>
<td width=30%>IRLMP_SEND_PDU_LEN</td>
<td width=26%>* int</td>
<td width=44%>Retrieves max number of bytes that can be sent in any one send() call while in  IRLMP_IRLPT_MODE (printing).  This value should be retrieved after the connect() completes but before any data is sent.</td>
</tr>
</table><br>
<p>
The <b>DEVICELIST</b> structure is an extendible array of device descriptions. IrSockets fills in as many device descriptions as can fit in the supplied buffer and returns in the optlen result parameter the required size if the buffer is of insufficient size. The device description consists of a device identifier necessary to form a sockaddr_irda structure and a displayable string describing the device.</p>
<p>
The <b>IAS_QUERY</b> structure is used to retrieve a single attribute of a single class. The application specifies the device and class to query and the attribute and attribute type. It is expected that the application allocates a buffer of the necessary size for the returned parameters.</p>
<p>
Many SO level socket options are not meaningful to IrSockets. Only SO_LINGER and SO_DONTLINGER are specifically supported.</p>
<h4>Return Values</h4>
<p>
If no error occurs, <b>getsockopt</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=41%>WSANOTINITIALISED</td>
<td width=59%>A successful <a href="wsapiref_1v8y.htm"><b>WSAStartup</b></a> must occur before using this function.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEFAULT</td>
<td width=59%>One of the <i>optval </i>or the <i>optlen </i>parameters is not a valid part of the user address space, or the <i>optlen</i> parameter is too small.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINPROGRESS</td>
<td width=59%>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINVAL</td>
<td width=59%>The <i>level</i> parameter is unknown or invalid.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENOPROTOOPT</td>
<td width=59%>The option is unknown or unsupported by the indicated protocol family. </td>
</tr>
<tr valign=top>
<td width=41%>WSAENOTSOCK</td>
<td width=59%>The descriptor is not a socket.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Use version 1.0 and later.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_94aa.htm"><b>setsockopt</b></a>, <a href="wsapiref_2qr6.htm"><b>socket</b></a>, <a href="wsapiref_6jn6.htm"><b>WSAAsyncSelect</b></a>, <a href="wsapiref_8kc2.htm"><b>WSAConnect</b></a>, <a href="wsapiref_2tiq.htm"><b>WSAGetLastError</b></a>, <a href="wsapiref_7a42.htm"><b>WSASetLastError</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
