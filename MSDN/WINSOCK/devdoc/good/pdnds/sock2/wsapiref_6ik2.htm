<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSAIoctl</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsaioctl_2"></a>WSAIoctl</h1>
<p>
The Windows Sockets <b>WSAIoctl</b> function controls the mode of a socket.</p>
<pre><code><b>int WSAIoctl (
  SOCKET</b><i> s</i><b>,                                               </b>
<b>  DWORD</b><i> dwIoControlCode</i><b>,                                  </b>
<b>  LPVOID</b><i> lpvInBuffer</i><b>,                                     </b>
<b>  DWORD</b><i> cbInBuffer</i><b>,                                       </b>
<b>  LPVOID</b><i> lpvOUTBuffer</i><b>,                                    </b>
<b>  DWORD</b><i> cbOUTBuffer</i><b>,                                      </b>
<b>  LPDWORD</b><i> lpcbBytesReturned</i><b>,                              </b>
<b>  LPWSAOVERLAPPED</b><i> lpOverlapped</i><b>,                           </b>
<b>  LPWSAOVERLAPPED_COMPLETION_ROUTINE</b><i> lpCompletionROUTINE  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying a socket.</dd>
<dt>
<i>dwIoControlCode</i></dt>
<dd>
[in] The control code of operation to perform.</dd>
<dt>
<i>lpvInBuffer</i></dt>
<dd>
[in] A pointer to the input buffer.</dd>
<dt>
<i>cbInBuffer</i></dt>
<dd>
[in] A number indicating the size of the input buffer.</dd>
<dt>
<i>lpvOutBuffer</i></dt>
<dd>
[out] A pointer to the output buffer.</dd>
<dt>
<i>cbOutBuffer</i></dt>
<dd>
[in] A number indicating the size of the output buffer.</dd>
<dt>
<i>lpcbBytesReturned</i></dt>
<dd>
[out] A pointer to actual number of bytes of output.</dd>
<dt>
<i>lpOverlapped </i></dt>
<dd>
[in] A pointer to a <a href="strucetc_0gz6.htm"><b>WSAOVERLAPPED</b></a> structure (ignored for non-overlapped sockets).</dd>
<dt>
<i>lpCompletionRoutine</i></dt>
<dd>
[in] A pointer to the completion routine called when the operation has been completed (ignored for non-overlapped sockets).
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>WSAIoctl</b> function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem.</p>
<p>
If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are NULL, the socket in this function will be treated as a non-overlapped socket. For a non-overlapped socket, <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> parameters are ignored, which cause the function to behave like the standard <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a> function except that <b>WSAIoctl</b> can block if socket <i>s</i> is in the blocking mode. If socket <i>s</i> is in the nonblocking mode, this function can return WSAEWOULDBLOCK when the specified operation cannot be finished immediately. In this case, the application may change the socket to the blocking mode and reissue the request or wait for the corresponding network event (such as FD_ROUTING_INTERFACE_CHANGE or FD_ADDRESS_LIST_CHANGE in case of SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE) using Windows message (using <b>WSAAsyncSelect</b>) or event (using <b>WSAEventSelect</b>) based  notification mechanism</p>
<p>
For overlapped sockets, operations that cannot be completed immediately will be initiated, and completion will be indicated at a later time. The final completion status is retrieved through <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a>. The <i>lpcbBytesReturned</i> parameter is ignored.</p>
<p>
Any ioctl may block indefinitely, depending on the service provider's implementation.  If the application cannot tolerate blocking in a <b>WSAIoctl</b> call, overlapped I/O would be advised for ioctls that are especially likely to block including:</p>
<p>
SIO_FINDROUTE<br>
SIO_FLUSH<br>
SIO_GET_QOS<br>
SIO_GET_GROUP_QOS<br>
SIO_SET_QOS<br>
SIO_SET_GROUP_QOS<br>
SIO_ROUTING_INTERFACE_CHANGE<br>
SIO_ADDRESS_LIST_CHANGE</p>
<p>
Some protocol-specific ioctls may also be especially likely to block. Check the relevant protocol-specific annex for any available information.</p>
<p>
It is possible to adopt an encoding scheme that preserves the currently defined <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a> opcodes while providing a convenient way to partition the opcode identifier space in as much as the <i>dwIoControlCode </i>parameter is now a 32-bit entity. The <i>dwIoControlCode</i> parameter is architected to allow for protocol and vendor independence when adding new control codes while retaining backward compatibility with the Windows Sockets 1.1 and Unix control codes. The <i>dwIoControlCode</i> parameter has the following form:</p>
<table cellspacing=4 cols=6>
<tr valign=top>
<td width=4%>3</td>
<td width=5%>3</td>
<td width=6%>2</td>
<td width=7%>2 2</td>
<td width=36%>2 2 2 2 2 2 2 1 1 1 1</td>
<td width=42%>1 1 1 1 1 1</td>
</tr>
<tr valign=top>
<td width=4%>1</td>
<td width=5%>0</td>
<td width=6%>9</td>
<td width=7%>8 7</td>
<td width=36%>6 5 4 3 2 1 0 9 8 7 6</td>
<td width=42%>5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0</td>
</tr>
<tr valign=top>
<td width=4%><b>I</b></td>
<td width=5%><b>O</b></td>
<td width=6%><b>V</b></td>
<td width=7%><b>T</b></td>
<td width=36%><b>Vendor/Address Family</b></td>
<td width=42%><b>Code</b></td>
</tr>
</table><br>
<p>
<b>I</b> is set if the input buffer is valid for the code, as with <b>IOC_IN</b>.</p>
<p>
<b>O</b> is set if the output buffer is valid for the code, as with <b>IOC_OUT</b>. Codes with both input and output parameters set both <b>I</b> and <b>O</b>.</p>
<p>
<b>V</b> is set if there are no parameters for the code, as with <b>IOC_VOID</b>.</p>
<p>
<b>T</b> is a two-bit quantity that defines the type of ioctl. The following values are defined:</p>
<p>
<b>0</b> – The ioctl is a standard Unix ioctl code, as with FIONREAD and FIONBIO.</p>
<p>
<b>1</b> – The ioctl is a generic Windows Sockets 2 ioctl code. New ioctl codes defined for Windows Sockets 2 will have <b>T</b> == <b>1</b>.</p>
<p>
<b>2</b> – The ioctl applies only to a specific address family.</p>
<p>
<b>3</b> – The ioctl applies only to a specific vendor's provider. This type allows companies to be assigned a vendor number that appears in the <b>Vendor/Address family</b> field. Then, the vendor can define new ioctls specific to that vendor without having to register the ioctl with a clearinghouse, thereby providing vendor flexibility and privacy.</p>
<p>
<b>Vendor/Address family</b> – An 11-bit quantity that defines the vendor who owns the code (if <b>T</b> == <b>3</b>) or that contains the address family to which the code applies (if <b>T</b> == <b>2</b>). If this is a Unix ioctl code (<b>T</b> == <b>0</b>) then this field has the same value as the code on Unix. If this is a generic Windows Sockets 2 ioctl (<b>T</b> == <b>1</b>) then this field can be used as an extension of the "code" field to provide additional code values.</p>
<p>
<b>Code</b> – The 16-bit quantity that contains the specific ioctl code for the operation.</p>
<p>
The following Unix ioctl codes (commands) are supported:
<dl>
<dt>
FIONBIO</dt>
<dd>
Enable or disable nonblocking mode on socket <i>s</i>. <i>lpvInBuffer</i> points at an <b>unsigned</b> <b>long</b>, which is nonzero if nonblocking mode is to be enabled and zero if it is to be disabled. When a socket is created, it operates in blocking mode (that is, nonblocking mode is disabled). This is consistent with BSD sockets.
<p>
The <a href="wsapiref_6jn6.htm"><b>WSAAsyncSelect</b></a> or <a href="wsapiref_34aa.htm"><b>WSAEventSelect</b></a> routine automatically sets a socket to nonblocking mode. If <b>WSAAsyncSelect</b> or <b>WSAEventSelect</b> has been issued on a socket, then any attempt to use <b>WSAIoctl</b> to set the socket back to blocking mode will fail with WSAEINVAL. To set the socket back to blocking mode, an application must first disable <b>WSAAsyncSelect</b> by calling <b>WSAAsyncSelect</b> with the <i>lEvent</i> parameter equal to zero, or disable <b>WSAEventSelect</b> by calling <b>WSAEventSelect</b> with the <i>lNetworkEvents</i> parameter equal to zero.
</dd>
<dt>
FIONREAD</dt>
<dd>
Determine the amount of data that can be read atomically from socket <i>s</i>. <i>lpvOutBuffer</i> points at an <b>unsigned long</b> in which <b>WSAIoctl</b> stores the result. If <i>s</i> is stream oriented (for example, type SOCK_STREAM), FIONREAD returns the total amount of data that can be read in a single receive operation; this is normally the same as the total amount of data queued on the socket (since data stream is byte-oriented, this is not guaranteed). If <i>s</i> is message oriented (for example, type SOCK_DGRAM), FIONREAD returns the size of the first datagram (message) queued on the socket.</dd>
<dt>
SIOCATMARK</dt>
<dd>
Determine whether or not all out-of-band data has been read. This applies only to a socket of stream-style (for example, type SOCK_STREAM) that has been configured for in-line reception of any out-of-band data (SO_OOBINLINE). If no out-of-band data is waiting to be read, the operation returns TRUE. Otherwise, it returns FALSE, and the next receive operation performed on the socket will retrieve some or all of the data preceding the "mark"; the application should use the SIOCATMARK operation to determine whether any remains. If there is any normal data preceding the "urgent" (out of band) data, it will be received in order. (Note that receive operations will never mix out-of-band and normal data in the same call.) <i>lpvOutBuffer</i> points at a <b>BOOL</b> in which <b>WSAIoctl</b> stores the result.
</dd>
</dl>
<p>
The following Windows Sockets 2 commands are supported:
<dl>
<dt>
SIO_ASSOCIATE_HANDLE (opcode setting: I, T==1)</dt>
<dd>
Associate this socket with the specified handle of a companion interface. The input buffer contains the integer value corresponding to the manifest constant for the companion interface (for example, TH_NETDEV and TH_TAPI.), followed by a value that is a handle of the specified companion interface, along with any other required information. Refer to the appropriate section in the Windows Sockets 2 Protocol-Specific Annex (a separate document) for details specific to a particular companion interface. The total size is reflected in the input buffer length. No output buffer is required. The WSAENOPROTOOPT error code is indicated for service providers that do not support this ioctl. The handle associated by this ioctl can be retrieved using SIO_TRANSLATE_HANDLE.
<p>
A companion interface might be used, for example, if a particular provider provides (1) a great deal of additional controls over the behavior of a socket and (2) the controls are provider-specific enough that they do not map to existing Windows Socket functions or ones likely to be defined in the future. It is recommend that the Component Object Model (COM) be used instead of this ioctl to discover and track other interfaces that might be supported by a socket. This ioctl is present for (reverse) compatibility with systems where COM is not available or cannot be used for some other reason.
</dd>
<dt>
SIO_ENABLE_CIRCULAR_QUEUEING (opcode setting: V, T==1)</dt>
<dd>
Indicates to the underlying message-oriented service provider that a newly arrived message should never be dropped because of a buffer queue overflow. Instead, the oldest message in the queue should be eliminated in order to accommodate the newly arrived message. No input and output buffers are required. Note that this ioctl is only valid for sockets associated with unreliable, message-oriented protocols. The WSAENOPROTOOPT error code is indicated for service providers that do not support this ioctl.</dd>
<dt>
SIO_FIND_ROUTE (opcode setting: O, T==1)</dt>
<dd>
When issued, this ioctl requests that the route to the remote address specified as a <a href="strucetc_0d82.htm"><b>SOCKADDR</b></a> in the input buffer be discovered. If the address already exists in the local cache, its entry is invalidated. In the case of Novell's IPX, this call initiates an IPX GetLocalTarget (GLT), which queries the network for the given remote address.</dd>
<dt>
SIO_FLUSH (opcode setting: V, T==1)</dt>
<dd>
Discards current contents of the sending queue associated with this socket. No input and output buffers are required. The WSAENOPROTOOPT error code is indicated for service providers that do not support this ioctl.</dd>
<dt>
SIO_GET_BROADCAST_ADDRESS (opcode setting: O, T==1)</dt>
<dd>
This ioctl fills the output buffer with a <a href="strucetc_0d82.htm"><b>SOCKADDR</b></a> structure containing a suitable broadcast address for use with <a href="wsapiref_4sqa.htm"><b>sendto</b></a>/<a href="wsapiref_752q.htm"><b>WSASendTo</b></a>.</dd>
<dt>
SIO_GET_EXTENSION_FUNCTION_POINTER (opcode setting: O, I, T==1)</dt>
<dd>
Retrieve a pointer to the specified extension function supported by the associated service provider. The input buffer contains a globally unique identifier (GUID) whose value identifies the extension function in question. The pointer to the desired function is returned in the output buffer. Extension function identifiers are established by service provider vendors and should be included in vendor documentation that describes extension function capabilities and semantics.</dd>
<dt>
SIO_GET_QOS (opcode setting: O, T==1)</dt>
<dd>
Reserved for future use with sockets. Retrieve the <a href="strucetc_6sc2.htm"><b>QUALITYOFSERVICE</b></a> structure associated with the socket. The input buffer is optional. Some protocols (for example, RSVP) allow the input buffer to be used to qualify a quality of service request. The <b>QUALITYOFSERVICE</b> structure will be copied into the output buffer. The output buffer must be sized large enough to be able to contain the full <b>QUALITYOFSERVICE</b> structure. The WSAENOPROTOOPT error code is indicated for service providers that do not support quality of service.</dd>
<dt>
SIO_GET_GROUP_QOS (opcode setting: O, I, T==1)</dt>
<dd>
Retrieve the <a href="strucetc_6sc2.htm"><b>QUALITYOFSERVICE</b></a> structure associated with the socket group to which this socket belongs. The input buffer is optional. Some protocols (for example, RSVP) allow the input buffer to be used to qualify a quality of service request. The <b>QUALITYOFSERVICE</b> structure will be copied into the output buffer. If this socket does not belong to an appropriate socket group, the <i>SendingFlowspec</i> and <i>ReceivingFlowspec </i>fields of the returned <b>QUALITYOFSERVICE</b> structure are set to NULL. The WSAENOPROTOOPT error code is indicated for service providers that do not support quality of service.</dd>
<dt>
SIO_MULTIPOINT_LOOPBACK (opcode setting: I, T==1)</dt>
<dd>
Controls whether data sent in a multipoint session will also be received by the same socket on the local host. A value of TRUE causes loopback reception to occur while a value of FALSE prohibits this. By default, loopback is enabled.</dd>
<dt>
SIO_MULTICAST_SCOPE (opcode setting: I, T==1)</dt>
<dd>
Specifies the scope over which multicast transmissions will occur. Scope is defined as the number of routed network segments to be covered. A scope of zero would indicate that the multicast transmission would not be placed "on the wire" but could be disseminated across sockets within the local host. A scope value of one (the default) indicates that the transmission will be placed on the wire, but will <i>not</i> cross any routers. Higher scope values determine the number of routers that can be crossed. Note that this corresponds to the time-to-live (TTL) parameter in IP multicasting. By default, scope is 1.</dd>
<dt>
SIO_SET_QOS (opcode setting: I, T==1)</dt>
<dd>
Associate the supplied <a href="strucetc_6sc2.htm"><b>QUALITYOFSERVICE</b></a> structure with the socket. No output buffer is required, the <b>QUALITYOFSERVICE</b> structure will be obtained from the input buffer. The WSAENOPROTOOPT error code is indicated for service providers that do not support quality of service.</dd>
<dt>
SIO_SET_GROUP_QOS(opcode setting: I, T==1)</dt>
<dd>
Reserved for future use with sockets. Establish the supplied <a href="strucetc_6sc2.htm"><b>QUALITYOFSERVICE</b></a> structure with the socket group to which this socket belongs. No output buffer is required, the <b>QUALITYOFSERVICE</b> structure will be obtained from the input buffer. The WSAENOPROTOOPT error code is indicated for service providers that do not support quality of service, or if the socket descriptor specified is not the creator of the associated socket group.</dd>
<dt>
SIO_TRANSLATE_HANDLE (opcode setting: I, O, T==1)</dt>
<dd>
To obtain a corresponding handle for socket <i>s</i> that is valid in the context of a companion interface (for example, TH_NETDEV and TH_TAPI). A manifest constant identifying the companion interface along with any other needed parameters are specified in the input buffer. The corresponding handle will be available in the output buffer upon completion of this function. Refer to the appropriate section in Windows Sockets 2 Protocol-Specific Annex<i> </i>for details specific to a particular companion interface. The WSAENOPROTOOPT error code is indicated for service providers that do not support this ioctl for the specified companion interface.This ioctl retrieves the handle associated using SIO_TRANSLATE_HANDLE.
<p>
It is recommend that the Component Object Model (COM) be used instead of this ioctl to discover and track other interfaces that might be supported by a socket. This ioctl is present for (reverse) compatibility with systems where COM is not available or cannot be used for some other reason.
</dd>
<dt>
SIO_ROUTING_INTERFACE_QUERY (opcode setting: I, O, T==1) </dt>
<dd>
To obtain the address of the local interface (represented as SOCKADDR structure) which should be used to send to the remote address specified in the input buffer (as SOCKADDR). Remote multicast addresses may be submitted in the input buffer to get the address of the preferred interface for multicast transmission.  In any case, the interface address returned may be used by the application in a subsequent bind() request.
<p>
Note that routes are subject to change. Therefore, applications cannot rely on the information returned by  SIO_ROUTING_INTERFACE_QUERY to be persistent. Applications may register for routing change notifications via the SIO_ROUTING_INTERFACE_CHANGE IOCTL which provides for notification via either overlapped IO or FD_ROUTING_INTERFACE_CHANGE event. The following sequence of actions can be used to guarantee that the application always has current routing interface information for a given destination: 

<ul>
<li>
issue SIO_ROUTING_INTERFACE_CHANGE IOCTL</li>
<li>
issue SIO_ROUTING_INTERFACE_QUERY IOCTL</li>
<li>
whenever SIO_ROUTING_INTERFACE_CHANGE IOCTL notifies the application of routing change (either via overlapped IO or by signaling FD_ROUTING_INTERFACE_CHANGE event), the whole sequence of actions should be repeated.</li>
</ul>

<p>
If output buffer is not large enough to contain the interface address, SOCKET_ERROR is returned as the result of this IOCTL and <b>WSAGetLastError</b> returns WSAEFAULT. The required size of the output buffer will be returned in <i>lpcbBytesReturned</i> in this case. Note the WSAEFAULT error code is also returned if the <i>lpvInBuffer</i>, <i>lpvOutBuffer</i> or <i>lpcbBytesReturned</i> parameter is not totally contained in a valid part of the user address space.

<p>
If the destination address specified in the input buffer cannot be reached via any of the available interfaces, SOCKET_ERROR is returned as the result of this IOCTL and <b>WSAGetLastError</b> returns WSAENETUNREACH or even WSAENETDOWN if all of the network connectivity is lost.
</dd>
<dt>
SIO_ROUTING_INTERFACE_CHANGE (opcode setting: I, T==1) </dt>
<dd>
To receive notification of the interface change that should be used to reach the remote address in the input buffer (specified as a SOCKADDR structure). No output information will be provided upon completion of this IOCTL; the completion merely indicates that routing interface for a given destination has changed and should be queried again via SIO_ROUTING_INTERFACE_QUERY. 
<p>
It is assumed (although not required) that the application uses overlapped IO to be notified of routing interface change via completion of SIO_ROUTING_INTERFACE_CHANGE request. Alternatively, if the SIO_ROUTING_INTERFACE_CHANGE IOCTL is issued on non-blocking socket <i>and</i> without overlapped parameters (<i>lpOverlapped</i> / <i>CompletionRoutine</i> are set NULL), it will complete immediately with error WSAEWOULDBLOCK, and the application can then wait for routing change events via call to <b>WSAEventSelect</b> or <b>WSAAsyncSelect</b> with FD_ROUTING_INTERFACE_CHANGE bit set in the network event bitmask

<p>
It is recognized that routing information remains stable in most cases so that requiring the application to keep multiple outstanding IOCTLs to get notifications about all destinations that it is interested in as well as having service provider to keep track of all them will unnecessarily tie significant system resources. This situation can be avoided by extending the meaning of the input parameters and relaxing the service provider requirements as follows:

<ul>
<li>
The application can specify a protocol family specific wildcard address (same as one used in <b>bind</b> call when requesting to bind to any available address) to request notifications of any routing changes.  This allows the application to keep only one outstanding SIO_ROUTING_INTERFACE_CHANGE for all the sockets/destinations it has and then use SIO_ROUTING_INTERFACE_QUERY to get the actual routing information</li>
<li>
Service provider has the option to ignore the information supplied by the application in the input buffer of the SIO_ROUTING_INTERFACE_CHANGE  (as though the application specified a wildcard address) and complete the SIO_ROUTING_INTERFACE_CHANGE IOCTL or signal FD_ROUTING_INTERFACE_CHANGE event in the event of any routing information change (not just the route to the destination specified in the input buffer). </li>
</ul>
</dd>
<dt>
SIO_ADDRESS_LIST_QUERY (opcode setting: I, O, T==1) </dt>
<dd>
To obtain a list of local transport addresses of socket's protocol family to which the application can bind. The list returned in the output buffer using the following format:
<pre><code>typedef struct _SOCKET_ADDRESS_LIST {
    INT iAddressCount;
    SOCKET_ADDRESS Address[1];
} SOCKET_ADDRESS_LIST, FAR * LPSOCKET_ADDRESS_LIST;
Members:
    iAddressCount - number of address structures in the list;
    Address - array of protocol family specific address structures.
</code></pre>

<p>
Note that in Win32 Plug-n-Play environments addresses can be added/removed dynamically. Therefore, applications cannot rely on the information returned by  SIO_ADDRESS_LIST_QUERY to be persistent.  Applications may register for address change notifications via the SIO_ADDRESS_LIST_CHANGE IOCTL which provides for notification via either overlapped IO or FD_ADDRESS_LIST_CHANGE event. The following sequence of actions can be used to guarantee that the application always has current address list information:<font face="Symbol">·</font>issue SIO_ADDRESS_LIST_CHANGE IOCTL

<ul>
<li>
issue SIO_ADDRESS_LIST_QUERY IOCTL</li>
<li>
whenever SIO_ADDRESS_LIST_CHANGE IOCTL notifies the application of address list change (either via overlapped IO or by signaling FD_ADDRESS_LIST_CHANGE event), the whole sequence of actions should be repeated.</li>
</ul>

<p>
If output buffer is not large enough to contain the address list, SOCKET_ERROR is returned as the result of this IOCTL and <b>WSAGetLastError</b> returns WSAEFAULT.  The required size of the output buffer will be returned in <i>lpcbBytesReturned</i> in this case. Note the WSAEFAULT error code is also returned if the lpvInBuffer, <i>lpvOutBuffer</i> or <i>lpcbBytesReturned</i> parameter is not totally contained in a valid part of the user address space.
</dd>
<dt>
SIO_ADDRESS_LIST_CHANGE (opcode setting: T==1) </dt>
<dd>
To receive notification of changes in the list of local transport addresses of socket's protocol family to which the application can bind.  No output information will be provided upon completion of this IOCTL; the completion merely indicates that list of available local address has changed and should be queried again via SIO_ADDRESS_LIST_QUERY.
<p>
It is assumed (although not required) that the application uses overlapped IO to be notified of change via completion of SIO_ADDRESS_LIST_CHANGE request. Alternatively, if the SIO_ADDRESS_LIST_CHANGE IOCTL is issued on non-blocking socket AND without overlapped parameters (<i>lpOverlapped</i> / <i>lpCompletionRoutine</i> are set to NULL), it will complete immediately with error WSAEWOULDBLOCK. The application can then wait for address list change events via call to <b>WSAEventSelect</b> or <b>WSAAsyncSelect</b> with FD_ADDRESS_LIST_CHANGE bit set in the network event bitmask.

</dd>
</dl>
<p>
If an overlapped operation completes immediately, <b>WSAIoctl</b> returns a value of zero and the <i>lpcbBytesReturned</i> parameter is updated with the number of bytes in the output buffer. If the overlapped operation is successfully initiated and will complete later, this function returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, <i>lpcbBytesReturned</i> is not updated. When the overlapped operation completes the amount of data in the output buffer is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a>.</p>
<p>
When called with an overlapped socket, the <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. The <i>lpOverlapped </i>parameter contains the address of a <a href="strucetc_0gz6.htm"><b>WSAOVERLAPPED</b></a> structure. </p>
<p>
If the <i>lpCompletionRoutine</i> parameter is NULL, the <i>hEvent</i> field of <i>lpOverlapped</i> is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use <a href="wsapiref_1p4i.htm"><b>WSAWaitForMultipleEvents</b></a> or <a href="wsapiref_5kky.htm"><b>WSAGetOverlappedResult</b></a> to wait or poll on the event object.</p>
<p>
If <i>lpCompletionRoutine</i> is not NULL, the <i>hEvent</i> field is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL <i>lpCompletionRoutine</i> and later calls <b>WSAGetOverlappedResult</b> for the same overlapped IO request may not set the <i>fWait</i> parameter for that invocation of <b>WSAGetOverlappedResult</b> to TRUE. In this case the usage of the <i>hEvent</i> field is undefined, and attempting to wait on the <i>hEvent</i> field would produce unpredictable results.</p>
<p>
The prototype of the completion routine is as follows:</p>
<pre><code><b>void CALLBACK CompletionRoutine(
  IN  DWORD </b><i>dwError</i><b>, </b>
<b>  IN  DWORD </b><i>cbTransferred</i><b>, </b>
<b>  IN  LPWSAOVERLAPPED </b><i>lpOverlapped</i><b>, </b>
<b>  IN  DWORD </b><i>dwFlags</i><b> </b>
<b>);</b>
</code></pre>
<p>
This <b>CompletionRoutine</b> is a placeholder for an application-defined or library-defined function. The <i>dwError</i> parameter specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. The <i>cbTransferred</i> parameter specifies the number of bytes returned. Currently, there are no flag values defined and <i>dwFlags</i> will be zero. The CompletionRoutine function does not return a value.</p>
<p>
Returning from this function allows invocation of another pending completion routine for this socket. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed.</p>
<p>
<b>Windows CE:</b> For secure sockets, the <i>lpcbBytesReturned</i> parameter is a pointer to a DWORD receiving the number of bytes returned in output buffer. Also, the last two parameters, namely, <i>lpOverlapped</i> and <i>lpCompletionRoutine</i>, must be NULL.</p>
<p>
In addition to the <b>ioctlsocket</b> control codes (FIONBIO, SIOCATMARK, FIONREAD), the <i>dwIoControlCode</i> parameter may also assume the following SSL-specific control flags:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=38%>Value</th>
<th align=left width=62%>Meaning</th>
</tr>
<tr valign=top>
<td width=38%>SO_SSL_GET_CAPABILITIES</td>
<td width=62%>Retrieves a set of flags describing the WinSock security provider's capabilities. The output buffer must be a pointer to a DWORD bit field. At present, only the SO_CAP_CLIENT flag is defined. </td>
</tr>
<tr valign=top>
<td width=38%>SO_SSL_GET_FLAGS</td>
<td width=62%>Retrieves <i>s</i>-channel specific flags associated with a particular socket. The output buffer must be a pointer to a DWORD bit field. See SO_SSL_SET_FLAGS for details on valid flags.</td>
</tr>
<tr valign=top>
<td width=38%>SO_SSL_SET_FLAGS</td>
<td width=62%>Sets the sockets' current <i>s</i>-channel-specific flag values. The input buffer must be a pointer to a DWORD bit field. Currently, only the SSL_FLAG_DEFER_HANDSHAKE flag is defined to allow the application to send and receive plain text data before switching to cipher text. It is required for setting up communication through proxy servers.<p>
Normally the WinSock security provider performs the secure handshake in the WinSock connect API. However, if this flag is set, the handshake is deferred until the application issues the SO_SSL_PERFORM_HANDSHAKE control code. After the handshaking, this flag is reset. </p>
</td>
</tr>
<tr valign=top>
<td width=38%>SO_SSL_GET_PROTOCOLS</td>
<td width=62%>Retrieves a list of protocols that the provider currently supports on this socket. The output buffer must be a pointer to a SSLPROTOCOLS structure as described below:<pre><code>typedef struct _SSLPROTOCOL {
     DWORD dwProtocol;
     DWORD dwVersion;
     DWORD dwFlags;
} SSLPROTOCOL, *LPSSLPROTOCOL;
typedef struct _SSLPROTOCOLS {
     DWORD dwCount;
     SSLPROTOCOL ProtocolList[1];
} SSLPROTOCOLS, FAR *LPSSLPROTOCOLS;</code></pre>
<p>
Valid protocols include SSL_PROTOCOL_SSL2, SSL_PROTOCOL_SSL3, and SSL_PROTOCOL_PCT1.</p>
</td>
</tr>
<tr valign=top>
<td width=38%>SO_SSL_SET_PROTOCOLS</td>
<td width=62%>Specifies a list of protocols the provider is to support on this socket. The input buffer must be a pointer to SSLPROTOCOLS structure described above.</td>
</tr>
<tr valign=top>
<td width=38%>SO_SSL_SET_VALIDATE_CERT_HOOK</td>
<td width=62%>Sets the pointer to the socket's certificate validation hook. It is used to specify the callback function invoked by the WinSock security provider when a set of credentials is received from the remote party. The input buffer must be a pointer to the SSLVALIDEATECERTHOOK structure, described below:<pre><code>typedef struct {
      SSLVALIDATECERTFUNC HookFunc;
      LPVOID pvArg;
} SSLVALIDATEPROTOCOLCERTHOOK, *PSSLVALIDATECERTHOOK;</code></pre>
<p>
where <i>HookFunc</i> is a pointer to the certificate validation callback function (see "Certificate Validation Callback" below). <i>pvArg</i> is a pointer to application specific data and may be used by the application for any purpose.</p>
</td>
</tr>
<tr valign=top>
<td width=38%>SO_SSL_PERFORM_HANDSHAKE</td>
<td width=62%>Initiates the secure handshake sequence on a connected socket where the SSL_FLAG_DEFER_HANDSHAKE flag has been set prior to the connection. Data buffers are not required, but the SSL_FLAG_DEFER_HANDSHAKE flag will be reset. </td>
</tr>
</table><br>
<p>
<b>Certificate Validation Callback</b></p>
<p>
The WinSock security provider invokes the certificate validation callback when the remote party receives a certificate for server authentication. All the client applications must implement the callback function to ensure that the certificate should meet the following minimum requirements:
<ul>
<li>
The certificate has not expired;</li>
<li>
The identity contained within the certificate matches that of the remote party.</li>
</ul>
<p>
The certificate validation callback function is of the following type:</p>
<p>
<b>typedef int (CALLBACK *SSLVALIDATECERTFUNC){</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>DWORD</b>  &nbsp;&nbsp;&nbsp;&nbsp;<i>dwType</i>,      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>LPVOID</b> &nbsp;&nbsp;&nbsp;&nbsp;<i>pvArg</i>,       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>DWORD</b>  &nbsp;&nbsp;&nbsp;&nbsp;<i>dwChainLen</i>,  &nbsp;&nbsp;&nbsp;&nbsp;// in<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>LPBLOB</b> &nbsp;&nbsp;&nbsp;&nbsp;<i>pCertChain</i>,  &nbsp;&nbsp;&nbsp;&nbsp;// in<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>DWORD</b> &nbsp;&nbsp;&nbsp;&nbsp;<i>dwFlags</i>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in<br>
<b>};</b></p>
<p>
The parameters are defined in the following table.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=21%>Parameters</th>
<th align=left width=79%>Meaning</th>
</tr>
<tr valign=top>
<td width=21%><i>dwType</i></td>
<td width=79%>Specifies the type of data pointed to be <i>pCertChain</i>. This must be SSL_CERT_X59 to specify that <i>pCertChain</i> be a pointer to an X509 style certificate.</td>
</tr>
<tr valign=top>
<td width=21%><i>PvArg</i></td>
<td width=79%>An application-defined context passed into the SSLVALIDATECERTHOOK structure.</td>
</tr>
<tr valign=top>
<td width=21%><i>DwChainLen</i></td>
<td width=79%>The number of certificates pointed to by <i>pCertChain</i>. In Windows CE this will always be one.</td>
</tr>
<tr valign=top>
<td width=21%><i>PCertChain</i></td>
<td width=79%>Pointer to the remote party's certificate.</td>
</tr>
<tr valign=top>
<td width=21%><i>DwFlags</i></td>
<td width=79%>To be designed to indicate that the certificate issuer list has been checked with the list of known certificate authorities and that the certificate is either trusted or not. This is required since not all the certificate chain is passed to the application.</td>
</tr>
</table><br>
<p>
The application-defined callback function will typically return one of the following error codes:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=40%>Value</th>
<th align=left width=60%>Meaning</th>
</tr>
<tr valign=top>
<td width=40%>SSL_ERR_OKAY</td>
<td width=60%>The remote party's certificate is acceptable.</td>
</tr>
<tr valign=top>
<td width=40%>SSL_ERR_BAD_DATA</td>
<td width=60%>The certificate is improperly formatted.</td>
</tr>
<tr valign=top>
<td width=40%>SSL_ERR_BAD_SIG</td>
<td width=60%>The signature check fails.</td>
</tr>
<tr valign=top>
<td width=40%>SSL_ERR_CERT_EXPIRED</td>
<td width=60%>The certificate has expired.</td>
</tr>
<tr valign=top>
<td width=40%>SSL_ERR_CERT_REVOKED</td>
<td width=60%>The certificate has been revoked by its issuer.</td>
</tr>
<tr valign=top>
<td width=40%>SSL_ERR_CERT_UNKNOWN</td>
<td width=60%>The issuer of the certificate is not recognized or some unspecified issue arose in the processing of the certificate, rendering it unacceptable.</td>
</tr>
</table><br>
<h4>Compatibility</h4>
<p>
The ioctl codes with <b>T</b> == <b>0 </b>are a subset of the ioctl codes used in Berkeley sockets. In particular, there is no command that is equivalent to FIOASYNC.</p>
<h4>Return Values</h4>
<p>
Upon successful completion, the <b>WSAIoctl</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling <b>WSAGetLastError</b>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=41%>WSAENETDOWN</td>
<td width=59%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEFAULT</td>
<td width=59%>The <i>lpvInBuffer</i>, <i>lpvOutBuffer</i> <i>lpcbBytesReturned</i>, <i>lpOverlapped</i>, or <i>lpCompletionRoutine</i> argument is not totally contained in a valid part of the user address space, or the <i>cbInBuffer</i> or <i>cbOutBuffer</i> argument is too small.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINVAL</td>
<td width=59%><i>dwIoControlCode</i> is not a valid command, or a<i> </i>supplied input parameter is not acceptable, or the command is not applicable to the type of socket supplied.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEINPROGRESS</td>
<td width=59%>The function is invoked when a callback is in progress.</td>
</tr>
<tr valign=top>
<td width=41%>WSAENOTSOCK</td>
<td width=59%>The descriptor <i>s</i> is not a socket.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEOPNOTSUPP</td>
<td width=59%>The specified ioctl command cannot be realized. (For examle, the <a href="strucetc_77qq.htm"><b>FLOWSPEC</b></a> structures specified in SIO_SET_QOS or SIO_SET_GROUP_QOS cannot be satisfied.)</td>
</tr>
<tr valign=top>
<td width=41%>WSA_IO_PENDING</td>
<td width=59%>An overlapped operation was successfully initiated and completion will be indicated at a later time.</td>
</tr>
<tr valign=top>
<td width=41%>WSAEWOULDBLOCK</td>
<td width=59%>The socket is marked as nonblocking and the requested operation would block.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in winsock2.h.<br>
&nbsp;&nbsp;<b>Import Library:</b> Link with ws2_32.lib.</p>
<h4>See Also</h4>
<p>
<a href="wsapiref_8qcy.htm"><b>getsockopt</b></a>, <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a>, <a href="wsapiref_94aa.htm"><b>setsockopt</b></a>, <a href="wsapiref_2qr6.htm"><b>socket</b></a>, <a href="wsapiref_533m.htm"><b>WSASocket</b></a></p>
<p>&nbsp;</p></body>
</HTML>
