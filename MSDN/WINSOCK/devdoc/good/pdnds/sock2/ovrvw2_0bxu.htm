<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Overlapped I/O and Event Objects</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_overlapped_i_o_and_event_objects_2"></a>Overlapped I/O and Event Objects</h2>
<p>
Windows Sockets 2 introduces overlapped I/O and requires that all transport providers support this capability. Overlapped I/O follows the model established in Win32 and can be performed only on sockets created through the <a href="wsapiref_533m.htm"><b>WSASocket</b></a> function with the WSA_FLAG_OVERLAPPED flag set or sockets created through the <a href="wsapiref_2qr6.htm"><b>socket</b></a><b> </b>function.</p>
<p>
<b>Note</b>  Creating a socket with the overlapped attribute has no impact on whether a socket is currently in the blocking or nonblocking mode. Sockets created with the overlapped attribute can be used to perform overlapped I/O—doing so does not change the blocking mode of a socket. Since overlapped I/O operations do not block, the blocking mode of a socket is irrelevant for these operations.</p>
<p>
For receiving, applications use the <a href="wsapiref_4z1u.htm"><b>WSARecv</b></a> or <a href="wsapiref_4wky.htm"><b>WSARecvFrom</b></a> functions to supply buffers into which data is to be received. If one or more buffers are posted prior to the time when data has been received by the network, that data could be placed in the user's buffers immediately as it arrives. Thus, it can avoid the copy operation that would otherwise occur at the time the <a href="wsapiref_2i9e.htm"><b>recv</b></a> or <a href="wsapiref_88oi.htm"><b>recvfrom</b></a> function is invoked. If data is already present when receive buffers are posted, it is copied immediately into the user's buffers.</p>
<p>
If data arrives when no receive buffers have been posted by the application, the network resorts to the familiar synchronous style of operation. That is, the incoming data is buffered internally until the application issues a receive call and thereby supplies a buffer into which the data can be copied. An exception to this is when the appliation uses <a href="wsapiref_94aa.htm"><b>setsockopt</b></a> to set the size of the receive buffer to zero. In this instance, reliable protocols would only allow data to be received when application buffers had been posted and data on unreliable protocols would be lost.</p>
<p>
On the sending side, applications use <a href="wsapiref_97n6.htm"><b>WSASend</b></a> or <a href="wsapiref_752q.htm"><b>WSASendTo</b></a> to supply pointers to filled buffers and then agree to not disturb the buffers in any way until the network has consumed the buffer's contents. </p>
<p>
Overlapped send and receive calls return immediately. A return value of zero indicates that the I/O operation was completed immediately and that the corresponding completion indication already occurred. That is, the associated event object has been signaled, or a completion routine has been queued and will be executed when the calling thread gets into the alertable wait state.</p>
<p>
A return value of SOCKET_ERROR coupled with an error code of <a href="errors_0oaa.htm#_win32_wsa_io_pending_2">WSA_IO_PENDING</a> indicates that the overlapped operation has been successfully initiated and that a subsequent indication will be provided when send buffers have been consumed or when a receive operation has been completed. However, for sockets that are byte-stream style, the completion indication occurs whenever the incoming data is exhausted, regardless of whether the buffers are full. Any other error code indicates that the overlapped operation was not successfully initiated and that no completion indication will be forthcoming.</p>
<p>
Both send and receive operations can be overlapped. The receive functions can be invoked several times to post receive buffers in preparation for incoming data, and the send functions can be invoked several times to queue multiple buffers to send. While the application can rely upon a series of overlapped send buffers being sent in the order supplied, the corresponding completion indications might occur in a different order. Likewise, on the receiving side, buffers will be filled in the order they are supplied, but the completion indications might occur in a different order.</p>
<p>
Canceling individual overlapped operations pending on a given socket is impossible. However, the <a href="wsapiref_714i.htm"><b>closesocket</b></a> function can be called to close the socket and eventually discontinue all pending operations.</p>
<p>
The deferred completion feature of overlapped I/O is also available for <a href="wsapiref_6ik2.htm"><b>WSAIoctl</b></a>, which is an enhanced version of <a href="wsapiref_7dde.htm"><b>ioctlsocket</b></a>.</p>
<p>&nbsp;</p></body>
</HTML>
