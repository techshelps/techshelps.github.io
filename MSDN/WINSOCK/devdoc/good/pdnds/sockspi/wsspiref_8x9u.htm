<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NSPLookupServiceNext</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_nsplookupservicenext_2"></a>NSPLookupServiceNext</h1>
<p>
The <b>NSPLookupServiceNext</b> function is called after obtaining a Handle from a previous call to <b>NSPLookupServiceBegin</b> in order to retrieve the requested service information.</p>
<p>
The provider will pass back a <b>WSAQUERYSET</b> structure in the <i>lpqsResults </i>buffer. The client should continue to call this function until it returns WSA_E_NOMORE, indicating that all of the <b>WSAQUERYSET</b> have been returned.</p>
<pre><code><b>int NSPAPI WSALookupServiceNext (
  HANDLE</b><i> hLookup</i><b>,</b>         
<b>  DWORD</b><i> dwControlFlags</i><b>,</b>   
<b>  LPDWORD</b><i> lpdwBufferLength</i><b>,</b>   
<b>  LPWSAQUERYSET</b><i> lpqsResults</i>   
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hLookup</i></dt>
<dd>
[in] Handle returned from the previous call to <b>WSALookupServiceBegin</b>.</dd>
<dt>
<i>dwControlFlags</i></dt>
<dd>
[in] Flags to control the next operation. Currently only LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not wish to (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result set—which was too large—and move to the next set for this call.</dd>
<dt>
<i>lpdwBufferLength</i></dt>
<dd>
[in/out] on input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the function fails, and the error is WSAEFAULT, then it contains the minimum number of bytes to pass for the <i>lpqsResults</i> to retrieve the record.</dd>
<dt>
<i>lpqsResults</i></dt>
<dd>
[out] a pointer to a block of memory, which will contain one result set in a <b>WSAQUERYSET</b> structure on return.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <i>dwControlFlags</i> specified in this function and the ones specified at the time of <a href="wsspiref_53ea.htm"><b>NSPLookupServiceBegin</b></a> are treated as "restrictions" for the purpose of combination. The restrictions are combined between the ones at <b>NSPLookupServiceBegin</b> timeand the ones at <b>NSPLookupServiceNext</b> time.Therefore the flags at <b>NSPLookupServiceNext</b> can never increase the amount of data returned beyond what was requested at <b>NSPLookupServiceBegin</b>, although it is NOT an error to specify more or fewer flags.The flags specified at a given <b>NSPLookupServiceNext</b> apply only to that call.</p>
<p>
The <i>dwControlFlags</i> LUP_FLUSHPREVIOUS and LUP_RES_SERVICE are exceptions to the "combined restrictions" rule (because they are "behavior" flags instead of "restriction" flags).If either of these flags are used in <b>NSPLookupServiceNext</b> they have their defined effect regardless of the setting of the same flags at <a href="wsspiref_53ea.htm"><b>NSPLookupServiceBegin</b></a>.</p>
<p>
For example, if LUP_RETURN_VERSION is specified at <b>NSPLookupServiceBegin</b> the service provider retrieves records including the "version".If LUP_RETURN_VERSION is NOT specified at <b>NSPLookupServiceNext</b>, the returned information does not include the "version", even though it was available.No error is generated.</p>
<p>
Also for example, if LUP_RETURN_BLOB is NOT specified at <a href="wsspiref_53ea.htm"><b>NSPLookupServiceBegin</b></a> but is specified at <b>NSPLookupServiceNext</b>, the returned information does not include the private data.No error is generated.</p>
<h4>Query Results</h4>
<p>
The following table describes how the query results are represented in the WSAQUERYSET structure. Refer to section <a href="../sock2/ovrvw4_0yya.htm#_win32_query_related_data_structures_2">Query-Related Data Structures</a> for additional information.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=43%>WSAQUERYSET Field Name</th>
<th align=left width=57%>Result Interpretation</th>
</tr>
<tr valign=top>
<td width=43%><i>dwSize</i></td>
<td width=57%>Will be set to sizeof(WSAQUERYSET). This is used as a versioning mechanism.</td>
</tr>
<tr valign=top>
<td width=43%><i>dwOuputFlags </i></td>
<td width=57%>The RESULT_IS_ALIAS flag indicates this is an alias result.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpszServiceInstanceName</i></td>
<td width=57%>Referenced string contains service name.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpServiceClassId</i></td>
<td width=57%>The GUID corresponding to the service class.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpVersion</i></td>
<td width=57%>References version number of the particular service instance.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpszComment</i></td>
<td width=57%>Optional comment string supplied by service instance.</td>
</tr>
<tr valign=top>
<td width=43%><i>dwNameSpace</i></td>
<td width=57%>Name space in which the service instance was found.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpNSProviderId</i></td>
<td width=57%>Identifies the specific name space provider that supplied this query result.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpszContext</i></td>
<td width=57%>Specifies the context point in a hierarchical name space at which the service is located.</td>
</tr>
<tr valign=top>
<td width=43%><i>dwNumberOfProtocols</i></td>
<td width=57%>Undefined for results.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpafpProtocols</i></td>
<td width=57%>Undefined for results, all needed protocol information is in the CSADDR_INFO structures.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpszQueryString</i></td>
<td width=57%>When <i>dwControlFlags</i> includes LUP_RETURN_QUERY_STRING, this field returns the unparsed remainder of the <i>lpszServiceInstanceName</i> specified in the original query.For example, in a name space that identifies services by hierarchical names that specify a host name and a file path within that host, the address returned might be the host address and the unparsed remainder might be the file path.If the <i>lpszServiceInstanceName</i> is fully parsed and LUP_RETURN_QUERY_STRING is used, this field is NULL or points to a zero-length string.</td>
</tr>
<tr valign=top>
<td width=43%><i>dwNumberOfCsAddrs</i></td>
<td width=57%>Indicates the number of elements in the array of <a href="../sock2/strucetc_4zua.htm"><b>CSADDR_INFO</b></a> structures.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpcsaBuffer</i></td>
<td width=57%>A pointer to an array of <a href="../sock2/strucetc_4zua.htm"><b>CSADDR_INFO</b></a> structures, with one complete transport address contained within each element.</td>
</tr>
<tr valign=top>
<td width=43%><i>lpBlob</i></td>
<td width=57%><i>(Optional) </i>This is a pointer to a provider-specific entity.</td>
</tr>
</table><br>
<h4>Return Values</h4>
<p>
The function should return NO_ERROR (zero) if the routine succeeds. It should return SOCKET_ERROR (-1) if the routine fails and it must set the appropriate error code using <b>SetLastError</b>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%>WSA_E_NO_MORE</td>
<td width=52%>There is no more data available.<p>
In Windows Sockets 2, conflicting error codes are defined for WSAENOMORE (10102) and WSA_E_NO_MORE (10110).The error code WSAENOMORE will be removed in a future version and only WSA_E_NO_MORE will remain.Name Space Providers should switch to using the WSA_E_NO_MORE error code as soon as possible to maintain compatibility with the widest possible range of applications.</p>
</td>
</tr>
<tr valign=top>
<td width=48%>WSA_E_CANCELLED</td>
<td width=52%>A call to NSPLookupServiceEnd was made while this call was still processing. The call has been canceled. The data in the <i>lpqsResults </i>buffer is undefined.<p>
In Windows Sockets 2, conflicting error codes are defined for WSAECANCELLED (10103) and WSA_E_CANCELLED (10111).The error code WSAECANCELLED will be removed in a future version and only WSA_E_CANCELLED will remain.Name Space Providers should switch to using the WSA_E_CANCELLED error code as soon as possible to maintain compatibility with the widest possible range of applications.</p>
</td>
</tr>
<tr valign=top>
<td width=48%>WSAEFAULT</td>
<td width=52%>The <i>lpqsResults</i> buffer was too small to contain a WSAQUERYSET set.</td>
</tr>
<tr valign=top>
<td width=48%>WSAEINVAL</td>
<td width=52%>One or more parameters were invalid or missing for this provider. </td>
</tr>
<tr valign=top>
<td width=48%>WSA_INVALID_HANDLE</td>
<td width=52%>The specified lookup handle is invalid.</td>
</tr>
<tr valign=top>
<td width=48%>WSANO_DATA</td>
<td width=52%>The name was found in the database but no data matching the given restrictions was located</td>
</tr>
<tr valign=top>
<td width=48%>WSASERVICE_NOT_FOUND</td>
<td width=52%>No such service is known. The service cannot be found in the specified name space.</td>
</tr>
<tr valign=top>
<td width=48%>WSA_NOT_ENOUGH_MEMORY </td>
<td width=52%>Not enough free memory available to perform this operation.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<p>&nbsp;</p></body>
</HTML>
