<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WPUCreateSocketHandle</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wpucreatesockethandle_2"></a>WPUCreateSocketHandle</h1>
<p>
The <b>WPUCreateSocketHandle</b> function creates a new socket handle.</p>
<pre><code><b>SOCKET WPUCreateSocketHandle (
  DWORD</b><i> dwCatalogEntryId</i><b>,</b>   
<b>  DWORD</b><i> dwContext</i><b>,</b>          
<b>  LPINT</b><i> lpErrno</i>             
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>dwCatalogEntryId</i></dt>
<dd>
[in] A descriptor identifying the calling service provider.</dd>
<dt>
<i>dwContext</i></dt>
<dd>
[in] A context value to associate with the new socket handle.</dd>
<dt>
<i>lpErrno</i></dt>
<dd>
[out] A pointer to the error code.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>WPUCreateSocketHandle </b>function creates a new socket handle for the specified provider. The handles created by <b>WPUCreateSocketHandle</b> are indistinguishable from true file system handles. This is significant in two respects. First, the Windows Socket 2 architecture takes care of redirecting the file system functions ReadFile and WriteFile to this service provider's <b>WSPRecv</b> and <b>WSPSend</b> functions, respectively. Second, in operating systems that support completion ports, the Windows Sockets 2 architecture supports associating a completion port with the socket handle and using it to report overlapped IO completion.</p>
<p>
Note, however, that the mechanism for redirecting <b>ReadFile</b> and <b>WriteFile</b> necessarily involves a user-to-kernel transition to get to the redirector, followed by a kernel-to-user transition to get to <b>WSPRecv</b> or <b>WSPSend</b>. On return, these transitions are retraced in reverse. This can be a significant performance penalty. Any service provider that uses <b>WPUCreateSocketHandle</b> to create its socket handles should not set XP1_IFS_HANDLES in its <b>WSAPROTOCOL_INFOW</b> structure. Clients should take the absence of XP1_IFS_HANDLES as guidance to avoid the use of <b>ReadFile</b> and <b>WriteFile</b>.</p>
<p>
There is no exceptional performance penalty for using the completion port mechanism with socket handles created with <b>WPUCreateSocketHandle</b>. A service provider should use <b>WPUCompleteOverlappedRequest</b> to announce completion of overlapped IO operations that may involve a completion port. Clients may freely use operating system functions to create, associate, and use a completion port for completion notification (for example, <b>CreateIoCompletionPort</b>, <b>GetQueuedCompletionStatus</b>, see relevant OS documentation for details). Note that completion ports are not integrated with the other asynchronous notification mechanisms offered by Windows Sockets 2. That is, a client can do a multiple-wait that includes multiple events and completion callbacks, but there is no predefined way for the multiple-wait to include completion ports.</p>
<h4>Layered Service Provider considerations&nbsp;&nbsp;&nbsp;&nbsp;</h4>
<p>
This procedure is of particular interest to Layered Service Providers. A layered service provider may use this procedure, instead of <b>WPUModifyIFSHandle</b> to create the socket handles it exposes to its client. The advantage of using this procedure is that all IO requests involving the socket can be guaranteed to go through this service provider. This is true even if the client assumes that the sockets are file system handles and calls the file system functions <b>ReadFile</b> and <b>WriteFile</b> (although it would pay a performance penalty for this assumption).</p>
<p>
The guarantee that all IO goes through this layer is a requirement for layers that need to process the IO stream either before or after the actual IO operation. Creating socket handles using <b>WPUCreateSocketHandle</b> and specifying an appropriate service provider interface procedure dispatch table at the time of <b>WSPStartup</b> makes sure that the layer has the chance to get involved in starting each IO operation. When the client requests overlapped IO operations this service provider layer will usually have to arrange to get into the path of IO completion notification as well.</p>
<p>
To see why this is true, consider what happens if the client associates a completion port with the socket handle for the purpose of overlapped IO completion notification. The port is associated with the socket handle exposed by this layer, not the next layer's socket handle. There is no way for this layer to determine if a completion port has been associated or what the port is. When this layer calls the next layer's IO operation, it uses the next layer's socket handle. The next layer's socket handle will <i>not</i> have the same completion port association. The client's expected completion-port notification will <i>not</i> happen without some extra help.</p>
<p>
The usual way a layered service provider takes care of this is to substitute a different overlapped IO structure and different overlapped IO parameters when invoking an IO operation in the next layer. The substitute overlapped IO structure references the client's stored overlapped structure and parameters. The invocation of the next layer sets up a callback notification. When the callback notification occurs, this layer performs any post-processing desired, retrieves the overlapped IO information it stored on behalf of the client, discards the substitute structures, and forwards an appropriate completion notification to the client.</p>
<h4>Return Values</h4>
<p>
If no error occurs, <b>WPUCreateSocketHandle</b> returns the new socket handle. Otherwise, it returns INVALID_SOCKET, and a specific error code is available in <i>lpErrno</i>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=31%>WSAENOBUFS</td>
<td width=69%>Not enough buffers available, too many sockets.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_2z5e.htm"><b>WPUCloseSocketHandle</b></a>, <a href="wsspiref_66wi.htm"><b>WPUQuerySocketHandleContext</b></a>, <a href="wsspiref_30mq.htm"><b>WPUModifyIFSHandle</b></a>, <a href="wsspiref_32ia.htm"><b>WPUCompleteOverlappedRequest</b></a></p>
<p>&nbsp;</p></body>
</HTML>
