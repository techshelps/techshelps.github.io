<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSPCloseSocket</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wspclosesocket_2"></a>WSPCloseSocket</h1>
<p>
The <b>WSPCloseSocket</b> function closes a socket.</p>
<pre><code><b>int WSPCloseSocket (
  SOCKET</b><i> s</i><b>,</b>      
<b>  LPINT</b><i> lpErrno  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying a socket.</dd>
<dt>
<i>lpErrno</i></dt>
<dd>
[out] A pointer to the error code.
</dd>
</dl>
<h4>Remarks</h4>
<p>
This function closes a socket. More precisely, it releases the socket descriptor <i>s</i>, so that further references to <i>s</i> should fail with the error WSAENOTSOCK. If this is the last reference to an underlying socket, the associated naming information and queued data are discarded. Any blocking or asynchronous calls pending on the socket (issued by any thread in this process) are canceled without posting any notification messages. Any pending overlapped operations issued by any thread in this process are also canceled. Whatever completion action was specified for these overlapped operations is performed (for example, event, completion routine, or completion port). In this case, the pending overlapped operations fail with the error status WSA_OPERATION_ABORTED. FD_CLOSE will <i>not</i> be posted after <b>WSPCloseSocket</b> is called.</p>
<p>
<b>WSPClosesocket</b> behavior is summarized as follows:
<ul>
<li>
if SO_DONTLINGER enabled (the default setting) <b>WSPCloseSocket</b> returns immediately, and connection is gracefully closed "in the background"</li>
<li>
if SO_LINGER enabled with a zero time-out: <b>WSPCloseSocket</b> returns immediately, and connection is reset/terminated</li>
<li>
if SO_LINGER enabled with nonzero time-out:<p>
– with blocking socket <b>WSPCloseSocket </b>blocks until all data sent or time-out expires
<p>
– with nonblocking socket returns immediately indicating failure
</li>
</ul>
<p>
The semantics of <b>WSPCloseSocket</b> are affected by the socket options SO_LINGER and SO_DONTLINGER as follows:</p>
<table cellspacing=4 cols=4>
<tr valign=top>
<th align=left width=29%>Option</th>
<th align=left width=19%>Interval</th>
<th align=left width=26%>Type of close</th>
<th align=left width=26%>Wait for close?</th>
</tr>
<tr valign=top>
<td width=29%>SO_DONTLINGER</td>
<td width=19%>Do not care</td>
<td width=26%>Graceful</td>
<td width=26%>No</td>
</tr>
<tr valign=top>
<td width=29%>SO_LINGER</td>
<td width=19%>Zero</td>
<td width=26%>Hard</td>
<td width=26%>No</td>
</tr>
<tr valign=top>
<td width=29%>SO_LINGER</td>
<td width=19%>Nonzero</td>
<td width=26%>Graceful</td>
<td width=26%>Yes</td>
</tr>
</table><br>
<p>
If SO_LINGER is set (that is, the <i>l_onoff</i> field of the linger structure is nonzero) and the time-out interval, <i>l_linger,</i> is zero, <b>WSPClosesocket</b> is not blocked even if queued data has not yet been sent or acknowledged. This is called a "hard" or "abortive" close, because the socket's virtual circuit is reset immediately, and any unsent data is lost. Any <a href="wsspiref_854i.htm"><b>WSPRecv</b></a> call on the remote side of the circuit will fail with WSAECONNRESET.</p>
<p>
If SO_LINGER is set with a nonzero time-out interval on a blocking socket, the <b>WSPClosesocket</b> call blocks on a blocking socket until the remaining data has been sent or until the time-out expires. This is called a graceful disconnect. If the time-out expires before all data has been sent, the service provider should terminate the connection before <b>WSPClosesocket</b> returns.</p>
<p>
Enabling SO_LINGER with a nonzero time-out interval on a nonblocking socket is not recommended. In this case, the call to <b>WSPClosesocket</b> will fail with an error of WSAEWOULDBLOCK if the close operation cannot be completed immediately. If <b>WSPClosesocket</b> fails with WSAEWOULDBLOCK the socket handle is still valid, and a disconnect is not initiated. The Windows Sockets SPI client must call <b>WSPClosesocket</b> again to close the socket, although <b>WSPClosesocket</b> can continue to fail unless the Windows Sockets SPI client disables SO_DONTLINGER, enables SO_LINGER with a zero time-out, or calls <a href="wsspiref_4dma.htm"><b>WSPShutdown</b></a> to initiate closure.</p>
<p>
If SO_DONTLINGER is set on a stream socket (that is, the <i>l_onoff</i> field of the linger structure is zero), the <b>WSPClosesocket</b> call will return immediately and does not get WSAEWOULDBLOCK, whether the socket is blocking or nonblocking. However, any data queued for transmission will be sent if possible before the underlying socket is closed. This is called a graceful disconnect and is the default behavior. Note that in this case the Windows Sockets provider is allowed to retain any resources associated with the socket until such time as the graceful disconnect has completed or the provider terminates the connection due to an inability to complete the operation in a provider-determined amount of time. This can affect Windows Sockets clients which expect to use all available sockets. This is the default behavior (SO_DONTLINGER is set by default)</p>
<h4>Return Values</h4>
<p>
If no error occurs, <b>WSPCloseSocket</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code is available in <i>lpErrno</i>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=37%>WSAENETDOWN</td>
<td width=63%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEINPROGRESS</td>
<td width=63%>A blocking Windows Sockets call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=37%>WSAENOTSOCK</td>
<td width=63%>The descriptor is not a socket.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEWOULDBLOCK</td>
<td width=63%>The socket is marked as nonblocking and SO_LINGER is set to a nonzero timeout value.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_2j1u.htm"><b>WSPAccept</b></a>, <a href="wsspiref_46ia.htm"><b>WSPSocket</b></a>, <a href="wsspiref_9baq.htm"><b>WSPIoctl</b></a>, <a href="wsspiref_5hte.htm"><b>WSPSetSockOpt</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
