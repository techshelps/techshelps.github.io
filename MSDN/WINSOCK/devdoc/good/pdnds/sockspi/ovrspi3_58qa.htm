<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPI: Out-Of-Band data</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_spi_out_of_band_data_2"></a>SPI: Out-Of-Band data</h3>
<p>
The service providers which support the out-of-band data abstraction for the stream-style sockets must adhere to the semantics in this section. We will describe OOB data handling in a protocol-independent manner. Please refer to the <i>Windows Sockets 2 Protocol-Specific Annex </i>(a separate document)<i> </i>for a discussion of OOB data implemented using "urgent data" in TCP/IP service providers. In the following, the use of <a href="wsspiref_854i.htm"><b>WSPRecv</b></a> also implies <b>WSPRecvFrom</b>. </p>

<h4><a name="_win32_spi_protocol_independent_oob_data_2"></a>SPI: Protocol Independent OOB data</h4>
<p>
OOB data is a logically independent transmission channel associated with each pair of connected stream sockets. OOB data may be delivered to the user independently of normal data. The abstraction defines that the OOB data facilities must support the reliable delivery of at least one OOB data block at a time. This data block may contain at least one byte of data, and at least one OOB data block may be pending delivery to the user at any one time. For communications protocols which support in-band signaling (i.e. TCP, where the "urgent data" is delivered in sequence with the normal data), the system normally extracts the OOB data from the normal data stream and stores it separately (leaving a gap in the "normal" data stream). This allows users to choose between receiving the OOB data in order and receiving it out of sequence without having to buffer all the intervening data. It is possible to "peek'' at out-of-band data. </p>
<p>
A user can determine if there is any OOB data waiting to be read using the <a href="wsspiref_9baq.htm"><b>WSPIoctl</b></a>(SIOCATMARK) function. For protocols where the concept of the "position" of the OOB data block within the normal data stream is meaningful (i.e. TCP), a Windows Sockets service provider will maintain a conceptual "marker" indicating the position of the last byte of OOB data within the normal data stream. This is not necessary for the implementation of the <a href="wsspiref_9baq.htm"><b>WSPIoctl</b></a>(SIOCATMARK) functionality - the presence or absence of OOB data is all that is required. </p>
<p>
For protocols where the concept of the "position" of the OOB data block within the normal data stream is meaningful an application may prefer to process out-of-band data "in-line", as part of the normal data stream. This is achieved by setting the socket option SO_OOBINLINE (see section <a href="wsspiref_9baq.htm"><b>WSPIoctl</b></a>). For other protocols where the OOB data blocks are truly independent of the normal data stream, attempting to set SO_OOBINLINE will result in an error. An application can use the SIOCATMARK <b>WSPIoctl</b> command to determine whether there is any unread OOB data preceding the mark. For example, it might use this to resynchronize with its peer by ensuring that all data up to the mark in the data stream is discarded when appropriate. </p>
<p>
With SO_OOBINLINE disabled (the default setting):
<ul>
<li>
The Windows Sockets service provider notifies a client of an FD_OOB event, if the client registered for notification with <a href="wsspiref_74du.htm"><b>WSPAsyncSelect</b></a>, in exactly the same way FD_READ is used to notify of the presence of normal data. That is, FD_OOB is posted when OOB data arrives and there was no OOB data previously queued, and also when data is read using the MSG_OOB flag, and some OOB data remains to be read after the read operation has returned. FD_READ messages are not posted for OOB data.</li>
<li>
The Windows Sockets service provider returns from <a href="wsspiref_2q2a.htm"><b>WSPSelect</b></a> with the appropriate <i>exceptfds</i> socket set if OOB data is queued on the socket.</li>
<li>
the client can call <a href="wsspiref_854i.htm"><b>WSPRecv</b></a> with MSG_OOB to read the urgent data block at any time. The block of OOB data "jumps the queue".</li>
<li>
the client can call <a href="wsspiref_854i.htm"><b>WSPRecv</b></a> without MSG_OOB to read the normal data stream. The OOB data block will not appear in the data stream with "normal data." If OOB data remains after any call to <a href="wsspiref_854i.htm"><b>WSPRecv</b></a>, the service provider notifies the client with FD_OOB or via <i>exceptfds</i><b> </b>when using<b> <a href="wsspiref_2q2a.htm">WSPSelect</a></b>.</li>
<li>
For protocols where the OOB data has a position within the normal data stream, a single <a href="wsspiref_854i.htm"><b>WSPRecv</b></a> operation will not span that position. One <b>WSPRecv</b> will return the normal data before the "mark", and a second <b>WSPRecv</b> is required to begin reading data after the "mark". </li>
</ul>
<p>
With SO_OOBINLINE enabled:
<ul>
<li>
FD_OOB messages are <b>_NOT_</b> posted for OOB data - for the purpose of the <a href="wsspiref_2q2a.htm"><b>WSPSelect</b></a> and <a href="wsspiref_74du.htm"><b>WSPAsyncSelect</b></a> functions, OOB data is treated as normal data, and indicated by setting the socket in <i>readfds</i> or by sending an FD_READ message respectively.</li>
<li>
the client may not call <a href="wsspiref_854i.htm"><b>WSPRecv</b></a> with the MSG_OOB flag set to read the OOB data block - the error code WSAEINVAL will be returned.</li>
<li>
the client can call <b>WSPRecv</b> without the MSG_OOB flag set. Any OOB data will be delivered in its correct order within the "normal" data stream. OOB data will never be mixed with normal data - there must be three read requests to get past the OOB data. The first returns the normal data prior to the OOB data block, the second returns the OOB data, the third returns the normal data following the OOB data. In other words, the OOB data block boundaries are preserved. </li>
</ul>
<p>
The <a href="wsspiref_74du.htm"><b>WSPAsyncSelect</b></a> routine is particularly well suited to handling notification of the presence of out-of-band-data when SO_OOBINLINE is off. </p>
<p>&nbsp;</p></body>
</HTML>
