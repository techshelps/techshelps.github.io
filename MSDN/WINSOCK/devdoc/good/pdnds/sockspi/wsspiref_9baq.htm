<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSPIoctl</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wspioctl_2"></a>WSPIoctl</h1>
<p>
The <b>WSPIoctl</b> function controls the mode of a socket.</p>
<pre><code><b>int WSPIoctl (
  SOCKET</b><i> s</i><b>,</b>                                                
<b>  DWORD</b><i> dwIoControlCode</i><b>,</b>                                   
<b>  LPVOID</b><i> lpvInBuffer</i><b>,</b>                                      
<b>  DWORD</b><i> cbInBuffer</i><b>,</b>                                        
<b>  LPVOID</b><i> lpvOutBuffer</i><b>,</b>                                     
<b>  DWORD</b><i> cbOutBuffer</i><b>,</b>                                       
<b>  LPDWORD</b><i> lpcbBytesReturned</i><b>,                               </b>
<b>  LPWSAOVERLAPPED</b><i> lpOverlapped</i><b>,                            </b>
<b>  LPWSAOVERLAPPED_COMPLETION_ROUTINE</b><i> lpCompletionRoutine</i><b>,  </b>
<b>  LPWSATHREADID</b><i> lpThreadId</i><b>,</b>                                
<b>  LPINT</b><i> lpErrno                                            </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] Handle to a socket</dd>
<dt>
<i>dwIoControlCode</i></dt>
<dd>
[in] Control code of operation to perform</dd>
<dt>
<i>lpvInBuffer</i></dt>
<dd>
[in] Address of input buffer</dd>
<dt>
<i>cbInBuffer</i></dt>
<dd>
[in] Size of input buffer</dd>
<dt>
<i>lpvOutBuffer</i></dt>
<dd>
[out] Address of output buffer</dd>
<dt>
<i>cbOutBuffer</i></dt>
<dd>
[in] Size of output buffer</dd>
<dt>
<i>lpcbBytesReturned</i></dt>
<dd>
[out] A pointer to the size of output buffer's contents.</dd>
<dt>
<i>lpOverlapped </i></dt>
<dd>
[in] Address of WSAOVERLAPPED structure (ignored for non-overlapped sockets).</dd>
<dt>
<i>lpCompletionRoutine</i></dt>
<dd>
[in] A pointer to the completion routine called when the operation has been completed (ignored for non-overlapped sockets).</dd>
<dt>
<i>lpThreadId</i></dt>
<dd>
[in] A pointer to a <b>WSATHREADID</b> structure to be used by the provider in a subsequent call to <b>WPUQueueApc</b>. The provider should store the referenced <b>WSATHREADID</b> structure (not the pointer to same) unitl after the <b>WPUQueueApc</b> function returns.</dd>
<dt>
<i>lpErrno</i></dt>
<dd>
[out] A pointer to the error code.
</dd>
</dl>
<h4>Remarks</h4>
<p>
This routine is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem. If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are NULL, the socket in this function will be treated as a non-overlapped socket.</p>
<p>
For nonoverlapped sockets, <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> parameters are ignored, and this function can block if socket <i>s</i> is in the blocking mode. Note that if socket <i>s</i> is in the nonblocking mode, this function can return WSAEWOULDBLOCK if the specified operation cannot be finished immediately. In this case, the Windows Sockets SPI client may change the socket to the blocking mode and reissue the request request or wait for the corresponding network event (such as FD_ROUTING_INTERFACE_CHANGE or FD_ADDRESS_LIST_CHANGE in case of SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE) using Windows message (via <b>WSPAsyncSelect</b> or event (using <b>WSPEventSelect</b>) based notification mechanism.. For overlapped sockets, operations that cannot be completed immediately will be initiated, and completion will be indicated at a later time. The final completion status is retrieved through the <b>WSPGetOverlappedResult</b>.</p>
<p>
Any <i>ioctl</i> may block indefinitely, depending on the implementation of the service provider. If the Windows Sockets SPI client cannot tolerate blocking in a <b>WSPIoctl</b> call, overlapped I/O would be advised for ioctls that are especially likely to block including:</p>
<p>
SIO_FINDROUTE</p>
<p>
SIO_FLUSH</p>
<p>
SIO_GET_QOS</p>
<p>
SIO_GET_GROUP_QOS</p>
<p>
SIO_SET_QOS</p>
<p>
SIO_SET_GROUP_QOS</p>
<p>
SIO_ROUTING_INTERFACE_CHANGE</p>
<p>
SIO_ADDRESS_LIST_CHANGE</p>
<p>
Some protocol-specific ioctls may also be especially likely to block. Check the relevant protocol-specific annex for any available information.</p>
<p>
In as much as the <i>dwIoControlCode </i>parameter is now a 32-bit entity, it is possible to adopt an encoding scheme that provides a convenient way to partition the opcode identifier space. The <i>dwIoControlCode</i> parameter is architected to allow for protocol and vendor independence when adding new control codes, while retaining backward compatibility with Windows Sockets 1.1 and Unix control codes. The <i>dwIoControlCode</i> parameter has the following form:</p>
<table cellspacing=4 cols=6>
<tr valign=top>
<td width=5%>3</td>
<td width=5%>3</td>
<td width=5%>2</td>
<td width=7%>2 2</td>
<td width=36%>2 2 2 2 2 2 2 1 1 1 1</td>
<td width=42%>1 1 1 1 1 1</td>
</tr>
<tr valign=top>
<td width=5%>1</td>
<td width=5%>0</td>
<td width=5%>9</td>
<td width=7%>8 7</td>
<td width=36%>6 5 4 3 2 1 0 9 8 7 6</td>
<td width=42%>5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0</td>
</tr>
<tr valign=top>
<td width=5%><b>I</b></td>
<td width=5%><b>O</b></td>
<td width=5%><b>V</b></td>
<td width=7%><b>T</b></td>
<td width=36%><b>Vendor/Address Family</b></td>
<td width=42%><b>Code</b></td>
</tr>
</table><br>
<p>
<b>I</b> is set if the input buffer is valid for the code, as with <b>IOC_IN</b>.</p>
<p>
<b>O</b> is set if the output buffer is valid for the code, as with <b>IOC_OUT</b>. Note that for codes with both input and output parameters, both <b>I</b> and <b>O</b> will be set.</p>
<p>
<b>V</b> is set if there are no parameters for the code, as with <b>IOC_VOID</b>.</p>
<p>
<b>T</b> is a two-bit quantity which defines the type of ioctl. The following values are defined:</p>
<p>
<b>0</b> – The ioctl is a standard Unix ioctl code, as with FIONREAD and FIONBIO.</p>
<p>
<b>1</b> – The ioctl is a generic Windows Sockets 2 ioctl code. New ioctl codes defined for Windows Sockets 2 will have <b>T</b> == <b>1</b>.</p>
<p>
<b>2</b> – The ioctl applies only to a specific address family.</p>
<p>
<b>3</b> – The ioctl applies only to a specific vendor's provider. This type allows companies to be assigned a vendor number which appears in the <b>Vendor/AddressFamily</b> field. Then, the vendor can define new ioctls specific to that vendor without having to register the ioctl with a clearinghouse, thereby providing vendor flexibility and privacy.</p>
<p>
<b>Vendor/Address Family</b> - An 11-bit quantity which defines the vendor who owns the code (if <b>T</b> == <b>3</b>) or which contains the address family to which the code applies (if <b>T</b> == <b>2</b>). If this is a Unix ioctl code (<b>T</b> == <b>0</b>) then this field has the same value as the code on Unix. If this is a generic Windows Sockets 2 ioctl (<b>T</b> == <b>1</b>) then this field can be used as an extension of the "code" field to provide additional code values.</p>
<p>
<b>Code</b> – The specific ioctl code for the operation.</p>
<p>
The following Unix commands are supported:</p>
<h4>Parameters</h4>
<dl>
<dt>
FIONBIO</dt>
<dd>
Enable or disable nonblocking mode on socket <i>s</i>. <i>lpvInBuffer</i> points at an <b>unsigned long</b>, which is nonzero if nonblocking mode is to be enabled and zero if it is to be disabled. When a socket is created, it operates in blocking mode (that is, nonblocking mode is disabled). This is consistent with BSD sockets.
<p>
The <b>WSPAsyncSelect</b> or <b>WSPEventSelect</b> routine automatically sets a socket to nonblocking mode. If <b>WSPAsyncSelect</b> or <b>WSPEventSelect</b> has been issued on a socket, then any attempt to use <b>WSPIoctl</b> to set the socket back to blocking mode will fail with WSAEINVAL. To set the socket back to blocking mode, a Windows Sockets SPI client must first disable <b>WSPAsyncSelect</b> by calling <b>WSPAsyncSelect</b> with the <i>lEvent</i> parameter equal to zero, or disable <b>WSPEventSelect</b> by calling <b>WSPEventSelect</b> with the lNetworkEvents parameter equal to zero.
</dd>
<dt>
FIONREAD</dt>
<dd>
Determine the amount of data which can be read atomically from socket <i>s</i>. <i>lpvOutBuffer</i> points at an <b>unsigned long</b> in which <b>WSPIoctl</b> stores the result. If <i>s</i> is stream oriented (for example, type SOCK_STREAM), FIONREAD returns the total amount of data which can be read in a single receive operation; this is normally the same as the total amount of data queued on the socket. If <i>s</i> is message oriented (for example, type SOCK_DGRAM), FIONREAD returns the size of the first datagram (message) queued on the socket.</dd>
<dt>
SIOCATMARK</dt>
<dd>
Determine whether or not all out-of-band data has been read. This applies only to a socket of stream-style (for example, type SOCK_STREAM) which has been configured for in-line reception of any out-of-band data (SO_OOBINLINE). If no out-of-band data is waiting to be read, the operation returns TRUE. Otherwise, it returns FALSE, and the next receive operation performed on the socket will retrieve some or all of the data preceding the "mark"; the Windows Sockets SPI client should use the SIOCATMARK operation to determine whether any remains. If there is any normal data preceding the "urgent" (out of band) data, it will be received in order. (Note that receive operations will never mix out-of-band and normal data in the same call.) <i>lpvOutBuffer</i> points at a <b>BOOL</b> in which <b>WSPIoctl</b> stores the result.
</dd>
</dl>
<p>
The following Windows Sockets 2 commands are supported:</p>
<h4>Parameters</h4>
<dl>
<dt>
SIO_ASSOCIATE_HANDLE (opcode setting: I, T==1)</dt>
<dd>
Associate this socket with the specified handle of a companion interface. The input buffer contains the integer value corresponding to the manifest constant for the companion interface (for example, TH_NETDEV and TH_TAPI), followed by a value which is a handle of the specified companion interface, along with any other required information. Refer to the appropriate section in the <b><i>Windows Sockets 2 Protocol-Specific Annex</i></b> and/or documentation for the particular companion interface for additional details. The total size is reflected in the input buffer length. No output buffer is required. The WSAENOPROTOOPT error code is indicated for service providers which do not support this ioctl. The handle associated by this ioctl can be retrieved using SIO_TRANSLATE_HANDLE.
<p>
A companion interface might be used, for example, if a particular provider provides (1) a great deal of additional controls over the behavior of a socket and (2) the controls are provider-specific enough that they do not map to existing Windows Socket functions or ones likely to be defined in the future. It is recommend that the Component Object Model (COM) be used instead of this ioctl to discover and track other interfaces that might be supported by a socket. This ioctl is present for (reverse) compatibility with systems where COM is not available or cannot be used for some other reason.
</dd>
<dt>
SIO_ENABLE_CIRCULAR_QUEUEING (opcode setting: V, T==1)</dt>
<dd>
Indicates to a message-oriented service provider that a newly arrived message should never be dropped because of a buffer queue overflow. Instead, the oldest message in the queue should be eliminated in order to accommodate the newly arrived message. No input and output buffers are required. Note that this ioctl is only valid for sockets associated with unreliable, message-oriented protocols. The WSAENOPROTOOPT error code is indicated for service providers which do not support this ioctl.</dd>
<dt>
SIO_FIND_ROUTE (opcode setting: O, T==1)</dt>
<dd>
When issued, this ioctl requests that the route to the remote address specified as a <b>SOCKADDR</b> in the input buffer be discovered. If the address already exists in the local cache, its entry is invalidated. In the case of Novell's IPX, this call initiates an IPX GetLocalTarget (GLT), which queries the network for the given remote address. </dd>
<dt>
SIO_FLUSH (opcode setting: V, T==1)</dt>
<dd>
Discards current contents of the sending queue associated with this socket. No input and output buffers are required. The WSAENOPROTOOPT error code is indicated for service providers which do not support this ioctl.</dd>
<dt>
SIO_GET_BROADCAST_ADDRESS (opcode setting: O, T==1)</dt>
<dd>
This ioctl fills the output buffer with a <b>SOCKADDR</b> structure containing a suitable broadcast address for use with <b>WSPSendTo</b>.</dd>
<dt>
SIO_GET_EXTENSION_FUNCTION_POINTER (opcode setting: O, I, T==1)</dt>
<dd>
Retrieve a pointer to the specified extension function supported by the associated service provider. The input buffer contains a GUID whose value identifies the extension function in question. The pointer to the desired function is returned in the output buffer. Extension function identifiers are established by service provider vendors and should be included in vendor documentation that describes extension function capabilities and semantics. </dd>
<dt>
SIO_GET_QOS (opcode setting: O, T==1)</dt>
<dd>
Retrieve the QOS structure associated with the socket. The input buffer is optional. Some protocols (for example, RSVP) allow the input buffer to be used to qualify a QOS request. The QOS structure will be copied into the output buffer. The output buffer must be sized large enough to be able to contain the full QOS structure. The WSAENOPROTOOPT error code is indicated for service providers which do not support QOS.</dd>
<dt>
SIO_GET_GROUP_QOS (opcode setting: O, T==1)</dt>
<dd>
Reserved for future use with socket groups: Retrieve the QOS structure associated with the socket group to which this socket belongs. The input buffer is optional. Some protocols (for example, RSVP) allow the input buffer to be used to qualify a QOS request. The QOS structure will be copied into the output buffer. If this socket does not belong to an appropriate socket group, the <i>SendingFlowspec</i> and <i>ReceivingFlowspec </i>fields of the returned QOS structure are set to NULL. The WSAENOPROTOOPT error code is indicated for service providers which do not support QOS.</dd>
<dt>
SIO_MULTIPOINT_LOOPBACK (opcode setting: I, T==1)</dt>
<dd>
Controls whether data sent in a multipoint session will also be received by the same socket on the local host. A value of TRUE causes loopback reception to occur while a value of FALSE prohibits this.</dd>
<dt>
SIO_MULTICAST_SCOPE (opcode setting: I, T==1)</dt>
<dd>
Specifies the scope over which multicast transmissions will occur. Scope is defined as the number of routed network segments to be covered. A scope of zero would indicate that the multicast transmission would not be placed "on the wire" but could be disseminated across sockets within the local host. A scope value of one (the default) indicates that the transmission will be placed on the wire, but will <i>not</i> cross any routers. Higher scope values determine the number of routers that can be crossed. Note that this corresponds to the time-to-live (TTL) parameter in IP multicasting.</dd>
<dt>
SIO_SET_QOS (opcode setting: I, T==1)</dt>
<dd>
Associate the supplied QOS structure with the socket. No output buffer is required, the QOS structure will be obtained from the input buffer. The WSAENOPROTOOPT error code is indicated for service providers which do not support QOS.</dd>
<dt>
SIO_SET_GROUP_QOS (opcode setting: I, T==1)</dt>
<dd>
Reserved for future use with socket groups: Establish the supplied QOS structure with the socket group to which this socket belongs. No output buffer is required, the QOS structure will be obtained from the input buffer. The WSAENOPROTOOPT error code is indicated for service providers which do not support QOS, or if the socket descriptor specified is not the creator of the associated socket group.</dd>
<dt>
SIO_TRANSLATE_HANDLE (opcode setting: I, O, T==1)</dt>
<dd>
To obtain a corresponding handle for socket <i>s</i> that is valid in the context of a companion interface (for example, TH_NETDEV and TH_TAPI). A manifest constant identifying the companion interface along with any other needed parameters are specified in the input buffer. The corresponding handle will be available in the output buffer upon completion of this function. Refer to the appropriate section in the <b><i>Windows Sockets 2 Protocol-Specific Annex</i></b> and/or documentation for the particular companion interface for additional details. The WSAENOPROTOOPT error code is indicated for service providers which do not support this ioctl for the specified companion interface. This ioctl retrieves the handle associated using SIO_TRANSLATE_HANDLE.
<p>
It is recommend that the Component Object Model (COM) be used instead of this ioctl to discover and track other interfaces that might be supported by a socket. his ioctl is present for (reverse) compatibility with systems where COM is not available or cannot be used for some other reason.
</dd>
<dt>
SIO_ROUTING_INTERFACE_QUERY (opcode setting: I, O, T==1) </dt>
<dd>
To obtain the address of the local interface (represented as SOCKADDR structure) which should be used to send to the remote address specified in the input buffer (as SOCKADDR). Remote multicast addresses may be submitted in the input buffer to get the address of the preferred interface for multicast transmission. In any case, the interface address returned may be used by the application in a subsequent <b>bind</b> request.
<p>
Note that routes are subject to change. Therefore, Windows Socket SPI clients cannot rely on the information returned by SIO_ROUTING_INTERFACE_QUERY to be persistent. SPI clients may register for routing change notifications using the SIO_ROUTING_INTERFACE_CHANGE IOCTL which provides for notification via either overlapped IO or FD_ROUTING_INTERFACE_CHANGE event. The following sequence of actions can be used to guarantee that the Windows Socket SPI client always has current routing interface information for a given destination: 

<ol>
<li>
issue SIO_ROUTING_INTERFACE_CHANGE IOCTL</li>
<li>
issue SIO_ROUTING_INTERFACE_QUERY IOCTL</li>
<li>
whenever SIO_ROUTING_INTERFACE_CHANGE IOCTL notifies the WinSock SPI client of routing change (either via overlapped IO or by signaling FD_ROUTING_INTERFACE_CHANGE event), the whole sequence of actions should be repeated. </li>
</ol>

<p>
If output buffer is not large enough to contain the interface address, SOCKET_ERROR is returned as the result of this IOCTL and <b>WSPGetLastError</b> returns WSAEFAULT. The required size of the output buffer will be returned in <i>lpcbBytesReturned</i> in this case. Note the WSAEFAULT error code is also returned if the <i>lpvInBuffer</i>, <i>lpvOutBuffer</i> or <i>lpcbBytesReturned</i> parameter is not totally contained in a valid part of the user address space.

<p>
If the destination address specified in the input buffer cannot be reached via any of the available interfaces, SOCKET_ERROR is returned as the result of this IOCTL and <b>WSAGetLastError</b> returns WSAENETUNREACH or even WSAENETDOWN if all of the network connectivity is lost.
</dd>
<dt>
SIO_ROUTING_INTERFACE_CHANGE (opcode setting: I, T==1) </dt>
<dd>
To receive notification of the interface change that should be used to reach the remote address in the input buffer (specified as a SOCKADDR structure). No output information will be provided upon completion of this IOCTL; the completion merely indicates that routing interface for a given destination has changed and should be queried again via SIO_ROUTING_INTERFACE_QUERY.
<p>
It is assumed (although not required) that the Windows Socket SPI client uses overlapped IO to be notified of routing interface change via completion of SIO_ROUTING_INTERFACE_CHANGE request. Alternatively, if the SIO_ROUTING_INTERFACE_CHANGE IOCTL is issued on non-blocking socket AND without overlapped parameters (<i>lpOverlapped</i> / <i>CompletionRoutine</i> are set NULL), it will complete immediately with error WSAEWOULDBLOCK, and the Windows Socket SPI client can then wait for routing change events using a call to <b>WSPEventSelect</b> or <b>WSPAsyncSelect</b> with FD_ROUTING_INTERFACE_CHANGE bit set in the network event bitmask

<p>
It is recognized that routing information remains stable in most cases so that requiring the Windows Socket SPI client to keep multiple outstanding IOCTLs to get notifications about all destinations that it is interested in as well as having service provider to keep track of all them will unnecessarily tie significant system resources. This situation can be avoided by extending the meaning of the input parameters and relaxing the service provider requirements as follows:

<p>
The Windows Socket SPI client can specify a protocol family specific wildcard address (same as one used in <b>bind</b> call when requesting to bind to any available address) to request notifications of any routing changes. This allows the Windows Socket SPI client to keep only one outstanding SIO_ROUTING_INTERFACE_CHANGE for all the sockets/destinations it has and then use SIO_ROUTING_INTERFACE_QUERY to get the actual routing information

<p>
Service provider can opt to ignore the information supplied by the Windows Socket SPI client in the input buffer of the SIO_ROUTING_INTERFACE_CHANGE (as though the Windows Socket SPI client specified a wildcard address) and complete the SIO_ROUTING_INTERFACE_CHANGE IOCTL or signal FD_ROUTING_INTERFACE_CHANGE event in the event of any routing information change (not just the route to the destination specified in the input buffer). 
</dd>
<dt>
SIO_ADDRESS_LIST_QUERY (opcode setting: I, O, T==1) </dt>
<dd>
To obtain a list of local transport addresses of socket's protocol family to which the WinSock SPI client can bind. The list returned in the output buffer using the following format:
<pre><code>typedef struct _SOCKET_ADDRESS_LIST {
….INT iAddressCount;
….SOCKET_ADDRESS Address[1];
} SOCKET_ADDRESS_LIST, FAR * LPSOCKET_ADDRESS_LIST;
Members:
….iAddressCount- number of address structures in the list;
….Address- array of protocol family specific address structures.
</code></pre>

<p>
Note that in Win32 Plug-n-Play environments addresses can be added/removed dynamically. Therefore, Windows Socket SPI clients cannot rely on the information returned by SIO_ADDRESS_LIST_QUERY to be persistent. Windows Socket SPI clients may register for address change notifications via the SIO_ADDRESS_LIST_CHANGE IOCTL which provides for notification via either overlapped IO or FD_ADDRESS_LIST_CHANGE event. The following sequence of actions can be used to guarantee that the Windows Socket SPI client always has current address list information:

<ol>
<li>
issue SIO_ADDRESS_LIST_CHANGE IOCTL</li>
<li>
issue SIO_ADDRESS_LIST_QUERY IOCTL</li>
<li>
whenever SIO_ADDRESS_LIST_CHANGE IOCTL notifies the WinSock SPI client of address list change (either via overlapped IO or by signaling FD_ADDRESS_LIST_CHANGE event), the whole sequence of actions should be repeated.</li>
</ol>

<p>
If output buffer is not large enough to contain the address list, SOCKET_ERROR is returned as the result of this IOCTL and <b>WSPGetLastError</b> returns WSAEFAULT. The required size of the output buffer will be returned in <i>lpcbBytesReturned</i> in this case. Note the WSAEFAULT error code is also returned if the <i>lpvInBuffer</i>, <i>lpvOutBuffer</i> or <i>lpcbBytesReturned</i> parameter is not totally contained in a valid part of the user address space.
</dd>
<dt>
SIO_ADDRESS_LIST_CHANGE (opcode setting: T==1) </dt>
<dd>
To receive notification of changes in the list of local transport addresses of socket's protocol family to which the Windows Socket SPI client can bind. No output information will be provided upon completion of this IOCTL; the completion merely indicates that list of available local address has changed and should be queried again via SIO_ADDRESS_LIST_QUERY.
<p>
It is assumed (although not required) that the Windows Socket SPI client uses overlapped IO to be notified of change via completion of SIO_ADDRESS_LIST_CHANGE request. Alternatively, if the SIO_ADDRESS_LIST_CHANGE IOCTL is issued on non-blocking socket AND without overlapped parameters (<i>lpOverlapped</i> / <i>lpCompletionRoutine</i> are set to NULL), it will complete immediately with error WSAEWOULDBLOCK. The Windows Socket SPI client can then wait for address list change events via call to <b>WSPEventSelect</b> or <b>WSPAsyncSelect</b> with FD_ADDRESS_LIST_CHANGE bit set in the network event bitmask.
</dd>
<dt>
SIO_QUERY_PNP_TARGET_HANDLE (opcode setting: O, T==1) </dt>
<dd>
To obtain socket descriptor of the next provider in the chain on which current socket depends in PnP sense. This IOCTL is invoked by the Windows Socket 2 DLL ONLY on sockets of Non-IFS service providers created via <a href="wsspiref_8m0i.htm"><b>WPUCreateSocketHandle</b></a> call. The provider should return in the output buffer the socket handle of the next provider in the chain on which given socket handle depends in PnP sense (e.g. the removal of the device that supports the underlying handle will result in invalidation of the handle above it in the chain).
<p>
If an overlapped operation completes immediately, this function returns a value of zero and the <i>lpcbBytesReturned</i> parameter is updated with the number of bytes in the output buffer. If the overlapped operation is successfully initiated and will complete later, this function returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, <i>lpcbBytesReturned</i> is not updated. When the overlapped operation completes the amount of data in the output buffer is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in <a href="wsspiref_36nm.htm"><b>WSPGetOverlappedResult</b></a>.

</dd>
</dl>
<p>
When called with an overlapped socket, the <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. The WSAOVERLAPPED structure has the following form:</p>
<pre><code>typedef struct _WSAOVERLAPPED {
    DWORD       Internal;      // reserved
    DWORD       InternalHigh;  // reserved
    DWORD       Offset;        // reserved
    DWORD       OffsetHigh;    // reserved
    WSAEVENT    hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;
 </code></pre>
<p>
If the <i>lpCompletionRoutine</i> parameter is NULL, the service provider signals the <i>hEvent</i> field of <i>lpOverlapped</i> when the overlapped operation completes if it contains a valid event object handle. The Windows Sockets SPI client can use <b>WSPGetOverlappedResult</b> to poll or wait on the event object.</p>
<p>
If <i>lpCompletionRoutine</i> is not NULL, the <i>hEvent</i> field is ignored and can be used by the Windows Sockets SPI client to pass context information to the completion routine. A client that passes a non-NULL <i>lpCompletionRoutine</i> and later calls <b>WSAGetOverlappedResult</b> for the same overlapped IO request may not set the <i>fWait</i> parameter for that invocation of <b>WSAGetOverlappedResult</b> to TRUE. In this case the usage of the <i>hEvent</i> field is undefined, and attempting to wait on the <i>hEvent</i> field would produce unpredictable results.</p>
<p>
It is the service provider's responsibility to arrange for invocation of the client-specified completion routine when the overlapped operation completes. Since the completion routine must be executed in the context of the same thread that initiated the overlapped operation, it cannot be invoked directly from the service provider. The WS2_32.DLL offers an asynchronous procedure call (APC) mechanism to facilitate invocation of completion routines.</p>
<p>
A service provider arranges for a function to be executed in the proper thread thread and process context by calling <b>WPUQueueApc</b>. This function can be called from any process and thread context, even a context different from the thread and process that was used to initiate the overlapped operation.</p>
<p>
<b>WPUQueueApc</b> takes as input parameters a pointer to a <b>WSATHREADID</b> structure (supplied to the provider through the <i>lpThreadId </i>input parameter), a pointer to an APC function to be invoked, and a 32-bit context value that is subsequently passed to the APC function. Because only a single 32-bit context value is available, the APC function cannot itself be the client-specified completion routine. The service provider must instead supply a pointer to its own APC function which uses the supplied context value to access the needed result information for the overlapped operation, and then invokes the client-specified completion routine.</p>
<p>
The prototype for the client-supplied completion routine is as follows:</p>
<pre><code><b>void CALLBACK CompletionRoutine (
 IN    DWORD </b><i>dwError</i><b>, </b>
<b> IN    DWORD </b><i>cbTransferred</i><b>, </b>
<b> IN    LPWSAOVERLAPPED </b><i>lpOverlapped</i><b>, </b>
<b> IN    DWORD </b><i>dwFlags</i><b> </b>
<b>);</b>
 </code></pre>
<p>
<b>CompletionRoutine</b> is a placeholder for a client supplied function. <i>dwError</i> specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. <i>cbTransferred</i> specifies the number of bytes returned. Currently there are no flag values defined and <i>dwFlags</i> will be zero. This function does not return a value.</p>
<p>
Returning from this function allows invocation of another pending completion routine for this socket. The completion routines can be called in any order, though not necessarily in the same order that the overlapped operations are completed.</p>
<h4>Compatibility</h4>
<p>
The ioctl codes with <b>T </b>== <b>0 </b>are a subset of the ioctl codes used in Berkeley sockets. In particular, there is no command which is equivalent to FIOASYNC.</p>
<h4>Return Values</h4>
<p>
If no error occurs and the operation has completed immediately, <b>WSPIoctl</b> returns zero. Note that in this case the completion routine, if specified, will have already been queued. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code is available in <i>lpErrno</i>. The error code WSA_IO_PENDING indicates that an overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that no overlapped operation was initiated and no completion indication will occur.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=37%>WSAENETDOWN</td>
<td width=63%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEFAULT</td>
<td width=63%>The <i>lpvInBuffer</i>, <i>lpvOutBuffer</i> or<i> lpcbBytesReturned </i>argument is not totally contained in a valid part of the user address space, or the <i>cbInBuffer</i> or <i>cbOutBuffer</i> argument is too small.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEINVAL</td>
<td width=63%><i>dwIoControlCode</i> is not a valid command, or a<i> </i>supplied input parameter is not acceptable, or the command is not applicable to the type of socket supplied.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEINPROGRESS</td>
<td width=63%>The function is invoked when a callback is in progress.</td>
</tr>
<tr valign=top>
<td width=37%>WSAENOTSOCK</td>
<td width=63%>The descriptor <i>s</i> is not a socket.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEOPNOTSUPP</td>
<td width=63%>The specified ioctl command cannot be realized. For example, the flow specifications specified in SIO_SET_QOS or SIO_SET_GROUP_QOS cannot be satisfied.</td>
</tr>
<tr valign=top>
<td width=37%>WSA_IO_PENDING</td>
<td width=63%>An overlapped operation was successfully initiated and completion will be indicated at a later time.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEWOULDBLOCK</td>
<td width=63%>The socket is marked as nonblocking and the requested operation would block.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_46ia.htm"><b>WSPSocket</b></a>, <a href="wsspiref_5hte.htm"><b>WSPSetSockOpt</b></a>, <a href="wsspiref_53w2.htm"><b>WSPGetSockOpt</b></a>, <a href="wsspiref_0wvm.htm"><b>WPUQueueApc</b></a></p>
<p>&nbsp;</p></body>
</HTML>
