<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSPStartup</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wspstartup_2"></a>WSPStartup</h1>
<p>
The <b>WSPStartup</b> function initiates use of a Windows Sockets service provider by a client.</p>
<pre><code><b>int WSPStartup (
  WORD</b><i> wVersionRequested</i><b>,</b>               
<b>  LPWSPDATAW</b><i> lpWSPData</i><b>,</b>                 
<b>  LPWSAPROTOCOL_INFOW</b><i> lpProtocolInfo</i><b>,</b>   
<b>  WSPUPCALLTABLE</b><i> UpcallTable</i><b>,</b>           
<b>  LPWSPPROC_TABLE</b><i> lpProcTable           </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>wVersionRequested</i></dt>
<dd>
[in] The highest version of Windows Sockets SPI support that the caller can use. The high order byte specifies the minor version (revision) number; the low-order byte specifies the major version number.</dd>
<dt>
<i>lpWSPData</i></dt>
<dd>
[out] A pointer to the <b>WSPDATA</b> data structure that is to receive details of the Windows Sockets service provider.</dd>
<dt>
<i>lpProtocolInfo</i></dt>
<dd>
[in] A pointer to a <b>WSAPROTOCOL_INFOW</b> structure that defines the characteristics of the desired protocol. This is especially useful when a single provider DLL is capable of instantiating multiple different service providers..</dd>
<dt>
<i>UpcallTable</i></dt>
<dd>
[in] The WS2_32.DLL's upcall dispatch table.</dd>
<dt>
<i>lpProcTable</i></dt>
<dd>
[out] A pointer to the table of SPI function pointers.
</dd>
</dl>
<h4>Remarks</h4>
<p>
This function <i>must</i> be the first Windows Sockets SPI function called by a Windows Sockets SPI client on a per-process basis. It allows the client to specify the version of Windows Sockets SPI required and to provide its upcall dispatch table. All upcalls (that is, functions prefixed with <b>WPU</b>) made by the Windows Sockets service provider are invoked through the client's upcall dispatch table. This function also allows the client to retrieve details of the specific Windows Sockets service provider implementation. The Windows Sockets SPI client can only issue further Windows Sockets SPI functions after a successful <b>WSPStartup</b> invocation. A table of pointers to the rest of the SPI functions is retrieved through the <i>lpProcTable</i> parameter.</p>
<p>
In order to support future versions of the Windows Sockets SPI and the WS2_32.DLL which may have functionality differences from the current Windows Sockets SPI, a negotiation takes place in <b>WSPStartup</b>. The caller of <b>WSPStartup</b> (either the WS2_32.DLL or a layered protocol) and the Windows Sockets service provider indicate to each other the highest version that they can support, and each confirms that the other's highest version is acceptable. Upon entry to <b>WSPStartup</b>, the Windows Sockets service provider examines the version requested by the client. If this version is equal to or higher than the lowest version supported by the service provider, the call succeeds and the service provider returns in <i>wHighVersion </i>the highest version it supports and in <i>wVersion</i> the minimum of its high version and <i>wVersionRequested. </i>The Windows Sockets service provider then assumes that the Windows Sockets SPI client will use <i>wVersion. </i>If the <i>wVersion</i> field of the <b>WSPDATA</b> structure is unacceptable to the caller, it should call <b>WSPCleanup</b> and either search for another Windows Sockets service provider or fail to initialize.</p>
<p>
This negotiation allows both a Windows Sockets service provider and a Windows Sockets SPI client to support a range of Windows Sockets versions. A client can successfully utilize a Windows Sockets service provider if there is any overlap in the version ranges. The following chart gives examples of how <b>WSPStartup</b> works in conjunction with different WS2_32.DLL and Windows Sockets service provider (SP) versions: </p>
<table cellspacing=4 cols=6>
<tr valign=top>
<th align=left width=13%>DLL <br>
Versions</th>
<th align=left width=13%>SP <br>
Versions</th>
<th align=left width=16%><i>wVersion<br>
Requested</i></th>
<th align=left width=13%><i>wVersion</i></th>
<th align=left width=12%><i>wHigh<br>
Version</i></th>
<th align=left width=33%>End Result </th>
</tr>
<tr valign=top>
<td width=13%>1.1</td>
<td width=13%>1.1</td>
<td width=16%>1.1</td>
<td width=13%>1.1</td>
<td width=12%>1.1</td>
<td width=33%>use 1.1</td>
</tr>
<tr valign=top>
<td width=13%>1.0 1.1</td>
<td width=13%>1.0</td>
<td width=16%>1.1</td>
<td width=13%>1.0</td>
<td width=12%>1.0</td>
<td width=33%>use 1.0 </td>
</tr>
<tr valign=top>
<td width=13%>1.0</td>
<td width=13%>1.0 1.1</td>
<td width=16%>1.0</td>
<td width=13%>1.0</td>
<td width=12%>1.1</td>
<td width=33%>use 1.0</td>
</tr>
<tr valign=top>
<td width=13%>1.1</td>
<td width=13%>1.0 1.1</td>
<td width=16%>1.1</td>
<td width=13%>1.1</td>
<td width=12%>1.1</td>
<td width=33%>use 1.1</td>
</tr>
<tr valign=top>
<td width=13%>1.1</td>
<td width=13%>1.0</td>
<td width=16%>1.1</td>
<td width=13%>1.0</td>
<td width=12%>1.0</td>
<td width=33%>DLL fails</td>
</tr>
<tr valign=top>
<td width=13%>1.0</td>
<td width=13%>1.1</td>
<td width=16%>1.0</td>
<td width=13%>---</td>
<td width=12%>---</td>
<td width=33%>WSAVERNOTSUPPORTED</td>
</tr>
<tr valign=top>
<td width=13%>1.0 1.1</td>
<td width=13%>1.0 1.1</td>
<td width=16%>1.1</td>
<td width=13%>1.1</td>
<td width=12%>1.1</td>
<td width=33%>use 1.1</td>
</tr>
<tr valign=top>
<td width=13%>1.1 2.0</td>
<td width=13%>1.1</td>
<td width=16%>2.0</td>
<td width=13%>1.1</td>
<td width=12%>1.1</td>
<td width=33%>use 1.1</td>
</tr>
<tr valign=top>
<td width=13%>2.0</td>
<td width=13%>2.0</td>
<td width=16%>2.0</td>
<td width=13%>2.0</td>
<td width=12%>2.0</td>
<td width=33%>use 2.0</td>
</tr>
</table><br>
<p>
The following code fragment demonstrates how a Windows Sockets SPI client which supports only version 2 of Windows Sockets SPI makes a <b>WSPStartup</b> call:</p>
<pre><code>WORD wVersionRequested;
WSPDATA WSPData;
 
int err;
 
WSPUPCALLTABLE upcallTable =
{ 
    /* initialize upcallTable with function pointers */
};
 
LPWSPPROC_TABLE lpProcTable =
{ 
    /* allocate memory for the ProcTable */
};
 
wVersionRequested = MAKEWORD( 2, 2 );
 
err = WSPStartup( wVersionRequested, &amp;WSPData, lpProtocolBuffer, upcallTable, lpProcTable );
if ( err != 0 ) {
    /* Tell the user that we could not find a useable */
    /* Windows Sockets service provider.                     */
    return;
}
 
/* Confirm that the Windows Sockets service provider supports 2.2.*/
/* Note that if the service provider supports versions */
/* greater than 2.2 in addition to 2.2, it will still */
/* return 2.2 in wVersion since that is the version we  */
/* requested.                                           */
 
if ( LOBYTE( WSPData.wVersion ) != 2 ||
         HIBYTE( WSPData.wVersion ) != 2 ) {
    /* Tell the user that we could not find a useable */
    /* Windows Sockets service provider.                     */
    WSPCleanup( );
    return;   
}
 
/* The Windows Sockets service provider is acceptable. Proceed. */
 </code></pre>
<p>
And this code fragment demonstrates how a Windows Sockets service provider which supports only version 2 performs the <b>WSPStartup</b> negotiation:</p>
<pre><code>/* Make sure that the version requested is &gt;= 2.2.  */
/* The low byte is the major version and the high   */
/* byte is the minor version.                       */
 
if ( LOBYTE( wVersionRequested ) &lt; 2) ||
    ((LOBYTE( wVersionRequested ) == 2) &amp;&amp;
     (HIBYTE( wVersionRequested ) &lt; 2))) {
    return WSAVERNOTSUPPORTED;
}
 
/* Since we only support 2.2, set both wVersion and  */
/* wHighVersion to 2.2.                              */
 
lpWSPData-&gt;wVersion = MAKEWORD( 2, 2 );
lpWSPData-&gt;wHighVersion = MAKEWORD( 2, 2 );
 </code></pre>
<p>
Once the Windows Sockets SPI client has made a successful <b>WSPStartup</b> call, it can proceed to make other Windows Sockets SPI calls as needed. When it has finished using the services of the Windows Sockets service provider, the client must call <b>WSPCleanup</b> in order to allow the Windows Sockets service provider to free any resources allocated for the client.</p>
<p>
Details of how Windows Sockets service provider information is encoded in the <b>WSPData</b> structure is as follows:</p>
<pre><code>typedef struct WSPData {
    WORD        wVersion;
    WORD        wHighVersion;
    WCHAR       szDescription[WSPDESCRIPTION_LEN+1];
} WSPDATA, FAR * LPWSPDATA;
 </code></pre>
<p>
The members of this structure are:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=27%>Element</th>
<th align=left width=73%>Usage</th>
</tr>
<tr valign=top>
<td width=27%>wVersion</td>
<td width=73%>The version of the Windows Sockets SPI specification that the Windows Sockets service provider expects the caller to use.</td>
</tr>
<tr valign=top>
<td width=27%>wHighVersion</td>
<td width=73%>The highest version of the Windows Sockets SPI specification that this service provider can support (also encoded as above). Normally this will be the same as <i>wVersion</i>.</td>
</tr>
<tr valign=top>
<td width=27%>szDescription</td>
<td width=73%>A null-terminated Unicode string into which the Windows Sockets provider copies a description of itself. The text (up to 256 characters in length) can contain any characters except control and formatting characters: the most likely use that a SPI client will put this to is to display it (possibly truncated) in a status message.</td>
</tr>
</table><br>
<p>
A Windows Sockets SPI client can call <b>WSPStartup</b> more than once if it needs to obtain the WSPData structure information more than once. On each such call the client can specify any version number supported by the provider.</p>
<p>
There must be one <b>WSPCleanup</b> call corresponding to every successful <b>WSPStartup</b> call to allow third-party DLLs to make use of a Windows Sockets provider. This means, for example, that if <b>WSPStartup</b> is called three times, the corresponding call to <b>WSPCleanup</b> must occur three times. The first two calls to <b>WSPCleanup</b> do nothing except decrement an internal counter; the final <b>WSPCleanup</b> call does all necessary resource deallocation.</p>
<p>
This function (and most other service provider functions) can be invoked in a thread that started out as a 16-bit process if the client is a 16-bit Windows Sockets 1.1 client. One important limitation of 16-bit processes is that a 16-bit process cannot create threads. This is significant to service provider implementers that plan to use an internal service thread as part of the implementation.</p>
<p>
Fortunately, there are usually only two areas where the desire for a service thread is strong: (1) in the implementation of overlapped I/O completion, and (2) in the implementation of <b>WSPEventSelect</b>. Both of these areas are only accessible through new Windows Sockets 2 functions, which can only be invoked by 32-bit processes. A service thread can be safely used if several design rules are carefully followed: (1) Use a service thread only for functionality that is unavailable to 16-bit Windows Sockets 1.1 clients, and (2) create the service thread only on demand.</p>
<p>
Several other cautions apply to the use of internal service threads. First, threads generally carry some performance penalty. Use as few as possible, and avoid thread transitions wherever possible. Second, your code should always check for errors in creating threads and fail gracefully and informatively (for example, with <b>WSAEOPNOTSUPP</b>) in case some execution event you did not expect results in a 16-bit process executing a code path that needs threads.</p>
<h4>Layered Service Provider Considerations</h4>
<p>
A layered service provider supplies an implementation of this function, but it is also a client of this function when it calls <b>WSPStartup</b> to initialize the next layer in the protocol chain. The call to the next layer's <b>WSPStartup</b> may happen during the execution of this layer's <b>WSPStartup</b> or it may be delayed and called on demand, such as when <b>WSPSocket</b> is called. In any case, some special considerations apply to this function's <i>lpProtocolInfo</i> parameter as it is propagated down through the layers of the protocol chain.</p>
<p>
The layered provider searches the <i>ProtocolChain</i> of the structure referenced by <i>lpProtocolInfo</i> to determine its own location in the chain (by searching for the layer's own catalog entry <i>Id</i>) and the identity of the next element in the chain. If the next element is another layer then when the next layer's <b>WSPStartup</b> is called, this layer must pass to the next layer a <i>lpProtocolInfo</i> that references the same unmodified <b>WSAPROTOCOL_INFOW</b> structure with the same unmodified chain information. However, if the next layer is the base protocol (i.e., the last element in the chain), this layer performs a substitution when calling the base provider's <b>WSPStartup</b>. In this case, the base provider's <b>WSAPROTOCOL_INFOW</b> structure should be referenced by the <i>lpProtocolInfo</i> parameter.</p>
<p>
One vital benefit of this policy is that base service providers do not have to be aware of protocol chains.</p>
<p>
This same propagation policy applies when propagating a <b>WSAPROTOCOL_INFOW</b> structure through a layered sequence of other functions such as <b>WSPAddressToString</b>, <b>WSPDuplicateSocket</b>, <b>WSPSocket</b>, or <b>WSPStringToAddress</b>.</p>
<h4>Return Values</h4>
<p>
<b>WSPStartup</b> returns zero if successful. Otherwise, it returns one of the error codes listed below.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=43%>WSASYSNOTREADY</td>
<td width=57%>Indicates that the underlying network subsystem is not ready for network communication.</td>
</tr>
<tr valign=top>
<td width=43%>WSAVERNOTSUPPORTED</td>
<td width=57%>The version of Windows Sockets SPI support requested is not provided by this particular Windows Sockets service provider.</td>
</tr>
<tr valign=top>
<td width=43%>WSAEINPROGRESS</td>
<td width=57%>A blocking Windows Sockets operation is in progress.</td>
</tr>
<tr valign=top>
<td width=43%>WSAEPROCLIM</td>
<td width=57%>Limit on the number of clients supported by the Windows Sockets implementation has been reached.</td>
</tr>
<tr valign=top>
<td width=43%>WSAEFAULT</td>
<td width=57%>The <i>lpWSPData</i> or <i>lpProcTable</i> parameter is invalid.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_2dpu.htm"><b>WSPSend</b></a>, <a href="wsspiref_68he.htm"><b>WSPSendTo</b></a>, <a href="wsspiref_3436.htm"><b>WSPCleanup</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
