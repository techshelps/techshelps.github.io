<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSPSetSockOpt</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wspsetsockopt_2"></a>WSPSetSockOpt</h1>
<p>
The <b>WSPSetSockOpt</b> function sets a socket option.</p>
<pre><code><b>int WSPSetSockOpt (
  SOCKET</b><i> s</i><b>,</b>                  
<b>  int</b><i> level</i><b>,</b>                 
<b>  int</b><i> optname</i><b>,</b>               
<b>  const char FAR *</b><i> optval</i><b>,</b>   
<b>  int</b><i> optlen</i><b>,</b>                
<b>  LPINT</b><i> lpErrno              </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying a socket.</dd>
<dt>
<i>level</i></dt>
<dd>
[in] The level at which the option is defined; the supported <i>level</i>s include SOL_SOCKET. (See annex for more protocol-specific <i>levels</i>.)</dd>
<dt>
<i>optname</i></dt>
<dd>
[in] The socket option for which the value is to be set.</dd>
<dt>
<i>optval</i></dt>
<dd>
[in] A pointer to the buffer in which the value for the requested option is supplied.</dd>
<dt>
<i>optlen</i></dt>
<dd>
[in] The size of the <i>optval</i> buffer.</dd>
<dt>
<i>lpErrno</i></dt>
<dd>
[out] A pointer to the error code.
</dd>
</dl>
<h4>Remarks</h4>
<p>
<b>WSPSetSockOpt</b> sets the current value for a socket option associated with a socket of any type, in any state. Although options can exist at multiple protocol levels, they are always present at the uppermost "socket'' level. Options affect socket operations, such as whether broadcast messages can be sent on the socket.</p>
<p>
There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options which require an integer value or structure. To enable a Boolean option, <i>optval</i> points to a nonzero integer. To disable the option <i>optval</i> points to an integer equal to zero. <i>optlen</i> should be equal to sizeof(int) for Boolean options. For other options, <i>optval</i> points to the an integer or structure that contains the desired value for the option, and <i>optlen</i> is the length of the integer or structure.</p>
<p>
<b><i>level = </i>SOL_SOCKET</b></p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=31%>Value</th>
<th align=left width=19%>Type</th>
<th align=left width=50%>Meaning</th>
</tr>
<tr valign=top>
<td width=31%><b>SO_BROADCAST</b></td>
<td width=19%>BOOL</td>
<td width=50%>Allow transmission of broadcast messages on the socket.</td>
</tr>
<tr valign=top>
<td width=31%><b>SO_DEBUG</b></td>
<td width=19%>BOOL</td>
<td width=50%>Record debugging information. </td>
</tr>
<tr valign=top>
<td width=31%><b>SO_DONTLINGER</b></td>
<td width=19%>BOOL</td>
<td width=50%>Reserved for future use with socket groups: Do not block close waiting for unsent data to be sent. Setting this option is equivalent to setting SO_LINGER with <i>l_onoff</i> set to zero.</td>
</tr>
<tr valign=top>
<td width=31%><b>SO_DONTROUTE</b></td>
<td width=19%>BOOL</td>
<td width=50%>Do not route: send directly to interface.</td>
</tr>
<tr valign=top>
<td width=31%><b>SO_GROUP_PRIORITY</b></td>
<td width=19%>int</td>
<td width=50%>Specify the relative priority to be established for sockets that are part of a socket group.</td>
</tr>
<tr valign=top>
<td width=31%><b>SO_KEEPALIVE</b></td>
<td width=19%>BOOL</td>
<td width=50%>Send keepalives.</td>
</tr>
<tr valign=top>
<td width=31%><b>SO_LINGER</b></td>
<td width=19%>struct linger</td>
<td width=50%>Linger on close if unsent data is present.</td>
</tr>
<tr valign=top>
<td width=31%><b>SO_OOBINLINE</b></td>
<td width=19%>BOOL</td>
<td width=50%>Receive out-of-band data in the normal data stream. </td>
</tr>
<tr valign=top>
<td width=31%><b>SO_RCVBUF</b></td>
<td width=19%>int</td>
<td width=50%>Specify the total per-socket buffer space reserved for receives. This is unrelated to SO_MAX_MSG_SIZE or the size of a TCP window.</td>
</tr>
<tr valign=top>
<td width=31%><b>SO_REUSEADDR</b></td>
<td width=19%>BOOL</td>
<td width=50%>Allow the socket to be bound to an address which is already in use. (See <b>bind</b>.) </td>
</tr>
<tr valign=top>
<td width=31%><b>SO_SNDBUF</b></td>
<td width=19%>int</td>
<td width=50%>Specify the total per-socket buffer space reserved for sends. This is unrelated to SO_MAX_MSG_SIZE or the size of a TCP window.</td>
</tr>
<tr valign=top>
<td width=31%><b>PVD_CONFIG</b></td>
<td width=19%>Service Provider Dependent</td>
<td width=50%>This object stores the configuration information for the service provider associated with socket <i>s</i>. The exact format of this data structure is service provider specific.</td>
</tr>
</table><br>
<p>
Calling <b>WSPGetSockOpt</b> with an unsupported option will result in an error code of WSAENOPROTOOPT being returned in <i>lpErrno</i>.
<dl>
<dt>
<b>SO_DEBUG</b></dt>
<dd>
Windows Sockets service providers are encouraged (but not required) to supply output debug information if the SO_DEBUG option is set by a Windows Sockets SPI client. The mechanism for generating the debug information and the form it takes are beyond the scope of this specification.</dd>
<dt>
<b>SO_GROUP_PRIORITY</b></dt>
<dd>
Reserved for future use with socket groups: Group priority indicates the priority of the specified socket relative to other sockets within the socket group. Values are non-negative integers, with zero corresponding to the highest priority. Priority values represent a hint to the service provider about how potentially scarce resources should be allocated. For example, whenever two or more sockets are both ready to transmit data, the highest priority socket (lowest value for SO_GROUP_PRIORITY) should be serviced first, with the remainder serviced in turn according to their relative priorities.
<p>
The WSAENOPROTOOPT error is indicated for non group sockets or for service providers which do not support group sockets.
</dd>
<dt>
<b>SO_KEEPALIVE</b></dt>
<dd>
A Windows Sockets SPI client can request that a TCP/IP provider enable the use of "keep-alive" packets on TCP connections by turning on the SO_KEEPALIVE socket option. A Windows Sockets provider need not support the use of keep-alives: if it does, the precise semantics are implementation-specific but should conform to section 4.2.3.6 of RFC 1122: <i>Requirements for Internet Hosts — Communication Layers</i>. If a connection is dropped as the result of "keep-alives" the error code WSAENETRESET is returned to any calls in progress on the socket, and any subsequent calls will fail with WSAENOTCONN.</dd>
<dt>
<b>SO_LINGER</b></dt>
<dd>
SO_LINGER controls the action taken when unsent data is queued on a socket and a <b>WSPCloseSocket</b> is performed. See <b>WSPCloseSocket</b> for a description of the way in which the SO_LINGER settings affect the semantics of <b>WSPCloseSocket</b>. The Windows Sockets SPI client sets the desired behavior by creating a <i>struct linger</i> (pointed to by the <i>optval</i> argument) with the following elements:
<pre><code>struct linger {
    u_short    l_onoff;
    u_short    l_linger;
}
 </code></pre>

<p>
To enable SO_LINGER, a Windows Sockets SPI client should set <i>l_onoff</i> to a nonzero value, set <i>l_linger</i> to zero or the desired time-out (in seconds), and call <b>WSPSetSockOpt</b>. To enable SO_DONTLINGER (that is, disable SO_LINGER) <i>l_onoff</i> should be set to zero and <b>WSPSetSockOpt</b> should be called. Note that enabling SO_LINGER with a nonzero time-out on a nonblocking socket is not recommended (see section <i>4.1.7. WSPCloseSocket</i> for details).

<p>
Enabling SO_LINGER also disables SO_DONTLINGER, and vice versa. Note that if SO_DONTLINGER is DISABLED (that is, SO_LINGER is ENABLED) then no time-out value is specified. In this case, the time-out used is implementation dependent. If a previous time-out has been established for a socket (by enabling SO_LINGER), then this time-out value should be reinstated by the service provider.
</dd>
<dt>
<b>SO_REUSEADDR</b></dt>
<dd>
By default, a socket cannot be bound (see <b>WSPBind</b>) to a local address which is already in use. On occasion, however, it may be desirable to "re-use" an address in this way. Since every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having two sockets bound to the same local address as long as the remote addresses are different. To inform the Windows Sockets provider that a <b>WSPBind</b> on a socket should be allowed to bind to a local address that is already in use by another socket, the Windows Sockets SPI client should set the SO_REUSEADDR socket option for the socket before issuing the <b>WSPBind</b>. Note that the option is interpreted only at the time of the <b>WSPBind</b>: it is therefore unnecessary (but harmless) to set the option on a socket which is not to be bound to an existing address, and setting or resetting the option after the <b>WSPBind</b> has no effect on this or any other socket.</dd>
<dt>
<b>SO_SNDBUF</b></dt>
<dd>
When a Windows Sockets implementation supports the SO_RCVBUF and SO_SNDBUF options, a Windows Sockets SPI client can request different buffer sizes (larger or smaller). The call can succeed even though the service provider did not make available the entire amount requested. A Windows Sockets SPI client must call <b>WSPGetSockOpt</b> with the same option to check the buffer size actually provided.</dd>
<dt>
<b>PVD_CONFIG</b></dt>
<dd>
This object stores the configuration information for the service provider associated with socket <i>s</i>. The exact format of this data structure is service provider specific.
</dd>
</dl>
<h4>Return Values</h4>
<p>
If no error occurs, <b>WSPSetSockOpt</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code is available in <i>lpErrno</i>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=36%>WSAENETDOWN</td>
<td width=64%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=36%>WSAEFAULT</td>
<td width=64%><i>optval</i> is not in a valid part of the process address space or <i>optlen</i> argument is too small.</td>
</tr>
<tr valign=top>
<td width=36%>WSAEINPROGRESS</td>
<td width=64%>The function is invoked when a callback is in progress.</td>
</tr>
<tr valign=top>
<td width=36%>WSAEINPROGRESS</td>
<td width=64%>A blocking Windows Sockets call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=36%>WSAEINVAL</td>
<td width=64%><i>level</i> is not valid, or the information in <i>optval </i>is not valid.</td>
</tr>
<tr valign=top>
<td width=36%>WSAENETRESET</td>
<td width=64%>The connection has been broken due to "keep-alive" activity detecting a failure while the operation was in progress.</td>
</tr>
<tr valign=top>
<td width=36%>WSAENOPROTOOPT</td>
<td width=64%>The option is unknown or unsupported for the specified provider. </td>
</tr>
<tr valign=top>
<td width=36%>WSAENOTCONN</td>
<td width=64%>Connection has been reset when SO_KEEPALIVE is set.</td>
</tr>
<tr valign=top>
<td width=36%>WSAENOTSOCK</td>
<td width=64%>The descriptor is not a socket.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_2iuq.htm"><b>WSPBind</b></a>, <a href="wsspiref_53w2.htm"><b>WSPGetSockOpt</b></a>, <a href="wsspiref_9baq.htm"><b>WSPIoctl</b></a>, <a href="wsspiref_46ia.htm"><b>WSPSocket</b></a>, <a href="wsspiref_3p0y.htm"><b>WSPEventSelect</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
