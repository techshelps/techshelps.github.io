<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPI: Name Resolution Model</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_spi_name_resolution_model_2"></a>SPI: Name Resolution Model</h3>
<p>
In developing a protocol-independent client/server application, there are two basic requirements that exist with respect to name resolution and registration: 
<ul>
<li>
The ability of the server half of the application (hereafter referred to as a service) to register its existence within (or become accessible to) one or more name spaces</li>
<li>
The ability of the client application to find the service within a name space and obtain the required transport protocol and addressing information </li>
</ul>
<p>
For those accustomed to developing TCP/IP based applications, this may seem to involve little more than looking up a host address and then using an agreed upon port number. Other networking schemes, however, allow the location of the service, the protocol used for the service, and other attributes to be discovered at run-time. To accommodate the broad diversity of capabilities found in existing name services, the Windows Sockets 2 interface adopts the model described below. </p>
<p>
A <i>name space</i> refers to some capability to associate (as a minimum) the protocol and addressing attributes of a network service with one or more human-friendly names. Many name spaces are currently in wide use including the Internet's Domain Name System(DNS), Netware Directory Services (NDS), X.500, etc. These name spaces vary widely in how they are organized and implemented. Some of their properties are particularly important to understand from the perspective of Windows Sockets name resolution. </p>

<h4><a name="_win32_spi_types_of_name_spaces_2"></a>SPI: Types of Name Spaces</h4>
<p>
There are three different types of name spaces in which a service could be registered:
<ul>
<li>
dynamic</li>
<li>
static</li>
<li>
persistent </li>
</ul>
<p>
Dynamic name spaces allow services to register with the name space on the fly, and for clients to discover the available services at run-time. Dynamic name spaces frequently rely on broadcasts to indicate the continued availability of a network service. Examples of dynamic name spaces include the SAP name space used within a Netware environment and the NBP name space used by Appletalk. </p>
<p>
Static name spaces require all of the services to be registered ahead of time, i.e. when the name space is created. The DNS is an example of a static name space. Although there is a programmatic way to resolve names, there is no programmatic way to register names. </p>
<p>
Persistent name spaces allow services to register with the name space on the fly. Unlike dynamic name spaces however, persistent name spaces retain the registration information in non-volatile storage where it remains until such time as the service requests that it be removed. Persistent name spaces are typified by directory services such as X.500 and the NDS (Netware Directory Service). These environments allow the adding, deleting, and modification of service properties. In addition, the service object representing the service within the directory service could have a variety of attributes associated with the service. The most important attribute for client applications is the service's addressing information. </p>

<h4><a name="_win32_spi_name_space_organization_2"></a>SPI: Name Space Organization</h4>
<p>
Many name spaces are arranged hierarchically. Some, such as X.500 and NDS, allow unlimited nesting. Others allow services to be combined into a single level of hierarchy or "group." This is typically referred to as a workgroup. When constructureing a query, it is often necessary to establish a context point within a name space hierarchy from which the search will begin. </p>

<h4><a name="_win32_spi_name_space_provider_architecture_2"></a>SPI: Name Space Provider Architecture</h4>
<p>
Naturally, the programmatic interfaces used to query the various types of name spaces and to register information within a name space (if supported) differ widely. A <i>name space provider</i> is a locally-resident piece of software that knows how to map between Windows Sockets's name space SPI and some existing name space (which could be implemented locally or be accessed via the network). This is illustrated as follows: </p>
<p>
<img src="images/ovrvw3_1.gif" border=0></p>
<p>
<b>Name Space Provider Architecture</b></p>
<p>
<b>Note</b>  Note that it is possible for a given name space, say DNS, to have more than one name space provider installed on a given machine. </p>
<p>
As mentioned above, the generic term <i>service</i> refers to the server-half of a client/server application. In Windows Sockets, a service is associated with a <i>service class,</i> and each instance of a particular service has a <i>service name</i> which must be unique within the service class. Examples of service classes include FTP Server, SQL Server, XYZ Corp. Employee Info Server, etc. As the example attempts to illustrate, some service classes are "well known" while others are very unique and specific to a particular vertical application. In either case, every service class is represented by both a class name and a class ID. The class name does not necessarily need to be unique, but the class ID must be. Globally Unique Identifiers (GUIDs) are used to represent service class IDs. For well-known services, class names and class ID's (GUIDs) have been pre-allocated, and macros are available to convert between, for example, TCP port numbers and the corresponding class ID GUIDs. For other services, the developer chooses the class name and uses the UUIDGEN.EXE utility to generate a GUID for the class ID. </p>
<p>
The notion of a service class exists to allow a set of attributes to be established that are held in common by all instances of a particular service. This set of attributes is supplied to Windows Sockets at the time the service class is defined, and is referred to as the service class schema information. The WS2_32.DLL in turns relays this information to all active name space providers. When an instance of a service is installed and made available on a host machine, that service is considered instantiated, and its service name is used to distinguish this particular instance of the service from other instances which may be known to the name space.</p>
<p>
Note that the installation of a service class only needs to occur on machines where the service executes, not on all of the clients which may utilize the service. Where possible, the WS2_32.DLL will provide service class schema information to a name space provider at the time an instantiation of a service is to be registered or a service query is initiated. The WS2_32.DLL does not, of course, store this information itself, but attempts to retrieve it from a name space provider that has indicated its ability to supply this data. Since there is no guarantee that the WS2_32.DLL will be able to supply the service class schema, name space providers that need this information must have a fallback mechanism to obtain it through name space-specific means. </p>
<p>
The Internet's Domain Name System does not have a well-defined means to store service class schema information. As a result, DNS name space providers will only be able to accommodate well-known TCP/IP services for which a service class GUID has been preallocated. In practice this is not a serious limitation since service class GUIDs have been preallocated for the entire set of TCP and UDP ports, and macros are available to retrieve the GUID associated with any TCP or UDP port. Thus all of the familiar services such as ftp, telnet, whois, etc. are well supported. When querying for these services, by convention the host name of the target machine is the service instance name. </p>
<p>
Continuing with our service class example, instance names of the ftp service may be "alder.intel.com" or "rhino.microsoft.com" while an instance of the XYZ Corp. Employee Info Server might be named "XYZ Corp. Employee Info Server Version 3.5". In the first two cases, the combination of the service class GUID for ftp and the machine name (supplied as the service instance name) uniquely identify the desired service. In the third case, the host name where the service resides can be discovered at service query time, so the service instance name does not need to include a host name. </p>
<p>&nbsp;</p></body>
</HTML>
