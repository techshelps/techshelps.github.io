<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WPUModifyIFSHandle</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wpumodifyifshandle_2"></a>WPUModifyIFSHandle</h1>
<p>
The <b>WPUModityIFSHandle</b> function receives (possibly) modified IFS handle from WS2_32.DLL.</p>
<pre><code><b>SOCKET WPUModifyIFSHandle (
  DWORD</b><i> dwCatalogEntryId</i><b>,</b>   
<b>  SOCKET</b><i> ProposedHandle</i><b>,</b>   
<b>  LPINT</b><i> lpErrno            </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>dwCatalogEntryId</i></dt>
<dd>
[in] A descriptor identifying the calling service provider.</dd>
<dt>
<i>ProposedHandle</i></dt>
<dd>
[in] An Installable File System(IFS) handle allocated by the provider.</dd>
<dt>
<i>lpErrno</i></dt>
<dd>
[out] A pointer to the error code.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>WPUModityIFSHandle </b>handle allows the WS2_32.DLL to streamline its internal operations by returning a possibly modified version of the supplied IFS handle. It is guaranteed that the returned handle is indistinguishable from the proposed handle as far as the operating system is concerned. IFS providers <i>must</i> call this function before returning any newly created socket descriptor to a service provider. The service provider will only use the modified handle for any subsequent socket operations.</p>
<p>
This routine is only used by IFS providers whose socket descriptors are real Installable File System handles.</p>
<h4>Layered Service Provider Considerations</h4>
<p>
This procedure may also be used by a layered provider that is layered on top of a base IFS provider and wants to expose the base provider's socket handles as its own instead of creating them with the <b>WPUCreateSocketHandle</b> call. A layered provider that wishes to "pass through" the IFS socket handles it receives from the next layer in the chain can call <b>WPUModifyIFSHandle</b>, passing its own catalog entry Id as <i>dwCatalogEntryId</i>. This informs the Windows Sockets DLL that this layer, and not the next layer, should be the target for SPI calls involving that socket handle.</p>
<p>
There are several limitations a layered provider should observe if it takes this approach.
<ul>
<li>
The provider should expose base provider entry points for <b>WSPSend</b> and <b>WSPRecv</b> in the procedure dispatch table it returns at the time of <b>WSPStartup</b> to make sure the Windows Sockets SPI client's access to these functions is as efficient as possible.</li>
<li>
The provider can not rely on its <b>WSPSend</b> and <b>WSPRecv</b> functions being invoked for all IO, particularly in the case of the IO system functions <b>ReadFile</b> and <b>WriteFile</b>. These functions would bypass the layered provider and invoke the base IFS provider's implementation directly even if the layered provider puts its own entry points for these functions into the procedure dispatch table.</li>
<li>
The provider can not rely on any ability to post-process overlapped IO using <b>WSPSend</b>, <b>WSPSendTo</b>, <b>WSPRecv</b>, <b>WSPRecvFrom</b>, or <b>WSPIoctl</b>. Post-processing notification may happen through completion ports and bypass the layered provider entirely. A layered provider has no way to determine that a completion port was used or determine what port it is. The layered provider has no way to insert itself into the notification sequence.</li>
<li>
The provider should pass through all overlapped IO requests directly to the base provider using the original overlapped parameters (for example, <b>WSAOVERLAPPED</b> structure and completion routine pointer). The provider should expose the base provider entry point for <b>WSPGetOverlappedResult</b>. Since some overlapped IO requests can bypass the layered provider completely the layered provider cannot reliably mark WSAOVERLAPPED structures to determine which ones it can report results for, and which ones would have to be passed through to the underlying provider's <b>WSPGetOverlappedResult</b>. This effectively means that <b>WSPIoctl</b> has to be a pass-through operation to the underlying provider.</li>
</ul>
<h4>Return Values</h4>
<p>
If no error occurs, <b>WPUModifyIFSHandle</b> returns the modified socket handle. Otherwise, it returns INVALID_SOCKET, and a specific error code is available in <i>lpErrno</i>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=27%>WSAEINVAL</td>
<td width=73%>The proposed handle is invalid.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_8m0i.htm"><b>WPUCreateSocketHandle</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
