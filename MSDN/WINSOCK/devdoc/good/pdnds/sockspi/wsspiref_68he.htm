<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSPSendTo</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wspsendto_2"></a>WSPSendTo</h1>
<p>
The <b>WSPSendTo</b> function sends data to a specific destination using overlapped I/O.</p>
<pre><code><b>int WSPSendTo (
  SOCKET</b><i> s</i><b>,</b>                                                 
<b>  LPWSABUF</b><i> lpBuffers</i><b>,</b>                                       
<b>  DWORD</b><i> dwBufferCount</i><b>,</b>                                      
<b>  LPDWORD</b><i> lpNumberOfBytesSent</i><b>,</b>                              
<b>  DWORD</b><i> dwFlags</i><b>,</b>                                            
<b>  const struct sockaddr FAR *</b><i> lpTo</i><b>,</b>                         
<b>  int</b><i> iTolen</i><b>,</b>                                               
<b>  LPWSAOVERLAPPED</b><i> lpOverlapped</i><b>,</b>                             
<b>  LPWSAOVERLAPPED_COMPLETION_ROUTINE</b><i> lpCompletionRoutine</i><b>,</b>   
<b>  LPWSATHREADID</b><i> lpThreadId</i><b>,</b>                                 
<b>  LPINT</b><i> lpErrno                                             </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] A descriptor identifying a socket.</dd>
<dt>
<i>lpBuffers</i></dt>
<dd>
[in] A pointer to an array of <b>WSABUF</b> structures. Each <b>WSABUF </b>structure contains a pointer to a buffer and the length of the buffer. This array must remain valid for the duration of the send operation.</dd>
<dt>
<i>dwBufferCount</i></dt>
<dd>
[in] The number of <b>WSABUF</b> structures in the <i>lpBuffers </i>array.</dd>
<dt>
<i>lpNumberOfBytesSent</i></dt>
<dd>
[out] A pointer to the number of bytes sent by this call.</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
[in] Specifies the way in which the call is made.</dd>
<dt>
<i>lpTo</i></dt>
<dd>
[in] An optional pointer to the address of the target socket.</dd>
<dt>
<i>iTolen</i></dt>
<dd>
[in] The size of the address in <i>lpTo</i>.</dd>
<dt>
<i>lpOverlapped</i></dt>
<dd>
[in] A pointer to a WSAOVERLAPPED structure (ignored for non-overlapped sockets).</dd>
<dt>
<i>lpCompletionRoutine</i></dt>
<dd>
[in] A pointer to the completion routine called when the send operation has been completed (ignored for non-overlapped sockets).</dd>
<dt>
<i>lpThreadId</i></dt>
<dd>
[in] A pointer to a <b>WSATHREADID</b> structure to be used by the provider in a subsequent call to <b>WPUQueueApc</b>. The provider should store the referenced <b>WSATHREADID</b> structure (not the pointer to same) until after the <b>WPUQueueApc</b> function returns.</dd>
<dt>
<i>lpErrno</i></dt>
<dd>
[out] A pointer to the error code.
</dd>
</dl>
<h4>Remarks</h4>
<p>
<b>WSPSendTo</b> is normally used on a connectionless socket specified by <i>s</i> to send a datagram contained in one or more buffers to a specific peer socket identified by the <i>lpTo</i> parameter. Even if the connectionless socket has been previously connected to a specific address with the <b>connect</b> function, <i>lpTo</i> overrides the destination address for that particular datagram only. On a connection-oriented socket, the <i>lpTo</i> and <i>iToLen </i>parameters are ignored; in this case the <b>WSPSendTo</b> function is equivalent to <b>WSPSend</b>.</p>
<p>
For overlapped sockets (created using <b>WSPSocket</b> with flag WSA_FLAG_OVERLAPPED) this will occur using overlapped I/O, unless both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are NULL in which case the socket is treated as a nonoverlapped socket. A completion indication will occur (invocation of the completion routine or setting of an event object) when the supplied buffer(s) have been consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or <b>WSPGetOverlappedResult</b>.</p>
<p>
For nonoverlapped sockets, the parameters <i>lpOverlapped</i>,<i> lpCompletionRoutine</i>, and <i>lpThreadId</i> are ignored and <b>WSPSendTo</b> adopts the regular synchronous semantics. Data is copied from the supplied buffer(s) into the transport's buffer. If the socket is nonblocking and stream oriented, and there is not sufficient space in the transport's buffer, <b>WSPSendTo</b> will return with only part of the Windows Sockets SPI client's buffers having been consumed. Given the same buffer situation and a blocking socket, <b>WSPSendTo</b> will block until all of the Windows Sockets SPI client's buffer contents have been consumed.</p>
<p>
The array of WSABUF structures pointed to by the lpBuffers parameter is transient. If this operation completes in an overlapped manner, it is the service provider's responsibility to capture these WSABUF structures before returning from this call. This enables applications to build stack-based WSABUF arrays.</p>
<p>
For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport, which can be obtained by getting the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol the error WSAEMSGSIZE is returned, and no data is transmitted.</p>
<p>
Note that the successful completion of a <b>WSPSendTo</b> does not indicate that the data was successfully delivered.</p>
<p>
<i>iFlags</i> can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the <i>dwFlags</i> parameter. The latter is constructed by OR-ing any of the following values:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=37%>Value</th>
<th align=left width=63%>Meaning</th>
</tr>
<tr valign=top>
<td width=37%>MSG_DONTROUTE</td>
<td width=63%>Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.</td>
</tr>
<tr valign=top>
<td width=37%>MSG_OOB</td>
<td width=63%>Send out-of-band data (stream-style socket such as SOCK_STREAM only).</td>
</tr>
<tr valign=top>
<td width=37%>MSG_PARTIAL</td>
<td width=63%>Specifies that <i>lpBuffers</i> only contains a partial message. Note that the error code WSAEOPNOTSUPP will be returned by transports which do not support partial message transmissions.</td>
</tr>
</table><br>
<h4>Overlapped socket I/O</h4>
<p>
If an overlapped operation completes immediately, <b>WSPSendTo</b> returns a value of zero and the <i>lpNumberOfBytesSent</i> parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later, <b>WSPSendTo</b> returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, <i>lpNumberOfBytesSent</i> is not updated. When the overlapped operation completes the amount of data transferred is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in <b>WSPGetOverlappedResult</b>.</p>
<p>
Providers must allow this function to be called from within the completion routine of a previous <b>WSPRecv</b>, <b>WSPRecvFrom</b>, <b>WSPSend</b> or <b>WSPSendTo</b> function. However, for a given socket, I/O completion routines cannot be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.</p>
<p>
The <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate overlapped structure. The WSAOVERLAPPED structure has the following form:</p>
<pre><code>typedef struct _WSAOVERLAPPED {
    DWORD       Internal;        // reserved
    DWORD       InternalHigh;    // reserved
    DWORD       Offset;          // reserved
    DWORD       OffsetHigh;      // reserved
    WSAEVENT    hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;
 </code></pre>
<p>
If the <i>lpCompletionRoutine</i> parameter is NULL, the service provider signals the <i>hEvent</i> field of <i>lpOverlapped</i> when the overlapped operation completes if it contains a valid event object handle. Windows Sockets SPI clients can use <b>WSPGetOverlappedResult</b> to wait or poll on the event object.</p>
<p>
If <i>lpCompletionRoutine</i> is not NULL, the <i>hEvent</i> field is ignored and can be used by the Windows Sockets SPI client to pass context information to the completion routine. A client that passes a non-NULL <i>lpCompletionRoutine</i> and later calls <b>WSAGetOverlappedResult</b> for the same overlapped IO request may not set the <i>fWait</i> parameter for that invocation of <b>WSAGetOverlappedResult</b> to TRUE. In this case the usage of the <i>hEvent</i> field is undefined, and attempting to wait on the <i>hEvent</i> field would produce unpredictable results.</p>
<p>
It is the service provider's responsibility to arrange for invocation of the client-specified completion routine when the overlapped operation completes. Since the completion routine must be executed in the context of the same thread that initiated the overlapped operation, it cannot be invoked directly from the service provider. The WS2_32.DLL offers an asynchronous procedure call (APC) mechanism to facilitate invocation of completion routines.</p>
<p>
A service provider arranges for a function to be executed in the proper thread by calling <b>WPUQueueApc</b>. This function can be called from any process and thread context, even a context different from the thread and process that was used to initiate the overlapped operation.</p>
<p>
<b>WPUQueueApc</b> takes as input parameters a pointer to a <b>WSATHREADID</b> structure (supplied to the provider through the <i>lpThreadId </i>input parameter), a pointer to an APC function to be invoked, and a 32-bit context value that is subsequently passed to the APC function. Because only a single 32-bit context value is available, the APC function cannot itself be the client-specified completion routine. The service provider must instead supply a pointer to its own APC function which uses the supplied context value to access the needed result information for the overlapped operation, and then invokes the client-specified completion routine.</p>
<p>
The prototype for the client-supplied completion routine is as follows:</p>
<pre><code><b>void CALLBACK CompletionRoutine (
 IN    DWORD </b><i>dwError</i><b>, </b>
<b> IN    DWORD </b><i>cbTransferred</i><b>, </b>
<b> IN    LPWSAOVERLAPPED </b><i>lpOverlapped</i><b>, </b>
<b> IN    DWORD </b><i>dwFlags</i><b> </b>
<b>);</b>
</code></pre>
<p>
<b>CompletionRoutine</b> is a placeholder for a client supplied function name. <i>dwError</i> specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. <i>cbTransferred</i> specifies the number of bytes sent. No flag values are currently defined and the <i>dwFlags</i> value will be zero. This function does not return a value.</p>
<p>
The completion routines can be called in any order, though not necessarily in the same order that the overlapped operations are completed. However, the service provider guarantees to the client that posted buffers are sent in the same order they are supplied.</p>
<h4>Return Values</h4>
<p>
If no error occurs and the receive operation has completed immediately, <b>WSPSendTo</b> returns zero. Note that in this case the completion routine, if specified, will have already been queued. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code is available in <i>lpErrno</i>. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that no overlapped operation was initiated and no completion indication will occur.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=40%>WSAENETDOWN</td>
<td width=60%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEACCES</td>
<td width=60%>The requested address is a broadcast address, but the appropriate flag was not set.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEINTR</td>
<td width=60%>The (blocking) call was canceled through <b>WSPCancelBlockingCall</b>.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEINPROGRESS</td>
<td width=60%>A blocking Windows Sockets call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEFAULT</td>
<td width=60%>The <i>lpBuffers </i>or <i>lpTo </i>parameters are not part of the user address space, or the <i>lpTo </i>argument is too small.</td>
</tr>
<tr valign=top>
<td width=40%>WSAENETRESET</td>
<td width=60%>The connection has been broken due to "keep-alive" activity detecting a failure while the operation was in progress.</td>
</tr>
<tr valign=top>
<td width=40%>WSAENOBUFS</td>
<td width=60%>The Windows Sockets provider reports a buffer deadlock.</td>
</tr>
<tr valign=top>
<td width=40%>WSAENOTCONN</td>
<td width=60%>The socket is not connected (connection-oriented sockets only)</td>
</tr>
<tr valign=top>
<td width=40%>WSAENOTSOCK</td>
<td width=60%>The descriptor is not a socket.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEOPNOTSUPP</td>
<td width=60%>MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, out-of-band data is not supported in the communication domain associated with this socket, MSG_PARTIAL is not supported, or the socket is unidirectional and supports only receive operations.</td>
</tr>
<tr valign=top>
<td width=40%>WSAESHUTDOWN</td>
<td width=60%>The socket has been shut down; it is not possible to <b>WSPSendTo</b> on a socket after <b>WSPShutdown</b> has been invoked with how set to SD_SEND or SD_BOTH.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEWOULDBLOCK</td>
<td width=60%>Overlapped sockets: There are too many outstanding overlapped I/O requests. Non-overlapped sockets: The socket is marked as nonblocking and the send operation cannot be completed immediately.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEMSGSIZE</td>
<td width=60%>The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEINVAL</td>
<td width=60%>The socket has not been bound with <b>WSPBind</b>, or the socket is not created with the overlapped flag.</td>
</tr>
<tr valign=top>
<td width=40%>WSAECONNABORTED</td>
<td width=60%>The virtual circuit was terminated due to a time-out or other failure.</td>
</tr>
<tr valign=top>
<td width=40%>WSAECONNRESET</td>
<td width=60%>The virtual circuit was reset by the remote side.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEADDRNOTAVAIL</td>
<td width=60%>The remote address is not a valid address (for example, ADDR_ANY).</td>
</tr>
<tr valign=top>
<td width=40%>WSAEAFNOSUPPORT</td>
<td width=60%>Addresses in the specified family cannot be used with this socket.</td>
</tr>
<tr valign=top>
<td width=40%>WSAEDESTADDRREQ</td>
<td width=60%>A destination address is required.</td>
</tr>
<tr valign=top>
<td width=40%>WSAENETUNREACH</td>
<td width=60%>The network cannot be reached from this host at this time.</td>
</tr>
<tr valign=top>
<td width=40%>WSA_OPERATION_ABORTED</td>
<td width=60%>The overlapped operation has been canceled due to the closure of the socket, or the execution of the SIO_FLUSH command in <b>WSPIoctl</b>.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_46ia.htm"><b>WSPSocket</b></a>, <a href="wsspiref_36nm.htm"><b>WSPGetOverlappedResult</b></a>, <a href="wsspiref_0wvm.htm"><b>WPUQueueApc</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
