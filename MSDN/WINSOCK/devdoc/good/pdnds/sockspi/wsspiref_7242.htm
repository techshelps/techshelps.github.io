<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSPDuplicateSocket</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wspduplicatesocket_2"></a>WSPDuplicateSocket</h1>
<p>
The <b>WSPDuplicateSocket</b> function returns a <b>WSAPROTOCOL_INFOW</b> structure that can be used to create a new socket descriptor for a shared socket.</p>
<pre><code><b>int WSPDuplicateSocket (
  SOCKET</b><i> s</i><b>,</b>                             
<b>  DWORD</b><i> dwProcessId</i><b>,</b>                    
<b>  LPWSAPROTOCOL_INFOW</b><i> lpProtocolInfo</i><b>,</b>   
<b>  LPINT</b><i> lpErrno</i>                         
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>s</i></dt>
<dd>
[in] Specifies the local socket descriptor.</dd>
<dt>
<i>dwProcessId</i></dt>
<dd>
[in] Specifies the ID of the target process for which the shared socket will be used.</dd>
<dt>
<i>lpProtocolInfo</i></dt>
<dd>
[out] A pointer to a buffer allocated by the client that is large enough to contain a <b>WSAPROTOCOL_INFOW</b> structure. The service provider copies the protocol info structure contents to this buffer.</dd>
<dt>
<i>lpErrno</i></dt>
<dd>
[out] A pointer to the error code.
</dd>
</dl>
<h4>Remarks</h4>
<p>
A source process calls <b>WSPDuplicateSocket</b> to obtain a special <b>WSAPROTOCOL_INFOW</b> structure. It uses some interprocess communications (IPC) mechanism to pass the contents of this structure to a target process, which in turn uses it in a call to <a href="wsspiref_46ia.htm"><b>WSPSocket</b></a> to obtain a descriptor for the duplicated socket. Note that the special <b>WSAPROTOCOL_INFOW</b> structure can only be used once by the target process.</p>
<p>
It is the service provider's responsibility to perform whatever operations are needed in the source process context and to create a <b>WSAPROTOCOL_INFOW</b> structure that will be recognized when it subsequently appears as a parameter to <a href="wsspiref_46ia.htm"><b>WSPSocket</b></a> in the target processes' context. The provider must then return a socket descriptor that references a common underlying socket. The <i>dwProviderReserved</i> field of the <b>WSAPROTOCOL_INFOW</b> structure is available for the service provider's use, and can be used to store any useful context information, including a duplicated handle.</p>
<p>
As is described in section <i>3.4.1. Descriptor Allocation</i>, when new socket descriptors are allocated IFS providers must call <a href="wsspiref_30mq.htm"><b>WPUModifyIFSHandle</b></a> and non-IFS providers must call <a href="wsspiref_8m0i.htm"><b>WPUCreateSocketHandle</b></a>.</p>
<p>
One possible scenario for establishing and using a shared socket in a handoff mode is illustrated below:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=46%>Source Process</th>
<th align=left width=8%>IPC</th>
<th align=left width=46%>Destination Process</th>
</tr>
<tr valign=top>
<td width=46%>1) WSPSocket, WSPConnect</td>
<td width=8%></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%>2) Request target process ID</td>
<td width=8%><font face="Symbol">Þ</font></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%></td>
<td width=46%>3) Receive process ID request and respond</td>
</tr>
<tr valign=top>
<td width=46%>4) Receive process ID</td>
<td width=8%><font face="Symbol">Ü</font></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%>5) Call <b>WSPDuplicateSocket</b> to get a special <b>WSAPROTOCOL_INFOW</b> structure</td>
<td width=8%></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%>6) Send <b>WSAPROTOCOL_INFOW</b> structure to target</td>
<td width=8%></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><font face="Symbol">Þ</font></td>
<td width=46%>7) Receive <b>WSAPROTOCOL_INFOW</b> structure</td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%></td>
<td width=46%>8) Call WSPSocket to create shared socket descriptor.</td>
</tr>
<tr valign=top>
<td width=46%>10) <a href="wsspiref_533m.htm"><b>WSPClosesocket</b></a></td>
<td width=8%></td>
<td width=46%>9) Use shared socket for data exchange</td>
</tr>
</table><br>
<h4>Return Values</h4>
<p>
If no error occurs, <b>WSPDuplicateSocket</b> returns zero. Otherwise, the value of SOCKET_ERROR is returned, and a specific error number is available in <i>lpErrno</i>.</p>
<h4>Comments</h4>
<p>
The descriptors that reference a shared socket can be used independently as far as I/O is concerned. However, the Windows Sockets interface does not implement any type of access control, so it is up to the processes involved to coordinate their operations on a shared socket. A typical use for shared sockets is to have one process that is responsible for creating sockets and establishing connections, hand off sockets to other processes which are responsible for information exchange.</p>
<p>
Since what is duplicated are the socket descriptors and not the underlying socket, all of the state associated with a socket is held in common across all the descriptors. For example a <a href="wsspiref_5hte.htm"><b>WSPSetSockOpt</b></a> operation performed using one descriptor is subsequently visible using a <a href="wsspiref_53w2.htm"><b>WSPGetSockOpt</b></a> from any or all descriptors. A process can call <a href="wsspiref_533m.htm"><b>WSPClosesocket</b></a> on a duplicated socket and the descriptor will become deallocated. The underlying socket, however, will remain open until <b>WSPClosesocket</b> is called by the last remaining descriptor.</p>
<p>
Notification on shared sockets is subject to the usual constraints of <a href="wsspiref_74du.htm"><b>WSPAsyncSelect</b></a> and <a href="wsspiref_3p0y.htm"><b>WSPEventSelect</b></a>. Issuing either of these calls using any of the shared descriptors cancels any previous event registration for the socket, regardless of which descriptor was used to make that registration. Thus, for example, a shared socket cannot deliver FD_READ events to process A and FD_WRITE events to process B. For situations when such tight coordination is required, it is suggested that developers use threads instead of separate processes.</p>
<p>
A layered service provider supplies an implementation of this function, but it is also a client of this function if and when it calls <a href="#_win32_wspduplicatesocket_2"><b>WSPDuplicateSocket</b></a> of the next layer in the protocol chain. Some special considerations apply to this function's <i>lpProtocolInfo</i> parameter as it is propagated down through the layers of the protocol chain.</p>
<p>
If the next layer in the protocol chain is another layer then when the next layer's <b>WSPDuplicateSocket</b> is called, this layer must pass to the next layer a <i>lpProtocolInfo</i> that references the same unmodified <b>WSAPROTOCOL_INFOW</b> structure with the same unmodified chain information. However, if the next layer is the base protocol (i.e., the last element in the chain), this layer performs a substitution when calling the base provider's <b>WSPDuplicateSocket</b>. In this case, the base provider's <b>WSAPROTOCOL_INFOW</b> structure should be referenced by the <i>lpProtocolInfo</i> parameter.</p>
<p>
One vital benefit of this policy is that base service providers do not have to be aware of protocol chains. This same propagation policy applies when propagating a <b>WSAPROTOCOL_INFOW</b> structure through a layered sequence of other functions such as <a href="wsspiref_19pu.htm"><b>WSPAddressToString</b></a>, <a href="wsspiref_3xbm.htm"><b>WSPStartup</b></a>, <a href="wsspiref_46ia.htm"><b>WSPSocket</b></a>, or <a href="wsspiref_0wdu.htm"><b>WSPStringToAddress</b></a>.</p>
<h4>Error Codes</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=37%>WSAENETDOWN</td>
<td width=63%>The network subsystem has failed.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEINVAL</td>
<td width=63%>Indicates that one of the specified parameters was invalid.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEINPROGRESS</td>
<td width=63%>A blocking Windows Sockets call is in progress, or the service provider is still processing a callback function.</td>
</tr>
<tr valign=top>
<td width=37%>WSAEMFILE</td>
<td width=63%>No more socket descriptors are available.</td>
</tr>
<tr valign=top>
<td width=37%>WSAENOBUFS</td>
<td width=63%>No buffer space is available. The socket cannot be created.</td>
</tr>
<tr valign=top>
<td width=37%>WSAENOTSOCK</td>
<td width=63%>The descriptor is not a socket.</td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Yes<br>
&nbsp;&nbsp;<b>Windows:</b> Yes<br>
&nbsp;&nbsp;<b>Windows CE:</b>  Unsupported.<br>
&nbsp;&nbsp;<b>Header:</b> Declared in ws2spi.h.</p>
<h4>See Also</h4>
<p>
<a href="wsspiref_8m0i.htm"><b>WPUCreateSocketHandle</b></a>, <a href="wsspiref_30mq.htm"><b>WPUModifyIFSHandle</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
