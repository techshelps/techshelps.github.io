<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using CAP</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_tools_using_cap"></a>Using CAP</h2>
<p>
CAP consists of the following files: </p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=33%>File</th>
<th align=left width=67%>Description</th>
</tr>
<tr valign=top>
<td width=33%>CAP.INI</td>
<td width=67%>Call Attributed Profiler initialization file.</td>
</tr>
<tr valign=top>
<td width=33%>CAP.DLL</td>
<td width=67%>Call Attributed Profiler DLL.</td>
</tr>
<tr valign=top>
<td width=33%>CAP.LIB</td>
<td width=67%>Call Attributed Profiler import library.</td>
</tr>
<tr valign=top>
<td width=33%>CAPDUMP.EXE</td>
<td width=67%>Allows collecting or clearing of profiling data and stopping profiling at any time.</td>
</tr>
<tr valign=top>
<td width=33%>CAPSETUP.EXE</td>
<td width=67%>Allows attaching CAP.DLL to Win32-based applications and detaching CAP.DLL from Win32-based applications.</td>
</tr>
<tr valign=top>
<td width=33%>CAPSTATS.EXE</td>
<td width=67%>Allows parsing and summarizing of data in .CAP files.</td>
</tr>
</table><br>
<p>
Windows NT does not ship with debugging symbols in its modules because it takes many megabytes of disk space to provide them. So, you should first run the APF32CVT utility on your application, with no action specified. This will give you a list of the system DLLs that need symbols. You can get the versions of the system with symbols (.DBG files) from your Windows NT CD, under SUPPORT\DEBUG. Then you rename the current system DLL; for example, type </p>
<p>
<b>ren</b> gdi32.dll gdi32.nsm</p>
<p>
Then copy the debug DLL from the CD to GDI32.DLL. Once you have done this for all the DLLs you want to measure, you must shut down and restart Windows NT so that the DLLs with symbols are loaded.</p>
<p>
Next, set up an initialization file called CAP.INI in one of the following locations:
<ul>
<li>
The current directory</li>
<li>
The Windows directory</li>
<li>
The root directory of the current drive</li>
<li>
The root directory of drive C</li>
</ul>
<p>
The CAP.INI file has sections that control the set of .EXEs and DLLs profiled. Each .EXE or .DLL listed must be placed on a separate line. The format of this file must be correct; otherwise, Windows NT might not start. The sections of CAP.INI are as follows:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=33%>Section</th>
<th align=left width=67%>Description</th>
</tr>
<tr valign=top>
<td width=33%>[EXES]</td>
<td width=67%>A list of applications to be profiled. Each name must be on a new line. When CAP.DLL initializes, it checks the current executable name against this list and will start profiling if the name is on the list. If the name is not on the list, CAP doesn't profile that process.</td>
</tr>
<tr valign=top>
<td width=33%>[PATCH IMPORTS]</td>
<td width=67%>A list of .DLLs and .EXEs<i> </i>to be profiled for imported entries. Each name must be on a new line. Listing a .DLL or .EXE here causes the profiling of all functions called by the listed .DLLs and .EXEs.</td>
</tr>
<tr valign=top>
<td width=33%>[PATCH CALLERS]</td>
<td width=67%>A list of .DLLs to be profiled for exported entries. Each name must be on a new line. DLLs listed here are profiled when called by the applications listed in the [EXE] section, or by any of their DLLs. </td>
</tr>
<tr valign=top>
<td width=33%>[NAME LENGTH]</td>
<td width=67%>The maximum length of a symbol to be printed in the output files. This number must be in the range from 20 to 2048. For C++ programs, this value should be set to at least 128 due to the name elaboration that is performed by the linker. If a symbol is longer than this value, it is truncated. If the field is not specified or is 0, the value defaults to 40. This section is optional.</td>
</tr>
<tr valign=top>
<td width=33%>[CHRONO FUNCS]</td>
<td width=67%>List of .DLLs, .EXEs, and corresponding functions that start the chronological listing. For example, "test=SomeFunc" indicates that all functions called from the "SomeFunc" function of the "test" module are listed, until the call depth is less than or equal to the depth of "SomeFunc".</td>
</tr>
<tr valign=top>
<td width=33%>[EXCLUDE FUNCS]</td>
<td width=67%>List of .DLLs, .EXEs, and corresponding functions that will be excluded from the profiling. However, if these functions call other functions that have not been excluded, they will be still included in the profiling.</td>
</tr>
<tr valign=top>
<td width=33%>[OUTPUT FILE]</td>
<td width=67%>Specifies a different drive and filename for the output file. For example, use filename=c:\results\solitaire\sol.cap.</td>
</tr>
<tr valign=top>
<td width=33%>[CAP FLAGS]</td>
<td width=67%>The following flags can be specified as "on" or "off": profile (profiling), dumpbinary (output in binary form), capthread (start 3 threads for CapDump), loadlibrary (init symbol table on LoadLibrary), setjump (intercept setjmp and longjmp), undecoratename (undecorated names), excelaware (delimiters for Excel import), regular dump (regular data), chronocollect (chronological listing collect), chronodump (chronological listing output), and slowsymbols (exhaustive symbol lookup) </td>
</tr>
</table><br>
<p>
Headers for the first three sections ([EXES], [PATCH IMPORTS], and [PATCH CALLERS]) are required in the CAP.INI file, but the contents of any section may be left blank. </p>
<p>
Next, attach CAP.DLL to the application process. Use one of the following methods to do this:
<ul>
<li>
Recompile using the <b>-Gh</b> and <b>-Zd</b> options. Then link with CAP.LIB and the <b>-debugtype:coff</b> and <b>-debug:mapped,partial</b> options. Run the application. If you are using WIN32.MAK, you can automatically specify these compiler and link options by using the following command line: nmake profile=1. For more information, see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_building_applications_using_win32.mak_pt">
</object><a href=JavaScript:alink_1.Click()>Building Applications Using WIN32.MAK</a>. <ul>
<li>
-or-</li>
</ul>
</li>
<li>
Place CAP.DLL in your system directory (for example, C:\WINNT\SYSTEM32). Run <b>CapSetup -A</b> to attach CAP.DLL to all Win32-based applications (it uses the AppInit_DLLs key in the registry). Administrator privilege is required. Reboot the system. Run your application. Only those applications listed in the [EXES] section of CAP.INI are profiled. You must explicitly list the modules whose functions you want profiled in the [PATCH IMPORTS] or [PATCH CALLERS] section of CAP.INI. Run <b>CapSetup -D</b> to detach CAP.DLL when you have finished profiling. Reboot the system.</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
