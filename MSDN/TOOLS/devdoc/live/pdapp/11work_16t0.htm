<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Looking Inside Your Working Set</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_tools_looking_inside_your_working_set"></a>Looking Inside Your Working Set</h1>
<p>
You may want to get a better understanding of the pieces inside the working set of your application. For example, you may save a lot of code space with the Working Set Tuner only to discover that the code space is only a small portion of your overall working set. In fact, this might even be something you want to do before you go to all the trouble to tune your code. </p>
<p>
You probably want to make these measurements on a test computer. Choose a computer large enough to hold your entire working-set tuning test scenario in memory. You may need to discover this size through the trial and error process described in this section.</p>
<p>
To do this, you can use a tool called Virtual Address Dump, or VADump. The VADump tool looks inside the working set of a process and determines the nature of each page. </p>
<p>
First, link your application using the <b>-debug</b> and <b>-debugtype:coff</b> options, so you get full use from VADump.</p>
<p>
Start your application, then start PView. Use PView to note the process identifier of your application. You'll need to supply this to VADump. You should convert the process identifier from hexadecimal to decimal, since VADump expects it in decimal format. Or you can use the TLIST utility to get the process identifier directly in decimal form. </p>
<p>
Set up your test scenario. Start Performance Monitor and leave it running, and command window so you can run VADump. Type the following in the command window, but don't press enter yet.</p>
<p>
<b>vadump</b> -o -m -p <i>PID</i> &gt; app.vad</p>
<p>
The <b>-o</b> option tells VADump to monitor the working set in the original style, the <b>-m</b> option tells VADump to use the mapped symbols, and the <b>-p</b> option indicates the process identifier (<i>PID</i>), in decimal, of the process to measure. In the example command line, the output is directed to the file APP.VAD. Again, do not press ENTER yet.</p>
<p>
You should flush everything from memory and the disk cache. You can use the CLEARMEM utility from the Resource Kit. Running CLEARMEM a few times generally completes the flush; however, you may want to watch your working set with Performance Monitor to be sure. Then switch to your application and execute the test scenario you devised for tuning the working set.</p>
<p>
Now switch to the VADump window and press the enter key execute the VADump command created earlier. The results will be put in APP.VAD if you use the command line we showed earlier.</p>
<p>
Take a look at Performance Monitor again and get the new size for your application's working set. This is likely to be a bit larger now than before, because VADump itself must bring some pages into the working set to scan all the page tables and working set entries for your application. </p>
<p>
Run the scenario in your application again. Performance Monitor should get no page faults in your application during this run. If it does, you may not have enough memory on the system to hold your application's working set. </p>
<p>
The output from VADump shows the nature of each page in the working set of your process: </p>
<pre><code>0x00010000 PRIVATE Base 0x00010000
0x00020000 PRIVATE Base 0x00020000
0x0012d000 PRIVATE Base 0x00030000
0x0012e000 PRIVATE Base 0x00030000
0x0012f000 PRIVATE Base 0x00030000
0x00130000 PRIVATE Base 0x00130000
0x00140000 PRIVATE Base 0x00140000
0x00141000 Process Heap
0x00142000 Process Heap
0x00143000 Process Heap
0x00240000 PAGEFILE_MAPPED Base 0x00240000
0x00250000 DATAFILE_MAPPED Base 0x00250000 unicode.nls
0x00251000 DATAFILE_MAPPED Base 0x00250000 unicode.nls
0x00253000 DATAFILE_MAPPED Base 0x00250000 unicode.nls
0x00260000 DATAFILE_MAPPED Base 0x00260000 locale.nls
0x00263000 DATAFILE_MAPPED Base 0x00260000 locale.nls
0x00270000 DATAFILE_MAPPED Base 0x00270000 sortkey.nls
0x002c0000 DATAFILE_MAPPED Base 0x002c0000 sorttbls.nls
0x002d0000 PRIVATE Base 0x002d0000
0x002e0000 PAGEFILE_MAPPED Base 0x002e0000
0x002f0000 PRIVATE Base 0x002f0000
0x01000000 menappl.exe
        (1000) _except_list
0x01001000 menappl.exe
        ( 165) LogDisplayDlgProc@16
        (  24) GetSystemPerfData@16
        ( 1a0) UpdateSystemData@8
        (  1c) MemorySize@4
        (  29) GetObjectDefByTitleIndex@8
        (  14) LogCollecting@4
        ( 113) DrawAlerts@8
        (  d2) DrawLog@8
        (  4c) SmallFileSizeString@8
 </code></pre>
<p>
The page virtual addresses appear on the left. For each section of address space, the base is shown on the right. PRIVATE pages are dynamic data pages that are private to the process. Process Heap pages are dynamically allocated from the process heap. It can be difficult to determine who is using this space, and you may need to look at pointers within your application using the debugger. </p>
<p>
The system pages are those allocated for the page tables and for the working set packing list itself. This might be larger than your application actually needs, because VADump needs to scan them. So use Performance Monitor as described to determine the difference. For this example, when we looked at the working set of Performance Monitor while charting, running VADump added 5 pages to the working set. </p>
<p>
If COFF symbols are included and the module was linked with the <b>-debug</b> flag, other pages that belong to specific modules are indicated by listing which public symbols occur within the page. This helps you to understand why a particular page has been brought into memory. If the module was compiled without the correct flags, you will see only the module name.</p>
<p>
Any pages listed as belonging to the module "Error" are pages that did not resolve to a particular module. </p>
<p>
You will also find some DATA pages at the upper end of the application's address space. These are for such system-related items as the Process Environment Block, the Thread Environment Blocks, the Per-Thread Data Area, and so on.</p>
<p>
Pages in the range starting at 0xC0000000 are page table pages. They are listed showing the range of pages they map, how many of those are in memory (these are called <i>resident pages</i>), and the range of resident pages and their modules. </p>
<p>
Finally, there is a summary of pages and who owns them. These pages summarize the pages already listed, so avoid counting them again. </p>
<p>&nbsp;</p></body>
</HTML>
