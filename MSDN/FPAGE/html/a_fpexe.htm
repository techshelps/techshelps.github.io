<html>

<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Source Code for fpexe Program</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<BODY bgcolor="#FFFFFF" text="#000000" link="#1B55FB" vlink="#BB1CFF" alink="#FF1C2C">


<h1>Source Code for fpexe Program</h1>

<h2>fpexe.c</h2>

<pre>/* ====================================================================
 *
 * FrontPage SUID Stub Executable
 *
 * Copyright (c) 1995-1997 Microsoft Corporation -- All Rights Reserved.
 *
 * NO WARRANTIES. Microsoft expressly disclaims any warranty for this code and
 * information. This code and information and any related documentation is
 * provided &quot;as is&quot; without warranty of any kind, either express or implied,
 * including, without limitation, the implied warranties or merchantability,
 * fitness for a particular purpose, or noninfringement. The entire risk
 * arising out of use or performance of this code and information remains with
 * you.
 *
 * NO LIABILITY FOR DAMAGES. In no event shall Microsoft or its suppliers be
 * liable for any damages whatsoever (including, without limitation, damages
 * for loss of business profits, business interruption, loss of business
 * information, or any other pecuniary loss) arising out of the use of or
 * inability to use this Microsoft product, even if Microsoft has been advised
 * of the possibility of such damages. Because some states/jurisdictions do not
 * allow the exclusion or limitation of liability for consequential or
 * incidental damages, the above limitation may not apply to you.
 *
 * Version 1.2
 */


/*
 * User configurable items.  We will not run the server extensions with any
 * UID/GID less than LOWEST_VALID_UID/LOWEST_VALID_GID.
 */

#if defined(LINUX)
#define LOWEST_VALID_UID 15
#else
#define LOWEST_VALID_UID 11
#endif

#if defined(HPUX) || defined(IRIX) || defined(SUNOS4)
#define LOWEST_VALID_GID 20
#else
#if defined(SCO)
#define LOWEST_VALID_GID 24
#else
#define LOWEST_VALID_GID 21   /* Solaris, AIX, Alpha, Bsdi, etc. */
#endif
#endif

#define CLEAN_PATH &quot;PATH=/usr/bin:/bin&quot;

static struct SaveEnvVars
{
    const char* szVar;
    int         iLen;
} gSafeEnvVars[] =
{
    { &quot;AUTH_TYPE=&quot;, 0 },
    { &quot;CONTENT_LENGTH=&quot;, 0 },
    { &quot;CONTENT_TYPE=&quot;, 0 },
    { &quot;DATE_GMT=&quot;, 0 },
    { &quot;DATE_LOCAL=&quot;, 0 },
    { &quot;DOCUMENT_NAME=&quot;, 0 },
    { &quot;DOCUMENT_PATH_INFO=&quot;, 0 },
    { &quot;DOCUMENT_ROOT=&quot;, 0 },
    { &quot;DOCUMENT_URI=&quot;, 0 },
    { &quot;FILEPATH_INFO=&quot;, 0 },
    { &quot;GATEWAY_INTERFACE=&quot;, 0 },
    { &quot;HTTP_&quot;, 0 },
    { &quot;LAST_MODIFIED=&quot;, 0 },
    { &quot;PATH_INFO=&quot;, 0 },
    { &quot;PATH_TRANSLATED=&quot;, 0 },
    { &quot;QUERY_STRING=&quot;, 0 },
    { &quot;QUERY_STRING_UNESCAPED=&quot;, 0 },
    { &quot;REDIRECT_QUERY_STRING=&quot;, 0 },
    { &quot;REDIRECT_STATUS=&quot;, 0 },
    { &quot;REDIRECT_URL=&quot;, 0 },
    { &quot;REMOTE_ADDR=&quot;, 0 },
    { &quot;REMOTE_HOST=&quot;, 0 },
    { &quot;REMOTE_IDENT=&quot;, 0 },
    { &quot;REMOTE_PORT=&quot;, 0 },
    { &quot;REMOTE_USER=&quot;, 0 },
    { &quot;REQUEST_METHOD=&quot;, 0 },
    { &quot;SCRIPT_FILENAME=&quot;, 0 },
    { &quot;SCRIPT_NAME=&quot;, 0 },
    { &quot;SCRIPT_URI=&quot;, 0 },
    { &quot;SCRIPT_URL=&quot;, 0 },
    { &quot;SERVER_ADMIN=&quot;, 0 },
    { &quot;SERVER_NAME=&quot;, 0 },
    { &quot;SERVER_PORT=&quot;, 0 },
    { &quot;SERVER_PROTOCOL=&quot;, 0 },
    { &quot;SERVER_SOFTWARE=&quot;, 0 },
    { &quot;TZ=&quot;, 0 },
    { &quot;USER_NAME=&quot;, 0 },
    { 0, 0 }
};

/*
 * End of user configurable items
 */


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#if !defined(bsdi) &amp;&amp; !defined(hpux) &amp;&amp; !defined(sun) &amp;&amp; !defined(linux) &amp;&amp; !defined(SCO5)
#include &lt;sys/mode.h&gt;
#endif

extern char **environ;
extern int errno;


#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif
#if (MAXPATHLEN &lt; 1024)
#undef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

#define KEYLEN 128                  /* Should be a multiple of sizeof(int) */


#define FPKEYDIR &quot;/usr/local/frontpage/currentversion/apache-fp&quot;
#define KEYFILE  &quot;/usr/local/frontpage/currentversion/apache-fp/suidkey.%d&quot;
#define FPDIR    &quot;/usr/local/frontpage/currentversion/exes&quot;

/* Legal modules */
#define SHTML    &quot;/_vti_bin/shtml.exe&quot;
#define FPCOUNT  &quot;/_vti_bin/fpcount.exe&quot;
#define AUTHOR   &quot;/_vti_bin/_vti_aut/author.exe&quot; 
#define ADMIN    &quot;/_vti_bin/_vti_adm/admin.exe&quot; 


/*
 * Something is not quite right - give up
 */
void die(const char *msg)
{
    char timebuf[26];
    time_t t = time(0);
    strcpy(timebuf, ctime(&amp;t));
    timebuf[24] = '\0';
    fprintf(stderr, &quot;[%s] %s\n&quot;, timebuf, msg);
    printf(&quot;Content-Type: text/html\n\n&lt;HTML&gt;*-*-* :-| :^| :-/ :-( 8-( *-*-*\n&lt;ul&gt;\n&lt;li&gt;status=1\n&lt;li&gt;osstatus=0\n&lt;li&gt;msg=FrontPage security violation.\n&lt;li&gt;osmsg=\n&lt;/ul&gt;\n&quot;, msg);
    exit(0);
}

/*
 * Remove any variable that is not known to be a standard CGI or OS
 * environment variable.  Also, sanitizes the PATH.
 */
static void CleanEnvironment() 
{
    char** pp;
    char** ppi;
    struct SaveEnvVars* pOkEnv;

    for (ppi = pp = environ;  *pp;  pp++)
    {
        /*
         * Inefficient linear lookup; could be improved with binary search.
         */
        for (pOkEnv = gSafeEnvVars;  pOkEnv-&gt;szVar;  pOkEnv++)
        {
            int iLen = pOkEnv-&gt;iLen;
            if (!iLen)
                pOkEnv-&gt;iLen = iLen = strlen(pOkEnv-&gt;szVar);

            if (strncmp(pOkEnv-&gt;szVar, *pp, iLen) == 0)
                break;
        }

        if (!strncmp(*pp, &quot;PATH=&quot;, 5))
            *ppi++ = CLEAN_PATH;
        else if (pOkEnv-&gt;szVar)
            *ppi++ = *pp;
    }

    *ppi = 0;
}

void main(int argc, char **argv)
{
    struct passwd* pw;
    const char* szFpUserName;
    const char* szFpExe = getenv(&quot;FPEXE&quot;);
    const char* szFpUid = getenv(&quot;FPUID&quot;);
    const char* szFpGid = getenv(&quot;FPGID&quot;);
    const char* szFpFd  = getenv(&quot;FPFD&quot;);
    char* pEnd;
    char* pDir;
    uid_t iFpUid;
    uid_t iFpGid;
    uid_t iBinUid;
    int iFpFd;
    int iKeyFd;
    int iCount;
    char szKeyFile[MAXPATHLEN];
    char szWork[MAXPATHLEN];
    char inpKey[KEYLEN];
    char refKey[KEYLEN];
    struct stat fs;
    
    /*
     * Assure that this program was actually SUID'd to root
     */
    if (geteuid())
        /*
         * User recovery:  Make sure fpexe is setuid to root
         */
        die(&quot;FrontPage SUID Error: not running as root&quot;);

    /*
     * Assure that the user the web server runs as is a valid user
     */
    if (!getpwuid(getuid()))
        /*
         * User recovery:  Make sure that the web server user is in /etc/passwd
         */
        die(&quot;FrontPage SUID Error: invalid uid&quot;);

    /*
     * Assure that we have the proper arguments (passed in the environment)
     */
    if (!szFpExe || !szFpUid || !szFpGid || !szFpFd)
        /*
         * User recovery:  Make sure fpexe is run from patched Apache server
         */
        die(&quot;Frontpage SUID Error: invalid environment arguments&quot;);

    /*
     * Validate the arguments
     */
    if (strcmp(szFpExe, SHTML) != 0   &amp;&amp;
        strcmp(szFpExe, FPCOUNT) != 0 &amp;&amp;
        strcmp(szFpExe, AUTHOR) != 0  &amp;&amp;
        strcmp(szFpExe, ADMIN) != 0)
        /*
         * User recovery:  Make sure fpexe is only invoked to run FrontPage
         * server extension programs.
         */
        die(&quot;FrontPage SUID Error: target program violation&quot;);

    if (strlen(szFpExe) + strlen(FPDIR) + 1 &gt; MAXPATHLEN)
        die(&quot;FrontPage SUID Error: path too long&quot;);
    strcpy(szWork, FPDIR);
    strcat(szWork, szFpExe);

    iFpUid = strtol(szFpUid, &amp;pEnd, 10);
    if (!pEnd || *pEnd)
        iFpUid = 0;
    if (iFpUid &lt; LOWEST_VALID_UID || !(pw = getpwuid(iFpUid)))
        /*
         * User recovery:  Make sure FrontPage user ids are above minimum
         */
        die(&quot;FrontPage SUID Error: invalid target uid&quot;);
    szFpUserName = strdup(pw-&gt;pw_name);

    iFpGid = strtol(szFpGid, &amp;pEnd, 10);
    if (!pEnd || *pEnd)
        iFpGid = 0;
    if (iFpGid &lt; LOWEST_VALID_GID || !getgrgid(iFpGid))
        /*
         * User recovery:  Make sure FrontPage group ids are above minimum
         */
        die(&quot;FrontPage SUID Error: invalid target gid&quot;);

    iFpFd = strtol(szFpFd, &amp;pEnd, 10);
    if (!pEnd || *pEnd)
        iFpFd = -1;
    if (iFpFd &lt; 0)
        /*
         * User recovery:  Make sure fpexe is run from patched Apache server
         */
        die(&quot;FrontPage SUID Error: invalid key file descriptor&quot;);

    /*
     * Read the key from our server.  And, while we're still root and have
     * access, read the key from the master key file.  Verify the key matches.
     */
    if (lstat(FPKEYDIR, &amp;fs) == -1 ||
        (fs.st_mode &amp; (S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) || fs.st_uid ||
        !(S_ISDIR(fs.st_mode)))
        /*
         * User recovery is: set directory to be owned by by root with
         * permissions rwx--x--x.
         */
        die(&quot;FrontPage SUID Error: key file directory is insecure&quot;);

    sprintf(szKeyFile, KEYFILE, (int)getpgrp());
    if (stat(szKeyFile, &amp;fs) == -1 ||
        (fs.st_mode &amp; (S_IRWXG | S_IRWXO)) || fs.st_uid)
        /*
         * User recovery is:  Make sure the key file is properly protected
         * (owned by root, permissions r**------), restart patched Apache
         * server.
         */
        die(&quot;FrontPage SUID Error: key file security violation&quot;);
    
    iKeyFd = open(szKeyFile, O_RDONLY);
    if (iKeyFd &lt; 0)
        /*
         * User recovery is:  Make sure fpexe is run from patched Apache
         * server, restart the patched Apache server.
         */
        die(&quot;FrontPage SUID Error: could not open key file&quot; );
    iCount = read(iKeyFd, refKey, sizeof(refKey));
    close(iKeyFd);
    if (iCount != sizeof(refKey))
        /*
         * User recovery is:  Make sure fpexe is run from patched Apache
         * server, restart the patched Apache server.
         */
        die(&quot;FrontPage SUID Error: could not read valid key from key file&quot;);

    iCount = read(iFpFd, inpKey, sizeof(inpKey));
    close(iFpFd);
    if (iCount != sizeof(inpKey))
        /*
         * User recovery is:  Make sure fpexe is run from patched Apache server
         */
        die(&quot;FrontPage SUID Error: could not read valid input key&quot;);

    if (memcmp(inpKey, refKey, sizeof(refKey)) != 0)
        /*
         * User recovery is:  Make sure fpexe is run from patched Apache server
         */
        die(&quot;FrontPage SUID Error: key security violation&quot;);

    /*
     * Change user and group IDs to be the indicated user
     */
    if (setgid(iFpGid) == -1 || initgroups(szFpUserName, iFpGid) == -1)
        /*
         * User recovery:  Make sure user is properly registered in 
         * /etc/passwd and /etc/group.
         */
        die(&quot;FrontPage SUID Error: setgid() failed&quot;);
    
    if (setuid(iFpUid) == -1)
        /*
         * User recovery:  Make sure user is properly registered in
         * /etc/passwd.
         */
        die(&quot;FrontPage SUID Error: setuid() failed&quot;);

    /*
     * Validate the target directory.
     */
    iBinUid = 0;
    if (pw = getpwnam(&quot;bin&quot;))
        iBinUid = pw-&gt;pw_uid;

    pDir = strrchr(szWork, '/');
    *pDir = 0;
    if (lstat(szWork, &amp;fs) == -1 || (fs.st_mode &amp; (S_IWGRP | S_IWOTH)) ||
                                    (fs.st_uid != iBinUid &amp;&amp; fs.st_uid != 0) ||
                                    !(S_ISDIR(fs.st_mode)))
        /*
         * User recovery is: make sure FrontPage exe programs are available,
         * set directory to be owned by bin or root and have permissions
         * rwx*-x*-x.
         */
        die(&quot;FrontPage SUID Error: target directory not found or insecure&quot;);

    *pDir = '/';

    /*
     * Validate the target program
     */
    if (stat(szWork, &amp;fs) == -1 || ((fs.st_mode &amp; (S_IWGRP | S_IWOTH)) ||
                                    (fs.st_mode &amp; (S_ISUID | S_ISGID)) ||
                                    (fs.st_uid != iBinUid &amp;&amp; fs.st_uid != 0)))
        /*
         * User recovery is: make sure FrontPage exe programs are available,
         * set programs to be owned by bin or root and have permissions
         * rwx*-x*-x.
         */
        die(&quot;FrontPage SUID Error: target program not found or insecure&quot;);

    *pDir = '/';

    /*
     * Make sure the environment contains no unsafe values.
     */
    CleanEnvironment();

    /*
     * Run the specified program.
     */
    argv[0] = szWork;
    umask(022);
    execv(argv[0], argv);

    /*
     * We should never get here.  Exit with error.
     */
    exit(1);
}</pre>
</body>
</html>
