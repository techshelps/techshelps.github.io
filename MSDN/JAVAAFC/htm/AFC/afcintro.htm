<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Introduction to AFC</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Application Foundation Classes"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="afcintro.htm#afcintro_0006000201010000">Technical Overview</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="afcintro.htm#afcintro_0006000201020000">AFCSkeleton&#151;A Basic AFC Application</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="afcintro.htm#afcintro_0006000201030000">Adding AFC Controls</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="355" VALIGN="bottom"><IMG SRC="art/afc2.gif" WIDTH="355" HEIGHT="27"  BORDER=0 ALT="AFC"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A HREF="def_afc.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="def_afc.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="AFC"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="AFCSkeleton.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD></TR>
<TR>
<TD WIDTH="355" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Microsoft Application Foundation Classes (AFC)</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">AFC</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Introduction to AFC</H2>
<P>Microsoft&#174; Application Foundation Classes (AFC) is a set of Java class libraries that provide user interface components and graphics effects for use in Java-based applets and applications. AFC is licensed to be redistributed with the Microsoft Win32 VM for Java. AFC can also be redistributed with AFC102.ZIP for browsers that only support JDK 1.0.2. The AFC libraries consist of the following packages:

<UL><LI>The <A HREF="def_pfx.htm">com.ms.fx</A> package (FX package) provides support for basic graphic elements such as colors, glyphs, fonts, curves, text, and textures.
<LI>The <A HREF="def_ui.htm">com.ms.ui</A> package (UI package) provides an application framework and includes many of the high-level user interface controls used by applications&#151;controls such as menus, dialog boxes, list boxes, scroll bars, push buttons, check boxes, edit boxes, and tree controls. 
<LI>The <A HREF="def_uevt.htm">com.ms.ui.event</A> package provides support for the Java 1.1 event model.
<LI>The <A HREF="def_ures.htm">com.ms.ui.resource</A> package provides support for using Win32 resource files with Java applications.
<LI>The <A HREF="def_ucab.htm">com.ms.util.cab</A> package provides access to cabinet file creation and extraction services.
</UL>
<P>This article provides an introduction to programming with the AFC UI package. It begins with an overview of the architecture of AFC and a description of the relationship between AFC and the Abstract Window Toolkit (AWT). It then presents a sample program that you can use as a starting point for writing programs that use the AFC class library. The article concludes with a description of how to use some basic AFC user interface controls.

<H3 STYLE="color:#333366"><A NAME="afcintro_0006000201010000">Technical Overview</A></H3><P>The largest and most important part of AFC is the user interface (UI) package, com.ms.ui. (Often, when people speak of AFC, they are actually referring to the UI package.) This package provides a basic application framework as well as user interface controls. The following diagram shows the class hierarchy of the basic UI package components. 

<P><IMG SRC="art/mark1.gif" WIDTH="454" HEIGHT="281" ALT="" ><P>The class hierarchy in the previous diagram is not complete&#151;it doesn't show interface classes that are implemented by many of the AFC classes, and it doesn't show all of the AFC classes (such as layout managers and AWT compatibility classes). The diagram should, however, give you an idea of the basic layout of AFC's class structure. 

<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201010100">AFC Component Model</A></H4><P>Like AWT, the fundamental elements of AFC are components, containers, and layout managers. Components are the most fundamental of these elements and are usually associated with visual elements&#151;all AFC UI controls are components. Containers are simply components that can contain other components. Layout managers are neither components nor containers; they are objects delegated by containers to calculate the position and size of the various components within the container. 

<P>AFC is similar in overall design to AWT&#151;if you're familiar with AWT, you can apply much of what you've learned to working with AFC. AFC does not, however, directly extend the AWT component architecture. Although AFC is based on an architecture that maintains many of the concepts (and method signatures) used by AWT, AFC is designed to support applications that are smaller, run faster, and are more compatible across different Java implementations. The AFC component model is based on the following design features:

<UL><LI>Lightweight base classes
<LI>Windowless components
<LI>Peerless implementation
</UL>
<P>Lightweight base classes enable UI components to use less data storage&#151;there is no memory wasted on unnecessary fields that are propagated to all of the classes derived from the base classes. This component model allows AFC to support high-capacity containers with a minimum of overhead. For example, consider a table with hundreds of entries that are bound to a database. With AFC, you can create a table entry component that requires only a few bytes of storage. On the other hand, if you create a table entry component by extending the AWT <B>Component</B> class, you'll inherit at least 104 bytes of storage that you probably don't need.

<P>Windowless components yield dramatic increases in performance as well as smaller components. Unlike AWT components, AFC components are not windows and do not have to carry the extra baggage required of components that are windows. Performance is enhanced because AFC does its own window management (such as clipping, moving, and resizing windows) and doesn't have to access native code through peers or other mechanisms.

<P>AFC is implemented without using peer classes&#151;there is no native code required to run AFC on a VM for Java. Because AFC doesn't have to deal with the subtle differences in AWT implementations on different VMs, it can provide a higher degree of cross-platform consistency than AWT.

<P><B>Note</B>  Because AFC components do not extend directly from the AWT <B>Component</B> class, you cannot freely mix AFC and AWT components in a single application. You can, however, use the AFC AWT compatibility classes to include AFC components in an AWT application. You can also use the <A HREF="UIAwtHost.htm">UIAwtHost</A> class to include AWT components in an AFC application.<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201010200">AFC Event Model</A></H4><P>AFC supports both the JDK 1.02 and the JDK 1.1 event model. AFC applications can use either event model, regardless of the event model supported by the VM used to run the application. There are some differences in the way that AFC and AWT implement event handling&#151;the following list summarizes these differences:

<UL><LI>AFC propagates 1.1-style events up the containment hierarchy regardless of whether there is a listener attached to the event target. AWT does not propagate events when there is a listener attached.
<LI>1.1-style window messages (<B>windowOpened</B>, <B>windowClosed</B>, and so on) are only generated when AFC applications are running on a 1.1 VM&#151;window messages are not generated when applications are running on a 1.02 VM.
<LI>AFC does not support 1.1-style component events (<B>componentHidden</B>, <B>componentMoved</B>, <B>componentResized</B>, <B>componentShown</B>).
<LI>AFC does not support the JDK 1.1 technique of dispatching events with the <B>dispatchEvent</B> method. In AFC, events must be posted using the JDK 1.02 <A HREF="UIComponent.htm#com_0003001142015d00">postEvent</A> method.
</UL>
<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201010300">Using the 1.02 Event Model</A></H4><P>To handle 1.02-style events, you must override the appropriate <A HREF="UIComponent.htm">UIComponent</A> method for the target object or its container. You can override the general-purpose <A HREF="UIComponent.htm#com_0003001142013600">handleEvent</A> method to handle any event or you can override the event-specific methods in the following list to handle specific events.
 
<UL><LI><A HREF="UIComponent.htm#com_0003001142010100">action</A>
<LI><A HREF="UIComponent.htm#com_0003001142013500">gotFocus</A>
<LI><A HREF="UIComponent.htm#com_0003001142014e00">keyDown</A>
<LI><A HREF="UIComponent.htm#com_0003001142014f00">keyUp</A>
<LI><A HREF="UIComponent.htm#com_0003001142015100">lostFocus</A>
<LI><A HREF="UIComponent.htm#com_0003001142015200">mouseClicked</A>
<LI><A HREF="UIComponent.htm#com_0003001142015300">mouseDown</A>
<LI><A HREF="UIComponent.htm#com_0003001142015400">mouseDrag</A>
<LI><A HREF="UIComponent.htm#com_0003001142015500">mouseEnter</A>
<LI><A HREF="UIComponent.htm#com_0003001142015600">mouseExit</A>
<LI><A HREF="UIComponent.htm#com_0003001142015700">mouseMove</A>
<LI><A HREF="UIComponent.htm#com_0003001142015800">mouseUp</A>
</UL>
<P>The 1.02-style event methods use the AWT <B>Event</B> class to represent events.

<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201010400">Using the 1.1 Event Model</A></H4><P>To handle 1.1-style events, you must implement the appropriate event listener interface in the target object or one of its containers. The following is a list of AFC event listener interfaces.

<UL><LI><A HREF="IUIActionListener.htm">IUIActionListener</A>
<LI><A HREF="IUIAdjustmentListener.htm">IUIAdjustmentListener</A>
<LI><A HREF="IUIContainerListener.htm">IUIContainerListener</A>
<LI><A HREF="IUIFocusListener.htm">IUIFocusListener</A>
<LI><A HREF="IUIItemListener.htm">IUIItemListener</A>
<LI><A HREF="IUIKeyListener.htm">IUIKeyListener</A>
<LI><A HREF="IUIMouseListener.htm">IUIMouseListener</A>
<LI><A HREF="IUIMouseMotionListener.htm">IUIMouseMotionListener</A>
<LI><A HREF="IUITextListener.htm">IUITextListener</A>
</UL>
<P>The 1.1-style event listeners use the AFC <A HREF="UIEvent.htm">UIEvent</A> class to represent events.

<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201010500">Using AFC Components in AWT Applications</A></H4><P>AFC includes a set of classes that enable AFC components to be used as JavaBeans in AWT applications. These classes consist of a bridge layer wrapped around an AFC component. The following illustration shows the relationship between an AFC component, the bridge layer, and an AWT container.

<P><IMG SRC="art/mark13.gif" WIDTH="178" HEIGHT="133" ALT="" ><P>There are corresponding AWT compatibility classes for all AFC UI control classes and several general-purpose classes such as <A HREF="UICanvas.htm">UICanvas</A> and <A HREF="UIPanel.htm">UIPanel</A>. The AWT compatibility classes have the same name as the corresponding AFC classes with the addition of an AwtUI prefix. For example, <A HREF="AwtUIPushButton.htm">AwtUIPushButton</A> is the AWT compatibility class for <A HREF="UIPushButton.htm">UIPushButton</A>. The <A HREF="AwtUIApplet.htm">AwtUIApplet</A> class is a bit different than the other AWT compatibility classes&#151;it's used to provide a top-level host container for AFC applets.

<P><B>Note</B>  You should only use one layer of AWT compatibility classes to provide a bridge between AWT containers and AFC components. The components contained by an AWT compatibility object must be AFC UI components (extended from <A HREF="IUIComponent.htm">IUIComponent</A>).<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201010600">Using AWT Components in AFC Applications</A></H4><P>In addition to the AWT compatibility classes, AFC provides an AWT host control, <A HREF="UIAwtHost.htm">UIAwtHost</A>, that allows you to include AWT components in an AFC application. The following example shows how to use the host control to include an AWT <B>Button</B> component in a <A HREF="UIPanel.htm">UIPanel</A> object.

<PRE><FONT FACE="Courier" SIZE="2">// Create an AFC panel and an AWT button
UIPanel p = new UIPanel ();
Button b = new Button ("AWT Button");

// Add button to panel using UIAwtHost bridge
p.add (new UIAwtHost (b));
</FONT></PRE>
<P><B>Note</B>  The <B>UIAwtHost</B> bridge cannot be used inside an AFC choice control. If used inside a menu list, the menu list cannot be launched as a pop-up menu.
<P>Events that propagate to the host are retargeted before being propagated up the containment hierarchy&#151;the host becomes the event target for these events. The host control supports event propagation for only one level of containment. Events associated with any component contained by the component being hosted are consumed by the host control and do not propagate further. You can get access to these events by overriding the <B>handleEvent</B> method of the host control.

<P>For example, in the previous sample, the <B>UIPanel</B> object will receive events associated with the AWT <B>Button</B> object. The target (specified in the <B>Event.target</B> field) will be the <B>UIAwtHost</B> object, however, not the <B>Button</B> object. If the <B>Button</B> object is contained by an AWT panel, events associated with the button will be consumed by the host control and will never propagate to the outer <A HREF="UIPanel.htm">UIPanel</A> object.

<H3 STYLE="color:#333366"><A NAME="afcintro_0006000201020000">AFCSkeleton&#151;A Basic AFC Application</A></H3><P>AFC-based applications are similar in construction to AWT-based applications. However, because of the way that AFC ties in with AWT, there are some important differences in how you construct applets for the two class libraries. Let's take a look at a basic AFC application. The following is the complete Java source for AFCSkeleton, an AFC application skeleton designed to function as an applet as well as a stand-alone application.

<P><IMG SRC="art/dwnld1.gif" WIDTH="16" HEIGHT="16" ALT="download" > <A HREF="http://www.microsoft.com/java/sdk/20/afc/afcskel.zip">Download</A> AFCSkeleton sample.



<PRE><FONT FACE="Courier" SIZE="2">
// AFCSkeleton.java

import java.awt.*;
import com.ms.ui.*;
import com.ms.fx.*;

// AWT applet bridge
public class AFCSkeleton extends AwtUIApplet {
  // Create instance of applet implementation
  public AFCSkeleton ()
  {
    super (new AFCSkeletonImplementation ());
  }
  
  // Stand-alone application entry point
  public static void main(String args[]) {
    // Create a frame to contain applet
    AFCSkeletonFrame f = new AFCSkeletonFrame ("AFC Skeleton");
    f.setVisible (true);
    f.setSize (320, 200);

    // Create applet implementation, add to frame, init
    AFCSkeletonImplementation applet
      = new AFCSkeletonImplementation ();
    f.add (applet);
    applet.init ();
  }

  // Add pass-through methods for scriptable applet methods here
  public String getInfo () {
    return(((AFCSkeletonImplementation)getUIApplet()).getInfo());
  }
}

// Applet implementation
class AFCSkeletonImplementation extends UIApplet {
  // Applet entry point
  public void init() {
    setBackground (FxColor.cyan);

    // Add additional components here
  }

  public String getInfo () {
    String s = "Info about AFCSkeleton.class\r\n";
    s += "Version: 1.0\r\n";
    return s;
  }
}

// Frame to host applet when run as stand-alone application
class AFCSkeletonFrame extends UIFrame {
  public AFCSkeletonFrame(String str) {super (str);}

  public boolean handleEvent (Event e) {
    switch (e.id) {
    case Event.WINDOW_DESTROY:
      // Frame window closed, exit app
      System.exit (0);
      return true;
    default:
      return super.handleEvent (e);
    }
  }
}</FONT></PRE>
<P>The purpose of AFCSkeleton is to illustrate the basic structure of AFC applets and applications. When you run AFCSkeleton as a stand-alone application, you'll see a framed window with a cyan background. The client area of the window will be set to 320 by 200 pixels. When you run it as an applet in a browser, you'll see a cyan rectangle set to the size specified by the APPLET tag. 

<P><B>Note</B>  There are many ways to create Java programs that can be run either as a stand-alone application or an applet. The AFCSkeleton example shown in this article is simplified to illustrate the basic minimum requirements of AFC applications.
<P>AFCSkeleton consists of three classes:
 
<UL><LI> Class <A HREF="AFCSkeleton.htm">AFCSkeleton</A> is a public class that extends <A HREF="AwtUIApplet.htm">AwtUIApplet</A>. This class provides a bridge to AWT when the program is run as an applet, as well as the <B>main</B> entry point when it is run as a stand-alone application.
<LI> Class <B>AFCSkeletonImplementation</B> is a private class that extends <A HREF="UIApplet.htm">UIApplet</A>. This class contains the actual implementation of the program.
<LI> Class <B>AFCSkeletonFrame</B> is a class that extends <A HREF="UIFrame.htm">UIFrame</A>. This class is used to provide a frame window for the program to use when it is run as a stand-alone application.
</UL>
<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201020100">The Structure of AFC Applets</A></H4><P> Applets written for AFC require at least two classes: an <A HREF="AwtUIApplet.htm">AwtUIApplet</A> bridge class to interface with the applet's host and a <A HREF="UIApplet.htm">UIApplet</A> class to provide the actual implementation of the applet. This may seem like a bit of extra work, but the bridge class is typically only a few lines of rote code. The following example shows the code implementing a basic AFC applet.

<PRE><FONT FACE="Courier" SIZE="2">import com.ms.ui.*;

// Bridge class
public class MyApplet extends AwtUIApplet 
{
  // Constructor
  public MyApplet () { super (new MyAppletImplementation ()); }
}

// Implementation class
class MyAppletImplementation extends UIApplet 
{
  // Applet entry point
  public void init()
  {
    // Add your components here
  }
}</FONT></PRE>
<P>The bridge class contains a single method: a constructor that creates an instance of the applet's <A HREF="UIApplet.htm">UIApplet</A> implementation class and passes it to the constructor for <A HREF="AwtUIApplet.htm">AwtUIApplet</A>.

<P><B>Note</B>   If any of the applet's methods are to be scriptable, they must be exposed to the host through the <A HREF="AwtUIApplet.htm">AwtUIApplet</A> bridge class.
<P>The applet implementation class is based on the <A HREF="UIApplet.htm">UIApplet</A> class. It can be constructed similarly to the <B>Applet</B>-based class for AWT applets. The basic applet <B>init</B>, <B>start</B>, <B>stop</B>, and <B>destroy</B> methods should be implemented in this class and not in the <A HREF="AwtUIApplet.htm">AwtUIApplet</A> bridge class. 

<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201020200">Running AFCSkeleton as an Applet</A></H4><P>The following HTML code will run AFCSkeleton as an applet and set its initial size to 320 by 240 pixels: 

<PRE><FONT FACE="Courier" SIZE="2">&lt;applet 
  code=AFCSkeleton.class
  id=AFCSkeleton
  width=320
  height=240 &gt;
&lt;/applet&gt;
</FONT></PRE>
<P>When AFCSkeleton is run as an applet, the entry point is the <B>AFCSkeletonImplementation.init</B> method:

<PRE><FONT FACE="Courier" SIZE="2">// Applet entry point
public void init()
{
  setBackground (FxColor.cyan);

  // Add additional components here
}
</FONT></PRE>
<P>All that happens in <B>init</B> is a call to the <B>setBackground</B> method to set the background of the <A HREF="UIApplet.htm">UIApplet</A> object to cyan. This is where you add the components that transform AFCSkeleton from an shell to a real program. The <B>init</B> method is also called when AFCSkeleton is run as a stand-alone application, so you can place all of your initialization code in a single routine.

<P>AFCSkeleton has one public method, <B>getInfo</B>, that can be called from a browser using a scripting language such as JavaScript or Microsoft&#174; Visual Basic&#174; Scripting Edition. Scriptable public methods must be exposed in the <A HREF="AwtUIApplet.htm">AwtUIApplet</A> bridge class. Calls to these methods should be passed to the implementation class as shown in the following code fragment that implements the <B>getInfo</B> method in the <B>AwtUIApplet</B> bridge class for AFCSkeleton:

<PRE><FONT FACE="Courier" SIZE="2">public String getInfo ()
{
  return (((AFCSkeletonImplementation)getUIApplet()).getInfo());
}</FONT></PRE>
<P>The key here is to use the <A HREF="AwtUIApplet.htm#com_0003001102020200">getUIApplet</A> method to get a reference to the <A HREF="UIApplet.htm">UIApplet</A> object containing the implementation of the applet's scriptable methods. 

<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201020300">Running AFCSkeleton as a Stand-alone Application</A></H4><P>When AFCSkeleton is run as a stand-alone application, the entry point is the <B>main</B> method in the <A HREF="AFCSkeleton.htm">AFCSkeleton</A> class:

<PRE><FONT FACE="Courier" SIZE="2">// Stand-alone application entry point
public static void main(String args[])
{
  // Create a frame to contain applet
  AFCSkeletonFrame f = new AFCSkeletonFrame ("AFC Skeleton");
  f.setVisible (true);
  f.setSize (320, 200);

  // Create applet implementation, add to frame, init
  AFCSkeletonImplementation applet
    = new AFCSkeletonImplementation ();
  f.add (applet);
  applet.init ();
}</FONT></PRE>
<P>The <B>main</B> method is executed only when the program is run as a stand-alone application. Its purpose is to create a frame (<A HREF="UIFrame.htm">UIFrame</A>) that contains an instance of the program as an applet. At first glance, this seems a bit convoluted, but it's actually quite elegant&#151;the frame exists only to provide a container for the applet. When an applet is run in a browser, the browser provides the container. 

<P>After creating an <B>AFCSkeletonImplementation</B> object and adding it to the frame object, <B>main</B> calls the <B>init</B> method to initialize the applet. Using this structure allows you to put all of your initialization code in a single initialization method instead of in two separate locations (one for when the program is run as an applet and one for when it's run as a stand-alone application).

<P>There's one more small piece of the puzzle here, the <A HREF="AwtUIHost.htm#com_0003001115021800">handleEvent</A> method in <B>AFCSkeletonFrame</B>:

<PRE><FONT FACE="Courier" SIZE="2">public boolean handleEvent (Event e)
{
  switch (e.id)
  {
  case Event.WINDOW_DESTROY:
    // Frame window closed, exit app
    System.exit (0);
    return true;
  default:
    return super.handleEvent (e);
  }
}
</FONT></PRE>
<P>The <B>handleEvent</B> method is an AFC <A HREF="UIComponent.htm">UIComponent</A> method that is overridden to intercept and process events. In the case of <B>AFCSkeletonFrame</B>, you need to trap the WINDOW_DESTROY message that is sent when the user attempts to close the window containing the stand-alone application. When <B>handleEvent</B> receives the WINDOW_DESTROY message, it exits the application. All other messages are passed on to the frame's superclass.

<H3 STYLE="color:#333366"><A NAME="afcintro_0006000201030000">Adding AFC Controls</A></H3><P>The next step is to add some AFC controls to the skeleton application. AFCExample1 is an application based on AFCSkeleton, with the addition of two buttons and a status bar.

<P><IMG SRC="art/dwnld1.gif" WIDTH="16" HEIGHT="16" ALT="download" > <A HREF="http://www.microsoft.com/java/sdk/20/afc/afcex1.zip">Download</A> AFCExample1 sample.


<P>The following is a screen shot of AFCExample1 when it runs as a stand-alone application:

<P><IMG SRC="art/art1-2.gif" WIDTH="320" HEIGHT="200" ALT="" ><P>Clicking one of the buttons changes the background color of the application to either red or blue. The text in the status bar changes to indicate the change in background color, as well as whenever the mouse cursor passes over a button.

<P>The controls in AFCExample1 are contained by a <A HREF="UIPanel.htm">UIPanel</A> object that is added to the application by the <B>init</B> method. The following is the source for the <B>init</B> method:

<PRE><FONT FACE="Courier" SIZE="2">// Applet entry point
public void init()
{
  setBackground (FxColor.lightGray);

  setLayout (new UIBorderLayout ());
  add (new AFCExample1Panel ());
  setValid (true);
}</FONT></PRE>
<P>In addition to adding a <A HREF="UIPanel.htm">UIPanel</A> object, <B>init</B> sets the background color and a layout manager for the application. The last thing <B>init</B> does is call the <B>setValid</B> method to force the layout manager to lay out all of the components contained by the application. 

<P><B>Note</B>  Neglecting to call <B>setValid</B> to force a component layout operation is a common mistake&#151;if you don't call <B>setValid</B>, your controls often either fail to appear or are arranged improperly when you run your application.
<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201030100">Using Panels to Contain Controls</A></H4><P>Panels are very useful for organizing and arranging controls. AFCExample1 includes a class, <B>AFCExample1Panel</B>, that extends <A HREF="UIPanel.htm">UIPanel</A> to provide a container for all of the controls used in the application. The following code fragment shows the class variables and constructor for the <B>AFCExample1Panel</B> class:

<PRE><FONT FACE="Courier" SIZE="2">private UIPanel p;
private UIPushButton b1, b2;
private UIStatus s;

// Constructor
public AFCExample1Panel ()
{
  setLayout (new UIBorderLayout ());

  // Create panel to contain buttons
  p = new UIPanel ();

  // Create buttons and add to ButtonPanel
  p.add (b1 = new UIPushButton ("Red", UIPushButton.RAISED));
  p.add (b2 = new UIPushButton ("Blue", UIPushButton.RAISED));
  b1.setBackground (FxColor.lightGray);
  b2.setBackground (FxColor.lightGray);

  // Create status bar control
  s = new UIStatus ("This is a UIStatus control.");
  s.setBackground (FxColor.lightGray);

  // Add button panel and status bar to AFCExample1Panel
  add (p, "Center");
  add (s, "South");
}</FONT></PRE>
<P>The first thing the constructor does is create a <A HREF="UIBorderLayout.htm">UIBorderLayout</A> layout manager and call <A HREF="AwtUIControl.htm#com_000300110d021f00">setLayout</A> to set it as the layout manager for the panel. The <B>AFCExample1Panel</B> container has two components managed by the <B>UIBorderLayout</B> layout manager:

<UL><LI>A <A HREF="UIStatus.htm">UIStatus</A> object that is positioned at the bottom of the <B>AFCExample1Panel</B> container.
<LI>A <A HREF="UIPanel.htm">UIPanel</A> object that contains two buttons and is positioned at the center of the <B>AFCExample1Panel</B> container.
</UL>
<P><A HREF="UIBorderLayout.htm">UIBorderLayout</A> is an AFC layout manager that is similar to AWT's <B>BorderLayout</B> layout manager&#151;it positions components along the four edges and at the center of a container. When you add components to a container that uses the <B>UIBorderLayout</B> layout manager, you specify their positions with keywords similar to compass directions: "North" for the top edge of the container, "South" for the bottom edge, "East" for the right edge, "West" for the left edge, and "Center" for the center. The center component receives the space that remains after the edge components have been positioned.

<H4 STYLE="color:#333366"><A NAME="afcintro_0006000201030200">Handling Control Events</A></H4><P>In addition to having a constructor, the <B>AFCExample1Panel</B> class overrides two <A HREF="IUIComponent.htm">IUIComponent</A> methods to handle events for the components that it contains. The <A HREF="UIChoice.htm#com_000300113e020100">action</A> method is overridden to handle clicks on the two buttons in the application. The following is the source for the overridden <B>action</B> method:

<PRE><FONT FACE="Courier" SIZE="2">// Action event handler
public boolean action (Event e, Object o)
{
  if (o == b1)
  {
    p.setBackground (FxColor.red);
    p.repaint ();
    s.setName ("Background color changed to red.");
  }
  else if (o == b2)
  {
    p.setBackground (FxColor.blue);
    p.repaint ();
    s.setName ("Background color changed to blue.");
  }
  return true;
}</FONT></PRE>
<P>The <A HREF="UIChoice.htm#com_000300113e020100">action</A> method determines which button has been clicked, and then performs the following actions:

<UL><LI>Calls the UIPanel.<A HREF="IUIComponent.htm#com_000300118d016000">setBackground</A> method to change the background color of the panel containing the buttons.
<LI>Calls the UIPanel.<A HREF="IUIComponent.htm#com_000300118d015b00">repaint</A> method to force a repaint of the panel.
<LI>Calls the UIStatus.<A HREF="IUIComponent.htm#com_000300118d017000">setName</A> method to change the text in the status bar.
</UL>
<P>The second overridden event-handling method is <A HREF="AwtUIHost.htm#com_0003001115021800">handleEvent</A>. It is overridden to detect when the mouse cursor moves into the area occupied by a <B>UIPushbutton</B> object. Here's the source for <B>handleEvent</B>:

<PRE><FONT FACE="Courier" SIZE="2">public boolean handleEvent (Event e)
{
  if ((e.id == Event.MOUSE_ENTER)
   &amp;&amp; (e.target instanceof UIPushButton))
  {
    s.setName ("UIPushbutton object: MOUSE_ENTER event.");
    return true;
  }
  else
  {
    return super.handleEvent (e);
  }
}</FONT></PRE>
<P>The <A HREF="AwtUIHost.htm#com_0003001115021800">handleEvent</A> method looks for a MOUSE_ENTER event on a target that is an instance of a <A HREF="UIPushButton.htm">UIPushButton</A> object. All other events are passed on to the <B>handleEvent</B> method of the superclass.

<P><B>Note</B>  The event handling implemented in the AFCExample1 sample described in this article is based on the JDK 1.02 event model. (AFC also supports the JDK 1.1 event model, also called the event delegation or Beans model.)
<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
