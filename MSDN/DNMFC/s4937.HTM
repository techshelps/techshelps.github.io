<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Bypassing MFC's Menu Update Mechanism</TITLE><META NAME="MS-HKWD" CONTENT="Bypassing MFC's Menu Update Mechanism"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H3>    Bypassing MFC's Menu Update Mechanism</H3><P>Your C-language code undoubtedly contains logic to enable and disable your program's menus depending on the program's current state. In order to make that code work in MFC, you need to disable MFC's mechanism for managing menu-item states.</P>
<P>When the user pulls down a menu, MFC searches for "update handlers" for the items on that menu, using the MFC message map. MFC performs this search before the menu drops down, so by the time the user sees the menu, its items have been appropriately enabled, disabled, checked, or unchecked. If MFC finds a handler for a menu item, it calls the handler to set the menu item's state. If there is no update handler associated with the command ID for a menu item, MFC disables the menu item by default. If you build your application at this stage, before bypassing the MFC mechanism, all of your menus will be grayed.</P>
<P>The following is an example of an update handler from another application:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>void CScribDoc::OnUpdateEditClearAll(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;Enable(!m_strokeList.IsEmpty());
}
</PRE></FONT>
<P>In the example, the update handler accesses an Edit Clear All command through the <B>CCmdUI</B> object passed to it. Calling the object's <B>Enable</B> member function takes care of enabling or disabling any user interface object — such as a menu item or toolbar button — associated with the command ID for that command.</P>
<P>Fortunately, disabling the menu update mechanism is easy. Just add the following line of code to the constructor for class CMainFrame (in MAINFRM.CPP):</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>CMainFrame::CMainFrame()
{
    m_bAutoMenuEnable = FALSE;    // bypass MFC menu enabling mechanism
}
</PRE></FONT>
<P>Now MFC relies entirely on your code to enable menu items. (Do this in CMainFrame rather than the view; the <B>CFrameWnd::m_bAutoMenuEnable</B> variable is easier to access there.)</P>
<P>For SHOWDIB, disable menu updating as shown above.</P>
<P>
<P><B>Note</B>  When memory is allocated for a C++ class object, the object's "constructor" is called. The constructor is a special function with the same name as the class. The constructor is normally used to initialize the object's allocated memory.</P>
<P>Just before a C++ object is destroyed, the object's "destructor" is called to clean up. The destructor is often used to deallocate any resources, such as memory, that were allocated by the constructor. The destructor has the same name as the class, prefixed with a tilde (~).</P>
<P>If you don't specify a constructor or destructor in your own classes, C++ supplies default versions, which may or may not do what you want.</P>
<P>
</FONT>
</BODY>
</HTML>
