<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Handling Messages Not Sent to the View</TITLE><META NAME="MS-HKWD" CONTENT="Handling Messages Not Sent to the View"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H3>    Handling Messages Not Sent to the View</H3><P>If you compile SHOWDIB after all of the previous changes, you'll find that, although the menus work, the menu items are not properly updated. For example, clipboard-related commands are all enabled, and a number of toggle commands at the top of the Options menu should be checked but aren't. </P>
<P>The problem stems from the original decision to override <B>WindowProc</B> in the view class. That was the correct decision, since other steps towards MFC will be much easier than if the override was done in another class, such as the main frame window class. But the view's WindowProc currently contains handler code for the <B>WM_INITMENU</B> message, although, as shown by the Spy++ tool (with Visual C++), the view window never receives that message; the main frame window does, since it owns the menus.</P>
<P>Various approaches are possible (as is often the case under the great flexibility of MFC). The easiest way is to also override <B>WindowProc</B> for class CMainFrame, just to handle this one message case. While it's a bit ugly to have to do multiple function overrides just to get all of SHOWDIB's message handling code to work minimally (you already have OnDraw and OnCmdMsg, as well as the first WindowProc), it's the quickest solution, so it's the one shown here.</P>
<P>For SHOWDIB, override <B>CWnd::WindowProc</B> in class CMainFrame. Then copy all of the code for the <B>WM_INITMENU</B> case into this override.</P>
<P>The CMainFrame::WindowProc override looks like this:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>LRESULT CMainFrame::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
    // TODO: Add your specialized code here and/or call the base class

    if (message == WM_INITMENU)
    {
        // TODO: Add your message handler code here
        /* check/uncheck menu items depending on state  of related
         * flags
         */

        ::CheckMenuItem((HMENU)wParam, IDM_UPDATECOL,
            (bUpdateColors ? MF_CHECKED : MF_UNCHECKED));
        ::CheckMenuItem((HMENU)wParam, IDM_TRANSPARENT,
            (wTransparent == TRANSPARENT ? MF_CHECKED : MF_UNCHECKED));
        ::CheckMenuItem((HMENU)wParam, IDM_DIBSCREEN,
            (bDIBToDevice ? MF_CHECKED : MF_UNCHECKED));
        ::CheckMenuItem((HMENU)wParam, IDM_NOUGLY,
            (bNoUgly ? MF_CHECKED : MF_UNCHECKED));
        ::CheckMenuItem((HMENU)wParam, IDM_MEMORYDIB, MF_CHECKED);
        ::EnableMenuItem((HMENU)wParam, IDM_PASTEDIB,
            ::IsClipboardFormatAvailable(CF_DIB)?MF_ENABLED:MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_PASTEDDB,
          ::IsClipboardFormatAvailable(CF_BITMAP)?MF_ENABLED:MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_PASTEPAL,
         ::IsClipboardFormatAvailable(CF_PALETTE)?MF_ENABLED:MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_PRINT,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_SAVE,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_COPY,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);

        ::EnableMenuItem((HMENU)wParam, IDM_ANIMATE0,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_ANIMATE5,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_ANIMATE50,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_ANIMATE100,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_ANIMATE200,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_ANIMATE201,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
        ::EnableMenuItem((HMENU)wParam, IDM_STEALCOL,
            bLegitDraw ? MF_ENABLED : MF_GRAYED);
    }
    return CFrameWnd::WindowProc(message, wParam, lParam);
}<BR></PRE></FONT>
<P>Notice that the Windows API calls have been disambiguated with the scope resolution operator. There's no need for calls to <B>GetSafeHwnd</B> or <B>GetSafeHdc</B> because none of the function calls pass an <B>HWND</B> or an <B>HDC</B>. You also need the following include directive in file MAINFRM.CPP:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>#include "showdib.h"<BR></PRE></FONT>
<P>This approach preserves your investment in the original SHOWDIB code and takes only a moment using ClassWizard and a bit of cut and paste. The better, but more time-consuming, alternative is to go all the way and use MFC's mechanism for updating menu commands, as described in <A HREF="S493F.HTM">Using MFC Menu Update Handlers</A>. </P>
</FONT>
</BODY>
</HTML>
