<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using MFC Menu Update Handlers</TITLE><META NAME="MS-HKWD" CONTENT="Using MFC Menu Update Handlers"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H3>    Using MFC Menu Update Handlers</H3><P>Your application needs to enable and disable menu items at appropriate times to let the user know which commands are available in any given context. In C-language applications for Windows, it's fairly typical  to update the state of all menu items in a single message handler. For example, in response to the <B>WM_INITMENU</B> message, SHOWDIB executes eighteen lines like the following line for the Edit Copy menu item:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>...
EnableMenuItem(wParam, IDM_COPY,
    bLegitDraw ? MF_ENABLED : MF_GRAYED);
...
</PRE></FONT>
<P>You saw this code in <A HREF="S4938.HTM">Handling Messages Not Sent to the View</A>. Except for a difference in command IDs, this code can be replaced by an MFC update handler like the following:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>void CScribDoc::OnUpdateEditCopy(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;Enable(bLegitDraw ? MF_ENABLED : MF_GRAYED);
}
</PRE></FONT>
<P>The code uses the same Boolean condition as the C version, but it makes the Boolean test in a call to the <B>Enable</B> member function of a <B>CCmdUI</B> object that MFC has attached to the <B>ID_EDIT_COPY</B> command. The bLegitDraw variable must be visible.</P>
<P>
<P><B>Tip</B>  In MFC version 3.0, you can update multiple command IDs with a single handler by specifying a range of contiguous IDs. For more information, see the article "Message Maps: Ranges of Messages" in Part 2 of <I>Programming with the Microsoft Foundation Class Library</I> (Visual C++ 2.0).</P>
<P>
<P>The MFC approach lets the framework manage the timing and complexity of keeping menus up to date. Although you now won't be able to find all such code in one place, you can easily get to the appropriate update handler for a command through ClassWizard's Edit Code button. The greatest advantage is that the same update handler that updates the menu item also updates the corresponding toolbar button if you have one. This works because both the menu item and the toolbar button have the same command ID.</P>
<P><B><FONT FACE="Symbol">Þ</FONT>    To add an update handler</B></P>
<P>    1.    Open ClassWizard, select the class you want to create a handler in, and specify the command ID that the handler is to update.</P>
<P>ClassWizard creates a prototype for the handler function in the class declaration. It also creates the shell of the handler function, complete with the correct parameter signature.</P>
<P>    2.    Move your code for that menu command into the handler.</P>
<P>In most cases, you can use the same Boolean expression you used when calling <B>EnableMenuItem</B>.</P>
<P>
<P>For SHOWDIB, you would move the code now found in CMainFrame::WindowProc into update handlers, then delete the WindowProc function in CMainFrame.</P>
<P>
<P><B>Note</B>  When you begin to update menus this way, remove the line of code that disables the MFC update mechanism in CFrameWnd::CFrameWnd (MAINFRM.CPP):</P>
<P>CMainFrame::CMainFrame()<BR>{<BR>   // m_bAutoMenuEnable = FALSE;  // bypass MFC menu enabling mechanism<BR>}<BR></P>
<P>
</FONT>
</BODY>
</HTML>
