<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Removing the Body of Your Old WinMain Function</TITLE><META NAME="MS-HKWD" CONTENT=" No more WinMain"><META NAME="MS-HKWD" CONTENT="Removing the Body of Your Old WinMain Function"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H4>    Removing the Body of Your Old WinMain Function</H4><P>Move any special initialization or idle-processing code from your C project's <B>WinMain</B> function (leave behind window class registration, window creation and display, and the message loop). Put the moved code into appropriate overridden <B>CWinApp</B> member functions in the MFC project, such as <B>InitInstance</B>, <B>InitApplication</B>, <B>Run</B>, or <B>ExitApplication</B>. You can put idle processing code into an override of the <B>OnIdle</B> member function. Guidelines:</P>
<UL><LI>    Application-level initialization code probably goes into <B>InitInstance</B>. AppWizard provides an override of this function, so you can simply copy the affected code into <B>InitInstance</B> in the <I>projname</I>.CPP file. (<B>InitApplication</B> is used for initialization code that applies only to the first running instance of the application.)</LI></UL><P>
<P><B>Note</B>  <I>PROJNAME</I> is whatever name you specified for your project in AppWizard.</P>
<P>
<UL><LI>    Application-level cleanup code goes into <B>ExitApplication</B>. AppWizard doesn't automatically override this function, so you must override it yourself. </LI><LI>    Code that fits elsewhere in the execution sequence might go somewhere in the <B>Run</B> function, which houses the application's message loop.</LI></UL><P>
<P>Once you've removed the code you need to save, delete your entire old <B>WinMain</B> function. You'll rely on MFC's version instead.</P>
<P>
<P><B>Tip</B>  C++ allows you to "override" member functions of class A in your derived class B. To override function A::Fun1, derive class B from class A and declare function B::Fun1. For an override, A::Fun1 (or the Fun1 version in one of A's base classes) must be a virtual function; otherwise, you simply hide A's version with B's version. For more details, see <A HREF="S492D.HTM#PT2">To override a class member function</A><B> </B></P>
<P>
<P>For SHOWDIB, move the following lines of code from the old <B>WinMain</B> function in SHOWDIB.CPP into the InitInstance function in class CShowDibApp, derived from <B>CWinApp</B> (in SHOWD.CPP):</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>    hInst = hInstance ;

     /* Initialize clip rectangle */

     SetRectEmpty(&amp;rcClip);

     if (!GetProfileString("extensions", "bmp", "", ach, sizeof(ach)))
             WriteProfileString("extensions", "bmp", 
                                                "showdib.exe ^.bmp");
     if (!GetProfileString("extensions", "dib", "", ach, sizeof(ach)))
             WriteProfileString("extensions", "dib", 
                                                "showdib.exe ^.dib");

     /* Save the pointer to the command line */
     lstrcpy(achFileName, lpCmdLine);
</PRE></FONT>
<P>If you're migrating 16-bit SHOWDIB, also move over the following lines:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>     /* default to MEMORY DIB's if XWindows */
     dwWinFlags = GetWinFlags();
     bMemoryDIB = (BOOL)(dwWinFlags &amp; WF_PMODE);
</PRE></FONT>
<P>You don't have to override <B>InitInstance</B> yourself, because AppWizard does it for you. You'll need to make some changes to support this code in its new location, as described below.</P>
<P><B><FONT FACE="Symbol">Þ</FONT>    To make the code changes work in SHOWDIB</B></P>
<P>    1.    Rename the lpCmdLine variable in the <B>lstrcpy</B> statement to <B>m_lpCmdLine</B>.</P>
<P>For 16-bit SHOWDIB, rename lpszCmdLine to <B>m_lpCmdLine</B>.</P>
<P>This uses a member variable of the MFC application class, CShowDibApp, instead of the old variable. The old variable in SHOWDIB.CPP will be deleted when you delete the old <B>WinMain</B>.</P>
<P>    2.    Similarly, rename the hInstance variable just before the code that initializes the clip region to <B>m_hInstance</B>, another MFC application class member variable.</P>
<P>    3.    "Disambiguate" both sets of calls to <B>GetProfileString</B> and <B>WriteProfileString</B> by prefixing a double colon (::) to them:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>if (!::GetProfileString("extensions", "bmp", "", ach, sizeof(ach)))<BR>      ::WriteProfileString("extensions", "bmp", "showdib.exe ^.bmp");<BR></PRE></FONT>
<P>The double colon is the C++ scope resolution operator, which here indicates that the functions are at file scope rather than class scope. In other words, MFC encapsulates or "wraps" these Windows API functions, but the calls here are to the Windows functions, not the wrapped MFC versions. This prevents an error in the number of parameters passed. For more information about disambiguating non-MFC function calls, see <A HREF="S4930.HTM">Disambiguating Calls to Windows API Functions</A>. </P>
<P>    4.    Add the following <B>#include</B> to the SHOWD.CPP file:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>#include "showdib.h"
</PRE></FONT>
<P>    5.    Move the declaration of the ach local variable from SHOWDIB.CPP to SHOWD.H. In class CShowDibApp (SHOWD.H), add the ach variable to a new "// Attributes" section of the class declaration, as shown below:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>class CShowDibApp : public CWinApp
{
public:
    CShowDibApp();

// Attributes
    CHAR        ach[40];    // for 16-bit SHOWDIB, it's char

// Overrides
    // ...
};<BR></PRE></FONT>
<P>This isn't strictly necessary, but it illustrates a common practice in MFC. Variables that you might ordinarily define as globals are often turned into class member variables. This makes them "global" (at class scope) from the point of view of class member functions but keeps down the clutter of true globals.</P>
<P>    6.    Delete your old <B>WinMain</B> function completely.</P>
<P>
<P>
<P><B>Tip</B>  You might want to use MFC naming conventions for consistency. Class names begin with "C". Member variable names begin with "m_" <FONT FACE="Symbol">¾</FONT> so the ach variable above should really be m_ach (everywhere). MFC programmers typically also use Hungarian notation. Charles Petzold discusses Hungarian notation in <I>Programming Windows 3.1</I> (Microsoft Press).</P>
<P>
</FONT>
</BODY>
</HTML>
