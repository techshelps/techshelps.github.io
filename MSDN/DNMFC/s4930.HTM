<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Disambiguating Calls to Windows API Functions</TITLE><META NAME="MS-HKWD" CONTENT="Disambiguating Calls to Windows API Functions"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H4>    Disambiguating Calls to Windows API Functions</H4><P>At its core, MFC wraps the Windows API (or large portions of it). MFC uses C++ classes to represent common Windows-based abstractions, such as windows, dialog boxes, device contexts, controls, brushes and other GDI objects, and so on. Most of these classes encapsulate a Windows handle, such as an <B>HWND</B> or <B>HDC</B>, as well as the relevant APIs that use that handle type. For example, class <B>CWnd</B> and all of the classes derived from it wrap an <B>HWND</B> by defining a class member variable to hold the <B>HWND</B> and class member functions to create and destroy the <B>HWND</B> and to otherwise operate on it. Most of the Windows API functions that take an <B>HWND</B> parameter are wrapped by <B>CWnd</B> or one of its derived classes.</P>
<P>Within an MFC program, though, you can freely call either the MFC wrapper function or the corresponding Windows API. You can get at all of the Windows API anytime you need to.</P>
<P>It can be pretty confusing if you're mixing MFC calls with Windows API calls, so you need to disambiguate your Windows API calls — the ones with the same names as MFC wrappers — using the C++ scope resolution operator (<B>::</B>). To use the scope operator, prefix the API name with it:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>::BeginPaint(m_hWnd, &amp;ps);
</PRE></FONT>
<P>This lets the compiler know you're calling outside the class scope.</P>
<P>
<P><B>Tip</B>  If you aren't sure whether to disambiguate a function call, use F1 help in Visual C++ on the API name. Functions that MFC wraps bring up a dialog box asking you to specify whether you want help on the MFC version or the Windows API version. If the dialog box appears and lists "Class Library Reference," disambiguate the call. In most cases, the MFC version has a different parameter signature, and often a different return type. The MFC migration tool also helps you spot functions that must be disambiguated.</P>
<P>
<P>For SHOWDIB, whose message handling <B>switch</B> statement uses nothing but Windows API calls, you need to disambiguate lots of function calls. Adding the scope operator to nearly all calls that take an initial <B>HWND</B> or <B>HDC</B> parameter in your view's WindowProc, OnDraw, and OnCmdMsg takes care of most of them. The compiler will give you error messages about parameter types or numbers of parameters for the rest.</P>
</FONT>
</BODY>
</HTML>
