<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Hook Up MFC Diagnostics</TITLE><META NAME="MS-HKWD" CONTENT="Hook Up MFC Diagnostics"><META NAME="MS-HKWD" CONTENT="Dumping an Object's Contents"><META NAME="MS-HKWD" CONTENT="Validating an Object's State"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H3>    Hook Up MFC Diagnostics</H3><P>Since most MFC classes are ultimately derived from class <B>CObject</B>, they inherit several useful diagnostic features. The two most important of these are the ability to:</P>
<UL><LI>    <A HREF="#sec0">Dump the contents of a class object</A> for diagnostic analysis.</LI><LI>    Have an object <A HREF="#sec1">validate its own internal state</A> before you use it.</LI></UL><P>
<P>You can easily take advantage of these abilities in your documents, views, and other classes derived from MFC base classes. All classes derived from <B>CObject</B>, directly or indirectly, inherit — and can override — two member functions: <B>Dump</B> and <B>AssertValid</B>. AppWizard assumes that you'll want to make these overrides and so writes shells for the functions for you.</P>
<H4><A NAME="sec0"></A>  Dumping an Object's Contents</H4><P>During development, you'll often want to know what an object's member variables contain. Override the <B>Dump</B> member function in your derived class to dump the class's contents to a "dump context." (Consult the discussion of diagnostics in your documentation to see where dumped contents are sent. You can search for the <B>afxDump</B> global variable.)</P>
<P>For example, even before you begin to move SHOWDIB's code into the document and view classes, you can override CShowDibView::Dump, something like this:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>#ifdef _DEBUG
void CShowDibView::Dump(CDumpContext&amp; dc) const
{
    CView::Dump(dc);

    // dump view object contents
    dc &lt;&lt; member_variable_1;   // pass variables to dump context
    dc &lt;&lt; member_variable_2;
    member_variable_3.Dump();  // or call the Dump function of any
                               // class objects contained by your class
    //...
}
#endif //_DEBUG
</PRE></FONT>
<P>Notice that Dump can only dump variables visible to it. Local variables inside member functions of CShowDibView aren't visible. But member variables of the class are visible. If a variable constitutes part of what you consider the class's state, it's a good idea to make it a class member variable.</P>
<P>Dump is always conditionally compiled for debug builds. MFC passes you a <B>CDumpContext</B> object, which works something like a C++ iostream object like <B>cout</B>. You "insert" variables to the dump context with the <B>CDumpContext</B> insertion operator (<B>&lt;&lt;</B>); insertions can be chained. <B>CDumpContext</B> accepts many common data types. You can regulate the "depth" to which objects are dumped. If you want to dump object-type data with its own Dump function, you can call the object's Dump function, passing your <B>CDumpContext</B> object. For more information about dumping, see the article "Diagnostics" in <I>Programming with the Microsoft Foundation Class Library</I> (Visual C++ 2.0) or Chapter 15 in the <I>Class Library User's Guide</I> (earlier versions).</P>
<H4><A NAME="sec1"></A>  Validating an Object's State</H4><P>C++ class objects can be internally very complex. When you construct an object, or receive one as a parameter to a function, you'd like to be able to validate the object's internal state for some sort of consistency or reasonableness. Override the <B>AssertValid</B> member function in your derived class to enable objects of the class to report their own internal validity. Used consistently throughout your <B>CObject</B>-derived classes, <B>AssertValid</B> is a powerful diagnostic tool.</P>
<P>In your AssertValid override, you usually use the <B>ASSERT</B> macro to test assumptions about the class's member variables. In debug builds, <B>ASSERT</B> tests a Boolean condition. If the condition is <B>FALSE</B>, the macro terminates the application with a message. Otherwise, execution continues normally. In release builds, <B>ASSERT</B> does nothing (and arguments passed to it are not evaluated). For example, an AssertValid function might look like this:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>#ifdef _DEBUG
void CShowDibView::AssertValid() const
{
    // assert validity of base class contents
    CShowDib::AssertValid();

    // assert the validity of object contents
    ASSERT(m_nValue == 0);
    ASSERT_VALID(m_pSubObject);
    // ...
}
#endif //_DEBUG
</PRE></FONT>
<P>Like Dump, AssertValid is conditionally compiled for debug builds. The function first calls the base class version to test any variables declared in that or higher base classes. Then it tests the validity of the derived class's member variables.</P>
<P>
<P><B>Tip</B>  If you need <B>ASSERT</B> functionality in a release build, use the <B>VERIFY</B> macro instead.</P>
<P>
<P>When one of your functions is passed an object that overrides <B>AssertValid</B>, use the <B>ASSERT_VALID</B> macro to invoke the object's AssertValid function:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>...
ASSERT_VALID(pAnObject);    // calls pAnObject's AssertValid
...
</PRE></FONT>
<P>If your class has member variables that contain pointers to other objects, you can also use <B>ASSERT_VALID</B> inside your AssertValid function, as shown above, to validate those objects. An <B>ASSERT_VALID</B> call can often work its way down through several layers of the AssertValid functions of embedded or contained objects. Figure 9 shows this process for the example that follows.</P>
<P><img src="PWPVALI.gif"></P>
<P>
<P>For example, suppose you have a <B>CObList</B> collection containing pointers to CPerson objects, and class CPerson, like <B>CObList</B>, overrides <B>AssertValid</B>. You can use this <B>AssertValid</B> function to check the internal consistency of the list. With a little more work, you can even have your list (a CPersonList class derived from <B>CObList</B>) call the AssertValid function of each contained CPerson object. The CPerson objects might in their turn call the AssertValid functions of subordinate objects that they contain. Here's a small fragment of code that gets the whole process going:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>// Given a pointer, pList, to a CPersonList of CPerson pointers...
ASSERT_VALID(pList);
// The rest flows from that call
</PRE></FONT>
<P>In a debug build, you aren't worried about the overhead of all this validation, and the easy validation is very valuable diagnostic information. For more information, see the article "Diagnostics: The ASSERT Macro" in Part 2 of <I>Programming with the Microsoft Foundation Class Library</I> for Visual C++ 2.0, or for earlier versions see "Overriding the AssertValid Function" in the <I>Class Library User's Guide</I>.</P>
</FONT>
</BODY>
</HTML>
