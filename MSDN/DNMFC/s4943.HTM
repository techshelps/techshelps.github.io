<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Make GDI Calls the MFC Way</TITLE><META NAME="MS-HKWD" CONTENT="Make GDI Calls the MFC Way"><META NAME="MS-HKWD" CONTENT="A New OnDraw"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H3>    Make GDI Calls the MFC Way</H3><P>In your original Windows code, the device context appears as a handle to a GDI data structure (a <B>DC</B>). Certain Windows API functions — the GDI calls — operate on a device context when you pass them a handle to one. In contrast, MFC encapsulates the device-context handle (<B>HDC</B>) inside an MFC object of class <B>CDC</B>. Using the device context the MFC way requires a different syntax and a different mode of thinking.</P>
<P>The model just described is one example of a general model in MFC, which comes from the use of C++. MFC encapsulates common Windows-based entities — device contexts, windows, dialog boxes, GDI objects such as brushes — in MFC classes. To use these classes, you (a) create an object of the class (or MFC does) and (b) call member functions of the class to manipulate it.</P>
<P>Making GDI calls the MFC way occurs mainly in the view's OnDraw member function. Making other Windows API calls the MFC way occurs throughout the MFC portions of your program.</P>
<P>In <A HREF="S4932.HTM#sec7">Moving Your Paint Code to OnDraw</A>, you saw SHOWDIB's <B>WM_PAINT</B> code as it appears in the OnDraw member function override. That code doesn't take full advantage of MFC, though, since it ignores the pointer to a <B>CDC</B> object that OnDraw receives as a parameter:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>void CShowDibView::OnDraw(CDC* pDC)
</PRE></FONT>
<P>That <B>CDC</B> object encapsulates a completely prepared device context, but instead of using it, the OnDraw code gets its own device context:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>hDC = ::BeginPaint(hWnd, &amp;ps);
</PRE></FONT>
<P>That version of OnDraw also calls Windows API functions directly rather than calling the MFC equivalents, requiring use of the C++ scope resolution operator to disambiguate the calls.</P>
<H4><A NAME="sec0"></A>  A New OnDraw</H4><P>Here's a version of OnDraw that (a) uses the <B>CDC</B> pointer and (b) calls MFC versions of the Windows API functions:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>void CShowDibView::OnDraw(CDC* pDC)
{
    HWND hWnd = GetSafeHwnd(); // for converting hWnd parameters
    HDC hDC = pDC-&gt;GetSafeHdc(); // for converting hdc parameters

    // TODO: add draw code for native data here
    /* If we have updated more than once, the rest of our
    * window is not in some level of degradation worse than
    * our redraw...  we need to redraw the whole area
    */
    if (UpdateCount &gt; 1) {
        ValidateRect(NULL);   // replaces Begin/EndPaint calls
        UpdateCount = 0;
        InvalidateRect(NULL);
        return;    // replace break statement
    }

    // BeginPaint call deleted
    AppPaint(hWnd,
             hdc,
             GetScrollPos(SB_HORZ),
             GetScrollPos(SB_VERT) );
    // EndPaint call deleted
    // delete break statement here

}
</PRE></FONT>
<P>In the second line of the function, this version of OnDraw calls <B>GetSafeHdc</B> (similar to <B>GetSafeHwnd</B>) through the <I>pDC</I> pointer. Recall that this syntax resembles accessing a struct's members through a pointer, but here the notation is used to access and call a member function of a C++ object instead. After this call, a safe <B>HDC</B> is available for use in the call to the SHOWDIB application-specific function AppPaint.</P>
<P>Instead of disambiguating the direct calls to the Windows API functions, as you saw earlier in WindowProc, this version of OnDraw uses the MFC versions of the same functions. Because the view class is ultimately derived from class <B>CWnd</B>, it inherits all of <B>CWnd</B>'s member functions, including these. OnDraw, as a member of the view class, can simply call those inherited functions directly (without having to call through a pointer as with the <B>HDC</B>). Note that the MFC versions don't pass an <B>HWND</B> parameter and so are shorter and simpler. </P>
<P>You'll want to make such changes generally in your new MFC application, although you really only need to do so in the code associated with your derived MFC classes. Such changes aren't necessary in the original C code that you simply converted to C++.</P>
</FONT>
</BODY>
</HTML>
