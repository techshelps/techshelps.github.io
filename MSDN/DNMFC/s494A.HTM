<HTML>
<HEAD>
<meta name="PREMIUM" content="MSDN">
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta name="MS.LOCALE" content="EN-US">
<meta name="DESCRIPTION" content="This page is from the MFC Migration Kit book in the MSDN Library">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Use Document Serialization for Input/Output</TITLE><META NAME="MS-HKWD" CONTENT="Use Document Serialization for Input/Output"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<H3>    Use Document Serialization for Input/Output</H3><P>MFC provides protocols for many standard commands and full implementations for some of them. For example, most of the File Open command is implemented for you. In response to File Open, the MFC framework displays the File Open dialog box, retrieves the selected filename, creates a document object and its associated view and frame window objects, opens the disk file, and tells the document to read the file in. All you have to write is a small amount of document-class code to specify what to read. Correspondingly, MFC documents respond to the Save and Save As commands. All you have to write is the code to write data to a file that the framework opens and closes for you.</P>
<P>Figure 10 and Figure 11 outline the File Open and File Save command sequences, which use file serialization.</P>
<P><img src="PWPOPEN.gif"></P>
<P>
<P>MFC's default implementation of these commands is called "document serialization." MFC calls a document object's <B>Serialize</B> member function to read or to write the document's data serially to or from a disk file. To make serialization really useful in an object-oriented environment, MFC makes it easy to store not only built-in C++ data types but also objects, including many of those derived from class <B>CObject</B>. Using this default "object persistence" mechanism, you can read and write the contents of objects, storing them on disk to be read back in later and reconstituted to their former states.</P>
<P>For example, suppose your document contains an array of CPerson objects, where each object contains a set of information about one person: <B>CString</B> objects containing the person's name and address, a <B>CTime</B> object containing date of birth, and perhaps a CPhone object, a <B>WORD</B> storing a social security number, and so on. Your program lets the user create several new person objects, storing them in the array. </P>
<P>When the user chooses the File Save command, MFC calls your document's Serialize member function, as shown in Figure 11. Serialize is passed a pointer to a <B>CArchive</B> object, which encapsulates a pointer to a <B>CFile</B> object already set to the right filename and already opened on disk. Within Serialize, you iterate through the person list, calling CPerson::Serialize for each person in the list. That function, in turn, passes the CPerson object's data to the <B>CArchive</B>, much as variables are passed to the <B>Dump</B> function described earlier. The CPerson object passes its name, address, and other information one by one to the archive, which causes them to be written to the file. A similar process occurs when you read the data back in.</P>
<P><img src="PWPSAVE.gif"></P>
<P>
<P>On disk, a serialized object consists of a sequence of data items: some "header" information to identify the type of data, then the data itself. When your program "deserializes" an object, it determines its type, dynamically constructs an empty object of the correct type, and tells the object to read in its own data.</P>
<P>To do your simple part of this complex dance, move your data structures into the document class and then override <B>Serialize</B> in your document class (actually, AppWizard writes the empty shell of this override for you). Here's a simple example of a CPerson::Serialize member function that the document's Serialize function can call:</P>
<P><BR></P><FONT FACE="COURIER" SIZE="3"><P>void CPerson::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
        // insert objects in the archive
        ar &lt;&lt; m_strName;
        ar &lt;&lt; m_wAge;
        ar &lt;&lt; m_wSSN;
    }
    else
    {
        // extract objects from the archive
        ar &gt;&gt; m_strName;
        ar &gt;&gt; m_wAge;
        ar &gt;&gt; m_wSSN;
    }
}</PRE></FONT>
<P>You write the lines within the <B>if</B> and <B>else</B> blocks. Store data in the archive using the <B>CArchive</B> insertion operator (<B>&lt;&lt;</B>), which is overloaded for most common built-in and MFC data types. Load data with the extraction operator (<B>&gt;&gt;</B>). Notice that you store and load data items in the same order.</P>
<P>If serialization doesn't suit your needs, you can override various member functions of the document class or the application class to implement something else. </P>
<P>For example, SHOWDIB already has file-handling code, so you might incorporate it into an overridden version of the serialization mechanism to take advantage of MFC's existing File Open and Save implementations while still using parts of SHOWDIB's existing code. One approach is to override <B>CDocument::OnOpenDocument</B> and remove the code that creates an archive and calls Serialize, replacing it with SHOWDIB's I/O code.</P>
</FONT>
</BODY>
</HTML>
