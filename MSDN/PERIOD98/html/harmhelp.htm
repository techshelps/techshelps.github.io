<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Harmonious HelpDesk</title>
<meta name=MS-HAID content="msdn_harmhelp">
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<Font face="verdana,arial,helvetica" size="2">
<h1><a name="msdn_harmhelp"></a>The Harmonious HelpDesk</h1>
<p>
Robert Coleridge<br>
MSDN Content Development Group</p>
<p>
Recently, one of our readers wrote to express concern that two of the articles in our Helpdesk series, "Designing the HelpDesk Transaction-Processing Object" and "Task Distribution in a Customer Service System," (published in the last issue of <i>Developer Network News</i>) offer conflicting data-access models. In fact, they are actually in complete harmony. It was a good question, though, so we decided to take the time to reply here, in case other readers had the same impression.</p>
<p>
Fred Pace's article, <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_hdobj">
</object><a href=JavaScript:alink_1.Click()>
"Designing the HelpDesk Transaction-Processing Object,"</a> which shows how the object model for the HelpDesk sample was designed, gives an excellent example of encapsulating data access through a defined API. Why would Fred do this? The answer is quite simple: In a distributed environment, all client/server designs should be based on an <i>n</i>-tier paradigm.</p>
<p>
Fred goes to great lengths to explain the design model for the HelpDesk. There are several reasons why this design is advantageous: The application is enterprise scalable, the application is easier to maintain, the application's clients tend to be thinner, and last but not least—the actual data is not exposed to the user, only a working copy of it. By encapsulating access to the data with an API set, there is a safety net of validation, security, workflow, and business logic. All of this ensures a much more scalable and robust application.</p>
<p>
Steve Kirk's <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_taskdist">
</object><a href=JavaScript:alink_2.Click()>
"Task Distribution in a Customer Service System"</a> is a great article on how to do load balancing with Transact-SQL (T-SQL). Through the power of T-SQL, Steve shows how the HelpDesk sample uses SQL tasks to automate the assignment process for incoming requests. In order to gain the highest performance-to-maintainability ratio, Steve wrote a "distribution optimizer" in T-SQL. By doing this he gains direct access to the data and encapsulates the data access to a few stored procedures.</p>
<p>
Since Steve's optimizer is written in T-SQL and directly accesses the data, it might appear that he violates the <i>n</i>-tier paradigm that MSDN advocates. However, because the optimizer is a scheduled SQL task, it runs at the lowest level—in the same tier as SQL Server itself.</p>
<p>
So, here we have two models: Fred's encapsulates data access through an API set, and Steve's directly manipulates the data via T-SQL. The question is, "Are they in conflict?"</p>
<p>
My answer: The model that Fred espouses deliberately exposes the data to a user, but only through an API set, while Steve's model does not expose the data at all. While Fred's API is for external exposure, Steve's stored procedures are for tasks internal to SQL Server and would never be invoked by an end user. So they are not in conflict, merely fulfilling different tasks on different tiers.</p>
</font></BODY>
</HTML>
