<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Basics of ActiveX </title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<Font face="verdana,arial,helvetica" size="2">
<h1><a name="thebasicsofactivex"></a>The Basics of ActiveX</h1>
<p class=indent>
by Al Saganich</p>
<p>
Java is a delight to program. Applications are quick to develop, robust, and expandable. But often, developers wish to use a host of controls and other gadgets that already exist. Perhaps you're a converted Visual Basic or Delphi programmer and want to use an old, familiar control in your hot new development environment. But Java is platform-independent, right? Well, yes, in its purest form—but you can use ActiveX controls in your Java application! And if you ever wanted to, here's your chance to learn how.</p>
<p>
The hype about ActiveX and the Internet has been unrelenting—how ActiveX controls build excitement into your Web pages by providing fancy graphics or access to legacy code or some other wizzy feature. But what does ActiveX really give you, and how do you use it? Are there limitations as to which controls you can use in Java applications? And how does ActiveX impact Java from the points of security, interoperability, and portability?</p>
<p>
In this article, we'll explore the basics of ActiveX, examining how to use ActiveX controls in Java applications. We'll investigate the nuts and bolts of ActiveX controls; we'll discuss which controls you can and can't use, and why; we'll detail how to call ActiveX methods and capture ActiveX events; and we'll touch on how Active X affects Java application security. </p>
<p>
Next month, we'll continue our ActiveX journey by demonstrating how to load ActiveX controls directly into a Web page, then pass these controls into a Java applet. We'll also show you how to package and ship controls, how to write your own ActiveX controls, and how to expose your Java applications as ActiveX controls.</p>
<h3>Why ActiveX?</h3>
<p>
Why use ActiveX in the first place? For many reasons. If you're like me, you're always looking for a simpler way to do something. I migrated from C to C++ because I liked classes and other aspects of C++, then on to Java because of its simple elegance. But along the way, I had to abandon a large body of code I'd written in C++. ActiveX lets me regain some of that investment. </p>
<p>
Another compelling reason to use ActiveX is the wealth of ActiveX controls that already exist. Visual Basic programmers have been evangelizing about the wonders of OLE controls for ages. Now, you can use many of those controls from Java, as well. In addition, ActiveX lets you easily access database information. Not to mention the fact that you can control other Microsoft applications via ActiveX scripting—you can embed your favorite spreadsheet directly into your Web page!</p>
<h3>The downside</h3>
<p>
ActiveX is a great technology, but it has its warts. First and foremost, Java is supposed to be portable—we've all heard about <i>write once, run anywhere</i>. Well, with ActiveX, that idea is gone. Currently, ActiveX controls bind you not only to a single platform—Windows—but also to a single browser—Internet Explorer. Your programs are no longer completely portable. </p>
<p>
Actually, ActiveX isn't as proprietary as it seems. A plug-in for Netscape exists, so you can run ActiveX-based pages in Netscape, but you're still limited to Win32 platforms. However, even that situation is changing. In October 1996, Microsoft placed ActiveX into the public domain by giving over the base code and control to the Cambridge, Massachusetts-based Open Group (www.activex.org). In fact, several companies are actively involved in bringing ActiveX to other platforms: Macromedia and Metrowerks to the Mac, and Bristol Technologies to UNIX. While it remains to be seen whether ActiveX will make it to other platforms, it's certainly here to stay on Windows.</p>
<h3>Tools of the trade</h3>
<p>
Three tools assist the Visual J++ developer in working with ActiveX controls: Regsvr32.exe, which registers a given control; JavaTLB, which generates .CLASS files and summary.txt from registered controls; and JActiveX.exe, which generates .CLASS files and java source code for a control. We'll discuss each of these tools as we encounter them in building an ActiveX-enabled Java application.</p>
<h3>Preparing an ActiveX control</h3>
<p>
A Java application accesses an ActiveX control via a set of .CLASS files that normally reside in the ${windows}\java\trustlib directory tree. Preparing a control for use with Visual J++ is a two-step process. First, you register the control using Regsvr32.exe, which ships with Visual J++. Regsvr32 takes one argument—the DLL or control to register—and any of several command-line switches, the most notable of which is /u to uninstall a control. By default—that is, when run with only a dll or ocx—Regsvr32.exe registers the control. </p>
<p class=indent>
Note: Download our code!</p>
<p>
For the remainder of this article, we'll assume that the ActiveX control binary (OCX, EXE, or DLL) has “magically” arrived on your computer. Next month, we'll look more closely at packaging controls for distribution directly from a Web page. You can download this article's sample files, including the ActiveX control, from www.cobb.com/vjp.</p>
<p>
If you've downloaded the source code for this month's example, open a DOS box and change to the directory containing prodcons.ocx. Then, type <i>regsvr32 prodcons.ocx</i>. <b>Figure A</b> shows the result of running Regsvr32.exe on the prodcons ocx.</p>
<p>
<b>Figure A</b></p>
<p>
<img src="vjp9821a.gif" border=0></p>
<p>
<b>Regsvr32 displays output like this.</b></p>
<p>
Once you've registered a control, it will appear in the JavaTLB (Java Type Library Wizard) tool. To run the JavaTLB, choose Tools | Java Type Library Wizard from Visual J++'s main menu; there's no keyboard shortcut. For example, in <b>Figure B,</b> JavaTLB displays all the currently registered controls. </p>
<p>
<b>Figure B</b></p>
<p>
<img src="vjp9821b.gif" border=0></p>
<p>
<b>The JavaTLB displays the currently registered tools.</b></p>
<p>
You can now manually generate the registered tool's required classes and package its files for use with Visual J++. For this example, select the ProdCons ActiveX Control Module control, as shown in <b>Figure B</b>, then click the OK button. <b>Figure C</b> shows the Java Type Library tab of the output window after we ran JavaTLB on the ProdCons control. </p>
<p>
<b>Figure C</b></p>
<p>
<img src="vjp9821c.gif" border=0></p>
<p>
<b>JavaTLB produced this output for ProdCons.ocx.</b></p>
<p class=indent>
Tip: Double-click the summary.txt line.</p>
<p class=indent>
After running the JavaTLB tool, you can double-click on the summary.txt line for any of the processed controls to immediately open the summary.txt file. This file contains a definition of the objects and interfaces in the ActiveX control from a Java perspective.</p>
<h3>Our first control</h3>
<p>
It's surprising how similar ActiveX controls are to everyday Java classes. From a programming perspective, they're just another class that Java can instantiate and use. Our ProdCon example is a simple ActiveX messaging control that works as a go-between for a producer and a consumer of strings. When an application sends a message, a NewMessage event is generated, signaling that a message can be retrieved. The control also supports getting the current count of available messages. <b>Figure D</b> shows the ProdCon example running. Let's look more closely at how other ActiveX controls work.</p>
<p>
<b>Figure D</b></p>
<p>
<img src="vjp9821d.gif" border=0></p>
<p>
<b>Our ProdCon example looks like this while it's running.</b></p>
<p>
An ActiveX control is really just reusable code in a binary form. Each control contains one or more interfaces that you can use to access it. For instance, our producer/consumer control could have had one interface for producers and another for consumers. </p>
<p>
When you create an ActiveX control, you create an instance of the control, but cast it as an instance of the interface in which you're interested. <b>Listing A</b> shows the summary.txt file for the ProdCons ActiveX control. We've highlighted the interfaces in color.</p>
<p>
<b>Listing A: ProdCons ActiveX object description</b></p>
<pre>public class prodcons/ProdCons extends 
<code>  java.lang.Object</code>
<code>{</code>
<code>}</code>
<code>public interface prodcons/IProdConsEvents </code>
<code>  extends com.ms.com.IUnknown</code>
<code>{</code>
<code>    public abstract void NewMessage();</code>
<code>}</code>
<code>public interface prodcons/IProdCons extends </code>
<code>  com.ms.com.IUnknown</code>
<code>{</code>
<code>    public abstract int GetMsgCount();</code>
<code>    public abstract int SendMsg(java.lang.String);</code>
<code>    public abstract java.lang.String GetMsg();</code></pre>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. . .</p>
<pre>}</pre>
<p>
We could have chosen the IProdCons interface or the IprodConsEvents interface as the interface to access our instance of an IProdCons object. As you'll see, the IProdConsEvents interface captures events. So, we created our object, as shown in Listing B, using IProdCons on the ProdCons object. Looking closely at the code, you'll see that while we created an instance of a ProdCons object, it was assigned to an instance of the interface we wanted to use to access—in this case IProdCons. </p>
<p class=indent>
Note: Understand the interface.</p>
<p>
In order to use an ActiveX control, you must understand the interfaces to that control. Carefully consult the documentation that came with the control you're using, then choose the interface that best suits your needs.</p>
<p>
<b>Listing B: Creating the ActiveX control in Java</b></p>
<pre>// ProdCon.java
<code>// 19-September-1997</code>
<code>// Al Saganich for </code>
<code>// Visual J++ Developer's Journal</code>
<code>//</code>
<code>// Copyright 1997, Al Saganich, </code>
<code>// Visual J++ Developers Journal.</code>
<code>//</code>
<code>// This code is provided without warrantee </code>
<code>// of any kind and may or may not be fit </code>
<code>// for any purpose other than illustration.</code>
<code>// This code may be used, changed or </code>
<code>// distributed in any form, </code>
<code>// electronic or otherwise, as long as this </code>
<code>// notice is not removed.</code>
<code>//</code>
<code>import java.awt.*;</code>
<code>import java.awt.event.*;</code>
<code>import com.ms.com.*;</code>
<code>import prodcons.*;</code>

<code>//</code>
<code>// ActiveX sample</code>
<code>// Al Saganich for </code>
<code>// Visual J++ Developer's Journal</code>
<code>//</code>
<code>// This class uses the prodcons classes to send </code>
<code>// and receive messages from an ActiveX control</code>
<code>// </code>
<code>class ProdCon implements </code>
<code>              IProdConsEvents,  </code>
<code>              // Event fired by the control.</code>
<code>              ActionListener</code>
<code>{</code>
<code>    IprodCons    iActiveX;</code>
<code>    ConnectionPointCookie     </code>
<code>                eventConnector;</code>
<code>. . .</code>
<code>    public ProdCon()</code>
<code>    {</code>
<code>        try</code>
<code>    {</code>
<code>        iActiveX = (IProdCons) new ProdCons();</code>
<code>    }</code>
<code>    catch (com.ms.com.ComFailException e)</code>
<code>    {</code>
<code>        System.out.println(e);</code>
<code>        return;</code>
<code>    }</code>
<code> . . .</code>
<code>}</code></pre>
<h3>Methods </h3>
<p>
ActiveX controls can have methods, just like Java classes. While the arguments are limited to ActiveX-supported types, most Java types are supported. <b>Table A</b> shows most of the ActiveX types and their Java equivalents. Of course, the same types apply to both method arguments and return values.</p>
<p>
<b>Table A: ActiveX types and Java equivalents</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=320><b>ActiveX</b></td>
<td class=blue width=320><b>Java</b></td>
</tr>
<tr valign=top>
<td width=320>short</td>
<td width=320>short</td>
</tr>
<tr valign=top>
<td width=320>long</td>
<td width=320>int</td>
</tr>
<tr valign=top>
<td width=320>float</td>
<td width=320>float</td>
</tr>
<tr valign=top>
<td width=320>double</td>
<td width=320>double</td>
</tr>
<tr valign=top>
<td width=320>CURRENCY</td>
<td width=320>long</td>
</tr>
<tr valign=top>
<td width=320>DATE</td>
<td width=320>double</td>
</tr>
<tr valign=top>
<td width=320>LPCSTR</td>
<td width=320>String</td>
</tr>
<tr valign=top>
<td width=320>BOOL</td>
<td width=320>boolean</td>
</tr>
<tr valign=top>
<td width=320>short *</td>
<td width=320>short[]</td>
</tr>
<tr valign=top>
<td width=320>long *</td>
<td width=320>long[]</td>
</tr>
</table><br>
<p>
Calling ActiveX methods and functions from Java is straightforward. <b>Listing C </b>shows two of the methods that act on an ActiveX object. The two lines shown in color access data from and send data to the ActiveX object, respectively.</p>
<p>
<b>Listing C: Calling ActiveX methods </b></p>
<pre>public void NewMessage()
<code>{</code>
<code>    System.out.println(</code>
<code>      " New Message event fired\n");</code>
<code>    try</code>
<code>    {</code>
<code>        String msg = iActiveX.GetMsg();</code>
<code>        String old = receiveBuffer.getText();</code>
<code>        old += "\n" + msg;</code>
<code>        receiveBuffer.setText(old);</code>
<code>    }</code>
<code>    catch (com.ms.com.ComFailException e)</code>
<code>    {</code>
<code>        System.out.println(e);</code>
<code>    }</code>
<code>}</code>

<code>public void send(String msg)</code>
<code>{</code>
<code>    try</code>
<code>    {</code>
<code>        iActiveX.SendMsg(msg);</code>
<code>        int count = iActiveX.getMsgCount();</code>
<code>    }</code>
<code>    catch (com.ms.com.ComFailException e)</code>
<code>    {</code>
<code>        System.out.println(e);</code>
<code>    }</code>
<code>}</code></pre>
<h3>Errors and exceptions</h3>
<p>
To this point, we haven't discussed errors and exceptions. From Java's perspective, ActiveX objects and Java objects are one and the same: Both can return values and throw exceptions. However, unlike most Java classes, ActiveX objects throw a small number of exceptions and count on one of the exception's member variables to determine exactly what happened! </p>
<p>
For the most part, ActiveX objects will throw com.ms.com.ComException—or exceptions derived from ComException, such as com.ms.com.ComFailException—when something goes wrong. To get more specific information, you need to use the getHResult() method to determine the type of exception.</p>
<p>
<b>Table B</b> shows common exception values and their meanings. <b>Listing D</b> shows how a simple method captures and processes exceptions. Note that ActiveX objects may return values other than the ones listed in the table; see your control's documentation for the error values it may return.</p>
<p>
<b>Table B: Common exception values</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=213><b>Description</b></td>
<td class=blue width=213><b>Symbolic constant</b></td>
<td class=blue width=213><b>Value</b></td>
</tr>
<tr valign=top>
<td width=213>Unexpected failure</td>
<td width=213><pre><code>E_UNEXPECTED</code></pre>
</td>
<td width=213>0x8000FFFF</td>
</tr>
<tr valign=top>
<td width=213>Not implemented</td>
<td width=213><pre><code>E_NOTIMPL</code></pre>
</td>
<td width=213>0x80004001</td>
</tr>
<tr valign=top>
<td width=213>Ran out of memory</td>
<td width=213><pre><code>E_OUTOFMEMORY</code></pre>
</td>
<td width=213>0x8007000E</td>
</tr>
<tr valign=top>
<td width=213>One or more arguments invalid</td>
<td width=213><pre><code>E_INVALIDARG</code></pre>
</td>
<td width=213>0x80070057</td>
</tr>
<tr valign=top>
<td width=213>No such interface supported</td>
<td width=213><pre><code>E_NOINTERFACE</code></pre>
</td>
<td width=213>0x80004002</td>
</tr>
<tr valign=top>
<td width=213>Invalid pointer</td>
<td width=213><pre><code>E_POINTER</code></pre>
</td>
<td width=213>0x80004003</td>
</tr>
<tr valign=top>
<td width=213>Invalid handle</td>
<td width=213><pre><code>E_HANDLE</code></pre>
</td>
<td width=213>0x80070006</td>
</tr>
<tr valign=top>
<td width=213>Operation aborted</td>
<td width=213><pre><code>E_ABORT</code></pre>
</td>
<td width=213>0x80004004</td>
</tr>
<tr valign=top>
<td width=213>Unspecified error</td>
<td width=213><pre><code>E_FAIL</code></pre>
</td>
<td width=213>0x80004005</td>
</tr>
<tr valign=top>
<td width=213>General access denied error</td>
<td width=213><pre><code>E_ACCESSDENIED</code></pre>
</td>
<td width=213>0x80070005</td>
</tr>
<tr valign=top>
<td width=213>Not implemented</td>
<td width=213><pre><code>E_NOTIMPL</code></pre>
</td>
<td width=213>0x80000001</td>
</tr>
<tr valign=top>
<td width=213>Unknown interface</td>
<td width=213><pre><code>DISP_E_UNKNOWNINTERFACE</code></pre>
</td>
<td width=213>0x80020001</td>
</tr>
<tr valign=top>
<td width=213>Member not found</td>
<td width=213><pre><code>DISP_E_MEMBERNOTFOUND</code></pre>
</td>
<td width=213>0x80020003</td>
</tr>
<tr valign=top>
<td width=213>Parameter not found</td>
<td width=213><pre><code>DISP_E_PARAMNOTFOUND</code></pre>
</td>
<td width=213>0x80020004</td>
</tr>
<tr valign=top>
<td width=213>Type mismatch</td>
<td width=213><pre><code>DISP_E_TYPEMISMATCH</code></pre>
</td>
<td width=213>0x80020005</td>
</tr>
<tr valign=top>
<td width=213>Unknown name</td>
<td width=213><pre><code>DISP_E_UNKNOWNNAME</code></pre>
</td>
<td width=213>0x80020006</td>
</tr>
<tr valign=top>
<td width=213>No named arguments</td>
<td width=213><pre><code>DISP_E_NONAMEDARGS</code></pre>
</td>
<td width=213>0x80020007</td>
</tr>
<tr valign=top>
<td width=213>Bad variable type</td>
<td width=213><pre><code>DISP_E_BADVARTYPE</code></pre>
</td>
<td width=213>0x80020008</td>
</tr>
<tr valign=top>
<td width=213>Exception occurred</td>
<td width=213><pre><code>DISP_E_EXCEPTION</code></pre>
</td>
<td width=213>0x80020009</td>
</tr>
<tr valign=top>
<td width=213>Out of present range</td>
<td width=213><pre><code>DISP_E_OVERFLOW</code></pre>
</td>
<td width=213>0x8002000A</td>
</tr>
<tr valign=top>
<td width=213>Invalid index</td>
<td width=213><pre><code>DISP_E_BADINDEX</code></pre>
</td>
<td width=213>0x8002000B</td>
</tr>
<tr valign=top>
<td width=213>Memory is locked</td>
<td width=213><pre><code>DISP_E_UNKNOWNLCID</code></pre>
</td>
<td width=213>0x8002000C</td>
</tr>
<tr valign=top>
<td width=213>Memory is locked</td>
<td width=213><pre><code>DISP_E_ARRAYISLOCKED</code></pre>
</td>
<td width=213>0x8002000D</td>
</tr>
<tr valign=top>
<td width=213>Invalid number of parameters</td>
<td width=213><pre><code>DISP_E_BADPARAMCOUNT</code></pre>
</td>
<td width=213>0x8002000E</td>
</tr>
<tr valign=top>
<td width=213>Parameter not optional</td>
<td width=213><pre><code>DISP_E_PARAMNOTOPTIONAL</code></pre>
</td>
<td width=213>0x8002000F</td>
</tr>
<tr valign=top>
<td width=213>Invalid callee</td>
<td width=213><pre><code>DISP_E_BADCALLEE</code></pre>
</td>
<td width=213>0x80020010</td>
</tr>
<tr valign=top>
<td width=213>Does not support a collection</td>
<td width=213><pre><code>DISP_E_NOTACOLLECTION</code></pre>
</td>
<td width=213>0x80020011</td>
</tr>
</table><br>
<p>
<b>Listing D: Further refining errors</b></p>
<pre>Try
<code>{</code>
<code>  SomeActiveXObject.Method();</code>
<code>}</code>
<code>Catch (com.ms.com.ComFailException ce)</code>
<code>{</code>
<code>  switch (ce.getHResult()</code>
<code>     {</code>
<code>  case E_UNEXPECTED:</code>
<code>  System.out.println(“Unexpected exception!”);</code>
<code>  break;</code>
<code>  case E_ E_NOTIMPL:</code>
<code>  System.out.println(“Method not implemented exception!”);</code>
<code>  break;</code>
<code>         // Other cases as required</code>
<code>         . . .</code>
<code>     }</code>
<code>}</code></pre>
<h3>Events</h3>
<p>
We've talked about creating objects, calling methods, and handling errors. But Java normally provides another feature: events. </p>
<p class=indent>
Note: Standard Visual J++ 1.1 doesn't support ActiveX events.</p>
<p>
As of this writing, Visual J++ 1.1 didn't support capturing and processing events. In order to correctly handle events, you need to download the Java SDK 2.0 (now in final release) from Microsoft's Web site at www.microsoft.com/java. The remainder of this article section assumes that you've downloaded and installed the Java SDK 2.0 final release. </p>
<p>
Earlier, we discussed which interface to use when accessing an ActiveX object. We also noted that another interface exists to support events. <b>Listing E</b> shows the portion of the ProdCon object description that deals with events. Let's see how to link a Java application to an ActiveX control for the purpose of capturing events.</p>
<p>
<b>Listing E: ProdCons events</b></p>
<pre>public interface prodcons/IProdConsEvents extends com.ms.com.IUnknown
<code>{</code>
<code>    public abstract void NewMessage();</code>
<code>}</code></pre>
<p>
As we previously mentioned, the IProdConsEvents interface defines the events that the ProdCons object produces—sharp eyes will have noticed that the one method this interface defines is abstract. Capturing events from an ActiveX object is a two-step process. First, the class that's going to intercept the events must implement the event interface, as defined in the summary.txt file. Second, the application must be connected to the object that generates the events. <b>Listing F</b> shows these steps in action.</p>
<p>
<b>Listing F: Steps to handing events</b></p>
<pre>import java.awt.*;
<code>import com.ms.com.*;</code>
<code>import prodcons.*;</code>

<code>class ProdCon implements </code>
<code>        IProdConsEvents,  </code>
<code>        // Step 1</code>
<code>        ActionListener</code>
<code>{</code>
<code>    IProdCons               iActiveX;</code>
<code>      // Used for step 2</code>
<code>    ConnectionPointCookie   eventconnector;</code>
<code>    . . .</code>
<code>    public void NewMessage()</code>
<code>    {</code>
<code>        // Do something when event fires</code>
<code>        . . .</code>
<code>    }</code>

<code>    public ProdCon()</code>
<code>    {</code>
<code>        . . .</code>

<code>        // Step 2 attach the objects together.</code>
<code>        try </code>
<code>        {</code>
<code>            eventconnector = </code>
<code>              new ConnectionPointCookie(</code>
<code>                 iActiveX,this, </code>
<code>                 Class.forName(</code>
<code>                 "prodcons.IProdConsEvents"));</code>
<code>        }</code>
<code>        catch (ClassNotFoundException e)</code>
<code>        {</code>
<code>            System.out.println(e);</code>
<code>            System.out.println(</code>
<code>              "Cannot catch prodcons events!");</code>
<code>            return;</code>
<code>        }</code>

<code>        . . .</code>
<code>    }</code>
<code>}</code></pre>
<p>
First we define the prodcon class as implementing the IProdConEvents interface. This interface requires that the NewMessage method be implemented. NewMessage events are fired whenever the SendMsg method is called. </p>
<p>
Next, we hook the applet and the control together using a ConnectionPointCookie object. This object takes three arguments: the event source, the event sink, and the connection interface. The <i>event source</i> is the class responsible for generating events. The <i>event sink</i> is the class responsible for consuming generated events. The <i>connection interface</i> is the class responsible for connecting the source to the sink. </p>
<p>
We create the first two arguments ourselves in the normal course of the application's development. However, we must force the third argument into existence. We can force a class to be loaded by using the forName static method of the java.lang.Class class. The forName static class method loads a class dynamically (and is often used to implement class loaders), then returns the loaded class or throws a ClassNotFoundException.</p>
<h3>Properties</h3>
<p>
ActiveX controls also have <i>properties</i>, which basically are public values that a user can manipulate to read and write on an object. Visual J++ doesn't provide a way to access a control's properties directly, but rather wraps each property in a get and set method. The ProdCon object exposes a property that was intentionally omitted from the prior interface description. Interested readers might want to load the ProdCon ActiveX project and see if they can determine what that property is. </p>
<h3>Control restrictions</h3>
<p>
It's important to understand the restrictions on using controls. Visual J++ has one major failing when it comes to using ActiveX controls: Any control created within a Java applet or application must be <i>non-visual</i>. In a future article, we'll discuss how to create simple non-visual controls with Visual C++. For now, suffice to say that you can't create visual controls within a Java application. </p>
<p>
However, all is not lost! You still can use a visual control <i>from</i> Java—you simply can't create it from within a Java applet. Instead, you must create the control on your Web page, then pass it into your Java applet via one of the applet's exposed methods. The focus of this article is using controls, but next month we'll look at the mechanics of, among other things, creating controls on your Web page for use in Java applications.</p>
<h3>Security (trusted vs. untrusted)</h3>
<p>
Finally, we must mention security. ActiveX uses the <i>keys to the castle</i> model of security, meaning that once you've installed a control on your machine, it can do what <i>any</i> application can do. Next month, we'll look more closely at security and how to create ActiveX controls, load them into cab files, then digitally sign the files for download. </p>
<h3>Conclusion</h3>
<p>
ActiveX technology has its quirks. However, it expands Java's potential immensely, opening areas that were previously unavailable to developers. Among other things, you can now take advantage of a huge number of commercial controls, many of which you can embed and control from within your Java applets. As we'll discuss next month, creating your own ActiveX controls and packaging them for distribution, while not trivial, is easily accomplished. So dust off those controls you mothballed when you started developing in Java—they can ride again!</p>
<p>
___________________________</p>
<p>
<b>Al Saganich</b> is an independent software consultant, currently under contract to Digital Equipment Corporation. He's co-author of the best-selling <i>Microsoft Visual J++ 1.1 SOURCEBOOK</i> and is working on the next release of <i>Java 1.2 for C/C++ Programmers</i>, both published by J. Wiley and Sons. You can reach Al at <b>asaganich@aol.com</b>.</p>
<p>
___________________________</p>
<p>
This article is reproduced from the February 1998 issue of <i>Visual J++ Developer's</i> <b><i>Journal</i>. </b><i>Visual J++ Developer's</i> <b><i>Journal</i></b> is an independently produced publication of The Cobb Group. No part of this article may be used or reproduced in any fashion (except in brief quotations used in critical articles and reviews) without prior consent of The Cobb Group. To contact The Cobb Group, please call (800) 223-8720 or (502) 493-3200.</p>
<p>
Copyright © 1998 The Cobb Group, a division of Ziff-Davis Inc. The Cobb Group and The Cobb Group logo are trademarks of Ziff-Davis Inc. All rights reserved. Reproduction in whole or in part in any form or medium without express written permission of Ziff-Davis is prohibited. </p>
</font></BODY>
</HTML>
