<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Building External Objects with Visual Basic </title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<Font face="verdana,arial,helvetica" size="2">
<h1><a name="buildingexternalobjectswithvisualbasic"></a>Building External Objects with Visual Basic </h1>
<p class=indent>
by Michael C. Amundsen</p>
<p>
In <i>Inside Visual Basic's</i> December 1997 articles “Classy Development” and “Come Fly the Friendly Skies of Visual Basic 5.0,” we discussed object-oriented development and how you can build standalone classes for use in your development work. This approach involves designing and building complete, compiled external objects and using those objects as the building blocks for your applications. </p>
<p>
In this article, we’ll continue discussing class development. Specifically, we’ll show you how to create an object that writes data to text files. (The article “Using External Objects with Visual Basic” [<i>Inside Visual Basic</i>, January 1998] covers techniques for making use of the object you’ll design and build here.)</p>
<h3>Creating compiled building blocks</h3>
<p>
Creating a set of reusable component objects is much more powerful than writing source code libraries for a couple of reasons. First, source code libraries are tied to a single language, such as VB, VC++, or J++. In fact, source code libraries are sometimes tied to a particular <i>version</i> of the language. Compiled components don’t suffer a single-language limit. You can use the external objects you build with VB in several development environments, including VC++, J++, Access, Excel, and other Office 97 applications.</p>
<p>
Passing out source code also creates management problems. It’s all too easy for programmers to alter the source code to fit specific needs—and even unintentional changes can render the object useless for another programmer. By passing out only the compiled component, others can’t alter the object in any way, either accidentally or on purpose.</p>
<p>
Although the process of designing, coding, and testing your building blocks takes time, the real advantage of creating compiled building blocks comes when it’s time to build a complete application. Once you’ve built a set of objects, creating a custom solution for customers (internal or external) is much quicker and less error-prone. The time invested in building these objects can pay back in big ways after just a few uses of the component in a production application.</p>
<h3>Object, please</h3>
<p>
Let’s say you’ve been asked to build a set of routines that allow programmers to easily create log file entries in a disk file. This set of routines should be simple to use and very portable. It should meet a number of general needs:</p>
<p>
You can use it to get basic user input and write it to a disk file.</p>
<p>
You can use it to log user actions in a secure application (log in/out, etc.)</p>
<p>
You can use it as an error log for applications.</p>
<p>
You can use it to create a log of unattended operations for applications.</p>
<p>
In addition, programmers should easily be able to add these routines to existing programs or access them from programs without the need to incorporate source code directly into their applications. Finally, the routines should be flexible enough that programmers can create their own dialogs and interfaces to the routines.</p>
<h3>Designing the TextFile object</h3>
<p>
The first step in designing an object is to clearly identify the actions needed to complete the task. Then, you must identify all the materials needed to perform those actions. Armed with this information, you can design an object with all the necessary methods and properties.</p>
<p>
To start, let’s call our object the TextFile object. Programmers will use this object to write data to a disk file. Although we only want a method to write data to the disk file, we’ll need a few other methods in order to complete the task. Table A lists the methods required for the TextFile object.</p>
<p>
<b>Table A: Methods for the TextFile object</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=140><b>Method</b></td>
<td class=blue width=72><b>Public</b></td>
<td class=blue width=464><b>Description</b></td>
</tr>
<tr valign=top>
<td width=140>OpenFile</td>
<td width=72>No</td>
<td width=464>Opens the disk file for write access.</td>
</tr>
<tr valign=top>
<td width=140>CloseFile</td>
<td width=72>Yes</td>
<td width=464>Closes the disk file after all writing is complete.</td>
</tr>
<tr valign=top>
<td width=140>WriteLine</td>
<td width=72>Yes</td>
<td width=464>Writes a line of text to the open disk file.</td>
</tr>
<tr valign=top>
<td width=140>CheckChar</td>
<td width=72>No</td>
<td width=464>Checks for invalid characters in filename.</td>
</tr>
<tr valign=top>
<td width=140>MakeFullFileName</td>
<td width=72>No</td>
<td width=464>Ensures that a complete filename, including folder, body name, and file tail, is created.</td>
</tr>
</table><br>
<p>
You’ll notice that of the five methods in Table A, the only two marked Public are CloseFile and WriteLine. These are the only two methods available for others to use. The other three methods (OpenFile, CheckChar, and MakeFullFileName) are internal routines that won’t be published.</p>
<p>
Next, you must define the materials needed to complete the actions—these are the properties of the TextFile object. Table B shows the suggested property list for our example.</p>
<p>
<b>Table B: Properties for the TextFile object</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=blue width=104><b>Property</b></td>
<td class=blue width=72><b>Public</b></td>
<td class=blue width=78><b>RW/RO</b></td>
<td class=blue width=422><b>Description</b></td>
</tr>
<tr valign=top>
<td width=104>FileFolder</td>
<td width=72>Yes</td>
<td width=78>RW</td>
<td width=422>Contains computer, drive, and path of disk file (i.e., <i>C:\MYFOLDER</i>).</td>
</tr>
<tr valign=top>
<td width=104>FileName</td>
<td width=72>Yes</td>
<td width=78>RW</td>
<td width=422>Contains name of disk file (i.e., <i>LOGFILE</i>).</td>
</tr>
<tr valign=top>
<td width=104>FileTail</td>
<td width=72>Yes</td>
<td width=78>RW</td>
<td width=422>Contains file tail of the disk file (i.e., <i>TXT</i>).</td>
</tr>
<tr valign=top>
<td width=104>FileMode</td>
<td width=72>Yes</td>
<td width=78>RW</td>
<td width=422>Contains value to determine if file writes will overwrite or append to existing file.</td>
</tr>
<tr valign=top>
<td width=104>FullFileName</td>
<td width=72>Yes</td>
<td width=78>RO</td>
<td width=422>Contains complete name of target disk file (i.e., <i>C:\MYFOLDER\LOGFILE.TXT</i>).</td>
</tr>
</table><br>
<p>
Of the five properties defined in Table B, only one is read-only (RO). This read-only property can be seen by other users, but not altered. It’s common for objects to have one or more read-only properties.</p>
<p>
Now that we’ve discussed all the actions and materials needed to complete the TextFile object task, it’s time to use Visual Basic to create the required object. (You can download our sample files from <b>www.cobb.com/ivb</b>, as part of the file jan98.zip. Just click the Source Code hyperlink.)</p>
<h3>Coding the TextFile object</h3>
<p>
In order to get the most use out of the TextFile object, you must create a standalone DLL. You can do this using Visual Basic 5.0 or Visual Basic 4.0-32. If you’re using Visual Basic 4.0-16, you can still complete this project by creating an OLE EXE module. (The example in this article was built using Visual Basic 5.0.)</p>
<p>
The first step in building the TextFile object is to create a new Visual Basic project. If you’re using Visual Basic 5.0, start Visual Basic and select ActiveX DLL as the project type. You’re now ready to begin adding code to the class module, so skip the next paragraph.</p>
<p>
If you’re using Visual Basic 4.0 (32 or 16 bit), start Visual Basic, remove the default form, and add a BAS Module to the project by selecting Module from the Insert menu. Enter a single subroutine in this BAS module called Main, as follows: </p>
<pre><code>Public Sub Main()

End Sub</code></pre>
<p>
Don’t add any code to this routine. It only exists to make sure Windows executes the DLL/EXE and registers its class object for use by others. Next, add a class module to the project (Select Insert | Class Module).</p>
<p>
Now, set the Name property of the class module to <i>TextFile</i>. If you’re using Visual Basic 5.0, set the Instancing property to 5 - MultiUse. If you’re using Visual Basic 4.0, set the Public property to True and the Instancing property to 2 - Creatable MultiUse. This step guarantees that others can create their own copies of the TextFile object.</p>
<p>
Next, set the name of the project. If you’re using Visual Basic 5.0, highlight the project in the Project Window, and set the Name property to <i>prjTextFile</i>. If you’re using Visual Basic 4.0, select Tools | Options | Project, and set the Project Name to <i>prjTextFile</i>.</p>
<p>
Please note: It’s <i>very </i>important that you set the Class Name and Project Name properties correctly. All programmers who want to access your object methods and properties will use these two properties.</p>
<p>
You’re now ready to add code to the project. First, you must create some local storage space to hold the values of the published properties of the object. To do so, add the code in section 1 of Listing A to the General Declarations section of the class module.</p>
<p>
<b>Listing A: TextFile external object</b></p>
<p>
<b>Section 1</b></p>
<pre>Option Explicit

<code>'</code>
<code>' define local storage for properties</code>
<code>Private mstrFileName As String</code>
<code>Private mstrFileFolder As String</code>
<code>Private mstrFileTail As String</code>
<code>Private mstrFullFileName As String</code>
<code>'</code>
<code>' for vb5 only</code>
<code>' create enumerated type</code>
<code>Enum tfFileMode</code>
<code>    overwrite = 0</code>
<code>    append = 1</code>
<code>End Enum</code>
<code>Private mtfMode As tfFileMode</code>

<code>' for vb4 only</code>
<code>'Private Const overwrite = 0</code>
<code>'Private Const append = 1</code>
<code>'Private mtfMode As Integer</code>

<code>'</code>
<code>' define private vars</code>
<code>Private mintFileChannel As Integer</code>
</pre>
<p>
<b>Section 2</b></p>
<pre>Private Sub Class_Initialize()
<code>    '</code>
<code>    ' set initial values</code>
<code>    '</code>
<code>    mstrFileName = "logfile"</code>
<code>    mstrFileFolder = App.Path</code>
<code>    mstrFileTail = "txt"</code>
<code>    MakeFullFileName</code>
<code>    '</code>
<code>    mintFileChannel = -1</code>
<code>    mtfMode = append</code>
<code>    '</code>
<code>End Sub</code>
</pre>
<p>
<b>Section 3</b></p>
<pre>Private Sub MakeFullFileName()
<code>    '</code>
<code>    ' build full filename</code>
<code>    '</code>
<code>    mstrFullFileName = mstrFileFolder &amp; "\" &amp; _
mstrFileName &amp; "." &amp; mstrFileTail</code>
<code>    '</code>
<code>End Sub</code>
</pre>
<p>
<b>Section 4</b></p>
<pre>Private Function CheckChar(strTemp As String, 
strInvalid As String) As Boolean
<code>    '</code>
<code>    ' check for invalid filechars</code>
<code>    '</code>
<code>    Dim intLoop As Integer</code>
<code>    Dim intLen As Integer</code>
<code>    Dim strChar As String</code>
<code>    '</code>
<code>    strTemp = Trim(strTemp)</code>
<code>    intLen = Len(strTemp)</code>
<code>    '</code>
<code>    For intLoop = 1 To intLen</code>
<code>        strChar = Mid(strTemp, intLoop, 1)</code>
<code>        If InStr(strInvalid, strChar) &lt;&gt; 0 Then</code>
<code>            CheckChar = True</code>
<code>            Exit Function</code>
<code>        End If</code>
<code>    Next</code>
<code>    '</code>
<code>    CheckChar = False</code>
<code>    '</code>
<code>End Function</code>
</pre>
<p>
<b>Section 5</b></p>
<pre>Private Sub OpenFile()
<code>    '</code>
<code>    ' open file for output</code>
<code>    '</code>
<code>    On Error GoTo OpenFileErr</code>
<code>    '</code>
<code>    mintFileChannel = FreeFile</code>
<code>    '</code>
<code>    If mtfMode = append Then</code>
<code>        Open mstrFullFileName For Append As
 mintFileChannel</code>
<code>    End If</code>
<code>    '</code>
<code>    If mtfMode = overwrite Then</code>
<code>        Open mstrFullFileName For Output As 
mintFileChannel</code>
<code>    End If</code>
<code>    '</code>
<code>    Exit Sub</code>
<code>    '</code>
<code>OpenFileErr:</code>
<code>    Err.Raise Err.Number, App.EXEName &amp; 
"_OpenFile", Err.Description</code>
<code>    '</code>
<code>End Sub</code>
</pre>
<p>
<b>Section 6</b></p>
<pre>Public Sub WriteLine(strLine As String)
<code>    '</code>
<code>    ' write line to output file</code>
<code>    '</code>
<code>    On Error GoTo WriteLineErr</code>
<code>    '</code>
<code>    If mintFileChannel = -1 Then</code>
<code>        OpenFile</code>
<code>    End If</code>
<code>    '</code>
<code>    Print #mintFileChannel, strLine</code>
<code>    '</code>
<code>    Exit Sub</code>
<code>    '</code>
<code>WriteLineErr:</code>
<code>    Err.Raise Err.Number, App.EXEName &amp; 
"_WriteLine", Err.Description</code>
<code>    '</code>
<code>End Sub</code>
</pre>
<p>
<b>Section 7</b></p>
<pre>Public Sub CloseFile()
<code>    '</code>
<code>    ' close open channel</code>
<code>    '</code>
<code>    On Error Resume Next</code>
<code>    '</code>
<code>    Close #mintFileChannel</code>
<code>    mintFileChannel = -1</code>
<code>    '</code>
<code>End Sub</code>
</pre>
<p>
<b>Section 8</b></p>
<pre>Public Property Get FileName() As String
<code>    '</code>
<code>    FileName = mstrFileName</code>
<code>    '</code>
<code>End Property</code>
</pre>
<p>
<b>Section 9</b></p>
<pre>Public Property Let FileName(ByVal vNewValue As String)
<code>    '</code>
<code>    vNewValue = Trim(vNewValue)</code>
<code>    If CheckChar(vNewValue, "`!@^*:;'&lt;&gt;,.?/\|") 
Then</code>
<code>        Err.Raise 380 ' invalid property</code>
<code>    Else</code>
<code>        mstrFileName = vNewValue</code>
<code>        MakeFullFileName</code>
<code>    End If</code>
<code>    '</code>
<code>End Property</code></pre>
<p>
<b>Section 10</b></p>
<pre>Public Property Get FileTail() As String
<code>    '</code>
<code>    FileTail = mstrFileTail</code>
<code>    '</code>
<code>End Property</code>

<code>Public Property Let FileTail(ByVal vNewValue As 
String)</code>
<code>    '</code>
<code>    vNewValue = Trim(vNewValue)</code>
<code>    If CheckChar(vNewValue, "`!@^*:;'&lt;&gt;,.?/\|") 
Then</code>
<code>        Err.Raise 380 ' invalid property</code>
<code>    Else</code>
<code>        mstrFileTail = vNewValue</code>
<code>        MakeFullFileName</code>
<code>    End If</code>
<code>    '</code>
<code>End Property</code>
</pre>
<p>
<b>Section 11</b></p>
<pre>Public Property Get FileFolder() As String
<code>    '</code>
<code>    FileFolder = mstrFileFolder</code>
<code>    '</code>
<code>End Property</code>

<code>Public Property Let FileFolder(ByVal vNewValue As 
String)</code>
<code>    '</code>
<code>    vNewValue = Trim(vNewValue)</code>
<code>    If CheckChar(vNewValue, "`!@^*;'&lt;&gt;,.?/|") Then
        Err.Raise 380 ' invalid property</code>
<code>    Else</code>
<code>        If Right(mstrFileFolder, 1) &lt;&gt; "\" Then
            mstrFileFolder = mstrFileFolder &amp; "\"</code>
<code>        End If</code>
<code>        mstrFileFolder = vNewValue</code>
<code>        MakeFullFileName</code>
<code>    End If</code>
<code>    '</code>
<code>End Property</code>
</pre>
<p>
<b>Section 12</b></p>
<pre>Public Property Get FullFileName() As String
<code>    '</code>
<code>    FullFileName = mstrFullFileName</code>
<code>    '</code>
<code>End Property</code>

<code>Public Property Let FullFileName(ByVal vNewValue 
As String)</code>
<code>    '</code>
<code>    Err.Raise 383 ' read-only msg</code>
<code>    '</code>
<code>End Property</code>
</pre>
<p>
<b>Section 13</b></p>
<pre>Public Property Get FileMode() As tfFileMode
<code>'Public Property Get FileMode() As Integer ' vb4</code>
<code>FileMode = mtfMode</code>
<code>    '</code>
<code>End Property</code>

Public Property Let FileMode(ByVal vNewValue As 
tfFileMode)
<code>'Public Property Let FileMode(ByVal vNewValue As 
Integer) ' vb4</code>
<code>    '</code>
<code>    If vNewValue = append Then</code>
<code>        mtfMode = append</code>
<code>        Exit Property</code>
<code>    End If</code>
<code>    '</code>
<code>    If vNewValue = overwrite Then</code>
<code>        mtfMode = overwrite</code>
<code>        Exit Property</code>
<code>    End If</code>
<code>    '</code>
<code>    Err.Raise 380 ' invalid property value</code>
<code>    '</code>
<code>End Property</code></pre>
<p>
<b>Section 14</b></p>
<pre>Private Sub Class_Terminate()
<code>    '</code>
<code>    CloseFile</code>
<code>    '</code>
<code>End Sub</code></pre>
<p>
In the first section of code, you can see that, along with the four string variables, we used an Enum to create an enumerated data type. This is a custom data type that we’ll use to define the file mode (overwrite or append). The Enum is only available in Visual Basic 5.0. If you’re using Visual Basic 4.0, use the constants that are commented out. You should also note that we defined a private variable to use as the file channel pointer for the actual disk write operation (mintFileChannel).</p>
<p>
Next, you need to add code to the Class_Initialize event to set the default values for your object properties. It’s always a good idea to set defaults for your properties. Add the code from section 2 to the Class_Initialize event.</p>
<p>
You can see that the internal file pointer is set to -1. This is an invalid value for file pointers. You can use this value as a flag to let you know that the file pointer hasn’t yet been set.</p>
<h3>Coding the TextFile support methods</h3>
<p>
The TextFile object has three support methods: CheckChar, MakeFullFileName, and OpenFile. These are internal routines that handle some of the behind-the-scenes work within the object. Although these routines are necessary, you probably don’t want to allow other users to access this code. For this reason, make all three of these routines Private rather than Public.</p>
<p>
First, add the MakeFullFileName method to your class. If you’re using Visual Basic 5.0, select Tools | Add Procedure. If you’re using Visual Basic 4.0, select Insert | Procedure. Then, type <i>MakeFullFileName</i> in the Name box. Set the Type to Sub and the Scope to Private. Now, add the code from section 3 to the MakeFullFileName subroutine.</p>
<p>
You can see this method just concatenates the stored file folder, filename, and file tail values into a single variable. This is the variable that we’ll use to open the disk file.</p>
<p>
Next, add the CheckChar method to the class. This method takes two parameters: the string to check and a list of characters to look for. If at least one of those characters is in the string, the routine returns true. You’ll use this routine to check for invalid characters in the folder, file, and tail properties. Add the CheckChar function to your class and enter the code from section 4.</p>
<p>
Finally, add the OpenFile method to the class. This routine will be called from within the public WriteLine method. Other users will never get access to this method. Add the OpenFile subroutine to your class and enter the code from section 5.</p>
<p>
There are two points of interest in the OpenFile method. First, note the use of If statements to check the value of tfMode. This value determines whether the file will be overwritten each time or appended. Also notice the use of the Err.Raise method in the error trap. The Err.Raise method will send an error report back to the calling program instead of popping up a dialog box. It’s very important that all objects that have no interface return error reports, not dialogs.</p>
<h3>Coding the TextFile public methods</h3>
<p>
Now you’re ready to add the two public methods, WriteLine and CloseFile, to the object. These two methods will be available to others to use. First, add the WriteLine method to the class object. Be sure to set the Scope to Public. Then add the code from section 6 to the WriteLine method. Please note that the WriteLine method first checks to see if the file has been opened. If not, it calls OpenFile.</p>
<p>
Next, add the CloseFile method from section 7 to the object. This routine simply closes out the file when requested. As you can see, the file channel pointer is reset to -1 at this time in case the user tries to perform a WriteLine after executing the FileClose method. After adding the object methods, you’re ready to add the object properties.</p>
<h3>Adding the object properties</h3>
<p>
There are five TextFile object properties defined in Table B. Properties are a way to give others controlled access to your local storage space. Two methods are actually used: The Let method allows users to send you data to store, and the Get method allows users to get a copy of your stored data. To build a complete property interface for your object, you must add a Let and a Get method for each property in your object. </p>
<p>
Luckily, Visual Basic provides an easy way to do this. If you’re using Visual Basic 5, select Tools | Add Procedure. If you’re using Visual Basic 4.0, select Insert | Procedure. Then, enter <i>FileName</i> in the Name box. Be sure to select Property as the Type and Public as the Scope before you press the OK button. You’ll see that this creates both the Let and the Get methods for your property.</p>
<p>
You can now add code to each method. Since the Get method lets users get a copy of your stored data, all you need to do is write code that copies your local memory variable back to the user. Section 8 shows how to do this. Notice that we changed the return type from Variant to String in order to match the local storage type.</p>
<p>
Now you’re ready to code the Let method. Others will use this method to send you data to store. The real advantage of the Let method is that you can write code to check the values received before you store them. This gives you a chance to send an error message back to the user, if necessary. Section 9 shows the code for the FileName Let method. </p>
<p>
Notice the error checking and reporting. After the CheckChar() method is called and if it returns true, the Err.Raise method is invoked using an existing error number. Visual Basic reports error number 380 when a property setting is invalid. It’s always a good idea to re-use existing Visual Basic errors for the same errors in your objects. Doing so will give users a familiar feedback and makes it easier for them to write error-handling code for your objects. Also, note that after the new property is accepted, the MakeFullFileName method is called to update the disk filename to use in all write actions.</p>
<p>
The Property Let and Get statements for the other properties are almost identical. The Get statements simply echo the storage value and the Let statements perform the same error-checking before finally storing the received data in a local storage variable. Next, create the FileTail property and add the code from section 10 to the Property Let and Property Get methods.</p>
<p>
The FileFolder property has a slight variance. Since the folder names can contain slashes and semicolons, the list of invalid chars is altered to fit folder names. Add the FileFolder property and enter the code from section 11.</p>
<p>
The next property to build is the FullFileName property. This property is marked as read-only (RO) in Table B. You want to allow users to perform the Get operation, but not the Let operation. Create the FullFileName property and add the code from section 12.</p>
<p>
The final property to build is the FileMode property. If you’re using Visual Basic 5.0, you’ll be creating a property of the type tfFileMode. If you’re using Visual Basic 4.0, make the property type Integer. Section 13 has the code for the Property Let and Get methods. That’s the end of the properties for the TextFile object.</p>
<h3>One final touch</h3>
<p>
There’s one more method you must add to the TextFile object: the Class_Terminate event. This event fires each time the object is destroyed. This is a good place to add code to clean up any unfinished business, close open files, etc. Section 14 has the code for the Class_Terminate event.</p>
<p>
You can see that the only thing that occurs here is a call to the CloseFile method. This will ensure that the data is properly flushed to the disk and that the file is safely closed.</p>
<h3>Compiling the object</h3>
<p>
Now that you’ve completed the coding, you’re ready to compile the object into a usable module. If you’re using Visual Basic 5.0 or Visual Basic 4.0-32, you’ll create a DLL. If you’re using Visual Basic 4.0, you’ll create a special kind of EXE called an OLE Server EXE.</p>
<p>
Usually, you should test your object before compiling for the final time. Testing the object is quite different with Visual Basic 4.0 or Visual Basic 5.0. For this reason, we’ll skip the details of testing right now. The article “Using External Objects with Visual Basic” [<i>Inside Visual Basic</i>, January 1998] shows you how to test your object.</p>
<p>
If you’re using Visual Basic 5.0, select File | Make prjTextFile DLL… to build the DLL. If you’re using Visual Basic 4.0-32, select File | Make OLE DLL. If you’re using Visual Basic 4.0-16, select File | Make EXE. This will build the final product that other programmers can use. Remember that the Visual Basic 4.0-16 version will create an EXE, while the 32-bit versions of Visual Basic will create a DLL.</p>
<p>
You can use this final compiled object not only within other Visual Basic applications, but also from Access, Excel, and other Office 97 applications. </p>
<p>
<b>Michael C. Amundsen</b> keeps busy writing and working as an IS consultant specializing in systems analysis and design. He co-authored Teach Yourself Database Programming with Visual Basic in 21 Days with Curt Smith and was a contributing author for Visual Basic 4 Unleashed. When Mike isn’t traveling to client sites or writing, he spends time with his family in Kentucky. You can reach Mike via CompuServe at <b>102641,1267</b> or on the Internet at MikeAmundsen@msn.com.</p>
<p>
Copyright © 1998 The Cobb Group, a division of Ziff-Davis Inc. The Cobb Group and The Cobb Group logo are trademarks of Ziff-Davis Inc. All rights reserved. Reproduction in whole or in part in any form or medium without express written permission of Ziff-Davis is prohibited.</p>
</font></BODY>
</HTML>
