<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Data Navigation Sample</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="vjhowdatanavigationsample"></a>Data Navigation Sample</h1>
<p>
This sample extends the <a href="vjjado_8lph.htm">framework code</a> to demonstrate the capabilities of metadata examination of Recordsets. Since ADO/WFC’s Field objects contain both metadata and field values, the metadata for a given Field may be accessed from any position within the Recordset. There is no requirement, as in JDBC, for separate DatabaseMetadata or ResultsetMetadata-style objects. The metadata is always available. </p>
<p>
The following code shows the procedure for extracting basic metadata information from the Fields collection of a Recordset, after the Recordset has been opened and populated.</p>
<pre><code>public boolean run()
{
 &nbsp; Recordset rs = new Recordset();
 &nbsp; rs.setCursorType (AdoEnums.adOpenStatic);
 &nbsp; rs.setCursorLocation (AdoEnums.adUseClientBatch);
 &nbsp; rs.setLockType (AdoEnums.adLockBatchOptimistic);
 &nbsp; rs.open("select * from authors", 
 &nbsp;&nbsp;&nbsp; "server=aServer;driver=sql server;uid=aUID;pwd=aPWD;database=pubs");

 &nbsp; rs.moveFirst();
 &nbsp; 
 &nbsp; Fields fields = rs.getFields();
 &nbsp; int cFields = fields.getCount();

 &nbsp; for( int iField = 0; iField &lt; cFields; iField++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; useField( fields.getItem( iField ) );
 &nbsp; }

 &nbsp; for( int iField = 0; iField &lt; cFields; iField++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.print( fields.getItem( iField ).getName() + "\t" );
 &nbsp; }
 &nbsp; System.out.println("");

 &nbsp; rs.moveFirst();
 &nbsp; while( !rs.getEOF() )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; for( int iField = 0; iField &lt; cFields; iField++ )
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print( getString( fields.getItem( iField ) ) + "\t" );
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("");

 &nbsp;&nbsp;&nbsp;&nbsp; rs.moveNext();
 &nbsp; }

 &nbsp; rs.close();
 &nbsp; rs.release();
 &nbsp; return true;
}

String getString (Field fld)
{
 &nbsp; if (fld.isNull())
 &nbsp;&nbsp;&nbsp;&nbsp; return "NULL";
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return fld.getObject().toString();
}

void useField (Field fld)
{
 &nbsp; AdoProperties props = fld.getProperties();
 &nbsp; int cProps = props.getCount();
 &nbsp; for( int iProp = 0; iProp &lt; cProps; iProp++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; AdoProperty p = props.getItem( iProp );
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("[" + p.getName() + " = " + p.getString() + "]");
 &nbsp; }

 &nbsp; System.out.println ("ActualSize = " + fld.getActualSize());
 &nbsp; System.out.println ("Attributes = " + fld.getAttributes());
 &nbsp; System.out.println ("DefinedSize = " + fld.getDefinedSize());
 &nbsp; System.out.println ("Name = " + fld.getName());
 &nbsp; System.out.println ("Type = " + fld.getType());
 &nbsp; System.out.println ("Precision = " + fld.getPrecision());
 &nbsp; System.out.println ("NumericScale = " + fld.getNumericScale());

}
</code></pre>
<p>
This sample begins by using the basic ADO/WFC constants to configure the Recordset’s properties prior to opening the cursor:</p>
<pre><code>rs.setCursorType (AdoEnums.adOpenStatic);
rs.setCursorLocation (AdoEnums.adUseClientBatch);
rs.setLockType (AdoEnums.adLockBatchOptimistic);
</code></pre>
<p>
The Recordset is now ready to execute the query. After populating the client-side, batch-mode cursor, the application extracts the Fields collection, which contains the navigation mechanism for accessing individual row data values, as well as the Field metadata. The Fields collection provides a method for determining the number of Field objects it contains. This varies with the “shape” of the Recordset. Having established the dimension or shape of the Recordset, the application proceeds to extract the AdoProperty objects associated with each Field.</p>
<p>
The <code>useField</code> method is the heart of the sample. This method retrieves the values of each AdoProperty of the Field, which are then written to the System console window. The code prints the core AdoProperties for Field objects: actual size, name, data type, precision, and numeric scale. The <code>useField</code> method demonstrates how you can easily access the metadata of a Recordset. </p>
<p>
Having displayed the Recordset’s metadata, displaying the data values in each row is a simple matter of iterating over the Recordset from the first row until <code>recordset.EOF</code> is encountered:</p>
<pre><code>rs.moveFirst();
while( !rs.getEOF() )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; for( int iField = 0; iField &lt; cFields; iField++ )
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print( getString( fields.getItem( iField ) ) + "\t");
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("");

 &nbsp;&nbsp;&nbsp;&nbsp; rs.moveNext();
 &nbsp; }
</code></pre>
<p>
Each Field in the given row is traversed and the row is accessed with the <code>getItem</code> accessor method. The value is then converted to a String object and written to the System console window. When the end of the current row is reached, the Recordset position is advanced to the next row by the <code>moveNext</code> method. The process repeats until the end of the Recordset is reached, and the program then terminates normally.</p>
</font></BODY>
</HTML>
