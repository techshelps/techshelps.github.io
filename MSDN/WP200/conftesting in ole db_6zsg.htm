<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Conformance Testing in OLE DB 2.0</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="conformancetestingoledb20"></a>Conformance Testing in OLE DB 2.0 </h1>
<p>
This paper has four sections:
<ul type=disc>
<li>
Introduction<br><br></li>
<li>
Building and running the OLE DB interface tests<br><br></li>
<li>
Using the TableDump utility to generate initialization files<br><br></li>
<li>
Building and running the ADO minimal tests</li>
</ul>
<h1>Introduction</h1>
<p>
The purpose of the conformance tests is to encourage developers to write good, compliant OLE DB providers.</p>
<p>
The conformance tests help provider writers confirm that their implementations match the OLE DB specification. Having a common set of tests also encourages consistent behavior across providers.</p>
<p>
Comprehensive testing of any OLE DB provider includes many tasks:
<ul type=disc>
<li>
Interface tests<br><br></li>
<li>
Tests for provider-specific behavior<br><br></li>
<li>
Stress tests<br><br></li>
<li>
Performance tests<br><br></li>
<li>
Multiuser testing<br><br></li>
<li>
Application tests (using the provider to build applications)<br><br></li>
<li>
Testing with a variety of consumers</li>
</ul>
<p>
The conformance tests contribute to the first task (OLE DB interface testing) and to the last task (consumer testing, through ADO). They are not intended to address any other tasks in this list.</p>
<p>
The conformance tests are meant to supplement a provider writer’s own testing, not to replace it.</p>
<p>
They include test variations for normal usage, as well as some error and boundary cases. They do not check performance, stress scenarios, low-resource conditions, multiuser cases, or provider-specific behavior. </p>
<p>
The conformance tests check usage of individual OLE DB interfaces and ADO methods. They do not check application scenarios.</p>
<p>
There are three stages in the life cycle of conformance tests: <i>unsupported</i>, <i>proposed</i>, and <i>approved</i>. </p>
<p>
Unsupported tests are provided only as examples. They were originally designed to work with the OLE DB Provider for ODBC Drivers, and may not work correctly with other providers. </p>
<p>
Proposed tests have been updated to work with a wide range of providers — for example, read-write, read-only, SQL, and non-SQL. After broader exposure, they will move to “approved” category. Microsoft&nbsp; plans to provide web links for providers who pass the approved tests. Other incentives may be used in the future. They are made available now so provider teams can use them to test their providers. </p>
<p>
Two sets of conformance tests are included in the Data Access SDK version 2.0: <i>OLE DB interface tests</i> and <i>ADO minimal tests</i>.</p>
<p>
The OLE DB interface tests check compliance to standards in the <i>OLE DB Programmer’s Reference</i>. There is at least one test module per OLE DB interface. The tests are grouped into levels, corresponding to the OLE DB interface levels. </p>
<p>
OLE DB leveling identifies the critical interfaces and behaviors (properties) required for providers and expected by consumers. If you are unfamiliar with OLE DB leveling, see <a href="oledbleveling_2lev.htm">OLE DB Leveling</a> in this collection of technical articles.</p>
<p>
The OLE DB interface tests were originally written to test theMicrosoft OLE DB Provider for ODBC Drivers, which is also included in this SDK. The first set of tests (for the level 0/minimum provider interfaces) has been modified to handle a wide range of providers, and has been moved from Unsupported to Proposed.</p>
<p>
In Data Access SDK version 2.0, only the level 0 (minimum) interface tests are supported. Tests for the other interfaces are still available in the Unsupported subdirectory. In future releases, more interface tests will be improved to support generic providers, and will be moved from Unsupported to Proposed.</p>
<p>
The ADO minimal tests are a small set of tests, at least one per ADO method, which check that ADO statements work correctly against a provider. These tests act as a “sanity” check that ADO applications should work with that provider. There are tests for each ADO method, including methods used for updates and for transactions. The tests are grouped so that you can run just the level 0 tests, which do not require updatability or transactions; or you can run the full set of ADO tests.</p>
<p>
Both the OLE DB and ADO tests use Table Dump generated files to identify provider-specific information, and to handle provider variations (such as read-only versus read-write, SQL versus non-SQL). The TableDump utility generates initialization files needed by the tests. This utility can be found in the Tools subdirectory.</p>
<p class=label>
<b>Conformance directory structure:</b></p>
<p>
Conformance</p>
<p class=indent>
Include</p>
<p class=indent>
Lib</p>
<p class=indent>
Tests</p>
<p class=indent>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proposed</p>
<p class=indent>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unsupported</p>
<p class=indent>
Tools</p>
<p class=indent>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADOPriv</p>
<p class=indent>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrivLib</p>
<p class=indent>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TableDump</p>
<h1>Section 2: Building and Running the OLE DB Conformance Tests</h1>
<h1>OLE DB Level 0 Conformance Tests</h1>
<p>
There is at least one level 0 test module for each level 0 interface, plus one test module for Data Coercion, and one test module for simple threading cases. In total there are 19 level 0 tests. The names of these tests are abbreviated forms of the interface names.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Name of file</b></td>
<td class=label width=50%><b>Interface tested</b></td>
</tr>
<tr valign=top>
<td width=50%>IACCESSR</td>
<td width=50%>IAccessor</td>
</tr>
<tr valign=top>
<td width=50%>ICLSFACT</td>
<td width=50%>IClassFactory and CoCreateInstance</td>
</tr>
<tr valign=top>
<td width=50%>ICOLINFO</td>
<td width=50%>IColumnsInfo</td>
</tr>
<tr valign=top>
<td width=50%>ICNVTTYP</td>
<td width=50%>IConvertType</td>
</tr>
<tr valign=top>
<td width=50%>IDBCRSES</td>
<td width=50%>IDBCreateSession</td>
</tr>
<tr valign=top>
<td width=50%>IDBINIT</td>
<td width=50%>IDBInitialize</td>
</tr>
<tr valign=top>
<td width=50%>IDBPRPTS</td>
<td width=50%>IDBProperties</td>
</tr>
<tr valign=top>
<td width=50%>IGETDSO</td>
<td width=50%>IGetDataSource</td>
</tr>
<tr valign=top>
<td width=50%>IOPENRW</td>
<td width=50%>IOpenRowset</td>
</tr>
<tr valign=top>
<td width=50%>IPERSIST</td>
<td width=50%>IPersistFile</td>
</tr>
<tr valign=top>
<td width=50%>IROWSET</td>
<td width=50%>IRowset</td>
</tr>
<tr valign=top>
<td width=50%>IROWCHNG</td>
<td width=50%>IRowsetChange</td>
</tr>
<tr valign=top>
<td width=50%>IROWDEL</td>
<td width=50%>IRowsetChange::DeleteRows</td>
</tr>
<tr valign=top>
<td width=50%>IROWIDEN</td>
<td width=50%>IRowsetIdentity</td>
</tr>
<tr valign=top>
<td width=50%>IROWINFO</td>
<td width=50%>IRowsetInfo</td>
</tr>
<tr valign=top>
<td width=50%>IROWNEW</td>
<td width=50%>IRowsetChange::InsertRow</td>
</tr>
<tr valign=top>
<td width=50%>ISESPRPT</td>
<td width=50%>ISessionProperties</td>
</tr>
<tr valign=top>
<td width=50%>THREADS</td>
<td width=50%>Threading test (tests free-threaded only, not apartment model)</td>
</tr>
<tr valign=top>
<td width=50%>DATALITE</td>
<td width=50%>Data Coercion test</td>
</tr>
</table><br>
<h1>Test Coverage</h1>
<p>
The level 0 test modules cover each interface in the minimum provider level section of the OLE DB Leveling document, plus Data Coercion and Threading. </p>
<p>
The tests are organized into test modules (one per interface). Each test module contains test cases, and each test case contains test variations.</p>
<p>
All the OLE DB test modules use Privlib.lib, which is a set of common C++ functions such as table creation, data comparison, and accessor creation. </p>
<h1>Getting Started</h1>
<p>
The OLE DB test sources, include files, and resource files can be found in</p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Tests\Proposed\OLEDBTests</p>
<p>
Additional include files are in</p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Include</p>
<p>
Libs are in </p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Lib</p>
<p>
Source for the test tools (PrivLib and TableDump) can be found in </p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Tools\</p>
<p>
Local Test Manager (LTM), the tool used to run the conformance tests, can be found in </p>
<p class=indent>
<i>InstallDirectory</i>\bin\oledb</p>
<h1>Building a Tool (TableDump or Privlib) or Test</h1>
<p>
You should build PrivLib and TableDump before trying to build any of the OLE DB tests.</p>
<p>
To build a tool or test, use <b>Open Workspace </b>on the .dsp in Visual C++®. </p>
<p>
For PrivLib, the .dsp is in </p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Tools\PrivLib</p>
<p>
Add all the include directories and all the LIB directories for the version 2.0 SDK to your Visual C++ directory. (To do this in Visual C++, on the <b>Tools</b> menu, click <b>Options</b>, and then click <b>Directories</b>.) </p>
<p>
Update your system path to include the following directories at the beginning of the path list:</p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Tests\Proposed\OLEDBTests\Include</p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Include</p>
<p class=indent>
<i>InstallDirectory</i>\Include</p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Lib</p>
<p>
For VC 5 users, build PrivLib using the default target.</p>
<p>
For VC 6 users, change the default target to "privlib - Win32 x86 Debug" or "privlib - Win32 (Alpha) axp Debug", and then build.</p>
<p>
To build an OLE DB test on an Intel® machine, build the test using the Debug MBCS target. On an Alpha machine, build the tests with the DEBUG target. For VC 5 users, these targets should be the default targets. For VC 6 users, change the default targets, and then build.</p>
<p>
Create an initialization file by using the TableDump program found in the Tools directory. (See Section 3 of this paper for more information on the TableDump utility.)</p>
<h1>Running the OLE DB Conformance Tests</h1>
<p>
The Local Test Manager (LTM) is now a standalone exe that does not have to be registered. Once LTM is running, set up your provider by adding a new provider, which means specifying the connection string. The next section contains more information on creating a provider connection string. </p>
<p>
Register the tests by going to <b>Test/Register Item</b> and selecting the Test module to register.</p>
<p>
Next, click the test module (not just so the test module name is highlighted but the box is checked), click the provider you added, and then click <b>Run</b>. </p>
<p>
Test modules and LTM are organized so you can run a test module, a test case, or a test variation. Hightlight the test module name and click the plus sign next to the test module to expose the test cases in that module. Click the plus sign next to a test case to expose the test variations in that test case. Each variation tests a single test scenario. Each variation returns pass, failure, or skipped. Many variations also return the expected HRESULT and the actual HRESULT received if an error occurs. </p>
<h1>Provider Connection String</h1>
<p>
Before running a test in LTM, you must set up a provider and specify a provider connection string. Normally, you should use an initialization file (FILE=filename.out) and specify the connection flags:</p>
<p>
<b>CONFLEVEL=CONF_LEVEL_0 | CONF_STRICT;</b></p>
<p>
where</p>
<p class=indent>
<b>CONFLEVEL=CONF_LEVEL_0</b> specifies that all level 0 interfaces are supported.</p>
<p class=indent>
<b>CONFLEVEL=CONF_STRICT</b> specifies that only level 0 interfaces are used when running the tests.</p>
<p class=label>
<b>Sample provider strings</b></p>
<p>
Provider: OLE DB Provider for ODBC Drivers</p>
<p>
LTM connection string: </p>
<p>
<code>DATASOURCE=datasource; USERID=userid; PASSWORD=password;</code></p>
<p>
DATASOURCE identifies the ODBC data source name set up through the ODBC Data Source Administrator.</p>
<p>
Provider: SQL Server OLE DB Provider</p>
<p>
LTM connection string: </p>
<p>
<code>DATASOURCE=server; USERID=userid; PASSWORD=password;</code></p>
<p>
DATASOURCE identifies the name of the server to which you’re connecting.</p>
<p>
Provider: Oracle OLE DB Provider</p>
<p>
LTM connection string: </p>
<p>
<code>DATASOURCE=server; USERID=userid; PASSWORD=password;</code></p>
<p>
DATASOURCE identifies the name of the Oracle server to which you’re connecting.</p>
<p>
Provider: OLE DB Simple Provider (OSP)</p>
<p>
LTM connection string: </p>
<p>
<code>FILE=\filename.ini;</code></p>
<p>
This is normally run with an .ini file because OSP does not support commands.</p>
<p>
Provider: Jolt (OLE DB Provider for Microsoft® Jet)</p>
<p>
LTM connection string:</p>
<p>
<code>DATASOURCE=c:\file.mdb; USERID=Admin;</code></p>
<h1>Debugging a Test</h1>
<p>
The level 0 tests should run with zero failures. </p>
<p>
However, in case of a failure, you can debug by following these steps:
<ol>
<li>
In Visual C++, open any of the test project files in \Msdasdk\Comformance\Tests\Proposed.<br><br></li>
<li>
On the <b>Settings</b> menu, click <b>Project</b>, and then click the <b>General</b> tab.<br><br></li>
<li>
Under <b>Executable for debug session</b>, enter the path to LTM.exe, for example:<p class=tl>
<code>c:\msdasdk\bin\oledb\ltm.exe</code></P></li>
<li>
Open the source code for the test in the Src directory, then set breakpoints.<br><br></li>
<li>
To start LTM.exe, press <b>F5</b>.<br><br></li>
<li>
Select the test variations to debug, select the provider, and then start the test.<p class=tl>
You will hit your breakpoint.</P></li>
</ol>
<p class=indent>
<B><b>Note&nbsp;&nbsp; </b></B>If you did not build the test DLL, then the .pdb file must be in the same directory as the test, or in a search path.</p>
<h1>Section 3: Using the Table Dump Utility to Generate .Ini Files</h1>
<p>
Trying to develop complete OLE DB conformance tests generic enough to handle the broad range of OLE DB providers is not an easy task. There are many differences, limitations, and issues that are unique to each and every provider. </p>
<p>
Some of the major issues are:
<ul type=disc>
<li>
Providers may have their own provider-specific Initialization properties. Standard initialization properties from the Initialization property group can be specified on the connection string.<br><br></li>
<li>
Some providers are completely read-only.<br><br></li>
<li>
Some providers do not allow table creation.<br><br></li>
<li>
Providers may have their own unique CommandText (if testing Commands).</li>
</ul>
<p>
Just trying to initialize generically to a provider is not trivial. We need more information from the provider. To guarantee data is sent and received correctly we have to know what the data is supposed to be ahead of time. With a provider that doesn’t support Table Creation or modification of data, it’s hard to establish a known set of data. </p>
<p>
To solve these problems and still test a wide range of OLE DB providers, we have developed an initialization file that can be used by all conformance tests. This file contains all necessary information to get initialized to the provider, understand the provider’s command syntax if available, confirm that the data retrieved is correct, and verify all other aspects of the provider meeting a particular conformance level.</p>
<p>
TableDump creates and obtains all information needed to run for the provider’s level of conformance. </p>
<h1>Provider Requirements</h1>
<p>
To solve the stated problems and still work with the broad range of providers, we currently impose the following requirements. 
<ul type=disc>
<li>
We need to know the initialization properties ahead of time, and all values to get connected.<br><br></li>
<li>
We need to know the command syntax for all statements if you are testing commands.<p class=tl>
<b>Note</b> &nbsp; Since commands are not in level 0, you will not use commands if using <b>CONFLEVEL=CONF_LEVEL_0 | CONF_STRICT;</b> options.</P></li>
<li>
We need to obtain all columns and rows of data and place into this file to be able to verify data correctly for all providers.</li>
</ul>
<h1>Data Requirements</h1>
<p>
For complete conformance testing there are requirements placed upon the table/data provided to the conformance tests: 
<ul type=disc>
<li>
The table must contain a separate column for every possible supported DBTYPE. This assures all types or data are tested and obtained.<br><br></li>
<li>
The table must contain at least 10 rows of data, and should be around 60-100 rows.<br><br></li>
<li>
The data provided in the table should stress the data type, which can be ColumnSize, Precision, or Scale. The data should have at least one MIN value for every data type, and at least one entry with maximum precision for that data type.</li>
</ul>
<h1>Usage</h1>
<p>
TableDump is a simple command-line utility that takes arguments for all the required information it needs.</p>
<p>
Here is a list of current arguments, their values, and meaning.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp; </b></B>All arguments are uppercase. They must be followed by “=” and end in a semicolon to distinguish them from other arguments. </p>
<p>
<b>PROVIDER=ProviderName; </b></p>
<p class=indent>
Required Argument. This is the Provider ProgID of the provider to use. TableDump will use ProgIDToCLSID to convert this to a CLSID to obtain an instance of the provider in CoCreateInstance.</p>
<p>
<b>TABLENAME=TableName; </b></p>
<p class=indent>
Required Argument. This is the TableName to pass to IOpenRowset.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp; </b></B>Although the argument is called TableName, this does not imply that TableDump only works with relational providers. Here, TableName just indicates the DBID passed to <b>IOpenRowset</b>.</p>
<p>
<b>BINDINGTYPE=DBTYPE_WSTR | DBTYPE_STR | DBTYPE_VARIANT; </b></p>
<p class=indent>
Optional Argument. Normally this option is not needed. When TableDump creates the Accessor, it needs to bind all columns to a type that can be represented in a file (string format). Because all providers are required to convert all supported types to DBTYPE_WSTR, this should not be needed by a provider that conforms to the spec, since this is the default TableDump will use. Unfortunately, not all providers conform, so we have allowed the user to specify the binding type to a common type that can be converted to STR. If using DBTYPE_VARIANT, it’s the provider’s responsibility to convert all values to VARIANT, and the tool will handle all conversions from VARIANT to string.</p>
<p>
<b>DEFAULTQUERY=DefaultQuery;&nbsp; </b></p>
<p class=indent>
Optional Argument. Normally this option is not needed. If you want to test command support, this is the default command for all queries used by the tests and PrivLib. All entries in the QUERY section will have this command as the default. You can then modify that section based upon the grammar or command syntax required for your provider.</p>
<p>
<b>OUTPUT=OutputFileName;&nbsp; </b></p>
<p class=indent>
Optional Argument. This is the output file name for the generated .ini file. You can include the entire path, including file name and extension. TableDump will use whatever is provided, or will default to “TableDump.out” if this option is not specified.</p>
<p>
<b>CACHE_AUTHINFO=;</b></p>
<p>
<b>ENCRYPT_PASSWORD=;</b></p>
<p>
<b>INTEGRATED=;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>MASK_PASSWRD=;</b></p>
<p>
<b>PASSWORD=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>PERSIST_ENCRYPTED=;</b></p>
<p>
<b>PERSIST_SENSITIVE_AUTHUNFO=;</b></p>
<p>
<b>USERID=;</b></p>
<p>
<b>DATASOURCE=; </b></p>
<p>
<b>HWND=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>IMPERSONATION_LEVEL=;</b></p>
<p>
<b>LCID=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>LOCATION=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>MODE=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>PROMPT=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>PROTECTION_LEVEL=;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>PROVIDERSTRING=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p>
<b>TIMEOUT=;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></p>
<p class=indent>
Optional Arguments. Each one of the above arguments corresponds to a property in the DBPROPSET_DBINIT group (without the preceding DBPROP_*_). To initialize your provider, you need to specify only whatever arguments are required. If none are needed for initialization, then none need to be specified. When using MSDASQL, usually only DATASOURCE, USERID, and PASSWORD are needed to initialize the provider.</p>
<h1>Usage With LTM</h1>
<p>
When creating a provider, specify <b>FILE=filename.ini</b> in the LTM InitString (). When running a test, the test will check the existence of this keyword and will process the .ini file before beginning any test variations.</p>
<h1>Format</h1>
<p>
Currently the format of the .ini is not that important because there is a tool generator. For most providers, the file will not have to be modified. In case manual editing is required, the following gives a brief description of the .ini file’s sections and meanings, along with a sample .ini file.</p>
<p>
<b>[INFO:]</b></p>
<p class=indent>
This is for all provider initialization and other init information. Currently this will contain:
<ul type=disc>
<li>
The provider’s name, <br><br></li>
<li>
The table name to use in <b>IOpenRowset</b> and/or the default query to use (For details on when this is used, see DEFAULTQUERY above.)</li>
</ul>
<p>
The following sample is from a provider MSDASQL, the table is Customers, and the initialization properties are DBPROP_INIT_DATASOURCE, DBPROP_AUTH_PASSWORD, and DBPROP_AUTH_USERID:</p>
<pre><code>[INFO] {Provider (Table, &lt;DataSource&gt;, &lt;DefaultQuery&gt;)}
{ PROVIDER=MSDASQL (TABLE=Customers, DATASOURCE= OLE_DB_NWind_Jet}
</code></pre>
<p>
<b>[QUERY:]</b></p>
<p class=indent>
This section is a large list of all the command statements that the test will try to use in the process of testing the provider. TableDump will generate all of these based upon the specified default query when the tool is used. This section may need to be manually edited to make sure that all command statements contain the correct grammar, columns, etc. to obtain the operation. The uppercase enumeration indicates the intended command, and everything between quotes represents the provider-specific syntax of that operation.</p>
<p class=indent>
This section is only looked at if you’re using the DEFAULTQUERY option (see the option for more details). If the above example specified <b>DEFAULTQUERY=select * from Customers</b>, this section would contain all statements with a default CommandText string within the quotes. </p>
<p class=indent>
The first SELECT_ALLFROMTABLE represents a command that will get executed to select all the columns from the table, so “select * from Customers” is our provider’s syntax to do that. The next is SELECT_EMPTYROWSET and the text inside quotes is the provider-specific syntax to obtain an empty rowset.</p>
<pre><code>&nbsp;[QUERY] {SQLEnumIdentifier("Query")}
{SELECT_ALLFROMTBL("select * from Customers ")}
{SELECT_EMPTYROWSET("select * from Customers where 0 = 1")}
</code></pre>
<p>
<b>[COLUMN:]</b></p>
<p class=indent>
This section is a list of all columns found on the specified table or a result from the default query. It contains all the information commonly reported from <b>IColumnsInfo</b>, such as type information, precision, scale, and other info flags to be used when creating and verify data.</p>
<pre><code>[COLUMN] {ColName(iOrdinal, TYPE, ulColumnSize, bPrecision, bScale, dwFlags)} 
{CustomerID(1,DBTYPE_STR ,5,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
</code></pre>
<p>
<b>[DATA:]</b></p>
<p class=indent>
This section is a list of all data found on the specified table or a result from the default query. The format is a 1:1 correspondence to the column section above. The first row of data is for the first row, and the first column refers to the first column in the Column section. All data is represented in the file in {“String”} format, and NULL is represented as {(null)}. When the testing framework reads this file back in, all types will get converted back into the correct type indicated in the Column section. When the column is of type VARIANT the data value is also prefixed with the VT_TYPE indicator for the specified subtype. To represent a VARIANT with subtype VT_I4 and Value 3, TableDump will produce VT_I4(“3), and DBTYPE_VARIANT will be indicated in the Column section. This is for providers that support VARIANT types, or support the possibility of every VARIANT in different rows to be of a different subtype.</p>
<pre><code>&nbsp;[DATA] {&lt;Type&gt;("data")} 
{("ALFKI")},{("Alfreds Futterkiste")},{("Maria Anders")},{("Sales Representative")},{("Obere Str. 57")},{("Berlin")},{(null)},{("12209")},{("Germany")},{("030-0074321")},{("030-0076545")},
</code></pre>
<h1>Example</h1>
<p>
Suppose you want to test a provider using the OLE DB conformance tests, and need to generate an .ini file that will be used by all the tests.</p>
<p>
Here is the example provider information:</p>
<p>
ProvderName: MSDASQL</p>
<p>
DataSource: OLE_DB_NWind_Jet</p>
<p>
UserID: admin</p>
<p>
Password: </p>
<p>
Table: Customers</p>
<p>
DefaultQuery: select * from Customers</p>
<p>
The following information is what’s needed to generate the .ini file :</p>
<p>
<code>TableDump.exe PROVIDER=MSDASQL; DATASOURCE= OLE_DB_NWind_Jet; USERID=admin; PASSWORD=; TABLENAME=Customers; DEFAULTQUERY=select * from Customers; OUTPUT=Customers.ini;</code></p>
<p>
This will create the following file, Customers.ini:</p>
<pre><code>[INFO] {Provider (Table, &lt;DefaultQuery&gt;)}
{ PROVIDER=MSDASQL (TABLE=Customers, DEFAULTQUERY="select * from Customers")}

[QUERY] {SQLEnumIdentifier("Query")}
{SELECT_ALLFROMTBL("select * from Customers")}
{SELECT_SEARCHABLE("select * from Customers")}
{SELECT_UPDATEABLE("select * from Customers")}
{SELECT_ABCANDCOLLIST("select * from Customers")}
{SELECT_DISTINCTCOLLISTORDERBY("select * from Customers")}
{SELECT_REVCOLLIST("select * from Customers")}
{SELECT_COLLISTGROUPBY("select * from Customers")}
{SELECT_COLLISTWHERELASTCOLINSELECT("select * from Customers")}
{SELECT_REVCOLLISTFROMVIEW("select * from Customers")}
{SELECT_COUNT("select * from Customers")}
{SELECT_COLLISTSELECTREVCOLLIST("select * from Customers")}
{SELECT_EMPTYROWSET("select * from Customers")}
{SELECT_COLLISTFROMTBL("select * from Customers")}
{SELECT_COLLISTTBLUNIONTBL("select * from Customers")}
{SELECT_COLLISTORDERBYCOLONECOMPUTE("select * from Customers")}
{SELECT_CROSSPRODUCT("select * from Customers")}
{SELECT_LEFTOUTERJOIN("select * from Customers")}
{SELECT_RIGHTOUTERJOIN("select * from Customers")}
{SELECT_FROMTBLWITHPARAMS("select * from Customers")}
{SELECT_CHANGECOLNAME("select * from Customers")}
{SELECT_DUPLICATECOLUMNS("select * from Customers")}
{SELECT_REVERSEDUPLICATECOLUMNS("select * from Customers")}
{SELECT_MAXCOLINQUERY("select * from Customers")}
{SELECT_COMPUTEDCOLLIST("select * from Customers")}
{SELECT_UPDATEABLEALLROWS("select * from Customers")}
{SELECT_ORDERBYNUMERIC("select * from Customers")}
{INSERT_1ROW("select * from Customers")}
{INSERT_ALLWITHPARAMS("select * from Customers")}
{SELECT_ALL_WITH_SEARCHABLE_AND_UPDATEABLE("select * from Customers")}
{SELECT_ALL_WITH_BLOB_AT_END("select * from Customers")}
{NO_QUERY("select * from Customers")}
{SELECT_ALL_WITH_FOR_BROWSE("select * from Customers")}

[COLUMN] {ColName(iOrdinal, TYPE, ulColumnSize, bPrecision, bScale, dwFlags)} 
{CustomerID(1,DBTYPE_STR ,5,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{CompanyName(2,DBTYPE_STR ,40,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{ContactName(3,DBTYPE_STR ,30,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{ContactTitle(4,DBTYPE_STR ,30,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{Address(5,DBTYPE_STR ,60,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{City(6,DBTYPE_STR ,15,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{Region(7,DBTYPE_STR ,15,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{PostalCode(8,DBTYPE_STR ,10,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{Country(9,DBTYPE_STR ,15,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{Phone(10,DBTYPE_STR ,24,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}
{Fax(11,DBTYPE_STR ,24,255,255,DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)}

[DATA] {&lt;Type&gt;("data")} 
{("ALFKI")},{("Alfreds Futterkiste")},{("Maria Anders")},{("Sales Representative")},{("Obere Str. 57")},{("Berlin")},{(null)},{("12209")},{("Germany")},{("030-0074321")},{("030-0076545")},
{("ANATR")},{("Ana Trujillo Emparedados y helados")},{("Ana Trujillo")},{("Owner")},{("Avda. de la Constitución 2222")},{("México D.F.")},{(null)},{("05021")},{("Mexico")},{("(5) 555-4729")},{("(5) 555-3745")},
{("ANTON")},{("Antonio Moreno Taquería")},{("Antonio Moreno")},{("Owner")},{("Mataderos 2312")},{("México D.F.")},{(null)},{("05023")},{("Mexico")},{("(5) 555-3932")},{(null)},
{("AROUT")},{("Around the Horn")},{("Thomas Hardy")},{("Sales Representative")},{("120 Hanover Sq.")},{("London")},{(null)},{("WA1 1DP")},{("UK")},{("(171) 555-7788")},{("(171) 555-6750")},
{("BERGS")},{("Berglunds snabbköp")},{("Christina Berglund")},{("Order Administrator")},{("Berguvsvägen 8")},{("Luleå")},{(null)},{("S-958 22")},{("Sweden")},{("0921-12 34 65")},{("0921-12 34 67")},
{("BLAUS")},{("Blauer See Delikatessen")},{("Hanna Moos")},{("Sales Representative")},{("Forsterstr. 57")},{("Mannheim")},{(null)},{("68306")},{("Germany")},{("0621-08460")},{("0621-08924")},
{("BLONP")},{("Blondel père et fils")},{("Frédérique Citeaux")},{("Marketing Manager")},{("24, place Kléber")},{("Strasbourg")},{(null)},{("67000")},{("France")},{("88.60.15.31")},{("88.60.15.32")},
{("BOLID")},{("Bólido Comidas preparadas")},{("Martín Sommer")},{("Owner")},{("C/ Araquil, 67")},{("Madrid")},{(null)},{("28023")},{("Spain")},{("(91) 555 22 82")},{("(91) 555 91 99")},
{("BONAP")},{("Bon app'")},{("Laurence Lebihan")},{("Owner")},{("12, rue des Bouchers")},{("Marseille")},{(null)},{("13008")},{("France")},{("91.24.45.40")},{("91.24.45.41")},
{("BOTTM")},{("Bottom-Dollar Markets")},{("Elizabeth Lincoln")},{("Accounting Manager")},{("23 Tsawassen Blvd.")},{("Tsawassen")},{("BC")},{("T2F 8M4")},{("Canada")},{("(604) 555-4729")},{("(604) 555-3745")},
{("BSBEV")},{("B's Beverages")},{("Victoria Ashworth")},{("Sales Representative")},{("Fauntleroy Circus")},{("London")},{(null)},{("EC2 5NT")},{("UK")},{("(171) 555-1212")},{(null)},

*The rest is removed for simplicity and saving trees…
</code></pre>
<h1>Section 4: Building and Running the ADO Minimal Tests</h1>
<h1>ADO Level 0 Conformance Tests</h1>
<p>
The <a href="ado2oledb.htm"><b>mapping of ADO properties and methods to OLE DB</b></a> interfaces provides the basis for the grouping of ADO properties and methods into the conformance levels.</p>
<p>
Before running ADO Level O conformance tests, you must manually modify the .ini file generated by TableDump. (See example in the previous section, “Example.”) Modify the SELECT_EMPTYROWSET line under [QUERY] by adding a query that will yield no results. For example:</p>
<pre><code>{SELECT_EMPTYROWSET("select * from mytable where 1=2")}
</code></pre>
<p>
If you do not modify this line, end-of-file and beginning-of-file tests will fail.</p>
<h1>ADO Update Conformance Tests</h1>
<p>
These tests are provided to confirm that ADO Update statements will work with compliant updatable providers.</p>
<h1>ADO Transaction Conformance Tests</h1>
<p>
These tests are provided to confirm that ADO Transaction statements will work with compliant providers that support transactions.</p>
<h1>Building ADOPriv.dll</h1>
<p>
Before running the ADO tests, you must build ADOPriv.dll.
<ol>
<li>
To build ADOPriv.dll, use <b>Open Workspace </b>on the <i>InstallDirectory</i>\ Conformance\Tools\ADOPriv\ADOPriv.dsp in Visual C++®. <br><br></li>
<li>
Add all the include directories and all the LIB directories for the version 2.0 SDK to your Visual C++ directory. (To do this in Visual C++, on the <b>Tools</b> menu, click <b>Options</b>, and then click <b>Directories</b>.) <br><br></li>
<li>
Update your system path to include the following directories:<p class=tl>
<i>InstallDirectory</i>\Conformance\Tests\Proposed\OLEDBTests\Include</P><p class=tl>
<i>InstallDirectory</i>\Conformance\Include</P><p class=tl>
<i>InstallDirectory</i>\Conformance\Lib</P></li>
<li>
Build ADOPriv using the default target.<br><br></li>
<li>
Copy ADOPriv.dll to <p class=tl>
<i>InstallDirectory</i>\Conformance\Lib</P></li>
<li>
Register it in that directory using Regsrv32.exe</li>
</ol>
<h1>Getting Started</h1>
<p>
The ADO tests are in </p>
<p class=indent>
<i>InstallDirectory</i>\Conformance\Tests\Proposed\ADOTests</p>
<p>
The test .dll and .reg files are in the ADOTests subdirectory itself. The source is in the SRC subdirectory, in case you need to rebuild the tests. </p>
<p>
ADOPriv.dll is in the Tools subdirectory. (This is the wrapper for the PrivLib used by the ADO tests for common functionality.)
<ol>
<li>
Register the ADO tests by executing <b>regsvr32</b> on each of the ADO test .dll files. For example: <pre><code>regsvr32 adolvl0.dll</code></pre>
</li>
</ol>
<pre></pre>
<ol start=2>
<li>
Execute each of the .reg files. For example: adolvl0.reg.<br><br></li>
<li>
If you haven’t already done so, create an .ini file using the TableDump program found in the Tools subdirectory.<br><br></li>
<li>
Start LTM by executing LTM.exe. When LTM is running, set up a provider by adding a new provider, which means specifying the connection string. See the next section for more information on creating a provider connection string. <br><br></li>
<li>
Click the test module, click the provider you added, and then click <b>Run</b>. </li>
</ol>
<p>
Test modules and LTM are set up so you can run a test module, a test case, or a test variation. 
<ol start=6>
<li>
Click the plus sign next to the test module to expose the cases in that module. Click the plus sign next to a test case to expose the variations in that case. </li>
</ol>
<p>
Each variation tests a single test scenario. Each variation will return pass or failure. In many cases, the variation will also return the expected HRESULT and the actual HRESULT received. </p>
<h1>Provider Connection String</h1>
<p class=label>
<b>ODBC Provider Example:</b></p>
<pre><code>DATASOURCE=ADOT7;
USERID=adolab;
PASSWORD=sometext;
FILE=C:\testdrop\ wayl7.ini;
DefaultQuery=select * from wayl7;
CURSORLOC=client;CONNECTIONTIMEOUT=500;</code></pre>
<p class=label>
<b>Oracle Provider Example:</b></p>
<pre><code>DATASOURCE=goliath.world;
USERID=ADOLAB1;
PASSWORD=sometext;
FILE=C:\testdrop\ wayl7can.ini;
DefaultQuery=select * from wayl7;
CURSORLOC=server;</code></pre>
<h1>Debugging</h1>
<p>
Your provider should get zero failures when running the Level 0 tests. If it supports updates and transactions, it should also get zero failures when running the Updatability and Transaction tests.</p>
<p>
In case there is a failure, the ADO tests can be viewed and stepped through by using Visual Studio™. Simply launch LTM, launch Visual Studio, attach to the TD process, and open the desired Visual Basic® source file. </p>
<p>
It is not possible at this time to debug the ADO tests in the Visual Basic environment</p>
</font></BODY>
</HTML>
