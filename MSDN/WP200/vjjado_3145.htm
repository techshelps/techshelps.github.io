<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Transaction Sample</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="vjhowtransactionsample"></a>Transaction Sample</h1>
<p>
This sample extends the <a href="vjjado_8lph.htm">framework code</a> to demonstrate ADO/WFC’s support for transactions. Transactional-aware applications are an integral part of modern computing. ADO fully supports both local transactions, as well as distributed, two-phase transactions coordinated by the Microsoft® Distributed Transaction Coordinator (DTC). The following sample utilizes local transaction management capabilities surfaced through the Connection object. You can get the current transaction from the Connection by using the <code>getActiveTransaction</code> method. </p>
<pre><code>public boolean run()
{
 &nbsp; Connection c = new Connection();
 &nbsp; c.setIsolationLevel (AdoEnums.adXactReadCommitted);
 &nbsp; c.setCursorLocation (AdoEnums.adUseClientBatch);
 &nbsp; c.open ("dsn=aDSN", "aName", "aPWD");

 &nbsp; Transaction t = c.getActiveTransaction();

 &nbsp; if (t != null)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; Recordset rs = c.execute ("select * from authors");
 &nbsp;&nbsp;&nbsp;&nbsp; t.beginTrans();

 &nbsp;&nbsp;&nbsp;&nbsp; int recordCount = rs.getRecordCount();
 &nbsp;&nbsp;&nbsp;&nbsp; c.executeUpdate ("delete from authors");
 &nbsp;&nbsp;&nbsp;&nbsp; rs.requery();
 &nbsp;&nbsp;&nbsp;&nbsp; if (rs.getRecordCount() != 0)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.close();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Roll back (undo) the changes. 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.rollbackTrans(false);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.close();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; // Make the changes permanent in the data source 
 &nbsp;&nbsp;&nbsp;&nbsp; // and then refresh the results to verify the operation. 
 &nbsp;&nbsp;&nbsp;&nbsp; t.commitTrans(false);
 &nbsp;&nbsp;&nbsp;&nbsp; rs.requery();
 &nbsp;&nbsp;&nbsp;&nbsp; rs.close();
 &nbsp; }
 &nbsp; 
 &nbsp; c.close();
 &nbsp; return true;
}
</code></pre>
<p>
The IsolationLevel property, set through <code>c.setIsolationLevel (AdoEnums.adXactReadCommitted)</code>, is important when dealing with transactionally-scoped data access and application logic. Isolation refers to the level of autonomy that a transaction has from data/state changes made in other transactions. In the case of ReadCommitted isolation (specified by the constant parameter passed to the Connection object), any access to data sources will only see “committed” data, meaning the changes that are durable and have been successfully made. This guards against “phantom writes” that may appear if lower, more relaxed isolation levels are used. </p>
<p>
The ADO/WFC Transaction object is dispensed from the Connection object. Once a non-null reference is obtained, the standard transaction operations may be used: beginning, committing, or aborting changes. In this sample, a new transaction is created after the initial select statement is executed from the Connection, resulting in a non-transacted Recordset. Subsequent to the <code>t.beginTrans()</code> call, the Recordset is replenished, after the Connection object is used to execute a SQL DML statement. This statement deletes the entire authors table. The Recordset, now empty, is within a transactional scope. The following lines then verify that the Recordset is indeed within the “scope” of the running transaction:</p>
<pre><code>if (rs.getRecordCount() != 0)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; rs.close();
 &nbsp;&nbsp;&nbsp;&nbsp; // Roll back (undo) the changes. 
 &nbsp;&nbsp;&nbsp;&nbsp; t.rollbackTrans(false);
 &nbsp;&nbsp;&nbsp;&nbsp; c.close();
 &nbsp;&nbsp;&nbsp;&nbsp; return false;
 &nbsp; }
</code></pre>
<p>
The RecordCount of the Recordset should equal zero, since the Connection deleted all of the rows. If it fails to equal zero, the entire delete operation is aborted, rolling back the state of the data source to the state it had before the transaction was started. If, on the other hand, the Recordset is empty, then the transaction has worked appropriately and the changes can be committed, as follows:</p>
<pre><code>t.commitTrans(false);
rs.requery();
rs.close();
</code></pre>
<p>
The Recordset is requeried, and should be empty, since the deletes were made permanent. The Recordset is then closed and the sample is completed. Transactions are an excellent way to write applications that ensure strange results do not creep into your control logic. ADO/WFC’s full support for both the local and distributed varieties make transactions a flexible and useful framework for building distributed business applications.</p>
</font></BODY>
</HTML>
