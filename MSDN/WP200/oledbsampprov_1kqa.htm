<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sample Provider Overview</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbsampleprovider"></a>Sample Provider Overview</h1>
<p>
The OLE DB sample provider, SAMPPROV.DLL, is a learning tool for developers new to OLE DB. Users can displaying the source code in the debugger to learn about building OLE DB providers. Although this provider uses a simple interface to access data in the underlying data source, it demonstrates the general procedures that developers need to follow to expose rowsets over a file-based data source using <b>IOpenRowset</b>.</p>
<h1>Sample Provider Features</h1>
<p>
The sample provider exposes data in a single, comma-separated value file named CUSTOMER.CSV. If you alter the code to use a different file, you must follow the formatting conventions of the sample file, which follow.</p>
<p>
The first line of a .csv file that can be read by SAMPPROV must contain the column names in quotation marks. The second line must list the column types and lengths. All additional lines contain data, in comma-separated format. Every line of data in the file must contain the correct number of values. The following example illustrates the file format. </p>
<pre><code>"Column1","Column2","Column3"
Char(20),SLONG,SLONG
"Name1",10,-10
@@@@@@@@@@@@@@@@@@@@@&nbsp;&nbsp;&nbsp;&nbsp; // Deleted Row
"Name2",110,-110
</code></pre>
<p>
In addition, the sample provider replaces deleted rows in the file with the at sign (@). These rows are ignored by the sample provider when the file is initialized. If a user updates a row, the new data is appended to the end of the file and the original row is overwritten with at signs, indicating that it is deleted.</p>
<h1>Sample Provider Limitations </h1>
<p>
The following are limitations in SAMPPROV.DLL:
<ul type=disc>
<li>
This code example is for illustrative purposes; the sample provider has not been rigorously tested.<br><br></li>
<li>
<b>IDBInitialize::Initialize</b> requires the path to the .csv file. If the path is not supplied by the calling application, SAMPPROV prompts the user for the path.<br><br></li>
<li>
The data source object can create only one session; the session can create only one rowset. This is because the underlying Cfileio object opens the .csv text files in exclusive mode, and has no mechanism to share access to the file.<br><br></li>
<li>
The use of properties is very simple. Only a small set of properties are illustrated, and properties are read-only.</li>
</ul>
<h1>Sample Provider Files</h1>
<p>
The following source files are included with the sample provider. The source files are located in the &lt;install directory&gt;\SAMPLES\SAMPPROV directory. The sample provider executable file SAMPPROV.DLL is located in the &lt;install directory&gt;\BIN directory.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=27%><b>File name</b></td>
<td class=label width=73%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%>ACCESSOR.cpp</td>
<td width=73%>CImpIAccessor object implementation.</td>
</tr>
<tr valign=top>
<td width=27%>ASSERTS.cpp</td>
<td width=73%>Simple assertion routines.</td>
</tr>
<tr valign=top>
<td width=27%>ASSERTS.h</td>
<td width=73%>Simple assertion routine header file.</td>
</tr>
<tr valign=top>
<td width=27%>BITARRAY.cpp</td>
<td width=73%>An implementation of a bit array class used by the internal buffer to mark released or unreleased rows.</td>
</tr>
<tr valign=top>
<td width=27%>BITARRAY.h</td>
<td width=73%>Class definitions for the bit array class.</td>
</tr>
<tr valign=top>
<td width=27%>CLASSFAC.cpp</td>
<td width=73%>DLL entry and exit points and the OLE ClassFactory class.</td>
</tr>
<tr valign=top>
<td width=27%>CLASSFAC.h</td>
<td width=73%>Class definitions for CClassFactory and DLL entry points.</td>
</tr>
<tr valign=top>
<td width=27%>COLINFO.cpp</td>
<td width=73%><b>IColumnsInfo</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>CRTSESS.cpp</td>
<td width=73%><b>IDBCreateSession</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>CVTTYPE.cpp</td>
<td width=73%><b>IConvertType</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>DATASRC.cpp</td>
<td width=73%>CDataSource object implementation.</td>
</tr>
<tr valign=top>
<td width=27%>DATASRC.h</td>
<td width=73%>CDataSource base object and contained interface definitions.</td>
</tr>
<tr valign=top>
<td width=27%>DBINIT.cpp</td>
<td width=73%><b>IDBInitialize</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>DBPROP.cpp</td>
<td width=73%><b>IDBProperties</b> and <b>IDBInfo</b> interface implementations.</td>
</tr>
<tr valign=top>
<td width=27%>DBSESS.cpp</td>
<td width=73%>CDBSession object implementation.</td>
</tr>
<tr valign=top>
<td width=27%>DBSESS.h</td>
<td width=73%>CDBSession base object and contained interface definitions.</td>
</tr>
<tr valign=top>
<td width=27%>EXTBUFF.cpp</td>
<td width=73%>The class that provides array-based access to a big block of memory.</td>
</tr>
<tr valign=top>
<td width=27%>EXTBUFF.h</td>
<td width=73%>Class definitions for CExtBuffer class.</td>
</tr>
<tr valign=top>
<td width=27%>FILEIDX.cpp</td>
<td width=73%>The index array code for a comma-separated value (.csv) provider.</td>
</tr>
<tr valign=top>
<td width=27%>FILEIDX.h</td>
<td width=73%>Class definitions for CFileIO class.</td>
</tr>
<tr valign=top>
<td width=27%>FILEIO.cpp</td>
<td width=73%>The file manipulation code for a comma-separated value (.csv) provider.</td>
</tr>
<tr valign=top>
<td width=27%>FILEIO.h</td>
<td width=73%>Class definitions for CFileIO class.</td>
</tr>
<tr valign=top>
<td width=27%>GLOBALS.cpp</td>
<td width=73%>Global initialization object.</td>
</tr>
<tr valign=top>
<td width=27%>GUIDS.h</td>
<td width=73%>Internal GUIDs.</td>
</tr>
<tr valign=top>
<td width=27%>HASHTBL.cpp</td>
<td width=73%>Hashing routines for row manipulation.</td>
</tr>
<tr valign=top>
<td width=27%>HASHTBL.h</td>
<td width=73%>Class definitions for CHashTbl class and miscellaneous bookmark functions.</td>
</tr>
<tr valign=top>
<td width=27%>HEADERS.cpp</td>
<td width=73%>Precompiled headers module.</td>
</tr>
<tr valign=top>
<td width=27%>HEADERS.h</td>
<td width=73%>Precompiled headers.</td>
</tr>
<tr valign=top>
<td width=27%>IROWSET.cpp</td>
<td width=73%><b>IRowset</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>LOCAL.RC</td>
<td width=73%>Localizable resource.</td>
</tr>
<tr valign=top>
<td width=27%>OPNROWST.cpp</td>
<td width=73%><b>IOpenRowset</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>PERSIST.cpp</td>
<td width=73%><b>IPersist</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>RC.h</td>
<td width=73%>Resource IDs.</td>
</tr>
<tr valign=top>
<td width=27%>ROWCHNG.cpp</td>
<td width=73%><b>IRowsetChange</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>ROWINFO.cpp</td>
<td width=73%><b>IRowsetInfo</b> interface implementation.</td>
</tr>
<tr valign=top>
<td width=27%>ROWSET.cpp</td>
<td width=73%>CRowset object implementation.</td>
</tr>
<tr valign=top>
<td width=27%>ROWSET.h</td>
<td width=73%>CRowset base object and contained interface definitions.</td>
</tr>
<tr valign=top>
<td width=27%>SAMPPROV.DEF</td>
<td width=73%>Project definitions.</td>
</tr>
<tr valign=top>
<td width=27%>SAMPPROV.h</td>
<td width=73%>Main include file.</td>
</tr>
<tr valign=top>
<td width=27%>SAMPPROV.MAK</td>
<td width=73%>Microsoft Developer Studio–generated NMAKE File.</td>
</tr>
<tr valign=top>
<td width=27%>SAMPPROV.RC</td>
<td width=73%>Main resource file.</td>
</tr>
<tr valign=top>
<td width=27%>SAMPVER.h</td>
<td width=73%>Version include file.</td>
</tr>
<tr valign=top>
<td width=27%>UTILPROP.cpp</td>
<td width=73%>Properties utility object implementation.</td>
</tr>
<tr valign=top>
<td width=27%>UTILPROP.h</td>
<td width=73%>CUtilProp object definitions.</td>
</tr>
</table><br>
<h1>Building the Sample Provider</h1>
<p>
The file &lt;install directory&gt;\SAMPLES\SAMPPROV\SAMPPROV.MAK is set up for compilation with NMAKE, the Microsoft® Program Maintenance Utility provided with Microsoft Developer Studio. SAMPPROV must have access to the following OLE DB files:</p>
<p class=tl>
OLEDB.h</P><p class=tl>
OLEDBERR.h</P><p class=tl>
OLEDB.LIB</P><p>
Verify that these files are on the path referred to by the INCLUDE environment variable.</p>
<p>
The following example syntax builds a debug version of SAMPPROV on the Intel® <i>x</i>86 platform based on the Win32® (<i>x</i>86) Dynamic-Link Library configuration.</p>
<pre><code>NMAKE /f "sampprov.mak" CFG="sampprov - Win32 x86 Debug"
</code></pre>
<p>
To build SAMPPROV on another platform or with a different configuration, use one of the following configuration options.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td width=56%><b>Configuration option</b></td>
<td width=44%><b>Type of file built</b></td>
</tr>
<tr valign=top>
<td width=56%>"sampprov - Win32 x86 Debug"</td>
<td width=44%>Debug version of SAMPPROV based on Win32 (<i>x</i>86) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td width=56%>"sampprov - Win32 x86 Release"</td>
<td width=44%>Retail version of SAMPPROV based on Win32 (<i>x</i>86) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td width=56%>"sampprov - Win32 (ALPHA) axp Debug"</td>
<td width=44%>Debug version of SAMPPROV based on Win32 (ALPHA) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td width=56%>"sampprov - Win32 (ALPHA) axp Release"</td>
<td width=44%>Retail version of SAMPPROV based on Win32 (ALPHA) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td width=56%>"sampprov - Win32 (PPC) ppc Debug"</td>
<td width=44%>Debug version of SAMPPROV based on Win32 (PPC) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td width=56%>"sampprov - Win32 (PPC) ppc Release"</td>
<td width=44%>Retail version of SAMPPROV based on Win32 (PPC) Dynamic-Link Library.</td>
</tr>
</table><br>
<p>
For additional information on using NMAKE, see the Developer Studio documentation.</p>
<h1>Writing an OLE DB Provider: An Introduction</h1>
<p>
The purpose of this section is to offer some general guidelines on how to construct an OLE DB data provider. </p>
<h1>Information Needed to Write an OLE DB Provider</h1>
<p>
OLE DB is based on the Component Object Model. Developers must be familiar with this model as well as with basic object-oriented coding practices to create an OLE DB provider. Although many different implementations are possible, the sample provider implements the TDataSource, TDBSession, and TRowset CoTypes. The sample provider uses the <b>IOpenRowset</b> interface, which is a required interface on the session for all providers. <b>IOpenRowset</b> is used by consumers that need access to the full data set and do not need to specify selection criteria.</p>
<p>
Developers should become familiar with data source objects, sessions, and rowsets by reading the <i>OLE DB Programmer’s Reference</i>. In addition, developers may want to read the “Overview” in the <i>OLE DB Programmer’s Reference</i> to get a general introduction to OLE DB conventions, design considerations, and a complete introduction to the objects that make up OLE DB.</p>
<h1>The Sample Provider</h1>
<p>
The sample provider offers access to a fixed-length text data file using OLE DB interfaces. The purpose of this sample provider is purely illustrative. The capabilities of the sample provider are limited; these limitations are discussed in “Sample Provider Overview,” previously in this paper.</p>
<p>
The sample provider opens the sample data file and enables the consumer to read the data, using the <b>IRowset</b> interface, in a forward-only fashion. The consumer can update or delete the current row but cannot add new rows. The format of the data file is discussed in “Sample Provider Overview,” previously in this paper.</p>
<h1>Objects and Interfaces Implemented by the Sample Provider</h1>
<p>
The sample provider implements three OLE DB objects.
<ul type=disc>
<li>
The data source object, which enables consumers to connect and initialize the interaction with the data file.<br><br></li>
<li>
The session, which enables consumers to create a rowset for the data set in the data file.<br><br></li>
<li>
The rowset, which exposes a data set to the consumer.</li>
</ul>
<p>
These objects, along with the interfaces implemented in the sample, are described in detail in the following topics, which also contain some of the implementation code for specific interfaces and methods.</p>
<p>
The following table lists the interfaces and methods implemented in the sample provider along with the name of the source code file in which each can be found.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=33%><b>Interface name</b></td>
<td class=label width=33%><b>Method name</b></td>
<td class=label width=34%><b>Source code file</b></td>
</tr>
<tr valign=top>
<td width=33%><b>IDBInitialize</b></td>
<td width=33%><b>Initialize</b></td>
<td width=34%>DBInit.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>Uninitialize</b></td>
<td width=34%>DBInit.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IDBCreateSession</b></td>
<td width=33%><b>CreateSession</b></td>
<td width=34%>CrtSess.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IDBProperties</b></td>
<td width=33%><b>GetProperties</b></td>
<td width=34%>UtilProp.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>GetPropertyInfo</b></td>
<td width=34%>UtilProp.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>SetProperties</b></td>
<td width=34%>UtilProp.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IPersist</b></td>
<td width=33%><b>GetClassID</b></td>
<td width=34%>Persist.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IGetDataSource</b></td>
<td width=33%><b>GetDataSource</b></td>
<td width=34%>DBSess.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IOpenRowset</b></td>
<td width=33%><b>OpenRowset</b></td>
<td width=34%>OpnRowst.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IColumnsInfo</b></td>
<td width=33%><b>GetColumnInfo</b></td>
<td width=34%>ColInfo.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>MapColumnIDs</b></td>
<td width=34%>ColInfo.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IConvertType</b></td>
<td width=33%><b>CanConvert</b></td>
<td width=34%>CvtType.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IAccessor</b></td>
<td width=33%><b>AddRefAccessor</b></td>
<td width=34%>Accessor.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>CreateAccessor</b></td>
<td width=34%>Accessor.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>GetBindings</b></td>
<td width=34%>Accessor.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>ReleaseAccessor</b></td>
<td width=34%>Accessor.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IRowset</b></td>
<td width=33%><b>AddRefRows</b></td>
<td width=34%>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>GetData</b></td>
<td width=34%>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>GetNextRows</b></td>
<td width=34%>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>ReleaseRows</b></td>
<td width=34%>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>RestartPosition</b></td>
<td width=34%>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IRowsetInfo</b></td>
<td width=33%><b>GetProperties</b></td>
<td width=34%>RowInfo.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>GetReferencedRowset</b></td>
<td width=34%>RowInfo.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>GetSpecification</b></td>
<td width=34%>RowInfo.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>IRowsetChange</b></td>
<td width=33%><b>DeleteRows</b></td>
<td width=34%>RowChng.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>InsertRow</b></td>
<td width=34%>RowChng.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>SetData</b></td>
<td width=34%>RowChng.cpp</td>
</tr>
<tr valign=top>
<td width=33%><b>ISessionProperties</b></td>
<td width=33%><b>GetProperties</b> </td>
<td width=34%>DBSess.cpp</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%><b>SetProperties</b></td>
<td width=34%>DBSess.cpp</td>
</tr>
</table><br>
<h1>Setting and Getting Provider Properties</h1>
<p>
The data source object is the first object created when a consumer instantiates an OLE DB data provider by calling <b>CoCreateInstance</b> or through some other technique.</p>
<p>
The data source object provides the starting point for communications between the provider and consumer. For example, a consumer can call <b>CoCreateInstance</b> and request an <b>IDBInitialize</b> interface pointer to instantiate a data source object. The provider’s developer must generate a CLSID (class ID) and store the ID in the Windows Registry. The consumer can use this CLSID with <b>CoCreateInstance</b> to instantiate the data source object. To facilitate this operation, providers should add their application or library information to the Windows Registry upon installation on a new system. The sample provider setup program registers the sample provider in the Windows Registry.</p>
<p>
The data source object is also responsible for setting and returning information about the properties supported by the provider and exposing the list of supported keywords and literals. This functionality is supported through the mandatory <b>IDBProperties</b> interface and the optional <b>IDBInfo</b> interface. The <b>IDBProperties</b> interface contains three methods:
<ul type=disc>
<li>
<b>GetProperties</b> returns the list of properties currently set on the data source object.<br><br></li>
<li>
<b>GetPropertyInfo</b> returns information about supported rowset and data source properties.<br><br></li>
<li>
<b>SetProperties</b> sets the properties on the data source object.</li>
</ul>
<p>
The <b>IDBInfo</b> interface contains two methods:
<ul type=disc>
<li>
<b>GetKeywords</b> returns a list of supported keywords.<br><br></li>
<li>
<b>GetLiteralInfo</b> returns information about literals used in text commands.</li>
</ul>
<p>
In the sample provider implementation, no command interfaces are implemented, so <b>GetKeywords</b> returns NULL. <b>GetLiteralInfo</b> is not implemented and returns E_NOTIMPL. <b>GetProperties</b>, <b>GetPropertyInfo</b>, and <b>SetProperties</b> are handled by passing the calls to the utility object that manages properties, which is found in UtilProp.cpp. The structure containing the properties known to the sample provider, which is also found in UtilProp.cpp, follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// Struct containing the properties we know about. The GUID and string fields are</code><pre><code>// initialized in the constructor, because C++ makes it awkward to do so at declaration
// time. So, if you change this table, be sure to make parallel changes in CUtilProp::CUtilProp.
PROPSTRUCT s_rgprop[] =
 {
/* 0 */ {DBPROP_IAccessor,&nbsp;&nbsp; FLAGS_ROWSETRO, VT_BOOL, TRUE,&nbsp; 0, NULL,&nbsp;&nbsp; L"IAccessor"},
/* 1 */ {DBPROP_IColumnsInfo,&nbsp; FLAGS_ROWSETRO, VT_BOOL, TRUE,&nbsp; 0, NULL,&nbsp;&nbsp; L"IColumnsInfo"},
/* 2 */ {DBPROP_IConvertType,&nbsp; FLAGS_ROWSETRO, VT_BOOL, TRUE,&nbsp; 0, NULL,&nbsp;&nbsp; L"IConvertType"},
/* 3 */ {DBPROP_IRowset,&nbsp;&nbsp; FLAGS_ROWSETRO, VT_BOOL, TRUE,&nbsp; 0, NULL,&nbsp;&nbsp; L"IRowset"},
/* 4 */ {DBPROP_IRowsetChange, FLAGS_ROWSETRW, VT_BOOL, TRUE,&nbsp; 0, NULL,&nbsp;&nbsp; L"IRowsetChange"},
/* 5 */ {DBPROP_IRowsetInfo,&nbsp;&nbsp; FLAGS_ROWSETRO, VT_BOOL, TRUE,&nbsp; 0, NULL,&nbsp;&nbsp; L"IRowsetInfo"},
/* 6 */ {DBPROP_ACTIVESESSIONS,&nbsp; FLAGS_DATASOURCE, VT_I4, FALSE, 1, NULL,&nbsp;&nbsp; L"Active Sessions"},
/* 7 */ {DBPROP_PROVIDERNAME,&nbsp; FLAGS_DATASOURCE, VT_BSTR, FALSE, 0, L"SAMPPROV.DLL",L"Provider Name"},
/* 8 */ {DBPROP_PROVIDEROLEDBVER,FLAGS_DATASOURCE, VT_BSTR, FALSE, 0, L"01.10",&nbsp;&nbsp; L"OLE DB Version"},
/* 9 */ {DBPROP_PROVIDERVER,&nbsp;&nbsp; FLAGS_DATASOURCE, VT_BSTR, FALSE, 0, _TEXT(VER_PRODUCTVERSION_STR), L"Provider Version"},
/* 10*/ {DBPROP_INIT_DATASOURCE, FLAGS_DBINITRW, VT_BSTR, FALSE, 0, L"",&nbsp;&nbsp;&nbsp; L"Data Source"},
/* 11*/ {DBPROP_INIT_HWND,&nbsp;&nbsp; FLAGS_DBINITRW, VT_I4, FALSE, 0, NULL,&nbsp;&nbsp; L"Window Handle"},
/* 12*/ {DBPROP_INIT_PROMPT,&nbsp;&nbsp; FLAGS_DBINITRW, VT_I2, FALSE, 4, NULL,&nbsp;&nbsp; L"Prompt"}
  };</code></pre>
</pre>
</td>
</tr>
</table><br>
<p>
The source code for <b>GetPropertyInfo</b>, which passes property information back to the provider, follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CUtilProp::GetPropertyInfo&nbsp; -----------------------------------------</code><pre><code>//
// @mfunc Returns information about rowset and data source properties 
//&nbsp;&nbsp; supported by the provider
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag E_INVALIDARG&nbsp; | pcPropertyIDSets or prgPropertyInfo was NULL
//&nbsp; @flag E_OUTOFMEMORY | Out of memory
//

STDMETHODIMP CUtilProp::GetPropertyInfo
  (
  BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fDSOInitialized,&nbsp;&nbsp; //@parm IN&nbsp; | if Initialized
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cPropertyIDSets,&nbsp;&nbsp; //@parm IN&nbsp; | # properties
  const DBPROPIDSET rgPropertyIDSets[],&nbsp; //@parm IN&nbsp; | Array of property sets
  ULONG*&nbsp;&nbsp;&nbsp; pcPropertyInfoSets,&nbsp; //@parm OUT | # DBPROPSET structures
  DBPROPINFOSET** prgPropertyInfoSets, //@parm OUT | DBPROPSET structures property 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; | information returned
  WCHAR**&nbsp;&nbsp;&nbsp;&nbsp; ppDescBuffer&nbsp;&nbsp; //@parm OUT | Property descriptions
  )
{
 BOOL&nbsp;&nbsp;&nbsp;&nbsp; fRet&nbsp;&nbsp;&nbsp;&nbsp; = TRUE;
 BOOL&nbsp;&nbsp;&nbsp;&nbsp; fPropsinError&nbsp; = FALSE;
 BOOL&nbsp;&nbsp;&nbsp;&nbsp; fPropsSucceed&nbsp; = FALSE;
 BOOL&nbsp;&nbsp;&nbsp;&nbsp; fIsSpecialGUID&nbsp;&nbsp; = FALSE;
 BOOL&nbsp;&nbsp;&nbsp;&nbsp; fIsNotSpecialGUID&nbsp; = FALSE;
 ULONG&nbsp;&nbsp;&nbsp; cProps&nbsp;&nbsp;&nbsp;&nbsp; = 0;
 ULONG&nbsp;&nbsp;&nbsp; cCount&nbsp;&nbsp;&nbsp;&nbsp; = 0;
 ULONG&nbsp;&nbsp;&nbsp; ulPropertySets&nbsp;&nbsp; = 0;
 WCHAR*&nbsp;&nbsp; pDescBuffer&nbsp;&nbsp;&nbsp; = NULL;
 DBPROPINFO*&nbsp; pPropInfo;
 DBPROPINFOSET* pPropInfoSet;

 // init out params
 if (pcPropertyInfoSets)
  *pcPropertyInfoSets&nbsp; = 0;
 if (prgPropertyInfoSets)
  *prgPropertyInfoSets = NULL;
 if (ppDescBuffer)
  *ppDescBuffer = NULL;

 // Check Arguments, on failure post HRESULT to error queue
 if( ((cPropertyIDSets &gt; 0) &amp;&amp; !rgPropertyIDSets) ||
  !pcPropertyInfoSets || !prgPropertyInfoSets )
  return ResultFromScode( E_INVALIDARG );

 // New argument check for &gt; 1 cPropertyIDs and NULL pointer for 
 // array of property ids.
 for(ULONG ul=0; ul&lt;cPropertyIDSets; ul++)
 {
  if( rgPropertyIDSets[ul].cPropertyIDs &amp;&amp; !(rgPropertyIDSets[ul].rgPropertyIDs) )
 &nbsp; return ResultFromScode( E_INVALIDARG );
  
  if (DBPROPSET_ROWSETALL == rgPropertyIDSets[ul].guidPropertySet&nbsp;&nbsp;&nbsp; ||
 &nbsp; DBPROPSET_DATASOURCEALL == rgPropertyIDSets[ul].guidPropertySet&nbsp;&nbsp; ||
 &nbsp; DBPROPSET_DATASOURCEINFOALL == rgPropertyIDSets[ul].guidPropertySet ||
 &nbsp; DBPROPSET_SESSIONALL == rgPropertyIDSets[ul].guidPropertySet&nbsp;&nbsp;&nbsp; ||
 &nbsp; DBPROPSET_DBINITALL == rgPropertyIDSets[ul].guidPropertySet)
 &nbsp; fIsSpecialGUID = TRUE;
  else
 &nbsp; fIsNotSpecialGUID = TRUE;

  if(fIsSpecialGUID &amp;&amp; fIsNotSpecialGUID)
 &nbsp; return ResultFromScode( E_INVALIDARG );
 }

 // save the count of PropertyIDSets
 cProps = cPropertyIDSets;

 // If the consumer does not restrict the property sets
 // by specify an array of property sets and a cPropertySets
 // greater than 0, then we need to make sure we 
 // have some to return
 if ( (cPropertyIDSets == 0) )
 {
  if( fDSOInitialized )
 &nbsp; cProps = NUMBER_OF_SUPPORTED_PROPERTY_SETS;
  else
 &nbsp; cProps = 1;
 } 

 // use task memory allocater to alloc a DBPROPINFOSET struct
 pPropInfoSet = (DBPROPINFOSET*) g_pIMalloc-&gt;Alloc(cProps *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( DBPROPINFOSET ));
 if ( !pPropInfoSet )
  return ResultFromScode( E_OUTOFMEMORY );

 memset( pPropInfoSet, 0, (cProps * sizeof( DBPROPINFOSET )));

 // Alloc memory for ppDescBuffer
 if ( ppDescBuffer )
 {
  pDescBuffer = (WCHAR*)g_pIMalloc-&gt;Alloc(NUMBER_OF_SUPPORTED_PROPERTIES * 
 &nbsp; CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE * sizeof(WCHAR) );
  
  if( pDescBuffer )
  {
 &nbsp; memset(pDescBuffer, 0, (NUMBER_OF_SUPPORTED_PROPERTIES * 
 &nbsp;&nbsp; CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE * sizeof(WCHAR)));
  
 &nbsp; *ppDescBuffer = pDescBuffer;
  }
  else
  {
 &nbsp; g_pIMalloc-&gt;Free( pPropInfoSet );
 &nbsp; return ResultFromScode( E_OUTOFMEMORY );
  }
 }

 // For each supported Property Set
 for (ulPropertySets=0; ulPropertySets &lt; cProps; ulPropertySets++)
 {
  BOOL fGetAllProps = FALSE;

  // If no restrictions return all properties from the three supported property sets
  if( cPropertyIDSets == 0 )
  {
 &nbsp; fGetAllProps = TRUE;

 &nbsp; // only do this once
 &nbsp; if (ulPropertySets == 0)
 &nbsp; {
 &nbsp;&nbsp; pPropInfoSet[0].guidPropertySet = DBPROPSET_DBINIT;
 &nbsp;&nbsp; pPropInfoSet[0].cPropertyInfos&nbsp; = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

 &nbsp;&nbsp; if ( fDSOInitialized )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; pPropInfoSet[1].guidPropertySet = DBPROPSET_DATASOURCEINFO;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[1].cPropertyInfos&nbsp; = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[2].guidPropertySet = DBPROPSET_ROWSET;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[2].cPropertyInfos&nbsp; = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
 &nbsp;&nbsp; }
 &nbsp; }
  }
  else
  {
 &nbsp; pPropInfoSet[ulPropertySets].guidPropertySet = rgPropertyIDSets[ulPropertySets].guidPropertySet;
 &nbsp; pPropInfoSet[ulPropertySets].cPropertyInfos&nbsp; = rgPropertyIDSets[ulPropertySets].cPropertyIDs;

 &nbsp; if ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINITALL) ||
 &nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT&nbsp;&nbsp; &amp;&amp;
 &nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0))
 &nbsp; {
 &nbsp;&nbsp; fGetAllProps = TRUE;
 &nbsp;&nbsp; pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_DBINIT;
 &nbsp;&nbsp; pPropInfoSet[ulPropertySets].cPropertyInfos&nbsp; = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;
 &nbsp; }
 &nbsp; else if (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEALL)
 &nbsp; {
 &nbsp;&nbsp; // Since we do not support it should return DB_E_ERRORSOCCURRED with 0 &amp; NULL
 &nbsp;&nbsp; fPropsinError = TRUE;
 &nbsp;&nbsp; pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_DATASOURCE;
 &nbsp;&nbsp; pPropInfoSet[ulPropertySets].cPropertyInfos&nbsp; = 0;
 &nbsp; }
 &nbsp; else if( fDSOInitialized )
 &nbsp; {
 &nbsp;&nbsp; if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFOALL) ||
 &nbsp;&nbsp;&nbsp; ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)) )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; fGetAllProps = TRUE;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_DATASOURCEINFO;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[ulPropertySets].cPropertyInfos&nbsp; = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_SESSIONALL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; // Since we do not support it should return a error with 0 &amp; NULL
 &nbsp;&nbsp;&nbsp; fPropsinError = TRUE;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_SESSION;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[ulPropertySets].cPropertyInfos&nbsp; = 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSETALL) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)) )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; fGetAllProps = TRUE;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_ROWSET;
 &nbsp;&nbsp;&nbsp; pPropInfoSet[ulPropertySets].cPropertyInfos&nbsp; = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)
 &nbsp;&nbsp;&nbsp; fPropsinError = TRUE;
 &nbsp; }
 &nbsp; else if (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)
 &nbsp; {
 &nbsp;&nbsp; // Since we do not support it should return a error with 0 &amp; NULL
 &nbsp;&nbsp; fPropsinError = TRUE;
 &nbsp; }
  }
  
  if (pPropInfoSet[ulPropertySets].cPropertyInfos)
  {
 &nbsp;&nbsp; // use task memory allocater to alloc array of DBPROPINFO structs
 &nbsp; pPropInfo = (DBPROPINFO*) g_pIMalloc-&gt;Alloc(sizeof( DBPROPINFO ) *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropInfoSet[ulPropertySets].cPropertyInfos);

 &nbsp; if (!pPropInfo)
 &nbsp; {
 &nbsp;&nbsp; if ( ppDescBuffer ) 
 &nbsp;&nbsp;&nbsp; *ppDescBuffer = NULL;
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pPropInfoSet );
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pDescBuffer );
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return ResultFromScode( E_OUTOFMEMORY );
 &nbsp; }
  
 &nbsp; pPropInfoSet[ulPropertySets].rgPropertyInfos = &amp;pPropInfo[0];

 &nbsp; memset( pPropInfo, 0, 
 &nbsp;&nbsp; (pPropInfoSet[ulPropertySets].cPropertyInfos * sizeof( DBPROPINFO )));
  }

 &nbsp; // for each prop in our table..
  for (cCount=0; cCount &lt; pPropInfoSet[ulPropertySets].cPropertyInfos; cCount++)
  {
 &nbsp; // init the Variant right up front
 &nbsp; // that way we can VariantClear with no worried (if we need to)
 &nbsp; VariantInit( &amp;pPropInfo[cCount].vValues );

 &nbsp; // set the description pointer
 &nbsp; pPropInfo[cCount].pwszDescription = pDescBuffer;

 &nbsp; // Check supported property sets
 &nbsp; if ( (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT) &amp;&amp; 
 &nbsp;&nbsp;&nbsp; (fGetAllProps) )
 &nbsp; {
 &nbsp;&nbsp; // load up their DBPROPINFO from our table
 &nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp; fRet = LoadDBPROPINFO( &amp;m_rgproperties[START_OF_SUPPORTED_DBINIT_PROPERTIES + cCount], 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pPropInfo[cCount] );
 &nbsp; }
 &nbsp; else if ( (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp; fGetAllProps &amp;&amp; fDSOInitialized)
 &nbsp; {
 &nbsp;&nbsp; // load up their DBPROPINFO from our table
 &nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp; fRet = LoadDBPROPINFO( &amp;m_rgproperties[START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + cCount], 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pPropInfo[cCount] );
 &nbsp; }

 &nbsp; else if ( (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fGetAllProps &amp;&amp; fDSOInitialized)
 &nbsp; {
 &nbsp;&nbsp; // load up their DBPROPINFO from our table
 &nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp; fRet = LoadDBPROPINFO( &amp;m_rgproperties[START_OF_SUPPORTED_ROWSET_PROPERTIES + cCount], 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pPropInfo[cCount] );
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp; ULONG ulIndex;

 &nbsp;&nbsp; pPropInfo[cCount].dwPropertyID = rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount];
 &nbsp;&nbsp; pPropInfo[cCount].dwFlags&nbsp; = DBPROPFLAGS_NOTSUPPORTED;

 &nbsp;&nbsp; if ( (GetPropIndex(rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount], &amp;ulIndex)) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; (fDSOInitialized || (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT)) )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp;&nbsp; fRet = LoadDBPROPINFO( &amp;m_rgproperties[ulIndex], &amp;pPropInfo[cCount] );
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; fPropsinError = TRUE;
 &nbsp;&nbsp;&nbsp; pPropInfo[cCount].pwszDescription = NULL;
 &nbsp;&nbsp; }
 &nbsp; }

 &nbsp; if (!fRet)
 &nbsp; {
 &nbsp;&nbsp; ULONG ulFor;

 &nbsp;&nbsp; // something went wrong
 &nbsp;&nbsp; // clear all variants used so far..
 &nbsp;&nbsp; for (ulFor = 0; ulFor &lt; cCount; ulFor++)
 &nbsp;&nbsp;&nbsp; VariantClear( &amp;pPropInfo[ulFor].vValues );

 &nbsp;&nbsp; // .. delete the pPropInfo array, return failure
 &nbsp;&nbsp; if ( ppDescBuffer ) *ppDescBuffer = NULL;
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pPropInfo );
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pPropInfoSet );
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pDescBuffer );
 &nbsp;&nbsp; return ResultFromScode( E_FAIL );
 &nbsp; }

 &nbsp; // move the description pointer to the next
 &nbsp; if ( pPropInfo[cCount].pwszDescription )
 &nbsp;&nbsp; pDescBuffer += (wcslen(pPropInfo[cCount].pwszDescription) + sizeof(CHAR));
  }
  // Set local back to FALSE
  fGetAllProps = FALSE;
 }

 // set count of properties and property information
 *pcPropertyInfoSets&nbsp; = cProps;
 *prgPropertyInfoSets = pPropInfoSet;

 if ( !fPropsSucceed &amp;&amp; fPropsinError )
 {
  if ( ppDescBuffer ) *ppDescBuffer = NULL;
  g_pIMalloc-&gt;Free( pDescBuffer );
  return ResultFromScode( DB_E_ERRORSOCCURRED );
 }
 else if ( fPropsSucceed &amp;&amp; fPropsinError )
  return ResultFromScode( DB_S_ERRORSOCCURRED );
 else
  return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<p>
The source code for <b>GetProperties</b>, which returns the current settings of all supported properties, follows. Immediately following the creation of the data source object, none of the properties are set. Properties are set by the <b>SetProperties</b> method.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CUtilProp::GetProperties ----------------------------------------------------</code><pre><code>//
// @mfunc Returns current settings of all properties supported by the DSO/rowset
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag E_INVALIDARG&nbsp; | pcProperties or prgPropertyInfo was NULL
//&nbsp; @flag E_OUTOFMEMORY | Out of memory
//
STDMETHODIMP CUtilProp::GetProperties
  (
  DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwBitMask,&nbsp;&nbsp;&nbsp;&nbsp; //@parm IN&nbsp; | Mask if Initialized
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cPropertyIDSets,&nbsp;&nbsp; //@parm IN&nbsp; | # of restiction property IDs
  const DBPROPIDSET rgPropertyIDSets[],&nbsp; //@parm IN&nbsp; | restriction guids
  ULONG*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcPropertySets,&nbsp; //@parm OUT | count of properties returned
  DBPROPSET**&nbsp;&nbsp; prgPropertySets&nbsp; //@parm OUT | property information returned
  )
{
 BOOL&nbsp;&nbsp; fRet&nbsp;&nbsp;&nbsp;&nbsp; = TRUE;
 BOOL&nbsp;&nbsp; fPropsinError&nbsp; = FALSE;
 BOOL&nbsp;&nbsp; fPropsSucceed&nbsp; = FALSE;
 ULONG&nbsp;&nbsp;&nbsp; cProps&nbsp;&nbsp; = 0;
 ULONG&nbsp;&nbsp;&nbsp; cCount&nbsp;&nbsp; = 0;
 ULONG&nbsp;&nbsp;&nbsp; ulPropertySets = 0;
 DBPROP*&nbsp; pProp;
 DBPROPSET* pPropSet;

 // save the count of PropertyIDSets
 cProps = cPropertyIDSets;

 // If the consumer does not restrict the property sets
 // by specify an array of property sets and a cPropertySets
 // greater than 0, then we need to make sure we 
 // have some to return
 if( cPropertyIDSets == 0 )
 {
  // only allow the DBINIT and DATASOURCE if Initialized
  if ( (dwBitMask &amp; PROPSET_DSOINIT) == PROPSET_DSOINIT )
 &nbsp; cProps = 2;
  else
 &nbsp; cProps = 1;
 }

 // use task memory allocater to alloc a DBPROPINFOSET struct
 pPropSet = (DBPROPSET*) g_pIMalloc-&gt;Alloc(cProps *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( DBPROPSET ));
 if ( !pPropSet )
  return ResultFromScode( E_OUTOFMEMORY );

 memset( pPropSet, 0, (cProps * sizeof( DBPROPSET )));

 // For each supported Property Set
 for (ulPropertySets=0; ulPropertySets &lt; cProps; ulPropertySets++)
 {
  BOOL fGetAllProps = FALSE;

  // If no restrictions return all properties from the three supported property sets
  if ( cPropertyIDSets == 0 )
  {
 &nbsp;&nbsp; fGetAllProps = TRUE;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // only do this once
 &nbsp;&nbsp; if ( ulPropertySets == 0 )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; if( !(dwBitMask &amp; PROPSET_SESSION) )
 &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; if ( !(dwBitMask &amp; PROPSET_ROWSET) )
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropSet[0].guidPropertySet = DBPROPSET_DBINIT;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropSet[0].cProperties&nbsp; = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( dwBitMask &amp; PROPSET_INIT )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropSet[1].guidPropertySet = DBPROPSET_DATASOURCEINFO;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropSet[1].cProperties&nbsp; = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropSet[0].guidPropertySet = DBPROPSET_ROWSET;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropSet[0].cProperties&nbsp; = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
  }
  else
  {
 &nbsp; pPropSet[ulPropertySets].guidPropertySet = rgPropertyIDSets[ulPropertySets].guidPropertySet;
 &nbsp; pPropSet[ulPropertySets].cProperties&nbsp; = rgPropertyIDSets[ulPropertySets].cPropertyIDs;

 &nbsp; if( rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0 )
 &nbsp; {
 &nbsp;&nbsp; fGetAllProps = TRUE;

 &nbsp;&nbsp; if( rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; pPropSet[ulPropertySets].cProperties&nbsp; = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((dwBitMask &amp; PROPSET_DSOINIT) == PROPSET_DSOINIT) )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; pPropSet[ulPropertySets].cProperties&nbsp; = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (dwBitMask &amp; PROPSET_ROWSET))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; pPropSet[ulPropertySets].cProperties&nbsp; = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; fGetAllProps = FALSE;
 &nbsp;&nbsp; }
 &nbsp; }
  }
  
  if( pPropSet[ulPropertySets].cProperties )
  {
 &nbsp;&nbsp; // use task memory allocater to alloc array of DBPROPINFO structs
 &nbsp; pProp = (DBPROP*) g_pIMalloc-&gt;Alloc(sizeof( DBPROP ) *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPropSet[ulPropertySets].cProperties);

 &nbsp; if (!pProp)
 &nbsp; {
 &nbsp;&nbsp; for(ULONG ul=0; ul&lt;ulPropertySets; ul++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; for(ULONG ul2=0; ul2&lt;pPropSet[ul].cProperties; ul2++)
 &nbsp;&nbsp;&nbsp;&nbsp; VariantClear( &amp;pPropSet[ul].rgProperties[ul2].vValue );

 &nbsp;&nbsp;&nbsp; g_pIMalloc-&gt;Free( pPropSet[ul].rgProperties );
 &nbsp;&nbsp; }
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pPropSet );

 &nbsp;&nbsp; return ResultFromScode( E_OUTOFMEMORY );
 &nbsp; }
  
 &nbsp; pPropSet[ulPropertySets].rgProperties = &amp;pProp[0];

 &nbsp; memset( pProp, 0, 
 &nbsp;&nbsp; (pPropSet[ulPropertySets].cProperties * sizeof( DBPROP )));
  }

 &nbsp; // for each prop in our table..
  for (cCount=0; cCount &lt; pPropSet[ulPropertySets].cProperties; cCount++)
  {
 &nbsp; // init the Variant right up front
 &nbsp; // that way we can VariantClear with no worried (if we need to)
 &nbsp; VariantInit( &amp;pProp[cCount].vValue );

 &nbsp; // Check supported property sets
 &nbsp; if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT &amp;&amp;
 &nbsp;&nbsp;&nbsp; fGetAllProps )
 &nbsp; {
 &nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp; // load up their DBPROP from our table
 &nbsp;&nbsp; fRet = LoadDBPROP( &amp;m_rgproperties[START_OF_SUPPORTED_DBINIT_PROPERTIES + cCount], 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pProp[cCount] );
 &nbsp; }
 &nbsp; else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; fGetAllProps )
 &nbsp; {
 &nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp; // load up their DBPROPINFO from our table
 &nbsp;&nbsp; fRet = LoadDBPROP( &amp;m_rgproperties[START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + cCount], 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pProp[cCount] );
 &nbsp; }
 &nbsp; else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; fGetAllProps )
 &nbsp; {
 &nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp; // load up their DBPROPINFO from our table
 &nbsp;&nbsp; fRet = LoadDBPROP( &amp;m_rgproperties[START_OF_SUPPORTED_ROWSET_PROPERTIES + cCount], 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pProp[cCount] );
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp; ULONG ulIndex;

 &nbsp;&nbsp; pProp[cCount].dwPropertyID = rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount];
 &nbsp;&nbsp; pProp[cCount].dwStatus&nbsp; = DBPROPSTATUS_NOTSUPPORTED;

 &nbsp;&nbsp; if(&nbsp; (GetPropIndex(rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount], &amp;ulIndex)) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; (((dwBitMask &amp; PROPSET_DSO) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT)) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((dwBitMask &amp; PROPSET_DSOINIT) == PROPSET_DSOINIT) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCE) ||
 &nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO))) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((dwBitMask &amp; PROPSET_SESSION) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_SESSION)) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((dwBitMask &amp; PROPSET_ROWSET) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET))) )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; fPropsSucceed = TRUE;
 &nbsp;&nbsp;&nbsp; fRet = LoadDBPROP( &amp;m_rgproperties[ulIndex], &amp;pProp[cCount] );
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp; fPropsinError = TRUE;
 &nbsp; }

 &nbsp; if (!fRet)
 &nbsp; {
 &nbsp;&nbsp; ULONG ulFor;

 &nbsp;&nbsp; // something went wrong
 &nbsp;&nbsp; // clear all variants used so far..
 &nbsp;&nbsp; for (ulFor = 0; ulFor &lt; cCount; ulFor++)
 &nbsp;&nbsp;&nbsp; VariantClear( &amp;pProp[ulFor].vValue );

 &nbsp;&nbsp; // .. delete the pPropInfo array, return failure
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pProp );
 &nbsp;&nbsp; g_pIMalloc-&gt;Free( pPropSet );
 &nbsp;&nbsp; return ResultFromScode( E_FAIL );
 &nbsp; }
  }
  // Set local back to FALSE
  fGetAllProps = FALSE;
 }

 // set count of properties and property information
 *pcPropertySets&nbsp; = cProps;
 *prgPropertySets = pPropSet;

 if ( !fPropsSucceed &amp;&amp; fPropsinError )
  return ResultFromScode( DB_E_ERRORSOCCURRED );
 else if ( fPropsSucceed &amp;&amp; fPropsinError )
  return ResultFromScode( DB_S_ERRORSOCCURRED );
 else
  return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<p>
The source code for <b>SetProperties</b>, which sets the values of all supported properties, follows. The consumer must set properties on the provider before initializing the data source object. In most providers, these properties provide information such as a database location, database name, user ID, and password. The sample provider requires only one value: a valid directory path to the data file.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CUtilProp::SetProperties ----------------------------------------------------</code><pre><code>//
// @mfunc Set current settings of properties supported by the DSO/rowset
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag E_INVALIDARG&nbsp; | pcProperties or prgPropertyInfo was NULL
//&nbsp; @flag E_OUTOFMEMORY | Out of memory
//
STDMETHODIMP CUtilProp::SetProperties
  (
  DWORD&nbsp;&nbsp;&nbsp; dwBitMask,&nbsp;&nbsp; //@parm IN&nbsp; Type of PropSet
  ULONG&nbsp;&nbsp;&nbsp; cPropertyIDSets, //@parm IN&nbsp; # of DBPROPSET
  DBPROPSET&nbsp;&nbsp;&nbsp; rgPropertyIDSets[] //@parm INOUT Array of property sets
 )
{
 ULONG ulPropertySets&nbsp; = 0;
 ULONG cCount&nbsp;&nbsp;&nbsp; = 0;
 BOOL&nbsp; fSetAllProps&nbsp; = TRUE;
 BOOL&nbsp; fOnePropSet&nbsp;&nbsp; = FALSE;

 // For each supported Property Set
 for (ulPropertySets=0; ulPropertySets &lt; cPropertyIDSets; ulPropertySets++)
 {
  ULONG ulIndex = 0;

 &nbsp; // for each prop in the propset
  for (cCount=0; cCount &lt; rgPropertyIDSets[ulPropertySets].cProperties; cCount++)
  {
 &nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_OK;
 &nbsp; 
 &nbsp; // only allow the DBINIT and DATASOURCE
 &nbsp; if ( (dwBitMask &amp; PROPSET_DSO) &amp;&amp;
 &nbsp;&nbsp;&nbsp; ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp; (dwBitMask &amp; PROPSET_INIT)) )
 &nbsp; {
 &nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSETTABLE;
 &nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp; }
 &nbsp; else if ( ((dwBitMask &amp; PROPSET_DSO) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_DATASOURCE &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_DBINIT)) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCE &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp; !(dwBitMask &amp; PROPSET_INIT)) )
 &nbsp; {
 &nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
 &nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp; }
 &nbsp; // only allow the SESSION
 &nbsp; else if ( (dwBitMask &amp; PROPSET_SESSION) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_SESSION) )
 &nbsp; {
 &nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
 &nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp; }
 &nbsp; // only allow the ROWSET
 &nbsp; else if ( (dwBitMask &amp; PROPSET_ROWSET) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_ROWSET) )
 &nbsp; {
 &nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
 &nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp; // get the index in the array
 &nbsp;&nbsp; if ( GetPropIndex(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwPropertyID, &amp;ulIndex) )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; // arg checking for the prop
 &nbsp;&nbsp;&nbsp; if ( (DBPROPOPTIONS_SETIFCHEAP != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (DBPROPOPTIONS_REQUIRED != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions) )
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_BADOPTION;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else if ( ((m_rgproperties[ulIndex].vtType != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VT_EMPTY != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt)) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IsValidValue(&amp;rgPropertyIDSets[ulPropertySets].rgProperties[cCount]) == S_FALSE)) 
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_BADVALUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else if ( !(m_rgproperties[ulIndex].dwFlags &amp; DBPROPFLAGS_WRITE) )
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if ( ((rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == VT_BOOL) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.boolVal != m_rgproperties[ulIndex].boolVal)) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == VT_I4) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.lVal != m_rgproperties[ulIndex].longVal)) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == VT_BSTR) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (wcscmp(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.bstrVal,m_rgproperties[ulIndex].pwstrVal))) )
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSETTABLE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fOnePropSet = TRUE;

 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; fOnePropSet = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; if( rgPropertyIDSets[ulPropertySets].rgProperties-&gt;vValue.vt == VT_EMPTY )
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy( &amp;m_rgproperties[ulIndex], &amp;s_rgprop[ulIndex], sizeof(PROPSTRUCT));
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // switch on the propid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( m_rgproperties[ulIndex].dwPropertyID )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DBPROP_INIT_DATASOURCE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcscpy(m_wszFilePath, V_BSTR(&amp;rgPropertyIDSets[ulPropertySets].rgProperties-&gt;vValue));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_rgproperties[ulIndex].pwstrVal = m_wszFilePath;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DBPROP_INIT_HWND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DBPROP_INIT_PROMPT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_rgproperties[ulIndex].longVal = V_I4(&amp;rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DBPROP_IRowsetChange:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_rgproperties[ulIndex].boolVal = V_BOOL(&amp;rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
 &nbsp;&nbsp;&nbsp; fSetAllProps = FALSE;
 &nbsp;&nbsp; }
 &nbsp; }
  }
 }
 
 // Figure out the retcode
 if ( fSetAllProps )
  return ResultFromScode( S_OK );
 else if ( fOnePropSet &amp;&amp; !fSetAllProps )
  return ResultFromScode( DB_S_ERRORSOCCURRED );
 else 
  return ResultFromScode( DB_E_ERRORSOCCURRED );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Initializing and Uninitializing the Data Source Object</h1>
<p>
The <b>IDBInitialize</b> interface contains two methods: <b>Initialize</b> and <b>Uninitialize</b>. The following sections discuss the implementation of these methods in the sample provider.</p>
<h1>Initializing the Data Source Object</h1>
<p>
<b>Initialize</b> enables consumers to explicitly initialize a data source object. Consumers must set properties on the data source object before attempting to initialize it; and consumers must supply a valid directory path to the data file in <b>IDBProperties::SetProperties</b>. If the directory path is invalid, the sample provider returns an E_FAIL error on initialization. The source code for <b>IDBInitialize::Initialize</b> follows; you can find the complete source code for <b>IDBInitialize</b> in DBInit.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIDBInitialize::Initialize ---------------------------------------------</code><pre><code>//
// @mfunc Initializes the DataSource object.. For this provider it requires
// that a valid path is given to where the file will be located.
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp; | Path exists
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp; | Invalid path
//&nbsp; @flag E_INVALIDARG&nbsp; | Invalid Parameters passed in
//&nbsp; @flag DB_E_ALREADYINITIALIZED | Datasource Object already initialized
//
STDMETHODIMP CImpIDBInitialize::Initialize
  (
  )
{
 HRESULT&nbsp;&nbsp; hr;
 DBPROPIDSET rgPropertyIDSets[1];
 ULONG&nbsp;&nbsp; cPropertySets;
 DBPROPSET*&nbsp; prgPropertySets;
 DBPROPID&nbsp; rgPropId[2];

 char szNewVal[MAX_PATH ];
 int&nbsp; nPrompt = DBPROMPT_NOPROMPT;

 assert( m_pObj );

 if (m_pObj-&gt;m_fDSOInitialized)
  return ResultFromScode( DB_E_ALREADYINITIALIZED );

 rgPropId[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DBPROP_INIT_DATASOURCE;
 rgPropId[1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DBPROP_INIT_PROMPT;
 
 rgPropertyIDSets[0].guidPropertySet = DBPROPSET_DBINIT;
 rgPropertyIDSets[0].rgPropertyIDs&nbsp;&nbsp; = rgPropId;
 rgPropertyIDSets[0].cPropertyIDs&nbsp; = 2;

 // Get the value of the DBPROP_INIT_DATASOURCE property
 hr = m_pObj-&gt;m_pUtilProp-&gt;GetProperties( 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROPSET_DSO,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgPropertyIDSets,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cPropertySets,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;prgPropertySets );

 // On failure treat it as if we were opening with prompt..
 if( SUCCEEDED(hr) &amp;&amp; (prgPropertySets[0].rgProperties[0].vValue.vt) )
  WideCharToMultiByte( CP_ACP, 0, V_BSTR(&amp;prgPropertySets[0].rgProperties-&gt;vValue), -1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szNewVal, sizeof( szNewVal ), NULL, NULL );
 else
  *szNewVal = '\0';
 &nbsp; 
 // Get the Prompt value
 nPrompt = V_I2(&amp;prgPropertySets[0].rgProperties[1].vValue);

 // Free the memory
 if (prgPropertySets)
 {
  for(ULONG ulIndex=0; ulIndex&lt;prgPropertySets[0].cProperties; ulIndex++)
 &nbsp; VariantClear(&amp;prgPropertySets[0].rgProperties[ulIndex].vValue);&nbsp; 
  
  g_pIMalloc-&gt;Free(prgPropertySets[0].rgProperties); 
  g_pIMalloc-&gt;Free(prgPropertySets);
 }

 // if caller didn't supply a directory path, ask the user
 if (nPrompt != DBPROMPT_NOPROMPT)
 {
  if (!BrowseDirs( GetDesktopWindow(), g_hInstance, NULL, szNewVal ))
 &nbsp; {
 &nbsp;&nbsp; return ResultFromScode( E_FAIL );
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp; lstrcpyn( m_pObj-&gt;m_szPath, szNewVal, MAX_PATH );
 &nbsp;&nbsp; m_pObj-&gt;m_fDSOInitialized = TRUE;
 &nbsp;&nbsp; return ResultFromScode( S_OK );
 &nbsp; }
 }
 else&nbsp; // caller did supply a directory path
 {
  // Get the current Directory
  char szCurrentDir[MAX_PATH];
  GetCurrentDirectory( MAX_PATH, szCurrentDir );

 &nbsp; // Check if the directory is a valid directory
  if (SetCurrentDirectory( szNewVal ))
  {
 &nbsp; // Restore to the original directory.
 &nbsp; SetCurrentDirectory( szCurrentDir );

 &nbsp; lstrcpyn( m_pObj-&gt;m_szPath, szNewVal, MAX_PATH );
 &nbsp; m_pObj-&gt;m_fDSOInitialized = TRUE;
 &nbsp; return ResultFromScode( S_OK );
  }
  else
  {
 &nbsp; return ResultFromScode( E_FAIL );
  }
 }
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<h1>Uninitializing the Data Source Object</h1>
<p>
<b>Uninitialize</b> enables consumers to return the data source object to an uninitialized state. It is an error to call <b>IDBInitialize::Uninitialize</b> when there are open sessions or rowsets on the data source object. The source code for <b>IDBInitialize::Uninitialize</b> follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIDBInitialize::Uninitialize ---------------------------------------------</code><pre><code>//
// @mfunc Returns the Data Source Object to an uninitialized state
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag DB_E_OBJECTOPEN | A DBSession object was already created
//
STDMETHODIMP CImpIDBInitialize::Uninitialize
  (
  void
  )
{
 assert( m_pObj );

 if (!m_pObj-&gt;m_fDSOInitialized)
 {
  // data source object is not initialized; do nothing
  return ResultFromScode( S_OK );
 }
 else
 {
  if (!m_pObj-&gt;m_fDBSessionCreated)
  {
 &nbsp; // DSO initialized, but no DBSession has been created.
 &nbsp; // So, reset DSO to uninitialized state
 &nbsp; m_pObj-&gt;m_fDSOInitialized = FALSE;
 &nbsp; return ResultFromScode( S_OK );
  }
  else
  {
 &nbsp; // DBSession has already been created; trying to uninit
 &nbsp; // the DSO now is an error
 &nbsp; return ResultFromScode( DB_E_OBJECTOPEN );
  }
 }
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Getting the Class ID of the Data Source Object</h1>
<p>
Consumers can retrieve the class ID of the data source object by calling <b>IPersist::GetClassID</b>. Generally, the consumer does this only when the provider does not support <b>IPersistFile</b> and the consumer wants to persist the class ID and initialization property values for later use.</p>
<p>
The source code for <b>IPersist::GetClassID</b> follows; you can find the complete source code for the <b>IPersist</b> interface in Persist.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIPersist::GetClassID --------------------------------------------------</code><pre><code>//
// @mfunc Get the CLSID of the DSO.
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | The method succeeded.
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Provider-specific error.
//
STDMETHODIMP CImpIPersist::GetClassID( CLSID *pClassID )
{
 // Check the pointer
 if (pClassID)
 {
  memcpy( pClassID, &amp;CLSID_SampProv, sizeof(CLSID) );
  return ResultFromScode(S_OK);
 }
 return ResultFromScode(E_FAIL);
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<h1>Creating a Session</h1>
<p>
After you initialize the data source object, you must create a session object to manage the session and provide the framework needed to create a rowset with <b>IOpenRowset::OpenRowset</b>. The <b>IDBCreateSession::CreateSession</b> interface on the data source object enables you to create a new session object and returns an interface pointer to the session.</p>
<p>
The source code for <b>IDBCreateSession::CreateSession</b> follows; you can find the complete source code for the <b>IDBCreateSession</b> interface in CrtSess.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIDBCreateSession::CreateSession ------------------------------------------------</code><pre><code>//
// @mfunc Creates a new DB Session object from the DSO, and returns the
// requested interface on the newly created object.
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | The method succeeded.
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp; | ppDBSession was NULL
//&nbsp; @flag DB_E_NOAGGREGATION&nbsp; | pUnkOuter was not NULL (this object does not support
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; being aggregated)
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Provider-specific error. This provider can only create
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; one DBSession
//&nbsp; @flag E_OUTOFMEMORY&nbsp;&nbsp; | Out of memory
//&nbsp; @flag E_NOINTERFACE&nbsp;&nbsp; | Could not obtain requested interface on DBSession object
//
STDMETHODIMP CImpIDBCreateSession::CreateSession
  (
  IUnknown* pUnkOuter,&nbsp; //@parm IN | Controlling IUnknown if being aggregated 
  REFIID&nbsp; riid,&nbsp;&nbsp; //@parm IN | The ID of the interface 
  IUnknown**&nbsp; ppDBSession //@parm OUT | A pointer to memory in which to return the interface pointer
  )
{
 CDBSession* pDBSession = NULL;
 HRESULT hr;

 // check in-params and NULL out-params in case of error
 if (ppDBSession)
  *ppDBSession = NULL;
 else
  return ResultFromScode( E_INVALIDARG );

 if (pUnkOuter)
  return ResultFromScode( DB_E_NOAGGREGATION );

 assert( m_pObj );

 // Check to see if the DSO is Uninitialized
 if (!m_pObj-&gt;m_fDSOInitialized)
  return ResultFromScode( E_UNEXPECTED );

 // this Data Source object can only create 1 DBSession...
 if (m_pObj-&gt;m_fDBSessionCreated)
  return ResultFromScode( E_FAIL );

 // open a DBSession object
 pDBSession = new CDBSession( NULL );
 if (!pDBSession)
  return ResultFromScode( E_OUTOFMEMORY );

 // initialize the object
 if (!pDBSession-&gt;FInit( m_pObj-&gt;m_szPath, m_pObj ))
 {
  delete pDBSession;
  return ResultFromScode( E_FAIL );
 }

 // get requested interface pointer on DBSession
 hr = pDBSession-&gt;QueryInterface( riid, (void **) ppDBSession );
 if (FAILED( hr ))
 {
  delete pDBSession;
  return ResultFromScode( hr );
 }

 // all went well
 m_pObj-&gt;m_fDBSessionCreated = TRUE;
 return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<p>
Once the session has been created, the provider must expose the interface pointer to the data source object that created the session. This interface pointer is exposed through the mandatory interface <b>IGetDataSource</b>. The code for <b>IGetDataSource::GetDataSource</b> follows; you can find the complete source code for the <b>IGetDataSource</b> interface in DBSess.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>//-----------------------------------------------------------------------------</code><pre><code>// CImpIGetDataSource::GetDataSource 
//
// @mfunc Retrieve an interface pointer on the session object
//
// @rdesc 
//&nbsp; @flag S_OK | Session Object Interface returned
//&nbsp; @flag E_INVALIDARG | ppDataSource was NULL
//&nbsp; @flag E_NOINTERFACE | IID not supported
//
STDMETHODIMP CImpIGetDataSource::GetDataSource
 (
 REFIID&nbsp; riid,&nbsp;&nbsp; // @parm IN&nbsp; | IID desired
 IUnknown** ppDataSource // @parm OUT | ptr to interface
 )
{
 // Check Function Arguments
 if( ppDataSource == NULL )
  return ResultFromScode(E_INVALIDARG);

 assert( m_pObj-&gt;m_pCDataSource );
 return ((m_pObj-&gt;m_pCDataSource)-&gt;QueryInterface(riid, (LPVOID*)ppDataSource));
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<h1>Creating a Rowset</h1>
<p>
The session contains the interface that enables consumers to open a data file and create a rowset object containing all rows in the data file. The sample provider implements <b>IOpenRowset</b> on the session to create this rowset. The following section describes this interface.</p>
<h1>Instantiating and Exposing a Rowset</h1>
<p>
The <b>IOpenRowset</b> interface contains a single method: <b>OpenRowset</b>. <b>IOpenRowset</b> is a required interface on the session. <b>IOpenRowset::OpenRowset</b> can be used by providers that do not support command objects to generate a rowset of all rows in a table or index. This provides a way for consumers to open and manipulate individual tables or indexes in a database with relatively low resource overhead. In the sample provider implementation, <b>IOpenRowset</b> accepts a file name as the name of the table and concatenates that with the directory name provided through <b>IDBProperties::SetProperties</b>. <b>IOpenRowset</b> uses the directory name and file name to instantiate a rowset and expose the rowset to the consumer.</p>
<p>
The source code for the <b>IOpenRowset::OpenRowset</b> method follows; you can find the complete source code for the <b>IOpenRowset</b> interface in OpnRowst.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIOpenRowset::OpenRowset ------------------------------------------------</code><pre><code>//
// @mfunc Opens and returns a rowset that includes all rows from a single base table
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp; | pTableID was NULL
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Provider-specific error
//&nbsp; @flag DB_E_NOTABLE&nbsp;&nbsp;&nbsp; | Specified table does not exist in current Data
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Data Source object
//&nbsp; @flag E_OUTOFMEMORY&nbsp;&nbsp; | Out of memory
//&nbsp; @flag E_NOINTERFACE&nbsp;&nbsp; | The requested interface was not available

STDMETHODIMP CImpIOpenRowset::OpenRowset
 (
 IUnknown*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pUnkOuter,&nbsp;&nbsp;&nbsp; //@parm IN&nbsp; | Controlling unknown, if any
 DBID*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTableID,&nbsp;&nbsp;&nbsp;&nbsp; //@parm IN&nbsp; | table to open
 DBID*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIndexID,&nbsp;&nbsp;&nbsp;&nbsp; //@parm IN&nbsp; | DBID of the index
 REFIID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; riid,&nbsp;&nbsp;&nbsp;&nbsp; //@parm IN&nbsp; | interface to return
 ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cProperties,&nbsp;&nbsp;&nbsp; //@parm IN&nbsp; | count of properties
 DBPROPSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgProperties[],&nbsp;&nbsp; //@parm INOUT | array of property values
 IUnknown**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ppRowset&nbsp;&nbsp;&nbsp; //@parm OUT | where to return interface
 )
{
 int&nbsp; cCharsCopied;
 char szFileName[MAX_PATH ];
 char szFile[_MAX_PATH ] = "";

 CFileIO*&nbsp; pFileio = NULL;
 CRowset*&nbsp; pRowset = NULL;
 HRESULT&nbsp;&nbsp; hr;
 HRESULT&nbsp;&nbsp; hrProp&nbsp; = ResultFromScode( S_OK );

 // NULL out-params in case of error
 if( ppRowset )
  *ppRowset = NULL;

 // Validate in-params
 if (pUnkOuter)
  return ResultFromScode( DB_E_NOAGGREGATION );

 // Check Arguments
 if ( !pTableID &amp;&amp; !pIndexID )
  return ResultFromScode( E_INVALIDARG );

 if ( riid == IID_NULL)
  return ResultFromScode( E_NOINTERFACE );

 assert( m_pObj-&gt;m_pUtilProp );

 // Check Arguments for use by properties
 hr = m_pObj-&gt;m_pUtilProp-&gt;SetPropertiesArgChk(cProperties, rgProperties);
 if( FAILED(hr) )
  return hr;

 // If the eKind is not known to use, basically it
 // means we have no table identifier
 if ( (!pTableID ) || ( pTableID-&gt;eKind != DBKIND_NAME ) ||
  ( (pTableID-&gt;eKind == DBKIND_NAME) &amp;&amp; (!(pTableID-&gt;uName.pwszName)) ) ||
  ( wcslen(pTableID-&gt;uName.pwszName)==0 ) )
  return ResultFromScode(DB_E_NOTABLE);

 // We only accept NULL for pIndexID
 if( pIndexID )
  return ResultFromScode(DB_E_NOINDEX);

 assert( m_pObj );

 // this DBSession object can only create 1 Rowset object
 if (m_pObj-&gt;m_fRowsetCreated)
  return ResultFromScode( E_FAIL );

 // set the properties
 if ( cProperties )
  hr = m_pObj-&gt;m_pUtilProp-&gt;SetProperties(PROPSET_ROWSET, cProperties, rgProperties);
 
 if( (hr == DB_E_ERRORSOCCURRED) || 
  (hr == DB_S_ERRORSOCCURRED) )
 {
  // If all the properties set were SETIFCHEAP then we can set 
  // our status to DB_S_ERRORSOCCURRED and continue.
  for(ULONG ul=0;ul&lt;cProperties; ul++)
  {
 &nbsp; for(ULONG ul2=0;ul2&lt;rgProperties[ul].cProperties; ul2++)
 &nbsp; {
 &nbsp;&nbsp; // Check for a required property that failed, if found, we must return
 &nbsp;&nbsp; // DB_E_ERRORSOCCURRED
 &nbsp;&nbsp; if( (rgProperties[ul].rgProperties[ul2].dwStatus != DBPROPSTATUS_OK) &amp;&amp;
 &nbsp;&nbsp;&nbsp; (rgProperties[ul].rgProperties[ul2].dwOptions != DBPROPOPTIONS_SETIFCHEAP) )
 &nbsp;&nbsp;&nbsp; return ResultFromScode(DB_E_ERRORSOCCURRED);
 &nbsp; }
  }
  hrProp = ResultFromScode(DB_S_ERRORSOCCURRED);
 }

 if( FAILED(hr) &amp;&amp; (hrProp==S_OK) )
  return hr;

 // if ppRowset NULL return
 if ( !ppRowset )
  return ResultFromScode( S_OK );
  
 // get file name
 cCharsCopied = WideCharToMultiByte( CP_ACP, 0, pTableID-&gt;uName.pwszName, -1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szFileName, sizeof( szFileName ), NULL, NULL );
 if (!cCharsCopied)
  return ResultFromScode( E_FAIL );

 // Concatenate the path and filename
 lstrcat( szFile, m_pObj-&gt;m_szPath );
 lstrcat( szFile, "\\" );
 lstrcat( szFile, szFileName );

 // open and initialize a file object
 pFileio = new CFileIO();
 if (!pFileio)
  return ResultFromScode( E_OUTOFMEMORY );

 hr = pFileio-&gt;fInit( szFile );
 if (FAILED( hr ))
 {
  delete pFileio;
  return hr;
 }

 // open and initialize a rowset\cursor object
 pRowset = new CRowset( NULL );
 if (!pRowset)
 {
  delete pFileio;
  return ResultFromScode( E_OUTOFMEMORY );
 }
 // Initialize the rowset\cursor.
 // For now, since don't yet support "setable" properties, so no properties to pass.
 // The rowset will always create all of its interfaces.
 // This is all-or-nothing.
 if (!pRowset-&gt;FInit( pFileio ))
 {
  delete pFileio;
  delete pRowset;
  return ResultFromScode( DB_E_NOTABLE );
 }
 //At this point we have handed off the pFileio pointer to the sample
 //provider so null it out.
 pFileio = NULL;

 // get requested interface pointer on rowset\cursor
 hr = pRowset-&gt;QueryInterface( riid, (void **) ppRowset );
 if (FAILED( hr ))
 {
  delete pRowset;
  delete pFileio;
  return ResultFromScode( hr );
 }

 //Assign creator pointer. Used for IRowsetInfo::GetSpecification
 pRowset-&gt;m_pCreator = m_pObj;&nbsp;&nbsp; 
 pRowset-&gt;m_pCreator-&gt;AddRef();
 m_pObj-&gt;m_fRowsetCreated = TRUE;

 return (hr == S_OK) ? hrProp : hr;
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Using the Rowset</h1>
<p>
Rowsets are the unifying abstraction that enables all OLE DB providers to expose base data, command results, or schema information, in tabular format. Conceptually, a rowset is a collection of rows in which each row contains columns of data.</p>
<p>
The <b>IOpenRowset</b> interface exposed by the session generates a rowset object, which encapsulates the provider’s data. A rowset typically has an internal buffer, or row cache, which enables shared access to the provider’s data by multiple consumers. The following section describes how providers and consumers interact with the rowset.</p>
<h1>Consumer and Provider Interactions with the Rowset</h1>
<p>
After receiving the rowset interface pointer, the consumer can request rowset metadata from the provider through <b>IColumnsInfo</b>, if it does not have prior knowledge of the data representation. The consumer uses the metadata to specify bindings, which describe how the consumer wants to receive the data. The consumer creates bindings by requesting <b>IAccessor</b> from the provider and specifying the bindings through <b>IAccessor::CreateAccessor</b>. The provider returns a handle to the accessor to the consumer.</p>
<p>
The consumer then requests a number of rows from the provider using <b>IRowset::GetNextRows</b>. The provider retrieves the data for these rows and stores it in the data cache. The provider then returns an array of row handles to the consumer. Each row handle returned by the provider has an initial reference count of one. The consumer is then free to get the data for any rows from the provider using <b>GetData</b>. The consumer supplies <b>GetData</b> with the row handle, the handle of an accessor, and the buffer location into which to return the data; the provider copies the data to the location specified by the consumer.</p>
<p>
Consumers using the sample provider can delete or change data in the rowset, but they cannot add new rows. To update rows, consumers call <b>IRowsetChange::SetData</b>, which sets the data in the data cache to the values specified by the consumer. To delete rows from the data cache, the consumer calls <b>IRowsetChange::DeleteRows</b>. A third method on <b>IRowsetChange</b>, <b>IRowsetChange::InsertRow</b>, is not implemented in the sample provider.</p>
<p>
When the consumer makes any change to data in the data cache, the effects of the change are written to the data source immediately. OLE DB specifies a change-buffering model, which enables the consumer to make changes that are not realized until the consumer calls <b>IRowsetUpdate::Update</b>; this model is not supported by the sample provider.</p>
<p>
When the consumer has finished working with a row, it can release the row by calling <b>IRowset::ReleaseRows</b>. <b>ReleaseRows</b> simply decrements the reference count on the row in the data cache. If the reference count for that row reaches zero, the row data is released from the data cache.</p>
<h1>Exposing Metadata</h1>
<p>
Providers expose information about the columns of a rowset through <b>IColumnsInfo</b>. The information for each column is returned in a DBCOLUMNINFO structure. For more details on the information contained in the DBCOLUMNINFO structure, see <b>IColumnsInfo::GetColumnsInfo</b> in the <i>OLE DB Programmer’s Reference</i>. OLE DB also enables sophisticated providers to expose a richer set of metadata through <b>IColumnsRowset</b>; the sample provider does not implement this interface.</p>
<h1>Exposing Metadata to Consumers</h1>
<p>
The <b>GetColumnInfo</b> method returns metadata that is most commonly used by consumers: column ID, column name, the ordinal number of the column in the rowset, the column’s data type, and so on. This information helps the consumer determine the binding type.</p>
<p>
The provider returns the information in an array of DBCOLUMNINFO structures, one DBCOLUMNINFO structure per column in the rowset. The order of the structures returned in the array is the order in which the columns appear in the rowset.</p>
<p>
The source code for <b>IColumnsInfo::GetColumnInfo</b> follows; you can find the complete source code for <b>IColumnsInfo</b> in ColInfo.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIColumnsInfo::GetColumnInfo -------------------------------------------</code><pre><code>//
// @mfunc Returns the column metadata needed by most consumers.
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag E_OUTOFMEMORY&nbsp;&nbsp; | Out of memory
//&nbsp; @flag E_INVALIDARG&nbsp; | pcColumns or prginfo or ppStringsbuffer was NULL
//
STDMETHODIMP CImpIColumnsInfo::GetColumnInfo
  (
  ULONG*&nbsp;&nbsp;&nbsp; pcColumns,&nbsp; //@parm OUT | Number of columns in rowset
  DBCOLUMNINFO**&nbsp; prgInfo,&nbsp;&nbsp;&nbsp; //@parm OUT | Array of DBCOLUMNINFO Structures
  WCHAR**&nbsp;&nbsp; ppStringsBuffer //@parm OUT | Storage for all string values
  )
{
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; icol;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; icolStart;
 DBCOLUMNINFO* rgdbcolinfo;
 WCHAR*&nbsp;&nbsp;&nbsp; pstrBuffer;

 // Initialize
 if (pcColumns)
  *pcColumns = 0;
 if (prgInfo)
  *prgInfo = NULL;
 if (ppStringsBuffer)
  *ppStringsBuffer = NULL;

 // Usual argument checking, prescribed by the spec.
 if (pcColumns == NULL || prgInfo == NULL || ppStringsBuffer == NULL)
  return ResultFromScode( E_INVALIDARG );

 icolStart = 1;
 rgdbcolinfo = (DBCOLUMNINFO *) g_pIMalloc-&gt;Alloc( m_pObj-&gt;m_cCols*sizeof( DBCOLUMNINFO ));
 if (rgdbcolinfo == NULL)
  return ResultFromScode( E_OUTOFMEMORY );

 memcpy( rgdbcolinfo, &amp;(m_pObj-&gt;m_rgdbcolinfo[icolStart]), m_pObj-&gt;m_cCols*sizeof( DBCOLUMNINFO ));

 // Copy the heap for column names.
 if (m_pObj-&gt;m_cbHeapUsed)
 {
  ptrdiff_t dp;

  pstrBuffer = (WCHAR *) g_pIMalloc-&gt;Alloc( m_pObj-&gt;m_cbHeapUsed );
  if (pstrBuffer == NULL)
  {
 &nbsp; g_pIMalloc-&gt;Free( rgdbcolinfo );
 &nbsp; return ResultFromScode( E_OUTOFMEMORY );
  }
  memcpy( pstrBuffer, m_pObj-&gt;m_pbHeap, m_pObj-&gt;m_cbHeapUsed );
  dp = (LONG) pstrBuffer - (LONG) (m_pObj-&gt;m_pbHeap);
  dp &gt;&gt;= 1;

  // Loop through columns and adjust pointers to column names.
  for (icol =0; icol &lt; m_pObj-&gt;m_cCols; icol++)
  {
 &nbsp; if (rgdbcolinfo[icol].pwszName)
 &nbsp;&nbsp;&nbsp; rgdbcolinfo[icol].pwszName += dp;
  }
 }

 *prgInfo&nbsp;&nbsp; = rgdbcolinfo;
 *ppStringsBuffer = pstrBuffer;
 *pcColumns = m_pObj-&gt;m_cCols;

 return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<h1>Returning Column Ordinals</h1>
<p>
For purposes of identification, columns in a rowset are identified by a column ID, which is a value of type DBID in the DBCOLUMNINFO structure. Although this is sufficient to uniquely identify the column, some providers may need to refer to the column by its position, or ordinal value.</p>
<p>
The <b>MapColumnIDs</b> method returns column ordinals for all column IDs provided in the <i>rgColumnIDs</i> array. Column ordinals do not change during the life of the rowset, but may change between different instances of the rowset. The source code for <b>IColumnsInfo::MapColumnIDs</b> follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIColumnsInfo::MapColumnIDs --------------------------------------------</code><pre><code>//
// @mfunc Returns an array of ordinals of the columns in a rowset that are
// identified by the specified column IDs.
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | cColumnIDs was not 0 and rgColumnIDs was NULL,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgColumns was NULL
//&nbsp; @flag DB_E_COLUMNUNAVAILABLE&nbsp; | An element of rgColumnIDs was invalid
//
STDMETHODIMP CImpIColumnsInfo::MapColumnIDs
  (
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cColumnIDs,&nbsp;&nbsp; //@parm IN | Number of Column IDs to map
  const DBID&nbsp; rgColumnIDs[],&nbsp; //@parm IN | Column IDs to map
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; rgColumns[]&nbsp;&nbsp; //@parm OUT | Ordinal values
  )
{
 ULONG ulError = 0;
 ULONG i;

 // If cColumnIDs is 0 return
 if (0 == cColumnIDs)
  return ResultFromScode( S_OK );

 // Check arguments
 if ((cColumnIDs != 0) &amp;&amp; (NULL == rgColumnIDs))
  return ResultFromScode( E_INVALIDARG );

 if (NULL == rgColumns)
  return ResultFromScode( E_INVALIDARG );

 // Walk the Column ID structs and determine
 // the ordinal value
 for (i=0; i &lt; cColumnIDs; i++)
 {
  if ((rgColumnIDs[i].uName.ulPropid &lt; 1)&nbsp;&nbsp;&nbsp;&nbsp; ||
 &nbsp;&nbsp; (rgColumnIDs[i].uName.ulPropid &gt; m_pObj-&gt;m_cCols) ||
 &nbsp;&nbsp; (rgColumnIDs[i].eKind != DBKIND_GUID_PROPID)&nbsp; ||
 &nbsp;&nbsp; (rgColumnIDs[i].uGuid.guid != GUID_NULL))
  {
 &nbsp; rgColumns[i] = DB_INVALIDCOLUMN;
 &nbsp; ulError++;
  }
  else
 &nbsp; rgColumns[i] = rgColumnIDs[i].uName.ulPropid;
 }

 if (!ulError)
  return ResultFromScode( S_OK );
 else if (ulError &lt; cColumnIDs)
  return ResultFromScode( DB_S_ERRORSOCCURRED );
 else
  return ResultFromScode( DB_E_ERRORSOCCURRED );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Creating and Using Accessors</h1>
<p>
Consumers describe the memory structure for their buffers through a process called binding. An accessor is a group of bindings. The sample provider supports a very basic type of accessor and cannot support reference accessors, which allow the consumer direct access to the rowset’s data cache.</p>
<p>
Accessors are implemented through <b>IAccessor</b>. You can create accessors with <b>IAccessor::CreateAccessor</b> and release accessors with <b>IAccessor::ReleaseAccessor</b>. You can use <b>IAccessor::GetBindings</b> to determine the bindings in an existing accessor. <b>IAccessor::AddRefAccessor</b> enables the consumer to add a reference count to an existing accessor. The following sections describe these methods.</p>
<h1>Determining Supported Conversions</h1>
<p>
Before the consumer creates an accessor, it can call <b>IConvertType::CanConvert</b> to determine if the provider supports a particular conversion.</p>
<p>
The source code for <b>IConvertType::CanConvert</b> follows; you can find the complete source code for <b>IConvertType</b> in CvtType.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>//----------------------------------------------------------------------------</code><pre><code>// CImpIConvertType::CanConvert
//
// @mfunc Used by consumer to determine provider support for a conversion
//
// @rdesc HRESULT indicating the status of the method
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Conversion supported
//&nbsp; @flag S_FALSE&nbsp;&nbsp;&nbsp;&nbsp; | Conversion unsupported
//&nbsp; @flag DB_E_BADCONVERTFLAG | dwConvertFlags was invalid
//&nbsp; @flag DB_E_BADCONVERTFLAG | called on rowset for DBCONVERTFLAG_PARAMETER
//&nbsp; @flag OTHER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | HRESULTS returned from support functions
//
STDMETHODIMP CImpIConvertType::CanConvert
 (
 DBTYPE&nbsp;&nbsp;&nbsp;&nbsp; wFromType,&nbsp;&nbsp; //@parm IN | src type
 DBTYPE&nbsp;&nbsp;&nbsp;&nbsp; wToType,&nbsp;&nbsp; //@parm IN | dst type
 DBCONVERTFLAGS dwConvertFlags //@parm IN | conversion flags
 )
{
 // Check Arguments
 if( dwConvertFlags != DBCONVERTFLAGS_COLUMN &amp;&amp;
  dwConvertFlags != DBCONVERTFLAGS_PARAMETER )
  return (ResultFromScode(DB_E_BADCONVERTFLAG));

 // Called on rowset, but asking about parameters?
 // Since we only support conversions on a Rowset we always
 // return error for DBCONVERTFLAGS_PARAMETER
 if( dwConvertFlags == DBCONVERTFLAGS_PARAMETER)
  return (ResultFromScode(DB_E_BADCONVERTFLAG));

 // Ask the conversion library for the answer
 return g_pIDataConvert-&gt;CanConvert(wFromType, wToType);
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<h1>Creating an Accessor</h1>
<p>
<b>CreateAccessor</b> associates a set of bindings with an accessor handle that is used to send data to or fetch data from the rowset’s data cache. The sample provider supports only the DBACCESSOR_ROWDATA accessor flag, which specifies that the accessor is to be used for rowset data.</p>
<p>
The source code for <b>IAccessor::CreateAccessor</b> follows; you can find the complete source code for <b>IAccessor</b> in Accessor.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIAccessor::CreateAccessor -----------------------------------------</code><pre><code>//
// @mfunc Creates a set of bindings that can be used to send data
// to or retrieve data from the data cache.
// NOTE:&nbsp; Currently does not support returning rgStatus[].
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Provider specific Error
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | pHAccessor was NULL, dwAccessorFlags was
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invalid, or cBindings was not 0 and
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgBindings was NULL
//&nbsp; @flag E_OUTOFMEMORY&nbsp;&nbsp;&nbsp;&nbsp; | Out of Memory
//&nbsp; @flag DB_E_ERRORSOCCURRED&nbsp;&nbsp; | dwBindPart in an rgBindings element was invalid, OR
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Column number specified was out of range, OR
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Requested coercion is not supported.
//&nbsp; @flag OTHER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Other HRESULTs returned by called functions
//
STDMETHODIMP CImpIAccessor::CreateAccessor
  (
  DBACCESSORFLAGS dwAccessorFlags,
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cBindings,&nbsp; //@parm IN | Number of Bindings
  const DBBINDING rgBindings[], //@parm IN | Array of DBBINDINGS
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cbRowSize,&nbsp; //@parm IN | Number of bytes in consumer's buffer
  HACCESSOR*&nbsp; phAccessor,&nbsp;&nbsp; //@parm OUT | Accessor Handle
  DBBINDSTATUS&nbsp; rgStatus[]&nbsp; //@parm OUT | Binding status
  )
{
 PACCESSOR pAccessor;
 ULONG&nbsp;&nbsp; hAccessor;
 ULONG&nbsp;&nbsp; ibind;
 ULONG&nbsp;&nbsp; icol;
 HRESULT&nbsp;&nbsp; hr;


 // Check Parameters
 if( (cBindings &amp;&amp; !rgBindings) ||
  (phAccessor == NULL) )
  return ResultFromScode( E_INVALIDARG );

 // init out params
 *phAccessor = (HACCESSOR) 0;


 // Check for the binding types we don't accept..
 if ((dwAccessorFlags &amp; DBACCESSOR_PASSBYREF)&nbsp;&nbsp;&nbsp; ||
 &nbsp; (dwAccessorFlags &amp; DBACCESSOR_PARAMETERDATA))
  return ResultFromScode( E_INVALIDARG );

 // .. then check for the binding type that is required
 if (!(dwAccessorFlags &amp; DBACCESSOR_ROWDATA))
  return ResultFromScode( E_INVALIDARG );


 // Check on the bindings the user gave us.
 for (ibind =0, hr =NOERROR; ibind &lt; cBindings; ibind++)
 {
  icol = rgBindings[ibind].iOrdinal;

  // make sure column number is in range
  if (!(0 &lt; icol &amp;&amp; icol &lt;= m_pObj-&gt;m_cCols))
  {
 &nbsp; TRACE( "CreateAccessor failure: binding %d, bad column number %d\n", ibind, icol );
 &nbsp; hr = ResultFromScode( DB_E_ERRORSOCCURRED );
 &nbsp; break;
  }

  // At least one of these valid parts has to be set. In SetData I assume it is the case.
  if ((rgBindings[ibind].dwPart &amp; DBPART_VALUE)&nbsp; == 0
 &nbsp; &amp;&amp; (rgBindings[ibind].dwPart &amp; DBPART_LENGTH) == 0
 &nbsp; &amp;&amp; (rgBindings[ibind].dwPart &amp; DBPART_STATUS) == 0)
  {
 &nbsp; TRACE( "CreateAccessor failure: binding %d, column %d, _VALUE, _LENGTH, _STATUS not specified", ibind, icol );
 &nbsp; hr = ResultFromScode( DB_E_ERRORSOCCURRED );

 &nbsp; if ( rgStatus )
 &nbsp; {
 &nbsp;&nbsp; //&nbsp; Set Bind status to DBBINDSTATUS_BADBINDINFO
 &nbsp; }
 &nbsp; break;
  }

  // Make sure we can do the coercion that is requested
  if( NOERROR != g_pIDataConvert-&gt;CanConvert(rgBindings[ibind].wType, m_pObj-&gt;m_rgdbcolinfo[icol].wType) ||
 &nbsp; NOERROR != g_pIDataConvert-&gt;CanConvert(m_pObj-&gt;m_rgdbcolinfo[icol].wType, rgBindings[ibind].wType) )
  {
 &nbsp; TRACE( "CreateAccessor failure: binding %d, column %d, cannot coerce types\n", ibind, icol );
 &nbsp; hr = ResultFromScode( DB_E_ERRORSOCCURRED );
 &nbsp; if ( rgStatus )
 &nbsp; {
 &nbsp;&nbsp; //&nbsp; Set Bind status to DBBINDSTATUS_UNSUPPORTEDCONVERSION
 &nbsp; }
 &nbsp; break;
  }
 }

 // Any errors amongst those checks?
 if (hr != NOERROR)
 {
  return hr;
 }

 // Make a copy of the client's binding array, and the type of binding.
 // Note: accessors with no bindings (cBindings=0) are legal.
 pAccessor = (ACCESSOR *) new BYTE[sizeof( ACCESSOR ) + (cBindings - 1) *sizeof( DBBINDING )];
 if (pAccessor == NULL)
  return ResultFromScode( E_OUTOFMEMORY );

 // We store a ptr to the newly created variable-sized ACCESSOR.
 // We have an array of ptrs (to ACCESSOR's).
 // The handle is the index into the array of ptrs.
 // The InsertIntoExtBuffer function appends to the end of the array.
 assert( m_pObj-&gt;m_pextbufferAccessor );
 hr = m_pObj-&gt;m_pextbufferAccessor-&gt;InsertIntoExtBuffer( &amp;pAccessor, hAccessor );
 if (FAILED( hr ))
 {
  delete [] pAccessor;
  return ResultFromScode( E_OUTOFMEMORY );
 }
 assert( hAccessor );

 // Copy the client's bindings into the ACCESSOR.
 pAccessor-&gt;dwAccessorFlags = dwAccessorFlags;
 pAccessor-&gt;cBindings&nbsp;&nbsp; = cBindings;
 pAccessor-&gt;cRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;&nbsp; // Establish Reference count.
 memcpy( &amp;(pAccessor-&gt;rgBindings[0]), &amp;rgBindings[0], cBindings*sizeof( DBBINDING ));

 // fill out-param and return
 *phAccessor = (HACCESSOR) hAccessor;
 return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<h1>Returning Accessor Bindings</h1>
<p>
<b>GetBindings</b> returns the bindings in an existing accessor. The source code for <b>IAccessor::GetBindings</b> follows; you can find the complete source code for <b>IAccessor</b> in Accessor.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIAccessor::GetBindings --------------------------------------------------</code><pre><code>//
// @mfunc Returns the bindings in an accessor
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | pdwAccessorFlags/pcBinding/prgBinding were NULL
//&nbsp; @flag E_OUTOFMEMORY&nbsp;&nbsp;&nbsp;&nbsp; | Out of Memory
//&nbsp; @flag DB_E_BADACCESSORHANDLE&nbsp; | Invalid Accessor given
//
STDMETHODIMP CImpIAccessor::GetBindings
  (
  HACCESSOR&nbsp;&nbsp;&nbsp; hAccessor,&nbsp;&nbsp; //@parm IN | Accessor Handle
  DBACCESSORFLAGS* pdwAccessorFlags,&nbsp; //@parm OUT | Binding Type flag
  ULONG*&nbsp;&nbsp;&nbsp;&nbsp; pcBindings,&nbsp;&nbsp;&nbsp; //@parm OUT | Number of Bindings returned
  DBBINDING**&nbsp; prgBindings&nbsp;&nbsp;&nbsp; //@parm OUT | Bindings
  )
{
 // Retrieve our accessor structure from the client's hAccessor,
 // make a copy of the bindings for the user, then done.
 PACCESSOR pAccessor;
 ULONG&nbsp;&nbsp; cBindingSize;
 HRESULT&nbsp;&nbsp; hr;

 // check parameters
 if (!pdwAccessorFlags || !pcBindings || !prgBindings)
  return ResultFromScode( E_INVALIDARG );

 // init out-params
 *pdwAccessorFlags = 0;
 *pcBindings&nbsp;&nbsp; = 0;
 *prgBindings&nbsp; = NULL;

 // Validate Accessor Handle
 hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor );
 if (FAILED( hr ) || pAccessor == NULL)
  return ResultFromScode( DB_E_BADACCESSORHANDLE );

 // Allocate and return Array of bindings
 cBindingSize = pAccessor-&gt;cBindings * sizeof( DBBINDING );
 *prgBindings = (DBBINDING *) g_pIMalloc-&gt;Alloc( cBindingSize );
 if (*prgBindings)
 {
  *pdwAccessorFlags = pAccessor-&gt;dwAccessorFlags;
  *pcBindings = pAccessor-&gt;cBindings;
  memcpy( *prgBindings, pAccessor-&gt;rgBindings, cBindingSize );
 }
 else
 {
  return ResultFromScode( E_OUTOFMEMORY );
 }

 // all went well..
 return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<h1>Adding a Reference Count to an Existing Accessor</h1>
<p>
<b>AddRefAccessor</b> adds a reference count to an existing accessor. The source code for <b>IAccessor::AddRefAccessor</b> follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIAccessor::AddRefAccessor -----------------------------------------</code><pre><code>//
// @mfunc Adds a reference count to an existing accessor
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Provider specific Error
//
STDMETHODIMP CImpIAccessor::AddRefAccessor
 (
 HACCESSOR hAccessor,&nbsp; //@parm IN&nbsp; | Accessor Handle
 ULONG*&nbsp; pcRefCounts&nbsp;&nbsp; //@parm OUT | Reference Count
 )
{
 // Retrieve our accessor structure from the client's hAccessor,
 // free it, then mark accessor ptr as unused.
 // We do not re-use accessor handles.&nbsp; This way, we hope
 // to catch more client errors.&nbsp; (Also, ExtBuffer doesn't
 // maintain a free list, so it doesn't know how to.)

 PACCESSOR pAccessor;
 HRESULT&nbsp;&nbsp; hr;

 if( pcRefCounts )
  *pcRefCounts = 0;

 hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor );
 if (FAILED( hr ) || pAccessor == NULL)
  return ResultFromScode( DB_E_BADACCESSORHANDLE );

 InterlockedIncrement(&amp;(pAccessor-&gt;cRef));

 if( pcRefCounts )
  *pcRefCounts = (ULONG)(pAccessor-&gt;cRef);

 return ResultFromScode(S_OK);
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Releasing an Accessor</h1>
<p>
<b>ReleaseAccessor</b> decrements the reference count on an accessor; when the reference count reaches zero, the accessor is released. The source code for <b>IAccessor::ReleaseAccessor</b> follows; you can find the complete source code for <b>IAccessor</b> in Accessor.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIAccessor::ReleaseAccessor ---------------------------------------</code><pre><code>//
// @mfunc Releases an Accessor
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag DB_E_BADACCESSORHANDLE&nbsp; | hAccessor was invalid
//
STDMETHODIMP CImpIAccessor::ReleaseAccessor
  (
  HACCESSOR hAccessor,&nbsp;&nbsp; //@parm IN&nbsp; | Accessor handle to release
  ULONG*&nbsp; pcRefCounts&nbsp; //@parm OUT | Reference Count
  )
{
 // Retrieve our accessor structure from the client's hAccessor,
 // free it, then mark accessor ptr as unused.
 // We do not re-use accessor handles.&nbsp; This way, we hope
 // to catch more client errors.&nbsp; (Also, ExtBuffer doesn't
 // maintain a free list, so it doesn't know how to.)

 PACCESSOR pAccessor;
 HRESULT&nbsp;&nbsp; hr;

 if( pcRefCounts )
  *pcRefCounts = 0;

 hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor );
 if (FAILED( hr ) || pAccessor == NULL)
  return ResultFromScode( DB_E_BADACCESSORHANDLE );

 // Free the actual structure.
 InterlockedDecrement(&amp;(pAccessor-&gt;cRef));
 assert( pAccessor-&gt;cRef &gt;= 0 );
 if( pAccessor-&gt;cRef &lt;= 0 )
 {
  delete [] pAccessor;
  if( pcRefCounts )
 &nbsp; *pcRefCounts = 0;
 }
 else
 {
  if( pcRefCounts )
 &nbsp; *pcRefCounts = (ULONG)(pAccessor-&gt;cRef);
 }

 // Store a null in our array-of-ptrs,
 // so we know next time that it is invalid.
 // (operator[] returns a ptr to the space where the ptr is stored.)
 *(PACCESSOR*) ((*m_pObj-&gt;m_pextbufferAccessor)[ (ULONG) hAccessor]) = NULL;

 return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Exposing Rowset Information</h1>
<p>
<b>IRowsetInfo</b> enables consumers to learn about the properties of a rowset through <b>IRowsetInfo::GetProperties</b>. In providers that implement bookmarks, consumers can get an interface pointer to a rowset referenced by a bookmark column with <b>IRowsetInfo::GetReferencedRowset</b>. Consumers can get an interface pointer to the object that created the rowset by calling <b>IRowsetInfo::GetSpecification</b>.</p>
<p>
In the sample provider implementation, calls to <b>IRowsetInfo::GetProperties</b> are handled by passing the call to the utility object that manages properties, which is found in UtilProp.cpp. The sample provider doesn’t support bookmarks, so all calls to <b>IRowsetInfo::GetReferencedRowset</b> return the error DB_E_NOTAREFERENCECOLUMN. The sample provider doesn’t store an interface pointer to the object that created the rowset, so calls to <b>IRowsetInfo::GetSpecification</b> are returned with the success code S_OK and the pointer to the memory in which to return the interface pointer is set to NULL.</p>
<h1>Managing Rowsets</h1>
<p>
<b>IRowset</b> provides methods for fetching rows sequentially, exposing data from those rows to consumers, and managing the rows in the rowset. <b>IRowset</b> contains five methods: <b>AddRefRows</b>, <b>GetData</b>, <b>GetNextRows</b>, <b>ReleaseRows</b>, and <b>RestartPosition</b>. The source code for <b>IRowset::AddRefRows</b> follows; you can find the complete source code for the <b>IRowset</b> interface in IRowset.cpp.</p>
<h1>Incrementing the Reference Count on Row Handles</h1>
<p>
<b>AddRefRows</b> increments the reference count on the row handles supplied by the caller. <b>AddRefRows</b> enables consumers to make multiple references to a row in the data cache.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIRowset::AddRefRows --------------------------------------------------</code><pre><code>//
// @mfunc Adds a reference count to an existing row handle
//
// @rdesc HResult
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag E_INVALIDARG&nbsp; | rghRows was NULL and cRows was not 0
//&nbsp; @flag DB_E_BADROWHANDLE | An element of rghRows was invalid

STDMETHODIMP&nbsp; CImpIRowset::AddRefRows
  (
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cRows,&nbsp;&nbsp;&nbsp; // @parm IN&nbsp;&nbsp; | Number of rows to refcount
  const HROW&nbsp; rghRows[],&nbsp; // @parm IN&nbsp;&nbsp; | Array of row handles to refcount
  ULONG*&nbsp;&nbsp;&nbsp; pcRefCounted, // @parm OUT&nbsp; | Number successfully refcounted
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; rgRefCounts[] // @parm OUT&nbsp; | Array of refcounts
  )
{
 ULONG ihRow = 0;
 ROWBUFF *pRowBuff;
 ULONG cAddRef;

 // init out param
 if (pcRefCounted)
  *pcRefCounted = 0;

 // check params
 if (cRows &amp;&amp; !rghRows)
  return ResultFromScode( E_INVALIDARG );

 cAddRef = 0;

 // for each of the HROWs the caller provided...
 for (ihRow = 0; ihRow &lt; cRows; ihRow++)
 {
  // check the row handle
  if (S_OK != (m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) rghRows[ihRow] ))
 &nbsp; return ResultFromScode( DB_E_BADROWHANDLE );

  // bump refcount
  pRowBuff = m_pObj-&gt;GetRowBuff((ULONG) rghRows[ihRow] );
  assert( pRowBuff-&gt;ulRefCount != 0 );
  assert( m_pObj-&gt;m_ulRowRefCount != 0 );
  ++pRowBuff-&gt;ulRefCount;
  ++m_pObj-&gt;m_ulRowRefCount;

  // bump total refcounted
  cAddRef++;

  // stuff new refcount into caller's array
  if (rgRefCounts)
 &nbsp; rgRefCounts[ihRow] = pRowBuff-&gt;ulRefCount;
 }

 // fill out-param
 if (pcRefCounted)
  (*pcRefCounted) = cAddRef;

 return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Populating the Data Cache</h1>
<p>
<b>IRowset::GetNextRows</b> gets the next sequence of rows from the file and places them in the rowset’s data cache. When <b>GetNextRows</b> is first called, it starts at the beginning of the file. After that, <b>GetNextRows</b> maintains information about its current position so it can proceed forward from that position. The sample provider does not support rowsets with reversible direction. The sample provider does, however, support <b>IRowset::RestartPosition</b>, which repositions the next fetch position to the beginning of the file. The source code for <b>IRowset::GetNextRows</b> follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIRowset::GetNextRows --------------------------------------------------</code><pre><code>//
// @mfunc Fetches rows in a sequential style, remembering the previous position
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag DB_S_ENDOFROWSET&nbsp;&nbsp;&nbsp; | Reached end of rowset
//&nbsp; @flag DB_E_CANTFETCHBACKWARDS | cRows was negative and we can't fetch backwards
//&nbsp; @flag DB_E_ROWSNOTRELEASED&nbsp; | Must release all HROWs before calling GetNextRows
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Provider-specific error
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | pcRowsObtained or prghRows was NULL
//&nbsp; @flag E_OUTOFMEMORY&nbsp;&nbsp;&nbsp;&nbsp; | Out of Memory
//&nbsp; @flag OTHER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Other HRESULTs returned by called functions
//
STDMETHODIMP CImpIRowset::GetNextRows
  (
  HCHAPTER hReserved,&nbsp;&nbsp; //@parm IN | Reserved for future use. Ingored.
  LONG&nbsp;&nbsp; cRowsToSkip,&nbsp;&nbsp; //@parm IN | Rows to skip before reading
  LONG&nbsp;&nbsp; cRows,&nbsp;&nbsp;&nbsp;&nbsp; //@parm IN | Number of rows to fetch
  ULONG&nbsp; *pcRowsObtained, //@parm OUT | Number of rows obtained
  HROW&nbsp;&nbsp; **prghRows&nbsp;&nbsp; //@parm OUT | Array of Hrows obtained
  )
{
 ULONG&nbsp; cRowsTmp;
 BOOL&nbsp;&nbsp; fExtraRow;
 ULONG&nbsp; cSlotAlloc =0;
 ULONG&nbsp; di;
 LONG&nbsp;&nbsp; irow, ih;
 ULONG&nbsp; irowFirst, irowLast;
 PROWBUFF prowbuff;
 HRESULT&nbsp; hr;
 BYTE&nbsp;&nbsp; *pbRowFirst;


 // Check validity of arguments.
 if (pcRowsObtained == NULL || prghRows == NULL)
  return ResultFromScode( E_INVALIDARG );

 // init out-params
 *pcRowsObtained = 0;

 // No-op case always succeeds.
 if (cRows == 0 &amp;&amp; cRowsToSkip == 0)
  return ResultFromScode( S_OK );

 // This implementation doesn't support scrolling backward.
 if (cRows &lt; 0 || cRowsToSkip &lt; 0)
  return ResultFromScode( DB_E_CANTFETCHBACKWARDS );

 // Are there any unreleased rows?
 if ((m_pObj-&gt;m_prowbitsIBuffer)-&gt;ArrayEmpty() != S_OK)
  return ResultFromScode( DB_E_ROWSNOTRELEASED );
 assert( m_pObj-&gt;m_ulRowRefCount == 0 ); // should be true since array was empty

 // Is the cursor fully materialized (end-of-cursor condition)?
 if (m_pObj-&gt;m_dwStatus &amp; STAT_ENDOFCURSOR)
  return ResultFromScode( DB_S_ENDOFROWSET );

 assert( m_pObj-&gt;m_rgbRowData );
 if (FAILED( m_pObj-&gt;Rebind((BYTE *) m_pObj-&gt;GetRowBuff( m_pObj-&gt;m_irowMin ))))
  return ResultFromScode( E_FAIL );

 // Sometimes we need an extra row to fetch data and copy it to appropriate place.
 fExtraRow = (cRows &gt; 1);
 cRowsTmp = cRows + (fExtraRow ? 1 : 0);


 if (FAILED( hr = GetNextSlots( m_pObj-&gt;m_pIBuffer, cRowsTmp, &amp;irowFirst )))
  return hr;
 cSlotAlloc = cRowsTmp;

 //
 // Fetch Data
 //
 if (cRowsToSkip)
 {
  // Calculate the new position
  m_pObj-&gt;m_irowFilePos += cRowsToSkip;

  // Check if skip causes END_OF_ROWSET
  if (m_pObj-&gt;m_irowFilePos &gt; m_pObj-&gt;m_pFileio-&gt;GetRowCnt() ||
 &nbsp;&nbsp; m_pObj-&gt;m_irowFilePos &lt;= 0)
  {
 &nbsp; m_pObj-&gt;m_dwStatus |= STAT_ENDOFCURSOR;
 &nbsp; return ResultFromScode( DB_S_ENDOFROWSET );
  }
 }

 pbRowFirst = (BYTE *) m_pObj-&gt;GetRowBuff( irowFirst );
 for (irow =1; irow &lt;= cRows; irow++)
 {
  // Get the Data from the File into the row buffer
  if (S_FALSE == (hr =&nbsp; m_pObj-&gt;m_pFileio-&gt;Fetch( m_pObj-&gt;m_irowFilePos + irow )))
  {
 &nbsp; m_pObj-&gt;m_dwStatus |= STAT_ENDOFCURSOR;
 &nbsp; break;
  }
  else
  {
 &nbsp; if (FAILED( hr ))
 &nbsp;&nbsp; return ResultFromScode( E_FAIL );
  }

  // Got a row, so copy it from bound row to the destination.
  // Very first row is Fetch buffer, we give out rows [2...cRows+1].
  if (fExtraRow)
 &nbsp; memcpy( pbRowFirst + (m_pObj-&gt;m_cbRowSize * irow), pbRowFirst, m_pObj-&gt;m_cbRowSize );
 }

 cRowsTmp = irow - 1; //Irow will be +1 because of For Loop
 m_pObj-&gt;m_irowLastFilePos = m_pObj-&gt;m_irowFilePos;
 m_pObj-&gt;m_irowFilePos += cRowsTmp;


 //
 // Through fetching many rows of data
 //
 // Allocate row handles for client.
 // Note that we need to use IMalloc for this.
 //
 // Should only malloc cRowsTmp, instead of cRows.
 //
 // Modified to use IMalloc.
 // Should malloc cRows, since client will assume it's that big.
 //

 *pcRowsObtained = cRowsTmp;
 if (*prghRows == NULL)
 {
  *prghRows = (HROW *) g_pIMalloc-&gt;Alloc( cRows*sizeof( HROW ));
 }

 if (NULL == *prghRows)
  return ResultFromScode( E_OUTOFMEMORY );

 //
 // Fill in the status information: Length, IsNull
 // May be able to wait until first call to GetData,
 // but have to do it sometime.
 //
 // Suggest keeping an array of structs of accessor info.
 // One element is whether accessor requires any status info or length info.
 // Then we could skip this whole section.
 //
 // Added check for cRowsTmp to MarkRows call.
 // Don't want to call if cRowsTmp==0.
 // (Range passed to MarkRows is inclusive, so can't specify marking 0 rows.)
 //
 // Note that SetSlots is a CBitArray member function -- not an IBuffer function.
 //
 // Bits are [0...n-1], row handles are [1...n].
 //
 // Cleanup. Row handles, bits, indices are the same [m....(m+n)], where m is some # &gt;0,
 //
 // Added row-wise reference counts and cursor-wise reference counts.
 //

 // Set row handles, fix data length field and compute data status field.//
 di = fExtraRow ? 1 : 0;
 m_pObj-&gt;m_cRows = cRowsTmp;
 irowLast = irowFirst + di + cRowsTmp - 1;

 // Cleanup extra slots where no hRow actually was put..
 //&nbsp; ** Because of less rows than asked for
 //&nbsp; ** Because of temporary for for data transfer.
 if (fExtraRow)
  if (FAILED( hr = ReleaseSlots( m_pObj-&gt;m_pIBuffer, irowFirst, 1 )))
 &nbsp; return hr;
 if (cSlotAlloc &gt; (cRowsTmp + di))
  if (FAILED( hr = ReleaseSlots( m_pObj-&gt;m_pIBuffer, irowFirst + cRowsTmp + di, (cSlotAlloc - cRowsTmp - di))))
 &nbsp; return hr;

 for (irow = (LONG) (irowFirst + di), ih =0; irow &lt;= (LONG) irowLast; irow++, ih++)
 {
  // Increment the rows-read count,
  // then store it as the bookmark in the very first DWORD of the row.

  prowbuff = m_pObj-&gt;GetRowBuff( irow );

  // Insert the bookmark and its row number (from 1...n) into a hash table.
  // This allows us to quickly determine the presence of a row in mem, given the bookmark.
  // The bookmark is contained in the row buffer, at the very beginning.
  // Bookmark is the row number within the entire result set [1...num_rows_read].

  // This was a new Bookmark, not in memory,
  // so return to user (in *prghRows) the hRow we stored.
  prowbuff-&gt;ulRefCount++;
  prowbuff-&gt;pbBmk = (BYTE*) m_pObj-&gt;m_irowLastFilePos + ih + 1;
  m_pObj-&gt;m_ulRowRefCount++;

  (*prghRows)[ih] = (HROW) (irow);
 }

 if (m_pObj-&gt;m_dwStatus &amp; STAT_ENDOFCURSOR)
  return ResultFromScode( DB_S_ENDOFROWSET );
 else
  return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Retrieving Data from the Data Cache</h1>
<p>
<b>IRowset::GetData</b> enables consumers to retrieve data from the data cache. <b>GetData</b> uses the bindings in the accessor to determine how the data should be returned and what data should be returned to the consumer’s buffer. Then, <b>GetData</b> converts the data in the cache to the type specified in the binding and transfers the converted data to the consumer. The source code for <b>IRowset::GetData</b> follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIRowset::GetData --------------------------------------------------</code><pre><code>//
// @mfunc Retrieves data from the rowset's cache
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag DB_S_ERRORSOCCURED&nbsp;&nbsp; | Could not coerce a column value
//&nbsp; @flag DB_E_BADACCESSORHANDLE | Invalid Accessor given
//&nbsp; @flag DB_E_BADROWHANDLE&nbsp; | Invalid row handle given
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp;&nbsp; | pData was NULL
//&nbsp; @flag OTHER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Other HRESULTs returned by called functions
//
STDMETHODIMP CImpIRowset::GetData
  (
  HROW&nbsp;&nbsp;&nbsp; hRow,&nbsp;&nbsp; //@parm IN | Row Handle
  HACCESSOR hAccessor,&nbsp; //@parm IN | Accessor to use
  void&nbsp;&nbsp; *pData&nbsp;&nbsp; //@parm OUT | Pointer to buffer where data should go.
  )
{
 PACCESSOR pAccessor;
 ULONG&nbsp;&nbsp; icol, ibind;
 ROWBUFF&nbsp;&nbsp; *pRowBuff;
 COLUMNDATA&nbsp; *pColumnData;
 DBBINDING *pBinding;
 ULONG&nbsp;&nbsp; cBindings;
 ULONG&nbsp;&nbsp; ulErrorCount;
 DBTYPE&nbsp; dwSrcType;
 DBTYPE&nbsp; dwDstType;
 void&nbsp;&nbsp;&nbsp; *pSrc;
 void&nbsp;&nbsp;&nbsp; *pDst;
 ULONG&nbsp;&nbsp; ulSrcLength;
 ULONG&nbsp;&nbsp; *pulDstLength;
 ULONG&nbsp;&nbsp; ulDstMaxLength;
 DWORD&nbsp;&nbsp; dwSrcStatus;
 DWORD&nbsp;&nbsp; *pdwDstStatus;
 DWORD&nbsp;&nbsp; dwPart;
 HRESULT&nbsp;&nbsp; hr;

 // Coerce data for row 'hRow', according to hAccessor.
 // Put in location 'pData'.&nbsp; Offsets and types are in hAccessor's bindings.
 //
 // Return S_OK if all lossless conversions,
 // return DB_S_ERRORSOCCURED if lossy conversion (truncation, rounding, etc.)
 // Return E_FAIL, etc., if horrible errors.

 // GetItemOfExtBuffer is basically operator[].
 // It takes an index (or handle) (referenced from 1...n),
 // and a ptr for where to write the data.
 //
 // It holds ptrs to a variable-length ACCESSOR struct.
 // So we get the ACCESSOR ptr for the client's accessor handle.

 assert( m_pObj-&gt;m_pextbufferAccessor );
 hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor );
 if (FAILED( hr ) || pAccessor == NULL)
  return ResultFromScode( DB_E_BADACCESSORHANDLE );

 assert( pAccessor );
 cBindings = pAccessor-&gt;cBindings;
 pBinding&nbsp; = pAccessor-&gt;rgBindings;

 // IsSlotSet returns S_OK&nbsp; if row is marked.
 //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_FALSE if row is not marked.
 // The "mark" means that there is data present in the row.
 // Rows are [1...n], slot marks are [0...n-1].
 if (m_pObj-&gt;m_prowbitsIBuffer-&gt;IsSlotSet((ULONG) hRow ) != S_OK)
  return ResultFromScode( DB_E_BADROWHANDLE );

 // Ensure a place to put data.
 if (pData == NULL)
  return ResultFromScode( E_INVALIDARG );

 pRowBuff = m_pObj-&gt;GetRowBuff((ULONG) hRow );

 // Internal error for a 0 reference count on this row,
 // since we depend on the slot-set stuff.
 assert( pRowBuff-&gt;ulRefCount );


 ulErrorCount = 0;
 for (ibind = 0; ibind &lt; cBindings; ibind++)
 {
  icol = pBinding[ibind].iOrdinal;
  pColumnData = (COLUMNDATA *) ((BYTE *) pRowBuff + m_pObj-&gt;m_rgdwDataOffsets[icol]);

  dwSrcType&nbsp; = m_pObj-&gt;m_rgdbcolinfo[icol].wType;
  pSrc&nbsp;&nbsp;&nbsp;&nbsp; = &amp;(pColumnData-&gt;bData);
  ulSrcLength&nbsp; = pColumnData-&gt;dwLength;
  dwSrcStatus&nbsp; = pColumnData-&gt;dwStatus;
  ulDstMaxLength = pBinding[ibind].cbMaxLen;
  dwDstType&nbsp; = pBinding[ibind].wType;
  dwPart&nbsp;&nbsp; = pBinding[ibind].dwPart;

  pDst&nbsp;&nbsp;&nbsp;&nbsp; = dwPart &amp; DBPART_VALUE ? ((BYTE*) pData + pBinding[ibind].obValue) : NULL;
  pulDstLength = dwPart &amp; DBPART_LENGTH ? (ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) : NULL;
  pdwDstStatus = dwPart &amp; DBPART_STATUS ? (ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) : NULL;

  hr = g_pIDataConvert-&gt;DataConvert(
 &nbsp;&nbsp;&nbsp;&nbsp; dwSrcType,
 &nbsp;&nbsp;&nbsp;&nbsp; dwDstType,
 &nbsp;&nbsp;&nbsp;&nbsp; ulSrcLength,
 &nbsp;&nbsp;&nbsp;&nbsp; pulDstLength,
 &nbsp;&nbsp;&nbsp;&nbsp; pSrc,
 &nbsp;&nbsp;&nbsp;&nbsp; pDst,
 &nbsp;&nbsp;&nbsp;&nbsp; ulDstMaxLength,
 &nbsp;&nbsp;&nbsp;&nbsp; dwSrcStatus,
 &nbsp;&nbsp;&nbsp;&nbsp; pdwDstStatus,
 &nbsp;&nbsp;&nbsp;&nbsp; 0, // bPrecision for conversion to DBNUMERIC
 &nbsp;&nbsp;&nbsp;&nbsp; 0, // bScale for conversion to DBNUMERIC
 &nbsp;&nbsp;&nbsp;&nbsp; DBDATACONVERT_DEFAULT);
  if (FAILED( hr ))
 &nbsp; return hr;&nbsp; // fatal error
  if (hr != ResultFromScode( S_OK ))
 &nbsp; ulErrorCount++; // can't coerce
 }

 // We report any lossy conversions with a special status.
 // Note that DB_S_ERRORSOCCURED is a success, rather than failure.
 return ResultFromScode( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Decrementing the Reference Count on Row Handles</h1>
<p>
<b>IRowset::ReleaseRows</b> decrements the reference count on the rows specified in the <i>rghRows</i> array. A consumer must call <b>ReleaseRows</b> once for each time a row was fetched or each time the row had its reference count incremented by <b>AddRefRow</b>. When the reference count reaches zero, the row is released if the rowset is in immediate update mode.</p>
<p>
In providers that implement <b>IRowsetUpdate</b>, rows are released unless there are pending changes on the row; the sample provider always performs rowset updates in immediate mode, which means that changes are immediately applied to the underlying data source. Therefore, the sample provider does not recognize any changes as pending. The source code for <b>IRowset::ReleaseRows</b> follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIRowset::ReleaseRows ---------------------------------------</code><pre><code>//
// @mfunc Releases row handles
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag E_INVALIDARG&nbsp; | Invalid parameters were specified
//&nbsp; @flag DB_E_BADROWHANDLE | Row handle was invalid
//
STDMETHODIMP CImpIRowset::ReleaseRows
  (
  ULONG&nbsp;&nbsp; cRow,&nbsp;&nbsp;&nbsp;&nbsp; //@parm IN&nbsp; | Number of rows to release
  const HROW&nbsp; rghRow[],&nbsp;&nbsp; //@parm IN&nbsp; | Array of handles of rows to be released
  DBROWOPTIONS&nbsp; rgRowOptions[], //@parm IN&nbsp; | Additional Options
  ULONG&nbsp;&nbsp; *pcRowReleased, //@parm OUT | Count of rows actually released
  ULONG&nbsp;&nbsp; rgRefCount[]&nbsp; //@parm OUT | Array of refcnts for the rows
  )
{
 ULONG ihRow;
 BOOL&nbsp; fEncounteredError;
 ROWBUFF *pRowBuff;
 ULONG cRowReleased = 0;


 // check params
 if (cRow &amp;&amp; !rghRow)
  return ResultFromScode( E_INVALIDARG );

 // init out param
 if (pcRowReleased)
  *pcRowReleased = 0;

 fEncounteredError = FALSE;
 ihRow = 0;

 while (ihRow &lt; cRow)
 {
  if ((m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) rghRow[ihRow] ) == S_OK)
  {
 &nbsp; // Found valid row, so decrement reference counts.
 &nbsp; // (Internal error for refcount to be 0 here, since slot set.)
 &nbsp; pRowBuff = m_pObj-&gt;GetRowBuff((ULONG) rghRow[ihRow] );
 &nbsp; assert( pRowBuff-&gt;ulRefCount != 0 );
 &nbsp; assert( m_pObj-&gt;m_ulRowRefCount != 0 );
 &nbsp; --pRowBuff-&gt;ulRefCount;
 &nbsp; --m_pObj-&gt;m_ulRowRefCount;

 &nbsp; if (rgRefCount)
 &nbsp;&nbsp; rgRefCount[ihRow] = pRowBuff-&gt;ulRefCount;

 &nbsp; if (pRowBuff-&gt;ulRefCount == 0)
 &nbsp; {
 &nbsp;&nbsp; ReleaseSlots( m_pObj-&gt;m_pIBuffer, (ULONG) rghRow[ihRow], 1 );
 &nbsp;&nbsp; cRowReleased++;
 &nbsp; }
 &nbsp; ihRow++;
  }
  else
  {
 &nbsp; // It is an error for client to try to release a row
 &nbsp; // for which "IsSetSlot" is false.&nbsp; Client gave us an invalid handle.
 &nbsp; // Ignore it (we can't release it...) and report error when done.
 &nbsp; fEncounteredError = TRUE;
 &nbsp; if (rgRefCount)
 &nbsp;&nbsp; rgRefCount[ihRow] = 0;
 &nbsp; // stop looping if we hit an error&nbsp; 
 &nbsp; break;&nbsp; 
  }
 }

 if (pcRowReleased)
  *pcRowReleased = cRowReleased;

 if (fEncounteredError)
  return ResultFromScode( DB_E_BADROWHANDLE );
 else
  return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Returning to the First Row of the Rowset</h1>
<p>
<b>IRowset::RestartPosition</b> moves the next fetch position used by <b>GetNextRows</b> to the first row of the rowset. The source code for <b>IRowset::RestartPosition</b> follows.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIRowset::ResartPosition ---------------------------------------</code><pre><code>//
// @mfunc Repositions the next fetch position to the start of the rowset
//
// - all rows must be released before calling this method
// - it is not expensive to Restart us, because we are from a single table
//
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Method Succeeded
//&nbsp; @flag DB_E_ROWSNOTRELEASED&nbsp; | All HROWs must be released before calling
//
STDMETHODIMP CImpIRowset::RestartPosition
  (
  HCHAPTER&nbsp; hReserved&nbsp;&nbsp;&nbsp; //@parm IN | Reserved for future use.&nbsp; Ignored.
  )
{
 // make sure all rows have been released
 if (S_OK != (m_pObj-&gt;m_prowbitsIBuffer)-&gt;ArrayEmpty())
  return DB_E_ROWSNOTRELEASED;
 assert( m_pObj-&gt;m_ulRowRefCount == 0 ); // should be true since array was empty

 // set "next fetch" position to the start of the rowset
 m_pObj-&gt;m_irowFilePos = 0;

 // clear "end of cursor" flag
 m_pObj-&gt;m_dwStatus &amp;= ~STAT_ENDOFCURSOR;

 return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Updating Rows</h1>
<p>
<b>IRowsetChange</b> enables consumers to change the values of columns in a row of data. If the consumer wants to change the data, it must first construct an accessor for the columns to be changed. <b>IRowsetChange</b> contains three methods: <b>DeleteRows</b>, <b>InsertRow</b>, and <b>SetData</b>. The sample provider does not implement the <b>InsertRow</b> method.</p>
<h1>Setting the New Data Values</h1>
<p>
<b>IRowsetChange::SetData</b> sets new data values for columns in a row. <b>SetData</b> cannot be used to change values in a deleted row. When <b>SetData</b> updates a row, it overwrites the row data in the provider’s data cache and in the underlying data source with at signs (@), causing the row to appear deleted. Then, it appends the new row to the end of the file. Changes made through <b>SetData</b> are applied to the data source immediately. The source code for <b>IRowsetChange::SetData</b> follows; you can find the complete source code for <b>IRowsetChange</b> in RowChng.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIRowsetChange::SetData ------------------------------------------------</code><pre><code>//
// @mfunc Sets new data values into fields of a row.
//
// @rdesc HRESULT
//&nbsp; @flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | The method succeeded
//&nbsp; @flag E_OUTOFMEMORY&nbsp;&nbsp;&nbsp; | Out of memory
//&nbsp; @flag DB_E_BADACCESSORHANDLE | Bad accessor handle
//&nbsp; @flag DB_E_READONLYACCESSOR&nbsp; | Tried to write through a read-only accessor
//&nbsp; @flag DB_E_BADROWHANDLE&nbsp; | Invalid row handle
//&nbsp; @flag E_INVALIDARG&nbsp;&nbsp;&nbsp;&nbsp; | pData was NULL
//&nbsp; @flag E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Provider-specific error
//&nbsp; @flag OTHER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Other HRESULTs returned by called functions
//
STDMETHODIMP CImpIRowsetChange::SetData
  (
  HROW&nbsp;&nbsp;&nbsp; hRow,&nbsp;&nbsp; //@parm IN | Handle of the row in which to set the data
  HACCESSOR hAccessor,&nbsp; //@parm IN | Handle to the accessor to use
  void*&nbsp; pData&nbsp;&nbsp; //@parm IN | Pointer to the data
  )
{
 PACCESSOR&nbsp;&nbsp; paccessor;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; icol, ibind;
 BYTE*&nbsp;&nbsp;&nbsp;&nbsp; pbProvRow;
 HRESULT&nbsp;&nbsp; hr;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; cBindings;
 DBBINDING*&nbsp; pBinding;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; dwErrorCount;
 DBTYPE&nbsp;&nbsp;&nbsp; dwSrcType;
 DBTYPE&nbsp;&nbsp;&nbsp; dwDstType;
 void*&nbsp;&nbsp;&nbsp;&nbsp; pSrc;
 void*&nbsp;&nbsp;&nbsp;&nbsp; pDst;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; dwSrcLength;
 ULONG*&nbsp;&nbsp;&nbsp; pdwDstLength;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; dwDstMaxLength;
 DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwSrcStatus;
 DWORD*&nbsp;&nbsp;&nbsp; pdwDstStatus;
 DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwPart;
 PCOLUMNDATA&nbsp;&nbsp; pColumnData;
 BYTE&nbsp;&nbsp;&nbsp; b;

 BYTE*&nbsp;&nbsp;&nbsp;&nbsp; rgbRowDataSave = NULL;

 rgbRowDataSave = (BYTE *) malloc( m_pObj-&gt;m_cbRowSize );
 if (NULL == rgbRowDataSave)
  return ResultFromScode( E_OUTOFMEMORY );

 if ( m_pObj-&gt;m_pextbufferAccessor == NULL&nbsp;&nbsp; 
 &nbsp; || FAILED( m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;paccessor))
 &nbsp; || paccessor == NULL)
 {
  return ResultFromScode( DB_E_BADACCESSORHANDLE );
 }
 &nbsp;&nbsp; 
 assert( paccessor );

 cBindings = paccessor-&gt;cBindings;
 pBinding&nbsp; = paccessor-&gt;rgBindings;

 // Is row handle right?
 if ((m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) hRow ) != S_OK)
  return ResultFromScode( DB_E_BADROWHANDLE );

 // Ensure a source of data.
 if (pData == NULL)
  return ResultFromScode( E_INVALIDARG );

 pbProvRow = (BYTE *) (m_pObj-&gt;GetRowBuff((ULONG) hRow ));

 // Save the row.
 memcpy( rgbRowDataSave, pbProvRow, m_pObj-&gt;m_cbRowSize );


 // Apply accessor to data.
 for (ibind = 0, dwErrorCount = 0; ibind &lt; cBindings; ibind++)
 {
  icol = pBinding[ibind].iOrdinal;
  pColumnData = (COLUMNDATA *) (pbProvRow + m_pObj-&gt;m_rgdwDataOffsets[icol]);

  dwDstType&nbsp; = m_pObj-&gt;m_rgdbcolinfo[icol].wType;
  pDst&nbsp;&nbsp;&nbsp;&nbsp; = &amp;(pColumnData-&gt;bData);
  pdwDstLength = (ULONG *) &amp; (pColumnData-&gt;dwLength);
  pdwDstStatus = &amp;(pColumnData-&gt;dwStatus);
  dwDstMaxLength = m_pObj-&gt;m_rgdbcolinfo[icol].ulColumnSize;

  dwPart&nbsp;&nbsp; = pBinding[ibind].dwPart;
  dwSrcType&nbsp; = pBinding[ibind].wType;

  if ((dwPart &amp; DBPART_VALUE) == 0)
  {
 &nbsp; if (((dwPart &amp; DBPART_STATUS)
 &nbsp;&nbsp;&nbsp; &amp;&amp; (*(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) &amp; DBSTATUS_S_ISNULL))
 &nbsp;&nbsp;&nbsp;&nbsp; || ((dwPart &amp; DBPART_LENGTH) &amp;&amp; *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) == 0))
 &nbsp; {
 &nbsp;&nbsp; pSrc = &amp;b;
 &nbsp;&nbsp; b = 0x00;
 &nbsp; }
 &nbsp; else
 &nbsp;&nbsp; return ResultFromScode( E_FAIL );
 &nbsp; }
  else
  {
 &nbsp; pSrc = (void *) ((BYTE*) pData + pBinding[ibind].obValue);
  }

  dwSrcLength = (dwPart &amp; DBPART_LENGTH) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) : 0;

  dwSrcStatus = (dwPart &amp; DBPART_STATUS) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus)
 &nbsp;&nbsp; : DBSTATUS_S_OK;

  hr = g_pIDataConvert-&gt;DataConvert(
 &nbsp;&nbsp;&nbsp;&nbsp; dwSrcType,
 &nbsp;&nbsp;&nbsp;&nbsp; dwDstType,
 &nbsp;&nbsp;&nbsp;&nbsp; dwSrcLength,
 &nbsp;&nbsp;&nbsp;&nbsp; pdwDstLength,
 &nbsp;&nbsp;&nbsp;&nbsp; pSrc,
 &nbsp;&nbsp;&nbsp;&nbsp; pDst,
 &nbsp;&nbsp;&nbsp;&nbsp; dwDstMaxLength,
 &nbsp;&nbsp;&nbsp;&nbsp; dwSrcStatus,
 &nbsp;&nbsp;&nbsp;&nbsp; pdwDstStatus,
 &nbsp;&nbsp;&nbsp;&nbsp; 0, // bPrecision for conversion to DBNUMERIC
 &nbsp;&nbsp;&nbsp;&nbsp; 0, // bScale for conversion to DBNUMERIC
 &nbsp;&nbsp;&nbsp;&nbsp; DBDATACONVERT_SETDATABEHAVIOR);
  if (FAILED( hr ))
 &nbsp; return hr;&nbsp; // fatal error
  if (hr != S_OK)
 &nbsp; dwErrorCount++; // rounding or truncation or can't coerce
 }

 // Carry out the update.
 if (FAILED( m_pObj-&gt;m_pFileio-&gt;UpdateRow((ULONG) ((PROWBUFF) pbProvRow)-&gt;pbBmk, m_pObj-&gt;m_rgdwDataOffsets, pbProvRow )))
 {
  // Restore the row to its previous state */
  memcpy( pbProvRow, rgbRowDataSave, m_pObj-&gt;m_cbRowSize );
  return ResultFromScode( E_FAIL );
 }

 free( rgbRowDataSave );

 // We report any lossy conversions with a special status.
 // Note that DB_S_ERRORSOCCURED is a success, rather than failure.
 return ResultFromScode( dwErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h1>Deleting Rows</h1>
<p>
<b>IRowsetChange</b> also enables consumers to delete rows from the rowset. <b>IRowsetChange::DeleteRows</b> deletes rows from the rowset by overwriting the entire row with at signs (@). Deletions made through <b>DeleteRows</b> are applied to the data source immediately. The source code for <b>IRowsetChange::DeleteRows</b> follows; you can find the complete source code for <b>IRowsetChange</b> in RowChg.cpp.</p>
<table border=1 cellpadding=5 cols=1 frame=below rules=rows width=587>
<tr valign=top>
<td width=100%><pre><code>// CImpIRowsetChange::DeleteRows ---------------------------------------</code><pre><code>//
// @mfunc Deletes rows from the provider.&nbsp; If Errors on individual rows
// occur, the DBERRORINFO array is updated to reflect the error and S_FALSE
// is returned instead of S_OK.
//
// @rdesc HRESULT indicating the status of the method
//&nbsp; @Flag S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | All row handles deleted
//&nbsp; @Flag DB_S_ERRORSOCCURRED | Some, but not all, row handles deleted
//&nbsp; @Flag E_INVALIDARG&nbsp;&nbsp;&nbsp; | Arguments did not match spec.
//&nbsp; @Flag E_OUTOFMEMORY&nbsp;&nbsp; | Could not allocated error array
//
STDMETHODIMP CImpIRowsetChange::DeleteRows
  (
  HCHAPTER&nbsp; hReserved,&nbsp; //@parm IN | Reserved for future use
  ULONG&nbsp;&nbsp; cRows,&nbsp;&nbsp;&nbsp; //@parm IN | Number of rows to delete
  const HROW&nbsp; rghRows[],&nbsp; //@parm IN | Array of handles to delete
  DBROWSTATUS rgRowStatus[] //@parm OUT&nbsp; | Error information
  )
{
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; ihRow&nbsp;&nbsp;&nbsp; = 0L;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; cErrors&nbsp; = 0L;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp; cRowReleased = 0L;
 BYTE*&nbsp;&nbsp;&nbsp;&nbsp; pbProvRow;

 // If No Row handle, just return.
 if (0 == cRows)
  return ResultFromScode( S_OK );

 // Check for Invalid Arguments
 if ((cRows &gt;= 1) &amp;&amp; (NULL == rghRows))
  return ResultFromScode( E_INVALIDARG );

 // Process row handles
 while (ihRow &lt; cRows)
 {
  if (rgRowStatus)
 &nbsp; rgRowStatus[ihRow] = DBROWSTATUS_S_OK;

  // Is row handle valid
  if (S_OK != (m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) rghRows[ihRow] ))
  {
 &nbsp; // Log Error
 &nbsp; if (rgRowStatus)
 &nbsp;&nbsp; rgRowStatus[ihRow]= DBROWSTATUS_E_INVALID;

 &nbsp; cErrors++;
 &nbsp; ihRow++;
 &nbsp; continue;
  }

  // Get RowBuffer to look at which row this applies to
  pbProvRow = (BYTE *) (m_pObj-&gt;GetRowBuff((ULONG) rghRows[ihRow] ));

  // Has row already been deleted
  //&nbsp; S_OK means deleted
  if (S_OK == m_pObj-&gt;m_pFileio-&gt;IsDeleted((ULONG) ((PROWBUFF) pbProvRow)-&gt;pbBmk ))
  {
 &nbsp; if (rgRowStatus)
 &nbsp;&nbsp; rgRowStatus[ihRow] = DBROWSTATUS_E_DELETED;
 &nbsp; cErrors++;
 &nbsp; ihRow++;
 &nbsp; continue;
  }

  // Delete the Row,
  if (S_OK != m_pObj-&gt;m_pFileio-&gt;DeleteRow((ULONG) ((PROWBUFF) pbProvRow)-&gt;pbBmk ))
  {
 &nbsp; // Some better decision as to what rowstatus to set could be done here..
 &nbsp; if (rgRowStatus)
 &nbsp;&nbsp; rgRowStatus[ihRow] = DBROWSTATUS_E_PERMISSIONDENIED;
 &nbsp; cErrors++;
 &nbsp; ihRow++;
 &nbsp; continue;
  }
 } //while


 // If everything went OK except errors in rows use DB_S_ERRORSOCCURRED.
 return cErrors ? (cErrors &lt; cRows) ? 
 &nbsp; ResultFromScode(DB_S_ERRORSOCCURRED) : 
 &nbsp; ResultFromScode(DB_E_ERRORSOCCURRED) : 
 &nbsp; ResultFromScode(S_OK);
}</code></pre>
</pre>
</td>
</tr>
</table><br>
</font></BODY>
</HTML>
