<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Recordset Sample</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="vjhowrecordsetscenario"></a>Recordset Sample</h1>
<p>
This sample extends the <a href="vjjado_8lph.htm">framework code</a> by making use of the Recordset, one of the core ADO/WFC classes. Recordsets can be opened much like a Connection, and can be used to execute data operations (such as add, remove, update) and to marshal tabular data to and from business objects. </p>
<pre><code>// Establish a global variable to hold the open Recordset
// used in run(), createRecordset(), and useRecordset().
private Recordset rs;

public boolean run()
{
 &nbsp; boolean fSuccess = true;
 &nbsp; fSuccess = createRecordset();
 &nbsp; useRecordset ();
 &nbsp; rs.close();
 &nbsp; return fSuccess;
}

boolean createRecordset ()
{
 &nbsp; Connection c = new Connection();
 &nbsp; c.open ("server=aDSN; ", "aName", "aPWD");

 &nbsp; rs = new Recordset();
 &nbsp; rs.setActiveConnection ("dsn=aDSN;database=pubs");
 &nbsp; rs.setSource ("select * from authors");
 &nbsp; rs.setActiveConnection (c);
 &nbsp; 
 &nbsp; rs.setCursorType (AdoEnums.adOpenStatic);
 &nbsp; rs.setCursorLocation (AdoEnums.adUseClientBatch);
 &nbsp; rs.setLockType (AdoEnums.adLockBatchOptimistic);
 &nbsp; rs.setCacheSize (10);
 &nbsp; rs.setMaxRecords (1000);
 &nbsp; rs.open();

 &nbsp; return true;
}

boolean useRecordset()
{
 &nbsp; // Extract all of the Recordset properties and 
 &nbsp; // print out the &lt;attribute, value&gt;-tuples. 
 &nbsp; AdoProperties props = rs.getProperties();
 &nbsp; int cProps = props.getCount();
 &nbsp; for( int iProp = 0; iProp &lt; cProps; iProp++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; AdoProperty p = props.getItem( iProp );
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("[" + p.getName() + " = " + p.getString() + "]");
 &nbsp; }

 &nbsp; // Perform simple navigation and boundary checking 
 &nbsp; // (BOF= beginning of file, EOF= end of file). 
 &nbsp; rs.moveFirst();
 &nbsp; rs.movePrevious();
 &nbsp; if (! rs.getBOF())
 &nbsp;&nbsp;&nbsp;&nbsp; return false;

 &nbsp; rs.moveLast();
 &nbsp; rs.moveNext();
 &nbsp; if (! rs.getEOF())
 &nbsp;&nbsp;&nbsp;&nbsp; return false;

 &nbsp; int recordCount = rs.getRecordCount();
 &nbsp; System.out.println ("record count = " + recordCount);

 &nbsp; rs.addNew( new Object[] {"899-46-2036", "O'Maley", "Zoltar",
 &nbsp;&nbsp;&nbsp;&nbsp; "67 Seventh Av.", "Salt Lake City", new Boolean (true),
 &nbsp;&nbsp;&nbsp;&nbsp; "801 826-0752", "UT", "84152","409-56-7098"});

 &nbsp; rs.update();
 &nbsp; rs.delete(1);
 &nbsp; rs.addNew();
 &nbsp; rs.cancelUpdate();

 &nbsp; rs.moveFirst();
 &nbsp; rs.delete(1);
 &nbsp; rs.cancelBatch();

 &nbsp; rs.setMarshalOptions (AdoEnums.adMarshalModifiedOnly);
 &nbsp; rs.setPersistFormat (AdoEnums.adPersistADTG);
 &nbsp; 
 &nbsp; if (rs.getMarshalOptions() != AdoEnums.adMarshalModifiedOnly)
 &nbsp;&nbsp;&nbsp;&nbsp; return false;
 &nbsp; if (rs.getPersistFormat() != AdoEnums.adPersistADTG)
 &nbsp;&nbsp;&nbsp;&nbsp; return false;

 &nbsp; rs.moveFirst();
 &nbsp; Object bmk = rs.getBookmark();
 &nbsp; rs.moveLast();
 &nbsp; rs.setBookmark(bmk);
 &nbsp; rs.movePrevious();
 &nbsp; if (! rs.getBOF())
 &nbsp;&nbsp;&nbsp;&nbsp; return false;
 &nbsp; 
 &nbsp; rs.addNew();
 &nbsp; if (rs.getEditMode() != AdoEnums.adEditAdd)
 &nbsp;&nbsp;&nbsp;&nbsp; return false;
 &nbsp; rs.cancelUpdate();

 &nbsp; // Requery the result, overriding any local changes
 &nbsp; // and completely replacing the result.
 &nbsp; rs.requery();
 &nbsp; 
 &nbsp; return true;
}
</code></pre>
<p>
The <code>createRecordset</code> method creates a Recordset by opening a connection and executing a query against the data source referenced by the System DSN:</p>
<pre><code>rs = new Recordset();
rs.setActiveConnection ("dsn=aDSN;database=pubs");
rs.setSource ("select * from authors");
</code></pre>
<p>
The ActiveConnection property is used in much the same way that the ConnectionString property is utilized on the Connection object — to specify a data source to connect to. The Source property is an overloaded property that can either reference a SQL DDL/DML string or a Command object. In this case, a string is used to initialize the Recordset. Note that no data has been fetched yet, since the Recordset has not been opened. It is also possible to set the ActiveConnection property of a Recordset to refer to a Connection object instance, as in <code>rs.setActiveConnection(c)</code>.</p>
<p>
The remaining properties are used to specify aspects of the type of cursor required by the application:</p>
<pre><code>rs.setCursorType (AdoEnums.adOpenStatic);
rs.setCursorLocation (AdoEnums.adUseClientBatch);
rs.setLockType (AdoEnums.adLockBatchOptimistic);
rs.setMaxRecords (1000);
rs.open();
</code></pre>
<p>
Note that in the absence of explicit property settings, any Recordset created by an <code>open</code> method invocation will result in a static, forward-only, server cursor — the equivalent of a generic ANSI cursor. However, you may need a cursor that supports scrolling and batch behavior; you may need a “disconnected” cursor where you can apply changes locally before deciding whether to propagate those changes back to the data source. Applications can be written to capitalize on this local caching of data, which provides a better solution for Internet applications that cannot afford to keep server resources tied up. The particular property settings chosen above request a static, local cursor that does not keep any locks on server resources. Instead, it uses optimistic concurrency control when it tries to update the data source. The MaxRecords property specifies an upper bound on the amount of rows that should be returned. Finally, the Recordset is opened through the <code>open</code> method. If the connection information has been specified properly, the Recordset is populated with up to 1000 rows of data.</p>
<p>
The <code>useRecordset</code> method begins with an iteration over the Recordset properties that were set in the <code>createRecordset</code> method. The properties are returned in a collection, <code>AdoProperties</code>, which is then traversed. Each attribute name of the Recordset is printed, followed by the value of the specific property. This type of information may be considered “component metadata” — information about the state of the component, rather than on what it contains.</p>
<pre><code>AdoProperties props = rs.getProperties();
int cProps = props.getCount();
for( int iProp = 0; iProp &lt; cProps; iProp++ )
{
 &nbsp; AdoProperty p = props.getItem( iProp );
 &nbsp; System.out.println("[" + p.getName() + " = " + p.getString() + "]");
}
</code></pre>
<p>
The next block of code consists of simple navigation commands. If the Recordset has a scrollable cursor, it supports the following navigational methods: <code>moveFirst</code>, <code>moveNext</code>, <code>movePrevious</code>, and <code>moveLast</code>. Recordsets also provide a bookmark object so that a position may be bookmarked and navigated back to quickly and efficiently. This requires you to use code similar to the following:</p>
<pre><code>rs.moveFirst();
Object bmk = rs.getBookmark();
rs.moveLast();
rs.setBookmark(bmk);
rs.movePrevious();
</code></pre>
<p>
A bookmark has an “opaque” structure, but two bookmarks can be compared to determine if they reference the same location. This is useful to writers of visual components such as data grids and other complex data-bound components. In the code above, the bookmark is set for the current row pointed to by the Recordset. The current position is then changed to the final row in the set. Then, the bookmark is used to set the position back to where the Recordset was pointing before the position was moved to the final row. Finally, the Recordset is moved back from the new&nbsp; position, placing it before the first row in the set. Recordsets have two special “positions” or states: just before the first row and just after the last row. These states are called BOF and EOF, respectively, and are often used in iteration constructions to terminate navigation. Testing for the values of these boolean properties is quite common in ADO/WFC programming and familiar to programmers from DAO and RDO.</p>
<p>
The next cluster of operations performed on the open, populated Recordset revolve around data manipulation, such as adding rows, deleting rows, accepting local updates, and canceling these local changes. The advantage of the local, disconnected cursor can be seen in such circumstances. The programmer has wider discretion to modify local, non-persistent data, rather than alter production data in the data source. This allows for a more efficient partitioning of application logic between the client, the application server (if utilized), and the data source.</p>
<pre><code>rs.addNew( new Object[] {"899-46-2036", "MindFlayer", "Zortan", 
 &nbsp; "67 Seventh Ave.","Salt Lake City", new Boolean (true), 
 &nbsp; "801 826-0752", "UT", "84152", "409-56-7098"});

rs.update();
rs.delete(1);
rs.addNew();
rs.cancelUpdate();
</code></pre>
<p>
New rows are added to the Recordset in the form of arrays of Object values. The “shape” of the array should match that of the Recordset. In this case, it is for an author row. Data type checking is performed on the values, and if a type coercion is not supported for a particular column, then an exception (AdoException) will be thrown by the <code>addNew</code> method. Applications may choose to catch this run-time exception, or allow for the core exception handler to catch the condition. This usually means aborting the current process, so you are encouraged to use proper try/catch blocks around such operations. The <code>delete</code> call above marks the first row of the Recordset as deleted. The row is not actually purged from the Recordset until <code>commit</code> is called. (For more information about <code>commit</code>, see the <a href="vjjado_3145.htm">Transaction sample</a>.) Rows that are marked as deleted enter a “row deleted” state and are not visible to the user unless the <code>cancelUpdate</code> method is invoked. New rows may be appended to the Recordset using the <code>addNew</code> method, which creates a row with null values for all fields. The <code>update</code> method is used to actually “push” the local changes to the data source. </p>
<p>
Next, two Recordset properties are set to specify how data is marshaled. Data marshaling refers to the packaging, transfer, and unpackaging of data across process and/or machine boundaries. ADO/WFC supports distributed object invocation/operation and data marshaling over protocols such as HTTP 1.0/1.1 and DCOM. The following relevant properties are set for the Recordset:</p>
<pre><code>rs.setMarshalOptions(AdoEnums.adMarshalModifiedOnly);
rs.setPersistFormat(AdoEnums.adPersistADTG);
</code></pre>
<p>
The MarshalOptions property specifies that when it is time to marshal the Recordset back to a business object or to the data source, only the modified and new data will be sent. If you have a large result and only end up modifying a small minority of rows, this makes perfect sense, assuming that your business rules (objects) do not require the full result set for processing. The PersistFormat property tells the ADO run time to package the rows of the Recordset in a specific, optimized format for transfer — the ADTG tablegram streaming format defined by Microsoft. These properties are activated only when the Recordset is “pushed” from the client to the middle tier or data source.</p>
<p>
Finally, the <code>requery</code> method is introduced in this sample. This method has the effect of purging the local Recordset cache and replacing it with the most recent results of the query or SQL DML used to create the Recordset. This is useful if information has become stale on the client. A simple scenario is to refresh a monitor display that lists the current prices of traded securities. ADO/WFC makes it easy to “restart with latest data.” Unlike other data access models, getting the latest data is as straightforward as requerying your Recordset. </p>
<p>
The last step in this sample, after returning from the <code>useRecordset</code> method, is to close and release the resources of the Recordset. This is an important habit to get into, especially in your Java business objects when you use ADO/WFC for data access programming.</p>
</font></BODY>
</HTML>
