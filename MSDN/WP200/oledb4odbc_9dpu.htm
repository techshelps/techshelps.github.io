<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE DB for the ODBC Programmer</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbodbcprogrammer"></a>OLE DB for the ODBC Programmer</h1>
<p>
<i>by Michael Pizzo and Jeff Cochran</i></p>
<h1>Introduction</h1>
<p>
This paper presents an introduction to OLE DB programming using the Microsoft® OLE DB Software Developer’s Kit (SDK). The goal of this paper is to aid Open Database Connectivity (ODBC) programmers in understanding and using OLE DB. It discusses the relationship of ODBC calls to corresponding OLE DB methods and the related programming issues. Basic OLE DB concepts are discussed, whereas advanced OLE DB features, such as notifications, IPersist * objects, transaction objects, and coordinated transactions, are not covered.</p>
<p>
OLE DB and ODBC are application programming interfaces (APIs) designed to provide access to a wide range of data sources. A data source consists of the data, its associated database management system (DBMS), the platform on which the DBMS exists, and the network used to access that platform. </p>
<p>
ODBC is designed to provide access primarily to SQL data in a multiplatform environment. OLE DB is designed to provide access to all types of data in an OLE Component Object Model (COM) environment. OLE DB includes the SQL functionality defined in ODBC but also defines interfaces suitable for gaining access to data other than SQL data.</p>
<p>
OLE facilitates application integration by defining a set of standard <i>interfaces</i>, groupings of semantically related functions through which one application accesses the services of another. Interfaces are the binary standard for component object interaction. Each interface contains a set of functions that define a contract between the object implementing the interface and the client using it.</p>
<p>
OLE DB is designed using OLE COM; for more information about COM, see the <i>Microsoft OLE 2 Programmer’s Reference</i>, Volume 1. Each interface consists of a set of related methods. The full functionality of OLE DB is factored into a number of different interfaces. Each data provider will implement some subset of these interfaces. </p>
<h1>OLE and OLE DB</h1>
<p>
Some of the key OLE concepts that you should be aware of include:
<ul type=disc>
<li>
Interface factoring <p class=tl>
An interface in OLE is a set of related methods. A single OLE object may support multiple interfaces at the same time. The consumer of an object can move between any interfaces supported on that object by calling <b>QueryInterface</b> (see the following bullet,<i> </i>“Interface negotiation”). If an object supports an interface, it supports all of the methods within that interface. Thus, once the consumer has determined that a particular interface is supported, it understands how to interact with the object. New interfaces that augment the functionality already supported by the existing interfaces can be added later, but methods can never be added or removed from existing interfaces. </P><p class=tl>
Because an object must support either all or none of the methods within an interface, interfaces are generally factored according to functionality. For example, if an object supports reading data and does or does not support writing data, the methods for reading data and those for writing data would appear in two different interfaces. Only the objects that supported writing data would support the interface containing the methods for writing data.</P><p class=tl>
OLE DB makes extensive use of interface factoring. Individually supportable functionality, such as different levels of scrollability in a result set or command preparation and parameter support, are factored into different interfaces. Each object has one or more required interfaces that encapsulate base functionality for that object and that can expose extended functionality by implementing one or more optional interfaces. The OLE DB consumer can determine what extended functionality the provider supports by querying for these optional interfaces.</P></li>
<li>
Interface negotiation <p class=tl>
<b>IUnknown</b> is implemented by all component objects. All other interfaces inherit, directly or indirectly, from this interface. It has three methods: <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>. Each interface is identified by a globally unique identifier (GUID) by which it is known at compile time. To determine if an object supports a particular interface, the client calls <b>QueryInterface</b> on that object. If an object supports the requested interface, <b>QueryInterface</b> returns a pointer to the interface. The interface identifier (IID) allows the client to dynamically determine, by way of a call to <b>IUnknown::QueryInterface</b>, the capabilities of other objects and to get the pointers to needed interfaces. Every interface that is obtained directly (by calls to <b>QueryInterface</b>) or indirectly (by calls to a method that returns an interface) must be released by calling the <b>Release</b> method of that object.</P></li>
<li>
Reference counting<p class=tl>
Reference counts are kept on each instance of a pointer to an interface that is derived from <b>IUnknown</b>. This ensures that the object is not destroyed before all references to it are released. </P></li>
<li>
Memory management<p class=tl>
OLE uses two kinds of memory: local application task memory and shared memory. All task memory allocated by the OLE libraries and by the object handlers is allocated using either an application-supplied allocator or the default allocator provided by OLE. </P><p class=tl>
The standard memory management model in COM requires that the callee allocates and the caller frees. OLE DB generally follows this model, except for certain cases where performance can be gained by the caller allocating and reusing the same piece of memory, or in some special cases, by the callee giving the caller pointers to callee-owned data. In this case, the caller is not allowed to write to or free the memory. </P></li>
<li>
Unicode<p class=tl>
All COM interface methods pass Unicode rather than ANSI strings. OLE DB follows this convention, except for getting and setting ANSI data that resides in tables. </P></li>
</ul>
<h1>Components of OLE DB</h1>
<p>
OLE DB providers can be classified as data providers and service providers. A data provider is one that owns data and exposes it in a tabular form. Some examples are relational database systems and spreadsheets. A service provider is any OLE DB component that does not own the data but encapsulates some service by producing and consuming data through OLE DB interfaces. Examples are query processors and transaction managers. </p>
<h1>OLE DB Objects</h1>
<p>
The following illustration shows the core object model of OLE DB.</p>
<p class=label>
<b>OLE DB Object Model</b></p>
<p>
<img src="dawp03.gif" border=0>
<ul type=disc>
<li>
Data Source Object <p class=tl>
The data source object is the initial object returned from an enumerator (see the bullet, “Enumerator Object,” that follows), generated by binding a file moniker or other moniker to a data source, or instantiated by calling the OLE function <b>CoCreateInstance</b> with a given OLE DB data provider’s unique class identifier (CLSID). It encapsulates the functionality of the ODBC environment as well as the connection and informational properties of the ODBC connection.</P></li>
<li>
Session Object <p class=tl>
A session object defines the scope of a transaction and generates rowsets from the data source. If the provider supports commands, the session also acts as a command factory. The data source object can also support interfaces for describing schema information and for creating tables and indexes for providers that support that functionality. Along with the data source object, the session encapsulates the functionality of the ODBC connection. Calling <b>IDBCreateSession::CreateSession</b> creates a session from the data source object. There can be multiple sessions associated with a data source object. </P></li>
<li>
Command Object<p class=tl>
If a provider supports building and executing queries, it exposes a command object. A command object is generated from a session object. It is used to specify, prepare, and execute a DML query or DDL definition and associated properties. The command encapsulates the general functionality of an ODBC statement in an unexecuted state. There may be multiple commands associated with a single session.</P></li>
<li>
Rowset Object<p class=tl>
A rowset object is a shared data object that represents tabular data, such as a result set returned by executing a query. Minimally, rowsets can be generated by calling <b>IOpenRowset::OpenRowset</b> on the session. All providers are required to support this minimal functionality. If the provider supports commands, rowsets are used to represent the results of row-returning queries. There are a number of other methods in OLE DB, such as the schema functions, that return information in the form of a rowset. A rowset encapsulates the general functionality of an ODBC statement in the executed state. There may be multiple rowsets associated with a single session or command.</P></li>
</ul>
<h1>Other OLE DB Objects</h1>
<p>
The following objects are also defined in OLE DB. They provide recursive data source enumeration, enhanced transaction control, and extended error retrieval.
<ul type=disc>
<li>
Enumerator Object<p class=tl>
Enumerator Objects list the data sources and enumerators visible to that enumerator. This is similar to the information provided by <b>SQLDataSources</b>, except that the information can be recursive.</P></li>
<li>
Transaction Object<p class=tl>
In addition to supporting <b>ITransactionLocal</b> on the session, providers that support transactions can optionally support the creation of a transaction object. Transaction objects provide more advanced transaction functionality, such as the registration of transaction notifications. </P></li>
<li>
Error Object<p class=tl>
In addition to the return codes and status information returned by each method in OLE DB, providers can optionally expose an OLE DB error object for extended error information, such as a description of the error or the appropriate SQLSTATE. This is similar to the information returned by <b>SQLError</b> or <b>SQLGetDiagRec</b><sup>1</sup>.</P></li>
</ul>
<p class=mini>
<sup>1</sup> Unless explicitly stated otherwise, ODBC 3.0 functions and function names are used throughout. For more information on mapping ODBC 1.x and 2.x to their ODBC 3.0 equivalents, see the ODBC 3.0 documentation.</p>
<h1>Basic OLE DB</h1>
<p>
This section describes the basic concepts and procedures defined in OLE DB, such as initializing the environment, locating and connecting to a data source, executing a command, and retrieving data from a rowset.</p>
<h1>Application Flow</h1>
<p>
The application flow in OLE DB is similar to the application flow in ODBC. In both cases, the application:
<ul type=disc>
<li>
Initializes the environment.<br><br></li>
<li>
Connects to a data source.<br><br></li>
<li>
Creates and executes a command.<br><br></li>
<li>
Processes results, if any.<br><br></li>
<li>
Cleans up.</li>
</ul>
<p>
A typical OLE DB consumer may look like the following code example. For the complete source code listing, see Appendix A. The individual routines in this sample are described in more detail in the following sections. The flow of control is as follows:
<ol>
<li>
Initialize OLE.<br><br></li>
<li>
Connect to a data source object.<br><br></li>
<li>
Create and execute a command.<br><br></li>
<li>
Process the results.<br><br></li>
<li>
Release objects and uninitialize OLE.</li>
</ol>
<pre><code>/********************************************************************
* General OLE DB application main()
********************************************************************/
#define UNICODE
#define _UNICODE
#define DBINITCONSTANTS // Initialize OLE constants...
#define INITGUID&nbsp;&nbsp;&nbsp; // ...once in each app.

#include &lt;windows.h&gt;

#include &lt;oledb.h&gt;  // OLE DB include files
#include &lt;oledberr.h&gt; 
#include &lt;msdaguid.h&gt; // ODBC provider include files
#include &lt;msdasql.h&gt;

// Global task memory allocator
IMalloc*&nbsp;&nbsp;&nbsp; g_pIMalloc = NULL;

int main()
  {
  IDBInitialize*&nbsp; pIDBInitialize = NULL;
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset = NULL;

  // Init OLE and set up the DLLs; see "Initializing the 
  // Environment."
  CoInitialize(NULL);

  // Get the task memory allocator.
  if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;g_pIMalloc)))
 &nbsp;&nbsp; goto EXIT;

  // Connect to the data source; see "Initializing a Data Source."
  if (FAILED(myInitDSO(&amp;pIDBInitialize)))
 &nbsp;&nbsp; goto EXIT;

  // Get a session, set and execute a command; see "Getting a 
  // Session and Executing a Command."
  if (FAILED(myCommand(pIDBInitialize, &amp;pIRowset)))
 &nbsp;&nbsp; goto EXIT;

  // Retrieve data from rowset; see "OLE DB Rowsets."
  myGetData(pIRowset);

EXIT:
  // Clean up and disconnect.
  if (pIRowset != NULL)
 &nbsp;&nbsp; pIRowset-&gt;Release();

  if (pIDBInitialize != NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if (FAILED(pIDBInitialize-&gt;Uninitialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Uninitialize is not required, but it will fail if an 
 &nbsp;&nbsp; // interface has not been released. We can use it for 
 &nbsp;&nbsp; // debugging.
 &nbsp;&nbsp; DumpError("Someone forgot to release something!");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; pIDBInitialize-&gt;Release();
 &nbsp;&nbsp; }

  if (g_pIMalloc != NULL)
 &nbsp;&nbsp; g_pIMalloc-&gt;Release();

  CoUninitialize();
  
  return (0);
  }</code></pre>
<h1>Initializing the Environment</h1>
<p>
In ODBC, the application generally dynamically links to the ODBC Driver Manager (Odbc32.dll). The Driver Manager loads and directs calls to the appropriate driver.</p>
<p>
In OLE DB, initialization of the environment is achieved by a call to <b>OleInitialize</b>, which initializes the OLE library. This is shown in the preceding code example. After the OLE library is initialized, the proper data provider is loaded by the system according to its class ID, and calls are made directly to the provider.</p>
<h1>Initializing a Data Source</h1>
<p>
The data source object exposes the <b>IDBInitialize</b> and <b>IDBProperties</b> interfaces that contain the methods to connect to a data source. The authentication information such as user ID, password, and the name of the data source are specified as properties of the data source object by calling <b>IDBProperties::SetProperties</b>. The method <b>IDBInitialize::Initialize</b> uses the specified properties to connect to the data source.</p>
<p>
In ODBC, establishing a connection involves the following steps:
<ol>
<li>
Call <b>SQLAllocHandle</b> to allocate a connection handle. <br><br></li>
<li>
Build a connection string containing keywords for authentication information, such as user ID, password, and the name of the data source.<br><br></li>
<li>
Call <b>SQLDriverConnect</b> providing the connection string and other information, such as level of prompting and the application’s window handle where appropriate.</li>
</ol>
<p>
In OLE DB, the equivalent functionality is achieved by the following steps:
<ol>
<li>
Build an array of property structures describing the authentication information, such as user ID, password, and the name of the data source, as well as the level of prompting and the application’s window handle when appropriate.<br><br></li>
<li>
Call <b>IDBProperties::SetProperties</b> to set initialization properties. (For more information about properties, see the following section, “Getting and Setting Properties”.)<br><br></li>
<li>
Call <b>IDBInitialize::Initialize</b> to initialize the data source object.</li>
</ol>
<p>
As can be seen, the model in OLE DB is similar to the model in ODBC. The primary differences are:
<ul type=disc>
<li>
OLE DB uses a well-defined set of property structures to represent the initialization and connection information, rather than building/parsing keywords within a connection string.<br><br></li>
<li>
The set of property structures is used for all of the initialization/connection information.<br><br></li>
<li>
The set of available initialization properties can be queried through <b>IDBProperties::GetPropertyInfo</b>.<br><br></li>
<li>
Rather than returning a connection string, the user can simply request the current set of initialization property values. <br><br></li>
<li>
Setting the initialization properties is separate from actually initializing (connecting) the data source. This allows the consumer to set, persist, and retrieve connection information without initializing (connecting) the data source.</li>
</ul>
<p>
The following code example shows a routine that initializes a data source object. The general flow of control is:
<ol>
<li>
Create an instance of the OLE DB Provider (in this case, the ODBC Provider).<br><br></li>
<li>
Set the initialization properties.<br><br></li>
<li>
Call <b>Initialize</b> to initialize the data source object, using the supplied properties.</li>
</ol>
<pre><code>/********************************************************************
* Initialize the data source.
********************************************************************/
HRESULT myInitDSO
  (
  IDBInitialize** ppIDBInitialize   // [out]
  )
  {
  // Create an instance of the MSDASQL (ODBC) provider.
  CoCreateInstance(CLSID_MSDASQL, NULL, CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp; IID_IDBInitialize, (void**)ppIDBInitialize);

  if (*ppIDBInitialize == NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  // See "Getting and Setting Properties."
  if (FAILED(mySetInitProps(*ppIDBInitialize)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  if (FAILED((*ppIDBInitialize)-&gt;Initialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("IDBInitialze-&gt;Initialize failed.");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  return (NOERROR);
  }</code></pre>
<h1>Getting and Setting Properties</h1>
<p>
Properties are used in OLE DB to specify options, such as initialization information on the data source object or supported properties of a rowset, as well as to discover properties of certain objects, such as the updatability of a rowset.</p>
<p>
Properties in OLE DB are similar to the environment, connection, and statement attributes in ODBC, with the following exceptions:
<ul type=disc>
<li>
In OLE DB, the provider can be queried for a list of all supported properties.<br><br></li>
<li>
In OLE DB, properties are grouped into “Property Groups.” Property groups are identified by a GUID. This allows third parties to define properties within their own property group, rather than trying to reserve ranges within a single set of attribute values.<br><br></li>
<li>
Instead of setting and retrieving properties individually, multiple properties can be set or retrieved from multiple groups in a single call. This is done by building an array of property sets, where each property set contains an array of property structures from a single property group.</li>
</ul>
<p>
OLE DB consumers can:
<ul type=disc>
<li>
Enumerate, set, and retrieve properties on a data source object using <b>IDBProperties</b>.<br><br></li>
<li>
Set or retrieve properties on a session using <b>ISessionProperties</b>.<br><br></li>
<li>
Set or retrieve properties on a command using <b>ICommandProperties</b>.<br><br></li>
<li>
Retrieve properties and information about a rowset using <b>IRowsetInfo</b>.</li>
</ul>
<p>
The following table shows the property groups in OLE DB and their GUIDs.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=43%><b>Property group</b></td>
<td class=label width=57%><b>Property group identifier (GUID)</b></td>
</tr>
<tr valign=top>
<td width=43%>Column</td>
<td width=57%>DBPROPFLAGS_COLUMN</td>
</tr>
<tr valign=top>
<td width=43%>Data Source</td>
<td width=57%>DBPROPFLAGS_DATASOURCE</td>
</tr>
<tr valign=top>
<td width=43%>Data Source Creation</td>
<td width=57%>DBPROPFLAGS_DATASOURCECREATE</td>
</tr>
<tr valign=top>
<td width=43%>Data Source Information</td>
<td width=57%>DBPROPFLAGS_DATASOURCEINFO</td>
</tr>
<tr valign=top>
<td width=43%>Data Source Initialization</td>
<td width=57%>DBPROPFLAGS_DBINIT</td>
</tr>
<tr valign=top>
<td width=43%>Index</td>
<td width=57%>DBPROPFLAGS_INDEX</td>
</tr>
<tr valign=top>
<td width=43%>Rowset</td>
<td width=57%>DBPROPFLAGS_ROWSET</td>
</tr>
<tr valign=top>
<td width=43%>Session</td>
<td width=57%>DBPROPFLAGS_SESSION</td>
</tr>
<tr valign=top>
<td width=43%>Table</td>
<td width=57%>DBPROPFLAGS_TABLE</td>
</tr>
</table><br>
<p>
The following structure contains an array of values of properties from a single property set:</p>
<pre><code>typedef struct&nbsp; tagDBPROPSET
  {
  DBPROP __RPC_FAR* rgProperties;&nbsp; // Pointer to an array of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DBPROP structures.
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cProperties;&nbsp;&nbsp; // Count of properties
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (DBPROPS) in the array.
  GUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guidPropertySet; // A GUID that identifies the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // property set to which the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // properties belong.
  } DBPROPSET;</code></pre>
<p>
The following structure contains information about a single property:</p>
<pre><code>typedef struct&nbsp; tagDBPROP
  {
  DBPROPID&nbsp;&nbsp;&nbsp; dwPropertyID;   // ID of property within a
               // property set.
  DBPROPOPTIONS&nbsp;&nbsp; dwOptions;   // Property is required?
               // Optional?
  DBPROPSTATUS&nbsp; dwStatus;   // Status returned by the
               // provider indicating success 
               // or failure in setting or 
               // getting the property. 
               // Enumerated values are: 
               //&nbsp; DBPROPSTATUS_OK
               //&nbsp; DBPROPSTATUS_NOTSUPPORTED
               //&nbsp; DBPROPSTATUS_BADVALUE
               //&nbsp; DBPROPSTATUS_BADOPTION
               //&nbsp; DBPROPSTATUS_BADCOLUMN
               //&nbsp; DBPROPSTATUS_NOTALLSETTABLE
               //&nbsp; DBPROPSTATUS_NOTSET
               //&nbsp; DBPROPSTATUS_NOTSETTABLE
               //&nbsp; DBPROPSTATUS_CONFLICTING
  DBID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colid;      // Optional, ordinal column
               // property applies to. If the 
               // property applies to all 
               // columns, colid should be set 
               // to DB_NULLID.
  VARIANT&nbsp;&nbsp;&nbsp;&nbsp; vValue;      // Value of the property.
  } DBPROP;</code></pre>
<p>
The following code example shows how an application sets initialization properties on a data source object. The code sets four properties within a single property group. The general flow of control is:
<ol>
<li>
Allocate an array of property structures. <br><br></li>
<li>
Allocate an array of a single property set.<br><br></li>
<li>
Initialize common property elements for the properties.<br><br></li>
<li>
Fill in the following properties:<ul type=disc>
<li>
Level of desired prompting (similar to <i>DriverCompletion</i> argument in <b>SQLDriverConnect</b>)<br><br></li>
<li>
Data source name (similar to <i>DSN=</i> element of the ODBC connection string)<br><br></li>
<li>
User name (similar to the <i>UID=</i> element of the ODBC connection string)<br><br></li>
<li>
Password (similar to the <i>PWD=</i> element of the ODBC connection string)</li>
</ul>
</li>
<li>
Set the property set to the array of properties and specify that the properties are from the initialization property group.<br><br></li>
<li>
Get the <b>IDBProperties</b> interface.<br><br></li>
<li>
Call <b>SetProperties</b> on the interface.</li>
</ol>
<pre><code>/********************************************************************
* Set initialization properties on a data source.
********************************************************************/
HRESULT mySetInitProps
  (
  IDBInitialize*&nbsp; pIDBInitialize   // [in]
  )
  {
  const ULONG&nbsp;&nbsp; nProps = 4;
  IDBProperties*&nbsp; pIDBProperties;
  DBPROP&nbsp;&nbsp;&nbsp; InitProperties[nProps];
  DBPROPSET&nbsp;&nbsp; rgInitPropSet;
  HRESULT&nbsp;&nbsp; hr;

  // Initialize common property options.
  for (ULONG i = 0; i &lt; nProps; i++ )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; VariantInit(&amp;InitProperties[i].vValue);
 &nbsp;&nbsp; InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
 &nbsp;&nbsp; InitProperties[i].colid = DB_NULLID;
 &nbsp;&nbsp; }

  // Level of prompting that will be done to complete the
  // connection process.
  InitProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
  InitProperties[0].vValue.vt = VT_I2;
  InitProperties[0].vValue.iVal = DBPROMPT_NOPROMPT;

  // Data source name--see the sample source code included with the
  // OLE DB SDK.
  InitProperties[1].dwPropertyID = DBPROP_INIT_DATASOURCE;
  InitProperties[1].vValue.vt = VT_BSTR;
  InitProperties[1].vValue.bstrVal =
 &nbsp;&nbsp; SysAllocString(OLESTR("OLE_DB_NWind_Jet"));

  // User ID
  InitProperties[2].dwPropertyID = DBPROP_AUTH_USERID;
  InitProperties[2].vValue.vt = VT_BSTR;
  InitProperties[2].vValue.bstrVal = SysAllocString(OLESTR(""));

  // Password
  InitProperties[3].dwPropertyID = DBPROP_AUTH_PASSWORD;
  InitProperties[3].vValue.vt = VT_BSTR;
  InitProperties[3].vValue.bstrVal = SysAllocString(OLESTR(""));

  rgInitPropSet.guidPropertySet = DBPROPSET_DBINIT;
  rgInitPropSet.cProperties = nProps;
  rgInitPropSet.rgProperties = InitProperties;

  // Set initialization properties.
  pIDBInitialize-&gt;QueryInterface(IID_IDBProperties, (void**)
 &nbsp;&nbsp; &amp;pIDBProperties);
  hr = pIDBProperties-&gt;SetProperties(1, &amp;rgInitPropSet);

  SysFreeString(InitProperties[1].vValue.bstrVal);
  SysFreeString(InitProperties[2].vValue.bstrVal);
  SysFreeString(InitProperties[3].vValue.bstrVal);

  pIDBProperties-&gt;Release();

  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Set properties failed.");
 &nbsp;&nbsp; }

  return (hr);
  }</code></pre>
<h1>Getting a Session and Executing a Command </h1>
<p>
The data source object exposes the <b>IDBCreateSession</b> interface through which a session object can be created. A session defines transaction scope and acts mainly as a command generator by supporting the <b>IDBCreateCommand</b> interface. Commands contain a DML query or a DDL definition. The execution of a row-returning command yields a rowset object. </p>
<p>
The session object in OLE DB is similar to the ODBC connection handle. However, the connection handle in ODBC is used for establishing connections as well as scoping transactions, so the application must allocate and connect a separate connection handle for each concurrent transaction. In OLE DB you can have multiple session objects on one initialized data source object, which means you can have multiple concurrent transactions without having to make multiple connections (where necessary, the provider makes additional connections using the connection information provided in the initialization of the data source object).</p>
<p>
The command object in OLE DB is similar to the ODBC statement handle in the unexecuted state. Like the ODBC connection handle, which can have several statement handles, a session object can have several command objects. </p>
<p>
An ODBC application performs the following steps to execute a command:
<ol>
<li>
Calls <b>SQLAllocHandle</b> to allocate a statement.<br><br></li>
<li>
Calls <b>SQLSetStmtAttr</b> to set various attributes that affect how the command is executed (such as query time-out) and how the cursor is opened (such as scrollability, updatability, and so on).<br><br></li>
<li>
Calls <b>SQLPrepare</b> if it wants to prepare the statement for repeated execution.<br><br></li>
<li>
Calls <b>SQLExecute</b> or <b>SQLExecDirect</b> to execute the query.</li>
</ol>
<p>
To use a command, an OLE DB consumer performs these steps: 
<ol>
<li>
Calls <b>IDBCreateCommand</b> to create a command.<br><br></li>
<li>
Calls <b>ICommandProperties::SetProperties</b> to set various attributes that affect how the command is executed (such as query time-out), as well as requesting properties to be supported by the resulting rowset. Typical properties include scrollability, updatability, the number of active row handles a consumer can hold at one time, sensitivity to changes outside the rowset, and so on.<br><br></li>
<li>
Calls <b>ICommandText::SetCommandText</b> to specify the command text, along with a GUID representing the command’s dialect. The standard dialect for ANSI SQL commands is DBGUID_DBSQL.<br><br></li>
<li>
Calls <b>ICommandPrepare::Prepare</b> if it wants to prepare the query for repeated execution.<br><br></li>
<li>
Calls <b>ICommandText::Execute</b> to execute the command.</li>
</ol>
<p>
The following code example shows setting and executing a command, and retrieving a rowset. The general flow of control is:
<ol>
<li>
Obtain the <b>IDBCreateSession</b> interface.<br><br></li>
<li>
Call <b>CreateSession</b> to create a session object that scopes the transaction boundaries within the current connection.<br><br></li>
<li>
Call <b>CreateCommand</b> to create a command object within the transaction.<br><br></li>
<li>
Call <b>SetCommandText</b> to set the command text.<br><br></li>
<li>
Call <b>Execute</b> to execute the command.<br><br></li>
<li>
Release the command object.<br><br></li>
<li>
Return the rowset object.</li>
</ol>
<pre><code>/********************************************************************
* Execute a command, retrieve a rowset interface pointer.
********************************************************************/
HRESULT myCommand
  (
  IDBInitialize*&nbsp; pIDBInitialize, // [in]
  IRowset**&nbsp;&nbsp; ppIRowset&nbsp;&nbsp; // [out]
  ) 
  {
  IDBCreateSession* pIDBCreateSession;
  IDBCreateCommand* pIDBCreateCommand;
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset;
  ICommandText*&nbsp;&nbsp; pICommandText;
  LPCTSTR&nbsp;&nbsp;&nbsp;&nbsp; wSQLString = OLESTR("SELECT CompanyName,
                 City, Phone, Fax")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" FROM Customers")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" ORDER BY CompanyName,
                 City");
  LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;
  HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;

  // Get the DB session object.
  if (FAILED(pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession,
 &nbsp;&nbsp; (void**) &amp;pIDBCreateSession)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Session initialization failed.");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  // Create the session, getting an interface for command creation.
  hr = pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
  pIDBCreateSession-&gt;Release();
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Create session failed.");
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }

  // Create the command object.
  hr = pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText,
 &nbsp;&nbsp; (IUnknown**) &amp;pICommandText);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Create command failed.");
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }
  pIDBCreateCommand-&gt;Release();

  // The command requires the actual text as well as an indicator
  // of its language and dialect.
  pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLString);

  // Execute the command.
  hr = pICommandText-&gt;Execute(NULL, IID_IRowset, NULL,
 &nbsp; &amp;cRowsAffected, (IUnknown**) &amp;pIRowset);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Command execution failed.");
 &nbsp;&nbsp; }
  pICommandText-&gt;Release();

  *ppIRowset = pIRowset;
  return (hr);
  }
OLE DB Rowsets</code></pre>
<p>
A rowset provides a standard way to work with a multiset of rows where each row contains one or more columns of data. This provides a standard way for all OLE DB data providers to expose data in tabular form. </p>
<p>
A rowset can be obtained in several ways. The first method, supported by all providers, uses the <b>IOpenRowset</b> interface. <b>IOpenRowset</b> provides for the simple case of retrieving all the data from the table. This is equivalent to executing SELECT * FROM <i>table</i>. The second method, supported by SQL providers, involves creating and executing a command to get a rowset that meets specific criteria, such as SELECT * FROM <i>table</i> WHERE <i>condition</i>. The <b>ICommandProperties</b> interface on the command can be used to specify the interfaces and properties that must be supported by the rowsets returned by <b>ICommand::Execute</b>.</p>
<p>
Conceptually, rowsets are similar to result sets in ODBC; however, their implementation is different. </p>
<p>
In ODBC, when the application calls <b>SQLFetch</b> or <b>SQLGetData</b> to retrieve data, the data is read from the database into the application’s memory. At that point, the application owns the data; neither the ODBC driver nor other components have access to that data. This model works fine provided that:
<ul type=disc>
<li>
The application is the only client of the data.<br><br></li>
<li>
A single component provides all of the functionality needed by the application.<br><br></li>
<li>
The application is in an environment in which it can maintain a connection to the database that keeps the state of the application’s position within the data, concurrency information for data retrieved, and so on. </li>
</ul>
<p>
OLE DB rowsets are not only designed to provide a high performance solution for the preceding scenarios but are also designed so that:
<ul type=disc>
<li>
Multiple controls can work together on the same data. For example, a grid control and a chart control can model the same results: If the grid control updates the data, the chart control gets a notification and can redraw the graph accordingly.<br><br></li>
<li>
Multiple components can work together to add incremental functionality to a single instance of the data. The data does not have to be copied to multiple components, and method calls don’t have to go through a hierarchy of components. Each component can operate directly on the data.<br><br></li>
<li>
The application can work in a disconnected environment with a stand-alone data object that maintains state, concurrency, and other information.</li>
</ul>
<p>
The OLE DB rowset basically takes the memory buffer out of the application and puts it in a stand-alone, shared data object. Rather than the application buffering data in its own memory, components access data in this shared memory through high-performance binding descriptions known as <i>accessors</i>. Because, in many cases, the application merely retrieves pointers to existing data and multiple components can access the same copy of the data, data access can often be faster than copying the data into the application’s own buffers. The rowset object also allows multiple components to coordinate their activities on this shared data object through notifications, and because the components are all sharing the same data, they can immediately see the changes made by other components. The rowset object exposes bookmarks, which let each individual component keep track of its own position, and the rowset object keeps track of concurrency information for deferred updating and optimistic concurrency control.</p>
<h1>Retrieving Data from a Rowset</h1>
<p>
The main differences between how data is retrieved in ODBC and how data is retrieved in OLE DB are a direct result of the differences between the application-owned data model of ODBC and the shared-data model of OLE DB.</p>
<p>
The most basic rowset in OLE DB exposes the following interfaces:
<ul type=disc>
<li>
<b>IColumnsInfo</b>. Provides information about the columns of the rowset (metadata). This is similar to <b>SQLDescribeCol</b> in ODBC.<br><br></li>
<li>
<b>IRowsetInfo</b>. Provides information about the rowset. This is similar to <b>SQLGetStmtAttr</b> in ODBC.<br><br></li>
<li>
<b>IAccessor</b>. Permits definition of groups of column bindings describing the way in which tabular data is bound to program variables. This is similar to the bindings specified through descriptors by calling <b>SQLSetDescField</b> in ODBC version 3.0.<br><br></li>
<li>
<b>IRowset</b>. Contains methods for iterating through the rows in the rowset sequentially. The methods in <b>IRowset</b> are similar to <b>SQLFetch</b> in ODBC.</li>
</ul>
<h1>Retrieving Rows</h1>
<p>
The provider manages the row buffers on behalf of the consumer. Rows are fetched from the data source into this row buffer using methods such as <b>IRowset::GetNextRows</b>, <b>IRowsetLocate::GetRowsAt</b>, and <b>IRowsetLocate::GetRowsByBookmark</b>. These methods are similar to <b>SQLExtendedFetch</b> in ODBC, except that instead of reading the data into the applications buffers, these functions read the data into the shared data object and return row handles (hRows) to the fetched data.</p>
<p>
The consumer accesses the data from these row handles using <b>IRowset::GetData</b>. <b>IRowset::GetData</b> takes an accessor that maps fields of the row to and/or from fields in a structure on the consumer side. The types of the fields in the consumer’s structure are indicated by the bindings in the accessor, and <b>IRowset::GetData</b> makes any necessary conversions between the buffered data and the consumer’s data structure. If <b>GetData</b> encounters an error, it sets the status value for the column to the appropriate error.</p>
<p>
To retrieve a row of data from the result set in ODBC, the application: 
<ol>
<li>
Calls <b>SQLBindCol</b> to bind the columns of the result set to storage locations, if not already done.<br><br></li>
<li>
Calls <b>SQLFetch</b> to move to the next row and retrieve data for all bound columns.<br><br></li>
<li>
Calls <b>SQLGetData</b> to retrieve data from unbound columns.</li>
</ol>
<p>
In OLE DB, the consumer performs the following functions to retrieve data:
<ol>
<li>
Calls <b>IAccessor::CreateAccessor</b> to specify binding information if not already done.<br><br></li>
<li>
Calls <b>IRowset::GetNextRows</b> to retrieve the next set of row handles.<br><br></li>
<li>
Calls <b>IRowset::GetData</b> to retrieve the data from the row handles according to the bindings specified by the accessor.</li>
</ol>
<p>
<b>IRowset::GetData</b> is similar to <b>SQLGetData</b> in ODBC, except that <b>IRowset::GetData</b>:
<ul type=disc>
<li>
Can be called for any held row handle, not just the current row.<br><br></li>
<li>
Allows the retrieval of multiple columns in a single call.<br><br></li>
<li>
Can return an interface to a live OLE object, not just a binary large object (BLOB).<br><br></li>
<li>
Can be used to return a pointer to data within the provider rather than a copy of the data.<br><br></li>
<li>
Returns an interface to a stream over the object rather than retrieve long data through multiple calls to <b>SQLGetData</b>.</li>
</ul>
<p>
The following code example demonstrates data retrieval in OLE DB. The general flow of control is:
<ol>
<li>
Get a description of the rowset.<br><br></li>
<li>
Build binding structures based on the description.<br><br></li>
<li>
Obtain the <b>IAccessor</b> interface on the rowset object.<br><br></li>
<li>
Call <b>CreateAccessor</b> to create an accessor.<br><br></li>
<li>
Call <b>GetNextRows</b> to retrieve the next set of row handles.<br><br></li>
<li>
Call <b>GetData</b> to access the data for each row.<br><br></li>
<li>
Release the set of retrieved row handles.<br><br></li>
<li>
Repeat steps 4 through 6 until all the data has been retrieved.<br><br></li>
<li>
Release the accessor.</li>
</ol>
<pre><code>/********************************************************************
* Retrieve data from a rowset.
********************************************************************/
void myGetData
  (
  IRowset*&nbsp; pIRowset&nbsp; // [in]
  ) 
  {
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nCols;
  DBCOLUMNINFO* pColumnsInfo = NULL;
  OLECHAR*&nbsp;&nbsp;&nbsp; pColumnStrings = NULL;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nCol;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cRowsObtained;&nbsp;&nbsp;&nbsp; // Count of rows
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // obtained
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; iRow;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Row count
  HROW&nbsp;&nbsp;&nbsp; rghRows[NUMROWS_CHUNK]; // Row handles
  HROW*&nbsp;&nbsp;&nbsp;&nbsp; pRows = &amp;rghRows[0];&nbsp; // Pointer to the row
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handles
  IAccessor*&nbsp; pIAccessor;&nbsp;&nbsp;&nbsp;&nbsp; // Pointer to the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accessor
  HACCESSOR&nbsp;&nbsp; hAccessor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Accessor handle
  DBBINDSTATUS* pDBBindStatus = NULL;
  DBBINDING*&nbsp; pDBBindings = NULL;
  char*&nbsp;&nbsp;&nbsp;&nbsp; pRowValues;

  // Get the description of the rowset for use in binding structure
  // creation; see "Describing Query Results."
  if (FAILED(myGetColumnsInfo(pIRowset, &amp;nCols, &amp;pColumnsInfo,
 &nbsp;&nbsp; &amp;pColumnStrings)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return;
 &nbsp;&nbsp; }

  // Create the binding structures; see "Elements of an Accessor."
  myCreateDBBindings(nCols, pColumnsInfo, &amp;pDBBindings,
 &nbsp;&nbsp; &amp;pRowValues);
  pDBBindStatus = new DBBINDSTATUS[nCols];

  // Create the accessor; see "Creating Accessors."
  pIRowset-&gt;QueryInterface(IID_IAccessor, (void**) &amp;pIAccessor);
  pIAccessor-&gt;CreateAccessor(
 &nbsp;&nbsp; DBACCESSOR_ROWDATA,// Accessor will be used to retrieve row
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // data
 &nbsp;&nbsp; nCols,&nbsp;&nbsp;&nbsp;&nbsp; // Number of columns being bound
 &nbsp;&nbsp; pDBBindings,&nbsp;&nbsp; // Structure containing bind info
 &nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not used for row accessors 
 &nbsp;&nbsp; &amp;hAccessor,&nbsp;&nbsp;&nbsp; // Returned accessor handle
 &nbsp;&nbsp; pDBBindStatus&nbsp; // Information about binding validity
 &nbsp;&nbsp; );
  // Process all the rows, NUMROWS_CHUNK rows at a time.
  while (TRUE)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pIRowset-&gt;GetNextRows(
 &nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cRowsToSkip
 &nbsp;&nbsp; NUMROWS_CHUNK,&nbsp; // cRowsDesired
 &nbsp;&nbsp; &amp;cRowsObtained,&nbsp;&nbsp; // cRowsObtained
 &nbsp;&nbsp; &amp;pRows );&nbsp;&nbsp;&nbsp;&nbsp; // Filled in w/ row handles.


 &nbsp;&nbsp; // All done; there are no more rows left to get.
 &nbsp;&nbsp; if (cRowsObtained == 0)
 &nbsp;&nbsp; break;

 &nbsp;&nbsp; // Loop over rows obtained, getting data for each.
 &nbsp;&nbsp; for (iRow=0; iRow &lt; cRowsObtained; iRow++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pIRowset-&gt;GetData(rghRows[iRow], hAccessor, pRowValues);
 &nbsp;&nbsp; for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; wprintf(OLESTR("%s%s:"), pColumnsInfo[nCol].pwszName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcslen(pColumnsInfo[nCol].pwszName) &gt; 10 ?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("\t") : OLESTR("\t\t"));
 &nbsp;&nbsp;&nbsp;&nbsp; printf("\t%s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pRowValues[pDBBindings[nCol].obValue]);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; printf("\n");
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Release row handles.
 &nbsp;&nbsp; pIRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL,
 &nbsp;&nbsp; NULL);
 &nbsp;&nbsp; }&nbsp; // End while

  // Release the accessor.
  pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL);
  pIAccessor-&gt;Release();

  delete [] pDBBindings;
  delete [] pDBBindStatus;

  g_pIMalloc-&gt;Free( pColumnsInfo );
  g_pIMalloc-&gt;Free( pColumnStrings );

  return;
  }</code></pre>
<h1>Describing Query Results</h1>
<p>
In ODBC, to describe the results of a query, an application:
<ul type=disc>
<li>
Calls <b>SQLNumResultCols</b> to find out the number of columns in the result set.<br><br></li>
<li>
Calls <b>SQLDescribeCol</b> or <b>SQLColAttribute</b> to describe each column in the result set.</li>
</ul>
<p>
In OLE DB, to describe the results of a query, an application: 
<ul type=disc>
<li>
Calls <b>IColumnsInfo</b> or <b>IColumnsRowset</b> to describe the columns in the rowset.</li>
</ul>
<p>
In OLE DB, the consumer can also call <b>IRowsetInfo</b> to get information about properties supported on the rowset. This is similar to calling <b>SQLGetStmtAttr</b> on an executed statement handle in ODBC.</p>
<p>
The following code example shows getting the metadata from the result set. Note that the <b>ColumnsInfo </b>interface passes off ownership of both the DBCOLUMNINFO structure array and the OLECHAR string that holds strings that are part of the rowset’s metadata. These strings are freed using the task memory allocation interface, <b>IMalloc</b>.</p>
<pre><code>/********************************************************************
* Get the characteristics of the rowset (the ColumnsInfo interface).
********************************************************************/
HRESULT myGetColumnsInfo
  (
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset,&nbsp;&nbsp;&nbsp; // [in]
  ULONG*&nbsp;&nbsp;&nbsp; pnCols,&nbsp;&nbsp;&nbsp; // [out]
  DBCOLUMNINFO**&nbsp; ppColumnsInfo, // [out]
  OLECHAR**&nbsp;&nbsp; ppColumnStrings&nbsp; // [out]
  )
  {
  IColumnsInfo* pIColumnsInfo;
  HRESULT&nbsp;&nbsp; hr;

  if (FAILED(pIRowset-&gt;QueryInterface(IID_IColumnsInfo, (void**)
 &nbsp; &amp;pIColumnsInfo)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Query rowset interface for IColumnsInfo failed");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  hr = pIColumnsInfo-&gt;GetColumnInfo(pnCols, ppColumnsInfo,
 &nbsp; ppColumnStrings);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("GetColumnInfo failed.");
 &nbsp;&nbsp; *pnCols = 0;
 &nbsp;&nbsp; }

  pIColumnsInfo-&gt;Release();
  return (hr);
  }</code></pre>
<h1>OLE DB Accessors</h1>
<p>
An accessor contains the binding information for one or more columns or parameters. The bindings supplied by the caller describe a data structure with offsets for each value. The consumer is responsible for correctly calculating the offsets. The consumer specifies the desired data type within the structure and the provider agrees to the binding if the conversion is legal and supported. The accessors are created on the rowset or command and their implementation is specific to the provider. They contain information or code to pack and unpack rows held by the provider. The consumer uses them like handles on the access functions of the row or column. Consumers can use more than one accessor, or a single accessor can define the mapping between a structure and multiple columns or parameters.</p>
<p>
Accessors in OLE DB are similar to descriptor handles in ODBC. Each represents a reusable, extensible set of binding information for multiple columns of a result set or parameters to a statement. Multiple accessors can be created for a single rowset, just as multiple descriptors can be used on a single result set. Accessors can be created on a command object so that they can be shared between multiple rowsets the same way that descriptors can be shared between multiple result sets (hStmts).</p>
<h1>Creating Accessors</h1>
<p>
In ODBC version 3.0, applications can create reusable descriptor handles that specify extendable binding information for a set of columns. To use a descriptor, the ODBC application:
<ul type=disc>
<li>
Calls <b>SQLAllocHandle</b> to allocate a descriptor handle.<br><br></li>
<li>
Calls <b>SQLSetDescField</b> for each piece of binding information on each column.</li>
</ul>
<p>
In OLE DB, consumers create reusable accessor handles that specify binding information for a set of columns. To use an accessor, the consumer:
<ul type=disc>
<li>
Creates an array of binding structures, each describing the binding information for a single column.<br><br></li>
<li>
Calls <b>CreateAccessor</b> to create an accessor handle using the binding information.</li>
</ul>
<p>
The main difference between descriptors and accessors is that <b>SQLSetDescField</b> is called multiple times to set individual properties for each column represented by the descriptor, while all of the binding information for an accessor is built into an array of binding structures that is passed in a single call to <b>CreateAccessor</b>. This is partially addressed in ODBC by the presence of&nbsp; “concise” functions, such as <b>SQLBindCol</b> and <b>SQLSetDescRec</b>, which allow the application to specify the most common subset of binding information in a single call per column.</p>
<h1>Elements of an Accessor</h1>
<p>
The section of memory bound to a column or parameter must have at least one and can have up to three of the following parts:
<ul type=disc>
<li>
Value. The actual column or parameter value.<br><br></li>
<li>
Length. The actual length of the column or parameter data stored in the value part, in bytes.<br><br></li>
<li>
Status. This serves a dual purpose. First, it indicates if the value is NULL. Second, it is used to return information about whether the value was successfully passed to or returned from the provider.</li>
</ul>
<p>
It is possible to have columns that are deferred. For a deferred column, the provider is not required to retrieve data until <b>IRowset::GetData</b> is called for that column or, if the column contains an OLE object, until a method used to access the object is called. The advantage of deferred columns is that data retrieval can be postponed until the data is needed, which is very beneficial when the data is large. </p>
<p>
The following structure defines the information specified for each column bound by an accessor.</p>
<pre><code>typedef struct tagDBBINDING
  {
  ULONG iOrdinal;         // Ordinal of column or
               // parameter to bind.
  ULONG obValue;         // Offset in consumer's buffer
               // for value.
  ULONG obLength;         // Offset in consumer's buffer
               // for length of value.
  ULONG obStatus;         // Offset in consumer's buffer
               // for status of operation.
  ITypeInfo __RPC_FAR* pTypeInfo;   // Reserved, should be NULL.
  DBOBJECT __RPC_FAR* pObject;   // Pointer to object structure.
               // Structure describes access 
               // to OLE objects in the 
               // column.
  DBBINDEXT __RPC_FAR* pBindExt;   // Reserved, should be NULL.
  DBPART dwPart;         // Enumerated parts to bind 
               // (value/length/status).
  DBMEMOWNER dwMemOwner;      // Memory is owned by consumer?
               // Provider?
  DBPARAMIO eParamIO;      // Parameter type
               // (input/output/not a 
               // parameter).
  ULONG cbMaxLen;         // Size of consumer's value
               // buffer if memory is consumer 
               // owned.
  DWORD dwFlags;         // Reserved, should be 0.
  DBTYPE wType;         // Data type indicator.
  BYTE bPrecision;         // Precision for
               // numeric/decimal data types.
  BYTE bScale;         // Scale for numeric/decimal
               // data types.
  } DBBINDING;</code></pre>
<p>
The provider returns column or output parameter data to the consumer and also sets the status value of each column or output parameter.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Status value</b></td>
<td class=label width=50%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_S_OK</td>
<td width=50%>Column/parameter value set/retrieved successfully.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_S_ISNULL</td>
<td width=50%>Column/parameter value is the NULL value.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_S_TRUNCATED</td>
<td width=50%>Column/parameter truncated.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_S_DEFAULT</td>
<td width=50%>The provider should use the parameter’s default value.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_BADACCESSOR</td>
<td width=50%>The accessor used to read/write the value was invalid.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_CANTCONVERT</td>
<td width=50%>The accessor specified an invalid conversion.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_CANTCREATE</td>
<td width=50%>The provider could not create a storage object for large data.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_DATAOVERFLOW</td>
<td width=50%>The conversion failed due to a data overflow.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_INTEGRITYVIOLATION</td>
<td width=50%>The data value violated an integrity constraint.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_PERMISSIONDENIED</td>
<td width=50%>The data value could not be set due to insufficient permissions.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_SCHEMAVIOLATION</td>
<td width=50%>The data value violated the Schema for the column.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_SIGNMISMATCH</td>
<td width=50%>The data value had the incorrect sign.</td>
</tr>
<tr valign=top>
<td width=50%>DBSTATUS_E_UNAVAILABLE</td>
<td width=50%>The data was not available.</td>
</tr>
</table><br>
<p>
The following code example shows traversing a DBCOLUMNINFO structure array obtained from a rowset and creating a set of bindings based on that information. An accessor is created from the binding structure array in the previous code sample.</p>
<pre><code>/********************************************************************
* Create binding structures from column information. Binding
* structures will be used to create an accessor that allows row value 
* retrieval.
********************************************************************/
void myCreateDBBindings
  (
  ULONG nCols,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [in]
  DBCOLUMNINFO* pColumnsInfo,&nbsp; // [in]
  DBBINDING** ppDBBindings,&nbsp; // [out]
  char** ppRowValues&nbsp;&nbsp;&nbsp;&nbsp; // [out]
  )
  {
  ULONG&nbsp;&nbsp; nCol;
  ULONG&nbsp;&nbsp; cbRow = 0;
  DBBINDING*&nbsp; pDBBindings;
  char*&nbsp;&nbsp; pRowValues;

  pDBBindings = new DBBINDING[nCols];

  for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pDBBindings[nCol].iOrdinal = nCol+1;
 &nbsp;&nbsp; pDBBindings[nCol].obValue = cbRow;
 &nbsp;&nbsp; pDBBindings[nCol].obLength = 0;
 &nbsp;&nbsp; pDBBindings[nCol].obStatus = 0;
 &nbsp;&nbsp; pDBBindings[nCol].pTypeInfo = NULL;
 &nbsp;&nbsp; pDBBindings[nCol].pObject = NULL;
 &nbsp;&nbsp; pDBBindings[nCol].pBindExt = NULL;
 &nbsp;&nbsp; pDBBindings[nCol].dwPart = DBPART_VALUE;
 &nbsp;&nbsp; pDBBindings[nCol].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 &nbsp;&nbsp; pDBBindings[nCol].eParamIO = DBPARAMIO_NOTPARAM;
 &nbsp;&nbsp; pDBBindings[nCol].cbMaxLen = pColumnsInfo[nCol].ulColumnSize;
 &nbsp;&nbsp; pDBBindings[nCol].dwFlags = 0;
 &nbsp;&nbsp; pDBBindings[nCol].wType = pColumnsInfo[nCol].wType;
 &nbsp;&nbsp; pDBBindings[nCol].bPrecision = pColumnsInfo[nCol].bPrecision;
 &nbsp;&nbsp; pDBBindings[nCol].bScale = pColumnsInfo[nCol].bScale;

 &nbsp;&nbsp; cbRow += pDBBindings[nCol].cbMaxLen;
 &nbsp;&nbsp; }

  pRowValues = new char[cbRow];

  *ppDBBindings = pDBBindings;
  *ppRowValues = pRowValues;

  return;
  }</code></pre>
<h1>Advanced Rowset Topics</h1>
<p>
OLE DB rowset interfaces and properties expose database cursor and bookmark support to the developer. In addition, OLE DB exposes support for client use of database resources such as scrollbar interface support.</p>
<p>
The OLE DB cursor model is derived from that implemented in ODBC and includes support for cursor type, cursor scrolling capability, and transaction isolation levels.</p>
<h1>Block Cursors </h1>
<p>
OLE DB supports block cursors by specifying the number of rows desired in the <b>IRowset::GetNextRows</b> method. In ODBC, a block cursor is defined by specifying the rowset size using the SQL_ATTR_ROW_ARRAY_SIZE attribute in a call to <b>SQLSetStmtAttr</b> prior to calling <b>SQLFetchScroll</b>.</p>
<h1>Sequential Rowsets</h1>
<p>
Sequential rowsets do not support locating specific rows, or fetching rows already retrieved. <b>GetNextRows</b> can retrieve one or more rows, but the rows must all be released before another <b>GetNextRows</b> call is permitted. This restriction is known as strict sequential cursor. This is similar to the forward-only cursor supported by ODBC. A more flexible model, relaxed sequential, allows prior rows to be held, but <b>GetNextRows</b> is still sequential, and the consumer cannot revisit earlier parts of the rowset. The relaxed sequential model also allows changes and updates to rows that have already been passed but have been held. Sequential rowsets do not implement the <b>IRowsetLocate</b> interface.</p>
<p>
<b>GetNextRows</b> is positional; that is, it fetches rows sequentially, at all times keeping track of the previous position. It can move forward, or backward if the rowset supports reversible direction. <b>IRowset::RestartPosition</b> repositions the next fetch position to the start of the rowset. <b>GetNextRows</b> keeps track of the next fetch position so that a sequence of calls to this method with no skips and no change of direction reads the entire rowset. This position is not connected to or disturbed by any other method that gets rows. Rowsets that support the property DBPROP_CANFETCHBACKWARDS can take a negative number for the count of requested rows. If the count of requested rows is negative, then the fetch direction is backwards. <b>GetNextRows</b> increases the reference count of each row for which it returns a handle. <b>ReleaseRows</b> must be called to release the handles that have been retrieved.</p>
<p>
<b>GetNextRows</b> is the same as calling <b>SQLFetch</b> in ODBC with no columns bound, except that it can move forward or backward relative to the current position and can return multiple row handles.</p>
<h1>Scrollable Rowsets</h1>
<p>
Scrollable rowsets support <b>IRowsetLocate</b>. <b>IRowsetLocate</b> is equivalent to ODBC <b>SQLFetchScroll</b>. Scrollable rowsets are not positional; the consumer uses bookmarks to fetch relative to a previous position.</p>
<p>
<b>IRowsetLocate</b> supports the following scrolling options:
<ul type=disc>
<li>
Forward or backward<br><br></li>
<li>
To the beginning or end of the rowset<br><br></li>
<li>
Relative to a specific row</li>
</ul>
<h1>Bookmarks</h1>
<p>
A bookmark is a value that the consumer can use to quickly and easily reposition to a row in the result set without incurring the overhead of holding on to the row. Bookmarks are valid only during the lifetime of the rowset to which they refer. An application retrieves a bookmark as column zero, in the same way it retrieves data from any other column in the rowset.</p>
<p>
Bookmark columns have the DBCOLUMNFLAG_ISBOOKMARK flag set in their column information. A bookmark may have a data type indicator of DBTYPE_I4 or DBTYPE_STR. </p>
<p>
OLE DB provides some standard bookmarks:
<ul type=disc>
<li>
DBBMK_INVALID. The bookmark is invalid. This is generally used for initializing variables. <br><br></li>
<li>
DBBMK_FIRST. Indicates the first row of the rowset.<br><br></li>
<li>
DBBMK_LAST. Indicates the last row of the rowset. </li>
</ul>
<p>
A bookmark becomes invalid if the row it points to is deleted, if it is based on a primary key and some of those key values were changed, or if the row it points to is no longer in the keyset. The validity of bookmarks after a transaction has been committed or aborted depends on the property DBPROP_COMMIT_PRESERVE. If this is set to <b>true</b>, then bookmarks remain valid; otherwise, they do not. </p>
<h1>Scrollbar Support</h1>
<p>
<b>IRowsetScroll</b> is the interface for moving to approximate locations in a moveable rowset. This method can be used for cases where precise positioning is not critical. <b>IRowsetScroll</b> supports the following interfaces: 
<ul type=disc>
<li>
<b>IRowsetScroll::GetApproximatePosition</b>. Gets the position of the row corresponding to the specified bookmark.<br><br></li>
<li>
<b>IRowsetScroll::GetRowsAtRatio</b>. Gets rows starting from a fractional position in the rowset.</li>
</ul>
<h1>Cursor Types </h1>
<p>
OLE DB support for scrollable cursors is provided and determined by the values of the rowset properties.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Property</b></td>
<td class=label width=50%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=50%>DBPROP_CANSCROLLBACKWARDS</td>
<td width=50%>The rowset can return to previously read rows.</td>
</tr>
<tr valign=top>
<td width=50%>DBPROP_OWNINSERT</td>
<td width=50%>The rowset can see its own inserts.</td>
</tr>
<tr valign=top>
<td width=50%>DBPROP_OTHERINSERT</td>
<td width=50%>The rowset can see inserts made outside of the rowset.</td>
</tr>
<tr valign=top>
<td width=50%>DBPROP_OWNUPDATEDELETE</td>
<td width=50%>The rowset can see its own changes and deletions.</td>
</tr>
<tr valign=top>
<td width=50%>DBPROP_OTHERUPDATEDELETE</td>
<td width=50%>The rowset can see changes and deletions made outside of the rowset.</td>
</tr>
</table><br>
<p>
These options are used to specify the characteristics of the static, keyset, and dynamic cursors defined in ODBC as follows:
<ul type=disc>
<li>
Static cursor <p class=tl>
In a static cursor, the membership, ordering, and values of the rowset are fixed after the rowset is opened. Rows updated, deleted, or inserted after the rowset is opened are not visible to the rowset until the command is reexecuted. </P><p class=tl>
To obtain a static cursor, the application sets the properties:</P><ul type=disc>
<li>
DBPROP_CANSCROLLBACKWARDS to VARIANT_TRUE<br><br></li>
<li>
DBPROP_OTHERINSERT to VARIANT_FALSE<br><br></li>
<li>
DBPROP_OTHERUPDATEDELETE to VARIANT_FALSE</li>
</ul>
<p class=tl>
In ODBC, this is equivalent to specifying SQL_CURSOR_STATIC for the SQL_ATTR_CURSOR_TYPE attribute in a call to <b>SQLSetStmtAttr</b>.</P></li>
<li>
Keyset-driven cursor <p class=tl>
In a keyset-driven cursor, the membership and ordering of rows in the rowset are fixed after the rowset is opened. However, values within the rows can change after the rowset is opened, including the entire row that is being deleted. Updates to a row are visible the next time the row is fetched, but rows inserted after the rowset is opened are not visible to the rowset until the command is reexecuted.</P><p class=tl>
To obtain a keyset-driven cursor, the application sets the properties:</P><ul type=disc>
<li>
DBPROP_CANSCROLLBACKWARDS to VARIANT_TRUE<br><br></li>
<li>
DBPROP_OTHERINSERT to VARIANT_FALSE<br><br></li>
<li>
DBPROP_OTHERUPDATEDELETE to VARIANT_TRUE</li>
</ul>
<p class=tl>
In ODBC, this is equivalent to specifying SQL_CURSOR_KEYSET_DRIVEN for the SQL_ATTR_CURSOR_TYPE attribute in a call to <b>SQLSetStmtAttr</b>.</P></li>
<li>
Dynamic cursor<p class=tl>
In a dynamic cursor, the membership, ordering, and values of the rowset can change after the rowset is opened. The row updated, deleted, or inserted after the rowset is opened is visible to the rowset the next time the row is fetched.</P><p class=tl>
To obtain a dynamic cursor, the application sets the properties:</P><ul type=disc>
<li>
DBPROP_CANSCROLLBACKWARDS to VARIANT_TRUE<br><br></li>
<li>
DBPROP_OTHERINSERT to VARIANT_TRUE<br><br></li>
<li>
DBPROP_OTHERUPDATEDELETE to VARIANT_TRUE</li>
</ul>
<p class=tl>
In ODBC, this is equivalent to specifying SQL_CURSOR_DYNAMIC for the SQL_ATTR_CURSOR_TYPE attribute in the call to <b>SQLSetStmtAttr</b>.</P></li>
<li>
Cursor sensitivity<p class=tl>
If the rowset property DBPROP_OWNINSERT is set to VARIANT_TRUE, the rowset can see its own inserts; if the rowset property DBPROP_OWNUPDATEDELETE is set to VARIANT_TRUE, the rowset can see its own updates and deletes. These are equivalent to the presence of the SQL_CASE_SENSITIVITY_ADDITIONS bit and a combination of the SQL_CASE_SENSITIVITY_UPDATES and SQL_CASE_SENSITIVITY_DELETIONS bits that are returned in the ODBC SQL_STATIC_CURSOR_ATTRIBUTES2 <b>SQLGetInfo </b>request.</P></li>
</ul>
<h1>Handling Long Data Types</h1>
<p>
To a rowset, a BLOB or OLE storage object is a large sequence of uninterpreted bytes that a consumer stores in a column. It is the consumer’s responsibility to interpret this sequence of bytes. BLOBs and OLE storage objects are categorized as:
<ul type=disc>
<li>
BLOB. Uninterpreted sequence of bytes. The type indicator of a BLOB column is DBTYPE_BYTES, DBTYPE_STR, or DBTYPE_WSTR.<br><br></li>
<li>
IPersist *Object. An OLE object supporting either <b>IPersistStream</b>, <b>IPersistStreamInit</b>, or <b>IPersistStorage</b>. The type indicator is DBTYPE_UNKNOWN.</li>
</ul>
<p>
A consumer can determine what types of BLOBs, OLE storage objects, and other types of OLE objects that a provider supports by calling <b>IDBProperties</b> with the DBPROP_OLEOBJECTS property.</p>
<h1>BLOBs as Long Data</h1>
<p>
If the entire BLOB can be held in memory, it is treated as long in-memory data. To read the BLOB data, the consumer binds the column with type identifier DBTYPE_BYTES, DBTYPE_STR, or DBTYPE_WSTR, and calls <b>IRowset::GetData</b> with an accessor containing this binding. The provider then returns the entire contents of the BLOB to the consumer. </p>
<h1>BLOBs as Storage Objects</h1>
<p>
If a BLOB is too large to hold in memory, the consumer manipulates it through the <b>ISequentialStream</b> storage interface. The rows in the rowset are containers of the storage objects. </p>
<p>
On retrieval, BLOB columns are deferred by default. Their data is not retrieved and storage objects are not created until <b>GetData</b> is called. In particular, methods that retrieve rows, such as <b>GetNextRows</b>, do not return data for BLOB columns in the data cache.</p>
<p>
A storage object created by the provider remains valid until one of the following occurs:
<ul type=disc>
<li>
The consumer calls <b>IRowset::ReleaseRows</b> to release the row containing the storage object, or <b>IRowset::Release</b> to release the rowset containing the row.<br><br></li>
<li>
The consumer calls <b>ITransaction::Commit</b> or <b>ITransaction::Abort</b>, and the retaining flag is not set.</li>
</ul>
<p>
It is the consumer’s responsibility to release the storage object, even if the containing row has been released.</p>
<h1>Accessing BLOB Data with Storage Objects</h1>
<p>
To bind to a BLOB data as a storage object, a consumer creates an accessor that includes a binding to the BLOB column. The consumer:
<ol>
<li>
Sets the <i>dwType</i> element of the DBBINDING structure for the BLOB column to DBTYPE_IUNKNOWN.<br><br></li>
<li>
Sets the <i>iid</i> element of the DBOBJECT structure in the binding to IID_ISequentialStream.<br><br></li>
<li>
Sets the <i>dwFlags</i> element of the DBOBJECT structure in the binding.</li>
</ol>
<p>
To read data from a BLOB column using a storage object, the consumer:
<ol>
<li>
Creates an accessor that includes a binding for the column.<br><br></li>
<li>
Calls <b>IRowset::GetData</b> with this accessor. The provider creates a storage object over the BLOB’s data and returns a pointer to the requested storage interface (<b>ISequentialStream</b>) on this object.<br><br></li>
<li>
Calls methods on the storage interface to read the BLOB’s data (<b>ISequentialStream::Read</b>).</li>
</ol>
<p>
If the consumer calls <b>GetData</b>, <b>GetVisibleData</b>, or <b>GetOriginalData</b> multiple times for the BLOB column, the provider returns distinct pointers to storage interfaces on each call. This is similar to opening a file a number of times and returning a different file handle each time. It is the consumer’s responsibility to call <b>Release</b> on each of these storage interfaces.</p>
<p>
For example, the following code example binds to a BLOB column and uses <b>ISequentialStream::Read</b> to read the data. For the complete source code listing, see Appendix B. The general flow of control is:
<ol>
<li>
Create a binding structure to retrieve the <b>ISequentialStream</b> interface from an OLE storage object.<br><br></li>
<li>
Obtain the <b>IAccessor</b> interface.<br><br></li>
<li>
Call <b>CreateAccessor</b> to create the accessor.<br><br></li>
<li>
Call <b>GetNextRows</b> to retrieve the row handles.<br><br></li>
<li>
Call <b>GetData</b> to retrieve the storage object from a row.<br><br></li>
<li>
Call <b>ISequentialStream</b> to read the data from the stream.<br><br></li>
<li>
Repeat steps 4, 5, and 6 to retrieve new storage objects and get the data.</li>
</ol>
<pre><code>/********************************************************************
* Retrieve data from an ODBC LONG_VARCHAR column (Notes in 
* Employees).
********************************************************************/
void myGetBLOBData
  (
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset         // [in]
  )
  {
  DBOBJECT&nbsp;&nbsp;&nbsp; ObjectStruct;      // For binding, retrieve 
                  // an object pointer.
  DBBINDING&nbsp;&nbsp; rgBinding[1];      // Bind a single column.

  IAccessor*&nbsp; pIAccessor = NULL;   // Accessor creation
  HACCESSOR&nbsp;&nbsp; hAccessor = NULL;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; ulErrorBinding;

  void*&nbsp;&nbsp;&nbsp;&nbsp; pData;         // Bound consumer buffer
  HROW&nbsp;&nbsp;&nbsp; rghRows[1];
  HROW*&nbsp;&nbsp;&nbsp;&nbsp; pRows = &amp;rghRows[0];
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cRows;

  char&nbsp;&nbsp;&nbsp; szNotes[BLOCK_SIZE + 1];   // Text data from
                  // "Notes"
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cbRead;         // Count of bytes read

  // Set up the object structure for accessor creation. Ask the
  // provider to return an ISequentialStream interface for reading.
  ObjectStruct.dwFlags = STGM_READ; 
  ObjectStruct.iid = IID_ISequentialStream;

  // Set up the binding structure for the accessor.
  rgBinding[0].iOrdinal = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Only one column
  rgBinding[0].obValue&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Offset to data
  rgBinding[0].obLength = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ignore length 
  rgBinding[0].obStatus = sizeof(IUnknown*);&nbsp; // Offset to status 
  rgBinding[0].pTypeInfo = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
  rgBinding[0].pObject&nbsp; = &amp;ObjectStruct;&nbsp; // Our interface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // request
  rgBinding[0].pBindExt = NULL;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
  rgBinding[0].dwPart = DBPART_VALUE |&nbsp; // Get both VALUE...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPART_STATUS;&nbsp; // ...and STATUS 
                   // parts.
  rgBinding[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
  rgBinding[0].eParamIO = DBPARAMIO_NOTPARAM;
  rgBinding[0].cbMaxLen = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable
  rgBinding[0].dwFlags&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
  rgBinding[0].wType = DBTYPE_IUNKNOWN;&nbsp;&nbsp; // Type 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DBTYPE_IUNKNOWN
  rgBinding[0].bPrecision = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable
  rgBinding[0].bScale = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable

  // Get the accessor interface and create the accessor.
  pIRowset-&gt;QueryInterface(IID_IAccessor, (void**) &amp;pIAccessor);

  if (FAILED(pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 1,
 &nbsp;&nbsp; rgBinding, sizeof(IUnknown*) + sizeof(ULONG), &amp;hAccessor,
 &nbsp;&nbsp; &amp;ulErrorBinding)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("CreateAccessor failed.");
 &nbsp;&nbsp; return;
 &nbsp;&nbsp; }

  // Allocate memory for the returned pointer and the status 
  // field. The first sizeof(IUnknown*) bytes are for the pointer 
  // to the object; the next sizeof(ULONG) bytes are for the 
  // status.
  pData = new BYTE[sizeof(IUnknown*) + sizeof(ULONG)];

 &nbsp; while (TRUE)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Get the next row.
 &nbsp;&nbsp; if (FAILED(pIRowset-&gt;GetNextRows(NULL, 0, 1, &amp;cRows, 
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;pRows)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("GetNextRows failed.\n");
 &nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; if (cRows == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Get the row data, the pointer to an ISequentialStream*.
 &nbsp;&nbsp; if (FAILED(pIRowset-&gt;GetData(*pRows, hAccessor, pData)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("GetData failed.\n");
 &nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Read and process BLOCK_SIZE bytes at a time.
 &nbsp;&nbsp; if ((ULONG)((BYTE*)pData)[rgBinding[0].obStatus] == 
 &nbsp;&nbsp;&nbsp;&nbsp; DBSTATUS_S_ISNULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process NULL data.
 &nbsp;&nbsp; printf("&lt;null&gt;");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if ((ULONG)((BYTE*)pData)[rgBinding[0].obStatus] == 
 &nbsp;&nbsp;&nbsp;&nbsp; DBSTATUS_S_OK)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; do
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; (*((ISequentialStream**) pData))-&gt;Read(szNotes, 
 &nbsp;&nbsp;&nbsp;&nbsp; BLOCK_SIZE, &amp;cbRead);
 &nbsp;&nbsp;&nbsp;&nbsp; if (cbRead &gt; 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Process data.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szNotes[cbRead] = (char) NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(szNotes);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; while (cbRead &gt;= BLOCK_SIZE);

 &nbsp;&nbsp; (*((ISequentialStream**) pData))-&gt;Release();
 &nbsp;&nbsp; 
 &nbsp;&nbsp; printf("\n\n");
 &nbsp;&nbsp; }

 &nbsp;&nbsp; pIRowset-&gt;ReleaseRows(cRows, pRows, NULL, NULL, NULL);
 &nbsp;&nbsp; }

  // Clean up.
  pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL);
  pIAccessor-&gt;Release();

  delete [] pData;
  }</code></pre>
<p>
To write data to a BLOB column using a storage object, the consumer first creates an accessor that includes a binding for the column and then:
<ol>
<li>
Calls <b>IRowset::GetData</b> with the accessor that binds the BLOB column. The provider creates a storage object over the BLOB’s data and returns a pointer to the requested storage interface (<b>ISequentialStream</b>) on this object.<br><br></li>
<li>
Calls a method on the storage interface to write data (<b>ISequentialStream::Write</b>).<p class=tl>
OLE’s structured storage model supports both transacted and direct modes. In transacted mode, all changes are buffered, and the buffered changes are persisted or discarded only when an explicit commit or abort request is done. In direct mode, every change is followed by an automatic commit. If the storage object is transacted (that is, the STGM_TRANSACTED flag is set in the <i>dwFlags</i> element of the DBOBJECT structure in the binding), the storage object does not publish the changes to the containing rowset until the consumer calls <b>Commit</b> on the storage interface. If the storage object is not transacted (that is, the STGM_DIRECT flag is set), the storage object publishes the changes to the containing rowset when the consumer calls a method on the storage interface to write the changes.</P></li>
</ol>
<p>
Alternately, the consumer calls <b>IRowsetChange::SetData</b> or <b>IRowsetChange::InsertRow</b> with the accessor that binds the BLOB column, passing a pointer to a storage interface on a separate storage object.</p>
<h1>Data Manipulation</h1>
<p>
Data manipulation in OLE DB can be executed using SQL queries in commands or using the <b>IRowsetChange</b> interface. </p>
<p>
<b>IRowsetChange</b> allows the consumer to:
<ul type=disc>
<li>
Update columns of a row by calling <b>IRowsetChange::SetData</b>.<br><br></li>
<li>
Delete a row or rows by calling <b>IRowsetChange::DeleteRows</b>.<br><br></li>
<li>
Insert a new row by calling <b>IRowsetChange::InsertRow</b>.</li>
</ul>
<h1>Delayed Updates</h1>
<p>
OLE DB supports delayed updates. With delayed updates, changes made to the rowset are not transmitted to the data source until <b>IRowsetUpdate::Update</b> is called.</p>
<p>
A rowset can be in delayed or immediate update mode, depending on whether it exposes the <b>IRowsetUpdate</b> interface. The consumer specifies whether <b>IRowsetUpdate</b> should be supported prior to opening the rowset.</p>
<p>
If the <b>IRowsetUpdate</b> interface is not included on the rowset, then the rowset is said to be in immediate update mode, and the changes are immediately transmitted to the data source. If <b>IRowsetUpdate</b> is present, then the changes are not transmitted to the data source until <b>IRowsetUpdate::Update</b> is called.</p>
<p>
For rowsets in delayed update mode, <b>IRowsetUpdate</b> allows the consumer to:
<ul type=disc>
<li>
Retrieve the initial value read for the row by calling <b>IRowsetUpdate::GetOriginalData</b>.<br><br></li>
<li>
Get a list of pending changes by calling <b>IRowsetUpdate::GetPendingRows</b>.<br><br></li>
<li>
Get the pending status of a given set of rows by calling <b>IRowsetUpdate::GetRowStatus</b>.<br><br></li>
<li>
Undo some, or all, of the pending changes by calling <b>IRowsetUpdate::Undo</b>.<br><br></li>
<li>
Commit some, or all, of the changes to the data source by calling <b>IRowsetUpdate::Update</b>.</li>
</ul>
<h1>Prepared Commands</h1>
<p>
If a command is to be executed multiple times, it is often more efficient to prepare it. Command preparation tells the query processor to save the execution plan so that it doesn’t have to be rebuilt for each execution.</p>
<p>
The <b>ICommandPrepare</b> interface supports methods for preparing a command. Calling <b>ICommandPrepare::Prepare</b> in OLE DB is equivalent to calling <b>SQLPrepare</b> in ODBC.</p>
<h1>Commands with Parameters</h1>
<p>
Parameters are used to insert scalar values into a command at execute time. Parameters are generally used in conjunction with a prepared command so that the command can be executed multiple times, each time with a different value.</p>
<p>
To specify parameters in ODBC, an application uses <b>SQLBindParameter</b> and <b>SQLParamData</b> in the following order:
<ol>
<li>
Calls <b>SQLBindParameter</b> for each parameter to specify the parameter type and bind buffers for the parameters’ values.<br><br></li>
<li>
Calls <b>SQLSetStmtAttr</b> if multiple values are to be specified for each set of parameters.<br><br></li>
<li>
Places the values in appropriate buffers.<br><br></li>
<li>
Calls <b>SQLExecute</b> or <b>SQLExecDirect</b>.</li>
</ol>
<p>
To specify parameters in OLE DB, an application uses the <b>ICommandWithParameters</b> interface in the following order:
<ol>
<li>
Creates an accessor describing the binding information for the set of parameters.<br><br></li>
<li>
Calls <b>ICommandWithParameters::SetParameterInfo</b> to specify the types of the parameters.<br><br></li>
<li>
Calls <b>ICommand::Execute</b> to execute the command, passing a structure containing the accessor, number of parameter sets, and a pointer to data for the parameters.</li>
</ol>
<h1>Binding Parameters</h1>
<p>
The consumer specifies parameter descriptions by setting information in the DBPARAMBINDINFO structure passed to <b>ICommandWithParameters::SetParameterInfo</b>. This is similar to the type, precision, and scale information specified in <b>SQLBindParameter</b> in ODBC. </p>
<p>
The DBPARAMBINDINFO structure is:</p>
<pre><code>typedef struct tagDBPARAMBINDINFO
  {
  LPOLESTR&nbsp; pwszDataSourceType;   // Data type name (OLESTR)
  LPOLESTR&nbsp; pwszName;      // Name of the parameter
  ULONG&nbsp;&nbsp; ulParamSize;   // Maximum length of data
               // accepted
  DBPARAMFLAGS&nbsp; dwFlags;   // Input/output/signed/nullable/object
  BYTE&nbsp;&nbsp;&nbsp; bPrecision;   // Precision for numeric data
            // types
  BYTE&nbsp;&nbsp;&nbsp; bScale;   // Scale for numeric data types
  } DBPARAMBINDINFO;</code></pre>
<p>
The <b>ICommand::Execute</b> method takes a pointer to the DBPARAMS structure as an argument. This structure includes a pointer to the data as well as an accessor that describes the layout of the data. Bindings described in the accessor are similar to the bindings specified in <b>SQLBindParameter</b> in ODBC. OLE DB allows the specification of multiple sets of parameters in a single call by specifying the number of sets of parameters in the <i>cParamSets</i> element of the DBPARAMS structure. This is similar to calling <b>SQLSetStmtAttr</b> in ODBC.</p>
<p>
The DBPARAMS structure is:</p>
<pre><code>typedef struct tagDBPARAMS
  {
  void __RPC_FAR*&nbsp; pData;      // Data, array containing
               // parameter values
  ULONG&nbsp;&nbsp;&nbsp; cParamSets;   // Count of sets of parameter
               // values in the data array
  HACCESSOR&nbsp;&nbsp;&nbsp; hAccessor;   // Handle of parameter
               // describing accessor
  } DBPARAMS;</code></pre>
<p>
The following code example shows parameter passing in OLE DB. For the complete source code listing, see Appendix C. The general flow of control is:
<ol>
<li>
Create bindings describing the parameters.<br><br></li>
<li>
Obtain the <b>IDBCreateSession</b> interface.<br><br></li>
<li>
Call <b>CreateSession</b> to create a session object that scopes the transaction boundaries within the current connection.<br><br></li>
<li>
Call <b>CreateCommand</b> to create a command object within the transaction.<br><br></li>
<li>
Call <b>SetCommandText</b> to set the command text.<br><br></li>
<li>
Obtain the <b>ICommandWithParameters</b> interface on the command object.<br><br></li>
<li>
Call <b>SetParameterInfo</b> to specify the parameter information.<br><br></li>
<li>
 Prepare the command.<br><br></li>
<li>
 Create a parameter accessor.<br><br></li>
<li>
 Build a structure containing the parameter information.<br><br></li>
<li>
 Call <b>Execute</b>, providing the parameter accessor and parameter <br>
  information, to execute the command.<br><br></li>
<li>
 Release the command object.</li>
</ol>
<pre><code>/********************************************************************
*&nbsp; Execute a prepared INSERT statement with parameters.
********************************************************************/
HRESULT myInsertWithParameters
  (
  IDBInitialize*&nbsp; pIDBInitialize
  ) 
  {
  IDBCreateSession* pIDBCreateSession;
  IDBCreateCommand* pIDBCreateCommand;
  ICommandText*&nbsp;&nbsp; pICommandText;
  ICommandPrepare*&nbsp; pICommandPrepare;
  ICommandWithParameters* pICmdWithParams;
  IAccessor*&nbsp;&nbsp;&nbsp; pIAccessor;
  WCHAR&nbsp;&nbsp;&nbsp;&nbsp; wSQLString[] = 
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR("insert into Customers (CustomerID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompanyName, ContactName,")
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" ContactTitle, Address, City, Region, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostalCode, Country,")
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" Phone, Fax)")
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
  DBPARAMS&nbsp;&nbsp;&nbsp; Params;
  long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;
  HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp; hParamAccessor;

  NEWCUSTOMERDATA&nbsp;&nbsp; aNewCustomers[] =
 &nbsp;&nbsp; {
 &nbsp;&nbsp; "YOUME",
 &nbsp;&nbsp; "You and Me Grocers",
 &nbsp;&nbsp; "William Smith",
 &nbsp;&nbsp; "General Manager",
 &nbsp;&nbsp; "383 15th Ave. N.",
 &nbsp;&nbsp; "New York",
 &nbsp;&nbsp; "NY",
 &nbsp;&nbsp; "10018",
 &nbsp;&nbsp; "USA",
 &nbsp;&nbsp; "(212) 555-8847",
 &nbsp;&nbsp; "(212) 555-9988",

 &nbsp;&nbsp; "YORBL",
 &nbsp;&nbsp; "Yorbalinda's",
 &nbsp;&nbsp; "Mary Jones",
 &nbsp;&nbsp; "Owner",
 &nbsp;&nbsp; "22 Sunny Vale Rd.",
 &nbsp;&nbsp; "San Diego",
 &nbsp;&nbsp; "CA",
 &nbsp;&nbsp; "93122",
 &nbsp;&nbsp; "USA",
 &nbsp;&nbsp; "(605) 555-4322",
 &nbsp;&nbsp; "(605) 555-4323"
 &nbsp;&nbsp; };
  NEWCUSTOMER&nbsp;&nbsp; NewCustomer;

  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nParams = 11;
  DBPARAMBINDINFO&nbsp;&nbsp; rgParamBindInfo[] = 
 &nbsp;&nbsp; {
 &nbsp;&nbsp; OLESTR("DBTYPE_CHAR"),&nbsp; OLESTR("CustomerID"),&nbsp; 5, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("CompanyName"),&nbsp; 40,
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("ContactName"),&nbsp; 30, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("ContactTitle"), 30, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Address"),&nbsp; 60, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("City"),&nbsp;&nbsp; 15, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Region"),&nbsp;&nbsp; 15, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("PostalCode"), 10, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Country"),&nbsp; 15, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Phone"),&nbsp;&nbsp;&nbsp; 24, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("FAX"),&nbsp;&nbsp;&nbsp; 24, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; };
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; rgParamOrdinals[] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {1,2,3,4,5,6,7,8,9,10,11};

  // Get the session.
  pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession,
 &nbsp;&nbsp; (void**)&amp;pIDBCreateSession);
  pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
  pIDBCreateSession-&gt;Release();

  // Create the command.
  pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText, 
 &nbsp;&nbsp; (IUnknown**) &amp;pICommandText);
  pIDBCreateCommand-&gt;Release();

  // The command requires the actual text as well as an indicator 
  // of its language.
  pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLString);

  // Set parameter information.
  pICommandText-&gt;QueryInterface(IID_ICommandWithParameters, 
 &nbsp;&nbsp; (void**)&amp;pICmdWithParams);
  pICmdWithParams-&gt;SetParameterInfo(nParams, rgParamOrdinals, 
 &nbsp;&nbsp; rgParamBindInfo);
  pICmdWithParams-&gt;Release();

  // Prepare the command.
  pICommandText-&gt;QueryInterface(IID_ICommandPrepare, 
 &nbsp;&nbsp; (void**)&amp;pICommandPrepare);
  if (FAILED(pICommandPrepare-&gt;Prepare(0)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pICommandPrepare-&gt;Release();
 &nbsp;&nbsp; pICommandText-&gt;Release();
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }
  pICommandPrepare-&gt;Release();

  // Create parameter accessors.
  if (FAILED(myCreateParamAccessor(pICommandText, &amp;hParamAccessor, 
 &nbsp;&nbsp; &amp;pIAccessor)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pICommandText-&gt;Release();
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  Params.pData = &amp;NewCustomer;&nbsp; // pData is the buffer pointer
  Params.cParamSets = 1;&nbsp;&nbsp;&nbsp; // Number of sets of parameters
  Params.hAccessor = hParamAccessor;// Accessor to the parameters
  
  // Specify the parameter information.
  for (UINT nCust = 0; nCust &lt; 2; nCust++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; strcpy(NewCustomer.acCustomerID, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCustID);
 &nbsp;&nbsp; strcpy(NewCustomer.acCompanyName, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCompanyName);
 &nbsp;&nbsp; strcpy(NewCustomer.acContactName, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szContactName);
 &nbsp;&nbsp; strcpy(NewCustomer.acContactTitle, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szContactTitle);
 &nbsp;&nbsp; strcpy(NewCustomer.acAddress, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szAddress);
 &nbsp;&nbsp; strcpy(NewCustomer.acCity, aNewCustomers[nCust].szCity);
 &nbsp;&nbsp; strcpy(NewCustomer.acRegion, aNewCustomers[nCust].szRegion);
 &nbsp;&nbsp; strcpy(NewCustomer.acPostalCode, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szPostalCode);
 &nbsp;&nbsp; strcpy(NewCustomer.acCountry, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCountry);
 &nbsp;&nbsp; strcpy(NewCustomer.acPhone, aNewCustomers[nCust].szPhone);
 &nbsp;&nbsp; strcpy(NewCustomer.acFAX, aNewCustomers[nCust].szFAX);

 &nbsp;&nbsp; // Execute the command.
 &nbsp;&nbsp; pICommandText-&gt;Execute(NULL, IID_NULL, &amp;Params, 
 &nbsp;&nbsp;&nbsp; &amp;cRowsAffected, NULL);

 &nbsp;&nbsp; printf("%ld rows inserted.\n", cRowsAffected);
 &nbsp;&nbsp; }

  pIAccessor-&gt;ReleaseAccessor(hParamAccessor, NULL);
  pIAccessor-&gt;Release();
  pICommandText-&gt;Release();

  return (NOERROR);
  }
</code></pre>
<h1>Creating Parameter Accessors</h1>
<p>
Input parameter data is read from, and output parameter data is written to, the specified locations within <i>Params.pData</i> according to the bindings specified by the accessor. An array of parameter sets can be passed in <i>pParamData</i>. <i>cParamSets</i> indicates the number of elements of the array. </p>
<p>
The following code example shows parameter binding for the <i>NEWCUSTOMER</i> structure used in the previous example. The general flow of control is:
<ol>
<li>
Specify the common binding information for all the parameters.<br><br></li>
<li>
Specify the specific binding information for each parameter.<br><br></li>
<li>
Call <b>CreateAccessor</b> to create the parameter accessor.<br><br></li>
<li>
Return the accessor handle along with the interface used to create it (so that it can be freed later).</li>
</ol>
<pre><code>/********************************************************************
*&nbsp; Create parameter accessor.
********************************************************************/
HRESULT myCreateParamAccessor
  (
  ICommand* pICmd,&nbsp; // [in]
  HACCESSOR*&nbsp; phAccessor, // [out]
  IAccessor** ppIAccessor // [out]
  )
  {
  IAccessor*&nbsp; pIAccessor;
  HACCESSOR&nbsp;&nbsp; hAccessor;
  const ULONG&nbsp;&nbsp; nParams = 11;
  DBBINDING&nbsp;&nbsp; Bindings[nParams];
  DBBINDSTATUS&nbsp; rgStatus[nParams]; // Returns information for 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // individual binding
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // validity.
  HRESULT&nbsp;&nbsp; hr;

  ULONG&nbsp;&nbsp;&nbsp;&nbsp; acbLengths[] = {5, 40, 30, 30, 60, 15, 15, 10, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, 24, 24};

  for (ULONG i = 0; i &lt; nParams; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; Bindings[i].iOrdinal = i + 1;
 &nbsp;&nbsp; Bindings[i].obLength = 0;
 &nbsp;&nbsp; Bindings[i].obStatus = 0;
 &nbsp;&nbsp; Bindings[i].pTypeInfo = NULL;
 &nbsp;&nbsp; Bindings[i].pObject = NULL;
 &nbsp;&nbsp; Bindings[i].pBindExt = NULL;
 &nbsp;&nbsp; Bindings[i].dwPart = DBPART_VALUE;
 &nbsp;&nbsp; Bindings[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 &nbsp;&nbsp; Bindings[i].eParamIO = DBPARAMIO_INPUT;
 &nbsp;&nbsp; Bindings[i].cbMaxLen = acbLengths[i];
 &nbsp;&nbsp; Bindings[i].dwFlags = 0;
 &nbsp;&nbsp; Bindings[i].wType = DBTYPE_STR;
 &nbsp;&nbsp; Bindings[i].bPrecision = 0;
 &nbsp;&nbsp; Bindings[i].bScale = 0;
 &nbsp;&nbsp; }

  Bindings[0].obValue = offsetof(NEWCUSTOMER, acCustomerID);
  Bindings[1].obValue = offsetof(NEWCUSTOMER, acCompanyName);
  Bindings[2].obValue = offsetof(NEWCUSTOMER, acContactName);
  Bindings[3].obValue = offsetof(NEWCUSTOMER, acContactTitle);
  Bindings[4].obValue = offsetof(NEWCUSTOMER, acAddress);
  Bindings[5].obValue = offsetof(NEWCUSTOMER, acCity);
  Bindings[6].obValue = offsetof(NEWCUSTOMER, acRegion);
  Bindings[7].obValue = offsetof(NEWCUSTOMER, acPostalCode);
  Bindings[8].obValue = offsetof(NEWCUSTOMER, acCountry);
  Bindings[9].obValue = offsetof(NEWCUSTOMER, acPhone);
  Bindings[10].obValue = offsetof(NEWCUSTOMER, acFAX);

  pICmd-&gt;QueryInterface(IID_IAccessor, (void**)&amp;pIAccessor);

  hr = pIAccessor-&gt;CreateAccessor(
 &nbsp;&nbsp; DBACCESSOR_PARAMETERDATA,   // Accessor that will be used 
               // to specify parameter data
 &nbsp;&nbsp; nParams,         // Number of parameters being
               // bound
 &nbsp;&nbsp; Bindings,         // Structure containing bind
               // information
 &nbsp;&nbsp; sizeof(NEWCUSTOMER),      // Size of parameter structure
 &nbsp;&nbsp; &amp;hAccessor,         // Returned accessor handle
 &nbsp;&nbsp; rgStatus         // Information about binding
               // validity
 &nbsp;&nbsp; );

  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Parameter accessor creation failed.");
 &nbsp;&nbsp; }
  else
 &nbsp;&nbsp; {
 &nbsp;&nbsp; *ppIAccessor = pIAccessor;
 &nbsp;&nbsp; *phAccessor = hAccessor;
 &nbsp;&nbsp; }

  return (hr);
  }</code></pre>
<h1>Advanced OLE DB Topics</h1>
<p>
This section describes advanced OLE DB topics, such as data source location, catalog and schema functions, transactions, error handling, and data types.</p>
<h1>Locating a Data Source</h1>
<p>
In ODBC, the application generally calls <b>SQLDataSources</b> to enumerate the different ODBC data sources installed on the computer. The application can also call <b>SQLDrivers</b> to enumerate the specific drivers and connect to them directly, without a data source. ODBC version 3.0 defines the concept of a file DSN, which is a data source definition that lives as a file in the file system.</p>
<p>
In OLE DB, consumers can browse for data sources using an enumerator. Enumerators provide a recursive, hierarchical model for browsing data sources. This model is similar to browsing for files in the file system, where a folder is represented by an enumerator and a file is represented by a data source. Just as folders can enumerate other folders as well as files, an enumerator can enumerate other enumerators as well as data sources.</p>
<p>
A root enumerator is provided as part of the OLE DB SDK that generates a rowset of available data providers and enumerators. Binding to a data source returns an uninitialized data source object for that data source. </p>
<p>
Once created, a data source object can be persisted as a file in the file system. Binding a file moniker to one of these persisted data sources generates an uninitialized data source object with a particular state, such as a data source name or location. Persisted data sources are equivalent to file DSNs in ODBC version 3.0. The consumer must still initialize the data source object after it is loaded.</p>
<h1>Catalog and Schema Functions</h1>
<p>
Schema information in OLE DB is retrieved using rowsets in the same manner as other types of data. The schema information specified in OLE DB is based on the ANSI SQL concepts of catalog and schema. A schema is a collection of database objects that are owned or have been created by a particular user, and a catalog contains one or more schemas. </p>
<p>
The <b>IDBSchemaRowset</b> interface provides a mechanism to the consumer for retrieving information about the database without knowing its structure. Schema rowsets are identified by GUIDs. Each schema GUID has a set of restrictions that can be specified to reduce the result set to the desired information. For example, to get a list of columns in a particular table, the schema name, database name, and table name can be specified as restrictions. The order and data type of these restrictions are fixed and are listed in the <i>Microsoft OLE DB Programmer’s Reference</i>. It is not necessary to specify all the restrictions; however, the unspecified restrictions must be set to type DBTYPE_EMPTY or VT_EMPTY. </p>
<p>
The <b>IDBSchemaRowset</b> interface has two methods:
<ul type=disc>
<li>
<b>IDBSchemaRowset::GetRowset</b>. Returns one of the standard schema information rowsets.<br><br></li>
<li>
<b>IDBSchemaRowset::GetSchema</b>. Returns a list of schema information views accessible through the <b>GetRowset</b> method. </li>
</ul>
<p>
The <b>IDBSchemaRowset</b> interface encapsulates the functionality of the catalog functions in ODBC, such as <b>SQLTables</b>, <b>SQLColumns</b>, <b>SQLProcedures</b>, <b>SQLProcedureColumns</b>, <b>SQLStatistics</b>, <b>SQLPrimaryKeys</b>, <b>SQLForeignKeys</b>, and <b>SQLGetTypeInfo</b>. </p>
<h1>Transactions</h1>
<p>
A session can be inside or outside a transaction at any point in time. When a session is created, it is outside a transaction, and all work done under the scope of that session is immediately committed on each method call. This is referred to as the <i>autocommit </i>or <i>implicit commit </i>mode.</p>
<p>
If the provider supports transactions, the session supports the <b>ITransactionLocal</b> interface. Calling <b>ITransactionLocal::StartTransaction</b> begins a transaction on the session. <b>ITransactionLocal</b> inherits from the <b>ITransaction</b> interface, which supports the <b>Commit</b> and <b>Abort</b> methods. When a session enters a transaction, all work done by the session, its command and rowsets, is part of that transaction. </p>
<p>
The following code example shows calling commit or abort on a session:</p>
<pre><code>ITransactionLocal*&nbsp; pITransactionlocal;

pIDBCreateCommand-&gt;QueryInterface(IID_ITransactionLocal,
  (void**) &amp;pITransactionlocal);
pITransactionlocal-&gt;StartTransaction(
  ISOLATIONLEVEL_READCOMMITTED, 0, NULL, NULL);

...&nbsp;&nbsp;&nbsp; // Do some work...setting bSave for the following.

if (bSave) // For commit
  pITransactionlocal-&gt;Commit(FALSE, XACTTC_SYNC_PHASEONE, 0);
else&nbsp;&nbsp; // For abort
  pITransactionlocal-&gt;Abort(NULL, FALSE, FALSE); // For abort

pITransactionlocal-&gt;Release();</code></pre>
<p>
Transactions have two important properties: retention and preservation. Retention indicates whether another transaction is implicitly started on committing or aborting the transaction. Preservation indicates whether the rowset capabilities are preserved on committing or aborting the transaction. Committing or aborting a transaction with the <i>fRetention</i> flag set to TRUE will implicitly start another transaction. After a commit or abort, the full functionality of the rowset is preserved or is zombied, depending on whether the rowset properties DBPROP_COMMITPRESERVE and DBPROP_ABORTPRESERVE are set to TRUE or FALSE. A zombied rowset is an object whose functionality is virtually lost. It supports only <b>IUnknown</b> operations and releasing row handles. A preserved rowset has all its capabilities intact. </p>
<h1>Isolation Levels</h1>
<p>
OLE DB defines the following isolation levels. These are similar to the isolation levels in ODBC.
<ul type=disc>
<li>
Read Uncommitted. The values in a record being accessed can change at any time.<br><br></li>
<li>
Read Committed. The values in a record do not change from the time the record is read until it is rewritten or passed over.<br><br></li>
<li>
Repeatable Read. The relationship between values in different records doesn’t change while the transaction is executing.<br><br></li>
<li>
Serializable. The existence of reference records does not change while the transaction is executing. </li>
</ul>
<h1>Error Handling</h1>
<p>
Methods return error information in two ways. The code returned by a method indicates the overall success or failure of a method while error objects provide detailed information. Success and warning return codes begin with S_ or DB_S_ and indicate that the method completed successfully. If a single warning condition occurs, the method returns the return code for that condition. If multiple warning conditions occur, a hierarchy is defined to determine which code is returned. Error return codes begin with E_ or DB_E_ and indicate that the method failed completely. Error objects in OLE DB are an extension of the error objects in Automation. 
<ul type=disc>
<li>
The <b>ISupportErrorInfo</b> interface, defined by Automation, determines whether an object can return OLE DB error objects and which interfaces on that object can return OLE DB error objects.<br><br></li>
<li>
The <b>IErrorInfo</b> interface, defined by Automation, returns the error message, the name of the component and the GUID of the interface in which the error occurred, and the name and topic of the help file that applies to the error.<br><br></li>
<li>
The <b>IErrorLookup</b> interface is exposed by a provider supporting OLE DB error objects. The provider creates an error lookup service and the lookup service exposes the <b>IErrorLookup</b> interface. This service is used by <b>IErrorRecords</b> and <b>IErrorInfo</b> interfaces.<br><br></li>
<li>
The <b>IErrorRecords</b> interface is the main interface through which OLE DB error objects are accessed.<br><br></li>
<li>
The <b>ISQLErrorInfo</b> interface is used to return the SQLSTATE and native error. All ODBC-related providers can expose this interface.</li>
</ul>
<h1>Data Types</h1>
<p>
OLE DB uses standard OLE- and Windows-based data types, and uses DBTYPE as a type indicator. A type indicator denotes the data type of a piece of memory. A type indicator is used to describe data types in metadata, method calls, and data and parameter binding.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Type indicators</b></td>
<td class=label width=50%><b>Physical type</b></td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_EMPTY</td>
<td width=50%> </td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_NULL</td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_RESERVED</td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_I1</td>
<td width=50%>signed char</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_I2</td>
<td width=50%>SHORT</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_I4</td>
<td width=50%>LONG</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_I8</td>
<td width=50%>LARGE_INTEGER</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_UI1</td>
<td width=50%>BYTE</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_UI2</td>
<td width=50%>unsigned short</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_UI4</td>
<td width=50%>unsigned int</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_UI8</td>
<td width=50%>ULARGE_INTEGER</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_R4</td>
<td width=50%>float</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_R8</td>
<td width=50%>double</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_CY</td>
<td width=50%>LARGE_INTEGER</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_DECIMAL</td>
<td width=50%>DBDECIMAL</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_NUMERIC</td>
<td width=50%>DBNUMERIC</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_DATE</td>
<td width=50%>DATE</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_BOOL</td>
<td width=50%>VARIANT_BOOL</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_BYTES</td>
<td width=50%>BYTE[cbMaxlen]</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_BSTR</td>
<td width=50%>BSTR</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_STR</td>
<td width=50%>char[cbMaxLen]</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_WSTR</td>
<td width=50%>wchar_t[cbMaxLen]</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_VARIANT</td>
<td width=50%>VARIANT</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_IDISPATCH</td>
<td width=50%>IDispatch *</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_IUNKOWN</td>
<td width=50%>IUnknown *</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_GUID</td>
<td width=50%>GUID</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_ERROR</td>
<td width=50%>SCODE</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_BYREF</td>
<td width=50%>void *</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_ARRAY</td>
<td width=50%>SAFEARRAY *</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_VECTOR</td>
<td width=50%>DBVECTOR</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_UDT</td>
<td width=50%>undefined</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_DBDATE</td>
<td width=50%>DBDATE</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_DBTIME</td>
<td width=50%>DBTIME</td>
</tr>
<tr valign=top>
<td width=50%>DBTYPE_TIMESTAMP</td>
<td width=50%>DBTIMESTAMP</td>
</tr>
</table><br>
<p>
Each OLE DB provider chooses a default type indicator for each of its native types and documents them in the PROVIDER_TYPES schema rowset. Providers are required to transfer data in the C type that corresponds to that type indicator and to convert data to and from WCHAR, if such a conversion is defined in the conversion tables. For the conversion table and guidelines, see <i>Microsoft OLE DB Programmer’s Reference</i>, Appendix A.</p>
<h1>ODBC Attributes and Corresponding OLE DB Properties</h1>
<p>
OLE DB and ODBC are different interfaces. A one-to-one correspondence between the properties of one interface and the attributes of the other does not exist. OLE DB contains a rich definition of property sets and interface method parameters that provide services significantly different from those provided by ODBC. For more information, see the OLE DB documentation of schema rowsets, property sets, and methods.</p>
<p>
The following tables show ODBC attributes and their OLE DB property equivalents. Where a one-to-one mapping cannot be made easily, the OLE DB property set and property columns are left blank.</p>
<h1>Column Attributes</h1>
<p>
ODBC developers use <b>SQLDescribeCol</b>, <b>SQLColAttribute</b>, or <b>SQLGetDescField</b> to retrieve a given attribute. The interfaces and retrieval methods in OLE DB are also shown. </p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=32%><b><br>
ODBC attribute</b></td>
<td class=label width=41%><b>OLE DB property set, schema rowset, <br>
or method</b></td>
<td class=label width=27%><b><br>
OLE DB property</b></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_AUTO_<br>
UNIQUE_VALUE</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
ISAUTOINCREMENT</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_BASE_<br>
COLUMN_NAME</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
BASECOLUMNNAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_BASE_<br>
TABLE_NAME</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
BASETABLENAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_CASE_<br>
SENSITIVE</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
ISCASESENSITIVE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_CATALOG_<br>
NAME</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
BASECATALOGNAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_CONCISE_<br>
TYPE</td>
<td width=41%></td>
<td width=27%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_COUNT</td>
<td width=41%>IColumnsInfo::GetColumnInfo</td>
<td width=27%>The value returned in the <i>pcColumns</i> argument</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_DISPLAY_SIZE</td>
<td width=41%></td>
<td width=27%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_FIXED_<br>
PREC_SCALE</td>
<td width=41%>IDBSchemaRowset::GetRowset<b> DBSCHEMA_PROVIDER_TYPES rowset restricted by DBCOLUMN_TYPE property from </b>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>FIXED_PREC_SCALE column</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_LABEL</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_LENGTH</td>
<td width=41%>IColumnsInfo::GetColumnInfo</td>
<td width=27%>Derived from <i>ulColumnSize</i></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_LITERAL_<br>
PREFIX</td>
<td width=41%>IDBSchemaRowset::GetRowset<b> DBSCHEMA_PROVIDER_TYPES rowset restricted by DBCOLUMN_TYPE property from </b>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>LITERAL_PREFIX column</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_LITERAL_<br>
SUFFIX</td>
<td width=41%>IDBSchemaRowset::GetRowset<b> DBSCHEMA_PROVIDER_TYPES rowset restricted by DBCOLUMN_TYPE property from </b>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>LITERAL_SUFFIX column</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_LOCAL_<br>
TYPE_NAME</td>
<td width=41%>IDBSchemaRowset::GetRowset<b> DBSCHEMA_PROVIDER_TYPES rowset restricted by DBCOLUMN_TYPE property from </b>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>LOCAL_TYPE_NAME column</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_NAME</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_NULLABLE</td>
<td width=41%>IColumnsRowset::GetColumnsRowset<br>
IColumnsInfo::GetColumnInfo</td>
<td width=27%>DBCOLUMN_FLAGS or <i>dwFlags</i> flag DBCOLUMNFLAGS_<br>
ISNULLABLE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_NUM_PREX_<br>
RADIX</td>
<td width=41%></td>
<td width=27%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_OCTET_<br>
LENGTH</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
OCTETLENGTH</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_PRECISION</td>
<td width=41%>IColumnsRowset::GetColumnsRowset<br>
IColumnsInfo::GetColumnInfo</td>
<td width=27%>DBCOLUMN_<br>
PRECISION or <i>bPrecision</i></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_SCALE</td>
<td width=41%>IColumnsRowset::GetColumnsRowset<br>
IColumnsInfo::GetColumnInfo</td>
<td width=27%>DBCOLUMN_SCALE or <i>bScale</i></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_SCHEMA_<br>
NAME</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
BASESCHEMANAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_SEARCHABLE</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
ISSEARCHABLE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_TABLE_NAME</td>
<td width=41%>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>DBCOLUMN_<br>
BASETABLENAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_TYPE</td>
<td width=41%>IColumnsRowset::GetColumnsRowset<br>
IColumnsInfo::GetColumnInfo</td>
<td width=27%>DBCOLUMN_TYPE or <i>wType</i></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_TYPE_NAME</td>
<td width=41%>IDBSchemaRowset::GetRowset<b> DBSCHEMA_PROVIDER_TYPES rowset restricted by DBCOLUMN_TYPE property from </b>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>TYPE_NAME column</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_UNNAMED</td>
<td width=41%></td>
<td width=27%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_UNSIGNED</td>
<td width=41%>IDBSchemaRowset::GetRowset<b> DBSCHEMA_PROVIDER_TYPES rowset restricted by DBCOLUMN_TYPE property from </b>IColumnsRowset::GetColumnsRowset</td>
<td width=27%>UNSIGNED_<br>
ATTRIBUTE column</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESC_UPDATABLE</td>
<td width=41%>IColumnsRowset::GetColumnsRowset<br>
IColumnsInfo::GetColumnInfo</td>
<td width=27%>DBCOLUMN_FLAGS or <i>dwFlags</i> flag DBCOLUMNFLAGS_<br>
WRITE</td>
</tr>
</table><br>
<h1>Connection Attributes</h1>
<p>
ODBC connection attributes that control the behavior of the ODBC drivers, such as SQL_ATTR_ASYNC_ENABLE, are not included. OLE DB database and schema properties are indicated.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=32%><b><br>
ODBC attribute</b></td>
<td class=label width=37%><b>OLE DB property set, schema rowset, or method</b></td>
<td class=label width=31%><b><br>
OLE DB property or flag</b></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ATTR_ACCESS_MODE</td>
<td width=37%>IDBProperties::SetProperties</td>
<td width=31%>DBPROP_<p>
DATASOURCEREADONLY</p>
</td>
</tr>
<tr valign=top>
<td width=32%>SQL_ATTR_AUTOCOMMIT</td>
<td width=37%></td>
<td width=31%>Autocommit mode is on if the session is outside of a transaction</td>
</tr>
<tr valign=top>
<td width=32%>SQL_ATTR_CONNECTION_<br>
TIMEOUT</td>
<td width=37%></td>
<td width=31%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ATTR_CURRENT_<br>
CATALOG</td>
<td width=37%>IDBProperties::SetProperties</td>
<td width=31%>DBPROP_<br>
CURRENTCATALOG</td>
</tr>
<tr valign=top>
<td width=32%>SQL_ATTR_LOGIN_<br>
TIMEOUT</td>
<td width=37%>IDBProperties::SetProperties</td>
<td width=31%>DBPROP_INIT_TIMEOUT</td>
</tr>
<tr valign=top>
<td width=32%>SQL_ATTR_QUIET_MODE</td>
<td width=37%>IDBProperties::SetProperties</td>
<td width=31%>DBPROP_INIT_HWND</td>
</tr>
<tr valign=top>
<td width=32%>SQL_ATTR_TXN_<br>
ISOLATION</td>
<td width=37%>ITransactionLocal::StartTransaction</td>
<td width=31%><i>isoLevel</i></td>
</tr>
</table><br>
<h1>Statement Attributes</h1>
<p>
OLE DB command properties and rowset methods are indicated.</p>
<p>
ODBC statement attributes that control driver behaviors, such as SQL_ATTR_NOSCAN, are not included in the table. Statement attributes that are used to set bound parameter and column behaviors are also not included. OLE DB uses the DBBINDING structure together with data accessors to control arrays of parameters and bound columns. For more information, see “Getting and Setting Data” in the OLE DB documentation.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=29%><b><br>
ODBC attribute</b></td>
<td class=label width=40%><b>OLE DB property set, schema rowset, <br>
or method</b></td>
<td class=label colspan=2 width=31%><b><br>
OLE DB property or flag</b></td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_ASYNC_<br>
ENABLE</td>
<td width=40%></td>
<td colspan=2 width=31%>Multiple concurrent operations are performed by different threads</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_<br>
CONCURRENCY</td>
<td width=40%>ITransactionLocal::StartTransaction<br>
ISessionProperties::SetProperties<br>
DBPROPSET_SESSION</td>
<td colspan=2 width=31%><i>isoLevel</i> value for the StartTransaction interface, DBPROP_SESS_<br>
AUTOCOMMIT_ISOLEVELS when set for auto commit mode on the session</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_CURSOR_<br>
SCROLLABLE</td>
<td width=40%>ICommandProperties::SetProperties<br>
DBPROPSET_ROWSET</td>
<td colspan=2 width=31%>DBPROP_<br>
CANSCROLLBACKWARDS </td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_CURSOR_<br>
SENSITIVITY</td>
<td width=40%>ICommandProperties::SetProperties<br>
DBPROPSET_ROWSET</td>
<td width=28%>DBPROP_OTHERINSERT and DBPROP_<br>
OTHERUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_CURSOR_<br>
TYPE</td>
<td width=40%>ICommandProperties::SetProperties<br>
DBPROPSET_ROWSET</td>
<td width=28%>DBPROP_CANSCROLL-BACKWARDS, DBPROP_OTHER-INSERT, and DBPROP_<br>
OTHERUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_KEYSET_<br>
SIZE</td>
<td width=40%></td>
<td width=28%></td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_MAX_<br>
LENGTH</td>
<td width=40%></td>
<td width=28%></td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_MAX_ROWS</td>
<td width=40%>ICommandProperties::SetProperties<br>
DBPROPSET_ROWSET</td>
<td width=28%>DBPROP_MAXROWS</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_QUERY_<br>
TIMEOUT</td>
<td width=40%>ICommandProperties::SetProperties<br>
DBPROPSET_ROWSET</td>
<td width=28%>DBPROP_<br>
COMMANDTIMEOUT</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_RETRIEVE_<br>
DATA</td>
<td width=40%>IRowset::GetData</td>
<td width=28%>Data is not retrieved until GetData method is called on the rowset</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_ROW_<br>
ARRAY_SIZE</td>
<td width=40%>IRowset::GetNextRows</td>
<td width=28%><i>cRows </i>value</td>
</tr>
<tr valign=top>
<td width=29%>SQL_ATTR_ROW_<br>
NUMBER</td>
<td width=40%></td>
<td width=28%></td>
</tr>
</table><br>
<h1>SQLGetInfo</h1>
<p>
<b>SQLGetInfo</b> returns information about a specific ODBC data source. OLE DB offers provider property sets and other entry points to expose provider-specific behaviors.</p>
<p>
OLE DB allows providers to define additional property sets. For example, the ODBC provider shipped with the OLE DB SDK defines the DBPROPSET_PROVIDERROWSET and DBPROPSET_PROVIDERDATASOURCEINFO property sets, and some <b>SQLGetInfo</b> <i>InfoType</i> parameters are supported through these provider-specific property sets.</p>
<p>
In the following table, <b>SQLGetInfo</b> <i>InfoType</i> parameters that have no meaning in OLE DB have been eliminated (for example, SQL_DM_VER, which returns the ODBC Driver Manager version number).</p>
<p>
Where a one-to-one match does not exist, a tip is provided to help you discover the information. For example, <b>SQLGetInfo</b> <i>InfoType</i> SQL_ALTER_DOMAIN has no direct support in OLE DB. However, you can use the provider’s <b>IDBInfo::GetKeywords</b> method to determine whether or not the provider recognizes the SQL ALTER statement.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=32%><b><br>
SQLGetInfo <i>InfoType</i> value</b></td>
<td class=label width=35%><b>OLE DB property set, schema rowset, or method</b></td>
<td class=label width=33%><b><br>
OLE DB property or flag</b></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ACCESSIBLE_<br>
PROCEDURES</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ACCESSIBLE_TABLES</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ACTIVE_<br>
ENVIRONMENTS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_AGGREGATE_<br>
FUNCTIONS</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ALTER_DOMAIN</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ALTER_TABLE</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ASYNC_MODE</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_BATCH_ROW_<br>
COUNT</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
MULTIPLEPARAMSETS</td>
</tr>
<tr valign=top>
<td width=32%>SQL_BATCH_SUPPORT</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_BOOKMARK_<br>
PERSISTENCE</td>
<td width=35%></td>
<td width=33%>Bookmarks are valid for the lifetime of the rowset to which they apply</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CATALOG_LOCATION</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
CATALOGLOCATION</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CATALOG_NAME</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_CATALOG_<br>
NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CATALOG_NAME_<br>
SEPARATOR</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_CATALOG_<br>
SEPARATOR</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CATALOG_TERM</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_CATALOGTERM</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CATALOG_USAGE</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_CATALOGUSAGE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_COLLATION_SEQ</td>
<td width=35%>IDBSchemaRowset::GetRowset<br>
<b>COLLATIONS</b></td>
<td width=33%>COLLATION_NAME column</td>
</tr>
<tr valign=top>
<td width=32%>SQL_COLUMN_ALIAS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CONCAT_NULL_<br>
BEHAVIOR</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
CONCATNULLBEHAVIOR</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CONVERT (all types)</td>
<td width=35%>IConvertType::CanConvertType</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CONVERT_<br>
FUNCTIONS</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CORRELATION_NAME</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_ASSERTION</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_<br>
CHARACTER_SET</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_COLLATION</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_DOMAIN</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_SCHEMA</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_TABLE</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_<br>
TRANSLATION</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CREATE_VIEW</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_CURSOR_COMMIT_<br>
BEHAVIOR</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b><p>
ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></p>
</td>
<td width=33%>DBPROP_PREPARE-COMMITBEHAVIOR<p>
DBPROP_<br>
COMMITPRESERVE</p>
</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CURSOR_ROLLBACK_<br>
BEHAVIOR</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b><p>
ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></p>
</td>
<td width=33%>DBPROP_PREPARE-ABORTTBEHAVIOR<p>
DBPROP_<br>
ABORTPRESERVE</p>
</td>
</tr>
<tr valign=top>
<td width=32%>SQL_CURSOR_SENSITIVITY</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DATA_SOURCE_NAME</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
DATASOURCENAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DATA_SOURCE_<br>
READ_ONLY</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
DATASOURCEREADONLY</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DATABASE_NAME</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCE</b></td>
<td width=33%>DBPROP_<br>
CURRENTCATALOG</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DATETIME_LITERALS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DBMS_NAME</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_DBMSNAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DBMS_VER</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_DBMSVER</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DDL_INDEX</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DEFAULT_TXN_<br>
ISOLATION</td>
<td width=35%></td>
<td width=33%>Transaction isolation is explicitly specified</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DESCRIBE_<br>
PARAMETER</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DRIVER_NAME</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_PROVIDERNAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DRIVER_ODBC_VER</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
PROVIDEROLEDBVER</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DRIVER_VER</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_PROVIDERVER</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_ASSERTION</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_CHARACTER_<br>
SET</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_COLLATION</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_DOMAIN</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_SCHEMA</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_TABLE</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_TRANSLATION</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DROP_VIEW</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_DYNAMIC_CURSOR_<br>
ATTRIBUTES1</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS, DBPROP_OTHERINSERT, DBPROP_<br>
OTHERUPDATEDELETE, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_DYNAMIC_CURSOR_<br>
ATTRIBUTES2</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS, DBPROP_OTHERINSERT, DBPROP_<br>
OTHERUPDATEDELETE, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_EXPRESSIONS_IN_<br>
ORDERBY</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_FETCH_DIRECTION</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS</td>
</tr>
<tr valign=top>
<td width=32%>SQL_FILE_USAGE</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_FORWARD_ONLY_<br>
CURSOR_ATTRIBUTES1</td>
<td width=35%>ICommandProperties::<br>
GetProperties<b><br>
DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_OTHERINSERT, DBPROP_<br>
OTHERUPDATEDELETE, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_FORWARD_ONLY_<br>
CURSOR_ATTRIBUTES2</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_OTHERINSERT, DBPROP_<br>
OTHERUPDATEDELETE, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_GETDATA_<br>
EXTENSIONS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_GROUP_BY</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_GROUPBY</td>
</tr>
<tr valign=top>
<td width=32%>SQL_IDENTIFIER_CASE</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_IDENTIFIERCASE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_IDENTIFIER_QUOTE_<br>
CHAR</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_QUOTE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_INDEX_KEYWORDS</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_INFO_SCHEMA_VIEWS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_INSERT_STATEMENT</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_INTEGRITY</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_KEYSET_CURSOR_<br>
ATTRIBUTES1</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_KEYSET_CURSOR_<br>
ATTRIBUTES2</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_KEYWORDS</td>
<td width=35%>IDBInfo::GetKeywords</td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_LIKE_ESCAPE_<br>
CLAUSE</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_ESCAPE_<br>
PERCENT, DBLITERAL_<br>
ESCAPE_UNDERSCORE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_ASYNC_<br>
CONCURRENT_<br>
STATEMENTS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_BINARY_<br>
LITERAL_LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_BINARY_<br>
LITERAL</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_CATALOG_<br>
NAME_LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_CATALOG_<br>
NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_CHAR_<br>
LITERAL_LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_CHAR_LITERAL</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_COLUMN_<br>
NAME_LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_COLUMN_<br>
NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_COLUMNS_<br>
IN_GROUP_BY</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_COLUMNS_<br>
IN_INDEX</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_COLUMNS_<br>
IN_ORDER_BY</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_COLUMNS_<br>
IN_SELECT</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_COLUMNS_<br>
IN_TABLE</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_CONCURRENT_<br>
ACTIVITIES</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_CURSOR_NAME_<br>
LEN</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_DRIVER_<br>
CONNECTIONS</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_ACTIVESESSIONS</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_IDENTIFIER_<br>
LEN</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_INDEX_SIZE</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_MAXINDEXSIZE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_PROCEDURE_<br>
NAME_LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_PROCEDURE_<br>
NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_ROW_SIZE</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_MAXROWSIZE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_ROW_SIZE_<br>
INCLUDES_LONG</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
MAXROWSIZEINCLUDES-BLOB</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_STATEMENT_<br>
LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_TEXT_<br>
COMMAND</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_TABLE_NAME_<br>
LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_TABLE_NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_TABLES_IN_<br>
SELECT</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
MAXTABLESINSELECT</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MAX_USER_NAME_<br>
LEN</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>DBLITERAL_USER_NAME</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MULT_RESULT_SETS</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
MULTIPLERESULTS</td>
</tr>
<tr valign=top>
<td width=32%>SQL_MULTIPLE_ACTIVE_<br>
TXN</td>
<td width=35%></td>
<td width=33%>Provider is responsible for spawning connections, if necessary, to provide multiple transactions from one DSO</td>
</tr>
<tr valign=top>
<td width=32%>SQL_NEED_LONG_DATA_<br>
LEN</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_NON_NULLABLE_<br>
COLUMNS</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
COLUMNDEFINITION</td>
</tr>
<tr valign=top>
<td width=32%>SQL_NULL_COLLATION</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_NULLCOLLATION</td>
</tr>
<tr valign=top>
<td width=32%>SQL_NUMERIC_FUNCTIONS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_OJ_CAPABILITIES</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_ORDER_BY_<br>
COLUMNS_IN_SELECT</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
ORDERBYCOLUMNSIN-SELECT</td>
</tr>
<tr valign=top>
<td width=32%>SQL_OUTER_JOINS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_OWNER_TERM</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_SCHEMATERM</td>
</tr>
<tr valign=top>
<td width=32%>SQL_OWNER_USAGE</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_SCHEMAUSAGE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_PARAM_ARRAY_<br>
ROW_COUNTS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_PARAM_ARRAY_<br>
SELECTS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_PROCEDURE_TERM</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
PROCEDURETERM</td>
</tr>
<tr valign=top>
<td width=32%>SQL_PROCEDURES</td>
<td width=35%>IDBSchemaRowset::GetSchemas <b>returns GUID for PROCEDURES schema rowset</b></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_QUOTED_IDENTIFIER_<br>
CASE</td>
<td width=35%>IDBProperties::GetProperties<b><br>
DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
QUOTEDIDENTIFIERCASE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_ROW_UPDATES</td>
<td width=35%>ICommandProperties::<br>
GetProperties<b><br>
DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_IRowsetResynch</td>
</tr>
<tr valign=top>
<td width=32%>SQL_SCHEMA_TERM</td>
<td width=35%>IDBProperties::GetProperties<b><br>
DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_SCHEMATERM</td>
</tr>
<tr valign=top>
<td width=32%>SQL_SCHEMA_USAGE</td>
<td width=35%>IDBProperties::GetProperties<b><br>
DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_SCHEMAUSAGE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_SCROLL_OPTIONS</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS, DBPROP_OTHERINSERT, DBPROP_<br>
OTHERUPDATEDELETE, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_SEARCH_PATTERN_<br>
ESCAPE</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_SERVER_NAME</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_INIT</b></td>
<td width=33%>DBPROP_INIT_LOCATION</td>
</tr>
<tr valign=top>
<td width=32%>SQL_SPECIAL_<br>
CHARACTERS</td>
<td width=35%>IDBInfo::GetLiteralInfo</td>
<td width=33%>Value of <i>pwszInvalidChars</i> when inquiring about identifiers, and so on</td>
</tr>
<tr valign=top>
<td width=32%>SQL_STATIC_CURSOR_<br>
ATTRIBUTES1</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
<b>DBPROPSET_ROWSET</b></td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_STATIC_CURSOR_<br>
ATTRIBUTES2</td>
<td width=35%>ICommandProperties::<br>
GetProperties<br>
DBPROPSET_ROWSET</td>
<td width=33%>DBPROP_<br>
CANSCROLLBACKWARDS, DBPROP_OWNINSERT, DBPROP_<br>
OWNUPDATEDELETE</td>
</tr>
<tr valign=top>
<td width=32%>SQL_STRING_FUNCTIONS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_SUBQUERIES</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_SUBQUERIES</td>
</tr>
<tr valign=top>
<td width=32%>SQL_SYSTEM_FUNCTIONS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_TABLE_TERM</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_TABLETERM</td>
</tr>
<tr valign=top>
<td width=32%>SQL_TIMEDATE_ADD_<br>
INTERVALS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_TIMEDATE_DIFF_<br>
INTERVALS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_TIMEDATE_<br>
FUNCTIONS</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_TXN_CAPABLE</td>
<td width=35%>IUnknown::QueryInterface on session for <b>IID_ITransactionLocal</b></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_TXN_ISOLATION_<br>
OPTION</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_<br>
SUPPORTED-TXNISORETAIN</td>
</tr>
<tr valign=top>
<td width=32%>SQL_UNION</td>
<td width=35%></td>
<td width=33%></td>
</tr>
<tr valign=top>
<td width=32%>SQL_USER_NAME</td>
<td width=35%>IDBProperties::GetProperties<br>
<b>DBPROPSET_DATASOURCEINFO</b></td>
<td width=33%>DBPROP_USERNAME</td>
</tr>
</table><br>
<p>
The following interfaces also support setting and getting of property information:
<ul type=disc>
<li>
<b>ICommandProperties</b>. Registers with the command the properties from the Rowset Property Group. The consumer can specify whether these properties specify optional or required support on the returned rowset.<br><br></li>
<li>
<b>IRowsetInfo::GetProperties</b>. Returns the current settings of all properties supported by the rowset. The value returned by this method can be different from the value returned by <b>ICommandProperties::GetProperties</b> for a property. This is because the provider’s ability to support the property might be affected by the current transaction or current query.</li>
</ul>
<h1>Mapping ODBC Functions to OLE DB Methods</h1>
<p>
Because a direct mapping between ODBC functions and OLE DB methods does not exist in all cases, only similar functionality is provided. When more than one method can be used to achieve the same thing, the methods are separated with the word “or”; for example, MethodA or MethodB. When more than one method must be called in sequence, the methods are numbered; for example, 1. MethodA, 2. MethodB, and so on.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=26%><b>ODBC function</b></td>
<td class=label width=40%><b>OLE DB method</b></td>
<td class=label width=34%><b>Remarks/property</b></td>
</tr>
<tr valign=top>
<td width=26%>SQLAllocHandle<p>
&nbsp;&nbsp;Environment</p>
<p>
&nbsp;&nbsp;Connection</p>
<p>
&nbsp;&nbsp;Descriptor</p>
<p>
&nbsp;&nbsp;Statement</p>
</td>
<td width=40%><p>
OleInitialize</p>
<p>
CoCreateInstance</p>
<p>
IAccessor::CreateAccessor</p>
<p>
IDBCreateCommand::CreateCommand</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLBindCol</td>
<td width=40%>IAccessor::CreateAccessor</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLBindParameter</td>
<td width=40%>IAccessor::CreateAccessor</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLBrowseConnect</td>
<td width=40%>ISourcesRowset::GetSourcesRowset</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLBulkOperations<p>
&nbsp;&nbsp;Insertions</p>
<p>
&nbsp;&nbsp;Deletions</p>
<p>
&nbsp;&nbsp;Updates</p>
<p>
&nbsp;&nbsp;Retrieve by bookmark</p>
</td>
<td width=40%><p>
IRowsetChange::InsertRows</p>
<p>
IRowsetChange::DeleteRows</p>
<p>
IRowsetChange::SetData</p>
<p>
IRowsetLocate::GetRowsByBookmark</p>
</td>
<td width=34%>If <b>IRowsetUpdate</b> is requested, all operations are batched until IRowsetUpdate::Update is called</td>
</tr>
<tr valign=top>
<td width=26%>SQLCancel</td>
<td width=40%>ICommand::Cancel</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLCloseCursor</td>
<td width=40%>IRowset::Release</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLColAttribute</td>
<td width=40%>IColumnsInfo::GetColumnInfo<b> or</b> IColumnsRowset::GetColumnsRowset</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLColumnPrivileges</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_<p>
COLUMN_PRIVILEGES</p>
</td>
</tr>
<tr valign=top>
<td width=26%>SQLColumns</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_COLUMNS</td>
</tr>
<tr valign=top>
<td width=26%>SQLConnect</td>
<td width=40%><b>1. </b>IDBProperties::SetProperties<p>
<b>2. </b>IDBInitialize::Initialize</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLDataSources</td>
<td width=40%>ISourcesRowset::GetSourcesRowset</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLDescribeCol</td>
<td width=40%>IColumnsInfo::GetColumnInfo</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLDescribeParam </td>
<td width=40%>ICommandWithParameters::<p>
GetParameterInfo</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLDisconnect</td>
<td width=40%>IDBInitialize::Uninitialize</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLDriverConnect</td>
<td width=40%><b>1. </b>IDBProperties::SetProperties<p>
<b>2. </b>IDBInitialize::Initialize</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLDrivers </td>
<td width=40%>ISourcesRowset::GetSourcesRowset</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLEndTran</td>
<td width=40%>ITransaction::Commit <b>or</b> ITransaction::Abort</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLError</td>
<td width=40%><b>1. </b>GetErrorInfo<p>
<b>2. </b>IErrorRecords</p>
<p>
<b>3. </b>IErrorInfo</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLExecDirect</td>
<td width=40%>ICommand::Execute</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLExecute</td>
<td width=40%>ICommand::Execute</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLFetch </td>
<td width=40%><b>1. </b>IRowset::GetNextRows,<p>
IRowsetLocate::GetRowsAt, <b>or</b> </p>
<p>
IRowsetLocate::GetRowsByBookmark</p>
<p>
<b>2. </b>IRowset::GetData</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLFetchScroll</td>
<td width=40%><b>1. </b>IRowset::GetNextRows,<p>
IRowsetLocate::GetRowsAt, <b>or</b></p>
<p>
IRowsetLocate::GetRowsByBookmark</p>
<p>
<b>2. </b>IRowset::GetData</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLForeignKeys</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_<p>
FOREIGN_KEYS</p>
</td>
</tr>
<tr valign=top>
<td width=26%>SQLFreeHandle <p>
&nbsp;&nbsp;Environment</p>
<p>
&nbsp;&nbsp;Connection</p>
<p>
&nbsp;&nbsp;Descriptor</p>
<p>
&nbsp;&nbsp;Statement</p>
</td>
<td width=40%><p>
OleUninitialize</p>
<p>
IDBInitialize::Release</p>
<p>
IAccessor::ReleaseAccessor</p>
<p>
IRowset::Release</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLFreeStmt<p>
&nbsp;&nbsp;SQL_DROP</p>
<p>
&nbsp;&nbsp;SQL_CLOSE</p>
<p>
&nbsp;&nbsp;SQL_UNBIND</p>
<p>
&nbsp;&nbsp;SQL_RESET_<br>
  PARAMS</p>
</td>
<td width=40%><p>
ICommand::Release</p>
<p>
IRowset::Release</p>
<p>
IAccessor::ReleaseAccessor</p>
<p>
IAccessor::ReleaseAccessor</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetConnectAttr</td>
<td width=40%>IDBProperties::GetProperties</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetCursorName </td>
<td width=40%><b>Not applicable</b></td>
<td width=34%>OLE DB performs updates through update methods, as opposed to positioned cursor operations</td>
</tr>
<tr valign=top>
<td width=26%>SQLGetData</td>
<td width=40%>IRowset::GetData <br>
<b>(for all data except BLOBs) or<br>
</b>ILockBytes<b>, </b>ISequentialStream, IStorage<b>, or </b>IStream <b>(for BLOB data)</b></td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetDescField</td>
<td width=40%>IAccessor::GetBindings</td>
<td width=34%>Elements within binding structure</td>
</tr>
<tr valign=top>
<td width=26%>SQLGetDescRec</td>
<td width=40%>IAccessor::GetBindings</td>
<td width=34%>Elements within binding structure</td>
</tr>
<tr valign=top>
<td width=26%>SQLDiagField</td>
<td width=40%><b>1. </b>GetErrorInfo<p>
<b>2. </b>IErrorRecords</p>
<p>
<b>3. </b>IErrorInfo</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLDiagRec</td>
<td width=40%><b>1. </b>GetErrorInfo<p>
<b>2. </b>IErrorRecords</p>
<p>
<b>3. </b>IErrorInfo</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetEnvAttr</td>
<td width=40%>IDBProperties::GetProperties</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetFunctions</td>
<td width=40%>IUnknown::QueryInterface</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetInfo</td>
<td width=40%>IDBProperties::GetProperties</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetStmtAttr</td>
<td width=40%>ICommandProperties::GetProperties<b> or </b>IRowsetInfo::GetProperties</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLGetTypeInfo</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_<p>
PROVIDER_TYPES</p>
</td>
</tr>
<tr valign=top>
<td width=26%>SQLMoreResults </td>
<td width=40%>IMultipleResults</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLNativeSql </td>
<td width=40%>ICommandText::GetCommandText</td>
<td width=34%>With NULL as pguidDialect</td>
</tr>
<tr valign=top>
<td width=26%>SQLNumParams </td>
<td width=40%>ICommandWithParams::<br>
GetParameterInfo</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLNumResultCols </td>
<td width=40%>IColumnsInfo::GetColumnInfo</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLParamData </td>
<td width=40%><b>Not applicable</b></td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLPrepare</td>
<td width=40%>ICommand::Prepare</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLPrimaryKeys</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_<p>
PRIMARY_KEYS</p>
</td>
</tr>
<tr valign=top>
<td width=26%>SQLProcedureColumns</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_<p>
PROCEDURE_PARAMETERS, DBSCHEMA_</p>
<p>
PROCEDURE_COLUMNS</p>
</td>
</tr>
<tr valign=top>
<td width=26%>SQLProcedures</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_PROCEDURES</td>
</tr>
<tr valign=top>
<td width=26%>SQLPutData </td>
<td width=40%>IRowsetChange::SetData<br>
<b>(for all data except BLOBs) or<br>
</b>ISequentialStream <b>(for BLOB data)</b></td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLRowCount</td>
<td width=40%><b><i>cRowsAffected</i> in </b>ICommand::Execute</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLSetConnectAttr</td>
<td width=40%>IDBProperties::SetProperties</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLSetCursorName </td>
<td width=40%><b>Not applicable</b></td>
<td width=34%>OLE DB performs updates through update methods, as opposed to positioned cursor operations</td>
</tr>
<tr valign=top>
<td width=26%>SQLSetDescField</td>
<td width=40%>IAccessor::CreateAccessor</td>
<td width=34%>Elements within binding structure</td>
</tr>
<tr valign=top>
<td width=26%>SQLSetDescRec</td>
<td width=40%>IAccessor::CreateAccessor</td>
<td width=34%>Elements within binding structure</td>
</tr>
<tr valign=top>
<td width=26%>SQLSetEnvAttr</td>
<td width=40%>IDBProperties::SetProperties</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLSetParam</td>
<td width=40%>ICommandWithParameters::SetParameterInfo</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLSetPos<p>
&nbsp;&nbsp;SQL_POSITION</p>
<p>
&nbsp;&nbsp;SQL_REFRESH</p>
<p>
&nbsp;&nbsp;SQL_UPDATE</p>
<p>
&nbsp;&nbsp;SQL_DELETE</p>
<p>
&nbsp;&nbsp;SQL_ADD</p>
</td>
<td width=40%><p>
<b>Not applicable</b></p>
<p>
IRowset::GetData<b> or </b>IRowsetResynch</p>
<p>
IRowsetChange::SetData</p>
<p>
IRowsetChange::Delete</p>
<p>
IRowsetChange::InsertRow</p>
<p>
IRowsetUpdate::Update</p>
</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLSetStmtAttr</td>
<td width=40%>ICommandProperties::SetProperties</td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=26%>SQLSpecialColumns</td>
<td width=40%>IColumnsInfo::GetColumnInfo</td>
<td width=34%>DBCOLUMNFLAGS_<br>
ISROWID and DBCOLUMNFLAGS_<br>
ISROWVER</td>
</tr>
<tr valign=top>
<td width=26%>SQLStatistics</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_STATISTICS</td>
</tr>
<tr valign=top>
<td width=26%>SQLTablePrivileges</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_TABLE_<br>
PRIVILEGES</td>
</tr>
<tr valign=top>
<td width=26%>SQLTables</td>
<td width=40%>IDBSchemaRowset::GetRowset</td>
<td width=34%>DBSCHEMA_TABLES</td>
</tr>
<tr valign=top>
<td width=26%>SQLTransact</td>
<td width=40%>ITransaction::Abort<b> and </b>ITransaction::Commit</td>
<td width=34%></td>
</tr>
</table><br>
<h1>Conclusion</h1>
<p>
ODBC and OLE DB each provide a rich application programming interface for the database developer. OLE and the component object model present the ODBC developer with an entirely new way of writing. The ODBC developer, familiar with procedural programming, must become comfortable with the world of OLE objects and the interface negotiation required to manipulate those objects.</p>
<p>
In addition, OLE DB often presents a new implementation of familiar development concepts like tabular data structures. The ODBC developer will need to rethink application structure to make effective use of OLE DB’s sessions, property sets, rowsets, and accessors.</p>
<p>
Becoming comfortable with OLE objects is a first step toward successful OLE application development. In this paper, tasks typically executed by an ODBC application are implemented through OLE DB object creation and manipulation. The information presented builds on the ODBC database developer’s existing knowledge to smooth the introduction to this new and different technology.</p>
<h1>Finding More Information</h1>
<p>
For more information about OLE DB and ODBC, see the following publications:</p>
<p>
Brockschmidt, Kraig. <i>Inside OLE.</i> Microsoft Press®, 1995.</p>
<p>
Geiger, Kyle. <i>Inside ODBC</i>. Microsoft Press, 1995.</p>
<p>
<i>Microsoft ODBC 3.0 Programmer’s Reference and SDK Guide</i>. Microsoft Press, 1997.</p>
<p>
<i>Microsoft OLE 2 Programmer’s Reference</i>. Volume 1. Microsoft Press, 1994.</p>
<p>
<i>Microsoft OLE DB Programmer’s Reference</i>. </p>
<h1>Appendix A</h1>
<p>
The following is a complete source code listing for the example presented in “Basic OLE DB.” The example selects the <b>CompanyName</b>, <b>City</b>, <b>Phone</b>,<b> </b>and <b>FAX </b>columns from the <b>Customers </b>table of the <b>Access Northwind </b>sample database. The database is shipped with the OLE DB SDK and is installed as the ODBC data source <i>OLE_DB_NWind_Jet.</i></p>
<p>
To build the file using Microsoft® Visual C++® 4.0 or later:
<ol>
<li>
Create a new console application.<br><br></li>
<li>
Copy the following code to a new .cpp file.<br><br></li>
<li>
Ensure that your build directory settings reference the OLE DB SDK include directory.<br><br></li>
<li>
Alter the build, link settings to include linking to Oledb.lib.</li>
</ol>
<pre><code>/********************************************************************
* OLE DB
********************************************************************/
#define UNICODE
#define _UNICODE
#define DBINITCONSTANTS // Initialize OLE constants...
#define INITGUID&nbsp;&nbsp;&nbsp; // ...once in each app

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#include &lt;oledb.h&gt;  // OLE DB include files
#include &lt;oledberr.h&gt; 
#include &lt;msdaguid.h&gt; // ODBC provider include files
#include &lt;msdasql.h&gt;

// Macros--number of row identifiers to retrieve
#define NUMROWS_CHUNK&nbsp;&nbsp;&nbsp;&nbsp; 35

// Prototypes
HRESULT myInitDSO(IDBInitialize** ppIDBI);
HRESULT mySetInitProps(IDBInitialize* pIDBInitialize);
HRESULT myCommand(IDBInitialize* pIDBI, IRowset** ppIRowset);
void&nbsp; myGetData(IRowset* pIRowset);
void&nbsp; DumpError(LPSTR lpStr);
HRESULT myGetColumnsInfo(IRowset* pIRowset, ULONG* pnCols,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBCOLUMNINFO** ppColumnsInfo, OLECHAR** ppColumnStrings);
void&nbsp; myCreateDBBindings(ULONG nCols, DBCOLUMNINFO* pColumnsInfo,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBBINDING** ppDBBindings, char** ppRowValues);

// Global task memory allocator
IMalloc*&nbsp;&nbsp;&nbsp; g_pIMalloc = NULL;

/********************************************************************
* General OLE DB application main()
********************************************************************/
int main()
  {
  IDBInitialize*&nbsp; pIDBInitialize = NULL;
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset = NULL;

  // Init OLE and set up the DLLs
  CoInitialize(NULL);

  // Get the task memory allocator.
  if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;g_pIMalloc)))
 &nbsp;&nbsp; goto EXIT;

 // Connect to the data source.
  if (FAILED(myInitDSO(&amp;pIDBInitialize)))
 &nbsp;&nbsp; goto EXIT;

  // Get a session, set and execute a command.
  if (FAILED(myCommand(pIDBInitialize, &amp;pIRowset)))
 &nbsp;&nbsp; goto EXIT;

  // Retrieve data from rowset.
  myGetData(pIRowset);

EXIT:
  // Clean up and disconnect.
  if (pIRowset != NULL)
 &nbsp;&nbsp; pIRowset-&gt;Release();

  if (pIDBInitialize != NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if (FAILED(pIDBInitialize-&gt;Uninitialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Uninitialize is not required, but it will fail if an 
 &nbsp;&nbsp; // interface has not been released; we can use it for
 &nbsp;&nbsp; // debugging.
 &nbsp;&nbsp; DumpError("Someone forgot to release something!");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; pIDBInitialize-&gt;Release();
 &nbsp;&nbsp; }

  if (g_pIMalloc != NULL)
 &nbsp;&nbsp; g_pIMalloc-&gt;Release();

  CoUninitialize();
  
  return (0);
  }

/********************************************************************
* Initialize the data source.
********************************************************************/
HRESULT myInitDSO
  (
  IDBInitialize** ppIDBInitialize&nbsp; // [out]
  )
  {
  // Create an instance of the MSDASQL (ODBC) provider.
  CoCreateInstance(CLSID_MSDASQL, NULL, CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp; IID_IDBInitialize, (void**)ppIDBInitialize);

  if (*ppIDBInitialize == NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  if (FAILED(mySetInitProps(*ppIDBInitialize)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  if (FAILED((*ppIDBInitialize)-&gt;Initialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("IDBInitialze-&gt;Initialize failed.");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  return (NOERROR);
  }

/********************************************************************
* Set initialization properties on a data source.
********************************************************************/
HRESULT mySetInitProps
  (
  IDBInitialize*&nbsp; pIDBInitialize&nbsp; // [in]
  )
  {
  const ULONG&nbsp;&nbsp; nProps = 4;
  IDBProperties*&nbsp; pIDBProperties;
  DBPROP&nbsp;&nbsp;&nbsp; InitProperties[nProps];
  DBPROPSET&nbsp;&nbsp; rgInitPropSet;
  HRESULT&nbsp;&nbsp; hr;

  // Initialize common property options.
  for (ULONG i = 0; i &lt; nProps; i++ )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; VariantInit(&amp;InitProperties[i].vValue);
 &nbsp;&nbsp; InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
 &nbsp;&nbsp; InitProperties[i].colid = DB_NULLID;
 &nbsp;&nbsp; }

  // Level of prompting that will be done to complete the 
  // connection process
  InitProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
  InitProperties[0].vValue.vt = VT_I2;
  InitProperties[0].vValue.iVal = DBPROMPT_NOPROMPT;    

  // Data source name--see the sample source included with the OLE
  // DB SDK.
  InitProperties[1].dwPropertyID = DBPROP_INIT_DATASOURCE;   
  InitProperties[1].vValue.vt = VT_BSTR;
  InitProperties[1].vValue.bstrVal = 
 &nbsp;&nbsp; SysAllocString(OLESTR("OLE_DB_NWind_Jet"));

  // User ID
  InitProperties[2].dwPropertyID = DBPROP_AUTH_USERID;
  InitProperties[2].vValue.vt = VT_BSTR;
  InitProperties[2].vValue.bstrVal = SysAllocString(OLESTR(""));

  // Password
  InitProperties[3].dwPropertyID = DBPROP_AUTH_PASSWORD;
  InitProperties[3].vValue.vt = VT_BSTR;
  InitProperties[3].vValue.bstrVal = SysAllocString(OLESTR(""));

  rgInitPropSet.guidPropertySet = DBPROPSET_DBINIT;
  rgInitPropSet.cProperties = nProps;
  rgInitPropSet.rgProperties = InitProperties;

  // Set initialization properties.
  pIDBInitialize-&gt;QueryInterface(IID_IDBProperties, (void**) 
 &nbsp;&nbsp; &amp;pIDBProperties);
  hr = pIDBProperties-&gt;SetProperties(1, &amp;rgInitPropSet);

  SysFreeString(InitProperties[1].vValue.bstrVal);
  SysFreeString(InitProperties[2].vValue.bstrVal);
  SysFreeString(InitProperties[3].vValue.bstrVal);

  pIDBProperties-&gt;Release();

  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Set properties failed.");
 &nbsp;&nbsp; }

  return (hr);
  }

/********************************************************************
* Execute a command, retrieve a rowset interface pointer.
********************************************************************/
HRESULT myCommand
  (
  IDBInitialize*&nbsp; pIDBInitialize, // [in]
  IRowset**&nbsp;&nbsp; ppIRowset&nbsp;&nbsp; // [out]
  ) 
  {
  IDBCreateSession* pIDBCreateSession;
  IDBCreateCommand* pIDBCreateCommand;
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset;
  ICommandText*&nbsp;&nbsp; pICommandText;
  LPCTSTR&nbsp;&nbsp;&nbsp;&nbsp; wSQLString = OLESTR("SELECT CompanyName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; City, Phone, Fax")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" FROM Customers")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" ORDER BY CompanyName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; City");
  LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;
  HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;

  // Get the DB session object.
  if (FAILED(pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession,
 &nbsp;&nbsp; (void**) &amp;pIDBCreateSession)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Session initialization failed.");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  // Create the session, getting an interface for command creation.
  hr = pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
  pIDBCreateSession-&gt;Release();
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Create session failed.");
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }

  // Create the command object.
  hr = pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText,
 &nbsp;&nbsp; (IUnknown**) &amp;pICommandText);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Create command failed.");
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }
  pIDBCreateCommand-&gt;Release();

  // The command requires the actual text as well as an indicator
  // of its language and dialect.
  pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLString);

  // Execute the command.
  hr = pICommandText-&gt;Execute(NULL, IID_IRowset, NULL, 
 &nbsp; &amp;cRowsAffected, (IUnknown**) &amp;pIRowset);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Command execution failed.");
 &nbsp;&nbsp; }
  pICommandText-&gt;Release();

  *ppIRowset = pIRowset;
  return (hr);
  }

/********************************************************************
* Get the characteristics of the rowset (the ColumnsInfo interface).
********************************************************************/
HRESULT myGetColumnsInfo
  (
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset,&nbsp;&nbsp;&nbsp; // [in]
  ULONG*&nbsp;&nbsp;&nbsp; pnCols,&nbsp;&nbsp;&nbsp; // [out]
  DBCOLUMNINFO**&nbsp; ppColumnsInfo, // [out]
  OLECHAR**&nbsp;&nbsp; ppColumnStrings&nbsp; // [out]
  )
  {
  IColumnsInfo* pIColumnsInfo;
  HRESULT&nbsp;&nbsp; hr;

  if (FAILED(pIRowset-&gt;QueryInterface(IID_IColumnsInfo, (void**) &amp;pIColumnsInfo)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Query rowset interface for IColumnsInfo failed");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  hr = pIColumnsInfo-&gt;GetColumnInfo(pnCols, ppColumnsInfo, ppColumnStrings);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("GetColumnInfo failed.");
 &nbsp;&nbsp; *pnCols = 0;
 &nbsp;&nbsp; }

  pIColumnsInfo-&gt;Release();
  return (hr);
  }

/********************************************************************
* Create binding structures from column information. Binding
* structures will be used to create an accessor that allows row value 
* retrieval.
********************************************************************/
void myCreateDBBindings
  (
  ULONG nCols,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [in]
  DBCOLUMNINFO* pColumnsInfo,&nbsp; // [in]
  DBBINDING** ppDBBindings,&nbsp; // [out]
  char** ppRowValues&nbsp;&nbsp;&nbsp;&nbsp; // [out]
  )
  {
  ULONG&nbsp;&nbsp; nCol;
  ULONG&nbsp;&nbsp; cbRow = 0;
  DBBINDING*&nbsp; pDBBindings;
  char*&nbsp;&nbsp; pRowValues;

  pDBBindings = new DBBINDING[nCols];

  for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pDBBindings[nCol].iOrdinal = nCol+1;
 &nbsp;&nbsp; pDBBindings[nCol].obValue = cbRow;
 &nbsp;&nbsp; pDBBindings[nCol].obLength = 0;
 &nbsp;&nbsp; pDBBindings[nCol].obStatus = 0;
 &nbsp;&nbsp; pDBBindings[nCol].pTypeInfo = NULL;
 &nbsp;&nbsp; pDBBindings[nCol].pObject = NULL;
 &nbsp;&nbsp; pDBBindings[nCol].pBindExt = NULL;
 &nbsp;&nbsp; pDBBindings[nCol].dwPart = DBPART_VALUE;
 &nbsp;&nbsp; pDBBindings[nCol].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 &nbsp;&nbsp; pDBBindings[nCol].eParamIO = DBPARAMIO_NOTPARAM;
 &nbsp;&nbsp; pDBBindings[nCol].cbMaxLen = pColumnsInfo[nCol].ulColumnSize;
 &nbsp;&nbsp; pDBBindings[nCol].dwFlags = 0;
 &nbsp;&nbsp; pDBBindings[nCol].wType = pColumnsInfo[nCol].wType;
 &nbsp;&nbsp; pDBBindings[nCol].bPrecision = pColumnsInfo[nCol].bPrecision;
 &nbsp;&nbsp; pDBBindings[nCol].bScale = pColumnsInfo[nCol].bScale;

 &nbsp;&nbsp; cbRow += pDBBindings[nCol].cbMaxLen;
 &nbsp;&nbsp; }

  pRowValues = new char[cbRow];

  *ppDBBindings = pDBBindings;
  *ppRowValues = pRowValues;

  return;
  }

/********************************************************************
* Retrieve data from a rowset.
********************************************************************/
void myGetData
  (
  IRowset*&nbsp; pIRowset&nbsp; // [in]
  ) 
  {
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nCols;
  DBCOLUMNINFO* pColumnsInfo = NULL;
  OLECHAR*&nbsp;&nbsp;&nbsp; pColumnStrings = NULL;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nCol;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cRowsObtained;&nbsp;&nbsp; // Number of rows obtained
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; iRow;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Row count
  HROW&nbsp;&nbsp;&nbsp; rghRows[NUMROWS_CHUNK];// Row handles
  HROW*&nbsp;&nbsp;&nbsp;&nbsp; pRows = &amp;rghRows[0]; // Pointer to the row 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handles
  IAccessor*&nbsp; pIAccessor;&nbsp;&nbsp;&nbsp; // Pointer to the accessor
  HACCESSOR&nbsp;&nbsp; hAccessor;&nbsp;&nbsp;&nbsp;&nbsp; // Accessor handle
  DBBINDSTATUS* pDBBindStatus = NULL;
  DBBINDING*&nbsp; pDBBindings = NULL;
  char*&nbsp;&nbsp;&nbsp;&nbsp; pRowValues;

  // Get the description of the rowset for use in binding structure
  // creation.
  if (FAILED(myGetColumnsInfo(pIRowset, &amp;nCols, &amp;pColumnsInfo,
 &nbsp;&nbsp; &amp;pColumnStrings)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return;
 &nbsp;&nbsp; }

  // Create the binding structures.
  myCreateDBBindings(nCols, pColumnsInfo, &amp;pDBBindings, 
 &nbsp;&nbsp; &amp;pRowValues);
  pDBBindStatus = new DBBINDSTATUS[nCols];

  // Create the accessor.
  pIRowset-&gt;QueryInterface(IID_IAccessor, (void**) &amp;pIAccessor);
  pIAccessor-&gt;CreateAccessor(
 &nbsp;&nbsp; DBACCESSOR_ROWDATA, // Accessor will be used to retrieve row 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // data.
 &nbsp;&nbsp; nCols,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of columns being bound
 &nbsp;&nbsp; pDBBindings,&nbsp;&nbsp;&nbsp; // Structure containing bind info
 &nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not used for row accessors 
 &nbsp;&nbsp; &amp;hAccessor,&nbsp;&nbsp; // Returned accessor handle
 &nbsp;&nbsp; pDBBindStatus&nbsp;&nbsp; // Information about binding validity
 &nbsp;&nbsp; );

  // Process all the rows, NUMROWS_CHUNK rows at a time
  while (TRUE)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pIRowset-&gt;GetNextRows(
 &nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cRowsToSkip
 &nbsp;&nbsp; NUMROWS_CHUNK,&nbsp; // cRowsDesired
 &nbsp;&nbsp; &amp;cRowsObtained,&nbsp;&nbsp; // cRowsObtained
 &nbsp;&nbsp; &amp;pRows );&nbsp;&nbsp;&nbsp;&nbsp; // Filled in w/ row handles.


 &nbsp;&nbsp; // All done; there are no more rows left to get.
 &nbsp;&nbsp; if (cRowsObtained == 0)
 &nbsp;&nbsp; break;

 &nbsp;&nbsp; // Loop over rows obtained, getting data for each.
 &nbsp;&nbsp; for (iRow=0; iRow &lt; cRowsObtained; iRow++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pIRowset-&gt;GetData(rghRows[iRow], hAccessor, pRowValues);
 &nbsp;&nbsp; for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; wprintf(OLESTR("%s%s:"), pColumnsInfo[nCol].pwszName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcslen(pColumnsInfo[nCol].pwszName) &gt; 10 ? 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("\t") :
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("\t\t"));
 &nbsp;&nbsp;&nbsp;&nbsp; printf("\t%s\n", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pRowValues[pDBBindings[nCol].obValue]);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; printf("\n");
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Release row handles.
 &nbsp;&nbsp; pIRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL, 
 &nbsp;&nbsp;&nbsp; NULL);
 &nbsp;&nbsp; }&nbsp; // End while

  // Release the accessor.
  pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL);
  pIAccessor-&gt;Release();

  delete [] pDBBindings;
  delete [] pDBBindStatus;

  g_pIMalloc-&gt;Free( pColumnsInfo );
  g_pIMalloc-&gt;Free( pColumnStrings );

  return;
  }

/********************************************************************
* Dump an error to the console.
********************************************************************/
void DumpError(LPSTR lpStr)
  {
  printf(lpStr);
  printf("\n");
  }</code></pre>
<h1>Appendix B</h1>
<p>
The following is a complete source code listing for the example presented in “Handling Long Data Types.” The example selects the <b>Notes</b> column (LONG_VARCHAR) from the <b>Employees </b>table of the <b>Access Northwind </b>sample database. The database is shipped with the OLE DB SDK and is installed as the ODBC data source <i>OLE_DB_NWind_Jet.</i></p>
<p>
To build the file using Microsoft Visual C++ 4.0 or later:
<ol>
<li>
Create a new console application.<br><br></li>
<li>
Copy the following code to a new .cpp file.<br><br></li>
<li>
Ensure that your build directory settings reference the OLE DB SDK include directory.<br><br></li>
<li>
Alter the build link settings to include linking to Oledb.lib.</li>
</ol>
<pre><code>/********************************************************************
* Using ISequentialStream to retrieve LONG_VARCHAR/ LONG_VARBINARY
* (BLOB) data
********************************************************************/
#define UNICODE
#define _UNICODE
#define DBINITCONSTANTS
#define INITGUID

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#include &lt;oledb.h&gt;  // OLE DB include files
#include &lt;oledberr.h&gt;
#include &lt;msdasql.h&gt; 

#define&nbsp; BLOCK_SIZE&nbsp;&nbsp; 250

// Prototypes
HRESULT myInitDSO(IDBInitialize** ppIDBI);
HRESULT mySetInitProps(IDBInitialize*&nbsp; pIDBInitialize);
HRESULT myCommand(IDBInitialize* pIDBI, IRowset** ppIRowset);
void&nbsp; myGetBLOBData(IRowset* pIRowset);
void&nbsp; DumpError(LPSTR lpStr);

IMalloc*&nbsp;&nbsp;&nbsp; g_pIMalloc = NULL;

/********************************************************************
* OLE DB application main()
********************************************************************/
int main()
  {
  IDBInitialize*&nbsp; pIDBInitialize = NULL;
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset = NULL;

  //Init OLE and set up the DLLs.
  CoInitialize(NULL);

  // Get the task memory allocator.
  if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;g_pIMalloc)))
 &nbsp;&nbsp; goto EXIT;

  // Connect to the data source.
  if (FAILED(myInitDSO(&amp;pIDBInitialize)))
 &nbsp;&nbsp; goto EXIT;

  // Get a session, set and execute a command.
  if (FAILED(myCommand(pIDBInitialize, &amp;pIRowset)))
 &nbsp;&nbsp; goto EXIT;

  myGetBLOBData(pIRowset);

EXIT:
  if (pIRowset != NULL)
 &nbsp;&nbsp; pIRowset-&gt;Release();

  if (pIDBInitialize != NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if (FAILED(pIDBInitialize-&gt;Uninitialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Uninitialize is not required, but it will fail if an
 &nbsp;&nbsp; // interface has not been released. We can use it for 
 &nbsp;&nbsp; // debugging.
 &nbsp;&nbsp; DumpError("Someone forgot to release something!");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; pIDBInitialize-&gt;Release();
 &nbsp;&nbsp; }

  if (g_pIMalloc != NULL)
 &nbsp;&nbsp; g_pIMalloc-&gt;Release();

  CoUninitialize();
  
  return (0);
  }


/********************************************************************
* Initialize the data source.
********************************************************************/
HRESULT myInitDSO
  (
  IDBInitialize** ppIDBInitialize   // [out]
  )
  {
  // Create an instance of the MSDASQL (ODBC) provider.
  CoCreateInstance(CLSID_MSDASQL, NULL, CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp; IID_IDBInitialize, (void**)ppIDBInitialize);

  if (*ppIDBInitialize == NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  if (FAILED(mySetInitProps(*ppIDBInitialize)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  if (FAILED((*ppIDBInitialize)-&gt;Initialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("IDBInitialze-&gt;Initialize failed.");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  return (NOERROR);
  }

/********************************************************************
* Set initialization properties on a data source.
********************************************************************/
HRESULT mySetInitProps
  (
  IDBInitialize*&nbsp; pIDBInitialize   // [in]
  )
  {
  const ULONG&nbsp;&nbsp; nProps = 4;
  IDBProperties*&nbsp; pIDBProperties;
  DBPROP&nbsp;&nbsp;&nbsp; InitProperties[nProps];
  DBPROPSET&nbsp;&nbsp; rgInitPropSet;
  HRESULT&nbsp;&nbsp; hr;

  // Initialize common property options.
  for (ULONG i = 0; i &lt; nProps; i++ )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; VariantInit(&amp;InitProperties[i].vValue);
 &nbsp;&nbsp; InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
 &nbsp;&nbsp; InitProperties[i].colid = DB_NULLID;
 &nbsp;&nbsp; }
   
  // Level of prompting that will be done to complete the
  // connection process.
  InitProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
  InitProperties[0].vValue.vt = VT_I2;
  InitProperties[0].vValue.iVal = DBPROMPT_NOPROMPT;    

  // Data source name--see the sample source included with the OLE
  // DB SDK.
  InitProperties[1].dwPropertyID = DBPROP_INIT_DATASOURCE;   
  InitProperties[1].vValue.vt = VT_BSTR;
  InitProperties[1].vValue.bstrVal = 
 &nbsp;&nbsp; SysAllocString(OLESTR("OLE_DB_NWind_Jet"));

  // User ID
  InitProperties[2].dwPropertyID = DBPROP_AUTH_USERID;
  InitProperties[2].vValue.vt = VT_BSTR;
  InitProperties[2].vValue.bstrVal = SysAllocString(OLESTR(""));

  // Password
  InitProperties[3].dwPropertyID = DBPROP_AUTH_PASSWORD;
  InitProperties[3].vValue.vt = VT_BSTR;
  InitProperties[3].vValue.bstrVal = SysAllocString(OLESTR(""));

  rgInitPropSet.guidPropertySet = DBPROPSET_DBINIT;
  rgInitPropSet.cProperties = nProps;
  rgInitPropSet.rgProperties = InitProperties;

  // Set initialization properties.
  pIDBInitialize-&gt;QueryInterface(IID_IDBProperties, (void**) 
 &nbsp; &amp;pIDBProperties);
  hr = pIDBProperties-&gt;SetProperties(1, &amp;rgInitPropSet);

  SysFreeString(InitProperties[1].vValue.bstrVal);
  SysFreeString(InitProperties[2].vValue.bstrVal);
  SysFreeString(InitProperties[3].vValue.bstrVal);

  pIDBProperties-&gt;Release();

  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Set properties failed.");
 &nbsp;&nbsp; }

  return (hr);
  }

/********************************************************************
* Execute a command selecting Notes from Employees.
********************************************************************/
HRESULT myCommand
  (
  IDBInitialize*&nbsp; pIDBInitialize, // [in]
  IRowset**&nbsp;&nbsp; ppIRowset&nbsp;&nbsp; // [out]
  ) 
  {
   IDBCreateSession* pIDBCreateSession;
   IDBCreateCommand* pIDBCreateCommand;
   IRowset*&nbsp;&nbsp;&nbsp; pIRowset;
   ICommandText*&nbsp;&nbsp; pICommandText;
  LPCTSTR&nbsp;&nbsp;&nbsp;&nbsp; wSQLString = OLESTR("SELECT Notes ")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("FROM Employees");
  LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;
  HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;

  // Set for failure.
  *ppIRowset = NULL;

  // Get the DB session object.
  hr = pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession,
 &nbsp;&nbsp; (void**) &amp;pIDBCreateSession);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Session initialization failed.");
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }

  // Create the session.
  hr = pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
  pIDBCreateSession-&gt;Release();
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Create session failed.");
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }

  // Create the command object.
  hr = pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText,
 &nbsp;&nbsp; (IUnknown**) &amp;pICommandText);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Create command failed.");
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }
  pIDBCreateCommand-&gt;Release();

  // The command requires the actual text as well as an indicator
  // of its language and dialect.
   pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLString);

  // Execute the command.
  hr = pICommandText-&gt;Execute(NULL, IID_IRowset, NULL,
 &nbsp; &amp;cRowsAffected, (IUnknown**) &amp;pIRowset);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Command execution failed.");
 &nbsp;&nbsp; }

  pICommandText-&gt;Release();

  *ppIRowset = pIRowset;
  return (hr);
  }

/********************************************************************
* Retrieve data from an ODBC LONG_VARCHAR column (Notes in
* Employees).
********************************************************************/
void myGetBLOBData
  (
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset&nbsp; // [in]
  )
  {
  DBOBJECT&nbsp;&nbsp;&nbsp; ObjectStruct;   // For binding, retrieve an
               // object pointer.
  DBBINDING&nbsp;&nbsp; rgBinding[1];   // Bind a single column.

  IAccessor*&nbsp; pIAccessor = NULL;&nbsp;&nbsp; // Accessor creation
  HACCESSOR&nbsp;&nbsp; hAccessor = NULL;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; ulErrorBinding;
  
  void*&nbsp;&nbsp;&nbsp;&nbsp; pData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bound consumer buffer
  HROW&nbsp;&nbsp;&nbsp; rghRows[1];
  HROW*&nbsp;&nbsp;&nbsp;&nbsp; pRows = &amp;rghRows[0];
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cRows;

  char&nbsp;&nbsp;&nbsp; szNotes[BLOCK_SIZE + 1];// Text data from "Notes"
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cbRead;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Count of bytes read
  
  // Set up the object structure for accessor creation. Ask the
  // provider to return an ISequentialStream interface for reading.
  ObjectStruct.dwFlags = STGM_READ; 
  ObjectStruct.iid = IID_ISequentialStream;

  // Set up the binding struct for the accessor.
  rgBinding[0].iOrdinal = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Only one column
  rgBinding[0].obValue&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Offset to data
  rgBinding[0].obLength = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ignore length 
  rgBinding[0].obStatus = sizeof(IUnknown*);&nbsp; // Offset to status 
  rgBinding[0].pTypeInfo = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
  rgBinding[0].pObject&nbsp; = &amp;ObjectStruct;&nbsp; // Our interface 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // request
  rgBinding[0].pBindExt = NULL;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
  rgBinding[0].dwPart = DBPART_VALUE |&nbsp; // Get both VALUE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPART_STATUS;&nbsp; // and STATUS
                   // parts.
  rgBinding[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
  rgBinding[0].eParamIO = DBPARAMIO_NOTPARAM;
  rgBinding[0].cbMaxLen = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable
  rgBinding[0].dwFlags&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
  rgBinding[0].wType = DBTYPE_IUNKNOWN;&nbsp;&nbsp; // Type 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DBTYPE_IUNKNOWN
  rgBinding[0].bPrecision = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable
  rgBinding[0].bScale = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable

  // Get the accessor interface and create the accessor.
  pIRowset-&gt;QueryInterface(IID_IAccessor, (void**) &amp;pIAccessor);

  if (FAILED(pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 1,
 &nbsp;&nbsp; rgBinding, sizeof(IUnknown*) + sizeof(ULONG), &amp;hAccessor,
 &nbsp;&nbsp; &amp;ulErrorBinding)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("CreateAccessor failed.");
 &nbsp;&nbsp; return;
 &nbsp;&nbsp; }

  // Allocate memory for the returned pointer and the status field. 
  // The first sizeof(IUnknown*) bytes are for the pointer to the 
  // object; the next sizeof(ULONG) bytes are for the status.
  pData = new BYTE[sizeof(IUnknown*) + sizeof(ULONG)];

  while (TRUE)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Get the next row.
 &nbsp;&nbsp; if (FAILED(pIRowset-&gt;GetNextRows(NULL, 0, 1, &amp;cRows, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pRows)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("GetNextRows failed.\n");
 &nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; if (cRows == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Get the row data, the pointer to an ISequentialStream*.
 &nbsp;&nbsp; if (FAILED(pIRowset-&gt;GetData(*pRows, hAccessor, pData)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("GetData failed.\n");
 &nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Read and process BLOCK_SIZE bytes at a time.
 &nbsp;&nbsp; if ((ULONG)((BYTE*)pData)[rgBinding[0].obStatus] == 
 &nbsp;&nbsp;&nbsp;&nbsp; DBSTATUS_S_ISNULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process NULL data.
 &nbsp;&nbsp; printf("&lt;null&gt;");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if ((ULONG)((BYTE*)pData)[rgBinding[0].obStatus] == 
 &nbsp;&nbsp;&nbsp;&nbsp; DBSTATUS_S_OK)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; do
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; (*((ISequentialStream**) pData))-&gt;Read(szNotes, 
 &nbsp;&nbsp;&nbsp;&nbsp; BLOCK_SIZE, &amp;cbRead);
 &nbsp;&nbsp;&nbsp;&nbsp; if (cbRead &gt; 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // process data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szNotes[cbRead] = (char) NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(szNotes);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; while (cbRead &gt;= BLOCK_SIZE);

 &nbsp;&nbsp; (*((ISequentialStream**) pData))-&gt;Release();
 &nbsp;&nbsp; 
 &nbsp;&nbsp; printf("\n\n");
 &nbsp;&nbsp; }

 &nbsp;&nbsp; pIRowset-&gt;ReleaseRows(cRows, pRows, NULL, NULL, NULL);
 &nbsp;&nbsp; }

  // Clean up.
  pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL);
  pIAccessor-&gt;Release();

  delete [] pData;
  }
  
/********************************************************************
* Dump an error to the console.
********************************************************************/
void DumpError(LPSTR lpStr)
  {
  printf(lpStr);
  printf("\n");
  }</code></pre>
<h1>Appendix C</h1>
<p>
The following is a complete source code listing for the example presented in “Data Manipulation.” The example inserts two new rows into the <b>Customers </b>table of the <b>Access Northwind </b>sample database. The database is shipped with the OLE DB SDK and is installed as the ODBC data source <i>OLE_DB_NWind_Jet.</i></p>
<p>
To build the file using Microsoft Visual C++ 4.0 or later:
<ol>
<li>
Create a new console application.<br><br></li>
<li>
Copy the following code to a new .cpp file.<br><br></li>
<li>
Ensure that your build directory settings reference the OLE DB SDK include directory.<br><br></li>
<li>
Alter the build, link settings to include linking to Oledb.lib.</li>
</ol>
<pre><code>/********************************************************************
* Parameterized execution in OLE DB
********************************************************************/
#define UNICODE
#define _UNICODE
#define DBINITCONSTANTS
#define INITGUID

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt; &nbsp; // For offset of macro
#include &lt;cguid.h&gt;  // IID_NULL

#include &lt;oledb.h&gt;  // OLE DB include files
#include &lt;oledberr.h&gt; 
#include &lt;msdaguid.h&gt;
#include &lt;msdasql.h&gt;

// Types--new customer struct
typedef struct tagNEWCUSTOMER
  {
  char&nbsp; acCustomerID[6];
  char&nbsp; acCompanyName[40];
  char&nbsp; acContactName[30];
  char&nbsp; acContactTitle[30];
  char&nbsp; acAddress[60];
  char&nbsp; acCity[15];
  char&nbsp; acRegion[15];
  char&nbsp; acPostalCode[10];
  char&nbsp; acCountry[15];
  char&nbsp; acPhone[24];
  char&nbsp; acFAX[24];
  } NEWCUSTOMER;

// Types--new customer data struct
typedef struct tagNEWCUSTOMERDATA
  {
  PSTR&nbsp;&nbsp;&nbsp; szCustID;
  PSTR&nbsp;&nbsp;&nbsp; szCompanyName;
  PSTR&nbsp;&nbsp;&nbsp; szContactName;
  PSTR&nbsp;&nbsp;&nbsp; szContactTitle;
  PSTR&nbsp;&nbsp;&nbsp; szAddress;
  PSTR&nbsp;&nbsp;&nbsp; szCity;
  PSTR&nbsp;&nbsp;&nbsp; szRegion;
  PSTR&nbsp;&nbsp;&nbsp; szPostalCode;
  PSTR&nbsp;&nbsp;&nbsp; szCountry;
  PSTR&nbsp;&nbsp;&nbsp; szPhone;
  PSTR&nbsp;&nbsp;&nbsp; szFAX;
  } NEWCUSTOMERDATA;

// Prototypes
HRESULT myInitDSO(IDBInitialize** ppIDBI);
HRESULT mySetInitProps(IDBInitialize* pIDBInitialize);
HRESULT myCreateParamAccessor(ICommand* pICmd, HACCESSOR* phAccessor,
 &nbsp;&nbsp; IAccessor** ppIAccessor);
HRESULT myInsertWithParameters(IDBInitialize* pIDBInitialize);
void&nbsp; myDelete(IDBInitialize* pIDBInitialize);
void&nbsp; DumpError(LPSTR lpStr);

IMalloc*&nbsp;&nbsp;&nbsp; g_pIMalloc = NULL;

/********************************************************************
* main()--control flow
********************************************************************/
int main()
  {
  IDBInitialize*&nbsp; pIDBInitialize = NULL;
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset = NULL;
  HRESULT&nbsp;&nbsp; hr;

  // Init OLE and set up the DLLs.
  CoInitialize(NULL);

  // Get the task memory allocator.
  if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;g_pIMalloc)))
 &nbsp;&nbsp; goto EXIT;

  if (FAILED(myInitDSO(&amp;pIDBInitialize)))
 &nbsp;&nbsp; goto EXIT;

  // Execute a prepared statement with parameters.
  if (FAILED(myInsertWithParameters(pIDBInitialize)))
 &nbsp;&nbsp; goto EXIT;

  // Delete rows just added.
  myDelete(pIDBInitialize);

EXIT:
  // Clean up and disconnect.
  if (pIRowset != NULL)
 &nbsp;&nbsp; pIRowset-&gt;Release();

  if (pIDBInitialize != NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; hr = pIDBInitialize-&gt;Uninitialize();
 &nbsp;&nbsp; pIDBInitialize-&gt;Release();
 &nbsp;&nbsp; }

  if (g_pIMalloc != NULL)
 &nbsp;&nbsp; g_pIMalloc-&gt;Release();

  CoUninitialize();
  
  return (0);
  }

/********************************************************************
*&nbsp; Execute a prepared INSERT statement with parameters.
********************************************************************/
HRESULT myInsertWithParameters
  (
  IDBInitialize*&nbsp; pIDBInitialize
  ) 
  {
  IDBCreateSession* pIDBCreateSession;
  IDBCreateCommand* pIDBCreateCommand;
  ICommandText*&nbsp;&nbsp; pICommandText;
  ICommandPrepare*&nbsp; pICommandPrepare;
  ICommandWithParameters* pICmdWithParams;
  IAccessor*&nbsp;&nbsp;&nbsp; pIAccessor;
  WCHAR&nbsp;&nbsp;&nbsp;&nbsp; wSQLString[] = 
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR("insert into Customers (CustomerID, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompanyName, ContactName,")
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" ContactTitle, Address, City, Region, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostalCode, Country,")
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" Phone, Fax)")
 &nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
  DBPARAMS&nbsp;&nbsp;&nbsp; Params;
  long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;
  HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp; hParamAccessor;

  NEWCUSTOMERDATA&nbsp;&nbsp; aNewCustomers[] =
 &nbsp;&nbsp; {
 &nbsp;&nbsp; "YOUME",
 &nbsp;&nbsp; "You and Me Grocers",
 &nbsp;&nbsp; "William Smith",
 &nbsp;&nbsp; "General Manager",
 &nbsp;&nbsp; "383 15th Ave. N.",
 &nbsp;&nbsp; "New York",
 &nbsp;&nbsp; "NY",
 &nbsp;&nbsp; "10018",
 &nbsp;&nbsp; "USA",
 &nbsp;&nbsp; "(212) 555-8847",
 &nbsp;&nbsp; "(212) 555-9988",

 &nbsp;&nbsp; "YORBL",
 &nbsp;&nbsp; "Yorbalinda's",
 &nbsp;&nbsp; "Mary Jones",
 &nbsp;&nbsp; "Owner",
 &nbsp;&nbsp; "22 Sunny Vale Rd.",
 &nbsp;&nbsp; "San Diego",
 &nbsp;&nbsp; "CA",
 &nbsp;&nbsp; "93122",
 &nbsp;&nbsp; "USA",
 &nbsp;&nbsp; "(605) 555-4322",
 &nbsp;&nbsp; "(605) 555-4323"
 &nbsp;&nbsp; };
  NEWCUSTOMER&nbsp;&nbsp; NewCustomer;

  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nParams = 11;
  DBPARAMBINDINFO&nbsp;&nbsp; rgParamBindInfo[] = 
 &nbsp;&nbsp; {
 &nbsp;&nbsp; OLESTR("DBTYPE_CHAR"),&nbsp; OLESTR("CustomerID"),&nbsp; 5, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("CompanyName"),&nbsp; 40, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("ContactName"),&nbsp; 30, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("ContactTitle"), 30, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Address"),&nbsp; 60, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("City"),&nbsp;&nbsp; 15, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Region"),&nbsp;&nbsp; 15, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("PostalCode"), 10, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Country"),&nbsp; 15, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Phone"),&nbsp;&nbsp;&nbsp; 24, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("FAX"),&nbsp;&nbsp;&nbsp; 24, 
 &nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp; };
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; rgParamOrdinals[] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {1,2,3,4,5,6,7,8,9,10,11};
  // Get the session.
  pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession, 
 &nbsp;&nbsp; (void**)&amp;pIDBCreateSession);
  pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
  pIDBCreateSession-&gt;Release();

  // Create the command.
  pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText, 
 &nbsp;&nbsp; (IUnknown**) &amp;pICommandText);
  pIDBCreateCommand-&gt;Release();

  // The command requires the actual text as well as an indicator
  // of its language.
  pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLString);

  // Set parameter information.
  pICommandText-&gt;QueryInterface(IID_ICommandWithParameters, 
 &nbsp;&nbsp; (void**)&amp;pICmdWithParams);
  pICmdWithParams-&gt;SetParameterInfo(nParams, rgParamOrdinals, 
 &nbsp;&nbsp; rgParamBindInfo);
  pICmdWithParams-&gt;Release();

  // Prepare the command.
  pICommandText-&gt;QueryInterface(IID_ICommandPrepare, (void**)&amp;pICommandPrepare);
  if (FAILED(pICommandPrepare-&gt;Prepare(0)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pICommandPrepare-&gt;Release();
 &nbsp;&nbsp; pICommandText-&gt;Release();
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }
  pICommandPrepare-&gt;Release();

  // Create parameter accessors.
  if (FAILED(myCreateParamAccessor(pICommandText, &amp;hParamAccessor, 
 &nbsp;&nbsp; &amp;pIAccessor)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pICommandText-&gt;Release();
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  Params.pData = &amp;NewCustomer; // pData is the buffer pointer
  Params.cParamSets = 1;&nbsp;&nbsp; // Number of sets of parameters
  Params.hAccessor = hParamAccessor; // Accessor to the parameters

  // Specify the parameter information.
  for (UINT nCust = 0; nCust &lt; 2; nCust++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; strcpy(NewCustomer.acCustomerID, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCustID);
 &nbsp;&nbsp; strcpy(NewCustomer.acCompanyName, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCompanyName);
 &nbsp;&nbsp; strcpy(NewCustomer.acContactName, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szContactName);
 &nbsp;&nbsp; strcpy(NewCustomer.acContactTitle, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szContactTitle);
 &nbsp;&nbsp; strcpy(NewCustomer.acAddress, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szAddress);
 &nbsp;&nbsp; strcpy(NewCustomer.acCity, aNewCustomers[nCust].szCity);
 &nbsp;&nbsp; strcpy(NewCustomer.acRegion, aNewCustomers[nCust].szRegion);
 &nbsp;&nbsp; strcpy(NewCustomer.acPostalCode, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szPostalCode);
 &nbsp;&nbsp; strcpy(NewCustomer.acCountry, 
 &nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCountry);
 &nbsp;&nbsp; strcpy(NewCustomer.acPhone, aNewCustomers[nCust].szPhone);
 &nbsp;&nbsp; strcpy(NewCustomer.acFAX, aNewCustomers[nCust].szFAX);

 &nbsp;&nbsp; // Execute the command.
 &nbsp;&nbsp; pICommandText-&gt;Execute(NULL, IID_NULL, &amp;Params, 
 &nbsp;&nbsp;&nbsp; &amp;cRowsAffected, NULL);
 &nbsp;&nbsp; printf("%ld rows inserted.\n", cRowsAffected);
 &nbsp;&nbsp; }

  pIAccessor-&gt;ReleaseAccessor(hParamAccessor, NULL);
  pIAccessor-&gt;Release();
  pICommandText-&gt;Release();

  return (NOERROR);
  }

/********************************************************************
*&nbsp; Delete rows just added using simple execution.
********************************************************************/
void myDelete
  (
  IDBInitialize*&nbsp; pIDBInitialize
  ) 
  {
  IDBCreateSession* pIDBCreateSession;
  IDBCreateCommand* pIDBCreateCommand;
  ICommandText*&nbsp;&nbsp; pICommandText;
  WCHAR&nbsp;&nbsp;&nbsp;&nbsp; wSQLDelete1[] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("delete from Customers where CustomerID = 'YOYOM'");
  WCHAR&nbsp;&nbsp;&nbsp;&nbsp; wSQLDelete2[] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("delete from Customers where CustomerID = 'YORBL'");
  long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;


  // Get the session.
  pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession, (void**)&amp;pIDBCreateSession);
  pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
  pIDBCreateSession-&gt;Release();

  // Create the command.
  pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText, (IUnknown**) &amp;pICommandText);
  pIDBCreateCommand-&gt;Release();

  // Set the command text for first delete statement and execute
  // the command.
  pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLDelete1);
  pICommandText-&gt;Execute(NULL, IID_NULL, NULL, &amp;cRowsAffected, NULL);

  printf("%ld rows deleted.\n", cRowsAffected);

  // Do it again.
  pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLDelete2);
  pICommandText-&gt;Execute(NULL, IID_NULL, NULL, &amp;cRowsAffected, NULL);

  printf("%ld rows deleted.\n", cRowsAffected);

  pICommandText-&gt;Release();

  return;
  }

/********************************************************************
*&nbsp; Create parameter accessor.
********************************************************************/
HRESULT myCreateParamAccessor
  (
  ICommand* pICmd,&nbsp; // [in]
  HACCESSOR*&nbsp; phAccessor, // [out]
  IAccessor** ppIAccessor // [out]
  )
  {
  IAccessor*&nbsp; pIAccessor;
  HACCESSOR&nbsp;&nbsp; hAccessor;
  const ULONG&nbsp;&nbsp; nParams = 11;
  DBBINDING&nbsp;&nbsp; Bindings[nParams];
  DBBINDSTATUS&nbsp; rgStatus[nParams]; // Returns information for
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // individual binding
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // validity.
  HRESULT&nbsp;&nbsp; hr;

  ULONG&nbsp;&nbsp;&nbsp;&nbsp; acbLengths[] = {5, 40, 30, 30, 60, 15, 15, 10, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, 24, 24};

  for (ULONG i = 0; i &lt; nParams; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; Bindings[i].iOrdinal = i + 1;
 &nbsp;&nbsp; Bindings[i].obLength = 0;
 &nbsp;&nbsp; Bindings[i].obStatus = 0;
 &nbsp;&nbsp; Bindings[i].pTypeInfo = NULL;
 &nbsp;&nbsp; Bindings[i].pObject = NULL;
 &nbsp;&nbsp; Bindings[i].pBindExt = NULL;
 &nbsp;&nbsp; Bindings[i].dwPart = DBPART_VALUE;
 &nbsp;&nbsp; Bindings[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 &nbsp;&nbsp; Bindings[i].eParamIO = DBPARAMIO_INPUT;
 &nbsp;&nbsp; Bindings[i].cbMaxLen = acbLengths[i];
 &nbsp;&nbsp; Bindings[i].dwFlags = 0;
 &nbsp;&nbsp; Bindings[i].wType = DBTYPE_STR;
 &nbsp;&nbsp; Bindings[i].bPrecision = 0;
 &nbsp;&nbsp; Bindings[i].bScale = 0;
 &nbsp;&nbsp; }

  Bindings[0].obValue = offsetof(NEWCUSTOMER, acCustomerID);
  Bindings[1].obValue = offsetof(NEWCUSTOMER, acCompanyName);
  Bindings[2].obValue = offsetof(NEWCUSTOMER, acContactName);
  Bindings[3].obValue = offsetof(NEWCUSTOMER, acContactTitle);
  Bindings[4].obValue = offsetof(NEWCUSTOMER, acAddress);
  Bindings[5].obValue = offsetof(NEWCUSTOMER, acCity);
  Bindings[6].obValue = offsetof(NEWCUSTOMER, acRegion);
  Bindings[7].obValue = offsetof(NEWCUSTOMER, acPostalCode);
  Bindings[8].obValue = offsetof(NEWCUSTOMER, acCountry);
  Bindings[9].obValue = offsetof(NEWCUSTOMER, acPhone);
  Bindings[10].obValue = offsetof(NEWCUSTOMER, acFAX);

  pICmd-&gt;QueryInterface(IID_IAccessor, (void**)&amp;pIAccessor);

  hr = pIAccessor-&gt;CreateAccessor(
 &nbsp;&nbsp; DBACCESSOR_PARAMETERDATA,   // Accessor that will be used
               // to specify parameter data
 &nbsp;&nbsp; nParams,         // Number of parameters being
               // bound
 &nbsp;&nbsp; Bindings,         // Structure containing bind
               // information
 &nbsp;&nbsp; sizeof(NEWCUSTOMER),      // Size of parameter structure
 &nbsp;&nbsp; &amp;hAccessor,         // Returned accessor handle
 &nbsp;&nbsp; rgStatus         // Information about binding
               // validity
 &nbsp;&nbsp; );

  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Parameter accessor creation failed.");
 &nbsp;&nbsp; }
  else
 &nbsp;&nbsp; {
 &nbsp;&nbsp; *ppIAccessor = pIAccessor;
 &nbsp;&nbsp; *phAccessor = hAccessor;
 &nbsp;&nbsp; }

  return (hr);
  }

/********************************************************************
* Initialize the Data Source.
********************************************************************/
HRESULT myInitDSO
  (
  IDBInitialize** ppIDBInitialize // [out]
  )
  {
  // Create an instance of the MSDASQL (ODBC) provider.
  CoCreateInstance(CLSID_MSDASQL, NULL, CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp; IID_IDBInitialize, (void**)ppIDBInitialize);

  if (*ppIDBInitialize == NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  if (FAILED(mySetInitProps(*ppIDBInitialize)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  if (FAILED((*ppIDBInitialize)-&gt;Initialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("IDBInitialze-&gt;Initialize failed.");
 &nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp; }

  return (NOERROR);
  }

/********************************************************************
* Set initialization properties on a data source.
*********************************************************************
HRESULT mySetInitProps
  (
  IDBInitialize*&nbsp; pIDBInitialize&nbsp; // [in]
  )
  {
  const ULONG&nbsp;&nbsp; nProps = 4;
  IDBProperties*&nbsp; pIDBProperties;
  DBPROP&nbsp;&nbsp;&nbsp; InitProperties[nProps];
  DBPROPSET&nbsp;&nbsp; rgInitPropSet;
  HRESULT&nbsp;&nbsp; hr;

  // Initialize common property options.
  for (ULONG i = 0; i &lt; nProps; i++ )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; VariantInit(&amp;InitProperties[i].vValue);
 &nbsp;&nbsp; InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
 &nbsp;&nbsp; InitProperties[i].colid = DB_NULLID;
 &nbsp;&nbsp; }

  // Level of prompting that will be done to complete the 
  // connection process.
  InitProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
  InitProperties[0].vValue.vt = VT_I2;
  InitProperties[0].vValue.iVal = DBPROMPT_NOPROMPT; 

  // Data source name--see the sample source included with the OLE
  // DB SDK.
  InitProperties[1].dwPropertyID = DBPROP_INIT_DATASOURCE;
  InitProperties[1].vValue.vt = VT_BSTR;
  InitProperties[1].vValue.bstrVal =
 &nbsp;&nbsp; SysAllocString(OLESTR("OLE_DB_NWind_Jet"));

  // User ID
  InitProperties[2].dwPropertyID = DBPROP_AUTH_USERID;
  InitProperties[2].vValue.vt = VT_BSTR;
  InitProperties[2].vValue.bstrVal = SysAllocString(OLESTR(""));

  // Password
  InitProperties[3].dwPropertyID = DBPROP_AUTH_PASSWORD;
  InitProperties[3].vValue.vt = VT_BSTR;
  InitProperties[3].vValue.bstrVal = SysAllocString(OLESTR(""));

  rgInitPropSet.guidPropertySet = DBPROPSET_DBINIT;
  rgInitPropSet.cProperties = nProps;
  rgInitPropSet.rgProperties = InitProperties;

  // Set initialization properties.
  pIDBInitialize-&gt;QueryInterface(IID_IDBProperties, (void**) 
 &nbsp;&nbsp; &amp;pIDBProperties);
  hr = pIDBProperties-&gt;SetProperties(1, &amp;rgInitPropSet);

  SysFreeString(InitProperties[1].vValue.bstrVal);
  SysFreeString(InitProperties[2].vValue.bstrVal);
  SysFreeString(InitProperties[3].vValue.bstrVal);

  pIDBProperties-&gt;Release();

  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError("Set properties failed.");
 &nbsp;&nbsp; }

  return (hr);
  }

/********************************************************************
* Dump an error to the console.
********************************************************************/
void DumpError(LPSTR lpStr)
  {
  printf(lpStr);
  printf("\n");
  }</code></pre>
</font></BODY>
</HTML>
