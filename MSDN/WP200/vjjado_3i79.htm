<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Event Handling Sample</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="vjhoweventhandlingsample"></a>Event Handling Sample</h1>
<p>
This sample introduces the powerful new event handling architecture based on delegates for the Virtual Machine (VM) for Java. The delegate event model is a replacement for the JavaBean model and is not compatible with it. The two styles should not be intermixed in application code. This is a large sample that delineates all of the ADO/WFC Recordset events that can be registered for callback by Java application developers.</p>
<pre><code>public class DemoFramework 
{
 &nbsp; Recordset recordSet;

 &nbsp; RecordsetEventHandler handler = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onWillMove");
 &nbsp; RecordsetEventHandler handler2 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onWillMove2");
 &nbsp; RecordsetEventHandler handler3 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onMoveComplete");
 &nbsp; RecordsetEventHandler handler4 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onEndOfRecordset");
 &nbsp; RecordsetEventHandler handler5 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onWillChangeField");
 &nbsp; RecordsetEventHandler handler6 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onFieldChangeComplete");

 &nbsp; public void addEventListeners()
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.addWillMoveHandler(handler);
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.addWillMoveHandler(handler2);
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.addMoveCompleteHandler(handler3);
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.addEndOfRecordsetHandler(handler4);
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.addWillChangeFieldHandler(handler5);
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.addFieldChangeCompleteHandler(handler6);
 &nbsp; }

 &nbsp; public void removeEventListeners()
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.removeWillMoveHandler(handler);
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.removeWillMoveHandler(handler2);
 &nbsp; }

 &nbsp; public void onEndOfRecordset(RecordsetEvent e)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("onEndOfRecordset:" + e);
 &nbsp; }

 &nbsp; public void onMoveComplete(RecordsetEvent e)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("onMoveComplete:" + e);
 &nbsp; }

 &nbsp; public void onWillMove(RecordsetEvent e)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("onWillMove:" + e);
 &nbsp; }

 &nbsp; public void onWillMove2(RecordsetEvent e)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("onWillMove2:" + e);
 &nbsp; }

 &nbsp; public void onWillChangeField(RecordsetEvent e)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("onWillChangeField:" + e);
 &nbsp; }

 &nbsp; public void onFieldChangeComplete(RecordsetEvent e)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("onFieldChangeComplete:" + e);
 &nbsp; }

 &nbsp; 
 &nbsp; void FieldChange()
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recordSet.getFields().getItem("au_lname").setString("someWeirdValue");
 &nbsp;&nbsp;&nbsp;&nbsp; } catch (Throwable t)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.printStackTrace();
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }

 &nbsp; public Recordset getRecordset(String strConnection, String strSQL)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; Recordset rs;
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; rs = new Recordset();
 &nbsp;&nbsp;&nbsp;&nbsp; rs.setCursorLocation(AdoEnums.adUseClient);
 &nbsp;&nbsp;&nbsp;&nbsp; rs.setLockType (AdoEnums.adLockBatchOptimistic);
 &nbsp;&nbsp;&nbsp;&nbsp; rs.setCacheSize (10);
 &nbsp;&nbsp;&nbsp;&nbsp; rs.setMaxRecords (1000);
 &nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; rs.open(strSQL, strConnection);
 &nbsp;&nbsp;&nbsp;&nbsp; rs.moveLast();
 &nbsp;&nbsp;&nbsp;&nbsp; rs.moveFirst();
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet = rs;

 &nbsp;&nbsp;&nbsp;&nbsp; return rs;
 &nbsp; }

 &nbsp; public void ScrollForward()
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.moveFirst();

 &nbsp;&nbsp;&nbsp;&nbsp; int lRows = 0;
 &nbsp;&nbsp;&nbsp;&nbsp; while (!recordSet.getEOF())
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lRows++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recordSet.moveNext();
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; 
 &nbsp; public boolean run()
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; String query = "select * from authors";
 &nbsp;&nbsp;&nbsp;&nbsp; String connection = "dsn=aDSN;database=pubs";

 &nbsp;&nbsp;&nbsp;&nbsp; boolean case1 = false, case2 = false, case0 = false;
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet = getRecordset(connection,query);

 &nbsp;&nbsp;&nbsp;&nbsp; addEventListeners();
 &nbsp;&nbsp;&nbsp;&nbsp; FieldChange();
 &nbsp;&nbsp;&nbsp;&nbsp; ScrollForward();
 &nbsp;&nbsp;&nbsp;&nbsp; removeEventListeners();

 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.close();
 &nbsp;&nbsp;&nbsp;&nbsp; recordSet.release();

 &nbsp;&nbsp;&nbsp;&nbsp; return true;
 &nbsp; }

 &nbsp; public static void main(String args[])
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; new DemoFramework().run();
 &nbsp; }
}
</code></pre>
<p>
A delegate can be thought of as a Java callback pointer (or function pointer). An event listener can arrange to be called back on any method it has. Delegates in ADO/WFC are wrapped within the &lt;<i>type</i>&gt;EventHandler classes. There is one EventHandler for each of the three main types of event-generating ADO components: RecordsetEventHandler, ConnectionEventHandler, and CommandEventHandler. The following code creates six RecordsetEventHandler delegates:</p>
<pre><code>&nbsp;&nbsp;&nbsp;RecordsetEventHandler handler = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onWillMove");
 &nbsp; RecordsetEventHandler handler2 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onWillMove2");
 &nbsp; RecordsetEventHandler handler3 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onMoveComplete");
 &nbsp; RecordsetEventHandler handler4 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onEndOfRecordset");
 &nbsp; RecordsetEventHandler handler5 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onWillChangeField");
 &nbsp; RecordsetEventHandler handler6 = 
 &nbsp;&nbsp;&nbsp;&nbsp; new RecordsetEventHandler(this,"onFieldChangeComplete");
</code></pre>
<p>
Each of the second parameters to the RecordsetEventHandler constructor statements above designate one of the possible Recordset object events, or conditions, that the Recordset can enter while manipulated within an application context. This sample is set up to listen to all of the events. Typically, a Java component may only be interested in a subset of that total; for example, a business object may be designed for validating any field changes in a form, but is disinterested in currency change notifications. </p>
<p>
Note that events are comprised of before (“will”) and after (“complete”) pairs of events. Listeners that want to be able to react to an event before it happens, with the opportunity to reverse the event, typically register for the “will” events. The following code shows how to add event listeners to the source object:</p>
<pre><code>recordSet.addWillChangeFieldHandler(handler);
recordSet.addFieldChangeCompleteHandler(handler2);
</code></pre>
<p>
Once an event listener is registered, the method specified in the RecordsetEventHandler will be invoked every time an event of the specified type occurs within the object. To show how an event is triggered, examine the <code>FieldChange</code> method. The DemoFramework class registers itself (using the <code>this</code> reference) to receive both the before (“will”) and after (“complete”) events. The <code>FieldChange</code> method, called during the <code>run</code> method, then triggers the event propagation:</p>
<pre><code>void FieldChange()
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recordSet.getFields().getItem("au_lname").setString("someWeirdValue");
 &nbsp;&nbsp;&nbsp;&nbsp; } catch (Throwable t)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.printStackTrace();
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
</code></pre>
<p>
Accessing the Field value triggers the event propagation mechanism. The <code>WillChangeFieldHandler</code> routine receives the event first, and outputs a simple console message acknowledging receipt. Then, the <code>FieldChangeCompleteHandler</code> routine receives the event, and also outputs a simple console message. Of course, the behavior of the two event handling methods could have been much more elaborate; for example, throwing a CancelChangeException to roll back the proposed change. (This is equivalent to the VetoableEventListener concept of JavaBeans, but without the immense overhead of the JavaBean model.) </p>
<p>
Familiarizing yourself with this new approach to event notifications and callback methods is a requisite for successful ADO/WFC programming in the component assembly paradigm. Classical, non-event-driven applications are still feasible without the delegate model, but most modern form-based UI applications stand to be improved through assimilation of this new event model. </p>
</font></BODY>
</HTML>
