<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ODBC 3.7 Visual Studio Analyzer Events</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcvistaevents"></a>ODBC 3.7 Visual Studio Analyzer Events</h1>
<p>
ODBC 3.70 will fire both stock and custom events to Visual Studio™ Analyzer to provide the client with performance and debugging information about the ODBC 3.7 layer. All Visual Studio Analyzer outbound events will be fired at the top-level interface so that developers will get as accurate a picture as possible regarding time spent in ODBC components vs. ADO and OLE DB components.</p>
<h1>Registration</h1>
<p>
Visual Studio Analyzer provides a COM method, <b>ISystemDebugEventFire::IsActive</b>, to let an event source find out if there is any event collector listening. This minimizes the overhead to an “if” checking and a function call. However, to call method <b>IsActive</b>, <b>CoInitialize</b> and <b>CoCreateInstance</b> are called first. Some ODBC applications do not use OLE, and in order not to slow the load of ODBC to these applications, Visual Studio Analyzer Events can be enabled/disabled from within the ODBC Administrator. That way OLE and Visual Studio Analyzer are initialized when ODBC is loaded only if it has been enabled.</p>
<p>
Visual Studio Analyzer requires any Visual Studio Analyzer Event source to register when the source is set up. There are two ways to register the ODBC Visual Studio Analyzer Event source. One is to call <b>ISystemDebugEventInstall::RegisterSource</b>, <b>RegisterStockEvent</b>, and <b>RegisterCustomEvent</b>, etc. in <b>SQLInstallDriverManager</b>. Another approach is for the user to enable/disable Visual Studio Analyzer Event in the ODBC Control Panel. The first approach has the benefit of only registering once on a machine. However, the setups of some programs are already very complicated and those applications may not find it necessary to view Visual Studio Analyzer events. Therefore, by using the ODBC Administrator, registration is deferred until a user enables Visual Studio Analyzer.</p>
<h1>Categories</h1>
<p>
ODBC will fire the events in following categories:</p>
<p>
DEBUG_EVENT_CATEGORY_STARTSTOP,</p>
<p>
DEBUG_EVENT_CATEGORY_CALLRETURN,</p>
<p>
DEBUG_EVENT_CATEGORY_QUERYRESULT,</p>
<p>
DEBUG_EVENT_CATEGORY_TRANSACTION</p>
<p>
In addition to the stock categories provided by Visual Studio Analyzer, ODBC 3.7 will add the following:</p>
<p>
DEBUG_EVENT_CATEGORY_CONNECTION</p>
<h1>ODBC 3.7 Visual Studio Analyzer Events by Handle</h1>
<h1>No Handle</h1>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=597>
<tr valign=top>
<td class=label width=14%><b>Category</b></td>
<td class=label width=14%><b>Type</b></td>
<td class=label width=16%><b>Event</b></td>
<td class=label width=56%><b>Fired When</b></td>
</tr>
<tr valign=top>
<td width=14%>startstop</td>
<td width=14%>Generic</td>
<td width=16%>STRART</td>
<td width=56%>When ODBC32.DLL is loaded</td>
</tr>
<tr valign=top>
<td width=14%>startstop</td>
<td width=14%>Generic</td>
<td width=16%>STOP</td>
<td width=56%>When ODBC32.DLL is unloaded</td>
</tr>
</table><br>
<h1>Connection</h1>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=666>
<tr valign=top>
<td class=label width=13%><b>Category</b></td>
<td class=label width=13%><b>Type</b></td>
<td class=label width=13%><b>Event</b></td>
<td class=label width=61%><b>Fired When</b></td>
</tr>
<tr valign=top>
<td width=13%>transaction</td>
<td width=13%>Generic</td>
<td width=13%>start</td>
<td width=61%>SQLSetConnectAttr(…SQL_ATTR_ENLIST_IN_DTC)</td>
</tr>
<tr valign=top>
<td width=13%>transaction</td>
<td width=13%>Generic</td>
<td width=13%>start</td>
<td width=61%>Any function call on an HDBC (or hstmt under this HDBC) after a call to SQLEndTran when SQL_ATTR_AUTOCOMMIT is set to SQL_AUTOCOMMIT_OFF. The overhead might be too high. We may want to fire the event after SQLEndTran returns from the driver.</td>
</tr>
<tr valign=top>
<td width=13%>transaction</td>
<td width=13%>Generic</td>
<td width=13%>commit</td>
<td width=61%>SQLEndTran(…SQL_COMMIT)</td>
</tr>
<tr valign=top>
<td width=13%>transaction</td>
<td width=13%>Generic</td>
<td width=13%>rollback</td>
<td width=61%>SQLEndTran(…SQL_ROLLBACK)</td>
</tr>
<tr valign=top>
<td width=13%>callreturn</td>
<td width=13%>Outbound</td>
<td width=13%>Enter</td>
<td width=61%>At the entrance of SQLConnect/SQLDriverConnect</td>
</tr>
<tr valign=top>
<td width=13%>callreturn</td>
<td width=13%>Inbound</td>
<td width=13%>Leave_Normal (Exception)</td>
<td width=61%>At the exit of SQLConnect/SQLDriverConnect if succeeds (or fails)</td>
</tr>
<tr valign=top>
<td width=13%>connection</td>
<td width=13%>Outbound</td>
<td width=13%>Open</td>
<td width=61%>Before call driver’s SQLConnect/SQLDriverConnect </td>
</tr>
<tr valign=top>
<td width=13%>connection</td>
<td width=13%>Inbound</td>
<td width=13%>Open</td>
<td width=61%>After driver’s SQLConnect/SQLDriverConnect returns</td>
</tr>
<tr valign=top>
<td width=13%>callreturn</td>
<td width=13%>Outbound</td>
<td width=13%>Enter</td>
<td width=61%>At the entrace of SQLDisconnect</td>
</tr>
<tr valign=top>
<td width=13%>Callreturn</td>
<td width=13%>Inbound</td>
<td width=13%>Leave_Normal (Exception)</td>
<td width=61%>At the exit of SQLDisconnect if succeeds (or fails)</td>
</tr>
<tr valign=top>
<td width=13%>Connection</td>
<td width=13%>Outbound</td>
<td width=13%>Close</td>
<td width=61%>Before call driver’s SQLDisconnect</td>
</tr>
<tr valign=top>
<td width=13%>connection</td>
<td width=13%>Inbound</td>
<td width=13%>close</td>
<td width=61%>After return from driver’s SQLDisconnect</td>
</tr>
</table><br>
<h1>Statement</h1>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=665>
<tr valign=top>
<td class=label width=13%><b>Category</b></td>
<td class=label width=12%><b>Type</b></td>
<td class=label width=14%><b>Event</b></td>
<td class=label width=61%><b>Fired When</b></td>
</tr>
<tr valign=top>
<td width=13%>queryresult</td>
<td width=12%>outbound</td>
<td width=14%>Querysend</td>
<td width=61%>Before the call of driver’s SQLExecute/SQLExecDirect</td>
</tr>
<tr valign=top>
<td width=13%>queryresult</td>
<td width=12%>inbound</td>
<td width=14%>Queryresult</td>
<td width=61%>After driver’s SQLExecute/SQLExecDirect return</td>
</tr>
<tr valign=top>
<td width=13%>callreturn</td>
<td width=12%>outbound</td>
<td width=14%>Enter</td>
<td width=61%>At enter of&nbsp; SQLPrepare, SQLExecute, SQLExecDirect, SQLFetch, SQLExtendedFetch, SQLFetchScroll, SQLMoreResults, SQLGetData, SQLCancel, SQLTables, SQLColumns, SQLProcedures, SQLGetTypeInfo, SQLProcedureColumns, SQLSpecialColumns, SQLTablePrivileges, SQLSetPos, SQLPutData, SQLBulkOperations, SQLSpecialColumns, SQLColumnPrivileges, SQLForeignKeys, SQLStatistics</td>
</tr>
<tr valign=top>
<td width=13%>callreturn</td>
<td width=12%>inbound</td>
<td width=14%>Leave_Normal (or exception)</td>
<td width=61%>At exit of SQLPrepare, SQLExecute, SQLExecDirect, SQLFetch, SQLExtendedFetch, SQLFetchScroll, SQLMoreResults, SQLGetData, SQLCancel, SQLTables, SQLColumns, SQLProcedures, SQLGetTypeInfo, SQLProcedureColumns, SQLSpecialColumns, SQLTablePrivileges, SQLSetPos, SQLPutData, SQLBulkOperations, SQLSpecialColumns, SQLColumnPrivileges, SQLForeignKeys, SQLStatistics</td>
</tr>
</table><br>
<h1>Visual Studio Analyzer Events Fired by ODBC 3.7</h1>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=576>
<tr valign=top>
<td class=label width=33%><b>Event</b></td>
<td class=label width=19%><b>Type</b></td>
<td class=label width=48%><b>Args (prgKeys)</b></td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=578>
<tr valign=top>
<td width=33%>query_result</td>
<td width=19%>inbound</td>
<td width=48%>BSTR SQLText,<p>
VARIANT_BOOL fAsync</p>
</td>
</tr>
<tr valign=top>
<td width=33%>query_send</td>
<td width=19%>outbound</td>
<td width=48%>BSTR SQLText<p>
VARIANT_BOOL fAsync</p>
</td>
</tr>
<tr valign=top>
<td width=33%>call enter</td>
<td width=19%>outbound</td>
<td width=48%>the input arguments</td>
</tr>
<tr valign=top>
<td width=33%>return_normal</td>
<td width=19%>inbound</td>
<td width=48%>the output arguments</td>
</tr>
<tr valign=top>
<td width=33%>return_exception</td>
<td width=19%>inbound</td>
<td width=48%>HRESULT hrException</td>
</tr>
<tr valign=top>
<td width=33%>connection_open*</td>
<td width=19%>outbound</td>
<td width=48%>BSTR ConnectString,<p>
BSTR UserId,</p>
<p>
BSTR Password</p>
</td>
</tr>
<tr valign=top>
<td width=33%>connection_close*</td>
<td width=19%>outbound</td>
<td width=48%></td>
</tr>
</table><br>
<p>
* indicates a custom event</p>
</font></BODY>
</HTML>
