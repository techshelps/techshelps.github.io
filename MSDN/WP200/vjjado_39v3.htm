<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Asynchronous Command Execution Sample</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="vjhowasynchronouscommandexecutionscenario"></a>Asynchronous Command Execution Sample</h1>
<p>
This sample demonstrates a convenient feature of ADO/WFC: the ability to asynchronously execute commands and populate large Recordsets on background threads. This sample extends the <a href="vjjado_8lph.htm">framework code</a> by spawning a thread and using an event listener to catch the “population complete” event. </p>
<pre><code>// This import statement is required for the
// delegate event callback class definition. 
import com.ms.lang.*;

... // framework code 

boolean done = false;
boolean execOK = false;

// Implement an event handling routine to
// catch the Recordset “population completion” 
// event from the population thread. 
public synchronized void onExecuteComplete(ConnectionEvent e)
{
 &nbsp; done = true;
 &nbsp; notify();
}

Recordset rs;
Command cmd;

public synchronized boolean run()
{
 &nbsp; execOK = false;
 &nbsp; 
 &nbsp; Connection c = new Connection();
 &nbsp; c.setCursorLocation (AdoEnums.adUseClientBatch);
 &nbsp; c.open ("dsn=aDSN", "aName", "aPWD");
 &nbsp; 
 &nbsp; // Establish a callback handler for the execute complete 
 &nbsp; // event and add it to the Connection object. 
 &nbsp; ConnectionEventHandler handler = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ConnectionEventHandler(this, "onExecuteComplete");
 &nbsp; c.addExecuteCompleteHandler(handler);

 &nbsp; cmd = new Command();
 &nbsp; cmd.setActiveConnection (c);
 &nbsp; cmd.setCommandText ("select * from authors");

 &nbsp; Runnable asyncExecute = new Runnable() {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; public void run() {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs = cmd.execute(null,AdoEnums.adRunAsync);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (DemoAsyncCommand.this) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done = true;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execOK = false;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DemoAsyncCommand.this.notify();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; };

 &nbsp; new Thread(asyncExecute,"RunAsync").start();
 &nbsp; execOK = true;
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; while (!done)
 &nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait();
 &nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execOK = false;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; if (execOK)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; rs.moveFirst();
 &nbsp;&nbsp;&nbsp;&nbsp; rs.moveLast();
 &nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; rs.close();
 &nbsp;&nbsp;&nbsp;&nbsp; c.close();
 &nbsp;&nbsp;&nbsp;&nbsp; return true;
 &nbsp; } else 
 &nbsp;&nbsp;&nbsp;&nbsp; return false;
}
</code></pre>
<p>
The first set of initialization code establishes the event handling “listener” for the Connection “execute complete” event — an event fired when the Command associated with the Connection finishes executing. A method, <code>onExecuteComplete(ConnectionEvent e)</code>, is defined within the sample class, which implicitly triggers the <code>notify</code> method. The following code is a standard delegate-based event registration call sequence:</p>
<pre><code>ConnectionEventHandler handler = new ConnectionEventHandler(this,"onExecuteComplete");
c.addExecuteCompleteHandler(handler);
</code></pre>
<p>
This event model diverges sharply from the JavaBean EventSource-EventAdpater-EventListener model that ships with the JDK 1.1. The Delegate class is a member of the com.ms.lang package, and should be imported into applications that rely on event handling between components on Win32 platforms. ADO/WFC components do not support the JDK 1.02 or JavaBean event models. The Command code is basically identical to the code in the <a href="vjjado_5g33.htm">Command sample</a>, without the parametric aspect. </p>
<p>
Note that the <code>run</code> method is prefixed with the Java access modifier, <code>synchronized</code>. This denotes that only one active thread may be running in the method body at any given time, ensuring that race conditions do not occur. The lines that define a new Runnable object are worth examining, since this is where the execution thread is being defined. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The Runnable interface is implemented by classes that want to operate as threaded objects, but do not want to subclass java.lang.Thread. The Runnable interface has only one method: the entry point <code>run</code>, which is invoked by the thread scheduler to start the threaded object.</p>
<pre><code>Runnable asyncExecute = new Runnable() {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; public void run() {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs = cmd.execute(null,AdoEnums.adRunAsync);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (DemoAsyncCommand.this) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done = true;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execOK = false;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DemoAsyncCommand.this.notify();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; };
</code></pre>
<p>
This code instantiates an anonymous Runnable object with one defined method, <code>run</code>. The body of the <code>run</code> method performs the <code>cmd.execute(null, AdoEnums.adRunAsync).</code> This segment of code only prepares the thread object to run; the object must be “started” through the following call sequence:</p>
<pre><code>new Thread(asyncExecute,"RunAsync").start();
</code></pre>
<p>
This starts the Command execution, which will perform in asynchronous mode. The Thread constructor used in the sample takes, as parameters, a Runnable instance and a “thread name.” (In this sample, “RunAsync” is the name associated with the thread.) The new thread will begin executing the method body of the <code>asyncExecute</code> object. The first code line is a Command object executing the current command string (“select * from author”) in asynchronous mode, specified by the constant parameter passed to the method. Had no constant been passed to the <code>execute</code> method, the command would have executed in synchronous mode. The ADO and OLE DB components that run underneath the covers of ADO/WFC are free-threaded objects and need to be configured just like their Java counterparts.</p>
<p>
While the command-execute thread runs in the background, the foreground thread enters a wait loop until notified, through the callback on the OnExecuteComplete event handler, that the command has finished executing. Once the event is fired from the background thread, the boolean variable <code>done</code> is set to true and the main thread can proceed to the task of navigating through the Recordset.</p>
<p>
This sample is for slightly more advanced users. It is not necessary to run ADO/WFC with explicit multi-threading, but there are certain scenarios, especially those involving long wait periods, where efficient use of threads will bolster the end user experience and lead to better control flow. As always, the final lines of the sample release the Recordset and Connection resources. </p>
<p>
Try experimenting with multi-threaded versions of the other samples, such as the <a href="vjjado_5tm7.htm">Connection</a> and <a href="vjjado_5uen.htm">Recordset</a> samples. Or, create a version of this sample with multiple Commands being executed simultaneously; for example, “select * from authors” and “select * from publishers, titles where publishers.pubid = titles.pubid”. Also, remember to use Runnable instead of subclassing Thread directly. You can always convert to a full Thread object through the overloaded constructor.</p>
</font></BODY>
</HTML>
