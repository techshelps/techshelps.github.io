<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Use the Hint for Efficient Repainting</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2"><h1><a name="_gs_use_the_hint_for_efficient_repainting"></a><sup></sup>Use the Hint for Efficient Repainting</h1>
<p>
The last task is to take advantage of the hint so the other views can repaint themselves more efficiently. This involves modifying the <code>CScribbleView</code> class by overriding the <code>OnUpdate</code> function to respond to any hint it receives.</p>
<p>
In Scribble Lesson 6, <a href="_gs_binding_visual_objects_to_code_using_wizardbar.htm">Binding Visual Objects to Code Using WizardBar</a>, you saw how to use WizardBar to connect user-interface objects to their message-handler functions. You can also use WizardBar to override functions inherited from the base class, which are not attached to user-interface objects. The following procedure illustrates this point.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To use WizardBar to override <code>OnUpdate</code>, file ScribbleView.cpp must be open in the text editor. </p>
<p class=label>
<b>To add the OnUpdate function to Scribble</b>
<ol>
<li>
Use WizardBar to open ScribbleView.cpp in the text editor.<br><br></li>
<li>
Click the arrow on the action button, located on the right end of WizardBar.<br><br></li>
<li>
On the menu, click <b>Add Virtual Function</b>.<p class=tl>
The <b>New Virtual Override</b> dialog box appears.</P></li>
<li>
From the <b>New Virtual Functions</b> list, select <code>OnUpdate</code>. <br><br></li>
<li>
Click <b>Add and Edit</b>.<br><br></li>
<li>
Replace the //TODO comments with the following code:<pre><code>// The document has informed this view that some data has changed.

if (pHint != NULL)
{
if (pHint-&gt;IsKindOf(RUNTIME_CLASS(CStroke)))
{
// The hint is that a stroke has been added (or changed).
// So, invalidate its rectangle.
CStroke* pStroke = (CStroke*)pHint;
CRect rectInvalid = pStroke-&gt;GetBoundingRect();
InvalidateRect(&amp;rectInvalid);
return;
}
}
// We can't interpret the hint, so assume that anything might
// have been updated.
Invalidate();
return;
</code></pre>
<p class=tl>
Remember, this function is called by the <code>UpdateAllViews</code> function of <code>CScribbleDoc</code>, which passes it a hint. In this function, the view checks if the hint is a <code>CStroke</code> object. If so, the view gets the bounding rectangle for the stroke and marks it as invalid. This rectangle marks the area that must be redrawn. If the hint isn’t a <code>CStroke</code> object, the view doesn’t know what area was modified, so it invalidates the entire client area as a precaution.</P><p class=tl>
After a region has been invalidated, Windows sends a <b>WM_PAINT</b> message. The <b>OnPaint</b> member function defined by <b>CView</b> handles this message by calling the virtual <code>OnDraw</code> member function. Consequently, you must modify the <code>OnDraw</code> function to take advantage of the invalidated rectangle when redrawing. </P></li>
<li>
From ClassView, jump to the <code>OnDraw</code> member function in class <code>CScribbleView</code>, and add the following code just after the <code>ASSERT_VALID(pDoc)</code> line:<pre><code>// Get the invalidated rectangle of the view, or in the case
// of printing, the clipping region of the printer DC.
CRect rectClip;
CRect rectStroke;
pDC-&gt;GetClipBox(&amp;rectClip);

//Note: CScrollView::OnPaint() will have already adjusted the
//viewpoint origin before calling OnDraw(), to reflect the
//currently scrolled position.
</code></pre>
</li>
<li>
Then add the following code immediately following the <code>CStroke* pStroke = strokeList.GetNext(pos)</code> line:<pre><code>rectStroke = pStroke-&gt;GetBoundingRect();
if (!rectStroke.IntersectRect(&amp;rectStroke, &amp;rectClip))
continue;
</code></pre>
<p class=tl>
In the <code>OnDraw</code> function, the view first calls the <b>GetClipBox</b> member function of <b>CDC</b> to get the invalidated portion of the client area. Then the view iterates through the list of strokes in the document, calling <code>IntersectRect</code> for each to determine if any part of the stroke lies in the invalidated region. If so, the view asks the stroke to draw itself. Any strokes that don’t intersect the invalidated region don’t have to be redrawn.</P></li>
</ol>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This is a good point to compile your changes and test the window updating.</p>
<p class=label>
<b>To test your update code</b>
<ol>
<li>
Build and execute Scribble.<br><br></li>
<li>
Add some lines to the document window.<br><br></li>
<li>
From the <b>Window</b> menu, click <b>New Window</b>, then click <b>Tile</b>.<br><br></li>
<li>
Draw in either window and note that the application now correctly tracks the results in both windows.</li>
</ol>
</font></BODY>
</HTML>
