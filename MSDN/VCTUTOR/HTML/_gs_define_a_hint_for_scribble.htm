<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Define a Hint for Scribble</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2"><h1><a name="_gs_define_a_hint_for_scribble"></a><sup></sup>Define a Hint for Scribble</h1>
<p>
When a stroke is added to a drawing in Scribble, the rectangular region that contains the new stroke is the only area that needs to be updated; the remainder of the drawing can be left alone. Therefore, a logical choice for a hint in Scribble is the bounding rectangle of the new stroke.</p>
<p>
Instead of creating a separate class to represent the hint, it’s more convenient to pass a <code>CStroke</code> pointer as a hint. Store the bounding rectangle for each stroke in the <code>CStroke</code> object itself, so that it can be quickly referred to by <code>OnUpdate</code> to determine which area of the window needs to be repainted. </p>
<p>
The following procedure assumes you have your Scribble project file (Scribble.dsw) open in the workspace. </p>
<p class=label>
<b>To define bounding rectangles for strokes</b>
<ol>
<li>
From ClassView, jump to the definition for class <code>CStroke</code>.<br><br></li>
<li>
In the Attributes section, add the following code, just after the <code>m_pointArray</code> declaration: <pre><code>protected:
CRect m_rectBounding;&nbsp; // smallest rect that surrounds all
  // of the points in the stroke
public:
CRect&amp; GetBoundingRect() { return m_rectBounding; }
</code></pre>
<p class=tl>
The protected member variable <code>m_rectBounding</code> is a <b>CRect</b> object storing the bounding rectangle, and the public member function <code>GetBoundingRect</code> allows the rectangle to be retrieved by the view. </P></li>
<li>
Now search ScribbleDoc.cpp for the <b>IMPLEMENT_SERIAL</b> macro and change the schema number parameter to 2.<pre><code>IMPLEMENT_SERIAL( CStroke, CObject, 2 )
</code></pre>
<p class=tl>
This version of Scribble changes what’s stored in a <code>CStroke</code> object by adding a new member variable. Changing the schema number distinguishes strokes saved by this version of Scribble from those of other versions.</P></li>
<li>
Go to the second <code>CStroke</code> constructor (the one that initializes the pen width) and add the following line:<pre><code>m_rectBounding.SetRectEmpty();
</code></pre>
<p class=tl>
This initializes the bounding rectangle to an empty rectangle in the constructor.</P></li>
<li>
Jump to the <code>CStroke</code> <code>Serialize</code> function and add the following line just after the first <b>if </b>condition:<pre><code>ar &lt;&lt; m_rectBounding;
</code></pre>
<p class=tl>
This stores the <code>m_rectBounding</code> member variable in the archive.</P></li>
<li>
Add its code pair just after the <b>else </b>branch:<pre><code>ar &gt;&gt; m_rectBounding;
</code></pre>
<p class=tl>
This reads the <code>m_rectBounding</code> member variable from the archive.</P></li>
</ol>
<p>
In the next procedure, you’ll add a helper function, <code>FinishStroke</code>. This function calculates the bounding rectangle, which is needed for smart repainting.</p>
<p class=label>
<b>To add the FinishStroke helper function</b>
<ol>
<li>
From ClassView, point at the <code>CStroke</code> class icon and click the right mouse button.<br><br></li>
<li>
From the pop-up menu, click <b>Add Function</b>.<p class=tl>
The <b>Add Member Function</b> dialog box appears.</P></li>
<li>
In the <b>Function Type</b> box, type the return type (in this case, <code>void</code>).<br><br></li>
<li>
In the <b>Function Declaration</b> box, type the following:<pre><code>FinishStroke()
</code></pre>
</li>
<li>
In the <b>Access</b> area, select <b>Public</b>.<br><br></li>
<li>
Click <b>OK</b>.<p class=tl>
ClassWizard adds the declaration to the header file, creates a starter definition in the implementation file, and jumps you to the body of the definition so you can begin typing your application-specific code.</P></li>
<li>
Type the following code to fill in the function definition for <code>FinishStroke</code>:<pre><code>if( m_pointArray.GetSize() == 0 )
{
m_rectBounding.SetRectEmpty();
return;
}
CPoint pt = m_pointArray[0];
m_rectBounding = CRect( pt.x, pt.y, pt.x, pt.y );

for (int i=1; i &lt; m_pointArray.GetSize(); i++)
{
// If the point lies outside of the accumulated bounding
// rectangle, then inflate the bounding rect to include it.
pt = m_pointArray[i];
m_rectBounding.left&nbsp;&nbsp; = min(m_rectBounding.left, pt.x);
m_rectBounding.right&nbsp; = max(m_rectBounding.right, pt.x);
m_rectBounding.top&nbsp;&nbsp;&nbsp; = min(m_rectBounding.top, pt.y);
m_rectBounding.bottom = max(m_rectBounding.bottom, pt.y);
}

// Add the pen width to the bounding rectangle.&nbsp; This is needed
// to account for the width of the stroke when invalidating
// the screen.
m_rectBounding.InflateRect(CSize(m_nPenWidth, m_nPenWidth));
return;
</code></pre>
</li>
</ol>
<p>
The <code>FinishStroke</code> member function calculates the bounding rectangle for a stroke. In this function, the stroke object iterates through its array of points, testing the location of each; if a point falls outside the current bounding rectangle, the stroke object enlarges the bounding rectangle just enough to contain it. Then the bounding rectangle is expanded on each side by the width of the pen.</p>
</font></BODY>
</HTML>
