<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Compensating for the Reversal of the Y-Axis</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2"><h1><a name="_gs_compensating_for_the_reversal_of_the_y.2d.axis"></a>Compensating for the Reversal of the Y-Axis</h1>
<p>
Even though <b>MM_LOENGLISH</b> mapping has changed the direction of the y-axis for drawing, most of the current Scribble code doesn’t require any modifications. This is because the <b>DPtoLP</b> function performs the conversion for you. (<b>DPtoLP</b> is called by the mouse event handler functions: <b>OnLButtonDown</b>, <b>OnMouseMove</b>, and <b>OnLButtonUp</b>.) </p>
<p>
When a point is received with a mouse message, its coordinates are converted by the <b>DPtoLP</b> function before being stored in a <code>CStroke</code> object. This means its y-coordinates are converted from a positive number of pixels to a negative number of inches (1 pixel = .01 inch). Those coordinates are then passed to the <b>LineTo</b> drawing function, and then it’s up to the device driver for the screen to determine how many pixels are equivalent to the value that was passed in inches. You never have to directly examine the value of the coordinates.</p>
<p>
However, there are some places where the reversal of the y-axis does have an impact. The mapping mode used by GDI is a characteristic of a device context. Functions that don’t use a device context are unaffected by the mapping mode. The member functions of the <b>CRect</b> class don’t use the mapping mode; consequently, you must make some adjustments wherever Scribble uses <b>CRect</b> functions. </p>
<p class=label>
<b><a name="_gs_to_compensate_for_the_reversal_of_the_y.2d.axis"></a>To compensate for the reversal of the y-axis</b>
<ol>
<li>
From ClassView, jump to the <code>FinishStroke</code> member function definition of class <code>CStroke</code>.<br><br></li>
<li>
Modify the code, as shown below, by reversing the <b>min </b>and <b>max </b>functions for the top and bottom of the bounding rectangle, and adding a cast to the y-axis <code>m_nPenWidth</code> parameter. These modifications take into account the negative sign of the y-coordinates.<p class=tl>
Note that the lines of code shown already exist&nbsp;? you are just modifying them slightly, as described.</P><pre><code>void CStroke::FinishStroke()
{
// ...

m_rectBounding.top        = max(m_rectBounding.top, pt.y);
m_rectBounding.bottom    = min(m_rectBounding.bottom, pt.y);
}

// ...
m_rectBounding.InflateRect
(CSize(m_nPenWidth,-(int)m_nPenWidth));
return;
}
</code></pre>
<p class=tl>
You must also make a correction when using the invalid rectangle. Recall that the <code>OnDraw</code> member function checks whether the invalid rectangle intersects the bounding rectangle for each stroke. The <b>IntersectRect</b> member function of <b>CRect</b> assumes that the bottom of a rectangle must have a larger y-coordinate than that of the top; it cannot find the intersection of two rectangles whose bottoms have smaller y-coordinates than their tops. </P></li>
<li>
Use ClassView to jump to the <code>OnDraw</code> member function definition of <code>CScribbleView</code>, and add the following lines of code after the line <code>pDC-&gt;GetClipBox(&amp;rectClip)</code>:<pre><code>pDC-&gt;LPtoDP(&amp;rectClip);
rectClip.InflateRect(1, 1); // avoid rounding to nothing
</code></pre>
</li>
<li>
Add the following lines of code after the line <code>rectStroke = pStroke-&gt;GetBoundingRect()</code>:<pre><code>pDC-&gt;LPtoDP(&amp;rectStroke);
rectStroke.InflateRect(1, 1);
</code></pre>
<p class=tl>
Both the invalidated rectangle and the bounding rectangle are converted to device coordinates (changing the signs of the coordinates to positive) before being tested for intersection. They are also inflated by one pixel in case they were rounded to nothing during the conversion. </P></li>
</ol>
</font></BODY>
</HTML>
