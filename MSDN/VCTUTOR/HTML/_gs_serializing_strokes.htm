<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Serializing Strokes</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2"><h1><a name="_gs_serializing_strokes"></a><sup></sup>Serializing Strokes</h1>
<p>
When the document responds to an <b>Open</b>, <b>Save</b>, or <b>Save As</b> command, it delegates the real serialization work to the strokes themselves. That is, the document tells the stroke list to serialize itself, and the stroke list, in turn, tells the individual strokes to serialize themselves. As a result, all strokes in the document are read from or written to a file.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Throughout the tutorial, Scribble is presented as a series of incremental versions. When you build successive versions that modify the structure of <code>CStroke</code>, they are incompatible with earlier versions. Attempts to read <code>CStroke</code> data stored by a previous version may fail because the serialization process expects a different structure. Each time you make such a modification of <code>CStroke</code>, tag the new version with a version number, as described in the procedure below. The version or “schema” number is checked automatically during serialization. You can check the schema number in the serialization code to support backward compatibility, allowing you to read files created with earlier versions of your application.</p>
<p>
You’ve added serialization for Scribble documents; now you’ll implement serialization for the strokes. </p>
<p class=label>
<b>To implement serialization for stroke objects</b>
<ol>
<li>
Use WizardBar to jump to the <code>CStroke </code>constructor and, just before it, add the <b>IMPLEMENT_SERIAL</b> macro as shown:<pre><code>IMPLEMENT_SERIAL( CStroke, CObject, 1 )
</code></pre>
<p class=tl>
The third argument is the schema number, discussed earlier. It’s set to 1 for Scribble Step 1.</P><p class=tl>
The <b>IMPLEMENT_SERIAL</b> macro complements the <b>DECLARE_SERIAL</b> macro, which you declared in ScribbleDoc.h when you were adding the code for the <code>CStroke</code> class. The two macros prepare a class for serialization.</P><p class=tl>
Like <code>CScribbleDoc</code>, <code>CStroke</code> also overrides the <b>Serialize</b> member function of its base class. When the stroke-list object is called to serialize itself, it calls each stroke object in turn to serialize itself. </P></li>
<li>
Just after the second <code>CStroke</code> constructor (the one that initializes the pen), add the following <code>Serialize</code> override:<pre><code>void CStroke::Serialize( CArchive&amp; ar )
{
if( ar.IsStoring( ) )
{
ar &lt;&lt; (WORD)m_nPenWidth;
m_pointArray.Serialize( ar );
}
else
{
WORD w;
ar &gt;&gt; w;
m_nPenWidth = w;
m_pointArray.Serialize( ar );
}
}
</code></pre>
<p class=tl>
If the archive object is used for storing, the stroke’s pen-width value is stored in the archive and then its array of points is stored. Notice that the <code>m_pointArray</code> object as a <b>CArray</b> object can serialize itself.</P><p class=tl>
If the archive object is used for loading, the stroke’s data must be read in the same order it was written: first the pen width, then the array of points. The <b>else</b> branch of the <b>if</b> statement declares a local variable to receive the width, then copies that value to <code>m_nPenWidth</code>. It then calls upon the point array to load its data (see the figure Serialization in Scribble in <a href="_gs_serializing_the_data.htm">Serializing the Data</a> earlier in this lesson).</P><p class=tl>
Note that the <code>m_nPenWidth</code> variable is cast to a <b>WORD</b> before it’s inserted in the archive, <b>ar</b>:</P><pre><code>ar &lt;&lt; (WORD)m_nPenWidth;
</code></pre>
<p class=tl>
The cast is necessary because <code>m_nPenWidth</code> is declared as type <b>UINT</b> (unsigned integer). The archive mechanism only supports saving types of fixed size. <b>UINT</b>, for example, is 16 bits in Windows 3.1 and 32 bits in Windows NT and Windows 95. Using the <b>WORD</b> cast makes the data files created by your application portable. To promote machine independence, class <b>CArchive</b> doesn’t have an extraction operator for type <b>int</b> but does have one for type <b>WORD</b>.</P></li>
</ol>
<p>
Once this code is in place, serialization of Scribble’s data is automatic.</p>
</font></BODY>
</HTML>
