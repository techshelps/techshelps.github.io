<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implement OLE In-Place Support in the View Class</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_gs_implement_ole_in.2d.place_support_in_the_view_class"></a><sup></sup>Implement OLE In-Place Support in the View Class</h1>
<p>
To implement OLE in-place support in the view class, you must:
<ul type=disc>
<li>
<a href="#_gs_to_implement_logical_mm_loenglish_rather_than_physical_mm_loenglish">Calculate logical MM_LOENGLISH sizes rather than physical MM_LOENGLISH sizes</a>.<br><br></li>
<li>
<a href="#_gs_to_adjust_the_scroll_view.92.s_scroll_bars_to_reflect_the_use_of_the_logical_mapping_mode">Adjust the scroll view’s scroll bars to reflect the use of the logical mapping mode</a>.<br><br></li>
<li>
<a href="#_gs_to_notify_ole_when_the_embedded_item_changes">Notify OLE when the embedded item changes</a>.</li>
</ul>
<p>
Before Scribble was enhanced to be an OLE in-place editing server, it was lazy about its device context coordinates using <b>MM_LOENGLISH</b>: Scribble did not adjust for how many logical pixels per inch were on the screen display. Most serious Windows applications scale their screen output because small fonts are rarely readable when displayed in their true (physical) size. Applications can adjust for the number of pixels in the logical inch by applying the kind of logic illustrated by the following code sample. This logic relies primarily on values returned by <b>CDC::GetDeviceCaps(LOGPIXELSX)</b> and <b>GetDeviceCaps(LOGPIXELSY)</b>. Now that Scribble is an OLE server, it should scale according to logical pixels per inch. Otherwise, you (and your user) will notice a difference in the scaling of a Scribble drawing when the Scribble server is fully open versus its scaling when it is displayed embedded in the container.</p>
<h3>Suggested Reading in the <i>Microsoft Foundation Class Reference</i></h3>
<ul type=disc>
<li>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_mfc_COleServerDoc.3a3a.NotifyChanged">
</object><a href=JavaScript:alink_1.Click()>COleServerDoc::NotifyChanged</a><br><br></li>
<li>
<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_mfc_CDC.3a3a.GetDeviceCaps">
</object><a href=JavaScript:alink_2.Click()>CDC::GetDeviceCaps</a></li>
</ul>
<p class=label>
<b><a name="_gs_to_implement_logical_mm_loenglish_rather_than_physical_mm_loenglish"></a>To implement logical MM_LOENGLISH rather than physical MM_LOENGLISH</b>
<ol>
<li>
From the <b>View</b> menu, click <b>ClassWizard</b>.<br><br></li>
<li>
If necessary, click the <b>Message Maps</b> tab and ensure that <code>CScribbleView</code> is selected in the <b>Class name</b> and <b>Object IDs</b> boxes.<br><br></li>
<li>
In the <b>Messages</b> box, click OnPrepareDC, and click the <b>Add Function</b> button.<br><br></li>
<li>
Click <b>Edit Code</b>.<br><br></li>
<li>
Implement the override of <code>OnPrepareDC</code> as follows:<pre><code>void CScribbleView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
CScribbleDoc* pDoc = GetDocument();
CScrollView::OnPrepareDC(pDC, pInfo);

pDC-&gt;SetMapMode(MM_ANISOTROPIC);
CSize sizeDoc = pDoc-&gt;GetDocSize();
sizeDoc.cy = -sizeDoc.cy;
pDC-&gt;SetWindowExt(sizeDoc);    

CSize sizeNum, sizeDenom;
pDoc-&gt;GetZoomFactor(&amp;sizeNum, &amp;sizeDenom);

int xLogPixPerInch = pDC-&gt;GetDeviceCaps(LOGPIXELSX);
int yLogPixPerInch = pDC-&gt;GetDeviceCaps(LOGPIXELSY);

long xExt = (long)sizeDoc.cx * xLogPixPerInch * sizeNum.cx;
xExt /= 100 * (long)sizeDenom.cx;
long yExt = (long)sizeDoc.cy * yLogPixPerInch * sizeNum.cy;
yExt /= 100 * (long)sizeDenom.cy;
pDC-&gt;SetViewportExt((int)xExt, (int)-yExt);
}
</code></pre>
</li>
</ol>
<p>
In the following procedure, you’ll implement the <code>ResyncScrollSizes</code> helper function mentioned previously.</p>
<p class=label>
<b><a name="_gs_to_adjust_the_scroll_view.92.s_scroll_bars_to_reflect_the_use_of_the_logical_mapping_mode"></a>To adjust the scroll view’s scroll bars to reflect the use of the logical MM_LOENGLISH mapping mode</b>
<ol>
<li>
In ClassView, right-click <code>CScribbleView</code>.<br><br></li>
<li>
From the pop-up menu, click <b>Add Member Function</b>.<br><br></li>
<li>
In the <b>Add Member Function</b> dialog box, specify the following:<ul type=disc>
<li>
In the <b>Function Type</b> box, type <code>void</code> .<br><br></li>
<li>
 In the <b>Function Declaration</b> box, type <code>ResyncScrollSizes()</code>.<br><br></li>
<li>
In the Access area, click <b>Public</b>.</li>
</ul>
<p class=tl>
Click <b>OK</b>.</P></li>
<li>
Fill in the starter definition with the following code:<pre><code>CClientDC dc(NULL);
OnPrepareDC(&amp;dc);
CSize sizeDoc = GetDocument()-&gt;GetDocSize();
dc.LPtoDP(&amp;sizeDoc);
SetScrollSizes(MM_TEXT, sizeDoc);
</code></pre>
</li>
<li>
Use ClassView to jump to <code>CScribbleView::OnInitialUpdate</code> and replace the call to <b>CScrollView::SetScrollSizes</b> with the call to the helper function, <code>ResyncScrollSizes</code>:<pre><code>void CScribbleView::OnInitialUpdate()
{
ResyncScrollSizes();
CScrollView::OnInitialUpdate();
}
</code></pre>
<p class=tl>
In the next several steps you’ll use WizardBar to add a function that updates the scroll bars appropriately when the window is sized. </P></li>
<li>
Switch to ScribbleView.cpp in the editor.<br><br></li>
<li>
In the WizardBar <b>Class</b> list box, click <code>CScribbleView</code><br><br></li>
<li>
Click the Action arrow, located on the right end of WizardBar.<br><br></li>
<li>
On the menu, click <b>Add Windows Message Handler</b>.<p class=tl>
The <b>New Windows Message and Event Handlers</b> dialog box appears.</P></li>
<li>
In the <b>New Windows messages/events</b> list, click WM_SIZE.<br><br></li>
<li>
Click <b>Add Handler </b>to add WM_SIZE to the <b>Existing message/event handlers</b> list. <br><br></li>
<li>
Click <b>Edit Existing</b>.<br><br></li>
<li>
Replace the //TODO comment with a call to <code>ResyncScrollSizes</code>:<pre><code>ResyncScrollSizes();        //&nbsp; ensure that scroll info is up-to-date
</code></pre>
</li>
<li>
Use ClassView to jump to the <code>CScribbleView</code> constructor and replace the comment with the following code:<pre><code>SetScrollSizes(MM_TEXT, CSize(0,0));
</code></pre>
<p class=tl>
You must initialize the scroll sizes in the <code>CScribbleView</code> constructor to default values, so that the extent is defined before the first call to <code>OnPrepareDC</code><b>.</b></P></li>
</ol>
<p>
When Scribble’s view finishes adding a new stroke in <code>CScribbleView::OnLButtonDown</code>, it calls the document’s <code>UpdateAllViews</code> to inform other views that they need to invalidate a portion of the client area occupied by the new stroke. This notification is fine for Scribble when it is running stand-alone, but it is not adequate when Scribble is fully opened and editing an embedded object. In the latter case, Scribble needs to inform the container that the object has changed. This requires an additional call to <b>COleServerDoc::NotifyChanged</b>.</p>
<p class=label>
<b><a name="_gs_to_notify_ole_when_the_embedded_item_changes"></a>To notify OLE when the embedded item changes</b>
<ul type=disc>
<li>
Use ClassView to jump to <code>CScribbleView::OnLButtonUp</code> and add the call to <b>NotifyChanged </b>just after the <b>ReleaseCapture</b> function call, before the final <b>return</b>: <pre><code>pDoc-&gt;NotifyChanged();
</code></pre>
</li>
</ul>
</font></BODY>
</HTML>
