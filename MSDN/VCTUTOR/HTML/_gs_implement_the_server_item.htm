<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implement the Server Item</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<h1><a name="_gs_implement_the_server_item"></a><sup></sup>Implement the Server Item</h1>
<p>
AppWizard has done most of the work associated with implementing the server item by providing the <b>COleServerItem</b>-derived class in ScribbleItem.cpp. All you have to do is add the application-specific implementation. </p>
<h3>Suggested Reading in the <i>Microsoft Foundation Class Reference</i></h3>
<ul type=disc>
<li>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_mfc_COleServerItem.3a3a.OnGetExtent">
</object><a href=JavaScript:alink_1.Click()>COleServerItem::OnGetExtent</a></li>
</ul>
<p>
The server item’s <code>OnDraw</code> member function is called when the server document needs to draw itself as an inactive embedded object inside the container window. In contrast, the view’s <code>OnDraw</code> is called when the document is activated in place inside the container. <code>CScribbleItem::OnDraw</code> needs to do essentially the same drawing that <code>CScribbleView::OnDraw</code> does. If your <code>OnDraw</code> code in your view class is complex, you will probably want to reuse that code by having your client item’s <code>OnDraw</code> call a shared draw routine. In Scribble, the <code>CStroke::DrawStroke</code> routine is reused.</p>
<p>
Recall that you previously added the AppWizard-generated file, ScribbleItem.cpp, to the project. Now you’ll modify the AppWizard-provided code to support Scribble-specific drawing functions.</p>
<p class=label>
<b>To implement the OLE item’s OnDraw function</b>
<ol>
<li>
Use ClassView to jump to <code>CScribbleItem::OnDraw</code> and modify the AppWizard-provided stubbed version of the function so that it looks like the following:<pre><code>BOOL CScribbleItem::OnDraw(CDC* pDC, CSize&amp; rSize) 
{
CScribbleDoc* pDoc = GetDocument();
ASSERT_VALID(pDoc);

pDC-&gt;SetMapMode(MM_ANISOTROPIC);
CSize sizeDoc = pDoc-&gt;GetDocSize();
sizeDoc.cy = -sizeDoc.cy;
pDC-&gt;SetWindowExt(sizeDoc);
pDC-&gt;SetWindowOrg(0,0);

CTypedPtrList&lt;CObList, CStroke*&gt;&amp; strokeList
= pDoc-&gt;m_strokeList;
POSITION pos = strokeList.GetHeadPosition();
while (pos != NULL)
{
strokeList.GetNext(pos)-&gt;DrawStroke(pDC);
}

return TRUE;
}
</code></pre>
<p class=tl>
This code sets the window extent to the size of the document so that when the document is drawn in the in-place window, the drawing will stretch to the size of the window.</P><p class=tl>
Notice that the above code reverses the sign of the y dimension to reflect the fact that strokes’ positions are maintained in <b>MM_LOENGLISH</b> coordinates by using negative y coordinates. </P></li>
<li>
Similarly, use ClassView to jump to the AppWizard-provided version of <code>CScribbleItem::OnGetExtent</code> and modify it as follows:<pre><code>BOOL CScribbleItem::OnGetExtent(DVASPECT dwDrawAspect, CSize&amp; rSize)
{
// This implementation of CScribbleItem::OnGetExtent only handles
// the "content" aspect indicated by DVASPECT_CONTENT.

if (dwDrawAspect != DVASPECT_CONTENT)
return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

// CScribbleItem::OnGetExtent is called to get the extent in
//&nbsp; HIMETRIC units of the entire item.&nbsp; The default 
//&nbsp; implementation here simply returns a hard-coded 
//&nbsp; number of units.
CScribbleDoc* pDoc = GetDocument();
ASSERT_VALID(pDoc);

rSize = pDoc-&gt;GetDocSize();
CClientDC dc(NULL);

// use a mapping mode based on logical units
//    (we can't use MM_LOENGLISH because MM_LOENGLISH uses 
//    physical inches)
dc.SetMapMode(MM_ANISOTROPIC);
dc.SetViewportExt(dc.GetDeviceCaps(LOGPIXELSX),             
dc.GetDeviceCaps(LOGPIXELSY));
dc.SetWindowExt(100, -100);
dc.LPtoHIMETRIC(&amp;rSize);    

return TRUE;
}
</code></pre>
</li>
<li>
Save ScribbleItem.cpp.</li>
</ol>
<p>
The framework calls the virtual <b>COleServerItem::OnGetExtent</b> member function when the item needs to set the viewport and window extents of the server item window when the item is in-place active. The new code modifies the original code provided by AppWizard, which sets the size of the server item to an arbitrary fixed value. The function must return the size of the server item in <b>HIMETRIC</b> units. In Scribble, the server item must return the size of the document. Scribble stores the drawing size in physical <b>MM_LOENGLISH</b> units. For reasons explained in the next topic, Scribble needs to convert the drawing size to <b>HIMETRIC</b> units based on its logical <b>MM_LOENGLISH</b> size rather than physical <b>MM_LOENGLISH</b> size.</p>
</font></BODY>
</HTML>
