<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Converting from Device Coordinates to Logical Coordinates</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2"><h1><a name="_gs_coverting_from_device_coordinates_to_logical_coordinates"></a>Converting from Device Coordinates to Logical Coordinates</h1>
<p>
When storing the coordinates of strokes, Scribble needs to know where the strokes are relative to the document, not relative to the client area. Consequently, <code>CScribbleView</code> must convert points from device coordinates (relative to the window origin) to logical coordinates (relative to the document origin) before storing them in <code>CStroke</code> objects.</p>
<p class=label>
<b>To store the strokes using logical coordinates</b>
<ol>
<li>
Use ClassView to jump to the <code>OnLButtonDown</code> member function of class <code>CScribbleView</code> in ScribbleView.cpp and add the following code to the beginning of the function definition: <pre><code>// CScrollView changes the viewport origin and mapping mode.
// It's necessary to convert the point from device coordinates
// to logical coordinates, such as are stored in the document.
CClientDC dc(this);
OnPrepareDC(&amp;dc); // set up mapping mode and viewport origin
dc.DPtoLP(&amp;point);
</code></pre>
<p class=tl>
In this function, the view receives a point specified in device coordinates. A device context is needed to find the GDI origin, so the function declares a <b>CClientDC</b> object, which is a <b>CDC</b> object for the client area of the view, and calls <b>OnPrepareDC</b> to adjust its origin. Then the function passes the point to the <b>DPtoLP</b> (Device Point to Logical Point) member function of <b>CDC</b> to perform the actual conversion. The point added to <code>m_pStrokeCur</code> is thus described in logical coordinates (that is, relative to the document origin).</P></li>
<li>
Jump to <code>OnMouseMove</code> and add similar code just after the line <code>CClientDC dc(this)</code>:<pre><code>// CScrollView changes the viewport origin and mapping mode.
// It's necessary to convert the point from device coordinates
// to logical coordinates, such as are stored in the document.
OnPrepareDC(&amp;dc); // set up mapping mode and viewport origin
dc.DPtoLP(&amp;point);
</code></pre>
<p class=tl>
This function already has a device context for drawing the stroke in progress, so the only modifications needed are to call <b>OnPrepareDC</b> to move the viewport origin and then <b>DPtoLP</b> to convert the point before adding it.</P></li>
<li>
Make the same modification to the <code>OnLButtonUp</code> member function, again, just after the line <code>CClientDC dc(this)</code>:<pre><code>// CScrollView changes the viewport origin and mapping mode.
// It's necessary to convert the point from device coordinates
// to logical coordinates, such as are stored in the document.
OnPrepareDC(&amp;dc);&nbsp; // set up mapping mode and viewport origin
dc.DPtoLP(&amp;point);
</code></pre>
<p class=tl>
Like <code>OnMouseMove</code>, this function already has a device context to complete drawing the stroke, so the only modifications needed are to call <b>OnPrepareDC</b> and then <b>DPtoLP</b>.</P></li>
<li>
Jump to <code>OnUpdate</code> and add the following lines of code just after the line <code>CStroke* pStroke = (CStroke*)pHint:</code><pre><code>CClientDC dc(this);
OnPrepareDC(&amp;dc);
</code></pre>
</li>
<li>
Skip a line (the <code>CRect rectInvalid</code> ... line) and add the following line:<pre><code>dc.LPtoDP(&amp;rectInvalid);
</code></pre>
<p class=tl>
Unlike the previous three functions, <code>OnUpdate</code> requires a conversion in the opposite direction; that is, from logical coordinates to device coordinates. Recall that <code>OnUpdate</code> retrieves the bounding rectangle of a stroke and invalidates that rectangle. The stroke’s bounding rectangle is stored in logical coordinates. However, the rectangle passed to <b>InvalidateRect</b> must be specified in device coordinates (since <b>InvalidateRect</b> is not a GDI function). Accordingly, a stroke’s bounding rectangle must have its coordinates converted into device coordinates before it can be invalidated.</P><p class=tl>
The function declares a <b>CClientDC</b> object and then calls the <b>OnPrepareDC</b> member function to move the viewport origin of the device context to reflect the currently scrolled position. The rectangle is then passed to the <b>LPtoDP</b> (Logical Point to Device Point) function of <b>CDC</b> to convert its points into device coordinates. (Both <b>DPtoLP</b> and <b>LPtoDP</b> are overloaded to accept rectangles as well as points.) Once it is converted, the rectangle can be invalidated.</P></li>
</ol>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This is a good point to compile and test Scribble’s scrolling.</p>
</font></BODY>
</HTML>
