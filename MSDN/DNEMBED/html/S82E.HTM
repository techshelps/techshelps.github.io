<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Isolation Levels</TITLE><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#FFFFFF" link=#003399 vlink=#996699>
<FONT FACE="Verdana, Arial, Helvetica"SIZE="2">

<H2>Isolation Levels</H2><P CLASS="t">An isolation level determines the degree to which data is isolated for use by one process and guarded against interference from other processes. With browse cursors, isolation level is controlled on a per-cursor basis in Microsoft SQL&nbsp;Server.</P>
<P CLASS="t">If you do not specify the HOLDLOCK option in the DECLARE CURSOR statement, the isolation level is similar to <I>cursor stability</I>. SQL Server maintains only a share lock on a single page of the database as you retrieve rows with the FETCH statement by using a browse cursor. As long as the cursor is located on a given row, no other process can update that data page.</P>
<P CLASS="t">When you use the HOLDLOCK option, the isolation level is set to <I>repeatable read</I>. With the FETCH statement and by using a browse cursor, SQL Server maintains a share lock on each fetched page of the database. No updates are permitted to the fetched data of the results set as long as the cursor is open, no matter what its position is in the table. The repeatable read isolation level is useful when you want to scan a results set and produce a self-consistent summary report without locking the entire results set. Other users can update rows of the results set that have not been fetched, but fetched rows cannot be updated until the cursor is closed. When a cursor is declared with HOLDLOCK, the lock is freed when the cursor closes. To reread a results set without freeing the lock, reopen the cursor without closing it. </P>
<P CLASS="t">When you use a DECLARE CURSOR statement with the FOR BROWSE<B> </B>option (which is required for UPDATE or DELETE<B> </B>WHERE CURRENT OF statements), SQL&nbsp;Server makes a snapshot of the results set when the cursor is opened. No locks are placed on the original data; the cursor cannot detect any changes that are made to the data as it fetches rows. If the cursor is reopened, SQL&nbsp;Server makes a new snapshot of the data, so the results might not be the same. </P>
<P CLASS="t">The FOR BROWSE<B> </B>and HOLDLOCK options are mutually exclusive. However, you can have cursors repeatedly read, and you can update rows by first locking the rows with the HOLDLOCK option and then opening a cursor by using the FOR BROWSE statement.</P>
<P CLASS="t">The following example illustrates the use of the HOLDLOCK option with a browse cursor:</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="NEW COURIER" SIZE= "3">/* Declare a cursor for browse. */
EXEC SQL DECLARE CURSOR c1 FOR SELECT * FROM orders FOR BROWSE;

/* Begin a transaction using dynamic SQL. */
strcpy(prep, "begin transaction");
EXEC SQL EXECUTE IMMEDIATE :prep;

/* Issue a singleton select that checks all rows but */
/* return one row of output only. */
EXEC SQL SELECT COUNT(*) INTO :count FROM orders HOLDLOCK;

/* The results set is now locked until the transaction is complete. */
/* Open the cursor previously declared for browse, do some fetches */
/* and updates, close it, reopen it, and so on. */
EXEC SQL OPEN c1;

while (SQLCODE ==0)
{
   EXEC SQL FETCH c1 INTO :order_struct;
                .
                .
                .
   EXEC SQL UPDATE orders SET trancode = :new_code
WHERE CURRENT OF c1;
}

EXEC SQL CLOSE c1;
EXEC SQL OPEN c1;

/* Some fetch and update operations can be done here, */
/* and the tables will not be changed. */

EXEC SQL CLOSE c2;
strcpy(prep, "commit transaction");
EXEC SQL EXECUTE IMMEDIATE :prep;
/* Now all locks are free. */
</FONT></PRE>
<P CLASS="t">Because the updates occur over the same connection as the HOLDLOCK operation in the example, conflict does not occur between the FOR BROWSE and the HOLDLOCK options. The locks are released when the transaction is committed or rolled back.</P>
</FONT>
</BODY>
</HTML>
