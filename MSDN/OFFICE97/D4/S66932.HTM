<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STD:</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<H3>STD:</H3>The style description is stored in an STD structure as follows:</P>
</P>
<P>// STD: STyle Definition</P>
<P>//   The STD contains the entire definition of a style.</P>
<P>//   It has two parts, a fixed-length base (cbSTDBase bytes long)</P>
<P>//   and a variable length remainder holding the name, and the upx and upe</P>
<P>//   arrays (a upx and upe for each type stored in the style, std.cupx)</P>
<P>//   Note that new fields can be added to the BASE of the STD without</P>
<P>//   invalidating the file format, because the STSHI contains the length</P>
<P>//   that is stored in the file.  When reading STDs from an older version,</P>
<P>//   new fields will be zero.</P>
<P>typedef struct _STD</P>
<P>    {</P>
<P>    // Base part of STD:</P>
<P>    ushort    sti : 12;          /* invariant style identifier */</P>
<P>    ushort    fScratch : 1;      /* spare field for any temporary use,</P>
<P>                                  always reset back to zero! */</P>
<P>    ushort    fInvalHeight : 1;  /* PHEs of all text with this style are wrong */</P>
<P>    ushort    fHasUpe : 1;       /* UPEs have been generated */</P>
<P>    ushort    fMassCopy : 1;     /* std has been mass-copied; if unused at</P>
<P>                                  save time, style should be deleted */</P>
<P>    ushort    sgc : 4;           /* style type code */</P>
<P>    ushort    istdBase : 12;     /* base style */</P>
<P>    ushort    cupx : 4;          /* # of UPXs (and UPEs) */</P>
<P>    ushort    istdNext : 12;     /* next style */</P>
<P>    ushort    bchUpe;            /* offset to end of upx's, start of upe's */</P>
<P></P>
<P>    ushort    fAutoRedef : 1;    /* auto redefine style when appropriate */</P>
<P>    ushort    fHidden : 1;       /* hidden from UI? */</P>
<P>    ushort : 14;               /* unused bits */</P>
<P></P>
<P>    // Variable length part of STD:</P>
<P>    XCHAR    xstzName[2];        /* sub-names are separated by chDelimStyle */</P>
<P>    /* char    grupx[]; */</P>
<P>    /* the UPEs are not stored on the file; they are a cache of the based-on</P>
<P>       chain */</P>
<P>    /* char    grupe[]; */</P>
<P>    } STD;</P>
</P>
The cb preceding each STD is the length of the data, which includes all of the STD except the grupe array (which is derived after the file is read in, by building each UPE from the base style UPE plus the exceptions in the UPX.) A cb of zero indicates an empty slot in the style array, i.e. no style has that istd. Note that the STD structure may be longer or shorter than the one stored in the file, stshi.cbSTDBaseInFile indicates the length of the base of the STD (up to stzName) as stored in the file. The stylesheet reader routine has to take this into account.</P>
</P>
The variable-length part of the STD actually has three variable-length subparts, the xstzName, the grupx, and the grupe. Since this doesn't fit well into a C structure declaration, some processing is needed to figure out where one part stops and the next part begins. An important note is that all variable-length parts and subparts of the STD begin on EVEN-BYTE OFFSETS within the STD, even if the length of the preceding variable-length part was odd.</P>
</P>
std.sti: The sti is an identifier which built-in style this is, or stiUser for a user-defined style. An sti is intended to be permanent through versions of Word, although new sti's may be added in new versions. The sti definitions are:</P>
</P>
<P>// standard sti codes - these are invariant identifiers for built-in styles</P>
<P>// and must remain the same (i.e. don't renumber them, or old files will be</P>
<P>// messed up.)</P>
<P>// NOTE: sti and istd are the same for Normal and level styles</P>
<P>// If you want to define a new built-in style:</P>
<P>//   1) Decide if you really need one--it will exist in all future versions!</P>
<P>//   2) Add a new sti below.  You can take the first available slot.</P>
<P>//   3) Change stiMax, and stiPapMax or stiChpMax</P>
<P>//   4) Add entry to _dnsti, and the two ids's in strman.pp</P>
<P>//   5) Add case in GetDefaultUpdForSti</P>
<P>//   6) Change cstiMaxBuiltinDependents if necessary</P>
<P>// If you want to change the definition of a built-in style</P>
<P>//   1) In order to make WinWord 2 documents that use the style look like</P>
<P>//      they did in WinWord 2, add a case in GetDefaultUpdForSti to handle</P>
<P>//      fOldDef.  This definition will be used when converting WinWord 2</P>
<P>//      stylesheets.</P>
<P>//   2) If you change the name of a built-in style, increment nVerBuiltInNames</P>
<P>#define stiNormal      0    // 0x0000</P>
<P></P>
<P>#define stiLev1        1    // 0x0001</P>
<P>#define stiLev2        2    // 0x0002</P>
<P>#define stiLev3        3    // 0x0003</P>
<P>#define stiLev4        4    // 0x0004</P>
<P>#define stiLev5        5    // 0x0005</P>
<P>#define stiLev6        6    // 0x0006</P>
<P>#define stiLev7        7    // 0x0007</P>
<P>#define stiLev8        8    // 0x0008</P>
<P>#define stiLev9        9    // 0x0009</P>
<P>#define stiLevFirst    stiLev1</P>
<P>#define stiLevLast     stiLev9</P>
<P></P>
<P>#define stiIndex1      10    // 0x000A</P>
<P>#define stiIndex2      11    // 0x000B</P>
<P>#define stiIndex3      12    // 0x000C</P>
<P>#define stiIndex4      13    // 0x000D</P>
<P>#define stiIndex5      14    // 0x000E</P>
<P>#define stiIndex6      15    // 0x000F</P>
<P>#define stiIndex7      16    // 0x0010</P>
<P>#define stiIndex8      17    // 0x0011</P>
<P>#define stiIndex9      18    // 0x0012</P>
<P>#define stiIndexFirst  stiIndex1</P>
<P>#define stiIndexLast   stiIndex9</P>
<P></P>
<P>#define stiToc1        19    // 0x0013</P>
<P>#define stiToc2        20    // 0x0014</P>
<P>#define stiToc3        21    // 0x0015</P>
<P>#define stiToc4        22    // 0x0016</P>
<P>#define stiToc5        23    // 0x0017</P>
<P>#define stiToc6        24    // 0x0018</P>
<P>#define stiToc7        25    // 0x0019</P>
<P>#define stiToc8        26    // 0x001A</P>
<P>#define stiToc9        27    // 0x001B</P>
<P>#define stiTocFirst    stiToc1</P>
<P>#define stiTocLast     stiToc9</P>
<P></P>
<P>#define stiNormIndent  28    // 0x001C</P>
<P>#define stiFtnText     29    // 0x001D</P>
<P>#define stiAtnText     30    // 0x001E</P>
<P>#define stiHeader      31    // 0x001F</P>
<P>#define stiFooter      32    // 0x0020</P>
<P>#define stiIndexHeading 33    // 0x0021</P>
<P>#define stiCaption     34    // 0x0022</P>
<P>#define stiToCaption   35    // 0x0023</P>
<P>#define stiEnvAddr     36    // 0x0024</P>
<P>#define stiEnvRet      37    // 0x0025</P>
<P>#define stiFtnRef      38    // 0x0026  char style</P>
<P>#define stiAtnRef      39    // 0x0027  char style</P>
<P>#define stiLnn         40    // 0x0028  char style</P>
<P>#define stiPgn         41    // 0x0029  char style</P>
<P>#define stiEdnRef      42    // 0x002A  char style</P>
<P>#define stiEdnText     43    // 0x002B</P>
<P>#define stiToa         44    // 0x002C</P>
<P>#define stiMacro       45    // 0x002D</P>
<P>#define stiToaHeading  46    // 0x002E</P>
<P>#define stiList         47    // 0x002F</P>
<P>#define stiListBullet  48    // 0x0030</P>
<P>#define stiListNumber  49    // 0x0031</P>
<P>#define stiList2         50    // 0x0032</P>
<P>#define stiList3         51    // 0x0033</P>
<P>#define stiList4         52    // 0x0034</P>
<P>#define stiList5         53    // 0x0035</P>
<P>#define stiListBullet2 54    // 0x0036</P>
<P>#define stiListBullet3 55    // 0x0037</P>
<P>#define stiListBullet4 56    // 0x0038</P>
<P>#define stiListBullet5 57    // 0x0039</P>
<P>#define stiListNumber2 58    // 0x003A</P>
<P>#define stiListNumber3 59    // 0x003B</P>
<P>#define stiListNumber4 60    // 0x003C</P>
<P>#define stiListNumber5 61    // 0x003D</P>
<P>#define stiTitle        62    // 0x003E</P>
<P>#define stiClosing     63    // 0x003F</P>
<P>#define stiSignature   64    // 0x0040</P>
<P>#define stiNormalChar  65    // 0x0041  char style</P>
<P>#define stiBodyText    66    // 0x0042</P>
<P>#define stiBodyText2   67    // 0x0043</P>
<P>#define stiListCont    68    // 0x0044</P>
<P>#define stiListCont2   69    // 0x0045</P>
<P>#define stiListCont3   70    // 0x0046</P>
<P>#define stiListCont4   71    // 0x0047</P>
<P>#define stiListCont5   72    // 0x0048</P>
<P>#define stiMsgHeader   73    // 0x0049</P>
<P>#define stiSubtitle    74    // 0x004A</P>
<P>#define stiSalutation  75    // 0x004B</P>
<P>#define stiDate        76    // 0X004C</P>
<P>#define stiBodyText1I  77    // 0x004D</P>
<P>#define stiBodyText1I2 78    // 0x004E</P>
<P>#define stiNoteHeading 79    // 0x004F</P>
<P>#define stiBodyText2   80    // 0x0050</P>
<P>#define stiBodyText3   81    // 0x0051</P>
<P>#define stiBodyTextInd2 82    // 0x0052</P>
<P>#define stiBodyTextInd3 83    // 0x0053</P>
<P>#define stiBlockQuote  84    // 0x0054</P>
<P>#define stiHyperlink   85    // 0x0055  char style</P>
<P>#define stiHyperlinkFollowed 86    // 0x0056   char style</P>
<P>#define stiStrong      87    // 0x0057  char style</P>
<P>#define stiEmphasis    88    // 0x0058  char style</P>
<P>#define stiNavPane     89    // 0x0059  char style</P>
<P>#define stiPlainText   90    // 0x005A</P>
<P></P>
<P></P>
<P>#define stiMax         91    // number of defined sti's</P>
<P></P>
<P>#define stiUser        0x0ffe    // user styles are distinguished by name</P>
<P>#define stiNil         0x0fff    // max for 12 bits</P>
</P>
See below for the names of these styles.</P>
</P>
std.stc: The type of each style is indicated by std.sgc.  The two types currently in use are:</P>
<P>sgcPara    1    // A paragraph style</P>
<P>sgcChp    2    // A character style</P>
More style types may exist in the future, so styles of an unknown type should be discarded.</P>
</P>
std.istdBase: The style that this style is based on. A style is always based on another style or the null style (istdNil). Following a "chain" of based-on styles will always end at the null style, because a based-on chain cannot have a loop in it. A style can have up to 11 "ancestors" in its based-on chain, including the null style. A style's definition is built up from the style that it is based on. See std.cupx, std.grupx, std.grupe.</P>
</P>
std.istdNext: The style that should be applied after this one. For a paragraph style, this is the style that is applied when Enter is pressed at the end of a paragraph. For a character style, the next style is essentially ignored, but should be the same as the current style.</P>
</P>
std.xstzName: The name of the style, including aliases. The name is stored as an xstz (preceded by a length byte, followed by a null-terminator.) A style name can contain multiple "aliases", separated by commas. Aliases are alternate names for the same style (e.g. a style named "a,b,c" has three aliases, and can be referred to by "a", "b", or "c", or any combination.) WinWord 2.x did not have aliases, but MacWord 5.x did. If a style is a built-in style, the built-in stylename is always stored first.</P>
</P>
All names (and aliases) must be unique within a stylesheet (e.g. styles "a,b" and "b,c" should not exist in the same stylesheet, as "b" matches multiple stylenames.)</P>
</P>
A stylename (including all its aliases and comma separators) can be up to 253 characters long. So the xstz format of that name can be up to 255 characters. Stylenames are case sensitive.</P>
</P>
The built-in stylenames (corresponding to each sti above) are defined for each language version of Word. For the USA, the names are:</P>
</P>
<P>// These are the names of the built-in styles as we want to present them</P>
<P>// to the user.</P>
<P>Normal</P>
<P>Heading 1</P>
<P>Heading 2</P>
<P>Heading 3</P>
<P>Heading 4</P>
<P>Heading 5</P>
<P>Heading 6</P>
<P>Heading 7</P>
<P>Heading 8</P>
<P>Heading 9</P>
<P>Index 1</P>
<P>Index 2</P>
<P>Index 3</P>
<P>Index 4</P>
<P>Index 5</P>
<P>Index 6</P>
<P>Index 7</P>
<P>Index 8</P>
<P>Index 9</P>
<P>TOC 1</P>
<P>TOC 2</P>
<P>TOC 3</P>
<P>TOC 4</P>
<P>TOC 5</P>
<P>TOC 6</P>
<P>TOC 7</P>
<P>TOC 8</P>
<P>TOC 9</P>
<P>Normal Indent</P>
<P>Footnote Text</P>
<P>Annotation Text</P>
<P>Header</P>
<P>Footer</P>
<P>Index Heading</P>
<P>Caption</P>
<P>Table of Figures</P>
<P>Envelope Address</P>
<P>Envelope Return</P>
<P>Footnote Reference</P>
<P>Annotation Reference</P>
<P>Line Number</P>
<P>Page Number</P>
<P>Endnote Reference</P>
<P>Endnote Text</P>
<P>Table of Authorities</P>
<P>Macro Text</P>
<P>TOA Heading</P>
<P>List</P>
<P>List 2</P>
<P>List 3</P>
<P>List 4</P>
<P>List 5</P>
<P>List Bullet</P>
<P>List Bullet 2</P>
<P>List Bullet 3</P>
<P>List Bullet 4</P>
<P>List Bullet 5</P>
<P>List Number</P>
<P>List Number 2</P>
<P>List Number 3</P>
<P>List Number 4</P>
<P>List Number 5</P>
<P>Title</P>
<P>Closing</P>
<P>Signature</P>
<P>Default Paragraph Font</P>
<P>Body Text</P>
<P>Body Text Indent</P>
<P>List Continue</P>
<P>List Continue 2</P>
<P>List Continue 3</P>
<P>List Continue 4</P>
<P>List Continue 5</P>
<P>Message Header</P>
<P>Subtitle</P>
<P>Salutation</P>
<P>Date</P>
<P>Body Text First Indent</P>
<P>Body Text First Indent 2</P>
<P>Note Heading</P>
<P>Body Text 2</P>
<P>Body Text 3</P>
<P>Body Text Indent 2</P>
<P>Body Text Indent 3</P>
<P>Block Text</P>
<P>Hyperlink</P>
<P>Followed Hyperlink</P>
<P>Strong</P>
<P>Emphasis</P>
<P>Document Map</P>
<P>Plain Text</P>
</P>
std.cupx: This is the number of UPXs in the std.grupx array. See below.</P>
</P>
std.grupx: This is an array of variable-length UPXs, with std.cupx UPXs in the array. This array begins after the variable-length xstzName field, at the next even-byte offset within the STD. A UPX (Universal Property eXception) describes the difference in formatting of this style as compared to its based-on style. The UPX structure looks like this:</P>
<P>typedef union _UPX</P>
<P>    {</P>
<P>    struct</P>
<P>        {</P>
<P>        uchar grpprl[cbMaxGrpprlStyleChpx];</P>
<P>        } chpx;</P>
<P>    struct</P>
<P>        {</P>
<P>        ushort istd;</P>
<P>        uchar grpprl[cbMaxGrpprlStylePapx];</P>
<P>        } papx;</P>
<P>    uchar rgb[1];</P>
<P>    } UPX;</P>
Each UPX stored in a file is not a complete UPX, rather it is a UPX with all trailing zero bytes lopped off, and preceded by a ushort length field. So it is stored like:</P>
    <I>Field</I>    <I>Size</I>    <I>Comment</I></P>
    cbUPX    2 bytes    size of the following UPX structure</P>
    UPX    (cbUPX)    Nonzero prefix of a UPX structure</P>
Each UPX begins on an even-byte offset within the STD, even if the length of the previous UPX (cbUPX) was odd.</P>
</P>
The meaning of each UPX depends on the style type (std.sgc). For a paragraph style, std.cupx is 2. The first UPX is a paragraph UPX (UPX.papx) and the second UPX is a character UPX (UPX.chpx). For a character style, std.cupx is 1, and that UPX is a character UPX (UPX.chpx). Note that new UPXs may be added in the future, so std.cupx might be larger than expected. Any UPXs past those expected should be discarded.</P>
</P>
The grpprl within each UPX contains the differences of this property type for this style from the UPE of that property type for the based on style. For example, if two paragraph styles, A and B, were identical except that B was bold where A was not, and B was based on A, B would have two UPXs, where the paragraph UPX would have an empty grpprl, and the character UPX would have a bold sprm in the grpprl. Thus B looks just like A (since B is based on A), with the exception that B is bold.</P>
</P>
std.grupe: This is an array (group) of variable-length UPEs. These are not stored in the file! Rather, they are constructed using the std.istdBase and std.grupx fields. A UPE (Universal Property Expansion) describes the "end-result" of the property formatting, i.e. what the style looks like. The UPE structure is the non-zero prefix of a UPD structure. The UPD structure looks like this:</P>
<P>typedef union _UPD</P>
<P>    {</P>
<P>    PAP pap;</P>
<P>    CHP chp;</P>
<P>    struct</P>
<P>        {</P>
<P>        ushort istd;</P>
<P>        uchar cbGrpprl;</P>
<P>        uchar grpprl[cbMaxGrpprlStyleChpx];</P>
<P>        } chpx;</P>
<P>    } UPD;</P>
</P>
The std.grupe and std.grupx arrays are similar: there is one UPE for each UPX, and internally they are stored similarly (a length ushort followed by a non-zero prefix), though remember that the UPEs are not stored in the file. The meaning of each UPE depends on the style type (std.sgc). For a paragraph style, the first UPE is a PAP (UPE.pap). The second UPE is a CHP (UPE.chp). For a character style, the first UPE is a CHPX (UPE.chpx).</P>
</P>
The UPEs for a style are constructed by taking the UPEs from the based-on style, and applying the UPXs to them. Obviously, if the UPEs for the based-on style haven't yet been constructed, that style's UPE needs to be constructed first. Eventually by following the based-on chain, a style will be based on the null style (istdNil). The UPEs for the null style are predefined:</P>
The UPE.pap for the null style is all zeros, except fWidowControl which is 1, dyaLine which is 240, and fMultLinespace which is 1.</P>
The UPE.chp for the null style is all zeros, except istd which is 10 (istdNormalChar), hps which is 20, lid which is 0x0400, and ftc which is set to the STSHI.ftcStandardChpStsh.</P>
The UPE.chpx for the null style has an istd of zero, a cbGrpprl of zero (and an empty grpprl).</P>
</P>
So, for a paragraph style, the first UPE is a UPE.pap. It can be constructed by starting the with first UPE from the based-on style (std.istdBase), and then applying the first UPX (UPX.papx) in std.grupx to that UPE. To apply a UPX.papx to a UPE.pap, set UPE.pap.istd equal to UPX.papx.istd, and then apply the UPX.papx.grpprl to UPE.pap. Similarly, the second UPE is a UPE.chp. It can be constructed by starting with the second UPE from the based-on style, and then applying the second UPX (UPX.chpx) in std.grupx to that UPE. To apply a UPX.chpx to a UPE.chp, apply the UPX.chpx.grpprl to UPE.chp. Note that a UPE.chp for a paragraph style should always have UPE.chp.istd == istdNormalChar.</P>
</P>
For a character style, the first (and only) UPE (a UPE.chpx) can be constructed by starting with the first UPE from the based-on style (std.istdBase), and then applying the first UPX (UPX.chpx) in std.grupx to that UPE. To apply a UPX.chpx to a UPE.chpx, take the grpprl in UPE.chpx.grpprl (which has a length of UPE.chpx.cbGrpprl) and merge the grpprl in UPX.chpx.grpprl into it. Merging grpprls is a tricky business, but for character styles it is easy because no prls in character style grpprls should interact with each other. Each prl from the source (the UPX.chpx.grpprl) should be inserted into the destination (the UPE.chpx.grpprl) so that the sprm of each prl is in increasing order, and any prls that have the same sprm are replaced by the prl in the source. UPE.chpx.cbGrpprl is then set to the length of resulting grpprl, and UPE.chpx.istd is set to the style's istd.</P>
</P></BODY></HTML>
