<HTML>
<HEAD>

<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Appendix B</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->



<H1>Appendix B</H1><P>//</P>
<P>// Sample code to read the text out of a PowerPoint '97 presentation.</P>
<P>//</P>
<P></P>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>
<P>#include &lt;time.h&gt;</P>
<P></P>
<P>// Stolen from app\sertypes.h</P>
<P>// system dependent sizes</P>
<P>// system dependent sizes</P>
<P>typedef signed long     sint4;            // signed 4-byte integral value</P>
<P>typedef signed short    sint2;            // signed 4-byte integral value</P>
<P>typedef unsigned long   uint4;            // unsigned 4-byte integral value</P>
<P>typedef unsigned short  uint2;            //          2-byte</P>
<P>typedef char            bool1;            // 1-byte boolean</P>
<P>typedef unsigned char   ubyte1;           // unsigned byte value</P>
<P>typedef uint2           psrType;</P>
<P>typedef uint4           psrSize;          // each record is preceeded by </P>
<P>                                          // pssTypeType and pssSizeType.</P>
<P>typedef uint2          psrInstance;</P>
<P>typedef uint2          psrVersion;</P>
<P>typedef uint4          psrReference;     // Saved object reference</P>
<P></P>
<P></P>
<P>#define PSFLAG_CONTAINER 0xFF             // If the version field of a record</P>
<P>                                          //  header takes on this value, the</P>
<P>                                          //  record header marks the start of</P>
<P>                                          //  a container.</P>
<P>// PowerPoint97 Record Header</P>
<P>typedef unsigned long DWord;</P>
<P></P>
<P>int AssertionFailed( const char* file, int line, const char* expr )</P>
<P>/*=================*/</P>
<P>{// AR: Message box the assert</P>
<P>   return( TRUE );</P>
<P>} /* AssertionFailed */</P>
<P></P>
<P></P>
<P>#define Assert( expr )                                                      \</P>
<P>{                                                                           \</P>
<P>   static char _str[] = #expr;                                              \</P>
<P>                                                                            \</P>
<P>   if( !(int)(expr) )                                                       \</P>
<P>      AssertionFailed( __FILE__, __LINE__, _str );                          \</P>
<P>} /* Assert */</P>
<P></P>
<P>static BOOL ReadText( WCHAR* buffer, unsigned long bufferSize, unsigned long* pSizeRet );</P>
<P>// Returns TRUE if more text exists.  Fills buffer upto bufferSize.  Actual size used is</P>
<P>// pSizeRet.</P>
<P></P>
<P></P>
<P>struct RecordHeader</P>
<P>{</P>
<P>   psrVersion     recVer      : 4;                  // may be PSFLAG_CONTAINER</P>
<P>   psrInstance    recInstance : 12; </P>
<P>    psrType        recType;</P>
<P>    psrSize        recLen;</P>
<P>};</P>
<P></P>
<P></P>
<P>struct PSR_CurrentUserAtom</P>
<P>{</P>
<P>   uint4  size;</P>
<P>   uint4  magic;  // Magic number to ensure this is a PowerPoint file.</P>
<P>   uint4  offsetToCurrentEdit;  // Offset in main stream to current edit field.</P>
<P>   uint2     lenUserName;</P>
<P>   uint2  docFileVersion;</P>
<P>   ubyte1 majorVersion;</P>
<P>   ubyte1 minorVersion;</P>
<P>};</P>
<P></P>
<P>struct PSR_UserEditAtom</P>
<P>{</P>
<P>   sint4  lastSlideID;    // slideID</P>
<P>   uint4  version;        // This is major/minor/build which did the edit</P>
<P>   uint4  offsetLastEdit; // File offset of last edit</P>
<P>   uint4  offsetPersistDirectory; // Offset to PersistPtrs for </P>
<P>                               // this file version.</P>
<P>   uint4  documentRef;</P>
<P>   uint4  maxPersistWritten;      // Addr of last persist ref written to the file (max seen so far).</P>
<P>   sint2  lastViewType;   // enum view type</P>
<P>};</P>
<P></P>
<P>struct PSR_SlidePersistAtom</P>
<P>{</P>
<P>   uint4  psrReference;</P>
<P>   uint4  flags;</P>
<P>   sint4  numberTexts;</P>
<P>   sint4  slideId;</P>
<P>   uint4  reserved;</P>
<P>};</P>
<P></P>
<P></P>
<P>#define CURRENT_USER_STREAM      L"Current User"</P>
<P>#define DOCUMENT_STREAM          L"PowerPoint Document"</P>
<P>#define HEADER_MAGIC_NUM         -476987297</P>
<P></P>
<P>const int PST_UserEditAtom       = 4085;</P>
<P>const int PST_PersistPtrIncrementalBlock = 6002; // Incremental diffs on persists</P>
<P>const int PST_SlidePersistAtom    = 1011;</P>
<P>const int PST_TextCharsAtom       = 4000;  // Unicode in text</P>
<P>const int PST_TextBytesAtom       = 4008;  // non-unicode text</P>
<P></P>
<P>class PPSPersistDirectory;</P>
<P></P>
<P>struct ParseContext</P>
<P>{</P>
<P>   ParseContext(ParseContext *pNext) : m_pNext(pNext), m_nCur(0) {}</P>
<P></P>
<P>   RecordHeader  m_rh;</P>
<P>   uint4         m_nCur;</P>
<P>   ParseContext *m_pNext;</P>
<P>};</P>
<P></P>
<P>const int SLIDELISTCHUNKSIZE=32;</P>
<P></P>
<P>struct SlideListChunk</P>
<P>{</P>
<P>   SlideListChunk( SlideListChunk* next, psrReference newOne ) :</P>
<P>      pNext( next ), numInChunk(1) { refs[0] = newOne; }</P>
<P>   SlideListChunk *pNext;</P>
<P>   DWord numInChunk;</P>
<P>   psrReference refs[SLIDELISTCHUNKSIZE];</P>
<P>};</P>
<P></P>
<P>class FileReader</P>
<P>{</P>
<P>public:</P>
<P>   FileReader(IStorage *pStg);</P>
<P>   ~FileReader();</P>
<P></P>
<P>   BOOL ReadText( WCHAR *pBuff, ULONG size, ULONG *pSizeRet );</P>
<P>   // Reads next size chars from file.  Returns TRUE if there is more</P>
<P>   // text to read.</P>
<P></P>
<P>   BOOL IsPowerPoint() { return m_isPP; } // Returns true if this is a PowerPoint '97 file.</P>
<P></P>
<P>   void ReadPersistDirectory();</P>
<P>   void PPSReadUserEditAtom( DWord offset, PSR_UserEditAtom&amp; userEdit );</P>
<P>   void ReadSlideList();</P>
<P></P>
<P>protected:</P>
<P>   BOOL ReadCurrentUser(IStream *pStm);</P>
<P>   void *ReadRecord( RecordHeader&amp; rh );</P>
<P></P>
<P>   BOOL Parse();</P>
<P>   IStream *GetDocStream();</P>
<P>   BOOL DoesClientRead( psrType type ) { return FALSE; }</P>
<P>   void ReleaseRecord( RecordHeader&amp; rh, void* diskRecBuf );</P>
<P>   DWord ParseForSlideLists();</P>
<P>   void AddSlideToList( psrReference refToAdd );</P>
<P>   BOOL StartParse( DWord offset );</P>
<P>   BOOL FillBufferWithText();</P>
<P>   BOOL FindNextSlide( DWord&amp; offset );</P>
<P></P>
<P>private:</P>
<P>   PSR_CurrentUserAtom m_currentUser;</P>
<P>   IStream *           m_pDocStream;</P>
<P>   IStorage *          m_pPowerPointStg;</P>
<P>   BOOL                 m_isPP;</P>
<P>   ParseContext*        m_pParseContexts;</P>
<P></P>
<P>   WCHAR*               m_pCurText;</P>
<P>   unsigned long        m_curTextPos;</P>
<P>   unsigned long        m_curTextLength;</P>
<P></P>
<P>   PSR_UserEditAtom*    m_pLastUserEdit;</P>
<P>   PPSPersistDirectory* m_pPersistDirectory;</P>
<P>   SlideListChunk*      m_pFirstChunk;</P>
<P>   int                  m_curSlideNum;</P>
<P></P>
<P>   WCHAR*               m_pClientBuf;</P>
<P>   unsigned long        m_clientBufSize;</P>
<P>   unsigned long        m_clientBufPos;</P>
<P>   ULONG*               m_pSizeRet;</P>
<P>};</P>
<P></P>
<P></P>
<P>FileReader::FileReader(IStorage *pStg) :</P>
<P>   m_pPowerPointStg(pStg), </P>
<P>   m_isPP(FALSE),</P>
<P>   m_pParseContexts(NULL),</P>
<P>   m_curTextPos(0),</P>
<P>   m_pLastUserEdit( NULL ),</P>
<P>   m_pPersistDirectory( NULL ),</P>
<P>   m_pDocStream( NULL ),</P>
<P>   m_pFirstChunk( NULL ),</P>
<P>   m_curSlideNum(0),</P>
<P>   m_pCurText( NULL ),</P>
<P>   m_pClientBuf( NULL ),</P>
<P>   m_clientBufSize( 0 ),</P>
<P>   m_clientBufPos( 0 )</P>
<P>{</P>
<P>   IStream *pStm = NULL;</P>
<P>   m_pPowerPointStg-&gt;AddRef();</P>
<P>   HRESULT hr = pStg-&gt;OpenStream( CURRENT_USER_STREAM, NULL, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, NULL, &amp;pStm );</P>
<P>   if( SUCCEEDED(hr) &amp;&amp; ReadCurrentUser(pStm) )</P>
<P>      m_isPP = TRUE;</P>
<P>   pStm-&gt;Release();</P>
<P>}</P>
<P></P>
<P>FileReader::~FileReader()</P>
<P>{</P>
<P>   m_pPowerPointStg-&gt;Release();</P>
<P>}</P>
<P></P>
<P>BOOL FileReader::FillBufferWithText()</P>
<P>{</P>
<P>   unsigned long amtToCopy = min( (m_curTextLength - m_curTextPos), (m_clientBufSize - m_clientBufPos) );</P>
<P>   unsigned long loop = amtToCopy;</P>
<P>   while( loop-- )</P>
<P>      m_pClientBuf[ m_clientBufPos++ ] = m_pCurText[ m_curTextPos++ ];</P>
<P>   if( m_curTextPos == m_curTextLength )</P>
<P>   {</P>
<P>      delete [] m_pCurText;</P>
<P>      m_pCurText = NULL;</P>
<P>      m_curTextPos = 0;</P>
<P>      m_curTextLength = 0;</P>
<P>   }</P>
<P>   *m_pSizeRet += amtToCopy;</P>
<P>   return (m_clientBufSize == m_clientBufPos); // If client's buffer is full return TRUE.</P>
<P>}</P>
<P></P>
<P>void FileReader::AddSlideToList( psrReference refToAdd )</P>
<P>{</P>
<P>   if( m_pFirstChunk == NULL ) </P>
<P>      m_pFirstChunk = new SlideListChunk(NULL, refToAdd);</P>
<P>   else</P>
<P>   {</P>
<P>      if( m_pFirstChunk-&gt;numInChunk+1 &gt; SLIDELISTCHUNKSIZE )</P>
<P>         m_pFirstChunk = new SlideListChunk(m_pFirstChunk, refToAdd);</P>
<P>      else</P>
<P>      {</P>
<P>         m_pFirstChunk-&gt;refs[m_pFirstChunk-&gt;numInChunk] = refToAdd;</P>
<P>         m_pFirstChunk-&gt;numInChunk++;</P>
<P>      }</P>
<P>   }</P>
<P>}</P>
<P></P>
<P>IStream *FileReader::GetDocStream()</P>
<P>{</P>
<P>   if( m_pDocStream == NULL )</P>
<P>   {</P>
<P>      if( !m_isPP )</P>
<P>         return NULL;</P>
<P>      HRESULT hr = m_pPowerPointStg-&gt;OpenStream( DOCUMENT_STREAM, NULL, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, NULL, &amp;m_pDocStream );</P>
<P>       if (FAILED(hr))</P>
<P>      {</P>
<P>           fprintf(stderr,"Error (%d) opening PowerPoint Document Stream.\n",(int)hr);</P>
<P>         return NULL;</P>
<P>       }</P>
<P>   }</P>
<P>   return m_pDocStream;</P>
<P></P>
<P>}</P>
<P></P>
<P>BOOL FileReader::ReadCurrentUser(IStream *pStm)</P>
<P>{</P>
<P>   ULONG nRd=0;</P>
<P>   RecordHeader rh;</P>
<P>   BOOL isPP = FALSE;</P>
<P>   if( SUCCEEDED( pStm-&gt;Read(&amp;rh, sizeof(rh), &amp;nRd) ) )</P>
<P>   {</P>
<P>      if( SUCCEEDED( pStm-&gt;Read(&amp;m_currentUser, sizeof(PSR_CurrentUserAtom), &amp;nRd) ) )</P>
<P>      {</P>
<P>         if( nRd != sizeof(PSR_CurrentUserAtom) )</P>
<P>            return FALSE;</P>
<P>      }</P>
<P>      isPP = ( m_currentUser.size == sizeof( m_currentUser )      )&amp;&amp;</P>
<P>             ( m_currentUser.magic == HEADER_MAGIC_NUM )&amp;&amp;</P>
<P>             ( m_currentUser.lenUserName &lt;= 255        );</P>
<P>   }</P>
<P></P>
<P>   return isPP;</P>
<P>}</P>
<P></P>
<P></P>
<P>class PPSDirEntry</P>
<P>{</P>
<P>   PPSDirEntry()</P>
<P>    : m_pNext( NULL ), m_pOffsets( NULL ), m_tableSize( 0 ){}</P>
<P></P>
<P>   PPSDirEntry* m_pNext;</P>
<P>   DWord*       m_pOffsets;</P>
<P>   DWord        m_tableSize;</P>
<P>public:</P>
<P>   ~PPSDirEntry(){ delete m_pOffsets; m_pOffsets = NULL; }</P>
<P></P>
<P>friend class PPSPersistDirectory;</P>
<P>}; // class PPSDirEntry</P>
<P> </P>
<P>class PPSPersistDirectory</P>
<P>{</P>
<P>public:</P>
<P>   PPSPersistDirectory();</P>
<P></P>
<P>   ~PPSPersistDirectory();</P>
<P></P>
<P>   void  AddEntry( DWord cOffsets, DWord* pOffsets );</P>
<P>   DWord GetPersistObjStreamPos( DWord ref );</P>
<P>   DWord NumberOfAlreadySavedPersists();</P>
<P></P>
<P>private:</P>
<P>   PPSDirEntry* m_pFirstDirEntry;</P>
<P>}; </P>
<P></P>
<P></P>
<P>PPSPersistDirectory::PPSPersistDirectory() : m_pFirstDirEntry( NULL ){}</P>
<P></P>
<P>PPSPersistDirectory::~PPSPersistDirectory()</P>
<P>{</P>
<P>   while( m_pFirstDirEntry )</P>
<P>   {</P>
<P>      PPSDirEntry* pDirEntry = m_pFirstDirEntry;</P>
<P>      m_pFirstDirEntry = m_pFirstDirEntry-&gt;m_pNext;</P>
<P>      delete pDirEntry;</P>
<P>   }</P>
<P>}</P>
<P></P>
<P>void PPSPersistDirectory::AddEntry( DWord cOffsets, DWord* pOffsets )</P>
<P>{</P>
<P>   PPSDirEntry* pDirEntry = new PPSDirEntry();</P>
<P></P>
<P>   pDirEntry-&gt;m_tableSize = cOffsets;</P>
<P>   pDirEntry-&gt;m_pOffsets = new DWord[cOffsets];</P>
<P>   memcpy( pDirEntry-&gt;m_pOffsets, pOffsets, cOffsets * sizeof( DWord ) );</P>
<P></P>
<P>   // append to the end of the entry list</P>
<P>   PPSDirEntry** ppDirEntry = &amp;m_pFirstDirEntry;</P>
<P>   while( NULL != *ppDirEntry )</P>
<P>      ppDirEntry = &amp;(*ppDirEntry)-&gt;m_pNext;</P>
<P>   *ppDirEntry = pDirEntry;</P>
<P>}</P>
<P>   </P>
<P>DWord PPSPersistDirectory::GetPersistObjStreamPos( DWord ref )</P>
<P>{</P>
<P>   PPSDirEntry* pEntry = m_pFirstDirEntry;</P>
<P>   while( pEntry )</P>
<P>   {</P>
<P>      DWord* pOffsets = pEntry-&gt;m_pOffsets;</P>
<P>      while( (DWord)( (char*)pOffsets - (char*)pEntry-&gt;m_pOffsets ) &lt; pEntry-&gt;m_tableSize * sizeof( DWord ) )</P>
<P>      {</P>
<P>         DWord nRefs = pOffsets[0] &gt;&gt; 20;</P>
<P>         DWord base = pOffsets[0] &amp; 0xFFFFF; // 1-based</P>
<P>         if( ( base &lt;= ref )&amp;&amp;( ref &lt; base + nRefs ) ) </P>
<P>            return pOffsets[ 1 + ref - base ];</P>
<P>         pOffsets += nRefs + 1;</P>
<P>      }</P>
<P>      pEntry = pEntry-&gt;m_pNext;</P>
<P>   }</P>
<P>   return (DWord) -1;</P>
<P>} </P>
<P> </P>
<P>DWord PPSPersistDirectory::NumberOfAlreadySavedPersists()</P>
<P>{</P>
<P>   DWord count = 0;</P>
<P>   PPSDirEntry* pEntry = m_pFirstDirEntry;</P>
<P>   while( pEntry )</P>
<P>   {</P>
<P>      DWord* pOffsets = pEntry-&gt;m_pOffsets;</P>
<P>      while( (DWord)( pEntry-&gt;m_pOffsets - pOffsets ) &lt; pEntry-&gt;m_tableSize * sizeof( DWord ) )</P>
<P>      {</P>
<P>         DWord nRefs = pOffsets[0] &gt;&gt; 20;</P>
<P>         count += nRefs;</P>
<P>         pOffsets += nRefs + 1;</P>
<P>      }</P>
<P>      pEntry = pEntry-&gt;m_pNext;</P>
<P>   }</P>
<P>   return count;</P>
<P>}</P>
<P></P>
<P>void FileReader::PPSReadUserEditAtom( DWord offset, PSR_UserEditAtom&amp; userEdit )</P>
<P>{</P>
<P>   LARGE_INTEGER li;</P>
<P>   li.LowPart = offset;</P>
<P>   li.HighPart = 0;</P>
<P>   GetDocStream()-&gt;Seek(li,STREAM_SEEK_SET, NULL);</P>
<P>   RecordHeader rh;</P>
<P>   GetDocStream()-&gt;Read(&amp;rh, sizeof(rh), NULL);</P>
<P>   Assert( rh.recType == PST_UserEditAtom );</P>
<P>   Assert( rh.recLen == sizeof( PSR_UserEditAtom ) );</P>
<P>   li.LowPart = offset;</P>
<P>   GetDocStream()-&gt;Read(&amp;userEdit, sizeof(userEdit), NULL);</P>
<P>}</P>
<P></P>
<P></P>
<P>void *FileReader::ReadRecord( RecordHeader&amp; rh )</P>
<P>// Return values:</P>
<P>// NULL and rh.recVer == PSFLAG_CONTAINER: no record was read in.</P>
<P>//    record header indicated start of container.</P>
<P>// NULL and rh.recVer != PSFLAG_CONTAINER: client must read in record.</P>
<P>{</P>
<P>   IStream *pStm = GetDocStream();</P>
<P>   // read record header, verify</P>
<P>   pStm-&gt;Read(&amp;rh, sizeof(rh), NULL);  //AR: Check Error</P>
<P></P>
<P>   // if client will read, do not read in record</P>
<P>   if( DoesClientRead( rh.recType ) )</P>
<P>      return NULL;</P>
<P></P>
<P>   // If container, return NULL</P>
<P>   if(rh.recVer == PSFLAG_CONTAINER)</P>
<P>      return NULL;</P>
<P></P>
<P></P>
<P>   // Allocate buffer for disk record. Client must call ReleaseRecord() or</P>
<P>   // pass the atom up to CObject::ConstructContents() which will</P>
<P>   // then release it.   </P>
<P>   void* buffer = new char[rh.recLen];</P>
<P></P>
<P>   // read in record</P>
<P>   pStm-&gt;Read(buffer, rh.recLen, NULL);</P>
<P></P>
<P>   // NOTE: ByteSwapping &amp; versioning not done by this simple reader.</P>
<P>   return (buffer);</P>
<P>}</P>
<P></P>
<P>void FileReader::ReleaseRecord( RecordHeader&amp; rh, void* diskRecBuf )</P>
<P>{</P>
<P>   if(rh.recType &amp;&amp; rh.recVer!=PSFLAG_CONTAINER)</P>
<P>      delete [] (char*)diskRecBuf;</P>
<P>   rh.recType = 0;         // consume the record so that record doesn't</P>
<P>                           // get processed again.</P>
<P>}</P>
<P></P>
<P>void FileReader::ReadPersistDirectory()</P>
<P>{</P>
<P>   if( NULL != m_pLastUserEdit )</P>
<P>      return; // already read</P>
<P></P>
<P>   PSR_UserEditAtom userEdit;</P>
<P>   DWord offsetToEdit = m_currentUser.offsetToCurrentEdit;</P>
<P></P>
<P>   while( 0 &lt; offsetToEdit )</P>
<P>   {</P>
<P>      PPSReadUserEditAtom( offsetToEdit, userEdit );</P>
<P>      if( NULL == m_pLastUserEdit )</P>
<P>      {</P>
<P>         m_pPersistDirectory = new PPSPersistDirectory();</P>
<P>         m_pLastUserEdit     = new PSR_UserEditAtom;</P>
<P>         *m_pLastUserEdit = userEdit;</P>
<P>      }</P>
<P>      LARGE_INTEGER li;</P>
<P>      li.LowPart = userEdit.offsetPersistDirectory;</P>
<P>      li.HighPart = 0;</P>
<P>      GetDocStream()-&gt;Seek(li,STREAM_SEEK_SET, NULL); // AR: check that seek succeeded.</P>
<P>      RecordHeader rh;</P>
<P>      DWord *pDiskRecord = (DWord*) ReadRecord(rh);</P>
<P>      Assert( PST_PersistPtrIncrementalBlock == rh.recType );</P>
<P>      m_pPersistDirectory-&gt;AddEntry( rh.recLen / sizeof( DWord ), pDiskRecord );</P>
<P>      ReleaseRecord( rh, pDiskRecord );</P>
<P>      offsetToEdit = userEdit.offsetLastEdit;</P>
<P>   }</P>
<P>} // PPStorage::ReadPersistDirectory </P>
<P></P>
<P>void FileReader::ReadSlideList()</P>
<P>{</P>
<P>   Assert( m_pLastUserEdit != NULL );</P>
<P>   DWord offsetToDoc = m_pPersistDirectory-&gt;GetPersistObjStreamPos( m_pLastUserEdit-&gt;documentRef );</P>
<P>   LARGE_INTEGER li;</P>
<P>   li.LowPart = offsetToDoc;</P>
<P>   li.HighPart = 0;</P>
<P>   GetDocStream()-&gt;Seek(li,STREAM_SEEK_SET, NULL);</P>
<P>   ParseForSlideLists();</P>
<P>}</P>
<P></P>
<P>DWord FileReader::ParseForSlideLists()</P>
<P>{</P>
<P>   IStream *pStm = GetDocStream();</P>
<P></P>
<P>   RecordHeader rh;</P>
<P>   DWord nRd=0;</P>
<P>   // Stack based parsing for SlideLists</P>
<P>   pStm-&gt;Read(&amp;rh, sizeof(rh), &amp;nRd);</P>
<P>   if( ( rh.recVer != PSFLAG_CONTAINER ) &amp;&amp; ( (rh.recVer &amp; 0x0F)!=0x0F ) )</P>
<P>   {</P>
<P>      if( rh.recType == PST_SlidePersistAtom )</P>
<P>      {</P>
<P>         PSR_SlidePersistAtom spa;</P>
<P>         Assert( sizeof(spa) == rh.recLen );</P>
<P>         pStm-&gt;Read(&amp;spa, sizeof(spa), &amp;nRd);</P>
<P>         AddSlideToList( spa.psrReference );</P>
<P>      }</P>
<P>      else</P>
<P>      {</P>
<P>         LARGE_INTEGER li;</P>
<P>         li.LowPart = rh.recLen;</P>
<P>         li.HighPart = 0;</P>
<P>         pStm-&gt;Seek(li,STREAM_SEEK_CUR, NULL);</P>
<P>      }</P>
<P>      nRd += rh.recLen;</P>
<P>   }</P>
<P>   else</P>
<P>   {</P>
<P>      DWord nCur = 0;</P>
<P>      while( nCur &lt; rh.recLen )</P>
<P>      {</P>
<P>         nCur += ParseForSlideLists();</P>
<P>      }</P>
<P>      nRd += nCur;</P>
<P>   }</P>
<P>   return nRd;</P>
<P></P>
<P>}</P>
<P></P>
<P>BOOL FileReader::ReadText( WCHAR *pBuff, ULONG size, ULONG *pSizeRet )</P>
<P>{</P>
<P>   DWord offset;</P>
<P>   *pSizeRet = 0;</P>
<P>   m_pSizeRet = pSizeRet;</P>
<P>   m_pClientBuf = pBuff;</P>
<P>   m_clientBufSize = size;</P>
<P>   m_clientBufPos = 0;</P>
<P></P>
<P>   for( ;; )</P>
<P>   {</P>
<P>      if( ( m_pParseContexts == NULL ) )</P>
<P>      {</P>
<P>         if( FindNextSlide(offset) )</P>
<P>         {</P>
<P>            if( StartParse( offset ) )</P>
<P>               return TRUE;</P>
<P>         }</P>
<P>         else</P>
<P>            return FALSE; // DONE parsing, no more slides</P>
<P>      }</P>
<P>      else</P>
<P>      {</P>
<P>         if( m_pClientBuf )</P>
<P>         {</P>
<P>            if( FillBufferWithText() ) // Use existing text first.</P>
<P>               return TRUE;</P>
<P>         }</P>
<P>         if( Parse() ) // restart parse where we left off.</P>
<P>            return TRUE;</P>
<P>      }</P>
<P>   }</P>
<P>}</P>
<P></P>
<P>BOOL FileReader::StartParse( DWord offset )</P>
<P>{</P>
<P>   LARGE_INTEGER li;</P>
<P>   li.LowPart = offset;</P>
<P>   li.HighPart = 0;</P>
<P>   GetDocStream()-&gt;Seek(li,STREAM_SEEK_SET, NULL);</P>
<P>   m_pParseContexts = new ParseContext( NULL );</P>
<P>   GetDocStream()-&gt;Read(&amp;m_pParseContexts-&gt;m_rh, sizeof(RecordHeader), NULL);</P>
<P>   return Parse();</P>
<P>}</P>
<P></P>
<P>BOOL FileReader::Parse()</P>
<P>{</P>
<P>   IStream *pStm = GetDocStream();</P>
<P></P>
<P>   RecordHeader rh;</P>
<P>   DWord nRd=0;</P>
<P>   Assert( m_pParseContexts );</P>
<P>   // Restarting a parse might complete a container so we test this initially.</P>
<P>   if( m_pParseContexts-&gt;m_nCur &gt;= m_pParseContexts-&gt;m_rh.recLen )</P>
<P>   {</P>
<P>      Assert(  m_pParseContexts-&gt;m_nCur == m_pParseContexts-&gt;m_rh.recLen );</P>
<P>      ParseContext* pParseContext = m_pParseContexts;</P>
<P>      m_pParseContexts = m_pParseContexts-&gt;m_pNext;</P>
<P>      delete pParseContext;</P>
<P>   }</P>
<P></P>
<P>   do</P>
<P>   {</P>
<P>      pStm-&gt;Read(&amp;rh, sizeof(RecordHeader), NULL);</P>
<P>      if( ( rh.recVer != PSFLAG_CONTAINER ) &amp;&amp; ( (rh.recVer &amp; 0x0F)!=0x0F ) )</P>
<P>      {</P>
<P>         if( rh.recType == PST_TextCharsAtom )</P>
<P>         {</P>
<P>            m_curTextPos = 0;</P>
<P>            m_curTextLength = rh.recLen/2;</P>
<P>            Assert( m_pCurText == NULL );</P>
<P>            m_pCurText = new WCHAR[rh.recLen/2];</P>
<P>            pStm-&gt;Read(m_pCurText, rh.recLen, &amp;nRd);</P>
<P>            wprintf( L"-%s-\n", m_pCurText );</P>
<P>            if( FillBufferWithText() )</P>
<P>               return TRUE;   // Stop parsing if buffer is full, and return control to client</P>
<P>         }</P>
<P>         else if( rh.recType == PST_TextBytesAtom )</P>
<P>         {</P>
<P>            Assert( m_pCurText == NULL );</P>
<P>            m_curTextPos = 0;</P>
<P>            m_curTextLength = rh.recLen;</P>
<P>            m_pCurText = new WCHAR[rh.recLen];</P>
<P>            pStm-&gt;Read(m_pCurText, rh.recLen, &amp;nRd);</P>
<P>            char *pHack = (char *) m_pCurText;</P>
<P>            unsigned int back2 = rh.recLen*2-1;</P>
<P>            unsigned int back1 = rh.recLen-1;</P>
<P>            for(unsigned int i=0;i&lt;rh.recLen;i++)</P>
<P>            {</P>
<P>               pHack[back2-1] = pHack[back1];</P>
<P>               pHack[back2] = 0;</P>
<P>               back2 -=2;</P>
<P>               back1--;</P>
<P>            }</P>
<P>            if( FillBufferWithText() )</P>
<P>               return TRUE;   // Stop parsing if buffer is full, and return control to client</P>
<P>         }</P>
<P>         else</P>
<P>         {</P>
<P>            LARGE_INTEGER li;</P>
<P>            ULARGE_INTEGER ul;</P>
<P>            li.LowPart = rh.recLen;</P>
<P>            li.HighPart = 0;</P>
<P>            pStm-&gt;Seek(li,STREAM_SEEK_CUR,&amp;ul);</P>
<P>         }</P>
<P>         m_pParseContexts-&gt;m_nCur += rh.recLen;</P>
<P>         m_pParseContexts-&gt;m_nCur += sizeof( RecordHeader ); // Atom rh's add towards containing container's size.</P>
<P>      }</P>
<P>      else</P>
<P>      {</P>
<P>         m_pParseContexts = new ParseContext( m_pParseContexts );</P>
<P>         m_pParseContexts-&gt;m_rh = rh;</P>
<P>      }</P>
<P>      if( m_pParseContexts-&gt;m_nCur &gt;= m_pParseContexts-&gt;m_rh.recLen )</P>
<P>      {</P>
<P>         Assert(  m_pParseContexts-&gt;m_nCur == m_pParseContexts-&gt;m_rh.recLen );</P>
<P>         ParseContext* pParseContext = m_pParseContexts;</P>
<P>         m_pParseContexts = m_pParseContexts-&gt;m_pNext;</P>
<P>         delete pParseContext;</P>
<P>      }</P>
<P>   } while( m_pParseContexts &amp;&amp; ( m_pParseContexts-&gt;m_nCur &lt; m_pParseContexts-&gt;m_rh.recLen ) );</P>
<P></P>
<P>   return FALSE;</P>
<P>}</P>
<P></P>
<P>BOOL FileReader::FindNextSlide( DWord&amp; offset )</P>
<P>{</P>
<P>   if( m_curSlideNum == 0 )</P>
<P>   {</P>
<P>      Assert( m_pLastUserEdit != NULL );</P>
<P>      offset = m_pPersistDirectory-&gt;GetPersistObjStreamPos( m_pLastUserEdit-&gt;documentRef );</P>
<P>      m_curSlideNum++;</P>
<P>      return TRUE;</P>
<P>   }</P>
<P>   else</P>
<P>   {</P>
<P>      uint4 curSlideNum = m_curSlideNum++; </P>
<P>      SlideListChunk *pCur = m_pFirstChunk;</P>
<P>      while( pCur &amp;&amp; ( curSlideNum &gt; pCur-&gt;numInChunk ) )</P>
<P>      {</P>
<P>         curSlideNum -= pCur-&gt;numInChunk;</P>
<P>         pCur = pCur-&gt;pNext;</P>
<P>      }</P>
<P>      if( pCur == NULL )</P>
<P>         return FALSE;</P>
<P>      offset = m_pPersistDirectory-&gt;GetPersistObjStreamPos( pCur-&gt;refs[curSlideNum-1] );</P>
<P>      return TRUE;</P>
<P>   }</P>
<P>}</P>
<P></P>
<P>static BOOL ReadText( void** ppContext, IStorage* pStgFrom, WCHAR* buffer, unsigned long bufferSize, unsigned long* pSizeRet )</P>
<P>{</P>
<P>   FileReader* pFI = NULL;</P>
<P>   if( *ppContext == NULL )</P>
<P>   {</P>
<P>      pFI = new FileReader( pStgFrom );</P>
<P>      *ppContext = pFI;</P>
<P>      if( !pFI-&gt;IsPowerPoint() )</P>
<P>      {</P>
<P>         delete pFI;</P>
<P>         *pSizeRet = 0;</P>
<P>         return FALSE;</P>
<P>      }</P>
<P>      pFI-&gt;ReadPersistDirectory();</P>
<P>      pFI-&gt;ReadSlideList();</P>
<P>   }</P>
<P>   else</P>
<P>   {</P>
<P>      pFI = (FileReader *)*ppContext;</P>
<P>   }</P>
<P>   BOOL bRet = pFI-&gt;ReadText(buffer, bufferSize, pSizeRet);</P>
<P>   if( !bRet )</P>
<P>   {</P>
<P>      delete pFI;</P>
<P>      *ppContext = NULL;</P>
<P>   }</P>
<P>   return bRet;</P>
<P>}</P>
<P></P>
<P>void main(int argc, char **argv)</P>
<P>{</P>
<P>    OLECHAR wc[256];</P>
<P>    HRESULT hr;</P>
<P>    IStorage *pStgFrom = NULL;</P>
<P></P>
<P>    if (argc &lt; 2)</P>
<P>    {</P>
<P>        fprintf(stderr,"Usage dblock &lt;file to be read&gt;\n");</P>
<P>        exit(0);</P>
<P>    }</P>
<P>    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, argv[1], -1, wc, 255);</P>
<P>     hr = StgOpenStorage(wc, NULL, STGM_READ | STGM_DIRECT | </P>
<P>               STGM_SHARE_DENY_WRITE, NULL, 0, &amp;pStgFrom);</P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        fprintf(stderr,"Error (%d) opening docfile: %s\n",(int)hr,argv[1]);</P>
<P>    }</P>
<P>   else</P>
<P>   {</P>
<P>      WCHAR wcBuf[6];</P>
<P>      ULONG sizeUsed;</P>
<P>      BOOL fContinue = TRUE;</P>
<P>      void *pContext = NULL;</P>
<P>      while( fContinue )</P>
<P>      {</P>
<P>         fContinue = ReadText( &amp;pContext, pStgFrom, wcBuf, 5, &amp;sizeUsed );</P>
<P>         wcBuf[sizeUsed] = 0;</P>
<P>         wprintf(L"-%s-\n", wcBuf);</P>
<P>      }</P>
<P>   }</P>
<P>}</P>
</P>
</P></FONT></BODY>
</HTML>
