<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Arrays of Data Structures</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Using Arrays of Data Structures</H2><P CLASS="t">You cannot use the SafeArrayCreate function to create a new array of user-defined structures. Instead, you must use the SafeArrayAllocDescriptor function to create the array descriptor, then use the SafeArrayAllocData function to allocate space for the array data, and finally use the SafeArrayAccessData function to return a pointer to the data. The SafeArrayAccessData function locks the array data; when you are done with the array, you should call the SafeArrayUnaccessData function to unlock it.</P>
<P CLASS="t">You cannot replace an existing array, so if your Visual Basic code passes a dimensioned array, you must redimension it. Remember to free any existing BSTR&nbsp;pointers in the array before overwriting them.</P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">The following example creates or redimensions an array of data structures and then copies an array of strings into the structures, adding the string length to each structure. Any existing BSTR data in the array is freed before new data is copied into the array.</P>

<pre><code><FONT FACE="Courier" SIZE="2">short WINAPI StructArray(LPSAFEARRAY *ppsaArg, 
    LPSAFEARRAY *ppsaStr)
{
    ARG *parg;
    SAFEARRAY *psa;
    BSTR *pbstr;
    unsigned long i, cElements;
    #define BUFF_SIZE 1024
    TCHAR szBuff[BUFF_SIZE];

    if (*ppsaStr == NULL)
        return -1;

    cElements = (*ppsaStr)-&gt;rgsabound[0].cElements;

    if (*ppsaArg == NULL) // create a new array
    {

        if (FAILED(SafeArrayAllocDescriptor(1, &amp;psa)))
            return -3;

        // set up the SAFEARRAY structure
        // and allocate data space

        psa-&gt;fFeatures = 0;
        psa-&gt;cbElements = sizeof(ARG);
        psa-&gt;rgsabound[0].cElements = cElements;
        psa-&gt;rgsabound[0].lLbound = (*ppsaStr)-&gt;rgsabound[0].lLbound;

        if (FAILED(SafeArrayAllocData(psa))) 
        {
            SafeArrayDestroyDescriptor(psa);
            return -4;
        }

        // get a pointer to the new data

        if (FAILED(SafeArrayAccessData(psa, 
                (void HUGEP* FAR*)&amp;parg))) 
        {
            SafeArrayDestroy(psa);
            return -5;</FONT></code></pre>
<P></P>
<P></P>
<P></P>

<pre><code><FONT FACE="Courier" SIZE="2">        }
    } 
    else // fail since we can't redimension
    {
            return -6;

        // get a pointer to the old data

        if (FAILED(SafeArrayAccessData(*ppsaArg, 
                (void HUGEP* FAR*)&amp;parg)))
            return -7;
    }

    // get a pointer to the string array data

    if (FAILED(SafeArrayAccessData(*ppsaStr, 
            (void HUGEP* FAR*)&amp;pbstr)))
        return -8;

    // allocate strings in the structure array and 
    // fill them with strings from the string array.
    // free any old BSTRs in the structure

    for (i = 0; i &lt; cElements; i++) 
    {
        SysFreeString(parg[i].bstr);//SysStringByteLen(pbstr[i])
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR)pbstr[i], -1, 
            szBuff, sizeof(szBuff));
        parg[i].bstr = SysAllocString(szBuff);
        parg[i].i = SysStringLen(parg[i].bstr);
    }

    // release pointers and move the structure
    // array pointer to the new array if we created one

    SafeArrayUnaccessData(*ppsaStr);
    
    if (*ppsaArg == NULL) 
    {
        SafeArrayUnaccessData(psa);
        *ppsaArg = psa;
    }
    else 
        SafeArrayUnaccessData(*ppsaArg);
        
    return 0;
}
</FONT></code></pre>
<P></P>
<P></P>
<P></P>
<P CLASS="t">Declared and called from Visual Basic:</P>

<pre><code><FONT FACE="Courier" SIZE="2">Declare Function StructArray Lib "debug\ADVDLL.DLL" _
    (x() As ARG, s() As String) As Integer

Sub StructArrayTest()
    Dim x() As ARG
    Dim s(1 To 4) As String
    s(1) = "yellow"
    s(2) = "orange"
    s(3) = "blue"
    s(4) = "green"
    n = StructArray(x, s)
    If n = 0 Then
        Worksheets(1).Activate
        Range("a1:c25").Clear
        For i = LBound(x) To UBound(x)
            Cells(i + 1, 1) = i
            Cells(i + 1, 2) = x(i).str
            Cells(i + 1, 3) = x(i).i
        Next
    Else
        MsgBox "StructArray failed, returned" &amp; n
    End If
End Sub
</FONT></code></pre>
<P CLASS="t">You will note in this code that we use MultiByteToWideChar on the string before we place it into the structure. This is the one exception to the rule that Excel passes and returns ANSI strings. Strings returned to Excel inside a structure must be UNICODE. This function converts the strings to UNICODE before creating a BSTR to place in the structure.</P></FONT>
</FONT></BODY></HTML>
