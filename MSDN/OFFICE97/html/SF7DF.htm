<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Performance</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Performance</H2><P CLASS="t">OLE Automation gained a reputation early on for being slow and unwieldy. This was due to the initial implementation of OLE Automation only supporting late binding. OLE 2.0 currently supports three types of binding:</P>
<P CLASS="ls">    1.    Late Binding</P>
<P CLASS="ls">    2.    ID Binding</P>
<P CLASS="ls">    3.    Early or Vtable Binding</P>
<P></P>
<P CLASS="t">To understand why the various types of bindings perform differently, you need to&nbsp;understand a little bit about the implementation of OLE Automation. OLE Automation controllers use the OLE IDispatch interface to gain access to OLE objects. IDispatch identifies all members (methods and properties) by a number, the Dispatch ID (DISPID). Programmers, on the other hand, know object members by name. The resolving of these names to determine which functions to call (known as <I>binding</I>) is the main performance impediment in OLE Automation. Each of the binding types mentioned above implement this binding in different manners.</P>
<H3><A NAME="sec0"></A>Late Binding</H3><P CLASS="t">Late binding is the slowest method and the one that gave OLE Automation a reputation for slowness. In late binding, the OLE Automation controller knows nothing about the object at compile time. At run time, all of the binding information is determined on the fly. The controller determines the DISPIDs by calling the IDispatch::GetIDsOfNames function. After determining the DISPID of the function it wants to call, it then call IDispatch::Invoke specifying the DISPID. In addition to being slow, this method provides no validity or syntax checking at compile time, since the information is determined on the fly at run time.</P>
<H3><A NAME="sec1"></A>ID Binding</H3><P CLASS="t">ID Binding is the next-fastest binding method for OLE Automation. In ID binding a type library is provided for the OLE Automation controller. This type library documents each of the DISPIDs of the various members. At compile time, the DISPIDs are determined and compiled into the application. When calling, the member function only needs to call IDispatch::Invoke, bypassing a call to IDispatch::GetIDsOfNames. This method is almost twice as fast as late binding.</P>
<P></P>
<P></P>
<P></P>
<H3><A NAME="sec2"></A>Early/Vtable Binding</H3><P CLASS="t">Early binding (also known as Vtable Binding) is the fastest OLE Automation method. Early binding totally bypasses the entire IDispatch interface and allows the controller to bind directly to the members in the object. Early binding does not&nbsp;use DISPIDs and will not work on a straight IDispatch implementation. The developer of the object must have provided a dual interface that is a combination of an IDispatch and a VTable interface. At compile time the type library for the object is read to determine the location in the VTable of each member. Code is then generated to directly call the function through the VTable. Early binding provides compile time type checking and, if an in-process OLE server is used, offers significant performance gains over the other binding methods. This is because there is no need to marshal arguments for the IDispatch::Invoke, no indirection through the Invoke call, and no marshaling is required in the server to&nbsp;unpack the various arguments before calling the member. Marshaling is the process of packing and unpacking arguments for a remote procedure call. With VTable binding on an in-process server, each member access equates to a direct function call. On an out-of-process OLE Server (EXE), this process will be slightly slower due to the overhead of the remoting code required to call the function in another process.</P>
<P CLASS="t">An interesting tidbit is that the main communication method for VBA is OLE Automation! Don't let performance be the determining factor in your choice of the C API over OLE Automation. Well-written OLE Automation code can be just&nbsp;as fast as code that uses the C API.</P></FONT>
</FONT></BODY></HTML>
