<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Recordset Objects</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="usingrecordsetobjects"></a>Using Recordset Objects</h2>
<p>
A <b>Recordset</b> object represents the records in a base table or the records that result from running a query. You use <b>Recordset</b> objects to manipulate the data in a database at the record level. </p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You use <b>Field</b> objects to manipulate the data in a database at the field level. For more information, see “Using Field Objects” later in this chapter.</p>
<p>
The four types of <b>Recordset</b> objects—<i>table</i>, <i>dynaset</i>, <i>snapshot</i>, and <i>forward-only</i>—differ from each other in significant ways:
<ul>
<li>
A table-type <b>Recordset</b> object can be created from a table in a Microsoft Access database, but not from an Open Database Connectivity (ODBC) or a linked table. When you create a table-type <b>Recordset</b>, the Jet database engine opens the actual table, and your subsequent data manipulations operate directly on base-table data. A table-type <b>Recordset</b> can be opened on only one table; it cannot be opened on a union query or a select query with a join.<p>
One of the biggest advantages of this type of <b>Recordset</b> object is that you can index it by using an index created for the underlying table. This allows much faster sorting and searching than is possible with the other types. To locate specific records, use the <b>Seek</b> method, which is faster than the Find methods.</p>
</li>
<li>
A dynaset-type <b>Recordset</b> object can be created from either a local or a linked table, or with a row-returning query that joins tables. It’s actually a set of references to records in one or more tables. With a dynaset, you can extract and update data from more than one table, including linked tables from other databases. Heterogeneous updatable joins are a unique feature of dynasets—they enable you to use updatable queries against tables in different types of databases.<p>
One of the main benefits of this type is that a dynaset and its underlying tables update each other. Changes made to records in the dynaset are also made in the underlying table, and changes made by other users to data in the underlying tables while the dynaset is open are reflected in the dynaset. The dynaset is the most flexible and powerful type of <b>Recordset</b> object, although searches and other manipulations may not run as fast as with a table-type <b>Recordset</b>.</p>
</li>
<li>
A snapshot-type <b>Recordset</b> object is a static copy of a set of records as it exists at the time the snapshot is created. A snapshot-type <b>Recordset</b> object can contain fields from one or more tables in a database. You can’t update a snapshot.<p>
The main advantage of a snapshot is that it creates less processing overhead than the other types, so it can run queries and return data faster, especially when working with ODBC data sources. </p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;For .mdb files, OLE Object and Memo fields are represented in a snapshot by pointers, rather than the actual data. For more information on OLE Object and Memo fields, see “The OLE Object and Memo Data Types” later in this chapter.</p>
</li>
<li>
A forward-only-type <b>Recordset</b> object, sometimes referred to as a <i>forward-scrolling snapshot</i> or a <i>forward-only snapshot</i>, provides a subset of the capabilities of a snapshot. With forward-only snapshots, you can move only in a forward direction through the records. <b>Recordset</b> objects of this type cannot be cloned and only support the <b>Move</b> and <b>MoveNext</b> methods. Like snapshots, you can’t update a forward-only-type <b>Recordset</b> object.<p>
The advantage of a forward-only-type <b>Recordset</b> object is that it usually provides the greatest speed. It does, however, offer the least functionality of any <b>Recordset</b>.</p>
</li>
</ul>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;A snapshot stores a copy of the entire record (except for OLE Object and Memo fields). A dynaset stores just the primary key for each record, copying the full record only when it’s needed for editing or display purposes. Since a snapshot stores a complete copy of all the records in a table, a snapshot may perform more slowly than a dynaset if the number of records is large. To determine whether a snapshot or dynaset is faster, you can open the <b>Recordset</b> as a dynaset and then open it as a snapshot to see which provides faster performance.</p>
<p>
The type of <b>Recordset</b> object you use depends on what you want to do and whether you want to change or simply view the data. For example, if you must sort the data or work with indexes, use a table. Because table-type <b>Recordset</b> objects are indexed, they also provide the fastest way to locate data. If you want to be able to update a set of records selected by a query, use a dynaset. If the table-type is unavailable and you only need to scan through a set of records, using a forward-only snapshot may improve performance.</p>
<p>
All other things being equal, if a table-type <b>Recordset </b>object is available, using it almost always results in the best performance.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;In this chapter, the terms table, snapshot, and dynaset are often used for the sake of simplicity. However, keep in mind that these are all types of <b>Recordset</b> objects. For example, the term dynaset refers to a dynaset-type <b>Recordset</b> object, not the obsolete DAO <b>Dynaset</b> object.</p>
<h3>Creating a Recordset Object Variable</h3>
<p>
To create a <b>Recordset</b> object variable, use the <b>OpenRecordset</b> method. First, declare a variable of type <b>Recordset</b>, and then set the variable to the object returned by the <b>OpenRecordset</b> method.</p>
<p>
You can use the <b>OpenRecordset</b> method with <b>Database</b>, <b>TableDef</b>, <b>QueryDef</b>, and existing <b>Recordset</b> objects. The syntax of the <b>OpenRecordset </b>method for <b>Database</b> object is:</p>
<p>
<b>Set</b> <i>variable</i> <b>=</b> <i>database</i><b>.OpenRecordset</b> <b>(</b><i>source</i> [, <i>type</i> [, <i>options</i> [, <i>lockedits</i> ]]]<b>)</b></p>
<p>
The syntax of the <b>OpenRecordset</b> method for all other types of objects is:</p>
<p>
<b>Set</b> <i>variable</i> <b>=</b> <i>object</i><b>.OpenRecordset</b> <b>(</b>[<i>type</i> [, <i>options</i> [, <i>lockedits</i> ]]]<b>)</b></p>
<p>
The <i>variable</i> argument is the name of the new <b>Recordset</b> object. The <i>database</i> argument is the name of the open <b>Database</b> object from which you’re creating the new <b>Recordset</b> object. The <i>object</i> argument is the <b>TableDef</b>, <b>QueryDef</b>, or existing <b>Recordset</b> object from which you’re creating the new <b>Recordset </b>object.</p>
<p>
The <i>source</i> argument specifies the source of the records for the new <b>Recordset </b>object. The value of <i>source</i> is the value of the resulting <b>Recordset</b> object’s DAO <b>Name</b> property. When you create a new <b>Recordset </b>object from a <b>Database</b> object, the <i>source</i> argument is a <b>TableDef </b>or <b>QueryDef</b> object in the database or a valid row-returning SQL query or statement. When you create a new <b>Recordset</b> object from a <b>TableDef</b>, <b>QueryDef</b>, or existing <b>Recordset</b> object, the object itself provides the data source for the new <b>Recordset</b>.</p>
<p>
The <i>type</i> argument is an intrinsic constant that specifies the kind of <b>Recordset</b> object that you want to create. You can use the following constants:
<ul>
<li>
<b>dbOpenTable</b></li>
<li>
<b>dbOpenDynaset</b></li>
<li>
<b>dbOpenSnapshot</b></li>
<li>
<b>dbOpenForwardOnly</b></li>
</ul>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The <b>dbOpenForwardOnly</b> type constant replaces the <b>dbForwardOnly</b> type constant that was available in previous versions of DAO. You can still use the <b>dbForwardOnly</b> constant, but it’s provided only for backward compatibility.</p>
<p>
The following sections discuss the <i>type</i>,<i> options</i>, and <i>lockedits</i> arguments in detail.</p>
<h4>Default Recordset Types</h4>
<p>
Because DAO automatically chooses the default <b>Recordset</b> type depending on the data source and how the <b>Recordset</b> is opened, you don’t need to specify a <b>Recordset</b> type. However, you can specify a type different from the default by using a <i>type</i> argument in the <b>OpenRecordset</b> method.</p>
<p>
The following list describes the available types and the default type, depending on how you open the <b>Recordset</b> object:
<ul>
<li>
Using the <b>OpenRecordset</b> method with a <b>Database</b> object:<pre><code>Set rstNew = dbs.OpenRecordset(&quot;Data Source&quot;)
</code></pre>
<p>
If <code>Data Source</code> is a table local to the database, all four types are available, and the table-type <b>Recordset</b> object is the default. If <code>Data Source</code> is anything else, only dynaset- and snapshot-type <b>Recordset</b> objects are available, and the dynaset type is the default.</p>
</li>
<li>
Using the<b> OpenRecordset</b> method with a <b>TableDef</b> object:<pre><code>Set rstNew = tdfTableData.OpenRecordset
</code></pre>
<p>
If <code>tdfTableData</code> refers to a table in a Microsoft Access database (.mdb) or to an installable ISAM database opened directly, then all four types are available and the table-type <b>Recordset</b> object is the default type. If <code>tdfTableData</code> is in an ODBC database or is a linked table in an external database, only dynaset- and snapshot-type <b>Recordset</b> objects are available, and the dynaset type is the default.</p>
</li>
<li>
Using the<b> OpenRecordset</b> method with a <b>QueryDef</b> object:<pre><code>Set rstNew = qdfQueryData.OpenRecordset
</code></pre>
<p>
Only dynaset- and snapshot-type <b>Recordset</b> objects are available, and the dynaset type is the default.</p>
</li>
<li>
Using the<b> OpenRecordset</b> method with an existing <b>Recordset</b> object:<pre><code>Set rstNew = rstExisting.OpenRecordset
</code></pre>
<p>
Only dynaset- and snapshot-type <b>Recordset</b> objects are available. The default is the type of the existing <b>Recordset</b>, in this case, the type of <code>rstExisting</code>.</p>
</li>
</ul>
<h4>OpenRecordset Options</h4>
<p>
With the <i>options</i> argument of the <b>OpenRecordset</b> method, you can specify a number of other features for a <b>Recordset</b> object. You can use the following constants:
<ul>
<li>
<b>dbAppendOnly</b>   Users can append new records to the <b>Recordset</b>, but they cannot edit or delete existing records. This is useful in applications that collect and archive data (dynaset only).</li>
<li>
<b>dbReadOnly</b>   No changes can be made to the <b>Recordset</b>. This argument is provided only for backward compatibility. Use the <b>dbReadOnly</b> constant in the <i>lockedits</i> argument instead.</li>
<li>
<b>dbSeeChanges</b>   If another user changes data in a record on which this <b>Recordset</b> has invoked the <b>Edit</b> method, but before it has invoked the <b>Update</b> method, a run-time error occurs. This is useful in applications where multiple users have simultaneous read/write permission on the same data (dynaset and table only).</li>
<li>
<b>dbDenyWrite</b>   When used on a dynaset or snapshot, this option prevents other users from adding or modifying records, although they can still read data. When used on a table, no other user can open any type of <b>Recordset</b> from an underlying table.</li>
<li>
<b>dbDenyRead</b>   Other users cannot read data in the table (table only).</li>
<li>
<b>dbForwardOnly</b>   This option creates a forward-only snapshot. It is provided only for backward compatibility. Use the <b>dbOpenForwardOnly</b> constant in the <i>type</i> argument instead.</li>
<li>
<b>dbSQLPassThrough</b>   When the <i>source</i> argument is an SQL statement, use this constant to pass the SQL statement to an ODBC database for processing. If used with a dynaset, data isn’t updatable (dynaset and snapshot only).</li>
<li>
<b>dbConsistent</b>   (Default) Only consistent updates are allowed (dynaset only). You can’t use this constant with the <b>dbInconsistent</b> constant.</li>
<li>
<b>dbInconsistent</b>   Inconsistent updates are allowed. This is the opposite of <b>dbConsistent</b> (dynaset only). You can’t use this constant with the <b>dbConsistent</b> constant.<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on inconsistent updates, see “Inconsistent Updates” later in this chapter.</p>
</li>
</ul>
<p>
With the <i>lockedits </i>argument of the <b>OpenRecordset</b> method, you can control how locking is handled for a <b>Recordset</b> object. You can use the following constants:
<ul>
<li>
<b>dbReadOnly</b>   No changes can be made to the <b>Recordset</b>. This constant replaces the <b>dbReadOnly</b> constant that was used in the <i>options</i> argument in previous versions of DAO.</li>
<li>
<b>dbPessimistic</b>   (Default) Microsoft Jet uses pessimistic locking to determine how changes are made to the <b>Recordset</b> in a multiuser environment.</li>
<li>
<b>dbOptimistic</b>   Microsoft Jet uses optimistic locking to determine how changes are made to the <b>Recordset</b> in a multiuser environment.</li>
</ul>
<p>
The default value is <b>dbPessimistic</b>. The only effect of using <b>dbPessimistic</b> or <b>dbOptimistic</b> is to preset the value of the <b>Recordset</b> object’s <b>LockEdits</b> property.</p>
<p>
Important   Setting both the <i>lockedits</i> argument and the <i>options</i> argument to <b>dbReadOnly</b> generates a run-time error.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on optimistic and pessimistic locking, see Chapter 10, “Creating Multiuser Applications.” For information on using <b>Recordset </b>objects in client/server applications, see Chapter 19, <a href="developingclientserverapplications.htm">“Developing Client/Server Applications.”</a></p>
<h4>Creating a Recordset Object from a Form</h4>
<p>
You can create a <b>Recordset</b> object based on a Microsoft Access form. To do so, use the <b>RecordsetClone</b> property of the form. This creates a dynaset-type <b>Recordset</b> that refers to the same underlying query or data as the form. If a form is based on a query, referring to the <b>RecordsetClone</b> property is the equivalent of creating a dynaset with the same query. You can use the <b>RecordsetClone</b> property when you want to apply a method that can’t be used with forms, such as the <b>FindFirst</b> method. The <b>RecordsetClone</b> property provides access to all the methods and properties that you can use with a dynaset. The syntax for the <b>RecordsetClone</b> property is:</p>
<p>
<b>Set</b> <i>variable</i> <b>=</b> <i>form</i><b>.RecordsetClone</b></p>
<p>
The <i>variable</i> argument is the name of an existing <b>Recordset</b> object. The <i>form</i> argument is the name of a Microsoft Access form. The following example shows how to assign a <b>Recordset</b> object to the records in the Orders form:</p>
<pre><code>Dim rstOrders As Recordset

Set rstOrders = Forms!Orders.RecordsetClone
</code></pre>
<p>
This code always creates the type of <b>Recordset</b> being cloned (the type of <b>Recordset</b> on which the form is based); no other types are available.</p>
<h4>Creating a Recordset Object from a Table</h4>
<p>
The method you use to create a <b>Recordset</b> object from a table depends on whether the table is local to the current database or is a linked table in another database. The following discussion explains the differences and provides examples for each type of table.</p>
<h5>Creating a Recordset from a Table in a Local Microsoft Access Database</h5>
<p>
The following example uses the <b>OpenRecordset</b> method to create a table-type <b>Recordset</b> object for a table in the current database:</p>
<pre><code>Dim dbs As Database, rstCustomers As Recordset

Set dbs = CurrentDb
Set rstCustomers = dbs.OpenRecordset(&quot;Customers&quot;)
</code></pre>
<p>
Notice that you don’t need to use the <b>dbOpenTable</b> constant to create a table-type <b>Recordset</b>. If you omit the <i>type</i> constant, as discussed in “Default Recordset Types” earlier in this chapter, DAO chooses the highest-functionality <b>Recordset</b> type available, depending on the object in which the <b>Recordset</b> is created, and the data source. Because the table type is available when you open a <b>Recordset</b> from a local table, DAO uses it.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on connecting to data in external databases, see Chapter&nbsp;18, <a href="accessingexternaldata.htm">“Accessing External Data.”</a></p>
<h5>Creating a Recordset from a Linked Table in a Different Database Format</h5>
<p>
The following example creates a dynaset-type <b>Recordset</b> object for a linked Paradox&reg; version 3.<i>x</i> table. Because the table type isn’t available when you open a <b>Recordset</b> from a linked table in a database other than a Microsoft Access database, DAO selects the next most efficient type, opening a dynaset-type <b>Recordset</b>.</p>
<pre><code>Dim dbs As Database
Dim tdf As TableDef
Dim rstTableData As Recordset

' Get current database.
Set dbs = CurrentDb
Set tdf = dbs.CreateTableDef(&quot;PDXAuthor&quot;)

' Connect to the Paradox table Author in the database 
' C:\PDX\Publish.
tdf.Connect = &quot;Paradox 3.X;DATABASE=C:\PDX\Publish&quot;
tdf.SourceTableName = &quot;Author&quot;

' Link the table.
dbs.TableDefs.Append tdf

' Create a dynaset-type Recordset for the table.
Set rstTableData = tdf.OpenRecordset()
</code></pre>
<p>
You can also open a Paradox table directly by first opening the Paradox database.</p>
<h5>Using an Index on a Table-Type Recordset Object</h5>
<p>
You can order records in a table-type <b>Recordset</b> object by setting its <b>Index</b> property. Any <b>Index</b> object in the <b>Indexes</b> collection of the <b>Recordset</b> object’s underlying table definition can be specified with the <b>Index</b> property.</p>
<p>
The following example creates a table-type <b>Recordset</b> object based on the Customers table, by using an existing index called City:</p>
<pre><code>Dim dbs As Database, rstTableData As Recordset

Set dbs = CurrentDb
Set rstTableData = dbs.OpenRecordset(&quot;Customers&quot;, dbOpenTable)

' Move to the first record.
rstTableData.MoveFirst

' First record with no index set.
MsgBox rstTableData!CompanyName 
rstTableData.Index = &quot;City&quot;&#09;&#09;&#09;' Select the City index.
rstTableData.MoveFirst&#09;&#09;&#09;&#09;' Move to the first record.
MsgBox rstTableData!CompanyName
rstTableData.Close
</code></pre>
<p>
If you set the <b>Index</b> property to an index that doesn’t exist, a trappable run-time error occurs. If you want to sort records according to an index that doesn’t exist, either create the index first, or create a dynaset- or snapshot-type <b>Recordset</b> by using a query that returns records in a specified order.</p>
<p>
Important   You must set the <b>Index</b> property before using the <b>Seek</b> method. For information on using the <b>Seek</b> method to locate records that satisfy criteria that you specify, see “Finding a Record in a Table-Type Recordset Object” later in this chapter.</p>
<h4>Creating a Recordset Object from a Query</h4>
<p>
You can also create a <b>Recordset</b> object based on a stored select query. In the following example, Current Product List is an existing select query stored in the current database:</p>
<pre><code>Dim dbs As Database, rstProducts As Recordset

Set dbs = CurrentDb
Set rstProducts = dbs.OpenRecordset(&quot;Current Product List&quot;)
</code></pre>
<p>
If a stored select query doesn’t already exist, the <b>OpenRecordset </b>method also accepts an SQL string instead of the name of a query. The previous example can be rewritten as follows:</p>
<pre><code>Dim dbs As Database, rstProducts As Recordset
Dim strQuerySQL As String

Set dbs = CurrentDb
strQuerySQL = &quot;SELECT * FROM Products WHERE Discontinued = No &quot; _
&#09;&amp; &quot;ORDER BY ProductName;&quot;
Set rstProducts = dbs.OpenRecordset(strQuerySQL)
</code></pre>
<p>
The disadvantage of this approach is that the query string must be compiled each time it’s run, whereas the stored query is compiled the first time it’s saved, which usually results in slightly better performance.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;When you create a <b>Recordset</b> object by using an SQL string or a stored query, your code doesn’t continue running until the query returns the first row in the <b>Recordset</b>.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on SQL statements, search the Help index for “SQL statements.”</p>
<h4>Sorting and Filtering Records</h4>
<p>
Unless you open a table-type <b>Recordset</b> object and set its <b>Index</b> property, you can’t be sure records will appear in any specific order. However, you usually want to retrieve records in a specific order. For example, you may want to view invoices arranged by increasing invoice number, or retrieve employee records in alphabetic order by their last names. To see records in a specific order, <i>sort</i> them.</p>
<p>
To sort data in a <b>Recordset</b> object that isn’t a table, use an SQL ORDER BY clause in the query that constructs the <b>Recordset</b>. You can specify an SQL string when you create a <b>QueryDef</b> object, when you create a stored query in a database, or when you use the <b>OpenRecordset</b> method.</p>
<p>
You can also <i>filter</i> data, which means you restrict the result set returned by a query to records that meet some criteria. With any type of <b>Recordset</b> object, use an SQL WHERE clause in the original query to filter data.</p>
<p>
The following example opens a dynaset-type <b>Recordset</b> object, and uses an SQL statement to retrieve, filter, and sort records:</p>
<pre><code>Dim dbs As Database, rstManagers As Recordset

Set dbs = CurrentDb
Set rstManagers = dbs.OpenRecordset(&quot;SELECT FirstName, LastName FROM &quot; _
&#09;&amp; &quot;Employees WHERE Title = 'Sales Manager' ORDER BY LastName&quot;)
</code></pre>
<p>
One drawback of running an SQL query in an <b>OpenRecordset</b> method is that it has to be recompiled every time you run it. If this query is used frequently, you can improve performance by first creating a stored query using the same SQL statement, and then opening a <b>Recordset</b> object against the query, as shown in the following example:</p>
<pre><code>Dim dbs As Database
Dim rstSalesReps As Recordset
Dim qdf As QueryDef

Set dbs = CurrentDb

Set qdf = dbs.CreateQueryDef(&quot;SalesRepQuery&quot;)
qdf.SQL = &quot;SELECT * FROM Employees WHERE Title = 'Sales Representative';&quot;

Set rstSalesReps = dbs.OpenRecordset(&quot;SalesRepQuery&quot;)
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;For even greater flexibility and control at run time, you can use query parameters to determine the sort order and filter criteria. For more information, see “Using Parameter Queries” later in this chapter.</p>
<h5>Recreating a Query from a Recordset Object</h5>
<p>
You can also use a <b>Recordset</b> object opened from a <b>QueryDef </b>object as a template to re-create the <b>QueryDef</b> object. To do this, use the <b>CopyQueryDef</b> method. This is useful in situations where a <b>Recordset</b> object variable created from a <b>QueryDef </b>object is passed to a function, and the function must re-create the SQL equivalent of the query and possibly modify it.</p>
<h5>Modifying a Query from a Recordset Object</h5>
<p>
You can use the <b>Requery</b> method on a dynaset- or snapshot-type <b>Recordset</b> object when you want to run the underlying query again after changing a parameter. This is more convenient than opening a new <b>Recordset</b>, and it runs faster.</p>
<p>
The following example creates a <b>Recordset </b>object and passes it to a function that uses the <b>CopyQueryDef</b> method to extract the equivalent SQL string. It then prompts the user to add an additional constraint clause to the query. The code uses the <b>Requery </b>method to run the modified query.</p>
<pre><code>Sub AddQuery()

&#09;Dim dbs As Database
&#09;Dim qdf As QueryDef
&#09;Dim rstSalesReps As Recordset

&#09;Set dbs = CurrentDb

&#09;Set qdf = dbs.CreateQueryDef(&quot;SalesRepQuery&quot;)
&#09;qdf.SQL = &quot;SELECT * FROM Employees WHERE Title = 'Sales Representative'&quot;

&#09;Set rstSalesReps = qdf.OpenRecordset()

&#09;' Call the function to add a constraint.
&#09;AddQueryFilter rstSalesReps 

&#09;' Return database to original.
&#09;dbs.QueryDefs.Delete &quot;SalesRepQuery&quot;
&#09;rstSalesReps.Close
End Sub

Function AddQueryFilter(rst As Recordset)

&#09;Dim qdf As QueryDef
&#09;Dim strNewFilter As String, strRightSQL As String

&#09;Set qdf = rst.CopyQueryDef

&#09;' Try &quot;LastName LIKE 'D*'&quot;.
&#09;strNewFilter = InputBox(&quot;Enter new criteria&quot;)

&#09;strRightSQL = Right(qdf.SQL, 1)
&#09;' Strip characters from the end of the query,
&#09;' as needed.
&#09;Do While strRightSQL = &quot; &quot; Or strRightSQL = &quot;;&quot; Or strRightSQL = vbCR Or _
&#09;&#09;strRightSQL = vbLF
&#09;&#09;&#09;qdf.SQL = Left(qdf.SQL, Len(qdf.SQL) - 1)
&#09;&#09;&#09;strRightSQL = Right(qdf.SQL, 1)
&#09;Loop

&#09;qdf.SQL = qdf.SQL &amp; &quot; AND &quot; &amp; strNewFilter &amp; &quot;;&quot;
&#09;rst.Requery qdf&#09;&#09;&#09;' Requery the Recordset.
&#09;rst.MoveLast&#09;&#09;&#09;&#09;' Populate the Recordset.

&#09;' &quot;Lastname LIKE 'D*'&quot; should return 2 records.
&#09;MsgBox &quot;Number returned = &quot; &amp; rst.RecordCount

End Function
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;To use the <b>Requery</b> method, the <b>Restartable</b> property of the <b>Recordset</b> object must be set to <b>True</b>. The <b>Restartable</b> property is always set to <b>True</b> when the <b>Recordset</b> is created from a query other than a crosstab query against tables in a Microsoft Access database. You can’t restart SQL pass-through queries. You may or may not be able to restart queries against linked tables in another database format. To determine whether a <b>Recordset</b> object can rerun its query, check the <b>Restartable</b> property. For more information on the <b>Restartable</b> property, search the Help index for<b> </b>“Restartable property.”</p>
<h5>The DAO Sort and Filter Properties</h5>
<p>
Another approach to sorting and filtering <b>Recordset</b> objects is to set the DAO <b>Sort</b> and <b>Filter</b> properties on an existing <b>Recordset</b>, and then open a new <b>Recordset</b> from the existing one. However, this is usually much slower than just including the sort and filter criteria in the original query or changing the query parameters and running it again with the <b>Requery</b> method. The DAO <b>Sort </b>and <b>Filter</b> properties are useful when you want to allow a user to sort or restrict a result set, but the original data source is unavailable for a new query—for example, when a <b>Recordset </b>object variable is passed to a function, and the function must reorder records or restrict the records in the set. With this approach, performance is likely to be slow if the<b> Recordset</b> has more than 100 records. Using the <b>CopyQueryDef </b>method described in the previous section is preferable.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the DAO <b>Sort </b>and <b>Filter</b> properties, search the Help index for the name of the property.</p>
<h3>Moving Through a Recordset Object</h3>
<p>
A <b>Recordset </b>object usually has a <i>current position</i>, most often at a record. When you refer to the fields in a <b>Recordset</b>, you obtain values from the record at the current position, which is known as the <i>current record</i>. However, the current position can also be immediately before the first record in a <b>Recordset</b> or immediately after the last record. In certain circumstances, the current position is undefined.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on referring to fields, see “Referring to Field Objects” later in this chapter.</p>
<p>
You can use the following Move methods to loop through the records in a <b>Recordset</b>:
<ul>
<li>
The <b>MoveFirst</b> method moves to the first record.</li>
<li>
The <b>MoveLast</b> method moves to the last record.</li>
<li>
The <b>MoveNext</b> method moves to the next record.</li>
<li>
The <b>MovePrevious</b> method moves to the previous record.</li>
<li>
The <b>Move</b> [<i>n</i>] method moves forward or backward the number of records you specify in its syntax.</li>
</ul>
<p>
You can use each of these methods on table-, dynaset-, and snapshot-type <b>Recordset </b>objects. On a forward-only-type <b>Recordset</b> object, you can use only the <b>MoveNext</b> and <b>Move</b> methods. If you use the <b>Move</b> method on a forward-only-type <b>Recordset</b>, the argument specifying the number of rows to move must be a positive integer.</p>
<p>
The following example opens a <b>Recordset</b> object on the Employees table containing all of the records that have a <b>Null</b> value in the ReportsTo field. The function then updates the records to indicate that these employees are temporary employees. For each record in the <b>Recordset</b>, the example changes the Title and Notes fields, and saves the changes with the <b>Update</b> method. It uses the <b>MoveNext</b> method to move to the next record.</p>
<pre><code>Function UpdateEmployees()

&#09;Dim dbs As Database, rstEmployees As Recordset, strQuery As String
&#09;Dim intI As Integer

&#09;On Error GoTo ErrorHandler

&#09;Set dbs = CurrentDb

&#09;' Open a recordset on all records from the Employees table that have
&#09;' a Null value in the ReportsTo field.
&#09;strQuery = &quot;SELECT * FROM Employees WHERE ReportsTo IS NULL;&quot;
&#09;Set rstEmployees = dbs.OpenRecordset(strQuery, dbOpenDynaset)

&#09;' If the recordset is empty, exit.
&#09;If rstEmployees.EOF Then Exit Function
&#09;intI = 1
&#09;With rstEmployees
&#09;&#09;Do Until .EOF
&#09;&#09;&#09;.Edit
&#09;&#09;&#09;![ReportsTo] = 5
&#09;&#09;&#09;![Title] = &quot;Temporary&quot;
&#09;&#09;&#09;![Notes] = rstEmployees![Notes] &amp; &quot;Temp #&quot; &amp; intI
&#09;&#09;&#09;.Update
&#09;&#09;&#09;.MoveNext
&#09;&#09;&#09;intI = intI + 1
&#09;&#09;Loop
&#09;&#09;.Close
&#09;End With
&#09;
ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select
End Function
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The previous example is provided only for the purposes of illustrating the <b>Update</b> and <b>MoveNext</b> methods. It would be much faster to perform this bulk operation with an SQL UPDATE query.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the Move methods, search the Help index for “Move.”</p>
<h4>Detecting the Limits of a Recordset Object</h4>
<p>
In a <b>Recordset</b> object, if you try to move too far in one direction, a run-time error occurs. For example, if you try to use the <b>MoveNext</b> method when you’re already beyond the end of the <b>Recordset</b>, a trappable error occurs. For this reason, it’s helpful to know the limits of the <b>Recordset</b> object.</p>
<p>
The <b>BOF</b> property indicates whether the current position is at the beginning of the <b>Recordset</b>. If <b>BOF</b> is <b>True</b>, the current position is before the first record in the <b>Recordset</b>. The <b>BOF </b>property is also <b>True </b>if there are no records in the <b>Recordset</b> when it’s opened. Similarly, the <b>EOF </b>property is <b>True </b>if the current position is after the last record in the <b>Recordset</b>, or if there are no records.</p>
<p>
The following example shows you how to use the <b>BOF</b> and <b>EOF </b>properties to detect the beginning and end of a <b>Recordset</b> object. This code fragment creates a table-type <b>Recordset </b>based on the Orders table from the current database. It moves through the records, first from the beginning of the <b>Recordset </b>to the end, and then from the end of the <b>Recordset </b>to the beginning.</p>
<pre><code>Dim dbs As Database, rstOrders As Recordset

Set dbs = CurrentDb
Set rstOrders = dbs.OpenRecordset(&quot;Orders&quot;, dbOpenTable)

Do Until rstOrders.EOF
&#09;.
&#09;. ' Manipulate data.
&#09;.
&#09;rstOrders.MoveNext&#09;&#09;&#09;' Move to the next record.
Loop

rstOrders.MoveLast&#09;&#09;&#09;&#09;' Move to the last record.

' Do Until beginning of file.
Do Until rstOrders.BOF
&#09;.
&#09;. ' Manipulate data.
&#09;.

&#09;' Move to the previous record.
&#09;rstOrders.MovePrevious 
Loop

rstOrders.Close&#09;&#09;&#09;&#09;&#09;' Close the Recordset.
</code></pre>
<p>
Notice that there’s no current record immediately following the first loop. The <b>BOF</b> and <b>EOF</b> properties both have the following characteristics:
<ul>
<li>
If the <b>Recordset</b> contains no records when you open it, both <b>BOF</b> and <b>EOF</b> are <b>True</b>.</li>
<li>
When <b>BOF</b> or <b>EOF </b>is <b>True</b>, the property remains <b>True </b>until you move to an existing record, at which time the value of <b>BOF </b>or <b>EOF </b>becomes <b>False</b>.</li>
<li>
When <b>BOF</b> or <b>EOF </b>is <b>False</b>, and the only record in a <b>Recordset</b> is deleted, the property remains <b>False</b> until you try to move to another record, at which time both <b>BOF</b> and <b>EOF </b>become <b>True</b>.</li>
<li>
At the moment you create or open a <b>Recordset</b> that contains at least one record, the first record is the current record, and both <b>BOF</b> and <b>EOF</b> are <b>False</b>.</li>
<li>
If the first record is the current record when you use the <b>MovePrevious</b> method, <b>BOF</b> is set to <b>True</b>. If you use <b>MovePrevious</b> while <b>BOF</b> is <b>True</b>, a run-time error occurs. When this happens, <b>BOF</b> remains <b>True</b> and there is no current record.</li>
<li>
Similarly, moving past the last record in the <b>Recordset</b> changes the value of the <b>EOF</b> property to <b>True</b>. If you use the <b>MoveNext</b> method while <b>EOF</b> is <b>True</b>, a run-time error occurs. When this happens, <b>EOF</b> remains <b>True</b> and there is no current record.</li>
</ul>
<p>
The following illustration shows the settings of the <b>BOF </b>and<b> EOF</b> properties for all possible current positions in a <b>Recordset</b>.</p>
<p>
<img src="abac09_1.gif" border=0></p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>BOF </b>and<b> EOF</b> properties, search the Help index for “BOF property” and “EOF property.”</p>
<h4>Counting the Number of Records in a Recordset Object</h4>
<p>
You may want to know the number of records in a <b>Recordset </b>object. For example, you may want to create a form that shows how many records are in each of the tables in a database. Or you may want to change the appearance of a form or report based on the number of records it includes.</p>
<p>
The <b>RecordCount</b> property contains the number of records in a table-type <b>Recordset </b>or the total number of records accessed in a dynaset- or snapshot-type <b>Recordset</b>. A <b>Recordset</b> object with no records has a <b>RecordCount</b> property value of 0.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The value of the <b>RecordCount</b> property equals the number of records that have actually been accessed. For example, when you first create a dynaset or snapshot, you have accessed (or visited) only one record. If you check the <b>RecordCount</b> property immediately after creating the dynaset or snapshot (assuming it has at least one record), the value is 1. To visit all the records, use the <b>MoveLast</b> method immediately after opening the <b>Recordset</b>, then use <b>MoveFirst</b> to return to the first record. This isn’t done automatically because it may be slow, especially for large result sets.</p>
<p>
When you open a table-type <b>Recordset</b> object, you effectively visit all of the records in the underlying table, and the value of the <b>RecordCount</b> property totals the number of records in the table as soon as the <b>Recordset</b> is opened. Canceled transactions may make the value of the <b>RecordCount</b> property out-of-date in some multiuser situations. Compacting the database restores the table’s record count to the correct value.</p>
<p>
The following example creates a snapshot-type <b>Recordset</b> object, and then determines the number of records in the <b>Recordset</b>:</p>
<pre><code>Function RecCount(strSQL As String) As Long
&#09;Dim rstCount As Recordset
&#09;Dim dbs As Database

&#09;On Error GoTo ErrorHandler
&#09;Set dbs = CurrentDb

&#09;Set rstCount = dbs.OpenRecordset(strSQL)

&#09;If rstCount.EOF Then
&#09;&#09;rstCount.Close
&#09;&#09;RecCount = 0
&#09;&#09;Exit Function
&#09;Else
&#09;&#09;rstCount.MoveLast
&#09;&#09;RecCount = rstCount.RecordCount
&#09;&#09;rstCount.Close
&#09;&#09;Exit Function
&#09;End If
&#09;&#09;&#09; 
ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select
End Function
</code></pre>
<p>
As your application deletes records in a dynaset-type <b>Recordset</b>, the value of the <b>RecordCount</b> property decreases. However, in a multiuser environment, records deleted by other users aren’t reflected in the value of the <b>RecordCount</b> property until the current record is positioned on a deleted record. At that time, the setting of the <b>RecordCount</b> property decreases by one. Using the <b>Requery</b> method on a <b>Recordset</b>, followed by the <b>MoveLast</b> method, sets the <b>RecordCount</b> property to the current total number of records in the <b>Recordset</b>.</p>
<p>
A snapshot-type <b>Recordset</b> object is static and the value of its <b>RecordCount</b> property doesn’t change when you add or delete records in the snapshot’s underlying table.</p>
<h4>Finding the Current Position in a Recordset Object</h4>
<p>
In some situations, you need to determine how far through a <b>Recordset</b> object you have moved the current record position, and perhaps indicate the current record position to a user. For example, you may want to indicate the current position on a dial, meter, or similar type of control. Two properties are available to indicate the current position: the <b>AbsolutePosition</b> property and the <b>PercentPosition</b> property.</p>
<p>
The <b>AbsolutePosition</b> property value is the position of the current record relative to 0. However, don’t think of this property as a record number; if the current record is undefined, the <b>AbsolutePosition</b> property returns – 1. In addition, there is no assurance that a record will have the same absolute position if the <b>Recordset</b> object is re-created because the order of individual records within a<b> Recordset</b> object isn’t guaranteed unless it’s created with an SQL statement that includes an ORDER BY clause.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>AbsolutePosition</b> property, see “Why Use Bookmarks Instead of Record Numbers?” later in this chapter.</p>
<p>
The <b>PercentPosition</b> property shows the current position expressed as a percentage of the total number of records indicated by the <b>RecordCount </b>property. Because the <b>RecordCount</b> property doesn’t reflect the total number of records in the <b>Recordset</b> object until the <b>Recordset</b> has been fully populated, the <b>PercentPosition</b> property only reflects the current record position as a percentage of the number of records that have been accessed since the <b>Recordset</b> was opened. To make sure that the <b>PercentPosition</b> property reflects the current record position relative to the entire <b>Recordset</b>, use the <b>MoveLast</b> and <b>MoveFirst</b> methods immediately after opening the <b>Recordset</b>. This fully populates the <b>Recordset</b> object before you use the <b>PercentPosition</b> property. If you have a large result set, using the <b>MoveLast </b>method may take a long time for <b>Recordsets</b> that aren’t of type table.</p>
<p>
Important   The <b>PercentPosition</b> property is only an approximation and shouldn’t be used as a critical parameter. This property is best suited for driving an indicator that marks a user’s progress while moving though a set of records. For example, you may want a control that indicates the percent of records completed. For more information on the <b>PercentPosition</b> property, search the Help index for “PercentPosition property.”</p>
<p>
The following example opens a <b>Recordset</b> object on a table called Employees. The procedure then moves through the Employees table and uses the <b>SysCmd</b> function to display a progress bar showing the percentage of the table that’s been processed. If the hire date of the employee is before Jan. 1, 1993, the text “Senior Staff” is appended to the Notes field.</p>
<pre><code>Function PercentPos()

&#09;Dim dbs As Database, strMsg As String, rstEmployees As Recordset, intRet As Integer
&#09;Dim intCount As Integer, strQuery As String, sngPercent As Single
&#09;Dim varReturn As Variant
&#09;Dim lngEmpID() As Long

&#09;On Error GoTo ErrorHandler

&#09;strQuery = &quot;SELECT * FROM Employees;&quot;
&#09;Set dbs = CurrentDb
&#09;Set rstEmployees = dbs.OpenRecordset(strQuery, dbOpenDynaset)

&#09;With rstEmployees
&#09;&#09;If .EOF Then&#09;&#09;&#09;&#09;' If no records, exit.
&#09;&#09;&#09;Exit Function
&#09;&#09;Else
&#09;&#09;&#09;strMsg = &quot;Processing Employees table...&quot;
&#09;&#09;&#09;intRet = SysCmd(acSysCmdInitMeter, strMsg, 100)
&#09;&#09;End If
&#09;&#09;Do Until .EOF
&#09;&#09;&#09;If !HireDate &lt; #1/1/93# Then
&#09;&#09;&#09;&#09;.Edit
&#09;&#09;&#09;&#09;!Notes = !Notes &amp; &quot;;&quot; &amp; &quot;Senior Staff&quot;
&#09;&#09;&#09;&#09;.Update
&#09;&#09;&#09;End If

&#09;&#09;&#09;If .PercentPosition &lt;&gt; 0 Then
&#09;&#09;&#09;&#09;intRet = SysCmd(acSysCmdUpdateMeter, .PercentPosition)
&#09;&#09;&#09;End If
&#09;&#09;&#09;.MoveNext
&#09;&#09;Loop
&#09;&#09;.Close
&#09;End With
&#09;intRet = SysCmd(acSysCmdRemoveMeter)

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;' Clear progress meter.
&#09;&#09;&#09;varReturn = SysCmd(acSysCmdSetStatus, &quot; &quot;)
&#09;&#09;&#09;&#09;Exit Function
&#09;End Select
End Function
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on reading data in a field, see “Reading and Writing Data” later in this chapter.</p>
<h3>Finding a Specific Record</h3>
<p>
The previous section, “Moving Through a Recordset Object,” explores ways you can use the Move methods—<b>MoveFirst</b>, <b>MoveLast</b>, <b>MoveNext</b>, <b>MovePrevious</b>, and <b>Move</b>—to loop through records in a <b>Recordset</b> object. However, in most cases it’s more efficient to search for a specific record.</p>
<p>
For example, you may want to find a particular employee based on an employee number, or you may want to find all of the detail records that belong to a specific order. In these cases, looping through all of the employee or order detail records could be time consuming. Instead, you can use the <b>Seek</b> method with table-type <b>Recordset</b> objects, and the Find methods with dynaset- and snapshot-type <b>Recordset</b> objects to locate records. Since the forward-only-type <b>Recordset </b>object doesn’t support the <b>Seek</b> method or any of the Find methods, you cannot search for records in a forward-only-type <b>Recordset</b>.</p>
<h4>Finding a Record in a Table-Type Recordset Object</h4>
<p>
You use the <b>Seek</b> method to locate a record in a table-type <b>Recordset</b> object.</p>
<p>
When you use the <b>Seek</b> method to locate a record, the Microsoft Jet database engine uses the table’s current index, as defined by the <b>Index</b> property. </p>
<p>
Important   If you use the <b>Seek</b> method on a table-type <b>Recordset</b> object without first setting the current index, a run-time error occurs.</p>
<p>
The syntax for the <b>Seek</b> method is:</p>
<p>
<i>table</i><b>.Seek</b> <i>comparison, key1, key2 ...</i></p>
<p>
The <i>table</i> argument is the table-type <b>Recordset</b> object you’re searching through. The <i>comparison</i> argument is a string that determines the kind of comparison that is being performed. The following table lists the comparison strings you can use with the <b>Seek</b> method.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Comparison string</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
&quot;=&quot;</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Equal to the specified key values</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
&quot;&gt;=&quot;</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Greater than or equal to the specified key values</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
&quot;&gt;&quot;</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Greater than the specified key values</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
&quot;&lt;=&quot;</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Less than or equal to the specified key values</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
 &quot;&lt;&quot;</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Less than the specified key values</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
</table>
<p>
The <i>keyn</i> arguments are a series of one or more values that correspond to the field or fields that make up the current index of the <b>Recordset</b>. Microsoft Jet compares these values to values in the corresponding fields of the <b>Recordset </b>object’s records. </p>
<p>
The following example opens a table-type <b>Recordset</b> object called Employees, and uses the <b>Seek</b> method to locate the record containing a value of lngEmpID in the EmployeeID field. It returns the hire date for the specified employee.</p>
<pre><code>Function intGetHireDate(lngEmpID As Long, varHireDate As Variant) As Integer

&#09;Dim rstEmployees As Recordset, dbs As Database

&#09;Const conFilePath As String = &quot;C:\Program Files\Microsoft Office\Office\Samples\&quot;

&#09;On Error GoTo ErrorHandler

&#09;Set dbs = OpenDatabase(conFilePath &amp; &quot;Northwind&quot;)
&#09;Set rstEmployees = dbs.OpenRecordset(&quot;Employees&quot;, dbOpenTable)

&#09;rstEmployees.Index = &quot;PrimaryKey&quot; &#09;&#09;' The index name for Employee ID.
&#09;rstEmployees.Seek &quot;=&quot;, lngEmpID

&#09;If rstEmployees.NoMatch Then
&#09;&#09;varHireDate = Null
&#09;&#09;' The constants conErrNoMatch, conSuccess, and conFailed are defined at 
&#09;&#09;' the module level as public constants with Integer values of 
&#09;&#09;' -32,761, 0, and -32,737 respectively.
&#09;&#09;intGetHireDate = conErrNoMatch
&#09;&#09;Exit Function
&#09;Else
&#09;&#09;varHireDate = rstEmployees!HireDate
&#09;&#09;intGetHireDate = conSuccess
&#09;&#09;Exit Function
&#09;End If

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;varHireDate = Null
&#09;&#09;&#09;intGetHireDate = conFailed
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select

End Function
</code></pre>
<p>
The <b>Seek</b> method always starts searching for records at the beginning of the <b>Recordset</b> object. If you use the <b>Seek</b> method with the same arguments more than once on the same <b>Recordset</b>, it finds the same record.</p>
<p>
You can use the <b>NoMatch</b> property on the <b>Recordset</b> object to test whether a record matching the search criteria was found. If the record matching the criteria was found, the <b>NoMatch</b> property will be <b>False</b>; otherwise it will be <b>True</b>.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>NoMatch</b> property, search the Help index for “NoMatch property.”</p>
<p>
The following example illustrates how you can create a function that uses the <b>Seek</b> method to locate a record by using a multiple-field index:</p>
<pre><code>Function GetFirstPrice(lngOrderID As Long, lngProductID As Long) As Variant

&#09;Dim dbs As Database, rstOrderDetail As Recordset

&#09;On Error GoTo ErrorHandler

&#09;Set dbs = CurrentDb
&#09;Set rstOrderDetail = dbs.OpenRecordset(&quot;Order Details&quot;, dbOpenTable)

&#09;rstOrderDetail.Index = &quot;PrimaryKey&quot;
&#09;rstOrderDetail.Seek &quot;=&quot;, lngOrderID, lngProductID

&#09;If rstOrderDetail.NoMatch Then
&#09;&#09;GetFirstPrice = Null
&#09;&#09;MsgBox &quot;Couldn't find order detail record.&quot;
&#09;Else
&#09;&#09;GetFirstPrice = rstOrderDetail!UnitPrice
&#09;End If

&#09;rstOrderDetail.Close

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select

End Function
</code></pre>
<p>
In this example, the table’s primary key consists of two fields: OrderID and ProductID. When you call the GetFirstPrice function with a valid (existing) combination of OrderID and ProductID field values, the function returns the unit price from the found record. If it can’t find the combination of field values you want in the table, the function returns the <b>Null</b> value.</p>
<p>
If the current index is a multiple-field index, trailing key values can be omitted and are treated as <b>Null </b>values. That is, you can leave off any number of key values from the end of a <b>Seek</b> method’s <i>key</i> argument, but not from the beginning or the middle. However, if you don’t specify all values in the index, you can use only the &quot;&gt;&quot; or &quot;&lt;&quot; comparison string with the <b>Seek</b> method.</p>
<h4>Finding a Record in a Dynaset- or Snapshot-Type Recordset Object</h4>
<p>
You can use the Find methods to locate a record in a dynaset- or snapshot-type <b>Recordset</b> object. DAO provides four Find methods:
<ul>
<li>
The <b>FindFirst</b> method finds the first record satisfying the specified criteria.</li>
<li>
The <b>FindLast</b> method finds the last record satisfying the specified criteria.</li>
<li>
The <b>FindNext</b> method finds the next record satisfying the specified criteria.</li>
<li>
The <b>FindPrevious</b> method finds the previous record satisfying the specified criteria. </li>
</ul>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;To locate a record in a table-type <b>Recordset</b> object, use the <b>Seek</b> method, which is described in the previous section.</p>
<p>
When you use the Find methods, you specify the search criteria; typically an expression equating a field name with a specific value.</p>
<p>
You can locate the matching records in reverse order by finding the last occurrence with the <b>FindLast</b> method and then using the <b>FindPrevious</b> method instead of the <b>FindNext </b>method.</p>
<p>
DAO sets the <b>NoMatch</b> property to <b>True</b> whenever a Find method fails and the current record position is undefined. There may be a current record, but you have no way to tell which one. If you want to be able to return to the previous current record following a failed Find method, use a bookmark.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on bookmarks, see the following section “Marking Record Position with Bookmarks.”</p>
<p>
The<b> NoMatch</b> property is <b>False</b> whenever the operation succeeds. In this case, the current record position is the record found by one of the Find methods.</p>
<p>
The following example illustrates how you can use the <b>FindNext</b> method to find all orders in the Orders table that have no corresponding records in the Order Details table and adds the value in the OrderID field to the array lngOrderID().</p>
<pre><code>Function FindEx(lngOrderID() As Long)
&#09;Dim dbs As Database, rstOrders As Recordset
&#09;Dim strQuery As String, rstOrderDetails As Recordset
&#09;Dim intIndex As Integer

&#09;On Error GoTo ErrorHandler

&#09;Set dbs = CurrentDb

&#09;' Open recordsets on the Orders and Order Details tables. If there are no
&#09;' records in either table, exit the function.

&#09;strQuery = &quot;SELECT * FROM Orders ORDER BY OrderID;&quot;
&#09;Set rstOrders = dbs.OpenRecordset(strQuery, dbOpenSnapshot)
&#09;If rstOrders.EOF Then Exit Function

&#09;strQuery = &quot;SELECT * FROM [Order Details] ORDER BY OrderID;&quot;
&#09;Set rstOrderDetails = dbs.OpenRecordset(strQuery, dbOpenSnapshot)

&#09;' For the first record in Orders, find the first matching record
&#09;' in OrderDetails. If no match, redimension the array of order IDs and
&#09;' add the order ID to the array.
&#09;rstOrderDetails.FindFirst &quot;OrderID = &quot; &amp; rstOrders![OrderID]
&#09;If rstOrderDetails.NoMatch Then
&#09;&#09;ReDim Preserve lngOrderID(1 To intIndex)
&#09;&#09;lngOrderID(intIndex) = rstOrders![OrderID]
&#09;End If

&#09;' The first match has already been found, so use the FindNext method to find the
&#09;' next record satisfying the criteria.
&#09;intIndex = 0
&#09;Do Until rstOrders.EOF
&#09;&#09;rstOrderDetails.FindNext &quot;OrderID = &quot; &amp; rstOrders![OrderID]
&#09;&#09;If rstOrderDetails.NoMatch Then
&#09;&#09;&#09;intIndex = intIndex + 1
&#09;&#09;&#09;ReDim Preserve lngOrderID(1 To intIndex)
&#09;&#09;&#09;lngOrderID(intIndex) = rstOrders![OrderID]
&#09;&#09;End If
&#09;&#09;rstOrders.MoveNext
&#09;Loop

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select

End Function
</code></pre>
<p>
<img src="abac09_2.gif" border=0></p>
<p>
Tip   If you need to frequently search records in a dynaset, you may find it easier to create a temporary indexed table and use the <b>Seek</b> method instead.</p>
<h4>Marking Record Position with Bookmarks</h4>
<p>
A <i>bookmark</i> is a system-generated <b>Byte</b> array that uniquely identifies each record. The DAO <b>Bookmark</b> property of a <b>Recordset </b>object changes each time you move to a new record. To identify a record, move to that record and then assign the value of the DAO<b> Bookmark </b>property to a variable of type <b>Variant</b>. To return to the record, set the DAO <b>Bookmark</b> property to the value of the variable.</p>
<p>
The following example illustrates how you can use a bookmark to save the current record position. You can then perform other operations on the <b>Recordset</b> object, and then return to the saved record position.</p>
<pre><code>Function BookMarkEx() As Integer
&#09;Dim dbs As Database, rstProducts As Recordset
&#09;Dim vBookMark As Variant, sngRevenue As Single
&#09;Dim strQuery As String, rstCategories As Recordset, strCriteria As String

&#09;On Error GoTo ErrHandler

&#09;BookMarkEx = 0
&#09;strQuery = &quot;SELECT * FROM Products WHERE UnitsOnOrder &gt;= 40 ORDER BY &quot; _
&#09;&#09; &amp; &quot;CategoryID, UnitsOnOrder DESC;&quot;
&#09;Set dbs = CurrentDb
&#09;Set rstProducts = dbs.OpenRecordset(strQuery, dbOpenSnapshot)
&#09;Set rstCategories = dbs.OpenRecordset(&quot;SELECT CategoryID FROM &quot; _
&#09;&#09; &amp; &quot;Categories ORDER BY CategoryID;&quot;, dbOpenSnapshot)

&#09;If rstProducts.NoMatch Then Exit Function

&#09;' For each category find the product generating the least revenue 
&#09;' and the product generating the most revenue.
&#09;Do Until rstCategories.EOF

&#09;&#09;strCriteria = &quot;CategoryID = &quot; &amp; rstCategories![CategoryID]
&#09;&#09;rstProducts.FindFirst strCriteria
&#09;&#09;sngRevenue = rstProducts![UnitPrice] * rstProducts![UnitsOnOrder]

&#09;&#09;If Not rstProducts.NoMatch Then
&#09;&#09;&#09;' Set a bookmark at the first record containing the CategoryID.
&#09;&#09;&#09;vBookMark = rstProducts.Bookmark
&#09;&#09;&#09;' Find the product generating the most revenue.

&#09;&#09;&#09;Do While rstProducts![CategoryID] = rstCategories![CategoryID]

&#09;&#09;&#09;&#09;If rstProducts![UnitPrice] * rstProducts![UnitsOnOrder] &gt; sngRevenue Then
&#09;&#09;&#09;&#09;&#09;sngRevenue = rstProducts![UnitPrice] * rstProducts![UnitsOnOrder]
&#09;&#09;&#09;&#09;End If
&#09;&#09;&#09;&#09;rstProducts.MoveNext

&#09;&#09;&#09;Loop
&#09;&#09;&#09;' Move to the first record containing the CategoryID.
&#09;&#09;&#09;rstProducts.Bookmark = vBookMark
&#09;&#09;&#09;sngRevenue = rstProducts![UnitPrice] * rstProducts![UnitsOnOrder]
&#09;&#09;&#09;' Find the product generating the least revenue.

&#09;&#09;&#09;Do While rstProducts![CategoryID] = rstCategories![CategoryID]
&#09;&#09;&#09;&#09;If rstProducts![UnitPrice] * rstProducts![UnitsOnOrder] &lt; sngRevenue Then
&#09;&#09;&#09;&#09;&#09;sngRevenue = rstProducts![UnitPrice] * rstProducts![UnitsOnOrder]
&#09;&#09;&#09;&#09;End If
&#09;&#09;&#09;&#09;rstProducts.MoveNext
&#09;&#09;&#09;Loop

&#09;&#09;End If
&#09;&#09;rstCategories.MoveNext
&#09;Loop

' Error Handler.
ErrHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select
End Function
</code></pre>
<p>
A bookmark is particularly useful if a method fails because the current record position is undefined.</p>
<p>
The <b>LastModified</b> property of the <b>Recordset</b> object provides a good illustration of how to use a bookmark. The <b>LastModified</b> property returns the bookmark of the last record in the <b>Recordset</b> to be added or modified. To use it, set the DAO <b>Bookmark </b>property equal to the <b>LastModified</b> property, as follows:</p>
<pre><code>rstCustomers.Bookmark = rstCustomers.LastModified
</code></pre>
<p>
This moves the current record position to the last record that was added or modified. This is particularly useful when adding new records, because after you add a new record, the current record is the one you were on before you added the record. With the <b>LastModified</b> property, you can move to the newly added record if that’s what your application expects.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on adding new records, see “Adding a New Record” later in this chapter.</p>
<h5>Bookmark Scope</h5>
<p>
When you close a <b>Recordset</b> object, any bookmarks you saved become invalid. You can’t use a bookmark from one <b>Recordset</b> in another <b>Recordset</b>, even if both <b>Recordset</b> objects are based on the same underlying table or query. However, you can use a bookmark on the clone of a <b>Recordset</b>, as shown in the following example:</p>
<pre><code>Dim dbs As Database
Dim rstOriginal As Recordset, rstDuplicate As Recordset
Dim strPlaceholder As String

Set dbs = CurrentDb
' Create the first Recordset.
Set rstOriginal = dbs.OpenRecordset(&quot;Orders&quot;, dbOpenDynaset)

' Save the current record position.
strPlaceholder = rstOriginal.Bookmark

' Create a duplicate Recordset.
Set rstDuplicate = rstOriginal.Clone()

' Go to same record.
rstDuplicate.Bookmark = strPlaceholder

rstOriginal.Close
</code></pre>
<p>
You can also use the DAO <b>Bookmark</b> property on the <b>Recordset</b> object underlying a form. With this property, your code can mark which record is currently displayed on the form, and then change the record that is being displayed. For example, on a form containing employee information, you may want a button that a user can click to show the record for an employee’s supervisor. The following example illustrates the event procedure you would use for the button’s Click event:</p>
<pre><code>Private Sub cmdShowSuper_Click()

&#09;Dim frmEmployees As Form
&#09;Dim rstEmployees As Recordset
&#09;Dim strOrigin As String
&#09;Dim strEmployee As String
&#09;Dim strSuper As String

&#09;Set frmEmployees = Screen.ActiveForm
&#09;' Open the Recordset.
&#09;Set rstEmployees = frmEmployees.RecordsetClone

&#09;strOrigin = frmEmployees.Bookmark
&#09;strEmployee = frmEmployees!FirstName &amp; &quot; &quot; &amp; frmEmployees!LastName
&#09;rstEmployees.FindFirst &quot;EmployeeID = &quot; &amp; frmEmployees!ReportsTo
&#09;If rstEmployees.NoMatch Then
&#09;&#09;MsgBox &quot;Couldn't find &quot; &amp; strEmployee &amp; &quot;'s supervisor.&quot;
&#09;Else
&#09;&#09;frmEmployees.Bookmark = rstEmployees.Bookmark
&#09;&#09;strSuper = frmEmployees!FirstName &amp; &quot; &quot; &amp; frmEmployees!LastName
&#09;&#09;MsgBox strEmployee &amp; &quot;'s supervisor is &quot; &amp; strSuper
&#09;&#09;frmEmployees.Bookmark = strOrigin
&#09;End If
&#09;rstEmployees.Close

End Sub
</code></pre>
<h5>Why Use Bookmarks Instead of Record Numbers?</h5>
<p>
If you have used another database or programming environment, you may be accustomed to referring to record numbers. For example, you may have written code that opens a text file and thereafter refers to specific records by their relative position in the file. The first record in the file would be record 1, the second would be record 2, and so on.</p>
<p>
In Microsoft Access databases, your view of records (a <b>Recordset</b>) is usually a subset of the records in one or more tables. Because the actual number of records in a <b>Recordset</b> can change at any time, especially in a multiuser environment, there’s no absolute record number you can always use to refer to a particular record. The <b>AbsolutePosition</b> property isn’t the same as a record number, because this property changes if a lower-numbered record is deleted.</p>
<p>
Furthermore, records returned in a <b>Recordset</b> object appear in no particular order, unless the <b>Recordset</b> was created with a query that includes an ORDER BY clause, or is a table-type <b>Recordset </b>with an index. Record numbers are usually meaningless in a <b>Recordset</b> object.</p>
<p>
Instead of record numbers, DAO provides bookmarks to uniquely identify a particular record. A given record retains its unique bookmark for the life of the <b>Recordset</b>.</p>
<h5>Which Recordset Objects Don’t Support Bookmarks?</h5>
<p>
Dynasets based on certain linked tables, such as Paradox tables that have no primary key, don’t support bookmarks, nor do forward-only-type <b>Recordset </b>objects.</p>
<p>
You can determine whether a given <b>Recordset </b>object supports bookmarks by checking the value of the <b>Bookmarkable</b> property, as in the following example:</p>
<pre><code>If rstLinkedTable.Bookmarkable Then
&#09;MsgBox &quot;The underlying table supports bookmarks.&quot;
Else
&#09;MsgBox &quot;The underlying table doesn't support bookmarks.&quot;
End If
</code></pre>
<p>
Important   If you try to use bookmarks on a <b>Recordset</b> object that doesn’t support bookmarks, a run-time error occurs.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>Bookmarkable</b> property, search the Help index for “Bookmarkable property.”</p>
<h3>Changing Data</h3>
<p>
After you’ve created a table- or dynaset-type<b> Recordset </b>object, you can change, delete, or add new records. You can’t change, delete, or add records to a snapshot-type or forward-only-type <b>Recordset</b> object.</p>
<p>
This section presents the methods and procedures for changing data in table- and dynaset-type <b>Recordset</b> objects.</p>
<h4>Using Parameter Queries</h4>
<p>
A <i>parameter query</i> is a query that when run displays a dialog box that prompts the user for information, such as criteria for retrieving records or a value to insert in a field. You can use stored parameter queries to accomplish most of the database maintenance tasks described in the rest of this chapter.</p>
<p>
In many situations, you’ll want a user or another procedure to provide parameters you can use with your stored queries and <b>Recordset</b> objects. Microsoft Jet provides the means to do this. First, create a stored query, specifying which parameters the user needs to provide. When you open a <b>Recordset</b> against one of these queries, the application opens a dialog box that prompts the user to enter a value, such as the criteria for a WHERE clause or the field on which to sort the selected records.</p>
<p>
The following example takes two strings that represent dates and creates a parameter query that returns all records in the Orders table whose order date is between the two dates. It adds all values in the OrderID field in the query’s recordset to an array.</p>
<pre><code>Function OrdersFromTo(strDateFrom As Variant, strDateTo As Variant, _
&#09;lngOrderIDs() As Long)

&#09;Dim dbs As Database, rstOrders As Recordset
&#09;Dim qdf As QueryDef, strSQL As String, intI As Integer

&#09;On Error GoTo ErrorHandler

&#09;Set dbs = CurrentDb
&#09;strSQL = &quot;PARAMETERS [DateFrom] DateTime, [DateTo] DateTime; &quot;
&#09;strSQL = strSQL &amp; &quot;SELECT * FROM Orders WHERE OrderDate BETWEEN &quot;
&#09;strSQL = strSQL &amp; &quot;[DateFrom] AND [DateTo];&quot;

&#09;' Create an unstored parameter query.
&#09;Set qdf = dbs.CreateQueryDef(&quot;&quot;, strSQL)

&#09;' Set the query parameters.
&#09;qdf.Parameters(&quot;DateFrom&quot;) = strDateFrom
&#09;qdf.Parameters(&quot;DateTo&quot;) = strDateTo

&#09;' Open a forward-only snapshot on the query.
&#09;Set rstOrders = qdf.OpenRecordset(dbOpenSnapshot, dbForwardOnly)

&#09;' Load all the OrderIDs in the query into an array that the caller
&#09;' of the function can use.

&#09;intI = 1
&#09;While rstOrders.EOF = False
&#09;&#09;ReDim lngOrderIDs(1 To intI)
&#09;&#09;lngOrderIDs(intI) = rstOrders!OrderID
&#09;&#09;intI = intI + 1
&#09;&#09;rstOrders.MoveNext
&#09;Wend

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select

End Function
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on parameter queries, search the Help index for “parameter queries.”</p>
<h4>Making Bulk Changes</h4>
<p>
Many of the changes you may otherwise perform in a loop can be done more efficiently with an update or delete query. The following example creates a <b>QueryDef</b> object to update the Employees table and then runs the query:</p>
<pre><code>Dim dbs As Database, qdfChangeTitles As QueryDef

Set dbs = CurrentDb
Set qdfChangeTitles = dbs.CreateQueryDef(&quot;&quot;)

qdfChangeTitles.SQL = &quot;UPDATE Employees SET Title = 'Account Executive' &quot; _
&#09;&amp; &quot;WHERE Title = 'Sales Representative';&quot;

qdfChangeTitles.Execute dbFailOnError&#09;&#09;' Invoke query.
</code></pre>
<p>
You can replace the entire SQL string in this example with a stored parameter query, in which case the procedure would prompt the user for parameter values. The following example shows how the previous example may be rewritten as a stored parameter query:</p>
<pre><code>Dim dbs As Database, qdfChangeTitles As QueryDef
Dim strSQLUpdate As String, strOld As String
Dim strNew As String

Set dbs = CurrentDb

strSQLUpdate = &quot;PARAMETERS [Old Title] Text, [New Title] Text; &quot; _
&#09;&amp; &quot;UPDATE Employees SET Title = [New Title] WHERE Title = [Old Title];&quot;

' Create the QueryDef object.
Set qdfChangeTitles = dbs.CreateQueryDef(&quot;&quot;, strSQLUpdate)

' Prompt for old title.
strOld = InputBox(&quot;Enter old job title&quot;)

' Prompt for new title.
strNew = InputBox(&quot;Enter new job title&quot;)

' Set parameters.
qdfChangeTitles.Parameters(&quot;Old Title&quot;) = strOld
qdfChangeTitles.Parameters(&quot;New Title&quot;) = strNew
' Invoke query.
qdfChangeTitles.Execute
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;A delete query is more efficient than code that loops through records looking for records to delete, especially with databases created in Microsoft Access for Windows 95 or later.</p>
<h4>Modifying an Existing Record</h4>
<p>
You can modify existing records in a table- or dynaset-type <b>Recordset</b> object by using the <b>Edit</b> and <b>Update</b> methods.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To modify an existing record in a table- or dynaset-type Recordset object</b>
<ol>
<li>
Go to the record that you want to change.</li>
<li>
Use the <b>Edit</b> method to prepare the current record for editing.</li>
<li>
Make the necessary changes to the record.</li>
<li>
Use the <b>Update</b> method to save the changes to the current record.</li>
</ol>
<p>
The following example illustrates how to change the job titles for all sales representatives in a table called Employees:</p>
<pre><code>Dim dbs As Database, rstEmployees As Recordset

Set dbs = CurrentDb
Set rstEmployees = dbs.OpenRecordset(&quot;Employees&quot;)

rstEmployees.MoveFirst
Do Until rstEmployees.EOF
&#09;If rstEmployees!Title = &quot;Sales Representative&quot; Then
&#09;&#09;rstEmployees.Edit
&#09;&#09;rstEmployees!Title = &quot;Account Executive&quot;
&#09;&#09;rstEmployees.Update
&#09;End If
&#09;rstEmployees.MoveNext
Loop
rstEmployees.Close
</code></pre>
<p>
Important   If you don’t use the <b>Edit</b> method before you try to change a value in the current record, a run-time error occurs. If you edit the current record and then move to another record or close the <b>Recordset</b> object without first using the <b>Update</b> method, your changes are lost without warning. For example, omitting the <b>Update</b> method from the preceding example results in no changes being made to the Employees table.</p>
<p>
You can also terminate the <b>Edit</b> method and any pending transactions without saving changes by using the <b>CancelUpdate </b>method. While you can terminate the <b>Edit </b>method just by moving off the current record, this isn’t practical when the current record is the first or last record in the <b>Recordset</b>, or is a new record. It’s generally simpler to use the <b>CancelUpdate</b> method.</p>
<h5>Inconsistent Updates</h5>
<p>
Dynaset-type <b>Recordset</b> objects can be based on a multiple-table query containing tables with a one-to-many relationship. For example, suppose you want to create a multiple-table query that combines fields from the Orders and Order Details tables. Generally speaking, you can’t change values in the Orders table because it’s on the “one” side of the relationship. Depending on your application, however, you may want to be able to make changes to the Orders table. To make it possible to freely change the values on the “one” side of a one-to-many relationship, use the <b>dbInconsistent</b> constant of the <b>OpenRecordset</b> method to create an inconsistent dynaset. For example:</p>
<p>
<code>Set rstTotalSales = dbs.OpenRecordset(&quot;Sales Totals&quot; ,, _   dbInconsistent)</code></p>
<p>
When you update an inconsistent dynaset, you can easily destroy the referential integrity of the data in the dynaset. You must take care to understand how the data is related across the one-to-many relationship and to update the values on both sides in a way that preserves data integrity.</p>
<p>
The <b>dbInconsistent</b> constant is available only for dynaset-type <b>Recordset</b> objects. It’s ignored for table-, snapshot-, and forward-only-type <b>Recordset</b> objects, but no compile or run-time error is returned if the <b>dbInconsistent</b> constant is used with those types of <b>Recordset</b> objects. </p>
<p>
Even with an inconsistent <b>Recordset</b>, some fields may not be updatable. For example, you can’t change the value of an AutoNumber field, and a <b>Recordset</b> based on certain linked tables may not be updatable.</p>
<h4>Deleting an Existing Record</h4>
<p>
You can delete an existing record in a table- or dynaset-type <b>Recordset</b> object by using the <b>Delete</b> method. You can’t delete records from a snapshot-type <b>Recordset</b> object. The following example deletes all the duplicate records in the Shippers table:</p>
<pre><code>Function DeleteDuplicateShippers() As Integer
&#09;Dim rstShippers As Recordset, strQuery As String, dbs As Database, strName As String

&#09;On Error GoTo ErrorHandler

&#09;strQuery = &quot;SELECT * FROM Shippers ORDER BY CompanyName;&quot;
&#09;Set dbs = CurrentDb
&#09;Set rstShippers = dbs.OpenRecordset(strQuery, dbOpenDynaset)

&#09;' If no records in Shippers table, exit.
&#09;If rstShippers.EOF Then Exit Function

&#09;strName = rstShippers![CompanyName]
&#09;rstShippers.MoveNext

&#09;Do Until rstShippers.EOF

&#09;&#09;If rstShippers![CompanyName] = strName Then
&#09;&#09;&#09;rstShippers.Delete
&#09;&#09;Else
&#09;&#09;&#09;strName = rstShippers![CompanyName]
&#09;&#09;End If
&#09;&#09;rstShippers.MoveNext

&#09;Loop
&#09;
ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;' The constants conSuccess and conFailed are defined at
&#09;&#09;&#09;' the module level as public constants with Integer values of
&#09;&#09;&#09;' 0 and -32,737 respectively.
&#09;&#09;&#09;DeleteDuplicateShippers = conSuccess
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;DeleteDuplicateShippers = conFailed
&#09;&#09;&#09;Exit Function
&#09;End Select

End Function
</code></pre>
<p>
When you use the <b>Delete</b> method, Microsoft Jet immediately deletes the current record without any warning or prompting. Deleting a record doesn’t automatically cause the next record to become the current record; to move to the next record you must use the <b>MoveNext</b> method. However, keep in mind that after you’ve moved off the deleted record, you cannot move back to it.</p>
<p>
If you try to access a record after deleting it on a table-type <b>Recordset</b>, you’ll get error 3167, “Record is deleted.” On a dynaset, you’ll get error 3021, “No current record.”</p>
<p>
If you have a <b>Recordset</b> clone positioned at the deleted record and you try to read its value, you’ll get error 3167 regardless of the type of <b>Recordset</b> object. Trying to use a bookmark to move to a deleted record will also result in error 3167.</p>
<h4>Adding a New Record</h4>
<p>
You can add a new record to a table- or dynaset-type <b>Recordset </b>object by using the <b>AddNew</b> method.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To add a new record to a table- or dynaset-type Recordset object</b>
<ol>
<li>
Use the <b>AddNew</b> method to create a new record you can edit.</li>
<li>
Assign values to each of the record’s fields.</li>
<li>
Use the <b>Update</b> method to save the new record.</li>
</ol>
<p>
The following example adds a new record to a table-type <b>Recordset </b>called Shippers:</p>
<pre><code>Dim dbs As Database, rstShippers As Recordset

Set dbs = CurrentDb
Set rstShippers = dbs.OpenRecordset(&quot;Shippers&quot;)

rstShippers.AddNew
rstShippers!CompanyName = &quot;Global Parcel Service&quot;
&#09;.
&#09;. ' Set remaining fields.
&#09;.

rstShippers.Update
rstShippers.Close
</code></pre>
<p>
When you use the <b>AddNew</b> method, Microsoft Jet prepares a new, blank record and makes it the current record. When you use the <b>Update</b> method to save the new record, the record that was current before you used the <b>AddNew</b> method<b> </b>becomes the current record again.</p>
<p>
The new record’s position in the <b>Recordset</b> depends on whether you added the record to a dynaset- or a table-type <b>Recordset</b> object. If you add a record to a dynaset-type<b> Recordset</b>, the new record appears at the end of the <b>Recordset</b>, no matter how the <b>Recordset</b> is sorted. To force the new record to appear in its properly sorted position, you can either use the <b>Requery</b> method or re-create the <b>Recordset</b> object.</p>
<p>
If you add a record to a table-type<b> Recordset</b>, the record appears positioned according to the current index, or at the end of the table if there is no current index. Because Microsoft Jet version 3.0 or later allows multiple users to create new records in a table simultaneously, your record may not appear right at the end of the <b>Recordset</b> as it did in previous versions of Microsoft Jet. Be sure to use the <b>LastModified</b> property rather than the <b>MoveLast</b> method to move to the record you just added.</p>
<p>
Important   If you use the <b>AddNew</b> method to add a new record, and then move to another record or close the <b>Recordset</b> object without first using the <b>Update</b> method, your changes are lost without warning. For example, omitting the <b>Update</b> method from the preceding example results in no changes being made to the Shippers table.</p>
<h5>Caching ODBC Data with a Recordset</h5>
<p>
You can use the dynaset-type <b>Recordset</b> to create a local cache for ODBC data. This lets you retrieve records in batches instead of one at a time as each record is requested, and makes much better use of your server connection, thus improving performance.</p>
<p>
The <b>CacheSize</b> and <b>CacheStart</b> properties establish the size and starting offset (expressed as a bookmark) for the cache. For example, you may set the <b>CacheSize</b> property to 100 records. Then, using the <b>FillCache</b> method, you can retrieve sufficient records to fill the cache.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on caching ODBC data, see Chapter 19, <a href="developingclientserverapplications.htm">“Developing Client/Server Applications.”</a></p>
<h4>Tracking Recordset Changes</h4>
<p>
You may need to determine when the underlying <b>TableDef</b> object of a table-type <b>Recordset</b> was created, or the last time it was modified. The <b>DateCreated</b> and <b>LastUpdated</b> properties, respectively, give you this information. Both properties return the date stamp applied to the table by the machine on which the table resided at the time it was stamped. These properties are only updated when the table’s design changes; they aren’t affected by changes to records in the table.</p>
<h3>Microsoft Jet Transactions</h3>
<p>
A <i>transaction</i> is a set of operations bundled together and treated as a single unit of work. The work in a transaction must be completed as a whole; if any part of the transaction fails, the entire transaction fails. Transactions offer the developer the ability to enforce data integrity. With multiple database operations bundled into a single unit that must succeed or fail as a whole, the database can’t reach an inconsistent state. Transactions are common to most database management systems.</p>
<p>
The most common example of transaction processing involves a bank’s automated teller machine (ATM). The processes of dispensing cash and then debiting the user’s account are considered a logical unit of work and are wrapped in a transaction: The cash isn’t dispensed unless the system is also able to debit the account. By using a transaction, the entire operation either succeeds or fails. This maintains the consistent state of the ATM database.</p>
<p>
You should consider using transactions if you want to make sure that each operation in a group of operations is successful before all operations are committed. Keep in mind that all transactions are invisible to other transactions. That is, no transaction can see another transaction’s updates to the database until the transaction is committed.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The behavior of transactions with Microsoft Access databases differs from the behavior of ODBC data sources, such as Microsoft SQL&nbsp;Server™. For example, if a database is connected to a file server, and the file server stops before a transaction has had time to commit its changes, then your database could be left in an inconsistent state. If you require true transaction support with respect to durability, you should investigate the use of a client/server architecture. For more information on client/server architecture, see Chapter 19, <a href="developingclientserverapplications.htm">“Developing Client/Server Applications.”</a></p>
<h4>Using Transactions in Your Applications</h4>
<p>
Microsoft Jet supports transactions through the DAO <b>BeginTrans</b>,<b> CommitTrans</b>, and <b>Rollback</b> methods of the <b>Workspace</b> object. The basic syntax is shown in the following table.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Method</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Operation</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<i><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">workspace.</i><b>BeginTrans</b></td>
<TD>
Begins the transaction</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<i><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">workspace.</i><b>CommitTrans</b></td>
<TD>
Posts the transaction, writing its updates to the permanent database objects</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<i><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">workspace.</i><b>Rollback</b></td>
<TD>
Cancels the transaction</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
</table>
<p>
The following example changes the job title of all sales representatives in the Employees table of the Northwind sample database. After the <b>BeginTrans</b> method starts a transaction that isolates all of the changes made to the Employees table, the <b>CommitTrans </b>method saves the changes. Notice that you can use the <b>Rollback</b> method to undo changes that you saved with the <b>Update</b> method.</p>
<pre><code>Sub ChangeTitle()

&#09;Dim dbsSales As Database
&#09;Dim rstEmp As Recordset
&#09;Dim wrkCurrent As Workspace

&#09;Set wrkCurrent = DBEngine.Workspaces(0)
&#09;Set dbsSales = OpenDatabase(&quot;Northwind.mdb&quot;)
&#09;Set rstEmp = dbsSales.OpenRecordset(&quot;Employees&quot;, dbOpenTable)

&#09;wrkCurrent.BeginTrans
&#09;Do Until rstEmp.EOF
&#09;&#09;If rstEmp!Title = &quot;Sales Representative&quot; Then
&#09;&#09;&#09;rstEmp.Edit
&#09;&#09;&#09;rstEmp!Title = &quot;Sales Associate&quot;
&#09;&#09;&#09;rstEmp.Update
&#09;&#09;End If
&#09;&#09;rstEmp.MoveNext
&#09;Loop

&#09;If MsgBox(&quot;Save all changes?&quot;, vbQuestion + vbYesNo) = vbYes Then
&#09;&#09;wrkCurrent.CommitTrans
&#09;Else
&#09;&#09;wrkCurrent.Rollback
&#09;End If

&#09;rstEmp.Close
&#09;dbsSales.Close

End Sub
</code></pre>
<p>
When you use transactions, all databases and<b> Recordset</b> objects in the specified<b> Workspace</b> object are affected—transactions are global to the workspace, not to a specific database or <b>Recordset</b>. If you perform operations on more than one database or within a workspace transaction, the <b>Commit</b> and <b>Rollback</b> methods affect all the objects changed within that workspace during the transaction.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You can also use the <b>BeginTrans</b>, <b>CommitTrans</b>, and<b> Rollback</b> methods with the <b>DBEngine</b> object. In this case, the transaction is applied to the default workspace, which is <code>DBEngine.Workspaces(0)</code>.</p>
<h4>Managing Transactions</h4>
<p>
Microsoft Jet uses sophisticated algorithms to enhance transaction performance, reliability, and usability. This section discusses topics related to how the Jet database engine manages transactions.</p>
<h5>Transaction Size</h5>
<p>
Transaction size is limited only by the amount of physical space on your disk drive. That is, Microsoft Jet can store a quantity of transaction data as large as the amount of free space on your disk drive. If the available disk space is exhausted during a transaction, a trappable run-time error occurs. Your code should check for this error (number 2004) and react accordingly. If you try to commit the transaction after this error occurs, Microsoft Jet will commit an indeterminate number of changes, possibly leaving the database in an inconsistent state. You should usually roll back the transaction when this error occurs to ensure a consistent database state.</p>
<h5>Nesting Transactions</h5>
<p>
You can have up to five levels of transactions active at any one time by nesting combinations of <b>BeginTrans</b> and either <b>CommitTrans</b> or <b>Rollback</b>. If you nest transactions, you must make sure that you commit or roll back the current transaction before trying to commit or roll back a transaction at a higher level of nesting.</p>
<p>
If you want to have transactions with overlapping, nonnested scopes, you can open additional <b>Workspace</b> objects and manage other transactions within those new workspaces.</p>
<h5>When a Transaction is Rolled Back by the Jet Database Engine</h5>
<p>
If you close a <b>Workspace</b> object, any transactions within the scope of the workspace are automatically rolled back. Microsoft Jet never automatically commits any transactions you have started. This behavior is also true of database object variables. If you close a database object variable, any uncommitted transactions within the scope of that database object variable are rolled back. You should be aware of this behavior when you write your code. Never assume that the Jet database engine is going to commit your transaction for you.</p>
<h5>Transactions on External Data Sources</h5>
<p>
Transactions aren’t supported on external non-Microsoft Jet data sources, with the exception of ODBC data. For example, if your database has linked FoxPro&reg; or dBASE&reg; tables, any transactions on those objects are ignored. This means that the transaction doesn’t fail or generate a run-time error, but it doesn’t actually do anything either.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Microsoft Access version 2.0 databases are opened by Microsoft Access for Windows 95 and Microsoft Access 97 as external installable ISAM databases. However, unlike other external data sources, the Jet database engine does support transactions on Microsoft Access version 2.<i>x</i> databases.</p>
<p>
To determine whether or not a <b>Database</b> or <b>Recordset</b> object supports transactions, you can check the value of its <b>Transactions</b> property. A value of <b>True</b> indicates that the object does support transactions, and a value of <b>False</b> indicates that the object doesn’t support transactions.</p>
<h4>Transactions and Performance</h4>
<p>
In previous versions of Microsoft Access, it was generally recommended that you use transactions as a performance enhancement. Now all transactions for DAO add, update, and delete operations are performed internally and automatically. In most situations, this automatic support provides your application with the best possible performance. However, there may be situations where you want to fine-tune transaction behavior. You can do this by creating and modifying various settings in the Windows Registry.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on tuning Registry settings used by Microsoft Jet, see “Adjusting Windows Registry Settings to Improve Performance” in Chapter 13, “Optimizing Your Application.”</p>
<h3>Extracting Data from a Record</h3>
<p>
After you’ve located a particular record or records, you may want to extract data to use in your application instead of modifying the underlying source table.</p>
<h4>Copying a Single Field</h4>
<p>
You can copy a single field of a record to a variable of the appropriate data type. The following example extracts three fields from the first record in a <b>Recordset</b> object:</p>
<pre><code>Dim dbs As Database, rstEmployees As Recordset
Dim strFirstName As String, strLastName As String
Dim strTitle As String
 
Set dbs = CurrentDb
Set rstEmployees = dbs.OpenRecordset(&quot;Employees&quot;)

rstEmployees.MoveFirst
strFirstName = rstEmployees!FirstName
strLastName = rstEmployees!LastName
strTitle = rstEmployees!Title

rstEmployees.Close
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on extracting data from a record, see “Reading and Writing Data” later in this chapter.</p>
<h4>Copying Entire Records to an Array</h4>
<p>
To copy one or more entire records, you can create a two-dimensional array and copy records one at a time. You increment the first subscript for each field and the second subscript for each record.</p>
<p>
A fast way to do this is with the <b>GetRows</b> method. The <b>GetRows </b>method returns a two-dimensional array. The first subscript identifies the field and the second identifies the row number, as follows:</p>
<pre><code>varRecords(intField, intRecord)
</code></pre>
<p>
The following example uses an SQL statement to retrieve three fields from a table called Employees into a <b>Recordset</b> object. It then uses the <b>GetRows</b> method to retrieve the first three records of the <b>Recordset</b>, and it stores the selected records in a two-dimensional array. It then prints each record, one field at a time, by using the two array indexes to select specific fields and records.</p>
<p>
To clearly illustrate how the array indexes are used, the following example uses a separate statement to identify and print each field of each record. In practice, it would be more reliable to use two loops, one nested in the other, and to provide integer variables for the indexes that step through both dimensions of the array.</p>
<pre><code>Sub GetRowsTest()

&#09;Dim dbs As Database
&#09;Dim rstEmployees As Recordset
&#09;Dim varRecords As Variant
&#09;Dim intNumReturned As Integer
&#09;Dim intNumColumns As Integer
&#09;Dim intColumn As Integer, intRow As Integer
 
&#09;Set dbs = CurrentDb
&#09;Set rstEmployees = dbs.OpenRecordset(&quot;SELECT FirstName, LastName, Title &quot; _
&#09;&#09;&amp; &quot;FROM Employees&quot;, dbOpenSnapshot)

&#09;varRecords = rstEmployees.GetRows(3)
&#09;intNumReturned = UBound(varRecords, 2) + 1
&#09;intNumColumns = UBound(varRecords, 1) + 1

&#09;For intRow = 0 To intNumReturned - 1
&#09;&#09;For intColumn = 0 To intNumColumns - 1
&#09;&#09;&#09;Debug.Print varRecords(intColumn, intRow)
&#09;&#09;Next intColumn
&#09;Next intRow

&#09;rstEmployees.Close

End Sub
</code></pre>
<p>
You can use subsequent calls to the <b>GetRows</b> method if more records are available. Because the array is filled as soon as you call the <b>GetRows </b>method, you can see why this approach is much faster than copying one field at a time.</p>
<p>
Notice also that you don’t have to declare the <b>Variant</b> as an array, because this is done automatically when the <b>GetRows</b> method returns records. This enables you to use fixed-length array dimensions without knowing how many records or fields will be returned, instead of using variable-length dimensions that take up more memory.</p>
<p>
If you’re trying to retrieve all the rows by using multiple<b> GetRows</b> calls, use the <b>EOF</b> property to be sure that you’re at the end of the <b>Recordset</b>. The <b>GetRows</b> method may return fewer rows than you request. If you request more that the remaining number of rows in a <b>Recordset</b>, for example, the<b> GetRows</b> method only returns the rows that remain. Similarly, if it can’t retrieve a row in the range requested, it doesn’t return that row. For example, if the fifth record cannot be retrieved in a group of ten records that you’re trying to retrieve, the <b>GetRows </b>method returns four records and leaves the current record position on the record that caused a problem—and doesn’t generate a run-time error. This situation may occur if a record in a dynaset was deleted by another user. If it returns fewer records than the number requested and you’re not at the end of the file, you need to read each field in the current record to determine what error the <b>GetRows</b> method encountered.</p>
<p>
Because the <b>GetRows</b> method always returns all the fields in the <b>Recordset</b> object, you may want to create a query that returns just the fields that you need. This is especially important for OLE Object and Memo fields.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on OLE Object and Memo fields, see “The OLE Object and Memo Data Types” later in this chapter.</p>
</FONT></FONT></BODY>
</HTML>
