<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Field Objects</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="usingfieldobjects"></a>Using Field Objects</h2>
<p>
The default collection of a <b>Recordset </b>object is its <b>Fields</b> collection. This collection includes a single <b>Field</b> object that corresponds to each field (or column) in the <b>Recordset</b>. Each <b>Field</b> object has a set of properties that uniquely identifies the field name, data type, and so on, as well as the value of the field in the current record. You use the <b>Field</b> objects in a <b>Recordset</b> object to read and set values for the fields in the current record of the <b>Recordset</b> object.</p>
<p>
You manipulate a field by using a <b>Field</b> object and its methods and properties. For example, you can:
<ul>
<li>
Use the <b>OrdinalPosition</b> property to get or set the position of a <b>Field</b> object relative to other fields in a <b>Fields</b> collection.</li>
<li>
Use the <b>FieldSize</b> property, the <b>GetChunk</b> method, or the <b>AppendChunk</b> method to get or set a value in an OLE Object or Memo field of a <b>Recordset</b> object.</li>
<li>
Read or set the DAO <b>Value</b> property of a <b>Recordset</b> object.</li>
<li>
Read or set the DAO <b>AllowZeroLength</b>,<b> Required</b>,<b> ValidationRule</b>, <b>ValidationText</b>, or <b>ValidateOnSet</b> property setting to find or specify validation conditions.</li>
<li>
Read the <b>SourceField</b> and <b>SourceTable</b> property settings to determine the original source of the data.</li>
</ul>
<h3>Referring to Field Objects</h3>
<p>
You can identify a <b>Field</b> object by its DAO <b>Name</b> property, which corresponds to the column name in the table from which the data in the field was retrieved. The <b>Fields</b> collection is the default collection of a <b>Recordset</b> object. Therefore, you can refer to the LastName field in the rstEmployees <b>Recordset</b> in any of the following ways:</p>
<pre><code>rstEmployees.Fields(&quot;LastName&quot;)
rstEmployees!LastName
rstEmployees![LastName]
</code></pre>
<p>
When using the<b> !</b> operator, you must include brackets around a field name when it contains spaces. For example, the statement:</p>
<pre><code>strEmp = rstEmployees!Last Name
</code></pre>
<p>
will not compile, but the statement:</p>
<pre><code>strEmp = rstEmployees![Last Name]
</code></pre>
<p>
will compile with no problems.</p>
<p>
Within the <b>Fields</b> collection, each <b>Field</b> object can also be identified by its index:</p>
<pre><code>rstEmployees.Fields(0)
</code></pre>
<p>
The index enables you to walk through the collection in a loop, replacing the index with a variable that is incremented with each pass through the loop. Objects in a collection are numbered starting with zero, so the first <b>Field</b> object in the <b>Fields</b> collection is number 0, the second is 1, and so on. The field order is determined by the underlying table. Fields are usually numbered in the order retrieved when the <b>Recordset</b> object is opened. One drawback to this approach is that you can’t be certain which field will be referred to, because the underlying table structure may change, fields may be added or deleted, and so on.</p>
<p>
To help you determine the order of fields in a <b>Fields</b> collection, the <b>Field</b> object supports the <b>OrdinalPosition</b> property, which you can use to get or set a field’s position relative to other fields in the collection. You can set the <b>OrdinalPosition</b> property to any positive integer to change the field order when data is displayed in a form, copied to an array or a Microsoft Excel worksheet, and so on.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>OrdinalPosition</b> property, search the Help index for “OrdinalPosition property.”</p>
<p>
When writing code that refers to fields within a loop, it’s more efficient to refer to <b>Field</b> objects rather than to refer to fields by their names. The following example shows a more efficient way of writing the ChangeTitle procedure discussed earlier in this chapter. Instead of referring to the Title field as <code>rstEmp!Title</code>, it refers to the field by its object variable, which doesn’t require that the field be looked up in the <b>Fields</b> collection every time it’s referred to.</p>
<pre><code>Sub ChangeTitle()

&#09;Dim dbsSales As Database
&#09;Dim rstEmp As Recordset, fldTitle As Field
&#09;Dim wrkCurrent As Workspace

&#09;Set wrkCurrent = DBEngine.Workspaces(0)
&#09;Set dbsSales = OpenDatabase(&quot;Northwind.mdb&quot;)
&#09;Set rstEmp = dbsSales.OpenRecordset(&quot;Employees&quot;, dbOpenTable)

&#09;Set fldTitle = rstEmp.Fields(&quot;Title&quot;)
&#09;wrkCurrent.BeginTrans

&#09;Do Until rstEmp.EOF
&#09;&#09;If fldTitle = &quot;Sales Representative&quot; Then
&#09;&#09;&#09;rstEmp.Edit
&#09;&#09;&#09;fldTitle = &quot;Sales Associate&quot;
&#09;&#09;&#09;rstEmp.Update
&#09;&#09;End If
 
&#09;&#09;rstEmp.MoveNext
&#09;Loop

&#09;If MsgBox(&quot;Save all changes?&quot;, vbQuestion + vbYesNo) = vbYes Then
&#09;&#09;wrkCurrent.CommitTrans
&#09;Else
&#09;&#09;wrkCurrent.Rollback
&#09;End If

&#09;rstEmp.Close
&#09;dbsSales.Close

End Sub
</code></pre>
<h3>Field Data Types</h3>
<p>
A <b>Field</b> object has a <b>Type</b> property that can be set to one of the following 12 DAO data types.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Type property setting</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Data type</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbBoolean</b></td>
<TD>
Boolean</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbByte</b></td>
<TD>
Byte</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbInteger</b></td>
<TD>
Integer</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbLong</b></td>
<TD>
Long</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbCurrency</b></td>
<TD>
Currency</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbSingle</b></td>
<TD>
Single</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbDouble</b></td>
<TD>
Double</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbDate</b></td>
<TD>
Date/Time</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbText</b></td>
<TD>
Text</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbLongBinary</b></td>
<TD>
OLE Object</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbMemo</b></td>
<TD>
Memo</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">dbGUID</b></td>
<TD>
GUID</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
</table>
<p>
For a <b>Field</b> object on a <b>Recordset</b>, the <b>Type</b> property is read-only. However, you must be aware of the field type when copying data to or from a field in code or a “Type mismatch” error may occur. For example, you cannot copy Text data to an Integer field.</p>
<p>
The <b>Type</b> property of a <b>Field</b> object on a <b>Recordset</b> is determined by the underlying table from which the record was retrieved. If you create the table and its fields by using DAO data-definition language (DDL) statements, you can easily determine the data type of the table’s fields.</p>
<p>
If you’re accessing external data through an installable ISAM driver, the data types within external tables may be different from those defined within Microsoft Jet. The installable ISAM driver for the external data source converts external data types into their closest equivalent DAO data type.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on data type conversion in external data sources, see Chapter 18, <a href="accessingexternaldata.htm">“Accessing External Data.”</a></p>
<h4>The GUID Data Type</h4>
<p>
The GUID data type is used to store a globally unique identifier, a unique string of digits that identifies OLE objects, Microsoft SQL&nbsp;Server remote procedure calls, and other entities that need a unique reference identification.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The GUID data type is also used in the <b>Database</b> object’s <b>ReplicaID</b> property to identify a replica. For information on replicas, see Chapter 20, <a href="usingreplicationinyourapplication.htm">“Using Replication in Your Application.”</a></p>
<h4>The Text Data Type</h4>
<p>
For <b>Field</b> objects declared as type Text, you must set the <b>Size</b> property, which indicates the length of the longest string that can be stored in the field. All other types of <b>Field</b> objects have their <b>Size</b> property set automatically.</p>
<h4>The Currency Data Type</h4>
<p>
If you need to store monetary values, use fields of type Currency. Don’t use any of the number data types (such as Single) for currency values, because numbers to the right of the decimal may be rounded during calculations. The Currency data type always maintains a fixed number of digits to the right of the decimal.</p>
<h4>The Long Data Type</h4>
<p>
In some tables, you’ll want to store a series of sequential numbers to uniquely identify records. For example, you may want to start customer order records at order number 1 and begin counting upward.</p>
<p>
Microsoft Access can automatically insert unique numbers in a field, saving your application the effort of generating unique identifiers to be used within a primary key field. To take advantage of this capability, define a field with the Long data type and set the <b>dbAutoIncrField</b> constant in the <b>Field</b> object’s <b>Attributes</b> property. Auto-incrementing fields start at 1 and increment sequentially. Fields of this type are also referred to as <i>AutoNumber</i> <i>fields</i>.</p>
<p>
If you want to establish a primary key/foreign key relationship between two tables by using an AutoNumber field, make sure that the foreign key field is also defined as Long.</p>
<p>
You can also set the DAO <b>DefaultValue</b> property of a <b>Field</b> object on a <b>TableDef</b> object to a special value called GenUniqueId( ). This causes a random number to be assigned to this field whenever a new record is added or created. The field’s <b>Type</b> property must be Long.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;A <b>Field</b> object’s data type is read/write before the field is appended to a table’s <b>Fields</b> collection, and read-only after it’s appended.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the DAO <b>Attributes</b> and <b>DefaultValue</b> properties, search the Help index for the name of the property.</p>
<h4>The OLE Object and Memo Data Types</h4>
<p>
OLE Object and Memo fields are collectively referred to as <i>large value fields</i> because they are typically much larger than fields of other data types. OLE<b> </b>Object fields consist of binary data up to 1.2 gigabytes in size. This type is used to store pictures, files, or other raw binary data. Memo fields are used to store lengthy text and numbers, such as comments or explanations. The size of a Memo field is limited by the maximum size of the database.</p>
<p>
Records within a <b>Recordset </b>object must fit on the 2K data pages supported by the Microsoft Jet database engine. Each <b>Field</b> object you include in the table definition counts toward this 2K total, including OLE Object and Memo fields. However, the amount stored for OLE Object and Memo fields is only 14 bytes per non-null field, and only 1 byte for null<b> </b>fields. The 14 bytes is used to store a pointer to the actual data for these fields, which is located on additional 2K pages. The amount of data committed to each text field isn’t set until you actually store data in the field. You can overcommit a data page by defining more text fields than there would be room for, but no more than about 2K of actual data can be stored in a record. For example, you can define fifteen 250-byte text fields in a record, but the total number of characters stored must be less than 2K.</p>
<p>
When you query tables containing large value fields, don’t include those fields in the field list unless you need them, because returning large value fields takes time. Also, be aware that you can’t index large value fields.</p>
<p>
A snapshot- or forward-only-type <b>Recordset </b>object opened against large value fields in an .mdb file doesn’t actually contain that data. Instead, the snapshot maintains references to the data in the original tables, the same way a dynaset refers to all data.</p>
<h5>Handling Large Value Data</h5>
<p>
Sometimes you’ll need to read or copy data from a large value field where you don’t have sufficient memory to copy the entire field in a single statement. Instead, you have to break up the data into smaller units, or chunks, that will fit available memory. The <b>FieldSize</b> property tells you how large the field is, measured in bytes. Then you can use the <b>GetChunk</b> method to copy a specific number of bytes to a buffer, and use the <b>AppendChunk</b> method to copy the buffer to the final location. You then continue using <b>GetChunk</b> and <b>AppendChunk</b> until the entire field is copied.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on DAO field data types, search the Help index for “data types, Microsoft Jet.”</p>
<h3>Reading and Writing Data</h3>
<p>
When you read or write data to a field, you’re actually reading or setting the DAO <b>Value</b> property of a <b>Field</b> object. The DAO <b>Value</b> property is the default property of a <b>Field</b> object. Therefore, you can set the DAO <b>Value</b> property of the LastName field in the rstEmployees <b>Recordset</b> in any of the following ways:</p>
<pre><code>rstEmployees!LastName.Value = strName
rstEmployees!LastName = strName
rstEmployees![LastName] = strName
</code></pre>
<h4>Write Permission</h4>
<p>
The tables underlying a <b>Recordset</b> object may not permit you to modify data, even though the <b>Recordset</b> is of type dynaset or table, which are usually updatable. Check the <b>Updatable</b> property of the <b>Recordset</b> to determine whether its data can be changed. If the property is <b>True</b>, the <b>Recordset </b>object can be updated.</p>
<p>
Individual fields within an updatable <b>Recordset</b> object may not be updatable, and trying to write to these fields generates a run-time error. To determine whether a given field is updatable, check the <b>DataUpdatable</b> property of the corresponding <b>Field </b>object in the<b> Fields</b> collection of the <b>Recordset</b>. The following example returns <b>True</b> if all fields in the dynaset created by strQuery are updatable and returns <b>False</b> otherwise.</p>
<pre><code>Function blnUpdatable(strQuery As String) As Boolean
&#09;Dim dbs As Database, rstDynaset As Recordset, intI As Integer

&#09;On Error GoTo ErrorHandler

&#09;' Initialize the function's return value to True.
&#09;blnUpdatable = True

&#09;Set dbs = CurrentDb
&#09;Set rstDynaset = dbs.OpenRecordset(strQuery, dbOpenDynaset)

&#09;' If the entire dynaset isn't updatable, return False.
&#09;If rstDynaset.Updatable = False Then
&#09;&#09;blnUpdatable = False
&#09;Else
&#09;&#09;' If the dynaset is updatable, check if all fields in the dynaset are updatable.
&#09;&#09;' If one of the fields isn't updatable, return False.
&#09;&#09;For intI = 0 To rstDynaset.Fields.Count - 1
&#09;&#09;&#09;If rstDynaset.Fields(intI).DataUpdatable = False Then
&#09;&#09;&#09;&#09;blnUpdatable = False
&#09;&#09;&#09;&#09;Exit For
&#09;&#09;&#09;End If
&#09;&#09;Next intI
&#09;End If

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 0
&#09;&#09;&#09;Exit Function
&#09;&#09;Case Else
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;Exit Function
&#09;End Select

End Function
</code></pre>
<h4>Criteria</h4>
<p>
Any single field can impose a number of criteria on data in that field when records are added or updated. These criteria are defined by a handful of properties. The DAO <b>AllowZeroLength</b> property on a Text or Memo field indicates whether or not the field will accept a zero-length string (&quot;&quot;). The DAO <b>Required</b> property indicates whether or not some value must be entered in the field, or if it instead can accept a <b>Null </b>value. For a <b>Field</b> object on a <b>Recordset</b>, these properties are read-only; their state is determined by the underlying table.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the DAO <b>AllowZeroLength</b> and <b>Required </b>properties, search the Help index for the name of the property.</p>
<h5>Field-Level Data Validation</h5>
<p>
<i>Validation</i> is the process of determining whether data entered into a field’s DAO <b>Value</b> property is within an acceptable range. A <b>Field</b> object on a <b>Recordset</b> may have the DAO <b>ValidationRule</b> and <b>ValidationText</b> properties set. The DAO <b>ValidationRule</b> property is simply a criteria expression, similar to the criteria of an SQL WHERE clause, without the WHERE keyword. The DAO <b>ValidationText</b> property is a string that Microsoft Access displays in an error message if you try to enter data in the field that’s outside the limits of the DAO <b>ValidationRule</b> property. If you’re using DAO in your code, then you can use the DAO <b>ValidationText</b> for a message that you want to display to the user.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The DAO <b>ValidationRule</b> and <b>ValidationText</b> properties also exist at the <b>Recordset</b> level. These are read-only properties, reflecting the table-level validation scheme established on the table from which the current record is retrieved.</p>
<p>
A <b>Field </b>object on a <b>Recordset</b> also features the <b>ValidateOnSet</b> property. When the <b>ValidateOnSet</b> property is set to <b>True</b>, Microsoft Access checks validation as soon as the field’s DAO <b>Value</b> property is set. When it’s set to <b>False </b>(the default), Microsoft Access checks validation only when the completed record is updated. For example, if you’re adding data to a record that contains a large Memo or OLE Object field and that has the DAO <b>ValidationRule</b> property set, you should determine whether the new data violates the validation rule before trying to write the data—you should write the data when the field value is set. To do so, set the <b>ValidateOnSet</b> property to <b>True</b>. If you wait to check validation until the entire record is written to disk, you may waste time trying to write an invalid record to disk.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the DAO <b>ValidationRule</b>, <b>ValidationText</b>, and <b>ValidateOnSet</b> properties, search the Help index for the name of the property.</p>
<h3>Tracing the Origin of Dynaset Fields</h3>
<p>
A dynaset-type <b>Recordset</b> object can include records from more than one source table. Also, within a single record, fields from different tables can be joined into new records. Sometimes it’s useful to know the table from which a field originated. The <b>SourceTable</b> property of a <b>Field</b> object returns the name of the table from which the field’s current data was retrieved.</p>
<p>
Within a query, a field can be renamed for display purposes. For example, in an SQL SELECT query, the AS operator in the select field list can create an alias for one of the returned fields. In a <b>Recordset </b>based on an SQL query, a field that has been aliased is represented by a <b>Field</b> object whose DAO <b>Name</b> property reflects the alias, not the original field name. To find out the original field name, check the <b>Field</b> object’s <b>SourceField</b> property.</p>
</FONT></FONT></BODY>
</HTML>
