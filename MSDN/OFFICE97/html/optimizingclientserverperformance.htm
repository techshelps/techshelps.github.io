<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Optimizing Client/Server Performance</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="optimizingclientserverperformance"></a>Optimizing Client/Server Performance</h2>
<p>
In addition to functional differences between local and remote tables, there are often considerable performance differences. Some parts of your application that perform well with local data may be significantly slower when the data is on a server, and may cause too much network traffic or use excessive server resources. This section discusses techniques you can use to improve the performance of client/server applications.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on optimizing any application, see Chapter 13, <a href="optimizingyourapplication.htm">“Optimizing Your Application.”</a></p>
<h3>Speeding Up Queries</h3>
<p>
The best way to improve the performance of queries on remote data is to have the server run as much of the query as possible. Microsoft Access attempts to send the entire query to the server, but evaluates locally any query clauses and expressions that aren’t supported by servers in general or by your server in particular. Some information about server capability is available when you link a remote table.</p>
<p>
If a query contains expressions that can’t be evaluated by your server, more or less of the query is evaluated locally, depending on where the expressions occur. Queries with such expressions in the SELECT clause are still evaluated on the server, unless they occur in a totals query, a union query, or a query that uses the DISTINCT predicate, in which case they are evaluated locally. Such expressions in other clauses (for example, WHERE, ORDER BY, and GROUP BY clauses) cause at least part of the query to be evaluated locally.</p>
<p>
This section describes how to design queries that maximize the use of the server and thereby improve query performance.</p>
<h4>Using Supported Functionality</h4>
<p>
If possible, don’t design queries that use functionality not generally supported by servers. The following sections identify some areas of functionality that aren’t generally supported and others that usually are.</p>
<h5>Functionality Not Supported by Most Servers</h5>
<p>
Most servers don’t support:
<ul>
<li>
Operations that can’t be expressed in a single SQL statement—for example, when a query’s FROM clause contains a totals query or a query that uses the DISTINCT predicate. Often, you can rearrange your queries so that they calculate totals or apply the DISTINCT predicate after all other operations.</li>
<li>
Operations that are Microsoft Access–specific extensions to SQL, such as complex crosstab queries, queries that use the TOP predicate or the <b>TopValues</b> property, and reports that have multiple levels of grouping and totals.</li>
<li>
Expressions that contain operators or functions specific to Microsoft Access. For example, the Microsoft Access financial and domain aggregate functions have no server equivalents.</li>
<li>
User-defined functions in Visual Basic that take remote fields as arguments. These functions don’t exist on the server, but must process remote field data.</li>
<li>
Heterogeneous joins between local tables and remote tables, or between remote tables in different ODBC data sources.<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information, see “Heterogeneous Joins” later in this section.</p>
</li>
<li>
Expressions or union queries that mix text and numeric data types. Most servers lack the data type leniency of Microsoft Access. If you need to mix data types, use explicit conversion functions.</li>
</ul>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For a list of DAO objects and methods that aren’t supported for use with external data sources that don’t use Microsoft Jet, see “Unsupported Objects and Methods” in Chapter 18, “Accessing External Data.”</p>
<h5>Functionality Supported by Some Servers</h5>
<p>
Servers differ in certain areas of functionality. Some servers support:
<ul>
<li>
Outer joins. (Note that Microsoft Access doesn’t send multiple outer joins to a server, although many inner joins can accompany a single outer join.)</li>
<li>
Numeric, string, and date/time functions (such as the <b>Log</b>, <b>Mid$</b>, and <b>DatePart</b> functions).</li>
<li>
Conversion functions (such as the <b>CInt</b>, <b>CStr</b>, and <b>CVDate</b> functions).</li>
</ul>
<p>
If the operation is supported, it’s sent to the server for processing; otherwise, it’s performed locally.</p>
<h4>Splitting WHERE Clause Restrictions</h4>
<p>
If a query’s SQL statement includes a WHERE clause that the server can’t evaluate completely, Microsoft Access splits the clause into several parts (linked by the AND operator), and sends as many of these parts to the server as possible. For example, suppose you write a function in Visual Basic called ProcessData and run the following query:</p>
<pre><code>SELECT field1, field2, field3
&#09;FROM table1
&#09;WHERE (field1 = 100 OR field1 = 200)
&#09;AND ProcessData(field2) &gt; 100
&#09;AND field3 LIKE &quot;A*&quot;
</code></pre>
<p>
Microsoft Access sends the following query to the server and evaluates <code>ProcessData(field2) &gt; 100</code> locally on the records returned.</p>
<pre><code>SELECT field1, field2, field3
&#09;FROM table1
&#09;WHERE (field1 = 100 OR field1 = 200)
&#09;AND field3 LIKE &quot;A*&quot;
</code></pre>
<p>
If you need to use a WHERE clause restriction that your server can’t process, you can limit the amount of data Microsoft Access requests by providing additional restrictions that your server can process. For maximum efficiency, these restrictions should involve fields indexed on the server.</p>
<h4>Optimizing Expressions That ContainMicrosoft Access–Specific Elements</h4>
<p>
If expressions in your queries contain user-defined functions, domain aggregate functions, and other elements specific to Microsoft Access (such as the <b>IIf</b> and <b>Choose</b> functions), they can’t be completely run by a server. If an expression that uses one of these elements involves remote data fields, Microsoft Access runs it locally and retrieves all necessary data from the server. If such an expression involves only constants and query parameters, however, Microsoft Access evaluates it just once and sends the result to the server as a query parameter.</p>
<p>
Whenever possible, optimize your queries by avoiding references to remote fields in expressions that can’t be evaluated by the server. For example, suppose you have a remote Tasks table with a Status field that contains code numbers (1 means unfinished and 2 means complete). The following query requires a user to type <b>1</b> or <b>2</b>, which isn’t very intuitive.</p>
<pre><code>SELECT * FROM Tasks
&#09;WHERE Status = [What Status?]
</code></pre>
<p>
In contrast, the following query allows the user to type <b>Unfinished</b> or <b>Complete</b> when prompted.</p>
<pre><code>SELECT * FROM Tasks
&#09;WHERE [What Status?] = IIf(Status=1,'Unfinished','Complete')
</code></pre>
<p>
However, because the <b>IIf</b> function uses the remote Status field, Microsoft Access sends the first part of the statement <code>(SELECT * FROM Tasks)</code> to the server and evaluates the restriction on each record locally.</p>
<p>
The following query also allows the user to type words instead of numbers.</p>
<pre><code>SELECT * FROM Tasks
&#09;WHERE Status = IIf([What Status?]='Unfinished',1,2)
</code></pre>
<p>
However, because the return value of the <b>IIf</b> function is effectively constant, Microsoft Access evaluates it once locally and sends the following statement to the server, supplying this part of the expression as a parameter value.</p>
<pre><code>SELECT * FROM Tasks
&#09;WHERE Status = ?
</code></pre>
<p>
This method is more efficient and reduces network traffic.</p>
<h4>Heterogeneous Joins</h4>
<p>
To perform a <i>heterogeneous join</i>—a join between local and remote tables—Microsoft Access either:
<ul>
<li>
Requests all the records in the remote table or tables and performs the join locally.</li>
<li>
Performs a <i>remote index join</i>. This means that for each key in the local table, Microsoft Access asks the server only for the records with a matching key value.</li>
</ul>
<p>
Microsoft Access uses a remote index join only if the remote field being joined is indexed and if the local table is considerably smaller than the remote table. For example, to join a local table called Employees that contains 10 records and a remote table called Tasks that contains 50 records on the EmployeeID field, Microsoft Access retrieves the 50 records from the Tasks table on the server and processes the join locally. However, if the remote table contains 1,000 records, Microsoft Access performs a remote index join. It sends 10 of the following queries to the server, supplying each EmployeeID value from the local Employees table as a parameter value.</p>
<pre><code>SELECT EmployeeID, TaskID
&#09;FROM Tasks
&#09;WHERE EmployeeID = ?
</code></pre>
<p>
This is generally much faster than retrieving all 1,000 records.</p>
<p>
Always index the remote join field so that Microsoft Access can perform a remote index join when appropriate. Regardless of whether or not Microsoft Access can perform a remote index join, you can improve the performance of a query that uses a heterogeneous join by supplying additional restrictions on remote fields. Microsoft Access sends these restrictions to the server, limiting the amount of data requested for the join.</p>
<h3>Speeding Up Forms</h3>
<p>
When you design a form based primarily on server data, take a minimalist approach for the best performance. Determine what data and functionality you need, and design forms that delay asking for this data and functionality until requested by the user. This section presents several minimalist techniques for improving the performance of your forms.</p>
<h4>Requesting Less Data</h4>
<p>
The more data you request from the server, the more processing time you use and the more network traffic you create. To request less data in your forms:
<ul>
<li>
Request as few records as necessary. For example, rather than opening a large <b>Recordset</b> object and navigating with one of the Find methods, use a filter or query to limit the size of the <b>Recordset</b>, being careful to use restrictions that the server can process.</li>
<li>
Base your forms on queries that select as few remote fields as necessary. That way, only fields used on the form are actually retrieved from the server. If you need to add fields to the form later, you can use the Query Builder (available from the <b>RecordSource</b> property box in the property sheet for the form).</li>
<li>
Use fewer bound controls, such as text boxes, list boxes, and combo boxes. Each form control that is bound to a remote field requires a separate query to be sent to the server when the form is opened. In particular, avoid controls that contain totals, and list boxes and combo boxes with large row sources for the list.</li>
</ul>
<h4>Displaying Fields Only on Request</h4>
<p>
In some cases, you may want a form to display all the fields in a record. In other cases, you may not need to make all the fields available to the user. To speed up the processing of your forms, you can use the following techniques to avoiding retrieving unnecessary data:
<ul>
<li>
Display the most important fields on a main form and provide a button to open another form that contains the other fields. Base the second form on a query that uses the primary key value on the main form as criteria. For example, suppose you have a main form based on the following query:<pre><code>SELECT OrderID, CustomerID, OrderDate, ShipVia, ShippedDate
&#09;FROM Orders
</code></pre>
<p>
You could base the second form on the following query, which runs only when the user clicks a button to request more information:</p>
<pre><code>SELECT Orders.*, Customers.*, Employees.*
&#09;FROM (Orders INNER JOIN Customers
&#09;&#09;ON Orders.CustomerID = Customers.CustomerID)
&#09;&#09;INNER JOIN Employees
&#09;&#09;ON Orders.EmployeeID = Employees.EmployeeID
&#09;WHERE OrderID = Forms!Orders!OrderID
</code></pre>
</li>
<li>
Display Memo and OLE Object fields on a form only when the user requests to see the information. Because Microsoft Access doesn’t retrieve Memo and OLE Object fields until they are displayed on the screen, waiting to display this data until it is needed improves performance. You can place Memo and OLE Object fields off screen on another form page. Add a label to the form, such as “Scroll down to see notes and pictures,” that tells the user how to display the information.</li>
<li>
Set the <b>Visible</b> property to No for controls bound to Memo and OLE Object fields, and add a toggle button or command button that sets the property to Yes when the user wants to view the contents of these controls.</li>
</ul>
<h4>Downloading Data You Use in More Than One Form</h4>
<p>
Often, an application contains several forms that use the same remote table—for example, as the source for a list box or combo box. If the data in the table doesn’t change frequently, you can speed up form loading and reduce server load by using one of the following techniques:
<ul>
<li>
If the data in the table never changes (such as the names and abbreviations of states or regions), store the table in the local Microsoft Access database. If the table is joined in queries with remote tables, also keep a copy of it on the server to avoid heterogeneous joins.</li>
<li>
If the data in the table changes rarely (such as a list of the buildings that a company owns), store the table both on the server and in the local Microsoft Access database. Your application must provide a way for the user to download the current data when it changes.</li>
<li>
If the data in the table changes occasionally (that is, less than daily, such as the employees in a small company or department), store the table both on the server and in the local Microsoft Access database. When your application starts, it must check to see if the tables are out of sync and download the current data from the server. This method uses extra time when your application starts, but your queries run faster.</li>
</ul>
<p>
In the following example, the LclDepts and LclEmps tables are local versions of the linked server tables RmtDepts and RmtEmps. The example empties the LclDepts and LclEmps tables and then repopulates them with the contents of the tables on the server.</p>
<pre><code>Dim wrkRemote As Workspace, dbsRemote As Database

Set wrkRemote = DBEngine.Workspaces(0)
Set dbsRemote = wrkRemote.Databases(0)

wrkRemote.BeginTrans
&#09;With dbsRemote
&#09;&#09;.Execute &quot;DELETE FROM LclDepts&quot;
&#09;&#09;.Execute &quot;INSERT INTO LclDepts SELECT * FROM RmtDepts&quot;
&#09;&#09;.Execute &quot;DELETE FROM LclEmps&quot;
&#09;&#09;.Execute &quot;INSERT INTO LclEmps SELECT * FROM RmtEmps&quot;
&#09;End With
wrkRemote.CommitTrans
</code></pre>
<p>
This example uses the <b>BeginTrans</b> and <b>CommitTrans</b> methods to make the downloading operation a transaction. This delays writing any data to disk until the <b>CommitTrans</b> method runs.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on using transactions, see “Using Transactions” later in this chapter.</p>
<h4>Using Less Functionality</h4>
<p>
To improve the performance of your client/server application, you may want to avoid using some of the more powerful features of Microsoft Access. This section discusses when you can improve performance by using less functionality in your forms.</p>
<h5>Snapshots vs. Dynasets</h5>
<p>
Microsoft Access provides two types of <b>Recordset</b> objects on which you can base your forms: dynasets, which can be updated, and snapshots, which cannot. If you don’t need to update data with your form, and the <b>Recordset</b> contains fewer than 500 records, you can reduce the time it takes the form to open by setting the form’s <b>RecordsetType</b> property to Snapshot. This causes Microsoft Access to use a snapshot-type <b>Recordset</b> object as the record source for the form, which is generally faster than using a dynaset.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;If you’re opening a snapshot in Visual Basic and need to make only one pass through the results, you can make the snapshot even more efficient by using the <b>dbForwardOnly</b> constant of the <b>OpenRecordset</b> method. This constant opens a forward-only-type <b>Recordset</b> object. For more information on forward-only-type <b>Recordset</b> objects, see Chapter 9, <a href="workingwithrecordsfields.htm">“Working with Records and Fields.”</a></p>
<p>
However, if the <b>Recordset</b> you’re using is large, or if it contains Memo or OLE Object fields, using a dynaset is more efficient. If you use a dynaset, Microsoft Access retrieves only the primary key of each record; if you use a snapshot, it retrieves the entire record. A dynaset is also more efficient because Memo and OLE Object fields are retrieved only if they are displayed on the screen or directly referenced in your code.</p>
<h5>Multiple-Table Queries vs. Subforms</h5>
<p>
Two methods are available for displaying information from multiple tables in a form: you can either base the form on a query that joins the tables, or you can place one or more subforms on the form. The first approach usually sends a single query to the server, which creates the join. The second approach sends at least two queries: one to retrieve the data for the main form and one for each embedded subform. This second approach requires more time for the form to load as well as more overhead.</p>
<p>
Because you can update and insert data in almost every field of a multiple-table query, a subform is often unnecessary. If you don’t need the convenient display capabilities of a subform, base your form on a single query for better performance.</p>
<h3>Improving the Performance of Updates and Deletions</h3>
<p>
Probably the simplest way to improve the performance of updates and deletions—especially if your remote table has many fields—is to add a <i>version field</i> (sometimes called a <i>timestamp</i>) to the remote table. A version field is maintained by the server, and its value automatically changes each time the record is updated. Typically, you can’t read the contents of a version field, but Microsoft Access uses it to detect changes in records.</p>
<p>
When updating or deleting a record, Microsoft Access checks to see if the version field has changed. If it has, the update or deletion is canceled to avoid overwriting another user’s changes. If the table doesn’t have a version field, Microsoft Access compares all the old field values to their current values in order to determine whether data has changed. This is less efficient and generates more network traffic. Moreover, when Microsoft Access checks values, data that hasn’t changed occasionally appears as if it had, either because of inaccuracies inherent in comparing floating-point numbers, or because Memo and OLE Object fields aren’t compared at all.</p>
<p>
To add a version field to a remote table, you can use the ALTER TABLE statement. For example, the following command adds a version field to a SQL Server table:</p>
<pre><code>ALTER TABLE RemoteTable ADD VersionCol TIMESTAMP
</code></pre>
<p>
You can run this statement as a pass-through query in Microsoft Access or use the administration tools available on your server to add the field. If you add fields to a remote table, relink the table to inform Microsoft Access of the new field’s existence.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Not all servers support version fields. To see if yours does, check the server’s documentation.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the ALTER TABLE statement, search the Help index for “ALTER TABLE statement.”</p>
<h3>Using Transactions</h3>
<p>
A powerful way to improve the performance of updates as well as multiuser concurrency is to use transactions. With transactions, Microsoft Jet accumulates multiple updates and writes them as a single batch. By performing operations as a batch, transactions ensure that operations either succeed or fail as a group, shielding other users from partially completed updates.</p>
<p>
You can control transactions in Visual Basic only by using the <b>BeginTrans</b>, <b>CommitTrans</b>, and <b>Rollback</b> methods of the <b>Workspace</b> object. To improve the performance of your application, use a transaction with:
<ul>
<li>
A sequence of <b>Recordset</b> updates, insertions, or deletions, or any combination of the three.</li>
<li>
A sequence of action queries.</li>
<li>
A sequence of pass-through queries that change data.</li>
<li>
Any combination of these operations in a sequence.<p>
<img src="abac19_2.gif" border=0></p>
</li>
</ul>
<p>
Tip   On most servers, transactions generate locks that prevent other users from updating or even reading data affected by the transaction until it’s committed or rolled back. Therefore, keep your transactions as short as possible, and avoid placing code sequences that wait for a user’s input inside a transaction.</p>
<h4>Batching Updates</h4>
<p>
The following example demonstrates how to use a transaction in Visual Basic to perform multiple updates in a batch. It uses three pass-through queries in a transaction to transfer money from a savings account to a checking account. The Microsoft Access application (the client) sends queries and updates to the server and retrieves the data it needs.</p>
<pre><code>Sub TransferFunds()
&#09;Dim wrkBatchUpdate As Workspace, dbsTransaction As Database
&#09;Dim qdfUpdateQuery As QueryDef

&#09;On Error GoTo TransferFailed
&#09;
&#09;Set wrkBatchUpdate = DBEngine.Workspaces(0)
&#09;Set dbsTransaction = wrkBatchUpdate.Databases(0)
&#09;wrkBatchUpdate.BeginTrans&#09;&#09;' Begin transaction.

&#09;' Create pass-through query.
&#09;Set qdfUpdateQuery = dbsTransaction.CreateQueryDef(&quot;&quot;)

&#09;With qdfUpdateQuery
&#09;&#09;.Connect = &quot;ODBC;DSN=Bank;UID=teller;DATABASE=access&quot;
&#09;&#09;.ReturnsRecords = False
&#09;&#09;.SQL = &quot;UPDATE Accounts SET Balance = Balance - 100 &quot; &amp; _
&#09;&#09;&#09;&quot;WHERE AccountID = 'SMITH_SAV'&quot;
&#09;&#09;.Execute&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Subtract from savings account.
&#09;&#09;.SQL = &quot;UPDATE Accounts SET Balance = Balance + 100 &quot; &amp; _
&#09;&#09;&#09;&quot;WHERE AccountID = 'SMITH_CHK'&quot;
&#09;&#09;.Execute&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Add to checking account.
&#09;&#09;.SQL = &quot;INSERT INTO LogBook &quot; &amp; _
&#09;&#09;&#09;&quot;(Type, Source, Destination, Amount)&quot; &amp; _
&#09;&#09;&#09;&quot;VALUES ('Transfer', 'SMITH_SAV', 'SMITH_CHK', 100)&quot;
&#09;&#09;.Execute&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Log transaction.
&#09;End With
&#09;wrkBatchUpdate.CommitTrans&#09;' Commit transaction.
&#09;Exit Sub

TransferFailed:
&#09;MsgBox Err
&#09;wrkBatchUpdate.Rollback&#09;&#09;&#09;' Roll back if any Execute fails.
&#09;Exit Sub
End Sub
</code></pre>
<p>
Note the use of the <b>CreateQueryDef</b> method to create a temporary pass-through query. This technique introduces the minimum possible overhead for Microsoft Jet, while still making use of transactions transparently through Visual Basic. However, it limits functionality to what the server provides, and it is more difficult to define a parameter query this way.</p>
<h4>Batching Insertions</h4>
<p>
If your application provides data-entry forms for multiple records of data, such as an order entry system, you can improve performance and robustness by saving new records in a local holding table and then transferring batches of records from the holding table to the server all at once within a transaction.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To insert a batch of records on a server by using a transaction</b>
<ol>
<li>
Create empty local tables that contain the same fields as your remote tables.</li>
<li>
Create a data-entry form based on these local tables.</li>
<li>
On the form, create a command button labeled “Post Records” for sending records to the server.</li>
<li>
Create an event procedure for the button’s Click event that copies the local records to the server tables and deletes the records from the local tables. The event procedure should perform all insertions and deletions within a transaction.</li>
</ol>
<p>
For example, suppose you have an Orders form that contains an Order Details subform based on two local tables, LclOrders and LclOrderDetails. The user enters a new order and a group of detail records in the subform. When the user clicks the PostRecords command button on the Orders form, the following procedure runs:</p>
<pre><code>Private Sub PostRecords_Click
&#09;Dim wrkTransaction As Workspace, dbsPosting As Database

&#09;On Error GoTo TransferFailed
&#09;
&#09;Set wrkTransaction = DBEngine.Workspaces(0)
&#09;Set dbsPosting = wrkTransaction.Databases(0)

&#09;wrkTransaction.BeginTrans&#09;&#09;&#09;' Begin transaction.
&#09;With dbsPosting
&#09;&#09;.Execute &quot;INSERT INTO RmtOrdersEmpty SELECT * &quot; &amp; _
&#09;&#09;&#09;&quot;FROM LclOrders&quot;, dbFailOnError
&#09;&#09;.Execute &quot;INSERT INTO RmtOrderDetailsEmpty SELECT * &quot; &amp; _
&#09;&#09;&#09;&quot;FROM LclOrderDetails&quot;, dbFailOnError
&#09;&#09;.Execute &quot;DELETE FROM LclOrders&quot;
&#09;&#09;.Execute &quot;DELETE FROM LclOrderDetails&quot;
&#09;End With
&#09;wrkTransaction.CommitTrans&#09;&#09;' Commit transaction.
&#09;Me.Requery&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Clear form for next order entry.
&#09;Exit Sub

TransferFailed:
&#09;MsgBox Err

&#09;wrkTransaction.Rollback&#09;&#09;&#09;&#09;' Roll back if any Execute fails.
&#09;Exit Sub
End Sub
</code></pre>
<p>
This procedure doesn’t insert the records directly into the tables on the server. RmtOrdersEmpty and RmtOrderDetailsEmpty aren’t the remote tables; instead, they are the following queries, which are based on the linked remote tables but return no records.</p>
<pre><code>SELECT * FROM RmtOrders WHERE False
SELECT * FROM RmtOrderDetails WHERE False
</code></pre>
<p>
For these append queries, inserting records into empty queries on linked remote tables provides the fastest possible speed, similar to opening a <b>Recordset</b> by using the <b>OpenRecordset</b> method with the <b>dbAppendOnly</b> constant.</p>
<p>
After this code deletes the records from the local tables, it uses the <b>Requery</b> method to present the user with a blank form for the next entry. In addition, it uses the <b>dbFailOnError</b> constant with the two append queries so that an error occurs if any part of either query fails. The error handler then rolls back any changes made.</p>
<h4>Limitations of Transactions</h4>
<p>
Although using transactions can improve the performance of your client/server applications, they do have several limitations:
<ul>
<li>
Although you can nest transactions in Visual Basic, servers generally don’t support nested transactions. Microsoft Access sends only the first-level transaction to a server.</li>
<li>
Depending on your server, some pass-through queries may not be allowed within a transaction. For example, some servers don’t allow data-definition queries within transactions. To determine the limits for your server, check its documentation.</li>
</ul>
<p>
Avoid sending server-specific transaction commands in pass-through queries because these commands may confuse the internal tracking of server transactions performed by Microsoft Jet. Instead, use the <b>BeginTrans</b>, <b>CommitTrans</b>, and <b>Rollback</b> methods. Microsoft Access translates these methods into the appropriate server commands.</p>
<p>
When you work with local data, each <b>Workspace</b> object represents an isolated transaction space. However, this isn’t the case for remote data used within the <b>Workspace</b> object. You can force a <b>Workspace</b> object to have a distinct remote transaction space by setting the <b>IsolateODBCTrans</b> property of the <b>Workspace</b> object to <b>True</b>. This prevents the <b>Workspace</b> object from sharing connections with other <b>Workspaces</b>, thus guaranteeing transaction isolation. You need to do this only if you use multiple concurrent transactions on your server (which isn’t very common).</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>IsolateODBCTrans</b> property, search the Help index for “IsolateODBCTrans property.” For more information on transactions, see Chapter 9, <a href="workingwithrecordsfields.htm">“Working with Records and Fields,”</a> or search the Help index for “transactions in DAO.”</p>
<h3>Using Remote Data Caching in Recordsets</h3>
<p>
Another way to improve your application’s performance is to cache remote data. Datasheets and forms based on remote data automatically cache data, but dynasets created in Visual Basic do not. If you’ll be moving around in and retrieving data from a small range of records (less than 200), you should explicitly use remote data caching. You can use the <b>CacheStart</b> and <b>CacheSize</b> properties to specify the range you want within the <b>Recordset</b>. Use the <b>FillCache</b> method to quickly fill all or part of this range with data from the server.</p>
<p>
Caching also helps when you simulate an action query by using a <b>Recordset</b>. You may want to do this if the operations involved are too complex for an action query. Typically, to simulate an action query, you advance through each record in the <b>Recordset</b>, analyze the record’s contents, and possibly update or delete the record. You can greatly improve performance if you move through the<b> Recordset</b> and fill the cache before processing every 100 records, even if you make only one pass through the <b>Recordset</b>.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on data caching, search the Help index for “caching data.”</p>
<h3>Using the MSysConf Table to Control Background Population</h3>
<p>
You can control <i>background population</i>, which is the rate at which Microsoft Access reads records from the server during idle time, by creating a table named MSysConf on your server. In the MSysConf table, you can set the number of rows of data that are retrieved at one time and the number of seconds of delay between each retrieval. If you’re experiencing excessive read locking on the server, you can adjust the table settings to increase background population speed. If too much network traffic is generated by background population, adjust the settings to slow it down.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Unlike Microsoft Access forms and datasheets, <b>Recordset</b> objects you create in Visual Basic code aren’t populated during idle time. If your server places read locks on records as they are retrieved, you shouldn’t remain on a record or page for an extended period of time. Partially populated <b>Recordset</b> objects in your Visual Basic code can prevent other users from updating data. If the <b>Recordset</b> is small, you can use the <b>MoveLast</b> method to fully populate the <b>Recordset</b> and clear any such locks. If the <b>Recordset</b> is large, you may want to use a Timer event procedure to implement your own version of background population.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the MSysConf table, search the Help index for “MSysConf table.”</p>
</FONT></FONT></BODY>
</HTML>
