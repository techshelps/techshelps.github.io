<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Locking Shared Data in Recordsets</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="lockingshareddatainrecordsets"></a>Locking Shared Data in Recordsets</h2>
<p>
Although bound forms are one way to create a multiuser application, they don’t provide the flexibility that Visual Basic procedures do. When you write your own locking procedures and run them from unbound forms, you can adapt your locking strategy and handle conflicts among users in a way more suitable for your situation—something that isn’t possible with bound forms.</p>
<h4>Levels of Locking</h4>
<p>
There are three different levels at which you can lock data in <b>Recordset</b> objects:
<ul>
<li>
<i>Exclusive mode</i> prevents all other users from using the entire database. This is the most restrictive level.</li>
<li>
<i>Recordset locking</i> locks a <b>Recordset</b> object’s underlying tables.</li>
<li>
<i>Page locking</i> locks the 2,048 byte (2K) page where the data that is being edited resides. This is the least restrictive level.</li>
</ul>
<p>
To determine at which level you want to lock objects in your application, you must decide the level of <i>concurrency</i> that you need. Concurrency is the ability of more than one transaction to access the same data at the same time. For example, if you want the objects to be available as often as possible to as many users as possible, a high-concurrency strategy would dictate that you use page locking, which is the least restrictive level. However, if your application requires guaranteed access to most or all of the data in the database, you may opt for exclusive mode. This ensures that your application has the database open exclusively so it can’t be shared by other users. </p>
<p>
The three levels aren’t mutually exclusive. Many multiuser applications use all three levels at different times. For example, in an order entry system in which you want many order takers to have access to data simultaneously, you can use page locking to lock data in the Orders table. You can use recordset locking at the end of the day to lock a summary table and update it with summary data. Finally, you can use exclusive mode each night to compact the database.</p>
<h4>Using Exclusive Mode</h4>
<p>
Exclusive mode is the most restrictive way you can lock data. It prevents all other users from opening the database; therefore, it denies all users access to all data in the database. This is useful for performing administrative or bulk changes to the database, such as repair or compact operations, or when making changes to the database’s underlying structure, or <i>schema</i>.</p>
<p>
When you access a database in a single-user environment, you typically open it in exclusive mode. This may provide better performance because Microsoft Jet doesn’t have to lock and unlock objects or refresh its cache. When you access a database in a multiuser environment, exclusive mode is no longer an option; you must open the database in shared mode.</p>
<p>
If you want multiple users to share data with your application, make sure none of them open your application’s database in exclusive mode. You can use security features in Microsoft Access to deny most users Open Exclusive permission. The database administrator should have Open Exclusive permission to perform such tasks as compacting and repairing the database. </p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on setting permissions, search the Help index for “setting permissions.”</p>
<p>
You can use code to open a database in exclusive mode. To do so, use the <b>OpenDatabase</b> method on the current <b>Workspace</b> object, and specify <b>True</b> for the <i>options</i> argument. The following procedure opens the Northwind sample database in exclusive mode and checks for errors to determine if the operation was successful:</p>
<pre><code>Sub OpenDatabaseExclusive()

&#09;Dim dbs As Database
&#09;Dim errCurrent As Error

&#09;' Try to open the Northwind database exclusively.
&#09;On Error Resume Next
&#09;Set dbs = OpenDatabase(&quot;Northwind.mdb&quot;, True)

&#09;If Err &lt;&gt; 0 Then
&#09;&#09;' If errors occur, display them.
&#09;&#09;For Each errCurrent In DBEngine.Errors
&#09;&#09;&#09;Debug.Print errCurrent.Description
&#09;&#09;Next
&#09;Else
&#09;&#09;' No errors: You have exclusive access.
&#09;&#09;Debug.Print &quot;The database is open in exclusive mode.&quot;
&#09;End If

&#09;dbs.Close
End Sub
</code></pre>
<p>
Using Visual Basic to open the Northwind sample database in exclusive mode has the same effect as selecting the <b>Exclusive</b> check box in the <b>Open</b> dialog box (<b>File</b> menu). If one user already has the database open for write access, and another user tries to open the database in exclusive mode, a locking error occurs. The second user can’t open the database in exclusive mode until the first user closes it.</p>
<h5>Using Read-Only Mode</h5>
<p>
If the database is opened in exclusive mode with read-only access (both the <i>options </i>and <i>read-only </i>arguments of the <b>OpenDatabase</b> method are specified as <b>True</b>), any user can read the database, but no user—including the user who opened it—can write to it. You may want to do this to force other users to open the database in read-only mode without establishing user-level security.</p>
<p>
When you open a database in read-only mode without also specifying exclusive mode, you cannot change objects in the database; this includes data and structural information. However, this mode doesn’t prevent other users from changing data.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Opening a database in read-only mode doesn’t prevent locking conflicts.</p>
<h5>Checking for Errors</h5>
<p>
When you are setting locks in code with any level of locking, it’s important that you handle any errors that occur. In Microsoft Access, you don’t check to see if a lock can be set before you set it. Instead, you try the operation and then check to see if it succeeded.</p>
<p>
The typical approach to locking is a four-step process:
<ol>
<li>
Turn off error handling.</li>
<li>
Attempt the operation.</li>
<li>
Check to see if an error occurred. If so, handle the error based on the error number.</li>
<li>
Turn on error handling.</li>
</ol>
<p>
This approach works well because you don’t have to anticipate every possible error before trying to set a lock; you handle the error only if it occurs. When writing multiuser code, you should handle the error by displaying a message and giving the user an opportunity to retry the operation. The OpenDatabaseExclusive procedure in the previous section uses this technique. </p>
<p>
The most common error you’ll encounter when you use exclusive mode is error number 3006, “Database &lt;<i>name</i>&gt; is exclusively locked.” This error occurs when you try to open a database that is currently open in exclusive mode by another user. To respond to the error, wait until the other user has finished working with the database and then try the operation again.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on error handling, see Chapter 8, <a href="handlingrun-timeerrors.htm">“Handling Run-Time Errors.”</a></p>
<h4>Using Recordset Locking</h4>
<p>
You use exclusive mode to lock an entire database. You use recordset locking, on the other hand, to control how one or more individual tables in a database are locked. Recordset locking applies only to table- and dynaset-type <b>Recordset</b> objects; it doesn’t apply to snapshot- and forward-only-type <b>Recordset </b>objects because these are inherently read-only objects.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The default recordset lock is a write lock, which means that other users can’t edit data in the locked records. You can also prevent users from reading the data by setting a read lock. You may want to do this if you are making bulk changes to a <b>Recordset</b> object and you want to prevent users from reading the data until you have completed your update. To set a read lock, specify the <b>dbDenyRead</b> constant in the <i>options</i> argument of the <b>OpenRecordset</b> method. For more information, search the Help index for “OpenRecordset method.”</p>
<h5>Opening the Database in Shared Mode</h5>
<p>
If you want to implement recordset locking, you must open your database in shared mode. When a database is opened in shared mode, multiple users can simultaneously access the database and Microsoft Jet handles conflicts between users.</p>
<p>
You can use code to open a database in shared mode. To do so, use the <b>OpenDatabase</b> method on the current <b>Workspace</b> object, and specify <b>False</b> for the <i>options</i> argument. The following procedure opens the Northwind sample database in shared mode and checks for errors to determine if the operation was successful:</p>
<pre><code>Sub OpenDatabaseShared()

&#09;Dim dbs As Database
&#09;Dim errCurrent As Error

&#09;' Try to open the Northwind database in shared mode.
&#09;On Error Resume Next
&#09;Set dbs = OpenDatabase(&quot;Northwind.mdb&quot;, False)

&#09;If Err &lt;&gt; 0 Then
&#09;&#09;' Errors occurred: Display them.
&#09;&#09;For Each errCurrent In DBEngine.Errors
&#09;&#09;&#09;Debug.Print errCurrent.Description
&#09;&#09;Next
&#09;Else
&#09;&#09;' No errors: Database is in shared mode.
&#09;&#09;Debug.Print &quot;The database is open in shared mode.&quot;
&#09;End If

&#09;dbs.Close
End Sub
</code></pre>
<p>
Using Visual Basic to open the Northwind sample database in shared mode has the same effect as clearing the <b>Exclusive</b> check box in the <b>Open</b> dialog box (<b>File</b> menu).</p>
<h5>Opening the Recordset Object</h5>
<p>
After you open the database in shared mode, you can implement recordset locking by specifying various constants in the <i>options</i> argument of the <b>OpenRecordset</b> method. You can use a combination of the available constants to more precisely specify the type of locking you want to implement.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For a complete list of the constants you can specify for the <i>options</i> argument of the <b>OpenRecordset</b> method, see “OpenRecordset Options” in Chapter 9, “Working with Records and Fields.”</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To open a Recordset object with locking enabled</b>
<ol>
<li>
Open the <b>Recordset</b> object’s database in shared mode.</li>
<li>
Determine the type of recordset locking you want to implement.</li>
<li>
Open the <b>Recordset</b> object by using the <b>OpenRecordset</b> method and set the <i>options</i> argument to the constant or combination of constants that specify the type of locking that you want.</li>
<li>
Close the <b>Recordset</b> object when you’re finished performing operations on the data to release any locks on the <b>Recordset</b> object.</li>
</ol>
<p>
For example, the following code locks a table by opening it with the <b>dbDenyWrite</b> and <b>dbDenyRead</b> constants specified in the<i> options</i> argument of the <b>OpenRecordset</b> method. For the duration of the procedure, no other users can access this table. If an error occurs when trying to open the table, the function returns the public constant conFailed.</p>
<pre><code>Function OpenTableEx(dbs As Database, strTable As String) As Integer

&#09;Dim rst As Recordset
&#09;On Error Resume Next

&#09;Set rst = dbs.OpenRecordset(strTable, dbOpenTable, dbDenyRead + dbDenyWrite)
&#09;Select Case Err
&#09;&#09;' conSuccess and conFailed are defined at the module level as public
&#09;&#09;' constants with values of 0 and -32,761 respectively.
&#09;&#09;Case 0: OpenTableEx = conSuccess
&#09;&#09;Case Else: OpenTableEx = conFailed
&#09;End Select

&#09;Err = 0

End Function
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;If you open a <b>Recordset</b> object without specifying any value for the <i>options</i> argument, Microsoft Jet uses page locking by default. It opens the <b>Recordset</b> object<b> </b>in shared mode and locks only the data that’s being edited in the current page.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on opening a <b>Recordset</b> object, see “Creating a Recordset Object Variable” in Chapter 9, “Working with Records and Fields.”</p>
<h5>Checking for Errors with Recordset Locking</h5>
<p>
As with opening databases in exclusive mode, setting locks on <b>Recordset</b> objects can cause errors if the lock fails. You should use the four-step process described in the previous section: turn off error handling, attempt the operation, check for errors and handle any that occur, and finally, turn on error handling.</p>
<p>
The most common error in recordset locking is error number 3262, “Couldn’t lock table &lt;<i>name</i>&gt;; currently in use by user &lt;<i>name</i>&gt; on machine &lt;<i>name</i>&gt;.” This error occurs when you try to use the <b>OpenRecordset</b> method on an object that can’t be locked. There is usually another user who has the same table or tables locked in a way that prevents your action. To respond to the error, wait a short period of time and try the operation again.</p>
<h4>Using Page Locking</h4>
<p>
While exclusive mode locks the entire database, and recordset locking locks one or more individual tables, page locking locks only the page containing the record that is currently being edited. This is the least restrictive level of locking. When you use page locking, other users can read data from the locked page, but they cannot change it. Page locking is the default locking level for <b>Recordset</b> objects.</p>
<p>
In the parts of your application that lock data at the page level, you must specify which type of page locking you want to use. There are two types of page locking available: pessimistic locking and optimistic locking.</p>
<p>
You can set the type of page locking for a <b>Recordset</b> object by specifying either the <b>dbPessimistic</b> or the <b>dbOptimistic</b> constant in the <i>lockedits</i> argument of the <b>OpenRecordset</b> method. You can also set the type of page locking after you open a <b>Recordset</b> object by using its <b>LockEdits</b> property. For pessimistic locking, set the <b>LockEdits</b> property to <b>True</b>; for optimistic locking, set the <b>LockEdits</b> propertyto <b>False</b>.</p>
<h5>Pessimistic Locking</h5>
<p>
With pessimistic locking, a page is locked once you begin editing a record on that page with the <b>Edit</b> method. The page remains locked until you save your changes to the record with the <b>Update</b> method or cancel the edit, either with the <b>CancelUpdate</b> method or by moving off the current record. Pessimistic locking is the default type of page locking for <b>Recordset</b> objects.</p>
<p>
The main advantage of pessimistic locking is that after you have obtained a lock, you know that you won’t encounter any locking conflicts as long as the record is locked. Additionally, pessimistic locking is the only way to guarantee that your application reads the most current data, because one user can’t change a record after another user has started to edit it.</p>
<p>
The disadvantage of pessimistic locking is that it locks the entire page for the duration of the procedure. Therefore, other users can’t change any records on that page until the lock is released.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To use pessimistic locking in your code</b>
<ol>
<li>
Open a table- or dynaset-type <b>Recordset</b> object on the data that you want to edit.</li>
<li>
Implement pessimistic locking by setting the <b>LockEdits</b> property of the <b>Recordset</b> object to <b>True</b>.</li>
<li>
Move to the record that you’re interested in.</li>
<li>
Use the <b>Edit</b> method to allow edits to the record. This locks the record. If the lock fails, try again.</li>
<li>
When the record is locked, make your changes to the record.</li>
<li>
Save your changes to the record by using the <b>Update</b> method. After your changes are saved, the lock is released.</li>
</ol>
<h5>Optimistic Locking</h5>
<p>
With optimistic locking, a page is locked only when you try to save the changes to the record with the <b>Update</b> method. Because the lock is applied only when your application tries to update the record, you minimize the time the lock is in place; this is the main advantage of optimistic locking.</p>
<p>
The disadvantage of optimistic locking is that when you are editing a record, you can’t be sure that the update will succeed. Your attempt to update the record with your edits fails if another user updates the record first.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To use optimistic locking in your code</b>
<ol>
<li>
Open a table- or dynaset-type <b>Recordset</b> object on the data that you want to edit.</li>
<li>
Move to the record that you’re interested in.</li>
<li>
Implement optimistic locking by setting the <b>LockEdits</b> property of the <b>Recordset</b> object to <b>False</b>.</li>
<li>
Use the <b>Edit</b> method to allow edits to the record. This does not lock the record.</li>
<li>
Make changes to the record.</li>
<li>
Save your changes to the record by using the <b>Update</b> method. This attempts to lock the record.</li>
<li>
Check to see if the <b>Update</b> method succeeded. If it didn’t, try again.</li>
</ol>
<p>
It’s possible for the <b>Update</b> method to fail in optimistic locking. For example, if one user has a <b>Recordset</b> object open with pessimistic locking, and another user tries to update data on the same page by using optimistic locking, the second user’s attempt to update will fail.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Optimistic locking turns into pessimistic locking when transactions are used. Because a transaction locks data so that users can’t change it until the transaction is committed, pessimistic locking is used even though the <b>LockEdits</b> property may have been set to <b>False</b>. For more information on transactions, see “Microsoft Jet Transactions” in Chapter 9, “Working with Records and Fields.”</p>
<h5>Checking for Errors with Page Locking</h5>
<p>
When using page locking, before proceeding, your code must check to see if the attempted lock succeeded. As with exclusive mode and recordset locking, you should turn off error handling, attempt the operation, check for errors and handle any that occur, and finally, turn on error handling.</p>
<p>
The following table describes the three most common errors that your application may encounter when you use page locking.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Error number and text</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Cause and suggested response</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">3186</b>  “Couldn’t save; currently locked by user &lt;<i>name</i>&gt; on machine &lt;<i>name</i>&gt;.”</td>
<TD>
This error occurs when a user tries to save a record on a page that is locked by another user.<p><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
To handle this error, program your application to wait for a short period of time, and then try to save the record again. Optionally, you can display a message that explains the problem and give users the opportunity to try the operation again.</p>
</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">3197</b>  “The database engine stopped the process because you and another user are attempting to change the same data at the same time.”</td>
<TD>
This error occurs when another user has changed the data a user is trying to update. The other user changed the data between the time the first user used the <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Edit</b> method and the <b>Update</b> method.<p>
If this error occurs when the user uses the <b>Edit</b> method, you may want to handle this error by programming your application to refresh the user’s view of the data with the current data and then attempt the <b>Edit</b> method a second time.</p>
<p>
If this error occurs when the user uses the <b>Update</b> method, then optimistic locking is in place and the record has changed since the user used the <b>Edit</b> method. To handle this error, program your application to display a message that informs the user that someone else has changed the data. You may want to display the current data and give the user the choice of whether to overwrite the other user’s changes or cancel their own edits.</p>
</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">3260</b>  “Couldn’t update; currently locked by user &lt;<i>name</i>&gt; on machine &lt;<i>name</i>&gt;.”</td>
<TD>
This error occurs when a user uses the <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Edit</b> method and the page containing the current record is locked.<p>
This error also occurs when a user uses the <b>AddNew</b> method or the <b>Update</b> method to save a record on a locked page. This situation can occur when the user is trying to save a new record or when optimistic locking is in place and another user locks the page.</p>
<p>
To handle this error, program your application to wait for a short period of time, and then try to save the record again. Optionally, you can inform users of the problem and allow them to indicate whether or not they want to retry the operation.</p>
</td>
</tr>
</table>
<h5>Page Locking Code Example</h5>
<p>
You can write a procedure that tries to lock a record, check to see if an error occurred, and respond to it regardless of the type of error. Alternatively, you can write a procedure that identifies the specific error that occurs and responds to it. The following procedure tries to edit a record. If a locking error occurs, the procedure tries to identify the error and responds accordingly. If an unidentified error occurs, the procedure displays a message and exits the function.</p>
<pre><code>Function UpdateUnitsInStock(strProduct As String, intUnitsInStock _
&#09;As Integer, intMaxTries As Integer) 

&#09;Dim dbs As Database, rstProducts As Recordset
&#09;Dim blnError As Boolean, intCount As Integer
&#09;Dim intLockCount, intChoice As Integer, intRndCount As Integer, intI As Integer

&#09;Const conFilePath As String = &quot;C:\Program Files\Microsoft Office\Office\Samples\&quot;

&#09;On Error GoTo ErrorHandler

&#09;' Open the database in shared mode. 
&#09;Set dbs = OpenDatabase(conFilePath &amp; &quot;Northwind.mdb&quot;)

&#09;' Open the table for editing. 
&#09;Set rstProducts = dbs.OpenRecordset(&quot;Products&quot;, dbOpenDynaset)

&#09;With rstProducts
&#09;&#09;' Set the locking type to pessimistic. Setting LockEdits to
&#09;&#09;' False would use optimistic locking.
&#09;&#09;.LockEdits = True

&#09;&#09;.FindFirst &quot;ProductName = &quot; &amp; Chr(34) &amp; strProduct &amp; Chr(34)

&#09;&#09;If .NoMatch Then
&#09;&#09;&#09;' conErrNoMatch is defined at the module level as a public
&#09;&#09;&#09;' constant of type Integer with a value of -32737.
&#09;&#09;&#09;UpdateUnitsInStock = conErrNoMatch
&#09;&#09;&#09;GoTo CleanExit
&#09;&#09;End If

&#09;&#09;' Attempt to edit the record. If a lock error occurs, the
&#09;&#09;' error handler will attempt to resolve it. Because this procedure
&#09;&#09;' uses pessimistic locking, errors are generated when you begin to edit a
&#09;&#09;' record. If it used optimistic locking, lock errors would occur when you
&#09;&#09;' update a record. 

&#09;&#09;.Edit
&#09;&#09;![UnitsInStock] = intUnitsInStock
&#09;&#09;.Update
&#09;
&#09;End With
&#09;
CleanExit: 
&#09;rstProducts.Close
&#09;dbs.Close
&#09;Exit Function

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 3197
&#09;&#09;&#09;' Data in the recordset has changed since it was opened.
&#09;&#09;&#09;' Try to edit the record again. This automatically refreshes
&#09;&#09;&#09;' the recordset to display the most recent data.
&#09;&#09;&#09;Resume

&#09;&#09;Case 3260&#09;&#09;&#09;&#09;&#09;&#09;&#09;' The record is locked.
&#09;&#09;&#09;intLockCount = intLockCount + 1
&#09;&#09;&#09;' Tried to get the lock twice already.
&#09;&#09;&#09;If intLockCount &gt; 2 Then&#09;&#09;' Let the user cancel or retry.
&#09;&#09;&#09;&#09;intChoice = MsgBox(Err.Description &amp; &quot; Retry?&quot;, _
&#09;&#09;&#09;&#09;&#09;vbYesNo + vbQuestion)
&#09;&#09;&#09;&#09;If intChoice = vbYes Then
&#09;&#09;&#09;&#09;&#09;intLockCount = 1
&#09;&#09;&#09;&#09;Else
&#09;&#09;&#09;&#09;&#09;' conErrRecordLocked is defined at the module level as a public
&#09;&#09;&#09;&#09;&#09;' constant of type Integer with a value of -32,736.
&#09;&#09;&#09;&#09;&#09;UpdateUnitsInStock = conErrRecordLocked
&#09;&#09;&#09;&#09;&#09;Resume CleanExit
&#09;&#09;&#09;&#09;End If
&#09;&#09;&#09;End If

&#09;&#09;&#09;' Yield to Windows.
&#09;&#09;&#09;DoEvents
&#09;&#09;&#09;' Delay a short random interval, making it longer each time the
&#09;&#09;&#09;' lock fails.
&#09;&#09;&#09;intRndCount = intLockCount ^ 2 * Int(Rnd * 3000 + 1000)
&#09;&#09;&#09;For intI = 1 To intRndCount: Next intI
&#09;&#09;&#09;&#09;Resume&#09;&#09;&#09;' Try the edit again.

&#09;&#09;Case Else&#09;&#09;&#09;&#09;&#09;' Unanticipated error.
&#09;&#09;&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error, vbOKOnly, &quot;ERROR&quot;
&#09;&#09;&#09;' conFailed is defined at the module level as a public
&#09;&#09;&#09;' constant of type Integer with a value of -32,761.
&#09;&#09;&#09;UpdateUnitsInStock = conFailed
&#09;&#09;&#09;Resume CleanExit

&#09;End Select

End Function
</code></pre>
<p>
Note that the code specifies a random interval to retry the operation. This is an important technique for making sure that two users who are trying to update the same record don’t end up in a deadlock situation where the code keeps trying to lock the record at the same time. By introducing a random element into the timing loop, you can minimize the chances of a deadlock.</p>
<h4>Testing a Record for Locking Status</h4>
<p>
You may want to check to see if a record is locked without actually locking its page or pages. The following procedure uses the <b>LockEdits</b> property to determine if the current record is locked:</p>
<pre><code>Function RecordLocked(rst As Recordset) As Boolean
&#09;Dim blnLock As Boolean

&#09;On Error GoTo ErrorHandler

&#09;' Save current value of LockEdits property.
&#09;blnLock = rst.LockEdits

&#09;' Set pessimistic locking.
&#09;rst.LockEdits = True

&#09;' Try to edit the record. This generates error 3197 if the
&#09;' record is locked.

&#09;rst.Edit
&#09;RecordLocked = False
&#09;rst.CancelUpdate

&#09;' Restore original value of LockEdits property.
&#09;rst.LockEdits = blnLock

&#09;Exit Function

ErrorHandler:
&#09;Select Case Err
&#09;&#09;Case 3197
&#09;&#09;&#09;Resume Next
&#09;&#09;Case Else
&#09;&#09;&#09;RecordLocked = True
&#09;&#09;&#09;Resume Next
&#09;&#09;&#09;Exit Function
&#09;End Select

End Function
</code></pre>
<h4>Implementing a Custom Locking Scheme</h4>
<p>
You may encounter situations in your multiuser application where the behavior of the built-in Microsoft Jet locking strategies isn’t appropriate. In this case, you may want to consider your own custom locking scheme. Implemented through a set of routines that you write, custom locking completely bypasses Microsoft Jet locking. Your code controls locking by identifying when a record should be locked and unlocked.</p>
<p>
The most common approach to this technique is to have a lock table that identifies when a record is locked. The lock table identifies records by storing the primary key value of the record, the lock status (locked or unlocked), and the name of the user who has the record locked.</p>
<p>
The implementation of a custom locking scheme requires a great deal of design, implementation, and testing time. In many cases, it can’t duplicate functionality that is built into Microsoft Jet. For example, even if you implement single-record locking, it would be very difficult to handle data in a <b>Recordset</b> object that’s based on more than one table, because you would have to determine all the tables that contain records that have to be locked. Custom locking schemes are most attractive when they affect only a few tables and aren’t based on a data model with complex joins and relationships.</p>
</FONT></FONT></BODY>
</HTML>
