<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Additional Tips for Fast Code</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="additionaltipsforfastcode"></a>Additional Tips for Fast Code</h2>
<p>
In general, you can do more to improve the speed of your code by choosing more efficient algorithms than by implementing particular coding “tricks.” However, certain techniques can help you write more efficient code. This section gives tips you can use to speed up your code.</p>
<h5>Use Object Variables to Refer to Properties, Controls, and DAO Objects</h5>
<p>
If you refer more than once to the value of a property or control on a form, or to a DAO object or its property, create object variables and refer to the variables rather than using full identifiers. This approach is especially effective for speeding up a looping operation on a series of properties, controls, or objects.</p>
<h5>Use the Me Keyword for Form References Within an Event Procedure</h5>
<p>
When you make form references within an event procedure, use the <b>Me</b> keyword to refer to the form. This restricts the search for the form to the instance of the form in which code is currently running.</p>
<h5>Use Constants Whenever Possible</h5>
<p>
If your code has strings or numbers that don’t change, declare them as constants instead of variables. Using constants makes your application run faster. Constants also make your code more readable and easier to maintain. Constants are resolved once when your program is compiled, with the appropriate value written into the code. With variables, on the other hand, each time the application runs and finds a variable, it needs to get the current value of the variable. Whenever possible, use the intrinsic constants listed in the Object Browser rather than creating your own.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on constants, see Chapter 4, <a href="workingwithvariablesdatatypesconstants.htm">“Working with Variables, Data Types, and Constants.”</a></p>
<h5>Use the Ilf Function Judiciously</h5>
<p>
Avoid using the <b>Ilf</b> function if either of the return expressions takes a long time to evaluate. When you use the<b> Ilf</b> function, Microsoft Access always evaluates both expressions, even though it returns only one of them. It’s often more efficient to replace the <b>Ilf</b> function with an <b>If...Then...Else</b> statement block.</p>
<h5>Use Specific Object Types</h5>
<p>
References to objects and their methods and properties are resolved either when an application is compiled or when it runs. To improve execution speed when working with Automation objects, instead of using a <b>Variant</b> data type or the generic <b>Object</b> data type, declare objects as they are listed in the <b>Classes </b>box in the Object Browser. This ensures that Visual Basic recognizes the specific type of object you’re referencing, allowing the reference to be resolved at compile time.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on object types and on using the Object Browser, see Chapter 5, <a href="workingwithobjectscollections.htm">“Working with Objects and Collections.”</a></p>
<h5>Use the Integer or Long Data Type for Math When Possible</h5>
<p>
Use the <b>Integer</b> or <b>Long</b> data type for math when the size and type of numbers permit. The <b>Variant</b> data type, though more flexible, uses more memory and processor time as it translates between data types. The following table ranks the numeric data types by calculation speed.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Numeric data types</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Speed</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Integer</b>, <b>Long</b></td>
<TD>
Fastest</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Single</b>, <b>Double</b></td>
<TD>
Next-to-fastest</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Currency</b></td>
<TD>
Next-to-slowest</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Variant</b></td>
<TD>
Slowest</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
</table>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on data types, see Chapter 4, <a href="workingwithvariablesdatatypesconstants.htm">“Working with Variables, Data Types, and Constants.”</a></p>
<h5>Use String Functions When Appropriate</h5>
<p>
Some functions have two versions, one that returns a <b>Variant</b> data type (for example, the <b>Str</b> function) and one that returns a <b>String</b> data type (for example, the <b>Str$</b> function). Use string functions when working with strings. Your operations run faster when you use string functions because Microsoft Access doesn’t need to perform type conversions.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on string functions, search the Help index for “returning strings.”</p>
<h5>Use Dynamic Arrays Instead of Fixed-Size Arrays</h5>
<p>
Consider using dynamic arrays instead of fixed-size arrays because you can reclaim memory when you no longer need the data in a dynamic array. Use either the <b>Erase</b> statement or the <b>ReDim</b> statement with the <b>Preserve</b> keyword to discard unneeded data and reclaim the memory used by the array. For example, you can reclaim the memory used by a dynamic array by using the <b>Erase</b> statement, as follows:</p>
<pre><code>Erase intArray
</code></pre>
<p>
While the <b>Erase</b> statement completely eliminates the array, the <b>ReDim</b> statement used with the <b>Preserve</b> keyword makes the array smaller without losing its contents.</p>
<pre><code>ReDim Preserve intArray(10, conNewUpperBound)
</code></pre>
<p>
Erasing a fixed-size array doesn’t reclaim the memory for the array; it simply clears out the values of each element of the array. If each element was a string, or a <b>Variant</b> data type containing a string or an array, then erasing the array would reclaim the memory from those strings or <b>Variant</b> data types, not the memory for the array itself.</p>
<h5>Replace Procedure Calls with Inline Code</h5>
<p>
Although using procedures makes your code more modular, performing each procedure call always involves some additional work and time. If you have a loop that calls a procedure many times, you can eliminate this overhead by removing the procedure call and placing the body of the procedure directly inline within the loop. If you place the same code inline in several loops, however, the duplicate code increases the size of your application. It also increases the chance that you won’t remember to update each section of duplicate code when you make changes.</p>
<h5>Use the Find Methods on Indexed Fields</h5>
<p>
When locating records that satisfy a specified criteria, the Find methods are much more efficient than the <b>Seek</b> method when used on a field that is indexed.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on the Find methods, see “Finding a Record in a Dynaset-&nbsp;or Snapshot-Type Recordset Object” in Chapter 9, “Working with Records and Fields.”</p>
<h5>Use Bookmarks for Fast Relocation</h5>
<p>
Use bookmarks instead of the <b>FindNext</b> method or some other means to return to a particular record. By using the <b>Bookmark</b> property, you can write a procedure to find a target record, store its bookmark value in a variable, move to other records, and return to the original record by referring to the bookmark.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>Bookmark</b> property, search the Help index for “Bookmark property.”</p>
<h5>Open Add-in Databases for Read-only Access</h5>
<p>
If your application includes add-ins and doesn’t need to write to them, load the add-in databases for read-only access rather than for read/write permission. The read-only database loads and runs faster because a locking information (.ldb) file doesn’t need to be maintained.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on working with add-ins, see Chapter 17, <a href="creatingwizardsbuildersmenuadd-ins.htm">“Creating Wizards, Builders, and Menu Add-ins.”</a></p>
<h5>Consider Reducing the Number of Procedures and Modules</h5>
<p>
While your application runs, each called procedure is placed in its own public block of memory. Microsoft Access incurs some overhead when creating and managing these blocks. You can reduce some of this overhead by combining short procedures into larger procedures and by consolidating your procedures into fewer modules. Keep in mind that using larger procedures in fewer modules makes your code more difficult to debug and maintain.</p>
<h5>Organize Your Modules</h5>
<p>
Visual Basic loads modules on demand—that is, it loads a module into memory only when your code calls one of the procedures in that module. If you never call a procedure in a particular module, Visual Basic never loads that module. Place related procedures in the same module so that Visual Basic only needs to load that module.</p>
<h5>Eliminate Dead Code and Unused Variables</h5>
<p>
As you develop and modify your applications, you may leave behind <i>dead code</i>—entire procedures that are not called from anywhere in your code. You may also have declared variables that are no longer used. Consider reviewing your code to find and remove unused procedures and variables; for example, <b>Debug.Print</b> statements.</p>
<p>
To search for references to a particular variable, use the <b>Find</b> command (<b>Edit</b> menu). Or, if you have <b>Option Explicit</b> statements in each of your modules, you can quickly discover if a variable is used in your application by removing its declaration and running the application. If the variable is used, Visual Basic generates an error. If you don’t see an error, the variable was not used.</p>
<p>
If your application has places in which the contents of a string variable or a <b>Variant</b> data type containing a string isn’t needed, assign a zero-length string (&quot;&quot;) to that variable. If you no longer need an object variable, set that variable to the <b>Nothing</b> keyword to reclaim the memory used by the object reference.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You can also use compiler directives and conditional compilation to ignore portions of code based on constant values that you specify. For more information, see Chapter 7, <a href="debuggingvisualbasiccode.htm">“Debugging Visual Basic Code.”</a></p>
<h5>Consider Stripping Comments from Your Delivered Application</h5>
<p>
Comments in code use memory. If your application contains many lines of commented code, consider stripping the comments from your code in the delivered application. Before delivering the application, save the code to a text file. Make a copy of the text file and strip out the comments. Then load the stripped code back into your application. Retain the text file that contains the commented code for your reference and future development work.</p>
<h5>Consider Saving Your Application as an MDE File</h5>
<p>
If it is appropriate for the situation your application will be used in, consider saving your application as an MDE file. Saving a database containing code as an MDE file removes the source code from the file and provides some additional optimization of memory use.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on MDE files, see “Saving Your Application as an MDE File” in Chapter 14, “Securing Your Application.”</p>
<h5>Deliver Your Application with Modules Compiled</h5>
<p>
Compile your modules before saving them and before delivering your application. This decreases the time it takes to load the module when your application calls a procedure that resides there. To compile all procedures in all modules in the current database, click <b>Compile And Save All Modules</b> on the <b>Debug</b> menu in the Module window.</p>
</FONT></FONT></BODY>
</HTML>
