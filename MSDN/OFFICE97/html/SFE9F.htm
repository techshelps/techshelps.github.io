<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Allocating BSTR Values</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Allocating BSTR Values</H2><P CLASS="t">You should always use OLE functions to operate on BSTR values. If you need to change a BSTR value, first test the BSTR to see if it is already assigned. If it isn't, you may use the SysAllocStringByteLen function to assign a value to the BSTR. If the BSTR is already assigned, you must free the current assignment (with the SysFreeString function) before you can use SysAllocStringByteLen. You cannot use the SysReAllocString or SysReAllocStringLen function to reallocate the string (these functions automatically free the initial assignment) because they do not have a byte version for dealing with the ANSI strings that Microsoft Excel is passing into the code.</P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">For example, the following C-language code copies some number of characters from one BSTR into another. Notice that this example tests the second BSTR to see if it is already assigned. If it is, the example uses the SysReAllocStringLen function to free the existing string before replacing it.</P>

<pre><code><FONT FACE="Courier" SIZE="2">short WINAPI StringArgs(BSTR *pbstrArg1, 
    BSTR *pbstrArg2, short cch)
{
    BSTR *pbstrTemp;

    // Return error code if requested characters 
    // less than zero, or input string is unassigned 
    // or has too few characters.
    // Use ByteLen since string is not unicode
    if (cch &lt; 0 || *pbstrArg1 == NULL || 
        (short)SysStringByteLen(*pbstrArg1) &lt; cch)
        return -1;        

    if (*pbstrArg2 == NULL) 
    {     // String is unassigned; 
        // we can allocate a new one.
        // Use ByteLen since string is not unicode
        *pbstrArg2 = SysAllocStringByteLen((LPSTR)*pbstrArg1, cch);
        if (*pbstrArg2 == NULL)
            return -2;
    }
    else 
    {     // Argument string is already assigned; 
        // we must reallocate.
        *pbstrTemp = SysAllocStringByteLen((LPSTR)*pbstrArg1, cch);
        // Did it fail?
        if (pbstrTemp == NULL)
            return -3;

        SysFreeString(*pbstrArg2);
        *pbstrArg2 = *pbstrTemp;
    }
        
    return 0;
}
</FONT></code></pre>
<P CLASS="t">The calls to the SysAllocStringByteLen function use the dereferenced BSTR pointer *pbstrArg1 to access the characters in the first argument. This is permitted&nbsp;when you are reading the characters, but you should not write to the&nbsp;dereferenced pointer.</P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">This Visual Basic code declares and calls the StringArgs function:</P>

<pre><code><FONT FACE="Courier" SIZE="2">Declare Function StringArgs Lib "debug\ADVDLL.DLL" _
    (inpStr As String, outStr As String, ByVal n As Integer) As Integer

Sub StringArgsTest()
    Dim newStr As String
    Dim x As Boolean

    ''' First code path
    x = StringArgs("abracadabra", newStr, 5)
    MsgBox x &amp; ":" &amp; newStr

    ''' Second code path
    x = StringArgs("abracadabra", newStr, 4)
    MsgBox x &amp; ":" &amp; newStr
End Sub
</FONT></code></pre></FONT>
</FONT></BODY></HTML>
