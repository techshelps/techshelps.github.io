<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Writing Your Add-in</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="writingyouradd-in"></a>Writing Your Add-in</h2>
<p>
Now that you know the type of add-in you are creating and the functionality it will provide, you can begin to write your add-in. Writing the add-in is much like writing any other Microsoft Access application. You create a new database, create and modify objects, write the Visual Basic code to define the actions your add-in will perform, and implement error handling.</p>
<h3>Creating the New Database</h3>
<p>
You build your add-in as its own database. If you plan on installing your add-in in the Office folder, make sure its name doesn’t duplicate the name of an existing add-in. If your add-in will be installed in another folder, naming is not an issue.</p>
<h3>Creating the Add-in’s Objects</h3>
<p>
As you create the objects for your add-in, keep in mind that they will be used on computers that may be different from yours. To make sure that your add-in will run well in all possible situations, try to anticipate both the low-end and high-end computers that may be used to run your add-in.</p>
<p>
For example, a form that barely fits on a screen with 1024 x 768 resolution will be difficult to work with on a screen with 640 x 480 resolution. Test your form in the lowest resolution you plan to support and make sure it fits easily within the Microsoft Access window. Design your form by using a 16-color palette and avoid using colors on buttons that don’t display well on monochrome monitors.</p>
<p>
If your add-in requires tables, create the tables in the new database. Don’t link tables, because linking requires more files in the distribution disk set and can cause problems if the user moves the database files to different folders.</p>
<p>
As with other Microsoft Access applications, the foundation of an add-in is the form. As you design your forms, remember the guidelines discussed earlier in this chapter. Try to implement as much of your Visual Basic code as possible in the form modules. If your add-in is complex, involving many sequential operations, you may find it useful to break down operations in modular units. Implement each unit in a separate form, designed as a dialog box, with execution started by the OnOpen or OnLoad events of the form. This makes a complex add-in easier to maintain and enhance.</p>
<h3>Using Functions, Statements, and Methods to Create Objects</h3>
<p>
Most wizards create user-interface objects, such as forms, reports, and controls, or Data Access Objects (DAO), such as tables or queries. Visual Basic provides a variety of functions, statements, and methods you can use to create and work with objects and controls. You can use them from any kind of add-in, but in most cases they are only appropriate for wizards because they must be used in an object’s Design view.</p>
<p>
The following table summarizes the functions you can use to create user-interface objects.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Function</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateForm</b></td>
<TD>
Creates a form, and then returns a <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Form</b> object.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateControl</b></td>
<TD>
Creates a control on a specified form that is open in Design view, and then returns a <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Control</b> object.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateReport</b></td>
<TD>
Creates a report, and then returns a <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Report</b> object.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateReportControl</b></td>
<TD>
Creates a control on a specified report that is open in Design view, and then returns a <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Control</b> object. </td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateGroupLevel</b></td>
<TD>
Creates a new group level for a specified report that is open in Design view, and then returns the new group’s index value (0–9). You specify how the group will be sorted or grouped, by specifying a field or expression.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
</table>
<p>
Because these functions return an object, you can set an object variable when you create the new object. For example, the following line of code creates a new text box control on the current form:</p>
<pre><code>Set ctlNewText = CreateControl(frmCurrentForm.Name,acTextBox)
</code></pre>
<p>
You can then set the properties of the control, such as the <b>Left</b>, <b>Top</b>, <b>Width</b>, and <b>Height</b> properties, by using the <code>ctrlNewText</code> object variable in code.</p>
<p>
The following table summarizes the statements you can use to delete controls.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Statement</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">DeleteControl</b></td>
<TD>
Deletes a specified control on a form that is open in Design view. </td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">DeleteReportControl</b></td>
<TD>
Deletes a specified control on a report that is open in Design view.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
</table>
<p>
The following table summarizes the DAO methods you can use to create databases, tables, queries, and user and group security accounts.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Method</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateDatabase</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Database</b> object. </td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateTableDef</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">TableDef</b> object that is used to represent a table or linked table. Use the <b>Append</b> method to add the new <b>TableDef</b> object to the <b>TableDefs</b> collection.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateField</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Field</b> object. Use the <b>Append</b> method to add the <b>Field</b> object to an existing <b>TableDef</b> object.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateIndex</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Index</b> object. Use the <b>Append</b> method to add the index to the <b>Indexes</b> collection of an existing <b>TableDef</b> object. </td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateQueryDef</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">QueryDef</b> object that is used to represent a query. The resulting <b>QueryDef</b> object is automatically appended (added) to the <b>QueryDefs</b> collection.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateRelation</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Relation</b> object that is used to represent relationships between fields in tables or queries. </td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateWorkspace</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Workspace</b> object that defines a session for the Microsoft Jet database engine. This is only used to create a new session in addition to the current (default) session. </td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateUser</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">User</b> object to add a new user account to the <b>Users</b> collection of a secured database. Use the <b>Append</b> method to add a new <b>User</b> object to the <b>Users</b> collection of the database.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">CreateGroup</b></td>
<TD>
Creates a new <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Group</b> object to add a new security group to the <b>Groups</b> collection of a secured database. Use the <b>Append</b> method to add the new <b>Group</b> object to the <b>Groups</b> collection of the database.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">DeleteObject</b></td>
<TD>
A method of the <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">DoCmd</b> object used to delete a specified database object. </td>
</tr>
</table>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on these functions, statements, and methods, search the Help index for the name of the function, statement, or method.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You can create a wizard or builder that edits existing controls as well as creates new controls. The user can invoke your wizard or builder by right-clicking on a control of the appropriate type, and then clicking <b>Build</b> on the shortcut menu. You can work with new or existing controls by using the properties of the <b>Control</b> object. For example, you can determine the type of an existing control by checking the <b>ControlType</b> property. For more information on the <b>Control</b> object, search the Help index for “Control object.”</p>
<h3>Implementing Error Handling</h3>
<p>
Error handling is very important in an add-in. Because add-ins are stored in their own database, run-time errors that occur trigger the Microsoft Access error message “A run-time error has occurred in database: &lt;<i>name</i>&gt;. You don’t have permission to view modules in this database.” This is confusing to the user, and it detracts from the usability of your add-in. Additionally, because your add-in may be distributed to users at sites other than your own, you may not be able to reproduce the user’s configuration on your system. This makes it very difficult to troubleshoot add-ins.</p>
<p>
Microsoft Access has a number of tools you can use in your modules to recover from run-time errors. This section outlines strategies for effective error handling in add-ins.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on error handling, see Chapter 8, <a href="handlingrun-timeerrors.htm">“Handling Run-Time Errors.”</a></p>
<p>
The standard method of error handling involves creating error-handling code in each of your procedures. When a run-time error occurs, the error-handling code takes over. This allows the procedure to retry operations or otherwise recover from the error.</p>
<p>
You can augment this error handling with public error-handling code. Public error-handling code is called whenever your add-in can’t recover from a run-time error. In public error handling, you define an error-handling procedure in a module and make its scope public. At a minimum, this procedure should contain the code to do the following:
<ul>
<li>
Supply the user with information about the error. You can display the Microsoft Access error number and the value of the <b>Description</b> property of the <b>Err</b> object to give the user details about what went wrong.</li>
<li>
Close all objects that your add-in opened. You want to leave the user’s copy of Microsoft Access in the same state it was in before your add-in started.</li>
<li>
Delete any temporary files or objects your add-in created. It’s a good idea to clean up your add-in in the event of an unrecoverable run-time error.</li>
<li>
Restore any user option settings your add-in has changed. For example, if your add-in changes the Show Status Bar setting, have the error-handling procedure restore the user’s Show Status Bar setting.</li>
</ul>
<p>
You may want to implement additional functionality in your public error handler. The following suggestions are optional, but they may make it easier for you to solve problems at a remote site:
<ul>
<li>
Replace Microsoft Access error messages with custom error messages. The standard Microsoft Access error messages may be confusing to the users of your add-in. By anticipating areas in which errors may be encountered, you can display error messages that supply more meaningful information to the user.</li>
<li>
Have your public error-handling code write pertinent information to a log file when it can’t recover. This information can include the current state of Microsoft Access (including the version number), information about the system’s environment, a list of objects that were open when the error occurred, and any other information to help you track down the source of the problem. This error log can be stored in a Microsoft Access table or in a separate text file. In many situations, you’ll find storing the error log in a text file to be the better approach. For example, if your public error-handling code was triggered by a serious error, you may not be able to open and write to tables in your code. Using a text file is usually more successful in these situations.</li>
<li>
Display the name of the procedure that was running when the run-time error occurred. Although Microsoft Access doesn’t provide intrinsic capabilities for retrieving the current procedure name, you can implement this feature as described in the following section.</li>
</ul>
<h4>Implementing a Public Error Procedure Stack</h4>
<p>
If you want your public error-handling code to provide the user with the name of the procedure that was running when an error occurs, you can implement a procedure stack in Visual Basic and include it in your application. You implement the stack as a public array. In every procedure, you call a procedure that stores the name of the current procedure on this stack. When your public error-handling code is called, it can retrieve the procedure name from this stack and report it to the user. If you know the name of the procedure that was running when the error occurred, you can find the source of the error more quickly.</p>
<p>
First, create a public array in your add-in’s Declarations section. For example:</p>
<pre><code>Public Const conStackSize = 10
Public strProcNames (1 to conStackSize) As String
</code></pre>
<p>
Second, create procedures to “push” procedure names on the stack and “pop” procedure names off the stack.</p>
<pre><code>Sub PushDebugStack(strSubOrFunction)
&#09;Dim intX As Integer

&#09;For intX = conStackSize To 2 Step -1
&#09;&#09;strProcNames(intX) = strProcNames(intX - 1)
&#09;Next
&#09;strProcNames(1) = strSubOrFunction
End Sub

Sub PopDebugStack()
&#09;Dim intX As Integer

&#09;For intX = 1 To (conStackSize - 1)
&#09;&#09;strProcNames(intX) = strProcNames(intX + 1)
&#09;Next intX
End Sub
</code></pre>
<p>
In each of your add-in’s procedures, call the procedure that pushes the add-in procedure’s name on the stack. Using the previous example, you would call PushDebugStack with the name of the current procedure as the argument. At each of the procedure’s exit points, call the procedure that pops the name off the stack. Using the previous example, you would call PopDebugStack.</p>
<p>
This method ensures that at any point in your program you have a list of up to 10 current procedures. The following example shows how to use these public error procedure stacks.</p>
<pre><code>Function SearchForm ()
&#09;PushDebugStack (&quot;SearchForm&quot;)
&#09;&#09;.
&#09;&#09;. ' Main body of program.
&#09;&#09;.
&#09;PopDebugStack
End Function
</code></pre>
<p>
In your public error-handling code, you can reference the procedure name stack and display the name of the current procedure, or display a list of up to 10 current procedures.</p>
<pre><code>Dim strMsg As String
Dim intX As Integer

MsgBox &quot;An error occurred in the following procedure: &quot; &amp; _
&#09;strProcNames(1)
strMsg = &quot;The following procedures were called: &quot;

For intX = 2 To conStackSize
&#09;strMsg = strMsg &amp; strProcNames(intX) &amp; &quot; &quot;
Next intX

MsgBox strMsg
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The number (10) used in the preceding example for the array size is an example. You can increase or decrease this number depending on the complexity of your add-in, and the level of detail you want for your public error-handling code.</p>
</FONT></FONT></BODY>
</HTML>
