<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Dynamic-Link Libraries</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="usingdynamic-linklibraries"></a>Using Dynamic-Link Libraries</h2>
<p>
A <i>dynamic-link library</i> (DLL) is a library of procedures that applications can link to and use at run time rather than link to statically at compile time. This means that DLLs can be updated without updating the application, and many applications can share a single DLL. Microsoft Windows is itself composed of several DLLs that contain the procedures all applications use to perform their activities, such as displaying windows and graphics, managing memory, and so on. These procedures are sometimes referred to as the Windows application programming interface (API).</p>
<p>
Your Microsoft Access applications can call the procedures in Windows DLLs to perform special actions that you can’t perform directly in Microsoft Access. You can also call procedures in other DLLs you have in your system.</p>
<p>
Because DLL procedures reside in files that are external to your Microsoft Access application, you have to give Microsoft Access some information so that it can find and run the DLL procedures you want to use. You provide this information with the <b>Declare</b> statement. Once you have declared a DLL procedure, you can use it in your code like any other procedure. However, you have to be especially careful about the arguments that you pass to DLL procedures, or the procedure may not be able to interpret the data and may not function as you expect.</p>
<p>
There are two basic steps in using a DLL procedure:
<ol>
<li>
First, tell Microsoft Access about the procedure by using a <b>Declare</b> statement. You must explicitly declare the procedure before you can call it.</li>
<li>
Next, call the procedure.</li>
</ol>
<p>
You declare a DLL procedure only once. After declaring the procedure, you can call it any number of times from anywhere in your application.</p>
<h5>Converting Applications That Call 16-Bit DLLs</h5>
<p>
If a database created in Microsoft Access version 2.<i>x</i> or earlier called procedures in the Windows API, you need to make some changes in your code when you convert the database to Microsoft Access 97. These earlier versions of Microsoft Access were 16-bit applications and ran on 16-bit versions of Windows. Microsoft Access 97 is a 32-bit application and runs only on 32-bit versions of Windows. </p>
<p>
If your existing Access Basic code made calls to a 16-bit Windows API, you need to modify these calls when you convert your database to Microsoft Access 97. For example, you need to change the names of the DLLs and the data types of some parameters. Also, note that 32-bit API procedure names are case-sensitive, so you need to make sure that the calls you make exactly match the procedure names in the Windows DLLs. </p>
<p>
There is a tool called the Windows API Viewer included with both Visual Basic and Microsoft Office 97, Developer Edition. This tool includes Visual Basic syntax for all 32-bit declarations, data types, and constants. You can copy and paste these declarations, data types, and constants into your Microsoft Access applications.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For tips on converting code that calls a DLL, search the Help index for “converting code.”</p>
<p>
If your Visual Basic code makes calls into a custom 16-bit DLL, either the developer of the DLL must provide a 32-bit compatibility layer for the DLL, or the DLL source code must be recompiled into a 32-bit version of the DLL.</p>
<h3>Declaring DLL Procedures</h3>
<p>
To declare a DLL procedure, place a <b>Declare</b> statement in the Declarations section of a form, report, or standard module. If you declare a DLL procedure in a standard module, it can be called by code anywhere in your application. If you declare a DLL procedure in a form or report module, you must use the <b>Private </b>keyword. The DLL procedure can only be called by other code in the form or report module it resides in.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For the complete syntax of the <b>Declare</b> statement, search the Help index for “Declare statement.”</p>
<p>
If the procedure doesn’t return a value, declare it as a <b>Sub </b>procedure. For example:</p>
<pre><code>Declare Sub InvertRect Lib &quot;user32&quot;(ByVal hDC&#09;As Long, lpRect As RECT)
</code></pre>
<p>
If the procedure does return a value, declare it as a <b>Function</b> procedure. For example:</p>
<pre><code>Declare Function GetSystemMetrics Lib &quot;user32&quot;(ByVal nIndex As Long) As Long
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The procedure name you use in a <b>Declare </b>statement is case-sensitive. The library name is also case-sensitive.</p>
<p>
Notice the <b>Lib</b> and <b>ByVal</b> keywords in the <b>Declare</b> statement. The <b>Declare</b> statement can also contain an optional <b>Alias</b> keyword. The use of these keywords is explained later in this section.</p>
<p>
The declarations for DLL procedures can get fairly complex. If you plan to declare and call DLL procedures in the Windows API, it’s a good idea to have complete documentation of the API for reference. You can find detailed documentation of the Windows API in each of these Microsoft products:
<ul>
<li>
Visual Basic Professional Edition</li>
<li>
Win32<font face="Symbol"><span style="font-family:Symbol">&#226;</span></font> Software Development Kit</li>
<li>
Visual C++<font face="Symbol"><span style="font-family:Symbol">&#226;</span></font> version 4.0</li>
</ul>
<p>
The rest of this section explains the syntax of the <b>Declare</b> statement in detail.</p>
<h4>Specifying the Library</h4>
<p>
The <b>Lib</b> <i>libname</i> clause in the <b>Declare</b> statement tells Microsoft Access where to find the dynamic-link library. For the Windows DLLs, this is either <code>&quot;user32&quot;</code>, <code>&quot;gdi32&quot;</code>, <code>&quot;kernel32&quot;</code>, or one of the other system DLLs such as <code>&quot;WINMM&quot;</code>. For other DLLs, <i>libname</i> is a file name that can include a path. For example:</p>
<pre><code>Declare Function LzCopy Lib &quot;C:\Win\LzExpand.dll&quot; (ByVal S As Long, _
&#09;ByVal D As Long) As Long
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;If no path is included in the library name, Visual Basic searches the default system path, then the \Windows folder, and finally the \Windows\System subfolder.</p>
<h4>Passing Arguments by Value or by Reference</h4>
<p>
By default, Microsoft Access passes all arguments <i>by reference</i>, which means that Visual Basic passes a 32-bit address where the value is stored instead of passing the actual value of the argument. If you want to clarify how data is being passed, you can use the <b>ByRef </b>keyword.</p>
<p>
Many DLL procedures expect an argument to be passed <i>by value</i>, which means that the procedure expects the actual value of the argument instead of its memory location. If you pass an argument by reference to a procedure that expects an argument passed by value, the procedure can’t interpret the data and doesn’t operate properly.</p>
<p>
To pass an argument by value, place the <b>ByVal</b> keyword in front of the argument declaration in the <b>Declare</b> statement. This ensures that each time you call the procedure, the argument is passed by value.</p>
<p>
For example, the following InvertRect procedure accepts its first argument by value and its second argument by reference:</p>
<pre><code>Declare Sub InvertRect Lib &quot;user32&quot;(ByVal hDC&#09;As Long, lpRect As RECT)
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;When you’re looking at DLL procedure documentation that uses C-language syntax, remember that C passes by value all arguments except arrays.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on passing arguments by value or by reference, see “Argument Data Types” in Chapter 4, “Working with Variables, Data Types, and Constants.”</p>
<h4>Passing Flexible Argument Types</h4>
<p>
Some DLL procedures can accept more than one type of data for the same argument. To pass more than one type of data, declare the argument with the <b>As</b> <b>Any</b> keyword to remove type restrictions. For example, you can declare a procedure as follows:</p>
<pre><code>Declare Function FindWindow Lib &quot;user32&quot; Alias &quot;FindWindowA&quot; _
&#09;(ByVal lpClassName As Any, ByVal lpWindowName As Any) As Long
</code></pre>
<p>
Then you can call this procedure and pass either a string or a <b>Null</b> value to each function argument:</p>
<pre><code>Function WindowExist ()

&#09;' Assign values to constants that will be passed to FindWindow.

&#09;Const lpClassName = &quot;SciCalc&quot;
&#09;Const lpWindowName = &quot;Calculator&quot;

&#09;' This demonstrates three different ways to call FindWindow:
&#09;&#09;' 1. The Class name only.
&#09;&#09;' 2. The Caption only.
&#09;&#09;' 3. Both the Class name and the Caption.
&#09;' A Null is represented by the symbol &quot;0&amp;&quot;.

&#09;MsgBox &quot;Window Handle = &quot; &amp; FindWindow(lpClassName, 0&amp;)
&#09;MsgBox &quot;Window Handle = &quot; &amp; FindWindow(0&amp;, lpWindowName)
&#09;MsgBox &quot;Window Handle = &quot; &amp; FindWindow(lpClassName, lpWindowName)

&#09;WindowExist = FindWindow(lpClassName, 0&amp;)

&#09;' Any of the above FindWindow calls could be used to return the
&#09;' window handle.
End Function
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The preceding code uses window handles to identify the window returned by the FindWindow function. For more information on handles, see “Handles” later in this chapter.</p>
<p>
When you remove type restrictions, Microsoft Access assumes the argument is passed by reference. Use the <b>ByVal</b> keyword in the actual call to the procedure to pass arguments by value. When passing strings, you must use the <b>ByVal</b> keyword to convert a Visual Basic string into a null-terminated string.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on passing strings, see “Calling DLL Procedures with Specific Data Types” later in this chapter.</p>
<h4>Using Nonstandard Names</h4>
<p>
Occasionally, a DLL procedure has a name that isn’t a valid identifier in Microsoft Access. It may have an invalid character (such as a hyphen), or be the same as a Visual Basic keyword (such as <b>GetObject</b>). When either is the case, use the <b>Alias</b> keyword.</p>
<p>
For example, some procedures in Windows DLLs begin with an underscore character. While you can use an underscore in a Visual Basic identifier, you can’t begin an identifier with an underscore. To use one of these procedures, you must declare the procedure with the <b>Alias </b>keyword.</p>
<pre><code>Declare Function LOpen Lib &quot;kernel32&quot; Alias &quot;_lopen&quot; (ByVal _
&#09;lpPathName As String, ByVal ReadWrite As Long) As Long
</code></pre>
<p>
In this example, <code>LOpen</code> becomes the name of the procedure as it’s referred to in your Microsoft Access procedures. The name <code>_lopen</code> is the name recognized in the DLL.</p>
<h4>Using Ordinal Numbers</h4>
<p>
In addition to a name, all DLL procedures can be identified by an <i>ordinal number</i> that specifies the position of the procedure in the DLL. Some DLLs don’t include the names of their procedures and require you to use ordinal numbers when declaring the procedures they contain. Using an ordinal number consumes less memory in your finished application and is slightly faster than identifying a procedure in a DLL by name. You may also want to use ordinal numbers when declaring other DLL procedures. To obtain the ordinal number of the DLL procedure you want to declare, consult the documentation for the DLL.</p>
<p>
To declare a DLL procedure by ordinal number, use the <b>Alias</b> keyword with a string containing the number sign character (#) and the ordinal number of the procedure. For example, if you want to call a function called GetAppSettings in a library called Utilities, and that function has the ordinal number 47, you can declare the DLL procedure as follows:</p>
<pre><code>Declare Function GetAppSettings Lib &quot;Utilities&quot; Alias &quot;#47&quot; () As Long
</code></pre>
<p>
You could specify any valid name for the procedure in this case, because Visual Basic is using the ordinal number to find the procedure in the DLL.</p>
<h3>Calling DLL Procedures</h3>
<p>
Once a procedure is declared, you can call it just as you would a Microsoft Access statement or function. For example:</p>
<pre><code>Private Sub Form_Load()
&#09;Const SM_MOUSEPRESENT = 19
&#09;
&#09;If GetSystemMetrics(SM_MOUSEPRESENT) Then
&#09;&#09;MsgBox &quot;Mouse installed&quot;
&#09;End If
End Sub
</code></pre>
<p>
Important   Microsoft Access can’t verify that you are passing correct values to a DLL procedure. If you pass incorrect values, the procedure may fail, which may cause your Microsoft Access application to shut down. This doesn’t cause permanent harm to your application, but you’ll have to reload and restart the application. Take care when using DLL procedures, and save your work often.</p>
<h4>Calling DLL Procedures with Specific Data Types</h4>
<p>
Microsoft Access incorporates a rich assortment of data types, including many—such as variable-length strings, <b>Currency</b>, and properties—that aren’t supported by the procedures in most dynamic-link libraries. Therefore, you must take care when using Visual Basic variables with DLL procedures.</p>
<h5>Strings</h5>
<p>
The procedures in most DLLs (and all the procedures in the Windows API) expect standard C strings (sometimes called ASCIIZ strings) which end in a null character (binary zero). If a DLL procedure expects a null-terminated string as an argument, declare the argument as a string with the <b>ByVal</b> keyword. When used with a string argument, the <b>ByVal</b> keyword tells Microsoft Access to pass the string as a null-terminated string.</p>
<h5>DLL Procedures That Modify Strings</h5>
<p>
Strings are always passed to DLL procedures by reference. (The <b>ByVal</b> keyword for string arguments specifies that Microsoft Access should convert the string to a null-terminated string, not that the string should be passed by value.) A DLL procedure can therefore modify a Microsoft Access string variable it receives as an argument. However, be careful when calling a DLL procedure that modifies a string. A DLL can’t increase the length of a Microsoft Access string; if the string isn’t long enough, the DLL simply writes beyond the end of the string. This corrupts other areas of memory. You can avoid this problem by making the string argument long enough that the DLL procedure never writes past the end of it.</p>
<p>
For example, the GetWindowsDirectory procedure returns the path for the Windows directory in its first argument.</p>
<pre><code>Declare Function GetWindowsDirectory Lib &quot;kernel32&quot; Alias _
&#09;&quot;GetWindowsDirectoryA&quot; (ByVal lpBuffer As String, _
&#09;ByVal nSize As Long) As Long
</code></pre>
<p>
One way to call this procedure is to make the returned argument a specified length by filling it with characters—in this case, null (ANSI zero) characters.</p>
<pre><code>strPath = String(255, 0)
strWorked = GetWindowsDirectory(strPath, Len(strPath))
</code></pre>
<p>
Another way to call this procedure is to define the string as fixed-length.</p>
<pre><code>Dim strPath As String * 255

strWorked = GetWindowsDirectory(strPath, Len(strPath))
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The Windows DLL procedures could possibly return strings longer than 255 characters. Always consult the documentation for information on the procedure at hand.</p>
<p>
You can use Microsoft Access strings when the DLL procedure calls for a memory buffer. Use one of the processes outlined previously in this section to ensure that the string is long enough to accept whatever data the procedure supplies.</p>
<h5>Arrays</h5>
<p>
You pass individual elements of an array in the same way you pass any variable that has the same type as the base type of the array. For example, the sndPlaySound function plays a digitized sound (.wav) file (if you have the sound hardware and drivers that can use these files).</p>
<pre><code>Declare Function sndPlaySound Lib &quot;WINMM&quot; (ByVal lpszSoundName _
&#09;As String, ByVal uFlags As Integer) As Integer
</code></pre>
<p>
You can use the sndPlaySound function to play a series of .wav files stored in an array.</p>
<pre><code>Dim intX As Integer, intWorked As Integer

For intX = 0 To UBound(WaveFiles)
&#09;intWorked = sndPlaySound(WaveFile(intX), 0)
Next intX
</code></pre>
<p>
You pass an entire numeric array by passing the first element of the array by reference. This works because numeric array data is always laid out sequentially in memory. A DLL procedure, if passed the first element of an array, has access to all the array’s elements. For example, if you made a call to a function in a C library that contained the following header:</p>
<pre><code>int CalcMean(int intArray, int intElements)
/*Returns the arithmetic mean of an array of integers.*/
</code></pre>
<p>
Then you would declare the function in your Visual Basic module:</p>
<pre><code>Declare Function CalcMean Lib &quot;Calc.dll&quot; (intArray As Integer, _
&#09;intElements As Integer) As Integer
</code></pre>
<p>
And you would pass the array to the library function by specifying the first element of the array as one of the function arguments, as shown in the last line of the following procedure:</p>
<pre><code>Function AvgOfRecords ()
&#09;Dim intN() As Integer
&#09;Dim dbs As Database, rst As Recordset
&#09;Dim intTotal As Integer, intX As Integer

&#09;Set dbs = CurrentDb
&#09;Set rst = dbs.OpenRecordset(&quot;Order Details&quot;)
&#09;rst.MoveLast
&#09;intTotal = rst.RecordCount
&#09;' ReDim the array to the # of recs in the table.
&#09;ReDim intN(intTotal)

&#09;rst.MoveFirst
&#09;' Fill the array with values from table.
&#09;For intX = 0 To (intTotal - 1)
&#09;&#09;intN(intX) = rst!Quantity
&#09;&#09;rst.MoveNext
&#09;Next intX

&#09;' Pass the first element of the array intN to CalcMean().
&#09;MsgBox &quot;The arithmetic mean is &quot; &amp; CalcMean(intN(0),intTotal)

&#09;rst.Close

End Function
</code></pre>
<p>
Caution   You can’t pass an entire string array. Each element of a string array must be passed individually, as a null-terminated string using the <b>ByVal</b> keyword. If a DLL procedure tries to access memory beyond the end of the first element in a string array, it may corrupt memory or cause an error. For more information on passing strings, see “Strings” earlier in this chapter.</p>
<h5>User-Defined Types</h5>
<p>
Some DLL procedures take user-defined types as arguments. <i>User-defined types</i> can contain one or more elements of any data type, array, or a previously defined user-defined type.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;User-defined types are referred to as <i>structures</i> in C and as <i>records</i> in Pascal. DLL documentation often uses the C terminology.</p>
<p>
As with an array, you can pass the individual elements of a user-defined type the same way you pass ordinary numeric or string variables.</p>
<p>
You can pass an entire user-defined type as a single argument if you pass it by reference. You can’t pass user-defined types by value. Microsoft Access passes the address of the first element, and the rest of the elements of a user-defined type are stored in memory following the first element. For example, the Windows GetSystemTime procedure uses the following user-defined type, which you can place in the Declarations section of any module:</p>
<pre><code>Type SYSTEMTIME
   Year As Integer
   Month As Integer
   DayOfWeek As Integer
   Day As Integer
   Hour As Integer
   Minute As Integer
   Second As Integer
   Milliseconds As Integer
End Type
</code></pre>
<p>
The GetSystemTime procedure accepts the user-defined type SYSTEMTIME and retrieves detailed time information from the system clock. To use the procedure, place the following declaration in the Declarations section of any module:</p>
<pre><code>Declare Sub GetSystemTime Lib &quot;kernel32&quot; (lpSystemTime As SYSTEMTIME)
</code></pre>
<p>
Now you can use the following <b>Sub</b> procedure to call the DLL procedure that retrieves the current time.</p>
<pre><code>Sub GetTheTime()
&#09;Dim usrTime As SYSTEMTIME
   
&#09;' Call the procedure to load the SYSTEMTIME structure.
&#09;GetSystemTime usrTime 
   
&#09;' Print the individual time elements to the Immediate pane of the Debug window.
  &#09;Debug.Print &quot;Year = &quot;; usrTime.Year
&#09;Debug.Print &quot;Month = &quot;; usrTime.Month
&#09;Debug.Print &quot;DayOfWeek = &quot;; usrTime.DayOfWeek
&#09;Debug.Print &quot;DayOfMonth = &quot;; usrTime.Day
&#09;' Note that hour is given in Greenwich Mean Time (GMT).
&#09;Debug.Print &quot;Hour = &quot;; usrTime.Hour
&#09;Debug.Print &quot;Minute = &quot;; usrTime.Minute
&#09;Debug.Print &quot;Second = &quot;; usrTime.Second
&#09;Debug.Print &quot;Milliseconds = &quot;; usrTime.Milliseconds
End Sub
</code></pre>
<p>
Most procedures that accept user-defined types don’t expect the user-defined types to contain string data. However, you can pass a user-defined type that includes fixed-length string elements to a DLL procedure. You can’t pass a user-defined type that includes variable-length string elements.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;When passing a user-defined type that contains binary data to a DLL procedure, be sure to store the binary data in a variable of an array of the <b>Byte</b> data type, instead of in a string variable. Because strings are assumed to contain characters, binary data may not be read properly in external procedures if it’s passed as a string variable.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on user-defined data types, see “Creating Your Own Data Types” in Chapter 4, “Working with Variables, Data Types, and Constants.”</p>
<h5>Null Pointers</h5>
<p>
Some DLL procedures occasionally expect to receive a null pointer as an argument. A <i>null pointer </i>is a pointer to nothing; null pointers have a value of zero. If you need to pass a null pointer to a DLL procedure, declare the argument with the <b>As</b> <b>Any</b> keyword and pass the expression <code>ByVal 0&amp;</code>.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the<b> As</b> <b>Any</b> keyword, see “Passing Flexible Argument Types” earlier in this chapter.</p>
<p>
For example, the FindWindow procedure accepts two string arguments, so you may expect to declare it as follows:</p>
<pre><code>Declare Function FindWindow Lib &quot;user32&quot; (ByVal lpClassName As String, _
&#09;ByVal lpWindowName As String) As Long
</code></pre>
<p>
However, the FindWindow procedure also accepts a null pointer for either or both of its arguments. If you declare it as in the previous example, you can’t pass null pointers to it. Passing a zero-length string (&quot;&quot;) doesn’t work; this passes a pointer to a null string rather than passing a null pointer.</p>
<p>
To pass a null pointer, declare the procedure as follows:</p>
<pre><code>Declare Function FindWindow Lib &quot;user32&quot; Alias &quot;FindWindowA&quot; _
&#09;(lpClassName As Any, lpWindowName As Any) As Long
</code></pre>
<p>
Although you can still call the procedure and pass it two strings, you can also pass a null pointer as one of the arguments.</p>
<pre><code>HWndExcel = FindWindow(ByVal 0&amp;, ByVal &quot;Microsoft Excel&quot;)
</code></pre>
<p>
Notice the use of the <b>ByVal</b> keyword with both arguments. You must use the <b>ByVal</b> keyword when passing the null pointer to ensure that the routine receives a zero value (a null pointer) instead of a pointer to a zero value.</p>
<p>
Also, notice the ampersand character (&amp;) after the zero. This informs Microsoft Access that you are passing a <b>Long</b> integer (32-bit), ensuring that a null pointer of the right size is passed. Pointers in Microsoft Access are always far (32-bit) pointers. You can use this technique to pass a null pointer to any procedure that accepts an argument by reference.</p>
<h5>Handles</h5>
<p>
The Windows DLL procedures make extensive use of handles—handles to Windows (hWnd), handles to device contexts (hDC), and so on. A <i>handle</i> is a unique long value defined by Windows and used to refer to objects such as forms and reports. When a procedure takes a handle as an argument, always declare it as a <b>ByVal</b> <b>Long</b>. DLL functions that return a handle can be declared as <b>Long</b> functions. Handles are identifier (ID) numbers, not pointers or numeric values. You should never perform mathematical operations on handles.</p>
<p>
The <b>hWnd</b> property of forms and reports supplies a valid handle that you can pass to DLL procedures. Like any other property passed to a DLL procedure, it can be passed only by value.</p>
<h5>Properties</h5>
<p>
To pass a property directly, you must pass it by value with the <b>ByVal </b>keyword. To pass a property by reference, you must use an intermediate variable. All strings are passed by reference; therefore, to pass a string property to a DLL procedure, you must first assign the property to a string variable and then pass the variable to the procedure.</p>
<h5>Object Variables</h5>
<p>
You can’t pass an object variable to a DLL procedure. Object variables are actually complex data structures, and DLL procedures can’t make use of them. Likewise, you can’t pass any of the system objects (<b>Application</b>, <b>Screen</b>, or <b>Debug</b>) or any DAO objects (<b>Database</b>, <b>Recordset</b>, and so on) to a DLL procedure.</p>
<h4>Converting Common Declarations</h4>
<p>
The procedures in DLLs are most commonly documented using C-language syntax. To call DLL procedures from Microsoft Access, you must translate them into valid <b>Declare</b> statements and call them correctly. The following table lists common C-language declarations and their Visual Basic equivalents.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">C-language declaration</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Visual Basic equivalent</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Call with</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
Boolean</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal </b>B<b> As Boolean</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Integer</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Pointer to a string (LPSTR)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal</b> S <b>As</b> <b>String</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">String</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Pointer to an integer (LPINT)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
I <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">As</b> <b>Integer</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Integer</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Pointer to a long integer (LPDWORD)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
L <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">As</b> <b>Long</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Long</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Pointer to a structure (for example, LPRECT)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
S <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">As</b> RECT</td>
<TD>
Any variable of that user-defined type</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
Integer (INT, UINT, WORD, BOOL)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal</b> I <b>As</b> <b>Integer</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Integer</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Handle (32-bit)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal </b>H<b> As Long</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Long</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Long (DWORD, LONG)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal</b> L <b>As</b> <b>Long</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Long</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Pointer to an array of integers</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
I <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">As Integer</b></td>
<TD>
The first element of the array, such as I(0)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
Pointer to a void (void *)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
V<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"> As</b> <b>Any</b></td>
<TD>
Any variable (use <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal</b> when passing a string)</td>
</tr>
<tr valign=top>
<TD>
Void (function return value)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Sub</b> procedure</td>
<TD>
Not applicable</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
NULL</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">As Any</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal</b> 0<b>&amp;</b></td>
</tr>
<tr valign=top>
<TD>
Char</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">ByVal </b>Ch<b> As Byte</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Byte</b> or<b> Variant</b> variable</td>
</tr>
<tr valign=top>
<TD>
Pointer to a char</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Ch <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">As Byte</b></td>
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Byte </b>or <b>Variant</b> variable</td>
</tr>
</table>
</FONT></FONT></BODY>
</HTML>
