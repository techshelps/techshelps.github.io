<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dealing with Uncalculated Cells</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Dealing with Uncalculated Cells</H2><P CLASS="t">During the recalculation of a worksheet, Microsoft Excel uses sophisticated heuristics to determine which cells are scheduled to be recalculated and in which order. This means that if you enter a function on a worksheet that calls a DLL and that function tries to look up the value of another cell, you cannot be sure whether the value has been recalculated yet. You need to be concerned about this only if all of the following conditions apply:</P>
<UL><LI CLASS="ULI1">You are writing a DLL function that will be entered on a worksheet.</LI><LI CLASS="ULI1">That function looks at the value of other cells on the worksheet.</LI><LI CLASS="ULI1">The DLL is not a macro type (the data type string does not contain "#"). For more information on this see Register (Form 1) "Handling Uncalculated Cells" in Chapter 2.</LI></UL><P></P>
<P CLASS="t">If your DLL functions are not meant to be entered on worksheets, or if they do not try to find out the values of cells elsewhere on the worksheet (for example, using xlCoerce), you do not need to worry about the possibility of uncalculated cells.</P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">Here is an example scenario: A DLL function called GetB5 returns the value of cell B5. The function would look like this:</P>

<pre><code><FONT FACE="Courier" SIZE="2">LPXLOPER WINAPI GetB5(void)
{
    static XLOPER xResult, xReference, xNum;

    xReference.xltype = xltypeSRef;
    xReference.val.sref.count = 1;
    xReference.val.sref.ref.rwFirst = 
        xReference.val.sref.ref.rwLast     = 4;
    xReference.val.sref.ref.colFirst = 
        xReference.val.sref.ref.colLast = 1;

    xNum.xltype = xltypeInt;
    xNum.val.w = xltypeNum;

    Excel4(xlCoerce, &amp;xResult, 2, (LPXLOPER) &amp;xReference,
        (LPXLOPER) &amp;xNum);

    return &amp;xResult;
}
</FONT></code></pre>
<P CLASS="t">This function can be registered with a <I>type_text</I> argument of "R!". The exclamation point means that the function is volatile and needs to be recalculated whenever the sheet changes. To work around this, set recalculation to manual. Next, enter the following formulas on a worksheet.</P>
<P CLASS="a">    <img src="CH07_24.gif"></P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">Microsoft Excel schedules the cells to be calculated in descending order. That is, first B1 will be calculated, then B2, then B3, and so on. What happens when we insert the GetB5 call on line B6?</P>
<P CLASS="a">    <img src="CH07_25.gif"></P>
<P CLASS="t">Initially, the value is correct. But Microsoft Excel has no way of knowing that the function GetB5 depends on the value of Cell B5. So if you change B1 . . .</P>
<P CLASS="a">    <img src="CH07_26.gif"></P>
<P CLASS="t">. . . and then recalculate by pressing F9, Microsoft Excel schedules B6 to be calculated first. Now when GetB5 tries to look at the value of B5, it finds that the cell has not been calculated yet. The xlCoerce function call returns xlretUncalced. However, Microsoft Excel remembers that it moved to that uncalculated cell and schedules B5 to be recalculated again later. Because the GetB5 function returns a wrong value, Microsoft Excel recalculates B2 through B5, and finally, calls GetB5 once again. So the final values are correct:</P>
<P CLASS="a">    <img src="CH07_27.gif"></P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">Finally, Microsoft Excel now knows that B6 is dependent on B5, and rightly schedules it to be calculated last in the future. GetB5 will not see xlretUncalced again.</P>
<P CLASS="t">Experienced XLM macro language users will recognize that this is not the behavior of the Microsoft Excel macro language. If GetB5 had been written in the&nbsp;XLM macro language, the first recalculation would simply have given the wrong value. Microsoft Excel would still reschedule B6, so the next recalculation would be correct. If, for some reason, you require this macro language behavior, you can specify # in the <I>type_text</I> argument to the REGISTER function.</P></FONT>
</FONT></BODY></HTML>
