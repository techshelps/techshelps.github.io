<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PropertyPut and PropertyGet</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H1>PropertyPut and PropertyGet</H1><P CLASS="t">The simplest example of a Microsoft Excel OLE Automation Controller is a DLL function that takes an object as an argument, obtains a DISPID for the object's Value property, and then uses PropertyPut or PropertyGet to set or get the value of the object. This simple example does not need the CoCreateInstance and QueryInterface functions, because the function can call the IDispatch interface directly with the object reference.</P>
<P CLASS="t">The CalcCells function is an example of a simple OLE Automation Controller. The function accepts a Range object as its first argument and a variant as its second argument. The function uses the PropertyGet method to obtain the value of&nbsp;the range; if the range contains more than one cell, the value is returned as an array. The function iterates the array, adding the value from each cell to a total (it&nbsp;attempts to coerce any values that are not doubles). Once the total is obtained, the function places the result in the second argument; if the argument specifies another range, the function uses the PropertyPut method to set the range value.</P>

<pre><code><FONT FACE="Courier" SIZE="2">SCODE WINAPI CalcCells(LPDISPATCH *ppdsSourceRange, 
    VARIANTARG *pvtResult)
{
    HRESULT hr;
    EXCEPINFO excep;
    ULONG cElements, i;
    DISPPARAMS dispparams;
    unsigned int uiArgErr, cDims;
    DISPID dispidValue, dispidPut;     
    VARIANTARG vSource, vResult, vTemp, *pvdata;
</FONT></code></pre>
<P></P>
<P></P>
<P></P>

<pre><code><FONT FACE="Courier" SIZE="2">    LPOLESTR lpszName = L"Value";

    hr = (*((*ppdsSourceRange)-&gt;lpVtbl-&gt;GetIDsOfNames))
            (*ppdsSourceRange, &amp;IID_NULL, &amp;lpszName, 
            1, LOCALE_SYSTEM_DEFAULT, &amp;dispidValue);
    if (hr != NOERROR)
        goto calc_error; 

    // PropertyGet has no arguments

    dispparams.cArgs = 0;
    dispparams.cNamedArgs = 0;

    // Invoke PropertyGet

    hr = (*((*ppdsSourceRange)-&gt;lpVtbl-&gt;Invoke))
            (*ppdsSourceRange, dispidValue, &amp;IID_NULL, 
            LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, 
            &amp;dispparams, &amp;vSource, &amp;excep, &amp;uiArgErr);
    if (hr != NOERROR)
        goto calc_error;

    // initialize the result variant

    VariantInit(&amp;vResult);
    vResult.vt = VT_R8;
    vResult.dblVal = 0.0;

    // If there is more than one cell in the source range, 
    // it's a variant containing an array. 
    // Access this using the SafeArray functions

    if (vSource.vt &amp; VT_ARRAY) 
    {
        // iterate the dimensions; number of elements is x*y*z
        for (cDims = 0, cElements = 1; 
                cDims &lt; vSource.parray-&gt;cDims; cDims++)
            cElements *= vSource.parray-&gt;rgsabound[cDims].cElements;

        // get a pointer to the data
        hr = SafeArrayAccessData(vSource.parray, (LPVOID)&amp;pvdata);
        if (hr != NOERROR)
            goto calc_error;

        // iterate the data. try to convert non-double values to double
    for (i = 0; i &lt; cElements; i++) 
    {</FONT></code></pre>
<P></P>
<P></P>
<P></P>

<pre><code><FONT FACE="Courier" SIZE="2">        vTemp = pvdata[i];
            if (vTemp.vt != VT_R8) 
            {
                hr = VariantChangeType(&amp;vTemp, 
                    &amp;vTemp, 0, VT_R8);
                if (hr != NOERROR)
                    goto calc_error;
            }

            // add the data. this is where we could 
            // add a more complicated function
            vResult.dblVal += vTemp.dblVal;
        }

        SafeArrayUnaccessData(vSource.parray);
    }
    else 
    {
        // only one cell in the source range. 
        // if it's not a double, try to convert it.
        if (vSource.vt != VT_R8) 
        {
            hr = VariantChangeType(&amp;vSource, &amp;vSource, 0, VT_R8);
            if (hr != NOERROR)
                goto calc_error;
        }
        vResult = vSource;
    }

    // if the result value is an object, 
    // get the DISPID for its Value property

    if (pvtResult-&gt;vt == VT_DISPATCH) 
    {
        hr = (*(pvtResult-&gt;pdispVal-&gt;lpVtbl-&gt;GetIDsOfNames))
                (pvtResult-&gt;pdispVal, &amp;IID_NULL, &amp;lpszName,
                1, LOCALE_SYSTEM_DEFAULT, &amp;dispidValue);
        if (hr != NOERROR)
            goto calc_error;

        dispidPut = DISPID_PROPERTYPUT;

        dispparams.rgdispidNamedArgs = &amp;dispidPut;
        dispparams.rgvarg = &amp;vResult;
        dispparams.cArgs = 1;
        dispparams.cNamedArgs = 1;

        // Invoke PropertyPut</FONT></code></pre>
<P></P>
<P></P>
<P></P>

<pre><code><FONT FACE="Courier" SIZE="2">        hr = (*(pvtResult-&gt;pdispVal-&gt;lpVtbl-&gt;Invoke))
                (pvtResult-&gt;pdispVal, dispidValue, &amp;IID_NULL, 
                LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYPUT, 
                &amp;dispparams, NULL, &amp;excep, &amp;uiArgErr);        
        if (hr != NOERROR)
            goto calc_error;
    }
    else 
    {
        // Result is not an object; it's a variable passed by reference.
        // Must free any existing allocation in the variant. 
        // The ReleaseVariant function is in dispargs.c

        ReleaseVariant(pvtResult);
        *pvtResult = vResult;
    }

    return 0;

calc_error:
    return GetScode(hr);    
}
</FONT></code></pre>
<P CLASS="t">This is a simple example, but it shows the setup for PropertyPut and PropertyGet and how the range value is returned as an array. You could write a more complex data-handling function around this simple example to implement a specialized DLL function. Remember that any variants your DLL function allocates (strings or arrays) must be freed to prevent memory leaks.</P>
<P CLASS="t">The code for this function is included on the samples disk in the SAMPLES\SDISP directory. This directory also includes the make file and module-definition file required to build SDISP.DLL. Once SDISP.DLL is available, you can call this function from Microsoft Excel, as shown in the following example:</P>

<pre><code><FONT FACE="Courier" SIZE="2">Declare Function CalcCells Lib "SDISP.DLL" _
    (source As Range, result As Variant) As Integer

Sub Button1_Click()
    Worksheets(1).Activate
    Range("A4").Clear
    CalcCells Range("A1:B3"), Range("A4")
End Sub
</FONT></code></pre>
<P></P>
<P></P>
<P></P></FONT>
</FONT></BODY></HTML>
