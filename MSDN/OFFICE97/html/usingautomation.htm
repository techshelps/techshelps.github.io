<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Automation</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="usingautomation"></a>Using Automation</h2>
<p>
Using Automation, you can integrate two or more components in a way that appears seamless to the user. Working with objects through Automation is very similar to working with objects in the component itself—you set and retrieve the object’s properties and apply its methods.</p>
<p>
When you perform an Automation operation, there are always two components involved. One component contains the objects you want to use. The other component is the one in which you are currently working, and from which you want to control those objects. Many components, including Microsoft Access, can act as either type of component. Some components can act as one or the other, but not both.</p>
<p>
For example, if you are working in Microsoft Access, you can create a Microsoft Word document through Automation if Microsoft Word 97 is installed on your computer. On the other hand, if you are working in Microsoft Word, you can use Automation to start Microsoft Access so that you can create a new database or retrieve information from an existing database.</p>
<p>
To use Automation in Microsoft Access, perform these steps, which are explained in greater detail in the sections that follow:
<ol>
<li>
Set a reference to the component’s object library.</li>
<li>
Create an instance of a class that defines an object in that object library and assign it to an object variable.</li>
<li>
Work with the new object by setting its properties and applying its methods.</li>
<li>
Close the object by using its <b>Quit </b>or <b>Close </b>method and use the <b>Nothing</b> keyword to free the memory that was allocated to the object variable.</li>
</ol>
<h3>Setting a Reference to an Object Library</h3>
<p>
Any component that supports Automation supplies information about its objects in an object library. The object library contains <i>classes </i>that define individual objects and collections of objects. An object’s class includes its name and information about its properties and methods—the information you need to know about the object in order to use it through Automation.</p>
<p>
Before you use another component’s objects in Visual Basic, you should set a reference to that component’s object library. Once you set a reference to an object library, Visual Basic recognizes the objects in that object library. You can then view those objects and their properties and methods in the Object Browser, which is available through the <b>View</b> menu, or by pressing F2, when you have a module open.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To set a reference to a component’s object library</b>
<ol>
<li>
Open a new or existing module.</li>
<li>
On the <b>Tools</b> menu, click <b>References</b>.<p>
Microsoft Access displays the <b>References</b> dialog box.</p>
</li>
<li>
In the <b>Available References</b> box, select the check box next to the object library that you want to reference.<p>
If a component’s object library doesn’t appear in the list, click <b>Browse</b> to locate the object library yourself. Often object library files end with .olb, .tlb, .dll, or .exe file name extensions.</p>
</li>
</ol>
<p>
For example, to see what objects are available in Microsoft Word, set a reference to the Microsoft Word 8.0 Object Library from Microsoft Access. Then open the Object Browser and click <b>Word</b> in the <b>Project/Library</b> box. The <b>Classes</b> box now lists all of the objects in the Microsoft Word object model.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the Object Browser, see “Using the Object Browser” in Chapter 5, “Working with Objects and Collections.” For more information on setting references to object libraries, see “Referencing Library Databases” in Chapter 12, “Using Library Databases and Dynamic-Link Libraries.”</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You can also set references in Visual Basic. For more information on setting references in code, search the Help index for “Reference object” or “References collection.”</p>
<h4>Binding Object Variables</h4>
<p>
You can use a component’s objects without setting a reference to that component’s object library. However, your code runs much faster if you do set a reference. Setting a reference affects when your code is bound. <i>Binding </i>is the process by which Visual Basic determines what type of object an object variable refers to. There are two types of binding: early binding and late binding.</p>
<p>
If you haven’t set a reference to the object library, you must declare any object variables that point to the component’s objects as type <b>Object</b>. When you declare an object variable as type <b>Object</b>, your code is late-bound. With late binding, Visual Basic has to determine at run time what type of object it is that you want to use; this process slows down your code. Late-bound component objects cannot be viewed using the Object Browser.</p>
<p>
Once you’ve set a reference to an object library, you can declare object variables according to their specific types. When you declare an object variable as a specific object type, your code is early-bound. Early-bound code runs faster than late-bound code because with early binding, Visual Basic determines what kind of object to create when you compile your code—before you run it.</p>
<p>
For example, if you are using Microsoft Excel’s objects through Automation, you can set a reference to the Microsoft Excel object library and then declare an object variable that points to a <b>Workbook </b>object as type <b>Workbook</b>. This code is early-bound.</p>
<pre><code>Dim wbk As Excel.Workbook
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You can also declare the object variable in the previous example by using the <b>New </b>keyword. For more information on the <b>New</b> keyword, see “Creating a New Instance with the New Keyword” later in this chapter.</p>
<p>
Alternatively, if you declared the variable as type <b>Object</b>, the code would be late-bound. This is true whether or not you’ve set a reference to the Microsoft Excel object library.</p>
<pre><code>Dim wbk As Object
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on object libraries, see Chapter 5, <a href="workingwithobjectscollections.htm">“Working with Objects and Collections.”</a> For more information on setting references, search the Help index for “setting references.”</p>
<h3>Creating an Instance of a Class</h3>
<p>
Once you set a reference to a component’s object library, you can begin using that component’s objects in Visual Basic. To create an object to use in Automation operations, you create an instance of that object’s class and assign the instance to an object variable. The object variable then points to the new object in memory. Note that when you create a new instance of a class, you are simply creating an instance of the object defined by that class.</p>
<p>
You can’t immediately use any object in the component’s object model, however. When you begin an Automation operation, the operating system has to start the component and return a reference to it. There are only a few objects in each object hierarchy that the operating system itself recognizes. Objects that the operating system recognizes are <i>registered </i>with the operating system. When you begin an Automation operation, you must begin with a registered object.</p>
<p>
Most components that are also applications have an <b>Application </b>object at the top of their object hierarchy which represents the application itself and contains all other objects and collections from the application’s type library. The <b>Application </b>object is always recognized by the operating system. When you create a new instance of a component’s <b>Application </b>class, you can then access all of the other objects in the component’s object model.</p>
<p>
Some components register a few other objects with the operating system as well. For example, Microsoft Excel registers a <b>Workbook</b> object in addition to its <b>Application </b>object. You can create a new <b>Workbook </b>object directly, without going through the <b>Application </b>object.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on which objects can be created directly through Automation, see the component’s documentation.</p>
<p>
The different ways to create a new instance of an object’s class are described in the following sections.</p>
<h4>Creating a New Instance with the New Keyword</h4>
<p>
The simplest way to create a new object is to declare an object variable by using the <b>New </b>keyword. When you use the <b>New </b>keyword, Visual Basic creates a new instance of an object’s class, returns a reference to that instance, and assigns the reference to the object variable being declared.</p>
<p>
For example, the following line of code creates a new instance of the Microsoft Excel <b>Application </b>class, returns a reference to that instance, and assigns it to an object variable.</p>
<pre><code>Dim appXL As New Excel.Application
</code></pre>
<p>
You can use the <b>New </b>keyword syntax only if you have set a reference to the object library supplied by the component. For example, you must set a reference to the Microsoft Excel object library before you can create a new instance of the Microsoft Excel <b>Application</b> class and assign it to an object variable. Variables declared with the <b>New </b>keyword are always early-bound.</p>
<p>
Note in the preceding example that the <b>Application </b>object is qualified so that Visual Basic knows to create the Microsoft Excel <b>Application </b>class. If you were to omit this qualification, Visual Basic would create a new instance of the Microsoft Access <b>Application </b>class, because you’re working within Microsoft Access. You can qualify an object with the name of the component that supplies the object library, as long as you’ve set a reference to that object library. To determine the name of the component, open the Object Browser and look in the <b>Project/Library</b> box. In the preceding example, the name of the component is Excel.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;It’s a good idea to make a habit of qualifying all objects used in Automation operations, because objects in different object libraries may have the same names. If you qualify your objects as you write Automation code, you can be assured that your code will continue to run properly in the presence of new object libraries that may be introduced in the future.</p>
<p>
If you want to use Microsoft Access objects from another component, such as Microsoft Excel, you can use the <b>New </b>keyword to create a new instance of the Microsoft Access <b>Application </b>class. For example:</p>
<pre><code>Dim appAccess As New Access.Application
</code></pre>
<p>
Each time you use the <b>New </b>keyword to create a new instance of a component’s <b>Application </b>class, Visual Basic starts the component. If the component is already running and you don’t want to start another instance, you should use the <b>GetObject </b>function.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>GetObject </b>function, see “Getting an Existing Instance with the GetObject Function” later in this chapter.</p>
<p>
A component that supports the <b>New </b>keyword syntax must have an object library, but not all components with object libraries also support the <b>New </b>keyword syntax. Check the component’s documentation to determine whether it supports the <b>New </b>keyword syntax. For components that don’t support the <b>New </b>keyword syntax, you can use the <b>CreateObject </b>function to return a new instance of an object’s class.</p>
<h4>Creating a New Instance with the CreateObject Function</h4>
<p>
The <b>CreateObject</b> function creates a new instance of a class and returns a reference to that instance. The <b>CreateObject </b>function is most useful for working with components that don’t support the <b>New </b>keyword syntax, although you can also use it with components that do support the <b>New </b>keyword.</p>
<p>
Use the <b>Set </b>statement to assign the reference returned by the<b> CreateObject </b>function to an object variable. The syntax for the <b>CreateObject </b>function is:</p>
<p>
<b>Set </b><i>objectvariable </i>= <b>CreateObject(</b><i>class</i><b>)</b></p>
<p>
In this syntax, <i>objectvariable </i>is an object variable of the type of object you want to create. For example, Microsoft Office Binder supplies an object library but doesn’t support the <b>New </b>keyword. To work with an instance of Microsoft Office Binder, you would first declare an object variable of type <b>Binder</b>, qualifying it with the name of the object library, as follows:</p>
<pre><code>Dim bnd As OfficeBinder.Binder
</code></pre>
<p>
In order for this example to work, you must have Microsoft Office Binder installed on your computer, and you must set a reference to the Microsoft Office Binder object library.</p>
<p>
As discussed earlier, declaring the object variable as a specific object type makes your code early-bound. If you declare the object variable as type <b>Object</b>, your codeis late-bound.</p>
<p>
The <i>class </i>argument specifies which component creates the object and what type of object it is, and takes the form <i>appname.objecttype</i>. To determine what the class argument should be, consult the component’s documentation. In the following example, <i>appname </i>is Office and <i>objecttype </i>is Binder.</p>
<pre><code>Set bnd = CreateObject(&quot;Office.Binder&quot;)
</code></pre>
<p>
The following example creates a new binder and adds a new Microsoft Word document and a new Microsoft Excel document.</p>
<pre><code>Sub CreateNewBinder()

&#09;' Declare variable of type Object.
&#09;Dim bnd As Object

&#09;' Create new instance and assign to variable.
&#09;Set bnd = CreateObject(&quot;Office.Binder&quot;)
&#09;' Add new Microsoft Word document.
&#09;bnd.Sections.Add(&quot;Word.Document&quot;)
&#09;' Add new Microsoft Excel workbook.
&#09;bnd.Sections.Add(&quot;Excel.Sheet&quot;)
&#09;' Save binder.
&#09;bnd.SaveAs FileName:= &quot;NewBinder.obd&quot;
&#09;' Free memory.
&#09;Set bnd = Nothing
End Sub
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;If you have more than one version of a component on your computer, you can specify the version number of the component that you want to use for an Automation operation. The following example creates a new instance of the Microsoft Excel version 7.0 <b>Application</b> class.</p>
<pre><code>Dim appXL As Excel.Application
Set appXL = CreateObject(&quot;Excel.Application.7&quot;)
</code></pre>
<p>
The version number for most applications included in Microsoft Office 95 is 7.0, while those in Microsoft Office 97 are version 8.0. For example, Microsoft Excel 95 is version 7.0, and Microsoft Excel 97 is version 8.0.</p>
<h4>Getting an Existing Instance with the GetObject Function</h4>
<p>
You can use the <b>GetObject</b> function to return a reference to an existing instance of a class in order to use that instance for an Automation operation. The <b>GetObject</b> function is useful when an instance of a component’s <b>Application</b> class already exists in memory, and you don’t want to create another instance. Use the <b>Set</b> statement to assign the reference returned by the <b>GetObject</b> function to an object variable. The syntax for the <b>GetObject</b> function is:</p>
<p>
<b>Set</b> <i>objectvariable</i> <b>=</b> <b>GetObject(</b>[<i>pathname</i>][, <i>class</i>]<b>)</b></p>
<p>
As with the <b>CreateObject</b> function, <i>objectvariable </i>is an object variable of the type of object you want to work with. For example, if you want to work with an existing instance of the Microsoft Excel <b>Application</b> class, first declare an object variable of type <b>Excel.Application</b>, and then use this variable with the <b>Set</b> statement and the <b>GetObject</b> function, as follows:</p>
<pre><code>Dim appXL As Excel.Application
Set appXL = GetObject(, &quot;Excel.Application&quot;)
</code></pre>
<p>
The optional <i>pathname</i> argument specifies the fully qualified path to an existing file. Use this argument if you want to work with an object in a specific file. The <i>class </i>argument specifies which component creates the object and what type of object it is, and takes the form <i>appname.objecttype</i>. In the previous example, <i>appname </i>is Excel and <i>objecttype </i>is Application.</p>
<p>
The following table provides a list of <i>class </i>arguments for some Microsoft components.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Component</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><i>class </i>argument</b></td>
<TD>
 <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Object returned</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
Microsoft Access</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Access.Application</code></pre>
</td>
<TD>
Microsoft Access <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Application </b>object</td>
</tr>
<tr valign=top>
<TD>
Microsoft Excel</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Excel.Application</code></pre>
</td>
<TD>
Microsoft Excel <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Application </b>object</td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Excel.Sheet</code></pre>
</td>
<TD>
Microsoft Excel <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Workbook </b>object</td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Excel.Chart</code></pre>
</td>
<TD>
Microsoft Excel <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Chart </b>object</td>
</tr>
<tr valign=top>
<TD>
Microsoft Word</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Word.Application</code></pre>
</td>
<TD>
Microsoft Word <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Application </b>object</td>
</tr>
</table>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;To determine the <i>class </i>argument for a component not in this list, consult the component’s documentation.</p>
<p>
You must specify either the <i>pathname </i>or the <i>class </i>argument, or both. If you specify a zero-length string (&quot;&quot;) for the <i>pathname</i> argument, the <b>GetObject </b>function creates a new instance of the component’s <b>Application</b> class specified by the <i>class</i> argument.</p>
<p>
You will get different results depending on which arguments you use with the <b>GetObject </b>function. The examples in the following table show different uses of the <b>GetObject </b>function with Microsoft Excel.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">GetObject function example</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Result</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Dim appXL As Excel.Application
Set appXL = GetObject(, &quot;Excel.Application&quot;)</code></pre>
</td>
<TD>
Returns a reference to an existing instance of the Microsoft Excel <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Application</b> class. Generates an error if Microsoft Excel is not already running.</td>
</tr>
<tr valign=top>
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Dim appXL As Excel.Application
Set appXL = GetObject(&quot;&quot;, &quot;Excel.Application&quot;)</code></pre>
</td>
<TD>
Creates a new hidden instance of the Microsoft Excel <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Application</b> class and returns a reference to that instance.</td>
</tr>
<tr valign=top>
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Dim wbk As Excel.Workbook
Set wbk = GetObject(&quot;&quot;, &quot;Excel.Sheet&quot;)</code></pre>
</td>
<TD>
Creates a new hidden instance of the Microsoft Excel <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Application</b> class and returns a reference to a <b>Workbook</b> object.</td>
</tr>
<tr valign=top>
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Dim wbk As Excel.Workbook
Set wbk = GetObject(, &quot;Excel.Sheet&quot;)</code></pre>
</td>
<TD>
Generates an error whether or not Microsoft Excel is running because the object type argument is different than the declared data type of the wbk object variable.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<pre><code><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Dim wbk As Excel.Workbook
Set wbk = GetObject(&quot;C:\My Documents\Revenue.xls&quot;)</code></pre>
</td>
<TD>
Creates a hidden instance of the Microsoft Excel <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Application</b> class and returns a reference to the <b>Workbook</b> object representing Revenue.xls.</td>
</tr>
</table>
<p>
If a component saves documents to disk as files, you can use the <b>GetObject</b> function to return a reference to an object in a specific document. For example, you can use the <b>GetObject </b>function to return a reference to a specific Microsoft Excel <b>Workbook</b> object, as shown in the last entry of the preceding table.</p>
<p>
This can be useful if a user has more than one instance of a component running at one time and you need to return a particular instance. For example, suppose your code has already opened the Microsoft Excel workbook Revenue.xls. If there’s another instance of Microsoft Excel open at the same time, the <b>GetObject</b> function may return either one. If you specifically need a reference to Revenue.xls, then you can specify the path and file name as an argument to the <b>GetObject</b> function.</p>
<p>
The following example creates an instance of the Microsoft Excel <b>Application</b> class and returns a reference to the <b>Workbook</b> object that represents the file Revenue.xls. The instance of Microsoft Excel is invisible to the user.</p>
<pre><code>Dim wbk As Excel.Workbook
Set wbk = GetObject(&quot;C:\My Documents\Revenue.xls&quot;, &quot;Excel.Sheet&quot;)
</code></pre>
<p>
In the preceding example, the <i>class </i>argument, <code>&quot;Excel.Sheet&quot;</code>, is optional. If you omit this argument, the operating system still knows what type of object to create because you’ve specified a particular file name. However, if you have more than one version of the component on your computer, you should specify the <i>class </i>argument with the component’s version number so that the correct version is used.</p>
<h3>Working with Objects Through Automation</h3>
<p>
Once you’ve created a new object and returned a reference to it, you can work with the object in Visual Basic in the same way you would work with any other object. That is, you can set and retrieve the object’s properties and apply its methods.</p>
<p>
Automation is useful when you’re writing code within a component that doesn’t provide some functionality you need, but you have another component that does provide that functionality. If both components support Automation, you can use the second component’s objects, properties, and methods from the first component.</p>
<p>
For example, Microsoft Access doesn’t have a built-in means to determine the median of a set of numbers. You can write your own procedure to find the median value, but using Automation to access the <b>Median</b> method of the Microsoft Excel <b>WorksheetFunction</b> object is easier. The following procedure uses the Microsoft Excel <b>Median</b> method to determine the median for a set of data passed as an array in the variable <code>avarItemArray</code>.</p>
<pre><code>Function GetMedian(avarItemArray As Variant) As Variant

&#09;' Create new instance of Microsoft Excel Application class.
&#09;Dim appXL As New Excel.Application

&#09;' Pass array to Microsoft Excel's Median function.
&#09;GetMedian = appXL.WorksheetFunction.Median(avarItemArray)
&#09;' Close Excel.
&#09;appXL.Quit
End Function
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The Microsoft Excel <b>Median</b> method is also a function in Microsoft Excel. The method and the function are identical, but the method is used with the <b>WorksheetFunction</b> object, while the function stands by itself. Functions that belong to a component are often available as methods of an object.</p>
<h4>Anticipating Messages in Automation Code</h4>
<p>
When you write Automation code, you should avoid actions that cause a component to display a dialog box, such as a message box. Once a dialog box is open, the code stops running until the user closes the dialog box. If the component isn’t visible to the user, the user won’t be able to close the dialog box. </p>
<p>
Some components post warning messages to the user before certain operations take place. For example, Microsoft Access warns the user before deleting a record in a table. When a component posts a warning message, execution halts until the user closes the warning message.</p>
<p>
The posted warning message presents problems if the component isn’t visible to the user or if the user doesn’t know what to do when the warning is posted. In some components, you can solve this problem in part by turning off all messages posted by the component. For example, in Microsoft Access you can use the <b>SetWarnings</b> method of the <b>DoCmd</b> object to turn off messages. This method turns off all messages except error messages. To determine whether a particular component offers a similar method, check the component’s documentation.</p>
<h4>Handling Errors in Automation Code</h4>
<p>
You must also carefully consider any errors that may occur when your Automation code is running and try to prevent them or handle them gracefully. For example, if a user must input a value that lies within a certain range, try to write the procedure so that it tests the value without generating an error. If an error does occur, Visual Basic posts an error message and halts the running code, unless you’ve included error-handling routines. By using an error-handling routine, you can prevent the error message from being displayed and correct the error. </p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on error handling, see Chapter 8, <a href="handlingrun-timeerrors.htm">“Handling Run-Time Errors.”</a></p>
<h3>Closing an Object</h3>
<p>
Objects use memory and system resources while they’re active. When you’ve finished working with an object, you should close the object by using the method supported by that particular object. Most objects support a <b>Close</b> method or a <b>Quit</b> method that you can use to close the object and free the resources it has been using. You should also use the <b>Nothing</b> keyword with the <b>Set</b> statement to free the memory that’s being used by the object variable associated with an object. Once you set an object variable to the <b>Nothing</b> keyword, it no longer points to an object and no longer uses system resources.</p>
<p>
The following example shows different ways to free the memory associated with an object variable:</p>
<pre><code>Sub UseExcel()

&#09;' Create a new instance of the Excel Application class.
&#09;Dim appXL As New Excel.Application
&#09;' Declare other object variables.
&#09;Dim wbk As Excel.Workbook

&#09;Set wbk = appXL.Workbooks.Add
&#09;appXL.Visible = True
&#09;&#09;.
&#09;&#09;. ' Perform an Automation operation.
&#09;&#09;.
&#09;' Close objects and component and free memory.
&#09;wbk.Close
&#09;appXL.Quit
&#09;Set appXL = Nothing
End Sub
</code></pre>
<p>
System resources are also freed when an object variable that points to an object goes out of scope. However, it’s a good idea to close an object or set it to the <b>Nothing</b> keyword to guarantee that resources are freed when the object is no longer needed, and to make your code self-documenting.</p>
<p>
If you are working with a component’s <b>Application</b> object, the component may not actually close when you set the object variable to the <b>Nothing</b> keyword, even though the memory used by the object variable has been freed. In this case, you must explicitly use the <b>Application</b> object’s <b>Quit</b> method to close the component before you set the object variable to the <b>Nothing</b> keyword.</p>
<h3>Using Microsoft Access Objects Through Automation</h3>
<p>
So far, you have seen how to work with other components’ objects from Microsoft Access. You can also work with Microsoft Access objects from other components. For example, you can use Automation to create a Microsoft Access report from a Microsoft Excel spreadsheet.</p>
<p>
The following example uses Automation from Microsoft Excel to create a linked table in a Microsoft Access database and then create a Microsoft Access report based on the data in the linked table. To use this example, you need to create a Microsoft Excel workbook named Revenue.xls, add some data to a worksheet in that workbook, and create a named range called DataRange that includes this data. Then, enter the following code in the Declarations section of a module in the Microsoft Excel workbook.</p>
<p>
Important   Before you run this code, make sure that the Microsoft Excel ISAM driver (MSEXCL35.dll) is installed on your system. The Microsoft Excel ISAM driver enables Microsoft Excel files to work with the Microsoft Jet database engine. For more information on working with the Microsoft Excel ISAM driver, search the Help index for “Microsoft Excel driver.” Also, make sure that the Northwind database Startup form is configured not to open when you open the Northwind sample database.</p>
<pre><code>' Enter in Declarations section of a module.
Dim appAccess As New Access.Application

Sub PrintReport()

&#09;Dim rpt As Access.Report, ctl As Access.Control
&#09;Dim dbs As DAO.Database, tdf As DAO.TableDef, fld As DAO.Field
&#09;Dim strDB As String, intLeft As Integer

&#09;' Set this constant to the path to your Northwind sample database.
&#09;Const conFilePath As String = &quot;C:\Program Files\Microsoft Office\Office\Samples\&quot;
&#09;&#09;
&#09;' Open database in Microsoft Access, specifying full path name.
&#09;appAccess.OpenCurrentDatabase conFilePath &amp; &quot;Northwind.mdb&quot;
&#09;' Return reference to current database.
&#09;Set dbs = appAccess.CurrentDb
&#09;' Create new TableDef object.
&#09;Set tdf = dbs.CreateTableDef(&quot;XLData&quot;)
&#09;' Specify connect string for Microsoft Excel ISAM driver.
&#09;tdf.Connect = &quot;EXCEL 8.0; Database=C:\My Documents\Revenue.xls&quot;
&#09;' Specify source table as a named range in a worksheet.
&#09;tdf.SourceTableName = &quot;DataRange&quot;
&#09;' Append new linked table to database.
&#09;dbs.TableDefs.Append tdf
&#09;' Create new report in Microsoft Access.
&#09;Set rpt = appAccess.CreateReport
&#09;' Specify linked table as report's record source.
&#09;rpt.RecordSource = tdf.Name
&#09;
&#09;' Create control on report for each field in linked table.
&#09;For Each fld In tdf.fields
&#09;&#09;Set ctl = appAccess.CreateReportControl(rpt.Name, acTextBox, , , _
&#09;&#09;&#09;fld.Name, intLeft)
&#09;&#09;intLeft = intLeft + ctl.Width
&#09;Next fld

&#09;' Open report in Print Preview.
&#09;appAccess.DoCmd.OpenReport rpt.Name, acViewPreview
&#09;' Restore report.
&#09;appAccess.DoCmd.Restore
&#09;' Display Microsoft Access as active application.
&#09;AppActivate &quot;Microsoft Access&quot;
End Sub
</code></pre>
</FONT></FONT></BODY>
</HTML>
