<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Arrays</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="arrays"></a>Arrays</h2>
<p>
If you have programmed in other languages, you’re probably familiar with the concept of <i>arrays</i>. You use arrays to refer to a series of variables by the same name while using a number (an index) to tell them apart. This helps you create smaller and simpler code in many situations because you can set up loops that deal efficiently with multiple cases by using the index number. Arrays have both upper and lower bounds, and the elements of the array are contiguous within those bounds. Because Visual Basic allocates space for each index number, avoid declaring an array larger than you need it to be.</p>
<p>
All the elements in an array have the same data type. Of course, when the data type is <b>Variant</b>, the individual elements may contain different kinds of data (strings, numbers, date/time values, or objects). You can declare an array with any of the fundamental data types, including user-defined types, and object variables. </p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on user-defined types, see “Creating Your Own Data Types” earlier in this chapter. For information on object types, see Chapter 5, <a href="workingwithobjectscollections.htm">“Working with Objects and Collections.”</a></p>
<h3>Declaring Fixed-Size Arrays</h3>
<p>
You can declare an ordinary (fixed-size) array in three ways, depending on the scope you want the array to have:
<ul>
<li>
To create a <i>public array</i>, use the <b>Public</b> statement in the Declarations section of a module to declare the array.</li>
<li>
To create a <i>module-level array</i>, use the <b>Private</b> or <b>Dim</b> statement in the Declarations section of a module to declare the array. </li>
<li>
To create a <i>local array</i>, use the <b>Dim</b> or <b>Static</b> statement within a procedure to declare the array.</li>
</ul>
<p>
There are additional rules when you create a <i>dynamic array</i> (an array whose size can change at run time). </p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on dynamic arrays, see “Dynamic Arrays” later in this chapter.</p>
<h4>Setting Upper and Lower Bounds</h4>
<p>
When declaring an array, follow the array name with the upper bound in parentheses. The upper bound must be a <b>Long</b> data type (in the range -231 to 231). For example, the following array declarations can appear in the Declarations section of a module:</p>
<pre><code>Dim intCount(14) As Integer&#09;&#09;&#09;&#09;' Declares an array with 15&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' elements (0 through 14).
Dim dblSum(20) As Double&#09;&#09;&#09;&#09;&#09;' Declares an array with 21&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' elements (0 through 20).
</code></pre>
<p>
To create a public array, you use <b>Public</b> in place of <b>Dim </b>(or<b> Private</b>):</p>
<pre><code>Public intCount(14) As Integer

Public dblSum(20) As Double
</code></pre>
<p>
To create a local array, use the <b>Dim</b> (or <b>Static</b>)<b> </b>statement:</p>
<pre><code>Dim intCount(14) As Integer

Static dblSum(20) As Double
</code></pre>
<p>
The first declaration creates an array with 15 elements, with index numbers running from 0 through 14. The second creates an array with 21 elements, with index numbers running from 0 through 20. The default lower bound is 0. However, you can change the default lower bound to 1 by placing the following <b>Option Base </b>statement in the Declarations section of a module:</p>
<pre><code>Option Base 1
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>Option</b> <b>Base</b> statement, search the Help index for “Option Base statement.”</p>
<p>
Another way to specify the lower bound is to provide it explicitly by using the <b>To</b> keyword. For example:</p>
<pre><code>Dim intCount(1 To 15) As Integer

Dim dblSum(100 To 120) As Double
</code></pre>
<p>
In the preceding declarations, the index numbers of <code>intCount</code> run from 1 through 15 (15 elements), and the index numbers of <code>dblSum</code> run from 100 through 120 (21 elements).</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;With some versions of Basic, you can use an array without first declaring it. With Visual Basic, this isn’t possible; you must declare an array before using it.</p>
<h3>Multidimensional Arrays</h3>
<p>
With Visual Basic, you can declare arrays of up to 60 dimensions. For example, the following statement declares a two-dimensional 10-by-10 array within a procedure:</p>
<pre><code>Static dblMatrix(9, 9) As Double
</code></pre>
<p>
Either or both dimensions can be declared with explicit lower bounds:</p>
<pre><code>Static dblMatrix(1 To 10, 1 To 10) As Double
</code></pre>
<p>
You can extend this to more than two dimensions, as in the following example:</p>
<pre><code>Dim intMultiD(3, 1 To 10, 1 To 15) As Integer
</code></pre>
<p>
This declaration creates a three-dimensional 4-by-10-by-15 array. The total number of elements is the product of these three dimensions, or 600. </p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Because the total storage needed by the array increases dramatically when you start adding dimensions to it, be sure to use multidimensional arrays with care. Be especially careful with <b>Variant</b> arrays, because <b>Variant</b> arrays are larger than arrays containing other data types.</p>
<h3>Using Loops to Manipulate Arrays</h3>
<p>
Loops often provide an efficient way to manipulate arrays. For example, the following loop initializes all elements in the array to 5:</p>
<pre><code>Static intCount(1 To 15) As Integer
Dim intX As Integer

For intX = 1 To 15
&#09;intCount(intX) = 5
Next intX
</code></pre>
<p>
You can efficiently process a multidimensional array by using nested <b>For</b> loops. For example, the following statements initialize every element in <code>dblMatrix</code> to a value based on its location in the array:</p>
<pre><code>Dim intX As Integer, intY As Integer
Static dblMatrix(1 To 10, 1 To 10) As Double

For intX = 1 To 10
&#09;For intY = 1 To 10
&#09;&#09;dblMatrix(intX, intY) = intX * 10 + intY
&#09;Next intY
Next intX
</code></pre>
<h3>Dynamic Arrays</h3>
<p>
Sometimes you may not know exactly how large to make an array. You may want to be able to change the size of the array at run time.</p>
<p>
A dynamic array can be resized at any time. Dynamic arrays are among the most flexible and convenient features in Visual Basic, and they help you to manage memory efficiently. For example, you can use a large array for a short time and then free up memory to the system when you’re no longer using the array.</p>
<p>
The alternative is to declare an array with the largest anticipated size and then to ignore array elements you don’t need. However, if overused, this approach may cause Microsoft Access to run low on memory.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To create a dynamic array</b>
<ol>
<li>
Declare the array with a <b>Public</b>,<b> Private</b>,<b> </b>or<b> Dim </b>statement at the module level (if you want the array to be public or module-level), or with a <b>Static</b> or <b>Dim</b> statement at the procedure level (if you want the array to be local). You declare the array as dynamic by giving it an empty dimension list. For example:<pre><code>Dim intDynArray() As Integer
</code></pre>
</li>
<li>
Allocate the actual number of elements with a <b>ReDim</b> statement. For example:<pre><code>ReDim intDynArray(intX + 1)
</code></pre>
</li>
</ol>
<p>
The <b>ReDim</b> statement can appear only in a procedure. Unlike the <b>Dim</b> and <b>Static</b> statements, <b>ReDim</b> makes the application carry out an action at run time.</p>
<p>
The <b>ReDim</b> statement supports the same syntax as that used for fixed arrays. Each <b>ReDim</b> statement can change the number of elements, as well as the lower and upper bounds for each dimension. However, the number of dimensions in the array can’t change from the number used in the first <b>ReDim</b> statement.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on array syntax, see “Arrays” earlier in this chapter.</p>
<p>
For example, you create the dynamic array <code>intMatrix</code> by first declaring it at the module level:</p>
<pre><code>Dim intMatrix() As Integer
</code></pre>
<p>
A function then allocates space for the array:</p>
<pre><code>Function CalcValuesNow () As Integer
&#09;.
&#09;.
&#09;.
&#09;ReDim intMatrix(19, 29)
End Function
</code></pre>
<p>
The <b>ReDim</b> statement allocates a matrix of 20-by-30 integers (for a total size of 600 elements). Alternatively, the bounds of a dynamic array can be set by using variables:</p>
<pre><code>ReDim intMatrix(intX, intY)
</code></pre>
<h4>Preserving the Contents of Dynamic Arrays</h4>
<p>
It’s important to note that each time you run the <b>ReDim</b> statement, all the values currently stored in the array are lost. Visual Basic resets the values to the <b>Empty </b>value (for <b>Variant</b> arrays), to zero (for numeric arrays), to a zero-length string (<code>&quot;&quot;</code>) (for string arrays), or to <b>Nothing</b> (for arrays of objects).</p>
<p>
This is useful when you want to prepare the array for new data or when you want to shrink the size of the array to take up minimal memory. However, you may sometimes want to change the size of the array without losing the data in the array. You can do this by using the <b>ReDim</b> statement with the <b>Preserve</b> keyword. For example, you can enlarge an array by one element without losing the values of the existing elements, as shown in the following code:</p>
<pre><code>ReDim Preserve intMatrix(UBound(intMatrix) + 1)
</code></pre>
<p>
Only the upper bound of the last dimension in a multidimensional array can be changed when you use the <b>Preserve</b> keyword. If you change any of the other dimensions or the lower bound of the last dimension, a run-time error occurs. Therefore, you can use code as follows:</p>
<pre><code>ReDim Preserve intMatrix(10, UBound(intMatrix, 2) + 1)
</code></pre>
<p>
But you cannot use the following code:</p>
<pre><code>ReDim Preserve intMatrix(UBound(intMatrix, 1) + 1, 10)
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>Preserve </b>keyword, search the Help index for “ReDim statement.”</p>
</FONT></FONT></BODY>
</HTML>
