<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using On Error Statements</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="usingonerrorstatements"></a>Using On Error Statements</h2>
<p>
You can handle Visual Basic run-time errors by adding <b>On Error</b> statements and error-handling code to your procedures. For example, the event procedures created by Microsoft Access wizards include <b>On Error</b> statements and error-handling code. The following Click event procedure created by a control wizard shows how many of the procedures created by wizards handle errors.</p>
<pre><code>Private Sub Button1_Click()
&#09;
&#09;Dim strDocName As String

&#09;On Error GoTo Err_Button1_Click

&#09;strDocName = &quot;ProductsPopUp&quot;
&#09;DoCmd.OpenForm strDocName

Exit_Button1_Click:
&#09;Exit Sub

Err_Button1_Click:
&#09;MsgBox Err.Description
&#09;Resume Exit_Button1_Click
End Sub
</code></pre>
<p>
In this code, the <b>On Error</b> statement turns on error handling. If an error occurs, Visual Basic <i>branches</i> (passes program control) to the Err_Button1_Click line label, which marks the beginning of the error-handling code. It then runs the <b>MsgBox</b> statement, displaying the error’s message string. Visual Basic then runs the <b>Resume</b> statement to exit the error-handling code, branching to the Exit_Button1_Click line label. Finally, Visual Basic runs the <b>Exit Sub</b> statement to exit the Button1_Click procedure.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on line labels, search the Help index for “GoTo statement.”</p>
<p>
If no error occurs, Visual Basic runs each line of code until it reaches the <b>Exit Sub</b> statement and then exits the procedure. It doesn’t run the Err_Button1_Click error-handling code that follows.</p>
<p>
If your application doesn’t handle Visual Basic run-time errors, users may be surprised if a run-time error suddenly halts the application. It’s especially important to handle Visual Basic errors if you’re creating a run-time version of your application. A run-time application shuts down if an untrapped error occurs.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on creating a run-time version of your application, see Chapter 15, <a href="deliveringyourapplication.htm">“Delivering Your Application.”</a></p>
<p>
For example, the following procedure doesn’t contain error-handling code. It returns <b>True</b> (– 1) if the specified file exists and <b>False</b> (0) if it doesn’t exist.</p>
<pre><code>Function FileExists (ByVal strFileName As String) As Boolean
&#09;FileExists = (Dir(strFileName) &lt;&gt; &quot;&quot;)
End Function
</code></pre>
<p>
The <b>Dir</b> function returns the first file matching the specified file name, and returns a zero-length string (&quot;&quot;) if no matching file is found. The code appears to cover either of the possible outcomes of the <b>Dir</b> call. However, if the drive letter specified in the argument isn’t a valid drive, the run-time error message “Device unavailable” is displayed. If the specified drive is a floppy disk drive, this function works correctly only if a disk is in the drive and the drive door is closed. If not, the run-time error “Disk not ready” occurs. In both cases, Microsoft Access displays the error message and halts execution of the code.</p>
<p>
To avoid this situation, you can use an <b>On Error</b> statement to respond to Visual Basic errors and take corrective action. For example, device problems such as an invalid drive or an empty floppy disk drive can be handled by the following code:</p>
<pre><code>Function FileExists (ByVal strFileName As String) As Boolean
&#09;Dim strMsg As String

&#09;On Error GoTo CheckError&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Turn on error handling.
&#09;FileExists = (Dir(strFileName) &lt;&gt; &quot;&quot;)&#09;' Use Dir function to see 
&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' if file exists.

&#09;Exit Function&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Avoid running error-handling
&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' code if no error occurs.

CheckError:&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Run following code 
&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' if error occurs.
&#09;' Declare constants to represent Visual Basic error codes.
&#09;Const conErrDiskNotReady = 71, conErrDeviceUnavailable = 68
&#09;' vbExclamation, vbOK, vbCancel, vbCritical, and vbOKCancel are
&#09;' intrinsic constants that don't need to be declared.

&#09;If (Err.Number = conErrDiskNotReady) Then
&#09;&#09;' Display message box with an exclamation point icon and with 
&#09;&#09;' OK and Cancel buttons.
&#09;&#09;strMsg = &quot;Put a floppy disk in the drive and close the drive door.&quot;
&#09;&#09;If MsgBox(strMsg, vbExclamation + vbOKCancel) = vbOK Then
&#09;&#09;&#09;Resume
&#09;&#09;Else
&#09;&#09;&#09;Resume Next
&#09;&#09;End If
&#09;ElseIf Err.Number = conErrDeviceUnavailable Then
&#09;&#09;strMsg = &quot;This drive or path does not exist: &quot; &amp; strfilename
&#09;&#09;MsgBox strMsg, vbExclamation
&#09;&#09;Resume Next
&#09;Else
&#09;&#09;strMsg = &quot;Error number &quot; &amp; Str(Err.Number) &amp; &quot; occurred: &quot; &amp; _
&#09;&#09;&#09;Err.Description
&#09;&#09;' Display message box with stop sign icon and OK button.
&#09;&#09;MsgBox strMsg, vbCritical
&#09;&#09;Stop
&#09;End If
&#09;Resume
End Function
</code></pre>
<p>
This code uses properties of the <b>Err</b> object to return the error code number and the message string associated with the run-time error that occurred.</p>
<p>
When Visual Basic generates the error “Disk not ready,” the FileExists function displays a message telling the user to click one of two buttons, OK or Cancel. If the user clicks OK, the <b>Resume</b> statement returns program control to the statement at which the error occurred and attempts to run that statement again. This statement succeeds if the user has corrected the problem; otherwise, the program returns to the error-handling code.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the methods and properties of the <b>Err</b> object, search the Help index for “Err object.”</p>
<p>
If the user clicks Cancel, the <b>Resume Next</b> statement returns program control to the statement following the one at which the error occurred, in this case, the <b>Exit Function</b> statement.</p>
<p>
If the “Device unavailable” error occurs, Visual Basic displays a message describing the problem. The <b>Resume Next</b> statement then returns program control to the statement following the one at which the error occurred.</p>
<p>
If an unanticipated error occurs, Visual Basic displays an alternative message and halts the code at the <b>Stop</b> statement.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on using the <b>Stop</b> statement for error handling, see “Guidelines for Complex Error Handling” later in this chapter.</p>
<p>
The error-handling code in the preceding example involves three steps:
<ol>
<li>
Turn on error handling, and set (<i>enable)</i> an error trap by telling the application where to branch (which error-handling routine to run) when an error occurs.<p>
The <b>On Error</b> statement in the FileExists function turns on error handling and directs the application to the CheckError line label.</p>
</li>
<li>
Write error-handling code that responds to all errors you can anticipate. If program control actually branches to the error-handling code at some point, the trap is then said to be <i>active</i>.<p>
The CheckError code handles the error by using an <b>If...Then...Else</b> statement that checks the value returned by the <b>Number</b> property of the <b>Err</b> object. The <b>Number</b> property of the <b>Err</b> object returns an error code number corresponding to the error message that Visual Basic generates. In the example, if the “Disk not ready” error is generated, a message prompts the user to close the drive door. A different message is displayed if the “Device unavailable” error occurs.</p>
<p>
Your code should also determine what action to take if an unanticipated error occurs. In the previous FileExists function, if any error other than “Disk not ready” or “Device unavailable” occurs, a general message is displayed and the program stops.</p>
</li>
<li>
Exit the error-handling code.<p>
In the case of the “Disk not ready” error, the <b>Resume</b> statement passes program control back to the statement at which the error occurred. Visual Basic then tries to run that statement again. If the situation hasn’t changed, then the same error occurs again, and execution branches back to the error-handling code.</p>
<p>
In the case of the “Device unavailable” error, the <b>Resume Next</b> statement passes program control to the statement following the one at which the error occurred.</p>
</li>
</ol>
<p>
The following sections describe in detail how to perform these steps. Refer to the FileExists function in this section as you read.</p>
<h3>Setting the Error Trap</h3>
<p>
The first step in writing error-handling code is creating an <b>On Error</b> statement, which specifies the next line of code to run if an error occurs. Use the syntax <b>On Error GoTo</b> <i>line</i>, where <i>line</i> indicates the line label identifying the error-handling code. Running the <b>On Error</b> statement turns on error handling and enables an error trap. The error trap remains enabled while the procedure containing it is active; that is, until an <b>Exit Sub</b>, <b>Exit Function</b>, <b>End Sub</b>, or <b>End Function</b> statement is run for that procedure. You can disable error handling in the current procedure by using another form of the <b>On Error</b> statement, <b>On Error GoTo 0</b>.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on disabling error handling, see “Turning Off Error Handling” later in this chapter.</p>
<h3>Writing Error-Handling Code</h3>
<p>
Begin the error-handling code with the line label specified in the <b>On Error</b> statement. In the FileExists function, the line label is CheckError. The colon is part of the label, although it isn’t used in the <b>On Error GoTo</b> <i>line</i> statement.</p>
<p>
You’ll usually include error-handling code at the end of a procedure, before the <b>End Function</b> or <b>End Sub</b> statement. Enter an <b>Exit Function</b>, <b>Exit Sub</b>, or <b>Exit Property</b> statement at the end of the main procedure code, but immediately preceding the error handler’s line label. This prevents Visual Basic from running the error-handling code at the conclusion of the main-procedure code if no error occurs.</p>
<p>
The <b>Number</b> property of the <b>Err</b> object returns an error code number representing the most recent run-time error. By using the <b>Number</b> property of the <b>Err</b> object in combination with the <b>Select Case</b> or <b>If...Then...Else</b> statement, you can take specific action for any error that occurs.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The string returned by the <b>Description</b> property of the <b>Err</b> object always explains the error associated with the current error code number. However, the exact wording of the message may vary among different versions of Microsoft Access. Therefore, use the <b>Number</b> property rather than the <b>Description</b> property to identify the specific error that occurred.</p>
<p>
When designing your error-handling routine, include code that tells the user what the problem is and how to proceed. Also, if the application can’t continue after an error is encountered, it’s a good idea to close open objects, remote connections, and database files when you exit the application.</p>
<h3>Exiting Error-Handling Code</h3>
<p>
The preceding FileExists function uses the <b>Resume</b> statement within the error-handling code to rerun the statement that caused the error, and uses the <b>Resume Next</b> statement to resume execution at the statement following the one at which the error occurred. Depending on the circumstances, there are other ways to exit error-handling code; regardless of which way you exit, you should always tell the error handler what to do when its execution is complete. To exit error-handling code, use any of the statements shown in the following table.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Statement</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Resume</b> </td>
<TD>
Resumes program execution starting with the statement that caused the error.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Resume Next</b></td>
<TD>
Resumes program execution at the statement immediately following the one that caused the error.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Resume</b> <i>line</i></td>
<TD>
Resumes program execution at the label specified by <i><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">line</i>, where <i>line</i> is a line label that must be in the same procedure as the error handler.</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Err.Raise Number:=</b> <i>number</i></td>
<TD>
Triggers the most recent run-time error again. When this statement is run within error-handling code, Visual Basic searches backward through the calls list for other error-handling code. The <i><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">calls list</i> is the chain of procedures that lead to the current point of execution. For more information, see “Unanticipated Errors” later in this chapter.</td>
</tr>
</table>
<h4>The Resume and Resume Next Statements</h4>
<p>
You can use the <b>Resume</b> and <b>Resume Next</b> statements to perform similar functions. The <b>Resume</b> statement returns program control to the statement that caused the error. You use it to rerun the statement after correcting the error. The <b>Resume Next</b> statement returns program control to the statement immediately following the one that caused the error. The difference between <b>Resume</b> and <b>Resume Next</b> is shown in the following illustration.</p>
<p>
<img src="abac08_1.gif" border=0></p>
<p>
Generally, you use the <b>Resume</b> statement whenever the user must make a correction. Use the <b>Resume Next</b> statement whenever a correction by the user isn’t required, and you want to continue program execution without attempting to rerun the statement that caused the error. You can also use the <b>Resume Next</b> statement if you anticipate an error in a loop, and you want to start the loop operation again if an error occurs. With the <b>Resume Next</b> statement, you can write error-handling code so that the existence of a run-time error isn’t revealed to the user. </p>
<p>
For example, the following Divide function uses error handling to perform division on its numeric arguments without revealing errors that have occurred. There are several errors that can occur in division. If the numerator is not zero, but the denominator is zero, Visual Basic generates the “Division by zero” error; if both numerator and denominator are zero in floating-point division, it generates the “Overflow” error; or if either the numerator or the denominator is a nonnumeric value (or can’t be considered a numeric value), Visual Basic displays an appropriate error message. In all three cases, the Divide function traps these errors and returns the <b>Null </b>value.</p>
<pre><code>Function Divide (Numerator, Denominator) As Variant
&#09;
&#09;Const conErrDivo = 11, conErrOverflow = 6, conErrIllFunc = 5

&#09;On Error GoTo MathHandler 

&#09;Divide = Numerator / Denominator
&#09;Exit Function

MathHandler:
&#09;' If error was Division by zero, Overflow, or 
&#09;' Illegal function call, return Null.
&#09;If Err.Number = conErrDivo Or Err.Number = conErrOverflow Or _
&#09;&#09;Err.Number = conErrIllFunc Then
&#09;&#09;Divide = Null&#09;&#09;
&#09;Else
&#09;&#09;MsgBox &quot;Unanticipated error &quot; &amp; Err.Number &amp; &quot;: &quot; &amp; _
&#09;&#09;&#09;Error.Description, vbExclamation
&#09;End If&#09;&#09;&#09;&#09;&#09;
&#09;' In all cases, Resume Next continues execution at the 
&#09;' Exit Function statement.
&#09;Resume Next&#09;&#09;&#09;&#09;
End Function
</code></pre>
<h4>The Resume <i>line </i>Statement</h4>
<p>
Alternatively, you can use the syntax <b>Resume</b> <i>line</i>, which returns control to a specified line label. The following example illustrates the use of the <b>Resume</b> <i>line</i> statement. A variation on the preceding FileExists function, the following VerifyFile function enables the user to enter a file specification that the function returns if the file exists.</p>
<pre><code>Function VerifyFile () As Variant
&#09;
&#09;Const conErrBadFileName = 52, conErrDriveDoorOpen = 71
&#09;Const conErrDeviceUnavailable = 68, conErrInvalidFileName = 64

&#09;Dim strPrompt As String, strMsg As String, strFileSpec As String

&#09;On Error GoTo Handler

&#09;strPrompt = &quot;Enter file specification to check:&quot;

StartHere:
&#09;strFileSpec = &quot;*.*&quot;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Start with a default spec.
&#09;strMsg = strMsg &amp; vbCrLf &amp; strPrompt
&#09;' Let the user modify the default.
&#09;strFileSpec = InputBox(strMsg, &quot;File Search&quot;, strFileSpec, 100, 100)
&#09;' Exit if the user enters nothing.&#09;
&#09;If strFileSpec = &quot;&quot; Then Exit Function&#09;
&#09;VerifyFile = Dir(strFileSpec)
&#09;Exit Function

Handler:
&#09;Select Case Err.Number&#09;&#09;&#09;&#09;&#09;&#09;' Analyze error code, then load message.
&#09;&#09;Case conErrInvalidFileName, conErrBadFileName
&#09;&#09;&#09;strMsg = &quot;Your file specification is invalid. Try another.&quot;
&#09;&#09;Case conErrDriveDoorOpen
&#09;&#09;&#09;strMsg = &quot;Close the disk drive door and try again.&quot;
&#09;&#09;Case conErrDeviceUnavailable
&#09;&#09;&#09;strMsg = &quot;The drive you specified was not found. Try again.&quot;
&#09;&#09;Case Else
&#09;&#09;&#09;Dim intErrNum As Integer&#09;&#09;&#09;

&#09;&#09;&#09;intErrNum = Err.Number
&#09;&#09;&#09;Err.Clear&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Clear the Err object.
&#09;&#09;&#09;Err.Raise Number:=intErrNum&#09;&#09;' Regenerate the error.
&#09;End Select
&#09;' This jumps back to the StartHere label so the user can 
&#09;' try another file name.
&#09;Resume StartHere&#09;
End Function&#09;&#09;&#09;&#09;
</code></pre>
<p>
If a file matching the specification is found, the function returns the file name. If no matching file is found, the function returns a zero-length string (&quot;&quot;). If one of the anticipated errors occurs, a message appropriate to the error is assigned to <code>Msg</code> and execution branches to the StartHere line label. This gives the user another chance to enter a valid path and file specification.</p>
<p>
Use the <b>Resume</b> <i>line</i> statement when you want to resume execution at a place other than the statement that caused the error, or the line immediately after the statement that caused the error. The <b>Resume</b> <i>line</i> statement can be especially useful if you want to exit the error-handling code and branch to a point just before an <b>Exit</b> statement in a <b>Function</b> or <b>Sub</b> procedure.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Although branching to a line label can be useful in some circumstances, jumps to labels are often considered throwbacks to a less structured style of programming. Too many <b>Resume</b> <i>line</i> statements can make code difficult to understand and debug.</p>
<h4>The Raise Method</h4>
<p>
The previous VerifyFile function also illustrates how to use the <b>Raise</b> method of the <b>Err</b> object to regenerate an unanticipated Visual Basic error within the error-handling routine itself. This causes Visual Basic to search backward through the calls list (if there is one) for error-handling code.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on this process, see the following section, “Unanticipated Errors.”</p>
<p>
If you haven’t included appropriate code to handle the error that has occurred, Visual Basic halts execution and displays an error message. The <b>Raise</b> method only returns descriptive strings for Visual Basic errors. If you use the <b>Raise</b> method to regenerate a Microsoft Access error, then you can use the <b>AccessError</b> method of the <b>Application</b> object to return a descriptive string for the error.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>AccessError</b> method, search the Help index for “AccessError method.”</p>
</FONT></FONT></BODY>
</HTML>
