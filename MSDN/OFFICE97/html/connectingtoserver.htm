<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Connecting to a Server</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="connectingtoserver"></a>Connecting to a Server</h2>
<p>
To access data on a remote server, your application must establish a connection. This connection creates a communication link to the server across the network. You can use any of the following methods to connect to a server:
<ul>
<li>
Link tables and SQL views from the server</li>
<li>
Use pass-through queries to send SQL statements straight to the server</li>
<li>
Directly access the server by using Visual Basic</li>
</ul>
<p>
This section describes each of these methods, as well as their respective time and memory requirements on both the client and the server.</p>
<h3>Linking Tables and SQL Views from a Server</h3>
<p>
The easiest and most common way to access data on a server is to link tables from the server. With few exceptions, you can use linked tables in your application just as you would Microsoft Access tables. Microsoft Access automatically connects to the server when you open a linked table.</p>
<p>
If your server supports SQL views, you can link them to your local database. An <i>SQL&nbsp;view</i> is a virtual table that is derived from other tables or previously defined views. It has a name, a list of attributes, and a query which define the contents of the view. Microsoft Access treats a linked view exactly like a linked table without indexes. The processing defined in a view is always performed by the server.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To link a table or an SQL view from a server</b></p>
<p>
In your Visual Basic code, create an ODBC connection string that references the data source you set up with the ODBC Data Source Administrator. Assign the connection string to a variable.
<ol>
<li>
Create a new <b>TableDef</b> object and set its <b>Connect</b> property to the variable you created in step 1.</li>
<li>
Append the <b>TableDef</b> object to the <b>TableDefs</b> collection to link the table or SQL view to your Microsoft Access database.</li>
<li>
Open a <b>Recordset</b> object on the linked table or SQL view. You can use the properties and methods of the <b>Recordset</b> object to manipulate the data in the ODBC data source.</li>
</ol>
<p>
The following example uses the Pubs sample database included with Microsoft SQL Server to link the Authors table, and counts the number of authors whose phone number begins with the area code that is passed as an argument to the function.</p>
<pre><code>Function CountByAreaCode(strAreaCode As String) As Long
&#09;Dim dbs As Database, rst As Recordset
&#09;Dim strConnect As String, tdf As TableDef
&#09;Dim lngCount As Long

&#09;strConnect = &quot;ODBC;DSN=Pubs;UID=SA;PWD=;DATABASE=Pubs&quot;

&#09;Set dbs = OpenDatabase(&quot;C:\data\cs.mdb&quot;)

&#09;' Delete any existing links named LinkedAuthors.
&#09;On Error Resume Next
&#09;dbs.TableDefs.Delete &quot;LinkedAuthors&quot;
&#09;dbs.TableDefs.Refresh

&#09;On Error GoTo ErrorHandler

&#09;' Create a TableDef and set its Connect property.
&#09;Set tdf = dbs.CreateTableDef(&quot;LinkedAuthors&quot;)
&#09;tdf.Connect = strConnect
&#09;' Specify the table to access within the Pubs database.
&#09;tdf.SourceTableName = &quot;Authors&quot;
&#09;dbs.TableDefs.Append tdf
&#09;dbs.TableDefs.Refresh

&#09;' Open a recordset on the linked table.
&#09;Set rst = dbs.OpenRecordset(&quot;LinkedAuthors&quot;, dbOpenForwardOnly)

&#09;' Count number of authors whose phone number begins with specified area code.
&#09;Do Until rst.EOF
&#09;&#09;If Left$(rst!phone, 3) = strAreaCode Then
&#09;&#09;&#09;lngCount = lngCount + 1
&#09;&#09;End If
&#09;&#09;rst.MoveNext
&#09;Loop
&#09;rst.Close
&#09;dbs.Close
&#09;CountByAreaCode = lngCount
&#09;Exit Function

ErrorHandler:
&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Err.Description
&#09;Exit Function
End Function
</code></pre>
<p>
In this example, the Authors <b>Recordset</b> object is opened as a forward-only-type <b>Recordset</b> object to optimize performance. Because forward-only-type <b>Recordset</b> objects are snapshots, you cannot update data in them. If you want to be able to update data in the recordset, open it as a dynaset-type <b>Recordset</b> object by using the <b>dbOpenDynaset</b> constant with the <b>OpenRecordset</b> method.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Although you can update information in ODBC databases by using update queries or dynaset-type <b>Recordset</b> objects, you should consider using a pass-through query, which is usually much more efficient. For more information on pass-through queries, see the next section “Using Pass-Through Queries.”</p>
<p>
Microsoft Access stores field and index information for the tables you link, which improves performance when you open the tables. Relink remote tables if you change their structure or the structure of their indexes on the server.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on relinking tables, search the Help index for “RefreshLink method.”</p>
<p>
<img src="abac19_1.gif" border=0></p>
<p>
Tip   When you link a table from a server, you usually have the option of storing your server password in the local database so that you don’t have to type it each time you start the application. However, if you don’t want users to have this option when they link tables, you can disable the feature. For more information, search the Help index for “MSysConf table.”</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on linking remote tables and creating connection strings, see Chapter 18, <a href="accessingexternaldata.htm">“Accessing External Data.”</a> For general information on linking, search the Help index for “tables, linking.”</p>
<h4>Creating Indexes on Linked SQL Views</h4>
<p>
If your server allows you to update data by using SQL views and you want to take advantage of this updatability in Microsoft Access, you need to create a <i>pseudo index</i> on the linked view. This index tells Microsoft Access the field or fields that make up the primary key for a record returned by the view—the field or fields that uniquely identify the record. Microsoft Access can then create an updatable dynaset on the view, which forms and queries can use to view and update data.</p>
<p>
For example, suppose you link an SQL view named SeptOrdersView that returns a subset of records in the remote Orders table, and you name the linked view SeptemberOrders. Because the OrderID field is still unique within the view, you would use a data-definition query to create the index by running the following SQL statement:</p>
<pre><code>CREATE UNIQUE INDEX index1 ON SeptemberOrders (OrderID)
</code></pre>
<p>
This doesn’t create a real index on the server or in your local database, nor does it take up much space locally. It simply tells Microsoft Access that the OrderID field is the primary key for the linked view.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on data-definition queries, search the Help index for “data-definition queries.”</p>
<h3>Using Pass-Through Queries</h3>
<p>
The second way to access data on a server is to use <i>pass-through queries</i>. Pass-through queries are SQL statements that are sent directly to a database server without interpretation by Microsoft Access. You can use pass-through queries in your application to directly manipulate the features of a database server that may or may not be supported by Microsoft Access.</p>
<p>
In many applications, you’ll use both ordinary Microsoft Access queries based on remote tables and pass-through queries. When you use an ordinary query to retrieve information from the tables on your database server, Microsoft Access compiles and runs the query, combining the power of the server with the capabilities of the Microsoft Jet database engine. With a pass-through query, you create an SQL statement that Microsoft Access sends directly to the server without stopping to compile the query.</p>
<p>
Pass-through queries offer the following advantages over ordinary Microsoft Access queries:
<ul>
<li>
You don’t need to consider how much of your pass-through query is being sent to the server for processing because the query is sent without modifications. This means that more processing occurs on the server and less traffic is generated over the network.</li>
<li>
Pass-through queries can use server-specific functionality—such as stored procedures and server-based intrinsic functions—that have no Visual Basic equivalent.</li>
<li>
Pass-through queries can log informational messages returned by the server, such as errors, warnings, and statistics.</li>
<li>
With pass-through queries, you can use nonstandard SQL extensions, as well as data-definition, server administration, and security commands that are supported by the server.</li>
<li>
Use a pass-through query if you want to join tables from different databases on a server (if the server supports multiple databases). Because each database is a separate ODBC data source, an ordinary query would consider the join to be heterogeneous and would run at least part of the query locally.<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on heterogeneous joins, see “Heterogeneous Joins” later in this chapter.</p>
</li>
<li>
Bulk update, delete, and append pass-through action queries are faster than action queries based on linked remote tables, especially when many records are affected. In addition, a pass-through action query cannot partially succeed as an ordinary action query can.</li>
</ul>
<p>
On the other hand, pass-through queries do have several disadvantages:
<ul>
<li>
A pass-through query always returns a snapshot, which can’t be updated. An ordinary query usually returns a dynaset, which reflects other users’ changes and can be updated.</li>
<li>
When you design pass-through queries, you type the commands directly into the SQL Pass-Through Query window. In contrast, when you design ordinary queries, you use the graphical query design grid.</li>
<li>
To create a pass-through query, you must know the exact SQL syntax supported by your server. SQL syntax and conventions often vary from server to server, particularly outer-join syntax, intrinsic function names, wildcard characters, and the use of single versus double quotation marks. All ordinary Microsoft Access queries use the same syntax, regardless of where the data is stored. Microsoft Access automatically translates Visual Basic intrinsic function names, wildcard characters, and other elements into the appropriate ODBC syntax.</li>
<li>
You can’t call user-defined functions in a pass-through query, but ordinary queries can use them as if they were intrinsic Visual Basic functions.</li>
<li>
You can add parameters to an ordinary query, causing Microsoft Access to automatically prompt the user for the parameter value. (Alternatively, the value can be supplied from a form control.) In contrast, you can’t add parameters to pass-through queries.</li>
</ul>
<h4>Creating Pass-Through Queries</h4>
<p>
Pass-through queries consist of an SQL statement and an ODBC connection string. The SQL statement is interpreted only by the database server and must follow the server’s SQL language specification. The SQL statement cannot contain any Microsoft Access–specific elements or any Visual Basic functions or commands.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on connection strings, see Chapter 18, <a href="accessingexternaldata.htm">“Accessing External Data.”</a></p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To create a pass-through query</b>
<ol>
<li>
Create a <b>QueryDef</b> object by using the <b>CreateQueryDef</b> method. Specify only the <i>name </i>argument for the query. If you want to create a temporary <b>QueryDef</b> object, specify a zero-length string (&quot;&quot;) for the <i>name </i>argument.</li>
<li>
Set the <b>Connect</b> property of the <b>QueryDef</b> object to a valid connection string. <p>
Important   Always set the <b>Connect</b> property before you set the <b>SQL</b> property so that Microsoft Jet passes the query directly to the ODBC data source without processing it. </p>
</li>
<li>
Set the <b>SQL</b> property of the <b>QueryDef</b> object to an SQL statement that is compatible with the ODBC data source you are querying.</li>
<li>
If your query is an action query that does not return a recordset, set the <b>ReturnsRecords</b> property of the <b>QueryDef</b> object to <b>False</b> and use the <b>Execute</b> method to run the query. Otherwise, set the <b>ReturnsRecords</b> property to <b>True</b> and run the query by opening a recordset on the stored query definition.</li>
</ol>
<p>
The following example sends three pass-though action queries to the Pubs sample database included with Microsoft SQL Server. The first query creates a new table called sales_archive with the same structure as the Sales table in the Pubs database. The second query appends all of the sales records that were created before 1993 from the Sales table to the sales_archive table. The third query deletes all of the sales records created before 1993 from the Sales table.</p>
<pre><code>Sub ArchiveSales()
&#09;Dim dbs As Database, qdf As QueryDef
&#09;Dim strConnect As String
&#09;Dim strSQL As String

&#09;On Error GoTo ErrorHandler

&#09;Set dbs = CurrentDb
&#09;strConnect = &quot;ODBC;DSN=Pubs;UID=sa;PWD=;DATABASE=Pubs&quot;
&#09;Set qdf = dbs.CreateQueryDef(&quot;&quot;)
&#09;qdf.Connect = strConnect

&#09;strSQL = &quot;CREATE TABLE sales_archive (stor_id char (4) &quot;
&#09;strSQL = strSQL &amp; &quot;NOT NULL, ord_num varchar (20) NOT NULL, &quot;
&#09;strSQL = strSQL &amp; &quot;ord_date datetime NOT NULL, &quot;
&#09;strSQL = strSQL &amp; &quot;qty smallint NOT NULL, &quot;
&#09;strSQL = strSQL &amp; &quot;payterms varchar (12) NOT NULL, &quot;
&#09;strSQL = strSQL &amp; &quot;title_id tid NOT NULL)&quot;

&#09;qdf.ReturnsRecords = False

&#09;qdf.SQL = strSQL
&#09;qdf.Execute

&#09;qdf.SQL = &quot;INSERT INTO sales_archive SELECT * FROM sales WHERE ord_date &lt; '1/1/93'&quot;
&#09;qdf.Execute

&#09;qdf.SQL = &quot;DELETE FROM sales WHERE ord_date &lt; '1/1/93'&quot;
&#09;qdf.Execute

&#09;Exit Sub

ErrorHandler:
&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Err.Description
&#09;Exit Sub
End Sub
</code></pre>
<p>
In the previous example, the <b>ReturnsRecords</b> property is set to <b>False</b> because all three queries are action queries. The following example uses a pass-through query to return records. It returns all sales records in the Pubs sample database for the year 1994.</p>
<pre><code>Dim dbs As Database, qdf As QueryDef
Dim strConnect As String, rst As Recordset
Dim strSQL As String

Set dbs = CurrentDb
strConnect = &quot;ODBC;DSN=Pubs;UID=SA;PWD=;DATABASE=Pubs&quot;
Set qdf = dbs.CreateQueryDef(&quot;94Sales&quot;)
qdf.Connect = strConnect
strSQL = &quot;SELECT * FROM sales WHERE ord_date BETWEEN &quot;
strSQL = strSQL &amp; &quot;'1/1/1994' AND '12/31/1994'&quot;
qdf.SQL = strSQL
qdf.ReturnsRecords = True

Set rst = dbs.OpenRecordset(&quot;94Sales&quot;, dbOpenSnapshot)

Do Until rst.EOF
&#09;Debug.Print rst!ord_date
&#09;rst.MoveNext
Loop
</code></pre>
<p>
Note<b> </b>  <b>Recordset</b> objects opened on a pass-through queries are always opened as snapshots and cannot be updated.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on pass-through queries, search the Help index for “pass-through queries.”</p>
<h4>Using Stored Procedures</h4>
<p>
In some environments, your access to server data is limited to a set of server-based stored procedures. You must carry out all data requests and updates through these stored procedures; you have no direct access to the remote tables. In such an environment, you use pass-through queries exclusively.</p>
<p>
Your server may have two sets of stored procedures defined: one to retrieve data and one to update data. If you don’t need to update data and only want to retrieve data, you can create a pass-through query for each stored procedure you want to call. You can then base other queries, forms, and reports on these queries as if they were linked tables.</p>
<p>
However, if you need to update data in this type of environment, you can collect the user’s input locally and then send the data to the server by running a pass-through query that calls the appropriate stored procedure. You may find either of the following two approaches helpful:
<ul>
<li>
Create a form based on a local holding table that temporarily stores records before they are sent to the server. Add code to the form’s AfterUpdate and AfterInsert event procedures that calls the data-updating stored procedures for each record in the holding table.</li>
<li>
Create an unbound form to collect data and add command buttons to the form for saving the data. You can then use the values in the form’s unbound controls when you call the data-updating stored procedures.</li>
</ul>
<p>
In either case, you need to write Visual Basic code to create a pass-through query that uses the name of the stored procedure and the values to be supplied from the form.</p>
<p>
If the stored procedure runs an action query, you can determine whether the stored procedure ran successfully by examining the first element of the <b>Fields</b> collection of the <b>Recordset</b> object that the stored procedure is based on. If the value is 0, then the procedure ran successfully. Otherwise, the procedure did not run successfully.</p>
<p>
For example, the following SQL Server stored procedure increases or decreases the royalty schedules in the Roysched table of the Pubs sample database included with Microsoft SQL Server. The amount of the increase or decrease is specified in the integer parameter named delta:</p>
<pre><code>CREATE PROCEDURE change_royalty @delta int AS UPDATE roysched
&#09;SET royalty = royalty + @delta
</code></pre>
<p>
The following function calls the change_royalty stored procedure in the Pubs sample database, examines the first element of the <b>Fields</b> collection, and returns 0 if the stored procedure ran successfully.</p>
<pre><code>Function intChangeRoyalty(intDelta As Integer) As Integer
&#09;Dim dbs As Database, qdf As QueryDef
&#09;Dim strConnect As String, rst As Recordset
&#09;Dim strSQL As String
&#09;On Error GoTo ErrorHandler
&#09;Set dbs = CurrentDb
&#09;strConnect = &quot;ODBC;DSN=Pubs;UID=sa;PWD=;DATABASE=Pubs&quot;
&#09;strSQL = &quot;declare @status int execute @status = change_royalty&quot;
&#09;strSQL = strSQL &amp; intDelta &amp; &quot; select 'return value' = @status&quot;
&#09;Set qdf = dbs.CreateQueryDef(&quot;&quot;)
&#09;qdf.Connect = strConnect
&#09;qdf.ReturnsRecords = True
&#09;qdf.SQL = strSQL
&#09;Set rst = qdf.OpenRecordset(dbOpenSnapshot)
&#09;' Examine the first element in the recordset's Fields collection.
&#09;' If it is 0, the stored procedure was successful.
&#09;If rst(0) = 0 Then 
&#09;&#09;intChangeRoyalty = 0 
&#09;Else
&#09;&#09;intChangeRoyalty = -1
&#09;End If
&#09;Exit Function

ErrorHandler:
&#09;MsgBox &quot;Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Err.Description
&#09;intChangeRoyalty = -1
&#09;Exit Function
End Function</code></pre>
<h3>Directly Accessing the Server</h3>
<p>
The third way to connect to a server is to access it directly in Visual Basic by using the <b>OpenDatabase</b> method with an ODBC connection string. This approach has several disadvantages, however. Although it’s possible to directly open snapshots and dynasets on a remote database, this is always much less efficient than using linked tables. When you link remote tables, Microsoft Jet caches locally a great deal of information about these tables, including field information, index information, and server capabilities. In contrast, when you access the remote tables directly, Microsoft Access has to ask the server for this information every time you run a query.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You’ll want to access the server directly when you preconnect. For information on preconnecting, see “Preconnecting” later in this chapter.</p>
</FONT></FONT></BODY>
</HTML>
