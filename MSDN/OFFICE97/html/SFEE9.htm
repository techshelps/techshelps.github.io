<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>xlSet</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>xlSet</H2><P CLASS="t">When you buy an airline ticket, you generally have to choose between a full-fare ticket with no restrictions and a much cheaper ticket with restrictions. The cheaper ticket might be nonrefundable or require a Saturday night stay.</P>
<P CLASS="t">Similarly, in Microsoft Excel there are two ways to enter information into cells. The usual way, available in the macro language, is to use the FORMULA function, called xlcFormula from C. This is the expensive, unrestricted way. It takes a long time, but you can put almost anything anywhere and, if you don't like&nbsp;the result, you can undo it by calling xlcUndo.</P>
<P CLASS="t">However, there is a much faster function called xlSet. It is available only from the&nbsp;C API, and comes with four restrictions:</P>
<UL><LI CLASS="ULI1">You can enter only constants, not formulas, into cells. This allows Microsoft Excel to skip recomputing the internal formula dependency tree.</LI><LI CLASS="ULI1">You cannot undo with the xlSet function. This saves time, since Microsoft Excel does not have to record the information required to undo the action.</LI><LI CLASS="ULI1">You are limited by the maximum array size in Microsoft Excel. Ranges larger than approximately 5,460 cells may fail.</LI><LI CLASS="ULI1">A function that is called from a worksheet cannot call xlSet. It is a command equivalent function. In other words if the function in the DLL was called as part of recalculation, xlSet will fail.</LI></UL><P></P>
<P CLASS="t">In spite of these restrictions, xlSet is very useful. In most database access scenarios, you need to write a large table of constant values into a rectangular range of cells. This can all be done with one call to Microsoft Excel.</P>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">Because xlSet is a command-equivalent function, it does not work in user-defined functions.</P>
<P></P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">The following code creates a large array and places it into the active sheet, in one&nbsp;step:</P>

<pre><code><FONT FACE="Courier" SIZE="2">int i,j;
static XLOPER rgx[10][10], xArray, xRef;
XLMREF xlmref;

if (xlretSuccess != Excel4(xlSheetId, &amp;xRef, 0))
    return;

xRef.xltype = xltypeRef;
xRef.val.mref.lpmref = (LPXLMREF) &amp;xlmref;
xlmref.count = 1;
xlmref.reftbl[0].rwFirst  = 0;
xlmref.reftbl[0].rwLast   = 9;
xlmref.reftbl[0].colFirst = 0;
xlmref.reftbl[0].colLast  = 9;

for (i=0; i&lt;10; i++)
{
    for (j=0; j&lt;10; j++)
    {
        rgx[i][j].xltype = xltypeNum;
        rgx[i][j].val.num = i * 10 + j;
    }
}

xArray.xltype = xltypeMulti;
xArray.val.array.lparray = (LPXLOPER) &amp;rgx;
xArray.val.array.rows = xArray.val.array.columns = 10;

Excel4(xlSet, 0, 2, (LPXLOPER) &amp;xRef, (LPXLOPER) &amp;xArray);
</FONT></code></pre>
<P CLASS="t">By using xlCoerce and xlSet, you can speed up data transfer dramatically.</P></FONT>
</FONT></BODY></HTML>
