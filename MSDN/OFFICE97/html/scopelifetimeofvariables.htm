<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Scope and Lifetime of Variables</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="scopelifetimeofvariables"></a>Scope and Lifetime of Variables</h2>
<p>
When you declare a variable within a procedure, only code within that procedure can read or change the value of that variable: Its <i>scope</i> is local to that procedure. Sometimes, however, you want to use a variable with a broader scope, one whose value is available to all procedures within the same module, or even to all the procedures in all modules. With Visual Basic, you can specify the scope of a variable when you declare it.</p>
<h3>Scope of Variables</h3>
<p>
Depending on how you declare a variable, it’s either a procedure-level or a module-level variable.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Scope</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Private</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Public</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
Procedure-level</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Variables are private to the procedure in which they appear.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Not applicable. You can’t declare public variables within a procedure.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
Module-level</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Variables are private to the module in which they appear.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Variables are available to all modules.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
</table>
<h4>Variables Used Within a Procedure</h4>
<p>
Procedure-level variables are recognized only in the procedure in which they’re declared. These are also known as <i>local</i> variables. You declare them with the <b>Dim</b> or <b>Static</b> keywords, as follows: </p>
<pre><code>Dim intTemp As Integer

Static intPermanent As Integer
</code></pre>
<p>
Local variables declared with the <b>Dim</b> keyword exist only as long as the procedure is running. Local variables declared with the <b>Static</b> keyword exist the entire time your application is running. </p>
<p>
Because of the advantages they provide, consider using local variables for any kind of temporary calculation. For example, you can create a dozen different procedures containing a variable called <code>intTemp</code>. As long as each <code>intTemp</code> is declared as a local variable, each procedure recognizes only its own version of <code>intTemp</code>. Any one procedure can alter the value in its local <code>intTemp</code> without affecting <code>intTemp</code> variables in other procedures.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Implicitly declared variables always have a local scope.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on procedures, see Chapter 2, <a href="introducingvisualbasic.htm">“Introducing Visual Basic.”</a></p>
<h4>Variables Used Within a Module</h4>
<p>
By default, a module-level variable is available to all the procedures in that module, but not to code in other modules. You create module-level variables in form, report, and standard modules by declaring them with the <b>Dim</b> or <b>Private</b> keywords in the Declarations section at the top of the module. For example, use either of the following statements:</p>
<pre><code>Dim intTemp As Integer

Private intTemp As Integer
</code></pre>
<p>
At the module level, there is no difference between <b>Private</b> and <b>Dim</b>. However, using <b>Private</b> is recommended because it readily contrasts with <b>Public</b> and makes your code easier to read.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on modules, see Chapter 2, <a href="introducingvisualbasic.htm">“Introducing Visual Basic.”</a></p>
<h4>Variables Used by All Modules</h4>
<p>
To make a module-level variable available to other modules, use the <b>Public</b> keyword to declare the variable. (The <b>Public</b> statement has replaced the <b>Global</b> statement used for declaring variables in Microsoft Access version 2.0.) The values in public variables are available to all procedures in all modules in your application. Like all module-level variables, public variables are declared in the Declarations section at the top of the module, as shown in the following example:</p>
<pre><code>Public intX As Integer
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;You can’t declare public variables within a procedure.</p>
<p>
In a form, report, or standard module, if you want to refer to a public variable in a different form or report module, you must qualify the reference by using the name of the form or report, such as <code>Forms!Orders.intX</code>.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on form and report modules, see Chapter 2, <a href="introducingvisualbasic.htm">“Introducing Visual Basic.”</a></p>
<p>
You can declare public variables in any module. Generally speaking, each public variable should be located in the module of which it’s a logical member. However, if you have public variables that are used for purely global purposes and are not specifically related to a particular module, you can put them all in one module. This makes the variables easier to find and your code easier to read.</p>
<h4>Scope and Variable Names</h4>
<p>
A variable can’t change scope while your code is running. However, you can use the same name for different variables under certain conditions. </p>
<p>
If public variables in different modules share the same name, it’s possible to differentiate between them in code. For example, if a public <b>Integer</b> variable <code>intX</code> is declared in both of the standard modules Module1 and Module2, you can refer to them as <code>Module1.intX</code> and <code>Module2.intX</code> to get the correct values.</p>
<h5>Public vs. Local Variables</h5>
<p>
You can also have a variable with the same name at a different scope. For example, you could have a public variable named <code>intX</code> and then, within a procedure, declare a local variable named <code>intX</code>. References to the name <code>intX</code> within the procedure would access the local variable, while references to <code>intX</code> outside the procedure would access the public variable. The module-level variable can be accessed from within the procedure by qualifying the variable with the module name.</p>
<pre><code>' This code is in the form module for Form1. Within the Test Sub
' procedure, the name intX always refers to the local variable, not
' to the variable declared in the Public statement at the top.

Public intX As Integer

Sub Test()
&#09;Dim intX As Integer

&#09;intX = 2&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' intX has a value of 2 (even though
&#09;MsgBox Forms!Form1.intX&#09;&#09;&#09;&#09;' MsgBox shows the value of intX in
End Sub&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Form1, which is 1).

Private Sub Form_Load()
&#09;intX = 1
End Sub 

Private Sub Command1_Click()
&#09;Test&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' intX has a value of 2.
End Sub
</code></pre>
<p>
In general, when variables have the same name but a different scope, the more local variable <i>shadows</i> (is accessed in preference to) less local variables. So, if you also had a private module-level variable named <code>intX</code>, it would shadow the public variable <code>intX</code> within that module (and the local <code>intX</code> would shadow the private module-level <code>intX</code> within that procedure).</p>
<h5>Using Variables and Properties with the Same Name</h5>
<p>
Shadowing rules treat form and report properties and controls, user-defined types, constants, and procedures as module-level variables in the form or report module. Thus, all module-level shadowing rules apply to each of these. You can’t have a form or report property or control with the same name as a module-level variable, constant, user-defined type, or procedure because both are in the same scope.</p>
<p>
Within the form or report module, local variables with the same names as controls on the form or report shadow the controls. You need to either qualify the control with a reference to the form or report, or you need to use the <b>Me</b> keyword to set or get its value or any of its properties. The following code shows one way to do this:</p>
<pre><code>Private Sub Form_Click()
&#09;Dim Text1, Caption

&#09;' Assume there is also a control on the form called Text1.
&#09;Text1 = &quot;Variable&quot;&#09;&#09;&#09;&#09;' Variable shadows control.
&#09;Me.Text1 = &quot;Control&quot;&#09;&#09;&#09;' Must qualify with Me to get control.
&#09;Text1.Top = 0&#09;&#09;&#09;&#09;&#09;' This causes an error!
&#09;Me.Text1.Top = 0&#09;&#09;&#09;&#09;' Must qualify with Me to get control.
&#09;Caption = &quot;Orders&quot;&#09;&#09;&#09;&#09;' Variable shadows property.
&#09;Me.Caption = &quot;Orders&quot;&#09;&#09;&#09;' Must qualify with Me to get form property.
End Sub
</code></pre>
<h5>Using Variables and Procedures with the Same Name</h5>
<p>
You may also have conflicts with the names of your private module-level and public module-level variables and the names of your procedures. A variable in the module can’t have the same name as any procedures or types defined in the module. It can, however, have the same name as public procedures, types, or variables defined in other modules. In this case, when the variable is accessed from another module, it must be qualified with the module name.</p>
<p>
While these shadowing rules are not complex, shadowing can be confusing and lead to subtle problems in your code. To avoid these problems, it’s good programming practice to keep the names of your variables distinct from each other. For example, in form or report modules, try to have unique names for properties that are different from names of controls on those forms or reports. This applies to procedure names as well.</p>
<h3>Lifetime of Variables</h3>
<p>
In addition to scope, variables also have a <i>lifetime</i>, which is the time during which a variable retains its value. The values in module-level and public variables are preserved as long as the database is open (unless you reinitialize your code). This is true for form and report module-level variables even if you close the form or report. However, local variables declared with the <b>Dim</b> keyword exist only while the procedure in which they are declared is running. Usually, when a procedure has finished, the values of its local variables are discarded and the memory used by the local variables is reclaimed. The next time the procedure is run, all of its local variables are reinitialized. However, you can make Visual Basic preserve the value of a local variable by making the variable <i>static</i>.</p>
<h4>Static Variables</h4>
<p>
To make a local variable in a procedure static, use the <b>Static</b> keyword to declare the variable exactly as you would using the <b>Dim</b> statement.</p>
<pre><code>Static intX As Integer
</code></pre>
<p>
For example, the following function calculates a running total by adding a new value to the total of previous values stored in the static variable <code>dblAccumulate</code>.</p>
<pre><code>Function RunningTotal(ByVal dblNum As Double) As Double
&#09;Static dblAccumulate As Double

&#09;dblAccumulate = dblAccumulate + dblNum
&#09;RunningTotal = dblAccumulate
End Function
</code></pre>
<p>
If you declare <code>dblAccumulate</code> with the <b>Dim</b> keyword instead of the <b>Static </b>keyword, the previous accumulated values aren’t preserved across calls to the function, and the function simply returns the value with which it was called.</p>
<p>
You can produce the same result by declaring <code>dblAccumulate</code> in the Declarations section of the module, making it a module-level variable. However, after you change the scope of a variable in this way, the procedure no longer has exclusive access to that variable. If other procedures access the value of the variable and change it, the running totals would be unreliable.</p>
<h4>Declaring All Local Variables as Static</h4>
<p>
To make all local variables in a procedure static, place the <b>Static</b> keyword at the beginning of a procedure declaration, as shown in the following example:</p>
<pre><code>Static Function RunningTotal(ByVal dblNum As Double) As Double
</code></pre>
<p>
This makes all the local variables in the procedure static, regardless of whether they are declared with the <b>Static</b> or <b>Dim</b> keywords, or declared implicitly. You can place the <b>Static</b> keyword in front of any <b>Function</b> or <b>Sub</b> procedure heading, including event procedures and those that are also declared as <b>Private</b>.</p>
</FONT></FONT></BODY>
</HTML>
