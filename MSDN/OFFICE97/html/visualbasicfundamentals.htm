<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual Basic Fundamentals</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="visualbasicfundamentals"></a>Visual Basic Fundamentals</h2>
<p>
In a simple application, you may need to use Visual Basic only to create event procedures and simple functions, as shown in the previous sections. However, as your applications get larger and more sophisticated, you’ll want to use the full power of the Visual Basic language. This section lays out the fundamental rules for writing Visual Basic code in Microsoft Access.</p>
<h3>Standard Modules and Class Modules</h3>
<p>
You store your Visual Basic code in <i>modules</i> in a Microsoft Access database. Modules provide a way to organize your procedures.</p>
<p>
Your database can contain two types of modules:
<ul>
<li>
<b>Standard modules</b>   You use standard modules to store code you may want to run from anywhere in the application. You can call public procedures in standard modules from expressions, macros, event procedures, or procedures in other standard modules.</li>
</ul>
<p>
To create a new standard module, you can either click <b>New</b> on the <b>Modules</b> tab in the Database window, or you can click <b>Module</b> on the <b>Insert</b> menu.</p>
<p>
<img src="abac02_23.gif" border=0>
<ul>
<li>
<b>Class modules</b>   You use class modules to create your own custom objects. The <b>Sub</b> and <b>Function</b> procedures that you define in a class module become methods of the custom object. The properties you define with the <b>Property Get</b>, <b>Property</b> <b>Let</b>, and <b>Property Set</b> statements become properties of the custom object.</li>
</ul>
<p>
To create a new class module, click <b>Class Module</b> on the <b>Insert</b> menu. Saved class modules appear on the <b>Modules</b> tab in the Database window with saved standard modules. You can distinguish an open class module from an open standard module by the title bar of the Module window—the title bar for a class module always includes the label Class Module.</p>
<p>
Each form and report in your database can contain an associated form module or report module. Form and report modules are also class modules, but you can’t save them separate from the form or report that they belong to. The class module that is associated with a form is especially useful because you can use it to create multiple instances of a form.</p>
<p>
Most frequently, you’ll use a form or report module to contain event procedures associated with the form or report. Each module can also contain other procedures that belong to the form or report. And, as with other class modules, you can use the <b>Property Get</b>, <b>Property Let</b>, and <b>Property Set</b> statements to create custom properties for the form or report.</p>
<p>
A form or report module is part of the form or report’s design. Thus, if you copy a form or report to another database, its module goes with it; if you delete a form or report, its module is deleted as well. Microsoft Access creates the form or report module automatically when you first add Visual Basic code to the form or report. All you need to do is write the event procedures and other procedures you want to store in the module.</p>
<p>
Note that a form or report doesn't have a module associated with it when it’s first created. These <i>lightweight</i> forms and reports typically load and display faster than forms or reports with modules. However, once you add any Visual Basic code to the form or report, the form or report module is automatically created. You can use the <b>HasModule</b> property to specify or determine if a form or report has an associated module.</p>
<p>
<img src="abac02_24.gif" border=0></p>
<h3>What’s In a Module?</h3>
<p>
A module can contain:
<ul>
<li>
<b>Declarations</b>   These are statements that define variables, constants, user-defined types, and external procedures. The Declarations section of a module is separate from the procedures, and declarations in this section apply to every procedure in the module. You can also define variables and constants within a procedure, in which case they apply only to the procedure they’re in.</li>
<li>
<b>Event procedures</b>   These are <b>Sub</b> procedures that apply to a specific object; they run in response to a user or system event, such as a mouse click. Event procedures are always stored with a form or report in the form or report module.</li>
<li>
<b>General procedures</b>   These are procedures that aren’t directly associated with an object or event. You can include general procedures in a standard module or a class module. General procedures can be either <b>Sub</b> procedures (procedures that don’t return a value) or <b>Function</b> procedures (procedures that do return a value).</li>
</ul>
<h3>Event Procedures</h3>
<p>
When Microsoft Access recognizes that an event has occurred on a form, report, or control, it automatically runs the event procedure named for the object and event. If you want to run code in response to a particular event, you add code to the event procedure for that event.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on the Microsoft Access event model, see Chapter 6, <a href="respondingtoevents.htm">“Responding to Events.”</a> For more information on all events, search the Help index for “events.”</p>
<p>
When you create an event procedure (by using the procedures described earlier in this chapter), Microsoft Access automatically creates a code template for the event and adds it to the form or report module. The name of an event procedure for a form or report is a combination of the word “Form” or “Report,” an underscore (_), and the event name. For example, if you want a form to run an event procedure when it’s clicked, use the procedure Form_Click. </p>
<p>
An event procedure for a control uses the same naming convention. For example, if you want a command button named MyButton to run an event procedure when it’s clicked, use the procedure MyButton_Click. If a control name contains characters other than numbers or letters, such as spaces, Microsoft Access replaces those characters with an underscore (_) in any event procedures for the control.</p>
<p>
Important   If you want to change the names of your controls, it’s a good idea to do so before you start writing event procedures for them. If you change the name of a control after attaching a procedure to it, you also must change the name of the procedure to match the control’s new name. Otherwise, Visual Basic can’t match the control to the procedure. When a procedure name doesn’t match a control name, Microsoft Access makes it a general procedure. You can find general procedures in the Module window by clicking <b>(General)</b> in the <b>Object</b> box, and then clicking the procedure name in the <b>Procedure</b> box.</p>
<h3>General Procedures</h3>
<p>
Microsoft Access runs event procedures in response to a particular event on a form, report, or control. A general procedure, in contrast, runs only when you explicitly call it. A function, for example, is a type of general procedure.</p>
<p>
Why use general procedures? One reason is to create your own functions to automate tasks you perform frequently. For example, you can create a function and then either create a custom menu command or custom toolbar button that runs the function, or use the function in an expression.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on customizing your menus and toolbars, see Chapter 1, <a href="creatingapplication.htm">“Creating an Application.”</a> For information on using functions in expressions, search the Help index for “expressions.”</p>
<p>
Another reason to use general procedures is that you may want several different event procedures to perform the same actions. A good programming strategy is to put common code in a separate general procedure and have event procedures call it. This eliminates the need to duplicate code, making the application easier to maintain.</p>
<p>
You can create general procedures either in a class module (which can be a form or report module) or in a standard module. If you want a general procedure that’s always available from anywhere in your application, place it in a standard module. If a procedure applies primarily to a specific form or report, place it in the module for that form or report.</p>
<h3>Creating and Calling Procedures</h3>
<p>
This section explains the syntax you use to create and call procedures in your application. Procedures can be either <b>Sub</b> procedures or <b>Function</b> procedures:
<ul>
<li>
<b>Sub</b> procedures perform operations, but they don’t return a value and can’t be used in expressions. <b>Sub</b> procedures can accept arguments. An event procedure is a <b>Sub</b> procedure that’s attached to a form or report. When Microsoft Access recognizes that an event has occurred on a form, report, or control, it automatically runs the event procedure named for the object and event. For example, you can write an event procedure that sets the focus to a specified control when the user exits another control. </li>
<li>
<b>Function</b> procedures return a value, such as the result of a calculation. Because they return values, <b>Function</b> procedures can be used in expressions. Like <b>Sub</b> procedures, <b>Function</b> procedures can accept arguments. For example, you can write a function that calculates the first day of the month that follows a date you pass the function in an argument. Then you can use that function in an expression on a form or report. </li>
</ul>
<h4>Sub Procedures</h4>
<p>
The syntax for a <b>Sub</b> procedure is:</p>
<p>
[<b>Private|Public</b>]<b> </b>[<b>Static</b>] <b>Sub</b> <i>procedurename</i> [(<i>arguments</i>)]</p>
<p>
&#09;<i>statements</i></p>
<p>
<b>End Sub</b></p>
<p>
The <i>statements</i> are the Visual Basic statements that make up the code you want to run each time the procedure is called. The <i>arguments</i> are argument names, separated by commas if there are more than one. Each argument looks like a variable declaration and acts like a variable in the procedure. The syntax for each argument is:</p>
<p>
[<b>Optional</b>] [<b>ByVal</b>] <i>variablename</i> [( )] [<b>As</b> <i>type</i>]</p>
<p>
<i>Type</i> can be any of the fundamental data types: <b>Byte</b>, <b>Integer</b>, <b>Long</b>, <b>Single</b>, <b>Double</b>, <b>Currency</b>,<b> Decimal</b>, <b>String</b>, <b>Boolean</b>, <b>Date</b>, <b>Object</b>, or <b>Variant</b>. If you don’t provide a type, the argument takes the <b>Variant</b> type and can contain any kind of data. Parentheses after <i>variablename</i> indicate that the argument is an array.</p>
<p>
By default, arguments to a procedure are passed by reference, meaning that changing the value of the variable changes it in the calling procedure as well. To pass arguments by value rather than by reference, use the <b>ByVal </b>keyword.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on the <b>Optional</b> keyword, see “Using a Variable Number of Arguments” later in this chapter. For information on the<b> Static </b>and<b> Private </b>keywords, search the Help index for “Sub statement.” For information on passing arguments by value or by reference, see “Argument Data Types” in Chapter 4, “Working with Variables, Data Types, and Constants.”</p>
<p>
When you call a <b>Sub</b> procedure, you specify the arguments you want the procedure to use. For example, the following <b>Sub</b> procedure makes a beep sound the number of times you specify with the <i>intBeeps</i> argument.</p>
<pre><code>Sub MultiBeep(intBeeps As Integer)

&#09;Dim intX As Integer, lngY As Long

&#09;For intX = 1 To intBeeps
&#09;&#09;Beep
&#09;&#09;For lngY = 1 To 100000&#09;&#09;&#09;&#09;' Short delay between beeps.
&#09;&#09;Next lngY
&#09;Next intX
End Sub
</code></pre>
<p>
The following statement calls the MultiBeep <b>Sub</b> procedure by using an <i>intBeeps</i> argument of 3, making a beep sound three times.</p>
<pre><code>MultiBeep 3
</code></pre>
<p>
You don’t enclose arguments in parentheses when you call a <b>Sub</b> procedure, as you do when you declare one, unless you use the <b>Call</b> statement to call the procedure, in which case the parentheses are required.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;To make your code more readable, you can pass arguments to <b>Sub</b> or <b>Function</b> procedures by name. For example, the following call to the MultiBeep <b>Sub</b> procedurepasses the <i>intBeeps</i> argument by name:</p>
<pre><code>MultiBeep intBeeps:=3
</code></pre>
<p>
When you pass multiple arguments by name, you can include them in any order you want. For more information on passing arguments by name, search the Help index for “named arguments.”</p>
<h4>Function Procedures</h4>
<p>
The syntax for a <b>Function</b> procedure is:</p>
<p>
[<b>Private|Public</b>]<b> </b>[<b>Static</b>] <b>Function</b> <i>procedurename</i> [(<i>arguments</i>)] [<b>As</b> <i>type</i>]</p>
<p>
&#09;<i>statements</i></p>
<p>
<b>End Function</b></p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on the<b> Static </b>and<b> Private </b>keywords, search the Help index for “Function statement.”</p>
<p>
The arguments for a <b>Function</b> procedure work in exactly the same way as the arguments for a <b>Sub</b> procedure, and have the same syntax. <b>Function</b> procedures differ from <b>Sub</b> procedures in three ways:
<ul>
<li>
You enclose arguments in parentheses both when declaring and when calling a <b>Function</b> procedure.</li>
<li>
<b>Function</b> procedures, like variables, have data types that determine the type of the return value.</li>
<li>
You return a value by assigning it to the <i>procedurename</i> itself. The value returned by the <b>Function</b> procedure can then be used as part of a larger expression.</li>
</ul>
<p>
For example, you could write a <b>Function</b> procedure that calculates the third side, or hypotenuse, of a right triangle given the other two sides.</p>
<pre><code>Function Hypotenuse (dblA As Double, dblB As Double) As Double
&#09;Hypotenuse = Sqr(dblA ^ 2 + dblB ^ 2)
End Function
</code></pre>
<p>
You call a <b>Function</b> procedure the same way you call any of the built-in functions in Visual Basic. For example:</p>
<pre><code>dblResult = Hypotenuse(dblWidth, dblHeight)
</code></pre>
<p>
<img src="abac02_25.gif" border=0></p>
<p>
Tip   If you aren’t interested in the result of a <b>Function</b> procedure, you can call it without including parentheses or assigning it to a variable, as you would a <b>Sub</b> procedure. For example, you can use the following code to call a function called DisplayForm and ignore its return value:</p>
<pre><code>DisplayForm strMessage
</code></pre>
<h4>Using a Variable Number of Arguments</h4>
<p>
You can declare optional arguments in a procedure definition with the <b>Optional</b> keyword. An optional argument is one that doesn’t have to be passed every time you call the procedure. You must declare optional arguments after any required arguments in the argument list. They can be of any type.</p>
<p>
If you include an optional argument in a procedure definition, then you need to consider what happens in the procedure when the argument is not passed. You can initialize an optional argument to a default value when you declare the argument, so that if the optional argument is not included when the procedure is called, the default value is used. If you don’t initialize the argument to a default value, Microsoft Access initializes it as it would initialize a variable of that type. If the argument is a number type, then it is initialized to zero. If it is a string, then it is initialized to a zero-length string (&quot;&quot;).</p>
<p>
In the following example, if a value is not passed for the optional argument, this argument is assigned the default value of 100.</p>
<pre><code>Sub DisplayError(strText As String, Optional intNumber As Integer = 100)
&#09;If intNumber = 100 Then
&#09;&#09;MsgBox strText
&#09;Else
&#09;&#09;MsgBox intNumber &amp; &quot;: &quot; &amp; strText
&#09;End If
End Sub
</code></pre>
<p>
You can call the procedure with either of the following lines of code.</p>
<pre><code>DisplayError &quot;Invalid Entry&quot;
DisplayError &quot;Invalid Entry&quot;, 250
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;If an optional argument is of type <b>Variant</b>, then you can use the <b>IsMissing</b> function to determine whether an optional argument was included when the procedure was called. The <b>IsMissing</b> function only works with arguments of type <b>Variant</b>.</p>
<p>
To write a procedure that accepts an arbitrary number of arguments, use the <b>ParamArray</b> keyword to pass an array of arguments with the <b>Variant</b> data type. With the <b>ParamArray</b> keyword, you can write functions like Sum, which calculates the sum of an arbitrary number of arguments.</p>
<pre><code>Function Sum(ParamArray varNumbers() As Variant) As Double

&#09;Dim dblTotal As Double, var As Variant

&#09;For Each var In varNumbers
&#09;&#09;dblTotal = dblTotal + var
&#09;Next var
&#09;Sum = dblTotal
End Function
</code></pre>
<p>
You can call the Sum function with the following line of code.</p>
<pre><code>dblSum = Sum(1, 3, 5, 7, 8)
</code></pre>
<h4>Calling Procedures from Other Modules</h4>
<p>
Unless you specify otherwise, general procedures you create are <i>public</i>, meaning that you can call them from anywhere in your application.</p>
<p>
<img src="abac02_26.gif" border=0></p>
<p>
Tip   If you know you will use a procedure only within its module, you should declare it with the <b>Private</b> keyword to avoid confusion and to speed up compilation of your code. Event procedures are always declared with the <b>Private </b>keyword, because they normally apply only to the form or report in which they are stored. For information on procedures declared with the<b> Private </b>keyword, search the Help index for “Private statement.”</p>
<p>
When you call a procedure that isn’t in the current module, Microsoft Access searches other modules and runs the first public procedure it finds that has the name you called. If the name of a public procedure isn’t unique in the database, you can specify the module it’s in when you call the procedure. For example, to run a <b>Sub</b> procedure called DisplayMsg that’s stored in a module called Utility, you use the following code:</p>
<pre><code>Utility.DisplayMsg
</code></pre>
<p>
You can call procedures in a class module from other modules as well. To do this, specify the name of the class module along with the procedure name. For example, to run a <b>Function</b> procedure called AddValues in a class module called Class1 and print the result to the Debug window, use the following code:</p>
<pre><code>Debug.Print Class1.AddValues
</code></pre>
<p>
Because form and report modules are also class modules, you call a procedure in a form or report module in the same way. To call a procedure in a form or report module, specify the name of the form or report module along with the procedure name. The name of the form or report module includes the qualification Form_ or Report_ followed by the name of the form or report. For example, to run a <b>Sub</b> procedure called DisplayRecords that’s stored with the Orders form, use the following code:</p>
<pre><code>Form_Orders.DisplayRecords
</code></pre>
<p>
Alternatively, you can call a procedure in a class module or a form or report module by referring to an object variable that points to an instance of either the class or the form or report. For example, the following code opens an instance of the Orders form, and then runs the DisplayRecords procedure.</p>
<pre><code>Dim frmOrders As New Form_Orders&#09;&#09;' Declare an object variable.

frmOrders.Visible = True&#09;&#09;&#09;&#09;&#09;&#09;' Open and display the Orders form.
frmOrders.DisplayRecords&#09;&#09;&#09;&#09;&#09;&#09;' Call the form's procedure.
&#09;.
&#09;.
&#09;.
Set frmOrders = Nothing&#09;&#09;&#09;&#09;&#09;&#09;' Close the new instance of the Orders form.
</code></pre>
<p>
By storing the DisplayRecords procedure in the Orders form module and making it public, you in effect create a custom method of the Orders form.</p>
<pre><code>Sub DisplayRecords
' This procedure can be called from another form
' to cause the Orders form to update itself.
&#09;.
&#09;.
&#09;.
End Sub
</code></pre>
<h3>Using Variables</h3>
<p>
Often you store values temporarily when performing calculations with Visual Basic. For example, you may want to calculate several values, compare them, and perform different operations on them, depending on the result of the comparison. You want to retain the values so you can compare them, but because you need to store them only while your code is running, you don’t want to store them in a table.</p>
<p>
Visual Basic uses <i>variables</i> to store values. Variables are like fields except that they exist within Visual Basic rather than in a table. Like a field, a variable has a name, which you use to refer to the value the variable contains, and a data type, which determines the kind of data the variable can store. Before you use a variable, it’s a good idea to declare it with a <b>Dim</b> statement, which tells Microsoft Access to set aside space for the variable.</p>
<p>
For example, in the following procedure, <code>dtmAny</code>, <code>dtmYear</code>, and <code>dtmMonth</code> are variables with the <b>Date</b> data type.</p>
<pre><code>Function DueDate(dtmAny As Date)

&#09;Dim dtmYear As Date, dtmMonth As Date

&#09;dtmYear = Year(dtmAny)
&#09;dtmMonth = Month(dtmAny) + 1
&#09;DueDate = DateSerial(dtmYear, dtmMonth, 1)
End Function
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on declaring and using variables, see Chapter 4, <a href="workingwithvariablesdatatypesconstants.htm">“Working with Variables, Data Types, and Constants.”</a></p>
<h3>Naming Conventions </h3>
<p>
While you are writing your Visual Basic code, you declare and name many elements (<b>Sub</b> and <b>Function</b> procedures, variables and constants, and so forth). The names of the procedures, variables, and constants you declare in your Visual Basic code must:
<ul>
<li>
Begin with a letter.</li>
<li>
Contain only letters, numbers, and the underscore character (_); punctuation characters and spaces aren’t allowed.</li>
<li>
Be no longer than 255 characters.</li>
<li>
Contain no keywords.</li>
</ul>
<p>
A <i>keyword</i> is a word that Visual Basic uses as part of its language. This includes predefined statements (such as <b>If</b> and <b>Loop</b>), functions (such as <b>Len </b>and <b>Abs</b>), methods (such as <b>Close</b> and <b>FindFirst</b>), and operators (such as <b>Or </b>and <b>Mod</b>).</p>
<h3>Controlling Execution</h3>
<p>
Visual Basic has several commands that help you control the execution of your code. For example, you can define groups of statements that may or may not be run, depending on the value of an expression, or you can define groups of statements that Visual Basic runs repeatedly. You can also define groups of statements that each are applied to one or more objects in your application.</p>
<p>
To run code conditionally, use the following statements:
<ul>
<li>
<b>If...Then</b></li>
<li>
<b>If...Then...Else</b></li>
<li>
<b>Select Case</b></li>
</ul>
<p>
To run one or more lines of code repetitively, use the following statements:
<ul>
<li>
<b>Do...Loop</b></li>
<li>
<b>For...Next</b></li>
<li>
<b>While...Wend</b></li>
</ul>
<p>
To apply one or more lines of code to an object or objects in your application, use the following statements:
<ul>
<li>
<b>For Each...Next</b></li>
<li>
<b>While...End While</b></li>
</ul>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on using these statements, search the Help index for any keyword in the statement.</p>
<h3>Using the DoCmd Object to Perform Macro Actions</h3>
<p>
Many common actions you perform in an application don’t have a corresponding command in the Visual Basic language. To perform the equivalent of a macro action, use methods of the <b>DoCmd</b> object. The syntax for the <b>DoCmd</b> object is:</p>
<p>
[<b>Application.</b>]<b>DoCmd</b>.<i>method</i> [<i>arguments</i>]</p>
<p>
Replace <i>method </i>with the name of a macro action. How many and what kind of arguments come after <i>method</i> depends on the specific macro action you want to run. You list the arguments in the same order they appear in the Macro window, or you can use named arguments. Specifying the <b>Application</b> object is optional; you can start a line with the <b>DoCmd</b> object.</p>
<p>
For example, the <b>Close</b> method, which corresponds to the Close action, takes two arguments that specify the type and name of the database object you want to close. You use commas to separate the arguments when a method takes multiple arguments.</p>
<pre><code>DoCmd.Close acForm, &quot;Add Products&quot;
</code></pre>
<p>
The first argument, <b>acForm</b>, is a Microsoft Access <i>intrinsic constant</i> specifying that the object to be closed is a form. Microsoft Access automatically declares a number of intrinsic constants that you can use to represent a variety of objects, actions, or data types. For example, you often use intrinsic constants with methods of the <b>DoCmd</b> object to specify action arguments that you can enter in the lower part of the Macro window.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on intrinsic constants, see Chapter 4, <a href="workingwithvariablesdatatypesconstants.htm">“Working with Variables, Data Types, and Constants,”</a> or search the Help index for “intrinsic constants.”</p>
<p>
Some methods of the <b>DoCmd</b> object take optional arguments. If you leave these arguments unspecified, Microsoft Access uses their default values. For example, if you leave both arguments for the <b>Close</b> method unspecified, Microsoft Access closes the active database object (whatever it may be).</p>
<pre><code>DoCmd.Close
</code></pre>
<p>
If you omit an optional argument but specify an argument that follows that argument, you must include a comma as a placeholder for the omitted argument. For example, the syntax for the <b>MoveSize</b> method is:</p>
<p>
<b>DoCmd.MoveSize</b> [<i>right</i>] [<b>,</b> <i>down</i>] [<b>, </b><i>width</i>] [<b>,</b> <i>height</i>]</p>
<p>
The following code uses the default (current) settings for its <i>right</i> and <i>down</i> arguments, while using the specified values for its <i>width</i> and <i>height</i> arguments.</p>
<pre><code>DoCmd.MoveSize , , 5000, 3000
</code></pre>
<p>
You can use methods of the <b>DoCmd</b> object to perform most macro actions, including the RunMacro action (which runs an existing macro as if it were a procedure). However, eight macro actions have no equivalent methods of the <b>DoCmd </b>object. In most cases, Visual Basic provides equivalent functionality with built-in statements or functions.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Action</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Visual Basic equivalent</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
AddMenu</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
No equivalent (but you can now create custom menus by using the command bars object model in Visual Basic)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
MsgBox</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">MsgBox </b>statement or function</td>
</tr>
<tr valign=top>
<TD>
RunApp</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Shell </b>function</td>
</tr>
<tr valign=top>
<TD>
RunCode</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Function</b> procedure call</td>
</tr>
<tr valign=top>
<TD>
SendKeys</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">SendKeys </b>statement</td>
</tr>
<tr valign=top>
<TD>
SetValue</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Assignment statement</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
StopAllMacros</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Stop</b> or <b>End</b> statements</td>
</tr>
<tr valign=top>
<TD>
StopMacro</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Exit Sub</b> or <b>Exit Function</b> statements</td>
</tr>
</table>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For information on methods of the <b>DoCmd</b> object, search the Help index for “DoCmd object.”</p>
<h3>Using the RunCommand Method to Perform Menu Commands</h3>
<p>
Occasionally, you may want your application to perform a command that’s on a Microsoft Access menu or toolbar. To perform a built-in command just as if the user clicked it, use the <b>RunCommand</b> method. The syntax for the<b> RunCommand</b> method is:</p>
<p>
<b>RunCommand</b> <i>command</i></p>
<p>
<i>Command</i> is a constant that corresponds to the Microsoft Access command you want to run. For example, the following line of code performs the <b>Options</b> command, causing Microsoft Access to display the <b>Options</b> dialog box:</p>
<pre><code>RunCommand acCmdOptions
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;To determine the constant for the command you want to run, search the Help index for “RunCommand method.”</p>
</FONT></FONT></BODY>
</HTML>
