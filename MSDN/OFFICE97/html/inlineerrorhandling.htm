<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Inline Error Handling</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="inlineerrorhandling"></a>Inline Error Handling</h2>
<p>
You may be used to programming in a language that doesn’t interrupt the execution of your code with exceptions when errors occur, but instead records errors for you to check and handle later. For example, the C programming language works this way. You may sometimes find it convenient to follow this practice in your Visual Basic code. When you check for errors immediately after each line of code that may cause an error, you are performing <i>inline error handling</i>.</p>
<p>
The simplest way to return an error number to a calling procedure is to create functions and statements that return an error number instead of a value if an error occurs. Using this method, you implement inline error handling by testing for an error immediately after each statement or function call in your code. In each case, you can design an error handler that tests for just the kind of error that may arise and provides an appropriate resolution.</p>
<p>
This approach doesn’t require that an actual Visual Basic run-time error occur. You can also trap user-defined errors, or you can use this method when you’re working with DLLs or other libraries that don’t raise Visual Basic errors.</p>
<p>
The following example uses the DoubleNum function from a section earlier in this chapter to demonstrate how to return an error number to a calling procedure if an argument passed to the DoubleNum function isn’t numeric.</p>
<pre><code>Dim TestValue As Variant

TestValue = DoubleNum(&quot;3210r&quot;)
If IsError(TestValue) Then
&#09;.
&#09;. ' Handle the error.
&#09;.
Else
&#09;.
&#09;. ' Continue program.
&#09;.
End If
</code></pre>
<p>
You can also use the <b>Raise</b> method of the <b>Err</b> object to pass an error value to the calling procedure. Place the <b>On Error Resume Next</b> statement at the beginning of your procedure, or before statements or function calls in your code that may cause an error. After an error occurs, you can use error-handling code to examine the value returned by the <b>Err</b> object’s properties. If the <b>Number</b> property of the <b>Err</b> object doesn’t return zero, an error has occurred and the error-handling code can take the appropriate action.</p>
<p>
The example in the previous section can be modified to use the <b>Raise</b> method as follows:</p>
<pre><code>Function DoubleNum(Num)
&#09;If IsNumeric(Num) Then
&#09;&#09;DoubleNum = Num * 2&#09;&#09;&#09;&#09;&#09;' Return result.
&#09;Else
&#09;&#09;Err.Raise Number:=30000&#09;&#09;&#09;' Raise a user-defined error.
&#09;End If
End Function

&#09;Dim TestValue As Variant

&#09;On Error Resume Next
&#09;TestValue = DoubleNum(&quot;3210r&quot;)
&#09;If Err.Number = 30000 Then
&#09;&#09;.
&#09;&#09;. ' Handle the error.
&#09;&#09;.
&#09;Else
&#09;&#09;.
&#09;&#09;. ' Continue program.
&#09;&#09;.
&#09;End If
&#09;On Error GoTo 0
</code></pre>
<p>
There are times when you may need to defer error handling in a loop. You can do this by manually resetting the <b>Number</b> property of the <b>Err</b> object to zero so that you can continue to check for errors in the loop. For example, the following <b>Sub</b> procedure iterates through all of the fields in a recordset and tries to change their values. If an error occurs, the field name is printed in the Debug window.</p>
<pre><code>Sub SetAllFields(rst As Recordset)
&#09;Dim fld As Field

&#09;rst.MoveFirst
&#09;On Error Resume Next
&#09;Do Until rst.EOF
&#09;&#09;For Each fld In rst.Fields
&#09;&#09;&#09;rst.Edit
&#09;&#09;&#09;&#09;fld = InputBox(&quot;New value for &quot; &amp; fld.Name &amp; &quot;?&quot;, , &quot;New Value&quot;)
&#09;&#09;&#09;&#09;If Err &lt;&gt; 0 Then
&#09;&#09;&#09;&#09;&#09;Err = 0
&#09;&#09;&#09;&#09;&#09;Debug.Print fld.Name
&#09;&#09;&#09;&#09;End If
&#09;&#09;&#09;rst.Update
&#09;&#09;Next fld
&#09;&#09;rst.MoveNext
&#09;Loop
&#09;rst.Close
End Sub
</code></pre>
<p>
If you don’t set the <b>Number</b> property of the<b> Err</b> object equal to zero inside the loop, then the first error that occurs will cause every subsequent field’s name to be printed in the Debug window.</p>
<p>
Keep these points in mind when using inline error handling:
<ul>
<li>
The code that detects and deals with an error differs from the error-handling code discussed earlier in this chapter in that it doesn’t contain any <b>Resume</b> statements.</li>
<li>
The error code number returned by the <b>Number</b> property of the <b>Err</b> object is the number of the most recent error. Additional errors that occur earlier in the preceding code aren’t accounted for.</li>
<li>
If a <b>Resume</b>, <b>Resume Next</b>, or <b>On Error</b> statement is run, or if a procedure call is made, Visual Basic resets the properties of the <b>Err</b> object to zero or zero-length strings (&quot;&quot;). If you’re going to use the values returned by the <b>Err</b> object properties, store them in variables before running any of these statements.</li>
<li>
If errors occur and error handling is deferred, logic errors in the intervening code can produce unexpected results. Try to limit the amount of time error handling is turned off by using an <b>On Error GoTo</b> statement as soon as you can to prevent failure to trap unexpected errors.</li>
</ul>
</FONT></FONT></BODY>
</HTML>
