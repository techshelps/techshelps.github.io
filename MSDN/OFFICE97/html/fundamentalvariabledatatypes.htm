<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Fundamental Variable Data Types</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<h2><a name="fundamentalvariabledatatypes"></a>Fundamental Variable Data Types</h2>
<p>
When you declare a variable, you can also supply a data type for the variable. All variables have a data type that determines what kind of data they can store. By default, if you don’t supply a data type (or if you declare the variable implicitly), the variable is given the <b>Variant</b> data type.</p>
<h3>The Variant Data Type</h3>
<p>
The <b>Variant</b> data type can store many kinds of data. Like a text box control on a form, a <b>Variant</b> variable is equally capable of storing numbers, strings of text, dates and times, or the <b>Null</b> value. You don’t have to convert between these types of data when assigning them to a <b>Variant</b> variable; Visual Basic automatically performs any necessary conversion, as shown in the following example:</p>
<pre><code>Dim varX&#09;&#09;&#09;&#09;&#09;&#09;&#09;' Variant by default.

varX = &quot;17&quot;&#09;&#09;&#09;&#09;&#09;&#09;' varX contains the two-character string &quot;17&quot;.
varX = varX - 15&#09;&#09;&#09;&#09;' varX now contains the numeric value 2.
varX = &quot;U&quot; &amp; varX&#09;&#09;&#09;&#09;' varX now contains the string &quot;U2&quot;.
</code></pre>
<p>
Although you can perform operations on <b>Variant</b> variables without much concern for what kind of data they actually contain, there are some pitfalls you’ll want to avoid:
<ul>
<li>
If you perform arithmetic operations on a <b>Variant</b>, or use a <b>Variant</b> in an arithmetic function, the variable must contain a valid number. For example, you can’t perform any arithmetic operations on the value <code>&quot;U2&quot;</code> even though it contains a numeric character, because the entire value isn’t a valid number. Likewise, you can’t perform any calculations on the value <code>&quot;1040EZ&quot;</code>. However, you can perform numeric calculations on the values <code>&quot;+10&quot;</code> and <code>&quot;-1.7E62&quot;</code> because they are valid numbers.</li>
</ul>
<p>
You can use the <b>IsNumeric</b> function to determine if the value contained by a <b>Variant</b> variable can be used as a valid number in an expression. For example:</p>
<pre><code>If IsNumeric(varX) And IsNumeric(varY) Then
&#09;varZ = varX * varY
Else
&#09;varZ = Null
End If
</code></pre>
<ul>
<li>
If you’re concatenating strings, use the <b>&amp;</b> operator instead of the <b>+</b> operator. The result of the <b>+</b> operator can be ambiguous when used with two <b>Variant</b> values.<p>
If both of the <b>Variant </b>values contain numbers, then the <b>+</b> operator performs addition. If both of the <b>Variant</b> values contain strings, then the <b>+</b> operator performs string concatenation. However, if one of the values is a number and the other is a string, the situation becomes more complicated. Visual Basic first attempts to convert the string into a number. If the conversion is successful, then the <b>+</b> operator adds the two values; if unsuccessful, it generates a “<code>Type mismatch”</code> error.</p>
<p>
To make sure that concatenation occurs, regardless of the representation of the value in the variables, use the <b>&amp;</b> operator. For example, the following code:</p>
<pre><code>Sub Test()
&#09;Dim varX As Variant, varY As Variant

&#09;varX = &quot;6&quot;
&#09;varY = &quot;7&quot;
&#09;Debug.Print varX + varY, varX &amp; varY
&#09;varX = 6
&#09;Debug.Print varX + varY, varX &amp; varY
End Sub
</code></pre>
<p>
produces the following result in the Debug window:</p>
<pre><code>67&#09;&#09;67
13&#09;&#09;67
</code></pre>
</li>
</ul>
<p>
Important   When typing your code, it’s important to leave a space between any variable name and the <b>&amp;</b> operator. If you don’t leave a space, Visual Basic assumes you intended to use the <b>&amp;</b> as the type-declaration character for the variable name.</p>
<p>
In addition to strings and numbers, <b>Variant</b> variables can also contain date/time values. For example:</p>
<pre><code>Function Century() As Integer
&#09;Dim varToday As Variant

&#09;varToday = Now
&#09;If varToday &gt;= #1/1/2001# Then
&#09;&#09;Century = 21
&#09;Else
&#09;&#09;Century = 20
&#09;End If
End Function
</code></pre>
<p>
In the same way that you can use the <b>IsNumeric</b> function to determine if a <b>Variant</b> variable contains a valid numeric value, you can use the <b>IsDate</b> function to determine if a <b>Variant</b> variable contains a valid date/time value. For example:</p>
<pre><code>Function Century (ByVal varDate As Variant) As Variant
&#09;If IsDate(varDate) Then
&#09;&#09;Century = ((Year(varDate) - 1) \ 100) + 1
&#09;Else
&#09;&#09;Century = Null
&#09;End If
End Function
</code></pre>
<p>
Objects, including Automation objects, can also be stored in <b>Variant </b>variables. This can be useful when you need to handle a variety of data types, including objects. For example, all the elements in an array must have the same data type. Setting the data type of an array to <b>Variant</b> allows you to store objects alongside other data types in an array.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on arrays, see “Arrays” later in this chapter.</p>
<h4>The Empty Value</h4>
<p>
Sometimes you need to know if a <b>Variant</b> variable has ever been assigned a value since the variable was created. A <b>Variant</b> variable has the <b>Empty</b> value before it’s assigned a value. The <b>Empty</b> value is a special value different from 0, a zero-length string (<code>&quot;&quot;</code>), or the <b>Null</b> value. You can use the <b>IsEmpty</b> function to determine if a<b> Variant</b> variable has the <b>Empty</b> value.</p>
<pre><code>If IsEmpty(varX) Then varX = 0
</code></pre>
<p>
When you use a <b>Variant</b> in an expression, an <b>Empty</b> value is treated as either 0 or a zero-length string, depending on the expression. The <b>Empty</b> value disappears as soon as any value is assigned to a <b>Variant</b> variable (including the value of 0, the zero-length string, and the <b>Null</b> value). You can set a <b>Variant</b> variable back to the <b>Empty</b> value by assigning the <b>Empty</b> keyword to the <b>Variant</b>.</p>
<h4>The Null Value</h4>
<p>
The <b>Variant</b> data type can contain one other special value: <b>Null</b>. <b>Null</b> is commonly used in database applications to indicate unknown or missing data. Fields and controls that haven’t been initialized have a default value of <b>Null</b>. You can use the <b>IsNull</b> function to determine if a <b>Variant</b> variable contains the <b>Null</b> value.</p>
<pre><code>If IsNull(varX) And IsNull(varY) Then
&#09;varZ = Null
Else
&#09;varZ = 0
End If
</code></pre>
<p>
A <b>Null</b> value has some unique characteristics:
<ul>
<li>
Expressions involving <b>Null</b> always result in <b>Null</b>. Thus, <b>Null</b> is said to <i>propagate</i> through expressions; if any part of the expression evaluates to <b>Null</b>, the entire expression evaluates to <b>Null</b>.</li>
<li>
Most functions return <b>Null</b> if you pass them <b>Null</b>, a <b>Variant</b> containing <b>Null</b>, or an expression that evaluates to <b>Null</b> as an argument.</li>
<li>
<b>Null</b> values propagate through intrinsic (built-in) functions that return <b>Variant</b> data types.</li>
</ul>
<p>
You can assign a <b>Null</b> value by using the <b>Null</b> keyword. For example:</p>
<pre><code>varZ = Null
</code></pre>
<p>
Only <b>Variant</b> variables can contain <b>Null</b> values. If you assign <b>Null</b> to a variable of any data type other than <b>Variant</b>, a trappable error occurs. Assigning <b>Null</b> to a <b>Variant</b> variable doesn’t cause an error, and <b>Null</b> will propagate through expressions involving <b>Variant</b> variables (though <b>Null</b> doesn’t propagate through certain functions). For example, the following code:</p>
<pre><code>Sub Test()
&#09;Dim varX As Variant, varY As Variant

&#09;varX = &quot;6&quot;
&#09;varY = Null

&#09;Debug.Print varX + varY, varX &amp; varY
End Sub
</code></pre>
<p>
produces this result in the Debug window: <code>Null&#09;6</code></p>
<p>
In addition, you can return <b>Null</b> from any <b>Function</b> procedure that has a <b>Variant</b> return value.</p>
<p>
<img src="abac04_2.gif" border=0></p>
<p>
Tip   The fact that <b>Null</b> propagates makes it useful as an error value. If you write <b>Function</b> procedures that return <b>Null</b> when an error occurs, and then combine these functions in expressions, you can use the <b>IsNull</b> function to test the final result of the expression to see if an error has occurred. Because <b>Null</b> propagates, the final result is <b>Null</b> if an error has occurred in any of the functions; you don’t have to test the result of each function separately.</p>
<h3>Other Fundamental Data Types</h3>
<p>
The <b>Variant</b> data type handles all types of fundamental data and converts between them automatically. However, you can usually create more concise, faster code by using other data types where appropriate. For example, if a variable will always contain small integer values, you can save several bytes, and significantly increase the speed of arithmetic operations on the variable, by declaring that variable to be <b>Integer</b> instead of <b>Variant</b>.</p>
<p>
The following table lists the fundamental data types in Visual Basic, including <b>Variant</b>.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Data type</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Range</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Byte</b></td>
<TD>
1-byte binary data</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
0 to 255</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Integer</b></td>
<TD>
2-byte integer</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
– 32,768 to 32,767</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Long</b></td>
<TD>
4-byte integer</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
– 2,147,483,648 to 2,147,483,647</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Single</b></td>
<TD>
4-byte floating-point number</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
– 3.402823E38 to – 1.401298E – 45 (negative values)<p><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
1.401298E – 45 to 3.402823E38 (positive values)</p>
</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Double </b></td>
<TD>
8-byte floating-point number</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
– 1.79769313486231E308 to – 4.94065645841247E – 324 (negative values)<p><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
4.94065645841247E – 324 to 1.79769313486231E308 (positive values)</p>
</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Currency</b></td>
<TD>
8-byte number with fixed decimal point</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
– 922,337,203,685,477.5808 to 922,337,203,685,477.5807</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">String</b></td>
<TD>
String of characters</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Zero to approximately two billion characters</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Variant</b></td>
<TD>
Date/time, floating-point number, integer,  string, or object. 16 bytes, plus 1 byte for each character if a string value.</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Date values: January 1, 100 to December 31, 9999Numeric values: same range as <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Double</b>String values: same range as <b>String</b> Can also contain <b>Error</b> or <b>Null </b>values</td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Boolean</b></td>
<TD>
2 bytes</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">True</b> or <b>False</b></td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Date</b></td>
<TD>
8-byte date/time value</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
January 1, 100 to December 31, 9999</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Object</b></td>
<TD>
4 bytes</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Any <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Object</b> reference</td>
</tr>
</table>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;You can also declare arrays of any of these fundamental data types. For more information, see “Arrays” later in this chapter.</p>
<p>
When you declare a variable by using a <b>Dim</b>, <b>Public</b>, <b>Private</b>, or <b>Static</b> statement, you use the <b>As</b> <i>type</i> clause to specify the data type of the variable. For example, the following statements declare <b>Integer</b>, <b>Currency</b>,<b> Double</b>, and <b>String</b> variables, respectively:</p>
<pre><code>Dim intX As Integer
Public curBillsPaid As Currency
Private dblAmt As Double
Static strName As String
</code></pre>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>Dim</b>, <b>Public</b>, <b>Private</b>, or <b>Static</b> statements, search the Help index for the name of the statement.</p>
<p>
A declaration statement can combine multiple declarations, as in the following statements:</p>
<pre><code>Dim intX As Integer, dblAmt As Double
Dim strName As String, curBillsPaid As Currency
Dim varTest, intY As Integer, varAmount
</code></pre>
<p>
Important   In a multiple declaration statement, you must use the <b>As</b> <i>type</i> clause for each variable whose data type you want to specify. If you don’t specify a data type, Visual Basic declares the variable as <b>Variant</b>. In the last line of code in the preceding example, Visual Basic declares only the variable <code>intY</code> as <b>Integer</b>. The variables <code>Test</code> and <code>Amount</code> are each declared as <b>Variant</b>.</p>
<p>
Most of the Visual Basic data types match the data types for fields that contain data. The few field data types that aren’t directly matched by a Visual Basic data type can be handled by another Visual Basic data type.</p>
<table>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Field data type</b></td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Compatible Visual Basic data type</b></td>
</tr>
<tr valign=top>
<TD>
</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
AutoNumber (Long Integer)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Long</b></td>
</tr>
<tr valign=top>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">AutoNumber (Replication ID</b>)</td>
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">No compatible Visual Basic type</b></td>
</tr>
<tr valign=top>
<TD>
Currency</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Currency</b></td>
</tr>
<tr valign=top>
<TD>
Date/Time</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Date</b></td>
</tr>
<tr valign=top>
<TD>
Hyperlink</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
No compatible Visual Basic type</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
Memo</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">String</b></td>
</tr>
<tr valign=top>
<TD>
Number (Byte)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Byte</b></td>
</tr>
<tr valign=top>
<TD>
Number (Integer)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Integer</b></td>
</tr>
<tr valign=top>
<TD>
Number (Long Integer)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Long</b></td>
</tr>
<tr valign=top>
<TD>
Number (Single)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Single</b></td>
</tr>
<tr valign=top>
<TD>
Number (Double)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Double</b></td>
</tr>
<tr valign=top>
<TD>
Number (Replication ID)</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
No compatible Visual Basic type</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</tr>
<tr valign=top>
<TD>
OLE Object</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
Array with the <b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Byte</b> data type</td>
</tr>
<tr valign=top>
<TD>
Text</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">String</b></td>
</tr>
<tr valign=top>
<TD>
Yes/No</td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<TD>
<b><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Boolean</b></td>
</tr>
</table>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;SQL data types are also used in Microsoft Access queries. For information on these data types, search the Help index for “ANSI SQL data types.”</p>
<p>
If a variable must be able to accept <b>Null</b> values, declare it as a <b>Variant</b> rather than one of the other fundamental data types. The <b>Variant</b> data type can accept <b>Null</b> values, while the other fundamental data types cannot.</p>
<h4>Numeric Data Types</h4>
<p>
If you know that a variable always stores whole numbers (for example, 12) rather than fractional numbers (for example, 3.57), declare it as an <b>Integer</b> or <b>Long</b> data type. Operations are faster with integers, and <b>Integer</b> and <b>Long</b> use less memory than <b>Variant</b>, <b>Double</b>, or <b>Currency</b>. Integers are especially useful as the counter variables in <b>For...Next</b> loops.</p>
<p>
If the variable contains a fraction, declare it as a <b>Single</b>, <b>Double</b>, or <b>Currency</b> variable. The <b>Currency</b> data type supports up to 4 digits to the right of the decimal point and 15 to the left; it’s a fast and accurate fixed-point data type suitable for monetary calculations. Floating-point (<b>Single</b> and <b>Double</b>) numbers have much larger ranges than <b>Currency</b>, but are subject to small rounding errors.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Floating-point values can be expressed as <i>mmm</i>E<i>eee</i>, in which <i>mmm</i> is the mantissa and <i>eee</i> is the exponent (a power of ten). The highest positive value of a <b>Single</b> data type is 3.402823E+38, or 3.4 times 10 to the 38th power; the highest positive value of a <b>Double</b> data type is 1.79769313486231E+308, or about 1.8 times 10 to the 308th power.</p>
<p>
If the variable contains binary data, declare it as an array of the <b>Byte</b> data type. Using <b>Byte</b> variables to store binary data preserves the data during format conversions. When <b>String</b> variables are converted between ANSI/DBCS and Unicode™ formats, any binary data in the variable may be corrupted. Visual Basic will automatically convert between ANSI/DBCS and Unicode in any of the following circumstances:
<ul>
<li>
Reading from files</li>
<li>
Writing to files</li>
<li>
Calling DLLs</li>
</ul>
<p>
All arithmetic operators work with the <b>Byte </b>data type.</p>
<p>
All numeric variables can be assigned to each other and to variables of the <b>Variant</b> data type. Visual Basic rounds off (doesn’t truncate) the fractional part of a floating-point number before assigning it to an integer.</p>
<h4>The String Data Type</h4>
<p>
If you have a variable that will always contain a string and never a numeric value, you can declare it as a <b>String </b>data type.</p>
<pre><code>Dim strAny As String
</code></pre>
<p>
You can then assign strings to this variable and manipulate it by using string functions.</p>
<pre><code>strAny = &quot;Database&quot;
strAny = Left(strAny, 4)
</code></pre>
<p>
Fixed-length strings in standard modules can be declared as <b>Public</b> or <b>Private</b>. In form and report modules, fixed-length strings must be declared as <b>Private</b>.</p>
<p>
By default, a string variable or argument is a <i>variable-length string</i>, which means the string grows or shrinks as you assign new data to it. You can also declare strings that have a fixed length. You specify a <i>fixed-length string</i> with the following syntax:</p>
<p>
<b>String</b> <b>*</b> <i>size</i></p>
<p>
For example, the following code declares a string that is always 50 characters long:</p>
<pre><code>Dim strEmpName As String * 50
</code></pre>
<p>
If you assign a string of fewer then 50 characters, <code>strEmpName</code> is padded with enough trailing spaces to total 50 characters. If you assign a string that is too long for the fixed-length string, the extra characters are truncated. For example, the following code:</p>
<pre><code>Dim strJust4 As String * 4
Dim strAny As String

strAny = &quot;Database&quot;
Debug.Print strAny

strJust4 = strAny
Debug.Print strJust4
</code></pre>
<p>
produces the following result in the Debug window:</p>
<pre><code>Database
Data
</code></pre>
<p>
Because fixed-length strings are padded with trailing spaces, you may find the <b>Trim</b>, <b>LTrim</b>, and <b>RTrim </b>functions useful when working with them.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>Trim</b>, <b>LTrim</b>, or <b>RTrim </b>functions, search the Help index for the name of the function.</p>
<p>
Visual Basic compares strings in one of several different ways, depending on the <b>Option Compare</b> statement specified in the Declarations section of your modules. You can specify either <b>Option Compare Database</b>, <b>Option Compare Binary</b>, or <b>Option Compare Text</b> to determine the relative ordering used in a comparison, and whether or not string comparisons are case-sensitive.</p>
<p>
Microsoft Access automatically inserts an <b>Option Compare Database</b> statement in the Declarations section of a new module, specifying that the string comparisons in that module are based on the database sort order. If no <b>Option Compare</b> statement is specified in a module, Visual Basic does case-sensitive <b>Binary</b> comparisons in that module based on the character’s relative order of appearance in the ANSI character set.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>Option Compare </b>statement, search the Help index for “Option Compare statement.”</p>
<h4>The Boolean Data Type</h4>
<p>
If you have a variable that will contain simple yes/no or on/off information, you can declare it as a <b>Boolean </b>data type. The default value of <b>Boolean</b> is <b>False</b>. In the following example, <code>blnCreditExceeded</code> is a <b>Boolean</b> variable that stores a simple <b>True</b> or <b>False</b> setting.</p>
<pre><code>Dim blnCreditExceeded As Boolean

' Add all charges.
Do Until rstCharges.EOF
&#09;curAmt = curAmt + rstCharges(&quot;Amount&quot;).Value
&#09;rstCharges.MoveNext
Loop

' Ask if the credit limit is exceeded.
If curAmt &gt; curLimit Then blnCreditExceeded = True
</code></pre>
<h4>The Date Data Type</h4>
<p>
Date and time values can be contained both in the specific <b>Date</b> data type and in <b>Variant</b> variables. The same general characteristics apply to dates in both types. </p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information, see “The Variant Data Type” earlier in this chapter.</p>
<p>
When other numeric data types are converted to <b>Date</b>, values to the left of the decimal represent date information, while values to the right of the decimal represent time. Midnight is 0, and noon is 0.5. Negative whole numbers represent dates before December 30, 1899.</p>
<h4>The Object Data Type</h4>
<p>
Object variables are stored as 32-bit (4-byte) addresses that refer to objects within an application or within some other application. A variable declared as <b>Object</b> can subsequently be assigned (by using the <b>Set</b> statement) to refer to any actual object recognized by the application. For example:</p>
<pre><code>Const conFilePath As String = &quot;C:\Program Files\Microsoft Office\Office\Samples\&quot;
Dim objDb As Object

Set objDb = OpenDatabase(conFilePath &amp; &quot;Northwind.mdb&quot;)
</code></pre>
<p>
When declaring object variables, instead of using a <b>Variant</b> data type or the generic <b>Object </b>data type, declare objects as they are listed in the <b>Classes</b> box in the Object Browser. Visual Basic can resolve references to the properties and methods of objects with specific types at compile time rather than at run time. This catches common errors sooner, and makes your code run faster.</p>
<p>
<img src="abac04_3.gif" border=0></p>
<p>
Tip   You may want to think of the objects listed in the <b>Classes</b> box in the Object Browser as additional data types that are available to you. You can declare objects from other applications —and other applications can declare objects from your application—in the same way that you declare ordinary object data types in Visual Basic.</p>
<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on objects and the Object Browser, see Chapter 5, <a href="workingwithobjectscollections.htm">“Working with Objects and Collections.”</a></p>
<h3>Argument Data Types</h3>
<p>
The arguments for procedures you write have the <b>Variant</b> data type by default. However, you can declare other data types for arguments. For example, the following function accepts a <b>String</b> and an <b>Integer</b>:</p>
<pre><code>Function Reverse (strAny As String, ByVal intChars As Integer) As String
' Reverses the first intChars characters in strAny.

&#09;Dim strTemp As String, intCount As Integer

&#09;If intChars &gt; Len(strAny) Then intChars = Len(strAny)
&#09;For intCount = intChars To 1 Step - 1
&#09;&#09;strTemp = strTemp + Mid(strAny, intCount, 1)
&#09;Next
&#09;Reverse = strTemp + Right(strAny, Len(strAny) - intChars)
End Function
</code></pre>
<p>
If you specify a data type for an argument, you must either:
<ul>
<li>
Pass a value of that type for the argument.</li>
<li>
Declare the argument by using the <b>ByVal</b> keyword to specify that the argument is passed <i>by value</i> rather than <i>by reference</i>. When you pass a variable by value, changes to the variable in the procedure don’t affect its value in the calling procedure.<p>
<b>See Also</b>&nbsp;&nbsp;&nbsp;For more information on the <b>ByVal </b>keyword, search the Help index for “ByVal keyword.”</p>
</li>
</ul>
<p>
For example, you can’t pass a <b>Variant</b> by reference to a string argument. Thus, the following code produces an error:</p>
<pre><code>Dim varTest As Variant

varTest = &quot;Testing&quot;
Debug.Print Reverse(varTest, 4)&#09;&#09;' Error: argument type mismatch.
</code></pre>
<p>
One way to avoid this problem is to pass an expression, rather than a<b> Variant</b>, for an argument. Visual Basic then evaluates the expression and, if it can, passes it as the required data type. The simplest way to turn a variable into an expression is to enclose it in parentheses. For example:</p>
<pre><code>Debug.Print Reverse((varTest), 4)&#09;' Makes the variable an expression.
</code></pre>
<p>
However, the best way to ensure that arguments are passed correctly is to declare the arguments with the <b>ByVal</b> keyword, as illustrated by the second argument, <code>ByVal intChars As Integer</code>, in the preceding Reverse function example. Thus, you can pass a <b>Variant</b> as the second argument to the Reverse function. For example:</p>
<pre><code>Dim strTest As String, varTest As Variant

strTest = &quot;Testing&quot;
varTest = &quot;2&quot;
Debug.Print Reverse(strTest, varTest)&#09;&#09;' Works!
</code></pre>
<p>
When you pass a variable to a procedure by reference, the variable’s value can be changed by that procedure. On the other hand, when you pass the variable by value, only a copy of the variable is passed to the procedure; therefore, if the procedure changes that value, the change affects only the copy and not the variable itself. This is important in the Reverse function; if the second argument isn’t declared with the <b>ByVal </b>keyword, bugs could appear in the code. For example, suppose the second argument wasn’t declared with the <b>ByVal </b>keyword, and you called it as follows:</p>
<pre><code>Dim intTest As Integer, strTest As String

intTest = 10
strTest = &quot;Testing&quot;
Debug.Print Reverse(strTest, intTest)&#09;' Now intTest = 7 (length of strTest).
</code></pre>
<p>
You don’t usually expect a function to modify its arguments, as happens here. To avoid this kind of side effect in any procedures that modify their arguments, declare those arguments with the <b>ByVal </b>keyword.</p>
<h3>Function Return Data Types</h3>
<p>
The value returned by a function has a data type. When you define the function, you can declare the data type of the value the function returns. For example, the Reverse function in the preceding section returns a <b>String</b>.</p>
<p>
As with variables, Visual Basic can work more efficiently with functions if you explicitly declare a data type for the values they return. If you don’t declare a data type, functions use the <b>Variant</b> data type. For example, if you don’t set a return value for a function (by assigning a value to the name of the function), the function returns a <b>Variant</b> containing the <b>Empty</b> value.</p>
<p>
If you declare the function to return a <b>String</b>, as in the Reverse function example, the function returns a zero-length string (<code>&quot;&quot;</code>) if you don’t assign a return value. If you declare the function to return a numeric data type, such as <b>Integer</b> or <b>Double</b>, it returns zero if you don’t explicitly assign a return value.</p>
</FONT></FONT></BODY>
</HTML>
