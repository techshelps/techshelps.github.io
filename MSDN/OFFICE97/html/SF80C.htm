<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multiple Instances of Microsoft Excel</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Multiple Instances of Microsoft Excel </H2><H4 CLASS="h6"><A NAME="sec0"></A>Windows 16-Bit Only</H4><P CLASS="h">You must consider the possibility that your DLL will be called by more than one running instance of Microsoft Excel. If this happens, remember that your DLL has only one global data segment. For example, consider this code:</P>

<pre><code><FONT FACE="Courier" SIZE="2">int i = 0;

int WINAPI test(void)
{
    return ++i;
}
</FONT></code></pre>
<P CLASS="t">This returns successive integers as long as there is only one copy of Microsoft Excel using this DLL. But if there are multiple instances of Microsoft Excel running at the same time and intermittently calling this DLL, there will still be only one copy of the variable i between all the instances. This means that your DLL cannot save state as easily as a normal C program can. What can you do about this, if you need a DLL to maintain a state that is distinct for each instance of Microsoft Excel?</P>
<P></P>
<P></P>
<P></P>
<P CLASS="t">The usual solution is to use a block of memory called an <I>instance block.</I> For example, you have a program Zoo with two functions: see_bears and see_fish. You can create an initialization function init_zoo, which allocates an instance block of memory (using LocalAlloc or GlobalAlloc) that contains all of the state that is instance-specific. The function init_zoo returns a pointer (or handle) to this&nbsp;memory. Then see_bears and see_fish take this handle as the first argument. Finally, exit_zoo frees the global memory. The code might look like this:</P>

<pre><code><FONT FACE="Courier" SIZE="2">typedef struct tagInstanceBlock
{
    int a;
    int b;
} INSTANCEBLOCK;

HANDLE WINAPI init_zoo()
{
    return GlobalAlloc(GMEM_MOVEABLE, sizeof(INSTANCEBLOCK));
}

void WINAPI see_bears(HANDLE hInstBlock)
{
    INSTANCEBLOCK FAR *pib;

    pib = GlobalLock(hInstBlock);

    // Now use pib-&gt;a and pib-&gt;b as instance-specific
    // variables

    GlobalUnlock(hInstBlock);
}

void WINAPI exit_zoo(HANDLE hInstBlock)
{
    GlobalFree(hInstBlock);
}
</FONT></code></pre>
<P CLASS="t">There are other ways around this problem. For example, you can store all instance-specific information on sheets, using Microsoft Excel to maintain your state. You can also store the instance handle in a name on the sheet or in the hidden name space. Or you can simply prevent multiple instances of Microsoft Excel from using your DLL. You can call the xlGetInst function to find out the instance handle of the instance that is calling you, so that you can distinguish between different instances.</P>
<P></P>
<P></P>
<P></P></FONT>
</FONT></BODY></HTML>
