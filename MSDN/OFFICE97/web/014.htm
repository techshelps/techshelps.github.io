<HTML><HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chapter 14: Debugging and Error Handling</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant For Microsoft Word 2.0z Beta">
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#ffffff" TOPMARGIN=0 LEFTMARGIN=0>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->



<!--TOOLBAR_START-->
<!--TOOLBAR_END-->
<!--Header/Footer Info_START-->

<TABLE WIDTH=98% BORDER=0 CELLPADDING=0>
<TR>
<TD WIDTH=30% ALIGN=LEFT><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT COLOR=#000000 FACE="VERDANA,ARIAL,HELVETICA" Size=1>
<B>C H A P T E R &nbsp;&nbsp; 14</B></FONT></TD>
<TD WIDTH=20% ALIGN=CENTER><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT COLOR=#000000 FACE="VERDANA,ARIAL,HELVETICA" Size=1>
<B></B></FONT></TD>
<TD WIDTH=50% ALIGN=RIGHT><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT COLOR=#000000 FACE="VERDANA,ARIAL,HELVETICA" SIZE=1>
<B>Microsoft Office 97/Visual Basic Programmer's Guide</B></FONT></TD></TR>
</TABLE>
<P>
<!--Header/Footer Info_END-->

<P><!--NAV_START-->
<TABLE WIDTH="98%" BGCOLOR="#ffffff" BORDER=0 CELLSPACING=0 CELLPADDING=3>
<TR><TD VALIGN="TOP" WIDTH=60%><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B>Debugging and Error Handling</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2></TD>
</TR>
</TABLE><HR>
<!--NAV_END-->
<MENU><MENU><MENU>
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Contents</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<UL>
<LI><A HREF="#CH014H101">How to Handle Errors</A>
<BR>
<LI><A HREF="#CH014H102">Designing an Error Handler</A>
<BR>
<LI><A HREF="#CH014H103">The Error&#173;Handling Hierarchy</A>
<BR>
<LI><A HREF="#CH014H104">Testing Error Handling by Generating Errors</A>
<BR>
<LI><A HREF="#CH014H105">Inline Error Handling</A>
<BR>
<LI><A HREF="#CH014H106">Centralized Error Handling</A>
<BR>
<LI><A HREF="#CH014H107">Turning Off Error Handling</A>
<BR>
<LI><A HREF="#CH014H108">Handling Errors in Referenced Objects</A>
<BR>
<LI><A HREF="#CH014H109">Approaches to Debugging</A>
<BR>
<LI><A HREF="#CH014H110">Avoiding Bugs</A>
<BR>
<LI><A HREF="#CH014H111">Design Time, Run Time, and Break Mode</A>
<BR>
<LI><A HREF="#CH014H112">Using the Debugging Windows</A>
<BR>
<LI><A HREF="#CH014H113">Using Break Mode</A>
<BR>
<LI><A HREF="#CH014H114">Running Selected Portions of Your Application</A>
<BR>
<LI><A HREF="#CH014H115">Monitoring the Call Stack</A>
<BR>
<LI><A HREF="#CH014H116">Testing Data and Procedures with the Immediate Window</A>
<BR>
<LI><A HREF="#CH014H117">Special Debugging Considerations</A>
<BR>
<LI><A HREF="#CH014H118">Tips for Debugging</A>
<P>
</UL>

<P>
No matter how carefully crafted your code, errors can (and probably
will) occur. Ideally, Visual Basic procedures wouldn't need error&#173;handling
code at all. Unfortunately, sometimes files are mistakenly deleted,
disk drives run out of space, or network drives disconnect unexpectedly.
Such possibilities can cause run&#173;time errors in your code.
To handle these errors, you need to add error&#173;handling code
to your procedures.
<P>
<a name="dex1"></a>
<P>
Sometimes errors can also occur within your code; this type of
error is commonly referred to as a <I>bug</I>. Minor
bugs can be frustrating or inconvenient. More severe bugs can
cause an application to stop responding to commands, possibly
requiring the user to restart the application, losing whatever
work hasn't been saved.
<P>
<a name="dex2"></a>
<P>
The process of locating and fixing bugs in your application is
known as <I>debugging</I>. Visual Basic provides several
tools to help analyze how your application operates. These debugging
tools are particularly useful in locating the source of bugs,
but you can also use the tools to experiment with changes to your
application or to learn how other applications work.
<P>
This chapter shows how to use the debugging tools included in
Visual Basic and explains how to handle <I>run&#173;time
errors</I>&nbsp;&#151; errors that occur while your
code is running and that result from attempts to complete an invalid
operation.
<P>
<FONT COLOR="#0000FF"><B>Note&nbsp;&nbsp;&nbsp;</B></FONT>The
information in this chapter applies to the Visual Basic Editor
in Microsoft Excel&nbsp;97, Word&nbsp;97, and PowerPoint&nbsp;97.
For information about debugging Visual Basic code and handling
errors in Microsoft Access&nbsp;97, see <I>Building Applications
with Microsoft Access&nbsp;97</I>, available in Microsoft Access&nbsp;97
and Microsoft Office&nbsp;97, Developer Edition. An online version
of <I>Building Applications with Microsoft Access&nbsp;97</I> is available
in the Value Pack on CD&#173;ROM in Microsoft Access&nbsp;97 and
Microsoft Office&nbsp;97, Professional Edition.
<P>
<A NAME="PG014C1"></A>
</MENU></MENU></MENU>
<!--ToTop_START-->
<TABLE width=98% cellpadding=0 cellspacing=0 border=0>


</TABLE>
<HR>
<!--ToTop_End-->
<MENU>

<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H101">How to Handle Errors</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex3"></a>
<P>
Ideally, Visual Basic procedures wouldn't need error&#173;handling
code at all. Reality dictates that hardware problems or unanticipated
actions by the user can cause run&#173;time errors that halt your
code, and there's usually nothing the user can do to resume running
the application. Other errors might not interrupt code, but they
can cause it to act unpredictably.
<P>
For example, the following procedure returns <B>True</B> if the
specified file exists and <B>False</B> if it does not, but doesn't
contain error&#173;handling code.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function FileExists (filename) As Boolean
&#09;FileExists = (Dir(filename) &lt;&gt; "")
End Function

</code></pre></FONT>
<P>
The <B>Dir</B> function returns the first file matching the specified
file name (given with or without wildcard characters, drive name,
or path); it returns a zero&#173;length string if no matching
file is found.
<P>
The code appears to cover either of the possible outcomes of the
<B>Dir</B> call. However, if the drive letter specified in the
argument is not a valid drive, the error "Device unavailable"
occurs. If the specified drive is a floppy disk drive, this function
will work correctly only if a disk is in the drive and the drive
door is closed. If not, Visual Basic presents the error "Disk
not ready" and halts execution of your code.
<P>
To avoid this situation, you can use the error&#173;handling features
in Visual Basic to intercept errors and take corrective action.
(Intercepting an error is also known as <I>trapping</I>
an error.) When an error occurs, Visual Basic sets the various
properties of the error object, <B>Err</B>, such as an error number,
a description, and so on. You can use the Err object and its properties
in an error&#173;handling routine so that your application can
respond intelligently to an error situation.
<P>
For example, device problems, such as an invalid drive or an empty
floppy disk drive, could be handled by the following example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function FileExists (filename) As Boolean
&#09;Dim Msg As String
&#09;' Turn on error trapping so error handler responds 
&#09;' if any error is detected.
&#09;On Error GoTo CheckError&#09;
&#09;&#09;FileExists = (Dir(filename) &lt;&gt; "")
&#09;&#09;' Avoid executing error handler if no error occurs.
&#09;&#09;Exit Function

CheckError:&#09;&#09;&#09;&#09;' Branch here if error occurs.
&#09;' Define constants to represent intrinsic Visual Basic error 
&#09;' codes. 
&#09;Const mnErrDiskNotReady = 71, mnErrDeviceUnavailable = 68
&#09;' vbExclamation, vbOK, vbCancel, vbCritical, and vbOKCancel are
&#09;'constants defined in the VBA type library.
&#09;If (Err.Number = MnErrDiskNotReady) Then
&#09;&#09;Msg = "Put a floppy disk in the drive and close the door."
&#09;&#09;' Display message box with an exclamation mark icon and with 
&#09;&#09;' OK and Cancel buttons.
&#09;&#09;If MsgBox(Msg, vbExclamation &amp; vbOKCancel) = vbOK Then
&#09;&#09;&#09;Resume
&#09;&#09;Else
&#09;&#09;&#09;Resume Next
&#09;&#09;End If
&#09;ElseIf Err.Number = MnErrDeviceUnavailable Then
&#09;&#09;Msg = "This drive or path does not exist: " &amp; filename
&#09;&#09;MsgBox Msg, vbExclamation
&#09;&#09;Resume Next
&#09;Else
&#09;&#09;Msg = "Unexpected error #" &amp; Str(Err.Number) &amp; " occurred: " _ 
&#09;&#09;&amp; Err.Description
&#09;&#09;' Display message box with Stop sign icon and OK button.
&#09;&#09;MsgBox Msg, vbCritical
&#09;&#09;Stop
&#09;End If
&#09;Resume
End Function

</code></pre></FONT>


In this code, the <B>Err</B> object's <B>Number</B> property contains the number associated with the run&#173;time error that occurred; the <B>Description</B> property contains a short description of the error. 

<P>
When Visual Basic generates the error "Disk not ready,"
this code presents a message telling the user to choose one of
two buttons&nbsp;&#151; <B>OK</B> or <B>Cancel</B>. If the
user chooses <B>OK</B>, the <B>Resume</B> statement returns control
to the statement at which the error occurred and attempts to re&#173;run
that statement. This succeeds if the user has corrected the problem;
otherwise, the program returns to the error handler.
<P>
If the user chooses <B>Cancel</B>, the <B>Resume Next</B> statement
returns control to the statement following the one at which the
error occurred (in this case, the <B>Exit Function</B> statement).
<P>
Should the error "Device unavailable" occur, this code
presents a message describing the problem. The <B>Resume Next</B>
statement then causes the function to continue execution at the
statement following the one at which the error occurred.
<P>
If an unanticipated error occurs, a short description of the error
is displayed and the code halts at the <B>Stop</B> statement.
<P>
The application you create can correct an error or prompt the
user to change the conditions that caused the error. To do this,
use techniques such as those shown in the preceding example. The
next section discusses these techniques in detail.
<P>
<A NAME="PG014C2"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H102">Designing an Error Handler</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex4"></a>
<P>
An <I>error handler</I> is a routine for trapping
and responding to errors in your application. You'll want to add
error handlers to any procedure where you anticipate the possibility
of an error (you should assume that any Visual Basic statement
can produce an error unless you explicitly know otherwise). The
process of designing an error handler involves three steps:
<P>

<OL>
<P>
<LI>Set, or <I>enable</I>,
an error trap by telling the application where to branch to (which
error&#173;handling routine to run) when an error occurs.
<P>
The <B>On Error</B> statement enables the trap and directs
the application to the label marking the beginning of the error&#173;handling
routine. 
<P>
In the preceding example, the FileExists function
contains an error&#173;handling routine named <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">CheckError</FONT>.
<P>
<LI>Write
an error&#173;handling routine that responds to all errors you
can anticipate. If control actually branches into the trap at
some point, the trap is then said to be <I>active</I>.
<P>
The <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">CheckError</FONT> routine handles the error using an
<B>If...Then...Else</B> statement that responds to the value in the <B>Err</B>
object's <B>Number</B> property, which is a numeric code corresponding
to a Visual Basic error. In the example, if "Disk not ready"
is generated, a message prompts the user to close the drive door.
A different message is displayed if the "Device unavailable"
error occurs. If any other error is generated, the appropriate
description is displayed and the program stops.
<P>
<LI>Exit
the error&#173;handling routine.
<P>
<A NAME="bk1">
<P>In the case of the "Disk not ready"
error, the Resume statement makes the code branch back to the
statement where the error occurred. Visual Basic then tries to
re&#173;run that statement. If the situation has not changed,
then another error occurs and execution branches back to the error&#173;handling
routine.</A>
<P>
In the case of the "Device unavailable"
error, the Resume Next statement makes the code branch to the
statement following the one at which the error occurred.
<P>
</OL>

<P>
Details on how to perform these steps are provided in the remainder
of this topic. Refer to the FileExists function in the preceding
example as you read through these steps.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H201">Setting the Error Trap</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex5"></a>
<P>
An error trap is enabled when Visual Basic runs the <B>On Error</B>
statement, which specifies an error handler. The error trap remains
enabled while the procedure containing it is active&nbsp;&#151;
that is, until an <B>Exit Sub</B>, <B>Exit Function</B>, <B>Exit
Property</B>, <B>End Sub</B>, <B>End Function</B>, or <B>End Property</B>
statement is run for that procedure. While only one error trap
can be enabled at any one time in any given procedure, you can
create several alternative error traps and enable different ones
at different times. You can also disable an error trap by using
a special case of the <B>On Error</B> statement&nbsp;&#151;
<B>On Error GoTo 0</B>. 
<P>
To set an error trap that jumps to an error&#173;handling routine,
use a <B>On Error GoTo</B> <I>line</I> statement,
where <I>line</I> indicates the label identifying
the error&#173;handling code. In the FileExists function example,
the label is <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">CheckError</FONT>.
(Although the colon is part of the label, it isn't used in the
<B>On Error GoTo</B> <I>line</I> statement.) 
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H202">Writing an Error&#173;Handling Routine</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex6"></a>
<P>
The first step in writing an error&#173;handling routine is adding
a line label to mark the beginning of the error&#173;handling
routine. The line label should have a descriptive name and must
be followed by a colon. A common convention is to place the error&#173;handling
code at the end of the procedure with an <B>Exit Sub</B>, <B>Exit
Function</B>, or <B>Exit Property</B> statement immediately before
the line label. This allows the procedure to avoid executing the
error&#173;handling code if no error occurs.
<P>
The body of the error&#173;handling routine contains the code
that actually handles the error, usually in the form of a <B>Select
Case</B> or <B>If&#133;Then&#133;Else</B> statement. You need
to determine which errors are likely to occur and provide a course
of action for each, for example, prompting the user to insert
a disk in the case of a "Disk not ready" error. An option
should always be provided to handle any unanticipated errors by
using the <B>Else</B> or <B>Case Else</B> clause&nbsp;&#151;
in the case of the FileExists function example, this option warns
the user then ends the application.
<P>
The <B>Number</B> property of the <B>Err</B> object contains a
numeric code representing the most recent run&#173;time error.
By using the <B>Err</B> object in combination with the <B>Select
Case</B> or <B>If...Then...Else</B> statement, you can take specific
action for any error that occurs.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="bk3">Exiting an Error&#173;Handling Routine</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<A NAME="bk2">The FileExists function example uses the <B>Resume</B>
statement within the error handler to re&#173;run the statement
that originally caused the error, and uses the <B>Resume Next</B>
statement to return execution to the statement following the one
at which the error occurred. There are other ways to exit an error&#173;handling
routine. Depending on the circumstances, you can do this using
any of the statements shown in the following table.</A>
<P>
<TABLE WIDTH=85% BORDER=1 BORDERCOLOR="#C0C0C0" CELLPADDING=4 CELLSPACING=0>

<TR><TD WIDTH=41% VALIGN="BOTTOM" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Statement</FONT></B></TD><TD WIDTH=59% VALIGN="BOTTOM" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Description</FONT></B>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Resume </B>[0]</FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Program execution resumes with the statement that caused the error or the most recently run call out of the procedure containing the error-handling routine. Use it to repeat an operation after correcting the condition that caused the error.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Resume Next</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Resumes program execution at the statement immediately following the one that caused the error. If the error occurred outside the procedure that contains the error handler, execution resumes at the statement immediately following the call to the procedure wherein the error occurred, if the called procedure does not have an enabled error handler.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Resume</B> <I>line</I></FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Resumes program execution at the label specified by <I>line</I>, where <I>line</I> is a line label (or nonzero line number) that must be in the same procedure as the error handler.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Err.Raise Number:= </B><I>number</I></FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Triggers a run-time error. When this statement is run within the error-handling routine, Visual Basic searches the calls list for another error-handling routine. (The <I>calls list</I> is the chain of procedures invoked to arrive at the current point of execution. For more information, see "<A HREF="#CH014H103">The Error-Handling Hierarchy</A>" later in this chapter.)</FONT>
</TD></TR>

<P>
</TABLE>
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>The Difference Between Resume and Resume Next</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex7"></a>
<P>
The difference between <B>Resume</B> and <B>Resume Next</B> is
that <B>Resume</B> continues running the application from the
statement that generated the error (the statement is re&#173;run),
while <B>Resume Next</B> continues running the application from
the statement that follows the one that generated the error. Generally,
you would use <B>Resume</B> whenever the error handler can correct
the error, and <B>Resume Next</B> when the error handler cannot.
You can write an error handler so that the existence of a run&#173;time
error is never revealed to the user or to display error messages
and allow the user to enter corrections.
<P>
The following example uses error handling to perform "safe"
division on its arguments without revealing errors that might
occur. The errors that can occur when performing division are
described in the following table.
<P>
<TABLE WIDTH=85% VALIGN="TOP" BORDER=1 BORDERCOLOR="#C0C0C0" CELLPADDING=4 CELLSPACING=0>

<TR><TD WIDTH=41% VALIGN="BOTTOM" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Error</FONT></B></TD><TD WIDTH=59% VALIGN="BOTTOM" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Cause</FONT></B>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">"Division by zero"</FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Numerator is nonzero, but the denominator is zero.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">"Overflow"</FONT></TD>
<TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Both numerator and denominator are zero (during floating-point division).</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">"Illegal procedure call"</FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Either the numerator or the denominator is a nonnumeric value (or can't be considered a numeric value).</FONT>
</TD></TR>

<P>
</TABLE>
<P>
In all three cases, the following example traps these errors and
returns <B>Null</B>.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function Divide (numer, denom) as Variant
&#09;Const mnErrDivByZero = 11, mnErrOverFlow = 6, mnErrBadCall = 5
&#09;On Error GoTo MathHandler
&#09;&#09;Divide &#09;= numer / denom
&#09;&#09;Exit Function
MathHandler:
&#09;If Err.Number = MnErrDivByZero Or Err.Number = ErrOverFlow _
&#09;Or Err = ErrBadCall Then
&#09;&#09;Divide = Null&#09;' If error was Division by zero, Overflow,
&#09;&#09;&#09;&#09;' or Illegal procedure call, return Null.
&#09;Else
&#09;&#09;' Display unanticipated error message.
&#09;&#09;MsgBox "Unanticipated error " &amp; Err.Number &amp; ": " &amp; _
&#09;&#09;Err.Description, vbExclamation
&#09;End If&#09;&#09;&#09;' In all cases, Resume Next continues
&#09;Resume Next&#09;&#09;&#09;' execution at the Exit Function statement.
End Function

</code></pre></FONT>
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B><A NAME="bk5">Resuming Execution at a Specified Line</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex8"></a>
<P>
<B>Resume Next</B> can also be used where an error occurs within
a loop, and you need to restart the operation. Or, you can use
<B>Resume</B> <I>line</I>, which returns control to
a specified line label.
<P>
The following example illustrates the use of the <B>Resume</B>
<I>line</I> statement. A variation on the FileExists
example shown earlier, this function allows the user to enter
a file specification that the function returns if the file exists.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function VerifyFile As String
&#09;Const mnErrBadFileName = 52, mnErrDriveDoorOpen = 71
&#09;Const mnErrDeviceUnavailable = 68, mnErrInvalidFileName = 64
&#09;Dim strPrompt As String, strMsg As String, strFileSpec As String
&#09;strPrompt = "Enter file specification to check:"
StartHere:
&#09;strFileSpec = "*.*"&#09;&#09;' Start with a default specification.
&#09;strMsg = strMsg &amp; vbCRLF &amp; strPrompt
&#09;' Let the user modify the default.
&#09;strFileSpec = InputBox(strMsg, "File Search", strFileSpec, 100, _
&#09;100)
&#09;' Exit if user deletes default.
&#09;If strFileSpec = "" Then Exit Function
&#09;On Error GoTo Handler
&#09;&#09;VerifyFile = Dir(FileSpec)
&#09;&#09;Exit Function
Handler:
&#09;Select Case Err.Number&#09;&#09;' Analyze error code and load message.
&#09;&#09;Case ErrInvalidFileName, ErrBadFileName
&#09;&#09;&#09;strMsg = "Your file specification was invalid; try _
&#09;&#09;&#09;another."
&#09;&#09;Case MnErrDriveDoorOpen
&#09;&#09;&#09;strMsg = "Close the disk drive door and try again."
&#09;&#09;Case MnErrDeviceUnavailable
&#09;&#09;&#09;strMsg = "The drive you specified was not found. Try _
&#09;&#09;&#09;again."
&#09;&#09;Case Else
&#09;&#09;&#09;Dim intErrNum As Integer
&#09;&#09;&#09;intErrNum = Err.Number
&#09;&#09;&#09;Err.Clear&#09;&#09;&#09' Clear the Err object.
&#09;&#09;&#09;Err.Raise Number:= intErrNum&#09;' Regenerate the error.
&#09;End Select
&#09;Resume StartHere&#09;&#09;' This jumps back to StartHere label so 
&#09;&#09;&#09;&#09;&#09;' the user can try another file name.
End Function

</code></pre></FONT>
<P>
If a file matching the specification is found, the function returns
the file name. If no matching file is found, the function returns
a zero&#173;length string. If one of the anticipated errors occurs,
a message is assigned to the <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">strMsg</FONT>
variable and execution jumps back to the label <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">StartHere</FONT>.
This gives the user another chance to enter a valid path and file
specification.
<P>
If the error is unanticipated, the <B>Case Else</B> segment regenerates
the error so that the next error handler in the calls list can
trap the error. This is necessary because if the error wasn't
regenerated, the code would continue to run at the <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Resume
StartHere</FONT> line. By regenerating the error you are
in effect causing the error to occur again; the new error will
be trapped at the next level in the call stack.
<P>
<A NAME="PG014C3"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H103">The Error&#173;Handling Hierarchy</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex9"></a>
<P>
An <I>enabled</I> error handler is one that was activated
by executing an On Error statement and hasn't yet been turned
off&nbsp;&#151; either by an <B>On Error GoTo 0</B> statement
or by exiting the procedure where it was enabled. An <I>active</I>
error handler is one in which execution is currently taking place.
To be active, an error handler must first be enabled, but not
all enabled error handlers are active. For example, after a <B>Resume</B>
statement, a handler is deactivated but still enabled.
<P>
When an error occurs within a procedure lacking an enabled error&#173;handling
routine, or within an active error&#173;handling routine, Visual
Basic searches the calls list for another enabled error&#173;handling
routine. The calls list is the sequence of calls that leads to
the currently executing procedure; it is displayed in the <B>Call
Stack</B> dialog box. You can display the <B>Call Stack</B> dialog
box only when in break mode (when you pause the execution of your
application), by clicking <B>Call Stack</B> on the <B>View</B>
menu.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H204">Searching the Calls List</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex10"></a>
<P>
Suppose that the following sequence of calls occurs:
<P>

<OL>
<P>
<LI>An event procedure calls
Procedure A.
<P>
<LI>Procedure A calls Procedure B.
<P>
<LI>Procedure
B calls Procedure C.
<P>
</OL>

<P>
While Procedure C is executing, the other procedures are pending.
If an error occurs in Procedure C and this procedure doesn't have
an enabled error handler, Visual Basic searches backward through
the pending procedures in the calls list&nbsp;&#151; first
Procedure B, then Procedure A, then the initial event procedure
(but no farther)&nbsp;&#151; and runs the first enabled error
handler it finds. If it doesn't encounter an enabled error handler
anywhere in the calls list, it presents a default unexpected error
message and halts execution.
<P>
If Visual Basic finds an enabled error&#173;handling routine,
execution continues in that routine as if the error had occurred
in the same procedure that contains the error handler. If a <B>Resume</B>
or a <B>Resume Next</B> statement is run in the error&#173;handling
routine, execution continues as shown in the following table.
<P>
<TABLE WIDTH=85% VALIGN="TOP" BORDER=1 BORDERCOLOR="#C0C0C0" CELLPADDING=4 CELLSPACING=0>

<TR><TD WIDTH=41% VALIGN="BOTTOM" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><A NAME="ThisTable"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Statement</FONT></B></A>
</TD><TD WIDTH=59% VALIGN="BOTTOM" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Result</FONT></B></TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Resume </B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">The call to the procedure that Visual Basic just searched is re-run. In the calls list given earlier, if Procedure A has an enabled error handler that includes a <B>Resume </B>statement, Visual Basic re-runs the call to Procedure B.</FONT>
</TD></TR>

<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Resume Next</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Execution returns to the statement following the last statement run in that procedure. This is the statement following the call to the procedure that Visual Basic just searched back through. In the calls list given earlier, if Procedure A has an enabled error handler that includes a <B>Resume Next </B>statement, execution returns to the statement after the call to Procedure B.</FONT>
</TD></TR>

<P>
</TABLE>
<P>
Notice that the statement run is in the procedure where the error&#173;handling
procedure is found, not necessarily in the procedure where the
error occurred. If you don't take this into account, your code
may perform in ways you don't intend. To make the code easier
to debug, you can simply go into break mode whenever an error
occurs, as explained in the section "<A HREF="#CH014H107">Turning Off Error Handling</A>"
later in this chapter.
<P>
If the error handler's range of errors doesn't include the error
that actually occurred, an unanticipated error can occur within
the procedure with the enabled error handler. In such a case,
the procedure could run endlessly, especially if the error handler
runs a <B>Resume</B> statement. To prevent such situations, use
the <B>Err</B> object's <B>Raise</B> method in a <B>Case Else</B>
statement in the handler. This actually generates an error within
the error handler, forcing Visual Basic to search through the
calls list for a handler that can deal with the error.
<P>
<A NAME="bk7">The effect of the search back through the calls
list is hard to predict, because it depends on whether <B>Resume</B>
or <B>Resume Next</B> is run in the handler that processes the
error successfully. <B>Resume</B> returns control to the most
recently run call out of the procedure containing the error handler.
<B>Resume Next</B> returns control to whatever statement immediately
follows the most recently run call out of the procedure containing
the error handler.</A>
<P>
<A NAME="Guidelines">For example, in the calls list discussed
earlier, if Procedure A has an enabled error handler and Procedure
B and C don't, an error occurring in Procedure C will be handled
by Procedure A's error handler. If that error handler uses a <B>Resume</B>
statement, upon exit, the program continues with a call to Procedure
B. However, if Procedure A's error handler uses a <B>Resume Next</B>
statement, upon exit, the program will continue with whatever
statement in Procedure A follows the call to Procedure B. In both
cases the error handler does not return directly to either the
procedure or the statement where the error originally occurred.</A>
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H205">Guidelines for Complex Error Handling</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex11"></a>
<P>
When you write large Visual Basic applications that use multiple
modules, the error&#173;handling code can get quite complex. Keep
these guidelines in mind:
<P>

<UL>
<P>
<LI>While you are debugging
your code, use the <B>Err</B> object's <B>Raise</B> method to
regenerate the error in all error handlers for cases where no
code in the handler deals with the specific error. This allows
your application to try to correct the error in other error&#173;handling
routines along the calls list. It also ensures that Visual Basic
will display an error message if an error occurs that your code
doesn't handle. When you test your code, this technique helps
you uncover the errors you aren't handling adequately.
<P>
<LI>Use
the Clear method if you need to explicitly clear the <B>Err</B>
object after handling an error. This is necessary when using inline
error handling with <B>On Error Resume Next</B>. Visual Basic
calls the <B>Clear</B> method automatically whenever it runs any
type of <B>Resume</B> statement, <B>Exit Sub</B>, <B>Exit Function</B>,
<B>Exit Property</B>, or any <B>On Error</B> statement.
<P>
<LI>If
you don't want another procedure in the calls list to trap the
error, use the <B>Stop</B> statement to force your code to terminate.
Using <B>Stop</B> lets you examine the context of the error while
refining your code in the development environment.
<P>
<LI>Write
a fail&#173;safe error&#173;handling procedure that all your error
handlers can call as a last resort for errors they cannot handle.
This fail&#173;safe procedure can perform an orderly termination
of your application by unloading forms and saving data.
<P>
<A NAME="PG014C4"></A>
</UL>

<P>


</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H104">Testing Error Handling by Generating Errors</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex12"></a>
<P>
Simulating errors is useful when you are testing your applications,
or when you want to treat a particular condition as being equivalent
to a Visual Basic run&#173;time error. For example, you might
be writing a module that uses an object defined in an external
application, and want errors returned from the object to be handled
as actual Visual Basic errors by the rest of your application.
<P>
In order to test for all possible errors, you may need to generate
some of the errors in your code. You can generate an error in
your code with the <B>Raise</B> method of the <B>Err</B> object.
The <B>Raise</B> method takes a list of named arguments that can
be passed with the method. When the code reaches a <B>Resume</B>
statement, the <B>Clear</B> method of the <B>Err</B> object is
invoked. It is necessary to regenerate the error in order to pass
it back to the previous procedure on the call stack.
<P>
You can also simulate any Visual Basic run&#173;time error by
supplying the error code for that error.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H206">Defining Your Own Errors</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
Sometimes you may want to define errors in addition to those defined
by Visual Basic. For example, an application that relies on a
modem connection might generate an error when the carrier signal
is dropped. If you want to generate and trap your own errors,
you can add your error numbers to the <B>vbObjectError</B> constant.
<P>
The <B>vbObjectError</B> constant reserves the numbers ranging
from its own offset to the sum of its offset and 512. Using a
number higher than this will ensure that your error numbers will
not conflict with future versions of Visual Basic.
<P>
To define your own error numbers, you add constants to the declarations
section of your module.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>' Error constants
Const gLostCarrier = 1 + vbObjectError + 512
Const gNoDialTone = 2 + vbObjectError + 512

</code></pre></FONT>
<P>
You can then use the <B>Raise</B> method as you would with any
of the intrinsic errors. In this case, the description property
of the <B>Err</B> object will return a standard description&nbsp;&#151;
"Application&#173;defined or object defined error."
To provide your own error description, you will need to add it
as a parameter to the <B>Raise</B> method.
<P>
<A NAME="PG014C5"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H105">Inline Error Handling</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex13"></a>
<P>
When you check for errors immediately after each line that may
cause an error, you are performing <I>inline error handling</I>.
Using inline error handling, you can write functions and statements
that return error numbers when an error occurs; raise a Visual
Basic error in a procedure and handle the error in the calling
procedure; or write a function to return a <B>Variant</B> data
type, and use the <B>Variant</B> to indicate to the calling procedure
that an error occurred.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H207">Returning Error Numbers</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex14"></a>
<P>
There are a number of ways to return error numbers. The simplest
way is to create functions and statements that return an error
number, instead of a value, if an error occurs. The following
example shows how you can use this approach in the FileExists
function example, which indicates whether or not a particular
file exists.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function FileExists (p As String) As Long
&#09;If Dir (p) &lt;&gt; " " Then
&#09;&#09;FileExists = conSuccess&#09;' Return a constant indicating 
&#09;Else&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;' the file exists.
&#09;&#09;FileExists = conFailure&#09;' Return failure constant.
&#09;End If
End Function

Dim ResultValue As Long
ResultValue = FileExists ("C:\Testfile.txt")
If ResultValue = conFailure Then
&#09;.
&#09;.&#09;' Handle the error.
&#09;.
Else
&#09;.
&#09;.&#09;' Proceed with the program.
&#09;.
End If

</code></pre></FONT>
<P>
The key to inline error handling is to test for an error immediately
after each statement or function call. In this manner, you can
design a handler that anticipates exactly the sort of error that
might arise and resolve it accordingly. This approach does not
require that an actual run&#173;time error arise.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H208">Handling Errors in the Calling Procedure</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
Another way to indicate an error condition is to raise a Visual
Basic error in the procedure itself, and handle the error in an
inline error handler in the calling procedure. The next example
shows the same FileExists procedure, raising an error number if
it is not successful. Before calling this function, the <B>On
Error Resume Next</B> statement sets the values of the <B>Err</B>
object properties when an error occurs, but without trying to
run an error&#173;handling routine.
<P>
The <B>On Error Resume Next</B> statement is followed by error&#173;handling
code. This code can check the properties of the <B>Err</B> object
to see if an error occurred. If <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Err.Number</FONT>
doesn't contain zero, an error has occurred, and the error&#173;handling
code can take the appropriate action based on the values of the
<B>Err</B> object's properties.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function FileExists (p As String)
&#09;If Dir (p) &lt;&gt; " " Then
&#09;&#09;Err.Raise conSuccess&#09;&#09;' Return a constant indicating
&#09;Else&#09;&#09;&#09;&#09;&#09;' the file exists.
&#09;&#09;Err.Raise conFailure&#09;&#09;' Raise error number conFailure.
&#09;End If
End Function

Dim ResultValue As Long
On Error Resume Next
ResultValue = FileExists ("C:\Testfile.txt")
If Err.Number = conFailure Then
&#09;.
&#09;.&#09;' Handle the error.
&#09;.
Else
&#09;.
&#09;.&#09;' Continue program.
&#09;.
End If

</code></pre></FONT>
<P>
The next example uses both the return value and one of the passed
arguments to indicate whether or not an error condition resulted
from the function call.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function Power (X As Long, P As Integer, ByRef Result As Integer) _
As Long
&#09;On Error GoTo ErrorHandler
&#09;Result = x^P
&#09;Exit Function
ErrorHandler:
&#09;Power = conFailure
End Function

' Calls the Power function.
Dim lngReturnValue As Long, lngErrorMaybe As Long
lngErrorMaybe = Power (10, 2, lngReturnValue)
If lngErrorMaybe Then
&#09;.
&#09;.&#09;' Handle the error.
&#09;.
Else
&#09;.
&#09;.&#09;' Continue program.
&#09;.
End If

</code></pre></FONT>
<P>
If the function was written simply to return either the result
value or an error code, the resulting value might be in the range
of error codes, and your calling procedure would not be able to
distinguish them. By using both the return value and one of the
passed arguments, your program can determine that the function
call failed, and take appropriate action. 
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H209">Using Variant Data Types</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex15"></a>
<P>
Another way to return inline error information is to take advantage
of the Visual Basic <B>Variant</B> data type and some related
functions. A <B>Variant</B> has a tag that indicates what type
of data is contained in the variable, and it can be tagged as
a Visual Basic error code. You can write a function to return
a <B>Variant</B>, and use this tag to indicate to the calling
procedure that an error has occurred.
<P>
The following example shows how the Power function can be written
to return a <B>Variant</B>.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function Power (X As Long, P As Integer) As Variant
&#09;On Error GoTo ErrorHandler
&#09;Power = x^P
&#09;Exit Function

ErrorHandler:
&#09;Power = CVErr(Err.Number)&#09;' Convert error code to tagged Variant.
End Function

' Calls the Power function.
Dim varReturnValue As Variant
varReturnValue = Power (10, 2)
If IsError (varReturnValue) Then
&#09;.
&#09;.&#09;' Handle the error.
&#09;.
Else
&#09;.
&#09;.&#09;' Continue program.
&#09;.
End If

</code></pre></FONT>
<P>
<A NAME="PG014C6"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H106">Centralized Error Handling</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex16"></a>
<P>
When you add error&#173;handling code to your applications, you'll
quickly discover that you're handling the same errors over and
over. With careful planning, you can reduce code size by writing
a few procedures that your error&#173;handling code can call to
handle common error situations.
<P>
The following FileErrors function shows a message appropriate
to the error that occurred and, where possible, allows the user
to choose a button to specify what action the program should take
next. It then returns code to the procedure that called it. The
value of the code indicates which action the program should take.
Note that user&#173;defined constants such as <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">MnErrDeviceUnavailable</FONT>
must be defined somewhere (either globally, or at the module level
of the module containing the procedure, or within the procedure
itself).

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Function FileErrors As Integer
&#09;Dim intMsgType As Integer, strMsg As String
&#09;Dim intResponse As Integer
&#09;' Return Value&#09;&#09;Meaning
&#09;' 0&#09;&#09;&#09;Resume
&#09;' 1&#09;&#09;&#09;Resume Next
&#09;' 2&#09;&#09;&#09;Unrecoverable error
&#09;' 3&#09;&#09;&#09;Unrecognized error
&#09;intMsgType = vbExclamation
&#09;Select Case Err.Number
&#09;&#09;Case MnErrDeviceUnavailable&#09;&#09;&#09;&#09;' Error 68
&#09;&#09;&#09;strMsg = "That device appears unavailable."
&#09;&#09;&#09;intMsgType = vbExclamation + 4
&#09;&#09;Case MnErrDiskNotReady&#09;&#09;&#09;&#09;&#09;' Error 71
&#09;&#09;&#09;strMsg = "Insert a disk in the drive and close the door."
&#09;&#09;Case MnErrDeviceIO&#09;&#09;&#09;&#09;&#09;&#09;' Error 57
&#09;&#09;&#09;strMsg = "Internal disk error."
&#09;&#09;&#09;intMsgType = vbExclamation + 4
&#09;&#09;Case MnErrDiskFull&#09;&#09;&#09;&#09;&#09;&#09;' Error 61
&#09;&#09;&#09;strMsg = "Disk is full. Continue?"
&#09;&#09;&#09;intMsgType = vbExclamation + 3&#09;&#09;
&#09;&#09;Case ErrBadFileName, ErrBadFileNameOrNumber&#09;' Error 64 &amp; 52
&#09;&#09;&#09;strMsg = "That filename is illegal."
&#09;&#09;Case ErrPathDoesNotExist&#09;&#09;&#09;&#09;' Error 76
&#09;&#09;&#09;strMsg = "That path doesn't exist."
&#09;&#09;Case ErrBadFileMode&#09;&#09;&#09;&#09;&#09;&#09;' Error 54
&#09;&#09;&#09;strMsg = "Can't open your file for that type of access."
&#09;&#09;Case ErrFileAlreadyOpen&#09;&#09;&#09;&#09;' Error 55
&#09;&#09;&#09;strMsg = "This file is already open."
&#09;&#09;Case ErrInputPastEndOfFile&#09;&#09;&#09;&#09;' Error 62
&#09;&#09;&#09;strMsg = "This file has a nonstandard end-of-file marker, "
&#09;&#09;&#09;strMsg = strMsg &amp; "or an attempt was made to read beyond "
&#09;&#09;&#09;strMsg = strMsg &amp; "the end-of-file marker."
&#09;&#09;Case Else
&#09;&#09;&#09;FileErrors = 3
&#09;&#09;&#09;Exit Function
&#09;End Select
&#09;intResponse = MsgBox (strMsg, strMmsgType, "Disk Error")
&#09;Select Case intRresponse
&#09;&#09;Case 1, 4&#09;&#09;' OK, Retry buttons.
&#09;&#09;&#09;FileErrors = 0
&#09;&#09;Case 5&#09;&#09;&#09;' Ignore button.
&#09;&#09;&#09;FileErrors = 1
&#09;&#09;Case 2, 3&#09;&#09;' Cancel, End buttons.
&#09;&#09;&#09;FileErrors = 2
&#09;&#09;Case Else
&#09;&#09;&#09;FileErrors = 3
&#09;End Select
End Function

</code></pre></FONT>
<P>
This procedure handles common file and disk&#173;related errors.
If the error is not related to disk Input/Output, it returns the
value 3. The procedure that calls this procedure should then either
handle the error itself, regenerate the error with the <B>Raise</B>
method, or call another procedure to handle it.
<P>
<FONT COLOR="#0000FF"><B>Note</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>&nbsp;&nbsp;&nbsp;As
you write larger applications, you'll find that you are using
the same constants in several procedures in various forms and
modules. Making those constants public and declaring them in a
single standard module may better organize your code and save
you from typing the same declarations repeatedly.
<P>
You can simplify error handling by calling the FileErrors procedure
wherever you have a procedure that reads or writes to disk. For
example, you've probably used applications that warn you if you
attempt to replace an existing disk file. Conversely, when you
try to open a file that doesn't exist, many applications warn
you that the file does not exist and ask if you want to create
it. In both instances, errors can occur when the application passes
the file name to the operating system.
<P>
<A NAME="PG014C7"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H107">Turning Off Error Handling</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex17"></a>
<P>
If an error trap has been enabled in a procedure, it is automatically
disabled when the procedure finishes running. However, you may
want to turn off an error trap in a procedure while the code in
that procedure is still running. To turn off an enabled error
trap, use the <B>On Error GoTo 0</B> statement. After Visual Basic
runs this statement, errors are detected but not trapped within
the procedure. You can use <B>On Error GoTo 0</B> to turn off
error handling anywhere in a procedure<A NAME="CurrentCell">&nbsp;&#151;
even within an error&#173;handling routine itself. </A>
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H210">Debugging Code with Error Handlers</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex18"></a>
<P>
When you are debugging code, you may find it confusing to analyze
its behavior when it generates errors that are trapped by an error
handler. You could comment out the <B>On Error</B> line in each
module in the project, but this is also cumbersome.
<P>
Instead, while debugging, you could turn off error handlers so
that every time there's an error, you enter break mode. To do
this, select the <B>Break on All Errors</B> option on the <B>General</B>
tab in the <B>Options</B> dialog box (<B>Tools</B> menu). With
this option selected, when an error occurs anywhere in the project,
you will enter break mode and the <B>Watch</B> window will display
the code where the error occurred. If this option is not selected,
an error may or may not cause an error message to be displayed,
depending on where the error occurred. For example, it may have
been raised by an external object referenced by your application.
If it does display a message, it may be meaningless, depending
on where the error originated.
<P>
<A NAME="PG014C8"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H108">Handling Errors in Referenced Objects</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex19"></a>
<P>
In procedures that reference one or more objects, it becomes more
difficult to determine where an error occurs, particularly if
it occurs in another application's object. For example, consider
an application that consists of a form module (MyForm), that references
a class module (MyClassA), that in turn references a Microsoft
Excel <B>Worksheet</B> object.
<P>
If the <B>Worksheet</B> object does not handle a particular error
arising in the worksheet, but regenerates it instead, Visual Basic
will pass the error to the referencing object, MyClassA. Visual
Basic automatically remaps untrapped errors arising in objects
outside of Visual Basic as error code 440.
<P>
The MyClassA object can either handle the error (which is preferable),
or regenerate it. The interface specifies that any object regenerating
an error that arises in a referenced object should not simply
propagate the error (pass as error code 440), but should instead
remap the error number to something meaningful. When you remap
the error, the number can either be a number defined by Visual
Basic that indicates the error condition, if your handler can
determine that the error is similar to a defined Visual Basic
error (for instance, overflow or division by zero), or an undefined
error number. Add the new number to the Visual Basic constant
<B>vbObjectError</B> to notify other handlers that this error
was raised by your object.
<P>
Whenever possible, a class module should try to handle every error
that arises within the module itself, and should also try to handle
errors that arise in an object it references that are not handled
by that object. However, there are some errors that it cannot
handle because it cannot anticipate them. There are also cases
where it is more appropriate for the referencing object to handle
the error, rather than the referenced object.
<P>
When an error occurs in the form module, Visual Basic raises one
of the predefined Visual Basic error numbers.
<P>
<FONT COLOR="#0000FF"><B>Note</B></FONT>&nbsp;&nbsp;&nbsp;If
you are creating a public class, be sure to clearly document the
meaning of each non&#173;Visual Basic error&#173;handler you define.
Other programmers who reference your public classes will need
to know how to handle errors raised by your objects.
<P>
When you regenerate an error, leave the <B>Err</B> object's other
properties unchanged. If the raised error is not trapped, the
<B>Source</B> and <B>Description</B> properties can be displayed
to help the user take corrective action.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H211">Handling Errors Passed from Reference
Objects</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
A class module could include the following error handler to accommodate
any error it might trap, regenerating those it is unable to resolve.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>MyServerHandler:
&#09;Select Case ErrNum
&#09;&#09;Case 7&#09;&#09;' Handle out-of-memory error.
&#09;&#09;&#09;.
&#09;&#09;&#09;.
&#09;&#09;&#09;.
&#09;&#09;Case 440&#09;&#09;' Handle external object error.
&#09;&#09;&#09;Err.Raise Number:=vbObjectError + 9999
&#09;&#09;' Error from another Visual Basic object.
&#09;&#09;Case Is &gt; vbObjectError and Is &lt; vbObjectError + 65536
&#09;&#09;&#09;ObjectError = ErrNum
&#09;&#09;Select Case ObjectError
&#09;&#09;&#09;' This object handles the error, based on error code
&#09;&#09;&#09;' documentation for the object.
&#09;&#09;&#09;Case vbObjectError + 10
&#09;&#09;&#09;.
&#09;&#09;&#09;.
&#09;&#09;&#09;.
&#09;&#09;&#09;Case Else
&#09;&#09;&#09;&#09;' Remap error as generic object error and regenerate.
&#09;&#09;&#09;&#09;Err.Raise Number:=vbObjectError + 9999
&#09;&#09;&#09;End Select
&#09;&#09;Case Else
&#09;&#09;&#09;' Remap error as generic object error and regenerate.
&#09;&#09;&#09;Err.Raise Number:=vbObjectError + 9999
&#09;End Select
&#09;Err.Clear
&#09;Resume Next

</code></pre></FONT>
<P>
The <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Case 440</FONT> statement traps errors that arise in a referenced
object outside the Visual Basic application. In this example,
the error is simply propagated using the value 9999, because it
is difficult for this type of centralized handler to determine
the cause of the error. When this error is raised, it is generally
the result of a fatal automation error (one that would cause the
component to end execution), or because an object didn't correctly
handle a trapped error. Error 440 shouldn't be propagated unless
it is a fatal error. If this trap were written for an inline handler
as discussed previously in "<A HREF="#CH014H105">Inline Error Handling</A>,"
it might be possible to determine the cause of the error and correct
it.
<P>
The statement <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Case Is &gt; vbObjectError and Is &lt; vbObjectError + 65536</FONT>
traps errors that originate in an object within the Visual Basic
application, or within the same object that contains this handler.
Only errors defined by objects will be in the range of the <B>vbObjectError</B>
offset.
<P>
The error code documentation provided for the object should define
the possible error codes and their meaning, so that this portion
of the handler can be written to intelligently resolve anticipated
errors. The actual error codes may be documented without the <B>vbObjectError</B>
offset, or they may be documented after being added to the offset,
in which case the <B>Case Else</B> statement should subtract <B>vbObjectError</B>,
rather than add it. On the other hand, object errors may be constants,
shown in the type library for the object, as shown in the Object
Browser. In that case, use the error constant in the <B>Case Else</B>
statement, instead of the error code.
<P>
Any error not handled should be regenerated with a new number,
as shown in the <B>Case Else</B> statement. Within your application,
you can design a handler to anticipate this new number you've
defined. If this were a public class, you would also want to include
an explanation of the new error&#173;handling code in your application's
documentation.
<P>
<A NAME="LastXEField">The last <B>Case Else</B> statement traps
and regenerates any other errors that are not trapped elsewhere
in the handler. Because this part of the trap will catch errors
that may or may not have the <B>vbObjectError</B> constant added,
you should simply remap these errors to a generic "unresolved
error" code. That code should be added to <B>vbObjectError</B>,
indicating to any handler that this error originated in the referenced
object.</A>
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H212">Debugging Error Handlers in Referenced
Objects</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
When you are debugging an application that has a reference to
an object created in Visual Basic or a class defined in a class
module, you may find it confusing to determine which object generates
an error. To make this easier, you can select the <B>Break in
Class Module</B> option on the <B>General</B> tab in the <B>Options</B>
dialog box (<B>Tools</B> menu). With this option selected, an
error in a class module will cause that class to enter the debugger's
break mode, allowing you to analyze the error.
<P>
<A NAME="PG014C9"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H109">Approaches to Debugging</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex20"></a>
<P>
The debugging techniques presented in this chapter use the analysis
tools provided by Visual Basic. Visual Basic cannot diagnose or
fix errors for you, but it does provide tools to help you analyze
how execution flows from one part of the procedure to another,
and how variables and property settings change as statements are
run. Debugging tools let you look inside your application to help
you determine what happens and why.
<P>
Visual Basic debugging support includes breakpoints, break expressions,
watch expressions, stepping through code one statement or one
procedure at a time, and displaying the values of variables and
properties. Visual Basic also includes special debugging features,
such as edit&#173;and&#173;continue capability, setting the next
statement to run, and procedure testing while the application
is in break mode.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H213">Kinds of Errors</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex21"></a>
<P>
To understand how debugging is useful, consider the three kinds
of errors you can encounter, described in the following paragraphs.
<P>
<B>Compile errors&nbsp;&nbsp;&nbsp;</B>These result
from incorrectly constructed code. If you incorrectly type a keyword,
omit some necessary punctuation, or use a <B>Next</B> statement
without a corresponding <B>For</B> statement at design time, Visual
Basic detects these errors when your code compiles.
<P>
<B>Run&#173;time errors&nbsp;&nbsp;&nbsp;</B>These
occur while the application is running (and are detected by Visual
Basic) when a statement attempts an operation that is impossible
to carry out. An example of this is division by zero. 
<P>
<B>Logic errors&nbsp;&nbsp;&nbsp;</B>These occur when
an application doesn't perform the way it was intended. An application
can have syntactically valid code, run without performing any
invalid operations, and yet produce incorrect results. Only by
testing the application and analyzing results can you verify that
the application is performing correctly.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H214">How Debugging Tools Help</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex22"></a>
<P>
Debugging tools are designed to help you with troubleshooting
logic and run&#173;time errors and observing the behavior of code
that has no errors.
<P>
For instance, an incorrect result may be produced at the end of
a long series of calculations. In debugging, the task is to determine
what and where something went wrong. Perhaps you forgot to initialize
a variable, chose the wrong operator, or used an incorrect formula.
<P>
There are no magic tricks to debugging, and there is no fixed
sequence of steps that works every time. Basically, debugging
helps you understand what's going on while your application runs.
Debugging tools give you a snapshot of the current state of your
application, including the values of variables, expressions, and
properties, and the names of active procedure calls. The better
you understand how your application is working, the faster you
can find bugs.
<P>
Among its many debugging tools, Visual Basic provides several
helpful buttons on the <B>Debug</B> toolbar, shown in the following
illustration.
<P>
<IMG SRC="01401.gif">
<P>
The following table briefly describes each tool's purpose. This
chapter discusses situations where each of these tools can help
you debug or analyze an application more efficiently.
<P>
<TABLE WIDTH=85% VALIGN="TOP" BORDER=1 BORDERCOLOR="#C0C0C0" CELLPADDING=4 CELLSPACING=0>

<TR><TD WIDTH=41% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Debugging tool</FONT></B></TD>
<TD WIDTH=59% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Purpose</FONT></B></TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Run</B>/<B>Continue</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Switches from design time to run time (<B>Run</B>) or switches from break mode to run time (<B>Continue</B>). (In break mode, the name of the button changes to <B>Continue</B>.)</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Break</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Switches from run time to break mode.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Reset</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Switches from break mode or run time to design time.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Toggle Breakpoint</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Defines a line in a module where Visual Basic suspends execution of the application.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Step Into</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Runs the next executable line of code in the application and steps into procedures.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Step Over</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Runs the next executable line of code in the application without stepping into procedures.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Step Out</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Runs the remainder of the current procedure and breaks at the next line in the calling procedure.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Locals Window</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Displays the current value of local variables.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Immediate Window</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Allows you to run code or query values while the application is in break mode.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Watch Window</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Displays the values of selected expressions.</FONT>
</TD></TR>

<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Quick Watch</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Lists the current value of an expression while the application is in break mode.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Call Stack</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">While in break mode, displays a dialog box that shows all procedures that have been called but not yet run to completion.</FONT>
</TD></TR>

<P>
</TABLE>
<P>
<A NAME="PG014C10"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H110">Avoiding Bugs</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex23"></a>
<P>
There are several ways to avoid creating bugs in your applications:
<P>

<UL>
<P>
<LI>Design your applications
carefully by writing down the relevant events and the way your
code will respond to each one. Give each event procedure and each
general procedure a specific, well&#173;defined purpose.
<P>
<LI>Include
numerous comments. As you go back and analyze your code, you'll
understand it much better if you state the purpose of each procedure
in comments.
<P>
<LI>Explicitly reference objects whenever
possible. Declare objects as they are listed in the <B>Classes</B>
box in the Object Browser, rather than using a <B>Variant</B>
or the generic <B>Object</B> data types.
<P>
<LI>Develop
a consistent naming scheme for the variables and objects in your
application.
<P>
<LI>One of the most common sources
of errors is incorrectly typing a variable name or confusing one
control with another. You can use <B>Option Explicit</B> to avoid
misspelling variable names.
<P>
<A NAME="PG014C11"></A>
</UL>

<P>


</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H111">Design Time, Run Time, and Break Mode</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex24"></a>
<P>
To test and debug an application, you need to understand which
of three modes you are in at any given time. You use Visual Basic
at design time to create an application, and at run time to run
it. In <I>break mode</I>, the execution of the program
is suspended so you can examine and alter data. The Visual Basic
title bar always shows you the current mode. 
<P>
The characteristics of the three modes and techniques for moving
among them are listed in the following table.
<P>
<TABLE WIDTH=85% VALIGN="TOP"  BORDER=1 BORDERCOLOR="#C0C0C0" CELLPADDING=4 CELLSPACING=0>

<TR><TD WIDTH=41% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Mode</FONT></B></TD><TD WIDTH=59% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Description</FONT></B>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Design time</FONT></TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Most of the work of creating an application is done at design time. You can design forms, draw controls, write code, and use the <B>Properties </B>window to set or view property settings. You cannot run code or use debugging tools, except for setting breakpoints and creating watch expressions.</FONT>
<P>
<FONT SIZE=2 FACE="Verdana, Arial, Helvetica">To switch to run time, click the <B>Run </B>button. To switch to break mode, click <B>Step Into </B>on the <B>Run </B>menu; the application enters break mode at the first executable statement.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Run time</FONT></TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">When an application takes control, you interact with the application the same way a user would. You can view code, but you cannot change it.</FONT>
<P>
<FONT SIZE=2 FACE="Verdana, Arial, Helvetica">To switch back to design time, click the <B>Reset </B>button. To switch to break mode, click the <B>Break </B>button.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Break mode</FONT></TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Execution is suspended while running the application. You can view and edit code, examine or modify data, restart the application, end execution, or continue execution from the same point.</FONT>
<P>
<FONT SIZE=2 FACE="Verdana, Arial, Helvetica">To switch to run time, click the <B>Continue </B>button (in break mode, the <B>Run </B>button becomes the <B>Continue </B>button). To switch to design time, click the <B>Reset </B>button.</FONT>
<P>
<FONT SIZE=2 FACE="Verdana, Arial, Helvetica">You can set breakpoints and watch expressions at design time, but other debugging tools work only in break mode. See "<A HREF="#CH014H113">Using Break Mode</A>" later in this chapter.</FONT>
</TD></TR>

<P>
</TABLE>
<P>
<A NAME="PG014C12"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H112">Using the Debugging Windows</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex25"></a>
<P>
Sometimes you can find the cause of a problem by running portions
of code. More often, however, you'll also have to analyze what's
happening to the data. You might isolate a problem in a variable
or property with an incorrect value, and then have to determine
how and why that variable or property was assigned an incorrect
value.
<P>
With the debugging windows, you can monitor the values of expressions
and variables while stepping through the statements in your application.
There are three debugging windows: the <B>Immediate</B> window,
the <B>Watch</B> window, and the <B>Locals</B> window. To display
one of these windows, either click the corresponding command on
the <B>View</B> menu, or click the corresponding button on the
<B>Debug</B> toolbar.
<P>
The <B>Immediate</B> window<I> </I>shows information
that results from debugging statements in your code, or that you
request by typing commands directly into the window. 
<P>
The <B>Watch</B> window<I> </I>shows the current <I>watch
expressions</I>, which are expressions whose values you
decide to monitor as the code runs. A <I>break expression</I>
is a watch expression that will cause Visual Basic to enter break
mode when a certain condition you define becomes true. In the
<B>Watch</B> window, the <B>Context</B> column indicates the procedure,
module, or modules in which each watch expression is evaluated.
The <B>Watch</B> window can display a value for a watch expression
only if the current statement is in the specified context. Otherwise,
the <B>Value</B> column shows a message indicating the statement
is not in context.
<P>
The <B>Locals</B> window shows the value of any variables within
the scope of the current procedure. As the execution switches
from procedure to procedure, the contents of the <B>Locals</B>
window changes to reflect only the variables applicable to the
current procedure. 
<P>
<FONT COLOR="#0000FF"><B>Tip</B></FONT>&nbsp;&nbsp;&nbsp;A
variable that represents an object appears in the Locals window
with a plus sign (+) to the left of its name. You can click the
plus sign to expand the variable, displaying the properties of
the object and their current values. If a property of the object
contains another object, that can be expanded as well. The same
holds true for variables that contain arrays or user&#173;defined
types.
<P>
<A NAME="PG014C13"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H113">Using Break Mode</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex26"></a>
<P>
At design time, you can change the design or code of an application,
but you cannot see how your changes affect the way the application
runs. At run time, you can watch how the application behaves,
but you cannot directly change the code.
<P>
Break mode halts the operation of an application and gives you
a snapshot of its condition at any moment. Variable and property
settings are preserved, so you can analyze the current state of
the application and enter changes that affect how the application
runs. When an application is in break mode, you can do the following:
<P>

<UL>
<P>
<LI>Modify code in the application.
<P>
<LI>Observe
the condition of the application's interface.
<P>
<LI>Determine
which active procedures have been called.
<P>
<LI>Watch
the values of variables, properties, and statements.
<P>
<LI>Change
the values of variables and properties.
<P>
<LI>View
or control which statement the application will run next.
<P>
<LI>Run
Visual Basic statements immediately.
<P>
<LI>Manually
control the operation of the application.
<P>
</UL>

<P>
<FONT COLOR="#0000FF"><B>Note</B></FONT>&nbsp;&nbsp;&nbsp;You
can set breakpoints and watch expressions at design time, but
other debugging tools work only in break mode.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H215">Entering Break Mode at a Problem Statement</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex27"></a>
<P>
When debugging, you may want the application to halt at the place
in the code where you think the problem might have started. This
is one reason Visual Basic provides breakpoints and <B>Stop</B>
statements. A <I>breakpoint</I> defines a statement
or set of conditions at which Visual Basic automatically stops
execution and puts the application in break mode without running
the statement containing the breakpoint.
<P>
You can enter break mode manually if you do any of the following
while the application is running:
<P>

<UL>
<P>
<LI>Press <FONT SIZE=2 FACE="Verdana, Arial, Helvetica">CTRL+BREAK</FONT>.
<P>
<LI>Choose
<B>Break</B> from the <B>Run</B> menu.
<P>
<LI>Click
the <B>Break</B> button on the toolbar.
<P>
</UL>

<P>
It's possible to break execution when the application is idle
(when it is between processing of events). When this happens,
execution does not stop at a specific line, but Visual Basic switches
to break mode anyway.
<P>
You can also enter break mode automatically when any of the following
occurs:
<P>

<UL>
<P>
<LI>A statement generates an
untrapped run&#173;time error.
<P>
<LI>A statement generates
a run&#173;time error and <B>Break on All Errors</B> was selected
in the <B>General</B> tab on the <B>Options</B> dialog box (<B>Tools</B>
menu).
<P>
<LI>A break expression defined in the <B>Add
Watch</B> dialog box changes or becomes true, depending on how
you defined it.
<P>
<LI>Execution reaches a line with
a breakpoint.
<P>
<LI>Execution reaches a <B>Stop</B>
statement.
<P>
<A NAME="CH014H216"></A></UL>

<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B>Fixing a Run&#173;Time Error and Continuing</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex28"></a>
<P>
Some run&#173;time errors result from simple oversights when entering
code; these errors are easily fixed. Frequent errors include misspelled
names and mismatched properties or methods with objects. 
<P>
Often you can enter a correction and continue program execution
with the same line that halted the application, even though you've
changed some of the code. Simply choose <B>Continue</B> from the
<B>Run</B> menu or click the <B>Continue</B> button on the toolbar.
As you continue running the application, you can verify that the
problem is fixed.
<P>
If you select the <B>Break on All Errors</B> option, Visual Basic
disables error handlers in code, so that when a statement generates
a run&#173;time error, Visual Basic enters break mode. If <B>Break
on All Errors</B> is not selected, and if an error handler exists,
it will intercept code and take corrective action.
<P>
Some changes (most commonly, changing variable declarations or
adding new variables or procedures) require you to restart the
application. When this happens, Visual Basic presents a message
that asks if you want to restart the application.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H217">Monitoring Data with Watch Expressions</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex29"></a>
<P>
As you debug your application, a calculation may not produce the
result you want or problems might occur when a certain variable
or property assumes a particular value or range of values. Many
debugging problems aren't immediately traceable to a single statement,
so you may need to observe the behavior of a variable or expression
throughout a procedure.
<P>
Visual Basic automatically monitors watch expressions&nbsp;&#151;
expressions that you define&nbsp;&#151; for you. When the
application enters break mode, these watch expressions appear
in the <B>Watch</B> window, where you can observe their values.
<P>
You can also direct watch expressions to put the application into
break mode whenever the expression's value changes or equals a
specified value. For example, instead of stepping through perhaps
tens or hundreds of loops one statement at a time, you can use
a watch expression to put the application in break mode when a
loop counter reaches a specific value. Or you may want the application
to enter break mode each time a flag in a procedure changes value.
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Adding, Editing, or Deleting a Watch Expression</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
You can add, edit, or delete a watch expression at design time
or in break mode. To add watch expressions, you can use the <B>Add
Watch</B> dialog box (<B>Debug</B> menu).
<P>
<IMG SRC="01402.gif">
<P>
You use the <B>Edit Watch</B> dialog box (<B>Debug</B> menu) to
modify or delete an existing watch expression. The <B>Add Watch</B>
and <B>Edit Watch</B> dialog boxes share the same components (except
the <B>Delete</B> button, which only appears in the <B>Edit Watch</B>
dialog box). These shared components are described in the following
table.
<P>
<TABLE WIDTH=85% VALIGN="TOP"  BORDER=1 BORDERCOLOR="#C0C0C0" CELLPADDING=4 CELLSPACING=0>

<TR><TD WIDTH=41% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Component</FONT></B></TD><TD WIDTH=59% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Description</FONT></B>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Expression </B>box</FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Contains the expression that the watch expression evaluates. The expression is a variable, a property, a function call, or any other valid expression. When you display the <B>Add Watch </B>dialog box, the <B>Expression </B>box contains the current expression (if any).</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Context </B>option group</FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Sets the scope of variables watched in the expression. Use if you have variables of the same name with different scope. You can also restrict the scope of variables in watch expressions to a specific procedure or to a specific form or module, or you can have it apply to the entire application by selecting All Procedures and All Modules. Visual Basic can evaluate a variable in a narrow context more quickly.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica"><B>Watch Type </B>option group</FONT>
</TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Sets how Visual Basic responds to the watch expression. Visual Basic can watch the expression and display its value in the <B>Watch </B>window when the application enters break mode. Or you can have the application enter break mode automatically when the expression evaluates to a true (nonzero) statement or each time the value of the expression changes.</FONT>
</TD></TR>

<P>
</TABLE>
<P>
<FONT COLOR="#0000FF"><B>Tip</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>&nbsp;&nbsp;&nbsp;You
can add a watch expression by dragging an expression from a module
to the Watch window.
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Using Quick Watch</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
While in break mode, you can check the value of a property, variable,
or expression for which you have not defined a watch expression.
To check such expressions, use the <B>Quick Watch</B> dialog box
(<B>Debug</B> menu or toolbar). The <B>Quick Watch</B> dialog
box shows the value of the selected expression in a module. To
continue watching this expression, click the <B>Add</B> button;
the <B>Watch</B> window, with relevant information from the <B>Instant
Watch</B> dialog box already entered, is displayed. If Visual
Basic cannot evaluate the value of the current expression, the
<B>Add</B> button is disabled.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H218">Using a Breakpoint to Selectively Halt
Execution</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex30"></a>
<P>
At run time, a breakpoint tells Visual Basic to halt just before
executing a specific line of code. When Visual Basic is executing
a procedure and it encounters a line of code with a breakpoint,
it switches to break mode.
<P>
You can set or remove a breakpoint in break mode or at design
time, or at run time when the application is idle. To set or remove
a breakpoint, click in the margin (the left edge of the module
window) next to a line of code. When you set a breakpoint, Visual
Basic highlights the selected line in bold, using the colors that
you specified on the <B>Editor Format</B> tab in the <B>Options</B>
dialog box (<B>Tools</B> menu).
<P>
In a module, Visual Basic indicates a breakpoint by displaying
the text on that line in bold and in the colors specified for
a breakpoint. A rectangular highlight surrounds the <I>current
statement</I>, or the next statement to be run. When the
current statement also contains a breakpoint, only the rectangular
outline highlights the line of code. After the current statement
moves to another line, the line with the breakpoint is displayed
in bold and in color again. The following illustration shows a
procedure with a breakpoint on the fourth line.
<P>
<IMG SRC="01403.gif">
<P>
After you reach a breakpoint and the application is halted, you
can examine the application's current state. Checking results
of the application is easy, because you can move the focus among
the forms and modules of your application and the debugging windows.
<P>
A breakpoint halts the application just before executing the line
that contains the breakpoint. If you want to observe what happens
when the line with the breakpoint runs, you must run at least
one more statement. To do this, use Step Into or Step Over. 
<P>
When you are trying to isolate a problem, remember that a statement
might be indirectly at fault because it assigns an incorrect value
to a variable. To examine the values of variables and properties
while in break mode, use the <B>Locals</B> window, <B>Quick Watch</B>,
watch expressions, or the <B>Immediate</B> window. 
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H219">Using Stop Statements</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex31"></a>
<P>
Placing a <B>Stop</B> statement in a procedure is an alternative
to setting a breakpoint. Whenever Visual Basic encounters a <B>Stop</B>
statement, it halts execution and switches to break mode. Although
<B>Stop</B> statements act like breakpoints, they aren't set or
cleared the same way. 
<P>
Remember that a <B>Stop</B> statement does nothing more than temporarily
halt execution, while an <B>End</B> statement halts execution,
resets variables, and returns to design time. You can always click
<B>Continue</B> on the <B>Run</B> menu to continue running the
application.
<P>
<A NAME="PG014C14"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H114">Running Selected Portions of Your Application</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex32"></a>
<P>
If you can identify the statement that caused an error, a single
breakpoint might help you locate the problem. More often, however,
you know only the general area of the code that caused the error.
A breakpoint helps you isolate that problem area. You can then
use Step Into and Step Over to observe the effect of each statement.
If necessary, you can also skip over statements or back up by
starting execution at a new line.
<P>
<TABLE WIDTH=85% VALIGN="TOP"  BORDER=1 BORDERCOLOR="#C0C0C0" CELLPADDING=4 CELLSPACING=0>

<TR><TD WIDTH=41% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Step Mode</FONT></B></TD><TD WIDTH=59% valign="Bottom" BGCOLOR="#C0C0C0"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><B><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Description</FONT></B>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Step Into</FONT></TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Run the current statement and break at the next line, even if it's in another procedure.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Step Over</FONT></TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Run the entire procedure called by the current line and break at the line following the current line.</FONT>
</TD></TR>
<TR><TD WIDTH=41% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Step Out</FONT></TD><TD WIDTH=59% VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=2 FACE="Verdana, Arial, Helvetica">Run the remainder of the current procedure and break at the statement following the one that called the procedure.</FONT>
</TD></TR>

<P>
</TABLE>
<P>
<FONT COLOR="#0000FF"><B>Note</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>&nbsp;&nbsp;&nbsp;You
must be in break mode to use these commands. They are not available
at design time or run time.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H220">Using Step Into</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex33"></a>
<P>
You can use Step Into to run code one statement at a time. (This
is also known as single stepping.) When you use Step Into to step
through code one statement at a time, Visual Basic temporarily
switches to run time, runs the current statement, and advances
to the next statement. Then it switches back to break mode. To
step through your code this way, click the <B>Step Into</B> button
on the <B>Debug</B> toolbar.
<P>
<FONT COLOR="#0000FF"><B>Note</B></FONT>&nbsp;&nbsp;&nbsp;Visual
Basic allows you to step into individual statements, even if they
are on the same line. A line of code can contain two or more statements,
separated by a colon (:). Visual Basic uses a rectangular outline
to indicate which of the statements will run next. Breakpoints
apply only to the first statement of a multiple&#173;statement
line.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H221">Using Step Over</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex34"></a>
<P>
Step Over is identical to Step Into, except when the current statement
contains a call to a procedure. Unlike Step Into, which steps
into the called procedure, Step Over runs it as a unit and then
steps to the next statement in the current procedure. To step
through your code this way, click the <B>Step Over</B> button
on the <B>Debug</B> toolbar.
<P>
Suppose, for example, that the statement calls the procedure SetAlarmTime.
If you choose Step Into, the module shows the SetAlarmTime procedure
and sets the current statement to the beginning of that procedure.
This is the better choice only if you want to analyze the code
within SetAlarmTime. If you use Step Over, the module continues
to display the current procedure. Execution advances to the statement
immediately after the call to SetAlarmTime, unless SetAlarmTime
contains a breakpoint or a Stop statement. Use Step Over if you
want to stay at the same level of code and don't need to analyze
the SetAlarmTime procedure.
<P>
You can alternate freely between Step Into and Step Over. The
command you use depends on which portions of code you want to
analyze at any given time.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H222">Using Step Out</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex35"></a>
<P>
Step Out is similar to Step Into and Step Over, except it advances
past the remainder of the code in the current procedure. If the
procedure was called from another procedure, it advances to the
statement immediately following the one that called the procedure.
To step through your code this way, click the <B>Step Out</B>
button on the <B>Debug</B> toolbar.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H223">Bypassing Sections of Code</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex36"></a>
<P>
When your application is in break mode, you can select a statement
further down in your code where you want execution to stop and
then click <B>Run To Cursor</B> on the <B>Debug</B> menu. This
lets you "step over" uninteresting sections of code,
such as large loops.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H224">Setting the Next Statement to Be Run</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex37"></a>
<P>
While debugging or experimenting with an application, you can
select a statement anywhere in the current procedure and then
click <B>Set Next Statement</B> on the <B>Debug</B> menu to skip
a certain section of code&nbsp;&#151; for instance, a section
that contains a known bug&nbsp;&#151; so you can continue
tracing other problems. Or you may want to return to an earlier
statement to test part of the application using different values
for properties or variables.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H225">Showing the Next Statement to Be Run</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
You can click <B>Show Next Statement</B> on the <B>Debug</B> menu
to place the insertion point on the line that will run next. This
feature is convenient if you've been executing code in an error
handler and aren't sure where execution will resume. The <B>Show
Next Statement</B> command is available only in break mode.
<P>
<A NAME="PG014C15"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H115">Monitoring the Call Stack</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex38"></a>
<P>
The <B>Call Stack</B> dialog box (<B>Debug</B> menu or toolbar)
shows a list of all active procedure calls; you can display the
<B>Call Stack</B> dialog box only when the application is in break
mode. <I>Active procedure calls </I>are the procedures
in the application that were started but not completed. You can
use the list of active procedure calls to help trace the operation
of an application as it runs a series of nested procedures. For
example, an event procedure can call a second procedure, which
can call a third procedure&nbsp;&#151; all before the event
procedure that started this chain is completed. Such nested procedure
calls can be difficult to follow and can complicate the debugging
process.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H226">Tracing Nested Procedures</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
The <B>Call Stack</B> dialog box lists all the active procedure
calls in a series of nested calls. It places the earliest active
procedure call at the bottom of the list and adds subsequent procedure
calls to the top of the list. The information given for each procedure
begins with the module name, followed by the name of the called
procedure. You can click the <B>Show</B> button in the <B>Call
Stack</B> dialog box to display the statement in a procedure that
passes control of the application to the next procedure in the
list.
<P>
<FONT COLOR="#0000FF"><B>Note</B></FONT>&nbsp;&nbsp;&nbsp;Because
the Call Stack dialog box doesn't indicate the variable assigned
to an instance of a class, it does not distinguish between multiple
instances of classes.
<P>
<A NAME="PG014C16"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H116">Testing Data and Procedures with the Immediate Window</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>

<P>
<a name="dex39"></a>
<P>
Sometimes when you are debugging or experimenting with an application,
you may want to run individual procedures, evaluate expressions,
or assign new values to variables or properties. You can use the
<B>Immediate</B> window to accomplish these tasks. You evaluate
expressions by printing their values in the <B>Immediate</B> window.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H227">Printing Information in the Immediate
Window</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
There are two ways to print to the <B>Immediate</B> window:
<P>

<UL>
<P>
<LI>Include <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Debug.Print</FONT>
statements in the application code.
<P>
<LI>Enter statements
that use the <B>Print</B> method directly in the <B>Immediate</B>
window.
<P>
</UL>

<P>
These printing techniques offer the following advantages over
watch expressions:
<P>

<UL>
<P>
<LI>You don't have to break
execution to get feedback on how the application is performing.
You can see data or other messages displayed as you run the application.
<P>
<LI>Feedback
is displayed in a separate area (the <B>Immediate</B> window),
so it does not interfere with output that a user sees.
<P>
</UL>

<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Printing from Application Code</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
The <B>Print</B> method sends output to the <B>Immediate</B> window
whenever you include the <B>Debug</B> object qualifier. For example,
the following statement prints the value of <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Salary</FONT>
to the <B>Immediate</B> window every time it is run.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Debug.Print "Salary = "; Salary

</code></pre></FONT>



<P>
This technique works best when there is a particular place in
your application code at which the variable (in this case, <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Salary</FONT>)
is known to change. For example, you might put the previous statement
in a loop that repeatedly alters <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Salary</FONT>.
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Printing from the Immediate Window</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
After you're in break mode, you can move the focus to the <B>Immediate</B>
window to examine data. You can evaluate any valid expression
in the <B>Immediate</B> window, including expressions involving
properties. The currently active module determines the scope.
Type a statement that uses the <B>Print</B> method and then press
<FONT SIZE=2 FACE="Verdana, Arial, Helvetica">ENTER</FONT> to see the result. A question mark (?)
is useful shorthand for the <B>Print</B> method.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H228">Assigning Values to Variables and Properties</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex40"></a>
<P>
As you start to isolate the possible cause of an error, you may
want to test the effects of particular data values. In break mode,
you can set values with statements like the following in the <B>Immediate</B>
window.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>VScroll1.Value = 100
MaxRows = 50

</code></pre></FONT>
<P>
The first statement alters a property of the <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">VScroll1</FONT>
object, and the second assigns a value to the variable <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">MaxRows</FONT>.
<P>
After you set the values of one or more properties and variables,
you can continue execution to see the results or you can test
the effect of the change on procedures.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H229">Testing Procedures with the Immediate
Window</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex41"></a>
<P>
The <B>Immediate</B> window evaluates any valid Visual Basic executable
statement, but it doesn't accept data declarations. You can enter
calls to procedures, however, which allows you to test the possible
effect of a procedure with any given set of arguments. Simply
enter a statement in the <B>Immediate</B> window (while in break
mode) as you would in a module, as shown in the following statements.
<P>

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>X = Quadratic(2, 8, 8)
DisplayGraph 50, Arr1
Form_MouseDown 1, 0, 100, 100

</code></pre></FONT>
<P>
When you press the <FONT SIZE=2 FACE="Verdana, Arial, Helvetica">ENTER</FONT> key, Visual Basic
switches to run time to run the statement, and then returns to
break mode. At that point, you can see results and test any possible
effects on variables or property values.
<P>
If <B>Option Explicit</B> is in effect (requiring all variable
declarations to be explicit), any variables you enter in the <B>Immediate</B>
window must already be declared within the current scope. Scope
applies to procedure calls just as it does to variables. You can
call any procedure within the currently active form. You can always
call a procedure in a module, unless you define the procedure
as <B>Private</B>, in which case you can call the procedure only
while executing in the module.
<P>
<a name="dex42"></a>
<P>
You can use the <B>Immediate</B> window to run a procedure repeatedly,
testing the effect of different conditions. Each separate call
of the procedure is maintained as a separate instance by Visual
Basic. This allows you to separately test variables and property
settings in each instance of the procedure. The <B>Call Stack</B>
dialog box maintains a listing of the procedures run by each command
from the <B>Immediate</B> window. Newer listings are at the top
of the list. You can use the <B>Call Stack</B> dialog box to select
any instance of a procedure, and then print the values of variables
from that procedure in the <B>Immediate</B> window.
<P>
<FONT COLOR="#0000FF"><B>Note</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>&nbsp;&nbsp;&nbsp;Although
most statements are supported in the Immediate window, a control
structure is valid only if it can be completely expressed on one
line of code; use colons to separate the statements that make
up the control structure.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H230">Checking Error Numbers</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex43"></a>
<P>
You can use the <B>Immediate</B> window to display the message
associated with a specific error number. For example, if you enter
the statement <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Error 58</FONT>
in the <B>Immediate</B> window and then press <FONT SIZE=2 FACE="Verdana, Arial, Helvetica">ENTER</FONT>
to run the statement, the appropriate error message ("File
already exists") is displayed.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H231">Tips for Using the Immediate Window</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
<a name="dex44"></a>
<P>
Here are some shortcuts you can use in the <B>Immediate</B> window:

<P>

<UL>
<P>
<LI>After you enter a statement, you can run it again by moving the insertion point back to that statement and pressing ENTER anywhere on the
line.
<P>
<LI>Before pressing ENTER, you can edit the current statement to alter its effects.
<P>
<LI>You can use the mouse or the arrow keys to move around in the <B>Immediate</B> window. Don't press ENTER unless you are at
a statement you want to run.
<P>
<LI>CTRL+HOME will take you to the top of the <B>Immediate</B> window; CTRL+END will take you to the bottom.
<P>
<LI>The HOME and END keys move to the beginning and end
of the current line.
</UL>

<A NAME="CH014H117"></A>
</MENU></MENU></MENU>
<!--TOTOP_START-->
<TABLE width=98% cellpadding=0 cellspacing=0 border=0>

</TABLE>
<HR>

<!--ToTop_End-->
<MENU>
<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H117">Special Debugging Considerations</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>
<P>
Certain events that are a common part of using Microsoft Windows
can pose special problems for debugging an application. It's important
to be aware of these special problems so they don't confuse or
complicate the debugging process.
<P>
If you remain aware of how break mode can put events at odds with
what your application expects, you can usually find solutions.
In some event procedures, you may need to use <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Debug.Print</FONT>
statements to monitor values of variables or properties instead
of using watch expressions or breakpoints. You may also need to
change the values of variables that depend on the sequence of
events. This is discussed in the following topics.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H232">Breaking Execution During a MouseDown
or KeyDown Event Procedure</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
If you break execution during a MouseDown event procedure, you
may release the mouse button or use the mouse to do any number
of tasks. When you continue execution, however, the application
assumes that the mouse button is still pressed down. You don't
get a MouseUp event until you press the mouse button down again
and then release it.
<P>
When you press the mouse button down during run time, you break
execution in the MouseDown event procedure again, assuming you
have a breakpoint there. In this scenario, you never get to the
MouseUp event. The solution is usually to remove the breakpoint
in the MouseDown procedure.
<P>
If you break execution during a KeyDown procedure, similar considerations
apply. If you retain a breakpoint in a KeyDown procedure, you
may never get a KeyUp event. 
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H233">Breaking Execution During a GotFocus or
LostFocus Event Procedure</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<P>
If you break execution during a GotFocus or LostFocus event procedure,
the timing of system messages can cause inconsistent results.
Use a <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Debug.Print</FONT>
statement instead of a breakpoint in GotFocus or LostFocus event
procedures.

<A NAME="CH014H118"></A>
</MENU></MENU></MENU>

<!--ToTop_START-->
<TABLE width=98% cellpadding=0 cellspacing=0 border=0>

</TABLE>
<HR>

<!--ToTop_End-->
<MENU>
<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH014H118">Tips for Debugging</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>
<P>
<a name="dex45"></a>
<P>
There are several ways to simplify debugging:
<P>

<UL>
<LI>When your application doesn't produce correct results, browse through
the code and try to find statements that may have caused the problem.
Set breakpoints at these statements and restart the application.

<P>
<LI>When the program halts, test the values of important variables and properties. Use <B>Quick Watch</B> or set watch expressions to monitor these values. Use the <B>Immediate</B> window to examine variables and expressions. 
<P>
<LI>Select <B>Break on All Errors</B> on the <B>General</B> tab of the <B>Options</B> dialog box (<B>Tools</B> menu) to determine where an error occurred.
Step through your code, using watch expressions and the <B>Locals</B>
window to monitor how values change as the code runs.
<P>
<LI>If an error occurs in a loop, define a break expression to determine
where the problem occurs. Use the <B>Immediate</B> window together
with <B>Set Next</B> statement to re&#173;run the loop after making
corrections.
<P>
</UL>

<BR>
</MENU></MENU></MENU>
<HR>
<!--TOTOP_START-->
<TABLE width=98% cellpadding=0 cellspacing=0 border=0>


</TABLE>
<!--ToTop_End-->

<!--EndNav_Start-->

<P>
</FONT>
</FONT></BODY>

</HTML>
