<HTML><HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chapter 13: Optimizing for Size and Speed</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant For Microsoft Word 2.0z Beta">
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR="#ffffff" TOPMARGIN=0 LEFTMARGIN=0>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->



<!--TOOLBAR_START-->
<!--TOOLBAR_END-->
<!--Header/Footer Info_START-->

<TABLE WIDTH=98% BORDER=0 CELLPADDING=0>
<TR>
<TD WIDTH=30% ALIGN=LEFT><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT COLOR=#000000 FACE="VERDANA,ARIAL,HELVETICA" Size=1>
<B>C H A P T E R &nbsp;&nbsp; 13</B></FONT></TD>
<TD WIDTH=20% ALIGN=CENTER><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT COLOR=#000000 FACE="VERDANA,ARIAL,HELVETICA" Size=1>
<B></B></FONT></TD>
<TD WIDTH=50% ALIGN=RIGHT><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT COLOR=#000000 FACE="VERDANA,ARIAL,HELVETICA" SIZE=1>
<B>Microsoft Office 97/Visual Basic Programmer's Guide</B></FONT></TD></TR>
</TABLE>
<P>
<!--Header/Footer Info_END-->

<P><!--NAV_START-->
<TABLE WIDTH="98%" BGCOLOR="#ffffff" BORDER=0 CELLSPACING=0 CELLPADDING=3>
<TR><TD VALIGN="TOP" WIDTH=60%><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B>Optimizing for Size and Speed</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2></TD>
</TR>
</TABLE><HR>
<!--NAV_END-->
<MENU><MENU><MENU>

<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Contents</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>

<UL>
<LI><A HREF="#CH013H101">General Optimization Strategies</A>
<BR>
<LI><A HREF="#CH013H102">Strategies for Optimizing Microsoft Excel</A>
<BR>
<LI><A HREF="#CH013H103">Strategies for Optimizing Microsoft Word</A>
</UL>

<A NAME="CH013H101"></A>
<a name="dex1"></a>
<P>
Visual Basic is an extremely flexible programming language: there
are often several ways to accomplish the same task. When you first
start to program, or when you write a macro that will run only
once, you'll probably be satisfied with simply "getting the
job done." When you write a macro that will be used many
times&nbsp;&#151; such as a macro that prepares a weekly report,
or an Auto_Open macro that runs every time you open a workbook
or document&nbsp;&#151; or when you write a macro that will
be used by other people, you'll probably want to <I>optimize</I>
the macro so that it requires less time and memory to run. The
techniques described in this chapter will help you write smaller,
faster macros.
<P>
<FONT COLOR="#0000FF"><B>Note&nbsp;&nbsp;&nbsp;</B></FONT>For
information about optimizing Visual Basic in Microsoft Access,
see <I>Building Applications with Microsoft Access&nbsp;97</I>, available
in Microsoft Access&nbsp;97 and Microsoft Office&nbsp;97, Developer
Edition. An online version of <I>Building Applications with Microsoft
Access&nbsp;97</I> is available in the Value Pack on CD&#173;ROM in
Microsoft Access&nbsp;97 and Microsoft Office&nbsp;97, Professional
Edition.
<P>
<A NAME="PG013C1"></A>

</MENU></MENU></MENU>

<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H101">General Optimization Strategies</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>


<P>
Use the following techniques for optimizing your Microsoft Excel,
Word, and PowerPoint code.
<P>
<FONT COLOR="#0000FF"><B>Note&nbsp;&nbsp;&nbsp;</B></FONT>Most
of the example code in this section was written in Microsoft Excel,
but the principles also apply to Word and PowerPoint. For information
about optimizing Visual Basic in Microsoft Access, see <I>Building
Applications with Microsoft Access 97</I>.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H201">Minimizing OLE References</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
<a name="dex2"></a>
<P>
Every Visual Basic method or property call requires one or more
calls through the OLE IDispatch interface. These OLE calls take
time. Minimizing the number of method or property calls is one
of the best ways to make your macro run faster.
<P>
Because you use a period (a "dot") to separate the parts
of a Visual Basic statement, an easy way to keep track of the
number of method and property calls is to "count the dots."
For example, the following statement contains three dots.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Workbooks(1).Sheets(1).Range("c5").Value = 10

</code></pre></FONT>


<P>
The following statement contains only one dot.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>ActiveWindow.Left = 200

</code></pre></FONT>

The examples in the following sections demonstrate how reducing
the number of dots creates faster&#173;running code.
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Using Object Variables</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
<a name="dex3"></a>
If you find that you're using the same object reference over and
over, you can set a variable for the object and subsequently use
the variable in place of the object reference. This way, you'll
only need to call the object accessor once, when you set the variable,
instead of calling it each time you want to refer to the object.
The following example calls the <B>Workbooks</B> method and the
<B>Sheets</B> method twice each.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Workbooks(1).Sheets(1).Range("c5").Value = 10
Workbooks(1).Sheets(1).Range("d10").Value = 12

</code></pre></FONT>



<P>
You can optimize the preceding example by setting an object variable.
The following example calls the <B>Workbooks</B> method and the
<B>Sheets</B> method only once each.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Set sheet = Workbooks(1).Sheets(1)
sheet.Range("c5").Value = 10
sheet.Range("d10").Value = 12

</code></pre></FONT>


<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Using the With Statement</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>

<a name="dex4"></a>
You can use the <B>With</B> statement to eliminate the need for
repetitive object references, without setting an explicit object
variable. The example in the preceding section could be rewritten
as follows, using the <B>With</B> statement. The following example
calls the <B>Workbooks</B> method and the <B>Sheets</B> method
only once each.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>With Workbooks(1).Sheets(1)
&#09;.Range("c5").Value = 10
&#09;.Range("d10").Value = 12
End With

</code></pre></FONT>



<P>
Using the <B>With</B> statement eliminates the need for the intermediate
variable used in the example in the preceding section; otherwise,
this code is the same as in that example.
<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Using a For Each...Next Loop</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>

<P>
<a name="dex5"></a>
<P>
Using a <B>For Each...Next</B> loop to iterate through a collection
or array is faster than using an indexed loop. In most cases,
using a <B>For Each...Next</B> loop is also more convenient and
makes your macro smaller and easier to read and debug.
<P>
The following example is slow because it sets the row variable
<FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">thisRow</FONT> by
calling <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">r.Rows(i)</FONT>
each time through the loop.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Set r = Worksheets(1).Range("a1:a200")
For i = 1 To r.Rows.Count
&#09;Set thisRow = r.Rows(i)
&#09;If thisRow.Cells(1, 1).Value &lt; 0 Then
&#09;&#09;thisRow.Font.Color = RGB(255, 0, 0)
&#09;End If
Next

</code></pre></FONT>


The following example is faster and smaller than the preceding
one because the <B>For Each...Next</B> loop keeps track of the
row count and position.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>For Each thisRow In Worksheets(1).Range("a1:a200").Rows
&#09;If thisRow.Cells(1, 1).Value &lt; 0 Then
&#09;&#09;thisRow.Font.Color = RGB(255, 0, 0)
&#09;End If
Next

</code></pre></FONT>


<P>
<FONT SIZE=3 FACE="Verdana, Arial, Helvetica"><B>Keeping Properties and Methods Outside Loops</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>

<a name="dex6"></a>
Your code can get variable values faster than it can get property
values. Therefore, if your code gets the value of a property within
a loop, it will run faster if you assign the property to a variable
outside the loop and use the variable instead of the property
inside the loop. The following example is slow because it gets
the <B>Value</B> property each time through the loop.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>For iLoop = 2 To 200
&#09;Cells(iLoop, 1).Value = Cells(1, 1).Value
Next

</code></pre></FONT>



<P>
The following example is faster than the preceding one because
the value of one property has been assigned to the variable <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">cv</FONT>
before the loop begins. Visual Basic must therefore access only
one property value (instead of two) each time through the loop.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>cv = Cells(1, 1).Value
For i Loop = 2 To 200
&#09;Cells(iLoop, 1).Value = cv
Next

</code></pre></FONT>


<a name="dex7"></a>
If you're using an object accessor inside a loop, try to move
it outside the loop. The following example calls the <B>ActiveWorkbook</B>
property, the <B>Sheets</B> property, and the <B>Cells</B> property
each time through the loop.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>For c = 1 To 1000
&#09;ActiveWorkbook.Sheets(1).Cells(c, 1) = c
Next

</code></pre></FONT>


<a
name="dex8"></a>
<P>
Rewriting this example by using the <B>With</B> statement moves
the <B>ActiveWorkbook</B> property and <B>Sheets</B> property
calls outside the loop. You could also move these calls outside
the loop by using an object variable.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>With ActiveWorkbook.Sheets(1)
&#09;For c = 1 To 1000
&#09;&#09;.Cells(c, 1) = c
&#09;Next
End With

</code></pre></FONT>



<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H202">Using Collection Index Numbers</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
<a name="dex9"></a>
<P>
With most object accessor methods and properties, you can specify
an individual object in a collection either by name or by number.
Using the object's index number is usually faster. If you use
the object's name, Visual Basic must resolve the name to the index
value; if you use the index value, you avoid this extra step.

<P>
There are, however, some significant advantages to specifying
an object in a collection by name. One advantage is that using
an object's name makes your code easier to read and debug. In
addition, specifying an object by name is safer than specifying
it by index number, because the index value for an object can
change while your code is running. For example, a menu's index
number represents the menu's position on the menu bar; therefore,
the index number can change if menus are added to or deleted from
the menu bar. This is one instance where faster isn't necessarily
better. You should use this technique only when you're sure that
the index value cannot change.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H203">Minimizing Object Activation and Selection</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
<a name="dex10"></a>
<P>
Most of the time, your code can operate on objects without activating
them. If you learned Visual Basic programming by using the macro
recorder, you're probably accustomed to activating or selecting
an object before you do anything to that object. The macro recorder
does this because it must follow your keystrokes as you activate
windows and select their contents. However, you can usually write
much simpler and faster Visual Basic code that produces the same
results without activating or selecting each object before working
with it. For example, filling cells C1:C20 on Sheet5 with random
numbers (using the <B>AutoFill</B> method) produces the macro
recorder output shown in the following example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Sheets("Sheet5").Select
Range("C1").Select
ActiveCell.FormulaR1C1 = "=RAND()"
Selection.AutoFill Destination:=Range("C1:C20"), Type:=xlFillDefault
Range("C1:C20").Select

</code></pre></FONT>


All of the <B>Select</B> method calls are unnecessary. You can
use the <B>With</B> statement to write code that operates directly
on the worksheet and the range, as shown in the following example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>With Sheets("Sheet5")
&#09;.Range("C1").FormulaR1C1 = "=RAND()"
&#09;.Range("C1").AutoFill Destination:=.Range("C1:C20"), _
&#09;&#09;Type:=xlFillDefault
End With

</code></pre></FONT>



<P>
Keep in mind that the macro recorder records exactly what you
do&nbsp;&#151; it cannot optimize anything on its own. The
recorded macro uses the <B>AutoFill</B> method because that's
how the user entered the random numbers. This isn't the most efficient
way to fill a range with random numbers. You can do the same thing
with a single line, as shown in the following example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Sheets("Sheet5").Range("C1:C20").Formula = "=RAND()"

</code></pre></FONT>


<P>
When you optimize recorded code, think about what you're trying
to do with the macro. Some of the operations you can perform in
the user interface (such as dragging a formula from a single cell
into a range) are recorded as methods (such as <B>AutoFill</B>)
that can be eliminated in the optimized code because there's a
faster way to perform the same operation in Visual Basic.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H204">Removing Unnecessary Recorded Expressions</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
<a name="dex11"></a>
<P>
Another reason why the macro recorder produces inefficient code
is that it cannot tell which options you've changed in a dialog
box. The recorder therefore explicitly sets all available options
when you close the dialog box. For example, selecting cells B2:B14
and then changing the font style to bold in the <B>Format Cells</B>
dialog box produces the recorded macro shown in the following
example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Range("B2:B14").Select
With Selection.Font
&#09;.Name = "Arial"
&#09;.FontStyle = "Bold"
&#09;.Size = 10
&#09;.Strikethrough = False
&#09;.Superscript = False
&#09;.Subscript = False
&#09;.OutlineFont = False
&#09;.Shadow = False
&#09;.Underline = xlNone
&#09;.ColorIndex = xlAutomatic
End With

</code></pre></FONT>



<P>
You can set the font style for the specified cell to bold with
a single line of code and without selecting the range, as shown
in the following example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Range("B2:B14").Font.FontStyle = "Bold"

</code></pre></FONT>


<P>
Again, if you think about what you're trying to do with the macro
and you look through the lists of properties and methods that
apply to the <B>Font</B> object, you'll see that you could also
write this macro using the <B>Bold</B> property, as shown in the
following example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Range("B2:B14").Font.Bold = True

</code></pre></FONT>

You can also experiment with the macro recorder by recording the
same operation performed different ways in the user interface.
For example, if you format a range by using the <B>Bold</B> button
on the <B>Standard</B> toolbar, the macro recorder uses the <B>Bold</B>
property.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H205">Minimizing the Use of Variant Variables</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>

Although you may find it convenient to use <B>Variant</B> variables
in your code, Visual Basic requires more time to process a value
stored in a <B>Variant</B> variable than it needs to process a
value stored in a variable declared with an explicit data type.
Your code can perform mathematical computations that don't involve
fractional values faster if you use <B>Integer</B> or <B>Long</B>
variables rather than <B>Variant</B> variables. <B>Integer</B>
or <B>Long</B> variables are also the best choice for the index
variable in <B>For...Next</B> loops. The speed you gain using
explicit variable types can come at the expense of flexibility.
For example, when using explicit data types, you may encounter
cases of overflow that <B>Variant</B> variables handle automatically.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H206">Using Specific Object Types</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>

<a name="dex12"></a>
References to objects and their methods and properties are resolved
either when your macro is compiled or when it runs. References
that are resolved when the macro is compiled are faster than references
that must be resolved while the macro is running.
<P>
If you declare variables and arguments as specific object types
(such as <B>Range</B> or <B>Worksheet</B>), Visual Basic can resolve
references to the properties and methods of those objects when
your macro is compiled. For a list of specific object types, see
the Object Browser.
<P>
In addition, you should use fully qualified object references.
This eliminates ambiguity and ensures that the variable has the
intended type. A fully qualified object reference includes the
library name, as shown in the following examples.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Dim wb As Excel.Workbook
Dim dc As Word.Document, cb As MSForms.CommandButton

</code></pre></FONT>



<P>
If you declare variables and arguments with the generic <B>Object</B>
data type, Visual Basic may have to resolve references to their
properties and methods when it encounters them at run time, resulting
in a significantly slower process.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H207">Using Constants</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>

<P>
<a name="dex13"></a>
<P>
Using constants in an application makes the application run faster.
Constants are evaluated once and are stored when your code is
compiled. Variables can change, though, so Visual Basic must get
the current variable value each time the macro runs. Constants
also make your macros more readable and easier to maintain. If
there are strings or numbers in a macro that don't change, declare
them as constants.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H208">Turning Off Screen Updating</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>


<P>
<a name="dex14"></a>
<P>
A macro that makes changes to the appearance of a document&nbsp;&#151;
such as a macro that changes the color of every other cell in
a large range or that creates a large number of graphic objects&nbsp;&#151;
will run faster when screen updating is turned off. You won't
be able to watch the macro run (the changes will appear all at
once when you turn screen updating back on), but it will run much
faster. You may want to leave screen updating turned on while
you write and debug the macro, and then turn it off before you
run the macro.
<P>
To turn off screen updating, set the <B>ScreenUpdating</B> property
to <B>False</B>, as shown in the following example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Application.ScreenUpdating = False

</code></pre></FONT>

Remember to set the <B>ScreenUpdating</B> property back to <B>True</B>
when your macro finishes running (older versions of Microsoft
Excel automatically reset this property, but Microsoft Excel&nbsp;97
and Word&nbsp;97 don't).
<P>
<B><FONT SIZE=2 COLOR=#0000FF FACE="Verdana, Arial, Helvetica">Tip&nbsp;&nbsp;&nbsp;</FONT></B>You
can sometimes achieve the same effect by not activating the object
you're changing. For example, if you create graphic objects on
a sheet without first activating the document, you don't need
to turn screen updating off because the changes won't be visible
anyway. 
<A NAME="PG013C2"></A>

</MENU></MENU></MENU>
<MENU>

<P>
<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H102">Strategies for Optimizing Microsoft Excel</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>


<a name="dex15"></a>
In addition to the general information discussed in this chapter,
you can use the following techniques to create smaller and faster
macros in Microsoft Excel.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H209">Using Worksheet Functions</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
A Microsoft Excel worksheet function that operates on a range
of cells is usually faster than a Visual Basic macro that accomplishes
the same task. For example, the SUM worksheet function is much
faster than Visual Basic code that iterates a range and adds the
values in the range's cells. For example, the following code runs
relatively slowly.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>For Each c In Worksheets(1).Range("A1:A200")
&#09;totVal = totVal + c.Value
Next

</code></pre></FONT>



<P>
The following code runs faster than the preceding example.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>totVal = Application.WorksheetFunction.Sum(Worksheets(1).Range("a1:a200"))

</code></pre></FONT>

Function that produce aggregrate results (such as PRODUCT, COUNT,
COUNTA, and COUNTIF) are good candidates for replacing slower
Visual Basic code, as are worksheet functions (such as MATCH and
LOOKUP) that can take a range as an argument.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H210">Using Special&#173;Purpose Visual Basic
Methods</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>

<a name="dex16"></a>
There are also several special&#173;purpose Visual Basic methods
that offer a concise way to perform a specific operation on a
range of cells. Like worksheet functions, these specialized methods
are faster than the general&#173;purpose Visual Basic code that
accomplishes the same task.
<P>
The following example changes the value in each cell in the range
A1:A200 in a relatively slow way.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>For Each c In Worksheets(1).Range("a1:a200").Cells
&#09;If c.Value = 4 Then c.Value = 4.5
Next

</code></pre></FONT>



<P>
<a name="dex17"></a>
<P>
The following example, which uses the <B>Replace</B> method, performs
the same operation much faster.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Worksheets(1).Range("a1:a200").Replace "4", "4.5"

</code></pre></FONT>


<P>
The following example shows a relatively slow way to add a blue
oval to each cell in the range A1:A500 that contains the value
4.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>For Each c In Worksheets(1).Range("a1:a500").Cells
&#09;If c.Value = 4 Then
&#09;&#09;With Worksheets(1).Ovals.Add(c.Left, c.Top, c.Width, c.Height)
&#09;&#09;&#09;.Interior.Pattern = xlNone
&#09;&#09;&#09;.Border.ColorIndex = 5
&#09;&#09;End With
&#09;End If
Next

</code></pre></FONT>



<P>
The following example, which uses the <B>Find</B> and <B>FindNext</B>
methods, performs the same task much faster.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>With Worksheets(1).Range("a1:a500")
&#09;Set c = .Find(4)
&#09;If Not c Is Nothing Then
&#09;&#09;firstAddress = c.Address
&#09;&#09;Do
&#09;&#09;&#09;With Worksheets(1).Ovals.Add(c.Left, c.Top, _
&#09;&#09;&#09;&#09;&#09;c.Width, c.Height)
&#09;&#09;&#09;&#09;.Interior.Pattern = xlNone
&#09;&#09;&#09;&#09;.Border.ColorIndex = 5
&#09;&#09;&#09;End With
&#09;&#09;&#09;Set c = .FindNext(c)
&#09;&#09;Loop While Not c Is Nothing And c.Address &lt;&gt; firstAddress
&#09;End If
End With

</code></pre></FONT>



<P>
<A NAME="LastXEField">For more information about special&#173;purpose
Visual Basic methods, see the topic in Help that pertains to the
object you're working with, and examine the list of that object's
methods. You can also examine the list of all Visual Basic methods
on the <B>Contents</B> tab in the <B>Help Topics</B> dialog box.</A>
<P>
<A NAME="PG013C3"></A>

</MENU></MENU></MENU>
<MENU>


<FONT SIZE=5 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H103">Strategies for Optimizing Microsoft Word</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<MENU><MENU>


<P>
<a name="dex18"></a>
<P>
In addition to the general information discussed in this chapter,
you can use the following techniques to create smaller and faster
macros in Word.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H211">Using Range Objects</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
Working with <B>Range</B> objects is faster than working with
the <B>Selection</B> object. You can define and use multiple <B>Range</B>
objects, which are invisible to the user.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H212">Using Next and Previous</A></B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
Whenever possible, use <B>Next</B> and <B>Previous</B> to return
the next or previous item in a collection. For example, using
<FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">myRange.Next Unit:=wdWord</FONT>
is faster than indexing the collection of words (<FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">myRange.Words(10)</FONT>).
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H213">Avoiding Using the WordBasic Object</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
Methods of the <B>WordBasic</B> object are slower than methods
and properties of other Visual Basic objects. For example, <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">WordBasic.FileOpen</FONT>
is slower than <FONT SIZE=2 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica">Documents.Open</FONT>.
<P>
<FONT SIZE=4 FACE="Verdana, Arial, Helvetica"><B><A NAME="CH013H214">Executing Built&#173;in Dialog Boxes</A>
</B></FONT><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
<P>
A <B>With</B> statement is an efficient way to set many properties
of a single object. Another technique for setting multiple properties
is to set the properties of a built&#173;in dialog box and then
execute the dialog box. Executing a built&#173;in dialog box is
faster than using the <B>With</B> statement because the built&#173;in
dialog box stores the property values and then sets them all at
once (using the <B>Execute</B> method), whereas the <B>With</B>
statement sets properties one at a time. The following example
sets a number of paragraph formatting properties by using a <B>With</B>
statement.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>With Selection.ParagraphFormat
&nbsp;&nbsp;&nbsp; .Alignment = wdAlignParagraphCenter
&nbsp;&nbsp;&nbsp; .KeepWithNext = True
&nbsp;&nbsp;&nbsp; .LeftIndent = InchesToPoints(0.5)
End With

</code></pre></FONT>


The following example sets the same properties as the preceding
example, but runs faster because it executes a built&#173;in dialog
box.

<FONT SIZE=3 FACE="COURIER NEW,COURIER" FACE="Verdana, Arial, Helvetica"><pre><code>Set dlg = Dialogs(wdDialogFormatParagraph)
dlg.Alignment = wdAlignParagraphCenter
dlg.KeepWithNext = True
dlg.LeftIndent = "0.5"
dlg.Execute

</code></pre></FONT>



<BR>

</MENU></MENU></MENU>
<HR>
<!--TOTOP_START-->
<TABLE width=98% cellpadding=0 cellspacing=0 border=0>


</TABLE>

<!--ToTop_End-->

<!--EndNav_Start-->

<P>
</FONT>
</FONT></BODY>



</HTML>
