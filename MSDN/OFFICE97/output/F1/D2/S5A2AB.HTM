<HTML>
<HEAD>

<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FindFirst, FindLast, FindNext, FindPrevious Methods</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->



<H1>FindFirst, FindLast, FindNext, FindPrevious Methods</H1>Applies To</P>
Dynaset-Type <SPAN CLASS="eln">Recordset</SPAN> object, <SPAN CLASS="eln">Recordset</SPAN> object, Snapshot-Type <SPAN CLASS="eln">Recordset</SPAN> object.</P>
Description</P>
Locates the first, last, next, or previous record in a dynaset- or snapshot-type Recordset object that satisfies the specified criteria and makes that record the <SPAN CLASS="pop">current record</SPAN> (<SPAN CLASS="pop">Microsoft&nbsp;Jet workspaces</SPAN> only).</P>
Syntax</P>
<SPAN CLASS="p">recordset</SPAN><SPAN CLASS="eln">.</SPAN>{<SPAN CLASS="eln">FindFirst</SPAN> | <SPAN CLASS="eln">FindLast</SPAN> | <SPAN CLASS="eln">FindNext</SPAN> | <SPAN CLASS="eln">FindPrevious</SPAN>}<SPAN CLASS="eln"> </SPAN><SPAN CLASS="p">criteria</SPAN></P>
The <SPAN CLASS="eln">Find</SPAN> methods have these parts.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="71pt" VALIGN="TOP"><COL WIDTH="289pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Part</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</P></TD></TR><TR><TD  VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"></P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="p">recordset</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">An <SPAN CLASS="pop">object variable</SPAN> that represents an existing dynaset- or snapshot-type <SPAN CLASS="eln">Recordset</SPAN> object.</P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="p">criteria</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">A <SPAN CLASS="eln">String</SPAN> used to locate the record. It is like the <SPAN CLASS="jump">WHERE clause</SPAN> in an <SPAN CLASS="pop">SQL statement</SPAN>, but without the word WHERE.</P></TD></TR></TBODY></TABLE>
<BR></P>Remarks</P>
If you want to include all the records in your search — not just those that meet a specific condition — use the <SPAN CLASS="jump">Move</SPAN> methods to move from record to record. To locate a&nbsp;record in a table-type <SPAN CLASS="eln">Recordset</SPAN>, use the <SPAN CLASS="eln">Seek</SPAN> method.</P>
If a record matching the criteria isn't located, the current record pointer is unknown, and the NoMatch property is set to <SPAN CLASS="eln">True</SPAN>. If <SPAN CLASS="p">recordset</SPAN> contains more than one record that satisfies the criteria, <SPAN CLASS="eln">FindFirst</SPAN> locates the first occurrence, <SPAN CLASS="eln">FindNext</SPAN> locates the next occurrence, and so on.</P>
Each of the Find methods begins its search from the location and in the direction specified in the following table.</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="96pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="134pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Find method</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Begins searching at</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Search direction</P></TD></TR><TR><TD  VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"></P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="eln">FindFirst</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Beginning of recordset</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">End of recordset </P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="eln">FindLast</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">End of recordset</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Beginning of recordset </P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="eln">FindNext</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Current record</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">End of recordset </P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="eln">FindPrevious</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Current record</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Beginning of recordset </P></TD></TR></TBODY></TABLE>
<BR></P>When you use the <SPAN CLASS="eln">FindLast</SPAN> method, the <SPAN CLASS="pop">Microsoft&nbsp;Jet database engine</SPAN> fully populates your <SPAN CLASS="eln">Recordset</SPAN> before beginning the search, if this hasn't already happened.</P>
Using one of the Find methods isn't the same as using a <SPAN CLASS="eln">Move</SPAN> method, however, which simply makes the first, last, next, or previous record current without specifying a condition. You can follow a Find operation with a Move operation.</P>
Always check the value of the <SPAN CLASS="eln">NoMatch </SPAN>property to determine whether the Find operation has succeeded. If the search succeeds, <SPAN CLASS="eln">NoMatch</SPAN> is <SPAN CLASS="eln">False</SPAN>. If it fails, <SPAN CLASS="eln">NoMatch</SPAN> is <SPAN CLASS="eln">True</SPAN> and the current record isn't defined. In this case, you must position the current record pointer back to a valid record.</P>
Using the <SPAN CLASS="eln">Find</SPAN> methods with <SPAN CLASS="pop">Microsoft&nbsp;Jet-connected ODBC</SPAN> -accessed recordsets can be inefficient. You may find that rephrasing your <SPAN CLASS="p">criteria</SPAN> to locate a specific record is faster, especially when working with large recordsets.</P>
In an <SPAN CLASS="pop">ODBCDirect workspace</SPAN>, the Find and <SPAN CLASS="eln">Seek</SPAN> methods are not available on any type of <SPAN CLASS="eln">Recordset</SPAN> object, because executing a Find or <SPAN CLASS="eln">Seek</SPAN> through an ODBC connection is not very efficient over the network. Instead, you should design the query (that is, using the <SPAN CLASS="p">source</SPAN> argument to the OpenRecordset method) with an appropriate WHERE clause that restricts the returned records to only those that meet the criteria you would otherwise use in a Find or <SPAN CLASS="eln">Seek</SPAN> method.</P>
When working with Microsoft&nbsp;Jet-connected ODBC databases and large dynaset-type <SPAN CLASS="eln">Recordset</SPAN> objects, you might discover that using the Find methods or using the Sort or Filter property is slow. To improve performance, use SQL queries with customized ORDER BY or WHERE clauses, <SPAN CLASS="pop">parameter queries</SPAN>, or QueryDef objects that retrieve specific indexed records.</P>
You should use the U.S. date format (month-day-year) when you search for fields containing dates, even if you're not using the U.S. version of the Microsoft&nbsp;Jet database engine; otherwise, the data may not be found. Use the Visual&nbsp;Basic <SPAN CLASS="eln">Format</SPAN>&nbsp;function to convert the date. For example:</P>

<pre><code>rstEmployees.FindFirst "HireDate &gt; #" _
    &amp; Format(mydate, 'm-d-yy' ) &amp; "#"</code></pre>
If <SPAN CLASS="p">criteria</SPAN> is composed of a string concatenated with a non-integer value, and the system parameters specify a non-U.S. decimal character such as a comma (for example, <SPAN CLASS="cte">strSQL = "PRICE &gt; " &amp; lngPrice</SPAN>, and <SPAN CLASS="cte">lngPrice = 125,50</SPAN>), an error occurs when you try to call the method. This is because during concatenation, the number will be converted to a string using your system's default decimal character, and Microsoft&nbsp;Jet SQL only accepts U.S. decimal characters.</P>
<SPAN CLASS="nh">Notes</SPAN></P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">For best performance, the <I>criteria</I> should be in either the form "<I>field </I>=<I> value</I>" where <I>field</I> is an indexed field in the underlying base table, or "<I>field</I> LIKE <I>prefix</I>" where <I>field </I>is an indexed field in the underlying base table and <I>prefix</I> is a prefix search string (for example, <SPAN CLASS="cte">"ART*"</SPAN>).</LI><LI CLASS="ULI1"><SPAN CLASS="pop">In general, for equivalent types of searches, the </SPAN><SPAN CLASS="eln">Seek</SPAN> method provides <SPAN CLASS="pop">better performance than the </SPAN>Find<SPAN CLASS="eln"> </SPAN>methods. This assumes that table-type <SPAN CLASS="eln">Recordset </SPAN>objects alone can satisfy your needs.
</LI></UL></SPAN>See Also</P>
<SPAN CLASS="eln">AbsolutePosition</SPAN> property, <SPAN CLASS="eln">Move</SPAN> method, <SPAN CLASS="eln">MoveFirst</SPAN>, <SPAN CLASS="eln">MoveLast</SPAN>, <SPAN CLASS="eln">MoveNext</SPAN>, <SPAN CLASS="eln">MovePrevious</SPAN> methods, <SPAN CLASS="eln">NoMatch</SPAN> property, <SPAN CLASS="eln">Seek</SPAN> method.</P>
Specifics (Microsoft&nbsp;Access)</P>
When specifying criteria for the Find methods, you must be careful to reference <SPAN CLASS="pop">fields</SPAN>&nbsp;and <SPAN CLASS="pop">controls</SPAN> properly, and to construct the criteria string correctly. For more information on restricting data to a subset of records and quotation marks in strings, see Domain Aggregate Functions.</P>
When you use a <SPAN CLASS="pop">bookmark</SPAN> in a Microsoft&nbsp;Access module, you must include an <SPAN CLASS="eln">Option Compare</SPAN> <SPAN CLASS="eln">Binary</SPAN> statement in the <SPAN CLASS="pop">Declarations section</SPAN> of the module. A bookmark is a <SPAN CLASS="pop">Variant</SPAN> array of <SPAN CLASS="pop">Byte</SPAN> data, so the <SPAN CLASS="pop">string comparison</SPAN> method for the&nbsp;module must be binary. If a bookmark is evaluated with a text-based string comparison method, such as the <SPAN CLASS="eln">Option Compare Text</SPAN> statement or the default setting for the <SPAN CLASS="eln">Option Compare Database</SPAN> statement, the current record may be set to&nbsp;an incorrect record.</P>
Example</P>
This example uses the <SPAN CLASS="eln">FindFirst</SPAN>, <SPAN CLASS="eln">FindLast</SPAN>, <SPAN CLASS="eln">FindNext</SPAN>, and <SPAN CLASS="eln">FindPrevious</SPAN> methods to&nbsp;move the record pointer of a <SPAN CLASS="eln">Recordset</SPAN> based on the supplied search string and command. The FindAny function is required for this procedure to run.</P>

<pre><code>Sub FindFirstX()

    Dim dbsNorthwind As Database
    Dim rstCustomers As Recordset
    Dim strCountry As String
    Dim varBookmark As Variant
    Dim strMessage As String
    Dim intCommand As Integer

    Set dbsNorthwind = OpenDatabase("Northwind.mdb")
    Set rstCustomers = dbsNorthwind.OpenRecordset( _
        "SELECT CompanyName, City, Country " &amp; _
        "FROM Customers ORDER BY CompanyName", _
        dbOpenSnapshot)

    Do While True
        ' Get user input and build search string.
        strCountry = _
            Trim(InputBox("Enter country for search."))
        If strCountry = "" Then Exit Do
        strCountry = "Country = '" &amp; strCountry &amp; "'"

        With rstCustomers
            ' Populate recordset.
            .MoveLast
            ' Find first record satisfying search string. Exit
            ' loop if no such record exists.
            .FindFirst strCountry
            If .NoMatch Then
                MsgBox "No records found with " &amp; strCountry &amp; "."
                Exit Do
            End If

            Do While True
                ' Store bookmark of current record.
                varBookmark = .Bookmark
                ' Get user choice of which method to use.
                strMessage = "Company: " &amp; !CompanyName &amp; _
                    vbCr &amp; "Location: " &amp; !City &amp; ", " &amp; _
                    !Country &amp; vbCr &amp; vbCr &amp; _
                    strCountry &amp; vbCr &amp; vbCr &amp; _
                    "[1 - FindFirst, 2 - FindLast, " &amp; _
                    vbCr &amp; "3 - FindNext, " &amp; _
                    "4 - FindPrevious]"
                intCommand = Val(Left(InputBox(strMessage), 1))
                If intCommand &lt; 1 Or intCommand &gt; 4 Then Exit Do

                ' Use selected Find method. If the Find fails,
                ' return to the last current record.
                If FindAny(intCommand, rstCustomers, _
                    strCountry) = False Then
                    .Bookmark = varBookmark
                    MsgBox "No match--returning to " &amp; _
                        "current record."
                End If

            Loop

        End With

        Exit Do
    Loop
    rstCustomers.Close
    dbsNorthwind.Close

End Sub

Function FindAny(intChoice As Integer, _
    rstTemp As Recordset, _
    strFind As String) As Boolean

    ' Use Find method based on user input.
    Select Case intChoice
        Case 1
            rstTemp.FindFirst strFind
        Case 2
            rstTemp.FindLast strFind
        Case 3
            rstTemp.FindNext strFind
        Case 4
            rstTemp.FindPrevious strFind
    End Select

    ' Set return value based on NoMatch property.
    FindAny = IIf(rstTemp.NoMatch, False, True)

End Function</code></pre>
Example (Microsoft&nbsp;Access)</P>
The following example creates a dynaset-type <SPAN CLASS="eln">Recordset</SPAN> object and then uses the <SPAN CLASS="eln">FindFirst</SPAN> method to locate the first record satisfying the specified criteria. The procedure then finds the remaining records that satisfy the criteria.</P>

<pre><code>Sub FindRecord()
    Dim dbs As Database, rst As Recordset
    Dim strCriteria As String

    ' Return reference to current database.
    Set dbs = CurrentDb
    ' Define search criteria.
    strCriteria = "[ShipCountry] = 'UK' And [OrderDate] &gt;= #1-1-95#"
    ' Create a dynaset-type Recordset object based on Orders table.
    Set rst = dbs.OpenRecordset("Orders", dbOpenDynaset)
    ' Find first matching record.
    rst.FindFirst strCriteria
    ' Check if record is found.
    If rst.NoMatch Then
        MsgBox "No record found."
    Else
        ' Find other matching records.
        Do Until rst.NoMatch
            Debug.Print rst!ShipCountry; "   "; rst!OrderDate
            rst.FindNext strCriteria
        Loop
    End If
    rst.Close
    Set dbs = Nothing
End Sub</code></pre>
<HR CLASS="rr"></FONT></BODY>
</HTML>
