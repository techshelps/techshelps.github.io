<HTML>
<HEAD>

<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Get Statement</TITLE><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>
	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->



<H2>Get Statement</H2>Description</P>
Reads data from an open disk file into a <SPAN CLASS="pop">variable</SPAN>.</P>
Syntax</P>
<SPAN CLASS="lee">Get</SPAN> [<SPAN CLASS="lee">#</SPAN>]<SPAN CLASS="p">filenumber</SPAN><SPAN CLASS="lee">, </SPAN>[<SPAN CLASS="p">recnumber</SPAN>]<SPAN CLASS="lee">, </SPAN><SPAN CLASS="p">varname</SPAN> </P>
The <SPAN CLASS="lee">Get</SPAN> statement syntax has these parts</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="296pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Part</P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Description</P></TD></TR><TR><TD COLSPAN="3" VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"></P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="p">filenumber</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Required. Any valid <SPAN CLASS="pop">file number</SPAN>.</P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="p">recnumber</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Optional. <SPAN CLASS="lee">Variant</SPAN> (<SPAN CLASS="lee">Long</SPAN>). Record number (<SPAN CLASS="lee">Random</SPAN> mode files) or byte number (<SPAN CLASS="lee">Binary</SPAN> mode files) at which reading begins.</P></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><SPAN CLASS="p">varname</SPAN></P></TD><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">Required. Valid variable name into which data is read.</P></TD></TR></TBODY></TABLE>
<BR></P>Remarks</P>
Data read with <SPAN CLASS="lee">Get</SPAN> is usually written to a file with <SPAN CLASS="lee">Put</SPAN>.</P>
The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit <SPAN CLASS="p">recnumber</SPAN>, the next record or byte following the last <SPAN CLASS="lee">Get</SPAN> or <SPAN CLASS="lee">Put</SPAN> <SPAN CLASS="pop">statement</SPAN> (or pointed to by the last <SPAN CLASS="lee">Seek</SPAN> function) is read. You must include delimiting commas, for example:</P>

<pre><code>Get #4,,FileBuffer</code></pre>
For files opened in <SPAN CLASS="lee">Random</SPAN> mode, the following rules apply:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">If the length of the data being read is less than the length specified in the <SPAN CLASS="lee">Len</SPAN> clause of the <SPAN CLASS="lee">Open</SPAN> statement, <SPAN CLASS="lee">Get</SPAN> reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data can't be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</LI><LI CLASS="ULI1">If the variable being read into is a variable-length string, <SPAN CLASS="lee">Get</SPAN> reads a 2-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the <SPAN CLASS="lee">Len</SPAN> clause in the <SPAN CLASS="lee">Open</SPAN> statement must be at least 2 bytes greater than the actual length of the string.</LI></UL></SPAN></P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">If the variable being read into is a <SPAN CLASS="lee">Variant</SPAN> of <SPAN CLASS="pop">numeric type</SPAN>, <SPAN CLASS="lee">Get</SPAN> reads 2 bytes identifying the <SPAN CLASS="lee">VarType</SPAN> of the <SPAN CLASS="lee">Variant</SPAN> and then the data that goes into the variable. For example, when reading a <SPAN CLASS="lee">Variant</SPAN> of <SPAN CLASS="lee">VarType</SPAN> 3, <SPAN CLASS="lee">Get </SPAN>reads 6 bytes: 2 bytes identifying the <SPAN CLASS="lee">Variant</SPAN> as <SPAN CLASS="lee">VarType</SPAN> 3 (<SPAN CLASS="lee">Long</SPAN>) and 4 bytes containing the <SPAN CLASS="lee">Long</SPAN> data. The record length specified by the <SPAN CLASS="lee">Len</SPAN> clause in the <SPAN CLASS="lee">Open</SPAN> statement must be at least 2 bytes greater than the actual number of bytes required to store the variable.
<SPAN CLASS="nh">Note</SPAN>&nbsp;&nbsp;&nbsp;You can use the <SPAN CLASS="lee">Get</SPAN> statement to read a <SPAN CLASS="lee">Variant</SPAN> <SPAN CLASS="pop">array</SPAN> from disk, but you can't use <SPAN CLASS="lee">Get</SPAN> to read a scalar <SPAN CLASS="lee">Variant </SPAN>containing an array. You also can't use <SPAN CLASS="lee">Get</SPAN> to read objects from&nbsp;disk.</P></LI><LI CLASS="ULI1">If the variable being read into is a <SPAN CLASS="lee">Variant</SPAN> of <SPAN CLASS="lee">VarType</SPAN> 8 (<SPAN CLASS="lee">String</SPAN>), <SPAN CLASS="lee">Get</SPAN> reads 2&nbsp;bytes identifying the <SPAN CLASS="lee">VarType</SPAN>, 2 bytes indicating the length of the string, and then reads the string data. The record length specified by the <SPAN CLASS="lee">Len</SPAN> clause in the <SPAN CLASS="lee">Open</SPAN> statement must be at least 4 bytes greater than the actual length of the string.</LI><LI CLASS="ULI1">If the variable being read into is a dynamic array, <SPAN CLASS="lee">Get</SPAN> reads a descriptor whose&nbsp;length equals 2 plus 8 times the number of dimensions, that is, 2&nbsp;+&nbsp;8&nbsp;*&nbsp;<SPAN CLASS="p">NumberOfDimensions</SPAN>. The record length specified by the <SPAN CLASS="lee">Len</SPAN> clause in&nbsp;the&nbsp;<SPAN CLASS="lee">Open</SPAN> statement must be greater than or equal to the sum of all the bytes required to read the array data and the array descriptor. For example, the following array declaration requires 118 bytes when the array is written to disk.

<pre><code>Dim MyArray(1 To 5,1 To 10) As Integer</code></pre>


The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 2).</P></LI><LI CLASS="ULI1">If the variable being read into is a fixed-size array, <SPAN CLASS="lee">Get</SPAN> reads only the data. No descriptor is read.</LI><LI CLASS="ULI1">If the variable being read into is any other type of variable (not a variable-length string or a <SPAN CLASS="lee">Variant</SPAN>), <SPAN CLASS="lee">Get</SPAN> reads only the variable data. The record length specified by the <SPAN CLASS="lee">Len</SPAN> clause in the <SPAN CLASS="lee">Open</SPAN> statement must be greater than or equal to the length of the data being read.</LI><LI CLASS="ULI1"><SPAN CLASS="lee">Get </SPAN>reads elements of <SPAN CLASS="pop">user-defined types</SPAN> as if each were being read individually,&nbsp;except that there is no padding between elements. On disk, a dynamic&nbsp;array in a user-defined type (written with <SPAN CLASS="lee">Put</SPAN>) is prefixed by a descriptor&nbsp;whose length equals 2 plus 8 times the number of dimensions, that is, 2&nbsp;+ 8 * <SPAN CLASS="p">NumberOfDimensions</SPAN>. The record length specified by the <SPAN CLASS="lee">Len</SPAN> clause in the <SPAN CLASS="lee">Open</SPAN> statement must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.
</LI></UL></SPAN>For files opened in <SPAN CLASS="lee">Binary</SPAN> mode, all of the <SPAN CLASS="lee">Random</SPAN> rules apply, except:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">The <SPAN CLASS="lee">Len</SPAN> clause in the <SPAN CLASS="lee">Open</SPAN> statement has no effect. <SPAN CLASS="lee">Get</SPAN> reads all variables from disk contiguously; that is, with no padding between records.</LI><LI CLASS="ULI1">For any array other than an array in a user-defined type, <SPAN CLASS="lee">Get</SPAN> reads only the data. No descriptor is read.</LI><LI CLASS="ULI1"><SPAN CLASS="lee">Get</SPAN> reads variable-length strings that aren't elements of user-defined types without expecting the 2-byte length descriptor. The number of bytes read equals the number of characters already in the string. For example, the following statements read 10&nbsp;bytes from <SPAN CLASS="pop">file number</SPAN> 1:

<pre><code>VarString = String(10," ")
Get #1,,VarString</code></pre>
</LI></UL></SPAN>See Also</P>
<SPAN CLASS="eln">Open</SPAN> statement, <SPAN CLASS="eln">Put</SPAN> statement, <SPAN CLASS="eln">Seek</SPAN> function, <SPAN CLASS="eln">Type</SPAN> statement, <SPAN CLASS="eln">VarType</SPAN> function.</P>
Example</P>
This example uses the <SPAN CLASS="lee">Get</SPAN> statement to read data from a file into a variable. This example assumes that <SPAN CLASS="cte">TESTFILE</SPAN> is a file containing five records of the user-defined type <SPAN CLASS="cte">Record</SPAN>.</P>

<pre><code>Type Record                                    ' Define user-defined type.
    ID As Integer
    Name As String * 20
End Type</code></pre>

<pre><code>Dim MyRecord As Record, Position        ' Declare variables.
' Open sample file for random access.
Open "TESTFILE" For Random As #1 Len = Len(MyRecord)
' Read the sample file using the Get statement.
Position = 3                                    ' Define record number.
Get #1, Position, MyRecord                ' Read third record.
Close #1                                        ' Close file.</code></pre>
<HR CLASS="rr"></FONT></BODY>
</HTML>
