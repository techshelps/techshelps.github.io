<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Opening and Displaying a .BMP File</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_opening_and_displaying_a_bmp_file"></a>Opening and Displaying a .BMP File</h2>
<p>
In the sample application, a user is able to open a .BMP file that contains a bitmapped image and display that image in the client area of the application's window. The user selects the file to be opened when the application displays the Open dialog box. For more information, see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_common_dialog_box_library">
</object><a href=JavaScript:alink_1.Click()>Common Dialog Box Library</a>. </p>
<p>
After the user selects a file and closes the dialog box, the file and path names are stored in members of the <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_openfilename_str">
</object><a href=JavaScript:alink_2.Click()><b>OPENFILENAME</b></a> structure. The application uses this data to open the appropriate file and retrieve the bitmap header and data. The following code sample can be used to retrieve this data. </p>
<pre><code>// Retrieve a handle identifying the file. 
 
hfbm = CreateFile(ofn.lpstrFile, GENERIC_READ, 
       FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES) NULL, 
       OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, 
       (HANDLE) NULL); 

// Retrieve the BITMAPFILEHEADER structure. 
 
ReadFile(hfbm, &amp;bmfh, sizeof(BITMAPFILEHEADER), &amp;dwRead, 
    (LPOVERLAPPED)NULL); 
 
// Retrieve the BITMAPFILEHEADER structure. 
 
ReadFile(hfbm, &amp;bmih, sizeof(BITMAPINFOHEADER), 
    &amp;dwRead, (LPOVERLAPPED)NULL); 
 
// Allocate memory for the BITMAPINFO structure. 
 
hmem1 = GlobalAlloc(GHND, sizeof(BITMAPINFOHEADER) + 
    ((1&lt;&lt;bmih.biBitCount) * sizeof(RGBQUAD))); 
 
lpbmi = GlobalLock(hmem1); 
 
// Load BITMAPINFOHEADER into the BITMAPINFO structure. 
 
lpbmi-&gt;bmiHeader.biSize = bmih.biSize; 
lpbmi-&gt;bmiHeader.biWidth = bmih.biWidth; 
lpbmi-&gt;bmiHeader.biHeight = bmih.biHeight; 
lpbmi-&gt;bmiHeader.biPlanes = bmih.biPlanes; 
lpbmi-&gt;bmiHeader.biBitCount = bmih.biBitCount; 
lpbmi-&gt;bmiHeader.biCompression = bmih.biCompression; 
lpbmi-&gt;bmiHeader.biSizeImage = bmih.biSizeImage; 
lpbmi-&gt;bmiHeader.biXPelsPerMeter = bmih.biXPelsPerMeter; 
lpbmi-&gt;bmiHeader.biYPelsPerMeter = bmih.biYPelsPerMeter; 
lpbmi-&gt;bmiHeader.biClrUsed = bmih.biClrUsed; 
lpbmi-&gt;bmiHeader.biClrImportant = bmih.biClrImportant; 
 
// Retrieve the color table. 
// 1 &lt;&lt; bmih.biBitCount == 2 ^ bmih.biBitCount 
 
ReadFile(hfbm, lpbmi-&gt;bmiColors, 
    ((1&lt;&lt;bmih.biBitCount) * sizeof(RGBQUAD)), 
    &amp;dwRead, (LPOVERLAPPED) NULL); 
 
// Allocate memory for the required number of bytes. 
 
hmem2 = GlobalAlloc(GHND, (bmfh.bfSize - bmfh.bfOffBits)); 
 
lpvBits = GlobalLock(hmem2); 
 
// Retrieve the bitmap data. 
 
ReadFile(hfbm, lpvBits, (bmfh.bfSize - bmfh.bfOffBits), 
    &amp;dwRead, (LPOVERLAPPED) NULL); 
 
// Create a bitmap from the data stored in the .BMP file. 
 
hbm = CreateDIBitmap(hdc, &amp;bmih, 
    CBM_INIT, lpvBits, 
    lpbmi, DIB_RGB_COLORS); 
 
// Unlock the global memory objects and close the .BMP file. 
 
GlobalUnlock(hmem1); 
GlobalUnlock(hmem2); 
CloseHandle(hfbm); 
 
// Set the fDisplayBitmap flag. 
 
if (hbm) 
    fDisplayBitmap = TRUE; 
else 
    TextOut(hdc, 100, 100, "LoadBitmap Failed", 17); 
 
// Paint the window (and draw the bitmap). 
 
GetClientRect(hwnd, &amp;rect); 
InvalidateRect(hwnd, &amp;rect, TRUE); 
UpdateWindow(hwnd); 
 </code></pre>
<p>
Once the bitmap data is retrieved, the bitmapped image can be drawn in the application's client area. The following code sample is used to draw the bitmap. </p>
<pre><code>case WM_PAINT: 
    BeginPaint(hwnd, &amp;ps); 
        if (fDisplayBitmap) 
        { 
            hdcMem = CreateCompatibleDC(ps.hdc); 
            SelectObject(hdcMem, hbm); 
            GetObject(hbm, sizeof(BITMAP), (LPSTR) &amp;bm); 
            BitBlt(ps.hdc, 0, 0, bm.bmWidth, bm.bmHeight, 
                hdcMem, 0, 0, SRCCOPY); 
            DeleteDC(hdcMem); 
        } 
    EndPaint(hwnd, &amp;ps); 
    break; 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
