<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Storing an Image</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_storing_an_image"></a>Storing an Image</h2>
<p>
Many applications store images permanently as files. For example, drawing applications store pictures, spreadsheet applications store charts, CAD applications store drawings, and so on. </p>
<p>
If you are writing an application that will store a bitmapped image in a file, you should use the bitmap file format described in <a href="bitmaps_4v1h.htm">Bitmap Storage</a>. To store a bitmap in this format, you must initialize a <a href="bitmaps_0zn6.htm"><b>BITMAPINFO</b></a> structure (consisting of a <a href="bitmaps_1rw2.htm"><b>BITMAPINFOHEADER</b></a> <a href="bitmaps_2k1e.htm"><b>BITMAPV4HEADER</b></a>, or<b> <a href="bitmaps_7c36.htm">BITMAPV5HEADER</a></b> structure and an array of <a href="bitmaps_5f8y.htm"><b>RGBQUAD</b></a> structures), as well as an array of palette indexes. </p>
<p>
The following example code defines a function that allocates memory for and initializes members within a <b>BITMAPINFOHEADER</b> structure. </p>
<pre><code>PBITMAPINFO CreateBitmapInfoStruct(HWND hwnd, HBITMAP hBmp)
{ 
    BITMAP bmp; 
    PBITMAPINFO pbmi; 
    WORD    cClrBits; 

    // Retrieve the bitmap's color format, width, and height. 
    if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&amp;bmp)) 
        errhandler("GetObject", hwnd); 

    // Convert the color format to a count of bits. 
    cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel); 
    if (cClrBits == 1) 
        cClrBits = 1; 
    else if (cClrBits &lt;= 4) 
        cClrBits = 4; 
    else if (cClrBits &lt;= 8) 
        cClrBits = 8; 
    else if (cClrBits &lt;= 16) 
        cClrBits = 16; 
    else if (cClrBits &lt;= 24) 
        cClrBits = 24; 
    else cClrBits = 32; 

    // Allocate memory for the BITMAPINFO structure. (This structure 
    // contains a BITMAPINFOHEADER structure and an array of RGBQUAD 
    // data structures.) 

     if (cClrBits != 24) 
         pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                    sizeof(BITMAPINFOHEADER) + 
                    sizeof(RGBQUAD) * (1&lt;&lt; cClrBits)); 

     // There is no RGBQUAD array for the 24-bit-per-pixel format. 

     else 
         pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                    sizeof(BITMAPINFOHEADER)); 

    // Initialize the fields in the BITMAPINFO structure. 

    pbmi-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
    pbmi-&gt;bmiHeader.biWidth = bmp.bmWidth; 
    pbmi-&gt;bmiHeader.biHeight = bmp.bmHeight; 
    pbmi-&gt;bmiHeader.biPlanes = bmp.bmPlanes; 
    pbmi-&gt;bmiHeader.biBitCount = bmp.bmBitsPixel; 
    if (cClrBits &lt; 24) 
        pbmi-&gt;bmiHeader.biClrUsed = (1&lt;&lt;cClrBits); 

    // If the bitmap is not compressed, set the BI_RGB flag. 
    pbmi-&gt;bmiHeader.biCompression = BI_RGB; 

    // Compute the number of bytes in the array of color 
    // indices and store the result in biSizeImage. 
    pbmi-&gt;bmiHeader.biSizeImage = (pbmi-&gt;bmiHeader.biWidth + 7) /8 
                                  * pbmi-&gt;bmiHeader.biHeight </code></pre>
<ul>
<li>
<code>cClrBits; </code></li>
</ul>
<pre><code>// Set biClrImportant to 0, indicating that all of the 
    // device colors are important. 
     pbmi-&gt;bmiHeader.biClrImportant = 0; 
     return pbmi; 
 } 
 </code></pre>
<p>
The following example code defines a function that initializes the remaining structures, retrieves the array of palette indices, opens the file, copies the data, and closes the file. </p>
<pre><code>void CreateBMPFile(HWND hwnd, LPTSTR pszFile, PBITMAPINFO pbi, 
                  HBITMAP hBMP, HDC hDC) 
 { 
     HANDLE hf;                 // file handle 
    BITMAPFILEHEADER hdr;       // bitmap file-header 
    PBITMAPINFOHEADER pbih;     // bitmap info-header 
    LPBYTE lpBits;              // memory pointer 
    DWORD dwTotal;              // total count of bytes 
    DWORD cb;                   // incremental count of bytes 
    BYTE *hp;                   // byte pointer 
    DWORD dwTmp; 

    pbih = (PBITMAPINFOHEADER) pbi; 
    lpBits = (LPBYTE) GlobalAlloc(GMEM_FIXED, pbih-&gt;biSizeImage);

    if (!lpBits) 
         errhandler("GlobalAlloc", hwnd); 

    // Retrieve the color table (RGBQUAD array) and the bits 
    // (array of palette indices) from the DIB. 
    if (!GetDIBits(hDC, hBMP, 0, (WORD) pbih-&gt;biHeight, lpBits, pbi, 
        DIB_RGB_COLORS)) 
    {
        errhandler("GetDIBits", hwnd); 
    }

    // Create the .BMP file. 
    hf = CreateFile(pszFile, 
                   GENERIC_READ | GENERIC_WRITE, 
                   (DWORD) 0, 
                    NULL, 
                   CREATE_ALWAYS, 
                   FILE_ATTRIBUTE_NORMAL, 
                   (HANDLE) NULL); 
    if (hf == INVALID_HANDLE_VALUE) 
        errhandler("CreateFile", hwnd); 
    hdr.bfType = 0x4d42;        // 0x42 = "B" 0x4d = "M" 
    // Compute the size of the entire file. 
    hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + 
                 pbih-&gt;biSize + pbih-&gt;biClrUsed 
                 * sizeof(RGBQUAD) + pbih-&gt;biSizeImage); 
    hdr.bfReserved1 = 0; 
    hdr.bfReserved2 = 0; 

    // Compute the offset to the array of color indices. 
    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + 
                    pbih-&gt;biSize + pbih-&gt;biClrUsed 
                    * sizeof (RGBQUAD); 

    // Copy the BITMAPFILEHEADER into the .BMP file. 
    if (!WriteFile(hf, (LPVOID) &amp;hdr, sizeof(BITMAPFILEHEADER), 
        (LPDWORD) &amp;dwTmp,  NULL)) 
    {
       errhandler("WriteFile", hwnd); 
    }

    // Copy the BITMAPINFOHEADER and RGBQUAD array into the file. 
    if (!WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER) 
                  + pbih-&gt;biClrUsed * sizeof (RGBQUAD), 
                  (LPDWORD) &amp;dwTmp, ( NULL)) 
        errhandler("WriteFile", hwnd); 

    // Copy the array of color indices into the .BMP file. 
    dwTotal = cb = pbih-&gt;biSizeImage; 
    hp = lpBits; 
    if (!WriteFile(hf, (LPSTR) hp, (int) cb, (LPDWORD) &amp;dwTmp,NULL)) 
           errhandler("WriteFile", hwnd); 

    // Close the .BMP file. 
     if (!CloseHandle(hf)) 
           errhandler("CloseHandle", hwnd); 

    // Free memory. 
    GlobalFree((HGLOBAL)lpBits);
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
