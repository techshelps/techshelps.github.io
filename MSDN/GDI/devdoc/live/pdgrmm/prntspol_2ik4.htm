<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Printing a Document</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_printing_a_document"></a>Printing a Document</h2>
<p>
Once the application initializes the necessary variables, registers its <a href="prntspol_21lv.htm"><b>AbortProc</b></a><b> </b>function, and displays its modeless Cancel dialog box, it can start the print job by calling the <a href="prntspol_95sz.htm"><b>StartDoc</b></a> function. </p>
<p>
After the application begins a print job, it can define individual pages in the document by calling the <a href="prntspol_2isl.htm"><b>StartPage</b></a> and <a href="prntspol_3b1h.htm"><b>EndPage</b></a> functions and embedding the appropriate calls to GDI drawing functions within this bracket. After the application has defined the last page, it can close the document and end the print job by calling the <a href="prntspol_0qhv.htm"><b>EndDoc</b></a> function. </p>
<p>
The following example shows the code required to print a string of text and a bitmapped image. The string of text, centered at the top of the page, identifies the path and filename for the file that contains the bitmapped image. The bitmapped image, centered vertically and horizontally on the page, is drawn so that the same proportions used to draw the image in the application's window are maintained. </p>
<pre><code>// Initialize the members of a DOCINFO structure. 
 
    di.cbSize = sizeof(DOCINFO); 
    di.lpszDocName = "Bitmap Printing Test"; 
    di.lpszOutput = (LPTSTR) NULL; 
    di.lpszDataType = (LPTSTR) NULL; 
    di.fwType = 0; 
 
    // Begin a print job by calling the StartDoc function. 
 
    nError = StartDoc(pd.hDC, &amp;di); 
    if (nError == SP_ERROR) 
    { 
        errhandler("StartDoc", hwnd); 
        goto Error; 
    } 
 
    // Inform the driver that the application is about to begin 
    // sending data. 
 
    nError = StartPage(pd.hDC); 
    if (nError &lt;= 0) 
    { 
        errhandler("StartPage", hwnd); 
        goto Error; 
    } 
 
    // Retrieve the number of pixels-per-logical-inch in the 
    // horizontal and vertical directions for the display upon which 
    // the bitmap was created. 
 
    fLogPelsX1 = (float) GetDeviceCaps(pd.hDC, LOGPIXELSX); 
    fLogPelsY1 = (float) GetDeviceCaps(pd.hDC, LOGPIXELSY); 
 
    // Retrieve the number of pixels-per-logical-inch in the 
    // horizontal and vertical directions for the printer upon which 
    // the bitmap will be printed. 
 
    fLogPelsX2 = (float) GetDeviceCaps(pd.hDC, LOGPIXELSX); 
    fLogPelsY2 = (float) GetDeviceCaps(pd.hDC, LOGPIXELSY); 
 
    // Determine the scaling factors required to print the bitmap and 
    // retain its original proportions. 
 
    if (fLogPelsX1 &gt; fLogPelsX2) 
        fScaleX = (fLogPelsX1 / fLogPelsX2); 
    else fScaleX = (fLogPelsX2 / fLogPelsX1); 
 
    if (fLogPelsY1 &gt; fLogPelsY2) 
        fScaleY = (fLogPelsY1 / fLogPelsY2); 
    else fScaleY = (fLogPelsY2 / fLogPelsY1); 
 
    // Compute the coordinates of the upper left corner of the 
    // centered bitmap. 
 
    cWidthPels = GetDeviceCaps(pd.hDC, HORZRES); 
    xLeft = ((cWidthPels / 2) - ((int) (((float) bmih.biWidth) 
            * fScaleX)) / 2); 
    cHeightPels = GetDeviceCaps(pd.hDC, VERTRES); 
    yTop = ((cHeightPels / 2) - ((int) (((float) bmih.biHeight) 
            * fScaleY)) / 2); 
 
    // Create a memory DC that is compatible with the printer and 
    // select the bitmap (which the user requested) into this DC. 
 
    hdcMem = CreateCompatibleDC(pd.hDC); 
 
    if (!SelectObject(hdcMem, hbm)) 
        errhandler("SelectObject Failed", hwnd); 
 
    // Use the StretchBlt function to scale the bitmap and maintain 
    // its original proportions (that is, if the bitmap was square 
    // when it appeared in the application's client area, it should 
    // also appear square on the page). 
 
    if(!StretchBlt(pd.hDC, xLeft, yTop, (int) ((float) bmih.biWidth * 
        fScaleX), (int) ((float) bmih.biHeight * fScaleY), 
        hdcMem, 0, 0, bmih.biWidth, bmih.biHeight, SRCCOPY)) 
    {
        errhandler("StretchBlt Failed", hwnd); 
    }
 
    // Delete the memory DC. 
 
    DeleteDC(hdcMem); 
 
    // Retrieve the width of the string that specifies the full path 
    // and filename for the file that contains the bitmap. 
 
    GetTextExtentPoint32(pd.hDC, ofn.lpstrFile, 
        ofn.nFileExtension + 3, &amp;szMetric); 
 
    // Compute the starting point for the text-output operation. The 
    // string will be centered horizontally and positioned three lines 
    // down from the top of the page. 
 
    xLeft = ((cWidthPels / 2) - (szMetric.cx / 2)); 
    yTop = (szMetric.cy * 3); 
 
    // Print the path and filename for the bitmap, centered at the top 
    // of the page. 
 
    TextOut(pd.hDC, xLeft, yTop, ofn.lpstrFile, 
        ofn.nFileExtension + 3); 
 
    // Determine whether the user has pressed the Cancel button in the 
    // AbortPrintJob dialog box; if the button has been pressed, call 
    // the AbortDoc function. Otherwise, inform the spooler that the 
    // page is complete. 
 
    nError = EndPage(pd.hDC); 
 
    if (nError &lt;= 0) 
    { 
        errhandler("EndPage", hwnd); 
        goto Error; 
    } 
 
    // Inform the driver that document has ended. 
 
    nError = EndDoc(pd.hDC); 
    if (nError &lt;= 0) 
        errhandler("EndDoc", hwnd); 
 
Error: 
    // Enable the application's window. 
 
    EnableWindow(hwnd, TRUE); 
 
    // Remove the AbortPrintJob dialog box. 
 
    DestroyWindow(hdlgCancel); 
 
    // Delete the printer DC. 
 
    DeleteDC(pd.hDC); 
 </code></pre>
<p>
Because the pixels on a screen typically have different dimensions than the dots on a printer, it is necessary to scale bitmapped images to obtain a WYSIWYG effect. This is done by obtaining horizontal and vertical scaling factors and then applying those factors to the width and height values passed to the <a href="bitmaps_9cok.htm"><b>StretchBlt</b></a> function. In the sample application, the scaling factors were obtained by retrieving the horizontal and vertical logical-pixel count for the two devices. Once the scaling factors were obtained, they were used to adjust the bitmap width and height. </p>
<p>
To center the bitmap on the page, the application first computed the width and height of the scaled bitmap. (The bitmap was scaled to maintain the original proportions of the image.) These values were divided by two and then subtracted from half of the width and height of the page. The result defines the coordinates of the upper left corner of the bitmap. </p>
<p>
To center the text at the top of the page, the application called the <a href="fontext_8smq.htm"><b>GetTextExtentPoint32</b></a> function to retrieve the width and height of the string specifying the path names and filenames. Once these values were obtained, the application used the height to position the string three lines down the page and the width to position the string horizontally centered on the page. </p>
<p>
The following illustration shows a representation of the page that appeared when the application printed the bitmapped image in the WINLOGO.BMP file. This illustration also depicts the variables used to position the text and to position and scale the bitmap. </p>
<p>
<img src="images/cspsp_01.gif" border=0></p>
<p>&nbsp;</p></body>
</HTML>
