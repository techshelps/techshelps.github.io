<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EnumDisplayMonitors</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_enumdisplaymonitors"></a>EnumDisplayMonitors</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The <b>EnumDisplayMonitors</b> function enumerates the display monitors that intersect a region formed by the intersection of a specified clipping rectangle and the visible region of a device context. <b>EnumDisplayMonitors</b> calls an application-defined <a href="monitor_0alf.htm"><i>MonitorEnumProc</i></a> callback function once for each display monitor that intersects the region. </p>
<pre><code><b>BOOL EnumDisplayMonitors (
</b>  <b>HDC</b> <i>hdc</i><b>,</b>                   // handle to a display device context 
  <b>LPCRECT</b> <i>lprcClip</i><b>,</b>          // specifies a clipping rectangle 
  <b>MONITORENUMPROC</b> <i>lpfnEnum</i><b>,</b>  // pointer to a callback function
  <b>LPARAM</b> <i>dwData</i><b> </b>             // data passed to the callback function 
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hdc</i></dt>
<dd>
Handle to a display device context that defines the visible region of interest. 
<p>
If this parameter is NULL, the <i>hdcMonitor</i> parameter passed to the <i>MonitorEnumProc</i> calls will be NULL, and the visible region of interest is the virtual screen that encompasses all the displays on the desktop. 
</dd>
<dt>
<i>lprcClip</i></dt>
<dd>
Pointer to a <a href="rectangl_6cqa.htm"><b>RECT</b></a> structure that specifies a clipping rectangle. The region of interest is the intersection of the clipping rectangle with the visible region specified by <i>hdc</i>. 
<p>
If <i>hdc</i> is non-NULL, the coordinates of the clipping rectangle are relative to the origin of the <i>hdc</i>. If <i>hdc</i> is NULL, the coordinates are virtual screen coordinates.

<p>
This parameter can be NULL if you don't want to clip the region specified by <i>hdc</i>.
</dd>
<dt>
<i>lpfnEnum</i></dt>
<dd>
Pointer to a <a href="monitor_0alf.htm"><i>MonitorEnumProc</i></a> application-defined callback function. </dd>
<dt>
<i>dwData</i></dt>
<dd>
Application-defined data that <b>EnumDisplayMonitors</b> passes directly to the <i>MonitorEnumProc</i> function. 
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is nonzero</p>
<p>
If the function fails, the return value is zero. </p>
<p>
<b>Windows NT:</b> To get extended error information, call <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_getlasterror">
</object><a href=JavaScript:alink_1.Click()><b>GetLastError</b></a>. .</p>
<h4>Remarks</h4>
<p>
There are two key reasons to call the <b>EnumDisplayMonitors</b> function:
<ul>
<li>
You want to draw optimally into a device context that spans several display monitors, and the monitors have different color formats. </li>
<li>
You want to obtain a handle and position rectangle for one or more display monitors.</li>
</ul>
<p>
To determine whether all the display monitors in a system share the same color format, call <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_getsystemmetrics">
</object><a href=JavaScript:alink_2.Click()><b>GetSystemMetrics</b></a>(SM_SAMEDISPLAYFORMAT). </p>
<p>
You do not need to use the <b>EnumDisplayMonitors</b> function when a window spans display monitors that have different color formats. You can continue to paint under the assumption that the entire screen has the color properties of the primary monitor. Your windows will look fine. <b>EnumDisplayMonitors</b> just lets you make them look better.</p>
<p>
Setting the <i>hdc</i> parameter to NULL lets you use the <b>EnumDisplayMonitors</b> function to obtain a handle and position rectangle for one or more display monitors. The following table shows how the four combinations of NULL and non-NULL <i>hdc</i> and <i>lprcClip</i> values affect the behavior of the <b>EnumDisplayMonitors</b> function:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=18%><i>hdc</i></th>
<th align=left width=16%><i>lprcRect</i></th>
<th align=left width=66%>EnumDisplayMonitors Behavior</th>
</tr>
<tr valign=top>
<td width=18%>NULL</td>
<td width=16%>NULL</td>
<td width=66%>Enumerates all display monitors. <p>
The callback function receives a NULL HDC. </p>
</td>
</tr>
<tr valign=top>
<td width=18%>NULL</td>
<td width=16%>non-NULL</td>
<td width=66%>Enumerates all display monitors that intersect the clipping rectangle. Use virtual screen coordinates for the clipping rectangle. <p>
The callback function receives a NULL HDC. </p>
</td>
</tr>
<tr valign=top>
<td width=18%>non-NULL</td>
<td width=16%>NULL</td>
<td width=66%>Enumerates all display monitors that intersect the visible region of the device context.<p>
The callback function receives a handle to a DC for the specific display monitor.</p>
</td>
</tr>
<tr valign=top>
<td width=18%>non-NULL</td>
<td width=16%>non-NULL</td>
<td width=66%>Enumerates all display monitors that intersect the visible region of the device context and the clipping rectangle. Use device context coordinates for the clipping rectangle.<p>
The callback function receives a handle to a DC for the specific display monitor.</p>
</td>
</tr>
</table><br>
<h4>Examples</h4>
<p>
To paint in response to a WM_PAINT message, using the capabilities of each monitor, you can use code like this in a window procedure: </p>
<pre><code>case WM_PAINT:
  hdc = BeginPaint(hwnd, &amp;ps);
  EnumDisplayMonitors(hdc, NULL, MyPaintEnumProc, 0);
  EndPaint(hwnd, &amp;ps);
</code></pre>
<p>
To paint the top half of a window using the capabilities of each monitor, you can use code like this:</p>
<pre><code>GetClientRect(hwnd, &amp;rc);
rc.bottom = (rc.bottom - rc.top) / 2;
hdc = GetDC(hwnd);
EnumDisplayMonitors(hdc, &amp;rc, MyPaintEnumProc, 0);
ReleaseDC(hwnd, hdc);
</code></pre>
<p>
To paint the entire virtual screen optimally for each display monitor, you can use code like this:</p>
<pre><code>hdc = GetDC(NULL);
EnumDisplayMonitors(hdc, NULL, MyPaintScreenEnumProc, 0);
ReleaseDC(NULL, hdc);
</code></pre>
<p>
To get information about all of the display monitors, you can use code like this:</p>
<pre><code>EnumDisplayMonitors(NULL, NULL, MyInfoEnumProc, 0);
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 98.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winuser.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use user32.lib.</p>
<h4>See Also</h4>
<p>
<a href="monitor_53sj.htm">Multiple Display Monitors Overview</a>, <a href="monitor_8woj.htm">Multiple Display Monitors Functions</a>, <a href="monitor_0alf.htm"><i>MonitorEnumProc</i></a> </p>
<p>&nbsp;</p></body>
</HTML>
