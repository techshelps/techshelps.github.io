<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EnumPrinterData</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_enumprinterdata"></a>EnumPrinterData</h1>
<p>
The <b>EnumPrinterData</b> function enumerates configuration data for a specified printer. </p>
<p>
A printer's configuration data consists of a set of named and typed values. The <b>EnumPrinterData</b> function obtains one of these values, and its name and a type code, each time you call it. Call the <b>EnumPrinterData</b> function several times in succession to obtain all of a printer's configuration data values. </p>
<p>
Printer configuration data is stored in the registry. While enumerating printer configuration data, you should avoid calling registry functions that might change that data. </p>
<pre><code><b>DWORD EnumPrinterData(
  HANDLE</b><i> hPrinter</i><b>,       </b>// handle to printer of interest
<b>  DWORD</b><i> dwIndex</i><b>,         </b>// index of value to retrieve
<b>  LPTSTR</b><i> pValueName</i><b>,     </b>// pointer to buffer to receive value name
<b>  DWORD</b><i> cbValueName</i><b>,     </b>// size in bytes of value name buffer
  <b>LPDWORD</b> <i>pcbValueName</i><b>,</b>  // pointer to variable to receive number of 
                         // bytes stored into value name buffer
<b>  LPDWORD</b><i> pType</i><b>,         </b>// pointer to variable to receive value 
                         // type code
<b>  LPBYTE</b><i> pData</i><b>,          </b>// pointer to buffer to receive value data
<b>  DWORD</b><i> cbData</i><b>,          </b>// size in bytes of value data buffer
<b>  LPDWORD</b><i> pcbData</i>        // pointer to variable to receive number of 
                         // bytes stored into value data buffer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hPrinter</i></dt>
<dd>
Handle to the printer whose configuration data is to be obtained.
<p>
You obtain this printer handle by calling the <b>OpenPrinter</b> function.  
</dd>
<dt>
<i>dwIndex</i></dt>
<dd>
An index value that specifies the configuration data value to retrieve.
<p>
Set this parameter to zero for the first call to <b>EnumPrinterData</b> for a given printer handle. Then increment the parameter by one for subsequent calls involving the same printer, until the function returns ERROR_NO_MORE_ITEMS. See the following <b>Remarks</b> section for further information.


<p>
<b>Note</b>&nbsp;&nbsp;If you use the technique mentioned in the descriptions of the <i>cbValueName</i> and <i>cbData</i> parameters to obtain adequate buffer size values, setting both those parameters to zero in a first call to <b>EnumPrinterData</b> for a given printer handle, the value of <i>dwIndex</i> does not matter for that call. Set <i>dwIndex</i> to zero in the next call to <b>EnumPrinterData</b> to start the actual enumeration process. 


<p>
Configuration data values are not ordered. New values will have an arbitrary index. This means that the <b>EnumPrinterData </b>function may return values in any order. 
</dd>
<dt>
<i>pValueName</i></dt>
<dd>
Pointer to a buffer that receives the name of the configuration data value, including a terminating null character. </dd>
<dt>
<i>cbValueName</i></dt>
<dd>
Specifies the size, in bytes, of the buffer pointed to by <i>pValueName</i>. 
<p>
If you want to have the operating system supply an adequate buffer size, set both this parameter and the <i>cbData</i> parameter to zero for the first call to <b>EnumPrinterData</b> for a given printer handle. When the function returns, the variable pointed to by <i>pcbValueName</i> will contain a buffer size that is large enough to successfully enumerate all of the printer's configuration data value names. 
</dd>
<dt>
<i>pcbValueName</i></dt>
<dd>
Pointer to a variable that receives the number of bytes stored into the buffer pointed to by <i>pValueName</i>.</dd>
<dt>
<i>pType</i></dt>
<dd>
Pointer to a variable that receives a type code for the value specified by <i>dwIndex</i>. The type code can be one of the following values: 
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Value</th>
<th align=left width=51%>Meaning</th>
</tr>
<tr valign=top>
<td width=49%>REG_BINARY</td>
<td width=51%>Binary data in any form.</td>
</tr>
<tr valign=top>
<td width=49%>REG_DWORD</td>
<td width=51%>A 32-bit number.</td>
</tr>
<tr valign=top>
<td width=49%>REG_DWORD_LITTLE_ENDIAN</td>
<td width=51%>A 32-bit number in little-endian format. This is equivalent to REG_DWORD.<p>
In little-endian format, a multi-byte value is stored in memory from the lowest byte (the "little end") to the highest byte. For example, the value 0x12345678 is stored as (0x78 0x56 0x34 0x12) in little-endian format.</p>
<p>
Windows and Windows NT are designed to run on little-endian computer architectures. A user may connect to computers that have big-endian architectures, such as some UNIX systems. </p>
</td>
</tr>
<tr valign=top>
<td width=49%>REG_DWORD_BIG_ENDIAN</td>
<td width=51%>A 32-bit number in big-endian format. <p>
In big-endian format, a multi-byte value is stored in memory from the highest byte (the "big end") to the lowest byte. For example, the value 0x12345678 is stored as (0x12 0x34 0x56 0x78) in big-endian format.</p>
<p>
Windows and Windows NT are designed to run on little-endian computer architectures. A user may connect to computers that have big-endian architectures, such as some UNIX systems. </p>
</td>
</tr>
<tr valign=top>
<td width=49%>REG_EXPAND_SZ</td>
<td width=51%>A null-terminated string that contains unexpanded references to environment variables (for example, "%PATH%"). It will be a Unicode or ANSI string depending on whether you use the Unicode or ANSI functions.</td>
</tr>
<tr valign=top>
<td width=49%>REG_LINK</td>
<td width=51%>A Unicode symbolic link.</td>
</tr>
<tr valign=top>
<td width=49%>REG_MULTI_SZ</td>
<td width=51%>An array of null-terminated strings, terminated by two null characters.</td>
</tr>
<tr valign=top>
<td width=49%>REG_NONE</td>
<td width=51%>No defined value type.</td>
</tr>
<tr valign=top>
<td width=49%>REG_RESOURCE_LIST</td>
<td width=51%>A device-driver resource list.</td>
</tr>
<tr valign=top>
<td width=49%>REG_SZ</td>
<td width=51%>A null-terminated string. It will be a Unicode or ANSI string, depending on whether you use the Unicode or ANSI functions.</td>
</tr>
</table><br>


<p>
The <i>pType</i> parameter can be NULL if the type code is not required. 
</dd>
<dt>
<i>pData</i></dt>
<dd>
Pointer to a buffer that receives the configuration data value. 
<p>
This parameter can be NULL if the configuration data value is not required. 
</dd>
<dt>
<i>cbData</i></dt>
<dd>
Specifies the size, in bytes, of the buffer pointed to by <i>pData</i>. 
<p>
If you want to have the operating system supply an adequate buffer size, set both this parameter and the <i>cbValueName</i> parameter to zero for the first call to <b>EnumPrinterData</b> for a given printer handle. When the function returns, the variable pointed to by <i>pcbData</i> will contain a buffer size that is large enough to successfully enumerate all of the printer's configuration data value names. 
</dd>
<dt>
<i>pcbData</i></dt>
<dd>
Pointer to a variable that receives the number of bytes stored into the buffer pointed to by <i>pData</i>.
<p>
This parameter can be NULL if <i>pData</i> is NULL.

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is ERROR_SUCCESS.</p>
<p>
If the function fails, the return value is a Win32 error value. </p>
<p>
The function returns ERROR_NO_MORE_ITEMS when there are no more configuration data values to retrieve for a given printer handle.</p>
<h4>Remarks</h4>
<p>
<b>EnumPrinterData</b> retrieves printer configuration data set by the <b>SetPrinterData</b> function. </p>
<p>
If you want to have the operating system supply an adequate buffer size, first call <b>EnumPrinterData </b>with both the <i>cbValueName</i> and <i>cbData </i>parameters set to zero, as noted earlier in the <b>Parameters </b>section. The value of <i>dwIndex</i> does not matter for this call. When the function returns, *<i>pcbValueName</i> and *<i>pcbData</i> will contain buffer sizes that are large enough to enumerate all of the printer's configuration data value names and values. On the next call, allocate value name and data buffers, set <i>cbValueName </i>and<i> cbData</i> to the sizes in bytes of the allocated buffers, and set <i>dwIndex </i>to zero. Thereafter, continue to call the <b>EnumPrinterData </b>function, incrementing <i>dwIndex</i> by one each time, until the function returns ERROR_NO_MORE_ITEMS. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winspool.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use winspool.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Implemented as Unicode and ANSI versions on Windows NT.</p>
<h4>See Also</h4>
<p>
<a href="prntspol_62ia.htm">Printing and Print Spooler Overview</a>, <a href="prntspol_7mgj.htm">Printing and Print Spooler Functions</a>, <a href="prntspol_6wdd.htm"><b>DeletePrinterData</b></a>, <a href="prntspol_0u3l.htm"><b>GetPrinterData</b></a>, <a href="prntspol_9qnm.htm"><b>OpenPrinter</b></a>, <a href="prntspol_13ua.htm"><b>SetPrinter</b></a>, <a href="prntspol_5aox.htm"><b>SetPrinterData</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
