<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CSNAPIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5787"></a>CSNAPIN.CPP</h2>
<pre><code>// This is a part of the Microsoft Management Console. <br>// Copyright 1995 - 1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Microsoft Management Console and related <br>// electronic documentation provided with the interfaces. <br> <br> <br> <br>#include "stdafx.h" <br>#include "Service.h"   <br>#include "CSnapin.h" <br>#include "DataObj.h" <br>#include "afxdlgs.h" <br>#include "resource.h" <br>#include "genpage.h"  // Step 3 <br> <br>#include &lt;atlimpl.cpp&gt; <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>                                                                 <br>// All data is static for the sample <br>FOLDER_DATA FolderData[NUM_FOLDERS] =  <br>{ <br>    {L"User Data", L"1111", L"Info about users", USER}, <br>    {L"Company Data", L"2222", L"Info about Companies", COMPANY}, <br>    {L"Virtual Data", L"3333", L"Info about virtual items", VIRTUAL},  <br>    {L"", L"", L"",STATIC} <br>}; <br> <br>FOLDER_DATA ExtFolderData[NUM_FOLDERS] =  <br>{ <br>    {L"1:", L"1111", L"Info about users", EXT_USER}, <br>    {L"2:", L"2222", L"Info about Companies", EXT_COMPANY}, <br>    {L"3:", L"3333", L"Infor about virtual items", EXT_VIRTUAL}, <br>    {L"", L"", L"",STATIC} <br>}; <br> <br>static MMCBUTTON SnapinButtons[] = <br>{ <br> { 0, 1, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Folder", L"New Folder" }, <br> { 1, 2, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Inbox",  L"Mail Inbox"}, <br> { 2, 3, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Outbox", L"Mail Outbox" }, <br> { 3, 4, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Send",   L"Send Message" }, <br> { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP,    L" ",      L"" }, <br> { 4, 5, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Trash",  L"Trash" }, <br> { 5, 6, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Open",   L"Open Folder"}, <br> { 6, 7, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"News",   L"Today's News" }, <br> { 7, 8, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"INews",  L"Internet News" }, <br> <br>}; <br> <br>static MMCBUTTON SnapinButtons2[] = <br>{ <br> { 0, 10, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Compose",   L"Compose Message" }, <br> { 1, 20, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Print",     L"Print Message" }, <br> { 2, 30, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Find",      L"Find Message" }, <br> { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP,    L" ",         L"" }, <br> { 3, 40, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Inbox",     L"Inbox" }, <br> { 4, 50, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Smile",     L"Smile :-)" }, <br> { 5, 60, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Reply",     L"Reply" }, <br> { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP   , L" ",         L"" }, <br> { 6, 70, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Reply All", L"Reply All" },  <br> <br>}; <br> <br>enum <br>{ <br>    // Identifiers for each of the commands/views to be inserted into the context menu. <br>    IDM_COMMAND1, <br>    IDM_COMMAND2, <br>    IDM_SAMPLE_OCX_VIEW, <br>    IDM_SAMPLE_WEB_VIEW <br>}; <br> <br>static int n_count = 0; <br> <br>//#define ODS OutputDebugString  <br>#define ODS OutputDebugString  <br> <br>#ifdef DBX <br>  void DbxPrint(LPTSTR pszFmt, ...) <br>  { <br>      va_list va; <br>      va_start (va, pszFmt); <br>      TCHAR buf[250]; <br>      wsprintf(buf, pszFmt, va); <br>      OutputDebugString(buf); <br>      va_end(va); <br>  } <br>  //#define DBX_PRINT     DbxPrint <br>  inline void __DummyTrace(LPTSTR, ...) { } <br>  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace <br>#else <br>  inline void __DummyTrace(LPTSTR, ...) { } <br>  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace <br>#endif  <br> <br>// <br>// The sample snap-in only has 1 property type and it's the workstation name <br>//  <br> <br>// <br>// Extracts the coclass guid format from the data object <br>// <br>template &lt;class TYPE&gt; <br>TYPE* Extract(LPDATAOBJECT lpDataObject, unsigned int cf) <br>{ <br>    ASSERT(lpDataObject != NULL); <br> <br>    TYPE* p = NULL; <br> <br>    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; <br>    FORMATETC formatetc = { cf, NULL,  <br>                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL  <br>                          }; <br> <br>    // Allocate memory for the stream <br>    int len = (cf == CDataObject::m_cfWorkstation) ?  <br>        ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE)) : sizeof(TYPE); <br> <br>    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len); <br>     <br>    // Get the workstation name from the data object <br>    do  <br>    { <br>        if (stgmedium.hGlobal == NULL) <br>            break; <br> <br>        if (FAILED(lpDataObject-&gt;GetDataHere(&amp;formatetc, &amp;stgmedium))) <br>            break; <br>         <br>        p = reinterpret_cast&lt;TYPE*&gt;(stgmedium.hGlobal); <br> <br>        if (p == NULL) <br>            break; <br> <br>    } while (FALSE);  <br> <br>    return p; <br>} <br> <br>BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject) <br>{ <br>    if (pDataObject == NULL) <br>        return FALSE; <br>     <br>    static UINT s_cf = 0;   <br>    if (s_cf == 0) <br>    { <br>        USES_CONVERSION; <br>        s_cf = RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT)); <br>    } <br> <br>    FORMATETC fmt = {s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}; <br> <br>    return (pDataObject-&gt;QueryGetData(&amp;fmt) == S_OK); <br>} <br> <br>// Data object extraction helpers <br>CLSID* ExtractClassID(LPDATAOBJECT lpDataObject) <br>{ <br>    return Extract&lt;CLSID&gt;(lpDataObject, CDataObject::m_cfCoClass);     <br>} <br> <br>GUID* ExtractNodeType(LPDATAOBJECT lpDataObject) <br>{ <br>    return Extract&lt;GUID&gt;(lpDataObject, CDataObject::m_cfNodeType);     <br>} <br> <br>wchar_t* ExtractWorkstation(LPDATAOBJECT lpDataObject) <br>{ <br>    return Extract&lt;wchar_t&gt;(lpDataObject, CDataObject::m_cfWorkstation);     <br>} <br> <br>INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject) <br>{ <br>    return Extract&lt;INTERNAL&gt;(lpDataObject, CDataObject::m_cfInternal);     <br>} <br> <br> <br>HRESULT _QueryDataObject(long cookie, DATA_OBJECT_TYPES type,  <br>                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject) <br>{ <br>    ASSERT(ppDataObject != NULL); <br>    ASSERT(pImpl != NULL); <br> <br>    CComObject&lt;CDataObject&gt;* pObject; <br> <br>    CComObject&lt;CDataObject&gt;::CreateInstance(&amp;pObject); <br>    ASSERT(pObject != NULL); <br> <br>    // Save cookie and type for delayed rendering <br>    pObject-&gt;SetType(type);   <br>    pObject-&gt;SetCookie(cookie); <br> <br>#ifdef _DEBUG <br>    pObject-&gt;SetComponentData(pImpl); <br>#endif  <br> <br>    // Store the coclass with the data object <br>    pObject-&gt;SetClsid(pImpl-&gt;GetCoClassID()); <br> <br>    return  pObject-&gt;QueryInterface(IID_IDataObject,  <br>                    reinterpret_cast&lt;void**&gt;(ppDataObject)); <br>} <br> <br>DWORD GetItemType(long cookie) <br>{ <br>    // folder = CFoder* is cookie <br>    // result = RESULT_DATA* is the cookie <br> <br>    return (*reinterpret_cast&lt;DWORD*&gt;(cookie)); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Return TRUE if we are enumerating our main folder <br> <br>BOOL CSnapin::IsEnumerating(LPDATAOBJECT lpDataObject) <br>{ <br>    BOOL bResult = FALSE; <br>     <br>    ASSERT(lpDataObject); <br>    GUID* nodeType = ExtractNodeType(lpDataObject); <br> <br>    // Is this my main node (static folder node type) <br>    if (::IsEqualGUID(*nodeType, cNodeTypeStatic) == TRUE) <br>        bResult = TRUE; <br> <br>    // Free resources <br>    ::GlobalFree(reinterpret_cast&lt;HANDLE&gt;(nodeType)); <br> <br>    return bResult; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CSnapin's IComponent implementation <br> <br>STDMETHODIMP CSnapin::GetResultViewType(long cookie,  LPOLESTR* ppViewType, long* pViewOptions) <br>{ <br> <br>    // guid for custom view <br>    static WCHAR* szCalendarGUID = L"{8E27C92B-1264-101C-8A2F-040224009C02}"; <br>    static WCHAR* szMicrosoftURL = L"www.microsoft.com"; <br> <br>    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT; <br> <br>    // if list view <br>    if (m_CustomViewID == VIEW_DEFAULT_LV) <br>    { <br>        m_bVirtualView = FALSE; <br> <br>       // if static folder not selected <br>        if (cookie != NULL) <br>        { <br>            // See if virtual data folder is selected <br>            CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(cookie); <br>            ASSERT(pFolder-&gt;itemType == SCOPE_ITEM); <br>            FOLDER_TYPES ftype = pFolder-&gt;GetType(); <br> <br>            m_bVirtualView = (ftype == VIRTUAL || ftype == EXT_VIRTUAL); <br> <br>            if (m_bVirtualView) <br>                *pViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST; <br>        } <br> <br>        return S_FALSE; <br>    } <br> <br>    WCHAR* pszView = (m_CustomViewID == VIEW_CALENDAR_OCX) ? szCalendarGUID : <br>                                                             szMicrosoftURL; <br>    UINT uiByteLen = (wcslen(pszView) + 1) * sizeof(WCHAR); <br>    LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen); <br>     <br>    USES_CONVERSION; <br> <br>    if (psz != NULL) <br>    { <br>       wcscpy(psz, pszView); <br>       *ppViewType = psz; <br>       return S_OK; <br>    } <br> <br>    return S_FALSE;             <br>} <br> <br>STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole) <br>{ <br>    DBX_PRINT(_T(" ----------  CSnapin::Initialize&lt;0x08x&gt;\n"), this); <br>    ASSERT(lpConsole != NULL); <br>    m_bInitializedC = true; <br> <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    // Save the IConsole pointer  <br>    m_pConsole = lpConsole; <br>    m_pConsole-&gt;AddRef(); <br> <br>    // Load resource strings <br>    LoadResources(); <br> <br>    // QI for a IHeaderCtrl <br>    HRESULT hr = m_pConsole-&gt;QueryInterface(IID_IHeaderCtrl,  <br>                        reinterpret_cast&lt;void**&gt;(&amp;m_pHeader)); <br> <br>    // Give the console the header control interface pointer <br>    if (SUCCEEDED(hr)) <br>        m_pConsole-&gt;SetHeader(m_pHeader); <br> <br>    m_pConsole-&gt;QueryInterface(IID_IResultData,  <br>                        reinterpret_cast&lt;void**&gt;(&amp;m_pResult)); <br> <br>    hr = m_pConsole-&gt;QueryResultImageList(&amp;m_pImageResult); <br>    ASSERT(hr == S_OK); <br> <br>    hr = m_pConsole-&gt;QueryConsoleVerb(&amp;m_pConsoleVerb); <br>    ASSERT(hr == S_OK); <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    if (IS_SPECIAL_DATAOBJECT(lpDataObject)) <br>    { <br>        if (event == MMCN_BTN_CLICK) <br>        { <br>            if (m_CustomViewID != VIEW_DEFAULT_LV) <br>            { <br>                switch (param) <br>                { <br>                case MMC_VERB_REFRESH: <br>                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_REFRESH")); <br>                    _OnRefresh(lpDataObject); <br>                    break; <br>     <br>                case MMC_VERB_PROPERTIES: <br>                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_PROPERTIES")); <br>                    break; <br>     <br>                default:  <br>                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::param unknown")); <br>                    break; <br>                } <br>            } <br>        } <br>        else  <br>        { <br>            switch (event) <br>            { <br>            case MMCN_REFRESH: <br>                ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMCN_REFRESH")); <br>                _OnRefresh(lpDataObject); <br>                break; <br>            } <br>        } <br> <br>        return S_OK; <br>    } <br> <br>    HRESULT hr = S_OK; <br>    long cookie; <br> <br>    if (event == MMCN_PROPERTY_CHANGE) <br>    { <br>        hr = OnPropertyChange(lpDataObject); <br>    } <br>    else if (event == MMCN_VIEW_CHANGE) <br>    { <br>        hr = OnUpdateView(lpDataObject); <br>    } <br>    else if (event == MMCN_DESELECT_ALL) <br>    { <br>        DBX_PRINT(_T("CSnapin::Notify -&gt; MMCN_DESELECT_ALL \n")); <br>    } <br>    else if (event == MMCN_COLUMN_CLICK) <br>    { <br>        DBX_PRINT(_T("CSnapin::Notify -&gt; MMCN_COLUMN_CLICK \n"));    <br>    } <br>    else if (event == MMCN_SNAPINHELP) <br>    { <br>        AfxMessageBox(_T("CSnapin::Notify -&gt;MMCN_SNAPINHELP"));     <br>    } <br>    else <br>    { <br>        INTERNAL* pInternal = NULL; <br> <br>        if (IsMMCMultiSelectDataObject(lpDataObject) == FALSE) <br>        { <br>            pInternal = ExtractInternalFormat(lpDataObject); <br>     <br>            if (pInternal == NULL) <br>            { <br>                ASSERT(FALSE); <br>                return S_OK; <br>            } <br>     <br>            if (pInternal) <br>                cookie = pInternal-&gt;m_cookie; <br>        } <br> <br>        switch(event) <br>        { <br>        case MMCN_ACTIVATE: <br>            break; <br> <br>        case MMCN_CLICK: <br>            hr = OnResultItemClk(pInternal-&gt;m_type, cookie); <br>            break; <br> <br>        case MMCN_DBLCLICK: <br>            if (pInternal-&gt;m_type == CCT_RESULT) <br>                Command(IDM_COMMAND1, lpDataObject); <br>            else  <br>                hr = S_FALSE; <br> <br>            break; <br> <br>        case MMCN_ADD_IMAGES: <br>            OnAddImages(cookie, arg, param); <br>            break; <br> <br>        case MMCN_SHOW: <br>            hr = OnShow(cookie, arg, param); <br>            break; <br> <br>        case MMCN_MINIMIZED: <br>            hr = OnMinimize(cookie, arg, param); <br>            break; <br> <br>        case MMCN_INITOCX: <br>            ::MessageBox(NULL, _T("MMCN_INITOCX"), _T("TRACE"), MB_OK); <br>            ASSERT(param != 0); <br>            break; <br> <br>        case MMCN_DESELECT_ALL: <br>        case MMCN_SELECT: <br>            HandleStandardVerbs((event == MMCN_DESELECT_ALL), <br>                                arg, lpDataObject);             <br>            break; <br> <br>        case MMCN_PASTE: <br>            AfxMessageBox(_T("CSnapin::MMCN_PASTE")); <br>            break; <br>         <br>        case MMCN_DELETE: <br>            AfxMessageBox(_T("CSnapin::MMCN_DELETE")); <br>            break; <br> <br>        case MMCN_CONTEXTHELP: <br>            hr = OnContextHelp(lpDataObject); <br>            break; <br> <br>        case MMCN_REFRESH: <br>            AfxMessageBox(_T("CSnapin::MMCN_REFRESH")); <br>            _OnRefresh(lpDataObject); <br>            break; <br> <br>        case MMCN_RENAME: <br>            ODS(_T("\n\n\t\tCSnapin::MMCN_RENAME\n\n")); <br>            break; <br> <br>        // Note - Future expansion of notify types possible <br>        default: <br>            hr = E_UNEXPECTED; <br>            break; <br>        } <br>         <br>        if (pInternal != NULL) <br>        { <br>            ::GlobalFree(reinterpret_cast&lt;HANDLE&gt;(pInternal)); <br>        } <br>    } <br> <br>    if (m_pResult) <br>        m_pResult-&gt;SetDescBarText(L"hello world"); <br> <br>    return hr; <br>} <br> <br>void CSnapin::_OnRefresh(LPDATAOBJECT pDataObject) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br>    INTERNAL* pInternal = ExtractInternalFormat(pDataObject); <br>    if (pInternal == NULL) <br>        return; <br> <br>    if (pInternal-&gt;m_type == CCT_SCOPE) <br>    { <br>        CComponentDataImpl* pData = dynamic_cast&lt;CComponentDataImpl*&gt;(m_pComponentData); <br>        CFolder* pFolder = pData-&gt;FindObject(pInternal-&gt;m_cookie); <br>        ::AfxMessageBox(pInternal-&gt;m_cookie ? pFolder-&gt;m_pszName : _T("Files")); <br>    } <br>    else  <br>    { <br>        RESULT_DATA* pData = reinterpret_cast&lt;RESULT_DATA*&gt;(pInternal-&gt;m_cookie); <br>        ::AfxMessageBox(pData-&gt;szName); <br>    } <br>} <br> <br>HRESULT CSnapin::OnContextHelp(LPDATAOBJECT pdtobj) <br>{ <br>    TCHAR name[128]; <br>    GetItemName(pdtobj, name); <br> <br>    TCHAR buf[200]; <br>    wsprintf(buf, _T("Context help requested for item: %s"), name); <br>    ::MessageBox(NULL, buf, _T("TRACE"), MB_OK); <br> <br>    return S_OK; <br>} <br> <br> <br>STDMETHODIMP CSnapin::Destroy(long cookie) <br>{ <br>    DBX_PRINT(_T(" ----------  CSnapin::Destroy&lt;0x08x&gt;\n"), this); <br>    ASSERT(m_bInitializedC); <br>    m_bDestroyedC = true; <br> <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    // Release the interfaces that we QI'ed <br>    if (m_pConsole != NULL) <br>    { <br>        // Tell the console to release the header control interface <br>        m_pConsole-&gt;SetHeader(NULL); <br>        SAFE_RELEASE(m_pHeader); <br> <br>        SAFE_RELEASE(m_pResult); <br>        SAFE_RELEASE(m_pImageResult); <br> <br>        // Release the IConsole interface last <br>        SAFE_RELEASE(m_pConsole); <br>        SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent <br> <br>        SAFE_RELEASE(m_pConsoleVerb); <br>    } <br> <br>    return S_OK; <br>} <br> <br>typedef CArray&lt;GUID, const GUID&amp;&gt; CGUIDArray; <br> <br>void GuidArray_Add(CGUIDArray&amp; rgGuids, const GUID&amp; guid) <br>{ <br>    for (int i=rgGuids.GetUpperBound(); i &gt;= 0; --i) <br>    { <br>        if (rgGuids[i] == guid) <br>            break; <br>    } <br> <br>    if (i &lt; 0) <br>        rgGuids.Add(guid); <br>} <br> <br>HRESULT CSnapin::QueryMultiSelectDataObject(long cookie, DATA_OBJECT_TYPES type, <br>                                            LPDATAOBJECT* ppDataObject) <br>{ <br>    ASSERT(ppDataObject != NULL); <br>    if (ppDataObject == NULL) <br>        return E_POINTER; <br> <br>    CGUIDArray rgGuids; <br> <br>    if (m_bVirtualView == TRUE) <br>    { <br>        GuidArray_Add(rgGuids, cNodeTypeCompany); <br>    } <br>    else  <br>    { <br>        // Determine the items selected <br>        ASSERT(m_pResult != NULL); <br>        RESULTDATAITEM rdi; <br>        ZeroMemory(&amp;rdi, sizeof(rdi)); <br>        rdi.mask = RDI_STATE; <br>        rdi.nIndex = -1; <br>        rdi.nState = TVIS_SELECTED; <br>     <br>        while (m_pResult-&gt;GetNextItem(&amp;rdi) == S_OK) <br>        { <br>            FOLDER_TYPES fType; <br>            DWORD* pdw = reinterpret_cast&lt;DWORD*&gt;(rdi.lParam); <br>     <br>     <br>            if (*pdw == SCOPE_ITEM) <br>            { <br>                CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(rdi.lParam); <br>                fType = pFolder-&gt;m_type; <br>            } <br>            else  <br>            { <br>                ASSERT(*pdw == RESULT_ITEM); <br>                RESULT_DATA* pData = reinterpret_cast&lt;RESULT_DATA*&gt;(rdi.lParam); <br>                fType = pData-&gt;parentType; <br>            } <br>                 <br>            const GUID* pguid; <br>            switch (fType) <br>            { <br>            case STATIC: <br>                pguid = &amp;cNodeTypeStatic; <br>                break; <br>     <br>            case COMPANY: <br>                pguid = &amp;cNodeTypeCompany; <br>                break; <br>     <br>            case USER: <br>                pguid = &amp;cNodeTypeUser; <br>                break; <br>     <br>            case EXT_COMPANY: <br>                pguid = &amp;cNodeTypeExtCompany; <br>                break; <br>     <br>            case EXT_USER: <br>                pguid = &amp;cNodeTypeExtUser; <br>                break; <br>     <br>            case VIRTUAL: <br>            case EXT_VIRTUAL: <br>                pguid = &amp;cNodeTypeVirtual; <br>                break; <br> <br>            default: <br>                return E_FAIL; <br>            } <br>     <br>            GuidArray_Add(rgGuids, *pguid); <br>        } <br>    } <br> <br>    CComObject&lt;CDataObject&gt;* pObject; <br>    CComObject&lt;CDataObject&gt;::CreateInstance(&amp;pObject); <br>    ASSERT(pObject != NULL); <br> <br>    // Save cookie and type for delayed rendering <br>    pObject-&gt;SetType(type);   <br>    pObject-&gt;SetCookie(cookie); <br>    pObject-&gt;SetMultiSelDobj(); <br> <br>    CComponentDataImpl* pImpl = dynamic_cast&lt;CComponentDataImpl*&gt;(m_pComponentData); <br> <br>#ifdef _DEBUG <br>    pObject-&gt;SetComponentData(pImpl); <br>#endif  <br> <br>    // Store the coclass with the data object <br>    pObject-&gt;SetClsid(pImpl-&gt;GetCoClassID()); <br>    UINT cb = rgGuids.GetSize() * sizeof(GUID); <br>    GUID* pGuid = new GUID[rgGuids.GetSize()]; <br>    CopyMemory(pGuid, rgGuids.GetData(), cb); <br>    pObject-&gt;SetMultiSelData((BYTE*)pGuid, cb); <br> <br>    return  pObject-&gt;QueryInterface(IID_IDataObject,  <br>                    reinterpret_cast&lt;void**&gt;(ppDataObject)); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CSnapin::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, <br>                        LPDATAOBJECT* ppDataObject) <br>{ <br>    if (cookie == MMC_MULTI_SELECT_COOKIE) <br>        return QueryMultiSelectDataObject(cookie, type, ppDataObject); <br>     <br>    ASSERT(type == CCT_RESULT); <br> <br>#ifdef _DEBUG <br>    if (cookie != MMC_MULTI_SELECT_COOKIE &amp;&amp;  <br>        m_bVirtualView == FALSE) <br>    { <br>        DWORD dwItemType = GetItemType(cookie); <br>        ASSERT(dwItemType == RESULT_ITEM); <br>    } <br>#endif  <br> <br>    // Delegate it to the IComponentData <br>    ASSERT(m_pComponentData != NULL); <br>    CComponentDataImpl* pImpl = dynamic_cast&lt;CComponentDataImpl*&gt;(m_pComponentData); <br>    ASSERT(pImpl != NULL); <br>    return _QueryDataObject(cookie, type, pImpl, ppDataObject); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CSnapin's implementation specific members <br> <br>DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin); <br> <br>CSnapin::CSnapin() <br>: m_bIsDirty(TRUE), m_bInitializedC(false), m_bDestroyedC(false) <br>{ <br>    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin); <br>    Construct(); <br>} <br> <br>CSnapin::~CSnapin() <br>{ <br>#if DBG==1 <br>    ASSERT(dbg_cRef == 0); <br>#endif  <br> <br>    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin); <br> <br>    SAFE_RELEASE(m_pToolbar1); <br>    SAFE_RELEASE(m_pToolbar2); <br>     <br>    SAFE_RELEASE(m_pMenuButton1); <br> <br>    SAFE_RELEASE(m_pControlbar); <br> <br>    // Make sure the interfaces have been released <br>    ASSERT(m_pConsole == NULL); <br>    ASSERT(m_pHeader == NULL); <br>    ASSERT(m_pToolbar1 == NULL); <br>    ASSERT(m_pToolbar2 == NULL); <br>     <br> <br>    delete m_pbmpToolbar1; <br>    delete m_pbmpToolbar2; <br> <br>    ASSERT(!m_bInitializedC || m_bDestroyedC); <br> <br>    Construct(); <br>} <br> <br>void CSnapin::Construct() <br>{ <br>#if DBG==1 <br>    dbg_cRef = 0; <br>#endif  <br> <br>    m_pConsole = NULL; <br>    m_pHeader = NULL; <br> <br>    m_pResult = NULL; <br>    m_pImageResult = NULL; <br>    m_pComponentData = NULL; <br>    m_pToolbar1 = NULL; <br>    m_pToolbar2 = NULL; <br>    m_pControlbar = NULL; <br> <br>    m_pMenuButton1 = NULL; <br> <br>    m_pbmpToolbar1 = NULL; <br>    m_pbmpToolbar2 = NULL; <br> <br>    m_pConsoleVerb = NULL; <br> <br>    m_CustomViewID = VIEW_DEFAULT_LV; <br>    m_bVirtualView = FALSE; <br>    m_dwVirtualSortOptions = 0; <br>} <br> <br>void CSnapin::LoadResources() <br>{ <br>    // Load strings from resources <br>    m_column1.LoadString(IDS_NAME); <br>    m_column2.LoadString(IDS_SIZE); <br>    m_column3.LoadString(IDS_TYPE); <br>} <br> <br>HRESULT CSnapin::InitializeHeaders(long cookie) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    ASSERT(m_pHeader); <br> <br>    USES_CONVERSION; <br> <br>    // Put the correct headers depending on the cookie <br>    // Note - cookie ignored for this sample <br>    m_pHeader-&gt;InsertColumn(0, T2COLE(m_column1), LVCFMT_LEFT, 180);     // Name  <br>    m_pHeader-&gt;InsertColumn(1, T2COLE(m_column2), LVCFMT_RIGHT, 90);     // Size <br>    m_pHeader-&gt;InsertColumn(2, T2COLE(m_column3), LVCFMT_LEFT, 160);     // Type <br> <br>    return hr; <br>} <br> <br>HRESULT CSnapin::InitializeBitmaps(long cookie) <br>{ <br>    ASSERT(m_pImageResult != NULL); <br> <br>    ::CBitmap bmp16x16; <br>    ::CBitmap bmp32x32; <br> <br>    // Load the bitmaps from the dll <br>    bmp16x16.LoadBitmap(IDB_16x16); <br>    bmp32x32.LoadBitmap(IDB_32x32); <br> <br>    // Set the images <br>    m_pImageResult-&gt;ImageListSetStrip(reinterpret_cast&lt;long*&gt;(static_cast&lt;HBITMAP&gt;(bmp16x16)), <br>                      reinterpret_cast&lt;long*&gt;(static_cast&lt;HBITMAP&gt;(bmp32x32)), <br>                       0, RGB(255, 0, 255)); <br> <br>    return S_OK; <br>} <br> <br>WCHAR* StringFromFolderType(FOLDER_TYPES type) <br>{ <br>    static WCHAR* s_szStatic    = L"Static"; <br>    static WCHAR* s_szCompany   = L"Company"; <br>    static WCHAR* s_szUser      = L"User"; <br>    static WCHAR* s_szVirtual   = L"Virtual"; <br>    static WCHAR* s_szUnknown   = L"Unknown"; <br> <br>    switch (type) <br>    { <br>    case STATIC:    return s_szStatic; <br>    case COMPANY:   return s_szCompany; <br>    case USER:      return s_szUser; <br>    case VIRTUAL:   return s_szVirtual; <br>    default:        return s_szUnknown; <br>    } <br>} <br> <br>STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult) <br>{ <br>    static WCHAR* s_szSize = L"200"; <br>     <br>    ASSERT(pResult != NULL); <br>  <br>    if (pResult) <br>    { <br>        if (pResult-&gt;bScopeItem == TRUE) <br>        { <br>            CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(pResult-&gt;lParam); <br>            if (pResult-&gt;mask &amp; RDI_STR) <br>            { <br>                if (pResult-&gt;nCol == 0) <br>                    pResult-&gt;str = pFolder-&gt;m_pszName; <br>                else if (pResult-&gt;nCol == 1) <br>                    pResult-&gt;str = (LPOLESTR)s_szSize; <br>                else  <br>                    pResult-&gt;str = (LPOLESTR)StringFromFolderType(pFolder-&gt;m_type); <br> <br>                ASSERT(pResult-&gt;str != NULL); <br>     <br>                if (pResult-&gt;str == NULL) <br>                    pResult-&gt;str = (LPOLESTR)L""; <br>            } <br>        } <br>        else  <br>        { <br>            RESULT_DATA* pData; <br> <br>            // if virtual, derive result item from index <br>            // else lParam is the item pointer <br>            if (m_bVirtualView) <br>                pData = GetVirtualResultItem(pResult-&gt;nIndex); <br>            else <br>                pData= reinterpret_cast&lt;RESULT_DATA*&gt;(pResult-&gt;lParam); <br>                 <br>            if (pResult-&gt;mask &amp; RDI_STR) <br>            { <br>                if (pResult-&gt;nCol == 0) <br>                    pResult-&gt;str = (LPOLESTR)pData-&gt;szName; <br>                else if(pResult-&gt;nCol == 1) <br>                    pResult-&gt;str = (LPOLESTR)pData-&gt;szSize; <br>                else  <br>                    pResult-&gt;str = (LPOLESTR)pData-&gt;szType; <br>     <br>                ASSERT(pResult-&gt;str != NULL); <br>     <br>                if (pResult-&gt;str == NULL) <br>                    pResult-&gt;str = (LPOLESTR)L""; <br>            } <br> <br>            // MMC can request image and indent for virtual data <br>            if (pResult-&gt;mask &amp; RDI_IMAGE) <br>                pResult-&gt;nImage = 4;     <br>        } <br>    } <br> <br>    return S_OK; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IExtendContextMenu Implementation <br> <br> <br>// Array of menu item commands to be inserted into the contest menu. <br>// Note - the first item is the menu text, // CCM_SPECIAL_DEFAULT_ITEM <br>// the second item is the status string <br>static CONTEXTMENUITEM menuItems[] =  <br>{  <br>    { <br>        L"Command 1", L"Sample extension menu added by snapin (Command 1)", <br>        IDM_COMMAND1, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0 <br>    }, <br>    { <br>        L"Command 2", L"Sample extension menu added by snapin (Command 2)", <br>        IDM_COMMAND2, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0 <br>    }, <br>    { NULL, NULL, 0, 0, 0 } <br>}; <br> <br>// Array of view items to be inserted into the context menu. <br>static CONTEXTMENUITEM viewItems[] =  <br>{  <br>    { <br>        L"Calendar", L"Sample OCX custom view", <br>        IDM_SAMPLE_OCX_VIEW, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0 <br>    }, <br>    { <br>        L"Microsoft", L"Sample WEB custom view", <br>        IDM_SAMPLE_WEB_VIEW, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0 <br>    },   <br>    { NULL, NULL, 0, 0, 0 }, <br>}; <br> <br>// guid for custom view <br>static GUID CLSID_SmGraphControl =  <br>        {0xC4D2D8E0L,0xD1DD,0x11CE,0x94,0x0F,0x00,0x80,0x29,0x00,0x43,0x47}; <br> <br>STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,  <br>                                    LPCONTEXTMENUCALLBACK pContextMenuCallback, <br>                                    long *pInsertionAllowed) <br>{ <br>    viewItems[0].fFlags = (m_CustomViewID == VIEW_CALENDAR_OCX) ? MF_CHECKED : 0; <br>    viewItems[1].fFlags = (m_CustomViewID == VIEW_MICROSOFT_URL) ? MF_CHECKED : 0; <br> <br>    return dynamic_cast&lt;CComponentDataImpl*&gt;(m_pComponentData)-&gt; <br>            AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed); <br>} <br> <br> <br>STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br>    INTERNAL* pInternal = ExtractInternalFormat(pDataObject); <br>    if (pInternal == NULL) <br>        return E_FAIL; <br> <br>    if (pInternal-&gt;m_type == CCT_SCOPE) <br>    { <br>        // Handle view specific commands here <br>        switch (nCommandID) <br>        { <br>        case IDM_SAMPLE_WEB_VIEW: <br>        case IDM_SAMPLE_OCX_VIEW: <br>            m_CustomViewID = (nCommandID == IDM_SAMPLE_OCX_VIEW) ?  <br>                                    VIEW_CALENDAR_OCX : VIEW_MICROSOFT_URL; <br> <br>            // Ask console to reslelect the node to force a new view <br>            if (pInternal-&gt;m_cookie == 0) <br>            { <br>                CComponentDataImpl* pCCDI =  <br>                    dynamic_cast&lt;CComponentDataImpl*&gt;(m_pComponentData); <br> <br>                ASSERT(pCCDI != NULL); <br> <br>                m_pConsole-&gt;SelectScopeItem(pCCDI-&gt;m_pStaticRoot); <br>            } <br>            else <br>            { <br>                CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(pInternal-&gt;m_cookie); <br>                m_pConsole-&gt;SelectScopeItem(pFolder-&gt;m_pScopeItem-&gt;ID); <br>            } <br>            break; <br>         <br>        case MMCC_STANDARD_VIEW_SELECT: <br>            m_CustomViewID = VIEW_DEFAULT_LV; <br>            break; <br> <br>        default: <br>            // Pass non-view specific commands to ComponentData <br>            return dynamic_cast&lt;CComponentDataImpl*&gt;(m_pComponentData)-&gt; <br>                Command(nCommandID, pDataObject); <br>        } <br>    } <br>    else if (pInternal-&gt;m_type == CCT_RESULT) <br>    { <br> <br>        // Handle each of the commands. <br>        switch (nCommandID) <br>        { <br>        case IDM_COMMAND1: <br>        case IDM_COMMAND2: <br>        { <br>            m_pResult-&gt;ModifyViewStyle(MMC_SINGLESEL, (MMC_RESULT_VIEW_STYLE)0); <br> <br>            RESULTDATAITEM rdi; <br>            ZeroMemory(&amp;rdi, sizeof(rdi)); <br>             <br>            rdi.mask = RDI_STATE; <br>            rdi.nState = LVIS_SELECTED; <br>            rdi.nIndex = -1; <br>            m_pResult-&gt;GetNextItem(&amp;rdi); <br> <br>            int iSel = rdi.nIndex; <br> <br>            RESULT_DATA* pData; <br> <br>            // if virtual view, derive result item from the index <br>            if (m_bVirtualView) <br>            { <br>                pData = GetVirtualResultItem(iSel); <br>            } <br>            // else get the cookie (which is result item ptr) <br>            else </code></pre>
<p>
</p>
<pre><code>{ <br>                ZeroMemory(&amp;rdi, sizeof(rdi)); <br>                rdi.mask = RDI_PARAM; <br>                rdi.nIndex = iSel; <br>                HRESULT hr = m_pResult-&gt;GetItem(&amp;rdi); <br>                ASSERT(SUCCEEDED(hr)); <br>                ASSERT(rdi.lParam != 0); <br> <br>                pData = reinterpret_cast&lt;RESULT_DATA*&gt;(rdi.lParam); <br>            } <br> <br>            CString strBuf = (nCommandID == IDM_COMMAND1) ?  <br>                _T("\t Command 1 executed.\n\n") : _T("\t Command 2 executed.\n\n"); <br> <br>            strBuf += pData-&gt;szName; <br>            strBuf += _T(" is the currently selected item."); <br> <br>            AfxMessageBox(strBuf); <br> <br>            // change image in list <br>            if (!m_bVirtualView) <br>            { <br>                ZeroMemory(&amp;rdi, sizeof(rdi)); <br>                rdi.mask = RDI_IMAGE; <br>                rdi.nIndex = iSel; <br>                rdi.nImage = 3; <br>                HRESULT hr = m_pResult-&gt;SetItem(&amp;rdi); <br>                ASSERT(SUCCEEDED(hr)); <br>            } <br>        } <br>        break; <br> <br>        default: <br>            ASSERT(FALSE); // Unknown command! <br>            break; <br>        } <br>    } <br>    else <br>    { <br>        ASSERT(0); <br>    } <br> <br>    ::GlobalFree(reinterpret_cast&lt;HANDLE&gt;(pInternal)); <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CSnapin::GetClassID(CLSID *pClassID) <br>{ <br>    ASSERT(pClassID != NULL); <br> <br>    // Copy the CLSID for this snapin <br>    *pClassID = CLSID_Snapin; <br> <br>    return E_NOTIMPL; <br>} <br> <br>STDMETHODIMP CSnapin::IsDirty() <br>{ <br>    // Always save / Always dirty. <br>    return ThisIsDirty() ? S_OK : S_FALSE; <br>} <br> <br>STDMETHODIMP CSnapin::Load(IStream *pStm) <br>{ <br>    DBX_PRINT(_T(" ----------  CSnapin::Load&lt;0x08x&gt;\n"), this); <br>    ASSERT(m_bInitializedC); <br> <br>    ASSERT(pStm); <br>    // Read the string <br>    char psz[10]; <br>    ULONG nBytesRead; <br>    HRESULT hr = pStm-&gt;Read(psz, 10, &amp;nBytesRead); <br> <br>    // Verify that the read succeeded <br>    ASSERT(SUCCEEDED(hr) &amp;&amp; nBytesRead == 10); <br> <br>    // check to see if the string is the correct string <br>    ASSERT(strcmp("987654321", psz) == 0); <br> <br>    ClearDirty(); <br> <br>    return SUCCEEDED(hr) ? S_OK : E_FAIL; <br>} <br> <br>STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL fClearDirty) <br>{ <br>    DBX_PRINT(_T(" ----------  CSnapin::Save&lt;0x08x&gt;\n"), this); <br>    ASSERT(m_bInitializedC); <br> <br>    ASSERT(pStm); <br> <br>    // Write the string <br>    ULONG nBytesWritten; <br>    HRESULT hr = pStm-&gt;Write("987654321", 10, &amp;nBytesWritten); <br> <br>    // Verify that the write operation succeeded <br>    ASSERT(SUCCEEDED(hr) &amp;&amp; nBytesWritten == 10); <br>    if (FAILED(hr)) <br>        return STG_E_CANTSAVE; <br> <br>    if (fClearDirty) <br>        ClearDirty(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize) <br>{ <br>    ASSERT(pcbSize); <br> <br>    // Set the size of the string to be saved <br>    ULISet32(*pcbSize, 10); <br> <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IComponentData implementation <br> <br>DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl); <br> <br>CComponentDataImpl::CComponentDataImpl() <br>    : m_bIsDirty(TRUE), m_pScope(NULL), m_pConsole(NULL),  <br>      m_bInitializedCD(false), m_bDestroyedCD(false) <br>{ <br>    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl); <br> <br>#ifdef _DEBUG <br>    m_cDataObjects = 0; <br>#endif <br>} <br> <br>CComponentDataImpl::~CComponentDataImpl() <br>{ <br>    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl); <br> <br>    ASSERT(m_pScope == NULL); <br>     <br>    ASSERT(!m_bInitializedCD || m_bDestroyedCD); <br> <br>    // Some snap-in is hanging on to data objects. <br>    // If they access, it will crash!!! <br>    ASSERT(m_cDataObjects &lt;= 1); <br>} <br> <br>STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown) <br>{ <br>    DBX_PRINT(_T(" ----------  CComponentDataImpl::Initialize&lt;0x08x&gt;\n"), this); <br>    m_bInitializedCD = true; <br> <br>    ASSERT(pUnknown != NULL); <br>    HRESULT hr; <br> <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    // MMC should only call ::Initialize once! <br>    ASSERT(m_pScope == NULL); <br>    pUnknown-&gt;QueryInterface(IID_IConsoleNameSpace,  <br>                    reinterpret_cast&lt;void**&gt;(&amp;m_pScope)); <br> <br>    // add the images for the scope tree <br>    ::CBitmap bmp16x16; <br>    LPIMAGELIST lpScopeImage; <br> <br>    hr = pUnknown-&gt;QueryInterface(IID_IConsole, reinterpret_cast&lt;void**&gt;(&amp;m_pConsole)); <br>    ASSERT(hr == S_OK); <br> <br>    hr = m_pConsole-&gt;QueryScopeImageList(&amp;lpScopeImage); <br> <br>    ASSERT(hr == S_OK); <br> <br>    // Load the bitmaps from the dll <br>    bmp16x16.LoadBitmap(IDB_16x16); <br> <br>    // Set the images <br>    lpScopeImage-&gt;ImageListSetStrip(reinterpret_cast&lt;long*&gt;(static_cast&lt;HBITMAP&gt;(bmp16x16)), <br>                      reinterpret_cast&lt;long*&gt;(static_cast&lt;HBITMAP&gt;(bmp16x16)), <br>                       0, RGB(255, 0, 255)); <br> <br>    lpScopeImage-&gt;Release(); <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent) <br>{ <br>    ASSERT(ppComponent != NULL); <br> <br>    CComObject&lt;CSnapin&gt;* pObject; <br>    CComObject&lt;CSnapin&gt;::CreateInstance(&amp;pObject); <br>    ASSERT(pObject != NULL); <br> <br>    // Store IComponentData <br>    pObject-&gt;SetIComponentData(this); <br> <br>    return  pObject-&gt;QueryInterface(IID_IComponent,  <br>                    reinterpret_cast&lt;void**&gt;(ppComponent)); <br>} <br> <br>STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param) <br>{ <br>    ASSERT(m_pScope != NULL); <br>    HRESULT hr; <br> <br>    // Since it's my folder it has an internal format. <br>    // Design Note: for extension.  I can use the fact, that the data object doesn't have  <br>    // my internal format and I should look at the node type and see how to extend it. <br>    if (event == MMCN_PROPERTY_CHANGE) <br>    { <br>        hr = OnProperties(param); <br>    } <br>    else <br>    { <br> <br>        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject); <br> <br>        if (pInternal == NULL) <br>        { <br>            return S_OK; <br>        } <br> <br>        long cookie = pInternal-&gt;m_cookie; <br>        ::GlobalFree(reinterpret_cast&lt;HANDLE&gt;(pInternal)); <br> <br>        switch(event) <br>        { <br>        case MMCN_PASTE: <br>            AfxMessageBox(_T("CSnapin::MMCN_PASTE")); <br>            break; <br>         <br>        case MMCN_DELETE: <br>            hr = OnDelete(cookie); <br>            break; <br> <br>        case MMCN_REMOVE_CHILDREN: <br>            hr = OnRemoveChildren(arg); <br>            break; <br> <br>        case MMCN_RENAME: <br>            hr = OnRename(cookie, arg, param); <br>            break; <br> <br>        case MMCN_EXPAND: <br>            hr = OnExpand(lpDataObject, arg, param); <br>            break; <br> <br>        default: <br>            break; <br>        } <br> <br>    } <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::Destroy() <br>{ <br>    DBX_PRINT(_T(" ----------  CComponentDataImpl::Destroy&lt;0x08x&gt;\n"), this); <br>    ASSERT(m_bInitializedCD); <br>    m_bDestroyedCD = true; <br>     <br>    // Delete enumerated scope items <br>    DeleteList();  <br> <br>    SAFE_RELEASE(m_pScope); <br>    SAFE_RELEASE(m_pConsole); <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject) <br>{ <br>#ifdef _DEBUG <br>    if (cookie == 0) <br>    { <br>        ASSERT(type != CCT_RESULT); <br>    } <br>    else  <br>    { <br>        ASSERT(type == CCT_SCOPE); <br>         <br>        DWORD dwItemType = GetItemType(cookie); <br>        ASSERT(dwItemType == SCOPE_ITEM); <br>    } <br>#endif  <br> <br>    return _QueryDataObject(cookie, type, this, ppDataObject); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//// IPersistStream interface members <br> <br>STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID) <br>{ <br>    ASSERT(pClassID != NULL); <br> <br>    // Copy the CLSID for this snapin <br>    *pClassID = CLSID_Snapin; <br> <br>    return E_NOTIMPL; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::IsDirty() <br>{ <br>    // Always save / Always dirty. <br>    return ThisIsDirty() ? S_OK : S_FALSE; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::Load(IStream *pStm) <br>{ <br>    DBX_PRINT(_T(" ----------  CComponentDataImpl::Load&lt;0x08x&gt;\n"), this); <br> <br>    ASSERT(pStm); <br>    ASSERT(m_bInitializedCD); <br> <br>    // Read the string <br>    char psz[10]; <br>    ULONG nBytesRead; <br>    HRESULT hr = pStm-&gt;Read(psz, 10, &amp;nBytesRead); <br> <br>    // Verify that the read succeeded <br>    ASSERT(SUCCEEDED(hr) &amp;&amp; nBytesRead == 10); <br> <br>    // check to see if the string is the correct string <br>    ASSERT(strcmp("123456789", psz) == 0); <br> <br>    ClearDirty(); <br> <br>    return SUCCEEDED(hr) ? S_OK : E_FAIL; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty) <br>{ <br>    DBX_PRINT(_T(" ----------  CComponentDataImpl::Save&lt;0x08x&gt;\n"), this); <br> <br>    ASSERT(pStm); <br>    ASSERT(m_bInitializedCD); <br> <br>    // Write the string <br>    ULONG nBytesWritten; <br>    HRESULT hr = pStm-&gt;Write("123456789", 10, &amp;nBytesWritten); <br> <br>    // Verify that the write operation succeeded <br>    ASSERT(SUCCEEDED(hr) &amp;&amp; nBytesWritten == 10); <br>    if (FAILED(hr)) <br>        return STG_E_CANTSAVE; <br> <br>    if (fClearDirty) <br>        ClearDirty(); <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize) <br>{ <br>    ASSERT(pcbSize); <br> <br>    // Set the size of the string to be saved <br>    ULISet32(*pcbSize, 10); <br> <br>    return S_OK; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//// Notify handlers for IComponentData <br> <br>HRESULT CComponentDataImpl::OnDelete(long cookie) <br>{ <br>    return S_OK; <br>} <br> <br>HRESULT CComponentDataImpl::OnRemoveChildren(long arg) <br>{ <br>    return S_OK; <br>} <br> <br>HRESULT CComponentDataImpl::OnRename(long cookie, long arg, long param) <br>{ <br>    if (arg == 0) <br>        return S_OK; <br>     <br>    LPOLESTR pszNewName = reinterpret_cast&lt;LPOLESTR&gt;(param); <br>    if (pszNewName == NULL) <br>        return E_INVALIDARG; <br> <br>    CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(cookie); <br>    ASSERT(pFolder != NULL); <br>    if (pFolder == NULL) <br>        return E_INVALIDARG; <br> <br>    pFolder-&gt;SetName(pszNewName); <br>     <br>    return S_OK; <br>} <br> <br>HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject, long arg, long param) <br>{ <br>    if (arg == TRUE) <br>    { <br>        // Did Initialize get called? <br>        ASSERT(m_pScope != NULL); <br>        EnumerateScopePane(lpDataObject, param); <br>    } <br> <br>    return S_OK; <br>} <br> <br>HRESULT CComponentDataImpl::OnSelect(long cookie, long arg, long param) <br>{ <br>    return E_UNEXPECTED; <br>} <br> <br>HRESULT CComponentDataImpl::OnProperties(long param) <br>{ <br>    if (param == NULL) <br>    { <br>        return S_OK; <br>    } <br> <br>    ASSERT(param != NULL); <br>    CFolder* pFolder = new CFolder(); <br> <br>    // Create a new folder object <br>    pFolder-&gt;Create( reinterpret_cast&lt;LPOLESTR&gt;(param), 0, 0, STATIC, FALSE); <br> <br>    // The static folder in the last item in the list <br>    POSITION pos = m_scopeItemList.GetTailPosition(); <br>    if (pos == 0) <br>    { <br>      //  CreateFolderList(); <br>        pos = m_scopeItemList.GetTailPosition(); <br>    } <br> <br>    ASSERT(pos); <br> <br>    // Add it to the internal list <br>    if (pos) <br>    { <br>        CFolder* pItem = m_scopeItemList.GetAt(pos); <br>        m_scopeItemList.InsertBefore(pos, pFolder); <br> <br>        pFolder-&gt;m_pScopeItem-&gt;relativeID = pItem-&gt;m_pScopeItem-&gt;relativeID; <br> <br>        // Set the folder as the cookie <br>        pFolder-&gt;m_pScopeItem-&gt;mask |= SDI_PARAM; <br>        pFolder-&gt;m_pScopeItem-&gt;lParam = reinterpret_cast&lt;LPARAM&gt;(pFolder); <br>        pFolder-&gt;SetCookie(reinterpret_cast&lt;long&gt;(pFolder)); <br>        m_pScope-&gt;InsertItem(pFolder-&gt;m_pScopeItem); <br>    } <br> <br>    ::GlobalFree(reinterpret_cast&lt;void*&gt;(param)); <br> <br>    return S_OK; <br>} <br> <br> <br>void CComponentDataImpl::CreateFolderList(LPDATAOBJECT lpDataObject) <br>{ <br>    CFolder* pFolder; <br>     <br>    ASSERT(lpDataObject != NULL); <br> <br>    wchar_t* pWkStation = ExtractWorkstation(lpDataObject); <br>    ASSERT(pWkStation != NULL); <br> <br>    CLSID* pCoClassID = ExtractClassID(lpDataObject); <br>    ASSERT(pCoClassID != NULL); <br> <br>    // Determine which folder set to use based on context information <br>    FOLDER_DATA* pFolderSet = FolderData; <br>    BOOL bExtend = FALSE; <br>     <br>    if (!IsEqualCLSID(*pCoClassID, GetCoClassID())) <br>    { <br>        pFolderSet = ExtFolderData; <br>        bExtend = TRUE; <br>        TRACE(_T("Using Extension Data\n")); <br>    } <br> <br>    ASSERT(m_scopeItemList.GetCount() == 0); <br>    wchar_t buf[100]; <br> <br>    for (int i=0; i &lt; NUM_FOLDERS; i++) <br>    { <br>        pFolder = new CFolder(); <br>        buf[0] = NULL; <br> <br>        USES_CONVERSION; <br> <br>        wcscpy(buf, pFolderSet[i].szName); <br> <br>        // Add context info to the folder name <br>        if (bExtend) <br>            wcscat(buf, pWkStation); <br> <br>        // Create the folder objects with static data <br>        pFolder-&gt;Create(buf, FOLDER_IMAGE_IDX, OPEN_FOLDER_IMAGE_IDX,  <br>            pFolderSet[i].type, FALSE); <br> <br>        m_scopeItemList.AddTail(pFolder); <br>    } <br> <br>    // mark cookie for last item <br>    pFolder-&gt;SetCookie(NULL);   <br> <br>    // Free memory from data object extraction <br>    ::GlobalFree(reinterpret_cast&lt;HGLOBAL&gt;(pWkStation)); <br>    ::GlobalFree(reinterpret_cast&lt;HGLOBAL&gt;(pCoClassID)); <br>} <br> <br>void CComponentDataImpl::EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent) <br>{ <br>    int i; <br> <br>    ASSERT(m_pScope != NULL); // make sure we QI'ed for the interface <br>    ASSERT(lpDataObject != NULL); <br> <br>    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject); <br> <br>    if (pInternal == NULL) <br>        return ; <br> <br>    long cookie = pInternal-&gt;m_cookie; <br> <br>    // Only the static node has enumerated children <br>    if (cookie != NULL) <br>        return ; <br> <br>    ::GlobalFree(reinterpret_cast&lt;HANDLE&gt;(pInternal)); <br> <br>    // Initialize folder list if empty <br>    if (m_scopeItemList.GetCount() == 0) <br>        CreateFolderList(lpDataObject); <br> <br>    // Enumerate the scope pane <br>    // return the folder object that represents the cookie <br>    // Note - for large list, use dictionary <br>    CFolder* pStatic = FindObject(cookie); <br> <br>    ASSERT(!pStatic-&gt;IsEnumerated()); <br>    // Note - Each cookie in the scope pane represents a folder. <br>    // A released product may have more then one level of children. <br>    // This sample assumes the parent node is one level deep. <br> <br>    ASSERT(pParent != NULL);  <br> <br>    // Cache the HSCOPEITEM of the static root. <br>    if (cookie == NULL) <br>        m_pStaticRoot = pParent; <br> <br>    POSITION pos = m_scopeItemList.GetHeadPosition(); <br>    CFolder* pFolder; <br> <br>    for (i=0; (i &lt; (NUM_FOLDERS - 1)) &amp;&amp; (pos != NULL); i++) <br>    { <br>        pFolder = m_scopeItemList.GetNext(pos); <br>        ASSERT(pFolder); <br> <br>        // Set the parent <br>        pFolder-&gt;m_pScopeItem-&gt;relativeID = pParent; <br> <br>        // Set the folder as the cookie <br>        pFolder-&gt;m_pScopeItem-&gt;mask |= SDI_PARAM; <br>        pFolder-&gt;m_pScopeItem-&gt;lParam = reinterpret_cast&lt;LPARAM&gt;(pFolder); <br>        pFolder-&gt;SetCookie(reinterpret_cast&lt;long&gt;(pFolder)); <br>        m_pScope-&gt;InsertItem(pFolder-&gt;m_pScopeItem); <br> <br>        // Note - On return, the ID member of 'm_pScopeItem'  <br>        // contains the handle to the newly inserted item! <br>        ASSERT(pFolder-&gt;m_pScopeItem-&gt;ID != NULL); <br>    } <br> <br>    // Last folder added is the static folder <br>    pStatic-&gt;Set(TRUE);     // folder has been enumerated <br>    pStatic-&gt;m_pScopeItem-&gt;relativeID = pParent; <br>} <br> <br>void CComponentDataImpl::DeleteList() <br>{ <br>    POSITION pos = m_scopeItemList.GetHeadPosition(); <br> <br>    while (pos) <br>        delete m_scopeItemList.GetNext(pos); <br>} <br> <br>CFolder* CComponentDataImpl::FindObject(long cookie) <br>{ <br>    POSITION pos = m_scopeItemList.GetHeadPosition(); <br>    CFolder* pFolder = NULL; <br> <br>    while(pos) <br>    { <br>        pFolder = m_scopeItemList.GetNext(pos); <br> <br>        if (*pFolder == cookie) <br>            return pFolder; <br>    } <br> <br>    return NULL; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem) <br>{ <br>    ASSERT(pScopeDataItem != NULL); <br>    if (pScopeDataItem == NULL) <br>        return E_POINTER; <br> <br>    CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(pScopeDataItem-&gt;lParam); <br> <br>    ASSERT(pScopeDataItem-&gt;mask &amp; SDI_STR); <br>    pScopeDataItem-&gt;displayname = pFolder-&gt;m_pszName; <br> <br>    //ASSERT(pScopeDataItem-&gt;displayname != NULL); <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB) <br>{ <br>    if (lpDataObjectA == NULL || lpDataObjectB == NULL) <br>        return E_POINTER; <br> <br>    // Make sure both data object are mine <br>    INTERNAL* pA; <br>    INTERNAL* pB; <br>    HRESULT hr = S_FALSE; <br> <br>    pA = ExtractInternalFormat(lpDataObjectA); <br>    pB = ExtractInternalFormat(lpDataObjectA); <br> <br>   if (pA != NULL &amp;&amp; pB != NULL) <br>        hr = (*pA == *pB) ? S_OK : S_FALSE; <br> <br>    ::GlobalFree(reinterpret_cast&lt;HANDLE&gt;(pA)); <br>    ::GlobalFree(reinterpret_cast&lt;HANDLE&gt;(pB)); <br> <br>    return hr; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IExtendPropertySheet2 Implementation <br> <br>HRESULT CComponentDataImpl::DoInsertWizard(LPPROPERTYSHEETCALLBACK lpProvider) <br>{ <br>    CStartUpWizard* pWizard = new CStartUpWizard; <br>    CStartupWizard1* pWizard1 = new CStartupWizard1; <br>     <br>    MMCPropPageCallback(&amp;pWizard-&gt;m_psp97); <br>    MMCPropPageCallback(&amp;pWizard1-&gt;m_psp97); <br> <br>    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&amp;pWizard-&gt;m_psp97); <br> <br>    if (hPage == NULL) <br>        return E_UNEXPECTED; <br> <br>    lpProvider-&gt;AddPage(hPage); <br> <br>    hPage = CreatePropertySheetPage(&amp;pWizard1-&gt;m_psp97); <br> <br>    if (hPage == NULL) <br>        return E_UNEXPECTED; <br> <br>    lpProvider-&gt;AddPage(hPage); <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::GetWatermarks(HBITMAP* lphWatermark, HBITMAP* lphHeader,  <br>                                               HPALETTE* lphPalette, BOOL* pbStretch) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    *lphHeader = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_BANNER)); <br>    *lphWatermark = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_WATERMARK)); <br>    *pbStretch = TRUE; // force the watermark bitmap to stretch <br>     <br>    return S_OK; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,  <br>                    long handle,  <br>                    LPDATAOBJECT lpIDataObject) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    // Look at the data object and determine if this an extension or a primary <br>    ASSERT(lpIDataObject != NULL); <br> <br> <br>    // Look at the data object and see if the snap-in manager is asking for pages <br>    INTERNAL* pInternal= ExtractInternalFormat(lpIDataObject); <br> <br>    if (pInternal != NULL) <br>    {    <br>        DATA_OBJECT_TYPES type = pInternal-&gt;m_type; <br>        FREE_DATA(pInternal); <br> <br>        if (type == CCT_SNAPIN_MANAGER) <br>        { <br>            HRESULT hr = DoInsertWizard(lpProvider); <br>            return hr; <br>        } <br>    } <br> <br>    CLSID* pCoClassID = ExtractClassID(lpIDataObject); <br> <br>    if(pCoClassID == NULL) <br>    { <br>        ASSERT(FALSE); <br>        return E_UNEXPECTED; <br>    } <br> <br>    CPropertyPage* pBasePage; <br> <br>    // Determine which <br>    // Note: Should check the node type, but the sample only has 1 <br>    if (IsEqualCLSID(*pCoClassID, GetCoClassID())) <br>    { <br>        // Create the primary property page <br>        CGeneralPage* pPage = new CGeneralPage(); <br>        pPage-&gt;m_hConsoleHandle = handle; <br>        pBasePage = pPage; <br>    } <br>    else <br>    { <br> <br>        // Create the extension property page <br>        CExtensionPage* pPage = new CExtensionPage(); <br>        pBasePage = pPage; <br> <br>        wchar_t* pWkStation = ExtractWorkstation(lpIDataObject); <br> <br>        if (pWkStation == NULL) <br>        { <br>            ASSERT(FALSE); <br>            return E_FAIL; <br>        } <br> <br>        // Save the workstation name <br>        pPage-&gt;m_szText = pWkStation;  <br>        FREE_DATA(pWkStation); <br> <br>    } <br> <br>    FREE_DATA(pCoClassID); <br> <br>    // Object gets deleted when the page is destroyed <br>    ASSERT(lpProvider != NULL); <br> <br>    HRESULT hr = MMCPropPageCallback(&amp;pBasePage-&gt;m_psp); <br> <br>    if (SUCCEEDED(hr)) <br>    { <br> <br>        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&amp;pBasePage-&gt;m_psp); <br> <br>        if (hPage == NULL) <br>            return E_UNEXPECTED; <br> <br>        lpProvider-&gt;AddPage(hPage); <br>    } <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br>     <br>    // Get the node type and see if it's one of mine <br> <br>    // if (nodetype == one of mine) <br>    //      do this <br>    // else <br>    //      see which node type it is and answer the question <br> <br>    return S_OK; <br>} <br> <br>BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject) <br>{ <br>    BOOL bResult = FALSE; <br>    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject); <br> <br>    if (pInternal-&gt;m_cookie == NULL &amp;&amp;  <br>        (pInternal-&gt;m_type == CCT_SCOPE || pInternal-&gt;m_type == CCT_RESULT)) <br>        bResult = TRUE; <br> <br>    FREE_DATA(pInternal); <br> <br>    return bResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IExtendContextMenu implementation <br>// <br>STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,  <br>                                    LPCONTEXTMENUCALLBACK pContextMenuCallback, <br>                                    long *pInsertionAllowed) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    // Note - snap-ins need to look at the data object and determine <br>    // in what context, menu items need to be added. They must also <br>    // observe the insertion allowed flags to see what items can be  <br>    // added. <br> <br>    if (IsMMCMultiSelectDataObject(pDataObject) == TRUE) <br>        return S_FALSE; <br> <br>    INTERNAL* pInternal = ExtractInternalFormat(pDataObject); <br>    BOOL bCmd1IsDefault = (pInternal-&gt;m_type == CCT_RESULT); <br> <br>    if (bCmd1IsDefault) <br>        menuItems[0].fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM; <br>    else  <br>        menuItems[0].fSpecialFlags = 0; <br> <br>    // Loop through and add each of the menu items <br>    if (*pInsertionAllowed &amp; CCM_INSERTIONALLOWED_TOP) <br>    { <br>        for (LPCONTEXTMENUITEM m = menuItems; m-&gt;strName; m++) <br>        { <br>            hr = pContextMenuCallback-&gt;AddItem(m); <br> <br>            if (FAILED(hr)) <br>                break; <br>        } <br>    } <br> <br>    // Loop through and add each of the view items <br>    if (*pInsertionAllowed &amp; CCM_INSERTIONALLOWED_VIEW) <br>    { <br>        for (LPCONTEXTMENUITEM m = viewItems; m-&gt;strName; m++) <br>        { <br>            hr = pContextMenuCallback-&gt;AddItem(m); <br> <br>            if (FAILED(hr)) <br>                break; <br>        } <br>    } <br> <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject) <br>{ <br>    // Note - snap-ins need to look at the data object and determine <br>    // in what context the command is being called. <br> <br>    // Handle each of the commands. <br>    switch (nCommandID) <br>    { <br>    case IDM_COMMAND1: <br>    { <br>        INTERNAL* pi = ExtractInternalFormat(pDataObject); <br>        ASSERT(pi); <br>        ASSERT(pi-&gt;m_type != CCT_RESULT); <br>        CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(pi-&gt;m_cookie); <br>        if (pFolder) <br>            m_pConsole-&gt;SelectScopeItem(pFolder-&gt;m_pScopeItem-&gt;ID); <br>        break; <br>    } <br>    case IDM_COMMAND2: <br>        ASSERT(m_pConsole); <br>        m_pConsole-&gt;MessageBox(L"Snapin Menu Comand Selected",  <br>                                    menuItems[nCommandID].strName, MB_OK, NULL); <br>        break; <br> <br>    default: <br>        ASSERT(FALSE); // Unknown command! <br>        break; <br>    } <br> <br>    return S_OK; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IExtendControlbar implementation <br>// <br> <br> <br>STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar) <br>{ <br>    TRACE(_T("CSnapin::SetControlbar(%ld)\n"),pControlbar); <br> <br>    // Please don't delete this. Required to make sure we pick up the bitmap <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    if (pControlbar != NULL) <br>    { <br> <br>        // Hold on to the controlbar interface. <br>        if (m_pControlbar) <br>        { <br>            m_pControlbar-&gt;Release(); <br>        } <br> <br>        m_pControlbar = pControlbar; <br>        m_pControlbar-&gt;AddRef(); <br> <br>        HRESULT hr=S_FALSE; <br> <br>        if (!m_pMenuButton1) <br>        { <br>            hr = m_pControlbar-&gt;Create(MENUBUTTON, this,  <br>                                reinterpret_cast&lt;LPUNKNOWN*&gt;(&amp;m_pMenuButton1)); <br>            ASSERT(SUCCEEDED(hr)); <br>        }             <br> <br>        if (m_pMenuButton1) <br>        { <br>            // Unlike toolbar buttons, menu buttons need to be added every time. <br>            hr = m_pMenuButton1-&gt;AddButton(FOLDEREX_MENU, L"FolderEx", L"Extended Folder Menu"); <br>            ASSERT(SUCCEEDED(hr)); <br>            hr = m_pMenuButton1-&gt;AddButton(FILEEX_MENU, L"FileEx", L"Extended File Menu"); <br>            ASSERT(SUCCEEDED(hr)); <br>        } <br> <br> <br>        // Create the Toolbar 1 <br>        if (!m_pToolbar1) <br>        { <br>            hr = m_pControlbar-&gt;Create(TOOLBAR, this, reinterpret_cast&lt;LPUNKNOWN*&gt;(&amp;m_pToolbar1)); <br>            ASSERT(SUCCEEDED(hr)); <br> <br> <br>            // Add the bitmap <br>            m_pbmpToolbar1 = new ::CBitmap; <br>            m_pbmpToolbar1-&gt;LoadBitmap(IDB_TOOLBAR1); <br>            hr = m_pToolbar1-&gt;AddBitmap(11, *m_pbmpToolbar1, 16, 16, RGB(255, 0, 255)); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>            // Add the buttons to the toolbar <br>            hr = m_pToolbar1-&gt;AddButtons(ARRAYLEN(SnapinButtons), SnapinButtons); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>        } <br> <br> <br>        // TOOLBAR 2 <br> <br>            // Create the Toolbar 2 <br>        if (!m_pToolbar2) <br>        { <br>            hr = m_pControlbar-&gt;Create(TOOLBAR, this, reinterpret_cast&lt;LPUNKNOWN*&gt;(&amp;m_pToolbar2)); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>            // Add the bitmap <br>            m_pbmpToolbar2 = new ::CBitmap; <br>            m_pbmpToolbar2-&gt;LoadBitmap(IDB_TOOLBAR2); <br>            hr = m_pToolbar2-&gt;AddBitmap(36, *m_pbmpToolbar2, 16, 16, RGB(192,192,192)); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>            // Add the buttons to the toolbar <br>            hr = m_pToolbar2-&gt;AddButtons(ARRAYLEN(SnapinButtons2), SnapinButtons2); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>        } <br> <br> <br>    } <br>    else <br>    { <br>        SAFE_RELEASE(m_pControlbar); <br>    } <br> <br> <br>    return S_OK; <br>} <br> <br> <br>void CSnapin::OnButtonClick(LPDATAOBJECT pdtobj, int idBtn) <br>{ <br>    TCHAR name[128]; <br>    GetItemName(pdtobj, name); <br> <br>    TCHAR buf[200]; <br>    wsprintf(buf, _T("Toolbar button&lt;%d&gt; was clicked. \nThe currently selected result item is &lt;%s&gt;"), idBtn, name); <br>    ::MessageBox(NULL, buf, _T("TRACE"), MB_OK); <br>} <br> <br> <br>STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, long arg, long param) <br>{ <br>    HRESULT hr=S_FALSE; <br> <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    switch (event) <br>    { <br>    case MMCN_BTN_CLICK: <br>        //TCHAR szMessage[MAX_PATH]; <br>        //wsprintf(szMessage, _T("CommandID %ld"),param); <br>        //AfxMessageBox(szMessage); <br>        OnButtonClick(reinterpret_cast&lt;LPDATAOBJECT&gt;(arg), param); <br>        break; <br> <br>    case MMCN_DESELECT_ALL: <br>    case MMCN_SELECT: <br>        HandleExtToolbars((event == MMCN_DESELECT_ALL), arg, param); <br>        break; <br> <br>    case MMCN_MENU_BTNCLICK: <br>        HandleExtMenus(arg, param); <br>        break; <br> <br>    default: <br>        break; <br>    } <br> <br> <br>    return S_OK; <br>} <br> <br>// This compares two data objects to see if they are the same object.   <br>// return  <br>//    S_OK if equal otherwise S_FALSE <br>// <br>// Note: check to make sure both objects belong to the snap-in. <br>// <br> <br>STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB) <br>{ <br>    return S_FALSE; <br>} <br> <br> <br>// This compare is used to sort the item's in the listview <br>//  <br>// Parameters: <br>// <br>// lUserParam - user param passed in when IResultData::Sort() was called <br>// cookieA - first item to compare <br>// cookieB - second item to compare <br>// pnResult [in, out]- contains the col on entry,  <br>//          -1, 0, 1 based on comparison for return value. <br>// <br>// Note: Assum sort is ascending when comparing. <br> <br> <br>STDMETHODIMP CSnapin::Compare(long lUserParam, long cookieA, long cookieB, int* pnResult) <br>{ <br>    if (pnResult == NULL) <br>    { <br>        ASSERT(FALSE); <br>        return E_POINTER; <br>    } <br> <br>    // check col range <br>    int nCol = *pnResult; <br>    ASSERT(nCol &gt;=0 &amp;&amp; nCol&lt; 3); <br> <br>    *pnResult = 0; <br> <br>    USES_CONVERSION; <br> <br>    LPTSTR szStringA;  <br>    LPTSTR szStringB;  <br> <br>    RESULT_DATA* pDataA = reinterpret_cast&lt;RESULT_DATA*&gt;(cookieA); <br>    RESULT_DATA* pDataB = reinterpret_cast&lt;RESULT_DATA*&gt;(cookieB); <br>     <br>     <br>    ASSERT(pDataA != NULL &amp;&amp; pDataB != NULL); <br> <br>    if (nCol == 0) <br>    { <br>        szStringA = OLE2T(pDataA-&gt;szName); <br>        szStringB = OLE2T(pDataB-&gt;szName); <br>    } <br>    else if(nCol == 1) <br>    { <br>        szStringA = OLE2T(pDataA-&gt;szSize); <br>        szStringB = OLE2T(pDataB-&gt;szSize); <br>    } <br>    else  <br>    { </code></pre>
<p>
</p>
<pre><code>szStringA = OLE2T(pDataA-&gt;szType); <br>        szStringB = OLE2T(pDataB-&gt;szType)   ; <br>    } <br> <br>    ASSERT(szStringA != NULL); <br>    ASSERT(szStringB != NULL); <br> <br>    *pnResult = _tcscmp(szStringA, szStringB); <br> <br>     <br>    return S_OK; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IResultOwnerData implementation <br>// <br>STDMETHODIMP CSnapin::FindItem (LPRESULTFINDINFO pFindInfo, int* pnFoundIndex) <br>{ <br>    // find next item that matches the string (exact or partial) <br>    // if matched found, set FoundIndex and return S_OK <br> <br>    // For the sample all items are named by their index number <br>    // so we don't do a real string search. Also, to simplify the code <br>    // the routine assumes a partial match search with wrap, which is what <br>    // keyboard navigation calls use. <br>    ASSERT((pFindInfo-&gt;dwOptions &amp; (RFI_PARTIAL | RFI_WRAP)) == (RFI_PARTIAL | RFI_WRAP)); <br> <br>    USES_CONVERSION; <br> <br>    TCHAR* lpszFind = OLE2T(pFindInfo-&gt;psz); <br> <br>    TRACE(_T("CSnapin::FindItem(\"%s\")"), lpszFind); <br> <br>    // convert search string to number <br>    int nMatchVal = 0; <br>    TCHAR* pch = lpszFind;     <br>    while (*pch &gt;= _T('0') &amp;&amp; *pch &lt;= _T('9') &amp;&amp; nMatchVal &lt; NUM_VIRTUAL_ITEMS) <br>        nMatchVal = nMatchVal * 10 + (*pch++ - _T('0')); <br> <br>    // if string has a non-decimal char or is too large, it won't match anything  <br>    if (*pch != 0 || nMatchVal &gt;= NUM_VIRTUAL_ITEMS) <br>        return S_FALSE; <br>     <br>    // if ascending sequence <br>    if (!(m_dwVirtualSortOptions &amp; RSI_DESCENDING)) <br>    { <br>        int nStartVal = pFindInfo-&gt;nStart; <br> <br>        // if match is less than start (but not zero), locate first value above start that matches <br>        // otherwise the match number itself it the answer <br>        if (nMatchVal &lt; nStartVal &amp;&amp; nMatchVal != 0) <br>        { <br>             // find scale factor to reach value &gt;= start value             <br>            int nScale = 1; <br>            while (nMatchVal * nScale &lt; nStartVal) <br>                nScale *= 10; <br>         <br>            // check special case of start value beginning with the match digits   <br>            int nTestVal = (nStartVal * 10 - nMatchVal * nScale) &lt; nScale ? nStartVal : nMatchVal * nScale; <br> <br>            // if not too big it's the match, else the match value is the match <br>            if (nTestVal &lt; NUM_VIRTUAL_ITEMS) <br>                nMatchVal = nTestVal; <br>        } <br>    } <br>    else  // descending sequence <br>    { <br>        // convert start index to start value <br>        int nStartVal = (NUM_VIRTUAL_ITEMS - 1) - pFindInfo-&gt;nStart; <br> <br>        if (nMatchVal != 0) <br>        { <br>            // if match number &gt; start, we will have to wrap to find a match <br>            // so use max index as our target <br>            int nTargetVal = (nMatchVal &gt; nStartVal) ? NUM_VIRTUAL_ITEMS - 1 : nStartVal; <br> <br>            // find scale factor that gets closest without going over target <br>            int nScale = 1; <br>            while (nMatchVal * nScale * 10 &lt; nTargetVal) <br>                nScale *= 10; <br> <br>            // check special case of target value beginning with the match digits   <br>            nMatchVal = (nTargetVal - nMatchVal * nScale) &lt; nScale ? nTargetVal : (nMatchVal + 1) * nScale - 1; <br>        }                <br> <br>        // convert match value back to an item index <br>        nMatchVal = (NUM_VIRTUAL_ITEMS - 1) - nMatchVal; <br>    } <br>             <br>    *pnFoundIndex = nMatchVal; <br>         <br>    return S_OK; <br>      <br>} <br> <br> <br>STDMETHODIMP CSnapin::CacheHint (int nStartIndex, int nEndIndex) <br>{ <br>    // If advantageous, use this hint to pre-fetch the result item info that <br>    // is about to be requested. <br>    TRACE(_T("CSnapin::CacheHint(%d,%d)\n"), nStartIndex, nEndIndex); <br> <br>    return S_OK; <br>     <br>} <br> <br>STDMETHODIMP CSnapin::SortItems (int nColumn, DWORD dwSortOptions, long lUserParam) <br>{ <br>    // sort request for user owned result items <br>    // if item order changed return S_OK, else S_FALSE <br>     <br>    // Sample only sorts on the first column (item name) <br> <br>    if ((nColumn == 0) &amp;&amp; (m_dwVirtualSortOptions != dwSortOptions)) <br>    { <br>        m_dwVirtualSortOptions = dwSortOptions; <br>        return S_OK; <br>    } <br> <br>    return S_FALSE; <br>     <br>} <br> <br> <br>void CSnapin::HandleStandardVerbs(bool bDeselectAll, long arg,  <br>                                  LPDATAOBJECT lpDataObject) <br>{ <br>    if (m_CustomViewID != VIEW_DEFAULT_LV) <br>    { <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE); <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); <br> <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE); <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE); <br> <br>        return; <br>    } <br> <br>    if (!bDeselectAll &amp;&amp; lpDataObject == NULL) <br>        return; <br> <br>    // You should crack the data object and enable/disable/hide standard <br>    // commands appropriately.  The standard commands are reset everytime you get <br>    // called. So you must reset them back. <br> <br>    WORD bScope = LOWORD(arg); <br>    WORD bSelect = HIWORD(arg); <br> <br>#if 0 <br>    TCHAR buf[40]; <br>    wsprintf(buf, _T("      %4d - CSnapin::OnSelect&lt;%d, %d&gt;\n"), ++n_count, bScope, bSelect); <br>    ODS(buf); <br>#else  <br>    DBX_PRINT(_T("      %4d - CSnapin::OnSelect&lt;%d, %d&gt;\n"), ++n_count, bScope, bSelect); <br>#endif  <br>     <br> <br>    if (!bDeselectAll &amp;&amp; IsMMCMultiSelectDataObject(lpDataObject) == TRUE) <br>    { <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE); <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE); <br>        return; <br>    } <br> <br>    INTERNAL* pInternal = lpDataObject ? ExtractInternalFormat(lpDataObject) : NULL; <br>     <br>    if (bDeselectAll || !bSelect)  <br>    { <br>        if (bScope) <br>        { <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_OPEN, ENABLED, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_COPY, ENABLED, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE); <br> <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); <br>        } <br>        else  <br>        { <br>            // Result pane background <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PASTE, HIDDEN, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE); <br> <br>            if (pInternal &amp;&amp; pInternal-&gt;m_cookie == 0) <br>            { <br>                m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE); <br>                m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE); <br>            } <br> <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); <br>        } <br> <br>        return; <br>    } <br> <br> <br>    if (m_pConsoleVerb &amp;&amp; pInternal) <br>    { <br>        if (pInternal-&gt;m_type == CCT_SCOPE) <br>        { <br>            // Standard funcitonality support by scope items <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_OPEN, HIDDEN, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_OPEN, ENABLED, TRUE); <br> <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); <br> <br>            // Enable properties for static node only. <br>            if (pInternal-&gt;m_cookie == 0) <br>            { <br>                m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE); <br>                //m_pConsoleVerb-&gt;SetDefaultVerb(MMC_VERB_PROPERTIES); <br>                m_pConsoleVerb-&gt;SetDefaultVerb(MMC_VERB_OPEN); <br>            } <br>            else  <br>            { <br>                m_pConsoleVerb-&gt;SetDefaultVerb(MMC_VERB_OPEN); <br>            } <br> <br>            // Standard funcitonality NOT support by scope items <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE); <br> <br>        } <br>        else <br>        { <br>            // Standard funcitonality support by result items <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE); <br>            m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE); <br>            m_pConsoleVerb-&gt;SetDefaultVerb(MMC_VERB_NONE); <br> <br>            // Standard funcitonality NOT support by result items <br>        } <br> <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE); <br>         <br>        // Standard funcitonality NOT support by all items <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE); <br>        m_pConsoleVerb-&gt;SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE); <br>    } <br>} <br> <br>void EnableToolbar(LPTOOLBAR pToolbar, MMCBUTTON rgSnapinButtons[], int nRgSize, <br>                   BOOL bEnable) <br>{ <br>    for (int i=0; i &lt; nRgSize; ++i) <br>    { <br>        if (rgSnapinButtons[i].idCommand != 0) <br>            pToolbar-&gt;SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,  <br>                                     bEnable); <br>    } <br>} <br> <br> <br>void EnableMenuBtns(LPMENUBUTTON pMenuBtn, MMCBUTTON rgSnapinButtons[], int nRgSize, <br>                   BOOL bEnable) <br>{ <br>    for (int i=0; i &lt; nRgSize; ++i) <br>    { <br>        if (rgSnapinButtons[i].idCommand != 0) <br>            pMenuBtn-&gt;SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,  <br>                                     bEnable); <br>    } <br>} <br> <br>void CSnapin::HandleExtToolbars(bool bDeselectAll, long arg, long param) <br>{ <br>    INTERNAL* pInternal = NULL; <br>    HRESULT hr; <br> <br>    BOOL bScope = (BOOL) LOWORD(arg); <br>    BOOL bSelect = (BOOL) HIWORD(arg); <br> <br>#if 1 <br>{ <br>    if (param) <br>    { <br>        LPDATAOBJECT pDataObject = reinterpret_cast&lt;LPDATAOBJECT&gt;(param); <br>        pInternal = ExtractInternalFormat(pDataObject); <br>    } <br> <br>    TCHAR buf[200]; <br>    wsprintf(buf, _T("      %4d - CExtendControlbar::OnSelect&lt;%d, %d&gt; = %d\n"),  <br>             ++n_count, bScope, bSelect, pInternal ? pInternal-&gt;m_cookie : 0); <br>    ODS(buf); <br>} <br>#else <br>    DBX_PRINT(_T("      %4d - CExtendControlbar::OnSelect&lt;%d, %d&gt;\n"), ++n_count, bScope, bSelect); <br>#endif  <br> <br>    if (bDeselectAll || bSelect == FALSE) <br>    { <br>        ASSERT(m_pToolbar1); <br>        EnableToolbar(m_pToolbar1, SnapinButtons,  <br>                      ARRAYLEN(SnapinButtons), FALSE); <br> <br>        ASSERT(m_pToolbar2); <br>        EnableToolbar(m_pToolbar2, SnapinButtons2,  <br>                      ARRAYLEN(SnapinButtons2), FALSE); <br> <br>        ASSERT(m_pMenuButton1 != NULL); <br>        m_pMenuButton1-&gt;SetButtonState(FOLDEREX_MENU, ENABLED, FALSE); <br>        m_pMenuButton1-&gt;SetButtonState(FILEEX_MENU, ENABLED, FALSE); <br> <br>        return; <br>    } <br> <br>    ASSERT(bSelect == TRUE); <br>    bool bFileExBtn = false; <br>    if (bScope == TRUE) <br>    {                  <br>        LPDATAOBJECT pDataObject = reinterpret_cast&lt;LPDATAOBJECT&gt;(param); <br>         <br>        pInternal = ExtractInternalFormat(pDataObject); <br>        if (pInternal == NULL) <br>            return; <br> <br>        CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(pInternal-&gt;m_cookie); <br> <br>        if (pInternal-&gt;m_cookie == 0) <br>        { <br>            if (IsPrimaryImpl() == TRUE) <br>            { <br>                // Attach the toolbars to the window <br>                hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1); <br>                ASSERT(SUCCEEDED(hr)); <br>     <br>                hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2); <br>                ASSERT(SUCCEEDED(hr)); <br>            } <br>        } <br>        else if ((IsPrimaryImpl() == TRUE &amp;&amp; pFolder-&gt;GetType() == COMPANY) || <br>                 (IsPrimaryImpl() == FALSE &amp;&amp; pFolder-&gt;GetType() == EXT_COMPANY)) <br>        { <br>            // Detach the toolbar2 from the window <br>            hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar2); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>            // Attach the toolbar1 to the window <br>            hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1); <br>            ASSERT(SUCCEEDED(hr)); <br>        } <br>        else if ((IsPrimaryImpl() == TRUE &amp;&amp; pFolder-&gt;GetType() == USER) || <br>                 (IsPrimaryImpl() == FALSE &amp;&amp; pFolder-&gt;GetType() == EXT_USER)) <br>        { <br>            // Detach the toolbar1 from the window <br>            hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar1); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>            // Attach the toolbar2 to the window <br>            hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2); <br>            ASSERT(SUCCEEDED(hr)); <br>        } <br>        else  <br>        { <br>            // Detach the toolbars from the window <br>            hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar1); <br>            ASSERT(SUCCEEDED(hr)); <br> <br>            hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar2); <br>            ASSERT(SUCCEEDED(hr)); <br>        } <br> <br>        FREE_DATA(pInternal); <br> <br>        EnableToolbar(m_pToolbar1, SnapinButtons,  <br>                      ARRAYLEN(SnapinButtons), FALSE); <br> <br>        EnableToolbar(m_pToolbar2, SnapinButtons2,  <br>                      ARRAYLEN(SnapinButtons2), FALSE); <br>    } <br>    else // result item selected. <br>    { <br>        LPDATAOBJECT pDataObject = reinterpret_cast&lt;LPDATAOBJECT&gt;(param); <br> <br>        if (pDataObject != NULL) <br>            pInternal = ExtractInternalFormat(pDataObject);  <br>     <br>        if (pInternal == NULL) <br>            return; <br> <br>        if (pInternal-&gt;m_type == CCT_RESULT) <br>        { <br>            bFileExBtn = true; <br> <br>            ASSERT(m_pToolbar1); <br>            EnableToolbar(m_pToolbar1, SnapinButtons,  <br>                          ARRAYLEN(SnapinButtons), TRUE); <br> <br>            m_pToolbar1-&gt;SetButtonState(1, ENABLED,       FALSE); <br>            m_pToolbar1-&gt;SetButtonState(2, CHECKED,       TRUE);  <br>            m_pToolbar1-&gt;SetButtonState(3, HIDDEN,        TRUE);  <br>            m_pToolbar1-&gt;SetButtonState(4, INDETERMINATE, TRUE);  <br>            m_pToolbar1-&gt;SetButtonState(5, BUTTONPRESSED, TRUE);  <br>             <br>            // Above is the correct way <br>            ASSERT(m_pToolbar2); <br>            m_pToolbar2-&gt;SetButtonState(20, CHECKED,       TRUE); <br>            m_pToolbar2-&gt;SetButtonState(30, HIDDEN,        TRUE); <br>            m_pToolbar2-&gt;SetButtonState(40, INDETERMINATE, TRUE); <br>            m_pToolbar2-&gt;SetButtonState(50, BUTTONPRESSED, TRUE); <br> <br>            EnableToolbar(m_pToolbar2, SnapinButtons2,  <br>                          ARRAYLEN(SnapinButtons2), TRUE); <br>        } <br>        else // sub folder slected <br>        { <br>            CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(pInternal-&gt;m_cookie); <br> <br>            ASSERT(m_pControlbar); <br> <br>            if (pInternal-&gt;m_cookie == 0) <br>            { <br>                if (IsPrimaryImpl() == TRUE) <br>                { <br>                    // Attach the toolbars to the window <br>                    hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1); <br>                    ASSERT(SUCCEEDED(hr)); <br>         <br>                    hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2); <br>                    ASSERT(SUCCEEDED(hr)); <br>                } <br>            } <br>            else if ((IsPrimaryImpl() == TRUE &amp;&amp; pFolder-&gt;GetType() == COMPANY) || <br>                     (IsPrimaryImpl() == FALSE &amp;&amp; pFolder-&gt;GetType() == EXT_COMPANY)) <br>            { <br>                // Detach the toolbar2 from the window <br>                hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar2); <br>                ASSERT(SUCCEEDED(hr)); <br>     <br>                // Attach the toolbar1 to the window <br>                hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1); <br>                ASSERT(SUCCEEDED(hr)); <br>            } <br>            else if ((IsPrimaryImpl() == TRUE &amp;&amp; pFolder-&gt;GetType() == USER) || <br>                     (IsPrimaryImpl() == FALSE &amp;&amp; pFolder-&gt;GetType() == EXT_USER)) <br>            { <br>                // Detach the toolbar1 from the window <br>                hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar1); <br>                ASSERT(SUCCEEDED(hr)); <br>     <br>                // Attach the toolbar2 to the window <br>                hr = m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2); <br>                ASSERT(SUCCEEDED(hr)); <br>            } <br>            else  <br>            { <br>                // Detach the toolbars from the window <br>                hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar1); <br>                ASSERT(SUCCEEDED(hr)); <br>     <br>                hr = m_pControlbar-&gt;Detach((LPUNKNOWN)m_pToolbar2); <br>                ASSERT(SUCCEEDED(hr)); <br>            } <br> <br>            ASSERT(m_pToolbar1); <br>            EnableToolbar(m_pToolbar1, SnapinButtons,  <br>                          ARRAYLEN(SnapinButtons), TRUE); <br> <br>            m_pToolbar1-&gt;SetButtonState(1, ENABLED,       FALSE); <br>            m_pToolbar1-&gt;SetButtonState(2, CHECKED,       TRUE);  <br>            m_pToolbar1-&gt;SetButtonState(3, ENABLED,       TRUE);  <br>            m_pToolbar1-&gt;SetButtonState(4, INDETERMINATE, TRUE);  <br>            m_pToolbar1-&gt;SetButtonState(5, BUTTONPRESSED, TRUE);  <br>             <br> <br>            ASSERT(m_pToolbar2); <br>            EnableToolbar(m_pToolbar2, SnapinButtons2,  <br>                          ARRAYLEN(SnapinButtons2), TRUE); <br> <br>            // Above is the correct way <br>            m_pToolbar2-&gt;SetButtonState(20, CHECKED,       FALSE); <br>            m_pToolbar2-&gt;SetButtonState(30, ENABLED,       TRUE); <br>            m_pToolbar2-&gt;SetButtonState(40, INDETERMINATE, FALSE); <br>            m_pToolbar2-&gt;SetButtonState(50, BUTTONPRESSED, TRUE); <br>        } <br>    } <br> <br>    if (m_pMenuButton1) <br>    { <br>        // Always make sure the menuButton is attached <br>        m_pControlbar-&gt;Attach(MENUBUTTON, m_pMenuButton1); <br> <br>        if (bFileExBtn) <br>        { <br>            m_pMenuButton1-&gt;SetButtonState(FILEEX_MENU, HIDDEN, FALSE); <br>            m_pMenuButton1-&gt;SetButtonState(FOLDEREX_MENU, HIDDEN, TRUE); <br>            m_pMenuButton1-&gt;SetButtonState(FILEEX_MENU, ENABLED, TRUE); <br>        } <br>        else  <br>        { <br>            m_pMenuButton1-&gt;SetButtonState(FOLDEREX_MENU, HIDDEN, FALSE); <br>            m_pMenuButton1-&gt;SetButtonState(FILEEX_MENU, HIDDEN, TRUE); <br>            m_pMenuButton1-&gt;SetButtonState(FOLDEREX_MENU, ENABLED, TRUE); <br>        } <br>    } <br>} <br> <br> <br>void CSnapin::HandleExtMenus(long arg, long param) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    LPDATAOBJECT* ppDataObject = reinterpret_cast&lt;LPDATAOBJECT*&gt;(arg); <br>    LPMENUBUTTONDATA pMenuData = reinterpret_cast&lt;LPMENUBUTTONDATA&gt;(param); <br> <br>    if (ppDataObject == NULL || pMenuData == NULL) <br>    { <br>        ASSERT(FALSE); <br>        return; <br>    } <br>     <br> <br>    ::CMenu menu; <br>    ::CMenu* pMenu = NULL; <br> <br>    switch (pMenuData-&gt;idCommand) <br>    { <br>    case FOLDEREX_MENU: <br>        menu.LoadMenu(FOLDEREX_MENU);  <br>        pMenu = menu.GetSubMenu(0); <br>        break; <br> <br>    case FILEEX_MENU: <br>        menu.LoadMenu(FILEEX_MENU);  <br>        pMenu = menu.GetSubMenu(0); <br>        break; <br> <br>    default: <br>        ASSERT(FALSE); <br>    } <br> <br>    if (pMenu == NULL) <br>        return; <br> <br>    pMenu-&gt;TrackPopupMenu(TPM_RETURNCMD | TPM_NONOTIFY, pMenuData-&gt;x, pMenuData-&gt;y, AfxGetMainWnd());  <br>  <br>} <br> <br> <br>void CSnapin::GetItemName(LPDATAOBJECT pdtobj, LPTSTR pszName) <br>{ <br>    ASSERT(pszName != NULL); <br>    pszName[0] = 0; <br> <br>    INTERNAL* pInternal = ExtractInternalFormat(pdtobj); <br>    ASSERT(pInternal != NULL); <br>    if (pInternal == NULL) <br>        return; <br> <br>    OLECHAR *pszTemp; <br>      <br>    if (pInternal-&gt;m_type == CCT_RESULT) <br>    { <br>        RESULT_DATA* pData; <br>        // if virtual, derive result item from index <br>        // else cookie is the item pointer <br>        if (m_bVirtualView) <br>            pData = GetVirtualResultItem(pInternal-&gt;m_cookie); <br>        else            <br>            pData = reinterpret_cast&lt;RESULT_DATA*&gt;(pInternal-&gt;m_cookie); <br>         <br>        ASSERT(pData != NULL); <br>        pszTemp = pData-&gt;szName; <br>    } <br>    else  <br>    { <br>        CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(pInternal-&gt;m_cookie); <br>        if (pFolder == 0) <br>            pszTemp = L"Static folder"; <br>        else <br>            pszTemp = OLE2T(pFolder-&gt;m_pszName); <br>    } <br> <br>    USES_CONVERSION; <br> <br>    lstrcpy(pszName, OLE2T(pszTemp)); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
