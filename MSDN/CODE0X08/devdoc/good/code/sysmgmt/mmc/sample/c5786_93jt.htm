<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DATAOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5789"></a>DATAOBJ.CPP</h2>
<pre><code>// This is a part of the Microsoft Management Console. <br>// Copyright 1995 - 1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Microsoft Management Console and related <br>// electronic documentation provided with the interfaces. <br> <br> <br>#include "stdafx.h" <br>#include "Service.h"  <br>#include "CSnapin.h" <br>#include "DataObj.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Sample code to show how to Create DataObjects <br>// Minimal error checking for clarity <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Snap-in NodeType in both GUID format and string format <br>// Note - Typically there is a node type for each different object, sample <br>// only uses one node type. <br> <br>unsigned int CDataObject::m_cfNodeType       = 0; <br>unsigned int CDataObject::m_cfNodeTypeString = 0;   <br>unsigned int CDataObject::m_cfDisplayName    = 0;  <br>unsigned int CDataObject::m_cfCoClass        = 0;  <br> <br>unsigned int CDataObject::m_cfInternal       = 0;  <br>unsigned int CDataObject::m_cfMultiSel       = 0; <br> <br> <br> <br>     <br>// Extension information <br>// The only additional clipboard format supported is to get the workstation name. <br>unsigned int CDataObject::m_cfWorkstation    = 0; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDataObject implementations <br> <br>CDataObject::CDataObject() <br>{ <br>USES_CONVERSION; <br> <br>m_cfNodeType       = RegisterClipboardFormat(W2T(CCF_NODETYPE)); <br>m_cfNodeTypeString = RegisterClipboardFormat(W2T(CCF_SZNODETYPE));   <br>m_cfDisplayName    = RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME));  <br>m_cfCoClass        = RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID));  <br>    m_cfMultiSel       = RegisterClipboardFormat(W2T(CCF_OBJECT_TYPES_IN_MULTI_SELECT)); <br> <br>#ifdef UNICODE <br>m_cfInternal       = RegisterClipboardFormat(W2T((LPTSTR)SNAPIN_INTERNAL));  <br>m_cfWorkstation    = RegisterClipboardFormat(W2T((LPTSTR)SNAPIN_WORKSTATION)); <br>#else <br>m_cfInternal       = RegisterClipboardFormat(W2T(SNAPIN_INTERNAL));  <br>m_cfWorkstation    = RegisterClipboardFormat(W2T(SNAPIN_WORKSTATION)); <br>#endif //UNICODE <br> <br> <br>    #ifdef _DEBUG <br>        m_ComponentData = NULL; <br>        dbg_refCount = 0; <br>    #endif <br> <br>    m_pbMultiSelData = 0; <br>    m_cbMultiSelData = 0; <br>    m_bMultiSelDobj = FALSE; <br>} <br> <br> <br>STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    HRESULT hr = DV_E_CLIPFORMAT; <br> <br>    if (lpFormatetc-&gt;cfFormat == m_cfMultiSel) <br>    { <br>        ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE); <br>        if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE) <br>            return E_FAIL; <br>         <br>        //return CreateMultiSelData(lpMedium); <br> <br>        ASSERT(m_pbMultiSelData != 0); <br>        ASSERT(m_cbMultiSelData != 0); <br> <br>        lpMedium-&gt;tymed = TYMED_HGLOBAL;  <br>        lpMedium-&gt;hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,  <br>                                          (m_cbMultiSelData + sizeof(DWORD))); <br>        if (lpMedium-&gt;hGlobal == NULL) <br>            return STG_E_MEDIUMFULL; <br> <br>        BYTE* pb = reinterpret_cast&lt;BYTE*&gt;(::GlobalLock(lpMedium-&gt;hGlobal)); <br>        *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID);  <br>        pb += sizeof(DWORD); <br>        CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData); <br> <br>        ::GlobalUnlock(lpMedium-&gt;hGlobal); <br> <br>        hr = S_OK; <br>    } <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium) <br>{ <br>    HRESULT hr = DV_E_CLIPFORMAT; <br> <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    // Based on the CLIPFORMAT write data to the stream <br>    const CLIPFORMAT cf = lpFormatetc-&gt;cfFormat; <br> <br>    if (cf == m_cfNodeType) <br>    { <br>        hr = CreateNodeTypeData(lpMedium); <br>    } <br>    else if (cf == m_cfCoClass) <br>    { <br>        hr = CreateCoClassID(lpMedium); <br>    } <br>    else if(cf == m_cfNodeTypeString)  <br>    { <br>        hr = CreateNodeTypeStringData(lpMedium); <br>    } <br>    else if (cf == m_cfDisplayName) <br>    { <br>        hr = CreateDisplayName(lpMedium); <br>    } <br>    else if (cf == m_cfInternal) <br>    { <br>        hr = CreateInternal(lpMedium); <br>    } <br>    else if (cf == m_cfWorkstation) <br>    { <br>        hr = CreateWorkstationName(lpMedium); <br>    } <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDataObject creation members <br> <br>HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium) <br>{ <br>    HRESULT hr = DV_E_TYMED; <br> <br>    // Do some simple validation <br>    if (pBuffer == NULL || lpMedium == NULL) <br>        return E_POINTER; <br> <br>    // Make sure the type medium is HGLOBAL <br>    if (lpMedium-&gt;tymed == TYMED_HGLOBAL) <br>    { <br>        // Create the stream on the hGlobal passed in <br>        LPSTREAM lpStream; <br>        hr = CreateStreamOnHGlobal(lpMedium-&gt;hGlobal, FALSE, &amp;lpStream); <br> <br>        if (SUCCEEDED(hr)) <br>        { <br>            // Write to the stream the number of bytes <br>            unsigned long written; <br>            hr = lpStream-&gt;Write(pBuffer, len, &amp;written); <br> <br>            // Because we told CreateStreamOnHGlobal with 'FALSE',  <br>            // only the stream is released here. <br>            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL  <br>            // at the correct time.  This is according to the IDataObject specification. <br>            lpStream-&gt;Release(); <br>        } <br>    } <br> <br>    return hr; <br>} <br> <br> <br>HRESULT CDataObject::CreateMultiSelData(LPSTGMEDIUM lpMedium) <br>{ <br>    ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE); <br>         <br>    ASSERT(m_pbMultiSelData != 0); <br>    ASSERT(m_cbMultiSelData != 0); <br> <br>    return Create(reinterpret_cast&lt;const void*&gt;(m_pbMultiSelData),  <br>                  m_cbMultiSelData, lpMedium); <br>} <br> <br>HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium) <br>{ <br>    // Create the node type object in GUID format <br>    const GUID* pcObjectType = NULL; <br> <br>    if (m_internal.m_cookie == NULL) <br>    { <br>        pcObjectType = &amp;cNodeTypeStatic; <br>    } <br>    else if (m_internal.m_type == CCT_SCOPE) <br>    { <br>        CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(m_internal.m_cookie); <br>        ASSERT(pFolder != NULL); <br>        if (pFolder == NULL) <br>            return E_UNEXPECTED; <br>         <br>        switch (pFolder-&gt;GetType()) <br>        { <br>        case COMPANY: <br>            pcObjectType = &amp;cNodeTypeCompany; <br>            break; <br>     <br>        case USER: <br>            pcObjectType = &amp;cNodeTypeUser; <br>            break; <br>     <br>        case EXT_COMPANY: <br>            pcObjectType = &amp;cNodeTypeExtCompany; <br>            break; <br>     <br>        case EXT_USER: <br>            pcObjectType = &amp;cNodeTypeExtUser; <br>            break; <br>     <br>        case VIRTUAL: <br>        case EXT_VIRTUAL: <br>            pcObjectType = &amp;cNodeTypeExtUser; <br>            break; <br>     <br>        default: <br>            pcObjectType = &amp;cNodeTypeDynamic; <br>            break; <br>        } <br>    } <br>    else if (m_internal.m_type == CCT_RESULT) <br>    { <br>        // RESULT_DATA* pData = reinterpret_cast&lt;RESULT_DATA*&gt;(m_internal.m_cookie); <br>         <br>        pcObjectType = &amp;cObjectTypeResultItem; <br>    } <br> <br>    return Create(reinterpret_cast&lt;const void*&gt;(pcObjectType), sizeof(GUID),  <br>                  lpMedium); <br>} <br> <br>HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium) <br>{ <br>    // Create the node type object in GUID string format <br>    const WCHAR* cszObjectType = NULL; <br> <br>    if (m_internal.m_cookie == NULL) <br>    { <br>        cszObjectType = cszNodeTypeStatic; <br>    } <br>    else if (m_internal.m_type == CCT_SCOPE) <br>    { <br>        CFolder* pFolder = reinterpret_cast&lt;CFolder*&gt;(m_internal.m_cookie); <br>        ASSERT(pFolder != NULL); <br>        if (pFolder == NULL) <br>            return E_UNEXPECTED; <br> <br>        switch (pFolder-&gt;GetType()) <br>        { <br>        case COMPANY: <br>            cszObjectType = cszNodeTypeCompany; <br>            break; <br>     <br>        case USER: <br>            cszObjectType = cszNodeTypeUser; <br>            break; <br>     <br>        case EXT_COMPANY: <br>            cszObjectType = cszNodeTypeExtCompany; <br>            break; <br>     <br>        case EXT_USER: <br>            cszObjectType = cszNodeTypeExtUser; <br>            break; <br>     <br>        default: <br>            cszObjectType = cszNodeTypeDynamic; <br>            break; <br>        } <br>    } <br>    else if (m_internal.m_type == CCT_RESULT) <br>    { <br>        // RESULT_DATA* pData = reinterpret_cast&lt;RESULT_DATA*&gt;(m_internal.m_cookie); <br>         <br>        cszObjectType = cszObjectTypeResultItem; <br>    } <br>    return Create(cszObjectType, ((wcslen(cszObjectType)+1) * sizeof(WCHAR)), lpMedium); <br>} <br> <br>HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium) <br>{ <br>    // This is the display named used in the scope pane and snap-in manager <br> <br>    // Load the name from resource <br>    // Note - if this is not provided, the console will used the snap-in name <br> <br>    CString szDispName; <br>    szDispName.LoadString(IDS_NODENAME); <br> <br>USES_CONVERSION; <br> <br>#ifdef UNICODE <br>return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium); <br>#else <br>return Create(T2W(szDispName), ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium); <br>#endif <br>} <br> <br>HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium) <br>{ <br>    return Create(&amp;m_internal, sizeof(INTERNAL), lpMedium); <br>} <br> <br>HRESULT CDataObject::CreateWorkstationName(LPSTGMEDIUM lpMedium) <br>{ <br>    TCHAR pzName[MAX_COMPUTERNAME_LENGTH+1] = {0}; <br>    DWORD len = MAX_COMPUTERNAME_LENGTH+1; <br> <br>    if (GetComputerName(pzName, &amp;len) == FALSE) <br>        return E_FAIL; <br> <br>    // Add 1 for the NULL and calculate the bytes for the stream <br>//#ifdef UNICODE <br>USES_CONVERSION; <br>    return Create(T2W(pzName), ((len+1)* sizeof(WCHAR)), lpMedium); <br>//#else <br>//    return Create(pzName, ((len+1)* sizeof(WCHAR)), lpMedium); <br>//#endif <br> <br>} <br> <br>HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium) <br>{ <br>    // Create the CoClass information <br>    return Create(reinterpret_cast&lt;const void*&gt;(&amp;m_internal.m_clsid), sizeof(CLSID), lpMedium); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
