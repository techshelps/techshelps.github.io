<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STDAFX.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5801"></a>STDAFX.H</h2>
<pre><code>// This is a part of the Microsoft Management Console. <br>// Copyright 1995 - 1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Microsoft Management Console and related <br>// electronic documentation provided with the interfaces. <br> <br>// stdafx.h : include file for standard system include files, <br>//      or project specific include files that are used frequently, <br>//      but are changed infrequently <br> <br>#undef _MSC_EXTENSIONS <br> <br> <br>#include &lt;afxwin.h&gt; <br>#include &lt;afxext.h&gt;         // MFC extensions <br>#include &lt;afxdisp.h&gt; <br>#include "afxtempl.h" <br> <br>//#include &lt;shellapi.h&gt; <br> <br>#include &lt;atlbase.h&gt; <br>using namespace ATL; <br> <br>//You may derive a class from CComModule and use it if you want to override <br>//something, but do not change the name of _Module <br>extern CComModule _Module; <br>#include &lt;atlcom.h&gt; <br> <br> <br>//#include "afxtempl.h"    <br> <br> <br>#pragma comment(lib, "mmc") <br>#include &lt;mmc.h&gt; <br> <br> <br> <br> <br>const long UNINITIALIZED = -1; <br> <br>// Constants used in samples <br>const int NUM_FOLDERS = 4; <br>const int NUM_NAMES = 4; <br>const int NUM_COMPANY = 6; <br>const int NUM_VIRTUAL_ITEMS = 100000; <br>const int MAX_ITEM_NAME = 64; <br> <br>// Sample folder types <br>enum FOLDER_TYPES <br>{ <br>    STATIC = 0x8000, <br>    COMPANY = 0x8001, <br>    USER = 0x8002, <br>    VIRTUAL = 0x8003, <br>    EXT_COMPANY = 0x8004, <br>    EXT_USER = 0x8005, <br>    EXT_VIRTUAL = 0x8006, <br>    NONE = 0xFFFF <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Helper functions <br> <br>template&lt;class TYPE&gt; <br>inline void SAFE_RELEASE(TYPE*&amp; pObj) <br>{ <br>    if (pObj != NULL)  <br>    {  <br>        pObj-&gt;Release();  <br>        pObj = NULL;  <br>    }  <br>    else  <br>    {  <br>        TRACE(_T("Release called on NULL interface ptr\n"));  <br>    } <br>} <br> <br>extern const CLSID CLSID_Snapin;    // In-Proc server GUID <br>extern const CLSID CLSID_Extension; // In-Proc server GUID <br>extern const CLSID CLSID_About;  <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//                  OBJECT TYPES <br>// <br> <br>// <br>// OBJECT TYPE for Scope Nodes. <br>// <br> <br>// Static NodeType GUID in numeric &amp; string formats. <br>extern const GUID cNodeTypeStatic; <br>extern const wchar_t*  cszNodeTypeStatic; <br> <br>// Company Data NodeType GUID in numeric &amp; string formats. <br>extern const GUID cNodeTypeCompany; <br>extern const wchar_t*  cszNodeTypeCompany; <br> <br>// User Data NodeType GUID in numeric &amp; string formats. <br>extern const GUID cNodeTypeUser; <br>extern const wchar_t*  cszNodeTypeUser; <br> <br>// Extension Company Data NodeType GUID in numeric &amp; string formats. <br>extern const GUID cNodeTypeExtCompany; <br>extern const wchar_t*  cszNodeTypeExtCompany; <br> <br>// Extension User Data NodeType GUID in numeric &amp; string formats. <br>extern const GUID cNodeTypeExtUser; <br>extern const wchar_t*  cszNodeTypeExtUser; <br> <br>// Extension Virtual NodeType GUID in numeric &amp; string formats. <br>extern const GUID cNodeTypeVirtual; <br>extern const wchar_t*  cszNodeTypeVirtual; <br> <br>// Dynamicaly created objects. <br>extern const GUID cNodeTypeDynamic; <br>extern const wchar_t*  cszNodeTypeDynamic; <br> <br> <br>// <br>// OBJECT TYPE for result items. <br>// <br> <br>// Result items object type GUID in numeric &amp; string formats. <br>extern const GUID cObjectTypeResultItem; <br>extern const wchar_t*  cszObjectTypeResultItem; <br> <br>// <br>// <br>////////////////////////////////////////////////////////////////////////////// <br> <br> <br> <br>// New Clipboard format that has the Type and Cookie <br>extern const wchar_t* SNAPIN_INTERNAL; <br> <br>// Published context information for extensions to extend <br>extern const wchar_t* SNAPIN_WORKSTATION; <br> <br>struct INTERNAL  <br>{ <br>    INTERNAL()  <br>    { <br>        m_type = CCT_UNINITIALIZED;  <br>        m_cookie = -1; <br>        ZeroMemory(&amp;m_clsid, sizeof(CLSID)); <br>    }; <br> <br>    ~INTERNAL() {} <br> <br>    DATA_OBJECT_TYPES   m_type;         // What context is the data object. <br>    long                m_cookie;       // What object the cookie represents <br>    CString             m_string;       //  <br>    CLSID               m_clsid;       // Class ID of who created this data object <br> <br>    INTERNAL &amp; operator=(const INTERNAL&amp; rhs)  <br>    {  <br>        if (&amp;rhs == this) <br>            return *this; <br> <br>        // Deep copy the information <br>        m_type = rhs.m_type;  <br>        m_cookie = rhs.m_cookie;  <br>        m_string = rhs.m_string; <br>        memcpy(&amp;m_clsid, &amp;rhs.m_clsid, sizeof(CLSID)); <br> <br>        return *this; <br>    }  <br> <br>    BOOL operator==(const INTERNAL&amp; rhs)  <br>    { <br>        return rhs.m_string == m_string; <br>    } <br>}; <br> <br>// Debug instance counter <br>#ifdef _DEBUG <br>inline void DbgInstanceRemaining(char * pszClassName, int cInstRem) <br>{ <br>    char buf[100]; <br>    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem); <br>    ::MessageBoxA(NULL, buf, "SAMPLE: Memory Leak!!!", MB_OK); <br>} <br>    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0; <br>    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls); <br>    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls); <br>    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \ <br>        extern int s_cInst_##cls; \ <br>        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls); <br>#else <br>    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)    <br>    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)     <br>    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)     <br>    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)     <br>#endif  <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
