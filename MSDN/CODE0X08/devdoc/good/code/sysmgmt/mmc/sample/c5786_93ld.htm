<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EVENTS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5791"></a>EVENTS.CPP</h2>
<pre><code>// This is a part of the Microsoft Management Console. <br>// Copyright 1995 - 1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// Microsoft Management Console and related <br>// electronic documentation provided with the interfaces. <br> <br>#include "stdafx.h" <br>#include "Service.h"  <br>#include "CSnapin.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>// Primary Data <br>RESULT_DATA StaticRootData[NUM_NAMES] = <br>{ <br>    {RESULT_ITEM, USER, L"Bill", L"990", L"CEO"}, <br>    {RESULT_ITEM, USER, L"Jill", L"991", L"Director"}, <br>    {RESULT_ITEM, USER, L"Hill", L"992", L"President"}, <br>    {RESULT_ITEM, USER, L"Will", L"993", L"Chairman"}, <br>}; <br> <br>RESULT_DATA UserData[NUM_NAMES] = <br>{ <br>    {RESULT_ITEM, USER, L"Joe", L"100", L"Employee"}, <br>    {RESULT_ITEM, USER, L"Harry", L"101", L"Manager"}, <br>    {RESULT_ITEM, USER, L"Jane", L"102", L"Vice President"}, <br>    {RESULT_ITEM, USER, L"Sue", L"103", L"Developer"}, <br>}; <br> <br>RESULT_DATA CompanyData[NUM_COMPANY] =  <br>{ <br>    {RESULT_ITEM, COMPANY, L"Taxes", L"43", L"IRS Documents"}, <br>    {RESULT_ITEM, COMPANY, L"Medical", L"345", L"HMO"}, <br>    {RESULT_ITEM, COMPANY, L"Dental", L"121", L"Plus Plan"}, <br>    {RESULT_ITEM, COMPANY, L"Insurance", L"2332", L"Dollars are Us"}, <br>    {RESULT_ITEM, COMPANY, L"401K", L"1000", L"Up to you"}, <br>    {RESULT_ITEM, COMPANY, L"Legal", L"78", L"Yes"} <br>}; <br> <br>// Extension data <br>RESULT_DATA UserDataExt[NUM_NAMES] = <br>{ <br>    {RESULT_ITEM, EXT_USER, L"Charles", L"200", L"Employee"}, <br>    {RESULT_ITEM, EXT_USER, L"Jill", L"201", L"Manager"}, <br>    {RESULT_ITEM, EXT_USER, L"John", L"202", L"Vice President"}, <br>    {RESULT_ITEM, EXT_USER, L"Tami", L"203", L"Developer"}, <br>}; <br> <br>RESULT_DATA CompanyDataExt[NUM_COMPANY] =  <br>{ <br>    {RESULT_ITEM, EXT_COMPANY, L"Payroll", L"99", L"Corporate Payroll"}, <br>    {RESULT_ITEM, EXT_COMPANY, L"Health", L"568", L"HMO"}, <br>    {RESULT_ITEM, EXT_COMPANY, L"Health Club", L"834", L"Plus Plan"}, <br>    {RESULT_ITEM, EXT_COMPANY, L"Insurance", L"1101", L"Dollars are Us"}, <br>    {RESULT_ITEM, EXT_COMPANY, L"401K", L"1543", L"Up to you"}, <br>    {RESULT_ITEM, EXT_COMPANY, L"Legal", L"27", L"Yes"} <br>}; <br> <br>// We use a single structure for all virtual items, so  <br>// the name field points to this buffer that is changed  <br>// on the fly. <br>WCHAR VirtualItemName[MAX_ITEM_NAME]; <br> <br>RESULT_DATA VirtualData[1] = <br>{  <br>    {RESULT_ITEM, VIRTUAL, VirtualItemName, L"100", L"Virtual"} <br>}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Event handlers for IFrame::Notify <br> <br>HRESULT CSnapin::OnFolder(long cookie, long arg, long param) <br>{ <br>    ASSERT(FALSE); <br> <br>    return S_OK; <br>} <br> <br>HRESULT CSnapin::OnAddImages(long cookie, long arg, long param) <br>{ <br>    if (arg == 0) <br>        return E_INVALIDARG; <br>     <br>    // if cookie is from a different snapin <br>    // if (IsMyCookie(cookie) == FALSE) <br>    if (0) <br>    { <br>        // add the images for the scope tree only <br>        ::CBitmap bmp16x16; <br>        ::CBitmap bmp32x32; <br>        LPIMAGELIST lpImageList = reinterpret_cast&lt;LPIMAGELIST&gt;(arg); <br>     <br>        // Load the bitmaps from the dll <br>        bmp16x16.LoadBitmap(IDB_16x16); <br>        bmp32x32.LoadBitmap(IDB_32x32); <br>     <br>        // Set the images <br>        lpImageList-&gt;ImageListSetStrip( <br>                        reinterpret_cast&lt;long*&gt;(static_cast&lt;HBITMAP&gt;(bmp16x16)), <br>                        reinterpret_cast&lt;long*&gt;(static_cast&lt;HBITMAP&gt;(bmp32x32)), <br>                        0, RGB(255, 0, 255)); <br>     <br>        lpImageList-&gt;Release(); <br>    } <br>    else  <br>    { <br>        InitializeBitmaps(cookie); <br>    } <br>    return S_OK; <br>} <br> <br>HRESULT CSnapin::OnShow(long cookie, long arg, long param) <br>{ <br>    // Note - arg is TRUE when it is time to enumerate <br>    if (arg == TRUE) <br>    { <br>        // if list view on display <br>        if (m_CustomViewID == VIEW_DEFAULT_LV) <br>        { <br>            // Show the headers for this nodetype <br>            InitializeHeaders(cookie); <br>            Enumerate(cookie, param); <br>        } <br>        // BUBBUG - Demonstration to should how you can attach <br>        // and a toolbar when a particular nodes gets focus. <br>        // warning this needs to be here as the toolbars are <br>        // currently hidden when the previous node looses focus. <br>        // This should be update to show the user how to hide <br>        // and show toolbars. (Detach and Attach). <br> <br>        //m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1); <br>        //m_pControlbar-&gt;Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2); <br>    } <br>    else <br>    { <br> <br>        // BUGBUG - Demonstration this to show how to hide toolbars that <br>        // could be particular to a single node. <br>        // currently this is used to hide the toolbars the console  <br>        // does not do any toolbar clean up. <br> <br>        //m_pControlbar-&gt;Detach(m_pToolbar1); <br>        //m_pControlbar-&gt;Detach(m_pToolbar2); <br>        // Free data associated with the result pane items, because <br>        // your node is no longer being displayed. <br>        // Note: The console will remove the items from the result pane <br>    } <br> <br>    return S_OK; <br>} <br> <br>HRESULT CSnapin::OnActivate(long cookie, long arg, long param) <br>{ <br>    return S_OK; <br>} <br> <br>HRESULT CSnapin::OnResultItemClk(DATA_OBJECT_TYPES type, long cookie) <br>{ <br>    RESULT_DATA* pResult; <br> <br>    if (m_bVirtualView == TRUE) <br>    { <br>        pResult = GetVirtualResultItem(cookie); <br>    } <br>    else if (cookie != 0) <br>    { <br>        DWORD* pdw = reinterpret_cast&lt;DWORD*&gt;(cookie); <br>        if (*pdw == RESULT_ITEM) <br>        { <br>            pResult = reinterpret_cast&lt;RESULT_DATA*&gt;(cookie); <br>        } <br>    } <br> <br>    return S_OK; <br>} <br> <br>HRESULT CSnapin::OnMinimize(long cookie, long arg, long param) <br>{ <br>    return S_OK; <br>} <br> <br>HRESULT CSnapin::OnPropertyChange(LPDATAOBJECT lpDataObject) <br>{ <br> <br>    return S_OK; <br>} <br> <br>HRESULT CSnapin::OnUpdateView(LPDATAOBJECT lpDataObject) <br>{ <br>    return S_OK; <br>} <br> <br>void CSnapin::Enumerate(long cookie, HSCOPEITEM pParent) <br>{ <br>    EnumerateResultPane(cookie); <br>} <br> <br>void CSnapin::EnumerateResultPane(long cookie) <br>{ <br>    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface <br>    ASSERT(m_pComponentData != NULL); <br> <br>    // Our static folders must be displayed in the result pane <br>    // by use because the console doesn't do it. <br>    CFolder* pFolder = dynamic_cast&lt;CComponentDataImpl*&gt;(m_pComponentData)-&gt;FindObject(cookie); <br> <br>    // The dynamic folder must be in our list <br>    ASSERT(pFolder != NULL); <br> <br>    FOLDER_TYPES type = pFolder-&gt;GetType(); <br> <br>    switch(type) <br>    { <br>    case STATIC: <br>        AddResultItems(&amp;StaticRootData[0], NUM_NAMES, 4); <br>        break; <br> <br>    case COMPANY: <br>        AddCompany(); <br>        break; <br> <br>    case USER: <br>        AddUser(); <br>        break; <br> <br>    case EXT_USER: <br>        AddExtUser(); <br>        break; <br> <br>    case EXT_COMPANY: <br>        AddExtCompany(); <br>        break; <br> <br>    case VIRTUAL: <br>    case EXT_VIRTUAL: <br>        AddVirtual(); <br>        break; <br> <br>    default: <br>        break; <br>    } <br>} <br> <br>void CSnapin::AddResultItems(RESULT_DATA* pData, int nCount, int imageIndex) <br>{ <br>    ASSERT(m_pResult); <br> <br>    RESULTDATAITEM resultItem; <br>    memset(&amp;resultItem, 0, sizeof(RESULTDATAITEM)); <br> <br>    for (int i=0; i &lt; nCount; i++) <br>    { <br>        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM; <br>        resultItem.str = MMC_CALLBACK; <br>        resultItem.nImage = imageIndex; <br>        resultItem.lParam = reinterpret_cast&lt;LPARAM&gt;(pData + i); <br>        m_pResult-&gt;InsertItem(&amp;resultItem); <br>    } <br> <br>    m_pResult-&gt;Sort(0,0,-1); <br> <br>} <br> <br>void CSnapin::AddUser() <br>{ <br>    AddResultItems(&amp;UserData[0], NUM_NAMES, 4); <br>} <br> <br>void CSnapin::AddCompany() <br>{ <br>    AddResultItems(&amp;CompanyData[0], NUM_COMPANY, 3); <br>} <br> <br>void CSnapin::AddExtUser() <br>{ <br>    AddResultItems(&amp;UserDataExt[0], NUM_NAMES, 4); <br>} <br> <br>void CSnapin::AddExtCompany() <br>{ <br>    AddResultItems(&amp;CompanyDataExt[0], NUM_COMPANY, 3); <br>} <br> <br>void CSnapin::AddVirtual() <br>{ <br>    // for virtual data, just set the item count <br>    m_pResult-&gt;SetItemCount(NUM_VIRTUAL_ITEMS, MMCLV_UPDATE_NOINVALIDATEALL); <br>} <br> <br> <br>RESULT_DATA* CSnapin::GetVirtualResultItem(int iIndex) <br>{ <br>    // reverse order for descending sort <br>    if (m_dwVirtualSortOptions &amp; RSI_DESCENDING) <br>        iIndex = (NUM_VIRTUAL_ITEMS - 1) - iIndex; <br> <br>    // Create a name from the index <br>    swprintf(VirtualItemName, L"%d", iIndex); <br> <br>    // return pointer to the virtual result item <br>    return &amp;VirtualData[0]; <br>     <br>} <br> <br>         </code></pre>
<p>&nbsp;</p></body>
</HTML>
