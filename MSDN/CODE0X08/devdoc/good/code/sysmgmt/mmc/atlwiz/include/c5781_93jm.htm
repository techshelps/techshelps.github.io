<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATLSNAP.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5782"></a>ATLSNAP.H</h2>
<pre><code>#ifndef __ATL_SNAPIN_H__ <br>#define __ATL_SNAPIN_H__ <br> <br>#include &lt;mmc.h&gt; <br>#include &lt;commctrl.h&gt; <br> <br>#ifdef _DEBUG <br>void __cdecl operator delete(void* p); <br>void* __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine); <br>#undef new <br>#define new new(__FILE__, __LINE__) <br> <br>#endif <br> <br>#ifdef __cplusplus <br>extern "C"{ <br>#endif  <br> <br>void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t); <br>void __RPC_USER MIDL_user_free( void __RPC_FAR * );  <br> <br>#ifndef __ISnapInDataInterface_INTERFACE_DEFINED__ <br>#define __ISnapInDataInterface_INTERFACE_DEFINED__ <br> <br>EXTERN_C const IID IID_ISnapInDataInterface; <br> <br>#if defined(__cplusplus) &amp;&amp; !defined(CINTERFACE) <br>     <br>    interface DECLSPEC_UUID("1FABD781-ECDA-11D0-AACE-00AA00C00189") <br>    ISnapInDataInterface : public IUnknown <br>    { <br>    public: <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(  <br>            MMC_NOTIFY_TYPE event, <br>            long arg, <br>            long param, <br>            BOOL bComponentData, <br>            IConsole __RPC_FAR *pConsole, <br>            IHeaderCtrl __RPC_FAR *pHeader, <br>            IToolbar __RPC_FAR *pToolbar) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDispInfo(  <br>            SCOPEDATAITEM __RPC_FAR *pScopeDataItem) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType(  <br>            LPOLESTR __RPC_FAR *ppVIewType, <br>            long __RPC_FAR *pViewOptions) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(  <br>            RESULTDATAITEM __RPC_FAR *pResultDataItem) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems(  <br>            LPCONTEXTMENUCALLBACK piCallback, <br>            long __RPC_FAR *pInsertionAllowed) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command(  <br>            long lCommandID) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages(  <br>            LPPROPERTYSHEETCALLBACK lpProvider, <br>            long handle, <br>IUnknown* pUnk) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( void) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar(  <br>            IControlbar __RPC_FAR *pControlbar, <br>            IExtendControlbar __RPC_FAR *pExtendControlbar) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify(  <br>            IControlbar __RPC_FAR *pControlbar, <br>            IExtendControlbar __RPC_FAR *pExtendControlbar, <br>            MMC_NOTIFY_TYPE event, <br>            long arg, <br>            long param) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetScopeData(  <br>            SCOPEDATAITEM __RPC_FAR *__RPC_FAR *pScopeDataItem) = 0; <br>         <br>        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultData(  <br>            RESULTDATAITEM __RPC_FAR *__RPC_FAR *pResultDataItem) = 0; <br>         <br>    }; <br>     <br>#else /* C style interface */ <br> <br>    typedef struct ISnapInDataInterfaceVtbl <br>    { <br>        BEGIN_INTERFACE <br>         <br>        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            /* [in] */ REFIID riid, <br>            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject); <br>         <br>        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(  <br>            ISnapInDataInterface __RPC_FAR * This); <br>         <br>        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(  <br>            ISnapInDataInterface __RPC_FAR * This); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            MMC_NOTIFY_TYPE event, <br>            long arg, <br>            long param, <br>            BOOL bComponentData, <br>            IConsole __RPC_FAR *pConsole, <br>            IHeaderCtrl __RPC_FAR *pHeader, <br>            IToolbar __RPC_FAR *pToolbar); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDispInfo )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            SCOPEDATAITEM __RPC_FAR *pScopeDataItem); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultViewType )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            LPOLESTR __RPC_FAR *ppVIewType, <br>            long __RPC_FAR *pViewOptions); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            RESULTDATAITEM __RPC_FAR *pResultDataItem); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMenuItems )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            LPCONTEXTMENUCALLBACK piCallback, <br>            long __RPC_FAR *pInsertionAllowed); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Command )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            long lCommandID); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyPages )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            LPPROPERTYSHEETCALLBACK lpProvider, <br>            long handle, <br>IUnknown* pUnk); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPagesFor )(  <br>            ISnapInDataInterface __RPC_FAR * This); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControlbar )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            IControlbar __RPC_FAR *pControlbar, <br>            IExtendControlbar __RPC_FAR *pExtendControlbar); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlbarNotify )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            IControlbar __RPC_FAR *pControlbar, <br>            IExtendControlbar __RPC_FAR *pExtendControlbar, <br>            MMC_NOTIFY_TYPE event, <br>            long arg, <br>            long param); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScopeData )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            SCOPEDATAITEM __RPC_FAR *__RPC_FAR *pScopeDataItem); <br>         <br>        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultData )(  <br>            ISnapInDataInterface __RPC_FAR * This, <br>            RESULTDATAITEM __RPC_FAR *__RPC_FAR *pResultDataItem); <br>         <br>        END_INTERFACE <br>    } ISnapInDataInterfaceVtbl; <br> <br>    interface ISnapInDataInterface <br>    { <br>        CONST_VTBL struct ISnapInDataInterfaceVtbl __RPC_FAR *lpVtbl; <br>    }; <br> <br>     <br> <br>#ifdef COBJMACROS <br> <br> <br>#define ISnapInDataInterface_QueryInterface(This,riid,ppvObject)\ <br>    (This)-&gt;lpVtbl -&gt; QueryInterface(This,riid,ppvObject) <br> <br>#define ISnapInDataInterface_AddRef(This)\ <br>    (This)-&gt;lpVtbl -&gt; AddRef(This) <br> <br>#define ISnapInDataInterface_Release(This)\ <br>    (This)-&gt;lpVtbl -&gt; Release(This) <br> <br> <br>#define ISnapInDataInterface_Notify(This,event,arg,param,bComponentData,pConsole,pHeader,pToolbar)\ <br>    (This)-&gt;lpVtbl -&gt; Notify(This,event,arg,param,bComponentData,pConsole,pHeader,pToolbar) <br> <br>#define ISnapInDataInterface_GetDispInfo(This,pScopeDataItem)\ <br>    (This)-&gt;lpVtbl -&gt; GetDispInfo(This,pScopeDataItem) <br> <br>#define ISnapInDataInterface_GetResultViewType(This,ppVIewType,pViewOptions)\ <br>    (This)-&gt;lpVtbl -&gt; GetResultViewType(This,ppVIewType,pViewOptions) <br> <br>#define ISnapInDataInterface_GetDisplayInfo(This,pResultDataItem)\ <br>    (This)-&gt;lpVtbl -&gt; GetDisplayInfo(This,pResultDataItem) <br> <br>#define ISnapInDataInterface_AddMenuItems(This,piCallback,pInsertionAllowed)\ <br>    (This)-&gt;lpVtbl -&gt; AddMenuItems(This,piCallback,pInsertionAllowed) <br> <br>#define ISnapInDataInterface_Command(This,lCommandID)\ <br>    (This)-&gt;lpVtbl -&gt; Command(This,lCommandID) <br> <br>#define ISnapInDataInterface_CreatePropertyPages(This,lpProvider,handle, pUnk)\ <br>    (This)-&gt;lpVtbl -&gt; CreatePropertyPages(This,lpProvider,handle, pUnk) <br> <br>#define ISnapInDataInterface_QueryPagesFor(This)\ <br>    (This)-&gt;lpVtbl -&gt; QueryPagesFor(This) <br> <br>#define ISnapInDataInterface_SetControlbar(This,pControlbar,pExtendControlbar)\ <br>    (This)-&gt;lpVtbl -&gt; SetControlbar(This,pControlbar,pExtendControlbar) <br> <br>#define ISnapInDataInterface_ControlbarNotify(This,pControlbar,pExtendControlbar,event,arg,param)\ <br>    (This)-&gt;lpVtbl -&gt; ControlbarNotify(This,pControlbar,pExtendControlbar,event,arg,param) <br> <br>#define ISnapInDataInterface_GetScopeData(This,pScopeDataItem)\ <br>    (This)-&gt;lpVtbl -&gt; GetScopeData(This,pScopeDataItem) <br> <br>#define ISnapInDataInterface_GetResultData(This,pResultDataItem)\ <br>    (This)-&gt;lpVtbl -&gt; GetResultData(This,pResultDataItem) <br> <br>#endif /* COBJMACROS */ <br> <br> <br>#endif /* C style interface */ <br> <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_Notify_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    MMC_NOTIFY_TYPE event, <br>    long arg, <br>    long param, <br>    BOOL bComponentData, <br>    IConsole __RPC_FAR *pConsole, <br>    IHeaderCtrl __RPC_FAR *pHeader, <br>    IToolbar __RPC_FAR *pToolbar); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_Notify_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_GetDispInfo_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    SCOPEDATAITEM __RPC_FAR *pScopeDataItem); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_GetDispInfo_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_GetResultViewType_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    LPOLESTR __RPC_FAR *ppVIewType, <br>    long __RPC_FAR *pViewOptions); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_GetResultViewType_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_GetDisplayInfo_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    RESULTDATAITEM __RPC_FAR *pResultDataItem); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_GetDisplayInfo_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_AddMenuItems_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    LPCONTEXTMENUCALLBACK piCallback, <br>    long __RPC_FAR *pInsertionAllowed); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_AddMenuItems_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_Command_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    long lCommandID); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_Command_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_CreatePropertyPages_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    LPPROPERTYSHEETCALLBACK lpProvider, <br>    long handle, <br>IUnknown* pUnk); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_CreatePropertyPages_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_QueryPagesFor_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_QueryPagesFor_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_SetControlbar_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    IControlbar __RPC_FAR *pControlbar, <br>    IExtendControlbar __RPC_FAR *pExtendControlbar); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_SetControlbar_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_ControlbarNotify_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    IControlbar __RPC_FAR *pControlbar, <br>    IExtendControlbar __RPC_FAR *pExtendControlbar, <br>    MMC_NOTIFY_TYPE event, <br>    long arg, <br>    long param); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_ControlbarNotify_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_GetScopeData_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    SCOPEDATAITEM __RPC_FAR *__RPC_FAR *pScopeDataItem); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_GetScopeData_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br>/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapInDataInterface_GetResultData_Proxy(  <br>    ISnapInDataInterface __RPC_FAR * This, <br>    RESULTDATAITEM __RPC_FAR *__RPC_FAR *pResultDataItem); <br> <br> <br>void __RPC_STUB ISnapInDataInterface_GetResultData_Stub( <br>    IRpcStubBuffer *This, <br>    IRpcChannelBuffer *_pRpcChannelBuffer, <br>    PRPC_MESSAGE _pRpcMessage, <br>    DWORD *_pdwStubPhase); <br> <br> <br> <br>#endif /* __ISnapInDataInterface_INTERFACE_DEFINED__ */ <br> <br>#ifdef __cplusplus <br>} <br>#endif <br> <br>#pragma comment(lib, "mmc.lib") <br> <br>#ifndef CPropertyPageImpl <br>#pragma comment(lib, "comctl32.lib") <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBase <br>{ <br>public: <br>PROPSHEETPAGE m_psp; <br> <br>operator PROPSHEETPAGE*() { return &amp;m_psp; } <br> <br>// Construction <br>CPropertyPageImpl(LPCTSTR lpszTitle = NULL) <br>{ <br>// initialize PROPSHEETPAGE struct <br>memset(&amp;m_psp, 0, sizeof(PROPSHEETPAGE)); <br>m_psp.dwSize = sizeof(PROPSHEETPAGE); <br>m_psp.dwFlags = PSP_USECALLBACK; <br>m_psp.hInstance = _Module.GetResourceInstance(); <br>m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD); <br>m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc; <br>m_psp.pfnCallback = T::PropPageCallback; <br>m_psp.lParam = (LPARAM)this; <br> <br>if(lpszTitle != NULL) <br>{ <br>m_psp.pszTitle = lpszTitle; <br>m_psp.dwFlags |= PSP_USETITLE; <br>} <br>} <br> <br>static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp) <br>{ <br>if(uMsg == PSPCB_CREATE) <br>{ <br>_ASSERTE(hWnd == NULL); <br>CDialogImplBase* pPage = (CDialogImplBase*)ppsp-&gt;lParam; <br>_Module.AddCreateWndData(&amp;pPage-&gt;m_thunk.cd, pPage); <br>} <br> <br>return 1; <br>} <br> <br>HPROPSHEETPAGE Create() <br>{ <br>return ::CreatePropertySheetPage(&amp;m_psp); <br>} <br> <br>BOOL EndDialog(int) <br>{ <br>// do nothing here, calling ::EndDialog will close the whole sheet <br>_ASSERTE(FALSE); <br>return FALSE; <br>} <br> <br>// Operations <br>void CancelToClose() <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>_ASSERTE(GetParent() != NULL); <br> <br>::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L); <br>} <br>void SetModified(BOOL bChanged = TRUE) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>_ASSERTE(GetParent() != NULL); <br> <br>if(bChanged) <br>::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L); <br>else <br>::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L); <br>} <br>LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>_ASSERTE(GetParent() != NULL); <br> <br>return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam); <br>} <br> <br>BEGIN_MSG_MAP(CPropertyPageImpl&lt; T &gt;) <br>MESSAGE_HANDLER(WM_NOTIFY, OnNotify) <br>END_MSG_MAP() <br> <br>// Message handler <br>LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br>_ASSERTE(::IsWindow(m_hWnd)); <br>NMHDR* pNMHDR = (NMHDR*)lParam; <br> <br>// don't handle messages not from the page/sheet itself <br>if(pNMHDR-&gt;hwndFrom != m_hWnd &amp;&amp; pNMHDR-&gt;hwndFrom != ::GetParent(m_hWnd)) <br>{ <br>bHandled = FALSE; <br>return 1; <br>} <br> <br>T* pT = (T*)this; <br>LRESULT lResult = 0; <br>// handle default <br>switch(pNMHDR-&gt;code) <br>{ <br>case PSN_SETACTIVE: <br>//? other values <br>lResult = pT-&gt;OnSetActive() ? 0 : -1; <br>break; <br>case PSN_KILLACTIVE: <br>lResult = !pT-&gt;OnKillActive(); <br>break; <br>case PSN_APPLY: <br>lResult = pT-&gt;OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE; <br>break; <br>case PSN_RESET: <br>pT-&gt;OnReset(); <br>break; <br>case PSN_QUERYCANCEL: <br>lResult = !pT-&gt;OnQueryCancel(); <br>break; <br>case PSN_WIZNEXT: <br>//? other values <br>lResult = !pT-&gt;OnWizardNext(); <br>break; <br>case PSN_WIZBACK: <br>lResult = !pT-&gt;OnWizardBack(); <br>break; <br>case PSN_WIZFINISH: <br>lResult = !pT-&gt;OnWizardFinish(); <br>break; <br>case PSN_HELP: <br>/**/lResult = pT-&gt;OnHelp(); <br>break; <br>default: <br>bHandled = FALSE;// not handled <br>} <br> <br>return lResult; <br>} <br> <br>// Overridables <br>BOOL OnSetActive() <br>{ <br>return TRUE; <br>} <br>BOOL OnKillActive() <br>{ <br>return TRUE; <br>} <br>BOOL OnApply() <br>{ <br>return TRUE; <br>} <br>void OnReset() <br>{ <br>} <br>BOOL OnQueryCancel() <br>{ <br>return TRUE;    // ok to cancel <br>} <br>BOOL OnWizardBack() <br>{ <br>return TRUE; <br>} <br>BOOL OnWizardNext() <br>{ <br>return TRUE; <br>} <br>BOOL OnWizardFinish() <br>{ <br>return TRUE; <br>} <br>BOOL OnHelp() <br>{ <br>return TRUE; <br>} <br>}; <br>#endif <br> <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject <br>{ <br>public: <br>STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n")); <br>} <br> <br>STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium) <br>{ <br>ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n")); <br>if (pmedium == NULL) <br>return E_POINTER; <br> <br>HRESULT hr = DV_E_TYMED; <br>// Make sure the type medium is HGLOBAL <br>if (pmedium-&gt;tymed == TYMED_HGLOBAL) <br>{ <br>// Create the stream on the hGlobal passed in <br>LPSTREAM pStream; <br>hr = CreateStreamOnHGlobal(pmedium-&gt;hGlobal, FALSE, &amp;pStream); <br>if (SUCCEEDED(hr)) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>hr = pT-&gt;FillData(pformatetc-&gt;cfFormat, pStream); <br>pStream-&gt;Release(); <br>} <br>} <br> <br>return hr; <br>} <br> <br>STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n")); <br>} <br>STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n")); <br>} <br>STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n")); <br>} <br>STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n")); <br>} <br>STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, <br>DWORD *pdwConnection) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n")); <br>} <br>STDMETHOD(DUnadvise)(DWORD dwConnection) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n")); <br>} <br>STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise) <br>{ <br>ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n")); <br>} <br>}; <br> <br> <br>template &lt;class T, class C&gt; <br>class ATL_NO_VTABLE IComponentDataImpl : public IComponentData  <br>{ <br>public : <br>CComQIPtr&lt;IConsoleNameSpace, &amp;IID_IConsoleNameSpace&gt; m_spConsoleNameSpace; <br>CComQIPtr&lt;IConsole, &amp;IID_IConsole&gt; m_spConsole; <br> <br>    STDMETHOD(Initialize)(LPUNKNOWN pUnknown) <br>{ <br>ATLTRACE(_T("IComponentDataImpl::Initialize\n")); <br> <br>if (pUnknown == NULL) <br>{ <br>ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n")); <br>return E_UNEXPECTED; <br>} <br> <br>m_spConsoleNameSpace = pUnknown; <br>if (m_spConsoleNameSpace == NULL) <br>{ <br>ATLTRACE(_T("QI for IConsoleNameSpace failed\n")); <br>return E_UNEXPECTED; <br>} <br> <br>m_spConsole = pUnknown; <br>if (m_spConsole == NULL) <br>{ <br>ATLTRACE(_T("QI for IConsole failed\n")); <br>return E_UNEXPECTED; <br>} <br> <br>return S_OK; <br>} <br> <br>STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent) <br>{ <br>ATLTRACE(_T("IComponentDataImpl::CreateComponent\n")); <br>if (ppComponent == NULL) <br>{ <br>ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n")); <br>return E_UNEXPECTED; <br>} <br> <br>*ppComponent = NULL; <br> <br>CComObject&lt; C &gt;* pComponent; <br>HRESULT hr = CComObject&lt; C &gt;::CreateInstance(&amp;pComponent); <br>if (FAILED(hr)) <br>{ <br>ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n")); <br>return hr; <br>} <br> <br>return pComponent-&gt;QueryInterface(IID_IComponent, (void**)ppComponent); <br>} <br> <br>     <br>    STDMETHOD(Notify)(  <br>        LPDATAOBJECT lpDataObject, <br>        MMC_NOTIFY_TYPE event, <br>        long arg, <br>        long param) <br>{ <br>ATLTRACE(_T("IComponentDataImpl::Notify\n")); <br>if (lpDataObject == NULL) <br>{ <br>ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n")); <br>return E_UNEXPECTED; <br>} <br> <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(lpDataObject); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL); <br>} <br> <br>    STDMETHOD(Destroy)(void) <br>{ <br>ATLTRACE(_T("IComponentDataImpl::Destroy\n")); <br> <br>m_spNode.Release(); <br>m_spConsole.Release(); <br>m_spConsoleNameSpace.Release(); <br>return S_OK; <br>} <br> <br>    STDMETHOD(QueryDataObject)(long cookie, <br>        DATA_OBJECT_TYPES type, <br>        LPDATAOBJECT  *ppDataObject) <br>{ <br>ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n")); <br>_ASSERTE(m_spNode != NULL); <br> <br>if (ppDataObject == NULL) <br>{ <br>ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n")); <br>return E_UNEXPECTED; <br>} <br> <br>*ppDataObject = NULL; <br> <br>if (cookie == NULL) <br>return m_spNode-&gt;QueryInterface(IID_IDataObject, (void**)(ppDataObject)); <br> <br>IUnknown* pUnk = (IUnknown*) cookie; <br>return pUnk-&gt;QueryInterface(IID_IDataObject, (void**)(ppDataObject)); <br>} <br>     <br>    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem) <br>{ <br>ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n")); <br> <br>if (pScopeDataItem == NULL) <br>{ <br>ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n")); <br>return E_UNEXPECTED; <br>} <br> <br>IUnknown* pUnk = (IUnknown*) pScopeDataItem-&gt;lParam; <br>if (pUnk == NULL) <br>pUnk = m_spNode; <br> <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(pUnk); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;GetDispInfo(pScopeDataItem); <br>} <br>     <br>    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, <br>        LPDATAOBJECT lpDataObjectB) <br>{ <br>ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n")); <br>return S_FALSE; <br>    } <br> <br>protected: <br>CComPtr&lt;IUnknown&gt; m_spNode; <br>}; <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IComponentImpl : public IComponent <br>{ <br>public: <br>//Review all of these may not be required <br>CComPtr&lt;IConsole&gt; m_spConsole; <br>CComQIPtr&lt;IHeaderCtrl, &amp;IID_IHeaderCtrl&gt; m_spHeaderCtrl; <br>CComPtr&lt;IImageList&gt; m_spImageList; <br>CComPtr&lt;IConsoleVerb&gt; m_spConsoleVerb; <br> <br>    STDMETHOD(Initialize)(LPCONSOLE lpConsole) <br>{ <br>ATLTRACE(_T("IComponentImpl::Initialize\n")); <br> <br>if (lpConsole == NULL) <br>{ <br>ATLTRACE(_T("lpConsole is NULL\n")); <br>return E_UNEXPECTED; <br>} <br> <br>m_spConsole = lpConsole; <br> <br>m_spHeaderCtrl = lpConsole; <br>if (m_spHeaderCtrl == NULL) <br>{ <br>ATLTRACE(_T("QI for IHeaderCtrl failed\n")); <br>return E_UNEXPECTED; <br>} <br> <br>HRESULT hr = m_spConsole-&gt;SetHeader(m_spHeaderCtrl); <br>if (FAILED(hr)) <br>{ <br>ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr); <br>return hr; <br>} <br> <br>hr = lpConsole-&gt;QueryResultImageList(&amp;m_spImageList); <br>if (FAILED(hr)) <br>{ <br>ATLTRACE(_T("IConsole::QueryResultImageList failed (HRESULT = %x)\n"), hr); <br>return hr; <br>} <br> <br>lpConsole-&gt;QueryConsoleVerb(&amp;m_spConsoleVerb) ; <br>if (FAILED(hr)) <br>{ <br>ATLTRACE(_T("IConsole::QueryConsoleVerb failed (HRESULT = %x)\n"), hr); <br>return hr; <br>} <br> <br>return S_OK; <br>} <br>     <br>STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, <br>        MMC_NOTIFY_TYPE event, <br>        long arg, <br>        long param) <br>{ <br>ATLTRACE(_T("IComponentImpl::Notify\n")); <br>if (lpDataObject == NULL) <br>{ <br>ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n")); <br>return E_UNEXPECTED; <br>} <br> <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(lpDataObject); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;Notify(event, arg, param, FALSE, m_spConsole, m_spHeaderCtrl, NULL); <br>} <br>     <br>    STDMETHOD(Destroy)(long cookie) <br>{ <br>ATLTRACE(_T("IComponentImpl::Destroy\n")); <br> <br>m_spConsoleVerb = NULL; <br>m_spImageList = NULL; <br>m_spHeaderCtrl.Release(); <br>m_spConsole.Release(); <br> <br>return S_OK; <br>} <br>     <br>    STDMETHOD(QueryDataObject)(long cookie, <br>        DATA_OBJECT_TYPES type, <br>        LPDATAOBJECT  *ppDataObject) <br>{ <br>ATLTRACE(_T("IComponentImpl::QueryDataObject\n")); <br> <br>if (ppDataObject == NULL) <br>{ <br>ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n")); <br>return E_UNEXPECTED; <br>} <br> <br>if (cookie == NULL) <br>{ <br>ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n")); <br>return E_UNEXPECTED; <br>} <br> <br>*ppDataObject = NULL; <br> <br>IUnknown* pUnk = (IUnknown *) cookie; <br>return pUnk-&gt;QueryInterface(IID_IDataObject, (void**)ppDataObject); <br>} <br>     <br>    STDMETHOD(GetResultViewType)(long cookie, <br>        LPOLESTR  *ppViewType, <br>        long  *pViewOptions) <br>{ <br>ATLTRACE(_T("IComponentImpl::GetResultViewType\n")); <br> <br>if (cookie == NULL) <br>{ <br>*ppViewType = NULL; <br>*pViewOptions = MMC_VIEW_OPTIONS_NONE; <br>return S_OK; <br>} <br> <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData((IUnknown*)cookie); <br>return spData-&gt;GetResultViewType(ppViewType, pViewOptions); <br>} <br>     <br>    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem) <br>{ <br>ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n")); <br>if (pResultDataItem == NULL) <br>{ <br>ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n")); <br>return E_UNEXPECTED; <br>} <br> <br>IUnknown* pUnk = (IUnknown*) pResultDataItem-&gt;lParam; <br>if (pUnk == NULL) <br>return E_UNEXPECTED; <br> <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(pUnk); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;GetDisplayInfo(pResultDataItem); <br>} <br>     <br>    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA, <br>        LPDATAOBJECT lpDataObjectB) <br>{ <br>ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n")); <br>} <br>}; <br> <br>template &lt;class T, class D&gt;         <br>class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare <br>{ <br>public: <br>    STDMETHOD(Compare)(long lUserParam, <br>        long cookieA, <br>        long cookieB, <br>        int *pnResult) <br>{ <br>ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare")); <br>} <br>}; <br> <br> <br>template &lt;class T&gt;         <br>class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu <br>{ <br>public: <br>    STDMETHOD(AddMenuItems)(LPDATAOBJECT piDataObject, <br>        LPCONTEXTMENUCALLBACK piCallback, <br>        long *pInsertionAllowed) <br>{ <br>ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n")); <br>if (piDataObject == NULL) <br>{ <br>ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with piDataObject==NULL\n")); <br>return E_UNEXPECTED; <br>} <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(piDataObject); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;AddMenuItems(piCallback, pInsertionAllowed); <br>} <br>     <br>    STDMETHOD(Command)(long lCommandID, <br>        LPDATAOBJECT piDataObject) <br>{ <br>ATLTRACE(_T("IExtendContextMenuImpl::Command\n")); <br>if (piDataObject == NULL) <br>{ <br>ATLTRACE(_T("IExtendContextMenu::Command called with piDataObject==NULL\n")); <br>return E_UNEXPECTED; <br>} <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(piDataObject); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;Command(lCommandID); <br>} <br>}; <br> <br>template&lt;class T&gt; <br>class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet <br>{ <br>public: <br>STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, </code></pre>
<p>
</p>
<pre><code>long handle, <br>        LPDATAOBJECT lpIDataObject) <br>{ <br>ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n")); <br>if (lpIDataObject == NULL) <br>{ <br>ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with lpIDataObject==NULL\n")); <br>return E_UNEXPECTED; <br>} <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(lpIDataObject); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;CreatePropertyPages(lpProvider, handle, this); <br>} <br>     <br>    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject) <br>{ <br>ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n")); <br>if (lpDataObject == NULL) <br>{ <br>ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with lpDataObject==NULL\n")); <br>return E_UNEXPECTED; <br>} <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData(lpDataObject); <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;QueryPagesFor(); <br>} <br>}; <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar <br>{ <br>CComPtr &lt;IControlbar&gt; m_spControlbar; <br>public: <br>STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar) <br>{ <br>ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n")); <br>if (pControlbar == NULL) <br>{ <br>ATLTRACE(_T("IExtendControlbar::SetControlbar called with pControlbar==NULL\n")); <br>return E_UNEXPECTED; <br>} <br>m_spControlbar = pControlbar; <br>return S_OK; <br>} <br>     <br>    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, <br>        long arg, <br>        long param) <br>{ <br>ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n")); <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; spData; <br>if (event == MMCN_BTN_CLICK) <br>{ <br>spData = ((IDataObject*) arg); <br>} <br>else if (event == MMCN_SELECT) <br>{ <br>BOOL bScope = (BOOL) LOWORD(arg); <br>if (bScope) <br>{ <br>LPDATAOBJECT* ppDataobject = (LPDATAOBJECT*) param; <br>if (ppDataobject[0]) <br>{ <br>spData = ppDataobject[0]; <br>if (spData != NULL) <br>spData-&gt;ControlbarNotify(m_spControlbar, this, event, arg, param); <br>} <br> <br>if (ppDataobject[1]) <br>{ <br>spData = ppDataobject[1]; <br>} <br>} <br>else <br>spData = (IDataObject*) param; <br>} <br>if (spData == NULL) <br>{ <br>ATLTRACE(_T("QI for ISnapInDataInterface failed\n")); <br>return E_UNEXPECTED; <br>} <br>return spData-&gt;ControlbarNotify(m_spControlbar, this, event, arg, param); <br>} <br>}; <br> <br>template &lt;class T&gt; <br>class ATL_NO_VTABLE ISnapinAboutImpl : public ISnapinAbout <br>{ <br>public: <br>STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapinAboutImpl::GetSnapinDescription\n")); <br>return S_OK; <br>} <br>     <br>    STDMETHOD(GetProvider)(LPOLESTR *lpName) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapinAboutImpl::GetProvider\n")); <br>return S_OK; <br>} <br>     <br>    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapinAboutImpl::GetSnapinVersion\n")); <br>return S_OK; <br>} <br>     <br>    STDMETHOD(GetSnapinImage)(HICON *hAppIcon) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapinAboutImpl::GetSnapinImage\n")); <br>return S_OK; <br>} <br>     <br>    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage, <br>        HBITMAP *hSmallImageOpen, <br>        HBITMAP *hLargeImage, <br>        COLORREF *cMask) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapinAboutImpl::GetStaticFolderImage\n")); <br>return S_OK; <br>} <br>}; <br> <br>class CSnapInBaseData <br>{ <br>public: <br>static const UINT m_CCF_NODETYPE; <br>static const UINT m_CCF_SZNODETYPE; <br>static const UINT m_CCF_DISPLAY_NAME; <br>static const UINT m_CCF_SNAPIN_CLASSID; <br>static const UINT m_CCF_SCOPEDATAITEM; <br>static const UINT m_CCF_RESULTDATAITEM; <br>CComDynamicUnkArray m_scopeonlyitems; <br>CComDynamicUnkArray m_resultonlyitems; <br>CComDynamicUnkArray* m_pParentList; <br>OLECHAR* m_pszDisplayName; <br> <br>SCOPEDATAITEM m_scopeDataItem; <br>RESULTDATAITEM m_resultDataItem; <br>CSnapInBaseData() <br>{ <br>m_pszDisplayName = NULL; <br> <br>memset(&amp;m_scopeDataItem, 0, sizeof(SCOPEDATAITEM)); <br> <br>m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_PARENT; <br>m_scopeDataItem.displayname = MMC_CALLBACK; <br>m_scopeDataItem.nImage = 0; <br>m_scopeDataItem.nOpenImage = 1; <br> <br>memset(&amp;m_resultDataItem, 0, sizeof(RESULTDATAITEM)); <br> <br>m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM; <br>m_resultDataItem.str = MMC_CALLBACK; <br>m_resultDataItem.nImage = 2; <br> <br>m_pParentList = NULL; <br>} <br> <br>~CSnapInBaseData() <br>{ <br>delete m_pszDisplayName; <br>m_pszDisplayName = NULL; <br>for (IUnknown** pp = m_scopeonlyitems.begin(); pp &lt; m_scopeonlyitems.end(); pp++) <br>{ <br>if (*pp) <br>{ <br>IUnknown* pUnk = *pp; <br>m_scopeonlyitems.Remove((DWORD)*pp); <br>pUnk-&gt;Release(); <br>} <br>} <br>for (pp = m_resultonlyitems.begin(); pp &lt; m_resultonlyitems.end(); pp++) <br>{ <br> <br>if (*pp) <br>{ <br>IUnknown* pUnk = *pp; <br>m_resultonlyitems.Remove((DWORD)*pp); <br>pUnk-&gt;Release(); <br>} <br>} <br>} <br> <br>void InitParentList(CComDynamicUnkArray* pParent) <br>{ <br>m_pParentList = pParent; <br>} <br> <br>}; <br> <br>#define SNAPINMENUID(id) \ <br>public: \ <br>static const UINT GetMenuID() \ <br>{ \ <br>static const UINT IDMENU = id; \ <br>return id; \ <br>} <br> <br>#define BEGIN_SNAPINCOMMAND_MAP(theClass) \ <br>typedef theClass _theClass; \ <br>HRESULT ProcessCommand(UINT nID, IDataObject* pDataObject) \ <br>{  <br> <br>#define PRIMARY_SNAPINCOMMAND_ENTRY(id, func) \ <br>if (id == nID) \ <br>return func(); <br> <br>#define PRIMARY_SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \ <br>if (id1 &gt;= nID &amp;&amp; nID &lt;= id2) \ <br>return func(nID); <br> <br>#define EXTENSION_SNAPINCOMMAND_ENTRY(id, func) \ <br>if (id == nID) \ <br>return func(pDataObject); <br> <br>#define EXTENSION_SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \ <br>if (id1 &gt;= nID &amp;&amp; nID &lt;= id2) \ <br>return func(nID, pDataObject); <br> <br>#define END_SNAPINCOMMAND_MAP() \ <br>return ISnapInDataInterfaceImpl&lt; _theClass &gt;::ProcessCommand(nID, pDataObject); \ <br>} <br> <br>struct CSnapInToolBarData <br>{ <br>WORD wVersion; <br>WORD wWidth; <br>WORD wHeight; <br>WORD wItemCount; <br>//WORD aItems[wItemCount] <br> <br>WORD* items() <br>{ return (WORD*)(this+1); } <br>}; <br> <br>#define RT_TOOLBAR  MAKEINTRESOURCE(241) <br> <br>struct CSnapInToolbarInfo <br>{ <br>public: <br>TCHAR** m_pStrToolTip; <br>TCHAR** m_pStrButtonText; <br>UINT* m_pnButtonID; <br>UINT m_idToolbar; <br>UINT m_nButtonCount; <br>IToolbar* m_pToolbar; <br> <br>~CSnapInToolbarInfo() <br>{ <br>if (m_pStrToolTip) <br>{ <br>for (UINT i = 0; i &lt; m_nButtonCount; i++) <br>{ <br>delete m_pStrToolTip[i]; <br>m_pStrToolTip[i] = NULL; <br>} <br>delete [] m_pStrToolTip; <br>m_pStrToolTip = NULL; <br>} <br> <br>if (m_pStrButtonText) <br>{ <br>for (UINT i = 0; i &lt; m_nButtonCount; i++) <br>{ <br>delete m_pStrButtonText[i]; <br>m_pStrButtonText[i] = NULL; <br>} <br> <br>delete [] m_pStrButtonText; <br>m_pStrButtonText = NULL; <br>} <br>if (m_pnButtonID) <br>{ <br>delete m_pnButtonID; <br>m_pnButtonID = NULL; <br>} <br> <br>m_nButtonCount = 0; <br>if (m_pToolbar) <br>m_pToolbar-&gt;Release(); <br>m_pToolbar = NULL; <br>} <br>}; <br> <br>#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \ <br>public: \ <br>static CSnapInToolbarInfo* GetToolbarInfo() \ <br>{ \ <br>static CSnapInToolbarInfo m_toolbarInfo[] = \ <br>{ <br> <br>#define SNAPINTOOLBARID_ENTRY(id) \ <br>{ NULL, NULL, NULL, id, 0, NULL}, <br> <br>#define END_SNAPINTOOLBARID_MAP() \ <br>{ NULL, NULL, NULL, 0, 0, NULL} \ <br>}; \ <br>return m_toolbarInfo; \ <br>} <br> <br>template &lt;class T&gt; <br>class ISnapInDataInterfaceImpl : public ISnapInDataInterface,  <br>public CSnapInBaseData <br>{ <br>public: <br>    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event, <br>        long arg, <br>        long param, <br>BOOL bComponentData, <br>IConsole* pConsole, <br>IHeaderCtrl* pHeader, <br>IToolbar* pToolbar) <br>{ <br>ATLTRACE(_T("ISnapInDataInterfaceImpl::Notify")); <br>if (event == MMCN_RENAME) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br>OLECHAR* pTemp = new OLECHAR[lstrlen((OLECHAR*)param) + 1]; <br>if (pTemp == NULL) <br>return S_FALSE; <br>lstrcpy(pTemp, (OLECHAR*)param); <br>if (!pT-&gt;Rename(pTemp)) <br>{ <br>delete []pTemp; <br>return S_FALSE; <br>} <br> <br>delete []m_pszDisplayName; <br>m_pszDisplayName = pTemp; <br>return S_OK; <br>} <br> <br>if (event == MMCN_ADD_IMAGES) <br>{ <br>CComPtr&lt;IImageList&gt; spImageList; <br>spImageList = (IImageList*)arg; <br> <br>return S_OK; <br>} <br> <br>if (event == MMCN_SHOW) <br>{ <br>int n = 0; <br>CComQIPtr&lt;IResultData, &amp;IID_IResultData&gt; spResultData(pConsole); <br>pHeader-&gt;InsertColumn(1, _T("File"),  LVCFMT_LEFT, MMCLV_AUTO); <br>return EnumerateResultChildren(spResultData); <br>} <br> <br>if (event == MMCN_EXPAND) <br>{ <br>CComQIPtr&lt;IConsoleNameSpace, &amp;IID_IConsoleNameSpace&gt; spConsoleNameSpace(pConsole); <br>return EnumerateScopeChildren(param, spConsoleNameSpace); <br>} <br> <br>if (event == MMCN_SELECT) <br>{ <br>CComPtr&lt;IConsoleVerb&gt; spVerb; <br>pConsole-&gt;QueryConsoleVerb(&amp;spVerb) ; <br> <br>spVerb-&gt;SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE); <br>return S_OK; <br>} <br> <br>return E_UNEXPECTED; <br>} <br>     <br>    STDMETHOD(GetDispInfo)(SCOPEDATAITEM *pScopeDataItem) <br>{ <br>ATLTRACE(_T("ISnapInDataInterfaceImpl::GetDispInfo")); <br>if (pScopeDataItem-&gt;mask &amp; SDI_STR) <br>pScopeDataItem-&gt;displayname = m_pszDisplayName; <br>if (pScopeDataItem-&gt;mask &amp; SDI_IMAGE) <br>pScopeDataItem-&gt;nImage = m_scopeDataItem.nImage; <br>if (pScopeDataItem-&gt;mask &amp; SDI_OPENIMAGE) <br>pScopeDataItem-&gt;nOpenImage = m_scopeDataItem.nOpenImage; <br>if (pScopeDataItem-&gt;mask &amp; SDI_CHILDREN) <br>pScopeDataItem-&gt;cChildren = m_scopeonlyitems.end() - m_scopeonlyitems.begin(); <br>return S_OK; <br> <br>} <br>     <br>    STDMETHOD(GetResultViewType)(LPOLESTR *ppVIewType, <br>        long *pViewOptions) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::GetResultViewType")); <br>} <br>     <br>    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem) <br>{ <br>ATLTRACE(_T("ISnapInDataInterfaceImpl::GetDisplayInfo")); <br>T* pT = static_cast&lt;T*&gt; (this); <br> <br>if (pResultDataItem-&gt;bScopeItem) <br>{ <br>if (pResultDataItem-&gt;mask &amp; RDI_STR) <br>{ <br>pResultDataItem-&gt;str = pT-&gt;GetResultPaneInfo(pResultDataItem-&gt;nCol); <br>} <br>if (pResultDataItem-&gt;mask &amp; RDI_IMAGE) <br>{ <br>pResultDataItem-&gt;nImage = m_scopeDataItem.nImage; <br>} <br> <br>return S_OK; <br>} <br>if (pResultDataItem-&gt;mask &amp; RDI_STR) <br>{ <br>pResultDataItem-&gt;str = pT-&gt;GetResultPaneInfo(pResultDataItem-&gt;nCol); <br>} <br>if (pResultDataItem-&gt;mask &amp; RDI_IMAGE) <br>{ <br>pResultDataItem-&gt;nImage = m_resultDataItem.nImage; <br>} <br>return S_OK; <br>} <br>     <br>    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback, <br>        long *pInsertionAllowed) <br>{ <br>ATLTRACE(_T("ISnapInDataInterfaceImpl::AddMenuItems")); <br>long insertionID; <br>T* pT = static_cast&lt;T*&gt; (this); <br>UINT menuID = pT-&gt;GetMenuID(); <br>if (menuID == 0) <br>return S_OK; <br>HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID)); <br>if (hMenu) <br>{ <br>for (int i = 0; 1; i++) <br>{ <br>HMENU hSubMenu = GetSubMenu(hMenu, i); <br>if (hSubMenu == NULL) <br>break; <br> <br>MENUITEMINFO menuItemInfo; <br>memset(&amp;menuItemInfo, 0, sizeof(menuItemInfo)); <br>menuItemInfo.cbSize = sizeof(menuItemInfo); <br> <br>switch (i) <br>{ <br>case 0: <br>if (! (*pInsertionAllowed &amp; CCM_INSERTIONALLOWED_TOP) ) <br>continue; <br>insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP; <br>break; <br> <br>case 1: <br>if (! (*pInsertionAllowed &amp; CCM_INSERTIONALLOWED_NEW) ) <br>continue; <br>insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW; <br>break; <br> <br>case 2:; <br>if (! (*pInsertionAllowed &amp; CCM_INSERTIONALLOWED_TASK) ) <br>continue; <br>insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK; <br>break; <br>case 3:; <br>if (! (*pInsertionAllowed &amp; CCM_INSERTIONALLOWED_VIEW) ) <br>continue; <br>insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW; <br>break; <br>default: <br>{ <br>insertionID = 0; <br>continue; <br>// Review <br>// Determine what to do here. <br>menuItemInfo.fMask = MIIM_TYPE ; <br>menuItemInfo.fType = MFT_STRING; <br>TCHAR buf[128]; <br>menuItemInfo.dwTypeData = buf; <br>menuItemInfo.cch = 128; <br>if (!GetMenuItemInfo(hMenu, i, TRUE, &amp;menuItemInfo)) <br>continue; <br>//insertionID = _ttol(buf); <br>} <br>break; <br>} <br> <br>menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID; <br>menuItemInfo.fType = MFT_STRING; <br>TCHAR buf[128]; <br>menuItemInfo.dwTypeData = buf; <br> <br>for (int j = 0; 1; j++) <br>{ <br>menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID; <br>menuItemInfo.fType = MFT_STRING; <br>menuItemInfo.cch = 128; <br>TCHAR strStatusBar[257]; <br> <br>if (!GetMenuItemInfo(hSubMenu, j, TRUE, &amp;menuItemInfo)) <br>break; <br> <br>pT-&gt;UpdateMenuState(menuItemInfo.wID, buf, &amp;menuItemInfo.fState); <br>LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, strStatusBar, 257); <br> <br>CONTEXTMENUITEM contextMenuItem; <br>memset(&amp;contextMenuItem, 0, sizeof(contextMenuItem)); <br>contextMenuItem.strName = buf; <br>contextMenuItem.strStatusBarText = strStatusBar; <br>contextMenuItem.lCommandID = menuItemInfo.wID; <br>contextMenuItem.lInsertionPointID = insertionID; <br>contextMenuItem.fFlags = menuItemInfo.fState; <br> <br>piCallback-&gt;AddItem(&amp;contextMenuItem); <br>} <br>} <br>DestroyMenu(hMenu); <br>} <br> <br>return S_OK; <br>} <br>     <br>    STDMETHOD(Command)(long lCommandID) <br>{ <br>ATLTRACE(_T("ISnapInDataInterfaceImpl::Command\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>return pT-&gt;ProcessCommand(lCommandID, NULL); <br>} <br>     <br>    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, <br>        long handle, IUnknown* pUnk) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::CreatePropertyPages")); <br>} <br>     <br>    STDMETHOD(QueryPagesFor)(void) <br>{ <br>ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::QueryPagesFor")); <br>} <br> <br>    STDMETHOD(SetControlbar)(IControlbar *pControlbar, IExtendControlbar* pExtendControlBar) <br>{ <br>ATLTRACE(_T("ISnapInDataInterfaceImpl::SetControlbar\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br> <br>CSnapInToolbarInfo* pInfo = pT-&gt;GetToolbarInfo(); <br>if (pInfo == NULL) <br>return S_OK; <br> <br>for( ; pInfo-&gt;m_idToolbar; pInfo++) <br>{ <br>if (pInfo-&gt;m_pToolbar) <br>continue; <br> <br>HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo-&gt;m_idToolbar)); <br>if (hBitmap == NULL) <br>return S_OK; <br> <br>HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo-&gt;m_idToolbar), RT_TOOLBAR); <br>if (hRsrc == NULL) <br>return S_OK; <br> <br>HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc); <br>if (hGlobal == NULL) <br>return S_OK; <br> <br>CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal); <br>if (pData == NULL) <br>return S_OK; <br>_ASSERTE(pData-&gt;wVersion == 1); <br> <br>pInfo-&gt;m_nButtonCount = pData-&gt;wItemCount; <br>pInfo-&gt;m_pnButtonID = new UINT[pInfo-&gt;m_nButtonCount]; <br>MMCBUTTON *pButtons = new MMCBUTTON[pData-&gt;wItemCount]; <br> <br>pInfo-&gt;m_pStrToolTip = new TCHAR* [pData-&gt;wItemCount]; <br>if (pInfo-&gt;m_pStrToolTip == NULL) <br>continue; <br> <br>for (int i = 0, j = 0; i &lt; pData-&gt;wItemCount; i++) <br>{ <br>pInfo-&gt;m_pStrToolTip[i] = NULL; <br>memset(&amp;pButtons[i], 0, sizeof(MMCBUTTON)); <br>pInfo-&gt;m_pnButtonID[i] = pButtons[i].idCommand = pData-&gt;items()[i]; <br>if (pButtons[i].idCommand) <br>{ <br>pButtons[i].nBitmap = j++; <br>// get the statusbar string and allow modification of the button state <br>TCHAR strStatusBar[512]; <br>LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, strStatusBar, 512); <br> <br>pInfo-&gt;m_pStrToolTip[i] = new TCHAR[lstrlen(strStatusBar) + 1]; <br>if (pInfo-&gt;m_pStrToolTip[i] == NULL) <br>continue; <br>lstrcpy(pInfo-&gt;m_pStrToolTip[i], strStatusBar); <br>pButtons[i].lpTooltipText = pInfo-&gt;m_pStrToolTip[i]; <br>pButtons[i].lpButtonText = _T(""); <br>pT-&gt;SetToolbarButtonInfo(pButtons[i].idCommand, &amp;pButtons[i].fsState, &amp;pButtons[i].fsType); <br>} <br>else <br>{ <br>pButtons[i].lpTooltipText = _T(""); <br>pButtons[i].lpButtonText = _T(""); <br>pButtons[i].fsType = TBSTYLE_SEP; <br>} <br>} <br> <br>        HRESULT hr = pControlbar-&gt;Create(TOOLBAR, pExtendControlBar, reinterpret_cast&lt;LPUNKNOWN*&gt;(&amp;pInfo-&gt;m_pToolbar)); <br>if (FAILED(hr)) <br>continue; <br> <br>hr = pInfo-&gt;m_pToolbar-&gt;AddBitmap(pData-&gt;wItemCount, hBitmap, pData-&gt;wWidth, pData-&gt;wHeight, RGB(192, 192, 192)); <br>if (FAILED(hr)) <br>{ <br>pInfo-&gt;m_pToolbar-&gt;Release(); <br>pInfo-&gt;m_pToolbar = NULL; <br>continue; <br>} <br> <br>hr = pInfo-&gt;m_pToolbar-&gt;AddButtons(pData-&gt;wItemCount, pButtons); <br>if (FAILED(hr)) <br>{ <br>pInfo-&gt;m_pToolbar-&gt;Release(); <br>pInfo-&gt;m_pToolbar = NULL; <br>} <br> <br>delete [] pButtons; <br>} <br>return S_OK; <br>} <br>     <br>    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar, <br>        IExtendControlbar *pExtendControlbar, <br>MMC_NOTIFY_TYPE event, <br>        long arg, long param) <br>{ <br>ATLTRACE(_T("ISnapInDataInterfaceImpl::ControlbarNotify\n")); <br>T* pT = static_cast&lt;T*&gt;(this); <br>CComQIPtr&lt;IDataObject, &amp;IID_IDataObject&gt; spData(this); <br> <br>SetControlbar(pControlbar, pExtendControlbar); <br> <br>if(event == MMCN_SELECT) <br>{ <br>BOOL bScope = (BOOL) LOWORD(arg); <br>BOOL bSelect = (BOOL) HIWORD (arg); <br> <br>if (!bScope) <br>{ <br>CSnapInToolbarInfo* pInfo = pT-&gt;GetToolbarInfo(); <br>if (pInfo == NULL) <br>return S_OK; <br> <br>if (!bSelect) <br>return S_OK; <br> <br>for(; pInfo-&gt;m_idToolbar; pInfo++) <br>{ <br>for (UINT i = 0; i &lt; pInfo-&gt;m_nButtonCount; i++) <br>{ <br>if (pInfo-&gt;m_pnButtonID[i]) <br>{ <br>for (int j = ENABLED; j &lt;= BUTTONPRESSED; j++) <br>{ <br>pInfo-&gt;m_pToolbar-&gt;SetButtonState(pInfo-&gt;m_pnButtonID[i],  <br>(MMC_BUTTON_STATE)j, <br>pT-&gt;UpdateToolbarButton(pInfo-&gt;m_pnButtonID[i], (MMC_BUTTON_STATE)j)); <br>} <br>} <br>} <br>} <br>} <br>else <br>{ <br>LPDATAOBJECT* pData = (LPDATAOBJECT*) param; <br>if (pData[0] == pData[1]) <br>return S_OK; <br>if (spData == pData[0]) <br>{ <br>CSnapInToolbarInfo* pInfo = pT-&gt;GetToolbarInfo(); <br>if (pInfo == NULL) <br>return S_OK; <br> <br>for(; pInfo-&gt;m_idToolbar; pInfo++) <br>{ <br>pControlbar-&gt;Detach(pInfo-&gt;m_pToolbar); <br>} <br>return S_OK; <br>} <br> <br>CSnapInToolbarInfo* pInfo = pT-&gt;GetToolbarInfo(); <br>if (pInfo == NULL) <br>return S_OK; <br> <br>for(; pInfo-&gt;m_idToolbar; pInfo++) <br>{ <br>pControlbar-&gt;Attach(TOOLBAR, pInfo-&gt;m_pToolbar); <br>for (UINT i = 0; i &lt; pInfo-&gt;m_nButtonCount; i++) <br>{ <br>if (pInfo-&gt;m_pnButtonID[i]) <br>{ <br>for (int j = ENABLED; j &lt;= BUTTONPRESSED; j++) <br>{ <br>pInfo-&gt;m_pToolbar-&gt;SetButtonState(pInfo-&gt;m_pnButtonID[i],  <br>(MMC_BUTTON_STATE)j, <br>pT-&gt;UpdateToolbarButton(pInfo-&gt;m_pnButtonID[i], (MMC_BUTTON_STATE)j)); <br>} <br>} <br>} <br>} <br>return S_OK; <br>} <br>} <br>return pT-&gt;ProcessCommand((UINT) param, NULL); <br>} <br> <br>STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem) <br>{ <br>if (pScopeDataItem == NULL) <br>return E_FAIL; <br> <br>*pScopeDataItem = &amp;m_scopeDataItem; <br>return S_OK; <br>} <br>         <br>    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem) <br>{ <br>if (pResultDataItem == NULL) <br>return E_FAIL; <br> <br>*pResultDataItem = &amp;m_resultDataItem; <br>return S_OK; <br>} <br> <br>void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags) <br>{ <br>return; <br>} <br> <br>void SetToolbarButtonInfo(UINT id, BYTE *fsState, BYTE *fsType) <br>{ <br>*fsState = TBSTATE_ENABLED; <br>*fsType = TBSTYLE_BUTTON; <br>} <br> <br>BOOL UpdateToolbarButton(UINT id, BYTE fsState) <br>{ <br>if (fsState == ENABLED) <br>return TRUE; <br>return FALSE; <br>} <br> <br>HRESULT ProcessCommand(UINT nID, IDataObject* pDataObject) <br>{ <br>ATLTRACE(_T("No handler for item with ID %d\n"), nID); <br>return S_OK; <br>} <br> <br>HRESULT FillData(CLIPFORMAT cf, LPSTREAM pStream) <br>{ <br>HRESULT hr = DV_E_CLIPFORMAT; <br>ULONG uWritten; <br> <br>T* pT = static_cast&lt;T*&gt; (this); <br> <br>if (cf == m_CCF_NODETYPE) <br>{ <br>hr = pStream-&gt;Write(pT-&gt;GetNodeType(), sizeof(GUID), &amp;uWritten); <br>return hr; <br>} <br> <br>if (cf == m_CCF_SZNODETYPE) <br>{ <br>hr = pStream-&gt;Write(pT-&gt;GetSZNodeType(), (lstrlen((LPCTSTR)pT-&gt;GetSZNodeType()) + 1 )* sizeof(TCHAR), &amp;uWritten); <br>return hr; <br>} <br> <br>if (cf == m_CCF_DISPLAY_NAME) <br>{ <br>hr = pStream-&gt;Write(pT-&gt;GetDisplayName(), (lstrlen((LPCTSTR)pT-&gt;GetDisplayName()) + 1) * sizeof(TCHAR), &amp;uWritten); <br>return hr; <br>} <br> <br>if (cf == m_CCF_SNAPIN_CLASSID) <br>{ <br>hr = pStream-&gt;Write(pT-&gt;GetSnapInCLSID(), sizeof(CLSID), &amp;uWritten); <br>return hr; <br>} <br> <br>if (cf == m_CCF_SCOPEDATAITEM) <br>{ <br>hr = pStream-&gt;Write(&amp;m_scopeDataItem, sizeof(SCOPEDATAITEM), &amp;uWritten); <br>return hr; <br>} <br> <br>if (cf == m_CCF_RESULTDATAITEM) <br>{ <br>hr = pStream-&gt;Write(&amp;m_resultDataItem, sizeof(RESULTDATAITEM), &amp;uWritten); <br>return hr; <br>} <br> <br>return hr; <br>} <br>OLECHAR* GetResultPaneInfo(int nCol) <br>{ <br>if (nCol == 0 &amp;&amp; m_pszDisplayName) <br>return m_pszDisplayName; <br> <br>return L"Override GetResultPaneInfo in your derived class"; <br>} <br> <br>void PopulateChildren() <br>{ <br>return; <br>} <br> <br>void AddScopeItem(IUnknown* p) <br>{ <br>m_scopeonlyitems.Add(p); <br>} <br> <br>void AddResultItem(IUnknown* p) <br>{ <br>m_resultonlyitems.Add(p); <br>} <br> <br>void RemoveScopeItem(IUnknown* p) <br>{ <br>m_scopeonlyitems.Remove((DWORD)p); <br>} <br> <br>void RemoveResultItem(IUnknown* p) <br>{ <br>m_resultonlyitems.Remove((DWORD)p); <br>} <br> <br>HRESULT EnumerateScopeChildren(long param, IConsoleNameSpace* pNameSpace) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br> <br>pT-&gt;PopulateChildren(); <br> <br>for (IUnknown** pp = m_scopeonlyitems.begin(); pp &lt; m_scopeonlyitems.end(); pp++) <br>{ <br>if (*pp == NULL) <br>continue; <br> <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; pData(*pp); <br>if (pData == NULL) <br>continue; <br> <br>SCOPEDATAITEM* pscopeData; <br>pData-&gt;GetScopeData(&amp;pscopeData); <br> <br>if (pscopeData == NULL) <br>continue; <br> <br>pscopeData-&gt;relativeID = param; <br>HRESULT hr = pNameSpace-&gt;InsertItem(pscopeData); <br>if (FAILED(hr)) <br>return hr; <br>} <br> <br>return S_OK; <br>} <br> <br>HRESULT EnumerateResultChildren(IResultData* pResultData) <br>{ <br>T* pT = static_cast&lt;T*&gt;(this); <br> <br>pT-&gt;PopulateChildren(); <br> <br>for (IUnknown** pp = m_resultonlyitems.begin(); pp &lt; m_resultonlyitems.end(); pp++) <br>{ <br>if (*pp == NULL) <br>continue; <br> <br>CComQIPtr&lt;ISnapInDataInterface, &amp;IID_ISnapInDataInterface&gt; pData(*pp); <br>if (pData == NULL) <br>continue; <br> <br>RESULTDATAITEM* pResultDataItem; <br>pData-&gt;GetResultData(&amp;pResultDataItem); <br> <br>if (pResultDataItem == NULL) <br>continue; <br> <br>HRESULT hr = pResultData-&gt;InsertItem(pResultDataItem); <br>if (FAILED(hr)) <br>return hr; <br>} <br> <br>return S_OK; <br>} <br> <br>static CSnapInToolbarInfo* GetToolbarInfo() <br>{ <br>return NULL; <br>} <br> <br>static const UINT GetMenuID()  <br>{ <br>return 0; <br>} <br> <br>ISnapInDataInterfaceImpl() <br>{ <br>} <br> <br>BOOL Rename(OLECHAR* pNewName) <br>{ <br>return TRUE; <br>} <br>         <br>}; <br> <br> <br>#endif //__ATL_SNAPIN_H__ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
