<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5822"></a>COMP.CPP</h2>
<pre><code>///////////////////////////////////////////////////////////////////////////// <br>// comp.cpp : IComponent Interface to communicate with MMC for the  <br>//                       results pane.  This implementation uses the <br>//                       default list view. <br>// <br>// This is a part of the MMC SDK. <br>// Copyright (C) 1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// MMC SDK Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// MMC Library product. <br>// <br> <br>#include "stdafx.h" <br>#include "disk.h" <br>#include "globals.h" <br>#include "compdata.h"                  // Step2: Added for SetIComponetData <br>#include "comp.h" <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComponent - Several new interfaces are added in Step2: <br>//               <br>//              mostly a stub place holder and serves no real purpose. It will <br>//              get filled in and used in later steps. <br> <br>CComponent::CComponent() <br>{ <br>  m_ipConsole     = NULL;              // Step2: Adding support for a bunch   <br>  m_ipHeaderCtrl  = NULL;              // of new interfaces <br>  m_ipResultData  = NULL;    <br>  m_ipConsoleVerb = NULL;   <br>  m_ipImageResult = NULL;    <br>  m_pCompData     = NULL;       <br>  m_cRefs         = 0;           <br> <br>} // end Constructor() <br> <br> <br>CComponent::~CComponent() <br>{ <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IComponent implementation <br>//  <br> <br>//--------------------------------------------------------------------------- <br>// IComponent::Initialize is called when a snap-in is being created and <br>// has items in the result pane to enumerate. The pointer to IConsole that <br>// is passed in is used to make QueryInterface calls to the console for <br>// interfaces such as IResultData. <br>// Step2:  We add the basic interfaces from the console. <br>// <br>STDMETHODIMP <br>CComponent::Initialize <br>( <br>  LPCONSOLE lpConsole        // [in] Pointer to IConsole's IUnknown interface <br>) <br>{ <br>  HRESULT hr = S_OK; <br>  _ASSERT( NULL != lpConsole ); <br> <br>  // Save away all the interfaces we'll need. <br>  // Fail if we can't QI the required interfaces. <br> <br>  m_ipConsole = lpConsole; <br>  m_ipConsole-&gt;AddRef(); <br>  hr = m_ipConsole-&gt;QueryInterface( IID_IResultData, <br>                                (VOID**)&amp;m_ipResultData <br>  ); <br>  if( FAILED(hr) )  <br>    return hr; <br> <br>  hr = m_ipConsole-&gt;QueryInterface( IID_IHeaderCtrl, <br>                                (VOID**)&amp;m_ipHeaderCtrl <br>  ); <br>  if( FAILED(hr) )  <br>    return hr;                         // Console needs the header <br>  else                                 // control pointer <br>    m_ipConsole-&gt;SetHeader( m_ipHeaderCtrl ); <br> <br>  hr = m_ipConsole-&gt;QueryResultImageList( &amp;m_ipImageResult); <br>  if( FAILED(hr) )  <br>    return hr; <br> <br>  hr = m_ipConsole-&gt;QueryConsoleVerb( &amp;m_ipConsoleVerb ); <br>  if( FAILED(hr) )  <br>    return hr; <br> <br>  // Load the bitmaps from the dll for the results pane <br>  m_hbmp16x16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_RESULT_16x16)); <br>  _ASSERT( m_hbmp16x16 ); <br>  m_hbmp32x32 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_RESULT_32x32)); <br>  _ASSERT( m_hbmp32x32 ); <br> <br>  return hr; <br> <br>} // end Initialize() <br> <br> <br>//--------------------------------------------------------------------------- <br>//  Step2:  Add code to implment notifications.  At this point we do not <br>//          handle every notification, but we have handlers for the most <br>//          important ones. <br>// <br>STDMETHODIMP <br>CComponent::Notify <br>( <br>  LPDATAOBJECT     pDataObject,  // [in] Points to data object <br>  MMC_NOTIFY_TYPE  event,        // [in] Identifies action taken by user <br>  long             arg,          // [in] Depends on the notification type <br>  long             param         // [in] Depends on the notification type <br>) <br>{ <br>  HRESULT hr = S_OK; <br> <br>  switch( event ) <br>  { <br>    case MMCN_ADD_IMAGES: <br>      ATLTRACE( L"CComponent::Notify: MMCN_ADD_IMAGES\n" ); <br>      hr = OnAddImages( pDataObject, arg, param ); <br>      break; <br> <br>    case MMCN_SHOW: <br>      ATLTRACE( L"CComponent::Notify: MMCN_SHOW\n" ); <br>      hr = OnShow( pDataObject, arg, param ); <br>      break; <br> <br>    case MMCN_SELECT: <br>      ATLTRACE( L"CComponent::Notify: MMCN_SELECT\n" ); <br>      hr = OnSelect( pDataObject, arg, param ); <br>      break; <br> <br>    case MMCN_REFRESH: <br>      ATLTRACE( L"CComponent::Notify: MMCN_REFRESH\n" ); <br>      hr = OnRefresh( pDataObject, arg, param ); <br>      break; <br> <br>    case MMCN_VIEW_CHANGE: <br>      ATLTRACE( L"CComponent::Notify: MMCN_VIEW_CHANGE unimplemented\n" ); <br>      break; <br> <br>    case MMCN_CLICK: <br>      ATLTRACE( L"CComponent::Notify: MMCN_CLICK unimplemented\n" ); <br>      break; <br> <br>    case MMCN_DBLCLICK: <br>      ATLTRACE( L"CComponent::Notify: MMCN_DBLCLICK unimplemented\n" ); <br>      break; <br> <br>    case MMCN_ACTIVATE: <br>      ATLTRACE( L"CComponent::Notify: MMCN_ACTIVATE unimplemented\n" ); <br>      break; <br> <br>    case MMCN_MINIMIZED: <br>      ATLTRACE( L"CComponent::Notify: MMCN_MINIMIZED unimplemented\n" ); <br>      break; <br> <br>    case MMCN_BTN_CLICK: <br>      ATLTRACE( L"CComponent::Notify: MMCN_BTN_CLICK unimplemented\n" ); <br>      break; <br> <br>    default: <br>      ATLTRACE( L"CComponent::Notify: unexpected event %x\n" , event ); <br>      hr = E_UNEXPECTED; <br>      break; <br>  } <br>  return hr; <br> <br>} // end Notify() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Releases all references to the console. <br>// Only the console should call this method. <br>// Step2:  Added a bunch of new interfaces to release <br>//  <br>STDMETHODIMP <br>CComponent::Destroy <br>( <br>  long cookie          // Reserved, not in use at this time <br>) <br>{ <br>  // Release the interfaces that we QI'ed <br>  m_ipConsole-&gt;SetHeader(NULL); <br>  if( NULL != m_ipHeaderCtrl )  <br>  {  <br>    m_ipHeaderCtrl-&gt;Release();  <br>    m_ipHeaderCtrl = NULL;  <br>  } <br> <br>  if( NULL != m_ipResultData )  <br>  {  <br>    m_ipResultData-&gt;Release();  <br>    m_ipResultData = NULL;  <br>  }  <br> <br>  if( NULL != m_ipImageResult ) <br>  { <br>    m_ipImageResult-&gt;Release();  <br>    m_ipImageResult = NULL;  <br>  } <br> <br>  if( NULL != m_ipConsoleVerb ) <br>  { <br>    m_ipConsoleVerb-&gt;Release(); <br>    m_ipConsoleVerb= NULL; <br>  } <br> <br>  if( NULL != m_ipConsole ) <br>  { <br>    m_ipConsole-&gt;Release();  <br>    m_ipConsole = NULL;  <br>  } <br> <br>  if( NULL != m_pCompData ) <br>  { <br>    m_pCompData-&gt;Release(); <br>    m_pCompData = NULL; <br>  } <br> <br>  _ASSERT( DeleteObject(m_hbmp16x16) ); <br>  _ASSERT( DeleteObject(m_hbmp32x32) ); <br>   <br>  return S_OK; <br> <br>} // end Destroy() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Returns a data object that can be used to retrieve context information <br>// for the specified cookie. <br>// Step2:  Now we need to implement this method <br>// <br>STDMETHODIMP <br>CComponent::QueryDataObject <br>( <br>  long               cookie,      // [in]  Specifies the unique identifier  <br>  DATA_OBJECT_TYPES  context,     // [in]  Type of data object <br>  LPDATAOBJECT      *ppDataObject // [out] Points to address of returned data <br>) <br>{ <br>  INT iResult; <br>  HRESULT hr = S_OK; <br>  CDataObject *pdoNew = NULL; <br> <br>  _ASSERT( CCT_SCOPE          == context  ||     // Must have a context <br>       CCT_RESULT         == context  ||     // we understand <br>           CCT_SNAPIN_MANAGER == context <br>         ); <br> <br>  do <br>  { <br>    pdoNew = new CDataObject; <br>    *ppDataObject = pdoNew; <br> <br>    if( !pdoNew )                      // Can't create object <br>    { <br>      hr = m_ipConsole-&gt;MessageBox( L"Out of memory", <br>                            L"CComponent::QueryDataObject", <br>MB_OK, <br>&amp;iResult <br>  ); <br>      break; <br>    } <br> <br>    if( CCT_RESULT == context ) <br>    { <br>      if( cookie ) <br>      { <br>        // cookie is the lparam field that we passed in SCOPEDATAITEM <br>        // used for the m_ipConsoleNameSpace-&gt;InsertItem(&amp;sdi); <br>        pdoNew-&gt;SetCookie( cookie, CCT_SCOPE, COOKIE_IS_STATUS ); <br>      } <br>      else  <br>      { <br>//        _ASSERT(FALSE);                // Should never have NULL cookie <br>        hr = E_UNEXPECTED;             // with CCT_RESULT as the context    <br>      } <br>    } <br>    else  <br>    { <br>      hr = E_UNEXPECTED;               // Only handling CCT_RESULT <br>    } <br>  } while( 0 ); <br> <br>  return S_FALSE; <br> <br>} // end QueryDataObject() <br> <br> <br>//--------------------------------------------------------------------------- <br>// This is where we provide strings for items we added to the the result <br>// pane.  We only have one item, so this is easy. We get asked for a string <br>// for each column. <br>// Note that we still need to provide strings for items that are actually <br>// scope pane items. Notice that when the scope pane item was asked for a <br>// string for the scope pane we gave it. Here we actually have two columns <br>// of strings - "Name" and "Type". <br>// We also get asked for the icons for items in both panes. <br>// <br>STDMETHODIMP <br>CComponent::GetDisplayInfo <br>( <br>  LPRESULTDATAITEM pResultItem    // [in,out] Type of info required <br>) <br>{ <br>  static WCHAR* s_szSize = L"ABC"; <br>     <br>  _ASSERT( NULL != pResultItem ); <br>  <br>  if (pResultItem) <br>  { <br>    // Only responding for scope items for now. <br>    if ( TRUE == pResultItem-&gt;bScopeItem ) <br>    { <br>      if (pResultItem-&gt;mask &amp; RDI_STR)     // Looking for a string <br>      { <br>        if (0 == pResultItem-&gt;nCol ) <br>          pResultItem-&gt;str = (LPOLESTR)L"Geometry"; <br>        else if (1 == pResultItem-&gt;nCol ) <br>          pResultItem-&gt;str = (LPOLESTR)L"Child Folder"; <br>        else  <br>          pResultItem-&gt;str = (LPOLESTR)L"Error: Invalid Column"; <br>      } <br> <br>      if (pResultItem-&gt;mask &amp; RDI_IMAGE) <br>      { <br>        pResultItem-&gt;nImage = 0; <br>      } <br>    } <br>    else                     // Step2: Provide strings for Result Pane items <br>    {                        //        See the comments in OnShow() <br>      if( pResultItem-&gt;mask &amp; RDI_STR ) <br>      { <br>        if( pResultItem-&gt;nCol == 0 ) <br>          pResultItem-&gt;str = (LPOLESTR)L"Column 0"; <br>        else if( pResultItem-&gt;nCol == 1 ) <br>          pResultItem-&gt;str = (LPOLESTR)L"Column 1"; <br>        else  <br>          pResultItem-&gt;str = (LPOLESTR)L"Error: Unknown Column."; <br>      } <br> <br>      if( pResultItem-&gt;mask &amp; RDI_IMAGE )  // Looking for image <br>      { <br>        pResultItem-&gt;nImage = 2; <br>      } <br>    } <br>  } <br> <br>  return S_OK; <br> <br>} // end GetDisplayInfo() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Determines what the result pane view should be <br>// <br>STDMETHODIMP <br>CComponent::GetResultViewType <br>( <br>  long  cookie,        // [in]  Specifies the unique identifier  <br>  BSTR  *ppViewType,   // [out] Points to address of the returned view type <br>  long  *pViewOptions  // [out] Pointer to the MMC_VIEW_OPTIONS enumeration <br>) <br>{ <br>  // Ask for default listview. <br>  // <br>  *pViewOptions = MMC_VIEW_OPTIONS_NONE; <br>  return S_FALSE; <br> <br>} // end GetResultViewType() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Not used in Step2  <br>// <br>HRESULT <br>CComponent::CompareObjects <br>( <br>  LPDATAOBJECT lpDataObjectA,  // [in] First data object to compare  <br>  LPDATAOBJECT lpDataObjectB   // [in] Second data object to compare <br>) <br>{ <br>return S_FALSE; <br> <br>} // end CompareObjects() <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//  Support methods <br>// <br> <br>//--------------------------------------------------------------------------- <br>// Here is where we handle the MMCN_SHOW message.  Insert the column  <br>// headers, and then the rows of data into the result pane. <br>// <br>HRESULT  <br>CComponent::OnShow <br>( <br>  LPDATAOBJECT pDataObject,    // [in] Points to data object <br>  long         arg,            // [in]  <br>  long         param           // [in] <br>) <br>{ <br>  INT             iResult; <br>  CDataObject     *pdo; <br>  RESULTDATAITEM  ResultItem; <br>  HRESULT         hr = S_OK; <br> <br>  _ASSERT( NULL != pDataObject ); <br>  _ASSERT( m_ipResultData );           // Must be first time <br> <br>  if( TRUE == arg ) <br>  { <br>    pdo = ExtractOwnDataObject(pDataObject); <br> <br>    // If this is the root node, Let use the default mmc column headings <br>    if( COOKIE_IS_ROOT == pdo-&gt;GetCookieType() ) <br>    { <br>      return S_FALSE; <br>    } <br> <br>    // Set the column headers in the results pane <br>    // <br>    hr = m_ipHeaderCtrl-&gt;InsertColumn( 0, L"One", 0, 100 ); <br>    _ASSERT( S_OK == hr ); <br>    hr = m_ipHeaderCtrl-&gt;InsertColumn( 1, L"Two", 0, 200 ); <br>    _ASSERT( S_OK == hr ); <br> <br>    // Set the items in the results pane rows <br>    // <br>    if( !pdo ) <br>    { <br>      hr = m_ipConsole-&gt;MessageBox( L"Unknown data object.\nNot set up to be an extension", <br>                                L"CComponent::OnShow", <br>                        MB_OK, <br>                                    &amp;iResult <br>  ); <br>      return hr; <br>    } <br> <br>    _ASSERT( CCT_SCOPE == pdo-&gt;GetContext() ); <br>    _ASSERT( COOKIE_IS_STATUS == pdo-&gt;GetCookieType() ); <br> <br>     <br>    // Here we add the one item to the result pane. <br>    // NOTE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <br>    // The lParam is what we see in QueryDataObject as the cookie. <br>    // In the upcomming steps we will actually create an object representing <br>    // row data, so that the cookie knows what to display in the results pane, <br>    // and when we get into GetDisplayInfo we cast the cookie to our object, <br>    // and can get the data to display. <br>    // <br>    memset( &amp;ResultItem, 0, sizeof(RESULTDATAITEM) ); <br>    ResultItem.mask =   RDI_STR     |    // Displayname is valid <br>                        RDI_IMAGE   |    // nImage is valid <br>                        RDI_PARAM;       // lParam is valid <br> <br>    ResultItem.str    = MMC_CALLBACK;    // Will get this from GetDisplayInfo <br>    ResultItem.nImage = 2; <br>    ResultItem.lParam = NULL; <br>    m_ipResultData-&gt;InsertItem( &amp;ResultItem ); <br>  } <br>  return hr; <br> <br>} // end OnShow() <br> <br>//--------------------------------------------------------------------------- <br>// Step2:  New handler for the MMCN_ADD_IMAGES message <br>// <br>HRESULT  <br>CComponent::OnAddImages <br>( <br>  LPDATAOBJECT pDataObject,  // [in] Points to the data object <br>  long arg,                  // [in] Not used <br>  long param                 // [in] Not used <br>) <br>{ <br>  HRESULT hr; <br>  _ASSERT( NULL != m_ipImageResult ); <br>  hr = m_ipImageResult-&gt;ImageListSetStrip( (LONG *)m_hbmp16x16, <br>                                           (LONG *)m_hbmp32x32, <br>                                           0, <br>                                           RGB(0,255,0) <br> ); <br>  _ASSERT( S_OK == hr ); <br>  return hr; <br> <br>} // end OnAddImages() <br> <br>//--------------------------------------------------------------------------- <br>// Step2: This is a handler for the MMCN_SELECT notification. The user <br>//        selected the node that populated the result pane. We have a  <br>//        chance to enable verbs. We will enable the REFRESH verb. <br>// <br>HRESULT  <br>CComponent::OnSelect <br>( <br>  LPDATAOBJECT pDataObject,  // [in] Points to the data object <br>  long         arg,          // [in] Contains flags about the selected item  <br>  long         param         // [in] Not used <br>) <br>{ <br>  BOOL fScopePane; <br>  BOOL fSelected; <br>  CDataObject *pdo; <br>  HRESULT hr  = S_OK; <br> <br>  fScopePane = LOWORD(arg); <br>  fSelected  = HIWORD(arg); <br>   <br>  // Don't care about de-select notifications so just return <br>  // <br>  if( !fSelected ) <br>  { <br>    return S_OK; <br>  } <br> <br>  // <br>  // Bail if we couldn't get the console verb interface, or if the <br>  // selected item is the root; <br>  // <br>  pdo = ExtractOwnDataObject( pDataObject ); <br>  _ASSERT( NULL != pdo );              // Check object before using it  <br> <br>  if( NULL == m_ipConsoleVerb || COOKIE_IS_ROOT == pdo-&gt;GetCookieType() ) <br>  { <br>    return S_OK; <br>  } <br> <br>  // <br>  // Use selections and set which verbs are allowed <br>  // <br>  <br>  if( fScopePane )                     // Selection in the scope pane <br>  { <br>    if( COOKIE_IS_STATUS == pdo-&gt;GetCookieType() ) <br>    { <br>      hr = m_ipConsoleVerb-&gt;SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ); <br>      _ASSERT( S_OK == hr ); <br>    } <br>  } <br>  else                                 // Selection in the result pane <br>  { <br>    // <br>  } <br>  return S_OK; <br> <br>} // end OnSelect() <br> <br> <br>//--------------------------------------------------------------------------- <br>//  Step2: Respond to the MMCN_REFRESH notification and refresh the rows. <br>// <br>HRESULT  <br>CComponent::OnRefresh <br>( <br>  LPDATAOBJECT pDataObject,  // [in] Points to the data object  <br>  long         arg,          // [in] <br>  long         param         // [in] <br>) <br>{ <br>  CDataObject     *pdo; <br>  RESULTDATAITEM  ResultItem; <br>  HRESULT         hr = S_OK; <br> <br>  // <br>  // Clear out and re-populate <br>  // <br>  hr = m_ipResultData-&gt;DeleteAllRsltItems(); <br>  _ASSERT( S_OK == hr ); <br> <br>  _ASSERT( NULL != m_ipResultData ); <br> <br>  pdo = ExtractOwnDataObject( pDataObject ); <br>  _ASSERT( NULL != pdo ); <br> <br>  // If this is the root node, Let use the default mmc column headings <br>  if( COOKIE_IS_ROOT == pdo-&gt;GetCookieType() ) <br>  { <br>    return S_FALSE; <br>  } <br> <br>  // <br>  // Set the items in the results pane rows <br>  // <br> <br>  _ASSERT( CCT_SCOPE == pdo-&gt;GetContext() ); <br>  _ASSERT( COOKIE_IS_STATUS == pdo-&gt;GetCookieType() ); <br> <br>  memset( &amp;ResultItem, 0, sizeof(RESULTDATAITEM) ); <br>  ResultItem.mask =   RDI_STR     |    // displayname is valid <br>                      RDI_IMAGE   |    // nImage is valid <br>                      RDI_PARAM;       // lParam is valid <br> <br>  ResultItem.str    = MMC_CALLBACK; <br>  ResultItem.nImage = 2; <br>  ResultItem.lParam = NULL; <br>  m_ipResultData-&gt;InsertItem( &amp;ResultItem ); <br> <br>  return S_OK; <br> <br>} // end OnRefresh() <br> <br> <br>//--------------------------------------------------------------------------- <br>//  Store the parent IComponetData object. <br>// <br>VOID <br>CComponent::SetIComponentData <br>( <br>  CComponentData*  pData <br>) <br>{ <br>  _ASSERT( pData );                     <br>  _ASSERT( NULL == m_pCompData );        // Can't do this twice <br>  LPUNKNOWN pUnk = pData-&gt;GetUnknown();  // Get the object IUnknown <br> <br>  HRESULT hr; <br>  hr = pUnk-&gt;QueryInterface( IID_IComponentData, <br>                         reinterpret_cast&lt;void**&gt;(&amp;m_pCompData) <br>   ); <br>  _ASSERT( S_OK == hr ); <br> <br>} // end SetIComponentData() </code></pre>
<p>&nbsp;</p></body>
</HTML>
