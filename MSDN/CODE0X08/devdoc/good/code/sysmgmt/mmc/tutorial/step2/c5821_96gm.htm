<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MMC.IDL</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5836"></a>MMC.IDL</h2>
<pre><code>import "oaidl.idl"; <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/// Interfaces implement by the Common Console's Node Manager <br> <br>interface IConsole; <br>interface IHeaderCtrl; <br>interface IToolbar; <br>interface IImageList; <br>interface IResultData; <br>interface IConsoleNameSpace; <br>interface IPropertySheetProvider; <br>interface IPropertySheetCallback; <br>interface IContextMenuProvider; <br>interface IContextMenuCallback; <br>interface IControlbar; <br>interface IConsoleVerb; <br>interface IMenuButton; <br>interface IQuickFilter; <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/// Interfaces implement by the Snap-in server <br> <br>interface IComponent; <br>interface IComponentData; <br>interface IExtendPropertySheet; <br>interface IExtendContextMenu; <br>interface IExtendControlbar; <br>interface IResultDataCompare; <br>interface ISnapinAbout; <br>interface IResultOwnerData; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/// Type definitions <br> <br>typedef IConsole*                   LPCONSOLE; <br>typedef IHeaderCtrl*                LPHEADERCTRL; <br>typedef IToolbar*                   LPTOOLBAR; <br>typedef IImageList*                 LPIMAGELIST; <br>typedef IResultData*                LPRESULTDATA; <br>typedef IConsoleNameSpace*          LPCONSOLENAMESPACE; <br>typedef IPropertySheetProvider*     LPPROPERTYSHEETPROVIDER; <br>typedef IPropertySheetCallback*     LPPROPERTYSHEETCALLBACK; <br>typedef IContextMenuProvider*       LPCONTEXTMENUPROVIDER; <br>typedef IContextMenuCallback*       LPCONTEXTMENUCALLBACK; <br>typedef IControlbar*                LPCONTROLBAR; <br>typedef IConsoleVerb*               LPCONSOLEVERB; <br>typedef IMenuButton*                LPMENUBUTTON; <br> <br>typedef IComponent*                 LPCOMPONENT; <br>typedef IComponentData*             LPCOMPONENTDATA; <br>typedef IExtendPropertySheet*       LPEXTENDPROPERTYSHEET; <br>typedef IExtendContextMenu*         LPEXTENDCONTEXTMENU; <br>typedef IExtendControlbar*          LPEXTENDCONTROLBAR; <br>typedef IResultDataCompare*         LPRESULTDATACOMPARE; <br>typedef ISnapinAbout*               LPSNAPABOUT; <br>typedef IResultOwnerData*           LPRESULTOWNERDATA; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Published Common Console ListView constants <br> <br>#define LVS_ICON                0x0000 <br>#define LVS_REPORT              0x0001 <br>#define LVS_SMALLICON           0x0002 <br>#define LVS_LIST                0x0003 <br>#define LVSICF_NOINVALIDATEALL  0x00000001 <br>#define LVSICF_NOSCROLL         0x00000002 <br> <br>const long  MMCLV_AUTO = -1; <br>const long  MMCLV_NOPARAM = -2; <br>const long  MMCLV_NOICON = -1; <br>const long  MMCLV_VIEWSTYLE_ICON = LVS_ICON; <br>const long  MMCLV_VIEWSTYLE_SMALLICON = LVS_SMALLICON; <br>const long  MMCLV_VIEWSTYLE_LIST = LVS_LIST; <br>const long  MMCLV_VIEWSTYLE_REPORT = LVS_REPORT; <br>const void* MMCLV_NOPTR = 0x0; <br>const long  MMCLV_UPDATE_NOINVALIDATEALL = LVSICF_NOINVALIDATEALL; <br>const long  MMCLV_UPDATE_NOSCROLL = LVSICF_NOSCROLL; <br> <br>static unsigned short* MMC_CALLBACK = ((unsigned short *)(-1)); <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// ResultData and Scope Data item structures. <br> <br>typedef long    HSCOPEITEM; <br>typedef long    COMPONENTID; <br>typedef long    HRESULTITEM; <br> <br>const DWORD RDI_STR     = 0x0002; <br>const DWORD RDI_IMAGE   = 0x0004; <br>const DWORD RDI_STATE   = 0x0008; <br>const DWORD RDI_PARAM   = 0x0010; <br>const DWORD RDI_INDEX   = 0x0020; <br>const DWORD RDI_INDENT  = 0x0040; <br> <br> <br>typedef enum _MMC_RESULT_VIEW_STYLE <br>{ <br>    MMC_SINGLESEL       = 0x0001, <br>    MMC_SHOWSELALWAYS   = 0x0002, <br>    MMC_NOSORTHEADER    = 0x0004, <br> <br>} MMC_RESULT_VIEW_STYLE; <br> <br> <br>// List view with single select <br>const long MMC_VIEW_OPTIONS_NONE            = 0x0000; <br> <br>// NO List view. Only custom views. <br>const long MMC_VIEW_OPTIONS_NOLISTVIEWS     = 0x0001; <br> <br>// List view with multi select. <br>const long MMC_VIEW_OPTIONS_MULTISELECT     = 0x0002; <br>  <br>//List view with user owned data <br>const long MMC_VIEW_OPTIONS_OWNERDATALIST   = 0x0004; <br> <br>//List view with filter header <br>const long MMC_VIEW_OPTIONS_FILTERED        = 0x0008; <br> <br>// Create new control (don't use cached) <br>const long MMC_VIEW_OPTIONS_CREATENEW       = 0x0010; <br> <br>// Property sheet options <br>const DWORD MMC_PSO_NOAPPLYNOW              = 0x00000001; <br>const DWORD MMC_PSO_HASHELP                 = 0x00000002; <br>const DWORD MMC_PSO_NEWWIZARDTYPE           = 0x00000004; <br> <br> <br> <br>// Type of controls that can be attached to the IControlbar <br>typedef enum  _MMC_CONTROL_TYPE <br>{ <br>    TOOLBAR, <br>    MENUBUTTON, <br>    COMBOBOXBAR <br>} MMC_CONTROL_TYPE; <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Console commands - These should be reviewed <br>// <br>typedef enum _MMC_CONSOLE_VERB <br>{ <br>    MMC_VERB_NONE            = 0x0000, <br>    MMC_VERB_OPEN            = 0x8000, <br>    MMC_VERB_COPY            = 0x8001,  <br>    MMC_VERB_PASTE           = 0x8002,  <br>    MMC_VERB_DELETE          = 0x8003,  <br>    MMC_VERB_PROPERTIES      = 0x8004,  <br>    MMC_VERB_RENAME          = 0x8005,  <br>    MMC_VERB_REFRESH         = 0x8006,       <br>    MMC_VERB_PRINT           = 0x8007,  <br>     <br>} MMC_CONSOLE_VERB; <br> <br>// Structure to create buttons on the toolbar <br>typedef struct _MMCButton <br>{ <br>    int      nBitmap;       // Offset into the bitmap list  <br>    int      idCommand;     // Command ID return when the button is clicked <br>    BYTE     fsState;       // TBSTYLE_ENABLED ..etc <br>    BYTE     fsType;        // TBSTYLE_BUTTON || TBSTYLE_SEP <br>    LPOLESTR     lpButtonText;  // Text value for the Button <br>    LPOLESTR     lpTooltipText; // Text value for the tooltip <br>     <br>} MMCBUTTON; <br> <br>typedef MMCBUTTON* LPMMCBUTTON; <br> <br>typedef enum _MMC_BUTTON_STATE <br>{ <br>    ENABLED         = 0x01, <br>    CHECKED         = 0x02, <br>    HIDDEN          = 0x04, <br>    INDETERMINATE   = 0x08, <br>    BUTTONPRESSED   = 0x10, <br> <br>} MMC_BUTTON_STATE; <br> <br>typedef struct _RESULTDATAITEM <br>{ <br>    DWORD       mask; <br>    BOOL        bScopeItem; <br>    HRESULTITEM itemID; <br>    int         nIndex; <br>    int         nCol; <br>    LPOLESTR    str; <br>    int         nImage; <br>    UINT        nState; <br>    LPARAM      lParam; <br>    int         iIndent; <br>} RESULTDATAITEM; <br> <br>typedef RESULTDATAITEM* LPRESULTDATAITEM; <br> <br>// Find result item options    <br>const DWORD RFI_PARTIAL = 0x0001; <br>const DWORD RFI_WRAP    = 0x0002; <br> <br>typedef struct _RESULTFINDINFO <br>{ <br>    LPOLESTR    psz; <br>    int         nStart; <br>    DWORD       dwOptions; <br>} <br> RESULTFINDINFO; <br>typedef RESULTFINDINFO* LPRESULTFINDINFO; <br> <br>// <br>// Sort Result Items options <br>// <br>const DWORD RSI_DESCENDING = 0x0001; <br> <br> <br>const DWORD SDI_STR         = 0x00002; <br>const DWORD SDI_IMAGE       = 0x00004; <br>const DWORD SDI_OPENIMAGE   = 0x00008; <br>const DWORD SDI_STATE       = 0x00010; <br>const DWORD SDI_PARAM       = 0x00020; <br>const DWORD SDI_CHILDREN    = 0x00040; <br> <br>// The top 4 bit of the mask determines the relative position of this item, <br>// relative to the SCOPEDATAITEM::relativeID. By default it is the parent. <br> <br>// For SDI_PARENT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the parent. <br>// As you can see by the SDI_PARENT value it is a no-op. Since by default <br>// SCOPEDATAITEM::relativeID is treated as the parents ID. <br>const DWORD SDI_PARENT      = 0x00000000; <br> <br>// For SDI_PREVIOUS, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the previous sibling <br>const DWORD SDI_PREVIOUS    = 0x10000000; <br> <br>// For SDI_NEXT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the next sibling. <br>const DWORD SDI_NEXT        = 0x20000000; <br> <br>// For SDI_PARENT, bit 27 determines whether the item is to be inserted as the <br>// first child. By default this item will inserted as the last child. <br>const DWORD SDI_FIRST       = 0x08000000; <br> <br> <br>typedef struct _SCOPEDATAITEM <br>{ <br>    DWORD       mask; <br>    LPOLESTR    displayname; <br>    int         nImage; <br>    int         nOpenImage; <br>    UINT        nState; <br>    int         cChildren; <br>    LPARAM      lParam; <br>    HSCOPEITEM  relativeID; <br>    HSCOPEITEM  ID; <br>} SCOPEDATAITEM; <br> <br>typedef SCOPEDATAITEM* LPSCOPEDATAITEM; <br> <br>typedef enum _MMC_SCOPE_ITEM_STATE <br>{ <br>    MMC_SCOPE_ITEM_STATE_NORMAL = 0x0001,        // Not bold. To set or get. <br>    MMC_SCOPE_ITEM_STATE_BOLD = 0x0002,          // To set or get. <br>    MMC_SCOPE_ITEM_STATE_EXPANDEDONCE = 0x0003,  // Only to get. <br>     <br>} MMC_SCOPE_ITEM_STATE; <br> <br> <br>typedef struct _CONTEXTMENUITEM <br>{ <br>    LPWSTR      strName; <br>    LPWSTR      strStatusBarText; <br>    LONG        lCommandID; <br>    LONG        lInsertionPointID; <br>    LONG        fFlags; <br>    LONG        fSpecialFlags; <br>} CONTEXTMENUITEM; <br> <br>typedef CONTEXTMENUITEM* LPCONTEXTMENUITEM; <br> <br>// <br>// Console defined menu command IDs <br>//   The console reserves the negative numbers for predefined menu command <br>//   IDs which it sends to a snapin's IExtendContextMenu::Command method   <br>// <br>typedef enum _MMC_MENU_COMMAND_IDS <br>{ <br>    MMCC_STANDARD_VIEW_SELECT = -1 <br>} MMC_MENU_COMMAND_IDS; <br> <br> <br> <br>//IMenuButton data structure <br> <br>typedef struct _MENUBUTTONDATA <br>{ <br>    int      idCommand; <br>    int      x; <br>    int      y; <br>} MENUBUTTONDATA; <br> <br>typedef MENUBUTTONDATA* LPMENUBUTTONDATA; <br> <br> <br>//  For multi select the cookie passed to the snapins will be  <br>//  MMC_MULTI_SELECT_COOKIE. The data object that will be returned  <br>//  should provide the CCF_OBJECT_TYPES_IN_MULTI_SELECT clipboard <br>//  format. <br>//  <br>const long MMC_MULTI_SELECT_COOKIE = -2; <br> <br>/* <br>NOTIFICATIONS <br>============= <br> <br>Notify(dataobject, event, arg, param); <br>    For all the MMC_NOTIFY_TYPE events,  <br>    dataobject <br>        For single select: <br>            dataobject for cookie, can be NULL when dataobject is not required <br>        For multi select: <br>            Console supplied data object. Supports only one format (CCF_MULTI_SELECT_SNAPIN), <br>            which can be used to accquire an IUnknow to the primary snapin. <br>    event = one of the MMCN_NOTIFY_TYPEs <br>    arg and param depend on type, see below. <br>     <br>MMCN_ACTIVATE <br>    Is sent when a window is being activated or deactivated. <br>    arg = TRUE if window is activated, false otherwise. <br>    param = Not used. <br> <br>MMCN_ADD_IMAGES <br>    Sent to IComponent to add images for the result pane. The primary snapin <br>        should add images for both folders and leaf items. Extension snapins <br>        should add only folder images.  <br>    arg = ptr to result panes IImageList. <br>    param = HSCOPEITEM of selected/deselected item <br>     <br>MMCN_BTN_CLICK       <br>    This message is sent when a user clicks on a button. <br>    arg   = When sent to ExtendControlbar it is the data object of currently selected, <br>            when sent to IComponent/IComponentData it is 0. <br>    param = CmdID of the button equal to a value of the MMC_COMMANDS enum type. <br> <br>MMCN_EXPAND          <br>    arg = TRUE =&gt; expand, FALSE =&gt; contract <br>    param = parents HSCOPEITEM. <br>     <br>MMCN_MINIMIZED       <br>    Is sent when a window is being minimized or maximized. <br>    arg = TRUE if minimized, false otherwise. <br>     <br>MMCN_PROPERTY_CHANGE <br>    lpDataObject = NULL <br>    lParam = user object <br> <br>MMCN_REMOVE_CHILDREN <br>    Informs the snapin to delete all the cookies it has added below. <br>    arg = HSCOPEITEM of the node whose children needs to be deleted. <br>    param = unused. <br>    return = unused. <br>     <br>MMCN_RENAME        <br>    This gets called the first time to query for rename and a <br>    second time to do the rename.  For the query S_OK or S_FALSE for the <br>    return type.  After the rename, we will send the new name with a LPOLESTR. <br>    arg = 0 for query, 1 for rename action  <br>    param = LPOLESTR for containing new name    <br>    return = S_OK to allow rename and S_FALSE to disallow rename.                     <br> <br>MMCN_SELECT <br>    If sent to IComponent::Notify: <br>        arg: <br>            BOOL bScope = (BOOL) LOWORD(arg); <br>            BOOL bSelect = (BOOL) HIWORD(arg); <br>                bScope:     TRUE if an item the scope pane is selected,  <br>                            FALSE if an item in the result pane is selected. <br>                bSelect:    TRUE if the item is selected,  <br>                            FALSE if it is de-selected. <br>        param:  <br>            Ignored.                 <br>                 <br>    If sent to IExtendControlbar::ControlbarNotify: <br>        arg: <br>            BOOL bScope = (BOOL) LOWORD(arg); <br>            BOOL bSelect = (BOOL) HIWORD(arg); <br>                bScope:     TRUE if an item the scope pane is selected,  <br>                            FALSE if an item in the result pane is selected. <br>                bSelect:    TRUE if the item is selected, <br>                            FALSE if it is de-selected.   <br>        param: <br>            LPDATAOBJECT pDataobject = (LPDATAOBJECT)param; <br>            pDataobject data object of item getting selected/de-selected. <br> <br>     <br>MMCN_SHOW            <br>    arg = &lt;&gt;0 if selecting, 0 if deselecting <br>    param = HSCOPEITEM of selected/deselected item <br> <br>MMCN_VIEW_CHANGE     <br>    This message is sent to update all views of a change. <br>    arg = TRUE if Scope Item, FALSE if Result Item <br>    param = ptr to DataObject selected <br> <br>MMCN_MENU_BTNCLICK       <br>    This message is sent when a user clicks on a button. <br>    arg   = Data object of currently selected. <br>    param = Structure (LPMENUBUTTONDATA). <br> <br>MMCN_SNAPINHELP <br>    This message is sent when the user requests help about the snapin. <br>    dataObject = NULL <br>    arg = 0 <br>    param = 0 <br> <br>MMCN_CONTEXTHELP <br>    This message is sent when the user requests help about a selected item <br>    arg = 0 <br>    param = 0  <br> <br>MMCN_DESELECT_ALL <br>    This message is sent when all items of an owner-data result pane <br>    are deselected. <br>    dataObject = NULL <br>    arg = 0 <br>    param = 0 <br>     <br>MMCN_COLUMN_CLICK <br>    This message is sent when the user clicks on a result listview column header. <br>    dataObject = NULL <br>    arg = Column number <br>    param = Sort option flags (RSI_xxx)  <br>     <br>MMCN_DELETE: <br>    Sent to inform the snapin that the item needs to be deleted. As a result of <br>    the user hitting the 'Delete' key or delete button. <br>    dataobject: dataobject of the selected item(s) provided by the snap-in. <br>    arg, param: unused. <br> <br>MMCN_CUTORMOVE: <br>    dataobject: NULL. <br>    arg: pointer to a dataobject. See multi-selection below. <br>    param: unused. <br> <br>MMCN_QUERY_PASTE: <br>    dataobject: dataobject of the selected item provided by the snap-in.         <br>    arg: dataobject of the item(s) provided by the source snap-in that needs to be pasted. <br>    param: unused. <br> <br>MMCN_PASTE: <br>    dataobject &amp; arg: are same as for MMCN_QUERY_PASTE. <br>    param: <br>        NULL for move (as opposed to cut). <br>        For single item paste: <br>            BOOL* pPasted = (BOOL*)param;  <br>            Set this to TRUE here if the item was successfully pasted. <br>        For multi-item paste: <br>            LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param; <br>            Use this to return a pointer to a dataobject consisting of the  <br>            items successfully pasted. (see MMCN_CUTORMOVE below). <br>*/ <br> <br>typedef enum _MMC_NOTIFY_TYPE <br>{ <br>    MMCN_ACTIVATE           = 0x8001, <br>    MMCN_ADD_IMAGES         = 0x8002, <br>    MMCN_BTN_CLICK          = 0x8003, <br>    MMCN_CLICK              = 0x8004, <br>    MMCN_COLUMN_CLICK       = 0x8005, <br>    MMCN_CONTEXTMENU        = 0x8006, <br>    MMCN_CUTORMOVE          = 0x8007, <br>    MMCN_DBLCLICK           = 0x8008, <br>    MMCN_DELETE             = 0x8009, <br>    MMCN_DESELECT_ALL       = 0x800A, <br>    MMCN_EXPAND             = 0x800B, <br>    MMCN_HELP               = 0x800C, <br>    MMCN_MENU_BTNCLICK      = 0x800D, <br>    MMCN_MINIMIZED          = 0x800E, <br>    MMCN_PASTE              = 0x800F, <br>    MMCN_PROPERTY_CHANGE    = 0x8010, <br>    MMCN_QUERY_PASTE        = 0x8011, <br>    MMCN_REFRESH            = 0x8012, <br>    MMCN_REMOVE_CHILDREN    = 0x8013, <br>    MMCN_RENAME             = 0x8014, <br>    MMCN_SELECT             = 0x8015, <br>    MMCN_SHOW               = 0x8016,  <br>    MMCN_VIEW_CHANGE        = 0x8017, <br>    MMCN_SNAPINHELP         = 0x8018, <br>    MMCN_CONTEXTHELP        = 0x8019, <br>    MMCN_INITOCX            = 0x801A, <br>     <br>} MMC_NOTIFY_TYPE; <br> <br>typedef enum _DATA_OBJECT_TYPES <br>{ <br>    CCT_SCOPE            = 0x8000, // Data object while for scope pane context <br>    CCT_RESULT           = 0x8001, // Data object while for result pane context <br>    CCT_SNAPIN_MANAGER   = 0x8002, // Data object while for snap-in manager context <br>    CCT_UNINITIALIZED    = 0xFFFF, // Data object has an invalid type <br> <br>} DATA_OBJECT_TYPES; <br> <br> <br>//New window option(s) <br>const unsigned long MMC_NW_OPTION_LONGTITLE =  0x0000;   <br>const unsigned long MMC_NW_OPTION_SHORTTITLE = 0x0001; <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Common Console clipboard formats <br>// <br> <br>// Clipboard format for node type guid <br>const wchar_t* CCF_NODETYPE = L"CCF_NODETYPE";  <br> <br>// Clipboard format for string version of node type guid <br>const wchar_t* CCF_SZNODETYPE = L"CCF_SZNODETYPE"; <br> <br>// Clipboard format for name displayed in scope pane <br>const wchar_t* CCF_DISPLAY_NAME = L"CCF_DISPLAY_NAME"; <br> <br>// Clipboard format for the snapin's class id. <br>const wchar_t* CCF_SNAPIN_CLASSID = L"CCF_SNAPIN_CLASSID"; <br> <br> <br>// This is the MMC supplied Multi-select data object. <br>const wchar_t* CCF_MMC_MULTISELECT_DATAOBJECT = L"CCF_MMC_MULTISELECT_DATAOBJECT"; <br> <br>// Clipboard format for the snapins multi selected dataobjects. <br>// If there are N snapins whose objects are selected in the result <br>// pane, these N dataobjects will be passed in a GloballAlloced <br>// memory. The first DWORD contains the number of snapins, this will <br>// be followed by N ptrs to the DataObjects. <br>typedef struct _SMMCDataObjects <br>{ <br>    DWORD           count; <br>    LPDATAOBJECT    lpDataObject[1]; <br>     <br>} SMMCDataObjects; <br>const wchar_t* CCF_MULTI_SELECT_SNAPINS = L"CCF_MULTI_SELECT_SNAPINS"; <br> <br>// Clipboard format for the array of GUIDs which constitutes the object  <br>// types of all the currently selected result items put by the snapin. <br>typedef struct _SMMCObjectTypes <br>{ <br>    DWORD   count; <br>    GUID    guid[1]; <br>     <br>} SMMCObjectTypes; <br> <br>const wchar_t* CCF_OBJECT_TYPES_IN_MULTI_SELECT = L"CCF_OBJECT_TYPES_IN_MULTI_SELECT"; <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// APIs exported in mmc.lib <br>// <br>cpp_quote("STDAPI MMCPropertyChangeNotify(long lNotifyHandle, long param);") <br>cpp_quote("STDAPI MMCFreeNotifyHandle(long lNotifyHandle);") <br>cpp_quote("STDAPI MMCPropPageCallback(void* vpsp);") <br>cpp_quote("EXTERN_C const CLSID CLSID_NodeManager;") <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Special dataobjects <br>// <br>cpp_quote("#define DOBJ_NULL (LPDATAOBJECT)0 ") <br>cpp_quote("#define DOBJ_CUSTOMOCX (LPDATAOBJECT)-1 ") <br>cpp_quote("#define DOBJ_CUSTOMWEB (LPDATAOBJECT)-2 ") <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Macros <br>// <br>cpp_quote("#define IS_SPECIAL_DATAOBJECT(d) ((int)(d) &gt;= -10 &amp;&amp; (int)(d) &lt;= 0)") <br>cpp_quote("#define IS_SPECIAL_COOKIE(c) ((c) &gt;= -10 &amp;&amp; (c) &lt;= -1)") <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  Interfaces <br>// <br>    [ <br>        object, <br>        uuid(955AB28A-5218-11D0-A985-00C04FD8D565), <br>        helpstring("IComponentData Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IComponentData : IUnknown <br>    { <br>        [helpstring("Snap-in entry point. Can QI for IConsole &amp; IConsoleNameSpace")] <br>        HRESULT Initialize([in] LPUNKNOWN pUnknown); <br> <br>        [helpstring("Create a Componet for this ComponetData")] <br>        HRESULT CreateComponent([out] LPCOMPONENT* ppComponent); <br> <br>        [helpstring("User actions")] <br>        HRESULT Notify([in] LPDATAOBJECT lpDataObject, [in] MMC_NOTIFY_TYPE event,  <br>                       [in] long arg, [in] long param); <br> <br>        [helpstring("Release cookies associated with the children of a specific node")] <br>        HRESULT Destroy(); <br> <br>        [helpstring("Returns a data object which may be used to retrieve the context information for the specified cookie")] <br>        HRESULT QueryDataObject([in] long cookie, [in] DATA_OBJECT_TYPES type, <br>                                [out] LPDATAOBJECT* ppDataObject); <br> <br>        [helpstring("Get display info for the name space item")] <br>        HRESULT GetDisplayInfo([in,out] SCOPEDATAITEM* pScopeDataItem); <br> <br>        [helpstring("The snap-in's compare function for two data objects")] <br>        HRESULT CompareObjects([in] LPDATAOBJECT lpDataObjectA, [in] LPDATAOBJECT lpDataObjectB); <br>    }; <br>     <br> <br>    [ <br>        object, <br>        uuid(43136EB2-D36C-11CF-ADBC-00AA00A80033), <br>        helpstring("IComponent Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IComponent : IUnknown <br>    { <br>        [helpstring("Snap-in entry point")] <br>        HRESULT Initialize([in] LPCONSOLE lpConsole); <br>         <br>        [helpstring("User actions")] <br>        HRESULT Notify([in] LPDATAOBJECT lpDataObject, [in] MMC_NOTIFY_TYPE event,  <br>                       [in] long arg, [in] long param); <br>                        <br>        [helpstring("Release cookies associated with the children of a specific node")] <br>        HRESULT Destroy([in] long cookie); <br> <br>        [helpstring("Returns a data object which may be used to retrieve the context information for the specified cookie")] <br>        HRESULT QueryDataObject([in] long cookie, [in] DATA_OBJECT_TYPES type, <br>                                [out] LPDATAOBJECT* ppDataObject); <br>                         <br>        [helpstring("Returns the result view type for the specified cookie")] <br>        HRESULT GetResultViewType([in] long cookie, [out] LPOLESTR* ppViewType,  <br>                                  [out] long* pViewOptions); <br> <br>        [helpstring("Get display info for the result item")] <br>        HRESULT GetDisplayInfo([in,out] RESULTDATAITEM*  pResultDataItem); <br> <br>        [helpstring("The snap-in's compare function for two data objects")] <br>        HRESULT CompareObjects([in] LPDATAOBJECT lpDataObjectA, [in] LPDATAOBJECT lpDataObjectB); <br>    }; <br> <br> <br>    [ <br>        object, <br>        uuid(E8315A52-7A1A-11D0-A2D2-00C04FD909DD), <br>        helpstring("Compare interface for sorting result items"), <br>        pointer_default(unique) <br>    ] <br>    interface IResultDataCompare : IUnknown <br>    { <br>        [helpstring("Compare two cookies")] <br>        HRESULT Compare([in] long lUserParam,  <br>            [in] long cookieA, [in] long cookieB, [in, out] int* pnResult); <br>    } <br> <br> <br>    [ <br>        object, <br>        uuid(9CB396D8-EA83-11d0-AEF1-00C04FB6DD2C), <br>        helpstring("Interface for owner data result pane list"), <br>        pointer_default(unique) <br>    ] <br>    interface IResultOwnerData : IUnknown <br>    { <br>        [helpstring("Find result item that matches string")] <br>        HRESULT FindItem([in] LPRESULTFINDINFO pFindInfo, [out] int* pnFoundIndex); <br>         <br>        [helpstring("Hint to cache result item data")] <br>        HRESULT CacheHint ([in] int nStartIndex, [in] int nEndIndex); <br>         <br>        [helpstring("Sort result items")] <br>        HRESULT SortItems([in] int nColumn, [in] DWORD dwSortOptions, [in] long lUserParam);  <br>    } <br> <br> <br>    [ <br>        object, <br>        uuid(43136EB1-D36C-11CF-ADBC-00AA00A80033), <br>        helpstring("IConsole Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IConsole : IUnknown <br>    { <br>        [helpstring("Sets IConsoles header interface")] <br>        HRESULT SetHeader([in] LPHEADERCTRL pHeader); <br> <br>        [helpstring("Sets IConsoles toolbar interface")] <br>        HRESULT SetToolbar([in] LPTOOLBAR pToolbar); <br> <br>        [helpstring("Queries IConsoles user provided IUnknown")] <br>        HRESULT QueryResultView([out] LPUNKNOWN* pUnknown); <br> <br>        [helpstring("Queries the IConsole provided image list for the scope pane.")] <br>        HRESULT QueryScopeImageList([out] LPIMAGELIST* ppImageList); <br> <br>        [helpstring("Queries the IConsole provided image list for the result pane.")] <br>        HRESULT QueryResultImageList([out] LPIMAGELIST* ppImageList); <br> <br>        [helpstring("Generates a notification to update view(s) because of content change")] <br>        HRESULT UpdateAllViews([in] LPDATAOBJECT lpDataObject,  <br>                               [in] long data,  <br>                               [in] long hint); <br>         <br>        [helpstring("Displays a message box")] <br>        HRESULT MessageBox([in] LPCWSTR lpszText, [in] LPCWSTR lpszTitle, <br>                           [in] UINT fuStyle, [out] int* piRetval); <br> <br>        [helpstring("Query for the IConsoleVerb.")] <br>        HRESULT QueryConsoleVerb([out] LPCONSOLEVERB * ppConsoleVerb); <br>         <br>        [helpstring("Selects the given scope item.")] <br>        HRESULT SelectScopeItem([in] HSCOPEITEM hScopeItem); <br>         <br>        [helpstring("Returns handle to the main frame window.")] <br>        HRESULT GetMainWindow([out] HWND* phwnd); <br>         <br>        [helpstring("Returns handle to the main frame window.")] <br>        HRESULT NewWindow([in] HSCOPEITEM hScopeItem, [in] unsigned long lOptions); <br> <br>    }; <br> <br> <br> <br>    [ <br>        object, <br>        uuid(43136EB3-D36C-11CF-ADBC-00AA00A80033), <br>        helpstring("INodeInit Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IHeaderCtrl : IUnknown <br>    { <br>        const int AUTO_WIDTH = -1;  // Column width is determined by the string length + padding <br> <br>        [helpstring("Add a column to a Default Result view")] <br>        HRESULT InsertColumn([in] int nCol, [in,] LPCWSTR title, [in] int nFormat, [in] int nWidth); <br> <br>        [helpstring("Remove a column to a Default Result view")] <br>        HRESULT DeleteColumn([in] int nCol); <br> <br>        [helpstring("Set a columns text")] <br>        HRESULT SetColumnText([in] int nCol, [in] LPCWSTR title); <br> <br>        [helpstring("Gets a columns text")] <br>        HRESULT GetColumnText([in] int nCol, [out] LPOLESTR* pText); <br> <br>        [helpstring("Set a columns width")] <br>        HRESULT SetColumnWidth([in] int nCol, [in] int nWidth); <br> <br>        [helpstring("Gets a columns width")] <br>        HRESULT GetColumnWidth([in] int nCol, [out] int* pWidth); <br>    }; <br> <br>enum <br>{ <br>/////////////////////////////////////////////////////////////////////////////// <br>// The following bits in insertion point / submenu IDs are handled specially: <br>// <br>// CCM_INSERTIONPOINTID_MASK_SPECIAL: <br>//   Insertion points and submenus whose IDs contain any bit in <br>//   CCM_INSERTIONPOINTID_MASK_SPECIAL have special behavior.  Snap-Ins may use <br>//   the other bits as they see fit. <br>// CCM_INSERTIONPOINTID_MASK_SHARED: <br>//   Insertion points and submenus whose IDs contain CCM_INSERTIONPOINTID_MASK_SHARED <br>//   are shared between the creator of the context menu, the primary extension and <br>//   the third-party extension.  Any of these entities adding items to a shared <br>//   insertion point or submenu, add them to the same insertion point or submenu. <br>//   Only IContextMenuProvider may create insertion points or submenus with this bit <br>//   set, unless CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY is also set, in which case <br>//   only the primary extension may create them. <br>// CCM_INSERTIONPOINT_CREATE_PRIMARY: <br>//   Only the system may add insertion points or submenus for which CCM_INSERTIONPOINT_SHARED <br>//   is set and this bit is not set.  Only the primary extension may add insertion points <br>//   or submenus for which both bits are set.  This prevents insertion point ID conflicts <br>//   between insertion points and submenus created by IContextMenuProvider and those <br>//   created by the primary extension. <br>// CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY: <br>//   If CCM_INSERTIONPOINT_SHARED is set and this bit is not set, then <br>//   the primary extension may not add to this insertion point or submenu. <br>// CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY: <br>//   If CCM_INSERTIONPOINT_SHARED is set and this bit is not set, then <br>//   the third-party extensions may not add to this insertion point or submenu. <br>// CCM_INSERTIONPOINTID_MASK_RESERVED: <br>//   Insertion points and submenus may not be added with any of these bits set. <br>// CCM_INSERTIONPOINTID_MASK_FLAGINDEX: <br>//   This mask extracts the the index field from system insertion point IDs. <br>//   The index gives the bit position of the associated insertion allowed flag. <br>    <br>    CCM_INSERTIONPOINTID_MASK_SPECIAL        = 0xFFFF0000, <br>    CCM_INSERTIONPOINTID_MASK_SHARED         = 0x80000000, <br>    CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY = 0x40000000, <br>    CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY    = 0x20000000, <br>    CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY   = 0x10000000, <br>    CCM_INSERTIONPOINTID_MASK_RESERVED       = 0x0FFF0000, <br>    CCM_INSERTIONPOINTID_MASK_FLAGINDEX      = 0x0000001F, <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Use these InsertionPointIDs to add items at the predefined insertion points: <br>// <br>// 0 <br>//   This is interpreted the same as CCM_INSERTIONPOINTID_ROOT_MENU (see below). <br>// CCM_INSERTIONPOINTID_PRIMARY_TOP: <br>//   The primary extension may use this insertion point to add items to the top of <br>//   the main context menu. <br>// CCM_INSERTIONPOINTID_PRIMARY_NEW: <br>//   The primary extension may use this insertion point to add items to the top of <br>//   the Create New submenu. <br>// CCM_INSERTIONPOINTID_PRIMARY_TASK: <br>//   The primary extension may use this insertion point to add items to the top of <br>//   the Task submenu. <br>// CCM_INSERTIONPOINTID_3RDPARTY_NEW: <br>//   Third-party extensions may use this insertion point to add items to the bottom of <br>//   the Create New submenu. <br>// CCM_INSERTIONPOINTID_3RDPARTY_TASK: </code></pre>
<p>
</p>
<pre><code>//   Third-party extensions may use this insertion point to add items to the bottom of <br>//   the Task submenu. <br>// CCM_INSERTIONPOINTID_ROOT_MENU: <br>//   IContextMenuProvider may use this insertion point to add items to the root menu. <br>//   Neither primary extensions nor third-party extension may add items to the root <br>//   menu except through insertion points added by IContextMenuProvider. <br>// <br>    CCM_INSERTIONPOINTID_PRIMARY_TOP   = 0xA0000000, // SHARED and ADD_PRIMARY <br>    CCM_INSERTIONPOINTID_PRIMARY_NEW   = 0xA0000001, // SHARED and ADD_PRIMARY <br>    CCM_INSERTIONPOINTID_PRIMARY_TASK  = 0xA0000002, // SHARED and ADD_PRIMARY <br>    CCM_INSERTIONPOINTID_PRIMARY_VIEW  = 0xA0000003, // SHARED and ADD_PRIMARY <br>    CCM_INSERTIONPOINTID_3RDPARTY_NEW  = 0x90000001, // SHARED and ADD_3RDPARTY <br>    CCM_INSERTIONPOINTID_3RDPARTY_TASK = 0x90000002, // SHARED and ADD_3RDPARTY <br>    CCM_INSERTIONPOINTID_ROOT_MENU     = 0x80000000  // SHARED <br>}; <br> <br>// <br>// Macro to derive an insertion allowed flag from an system insertion point ID <br>// <br>#define INSERTALLOWED_FLAG(insertionID) \ <br>         (1L &lt;&lt; (insertionID &amp; CCM_INSERTIONPOINTID_MASK_FLAGINDEX))  <br>enum <br>{ <br>/////////////////////////////////////////////////////////////////////////////////////   <br>// These flags give permission to insert menu items at the CCM_INSERTIONPOINTID_xxx <br>// insertion points define above. The bit position of each flag is derived from the <br>// index portion of the corresponding insertion point ID. They are passed to the <br>// snap-in's AddMenuItems method.   <br> <br>   CCM_INSERTIONALLOWED_TOP  = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_TOP), <br>   CCM_INSERTIONALLOWED_NEW  = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_NEW), <br>   CCM_INSERTIONALLOWED_TASK = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_TASK), <br>   CCM_INSERTIONALLOWED_VIEW = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_VIEW) <br>}; <br> <br> <br>enum <br>{ <br>/////////////////////////////////////////////////////////////////////////////// <br>// The following bits in menu command IDs are handled specially: <br>// <br>// CCM_COMMANDID_MASK_RESERVED: <br>//   Items other than insertion points and submenus may not be added with any of <br>//   these bits set. <br>//  <br>    CCM_COMMANDID_MASK_RESERVED       = 0xFFFF0000 <br>}; <br> <br>enum <br>{ <br>/////////////////////////////////////////////////////////////////////////////// <br>// The following flags may be passed via AddMenuItem parameter fSpecialFlags: <br>// <br>// CCM_SPECIAL_SEPARATOR <br>//   Ignore all other parameters except lInsertionPointID.  Add a separator to the <br>//   end of the menu or the specified insertion point, except that <br>//   CCM_SPECIAL_SEPARATOR will never add a separator as the first or last item <br>//   in a menu/submenu, and if two or more consecutive CCM_SPECIAL_SEPARATORs are added, <br>//   only one appears in the menu.  Only IContextMenuProvider is permitted to add <br>//   separators, either special or otherwise, to menus created by IContextMenuProvider. <br>// <br>    CCM_SPECIAL_SEPARATOR         = 0x0001, <br>// <br>// CCM_SPECIAL_SUBMENU <br>//   If this submenu is empty, then it will be grayed and disabled. <br>//   This is only valid for MF_POPUP items. <br>// <br>    CCM_SPECIAL_SUBMENU           = 0x0002, <br>// <br>// CCM_SPECIAL_DEFAULT_ITEM <br>//   This should be the default menu item.  If more than one menu item specifies this flag, <br>//   the last one in each submenu takes precedence. <br>// <br>    CCM_SPECIAL_DEFAULT_ITEM      = 0x0004, <br>// <br>// CCM_SPECIAL_INSERTION_POINT <br>//   Ignore all other parameters except lCommandID and lInsertionPointID.  This creates <br>//   a new "insertion point" at the end of the insertion point or submenu identified by <br>//   lInsertionPointID (0 is the end of the main menu).  Subsequent calls may use <br>//   the lCommandID from this call as their lInsertionPointID, and insert their own <br>//   menu items, submenus or insertion points at this point in this menu. <br>// <br>    CCM_SPECIAL_INSERTION_POINT   = 0x0008, <br>// <br>// CCM_SPECIAL_TESTONLY <br>//   Perform the normal validation of the menu item parameters and return the appropriate <br>//   result code, but do not actually add the menu item.  <br>// <br>    CCM_SPECIAL_TESTONLY          = 0x0010      <br>}; <br> <br> <br>    [ <br>        object, <br>        uuid(43136EB7-D36C-11CF-ADBC-00AA00A80033), <br>        helpstring("IContextMenuCallback Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IContextMenuCallback : IUnknown <br>    { <br>        // returns S_OK if the item was added <br>        // returns E_INVALIDARG if given a NULL pointer <br>        // returns E_INVALIDARG if an item already exists with this lCommandID <br>        // returns E_INVALIDARG if insertion point ID could not be found <br>        // returns E_INVALIDARG if command ID or insertion point ID is invalid <br>        // returns E_INVALIDARG if fFlags contains MF_OWNERDRAW or MF_BITMAP <br>        // returns E_INVALIDARG if an extension attempts to add an item where <br>        //   fFlags contains MF_SEPARATOR or fSpecialFlags contains CCM_SPECIAL_SEPARATOR <br>        //   except in submenus created by extensions <br>        // otherwise an unexpected error occurred <br>        [helpstring("Adds one item to context menu")] <br>        HRESULT AddItem([in] CONTEXTMENUITEM* pItem); <br>    }; <br> <br> <br> <br>    [ <br>        object, <br>        uuid(43136EB6-D36C-11CF-ADBC-00AA00A80033), <br>        object, <br>        helpstring("IContextMenuProvider Interface"), <br>        pointer_default(unique) <br>    ] <br>    // <br>    // Note that this derives from IContextMenuCallback <br>    // <br>    interface IContextMenuProvider : IContextMenuCallback <br>    { <br>        // Methods <br>        // returns S_OK unless an unexpected error occurs <br>        [helpstring("Clear context menu")] <br>        HRESULT EmptyMenuList(); <br> <br>        // returns S_OK if successful <br>        // returns E_INVALIDARG on NULL parameter <br>        // passes through return code from IExtendContextMenu::AddMenuItems <br>        //   or from CoCreateInstance <br>        // otherwise an unexpected error occurred <br>        [helpstring("Allow the primary extension to add to bottom of context menu")] <br>        HRESULT AddPrimaryExtensionItems([in] LPUNKNOWN piExtension, [in] LPDATAOBJECT piDataObject); <br> <br>        // returns S_OK if successful <br>        // returns E_INVALIDARG on NULL parameter <br>        // returns S_FALSE if context menu has already been extended <br>        // passes through return code from IExtendContextMenu::AddMenuItems <br>        //   or from CLSIDToString or CoCreateInstance <br>        // otherwise an unexpected error occurred <br>        [helpstring("Allow third-party extensions to add to bottom of context menu")] <br>        HRESULT AddThirdPartyExtensionItems([in] LPDATAOBJECT piDataObject); <br> <br>        // returns S_OK unless an unexpected error occurs <br>        [helpstring("Display context menu")] <br>        HRESULT ShowContextMenu([in] HWND hwndParent, [in] long xPos, [in] long yPos, [out,retval] long* plSelected); <br>    }; <br> <br> <br>    [ <br>        object, <br>        uuid(4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0), <br>        helpstring("IExtendContextMenu Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IExtendContextMenu : IUnknown <br>    { <br>        [helpstring("Extension may add context menu items via callback interface")] <br>        HRESULT AddMenuItems([in] LPDATAOBJECT piDataObject, <br>                             [in] LPCONTEXTMENUCALLBACK piCallback, <br>                             [in,out] long *pInsertionAllowed); <br> <br>        [helpstring("Extension context menu item was selected")] <br>        HRESULT Command([in] long lCommandID, [in] LPDATAOBJECT piDataObject); <br>    }; <br> <br>    [ <br>        object, <br>        uuid(43136EB8-D36C-11CF-ADBC-00AA00A80033), <br>        helpstring("IImageList Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IImageList : IUnknown <br>    { <br>        [helpstring("Sets an Icon in the image list, creates it if it is not there.")] <br>        HRESULT ImageListSetIcon([in] long* pIcon, [in] long nLoc); <br> <br>        [helpstring("Sets a strip in the image list, starting at nLoc using a pair of bitmaps.")] <br>        HRESULT ImageListSetStrip([in] long* pBMapSm, <br>            [in] long* pBMapLg,[in] long nStartLoc, [in] COLORREF cMask); <br>    }; <br> <br>     <br> <br>    [ <br>        object, <br>        uuid(31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6), <br>        helpstring("IResultData Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IResultData : IUnknown <br>    { <br>        [helpstring("Allows the snap-in to insert a single item.")] <br>        HRESULT InsertItem([in,out] LPRESULTDATAITEM item); <br> <br>        [helpstring("Allows the snap-in to delete a single item.")] <br>        HRESULT DeleteItem([in] HRESULTITEM itemID, [in] int nCol); <br> <br>        [helpstring("Allows the snap-in to find an item/subitem based on its user inserted lParam.")] <br>        HRESULT FindItemByLParam([in] LPARAM lParam, [out] HRESULTITEM *pItemID); <br> <br>        [helpstring("Allows the snap-in to delete all the items.")] <br>        HRESULT DeleteAllRsltItems(); <br> <br>        [helpstring("Allows the snap-in to set a single item.")] <br>        HRESULT SetItem([in] LPRESULTDATAITEM item); <br> <br>        [helpstring("Allows the snap-in to get a single item.")] <br>        HRESULT GetItem([in,out] LPRESULTDATAITEM item); <br> <br>        [helpstring("Returns the lParam of the first item, which matches the given state.")] <br>        HRESULT GetNextItem([in,out] LPRESULTDATAITEM item); <br>       <br>        [helpstring("Allows the snap-in to modify the state of an item.")] <br>        HRESULT ModifyItemState([in] int nIndex, [in] HRESULTITEM itemID, <br>                                [in] UINT uAdd, [in] UINT uRemove); <br> <br>        [helpstring("Allows the snap-in to set the result view style.")] <br>        HRESULT ModifyViewStyle([in] MMC_RESULT_VIEW_STYLE add,  <br>                             [in] MMC_RESULT_VIEW_STYLE remove); <br> <br>        [helpstring("Allows the snap-in to set the result view mode.")] <br>        HRESULT SetViewMode([in] long lViewMode); <br> <br>        [helpstring("Allows the snap-in to get the result view mode.")] <br>        HRESULT GetViewMode([out] long* lViewMode); <br> <br>        [helpstring("Allows the snap-in to update a single item.")] <br>        HRESULT UpdateItem([in] HRESULTITEM itemID); <br> <br>        [helpstring("Sort all items in result pane")] <br>        HRESULT Sort([in] int nColumn, [in] DWORD dwSortOptions, [in] long lUserParam); <br> <br>        [helpstring("Set the description bar text for the result view")] <br>        HRESULT SetDescBarText([in] LPOLESTR DescText); <br> <br>        [helpstring("Set number of items in result pane list")] <br>        HRESULT SetItemCount([in] int nItemCount, [in] DWORD dwOptions); <br>         <br>    }; <br> <br> <br>    [ <br>        object, <br>        uuid(9757abb8-1b32-11d1-a7ce-00c04fd8d565), <br>        helpstring("IQuickFilter Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IQuickFilter : IUnknown <br>    { <br>        [helpstring("Sets the time out for the quick filter")] <br>        HRESULT SetChangeTimeOut([in] unsigned long uTimeout); <br>         <br>        [helpstring("Sets the quick filter")] <br>        HRESULT SetQuickFilter([in] UINT nColumn, [in] long lFilter); <br>         <br>        [helpstring("Gets the quick filter")] <br>        HRESULT GetQuickFilter([in] UINT nColumn, [out] long* plFilter); <br>    }; <br>     <br> <br> <br>    [ <br>        object, <br>        uuid(BEDEB620-F24D-11cf-8AFC-00AA003CA9F6), <br>        helpstring("IConsoleNameSpace Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IConsoleNameSpace : IUnknown <br>    { <br>        import "oaidl.idl"; <br>        [helpstring("Allows the snap-in to insert a single item into the scope view.")] <br>        HRESULT InsertItem([in,out] LPSCOPEDATAITEM  item); <br> <br>        [helpstring("Allows the snap-in to delete a single item from the scope view.")] <br>        HRESULT DeleteItem([in] HSCOPEITEM hItem, [in] long fDeleteThis); <br> <br>        [helpstring("Allows the snap-in to set a single scope view item.")] <br>        HRESULT SetItem([in] LPSCOPEDATAITEM item); <br> <br>        [helpstring("Allows the snap-in to get a single scope view item.")] <br>        HRESULT GetItem([in,out] LPSCOPEDATAITEM item); <br>         <br>        [helpstring("The handle of the child item if successful, otherwise NULL.")] <br>        HRESULT GetChildItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemChild, <br>                             [out] long* plCookie); <br>         <br>        [helpstring("The handle of the next item if successful, otherwise NULL.")] <br>        HRESULT GetNextItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemNext, <br>                            [out] long* plCookie); <br>                             <br>        [helpstring("The handle of the parent item if successful, otherwise NULL.")] <br>        HRESULT GetParentItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemParent, <br>                              [out] long* plCookie); <br>    }; <br> <br>struct _PSP; <br>typedef struct _PSP * HPROPSHEETPAGE; <br> <br>    [ <br>        local, <br>        object, <br>        uuid(85DE64DD-EF21-11cf-A285-00C04FD8DBE6), <br>        helpstring("IPropertySheetCallback Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IPropertySheetCallback : IUnknown <br>    { <br> <br>        [helpstring("Snap-in uses this to add a page to a property sheet")] <br>        HRESULT AddPage([in] HPROPSHEETPAGE hPage); <br> <br>        [helpstring("Snap-in uses this to remove a page from a property sheet")] <br>        HRESULT RemovePage([in] HPROPSHEETPAGE  hPage); <br>    }; <br> <br>    [ <br>        object, <br>        uuid(85DE64DE-EF21-11cf-A285-00C04FD8DBE6), <br>        helpstring("IPropertySheetProvider Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IPropertySheetProvider : IUnknown <br>    { <br>        [helpstring("Creates a property sheet frame")] <br>        HRESULT CreatePropertySheet([in] LPCWSTR title, [in] boolean type,  <br>                                    [in] long cookie, [in] LPDATAOBJECT pIDataObjectm, <br>                                    [in] DWORD dwOptions); <br> <br>        [helpstring("Determine if the property sheet exist")] <br>        HRESULT FindPropertySheet([in] long cookie, [in] LPCOMPONENT lpComponent, [in] LPDATAOBJECT lpDataObject); <br> <br>        [helpstring("Collects the pages from the primary snap-in")] <br>        HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane); <br> <br>        [helpstring("Collects the pages from the extension snap-in(s)")] <br>        HRESULT AddExtensionPages(); <br> <br>        [helpstring("Shows a property sheet frame parented to the HWND passed in")] <br>        HRESULT Show([in] long window, [in] int page); <br>    }; <br> <br>    [ <br>        object, <br>        uuid(85DE64DC-EF21-11cf-A285-00C04FD8DBE6), <br>        helpstring("IExtendPropertySheet Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IExtendPropertySheet : IUnknown <br>    { <br>        [helpstring("Interface implemented by the snap-in to add pages to a sheet")] <br>        // handle - This handle must be saved in the property page object  <br>        //          to notify the parent of changes in property using API  <br>        //          MMCPropertyChangeNotify. The API MMCFreeNotifyHandle <br>        //          should be called just before the property page is <br>        //          destroyed to delete the handle. <br>        HRESULT CreatePropertyPages([in] LPPROPERTYSHEETCALLBACK lpProvider, <br>                                    [in] long handle,  <br>                                    [in] LPDATAOBJECT lpIDataObject); <br> <br>        [helpstring("Interface implemented by the snap-in to determine if this object needs pages")] <br>        HRESULT QueryPagesFor([in] LPDATAOBJECT lpDataObject); <br>    }; <br> <br> <br> <br>    [ <br>        object, <br>        uuid(69FB811E-6C1C-11D0-A2CB-00C04FD909DD), <br>        helpstring("Control bar to hold toolbar and other controls"), <br>        pointer_default(unique) <br>    ] <br>    interface IControlbar : IUnknown <br>    { <br>        [helpstring("Create and return the control requested")] <br>        HRESULT Create([in] MMC_CONTROL_TYPE nType,  <br>                       [in] LPEXTENDCONTROLBAR pExtendControlbar, <br>                       [out] LPUNKNOWN* ppUnknown); <br> <br>        [helpstring("Associated the control to the control bar")] <br>        HRESULT Attach([in] MMC_CONTROL_TYPE nType, [in] LPUNKNOWN  lpUnknown); <br> <br>        [helpstring("Break the association between the control and the control bar")] <br>        HRESULT Detach([in] LPUNKNOWN lpUnknown); <br>    }; <br> <br>    [ <br>        object, <br>        uuid(49506520-6F40-11D0-A98B-00C04FD8D565), <br>        helpstring("IExtendControlbar Interface"), <br>        pointer_default(unique) <br>    ] <br>    interface IExtendControlbar : IUnknown <br>    { <br>        [helpstring("Extension may add toolbars via callback interface")] <br>        HRESULT SetControlbar([in] LPCONTROLBAR pControlbar); <br>         <br>        [helpstring("User actions")] <br>        HRESULT ControlbarNotify([in] MMC_NOTIFY_TYPE event,  <br>                                 [in] long arg, [in] long param); <br>    }; <br> <br> <br>    [ <br>        object, <br>        uuid(43136EB9-D36C-11CF-ADBC-00AA00A80033), <br>        pointer_default(unique) <br>    ] <br>    interface IToolbar : IUnknown <br>    { <br>        [helpstring("Add and image to the toolbar")] <br>        HRESULT AddBitmap([in] int nImages, [in] HBITMAP hbmp, [in] int cxSize, [in] int cySize, [in] COLORREF crMask ); <br>     <br>        [helpstring("Add an array of buttons to the toolbar")] <br>        HRESULT AddButtons([in] int nButtons, [in] LPMMCBUTTON lpButtons); <br> <br>        [helpstring("Add a single button to the toolbar at position nIndex")] <br>        HRESULT InsertButton([in] int nIndex, [in] LPMMCBUTTON lpButton);  <br> <br>        [helpstring("Remove a button at the index")] <br>        HRESULT DeleteButton([in] int nIndex); <br>     <br>        [helpstring("Get an attribute of a button")] <br>        HRESULT GetButtonState([in] int idCommand, [in] MMC_BUTTON_STATE nState, [out] BOOL* pState); <br> <br>        [helpstring("Set an attribute of a button")] <br>        HRESULT SetButtonState([in] int idCommand, [in] MMC_BUTTON_STATE nState, [in] BOOL bState); <br>    }; <br> <br> <br>    [ <br>        object, <br>        uuid(E49F7A60-74AF-11D0-A286-00C04FD8FE93), <br>        pointer_default(unique) <br>    ] <br>    interface IConsoleVerb : IUnknown <br>    { <br>        [helpstring("Get verb state")] <br>        HRESULT GetVerbState([in] MMC_CONSOLE_VERB eCmdID, [in] MMC_BUTTON_STATE nState, [out] BOOL* pState); <br> <br>        [helpstring("Set verb state")] <br>        HRESULT SetVerbState([in] MMC_CONSOLE_VERB eCmdID, [in] MMC_BUTTON_STATE nState, [in] BOOL bState); <br>                           <br>        [helpstring("Set default verb")] <br>        HRESULT SetDefaultVerb([in] MMC_CONSOLE_VERB eCmdID); <br>         <br>        [helpstring("Get default verb")] <br>        HRESULT GetDefaultVerb([out] MMC_CONSOLE_VERB* peCmdID); <br>    }; <br> <br> <br>    [ <br>        object, <br>        uuid(1245208C-A151-11D0-A7D7-00C04FD909DD), <br>        pointer_default(unique) <br>    ] <br>    interface ISnapinAbout : IUnknown <br>    { <br>        [helpstring("Text for the snap-in description box")] <br>        HRESULT GetSnapinDescription([  out] LPOLESTR* lpDescription); <br> <br>        [helpstring("Provider name")] <br>        HRESULT GetProvider([out] LPOLESTR* lpName); <br> <br>        [helpstring("Version number for the snap-in")] <br>        HRESULT GetSnapinVersion([out] LPOLESTR* lpVersion); <br> <br>        [helpstring("Main icon for about box")] <br>        HRESULT GetSnapinImage([out] HICON* hAppIcon); <br> <br>        [helpstring("Static folder images for scope and result panes")] <br>        HRESULT GetStaticFolderImage([out] HBITMAP* hSmallImage,  <br>                                     [out] HBITMAP* hSmallImageOpen,  <br>                                     [out] HBITMAP* hLargeImage,  <br>                                     [out] COLORREF* cMask); <br>    }; <br> <br> <br>    [ <br>        object, <br>        uuid(951ED750-D080-11d0-B197-000000000000), <br>        pointer_default(unique) <br>    ] <br>    interface IMenuButton : IUnknown <br>    { <br>        [helpstring("Adds a button")] <br>        HRESULT AddButton([in] int idCommand,[in] LPOLESTR lpButtonText, <br>                                             [in] LPOLESTR lpTooltipText); <br> <br>        [helpstring("Set an attributes of a button")] <br>        HRESULT SetButton([in] int idCommand,[in] LPOLESTR lpButtonText, <br>                                             [in] LPOLESTR lpTooltipText); <br> <br>        [helpstring("Set the state of a button")] <br>        HRESULT SetButtonState([in] int idCommand,  <br>                               [in] MMC_BUTTON_STATE nState,  <br>                               [in] BOOL bState); <br>    }; <br> <br> <br> <br>    [ <br>        object, <br>        uuid(A6B15ACE-DF59-11D0-A7DD-00C04FD909DD), <br>        pointer_default(unique) <br>    ] <br>    interface ISnapinHelp : IUnknown <br>    { <br>        [helpstring("Get the compiled help file (.chm) from a snap-in to merge")] <br>        HRESULT GetHelpTopic([out] LPOLESTR* lpCompiledHelpFile); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
