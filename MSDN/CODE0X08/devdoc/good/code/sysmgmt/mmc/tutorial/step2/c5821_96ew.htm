<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISK.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5828"></a>DISK.CPP</h2>
<pre><code>///////////////////////////////////////////////////////////////////////////// <br>// disk.cpp : Implementation of DLL Exports. <br>// <br>// This is a part of the MMC SDK. <br>// Copyright (C) 1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// MMC SDK Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// MMC Library product. <br>// <br> <br>// Note: Proxy/Stub Information <br>//To build a separate proxy/stub DLL,  <br>//run nmake -f diskps.mk in the project directory. <br> <br>#include "stdafx.h" <br>#include "resource.h" <br>#include "initguid.h" <br>#include "disk.h" <br> <br>#include "disk_i.c" <br>#include "globals.h" <br>#include "compdata.h" <br> <br> <br>CComModule _Module; <br> <br>BEGIN_OBJECT_MAP(ObjectMap) <br>OBJECT_ENTRY(CLSID_ComponentData, CComponentData) <br>END_OBJECT_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// DLL Entry Point <br> <br>extern "C" <br>BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) <br>{ <br>  if ( DLL_PROCESS_ATTACH == dwReason ) <br>  { <br>    g_hinst = hInstance;               // Store global instance handle <br>_Module.Init(ObjectMap, hInstance); <br>DisableThreadLibraryCalls(hInstance); <br>  } <br>  else if ( DLL_PROCESS_DETACH == dwReason ) <br>_Module.Term(); <br> <br>  return TRUE;                         // OK <br> <br>} // end DllMain() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Used to determine whether the DLL can be unloaded by OLE <br> <br>STDAPI DllCanUnloadNow(void) <br>{ <br>  return (_Module.GetLockCount()==0) ? S_OK : S_FALSE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Returns a class factory to create an object of the requested type <br> <br>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) <br>{ <br>  return _Module.GetClassObject(rclsid, riid, ppv); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// DllRegisterServer - Adds entries to the system registry <br>// If we don't get these things into the registry, then MMC will not see us <br>// and we will not appear in the "Add Snapin" dialog. <br>// We error check every return value in both DllRegisterServer() and <br>// DllUnRegisterServer().  You may want to do this only in your debug <br>// version to reduce code size, at the expense of making troubleshooting  <br>// more difficult <br>// <br>STDAPI DllRegisterServer(void) <br>{ <br>  HKEY hMmcParentKey  = NULL; <br>  HKEY hDiskParentKey = NULL; <br>  HKEY hStandAloneKey = NULL; <br>  HKEY hNodeTypesKey  = NULL; <br>  HKEY hTempNodeKey   = NULL; <br>  LONG nErr           = 0; <br> <br>  //DebugBreak();                  // Uncomment this to step through registration <br> <br>  // Open the MMC Parent key <br>  nErr = RegOpenKey( HKEY_LOCAL_MACHINE, <br>                 L"Software\\Microsoft\\MMC\\SnapIns", <br>         &amp;hMmcParentKey <br>       ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Open MMC Parent Key Failed" ); <br>   <br>  // Create the ID for our ICompnentData Interface <br>  // The ID was generated for us, because we used a Wizard to create the app. <br>  // Take the ID for IComponentData in the IDL file. <br>  // <br>  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <br>  // Make sure you change this if you use this code as a starting point! <br>  // Change other IDs as well below! <br>  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <br>  nErr = RegCreateKey( hMmcParentKey, <br>                     L"{CF8CC7EF-0CFE-11D1-8F07-000000000000}", <br>               &amp;hDiskParentKey <br>               ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Open Disk Parent Key Failed" ); <br> <br>  nErr = RegSetValueEx( hDiskParentKey, <br>                    L"NameString", <br>            0, <br>        REG_SZ, <br>        (LPBYTE)L"Disk Sample", <br>        sizeof(L"Disk Sample") <br>          ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Set NameString Failed" ); <br> <br>  nErr = RegSetValueEx( hDiskParentKey, <br>                    L"NodeType", <br>        0, <br>        REG_SZ, <br>        (LPBYTE)L"{570F713A-0F57-11D1-A194-00C04FC3092F}", <br>        sizeof(L"{570F713A-0F57-11D1-A194-00C04FC3092F}") <br>          ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Set NodeType Failed" ); <br> <br> <br>  // We are a stand alone snapin, so set the key for this <br>  nErr = RegCreateKey( hDiskParentKey, L"StandAlone", &amp;hStandAloneKey); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Create StandAlone Key Failed" ); <br> <br>  // StandAlone has no children, so close it <br>  nErr = RegCloseKey( hStandAloneKey );               <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close StandAlone Failed" ); <br> <br>  // Set the node types that appear in our snapin <br>  nErr = RegCreateKey( hDiskParentKey, L"NodeTypes", &amp;hNodeTypesKey ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Create NodeTypes Key Failed" ); <br> <br>  // Here is our root node.  Used uuidgen to get it <br>  nErr = RegCreateKey( hNodeTypesKey, <br>                   L"{570F713A-0F57-11D1-A194-00C04FC3092F}", <br>       &amp;hTempNodeKey <br>         ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Create RootNode Key Failed" ); <br> <br>  nErr = RegSetValueEx( hTempNodeKey, <br>                    NULL, <br>            0, <br>        REG_SZ, <br>        (LPBYTE)L"Root Node", <br>        sizeof(L"Root Node") <br>          ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Set Root Node String Failed" ); <br> <br>  nErr = RegCloseKey( hTempNodeKey );    // Close it so we can reuse handle <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close RootNode Failed" ); <br> <br>  // Here is our child node under the root node. Used uuidgen to get it <br>  nErr = RegCreateKey( hNodeTypesKey, <br>                   L"{50C4FBDC-1F02-11D1-A1AE-00C04FC3092F}", <br>       &amp;hTempNodeKey <br>         ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Create Child Node Key Failed" ); <br> <br>  nErr = RegSetValueEx( hTempNodeKey, <br>                    NULL, <br>        0, <br>        REG_SZ, <br>        (LPBYTE)L"Child Under Root Node", <br>        sizeof(L"Child Under Root Node") <br>          ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Set Child Node String Failed" ); <br> <br>  nErr = RegCloseKey( hTempNodeKey ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close Child Node Key Failed" ); <br> <br>  nErr = RegCloseKey( hNodeTypesKey  ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close Node Types Key Failed" ); <br> <br>  nErr = RegCloseKey( hDiskParentKey ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close Disk Parent Key Failed" ); <br> <br>  nErr = RegCloseKey( hMmcParentKey  ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close MMC Parent Key Failed" ); <br> <br>  // Registers object, typelib and all interfaces in typelib <br>  return _Module.RegisterServer(TRUE); <br> <br>} // end DllRegisterServer() <br> <br>//--------------------------------------------------------------------------- <br>// DllUnregisterServer:  Since we are a good citizen, delete all the keys <br>//                       we added to the MMC keys in the registry as well as <br>//                       the normal unregistering of our com objects. <br>// <br>STDAPI DllUnregisterServer(void) <br>{ <br>  HKEY hMmcParentKey  = NULL;          // MMC parent key <br>  HKEY hDiskParentKey = NULL;          // Our Snap-In key  - has children <br>  HKEY hNodeTypesKey  = NULL;          // Our NodeType key - has children <br>  LONG nErr           = 0; <br> <br>  // DebugBreak();                       // Uncomment this to step through UnRegister <br> <br>  // Open the MMC parent key <br>  nErr = RegOpenKey( HKEY_LOCAL_MACHINE, <br>                     L"Software\\Microsoft\\MMC\\SnapIns", <br>                     &amp;hMmcParentKey <br>                   ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Open MMC Parent Key Failed"  );  <br> <br>  // Open our Parent key <br>  nErr = RegOpenKey( hMmcParentKey, <br>                     L"{CF8CC7EF-0CFE-11D1-8F07-000000000000}", <br>                     &amp;hDiskParentKey <br>                   ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Open Disk Parent Key Failed" ); <br>   <br>  // Now open the NodeTypes key <br>  nErr = RegOpenKey( hDiskParentKey,       // Handle of parent key <br>                     L"NodeTypes",         // Name of key to open <br>                     &amp;hNodeTypesKey        // Handle to newly opened key <br>                   ); <br>  if( ERROR_SUCCESS != nErr ) <br>     DisplayError( GetLastError(), L"Open NodeTypes Key Failed"  ); <br> <br>  // Delete the root node key  <br>  nErr = RegDeleteKey( hNodeTypesKey, L"{570F713A-0F57-11D1-A194-00C04FC3092F}" );   <br>  if( ERROR_SUCCESS != nErr ) <br>     DisplayError( GetLastError(), L"Delete Root Node Key Failed"  ); <br> <br>  // Delete the child node key <br>  nErr = RegDeleteKey( hNodeTypesKey, L"{50C4FBDC-1F02-11D1-A1AE-00C04FC3092F}" );   <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Delete Child Node Key Failed"  ); <br> <br>  // Close the node type key so we can delete it <br>  nErr = RegCloseKey( hNodeTypesKey );  <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close NodeTypes Key failed"  ); <br> <br>  // Delete the NodeTypes key <br>  nErr = RegDeleteKey( hDiskParentKey, L"NodeTypes" );   <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Delete NodeTypes Key failed"  ); <br>   <br>  // StandAlone key has no children so we can delete it now <br>  nErr = RegDeleteKey( hDiskParentKey, L"StandAlone" ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Delete StandAlone Key Failed"  );  <br>   <br>  // Close our Parent Key <br>  nErr = RegCloseKey( hDiskParentKey ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close Disk Parent Key Failed"  );  <br> <br>  // Now we can delete our Snap-In key since the children are gone <br>  nErr = RegDeleteKey( hMmcParentKey, L"{CF8CC7EF-0CFE-11D1-8F07-000000000000}" );   <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Delete Disk Parent Key Failed"  );  <br> <br>  nErr = RegCloseKey( hMmcParentKey ); <br>  if( ERROR_SUCCESS != nErr ) <br>    DisplayError( GetLastError(), L"Close MMC Parent Key Failed"  );  <br> <br>  // UnRegisters object, typelib and all interfaces in typelib <br>  return _Module.UnregisterServer(); <br> <br>} // end DllUnregisterServer() <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
