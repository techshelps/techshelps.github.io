<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DATAOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5807"></a>DATAOBJ.CPP</h2>
<pre><code>///////////////////////////////////////////////////////////////////////////// <br>// dataobj.cpp : Implementation of IDataObject for data communication <br>// <br>// This is a part of the MMC SDK. <br>// Copyright (C) 1997 Microsoft Corporation <br>// All rights reserved. <br>// <br>// This source code is only intended as a supplement to the <br>// MMC SDK Reference and related <br>// electronic documentation provided with the library. <br>// See these sources for detailed information regarding the <br>// MMC Library product. <br>// <br> <br>#include "stdafx.h" <br>#include "disk.h" <br>#include "dataobj.h" <br> <br>                <br>// <br>// This is the minimum set of clipboard formats we must implement. <br>// MMC uses these to get necessary information from our snapin about <br>// our nodes. <br>// <br>UINT CDataObject::s_cfInternal    = 0; <br>UINT CDataObject::s_cfDisplayName = 0; <br>UINT CDataObject::s_cfNodeType    = 0; <br>UINT CDataObject::s_cfSnapinClsid = 0; <br> <br>// Generated with uuidgen. Each node must have a GUID associated with it. <br>// This one is for the main root node. <br>const GUID GUID_RootNode = /* 570f713a-0f57-11d1-a194-00c04fc3092f */ <br>{ <br>    0x570f713a, <br>    0x0f57, <br>    0x11d1, <br>    {0xa1, 0x94, 0x00, 0xc0, 0x4f, 0xc3, 0x09, 0x2f} <br>}; <br> <br>// Generated with uuidgen. Each node must have a GUID associated with it. <br>// This one is for the child under the main root node. <br>const GUID GUID_MainNode = { /* 50c4fbdc-1f02-11d1-a1ae-00c04fc3092f */ <br>    0x50c4fbdc, <br>    0x1f02, <br>    0x11d1, <br>    {0xa1, 0xae, 0x00, 0xc0, 0x4f, 0xc3, 0x09, 0x2f} <br>}; <br> <br> <br>#define CF_SNAPIN_INTERNAL L"MMC_SNAPIN_MACHINE_NAME" <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDataObject - This class is used to pass data back and forth with MMC. It <br>//               uses a standard interface, IDataObject to acomplish this. Refer <br>//               to OLE documentation for a description of clipboard formats and <br>//               the IdataObject interface. <br> <br>//============================================================================ <br>// <br>// Constructor and Destructor <br>//  <br> <br> <br>//---------------------------------------------------------------------------- <br>//  CDataObject::CDataObject <br>// <br>CDataObject::CDataObject() <br>{ <br> <br>  m_ulCookie = 0; <br>  m_Context  = CCT_UNINITIALIZED; <br>  m_Type     = COOKIE_IS_ROOT; <br> <br>  // These are the clipboard formats that we must supply at a minimum. <br>  // mmc.h actually defined these. We can make up our own to use for <br>  // other reasons. We don't need any others at this time. <br>  s_cfInternal    = RegisterClipboardFormat(CF_SNAPIN_INTERNAL); <br>  s_cfDisplayName = RegisterClipboardFormat(CCF_DISPLAY_NAME); <br>  s_cfNodeType    = RegisterClipboardFormat(CCF_NODETYPE); <br>  s_cfSnapinClsid = RegisterClipboardFormat(CCF_SNAPIN_CLASSID); <br> <br>} // end Constructor() <br> <br> <br> <br> <br>//--------------------------------------------------------------------------- <br>//  CDataObject::~CDataObject <br>// <br>CDataObject::~CDataObject() <br>{ <br>  if ( COOKIE_IS_STATUS == m_Type ) <br>  { <br>     _ASSERT(m_ulCookie); <br>  } <br>} // end Destructor() <br> <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IDataObject implementation <br>//  <br> <br>//--------------------------------------------------------------------------- <br>//  Fill the hGlobal in pmedium with the requested data <br>// <br>STDMETHODIMP  <br>CDataObject::GetDataHere <br>( <br>  FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure  <br>  STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure   <br>) <br>{ <br>  HRESULT hr = DV_E_FORMATETC;         // Unknown format <br>  const   CLIPFORMAT cf = pFormatEtc-&gt;cfFormat; <br>  IStream *pStream = NULL; <br> <br>  pMedium-&gt;pUnkForRelease = NULL;      // by OLE spec <br> <br>  do                                   // Write data to the stream based <br>  {                                    // of the clipformat <br>    hr = CreateStreamOnHGlobal( pMedium-&gt;hGlobal, FALSE, &amp;pStream ); <br>    if ( FAILED(hr) ) <br>      return hr;                       // Minimal error checking <br> <br>    if (cf == s_cfDisplayName) <br>    { <br>      hr = _WriteDisplayName( pStream ); <br>    } <br>    else if (cf == s_cfInternal) <br>    { <br>      hr = _WriteInternal( pStream ); <br>    } <br>    else if (cf == s_cfNodeType) <br>    { <br>      hr = _WriteNodeType( pStream ); <br>    } <br>    else if (cf == s_cfSnapinClsid) <br>    { <br>      hr = _WriteClsid( pStream ); <br>    } <br>  } while (0); <br> <br>  pStream-&gt;Release(); <br> <br>  return hr; <br> <br>} // end GetDataHere() <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//  Support methods <br>// <br> <br>//--------------------------------------------------------------------------- <br>//  Write the appropriate GUID to the stream <br>// <br>HRESULT <br>CDataObject::_WriteNodeType <br>( <br>  IStream* pStream           // [in] Stream we are writing to <br>) <br>{ <br>  const GUID *pGuid = NULL; <br>     <br>  switch (m_Type) <br>  { <br>    case COOKIE_IS_ROOT: <br>      pGuid = &amp;GUID_RootNode; <br>      break; <br> <br>    case COOKIE_IS_STATUS: <br>      pGuid = &amp;GUID_MainNode; <br>      break; <br> <br>    default: <br>     _ASSERT( FALSE ); <br>     return E_UNEXPECTED; <br>  } <br> <br>  return pStream-&gt;Write( (PVOID)pGuid, sizeof(GUID), NULL ); <br> <br>} // end _WriteNodeType() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Writes the display name to the stream <br>//  <br>HRESULT <br>CDataObject::_WriteDisplayName <br>( <br>  IStream* pStream           // [in] Stream we are writing to      <br>) <br>{ <br>  LPWSTR  pwszName; <br> <br>  if (m_ulCookie) <br>  { <br>    pwszName = L"Change This"; <br>  } <br>  else                                 // Null cookie is root  <br>  { <br>    pwszName = L"Hello MMC"; <br>  } <br> <br>  ULONG ulSizeofName = wcslen(pwszName); <br>  ulSizeofName++;                      // Count null <br>  ulSizeofName *= sizeof(WCHAR); <br> <br>  return pStream-&gt;Write(pwszName, ulSizeofName, NULL); <br> <br>} // end _WriteDisplayName() <br> <br> <br>//--------------------------------------------------------------------------- <br>//  Writes a pointer to this data object to the stream <br>// <br>HRESULT <br>CDataObject::_WriteInternal <br>( <br>  IStream* pStream           // [in] Stream we are writing to  <br>) <br>{ <br>  CDataObject *pThis = this; <br>  return pStream-&gt;Write( &amp;pThis, sizeof(CDataObject*), NULL ); <br> <br>} // end _WriteInternal <br> <br>//--------------------------------------------------------------------------- <br>//  Writes the Class ID to the stream <br>// <br>HRESULT <br>CDataObject::_WriteClsid <br>( <br>  IStream* pStream           // [in] Stream we are writing to <br>) <br>{ <br>  return pStream-&gt;Write( &amp;CLSID_ComponentData, <br>                         sizeof(CLSID_ComponentData), <br>                         NULL <br>                       ); <br>} // end _WriteClsid() <br> <br> <br>//--------------------------------------------------------------------------- <br>//  The cookie is what ever we decide it is going to be. <br>//  This is being called from QuerDataObject. Refer to that code. <br>// <br>VOID  <br>CDataObject::SetCookie <br>( <br>  ULONG              ulCookie, // [in] Unique indentifier <br>  DATA_OBJECT_TYPES  Context,  // [in] Context of the caller <br>  COOKIETYPE         Type      // [in] Type of cookie <br>) <br>{ <br>  _ASSERT(!m_ulCookie); <br>  m_ulCookie = ulCookie; <br>  m_Type = Type; <br>  m_Context = Context; <br> <br>  if (m_Type == COOKIE_IS_STATUS) <br>  { <br>    _ASSERT(m_ulCookie); <br>  } <br>} // end SetCookie() <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IUnknown implementation <br>//  <br> <br> <br>//--------------------------------------------------------------------------- <br>//  Standard implementation <br>// <br>STDMETHODIMP <br>CDataObject::QueryInterface <br>( <br>  REFIID  riid, <br>  LPVOID *ppvObj <br>) <br>{ <br>  // TRACE_METHOD(CDataObject, QueryInterface); <br>  HRESULT hr = S_OK; <br> <br>  do <br>  { <br>    if (NULL == ppvObj) <br>    { <br>      hr = E_INVALIDARG; <br>      break; <br>    } <br> <br>    if (IsEqualIID(riid, IID_IUnknown)) <br>    { <br>      *ppvObj = (IUnknown *)(IDataObject *)this; <br>    } <br>    else if (IsEqualIID(riid, IID_IDataObject)) <br>    { <br>      *ppvObj = (IUnknown *)(IDataObject *)this; <br>    } <br>    else <br>    { <br>      hr = E_NOINTERFACE; <br>      *ppvObj = NULL; <br>      break; <br>    } <br> <br>    //  <br>    // If we got this far we are handing out a new interface pointer on  <br>    // this object, so addref it.   <br>    //  <br> <br>    AddRef(); <br>  } while (0); <br> <br>  return hr; <br> <br>} // end QueryInterface() <br> <br>//--------------------------------------------------------------------------- <br>//  Standard implementation <br>// <br>STDMETHODIMP_(ULONG) <br>CDataObject::AddRef() <br>{ <br>  return InterlockedIncrement((LONG *) &amp;m_cRefs); <br>} <br> <br>//--------------------------------------------------------------------------- <br>//  Standard implementation <br>// <br>STDMETHODIMP_(ULONG) <br>CDataObject::Release() <br>{ <br>  ULONG cRefsTemp; <br> <br>  cRefsTemp = InterlockedDecrement((LONG *)&amp;m_cRefs); <br> <br>  if (0 == cRefsTemp) <br>  { <br>    delete this; <br>  } <br> <br>  return cRefsTemp; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
