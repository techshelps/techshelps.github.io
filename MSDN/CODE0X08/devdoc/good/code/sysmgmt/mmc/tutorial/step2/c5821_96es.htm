<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMPDATA.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5824"></a>COMPDATA.CPP</h2>
<pre><code>///////////////////////////////////////////////////////////////////////////// <br>//  compdata.cpp : IComponentData Interface to communicate with MMC for  <br>//                 scope pane use <br>// <br>//  This is a part of the MMC SDK. <br>//  Copyright (C) 1997 Microsoft Corporation <br>//  All rights reserved. <br>// <br>//  This source code is only intended as a supplement to the <br>//  MMC SDK Reference and related <br>//  electronic documentation provided with the library. <br>//  See these sources for detailed information regarding the <br>//  MMC Library product. <br>// <br> <br>#include "stdafx.h" <br>#include &lt;mmc.h&gt;                       // Copy from MMC.SDK <br>#include "disk.h" <br>#include "globals.h"                   // Helper functions <br>#include "comp.h" <br>#include "compdata.h" <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CComponentData - This class is the interface to handle anything to do  <br>//                  with the scope pane. MMC calls the IComponent interfaces. <br>//                  This class keeps a few pointers to interfaces that MMC <br>//                  implements. <br> <br> <br>CComponentData::CComponentData() <br>{ <br>  m_ipConsoleNameSpace = NULL; <br>  m_ipConsole          = NULL; <br>} <br> <br>CComponentData::~CComponentData() <br>{ <br>// We release the cached interface pointers in Destroy() <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// IComponentData methods <br>// <br> <br>//--------------------------------------------------------------------------- <br>// We get here only once, when the user clicks on the snapin. <br>// <br>// This method should not change as we progress through further steps. <br>// Here we get a chance to get pointer to some interfaces MMC provides. <br>// We QueryInterface for pointers to the name space and console, which <br>// we cache in local variables <br>// The other task to acomplish here is the adding of a bitmap that contains <br>// the icons to be used in the scope pane. <br>// <br>STDMETHODIMP <br>CComponentData::Initialize <br>( <br>  LPUNKNOWN pUnknown         // [in] Pointer to the IConsole s IUnknown interface <br>) <br>{ <br>    HRESULT      hr; <br>    LPIMAGELIST  lpScopeImage; <br> <br>    _ASSERT( NULL != pUnknown ); <br> <br>    // MMC should only call ::Initialize once! <br>    _ASSERT( NULL == m_ipConsoleNameSpace ); <br> <br>    // <br>    // Get pointer to name space interface <br>    // <br>    hr = pUnknown-&gt;QueryInterface(IID_IConsoleNameSpace, (VOID**)(&amp;m_ipConsoleNameSpace)); <br>    _ASSERT( S_OK == hr ); <br> <br>    // <br>    // Get pointer to console interface <br>    // <br>    hr = pUnknown-&gt;QueryInterface(IID_IConsole, (VOID**)(&amp;m_ipConsole)); <br>    _ASSERT( S_OK == hr ); <br> <br> <br>    // <br>    // Add the images for the scope tree <br>    // <br>    hr = m_ipConsole-&gt;QueryScopeImageList(&amp;lpScopeImage); <br>    _ASSERT( S_OK == hr ); <br> <br>    // Load the bitmaps from the dll <br>    m_hbmp16x16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_SCOPE_16x16)); <br>    _ASSERT( NULL != m_hbmp16x16 ); <br>  <br>    // Set the images <br>    hr = lpScopeImage-&gt;ImageListSetStrip( (long*)m_hbmp16x16, <br>                                          (long*)m_hbmp16x16, <br>                                          0, <br>                                          RGB(0,255,0) <br>                                        ); <br>    _ASSERT( S_OK == hr ); <br> <br>    lpScopeImage-&gt;Release(); <br> <br>    return S_OK; <br> <br>} // end Initialize() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Release interfaces and clean up objects which allocated memory <br>// <br>STDMETHODIMP <br>CComponentData::Destroy() <br>{ <br>  // Free interfaces <br>  m_ipConsoleNameSpace-&gt;Release(); <br>  m_ipConsoleNameSpace = NULL; <br> <br>  m_ipConsole-&gt;Release();  <br>  m_ipConsole = NULL; <br> <br>  _ASSERT( DeleteObject(m_hbmp16x16) ); <br> <br>  return S_OK; <br> <br>} // end Destroy() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Come in here once right after Initialize. MMC wants a pointer to the <br>// IComponent interface. <br>// <br>STDMETHODIMP <br>CComponentData::CreateComponent <br>( <br>  LPCOMPONENT* ppComponent   // [out] Pointer to the location that stores <br>)                            // the newly created pointer to IComponent <br>{ <br>  CComObject&lt;CComponent&gt;* pObject; <br> <br>  // <br>  // MMC asks us for a pointer to the IComponent interface <br>  // <br>  // For those getting up to speed with COM... <br>  // If we had implemented IUnknown with its methods QueryInterface, AddRef, <br>  // and Release in our CComponent class... <br>  // The following line would have worked <br>  // <br>  // pNewSnapin = new CComponent(this); <br>  // <br>  // In this code we will have ATL take care of IUnknown for us and create <br>  // an object in the following manner... <br> <br>  _ASSERT( NULL != ppComponent ); <br> <br>  CComObject&lt;CComponent&gt;::CreateInstance( &amp;pObject ); <br>  _ASSERT( NULL != pObject ); <br> <br>  // Step2:  Store IComponentData. <br>  // Can't have a constructor with parameters, so pass it in this way. <br>  pObject-&gt;SetIComponentData( this ); <br> <br>  return  pObject-&gt;QueryInterface( IID_IComponent, <br>                                   reinterpret_cast&lt;void**&gt;(ppComponent) <br>                                 ); <br>} // end CreateComponent() <br> <br> <br>//--------------------------------------------------------------------------- <br>// In this first step, we only implement EXPAND. <br>// The expand message asks us to populate what is under our root node. <br>// We just put one item under there. <br>// <br>STDMETHODIMP <br>CComponentData::Notify <br>( <br>  LPDATAOBJECT     lpDataObject,  // [in] Points to the selected data object <br>  MMC_NOTIFY_TYPE  event,         // [in] Identifies action taken by user.  <br>  long             arg,           // [in] Depends on the notification type <br>  long             param          // [in] Depends on the notification type <br>) <br>{ <br>  HRESULT hr = S_OK; <br> <br>  switch (event) <br>  { <br>    case MMCN_EXPAND: <br>      ATLTRACE( L"ComponentData::Notify: MMCN_EXPAND\n" ); <br>      hr = OnExpand( lpDataObject, arg, param ); <br>      break; <br> <br>    case MMCN_DELETE:                  // Step2:  Function not implemented  <br>      ATLTRACE( L"CComponentData::Notify: MMCN_DELETE unimplemented\n" ); <br>      hr = S_FALSE; <br>      break; <br> <br>    case MMCN_RENAME:                  // Step2:  Function not implemented <br>      ATLTRACE( L"ComponentData::Notify: MMCN_RENAME unimplemented\n" ); <br>      hr = S_FALSE; <br>      break; <br> <br>    case MMCN_SELECT:                  // Step2:  Function not implemented <br>      ATLTRACE(_T("ComponentData::Notify: MMCN_SELECT unimplemented\n")); <br>      hr = S_FALSE; <br>      break; <br> <br>    case MMCN_PROPERTY_CHANGE:         // Step2:  Function not implemented <br>      ATLTRACE(_T("ComponentData::Notify: MMCN_PROPERTY_CHANGE unimplemented\n")); <br>      hr = S_FALSE; <br>      break; <br> <br>    case MMCN_REMOVE_CHILDREN:         // Step2:  Function not implemented <br>      ATLTRACE(_T("ComponentData::Notify: MMCN_REMOVE_CHILDREN unimplemented\n")); <br>      hr = S_FALSE; <br>      break; <br> <br>    default: <br>      ATLTRACE( L"CComponentData::Notify: unimplemented event %x\n", event ); <br>      hr = S_FALSE; <br>      break; <br>  } <br>  return hr; <br> <br>} // end Notify() <br> <br> <br>//--------------------------------------------------------------------------- <br>// This is where MMC asks us to provide IDataObjects for every node in the <br>// scope pane <br>// <br>STDMETHODIMP <br>CComponentData::QueryDataObject <br>(  <br>  long              cookie,       // [in]  Data object's unique identifier  <br>  DATA_OBJECT_TYPES type,         // [in]  Data object's type <br>  LPDATAOBJECT*     ppDataObject  // [out] Points to the returned data object <br>) <br>{ <br>  HRESULT     hr      = S_OK; <br>  CDataObject *pdoNew = NULL; <br> <br>  do <br>  { <br>pdoNew = new CDataObject; <br>    *ppDataObject = pdoNew; <br> <br>    if (!pdoNew)   <br>    { <br>      hr = E_OUTOFMEMORY; <br>      // Use MessageBox() rather than IConsole::MessageBox() here because the <br>      // first time this gets called m_ipConsole is not fully initialized <br>      ::MessageBox( NULL, <br>                    L"Unable to allocate new data object", <br>                    L"CComponentData::QueryDataObject", <br>                    MB_OK <br>                  ); <br>      break; <br>    } <br> <br>    // <br>    // The cookie represents a snapin manager or scope pane item. <br>    // <br>    // If the passed-in cookie is NULL, it is our snapin's root node folder <br>    // We never needed to ask for this to be created. MMC did this for us. <br>    // <br>    // If the passed-in cookie is non-NULL, then it should be one we <br>    // created when we added a node to the scope pane. See OnExpand().  <br>    // <br> <br>    if (cookie) <br>    { <br>      // cookie is the lparam field that we passed in SCOPEDATAITEM <br>      // used for the m_ipConsoleNameSpace-&gt;InsertItem(&amp;sdi); <br>      pdoNew-&gt;SetCookie( cookie, CCT_SCOPE, COOKIE_IS_STATUS ); <br>    } <br>    else  <br>    { <br>      // In this case the node is our top node, and was placed there for us. <br>      pdoNew-&gt;SetCookie( 0, type, COOKIE_IS_ROOT ); <br>    } <br>  } while (0); <br> <br>  return hr; <br> <br>} // end QueryDataObject() <br> <br> <br>//--------------------------------------------------------------------------- <br>// This is where we provide strings for nodes in the scope pane. <br>// We only have one node, so this is easy. MMC handles the root node string. <br>// <br>STDMETHODIMP <br>CComponentData::GetDisplayInfo <br>( <br>  LPSCOPEDATAITEM pItem      // [in, out] Points to a SCOPEDATAITEM struct <br>) <br>{ <br>  _ASSERT( NULL != pItem ); <br>  _ASSERT( pItem-&gt;mask &amp; SDI_STR ); <br> <br>  pItem-&gt;displayname = (LPOLESTR)L"Geometry";  // Title to our child folder <br> <br>return S_OK; <br> <br>} // end GetDisplayInfo() <br> <br> <br>//--------------------------------------------------------------------------- <br>// Step2: Here we test two data objects. <br>// <br>STDMETHODIMP <br>CComponentData::CompareObjects <br>( <br>  LPDATAOBJECT lpDataObjectA,    // [in] First data object to compare <br>  LPDATAOBJECT lpDataObjectB     // [in] Second data object to compare <br>) <br>{ <br>  CDataObject *pdoA; <br>  CDataObject *pdoB; <br> <br>  // At least one of these data objects is supposed to be ours, so one <br>  // of the extracted pointers should be non-NULL. <br>  pdoA = ExtractOwnDataObject( lpDataObjectA ); <br>  pdoB = ExtractOwnDataObject( lpDataObjectB ); <br>  _ASSERT( pdoA || pdoB );             // Assert if we can't get any objects <br> <br>  // If extraction failed for one of them, then that one is foreign and <br>  // can't be equal to the other one.  (Or else ExtractOwnDataObject <br>  // returned NULL because it ran out of memory, but the most conservative <br>  // thing to do in that case is say they're not equal.) <br>  if( !pdoA || !pdoB ) <br>  { <br>    return S_FALSE; <br>  } <br> <br>  // The cookie type could be COOKIE_IS_ROOT or COOKIE_IS_OBJECT.  If they <br>  // differ then the objects refer to different things. <br>  if( pdoA-&gt;GetCookieType() != pdoB-&gt;GetCookieType() ) <br>  { <br>    return S_FALSE; <br>  } <br> <br>  return S_OK; <br> <br>} // end CompareObjects() <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>//  Methods needed to support IComponentData <br>// <br> <br>//--------------------------------------------------------------------------- <br>// Here is our chance to place things under the root node. <br>// We will put one item under it. <br>// <br>HRESULT  <br>CComponentData::OnExpand <br>( <br>  LPDATAOBJECT pDataObject,      // [in] Points to data object <br>  long         arg,              // [in] TRUE is we are expanding <br>  long         param             // [in] Points to the HSCOPEITEM <br>) <br>{ <br>  CDataObject   *pdo; <br>  SCOPEDATAITEM sdi; <br>  INT           iResult; <br>  HRESULT       hr = S_OK; <br> <br>  _ASSERT( NULL != m_ipConsoleNameSpace ); // Make sure we QI'ed for the interface <br>  _ASSERT( NULL != pDataObject );          // Must have valid data object <br> <br>  if (TRUE == arg ) <br>  { <br>    pdo = ExtractOwnDataObject( pDataObject ); <br> <br>    if( !pdo ) <br>    { <br>      hr = m_ipConsole-&gt;MessageBox( L"Did not understand the data object.\nNot set up to be an extension", <br>                                    L"CComponentData::OnExpand", <br>                                    MB_OK, <br>                                    &amp;iResult <br>                                  ); <br>      return hr; <br>    } <br> <br>    // Make sure that what we are placing ourselvs under is the root node! <br>    if (pdo-&gt;GetCookieType() != COOKIE_IS_ROOT) <br>      return S_FALSE; <br> <br>    _ASSERT( CCT_SCOPE == pdo-&gt;GetContext() );   // Scope pane must be current context <br>    _ASSERT( COOKIE_IS_ROOT == pdo-&gt;GetCookieType() ); <br> <br>    // <br>    // Place our folder into the scope pane <br>    // <br>    ZeroMemory(&amp;sdi, sizeof(SCOPEDATAITEM) ); <br>    sdi.mask       = SDI_STR       |   // Displayname is valid <br>                     SDI_PARAM     |   // lParam is valid <br>                     SDI_IMAGE     |   // nImage is valid <br>                     SDI_OPENIMAGE |   // nOpenImage is valid <br>                     SDI_PARENT; <br>    sdi.relativeID  = (HSCOPEITEM)param; <br>    sdi.nImage      = 0; <br>    sdi.nOpenImage  = 1; <br>    sdi.displayname = MMC_CALLBACK; <br>    sdi.lParam      = (LPARAM)1;       // The cookie <br> <br>    hr = m_ipConsoleNameSpace-&gt;InsertItem( &amp;sdi ); <br>  } <br>  return hr; <br> <br>} // end OnExpand() </code></pre>
<p>&nbsp;</p></body>
</HTML>
