<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFINST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5851"></a>INFINST.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// <br>//    PROGRAM:InfInst.c <br>// <br>//    PURPOSE:Demonstrates how create a wizard based install <br>//              using win32 functions in setupapi.dll <br>// <br>//    PLATFORMS:Windows 95 and NT 4.0 <br>// <br>//    FUNCTIONS: <br>//    WinMain() - calls initialization function, processes message loop <br>//    InitApplication() - Initializes window data nd registers window <br>//    InitInstance() - saves instance handle and creates main window <br>//    MainWindProc() - Processes messages <br>//    RuntimeRegistration() - Add runtime data to registry <br>//      RegisterString() - adds a string to registry, simple win32 registry api wrapper <br>//      GetRegString() - gets a string from registry, simple win32 registry api wrapper <br>//      GetPlatformInfo () - not used but this is an exampleof what you can do in <br>//             a win32 or win16 setup stub program to get your setup started <br>//             NOTE: In this sample we are assuming the autorun.inf takes care of this <br>// <br>//    CALLS: <br>//    DoInstallation() - Does the resulting installation options in doinst.c <br>// <br>//    SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>#include &lt;windows.h&gt;    // includes basic windows functionality <br>#include &lt;string.h&gt;     // includes the string functions <br>#include &lt;prsht.h&gt;      // includes the property sheet functionality <br>#include "setupapi.h"   // includes the inf setup api  <br>#include "resource.h"   // includes the definitions for the resources <br>#include "instwiz.h"     // includes the application-specific information <br>#include "infinst.h"     // includes the application-specific information <br>#include "infdesc.h" <br> <br>INSTALLINFO setupInfo;      // a structure containing the review information <br>HWND hwndEdit;          // handle to the main MLE <br>TCHAR lpReview[MAX_BUF]; // Buffer for the review <br> <br>BOOL bCreated = FALSE;  // Keep us minimized once we are created <br> <br>// <br>// <br>//   FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>// <br>//   PURPOSE: Main entry point for the application.  <br>// <br>//   COMMENTS: <br>//     <br>//    This function calls the initialization functions and processes <br>//    the main message loop. <br>//  <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br>        MSG msg;                        <br> <br>        // save off the current instance <br>        setupInfo.hInst = hInstance; <br> <br>        // if the initialization fails, return. <br>        if (!InitApplication(hInstance)) <br>            return (FALSE);      <br> <br>        // Perform initializations that apply to a specific instance  <br>        if (!InitInstance(hInstance, nCmdShow)) <br>            return (FALSE); <br> <br>       // Acquire and dispatch messages until a WM_QUIT message is received.  <br>       while (GetMessage(&amp;msg, NULL, 0,0))                 <br>       { <br>      TranslateMessage(&amp;msg); <br>      DispatchMessage(&amp;msg);  <br>       } <br>        <br>       return (msg.wParam);   <br>} <br> <br> <br>// <br>// <br>//   FUNCTION: InitApplication(HANDLE)  <br>// <br>//   PURPOSE: Initializes window data and registers window class  <br>// <br>//   COMMENTS: <br>// <br>//    This function registers the window class for the main window. <br>//  <br>BOOL InitApplication(HANDLE hInstance) <br>{ <br>        WNDCLASS  wcSample; <br>     <br>        // Fill in window class structure with parameters that describe the        <br>        // main window.                                                            <br> <br>        wcSample.style = 0;                      <br>        wcSample.lpfnWndProc = (WNDPROC)MainWndProc;  <br>        wcSample.cbClsExtra = 0;               <br>        wcSample.cbWndExtra = 0;               <br>        wcSample.hInstance = hInstance;        <br>        wcSample.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(EXE_ICON)); <br>        wcSample.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wcSample.hbrBackground = GetStockObject(WHITE_BRUSH);  <br>        wcSample.lpszMenuName =  NULL;   <br>        wcSample.lpszClassName = TEXT("SampleWClass"); <br> <br>        return (RegisterClass(&amp;wcSample)); <br> <br>} <br> <br> <br>// <br>// <br>//   FUNCTION: InitInstance(HANDLE, int) <br>// <br>//   PURPOSE: Creates the main window. <br>// <br>//   COMMENTS: N/A <br>//     <br>//  <br>BOOL InitInstance( <br>    HANDLE          hInstance, <br>    int             nCmdShow)  <br>{ <br>    HWND hWndMain; <br> <br>    hWndMain = CreateWindow( <br>        TEXT("SampleWClass"), <br>        TEXT("Install Sample"),  <br>    WS_OVERLAPPEDWINDOW,  <br>    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <br>    NULL,                <br>    NULL,                <br>    hInstance,           <br>    NULL); <br> <br>    /* If window could not be created, return "failure" */ <br>    if (!hWndMain) <br>    return (FALSE); <br> <br>    /* Make the window visible; update its client area; and return "success" */ <br>    ShowWindow(hWndMain, SW_MINIMIZE); <br>    UpdateWindow(hWndMain);  <br>    return (TRUE);       <br> <br>} <br> <br>// <br>//   FUNCTION: MainWndProc(HWND, UINT, UINT, LONG) <br>// <br>//  PURPOSE:  Processes messages for the main window procedure  <br>// <br>//    MESSAGES: <br>//     <br>//    WM_CREATE - creates the main MLE for the window <br>//    WM_COMMAND - processes the menu commands for the application <br>//    WM_SIZE - sizes the MLE to fill the client area of the window <br>//    WM_DESTROY - posts a quit message and returns <br>// <br>LONG APIENTRY MainWndProc( <br>    HWND hWnd,                // window handle                    <br>    UINT message,             // type of message                  <br>    UINT wParam,              // additional information           <br>    LONG lParam)              // additional information           <br>{ <br> <br>    switch (message)  <br>    { <br>        case WM_CREATE: <br>            // TODO: put in a Bitmap for a splash window ); <br>             <br>            GetRegString(MYPRODUCT_KEY, USER_NAME_KEY,  setupInfo.pszUserName); <br>            GetRegString(MYPRODUCT_KEY, COMPANY_KEY,    setupInfo.pszCompany); <br>            GetRegString(MYPRODUCT_KEY, PRODUCT_ID_KEY, setupInfo.pszProductIdString); <br>            GetRegString(MYPRODUCT_KEY, EMAIL_KEY,      setupInfo.pszEmailAddress); <br>            GetRegString(MYPRODUCT_KEY, TEXT("DestinationPath"),  setupInfo.pszDestPath); <br> <br>            // Start up the install  <br>            PostMessage(hWnd, WM_COMMAND, ID_INSTALL, 0 ); <br>            return 0; <br>  <br>         case WM_WINDOWPOSCHANGING: <br>             if (bCreated) <br>             {   <br>                 LPWINDOWPOS lpwp; <br> <br>                 lpwp = (LPWINDOWPOS) lParam; // points to size and position data  <br>                 lpwp-&gt;flags = SWP_NOMOVE    | SWP_NOOWNERZORDER | <br>                               SWP_NOSIZE | SWP_NOREDRAW |  <br>                               SWP_NOREPOSITION; <br> <br>              }  <br>              else <br>              {  <br>                 bCreated = TRUE; <br>              } <br>              break; <br> <br>        case WM_COMMAND: <br>            switch( LOWORD( wParam )) <br>    { <br>                /*******************************************************\ <br>                * <br>                *  Here is where the real work takes place <br>                *     Do the wizard to collect the user information <br>                *     Do the installation with the setupapis <br>                *     Update the registry with runtime user data <br>                *      <br>                \*******************************************************/ <br>                case ID_INSTALL: <br>                    // Do installation <br>                    DoInstallation(hWnd, &amp;setupInfo); <br> <br>                    //installs done so go away <br>                    PostMessage(hWnd, WM_DESTROY, 0, 0 ); <br>                    break; <br> <br>                 default: <br>                    return (DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>    } <br>    break; <br> <br>    case WM_DESTROY:                  /* message: window being destroyed */ <br>    PostQuitMessage(0); <br>    break; <br> <br>    default: <br>    return (DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return (0); <br>} <br> <br> <br>void RuntimeRegistration(INSTALLINFO *si) <br>{ <br>    // <br>    // The setupapi calls have completed <br>    // now we will finish up by updating the user information <br>    // and uninstall in the registry <br>    // <br> <br>    char buf[MAX_PATH]; <br> <br>    // <br>    // Stuff for out product <br>    // fixed application values are done by the inf <br>    // We are only doing runtime values here <br>    // <br> <br>    RegisterString(MYPRODUCT_KEY, <br>             USER_NAME_KEY, <br>             si-&gt;pszUserName); <br> <br>    RegisterString(MYPRODUCT_KEY, <br>             COMPANY_KEY, <br>             si-&gt;pszCompany); <br>     <br>    RegisterString(MYPRODUCT_KEY, <br>             PRODUCT_ID_KEY, <br>             si-&gt;pszProductIdString); <br>     <br>    RegisterString(MYPRODUCT_KEY, <br>             EMAIL_KEY, <br>             si-&gt;pszEmailAddress); <br>     <br> <br>    wsprintf(buf, "%s", si-&gt;pszDestPath); <br>     <br>    RegisterString(MYPRODUCT_KEY, <br>                TEXT("DestinationPath"), <br>                buf); <br> <br>/* <br>    // <br>    // Setup up Add/Remove Programs Control Panel Applet <br>    // We need to set Display name and how to uninstall <br>    // <br>    // UNINSTALL Info <br>    // <br> <br>    RegisterString(UNINSTALL_KEY, <br>                TEXT("DisplayName"), <br>                TEXT("MyProduct Version 1.0")); <br> <br>    wsprintf(buf, "%s\\setup.exe Uninstall", si-&gt;pszDestPath); <br>     <br>    RegisterString(UNINSTALL_KEY, <br>                TEXT("UninstallString"), <br>                buf); <br> <br>*/     <br>    return; <br>} <br> <br> <br>BOOL  <br>RegisterString ( <br>   LPSTR pszKey,  <br>   LPSTR pszValue,  <br>   LPSTR pszData <br>   ) <br>{ <br> <br>    HKEY hKey; <br>    DWORD dwDisposition; <br> <br>    // <br>    // Create the key, if it exists it will be opened <br>    // <br> <br>    if (ERROR_SUCCESS !=  <br>        RegCreateKeyEx( <br>          HKEY_LOCAL_MACHINE,       // handle of an open key  <br>          pszKey,                  // address of subkey name  <br>          0,                       // reserved  <br>          NULL,                    // address of class string  <br>          REG_OPTION_NON_VOLATILE, // special options flag  <br>          KEY_ALL_ACCESS,           // desired security access  <br>          NULL,                       // address of key security structure  <br>          &amp;hKey,                   // address of buffer for opened handle   <br>          &amp;dwDisposition))            // address of disposition value buffer  <br>    { <br>        return FALSE; <br>    } <br> <br>    // <br>    // Write the value and it's data to the key <br>    // <br> <br>    if (ERROR_SUCCESS !=  <br>        RegSetValueEx( <br>            hKey,                 // handle of key to set value for   <br>            pszValue,             // address of value to set  <br>            0,                     // reserved  <br>            REG_SZ,                 // flag for value type  <br>            pszData,             // address of value data  <br>            strlen(pszData) ))      // size of value data  <br>    { <br>         <br>        RegCloseKey(hKey); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Close the key <br>    // <br>     <br>    RegCloseKey(hKey); <br>     <br>    return TRUE; <br>} <br> <br>BOOL <br>GetRegString ( <br>  LPSTR pszKey, <br>  LPSTR pszValue, <br>  LPSTR pszData <br>  ) <br>{ <br> <br>    HKEY hKey; <br>    DWORD dwDataSize = MAX_PATH - 1; <br>    DWORD dwValueType = REG_SZ; <br> <br>    RegOpenKeyEx( <br>       HKEY_LOCAL_MACHINE,    // handle of open key  <br>       pszKey,                // address of name of subkey to open  <br>       0,                    // reserved  <br>       KEY_QUERY_VALUE,        // security access mask  <br>       &amp;hKey                 // address of handle of open key  <br>       );     <br> <br>    RegQueryValueEx( <br>        hKey,         // handle of key to query  <br>        pszValue,     // address of name of value to query  <br>        0,             // reserved  <br>        &amp;dwValueType,// address of buffer for value type  <br>        pszData,     // address of data buffer  <br>        &amp;dwDataSize  // address of data buffer size  <br>        ); <br> <br>    if (pszData[dwDataSize] != '\0') <br>        pszData[dwDataSize] = '\0'; <br> <br>    return TRUE; <br>} <br> <br>/* <br> <br>//      GetPlatformInfo () - not used but this is an example of what you can do in <br>//             a win32 or win16 setup stub program to get your setup started <br>//             NOTE: In this sample we are assuming the autorun.inf takes care of this <br>//                   for us. See the autorun.inf which shows this <br>// <br>//      The core of this could be your entire WinMain in a win16 stub  <br>// <br>int GetPlatformInfo(HINSTANCE hInstance) <br>{ <br>    char szCpu[64], szPath[_MAX_PATH], szExeStr[128]; <br>    char szSystemDir[_MAX_PATH]; <br>     <br>    GetModuleFileName(hInstance, szPath, _MAX_PATH); <br>    *(strrchr(szPath, '\\') + 1) = '\0';// Strip SETUPPROG off path <br>    GetSystemDirectory(szSystemDir, _MAX_PATH); <br> <br>                                                         <br>    if (getenv("PROCESSOR_ARCHITECTURE") != NULL) <br>    { <br>    lstrcpyn(szCpu, getenv("PROCESSOR_ARCHITECTURE"), 63); <br>    } <br>    else <br>    {   // Not defined, guess x86 <br>    lstrcpy(szCpu, "x86"); <br>    } <br> <br>        if (HIBYTE(LOWORD(GetVersion())) &gt; 11) // Check if Win95  <br>{ <br>    //Win95 <br>            sprintf(szExeStr, "%s\\Bin\\I386\\infinst.exe CmdLineOptions", szPath); <br>}  <br>        // Else pick the NT platform <br>        else if (!lstrcmp(szCpu, "MIPS")) <br>{                            <br>            sprintf(szExeStr, "%s\\Bin\\MIPS\\infinst.exe CmdLineOptions", szPath); <br>} <br>else if (!lstrcmp(szCpu, "ALPHA")) <br>{ <br>            sprintf(szExeStr, "%s\\Bin\\ALPHA\\infinst.exe CmdLineOptions", szPath); <br>} <br>else if (!lstrcmp(szCpu, "PPC")) <br>{ <br>            sprintf(szExeStr, "%s\\Bin\\PPC\\infinst.exe CmdLineOptions", szPath); <br>}                                          <br>else   // x86 NT box <br>{ <br>            sprintf(szExeStr, "%s\\Bin\\I386\\infinst.exe CmdLineOptions", szPath); <br>        } <br> <br>    //    MessageBox ( NULL, szExeStr,szCpu,MB_OK); <br> <br>    //    WinExec(szExeStr, SW_SHOW); <br> <br>    if (wReturn &lt; 32) { <br>             //Failed <br>    } <br>    else { <br>              //Worked <br>    } <br> <br>    return(0); <br>} <br>*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
