<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOINST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5849"></a>DOINST.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt;    // includes basic windows functionality <br>#include &lt;string.h&gt;     // includes the string functions <br>#include &lt;shlobj.h&gt;     // To update the desktop <br>#include &lt;regstr.h&gt; <br> <br>#include "setupapi.h"   // includes the inf setup api  <br>#include "instwiz.h"    // includes the application-specific information <br>#include "infinst.h"    // includes the application-specific information <br>#include "infdesc.h"    // includes the specifics of how this <br>                        // inf is layed out, like the inf names <br>                        // the HKeys and the DirIds <br> <br>DWORD InstallFinish(BOOL DoRunOnce); <br> <br>// <br>//    FUNCTION: BOOL DoInstallation( HWND hWnd, INSTALLINFO * si ) <br>// <br>//    PURPOSE: Install components via setupapi.dll. <br>// <br>//   COMMENTS: <br>//     <br>//      The function does inf install operations based <br>//      on the content of the INSTALLINFO data. <br>//      These steps could be done during the wizard but <br>//      this technique allows for installations with user input. <br>// <br>// This routine will take a INSTALLINFO <br>// and do an installation based on those settings <br>// using the setupapi.dll <br> <br>BOOL DoInstallation( HWND hWnd, INSTALLINFO * si ) <br>{ <br> <br>    HINF hInf; <br>    char szSourcePath[MAX_PATH]; <br>    char szInfFileName[MAX_PATH]; <br>     <br>    DWORD dwResult; <br>    BOOL bResult = FALSE; <br> <br>    // Context for my call back routine <br>    MY_INSTALL_DATA MyInstallData; <br> <br>    HSPFILEQ FileQueue; <br> <br>    // <br>    // First we setup the inf to what the wizard collected <br>    // note the hInf will maintain the information and let <br>    // you build copy list as you go <br>    // This sample seperates the wizard from the setapi stuff <br>    // just to keep the setupapi stuff in one place <br>    // <br> <br>    // <br>    // The install process overview is:  <br>    //   TASK                       SETUPAPI <br>    //   open a specific inf        SetupOpenInfFile <br>    //   call the wizard for input  CreateWizard (implemented in instwiz.c) <br>    //   set the directory ids      SetupSetDirectoryId  <br>    //   create a file queue        SetupOpenFileQueue <br>    //   create a queue context     SetupInitDefaultQueueCallback <br>    //   add files to queue         SetupInstallFilesFromInfSection <br>    //   do the copy                SetupCommitFileQueue <br>    //???   do the registry stuff      SetupInstallFromInfSection <br>    //   close the queue            SetupTermDefaultQueueCallback <br>    //   close the inf              SetupCloseFileQueue <br>     <br>    // <br>    // In this sample we assume the inf is in the base of the <br>    // base installation source path--it usually is for most installs <br>    // <br>     <br>    GetModuleFileName(NULL, szSourcePath, _MAX_PATH); <br>    *(strrchr(szSourcePath, '\\') + 1) = '\0';        // Strip setup.exe off path <br> <br>    strcpy(szInfFileName, szSourcePath); <br>    strcat(szInfFileName, "product.inf"); <br> <br>    // <br>    // Get inf handle <br>    // must know where the inf is located  <br>    // SetupOpenInfFile will only look in windows\inf by default <br>    // <br> <br>    hInf = SetupOpenInfFile (  <br>        szInfFileName,       // If path,needs full path, else looks in %windir%\inf <br>        NULL,                // Inf Type, matches Class in [Version] section SetupClass=SAMPLE <br>        INF_STYLE_WIN4,      // or INF_STYLE_OLDNT <br>        NULL                 // Line where error occurs if inf is has a problem <br>        ); <br> <br>    if (hInf == INVALID_HANDLE_VALUE)  <br>    { <br>        dwResult = GetLastError(); <br> <br>        //    <br>        // TODO: handle case where inf cannot be opened <br>        //       by asking the user to locate the inf <br>     <br>        return FALSE; <br>    } <br> <br>    // Run the wizard <br>    if (CreateWizard(hWnd, si-&gt;hInst)) <br>    { <br>        RuntimeRegistration(si); <br>    } <br>    else <br>    { <br>        SetupCloseInfFile(hInf); <br>        return FALSE; <br>    } <br>  <br>    // <br>    // Special case the uninstall destitation path <br>    // this is because we need to get the registry value <br>    // for where to delete the files from.  <br>    // <br> <br>    if (IDC_INSTALL_TYPE_UNINSTALL == si-&gt;iInstall_Type) <br>    { <br>        // get path installed to here! <br>        // query registry for si-&gt;pszDestPath <br> <br>        GetRegString (MYPRODUCT_KEY, TEXT("DestinationPath"), <br>                si-&gt;pszDestPath); <br>    } <br> <br>    // <br>    // Directory ids are set per HINF <br>    // <br>    // TODO: verify dest path as a valid file name <br> <br>    bResult = SetupSetDirectoryId(hInf,          // the HINF that will hold these ids <br>                        (DWORD) DESTINATION_DIR, // the id that matchs one in the inf <br>                        si-&gt;pszDestPath);        // the user's string <br>     <br>    if(!bResult)  <br>    { <br>        dwResult = GetLastError(); <br>         <br>        // TODO: handle case where we cannot set dirids, should we default or bail? <br>        //       perhaps write this out to an error log <br>        //  <br>        // Close the inf file and return <br>        // <br> <br>        SetupCloseInfFile(hInf); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Create a Setup file queue and initialize the default Setup <br>    // queue callback routine. <br>    // <br> <br>    FileQueue = SetupOpenFileQueue(); <br> <br>    if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE))  <br>    { <br>        dwResult = ERROR_NOT_ENOUGH_MEMORY; <br>         <br>        // <br>        // Close the queue and return <br>        // <br> <br>        SetupCloseInfFile(hInf); <br>        return FALSE; <br>    } <br> <br>    // <br>    // This initialize memory for the default call back <br>    // This context MUST be used if our private callback routine  <br>    //     wants to callback into the default routine, we do it here with  <br>    //     a global value for the default context <br>    // <br>    // We want to use the default progress dialog. <br>    // We could override this by specifying a window that <br>    // will handle the ui in param 2.   <br>    // By not passing a progress HWND this is the same as  <br>    // using SetupInitDefaultQueueCallback. <br>    // <br> <br>    MyInstallData.pDefaultContext = SetupInitDefaultQueueCallbackEx( <br>                    hWnd,  // HWND of owner window <br>                    NULL,  // HWND of alternate progress dialog which receives -- for example <br>                           //      if you wanted to display your progress bar right in the wizard <br>                    0,     // Message sent to above window indicating a progress message <br>                    0,     // DWORD Reserved <br>                    NULL   // PVOID Reserved <br>                    ); <br> <br>    if(!(MyInstallData.pDefaultContext))  <br>    { <br>        dwResult = ERROR_NOT_ENOUGH_MEMORY; <br> <br>        // <br>        // Close the queue and the inf file and return <br>        // <br> <br>        SetupCloseFileQueue(FileQueue); <br>        SetupCloseInfFile(hInf); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Now that we have a FileQueue, a Queue Context, and an HINF <br>    // we want to map the DirectoryIds in the INF to the ones <br>    // obtained by the user  <br> <br>    // <br>    // Queue file operations and commit the queue. <br>    // <br> <br>    // <br>    // Install each option they have selected <br>    // <br> <br>    if (IDC_INSTALL_TYPE_UNINSTALL == si-&gt;iInstall_Type) <br>    { <br>        //TODO: allow the user to remove specific components <br>        //      note you would want to update the wizard to reflect this <br>         <br>        bResult = SetupInstallFilesFromInfSection( <br>                  hInf,     // HINF that has the directory ids set above <br>                  NULL,          // layout.inf if you have one, this a convient <br>                                 //     place to do all of your file to media id mapping <br>                  FileQueue,     // Queue to add files to <br>                  TEXT("MyProgramUninstall"),   // SectionName, <br>                  szSourcePath,    // Path where the source files are located <br>                  SP_COPY_NEWER);// The controls how to version check <br>                                 // and how to prompt <br>    } <br>    else <br>    { <br> <br>      if (si-&gt;iCustom_Options1){ <br>        bResult = SetupInstallFilesFromInfSection( <br>                      hInf,     // HINF that has the directory ids set above <br>                      NULL,          // layout.inf if you have one, this a convient <br>                                     //     place to do all of your file to media id mapping <br>                      FileQueue,     // Queue to add files to <br>                      INF_OPTION1,   // SectionName, <br>                      szSourcePath,    // Path where the source files are located <br>                      SP_COPY_NEWER);// The controls how to version check <br>                                     // and how to prompt <br>        } <br>         <br>        if (si-&gt;iCustom_Options2) { <br>            bResult = SetupInstallFilesFromInfSection(hInf, NULL,  <br>                FileQueue, INF_OPTION2, szSourcePath, SP_COPY_NEWER ); <br>        } <br> <br>        if (si-&gt;iCustom_Options3) { <br>            bResult = SetupInstallFilesFromInfSection(hInf, NULL,  <br>                FileQueue, INF_OPTION3, szSourcePath, SP_COPY_NEWER ); <br>        } <br> <br>        if (si-&gt;iCustom_Options4) { <br>            bResult = SetupInstallFilesFromInfSection(hInf, NULL,  <br>                FileQueue, INF_OPTION4, szSourcePath, SP_COPY_NEWER ); <br>        } <br>    } <br> <br>    // <br>    // All the files for each component are now in one queue <br>    // now we commit it to start the copy ui, this way the <br>    // user has one long copy progress dialog--and for a big install <br>    // can go get the cup of coffee  <br>    // <br>    if(bResult) { <br>         <br>        bResult = SetupCommitFileQueue( <br>                hWnd,                      // Owner <br>                FileQueue,                 // Queue with the file list <br>                (PSP_FILE_CALLBACK) MyQueueCallback,  <br>                                           // This is our handler, it calls the default for us <br>                                           // NOTE: <br>                                           // (PSP_FILE_CALLBACK) SetupDefaultQueueCallback <br>                                           // would use the default message handler automatically <br>                &amp;MyInstallData             // Pointer to resources allocated with SetupInitDefaultQueueCallback/Ex                  <br>                ); <br> <br>        dwResult = bResult ? NO_ERROR : GetLastError(); <br> <br>    } else { <br>         <br>        dwResult = GetLastError(); <br>     <br>    } <br> <br>    // <br>    // Do registry munging, etc.  <br>    // NOTE: you can do the entire install <br>    // for a section with this api but in this case <br>    // we build the file list conditionally and <br>    // do only out ProductInstall section for registy stuff <br>    // Also using SPINST_FILES will do the files <br>    // as above but only one section at a time <br>    // so the progress bar would keep completing and starting over <br>    // SPINST_ALL does files, registry and inis <br>    //  <br>    if (si-&gt;iCustom_Options1) <br>    { <br>      bResult = SetupInstallFromInfSection( <br>            hWnd, <br>            hInf, <br>            INF_OPTION1, <br>            SPINST_REGISTRY | SPINST_INIFILES, <br>            NULL, <br>            NULL,//szSourcePath,    // Path where the source files are located <br>            0,//SP_COPY_NEWER, <br>            NULL,//(PSP_FILE_CALLBACK) MyQueueCallback,  <br>            NULL,//&amp;MyInstallData, <br>            NULL,  <br>            NULL <br>            ); <br>    } <br> <br>    // <br>    // Perserve first non-success error code. <br>    // <br>    if(!bResult &amp;&amp; (dwResult == NO_ERROR)) { <br>     <br>        dwResult = GetLastError(); <br>     <br>    } <br> <br>    // <br>    // We're done so free the context, close the queue, <br>    // and release the inf handle <br>    // <br> <br>    SetupTermDefaultQueueCallback(MyInstallData.pDefaultContext); <br>    SetupCloseFileQueue(FileQueue); <br>    SetupCloseInfFile(hInf); <br>     <br>    if(dwResult != NO_ERROR) { <br>     <br>        // TODO: Log an error here <br>     <br>    } <br> <br>    if (bResult) { <br>     <br>        // do whatever you need to complete a successful install <br> <br>        // <br>        // Refresh the desktop for folders and icons. <br>        // <br>        InstallFinish(TRUE);     <br> <br>    } else { <br> <br>        MessageBox( hWnd,  <br>            TEXT("Installation script did not complete successfully!"),  <br>            TEXT("Product Sample Install Error"),  <br>            MB_OK); <br>    } <br>     <br>    return TRUE; <br>} <br> <br>LRESULT  <br>WINAPI <br>MyQueueCallback ( <br>    IN MY_INSTALL_DATA* pMyInstallData, <br>    IN UINT Notification, <br>    IN UINT Param1, <br>    IN UINT Param2 <br>    ) <br>{ <br>    if (SPFILENOTIFY_DELETEERROR == Notification) <br>    { <br>        // Skip any file delete errors <br>        // this sample only deletes files on an unintall <br>        // so if the delete encounters an error simply skip the operation <br>        // and continue processing the queue <br>        return FILEOP_SKIP; <br>    } <br>    else <br>    { <br>        // Pass all other notifications through without modification <br>        return SetupDefaultQueueCallback(pMyInstallData-&gt;pDefaultContext,  <br>                                         Notification, Param1, Param2); <br>    } <br>} <br> <br> <br>DWORD <br>InstallFinish( <br>    IN BOOL DoRunOnce <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine sets up runonce/grpconv to run after a successful INF installation. <br> <br>Arguments: <br> <br>    DoRunOnce - If TRUE, then invoke (via WinExec) the runonce utility to perform the <br>        runonce actions.  If this flag is FALSE, then this routine simply sets the <br>        runonce registry values and returns. <br> <br>        NOTE:  The return code from WinExec is not currently being checked, so the return <br>        value of InstallStop only reflects whether the registry values were set up <br>        successfully--_not_ whether 'runonce -r' was successfully run. <br> <br>Return Value: <br> <br>    If successful, the return value is NO_ERROR, otherwise it is the Win32 error code <br>    indicating the error that was encountered. <br> <br>--*/ <br>{ <br>    HKEY  hKey, hSetupKey; <br>    DWORD Error; <br>    LONG l; <br> <br>    // <br>    // First, open the key "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" <br>    // <br>    if((l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,  <br>                         REGSTR_PATH_RUNONCE,  <br>                         0, KEY_ALL_ACCESS, &amp;hKey)) != ERROR_SUCCESS) { <br>        return (DWORD)l; <br>    } <br> <br>    // <br>    // If we need to run the runonce exe for the setup key... <br>    // <br>    if(RegOpenKeyEx(hKey, <br>                    TEXT("Setup"), <br>                    0, <br>                    KEY_READ, <br>                    &amp;hSetupKey) == ERROR_SUCCESS) { <br>        // <br>        // We don't need the key--we just needed to check its existence. <br>        // <br>        RegCloseKey(hSetupKey); <br> <br>        // <br>        // Add the runonce value. <br>        // <br>        Error = (DWORD)RegSetValueEx(hKey, <br>                                     TEXT("Wrapper"), <br>                                     0, <br>                                     REG_SZ, <br>                                     TEXT("runonce"), <br>                                     sizeof(TEXT("runonce")) <br>                                    ); <br>    } else { <br>        // <br>        // We're OK so far. <br>        // <br>        Error = NO_ERROR; <br>    } <br> <br>    // <br>    // GroupConv is always run. <br>    // <br>    if(RegSetValueEx(hKey, <br>                     TEXT("GrpConv"), <br>                     0, <br>                     REG_SZ, <br>                     TEXT("grpconv -o"), <br>                     sizeof(TEXT("grpconv -o"))) != ERROR_SUCCESS) { <br>        // <br>        // Since GrpConv is always run, consider it a more serious error than any error <br>        // encountered when setting 'runonce'.  (This decision is rather arbitrary, but <br>        // in practice, it should never make any difference.  Once we get the registry key <br>        // opened, there's no reason either of these calls to RegSetValueEx should fail.) <br>        // <br>        Error = (DWORD)l; <br>    } <br> <br>    RegCloseKey(hKey); <br> <br>    if(DoRunOnce) { <br>        WinExec("runonce -r", SW_SHOWNORMAL); <br>    } <br> <br>    return Error; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
