<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SA.CPP</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5934"></a>SA.CPP</h2>
<pre><code>// =========================================================================== <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br>// <br>//+-------------------------------------------------------------------------- <br>// <br>// File:        sa.cpp <br>// <br>// Contents:    All code needed to build the simple job submission tool <br>// <br>// Purpose:     Demonstration of calls to methods of the following new <br>//              interfaces: <br>//                  1. ITaskScheduler <br>//                  2. ITask <br>//                  3. ITaskTrigger <br>//                  4. IEnumWorkItems <br>// <br>// Comments:    This application is similar in functionality to <br>//              the "AT" command provided with Windows NT.  However, <br>//              the AT command functions through the NetSchedule APIs, <br>//              as opposed to the COM interfaces demonstrated here. <br>// <br>//              The Task Scheduler replaces ATSVC.EXE and implements <br>//              those APIs as a restricted subset of the new ones <br>//              demonstrated here. <br>// <br>//              On Win9x systems, the Task Scheduler replaces <br>//              the System Agent, providing more flexible and reliable <br>//              scheduling options than previously available. <br>//              However, although the SAGE jobs are converted <br>//              to Task Scheduler work items, the actual <br>//              SAGE API has been abandoned and is not implemented. <br>// <br>//              The Task Scheduler APIs provide a greater degree of <br>//              freedom and robustness than those APIs.  This code <br>//              demonstrates a stripped version of AT rewritten to <br>//              use the new APIs. <br>// <br>// Additional:  The Task Scheduler service must be running.  It is easily <br>//              started by the command "net start schedule" if it is not <br>//              running.  It is also trivial to start it through <br>//              the service control manager APIs. Doing it in the code <br>//              directly makes a good enhancement to the program below. <br>//  <br>//              Since there is not a service controller on Win9x,  <br>//              the user may start the service by executing the <br>//              binary directly from the command line (mstask.exe). <br>//              Win9x users will see a system tray icon if the service  <br>//              is running. <br>// <br>//              The service may also be started from the folder UI available <br>//              directly by opening "My Computer" and then opening the  <br>//              "Scheduled Tasks" folder.  The start command appears on the <br>//              "Advanced" menu. <br>// <br>//              Sample code to start and stop the service, on both  <br>//              Windows NT and Win9x based systems appears in the <br>//              documentation. <br>// <br>//              If the Task Scheduler service is not running, most  <br>//              of this program will fail to execute.  If there are  <br>//              tasks waiting to execute after login, the service  <br>//              will have been started by default. <br>//              <br>//--------------------------------------------------------------------------- <br> <br>#include &lt;wchar.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;mbctype.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;mstask.h&gt; <br>#include &lt;msterr.h&gt; <br> <br>//+-------------------------------------------------------------------------- <br>// Global variables <br>//--------------------------------------------------------------------------- <br> <br>ITaskScheduler *g_pITaskScheduler = NULL; <br> <br>//+-------------------------------------------------------------------------- <br>// Function Prototypes <br>//--------------------------------------------------------------------------- <br> <br>HRESULT Init(void); <br>void Cleanup(void); <br>void DisplayHelp(LPWSTR); <br>HRESULT EnumerateJobs(void); <br>HRESULT DeleteJob(LPWSTR); <br>HRESULT AddJob(LPWSTR, LPSYSTEMTIME, LPWSTR, LPWSTR, LPWSTR); <br>HRESULT ConvertToSystemTime(LPWSTR, LPSYSTEMTIME); <br> <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:        main <br>// <br>// Synopsis:        Entry point for code.  Parses command line, <br>//                  and calls appropriate subfunction as a result. <br>// <br>//  Arguments:      See DisplayHelp().  Uses argv, argc to get  <br>//                  command line args. <br>// <br>//  Returns:        S_OK for success or the failure code for failure. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LONG _CRTAPI1 main (int argc, char **argv) <br>{ <br>    HRESULT hr = S_OK; <br>    UINT uCodePage; <br>    char *lpcszDeleteFlag = "/DELETE"; <br>    WCHAR lpwszJobName[255], lpwszTime[32]; <br>    WCHAR lpwszUserName[64], lpwszPassword[64], lpwszCommand[255]; <br>    WCHAR lpwszProgName[255]; <br>    SYSTEMTIME tTime; <br> <br>    // For protection <br> <br>    g_pITaskScheduler = NULL; <br> <br>    // String conversion initialization <br> <br>    uCodePage = _getmbcp(); <br>    <br>    MultiByteToWideChar(uCodePage, 0, argv[0], <br>                        -1, lpwszProgName, <br>                        255); <br> <br>    // Check number of command line arguments. <br>    //      1 argument      =   enumerate work items  <br>    //      2 args          =   display help (don't init OLE) <br>    //      3 args          =   delete work item  <br>    //      4, 5 or 6 args  =   add a work item  <br>    //      all others      =   error, display help <br> <br>    if ((argc == 2) || (argc &gt; 6)) <br>    { <br>        DisplayHelp(lpwszProgName); <br>        return hr; <br>    } <br> <br>    // Attempt to initialize OLE and fill in the global g_pITaskScheduler <br> <br>    hr = Init(); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: OLE initialization and instantiation failed\n"); <br>        return hr; <br>    } <br>     <br>    switch(argc) <br>    { <br>        case 1: <br>            // User would like to enumerate work items  <br> <br>            hr = EnumerateJobs(); <br>            break; <br> <br>        case 3: <br>            if (! lstrcmpiA(argv[2], lpcszDeleteFlag)) <br>            { <br>                // User would like to delete work item in argv[1] <br> <br>                MultiByteToWideChar(uCodePage, 0, argv[1],  <br>                                    -1, lpwszJobName, <br>                                    255); <br> <br>                hr = DeleteJob(lpwszJobName); <br>            } <br>            else <br>            { <br>                // User has made an error in command line args                 <br>                 <br>                wprintf(L"Error: Must be %s taskname.job /DELETE\n", lpwszProgName); <br>                wprintf(L"\n %s /?  for more help.\n", lpwszProgName); <br>                 <br>                Cleanup(); <br>                return E_FAIL; <br>            } <br>            break; <br> <br>        case 4: <br>        case 5: <br>        case 6: <br>            // User would like to add a work item.  The following <br>            // argument cases apply: <br>            //      4 - User has specified work item name, but not given  <br>            //          username or password.  Will prompt later. <br>            //      5 - User has specified work item name and username, <br>            //          but no password.  Will prompt later.             <br>            //      6 - User has specified all information. <br>             <br>                uCodePage = _getmbcp(); <br>     <br>                MultiByteToWideChar(uCodePage, 0, argv[1],  <br>                                    -1, lpwszJobName, <br>                                    255); <br>                MultiByteToWideChar(uCodePage, 0, argv[2], <br>                                    -1, lpwszTime, <br>                                    32); <br> <br>            hr = ConvertToSystemTime(lpwszTime, &amp;tTime); <br>            if (FAILED(hr)) <br>            { <br>                wprintf(L"Error: Conversion of command line time to system time failed.\n"); <br>                Cleanup(); <br>                return hr; <br>            } <br>             <br>            *lpwszUserName = L'\0'; <br>            *lpwszPassword = L'\0'; <br> <br>            MultiByteToWideChar(uCodePage, 0, argv[3], <br>                                -1, lpwszCommand, <br>                                255); <br> <br>            if (argc &gt; 4) <br>            { <br> <br>                MultiByteToWideChar(uCodePage, 0, argv[4], <br>                                    -1, lpwszUserName, <br>                                    64); <br>            } <br>            if (argc == 6) <br>            { <br> <br>                MultiByteToWideChar(uCodePage, 0, argv[5], <br>                                    -1, lpwszPassword, <br>                                    64); <br>            } <br>             <br>            hr = AddJob(lpwszJobName, &amp;tTime, lpwszCommand, lpwszUserName, lpwszPassword); <br>             <br>            break; <br> <br>        default: <br>            hr = E_FAIL; <br>            DisplayHelp(lpwszProgName); <br>    } <br>     <br>    Cleanup(); <br>    return hr; <br>} <br> <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:        Init() <br>// <br>// Synopsis:        Called to initialize and instantiate a task  <br>//                  scheduler object. <br>// <br>// Arguments:       none (void) <br>// <br>// Returns:         HRESULT indicating success or failure.  S_OK on success. <br>// <br>// Side effect:     Sets global pointer g_pITaskScheduler, for use in other <br>//                  functions.   <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT Init() <br>{ <br>    HRESULT hr = S_OK; <br> <br>    // Bring in the library <br> <br>    hr = CoInitialize(NULL); <br>    if (FAILED(hr)) <br>    { <br>        return hr; <br>    } <br> <br>    // Create the pointer to Task Scheduler object <br>    // CLSID from the header file mstask.h <br> <br>    hr = CoCreateInstance( <br>        CLSID_CTaskScheduler, <br>        NULL, <br>        CLSCTX_INPROC_SERVER, <br>        IID_ITaskScheduler, <br>        (void **) &amp;g_pITaskScheduler); <br> <br>    // Should we fail, unload the library <br> <br>    if (FAILED(hr)) <br>    { <br>        CoUninitialize(); <br>    } <br> <br>    return hr; <br>} <br> <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:    Cleanup() <br>// <br>// Synopsis:    Called to clean up OLE, memory, etc. before termination <br>// <br>// Arguments:   none (void) <br>// <br>// Returns:     nothing (void) <br>// <br>// Side effect: Cancels the global pointer g_pITaskScheduler. <br>// <br>//--------------------------------------------------------------------------- <br> <br>void Cleanup() <br>{ <br>    if (g_pITaskScheduler) <br>    { <br>        g_pITaskScheduler-&gt;Release(); <br>        g_pITaskScheduler = NULL; <br>    } <br>    <br>    // Unload the library, now that our pointer is freed. <br> <br>    CoUninitialize(); <br>    return; <br>} <br> <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:    DisplayHelp()  <br>// <br>// Synopsis:    Prints out help and usage information <br>// <br>// Arguments:   lpwszProgName - a pointer to a WSTR containing argv[0] <br>// <br>// Returns:     nothing (void) <br>// <br>//--------------------------------------------------------------------------- <br> <br>void DisplayHelp(LPWSTR lpwszProgName) <br>{ <br>    wprintf(L"%s -- a small program to replicate some\n", lpwszProgName);  <br>    wprintf(L"\tfunctionality of the AT command, using the\n"); <br>    wprintf(L"\tnew Task Scheduler interfaces.\n\n"); <br> <br>    wprintf(L"Usage:\n"); <br>    wprintf(L"\t%s /?\n\t\t\t\t\t\t- Display this help\n",lpwszProgName); <br>    wprintf(L"\t%s\n\t\t\t\t\t\t- Show all work items\n",lpwszProgName); <br>    wprintf(L"\t%s TaskName.job /DELETE \n\t\t\t\t\t\t- delete work item\n",lpwszProgName); <br>    wprintf(L"\t%s TaskName.job Time Command [UserName [Password]]\n\t\t\t\t\t\t- submit a new work item\n\n",lpwszProgName); <br> <br>    wprintf(L"TaskName.job is the name of the work item object on disk.\n"); <br>    wprintf(L"The work item will appear in the Scheduled Tasks folder as TaskName\n"); <br>    wprintf(L"but must be given the extension \".job\" for the service \n"); <br>    wprintf(L"to recognize and run it.\n\n"); <br> <br>    wprintf(L"Task Time is in 24 hour format (such as 15:30) and is the\n"); <br>    wprintf(L"next instance of this time within 24 hours.\n\n"); <br>     <br>    wprintf(L"The Command should contain the name of the executable to run.\n"); <br>    wprintf(L"Note that the pathname may NOT contain spaces.  If the\n"); <br>    wprintf(L"program requires command line parameters, enclose the entire\n"); <br>    wprintf(L"command string in quotation marks.\n\n"); <br> <br>    wprintf(L"Username and password are required to run the specified work item under Windows NT.\n"); <br>    wprintf(L"Under Windows NT, if not specified, you will be prompted.\n"); <br>    wprintf(L"Under Windows 95, both fields are ignored.  If not specified\n"); <br>    wprintf(L"on the command line, you will not be prompted.\n\n"); <br>     <br>    return; <br>} <br>  <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:    EnumerateJobs() <br>// <br>// Synopsis:    Goes through all scheduled work items on a system and  <br>//              lists them, along with a short trigger string. <br>// <br>// Arguments:   none (void).  Requires g_pITaskScheduler. <br>// <br>// Returns:     HRESULT indicating success (S_OK) or other. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT EnumerateJobs() <br>{ <br>    HRESULT hr = S_OK, hrLoop = S_OK; <br>    IEnumWorkItems *pIEnumWorkItems; <br>    IUnknown *pIU; <br>    ITask *pITask; <br>    ULONG ulTasksToGet = 1, ulActualTasksRetrieved = 0; <br>    LPWSTR *rgpwszNames, pwszTrigger; <br>    WORD wTrigCount = 0; <br>    WORD wTemp; <br> <br>     <br>    // <br>    // Get an enumeration pointer, using ITaskScheduler::Enum <br>    // <br> <br>    hr = g_pITaskScheduler-&gt;Enum(&amp;pIEnumWorkItems); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Failed to get enumerator\n"); <br>        return hr; <br>    } <br> <br>    do <br>    { <br>        // Get a single work item, using IEnumWorkItems::Next <br> <br>        hrLoop = pIEnumWorkItems-&gt;Next(ulTasksToGet, &amp;rgpwszNames, <br>                                       &amp;ulActualTasksRetrieved); <br>        if (hrLoop == S_FALSE) <br>        { <br>            // There are no more waiting tasks to look at <br>            break; <br>        } <br> <br>        // Attach to the work item, using ITaskScheduler::Activate <br> <br>        hr = g_pITaskScheduler-&gt;Activate(rgpwszNames[0], IID_ITask, &amp;pIU); <br>        if (FAILED(hr)) <br>        { <br>            wprintf(L"Error: Activate Failed\n",hr); <br>            break; <br>        } <br> <br>        // QI pIU for pITask <br>    <br>        hr = pIU-&gt;QueryInterface(IID_ITask, (void **) &amp;pITask); <br>        pIU-&gt;Release(); <br>        pIU = NULL; <br>        if (FAILED(hr)) <br>        { <br>            wprintf(L"Error: QI for ITask failed in Activate.\n"); <br>            break; <br>        } <br> <br>        // Display task name <br> <br>        wprintf(L"Task: %s\n",rgpwszNames[0]);  <br> <br>        // Use ITask::GetTriggerCount to get count of triggers <br> <br>        hr = pITask-&gt;GetTriggerCount(&amp;wTrigCount); <br>        if (FAILED(hr)) <br>        { <br>            wprintf(L"Error: Failed to count triggers\n"); <br>            pITask-&gt;Release(); <br>            break; <br>        } <br>         <br>        for (wTemp = 0; wTemp &lt; wTrigCount; wTemp++) <br>        { <br>            // Dump Triggers using ITask::GetTriggerString <br> <br>            hr = pITask-&gt;GetTriggerString(wTemp, &amp;pwszTrigger); <br>            if (FAILED(hr)) <br>            { <br>                wprintf(L"Error: Failed to get trigger string\n"); <br>                pITask-&gt;Release(); <br>                break; <br>            } <br> <br>            wprintf(L"\tTrigger: %s\n",pwszTrigger); <br> <br>            // Clean up the memory we were allocated for trig string <br> <br>            CoTaskMemFree(pwszTrigger); <br>        } <br> <br>        // Clean up each element in the array of job names, then <br>        // clean up the final array. <br> <br>        CoTaskMemFree(rgpwszNames[0]); <br>        CoTaskMemFree(rgpwszNames); <br>         <br>        // Free the ITask pointer <br>     <br>        pITask-&gt;Release(); <br> <br>    } while(1); <br> <br>    // Release the enumeration pointer <br>     <br>    pITask = NULL; <br> <br>    pIEnumWorkItems-&gt;Release(); <br>    pIEnumWorkItems = NULL; <br> <br>    return hr;  <br>}     <br>     <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:        DeleteJob() <br>// <br>// Synopsis:        Deletes a work item from the Scheduled Tasks folder. <br>// <br>// Arguments:       lpwszJobName - the name of the work item to delete <br>// <br>// Returns:         HRESULT indicating success (S_OK) or failure. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT DeleteJob(LPWSTR lpwszJobName) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    hr = g_pITaskScheduler-&gt;Delete(lpwszJobName); <br> <br>    return hr; <br>} <br> <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:        AddJob() <br>// <br>// Synopsis:        Adds a new work item to the Scheduled Tasks folder. <br>// <br>// Arguments:       lpwszJobName - name of the task file <br>//                  lptTime      - pointer to SYSTEMTIME struct containing <br>//                                      the time the job should run. <br>//                  lpwszCommand - name of application (command) to run. <br>//                  lpwszUserName- user name to run job under <br>//                  lpwszPassword- password for that user <br>// <br>// Returns:         HRESULT indicating success (S_OK) or failure. <br>// <br>// Notes:           The password or BOTH the username and password <br>//                  may be passed in as '\0' strings, in which case <br>//                  this function will prompt on stdout for password <br>//                  and username <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT AddJob(LPWSTR lpwszJobName, LPSYSTEMTIME lptTime, <br>                LPWSTR lpwszCommand, LPWSTR lpwszUserName, <br>                LPWSTR lpwszPassword) <br>{ <br>    HRESULT hr = S_OK; <br>    IUnknown *pIU; <br>    IPersistFile *pIPF; <br>    ITask *pITask; <br>    ITaskTrigger *pITaskTrig; <br>    DWORD dwTaskFlags, dwTrigFlags; <br>    WORD wTrigNumber; <br>    TASK_TRIGGER TaskTrig; <br>    WCHAR lpwszAppName[255]; <br>    int i; <br>     <br>    // Add the task.  Most likely failure is that work item already exists. <br>    // Uses ITaskScheduler::NewWorkItem <br> <br>    hr = g_pITaskScheduler-&gt;NewWorkItem(lpwszJobName,  <br>                                        CLSID_CTask,  <br>                                        IID_ITask,  <br>                                        &amp;pIU); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error:  Create New Task failure\n"); <br>        return hr; <br>    } <br> <br>    // We now have an IUnknown pointer.  This is queried for an ITask <br>    // pointer on the work item we just added. <br>     <br>    hr = pIU-&gt;QueryInterface(IID_ITask, (void **) &amp;pITask); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: IUnknown failed to yield ITask\n"); <br>        pIU-&gt;Release(); <br>        return hr; <br>    } <br>     <br>    // Cleanup pIUnknown, as we are done with it. <br>     <br>    pIU-&gt;Release(); <br>    pIU = NULL; <br> <br>    // <br>    // We need to see if we support security, and we <br>    // do this by calling ITask::SetAccountInformation <br>    // and checking if the failure code is SCHED_E_NO_SECURITY_SERVICES <br>    // <br> <br>    hr = pITask-&gt;SetAccountInformation(lpwszUserName, lpwszPassword); <br>    if (hr != SCHED_E_NO_SECURITY_SERVICES) <br>    { <br>     <br>        // Check to see if username is null <br> <br>        if (*lpwszPassword == L'\0') <br>        { <br>            // If password was null, chance username is, too. <br> <br>            if (*lpwszUserName == L'\0') <br>            { <br>                wprintf(L"Enter username to run job %s as: ",lpwszJobName); <br>                wscanf(L"%s",lpwszUserName); <br>                wprintf(L"\n"); <br>            } <br>     <br>            wprintf(L"Enter password to user %s: ",lpwszUserName); <br>            wscanf(L"%s",lpwszPassword); <br>            wprintf(L"\n"); <br>        } <br>    } <br> <br>    // Set the account information using ITask::SetAccountInformation <br>    // This fails for Win9x, but we ignore the failure. <br> <br>    hr = pITask-&gt;SetAccountInformation(lpwszUserName, lpwszPassword); <br>    if ((FAILED(hr)) &amp;&amp; (hr != SCHED_E_NO_SECURITY_SERVICES)) <br>    { <br>        wprintf(L"Error: Failed to set credentials on task object %x\n",hr); <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br> <br>    // Extract parameters from the application name <br>    // Note that there might not be any parameters at all. <br>    // We butcher a path like C:\Program Files\foo.exe, because <br>    // we break on space, but this is ok, because user could say <br>    // C:\progra~1\foo.exe instead. <br> <br>    i = 0; <br>    while ((*lpwszCommand != L' ') &amp;&amp; (*lpwszCommand != '\0')) <br>    { <br>        lpwszAppName[i] = *lpwszCommand; <br>        i++; <br>        lpwszCommand++; <br>    } <br>    lpwszAppName[i] = L'\0'; <br>    if (*lpwszCommand == L' ') <br>    { <br>        lpwszCommand++; <br>    } <br>     <br>    // Set command name with ITask::SetApplicationName <br> <br>    hr = pITask-&gt;SetApplicationName(lpwszAppName); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Failed to set command name (with parms)\n");  <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br> <br> <br>    // Set task parameters with ITask::SetParameters <br> <br>    hr = pITask-&gt;SetParameters(lpwszCommand); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Failed to set parameters\n"); <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br>         <br>    // Set the comment, so we know how this job go there <br>    // Uses ITask::SetComment <br> <br>    hr = pITask-&gt;SetComment(L"This scheduled task created by command line SDK sample tool"); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Task comment could not be set\n"); <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br> <br>    // Set the flags on the task object <br>    // Use ITask::SetFlags <br> <br>    dwTaskFlags = TASK_FLAG_DELETE_WHEN_DONE; <br>    hr = pITask-&gt;SetFlags(dwTaskFlags); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Could not set task flags\n"); <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br> <br>    // Now, create a trigger to run the task at our specified time. <br>    // Uses ITask::CreateTrigger() <br> <br>    hr = pITask-&gt;CreateTrigger(&amp;wTrigNumber, &amp;pITaskTrig); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Could not create a new trigger\n"); <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br> <br>    // Now, fill in the trigger as necessary. <br> <br>    dwTrigFlags = 0; <br> <br>    TaskTrig.cbTriggerSize = sizeof(TASK_TRIGGER); <br>    TaskTrig.Reserved1 = 0; <br>    TaskTrig.wBeginYear = lptTime-&gt;wYear; <br>    TaskTrig.wBeginMonth = lptTime-&gt;wMonth; <br>    TaskTrig.wBeginDay = lptTime-&gt;wDay; <br>    TaskTrig.wEndYear = 0; <br>    TaskTrig.wEndMonth = 0; <br>    TaskTrig.wEndDay = 0; <br>    TaskTrig.wStartHour = lptTime-&gt;wHour; <br>    TaskTrig.wStartMinute = lptTime-&gt;wMinute; <br>    TaskTrig.MinutesDuration = 0; <br>    TaskTrig.MinutesInterval = 0; <br>    TaskTrig.rgFlags = dwTrigFlags; <br>    TaskTrig.TriggerType = TASK_TIME_TRIGGER_ONCE; <br>    TaskTrig.wRandomMinutesInterval = 0; <br>    TaskTrig.Reserved2 = 0; <br> <br>    // Add this trigger to the task using ITaskTrigger::SetTrigger <br> <br>    hr = pITaskTrig-&gt;SetTrigger(&amp;TaskTrig); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Failed to set trigger to desired values\n"); <br>        pITaskTrig-&gt;Release(); <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br> <br>    // Make the changes permanent <br>    // Requires using IPersistFile::Save() <br> <br>    hr = pITask-&gt;QueryInterface(IID_IPersistFile, (void **) &amp;pIPF);  <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Could not get IPersistFile on task\n"); <br>        pITaskTrig-&gt;Release(); <br>        pITask-&gt;Release(); <br>        return hr; <br>    } <br> <br>    hr = pIPF-&gt;Save(NULL, FALSE); <br>    if (FAILED(hr)) <br>    { <br>        wprintf(L"Error: Could not save object\n"); <br>        pITaskTrig-&gt;Release(); <br>        pITask-&gt;Release(); <br>        pIPF-&gt;Release(); <br>        return hr; <br>    } <br> <br>    // We no longer need ITask <br>     <br>    pITask-&gt;Release(); <br>    pITask = NULL; <br> <br>    // Done with ITaskTrigger pointer <br>     <br>    pITaskTrig-&gt;Release(); <br>    pITaskTrig = NULL; <br> <br>    // Done with IPersistFile <br>     <br>    pIPF-&gt;Release(); <br>    pIPF = NULL; <br> <br>    return hr; <br>}  <br> <br> <br>//+-------------------------------------------------------------------------- <br>// <br>// Function:        ConvertToSystemTime() <br>// <br>// Synopsis:        Given a text string from the command line of the form <br>//                  XX:YY where XX = 0 - 23, and YY = 0 - 59, <br>//                  obtain the next instance in 24 hours of said time <br>//                  and return this time in a SYSTEMTIME structure <br>//                  so that it can be used to set triggers <br>// <br>// Arguments:       lpwszTime    -   The text string of time <br>//                  lptTime     -   The SYSTEMTIME pointer <br>// <br>// Returns:         HRESULT of success (S_OK) or failure <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT ConvertToSystemTime(LPWSTR lpwszTime, LPSYSTEMTIME lptTime) <br>{ <br>    WORD wMin = 0, wHr = 0, wMaxFeb = 28; <br>    WCHAR szTemp[3], *szEnd1, *szEnd2; <br>    SYSTEMTIME tNow; <br>    int i, j; <br> <br>    // Extract minutes and hour from string <br> <br>    if ((wcslen(lpwszTime) &gt; 5) || (wcslen(lpwszTime) &lt; 4)) <br>    { <br>        wprintf(L"Error: Invalid time string given\n"); <br>        return E_FAIL; <br>    } <br> <br>    // Hours first. <br>     <br>    i = 0; <br>    while (*lpwszTime != ':') <br>    { <br>        szTemp[i] = *lpwszTime; <br>        i++; <br>        if (i &gt; 2) <br>        { <br>            // User gave a bad time string <br>            wprintf(L"Error: Bad hours in time string\n"); <br>            return E_FAIL; <br>        } <br>        lpwszTime++; <br>    } <br>    szTemp[i] = L'\0'; <br>    lpwszTime++; <br>  <br>    // Convert to value <br> <br>    wHr = (WORD) wcstoul(szTemp, &amp;szEnd1, 10); <br>     <br>    // Now do minutes <br>  <br>    i = wcslen(lpwszTime); <br>    j = 0; <br>    while (i) <br>    { <br>        szTemp[j] = *lpwszTime; <br>        j++; <br>        i--; <br>        lpwszTime++; <br>    } <br>    szTemp[j] = L'\0'; <br> <br>    wMin = (WORD) wcstoul(szTemp, &amp;szEnd2, 10); <br> <br>    // Now figure out if we are running today or tomorrow <br>     <br>    GetLocalTime(&amp;tNow); <br>    if ((wHr &lt; tNow.wHour) ||  <br>       ((wHr == tNow.wHour) &amp;&amp; (wMin &lt; tNow.wMinute))) <br>    { <br>        // Job is tomorrow - we must figure out what tomorrow is <br>         <br>        switch(tNow.wMonth) <br>        { <br>            case 4: <br>            case 6: <br>            case 9: <br>            case 11: <br>                // Thirty day months <br>                 <br>                if ((tNow.wDay + 1) &gt; 30) <br>                { <br>                    tNow.wDay = 1; <br>                    tNow.wMonth++; <br>                } <br>                else <br>                { <br>                    tNow.wDay++; <br>                } <br>                break; <br> <br>            case 2: <br>                // February <br>                // Leap Year? <br>                 <br>                if ((tNow.wYear % 4) == 0)  <br>                { <br>                    wMaxFeb = 29; <br>                } <br>                if (((tNow.wYear % 100) == 0) &amp;&amp; <br>                    ((tNow.wYear % 400) != 0)) <br>                { <br>                    wMaxFeb = 28; <br>                } <br> <br>                if ((tNow.wDay + 1) &gt; wMaxFeb) <br>                { <br>                    tNow.wDay = 1; <br>                    tNow.wMonth++; <br>                } <br>                else <br>                { <br>                    tNow.wDay++; <br>                } <br>                break; <br> <br>            default: <br>                // 31 day months.  Handle Dec. later <br>                 <br>                if ((tNow.wDay + 1) &gt; 31) <br>                { <br>                    tNow.wDay = 1; <br>                    tNow.wMonth++; <br>                } <br>                else <br>                { <br>                    tNow.wDay++; <br>                } <br>                 <br>                if (tNow.wMonth &gt; 12) <br>                { <br>                    tNow.wMonth = 1; <br>                    tNow.wYear++; <br>                } <br>        } <br>    } <br> <br>    if ((wMin &lt; 0) || (wMin &gt; 59)) <br>    { <br>        wprintf(L"Error: Invalid minutes (need 0 - 59)\n"); <br>        return E_FAIL; <br>    } <br>    else <br>    { <br>        tNow.wMinute = wMin; <br>    } <br>    if ((wHr &lt; 0) || (wHr &gt; 23)) <br>    { <br>        wprintf(L"Error: Invalid hours (need 0 - 23)\n"); <br>        return E_FAIL; <br>    } <br>    else <br>    { <br>        tNow.wHour = wHr; <br>    } <br> <br>    lptTime-&gt;wHour = tNow.wHour; <br>    lptTime-&gt;wMinute = tNow.wMinute; <br>    lptTime-&gt;wYear = tNow.wYear; <br>    lptTime-&gt;wMonth = tNow.wMonth; <br>    lptTime-&gt;wDay = tNow.wDay; <br>    lptTime-&gt;wDayOfWeek = 0; <br>    lptTime-&gt;wSecond = 0; <br>    lptTime-&gt;wMilliseconds = 0; <br>    return S_OK; <br>}  <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
