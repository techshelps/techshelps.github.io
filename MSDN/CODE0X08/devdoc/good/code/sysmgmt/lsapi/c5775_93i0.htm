<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHALLENG.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5778"></a>CHALLENG.C</h2>
<pre><code>/* <br> *  This is a part of the Microsoft Source Code Samples. <br> *  Copyright 1996 - 1998 Microsoft Corporation. <br> *  All rights reserved. <br> * <br> *  The following example demonstrates how license updates are made and <br> *  how the challenge mechanism is used at request and update times.  The <br> *  application developer should analyze the application to determine the <br> *  appropriate time to perform an update.  For example, this application <br> *  prints a message 20 times and the appropriate time to do an update <br> *  was decided to be done after every 5th message was printed. <br> */ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;time.h&gt; <br>#include "windows.h" <br> <br>/* <br> * Include the MD4 header for computing the challenge. <br> */ <br>#include "md4.h" <br> <br>/* <br> * Include the LSAPI header file. <br> */ <br>#include "lsapi.h" <br> <br>/* <br> * Define the product name, product version, and publisher name for <br> * use with the licensing calls. <br> */ <br>#define MYAPP_PRODUCT_NAME    "sample_product" <br>#define MYAPP_PRODUCT_VERSION "2.0" <br>#define MYAPP_PUBLISHER_NAME  "sample_publishers" <br> <br> <br>/* <br> * Define the strings used to log a comment with the license system. <br> */ <br>#define MYAPP_REQUEST_LOG_COMMENT "Comment for the LSRequest call" <br>#define MYAPP_RELEASE_LOG_COMMENT "Comment for the LSRelease call" <br>#define MYAPP_UPDATE_LOG_COMMENT  "Comment for the LSUpdate call" <br> <br>/* <br> * The digest length is defined to be 16 according to the LSAPI spec. <br> */ <br>#define DIGESTLEN                16 <br> <br>/* <br> * Define the number of secrets <br> */ <br>#define NUMBER_OF_SECRETS         4 <br> <br>/* <br> * Define macros to indicate to the challenge routines whether we are <br> * doing an LSRequest or an LSUpdate <br> */ <br>#define LS_REQUEST 0 <br>#define LS_UPDATE  1 <br> <br>/* <br> * Global variable used to determine if we are on a little endian machine <br> * or not. <br> */ <br>int          littleEndian = 0; <br> <br> <br>/* <br> * Forward declarations. <br> */ <br>void PrintErrors( LS_HANDLE handle, LS_STATUS_CODE errorCode ); <br>LS_STATUS_CODE getChallenge( <br>      LS_CHALLENGE    FAR *challenge, <br>      LS_STR          FAR *theString, <br>      LS_ULONG        unitsConsumed, <br>      LS_ULONG        unitsReserved, <br>      LS_STR          FAR *logcomment, <br>      LS_ULONG        R, <br>      LS_ULONG        X, <br>      LS_ULONG        typeOfCall); <br>int checkChallenge( <br>      LS_CHALLENGE    FAR *challenge, <br>      LS_STR          FAR *theString, <br>      LS_ULONG        unitsConsumed , <br>      LS_ULONG        unitsReserved , <br>      LS_STR          FAR *logComment , <br>      LS_ULONG        unitsGranted , <br>      LS_STATUS_CODE  status , <br>      LS_ULONG        R, <br>      LS_ULONG        X, <br>      LS_ULONG        typeOfCall); <br>void swap( LS_STR FAR *byte1, LS_STR FAR *byte2 ); <br>int PlaceInt( char FAR *buffer, LS_ULONG value ); <br> <br> <br> <br> <br> <br>__cdecl main() <br>{ <br>   LS_STATUS_CODE     status; <br>   unsigned long      unitsGranted = 0; <br>   LS_CHALLENGE       challenge; <br>   LS_HANDLE          licenseHandle = (LS_HANDLE) NULL; <br>   LS_ULONG           R; <br>   LS_ULONG           X; <br>   int                i; <br>   int                endianTester = 1 ; <br>   LS_STR             challengeString[100]; <br>   char               FAR *endianChar = NULL; <br>   LS_ULONG           Secrets[4] = { 0x7778797A, 0x31323334, 1633837924, 926431536 }; <br> <br>   /************ the following code is for the LSAPI beta only! ************/ <br>   char               szProviderPath[ MAX_PATH ]; <br>   UINT               nChars; <br> <br>   /* install if necessary */ <br>   nChars = GetSystemDirectory( szProviderPath, sizeof( szProviderPath ) ); <br>   if ( 0 == nChars ) <br>   { <br>      printf( "Can't get system directory, error %d.\n", GetLastError() ); <br>   } <br> <br>   lstrcat( szProviderPath, "\\mslsp32.dll" ); <br>   status = LSInstall( szProviderPath ); <br>   if ( LS_SUCCESS != status ) <br>   { <br>      printf( "Cannot install LSAPI, error 0x%08lx.\n", status ); <br>   } <br> <br>   /* add licenses for our product */ <br>   status = LSLicenseUnitsSet( LS_ANY, <br>                               MYAPP_PUBLISHER_NAME, <br>                               MYAPP_PRODUCT_NAME, <br>                               MYAPP_PRODUCT_VERSION, <br>                               LS_LICENSE_TYPE_NODE, <br>                               LS_NULL, <br>                               1, <br>                               sizeof( Secrets ) / sizeof( *Secrets ), <br>                               Secrets ); <br>   if ( LS_SUCCESS != status ) <br>   { <br>      printf( "Cannot install licenses, error 0x%lx.\n", status ); <br>   } <br>   /************ the above code is for the LSAPI beta only! ************/ <br> <br>   /* <br>    * test endianness and set global variable by casting an int <br>    * as bytes and look at the first byte <br>    */ <br>   endianChar = (char FAR *) &amp;endianTester ; <br>   if ( *endianChar ) <br>        littleEndian = 1 ; <br> <br>   /* <br>    * Calculate the string for the challenge on the LSRequest call. <br>    */ <br>   sprintf( challengeString, "%s%s%s%s%s", <br>            "LSRequest", <br>            LS_ANY, <br>            MYAPP_PUBLISHER_NAME, <br>            MYAPP_PRODUCT_NAME, <br>            MYAPP_PRODUCT_VERSION ); <br> <br>   /* <br>    * Pick the random number R and randomly pick a number for the index X <br>    * between 1 and the number of secrets. <br>    */ <br>   srand( (unsigned)time( NULL ) ); <br>   R = rand(); <br>   X = (int)(NUMBER_OF_SECRETS * ((float)rand()/(float)RAND_MAX)) + 1; <br> <br>   /* <br>    * Calculate the message digest for the challenge argument. <br>    */ <br>   status = getChallenge( <br>         &amp;challenge, <br>         challengeString, <br>         0,                    /* Unused argument for LSRequest call */ <br>         LS_DEFAULT_UNITS, <br>         MYAPP_REQUEST_LOG_COMMENT, <br>         R, <br>         X, <br>         LS_REQUEST ); <br>   if ( LS_SUCCESS != status ) <br>      { <br>      PrintErrors( licenseHandle, status ); <br>      return(1); <br>      } <br> <br>   /* <br>    * Make the grant request call <br>    */ <br>   status = LSRequest( <br>         (LS_STR FAR *) LS_ANY, <br>         (LS_STR FAR *) MYAPP_PUBLISHER_NAME, <br>         (LS_STR FAR *) MYAPP_PRODUCT_NAME, <br>         (LS_STR FAR *) MYAPP_PRODUCT_VERSION, <br>         LS_DEFAULT_UNITS, <br>         (LS_STR FAR *) MYAPP_REQUEST_LOG_COMMENT, <br>         &amp;challenge, <br>         &amp;unitsGranted, <br>         &amp;licenseHandle); <br>   if ( LS_SUCCESS != status ) <br>      { <br>      PrintErrors( licenseHandle, status ); <br>      LSFreeHandle( licenseHandle ); <br>      return(1); <br>      } <br> <br>   /* <br>    * Check whether the challenge succeeded. <br>    */ <br>   if ( !checkChallenge( <br>         &amp;challenge, <br>         challengeString, <br>         0,                    /* Unused argument for LSRequest call */ <br>         LS_DEFAULT_UNITS, <br>         MYAPP_REQUEST_LOG_COMMENT, <br>         unitsGranted, <br>         status, <br>         R, <br>         X, <br>         LS_REQUEST ) ) <br>      { <br>      printf("Challenge failed!!!\n"); <br>      /* <br>       * Since we failed, we should still release the grant and free <br>       * the license handle. <br>       */ <br>      status = LSRelease( licenseHandle, <br>                          LS_DEFAULT_UNITS, <br>                          (LS_STR FAR *) MYAPP_RELEASE_LOG_COMMENT); <br>      if ( LS_SUCCESS != status ) <br>         PrintErrors( licenseHandle, status ); <br> <br>      LSFreeHandle( licenseHandle ); <br>      return(1); <br>      } <br> <br>   /* <br>    * Now we can start the application.  Print "Hello, World" 20 times <br>    * performing an update after every 5th time. <br>    */ <br>   for ( i = 0; i&lt;20; i++ ) <br>      { <br>      printf("Hello, World.\n"); <br> <br>      if ( 0 == i%5 ) <br>         { <br>         /* <br>          * Calculate the challenge string for the challenge on <br>          * the LSUpdate call. <br>          */ <br>         sprintf( challengeString, "%s", "LSUpdate"); <br> <br>         /* <br>          * Pick the random number R using the process id for the seed <br>          * to the random number generator.  Also randomly pick a number <br>          * for the index X between 1 and NUMBER_OF_SECRETS. <br>          */ <br>         srand( (unsigned)time( NULL ) ); <br>         R = rand(); <br>         X = (int)(NUMBER_OF_SECRETS * ((float)rand()/(float)RAND_MAX)) + 1; <br> <br>         /* <br>          * Calculate the message digest for the challenge argument. <br>          */ <br>         status = getChallenge( <br>               &amp;challenge, <br>               challengeString, <br>               LS_DEFAULT_UNITS, <br>               LS_DEFAULT_UNITS, <br>               MYAPP_UPDATE_LOG_COMMENT, <br>               R, <br>               X, <br>               LS_UPDATE ); <br>         if ( LS_SUCCESS != status ) <br>            { <br>            PrintErrors( licenseHandle, status ); <br>            status = LSRelease( licenseHandle, <br>                                LS_DEFAULT_UNITS, <br>                                (LS_STR FAR *) MYAPP_RELEASE_LOG_COMMENT); <br>            LSFreeHandle( licenseHandle ); <br>            return(1); <br>            } <br> <br>         /* <br>          * Make the update call. <br>          */ <br>         status = LSUpdate( licenseHandle, <br>                            LS_DEFAULT_UNITS, <br>                            LS_DEFAULT_UNITS, <br>                            (LS_STR FAR *) MYAPP_UPDATE_LOG_COMMENT, <br>                            &amp;challenge, <br>                            &amp;unitsGranted); <br>         if ( LS_SUCCESS != status ) <br>            { <br>            PrintErrors( licenseHandle, status ); <br>            status = LSRelease( licenseHandle, <br>                                LS_DEFAULT_UNITS, <br>                                (LS_STR FAR *) MYAPP_RELEASE_LOG_COMMENT); <br>            LSFreeHandle( licenseHandle ); <br>            return( 1 ); <br>            } <br> <br>         /* <br>          * Check whether the challenge succeeded. <br>          */ <br>         if ( !checkChallenge( <br>               &amp;challenge, <br>               challengeString, <br>               LS_DEFAULT_UNITS, <br>               LS_DEFAULT_UNITS, <br>               MYAPP_UPDATE_LOG_COMMENT, <br>               unitsGranted, <br>               status, <br>               R, <br>               X, <br>               LS_UPDATE ) ) <br>            { <br>            printf("Challenge failed!!!\n"); <br>            /* <br>             * Release the grant. <br>             */ <br>            status = LSRelease( licenseHandle, <br>                                LS_DEFAULT_UNITS, <br>                                (LS_STR FAR *) MYAPP_RELEASE_LOG_COMMENT); <br>            if ( LS_SUCCESS != status ) <br>               PrintErrors( licenseHandle, status ); <br> <br>            LSFreeHandle( licenseHandle ); <br>            return(1); <br>            } <br>         }  /* End of if ( 0 == i%5 ) */ <br> <br>      }  /* End of for loop. */ <br> <br>   /* <br>    * Release the grant. <br>    */ <br>   status = LSRelease( licenseHandle, <br>                       LS_DEFAULT_UNITS, <br>                       (LS_STR FAR *) MYAPP_RELEASE_LOG_COMMENT); <br>   if ( LS_SUCCESS != status ) <br>      { <br>      PrintErrors( licenseHandle, status ); <br>      LSFreeHandle( licenseHandle ); <br>      return( 1 ); <br>      } <br> <br>   /* <br>    * Free the license handle. <br>    */ <br>   LSFreeHandle( licenseHandle ); <br>   return(0); <br>} <br> <br> <br>/* <br> * Print the error message. <br> */ <br>void PrintErrors( LS_HANDLE handle, LS_STATUS_CODE errorCode ) <br>{ <br>   LS_STATUS_CODE   status; <br>   char             errorText[200]; <br> <br> <br>   status = LSGetMessage( handle, errorCode, (LS_STR FAR *)errorText, 200); <br>   if ( LS_TEXT_UNAVAILABLE == status ) <br>      printf("Error: No message catalog available.\n"); <br>   else <br>      if ( LS_UNKNOWN_STATUS == status ) <br>         printf("Error: Unknown error code was used.\n"); <br>      else <br>         printf("Error: %s\n", errorText); <br>} <br> <br> <br>/* <br> * Use the algorithmic approach to calculate the message digest to send <br> * to the server. <br> */ <br>LS_STATUS_CODE getChallenge( <br>      LS_CHALLENGE    FAR *challenge, <br>      LS_STR          FAR *theString, <br>      LS_ULONG        unitsConsumed, <br>      LS_ULONG        unitsReserved, <br>      LS_STR          FAR *logComment, <br>      LS_ULONG        R, <br>      LS_ULONG        X, <br>      LS_ULONG        typeOfCall) <br>{ <br>   MD4_CTX        MD; <br>   char           secret[4]; <br>   LS_STR         hashString[200], FAR *hashStringPtr; <br>   int            bufferLen, bytes, i; <br> <br> <br>   /* <br>    * Set the protocol, index, random number, and size on the challenge <br>    * argument. <br>    */ <br>   challenge-&gt;Protocol = LS_BASIC_PROTOCOL; <br>   challenge-&gt;ChallengeData.SecretIndex = X; <br>   challenge-&gt;ChallengeData.Random = R; <br> <br>   /* <br>    * Get the secret.  NOTE: Greater steps should be taken to obsure the <br>    * secrets than is shown.  Also, more secrets should be used than 4. <br>    * Several methods are shown on how the secret can be specified. <br>    */ <br>   switch ( X ) <br>      { <br>      case 1: <br>         PlaceInt( secret, 0x7778797A ); <br>         break; <br>      case 2: <br>         PlaceInt( secret, 0x31323334 ); <br>         break; <br>      case 3: <br>         PlaceInt( secret, 1633837924 ); <br>         break; <br>      case 4: <br>         PlaceInt( secret, 926431536 ); <br>         break; <br>      default: <br>         printf("Index out of range\n"); <br>         return( 0 ); <br>         break; <br>      } <br> <br>   /* <br>    * Compute the hash string to be used on input to the MD4 algorithm. <br>    */ <br>   strcpy( hashString, theString ); <br>   hashStringPtr = hashString + strlen( theString ); <br>   bufferLen = strlen( theString ); <br> <br>   /* <br>    * Add units consumed only for LSUpdate call <br>    */ <br>   if ( LS_UPDATE == typeOfCall ) <br>      { <br>      bytes = PlaceInt( hashStringPtr, (LS_ULONG) unitsConsumed ); <br>      hashStringPtr += bytes; <br>      bufferLen += bytes; <br>      } <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) unitsReserved ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   strcpy( hashStringPtr, logComment ); <br>   bufferLen += strlen( logComment ); <br>   hashStringPtr += strlen( logComment ); <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) R ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) X ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   for ( i=0; i&lt;4; i++ ) <br>      { <br>      *hashStringPtr = secret[i]; <br>      hashStringPtr++; <br>      bufferLen++; <br>      } <br> <br> <br>   /* <br>    * Make the MD4 calls. <br>    */ <br>   MD4Init(&amp;MD); <br>   MD4Update( <br>      (MD4_CTX *) &amp;MD, <br>      (unsigned char *) hashString, <br>      (unsigned int) bufferLen ); <br>   MD4Final( <br>      challenge-&gt;ChallengeData.MsgDigest.MessageDigest, <br>      (MD4_CTX *) &amp;MD); <br> <br>   challenge-&gt;Size = sizeof( challenge-&gt;ChallengeData ); <br>   return( LS_SUCCESS ); <br>} <br> <br> <br>/* <br> * Check the return challenge argument. <br> */ <br>int checkChallenge( <br>      LS_CHALLENGE    FAR *challenge, <br>      LS_STR          FAR *theString, <br>      LS_ULONG        unitsConsumed , <br>      LS_ULONG        unitsReserved , <br>      LS_STR          FAR *logComment , <br>      LS_ULONG        unitsGranted , <br>      LS_STATUS_CODE  status , <br>      LS_ULONG        R, <br>      LS_ULONG        X, <br>      LS_ULONG        typeOfCall) <br>{ <br>   char           secret[4]; <br>   MD4_CTX        MD; <br>   LS_STR         hashString[200]; <br>   LS_STR         digest[DIGESTLEN], FAR *hashStringPtr; <br>   int            i, bufferLen, bytes, j; <br> <br> <br>   /* <br>    * Get the secret.  NOTE: Greater steps should be taken to obsure the <br>    * secrets than is shown.  Also, more secrets should be used than 4. <br>    * Several methods are shown on how the secret can be specified. <br>    */ <br>   switch ( X ) <br>      { <br>      case 1: <br>         PlaceInt( secret, 0x7778797A ); <br>         break; <br>      case 2: <br>         PlaceInt( secret, 0x31323334 ); <br>         break; <br>      case 3: <br>         PlaceInt( secret, 1633837924 ); <br>         break; <br>      case 4: <br>         PlaceInt( secret, 926431536 ); <br>         break; <br>      default: <br>         printf("Index out of range\n"); <br>         return( 0 ); <br>         break; <br>      } <br> <br>   /* <br>    * Compute the hash string. <br>    */ <br>   strcpy( hashString, theString ); <br>   hashStringPtr = hashString + strlen( theString ); <br>   bufferLen = strlen( theString ); <br> <br>   /* <br>    * Add units consumed only for LSUpdate call <br>    */ <br>   if ( LS_UPDATE == typeOfCall ) <br>      { <br>      bytes = PlaceInt( hashStringPtr, (LS_ULONG) unitsConsumed ); <br>      hashStringPtr += bytes; <br>      bufferLen += bytes; <br>      } <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) unitsReserved ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   strcpy( hashStringPtr, logComment ); <br>   bufferLen += strlen( logComment ); <br>   hashStringPtr += strlen( logComment ); <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) unitsGranted ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) status ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) R ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   bytes = PlaceInt( hashStringPtr, (LS_ULONG) X ); <br>   hashStringPtr += bytes; <br>   bufferLen += bytes; <br> <br>   for ( i=0; i&lt;4; i++ ) <br>      { <br>      *hashStringPtr = secret[i]; <br>      hashStringPtr++; <br>      bufferLen++; <br>      } <br> <br> <br>   /* <br>    * Compute the message digest. <br>    */ <br>   MD4Init(&amp;MD); <br>   MD4Update( <br>      (MD4_CTX *) &amp;MD, <br>      (unsigned char *) hashString, <br>      (unsigned int) bufferLen ); <br>   MD4Final( <br>      digest, <br>      (MD4_CTX *) &amp;MD); <br> <br>   /* <br>    * Compare the digest with the one on the challenge <br>    */ <br>   j = 0 ; <br>   for( i = 0; i &lt; DIGESTLEN; i++ ) <br>    { <br>      if( digest[i] != challenge-&gt;ChallengeData.MsgDigest.MessageDigest[i] ) <br>         break ; <br>      j++ ; <br>    } <br> <br>   if( j == DIGESTLEN ) <br>      return( 1 ); <br> <br>   return( 0 ); <br>} <br> <br>/* <br> * swap bytes <br> */ <br>void swap( LS_STR FAR *byte1, LS_STR FAR *byte2 ) <br>{ <br>   LS_STR           tmp; <br> <br>   tmp = *byte2; <br>   *byte2 = *byte1; <br>   *byte1 = tmp; <br>} <br> <br> <br> <br>/* <br> * Places integer in byte buffer, swapping bytes if necessary <br> */ <br>int PlaceInt( char FAR *buffer, LS_ULONG value ) <br>{ <br>   if ( littleEndian ) <br>      { <br>      swap(&amp;(((char FAR *) &amp;value)[0]), &amp;(((char FAR *) &amp;value)[3])); <br>      swap(&amp;(((char FAR *) &amp;value)[1]), &amp;(((char FAR *) &amp;value)[2])); <br>      } <br> <br>   memcpy( buffer, &amp;value, sizeof( LS_ULONG ) ); <br> <br>   return( (int) sizeof( LS_ULONG ) ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
