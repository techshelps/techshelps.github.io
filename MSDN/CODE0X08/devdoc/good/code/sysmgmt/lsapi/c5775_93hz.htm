<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MD4C.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5777"></a>MD4C.C</h2>
<pre><code>/* MD4C.C - RSA Data Security, Inc., MD4 message-digest algorithm <br> */ <br> <br>/* Copyright (C) 1990-2, RSA Data Security, Inc. All rights reserved. <br> <br>   License to copy and use this software is granted provided that it <br>   is identified as the "RSA Data Security, Inc. MD4 Message-Digest <br>   Algorithm" in all material mentioning or referencing this software <br>   or this function. <br> <br>   License is also granted to make and use derivative works provided <br>   that such works are identified as "derived from the RSA Data <br>   Security, Inc. MD4 Message-Digest Algorithm" in all material <br>   mentioning or referencing the derived work. <br> <br>   RSA Data Security, Inc. makes no representations concerning either <br>   the merchantability of this software or the suitability of this <br>   software for any particular purpose. It is provided "as is" <br>   without express or implied warranty of any kind. <br> <br>   These notices must be retained in any copies of any part of this <br>   documentation and/or software. <br> */ <br> <br>/* This code differs from the MD4 implementation contained in Internet <br>   RFC-1320 in the following respects: <br> <br>   1. Faster boolean computations for the "F" and "G" functions, as <br>      suggested by Richard Schoeppel, rcs@cs.arizona.edu, have been included. <br>      The original code contained in the RFC is retained as comments. <br> <br>   2. PROTO_LIST was removed from the function prototypes. <br> */ <br> <br>#include "md4.h" <br> <br>/* Constants for MD4Transform routine. <br> */ <br>#define S11 3 <br>#define S12 7 <br>#define S13 11 <br>#define S14 19 <br>#define S21 3 <br>#define S22 5 <br>#define S23 9 <br>#define S24 13 <br>#define S31 3 <br>#define S32 9 <br>#define S33 11 <br>#define S34 15 <br> <br>static void MD4Transform ( UINT4 *state, unsigned char *block ) ; <br>static void Encode ( unsigned char *output, <br>                     UINT4 *input, unsigned int len ) ; <br>static void Decode ( UINT4 *output, <br>                     unsigned char *input, unsigned int len ) ; <br>static void MD4_memcpy ( POINTER output, POINTER input, unsigned int len ) ; <br>static void MD4_memset ( POINTER output, int value, unsigned int len ) ; <br> <br> <br>static unsigned char PADDING[64] = { <br>  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 <br>}; <br> <br>/* F, G and H are basic MD4 functions. <br>   Faster methods suggested by Richard Schoeppel, rcs@cs.arizona.edu <br> */ <br> <br>/* #define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))              original code */ <br>#define F(x, y, z) ((z) ^ ((x) &amp; ((y) ^ (z))))               /* faster method */ <br>/* #define G(x, y, z) (((x) &amp; (y)) | ((x) &amp; (z)) | ((y) &amp; (z))) original code */ <br>#define G(x, y, z) (((x) &amp; (y)) | ((z) &amp; ((x) | (y))))       /* faster method */ <br>#define H(x, y, z) ((x) ^ (y) ^ (z)) <br> <br>/* ROTATE_LEFT rotates x left n bits. <br> */ <br>#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n)))) <br> <br>/* FF, GG and HH are transformations for rounds 1, 2 and 3 */ <br>/* Rotation is separate from addition to prevent recomputation */ <br> <br>#define FF(a, b, c, d, x, s) { \ <br>    (a) += F ((b), (c), (d)) + (x); \ <br>    (a) = ROTATE_LEFT ((a), (s)); \ <br>  } <br>#define GG(a, b, c, d, x, s) { \ <br>    (a) += G ((b), (c), (d)) + (x) + (UINT4)0x5a827999; \ <br>    (a) = ROTATE_LEFT ((a), (s)); \ <br>  } <br>#define HH(a, b, c, d, x, s) { \ <br>    (a) += H ((b), (c), (d)) + (x) + (UINT4)0x6ed9eba1; \ <br>    (a) = ROTATE_LEFT ((a), (s)); \ <br>  } <br> <br>/* MD4 initialization. Begins an MD4 operation, writing a new context. <br> */ <br> <br>void MD4Init ( MD4_CTX *context )               /* context */ <br> <br>{ <br>  context-&gt;count[0] = context-&gt;count[1] = 0; <br> <br>  /* Load magic initialization constants. <br>   */ <br>  context-&gt;state[0] = 0x67452301; <br>  context-&gt;state[1] = 0xefcdab89; <br>  context-&gt;state[2] = 0x98badcfe; <br>  context-&gt;state[3] = 0x10325476; <br>} <br> <br>/* MD4 block update operation. Continues an MD4 message-digest <br>     operation, processing another message block, and updating the <br>     context. <br> */ <br> <br>void MD4Update ( MD4_CTX *context,              /* context */ <br>                 POINTER input,                 /* input block */ <br>                 unsigned int inputLen )        /* length of input block */ <br> <br>{ <br>  unsigned int i, index, partLen; <br> <br>  /* Compute number of bytes mod 64 */ <br>  index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F); <br>  /* Update number of bits */ <br>  if ((context-&gt;count[0] += ((UINT4)inputLen &lt;&lt; 3)) <br>      &lt; ((UINT4)inputLen &lt;&lt; 3)) <br>    context-&gt;count[1]++; <br>  context-&gt;count[1] += ((UINT4)inputLen &gt;&gt; 29); <br> <br>  partLen = 64 - index; <br> <br>  /* Transform as many times as possible. <br>   */ <br>  if (inputLen &gt;= partLen) { <br>    MD4_memcpy <br>      ((POINTER)&amp;context-&gt;buffer[index], (POINTER)input, partLen); <br>    MD4Transform (context-&gt;state, context-&gt;buffer); <br> <br>    for (i = partLen; i + 63 &lt; inputLen; i += 64) <br>      MD4Transform (context-&gt;state, &amp;input[i]); <br> <br>    index = 0; <br>  } <br>  else <br>    i = 0; <br> <br>  /* Buffer remaining input */ <br>  MD4_memcpy <br>    ((POINTER)&amp;context-&gt;buffer[index], (POINTER)&amp;input[i], <br>     inputLen-i); <br>} <br> <br>/* MD4 finalization. Ends an MD4 message-digest operation, writing the <br>     the message digest and zeroizing the context. <br> */ <br> <br>void MD4Final ( unsigned char *digest,          /* 16-byte message digest */ <br>                MD4_CTX *context )              /* context */ <br> <br>{ <br>  unsigned char bits[8]; <br>  unsigned int index, padLen; <br> <br>  /* Save number of bits */ <br>  Encode (bits, context-&gt;count, 8); <br> <br>  /* Pad out to 56 mod 64. <br>   */ <br>  index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f); <br>  padLen = (index &lt; 56) ? (56 - index) : (120 - index); <br>  MD4Update (context, PADDING, padLen); <br> <br>  /* Append length (before padding) */ <br>  MD4Update (context, bits, 8); <br>  /* Store state in digest */ <br>  Encode (digest, context-&gt;state, 16); <br> <br>  /* Zeroize sensitive information. <br>   */ <br>  MD4_memset ((POINTER)context, 0, sizeof (*context)); <br> <br>} <br> <br>/* MD4 basic transformation. Transforms state based on block. <br> */ <br> <br>static void MD4Transform ( UINT4 *state,        /* 16-byte state */ <br>                           unsigned char *block ) /* 64-byte block */ <br> <br>{ <br>  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16]; <br> <br>  Decode (x, block, 64); <br> <br>  /* Round 1 */ <br>  FF (a, b, c, d, x[ 0], S11); /* 1 */ <br>  FF (d, a, b, c, x[ 1], S12); /* 2 */ <br>  FF (c, d, a, b, x[ 2], S13); /* 3 */ <br>  FF (b, c, d, a, x[ 3], S14); /* 4 */ <br>  FF (a, b, c, d, x[ 4], S11); /* 5 */ <br>  FF (d, a, b, c, x[ 5], S12); /* 6 */ <br>  FF (c, d, a, b, x[ 6], S13); /* 7 */ <br>  FF (b, c, d, a, x[ 7], S14); /* 8 */ <br>  FF (a, b, c, d, x[ 8], S11); /* 9 */ <br>  FF (d, a, b, c, x[ 9], S12); /* 10 */ <br>  FF (c, d, a, b, x[10], S13); /* 11 */ <br>  FF (b, c, d, a, x[11], S14); /* 12 */ <br>  FF (a, b, c, d, x[12], S11); /* 13 */ <br>  FF (d, a, b, c, x[13], S12); /* 14 */ <br>  FF (c, d, a, b, x[14], S13); /* 15 */ <br>  FF (b, c, d, a, x[15], S14); /* 16 */ <br> <br>  /* Round 2 */ <br>  GG (a, b, c, d, x[ 0], S21); /* 17 */ <br>  GG (d, a, b, c, x[ 4], S22); /* 18 */ <br>  GG (c, d, a, b, x[ 8], S23); /* 19 */ <br>  GG (b, c, d, a, x[12], S24); /* 20 */ <br>  GG (a, b, c, d, x[ 1], S21); /* 21 */ <br>  GG (d, a, b, c, x[ 5], S22); /* 22 */ <br>  GG (c, d, a, b, x[ 9], S23); /* 23 */ <br>  GG (b, c, d, a, x[13], S24); /* 24 */ <br>  GG (a, b, c, d, x[ 2], S21); /* 25 */ <br>  GG (d, a, b, c, x[ 6], S22); /* 26 */ <br>  GG (c, d, a, b, x[10], S23); /* 27 */ <br>  GG (b, c, d, a, x[14], S24); /* 28 */ <br>  GG (a, b, c, d, x[ 3], S21); /* 29 */ <br>  GG (d, a, b, c, x[ 7], S22); /* 30 */ <br>  GG (c, d, a, b, x[11], S23); /* 31 */ <br>  GG (b, c, d, a, x[15], S24); /* 32 */ <br> <br>  /* Round 3 */ <br>  HH (a, b, c, d, x[ 0], S31); /* 33 */ <br>  HH (d, a, b, c, x[ 8], S32); /* 34 */ <br>  HH (c, d, a, b, x[ 4], S33); /* 35 */ <br>  HH (b, c, d, a, x[12], S34); /* 36 */ <br>  HH (a, b, c, d, x[ 2], S31); /* 37 */ <br>  HH (d, a, b, c, x[10], S32); /* 38 */ <br>  HH (c, d, a, b, x[ 6], S33); /* 39 */ <br>  HH (b, c, d, a, x[14], S34); /* 40 */ <br>  HH (a, b, c, d, x[ 1], S31); /* 41 */ <br>  HH (d, a, b, c, x[ 9], S32); /* 42 */ <br>  HH (c, d, a, b, x[ 5], S33); /* 43 */ <br>  HH (b, c, d, a, x[13], S34); /* 44 */ <br>  HH (a, b, c, d, x[ 3], S31); /* 45 */ <br>  HH (d, a, b, c, x[11], S32); /* 46 */ <br>  HH (c, d, a, b, x[ 7], S33); /* 47 */ <br>  HH (b, c, d, a, x[15], S34); /* 48 */ <br> <br>  state[0] += a; <br>  state[1] += b; <br>  state[2] += c; <br>  state[3] += d; <br> <br>  /* Zeroize sensitive information. <br>   */ <br>  MD4_memset ((POINTER)x, 0, sizeof (x)); <br>} <br> <br>/* Encodes input (UINT4) into output (unsigned char). Assumes len is <br>     a multiple of 4. <br> */ <br> <br>static void Encode ( unsigned char *output, <br>                     UINT4 *input, <br>                     unsigned int len ) <br> <br>{ <br>  unsigned int i, j; <br> <br>  for (i = 0, j = 0; j &lt; len; i++, j += 4) { <br>    output[j] = (unsigned char)(input[i] &amp; 0xff); <br>    output[j+1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff); <br>    output[j+2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff); <br>    output[j+3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff); <br>  } <br>} <br> <br>/* Decodes input (unsigned char) into output (UINT4). Assumes len is <br>     a multiple of 4. <br> */ <br> <br>static void Decode ( UINT4 *output, <br>                     unsigned char *input, <br>                     unsigned int len ) <br> <br>{ <br>  unsigned int i, j; <br> <br>  for (i = 0, j = 0; j &lt; len; i++, j += 4) <br>    output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) | <br>      (((UINT4)input[j+2]) &lt;&lt; 16) | (((UINT4)input[j+3]) &lt;&lt; 24); <br>} <br> <br>/* Note: Replace "for loop" with standard memcpy if possible. <br> */ <br> <br>static void MD4_memcpy ( POINTER output,    /* target string to copy to */ <br>                         POINTER input,     /* source string to copy from */ <br>                         unsigned int len ) /* number of bytes to copy */ <br> <br>{ <br>  unsigned int i; <br> <br>  for (i = 0; i &lt; len; i++) <br>    output[i] = input[i]; <br>} <br> <br>/* Note: Replace "for loop" with standard memset if possible. <br> */ <br> <br>static void MD4_memset ( POINTER output,     /* first location to set */ <br>                         int value,          /* value to set string to */ <br>                         unsigned int len )  /* number of bytes to set */ <br> <br>{ <br>  unsigned int i; <br> <br>  for (i = 0; i &lt; len; i++) <br>    ((char *)output)[i] = (char)value; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
