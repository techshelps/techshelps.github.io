<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIEWDLL.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5894"></a>VIEWDLL.C</h2>
<pre><code>/************************************************************************* <br> <br>VIEWC.DLL - This Module creates Views based on the current Group Map in <br>SMS <br> <br>Copyright (c), 1994 by Microsoft Corp. <br> <br>Modified: 7/11/95 a-cvadai  Added error message messageboxes. <br>          9/13/95 a-cvadai  Changed outer- to inner-joins on all views <br> <br>*************************************************************************/ <br> <br>#define DBNTWIN32               // must identify operating system environment <br>#include "windows.h" <br> <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt;         // DB-LIB header file (should always be included) <br>#include &lt;stdio.h&gt; <br>#include "smsview.h" <br>#include "viewdlls.h" <br> <br>int RetCode, CmdComplete; <br> <br>void ErrorMsg(int ,int); <br>int GenViews(dbproc,dbprocView,CreateGroupName,DropOnlyFlag,CommandLine) <br>DBPROCESS *dbproc; <br>DBPROCESS *dbprocView; <br>char *CreateGroupName; <br>int DropOnlyFlag; <br>int CommandLine; <br> <br>{ <br>  RETCODE result_code; <br>  struct VIEWDEF TableDef[MAX_COLUMNS]; <br>  char szTmpText[500]; <br>  char szText[500]; <br>  char szMsgTitle[32]; <br> <br>  // Variables to bind to Group Map select <br>  char  ViewName[MAX_COLUMN_NAME], <br>        ArchitectureName[MAX_COLUMN_NAME], <br>        GroupName[MAX_COLUMN_NAME], <br>        AttributeName[MAX_COLUMN_NAME], <br>        ColumnName[MAX_COLUMN_NAME] , <br>        CommonTableName[MAX_COLUMN_NAME], <br>        SpecificTableName[MAX_COLUMN_NAME]; <br> <br>   // Variables to keep Current View Details <br>   char CurCommonTableName[MAX_COLUMN_NAME], <br>        CurArchitectureName[MAX_COLUMN_NAME], <br>        CurSpecificTableName[MAX_COLUMN_NAME]; <br> <br>  int CurKey = 0, <br>      CurArchitectureKey, <br>      i= 0, LastMode, <br>      ViewSuffix = 0; <br> <br>  int GroupKey, <br>      ArchitectureKey, <br>      Mode,  <br>      CommonSpecificFlag; <br> <br>      RetCode = SUCCEED; <br>      CmdComplete=CommandLine; <br> <br>     dberrhandle((void *)err_handler); <br>     dbmsghandle((void *)err_handler); <br>    // Set up a View that we can use to get all the Group Info <br> <br>    dbcmd (dbproc , (char *) "SELECT AttributeMap.GroupKey,"); <br>    dbcmd (dbproc , (char *) " ArchitectureMap.ArchitectureName, "); <br>    dbcmd (dbproc , (char *) " GroupMap.ArchitectureKey , "); <br>    dbcmd (dbproc , (char *) " GroupMap.GroupName,"); <br>    dbcmd (dbproc , (char *) " AttributeMap.AttributeName,"); <br>    dbcmd (dbproc , (char *) " AttributeMap.ColumnName,"); <br>    dbcmd (dbproc , (char *) " AttributeMap.CommonSpecificFlag,"); <br>    dbcmd (dbproc , (char *) " GroupMap.CommonTableName, "); <br>    dbcmd (dbproc , (char *) " GroupMap.SpecificTableName, "); <br>    dbcmd (dbproc , (char *) " ArchitectureMap.Mode "); <br> <br>    dbcmd (dbproc , (char *) " FROM ArchitectureMap ArchitectureMap,"); <br>    dbcmd (dbproc , (char *) " AttributeMap AttributeMap,"); <br>    dbcmd (dbproc , (char *) " GroupMap GroupMap     "); <br> <br>    dbcmd (dbproc , (char *) " WHERE GroupMap.ArchitectureKey = " <br>                             "AttributeMap.ArchitectureKey AND "); <br>    dbcmd (dbproc , (char *) " AttributeMap.ArchitectureKey = " <br>                             "ArchitectureMap.ArchitectureKey AND "); <br>    dbcmd (dbproc , (char *) " AttributeMap.GroupKey = GroupMap.GroupKey"); <br> <br>    // Check if only specific group's selected <br>    if (strlen(CreateGroupName) != 0) { <br>        dbcmd (dbproc , (char *) " AND GroupMap.GroupName ='"); <br>        dbcmd (dbproc , (char *) CreateGroupName ); <br>        dbcmd (dbproc,  (char *) "'"); <br>    } <br> <br>    dbcmd (dbproc , (char *) " ORDER BY "); <br>    dbcmd (dbproc , (char *) " ArchitectureMap.ArchitectureKey ,"); <br>    dbcmd (dbproc , (char *) " AttributeMap.GroupKey"); <br> <br> <br>    dbsqlexec (dbproc); <br> <br>    // now check the results from the SQL server <br>    while ((result_code = dbresults(dbproc)) != NO_MORE_RESULTS) { <br>        if (result_code == SUCCEED) { <br>            dbbind(dbproc, 1, INTBIND, (DBINT) MAX_COLUMN_NAME, <br>                  (char *)&amp;GroupKey); <br>            dbbind(dbproc, 2, NTBSTRINGBIND, (DBINT) MAX_COLUMN_NAME, <br>                   (char *)ArchitectureName); <br>            dbbind(dbproc, 3, INTBIND, (DBINT) MAX_COLUMN_NAME, <br>                   (char *)&amp;ArchitectureKey); <br>            dbbind(dbproc, 4, NTBSTRINGBIND, (DBINT) MAX_COLUMN_NAME, <br>                  (char *)GroupName); <br>            dbbind(dbproc, 5, NTBSTRINGBIND, (DBINT) MAX_COLUMN_NAME, <br>                   (char *)AttributeName); <br>            dbbind(dbproc, 6, NTBSTRINGBIND, (DBINT) MAX_COLUMN_NAME, <br>                   (char *)ColumnName); <br>            dbbind(dbproc, 7, INTBIND, (DBINT) MAX_COLUMN_NAME, <br>                   (char *)&amp;CommonSpecificFlag); <br>            dbbind(dbproc, 8, NTBSTRINGBIND, (DBINT) MAX_COLUMN_NAME, <br>                   (char *)CommonTableName); <br>            dbbind(dbproc, 9, NTBSTRINGBIND, (DBINT) MAX_COLUMN_NAME, <br>                   (char *)SpecificTableName); <br>            dbbind(dbproc, 10, INTBIND, (DBINT) MAX_COLUMN_NAME, <br>                  (char *)&amp;Mode); <br> <br> <br>            // Loop through all the groups Breaking when a Arctecture , Group Changes <br> <br>            CurKey = -1; <br>            i = 0; <br>            ViewSuffix = 0; <br>            while (dbnextrow(dbproc) != NO_MORE_ROWS ) { <br>                if ( ((CurKey != GroupKey || CurArchitectureKey != ArchitectureKey) &amp;&amp; CurKey != -1) <br>                     || (i == MAX_COLUMNS) ) { <br>                    if (CreateV(ViewName, &amp;TableDef[0],dbprocView,i, <br>                            CurArchitectureKey, CurKey, CurCommonTableName, <br>                            CurSpecificTableName, ViewSuffix, <br>                            CurArchitectureName, DropOnlyFlag, LastMode) == FAIL) { <br> <br>                        LoadString(hInst, IDS_ERR_BADGROUP, szTmpText, 500); <br>                        LoadString(hInst, IDS_MSC_DBERROR, szMsgTitle, 32); <br> <br>                        sprintf(szText, (const char *)szTmpText, ViewName); <br>                        MessageBox(NULL, szText, szMsgTitle, MB_ICONSTOP); <br>                    } <br>                    if ( i == MAX_COLUMNS &amp;&amp; CurKey == GroupKey) <br>                        ViewSuffix++; <br>                    else <br>                        ViewSuffix = 0; <br> <br>                    i = 0; <br>                }      // End if <br>                strcpy(ViewName, GroupName); <br>                strcpy(TableDef[i].ColName,ColumnName); <br>                TableDef[i].ComSpec = CommonSpecificFlag; <br> <br>                CurArchitectureKey = ArchitectureKey; <br>                CurKey = GroupKey; <br>                strcpy(CurCommonTableName,CommonTableName); <br>                strcpy(CurSpecificTableName,SpecificTableName); <br>                strcpy(CurArchitectureName,ArchitectureName); <br>                LastMode = Mode; <br>                i++; <br> <br>            } <br> <br>            // Make sure we Create a view for the last group <br> <br>            if (CreateV(ViewName,TableDef,dbprocView,i,CurArchitectureKey, <br>                    CurKey, CurCommonTableName, CurSpecificTableName, <br>                    ViewSuffix, CurArchitectureName, DropOnlyFlag, LastMode) == FAIL) { <br>                 <br>                    LoadString(hInst, IDS_ERR_BADGROUP, szTmpText, 500); <br>                    LoadString(hInst, IDS_MSC_DBERROR, szMsgTitle, 32); <br> <br>                    sprintf(szText, (const char *)szTmpText, ViewName); <br>                    MessageBox(NULL, szText, szMsgTitle, MB_ICONSTOP); <br> <br>            } <br> <br>            DropView(dbproc,"SNMP_Varbinds"); <br>            DropView(dbproc,"GroupNames"); <br> <br>            if (!DropOnlyFlag) { <br>                CreateSNMPVarbindsView(dbprocView); <br>                CreateGroupView(dbprocView); <br>            } <br>        } <br>        else { <br>            return(FAIL); <br>            break; <br>        } <br>    } // while (TRUE) <br> <br>    return(RetCode); <br>} <br> <br> <br> <br>/****************************************************************************** <br> <br>Create a View that will logicaly represent the DataBase <br>Typical View Of the Disk Group would be <br> <br>Create View SMS_Disk as select dwMachineID, <br>             Disk_COMM.Disk_Index0 , Disk_COMM.File_System0 , <br>             Disk_COMM.Storage_Type0 , Disk_SPEC.Volume_Name0 , <br>             Disk_SPEC.Serial_Number0 ,Disk_SPEC.Heads0 , <br>             Disk_SPEC.Sectors0 , Disk_SPEC.Cylinders0 , <br>             Disk_SPEC.__Disk_Full0 , Disk_SPEC.Free_Storage__MByte_0 , <br>             Disk_SPEC.Storage_Size__MByte_0 , Disk_SPEC.Storage_Used__MByte_0 <br>        from Disk_COMM  , Disk_SPEC, MachineDataTable <br>        where Disk_COMM.key =* CommonKey and Disk_SPEC.key =* SpecificKey <br>         and ArchitectureKey = 5 and GroupKey = 5 <br>*****************************************************************************/ <br> <br>int CreateV(ViewName, TableDef,dbproc,NoCols,ArchitectureKey,GroupKey , <br>        CurCommonTableName , CurSpecificTableName,ViewSuffix, <br>        CurArchitectureName,DropOnlyFlag, Mode) <br> <br>char * ViewName; <br>struct VIEWDEF * TableDef; <br>DBPROCESS * dbproc; <br>int NoCols, <br>    ArchitectureKey , <br>    GroupKey; <br>char * CurCommonTableName , <br>     * CurSpecificTableName; <br>int ViewSuffix; <br>char * CurArchitectureName; <br>int DropOnlyFlag; <br> <br> <br>{ <br>    int i ; <br>    char TableName[MAX_COLUMN_NAME]; <br>    int CommonFlag = FALSE, <br>    SpecFlag = FALSE; <br>    BOOL bDirect = FALSE; <br> <br>    char cmd[MAX_COLUMN_NAME]; <br> <br>    if (Mode == 1) { <br>        bDirect = TRUE; <br>    } <br> <br>    for ( i= 0; ViewName[i]; i++)  // Change all Spaces to _ to derive Table Name <br>        if (ViewName[i] == ' ') <br>            ViewName[i] = '_'; <br> <br>    MakeUName(ViewName, CurSpecificTableName, CurCommonTableName); <br> <br>    if (ViewSuffix) // If this is not the first view <br>        sprintf(ViewName,"%s%d",ViewName,ViewSuffix); <br> <br> <br>    DropView ( dbproc,ViewName); <br> <br>    if( DropOnlyFlag ) <br>        return(SUCCEED); <br> <br>    // 9/13/1995 a-cvadai <br>    // First, make sure there is a 0-datakey row in each table <br>    // so the views can use inner-joins. <br>    // ======================================================= <br> <br>    if (!bDirect) { <br>     <br>        if (strlen(CurSpecificTableName) &gt; 0) { <br>            dbcmd (dbproc, (char *) " IF NOT EXISTS (select * from "); <br>            dbcmd (dbproc, (char *) CurSpecificTableName); <br>            dbcmd (dbproc, (char *) " where datakey = 0) INSERT "); <br>            dbcmd (dbproc, (char *) CurSpecificTableName); <br>            dbcmd (dbproc, (char *) " (datakey) values (0)"); <br>            dbsqlexec (dbproc); <br>            dbresults(dbproc);  <br>            do { <br>                while (dbnextrow(dbproc) == REG_ROW) { <br>                    ; <br>                } <br>            } while (dbresults(dbproc) == SUCCEED); <br> <br>        } <br>    <br>        if (strlen(CurCommonTableName) &gt; 0) { <br>            dbcmd (dbproc, (char *) " IF NOT EXISTS (select * from "); <br>            dbcmd (dbproc, (char *) CurCommonTableName); <br>            dbcmd (dbproc, (char *) " where datakey = 0) INSERT "); <br>            dbcmd (dbproc, (char *) CurCommonTableName); <br>            dbcmd (dbproc, (char *) " (datakey) values (0)");  <br>            dbsqlexec (dbproc); <br>            dbresults(dbproc); <br>            do { <br>                while (dbnextrow(dbproc) == REG_ROW) { <br>                    ; <br>                } <br>            } while (dbresults(dbproc) == SUCCEED); <br> <br>        } <br>    } <br> <br>    dbcmd (dbproc , (char *) "Create View "); <br>    dbcmd (dbproc , (char *) PREFIX); <br>    dbcmd (dbproc , (char *) ViewName); <br>    dbcmd (dbproc , (char *) " as select "); <br> <br>    if (!bDirect) { <br>        dbcmd (dbproc ,(char *) "dwMachineID , "); <br>    } <br>    else { <br>        dbcmd (dbproc ,(char *) "MachineID , "); <br>    } <br> <br> <br>    for ( i = 0; i &lt; NoCols;i++) { <br>         // Check if this attribute is in the COMM or SPEC tables <br>        if (TableDef[i].ComSpec == COMMON) <br>            strcpy(TableName,CurCommonTableName); <br>        else <br>            strcpy(TableName,CurSpecificTableName); <br> <br>        if (i)    // We need a , after the first Table name <br>            dbcmd(dbproc,(char *) " , "); <br> <br>            dbcmd(dbproc,(char *) TableName); // Append the Table Name eg DISK_COMM <br>            dbcmd(dbproc,(char *) "."); <br>            dbcmd(dbproc,(char *) TableDef[i].ColName); <br> <br>    } // End For <br> <br>    dbcmd (dbproc,(char *)" from "); <br>     <br>    if (!bDirect) { <br>        dbcmd (dbproc,(char *)" MachineDataTable "); <br> <br>        if (strlen (CurCommonTableName) != 0) { <br>            dbcmd (dbproc,(char *)" ,"); <br> <br>            // Append the Table Name eg DISK_COMM <br>            dbcmd(dbproc,(char *) CurCommonTableName); <br>            dbcmd(dbproc,(char *) "  "); <br>        } <br>    } <br> <br>    if ( strlen (CurSpecificTableName) != 0) { <br>        if (!bDirect) { <br>            dbcmd (dbproc,(char *)" , "); <br>        } <br> <br>        // Append the Table Name eg DISK_SPEC <br>        dbcmd(dbproc,(char *) CurSpecificTableName); <br>        dbcmd(dbproc,(char *) " "); <br>    } <br> <br>    if (!bDirect) { <br> <br>        dbcmd(dbproc ,(char *) "where " ); <br>        if (strlen (CurCommonTableName) != 0) { <br>            dbcmd(dbproc ,(char *) CurCommonTableName); <br>            dbcmd(dbproc ,(char *) ".datakey = "); <br>            dbcmd(dbproc ,(char *) " CommonKey and "); <br>        } <br> <br>        if ( strlen (CurSpecificTableName) != 0) { <br>            dbcmd(dbproc ,(char *) CurSpecificTableName); <br>            dbcmd(dbproc ,(char *) ".datakey = "); <br>            dbcmd(dbproc ,(char *) "SpecificKey and "); <br>        } <br>        dbcmd(dbproc ,(char *) "ArchitectureKey = "); <br>        sprintf(cmd,"%d", ArchitectureKey); <br>        dbcmd(dbproc ,(char *) cmd); <br>        dbcmd(dbproc ,(char *) " and GroupKey = "); <br>        sprintf(cmd,"%d", GroupKey); <br>        dbcmd(dbproc ,(char *) cmd); <br>    } <br> <br>    dbsqlexec (dbproc); <br> <br>    return ( CheckSQLReturn(dbproc, "Create View")); <br>} <br> <br> <br> <br> <br>DropView(DBPROCESS *dbproc, char * ViewName) <br>{ <br> <br>    // Check if View already exists and if so Drop it <br>    dbcmd (dbproc ,(char *) "IF EXISTS (SELECT * FROM sysobjects "); <br>    dbcmd (dbproc ,(char *) " WHERE id = object_id('dbo."); <br>    dbcmd (dbproc ,(char *) PREFIX); <br>    dbcmd (dbproc ,(char *) ViewName); <br>    dbcmd (dbproc ,(char *) "'))"); <br>    dbcmd (dbproc ,(char *) " DROP view dbo."); <br>    dbcmd (dbproc ,(char *) PREFIX); <br>    dbcmd (dbproc ,(char *) ViewName); <br> <br>    dbsqlexec (dbproc); <br> <br>    return( CheckSQLReturn(dbproc, "Drop View")); <br> <br> <br>} <br> <br> <br>// Create a View of all the groups that have been made into Views <br> <br>CreateGroupView(DBPROCESS * dbproc) <br>{ <br> <br>    dbcmd (dbproc , (char *) "Create View "); <br>    dbcmd (dbproc , (char *) PREFIX); <br>    dbcmd (dbproc , (char *) "GroupNames"); <br>    dbcmd (dbproc , (char *) " as select "); <br>    dbcmd (dbproc , (char *) " GM.GroupName  "); <br> <br>    dbcmd (dbproc , (char *) " FROM ArchitectureMap AM,"); <br> <br>    dbcmd (dbproc , (char *) " GroupMap GM "); <br> <br>    dbcmd (dbproc , (char *) " WHERE "); <br> <br>    dbcmd (dbproc , (char *) " GM.ArchitectureKey = AM.ArchitectureKey "); <br> <br>    dbsqlexec (dbproc); <br>    return ( CheckSQLReturn(dbproc, "Create Group View")); <br>} <br> <br>CreateSNMPVarbindsView(DBPROCESS * dbproc) <br>{ <br> <br>    dbcmd (dbproc , (char *) "Create View "); <br>    dbcmd (dbproc , (char *) PREFIX); <br>    dbcmd (dbproc , (char *) "SNMP_Varbinds"); <br>    dbcmd (dbproc , (char *) " as select "); <br>    dbcmd (dbproc , (char *) " MachineID, Variable, ObjectIdentifier, DataType, Data1, Data2, Data3, Data4, Data5, Data6 "); <br> <br>    dbcmd (dbproc , (char *) " FROM SNMP_Varbinds"); <br> <br>    dbsqlexec (dbproc); <br>    return ( CheckSQLReturn(dbproc, "Create Group View")); <br>} <br> <br> <br>//Make UniqueName <br> <br>void MakeUName(vName,uName,cName) <br>    char * vName , <br>         * uName , * cName; <br> <br> <br> <br>{ <br>    char p1[MAX_COLUMNS] = ""; <br>    char p2[MAX_COLUMNS] = ""; <br>    char commstr[] = "_COMM"; <br>    char specstr[] = "_SPEC"; <br>    char *psearch; <br>    int  lenp1; <br> <br>    if ( strlen (uName) != 0) { <br>        if ((psearch = strstr(uName,specstr)) == NULL) <br>        strcpy(vName,uName); <br>    else { <br>        lenp1 = psearch-uName; <br>        strncpy (p1,uName,lenp1); <br>        strcpy (p2,psearch+5); <br>        sprintf(vName,"%s%s",p1,p2); <br> <br>        } <br>    } <br>    else { <br>        if ((psearch = strstr(cName,commstr)) == NULL) <br>        strcpy(vName,cName); <br>    else { <br>        lenp1 = psearch-cName; <br>        strncpy (p1,cName,lenp1); <br>        strcpy (p2,psearch+5); <br>        sprintf(vName,"%s%s",p1,p2); <br>        } <br> <br>    } <br> <br>} <br> <br> <br>//     Check SQL return and empty return buffer <br> <br>CheckSQLReturn(DBPROCESS * dbproc, char *Action) <br>{ <br>    RETCODE result_code; <br>    int iResult = FAIL; <br>     <br>    while ((result_code = dbresults(dbproc)) != NO_MORE_RESULTS) { <br>        if (result_code == SUCCEED) { <br>            iResult = SUCCEED; <br>            while (dbnextrow(dbproc) != NO_MORE_ROWS) <br>                ;  /* do nothing */ <br>        } <br>        else { <br>             return(FAIL); <br>             break; <br>        } <br>    } <br>    return (iResult); <br>} <br> <br> <br>// <br>int err_handler(DBPROCESS * dbproc, int severity, int dberr, int oserr, <br>                char * dberrstr, char * oserrstr) <br>{ <br> <br>    char    szString[512]; <br>    char    szMsgTitle[32]; <br>    int     iString; <br> <br>    // Ignore any 'Changed context' errors. <br> <br>    if (dberr == 5701 || dberr == 5703) { <br>        return 0; <br>    } <br> <br>    LoadString(hInst, IDS_ERR_SQL_ERROR, szString, MAX_PATH); <br>    LoadString(hInst, IDS_MSC_DBERROR, szMsgTitle, 32); <br> <br>    iString = sizeof(szString) - strlen(szString); <br>    if (dberrstr != NULL) { <br>        strncpy(szString, dberrstr, iString); <br>    } <br>    else if (oserr != DBNOERR &amp;&amp; oserrstr != NULL) { <br>        strncpy(szString, oserrstr, iString); <br>    } <br>    szString[sizeof(szString)-1] = 0; <br> <br>    if (strstr(szString, "General SQL Server") == NULL) { <br>        MessageBox(NULL, szString, szMsgTitle, MB_ICONSTOP);     <br>    } <br> <br>    return(INT_CANCEL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
