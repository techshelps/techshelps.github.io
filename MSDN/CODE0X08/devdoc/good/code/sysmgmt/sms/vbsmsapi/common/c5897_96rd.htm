<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMSAPI.BAS</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5899"></a>SMSAPI.BAS</h2>
<pre><code>Option Explicit <br>'// ************************************************************************** <br>'// <br>'//  File: SMSAPI.H <br>'// <br>'//  Copyright (c) 1994, 1995 Microsoft Corp. <br>'// <br>'//  This is the header file for the SMS API. <br>'// <br>'//  This file contains all data definitions, manifests, return codes and <br>'//  API declarations that constitute the API set. <br>'// <br>'// <br>'// ************************************************************************** <br>' <br>' <br>' <br>'// ************************************************************************** <br>'// <br>'//  The SMS API set provides a set of interfaces to enable querying and, <br>'//  in some cases creation and deletion, of data from an SMS database. <br>'// <br>'//  SMS contains numerous objects to which an ISV needs access. These objects <br>'//  are (not in any particular order): packages, jobs, workstation command <br>'//  lines, program items, sites, domains, machines, machine groups. <br>'// <br>'//  The SMS API is built using a technology known as the objectity technique. <br>'//  This technique expresses all objects in terms of containers, folders, <br>'//  and scalars. All SMS objects are thus expressed in these terms. <br>'//  The advantage of this is that we have a standard interface to all <br>'//  objects. That is, the API does not distinguish between, say, a job and <br>'//  a machine. <br>'// <br>'//  The starting point is the container. There are certain types of container <br>'//  defined (container types below). A container is opened and then <br>'//  populated. The act of populating a container causes it to be filled with <br>'//  folders of defned types. A folder can contain sub-folders and scalars. <br>'//  Scalars are akin to leaf nodes in a hierarchy graph. The contain a <br>'//  name, type, and value. <br>'// <br>'//  Much of the power to the objectity technique is provided by filters. <br>'//  These are objects which specify selection criteria. Filters are applied <br>'//  by the user at the container level, at which point the implementation of <br>'//  the API will assume ownership of the filter. It is guaranteed that only <br>'//  folders matching the filters will be included in the container hierarchy. <br>'// <br>'//  Every folder can contain a set of scalars. Not all folders do, for <br>'//  example a machine folder does not. In some cases a folder contains a <br>'//  defined set of scalars, in other cases the scalar set can only be <br>'//  determined at run time. In cases where the scalar set is predetermined <br>'//  it will be documented in supporting documentation. <br>'// <br>'//  The APIs behave in an uniform manner. <br>'//  1. They all return a status code (SMS_STATUS). <br>'//  2. Where a value needs to be returned, it is done via a reference <br>'//     parameter. <br>'// <br>'//  An API is provided to determine the API version. Any problems involving <br>'//  the SMS API should include the information provided by this API. <br>'// <br>'//  The first step in using the APIs to to establish a connection to a <br>'//  datasource. Currently the only datasource supported in SQL, but the <br>'//  API is designed in such a way that additional datasources can be <br>'//  added. Two APIs are provided for dealing with datasources: <br>'//  DataSourceConnect and DataSourceDisonnect. The connect API returns a <br>'//  connection handle, this is used in subsequent calls to open containers. <br>'// <br>'//  Apart from these APIs, the rest of the API set is divided into four <br>'//  groups: <br>'//  1. Container APIs. <br>'//  2. Folder APIs. <br>'//  3. Scalar APIs. <br>'//  4. Filter APIs. <br>'// <br>'//  1. Container APIs. <br>'//  These allow a container to be opened, a filter to be applied to a <br>'//  container, a container to be populated with folders, a folder to be <br>'//  retrieved, and the container to be closed. An API also exists to <br>'//  return the number of folders currently contained in a container. <br>'// <br>'//  2. Folder APIs. <br>'//  These allow a for retrieval of various types of information about a <br>'//  folder (its ID or name, its type, the number of sub-folders, the number <br>'//  of scalars). Retrieval of sub-folders within a folder in both a <br>'//  sequential fashion and by name. Retrieval of scalars (sequential and by <br>'//  name. And closure of the folder. <br>'//  An API exists to allow folder creation. However, this is implementation <br>'//  dependant. That is, most folders do not permit creation, some (eg <br>'//  ceratin types of jobs) do. <br>'// <br>'//  3. Scalar APIs. <br>'//  There is a bit of overlap between this and the previous group. Although <br>'//  scalar retrieval is included in the Folder API group, it can also be <br>'//  considered a scalar API. <br>'//  An API is provided to set/update the value of a scalar. This can <br>'//  currently only be done in a folder that is being newly created. <br>'// <br>'//  4. Filter APIs. <br>'//  APIs for opening and closing a filter, and adding tokens into a filter. <br>'//  Filters are composed of one or more tokens of the same type. Some filters <br>'//  permit grouping of tokens within the filter (ie machine filter). This <br>'//  allows for complex boolean expressions. <br>'//  Tokens differ between different filters, but have a common interface. <br>'//  Tokens are contructed via the SmsAddToken API. <br>'// <br>'//  5. Filter container APIs <br>'//  Certain filters can be persistent, that is they are saved in the database <br>'//  and can be reloaded by separate processes. These filters can be created <br>'//  either the APIs, or via the SMS Admin. <br>'//   These APIs enable the retrieval of these filters from the datasource <br>'//  and the commital of new filters into the datasource. <br>'//  Currently machine filters are the only filters capable of exhibiting <br>'//  persistence. <br>'// <br>'// ************************************************************************** <br>' <br>'// ==================================================================== <br>'// <br>'//  Includes <br>'// <br>'// ==================================================================== <br>' <br>'/* VB: These includes must be explicitly listed in the VB makefile   */ <br>' <br>'include qrycodes.bas         // The query codes for Machine queries. <br>' <br>'include smsinfo.bas          // Manifests related to scalar settings. <br>' <br>'include objectty.bas         // Objectity engine. <br>' <br>' <br>'// ==================================================================== <br>'// <br>'//  Datasource definition information. <br>'// <br>'// ==================================================================== <br>' <br>'// <br>'// Supported datasources. <br>'// (NOTE: only sql supported currently). <br>'// <br> Type DATASOURCE_TYPE <br>     enum As Long <br> End Type <br>  <br> ' These are initialized in Init_DATASOURCE_TYPE_enums() <br> Global DB_SQL As DATASOURCE_TYPE <br> Global DB_SQL_CONNECTED As DATASOURCE_TYPE <br> Global DB_OTHER As DATASOURCE_TYPE <br>' <br>' <br>'// <br>'// Prototype for a decryption function. This is the last parameter <br>'// to the SQL_CONNECT_PARAMS structure. <br>'// When a user calls the DataSourceConnect API he can pass in the <br>'// user name and password in encrypted form. If the decryption function <br>'// pointer is non-null the the API will attempt to call this function <br>'// both for the user name and password. <br>'// The decryption function is user-supplied, it is expected to return <br>'// the decrypted data in the first parameter. <br>'// <br>' <br>'typedef void (*PDECRYPTFUNC)(char *pszBuffer, char *pszDecryptMe, char *pszKey); <br>'/* VB: This can not be done this way in VB  */ <br>' <br>' <br>'// <br>'//  The information block needed for the DataSourceConnect API. <br>'//  1. SQL datasource. <br>'// <br>' <br> Type SQL_CONNECT_PARAMS <br>     ds As DATASOURCE_TYPE <br>     pszServer As String                 '// SQL Server name. <br>     pszUserName As String               '// User name (possibly encrypted). <br>     pszPasswd As String                 '// Password (possibly encrypted). <br>     pszDbName As String                 '// Database name. <br>     pszKey As String                    '// Decryption key. <br>     pFunc As Long                       '// Pointer to a decryption function. <br> End Type <br>' <br>' <br>'// <br>'//  2. RESERVED DO NOT USE <br>'// <br>' <br>'typedef struct _SQL_CONNECT_CONNECTED_PARAMS { <br>'    DATASOURCE_TYPE ds; <br>'    HANDLE hDataSource; <br>'    const char *pszAccessType; <br>'} SQL_CONNECT_CONNECTED_PARAMS; <br>' <br>' <br>' <br>'// <br>'// This only has the type field. It is used for extracting the type <br>'// in such a fashion that user code doesn't have to imply any <br>'// particular data source. It has no use other than that. <br>'// <br>' <br> Type GENERIC <br>     ds As DATASOURCE_TYPE <br> End Type <br>' <br>' <br>' <br>'// We can now define the DATASOURCE. It is a union of the structs above. <br>'typedef union { <br>'    GENERIC             type; <br>'    SQL_CONNECT_PARAMS  sqlParams; <br>'    SQL_CONNECT_CONNECTED_PARAMS sqlConnectedParams; <br>'} DATASOURCE; <br>' <br>'/* VB: Unions can not be done in VB  */ <br>' <br>' <br>' <br>'// ==================================================================== <br>'// <br>'//  Return codes. See also objectty.h. <br>'// <br>'// ==================================================================== <br>'typedef DWORD SMS_STATUS;           // All APIs return an SMS_STATUS. <br>'/* VB: All API's return Long  */ <br>' <br> Global Const SMS_OK = OTT_OK <br> Global Const SMS_MORE_DATA = OTT_MORE_DATA <br> Global Const SMS_NO_MORE_DATA = OTT_NO_MORE_DATA <br> Global Const SMS_FOLDER_NO_UPDATE = OTT_FOLDER_NO_UPDATE <br>' <br>'// Error codes when registering (and accessing) containers and filters <br> Global Const SMS_DUPLICATE_CONTAINER_ID = OTT_DUPLICATE_CONTAINER_ID <br> Global Const SMS_DUPLICATE_FOLDER_ID = OTT_DUPLICATE_FOLDER_ID <br> Global Const SMS_DUPLICATE_FILTER_ID = OTT_DUPLICATE_FILTER_ID <br>' <br> Global Const SMS_DUPLICATE_FILTER = OTT_DUPLICATE_FILTER <br>' <br> Global Const SMS_SCALAR_NO_UPDATE = OTT_SCALAR_NO_UPDATE <br> Global Const SMS_SCALAR_WRONG_TYPE = OTT_SCALAR_WRONG_TYPE <br> Global Const SMS_INVALID_CONTAINER_ID = OTT_INVALID_CONTAINER_ID <br> Global Const SMS_INVALID_FOLDER_ID = OTT_INVALID_FOLDER_ID <br> Global Const SMS_INVALID_FILTER_ID = OTT_INVALID_FILTER_ID <br>' <br> Global Const SMS_CONTAINER_NO_UPDATE = OTT_CONTAINER_NO_UPDATE <br>' <br> Global Const SMS_PARAMETER_ERROR = OTT_PARAMETER_ERROR <br> Global Const SMS_UNSUPPORTED = OTT_UNSUPPORTED <br>' <br>'// This is returned when a specific object (folder or scalar) is <br>'// requested and not found. APIs returning this are GetFolderByID <br>'// and GetScalarByName. <br> Global Const SMS_NOT_FOUND = OTT_NOT_FOUND <br>' <br> Global Const SMS_PARENT_NOT_FOUND = OTT_PARENT_NOT_FOUND <br>' <br> Global Const SMS_CANT_DELETE = OTT_CANT_DELETE <br>' <br> Global Const SMS_NEW_FOLDER = OTT_NEW_FOLDER <br>' <br>'// Error when attempting to multiply link a folder. <br> Global Const SMS_FOLDER_LINKED = OTT_FOLDER_LINKED <br>' <br>'// Filter operations. <br> Global Const SMS_RANGE_ERROR = OTT_RANGE_ERROR <br>' <br>'// These are returned when a container operation is tried <br>'// when it shouldn't be. <br> Global Const SMS_CONTAINER_NOT_POPULATED = OTT_CONTAINER_NOT_POPULATED <br> Global Const SMS_CONTAINER_POPULATED = OTT_CONTAINER_POPULATED <br>' <br>' <br>'// Attempt to perform persistent operation on a non-persistent filter. <br> Global Const SMS_FILTER_NOT_PERSISTENT = OTT_FILTER_NOT_PERSISTENT <br>' <br>'// Error return if the connection handle of a filter doesn't match <br>'// that of a container to which the filter is being applied. <br> Global Const SMS_INVALID_CONNECTION_HANDLE = OTT_INVALID_CONNECTION_HANDLE <br> Global Const SMS_INVALID_FILTER_TYPE = OTT_INVALID_FILTER_TYPE <br> <br>'// Folder's can't be unlinked if there are multiple handles <br>'// to the same object. <br> Global Const SMS_IN_USE_BY_OTHER = OTT_IN_USE_BY_OTHER <br>' <br>' <br>'// User (ie non-engine) codes begin here. <br> Global Const SMS_ERROR = OTT_END + 1 <br> Global Const SMS_SQL_ERROR = OTT_END + 2 <br> Global Const SMS_INVALID_DATASOURCE = OTT_END + 3 <br> Global Const SMS_INVALID_HANDLE = OTT_END + 4 <br> Global Const SMS_INVALID_FOLDER_TYPE = OTT_END + 6 <br>' <br> Global Const SMS_CONNECT_FAILED = OTT_END + 7 <br> Global Const SMS_NO_CREATE = OTT_END + 8 <br> Global Const SMS_FOLDER_NOT_MODIFIED = OTT_END + 9 <br> Global Const SMS_INCORRECT_FOLDER_TYPE = OTT_END + 10 'Unused. <br> Global Const SMS_INVALID_PARAMETER = OTT_END + 11 <br> Global Const SMS_EMPTY = OTT_END + 12 <br>' <br>'// Error when attempting to commit a child folder when the <br>'// parent folder must be committed. <br> Global Const SMS_PARENT_NEEDS_COMMIT = OTT_END + 13 <br> Global Const SMS_PARENT_ALREADY_COMMITTED = OTT_END + 14 <br>' <br>'// Used in asynchronous folder retrieval. Indicates that there <br>'// might be more data but it isn't available yet. <br> Global Const SMS_NOT_READY = OTT_END + 15 <br>' <br> Global Const SMS_FILTER_NO_MODIFY = OTT_END + 16 <br> Global Const SMS_FOLDER_ALREADY_DELETED = OTT_END + 17 <br>' <br>'// Only allow one active connection. This is an SMS restriction. <br> Global Const SMS_ALREADY_CONNECTED = OTT_END + 18 <br> <br>'// Some failure in committing a folder <br> Global Const SMS_COMMIT_FAILED = OTT_END + 19 <br> <br> <br>'// Specific failure in linking a folder <br> Global Const SMS_DUPLICATE_FOLDER = OTT_END + 20 <br> <br> Global Const SMS_ERROR_LAST = OTT_END + 20 <br> <br> <br>'Error strings <br>'This array is initialized in Init_SMSError_array() <br>Global SMSError$(0 To SMS_ERROR_LAST) <br> <br>' <br>'// ==================================================================== <br>'// <br>'//  Various manifests. <br>'// <br>'// ==================================================================== <br>' <br>'// The location of the SMS registry root. <br> Global Const SMS_REG_ROOT = "SOFTWARE\Microsoft\SMS\" <br>' <br>'// The max size of character (string) data that we return. <br> Global Const SMS_DATA_BUFF_SIZE = 255 <br>' <br>' <br>'// 'SMSBUFF' and 'OBJDESCRIPTOR' used in object type enumeration APIs. <br>'// =================================================================== <br> <br>'// A character buffer. <br>'// ------------------- <br>'typedef char SMSBUFF[SMS_DATA_BUFF_SIZE+1]; <br> <br>'// Describes an object returned from SmsEnumObjects. <br>'// ------------------------------------------------- <br> Type OBJDESCRIPTOR <br>     objType As Long                   '// Type of this object. <br>     szName As String                  '// Object name (eg 'Personal Computer') <br>     szFriendlyName As String          '// Friendly name. Only used in groups <br>                                       '// where szName would be, eg, <br>                                       '// 'MICROSOFT|IDENTIFICATION|1.0', the <br>                                       '// friendly name would be 'Identification'. <br>     bGotFriendlyName As Long          '// TRUE if we have a friendly name. <br> <br>     dwRelopMin As Long                '// For attributes, indicates range of <br>     dwRelopMax As Long                '// relational operators that can be used <br>                                       '// for this attribute. <br>     bGotRelops As Long                '// TRUE if we have the relops fields set. <br> <br> End Type <br> <br> <br>'// Object types. <br>'// ============= <br>'// This is the value that is inserted by the object <br>'// enumeration APIs into the OBJDESCRIPTOR structure. <br>'// -------------------------------------------------- <br> Global Const OT_ARCHLIST = 1 <br> Global Const OT_ARCH = 2 <br> Global Const OT_GROUP = 3 <br> Global Const OT_ATTRIBUTE = 4 <br> <br> Global Const OT_PLATFORMS = 5 <br> Global Const OT_PLATFORM_PDF = 6 <br> Global Const OT_PLATFORM_WINST = 7 <br> Global Const OT_PLATFORM_NAD = 8 <br> <br> Global Const OT_UNKNOWN = 100 <br> <br> <br> <br>'// -------------------------------------------------------------------- <br>'// Flags for Populate options. <br>'// -------------------------------------------------------------------- <br> Global Const POP_SYNC = &amp;H0&amp; <br> Global Const POP_ASYNC = &amp;H1&amp; <br> Global Const POP_EVENT = &amp;H10&amp; <br> Global Const POP_WINDOW = &amp;H20&amp; <br>' <br>' <br>'// -------------------------------------------------------------------- <br>'// Folder types supported by smsapi (MUST NOT BEGIN AT ZERO). <br>'// -------------------------------------------------------------------- <br> Global Const F_SITE = 1                 'Site folder <br> Global Const F_MACHINE = 2              'Machine folder <br> Global Const F_GROUP = 3                'Subfolder of machine <br> Global Const F_DOMAIN = 4               'Domain folder, subfolder of a site <br> <br>'// Jobs <br> Global Const F_SYSTEMJOB = 5            'System (NAD/Site) job folder <br>'Global Const F_MINIJOB = 6              'Mini-job folder <br> Global Const F_INSTALLJOB = 7           'Job folder (wksta install) <br> Global Const F_SRVINSTALLJOB = 8        'Job folder (server install) <br> Global Const F_REMPKGJOB = 9            'Remove package Job folder <br>' <br> Global Const F_PACKAGE = 10             'Packages <br> Global Const F_WCL = 11                 'Workstation command lines <br> Global Const F_PROGITEM = 12            'Program items <br> Global Const F_INVENTORY = 13           'Inventory rules. <br>' <br> Global Const F_MACHINEGROUP = 14        'Machine group <br> Global Const F_SITEGROUP = 15           'Site group folder <br>' <br>'// -------------------------------------------------------------------- <br>'// Container types supported by smsapi (MUST NOT BEGIN AT ZERO). <br>'// -------------------------------------------------------------------- <br> Global Const C_SITE = 1                 'Site container <br> Global Const C_JOB = 2                  'Job container <br> Global Const C_MACHINE = 3              'Machine container <br> Global Const C_PACKAGE = 4              'Package container <br> Global Const C_MACHINEGROUP = 5         'Machine group <br> Global Const C_SITEGROUP = 6            'Site group <br>' <br>' <br>'// ==================================================================== <br>'// <br>'//      Filter information. <br>'// <br>'// ==================================================================== <br>' <br>' <br>'// -------------------------------------------------------------------- <br>'//  Filter types <br>'// -------------------------------------------------------------------- <br> Global Const SITE_FILTER = 1 <br> Global Const MACHINE_FILTER = 2 <br> Global Const GROUP_FILTER = 3 <br> Global Const JOB_FILTER = 4 <br> Global Const ARCHITECTURE_FILTER = 5 <br> Global Const PACKAGE_FILTER = 6 <br> Global Const ATTRIBUTE_FILTER = 7 <br> Global Const SITELIMIT_FILTER = 8 <br>' <br>' <br>'// -------------------------------------------------------------------- <br>'// Token types. <br>'// -------------------------------------------------------------------- <br> Global Const TOKEN_USER = &amp;H8      '1000 bit 3 always set for user-token <br> Global Const TOKEN_OR = &amp;H2        '0010 bit 1 always set for AND/OR <br> Global Const TOKEN_AND = &amp;H3       '0011 bit 1 always set for AND/OR <br> Global Const TOKEN_OPENPAREN = &amp;H4 '0100 bit 2 always set for PAREN <br> Global Const TOKEN_CLOSEPAREN = &amp;H5'0101 bit 2 always set for PAREN <br> Global Const TOKEN_NOTIN = &amp;H20    '10100 bit 2 set for a PAREN plus bit 4 for an extra indicator. <br> Global Const TOKEN_OPERATOR = &amp;H2  'Detects both AND or OR <br> Global Const TOKEN_PAREN = &amp;H4     'Detects either open or close paren <br>' <br>' <br>'// -------------------------------------------------------------------- <br>'// Manifests used in filter token APIs. <br>'// -------------------------------------------------------------------- <br> Global Const AT_START = OTT_AT_START 'Token will be inserted at start of expression <br> Global Const AT_END = OTT_AT_END     'Token will be appended to end of expression <br>' <br>'// <br>'// Flags fields in SmsManipulateTokens. <br>'// <br> Global Const TOK_GROUP = 1          'Flags field in SmsManipulateTokens <br> Global Const TOK_UNGROUP = 2 <br> Global Const TOK_DELETE = 3 <br> Global Const TOK_GROUP_NOT = 4 <br>' <br>' <br> Sub Init_DATASOURCE_TYPE_enums () <br>     DB_SQL.enum = 0 <br>     DB_SQL_CONNECTED.enum = 1 <br>     DB_OTHER.enum = 2 <br> End Sub <br> <br> Function Init_SMSAPI% () <br>     'Default return value True (DLL loaded) <br>     Init_SMSAPI% = True <br>  <br>     'Initialize "included" modules <br>     Init_OBJECTTY <br>     Init_QRYCODES <br>  <br>     'Initialize this module <br>     Init_DATASOURCE_TYPE_enums <br>  <br>     'Initialize error string array <br>     Init_SMSError_array <br> End Function <br> <br> Sub Init_SMSError_array () <br>     SMSError$(SMS_OK) = "SMS_OK" <br>     SMSError$(SMS_MORE_DATA) = "SMS_MORE_DATA" <br>     SMSError$(SMS_NO_MORE_DATA) = "SMS_NO_MORE_DATA" <br>     SMSError$(SMS_FOLDER_NO_UPDATE) = "SMS_FOLDER_NO_UPDATE" <br>  <br>'// Error codes when registering (and accessing) containers and filters <br>     SMSError$(SMS_DUPLICATE_CONTAINER_ID) = "SMS_DUPLICATE_CONTAINER_ID" <br>     SMSError$(SMS_DUPLICATE_FOLDER_ID) = "SMS_DUPLICATE_FOLDER_ID" <br>     SMSError$(SMS_DUPLICATE_FILTER_ID) = "SMS_DUPLICATE_FILTER_ID" <br>     SMSError$(SMS_DUPLICATE_FILTER) = "SMS_DUPLICATE_FILTER" <br>      <br>     SMSError$(SMS_SCALAR_NO_UPDATE) = "SMS_SCALAR_NO_UPDATE" <br>     SMSError$(SMS_SCALAR_WRONG_TYPE) = "SMS_SCALAR_WRONG_TYPE" <br>     SMSError$(SMS_INVALID_CONTAINER_ID) = "SMS_INVALID_CONTAINER_ID" <br>     SMSError$(SMS_INVALID_FOLDER_ID) = "SMS_INVALID_FOLDER_ID" <br>     SMSError$(SMS_INVALID_FILTER_ID) = "SMS_INVALID_FILTER_ID" <br>  <br>     SMSError$(SMS_CONTAINER_NO_UPDATE) = "SMS_CONTAINER_NO_UPDATE" <br>  <br>     SMSError$(SMS_PARAMETER_ERROR) = "SMS_PARAMETER_ERROR" <br>     SMSError$(SMS_UNSUPPORTED) = "SMS_UNSUPPORTED" <br>  <br>'// This is returned when a specific object (folder or scalar) is <br>'// requested and not found. APIs returning this are GetFolderByID <br>'// and GetScalarByName. <br>     SMSError$(SMS_NOT_FOUND) = "SMS_NOT_FOUND" <br>  <br>     SMSError$(SMS_PARENT_NOT_FOUND) = "SMS_PARENT_NOT_FOUND" <br>      <br>     SMSError$(SMS_CANT_DELETE) = "SMS_CANT_DELETE" <br>      <br>     SMSError$(SMS_NEW_FOLDER) = "SMS_NEW_FOLDER" <br>  <br>'// Error when attempting to multiply link a folder. <br>     SMSError$(SMS_FOLDER_LINKED) = "SMS_FOLDER_LINKED" <br>      <br>'// Filter operations. <br>     SMSError$(SMS_RANGE_ERROR) = "SMS_RANGE_ERROR" <br>      <br>'// These are returned when a container operation is tried <br>'// when it shouldn't be. <br>     SMSError$(SMS_CONTAINER_NOT_POPULATED) = "SMS_CONTAINER_NOT_POPULATED" <br>     SMSError$(SMS_CONTAINER_POPULATED) = "SMS_CONTAINER_POPULATED" <br>  <br>'// Attempt to perform persistent operation on a non-persistent filter. <br>     SMSError$(SMS_FILTER_NOT_PERSISTENT) = "SMS_FILTER_NOT_PERSISTENT" <br>  <br>'// Error return if the connection handle of a filter doesn't match <br>'// that of a container to which the filter is being applied. <br>     SMSError$(SMS_INVALID_CONNECTION_HANDLE) = "SMS_INVALID_CONNECTION_HANDLE" <br>  <br>'// User (ie non-engine) codes begin here. <br>     SMSError$(SMS_ERROR) = "SMS_ERROR" <br>     SMSError$(SMS_SQL_ERROR) = "SMS_SQL_ERROR" <br>     SMSError$(SMS_INVALID_DATASOURCE) = "SMS_INVALID_DATASOURCE" <br>     SMSError$(SMS_INVALID_HANDLE) = "SMS_INVALID_HANDLE" <br>     SMSError$(SMS_INVALID_FILTER_TYPE) = "SMS_INVALID_FILTER_TYPE" <br>     SMSError$(SMS_INVALID_FOLDER_TYPE) = "SMS_INVALID_FOLDER_TYPE" <br>  <br>     SMSError$(SMS_CONNECT_FAILED) = "SMS_CONNECT_FAILED" <br>     SMSError$(SMS_NO_CREATE) = "SMS_NO_CREATE" <br>     SMSError$(SMS_FOLDER_NOT_MODIFIED) = "SMS_FOLDER_NOT_MODIFIED" <br>     SMSError$(SMS_INCORRECT_FOLDER_TYPE) = "SMS_INCORRECT_FOLDER_TYPE" <br>     SMSError$(SMS_INVALID_PARAMETER) = "SMS_INVALID_PARAMETER" <br>     SMSError$(SMS_EMPTY) = "SMS_EMPTY" <br>  <br>'// Error when attempting to commit a child folder when the <br>'// parent folder must be committed. <br>     SMSError$(SMS_PARENT_NEEDS_COMMIT) = "SMS_PARENT_NEEDS_COMMIT" <br>     SMSError$(SMS_PARENT_ALREADY_COMMITTED) = "SMS_PARENT_ALREADY_COMMITTED" <br>  <br>'// Used in asynchronous folder retrieval. Indicates that there <br>'// might be more data but it isn't available yet. <br>     SMSError$(SMS_NOT_READY) = "SMS_NOT_READY" <br>      <br>     SMSError$(SMS_FILTER_NO_MODIFY) = "SMS_FILTER_NO_MODIFY" <br>     SMSError$(SMS_FOLDER_ALREADY_DELETED) = "SMS_FOLDER_ALREADY_DELETED" <br>  <br>'// Only allow one active connection (SMS restriction). <br>     SMSError$(SMS_ALREADY_CONNECTED) = "SMS_ALREADY_CONNECTED" <br> End Sub <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
