<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VB4SMS32.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5903"></a>VB4SMS32.CPP</h2>
<pre><code>//**************************************************************************** <br>// <br>//  Copyright (c) 1995, Microsoft Corporation <br>// <br>//  File:  VB4SMS32.CPP <br>// <br>//  Implementation file for the 32-bit Visual Basic interface DLL <br>//  for SMSAPI.DLL (a Win32 dll) <br>// <br>//  History: <br>// <br>//      Gary F. Fuehrer, SEA     01 Mar 96    Created. <br>// <br>//**************************************************************************** <br> <br>/*********************  Header Files **********************/ <br> <br>#define STRICT <br>#define WIN32_EXTRA_LEAN <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;winnls.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;string.h&gt; <br> <br>/****************************************************************************/ <br>#include "smsapi.h" <br>#include "vb4sms32.h" <br>typedef void* HLSTR; <br>typedef USHORTERR;// err <br> <br>// Default selector limit for 32bit char* <br>#define MAX_VB_STRING  SMS_DATA_BUFF_SIZE+1 <br> <br> <br>/**************************** Globals ***************************************/ <br>static HANDLE  ghInst = NULL; <br> <br>// An array of open connections.  This is merely a convenience for the user. <br>// Any connections made beyond MAX_CONNECTIONS won't be disconnected by WEP. <br>#define MAX_CONNECTIONS  16 <br>static HANDLE     gahConnections[MAX_CONNECTIONS]; <br> <br>// General use buffer of length SMS_DATA_BUFF_SIZE <br>static char gStrBuff[SMS_DATA_BUFF_SIZE + 1]; <br> <br>// General use buffer of length SMS_DATA_BUFF_SIZE <br>static char gNameBuff[SMS_DATA_BUFF_SIZE + 1]; <br> <br>// General use TOKEN buffer <br>static TOKEN gTokenBuff; <br> <br>/****************************************************************************/ <br> <br> <br>/********************************************************************\ <br>* Function: int FAR PASCAL LibMain( HINSTANCE, WORD, WORD, LPSTR )   * <br>*                                                                    * <br>*  Purpose: DLL entry point                                          * <br>*                                                                    * <br>* Comments: Loads the Win32 stub application                         * <br>*                                                                    * <br>*                                                                    * <br>\********************************************************************/ <br> <br>BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) <br>{ <br>    int nIndex; <br> <br>    switch( ul_reason_for_call ) { <br>    case DLL_PROCESS_ATTACH: <br>        ghInst = hModule; <br>        break; <br> <br>    case DLL_THREAD_ATTACH: <br>        break; <br> <br>    case DLL_THREAD_DETACH: <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br>        // Disconnect any known open connections <br>        for (nIndex = 0; nIndex &lt; MAX_CONNECTIONS; nIndex++) <br>            if (gahConnections[nIndex]) <br>                SmsDataSourceDisconnect(gahConnections[nIndex]); <br>        break; <br>    } <br>    return TRUE; <br>} <br> <br>/*********************** Utility Routines and Macros ************************/ <br> <br>BYTE gbANSI = FALSE; <br>#define VBStringLength(String) ((gbANSI) ? SysStringByteLen(String) \ <br>                                         : SysStringLen(String)) <br> <br>// Copy VB string to an ANSI SZ string <br>inline SMS_STATUS <br>CopyString2Sms(char *pszDest, BSTR pszSrc, UINT uLimit = MAX_VB_STRING) <br>{ <br>    if (uLimit &lt;= 0) return SMS_OK; <br> <br>    UINT uLen = min(VBStringLength(pszSrc), uLimit-1); <br>    if (gbANSI) <br>        strncpy(pszDest, (char*)pszSrc, uLen); <br>    else WideCharToMultiByte(CP_ACP, 0, pszSrc, uLen, pszDest, uLimit, <br>                             NULL, NULL); <br>    pszDest[uLen] = '\0'; <br> <br>    return SMS_OK; <br>} <br> <br>// Copy ANSI SZ string to a VB string (freeing the old one) <br>inline SMS_STATUS <br>CopyString2VB(BSTR* pBStr, const char *pszSrc, UINT uLimit = MAX_VB_STRING) <br>{ <br>    UINT uLen = min(strlen(pszSrc), uLimit-1); <br> <br>    // Allocate a VB string of this length <br>    BSTR pwsz = NULL; <br>    if (uLen != 0) <br>        pwsz = SysAllocStringByteLen(NULL, (gbANSI) ? uLen : uLen &lt;&lt; 1); <br> <br>    if (pwsz != NULL || uLen == 0) <br>    { <br>        if (*pBStr != NULL) SysFreeString(*pBStr); <br>        *pBStr = pwsz; <br> <br>        if (pwsz == NULL) return SMS_OK; <br> <br>        if (gbANSI) <br>            strncpy((char*)pwsz, pszSrc, uLen); <br>        else MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszSrc, uLen, <br>                                 pwsz, uLen); <br> <br>        return SMS_OK; <br>    } <br> <br>    return SMS_ERROR; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>///////////     The APIs     ////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////// <br> <br> <br>// ==================================================================== <br>//      Version number API. <br>// ==================================================================== <br>                                                                        /* VB: <br>  Declare Function SmsAPIVer&amp; Lib "vb4sms32.dll" (pVersion As String) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsAPIVerVB(BSTR* pbstrVersion) <br>{ <br>    char      *pszVer32; <br>    SMS_STATUS ret; <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsAPIVer(&amp;pszVer32); <br> <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(pbstrVersion, pszVer32); <br> <br>    return ret; <br>} <br> <br> <br>// ==================================================================== <br>//      Connection APIs. <br>// ==================================================================== <br>                                                                        /* VB: <br>  Declare Function SmsDataSourceConnect&amp; Lib "vb4sms32.dll" (pDataSource As SQL_CONNECT_PARAMS, phConn As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsDataSourceConnectVB(SQL_CONNECT_PARAMS *pSqlCP, HANDLE *phConn) <br>{ <br>    int nIndex; <br>    DATASOURCE ds; <br>    SMS_STATUS ret = SMS_ERROR; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to SQL_CONNECT_PARAMS is invalid) <br>    if (IsBadWritePtr(pSqlCP, sizeof(*pSqlCP))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // See if we can find an availiable connection slot. <br>    for (nIndex = 0; nIndex &lt; MAX_CONNECTIONS; nIndex++) <br>        if (!gahConnections[nIndex]) break; <br> <br>    // Call 32bit SMS API routine <br>    ds.sqlParams = *pSqlCP; <br>    ret = SmsDataSourceConnect(&amp;ds, phConn); <br> <br>    if (ret == SMS_OK &amp;&amp; nIndex &lt; MAX_CONNECTIONS) <br>        gahConnections[nIndex] = *phConn; <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsDataSourceDisconnect&amp; Lib "vb4sms32.dll" (ByVal hConn As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsDataSourceDisconnectVB(HANDLE hConn) <br>{ <br>    int        nIndex; <br>    SMS_STATUS ret = SMS_ERROR; <br> <br>    // Try to find the connection in the list of known connections <br>    for (nIndex = 0; nIndex &lt; MAX_CONNECTIONS; nIndex++) <br>        if (hConn == gahConnections[nIndex]) break; <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsDataSourceDisconnect(hConn); <br> <br>    if (ret == SMS_OK &amp;&amp; nIndex &lt; MAX_CONNECTIONS) <br>        gahConnections[nIndex] = 0; <br> <br>    return ret; <br>} <br> <br> <br>// ==================================================================== <br>//      Engine APIs. <br>// ==================================================================== <br> <br>HRESULT <br>AllocVBArray(SAFEARRAY* &amp;pArray, DWORD cArray, UINT uElemSize) <br>{ <br> <br>    if (pArray != NULL) <br>    { <br>        // See if the array is the right kind <br>        if (SafeArrayGetElemsize(pArray) != uElemSize) return E_INVALIDARG; <br> <br>        // See if the array is already large enough <br>        if (cArray &lt;= pArray-&gt;rgsabound[0].cElements) return SMS_OK; <br> <br>        SAFEARRAYBOUND sab = pArray-&gt;rgsabound[0]; <br>        sab.cElements = cArray; <br>        return SafeArrayRedim(pArray, &amp;sab); <br>    } <br>    else <br>    { <br>        // Allocate an array descriptor for an array of user defined types <br>        HRESULT ret = SafeArrayAllocDescriptor(1, &amp;pArray); <br>        if (ret != S_OK) return ret; <br> <br>        // Set the element size and array bounds <br>        pArray-&gt;cbElements = uElemSize; <br>        pArray-&gt;rgsabound[0].lLbound = 0; <br>        pArray-&gt;rgsabound[0].cElements = cArray; <br>        return SafeArrayAllocData(pArray); <br>    } <br>} <br> <br>SMS_STATUS <br>CopyFolderInfo2VB(FOLDER_INFO *pFolderInfoVB, FOLDER_INFO *pFolderInfo) <br>{ <br>    SMS_STATUS ret; <br> <br>    // Preserve the BSTR and SAFEARRAY members in the FOLDER_INFO from VB <br>    char*           pszTagVB = pFolderInfoVB-&gt;pszTag; <br>    DWORD*          pFolderTagsVB = pFolderInfoVB-&gt;pFolderTags; <br>    DWORD*          pFilterTagsVB = pFolderInfoVB-&gt;pFilterTags; <br>    SCALAR_INFOVB*  pScalarsVB = (SCALAR_INFOVB*)pFolderInfoVB-&gt;pScalars; <br> <br>    // Copy the folder info structure into the VB array <br>    *pFolderInfoVB = *pFolderInfo; <br> <br>    // Restore members of FOLDER_INFO before possible exit <br>    pFolderInfoVB-&gt;pszTag = pszTagVB; <br>    pFolderInfoVB-&gt;pFolderTags = pFolderTagsVB; <br>    pFolderInfoVB-&gt;pFilterTags = pFilterTagsVB; <br>    pFolderInfoVB-&gt;pScalars = (SCALAR_INFO*)pScalarsVB; <br> <br>    // Copy the pszTag member <br>    ret = CopyString2VB((BSTR*)&amp;pFolderInfoVB-&gt;pszTag, pFolderInfo-&gt;pszTag); <br>    if (ret != SMS_OK) return ret; <br> <br>    // Copy the pFolderTags array <br>    if (pFolderInfo-&gt;ctFolders &gt; 0) <br>    { <br>        // Create or Redim as necessary <br>        if (AllocVBArray((SAFEARRAY*&amp;)pFolderInfoVB-&gt;pFolderTags, <br>                         pFolderInfo-&gt;ctFolders, <br>                         sizeof(*pFolderTagsVB)) != S_OK) <br>            return SMS_ERROR; <br> <br>        // Lock down the array and obtain pointer to the data <br>        if (SafeArrayAccessData((SAFEARRAY*)pFolderInfoVB-&gt;pFolderTags, <br>                                (void**)&amp;pFolderTagsVB) != S_OK) <br>            return SMS_ERROR; <br> <br>        // Copy the array and unlock it <br>        memcpy(pFolderTagsVB, pFolderInfo-&gt;pFolderTags, <br>               pFolderInfo-&gt;ctFolders * sizeof(*pFolderTagsVB)); <br>        SafeArrayUnaccessData((SAFEARRAY*)pFolderInfoVB-&gt;pFolderTags); <br>    } <br> <br>    // Copy the pFilterTags array <br>    if (pFolderInfo-&gt;ctFilters &gt; 0) <br>    { <br>        // Create or Redim as necessary <br>        if (AllocVBArray((SAFEARRAY*&amp;)pFolderInfoVB-&gt;pFilterTags, <br>                         pFolderInfo-&gt;ctFilters, <br>                         sizeof(*pFilterTagsVB)) != S_OK) <br>            return SMS_ERROR; <br> <br>        // Lock down the array and obtain pointer to the data <br>        if (SafeArrayAccessData((SAFEARRAY*)pFolderInfoVB-&gt;pFilterTags, <br>                                (void**)&amp;pFilterTagsVB) != S_OK) <br>            return SMS_ERROR; <br> <br>        // Copy the array and unlock it <br>        memcpy(pFilterTagsVB, pFolderInfo-&gt;pFilterTags, <br>               pFolderInfo-&gt;ctFilters * sizeof(*pFilterTagsVB)); <br>        SafeArrayUnaccessData((SAFEARRAY*)pFolderInfoVB-&gt;pFilterTags); <br>    } <br> <br>    // Copy the pScalars array <br>    if (pFolderInfo-&gt;ctScalars &gt; 0) <br>    { <br>        // Create or Redim as necessary <br>        if (AllocVBArray((SAFEARRAY*&amp;)pFolderInfoVB-&gt;pScalars, <br>                         pFolderInfo-&gt;ctScalars, <br>                         sizeof(*pScalarsVB)) != S_OK) return SMS_ERROR; <br> <br>        // Lock down the array and obtain pointer to the data <br>        if (SafeArrayAccessData((SAFEARRAY*)pFolderInfoVB-&gt;pScalars, <br>                                (void**)&amp;pScalarsVB) != S_OK) return SMS_ERROR; <br> <br>        // Copy the array and unlock it <br>        DWORD dwIndex = pFolderInfo-&gt;ctScalars; <br>        SCALAR_INFO* pScalars = pFolderInfo-&gt;pScalars; <br>        while (dwIndex-- &gt; 0) <br>        { <br>            pScalarsVB-&gt;scType = pScalars-&gt;scType; <br>            pScalars-&gt;fAccess = pScalars-&gt;fAccess; <br>            ret = CopyString2VB(&amp;pScalarsVB-&gt;szName, pScalars-&gt;szName); <br>            if (ret != SMS_OK) break; <br> <br>            // Advance to next scalar <br>            pScalarsVB++; <br>            pScalars++; <br>        } <br>        SafeArrayUnaccessData((SAFEARRAY*)pFolderInfoVB-&gt;pScalars); <br>    } <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsDescribeFolder&amp; Lib "vb4sms32.dll" (tObjectity As BASETYPE, ByVal dwTag As Long, pFolderInfo As FOLDER_INFO) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsDescribeFolderVB(BASETYPE* tObjectity, DWORD dwTag, <br>                    LPSAFEARRAY* ppArray) <br>{ <br>    SAFEARRAY* &amp;pArray = *ppArray; <br>    SMS_STATUS   ret; <br> <br>    // Create or Redim as necessary <br>    FOLDER_INFO* pFoldersVB; <br>    if (AllocVBArray(pArray, 1, sizeof(*pFoldersVB)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pFoldersVB) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Call 32bit SMS API routine <br>    FOLDER_INFO *pFolderInfo; <br>    ret = SmsDescribeFolder(*tObjectity, dwTag, &amp;pFolderInfo); <br>    if (ret == SMS_OK) <br>        // Copy the FOLDER_INFO struct from 32bit land <br>        ret = CopyFolderInfo2VB(pFoldersVB, pFolderInfo); <br> <br>    // Unlock the VB array <br>    SafeArrayUnaccessData(pArray); <br>    return ret; <br>} <br> <br> <br>typedef SMS_STATUS (*ENUM_FN)(FOLDER_INFO**, DWORD*); <br> <br>SMS_STATUS <br>SmsEnumFoldersContainers(LPSAFEARRAY* ppArray, DWORD *pCount, ENUM_FN SmsEnum) <br>{ <br>    SAFEARRAY* &amp;pArray = *ppArray; <br>    FOLDER_INFO* pFoldersVB; <br>    SMS_STATUS  ret; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (pCount is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Count is too big) <br>    if (*pCount &gt;= 0x80000000 / sizeof(*pFoldersVB)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Get the count of FOLDER_INFOs <br>    *pCount = 0; <br>    ret = SmsEnum(NULL, pCount); <br>    if (ret != SMS_MORE_DATA) return ret; <br> <br>    // Create or Redim as necessary <br>    if (AllocVBArray(pArray, *pCount, sizeof(*pFoldersVB)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pFoldersVB) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Get an array large enough to accept FOLDER_INFO pointers <br>    DWORD cFolders = *pCount; <br>    FOLDER_INFO** ppFolders = new FOLDER_INFO*[cFolders]; <br>    if (ppFolders != NULL) <br>    { <br>        // Call 32bit SMS API routine <br>        ret = SmsEnum(ppFolders, pCount); <br> <br>        if (ret == SMS_OK) <br>            for (DWORD dwIndex = 0; dwIndex &lt; cFolders; dwIndex++) <br>            { <br>                ret = CopyFolderInfo2VB(&amp;pFoldersVB[dwIndex], <br>                                        ppFolders[dwIndex]); <br>                if (ret != SMS_OK) break; <br>            } <br> <br>        // Free the array of FOLDER_INFO pointers <br>        delete[] ppFolders; <br>        ppFolders = NULL; <br>    } <br>    else ret = SMS_ERROR; <br> <br>    // Unlock the VB array of FOLDER_INFOs <br>    SafeArrayUnaccessData(pArray); <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsEnumContainers&amp; Lib "vb4sms32.dll" (Containers() As FOLDER_INFO, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsEnumContainersVB(LPSAFEARRAY* ppArray, DWORD *pCount) <br>{ <br>    return SmsEnumFoldersContainers(ppArray, pCount, SmsEnumContainers); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsEnumFolders&amp; Lib "vb4sms32.dll" (Folders() As FOLDER_INFO, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsEnumFoldersVB(LPSAFEARRAY* ppArray, DWORD *pCount) <br>{ <br>    return SmsEnumFoldersContainers(ppArray, pCount, SmsEnumFolders); <br>} <br> <br>SMS_STATUS <br>CopyFilterInfo2VB(FILTER_INFOVB *pFilterInfoVB, FILTER_INFO *pFilterInfo) <br>{ <br>    SMS_STATUS ret = SMS_OK; <br> <br>    // szTag <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pFilterInfoVB-&gt;szTag, <br>                            pFilterInfo-&gt;szTag, <br>                            sizeof(pFilterInfo-&gt;szTag)); <br> <br>    // filterType <br>    pFilterInfoVB-&gt;filterType = pFilterInfo-&gt;filterType; <br> <br>    // szName <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pFilterInfoVB-&gt;szName, <br>                            pFilterInfo-&gt;szName, <br>                            sizeof(pFilterInfo-&gt;szName)); <br> <br>    // szValue <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pFilterInfoVB-&gt;szValue, <br>                            pFilterInfo-&gt;szValue, <br>                            sizeof(pFilterInfo-&gt;szValue)); <br> <br>    // szOperator <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pFilterInfoVB-&gt;szOperator, <br>                            pFilterInfo-&gt;szOperator, <br>                            sizeof(pFilterInfo-&gt;szOperator)); <br>     <br>    // szArchitecture <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pFilterInfoVB-&gt;szArchitecture, <br>                            pFilterInfo-&gt;szArchitecture, <br>                            sizeof(pFilterInfo-&gt;szArchitecture)); <br> <br>    // szGroupClass <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pFilterInfoVB-&gt;szGroupClass, <br>                            pFilterInfo-&gt;szGroupClass, <br>                            sizeof(pFilterInfo-&gt;szGroupClass)); <br> <br>    // szAttributeName <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pFilterInfoVB-&gt;szAttributeName, <br>                            pFilterInfo-&gt;szAttributeName, <br>                            sizeof(pFilterInfo-&gt;szAttributeName)); <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsEnumFilters&amp; Lib "vb4sms32.dll" (Filters() As FILTER_INFO, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsEnumFiltersVB(LPSAFEARRAY* ppArray, DWORD *pCount) <br>{ <br>    SAFEARRAY* &amp;pArray = *ppArray; <br>    FILTER_INFOVB* pFiltersVB; <br>    SMS_STATUS  ret; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (pCount is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Count is too big) <br>    if (*pCount &gt;= 0x80000000 / sizeof(*pFiltersVB)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Get the count of FILTER_INFOs <br>    *pCount = 0; <br>    ret = SmsEnumFilters(NULL, pCount); <br>    if (ret != SMS_MORE_DATA) return ret; <br> <br>    // Create or Redim as necessary <br>    if (AllocVBArray(pArray, *pCount, sizeof(*pFiltersVB)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pFiltersVB) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Get an array large enough to accept FILTER_INFO pointers <br>    DWORD cFilters = *pCount; <br>    FILTER_INFO* pFilters = new FILTER_INFO[cFilters]; <br>    if (pFilters != NULL) <br>    { <br>        // Call 32bit SMS API routine <br>        ret = SmsEnumFilters(pFilters, pCount); <br> <br>        if (ret == SMS_OK) <br>            for (DWORD dwIndex = 0; dwIndex &lt; cFilters; dwIndex++) <br>            { <br>                ret = CopyFilterInfo2VB(&amp;pFiltersVB[dwIndex], <br>                                        &amp;pFilters[dwIndex]); <br>                if (ret != SMS_OK) break; <br>            } <br> <br>        // Unlock the array of FILTER_INFO pointers <br>        delete[] pFilters; <br>        pFilters = NULL; <br>    } <br>    else ret = SMS_ERROR; <br> <br>    // Unlock the VB array of FILTER_INFOs <br>    SafeArrayUnaccessData(pArray); <br>    return ret; <br>} <br> <br> <br>// ==================================================================== <br>//      Container APIS. <br>// ==================================================================== <br>                                                                        /* VB: <br>  Declare Function SmsOpenContainer&amp; Lib "vb4sms32.dll" (ByVal cType As Long, ByVal hConnection As Long, phContainer As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsOpenContainerVB(DWORD cType, HANDLE hConnection, HANDLE *phContainer) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Container Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phContainer, sizeof(*phContainer))) <br>        return SMS_INVALID_PARAMETER; <br>     <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsOpenContainer(cType, hConnection, phContainer); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsSetFilter&amp; Lib "vb4sms32.dll" (ByVal hContainer As Long, ByVal hFilter As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsSetFilterVB(HANDLE hContainer, HANDLE hFilter) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsSetFilter(hContainer, hFilter); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsPopulate&amp; Lib "vb4sms32.dll" (ByVal hContainer As Long, ByVal dwOptions As Long, pNotify As Any) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsPopulateVB(HANDLE hContainer, DWORD dwOptions, NOTIFY* pNotify) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Folder Handle from VB is invalid) <br>    if (dwOptions != POP_SYNC  <br>                           &amp;&amp; IsBadWritePtr((void*)pNotify, sizeof(*pNotify))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsPopulate(hContainer, dwOptions, pNotify); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetNextFolder&amp; Lib "vb4sms32.dll" (ByVal hParent As Long, ByVal fType As Long, phFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetNextFolderVB(HANDLE hParent, DWORD fType, HANDLE *phFolder) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Folder Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phFolder, sizeof(*phFolder))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsGetNextFolder(hParent, fType, phFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsCloseContainer&amp; Lib "vb4sms32.dll" (ByVal hContainer As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCloseContainerVB(HANDLE hContainer) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsCloseContainer(hContainer); <br>} <br> <br> <br>// ==================================================================== <br>//  Folder (collection) APIs. <br>//  A collection contains other things, that is it can have embedded <br>//  collections and it can also have properties (scalars). <br>// ==================================================================== <br>                                                                        /* VB: <br>  Declare Function SmsCreateFolder&amp; Lib "vb4sms32.dll" (ByVal hParent As Long, ByVal fType As Long, ByVal pszFolderID As String, phFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCreateFolderVB(HANDLE hParent, DWORD fType, const char *pszFolderID, <br>                  HANDLE *phFolder) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to string from VB is invalid) <br>    if (IsBadStringPtr(pszFolderID, MAX_VB_STRING)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Pointer to Folder Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phFolder, sizeof(*phFolder))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsCreateFolder(hParent, fType, pszFolderID, phFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetFolderID&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, pszFolderID As String) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetFolderIDVB(HANDLE hFolder, BSTR* pszFolderID) <br>{ <br>    SMS_STATUS ret; <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsGetFolderID(hFolder, gStrBuff); <br>    if (ret == SMS_OK) <br>        // Copy the string to VB land <br>        ret = CopyString2VB(pszFolderID, gStrBuff, sizeof(gStrBuff)); <br> <br>    return ret; <br>} <br>                                                                        /* VB: <br>  Declare Function SmsGetFolderType&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, pfType As Long, pszfType As String) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetFolderTypeVB(HANDLE hFolder, DWORD *pfType, BSTR* pszfType) <br>{ <br>    SMS_STATUS ret; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Type from VB is invalid) <br>    if (IsBadWritePtr(pfType, sizeof(*pfType))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsGetFolderType(hFolder, pfType, gStrBuff); <br>    if (ret == SMS_OK) <br>        // Copy the string to VB land <br>        ret = CopyString2VB(pszfType, gStrBuff, sizeof(gStrBuff)); <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsEnumFolderTypes&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, pfTypes As Long, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsEnumFolderTypesVB(HANDLE hFolder, LPSAFEARRAY* ppArray, DWORD *pCount) <br>{ <br>    SAFEARRAY* &amp;pArray = *ppArray; <br>    DWORD* pfTypes; <br>    SMS_STATUS  ret; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Folder Type Count from VB is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Count is too big) <br>    if (*pCount &gt;= 0x80000000 / sizeof(*pfTypes)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Get the count of folder types <br>    *pCount = 0; <br>    ret = SmsEnumFolderTypes(hFolder, NULL, pCount); <br>    if (ret != SMS_MORE_DATA) return ret; <br> <br>    // Create or Redim as necessary <br>    if (AllocVBArray(pArray, *pCount, sizeof(*pfTypes)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pfTypes) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsEnumFolderTypes(hFolder, pfTypes, pCount); <br> <br>    // Unlock the array <br>    SafeArrayUnaccessData(pArray); <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetFolderCount&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, ByVal fType As Long, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetFolderCountVB(HANDLE hFolder, DWORD fType, DWORD *pCount) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Folder Type Count from VB is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsGetFolderCount(hFolder, fType, pCount); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetFolderByID&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, ByVal fType As Long, ByVal pszFolderID As String, phSubFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetFolderByIDVB(HANDLE hFolder, DWORD fType, const char *pszFolderID, <br>                   HANDLE *phSubFolder) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters </code></pre>
<p>
</p>
<pre><code><br>    // if (Pointer to string from VB is invalid) <br>    if (IsBadStringPtr(pszFolderID, MAX_VB_STRING)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Pointer to SubFolder Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phSubFolder, sizeof(*phSubFolder))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    char *pTemp = const_cast&lt;char*&gt;(pszFolderID);  // FIX: SMSAPI incorrectly declared 3rd parameter <br>    return SmsGetFolderByID(hFolder, fType, pTemp, phSubFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsRewind&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, ByVal dwOptions As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsRewindVB(HANDLE hFolder, DWORD dwOptions) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsRewind(hFolder, dwOptions); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsCloseFolder&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCloseFolderVB(HANDLE hFolder) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsCloseFolder(hFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsLinkFolder&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsLinkFolderVB(HANDLE hFolder) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsLinkFolder(hFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsUnlinkFolder&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsUnlinkFolderVB(HANDLE hFolder) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsUnlinkFolder(hFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsCommitFolder&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCommitFolderVB(HANDLE hFolder) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsCommitFolder(hFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsDupFolder&amp; Lib "vb4sms32.dll" (ByVal hParent As Long, ByVal hFolder As Long, phNewFolder As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsDupFolderVB(HANDLE hParent, HANDLE hFolder, HANDLE* phNewFolder) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsDupFolder(hParent, hFolder, phNewFolder); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetScalarCount&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetScalarCountVB(HANDLE hFolder, DWORD *pCount) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Folder Count from VB is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsGetScalarCount(hFolder, pCount); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetNextScalar&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, pScalarStruct As SCALAR) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetNextScalarVB(HANDLE hFolder, LPSAFEARRAY* ppArray) <br>{ <br>    SMS_STATUS ret; <br>    char *pszName; <br>    BSTR pszValue; <br>    SAFEARRAY* pValue; <br>    SAFEARRAY* &amp;pArray = *ppArray; <br> <br>    // Create or Redim as necessary <br>    SCALAR *pScalar; <br>    if (AllocVBArray(pArray, 1, sizeof(*pScalar)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pScalar) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Preserve the BSTR members, pszName &amp; pszValue, in the SCALAR from VB <br>    pszName = pScalar-&gt;pszName; <br>    pszValue = (BSTR)pScalar-&gt;pszValue; <br>    pValue = (SAFEARRAY*)pScalar-&gt;pValue; <br> <br>    // Provide SCALAR with buffers to receive data <br>    pScalar-&gt;pszName = gNameBuff; <br>    pScalar-&gt;pszValue = NULL; <br>    pScalar-&gt;pValue = NULL; <br>    pScalar-&gt;dwLen = 0; <br> <br>    // Call 32bit SMS API routine to get buffer lengths <br>    ret = SmsGetNextScalar(hFolder, pScalar); <br> <br>    // Check for BINARY scalar and wrong return code <br>    if (ret == SMS_OK &amp;&amp; pScalar-&gt;scType == SCALAR_BINARY &amp;&amp; <br>        pScalar-&gt;dwLen &gt; 0) <br>        ret = SMS_MORE_DATA; <br> <br>    if (ret == SMS_MORE_DATA) <br>    { <br>        // Provide SCALAR with buffers to receive data <br>        if (pScalar-&gt;scType == SCALAR_STRING) <br>        { <br>            pScalar-&gt;pszValue = new char[pScalar-&gt;dwLen]; <br>            if (pScalar-&gt;pszValue == NULL) ret = SMS_ERROR; <br>        } <br>        else if (pScalar-&gt;scType == SCALAR_BINARY) <br>        { <br>            // Create or Redim as necessary <br>            if (AllocVBArray(pValue, pScalar-&gt;dwLen, 1) != S_OK) <br>                ret = SMS_INVALID_PARAMETER; <br> <br>            // Lock down the array and obtain pointer to the data <br>            else if (SafeArrayAccessData(pValue, &amp;pScalar-&gt;pValue) != S_OK) <br>                ret = SMS_INVALID_PARAMETER; <br>        } <br>        else ret = SMS_ERROR; <br> <br>        if (ret == SMS_MORE_DATA) <br>        { <br>            // Call 32bit SMS API routine to get data <br>            ret = SmsGetScalarByName(hFolder, pScalar-&gt;pszName, pScalar); <br> <br>            // Copy string buffer to pszValue <br>            if (ret == SMS_OK &amp;&amp; pScalar-&gt;pszValue != NULL) <br>            { <br>                ret = CopyString2VB(&amp;pszValue, pScalar-&gt;pszValue); <br> <br>                // Free the string buffer <br>                delete[] pScalar-&gt;pszValue; <br>            } <br> <br>            // Unlock the VB Byte array <br>            if (pScalar-&gt;pValue != NULL) <br>                SafeArrayUnaccessData(pValue); <br>        } <br>    } <br> <br>    // Restore pszName &amp; pszValue members of SCALAR before possible exit <br>    pScalar-&gt;pszName = pszName; <br>    pScalar-&gt;pszValue = (char*)pszValue; <br>    pScalar-&gt;pValue = pValue; <br> <br>    // Copy the name from buffer to VB BSTR <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB((BSTR*)&amp;pScalar-&gt;pszName, gNameBuff); <br> <br>    // Unlock the VB array <br>    SafeArrayUnaccessData(pArray); <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetScalarByName&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, ByVal pszName As String, pScalarStruct As SCALAR) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetScalarByNameVB(HANDLE hFolder, const char *pszNameVB, <br>                     LPSAFEARRAY* ppArray) <br>{ <br>    SMS_STATUS ret; <br>    char *pszName; <br>    BSTR pszValue; <br>    SAFEARRAY* pValue; <br>    SAFEARRAY* &amp;pArray = *ppArray; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to string from VB is invalid) <br>    if (IsBadStringPtr(pszNameVB, MAX_VB_STRING)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Create or Redim as necessary <br>    SCALAR *pScalar; <br>    if (AllocVBArray(pArray, 1, sizeof(*pScalar)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pScalar) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Preserve the BSTR members, pszName &amp; pszValue, in the SCALAR from VB <br>    pszName = pScalar-&gt;pszName; <br>    pszValue = (BSTR)pScalar-&gt;pszValue; <br>    pValue = (SAFEARRAY*)pScalar-&gt;pValue; <br> <br>    // Provide SCALAR with buffers to receive data <br>    pScalar-&gt;pszName = gNameBuff; <br>    pScalar-&gt;pszValue = NULL; <br>    pScalar-&gt;pValue = NULL; <br>    pScalar-&gt;dwLen = 0; <br> <br>    // Call 32bit SMS API routine to get buffer lengths <br>    ret = SmsGetScalarByName(hFolder, pszNameVB, pScalar); <br> <br>    // Check for BINARY scalar and wrong return code <br>    if (ret == SMS_OK &amp;&amp; pScalar-&gt;scType == SCALAR_BINARY &amp;&amp; <br>        pScalar-&gt;dwLen &gt; 0) <br>        ret = SMS_MORE_DATA; <br> <br>    if (ret == SMS_MORE_DATA || <br>        (pScalar-&gt;scType == SCALAR_BINARY) &amp;&amp; pScalar-&gt;dwLen &gt; 0) <br>    { <br>        // Provide SCALAR with buffers to receive data <br>        if (pScalar-&gt;scType == SCALAR_STRING) <br>        { <br>            pScalar-&gt;pszValue = new char[pScalar-&gt;dwLen]; <br>            if (pScalar-&gt;pszValue == NULL) ret = SMS_ERROR; <br>        } <br>        else if (pScalar-&gt;scType == SCALAR_BINARY) <br>        { <br>            // Create or Redim as necessary <br>            if (AllocVBArray(pValue, pScalar-&gt;dwLen, 1) != S_OK) <br>                ret = SMS_INVALID_PARAMETER; <br> <br>            // Lock down the array and obtain pointer to the data <br>            else if (SafeArrayAccessData(pValue, &amp;pScalar-&gt;pValue) != S_OK) <br>                ret = SMS_INVALID_PARAMETER; <br>        } <br>        else ret = SMS_ERROR; <br> <br>        if (ret == SMS_MORE_DATA) <br>        { <br>            // Call 32bit SMS API routine to get data <br>            ret = SmsGetScalarByName(hFolder, pszNameVB, pScalar); <br> <br>            // Copy string buffer to pszValue <br>            if (ret == SMS_OK &amp;&amp; pScalar-&gt;pszValue != NULL) <br>            { <br>                ret = CopyString2VB(&amp;pszValue, pScalar-&gt;pszValue); <br> <br>                // Free the string buffer <br>                delete[] pScalar-&gt;pszValue; <br>            } <br> <br>            // Unlock the VB Byte array <br>            if (pScalar-&gt;pValue != NULL) <br>                SafeArrayUnaccessData(pValue); <br>        } <br>    } <br> <br>    // Restore pszTag &amp; pszValue members of SCALAR before possible exit <br>    pScalar-&gt;pszName = pszName; <br>    pScalar-&gt;pszValue = (char*)pszValue; <br>    pScalar-&gt;pValue = pValue; <br> <br>    // Copy the name from buffer to VB BSTR <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB((BSTR*)&amp;pScalar-&gt;pszName, gNameBuff); <br> <br>    // Unlock the VB array <br>    SafeArrayUnaccessData(pArray); <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsSetScalar&amp; Lib "vb4sms32.dll" (ByVal hFolder As Long, pScalarStruct As SCALAR) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsSetScalarVB(HANDLE hFolder, LPSAFEARRAY* ppArray) <br>{ <br>    BSTR pszName, pszValue; <br>    SAFEARRAY* pValue; <br>    SAFEARRAY* &amp;pArray = *ppArray; <br>    char NullCharBuff = '\0', *pCharBuff = &amp;NullCharBuff; <br>    BYTE NullByteBuff = NULL, *pByteBuff = &amp;NullByteBuff; <br> <br>    // Lock down the array and obtain pointer to the data <br>    SCALAR *pScalar; <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pScalar) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    if (pScalar-&gt;scType == SCALAR_STRING &amp;&amp; pScalar-&gt;pszValue == NULL &amp;&amp; <br>        pScalar-&gt;dwLen &gt; 0) return SMS_INVALID_PARAMETER; <br> <br>    if (pScalar-&gt;scType == SCALAR_BINARY &amp;&amp; pScalar-&gt;pValue == NULL) <br>        if (pScalar-&gt;dwLen &gt; 0) return SMS_INVALID_PARAMETER; <br> <br>    // Preserve the BSTR members, pszName &amp; pszValue, in the SCALAR from VB <br>    pszName = (BSTR)pScalar-&gt;pszName; <br>    pszValue = (BSTR)pScalar-&gt;pszValue; <br>    pValue = (SAFEARRAY*)pScalar-&gt;pValue; <br> <br>    // Get a value string buffer <br>    if (pScalar-&gt;scType == SCALAR_STRING &amp;&amp; pszValue != NULL &amp;&amp; <br>        (pCharBuff = new char[VBStringLength(pszValue) + 1]) == NULL) <br>        return SMS_ERROR; <br> <br>    // Lock down the array and obtain pointer to the byte data <br>    if (pScalar-&gt;scType == SCALAR_BINARY &amp;&amp; pValue != NULL &amp;&amp; <br>        SafeArrayAccessData(pValue, (void**)&amp;pByteBuff) != S_OK) <br>        return SMS_ERROR; <br> <br>    // Copy the strings from VB to SMS <br>    CopyString2Sms(gNameBuff, pszName); <br>    if (pCharBuff != NULL) CopyString2Sms(pCharBuff, pszValue); <br> <br>    // Set SCALAR value to buffers with data <br>    pScalar-&gt;pszName = gNameBuff; <br>    pScalar-&gt;pszValue = pCharBuff; <br>    pScalar-&gt;pValue = pByteBuff; <br> <br>    // Call 32bit SMS API routine <br>    SMS_STATUS ret = SmsSetScalar(hFolder, pScalar); <br> <br>    // Restore pszTag, pszValue, &amp; pValue members of SCALAR before exit <br>    pScalar-&gt;pszName = (char*)pszName; <br>    pScalar-&gt;pszValue = (char*)pszValue; <br>    pScalar-&gt;pValue = pValue; <br> <br>    // Unlock the array and delete the string value buffer <br>    if (pByteBuff != &amp;NullByteBuff) SafeArrayUnaccessData(pValue); <br>    if (pCharBuff != &amp;NullCharBuff) delete[] pCharBuff; <br> <br>    // Unlock the VB array <br>    SafeArrayUnaccessData(pArray); <br> <br>    return ret; <br>} <br> <br> <br>// ==================================================================== <br>//  FilterContainer APIs <br>// ==================================================================== <br>                                                                        /* VB: <br>  Declare Function SmsOpenFilterContainer&amp; Lib "vb4sms32.dll" (ByVal hConnection As Long, phFContainer As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsOpenFilterContainerVB(HANDLE hConnection, HANDLE *phFContainer) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Container Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phFContainer, sizeof(*phFContainer))) <br>        return SMS_INVALID_PARAMETER; <br>     <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsOpenFilterContainer(hConnection, phFContainer); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsCloseFilterContainer&amp; Lib "vb4sms32.dll" (ByVal hFContainer As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCloseFilterContainerVB(HANDLE hFContainer) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsCloseFilterContainer(hFContainer); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetNextFilter&amp; Lib "vb4sms32.dll" (ByVal hFContainer As Long, ByVal frType As Long, phFilter As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetNextFilterVB(HANDLE hFContainer, DWORD frType, HANDLE *phFilter) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Filter Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phFilter, sizeof(*phFilter))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsGetNextFilter(hFContainer, frType, phFilter); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetFilterByID&amp; Lib "vb4sms32.dll" (ByVal hFContainer As Long, ByVal frType As Long, ByVal pszFilterID As String, phFilter As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetFilterByIDVB(HANDLE hFContainer, DWORD frType, const char *pszFilterID, <br>                   HANDLE *phFilter) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to string from VB is invalid) <br>    if (IsBadStringPtr(pszFilterID, MAX_VB_STRING)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Pointer to Filter Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phFilter, sizeof(*phFilter))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsGetFilterByID(hFContainer, frType, pszFilterID, phFilter); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetFilterID&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long, pszFilterID As String) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetFilterIDVB(HANDLE hFilter, BSTR* pszFilterID) <br>{ <br>    SMS_STATUS ret; <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsGetFilterID(hFilter, gStrBuff); <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(pszFilterID, gStrBuff, sizeof(gStrBuff)); <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsCommitFilter&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long, ByVal hFContainer As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCommitFilterVB(HANDLE hFilter, HANDLE hFContainer) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsCommitFilter(hFilter, hFContainer); <br>} <br> <br> <br>// ==================================================================== <br>//  Filter APIs <br>// ==================================================================== <br>                                                                        /* VB: <br>  Declare Function SmsCreateFilter&amp; Lib "vb4sms32.dll" (ByVal frType As Long, ByVal hConnection As Long, phFilter As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCreateFilterVB(DWORD frType, HANDLE hConnection, HANDLE *phFilter) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Filter Handle from VB is invalid) <br>    if (IsBadWritePtr((void*)phFilter, sizeof(*phFilter))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsCreateFilter(frType, hConnection, phFilter); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsCloseFilter&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsCloseFilterVB(HANDLE hFilter) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsCloseFilter(hFilter); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetFilterType&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long, pfilterType As Long, pszTag As String) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetFilterTypeVB(HANDLE hFilter, DWORD *pfilterType, BSTR* pszTag) <br>{ <br>    SMS_STATUS ret; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Filter Handle from VB is invalid) <br>    if (IsBadWritePtr(pfilterType, sizeof(*pfilterType))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsGetFilterType(hFilter, pfilterType, gStrBuff); <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(pszTag, gStrBuff, sizeof(gStrBuff)); <br> <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetToken&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long, ByVal iIndex As Long, pTokenInfo As TOKEN) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetTokenVB(HANDLE hFilter, INT iIndex, TOKENVB *pTokenInfoVB) <br>{ <br>    SMS_STATUS ret; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to FOLDER_INFO struct from VB is invalid) <br>    if (IsBadWritePtr(pTokenInfoVB, sizeof(*pTokenInfoVB))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Turn on ANSI string copy <br>    gbANSI = TRUE; <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsGetToken(hFilter, iIndex, &amp;gTokenBuff); <br> <br>    // tokenType <br>    pTokenInfoVB-&gt;tokenType = gTokenBuff.tokenType; <br> <br>    // szName <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pTokenInfoVB-&gt;szName, <br>                            gTokenBuff.szName, <br>                            sizeof(gTokenBuff.szName)); <br> <br>    // szValue <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pTokenInfoVB-&gt;szValue, <br>                            gTokenBuff.szValue, <br>                            sizeof(gTokenBuff.szValue)); <br> <br>    // dwOp <br>    pTokenInfoVB-&gt;dwOp = gTokenBuff.dwOp; <br> <br>    // szArchitecture <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pTokenInfoVB-&gt;szArchitecture, <br>                            gTokenBuff.szArchitecture, <br>                            sizeof(gTokenBuff.szArchitecture)); <br> <br>    // szGroupClass <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pTokenInfoVB-&gt;szGroupClass, <br>                            gTokenBuff.szGroupClass, <br>                            sizeof(gTokenBuff.szGroupClass)); <br> <br>    // szAttributeName <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pTokenInfoVB-&gt;szAttributeName, <br>                            gTokenBuff.szAttributeName, <br>                            sizeof(gTokenBuff.szAttributeName)); <br> <br>    // szTokenString <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pTokenInfoVB-&gt;szTokenString, <br>                            gTokenBuff.szTokenString, <br>                            sizeof(gTokenBuff.szTokenString)); <br> <br>    // bIndent <br>    pTokenInfoVB-&gt;bIndent = gTokenBuff.bIndent; <br> <br>    gbANSI = FALSE; <br>    return ret; <br>} <br>                                                                        /* VB: <br>  Declare Function SmsAddToken&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long, opAndOr As ANDOR, pTokenInfo As TOKEN, ByVal iIndex As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsAddTokenVB(HANDLE hFilter, ANDOR* opAndOr, TOKENVB *pTokenInfoVB, INT iIndex) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to TOKENVB struct from VB is invalid) <br>    if (IsBadReadPtr(pTokenInfoVB, sizeof(*pTokenInfoVB))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    if (VBStringLength(pTokenInfoVB-&gt;szName) &gt;= sizeof(gTokenBuff.szName)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    if (VBStringLength(pTokenInfoVB-&gt;szValue) &gt;= sizeof(gTokenBuff.szValue)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    if (VBStringLength(pTokenInfoVB-&gt;szArchitecture) <br>                                         &gt;= sizeof(gTokenBuff.szArchitecture)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    if (VBStringLength(pTokenInfoVB-&gt;szGroupClass) <br>                                           &gt;= sizeof(gTokenBuff.szGroupClass)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    if (VBStringLength(pTokenInfoVB-&gt;szAttributeName) <br>                                        &gt;= sizeof(gTokenBuff.szAttributeName)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    if (VBStringLength(pTokenInfoVB-&gt;szTokenString)  <br>                                          &gt;= sizeof(gTokenBuff.szTokenString)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Turn on ANSI string copy <br>    gbANSI = TRUE; <br> <br>    // tokenType <br>    gTokenBuff.tokenType = pTokenInfoVB-&gt;tokenType; <br> <br>    // szName <br>    CopyString2Sms(gTokenBuff.szName, pTokenInfoVB-&gt;szName, <br>                   sizeof(gTokenBuff.szName)); <br> <br>    // szValue <br>    CopyString2Sms(gTokenBuff.szValue, pTokenInfoVB-&gt;szValue, <br>                   sizeof(gTokenBuff.szValue)); <br> <br>    // dwOp <br>    gTokenBuff.dwOp = pTokenInfoVB-&gt;dwOp; <br> <br>    // szArchitecture <br>    CopyString2Sms(gTokenBuff.szArchitecture, pTokenInfoVB-&gt;szArchitecture, <br>                   sizeof(gTokenBuff.szArchitecture)); <br> <br>    // szGroupClass <br>    CopyString2Sms(gTokenBuff.szGroupClass, pTokenInfoVB-&gt;szGroupClass, <br>                   sizeof(gTokenBuff.szGroupClass)); <br> <br>    // szAttributeName <br>    CopyString2Sms(gTokenBuff.szAttributeName, pTokenInfoVB-&gt;szAttributeName, <br>                   sizeof(gTokenBuff.szAttributeName)); <br> <br>    // szTokenString <br>    CopyString2Sms(gTokenBuff.szTokenString, pTokenInfoVB-&gt;szTokenString, <br>                   sizeof(gTokenBuff.szTokenString)); <br> <br>    // bIndent <br>    gTokenBuff.bIndent = pTokenInfoVB-&gt;bIndent; <br> <br>    // Turn back off ANSI copy <br>    gbANSI = FALSE; <br> <br>    // Call 32bit SMS API routine <br>    return SmsAddToken(hFilter, *opAndOr, &amp;gTokenBuff, iIndex); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetTokenCount&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetTokenCountVB(HANDLE hFilter, DWORD *pCount) <br>{ <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Filter Handle from VB is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Call 32bit SMS API routine <br>    return SmsGetTokenCount(hFilter, pCount); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsManipulateTokens&amp; Lib "vb4sms32.dll" (ByVal hFilter As Long, ByVal dwFlags As Long, ByVal iStart As Long, ByVal iEnd As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsManipulateTokensVB(HANDLE hFilter, DWORD dwFlags, INT iStart, INT iEnd) <br>{ <br>    // Call 32bit SMS API routine <br>    return SmsManipulateTokens(hFilter, dwFlags, iStart, iEnd); <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsGetAllFilters&amp; Lib "vb4sms32.dll" (ByVal hContainer As Long, pahFilters As Long, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsGetAllFiltersVB(HANDLE hContainer, LPSAFEARRAY* ppArray, DWORD *pCount) <br>{ <br>    SMS_STATUS ret; <br>    HANDLE *pahFilters; <br>    SAFEARRAY* &amp;pArray = *ppArray; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (Pointer to Count from VB is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Count is too big) <br>    if (*pCount &gt;= 0x80000000 / sizeof(*pahFilters)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Get the count of FILTER_INFOs <br>    *pCount = 0; <br>    ret = SmsGetAllFilters(hContainer, NULL, pCount); <br>    if (ret != SMS_MORE_DATA) return ret; <br> <br>    // Create or Redim as necessary <br>    if (AllocVBArray(pArray, *pCount, sizeof(*pahFilters)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;pahFilters) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Call 32bit SMS API routine <br>    ret = SmsGetAllFilters(hContainer, pahFilters, pCount); <br> <br>    // Unlock the VB array of FILTER_INFOs <br>    SafeArrayUnaccessData(pArray); <br>    return ret; <br>} <br> <br>                                                                        /* VB: <br>  Declare Function SmsEnumObjectTypes&amp; Lib "vb4sms32.dll" (ByVal hConnection As Long, pObjects() As String, pCount As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsEnumObjectTypesVB(HANDLE hConnection, LPSAFEARRAY* ppArray, DWORD *pCount) <br>{ <br>    SAFEARRAY* &amp;pArray = *ppArray; <br>    BSTR* paObjTypesVB; <br>    SMS_STATUS  ret; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    // if (pCount is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Count is too big) <br>    if (*pCount &gt;= 0x80000000 / sizeof(*paObjTypesVB)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Get the count of object types <br>    *pCount = 0; <br>    ret = SmsEnumObjectTypes(hConnection, NULL, pCount); <br>    if (ret != SMS_MORE_DATA) return ret; <br> <br>    // Create or Redim as necessary <br>    if (AllocVBArray(pArray, *pCount, sizeof(*paObjTypesVB)) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Lock down the array and obtain pointer to the data <br>    if (SafeArrayAccessData(pArray, (void**)&amp;paObjTypesVB) != S_OK) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // Get an array large enough to accept object types </code></pre>
<p>
</p>
<pre><code>DWORD cObjTypes = *pCount; <br>    SMSBUFF* pObjTypes = new SMSBUFF[cObjTypes]; <br>    if (pObjTypes != NULL) <br>    { <br>        // Call 32bit SMS API routine <br>        ret = SmsEnumObjectTypes(hConnection, pObjTypes, pCount); <br> <br>        if (ret == SMS_OK) <br>            for (DWORD dwIndex = 0; dwIndex &lt; cObjTypes; dwIndex++) <br>            { <br>                ret = CopyString2VB(&amp;paObjTypesVB[dwIndex], <br>                                    pObjTypes[dwIndex]); <br>                if (ret != SMS_OK) break; <br>            } <br> <br>        // Unlock the array of object types <br>        delete[] pObjTypes; <br>        pObjTypes = NULL; <br>    } <br>    else ret = SMS_ERROR; <br> <br>    // Unlock the VB array of object types <br>    SafeArrayUnaccessData(pArray); <br>    return ret; <br>} <br> <br> <br>SMS_STATUS CopyObjectDescriptor2VB(OBJDESCRIPTORVB* pObjectVB, <br>                                   OBJDESCRIPTOR* pObject) <br>{ <br>    SMS_STATUS ret = SMS_OK; <br> <br>    // objType <br>    pObjectVB-&gt;objType = pObject-&gt;objType; <br> <br>    // szName <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pObjectVB-&gt;szName, <br>                            pObject-&gt;szName); <br> <br>    // szFriendlyName <br>    if (ret == SMS_OK) <br>        ret = CopyString2VB(&amp;pObjectVB-&gt;szFriendlyName, <br>                            pObject-&gt;szFriendlyName); <br> <br>    // bGotFriendlyName <br>    pObjectVB-&gt;bGotFriendlyName = pObject-&gt;bGotFriendlyName; <br> <br>    // dwRelopMin <br>    pObjectVB-&gt;dwRelopMin = pObject-&gt;dwRelopMin; <br> <br>    // dwRelopMax <br>    pObjectVB-&gt;dwRelopMax = pObject-&gt;dwRelopMax; <br> <br>    // bGotRelops <br>    pObjectVB-&gt;bGotRelops = pObject-&gt;bGotRelops; <br> <br>    return ret; <br>} <br>                                                                        /* VB: <br>  Declare Function SmsEnumObjects&amp; Lib "vb4sms32.dll" (ByVal hConnection As Long, ByVal pszObjectType As String, pPredecessors() As String, ByVal CtPredecessors As Long, pObjects() As OBJDESCRIPTOR, pCtObjects As Long) <br>                                                                        '*/ <br>extern "C" SMS_STATUS WINAPI <br>SmsEnumObjectsVB(HANDLE hConnection, char* pszObjectType, LPSAFEARRAY* ppPredecessorsVB, DWORD CtPredecessors, LPSAFEARRAY* ppArray, DWORD *pCount) <br>{ <br>    SAFEARRAY* &amp;pArray = *ppArray; <br>    SAFEARRAY* &amp;pPredecessorsVB = *ppPredecessorsVB; <br>    BSTR* paPredecessorsVB; <br>    OBJDESCRIPTORVB* paObjectsVB; <br>    SMS_STATUS  ret = SMS_OK; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Check parameters <br> <br>    if (ppPredecessorsVB != NULL &amp;&amp; CtPredecessors &gt; 0) <br>    { <br>        if (pPredecessorsVB-&gt;cDims != 1) <br>            return SMS_INVALID_PARAMETER; <br> <br>        if (pPredecessorsVB-&gt;cbElements!= 4) <br>            return SMS_INVALID_PARAMETER; <br> <br>        if (pPredecessorsVB-&gt;rgsabound[0].cElements &lt; CtPredecessors) <br>            return SMS_INVALID_PARAMETER; <br>    } <br> <br>    // if (pCount is invalid) <br>    if (IsBadWritePtr(pCount, sizeof(*pCount))) <br>        return SMS_INVALID_PARAMETER; <br> <br>    // if (Count is too big) <br>    if (*pCount &gt;= 0x80000000 / sizeof(*paObjectsVB)) <br>        return SMS_INVALID_PARAMETER; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br> <br>    // Copy Predecessors array <br>    // Get an array large enough to accept object types <br>    SMSBUFF* pPredecessors = NULL; <br>    if (ppPredecessorsVB != NULL &amp;&amp; CtPredecessors &gt; 0) <br>    { <br>        pPredecessors = new SMSBUFF[CtPredecessors]; <br>        if (pPredecessors == NULL) return SMS_ERROR; <br> <br>        // Lock down the array and obtain pointer to the data <br>        if (SafeArrayAccessData(pPredecessorsVB, (void**)&amp;paPredecessorsVB) != S_OK) <br>            {ret = SMS_INVALID_PARAMETER; goto SmsEnumObjectsVB_Quit;} <br> <br>        // Turn on ANSI string copy <br>        gbANSI = TRUE; <br> <br>        for (DWORD dwIndex = 0; dwIndex &lt; CtPredecessors; dwIndex++) <br>        { <br>            ret = CopyString2Sms(pPredecessors[dwIndex], <br>                                 paPredecessorsVB[dwIndex]); <br>            if (ret != SMS_OK) break; <br>        } <br> <br>        // Turn back off ANSI string copy <br>        gbANSI = FALSE; <br> <br>        // Unlock the VB array of object types <br>        SafeArrayUnaccessData(pPredecessorsVB); <br>    } <br> <br>    if (ret == SMS_OK) <br>    { <br>        // Get the count of object types <br>        *pCount = 0; <br>        ret = SmsEnumObjects(hConnection, pszObjectType, pPredecessors, <br>                             CtPredecessors, NULL, pCount); <br>        if (ret != SMS_MORE_DATA) goto SmsEnumObjectsVB_Quit; <br> <br>        // Create or Redim as necessary <br>        if (AllocVBArray(pArray, *pCount, sizeof(*paObjectsVB)) != S_OK) <br>            {ret = SMS_INVALID_PARAMETER; goto SmsEnumObjectsVB_Quit;} <br> <br>        // Lock down the array and obtain pointer to the data <br>        if (SafeArrayAccessData(pArray, (void**)&amp;paObjectsVB) != S_OK) <br>            {ret = SMS_INVALID_PARAMETER; goto SmsEnumObjectsVB_Quit;} <br> <br>        // Get an array large enough to accept object types <br>        DWORD cObjects = *pCount; <br>        OBJDESCRIPTOR* pObjects = new OBJDESCRIPTOR[cObjects]; <br>        if (pObjects != NULL) <br>        { <br>            // Call 32bit SMS API routine <br>            ret = SmsEnumObjects(hConnection, pszObjectType, pPredecessors, <br>                                 CtPredecessors, pObjects, pCount); <br> <br>            if (ret == SMS_OK) <br>                for (DWORD dwIndex = 0; dwIndex &lt; cObjects; dwIndex++) <br>                { <br>                    ret = CopyObjectDescriptor2VB(&amp;paObjectsVB[dwIndex], <br>                                                  &amp;pObjects[dwIndex]); <br>                    if (ret != SMS_OK) break; <br>                } <br> <br>            // Unlock the array of object types <br>            delete[] pObjects; <br>            pObjects = NULL; <br>        } <br>        else ret = SMS_ERROR; <br> <br>        // Unlock the VB array of object types <br>        SafeArrayUnaccessData(pArray); <br>    } <br> <br>SmsEnumObjectsVB_Quit: <br>    // Free the array of predecessors <br>    if (pPredecessors != NULL) delete[] pPredecessors; <br>    pPredecessors = NULL; <br> <br>    return ret; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
