<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ISVREG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5863"></a>ISVREG.C</h2>
<pre><code>/* */ <br>/*ISVReg.c - C routine that creates Registry entries */ <br>/*for ISV Application Launching in SMS 1.2 */ <br>/* */ <br>/* */ <br> <br>#include &lt;windows.h&gt; <br>#include "isvreg.h" <br> <br>#if defined(__cplusplus) <br>extern "C" <br>{ <br>#endif <br> <br>int MakeMultiSz(LPTSTR lpBuf, LPCTSTR lpData) <br>{ <br>/* fills lpBuf from lpData converting carriage returns to*/ <br>/* nulls and eliminating other control characters.*/ <br>/* Adds an additional null at the end*/ <br>/* to make a valid REG_MULTI_SZ string*/ <br>/* returns size in bytes of result including nulls*/ <br>LPTSTR lpB; <br>LPCTSTR lpD; <br> <br>lpB = lpBuf; <br>lpD = lpData; <br>while (*lpD  != _T('\0')) <br>{ <br>if (*lpD == _T('\r')) <br>{ <br>*lpB++ = _T('\0'); <br>} <br>else <br>if (!_istcntrl(*lpD)) <br>{ <br>*lpB++ = *lpD; <br>} <br>lpD++; <br>} <br>*lpB++ = _T('\0');/* add additional null */ <br>*lpB++ = _T('\0');/* add additional null */ <br>/* return size as the differential in bytes */ <br>return ((LPBYTE)lpB - (LPBYTE)lpBuf); <br>} <br> <br>/*  <br>    UnregisterApplication(HKEY hkParentKey, LPCTSTR lpAppName) <br> <br>    Deletes the key with the given name after deleting any context <br>    keys that may be underneath it. This routine is necessary because <br>    Windows NT 3.51 RegDeleteKey doesn't automatically delete subkeys. <br>     <br>    This routine will break if subkeys are added to the context keys. <br>    It can be removed if RegDeleteKey is eventually brought to up speed <br>    and so can delete all subkeys like it does in Win95. <br>*/ <br>long UnregisterApplication(HKEY hkParentKey, LPCTSTR lptAppName) <br>{ <br>    long    lRet; <br>    HKEY    hkAppKey; <br>TCHARtSubKey[MAX_PATH+1]; <br> <br>    /* open the appName key */ <br>lRet = RegOpenKeyEx( hkParentKey, lptAppName, 0, KEY_ALL_ACCESS, &amp;hkAppKey); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        return ERROR_SUCCESS;    /* if not there it's OK */ <br>    } <br> <br>    /* enumerate the subkeys, deleting each one, assumes they don't have */ <br>    /* subkeys themselves                                                */ <br>    while(TRUE) <br>    { <br>        lRet = RegEnumKey(hkAppKey, 0, tSubKey, MAX_PATH+1); <br>        if (lRet == ERROR_NO_MORE_ITEMS || lRet != ERROR_SUCCESS) <br>        { <br>            break; <br>        } <br>   lRet = RegDeleteKey(hkAppKey, tSubKey); <br>        if (lRet != ERROR_SUCCESS) <br>        { <br>            break; <br>        } <br>} <br> <br>    if (lRet == ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS) <br>    { <br>        RegCloseKey(hkAppKey); <br>        lRet = RegDeleteKey(hkParentKey, lptAppName); <br>    } <br> <br>    return lRet; <br>} <br> <br>/* <br>RegisterSMSTool(BOOL bRemove, LPISVAppReg lpisv) <br> <br>This routine makes multiple calls to Registry APIs to create or update <br>information about a single application that wants to be visible in the <br>SMS menu and launchable from the SMS Admin UI. <br> <br>bRemove == TRUE means get rid of named application in the Registry. <br>bRemove == FALSE means add or update the application into the Registry. <br> <br>The input struct contains all the strings and values to be registered. <br>See the ISV Application Launching spec for details about what these <br>strings should be. In general the name of the key or value is the <br>about the same as the member variable. Because an application can support  <br>multiple contexts, the structure takes a pointer to multiple ISVContext <br>structs in an array, plus a count. <br> <br>Return ERROR_SUCCESS if successful, otherwise the error code from the <br>Registry function that failed. Does some preliminary error checking to <br>    catch some bad input situations. <br>*/ <br> <br>LONG WINAPI RegisterSMSTool(BOOL bRemove, LPISVAppReg lpisv) <br>{ <br>/* This code creates or updates the registry settings for an*/ <br>/* SMS ISV application that wants to be launched from the SMS*/ <br>/* Administrator UI.*/ <br> <br>TCHARtCurKey[MAX_PATH+1]; <br>TCHARtValueName[MAX_PATH+1]; <br>TCHARtValueData[SmsRegMaxLength]; <br>LONGlRet; <br>HKEYhkParentKey; <br>HKEYhkCurKey; <br>DWORDdwKeyDisp; <br>intnSize; <br>inti; <br> <br>    /* do some preliminary error checking */ <br>    if (_tcslen(lpisv-&gt;m_pAppNameKey) &lt;= 0 || <br>        _tcslen(lpisv-&gt;m_pVendor) &lt;= 0 || <br>        (bRemove == FALSE &amp;&amp; _tcslen(lpisv-&gt;m_pCommand) &lt;= 0) || <br>        (bRemove == FALSE &amp;&amp; lpisv-&gt;m_nNumContexts &lt;= 0) || <br>        (lpisv-&gt;m_nNumContexts &gt; SmsTotalNumContexts-1) || <br>        (bRemove == FALSE &amp;&amp; _tcslen(lpisv-&gt;m_pAppName) &lt;= 0)) <br>    { <br>        return ERROR_INVALID_PARAMETER; <br>    } <br> <br>    /* get the starting key. This routine should NOT create it */ <br>_tcscpy(tCurKey, SmsRegRootKey); <br>lRet = RegOpenKeyEx <br>( <br>lpisv-&gt;m_bHkeyLocal ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,  <br>tCurKey, 0, KEY_ALL_ACCESS, &amp;hkParentKey <br>); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        return lRet; <br>    } <br> <br>/* version checking will happen here if and when */ <br> <br>/* Make subkeys and values */ <br>/* Vendor key is the passed in name of the vendor */ <br>_tcscpy(tCurKey, lpisv-&gt;m_pVendor); <br>    lRet = RegCreateKeyEx(hkParentKey, tCurKey, 0, NULL,  <br>REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hkCurKey, &amp;dwKeyDisp); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>if (bRemove) <br>{ <br>/* remove the named application */ <br>        lRet = UnregisterApplication(hkCurKey, lpisv-&gt;m_pAppNameKey); <br>        if (lRet == ERROR_SUCCESS) <br>        { <br>            // if there are no more subkeys then delete the vendor key <br>            DWORD dwNumSubkeys = 1; <br>            RegQueryInfoKey(hkCurKey, NULL, NULL, NULL, &amp;dwNumSubkeys,  <br>                NULL, NULL, NULL, NULL, NULL, NULL, NULL); <br>            RegCloseKey(hkCurKey); <br>            if (dwNumSubkeys == 0) <br>            { <br>                lRet = RegDeleteKey(hkParentKey, tCurKey); <br>            } <br>        } <br>        else <br>        { <br>            RegCloseKey(hkCurKey); <br>        } <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>/* Make the key for the application itself */ <br>    RegCloseKey(hkParentKey); <br>hkParentKey = hkCurKey; <br>_tcscpy(tCurKey, lpisv-&gt;m_pAppNameKey); <br>lRet = RegCreateKeyEx(hkParentKey, tCurKey, 0, NULL,  <br>REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hkCurKey, &amp;dwKeyDisp); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkCurKey); <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>/* values for the named application key */ <br>/* ApplicationName */ <br>_tcscpy(tValueName, SmsRegNameValue); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_SZ,  <br>lpisv-&gt;m_pAppName, _tcslen(lpisv-&gt;m_pAppName)+1); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkCurKey); <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>/* Order */ <br>_tcscpy(tValueName, SmsRegOrder); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_DWORD,  <br>(const BYTE *)&amp;lpisv-&gt;m_dwOrder, sizeof(DWORD)); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkCurKey); <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>/* Command */ <br>_tcscpy(tValueName, SmsRegCommand); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_SZ,  <br>lpisv-&gt;m_pCommand, _tcslen(lpisv-&gt;m_pCommand)+1); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkCurKey); <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>/* Description */ <br>_tcscpy(tValueName, SmsRegDescription); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_SZ,  <br>lpisv-&gt;m_pDescription, _tcslen(lpisv-&gt;m_pDescription)+1); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkCurKey); <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>/* Working Directory */ <br>_tcscpy(tValueName, SmsRegWorkingDir); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_EXPAND_SZ,  <br>lpisv-&gt;m_pWorkingDir, _tcslen(lpisv-&gt;m_pWorkingDir)+1); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkCurKey); <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br> <br>/* Run Window */ <br>_tcscpy(tValueName, SmsRegRunWindow); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_SZ,  <br>lpisv-&gt;m_pRunWindow, _tcslen(lpisv-&gt;m_pRunWindow)+1); <br>if (lRet != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkCurKey); <br>        RegCloseKey(hkParentKey); <br>        return lRet; <br>    } <br>     <br>    /* create a subkey for each context */ <br>    RegCloseKey(hkParentKey); <br>hkParentKey = hkCurKey; <br> <br>for (i = 0; i &lt; lpisv-&gt;m_nNumContexts; i++) <br>{ <br>ISVContext isvContext; <br> <br>isvContext = lpisv-&gt;m_pContexts[i]; <br> <br>/* create/open context key */ <br>_tcscpy(tCurKey, isvContext.m_pContextKey); <br>lRet = RegCreateKeyEx(hkParentKey, tCurKey, 0, NULL,  <br>REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,  <br>&amp;hkCurKey, &amp;dwKeyDisp); <br>    if (lRet != ERROR_SUCCESS) <br>        { <br>            RegCloseKey(hkCurKey); <br>            RegCloseKey(hkParentKey); <br>            return lRet; <br>        } <br> <br>/* values for context, construct REG_MULTI_SZ strings from input */ <br>/* Enable Rule */ <br>_tcscpy(tValueName, SmsRegEnableRule); <br>nSize = MakeMultiSz(tValueData, isvContext.m_pEnableRule); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_MULTI_SZ,  <br>tValueData, nSize); <br>    if (lRet != ERROR_SUCCESS) <br>        { <br>            RegCloseKey(hkCurKey); <br>            RegCloseKey(hkParentKey); <br>            return lRet; <br>        } <br> <br>/* Present Rule */ <br>_tcscpy(tValueName, SmsRegPresentRule); <br>nSize = MakeMultiSz(tValueData, isvContext.m_pPresentRule); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_MULTI_SZ,  <br>tValueData, nSize); <br>    if (lRet != ERROR_SUCCESS) <br>        { <br>            RegCloseKey(hkCurKey); <br>            RegCloseKey(hkParentKey); <br>            return lRet; <br>        } <br> <br>/* Arguments */ <br>_tcscpy(tValueName, SmsRegArguments); <br>nSize = MakeMultiSz(tValueData, isvContext.m_pArguments); <br>lRet = RegSetValueEx(hkCurKey, tValueName, 0, REG_MULTI_SZ,  <br>tValueData, nSize); <br>    if (lRet != ERROR_SUCCESS) <br>        { <br>            RegCloseKey(hkCurKey); <br>            RegCloseKey(hkParentKey); <br>            return lRet; <br>        } <br> <br>        RegCloseKey(hkCurKey);      /* close this subkey */ <br>} <br> <br>    RegCloseKey(hkParentKey); <br>return ERROR_SUCCESS; <br>} <br> <br>#if defined(__cplusplus) <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
