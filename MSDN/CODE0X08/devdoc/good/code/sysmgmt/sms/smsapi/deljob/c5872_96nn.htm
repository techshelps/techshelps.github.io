<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DELJOB.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5873"></a>DELJOB.CPP</h2>
<pre><code>// =========================================================================== <br>// Copyright (C) 1995 by Microsoft Corporation. <br>// <br>//  File: deljob.cpp <br>// <br>//  This program illustrates how to use the SMS SDK to delete an SMS <br>//  job. <br>// <br>//  Author: Larry A. French <br>// <br>// =========================================================================== <br> <br> <br>// ==================================================================== <br>//  Includes. <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;stdlib.h&gt;                 // for itoa <br>#include &lt;smsapi.h&gt;                 // Header for the APIs. <br>#include &lt;time.h&gt;                   // for time functions. <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br>// ==================================================================== <br>//      Defines. <br>// ==================================================================== <br> <br>#define CCH_MAXSTRING   256 <br>#define MAX_CREATE      100 <br> <br> <br> <br>// ==================================================================== <br>//  Local prototypes. <br>// ==================================================================== <br>const char *GetStatusName( SMS_STATUS stat ); <br> <br>void DisplaySmsError(const char* pszMessage, SMS_STATUS stat); <br> <br>BOOL DidRequestHelp(int argc, char** argv); <br> <br>HANDLE ConnectToDatasource(); <br> <br>void DisplayHelp(); <br> <br>void InputString(const char* pszMessage, char* pszResult); <br> <br>void DisplayGreeting(); <br> <br>BOOL UserSaysYes(const char* pszPrompt); <br> <br> <br>// ==================================================================== <br>//  Structs. <br>// ==================================================================== <br>// This struct holds a folder handle and its ID. <br>typedef struct _FOLDERREC { <br>    HANDLE hFolder;                     // Handle to a folder. <br>    char szID[SMS_DATA_BUFF_SIZE+1];    // Its ID. <br>    BOOL bDeleted;                      // marked as deleted in this program. <br>} FOLDERREC; <br> <br> <br> <br>// ==================================================================== <br>//  The work starts here. <br>// ==================================================================== <br>void main(int argc, char** argv) <br>{ <br>    // Check to see if this is a request to display the help <br>    // screen.  If so, display it. Otherwise, display a greeting <br>    // banner. <br>    //========================================================= <br>    if (DidRequestHelp(argc, argv)) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br> <br> <br> <br>    SMS_STATUS stat; <br>    HANDLE hConnect; <br>    HANDLE hContainerJob; <br>    char szJobID[SMS_DATA_BUFF_SIZE + 1]; <br>    char szPrompt[CCH_MAXSTRING]; <br> <br> <br> <br>    // Connect to the data source. If the connect fails, give up. <br>    // Note a message will have already been displayed by <br>    // ConnectToDatasource. <br>    //=========================================================== <br>    hConnect = ConnectToDatasource(); <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br>    // Open package container. <br>    // ======================= <br>    stat = SmsOpenContainer( C_JOB, hConnect, &amp;hContainerJob ); <br>    if (stat != SMS_OK) { <br>        printf("SmsOpenContainer failed: %d\n", stat); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br> <br> <br> <br>    // Select all folders (no filters.) <br>    // ================================ <br>    stat = SmsPopulate( hContainerJob, POP_SYNC, NULL); <br>    if (!(stat == SMS_OK || stat==SMS_EMPTY)) { <br>        printf("Bad return from SmsPopulate: %d\n", stat); <br>        SmsCloseContainer( hContainerJob ); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br> <br> <br> <br>    FOLDERREC *paFolderRec = NULL; <br> <br>    // Get count of folders in container, allocate memory. <br>    // =================================================== <br>    DWORD ctFolders; <br>    SmsGetFolderCount( hContainerJob, F_ANY, &amp;ctFolders ); <br>    paFolderRec = (FOLDERREC *)malloc( ctFolders * sizeof(FOLDERREC) ); <br> <br>    // Retrieve all the jobs and store their handles and IDs. <br>    // ====================================================== <br>    for (DWORD dwI = 0; dwI &lt; ctFolders; dwI++) { <br> <br>        SmsGetNextFolder( hContainerJob, F_ANY, &amp;(paFolderRec[dwI].hFolder) ); <br>        SmsGetFolderID( paFolderRec[dwI].hFolder, paFolderRec[dwI].szID ); <br>        paFolderRec[dwI].bDeleted = FALSE; <br>    } <br>     <br>    BOOL bDidDeleteFolder; <br> <br>AGAIN: <br>     <br>    // The bDidDelete flag is used to indicate whether or not <br>    // the folder deletion was successful.  We assume that something <br>    // will go wrong until we have proven otherwise and know that <br>    // the folder was in fact deleted. <br>    //============================================================= <br>    bDidDeleteFolder = FALSE; <br> <br>    printf("**************************************************\n"); <br>    printf("* Please enter the ID of the job that you wish   *\n"); <br>    printf("* to delete.                                     *\n"); <br>    printf("* Available jobs are:                            *\n"); <br>    printf("**************************************************\n"); <br> <br>    // Display the job IDs. <br>    // ==================== <br>    for (dwI = 0; dwI &lt; ctFolders; dwI++) { <br>        if (!paFolderRec[dwI].bDeleted) { <br>            printf("[%d] %s\n", dwI, paFolderRec[dwI].szID); <br>        } <br>    } <br>    printf("\n"); <br> <br>    InputString("Job ID", szJobID); <br>    sprintf(szPrompt, "Delete job \"%s\"", szJobID); <br> <br> <br>    if (UserSaysYes(szPrompt)) { <br>        // Control comes here if the user has given the OK to delete <br>        // the specified job. To delete the job, we first get its <br>        // its folder handle, unlink the folder, and then commit it. <br>        // Note that SmsGetFolderByID doesn't work on containers. <br>        // <br>        // Search the array of FOLDERRECs looking for this ID. <br>        // ========================================================= <br>        BOOL bFound = FALSE; <br>        for (dwI = 0; dwI &lt; ctFolders; dwI++) { <br>            if (strcmp( szJobID, paFolderRec[dwI].szID ) == 0) { <br> <br>                // Check that not already deleted <br>                if (!paFolderRec[dwI].bDeleted) { <br>                    bFound = TRUE; <br>                } <br>                break; <br>            } <br>        } <br> <br> <br>        // If we found the ID, unlink and commit the folder. <br>        // ================================================= <br>        if (bFound) { <br>            // Unlink the folder to remove it from the in-memory hierarchy. <br>            //============================================================ <br>            stat = SmsUnlinkFolder(paFolderRec[dwI].hFolder); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("Failed to unlink the job folder", stat); <br>            } <br> <br> <br>            // Commit the unlinked folder to delete the folder in the <br>            // datasource. <br>            //======================================================= <br>            stat = SmsCommitFolder(paFolderRec[dwI].hFolder); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("Failed to commit the job folder", stat); <br>            } <br> <br>            // If all OK then mark that job as deleted in our array. <br>            // ===================================================== <br>            if (stat == SMS_OK) { <br>                paFolderRec[dwI].bDeleted = TRUE; <br>                bDidDeleteFolder = TRUE; <br>                printf("Job: %s was deleted succesfully\n\n", szJobID); <br>            } <br> <br>        } else { <br>            printf("Job %s not found\n", szJobID ); <br>        } <br> <br>    } <br> <br>    // Allow user to try again. <br>    // (This is one of the few cases where a goto is permitted.) <br>    // ========================================================= <br>     <br>    if (UserSaysYes(bDidDeleteFolder ? "Delete another job?" : "Try again?")) { <br>        goto AGAIN; <br>    } <br> <br> <br>    // Close all job folders. <br>    // ====================== <br>    for (dwI = 0; dwI &lt; ctFolders; dwI++) { <br>        SmsCloseFolder( paFolderRec[dwI].hFolder ); <br>    } <br> <br> <br>    // Close the container. <br>    //===================== <br>    stat = SmsCloseContainer( hContainerJob ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to close the package container", stat); <br>    } <br> <br>    // Disconnect from the datasource. <br>    //================================ <br>    stat = SmsDataSourceDisconnect( hConnect ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to disconnect from the datasource", stat); <br>    } <br> <br> <br>}  /* main */ <br> <br> <br> <br> <br>// ==================================================================== <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char* pszMessage <br>//          The user prompt to display. <br>// <br>//      char* pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString(const char* pszMessage, char* pszResult) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br>// ==================================================================== <br>// UserSaysYes <br>// <br>// Prompt the user to reply yes or no.  If the user enters "Y" then <br>// return TRUE, otherwise FALSE. <br>// <br>// Parameters: <br>//      const char* pszPrompt <br>//          The string used to prompt the user <br>// <br>// Returns: <br>//      TRUE = User replied "Y" or "y" <br>//      FALSE = User gave any other reply. <br>// <br>// ==================================================================== <br>BOOL UserSaysYes(const char* pszPrompt) <br>{ <br>    printf("%s? [y/n]", pszPrompt); <br>    char szReply[256]; <br>    gets(szReply); <br> <br>    return(szReply[0] == 'y' || szReply[0] == 'Y'); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>// <br>// ==================================================================== <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXSTRING]; <br>    char szUser[CCH_MAXSTRING]; <br>    char szPasswd[CCH_MAXSTRING]; <br>    char szDatabase[CCH_MAXSTRING]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br>// ==================================================================== <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char** argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>// ==================================================================== <br>BOOL DidRequestHelp(int argc, char** argv) <br>{ <br>    const char* pszCommand = argv[1]; <br>    if (argc==2  &amp;&amp; (strcmp((const char*) argv[1], "-help")==0)) { <br>        return(TRUE); <br>    } <br>    else { <br>        return(FALSE); <br>    } <br>} <br> <br> <br>// ==================================================================== <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br>void DisplayHelp() <br>{ <br>    printf("\n\n"); <br>    printf("********************************************************\n"); <br>    printf("* deljob.exe:                                          *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* This program illustrates how to use the SMS SDK to   *\n"); <br>    printf("* delete a job in the SMS database.                    *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* Syntax:                                              *\n"); <br>    printf("*     deljob.exe [-help]                               *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* Switches:                                            *\n"); <br>    printf("*     -help       Display this help screen.            *\n"); <br>    printf("*                                                      *\n"); <br>    printf("********************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>// ==================================================================== <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>// <br>// ==================================================================== <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br>} <br> <br> <br> <br> <br>/* EOF: deljob.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
