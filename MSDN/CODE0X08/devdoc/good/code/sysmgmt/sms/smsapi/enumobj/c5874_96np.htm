<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5875"></a>ENUMOBJ.CPP</h2>
<pre><code>// ==================================================================== <br>// <br>//  File: enumobj.cpp <br>// <br>//  Copyright (c) 1996 Microsoft Corp. <br>// <br>//  Author: <br>//      Jonathan Shuval     Microsoft Corp. <br>// <br>//  Sample program for illustrating use of the SMS object enumeration <br>//  APIs. <br>// <br>// <br>// ==================================================================== <br> <br> <br>// ==================================================================== <br>// <br>//      Includes <br>// <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt; <br> <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br>// ==================================================================== <br>// <br>//      Defines. <br>// <br>// ==================================================================== <br>#define CCH_MAXINPUT 256 <br> <br> <br>// ==================================================================== <br>// <br>//      Prototypes. <br>// <br>// ==================================================================== <br> <br>// Display an error message with its SMS status value. <br>// ------------------------------------------------------------- <br>void DisplaySmsError( const char *pszMessage, SMS_STATUS stat ); <br> <br> <br>// Connect to the SMS datasource. <br>// ------------------------------------------------------------- <br>HANDLE ConnectToDatasource(); <br> <br> <br>// Do the real enumerate, recursive. <br>// ------------------------------------------------------------- <br>void enumObj( HANDLE hConnect, <br>              SMSBUFF *pPreds, <br>              DWORD ctPreds, <br>              char *pszObj, <br>              int iIndent ); <br> <br> <br>// Prompt the user for input and return the reply. <br>// ------------------------------------------------------------- <br>void InputString( const char *pszMessage, char *pszResult ); <br> <br> <br> <br>// ==================================================================== <br>// <br>//      Globals. <br>// <br>// ==================================================================== <br>// None. <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//      Start here. <br>// <br>// ==================================================================== <br> <br>void main() <br>{ <br> <br> <br> <br>    // Get and display the SMS API version. <br>    // ------------------------------------ <br>    char *pszVersion;                   // Receives pointer to the version string. <br>    SmsAPIVer( &amp;pszVersion );           // Get version <br>    printf("Using %s\n", pszVersion);   // and print it. <br> <br> <br>    SMS_STATUS stat; <br>    DWORD dwLoop; <br> <br> <br>    //=========================================== <br>    // Connect to the SMS datasource. <br>    //=========================================== <br>    HANDLE hConnect; <br>    hConnect = ConnectToDatasource(); <br> <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br> <br>    // Get the first-class objects. <br>    // ============================ <br>    SMSBUFF ObjectTypes[10]; <br>    DWORD ctObjectTypes = 10; <br> <br>    stat = SmsEnumObjectTypes( hConnect, ObjectTypes, &amp;ctObjectTypes ); <br> <br>    if (stat != SMS_OK) { <br>        printf("EnumObjectTypes fails: %d\n", stat); <br>        return; <br>    } <br> <br>    printf("There are %d object types...\n", ctObjectTypes); <br>    for (dwLoop = 0; dwLoop &lt; ctObjectTypes; dwLoop++) { <br>        printf("\t%s\n", ObjectTypes[dwLoop]); <br>    } <br>    printf("\n\n"); <br> <br> <br> <br>    // Now loop for each object type <br>    // ============================= <br> <br>    for (dwLoop = 0; dwLoop &lt; ctObjectTypes; dwLoop++) { <br>        printf("\n[%d] Enumerating %s...\n", dwLoop, ObjectTypes[dwLoop]); <br> <br> <br>        SMSBUFF Predecessors[50]; <br>        DWORD ctPreds = 0; <br> <br>        enumObj( hConnect, Predecessors, ctPreds, ObjectTypes[dwLoop], 1 ); <br> <br>    } <br> <br> <br>    printf("**** All done ****\n\n"); <br> <br>    SmsDataSourceDisconnect( hConnect ); <br> <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// enumObj <br>// <br>// <br>// <br>// <br>// Parameters: <br>//      HANDLE hConnect         Handle to the connection. <br>//      SMSBUFF *pPreds         Pointer to the predecessor list. <br>//      DWORD ctPreds           Number of entries in the predecessor list. <br>//                              Note: this is not the size of the list, <br>//                              it is the number of entries that are <br>//                              filled in in the list. <br>//      char *pszObj            Name of object to enumerate. <br>//      int iIndent             Indent level. Just so we can display things <br>//                              nicely. <br>// <br>// Returns; <br>//      Nothing. <br>// <br>// NOTE: assumes that predecessor buffer is big enough. <br>// ==================================================================== <br>void enumObj( HANDLE hConnect, <br>              SMSBUFF *pPreds, <br>              DWORD ctPreds, <br>              char *pszObj, <br>              int iIndent ) <br>{ <br>    OBJDESCRIPTOR Objects[50];      // Filled in by the API. Contains <br>                                    // descriptions of each object. <br>    DWORD ctObjs = 50; <br>    SMS_STATUS stat; <br>    char *pszObjType;               // We display the object type. <br> <br>    // Leading spaces for indentation. Just so that the display looks ok. <br>    // ------------------------------------------------------------------ <br>    char szIndent[50]; <br>    szIndent[0] = '\0'; <br>    for (int i = 0; i &lt; iIndent; i++) { <br>        strcat(szIndent, "    "); <br>    } <br> <br> <br>    stat = SmsEnumObjects( hConnect, pszObj, pPreds, ctPreds, Objects, &amp;ctObjs ); <br>    if (stat == SMS_NO_MORE_DATA) { <br>        return;             // Just means we've finished enumerating this one. <br>    } <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Bad return from EnumObjects", stat); <br>        return; <br>    } <br> <br> <br>    // Add each object from our returned buffer into the <br>    // predecessor list and recurse. <br>    // ================================================= <br>    for (DWORD dwLoop = 0; dwLoop &lt; ctObjs; dwLoop++) { <br> <br>        // Print out the current object. <br>        // ----------------------------- <br>        printf("%s%-25s", szIndent, Objects[dwLoop].szName); <br> <br>        // If we've got a friendly name print it. <br>        // -------------------------------------- <br>        if (Objects[dwLoop].bGotFriendlyName) { <br>            printf(" &lt;%s&gt;", Objects[dwLoop].szFriendlyName); <br>        } <br> <br>        // If this is an attribute we'll have its range of <br>        // relational operators. <br>        // ----------------------------------------------- <br>        if (Objects[dwLoop].bGotRelops) { <br>            printf(" ['%s' to '%s']", <br>                OpName[Objects[dwLoop].dwRelopMin], <br>                OpName[Objects[dwLoop].dwRelopMax]); <br>        } <br>        printf("\n"); <br> <br>        // Print object type. <br>        // ------------------ <br>        switch (Objects[dwLoop].objType) { <br>        case OT_ARCHLIST: <br>            pszObjType = "Architecture list"; <br>            break; <br> <br>        case OT_ARCH: <br>            pszObjType = "Architecture"; <br>            break; <br> <br>        case OT_GROUP: <br>            pszObjType = "Group"; <br>            break; <br> <br>        case OT_ATTRIBUTE: <br>            pszObjType = "Attribute"; <br>            break; <br> <br> <br>        case OT_PLATFORMS: <br>            pszObjType = "Platform list"; <br>            break; <br> <br>        case OT_PLATFORM_PDF: <br>            pszObjType = "PDF Platform"; <br>            break; <br> <br>        case OT_PLATFORM_WINST: <br>            pszObjType = "Winst platform"; <br>            break; <br> <br>        case OT_PLATFORM_NAD: <br>            pszObjType = "NAD platform"; <br>            break; <br> <br> <br>        case OT_UNKNOWN: <br>            pszObjType = "Unknown"; <br>            break; <br> <br>        } <br>        printf("%sThis is a: %s\n", szIndent, pszObjType ); <br> <br> <br>        // Recurse to get descendents. <br>        // --------------------------- <br>        strcpy( pPreds[ctPreds], pszObj );      // Add current object to pred list <br>        enumObj( hConnect, pPreds, ctPreds+1, Objects[dwLoop].szName, iIndent+1 ); <br> <br>    } <br> <br>} <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char* pszMessage <br>//          The user prompt to display. <br>// <br>//      char* pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString( const char *pszMessage, char *pszResult) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>// <br>// ==================================================================== <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXINPUT]; <br>    char szUser[CCH_MAXINPUT]; <br>    char szPasswd[CCH_MAXINPUT]; <br>    char szDatabase[CCH_MAXINPUT]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br>/* EOF: enumobj.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
