<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NEWPKG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5881"></a>NEWPKG.CPP</h2>
<pre><code>//************************************************************************** <br>// Copyright (C) 1995 by Microsoft Corporation. <br>// <br>//  File: newpkg.cpp <br>// <br>//  DESCRIPTION: <br>// <br>//  This program illustrates how to use the SMS SDK to view, create, and <br>//  delete packages.  It can be used to create sharing and workstation <br>//  packages but not inventory packages.  Also the packages created with <br>//  only a single sub-folder.  Thus the packages it creates can not be for <br>//  both sharing and workstations. <br>// <br>// <br>//  PROGRAM FLOW: <br>// <br>//  After logging on to a datasource, a package container is created and <br>//  populated. The program then enters a loop asking whether the user <br>//  wants to view the next package folder, delete the currently viewed <br>//  folder, or create a new folder. <br>// <br>//  Author: Larry A. French <br>// <br>//========================================================================== <br>//  The following API calls are used in this program. <br>// <br>//      SmsDataSourceConnect <br>//      SmsDataSourceDisconnect <br>//      SmsOpenContainer <br>//      SmsCloseContainer <br>//      SmsCreateFolder <br>//      SmsPopulate <br>//      SmsGetNextFolder <br>//      SmsDescribeFolder <br>//      SmsGetFolderID <br>//      SmsGetFolderType <br>//      SmsGetFolderCount <br>//      SmsLinkFolder <br>//      SmsUnlinkFolder <br>//      SmsCommitFolder <br>//      SmsRewind <br>//      SmsCloseFolder <br>//      SmsGetScalarCount <br>//      SmsSetScalar <br>//      SmsGetNextScalar <br>// <br>//************************************************************************** <br> <br> <br>// ==================================================================== <br>//  Includes. <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;stdlib.h&gt;                 // for itoa <br>#include &lt;smsapi.h&gt;                 // Header for the APIs. <br>#include &lt;time.h&gt;                   // for time functions. <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br>// ==================================================================== <br>// <br>//      Defines. <br>// <br>// ==================================================================== <br> <br>#define CCH_MAXSTRING   256 <br>#define MAX_CREATE      100 <br> <br>#define PACKAGE_PERMISSIONS (PACKAGE_USER_READ | PACKAGE_USER_WRITE | PACKAGE_GUEST_READ) <br> <br> <br> <br>// ==================================================================== <br>// <br>//      Prototypes. <br>// <br>// ==================================================================== <br> <br>void DisplayScalars( HANDLE hFolder ); <br>void ViewFolder( HANDLE hFolder ); <br>HANDLE CreatePackageFolder( HANDLE hFolderParent ); <br>time_t ReadTime(); <br>BOOL DidRequestHelp(int argc, char** argv); <br>void DisplayHelp(); <br>void DisplayGreeting(); <br>BOOL UserSaysYes(const char* pszPrompt); <br>HANDLE ConnectToDatasource(); <br>void DisplaySmsError(const char* pszMessage, SMS_STATUS stat); <br>const char* GetStatusName(SMS_STATUS stat); <br>void InputString(const char* pszMessage, char* pszResult); <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//  The work starts here. <br>// <br>// ==================================================================== <br>void main(int argc, char** argv) <br>{ <br>    // Check to see if this is a request to display the help <br>    // screen.  If so, display it. Otherwise, display a greeting <br>    // banner. <br>    //========================================================= <br>    if (DidRequestHelp(argc, argv)) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br> <br>    SMS_STATUS stat; <br>    HANDLE hConnect; <br>    HANDLE hContainerPkg; <br>    DWORD numFolders; <br>    DWORD numFoldersMax; <br>    DWORD dwFolder; <br>    DWORD dwIndex; <br> <br> <br>    // Connect to the data source.  If the connect fails, give up. <br>    // Note that a status message will be displayed by ConnectToDatasource. <br>    //===================================================================== <br>    hConnect = ConnectToDatasource(); <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br>    // Open package container. <br>    // ============================================================== <br>    stat = SmsOpenContainer( C_PACKAGE, hConnect, &amp;hContainerPkg ); <br>    if (stat != SMS_OK) { <br>        printf("SmsOpenContainer failed: %d\n", stat); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br>    // Any filters would be set here. <br> <br> <br>    // Select all folders matching our filters. <br>    // ======================================== <br>    stat = SmsPopulate( hContainerPkg, POP_SYNC, NULL); <br>    if (!(stat == SMS_OK || stat==SMS_EMPTY)) { <br>        printf("Bad return from SmsPopulate: %d\n", stat); <br>        SmsCloseContainer( hContainerPkg ); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br> <br>    stat = SmsGetFolderCount( hContainerPkg, F_ANY, &amp;numFolders); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsGetFolderCount failed on package container", stat); <br>        return; <br>    } <br> <br>    printf("==========  Container has %d folders  =========\n\n", numFolders ); <br> <br> <br>    // Allocate enough space to hold handles for all of the folders currently <br>    // in the container, plus more than enough space to hold all of the folders <br>    // that we will create. <br>    //========================================================================= <br>    numFoldersMax = numFolders + MAX_CREATE; <br> <br>    HANDLE *phFolders = (HANDLE *)malloc(numFoldersMax * sizeof(HANDLE)); <br>    HANDLE hFolder; <br> <br>    // Open all top-level folders. <br>    // --------------------------- <br>    for (dwFolder = 0; dwFolder &lt; numFolders; dwFolder++) { <br>        stat = SmsGetNextFolder( hContainerPkg, F_ANY, &amp;hFolder ); <br>        if (stat != SMS_OK) { <br>            printf("Error in retrieving a folder: %d\n", stat); <br>            break; <br>        } <br> <br>        phFolders[dwFolder] = hFolder; <br>    } <br> <br> <br>    // Now we enter a loop asking the user whether they want to <br>    // view the next folder, Delete the folder just displayed, <br>    // or create a new folder. <br>    // ========================================================= <br>    BOOL bDoQuit = FALSE; <br>    char szReply[CCH_MAXSTRING]; <br>    dwFolder = 0; <br> <br>    while (!bDoQuit) { <br> <br>        printf("\n\n"); <br>        printf("*******************************************\n"); <br>        printf("* Enter a command:                        *\n"); <br>        printf("*    N      View next folder.             *\n"); <br>        printf("*    P      View previous folder.         *\n"); <br>        printf("*    V      View current folder.          *\n"); <br>        printf("*    D      Delete current folder.        *\n"); <br>        printf("*    C      Create new folder.            *\n"); <br>        printf("*    X      Exit.                         *\n"); <br>        printf("*******************************************\n"); <br>        printf("\n"); <br> <br>        InputString("[NPVDCX]", szReply); <br> <br>        switch (szReply[0]) { <br>        case 0: <br>        case 'N': case 'n': <br> <br>            // Fall through to the "View" command <br>            // =========== View next folder ==================== <br>            if ((dwFolder + 1) &lt; numFolders) { <br>                dwFolder++; <br>                ViewFolder( phFolders[dwFolder] ); <br>            } else <br>                printf("At end of folder list\n"); <br>           break; <br> <br>        case 'P': case 'p': <br>            if (dwFolder &gt; 0) { <br>                --dwFolder; <br>                ViewFolder(phFolders[dwFolder]); <br>            } else { <br>                printf("At first folder\n"); <br>            } <br>            break; <br> <br>        case 'V': case 'v': <br>            if (dwFolder &gt;= 0 &amp;&amp; dwFolder &lt; numFolders) { <br>                ViewFolder( phFolders[dwFolder]); <br>            } else { <br>                printf("View: No such folder: %d\n", dwFolder); <br>            } <br>            break; <br> <br>        case 'D': case 'd': <br>            // =========== Delete current folder =============== <br> <br>            // Check we have a folder to delete. <br>            if (dwFolder &gt;= numFolders || dwFolder &lt; 0) { <br>                printf("Delete: No such folder: %d\n", dwFolder); <br>                break; <br>            } <br> <br>            hFolder = phFolders[dwFolder]; <br> <br>            if (!UserSaysYes("Are you sure you want to delete this folder")) { <br>                printf("Delete cancelled\n"); <br>                break; <br>            } <br> <br>            stat = SmsUnlinkFolder( hFolder ); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("Delete: UnlinkFolder failed", stat); <br>                break; <br>            } <br>            stat = SmsCommitFolder( hFolder ); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("Delete: commit folder failed", stat); <br>                break; <br>            } <br> <br>            // Close the folder so that its memory will be deallocated <br>            // when all other references to it go away.  Note that the <br>            // container retains a reference to its folder, so the memory <br>            // will not actually be deallocated until the container is <br>            // also closed. <br>            //========================================================== <br>            stat = SmsCloseFolder(hFolder); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("Delete: close folder failed", stat); <br>                break; <br>            } <br> <br>            // Remove the folder's handle from the handle table. <br>            //================================================== <br>            for(dwIndex = dwFolder; dwIndex &lt; (numFolders - 1); ++dwIndex) { <br>                phFolders[dwIndex] = phFolders[dwIndex+1]; <br>            } <br> <br>            // Adjust the folder index and folder count. <br>            // since there is now one less folder in the table. <br>            //================================================= <br>            --numFolders; <br>            if ((dwFolder &gt; 0) &amp;&amp; (dwFolder &gt;= numFolders)) { <br>                --dwFolder; <br>            } <br>            printf("Folder deleted\n"); <br>            break; <br> <br>        case 'C': case 'c': <br>            // =========== Create new folder =================== <br> <br>            // Check to see if the folder handle array is already <br>            // full.  If so, then display an error message and <br>            // begin a new command. <br>            //=================================================== <br>            if (numFolders &gt;= numFoldersMax) { <br>                printf("Can't create a new folder because the folder\n"); <br>                printf("handle array is full.\n"); <br>                printf("\n"); <br>                break; <br>            } <br> <br>            HANDLE hFolderPkg; <br>            hFolderPkg = CreatePackageFolder(hContainerPkg); <br>            if (hFolderPkg != NULL) { <br>                dwFolder = numFolders; <br>                phFolders[numFolders++] = hFolderPkg; <br>            } <br>            break; <br> <br>        case 'X': case 'x': <br>            // Terminate. <br>            bDoQuit = TRUE; <br>            break; <br> <br>        default: <br>            // print the message again. <br>            printf("Actions are: N(ext folder), D(elete folder), C(reate folder)\n"); <br>            printf("Type x to exit\n"); <br>            break; <br>        } <br>    } <br> <br>    // Close all of the package folders so that their memory will <br>    // be deallocated (when the container is closed). <br>    //=========================================================== <br>    for (dwFolder=0; dwFolder &lt; numFolders; ++dwFolder) { <br>        stat = SmsCloseFolder(phFolders[dwFolder]); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close a package folder", stat); <br>        } <br>    } <br> <br> <br>    // Close the container. <br>    //===================== <br>    stat = SmsCloseContainer( hContainerPkg ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to close the package container", stat); <br>    } <br> <br>    // Disconnect from the datasource. <br>    //================================ <br>    stat = SmsDataSourceDisconnect( hConnect ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to disconnecct from the datasource", stat); <br>    } <br> <br>    // Deallocate memory used for folder handles. <br>    //=========================================== <br>    free( phFolders ); <br> <br>}  /* main */ <br> <br> <br> <br> <br> <br> <br>//*************************************************************************** <br>// ReadTime <br>// <br>// Ask the user to enter a time string and convert it to a time_t value. <br>// <br>// Input: None. <br>// <br>// Returns: <br>//      time_t     The time value the user entered. <br>// <br>// <br>//*************************************************************************** <br>time_t ReadTime() <br>{ <br>    char szTime[CCH_MAXSTRING]; <br>    InputString("Enter time in the form mm/dd/yy hh:mm ", szTime); <br> <br> <br>    int mon, day, year, hour, min; <br>    time_t today; <br>    time( &amp;today ); <br> <br>    // Get the month (1..12) <br>    mon = (szTime[0] - '0') * 10 + (szTime[1]) - '0'; <br>    mon--; <br>    if (mon &lt; 0 || mon &gt; 11) { <br>        printf("Month wrong (valid 01-12)\n"); <br>        return(today); <br>    } <br> <br>    // Day (1..31) <br>    day = (szTime[3] - '0') * 10 + (szTime[4] - '0'); <br>    if (day &lt; 1 || day &gt; 31) { <br>        printf("Day wrong (Valid 01-07)\n"); <br>        return(today); <br>    } <br> <br>    // Year <br>    year = (szTime[6] - '0') * 10 + (szTime[7] - '0'); <br>    if (year &lt; 90 || year &gt; 99) { <br>        printf("Year wrong (Valid 90-99)\n"); <br>        return(today); <br>    } <br> <br>    // Hour (0..23) <br>    hour = (szTime[9] - '0') * 10 + (szTime[10] - '0'); <br>    if (hour &lt; 0 || hour &gt; 23) { <br>        printf("Hour wrong (Valid 00-23)\n"); <br>        return(today); <br>    } <br> <br>    // Minute (0..59) <br>    min = (szTime[12] - '0') * 10 + (szTime[13] - '0'); <br>    if (min &lt; 0 || min &gt; 59) { <br>        printf("Minute wrong (Valid 00-59)\n"); <br>        return(today); <br>    } <br> <br>    // Format the time, we want a time_t. <br>    struct tm theTime; <br>    theTime.tm_mon   = mon; <br>    theTime.tm_mday  = day; <br>    theTime.tm_year  = year; <br>    theTime.tm_hour  = hour; <br>    theTime.tm_min   = min; <br>    theTime.tm_sec   = 0; <br>    theTime.tm_isdst = -1; <br> <br>    time_t time = mktime( &amp;theTime ); <br>    return(time); <br>} <br> <br> <br> <br> <br>//************************************************************************** <br>// SetScalarString <br>// <br>// This function sets the value specified scalar to the given string <br>// value. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char* pszName <br>//          The name of the scalar. <br>//      char* pszValue <br>//          The string that will be assigned to the scalar's value. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_STRING. <br>//*************************************************************************** <br>SMS_STATUS SetScalarString(HANDLE hFolder, char* pszName, char* pszValue) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_STRING; <br>    sc.pszValue = pszValue; <br> <br>    SMS_STATUS stat; <br>    stat = SmsSetScalar(hFolder, &amp;sc); <br>    return( stat ); <br>} <br> <br> <br> <br> <br>//************************************************************************** <br>// SetScalarDword <br>// <br>// This function sets the value of the specified scalar to <br>// the given DWORD value. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char* pszName <br>//          The name of the scalar. <br>//      DWORD dwValue <br>//          The DWORD value to set the scalar to. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_INT. <br>//*************************************************************************** <br>SMS_STATUS SetScalarDword(HANDLE hFolder, char* pszName, DWORD dwValue) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_INT; <br>    sc.dwValue = dwValue; <br> <br> <br>    SMS_STATUS stat; <br>    stat = SmsSetScalar(hFolder, &amp;sc); <br>    return( stat ); <br>} <br> <br> <br> <br> <br>//************************************************************************** <br>// GetPlatformSelection <br>// <br>// Prompt the user to select a one or more platforms.  The platforms are <br>// selected by entering a comma separated list of platform indexes.  These <br>// platform indexes are converted to the platforms flags value for the SDK. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The SMS SDK platform flags value. <br>//*************************************************************************** <br>DWORD GetPlatformSelection() <br>{ <br>    printf("\n\n"); <br>    printf("**********************************************\n"); <br>    printf("* Select a platform from the following list. *\n"); <br>    printf("**********************************************\n"); <br>    printf("   1) MS-DOS \n"); <br>    printf("   2) Windows 3.1\n"); <br>    printf("   3) Windows 95\n"); <br>    printf("   4) Windows NT (X86)\n"); <br>    printf("   5) Windows NT (Mips)\n"); <br>    printf("   6) Windows NT (Alpha)\n"); <br>    printf("   7) Macintosh\n"); <br>    printf("\n"); <br> <br>    DWORD dwPlatforms = 0; <br>    char szReply[CCH_MAXSTRING]; <br>    InputString("Enter a comma separated list of platform number(s)", szReply); <br>    printf("\n"); <br> <br>    // Scan through the reply string and set the bits <br>    // dwPlatforms to correspond to the platform(s) specified <br>    // by the user.  Note that the list is a string of comma <br>    // separated digits. <br>    //====================================================== <br>    const char* pszReply = szReply; <br>    while (*pszReply) { <br>        if (*pszReply &lt; '1' || *pszReply &gt; '7') { <br>            // An invalid character is present in the <br>            // reply.  Flag this error by returning zero. <br>            //========================================== <br>            dwPlatforms = 0; <br>            break; <br>        } <br> <br>        // Interpret the platform selector character. <br>        //=========================================== <br>        switch(*pszReply++) { <br>        case '1': <br>            dwPlatforms |= PLTFRM_MSDOS; <br>            break; <br>        case '2': <br>            dwPlatforms |= PLTFRM_WIN16; <br>            break; <br>        case '3': <br>            dwPlatforms |= PLTFRM_WIN95; <br>            break; <br>        case '4': <br>            dwPlatforms |= PLTFRM_WIN32_X86; <br>            break; <br>        case '5': <br>            dwPlatforms |= PLTFRM_WIN32_MIPS; <br>            break; <br>        case '6': <br>            dwPlatforms |= PLTFRM_WIN32_ALPHA; <br>            break; <br>        case '7': <br>            dwPlatforms |= PLTFRM_MACINTOSH; <br>            break; <br>        } <br> <br>        // Skip any trailing whitespace after the digit. <br>        //============================================== <br>        while (*pszReply == ' ' || *pszReply=='\t') { <br>            ++pszReply; <br>        } <br> <br>        // Skip the comma. <br>        //================ <br>        if (*pszReply == ',') { <br>            ++pszReply; <br>        } <br> <br>        // Skip white space preceding the next digit. <br>        //========================= <br>        while (*pszReply == ' ' || *pszReply=='\t') { <br>            ++pszReply; <br>        } <br> <br>    } <br> <br>    return( dwPlatforms ); <br>} <br> <br> <br> <br> <br> <br> <br>//************************************************************************** <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>//*************************************************************************** <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXSTRING]; <br>    char szUser[CCH_MAXSTRING]; <br>    char szPasswd[CCH_MAXSTRING]; <br>    char szDatabase[CCH_MAXSTRING]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br> <br> <br> <br> <br>//************************************************************************** <br>// ViewFolder <br>// <br>//  Display the folder contents.  This version only displays the folder name <br>//  and type, number of scalars, and the scalars. Other information not <br>//  relevant. <br>// <br>//  NOTE: no error checking. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder to view. <br>// <br>// Returns: Nothing. <br>// <br>//************************************************************************** <br>void ViewFolder( HANDLE hFolder ) <br>{ <br>    char szFolderID[SMS_DATA_BUFF_SIZE + 1];        // This folder's ID. <br>    char szfType[SMS_DATA_BUFF_SIZE + 1];           // Folder's tag. <br>    DWORD fType;                        // Folder's type. <br>    DWORD ctScalars;                    // How many scalars in this folder. <br>    SMS_STATUS stat; <br> <br> <br>    // Get folder ID and type. <br>    // ----------------------- <br>    stat = SmsGetFolderID( hFolder, szFolderID ); <br>    if (stat == SMS_NEW_FOLDER) { <br>        strcpy( szFolderID, "New folder without an ID yet" ); <br> <br>    } <br>    else if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get folder ID", stat); <br>        strcpy( szFolderID, "Couldn't get the folder ID" ); <br>    } <br> <br>    printf("============== %s ===========\n", szFolderID); <br> <br>    stat = SmsGetFolderType( hFolder, &amp;fType, szfType ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get folder type", stat); <br>    } <br> <br>    printf("SCALARS FOR FOLDER %s\n", szFolderID); <br> <br>    // Get count of scalars. <br>    // --------------------- <br>    stat = SmsGetScalarCount( hFolder, &amp;ctScalars ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get scalar count", stat); <br>    } <br>    printf("%s (%s) contains %d scalars\n", szFolderID, szfType, ctScalars); <br> <br> <br>    // Display the scalars. <br>    // -------------------- <br>    DisplayScalars( hFolder ); <br> <br> <br>    // Get the folder count <br>    DWORD ctFolders; <br>    stat = SmsGetFolderCount(hFolder, F_ANY, &amp;ctFolders); <br>    printf("%s (%s) contains %d sub-folders\n", szFolderID, szfType, ctFolders); <br>    for (DWORD dwFolder = 0; dwFolder &lt; ctFolders; ++dwFolder) { <br>        printf("Getting subfolder\n"); <br>        HANDLE hSubFolder; <br>        stat = SmsGetNextFolder(hFolder, F_ANY, &amp;hSubFolder); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsGetNextFolder failed", stat); <br>            break; <br>        } <br> <br>        ViewFolder(hSubFolder); <br> <br>        // Close the sub-folder to avoid a memory leak. <br>        //============================================ <br>        stat = SmsCloseFolder(hSubFolder); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close an open folder", stat); <br>            break; <br>        } <br>    } <br> <br> <br>    SmsRewind(hFolder, RW_FOLDER | RW_SCALAR); <br> <br>}  /* ViewFolder */ <br> <br> <br> <br> <br> <br>//************************************************************************* <br>// CreateWcl <br>// <br>// This method is called to create a WCL subfolder in <br>// a package folder. <br>// <br>// Parameters: <br>//      HANDLE hFolderPkg <br>//          This is the handle of the parent folder that the newly <br>//          created subfolder will be inserted into.  For WCL and <br>//          program item folders, the parent folder is a package <br>//          folder. <br>// <br>// Returns: <br>//      HANDLE <br>//          This is the handle of the newly created subfolder. <br>// <br>//************************************************************************* <br>HANDLE CreateWcl(HANDLE hFolderPkg) <br>{ <br>    printf("\n\n"); <br>    printf("*****************************************************\n"); <br>    printf("* Creating the workstation command line sub-folder. *\n"); <br>    printf("*****************************************************\n"); <br>    printf("\n"); <br> <br> <br>    HANDLE hFolderNew; <br>    SMS_STATUS stat; <br>    char szError[CCH_MAXSTRING]; <br>    char szReply[CCH_MAXSTRING]; <br>    DWORD dwPlatforms; <br> <br>    // Create the WCL folder <br>    //====================== <br>    stat = SmsCreateFolder( hFolderPkg, F_WCL, "", &amp;hFolderNew ); <br>    if (stat != SMS_OK) { <br>        sprintf(szError, "SmsCreateFolder failed to create the WCL folder"); <br>        DisplaySmsError(szError, stat); <br>        return( NULL ); <br>    } <br> <br> <br>    dwPlatforms = GetPlatformSelection(); <br> <br> <br>    printf("\n\n"); <br>    printf("*********************************************\n"); <br>    printf("* Enter values for the WCL folder scalars.  *\n"); <br>    printf("*********************************************\n"); <br>    printf("\n"); <br> <br>    InputString("Name", szReply); <br>    SetScalarString(hFolderNew, "Name", szReply); <br> <br>    InputString("Command", szReply); <br>    SetScalarString(hFolderNew, "Command", szReply); <br> <br>    SetScalarDword(hFolderNew, "Flags", 0); <br>    SetScalarDword(hFolderNew, "Platforms", dwPlatforms); <br> <br> <br> <br>    // Link the new WCL folder into the folder hierarchy.  Note that <br>    // this does not insert the folder into the datasource.  Only <br>    // SmsCommitFolder modifies the datasource. <br>    //============================================================== <br>    stat = SmsLinkFolder(hFolderNew); <br>    if ((stat != SMS_OK) &amp;&amp; (stat != SMS_PARENT_NEEDS_COMMIT)) { <br>        sprintf(szError, "SmsLinkFolder failed to link the WCL folder"); <br>        DisplaySmsError(szError, stat); <br>        return( NULL ); <br>    } <br> <br>    return( hFolderNew ) ; <br>} <br> <br> <br> <br>//************************************************************************* <br>// CreateProgItem <br>// <br>// This method is called to create a program item subfolder in <br>// a package folder. <br>// <br>// Parameters: <br>//      HANDLE hFolderPkg <br>//          This is the handle of the parent folder that the newly <br>//          created subfolder will be inserted into.  For WCL and <br>//          program item folders, the parent folder is a package <br>//          folder. <br>// <br>// Returns: <br>//      HANDLE <br>//          This is the handle of the newly created subfolder. <br>// <br>//************************************************************************* <br>HANDLE CreateProgItem(HANDLE hFolderPkg) <br>{ <br>    printf("\n\n"); <br>    printf("*****************************************\n"); <br>    printf("* Creating the program item sub-folder. *\n"); <br>    printf("*****************************************\n"); <br>    printf("\n"); <br> <br>    HANDLE hFolderNew; <br>    SMS_STATUS stat; <br>    char szReply[CCH_MAXSTRING]; <br>    char szError[CCH_MAXSTRING]; <br>    DWORD dwPlatforms; <br> <br>    // Create the programe item folder <br>    //================================ <br>    stat = SmsCreateFolder( hFolderPkg, F_PROGITEM, "", &amp;hFolderNew ); <br>    if (stat != SMS_OK) { <br>        sprintf(szError, "SmsCreateFolder failed to create the program item folder"); <br>        DisplaySmsError(szError, stat); <br>        return( NULL ); <br>    } <br> <br> <br> <br>    // Set the value of the scalars for the program item. <br>    //=================================================== <br>    dwPlatforms = GetPlatformSelection(); <br> <br> <br> <br>    printf("\n\n"); <br>    printf("******************************************************\n"); <br>    printf("* Enter values for the program item folder scalars.  *\n"); <br>    printf("******************************************************\n"); <br>    printf("\n"); <br> <br>    InputString("Description", szReply); <br>    SetScalarString(hFolderNew, "Description", szReply); <br> <br>    InputString("Command line", szReply); <br>    SetScalarString(hFolderNew, "Command line", szReply); <br> <br>    SetScalarDword(hFolderNew,  "Run minimized", FALSE); <br>    SetScalarDword(hFolderNew,  "Platforms", dwPlatforms); <br>    SetScalarString(hFolderNew, "Configure script file", ""); <br>    SetScalarDword(hFolderNew,  "Search local flag", 1); <br>    SetScalarDword(hFolderNew,  "Drive mode", 1); <br> <br>    InputString("Registry name", szReply); <br>    SetScalarString(hFolderNew, "Registry name", szReply); <br>    SetScalarDword(hFolderNew,  "Executable flag", TRUE); <br> <br> <br> <br>    // Link the new WCL folder into the folder hierarchy.  Note that <br>    // this does not insert the folder into the datasource.  Only <br>    // SmsCommitFolder modifies the datasource. <br>    //============================================================== <br>    stat = SmsLinkFolder(hFolderNew); </code></pre>
<p>
</p>
<pre><code>if ((stat != SMS_OK) &amp;&amp; (stat != SMS_PARENT_NEEDS_COMMIT)) { <br>        sprintf(szError, "SmsLinkFolder failed to link the programe item folder"); <br>        DisplaySmsError(szError, stat); <br>        return( NULL ); <br>    } <br> <br>    return( hFolderNew ) ; <br>} <br> <br> <br> <br> <br> <br>//************************************************************************* <br>// CreatePackageFolder <br>// <br>// Create a new package folder <br>// <br>// Parameters: <br>//      HANDLE hPackageContainer <br>//          This is the handle to the package folder's parent, which <br>//          is a package container. <br>// <br>// Returns: <br>//      The package folder's handle. <br>// <br>// ==================================================================== <br>HANDLE CreatePackageFolder(HANDLE hPackageContainer) <br>{ <br>    SMS_STATUS stat; <br>    char szReply[CCH_MAXSTRING]; <br>    HANDLE hFolderPkg = NULL; <br>    HANDLE hFolderWCL = NULL; <br>    HANDLE hFolderProgItem = NULL; <br> <br> <br> <br>    stat = SmsCreateFolder( hPackageContainer, F_PACKAGE, "", &amp;hFolderPkg ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsCreateFolder failed to create the package folder.", stat); <br>        return( NULL ); <br>    } <br> <br> <br>    printf("\n\n"); <br>    printf("***************************************************\n"); <br>    printf("* Creating package folder.  Select a package      *\n"); <br>    printf("* type.                                           *\n"); <br>    printf("*                                                 *\n"); <br>    printf("*    S         Sharing.                           *\n"); <br>    printf("*    W         Workstation.                       *\n"); <br>    printf("***************************************************\n"); <br>    printf("\n"); <br> <br>    InputString("SW: ", szReply); <br>    switch(szReply[0]) { <br>    case 'S': case 's': <br>        hFolderProgItem = CreateProgItem(hFolderPkg); <br>        break; <br>    case 'W': case 'w': <br>        hFolderWCL = CreateWcl(hFolderPkg); <br>        break; <br>    } <br> <br> <br> <br> <br>    printf("\n\n"); <br>    printf("*************************************\n"); <br>    printf("* Enter the package folder scalars. *\n"); <br>    printf("*************************************\n"); <br>    printf("\n"); <br> <br> <br>    InputString("Package name", szReply); <br>    SetScalarString(hFolderPkg, "Name", szReply); <br> <br>    InputString("Package comment", szReply); <br>    SetScalarString(hFolderPkg, "Comment", szReply); <br> <br>    // If this package contains a workstation command line, then set the <br>    // scalars that are relevant to workstation command lines. <br>    //================================================================== <br>    if (hFolderWCL) { <br>        SetScalarDword(hFolderPkg, "Share permissions", (DWORD) PACKAGE_PERMISSIONS); <br> <br>        InputString("Workstation root", szReply); <br>        SetScalarString(hFolderPkg, "Workstation root", szReply); <br> <br>    } <br> <br>    // If this package contains a program item, then set the scalars <br>    // that are relevant to program items. <br>    //============================================================== <br>    if (hFolderProgItem) { <br>        SetScalarDword(hFolderPkg, "Share permissions", (DWORD) PACKAGE_PERMISSIONS); <br> <br>        InputString("Server root", szReply); <br>        SetScalarString(hFolderPkg, "Server root", szReply); <br> <br>        InputString("Share name", szReply); <br>        SetScalarString(hFolderPkg, "Share name", szReply); <br>    } <br> <br> <br> <br> <br> <br>    // Display the folder and ask the user if he or she really wants to <br>    // write the folder to the datasource.  If the user says yes, then <br>    // commit the subfolder's first and then the package folder.  Note that <br>    // it does not make any sense to commit the package folder before its <br>    // subfolders because, once a folder is committed, modification is not <br>    // allowed and it would not be possible to commit the subfolders. <br>    //=================================================================== <br> <br>    ViewFolder(hFolderPkg); <br> <br>    if (UserSaysYes("OK to write the folder to the datasource")) { <br> <br>        if (hFolderWCL) { <br>            stat = SmsCommitFolder(hFolderWCL); <br>            if (stat != SMS_OK &amp;&amp; stat!=SMS_PARENT_NEEDS_COMMIT) { <br>                DisplaySmsError("Failed to commit the WCL folder", stat); <br>                goto CLOSE_FOLDERS_AND_EXIT; <br>            } <br>        } <br> <br>        if (hFolderProgItem) { <br>            stat = SmsCommitFolder(hFolderProgItem); <br>            if (stat != SMS_OK &amp;&amp; stat!=SMS_PARENT_NEEDS_COMMIT) { <br>                DisplaySmsError("Failed to commit the program item folder", stat); <br>                goto CLOSE_FOLDERS_AND_EXIT; <br>            } <br>        } <br> <br> <br> <br>        // Place the package folder in the in-memory hierarchy. <br>        stat = SmsLinkFolder(hFolderPkg); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsLinkFolder failed on the package folder", stat); <br>            goto CLOSE_FOLDERS_AND_EXIT; <br>        } <br> <br> <br>        // write it back to data source. <br>        stat = SmsCommitFolder( hFolderPkg ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to commit the package folder", stat); <br>        } <br>    } <br> <br>    // Fall through to close the folders. <br> <br>CLOSE_FOLDERS_AND_EXIT: <br> <br>    // Close the folder's so that memory will be freed when there are no <br>    // references to them.  A folder's memory is freed when its reference <br>    // count goes to zero.  A folder has one reference for each handle to it <br>    // that is returned plus an additional refernce from its parent folder or <br>    // container.  Thus we close the folder handles here so that the memory <br>    // allocated to the folders will be freed, but the memory won't actually <br>    // be freed until the package container is closed.  If you fail to close <br>    // any handle returned to you by the SMS API, the memory for that folder <br>    // will never be deallocated (even when the folder's container is closed). <br>    //======================================================================== <br> <br> <br>    if (hFolderWCL != NULL) { <br>        stat = SmsCloseFolder(hFolderWCL); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close the WCL folder", stat); <br>        } <br>    } <br> <br>    if (hFolderProgItem != NULL) { <br>        stat = SmsCloseFolder(hFolderProgItem); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close the program item folder", stat); <br>        } <br>    } <br> <br> <br>    return( hFolderPkg ); <br>} <br> <br> <br>//************************************************************************* <br>// DisplayScalars <br>// <br>// Display a folder's scalars. <br>// <br>// Parameters: <br>//      HANDLE hfolder <br>//          This is the folder handle. <br>// <br>// Returns: Nothing. <br>// <br>// ==================================================================== <br>void DisplayScalars( HANDLE hFolder ) <br>{ <br>    SMS_STATUS stat = SMS_OK; <br>    SCALAR scalar; <br>    char *pszTime;          // For conversion of time scalars. <br> <br>    // The scalars do not have their own string value buffer, so <br>    // we allocate the buffers here and set pointers to them in the <br>    // scalar structure. <br>    //============================================================= <br>    char szName[SMS_DATA_BUFF_SIZE+1]; <br>    char szValue[SMS_DATA_BUFF_SIZE+1]; <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br>    scalar.pValue = NULL; <br> <br> <br>    while (1) { <br> <br>        scalar.dwLen = sizeof(szValue)-1;       // must tell him the size <br> <br>        stat = SmsGetNextScalar( hFolder, &amp;scalar); <br>        if (stat == SMS_NO_MORE_DATA) { <br>            break; <br>        } <br> <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { <br>            DisplaySmsError("SmsGetNextScalar failed in method DisplayScalars", stat); <br>            break; <br>        } <br> <br>        if (stat == SMS_MORE_DATA) { <br> <br>            printf("Receive buffer too small, should be %d. Data truncated\n", <br>                            scalar.dwLen); <br>        } <br> <br>        // Check scalar type, display accordingly. <br>        // --------------------------------------- <br>        switch (scalar.scType) { <br>        case SCALAR_STRING: <br>            printf("\t%25s: %s\n", scalar.pszName, scalar.pszValue); <br>            break; <br> <br>        case SCALAR_INT: <br>            printf("\t%25s: %ld\n", scalar.pszName, scalar.dwValue); <br>            break; <br> <br>        case SCALAR_TIME: <br>            // Check if we have a string equivalence. If so use it. <br>            if (scalar.bStringEquivalence) { <br>                printf("\t%25s: %s\n", scalar.pszName, scalar.pszValue); <br> <br>            } else { <br>                pszTime = ctime( &amp;scalar.tValue ); <br>                printf("\t%25s: %s", scalar.pszName, pszTime); <br>            } <br>            break; <br> <br>        case SCALAR_BINARY: <br>            // In this sample we won't display the binary data. <br>            // Just tell the user its size. <br>            printf("\t%25s (Binary - this is its size): %ld\n", scalar.pszName, scalar.dwLen); <br>            break; <br>        } <br>    } <br> <br>    // Why did we exit (other than no more scalars)? <br>    //============================================== <br>    if (stat != SMS_NO_MORE_DATA) { <br>        printf("Bad return from Scalar access: %d\n", stat); <br>    } <br> <br>    printf("\n"); <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>// ******************************************************************** <br>//      Helper functions. <br>// ******************************************************************** <br> <br>//********************************************************** <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char** argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>//*********************************************************** <br>BOOL DidRequestHelp(int argc, char** argv) <br>{ <br>    const char* pszCommand = argv[1]; <br>    if (argc==2  &amp;&amp; (strcmp((const char*) argv[1], "-help")==0)) { <br>        return(TRUE); <br>    } <br>    else { <br>        return(FALSE); <br>    } <br>} <br> <br> <br>//********************************************************************** <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>//********************************************************************* <br>void DisplayHelp() <br>{ <br>    printf("\n\n"); <br>    printf("********************************************************\n"); <br>    printf("* newpkg.exe:                                          *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* This is a sample program for the SMS SDK. It can be  *\n"); <br>    printf("* used to view, create, or delete packages in the SMS  *\n"); <br>    printf("* database.                                            *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* Syntax:                                              *\n"); <br>    printf("*     newpkg.exe [-help]                               *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* Switches:                                            *\n"); <br>    printf("*     -help       Display this help screen.            *\n"); <br>    printf("*                                                      *\n"); <br>    printf("********************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>//******************************************************************* <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>//****************************************************************** <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br>} <br> <br> <br> <br> <br>//************************************************************************** <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char* pszMessage <br>//          The user prompt to display. <br>// <br>//      char* pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>//*************************************************************************** <br>void InputString(const char* pszMessage, char* pszResult) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br>//************************************************************************** <br>// UserSaysYes <br>// <br>// Prompt the user to reply yes or no.  If the user enters "Y" then <br>// return TRUE, otherwise FALSE. <br>// <br>// Parameters: <br>//      const char* pszPrompt <br>//          The string used to prompt the user <br>// <br>// Returns: <br>//      TRUE = User replied "Y" or "y" <br>//      FALSE = User gave any other reply. <br>//************************************************************************** <br>BOOL UserSaysYes(const char* pszPrompt) <br>{ <br>    printf("%s? [y/n]", pszPrompt); <br>    char szReply[CCH_MAXSTRING]; <br>    gets(szReply); <br> <br>    return(szReply[0] == 'y' || szReply[0] == 'Y'); <br> <br>} <br> <br> <br> <br>/* EOF: newjob.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
