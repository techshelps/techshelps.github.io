<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MGRP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5877"></a>MGRP.CPP</h2>
<pre><code>// ==================================================================== <br>// <br>//  File: mgrp.cpp <br>// <br>//  Copyright (C) 1996 by Microsoft Corporation. <br>// <br>//  Author: <br>//      Jonathan Shuval     Microsoft Corp. <br>// <br>// <br>//  This sample shows how to create a machine group and insert machines <br>//  into it. <br>// <br>// ==================================================================== <br> <br> <br> <br>// ==================================================================== <br>//  Includes. <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt;             // Header for the APIs. <br>#include &lt;time.h&gt;               // For converting time scalars into string. <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br> <br>// ==================================================================== <br>//  Defines. <br>// ==================================================================== <br>#define CCH_MAXINPUT 256 <br> <br> <br> <br>// ==================================================================== <br>//  Local prototypes. <br>// ==================================================================== <br> <br>// Does the real work. <br>// ------------------------------------------------------------- <br>void doTheWork( HANDLE hConnect ); <br> <br> <br>// Set filters according to what container we're looking at. <br>// ------------------------------------------------------------- <br>BOOL setMachFilters( HANDLE hConnect, HANDLE hContainer ); <br> <br> <br>// Functions to display folders, scalars, and expressions. <br>// ------------------------------------------------------------- <br>void DisplayFolder( HANDLE hFolder ); <br>void DisplayScalars( HANDLE hFolder ); <br> <br> <br>// Prompt the user for input and return the reply. <br>// ------------------------------------------------------------- <br>void InputString(const char* pszMessage, char* pszResult); <br> <br> <br>// Connect to the SMS datasource. <br>// ------------------------------------------------------------- <br>HANDLE ConnectToDatasource(); <br> <br> <br>// Display an error message with its SMS status value. <br>// ------------------------------------------------------------- <br>void DisplaySmsError(const char* pszMessage, SMS_STATUS stat); <br> <br> <br>// Get the string equivallent for an SMS status code. <br>// ------------------------------------------------------------- <br>const char *GetStatusName(SMS_STATUS stat); <br> <br>// Set a string scalar. <br>// ------------------------------------------------------------- <br>SMS_STATUS SetScalarString( HANDLE hFolder, char *pszName, char *pszValue); <br> <br> <br>// ==================================================================== <br>// <br>//  Macros for checking status <br>// <br>// ==================================================================== <br>        // Void return <br>#define CHKSTAT(str) if (stat != SMS_OK) { \ <br>        DisplaySmsError(str, stat);         \ <br>        return; } <br> <br>        // Bool return <br>#define CHKSTAT_RTN(str) if (stat != SMS_OK) { \ <br>        DisplaySmsError(str, stat);             \ <br>        return(FALSE); } <br> <br> <br> <br>// ==================================================================== <br>// <br>//  The work starts here. <br>// <br>// ==================================================================== <br>void main() <br>{ <br> <br>    HANDLE hConnect; <br> <br>    // Get and display API version. <br>    // ---------------------------- <br>    char *pszVersion; <br>    SmsAPIVer( &amp;pszVersion ); <br>    printf("%s\n", pszVersion ); <br> <br> <br> <br>    //=========================================== <br>    // Connect to the SMS datasource. <br>    //=========================================== <br>    hConnect = ConnectToDatasource(); <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br> <br>    // This loop allows us to do the real work multiple times. <br>    // ======================================================= <br>    BOOL bDone = FALSE; <br>    char reply[10]; <br> <br>    while (!bDone) { <br> <br>        doTheWork( hConnect ); <br> <br>        printf("Restart [y/n]? "); gets(reply); <br>        bDone = (reply[0] != 'y' &amp;&amp; reply[0] != 'Y'); <br>    } <br> <br> <br>    // Disconnect from the datasource. <br>    // =============================== <br>    SmsDataSourceDisconnect( hConnect ); <br> <br> <br>}  /* main */ <br> <br> <br> <br>// ==================================================================== <br>// <br>//  This function does whatever work is required. <br>//  In this case, it will: <br>//      - open a machine group container <br>//      - create a machine group folder <br>//      - open a machine container <br>//      - select machine folders from mach container that I want <br>//          to copy to the mgrp folder <br>//      - loop copying these machine folders to the mgrp folder <br>//      - link and commit the mgrp folder <br>//      - close everything <br> <br>// <br>// ==================================================================== <br>void doTheWork( HANDLE hConnect ) <br>{ <br>    HANDLE hMGrpContainer; <br>    HANDLE hMachContainer; <br>    SMS_STATUS stat; <br> <br>    // Open the containers <br>    // =================== <br>    stat = SmsOpenContainer( C_MACHINEGROUP, hConnect, &amp;hMGrpContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsOpenContainer (mach grp) failed", stat); <br>        return; <br>    } <br> <br>    stat = SmsOpenContainer( C_MACHINE, hConnect, &amp;hMachContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsOpenContainer (mach) failed", stat); <br>        SmsCloseContainer( hMGrpContainer ); <br>        return; <br>    } <br> <br> <br>    // Create machine group folder <br>    // =========================== <br>    HANDLE hMGrpFolder; <br>    stat = SmsCreateFolder( hMGrpContainer, F_MACHINEGROUP, "", &amp;hMGrpFolder ); <br>    if (stat != SMS_OK) { <br>        char szError[256]; <br>        sprintf(szError, "SmsCreateFolder failed to create MachineGroup folder"); <br>        DisplaySmsError(szError, stat); <br>        SmsCloseContainer( hMGrpContainer ); <br>        SmsCloseContainer( hMachContainer ); <br>        return; <br>    } <br> <br> <br> <br> <br>    // Select machine folders that we want tp put in to the mgrp folder. <br>    // Just get all the PC machines from the mach container for now. <br>    // Set filter for arch PC only machines. <br>    // ================================================================= <br>    setMachFilters( hConnect, hMachContainer ); <br> <br>    stat = SmsPopulate( hMachContainer, POP_SYNC, NULL ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Bad return from SmsPopulate", stat); <br>        // Close everything and return. <br>        SmsCloseContainer( hMGrpContainer ); <br>        SmsCloseContainer( hMachContainer ); <br>        SmsCloseFolder( hMGrpFolder ); <br>        return; <br>    } <br> <br> <br> <br>    // Loop getting a handle to each machine folder and <br>    // inserting it into the new mgroup folder. <br>    // ================================================ <br>    DWORD ctFolders; <br>    SmsGetFolderCount( hMachContainer, F_ANY, &amp;ctFolders ); <br>    printf("\n======== Mach Container has %d folders\n", ctFolders); <br> <br>    HANDLE hFolder; <br>    char szFolderID[100];               // This folder's ID. <br>    BOOL bValid = TRUE; <br> <br>    for (DWORD dwLoop = 0; dwLoop &lt; ctFolders; dwLoop++) { <br> <br>        SmsGetNextFolder( hMachContainer, F_ANY, &amp;hFolder ); <br> <br>        // Display message saying what we've got <br>        // ------------------------------------- <br>        stat = SmsGetFolderID( hFolder, szFolderID ); <br>        printf("[%d] Got folder: %s, about to insert in new folder\n", <br>                dwLoop+1, szFolderID); <br> <br> <br>        // Insert the machine folder into the machine group folder. <br>        // This can't do a straight swap of parents since we want to keep <br>        // the machine folder's relationship to his current parent. <br>        // What this API does therefore is to make a *copy* of the folder <br>        // and link this copy into the mach group folder (ie the mach group <br>        // folder becomes the new folder's parent). <br>        // This means that this API returns a handle to the newly-created <br>        // folder. <br>        // ================================================================ <br>        HANDLE hNewFolder; <br>        stat = SmsDupFolder( hMGrpFolder, hFolder, &amp;hNewFolder ); <br>        if (stat != SMS_OK) { <br>            printf("Failure duplicating folder %s: %d\n", szFolderID, stat); <br>            bValid = FALSE; <br>            break; <br>        } <br> <br>        // Now we need to link and commit the new machine folder to <br>        // the machine group folder. <br>        // ======================================================== <br>        stat = SmsLinkFolder( hNewFolder ); <br>        if (stat != SMS_OK) { <br>            printf("Failure linking folder %s: %d\n", szFolderID, stat); <br>            goto CLOSE; <br>        } <br> <br>        stat = SmsCommitFolder( hNewFolder ); <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_PARENT_NEEDS_COMMIT) { <br>            printf("Failure comitting folder %s: %d\n", szFolderID, stat); <br>            goto CLOSE; <br>        } <br> <br> <br> <br>        SmsCloseFolder( hFolder ); <br>        SmsCloseFolder( hNewFolder ); <br>    } <br> <br> <br>    // Set scalars for the mach group folder. <br>    // ====================================== <br>    char szBuff[99]; <br>    InputString("Give me a unique name for the mach gp", szBuff); <br>    SetScalarString( hMGrpFolder, "Name", szBuff ); <br>    SetScalarString( hMGrpFolder, "Comment", "some comment" ); <br> <br>    // Link mach grp folder into parent and commit it. <br>    // =============================================== <br>    stat = SmsLinkFolder( hMGrpFolder ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsLinkFolder failed on the mach Group folder", stat); <br>        goto CLOSE; <br>    } <br> <br>    // Write it back to data source. <br>    // ============================= <br>    stat = SmsCommitFolder( hMGrpFolder ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsCommitFolder failed on the mach Group folder", stat); <br>        goto CLOSE; <br>    } <br> <br> <br> <br>    // If we got here then all seems to be ok. <br>    // Display the mach group folder <br>    // ======================================= <br>    DisplayFolder( hMGrpFolder ); <br> <br>    // Close everything - we're done. <br>    // ============================== <br>CLOSE: <br>    SmsCloseContainer( hMGrpContainer ); <br>    SmsCloseContainer( hMachContainer ); <br>    SmsCloseFolder( hMGrpFolder ); <br> <br> <br>    printf("\n********* All done ***************\n"); <br> <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>//  We are passed in a handle to a folder. We retrieve the folder's <br>//  information, displaying scalars if any. <br>//  We then recursively examine sub-folders (after closing the <br>//  current folder). <br>// ==================================================================== <br>void DisplayFolder( HANDLE hFolder ) <br>{ <br> <br>    SMS_STATUS stat; <br>    HANDLE hSubFolder; <br>    DWORD fType;                   // type of folder we're dealing with. <br>    char szfType[30];                   // type as a string. <br>    DWORD totFolders;                   // Total number of sub-folders of <br>                                        // all types. <br>    char szFolderID[100];               // This folder's ID. <br>    DWORD ctScalars;                    // How many scalars in this folder. <br> <br>    printf("\n============================================================\n"); <br> <br>    // Get folder type and id. <br>    // ----------------------- <br>    stat = SmsGetFolderID( hFolder, szFolderID ); <br>    if (stat != SMS_OK) { <br>        if (stat == SMS_NEW_FOLDER) { <br>            strcpy(szFolderID, "**New folder**"); <br>        } else { <br>            CHKSTAT("SmsGetFolderID"); <br>        } <br>    } <br> <br>    stat = SmsGetFolderType( hFolder, &amp;fType, szfType ); <br>    CHKSTAT("SmsGetFolderType"); <br>    printf("Folder ID \"%s\" is a %s\n\n", szFolderID, szfType); <br> <br>    // How many scalars in this folder. <br>    // -------------------------------------------------------- <br>    stat = SmsGetScalarCount( hFolder, &amp;ctScalars ); <br>    CHKSTAT("SmsGetScalarCount"); <br>    printf("Contains %d scalars\n\n", ctScalars); <br>    DisplayScalars( hFolder ); <br> <br> <br>    // Get count of all sub-folders (ie of all types). <br>    // and allocate space for their handles. <br>    // ----------------------------------------------- <br>    stat = SmsGetFolderCount( hFolder, F_ANY, &amp;totFolders ); <br>    printf("Contains %d folders\n\n", totFolders); <br> <br>    char szSubFolderID[100]; <br>    DWORD ctFolders; <br>    HANDLE *phFolders; <br>    phFolders = (HANDLE *)malloc(totFolders * sizeof(HANDLE)); <br> <br> <br>    // This loop gets the sub-folder IDs and displays them. <br>    // ==================================================== <br> <br>    for (ctFolders = 0; ctFolders &lt; totFolders; ctFolders++) { <br> <br>        // Get a handle to a sub-folder. <br>        // ----------------------------- <br>        stat = SmsGetNextFolder( hFolder, F_ANY, &amp;hSubFolder ); <br>        CHKSTAT("SmsGetNextFolder"); <br>        phFolders[ctFolders] = hSubFolder; <br> <br>        // Get and display the sub-folder's ID. <br>        // ------------------------------------ <br>        stat = SmsGetFolderID( hSubFolder, szSubFolderID ); <br>        CHKSTAT("SmsGetFolderID"); <br>        printf("\tSub-folder: \"%s\"\n", szSubFolderID); <br>    } <br> <br> <br>    // ======================================================= <br>    // We can now release the handle that was passed in to us. <br>    // If we wait until the function returns then, because we <br>    // recurse, we don't release it till the very end. <br>    // ======================================================= <br>    SmsCloseFolder( hFolder ); <br> <br>    // This loop gets the sub-folders and displays them. <br>    // ================================================= <br>    for (ctFolders = 0; ctFolders &lt; totFolders; ctFolders++) { <br>        DisplayFolder( phFolders[ctFolders] ); <br>    } <br> <br>    // Free the folder handle array. <br>    // ----------------------------- <br>    free( phFolders ); <br> <br>}  /* DisplayFolder */ <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Display all the scalars for the folder. <br>// <br>// Note: the buffer for string scalars has been deliberately set to a <br>// value lower than the maximum. If we encounter a string scalar whose <br>// value exceeds this amount then we will print the 'data truncated' <br>// message. <br>// <br>// ==================================================================== <br>void DisplayScalars( HANDLE hFolder ) <br>{ <br>    SMS_STATUS stat = SMS_OK; <br>    SCALAR scalar; <br>    char szName[50];                        // Buffer for name. <br>    char szValue[SMS_DATA_BUFF_SIZE+1];     // Buffer for string value. <br>    BYTE byValue[SMS_DATA_BUFF_SIZE+1];     // Buffer for binary scalars. <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br>    scalar.pValue   = byValue; <br> <br>    char *pszTime;          // For time scalars. <br> <br> <br>    while (1) { <br> <br>        scalar.dwLen = sizeof(szValue)-1;       // must tell him the size <br> <br>        stat = SmsGetNextScalar( hFolder, &amp;scalar); <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { <br>            break; <br>        } <br> <br>        if (stat == SMS_MORE_DATA) { <br>            printf("Receive buffer too small, should be %d. Data truncated\n", <br>                            scalar.dwLen); <br>        } <br>        // Check scalar type, display accordingly. <br>        // --------------------------------------- <br>        switch (scalar.scType) { <br>        case SCALAR_STRING: <br>            printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); <br>            break; <br> <br>        case SCALAR_INT: <br>            printf("\t%30s: %ld\n", scalar.pszName, scalar.dwValue); <br>            break; <br> <br>        case SCALAR_TIME: <br>            // If there is a string equivalence use it. <br>            if (scalar.bStringEquivalence) { <br>                printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); <br>            } else { <br>                pszTime = ctime( &amp;scalar.tValue ); <br>                printf("\t%30s: %s", scalar.pszName, pszTime); <br>            } <br>            break; <br> <br>        case SCALAR_BINARY: <br>            // Got binary data. <br>            // Just tell the user how much data there is. <br>            printf("\t%30s: Binary data - %d bytes of data\n", <br>                        scalar.pszName, scalar.dwLen); <br>            break; <br>        } <br>    } <br> <br>    // Why did we exit (other than no more scalars)? <br>    // --------------------------------------------- <br>    if (stat != SMS_NO_MORE_DATA) { <br>        DisplaySmsError("Bad return from Scalar access", stat); <br>    } <br> <br>    // Terminate with newline. <br>    // ----------------------- <br>    printf("\n"); <br> <br>} <br> <br> <br> <br> <br>// ******************************************************************** <br>//      Helper functions. <br>// ******************************************************************** <br> <br> <br> <br> <br>// ==================================================================== <br>// This function sets the filters when we are looking at a Machine <br>// container. <br>// <br>// Want only PC archs, so we set an architecture filter. <br>// <br>// ==================================================================== <br>BOOL setMachFilters( HANDLE hConnect, HANDLE hContainer ) <br>{ <br>    HANDLE hFilter; <br> <br> <br>    // ========================================================= <br>    // Architecture filter. <br>    // Architecture = Personal Computer. <br>    // ========================================================= <br>    SmsCreateFilter( ARCHITECTURE_FILTER, hConnect, &amp;hFilter ); <br> <br>    TOKEN ArchToken; <br>    memset( &amp;ArchToken, 0, sizeof(TOKEN) ); <br> <br>    strcpy( ArchToken.szName, "Architecture" ); <br>    strcpy( ArchToken.szValue, "Personal Computer" ); <br>    ArchToken.dwOp = QOP_STR_EQ; <br> <br>    SmsAddToken( hFilter, OP_OR, &amp;ArchToken, 0 ); <br> <br>    SmsSetFilter( hContainer, hFilter ); <br>    SmsCloseFilter( hFilter ); <br> <br>    SmsCloseFilter( hFilter ); <br> <br>    return(TRUE); <br> <br>}  /* setMachFilters */ <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char* pszMessage <br>//          The user prompt to display. <br>// <br>//      char* pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString(const char* pszMessage, char* pszResult) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>// <br>// ==================================================================== <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXINPUT]; <br>    char szUser[CCH_MAXINPUT]; <br>    char szPasswd[CCH_MAXINPUT]; <br>    char szDatabase[CCH_MAXINPUT]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br>SMS_STATUS SetScalarString(HANDLE hFolder, char* pszName, char* pszValue) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_STRING; <br>    sc.pszValue = pszValue; <br> <br>    SMS_STATUS stat; <br>    stat = SmsSetScalar(hFolder, &amp;sc); <br>    return( stat ); <br>} <br> <br> <br> <br>/* EOF: mgrp.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
