<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVINST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5885"></a>SRVINST.CPP</h2>
<pre><code>//************************************************************************** <br>// Copyright (C) 1995 by Microsoft Corporation. <br>// <br>// This is a sample program for the SMS SDK.  It illustrates how to create <br>// a server install job and monitor its status until the job completes. <br>// <br>// This sample program also illustrates how to create a run command on <br>// workstation job. <br>// <br>// The program will request the following input: <br>// <br>// Share package on workstation job: <br>//    Package name    = User defined name of the package <br>//    Package comment = User defined text <br>//    Package location (UNC path) = The pathname to the directory where the <br>//                                  package files are located. <br>//    Package share name = The name that the package will be shared as on the <br>//                         server. <br>//    Program item description = User defined text <br>//    Program item command line = The command to execute on the server. <br>//    Program item registry name = User defined registry key for the package <br>// <br>// Run command on workstation job. <br>//    Package name = User defined name of the package <br>//    Package comment = User defined text <br>//    Package location (share name) = The pathname to the directory where the <br>//                                    client package is located. <br>//    WCL Name = User defined name for the workstation command line <br>//    WCL Command = The command line to execute. <br>// <br>// NOTE: If you choose to create a share package on server job, then you must <br>//       first share the package directory.  If you choose to create a run <br>//       command on workstation job, then you must first share the directory <br>//       where the package files are located. <br>// <br>//***************************************************************************** <br> <br> <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt; <br>#include &lt;smsinfo.h&gt; <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br>// ==================================================================== <br>//      Defines. <br>// ==================================================================== <br> <br>#define CCH_MAXSTRING   256 <br>#define CCH_MAXINPUT    256 <br>#define C_MAXSITES      256 <br> <br>#define SHARE_PERMISSIONS (PACKAGE_USER_READ | PACKAGE_USER_WRITE | PACKAGE_GUEST_READ) <br> <br> <br>extern const char *GetStatusName( SMS_STATUS stat ); <br> <br>enum {CMD_RUN_COMMAND, CMD_SHARE_PACKAGE, CMD_QUIT}; <br> <br> <br> <br> <br>// ==================================================================== <br>// TClientParams <br>// <br>// This typedef defines the parameters for the client setup <br>// job that are collected from the user. <br>// ==================================================================== <br>typedef struct <br>{ <br>    char szPackageName[CCH_MAXSTRING]; <br>    char szPackageComment[CCH_MAXSTRING]; <br>    char szPackagePath[CCH_MAXSTRING]; <br>    char szWclName[CCH_MAXSTRING]; <br>    char szWclCommand[CCH_MAXSTRING]; <br>    char szSiteName[CCH_MAXSTRING]; <br>    DWORD dwPlatforms; <br>} TClientParams; <br> <br> <br>// ==================================================================== <br>// TServerParams <br>// <br>// This typedef defines the parameters for the share package on <br>// workstation job that are collected from the user. <br>// ==================================================================== <br>typedef struct <br>{ <br>    char szPackageName[CCH_MAXSTRING]; <br>    char szPackageComment[CCH_MAXSTRING]; <br>    char szPackagePath[CCH_MAXSTRING]; <br>    char szShareName[CCH_MAXSTRING]; <br>    char szDescription[CCH_MAXSTRING]; <br>    char szCmdLine[CCH_MAXSTRING]; <br>    char szRegistryName[CCH_MAXSTRING]; <br>    char szSiteName[CCH_MAXSTRING]; <br>    DWORD dwPlatforms; <br> <br>} TServerParams; <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Local prototypes. <br>// <br>// ==================================================================== <br> <br>void DisplayHelp(); <br> <br>void DisplayGreeting(); <br> <br>BOOL DidRequestHelp( int argc, char** argv ); <br> <br>void DisplaySmsError( const char *pszMessage, SMS_STATUS stat ); <br> <br>const char *GetStatusName( SMS_STATUS stat ); <br> <br>BOOL DidRequestHelp( int argc, char** argv ); <br> <br>HANDLE ConnectToDatasource(); <br> <br>void InputString( const char *pszMessage, char *pszResult ); <br> <br>void GetSiteName( HANDLE hConnect, char *pszSiteName ); <br> <br>void ClientDoRunCommand( HANDLE hConnect, TClientParams *pcp ); <br> <br>DWORD GetPlatformSelection(); <br> <br>void ServerDoShare( HANDLE hConnect, TServerParams *psp ); <br> <br>int GetJobType(); <br> <br> <br>SMS_STATUS ClientJobCreate( HANDLE hConnect, <br>                            TClientParams *pcp, <br>                            char *pszPackageID, <br>                            char *pszWCLID ); <br> <br> <br>// ==================================================================== <br>// <br>//  The work starts here. <br>// <br>// ==================================================================== <br>void main( int argc, char **argv ) <br>{ <br> <br>    // Check to see if this is a request to display the help <br>    // screen.  If so, display it. Otherwise, display a greeting <br>    // banner. <br>    //========================================================= <br>    if (DidRequestHelp(argc, argv)) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br>    HANDLE hConnect = ConnectToDatasource(); <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br> <br>    char szSiteName[CCH_MAXSTRING]; <br>    GetSiteName(hConnect, szSiteName); <br> <br>    DWORD dwPlatforms = 0; <br>    while (dwPlatforms == 0) { <br>        dwPlatforms = GetPlatformSelection(); <br>        if (dwPlatforms == 0) { <br>            printf("Error: Invalid platform selection\n"); <br>        } <br>    } <br> <br> <br> <br> <br>    switch(GetJobType()) { <br>    case CMD_SHARE_PACKAGE: <br> <br>        printf("***************************************\n"); <br>        printf("* Share package on server job.        *\n"); <br>        printf("***************************************\n"); <br>        TServerParams sp; <br>        strcpy(sp.szSiteName, szSiteName); <br>        sp.dwPlatforms = dwPlatforms; <br>        InputString("Package name", sp.szPackageName); <br>        InputString("Package comment", sp.szPackageComment); <br>        InputString("Package directory location (UNC path)", sp.szPackagePath); <br>        InputString("Package share name", sp.szShareName); <br>        InputString("Program item description", sp.szDescription); <br>        InputString("Program item command line", sp.szCmdLine); <br>        InputString("Program item registry name", sp.szRegistryName); <br>        printf("\n"); <br> <br>        // First share the package on the server <br>        //======================================= <br>        ServerDoShare(hConnect, &amp;sp); <br> <br>        printf("**************************************************\n"); <br>        printf("* The server install job has completed.  To      *\n"); <br>        printf("* use the shared package please create a program *\n"); <br>        printf("* group in the SMS administration program and add*\n"); <br>        printf("* the package that was just shared to the group. *\n"); <br>        printf("*                                                *\n"); <br>        printf("* For more information, please refer to chapter  *\n"); <br>        printf("* nine of the SMS Administrator's guide.         *\n"); <br>        printf("**************************************************\n"); <br>        printf("\n"); <br>        break; <br> <br>    case CMD_RUN_COMMAND: <br> <br>        printf("************************************************\n"); <br>        printf("* Run command on workstation job.              *\n"); <br>        printf("************************************************\n"); <br>        TClientParams cp; <br>        strcpy(cp.szSiteName, szSiteName); <br>        cp.dwPlatforms = dwPlatforms; <br>        InputString("Package name", cp.szPackageName); <br>        InputString("Package directory location (UNC path)", cp.szPackagePath); <br>        InputString("Package comment", cp.szPackageComment); <br>        InputString("WCL Name", cp.szWclName); <br>        InputString("WCL Command", cp.szWclCommand); <br>        printf("\n"); <br> <br> <br>        // Now that we've shared the package on the server, <br>        // submit a job to setup the client program. <br>        //================================================= <br>        ClientDoRunCommand(hConnect, &amp;cp); <br>        break; <br>    default: <br>        printf("Invalid job type. No job submitted.\n"); <br>        break; <br>    } <br> <br>    if (hConnect != NULL) { <br>        SmsDataSourceDisconnect( hConnect ); <br>    } <br>} <br> <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// SetScalarString <br>// <br>// This function sets the value specified scalar to the given string <br>// value. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char *pszName <br>//          The name of the scalar. <br>//      char *pszValue <br>//          The string that will be assigned to the scalar's value. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_STRING. <br>// <br>// ==================================================================== <br>SMS_STATUS SetScalarString( HANDLE hFolder, char *pszName, char *pszValue ) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_STRING; <br>    sc.pszValue = pszValue; <br> <br>    SMS_STATUS stat; <br>    stat = SmsSetScalar(hFolder, &amp;sc); <br>    return stat; <br>} <br> <br> <br>// ==================================================================== <br>// <br>// SetScalarBool <br>// <br>// This function sets the value specified scalar to the given boolean value <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char *pszName <br>//          The name of the scalar. <br>//      BOOL bIsTrue <br>//          The boolean value to set the scalar to. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_INT. <br>// <br>// ==================================================================== <br>SMS_STATUS SetScalarBool( HANDLE hFolder, char *pszName, BOOL bIsTrue ) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_INT; <br>    sc.dwValue = bIsTrue ? 1 : 0; <br> <br> <br>    SMS_STATUS stat; <br>    stat = SmsSetScalar(hFolder, &amp;sc); <br>    return stat; <br>} <br> <br> <br>// ==================================================================== <br>// <br>// SetScalarDword <br>// <br>// This function sets the value specified scalar to the given DWORD value. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char *pszName <br>//          The name of the scalar. <br>//      DWORD dwValue <br>//          The DWORD value to set the scalar to. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_INT. <br>// <br>// ==================================================================== <br>SMS_STATUS SetScalarDword( HANDLE hFolder, char *pszName, DWORD dwValue ) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_INT; <br>    sc.dwValue = dwValue; <br> <br> <br>    SMS_STATUS stat; <br>    stat = SmsSetScalar(hFolder, &amp;sc); <br>    return stat; <br>} <br> <br> <br>// ==================================================================== <br>// <br>// SetScalarTime <br>// <br>// This function sets the value specified scalar to the given time <br>// value. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char *pszName <br>//          The name of the scalar. <br>//      time_t tValue <br>//          The time value to assign to the scalar. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_TIME. <br>// <br>// ==================================================================== <br>SMS_STATUS SetScalarTime( HANDLE hFolder, char *pszName, time_t tValue ) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_TIME; <br>    sc.tValue = tValue; <br> <br>    SMS_STATUS stat; <br>    stat = SmsSetScalar(hFolder, &amp;sc); <br>    return stat; <br>} <br> <br> <br>// ==================================================================== <br>// <br>// GetScalarString <br>// <br>// This function gets the string value of the specified scalar. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char *pszName <br>//          The name of the scalar. <br>//      char *pchBuffer <br>//          Pointer to the buffer to store the scalar's string value. <br>//      DWORD cchBuffer <br>//          The size of the buffer. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_STRING. <br>// <br>// ==================================================================== <br>SMS_STATUS GetScalarString( HANDLE hFolder, <br>                            char *pszName, <br>                            char *pchBuffer, <br>                            DWORD cchBuffer ) <br>{ <br>    SCALAR sc; <br> <br>    SMS_STATUS stat; <br>    *pchBuffer = '\0'; <br> <br>    char szNameBuffer[CCH_MAXSTRING]; <br>    sc.pszName = szNameBuffer; <br>    sc.pszValue = pchBuffer; <br>    sc.dwLen = cchBuffer; <br>    stat = SmsGetScalarByName(hFolder, pszName, &amp;sc); <br> <br>    if (stat == SMS_OK) { <br>        if (sc.scType == SCALAR_STRING) { <br>            strcpy(pchBuffer, sc.pszValue); <br>        } <br>        else { <br>            DisplaySmsError("GetScalarString: scalar is not SCALAR_STRING", SMS_OK); <br>            stat = SMS_ERROR; <br>        } <br>    } <br>    else { <br>        DisplaySmsError("GetScalarString: SmsGetScalarByName failed", stat); <br>    } <br>    return(stat); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// GetScalarDword <br>// <br>// This function gets the DWORD value of the specified scalar. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>// <br>//      char *pszName <br>//          The name of the scalar. <br>// <br>//      DWORD *pdwValue <br>//          Pointer to the place to store the scalar's DWORD value. <br>// <br>// Returns: <br>//      SMS_STATUS <br>//          The SMS status code. <br>// <br>// Note that the scalar specified must be of type SCALAR_INT. <br>// <br>// ==================================================================== <br>SMS_STATUS GetScalarDword( HANDLE hFolder, char *pszName, DWORD *pdwValue ) <br>{ <br>    SCALAR sc; <br> <br>    SMS_STATUS stat; <br>    char szNameBuffer[CCH_MAXSTRING]; <br>    sc.pszName = szNameBuffer; <br>    stat = SmsGetScalarByName(hFolder, pszName, &amp;sc); <br> <br>    if (stat == SMS_OK) { <br>        if (sc.scType == SCALAR_INT) { <br>            *pdwValue = sc.dwValue; <br>        } <br>        else { <br>            DisplaySmsError("GetScalarDword: Scalar is not SCALAR_INT", SMS_OK); <br>            stat = SMS_ERROR; <br>        } <br>    } <br>    else { <br>        DisplaySmsError("GetScalarDword: SmsGetScalarByName failed", stat); <br>    } <br>    return(stat); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// FindFolder <br>// <br>// This function searches a container for a folder with a scalar that <br>// matches the given scalar name and string scalar value. <br>// <br>// Parameters: <br>//      HANDLE hContainer <br>//          The handle of the containter to search. <br>// <br>//      char *pszName <br>//          The name of the scalar. <br>// <br>//      char *pszScalarValue <br>//          The "match" value to test for. <br>// <br>//      HFOLDER* phFolder <br>//          Pointer to the place to store the folder handle if a folder <br>//          containing the specified scalar value is found. <br>// <br>// <br>// Returns; <br>//      SMS_OK if the folder is found, SMS_NOT_FOUND otherwise. <br>//      The folder handle is returned via a pointer. <br>// <br>// ==================================================================== <br>SMS_STATUS FindFolder( HANDLE hContainer, <br>                       DWORD fType, <br>                       char *pszScalarName, <br>                       char *pszScalarValue, <br>                       HANDLE *phFolder ) <br>{ <br>    *phFolder = NULL; <br> <br>    while(TRUE) { <br>        SMS_STATUS stat; <br>        HANDLE hFolder; <br>        char szValue[CCH_MAXSTRING]; <br> <br>        stat = SmsGetNextFolder(hContainer, fType, &amp;hFolder); <br>        if (stat == SMS_NO_MORE_DATA) { <br>            return(SMS_NOT_FOUND); <br>        } <br> <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsGetNextFolder error", stat); <br>            return(SMS_NOT_FOUND); <br>        } <br> <br>        GetScalarString(hFolder, pszScalarName, szValue, sizeof(szValue)); <br>        if (!strcmp(szValue, pszScalarValue)) { <br>            *phFolder = hFolder; <br>            return(SMS_OK); <br>        } <br> <br>        SmsCloseFolder(hFolder); <br>    } <br>} <br> <br> <br>// ==================================================================== <br>// <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char *pszMessage <br>//          The user prompt to display. <br>// <br>//      char *pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString( const char *pszMessage, char *pszResult ) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>// <br>// ==================================================================== <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXINPUT]; <br>    char szUser[CCH_MAXINPUT]; <br>    char szPasswd[CCH_MAXINPUT]; <br>    char szDatabase[CCH_MAXINPUT]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>// GetPlatformSelection <br>// <br>// Prompt the user to select a one or more platforms.  The platforms <br>// are selected by entering a comma separated list of platform indexes. <br>// These platform indexes are converted to the platforms flags value <br>// for the SDK. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The SMS SDK platform flags value. <br>// <br>// ==================================================================== <br>DWORD GetPlatformSelection() <br>{ <br>    printf("**********************************************\n"); <br>    printf("* Select a platform from the following list. *\n"); <br>    printf("**********************************************\n"); <br>    printf("   1) MS-DOS \n"); <br>    printf("   2) Windows 3.1\n"); <br>    printf("   3) Windows95\n"); <br>    printf("   4) Windows NT (X86)\n"); <br>    printf("   5) Windows NT (Mips)\n"); <br>    printf("   6) Windows NT (Alpha)\n"); <br>    printf("   7) Macintosh\n"); <br>    printf("\n"); <br> <br>    DWORD dwPlatforms = 0; <br>    char szReply[CCH_MAXINPUT]; <br>    InputString("Enter a comma separated list of platform number(s)", szReply); <br>    printf("\n"); <br> <br>    const char *pszReply = szReply; <br>    while (*pszReply) { <br> <br> <br>        if (*pszReply &lt; '1' || *pszReply &gt; '6') { <br>            // An invalid character is present in the <br>            // reply.  Flag this error by returning zero. <br>            //========================================== <br>            dwPlatforms = 0; <br>            break; <br>        } <br> <br>        // Interpret the platform selector character. <br>        //=========================================== <br>        switch(*pszReply++) { <br>        case '1': <br>            dwPlatforms |= PLTFRM_MSDOS; <br>            break; <br> <br>        case '2': <br>            dwPlatforms |= PLTFRM_WIN16; <br>            break; <br> <br>        case '3': <br>            dwPlatforms |= PLTFRM_WIN95; <br>            break; <br> <br>        case '4': <br>            dwPlatforms |= PLTFRM_WIN32_X86; <br>            break; <br> <br>        case '5': <br>            dwPlatforms |= PLTFRM_WIN32_MIPS; <br>            break; <br> <br>        case '6': <br>            dwPlatforms |= PLTFRM_WIN32_ALPHA; <br>            break; <br> <br>        case '7': <br>            dwPlatforms |= PLTFRM_MACINTOSH; <br>            break; <br>        } <br> <br>        // Skip any trailing whitespace after the digit. <br>        //============================================== <br>        while(*pszReply == ' ' || *pszReply=='\t') { <br>            ++pszReply; <br>        } <br> <br>        // Skip the comma. <br>        //================ <br>        if (*pszReply == ',') { <br>            ++pszReply; <br>        } <br> <br>        // Skip white space preceding the next digit. <br>        //========================= <br>        while (*pszReply == ' ' || *pszReply=='\t') { <br>            ++pszReply; <br>        } <br> <br>    } <br> <br>    return( dwPlatforms ); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ServerWriteProgItem <br>// <br>// Set the value of the program item folder's scalars, link it into the <br>// folder hierarchy and finally insert it into the data source. <br>// <br>// Parameters: <br>//      HANDLE hFolderProgItem <br>//          The program item folder's handle. <br>// <br>//      TServerParams *psp <br>//          Pointer to the "share package on server" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>// Returns: <br>//      SMS_OK if no error occurred, otherwise the SDK status code. <br>// <br>// ==================================================================== <br>SMS_STATUS ServerWriteProgItem( HANDLE hFolderProgItem, TServerParams *psp ) <br>{ <br> <br>    SetScalarString(hFolderProgItem, "Description", psp-&gt;szDescription); <br>    SetScalarString(hFolderProgItem, "Command line", psp-&gt;szCmdLine); <br>    SetScalarDword(hFolderProgItem,  "Run minimized", 0); <br>    SetScalarDword(hFolderProgItem,  "Platforms", psp-&gt;dwPlatforms); <br>    SetScalarString(hFolderProgItem, "Configure script file", ""); <br>    SetScalarDword(hFolderProgItem,  "Search local flag", 1); <br>    SetScalarDword(hFolderProgItem,  "Drive mode", 1); <br>    SetScalarString(hFolderProgItem, "Registry name", psp-&gt;szRegistryName); <br>    SetScalarDword(hFolderProgItem,  "Executable flag", 1); <br> <br> <br> <br>    SMS_STATUS stat; <br>    stat = SmsLinkFolder(hFolderProgItem); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to link the server share program item folder into the hierarchy", stat); <br>        return( stat ); <br>    } <br> <br>    stat = SmsCommitFolder(hFolderProgItem); <br>    if ((stat != SMS_OK) &amp;&amp; (stat != SMS_PARENT_NEEDS_COMMIT)) { <br>        DisplaySmsError("Failed to insert the server share program item folder into the package", stat); <br>    } <br>    else { <br>        // If the status code was SMS_PARENT_NEEDS_COMMIT, we convert the status to <br>        // SMS_OK, since the commit was successful. <br>        //========================================================================= <br>        stat = SMS_OK; <br>    } <br> <br> <br>    // Note program item folders are not actually inserted into the <br>    // datasource until a commit is also done on the parent <br>    // package folder. <br>    //===================================================== <br>    return( stat ); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// ServerWritePkg <br>// <br>// Set the value of the package folder's scalars, link it into the <br>// folder hierarchy and finally insert it into the data source. <br>// <br>// Parameters: <br>//      HANDLE hFolderPkg <br>//          The package folder's handle. <br>// <br>//      TServerParams *psp <br>//          Pointer to the "share package on server" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>// Returns: <br>//      SMS_OK if no error occurred, otherwise the SDK status code. <br>// <br>// ==================================================================== <br>SMS_STATUS ServerWritePkg( HANDLE hFolderPkg, TServerParams *psp ) <br>{ <br>    SetScalarString(hFolderPkg, "Name", psp-&gt;szPackageName); <br>    SetScalarString(hFolderPkg, "Comment", psp-&gt;szPackageComment); <br>    SetScalarString(hFolderPkg, "Server root", psp-&gt;szPackagePath); <br>    SetScalarString(hFolderPkg, "Share name", psp-&gt;szShareName); <br>    SetScalarDword(hFolderPkg,  "Share permissions", (DWORD)SHARE_PERMISSIONS); <br> <br> <br>    SMS_STATUS stat; <br>    stat = SmsLinkFolder(hFolderPkg); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to link the server share package folder into the hierarchy", stat); <br>        return( stat ); <br>    } <br> <br> <br>    stat = SmsCommitFolder(hFolderPkg); <br>    if ((stat != SMS_OK) &amp;&amp; (stat != SMS_PARENT_NEEDS_COMMIT)) { <br>        DisplaySmsError("Failed to insert the server share package folder into the datasource", stat); <br>    } <br> <br>    return( stat ); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// ServerCreatePkg <br>// <br>// This function create the server install job package. <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      TServerParams *psp <br>//          Pointer to the "share package on server" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>//      char *pszPackageID <br>//          Pointer to the buffer where the package ID will be <br>//          returned. <br>// <br>//      DWORD cchPackageID <br>//          Size of the package ID buffer. <br>// <br>//      char *pszProgItemID <br>//          Pointer to the buffer where the program item ID will be <br>//          returned. <br>// <br>//      DWORD cchProgItemID <br>//          Size of the program item ID buffer. <br>// <br>// Returns: <br>//      SMS_OK if no error occurred, otherwise the SDK status code. <br>// <br>// ==================================================================== <br>SMS_STATUS ServerCreatePkg( HANDLE hConnect, <br>                            TServerParams *psp, <br>                            char *pszPackageID, <br>                            DWORD cchPackageID, <br>                            char *pszProgItemID, <br>                            DWORD cchProgItemID) <br>{ <br>    SMS_STATUS stat; <br>    HANDLE hContainer; <br>    HANDLE hFolderPkg = NULL; <br>    HANDLE hFolderProgItem = NULL; <br> <br>    // First open the package container.  If we fail to open it, <br>    // display an error message and give up. <br>    //========================================================= <br>    stat = SmsOpenContainer( C_PACKAGE, hConnect, &amp;hContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to open the package container", stat); <br>        return( stat ); <br>    } <br> <br>    // Now create a new package folder. <br>    //================================= <br>    stat = SmsCreateFolder( hContainer, F_PACKAGE, "Dummy", &amp;hFolderPkg ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to create server share package", stat); <br>        goto CLEANUP_AND_EXIT; <br>    } <br> <br> <br>    stat = SmsCreateFolder(hFolderPkg, F_PROGITEM, "Dummy", &amp;hFolderProgItem); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to create server share program item", stat); <br>        goto CLEANUP_AND_EXIT; <br>    } <br> <br> <br>    stat = ServerWriteProgItem(hFolderProgItem, psp); <br>    if (stat != SMS_OK) { <br>        goto CLEANUP_AND_EXIT; <br>    } <br> <br>    stat = ServerWritePkg(hFolderPkg, psp); <br>    if (stat != SMS_OK) { <br>        goto CLEANUP_AND_EXIT; <br>    } <br> <br> <br>    GetScalarString(hFolderPkg, "Key", pszPackageID, cchPackageID); <br>    GetScalarString(hFolderProgItem, "ItemKey", pszProgItemID, cchProgItemID); <br>    stat = SMS_OK; <br> <br> <br>CLEANUP_AND_EXIT: <br> <br>    if (hFolderProgItem) { <br>        SmsCloseFolder(hFolderProgItem); <br>    } <br> <br>    if (hFolderPkg) { <br>        SmsCloseFolder(hFolderPkg); <br>    } <br> <br>    SmsCloseContainer(hContainer); <br>    return( stat ); <br>} <br> <br> <br> <br>// ==================================================================== </code></pre>
<p>
</p>
<pre><code>// <br>// ServerWriteJob <br>// <br>// This function sets the values of the job folder's scalars, links the <br>// job folder into the folder hierachy, and then inserts the folder <br>// into the data source. <br>// <br>// Parameters: <br>//      HANDLE hFolderJob <br>//          The handle to the server install job folder. <br>// <br>//      TServerParams *psp <br>//          Pointer to the "share package on server" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>//      char *pszPackageID <br>//          Pointer to the server install package ID. <br>// <br>// Returns: <br>//      SMS_OK if no error occurred, otherwise the SDK status code. <br>// <br>// ==================================================================== <br>BOOL ServerWriteJob( HANDLE hFolderJob, <br>                     TServerParams *psp, <br>                     char *pszPackageID ) <br>{ <br>    // Submit the job immediately, so set the job submission time <br>    // to the current time. <br>    //=========================================================== <br>    time_t timeJob; <br>    time( &amp;timeJob ); <br> <br> <br>    SetScalarString(hFolderJob, "Job comment",      "This is an SDK sample job"); <br>    SetScalarTime(  hFolderJob, "Activate time",    timeJob); <br>    SetScalarDword( hFolderJob, "Priority",         3); <br>    SetScalarDword( hFolderJob, "Repeat mode",      1); <br>    SetScalarDword( hFolderJob, "Cancel mode",      0); <br>    SetScalarString(hFolderJob, "Package ID",       pszPackageID); <br>    SetScalarDword( hFolderJob, "PackageOverwriteFlag", 0); <br>    SetScalarDword( hFolderJob, "Job target",       WKSTAJOB_TGT_MACHPATH); <br>    SetScalarDword( hFolderJob, "Limit to sites",   JOBTGT_SITE); <br>    SetScalarDword( hFolderJob, "Include subsites", JOBTGT_INCLUDESUBSITES); <br>    SetScalarString(hFolderJob, "Site limit name",  psp-&gt;szSiteName); <br> <br>    // At this point we have a folder in memory, but it has not <br>    // been linked into the folder hierarchy yet.  We do so by <br>    // calling SmsLinkFolder. <br>    //========================================================= <br>    SMS_STATUS stat; <br>    stat = SmsLinkFolder(hFolderJob); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsLinkFolder(hFolderJob) failed", stat); <br>        return(stat); <br>    } <br> <br>    // The folder is now linked into the folder hierachy, but it <br>    // has not yet been inserted into the data source.  We do so <br>    // now by calling SmsCommitFolder. <br>    //========================================================== <br>    stat = SmsCommitFolder(hFolderJob); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to insert the job into the datasource", stat); <br>        return(stat); <br>    } <br> <br>    return( SMS_OK ); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ServerSubmitShareJob <br>// <br>// This function creates a share package on server job. <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      TServerParams *psp <br>//          Pointer to the "share package on server" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>//      char *pszPackageID <br>//          Pointer to the server install package ID. <br>// <br>//      char *pszJobID <br>//          Pointer to the buffer where the server install job ID will <br>//          be returned. <br>// <br>//      DWORD cchJobID <br>//          The size of the job ID buffer. <br>// <br>// Returns; <br>//      SMS_OK if everything was successful, otherwise the SMS SDK <br>//      status code. <br>//      The job ID is in the job name buffer. <br>// <br>// ==================================================================== <br>SMS_STATUS ServerSubmitShareJob(HANDLE hConnect, <br>                                TServerParams *psp, <br>                                char *pszPackageID, <br>                                char *pszJobID, <br>                                DWORD cchJobID) <br>{ <br>    *pszJobID = 0; <br> <br>    SMS_STATUS stat; <br>    HANDLE hContainerJob; <br>    stat = SmsOpenContainer( C_JOB, hConnect, &amp;hContainerJob ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to open job container", stat); <br>        return( stat ); <br>    } <br> <br>    HANDLE hFolderJob; <br>    stat = SmsCreateFolder( hContainerJob, F_SRVINSTALLJOB, "Dummy", &amp;hFolderJob ); <br>    if (stat == SMS_OK) { <br>        if (ServerWriteJob(hFolderJob, psp, pszPackageID) == SMS_OK) { <br> <br>            // We will need the Job ID later so that we can wait for <br>            // the job to complete before submitting the client setup <br>            // package.  We get the Job ID below. <br>            //================================================== <br>            GetScalarString(hFolderJob, "Job ID", pszJobID, cchJobID); <br>        } <br> <br> <br>        // We close the folder to avoid a memory leak. <br>        //============================================ <br>        stat = SmsCloseFolder(hFolderJob); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close job folder", stat); <br>        } <br> <br>    } <br>    else { <br>        DisplaySmsError("Failed to create the job folder", stat); <br>    } <br> <br> <br> <br>    stat = SmsCloseContainer(hContainerJob); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to close the job container", stat); <br>    } <br>    return stat; <br>} <br> <br> <br>// ==================================================================== <br>// <br>// JobStatusToString <br>// <br>// Convert the job status value to a human readable string. <br>// <br>// Parameters: <br>//      DWORD dwJobStatus <br>//          The status value from the job's "Job status" scalar. <br>// <br>//      char *pszJobStatus <br>//          Pointer to a buffer to recieve the human readable version <br>//          of the job status. <br>//          The size of the job ID buffer. <br>// <br>// Returns; <br>//      SMS_OK if everything was successful, otherwise the SMS SDK <br>//      status code. <br>// <br>// ==================================================================== <br>void JobStatusToString( DWORD dwJobStatus, char *pszJobStatus ) <br>{ <br>    char *psz; <br>    switch(dwJobStatus) { <br>    case JOBSTAT_PENDING: <br>        psz = "pending"; <br>        break; <br>    case JOBSTAT_ACTIVE: <br>        psz = "active"; <br>        break; <br>    case JOBSTAT_CANCELLED: <br>        psz = "cancelled"; <br>        break; <br>    case JOBSTAT_COMPLETE: <br>        psz = "complete"; <br>        break; <br>    case JOBSTAT_FAILED: <br>        psz = "failed"; <br>        break; <br>    case JOBSTAT_RETRYING: <br>        psz = "retrying"; <br>        break; <br>    default: <br>        sprintf(pszJobStatus, "unkown status %ld", dwJobStatus); <br>        return; <br>        break; <br>    } <br>    strcpy(pszJobStatus, psz); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>// ServerWaitJobComplete <br>// <br>// This function polls the status of the server install job and <br>// continues doing so until the job is complete.  As this is done, <br>// status given to the user as to the progress of the job. <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      char *pszJobID <br>//          Pointer to the ID string for the job to wait on. <br>// <br>// Returns: <br>//      SMS_OK if everything went ok and the job has completed, <br>//      otherwise the SDK status code. <br>// <br>// ==================================================================== <br>SMS_STATUS ServerWaitJobComplete( HANDLE hConnect, char *pszJobID ) <br>{ <br>    printf("***************************************\n"); <br>    printf("* Share package on server job.        *\n"); <br>    printf("* Waiting for job to complete.        *\n"); <br>    printf("***************************************\n"); <br> <br>    while(TRUE) { <br>        SMS_STATUS stat; <br>        HANDLE hContainerJob; <br>        stat = SmsOpenContainer( C_JOB, hConnect, &amp;hContainerJob ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to open job container while waiting for server share job", stat); <br>            return( stat ); <br>        } <br> <br>        stat = SmsPopulate(hContainerJob, POP_SYNC, NULL); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to populate job container while waiting for server share job", stat); <br>            SmsCloseContainer(hContainerJob); <br>            return(stat); <br>        } <br> <br>        HANDLE hFolderJob; <br>        stat = FindFolder(hContainerJob,  F_SRVINSTALLJOB, "Job ID", pszJobID, &amp;hFolderJob); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Server share job not found while waiting", stat); <br>            SmsCloseContainer(hContainerJob); <br>            return(stat); <br>        } <br> <br>        DWORD dwScalarValue; <br>        GetScalarDword(hFolderJob, "Job status", &amp;dwScalarValue); <br> <br>        SmsCloseFolder(hFolderJob); <br>        SmsCloseContainer(hContainerJob); <br> <br> <br>        char szJobStatus[CCH_MAXSTRING]; <br>        JobStatusToString(dwScalarValue, szJobStatus); <br> <br>        printf("Share package on server job, status = %s\n", szJobStatus); <br> <br>        if (dwScalarValue == 4) { <br>             return(SMS_OK); <br>        } <br> <br> <br> <br>        // Sleep for 10 seconds before checking the status of the server <br>        // share job again. <br>        //============================================================= <br>        Sleep(10000); <br>    } <br> <br>    // Control should never come here. So no return value is <br>    // necessary. <br>    //====================================================== <br> <br>} <br> <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ServerDoShare <br>// <br>// This function creates a server install package and then submits <br>// a share package on server job. <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      TServerParams *psp <br>//          Pointer to the "share package on server" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>// Returns: <br>//      SMS_OK if everything went ok, otherwise the SDK status code. <br>// <br>// ==================================================================== <br>void ServerDoShare( HANDLE hConnect, TServerParams *psp ) <br>{ <br>    char szPackageID[CCH_MAXSTRING]; <br>    char szProgItemID[CCH_MAXSTRING]; <br>    char szJobID[CCH_MAXSTRING]; <br>    SMS_STATUS stat; <br> <br>    stat = ServerCreatePkg(hConnect, <br>                           psp, <br>                           szPackageID, sizeof(szPackageID), <br>                           szProgItemID, sizeof(szProgItemID)); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to create server share package", stat); <br>        return; <br>    } <br> <br> <br>    // Submit the share package on server job and get the <br>    // job ID. <br>    //==================================================== <br>    stat = ServerSubmitShareJob(hConnect, <br>                    psp, <br>                    szPackageID, <br>                    szJobID, <br>                    sizeof(szJobID)); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to submit server share package", stat); <br>        return; <br>    } <br> <br> <br>    ServerWaitJobComplete(hConnect, szJobID); <br>} <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ClientWritePkg <br>// <br>// This function defines the attributes (scalar values) for the client <br>// setup package. <br>// <br>// Parameters: <br>//      HANDLE hFolderPkg <br>//          The handle to the package folder for the client setup job. <br>// <br>//      TClientParams *pcp <br>//          Pointer to the "run setup command on client" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>// Returns: <br>//      SMS_OK if everything went ok, otherwise the SDK status code. <br>// <br>// ==================================================================== <br>BOOL ClientWritePkg( HANDLE hFolderPkg, TClientParams *pcp ) <br>{ <br>    SetScalarString(hFolderPkg, "Name", pcp-&gt;szPackageName); <br>    SetScalarString(hFolderPkg, "Comment", pcp-&gt;szPackageComment); <br>    SetScalarString(hFolderPkg, "Workstation root", pcp-&gt;szPackagePath); <br>    SetScalarDword(hFolderPkg,  "Share permissions", (DWORD) SHARE_PERMISSIONS); <br> <br>    SMS_STATUS stat; <br>    stat = SmsCommitFolder(hFolderPkg); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to insert the package into the datasource", stat); <br>        return(FALSE); <br>    } <br> <br>    return(TRUE); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// ClientWriteWcl <br>// <br>// This function defines the attributes (scalar values) for the <br>// workstation command line folder that is part of the client setup <br>// package. <br>// <br>// Parameters: <br>//      HANDLE hFolderWcl <br>//          The handle to the workstation command line folder for the <br>//          client setup job. <br>// <br>//      TClientParams *pcp <br>//          Pointer to the "run setup command on client" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>// Returns: <br>//      SMS_OK if everything went ok, otherwise the SDK status code. <br>// <br>// ==================================================================== <br>BOOL ClientWriteWcl( HANDLE hFolderWCL, TClientParams *pcp ) <br>{ <br> <br>    SetScalarString(hFolderWCL, "Name",      pcp-&gt;szWclName); <br>    SetScalarString(hFolderWCL, "Command",   pcp-&gt;szWclCommand); <br>    SetScalarDword( hFolderWCL, "Flags",     0); <br>    SetScalarDword( hFolderWCL, "Platforms", pcp-&gt;dwPlatforms); <br> <br> <br>    SMS_STATUS stat; <br>    stat = SmsLinkFolder(hFolderWCL); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to link the WCL folder into the hierarchy", stat); <br>        return( FALSE ); <br>    } <br> <br>    stat = SmsCommitFolder(hFolderWCL); <br>    if ((stat != SMS_OK) &amp;&amp; (stat != SMS_PARENT_NEEDS_COMMIT)) { <br>        DisplaySmsError("Failed to insert the WCL folder into the package", stat); <br>        return( FALSE ); <br>    } <br> <br> <br> <br>    // Note WCL folders are not actually inserted into the <br>    // datasource until a commit is also done on the parent <br>    // package folder. <br>    //===================================================== <br> <br>    return( TRUE ); <br>} <br> <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ClientPkgCreate <br>// <br>// This function defines creates an SMS package for the client setup <br>// program. <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      TClientParams *pcp <br>//          Pointer to the "run setup command on client" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>//      char *pszPackageID <br>//          Pointer to the buffer where the package folder ID string <br>//          will be returned. <br>// <br>//      DWORD cchPackageID <br>//          The size of the package ID buffer. <br>// <br>//      char *pszWclID <br>//          Pointer to the buffer where the workstation command line <br>//          folder ID will be returned. <br>// <br>//      DWORD cchWclID <br>//          The size of the workstation command line ID buffer. <br>// <br>// Returns: <br>//      SMS_OK if everything went ok, otherwise the SMS SDK status <br>//      code. <br>//      The package ID and the WCL IDs are returned in their respective <br>//      buffers. <br>// <br>// ==================================================================== <br>SMS_STATUS ClientPkgCreate( HANDLE hConnect, <br>                            TClientParams *pcp, <br>                            char *pszPackageID, <br>                            DWORD cchPackageID, <br>                            char *pszWclID, <br>                            DWORD cchWclID ) <br>{ <br>    SMS_STATUS stat; <br>    HANDLE hContainer; <br> <br>    // First open the package container.  If we fail to open it, <br>    // display an error message and give up. <br>    //========================================================= <br>    stat = SmsOpenContainer( C_PACKAGE, hConnect, &amp;hContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to open the package container", stat); <br>        return( stat ); <br>    } <br> <br>    // Now create a new package folder. <br>    //================================= <br>    HANDLE hFolderPkg; <br>    stat = SmsCreateFolder( hContainer, F_PACKAGE, "Dummy", &amp;hFolderPkg ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to create package folder for setup command", stat); <br>        SmsCloseContainer(hContainer); <br>        return(stat); <br>    } <br> <br> <br>    HANDLE hFolderWCL; <br>    stat = SmsCreateFolder(hFolderPkg, F_WCL, "Dummy", &amp;hFolderWCL); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to create WCL folder for setup command", stat); <br>        SmsCloseContainer(hContainer); <br>        return(stat); <br>    } <br> <br> <br>    // At this point we have created both the WCL and the package folder <br>    // and now we define their attributes.  Note that the WCL attributes <br>    // are defined first because the call to SmsCommitFolder for the WCL <br>    // must precede the call to SmsCommitFolder for the package.  This is <br>    // because the WCL is part of the package and the package can't be <br>    // modified after a commit is done on it. <br>    //================================================================== <br>    ClientWriteWcl(hFolderWCL, pcp); <br>    ClientWritePkg(hFolderPkg, pcp); <br> <br> <br> <br>    // We now get the identification strings for the package and the WCL. <br>    // This is done here because the WCL key is not defined until the <br>    // package it is contained in has been committed. <br>    //================================================================== <br>    GetScalarString(hFolderPkg, "Key", pszPackageID, cchPackageID); <br>    GetScalarString(hFolderWCL, "Name", pszWclID, cchWclID); <br> <br>    stat = SmsCloseFolder(hFolderWCL); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to close the WCL folder", stat); <br>    } <br> <br> <br>    stat = SmsCloseFolder(hFolderPkg); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to close the package folder", stat); <br>    } <br> <br>    stat = SmsCloseContainer(hContainer); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to close the package container", stat); <br>    } <br> <br>    return( stat ); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// ClientWriteJob <br>// <br>// This function defines the values of the job folder, links the folder <br>// into the folder hierarchy, and finally inserts the folder into the <br>// datasource. <br>// <br>// Parameters: <br>//      HANDLE hFolderJob <br>//          The job folder's handle. <br>// <br>//      TClientParams *pcp <br>//          Pointer to the "run command on client" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>//      char *pszPackageID <br>//          Pointer to the package folder ID string. <br>// <br>//      char *pszWclID <br>//          Pointer to the workstation command line folder ID. <br>// <br>// Returns: <br>//   SMS_OK if everything went OK, otherwise the SMS SDK status code. <br>// <br>// ==================================================================== <br>SMS_STATUS ClientWriteJob(  HANDLE hFolderJob, <br>                            TClientParams *pcp, <br>                            char *pszPackageID, <br>                            char *pszWCLID) <br>{ <br>    // Submit the job immediately. To do this we set the job <br>    // submission time to the current time. <br>    //====================================================== <br>    time_t timeJob; <br>    time( &amp;timeJob ); <br> <br>    SetScalarString(hFolderJob, "Job comment",          "This is an SDK sample job"); <br>    SetScalarTime(  hFolderJob, "Activate time",        timeJob); <br>    SetScalarDword( hFolderJob, "Priority",             JOBPRI_LOW); <br>    SetScalarDword( hFolderJob, "Repeat mode",          JOBRPT_NEVER); <br>    SetScalarDword( hFolderJob, "Cancel mode",          JOBCANCEL_DONT_CANCEL); <br>    SetScalarString(hFolderJob, "Package ID",           pszPackageID); <br>    SetScalarString(hFolderJob, "WCL name",             pcp-&gt;szWclName); <br>    SetScalarString(hFolderJob, "Machine path",         "*|*|*"); <br>    SetScalarTime(  hFolderJob, "Offer time",           timeJob); <br>    SetScalarTime(  hFolderJob, "Mandatory time",       timeJob); <br>    SetScalarDword( hFolderJob, "Use mandatory time",   0); <br>    SetScalarDword( hFolderJob, "Force over slow link", 0); <br>    SetScalarDword( hFolderJob, "Use expire time",      0); <br>    SetScalarDword( hFolderJob, "Job target",           WKSTAJOB_TGT_MACHPATH); <br>    SetScalarDword( hFolderJob, "Limit to sites",       JOBTGT_SITE); <br>    SetScalarDword( hFolderJob, "Include subsites",     JOBTGT_INCLUDESUBSITES); <br>    SetScalarString(hFolderJob, "Site limit name",      pcp-&gt;szSiteName); <br>    SetScalarDword( hFolderJob, "Run workstation command",  TRUE); <br> <br> <br>    // At this point, the job folder exists in memory.  Now <br>    // we must insert the folder into the data source.  We do <br>    // this by calling SmsCommitFolder. <br>    //========================================================= <br>    SMS_STATUS stat; <br>    stat = SmsLinkFolder(hFolderJob); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsLinkFolder(hFolderJob) failed", stat); <br>        return(stat); <br>    } <br> <br>    stat = SmsCommitFolder(hFolderJob); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to insert the job into the datasource", stat); <br>        return(stat); <br>    } <br> <br>    return( SMS_OK ); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ClientJobCreate <br>// <br>// This function creates an SMS job to run a command on the client <br>// workstation.   The name of the network share path is passed <br>// as a parameter to the client setup program. <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      TClientParams *pcp <br>//          Pointer to the "run command on client" parameters <br>//          that the user was asked to input at the beginning of the <br>//          program. <br>// <br>//      char *pszPackageID <br>//          Pointer to the package folder ID string. <br>// <br>//      char *pszWclID <br>//          Pointer to the workstation command line folder ID. <br>// <br>// Returns: <br>//      SMS_OK if everything went OK, otherwise the SMS SDK status <br>//      code. <br>// <br>// ==================================================================== <br>SMS_STATUS ClientJobCreate( HANDLE hConnect, <br>                            TClientParams *pcp, <br>                            char *pszPackageID, <br>                            char *pszWCLID) <br>{ <br> <br>    SMS_STATUS stat; <br> <br>    HANDLE hContainerJob; <br>    stat = SmsOpenContainer( C_JOB, hConnect, &amp;hContainerJob ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to open job container", stat); <br>        return( stat ); <br>    } <br> <br>    HANDLE hFolderJob; <br>    stat = SmsCreateFolder( hContainerJob, F_INSTALLJOB, "Dummy", &amp;hFolderJob ); <br>    if (stat == SMS_OK) { <br>        ClientWriteJob(hFolderJob, pcp, pszPackageID, pszWCLID); <br> <br>        stat = SmsCloseFolder(hFolderJob); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close job folder", stat); <br>        } <br> <br>    } <br>    else { <br>        DisplaySmsError("Failed to create the job folder", stat); <br>    } <br> <br>    stat = SmsCloseContainer(hContainerJob); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to close the job container", stat); <br>    } <br>    return stat; <br>} <br> <br> <br>// ==================================================================== <br>// <br>// ClientDoRunCommand <br>// <br>// This function submits a run command on workstation job. <br>// <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      TClientParams *pcp <br>//          Pointer to the "client" parameters that the user was asked to <br>//          input at the beginning of the program. <br>// <br>// Returns:  Nothing. <br>// <br>// ==================================================================== <br>void ClientDoRunCommand( HANDLE hConnect, TClientParams *pcp ) <br>{ <br>    char szPackageID[CCH_MAXSTRING]; <br>    char szWclID[CCH_MAXSTRING]; <br> <br>    SMS_STATUS stat; <br>    stat = ClientPkgCreate(hConnect, <br>                           pcp, <br>                           szPackageID, sizeof(szPackageID), <br>                           szWclID, sizeof(szWclID)); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Could not create client package", stat); <br>        return; <br>    } <br> <br>    stat =  ClientJobCreate(hConnect, pcp, szPackageID, szWclID); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Could not create client job", stat); <br>    } <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>// GetSiteName <br>// <br>// This function query's the user to select the SMS site that will be <br>// used in this sample <br>// <br>// Parameters: <br>//      HANDLE hConnect <br>//          The datasource connection handle. <br>// <br>//      char *pszSiteName <br>//          Pointer to the buffer where the site name will be returned. <br>// <br>// Returns:  Nothing. <br>// <br>// ==================================================================== <br>void GetSiteName( HANDLE hConnect, char *pszSiteName ) <br>{ <br>    *pszSiteName = '\0'; <br> <br> <br>    HANDLE hContainerSite; <br>    SMS_STATUS stat; <br> <br>    stat = SmsOpenContainer( C_SITE, hConnect, &amp;hContainerSite ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to open site container", stat); <br>        return; <br>    } <br> <br> <br>    stat = SmsPopulate(hContainerSite, POP_SYNC, NULL); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Failed to populate site container", stat); <br>        return; <br>    } <br> <br> <br>    HANDLE ahFolderSite[C_MAXSITES]; <br>    HANDLE hFolderSite; <br>    int ctFolders = 0; <br>    int iFolder; <br> <br> <br>    // Get the folder handle for each folder in the site container.  Also <br>    // count the folders so that we know how many we have. <br>    //=================================================================== <br>    while(SmsGetNextFolder(hContainerSite, F_SITE, &amp;hFolderSite) == SMS_OK) { <br>        ahFolderSite[ctFolders] = hFolderSite; <br>        ++ctFolders; <br>    } <br> <br> <br> <br>    // Ask the user to select one of the sites.  After the user <br>    // select's a site, copy its name to pszSiteName. <br>    //========================================================= <br>    char szValue[CCH_MAXSTRING]; <br>    if (ctFolders &gt; 0) { <br>        printf("******************************************\n"); <br>        printf("* Select a site from the following list. *\n"); <br>        printf("******************************************\n"); <br>        printf("\n"); <br> <br> <br>        for(iFolder=0; iFolder &lt; ctFolders; ++iFolder) { <br>            GetScalarString(ahFolderSite[iFolder], "Site name", szValue, sizeof(szValue)); <br>            printf("[%d]. %s\n", iFolder + 1, szValue); <br>        } <br>        printf("\n"); <br> <br> <br>        InputString("Enter site number", szValue); <br>        printf("\n"); <br>        sscanf(szValue, "%d", &amp;iFolder); <br> <br>        if (iFolder &gt; 0 &amp;&amp; iFolder &lt;= ctFolders) { <br>            GetScalarString(ahFolderSite[iFolder-1], "Site name", szValue, sizeof(szValue)); <br>            strcpy(pszSiteName, szValue); <br>        } <br>    } <br> <br>    // Close all of the site folders that we opened via SmsGetNextFolder. <br>    //=================================================================== <br>    for (iFolder = 0; iFolder &lt; ctFolders; ++iFolder) { <br>        SmsCloseFolder(ahFolderSite[iFolder]); <br>    } <br> <br>} <br> <br> <br>// ==================================================================== <br>// <br>// GetJobType <br>// <br>// This function query's the user to select the type of SMS job he or <br>// she would like to create. <br>// <br>// Parameters: None. <br>// <br>// Returns.  A status code indicating the job type. <br>//      CMD_RUN_COMMAND = Run command on workstation job. <br>//      CMD_SHARE_PACKAGE = Share package on server job. <br>//      CMD_QUIT = Exit without creating a job. <br>// <br>// ==================================================================== <br>int GetJobType() <br>{ <br>    printf("***************************************\n"); <br>    printf("* Select the job type to create.      *\n"); <br>    printf("***************************************\n"); <br>    printf("1. Run command on workstation.\n"); <br>    printf("2. Share package on server.\n"); <br>    printf("3. Quit.\n"); <br>    printf("\n"); <br> <br>    char szReply[CCH_MAXSTRING]; <br>    InputString("Enter the job type", szReply); <br>    printf("\n"); <br> <br>    int iType = 0; <br>    sscanf(szReply, "%d", &amp;iType); <br>    switch(iType) { <br>    case 1: <br>        return(CMD_RUN_COMMAND); <br>    case 2: <br>        return(CMD_SHARE_PACKAGE); <br>    default: <br>        return(CMD_QUIT); <br>    } <br>} <br> <br> <br> <br> <br>// ******************************************************************** <br>//      Helper functions. <br>// ******************************************************************** <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char** argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>// ==================================================================== <br>BOOL DidRequestHelp(int argc, char** argv) <br>{ <br>    if (argc == 2  &amp;&amp; (strcmp(argv[1], "-help") == 0)) { </code></pre>
<p>
</p>
<pre><code>return(TRUE); <br>    } <br>    else { <br>        return(FALSE); <br>    } <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br>void DisplayHelp() <br>{ <br>    printf("\n\n"); <br>    printf("***********************************************************\n"); <br>    printf("* srvinst.exe:                                            *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* SMS API Example: Creation of jobs.                      *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* This sample program demonstrates how the SMS SDK can    *\n"); <br>    printf("* be used to create a \"share package on server\" job or a  *\n"); <br>    printf("* \"run command on workstation\" job.                       *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Prior to running this program, you must first share the *\n"); <br>    printf("* directory where the source files are for the package.   *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Syntax:                                                 *\n"); <br>    printf("*     srvinst.exe [-help]                                 *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Switches:                                               *\n"); <br>    printf("*     -help       Display this help message.              *\n"); <br>    printf("*                                                         *\n"); <br>    printf("***********************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>// <br>// ==================================================================== <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br>} <br> <br> <br> <br>/* EOF: srvinst.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
