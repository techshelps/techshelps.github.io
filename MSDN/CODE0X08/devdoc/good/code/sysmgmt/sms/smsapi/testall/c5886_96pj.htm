<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TESTALL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5887"></a>TESTALL.CPP</h2>
<pre><code>// ==================================================================== <br>// <br>//  File: testall.cpp <br>// <br>//  Copyright (C) 1994, 1995 by Microsoft Corporation. <br>// <br>//  Author: <br>//      Jonathan Shuval     Microsoft Corp. <br>// <br>// <br>//  This program illustrates the use of the SMS APIs to examine either <br>//  a site container, a jobs container, or a package container. The <br>//  only difference in code between them is the setting of filters. <br>// <br>//  The following APIs are used in this program: <br>// <br>//      SmsAPIVer <br>// <br>//      SmsDataSourceConnect <br>//      SmsDataSourceDisconnect <br>// <br>//      SmsOpenContainer <br>//      SmsSetFilter <br>//      SmsPopulate <br>//      SmsGetFolderCount <br>//      SmsCloseContainer <br>// <br>//      SmsCreateFilter <br>//      SmsGetToken <br>//      SmsGetTokenCount <br>//      SmsAddToken <br>//      SmsCloseFilter <br>// <br>//      SmsGetFolderID <br>//      SmsGetFolderType <br>//      SmsGetNextFolder <br>//      SmsGetScalarCount <br>//      SmsGetNextScalar <br>//      SmsCloseFolder <br>// <br>//  See the readme.txt file in this directory for more information. <br>// <br>// ==================================================================== <br> <br> <br> <br>// ==================================================================== <br>//  Includes. <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt;             // Header for the APIs. <br>#include &lt;time.h&gt;               // For converting time scalars into string. <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br> <br>// ==================================================================== <br>//  Defines. <br>// ==================================================================== <br>#define CCH_MAXINPUT 256 <br> <br> <br> <br>// ==================================================================== <br>//  Local prototypes. <br>// ==================================================================== <br> <br>// Does the real work. <br>// ------------------------------------------------------------- <br>void doTheWork( HANDLE hConnect ); <br> <br> <br>// Ask user if they want to see site, jobs or package container. <br>// ------------------------------------------------------------- <br>DWORD getDumpOption(); <br> <br> <br>// Set filters according to what container we're looking at. <br>// ------------------------------------------------------------- <br>BOOL setSiteFilters( HANDLE hConnect, HANDLE hContainer ); <br>BOOL setJobFilters( HANDLE hConnect, HANDLE hContainer ); <br>BOOL setPkgFilters( HANDLE hConnect, HANDLE hContainer ); <br> <br> <br>// Functions to display folders, scalars, and expressions. <br>// ------------------------------------------------------------- <br>void DisplayFolder( HANDLE hFolder ); <br>void DisplayScalars( HANDLE hFolder ); <br>void DisplayExpression( HANDLE hFolder ); <br> <br> <br>// Prompt the user for input and return the reply. <br>// ------------------------------------------------------------- <br>void InputString(const char* pszMessage, char* pszResult); <br> <br> <br>// Connect to the SMS datasource. <br>// ------------------------------------------------------------- <br>HANDLE ConnectToDatasource(); <br> <br> <br>// Display the help message. <br>// ------------------------------------------------------------- <br>void DisplayHelp(); <br> <br> <br>// Display the greeting. <br>// ------------------------------------------------------------- <br>void DisplayGreeting(); <br> <br> <br>// Check to see if there was a request for help <br>// on the command line. <br>// ------------------------------------------------------------- <br>BOOL DidRequestHelp(int argc, char** argv); <br> <br> <br>// Display an error message with its SMS status value. <br>// ------------------------------------------------------------- <br>void DisplaySmsError(const char* pszMessage, SMS_STATUS stat); <br> <br> <br>// Get the string equivallent for an SMS status code. <br>// ------------------------------------------------------------- <br>const char* GetStatusName(SMS_STATUS stat); <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Macros for checking status <br>// <br>// ==================================================================== <br>        // Void return <br>#define CHKSTAT(str) if (stat != SMS_OK) { \ <br>        DisplaySmsError(str, stat);         \ <br>        return; } <br> <br>        // Bool return <br>#define CHKSTAT_RTN(str) if (stat != SMS_OK) { \ <br>        DisplaySmsError(str, stat);             \ <br>        return(FALSE); } <br> <br> <br> <br>// ==================================================================== <br>// <br>//  The work starts here. <br>// <br>// ==================================================================== <br>void main(int argc, char** argv) <br>{ <br>    // Check to see if this is a request to display the help <br>    // screen.  If so, display it. Otherwise, display a greeting <br>    // banner. <br>    //========================================================= <br>    if (DidRequestHelp(argc, argv)) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br> <br> <br>    HANDLE hConnect; <br> <br>    // Get and display API version. <br>    // ---------------------------- <br>    char *pszVersion; <br>    SmsAPIVer( &amp;pszVersion ); <br>    printf("%s\n", pszVersion ); <br> <br> <br> <br>    //=========================================== <br>    // Connect to the SMS datasource. <br>    //=========================================== <br>    hConnect = ConnectToDatasource(); <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br> <br>    // This loop allows us to do the real work multiple times. <br>    // ======================================================= <br>    BOOL bDone = FALSE; <br>    char reply[10]; <br> <br>    while (!bDone) { <br> <br>        doTheWork( hConnect ); <br> <br>        printf("Restart [y/n]? "); gets(reply); <br>        bDone = (reply[0] != 'y' &amp;&amp; reply[0] != 'Y'); <br>    } <br> <br> <br>    // Disconnect from the datasource. <br>    // =============================== <br>    SmsDataSourceDisconnect( hConnect ); <br> <br> <br>}  /* main */ <br> <br> <br>// ==================================================================== <br>// <br>//  This function does whatever work is required. <br>//  In this case, it will: <br>//      - open a container <br>//      - set filters <br>//      - populate the container <br>//      - retrieve all folders from the container and store the handles <br>//      - cause these folder to be displayed. <br>// <br>// ==================================================================== <br>void doTheWork( HANDLE hConnect ) <br>{ <br>    HANDLE hContainer; <br>    SMS_STATUS stat; <br> <br>    // Ask the user if he wants a site hierarchy, jobs, or package dump. <br>    // ================================================================= <br>    DWORD cType = getDumpOption(); <br>    BOOL bRet; <br> <br>    stat = SmsOpenContainer( cType, hConnect, &amp;hContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsOpenContainer failed", stat); <br>        return; <br>    } <br> <br>    switch (cType) { <br>    case C_SITE: <br>        bRet = setSiteFilters( hConnect, hContainer ); <br>        break; <br> <br>    case C_JOB: <br>        bRet = setJobFilters( hConnect, hContainer ); <br>        break; <br> <br>    case C_PACKAGE: <br>        bRet = setPkgFilters( hConnect, hContainer ); <br>        break; <br>    } <br> <br>    if (!bRet) { <br>        printf("Failure in filters.\n"); <br>        SmsCloseContainer( hContainer ); <br>        return; <br>    } <br> <br>    // Select all objects matching filter. <br>    // ----------------------------------- <br>    stat = SmsPopulate( hContainer, POP_SYNC, NULL ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Bad return from SmsPopulate", stat); <br>        SmsCloseContainer( hContainer ); <br>        return; <br>    } <br> <br>    DWORD numFolders; <br>    SmsGetFolderCount( hContainer, F_ANY, &amp;numFolders ); <br>    printf("\n======== Container has %d folders ==========================\n\n", <br>                                numFolders); <br> <br> <br>    // For each object in the list enumerate its properties. <br>    // What I'm going to do is open all folders in a loop and <br>    // then close the container. The open container causes all <br>    // objects to be left open until the container closes. This <br>    // chews up memory big time. <br>    // ------------------------------------------------------ <br>    CObArray topFolders; <br>    HANDLE hFolder; <br> <br>    // Open all top-level folders. <br>    // =========================== <br>    while (1) { <br>        stat = SmsGetNextFolder( hContainer, F_ANY, &amp;hFolder ); <br>        if (stat != SMS_OK) { <br>            // Either error or no more objects in list. <br>            break; <br>        } <br> <br>        // Store the folder's handle for later processing. <br>        // ----------------------------------------------- <br>        topFolders.Add( (CObject *)hFolder ); <br>    } <br> <br>    printf("*** Retrieved %d folders ***\n", topFolders.GetSize()); <br>    // Check why we exited the loop. <br>    // ----------------------------- <br>    if (stat != SMS_NO_MORE_DATA) { <br>        printf("Failed to retrieve folder: %d\n", stat); <br>    } <br> <br>    // Close the container. <br>    // -------------------- <br>    SmsCloseContainer( hContainer ); <br>    printf("*** Container closed ***\n"); <br> <br> <br>    for (int iLoop = 0; iLoop &lt; topFolders.GetSize(); iLoop++) { <br> <br>        // Retrieve the handle. <br>        // -------------------- <br>        hFolder = (HANDLE)topFolders[iLoop]; <br> <br>        printf("\n*** Top folder #%d\n", iLoop); <br> <br>        // Display the folder. <br>        // ------------------- <br>        DisplayFolder( hFolder ); <br> <br>        // The folder is closed inside DisplayFolder. <br>    } <br> <br>    printf("\n********* All done ***************\n"); <br> <br>} <br> <br> <br>// ==================================================================== <br>//  We are passed in a handle to a folder. We retrieve the folder's <br>//  information, displaying scalars if any. <br>//  We then recursively examine sub-folders (after closing the <br>//  current folder). <br>// ==================================================================== <br>void DisplayFolder( HANDLE hFolder ) <br>{ <br> <br>    SMS_STATUS stat; <br>    HANDLE hSubFolder; <br>    DWORD fType;                   // type of folder we're dealing with. <br>    char szfType[30];                   // type as a string. <br>    DWORD totFolders;                   // Total number of sub-folders of <br>                                        // all types. <br>    char szFolderID[100];               // This folder's ID. <br>    DWORD ctScalars;                    // How many scalars in this folder. <br> <br>    printf("\n============================================================\n"); <br> <br>    // Get folder type and id. <br>    // ----------------------- <br>    stat = SmsGetFolderID( hFolder, szFolderID ); <br>    CHKSTAT("SmsGetFolderID"); <br> <br>    stat = SmsGetFolderType( hFolder, &amp;fType, szfType ); <br>    CHKSTAT("SmsGetFolderType"); <br>    printf("Folder ID \"%s\" is a %s\n\n", szFolderID, szfType); <br> <br>    // How many scalars in this folder. <br>    // -------------------------------------------------------- <br>    stat = SmsGetScalarCount( hFolder, &amp;ctScalars ); <br>    CHKSTAT("SmsGetScalarCount"); <br>    printf("Contains %d scalars\n\n", ctScalars); <br>    DisplayScalars( hFolder ); <br> <br> <br>    // If folder has an associated expression, display it. <br>    // --------------------------------------------------- <br>    DisplayExpression( hFolder ); <br> <br>    // Get count of all sub-folders (ie of all types). <br>    // and allocate space for their handles. <br>    // ----------------------------------------------- <br>    stat = SmsGetFolderCount( hFolder, F_ANY, &amp;totFolders ); <br>    printf("Contains %d folders\n\n", totFolders); <br> <br>    HANDLE *phFolders = (HANDLE *)malloc(totFolders * sizeof(HANDLE)); <br> <br> <br>    // This loop gets the sub-folder IDs and displays them. <br>    // ==================================================== <br>    char szSubFolderID[100]; <br>    DWORD ctFolders; <br> <br>    for (ctFolders = 0; ctFolders &lt; totFolders; ctFolders++) { <br> <br>        // Get a handle to a sub-folder. <br>        // ----------------------------- <br>        stat = SmsGetNextFolder( hFolder, F_ANY, &amp;hSubFolder ); <br>        CHKSTAT("SmsGetNextFolder"); <br>        phFolders[ctFolders] = hSubFolder; <br> <br>        // Get and display the sub-folder's ID. <br>        // ------------------------------------ <br>        stat = SmsGetFolderID( hSubFolder, szSubFolderID ); <br>        CHKSTAT("SmsGetFolderID"); <br>        printf("\tSub-folder: \"%s\"\n", szSubFolderID); <br>    } <br> <br>    // ======================================================= <br>    // We can now release the handle that was passed in to us. <br>    // If we wait until the function returns then, because we <br>    // recurse, we don't release it till the very end. <br>    // ======================================================= <br>    SmsCloseFolder( hFolder ); <br> <br>    // This loop gets the sub-folders and displays them. <br>    // ================================================= <br>    for (ctFolders = 0; ctFolders &lt; totFolders; ctFolders++) { <br>        DisplayFolder( phFolders[ctFolders] ); <br>    } <br> <br>    // Free the folder handle array. <br>    // ----------------------------- <br>    free( phFolders ); <br> <br>}  /* DisplayFolder */ <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Display all the scalars for the folder. <br>// <br>// Note: the buffer for string scalars has been deliberately set to a <br>// value lower than the maximum. If we encounter a string scalar whose <br>// value exceeds this amount then we will print the 'data truncated' <br>// message. <br>// <br>// ==================================================================== <br>void DisplayScalars( HANDLE hFolder ) <br>{ <br>    SMS_STATUS stat = SMS_OK; <br>    SCALAR scalar; <br>    char szName[50];                        // Buffer for name. <br>    char szValue[SMS_DATA_BUFF_SIZE+1];     // Buffer for string value. <br>    BYTE byValue[SMS_DATA_BUFF_SIZE+1];     // Buffer for binary scalars. <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br>    scalar.pValue   = byValue; <br> <br>    char *pszTime;          // For time scalars. <br> <br> <br>    while (1) { <br> <br>        scalar.dwLen = sizeof(szValue)-1;       // must tell him the size <br> <br>        stat = SmsGetNextScalar( hFolder, &amp;scalar); <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { <br>            break; <br>        } <br> <br>        if (stat == SMS_MORE_DATA) { <br>            printf("Receive buffer too small, should be %d. Data truncated\n", <br>                            scalar.dwLen); <br>        } <br>        // Check scalar type, display accordingly. <br>        // --------------------------------------- <br>        switch (scalar.scType) { <br>        case SCALAR_STRING: <br>            printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); <br>            break; <br> <br>        case SCALAR_INT: <br>            printf("\t%30s: %ld\n", scalar.pszName, scalar.dwValue); <br>            break; <br> <br>        case SCALAR_TIME: <br>            // If there is a string equivalence use it. <br>            if (scalar.bStringEquivalence) { <br>                printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); <br>            } else { <br>                pszTime = ctime( &amp;scalar.tValue ); <br>                printf("\t%30s: %s", scalar.pszName, pszTime); <br>            } <br>            break; <br> <br>        case SCALAR_BINARY: <br>            // Got binary data. <br>            // Just tell the user how much data there is. <br>            printf("\t%30s: Binary data - %d bytes of data\n", <br>                        scalar.pszName, scalar.dwLen); <br>            break; <br>        } <br>    } <br> <br>    // Why did we exit (other than no more scalars)? <br>    // --------------------------------------------- <br>    if (stat != SMS_NO_MORE_DATA) { <br>        DisplaySmsError("Bad return from Scalar access", stat); <br>    } <br> <br>    // Terminate with newline. <br>    // ----------------------- <br>    printf("\n"); <br> <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>// DisplayExpression -- inv pkg has an expression, display it. <br>// <br>// ==================================================================== <br>void DisplayExpression( HANDLE hFolder ) <br>{ <br>    DWORD ctTokens; <br>    SMS_STATUS stat; <br> <br>    stat = SmsGetTokenCount( hFolder, &amp;ctTokens ); <br>    if (stat != SMS_OK) { <br>        printf("Folder has no expression\n\n"); <br>        return; <br>    } <br> <br> <br>    printf("Folder has expression with %d tokens\n\n", ctTokens); <br> <br>    TOKEN Token; <br> <br>    for (DWORD dwI = 0; dwI &lt; ctTokens; dwI++) { <br>        stat = SmsGetToken( hFolder, (INT)dwI, &amp;Token ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("GetToken failed", stat); <br>            break; <br>        } <br>        // print out token <br>        CString sTokenType; <br> <br>        switch (Token.tokenType) { <br>        case TOKEN_USER: <br>            sTokenType = "User token "; <br>            break; <br> <br>        case TOKEN_OR: <br>            sTokenType = "OR token   "; <br>            break; <br> <br>        case TOKEN_AND: <br>            sTokenType = "AND token  "; <br>            break; <br> <br>        case TOKEN_OPENPAREN: <br>            sTokenType = "Open paren "; <br>            break; <br> <br>        case TOKEN_CLOSEPAREN: <br>            sTokenType = "Close paren"; <br>            break; <br> <br>        default: <br>            sTokenType = "Invalid token type!"; <br>            break; <br>        } <br> <br>        printf("[%d: %s] %s\n", dwI, <br>                (const char *)sTokenType, Token.szTokenString ); <br> <br>    } <br> <br>    // Terminate with newline. <br>    // ----------------------- <br>    printf("\n"); <br> <br>} <br> <br> <br> <br>// ******************************************************************** <br>//      Helper functions. <br>// ******************************************************************** <br> <br> <br>// ==================================================================== <br>// Ask the user if they want to look at site, jobs, pkg hierarchy. <br>// ==================================================================== <br>DWORD getDumpOption() <br>{ <br>    DWORD cType; <br>    char reply[10]; <br>    BOOL valid = FALSE; <br> <br>    while (!valid) { <br>        printf("Options: (S)ites (J)obs (P)ackages: "); <br>        gets(reply); <br> <br>        switch (reply[0]) { <br>        case 'S': case 's': <br>            cType = C_SITE; <br>            valid = TRUE; <br>            break; <br> <br>        case 'J': case 'j': <br>            cType = C_JOB; <br>            valid = TRUE; <br>            break; <br> <br>        case 'P': case 'p': <br>            cType = C_PACKAGE; <br>            valid = TRUE; <br>            break; <br> <br>        default: <br>            printf("Invalid - try again (S, J, P): "); <br>            break; <br> <br>        } <br>    } <br> <br>    return(cType); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// This function sets the filters when we are looking at a site <br>// container. <br>// <br>// This illustrates the use of the following filters: Site filter, <br>// architecture filter, machine filter, group filter. <br>// <br>// The user is given the choice of using some of these filters or not. <br>// ==================================================================== <br>BOOL setSiteFilters( HANDLE hConnect, HANDLE hContainer ) <br>{ <br>    SMS_STATUS stat; <br>    char reply[5]; <br>    HANDLE hFilter; <br> <br>    // ========================================================= <br>    // Site filter: RootSite or SiteByCode <br>    // ========================================================= <br>    TOKEN SiteToken; <br>    memset( &amp;SiteToken, 0, sizeof(TOKEN) ); <br>    stat = SmsCreateFilter( SITE_FILTER, hConnect, &amp;hFilter ); <br>    CHKSTAT_RTN("SmsCreateFilter"); <br> <br>    printf("Site filter. Rootsite or Site by code [R/S]? "); <br>    gets(reply); <br>    if (reply[0] == 'R' || reply[0] == 'r') { <br>        strcpy( SiteToken.szName, "RootSite" ); <br>        stat = SmsAddToken( hFilter, OP_OR, &amp;SiteToken, 0 ); <br>        CHKSTAT_RTN("SmsAddToken (site filter)"); <br> <br>    } else { <br>        printf("Give 3 letter site code: "); <br>        gets(reply); <br>        strcpy( SiteToken.szName, "SiteByCode" ); <br>        strcpy( SiteToken.szValue, reply ); <br>        SiteToken.dwOp = QOP_STR_EQ; <br>        stat = SmsAddToken( hFilter, OP_OR, &amp;SiteToken, 0 ); <br>        CHKSTAT_RTN("SmsAddToken (site filter)"); <br>    } <br>    stat = SmsSetFilter( hContainer, hFilter ); <br>    SmsCloseFilter( hFilter ); <br>    if (stat != SMS_OK) { <br>        printf("SmsSetFilter failed: %d\n", stat); <br>        return(FALSE); <br>    } <br> <br> <br> <br>    // ========================================================= <br>    // Architecture filter. <br>    // Must set an architecture filter else we get no machines. <br>    // Architecture = Personal Computer. <br>    // ========================================================= <br>    TOKEN ArchToken; <br>    memset( &amp;ArchToken, 0, sizeof(TOKEN) ); <br> <br>    stat = SmsCreateFilter( ARCHITECTURE_FILTER, hConnect, &amp;hFilter ); <br>    CHKSTAT_RTN("SmsCreateFilter"); <br> <br>    strcpy( ArchToken.szName, "Architecture" ); <br>    strcpy( ArchToken.szValue, "Personal Computer" ); <br>    ArchToken.dwOp = QOP_STR_EQ; <br> <br>    stat = SmsAddToken( hFilter, OP_OR, &amp;ArchToken, 0 ); <br>    CHKSTAT_RTN("SmsAddToken (architecture filter)"); <br> <br>    stat = SmsSetFilter( hContainer, hFilter ); <br>    SmsCloseFilter( hFilter ); <br> <br>    CHKSTAT_RTN("SmsSetFilter (architecture filter)"); <br> <br> <br>    // ========================================================= <br>    // Machine filter. This filter will result in only machines <br>    // with a SystemRole of Server being included in the parent <br>    // (domain) folder. <br>    // ========================================================= <br>    printf("Filter SystemRole=Server [y/n]? "); <br>    gets(reply); <br>    if (reply[0] == 'y') { <br>        TOKEN MachToken; <br>        memset( &amp;MachToken, 0, sizeof(TOKEN) ); <br>        strcpy( MachToken.szArchitecture, "Personal Computer" ); <br>        strcpy( MachToken.szGroupClass, "MICROSOFT|IDENTIFICATION|1.0" ); <br>        strcpy( MachToken.szAttributeName, "SystemRole" ); <br>        strcpy( MachToken.szValue, "Server" ); <br>        MachToken.dwOp = QOP_STR_EQ; <br> <br>        stat = SmsCreateFilter( MACHINE_FILTER, hConnect, &amp;hFilter ); <br>        CHKSTAT_RTN("SmsCreateFilter (machine filter)"); <br> <br>        stat = SmsAddToken( hFilter, OP_AND, &amp;MachToken, 0 ); <br>        CHKSTAT_RTN("SmsAddToken (machine filter)"); <br> <br>        stat = SmsSetFilter( hContainer, hFilter ); <br>        SmsCloseFilter( hFilter ); <br>        CHKSTAT_RTN("SmsSetFilter (machine filter)"); <br>    } <br> <br> <br>    // ========================================================= <br>    // Group filter. <br>    //  Only one filter of a particular type can be applied to a <br>    //  container. So we just record whether or not there is a <br>    //  group filter to be set. <br>    //  This group filter says that we only want the <br>    //  identification group for a machine. <br>    // ========================================================= <br>    BOOL bSetGroupFilter = FALSE; <br> <br>    stat = SmsCreateFilter( GROUP_FILTER, hConnect, &amp;hFilter ); <br>    CHKSTAT_RTN("SmsCreateFilter (group filter)"); <br>    TOKEN GroupToken; <br>    memset( &amp;GroupToken, 0, sizeof(TOKEN) ); <br> <br>    printf("Filter Group= MICROSOFT|IDENTIFICATION|1.0 [y/n]? "); <br>    gets(reply); <br>    if (reply[0] == 'y') { <br> <br>        // Define a (perculating) filter: Group=Ident. <br>        // ------------------------------------------------- <br>        strcpy( GroupToken.szName, "GroupClass" ); <br>        strcpy( GroupToken.szValue, "MICROSOFT|IDENTIFICATION|1.0" ); <br>        GroupToken.dwOp = QOP_STR_EQ; <br> <br>        stat = SmsAddToken( hFilter, OP_OR, &amp;GroupToken, 0 ); <br>        CHKSTAT_RTN("SmsAddToken (group filter - ID group)"); <br>        bSetGroupFilter = TRUE; <br>    } <br> <br>    // ========================================================= <br>    //  This one says that we only want the netcard <br>    //  group for a machine. <br>    // ========================================================= <br>    printf("Filter Group= MICROSOFT|NETCARD|1.0 [y/n]? "); <br>    gets(reply); <br>    if (reply[0] == 'y') { <br> <br>        // Define a (perculating) filter: Group=Netcard. <br>        // ------------------------------------------------- <br>        strcpy( GroupToken.szName, "GroupClass" ); <br>        strcpy( GroupToken.szValue, "MICROSOFT|NETCARD|1.0" ); <br>        GroupToken.dwOp = QOP_STR_EQ; <br> <br>        stat = SmsAddToken( hFilter, OP_OR, &amp;GroupToken, 0 ); <br>        CHKSTAT_RTN("SmsAddToken (group filter - Netcard group)"); <br>        bSetGroupFilter = TRUE; <br>    } <br> <br>    // Did user select a group filter? If so apply it to the container now. <br>    // ==================================================================== <br>    if (bSetGroupFilter) { <br>        stat = SmsSetFilter( hContainer, hFilter ); <br>        CHKSTAT_RTN("SmsSetFilter (group filter)"); <br>    } <br>    SmsCloseFilter( hFilter ); <br> <br>    return(TRUE); <br> <br>}  /* setSiteFilters */ <br> <br> <br> <br> <br>// ==================================================================== <br>// This function sets filters appropriate for a jobs container. <br>// It illustrates the use of jobs filters. <br>// <br>// If no job filter is selected, then all jobs will be retrieved. <br>// Currently, this will only test out the JobType tokens. <br>// The user can select one or more of the following JobType tokens in <br>// a job filter: <br>//  look at workstation install jobs <br>//  look at server share jobs <br>//  look at remove package jobs <br>//  look at system jobs (ie all the rest). <br>// <br>// NOTE: minimal error checking at the moment. <br>// <br>// ==================================================================== <br>BOOL setJobFilters( HANDLE hConnect, HANDLE hContainer ) <br>{ <br> <br>    SMS_STATUS stat = SMS_OK; <br>    HANDLE hFilter; <br>    BOOL done = FALSE; <br>    char reply[10]; <br>    BOOL bRet = TRUE; <br>    BOOL bTokenSelected = FALSE;    // Has token been added to filter? <br>    const INT iIndex = -2;          // Token index in filter. -2 means add to end. <br> <br>    printf("Select filters for jobs container.\n"); <br>    printf("Choices are: \n\tWorkstation install 'w'\n\tServer share 's'\n\tRemove package 'r'\n\tSystem 'y'\n"); <br> <br>    stat = SmsCreateFilter( JOB_FILTER, hConnect, &amp;hFilter ); <br>    CHKSTAT_RTN("SmsCreateFilter (job filter)"); <br> <br>    TOKEN JobToken; <br>    memset( &amp;JobToken, 0, sizeof(TOKEN) ); <br> <br>    while (!done) { <br>        printf("\nSelect one of [wsry] 'x' to complete: "); <br>        gets(reply); <br> <br>        switch (reply[0]) { <br>        case 'W': <br>        case 'w': <br>            // Workstation install jobs <br>            strcpy( JobToken.szName, "JobType" ); <br>            strcpy( JobToken.szValue, "Install" ); <br>            JobToken.dwOp = QOP_STR_EQ; <br>            stat = SmsAddToken( hFilter, OP_OR, &amp;JobToken, iIndex ); <br>            CHKSTAT_RTN("SmsAddToken (job filter)"); <br>            bTokenSelected = TRUE; <br>            break; <br> <br>        case 'S': <br>        case 's': <br>            // Server share jobs <br>            strcpy( JobToken.szName, "JobType" ); <br>            strcpy( JobToken.szValue, "Server" ); <br>            JobToken.dwOp = QOP_STR_EQ; <br>            stat = SmsAddToken( hFilter, OP_OR, &amp;JobToken, iIndex ); <br>            CHKSTAT_RTN("SmsAddToken (job filter)"); <br>            bTokenSelected = TRUE; <br>            break; <br> <br>        case 'R': <br>        case 'r': <br>            // Remove package jobs <br>            strcpy( JobToken.szName, "JobType" ); <br>            strcpy( JobToken.szValue, "Remove package" ); <br>            JobToken.dwOp = QOP_STR_EQ; <br>            stat = SmsAddToken( hFilter, OP_OR, &amp;JobToken, iIndex ); <br>            CHKSTAT_RTN("SmsAddToken (job filter)"); <br>            bTokenSelected = TRUE; <br>            break; <br> <br>        case 'Y': <br>        case 'y': <br>            // System jobs <br>            strcpy( JobToken.szName, "JobType" ); <br>            strcpy( JobToken.szValue, "System" ); <br>            JobToken.dwOp = QOP_STR_EQ; <br>            stat = SmsAddToken( hFilter, OP_OR, &amp;JobToken, iIndex ); <br>            CHKSTAT_RTN("SmsAddToken (job filter)"); <br>            bTokenSelected = TRUE; <br>            break; <br> <br>        case 'X': <br>        case 'x': <br>            // finished <br>            done = TRUE; <br>            break; <br> <br>        default: <br>            // give message again <br>            printf("Invalid response\n"); <br>            printf("Choices are: \n\tWorkstation install 'w'\n\tServer share 's'\n\tRemove package 'r'\n\tSystem 'y'\n"); <br>        } <br>    } <br> <br> <br>    // Only apply the filter if a token has been selected. <br>    // --------------------------------------------------- <br>    if (bTokenSelected) { <br>        stat = SmsSetFilter( hContainer, hFilter ); <br>        CHKSTAT_RTN("SmsSetFilter (job filter)"); <br>    } <br>    SmsCloseFilter( hFilter ); <br> <br> <br>    return(bRet); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// This function sets filters appropriate for a packages container. <br>// It illustrates the use of packages filters. <br>// <br>// If no package filter is selected, then all packages will be retrieved. <br>// <br>// Package filter only uses the value field, values are: <br>//  "Workstation", "Server", "Inventory" <br>// <br>// NOTE: minimal error checking at the moment. <br>// <br>// ==================================================================== <br>BOOL setPkgFilters( HANDLE hConnect, HANDLE hContainer ) <br>{ <br> <br>    SMS_STATUS stat = SMS_OK; <br>    HANDLE hFilter; <br>    BOOL done = FALSE; <br>    char reply[10]; <br>    BOOL bRet = TRUE; <br>    BOOL bTokenSelected = FALSE;    // Has token been added to filter? <br>    const INT iIndex = -2;          // Token index in filter. -2 means add to end. <br> <br>    printf("Select filters for packages container.\n"); <br>    printf("Choices are: \n\tWorkstation 'w'\n\tServer 's'\n\tInventory 'i'\n"); </code></pre>
<p>
</p>
<pre><code><br>    stat = SmsCreateFilter( PACKAGE_FILTER, hConnect, &amp;hFilter ); <br>    CHKSTAT_RTN("SmsCreateFilter (package filter)"); <br> <br>    TOKEN PkgToken; <br>    memset( &amp;PkgToken, 0, sizeof(TOKEN) ); <br> <br>    while (!done) { <br>        printf("\nSelect one of [wsi] 'x' to complete: "); <br>        gets(reply); <br> <br>        switch (reply[0]) { <br>        case 'W': case 'w': <br>            // Workstation packages <br>            strcpy( PkgToken.szName, "PackageType" ); <br>            strcpy( PkgToken.szValue, "Workstation" ); <br>            PkgToken.dwOp = QOP_STR_EQ; <br>            stat = SmsAddToken( hFilter, OP_OR, &amp;PkgToken, iIndex ); <br>            CHKSTAT_RTN("SmsAddToken (package filter)"); <br>            bTokenSelected = TRUE; <br>            break; <br> <br>        case 'S': case 's': <br>            // Server share packages <br>            strcpy( PkgToken.szName, "PackageType" ); <br>            strcpy( PkgToken.szValue, "Server" ); <br>            PkgToken.dwOp = QOP_STR_EQ; <br>            stat = SmsAddToken( hFilter, OP_OR, &amp;PkgToken, iIndex ); <br>            CHKSTAT_RTN("SmsAddToken (package filter)"); <br>            bTokenSelected = TRUE; <br>            break; <br> <br>        case 'I': case 'i': <br>            // Inventory package. <br>            strcpy( PkgToken.szName, "PackageType" ); <br>            strcpy( PkgToken.szValue, "Inventory" ); <br>            PkgToken.dwOp = QOP_STR_EQ; <br>            stat = SmsAddToken( hFilter, OP_OR, &amp;PkgToken, iIndex ); <br>            CHKSTAT_RTN("SmsAddToken (package filter)"); <br>            bTokenSelected = TRUE; <br>            break; <br> <br>        case 'X': <br>        case 'x': <br>            // finished <br>            done = TRUE; <br>            break; <br> <br>        default: <br>            // give message again <br>            printf("Invalid response\n"); <br>            printf("Choices are: \n\tWorkstation 'w'\n\tServer 's'\n\tInventory 'i'\n"); <br>        } <br>    } <br> <br> <br>    // Only apply the filter if a token has been selected. <br>    // --------------------------------------------------- <br>    if (bTokenSelected) { <br>        stat = SmsSetFilter( hContainer, hFilter ); <br>        CHKSTAT_RTN("SmsSetFilter (package filter)"); <br>    } <br> <br>    SmsCloseFilter( hFilter ); <br> <br> <br>    return(bRet); <br>} <br> <br> <br> <br>// ==================================================================== <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char* pszMessage <br>//          The user prompt to display. <br>// <br>//      char* pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString(const char* pszMessage, char* pszResult) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>// <br>// ==================================================================== <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXINPUT]; <br>    char szUser[CCH_MAXINPUT]; <br>    char szPasswd[CCH_MAXINPUT]; <br>    char szDatabase[CCH_MAXINPUT]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char** argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>// ==================================================================== <br>BOOL DidRequestHelp( int argc, char **argv ) <br>{ <br>    if (argc == 2  &amp;&amp; (strcmp(argv[1], "-help") == 0)) { <br>        return(TRUE); <br>    } <br>    else { <br>        return(FALSE); <br>    } <br>} <br> <br> <br>// ==================================================================== <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br>void DisplayHelp() <br>{ <br>    printf("\n\n"); <br>    printf("********************************************************\n"); <br>    printf("* testall.exe:                                         *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* This is a sample program for the SMS SDK. It can be  *\n"); <br>    printf("* used to view the contents of site, job, and package  *\n"); <br>    printf("* folders in the SMS database.                         *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* Syntax:                                              *\n"); <br>    printf("*     testall.exe [-help]                              *\n"); <br>    printf("*                                                      *\n"); <br>    printf("* Switches:                                            *\n"); <br>    printf("*     -help       Display this help screen.            *\n"); <br>    printf("*                                                      *\n"); <br>    printf("********************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>// ==================================================================== <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>// <br>// ==================================================================== <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br>} <br> <br> <br> <br>/* EOF: testall.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
