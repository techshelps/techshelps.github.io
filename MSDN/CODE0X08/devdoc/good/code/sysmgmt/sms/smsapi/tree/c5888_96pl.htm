<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TREE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5889"></a>TREE.CPP</h2>
<pre><code>// ==================================================================== <br>// <br>//  File: tree.cpp <br>// <br>//  Copyright (c) 1994, 1995 Microsoft Corp. <br>// <br>//  Author: <br>//      Jonathan Shuval     Microsoft Corp. <br>// <br>// <br>//  This sample builds a tree of the container/folder hierarchy and <br>//  displays it to the console. <br>// <br>//  The information that is displayed is as follows: <br>//  For each container we display the container's type and tag followed <br>//  by a list of filters (possibly empty). This lists filters that are <br>//  acted upon directly at that level. <br>//  Following the filter list is a folder list. This gives the folder's <br>//  type and tag, its filter list, and then a list of scalars for the <br>//  folder. <br>//  The scalar display shows the scalar name, it's type, and its access <br>//  mode. <br>// <br>//  See the readme.txt file in this directory for more information. <br>// <br>// ==================================================================== <br> <br> <br>// ==================================================================== <br>// <br>//      Includes <br>// <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt; <br> <br> <br>// ==================================================================== <br>// <br>//      Defines. <br>// <br>// ==================================================================== <br>#define CCH_MAXSTRING 256 <br> <br> <br>// ==================================================================== <br>// <br>//      Prototypes. <br>// <br>// ==================================================================== <br> <br>// Process a container. <br>// ------------------------------------------------------------- <br>void doContainer( FOLDER_INFO *pContainer ); <br> <br> <br>// Process a folder. <br>// ------------------------------------------------------------- <br>void doFolder( DWORD folderType, int indent, DWORD dwConType ); <br> <br> <br>// Adds a container to the container list. <br>// ------------------------------------------------------------- <br>void AddContainer( DWORD dwConType ); <br> <br> <br>// Given a filter type display its properties. <br>// ------------------------------------------------------------- <br>void doFilter( DWORD dwFilterType, int indent ); <br> <br> <br>// Locates filter of specified type from the global filter list. <br>// ------------------------------------------------------------- <br>FILTER_INFO *FindFilter( DWORD filterType ); <br> <br> <br>// Mark folder as already enumerated within this container graph. <br>// ------------------------------------------------------------- <br>void Enumerated( DWORD dwConType, DWORD folderType ); <br> <br> <br>// Call this to find out if this foldertype already been <br>// enumerated within this container graph. <br>// ------------------------------------------------------------- <br>BOOL IsEnumerated(DWORD dwConType, DWORD folderType); <br> <br> <br>// Prompt the user for input and return the reply. <br>// ------------------------------------------------------------- <br>void InputString( const char *pszMessage, char *pszResult ); <br> <br> <br>// Display the help message. <br>// ------------------------------------------------------------- <br>void DisplayHelp(); <br> <br>// Display the greeting. <br>// ------------------------------------------------------------- <br>void DisplayGreeting(); <br> <br> <br>// Check to see if there was a request for help <br>// on the command line. <br>// ------------------------------------------------------------- <br>BOOL DidRequestHelp( int argc, char **argv ); <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//      Globals. <br>// <br>// ==================================================================== <br>FOLDER_INFO **gpFolders = NULL;     // List of FOLDER_INFOs. <br>DWORD gctFolders = 0;               // Count of them. <br> <br> <br>FILTER_INFO *gpFilters = NULL;      // List of FILTER_INFOs. <br>DWORD gctFilters = 0;               // Count of them. <br> <br>// <br>// This struct is used to hold information about what folders <br>// have already been enumerated for a particular container. <br>// <br>typedef struct tagContainerEntry { <br>    DWORD dwConType;                // Container's type. <br>    CDWordArray aEnumFolders;       // Folders already enumerated. <br>} ContainerEntry; <br> <br> <br>CObArray ContainerList;             // List of containers (contains list <br>                                    // of ContainerEntry structs.) <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//      Start here. <br>// <br>// ==================================================================== <br>void main( int argc, char** argv ) <br>{ <br>    // Check to see if this is a request to display the help <br>    // screen.  If so, display it. Otherwise, display a greeting <br>    // banner. <br>    //========================================================= <br>    if (DidRequestHelp( argc, argv )) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br> <br> <br>    // Data. <br>    // ===== <br> <br>    DWORD ctContainers; <br>    FOLDER_INFO **pContainers = NULL; <br>    FOLDER_INFO *pCont = NULL; <br> <br> <br> <br> <br>    // Enumerate containers. <br>    // ===================== <br> <br>        // Get number of containers. <br>    SmsEnumContainers( NULL, &amp;ctContainers ); <br> <br>        // Allocate memory and get the containers. <br>    pContainers = new FOLDER_INFO *[ctContainers]; <br>    SmsEnumContainers( pContainers, &amp;ctContainers ); <br> <br> <br>    // Enumerate all filters. <br>    // ====================== <br>        // Get number of filters. <br>    SmsEnumFilters(NULL, &amp;gctFilters); <br> <br>        // Allocate memory and get the filters. <br>    gpFilters = new FILTER_INFO[gctFilters]; <br>    SmsEnumFilters( gpFilters, &amp;gctFilters ); <br> <br> <br>    // Enumerate all folders. <br>    // ====================== <br>        // Get number of folders. <br>    SmsEnumFolders( NULL, &amp;gctFolders ); <br> <br>        // Allocate memory and get the folders. <br>    gpFolders = new FOLDER_INFO *[gctFolders]; <br>    SmsEnumFolders( gpFolders, &amp;gctFolders ); <br> <br> <br>    // Loop through each container. <br>    // ============================ <br> <br>    for (DWORD i = 0; i &lt; ctContainers; i++) { <br> <br>        // Process the container <br>        doContainer( pContainers[i] ); <br>    } <br> <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  doContainer -- process container. <br>// <br>//  This is called from main. We print out information for this <br>//  container, and then process each folder within the container. <br>// <br>// ==================================================================== <br> <br>void doContainer( FOLDER_INFO *pContainer ) <br>{ <br>    DWORD dwI; <br> <br>    // Add this container to our container list. <br>    // ========================================= <br>    AddContainer( pContainer-&gt;dwTag ); <br> <br>    // We are now looking at the FOLDER_INFO for a container. <br>    // We want to print out the count and list of filters, <br>    // the folder type count, and then process each folder. <br>    // ====================================================== <br>    printf("Container: %s [%d]\n", pContainer-&gt;pszTag, pContainer-&gt;dwTag); <br> <br>    // Print out list of filters. <br>    // ============================= <br>    printf("%d filter(s)\n", pContainer-&gt;ctFilters); <br>    DWORD *pFilters = pContainer-&gt;pFilterTags; <br> <br>    for (dwI = 0; dwI &lt; pContainer-&gt;ctFilters; dwI++) { <br>        doFilter( pFilters[dwI], 1 ); <br>    } <br> <br> <br>    // Print out list of folders. <br>    // ========================== <br>    printf("%d folder-type(s)\n", pContainer-&gt;ctFolders); <br> <br>    DWORD *pFolderIDs = pContainer-&gt;pFolderTags; <br>    for (dwI = 0; dwI &lt; pContainer-&gt;ctFolders; dwI++) { <br> <br>        // Now cause the folder to print himself out. <br>        // ------------------------------------------ <br>        doFolder( pFolderIDs[dwI], 1, pContainer-&gt;dwTag ); <br>    } <br> <br>    // No scalars for container. <br>    // ========================= <br> <br>    printf("\n\n"); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  FindFilter -- locate filter of specified type from the list of <br>//  filter descriptors returned by the API SmsEnumFilters. <br>// <br>//  Return a pointer to the FILTER_INFO for the filter. <br>// <br>//  Called from doFilter. <br>// <br>// ==================================================================== <br> <br>FILTER_INFO *FindFilter( DWORD filterType ) <br>{ <br>    FILTER_INFO *pFI; <br>    for (DWORD dwI = 0; dwI &lt; gctFilters; dwI++) { <br>        pFI = &amp;gpFilters[dwI]; <br>        if (pFI-&gt;filterType == filterType) { <br>            return(pFI); <br>        } <br>    } <br> <br>    return(NULL); <br>} <br> <br> <br>// ==================================================================== <br>// <br>//  dumpScalar -- given a SCALAR_INFO, display the scalar. <br>// <br>//  We display the scalar's name, type, and access mode. <br>// <br>//  Params: <br>//      SCALAR_INFO                 Scalar to display. <br>//      indent                      indent level <br>// <br>// <br>// ==================================================================== <br> <br>void dumpScalar( SCALAR_INFO *pSc, int indent ) <br>{ <br>    // Indentation. <br>    // ============ <br>    char szIndent[100]; <br>    memset( szIndent, '\0', 100 ); <br>    for (int iLevel = 0; iLevel &lt; indent; iLevel++) { <br>        strcat( szIndent, "\t"); <br>    } <br> <br>    char *pszType, *pszAccess; <br> <br>    // Determine scalar type, display accordingly. <br>    // =========================================== <br>    switch (pSc-&gt;scType) { <br>    case SCALAR_STRING: <br>        pszType = "string";     break; <br> <br>    case SCALAR_INT: <br>        pszType = "integer";    break; <br> <br>    case SCALAR_TIME: <br>        pszType = "time";       break; <br> <br>    case SCALAR_BINARY: <br>        pszType = "binary";     break; <br>    } <br> <br>    // Determine access mode, display accordingly. <br>    // =========================================== <br>    switch (pSc-&gt;fAccess) { <br>    case ACCESS_READ: <br>        pszAccess = "read";     break; <br> <br>    case ACCESS_CREATE: <br>        pszAccess = "create";   break; <br> <br>    case ACCESS_MODIFY: <br>        pszAccess = "modify";   break; <br> <br>    case ACCESS_DELETE: <br>        pszAccess = "delete";   break; <br>    } <br> <br> <br>    printf("%s%s (%s, %s)\n", szIndent, pSc-&gt;szName, pszType, pszAccess); <br> <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  doScalars -- display a folder's scalar. <br>// <br>//  Loop through the list of SCALAR structures that are embedded in the <br>//  FOLDER_INFO, and display them. <br>// <br>//  The 'indent' parameter says how far to indent the resulting display <br>//  string so it looks almost presentable. <br>// <br>//  Params: <br>//      FOLDER_INFO *pFolder        The structure describing the folder <br>//                                  under consideration. <br>//      int indent                  Indent level. <br>// <br>//  Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br> <br>void doScalars( FOLDER_INFO *pFolder, int indent ) <br>{ <br>    SCALAR_INFO *pScalar; <br> <br>    for (DWORD dwI = 0; dwI &lt; pFolder-&gt;ctScalars; dwI++) { <br>        pScalar = &amp;pFolder-&gt;pScalars[dwI]; <br>        dumpScalar( pScalar, indent ); <br>    } <br>} <br> <br> <br>// ==================================================================== <br>// <br>//  doFolder -- Given a folder type print out this folder's information. <br>// <br>//  The folder has already been retrieved in SmsEnumFolders, we just <br>//  access it from there. <br>// <br>//  Params: <br>//      folderType                  Folder type we're interested in. <br>//      dwConType                   Container's type. <br>// <br>//  Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br> <br>void doFolder( DWORD folderType, int indent, DWORD dwConType ) <br>{ <br> <br>    FOLDER_INFO *pFolder; <br>    DWORD dwI; <br>    BOOL bFound = FALSE; <br> <br>    // Indentation. <br>    // ============ <br>    char szIndent[100]; <br>    memset( szIndent, '\0', 100 ); <br>    for (int iLevel = 0; iLevel &lt; indent; iLevel++) { <br>        strcat( szIndent, "\t"); <br>    } <br> <br> <br>    // Loop through the retrieved folders looking for <br>    // the one with a tag for folderType. <br>    // ============================================== <br>    for (dwI = 0; dwI &lt; gctFolders; dwI++) { <br>        pFolder = gpFolders[dwI]; <br>        if (pFolder-&gt;dwTag == folderType) { <br>            bFound = TRUE; <br>            break; <br>        } <br>    } <br> <br> <br>    if (!bFound) { <br>        printf("&lt;&lt;&lt; Error: couldn't locate folder %d &gt;&gt;&gt;\n", folderType); <br>        return; <br>    } <br> <br> <br>    // Display folder type and tag and filter count. <br>    // ============================================= <br>    printf("%s********** %s folder [%d] **********\n", <br>        szIndent,    pFolder-&gt;pszTag, pFolder-&gt;dwTag); <br> <br>    // Check to see if it's already been displayed. <br>    // We only want to do this in the context of the current container. <br>    // ---------------------------------------------------------------- <br>    if (IsEnumerated(dwConType, folderType)) { <br>        printf("%sFolder already enumerated in this container\n", szIndent); <br>        printf("%s********** End of %s folder **********\n\n", <br>                    szIndent, pFolder-&gt;pszTag ); <br>        return; <br>    } <br> <br>    printf("%s%d filter(s)\n", szIndent, pFolder-&gt;ctFilters); <br> <br>    // Print out list of filter types. <br>    // =============================== <br>    DWORD *pFilters = pFolder-&gt;pFilterTags; <br> <br>    for (dwI = 0; dwI &lt; pFolder-&gt;ctFilters; dwI++) { <br>        doFilter( pFilters[dwI], indent ); <br>    } <br> <br>    // Print out number of scalars, then display them. <br>    // =============================================== <br>    printf("%s%d scalars\n", szIndent, pFolder-&gt;ctScalars); <br>    doScalars( pFolder, indent ); <br> <br> <br>    // Prepare to display sub-folders. <br>    // =============================== <br>    printf("%s%d folder-type(s)\n", szIndent, pFolder-&gt;ctFolders); <br> <br> <br>    // Before processing sub-folder types mark this folder as already <br>    // enumerated in this container. Prevents infinite recursion. <br>    Enumerated(dwConType, folderType); <br> <br>    // Print out list of folder types. <br>    DWORD *pFolderIDs = pFolder-&gt;pFolderTags; <br>    for (dwI = 0; dwI &lt; pFolder-&gt;ctFolders; dwI++) { <br>        // Now cause the folder to print himself out. <br>        doFolder( pFolderIDs[dwI], indent+1, dwConType ); <br> <br>    } <br> <br>    printf("%s********** End of %s folder **********\n\n", <br>                szIndent, pFolder-&gt;pszTag ); <br> <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  doFilter -- given a filter type display its properties. <br>// <br>//  Called from doContainer and doFolder. <br>// <br>// ==================================================================== <br> <br>void doFilter( DWORD dwFilterType, int indent ) <br>{ <br> <br>    FILTER_INFO *pFilter = FindFilter( dwFilterType ); <br> <br>    if (!pFilter) { <br>        printf("&lt;&lt;&lt; Error: couldn't locate filter %d &gt;&gt;&gt;\n", dwFilterType); <br>        return; <br>    } <br> <br>    // Indentation. <br>    // ============ <br>    char szIndent[100]; <br>    memset( szIndent, '\0', 100 ); <br>    for (int iLevel = 0; iLevel &lt; indent; iLevel++) { <br>        strcat( szIndent, "\t"); <br>    } <br> <br>    // Display filter type and tag. <br>    // ============================ <br>    printf("%s%s (%d)\n", szIndent, pFilter-&gt;szTag, dwFilterType); <br> <br> <br>    // Display filter properties. <br>    // ========================== <br>    char *ppszField[10];            // Store pointers here. <br>    DWORD ctFields = 0;             // Number of pointers. <br> <br>    char szBuff[256];               // Build up output string here. <br>    sprintf(szBuff, "%s\t[", szIndent); // Additional level of indent. <br> <br>    if (*(pFilter-&gt;szName)) { <br>        ppszField[ctFields++] = "Token.szName = "; <br>        ppszField[ctFields++] = pFilter-&gt;szName; <br>    } <br> <br>    if (*(pFilter-&gt;szValue)) { <br>        ppszField[ctFields++] = "Token.szValue = "; <br>        ppszField[ctFields++] = pFilter-&gt;szValue; <br>    } <br> <br>    if (*(pFilter-&gt;szOperator)) { <br>        ppszField[ctFields++] = "Token.szOperator = "; <br>        ppszField[ctFields++] = pFilter-&gt;szOperator; <br>    } <br> <br>    if (*(pFilter-&gt;szArchitecture)) { <br>        ppszField[ctFields++] = "Token.szArchitecture = "; <br>        ppszField[ctFields++] = pFilter-&gt;szArchitecture; <br>    } <br> <br>    if (*(pFilter-&gt;szGroupClass)) { <br>        ppszField[ctFields++] = "Token.szGroupClass = "; <br>        ppszField[ctFields++] = pFilter-&gt;szGroupClass; <br>    } <br> <br>    if (*(pFilter-&gt;szAttributeName)) { <br>        ppszField[ctFields++] = "Token.szAttributeName = "; <br>        ppszField[ctFields++] = pFilter-&gt;szAttributeName; <br>    } <br> <br> <br>    for (DWORD dwI = 0; dwI &lt; ctFields; dwI += 2) { <br>        printf("\t%s%s\"%s\"\n", szIndent, ppszField[dwI], ppszField[dwI+1]); <br>    } <br> <br> <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  AddContainer -- adds a container to the container list. <br>// <br>// This is only for detecting folders that have already been <br>// enumerated. Nothing more. <br>// Trouble is we duplicate! <br>// <br>// ==================================================================== <br> <br>void AddContainer( DWORD dwConType ) <br>{ <br>    ContainerEntry *pCEntry; <br>    pCEntry = new ContainerEntry; <br>    pCEntry-&gt;dwConType = dwConType; <br> <br>    ContainerList.Add((CObject *)pCEntry ); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Enumerated -- Mark this folder as already enumerated within this <br>//  container graph. <br>// <br>// ==================================================================== <br> <br>void Enumerated(DWORD dwConType, DWORD folderType) <br>{ <br>    // Locate the container. <br>    BOOL bFound = FALSE; <br>    DWORD dwI;                  // loop index. <br>    ContainerEntry *pCEntry; <br> <br>    // We keep a global ContainerList (CObArray) which contains <br>    // a list of container entries (above). <br> <br>    // Locate container entry. <br>    // ======================= <br>    for (dwI = 0; dwI &lt; (DWORD)ContainerList.GetSize(); dwI++) { <br>        pCEntry = (ContainerEntry *)ContainerList[dwI]; <br>        if (pCEntry-&gt;dwConType == dwConType) { <br>            bFound = TRUE; <br>            break; <br>        } <br>    } <br> <br>    if (!bFound) { <br>        printf("&lt;&lt;&lt; Error: container tag %d not found in list &gt;&gt;&gt;\n", dwConType); <br>        return; <br>    } <br> <br>    // Add this folder to our list of enumerated folders. <br>    // ================================================== <br>    pCEntry-&gt;aEnumFolders.Add( folderType ); <br> <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  IsEnumerated -- Has this foldertype already been enumerated within <br>//  this container graph? <br>// <br>// ==================================================================== <br> <br>BOOL IsEnumerated(DWORD dwConType, DWORD folderType) <br>{ <br>    BOOL bFound = FALSE; <br>    DWORD dwI;                  // loop index. <br>    ContainerEntry *pCEntry; <br> <br>    // We keep a global ContainerList (CObArray) which contains <br>    // a list of container entries (above). <br> <br>    // Locate container entry. <br>    // ======================= <br>    for (dwI = 0; dwI &lt; (DWORD)ContainerList.GetSize(); dwI++) { <br>        pCEntry = (ContainerEntry *)ContainerList[dwI]; <br>        if (pCEntry-&gt;dwConType == dwConType) { <br>            bFound = TRUE; <br>            break; <br>        } <br>    } <br> <br>    if (!bFound) { <br>        printf("&lt;&lt;&lt; Error: container tag %d not found in list &gt;&gt;&gt;\n", dwConType); <br>        return(FALSE); <br>    } <br> <br>    // Now look through the array of enumerated folders. <br>    // ================================================= <br>    for (dwI = 0; dwI &lt; (DWORD)pCEntry-&gt;aEnumFolders.GetSize(); dwI++) { <br>        if (pCEntry-&gt;aEnumFolders[dwI] == folderType) { <br> <br>            // Found it. Folder already enumerated. <br>            // ------------------------------------ <br>            return(TRUE); <br>        } <br>    } <br> <br>    // Folder hasn't been enumerated. <br>    // ------------------------------ <br>    return(FALSE); <br>} <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char* pszMessage <br>//          The user prompt to display. <br>// <br>//      char* pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString( const char *pszMessage, char *pszResult) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char** argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>// ==================================================================== <br>BOOL DidRequestHelp(int argc, char** argv) <br>{ <br>    if (argc == 2  &amp;&amp; (strcmp(argv[1], "-help") == 0)) { <br>        return(TRUE); <br>    } <br>    else { <br>        return(FALSE); <br>    } <br>} <br> <br> <br>// ==================================================================== <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br>void DisplayHelp() <br>{ <br>    // Version information. <br>    // ==================== <br>    char *pVer; <br>    SmsAPIVer( &amp;pVer ); <br>    printf("\n%s\n\n", pVer); <br> <br> <br>    // Description. <br>    // ============ <br> <br>    printf("********************************************************************\n"); <br>    printf("* tree.exe:                                                        *\n"); <br>    printf("*                                                                  *\n"); <br>    printf("* This is a sample program for the SMS SDK.  It shows how the      *\n"); <br>    printf("* container hierarchy can be displayed.                            *\n"); <br>    printf("*                                                                  *\n"); <br>    printf("* For each container in SMS, the following details are displayed:  *\n"); <br>    printf("*     the container's tag and type                                 *\n"); <br>    printf("*     any filters that are acted upon directly by the container    *\n"); <br>    printf("*                                                                  *\n"); <br>    printf("* Following this is a display of all folders within that container.*\n"); <br>    printf("*                                                                  *\n"); <br>    printf("* For folders the following is displayed:                          *\n"); <br>    printf("*     the folder's type and tag                                    *\n"); <br>    printf("*     any filters that are acted upon by the folder                *\n"); <br>    printf("*     a list of the folder's scalars                               *\n"); <br>    printf("* Note that folder enumeration is recursive, that is, some folders *\n"); <br>    printf("* contain sub-folders.                                             *\n"); <br>    printf("*                                                                  *\n"); <br>    printf("* For filters a list of the filter's attributes are displayed.     *\n"); <br>    printf("*                                                                  *\n"); <br>    printf("* Syntax:                                                          *\n"); <br>    printf("*     tree.exe [-help]                                             *\n"); <br>    printf("*                                                                  *\n"); <br>    printf("* Switches:                                                        *\n"); <br>    printf("*     -help       Display this help screen.                        *\n"); <br>    printf("*                                                                  *\n"); <br>    printf("********************************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>// ==================================================================== <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>// <br>// ==================================================================== <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br> <br>    // Pause so the description doesn't fly off the screen. <br>    // ==================================================== <br>    char szReply[CCH_MAXSTRING]; <br>    InputString("Press ENTER to continue", szReply); <br>    printf("\n"); <br>} <br> <br> <br> <br> <br> <br> <br>/* EOF: tree.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
