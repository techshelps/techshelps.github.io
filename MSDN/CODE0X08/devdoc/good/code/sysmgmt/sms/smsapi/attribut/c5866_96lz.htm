<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ATTRIBUT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5867"></a>ATTRIBUT.CPP</h2>
<pre><code>// ==================================================================== <br>// <br>//  File: attribut.cpp <br>// <br>//  Copyright (C) 1994, 1995 Microsoft Corp. <br>// <br>//  Author: <br>//      Jonathan Shuval     Microsoft Corp. <br>// <br>//  This program illustrates possible uses of the following SMS APIs: <br>// <br>//      SmsAPIVer <br>// <br>//      SmsDataSourceConnect <br>//      SmsDataSourceDisconnect <br>// <br>//      SmsOpenContainer <br>//      SmsSetFilter <br>//      SmsPopulate <br>//      SmsGetFolderCount <br>//      SmsCloseContainer <br>//      SmsGetNextFolder <br>// <br>//      SmsCreateFilter <br>//      SmsAddToken <br>//      SmsCloseFilter <br>// <br>//      SmsGetFolderType <br>//      SmsGetFolderID <br>//      SmsCloseFolder <br>//      SmsGetScalarCount <br>//      SmsGetNextScalar <br>// <br>// <br>//  See the readme.txt file in this directory for a decription of this <br>//  sample. <br>// <br>// ==================================================================== <br>// <br> <br> <br>// ==================================================================== <br>// <br>//  Includes. <br>// <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt;             // Header for the APIs. <br>#include &lt;time.h&gt;               // For converting time scalars into strings. <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br>// ==================================================================== <br>// <br>//  Defines. <br>// <br>// ==================================================================== <br>#define CCH_MAXINPUT 256        // Length for some string buffers. <br> <br> <br>// ==================================================================== <br>// <br>//  Globals. <br>// <br>// ==================================================================== <br>HANDLE ghConnect;               // Connection handle. <br> <br> <br>// ==================================================================== <br>// <br>//  Local prototypes. <br>// <br>// ==================================================================== <br> <br> <br>// Set filters. <br>// ------------------------------------------------------------- <br>BOOL setFilters( HANDLE hContainer ); <br> <br> <br>// Displays folders (recursively). <br>// ------------------------------------------------------------- <br>void DisplayFolder( DWORD ctFolder, HANDLE hFolder ); <br> <br> <br>// Retrieves, decodes, and displays a folder's scalars. <br>// ------------------------------------------------------------- <br>void DisplayScalars( HANDLE hFolder ); <br> <br> <br>// Prompt the user for input and return the reply. <br>// ------------------------------------------------------------- <br>void InputString( const char *pszMessage, char *pszResult ); <br> <br> <br>// Connect to the SMS datasource. <br>// ------------------------------------------------------------- <br>HANDLE ConnectToDatasource(); <br> <br> <br>// Display the help message. <br>// ------------------------------------------------------------- <br>void DisplayHelp(); <br> <br> <br>// Display the greeting. <br>// ------------------------------------------------------------- <br>void DisplayGreeting(); <br> <br> <br>// Check if there was a request for help on the command line. <br>// ------------------------------------------------------------- <br>BOOL DidRequestHelp( int argc, char **argv ); <br> <br> <br>// Display an error message with its SMS status value. <br>// ------------------------------------------------------------- <br>void DisplaySmsError( const char *pszMessage, SMS_STATUS stat ); <br> <br> <br>// Get the string equivalence for an SMS status code. <br>// ------------------------------------------------------------- <br>const char *GetStatusName( SMS_STATUS stat ); <br> <br> <br> <br> <br> <br> <br>// ==================================================================== <br>//  The work starts here. <br>// ==================================================================== <br>void main( int argc, char **argv ) <br>{ <br> <br>    // Check to see if this is a request to display the help <br>    // screen. If so, display it. Otherwise, display a greeting <br>    // banner. <br>    // ========================================================= <br>    if (DidRequestHelp(argc, argv)) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br> <br>    SMS_STATUS stat;                    // Return from the APIs. <br>    HANDLE hContainer;                  // Handle to a container. <br> <br> <br>    // Get and display the SMS API version. <br>    // ------------------------------------ <br>    char *pszVersion;                   // Receives pointer to the version string. <br>    SmsAPIVer( &amp;pszVersion );           // Get version <br>    printf("Using %s\n", pszVersion);   // and print it. <br> <br> <br>    //=========================================== <br>    // Connect to the SMS datasource. <br>    //=========================================== <br>    ghConnect = ConnectToDatasource(); <br>    if (ghConnect == NULL) { <br>        return; <br>    } <br> <br> <br>    // Open the site container. <br>    // ======================== <br>    stat = SmsOpenContainer( C_SITE, ghConnect, &amp;hContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsOpenContainer failed", stat); <br>        SmsDataSourceDisconnect( ghConnect ); <br>        return; <br>    } <br> <br>    // Construct and apply filters. <br>    // ============================ <br>    BOOL bRet = setFilters( hContainer ); <br>    if (!bRet) { <br>        // Error message already displayed, but give a general one as well. <br>        printf("Problem with setting filters.\n"); <br>        SmsDataSourceDisconnect( ghConnect ); <br>        return; <br>    } <br> <br>    // Select all folders matching our filters. <br>    // ======================================== <br>    stat = SmsPopulate( hContainer, POP_SYNC, NULL ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("Bad return from SmsPopulate", stat); <br>        SmsCloseContainer( hContainer ); <br>        SmsDataSourceDisconnect( ghConnect ); <br>        return; <br>    } <br> <br>    printf("========   Enumerating site hierarchy   =============\n"); <br> <br>    // For each folder in the list enumerate its properties. <br>    // What we do is open all folders in a loop and  then <br>    // close the container. The open container causes ALL <br>    // folders to be left open until the container closes. <br>    // ----------------------------------------------------- <br>    CObArray topFolders; <br>    HANDLE hFolder; <br> <br>    // Open all top-level folders. <br>    // =========================== <br>    while ((stat = SmsGetNextFolder( hContainer, F_ANY, &amp;hFolder )) == SMS_OK) { <br> <br>        // Store the folder's handle for later processing. <br>        // ----------------------------------------------- <br>        topFolders.Add( (CObject *)hFolder ); <br>    } <br> <br>    printf("*** Retrieved %d folders ***\n", topFolders.GetSize()); <br> <br>    // Check why we exited the loop. <br>    // ----------------------------- <br>    if (stat != SMS_NO_MORE_DATA) { <br>        DisplaySmsError("Failed to retrieve folder", stat); <br>    } <br> <br>    // Close the container. <br>    // -------------------- <br>    SmsCloseContainer( hContainer ); <br> <br> <br>    // Now (recursively) process each top-level folder. <br>    // ================================================ <br>    for (int iLoop = 0; iLoop &lt; topFolders.GetSize(); iLoop++) { <br> <br>        // Retrieve the handle. <br>        // -------------------- <br>        hFolder = (HANDLE)topFolders[iLoop]; <br> <br>        printf("*** Top folder #%d\n", iLoop); <br> <br>        // Display the folder. <br>        // ------------------- <br>        DisplayFolder( iLoop, hFolder ); <br> <br>        // Note: the folder is closed inside DisplayFolder. <br>    } <br> <br>    printf("********* All done ***************\n"); <br> <br>    stat = SmsDataSourceDisconnect( ghConnect ); <br> <br> <br>}  /* main */ <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//  DisplayFolder <br>// <br>//  Display the folder's details and scalars, then recursively process <br>//  any sub-folders. <br>// <br>//  Parameters: <br>//      DWORD ctFolder <br>//          The number of sub-folders at this level of the container/folder <br>//          hierarchy. <br>// <br>//      HANDLE hFolder <br>//          The handle of the folder to display. <br>// <br>//  Returns: Nothing. <br>// <br>// ==================================================================== <br> <br>// Simple macro for checking status. <br>#define CHKSTAT(str) if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { \ <br>        printf(str); printf(": %d\n", stat); \ <br>        return; } <br> <br>void DisplayFolder( DWORD ctFolder, HANDLE hFolder ) <br>{ <br> <br>    SMS_STATUS stat; <br>    HANDLE hSubFolder; <br>    DWORD fType;                        // type of folder we're dealing with. <br>    char szfType[30];                   // type as a string. <br>    DWORD totFolders;                   // Total number of sub-folders of <br>                                        // all types. <br>    char szFolderID[100];               // This folder's ID. <br>    DWORD ctScalars;                    // How many scalars in this folder. <br> <br> <br>    // Get object type and id. <br>    // ----------------------- <br>    stat = SmsGetFolderID( hFolder, szFolderID ); <br>    CHKSTAT("SmsGetFolderID"); <br> <br>    stat = SmsGetFolderType( hFolder, &amp;fType, szfType ); <br>    CHKSTAT("SmsGetFolderType"); <br> <br>    printf("===================================================\n"); <br>    printf("[%d] Folder %s is a %s\n", ctFolder, szFolderID, szfType); <br> <br>    // How many scalars and folders in this folder. <br>    // -------------------------------------------------------- <br>    stat = SmsGetScalarCount( hFolder, &amp;ctScalars ); <br>    stat = SmsGetFolderCount( hFolder, F_ANY, &amp;totFolders ); <br>    printf("\tContains %d scalars and %d folders\n", ctScalars, totFolders); <br>    DisplayScalars( hFolder ); <br> <br> <br>    // Allocate space for sub-folder handles. <br>    // -------------------------------------- <br>    CObArray subFolders; <br>    subFolders.SetSize( totFolders ); <br> <br> <br>    // This loop gets the sub-folder IDs and displays them. <br>    // ==================================================== <br>    char szSubFolderID[100]; <br>    DWORD ctFolders; <br> <br>    for (ctFolders = 0; ctFolders &lt; totFolders; ctFolders++) { <br> <br>        // Get a handle to a sub-folder. <br>        // ----------------------------- <br>        stat = SmsGetNextFolder( hFolder, F_ANY, &amp;hSubFolder ); <br>        CHKSTAT("SmsGetNextFolder"); <br>        subFolders.SetAt( ctFolders, (CObject *)hSubFolder ); <br> <br>        // Get and display the sub-folder's ID. <br>        // ------------------------------------ <br>        stat = SmsGetFolderID( hSubFolder, (char *)szSubFolderID ); <br>        CHKSTAT("SmsGetFolderID"); <br>        printf("Sub-folder #%d: %s\n", ctFolders, szSubFolderID); <br>    } <br> <br>    // ======================================================= <br>    // We can now release the handle that was passed in to us. <br>    // If we wait until the function returns then, because we <br>    // recurse, we don't release it till the very end. <br>    // ======================================================= <br>    SmsCloseFolder( hFolder ); <br> <br> <br>    // This loop gets the sub-folders and displays them. <br>    // ================================================= <br>    for (ctFolders = 0; ctFolders &lt; totFolders; ctFolders++) { <br>        hSubFolder = (HANDLE)subFolders[ctFolders]; <br>        DisplayFolder( ctFolders, hSubFolder ); <br>    } <br> <br>    // Free the folder handle array. <br>    // ----------------------------- <br>    subFolders.RemoveAll(); <br> <br>}  /* DisplayFolder */ <br> <br> <br> <br>// ==================================================================== <br>// <br>//  DisplayScalars <br>// <br>//  Display all the scalars for the folder. <br>// <br>//  Parameters: <br>//      HANDLE hFolder <br>//          This is the folder handle. Display this folder's scalars. <br>// <br>//  Returns:  Nothing. <br>// <br>// ==================================================================== <br> <br>#define MY_BUFF_SIZE 100            // Buff size for strings and binaries. <br>// NOTE: this is deliberately set lower than the maximum (SMS_DATA_BUFF_SIZE). <br>// By doing this we can exercise the code for checking if the buffer is too <br>// small for the data (see 'Check for buffer being too small' below). <br> <br>void DisplayScalars( HANDLE hFolder ) <br>{ <br>    SMS_STATUS stat = SMS_OK; <br>    SCALAR scalar; <br>    char szName[50];                // buffer for name <br>    char szValue[MY_BUFF_SIZE];     // buffer for value <br>    BYTE byValue[MY_BUFF_SIZE];     // Buffer for binary scalars. <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br>    scalar.pValue   = byValue; <br> <br>    char *pszTime;                  // For time scalars. <br>    CTime tTime;                    //  ditto <br>    CString sTime;                  //  ditto <br> <br> <br>    while (1) { <br> <br>        scalar.dwLen = MY_BUFF_SIZE-1;       // must tell him the size <br> <br>        stat = SmsGetNextScalar( hFolder, &amp;scalar); <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { <br>            break; <br>        } <br> <br>        // Check for buffer being too small. <br>        // --------------------------------- <br>        if (stat == SMS_MORE_DATA) { <br>            printf("Receive buffer too small, should be %d. Data truncated\n", <br>                            scalar.dwLen); <br>            // NOTE: at this point we could retrieve the scalar by name <br>            // after allocating a larger buffer. <br>        } <br> <br> <br>        // Check scalar type, display accordingly. <br>        // --------------------------------------- <br>        switch (scalar.scType) { <br>        case SCALAR_STRING: <br>            printf("\t%25s (string): %s\n", scalar.pszName, scalar.pszValue); <br>            break; <br> <br>        case SCALAR_INT: <br>            printf("\t%25s (Integer): %ld\n", scalar.pszName, scalar.dwValue); <br>            break; <br> <br>        case SCALAR_TIME: <br>            // Check if we have a string equivalence. If so use it. <br>            if (scalar.bStringEquivalence) { <br>                pszTime = scalar.pszValue; <br> <br>            } else { <br>                // Use time functions to make a string out of it. <br>                // NOTE: we really need to get rid of trailing newline. <br>                tTime = scalar.tValue; <br>                sTime = tTime.Format( "%m/%d/%y %I:%M %p" ); <br>                pszTime = (char *)(const char *)sTime; <br>            } <br>            printf("\t%25s (time): %s", scalar.pszName, pszTime); <br>            break; <br> <br>        case SCALAR_BINARY: <br>            // In this sample we won't display the binary data. <br>            // Just tell the user its size. <br>            printf("\t%25s (Binary - this is its size): %ld\n", scalar.pszName, scalar.dwLen); <br>            break; <br>        } <br>    } <br> <br>    // Why did we exit (other than no more scalars)? <br>    // --------------------------------------------- <br>    if (stat != SMS_NO_MORE_DATA) { <br>        DisplaySmsError("Bad return from Scalar access: %d\n", stat); <br>    } <br> <br>    // Terminate with newline. <br>    // ----------------------- <br>    printf("\n"); <br> <br>} <br> <br> <br>// ******************************************************************** <br>//      Helper functions. <br>// ******************************************************************** <br> <br> <br>// ==================================================================== <br>// <br>// setFilters <br>// <br>// Create a new filter and apply it to the specified container. <br>// <br>// Parameters: <br>//      HANDLE hContainer <br>//          This is the handle of the container to which the filter <br>//          will be applied to. <br>// <br>// Returns: <br>//      BOOL <br>//          TRUE if no errors occcured, otherwise FALSE. <br>// <br>// ==================================================================== <br> <br> <br>#define CHECK(str) if (stat != SMS_OK) {       \ <br>        DisplaySmsError(str, stat);            \ <br>        return(FALSE);                         \ <br>    } <br> <br> <br>BOOL setFilters( HANDLE hContainer ) <br>{ <br> <br>    printf("This test will set the following filters:\n"); <br>    printf("        Site filter: RootSite\n"); <br>    printf("Architecture filter: Personal Computer\n"); <br>    printf("   Attribute filter: (MS|ID|1.0) Name\n"); <br>    printf("                   : (MS|ID|1.0) SMSLocation\n"); <br>    printf("                   : (MS|ID|1.0) NetCardID\n"); <br> <br>    SMS_STATUS stat; <br>    HANDLE hFilter; <br>    TOKEN Token; <br> <br>    // Define a filter: root site. <br>    // ---------------------------------- <br>    memset( &amp;Token, 0, sizeof(TOKEN) );             // Clear it. <br>    stat = SmsCreateFilter( SITE_FILTER, ghConnect, &amp;hFilter ); <br>    strcpy( Token.szName, "RootSite" ); <br>    stat = SmsAddToken( hFilter, OP_OR, &amp;Token, -2 ); <br>    CHECK("SmsAddToken (site)"); <br> <br>    stat = SmsSetFilter( hContainer, hFilter ); <br>    SmsCloseFilter( hFilter ); <br>    CHECK("SmsSetFilter (site)"); <br> <br> <br> <br>    // ========================================================= <br>    // Must set an architecture filter else we get no machines. <br>    // ========================================================= <br>    memset( &amp;Token, 0, sizeof(TOKEN) );             // Clear it. <br>    stat = SmsCreateFilter( ARCHITECTURE_FILTER, ghConnect, &amp;hFilter ); <br>    strcpy( Token.szName, "Architecture" ); <br>    strcpy( Token.szValue, "Personal Computer" ); <br>    Token.dwOp = QOP_STR_EQ; <br>    stat = SmsAddToken( hFilter, OP_OR, &amp;Token, -2 ); <br>    CHECK("SmsAddToken (architecture)"); <br>    stat = SmsSetFilter( hContainer, hFilter ); <br>    SmsCloseFilter( hFilter ); <br>    CHECK("SmsSetFilter (architecture)"); <br> <br> <br>    // ========================================================= <br>    // Attribute filter (MICROSOFT|IDENTIFICATION|1.0) <br>    // Three tokens: <br>    //  Name <br>    //  SMSLocation <br>    //  NetCardID <br>    // ========================================================= <br>    memset( &amp;Token, 0, sizeof(TOKEN) );             // Clear it. <br>    stat = SmsCreateFilter( ATTRIBUTE_FILTER, ghConnect, &amp;hFilter ); <br> <br>    strcpy( Token.szArchitecture, "Personal Computer" ); <br>    strcpy( Token.szGroupClass, "MICROSOFT|IDENTIFICATION|1.0" ); <br>    strcpy( Token.szAttributeName, "Name" ); <br>    stat = SmsAddToken( hFilter, OP_OR, &amp;Token, -2 ); <br>    CHECK("SmsAddToken (attribute:name)"); <br> <br>    strcpy( Token.szAttributeName, "SMSLocation" ); <br>    stat = SmsAddToken( hFilter, OP_OR, &amp;Token, -2 ); <br>    CHECK("SmsAddToken (attribute:Location)"); <br> <br>    strcpy( Token.szAttributeName, "NetCardID" ); <br>    stat = SmsAddToken( hFilter, OP_OR, &amp;Token, -2 ); <br>    CHECK("SmsAddToken (attribute:NetCardID)"); <br> <br>    stat = SmsSetFilter( hContainer, hFilter ); <br>    SmsCloseFilter( hFilter ); <br>    CHECK("SmsSetFilter (attribute)"); <br> <br> <br>    return( TRUE ); <br> <br>}  /* setFilters */ <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char *pszMessage <br>//          The user prompt to display. <br>// <br>//      char *pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString( const char *pszMessage, char *pszResult ) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>// <br>// ==================================================================== <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXINPUT]; <br>    char szUser[CCH_MAXINPUT]; <br>    char szPasswd[CCH_MAXINPUT]; <br>    char szDatabase[CCH_MAXINPUT]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char **argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>// ==================================================================== <br>BOOL DidRequestHelp( int argc, char **argv ) <br>{ <br>    if (argc == 2  &amp;&amp; (strcmp(argv[1], "-help") == 0)) { <br>        return( TRUE ); <br>    } <br>    else { <br>        return( FALSE ); <br>    } <br> <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br>void DisplayHelp() <br>{ <br>    printf("\n\n"); <br>    printf("***********************************************************\n"); <br>    printf("* attribut.exe:                                           *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* SMS API Example: Test attribute filters.                *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* This sample illustrates the use of the Attribute filter *\n"); <br>    printf("* that is applied to a site container in order to         *\n"); <br>    printf("* enumerate specified properties of a machine             *\n"); <br>    printf("* (architecture Personal Computer).                       *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Applying an attribute filter in order to enumerate      *\n"); <br>    printf("* machines is considerably faster than setting group      *\n"); <br>    printf("* filters and then retrieving specified machine group     *\n"); <br>    printf("* scalars (machine properties).                           *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Syntax:                                                 *\n"); <br>    printf("*     attribut.exe [-help]                                *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Switches:                                               *\n"); <br>    printf("*     -help       Display this help message.              *\n"); <br>    printf("*                                                         *\n"); <br>    printf("***********************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>// <br>// ==================================================================== <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br>} <br> <br> <br> <br>/* EOF: attribut.cpp */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
