<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5874"></a>README.TXT</h2>
<pre><code>SMS API Example: object enumeration. (enumobj.exe) <br>    ================================================== <br> <br>This sample illustrates the use of the SMS object enumeration APIs. <br>The objects involved here are currently Architectures and Platforms, <br>and their descendent objects. <br> <br>The API draws a distinction between 'first-class' and 'secondary objects. <br>A 'first-class' object is one that can be described by SMS without any <br>prior knowledge. The first-class objects that are known to the system <br>is returned by calling SmsEnumObjectTypes. Calling this will currently <br>result in two object-types being returned: Architectures and Platforms. <br>In order to determine what Architectures exist the user then calls <br>SmsEnumObjects, passing "Architectures" as the types of object that we <br>are interested in. What is returned from this call depends on the <br>individual database. The set of architectures will certainly include: <br>        Personal Computer <br>        SMSEvents <br>        SNMP Traps      (SMS 1.2 and above) <br>        PackageLocation <br>        UserGroups <br>        etc. <br>These are all secondary objects whose type is "Architecture". <br> <br>It is now possible to determine what objects each of these contain. <br>For instance, every object of type 'Architecture' will contain one or <br>more object of type 'Group', such as "MICROSOFT|IDENTIFICATION|1.0". <br>Note that it is impossible to determine what groups exist without first <br>knowing what architecture the user is interested in. Similarly, while a <br>Group object contains Attribute objects, it is impossible to know what <br>Attributes exist without knowing what group we are talking about. <br>This is why the SmsEnumObjects API has the notion of a predecessor list. <br> <br>The data type used by the API to describe an object that it returns <br>is known as OBJDESCRIPTOR. Looking at the definition for this data type <br>(see smsapi.h) we see that there are the following fields: <br>         <br>    DWORD objType                Type of this object. <br> <br>    SMSBUFF szName               Object name (eg 'Personal Computer') <br> <br>    SMSBUFF szFriendlyName       Friendly name. Only used in groups <br>                                 where szName would be, eg, <br>                                 'MICROSOFT|IDENTIFICATION|1.0', the <br>                                 friendly name would be 'Identification'. <br> <br>    BOOL bGotFriendlyName        TRUE if we have a friendly name. <br> <br>    DWORD dwRelopMin             For attributes, indicates range of <br>    DWORD dwRelopMax             relational operators that can be used <br>                                 for this attribute. <br> <br>    BOOL bGotRelops              TRUE if we have the relops fields set. <br> <br> <br>The 'objType' parameter is one of the set of OT_ defines (also in smsapi.h). <br>This tells the user what type of object is described by this OBJDESCRIPTOR. <br> <br>'szName' provides the name for this object (eg 'Personal Computer', 'SMSID'). <br> <br>'szFriendlyName' if this is not null then it gives a user-friendly name for <br>the object (see above). This is only used in the case of Group objects, but <br>the 'bGotFriendlyName' datum will indicate whether this field is present <br>or not. <br> <br>'dwRelopMin' and 'dwRelopMax' are used by attributes. They inform the caller <br>what the range of operators are for the attribute in question. 'bGotRelops' <br>is TRUE if these fields are present. <br>The values of these relational operators is from the file qrycodes.h. <br> <br> <br>Note that this example operates in a recursive manner in order to enumerate <br>all objects that are known to the API set. <br>A different use would of the APIs would be something like: given a specific <br>architecture and a specific group, what attributes exist. Code for this would <br>be something like: <br>        (where Architecture is Personal Computer, and Group is MICROSOFT| <br>         VIDEO|1.0) <br> <br> <br>    SMSBUFF aPreds[10]; <br>    strcpy( aPreds[0], "Architectures" ); <br>    strcpy( aPreds[1], "MICROSOFT|VIDEO|1.0 ); <br>    strcpy( aPreds[2], "MICROSOFT|VIDEO|1.0 ); <br> <br>    SmsEnumObjects( hConnect,   // Handle to datasource connection. <br>                    pszObj,     // Attribute. <br>                    pPreds,     // see above. <br>                    ctPreds,    // 3: Architectures, PC, MS|VIDEO|1.0 <br>                    Objects,    // filled in by API. <br>                    &amp;ctObjs );  // filled in by API. <br> <br>This would return, in 'Objects', all attributes for the video group.     <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
