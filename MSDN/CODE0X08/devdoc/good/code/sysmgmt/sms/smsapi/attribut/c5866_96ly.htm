<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5866"></a>README.TXT</h2>
<pre><code>SMS API Example: attribute filters. (attribut.exe) <br>    ================================================== <br> <br>This sample illustrates the use of the Attribute filter that is <br>applied to a site container in order to enumerate specified <br>properties of a machine (architecture: Personal Computer). <br> <br>Applying an attribute filter in order to enumerate machines is <br>faster than setting group filters and then retrieving specified <br>machine group scalars (machine properties). This is due to the <br>nature of the SQL operations that have to be performed. <br>This filter is also useful in the respect that only the information <br>that is requested will be returned. <br> <br>This program opens a site container, constructs and applies an <br>attribute filter composed of three tokens: <br>    a) Name scalar        (from MICROSOFT|IDENTIFICATION|1.0 group). <br>    b) SMSLocation scalar (from MICROSOFT|IDENTIFICATION|1.0 group). <br>    c) NetCardID scalar   (from MICROSOFT|IDENTIFICATION|1.0 group). <br> <br>Two other filters are applied to the container: <br>1. Site filter: to instruct the container to retrieve the root site. <br>2. Architecture filter: to specify that we want machines of the <br>   Personal Computer architecture. <br> <br>After populating the container, which will cause the container to <br>contain only a site folder for the root site, we open the folder <br>and then close the container. <br>Closing the container is an important step since the container <br>increments a use count that is held for all descendant folders. If <br>the container is not closed as soon as possible we will never be <br>able to free the resources for any descendant folder. This would <br>cause us to exceed virtual memory very quickly for a database of <br>any size. <br> <br>We then enter a loop to deal with any folders contained in the <br>site container. Although, by definition, there can only be one <br>folder in the site container, this loop is an example of the <br>general procedure to be followed in folder enumeration involving <br>the SMS API set. <br> <br>The function DisplayFolder does most of the work. <br>It is passed a handle to the folder currently under examination, <br>at this stage all he is aware of is that this is a handle to a <br>folder. No mention is made yet as to what type of folder this is. <br> <br>For display purposes we retrieve the ID of the folder. We then <br>discovers the folder's properties; these are: <br>1. the folder's type, and <br>2. the number of scalars and sub-folders contained in this folder. <br> <br>The scalars are then displayed. <br> <br>For each folder we will open each of its child sub-folders, storing <br>the handles away in a temporary list, and then close the folder. <br>This is identical to what we did above for the container. <br> <br> <br>Turning our attention now to the DisplayScalars function we see <br>that this consists of a simple loop that repeatedly tries to <br>retrieve a scalar from the folder. The loop terminates when there <br>are no more scalars in the folder. <br>Careful note should be taken of the use of the SCALAR structure. <br>This is composed (currently - expect minor modifications here) of <br>six fields, two of which are pointers to memory that must be <br>allocated by the application. <br>When retrieving a scalar we set the pszName and pszValue pointers <br>to buffers. The pszName buffer will receive the name of the scalar, <br>no indication is given by the API as to what size that buffer <br>should be. However, a size of 256 (see SMS_DATA_BUFF_SIZE define) <br>is guaranteed to be sufficient. <br>The pszValue field is used when retrieving string data. For binary <br>data the pvalue field is used. <br>Associated with this is a length field. Prior to retrieving a <br>scalar, you must set the length field to the size of this buffer. <br>If the scalar is a string or binary, then the actual size of the <br>data will be returned here. If the buffer was too small then the <br>return code from the API will be SMS_MORE_DATA. <br> <br>Once this API has been called, we execute a switch statement to <br>find out what the type of the scalar is. For integer and time <br>scalars the value will be in the dwValue member of the SCALAR <br>structure. The time value can be converted to a string by using <br>one of the standard C library routines, or a CTime object from <br>MFC. <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
