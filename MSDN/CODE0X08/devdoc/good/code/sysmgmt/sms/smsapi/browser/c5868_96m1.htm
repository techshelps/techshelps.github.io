<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BROWSER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5869"></a>BROWSER.CPP</h2>
<pre><code>//*************************************************************************** <br>// <br>//  File: browser.cpp <br>// <br>//  Copyright (c) 1994, 1995 Microsoft Corp. <br>// <br>//  Sample Windows application for the SMS API. <br>// <br>//  Author: <br>//      Jonathan Shuval <br>// <br>//  This program implements a browser for SMS objects. <br>// <br>//  See the readme.txt file in this directory for full details. <br>// <br>//*************************************************************************** <br> <br> <br>// ==================================================================== <br>// <br>//  Includes <br>// <br>// ==================================================================== <br>#include "resource.h" <br> <br>#include &lt;afx.h&gt; <br>#include &lt;afxcoll.h&gt; <br>#include &lt;time.h&gt;               // For converting time scalars into strings. <br> <br>#include &lt;smsapi.h&gt;             // SMS API <br> <br>// 3d controls. <br>// ----------------------- <br>#include &lt;ctl3d.h&gt; <br> <br>// My header. <br>// ----------------------- <br>#include "browser.h" <br> <br> <br>// ==================================================================== <br>// <br>//  Manifests. <br>// <br>// ==================================================================== <br>#define WM_LOGIN_MSG    WM_USER+101     // So we can send ourself an <br>                                        // instruction to connect. <br> <br> <br> <br> <br> <br>// ------------------------------------------------------------- <br>//  Debug utility <br>// ------------------------------------------------------------- <br>#ifdef DEBUG <br>#include &lt;io.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;time.h&gt; <br>int  Log( char *pFmt, ... ); <br>#endif  // DEBUG <br> <br> <br>// ==================================================================== <br>// <br>//  The program starts here. <br>// <br>// ==================================================================== <br> <br>int PASCAL WinMain( <br>                HINSTANCE hInstance, <br>                HINSTANCE hPrevInstance, <br>                LPSTR lpszCmdLine, <br>                int nCmdShow) <br>{ <br>    int rc; <br> <br>    _hInstance = hInstance; <br> <br>    // Register the 3d controls. <br>    // ========================= <br>    Ctl3dRegister(_hInstance); <br>    Ctl3dAutoSubclass(_hInstance); <br> <br> <br>    // Load the saved db login information into the globals. <br>    // Change to suite your preference. <br>    // ========================================================= <br>    strcat( gszServer,   "jonshu2" ); <br>    strcat( gszDbName,   "SMS" ); <br>    strcat( gszUserName, "sa" ); <br> <br>    // Dialogue does the work. <br>    // ======================= <br>    rc = DialogBox( _hInstance, <br>                    MAKEINTRESOURCE(IDD_MAIN_DIALOG), <br>                    0, <br>                    (DLGPROC)MainDlg ); <br> <br> <br> <br>    Ctl3dUnregister(_hInstance); <br> <br>    return(rc); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Dialogue to solicit login information for the datasource. <br>// <br>// ==================================================================== <br> <br>extern "C" BOOL CALLBACK LoginDlg(  HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br> <br>    HWND hEdit; <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        //KLUDGE: set it with the params I most often use. <br>        SetDlgItemText( hDlg, IDC_SQLSERVER, gszServer ); <br>        SetDlgItemText( hDlg, IDC_DATABASE,  gszDbName ); <br>        SetDlgItemText( hDlg, IDC_LOGINID,   gszUserName); <br> <br>        // Set focus on this control. <br>        hEdit = GetDlgItem( hDlg, IDC_SQLSERVER ); <br>        SetFocus(hEdit); <br>        return(TRUE); <br> <br>    case WM_CLOSE: <br>        EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br> <br>    case WM_COMMAND: <br> <br>        switch (wParam) { <br> <br>        case IDOK: <br>            // Retrieve the values from the edit controls. <br>            //LATER: validate. <br>            gdsParams.sqlParams.ds          = DB_SQL; <br>            gdsParams.sqlParams.pFunc       = NULL;     // No encryption. <br>            gdsParams.sqlParams.pszKey      = ""; <br>            gdsParams.sqlParams.pszServer   = gszServer; <br>            gdsParams.sqlParams.pszDbName   = gszDbName; <br>            gdsParams.sqlParams.pszUserName = gszUserName; <br>            gdsParams.sqlParams.pszPasswd   = gszPasswd; <br> <br>            hEdit = GetDlgItem( hDlg, IDC_SQLSERVER ); <br>            SendMessage( hEdit, WM_GETTEXT, sizeof(gszServer), (LPARAM)gszServer ); <br> <br>            hEdit = GetDlgItem( hDlg, IDC_DATABASE ); <br>            SendMessage( hEdit, WM_GETTEXT, sizeof(gszDbName), (LPARAM)gszDbName ); <br> <br>            hEdit = GetDlgItem( hDlg, IDC_LOGINID ); <br>            SendMessage( hEdit, WM_GETTEXT, sizeof(gszUserName), (LPARAM)gszUserName ); <br> <br>            hEdit = GetDlgItem( hDlg, IDC_PASSWORD ); <br>            SendMessage( hEdit, WM_GETTEXT, sizeof(gszPasswd), (LPARAM)gszPasswd ); <br> <br>            // Disable the Login button. This will be enabled after a <br>            // container enumeration has completed. <br>            hEdit = GetDlgItem( hDlg, IDC_CONNECT ); <br>            EnableWindow( hEdit, FALSE ); <br> <br> <br>            // And now terminate. <br>            EndDialog( hDlg, IDOK ); <br>            return(TRUE); <br>        } <br>    } <br> <br>    return(FALSE); <br> <br>}  /* LoginDlg */ <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//  The real work starts here. <br>// <br>//  This dialogue allows the user to select a container from the list <br>//  of available containers. Once selected the user can select filters <br>//  to be applied to the container. <br>//  When these steps are completed the container can be viewed by <br>//  pressing the "View container" button. <br>// ==================================================================== <br> <br>extern "C" BOOL CALLBACK MainDlg(   HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br> <br>    // At init we disable all controls except the "Select container" button. <br>    // Once a container has been selected this button is disabled and the <br>    // "Select filter" button and associated listbox are enabled. <br>    // This button enables us to select multiple filters. <br>    // Pressing the "View container" button causes us to dismiss this <br>    // dialogue and display the container contents. <br>    // ===================================================================== <br>    HWND hEdit; <br>    SMS_STATUS stat; <br>    DWORD dwI; <br>    FOLDER_INFO *pCont = NULL; <br>    FILTER_INFO    *pF = NULL; <br>    MY_FILTER_INFO *pMyFilter = NULL; <br>    DWORD ctContainers = 0; <br>    int index; <br>    static CObArray aFilters;       // Array of FILTER_INFOs representing <br>                                    // selected filters. <br>    // Get the container types and insert them into the menu <br>    static FOLDER_INFO **pContainerList = NULL; <br>    int reply; <br>    HANDLE hFilter; <br> <br>    switch (message) { <br>    case WM_INITDIALOG: <br>        // Dialogue initialisation. <br> <br> <br>        // Post a message to ourselves. This will be processed after the init <br>        // completes. <br>        // This message causes us to connect to the data source. <br>        PostMessage( hDlg, WM_LOGIN_MSG, 0, 0 ); <br> <br> <br>        // ============================================================== <br>        // We need to enumerate the containers and filters <br>        // and populate the appropriate listboxes. <br>        // Enumeration is done by calling into the engine. <br>        // The resulting lists are held in globals. <br>        // ============================================================== <br> <br>        // Enumerate the container types. <br>        // --------------------------------------------------------- <br> <br>            // Get the number of containers. <br>        SmsEnumContainers(NULL, &amp;ctContainers); <br> <br>            // Allocate memory and call the enum again. <br>        pContainerList = new FOLDER_INFO *[ctContainers]; <br>        SmsEnumContainers(pContainerList, &amp;ctContainers); <br> <br>            // Populate the listbox. <br>        hEdit = GetDlgItem(hDlg, IDC_AVAIL_CONTAINER_LIST); <br> <br>        for (dwI = 0; dwI &lt; ctContainers; dwI++) { <br> <br>            pCont = pContainerList[dwI]; <br>            SendMessage(hEdit, LB_ADDSTRING, 0, (LPARAM)pCont-&gt;pszTag); <br>        } <br> <br>            // Select the first one in the list. <br>        SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br> <br> <br>        // Enumerate the filter types. <br>        // --------------------------------------------------------- <br>            // Get the number of filters. <br>        SmsEnumFilters(0, &amp;ctFilters); <br> <br>            // Allocate memory and call the enum again. <br>        gpAvailFilterList = new FILTER_INFO[ctFilters]; <br>        SmsEnumFilters(gpAvailFilterList, &amp;ctFilters); <br> <br>            // Populate the listbox. <br>        hEdit = GetDlgItem(hDlg, IDC_AVAIL_FILTER_LIST); <br> <br>        for (dwI = 0; dwI &lt; ctFilters; dwI++) { <br>            pF = &amp;gpAvailFilterList[dwI]; <br>            SendMessage(hEdit, LB_ADDSTRING, 0, (LPARAM)pF-&gt;szTag); <br>            pF++; <br>        } <br> <br>            // Select the first one in the list. <br>        SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br> <br> <br>        // Disable all except the select container button. <br>        // =============================================== <br>            // Container group <br>            // --------------- <br>        hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_BTN); <br>        EnableWindow( hEdit, TRUE ); <br> <br>        hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_DONE); <br>        EnableWindow( hEdit, FALSE ); <br> <br>            // Filter group. <br>            // ------------- <br>        hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTER_BTN); <br>        EnableWindow( hEdit, FALSE ); <br> <br>        hEdit = GetDlgItem(hDlg, IDC_DESELECT_FILTER_BTN); <br>        EnableWindow( hEdit, FALSE ); <br> <br>        hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTERS_DONE); <br>        EnableWindow( hEdit, FALSE ); <br> <br>        // Disable the "view container" button. <br>        hEdit = GetDlgItem(hDlg, IDOK); <br>        EnableWindow( hEdit, FALSE ); <br> <br>        // Disable the "configure filter" button. <br>        hEdit = GetDlgItem(hDlg, IDC_CONFIG_FILTER_BTN); <br>        EnableWindow( hEdit, FALSE ); <br> <br>        // Disable the "View selected filters" button. <br>        hEdit = GetDlgItem(hDlg, IDC_VIEW_SEL_FILTERS_BTN); <br>        EnableWindow( hEdit, FALSE ); <br> <br>        return(TRUE); <br> <br> <br>    case WM_CLOSE: <br>        EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br> <br>    case WM_LOGIN_MSG: <br>        // Establish connection to datasource. <br>        // Done via the Login dialogue. <br>        // ==================================== <br>        DialogBox( _hInstance, <br>                   MAKEINTRESOURCE(IDD_LOGIN), <br>                   hDlg, <br>                   (DLGPROC)LoginDlg ); <br> <br>        stat = SmsDataSourceConnect( &amp;gdsParams, &amp;ghConnect ); <br>        if (stat != SMS_OK) { <br>            wsprintf(szMsg, "DataSourceConnect fails: %d", stat); <br>            MessageBox(hDlg, szMsg, "Problem here", MB_OK); <br> <br>        } else { <br>            // Enable "select container" button. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_BTN); <br>            EnableWindow( hEdit, TRUE ); <br>        } <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br> <br>        switch (wParam) { <br> <br>        case IDC_SELECT_CONTAINER_BTN: <br>            // This takes the current selection from the avail containers <br>            // list and puts it in the selected container control. <br>            hEdit = GetDlgItem(hDlg, IDC_AVAIL_CONTAINER_LIST); <br>            index = SendMessage(hEdit, LB_GETCURSEL, 0, 0); <br>            gpCInfo = pContainerList[index]; <br> <br>            hEdit = GetDlgItem(hDlg, IDC_SELECTED_CONTAINER); <br>            SendMessage(hEdit, WM_SETTEXT, 0, (LPARAM)gpCInfo-&gt;pszTag); <br> <br>            // Enable the container done button. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_DONE); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            // Disable the "Connect" button. <br>            hEdit = GetDlgItem(hDlg, IDC_CONNECT); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            return(TRUE); <br> <br> <br>        case IDC_SELECT_CONTAINER_DONE: <br> <br>            // Disable the "Select container" button and enable the <br>            // "Select filters" button. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            // Disable container done btn. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_DONE); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            // Enable the filters buttons. <br>            // --------------------------- <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTER_BTN); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTERS_DONE); <br>            EnableWindow( hEdit, TRUE ); <br> <br> <br> <br>            // Open the container. <br>            // ------------------- <br>            stat = SmsOpenContainer( gpCInfo-&gt;dwTag, ghConnect, &amp;ghContainer ); <br>            if (stat != SMS_OK) { <br>                wsprintf(szMsg, "bad return from OpenContainer: %d", stat); <br>                MessageBox(hDlg, szMsg, "Badness", MB_OK ); <br>            } <br> <br>            return(TRUE); <br> <br> <br>        case IDC_SELECT_FILTER_BTN: <br>            // "Select filter" button. <br>            // This button is grayed-out until a container has <br>            // been selected. <br> <br>            // Take the currently selected filter from the <br>            // available filter listbox and add it to the selected <br>            // filters listbox. <br>            hEdit = GetDlgItem(hDlg, IDC_AVAIL_FILTER_LIST); <br>            index = SendMessage(hEdit, LB_GETCURSEL, 0, 0); <br>            pF = &amp;gpAvailFilterList[index]; <br> <br>            hEdit = GetDlgItem(hDlg, IDC_SELECTED_FILTERS); <br>            index = SendMessage(hEdit, LB_ADDSTRING, 0, (LPARAM)pF-&gt;szTag); <br> <br>            // Highlight this selection in the selected box. <br>            SendMessage(hEdit, LB_SETCURSEL, (WPARAM)index, 0 ); <br> <br> <br>            // Add the filter entry to a list of filters that we <br>            // keep handy. Maintain the index for easier access. <br>            //NOTE: remember to free it all. <br>            pMyFilter = new MY_FILTER_INFO; <br>            pMyFilter-&gt;pF = pF; <br>            pMyFilter-&gt;hFilter = NULL; <br>            aFilters.Add( (CObject *)pMyFilter ); <br> <br>            // Enable the deselect button. <br>            // --------------------------- <br>            hEdit = GetDlgItem(hDlg, IDC_DESELECT_FILTER_BTN); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            // And the "configure filter" button. <br>            // ---------------------------------- <br>            hEdit = GetDlgItem(hDlg, IDC_CONFIG_FILTER_BTN); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            // Enable the "selected filters" label and combo. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECTED_FILTERS); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            return(TRUE); <br> <br> <br>        case IDC_DESELECT_FILTER_BTN: <br>            // Remove the current item from the selected filters listbox. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECTED_FILTERS); <br>            index = SendMessage(hEdit, LB_GETCURSEL, 0, 0); <br>            SendMessage(hEdit, LB_DELETESTRING, (WPARAM)index, 0); <br> <br>            // Remove this filter from the selected filters list. <br>            pMyFilter = (MY_FILTER_INFO *)aFilters.GetAt( index ); <br>            delete pMyFilter; <br>            pMyFilter = NULL; <br>            aFilters.RemoveAt( index ); <br> <br>            // Select the previous one in the list. <br>            // If this was the first (index = 0) then leave index alone <br>            // else decrement it. <br>            if (index &gt; 0) { <br>                index--; <br>            } <br>            SendMessage(hEdit, LB_SETCURSEL, (WPARAM)index, 0); <br> <br>            // Check if we need to disable any buttons. <br>            // If the selected filters listbox is now empty disable <br>            // the "deselect" and "configure" filter buttons. <br>            // ----------------------------------------------------- <br>            index = SendMessage(hEdit, LB_GETCOUNT, 0, 0); <br>            if (index == 0) { <br>                // deselect button. <br>                // --------------------------- <br>                hEdit = GetDlgItem(hDlg, IDC_DESELECT_FILTER_BTN); <br>                EnableWindow( hEdit, FALSE ); <br> <br>                // configure filter button. <br>                // ---------------------------------- <br>                hEdit = GetDlgItem(hDlg, IDC_CONFIG_FILTER_BTN); <br>                EnableWindow( hEdit, FALSE ); <br>            } <br> <br> <br>            return(TRUE); <br> <br> <br>        case IDC_CONFIG_FILTER_BTN: <br>            // Call a dialogue to handle this. <br> <br>            // Retrieve the filter and pass it in a global so that <br>            // the dlgproc can use it. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECTED_FILTERS); <br>            index = SendMessage(hEdit, LB_GETCURSEL, 0, 0); <br>            gpMyFilter = (MY_FILTER_INFO *)aFilters[index]; <br> <br>            reply = DialogBox(  _hInstance, <br>                                MAKEINTRESOURCE(IDD_CONFIG_FILTER), <br>                                hDlg, <br>                                (DLGPROC)ConfigFilterDlg ); <br> <br>            //LATER: put in cancel btn <br>            return(TRUE); <br> <br> <br>        case IDC_VIEW_SEL_FILTERS_BTN: <br>            // User has requested to view filters that have been <br>            // applied to the container. <br>            // ================================================= <br>            DialogBox(  _hInstance, <br>                        MAKEINTRESOURCE(IDD_VIEW_SEL_FILTERS_DLG), <br>                        hDlg, <br>                        (DLGPROC)ViewSelFiltersDlg ); <br>            return(TRUE); <br> <br> <br> <br>        case IDC_SELECT_FILTERS_DONE: <br>            // Check that all of the filters that we've selected have been <br>            // configured, warning if not. <br>            // (NOTE: we should put in a check mark next to selected <br>            // filters to show if they've been configured.) <br>            // It is only at this point that we can actually apply the <br>            // filter to the container. <br> <br>            // Loop through the filters. <br>            for (dwI = 0; dwI &lt; (DWORD)aFilters.GetSize(); dwI++) { <br>                pMyFilter = (MY_FILTER_INFO *)aFilters[dwI]; <br>                if (pMyFilter-&gt;hFilter == NULL) { <br>                    wsprintf(szMsg, "A %s has not been configured,\ndo you want to configure it now?", <br>                                    pMyFilter-&gt;pF-&gt;szTag); <br>                    reply = MessageBox( hDlg, <br>                                        szMsg, <br>                                        "Warning", <br>                                        MB_ICONEXCLAMATION| MB_YESNO ); <br>                    if (reply == IDYES) { <br>                        // We want to configure this filter now. <br>                        // Stubbed: needs implementing. <br>                        MessageBox(hDlg, "Not implemented", "Go away", MB_OK); <br>                    } <br> <br>                } else { <br>                    // We can apply the filter now. <br>                    hFilter = pMyFilter-&gt;hFilter; <br>                    stat = SmsSetFilter( ghContainer, hFilter ); <br>                    SmsCloseFilter( hFilter); <br>                    if (stat != SMS_OK) { <br>                        wsprintf(szMsg, "SetFilter for %s failed: %d", <br>                                            pMyFilter-&gt;pF-&gt;szTag, stat); <br>                        MessageBox(hDlg, szMsg, "Warning", MB_OK); <br>                    } <br>                } <br>            } <br> <br>            // Must grey-out all other filter controls. <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTERS_DONE); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_DESELECT_FILTER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_CONFIG_FILTER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br> <br>            // The view container btn enabled only when filter done btn <br>            // clicked. <br>            hEdit = GetDlgItem(hDlg, IDOK); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            // Enable the "Connect" button. <br>            hEdit = GetDlgItem(hDlg, IDC_CONNECT); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            // Enable the "View selected filters" button. <br>            // We only want to do this if we have any filters. <br>            if (aFilters.GetSize() &gt; 0) { <br>                hEdit = GetDlgItem(hDlg, IDC_VIEW_SEL_FILTERS_BTN); <br>                EnableWindow( hEdit, TRUE ); <br>            } <br> <br>            return(TRUE); <br> <br>        case IDOK: <br>            // This is the "View Container" button. <br> <br>            // Tell the container to populate himself. <br>            stat = SmsPopulate( ghContainer, POP_SYNC, NULL ); <br>            if (stat != SMS_OK) { <br>                wsprintf(szMsg, "bad return from Populate: %d", stat); <br>                MessageBox(hDlg, szMsg, "Badness", MB_OK ); <br>            } <br> <br>            // Enter the container view dialogue. <br>            DialogBox(  _hInstance, <br>                        MAKEINTRESOURCE(IDD_THE_CONTAINER), <br>                        hDlg, <br>                        (DLGPROC)ContainerViewDlg ); <br> <br>            SmsCloseContainer( ghContainer ); <br> <br>            // Log off from data source. <br>            SmsDataSourceDisconnect( ghConnect ); <br> <br> <br>            //////////////////////////////////////////////////// <br>            //  Ready for restart. <br>            //////////////////////////////////////////////////// <br> <br>            // Free all global and static data. <br>            // ------------------------------------------------- <br>            for (index = 0; index &lt; aFilters.GetSize(); index ++) { <br>                pMyFilter = (MY_FILTER_INFO *)aFilters.GetAt( index ); <br>                delete pMyFilter; <br>                pMyFilter = NULL; <br>            } <br>            aFilters.RemoveAll(); <br> <br>            pCont = NULL; <br>            pF = NULL; <br>            gpCInfo = NULL; <br>            ghConnect = NULL; <br> <br>            // Delete any strings that were in the selected <br>            // container and filter edit controls. <br>            // ------------------------------------------------- <br>            SetDlgItemText( hDlg, IDC_SELECTED_CONTAINER, "" ); <br>            hEdit = GetDlgItem(hDlg, IDC_SELECTED_FILTERS); <br>            SendMessage( hEdit, LB_RESETCONTENT, 0, 0 ); <br> <br>            // Disable all controls except Login. <br>            // ------------------------------------------------- <br>                // Container group <br>                // --------------- <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_CONTAINER_DONE); <br>            EnableWindow( hEdit, FALSE ); <br> <br>                // Filter group. <br>                // ------------- <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_DESELECT_FILTER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_SELECT_FILTERS_DONE); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            // Disable the "view container" button. <br>            hEdit = GetDlgItem(hDlg, IDOK); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            // Disable the "configure filter" button. <br>            hEdit = GetDlgItem(hDlg, IDC_CONFIG_FILTER_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            // Disable the "View selected filters" button. <br>            hEdit = GetDlgItem(hDlg, IDC_VIEW_SEL_FILTERS_BTN); <br>            EnableWindow( hEdit, FALSE ); <br> <br>            // Reset listbox selections. <br>            // ------------------------------------------------- <br>            // Reset listbox selections to first in list. <br>            hEdit = GetDlgItem(hDlg, IDC_AVAIL_CONTAINER_LIST); <br>            SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_AVAIL_FILTER_LIST); <br>            SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br> <br> <br>            //////////////////////////////////////////////////// <br> <br>            // Enable the Login button so use can try again. <br>            hEdit = GetDlgItem( hDlg, IDC_CONNECT ); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            return(TRUE); <br> <br> <br>        case IDC_CONNECT: <br>            // This is the "Connect" button. <br>            SendMessage( hDlg, WM_LOGIN_MSG, 0, 0 ); <br>            return(TRUE); <br> <br> <br>        case IDC_ALL_DONE: <br>            // This is the "done" button. <br>            EndDialog( hDlg, IDOK ); <br> <br>            // And now terminate. <br>            return(TRUE); <br>        } <br>    } <br> <br>    return(FALSE); <br> <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//  This is the view container dialogue that is brought up in response <br>//  to the "view container" button in the main dialogue. <br>// <br>//  We have a listbox for the sub-folders, which we need to populate. <br>//  We also have a group box containing details about the container. <br>// <br>//  The container handle is held in a global "ghContainer". <br>// <br>// ==================================================================== <br> <br>extern "C" BOOL CALLBACK ContainerViewDlg( <br>                                    HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br> <br>    // We need to fill in the container tag and the number of folders. <br>    // The first we'll put into a global for now (from MainDlg), the <br>    // latter is currently unavailable so we'll put in some gunk. <br> <br>    HWND hEdit; <br>    static DWORD ctFolders = 0; <br>    SMS_STATUS stat; <br>    static CStringArray asID;           // Array of CStrings for IDs. <br>    CString sID; <br>    char szID[SMS_DATA_BUFF_SIZE+1];    // buffer to read in folder ID. <br>    DWORD dwI; <br>    HANDLE handle;                      // Temp holds handle of folder. <br>    int index; <br>    static CDWordArray folderList;      // List of opened folder handles. <br> <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        // Dialogue initialisation. <br> <br>        // We have to open all the sub-folders, holding their <br>        // handles in some array. For each folder we want to extract <br>        // and display in the listbox it's ID. <br>        // NOTE: GetFolderCount not yet imnplemented for containers. <br>        // Instead I'll do GetNextFolder till I run out of folders. <br>        ctFolders = 0; <br> <br>        for (ctFolders = 0; 1; ctFolders++) { <br> <br>            stat = SmsGetNextFolder( ghContainer, F_ANY, &amp;handle ); <br>            if (stat != SMS_OK) { <br>                // assume no more folders for now <br>                break; <br>            } <br>            // Save the handle. <br>            folderList.Add( (DWORD)handle ); <br>        } <br> <br> <br>        // Get the ID of each folder and insert into listbox. <br>        // -------------------------------------------------- <br>        hEdit = GetDlgItem(hDlg, IDC_ID_LB); <br> <br>        for (dwI = 0; dwI &lt; ctFolders; dwI++) { <br> <br>            // Retrieve the ID and store in the listbox. <br>            handle = (HANDLE)folderList.GetAt( dwI ); <br>            stat = SmsGetFolderID( handle, szID ); <br>            if (stat != SMS_OK) { <br>                wsprintf(szMsg, "GetID [%d] fails: %d", dwI, stat); <br>                MessageBox(hDlg, szMsg, "API problem", MB_OK); <br>            } <br>            asID.SetAtGrow( dwI, (CString)szID ); <br> <br>            SendMessage(hEdit, LB_ADDSTRING, 0, (LPARAM)szID); <br>        } <br> <br> <br>        // Select the first one in the list. <br>        SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br> <br> <br>        // Set container name and number of folders. <br>        // ----------------------------------------- <br>        SetDlgItemText( hDlg, IDC_WHAT_CONTAINER, (LPCSTR)gpCInfo-&gt;pszTag ); <br>        SetDlgItemInt( hDlg, IDC_CTR_NUM_FOLDERS, ctFolders, FALSE ); <br> <br>        // If no folders disable the "View folder" button. <br>        // ----------------------------------------------- <br>        if (ctFolders == 0) { <br>            hEdit = GetDlgItem(hDlg, IDOK); <br>            EnableWindow( hEdit, FALSE ); <br>        } <br> <br>        return(TRUE); <br> <br> <br>    case WM_CLOSE: <br>        // Close all folders. <br>        for (dwI = 0; dwI &lt; ctFolders; dwI++) { <br>            handle = (HANDLE)folderList.GetAt( dwI ); <br>            SmsCloseFolder( handle ); <br>        } <br>        folderList.RemoveAll(); <br> <br>        // Clear the ID string array. <br>        asID.RemoveAll(); <br> <br>        EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br> <br>    case WM_COMMAND: <br> <br>        switch (wParam) { <br> <br>        case IDOK: <br>            // Get the current selection and store it in a global <br>            // so that it can be picked up by FolderViewDlg. <br>            // -------------------------------------------------- <br>            hEdit = GetDlgItem(hDlg, IDC_ID_LB); <br>            index = SendMessage(hEdit, LB_GETCURSEL, 0, 0); <br>            ghFolder = (HANDLE)folderList.GetAt( index ); <br> <br>            // Now we rewind the folder. This means that we can re-enumerate <br>            // the folder's properties (ID, scalars etc). <br>            SmsRewind( ghFolder, RW_ALL ); </code></pre>
<p>
</p>
<pre><code><br>            // Enter the folder view dialogue. <br>            DialogBox(  _hInstance, <br>                        MAKEINTRESOURCE(IDD_FOLDER_VIEW), <br>                        hDlg, <br>                        (DLGPROC)FolderViewDlg ); <br> <br>            return(TRUE); <br> <br>        case IDC_DONE: <br>            // We're done with this container. Close all the folders <br>            // and the container. <br>            for (dwI = 0; dwI &lt; ctFolders; dwI++) { <br>                handle = (HANDLE)folderList.GetAt( dwI ); <br>                // Close the folder <br>                SmsCloseFolder( handle ); <br>            } <br>            folderList.RemoveAll(); <br> <br> <br>            // Clear the ID string array. <br>            asID.RemoveAll(); <br> <br> <br>            // Container closed in calling dlg. <br> <br>            // This returns us to the previous dialogue. <br>            EndDialog(hDlg, IDOK); <br>            return(TRUE); <br>        } <br>    } <br> <br>    return(FALSE); <br> <br> <br> <br>}  /* ContainerViewDlg */ <br> <br> <br>// ==================================================================== <br>// <br>//  This is the view folder dialogue that is brought up in response to <br>//  the "view folder" button in the container dialogue. <br>// <br>//  We have a listbox for the sub-folders, which we need to populate. <br>//  We also have a group box containing details about the folder. <br>// <br>//  The handle to the current folder has been placed in the ghFolder <br>//  global. <br>// <br>//  When this dlgproc is entered via INITDIALOG we create a folder <br>//  frame that contains information that we have gleaned from the <br>//  folder, including the folder's handle. This frame is stacked. <br>//  When the 'view sub-folder" button is pressed we will simulate this <br>//  same action. A 'Done" button press causes us to free the current <br>//  frame and reload from the top of stack (if any). <br>//  The WM_CLOSE causes us to walk the stack frame freeing all frames. <br>// <br>// ==================================================================== <br> <br>// Macro for easier checking of returns from the APIs. <br>// Not sure about the NO_MORE_DATA. Check it. <br>#define CHKIT(h, str) if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA &amp;&amp; stat != SMS_NO_MORE_DATA) { \ <br>    wsprintf(szMsg, "Handle: %08X %s fails: %d", h, str, stat); \ <br>    MessageBox(hDlg, szMsg, "API Error", MB_OK); return((CFrame *)NULL); } <br> <br> <br>extern "C" BOOL CALLBACK FolderViewDlg( <br>                                    HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br>    HWND hEdit; <br>    DWORD dwI;                          // Loop index. <br> <br>    int index; <br>    CString sID;                        // Temp sub-folder's ID. <br>    static CFrame *pf = NULL;           // Current stack frame. <br>    char *pszTmp; <br>    char szBuff[SMS_DATA_BUFF_SIZE+1];  // Just for setting window title. <br> <br>    static CFrameStack frameStack(hDlg); <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        // Dialogue initialisation. <br> <br>        // Set the window title to say "View of folder: &lt;name&gt;". <br>        SmsGetFolderID( ghFolder, szBuff ); <br>        wsprintf(szMsg, "View of folder: %s", szBuff); <br>        SetWindowText( hDlg, szMsg ); <br> <br>        // Extract requisite information about the folder: <br>        // ID, type (use tag), scalar count, folder count, folder type count. <br>        pf = CreateFolderFrame( hDlg, ghFolder ); <br>        if (pf) { <br>            // And display it. <br>            DisplayFolderFrame( hDlg, pf ); <br> <br>        } else { <br>            // This is an error. <br>            wsprintf(szMsg, "CreateFolderFrame failed for handle %08X", ghFolder); <br>            MessageBox(hDlg, szMsg, "An error", MB_OK); <br>            EndDialog( hDlg, IDCANCEL ); <br>        } <br> <br>        return(TRUE); <br> <br> <br>    case WM_CLOSE: <br>        // Delete current frame. <br>        // ===================== <br>        // remove the ID strings from the string array <br>        for (dwI = 0; dwI &lt; (DWORD)pf-&gt;aszID.GetSize(); dwI++) { <br>            pszTmp = (char *)pf-&gt;aszID[dwI]; <br>            delete pszTmp; <br>        } <br>        // remove the handles <br>        delete pf-&gt;phFolders; <br> <br>        delete pf; <br>        pf = NULL; <br> <br>        // Free all previous frames. <br>        // ========================= <br>        while (pf = frameStack.pop()) { <br>            // remove the ID strings from the string array <br>            for (dwI = 0; dwI &lt; (DWORD)pf-&gt;aszID.GetSize(); dwI++) { <br>                pszTmp = (char *)pf-&gt;aszID[dwI]; <br>                delete pszTmp; <br>            } <br>            // Remove the handles <br>            delete pf-&gt;phFolders; <br>            ghFolder = pf-&gt;hFolder; <br>            delete pf; <br> <br>        } <br>        EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br> <br>    case WM_COMMAND: <br> <br>        switch (wParam) { <br> <br>        case IDC_VIEW_FOLDER: <br>            // We're going down a level so stack our frame. <br>            frameStack.push( pf ); <br> <br>            // Get the current selection index. Use this to locate <br>            // the folder's handle. <br>            // We must save the existing folder handle in the frame <br>            // and re-instate it when we return. <br> <br>            hEdit = GetDlgItem( hDlg, IDC_SUBFOLDER_LIST ); <br>            index = SendMessage(hEdit, LB_GETCURSEL, 0, 0); <br>            ghFolder = pf-&gt;phFolders[index]; <br> <br>            // First clear the listbox entries (should clear other entries <br>            // as well, but I think they'll just get overwritten.) <br>            SendMessage(hEdit, LB_RESETCONTENT, 0, 0); <br> <br>            // Create a new stack frame with all the details <br>            // that we did in the INITDLG. <br>            pf = CreateFolderFrame( hDlg, ghFolder ); <br>            if (pf) { <br>                // And display it. <br>                DisplayFolderFrame( hDlg, pf ); <br> <br>            } else { <br>                // This is an error. <br>                wsprintf(szMsg, "CreateFolderFrame failed for handle %08X", ghFolder); <br>                MessageBox(hDlg, szMsg, "An error", MB_OK); <br>                EndDialog( hDlg, IDCANCEL ); <br>            } <br> <br> <br>            // Select the first one in the list and set focus here. <br>            SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br>            SetFocus(hEdit); <br> <br>            return(TRUE); <br> <br> <br>        case IDC_VIEW_SCALARS: <br>            // So we can enumerate scalars from the beginning. <br>            SmsRewind( ghFolder, RW_ALL ); <br> <br>            DialogBox( _hInstance, <br>                       MAKEINTRESOURCE(IDD_SCALARS), <br>                       hDlg, <br>                       (DLGPROC)ScalarViewDlg ); <br>            return(TRUE); <br> <br> <br>        case IDC_VIEW_EXPRESSION: <br>            // So we can enumerate tokens in expression from the beginning. <br>            SmsRewind( ghFolder, RW_ALL ); <br> <br>            DialogBox( _hInstance, <br>                       MAKEINTRESOURCE(IDD_EXPRESSION), <br>                       hDlg, <br>                       (DLGPROC)ExpressionViewDlg ); <br>            return(TRUE); <br> <br> <br> <br>        case IDC_BACK: <br>            // This will take us back one level. <br>            // We have to free all data from the current stack frame <br>            // and then restore the previous one. <br>            // When the stack frame is empty we return to the previous <br>            // dialogue. <br> <br>            // Delete current frame. <br>            // ===================== <br>            // remove the ID strings from the string array <br>            for (dwI = 0; dwI &lt; (DWORD)pf-&gt;aszID.GetSize(); dwI++) { <br>                pszTmp = (char *)pf-&gt;aszID[dwI]; <br>                delete pszTmp; <br>            } <br>            // remove the handles <br>            delete pf-&gt;phFolders; <br> <br>            delete pf; <br>            pf = NULL; <br> <br> <br>            // Restore the previous frame. <br>            // =========================== <br>            pf = frameStack.pop(); <br>            if (pf == NULL) { <br>                // Nothing there, return to previous dialogue. <br>                EndDialog(hDlg, IDOK); <br>                return(TRUE); <br>            } <br> <br> <br>            DisplayFolderFrame( hDlg, pf ); <br>            // restore folder handle <br>            ghFolder = pf-&gt;hFolder; <br> <br>            return(TRUE); <br>        } <br>    } <br> <br>    return(FALSE); <br> <br>}   /* FolderViewDlg */ <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Creates a frame for this folder. <br>//  Note: We could check if we have already stacked this folder. <br>// <br>// ==================================================================== <br> <br>CFrame *CreateFolderFrame( HWND hDlg, HANDLE hFolder ) <br>{ <br>    HANDLE hSubFolder = NULL;           // Temp reference to sub-folder. <br>    CFrame *pFrame = new CFrame; <br>    SMS_STATUS stat; <br> <br> <br>    SmsRewind( hFolder, RW_ALL ); <br> <br>    // Save the folder's handle. <br>    pFrame-&gt;hFolder = ghFolder; <br> <br>    stat = SmsGetFolderID( hFolder, pFrame-&gt;szFolderID ); <br>    CHKIT(hFolder, "GetFolderID"); <br> <br>    stat = SmsGetFolderType( hFolder, &amp;pFrame-&gt;fType, pFrame-&gt;szfType ); <br>    CHKIT(hFolder, "GetFolderType"); <br> <br>    stat = SmsGetScalarCount( hFolder, &amp;pFrame-&gt;ctScalars ); <br>    CHKIT(hFolder, "GetScalarCount"); <br> <br>    stat = SmsGetFolderCount( hFolder, F_ANY, &amp;pFrame-&gt;ctFolders ); <br>    CHKIT(hFolder, "GetFolderCount"); <br> <br>    stat = SmsEnumFolderTypes( hFolder, NULL, &amp;pFrame-&gt;ctFolderTypes ); <br>    CHKIT(hFolder, "EnumFolderTypes"); <br> <br>    // 02-May-96. Add expression display (inventory folder). <br>    stat = SmsGetTokenCount( hFolder, &amp;pFrame-&gt;ctTokens ); <br>//    CHKIT(hFolder, "GetTokenCount"); <br> <br> <br>    // Enumerate the sub-folders. <br>    // ----------------------------------------- <br>    char szBuff[SMS_DATA_BUFF_SIZE+1]; <br> <br>    // Allocate a handle for each folder. <br>    pFrame-&gt;phFolders = (HANDLE *)new HANDLE[pFrame-&gt;ctFolders]; <br>    char *pszTmp; <br> <br>    DWORD dwI; <br>    for (dwI = 0; dwI &lt; pFrame-&gt;ctFolders; dwI++) { <br>        // Rewind the folder - just in case. <br> <br>        stat = SmsGetNextFolder( hFolder, F_ANY, &amp;hSubFolder ); <br>        CHKIT(hFolder, "GetNextFolder"); <br>        pFrame-&gt;phFolders[dwI] = hSubFolder; <br> <br>        // Get folder's ID and add it to our cstring array and to the listbox. <br>        // We want it saved since we will have to redraw the listbox when <br>        // drilling down and then up in the folder list. <br>        stat = SmsGetFolderID( hSubFolder, szBuff ); <br>        CHKIT(hFolder, "GetFolderID"); <br>        pszTmp = new char[strlen(szBuff)+1];        // deleted when we do a BACK or CLOSE <br>        strcpy(pszTmp, szBuff); <br>        pFrame-&gt;aszID.Add( (CObject *)pszTmp ); <br> <br>    } <br> <br>    return(pFrame); <br> <br>}  /* CreateFolderFrame */ <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Display the given folder frame. This is part of the Folder view <br>//  dialogue. <br>// <br>// ==================================================================== <br> <br>void DisplayFolderFrame( HWND hDlg, CFrame *pFrame ) <br>{ <br>    HWND hEdit; <br> <br>    // First of all lets clear the listbox (whether needs it or not). <br>    hEdit = GetDlgItem( hDlg, IDC_SUBFOLDER_LIST ); <br>    SendMessage(hEdit, LB_RESETCONTENT, 0, 0); <br> <br> <br>    SetDlgItemText( hDlg, IDC_FOLDERID, (LPCSTR)pFrame-&gt;szFolderID); <br>    SetDlgItemText( hDlg, IDC_FOLDERTYPE, (LPCSTR)pFrame-&gt;szfType); <br>    SetDlgItemInt( hDlg,  IDC_FOLDERSC_CT, pFrame-&gt;ctScalars, FALSE); <br>    SetDlgItemInt( hDlg,  IDC_FOLDERFOLDER_CT, pFrame-&gt;ctFolders, FALSE); <br>    SetDlgItemInt( hDlg,  IDC_FOLDERFT_CT, pFrame-&gt;ctFolderTypes, FALSE); <br> <br> <br>    // Display the sub-folder IDs. <br>    // ----------------------------------------- <br>    hEdit = GetDlgItem( hDlg, IDC_SUBFOLDER_LIST ); <br>    char *pszTmp; <br> <br>    for (DWORD dwI = 0; dwI &lt; pFrame-&gt;ctFolders; dwI++) { <br> <br>        pszTmp = (char *)pFrame-&gt;aszID.GetAt( dwI ); <br>        SendMessage(hEdit, LB_ADDSTRING, 0, (LPARAM)pszTmp); <br>    } <br> <br>    // If there are no sub-folders or no scalars then <br>    // disable the appropriate buttons. <br>    // ----------------------------------------------------- <br>    hEdit = GetDlgItem( hDlg, IDC_VIEW_SCALARS ); <br>    if (pFrame-&gt;ctScalars == 0) { <br>        EnableWindow( hEdit, FALSE ); <br>    } else { <br>        EnableWindow( hEdit, TRUE ); <br>    } <br> <br>    hEdit = GetDlgItem( hDlg, IDC_VIEW_FOLDER ); <br>    if (pFrame-&gt;ctFolders == 0) { <br>        EnableWindow( hEdit, FALSE ); <br>    } else { <br>        EnableWindow( hEdit, TRUE ); <br>    } <br> <br> <br>    // Select the first one in the list and set focus here. <br>    hEdit = GetDlgItem( hDlg, IDC_SUBFOLDER_LIST ); <br>    SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br> <br>    // [02-May-96] If there are no tokens in this folder (ie it doesn't <br>    // have an expression) then disable the 'View expression' button. <br>    // ---------------------------------------------------------------- <br>    hEdit = GetDlgItem( hDlg, IDC_VIEW_EXPRESSION ); <br>    if (pFrame-&gt;ctTokens == 0) { <br>        EnableWindow( hEdit, FALSE ); <br>    } else { <br>        EnableWindow( hEdit, TRUE ); <br>    } <br>} <br> <br> <br>// ========================================================================== <br>// <br>//  Dialogue proc for the scalar view. <br>// <br>//  We need the hFolder, and preferably it's ID as well. We can put that <br>//  in the dlg title. <br>//  The hFolder is needed since we're going to enumerate its scalars. <br>//  We'll construct 2 string arrays, one for the scalar name, the other <br>//  for the value (maybe put in type as well later). <br>// <br>// ========================================================================== <br> <br>extern "C" BOOL CALLBACK ScalarViewDlg( <br>                                    HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br> <br>    HWND hEditName;                 // Explicit handle to name listbox. <br>    HWND hEditVal;                  // Explicit handle to value listbox. <br>    HWND hEditType;                 // Explicit handle to type listbox. <br>    int index; <br>    SCALAR scalar; <br>    char szName[SMS_DATA_BUFF_SIZE+1];      // Scalar name. <br>    char szValue[SMS_DATA_BUFF_SIZE+1];     // String value. <br>    BYTE byValue[SMS_DATA_BUFF_SIZE];       // Binary value. <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br>    scalar.pValue   = byValue; <br>    SMS_STATUS stat; <br>    char szBuff[SMS_DATA_BUFF_SIZE+1]; <br> <br>    char *pszVal;                   // Point to scalar's value. <br>    char *pszType;                  // Point to scalar's type. <br> <br>    CTime tTime;                    // For time scalars <br>    CString sTime;                  //  ditto <br> <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        // Dialogue initialisation. <br> <br>        // 1. Set the window title to say "Scalars for folder &lt;name&gt;". <br>        SmsGetFolderID( ghFolder, szBuff ); <br>        wsprintf(szMsg, "Scalars for folder %s", szBuff); <br>        SetWindowText( hDlg, szMsg ); <br> <br>        // 2. Enumerate the scalars storing the strings (strings only at <br>        // the moment) in 2 string lists: name and value. <br> <br>        hEditName = GetDlgItem(hDlg, IDC_SCNAME_LB); <br>        hEditVal  = GetDlgItem(hDlg, IDC_SCVAL_LB); <br>        hEditType = GetDlgItem(hDlg, IDC_SCTYPE_LB); <br> <br>        while (1) { <br>            scalar.dwLen = sizeof(szValue)-1; <br> <br>            stat = SmsGetNextScalar( ghFolder, &amp;scalar ); <br>            if (stat != SMS_OK) { <br>                break; <br>            } <br> <br>            // Copy the name and value into the listboxes - don't think I'll <br>            // bother with saving them though. <br> <br> <br>            switch (scalar.scType) { <br>            case SCALAR_STRING: <br>                pszVal = scalar.pszValue; <br>                pszType = "String"; <br>                break; <br> <br>            case SCALAR_INT: <br>                // Convert to string. <br>                wsprintf(szBuff, "%d", scalar.dwValue); <br>                pszVal = szBuff; <br>                pszType = "Integer"; <br>                break; <br> <br>            case SCALAR_TIME: <br>                // Check if we have a string equivalence. If so use it. <br>                if (scalar.bStringEquivalence) { <br>                    pszVal = scalar.pszValue; <br> <br>                } else { <br>                    // Use time functions to make a string out of it. <br>                    // NOTE: we really need to get rid of trailing newline. <br>                    tTime = scalar.tValue; <br>                    sTime = tTime.Format( "%m/%d/%y %I:%M %p" ); <br>                    pszVal = (char *)(const char *)sTime; <br>                } <br>                pszType = "Time"; <br>                break; <br> <br>            case SCALAR_BINARY: <br>                // Just print out its length. <br>                pszType = "Binary"; <br>                wsprintf( szBuff, "Length of binary data: %ld", scalar.dwLen); <br>                pszVal = szBuff; <br>                break; <br> <br>            default: <br>                wsprintf(szBuff, "UNKNOWN TYPE"); <br>                pszVal = szBuff; <br>                pszType = "Unknown type"; <br>                break; <br>            } <br> <br>            // Scalar name. <br>            SendMessage(hEditName, LB_ADDSTRING, 0, (LPARAM)scalar.pszName); <br> <br>            // Scalar type. <br>            SendMessage(hEditType, LB_ADDSTRING, 0, (LPARAM)pszType); <br> <br>            // Scalar value. <br>            SendMessage(hEditVal,  LB_ADDSTRING, 0, (LPARAM)pszVal); <br> <br> <br>        } <br> <br>        // Set current selections to the first in each list. <br>        SendMessage(hEditName, LB_SETCURSEL, (WPARAM)0, 0); <br>        SendMessage(hEditType, LB_SETCURSEL, (WPARAM)0, 0); <br>        SendMessage(hEditVal,  LB_SETCURSEL, (WPARAM)0, 0); <br> <br>        // Set focus on this control. <br>        SetFocus(hEditName); <br> <br>        return(TRUE); <br> <br> <br>    case WM_CLOSE: <br>        // Do I need to delete the strings from the listboxes?? <br>        EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br> <br>    case WM_COMMAND: <br> <br>        // Whatever listbox is selected we want to select the <br>        // corresponding entry in the other. <br>        if (HIWORD(wParam) == LBN_SELCHANGE) { <br> <br>            index = SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0); <br> <br> <br>            hEditName = GetDlgItem(hDlg, IDC_SCNAME_LB); <br>            hEditType = GetDlgItem(hDlg, IDC_SCTYPE_LB); <br>            hEditVal  = GetDlgItem(hDlg, IDC_SCVAL_LB); <br> <br>            // Select the corresponding entry all listboxes. <br>            SendMessage(hEditName, LB_SETCURSEL, (WPARAM)index, 0); <br>            SendMessage(hEditType, LB_SETCURSEL, (WPARAM)index, 0); <br>            SendMessage(hEditVal,  LB_SETCURSEL, (WPARAM)index, 0); <br> <br>            return(TRUE); <br>        } <br> <br> <br>        switch (wParam) { <br> <br>        case IDOK: <br>            // Do I need to delete the strings from the listboxes?? <br>            EndDialog(hDlg, IDOK); <br>            return(TRUE); <br> <br>        } <br>    } <br> <br>    return(FALSE); <br> <br>}  /* ScalarViewDlg */ <br> <br> <br>// ========================================================================== <br>// <br>//  Dialogue proc for the expression view. <br>//##// <br>//  We need the hFolder, and preferably it's ID as well. We can put that <br>//  in the dlg title. <br>//  The hFolder is needed since we're going to enumerate its scalars. <br>//  We'll construct 2 string arrays, one for the scalar name, the other <br>//  for the value (maybe put in type as well later). <br>// <br>// ========================================================================== <br> <br>extern "C" BOOL CALLBACK ExpressionViewDlg( <br>                                    HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br> <br>    HWND hEditToken;                // Explicit handle to token listbox. <br>    char szBuff[SMS_DATA_BUFF_SIZE+1];  // Just for setting window title. <br>    DWORD dwLoop = 0; <br> <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        // Dialogue initialisation. <br> <br>        // 1. Set the window title to say "Expression for folder &lt;name&gt;". <br>        SmsGetFolderID( ghFolder, szBuff ); <br>        wsprintf(szMsg, "Expression for folder %s", szBuff); <br>        SetWindowText( hDlg, szMsg ); <br> <br>        // 2. Enumerate the tokens storing them (ie their display strings) <br>        // into a string list. <br> <br>        hEditToken = GetDlgItem(hDlg, IDC_TOKENS_LB); <br> <br>        // Clear the token. <br>        // ================ <br>        TOKEN Token; <br>        DWORD ctTokens; <br> <br>        // Loop through its tokens, display the token string in the <br>        // edit control. <br>        // ======================================================== <br>        SmsGetTokenCount( ghFolder, &amp;ctTokens ); <br>        for (dwLoop = 0; dwLoop &lt; ctTokens; dwLoop++) { <br> <br>            memset(&amp;Token, 0, sizeof(TOKEN)); <br>            Token.bIndent = 1;                  // Request indentation. <br>            // Get token. <br>            SmsGetToken( ghFolder, dwLoop, &amp;Token ); <br> <br>            SendMessage(hEditToken, LB_ADDSTRING, 0, (LPARAM)Token.szTokenString); <br>        } <br> <br> <br>        // Set focus on this control. <br>        SetFocus(hEditToken); <br> <br>        return(TRUE); <br> <br> <br>    case WM_CLOSE: <br>        // Do I need to delete the strings from the listboxes?? <br>        EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br> <br>    case WM_COMMAND: <br> <br>        switch (wParam) { <br> <br>        case IDOK: <br>            // Do I need to delete the strings from the listboxes?? <br>            EndDialog(hDlg, IDOK); <br>            return(TRUE); <br> <br>        } <br>#ifdef XXX <br>        // Whatever listbox is selected we want to select the <br>        // corresponding entry in the other. <br>        if (HIWORD(wParam) == LBN_SELCHANGE) { <br> <br>            index = SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0); <br> <br> <br>            hEditName = GetDlgItem(hDlg, IDC_SCNAME_LB); <br>            hEditType = GetDlgItem(hDlg, IDC_SCTYPE_LB); <br>            hEditVal  = GetDlgItem(hDlg, IDC_SCVAL_LB); <br> <br>            // Select the corresponding entry all listboxes. <br>            SendMessage(hEditName, LB_SETCURSEL, (WPARAM)index, 0); <br>            SendMessage(hEditType, LB_SETCURSEL, (WPARAM)index, 0); <br>            SendMessage(hEditVal,  LB_SETCURSEL, (WPARAM)index, 0); <br> <br>            return(TRUE); <br>        } <br>#else <br>        return(TRUE); <br>#endif  // XXX <br> <br> <br>        switch (wParam) { <br> <br>        case IDOK: <br>            // Do I need to delete the strings from the listboxes?? <br>            EndDialog(hDlg, IDOK); <br>            return(TRUE); <br> <br>        } <br>    } <br> <br>    return(FALSE); <br> <br>}  /* ExpressionViewDlg */ <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// This is the dialogue that is brought up in response to the <br>// config filter button in the main dialogue. <br>// <br>//  A MY_FILTER_INFO struct is passed via a global. This <br>//  contains a description of the filter template (ie a FILTER_INFO <br>//  structure) and the handle of a particular filter. By examining <br>//  the filter info we determine how the filter's tokens are composed. <br> <br>//  The dialogue itself has the group name controls set to not- <br>//  visible. If this is a Token2 then we make them visible. <br>// <br>//  For each token there is a name, a value and an operator. <br>//  I'll hard-code the operators for the moment. <br>//  Not all tokens need the value and operator, this should be <br>//  determined by the token processing. <br>//  The nature of the value is also dependent on the token, it's <br>//  (currently) either a DWORD or a string. <br>// <br>//  We create the filter and do the add tokens here. The filter <br>//  handle is stored in the MY_FILTER_INFO struct. When we <br>//  return the invoker of this dialogue will do a SetFilter. <br>// <br>// ==================================================================== <br> <br>extern "C" BOOL CALLBACK ConfigFilterDlg( <br>                                    HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br> <br>    HWND hEdit; <br>    FILTER_INFO *pFltr = NULL; <br>    static MY_FILTER_INFO *pMyF; <br>    int index; <br>    SMS_STATUS stat; <br>    static HANDLE hFilter = NULL; <br>    ANDOR opAndOr; <br>    TOKEN Token;                        // Token to add into filter. <br> <br>    // We only know what fields the filter supports when we check the <br>    // TOKEN_INFO structure. The fields there that contain strings <br>    // tell us a) that the field is used by the filter, and b) what <br>    // the label should be for that field. <br>    // For simplicity we have two dialogues, we use one dialogue proc <br>    // to process both. This is only because of the difficulties <br>    // involved in moving edit controls around. <br>    // Different filter types will use different combinations of the <br>    // edit controls. <br>    // =============================================================== <br>    static BOOL bHasName; <br>    static BOOL bHasValue; <br>    static BOOL bHasGroupClass; <br>    static BOOL bHasArch; <br>    static BOOL bHasOp; <br>    static BOOL bHasAttribute; <br> <br>    int iLoop;                          // Loop index. <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        // Dialogue initialisation. <br>        pMyF = gpMyFilter; <br>        pFltr = pMyF-&gt;pF; <br> <br>        // Look at the filter to determine what fields it will use. <br>        // make the appropriate fields visible, and set their labels. <br>        // ========================================================== <br>        bHasName       = FALSE; <br>        bHasValue      = FALSE; <br>        bHasGroupClass = FALSE; <br>        bHasArch       = FALSE; <br>        bHasOp         = FALSE; <br>        bHasAttribute  = FALSE; <br> <br>        // Clear the token. <br>        // ================ <br>        memset(&amp;Token, 0, sizeof(TOKEN)); <br> <br>        // Name. <br>        if (strlen(pFltr-&gt;szName)) { <br>            hEdit = GetDlgItem(hDlg, IDC_NAME_STATIC); <br>            SetWindowText( hEdit, pFltr-&gt;szName ); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_NAME); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br>            bHasName = TRUE; <br>        } <br> <br>        // Value. <br>        if (strlen(pFltr-&gt;szValue)) { <br>            hEdit = GetDlgItem(hDlg, IDC_VALUE_STATIC); <br>            SetWindowText( hEdit, pFltr-&gt;szValue ); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_VALUE); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br>            bHasValue = TRUE; <br>        } <br> <br>        // GroupClass. <br>        if (strlen(pFltr-&gt;szGroupClass)) { <br>            hEdit = GetDlgItem(hDlg, IDC_GROUPCLASS_STATIC); <br>            SetWindowText( hEdit, pFltr-&gt;szGroupClass ); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_GROUPCLASS); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br>            bHasGroupClass = TRUE; <br>        } <br> <br>        // AttributeName. <br>        if (strlen(pFltr-&gt;szAttributeName)) { <br>            hEdit = GetDlgItem(hDlg, IDC_ATTRIBUTE_STATIC); <br>            SetWindowText( hEdit, pFltr-&gt;szAttributeName ); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_ATTRIBUTE); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br>            bHasAttribute = TRUE; <br>        } <br> <br>        // Architecture. <br>        if (strlen(pFltr-&gt;szArchitecture)) { <br>            hEdit = GetDlgItem(hDlg, IDC_ARCHITECTURE_STATIC); <br>            SetWindowText( hEdit, pFltr-&gt;szArchitecture ); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_ARCHITECTURE); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br>            bHasArch = TRUE; <br>        } <br> <br>        // Operator. <br>        if (strlen(pFltr-&gt;szOperator)) { <br>            hEdit = GetDlgItem(hDlg, IDC_OPERATOR_STATIC); <br>            SetWindowText( hEdit, pFltr-&gt;szOperator ); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br> <br>            hEdit = GetDlgItem(hDlg, IDC_OP_CB); <br>            ShowWindow( hEdit, SW_SHOWNORMAL ); <br>            bHasOp = TRUE; <br>        } <br> <br> <br> <br>        // Create the filter. <br>        // If all goes ok then this will be stored in <br>        // gpMyFilter, and used in the main dlg. <br>        // ----------------------------------------------------- <br>        stat = SmsCreateFilter( pFltr-&gt;filterType, ghConnect, &amp;hFilter ); <br>        if (stat != SMS_OK) { <br>            wsprintf(szMsg, "OpenFilter fails: %d", stat); <br>            MessageBox(hDlg, szMsg, "Whoops", MB_OK); <br>        } <br> <br> <br>        // Insert the operators that we support into the combobox. <br>        hEdit = GetDlgItem(hDlg, IDC_OP_CB); <br>        for (iLoop = 0; iLoop &lt; QOP_LAST; iLoop++) { <br>            SendMessage(hEdit, CB_ADDSTRING, 0, (LPARAM)OpName[iLoop]); <br>        } <br> <br>        // Default to selecting string equals. <br>        SendMessage(hEdit, CB_SETCURSEL, QOP_STR_EQ, 0); <br> <br>        // Modify the window text to "Configure &lt;type&gt; filter" <br>        // We access the global MyFilter pointer, this points to <br>        // the filter type that we're working with. <br>        wsprintf(szMsg, "Configuring %s", pFltr-&gt;szTag); <br>        SetWindowText( hDlg, szMsg ); <br> <br>        // Disable the "Done" button. <br>        hEdit = GetDlgItem(hDlg, IDOK); <br>        EnableWindow( hEdit, FALSE ); <br> <br>        return(TRUE); <br> <br> <br>    case WM_CLOSE: </code></pre>
<p>
</p>
<pre><code>EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br> <br>        switch (wParam) { <br> <br>        case IDC_ADDAND_BTN: <br>        case IDC_ADDOR_BTN: <br>            if (wParam == IDC_ADDAND_BTN) { <br>                opAndOr = OP_AND; <br>            } else { <br>                opAndOr = OP_OR; <br>            } <br> <br>            // Extract the fields. We recorded in INITDIALOG which fields <br>            // we have. <br>                // Name <br>            if (bHasName) { <br>                GetDlgItemText(hDlg, IDC_NAME, (LPTSTR)Token.szName, sizeof(Token.szName)); <br>            } <br> <br>                // Value (string first) <br>            if (bHasValue) { <br>                GetDlgItemText(hDlg, IDC_VALUE, (LPTSTR)Token.szValue, sizeof(Token.szValue)); <br>            } <br> <br>                // Operator. Get the index of the selection in the listbox <br>                // and convert to operator code. <br>            if (bHasOp) { <br>                hEdit = GetDlgItem(hDlg, IDC_OP_CB); <br>                index = SendMessage(hEdit, CB_GETCURSEL, 0, 0); <br>                Token.dwOp = index; <br>            } <br> <br>                // GroupClass <br>            if (bHasGroupClass) { <br>                GetDlgItemText(hDlg, IDC_GROUPCLASS, (LPTSTR)Token.szGroupClass, sizeof(Token.szGroupClass)); <br>            } <br> <br>                // Attribute name. <br>            if (bHasAttribute) { <br>                GetDlgItemText(hDlg, IDC_ATTRIBUTE, (LPTSTR)Token.szAttributeName, sizeof(Token.szAttributeName)); <br>            } <br> <br>                // Architecture <br>            if (bHasArch) { <br>                GetDlgItemText(hDlg, IDC_ARCHITECTURE, (LPTSTR)Token.szArchitecture, sizeof(Token.szArchitecture)); <br>            } <br>            // Add the token into the filter. <br>            // -2 for the index parameter means add the token at the end <br>            // of the filter's expression. <br>            // --------------------------------------------------------- <br>            pMyF = gpMyFilter; <br>            pFltr = pMyF-&gt;pF; <br> <br>            stat = SmsAddToken( hFilter, opAndOr, &amp;Token, -2 ); // -2 = at end. <br>            if (stat != SMS_OK) { <br>               wsprintf(szMsg, "AddToken fails: %d", stat); <br>               MessageBox(hDlg, szMsg, "Whoops", MB_OK); <br>            } <br> <br> <br>            // Clear the edit controls. <br>            // ------------------------ <br>            SetDlgItemText( hDlg, IDC_NAME        , "" ); <br>            SetDlgItemText( hDlg, IDC_VALUE       , "" ); <br>            SetDlgItemText( hDlg, IDC_GROUPCLASS  , "" ); <br>            SetDlgItemText( hDlg, IDC_ATTRIBUTE   , "" ); <br>            SetDlgItemText( hDlg, IDC_ARCHITECTURE, "" ); <br> <br> <br>            // Enable the "Done" button. <br>            // ------------------------- <br>            hEdit = GetDlgItem(hDlg, IDOK); <br>            EnableWindow( hEdit, TRUE ); <br> <br>            return(TRUE); <br> <br>        case IDOK: <br>            // We need to set the filter handle in the MYFILTER. <br>            pMyF = gpMyFilter; <br>            pMyF-&gt;hFilter = hFilter; <br>            hFilter = NULL; <br> <br>            EndDialog(hDlg, IDOK); <br>            return(TRUE); <br> <br> <br>        } <br>    } <br> <br>    return(FALSE); <br> <br>}  /* SelectFilterDlg */ <br> <br> <br> <br>// ==================================================================== <br>// <br>// This is the dialogue that is brought up in response to the <br>// view selected filters button in the main dialogue. <br>// It enables the user to view the filters that they have <br>// created and applied to the container. It shows the use of the <br>// SmsRetrieveFilters and SmsGetToken APIs. <br>// <br>// ==================================================================== <br> <br>extern "C" BOOL CALLBACK ViewSelFiltersDlg( <br>                                    HWND hDlg, <br>                                    UINT message, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br> <br>    HWND hEdit, hEdit1; <br>    SMS_STATUS stat; <br>    static DWORD ctFilters = 0;     // How many filters there are in the <br>                                    // container. <br>    DWORD ctTokens;                 // How many tokens in filter. <br>    static HANDLE *ahFilters;       // Retrieve an array of handles. <br>    DWORD dwLoop;                   // Loop index. <br>    TOKEN Token; <br>    int index;                      // Get index of selected filter. <br>    char szBuff[256];               // Build up filter tokens here. <br> <br> <br> <br> <br>    switch (message) { <br> <br>    case WM_INITDIALOG: <br>        // Dialogue initialisation. <br> <br>        // Get the number of filters, then allocate spae and call again. <br>        // ============================================================= <br>        stat = SmsGetAllFilters( ghContainer, NULL, &amp;ctFilters ); <br> <br>        ahFilters = new HANDLE[ctFilters]; <br>        stat = SmsGetAllFilters( ghContainer, ahFilters, &amp;ctFilters ); <br> <br>        // Build up the list of filters. We want to populate the listbox <br>        // with the filter tags. When one of these is selected (via the <br>        // view button) we'll display its contents in the edit control box. <br> <br>            // Populate the listbox. <br>        hEdit = GetDlgItem(hDlg, IDC_SEL_FILTERS_LB); <br> <br>        HANDLE hFilter; <br>        DWORD filterType;               // Current filter's type and tag <br>        char szFilterTag[50];           // ... <br> <br>        for (dwLoop = 0; dwLoop &lt; ctFilters; dwLoop++) { <br>            hFilter = ahFilters[dwLoop]; <br>            SmsGetFilterType( hFilter, &amp;filterType, szFilterTag ); <br> <br>            SendMessage(hEdit, LB_ADDSTRING, 0, (LPARAM)szFilterTag); <br>        } <br> <br>            // Select the first one in the list. <br>        SendMessage(hEdit, LB_SETCURSEL, 0, 0); <br> <br>            // Send the listbox a focus message. This should cause him <br>            // to display the contents of the specified filter. <br>        if (ctFilters &gt; 0) { <br>            WPARAM wp = MAKEWPARAM( IDC_SEL_FILTERS_LB, LBN_SELCHANGE ); <br>            SendMessage(hDlg, WM_COMMAND, wp, (LPARAM)hEdit); <br>        } <br>        return(TRUE); <br> <br> <br>    case WM_CLOSE: <br>        // Close all the filters that we retrieved in SmsGetAllFilters. <br>        for (dwLoop = 0; dwLoop &lt; ctFilters; dwLoop++) { <br>            hFilter = ahFilters[dwLoop]; <br>            SmsCloseFilter( hFilter ); <br>        } <br>        delete ahFilters; <br> <br>        EndDialog( hDlg, IDCANCEL ); <br>        return(TRUE); <br> <br> <br>    case WM_SYSCOLORCHANGE: <br>        Ctl3dColorChange(); <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br> <br>        if ((HIWORD(wParam) == LBN_SELCHANGE) &amp;&amp; <br>            (LOWORD(wParam) == IDC_SEL_FILTERS_LB)) { <br> <br>            hEdit1 = (HWND)lParam; <br> <br>            // Clear the contents of the view listbox. <br>            // ======================================= <br>            szBuff[0] = '\0'; <br>            hEdit = GetDlgItem(hDlg, IDC_VIEWFILTER); <br>            SendMessage(hEdit, WM_SETTEXT, 0, (LPARAM)""); <br> <br>            // Find out which filter we've selected and get it's handle. <br>            // ========================================================= <br>            index = SendMessage(hEdit1, LB_GETCURSEL, 0, 0); <br>            hFilter = ahFilters[index]; <br> <br>            // Clear the token. <br>            // ================ <br>            memset(&amp;Token, 0, sizeof(TOKEN)); <br> <br>            // Loop through its tokens, display the token string in the <br>            // edit control. <br>            // ======================================================== <br>            SmsGetTokenCount( hFilter, &amp;ctTokens ); <br>            for (dwLoop = 0; dwLoop &lt; ctTokens; dwLoop++) { <br>                // Get token. <br>                SmsGetToken( hFilter, dwLoop, &amp;Token ); <br> <br>                strcat( szBuff, Token.szTokenString ); <br>                strcat( szBuff, " "); <br>            } <br>            SendMessage(hEdit, WM_SETTEXT, 0, (LPARAM)szBuff); <br> <br>            return(TRUE); <br>        } <br> <br>        switch (wParam) { <br> <br> <br>        case IDOK: <br>            EndDialog(hDlg, IDOK); <br>            return(TRUE); <br> <br> <br>        } <br>    } <br> <br>    return(FALSE); <br> <br>}  /* ViewSelFiltersDlg */ <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>//  CFrameStack class. <br>// <br>//  This is only used in the folder view dialogue. It enables us to <br>//  descend into sub-folders but keep this current folder's data <br>//  around. <br>//  When we want to look at a sub-folder we just pop the current <br>//  folder's data onto the stack. when we return from a sub-folder we <br>//  just pop the stack. <br>// <br>// ==================================================================== <br>CFrameStack::CFrameStack(HWND hDlg) <br>{ <br>    sp = 0; <br>    _hDlg = hDlg; <br>} <br> <br>CFrameStack::~CFrameStack() <br>{ <br>    // Clear all objects from stack and delete them. <br>    CFrame *pFrame; <br>    for (int i = 0; i &lt; stack.GetSize(); i++) { <br>        pFrame = (CFrame *)stack[i]; <br>        delete pFrame; <br>    } <br>    stack.RemoveAll(); <br>} <br> <br> <br>void CFrameStack::push( CFrame *pFrame ) <br>{ <br>    stack.Add( (CObject *)pFrame ); <br>    sp++; <br> <br>} <br> <br> <br>CFrame *CFrameStack::pop() <br>{ <br>    if (sp == 0) { <br>        return(NULL); <br>    } <br>    --sp; <br>    CFrame *pFrame = (CFrame *)stack.GetAt( sp ); <br>    stack.RemoveAt( sp ); <br> <br>    return(pFrame); <br>} <br> <br> <br>//Debug: dump the stack <br>void CFrameStack::Dump( const char *psz ) <br>{ <br>    CFrame *pf; <br>    char *p = szMsg; <br> <br>    wsprintf(p, "sp=%d GetUpperBound=%d\n", sp-1, stack.GetUpperBound()); <br>    p += strlen(p); <br> <br>    for (int i = 0; i &lt;= sp-1; i++) { <br>        pf = (CFrame *)stack[i]; <br>        wsprintf(p, "%d ID: %s\n", i, pf-&gt;szFolderID); <br>        p += strlen(p); <br>    } <br>    MessageBox( _hDlg, szMsg, psz, MB_OK ); <br>} <br> <br> <br> <br>#ifdef DEBUG <br> <br>// ==================================================================== <br>// <br>//  Debug log utility. <br>//  Here so people can see an example of such a thing. <br>// <br>// eg: Log("WM_TIMER GetWindowRect fails: %d", GetLastError()); <br>// <br>// ==================================================================== <br>int Log(char *fmt, ...) <br>{ <br>    char *buffer = new char[2048]; <br> <br>    va_list argptr; <br>    int cnt; <br>    va_start(argptr, fmt); <br>    cnt = vsprintf(buffer, fmt, argptr); <br>    va_end(argptr); <br> <br>    FILE *fp; <br> <br>    fp = fopen("browser.log", "at"); <br> <br>    if (!fp) { <br>        delete buffer; <br>        return( 0 ); <br>    } <br> <br>    time_t now; <br>    time(&amp;now); <br>    struct tm *local = localtime(&amp;now); <br> <br>    fprintf(fp, "%s\n", buffer); <br> <br>    BOOL killfile = FALSE; <br> <br>    if (ftell(fp) &gt; 0x10000) { <br>        killfile = TRUE;   // 64K Limit on log <br>    } <br> <br>    fclose(fp); <br> <br>    if (killfile) { <br>        remove("log.log"); <br>    } <br> <br>    delete buffer; <br> <br>    return( cnt ); <br>} <br>#endif  // DEBUG <br> <br> <br>/* EOF: browser.cpp */ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
