<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PDF.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5882"></a>PDF.CPP</h2>
<pre><code>// ==================================================================== <br>// <br>//  File: pdf.cpp <br>// <br>//  Copyright (C) 1996 Microsoft Corp. <br>// <br>//  Author: <br>//      Jonathan Shuval     Microsoft Corp. <br>// <br>//  This program illustrates how to import a pdf file into SMS using <br>//  the SMS API set. <br>// <br>//  This sample is referenced in the Back Office documentation for SMS <br>// <br>// ==================================================================== <br> <br> <br>#define PDF_NO_ERROR                0 <br>#define PDF_ERROR                   1 <br>#define PDF_ERROR_FILENOTFOUND      2 <br>#define PDF_ERROR_NOTPDF            3 <br>#define PDF_ERROR_VERSION           4 <br>#define PDF_ERROR_MISSINGINFO       5 <br> <br>#define FILE_VERSION_PDF            "1.0" <br> <br>// ==================================================================== <br>// <br>//  Includes. <br>// <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt;             // Header for the APIs. <br> <br>// Include the GetStatusName and DisplaySmsEror functions. <br>// ------------------------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br>// ==================================================================== <br>//  Defines. <br>// ==================================================================== <br>#define CCH_MAXINPUT    256 <br>#define MAX_BUF         2048    // Max local buf size. <br>                                // No key info can exceed this. <br> <br>// ==================================================================== <br>//  Globals <br>// ==================================================================== <br>CString gsFilename;             // PDF filename. <br>CString gsWorkingPath;          // Directory containing PDF file. <br> <br> <br>// ==================================================================== <br>// <br>//  Local prototypes. <br>// <br>// ==================================================================== <br> <br>// Connect to the SMS datasource. <br>// ------------------------------------------------------------- <br>HANDLE ConnectToDatasource(); <br> <br> <br>// Display the help message. <br>// ------------------------------------------------------------- <br>void DisplayHelp(); <br> <br> <br>// Display the greeting. <br>// ------------------------------------------------------------- <br>void DisplayGreeting(); <br> <br> <br>// Check if there was a request for help on the command line. <br>// ------------------------------------------------------------- <br>BOOL DidRequestHelp( int argc, char **argv ); <br> <br> <br>// Display an error message with its SMS status value. <br>// ------------------------------------------------------------- <br>void DisplaySmsError( const char *pszMessage, SMS_STATUS stat ); <br> <br> <br>// Get the string equivalence for an SMS status code. <br>// ------------------------------------------------------------- <br>const char *GetStatusName( SMS_STATUS stat ); <br> <br> <br>// Prompt the user for input and return the reply. <br>// ------------------------------------------------------------- <br>void InputString( const char *pszMessage, char *pszResult ); <br> <br> <br>// Set the value of string and integer scalars. <br>// ------------------------------------------------------------- <br>void SetScalarString(HANDLE hFolder, char *pszName, const char *pszValue); <br>void SetScalarInt(HANDLE hFolder, char *pszName, DWORD dwValue); <br> <br> <br>// Display specified folder (and sub-folders). <br>// ------------------------------------------------------------- <br>void ViewFolder( HANDLE hFolder ); <br> <br> <br>// Display a folder's scalars. <br>// ------------------------------------------------------------- <br>void DisplayScalars( HANDLE hFolder ); <br> <br> <br> <br>// Decomposes string of comma-separated platforms into bit field. <br>// ------------------------------------------------------------- <br>DWORD GetPlatforms( char *buf ); <br> <br> <br>// Controlling function. Calls workers to parse the pdf and <br>// create the folder(s). <br>// ------------------------------------------------------------- <br>DWORD Import( HANDLE hConnect, HANDLE hContainer, const char *pPathToPDF); <br> <br> <br>// Parse basic package identification info. <br>// ------------------------------------------------------------- <br>DWORD ParsePackageDef( HANDLE hPkgFolder ); <br> <br> <br>// Parse properties for program items. <br>// ------------------------------------------------------------- <br>DWORD ParseProgramItemProperties( HANDLE hPkgFolder ); <br> <br> <br>// Parse properties for setup variations. <br>// ------------------------------------------------------------- <br>DWORD ParseSetupVariations( HANDLE hPkgFolder ); <br> <br> <br>// Parse properties for setup for sharing. <br>// ------------------------------------------------------------- <br>DWORD ParseSetupForSharing( HANDLE hPkgFolder ); <br> <br> <br>// Functions for parsing inventory rules. <br>// ------------------------------------------------------------- <br>DWORD ParseInventoryRules( HANDLE hPkgFolder ); <br>void FillFileTokens(TOKEN *pToken, char *pszBuf ); <br> <br> <br>// Test if specified file exists. <br>// ------------------------------------------------------------- <br>BOOL FileExists(const char *pszPath); <br> <br> <br>// Initialise the (global) platform aray. This contains <br>// CPlatform objects each of which contains a string form of the <br>// platform name and a binary value to be used when setting the <br>// platforms scalar. <br>// ------------------------------------------------------------- <br>void InitPlatforms(); <br> <br> <br> <br> <br> <br>// ==================================================================== <br>//  The work starts here. <br>// ==================================================================== <br> <br>void main( int argc, char **argv ) <br>{ <br>    // Check to see if this is a request to display the help <br>    // screen. If so, display it. Otherwise, display a greeting <br>    // banner. <br>    // ========================================================= <br>    if (DidRequestHelp(argc, argv)) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br> <br>    SMS_STATUS stat;                    // Return from the APIs. <br>    HANDLE hConnect;                    // Connection handle. <br>    HANDLE hContainer;                  // Handle to a container. <br> <br> <br>    // Get and display the SMS API version. <br>    // ------------------------------------ <br>    char *pszVersion;                   // Receives pointer to version string. <br>    SmsAPIVer( &amp;pszVersion );           // Get version <br>    printf("Using %s\n", pszVersion);   // and print it. <br> <br> <br>    //=========================================== <br>    // Connect to the SMS datasource. <br>    //=========================================== <br>    hConnect = ConnectToDatasource(); <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br>    //=========================================== <br>    // Get the pdf file name and validate it. <br>    //=========================================== <br>char szPDF[128]; <br> <br>if(argc == 2) <br>{ <br>// Assume pdf file on command line <br>strcpy(szPDF, argv[1]); <br>printf("Using pdf file : %s\n",szPDF); <br>} <br>else <br>{ <br>InputString("PDF file name", szPDF); <br>} <br> <br>    if (!FileExists( szPDF )) { <br>        printf("Can't find pdf file: %s\n", szPDF); <br>printf("Make sure it's in the current directory\n"); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br>    // Open package container. <br>    // ======================== <br>    stat = SmsOpenContainer( C_PACKAGE, hConnect, &amp;hContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsOpenContainer failed", stat); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br>    // Does the work. <br>    // ============== <br>    DWORD dwRet = Import( hConnect, hContainer, szPDF ); <br>    if (dwRet != 0) { <br>        printf("Error %d, file not processed\n", dwRet); <br>    } <br> <br>    // Close everything. <br>    // ================= <br>    SmsCloseContainer( hContainer ); <br>    SmsDataSourceDisconnect( hConnect ); <br> <br>} <br> <br> <br> <br>//************************************************************************* <br>// <br>//  Import() <br>// <br>//  Imports a PDF and initializes the member object pointed to by <br>//  &lt;pPackage&gt;.  This function calls other lower level parsing functions. <br>// <br>//  Parameters: <br>//      HANDLE hConnect                     Connection handle. <br>//      HANDLE hContainer                   Container handle. <br>//      const char *pPathToPDF              Path to the PDF file. <br>// <br>// <br>//  Returns: <br>// <br>//      DWORD                               0 on success, or a specific <br>//                                          error code. <br>// <br>//************************************************************************* <br>DWORD Import( HANDLE hConnect, HANDLE hContainer, const char *pPathToPDF ) <br>{ <br>    gsFilename = pPathToPDF;        // Hold globally as CString. <br> <br> <br>    // Compute the working directory/path based on analysis <br>    // of the filename. <br>    // ==================================================== <br> <br>    int iLastSlash = gsFilename.ReverseFind('\\'); <br> <br>    if (iLastSlash != -1) { <br>        gsWorkingPath = gsFilename.Left(iLastSlash) + "\\"; <br>    } <br> <br>    // Create a package folder. <br>    // ======================== <br>    SMS_STATUS stat; <br>    HANDLE hPkgFolder; <br>    stat = SmsCreateFolder( hContainer, F_PACKAGE, "", &amp;hPkgFolder ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsCreateFolder (package) failed", stat); <br>        return(PDF_ERROR); <br>    } <br> <br>    // Initialise the platforms array. <br>    // =============================== <br>    InitPlatforms(); <br> <br> <br>    // Start working. <br>    // ============== <br> <br>    DWORD dwRet = PDF_NO_ERROR; <br> <br>    dwRet = ParsePackageDef( hPkgFolder ); <br>    if (dwRet != 0) { <br>        printf("ParsePackageDef failed: %d\n", dwRet); <br>        return(dwRet); <br>    } <br> <br>    dwRet = ParseSetupVariations( hPkgFolder ); <br>    if (dwRet != 0) { <br>        printf("ParseSetupVariations failed: %d\n", dwRet); <br>        return(dwRet); <br>    } <br> <br>    dwRet = ParseSetupForSharing( hPkgFolder ); <br>    if (dwRet != 0) { <br>        printf("ParseSetupForSharing failed: %d\n", dwRet); <br>        return(dwRet); <br>    } <br> <br>    dwRet = ParseProgramItemProperties( hPkgFolder ); <br>    if (dwRet != 0) { <br>        printf("ParseProgramItemProperties failed: %d\n", dwRet); <br>        return(dwRet); <br>    } <br> <br>    dwRet = ParseInventoryRules( hPkgFolder ); <br>    if (dwRet != 0) { <br>        printf("ParseInventoryRules failed: %d\n", dwRet); <br>        return(dwRet); <br>    } <br> <br> <br>    // If we got this far then everything must have been ok. <br>    // We can link and commit the folder. <br>    // ===================================================== <br>    stat = SmsLinkFolder( hPkgFolder ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsLinkFolder for package failed", stat); <br>        return(PDF_ERROR); <br>    } <br>    stat = SmsCommitFolder( hPkgFolder ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsCommitFolder for package failed", stat); <br>        return(PDF_ERROR); <br>    } <br>    // Display the folder. <br>    // =================== <br>    printf("This is what the folder looks like:\n"); <br>    ViewFolder( hPkgFolder ); <br> <br> <br>    return(dwRet); <br>} <br> <br> <br> <br> <br> <br>//*************************************************************************** <br>// <br>//  ParsePackageDef <br>// <br>//  Parses out basic package identification info. <br>// <br>//  Parameters: <br>//      HANDLE hPkgFolder               Folder to newly created package <br>//                                      folder. <br>//  Returns: <br>//      DWORD                           0 on success or a PDF_ error code. <br>// <br>//*************************************************************************** <br>DWORD ParsePackageDef( HANDLE hPkgFolder ) <br>{ <br>    CString sWork; <br>    char *pszTmp = new char[MAX_BUF]; <br>    char szBuff[MAX_BUF]; <br>    DWORD dwCheck = 0; <br>    DWORD dwRet = PDF_ERROR; <br>CString sDirectory; <br>char sDirBuff[MAX_BUF]; <br> <br>if(!GetCurrentDirectory(MAX_BUF,  <br>sDirBuff)) <br>{ <br>dwRet = PDF_ERROR_FILENOTFOUND; <br>goto Exit; <br>} <br> <br>sDirectory = sDirBuff; <br>sDirectory += '\\'; <br>gsFilename = sDirectory + gsFilename; <br> <br>    // Verify file exists. <br>    // =================== <br> <br>    if (!FileExists((const char *)gsFilename)) { <br>        dwRet = PDF_ERROR_FILENOTFOUND; <br>        goto Exit; <br>    } <br> <br>    // Verify we have a PDF of the correct version. <br>    // ============================================ <br> <br>    dwCheck = GetPrivateProfileString(  "PDF", <br>                                        "Version", <br>                                        "", <br>                                        pszTmp, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>    if (!dwCheck) { <br>        printf("This file is not a valid PDF file.\n"); <br>        dwRet = PDF_ERROR_NOTPDF; <br>        goto Exit; <br>    } <br> <br>    if (_strnicmp(pszTmp, FILE_VERSION_PDF, strlen(FILE_VERSION_PDF)) != 0) { <br>        printf("\n"); <br>        printf("This file does not have the correct PDF version.\n"); <br>        printf("Acceptable PDF version is %s\n", FILE_VERSION_PDF); <br>        dwRet = PDF_ERROR_VERSION; <br>        goto Exit; <br>    } <br> <br>    // [Package Definition] <br>    // ==================== <br> <br>    // Product <br>    // ======= <br> <br>    dwCheck = GetPrivateProfileString(  "Package Definition", <br>                                        "Product", <br>                                        "", <br>                                        pszTmp, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>    if (!dwCheck) { <br>        dwRet = PDF_ERROR_MISSINGINFO; <br>        goto Exit; <br>    } <br> <br>    sWork = pszTmp; <br>    sWork += " "; <br> <br>    // Version <br>    // ======= <br> <br>    GetPrivateProfileString("Package Definition", <br>                            "Version", <br>                            "", <br>                            pszTmp, <br>                            MAX_BUF, <br>                            gsFilename); <br> <br>    sWork += pszTmp;  // product + version <br> <br>    SetScalarString( hPkgFolder, "Name", (const char *)sWork); <br> <br>    // Comment <br>    // ======= <br> <br>    GetPrivateProfileString("Package Definition", <br>                            "Comment", <br>                            "", <br>                            pszTmp, <br>                            MAX_BUF, <br>                            gsFilename); <br> <br>    SetScalarString( hPkgFolder, "Comment", pszTmp ); <br> <br> <br> <br>    // Source directory for Workstations. <br>    // If it's not in the pdf ask the user for it. It's mandatory. <br>    // =========================================================== <br>    GetPrivateProfileString("Package Definition", <br>                            "ImportDirectory", <br>                            "", <br>                            pszTmp, <br>                            MAX_BUF, <br>                            gsFilename); <br>    if (strlen(pszTmp) == 0) { <br>        printf("\n"); <br>        printf("If this package is destined to be set up for workstations\n"); <br>        printf("you must enter a value for the ImportDirectory.\n"); <br>        printf("If you do not do so then the package will not be completely\n"); <br>        printf("set up and you must alter it via the SMS Admin utility\n"); <br>        printf( "Please enter a value (relative to path %s) or just hit ENTER: ", <br>                            (const char *)gsWorkingPath); <br>        gets( pszTmp ); <br>    } <br>    if (strlen(pszTmp) != 0) { <br>        strcpy( szBuff, (const char *)gsWorkingPath ); <br>        strcat( szBuff, pszTmp ); <br>        SetScalarString( hPkgFolder, "Workstation root", szBuff ); <br>    } <br> <br> <br> <br>    // Source directory for Shared Server Apps. <br>    // If it's not in the pdf ask the user for it. It's mandatory. <br>    // =========================================================== <br>    GetPrivateProfileString("Package Definition", <br>                            "SetupDirectory", <br>                            "", <br>                            pszTmp, <br>                            MAX_BUF, <br>                            gsFilename); <br>    if (strlen(pszTmp) == 0) { <br>        printf("If this package is destined to be set up for sharing\n"); <br>        printf("you must enter a value for the SetupDirectory.\n"); <br>        printf("If you do not do so then the package will not be completely\n"); <br>        printf("set up and you must alter it via the SMS Admin utility\n"); <br>        printf( "Please enter a value (relative to path %s) or just hit ENTER: ", <br>                            (const char *)gsWorkingPath); <br>        gets( pszTmp ); <br>    } <br>    if (strlen(pszTmp) != 0) { <br>        strcpy( szBuff, (const char *)gsWorkingPath ); <br>        strcat( szBuff, pszTmp ); <br>        SetScalarString( hPkgFolder, "Server root", szBuff ); <br>    } <br> <br> <br>    // Get package access specifications from PDF. If there are specifications <br>    // set them in the package. If there are no specifications leave it alone. <br>    // ======================================================================= <br> <br>    GetPrivateProfileString("Package Definition", <br>                            "WorkstationAccess", <br>                            "", <br>                            pszTmp, <br>                            MAX_BUF, <br>                            gsFilename); <br> <br>    if (strlen(pszTmp) &gt; 0) { <br>        DWORD dwPerms = 0; <br> <br>        if (strstr( pszTmp, "UserRead" )) { <br>            dwPerms |= PACKAGE_USER_READ; <br>        } <br>        if (strstr( pszTmp, "UserWrite" )) { <br>            dwPerms |= PACKAGE_USER_WRITE; <br>        } <br>        if (strstr( pszTmp, "GuestRead" )) { <br>            dwPerms |= PACKAGE_GUEST_READ; <br>        } <br>        if (strstr( pszTmp, "GuestWrite" )) { <br>            dwPerms |= PACKAGE_GUEST_WRITE; <br>        } <br> <br>        SetScalarInt( hPkgFolder, "Workstation permissions", dwPerms ); <br>    } <br> <br>    dwRet = 0; <br> <br>Exit: <br>    delete pszTmp; <br>    return(dwRet); <br>} <br> <br> <br> <br>//*************************************************************************** <br>// <br>//  ParseProgramItemProperties <br>// <br>//  Parses out properties for program items. <br>// <br>//  Returns: <br>// <br>//      DWORD                           0 on success or a PDF_ error code. <br>// <br>//*************************************************************************** <br>DWORD ParseProgramItemProperties( HANDLE hPkgFolder ) <br>{ <br>    DWORD dwRet = 0; <br>    char *buf = new char[MAX_BUF];      // Temporary working buffer <br> <br>    SMS_STATUS stat; <br> <br>    for (int i = 1; ; i++) { <br> <br>        // Create a new progitem folder. <br>        // Do this once per iteration. <br>        // If all goes well it will be linked and committed at the end <br>        // of each iteration. <br>        // =========================================================== <br>        HANDLE hPIFolder; <br>        stat = SmsCreateFolder( hPkgFolder, F_PROGITEM, "", &amp;hPIFolder ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsCreateFolder (program item) failed", stat); <br>            return( PDF_ERROR ); <br>        } <br> <br>        char Section[128]; <br>        sprintf(Section, "Program Item Properties %d", i); <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "CommandLine", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        if (dwRet == 0) {           // When no more program item sections <br>            break;                  // are available. <br>        } <br> <br> <br>        // If here, we have started reading a program item. <br>        // ================================================ <br> <br>        SetScalarString( hPIFolder, "Command line", buf ); <br> <br>        //----------------------------------------------------- <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "Description", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        SetScalarString( hPIFolder, "Description", buf ); <br> <br>        //----------------------------------------------------- <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "ConfigurationScript", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        if (strlen(buf)) { <br>            SetScalarString( hPIFolder, "Configure script file", buf ); <br>        } <br> <br>        //----------------------------------------------------- <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "RegistryName", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        SetScalarString( hPIFolder, "Registry name", buf ); <br> <br>        //----------------------------------------------------- <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "RunMinimized", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        if (_stricmp(buf, "TRUE") == 0) { <br>            SetScalarInt( hPIFolder,  "Run minimized", TRUE ); <br>        } else { <br>            SetScalarInt( hPIFolder,  "Run minimized", FALSE ); <br>        } <br> <br>        //----------------------------------------------------- <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "RunLocalCopyIfPresent", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        if (_stricmp(buf, "TRUE") == 0) { <br>            SetScalarInt( hPIFolder,  "Search local flag", TRUE ); <br>        } else { <br>            SetScalarInt( hPIFolder,  "Search local flag", FALSE ); <br>        } <br> <br>        //----------------------------------------------------- <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "DriveMode", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br> <br>        if (strstr(buf, "UNC")) { <br>            SetScalarInt( hPIFolder, "Drive mode", PI_DRIVEMODE_UNC ); <br>        } <br> <br>        if (strstr(buf, "ANY_DRIVE_LETTER")) { <br>            SetScalarInt( hPIFolder, "Drive mode", PI_DRIVEMODE_ANY_LETTER ); <br>        } <br> <br>        if (strstr(buf, "SPECIFIC_DRIVE_LETTER")) { <br>            // Specific drive letter. <br>            char *p = strstr(buf, ":"); <br>            SetScalarInt( hPIFolder, "Drive mode", PI_DRIVEMODE_SPECIFIC_LETTER ); <br>            SetScalarString( hPIFolder, "Drive letter", &amp;p[-1] ); <br>        } <br> <br>        //----------------------------------------------------- <br> <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "SupportedPlatforms", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        // 'buf' contains an array of strings comma-separated. <br>        // Each of these strings corresponds to a platform. <br>        // An example would be: <br>        //  "Windows 3.1, Windows NT 3.1 (MIPS), ..." <br>        // We'll call a function to analyse these strings and set <br>        // the appropriate bits in a DWORD. This is the value that <br>        // we will store in the scalar. <br>        DWORD dwPlatforms = GetPlatforms( buf ); <br>        SetScalarInt( hPIFolder, "Platforms", dwPlatforms ); <br> <br> <br>        //----------------------------------------------------- <br> <br> <br>        // Read in the icon. <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "SetupIcon", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        CString sFile = gsWorkingPath + buf; <br> <br>        FILE *fIcon = fopen((const char *)sFile, "rb"); <br> <br>        if (fIcon) { <br>            BYTE *pIconFileImage; <br>            DWORD dwImageSize; <br> <br>            fseek(fIcon, 0, SEEK_END); <br>            dwImageSize = (DWORD)ftell(fIcon); <br>            fseek(fIcon, 0, SEEK_SET); <br>            pIconFileImage = new BYTE[dwImageSize]; <br>            DWORD dwResult = fread(pIconFileImage, sizeof(BYTE), dwImageSize, fIcon); <br>            if (dwResult == dwImageSize) { <br>                SCALAR sc; <br>                sc.pszName = "Icon"; <br>                sc.scType = SCALAR_BINARY; <br>                sc.pValue = pIconFileImage; <br>                sc.dwLen = dwImageSize; <br>                SmsSetScalar( hPIFolder, &amp;sc ); <br>            } else { <br>                printf("Can't read icon file %s\n", (const char *)sFile); <br>                delete pIconFileImage; <br>            } <br>            fclose(fIcon); <br>        } else { <br>            printf("Can't access icon file %s\n", (const char *)sFile); <br>        } <br> <br>        //----------------------------------------------------- <br> <br>        dwRet = GetPrivateProfileString(Section, <br>                                        "DisplayIconInProgGroup", <br>                                        "TRUE", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        if (_stricmp(buf, "TRUE") == 0) { <br>            SetScalarInt( hPIFolder,  "Display Icon in Program Group", TRUE ); <br>        } else { <br>            SetScalarInt( hPIFolder,  "Display Icon in Program Group", FALSE ); <br>        } <br> <br> <br> <br>        // Add the program item folder to the package folder. <br>        // ================================================== <br>        stat = SmsLinkFolder( hPIFolder ); <br>        stat = SmsCommitFolder( hPIFolder ); <br>        stat = SmsCloseFolder( hPIFolder ); <br>    } <br> <br>    delete buf; <br>    return 0; <br>} <br> <br>//*************************************************************************** <br>// <br>//  ParseSetupVariations <br>// <br>// <br>//  Returns: <br>// <br>//      DWORD                           0 on success or a PDF_ error code. <br>// <br>//*************************************************************************** <br>DWORD ParseSetupVariations( HANDLE hPkgFolder ) <br>{ <br>    CStringArray asVariations; <br>    DWORD dwRet; <br>    char *buf = new char[MAX_BUF]; <br> <br>    dwRet = GetPrivateProfileString("Package Definition", <br>                                    "SetupVariations", <br>                                    "", <br>                                    buf, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    char *p = strtok(buf, ","); <br> <br>    while (p) { <br>        while (*p == ' ') <br>            p++;  // Move past leading blanks <br> <br>        asVariations.Add(p); <br>        p = strtok(NULL, ","); <br>    } <br> <br> <br>    // Now parse out the individual variations. <br>    // ======================================== <br> <br> <br>    for (int i = 0; i &lt; asVariations.GetSize(); i++) { <br> <br> <br>        // Create a new WCL folder. <br>        // Do this once per iteration. <br>        // If all goes well it will be linked and committed at the end <br>        // of each iteration. <br>        // =========================================================== <br>        HANDLE hWclFolder; <br>        SMS_STATUS stat; <br>        stat = SmsCreateFolder( hPkgFolder, F_WCL, "", &amp;hWclFolder ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsCreateFolder (wcl) failed", stat); <br>            return( PDF_ERROR ); <br>        } <br> <br>        CString sVariation = asVariations[i] + CString(" Setup"); <br> <br>        //------------------------------------------------------ <br> <br>        dwRet = GetPrivateProfileString(sVariation, <br>                                        "CommandLine", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        SetScalarString( hWclFolder, "Command", buf ); <br> <br>        //------------------------------------------------------ <br> <br>        dwRet = GetPrivateProfileString(sVariation, <br>                                        "CommandName", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        SetScalarString( hWclFolder, "Name", buf ); <br> <br>        //------------------------------------------------------ <br>        // since wclFlags is zero initialized we only need to OR <br>        // it together with any bitfields needing set <br>        DWORD wclFlags = 0; <br> <br>        dwRet = GetPrivateProfileString(sVariation, <br>                                        "UserInputRequired", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        if (_stricmp(buf, "TRUE") != 0) { </code></pre>
<p>
</p>
<pre><code>wclFlags |= WCL_AUTOMATED_COMMAND_LINE; <br>        } <br> <br> <br>        SetScalarInt( hWclFolder, "Flags", wclFlags ); <br> <br>        //------------------------------------------------------ <br> <br> <br>        dwRet = GetPrivateProfileString(sVariation, <br>                                        "SupportedPlatforms", <br>                                        "", <br>                                        buf, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        DWORD dwPlatforms = GetPlatforms( buf ); <br>        SetScalarInt( hWclFolder, "Platforms", dwPlatforms ); <br> <br> <br>        //------------------------------------------------------ <br> <br> <br>        // Add WCL to package. -- link and commit wcl folder. <br>        // =================== <br> <br>        stat = SmsLinkFolder( hWclFolder ); <br>        stat = SmsCommitFolder( hWclFolder ); <br>        stat = SmsCloseFolder( hWclFolder ); <br> <br>    } <br> <br>    delete buf; <br>    return 0; <br>} <br> <br> <br>//*************************************************************************** <br>// <br>//  ParseSetupForSharing <br>// <br>// <br>//  Returns: <br>// <br>//      DWORD                           0 on success or a PDF_ error code. <br>// <br>//*************************************************************************** <br>DWORD ParseSetupForSharing( HANDLE hPkgFolder ) <br>{ <br>    BOOL bSharePkg = FALSE; <br>    DWORD dwRet; <br> <br>    char *buf = new char[MAX_BUF]; <br> <br>    //------------------------------------------------- <br> <br>    dwRet = GetPrivateProfileString("Setup Package for Sharing", <br>                                    "ShareName", <br>                                    "", <br>                                    buf, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>      SetScalarString( hPkgFolder, "Share name", buf ); <br> <br>    //------------------------------------------------- <br> <br>    dwRet = GetPrivateProfileString("Setup Package for Sharing", <br>                                    "ShareAccess", <br>                                    "", <br>                                    buf, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    DWORD dwFlags = 0; <br> <br>    if (strstr(buf, "UserRead")) { <br>        dwFlags |= PACKAGE_USER_READ; <br>    } <br>    if (strstr(buf, "UserWrite")) { <br>        dwFlags |= PACKAGE_USER_WRITE; <br>    } <br>    if (strstr(buf, "GuestRead")) { <br>        dwFlags |= PACKAGE_GUEST_READ; <br>    } <br>    if (strstr(buf, "GuestWrite")) { <br>        dwFlags |= PACKAGE_GUEST_WRITE; <br>    } <br> <br>    SetScalarInt( hPkgFolder, "Share permissions", dwFlags ); <br> <br>    if (dwFlags) { <br>        bSharePkg = TRUE; <br>    } <br> <br>    //------------------------------------------------- <br> <br> <br>    delete buf; <br>    return 0; <br>} <br> <br> <br>//*************************************************************************** <br>// <br>//  FillFileTokens <br>// <br>// <br>// <br>// <br>//*************************************************************************** <br>void FillFileTokens(TOKEN *pToken, char *pszBuf ) <br>{ <br>    char *pszBuff2 = new char[MAX_BUF]; <br>    char *pszBuff3 = new char[MAX_BUF]; <br> <br>    DWORD dwRet; <br>    LONG offset, length, value; <br>    int hr, min, mm, dd, yy; <br>    CString sToken; <br>    const CString sQuote("\""); <br> <br>    //-------------------------------------------------------------- <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "FILE", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    sToken = "FILE " + sQuote + pszBuff2 + sQuote; <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "SIZE", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    if (dwRet) { <br>        sToken += CString(" SIZE ") + pszBuff2; <br>    } <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, <br>                                    "COLLECT", <br>                                    "", <br>                                    pszBuff2, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    if (dwRet &amp;&amp; (_stricmp(pszBuff2, "TRUE") == 0)) { <br>        sToken += CString(" COLLECT "); <br>    } <br> <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, <br>                                    "CHECKSUM", <br>                                    "", <br>                                    pszBuff2, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d,%d,%d", &amp;offset, &amp;length, &amp;value); <br>        sToken += CString(" CHECKSUM ") + pszBuff2; <br>    } <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "CRC", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d,%d,%d", &amp;offset, &amp;length, &amp;value); <br>        sToken += CString(" CRC ") + pszBuff2; <br>    } <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "DATE", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d,%d,%d", &amp;mm, &amp;dd, &amp;yy); <br>        sprintf( pszBuff3, "%d/%d/%d", mm, dd, yy ); <br>        sToken += CString(" DATE ") + pszBuff3; <br>    } <br> <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "TIME", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d,%d", &amp;hr, &amp;min); <br>        sprintf( pszBuff3, "%d:%d", hr, min ); <br>        sToken += CString(" TIME ") + pszBuff3; <br>    } <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "BYTE", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d,%d", &amp;offset, &amp;value); <br>        sToken += CString(" BYTE ") + pszBuff2; <br>    } <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "WORD", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d,%d", &amp;offset, &amp;value); <br>        sToken += CString(" WORD ") + pszBuff2; <br>    } <br> <br> <br>    //-------------------------------------------------------------- <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, "LONG", "", pszBuff2, MAX_BUF, gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d,%d", &amp;offset, &amp;value); <br>        sToken += CString(" LONG ") + pszBuff2; <br>    } <br> <br> <br>    //-------------------------------------------------------------- <br>    // String values <br> <br>    dwRet = GetPrivateProfileString(pszBuf, <br>                                    "TOKEN 1", <br>                                    "", <br>                                    pszBuff2, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    if (dwRet) { <br>        // All this to remove the comma after the offset. <br>        sscanf(pszBuff2, "%d, \"%[^\"]", &amp;offset, pszBuff3); <br>        sprintf( pszBuff2, "%d \"%s\"", offset, pszBuff3 ); <br>        sToken += CString(" STRING ") + pszBuff2; <br>    } <br> <br>    dwRet = GetPrivateProfileString(pszBuf, <br>                                    "TOKEN 2", <br>                                    "", <br>                                    pszBuff2, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d, \"%[^\"]", &amp;offset, pszBuff3); <br>        sprintf( pszBuff2, "%d \"%s\"", offset, pszBuff3 ); <br>        sToken += CString(" STRING ") + pszBuff2; <br>    } <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, <br>                                    "TOKEN 3", <br>                                    "", <br>                                    pszBuff2, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d, \"%[^\"]", &amp;offset, pszBuff3); <br>        sprintf( pszBuff2, "%d \"%s\"", offset, pszBuff3 ); <br>        sToken += CString(" STRING ") + pszBuff2; <br>    } <br> <br> <br>    dwRet = GetPrivateProfileString(pszBuf, <br>                                    "TOKEN 4", <br>                                    "", <br>                                    pszBuff2, <br>                                    MAX_BUF, <br>                                    gsFilename); <br> <br>    if (dwRet) { <br>        sscanf(pszBuff2, "%d, \"%[^\"]", &amp;offset, pszBuff3); <br>        sprintf( pszBuff2, "%d \"%s\"", offset, pszBuff3 ); <br>        sToken += CString(" STRING ") + pszBuff2; <br>    } <br> <br> <br>    //-------------------------------------------------------------- <br> <br>    // Store the string in the token. <br>    // ============================== <br>    strcpy( pToken-&gt;szTokenString, (const char *)sToken ); <br> <br> <br>    delete pszBuff2; <br>    delete pszBuff3; <br>} <br> <br> <br> <br> <br>//*************************************************************************** <br>// <br>//  ParseInventoryRules <br>// <br>//  Parameters: <br>//      HANDLE hPkgFolder               Handle to package folder. <br>// <br>//  Returns: <br>// <br>//      DWORD                           0 on success or a PDF_ error code. <br>// <br>//  NOTE: This doesn't handle nested grouping. <br>// <br>//*************************************************************************** <br>DWORD ParseInventoryRules( HANDLE hPkgFolder ) <br>{ <br>    char *pszBuff1 = new char[MAX_BUF]; <br>    char *pszBuff2 = new char[MAX_BUF]; <br> <br>    char rulenum[64]; <br>    DWORD dwRet; <br>    INT iStart, iEnd, iNextToken; <br>    iNextToken = 0; <br> <br>    ANDOR opAndOr = OP_AND; <br> <br>    HANDLE hInvFolder; <br>    SMS_STATUS stat; <br>    stat = SmsCreateFolder( hPkgFolder, F_INVENTORY, "", &amp;hInvFolder ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsCreateFolder (inventory) failed", stat); <br>        return( PDF_ERROR ); <br>    } <br> <br>    // First, we build up the expression by traversin the <br>    // DetectionRule parts of the [Setup Package for Inventory] <br>    // section. <br>    // ======================================================== <br> <br>    for (int i = 1; 1; i++) { <br> <br>        sprintf(rulenum, "Detection Rule Part %d", i); <br> <br>        dwRet = GetPrivateProfileString("Setup Package for Inventory", <br>                                        rulenum, <br>                                        "", <br>                                        pszBuff1, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        if (!dwRet) { <br>            break; <br>        } <br> <br>        TOKEN Token; <br>        memset( &amp;Token, 0, sizeof(TOKEN) ); <br> <br>        // If here, we have a rule token. <br>        // ============================== <br> <br>        if (_stricmp(pszBuff1, "AND") == 0) { <br>            opAndOr = OP_AND; <br>            iNextToken++; <br>        } <br> <br>        else if (_stricmp(pszBuff1, "OR") == 0) { <br>            opAndOr = OP_OR; <br>            iNextToken++; <br>        } <br> <br>        else if (_stricmp(pszBuff1, ")") == 0) { <br>            // Save the end index and then call SmsManipulateTokens. <br>            // Note that we subtract 1 from NextToken. This is because <br>            // we want the index of the *last* token in the range, and <br>            // not what the next one will be. <br>            iEnd = iNextToken-1; <br>            stat = SmsManipulateTokens( hInvFolder, TOK_GROUP, iStart, iEnd ); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("SmsManipulateToken fails", stat); <br>            } <br>        } <br> <br>        else if (_stricmp(pszBuff1, "(") == 0) { <br>            // Start of a group. <br>            // We will need to know and save the start and end indecies. <br>            // These we then pass through to SmsManipulateTokens. <br>            // This means that we need to keep track of the token indecies <br>            // all the way through. <br>            iStart = iNextToken; <br>        } <br> <br>        else { <br>            // This is the real part of the token. <br>            FillFileTokens(&amp;Token, pszBuff1); <br>            stat = SmsAddToken( hInvFolder, opAndOr, &amp;Token, AT_END ); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("SmsAddToken fails", stat); <br>            } <br>            iNextToken++; <br>        } <br> <br>#ifdef DEBUG <br>    // Retrieve and print out tokens - with their indecies. <br>    DWORD ctTknsX=0; <br>    stat = SmsGetTokenCount( hInvFolder, &amp;ctTknsX ); <br>    printf("Tokens so far: %d Next token: %d\n", ctTknsX, iNextToken); <br>    for (int i = 0; i &lt; (int)ctTknsX; i++) { <br>        stat = SmsGetToken( hInvFolder, i, &amp;Token ); <br>        printf(" [%d] &lt;%s&gt;\n", i, Token.szTokenString); <br>    } <br>    printf("=======\n"); <br>#endif  // DEBUG <br> <br>    } <br> <br> <br>    // Set 'Inventory this package' scalar if appropriate. <br>    // We only want to do this if there were indeed any inventory <br>    // rules specified. We check this by looking to see if the <br>    // filter contains tokens. <br>    // ========================================================== <br>    DWORD ctTokens=0; <br>    stat = SmsGetTokenCount( hInvFolder, &amp;ctTokens ); <br> <br>    if (ctTokens &gt; 0) { <br>        // Grab this stuff from the section dealing with package folder. <br>        // We deal with it here in the inventory folder. <br>        // ------------------------------------------------------------- <br>        dwRet = GetPrivateProfileString("Setup Package for Inventory", <br>                                        "InventoryThisPackage", <br>                                        "", <br>                                        pszBuff1, <br>                                        MAX_BUF, <br>                                        gsFilename); <br> <br>        DWORD dwFlags; <br>        if (_stricmp(pszBuff1, "TRUE") == 0) { <br>            dwFlags = 1; <br>        } else { <br>            dwFlags = 0; <br>        } <br>        SetScalarInt( hInvFolder, "Inventory this package", dwFlags ); <br>    } <br> <br>    // Cleanup. <br>    // ======== <br> <br>    delete pszBuff1; <br>    delete pszBuff2; <br> <br> <br>    // Only link and commit if there were any inventory rules. <br>    // ======================================================= <br>    if (ctTokens &gt; 0) { <br>        stat = SmsLinkFolder( hInvFolder ); <br>        stat = SmsCommitFolder( hInvFolder ); <br>    } <br>    stat = SmsCloseFolder( hInvFolder ); <br> <br>    return(0); <br>} <br> <br> <br> <br>// Ancilliary routines <br> <br>//*************************************************************************** <br>// <br>// <br>// <br>//*************************************************************************** <br> <br>BOOL FileExists(const char *pszPath) <br>{ <br>    BOOL bRet; <br>    CFileStatus status; <br> <br>    if (CFile::GetStatus( pszPath, status )) { <br>        bRet = TRUE; <br>    } else { <br>        bRet = FALSE; <br>    } <br> <br>    return(bRet); <br>} <br> <br> <br>//************************************************************************* <br>// <br>//  We are given a string buffer which contains a series of comma-delimited <br>//  platform names. <br>//  We analyse this string breaking it down into the individual platforms. <br>//  Each (valid) platform will then cause a corresponding bit-pattern to be <br>//  ORed into the resulting DWORD that we return. <br>// <br>//************************************************************************* <br> <br>// Build up an array with platform names, for each name also have <br>// its corresponding bit value. <br>class CPlatform : public CObject <br>{ <br>public: <br>    CPlatform() {}; <br>    CPlatform( CString sPlatform, DWORD bPlatform ) { <br>        this-&gt;sPlatform = sPlatform; <br>        this-&gt;bPlatform = bPlatform; <br>    } <br>    ~CPlatform() {}; <br>    CString sPlatform;          // String name of platform (eg "Macintosh"). <br>    DWORD bPlatform;            // Bit value used in platform scalar. <br>}; <br> <br>CObArray aPlatforms; <br> <br>// Setup the array. <br>void InitPlatforms() <br>{ <br>    CPlatform *pPlat; <br> <br>    pPlat = new CPlatform( "Macintosh",   PLTFRM_MACINTOSH ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "MS-DOS 5.0",  PLTFRM_DOS5 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "MS-DOS 6.0",  PLTFRM_DOS6 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "MS-DOS 6.2",  PLTFRM_DOS6 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "MS-DOS 6.21", PLTFRM_DOS6 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "MS-DOS 6.22", PLTFRM_DOS6 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows 3.1", PLTFRM_WIN16 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.1 (Alpha)", PLTFRM_WIN32_ALPHA ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.1 (MIPS)",  PLTFRM_WIN32_MIPS ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.1 (x86)",   PLTFRM_WIN32_X86 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.5 (Alpha)", PLTFRM_WIN32_ALPHA ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.5 (MIPS)",  PLTFRM_WIN32_MIPS ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.5 (x86)",   PLTFRM_WIN32_X86 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.51 (Alpha)",PLTFRM_WIN32_ALPHA ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.51 (MIPS)", PLTFRM_WIN32_MIPS ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 3.51 (x86)",  PLTFRM_WIN32_X86 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 4.0 (Alpha)", PLTFRM_WIN32_ALPHA ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 4.0 (MIPS)",  PLTFRM_WIN32_MIPS ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows NT 4.0 (x86)",   PLTFRM_WIN32_X86 ); <br>    aPlatforms.Add( pPlat ); <br> <br>    pPlat = new CPlatform( "Windows95", PLTFRM_WIN95 ); <br>    aPlatforms.Add( pPlat ); <br>} <br> <br>DWORD GetPlatforms( char *buf ) <br>{ <br>    DWORD dwPlatforms = 0; <br>    CPlatform *pPlatform; <br>    CString sBuff = buf;            // Easier to work with. <br> <br>    // We have an array of platform names. Check each one of <br>    // these against our string setting the appropriate value <br>    // for each platform that we find. <br>    // ====================================================== <br>    for (int iLoop = 0; iLoop &lt; aPlatforms.GetSize(); iLoop++) { <br>        pPlatform = (CPlatform *)aPlatforms[iLoop]; <br>        if (sBuff.Find( pPlatform-&gt;sPlatform ) != -1) { <br>            // Found a match. Get the bit value. <br>            dwPlatforms |= pPlatform-&gt;bPlatform; <br>        } <br>    } <br> <br>    return(dwPlatforms); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>// <br>// ==================================================================== <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXINPUT]; <br>    char szUser[CCH_MAXINPUT]; <br>    char szPasswd[CCH_MAXINPUT]; <br>    char szDatabase[CCH_MAXINPUT]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        printf("Connect to data source failed: %d\n", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char **argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>// ==================================================================== <br>BOOL DidRequestHelp( int argc, char **argv ) <br>{ <br>    if (argc == 2  &amp;&amp; (strcmp(argv[1], "-help") == 0)) { <br>        return(TRUE); <br>    } <br>    else { <br>        return(FALSE); <br>    } <br> <br>} <br> <br> <br> <br> <br>// ==================================================================== <br>// <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// ==================================================================== <br>void DisplayHelp() <br>{ <br>    printf("\n\n"); <br>    printf("***********************************************************\n"); <br>    printf("* pdf.exe:                                                *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* SMS API Example: Import a PDF file into an SMS database.*\n"); <br>    printf("*                                                         *\n"); <br>    printf("* This sample shows hows the SMS APIs can be used to      *\n"); <br>    printf("* import a pdf file.                                      *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* The user will be asked to provide the SMS database      *\n"); <br>    printf("* details, and then the name of a pdf file.               *\n"); <br>    printf("*                                                         *\n"); <br>    printf("*                                                         *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Syntax:                                                 *\n"); <br>    printf("*     pdf.exe [-help] file.pdf                            *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Switches:                                               *\n"); <br>    printf("*     -help       Display this help message.              *\n"); <br>    printf("*                                                         *\n"); <br>    printf("***********************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>// <br>// ==================================================================== <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br>} <br> <br> <br>// ==================================================================== <br>// <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char *pszMessage <br>//          The user prompt to display. <br>// <br>//      char *pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>// <br>// ==================================================================== <br>void InputString( const char *pszMessage, char *pszResult ) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br> <br> <br>#ifdef XXX <br>//************************************************************************** <br>// ViewFolder <br>// <br>//  Display the folder contents.  This version only displays the folder name <br>//  and type, number of scalars, and the scalars. Other information not <br>//  relevant. <br>// <br>//  NOTE: no error checking. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder to view. <br>// <br>// Returns: Nothing. <br>// <br>//************************************************************************** <br>void ViewFolder( HANDLE hFolder ) <br>{ <br>    char szFolderID[SMS_DATA_BUFF_SIZE + 1];        // This folder's ID. <br>    char szfType[SMS_DATA_BUFF_SIZE + 1];           // Folder's tag. <br>    DWORD fType;                        // Folder's type. <br>    DWORD ctScalars;                    // How many scalars in this folder. <br>    SMS_STATUS stat; <br> <br> <br>    // Get folder ID and type. <br>    // ----------------------- <br>    stat = SmsGetFolderID( hFolder, szFolderID ); <br>    if (stat == SMS_NEW_FOLDER) { <br>        strcpy( szFolderID, "New folder without an ID yet" ); <br> <br>    } <br>    else if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get folder ID", stat); <br>        strcpy( szFolderID, "Couldn't get the folder ID" ); <br>    } <br> <br>    printf("============== '%s' ===========\n", szFolderID); <br> <br>    stat = SmsGetFolderType( hFolder, &amp;fType, szfType ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get folder type", stat); <br>    } <br> <br>    printf("SCALARS FOR FOLDER '%s'\n", szFolderID); <br> <br>    // Get count of scalars. <br>    // --------------------- <br>    stat = SmsGetScalarCount( hFolder, &amp;ctScalars ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get scalar count", stat); <br>    } <br>    printf("'%s' (%s) contains %d scalars\n", szFolderID, szfType, ctScalars); <br> <br> <br>    // Display the scalars. <br>    // -------------------- <br>    DisplayScalars( hFolder ); <br> <br> <br>    // Get the folder count <br>    DWORD ctFolders; <br>    stat = SmsGetFolderCount(hFolder, F_ANY, &amp;ctFolders); <br>    printf("'%s' (%s) contains %d sub-folders\n", szFolderID, szfType, ctFolders); <br>    for (DWORD dwFolder = 0; dwFolder &lt; ctFolders; ++dwFolder) { <br>        printf("Getting subfolder\n"); <br>        HANDLE hSubFolder; <br>        stat = SmsGetNextFolder(hFolder, F_ANY, &amp;hSubFolder); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsGetNextFolder failed", stat); <br>            break; <br>        } <br> <br>        ViewFolder(hSubFolder); <br> <br>        // Close the sub-folder to avoid a memory leak. <br>        //============================================ <br>        stat = SmsCloseFolder(hSubFolder); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close an open folder", stat); <br>            break; <br>        } <br>    } <br> <br> <br>    SmsRewind(hFolder, RW_FOLDER | RW_SCALAR); <br> <br>}  /* ViewFolder */ <br> <br> <br>//************************************************************************* <br>// DisplayScalars <br>// <br>// Display a folder's scalars. <br>// <br>// Parameters: <br>//      HANDLE hfolder <br>//          This is the folder handle. <br>// <br>// Returns: Nothing. <br>// <br>// ==================================================================== <br>void DisplayScalars( HANDLE hFolder ) <br>{ <br>    SMS_STATUS stat = SMS_OK; <br>    SCALAR scalar; <br>    char *pszTime;          // For conversion of time scalars. <br> <br>    // The scalars do not have their own string value buffer, so <br>    // we allocate the buffers here and set pointers to them in the <br>    // scalar structure. <br>    //============================================================= <br>    char szName[SMS_DATA_BUFF_SIZE+1]; <br>    char szValue[SMS_DATA_BUFF_SIZE+1]; <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br>    scalar.pValue = NULL; <br> <br> <br>    while (1) { <br> <br>        scalar.dwLen = sizeof(szValue)-1;       // must tell him the size <br> <br>        stat = SmsGetNextScalar( hFolder, &amp;scalar); <br>        if (stat == SMS_NO_MORE_DATA) { <br>            break; <br>        } <br> <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { <br>            DisplaySmsError("SmsGetNextScalar failed in method DisplayScalars", stat); <br>            break; <br>        } <br> <br>        if (stat == SMS_MORE_DATA) { <br> <br>            printf("Receive buffer too small, should be %d. Data truncated\n", <br>                            scalar.dwLen); <br>        } <br> <br>        // Check scalar type, display accordingly. <br>        // --------------------------------------- <br>        switch (scalar.scType) { <br>        case SCALAR_STRING: <br>            printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); <br>            break; <br> <br>        case SCALAR_INT: <br>            printf("\t%30s: %ld\n", scalar.pszName, scalar.dwValue); <br>            break; <br> <br>        case SCALAR_TIME: <br>            // Check if we have a string equivalence. If so use it. <br>            if (scalar.bStringEquivalence) { <br>                printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); </code></pre>
<p>
</p>
<pre><code><br>            } else { <br>                pszTime = ctime( &amp;scalar.tValue ); <br>                printf("\t%30s: %s", scalar.pszName, pszTime); <br>            } <br>            break; <br> <br>        case SCALAR_BINARY: <br>            // In this sample we won't display the binary data. <br>            // Just tell the user its size. <br>            printf("\t%30s: (Binary - this is its size) %ld\n", scalar.pszName, scalar.dwLen); <br>            break; <br>        } <br>    } <br> <br>    // Why did we exit (other than no more scalars)? <br>    //============================================== <br>    if (stat != SMS_NO_MORE_DATA) { <br>        printf("Bad return from Scalar access: %d\n", stat); <br>    } <br> <br>    printf("\n"); <br>} <br>#endif  // XXX <br> <br> <br> <br>//************************************************************************** <br>// SetScalarString <br>// <br>// This function sets the value specified scalar to the given string <br>// value. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char *pszName <br>//          The name of the scalar. <br>//      const char *pszValue <br>//          The string that will be assigned to the scalar's value. <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// Note that the scalar specified must be of type SCALAR_STRING. <br>// <br>//*************************************************************************** <br>void SetScalarString(HANDLE hFolder, char* pszName, const char *pszValue) <br>{ <br>    SCALAR sc; <br>    sc.pszName  = pszName; <br>    sc.scType   = SCALAR_STRING; <br>    sc.pszValue = (char *)pszValue; <br> <br>    SMS_STATUS stat = SmsSetScalar(hFolder, &amp;sc); <br> <br>    if (stat != SMS_OK) { <br>        CString sErr = "SmsSetScalar ('"; <br>        sErr += pszName; <br>        sErr += "') failed"; <br>        DisplaySmsError( (const char *)sErr, stat); <br>    } <br> <br>} <br> <br> <br> <br> <br>//************************************************************************** <br>// SetScalarInt <br>// <br>// This function sets the value of the specified scalar to <br>// the given DWORD value. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder containing the scalar to modify. <br>//      char* pszName <br>//          The name of the scalar. <br>//      DWORD dwValue <br>//          The DWORD value to set the scalar to. <br>// <br>// Returns: <br>//      Nothing. <br>// <br>// Note that the scalar specified must be of type SCALAR_INT. <br>// <br>//*************************************************************************** <br>void SetScalarInt(HANDLE hFolder, char *pszName, DWORD dwValue) <br>{ <br>    SCALAR sc; <br>    sc.pszName = pszName; <br>    sc.scType = SCALAR_INT; <br>    sc.dwValue = dwValue; <br> <br> <br>    SMS_STATUS stat = SmsSetScalar(hFolder, &amp;sc); <br> <br>    if (stat != SMS_OK) { <br>        CString sErr = "SmsSetScalar ('"; <br>        sErr += pszName; <br>        sErr += "') failed"; <br>        DisplaySmsError( (const char *)sErr, stat); <br>    } <br>} <br> <br> <br>//************************************************************************** <br>// ViewFolder <br>// <br>//  Display the folder contents.  This version only displays the folder name <br>//  and type, number of scalars, and the scalars. Other information not <br>//  relevant. <br>// <br>//  NOTE: no error checking. <br>// <br>// Parameters: <br>//      HANDLE hFolder <br>//          The handle of the folder to view. <br>// <br>// Returns: Nothing. <br>// <br>//************************************************************************** <br>void ViewFolder( HANDLE hFolder ) <br>{ <br>    char szFolderID[SMS_DATA_BUFF_SIZE + 1];        // This folder's ID. <br>    char szfType[SMS_DATA_BUFF_SIZE + 1];           // Folder's tag. <br>    DWORD fType;                        // Folder's type. <br>    DWORD ctScalars;                    // How many scalars in this folder. <br>    SMS_STATUS stat; <br> <br> <br>    // Get folder ID and type. <br>    // ----------------------- <br>    stat = SmsGetFolderID( hFolder, szFolderID ); <br>    if (stat == SMS_NEW_FOLDER) { <br>        strcpy( szFolderID, "New folder without an ID yet" ); <br> <br>    } <br>    else if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get folder ID", stat); <br>        strcpy( szFolderID, "Couldn't get the folder ID" ); <br>    } <br> <br>    printf("============== '%s' ===========\n", szFolderID); <br> <br>    stat = SmsGetFolderType( hFolder, &amp;fType, szfType ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get folder type", stat); <br>    } <br> <br>    printf("SCALARS FOR FOLDER '%s'\n", szFolderID); <br> <br>    // Get count of scalars. <br>    // --------------------- <br>    stat = SmsGetScalarCount( hFolder, &amp;ctScalars ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("ViewFolder: can't get scalar count", stat); <br>    } <br>    printf("'%s' (%s) contains %d scalars\n", szFolderID, szfType, ctScalars); <br> <br> <br>    // Display the scalars. <br>    // -------------------- <br>    DisplayScalars( hFolder ); <br> <br> <br>    // Get the folder count <br>    DWORD ctFolders; <br>    stat = SmsGetFolderCount(hFolder, F_ANY, &amp;ctFolders); <br>    printf("'%s' (%s) contains %d sub-folders\n", szFolderID, szfType, ctFolders); <br>    for (DWORD dwFolder = 0; dwFolder &lt; ctFolders; ++dwFolder) { <br>        printf("Getting subfolder\n"); <br>        HANDLE hSubFolder; <br>        stat = SmsGetNextFolder(hFolder, F_ANY, &amp;hSubFolder); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsGetNextFolder failed", stat); <br>            break; <br>        } <br> <br>        ViewFolder(hSubFolder); <br> <br>        // Close the sub-folder to avoid a memory leak. <br>        //============================================ <br>        stat = SmsCloseFolder(hSubFolder); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Failed to close an open folder", stat); <br>            break; <br>        } <br>    } <br> <br> <br>    SmsRewind(hFolder, RW_FOLDER | RW_SCALAR); <br> <br>}  /* ViewFolder */ <br> <br> <br>//************************************************************************* <br>// DisplayScalars <br>// <br>// Display a folder's scalars. <br>// <br>// Parameters: <br>//      HANDLE hfolder <br>//          This is the folder handle. <br>// <br>// Returns: Nothing. <br>// <br>// ==================================================================== <br>void DisplayScalars( HANDLE hFolder ) <br>{ <br>    SMS_STATUS stat = SMS_OK; <br>    SCALAR scalar; <br>    char *pszTime;          // For conversion of time scalars. <br> <br>    // The scalars do not have their own string value buffer, so <br>    // we allocate the buffers here and set pointers to them in the <br>    // scalar structure. <br>    //============================================================= <br>    char szName[SMS_DATA_BUFF_SIZE+1]; <br>    char szValue[SMS_DATA_BUFF_SIZE+1]; <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br>    scalar.pValue = NULL; <br> <br> <br>    while (1) { <br> <br>        scalar.dwLen = sizeof(szValue)-1;       // must tell him the size <br> <br>        stat = SmsGetNextScalar( hFolder, &amp;scalar); <br>        if (stat == SMS_NO_MORE_DATA) { <br>            break; <br>        } <br> <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { <br>            DisplaySmsError("SmsGetNextScalar failed in method DisplayScalars", stat); <br>            break; <br>        } <br> <br>        if (stat == SMS_MORE_DATA) { <br> <br>            printf("Receive buffer too small, should be %d. Data truncated\n", <br>                            scalar.dwLen); <br>        } <br> <br>        // Check scalar type, display accordingly. <br>        // --------------------------------------- <br>        switch (scalar.scType) { <br>        case SCALAR_STRING: <br>            printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); <br>            break; <br> <br>        case SCALAR_INT: <br>            printf("\t%30s: %ld\n", scalar.pszName, scalar.dwValue); <br>            break; <br> <br>        case SCALAR_TIME: <br>            // Check if we have a string equivalence. If so use it. <br>            if (scalar.bStringEquivalence) { <br>                printf("\t%30s: %s\n", scalar.pszName, scalar.pszValue); <br> <br>            } else { <br>                pszTime = ctime( &amp;scalar.tValue ); <br>                printf("\t%30s: %s", scalar.pszName, pszTime); <br>            } <br>            break; <br> <br>        case SCALAR_BINARY: <br>            // In this sample we won't display the binary data. <br>            // Just tell the user its size. <br>            printf("\t%30s: (Binary - this is its size) %ld\n", scalar.pszName, scalar.dwLen); <br>            break; <br>        } <br>    } <br> <br>    // Why did we exit (other than no more scalars)? <br>    //============================================== <br>    if (stat != SMS_NO_MORE_DATA) { <br>        printf("Bad return from Scalar access: %d\n", stat); <br>    } <br> <br>    printf("\n"); <br>} <br> <br> <br>/* EOF: pdf.cpp */ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
