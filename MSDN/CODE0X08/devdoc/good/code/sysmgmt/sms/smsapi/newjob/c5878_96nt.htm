<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NEWJOB.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5879"></a>NEWJOB.CPP</h2>
<pre><code>// ==================================================================== <br>// <br>//  File: newjob.cpp <br>// <br>//  Copyright (C) 1994, 1995 by Microsoft Corporation. <br>// <br>//  Author: <br>//      Jonathan Shuval     Microsoft Corp. <br>// <br>// <br>//  This program illustrates the use of the SMS APIs to view, create <br>//  and delete jobs. <br>// <br>//  See the readme.txt file in this directory for more information. <br>// <br>// <br>// ==================================================================== <br> <br> <br> <br>// ==================================================================== <br>//  Includes. <br>// ==================================================================== <br>#include &lt;afx.h&gt; <br>#include &lt;smsapi.h&gt;                 // Header for the APIs. <br>#include &lt;time.h&gt;                   // for time functions. <br> <br>// Include the GetStatusName function. <br>// ------------------------------------- <br>#include "..\common\status.inc" <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Defines. <br>// <br>// ==================================================================== <br>#define CCH_MAXINPUT 256 <br> <br> <br> <br>// ==================================================================== <br>//  Local prototypes. <br>// ==================================================================== <br> <br> <br>// Display the folder's scalars. <br>// ------------------------------------------------------------- <br>void DisplayScalars( HANDLE hFolder ); <br> <br> <br>// Display a folder. <br>// ------------------------------------------------------------- <br>void ViewFolder( HANDLE hFolder ); <br> <br> <br>// Create a new folder. <br>// ------------------------------------------------------------- <br>void CreateNewFolder( HANDLE hParent ); <br> <br> <br>// Convert date string from "dd\mm\yy hh:mm" to time_t. <br>// ------------------------------------------------------------- <br>time_t ReadTime( char szTime[] ); <br> <br> <br>// Prompt the user for input and return the reply. <br>//------------------------------------------------ <br>void InputString(const char* pszMessage, char* pszResult); <br> <br> <br>// Connect to the SMS datasource. <br>//------------------------------ <br>HANDLE ConnectToDatasource(); <br> <br> <br> <br> <br>// Display the help message. <br>//========================= <br>void DisplayHelp(); <br> <br>// Display the greeting. <br>//====================== <br>void DisplayGreeting(); <br> <br> <br>// Check to see if there was a request for help <br>// on the command line. <br>//============================================== <br>BOOL DidRequestHelp(int argc, char** argv); <br> <br> <br> <br>// Display an error message with its SMS status value. <br>//==================================================== <br>void DisplaySmsError(const char* pszMessage, SMS_STATUS stat); <br> <br>// Get the string equivallent for an SMS status code. <br>//=================================================== <br>const char* GetStatusName(SMS_STATUS stat); <br> <br> <br> <br> <br> <br> <br>// ==================================================================== <br>//  The work starts here. <br>// ==================================================================== <br>void main(int argc, char** argv) <br>{ <br>    // Check to see if this is a request to display the help <br>    // screen.  If so, display it. Otherwise, display a greeting <br>    // banner. <br>    //========================================================= <br>    if (DidRequestHelp(argc, argv)) { <br>        DisplayHelp(); <br>        return; <br>    } <br>    else { <br>        DisplayGreeting(); <br>    } <br> <br> <br> <br> <br>    SMS_STATUS stat; <br>    HANDLE hConnect; <br>    HANDLE hContainer; <br> <br> <br>    //=========================================== <br>    // Connect to the SMS datasource. <br>    //=========================================== <br>    hConnect = ConnectToDatasource(); <br>    if (hConnect == NULL) { <br>        return; <br>    } <br> <br>    // Open job container. <br>    // =================== <br>    stat = SmsOpenContainer( C_JOB, hConnect, &amp;hContainer ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsOpenContainer failed", stat); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br> <br>    // Set filters. <br>    // ============ <br>    // None. <br> <br> <br>    // Select all folders matching our filters. <br>    // ======================================== <br>    stat = SmsPopulate( hContainer, POP_SYNC, NULL ); <br>    if (stat != SMS_OK &amp;&amp; stat != SMS_EMPTY) { <br>        DisplaySmsError("Bad return from SmsPopulate", stat); <br>        SmsCloseContainer( hContainer ); <br>        SmsDataSourceDisconnect( hConnect ); <br>        return; <br>    } <br> <br> <br> <br>    // Retrieve all the folders from the container and save them <br>    // away in a list. SmsGetFolderCount tells us how many folders <br>    // are in the container, use this value to allocate space for <br>    // the handles. <br>    // Don't close the container because it will be needed if we <br>    // want to create a job. <br>    // =========================================================== <br>    DWORD  numFolders; <br>    DWORD  dwI; <br>    HANDLE *phFolders; <br>    HANDLE hFolder; <br> <br>    SmsGetFolderCount( hContainer, F_ANY, &amp;numFolders); <br>    printf("==========  Container has %d folders  =========\n\n", numFolders ); <br> <br> <br>    // Allocate memory for the top-level folders. <br>    // ------------------------------------------ <br>    phFolders = (HANDLE *)malloc(numFolders * sizeof(HANDLE)); <br> <br>    // Open all top-level folders. <br>    // --------------------------- <br>    for (dwI = 0; dwI &lt; numFolders; dwI++) { <br> <br>        stat = SmsGetNextFolder( hContainer, F_ANY, &amp;hFolder ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("Error in retrieving a folder", stat); <br>            break; <br>        } <br> <br>        phFolders[dwI] = hFolder; <br>    } <br> <br> <br>    // Now we enter a loop asking the user whether they want to <br>    // view the next folder, delete the folder just displayed, <br>    // or create a new folder. <br>    // ========================================================= <br>    BOOL  done = FALSE; <br>    char  reply[10]; <br>    DWORD dwIndex = 0; <br>    char  szFolderID[SMS_DATA_BUFF_SIZE+1]; <br> <br>    // Display the first one (if it exists). That way we always <br>    // have a current folder. <br>    // If we don't have any then that's ok because the Delete <br>    // will fail like it's supposed to. <br>    // ======================================================== <br>    if (numFolders &gt; 0) { <br>        ViewFolder( phFolders[dwIndex] ); <br>    } <br> <br>    printf("You may now do one of the following:\n"); <br>    printf("View the Next folder, Delete the current folder, Create a new folder\n"); <br>    printf("Type X to exit\n"); <br> <br>    while (!done) { <br> <br>        printf("[NDCX]: "); <br>        gets(reply); <br> <br>        switch (reply[0]) { <br>        case 0: <br>        case 'N': case 'n': <br>            // =========== View next folder ==================== <br>            dwIndex++; <br>            if (dwIndex &lt; numFolders) { <br>                ViewFolder( phFolders[dwIndex] ); <br>            } else { <br>                printf("No more folders to view\n"); <br>            } <br>            break; <br> <br>        case 'D': case 'd': <br>            // =========== Delete current folder =============== <br>            // Check we have a folder to delete. <br>            if (dwIndex &gt;= numFolders) { <br>                printf("No folder to delete\n"); <br>                break; <br>            } <br> <br>            SmsGetFolderID( phFolders[dwIndex], szFolderID ); <br>            printf("Confirm deletion of folder \"%s\"? [y/n] ", szFolderID); <br>            gets(reply); <br>            if (reply[0] != 'y') { <br>                printf("Delete cancelled\n"); <br>                break; <br>            } <br> <br>            stat = SmsUnlinkFolder( phFolders[dwIndex] ); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError( "SmsUnlinkFolder failed", stat); <br>                break; <br>            } <br>            stat = SmsCommitFolder( phFolders[dwIndex] ); <br>            if (stat != SMS_OK) { <br>                DisplaySmsError("SmsCommitFolder error", stat); <br>                break; <br>            } <br> <br>            printf("Folder deleted\n"); <br>            break; <br> <br>        case 'C': case 'c': <br>            // =========== Create new folder =================== <br>            CreateNewFolder( hContainer ); <br>            break; <br> <br>        case 'X': case 'x': <br>            // Terminate. <br>            done = TRUE; <br>            break; <br> <br>        default: <br>            // print the message again. <br>            printf("Actions are: N(ext folder), D(elete folder), C(reate folder)\n"); <br>            printf("Type X to exit\n"); <br>            break; <br>        } <br>    } <br> <br> <br> <br> <br> <br>    // Close the container, and disconnect from datasource. <br>    // ---------------------------------------------------- <br>    SmsCloseContainer( hContainer ); <br>    stat = SmsDataSourceDisconnect( hConnect ); <br> <br> <br>    // Deallocate memory used for folder handles. <br>    // ------------------------------------------ <br>    free( phFolders ); <br> <br>}  /* main */ <br> <br> <br> <br> <br> <br>// ==================================================================== <br>// Display the folder contents. <br>// <br>//  This version only displays the folder name and type, number of <br>//  scalars, and the scalars. Other information not relevant. <br>// <br>//  NOTE: no error checking. <br>// <br>// ==================================================================== <br>void ViewFolder( HANDLE hFolder ) <br>{ <br>    char szFolderID[SMS_DATA_BUFF_SIZE+1];              // This folder's ID. <br>    char szfType[SMS_DATA_BUFF_SIZE+1];                 // Folder's tag. <br>    DWORD fType;                                        // Folder's type. <br>    DWORD ctScalars;                                    // How many scalars in this folder. <br>    SMS_STATUS stat; <br> <br>    // Get folder ID and type. <br>    // ----------------------- <br>    stat = SmsGetFolderID( hFolder, szFolderID ); <br>    // Test return. If this is a newly created folder that hasn't been <br>    // inserted into the datasource it will not yet have a valid ID. <br>    if (stat != SMS_OK) { <br>        strcpy(szFolderID, "&lt;New Job&gt;"); <br>    } <br>    stat = SmsGetFolderType( hFolder, &amp;fType, szfType ); <br> <br>    // Rewind the folder, just in case. <br>    // This allows us to re-examine a folder (ie call this multiple times). <br>    // ==================================================================== <br>    SmsRewind( hFolder, RW_ALL ); <br> <br>    // Get count of scalars. <br>    // --------------------- <br>    stat = SmsGetScalarCount( hFolder, &amp;ctScalars ); <br>    printf("%s (%s) contains %d scalars\n", szFolderID, szfType, ctScalars); <br> <br>    // Display the scalars. <br>    // -------------------- <br>    DisplayScalars( hFolder ); <br> <br>    printf("============== %s ===========\n", szFolderID); <br> <br>}  /* ViewFolder */ <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Create a new folder. <br>// <br>//  This is an example of how to create a folder. <br>// <br>//  There are several types of job folder. This function can create: <br>//      a run command on workstation job <br>//      a share package on server job <br>//      a remove package from server job. <br>// <br>// <br>// ==================================================================== <br> <br>void CreateNewFolder( HANDLE hParent ) <br>{ <br>    printf("This function allows the creation of one of:\n"); <br>    printf("\t\"Run command on Workstation\" job (w)\n"); <br>    printf("\t\"Share package on Server\" job    (s)\n"); <br>    printf("\t\"Remove package from Server\" job (r)\n"); <br> <br>    DWORD dwJobType; <br>    char szType[10]; <br>    BOOL done = FALSE; <br> <br>    while (!done) { <br>        done = TRUE; <br> <br>        printf("Enter one of [wsr]: "); <br>        gets(szType); <br> <br>        switch (szType[0]) { <br>        case 'w': case 'W': <br>            dwJobType = F_INSTALLJOB; <br>            break; <br> <br>        case 's': case 'S': <br>            dwJobType = F_SRVINSTALLJOB; <br>            break; <br> <br>        case 'r': case 'R': <br>            dwJobType = F_REMPKGJOB; <br>            break; <br> <br>        default: <br>            done = FALSE; <br>            printf("Invalid reply\n"); <br>        } <br>    } <br> <br>    HANDLE hNewFolder; <br>    SMS_STATUS stat; <br> <br>    // Note the id of "&lt;New Job&gt;", this is because for jobs, SMS assigns <br>    // the job id itself. <br> <br>    stat = SmsCreateFolder( hParent, dwJobType, "&lt;New Job&gt;", &amp;hNewFolder ); <br>    if (stat != SMS_OK) { <br>        DisplaySmsError("SmsCreateFolder fails", stat); <br>        return; <br>    } <br> <br>    // Use an objectity engine API to get information about the <br>    // folder and its scalars. <br>    // --------------------------------------------------------- <br>    FOLDER_INFO *pFInfo; <br>    stat = SmsDescribeFolder( T_FOLDER, dwJobType, &amp;pFInfo ); <br> <br>    SCALAR_INFO *pSInfo;        // The info structure contains a pointer <br>                                // to an array of SCALAR_INFOs. Each of these <br>                                // describes a scalar. <br>    SCALAR sc;                  // We create scalars using a SCALAR. <br> <br>    // Data for retrieving information from user for scalars. <br>    char szValue[SMS_DATA_BUFF_SIZE+1];     // User enters value here. <br>    time_t time;                            // Times are converted to t_time. <br> <br> <br>    // Loop through all the scalars, ask the user to supply a <br>    // value, but only if the scalar is modifiable. <br>    // ========================================================= <br> <br>    for (DWORD dwI = 0; dwI &lt; pFInfo-&gt;ctScalars; dwI++) { <br> <br>        pSInfo = &amp;pFInfo-&gt;pScalars[dwI]; <br> <br>        // Is scalar modifiable? <br>        if (pSInfo-&gt;fAccess == ACCESS_CREATE || pSInfo-&gt;fAccess == ACCESS_MODIFY) { <br> <br>            // Set up common fields in the scalar. <br>            // ----------------------------------- <br>            sc.pszName = pSInfo-&gt;szName; <br>            sc.scType  = pSInfo-&gt;scType; <br> <br>            char *pszType; <br> <br>            switch (sc.scType) { <br>            case SCALAR_STRING: <br>                pszType = "string";     break; <br> <br>            case SCALAR_INT: <br>                pszType = "integer";    break; <br> <br>            case SCALAR_TIME: <br>                pszType = "time";       break; <br> <br>            case SCALAR_BINARY: <br>                pszType = "binary";     break; <br>            } <br>            printf("Enter (%s) value for '%s': ", pszType, pSInfo-&gt;szName); <br> <br>            // Now we need to know what type this is (string, int etc) <br>            if (pSInfo-&gt;scType == SCALAR_STRING) { <br>                gets( szValue ); <br>                // store it directly <br>                sc.dwLen = sizeof(szValue)-1;   // -1 for terminating NULL. <br>                sc.pszValue = szValue; <br> <br>                stat = SmsSetScalar( hNewFolder, &amp;sc ); <br> <br> <br>            } else if (pSInfo-&gt;scType == SCALAR_INT) { <br>                gets( szValue ); <br>                // convert to int <br>                sc.dwValue = atol( szValue ); <br> <br>                stat = SmsSetScalar( hNewFolder, &amp;sc ); <br> <br> <br>            } else if (pSInfo-&gt;scType == SCALAR_TIME) { <br>                printf("Enter time in the form mm/dd/yy hh:mm "); <br>                gets( szValue ); <br>                // Only primitive checking <br>                time = ReadTime( szValue ); <br>                sc.tValue = time; <br> <br>                stat = SmsSetScalar( hNewFolder, &amp;sc ); <br> <br> <br>            } else if (pSInfo-&gt;scType == SCALAR_BINARY) { <br>                // Be simplistic about this. <br>                gets( szValue ); <br>                memcpy( sc.pValue, szValue, strlen(szValue) ); <br>                stat = SmsSetScalar( hNewFolder, &amp;sc ); <br>            } <br>        } <br> <br>    } <br> <br> <br>    // Now display it and ask user for confirmation of creation. <br>    // ========================================================= <br>    printf("Newly created folder:\n"); <br>    ViewFolder( hNewFolder ); <br>    printf("OK to link folder into parent [y/n]? "); <br>    char reply[10]; <br>    gets(reply); <br>    if (reply[0] == 'y') { <br>        // link it in to parent. <br>        stat = SmsLinkFolder( hNewFolder ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsLinkFolder error", stat); <br>            return; <br>        } <br> <br>        // write it back to data source. <br>        stat = SmsCommitFolder( hNewFolder ); <br>        if (stat != SMS_OK) { <br>            DisplaySmsError("SmsCommitFolder error", stat); <br>            return; <br>        } <br>        SmsGetFolderID( hNewFolder, szValue ); <br> <br>        char *pszType; <br>        switch (dwJobType) { <br>        case F_INSTALLJOB: <br>            pszType = "Workstation install job"; <br>            break; <br> <br>        case F_SRVINSTALLJOB: <br>            pszType = "Server share job"; <br>            break; <br> <br>        case F_REMPKGJOB: <br>            pszType = "Remove package job"; <br>            break; <br> <br>        } <br> <br>        printf("*****  %s %s created *****\n\n", pszType, szValue); <br> <br>        printf("View of new folder from the datasource...\n"); <br>        ViewFolder( hNewFolder ); <br>        printf("\n\n"); <br> <br>    } else { <br>        printf("Folder creation cancelled\n"); <br>    } <br> <br>} <br> <br> <br> <br>// ==================================================================== <br>// <br>//  Display all the scalars for the folder. <br>// <br>//  This example also shows how the scalar can detect that a buffer is <br>//  too small. <br>// ==================================================================== <br>void DisplayScalars( HANDLE hFolder ) <br>{ <br>    SMS_STATUS stat = SMS_OK; <br>    SCALAR scalar; <br>    char szName[SMS_DATA_BUFF_SIZE+1];       // buffer for name <br>    char szValue[SMS_DATA_BUFF_SIZE+1];      // buffer for value <br>    char *pszTime;          // For conversion of time scalars. <br> <br> <br>    scalar.pszName  = szName; <br>    scalar.pszValue = szValue; <br> <br> <br>    while (1) { <br> <br>        scalar.dwLen = sizeof(szValue)-1;       // must tell him the size <br> <br>        stat = SmsGetNextScalar( hFolder, &amp;scalar); <br>        if (stat != SMS_OK &amp;&amp; stat != SMS_MORE_DATA) { <br>            break; <br>        } <br> <br>        if (stat == SMS_MORE_DATA) { <br>            printf("Receive buffer too small, should be %d. Data truncated\n", <br>                            scalar.dwLen); <br>        } <br> <br>        // Check scalar type, display accordingly. <br>        // --------------------------------------- <br>        switch (scalar.scType) { <br>        case SCALAR_STRING: <br>            printf("\t%25s: %s\n", scalar.pszName, scalar.pszValue); <br>            break; <br> <br>        case SCALAR_INT: <br>            printf("\t%25s: %ld\n", scalar.pszName, scalar.dwValue); <br>            break; <br> <br>        case SCALAR_TIME: <br>            // If there is a string equivalence use it. <br>            if (scalar.bStringEquivalence) { <br>                printf("\t%25s: %s\n", scalar.pszName, scalar.pszValue); <br>            } else { <br>                pszTime = ctime( &amp;scalar.tValue ); <br>                printf("\t%25s: %s", scalar.pszName, pszTime); <br>            } <br>            break; <br> <br>        case SCALAR_BINARY: <br>            // Got binary data. <br>            // Just tell the user how much data there is. <br>            printf("\t%25s: Binary data %d bytes of data\n", <br>                    scalar.pszName, scalar.dwLen); <br>            break; <br>        } <br>    } <br> <br>    // Why did we exit (other than no more scalars)? <br>    // --------------------------------------------- <br>    if (stat != SMS_NO_MORE_DATA) { <br>        DisplaySmsError("Bad return from Scalar access", stat); <br>    } <br> <br>} <br> <br> <br> <br>// ******************************************************************** <br>//      Helper functions. <br>// ******************************************************************** <br> <br> <br>// ==================================================================== <br>//  Convert time string to time_t. Primitive checking only. <br>//  If there are any errors we print a wanring and set the date/time to <br>//  today. <br>// ==================================================================== <br>time_t ReadTime( char szTime[] ) <br>{ <br>    int mon, day, year, hour, min; <br>    time_t today; <br>    time( &amp;today ); <br> <br>    // Get the month (1..12) <br>    mon = (szTime[0] - '0') * 10 + (szTime[1]) - '0'; <br>    mon--; <br>    if (mon &lt; 0 || mon &gt; 11) { <br>        printf("Month wrong (valid 01-12)\n"); <br>        return(today); <br>    } <br> <br>    // Day (1..31) <br>    day = (szTime[3] - '0') * 10 + (szTime[4] - '0'); <br>    if (day &lt; 1 || day &gt; 31) { <br>        printf("Day wrong (Valid 01-07)\n"); <br>        return(today); <br>    } <br> <br>    // Year <br>    year = (szTime[6] - '0') * 10 + (szTime[7] - '0'); <br>    if (year &lt; 90 || year &gt; 99) { <br>        printf("Year wrong (Valid 90-99)\n"); <br>        return(today); <br>    } <br> <br>    // Hour (0..23) <br>    hour = (szTime[9] - '0') * 10 + (szTime[10] - '0'); <br>    if (hour &lt; 0 || hour &gt; 23) { <br>        printf("Hour wrong (Valid 00-23)\n"); <br>        return(today); <br>    } <br> <br>    // Minute (0..59) <br>    min = (szTime[12] - '0') * 10 + (szTime[13] - '0'); <br>    if (min &lt; 0 || min &gt; 59) { <br>        printf("Minute wrong (Valid 00-59)\n"); <br>        return(today); <br>    } <br> <br>    // Format the time, we want a time_t. <br>    struct tm theTime; <br>    theTime.tm_mon   = mon; <br>    theTime.tm_mday  = day; <br>    theTime.tm_year  = year; <br>    theTime.tm_hour  = hour; <br>    theTime.tm_min   = min; <br>    theTime.tm_sec   = 0; <br>    theTime.tm_isdst = -1; <br> <br>    time_t time = mktime( &amp;theTime ); <br>    return(time); <br> <br>} <br> <br> <br>//************************************************************************** <br>// InputString <br>// <br>// Prompt the user to input a string and return the string in the <br>// specified buffer. <br>// <br>// Parameters: <br>//      const char* pszMessage <br>//          The user prompt to display. <br>// <br>//      char* pszResult <br>//          Pointer to the buffer where the user's input will be returned. <br>// <br>// Returns; <br>//      The user's input is returned via the given buffer. <br>//*************************************************************************** <br>void InputString(const char* pszMessage, char* pszResult) <br>{ <br>    printf("%s: ", pszMessage); <br>    gets(pszResult); <br>} <br> <br> <br> <br> <br>//************************************************************************** <br>// ConnectToDatasource <br>// <br>// Get the datasource connection information from the user and use it <br>// to connect to the datasource. <br>// <br>// Parameters:  None. <br>// <br>// Returns: <br>//      The connection handle or NULL if the connection failed. <br>//*************************************************************************** <br>HANDLE ConnectToDatasource() <br>{ <br>    // Get the information we need to connect to the <br>    // data source from the user. <br>    //============================================== <br>    char szServer[CCH_MAXINPUT]; <br>    char szUser[CCH_MAXINPUT]; <br>    char szPasswd[CCH_MAXINPUT]; <br>    char szDatabase[CCH_MAXINPUT]; <br> <br>    printf("\n"); <br>    printf("**************************\n"); <br>    printf("* Connect to data source *\n"); <br>    printf("**************************\n"); <br>    InputString("SQL server name", szServer); <br>    InputString("SQL database name", szDatabase); <br>    InputString("User name for SQL server", szUser); <br>    InputString("Password for SQL server", szPasswd); <br>    printf("\n"); <br> <br> <br>    // Connect to a data source. SQL in this case. <br>    // =========================================== <br>    DATASOURCE dsParams; <br> <br>    dsParams.sqlParams.ds          = DB_SQL; <br>    dsParams.sqlParams.pszServer   = szServer; <br>    dsParams.sqlParams.pszUserName = szUser; <br>    dsParams.sqlParams.pszPasswd   = szPasswd; <br>    dsParams.sqlParams.pszDbName   = szDatabase; <br>    dsParams.sqlParams.pFunc       = NULL;         // No encryption. <br>    dsParams.sqlParams.pszKey      = ""; <br> <br>    HANDLE hConnect; <br>    SMS_STATUS stat; <br>    stat = SmsDataSourceConnect( &amp;dsParams, &amp;hConnect); <br> <br>    if (stat != SMS_OK) { <br>        hConnect = NULL; <br>        DisplaySmsError("Connect to data source failed", stat); <br>    } <br> <br>    return( hConnect ); <br>} <br> <br> <br> <br> <br>//********************************************************** <br>// DidRequestHelp <br>// <br>// Check the program's arguments to see if the user asked for <br>// the help screen to be displayed. <br>// <br>// Parameters: <br>//      int argc <br>//          The argc value from main(argc, argv) <br>// <br>//      char** argv <br>//          The argv value from main(argc, argv) <br>// <br>// Returns: <br>//      TRUE if command line parameters included a request <br>//      for help to be displayed. <br>// <br>//*********************************************************** <br>BOOL DidRequestHelp(int argc, char** argv) <br>{ <br>    const char* pszCommand = argv[1]; <br>    if (argc==2  &amp;&amp; (strcmp((const char*) argv[1], "-help")==0)) { <br>        return(TRUE); <br>    } <br>    else { <br>        return(FALSE); <br>    } <br>} <br> <br> <br> <br> <br>//********************************************************************** <br>// DisplayHelp <br>// <br>// This function displays the samples help screen. <br>// <br>// Parameters: <br>//      None <br>// <br>// Returns: <br>//      Nothing. <br>// <br>//********************************************************************* <br>void DisplayHelp() <br>{ <br>    printf("\n\n"); <br>    printf("***********************************************************\n"); <br>    printf("* newjob.exe:                                             *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* SMS API Example: view, create, and delete job folders.  *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* This sample illustrates the use of the SMS APIs in      *\n"); <br>    printf("* order to view create, and delete job folders.           *\n"); <br>    printf("* There are four types of job folders:                    *\n"); <br>    printf("*         Run command on Workstation job                  *\n"); <br>    printf("*         Share package on Server job                     *\n"); <br>    printf("*         Remove package from Server job                  *\n"); <br>    printf("*         System job                                      *\n"); <br>    printf("* All of these except system jobs can be created and      *\n"); <br>    printf("* deleted.                                                *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Syntax:                                                 *\n"); <br>    printf("*     newjob.exe [-help]                                  *\n"); <br>    printf("*                                                         *\n"); <br>    printf("* Switches:                                               *\n"); <br>    printf("*     -help       Display this help message.              *\n"); <br>    printf("*                                                         *\n"); <br>    printf("***********************************************************\n"); <br>    printf("\n"); <br>} <br> <br> <br> <br>//******************************************************************* <br>// DisplayGreeting <br>// <br>// Display the initial greeting banner. <br>// <br>// Parameters: <br>//     None. <br>// <br>// Returns: <br>//     Nothing. <br>//****************************************************************** <br>void DisplayGreeting() <br>{ <br>    // For this sample, the greeting is identical to the help screen. <br>    //=============================================================== <br>    DisplayHelp(); <br>} <br> <br> <br> <br> <br>/* EOF: newjob.cpp */ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
