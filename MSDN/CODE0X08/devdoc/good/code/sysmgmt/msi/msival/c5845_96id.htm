<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSIVAL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5845"></a>MSIVAL.CPP</h2>
<pre><code>#if 0  // makefile definitions, to build: %vcbin%\nmake -fMsiVal.cpp <br> <br># Copyright 1997 - 1998 Microsoft Corporation <br> <br>DESCRIPTION = Msi Database Validator Using External API <br>MODULENAME = MsiVal <br>SUBSYSTEM = console <br>FILEVERSION = Msi <br>!include &lt;MsiTool.Mak&gt; <br>!if 0  #nmake skips the rest of this file <br>#endif // end of makefile definitions <br> <br>// Required headers <br>#define WINDOWS_LEAN_AND_MEAN  // faster compile <br>#include &lt;windows.h&gt; <br> <br>#define IDS_NoError            0 <br>#define IDS_DuplicateKey       1 <br>#define IDS_Required           2 <br>#define IDS_BadLink            3 <br>#define IDS_Overflow           4 <br>#define IDS_Underflow          5 <br>#define IDS_NotInSet           6 <br>#define IDS_BadVersion         7 <br>#define IDS_BadCase            8 <br>#define IDS_BadGuid            9 <br>#define IDS_BadWildCard        10 <br>#define IDS_BadIdentifier      11 <br>#define IDS_BadLanguage        12 <br>#define IDS_BadFileName        13 <br>#define IDS_BadPath            14 <br>#define IDS_BadCondition       15 <br>#define IDS_BadFormatted       16 <br>#define IDS_BadTemplate        17 <br>#define IDS_BadDefaultDir      18 <br>#define IDS_BadRegPath         19 <br>#define IDS_BadCustomSource    20  <br>#define IDS_BadProperty        21 <br>#define IDS_MissingData        22 <br>#define IDS_BadCabinet         23 <br>#define IDS_BadCategory        24 <br>#define IDS_BadKeyTable        25 <br>#define IDS_BadMaxMinValues    26 <br>#define IDS_BadShortcut        27 <br>#define IDS_StringOverflow     28 <br>#define IDS_UndefinedError     29 <br>#define IDS_MissingEntry       30 <br>#define IDS_BadLocalizeAttrib  31 <br> <br>#ifndef RC_INVOKED    // start of source code <br>#include &lt;stdio.h&gt;   // printf/wprintf <br>#include &lt;tchar.h&gt;   // define UNICODE=1 on nmake command line to build UNICODE <br>#include "MsiQuery.h" <br> <br>TCHAR*  g_szErrorContext = 0; // Global error string <br>HANDLE g_hStdOut = 0; // Global handle <br> <br>// Function prototypes <br>void Display(LPCTSTR szMessage); <br>void CheckMsi(UINT iStat, TCHAR* szContext); <br>BOOL CheckMissingColumns(MSIHANDLE hDatabase); <br>BOOL Validate(MSIHANDLE hDatabase); <br>BOOL ValidateOrganizationInstallSequence(MSIHANDLE hDatabase); <br>BOOL ValidateRequired(MSIHANDLE hDatabase); <br>BOOL InDialogTable(MSIHANDLE hDatabase, LPCTSTR szAction); <br>BOOL InCustomActionTable(MSIHANDLE hDatabase, LPCTSTR szAction); <br>BOOL ValidateInstallSequence(MSIHANDLE hDatabase); <br> <br>// SQL queries <br>const TCHAR szSQLTableCatalog[]         = TEXT("SELECT `Name` FROM `_Tables`"); <br>const TCHAR szSQLTable[]                = TEXT("SELECT * FROM "); <br>const TCHAR szSQLColMissing[]           = TEXT("SELECT `Table`, `Number`, `Name`, `Type` FROM `_Columns` WHERE `Table`=? AND `Name`=?"); <br>const TCHAR szSQLValidationTable[]      = TEXT("SELECT `Table`, `Column` FROM `_Validation`"); <br>const TCHAR szSQLInstallSeqTable[]      = TEXT("SELECT `Action`, `Sequence` FROM `InstallSequence` ORDER BY `Sequence`"); <br>const TCHAR szSQLInstallValidate[]      = TEXT("SELECT `Action`, `SectionFlag` FROM `_InstallValidate` WHERE `Action`=?"); <br>const TCHAR szSQLRequiredTable[]        = TEXT("SELECT `Table`, `Value`, `KeyCount` FROM `_Required` ORDER BY `Table`"); <br>const TCHAR szSQLDialogTable[]          = TEXT("SELECT `Dialog` FROM `Dialog` WHERE `Dialog`=?"); <br>const TCHAR szSQLCustomActionTable[]    = TEXT("SELECT `Action` FROM `CustomAction` WHERE `Action`=?"); <br>const TCHAR szSQLSeqTableQueryNotNull[] = TEXT("SELECT `Dependent` FROM `_Sequence` WHERE `Action`=? AND `Marker`=210  AND `After`=0"); <br>const TCHAR szSQLSeqTableQueryNull[]    = TEXT("SELECT `Dependent` FROM `_Sequence` WHERE `Action`=? AND `Marker`=0 AND `After`=1 AND `Optional`=0");  <br>const TCHAR szSQLSeqTableAddCol[]       = TEXT("ALTER TABLE `_Sequence` ADD `Marker` SHORT TEMPORARY"); <br>const TCHAR szSQLSeqMarkerInit[]        = TEXT("UPDATE `_Sequence` SET `Marker`=0"); <br> <br>const int iMaxNumColumns = 32; <br>const int cchBuffer = 4096; <br>const int cbName = 64; <br> <br>const int cchDisplayBuf = 4096; <br> <br>// InstallSequence sectional constants <br>const int isdSearch         = 0x00000001L; <br>const int isdCosting        = 0x00000002L; <br>const int isdSelection      = 0x00000004L; <br>const int isdAdvertise      = 0x00000008L; // before execute because must be called before InstallValidate <br>const int isdExecution      = 0x00000010L; <br> <br>// InstallSequence sectional devisors <br>const TCHAR szEndSearch[]      = TEXT("CostInitialize");  // end Search, begin Costing <br>const TCHAR szEndCosting[]     = TEXT("CostFinalize");    // end Costing, begin Selection <br>const TCHAR szEndSelection[]   = TEXT("RegisterProduct"); // end Selection, begin Advertise <br>const TCHAR szEndAdvertise[]   = TEXT("InstallValidate"); // end Advertise, begin Execution <br>const TCHAR szReset[]          = TEXT("ExecuteFinalize"); // reset to Search <br> <br>// InstallSequence divisions <br>const TCHAR szSearch[]         = TEXT("Search"); <br>const TCHAR szCosting[]        = TEXT("Costing"); <br>const TCHAR szSelection[]      = TEXT("Selection"); <br>const TCHAR szAdvertise[]      = TEXT("Advertise"); <br>const TCHAR szExecution[]      = TEXT("Execution"); <br> <br>//_______________________________________________________________________________________________________________ <br>// <br>// _tmain -- UNICODE/ANSI main function <br>//  <br>// Driver routine <br>//_______________________________________________________________________________________________________________ <br> <br>extern "C" int __cdecl _tmain(int argc, TCHAR* argv[]) <br>{ <br>// Determine handle <br>g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE); <br>if (g_hStdOut == INVALID_HANDLE_VALUE) <br>g_hStdOut = 0;  // non-zero if stdout redirected or piped <br> <br>// Bool to allow user to specify option to turn OFF InstallSequence and Required Validation <br>//!! So that databases won't fail if don't have the _InstallValidate and/or _Required tables <br>BOOL fOff = FALSE; <br> <br>if (argc != 2 &amp;&amp; argc != 3) <br>{ <br>_tprintf(TEXT("USAGE:\n msival.exe {database}\n msival.exe {database} -OFF")); <br>return 1; <br>} <br> <br>if (argc == 2 &amp;&amp; (lstrcmp(argv[1],TEXT("-?")) == 0 || lstrcmp(argv[1],TEXT("/?")) == 0)) <br>{ <br>                _tprintf(TEXT("USAGE:\n msival.exe {database}\n") <br>                         TEXT("msival.exe {database} -OFF\n") <br>                         TEXT("NOTE:\n") <br>                         TEXT(" For validation to proceed. . .\n") <br>                                 TEXT("\tTables required:\n") <br>                                 TEXT("\t _Validation (always)\n") <br>                                 TEXT("\t _InstallValidate (unless -OFF)\n") <br>                                 TEXT("\t _Required (unless -OFF)\n") <br>                                 TEXT("\t _Sequence (unless -OFF)\n")); <br>return 0; <br>} <br> <br>if (argc == 3) <br>{ <br>if (lstrcmp(argv[2],TEXT("-OFF")) == 0 || lstrcmp(argv[2],TEXT("/OFF")) == 0 <br>|| lstrcmp(argv[2],TEXT("-off")) == 0 || lstrcmp(argv[2],TEXT("/off")) == 0) <br>fOff = TRUE; <br>else <br>{ <br>_tprintf(TEXT("USAGE:\n msival.exe {database} -OFF\n")); <br>return 0; <br>} <br>} <br> <br>BOOL fDataValid = TRUE; <br>BOOL fColValid  = TRUE; <br>BOOL fSeqOrgValid  = TRUE; <br>BOOL fSeqOrderValid = TRUE; <br>BOOL fReqValid  = TRUE; <br>try <br>{ <br>PMSIHANDLE hDatabase; <br>CheckMsi(MsiOpenDatabase(argv[1],MSIDBOPEN_READONLY,&amp;hDatabase),TEXT("OpenDatabase")); <br>_tprintf(TEXT("\nINFO: Validating for missing columns. . .\n\n")); <br>fColValid = CheckMissingColumns(hDatabase); <br>_tprintf(TEXT("\nINFO: Validating data and foreign keys. . .\n\n")); <br>fDataValid = Validate(hDatabase); <br>if (fOff) <br>{ <br>// Print out warning of database not exactly valid since skipping these validations <br>_tprintf(TEXT("WARNING!\n Skipping InstallSequence and Required Validation.\n  Database may not be completely valid\n")); <br>} <br>else <br>{ <br>_tprintf(TEXT("\nINFO: Validating Install Sequence Table Organization. . .\n\n")); <br>fSeqOrgValid = ValidateOrganizationInstallSequence(hDatabase); <br>_tprintf(TEXT("\nINFO: Validating Sequence of Actions In Install Sequence Table. . .\n\n")); <br>fSeqOrderValid = ValidateInstallSequence(hDatabase); <br>_tprintf(TEXT("\nINFO: Validating Required Values. . .\n\n")); <br>fReqValid = ValidateRequired(hDatabase); <br>} <br>if (fDataValid &amp;&amp; fColValid &amp;&amp; fSeqOrgValid &amp;&amp; fReqValid &amp;&amp; fSeqOrderValid) <br>_tprintf(TEXT("Database is valid: %s"), argv[1]); <br>} <br>catch (UINT iError) <br>{ <br>_tprintf(TEXT("\n%s error %i"), g_szErrorContext, iError); <br>MsiCloseAllHandles(); <br>return 1; <br>} <br>catch (...) <br>{ <br>_tprintf(TEXT("\n%s"), TEXT("Unhandled exception")); <br>MsiCloseAllHandles(); <br>return 99; <br>} <br>int iOpenHandles = MsiCloseAllHandles();  // diagnostic check only <br>if (iOpenHandles != 0) <br>_tprintf(TEXT("\n%i Handle(s) not closed"), iOpenHandles); <br>return (fDataValid &amp;&amp; fColValid &amp;&amp; fSeqOrgValid &amp;&amp; fReqValid &amp;&amp; fSeqOrderValid) ? 0 : 1; <br>} <br> <br> <br>void CheckMsi(UINT iStat, TCHAR* szContext) <br>/*---------------------------------------------------------------------------------- <br>CheckMsi -- Routine to check return status for error and throw exception if error. <br>  Arguments: <br>iStat -- error status <br>szContext -- error string <br>  Returns: <br>none, but throws error if one <br>-------------------------------------------------------------------------------------*/ <br>{ <br>if (iStat != ERROR_SUCCESS) <br>{ <br>g_szErrorContext = szContext; <br>throw iStat; <br>} <br>} <br> <br>BOOL CheckMissingColumns(MSIHANDLE hDatabase) <br>/*--------------------------------------------------------------------- <br>CheckMissingColumns -- used _Validation table and _Columns catalog to <br> determine if any columns/tables are not listed.  All columns in <br> _Validation table must be listed in the _Columns catalog.  If a column <br> is optional and not used in the database, then it should not be found <br> in the _Validation table or the _Columns catalog.  Normal validation <br> catches the instance where a column is defined in the _Columns catalog <br> but not in the _Validation table. <br>---------------------------------------------------------------------*/ <br>{ <br>PMSIHANDLE hValidationView   = 0; <br>PMSIHANDLE hColCatalogView   = 0; <br>PMSIHANDLE hValidationRecord = 0; <br>PMSIHANDLE hColCatalogRecord = 0; <br>PMSIHANDLE hExecRecord       = 0; <br> <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLColMissing, &amp;hColCatalogView), TEXT("OpenColumnCatalogView")); <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLValidationTable, &amp;hValidationView), TEXT("OpenValidationTableView")); <br> <br>UINT iRet = 0; <br>TCHAR szTable[cbName] = {0}; <br>TCHAR szColumn[cbName] = {0}; <br>unsigned long cchTableBuf = sizeof(szTable)/sizeof(TCHAR); <br>unsigned long cchColumnBuf = sizeof(szColumn)/sizeof(TCHAR); <br>BOOL fStat = TRUE; <br> <br>hExecRecord = MsiCreateRecord(2); <br>CheckMsi(MsiViewExecute(hValidationView, 0), TEXT("ExecuteValidationView")); <br>for (;;) <br>{ <br>iRet = MsiViewFetch(hValidationView, &amp;hValidationRecord); <br>if (iRet == ERROR_NO_MORE_ITEMS || !hValidationRecord) <br>break; <br>CheckMsi(iRet, TEXT("ColumnCatalogFetch")); <br>CheckMsi(MsiRecordGetString(hValidationRecord, 1, szTable, &amp;cchTableBuf), TEXT("GetTableName")); <br>cchTableBuf = sizeof(szTable)/sizeof(TCHAR); <br>CheckMsi(MsiRecordGetString(hValidationRecord, 2, szColumn, &amp;cchColumnBuf), TEXT("GetColumnName")); <br>cchColumnBuf = sizeof(szColumn)/sizeof(TCHAR); <br>CheckMsi(MsiRecordSetString(hExecRecord, 1, szTable), TEXT("SetTableName")); <br>CheckMsi(MsiRecordSetString(hExecRecord, 2, szColumn), TEXT("SetColumnName")); <br>CheckMsi(MsiViewExecute(hColCatalogView, hExecRecord), TEXT("ExecuteColumnCatalogView")); <br>iRet = MsiViewFetch(hColCatalogView, &amp;hColCatalogRecord); <br>if (iRet == ERROR_NO_MORE_ITEMS || !hColCatalogRecord) <br>{ <br>// Error --&gt; Missing from database <br>TCHAR szMsgBuf[150]; <br>const TCHAR* szMessage = (TCHAR*)IDS_MissingEntry; <br>const TCHAR** pszMsg; <br>pszMsg = &amp;szMessage; <br>::LoadString(0, *(unsigned*)pszMsg, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)); <br>*pszMsg = szMsgBuf; <br>_tprintf(TEXT("Table.Column: %s.%s Message: %s\n"), szTable, szColumn, szMsgBuf); <br>fStat = FALSE; <br>} <br>CheckMsi(MsiViewClose(hColCatalogView), TEXT("CloseView")); <br>} <br>MsiViewClose(hValidationView); <br> <br>return fStat; <br>} <br> <br>BOOL InDialogTable(MSIHANDLE hDatabase, LPCTSTR szAction) <br>{ <br>PMSIHANDLE hviewDialogTable = 0; <br>PMSIHANDLE hrecExecute      = 0; <br>PMSIHANDLE hrecFetch        = 0; <br> <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLDialogTable, &amp;hviewDialogTable), TEXT("DialogTableOpenView")); <br>hrecExecute = MsiCreateRecord(1); <br>CheckMsi(hrecExecute == NULL, TEXT("CreateRecord")); <br>CheckMsi(MsiRecordSetString(hrecExecute, 1, szAction), TEXT("RecordSetString")); <br>CheckMsi(MsiViewExecute(hviewDialogTable, hrecExecute), TEXT("DialogTableViewExecute")); <br>UINT iStat = MsiViewFetch(hviewDialogTable, &amp;hrecFetch); <br>CheckMsi(MsiViewClose(hviewDialogTable), TEXT("CloseDialogTableView")); <br>if (iStat == ERROR_SUCCESS &amp;&amp; hrecFetch != 0) <br>return TRUE; <br>return FALSE; <br>} <br> <br>BOOL InCustomActionTable(MSIHANDLE hDatabase, LPCTSTR szAction) <br>{ <br>PMSIHANDLE hviewCustomActionTable = 0; <br>PMSIHANDLE hrecExecute            = 0; <br>PMSIHANDLE hrecFetch              = 0; <br> <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLCustomActionTable, &amp;hviewCustomActionTable), TEXT("CustomActionTableOpenView")); <br>hrecExecute = MsiCreateRecord(1); <br>CheckMsi(hrecExecute == NULL, TEXT("CreateRecord")); <br>CheckMsi(MsiRecordSetString(hrecExecute, 1, szAction), TEXT("RecordSetString")); <br>CheckMsi(MsiViewExecute(hviewCustomActionTable, hrecExecute), TEXT("CustomActionTableViewExecute")); <br>UINT iStat = MsiViewFetch(hviewCustomActionTable, &amp;hrecFetch); <br>CheckMsi(MsiViewClose(hviewCustomActionTable), TEXT("CloseCustomActionTableView")); <br>if (iStat == ERROR_SUCCESS &amp;&amp; hrecFetch != 0) <br>return TRUE; <br>return FALSE; <br>} <br> <br>BOOL ValidateOrganizationInstallSequence(MSIHANDLE hDatabase) <br>/*--------------------------------------------------------------------------------------- <br>ValidateOrganizationInstallSequence -- Routine to validate InstallSequence table of database.  Uses <br>the _InstallValidate table as the basis for the validation. <br>-----------------------------------------------------------------------------------------*/ <br>{ <br>PMSIHANDLE hviewInstallTable    = 0; <br>PMSIHANDLE hviewValInstallTable = 0; <br>PMSIHANDLE hrecValExecute       = 0; <br>PMSIHANDLE hrecInstallFetch     = 0; <br>PMSIHANDLE hrecValFetch         = 0; <br> <br>int isd = isdSearch; // initialize section definition to Search <br> <br>BOOL fValid = TRUE; // validation status <br>BOOL fRequireExecute = FALSE; // if script operations, must call ExecuteFinalize <br> <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLInstallSeqTable, &amp;hviewInstallTable), TEXT("OpenView on InstallSequence table")); <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLInstallValidate, &amp;hviewValInstallTable), TEXT("OpenView on _InstallValidate table")); <br>CheckMsi(MsiViewExecute(hviewInstallTable, 0), TEXT("ExecuteView InstallSequence view")); <br> <br>hrecValExecute = MsiCreateRecord(1); <br>CheckMsi(hrecValExecute == NULL, TEXT("CreateRecord")); <br>UINT iRet = ERROR_SUCCESS; <br>while ((iRet = MsiViewFetch(hviewInstallTable, &amp;hrecInstallFetch)) != ERROR_NO_MORE_ITEMS) <br>{ <br>CheckMsi(iRet, TEXT("InstallSequenceTableFetch")); <br>if (!hrecInstallFetch) <br>break; <br>TCHAR szAction[255] = {0}; <br>DWORD cbAction = sizeof(szAction)/sizeof(TCHAR); <br>CheckMsi(MsiRecordGetString(hrecInstallFetch, 1, szAction, &amp;cbAction), TEXT("InstallFetchRecGetString Error")); <br>CheckMsi(MsiRecordSetString(hrecValExecute, 1, szAction), TEXT("ValExecuteRecSetString Error")); <br>CheckMsi(MsiViewExecute(hviewValInstallTable, hrecValExecute), TEXT("Execute _InstallValidate view")); <br> <br>// Determine if have to switch the current section state <br>// Depends on a certain action defined as the boundary <br>// This action is required in the InstallSequence table -- CostInitialize, CostFinalize, InstallValidate <br>// ExecuteFinalize can cause a reset so you execute one script and then continue again <br>// ExecuteFinalize must be called if any execution operations exist <br>if (lstrcmp(szAction, szEndSearch) == 0) <br>isd = isdCosting; <br>else if (lstrcmp(szAction, szEndCosting) == 0) <br>isd = isdSelection; <br>else if (lstrcmp(szAction, szEndSelection) == 0) <br>isd = isdAdvertise; <br>else if (lstrcmp(szAction, szEndAdvertise) == 0) <br>isd = isdExecution; <br>else if (lstrcmp(szAction, szReset) == 0) <br>{ <br>if (fRequireExecute) <br>fRequireExecute = FALSE; <br>else <br>{ <br>TCHAR szError[cchBuffer] = {0}; <br>wsprintf(szError, TEXT("ERROR: Action: '%s' Can Only Be Called When Script Operations Exist To Be Executed\n"), szAction); <br>Display(szError); <br>} <br>isd = isdSearch; // reset to search <br>} <br> <br>// Validate action, using the _InstallValidate table to obtain the section mask to which <br>// the action belongs and then comparing with the current section state <br>if ((iRet = MsiViewFetch(hviewValInstallTable, &amp;hrecValFetch)) == ERROR_NO_MORE_ITEMS) <br>{ <br>// Action not found in _InstallValidate table <br>// Check to see if CustomAction (located in CustomAction table) or Dialog (located in Dialog table) <br>if (!InDialogTable(hDatabase, szAction) &amp;&amp; !InCustomActionTable(hDatabase, szAction)) <br>{ <br>TCHAR szError[cchBuffer] = {0}; <br>wsprintf(szError, TEXT("ERROR: Action: '%s' -- Not in _InstallValidate, CustomAction or Dialog tables\n"), szAction); <br>Display(szError); <br>fValid = FALSE; <br>} <br>} <br>else <br>{ <br>// Action found in _InstallValidate table <br>// Obtain the SectionFlag <br>// Compare the SectionFlag to the current flag and determine if match <br>// If not match, then ERROR --&gt; incorrect section (print action, current section, correct section) <br>CheckMsi(iRet, TEXT("_InstallValidateFetch Error")); <br>int iSection = MsiRecordGetInteger(hrecValFetch, 2); <br>CheckMsi(iSection == MSI_NULL_INTEGER, TEXT("ValFetchRecGetInteger")); <br>if (iSection &amp; isd) <br>{ <br>// Action located in correct section, found <br>if (iSection == isdExecution || iSection == isdAdvertise) <br>fRequireExecute = TRUE; <br>} <br>else <br>{ <br>// Action not in correct section <br>// Print out error --&gt; action, current section, correct section <br>TCHAR szError[cchBuffer] = {0}; <br>TCHAR szCurrentSect[cchBuffer] = {0}; <br>TCHAR szCorrectSect[cchBuffer] = {0}; <br>switch (isd) <br>{ <br>case isdSearch:    lstrcpy(szCurrentSect, szSearch);    break; <br>case isdCosting:   lstrcpy(szCurrentSect, szCosting);   break; <br>case isdSelection: lstrcpy(szCurrentSect, szSelection); break; <br>case isdAdvertise: lstrcpy(szCurrentSect, szAdvertise); break; <br>case isdExecution: lstrcpy(szCurrentSect, szExecution); break; <br>} <br>switch (iSection) <br>{ <br>case isdSearch:    lstrcpy(szCorrectSect, szSearch);    break; <br>case isdCosting:   lstrcpy(szCorrectSect, szCosting);   break; <br>case isdSelection: lstrcpy(szCorrectSect, szSelection); break; <br>case isdAdvertise: lstrcpy(szCorrectSect, szAdvertise); break; <br>case isdExecution: lstrcpy(szCorrectSect, szExecution); break; <br>} <br>wsprintf(szError, TEXT("ERROR: Action: '%s' CurrentSection: '%s' CorrectSection: '%s'\n"), szAction, szCurrentSect, szCorrectSect); <br>Display(szError); <br>fValid = FALSE; <br>} <br>} <br>CheckMsi(MsiViewClose(hviewValInstallTable), TEXT("ValInstallTableViewClose")); <br>} <br>if (fRequireExecute) <br>{ <br>TCHAR szError[cchBuffer] = {0}; <br>wsprintf(szError, TEXT("ERROR: ExecuteFinalize must be called as there are script operations\n")); <br>Display(szError); <br>fValid = FALSE; <br>} <br>return fValid; <br>} <br> <br> <br>BOOL ValidateRequired(MSIHANDLE hDatabase) <br>/*----------------------------------------------------------------------------------- <br>ValidateRequired -- Uses the _Required table and checks the tables listed for the <br>'required' values that are listed in the table. <br> <br>-------------------------------------------------------------------------------------*/ <br>{ <br>PMSIHANDLE hviewRequiredTable = 0; <br>PMSIHANDLE hviewTable         = 0; <br>PMSIHANDLE hrecTableExecute   = 0; <br>PMSIHANDLE hrecRequiredFetch  = 0; <br>PMSIHANDLE hrecTableFetch     = 0; <br>PMSIHANDLE hrecColInfo        = 0; <br> <br>BOOL fValid = TRUE; <br>BOOL fFirstRun = TRUE; <br>UINT iStat = ERROR_SUCCESS; <br> <br>TCHAR szPrevTable[100] = {0}; <br>TCHAR szTable[100] = {0}; <br>TCHAR szValue[256] = {0}; <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLRequiredTable, &amp;hviewRequiredTable), TEXT("OpenViewRequiredTable")); <br>CheckMsi(MsiViewExecute(hviewRequiredTable, 0), TEXT("RequiredTableViewExecute")); <br>while ((iStat = MsiViewFetch(hviewRequiredTable, &amp;hrecRequiredFetch)) != ERROR_NO_MORE_ITEMS) <br>{ <br>CheckMsi(iStat, TEXT("RequiredTableViewFetch")); <br>if (!hrecRequiredFetch) <br>break; <br>int cPrimaryKeys = MsiRecordGetInteger(hrecRequiredFetch, 3); <br>DWORD cbTable = sizeof(szTable)/sizeof(TCHAR); <br>DWORD cbValue = sizeof(szValue)/sizeof(TCHAR); <br>CheckMsi(MsiRecordGetString(hrecRequiredFetch, 1, szTable, &amp;cbTable), TEXT("RequiredTableRecordGetString")); <br>CheckMsi(MsiRecordGetString(hrecRequiredFetch, 2, szValue, &amp;cbValue), TEXT("RequiredTableRecordGetString")); <br>if (fFirstRun) <br>fFirstRun = FALSE; <br>else <br>CheckMsi(MsiViewClose(hviewTable), TEXT("TableViewClose")); <br>hrecTableExecute = MsiCreateRecord(cPrimaryKeys); <br>if (hrecTableExecute == 0) <br>return FALSE; <br> <br>if (lstrcmp(szPrevTable, szTable) != 0) <br>{ <br>// New table, need to open a new view. <br>TCHAR szSQL[1024] = {0}; <br>PMSIHANDLE hrecPrimaryKeys = 0; <br>TCHAR szKeyColName[50] = {0}; <br>DWORD cbKey = sizeof(szKeyColName)/sizeof(TCHAR); <br>CheckMsi(MsiDatabaseGetPrimaryKeys(hDatabase, szTable, &amp;hrecPrimaryKeys), TEXT("DatabaseGetPrimaryKeys")); <br>CheckMsi(MsiRecordGetString(hrecPrimaryKeys, 1, szKeyColName, &amp;cbKey), TEXT("PrimaryKeysRecordGetString")); <br>CheckMsi(MsiRecordGetFieldCount(hrecPrimaryKeys) != cPrimaryKeys, TEXT("PrimaryKeyCountWrong")); <br>CheckMsi(cPrimaryKeys == ERROR_INVALID_HANDLE, TEXT("PrimaryKeysRecordGetFieldCount")); <br> <br>// Develop query of table to be checked <br>int cchWritten = wsprintf(szSQL, TEXT("SELECT * FROM `%s` WHERE `%s`=?"), szTable, szKeyColName); <br>int cchAddition = cchWritten; <br>for (int i = 2; i &lt;= cPrimaryKeys; i++) <br>{ <br>cbKey = sizeof(szKeyColName)/sizeof(TCHAR); <br>CheckMsi(MsiRecordGetString(hrecPrimaryKeys, i, szKeyColName, &amp;cbKey), TEXT("PrimaryKeysRecordGetString")); <br>cchWritten = wsprintf(szSQL + cchAddition, TEXT(" AND `%s`=?"), szKeyColName); <br>cchAddition = cchWritten; <br>} <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQL, &amp;hviewTable), TEXT("DatabaseOpenView")); <br>CheckMsi(MsiViewGetColumnInfo(hviewTable, MSICOLINFO_TYPES, &amp;hrecColInfo), TEXT("GetColumnInfo")); <br>lstrcpy(szPrevTable, szTable); <br>} <br> <br>// Fill in execute record with the key data values <br>TCHAR* pch = szValue; <br>TCHAR szKeyValue[256] = {0}; <br>TCHAR szType[32] = {0}; <br>DWORD cbType = sizeof(szType)/sizeof(TCHAR); <br>int nDex = 0; <br>for (int j = 1; j &lt;= cPrimaryKeys; j++) <br>{ <br>while (pch != 0 &amp;&amp; *pch != TEXT(';') &amp;&amp;  *pch != 0) <br>szKeyValue[nDex++] = *pch++; <br>szKeyValue[nDex] = 0; <br>pch++; // for ; or 0 <br>cbType = sizeof(szType)/sizeof(TCHAR); <br>CheckMsi(MsiRecordGetString(hrecColInfo, j, szType, &amp;cbType), TEXT("ColInfoGetString")); <br>if (szType != 0 &amp;&amp; *szType == TEXT('s')) <br>CheckMsi(MsiRecordSetString(hrecTableExecute, j, szKeyValue), TEXT("TableExecuteRecordSetString")); <br>else // integer primary key <br>CheckMsi(MsiRecordSetInteger(hrecTableExecute, j, _ttoi(szKeyValue)), TEXT("TableExecuteRecordSetInteger")); <br>nDex = 0; <br>} <br> <br>// Execute view and attempt to fetch listed item from table <br>CheckMsi(MsiViewExecute(hviewTable, hrecTableExecute), TEXT("TableViewExecute")); <br>iStat = MsiViewFetch(hviewTable, &amp;hrecTableFetch); <br>if (iStat == ERROR_NO_MORE_ITEMS) <br>{ <br>// Value not found <br>TCHAR szError[cchBuffer] = {0}; <br>wsprintf(szError, TEXT("ERROR: Value: '%s' Is Required In Table: '%s'\n"), szValue, szTable); <br>Display(szError); <br>fValid = FALSE; <br>} <br>else if (iStat != ERROR_SUCCESS) <br>CheckMsi(iStat, TEXT("TableViewFetch")); <br>} <br> <br>return fValid; <br> <br>} <br> <br> <br>BOOL ValidateInstallSequence(MSIHANDLE hDatabase) <br>/*---------------------------------------------------------------------------- <br>ValidateInstallSequence -- validates the order of the actions in the <br>InstallSequence table to ensure that they are allowed by the _Sequence table. <br>The _Sequence table is required for this validation. <br>------------------------------------------------------------------------------*/ <br>{ <br>BOOL fValid = TRUE; <br> <br>PMSIHANDLE hviewInstallTable    = 0; <br>PMSIHANDLE hviewSeqQueryNull    = 0; <br>PMSIHANDLE hviewSeqQueryNotNull = 0; <br>PMSIHANDLE hviewSeqUpdate       = 0; <br>PMSIHANDLE hviewSeqAddColumn    = 0; <br>PMSIHANDLE hviewSeqMarkerInit   = 0; <br>PMSIHANDLE hrecSeqUpdateExecute = 0; <br>PMSIHANDLE hrecQueryExecute     = 0; <br>PMSIHANDLE hrecInstallFetch     = 0; <br>PMSIHANDLE hrecQueryNullFetch   = 0; <br>PMSIHANDLE hrecQueryNotNullFetch= 0; <br> <br>// Create the temporary marking column for the _Sequence table (this will store the sequence #s of the Dependent Actions) <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLSeqTableAddCol, &amp;hviewSeqAddColumn), TEXT("_SequenceTableAddColOpenView")); <br>CheckMsi(MsiViewExecute(hviewSeqAddColumn, 0), TEXT("_SequenceTableAddColExecute")); <br>CheckMsi(MsiViewClose(hviewSeqAddColumn), TEXT("_SequenceTableAddColClose")); <br> <br>// Initialize the temporary marking column to zero <br>//!! NO INSTALL SEQUENCE ACTIONS CAN HAVE A ZERO SEQUENCE # AS ZERO IS CONSIDERED "NULL" <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLSeqMarkerInit, &amp;hviewSeqMarkerInit), TEXT("_SequenceTableMarkerInitOpenView")); <br>CheckMsi(MsiViewExecute(hviewSeqMarkerInit, 0), TEXT("_SequenceTableMarkerInitExecute")); <br>CheckMsi(MsiViewClose(hviewSeqMarkerInit), TEXT("_SequenceTableMarkerInitClose")); <br> <br>// Open view on InstallSequence table and order by the Sequence # <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLInstallSeqTable, &amp;hviewInstallTable), TEXT("InstallSequenceTableOpenView")); <br>CheckMsi(MsiViewExecute(hviewInstallTable, 0), TEXT("InstallSequenceTableExecute")); <br> <br>// Open the two query views on _Sequence table for determining the validity of the actions <br>// Create execution record <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLSeqTableQueryNull, &amp;hviewSeqQueryNull), TEXT("SequenceTableQueryNullOpenView")); <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLSeqTableQueryNotNull, &amp;hviewSeqQueryNotNull), TEXT("_SequenceTableQueryNotNullOpenView")); <br>hrecQueryExecute = MsiCreateRecord(1); // for action <br>CheckMsi(hrecQueryExecute == 0, TEXT("QueryExecuteCreateRecord")); <br>hrecSeqUpdateExecute = MsiCreateRecord(1); // for action <br>CheckMsi(hrecSeqUpdateExecute == 0, TEXT("UpdateExecuteCreateRecord")); <br> <br>// Start fetching actions from the InstallSequence table <br>UINT iStat1 = ERROR_SUCCESS; <br>UINT iStat2 = ERROR_SUCCESS; <br>TCHAR szSQLUpdateQuery[4096] = {0}; <br>TCHAR szAction[100] = {0}; <br>int iSequence = 0; <br>for (;;) <br>{ <br>iStat1 = MsiViewFetch(hviewInstallTable, &amp;hrecInstallFetch); <br>if (iStat1 == ERROR_NO_MORE_ITEMS || !hrecInstallFetch) <br>break; <br>CheckMsi(iStat1, TEXT("InstallTableFetch")); <br>DWORD cbSize = sizeof(szAction)/sizeof(TCHAR); <br> <br>// Obtain name of action and Sequence # of action in InstallSequence table <br>CheckMsi(MsiRecordGetString(hrecInstallFetch, 1, szAction, &amp;cbSize), TEXT("InstallFetchRecordGetString")); <br>iSequence = MsiRecordGetInteger(hrecInstallFetch, 2); <br>CheckMsi(iSequence == MSI_NULL_INTEGER, TEXT("InstallFetchRecordGetInteger")); <br> <br>// Prepare execution records <br>CheckMsi(MsiRecordSetString(hrecQueryExecute, 1, szAction), TEXT("_SequenceQueryExecuteRecordSetString")); <br>CheckMsi(MsiRecordSetString(hrecSeqUpdateExecute, 1, szAction), TEXT("_SequenceUpdateExecuteRecordSetString")); <br> <br>// Execute _Sequence query table views <br>CheckMsi(MsiViewExecute(hviewSeqQueryNull, hrecQueryExecute), TEXT("_SequenceQueryNullExecute")); <br>CheckMsi(MsiViewExecute(hviewSeqQueryNotNull, hrecQueryExecute), TEXT("_SequenceQueryNotNullExecute")); <br> <br>// Fetch from _Sequence table.  If resultant set, then ERROR <br>// Following are the possibilities and whether permitted: <br>//   Action After Dependent Where Dependent Is Required And Temp Sequence Column Is Zero --&gt; ERROR <br>//   Action After Dependent Where Dependent Is Required And Temp Sequence Column Is Greater Than Zero --&gt; CORRECT <br>//   Action After Dependent Where Dependent Is Optional And Temp Sequence Column Is Zero --&gt; CORRECT <br>//   Action After Dependent Where Dependent Is Optional And Temp Sequence Column Is Greater Than Zero --&gt; CORRECT <br>//   Action Before Dependent Where Dependent Is Optional Or Required And Temp Sequence Column Is Zero --&gt; CORRECT <br>//   Action Before Dependent Where Dependent Is Optional Or Requred And Temp Sequence Column Is Greater Than Zero --&gt; ERROR <br> <br>// ** Only issue is when Action Is After Optional Dependent And Temp Sequence Column Is Zero because we <br>// ** have no way of knowing whether the action will be later (in which case it would be invalid.  This is <br>// ** ensured to be successful though by proper authoring of the _Sequence table.  If an Action comes after <br>// ** the Optional Dependent Action, then the _Sequence table must also be authored with the Dependent Action <br>// ** listed as coming before that Action (so if we come later, and find a result set, we flag this case). <br> <br>// If return is not equal to ERROR_NO_MORE_ITEMS, then ERROR and Output Action <br>//!! Any more info to output ?? <br>iStat1 = MsiViewFetch(hviewSeqQueryNull, &amp;hrecQueryNullFetch); <br>iStat2 = MsiViewFetch(hviewSeqQueryNotNull, &amp;hrecQueryNotNullFetch); <br> <br>if (iStat1 != ERROR_NO_MORE_ITEMS || iStat2 != ERROR_NO_MORE_ITEMS) <br>{ <br>TCHAR szError[1024] = {0}; <br>TCHAR szDependent[100] = {0}; <br>DWORD cb = sizeof(szDependent)/sizeof(TCHAR); <br>if (iStat1 != ERROR_NO_MORE_ITEMS) <br>CheckMsi(MsiRecordGetString(hrecQueryNullFetch, 1, szDependent, &amp;cb), TEXT("MsiRecordGetString")); </code></pre>
<p>
</p>
<pre><code>else <br>CheckMsi(MsiRecordGetString(hrecQueryNotNullFetch, 1, szDependent, &amp;cb), TEXT("MsiRecordGetString")); <br>wsprintf(szError, TEXT("ERROR: %s Action Is Sequenced Incorrectly (Dependent=%s)\n"), szAction, szDependent); <br>Display(szError); <br>fValid = FALSE; <br>} <br> <br>// Update _Sequence table temporary Sequence column (that we created) with the install sequence number <br>// The Sequence column stores the sequence number of the Dependent Actions, so we are updating every <br>// row where the action in the Dependent column equals the current action.  In the query view, we only <br>// check to insure that this column is zero or greater than zero (so we don't care too much about the value) <br>// Build the query: UPDATE `_Sequence` SET `Marker`=iSequence WHERE `Dependent`=szAction <br>wsprintf(szSQLUpdateQuery, TEXT("UPDATE `_Sequence` SET `Marker`=%d WHERE `Dependent`=?"), iSequence); <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLUpdateQuery, &amp;hviewSeqUpdate), TEXT("_SequenceTableUpdateOpenView")); <br>CheckMsi(MsiViewExecute(hviewSeqUpdate, hrecSeqUpdateExecute), TEXT("_SequenceUpdateExectue")); <br> <br>// Close the _Sequence table views so we can re-execute <br>CheckMsi(MsiViewClose(hviewSeqUpdate), TEXT("_SequenceUpdateViewClose")); <br>CheckMsi(MsiViewClose(hviewSeqQueryNull), TEXT("_SequenceQueryNullViewClose")); <br>CheckMsi(MsiViewClose(hviewSeqQueryNotNull), TEXT("_SequenceQueryNotNullViewClose")); <br>} <br> <br>// Close the InstallSequence table view <br>CheckMsi(MsiViewClose(hviewInstallTable), TEXT("InstallSequenceTableViewClose")); <br> <br>return fValid; <br>} <br> <br> <br>BOOL Validate(MSIHANDLE hDatabase) <br>/*----------------------------------------------------------------------------------- <br>Validate -- Routine to validate database.  Prints out invalid data if any. <br>  Arguments: <br>hDatabase -- handle to database <br>iValid -- integer for storing whether database is valid <br>  Returns: <br>BOOL status -- TRUE (all valid), FALSE (invalid data found) <br>-------------------------------------------------------------------------------------*/ <br>{ <br>// _Tables (Table Catalog) <br>PMSIHANDLE hTableCatalogView; <br>PMSIHANDLE hTableCatalogRecord; <br>// Table To Validate <br>PMSIHANDLE hValidationView; <br>PMSIHANDLE hValidationRecord; <br>// Record for Primary Keys <br>PMSIHANDLE hKeyRecord; <br> <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQLTableCatalog, &amp;hTableCatalogView),TEXT("OpenTableCatalogView")); <br>CheckMsi(MsiViewExecute(hTableCatalogView, 0), TEXT("Execute Table Catalog View")); <br>TCHAR szSQL[256]; <br>TCHAR szTableName[32]; <br>TCHAR szColumnData[255]; <br>TCHAR szColumnName[32]; <br>DWORD cchTableName = sizeof(szTableName)/sizeof(TCHAR); <br>DWORD cchColumnName = sizeof(szColumnName)/sizeof(TCHAR); <br>DWORD cchColumnData = sizeof(szColumnData)/sizeof(TCHAR); <br> <br>BOOL fDataValid = TRUE; // initially valid <br>DWORD cchTableBuf = cchTableName; <br>DWORD cchDataBuf = cchColumnData; <br>DWORD cchBuf = cchColumnName; <br>UINT uiRet = 0; <br>for (;;) <br>{ <br> <br>uiRet = MsiViewFetch(hTableCatalogView, &amp;hTableCatalogRecord); <br>if (uiRet == ERROR_NO_MORE_ITEMS) <br>break; <br>CheckMsi(uiRet, TEXT("Fetch Table Catalog Record")); <br>if (!hTableCatalogRecord) <br>break; <br>cchTableBuf = cchTableName; // on return size of string written <br>CheckMsi(MsiRecordGetString(hTableCatalogRecord, 1, szTableName, &amp;cchTableBuf), TEXT("Get Table Name From Fetched Record")); <br>MSICONDITION ice = MsiDatabaseIsTablePersistent(hDatabase, szTableName); <br>if (ice == MSICONDITION_FALSE) <br>continue; <br>CheckMsi(ice != MSICONDITION_TRUE, TEXT("IsTablePersistent")); <br>wsprintf(szSQL, TEXT("%s`%s`"), szSQLTable, szTableName); <br>CheckMsi(MsiDatabaseOpenView(hDatabase, szSQL, &amp;hValidationView),TEXT("OpenView")); <br>CheckMsi(MsiViewExecute(hValidationView, 0), TEXT("Execute View")); <br>for (;;) <br>{ <br>uiRet = MsiViewFetch(hValidationView, &amp;hValidationRecord); <br>if (uiRet == ERROR_NO_MORE_ITEMS) <br>break; <br>CheckMsi(uiRet, TEXT("Fetch record")); <br>if (!hValidationRecord) <br>break; <br>if (MsiViewModify(hValidationView, MSIMODIFY_VALIDATE, hValidationRecord) != ERROR_SUCCESS) <br>{ <br>fDataValid = FALSE; <br>cchTableBuf = cchTableName; <br>cchDataBuf = cchColumnData; <br>cchBuf = cchColumnName; <br> <br>MSIDBERROR eReturn; <br>while ((eReturn = MsiViewGetError(hValidationView, szColumnName, &amp;cchBuf)) != MSIDBERROR_NOERROR) <br>{ <br>if (eReturn == MSIDBERROR_FUNCTIONERROR || eReturn == MSIDBERROR_MOREDATA || eReturn == MSIDBERROR_INVALIDARG) <br>{ <br>_tprintf(TEXT("\nFunction Error")); <br>break; <br>} <br> <br>int iResId; <br>int iValue; <br>switch (eReturn) <br>{ <br>case MSIDBERROR_NOERROR:           iResId = IDS_NoError;          break; <br>case MSIDBERROR_DUPLICATEKEY:      iResId = IDS_DuplicateKey;     break; <br>case MSIDBERROR_REQUIRED:          iResId = IDS_Required;         break; <br>case MSIDBERROR_BADLINK:           iResId = IDS_BadLink;          break; <br>case MSIDBERROR_OVERFLOW:          iResId = IDS_Overflow;         break; <br>case MSIDBERROR_UNDERFLOW:         iResId = IDS_Underflow;        break; <br>case MSIDBERROR_NOTINSET:          iResId = IDS_NotInSet;         break; <br>case MSIDBERROR_BADVERSION:        iResId = IDS_BadVersion;       break; <br>case MSIDBERROR_BADCASE:           iResId = IDS_BadCase;          break; <br>case MSIDBERROR_BADGUID:           iResId = IDS_BadGuid;          break; <br>case MSIDBERROR_BADWILDCARD:       iResId = IDS_BadWildCard;      break; <br>case MSIDBERROR_BADIDENTIFIER:     iResId = IDS_BadIdentifier;    break; <br>case MSIDBERROR_BADLANGUAGE:       iResId = IDS_BadLanguage;      break; <br>case MSIDBERROR_BADFILENAME:       iResId = IDS_BadFileName;      break; <br>case MSIDBERROR_BADPATH:           iResId = IDS_BadPath;          break; <br>case MSIDBERROR_BADCONDITION:      iResId = IDS_BadCondition;     break; <br>case MSIDBERROR_BADFORMATTED:      iResId = IDS_BadFormatted;     break; <br>case MSIDBERROR_BADTEMPLATE:       iResId = IDS_BadTemplate;      break; <br>case MSIDBERROR_BADDEFAULTDIR:     iResId = IDS_BadDefaultDir;    break; <br>case MSIDBERROR_BADREGPATH:        iResId = IDS_BadRegPath;       break; <br>case MSIDBERROR_BADCUSTOMSOURCE:   iResId = IDS_BadCustomSource;  break; <br>case MSIDBERROR_BADPROPERTY:       iResId = IDS_BadProperty;      break; <br>case MSIDBERROR_MISSINGDATA:       iResId = IDS_MissingData;      break; <br>case MSIDBERROR_BADCATEGORY:       iResId = IDS_BadCategory;      break; <br>case MSIDBERROR_BADKEYTABLE:       iResId = IDS_BadKeyTable;      break; <br>case MSIDBERROR_BADMAXMINVALUES:   iResId = IDS_BadMaxMinValues;  break; <br>case MSIDBERROR_BADCABINET:        iResId = IDS_BadCabinet;       break; <br>case MSIDBERROR_BADSHORTCUT:       iResId = IDS_BadShortcut;      break; <br>case MSIDBERROR_STRINGOVERFLOW:    iResId = IDS_StringOverflow;   break; <br>case MSIDBERROR_BADLOCALIZEATTRIB: iResId = IDS_BadLocalizeAttrib;break; <br>default:                           iResId = IDS_UndefinedError;   break; <br>}; <br> <br>// Print table <br>_tprintf(TEXT("\n Error: %s\t"), szTableName); <br> <br>// Get Row <br>CheckMsi(MsiDatabaseGetPrimaryKeys(hDatabase, szTableName, &amp;hKeyRecord), TEXT("Get Primary Keys")); <br>unsigned int iNumFields = MsiRecordGetFieldCount(hKeyRecord); <br>if (MsiRecordGetString(hValidationRecord, 1, szColumnData, &amp;cchDataBuf) != ERROR_SUCCESS) <br>{ <br>iValue = MsiRecordGetInteger(hValidationRecord, 1); <br>_tprintf(TEXT("%d"), iValue); <br>} <br>else <br>_tprintf(TEXT("%s"), szColumnData); <br>cchDataBuf = cchColumnData; <br>for (int i = 2; i &lt;= iNumFields; i++) <br>{ <br>_tprintf(TEXT(".")); <br>cchDataBuf = cchColumnData; <br>if (MsiRecordGetString(hValidationRecord, i, szColumnData, &amp;cchDataBuf) != ERROR_SUCCESS) <br>{ <br>iValue = MsiRecordGetInteger(hValidationRecord, 1); <br>_tprintf(TEXT("%d"), iValue); <br>} <br>else <br>_tprintf(TEXT("%s"), szColumnData); <br>} <br>// Print name of column and enum value <br>TCHAR szMsgBuf[80]; <br>const TCHAR* szMessage = (TCHAR*)iResId; <br>const TCHAR** pszMsg; <br>pszMsg = &amp;szMessage; <br>::LoadString(0, *(unsigned*)pszMsg, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)); <br>*pszMsg = szMsgBuf; <br>_tprintf(TEXT("\t%s\t%s"), szColumnName, szMsgBuf); <br>cchBuf = cchColumnName; // on return size of string written <br>cchDataBuf = cchColumnData; <br>} <br>cchBuf = cchColumnName; // on return size of string written <br>} <br>} <br>CheckMsi(MsiViewClose(hValidationView), TEXT("Close view")); <br>} <br>CheckMsi(MsiViewClose(hTableCatalogView), TEXT("Close Table Catalog View")); <br>return fDataValid; <br>} <br> <br>void Display(LPCTSTR szMessage) <br>{ <br>if (szMessage) <br>{ <br>int cbOut = _tcsclen(szMessage);; <br>if (g_hStdOut) <br>{ <br>#ifdef UNICODE <br>char rgchTemp[cchDisplayBuf]; <br>if (GetFileType(g_hStdOut) == FILE_TYPE_CHAR) <br>{ <br>WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0); <br>szMessage = (LPCWSTR)rgchTemp; <br>} <br>else <br>cbOut *= 2;   // write Unicode if not console device <br>#endif <br>DWORD cbWritten; <br>WriteFile(g_hStdOut, szMessage, cbOut, &amp;cbWritten, 0); <br>} <br>else <br>MessageBox(0, szMessage, GetCommandLine(), MB_OK); <br>} <br>} <br> <br> <br> <br> <br>#else // RC_INVOKED, end of source code, start of resources <br>// resource definition go here <br> <br>STRINGTABLE DISCARDABLE <br>{ <br>IDS_NoError,          "No Error" <br>IDS_DuplicateKey,     "Duplicate primary key" <br>IDS_Required,         "Not a nullable column" <br>IDS_BadLink,          "Not a valid foreign key" <br>IDS_Overflow,         "Value exceeds MaxValue" <br>IDS_Underflow,        "Value below MinValue" <br>IDS_NotInSet,         "Value not a member of the set" <br>IDS_BadVersion,       "Invalid version string" <br>IDS_BadCase,          "Must be all upper or all lower case" <br>IDS_BadGuid,          "Invalid GUID string" <br>IDS_BadWildCard,      "Invalid wildcard filename or usage of wildcards" <br>IDS_BadIdentifier,    "Invalid identifier" <br>IDS_BadLanguage,      "Invalid Language Id" <br>IDS_BadFileName,      "Invalid Filename" <br>IDS_BadPath,          "Invalid full path" <br>IDS_BadCondition,     "Bad conditional string" <br>IDS_BadFormatted,     "Invalid format string" <br>IDS_BadTemplate,      "Invalid template string" <br>IDS_BadDefaultDir,    "Invalid DefaultDir string" <br>IDS_BadRegPath,       "Invalid registry path" <br>IDS_BadCustomSource,  "Bad CustomSource data" <br>IDS_BadProperty,      "Bad property" <br>IDS_MissingData,      "Missing data in _Validation table or old Database" <br>IDS_BadCabinet,       "Bad cabinet syntax/name" <br>IDS_BadCategory,      "_Validation table: Invalid category string" <br>IDS_BadKeyTable,      "_Validation table: Data in KeyTable col is bad" <br>IDS_BadMaxMinValues,  "_Validation table: value in MaxValue col &lt; that in MinValue col" <br>IDS_BadShortcut,      "Bad shortcut target" <br>IDS_StringOverflow,   "String overflow:  Length greater than that allowed by column definition" <br>IDS_MissingEntry,     "Column is required by _Validation table" <br>IDS_UndefinedError,   "Undefined Error" <br>IDS_BadLocalizeAttrib,"Primary Key columns cannot be set to be localized" <br>} <br> <br>#endif // RC_INVOKED <br>#if 0  <br>!endif // makefile terminator <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
