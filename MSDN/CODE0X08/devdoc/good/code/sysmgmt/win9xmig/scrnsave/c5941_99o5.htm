<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POOLMEM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5945"></a>POOLMEM.C</h2>
<pre><code>#include "pch.h" <br>  <br>// Tree Memory Allocation structure. <br> <br> <br>typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK; <br> <br>struct _POOLMEMORYBLOCK { <br>    DWORD                 Index; <br>    DWORD                 Size; <br>    PPOOLMEMORYBLOCK      NextBlock; <br>    PPOOLMEMORYBLOCK      PrevBlock; <br>    PBYTE                 RawMemory;   <br>}; <br> <br>typedef struct _POOLHEADER { <br>    PPOOLMEMORYBLOCK PoolHead; <br>    HANDLE           Heap; <br>} POOLHEADER, *PPOOLHEADER; <br> <br> <br>BOOL <br>PoolMemAddMemory ( <br>    IN  POOLHANDLE  Handle, <br>    IN  DWORD       Size <br>    ) <br>{ <br>    PBYTE               allocedMemory; <br>    PPOOLMEMORYBLOCK    newBlock; <br>    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle; <br>    DWORD               sizeNeeded; <br> <br>    assert(poolHeader != NULL); <br> <br>    // <br>    // Determine size needed and attempt to allocate memory. <br>    // <br>    if (Size + sizeof(POOLMEMORYBLOCK) &gt; POOLMEMORYBLOCKSIZE) { <br>        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK); <br>    } <br>    else { <br>        sizeNeeded = POOLMEMORYBLOCKSIZE; <br>    } <br> <br>    allocedMemory = HeapAlloc(poolHeader -&gt; Heap,0,sizeNeeded); <br> <br>    if (allocedMemory) { <br> <br>        // <br>        // Use the beginning of the alloc'ed block as the poolblock structure. <br>        // <br>        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory; <br>        newBlock -&gt; Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK); <br>        newBlock -&gt; RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK); <br>        newBlock -&gt; Index       = 0; <br>     <br>        // <br>        // Link the block into the list. <br>        // <br>        if (poolHeader -&gt; PoolHead) { <br>            poolHeader -&gt; PoolHead -&gt; PrevBlock = newBlock; <br>        } <br>        newBlock   -&gt; NextBlock   = poolHeader -&gt; PoolHead; <br>        newBlock   -&gt; PrevBlock   = NULL; <br>        poolHeader -&gt; PoolHead    = newBlock; <br> <br> <br>    } <br>    // <br>    // Assuming allocedMemory is non-NULL, we have succeeded. <br>    // <br>    return allocedMemory != NULL; <br>} <br> <br> <br>POOLHANDLE <br>WINAPI <br>PoolMemInitPool ( <br>    ) <br>{ <br>    BOOL        ableToAddMemory; <br>    PPOOLHEADER header = NULL; <br>    HANDLE      procHeap; <br> <br> <br>    procHeap = GetProcessHeap(); <br>    // <br>    // Allocate the header of this pool. <br>    // <br>    header = HeapAlloc(procHeap,0,sizeof(POOLHEADER)); <br> <br>    if (header) { <br> <br>        // <br>        // Allocation was successful. Now, initialize the pool. <br>        // <br>        header -&gt; PoolHead = NULL; <br>        header -&gt; Heap = procHeap; <br> <br>        // <br>        // Actually add some memory to the pool. <br>        // <br>        ableToAddMemory = PoolMemAddMemory(header,0); <br> <br>        if (!ableToAddMemory) { <br>            // <br>            // Unable to add memory to the pool. <br>            // <br>            HeapFree(header -&gt; Heap,0,header); <br>            header = NULL; <br>        } <br> <br>    } <br>    return (POOLHANDLE) header; <br>} <br> <br> <br>VOID <br>WINAPI <br>PoolMemDestroyPool ( <br>    POOLHANDLE Handle <br>    ) <br>{ <br>    PPOOLMEMORYBLOCK nextBlock; <br>    PPOOLMEMORYBLOCK blockToFree;  <br>    PPOOLHEADER      poolHeader; <br> <br>    assert(Handle != NULL); <br> <br>    poolHeader = (PPOOLHEADER) Handle; <br> <br>    // <br>    // Walk the list, freeing as we go. <br>    // <br>    blockToFree = poolHeader -&gt;  PoolHead; <br> <br>    while (blockToFree != NULL) { <br>     <br>        nextBlock = blockToFree-&gt;NextBlock; <br>        HeapFree(poolHeader -&gt; Heap,0,blockToFree); <br>        blockToFree = nextBlock; <br>    } <br> <br>    // <br>    // Also, deallocate the poolheader itself. <br>    // <br>    HeapFree(poolHeader -&gt; Heap,0,poolHeader); <br> <br>} <br> <br>PVOID <br>WINAPI <br>PoolMemGetAlignedMemory ( <br>    IN POOLHANDLE Handle, <br>    IN DWORD      Size, <br>    IN DWORD      AlignSize <br>    ) <br> <br>{ <br>    BOOL                haveEnoughMemory = TRUE; <br>    PVOID               rMemory          = NULL; <br>    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle; <br>    PPOOLMEMORYBLOCK    currentBlock; <br>    DWORD               sizeNeeded; <br>    DWORD               padLength; <br> <br>    assert(poolHeader != NULL); <br> <br>    currentBlock = poolHeader -&gt; PoolHead; <br> <br>    // Determine if more memory is needed, attempt to add if needed. <br>    sizeNeeded = Size; <br> <br>    if (currentBlock -&gt; Size - currentBlock -&gt; Index &lt; sizeNeeded + AlignSize) { <br> <br>        haveEnoughMemory = PoolMemAddMemory(poolHeader,sizeNeeded + AlignSize); <br>        currentBlock = poolHeader -&gt; PoolHead; <br>    } <br> <br>    // If there is enough memory available, return it. <br>    if (haveEnoughMemory) { <br>        if (AlignSize) { <br> <br>            padLength = (DWORD) currentBlock + sizeof(POOLMEMORYBLOCK)  <br>                + currentBlock -&gt; Index; <br>            currentBlock -&gt; Index += (AlignSize - (padLength % AlignSize)) % AlignSize; <br> <br>        } <br>       <br>          <br>        //Now, get the address of the memory to return. <br>        rMemory = (PVOID)  <br>            &amp;(currentBlock-&gt;RawMemory[currentBlock -&gt; Index]); <br>  <br>        currentBlock-&gt;Index += sizeNeeded; <br>    } <br> <br>    return rMemory; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
