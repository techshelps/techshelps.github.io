<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCRNSAVE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5948"></a>SCRNSAVE.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    scrnsave.c <br> <br>Abstract: <br> <br>    This source file implements the seven required functions for a <br>    Windows NT 5.0 migration DLL.  The DLL demonstrates how the <br>    interface works by performing the Windows 9x screen saver  <br>    upgrade. <br> <br>    The source here is a subset of the actual screen saver DLL <br>    that ships with Windows NT Setup. <br> <br>    This sample demonstrates: <br> <br>      - How to detect installation of your application <br> <br>      - A typical implementation of QueryVersion, Initialize9x,  <br>        MigrateUser9x, MigrateSystem9x, InitializeNT,  <br>        MigrateUserNT and MigraetSystemNT <br> <br>      - How to provide language-dependent incompatibility <br>        messages to the user <br> <br>      - How to remove Setup's incompatibility messages via <br>        [Handled] section <br> <br>      - Saving settings to a temporarly file in the working  <br>        directory <br> <br>      - Mix use of ANSI and UNICODE <br> <br>      - Use of the SetupLogError API <br> <br>      - Deleting files <br> <br>      - Handling the move from system to system32 <br> <br>Author: <br> <br>    Jim Schmidt 11-Apr-1997 <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#include "pch.h" <br> <br>// <br>// Constants <br>// <br> <br>#define CP_USASCII          1252 <br>#define END_OF_CODEPAGES    -1 <br> <br>// <br>// Code page array <br>// <br> <br>INT   g_CodePageArray[] = { <br>            CP_USASCII, <br>            END_OF_CODEPAGES <br>            }; <br> <br>// <br>// Multi-sz (i.e., double-nul terminated) list of files to find <br>// <br> <br>CHAR    g_ExeNamesBuf[] = "Blank Screen.scr\0" <br>                          "Curves and Colors.scr\0" <br>                          "Flying Through Space.scr\0" <br>                          "Scrolling Marquee.scr\0" <br>                          "Mystify Your Mind.scr\0"; <br> <br>// <br>// Copies of the working directory and source directory <br>// <br> <br>LPSTR   g_WorkingDirectory = NULL; <br>LPSTR   g_SourceDirectories = NULL;         // multi-sz <br>LPSTR   g_SettingsFile = NULL; <br>LPSTR   g_MigrateDotInf = NULL; <br> <br>// <br>// Registry locations and INI file sections <br>// <br> <br>#define REGKEY_DESKTOP "Control Panel\\Desktop" <br>#define FULL_REGKEY_DESKTOP "HKR\\Control Panel\\Desktop" <br>#define FULL_REGKEY_PWD_PROVIDER "HKLM\\System\\CurrentControlSet\\Control\\PwdProvider\\SCRSAVE" <br> <br>#define REGVAL_SCREENSAVEACTIVE "ScreenSaveActive" <br>#define REGVAL_SCREENSAVELOWPOWERACTIVE "ScreenSaveLowPowerActive" <br>#define REGVAL_SCREENSAVELOWPOWERTIMEOUT "ScreenSaveLowPowerTimeout" <br>#define REGVAL_SCREENSAVEPOWEROFFACTIVE "ScreenSavePowerOffActive" <br>#define REGVAL_SCREENSAVEPOWEROFFTIMEOUT "ScreenSavePowerOffTimeout" <br>#define REGVAL_SCREENSAVETIMEOUT "ScreenSaveTimeOut" <br>#define REGVAL_SCREENSAVEUSEPASSWORD "ScreenSaveUsePassword" <br> <br>#define REGVAL_LOWPOWERACTIVE "LowPowerActive" <br>#define REGVAL_LOWPOWERTIMEOUT "LowPowerTimeout" <br>#define REGVAL_POWEROFFACTIVE "PowerOffActive" <br>#define REGVAL_POWEROFFTIMEOUT "PowerOffTimeout" <br>#define REGVAL_SCREENSAVERISSECURE "ScreenSaverIsSecure" <br> <br>// <br>// State variables <br>// <br> <br>BOOL g_FoundPassword = FALSE; <br>LPCSTR g_User; <br>CHAR g_UserNameBuf[MAX_PATH]; <br>HANDLE g_hHeap; <br> <br> <br> <br>BOOL <br>WINAPI <br>DllMain ( <br>    IN      HANDLE DllInstance, <br>    IN      ULONG  ReasonForCall, <br>    IN      LPVOID Reserved <br>    ) <br>{ <br>    switch (ReasonForCall)  { <br> <br>    case DLL_PROCESS_ATTACH: <br>        // <br>        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages <br>        // <br>        DisableThreadLibraryCalls (DllInstance); <br> <br>        // <br>        // Global init <br>        // <br>        g_hHeap = GetProcessHeap(); <br> <br>        if (!MigInf_Initialize()) { <br>            return FALSE; <br>        } <br> <br>        // Open log; FALSE means do not delete existing log <br>        SetupOpenLog (FALSE); <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br>        MigInf_CleanUp(); <br> <br>        // Clean up strings <br>        if (g_WorkingDirectory) { <br>            HeapFree (g_hHeap, 0, g_WorkingDirectory); <br>        } <br>        if (g_SourceDirectories) { <br>            HeapFree (g_hHeap, 0, g_SourceDirectories); <br>        } <br>        if (g_SettingsFile) { <br>            HeapFree (g_hHeap, 0, g_SettingsFile); <br>        } <br>        if (g_MigrateDotInf) { <br>            HeapFree (g_hHeap, 0, g_MigrateDotInf); <br>        } <br> <br>        SetupCloseLog(); <br> <br>        break; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>LONG <br>CALLBACK <br>QueryVersion ( <br>    OUT     LPCSTR *ProductID, <br>OUT     LPUINT DllVersion, <br>OUT     LPINT *CodePageArray,    OPTIONAL <br>OUT     LPCSTR *ExeNamesBuf,    OPTIONAL <br>        LPVOID Reserved <br>    ) <br>{ <br>    // <br>    // First, we do some preliminary investigation to see if  <br>    // our components are installed.   <br>    // <br> <br>    if (!GetScrnSaveExe()) { <br>        // <br>        // We didn't detect any components, so we return  <br>        // ERROR_NOT_INSTALLED and the DLL will stop being called. <br>        // Use this method as much as possible, because user enumeration <br>        // for MigrateUser9x is relatively slow.  However, don't spend too <br>        // much time here because QueryVersion is expected to run quickly. <br>        // <br>        return ERROR_NOT_INSTALLED; <br>    } <br> <br>    // <br>    // Screen saver is enabled, so tell Setup who we are.  ProductID is used <br>    // for display, so it must be localized.  The ProductID string is  <br>    // converted to UNICODE for use on Windows NT via the MultiByteToWideChar <br>    // Win32 API.  The first element of CodePageArray is used to specify <br>    // the code page of ProductID, and if no elements are returned in <br>    // CodePageArray, Setup assumes CP_ACP. <br>    // <br> <br>    *ProductID  = g_MyProductId; <br> <br>    // <br>    // Report our version.  Zero is reserved for use by DLLs that <br>    // ship with Windows NT. <br>    // <br> <br>    *DllVersion = 1; <br> <br>    //  <br>    // Because we have English messages, we return an array that has <br>    // the English language ID.  The sublanguage is neutral because <br>    // we do not have currency, time, or other geographic-specific  <br>    // information in our messages. <br>    // <br>    // Tip: If it makes more sense for your DLL to use locales, <br>    // return ERROR_NOT_INSTALLED if the DLL detects that an appropriate  <br>    // locale is not installed on the machine. <br>    // <br> <br>    *CodePageArray = g_CodePageArray; <br> <br>    // <br>    // ExeNamesBuf - we pass a list of file names (the long versions) <br>    // and let Setup find them for us.  Keep this list short because <br>    // every instance of the file on every hard drive will be reported <br>    // in migrate.inf. <br>    // <br>    // Most applications don't need this behavior, because the registry <br>    // usually contains full paths to installed components.  We need it, <br>    // though, because there are no registry settings that give us the <br>    // paths of the screen saver DLLs. <br>    // <br> <br>    *ExeNamesBuf = g_ExeNamesBuf; <br> <br>    return ERROR_SUCCESS; <br>} <br> <br> <br>LONG <br>CALLBACK <br>Initialize9x ( <br>IN      LPCSTR WorkingDirectory, <br>IN      LPCSTR SourceDirectories, <br>        LPVOID Reserved <br>    ) <br>{ <br>    INT Len; <br>     <br>    // <br>    // Because we returned ERROR_SUCCESS in QueryVersion, we are being <br>    // called for initialization.  Therefore, we know screen savers are <br>    // enabled on the machine at this point. <br>    //  <br> <br>    // <br>    // Make global copies of WorkingDirectory and SourceDirectories -- <br>    // we will not get this information again, and we shouldn't <br>    // count on Setup keeping the pointer valid for the life of our <br>    // DLL. <br>    // <br> <br>    Len = CountStringBytes (WorkingDirectory); <br>    g_WorkingDirectory = HeapAlloc (g_hHeap, 0, Len); <br> <br>    if (!g_WorkingDirectory) { <br>        return GetLastError(); <br>    } <br> <br>    CopyMemory (g_WorkingDirectory, WorkingDirectory, Len); <br> <br>    Len = CountMultiStringBytes (SourceDirectories); <br>    g_SourceDirectories = HeapAlloc (g_hHeap, 0, Len); <br> <br>    if (!g_SourceDirectories) { <br>        return GetLastError(); <br>    } <br> <br>    CopyMemory (g_SourceDirectories, SourceDirectories, Len); <br> <br>    // <br>    // Now create our private 'settings file' path <br>    // <br> <br>    GenerateFilePaths(); <br> <br>    // <br>    // Return success to have MigrateUser9x called <br>    // <br>    // Tip: A DLL can save system settings during Initialize9x as <br>    //      well as MigrateSystem9x. <br>    // <br>    // <br> <br>    return ERROR_SUCCESS; <br>} <br> <br> <br>LONG <br>CALLBACK  <br>MigrateUser9x ( <br>IN      HWND ParentWnd,  <br>IN      LPCSTR UnattendFile, <br>IN      HKEY UserRegKey,  <br>IN      LPCSTR UserName,  <br>        LPVOID Reserved <br>) <br>{ <br>    HKEY RegKey; <br>    LPCSTR ScrnSaveExe; <br>    DWORD rc = ERROR_SUCCESS; <br>    LPSTR SectionNameBuf, p; <br>    DWORD SectionNameSize; <br>    DWORD Len; <br> <br>    // <br>    // This DLL does not require input from the user to upgrade <br>    // their settings, so ParentWnd is not used.  Avoid displaying <br>    // any user interface when possible. <br>    // <br>    // We don't need to use UnattendFile settings because we are not <br>    // a service (such as a network redirector).  Therefore, we do not  <br>    // use the  UnattendFile parameter. <br>    // <br>    // We don't have any files that need to be generated or expanded on <br>    // the NT side of Setup, so we do not write to the  <br>    // [NT Disk Space Requirements] section of migrate.inf. <br>    // <br> <br>    // <br>    // We must collect a few registry keys: <br>    // <br>    //   HKCU\Control Panel\Desktop <br>    //        ScreenSaveActive <br>    //        ScreenSaveLowPowerActive <br>    //        ScreenSaveLowPowerTimeout <br>    //        ScreenSavePowerOffActive <br>    //        ScreenSavePowerOffTimeout <br>    //        ScreenSaveTimeOut <br>    //        ScreenSaveUsePassword <br>    // <br>    // If ScreenSave_Data exists, we tell the user that their <br>    // password is not supported by writing an incompatiility <br>    // message. <br>    // <br> <br>    // <br>    // Save the user name in a global so our utils write to the <br>    // correct section. <br>    // <br> <br>    if (UserName) { <br>        g_User = UserName; <br>    } else { <br>        g_User = S_DEFAULT_USER; <br>    } <br> <br>    // OpenRegKey is our utility (in utils.c) <br>    RegKey = OpenRegKey (UserRegKey, REGKEY_DESKTOP); <br>    if (!RegKey) { <br>        // <br>        // User's registry is invalid, so skip the user <br>        // <br>        return ERROR_NOT_INSTALLED; <br>    } <br> <br>    // <br>    // Note: NO changes allowed on Win9x side, we can only read our <br>    //       settings and save them in a file. <br>    // <br> <br>    if (!CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEACTIVE) || <br>        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVELOWPOWERACTIVE) || <br>        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVELOWPOWERTIMEOUT) || <br>        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEPOWEROFFACTIVE) || <br>        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEPOWEROFFTIMEOUT) || <br>        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVETIMEOUT) || <br>        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEUSEPASSWORD) <br>        ) { <br>        rc = GetLastError(); <br>    } <br> <br>    if (atoi (GetRegValueString (RegKey, REGVAL_SCREENSAVEUSEPASSWORD))) { <br>        // Queue change so there is only one message <br>        g_FoundPassword = TRUE; <br>    } <br> <br>    // <br>    // Save EXE location in our dat file <br>    // <br> <br>    ScrnSaveExe = GetScrnSaveExe(); <br> <br>    if (ScrnSaveExe) { <br>        if (!SaveDatFileKeyAndVal (S_SCRNSAVE_EXE, ScrnSaveExe)) { <br>            rc = GetLastError(); <br>        } <br>    } <br> <br>    // <br>    // Copy control.ini sections to our dat file <br>    // <br> <br>    SectionNameSize = 32768; <br>    SectionNameBuf = (LPSTR) HeapAlloc (g_hHeap, 0, SectionNameSize); <br>    if (!SectionNameBuf) { <br>        return GetLastError(); <br>    } <br> <br>    GetPrivateProfileString ( <br>        NULL, <br>        NULL, <br>        S_DOUBLE_EMPTY, <br>        SectionNameBuf, <br>        SectionNameSize, <br>        S_CONTROL_INI <br>        ); <br> <br>    Len = _mbslen (S_SCRNSAVE_DOT); <br>    for (p = SectionNameBuf ; *p ; p = _mbschr (p, 0) + 1) { <br>        // <br>        // Determine if section name has "Screen Saver." at the beginning <br>        // <br> <br>        if (!_mbsnicmp (p, S_SCRNSAVE_DOT, Len)) { <br>            // <br>            // It does, so save it to our private file <br>            // <br>            SaveControlIniSection (p, p + Len); <br>        } <br>    } <br> <br>    CloseRegKey (RegKey); <br> <br>    if (rc != ERROR_SUCCESS) { <br>        CHAR Msg[512]; <br> <br>        wsprintf (Msg, USER_PROCESSING_ERROR, g_User, rc); <br>        SetupLogError (Msg, LogSevError); <br>    } else { <br>        // <br>        // Write handled for every setting we are processing.  Because this <br>        // DLL supports only some of the values in the Desktop key, we must <br>        // be very specific as to which values are actually handled.  If <br>        // your DLL handles all registry values AND subkeys of a registry <br>        // key, you can specify NULL in the second parameter of  <br>        // MigInf_AddHandledRegistry. <br>        // <br> <br>        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEACTIVE); <br>        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVELOWPOWERACTIVE); <br>        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVELOWPOWERTIMEOUT); <br>        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEPOWEROFFACTIVE); <br>        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEPOWEROFFTIMEOUT); <br>        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVETIMEOUT); <br>        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEUSEPASSWORD); <br>    } <br> <br>    return rc; <br>} <br> <br> <br>LONG  <br>CALLBACK  <br> <br>MigrateSystem9x ( <br>IN      HWND ParentWnd,  <br>IN      LPCSTR UnattendFile, <br>        LPVOID Reserved <br>) <br>{ <br>    // <br>    // We handle the password provider incompatibility <br>    // <br> <br>    MigInf_AddHandledRegistry (FULL_REGKEY_PWD_PROVIDER, NULL); <br> <br>    // <br>    // Write incompatibility message if necessary (detected in MigrateUser9x) <br>    // <br> <br>    if (g_FoundPassword) { <br>        MigInf_AddMessage (g_MyProductId, PASSWORD_ALERT); <br>        MigInf_AddMessageRegistry ( <br>                g_MyProductId,  <br>                FULL_REGKEY_DESKTOP,  <br>                REGVAL_SCREENSAVEUSEPASSWORD <br>                ); <br>    } <br> <br>    // <br>    // Write memory version of migrate.inf to disk <br>    // <br> <br>    if (!MigInf_WriteInfToDisk()) { <br>        return GetLastError(); <br>    } <br> <br>    return ERROR_SUCCESS; <br>} <br> <br> <br>LONG <br>CALLBACK  <br>InitializeNT ( <br>IN      LPCWSTR WorkingDirectory, <br>IN      LPCWSTR SourceDirectories, <br>        LPVOID Reserved <br>) <br>{ <br>    INT Length; <br>    LPCWSTR p; <br> <br>    // <br>    // Save our working directory and source directory.  We <br>    // convert UNICODE to ANSI because we know we are on a US <br>    // version of NT.  This conversion is not valid for far east <br>    // languages, because we use CP_ACP (ANSI code page). <br>    // <br>    // If your DLL supports far east languages, use UNICODE and <br>    // call the W version of Win32 functions that take strings. <br>    // <br> <br>    // <br>    // Compute length of source directories <br>    // <br> <br>    p = SourceDirectories; <br>    while (*p) { <br>        p = wcschr (p, 0) + 1; <br>    } <br>    p++; <br>    Length = (p - SourceDirectories) / sizeof (WCHAR); <br> <br>    // <br>    // Convert the directories from UNICODE to DBCS.  This DLL is <br>    // compiled in ANSI. <br>    // <br> <br>    g_WorkingDirectory = (LPSTR) HeapAlloc (g_hHeap, 0, MAX_PATH); <br>    if (!g_WorkingDirectory) { <br>        return GetLastError(); <br>    } <br> <br>    WideCharToMultiByte ( <br>        CP_ACP,  <br>        0,  <br>        WorkingDirectory,  <br>        -1, <br>        g_WorkingDirectory, <br>        MAX_PATH, <br>        NULL, <br>        NULL <br>        ); <br> <br>    g_SourceDirectories = (LPSTR) HeapAlloc (g_hHeap, 0, Length * sizeof(WCHAR)); <br>    if (!g_SourceDirectories) { <br>        return GetLastError(); <br>    } <br> <br>    WideCharToMultiByte ( <br>        CP_ACP,  <br>        0,  <br>        SourceDirectories,  <br>        Length, <br>        g_SourceDirectories, <br>        Length * sizeof (WCHAR), <br>        NULL, <br>        NULL <br>        ); <br> <br>    // <br>    // Now generate the derived file names <br>    // <br> <br>    GenerateFilePaths(); <br> <br>    // <br>    // Note: We have no use for g_SourceDirectories for the screen saver <br>    //       upgrade.  The g_SourceDirectories string points to the Windows <br>    //       NT media (i.e. e:\i386) and optional directories specified on <br>    //       the WINNT32 command line. <br>    // <br> <br>    return ERROR_SUCCESS; <br>} <br> <br> <br> <br>LONG <br>CALLBACK  <br>MigrateUserNT ( <br>IN      HINF UnattendInfHandle, <br>IN      HKEY UserRegKey, <br>IN      LPCWSTR UserName, <br>            LPVOID Reserved <br>) <br>{ <br>    HKEY DesktopRegKey; <br>    DWORD rc = ERROR_SUCCESS; <br>    BOOL b = TRUE; <br> <br>    // <br>    // Setup gives us the UnattendInfHandle instead of the file name, <br>    // so we don't have to open the inf file repeatitively.  Since <br>    // Setup opened the handle, let Setup close it. <br>    // <br> <br>    // <br>    // Convert UserName to ANSI <br>    // <br> <br>    if (UserName) { <br>        WideCharToMultiByte ( <br>            CP_ACP,  <br>            0,  <br>            UserName,  <br>            -1, <br>            g_UserNameBuf, <br>            MAX_PATH, <br>            NULL, <br>            NULL <br>            ); <br> <br>        g_User = g_UserNameBuf; <br>    } else { <br>        g_User = S_DEFAULT_USER; <br>    } <br> <br>    // <br>    // Setup copies all of the Win9x registry, EXCEPT for the registry <br>    // keys that are suppressed in usermig.inf or wkstamig.inf. <br>    // <br>    // We need the HKCU\Control Panel\Desktop key, and because this is <br>    // an OS key, the settings have been altered. Most applications <br>    // store their settings in HKCU\Software, HKLM\Software or  <br>    // HKCC\Software, and all three of these keys are copied in their <br>    // entirety (except the operating system settings in  <br>    // Software\Microsoft\Windows). <br>    // <br>    // When the non-OS software settings are copied from Win9x to NT, Setup <br>    // sometimes alters their value.  For example, all registry values <br>    // that point to a file that was moved from SYSTEM to SYSTEM32 <br>    // are modified to point to the right place. <br>    // <br> <br>    // <br>    // Note: we use CreateRegKey here, but actually the key always exists <br>    // because the NT defaults have been copied into the user's registry <br>    // already.  This approach reduces the possibility of failure. <br>    // <br> <br>    DesktopRegKey = CreateRegKey (UserRegKey, REGKEY_DESKTOP); <br>    if (!DesktopRegKey) { <br>        CHAR Msg[512]; <br> <br>        rc = GetLastError(); <br>        wsprintf (Msg, S_REGISTRY_ERROR, g_User, rc); <br>        SetupLogError (Msg, LogSevError); <br> <br>        return rc; <br>    } <br> <br>    // The variable b is used to fall through when we fail unexpectedly <br> <br>    b = TranslateGeneralSetting ( <br>            DesktopRegKey,  <br>            REGVAL_SCREENSAVEACTIVE,  <br>            NULL <br>            ); <br> <br>    if (b) { <br>        b = TranslateGeneralSetting ( <br>                DesktopRegKey,  <br>                REGVAL_SCREENSAVELOWPOWERACTIVE,  <br>                REGVAL_LOWPOWERACTIVE <br>                ); <br>    } <br>    if (b) { <br>        b = TranslateGeneralSetting ( <br>                DesktopRegKey,  <br>                REGVAL_SCREENSAVELOWPOWERTIMEOUT,  <br>                REGVAL_LOWPOWERTIMEOUT <br>                ); <br>    } <br>    if (b) { <br>        b = TranslateGeneralSetting ( <br>                DesktopRegKey,  <br>                REGVAL_SCREENSAVEPOWEROFFACTIVE,  <br>                REGVAL_POWEROFFACTIVE <br>                ); <br>    } <br>    if (b) { <br>        b = TranslateGeneralSetting ( <br>                DesktopRegKey,  <br>                REGVAL_SCREENSAVEPOWEROFFTIMEOUT,  <br>                REGVAL_POWEROFFTIMEOUT <br>                ); <br>    } <br>    if (b) { <br>        b = TranslateGeneralSetting ( <br>                DesktopRegKey,  <br>                REGVAL_SCREENSAVETIMEOUT,  <br>                NULL <br>                ); <br>    } <br>    if (b) { <br>        b = TranslateGeneralSetting ( <br>                DesktopRegKey,  <br>                REGVAL_SCREENSAVEUSEPASSWORD,  <br>                REGVAL_SCREENSAVERISSECURE <br>                ); <br>    } <br> <br>    if (b) { <br>        b = SaveScrName (DesktopRegKey, S_SCRNSAVE_EXE); <br>    } <br> <br>    if (b) { <br>        // <br>        // For screen savers work differently on Win9x and NT, perform <br>        // translation. <br>        // <br> <br>        TranslateScreenSavers (UserRegKey); <br>         <br>        // <br>        // The other settings just need to be copied from control.ini <br>        // to the registry. <br>        // <br> <br>        CopyUntranslatedSettings (UserRegKey); <br>    } <br> <br> <br>    CloseRegKey (DesktopRegKey); <br> <br>    // <br>    // Always return success, because if an error occurred for one user, <br>    // we don't have a reason not to process the next user.  If your DLL <br>    // runs into a fatal problem, such as a disk space shortage, you <br>    // should return the error. <br>    // <br> <br>    return ERROR_SUCCESS; <br>} <br> <br> <br>LONG <br>CALLBACK  <br>MigrateSystemNT ( <br>IN      HINF UnattendInfHandle, <br>            LPVOID Reserved <br>) <br>{ <br>    CHAR FileName[MAX_PATH]; <br>    HINF MigrateInf; <br>    INFCONTEXT ic; <br>    CHAR Msg[512]; <br> <br>    // <br>    // We now delete the Win9x screen savers that were replaced <br>    // by Windows NT. <br>    // <br> <br>    MigrateInf = SetupOpenInfFile ( <br>                        g_MigrateDotInf, <br>                        NULL, <br>                        INF_STYLE_WIN4, <br>                        NULL <br>                        ); <br> <br>    if (MigrateInf != INVALID_HANDLE_VALUE) { <br> <br>        // <br>        // Use Setup APIs to scan migration paths section <br>        // <br> <br>        if (SetupFindFirstLine (MigrateInf, S_MIGRATION_PATHS, NULL, &amp;ic)) { <br>            do { <br>                if (SetupGetStringField (&amp;ic, 0, FileName, MAX_PATH, NULL)) { <br>                    // <br>                    // All 32-bit binaries located in the Win9x system directory <br>                    // were moved to system32.  However, the paths reported in <br>                    // [Migration Paths] are the original Win9x paths.  We <br>                    // convert c:\windows\system\file to c:\windows\system32\file. <br>                    // <br> <br>                    ConvertSystemToSystem32 (FileName); <br> <br>                    // <br>                    // Now delete the file. Ignore errors because user may have  <br>                    // lost power, and we may be going through this a second time. <br>                    // <br> <br>                    if (!DeleteFile (FileName)) { <br>                        wsprintf (Msg, DELETEFILE_ERROR, FileName, GetLastError()); <br>                        SetupLogError (Msg, LogSevError); <br>                    } else { <br>                        wsprintf (Msg, DELETEFILE_SUCCESS, FileName); <br>                        SetupLogError (Msg, LogSevInformation); <br>                    } <br>                } <br>            } while (SetupFindNextLine (&amp;ic, &amp;ic)); <br>        } <br>     <br>        SetupCloseInfFile (MigrateInf); <br>    } <br> <br>    return ERROR_SUCCESS; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
