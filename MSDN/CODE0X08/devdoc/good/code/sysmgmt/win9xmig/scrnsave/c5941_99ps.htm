<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5950"></a>UTILS.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    utils.c <br> <br>Abstract: <br> <br>    This source file implements utility functions used by scrnsave.c. <br> <br>Author: <br> <br>    Jim Schmidt (jimschm) 11-Apr-1997 <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#include "pch.h" <br> <br>#ifdef UNICODE <br>#error UNICODE cannot be defined <br>#endif <br> <br>// <br>// Declare strings <br>// <br> <br>#define DEFMAC(var,str) CHAR var[] = str; <br>DEFINE_STRINGS <br>#undef DEFMAC <br> <br>// <br>// Temporary buffer <br>// <br> <br>static CHAR g_Data[MAX_PATH]; <br> <br>// <br>// Buffer for string representation of registry keys (for error logging) <br>// <br> <br>typedef struct _tagKEYTOSTR { <br>    struct _tagKEYTOSTR *Prev, *Next; <br>    HKEY Key; <br>    CHAR RegKey[]; <br>} KEYTOSTR, *PKEYTOSTR; <br> <br>static PKEYTOSTR g_Head = NULL; <br> <br>VOID <br>pAddKeyToStrMapping ( <br>    IN      HKEY Key, <br>    IN      LPCSTR RootStr, <br>    IN      LPCSTR KeyStr <br>    ) <br>{ <br>    PKEYTOSTR Node; <br>    DWORD Size; <br>    CHAR FullKeyStr[MAX_PATH]; <br> <br>    // We control RootStr and KeyStr, so we know it is less than MAX_PATH in length <br>    wsprintf (FullKeyStr, "%s\\%s", RootStr, KeyStr); <br> <br>    Size = sizeof (KEYTOSTR) + CountStringBytes (FullKeyStr); <br> <br>    Node = (PKEYTOSTR) HeapAlloc (g_hHeap, 0, Size); <br>    if (Node) { <br>        Node-&gt;Prev = NULL; <br>        Node-&gt;Next = g_Head; <br>        Node-&gt;Key = Key; <br>        _mbscpy (Node-&gt;RegKey, FullKeyStr); <br> <br>        if (g_Head) { <br>            g_Head-&gt;Prev = Node; <br>        } <br>        g_Head = Node; <br>    } <br>} <br> <br>PKEYTOSTR <br>pFindKeyToStrMapping ( <br>    IN      HKEY Key <br>    ) <br>{ <br>    PKEYTOSTR Node; <br> <br>    Node = g_Head; <br>    while (Node) { <br>        if (Node-&gt;Key == Key) { <br>            return Node; <br>        } <br>        Node = Node-&gt;Next; <br>    } <br> <br>    return NULL; <br>} <br> <br>VOID <br>pRemoveKeyToStrMapping ( <br>    IN      HKEY Key <br>    ) <br>{ <br>    PKEYTOSTR Node; <br> <br>    Node = pFindKeyToStrMapping (Key); <br>    if (!Node) { <br>        return; <br>    } <br> <br>    if (Node-&gt;Prev) { <br>        Node-&gt;Prev-&gt;Next = Node-&gt;Next; <br>    } else { <br>        g_Head = Node-&gt;Next; <br>    } <br> <br>    if (Node-&gt;Next) { <br>        Node-&gt;Next-&gt;Prev = Node-&gt;Prev; <br>    } <br> <br>    HeapFree (g_hHeap, 0, Node); <br>} <br>     <br> <br>VOID <br>LogRegistryError ( <br>    IN      HKEY Key, <br>    IN      LPCSTR ValueName <br>    ) <br>{ <br>    DWORD rc = GetLastError(); <br>    CHAR Msg[512]; <br>    LPCSTR FullKeyStr; <br>    PKEYTOSTR Node; <br> <br>    Node = pFindKeyToStrMapping (Key); <br>    if (Node) { <br>        FullKeyStr = Node-&gt;RegKey; <br>    } else { <br>        FullKeyStr = S_DEFAULT_KEYSTR; <br>    } <br> <br>    wsprintf (Msg, S_REGISTRY_ERROR, g_User, rc, FullKeyStr, ValueName); <br>    SetupLogError (Msg, LogSevError); <br>} <br> <br> <br>VOID <br>GenerateFilePaths ( <br>    VOID <br>    ) <br>{ <br>    INT Len; <br> <br>    // Safety (unexpected condition) <br>    if (!g_WorkingDirectory) { <br>        return; <br>    } <br> <br>    Len = CountStringBytes (g_WorkingDirectory) + sizeof(S_SETTINGS_MASK); <br>    g_SettingsFile = (LPSTR) HeapAlloc (g_hHeap, 0, Len); <br>    if (!g_SettingsFile) { <br>        return; <br>    } <br>    wsprintf (g_SettingsFile, S_SETTINGS_MASK, g_WorkingDirectory); <br> <br>    Len = CountStringBytes (g_WorkingDirectory) + sizeof(S_MIGINF_MASK); <br>    g_MigrateDotInf = (LPSTR) HeapAlloc (g_hHeap, 0, Len); <br>    if (!g_MigrateDotInf) { <br>        return; <br>    } <br>    wsprintf (g_MigrateDotInf, S_MIGINF_MASK, g_WorkingDirectory); <br>} <br> <br> <br>HKEY <br>OpenRegKey ( <br>    IN      HKEY RootKey, <br>    IN      LPCSTR KeyStr <br>    ) <br>{ <br>    HKEY Key; <br>    LONG rc; <br> <br>    rc = RegOpenKeyEx (RootKey, KeyStr, 0, KEY_ALL_ACCESS, &amp;Key); <br>    if (rc != ERROR_SUCCESS) { <br>        SetLastError (rc); <br>        return NULL; <br>    } <br> <br>    pAddKeyToStrMapping (Key, S_HKR, KeyStr); <br> <br>    return Key; <br>} <br> <br> <br>HKEY <br>CreateRegKey ( <br>    IN      HKEY RootKey, <br>    IN      LPCSTR KeyStr <br>    ) <br>{ <br>    HKEY Key; <br>    LONG rc; <br>    DWORD DontCare; <br> <br>    pAddKeyToStrMapping (NULL, S_HKR, KeyStr); <br> <br>    rc = RegCreateKeyEx (RootKey, KeyStr, 0, S_EMPTY, 0,  <br>                         KEY_ALL_ACCESS, NULL, &amp;Key, &amp;DontCare); <br>    if (rc != ERROR_SUCCESS) { <br>        SetLastError (rc); <br>        LogRegistryError (NULL, S_EMPTY); <br>        pRemoveKeyToStrMapping (NULL); <br>        return NULL; <br>    } <br> <br>    pRemoveKeyToStrMapping (NULL); <br>    pAddKeyToStrMapping (Key, S_HKR, KeyStr); <br> <br>    return Key; <br>} <br> <br>VOID <br>CloseRegKey ( <br>    IN      HKEY Key <br>    ) <br>{ <br>    pRemoveKeyToStrMapping (Key); <br>    RegCloseKey (Key); <br>} <br> <br> <br>LPCSTR <br>GetRegValueString ( <br>    IN      HKEY Key, <br>    IN      LPCSTR ValueName <br>    ) <br>{ <br>    static CHAR DataBuf[MAX_PATH]; <br>    DWORD Size; <br>    LONG rc; <br>    DWORD Type; <br>    DWORD d; <br> <br>    Size = MAX_PATH; <br>    rc = RegQueryValueEx (Key, ValueName, NULL, &amp;Type, DataBuf, &amp;Size); <br>    SetLastError (rc); <br> <br>    if (rc != ERROR_SUCCESS) { <br>        return NULL; <br>    } <br> <br>    if (Type == REG_DWORD) { <br>        d = *((PDWORD) DataBuf); <br>        wsprintf (DataBuf, "%u", d); <br>    } <br>    else if (Type != REG_SZ) { <br>        return NULL; <br>    } <br> <br>    return DataBuf; <br>} <br> <br>BOOL <br>SetRegValueString ( <br>    HKEY Key, <br>    LPCSTR ValueName, <br>    LPCSTR ValueStr <br>    ) <br>{ <br>    LONG rc; <br>    LPCSTR p; <br> <br>    p = _mbschr (ValueStr, 0); <br>    p++; <br> <br>    rc = RegSetValueEx (Key, ValueName, 0, REG_SZ, ValueStr, p - ValueStr); <br>    SetLastError (rc); <br> <br>    if (rc != ERROR_SUCCESS) { <br>        LogRegistryError (Key, ValueName); <br>    } <br> <br>    return rc == ERROR_SUCCESS; <br>} <br> <br> <br>LPCSTR <br>GetScrnSaveExe ( <br>    VOID <br>    ) <br>{ <br>    CHAR IniFileSetting[MAX_PATH]; <br> <br>    GetPrivateProfileString ( <br>            S_BOOT,  <br>            S_SCRNSAVE_EXE,  <br>            S_EMPTY,  <br>            IniFileSetting,  <br>            MAX_PATH,  <br>            S_SYSTEM_INI <br>            ); <br> <br>    if (!IniFileSetting[0]) { <br>        return NULL; <br>    } <br> <br>    if (!OurGetLongPathName (IniFileSetting, g_Data)) { <br>        // File does not exist <br>        return NULL; <br>    } <br> <br>    return g_Data[0] ? g_Data : NULL; <br>} <br> <br>INT <br>_mbsbytes ( <br>    IN      LPCSTR str <br>    ) <br>{ <br>    LPCSTR p; <br> <br>    // Find the nul terminator and return the number of bytes <br>    // occupied by the characters in the string, but don't <br>    // include the nul. <br> <br>    p = _mbschr (str, 0); <br>    return (p - str); <br>} <br> <br> <br>DWORD <br>CountStringBytes ( <br>    IN      LPCSTR str <br>    ) <br>{ <br>    // Return bytes in string, plus 1 for the nul <br>    return _mbsbytes (str) + 1; <br>} <br> <br>DWORD <br>CountMultiStringBytes ( <br>    IN      LPCSTR str <br>    ) <br>{ <br>    LPCSTR p; <br>    INT Total = 0; <br>    INT Bytes; <br> <br>    p = str; <br> <br>    do { <br>        Bytes = CountStringBytes (p); <br>        p += Bytes; <br>        Total += Bytes; <br>    } while (Bytes &gt; 1); <br> <br>    return Total; <br>} <br> <br> <br>LPSTR <br>CopyStringAtoB ( <br>    OUT     LPSTR mbstrDest,  <br>    IN      LPCSTR mbstrStart,  <br>    IN      LPCSTR mbstrEnd     // first char NOT to copy <br>    ) <br>{ <br>    LPSTR mbstrOrg; <br> <br>    mbstrOrg = mbstrDest; <br> <br>    // Assume mbstrEnd is on a lead byte <br> <br>    while (mbstrStart &lt; mbstrEnd) { <br>        if (isleadbyte (*mbstrStart)) { <br>            *mbstrDest = *mbstrStart; <br>            mbstrDest++; <br>            mbstrStart++; <br>        } <br> <br>        *mbstrDest = *mbstrStart; <br>        mbstrDest++; <br>        mbstrStart++; <br>    } <br> <br>    *mbstrDest = 0; <br> <br>    return mbstrOrg; <br>} <br> <br>LPSTR  <br>AppendStr ( <br>    OUT     LPSTR mbstrDest,  <br>    IN      LPCSTR mbstrSrc <br>    ) <br> <br>{ <br>    // Advance mbstrDest to end of string <br>    mbstrDest = _mbschr (mbstrDest, 0); <br> <br>    // Copy string <br>    while (*mbstrSrc) { <br>        *mbstrDest = *mbstrSrc++; <br>        if (isleadbyte (*mbstrDest)) { <br>            mbstrDest++; <br>            *mbstrDest = *mbstrSrc++; <br>        } <br>        mbstrDest++; <br>    } <br> <br>    *mbstrDest = 0; <br> <br>    return mbstrDest; <br>} <br> <br> <br>BOOL <br>pFindShortName ( <br>    IN      LPCTSTR WhatToFind, <br>    OUT     LPTSTR Buffer <br>    ) <br>{ <br>    WIN32_FIND_DATA fd; <br>    HANDLE hFind; <br> <br>    hFind = FindFirstFile (WhatToFind, &amp;fd); <br>    if (!hFind) { <br>        return FALSE; <br>    } <br> <br>    FindClose (hFind); <br>    _mbscpy (Buffer, fd.cFileName); <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>OurGetLongPathName ( <br>    IN      LPCSTR ShortPath, <br>    OUT     LPSTR Buffer <br>    ) <br>{ <br>    CHAR FullPath[MAX_PATH]; <br>    LPSTR FilePart; <br>    LPSTR BufferEnd; <br>    LPSTR p, p2; <br>    CHAR c; <br> <br>    // <br>    // Convert ShortPath into complete path name <br>    // <br> <br>    if (!_mbschr (ShortPath, TEXT('\\'))) { <br>        if (!SearchPath (NULL, ShortPath, NULL, MAX_PATH, FullPath, &amp;FilePart)) { <br>            return FALSE; <br>        } <br>    } else { <br>        GetFullPathName (ShortPath, MAX_PATH, FullPath, &amp;FilePart); <br>    } <br> <br>    // <br>    // Convert short path to long path <br>    // <br> <br>    p = FullPath; <br> <br>    // Don't process non-local paths <br>    if (!(*p) || _mbsnextc (_mbsinc (p)) != TEXT(':')) { <br>        _mbscpy (Buffer, FullPath); <br>        return TRUE; <br>    } <br> <br>    p = _mbsinc (p); <br>    p = _mbsinc (p); <br>    if (_mbsnextc (p) != TEXT('\\')) { <br>        _mbscpy (Buffer, FullPath); <br>        return TRUE; <br>    } <br>     <br>    // Copy drive letter to buffer <br>    p = _mbsinc (p); <br>    CopyStringAtoB (Buffer, FullPath, p); <br>    BufferEnd = _mbschr (Buffer, 0); <br> <br>    // Convert each portion of the path <br>    do { <br>        // Locate end of this file or dir <br>        p2 = _mbschr (p, TEXT('\\')); <br>        if (!p2) { <br>            p = _mbschr (p, 0); <br>        } else { <br>            p = p2; <br>        } <br> <br>        // Look up file <br>        c = *p; <br>        *p = 0; <br>        if (!pFindShortName (FullPath, BufferEnd)) { <br>            return FALSE; <br>        } <br>        *p = c; <br> <br>        // Move on to next part of path <br>        BufferEnd = _mbschr (BufferEnd, 0); <br>        if (*p) { <br>            p = _mbsinc (p); <br>            BufferEnd = AppendStr (BufferEnd, TEXT("\\")); <br>        } <br>    } while (*p); <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>CreateScreenSaverParamKey ( <br>    IN      LPCSTR ScreenSaverName, <br>    IN      LPCSTR ValueName, <br>    OUT     LPSTR Buffer <br>    ) <br>{ <br>    // <br>    // Make sure we cannot create a string bigger than MAX_PATH <br>    // <br> <br>    if (_mbslen (ScreenSaverName) + 4 + _mbslen (ValueName) &gt; MAX_PATH) { <br>        return FALSE; <br>    } <br> <br>    // <br>    // Format the string with length of screen saver name, screen saver name, <br>    // and value name. <br>    // <br> <br>    wsprintf (Buffer, "%03u/%s/%s", _mbslen (ScreenSaverName), ScreenSaverName, ValueName); <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>DecodeScreenSaverParamKey ( <br>    IN      LPCSTR EncodedString, <br>    OUT     LPSTR ScreenSaverName, <br>    OUT     LPSTR ValueName <br>    ) <br>{ <br>    INT Len; <br> <br>    // <br>    // Validate encoded string.  It is in the form of ###/screen saver name/value name. <br>    // <br> <br>    Len = atoi (EncodedString); <br>    if (Len &lt; 0 || Len &gt;= MAX_PATH || (Len - 5) &gt; (INT) _mbslen (EncodedString)) { <br>        return FALSE; <br>    } <br> <br>    if (EncodedString[3] != '/' || EncodedString[4 + Len] != '/') { <br>        return FALSE; <br>    } <br> <br>    if (_mbslen (EncodedString + 5 + Len) &gt;= MAX_PATH) { <br>        return FALSE; <br>    } <br> <br>    // <br>    // Extract screen saver name and value name <br>    // <br> <br>    _mbsncpy (ScreenSaverName, EncodedString + 4, Len); <br>    ScreenSaverName[Len] = 0; <br> <br>    _mbscpy (ValueName, EncodedString + 5 + Len); <br>    return TRUE; <br>} <br> <br>LPSTR <br>_mbsistr ( <br>    IN      LPCSTR mbstrStr,  <br>    IN      LPCSTR mbstrSubStr <br>    ) <br>{ <br>    LPCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos; <br>    LPCSTR mbstrEnd; <br> <br>    mbstrEnd = (LPSTR) ((LPBYTE) mbstrStr + _mbsbytes (mbstrStr) - _mbsbytes (mbstrSubStr)); <br> <br>    for (mbstrStart = mbstrStr ; mbstrStart &lt;= mbstrEnd ; mbstrStart = _mbsinc (mbstrStart)) { <br>        mbstrStrPos = mbstrStart; <br>        mbstrSubStrPos = mbstrSubStr; <br> <br>        while (*mbstrSubStrPos &amp;&amp;  <br>               _mbctolower ((INT) _mbsnextc (mbstrSubStrPos)) == _mbctolower ((INT) _mbsnextc (mbstrStrPos)))  <br>        { <br>            mbstrStrPos = _mbsinc (mbstrStrPos); <br>            mbstrSubStrPos = _mbsinc (mbstrSubStrPos); <br>        } <br> <br>        if (!(*mbstrSubStrPos)) <br>            return (LPSTR) mbstrStart; <br>    } <br> <br>    return NULL;     <br>} <br> <br>VOID <br>DeletePartOfString ( <br>    IN      LPSTR Buffer, <br>    IN      DWORD CharsToDelete <br>    ) <br>{ <br>    LPSTR p; <br>    DWORD d; <br> <br>    p = Buffer; <br>    for (d = 0 ; *p &amp;&amp; d &lt; CharsToDelete ; d++) { <br>        p = _mbsinc (p); <br>    } <br> <br>    if (!(*p)) { <br>        *Buffer = 0; <br>    } else { <br>        MoveMemory (Buffer, p, CountStringBytes(p)); <br>    } <br>} <br> <br>VOID <br>InsertStringInString ( <br>    IN      LPSTR Buffer, <br>    IN      LPCSTR StringToInsert <br>    ) <br>{ <br>    DWORD BytesToMove; <br>    DWORD BytesOfInsertedString; <br> <br>    BytesToMove = CountStringBytes (Buffer); <br>    BytesOfInsertedString = _mbsbytes(StringToInsert); <br>    MoveMemory (Buffer + BytesOfInsertedString,  <br>                Buffer, <br>                BytesToMove <br>                ); <br>    _mbsncpy (Buffer, StringToInsert, _mbslen (StringToInsert)); <br>} <br> <br> <br>VOID <br>ConvertSystemToSystem32 ( <br>    IN OUT  LPSTR FileName <br>    ) <br>{ <br>    LPSTR p; <br> <br>    // look for \system\ in the path somewhere <br>    p = _mbsistr (FileName, S_SYSTEM_DIR); <br>    if (p) { <br>        // Remove "\system\" and replace with "\system32\" <br>        DeletePartOfString (p, _mbslen (S_SYSTEM_DIR)); <br>        InsertStringInString (p, S_SYSTEM32_DIR); <br>    } <br>} <br> <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
