<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MIGINF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5936"></a>MIGINF.C</h2>
<pre><code>#include "poolmem.h" <br>#include "miginf.h" <br>#include &lt;setupapi.h&gt; <br> <br>#define MIGRATEINF              ".\\migrate.inf" <br>#define INITIALBUFFERSIZE       1024 <br>#define MIGINF_NOCREATE         FALSE <br>#define MIGINF_CREATE           TRUE <br> <br> <br>typedef struct tagMIGOBJECT MIGOBJECT, *PMIGOBJECT; <br>struct tagMIGOBJECT { <br> <br>    PSTR        Key; <br>    PSTR        Value; <br>     <br>    PMIGOBJECT  Next; <br>}; <br> <br>typedef struct tagMIGSECTION MIGSECTION, * PMIGSECTION; <br>struct tagMIGSECTION { <br> <br>    PSTR        Name; <br>    PMIGOBJECT  Items; <br> <br>    PMIGSECTION Next; <br>}; <br> <br>PMIGSECTION g_MigrationInf; <br>POOLHANDLE  g_Pool = NULL; <br> <br> <br>static <br>PCSTR <br>pGetTypeAsString ( <br>    IN MIGTYPE Type <br>    ) <br>{ <br>    // <br>    // Note: Strings must be in the same order as the  <br>    // corresponding types in the MIGTYPE enumeration above. <br>    // <br>    static PCHAR typeStrings[] = { <br>            "FIRST - Invalid", <br>            "File", <br>            "Path", <br>            "Registry", <br>            "Message - Invalid", <br>            "LAST - Invalid" <br>        }; <br> <br>    assert(Type &gt; MIG_FIRSTTYPE &amp;&amp; Type &lt; MIG_LASTTYPE); <br> <br>    return typeStrings[Type]; <br>} <br> <br>static <br>PMIGSECTION  <br>pFindSection ( <br>    IN PCSTR SectionString, <br>    IN BOOL  CreateIfNotExist <br>    ) <br>{ <br>    PMIGSECTION rSection; <br> <br>    // <br>    // We assume that SectionString is not null. <br>    // <br>    assert(SectionString); <br> <br>    rSection = g_MigrationInf; <br> <br>    while (rSection &amp;&amp; (_mbsicmp(rSection -&gt; Name,SectionString) != 0)) { <br> <br>        // <br>        // Continue looking. <br>        // <br>        rSection = rSection -&gt; Next; <br>    } <br>         <br>    if (!rSection &amp;&amp; CreateIfNotExist) { <br>        // <br>        // No section was found matching this name. Make a new section and add it  <br>        // to the list. <br>        // <br>        rSection = PoolMemGetMemory(g_Pool,sizeof(MIGSECTION)); <br>        if (rSection) { <br> <br>            ZeroMemory(rSection,sizeof(MIGSECTION)); <br>            rSection -&gt; Name  = PoolMemDuplicateStringA(g_Pool,SectionString); <br>            rSection -&gt; Next  = g_MigrationInf; <br>            g_MigrationInf    = rSection; <br> <br>            if (!rSection -&gt; Name) { <br>                // <br>                // Something went wrong when we tried to duplicate the SectionString. <br>                // NULL out the rSection so that the caller doesn't get back a  <br>                // malformed section object. <br>                // <br>                rSection = NULL; <br>            } <br>        } <br>    } <br> <br>    return rSection; <br>} <br> <br>static <br>BOOL <br>pPathIsInPath( <br>    IN PCSTR    SubPath, <br>    IN PCSTR    ParentPath <br>    ) <br>{ <br>    DWORD parentLength; <br>    BOOL  rInPath; <br> <br>    // <br>    // This function assumes both parameters are non-NULL. <br>    // <br>    assert(SubPath); <br>    assert(ParentPath); <br>     <br>    parentLength = _mbslen(ParentPath); <br> <br>    // <br>    // A path is considered "in" another path if the path is in the ParentPath <br>    // or a subdirectory of it. <br>    // <br>    rInPath = !_mbsnicmp(SubPath,ParentPath,parentLength); <br> <br>    if (rInPath) { <br>        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\'; <br>    } <br> <br>    return rInPath; <br> <br>} <br> <br>static <br>DWORD <br>pGetMbsSize ( <br>    IN  LPCSTR  String <br>    ) <br>{ <br>    DWORD rLength; <br>     <br>    rLength = (DWORD) _mbschr(String,0) - (DWORD) String + 1; <br> <br>    return rLength; <br> <br>} <br> <br> <br>static <br>LPSTR  <br>pEscapeString ( <br>    IN  MIGTYPE Type, <br>    OUT LPSTR   EscapedString,  <br>    IN  LPCSTR  String <br>    ) <br> <br>{ <br>    LPSTR   stringStart; <br>    static  CHAR exclusions[] = "[]~,;%\""; <br>    INT     currentChar; <br> <br>    // <br>    // We assume that all parameters are valid. <br>    // <br>    assert(EscapedString &amp;&amp; String); <br> <br>    stringStart = EscapedString; <br> <br>    while (*String)  { <br>        currentChar = _mbsnextc (String); <br>         <br>        if (Type == MIG_REGKEY) { <br>             <br>            // <br>            // Registry keys require more complex escaping than do normal INF strings. <br>            // <br>            if (!_ismbcprint (currentChar) || _mbschr (exclusions, currentChar)) { <br>                 <br>                // <br>                // Escape unprintable or excluded character <br>                // <br>                wsprintfA (EscapedString, "~%X~", currentChar); <br>                EscapedString = _mbschr (EscapedString, 0); <br>                String = _mbsinc (String); <br>            } <br>            else { <br>                // <br>                // Copy multibyte character <br>                // <br>                if (isleadbyte (*String)) { <br>                    *EscapedString = *String; <br>                    EscapedString++; <br>                    String++; <br>                } <br>                 <br>                *EscapedString = *String; <br>                EscapedString++; <br>                String++; <br>            } <br>        } <br>        else { <br> <br>            // <br>            // Escaping is pretty simple for non-registry keys. All we do is double up <br>            // quotes and percents. <br>            // <br>            if (*String == '\"' || *String == '%') { <br> <br>                *EscapedString = *String; <br>                EscapedString++; <br>            } <br>             <br>            // <br>            // Copy multibyte character <br>            // <br>            if (isleadbyte (*String)) { <br>                *EscapedString = *String; <br>                EscapedString++; <br>                String++; <br>            } <br>             <br>            *EscapedString = *String; <br>            EscapedString++; <br>            String++; <br>        } <br>    } <br> <br>    // <br>    // Ensure that returned string is NULL terminated. <br>    // <br>    *EscapedString = 0; <br> <br>    return stringStart; <br>} <br> <br> <br>static <br>PSTR <br>pGetValueString ( <br>    IN MIGTYPE    ObjectType, <br>    IN LPCSTR     StringOne, <br>    IN LPCSTR     StringTwo <br>    ) <br>{ <br>    static PSTR     buffer; <br>    static DWORD    bufferSize; <br>    DWORD           maxLength; <br>    PSTR            bufferEnd; <br>     <br>    // <br>    // This function assumes that StringOne exists. <br>    // <br>    assert(StringOne); <br> <br>    if (ObjectType == MIG_REGKEY) { <br>        // <br>        // Size: size of both strings, plus the size of the quotes, plus the size of the brackets  <br>        // for the value, * 6. This is the maximum size one of these could grow to, if every  <br>        // character had to be escaped out. <br>        // <br>        maxLength = (pGetMbsSize(StringOne) + (StringTwo ? pGetMbsSize(StringTwo) + 2 : 0)) * 6 + 2; <br>    } <br>    else { <br>        // <br>        // Size: size of the string * 2 (The max size if every char was a '%' or '"' plus the quotes. <br>        // <br>        maxLength = pGetMbsSize(StringOne) * 2 + 2; <br>    } <br> <br>    if (maxLength &gt; bufferSize) { <br> <br>        // <br>        // Initialize our buffer, or create a larger one. <br>        // <br>        bufferSize = (maxLength &gt; INITIALBUFFERSIZE) ? maxLength : INITIALBUFFERSIZE; <br>        buffer = PoolMemCreateStringA(g_Pool,bufferSize); <br>    } <br> <br>    if (buffer != NULL) { <br>         <br>        // <br>        // Insert initial quote. <br>        // <br>        *buffer = '"'; <br>  <br>        // <br>        // Massage the string to ensure it is a valid INF file string. <br>        // <br>        pEscapeString(ObjectType,_mbsinc(buffer),StringOne); <br> <br>        // <br>        // If this is a REGISTRY entry, then we also need to add the value part of the string,  <br>        // if one was specified (In StringTwo) <br>        // <br> <br>        if (ObjectType == MIG_REGKEY &amp;&amp; StringTwo) { <br> <br>            // <br>            // Add the opening bracket. <br>            // <br>            bufferEnd = _mbschr(buffer,0); <br>            *bufferEnd = '['; <br>             <br>            // <br>            // Add the value string in, again making sure the string is valid for an INF file. <br>            // <br>            pEscapeString(ObjectType,_mbsinc(bufferEnd),StringTwo); <br> <br>            // <br>            // Now, add the closing braket. <br>            // <br>            bufferEnd = _mbschr(buffer,0); <br>            *bufferEnd = ']'; <br> <br>            // <br>            // Terminate the string. <br>            // <br>            bufferEnd = _mbsinc(bufferEnd); <br>            *bufferEnd = 0; <br>        } <br> <br>        // <br>        // Add the final quote. <br>        // <br>        bufferEnd = _mbschr(buffer,0); <br>        *bufferEnd = '"'; <br>        bufferEnd = _mbsinc(bufferEnd); <br>        *bufferEnd = 0; <br>    } <br>     <br>    return buffer; <br>} <br> <br>static <br>BOOL <br>pCreateMigObject ( <br>    IN MIGTYPE          ObjectType, <br>    IN PCSTR            ParamOne, <br>    IN PCSTR            ParamTwo, <br>    IN PMIGSECTION      Section <br>    ) <br>{ <br>    BOOL            rSuccess; <br>    PMIGOBJECT      newObject = NULL; <br> <br>    // <br>    // pCreateMigObject uses a set of hueristics to correctly assemble an object.  <br>    // These hueristics are based on the ObjectType and the contents of ParamTwo. <br>    //  <br>    // ObjectType       ParamTwo      Key                   Value <br>    // ------------------------------------------------------------------------- <br>    // MIG_REGKEY       &lt;any&gt;         ParamOne[ParamTwo]    Registry <br>    // &lt;other&gt;          NULL          ParamOne              &lt;ObjectType As String&gt; <br>    // &lt;other&gt;          non-NULL      ParamOne              ParamTwo <br>    // <br>    // <br> <br> <br>    if (Section) { <br> <br>        // <br>        // First, create an object... <br>        // <br>        newObject = PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT)); <br> <br>        if (newObject) { <br> <br>            if (ObjectType == MIG_REGKEY) { <br> <br>                newObject -&gt; Key =  <br>                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,ParamTwo)); <br> <br>                newObject -&gt; Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType)); <br>            } <br>            else { <br>                 <br>                newObject -&gt; Key =  <br>                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,NULL)); <br> <br>                if (ParamTwo) { <br>                    newObject -&gt; Value = <br>                        PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamTwo,NULL)); <br>                } <br>                else { <br> <br>                    newObject -&gt; Value =  <br>                        PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType)); <br>                } <br>            } <br>        } <br>    } <br> <br> <br>    if (newObject &amp;&amp; newObject -&gt; Key &amp;&amp; newObject -&gt; Value) { <br> <br>        // <br>        // The object has been successfully created. Link it into the section. <br>        // <br>        newObject -&gt; Next = Section -&gt; Items; <br>        Section -&gt; Items = newObject; <br>        rSuccess = TRUE; <br>    } <br>    else { <br>        rSuccess = FALSE; <br>    } <br> <br>    return newObject &amp;&amp; newObject -&gt; Key &amp;&amp; newObject -&gt; Value; <br>} <br> <br> <br>static <br>BOOL <br>pWriteInfSectionToDisk ( <br>    IN PMIGSECTION Section <br>    ) <br>{ <br>    PMIGOBJECT curObject; <br>    BOOL       rSuccess = TRUE; <br> <br>    if (Section) { <br> <br>        curObject = Section -&gt; Items; <br> <br>        while (curObject &amp;&amp; rSuccess) { <br> <br>            if (Section -&gt; Name &amp;&amp; curObject -&gt; Key &amp;&amp; curObject -&gt; Value) { <br>             <br>                rSuccess = WritePrivateProfileString( <br>                    Section   -&gt; Name, <br>                    curObject -&gt; Key,  <br>                    curObject -&gt; Value, <br>                    MIGRATEINF <br>                    ); <br>            } <br> <br>            curObject = curObject -&gt; Next; <br>        } <br>    } <br>    else { <br>        rSuccess = FALSE; <br>    } <br> <br>    return rSuccess; <br>} <br> <br> <br>static <br>BOOL <br>pBuildListFromSection ( <br>    IN PCSTR    SectionString <br>    ) <br>{ <br>    HINF            infHandle; <br>    PMIGSECTION     section; <br>    PMIGOBJECT      currentObject; <br>    INFCONTEXT      ic; <br>    DWORD           size; <br>    BOOL            rSuccess = TRUE; <br> <br>    // <br>    // This function assumes that Section is non-NULL. <br>    // <br>    assert(SectionString); <br> <br>    currentObject = NULL; <br>     <br>    // <br>    // First find the section specified. <br>    // <br>    section = pFindSection(SectionString,MIGINF_CREATE); <br> <br>    if (section) { <br>         <br>        infHandle = SetupOpenInfFileA(MIGRATEINF,NULL,INF_STYLE_WIN4,NULL); <br>         <br>        if (infHandle != INVALID_HANDLE_VALUE) { <br>             <br>            if (SetupFindFirstLine(infHandle,SectionString,NULL,&amp;ic)) { <br>                 <br>                do { <br> <br>                    // <br>                    // Create the object. <br>                    // <br>                    currentObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT)); <br>                     <br>                    if (!currentObject) { <br>                        rSuccess = FALSE; <br>                        break; <br>                    } <br>                     <br>                    // <br>                    // Get the size of the string. <br>                    // <br>                    if (!SetupGetLineTextA(&amp;ic,NULL,NULL,NULL,NULL,0,&amp;size)) { <br>                        rSuccess = FALSE; <br>                        break; <br>                    } <br>                     <br>                    // <br>                    // Create a string large enough. <br>                    // <br>                    currentObject -&gt; Key = PoolMemCreateStringA(g_Pool,size); <br>                     <br>                    if (!currentObject -&gt; Key) { <br>                        rSuccess = FALSE; <br>                        break; <br>                    } <br>                     <br>                    // <br>                    // Get the string. <br>                    // <br>                    if (!SetupGetLineTextA(&amp;ic,NULL,NULL,NULL,currentObject -&gt; Key,size,NULL)) { <br>                        rSuccess = FALSE; <br>                        break; <br>                    } <br>                     <br>                    // <br>                    // Successfully retrieved the line. <br>                    // <br>                    currentObject -&gt; Value  = (PSTR) pGetTypeAsString(MIG_FILE); <br>                    currentObject -&gt; Next   = section -&gt; Items; <br>                    section -&gt; Items        = currentObject; <br>                     <br>                } while(SetupFindNextLine(&amp;ic,&amp;ic)); <br>                 <br>            } <br>             <br>            SetupCloseInfFile(infHandle); <br>        } <br>    } <br>    else { <br>        rSuccess = FALSE; <br>    } <br> <br>    return rSuccess; <br>} <br> <br> <br>BOOL <br>MigInf_Initialize( <br>    VOID <br>    ) <br>{ <br> <br>    // <br>    // First, initialize our pool and Zero out the structure. <br>    // <br>    g_Pool = PoolMemInitPool(); <br> <br> <br>    if (g_Pool) { <br>         <br>        // <br>        // Now, read in the migration paths and excluded paths sections. <br>        // <br>        if (!pBuildListFromSection(SECTION_MIGRATIONPATHS) || <br>            !pBuildListFromSection(SECTION_EXCLUDEDPATHS)) { <br>            // <br>            // Something went wrong (i.e. out of memory. Destroy and NULL our pool. <br>            // <br>            PoolMemDestroyPool(g_Pool); <br>            g_Pool = NULL; <br>        } <br>    } <br> <br>    // <br>    // If our memory pool initialized successfully, return TRUE. <br>    // <br>    return (g_Pool != NULL); <br> <br>} <br> <br> <br>VOID <br>MigInf_CleanUp ( <br>    VOID <br>    ) <br>{ <br>    // <br>    // Only thing we need to do is clean out pool mem. We'll NULL out the list header to make <br>    // sure it isn't usable. <br>    // <br>    if (g_Pool) { <br>        PoolMemDestroyPool(g_Pool); <br>        g_Pool = NULL; <br>    } <br>     <br>    g_MigrationInf = NULL; <br> <br>} <br> <br> <br>BOOL <br>MigInf_AddObject ( <br>    IN MIGTYPE  ObjectType, <br>    IN PCSTR    SectionString, <br>    IN PCSTR    ParamOne, <br>    IN PCSTR    ParamTwo <br>    ) <br>{ <br> <br>    return pCreateMigObject( <br>        ObjectType, <br>        ParamOne, <br>        ParamTwo, <br>        pFindSection(SectionString,MIGINF_CREATE) <br>        ); <br>} <br> <br>BOOL  <br> <br>MigInf_FirstInSection( <br>    IN PCSTR SectionName,  <br>    OUT PMIGINFSECTIONENUM Enum <br>    ) <br>{ <br>    PMIGSECTION section; <br> <br>    // <br>    // We assume that Enum is valid. <br>    // <br>    assert(Enum); <br> <br>    section = pFindSection(SectionName,MIGINF_NOCREATE); <br> <br>    if (section) { <br>        Enum -&gt; EnumKey = (PVOID) section -&gt; Items; <br>    } <br> <br>    return MigInf_NextInSection(Enum); <br>} <br> <br>BOOL  <br>MigInf_NextInSection( <br>    IN OUT PMIGINFSECTIONENUM Enum <br>    ) <br>{ <br> <br> <br>    BOOL            rSuccess = FALSE; <br> <br>    // <br>    // We assume that the Enum is valid. <br>    // <br>    assert(Enum); <br> <br>    if (Enum -&gt; EnumKey) { <br> <br>        Enum -&gt; Key     = ((PMIGOBJECT) (Enum -&gt; EnumKey)) -&gt; Key; <br>        Enum -&gt; Value   = ((PMIGOBJECT) (Enum -&gt; EnumKey)) -&gt; Value; <br>        Enum -&gt; EnumKey = ((PVOID) ((PMIGOBJECT) (Enum -&gt; EnumKey)) -&gt; Next); <br>        rSuccess = TRUE; <br>    } <br> <br>    return rSuccess; <br>} <br> <br> <br>BOOL <br>MigInf_WriteInfToDisk ( <br>    VOID <br>    ) <br>{ <br> <br>    BOOL        rSuccess = TRUE; <br>    PMIGSECTION curSection; <br>     <br>    // <br>    // Simply loop through all of the sections, writing each of them to disk. <br>    // As long as WriteSectionToDisk works, we work. <br>    // <br>    curSection = g_MigrationInf; <br> <br>    while (curSection &amp;&amp; rSuccess) { <br> <br>        // <br>        // We skip the [Excluded Paths] and [Migration Paths] sections. <br>        // <br>        if (_mbsicmp(curSection -&gt; Name,SECTION_EXCLUDEDPATHS) &amp;&amp; <br>            _mbsicmp(curSection -&gt; Name,SECTION_MIGRATIONPATHS)) { <br>             <br>            rSuccess = pWriteInfSectionToDisk(curSection); <br>        }  <br> <br>        curSection = curSection -&gt; Next; <br>         <br>    } <br> <br>    return rSuccess; <br>} <br> <br>BOOL <br>MigInf_PathIsExcluded ( <br>    IN PCSTR    Path <br>    ) <br>{ <br>    PMIGOBJECT  curExcluded; <br>    PMIGSECTION section; <br>    BOOL        rIsExcluded = FALSE; <br> <br>    // <br>    // We assume Path is valid. <br>    // <br>    assert(Path); <br>     <br>    section = pFindSection(SECTION_EXCLUDEDPATHS,MIGINF_NOCREATE); <br> <br>    if (section) { <br> <br>        curExcluded = section -&gt; Items; <br>         <br>        while (curExcluded &amp;&amp; !rIsExcluded) { <br>             <br>            rIsExcluded = pPathIsInPath(Path,curExcluded -&gt; Key); <br>            curExcluded = curExcluded -&gt; Next; <br>        } <br>    } <br>     <br>    return rIsExcluded; <br>} <br> <br> <br> <br> <br>BOOL  <br>MigInf_UseSpace ( <br>    IN PCSTR DriveRoot, <br>    IN LONGLONG Space <br>    )  <br>{ <br> <br>    BOOL rSuccess; <br>    PMIGSECTION section; <br>    static CHAR spaceString[MAX_PATH]; <br> <br>    section = pFindSection(SECTION_DISKSPACEUSED,MIGINF_CREATE); <br> <br>    if (section) { <br> <br>        sprintf(spaceString,"%I64u",Space); <br>        rSuccess = pCreateMigObject (MIG_FILE,DriveRoot,spaceString,section); <br>    } <br>    else { <br>        rSuccess = FALSE; <br>    } <br> <br>    return rSuccess; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
