<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PVIEWMIG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5940"></a>PVIEWMIG.C</h2>
<pre><code><br>#define STRICT <br>#define LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;setupapi.h&gt; <br>#include &lt;assert.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;mbstring.h&gt; <br>#include "miginf.h" <br> <br> <br>#define DIRECTORYKEY                "SOFTWARE\\Microsoft\\DevStudio\\5.0\\Products\\Microsoft Visual C++" <br>#define DIRECTORYVALUE               "ProductDir" <br>#define DIR_95SPECIFIC               "\\bin\\win95" <br>#define FILE_PVIEW                   "pview.exe" <br>#define MESSAGE                                                                                 \ <br>    "PVIEW.EXE has been found in one or more directories outside of your Visual C++ 5.0"        \ <br>    " installation directory. These copies will not be updated with the NT version."            \ <br> <br>#define MESSAGE_SECTION              "Microsoft\\Visual C++ 5.0\\Process Viewer" <br>#define SIZENEEDED                   100000L         <br> <br>#define CP_USASCII          1252 <br> <br>// <br>// 9x side globals. <br>// <br>const CHAR  g_ProductId[]                       = {"Microsoft Visual C++ 5.0"}; <br>UINT        g_DllVersion                        = 1; <br>INT         g_CodePageArray[]                   = {CP_USASCII,-1}; <br>CHAR        g_ExeNamesBuffer[]                  = {"pview95.exe\0""\0"}; <br> <br>// <br>// Nt side globals. <br>// <br> <br>// <br>// Uncomment next line to get popups. <br>// <br>#define MYDEBUG <br>#ifdef  MYDEBUG <br>#   define INFO(x)     (MessageBoxA(NULL,(x),"PVIEW Sample Migration Dll",MB_OK | MB_ICONINFORMATION)) <br>#else <br>#   define INFO(x) <br>#endif <br> <br> <br> <br> <br>static <br>BOOL <br>PathIsInPath( <br>    IN PCSTR    SubPath, <br>    IN PCSTR    ParentPath <br>    ) <br>{ <br>    DWORD parentLength; <br>    BOOL  rInPath; <br> <br>    // <br>    // This function assumes both parameters are non-NULL. <br>    // <br>    assert(SubPath); <br>    assert(ParentPath); <br>     <br>    parentLength = _mbslen(ParentPath); <br> <br>    // <br>    // A path is considered "in" another path if the path is in the ParentPath <br>    // or a subdirectory of it. <br>    // <br>    rInPath = !_mbsnicmp(SubPath,ParentPath,parentLength); <br> <br>    if (rInPath) { <br>        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\'; <br>    } <br> <br>    return rInPath; <br> <br>} <br> <br> <br>static <br>PSTR <br>GetPviewDirectoryNt ( <br>    VOID <br>    ) <br>{ <br>    HKEY    softwareKey; <br>    LONG    rc; <br>    LONG    valueType; <br>    LONG    sizeNeeded; <br>    PSTR    rString = NULL; <br> <br>    // <br>    // First, open the key. <br>    // <br>    rc = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>        DIRECTORYKEY, <br>        0, <br>        KEY_READ, <br>        &amp;softwareKey <br>        ); <br> <br>     <br>    if (rc == ERROR_SUCCESS) { <br>         <br>        // <br>        // Determine how large of a buffer to allocate. <br>        // <br>         <br>        rc = RegQueryValueEx( <br>            softwareKey, <br>            DIRECTORYVALUE, <br>            0, <br>            &amp;valueType, <br>            NULL, <br>            &amp;sizeNeeded <br>            ); <br> <br>        // <br>        // Allocate enough space for the registry path, with the additional <br>        // subpath to Visual C++ 5.0's win 95 specific binaries. <br>        // <br>        rString = LocalAlloc(0,sizeNeeded + lstrlen(DIR_95SPECIFIC) + 1); <br>         <br>    } <br>     <br>    if (rc == ERROR_SUCCESS &amp;&amp; rString != NULL) { <br>         <br>        // <br>        // Read in the buffer. <br>        // <br>         <br>        rc = RegQueryValueEx( <br>            softwareKey, <br>            DIRECTORYVALUE, <br>            0, <br>            &amp;valueType, <br>            (PBYTE) rString, <br>            &amp;sizeNeeded <br>            ); <br> <br>        if (rc == ERROR_SUCCESS) { <br>             <br>            if (valueType != REG_SZ) { <br>                rc = ERROR_INVALID_DATATYPE; <br>            } <br>        } <br>    } <br> <br> <br>    // <br>    // If we didn't complete successfully, set the last error, and free the <br>    // return string if it was allocated. <br>    // <br>    if (rc != ERROR_SUCCESS) { <br>        SetLastError(rc); <br> <br>        if (rString) { <br>            LocalFree(rString); <br>            rString = NULL; <br>        } <br>    } <br> <br>    return rString; <br>} <br> <br> <br>static <br>PSTR <br>GetPviewDirectory9x ( <br>    VOID <br>    ) <br>{ <br>    HKEY    softwareKey; <br>    LONG    rc; <br>    LONG    valueType; <br>    LONG    sizeNeeded; <br>    PSTR    rString = NULL; <br> <br>    // <br>    // First, open the key. <br>    // <br>    rc = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>        DIRECTORYKEY, <br>        0, <br>        KEY_READ, <br>        &amp;softwareKey <br>        ); <br> <br>     <br>    if (rc == ERROR_SUCCESS) { <br>         <br>        // <br>        // Determine how large of a buffer to allocate. <br>        // <br>         <br>        rc = RegQueryValueEx( <br>            softwareKey, <br>            DIRECTORYVALUE, <br>            0, <br>            &amp;valueType, <br>            NULL, <br>            &amp;sizeNeeded <br>            ); <br> <br>        // <br>        // Allocate enough space for the registry path, with the additional <br>        // subpath to Visual C++ 5.0's win 95 specific binaries. <br>        // <br>        rString = LocalAlloc(0,sizeNeeded + lstrlen(DIR_95SPECIFIC) + 1); <br>         <br>    } <br>     <br>    if (rc == ERROR_SUCCESS &amp;&amp; rString != NULL) { <br>         <br>        // <br>        // Read in the buffer. <br>        // <br>         <br>        rc = RegQueryValueEx( <br>            softwareKey, <br>            DIRECTORYVALUE, <br>            0, <br>            &amp;valueType, <br>            (PBYTE) rString, <br>            &amp;sizeNeeded <br>            ); <br> <br>        if (rc == ERROR_SUCCESS) { <br>             <br>            if (valueType == REG_SZ) { <br> <br>                // <br>                // We have successfully read in the value of the installation <br>                // directory into rString. Now, all we need to do is tack on <br>                // the win 95 specific portion that we care about. <br>                // <br>                lstrcat(rString,DIR_95SPECIFIC); <br> <br>            } <br>            else { <br>                rc = ERROR_INVALID_DATATYPE; <br>            } <br>        } <br>    } <br> <br> <br>    // <br>    // If we didn't complete successfully, set the last error, and free the <br>    // return string if it was allocated. <br>    // <br>    if (rc != ERROR_SUCCESS) { <br>        SetLastError(rc); <br> <br>        if (rString) { <br>            LocalFree(rString); <br>            rString = NULL; <br>        } <br>    } <br> <br>    return rString; <br>} <br> <br>static <br>LONG <br>CheckForInstalledComponents ( <br>    VOID <br>    ) <br>{ <br>    BOOL    rc; <br>    HKEY    softwareKey; <br> <br> <br>    // <br>    // Attempt to open the key. <br>    // <br>    rc = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>        DIRECTORYKEY, <br>        0, <br>        KEY_READ, <br>        &amp;softwareKey <br>        ); <br> <br>    // <br>    // If the key exists, then assume that Microsoft Visual C++ 5.0 is installed. <br>    // <br>    RegCloseKey(softwareKey); <br> <br>    return rc; <br>} <br> <br> <br> <br>BOOL <br>WINAPI <br>DllMain ( <br>    IN      HANDLE Instance, <br>    IN      ULONG  Reason, <br>    IN      LPVOID Reserved <br>    ) <br>{ <br> <br> <br>    switch (Reason)  { <br> <br>    case DLL_PROCESS_ATTACH: <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br>        // <br>        // Ensure that the MigInf structure is cleaned up before unloading this DLL. <br>        // <br>        MigInf_CleanUp(); <br>        break; <br>    } <br> <br>    return TRUE; <br>} <br> <br>LONG <br>CALLBACK  <br>QueryVersion ( <br>    OUT LPCSTR  *   ProductId, <br>    OUT LPUINT      DllVersion, <br>    OUT LPINT   *   CodePageArray,OPTIONAL <br>    OUT LPCSTR  *   ExeNamesBuf,OPTIONAL <br>        LPVOID      Reserved <br>    ) <br>{ <br> <br>    LONG rc; <br> <br>    INFO("Entering QueryVersion."); <br> <br>    assert(ProductId); <br>    assert(DllVersion); <br>    assert(CodePageArray); <br>    assert(ExeNamesBuf); <br> <br>    // <br>    // Setup is calling us to query our version information and to identify if  <br>    // we need processing. We always need to provide the product ID and the  <br>    // DLL version. <br>    // <br>    *ProductId = g_ProductId; <br>    *DllVersion = g_DllVersion; <br>     <br>    // <br>    // Check to see if there is anything to do. <br>    // <br>    if (CheckForInstalledComponents() == ERROR_SUCCESS) { <br>         <br>        // <br>        // There are installed components. Return the information Setup is <br>        // asking for. <br>        // <br>        *CodePageArray  = g_CodePageArray; // Use the CP_ACP code page for conversion to unicode, <br>        *ExeNamesBuf    = g_ExeNamesBuffer; <br>         <br>        // <br>        // Since there is work to do, return EXIT_SUCCESS. This informs Setup <br>        // that this dll does require processing during migration. <br>        // <br>        rc = ERROR_SUCCESS; <br>    } <br>    else { <br>        rc = ERROR_NOT_INSTALLED; <br>    } <br> <br>    return rc; <br> <br>} <br> <br> <br> <br>LONG <br>CALLBACK <br>Initialize9x ( <br>    IN      LPCSTR   WorkingDirectory, <br>    IN      LPCSTR   SourceDirectories, <br>            LPVOID   Reserved <br>            ) <br>{ <br>    LONG rc; <br> <br>    // <br>    // Setup guarantees that the source directories parameter is valid. <br>    // <br>    assert(SourceDirectories); <br> <br>    INFO("Entering Initialize9x."); <br> <br>    // <br>    // Initialize the MigInf structure. <br>    // <br>    if (!MigInf_Initialize()) { <br>        rc = GetLastError(); <br>    } <br>    else { <br>        rc = ERROR_SUCCESS; <br>    } <br>     <br> <br>    return rc; <br>} <br> <br> <br>LONG <br>CALLBACK <br>MigrateUser9x ( <br>    IN      HWND        ParentWnd, <br>    IN      LPCSTR      UnattendFile, <br>    IN      HKEY        UserRegKey, <br>    IN      LPCSTR      UserName, <br>            LPVOID      Reserved <br>    ) <br>{ <br>    // <br>    // Setup guarantees that UnattendFile,UserRegKey will be non-NULL <br>    // <br>    assert(UnattendFile); <br>    assert(UserRegKey); <br>    INFO("Entering MigrateUser9x."); <br>     <br> <br>    // <br>    // Nothing to do per user, so, return ERROR_NO_MORE_FILES <br>    // <br>    return ERROR_NOT_INSTALLED; <br>} <br> <br> <br>LONG <br>CALLBACK <br>MigrateSystem9x ( <br>    IN      HWND        ParentWnd, <br>    IN      LPCSTR      UnattendFile, <br>            LPVOID      Reserved <br>    ) <br>{ <br>    LONG                rc                  = EXIT_SUCCESS; <br>    PSTR                visualCppDirectory  = NULL; <br>    MIGINFSECTIONENUM   sectionEnum; <br>    BOOL                firstMessage        = TRUE; <br>    PCSTR               messageSection      = NULL; <br> <br>    // <br>    // Setup guarantees that UnattendFile will be non-NULL. <br>    // <br>    assert(UnattendFile); <br> <br>    INFO("Entering MigrateSystem9x"); <br> <br>    // <br>    // Since we are in this function, Initialize9x MUST have returned ERROR_SUCCESS. <br>    // Microsoft Visual C++ is installed on this machine.  <br>    // <br> <br>    // <br>    // Initialize the miginf module to handle interfacing with Migrate.Inf and retrieve <br>    // the installation directory for Visual C++. <br>    // <br>    visualCppDirectory = GetPviewDirectory9x(); <br>    if (!visualCppDirectory) { <br>        rc = GetLastError(); <br>    } <br>    else { <br> <br>        // <br>        // The migration INF was successfully initialized. See if there is anything for  <br>        // us to do. There is work to be done if (1) the [Migration Paths] section of  <br>        // Migrate.inf contains some paths (Indicating that setup found some of the files <br>        // we asked it to look for in ExeNamesBuf) and (2) The Visual CPP Install directory <br>        // is not in the Excluded Paths Section. <br>        // <br> <br>         <br> <br>        if (MigInf_FirstInSection(SECTION_MIGRATIONPATHS,&amp;sectionEnum)  <br>            &amp;&amp; !MigInf_PathIsExcluded(visualCppDirectory)) { <br> <br>            // <br>            // All checks are good. We have work to do. <br>            // we need to sift through the files that <br>            // Setup returned in the Migration paths section. If the files <br>            // returned are in the installation directory, we will write them <br>            // to both the [Handled Files] sections and the [Moved Files]  <br>            // sections. If not, we will write the file to the [Handled Files] <br>            // section and then write a message to the [Incompatible Messages] <br>            // section. This will allow us to override the message that  <br>            // Setup is providing for these files with a more meaningful one. <br>            // <br>            do { <br> <br>                if (PathIsInPath(sectionEnum.Key,visualCppDirectory)) { <br> <br>                    // <br>                    // This file is in our installation path. We'll be handling it. <br>                    // <br>                    if (!MigInf_AddObject( <br>                            MIG_FILE, <br>                            SECTION_HANDLED, <br>                            sectionEnum.Key, <br>                            NULL <br>                            )) { <br> <br>                        rc = ERROR_CANTWRITE; <br>                        break; <br>                    } <br> <br>                    // <br>                    // We also need to note the amount of space that we will use. <br>                    // <br>                    if (!MigInf_UseSpace(sectionEnum.Key,SIZENEEDED)) { <br>                        rc = ERROR_CANTWRITE; <br>                        break; <br>                    } <br> <br>                } <br>                else { <br> <br>                    // <br>                    // This file is not in our installation path. <br>                    // <br>                    if (firstMessage) { <br> <br>                        // <br>                        // We'll only add one message to the incompatible messages  <br>                        // section, no matter how many PVIEW's we find outside of  <br>                        // the installation directory.  However, we'll add all of  <br>                        // those files to the section that controls that message. <br>                        // That way, the message will always appear unless _every_  <br>                        // file in that section has been handled by something  <br>                        // (i.e. another migration DLL.) <br>                        // <br> <br>                        firstMessage    = FALSE; <br> <br>                        if (!MigInf_AddObject( <br>                                MIG_MESSAGE, <br>                                SECTION_INCOMPATIBLE, <br>                                MESSAGE_SECTION, <br>                                MESSAGE <br>                                )) { <br> <br>                            rc = ERROR_CANTWRITE; <br>                            break; <br>                        } <br>                    } <br>                     <br> <br>                    if (!MigInf_AddObject( <br>                            MIG_FILE, <br>                            MESSAGE_SECTION, <br>                            sectionEnum.Key, <br>                            NULL <br>                            )) { <br>                        rc = ERROR_CANTWRITE; <br>                        break; <br>                    } <br>                } <br>                 <br>            } while (MigInf_NextInSection(&amp;sectionEnum)); <br>        }  <br>        else { <br> <br>            // <br>            // There is nothing for us to do. <br>            // <br>            rc = ERROR_NOT_INSTALLED; <br>        } <br> <br>        MigInf_WriteInfToDisk(); <br>    } <br> <br> <br>    // <br>    // Free the memory allocated in GetVisualCppDirectory. <br>    // <br>     <br>    if (visualCppDirectory) { <br>        LocalFree(visualCppDirectory); <br>    } <br>     <br>    return rc; <br>} <br> <br>LONG <br>CALLBACK <br>InitializeNT ( <br>    IN      LPCWSTR     WorkingDirectory, <br>    IN      LPCWSTR     SourceDirectory, <br>            LPVOID      Reserved <br>    ) <br>{ <br> <br>    // <br>    // Setup ensures that WorkingDirectory and SourceDirectory will be non-NULL. <br>    // <br>    assert(WorkingDirectory != NULL &amp;&amp; SourceDirectory != NULL); <br> <br> <br>    // <br>    // We do not need to do anything in this call. Simply return ERROR_SUCCES <br>    // <br>    return ERROR_SUCCESS; <br>} <br> <br> <br>LONG <br>CALLBACK <br>MigrateUserNT ( <br>    IN HINF         UnattendInfHandle, <br>    IN HKEY         UserRegHandle, <br>    IN LPCWSTR      UserName, <br>       LPVOID       Reserved <br>    ) <br>{ <br> <br>    // <br>    // Setup guarantees that UnattendInfHandle and UserRegHandle are non-NULL and valid. <br>    // UserName can be NULL, however, for the default user. <br>    // <br>    assert(UnattendInfHandle); <br> <br> <br>    // <br>    // Nothing to do per user. Simply return ERROR_SUCCESS. <br>    // (Note the difference in return codes between MigrateUser9x and MigrateUserNT.) <br>    // <br>    return ERROR_SUCCESS; <br>} <br> <br> <br>LONG <br>CALLBACK <br>MigrateSystemNT ( <br>    IN HINF         UnattendInfHandle, <br>       LPVOID       Reserved <br>    ) <br>{ <br>    LONG    rc; <br>    PSTR    pviewDir; <br>    CHAR    fromPath[MAX_PATH]; <br>    CHAR    toPath[MAX_PATH]; <br> <br>    // <br>    // Setup guarantees that UnattendInfHandle is non-NULL and is valid. <br>    // <br>    assert(UnattendInfHandle &amp;&amp; UnattendInfHandle != INVALID_HANDLE_VALUE); <br> <br>    // <br>    // If we have gotten to this point, we know that we are installed. All we need to do is copy  <br>    // the NT version of PVIEW into the installation directory of Visual C++ 5.0 Note that we do <br>    // not replace the 9x version as a normal Visual C++ install on NT would have the 9x of PVIEW <br>    // as well. <br>    // <br>    pviewDir = GetPviewDirectoryNt(); <br> <br>    if (pviewDir) { <br> <br>        sprintf(fromPath,".\\%s",FILE_PVIEW); <br>        sprintf(toPath,"%s\\%s",pviewDir,FILE_PVIEW); <br> <br>        if (!CopyFileA(fromPath,toPath,FALSE)) { <br>            rc = GetLastError(); <br>        } <br>        else { <br>            rc = ERROR_SUCCESS; <br>        } <br> <br>    } <br>    else { <br>        rc = GetLastError(); <br>    } <br>         <br>    return rc = ERROR_SUCCESS; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
