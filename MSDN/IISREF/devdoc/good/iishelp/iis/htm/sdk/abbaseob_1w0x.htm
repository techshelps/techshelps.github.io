<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enumerating Keys and Data</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_k2_enumerating_keys_and_data"></a>Enumerating Keys and Data</h3>
<p>
You can use the <b>EnumKeys</b> method to enumerate the subkeys of a key. The name of one subkey is returned per each enumeration call. ERROR_NO_MORE_ITEMS is returned after the last subkey has been enumerated. To get a total count of the subkeys associated with a key, you can increment the index parameter of the method. See <i>Enumerating Subkeys</i> for details and example code that enumerates keys. </p>
<p>
Similarly, you can use the <b>EnumData</b> method to enumerate the data elements of a key. One data item is enumerated per call, but unlike enumerating keys, the <b>EnumData</b> method returns the data as well as the data identifier. ERROR_NO_MORE_ITEMS is returned after the last data item has been enumerated. To get a total count of the data items associated with a key, you must increment the index parameter of the method. See <i>Enumerating Data Items</i> for details and example code that enumerates data items. </p>
<h4>Enumerating Subkeys</h4>
<p>
The following example uses the <b>EnumKeys</b> method to enumerate the number of virtual Web servers defined on the local machine. This example also uses the Active Template Library to demonstrate smart pointers. Smart pointers perform the normal COM <b>QueryInterface</b>, <b>AddRef</b> and <b>Release</b> calls automatically.</p>
<pre><code>#define UNICODE 
#define INITGUID 
#include "iadmw.h"    // COM Interface header 
#include "iiscnfg.h"  // MD_ &amp; IIS_MD_ #defines 
#include "atlBase.h"  // ATL support 
HRESULT hRes = 0; 
DWORD indx = 0; 
METADATA_HANDLE MyHandle; 
WCHAR SubKeyName[METADATA_MAX_NAME_LEN]; 
CComPtr &lt;IMSAdminBase&gt; pIMeta; 
 
hRes = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
IID_IMSAdminBase, (void **) &amp;pIMeta); 
 
if (FAILED(hRes)) 
    return; 
 
//get a handle to the local machine 
hRes = pIMeta-&gt;OpenKey(METADATA_MASTER_ROOT_HANDLE, TEXT("/LM"), METADATA_PERMISSION_READ, 20, &amp;MyHandle); 
 
//loop until there are no more subkeys 
while (SUCCEEDED(hRes)){ 
 
    //enumerate the subkeys of the World Wide Web service 
    hRes = pIMeta-&gt;EnumKeys(MyHandle, TEXT("/W3SVC"), SubKeyName, indx); 
 
    if (SUCCEEDED(hRes)) { 
    //store the virtual server names in an array for future use 
    //Note: declare a suitable array of names and add 
    // array bound checking 
    wcscpy (names[indx],SubKeyName); 
    } 
 
    //increment the index 
    indx++; 
} 
 
//release the handle 
pIMeta-&gt;CloseKey(MyHandle); 
 </code></pre>
<h4>Enumerating Data Items</h4>
<p>
The <b>EnumData</b> method returns the entire data entry, so you must pass in a <b>METADATA_RECORD</b> structure to receive the data. The values that are set for the <b>METADATA_RECORD</b> members when that structure is passed into the <b>EnumData</b> method specify which data items are to be enumerated.</p>
<p>
The following example enumerates all of the server-related data entries of the first virtual Web server, including any inherited data. This is an example only, and does not include all appropriate error handling.</p>
<pre><code>#define UNICODE 
#define INITGUID 
#include "iadmw.h"    // COM Interface header 
#include "iiscnfg.h"  // MD_ &amp; IIS_MD_ #defines 
#include "atlBase.h"  // ATL support 
HRESULT hRes = 0; 
DWORD indx = 0; 
METADATA_HANDLE MyHandle; 
METADATA_RECORD MyRecord; 
DWORD dwBufLen = ORIGINAL_BUFFER_SIZE; 
DWORD dwReqBufLen = 0; 
PBYTE pbBuffer = new BYTE[dwBufLen]; 
CComPtr &lt;IMSAdminBase&gt; pIMeta; 
 
hRes = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
IID_IMSAdminBase, (void **) &amp;pIMeta); 
 
if (FAILED(hRes)) 
    return; 
 
//get a handle to the Web service 
hRes = pIMeta-&gt;OpenKey(METADATA_MASTER_ROOT_HANDLE, TEXT("/LM/W3SVC"), METADATA_PERMISSION_READ, 20, &amp;MyHandle); 
if (SUCCEEDED(hRes)) { 
//loop until there are no more data items  
while (SUCCEEDED(hRes)){ 
  
    //initialize the input structure, 
    //the values specify what kind of data to enumerate 
    MyRecord.dwMDAttributes = METADATA_INHERIT; 
    MyRecord.dwMDUserType = IIS_MD_UT_SERVER; 
    MyRecord.dwMDDataType = ALL_METADATA; 
    MyRecord.dwMDDataLen = dwBufLen; 
    MyRecord.pbMDData = pbBuffer; 
 
    //enumerate the data of the first virtual Web server 
    //checking to ensure that the data returned does not 
    //overflow the buffer 
  
    hRes = pIMeta-&gt;EnumData(MyHandle, TEXT("/1"), &amp;MyRecord, indx, &amp;dwReqBufLen); 
    if (hres == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) { 
        delete [] (pbBuffer); 
        pbBuffer = new BYTE[dwReqBufLen]; 
        dwBufLen = dwReqBufLen; 
        MyRecord-&gt;dwMDDataLen = dwReqBufLen; 
        MyRecord-&gt;pbMDData = pbBuffer; 
        hRes = pIMeta-&gt;EnumData(MyHandle, TEXT("/1"), &amp;MyRecord, indx, &amp;dwReqBufLen); 
 
    } 
    if (SUCCEEDED(hRes)) { 
        //store the data identifiers in an array for future use 
        //Note: declare a suitable DWORD array for names and add 
        // array bound checking 
        data[indx] = MyRecord-&gt;dwMDIdentifier; 
        // Additional code needed to store other data fields. 
    } 
 
    //increment the index 
    indx++; 
} // end while 
 
//release the handle and buffer 
pIMeta-&gt;CloseKey(MyHandle); 
} // end if pIMeta-&gt;OpenKey Succeeded 
delete pbBuffer; 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
