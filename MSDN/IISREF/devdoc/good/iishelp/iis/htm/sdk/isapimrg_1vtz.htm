<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Extension Request Processing</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_in_extension_request_processing"></a>Extension Request Processing</h2>
<p>
When IIS receives a request for your ISAPI extension, it loads the DLL and calls the <a href="appref_7cmm.htm"><b>GetExtensionVersion</b></a> entry point function. <b>GetExtensionVersion</b> returns a pointer to an <a href="appref_26pb.htm"><b>HSE_VERSION_INFO</b></a> structure. IIS then calls the <a href="appref_2n8j.htm"><b>HttpExtensionProc</b></a> function with a pointer to an <a href="appref_3z1n.htm"><b>Extension_Control_Block</b></a> (ECB) structure. Your extension processes the data contained in the ECB and uses the callback functions in ECB to write back responses to the client. When the extension is no longer needed, IIS calls the <a href="appref_64oe.htm"><b>TerminateExtension</b></a> function to unload the extension from memory. </p>
<p>
After IIS finishes processing a request for an ISAPI, it can either close the connection or keep it open. A request can specify that the connection should remain open by specifying the Connection: Keep-Alive header. (With all HTTP 1.1 requests the Connection Keep-Alive header is included by default.) If you have designed your ISAPI extension to support Keep-Alive requests, you should indicate this to the client by calling the ServerSupporFunction and specifying the HSE_REQ_SEND_RESPONSE_HEADER value for the dwHSERequest parameter. The response header you specify should contain Connection: Keep-Alive. The following code demonstrates sending the Keep-Alive header:</p>
<pre><code>DWORD 
SendHeaderToClient(
    LPEXTENSION_BLOCK pECB
    )
{
    BOOL fReturn;
    CHAR szHeader[256] = "";
    DWORD hseStatus = HSE_STATUS_SUCCESS;
 
    strcpy(szHeader, "Content-type: test/html\r\n\r\n");
    fReturn = 
    pECB-&gt;ServerSupportFunction(pECB-&gt;ConnID, 
                                HSE_REQ_SEND_RESPONSE_HEADER,
                                "Connection:Keep-Alive" // Telling the client not to close the connection
                                NULL,
                                (LPDWORD) szHeader);
 
    if (! fReturn ) {
        hseStatus = HSE_STATUS_ERROR;
    }
    return (hseStatus);
}
 </code></pre>
<p>
If the request has indicated that the connection should remain open, subsequent requests can be sequential or pipelined. When a client pipelines requests, it does not need to wait for earlier requests to be serviced before sending subsequent requests. IIS guarantees that pipelined requests will be returned to the client in the order they were received. IIS manages the ordering of request internally, so your extension does not need to add any special processing for pipelined requests.</p>
<p>
For more details on pipelined requests, see RFC 2068 published by the World Wide Web consortium. RFC 2068 is available at http://www.isi.edu.</p>
<p>&nbsp;</p></body>
</HTML>
