<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calls to the Event Notification and Authorization API</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h3><a name="callstoeventnotificationauthorizationapi"></a>Calls to the Event Notification and Authorization API</h3>
<p>
The NetShow Event Notification and Authorization components use <i>contexts</i> to hold and pass around information about the server, user, or content. A context is an object wrapper of a data set and implements certain interface for manipulating the encapsulated data. For example, a server context encapsulates server information and exposes methods to access or to manipulate the server without having to know its underlying data structures. To have a plug-in component work with the server, user, or content amounts to specifying the appropriate <i>server, user, </i>or<i> presentation context</i> in the component and calling the methods of the interface. The context interfaces in NetShow inherit from the <b>IPropertyMap</b> interface. For more information about contexts supported by NetShow, see the discussion of “<a href="eventnotificationauthorizationcontexts.htm">Event Notification Authorizatioin Contexts</a>” in this document. </p>
<p>
When the NetShow server is started, it retrieves from the system registry the class identifier (CLSID), and creates instances of all the notification and authorization plug-in components. Then the server and the components proceed to interact with each other in the following order.</p>

<h4><a name="author_initialization"></a>Initialization</h4>
<p>
The NetShow server calls the <a href="insseventhandlerinitialize.htm"><b>INSSEventHandler::Initialize</b></a> method on each component to initialize the instantiated objects. The server passes in a pointer to the server context so that a component can use it to retrieve information about the server. The retrievable information includes:
<ul type=disc>
<li>
The name of the server.</li>
<li>
The server’s virtual name.</li>
<li>
The version and build numbers of the server.</li>
</ul>
<p>
The server context is available as long as the server is running. Later, the server can pass additional contexts into a component, such as a user context or a presentation context. </p>

<h4><a name="settingheartbeat"></a>Setting a Heartbeat</h4>
<p>
NetShow defines a heartbeat as a server timer event. A heartbeat can be used for timing other events and for monitoring the operational state of the server. You can have the server enable the heartbeat by specifying a positive value for the <i>dwMsHeartbeatPeriod</i> parameter in the <b>Initialize</b> method of the <b>INNSSEventHandler</b> interface. If a heartbeat is enabled, the server calls the <a href="insseventhandleronheartbeat.htm"><b>INSSEventHandler::OnHeartbeat</b></a><b> </b>method at the regular intervals of the specified heartbeat period. Setting the <i>dwMsHeartbeatPeriod</i> parameter to zero disables the heartbeat. </p>
<p>
For billing purposes, notification and authorization components can start their own timer events. For example, a component that authorizes the pay-per-minute <b>Play</b> event can start a timer once the user begins playing a title and can stop the timer when the user finishes viewing the title. The period of time from the start of play to the finish may be billable to the client if the server is up and running for the entire period. If, on the other hand, the server is down for sometime, the time interval clocked with the component’s timer may not be appropriate for the billing purpose. In this case, heartbeat is a preferred measure of time, because the <b>OnHeartbeat</b> method is only called while the server is up and running.</p>

<h4><a name="specifyingnotificationevents"></a>Specifying Notification Events</h4>
<p>
After initialization the server calls the <a href="insseventhandlergethandledevents.htm"><b>INSSEventHandler::GetHandledEvents</b></a> method of each component. This method is used to select events that will trigger a call to the event handler by the server. The following types of events are supported for notification.
<ul type=disc>
<li>
Clients connecting and disconnecting to and from the server.</li>
<li>
Opening and closing titles.</li>
<li>
Starting and stopping titles.</li>
<li>
Skiping or enabling client authentication.</li>
</ul>

<h4><a name="testforauthorizationsupport"></a>Test for Authorization Support</h4>
<p>
After notification events are set, the server calls the <b>QueryInterface</b> method of the <a href="insseventauthorization.htm"><b>INSSEventAuthorization</b></a> interface to determine whether or not the authorization interface is supported. All components must implement the <a href="insseventhandler.htm"><b>INSSEventHandler</b></a><b> </b>interface. However, the <a href="insseventauthorization.htm"><b>INSSEventAuthorization</b></a> interface is optional. When authorization is supported, the server invokes the <a href="insseventauthorizationgetauthorizedevents.htm"><b>INSSEventAuthorization::GetAuthorizedEvents</b></a><b> </b>method to retrieve the array of authorized events and thus determines which events will require authorization.</p>

<h4><a name="specifyingauthorizationevents"></a>Specifying Authorization Events</h4>
<p>
A component specifies which event must undergo the authorization process. You implement the scheme with the <a href="insseventauthorizationgetauthorizedevents.htm"><b>INSSEventAuthorization::GetAuthorizedEvents</b></a><b> </b>method. This method is similar to that specifying the events for notification. However, fewer events are supported for authorization. For instance, requiring authorization from the server before the client disconnects is not useful because the server cannot prevent a client from disconnecting.</p>
<p>
You can specify the following events for authorization:
<ul type=disc>
<li>
Clients connecting to the server.</li>
<li>
Opening a title.</li>
<li>
Playing a title.</li>
<li>
Skipping client authentication.</li>
</ul>

<h4><a name="authorization"></a>Authorization</h4>
<p>
The NetShow server calls the <a href="insseventauthorizationauthorizeevent.htm"><b>INSSEventAuthorization::AuthorizeEvent</b></a><b> </b>method to determine whether it will perform the task assoicated with an event that requires authorization. When calling the method, the server supplies the component with information about the event, client, and content to be authorized.</p>
<p>
If the authorization is a complicated and lengthy process, you should implement the <b>AuthorizeEvent</b> method in an asynchronous fashion, spawning another thread to determine if the request should be granted. Asynchronous implementation results in an immediate return of calls to the method and frees the server to proceed with other tasks while the authorization is in process. However, if the authorization is simple, as is in most cases, the method should return synchronously; that is, return a call after the authorization is done. </p>
<p>
At the end of the authorization process, whether the request is granted or denied, the authorization component makes a call to the server to invoke the <a href="insseventauthorizationcallbackoneventauthorized.htm"><b>INSSEventAuthorizationCallback::OnEventAuthorized</b></a>method. A pointer to the callback interface is passed in by the server when it invokes the <b>AuthorizeEvent</b> method. The authorization component must call this method, whether the <b>AuthorizeEvent</b> method returns synchronously or asynchronously. </p>
<p>
To uniquely identify the event requested for authorization, both the server and the authorization component pass the <i>dwRequestId</i> parameter to each other. The server passes the parameter into the component through the call to the <a href="insseventauthorizationauthorizeevent.htm"><b>INSSEventAuthorization::AuthorizeEvent</b></a> method. The authorization component must pass the same request identifier back to the server through the call to the <a href="insseventauthorizationcallbackoneventauthorized.htm"><b>INSSEventAuthorizationCallback::OnEventAuthorized</b></a><b> </b>method.</p>

<h4><a name="eventnotification"></a>Event Notification</h4>
<p>
Suppose that a user choses to play a title. If authorization is required to play the title, the server asks the event notification and authorization component to check on the user. When the user is authorized to play the title, the server then opens the title for user to play. If the authorization fails, the server will not open the requested title. In either case, the server calls the <a href="insseventhandlerhandleevent.htm"><b>INSSEventHandler::HandleEvent</b></a><b> </b>method to notify the component whether or not the event occurs (in this case, whether the title is being played or not). If authorization is not required, the server will open the title for the user and then notify the component that the title is being played.</p>
<p>
The server also notifies the component of any other events that are registered for notification and/or authorization by using the <b>INSSEventHandler::GetHandleEvents</b> method. The notification specifies the type of event requested and the results of the authorization, when applicable. You can choose to implement different responses to the notification in the <b>INSSEventHandler::HandleEvents</b> method. For example, you can present the viewing statistics of the client when the user connects to the server. Or you can announce the charge inccurred by the viewer when the title is stopped.</p>

<h4><a name="eventnotificationauthorizationframework"></a>Event Notification and Authorization Framework</h4>
<p>
The following diagram illustrates a simple model of the sequence of calls between the NetShow server and the event notification and authorization interfaces. This chart assumes that there is only one authorization interface, and does not address client authentication.</p>
<p>
<img src="ns_author2.gif" border=0></p>
<A HREF="legal.htm">&copy; 1996-1998 Microsoft Corporation. All rights reserved.</A></BODY>
</HTML>
