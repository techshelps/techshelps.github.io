<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLESTD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6343"></a>OLESTD.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Standard Utilities <br>** <br>**    olestd.c <br>** <br>**    This file contains utilities that are useful for most standard <br>**        OLE 2.0 compound document type applications. <br>** <br>**    (c) Copyright Microsoft Corp. 1992-1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H) <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#include &lt;stdlib.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include "common.h" <br> <br>OLEDBGDATA <br> <br>static char szAssertMemAlloc[] = "CoGetMalloc failed"; <br>static int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight); <br> <br>//The instance handle shared amongst all dialogs. <br>HINSTANCE     ghInst; <br> <br> <br>/* OleStdSwitchDisplayAspect <br>** ------------------------- <br>**    Switch the currently cached display aspect between DVASPECT_ICON <br>**    and DVASPECT_CONTENT. <br>** <br>**    NOTE: when setting up icon aspect, any currently cached content <br>**    cache is discarded and any advise connections for content aspect <br>**    are broken. <br>** <br>**    RETURNS: <br>**      S_OK -- new display aspect setup successfully <br>**      E_INVALIDARG -- IOleCache interface is NOT supported (this is <br>**                  required). <br>**      &lt;other SCODE&gt; -- any SCODE that can be returned by <br>**                  IOleCache::Cache method. <br>**      NOTE: if an error occurs then the current display aspect and <br>**            cache contents unchanged. <br>*/ <br>STDAPI OleStdSwitchDisplayAspect( <br>      LPOLEOBJECT             lpOleObj, <br>      LPDWORD                 lpdwCurAspect, <br>      DWORD                   dwNewAspect, <br>      HGLOBAL                 hMetaPict, <br>      BOOL                    fDeleteOldAspect, <br>      BOOL                    fSetupViewAdvise, <br>      LPADVISESINK            lpAdviseSink, <br>      BOOL FAR*               lpfMustUpdate <br>) <br>{ <br>   LPOLECACHE      lpOleCache = NULL; <br>   LPVIEWOBJECT    lpViewObj = NULL; <br>   LPENUMSTATDATA  lpEnumStatData = NULL; <br>   STATDATA        StatData; <br>   FORMATETC       FmtEtc; <br>   STGMEDIUM       Medium; <br>   DWORD           dwAdvf; <br>   DWORD           dwNewConnection; <br>   DWORD           dwOldAspect = *lpdwCurAspect; <br>   HRESULT         hrErr; <br> <br>   if (lpfMustUpdate) <br>      *lpfMustUpdate = FALSE; <br> <br>   lpOleCache = (LPOLECACHE)OleStdQueryInterface( <br>                              (LPUNKNOWN)lpOleObj,&amp;IID_IOleCache); <br> <br>   // if IOleCache* is NOT available, do nothing <br>   if (! lpOleCache) <br>      return E_INVALIDARG; <br> <br>   // Setup new cache with the new aspect <br>   FmtEtc.cfFormat = 0;     // whatever is needed to draw <br>   FmtEtc.ptd      = NULL; <br>   FmtEtc.dwAspect = dwNewAspect; <br>   FmtEtc.lindex   = -1; <br>   FmtEtc.tymed    = TYMED_NULL; <br> <br>   /* NOTE: if we are setting up Icon aspect with a custom icon <br>   **    then we do not want DataAdvise notifications to ever change <br>   **    the contents of the data cache. thus we set up a NODATA <br>   **    advise connection. otherwise we set up a standard DataAdvise <br>   **    connection. <br>   */ <br>   if (dwNewAspect == DVASPECT_ICON &amp;&amp; hMetaPict) <br>      dwAdvf = ADVF_NODATA; <br>   else <br>      dwAdvf = ADVF_PRIMEFIRST; <br> <br>   OLEDBG_BEGIN2("IOleCache::Cache called\r\n") <br>   hrErr = lpOleCache-&gt;lpVtbl-&gt;Cache( <br>         lpOleCache, <br>         (LPFORMATETC)&amp;FmtEtc, <br>         dwAdvf, <br>         (LPDWORD)&amp;dwNewConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   if (! SUCCEEDED(hrErr)) { <br>      OleDbgOutHResult("IOleCache::Cache returned", hrErr); <br>      OleStdRelease((LPUNKNOWN)lpOleCache); <br>      return hrErr; <br>   } <br> <br>   *lpdwCurAspect = dwNewAspect; <br> <br>   /* NOTE: if we are setting up Icon aspect with a custom icon, <br>   **    then stuff the icon into the cache. otherwise the cache must <br>   **    be forced to be updated. set the *lpfMustUpdate flag to tell <br>   **    caller to force the object to Run so that the cache will be <br>   **    updated. <br>   */ <br>   if (dwNewAspect == DVASPECT_ICON &amp;&amp; hMetaPict) { <br> <br>      FmtEtc.cfFormat = CF_METAFILEPICT; <br>      FmtEtc.ptd      = NULL; <br>      FmtEtc.dwAspect = DVASPECT_ICON; <br>      FmtEtc.lindex   = -1; <br>      FmtEtc.tymed    = TYMED_MFPICT; <br> <br>      Medium.tymed            = TYMED_MFPICT; <br>      Medium.u.hGlobal        = hMetaPict; <br>      Medium.pUnkForRelease   = NULL; <br> <br>      OLEDBG_BEGIN2("IOleCache::SetData called\r\n") <br>      hrErr = lpOleCache-&gt;lpVtbl-&gt;SetData( <br>            lpOleCache, <br>            (LPFORMATETC)&amp;FmtEtc, <br>            (LPSTGMEDIUM)&amp;Medium, <br>            FALSE   /* fRelease */ <br>      ); <br>      OLEDBG_END2 <br>   } else { <br>      if (lpfMustUpdate) <br>         *lpfMustUpdate = TRUE; <br>   } <br> <br>   if (fSetupViewAdvise &amp;&amp; lpAdviseSink) { <br>      /* NOTE: re-establish the ViewAdvise connection */ <br>      lpViewObj = (LPVIEWOBJECT)OleStdQueryInterface( <br>                              (LPUNKNOWN)lpOleObj,&amp;IID_IViewObject); <br> <br>      if (lpViewObj) { <br> <br>         OLEDBG_BEGIN2("IViewObject::SetAdvise called\r\n") <br>         lpViewObj-&gt;lpVtbl-&gt;SetAdvise( <br>               lpViewObj, <br>               dwNewAspect, <br>               0, <br>               lpAdviseSink <br>         ); <br>         OLEDBG_END2 <br> <br>         OleStdRelease((LPUNKNOWN)lpViewObj); <br>      } <br>   } <br> <br>   /* NOTE: remove any existing caches that are set up for the old <br>   **    display aspect. It WOULD be possible to retain the caches set <br>   **    up for the old aspect, but this would increase the storage <br>   **    space required for the object and possibly require additional <br>   **    overhead to maintain the unused cachaes. For these reasons the <br>   **    strategy to delete the previous caches is prefered. if it is a <br>   **    requirement to quickly switch between Icon and Content <br>   **    display, then it would be better to keep both aspect caches. <br>   */ <br> <br>   if (fDeleteOldAspect) { <br>      OLEDBG_BEGIN2("IOleCache::EnumCache called\r\n") <br>      hrErr = lpOleCache-&gt;lpVtbl-&gt;EnumCache( <br>            lpOleCache, <br>            (LPENUMSTATDATA FAR*)&amp;lpEnumStatData <br>      ); <br>      OLEDBG_END2 <br> <br>      while(hrErr == NOERROR) { <br>         hrErr = lpEnumStatData-&gt;lpVtbl-&gt;Next( <br>               lpEnumStatData, <br>               1, <br>               (LPSTATDATA)&amp;StatData, <br>               NULL <br>         ); <br>         if (hrErr != NOERROR) <br>            break;              // DONE! no more caches. <br> <br>         if (StatData.formatetc.dwAspect == dwOldAspect) { <br> <br>            // Remove previous cache with old aspect <br>            OLEDBG_BEGIN2("IOleCache::Uncache called\r\n") <br>            lpOleCache-&gt;lpVtbl-&gt;Uncache(lpOleCache,StatData.dwConnection); <br>            OLEDBG_END2 <br>         } <br>      } <br> <br>      if (lpEnumStatData) { <br>         OleStdVerifyRelease( <br>               (LPUNKNOWN)lpEnumStatData, <br>               OLESTR ("OleStdSwitchDisplayAspect: Cache enumerator NOT released")); <br>      } <br>   } <br> <br>   if (lpOleCache) <br>      OleStdRelease((LPUNKNOWN)lpOleCache); <br> <br>   return NOERROR; <br>} <br> <br> <br>/* OleStdQueryInterface <br>** -------------------- <br>**    Returns the desired interface pointer if exposed by the given object. <br>**    Returns NULL if the interface is not available. <br>**    eg.: <br>**      lpDataObj = OleStdQueryInterface(lpOleObj, &amp;IID_DataObject); <br>*/ <br>STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid) <br>{ <br>   LPUNKNOWN lpInterface; <br>   HRESULT hrErr; <br> <br>   hrErr = lpUnk-&gt;lpVtbl-&gt;QueryInterface( <br>         lpUnk, <br>         riid, <br>         (LPVOID FAR*)&amp;lpInterface <br>   ); <br> <br>   if (hrErr == NOERROR) <br>      return lpInterface; <br>   else <br>      return NULL; <br>} <br> <br> <br>/* OleStdFreeString <br>** ---------------- <br>**    Free a string that was allocated with the currently active <br>**    IMalloc* allocator. <br>** <br>**    if the caller has the current IMalloc* handy, then it can be <br>**    passed as a argument, otherwise this function will retrieve the <br>**    active allocator and use it. <br>*/ <br>STDAPI_(void) OleStdFreeString(LPOLESTR lpsz, LPMALLOC lpMalloc) <br>{ <br>   BOOL fMustRelease = FALSE; <br> <br>   if (! lpMalloc) { <br>      if (CoGetMalloc(MEMCTX_TASK, &amp;lpMalloc) != NOERROR) <br>         return; <br>      fMustRelease = TRUE; <br>   } <br> <br>   lpMalloc-&gt;lpVtbl-&gt;Free(lpMalloc, lpsz); <br> <br>   if (fMustRelease) <br>      lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br>} <br> <br> <br>/* Call Release on the object that is expected to go away. <br>**      if the refcnt of the object did no go to 0 then give a debug message. <br>*/ <br>STDAPI_(ULONG) OleStdVerifyRelease(LPUNKNOWN lpUnk, LPOLESTR lpszMsg) <br>{ <br>   ULONG cRef; <br>   char  lpszAnsiMsg[256]; <br> <br>   W2A (lpszMsg, lpszAnsiMsg, 256); <br>   cRef = lpUnk-&gt;lpVtbl-&gt;Release(lpUnk); <br> <br>#if defined( _DEBUG ) <br>   if (cRef != 0) { <br>      char szBuf[80]; <br>      if (lpszMsg) <br>         MessageBox(NULL, lpszAnsiMsg, NULL, MB_ICONEXCLAMATION | MB_OK); <br>      wsprintf( <br>            /*(LPSTR)*/szBuf, <br>            "refcnt (%ld) != 0 after object (0x%lx) release\n", <br>            cRef, <br>            lpUnk <br>      ); <br>      if (lpszMsg) <br>         OleDbgOut1(lpszAnsiMsg); <br>      OleDbgOut1(/*(LPSTR)*/szBuf); <br>      OleDbgAssertSz(cRef == 0, /*(LPSTR)*/szBuf); <br>   } else { <br>      char szBuf[80]; <br>      wsprintf( <br>            /*(LPSTR)*/szBuf, <br>            "refcnt = 0 after object (0x%lx) release\n", lpUnk <br>      ); <br>      OleDbgOut4(/*(LPSTR)*/szBuf); <br>   } <br>#endif <br>   return cRef; <br>} <br> <br> <br>/* Call Release on the object that is NOT necessarily expected to go away. <br>*/ <br>STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk) <br>{ <br>   ULONG cRef; <br> <br>   cRef = lpUnk-&gt;lpVtbl-&gt;Release(lpUnk); <br> <br>#if defined( _DEBUG ) <br>   { <br>      char szBuf[80]; <br>      wsprintf( <br>            /*(LPSTR)*/szBuf, <br>            "refcnt = %ld after object (0x%lx) release\n", <br>            cRef, <br>            lpUnk <br>      ); <br>      OleDbgOut4(/*(LPSTR)*/szBuf); <br>   } <br>#endif <br>   return cRef; <br>} <br> <br> <br>/************************************************************************* <br>** OleStdCreateRootStorage <br>**    create a root level Storage given a filename that is compatible <br>**    to be used by a top-level OLE container. if the filename <br>**    specifies an existing file, then an error is returned. <br>**    the root storage (Docfile) that is created by this function <br>**    is suitable to be used to create child storages for embedings. <br>**    (CreateChildStorage can be used to create child storages.) <br>**    NOTE: the root-level storage is opened in transacted mode. <br>*************************************************************************/ <br> <br>STDAPI_(LPSTORAGE) OleStdCreateRootStorage(LPOLESTR lpszStgName, DWORD grfMode) <br>{ <br>   HRESULT hr; <br>   DWORD grfCreateMode = STGM_READWRITE | STGM_TRANSACTED; <br>   DWORD reserved = 0; <br>   LPSTORAGE lpRootStg; <br>   char szMsg[64]; <br> <br>   // if temp file is being created, enable delete-on-release <br>   if (! lpszStgName) <br>      grfCreateMode |= STGM_DELETEONRELEASE; <br> <br>   hr = StgCreateDocfile( <br>         lpszStgName, <br>         grfMode | grfCreateMode, <br>         reserved, <br>         (LPSTORAGE FAR*)&amp;lpRootStg <br>      ); <br> <br>   if (hr == NOERROR) <br>      return lpRootStg;               // existing file successfully opened <br> <br>   OleDbgOutHResult("StgCreateDocfile returned", hr); <br> <br>   if (0 == LoadString(ghInst, (UINT)IDS_OLESTDNOCREATEFILE, /*(LPSTR)*/szMsg, 64)) <br>     return NULL; <br> <br>   MessageBox(NULL, /*(LPSTR)*/szMsg, NULL,MB_ICONEXCLAMATION | MB_OK); <br>   return NULL; <br>} <br> <br> <br>/* <br>** OleStdCreateChildStorage <br>**    create a child Storage inside the given lpStg that is compatible <br>**    to be used by an embedded OLE object. the return value from this <br>**    function can be passed to OleCreateXXX functions. <br>**    NOTE: the child storage is opened in transacted mode. <br>*/ <br>STDAPI_(LPSTORAGE) OleStdCreateChildStorage(LPSTORAGE lpStg, LPOLESTR lpszStgName) <br>{ <br>   if (lpStg != NULL) { <br>      LPSTORAGE lpChildStg; <br>      DWORD grfMode = (STGM_READWRITE | STGM_TRANSACTED | <br>            STGM_SHARE_EXCLUSIVE); <br>      DWORD reserved = 0; <br> <br>      HRESULT hrErr = lpStg-&gt;lpVtbl-&gt;CreateStorage( <br>            lpStg, <br>            lpszStgName, <br>            grfMode, <br>            reserved, <br>            reserved, <br>            (LPSTORAGE FAR*)&amp;lpChildStg <br>         ); <br> <br>      if (hrErr == NOERROR) <br>         return lpChildStg; <br> <br>      OleDbgOutHResult("lpStg-&gt;lpVtbl-&gt;CreateStorage returned", hrErr); <br>   } <br>   return NULL; <br>} <br> <br>HRESULT HrGetClassFileA(LPCSTR szFilenameA, CLSID * pclsid) <br>{ <br>    WCHAR lpszFilenameW[MAX_PATH]; <br>    HRESULT hr; <br> <br>    A2W (szFilenameA, lpszFilenameW, MAX_PATH); <br> <br>    hr = GetClassFile(lpszFilenameW, pclsid); <br> <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
