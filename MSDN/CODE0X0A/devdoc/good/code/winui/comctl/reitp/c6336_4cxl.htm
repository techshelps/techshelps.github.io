<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAWICON.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6339"></a>DRAWICON.C</h2>
<pre><code>/* <br> * DRAWICON.C <br> * <br> * Functions to handle creation of metafiles with icons and labels <br> * as well as functions to draw such metafiles with or without the label. <br> * <br> * The metafile is created with a comment that marks the records containing <br> * the label code.  Drawing the metafile enumerates the records, draws <br> * all records up to that point, then decides to either skip the label <br> * or draw it. <br> * <br> * Copyright (c)1992-1996 Microsoft Corporation, All Right Reserved <br> */ <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#include "common.h" <br>#include "utility.h" <br> <br>/* <br> * Strings for metafile comments.  KEEP THESE IN SYNC WITH THE <br> * STRINGS IN GETICON.C. <br> */ <br> <br>static char szIconOnly[]="IconOnly";        //Where to stop to exclude label. <br> <br> <br> <br> <br>/* <br> * OleUIMetafilePictIconFree <br> * <br> * Purpose: <br> *  Deletes the metafile contained in a METAFILEPICT structure and <br> *  frees the memory for the structure itself. <br> * <br> * Parameters: <br> *  hMetaPict       HGLOBAL metafilepict structure created in <br> *                  OleUIMetafilePictFromIconAndLabel <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) OleUIMetafilePictIconFree(HGLOBAL hMetaPict) <br>   { <br>   LPMETAFILEPICT      pMF; <br> <br>   if (NULL==hMetaPict) <br>      return; <br> <br>   pMF=(LPMETAFILEPICT)GlobalLock(hMetaPict); <br> <br>   if (NULL!=pMF) <br>      { <br>      if (NULL!=pMF-&gt;hMF) <br>         DeleteMetaFile(pMF-&gt;hMF); <br>      } <br> <br>   GlobalUnlock(hMetaPict); <br>   GlobalFree(hMetaPict); <br>   return; <br>   } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * OleUIMetafilePictIconDraw <br> * <br> * Purpose: <br> *  Draws the metafile from OleUIMetafilePictFromIconAndLabel, either with <br> *  the label or without. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw. <br> *  pRect           LPRECT in which to draw the metafile. <br> *  hMetaPict       HGLOBAL to the METAFILEPICT from <br> *                  OleUIMetafilePictFromIconAndLabel <br> *  fIconOnly       BOOL specifying to draw the label or not. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, FALSE if the <br> *                  given metafilepict is invalid. <br> */ <br> <br>STDAPI_(BOOL) OleUIMetafilePictIconDraw(HDC hDC, LPRECT pRect, HGLOBAL hMetaPict <br>                             , BOOL fIconOnly) <br>   { <br>   LPMETAFILEPICT  pMF; <br>   DRAWINFO        di; <br>   int             cx, cy; <br>   SIZE            size; <br>   POINT           point; <br> <br>   if (NULL==hMetaPict) <br>      return FALSE; <br> <br>   pMF=GlobalLock(hMetaPict); <br> <br>   if (NULL==pMF) <br>      return FALSE; <br> <br>   di.Rect = *pRect; <br>   di.fIconOnly = fIconOnly; <br> <br>   //Transform to back to pixels <br>   cx=XformWidthInHimetricToPixels(hDC, pMF-&gt;xExt); <br>   cy=XformHeightInHimetricToPixels(hDC, pMF-&gt;yExt); <br> <br>   SaveDC(hDC); <br> <br>   SetMapMode(hDC, pMF-&gt;mm); <br>   SetViewportOrgEx(hDC, (pRect-&gt;right - cx) / 2, 0, &amp;point); <br> <br>   SetViewportExtEx(hDC, min ((pRect-&gt;right - cx) / 2 + cx, cx), cy, &amp;size); <br> <br>   if (fIconOnly) <br>      { <br>      // Since we've used the __export keyword on the <br>      // EnumMetafileIconDraw proc, we do not need to use <br>      // MakeProcInstance <br>      EnumMetaFile(hDC, pMF-&gt;hMF, (MFENUMPROC)EnumMetafileIconDraw <br>         , (LPARAM)(LPDRAWINFO)&amp;di); <br>      } <br>   else <br>      PlayMetaFile(hDC, pMF-&gt;hMF); <br> <br>   RestoreDC(hDC, -1); <br> <br>   GlobalUnlock(hMetaPict); <br>   return TRUE; <br>   } <br> <br> <br> <br> <br>/* <br> * EnumMetafileIconDraw <br> * <br> * Purpose: <br> *  EnumMetaFile callback function that draws either the icon only or <br> *  the icon and label depending on given flags. <br> * <br> * Parameters: <br> *  hDC             HDC into which the metafile should be played. <br> *  phTable         HANDLETABLE FAR * providing handles selected into the DC. <br> *  pMFR            METARECORD FAR * giving the enumerated record. <br> *  lParam          LPARAM flags passed in EnumMetaFile. <br> * <br> * Return Value: <br> *  int             0 to stop enumeration, 1 to continue. <br> */ <br> <br>int CALLBACK EXPORT EnumMetafileIconDraw(HDC hDC, HANDLETABLE FAR *phTable <br>   , METARECORD FAR *pMFR, int cObj, LPARAM lParam) <br>   { <br>   LPDRAWINFO lpdi = (LPDRAWINFO)lParam; <br> <br>   /* <br>    * We play everything blindly except for DIBBITBLT (or DIBSTRETCHBLT) <br>    * and ESCAPE with MFCOMMENT.  For the BitBlts we change the x,y to <br>    * draw at (0,0) instead of wherever it was written to draw.  The <br>    * comment tells us there to stop if we don't want to draw the label. <br>    */ <br> <br>   //If we're playing icon only, stop enumeration at the comment. <br>   if (lpdi-&gt;fIconOnly) <br>      { <br>      if (META_ESCAPE==pMFR-&gt;rdFunction &amp;&amp; MFCOMMENT==pMFR-&gt;rdParm[0]) <br>         { <br>         if (0==lstrcmpi(szIconOnly, (LPSTR)&amp;pMFR-&gt;rdParm[2])) <br>            return 0; <br>         } <br> <br>      /* <br>       * Check for the records in which we want to munge the coordinates. <br>       * destX is offset 6 for BitBlt, offset 9 for StretchBlt, either of <br>       * which may appear in the metafile. <br>       */ <br>      if (META_DIBBITBLT==pMFR-&gt;rdFunction) <br>         pMFR-&gt;rdParm[6]=0; <br> <br>      if (META_DIBSTRETCHBLT==pMFR-&gt;rdFunction) <br>           pMFR-&gt;rdParm[9] = 0; <br> <br>      } <br> <br> <br>   PlayMetaFileRecord(hDC, phTable, pMFR, cObj); <br>   return 1; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * OleUIMetafilePictExtractLabel <br> * <br> * Purpose: <br> *  Retrieves the label string from metafile representation of an icon. <br> * <br> * Parameters: <br> *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile. <br> *  lpszLabel       LPSTR in which to store the label. <br> *  cchLabel        UINT length of lpszLabel. <br> *  lpWrapIndex     DWORD index of first character in last line. Can be NULL <br> *                  if calling function doesn't care about word wrap. <br> * <br> * Return Value: <br> *  UINT            Number of characters copied. <br> */ <br>STDAPI_(UINT) OleUIMetafilePictExtractLabel(HGLOBAL hMetaPict, LPOLESTR lpszLabel <br>                                , UINT cchLabel, LPDWORD lpWrapIndex) <br>   { <br>   LPMETAFILEPICT  pMF; <br>   LABELEXTRACT    le; <br>   HDC             hDC; <br> <br>   /* <br>    * We extract the label by getting a screen DC and walking the metafile <br>    * records until we see the ExtTextOut record we put there.  That <br>    * record will have the string embedded in it which we then copy out. <br>    */ <br> <br>   if (NULL==hMetaPict || NULL==lpszLabel || 0==cchLabel) <br>      return FALSE; <br> <br>   pMF=GlobalLock(hMetaPict); <br> <br>   if (NULL==pMF) <br>      return FALSE; <br> <br>   le.lpsz=lpszLabel; <br>   le.u.cch=cchLabel; <br>   le.Index=0; <br>   le.fFoundIconOnly=FALSE; <br>   le.fFoundSource=FALSE;  //Unused for this function. <br>   le.fFoundIndex=FALSE;   //Unused for this function. <br>   le.PrevIndex = 0; <br> <br>   //Use a screen DC so we have something valid to pass in. <br>   hDC=GetDC(NULL); <br> <br>   // Since we've used the EXPORT keyword on the <br>   // EnumMetafileExtractLabel proc, we do not need to use <br>   // MakeProcInstance <br> <br>   EnumMetaFile(hDC, pMF-&gt;hMF, (MFENUMPROC)EnumMetafileExtractLabel, (LONG)(LPLABELEXTRACT)&amp;le); <br> <br>   ReleaseDC(NULL, hDC); <br> <br>   GlobalUnlock(hMetaPict); <br> <br>   //Tell where we wrapped (if calling function cares) <br>   if (NULL != lpWrapIndex) <br>      *lpWrapIndex = le.PrevIndex; <br> <br>   //Return amount of text copied <br>   return le.u.cch; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * EnumMetafileExtractLabel <br> * <br> * Purpose: <br> *  EnumMetaFile callback function that walks a metafile looking for <br> *  ExtTextOut, then concatenates the text from each one into a buffer <br> *  in lParam. <br> * <br> * Parameters: <br> *  hDC             HDC into which the metafile should be played. <br> *  phTable         HANDLETABLE FAR * providing handles selected into the DC. <br> *  pMFR            METARECORD FAR * giving the enumerated record. <br> *  pLE             LPLABELEXTRACT providing the destination buffer and length. <br> * <br> * Return Value: <br> *  int             0 to stop enumeration, 1 to continue. <br> */ <br> <br>int CALLBACK EXPORT EnumMetafileExtractLabel(HDC hDC, HANDLETABLE FAR *phTable <br>   , METARECORD FAR *pMFR, int cObj, LPLABELEXTRACT pLE) <br>   { <br> <br>   /* <br>    * We don't allow anything to happen until we see "IconOnly" <br>    * in an MFCOMMENT that is used to enable everything else. <br>    */ <br>   if (!pLE-&gt;fFoundIconOnly) <br>      { <br>      if (META_ESCAPE==pMFR-&gt;rdFunction &amp;&amp; MFCOMMENT==pMFR-&gt;rdParm[0]) <br>         { <br>         if (0==lstrcmpi(szIconOnly, (LPSTR)&amp;pMFR-&gt;rdParm[2])) <br>            pLE-&gt;fFoundIconOnly=TRUE; <br>         } <br> <br>      return 1; <br>      } <br> <br>   //Enumerate all records looking for META_EXTTEXTOUT - there can be more <br>   //than one. <br>   if (META_EXTTEXTOUT==pMFR-&gt;rdFunction) <br>      { <br>      UINT        cchMax; <br>      LPOLESTR    lpszTemp; <br> <br>       /* <br>       * If ExtTextOut has NULL fuOptions, then the rectangle is omitted <br>       * from the record, and the string starts at rdParm[4].  If <br>       * fuOptions is non-NULL, then the string starts at rdParm[8] <br>       * (since the rectange takes up four WORDs in the array).  In <br>       * both cases, the string continues for (rdParm[2]+1) &gt;&gt; 1 <br>       * words.  We just cast a pointer to rdParm[8] to an LPSTR and <br>       * lstrcpyn into the buffer we were given. <br>       * <br>       * Note that we use element 8 in rdParm instead of 4 because we <br>       * passed ETO_CLIPPED in for the options on ExtTextOut--docs say <br>       * [4] which is rect doesn't exist if we passed zero there. <br>       * <br>       */ <br> <br>      cchMax=min(pLE-&gt;u.cch - pLE-&gt;Index, (UINT)pMFR-&gt;rdParm[2]); <br>      lpszTemp = /*(LPOLESTR)*/((/*(LPSTR)*/pLE-&gt;lpsz) + pLE-&gt;Index); <br> <br>      A2W ((LPSTR)&amp;(pMFR-&gt;rdParm[8]), lpszTemp, cchMax); <br>      lpszTemp[cchMax]='\0'; <br> <br>      pLE-&gt;u.cch = OLESTRLEN (pLE-&gt;lpsz); <br>      pLE-&gt;PrevIndex = pLE-&gt;Index; <br>      pLE-&gt;Index += cchMax; <br>      } <br> <br>   return 1; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * OleUIMetafilePictExtractIcon <br> * <br> * Purpose: <br> *  Retrieves the icon from metafile into which DrawIcon was done before. <br> * <br> * Parameters: <br> *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile. <br> * <br> * Return Value: <br> *  HICON           Icon recreated from the data in the metafile. <br> */ <br>STDAPI_(HICON) OleUIMetafilePictExtractIcon(HGLOBAL hMetaPict) <br>   { <br>   LPMETAFILEPICT  pMF; <br>   HDC             hDC; <br>   ICONEXTRACT     ie; <br> <br>   /* <br>    * We extract the label by getting a screen DC and walking the metafile <br>    * records until we see the ExtTextOut record we put there.  That <br>    * record will have the string embedded in it which we then copy out. <br>    */ <br> <br>   if (NULL==hMetaPict) <br>      return NULL; <br> <br>   pMF=GlobalLock(hMetaPict); <br> <br>   if (NULL==pMF) <br>      return FALSE; <br> <br>   //Use a screen DC so we have something valid to pass in. <br>   hDC=GetDC(NULL); <br>   ie.fAND=TRUE; <br> <br>   // We get information back in the ICONEXTRACT structure. <br>   // (Since we've used the EXPORT keyword on the <br>   // EnumMetafileExtractLabel proc, we do not need to use <br>   // MakeProcInstance) <br>   EnumMetaFile(hDC, pMF-&gt;hMF, (MFENUMPROC)EnumMetafileExtractIcon, (LONG)(LPICONEXTRACT)&amp;ie); <br> <br>   ReleaseDC(NULL, hDC); <br>   GlobalUnlock(hMetaPict); <br> <br>   return ie.hIcon; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * EnumMetafileExtractIcon <br> * <br> * Purpose: <br> *  EnumMetaFile callback function that walks a metafile looking for <br> *  StretchBlt (3.1) and BitBlt (3.0) records.  We expect to see two <br> *  of them, the first being the AND mask and the second being the XOR <br> *  data.  We <br> *  ExtTextOut, then copies the text into a buffer in lParam. <br> * <br> * Parameters: <br> *  hDC             HDC into which the metafile should be played. <br> *  phTable         HANDLETABLE FAR * providing handles selected into the DC. <br> *  pMFR            METARECORD FAR * giving the enumerated record. <br> *  pIE             LPICONEXTRACT providing the destination buffer and length. <br> * <br> * Return Value: <br> *  int             0 to stop enumeration, 1 to continue. <br> */ <br> <br>int CALLBACK EXPORT EnumMetafileExtractIcon(HDC hDC, HANDLETABLE FAR *phTable <br>   , METARECORD FAR *pMFR, int cObj, LPICONEXTRACT pIE) <br>   { <br>   LPBITMAPINFO        lpBI; <br>   LPBITMAPINFOHEADER  lpBH; <br>   LPBYTE              lpbSrc; <br>   LPBYTE              lpbDst; <br>   UINT                uWidth, uHeight; <br>   DWORD               cb; <br>   HGLOBAL             hMem; <br>   BITMAP              bm; <br>   HBITMAP             hBmp; <br>   int                 cxIcon, cyIcon; <br> <br> <br>   //Continue enumeration if we don't see the records we want. <br>   if (META_DIBBITBLT!=pMFR-&gt;rdFunction &amp;&amp; META_DIBSTRETCHBLT!=pMFR-&gt;rdFunction) <br>      return 1; <br> <br>   /* <br>    * Windows 3.0 DrawIcon uses META_DIBBITBLT in whereas 3.1 uses <br>    * META_DIBSTRETCHBLT so we have to handle each case separately. <br>    */ <br> <br>   if (META_DIBBITBLT==pMFR-&gt;rdFunction)       //Win3.0 <br>      { <br>      //Get dimensions and the BITMAPINFO struct. <br>      uHeight=pMFR-&gt;rdParm[1]; <br>      uWidth =pMFR-&gt;rdParm[2]; <br>      lpBI=(LPBITMAPINFO)&amp;(pMFR-&gt;rdParm[8]); <br>      } <br> <br>   if (META_DIBSTRETCHBLT==pMFR-&gt;rdFunction)   //Win3.1 <br>      { <br>      //Get dimensions and the BITMAPINFO struct. <br>      uHeight=pMFR-&gt;rdParm[2]; <br>      uWidth =pMFR-&gt;rdParm[3]; <br>      lpBI=(LPBITMAPINFO)&amp;(pMFR-&gt;rdParm[10]); <br>      } <br> <br>   lpBH=(LPBITMAPINFOHEADER)&amp;(lpBI-&gt;bmiHeader); <br> <br>   //Pointer to the bits which follows the BITMAPINFO structure. <br>   lpbSrc=(LPBYTE)lpBI+lpBH-&gt;biSize; <br> <br>   //Add the length of the color table. <br>   if (0!=lpBH-&gt;biClrUsed) <br>      lpbSrc+=(DWORD)(lpBH-&gt;biClrUsed*sizeof(RGBQUAD)); <br>   else <br>      { <br>      /* <br>       * 1 &lt;&lt; bc gives 2, 16, 256 for 1, 4, or 8 bits.  24-bit <br>       * bitmaps have no color table, so there's no need to <br>       * change lpbSrc. <br>       */ <br>      if (lpBH-&gt;biBitCount &lt;= 8) <br>          lpbSrc+=(DWORD)((1 &lt;&lt; (lpBH-&gt;biBitCount))*sizeof(RGBQUAD)); <br>      } <br> <br> <br>   /* <br>    * All the bits we have in lpbSrc are device-independent, so we <br>    * need to change them over to be device-dependent using SetDIBits. <br>    * Once we have a bitmap with the device-dependent bits, we can <br>    * GetBitmapBits to have buffers with the real data. <br>    * <br>    * For each pass we have to allocate memory for the bits.  We save <br>    * the memory for the mask between passes. <br>    */ <br> <br>   //Use CreateBitmap for ANY monochrome bitmaps <br>   if (pIE-&gt;fAND || 1==lpBH-&gt;biBitCount || lpBH-&gt;biBitCount &gt; 8) <br>      hBmp=CreateBitmap((UINT)lpBH-&gt;biWidth, (UINT)lpBH-&gt;biHeight, 1, 1, NULL); <br>   else if (lpBH-&gt;biBitCount &lt;= 8) <br>      hBmp=CreateCompatibleBitmap(hDC, (UINT)lpBH-&gt;biWidth, (UINT)lpBH-&gt;biHeight); <br> <br>   if (!hBmp || !SetDIBits(hDC, hBmp, 0, (UINT)lpBH-&gt;biHeight, (LPVOID)lpbSrc, lpBI, DIB_RGB_COLORS)) <br>      { <br>      if (!pIE-&gt;fAND) <br>         GlobalFree(pIE-&gt;hMemAND); <br> <br>      DeleteObject(hBmp); <br>      return 0; <br>      } <br> <br>   //Allocate memory and get the DDBits into it. <br>   GetObject(hBmp, sizeof(bm), &amp;bm); <br> <br>   cb=bm.bmHeight*bm.bmWidthBytes * bm.bmPlanes; <br> <br>//    if (cb % 4 != 0)        // dword align <br>//      cb += 4 - (cb % 4); <br> <br>   hMem=GlobalAlloc(GHND, cb); <br> <br>   if (NULL==hMem) <br>      { <br>      if (NULL!=pIE-&gt;hMemAND) <br>         GlobalFree(pIE-&gt;hMemAND); <br> <br>      DeleteObject(hBmp); <br>      return 0; <br>      } <br> <br>   lpbDst=(LPBYTE)GlobalLock(hMem); <br>   GetBitmapBits(hBmp, cb, (LPVOID)lpbDst); <br> <br>   DeleteObject(hBmp); <br>   GlobalUnlock(hMem); <br> <br> <br>   /* <br>    * If this is the first pass (pIE-&gt;fAND==TRUE) then save the memory <br>    * of the AND bits for the next pass. <br>    */ <br>   if (pIE-&gt;fAND) <br>      { <br>      pIE-&gt;fAND=FALSE; <br>      pIE-&gt;hMemAND=hMem; <br> <br>      //Continue enumeration looking for the next blt record. <br>      return 1; <br>      } <br>   else <br>      { <br>      //Get the AND pointer again. <br>      lpbSrc=(LPBYTE)GlobalLock(pIE-&gt;hMemAND); <br> <br>      /* <br>       * Create the icon now that we have all the data.  lpbDst already <br>       * points to the XOR bits. <br>       */ <br>      cxIcon = GetSystemMetrics(SM_CXICON); <br>      cyIcon = GetSystemMetrics(SM_CYICON); <br> <br>      pIE-&gt;hIcon=CreateIcon(ghInst, <br>                       uWidth, <br>                       uHeight, <br>                       (BYTE)bm.bmPlanes, <br>                       (BYTE)bm.bmBitsPixel, <br>                       (LPVOID)lpbSrc, <br>                       (LPVOID)lpbDst); <br> <br>      GlobalUnlock(pIE-&gt;hMemAND); <br>      GlobalFree(pIE-&gt;hMemAND); <br>      GlobalFree(hMem); <br> <br>      //We're done so we can stop. <br>      return 0; <br>      } <br>   } <br> <br> <br> <br> <br> <br>/* <br> * OleUIMetafilePictExtractIconSource <br> * <br> * Purpose: <br> *  Retrieves the filename and index of the icon source from a metafile <br> *  created with OleUIMetafilePictFromIconAndLabel. <br> * <br> * Parameters: <br> *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile. <br> *  lpszSource      LPSTR in which to store the source filename.  This <br> *                  buffer should be OLEUI_CCHPATHMAX characters. <br> *  piIcon          UINT FAR * in which to store the icon's index <br> *                  within lpszSource <br> * <br> * Return Value: <br> *  BOOL            TRUE if the records were found, FALSE otherwise. <br> */ <br>STDAPI_(BOOL) OleUIMetafilePictExtractIconSource(HGLOBAL hMetaPict <br>   , LPOLESTR lpszSource, UINT FAR *piIcon) <br>   { <br>   LPMETAFILEPICT  pMF; <br>   LABELEXTRACT    le; <br>   HDC             hDC; <br> <br>   /* <br>    * We will walk the metafile looking for the two comment records <br>    * following the IconOnly comment.  The flags fFoundIconOnly and <br>    * fFoundSource indicate if we have found IconOnly and if we have <br>    * found the source comment already. <br>    */ <br> <br>   if (NULL==hMetaPict || NULL==lpszSource || NULL==piIcon) <br>      return FALSE; <br> <br>   pMF=GlobalLock(hMetaPict); <br> <br>   if (NULL==pMF) <br>      return FALSE; <br> <br>   le.lpsz=lpszSource; <br>   le.fFoundIconOnly=FALSE; <br>   le.fFoundSource=FALSE; <br>   le.fFoundIndex=FALSE; <br> <br>   //Use a screen DC so we have something valid to pass in. <br>   hDC=GetDC(NULL); <br> <br>   EnumMetaFile(hDC, pMF-&gt;hMF, (MFENUMPROC)EnumMetafileExtractIconSource, (LONG)(LPLABELEXTRACT)&amp;le); <br> <br>   ReleaseDC(NULL, hDC); <br>   GlobalUnlock(hMetaPict); <br> <br>   //Copy the icon index to the caller's variable. <br>   *piIcon=le.u.iIcon; <br> <br>   //Check that we found everything. <br>   return (le.fFoundIconOnly &amp;&amp; le.fFoundSource &amp;&amp; le.fFoundIndex); <br>   } <br> <br> <br>/* <br> * EnumMetafileExtractIconSource <br> * <br> * Purpose: <br> *  EnumMetaFile callback function that walks a metafile skipping the first <br> *  comment record, extracting the source filename from the second, and <br> *  the index of the icon in the third. <br> * <br> * Parameters: <br> *  hDC             HDC into which the metafile should be played. <br> *  phTable         HANDLETABLE FAR * providing handles selected into the DC. <br> *  pMFR            METARECORD FAR * giving the enumerated record. <br> *  pLE             LPLABELEXTRACT providing the destination buffer and <br> *                  area to store the icon index. <br> * <br> * Return Value: <br> *  int             0 to stop enumeration, 1 to continue. <br> */ <br>int CALLBACK EXPORT EnumMetafileExtractIconSource(HDC hDC, HANDLETABLE FAR *phTable <br>   , METARECORD FAR *pMFR, int cObj, LPLABELEXTRACT pLE) <br>   { <br>   LPSTR       psz; <br> <br>   /* <br>    * We don't allow anything to happen until we see "IconOnly" <br>    * in an MFCOMMENT that is used to enable everything else. <br>    */ <br>   if (!pLE-&gt;fFoundIconOnly) <br>      { <br>      if (META_ESCAPE==pMFR-&gt;rdFunction &amp;&amp; MFCOMMENT==pMFR-&gt;rdParm[0]) <br>         { <br>         if (0==lstrcmpi(szIconOnly, (LPSTR)&amp;pMFR-&gt;rdParm[2])) <br>            pLE-&gt;fFoundIconOnly=TRUE; <br>         } <br> <br>      return 1; <br>      } <br> <br>   //Now see if we find the source string. <br>   if (!pLE-&gt;fFoundSource) <br>      { <br>      if (META_ESCAPE==pMFR-&gt;rdFunction &amp;&amp; MFCOMMENT==pMFR-&gt;rdParm[0]) <br>         { <br>         A2W  ((LPSTR)&amp;pMFR-&gt;rdParm[2], pLE-&gt;lpsz, OLEUI_CCHPATHMAX); <br>         pLE-&gt;lpsz[OLEUI_CCHPATHMAX-1] = '\0'; <br>         pLE-&gt;fFoundSource=TRUE; <br>         } <br> <br>      return 1; <br>      } <br> <br>   //Next comment will be the icon index. <br>   if (META_ESCAPE==pMFR-&gt;rdFunction &amp;&amp; MFCOMMENT==pMFR-&gt;rdParm[0]) <br>      { <br>      /* <br>       * This string contains the icon index in string form, <br>       * so we need to convert back to a UINT.  After we see this <br>       * we can stop the enumeration.  The comment will have <br>       * a null terminator because we made sure to save it. <br>       */ <br>      psz=(LPSTR)&amp;pMFR-&gt;rdParm[2]; <br>      pLE-&gt;u.iIcon=0; <br> <br>      //Do Ye Olde atoi <br>      while (*psz) <br>         pLE-&gt;u.iIcon=(10*pLE-&gt;u.iIcon)+((*psz++)-'0'); <br> <br>      pLE-&gt;fFoundIndex=TRUE; <br>      return 0; <br>      } <br> <br>   return 1; <br>   } </code></pre>
<p>&nbsp;</p></body>
</HTML>
