<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEUTL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6345"></a>OLEUTL.C</h2>
<pre><code>/* <br> * OLEUTL.C <br> * <br> * Miscellaneous utility functions for OLE 2.0 Applications: <br> * <br> *  Function                      Purpose <br> *  ------------------------------------------------------------------- <br> *  SetDCToDrawInHimetricRect     Sets up an HIMETRIC mapping mode in a DC. <br> *  ResetOrigDC                   Performs the opposite of <br> *                                SetDCToDrawInHimetricRect <br> *  XformWidthInPixelsToHimetric  Converts an int width into HiMetric units <br> *  XformWidthInHimetricToPixels  Converts an int width from HiMetric units <br> *  XformHeightInPixelsToHimetric Converts an int height into HiMetric units <br> *  XformHeightInHimetricToPixels Converts an int height from HiMetric units <br> *  XformRectInPixelsToHimetric   Converts a rect into HiMetric units <br> *  XformRectInHimetricToPixels   Converts a rect from HiMetric units <br> *  XformSizeInPixelsToHimetric   Converts a SIZEL into HiMetric units <br> *  XformSizeInHimetricToPixels   Converts a SIZEL from HiMetric units <br> *  AreRectsEqual                 Compares to Rect's <br> * <br> *  ParseCmdLine                  Determines if -Embedding exists <br> *  OpenOrCreateRootStorage       Creates a root docfile for OLE storage <br> *  CommitStorage                 Commits all changes in a docfile <br> *  CreateChildStorage            Creates child storage in another storage <br> *  OpenChildStorage              Opens child storage in another storage <br> * <br> * <br> * Copyright (c)1992-1996 Microsoft Corporation, All Right Reserved <br> */ <br> <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#include &lt;stdlib.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>//Internal function to this module <br>static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst); <br> <br> <br>/* <br> * SetDCToAnisotropic <br> * <br> * Purpose: <br> *  Setup the correspondence between the rect in device unit (Viewport) and <br> *  the rect in logical unit (Window) so that the proper scaling of <br> *  coordinate systems will be calculated. set up both the Viewport and <br> *  the window as follows: <br> * <br> *      1) ------------------ ( 2 <br> *      |                     | <br> *      |                     | <br> *      |                     | <br> *      |                     | <br> *      |                     | <br> *      3) ------------------ ( 4 <br> * <br> *      Origin   = P3 <br> *      X extent = P2x - P3x <br> *      Y extent = P2y - P3y <br> * <br> * Parameters: <br> *  hDC             HDC to affect <br> *  lprcPhysical    LPRECT containing the physical (device) extents of DC <br> *  lprcLogical     LPRECT containing the logical extents <br> *  lprcWindowOld   LPRECT in which to preserve the window for ResetOrigDC <br> *  lprcViewportOld LPRECT in which to preserver the viewport for ResetOrigDC <br> * <br> * Return Value: <br> *  int             The original mapping mode of the DC. <br> */ <br> <br>STDAPI_(int) SetDCToAnisotropic( <br>                HDC hDC, <br>                LPRECT lprcPhysical, LPRECT lprcLogical, <br>                LPRECT lprcWindowOld, LPRECT lprcViewportOld) <br>{ <br>        int     nMapModeOld=SetMapMode(hDC, MM_ANISOTROPIC); <br> <br>        SetWindowOrgEx(hDC, lprcLogical-&gt;left, lprcLogical-&gt;bottom, (LPPOINT)&amp;lprcWindowOld-&gt;left); <br>        SetWindowExtEx(hDC, (lprcLogical-&gt;right-lprcLogical-&gt;left), (lprcLogical-&gt;top-lprcLogical-&gt;bottom), (LPSIZE)&amp;lprcWindowOld-&gt;right); <br>        SetViewportOrgEx(hDC, lprcPhysical-&gt;left, lprcPhysical-&gt;bottom, (LPPOINT)&amp;lprcViewportOld-&gt;left); <br>        SetViewportExtEx(hDC, (lprcPhysical-&gt;right-lprcPhysical-&gt;left), (lprcPhysical-&gt;top-lprcPhysical-&gt;bottom), (LPSIZE)&amp;lprcViewportOld-&gt;right); <br> <br>        return nMapModeOld; <br>} <br> <br> <br>/* <br> * SetDCToDrawInHimetricRect <br> * <br> * Purpose: <br> *  Setup the correspondence between the rect in pixels (Viewport) and <br> *  the rect in HIMETRIC (Window) so that the proper scaling of <br> *  coordinate systems will be calculated. set up both the Viewport and <br> *  the window as follows: <br> * <br> *      1) ------------------ ( 2 <br> *      |                     | <br> *      |                     | <br> *      |                     | <br> *      |                     | <br> *      |                     | <br> *      3) ------------------ ( 4 <br> * <br> *      Origin   = P3 <br> *      X extent = P2x - P3x <br> *      Y extent = P2y - P3y <br> * <br> * Parameters: <br> *  hDC             HDC to affect <br> *  lprcPix         LPRECT containing the pixel extents of DC <br> *  lprcHiMetric    LPRECT to receive the himetric extents <br> *  lprcWindowOld   LPRECT in which to preserve the window for ResetOrigDC <br> *  lprcViewportOld LPRECT in which to preserver the viewport for ResetOrigDC <br> * <br> * Return Value: <br> *  int             The original mapping mode of the DC. <br> */ <br>STDAPI_(int) SetDCToDrawInHimetricRect( <br>        HDC hDC, <br>        LPRECT lprcPix, LPRECT lprcHiMetric, <br>        LPRECT lprcWindowOld, LPRECT lprcViewportOld) <br>        { <br>        int     nMapModeOld=SetMapMode(hDC, MM_ANISOTROPIC); <br>        BOOL    fSystemDC  =FALSE; <br> <br>        if (NULL==hDC) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        XformRectInPixelsToHimetric(hDC, lprcPix, lprcHiMetric); <br> <br>        SetWindowOrgEx(hDC, lprcHiMetric-&gt;left, lprcHiMetric-&gt;bottom, (LPPOINT)&amp;lprcWindowOld-&gt;left); <br>        SetWindowExtEx(hDC, (lprcHiMetric-&gt;right-lprcHiMetric-&gt;left), (lprcHiMetric-&gt;top-lprcHiMetric-&gt;bottom), (LPSIZE)&amp;lprcWindowOld-&gt;right); <br>        SetViewportOrgEx(hDC, lprcPix-&gt;left, lprcPix-&gt;bottom, (LPPOINT)&amp;lprcViewportOld-&gt;left); <br>        SetViewportExtEx(hDC, (lprcPix-&gt;right-lprcPix-&gt;left), (lprcPix-&gt;top-lprcPix-&gt;bottom), (LPSIZE)&amp;lprcViewportOld-&gt;right); <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return nMapModeOld; <br>        } <br> <br> <br> <br>/* <br> * ResetOrigDC <br> * <br> * Purpose: <br> *  Restores a DC set to draw in himetric from SetDCToDrawInHimetricRect. <br> * <br> * Parameters: <br> *  hDC             HDC to restore <br> *  nMapModeOld     int original mapping mode of hDC <br> *  lprcWindowOld   LPRECT filled in SetDCToDrawInHimetricRect <br> *  lprcViewportOld LPRECT filled in SetDCToDrawInHimetricRect <br> * <br> * Return Value: <br> *  int             Same as nMapModeOld. <br> */ <br> <br>STDAPI_(int) ResetOrigDC( <br>        HDC hDC, int nMapModeOld, <br>        LPRECT lprcWindowOld, LPRECT lprcViewportOld) <br>        { <br>        POINT     pOld; <br> <br>        SetMapMode(hDC, nMapModeOld); <br> <br>        SetWindowOrgEx(hDC,   lprcWindowOld-&gt;left,    lprcWindowOld-&gt;top,      (LPPOINT)&amp;pOld); <br>        SetWindowExtEx(hDC,   lprcWindowOld-&gt;right,   lprcWindowOld-&gt;bottom,   (LPSIZE)&amp;pOld); <br>        SetViewportOrgEx(hDC, lprcViewportOld-&gt;left,  lprcViewportOld-&gt;top,    (LPPOINT)&amp;pOld); <br>        SetViewportExtEx(hDC, lprcViewportOld-&gt;right, lprcViewportOld-&gt;bottom, (LPSIZE)&amp;pOld); <br> <br>        return nMapModeOld; <br>        } <br> <br> <br> <br>/* <br> * XformWidthInPixelsToHimetric <br> * XformWidthInHimetricToPixels <br> * XformHeightInPixelsToHimetric <br> * XformHeightInHimetricToPixels <br> * <br> * Functions to convert an int between a device coordinate system and <br> * logical HiMetric units. <br> * <br> * Parameters: <br> *  hDC             HDC providing reference to the pixel mapping.  If <br> *                  NULL, a screen DC is used. <br> * <br> *  Size Functions: <br> *  lpSizeSrc       LPSIZEL providing the structure to convert.  This <br> *                  contains pixels in XformSizeInPixelsToHimetric and <br> *                  logical HiMetric units in the complement function. <br> *  lpSizeDst       LPSIZEL providing the structure to receive converted <br> *                  units.  This contains pixels in <br> *                  XformSizeInPixelsToHimetric and logical HiMetric <br> *                  units in the complement function. <br> * <br> *  Width Functions: <br> *  iWidth          int containing the value to convert. <br> * <br> * Return Value: <br> *  Size Functions:     None <br> *  Width Functions:    Converted value of the input parameters. <br> * <br> * NOTE: <br> *  When displaying on the screen, Window apps display everything enlarged <br> *  from its actual size so that it is easier to read. For example, if an <br> *  app wants to display a 1in. horizontal line, that when printed is <br> *  actually a 1in. line on the printed page, then it will display the line <br> *  on the screen physically larger than 1in. This is described as a line <br> *  that is "logically" 1in. along the display width. Windows maintains as <br> *  part of the device-specific information about a given display device: <br> *      LOGPIXELSX -- no. of pixels per logical in along the display width <br> *      LOGPIXELSY -- no. of pixels per logical in along the display height <br> * <br> *  The following formula converts a distance in pixels into its equivalent <br> *  logical HIMETRIC units: <br> * <br> *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix) <br> *                       ------------------------------- <br> *                           PIXELS_PER_LOGICAL_IN <br> * <br> */ <br>STDAPI_(int) XformWidthInPixelsToHimetric(HDC hDC, int iWidthInPix) <br>        { <br>        int     iXppli;     //Pixels per logical inch along width <br>        int     iWidthInHiMetric; <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iXppli = GetDeviceCaps (hDC, LOGPIXELSX); <br> <br>        //We got pixel units, convert them to logical HIMETRIC along the display <br>        iWidthInHiMetric = MAP_PIX_TO_LOGHIM(iWidthInPix, iXppli); <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return iWidthInHiMetric; <br>        } <br> <br> <br>STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric) <br>        { <br>        int     iXppli;     //Pixels per logical inch along width <br>        int     iWidthInPix; <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iXppli = GetDeviceCaps (hDC, LOGPIXELSX); <br> <br>        //We got logical HIMETRIC along the display, convert them to pixel units <br>        iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli); <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return iWidthInPix; <br>        } <br> <br> <br>STDAPI_(int) XformHeightInPixelsToHimetric(HDC hDC, int iHeightInPix) <br>        { <br>        int     iYppli;     //Pixels per logical inch along height <br>        int     iHeightInHiMetric; <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iYppli = GetDeviceCaps (hDC, LOGPIXELSY); <br> <br>        //* We got pixel units, convert them to logical HIMETRIC along the display <br>        iHeightInHiMetric = MAP_PIX_TO_LOGHIM(iHeightInPix, iYppli); <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return iHeightInHiMetric; <br>        } <br> <br> <br>STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric) <br>        { <br>        int     iYppli;     //Pixels per logical inch along height <br>        int     iHeightInPix; <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iYppli = GetDeviceCaps (hDC, LOGPIXELSY); <br> <br>        //* We got logical HIMETRIC along the display, convert them to pixel units <br>        iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli); <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return iHeightInPix; <br>        } <br> <br> <br> <br>/* <br> * XformRectInPixelsToHimetric <br> * XformRectInHimetricToPixels <br> * <br> * Purpose: <br> *  Convert a rectangle between pixels of a given hDC and HIMETRIC units <br> *  as manipulated in OLE.  If the hDC is NULL, then a screen DC is used <br> *  and assumes the MM_TEXT mapping mode. <br> * <br> * Parameters: <br> *  hDC             HDC providing reference to the pixel mapping.  If <br> *                  NULL, a screen DC is used. <br> *  lprcSrc         LPRECT providing the rectangle to convert.  This <br> *                  contains pixels in XformRectInPixelsToHimetric and <br> *                  logical HiMetric units in the complement function. <br> *  lprcDst         LPRECT providing the rectangle to receive converted units. <br> *                  This contains pixels in XformRectInPixelsToHimetric and <br> *                  logical HiMetric units in the complement function. <br> * <br> * Return Value: <br> *  None <br> * <br> * NOTE: <br> *  When displaying on the screen, Window apps display everything enlarged <br> *  from its actual size so that it is easier to read. For example, if an <br> *  app wants to display a 1in. horizontal line, that when printed is <br> *  actually a 1in. line on the printed page, then it will display the line <br> *  on the screen physically larger than 1in. This is described as a line <br> *  that is "logically" 1in. along the display width. Windows maintains as <br> *  part of the device-specific information about a given display device: <br> *      LOGPIXELSX -- no. of pixels per logical in along the display width <br> *      LOGPIXELSY -- no. of pixels per logical in along the display height <br> * <br> *  The following formula converts a distance in pixels into its equivalent <br> *  logical HIMETRIC units: <br> * <br> *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix) <br> *                      ------------------------------- <br> *                            PIXELS_PER_LOGICAL_IN <br> * <br> * Rect in Pixels (MM_TEXT): <br> * <br> *              0---------- X <br> *              | <br> *              |       1) ------------------ ( 2   P1 = (rc.left, rc.top) <br> *              |       |                     |     P2 = (rc.right, rc.top) <br> *              |       |                     |     P3 = (rc.left, rc.bottom) <br> *              |       |                     |     P4 = (rc.right, rc.bottom) <br> *                      |                     | <br> *              Y       |                     | <br> *                      3) ------------------ ( 4 <br> * <br> *              NOTE:   Origin   = (P1x, P1y) <br> *                      X extent = P4x - P1x <br> *                      Y extent = P4y - P1y <br> * <br> * <br> * Rect in Himetric (MM_HIMETRIC): <br> * <br> * <br> *                      1) ------------------ ( 2   P1 = (rc.left, rc.top) <br> *              Y       |                     |     P2 = (rc.right, rc.top) <br> *                      |                     |     P3 = (rc.left, rc.bottom) <br> *              |       |                     |     P4 = (rc.right, rc.bottom) <br> *              |       |                     | <br> *              |       |                     | <br> *              |       3) ------------------ ( 4 <br> *              | <br> *              0---------- X <br> * <br> *              NOTE:   Origin   = (P3x, P3y) <br> *                      X extent = P2x - P3x <br> *                      Y extent = P2y - P3y <br> * <br> * <br> */ <br> <br>STDAPI_(void) XformRectInPixelsToHimetric( <br>        HDC hDC, LPRECT lprcPix, LPRECT lprcHiMetric) <br>        { <br>        int     iXppli;     //Pixels per logical inch along width <br>        int     iYppli;     //Pixels per logical inch along height <br>        int     iXextInPix=(lprcPix-&gt;right-lprcPix-&gt;left); <br>        int     iYextInPix=(lprcPix-&gt;bottom-lprcPix-&gt;top); <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC || <br>            GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE || <br>            GetDeviceCaps(hDC, LOGPIXELSX) == 0) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iXppli = GetDeviceCaps (hDC, LOGPIXELSX); <br>        iYppli = GetDeviceCaps (hDC, LOGPIXELSY); <br> <br>        //We got pixel units, convert them to logical HIMETRIC along the display <br>        lprcHiMetric-&gt;right = MAP_PIX_TO_LOGHIM(iXextInPix, iXppli); <br>        lprcHiMetric-&gt;top   = MAP_PIX_TO_LOGHIM(iYextInPix, iYppli); <br> <br>        lprcHiMetric-&gt;left    = 0; <br>        lprcHiMetric-&gt;bottom  = 0; <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return; <br>        } <br> <br> <br> <br>STDAPI_(void) XformRectInHimetricToPixels( <br>        HDC hDC, LPRECT lprcHiMetric, LPRECT lprcPix) <br>        { <br>        int     iXppli;     //Pixels per logical inch along width <br>        int     iYppli;     //Pixels per logical inch along height <br>        int     iXextInHiMetric=(lprcHiMetric-&gt;right-lprcHiMetric-&gt;left); <br>        int     iYextInHiMetric=(lprcHiMetric-&gt;bottom-lprcHiMetric-&gt;top); <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC || <br>            GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE || <br>            GetDeviceCaps(hDC, LOGPIXELSX) == 0) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iXppli = GetDeviceCaps (hDC, LOGPIXELSX); <br>        iYppli = GetDeviceCaps (hDC, LOGPIXELSY); <br> <br>        //We got pixel units, convert them to logical HIMETRIC along the display <br>        lprcPix-&gt;right = MAP_LOGHIM_TO_PIX(iXextInHiMetric, iXppli); <br>        lprcPix-&gt;top   = MAP_LOGHIM_TO_PIX(iYextInHiMetric, iYppli); <br> <br>        lprcPix-&gt;left  = 0; <br>        lprcPix-&gt;bottom= 0; <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return; <br>        } <br> <br> <br> <br> <br>/* <br> * XformSizeInPixelsToHimetric <br> * XformSizeInHimetricToPixels <br> * <br> * Functions to convert a SIZEL structure (Size functions) or <br> * an int (Width functions) between a device coordinate system and <br> * logical HiMetric units. <br> * <br> * Parameters: <br> *  hDC             HDC providing reference to the pixel mapping.  If <br> *                  NULL, a screen DC is used. <br> * <br> *  Size Functions: <br> *  lpSizeSrc       LPSIZEL providing the structure to convert.  This <br> *                  contains pixels in XformSizeInPixelsToHimetric and <br> *                  logical HiMetric units in the complement function. <br> *  lpSizeDst       LPSIZEL providing the structure to receive converted <br> *                  units.  This contains pixels in <br> *                  XformSizeInPixelsToHimetric and logical HiMetric <br> *                  units in the complement function. <br> * <br> *  Width Functions: <br> *  iWidth          int containing the value to convert. <br> * <br> * Return Value: <br> *  Size Functions:     None <br> *  Width Functions:    Converted value of the input parameters. <br> * <br> * NOTE: <br> *  When displaying on the screen, Window apps display everything enlarged <br> *  from its actual size so that it is easier to read. For example, if an <br> *  app wants to display a 1in. horizontal line, that when printed is <br> *  actually a 1in. line on the printed page, then it will display the line <br> *  on the screen physically larger than 1in. This is described as a line <br> *  that is "logically" 1in. along the display width. Windows maintains as <br> *  part of the device-specific information about a given display device: <br> *      LOGPIXELSX -- no. of pixels per logical in along the display width <br> *      LOGPIXELSY -- no. of pixels per logical in along the display height <br> * <br> *  The following formula converts a distance in pixels into its equivalent <br> *  logical HIMETRIC units: <br> * <br> *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix) <br> *                       ------------------------------- <br> *                           PIXELS_PER_LOGICAL_IN <br> * <br> */ <br> <br>STDAPI_(void) XformSizeInPixelsToHimetric( <br>        HDC hDC, LPSIZEL lpSizeInPix, LPSIZEL lpSizeInHiMetric) <br>        { <br>        int     iXppli;     //Pixels per logical inch along width <br>        int     iYppli;     //Pixels per logical inch along height <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC || <br>            GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE || <br>            GetDeviceCaps(hDC, LOGPIXELSX) == 0) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iXppli = GetDeviceCaps (hDC, LOGPIXELSX); <br>        iYppli = GetDeviceCaps (hDC, LOGPIXELSY); <br> <br>        //We got pixel units, convert them to logical HIMETRIC along the display <br>        lpSizeInHiMetric-&gt;cx = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix-&gt;cx, iXppli); <br>        lpSizeInHiMetric-&gt;cy = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix-&gt;cy, iYppli); <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return; <br>        } <br> <br> <br>STDAPI_(void) XformSizeInHimetricToPixels( <br>        HDC hDC, LPSIZEL lpSizeInHiMetric, LPSIZEL lpSizeInPix) <br>        { <br>        int     iXppli;     //Pixels per logical inch along width <br>        int     iYppli;     //Pixels per logical inch along height <br>        BOOL    fSystemDC=FALSE; <br> <br>        if (NULL==hDC || <br>            GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE || <br>            GetDeviceCaps(hDC, LOGPIXELSX) == 0) <br>                { <br>                hDC=GetDC(NULL); <br>                fSystemDC=TRUE; <br>                } <br> <br>        iXppli = GetDeviceCaps (hDC, LOGPIXELSX); <br>        iYppli = GetDeviceCaps (hDC, LOGPIXELSY); <br> <br>        //We got logical HIMETRIC along the display, convert them to pixel units <br>        lpSizeInPix-&gt;cx = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric-&gt;cx, iXppli); <br>        lpSizeInPix-&gt;cy = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric-&gt;cy, iYppli); <br> <br>        if (fSystemDC) <br>                ReleaseDC(NULL, hDC); <br> <br>        return; <br>        } <br> <br> <br>#if defined( OBSOLETE ) <br>// This function has been converted to a macro <br> <br>/* AreRectsEqual <br>** ------------- <br>*/ <br>STDAPI_(BOOL) AreRectsEqual(LPRECT lprc1, LPRECT lprc2) <br>{ <br>        if ((lprc1-&gt;top == lprc2-&gt;top) &amp;&amp; <br>                (lprc1-&gt;left == lprc2-&gt;left) &amp;&amp; <br>                (lprc1-&gt;right == lprc2-&gt;right) &amp;&amp; <br>                (lprc1-&gt;bottom == lprc2-&gt;bottom)) <br>                return TRUE; <br> <br>        return FALSE; <br>} <br>#endif  // OBSOLETE <br> <br> <br>/* <br> * ParseCmdLine <br> * <br> * Parses the Windows command line which was passed to WinMain. <br> * This function determines if the -Embedding switch has been given. <br> * <br> */ <br> <br>STDAPI_(void) ParseCmdLine( <br>        LPSTR lpszLine, <br>        BOOL FAR* lpfEmbedFlag, <br>        LPSTR szFileName) <br>{ <br>        int i=0; <br>        char szBuf[256]; <br> <br>        if(lpfEmbedFlag) <br>                *lpfEmbedFlag = FALSE; <br>        szFileName[0]='\0';             // NULL string <br> <br>        // skip blanks <br>        while(isspace(*lpszLine)) lpszLine++; <br> <br>        if(!*lpszLine)   // No filename or options, so start a fresh document. <br>                return; <br> <br>        // Check for "-Embedding" or "/Embedding" and set fEmbedding. <br>        if(lpfEmbedFlag &amp;&amp; (*lpszLine == '-' || *lpszLine == '/')) { <br>                lpszLine++; <br>                lpszLine = GetWord(lpszLine, szBuf); <br>                *lpfEmbedFlag = !lstrcmp(szBuf, EMBEDDINGFLAG); <br>        } <br> <br>        // skip blanks <br>        while(isspace(*lpszLine)) lpszLine++; <br> <br>        // set szFileName to argument <br>        while(lpszLine[i]) { <br>                szFileName[i]=lpszLine[i]; <br>                i++; <br>        } <br>        szFileName[i]='\0'; <br>} <br> <br> <br>/* GetWord <br> * ------- <br> * <br> * LPSTR lpszSrc - Pointer to a source string <br> * LPSTR lpszDst - Pointer to destination buffer <br> * <br> * Will copy one space-terminated or null-terminated word from the source <br> * string to the destination buffer. <br> * returns: pointer to next character following the word. <br> */ <br>static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst) <br>{ <br>        while (*lpszSrc &amp;&amp; !isspace(*lpszSrc)) <br>                *lpszDst++ = *lpszSrc++; <br> <br>        *lpszDst = '\0'; <br>        return lpszSrc; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
