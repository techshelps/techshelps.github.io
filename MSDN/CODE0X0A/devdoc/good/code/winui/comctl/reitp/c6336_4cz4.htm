<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FRMTBAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6340"></a>FRMTBAR.C</h2>
<pre><code>/* <br> *frmtbar.c <br> * <br> *Implementation of a richedit format bar <br> * <br> */ <br> <br>#include "preinc.h" <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include &lt;richedit.h&gt; <br> <br>#include &lt;commctrl.h&gt; <br>#include "dbugit.h" <br> <br>#include "reitp.rh" <br>#include "frmtbar.h" <br> <br> <br>ASSERTDATA <br> <br>/* <br> *The current format state <br> */ <br>typedef struct tagFormatBarState <br>{ <br>HWNDhwndToolbar;// Toolbar <br>HWNDhwndName;// Font name combo <br>HWNDhwndSize;// Font size combo <br>HWNDhwndColor;// Font color combo <br> <br>HDChdc;// Our copy of the DC to use <br>INTcyPerInch;// Pixels per inch vertically <br> <br>HBRUSHhbrushWindow;// Common brushes <br>HBRUSHhbrushHighlight; <br>HBRUSHhbrushButtonFace; <br>COLORREFcrWindow;// Common colors <br>COLORREFcrHighlight; <br>COLORREFcrButtonFace; <br> <br>CHARFORMATcf;// The current char format <br>PARAFORMATpf;// The current paragraph format <br>DWORDdwCFMaskChange;// What changed <br> <br>LONGrglSize[128];// Possible font sizes <br>LONGclSize;// Number of font sizes <br>BOOLfTrueType;// TrueType flag <br> <br>BOOLfExpectChoice;// Flag that we want next CBN_* <br>BOOLfGiveUpFocus;// Flag that we are done <br>} FormatBarState; <br> <br>#definePfbsGetWindowPtr(_hwnd)\ <br>((FormatBarState *) GetWindowLong(_hwnd, 0)) <br>#defineSetWindowPtr(_hwnd, _p)SetWindowLong(_hwnd, 0, (LONG) _p) <br> <br>#defineGetFormatBarField(_hwnd, _fld)(PfbsGetWindowPtr(_hwnd)-&gt;_fld) <br> <br>/* <br> *Range of sizes we'll show user for TrueType fonts <br> */ <br>#definelTrueTypeSizeMin4 <br>#definelTrueTypeSizeMac127 <br> <br>static TCHARszFormatBar[] = FORMATBARCLASSNAME; <br>static TCHARszToolbar[] = TOOLBARCLASSNAME; <br>static TCHARszComboBox[] = "ComboBox"; <br> <br>/* <br> *Our own private messages from the combobox edit control to the format bar <br> *letting up know about important keyevents <br> *wParam =window ID of the combobox owning the edit control <br> *lParam =window handle of the combobox owning the edit control <br> *returns: none <br> */ <br>#defineWM_TAB( WM_USER + 1 ) <br>#defineWM_RETURN( WM_USER + 2 ) <br>#defineWM_ESCAPE( WM_USER + 3 ) <br> <br>#definecxDownButton16 <br>#define cxName128 + cxDownButton <br>#define cxSize40 + cxDownButton <br>#define cxColor24 + cxDownButton <br>#definecxGap1(8 + cxName + 8 + cxSize + 8) <br>#definecxGap2(cxColor + 8) <br> <br>#defineCFM_MASKS( CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR ) <br>#defineCFE_EFFECTS( CFE_BOLD | CFE_ITALIC | CFE_UNDERLINE | \ <br>CFE_AUTOCOLOR ) <br> <br>#defineINITIAL_COLOR0x40000000 <br> <br> <br>static TBBUTTON rgtbbutton[] = <br>{ <br>{ cxGap1, 0L, TBSTATE_ENABLED, TBSTYLE_SEP, 0, 0, 0L, -1}, <br> <br>{ tbBold, TBI_Bold, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0, 0L, -1}, <br>{ tbItalic, TBI_Italic, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0, 0L, -1},  <br>{ tbUnderline, TBI_Underline, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0, 0L, -1},  <br>{ cxGap2, 0L, TBSTATE_ENABLED, TBSTYLE_SEP, 0, 0, 0L, -1}, <br> <br>{ tbBullet, TBI_Bullet, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0, 0L, -1}, <br>{ 0, 0L, TBSTATE_ENABLED, TBSTYLE_SEP, 0, 0, 0L, -1}, <br> <br>{ tbDecreaseIndent, TBI_DecreaseIndent, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0L, -1}, <br>{ tbIncreaseIndent, TBI_IncreaseIndent, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0L, -1}, <br>{ 0, 0L, TBSTATE_ENABLED, TBSTYLE_SEP, 0, 0, 0L, -1}, <br> <br>{ tbLeft, TBI_Left, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, 0L, -1}, <br>{ tbCenter, TBI_Center, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, 0L, -1},  <br>{ tbRight, TBI_Right, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, 0L, -1},  <br>{ 0, 0L, TBSTATE_ENABLED, TBSTYLE_SEP, 0, 0, 0L, -1}, <br>}; <br>#define ctbbutton(sizeof(rgtbbutton) / sizeof(TBBUTTON)) <br> <br>static DWORDrgdwCFEffect[]={ CFE_BOLD, CFE_ITALIC, CFE_UNDERLINE }; <br>static WORDrgwPFAlignment[]={ PFA_LEFT, PFA_CENTER, PFA_RIGHT }; <br> <br>// Hold the old wndproc's ! <br>//$ REVIEW: Make this per instance ? <br>static WNDPROCpfnEditWndProc = NULL; <br>static WNDPROCpfnComboBoxWndProc = NULL; <br>static WNDPROCpfnToolbarWndProc = NULL; <br> <br>/* <br> *Color table for dropdown on toolbar.  Matches COMMDLG colors <br> *exactly. <br> */ <br>static DWORD rgrgbColors[] = { <br>RGB(  0,   0, 0),  /* Black*/ <br>RGB(128,   0, 0),  /* Dark red*/ <br>RGB(  0, 128, 0),  /* Dark green*/ <br>RGB(128, 128, 0),  /* Dark yellow*/ <br>RGB(  0,   0, 128),/* Dark blue*/ <br>RGB(128,   0, 128),/* Dark purple*/ <br>RGB(  0, 128, 128),/* Dark aqua*/ <br>RGB(128, 128, 128),/* Dark grey*/ <br>RGB(192, 192, 192),/* Light grey*/ <br>RGB(255,   0, 0),  /* Light red*/ <br>RGB(  0, 255, 0),  /* Light green*/ <br>RGB(255, 255, 0),  /* Light yellow */ <br>RGB(  0,   0, 255),/* Light blue*/ <br>RGB(255,   0, 255),/* Light purple */ <br>RGB(  0, 255, 255),/* Light aqua*/ <br>RGB(255, 255, 255),/* White*/ <br>}; <br> <br>const INT crgbColorsMax = sizeof(rgrgbColors) / sizeof(rgrgbColors[0]); <br> <br>#defineTraceCharFormat(_sz, _pcf) <br> <br> <br>/* <br> *UpdateBrush <br> * <br> *Purpose: <br> *Syncs up the brushes with the known color scheme as needed <br> * <br> *Arguments: <br> *hwndHandle of the format bar <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID UpdateBrush(HBRUSH * phbrush, COLORREF * pcr, INT nIndex) <br>{ <br>COLORREFcr; <br> <br>if (((cr = GetSysColor(nIndex)) != *pcr) || <br>!*phbrush) <br>{ <br>if (*phbrush) <br>DeleteObject(*phbrush); <br>*phbrush = CreateSolidBrush(*pcr = cr); <br>} <br>} <br> <br> <br>/* <br> *UpdateBrushes <br> * <br> *Purpose: <br> *Syncs up the brushes with the known color scheme as needed <br> * <br> *Arguments: <br> *hwndHandle of the format bar <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID UpdateBrushes(HWND hwnd) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br> <br>UpdateBrush(&amp;pfbs-&gt;hbrushWindow, &amp;pfbs-&gt;crWindow, COLOR_WINDOW); <br>UpdateBrush(&amp;pfbs-&gt;hbrushHighlight, &amp;pfbs-&gt;crHighlight, COLOR_HIGHLIGHT); <br>UpdateBrush(&amp;pfbs-&gt;hbrushButtonFace, &amp;pfbs-&gt;crButtonFace, COLOR_BTNFACE); <br>} <br> <br> <br>/* <br> *LFBEditWndProc <br> * <br> *Purpose: <br> *Take care of handling the notifications from the combobox controls we <br> *get for the format bar <br> * <br> *Arguments: <br> *hwnd <br> *wMsg <br> *wParam <br> *lParam <br> * <br> *Returns: <br> *LRESULT <br> */ <br>LRESULT CALLBACK LFBEditWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, <br>LPARAM lParam) <br>{ <br>switch (wMsg) <br>{ <br>case WM_KEYDOWN: <br>{ <br>HWNDhwndCombo = GetParent(hwnd); <br>HWNDhwndFormatBar = GetParent(GetParent(hwndCombo)); <br>INTnID = GetWindowID(hwndCombo); <br> <br>switch(wParam) <br>{ <br> <br>case VK_ESCAPE: <br>SendMessage(hwndFormatBar, WM_ESCAPE, nID, <br>(LPARAM) (LPTSTR) hwndCombo); <br> <br>case VK_TAB: <br>case VK_RETURN: <br>return 0; <br>} <br>} <br>break; <br> <br>case WM_CHAR: <br>{ <br>HWNDhwndCombo = GetParent(hwnd); <br>HWNDhwndFormatBar = GetParent(GetParent(hwndCombo)); <br>INTnID = GetWindowID(hwndCombo); <br> <br>switch(wParam) <br>{ <br>case VK_RETURN: <br>SendMessage(hwndFormatBar, WM_RETURN, nID, <br>(LPARAM) (LPTSTR) hwndCombo); <br>return 0; <br> <br>case VK_TAB: <br>SendMessage(hwndFormatBar, WM_TAB, nID, <br>(LPARAM) (LPTSTR) hwndCombo); <br>return 0; <br> <br>   case VK_ESCAPE: <br>return 0; <br>} <br>} <br>break; <br> <br>case WM_KEYUP: <br>switch (wParam) <br>{ <br>case VK_RETURN: <br>case VK_TAB: <br>case VK_ESCAPE: <br>return 0; <br>} <br>break; <br>} <br> <br>return CallWindowProc(pfnEditWndProc, hwnd, wMsg, wParam, lParam); <br>} <br> <br> <br>/* <br> *LFBComboBoxWndProc <br> * <br> *Purpose: <br> *Take care of handling the notifications from the combobox controls we <br> *get for the format bar <br> * <br> *Arguments: <br> *hwnd <br> *wMsg <br> *wParam <br> *lParam <br> * <br> *Returns: <br> *LRESULT <br> */ <br>LRESULT CALLBACK LFBComboBoxWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, <br>LPARAM lParam) <br>{ <br>switch (wMsg) <br>{ <br>case WM_KEYDOWN: <br>{ <br>HWNDhwndFormatBar = GetParent(GetParent(hwnd)); <br>INTnID = GetWindowID(hwnd); <br> <br>switch(wParam) <br>{ <br>case VK_TAB: <br>SendMessage(hwndFormatBar, WM_TAB, nID, <br>(LPARAM) (LPTSTR) hwnd); <br>return 0; <br> <br>case VK_RETURN: <br>SendMessage(hwndFormatBar, WM_RETURN, nID, <br>(LPARAM) (LPTSTR) hwnd); <br>return 0; <br> <br>case VK_ESCAPE: <br>SendMessage(hwndFormatBar, WM_ESCAPE, nID, <br>(LPARAM) (LPTSTR) hwnd); <br>return 0; <br>} <br>} <br>break; <br> <br>case WM_KEYUP: <br>case WM_CHAR: <br>switch(wParam) <br>{ <br>case VK_TAB: <br>case VK_RETURN: <br>case VK_ESCAPE: <br>return 0; <br>} <br>break; <br>} <br> <br>return CallWindowProc(pfnComboBoxWndProc, hwnd, wMsg, wParam, lParam); <br>} <br> <br> <br>/* <br> *LFBToolbarWndProc <br> * <br> *Purpose: <br> *Take care of handling the notifications from the combobox controls we <br> *get for the format bar <br> * <br> *Arguments: <br> *hwnd <br> *wMsg <br> *wParam <br> *lParam <br> * <br> *Returns: <br> *LRESULT <br> */ <br> <br>LRESULT CALLBACK LFBToolbarWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, <br>LPARAM lParam) <br>{ <br>switch (wMsg) <br>{ <br>case WM_CTLCOLORLISTBOX: <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(GetParent(hwnd)); <br> <br>// Peek at the current information <br>UpdateBrush(&amp;pfbs-&gt;hbrushButtonFace, &amp;pfbs-&gt;crButtonFace, <br>COLOR_BTNFACE); <br>return (LRESULT) (LPTSTR) pfbs-&gt;hbrushButtonFace; <br>} <br>break; <br>} <br> <br>return CallWindowProc(pfnToolbarWndProc, hwnd, wMsg, wParam, lParam); <br>} <br> <br> <br>/* <br> *NEnumFontNameProc <br> * <br> *Purpose: <br> *The callback for EnumFontFamilies which fills the font names combobox <br> *with the available fonts <br> * <br> *Arguments: <br> * <br> *Returns: <br> *Non-zero as long a font name can be inserted into the combobox <br> */ <br>INT CALLBACK NEnumFontNameProc(LOGFONT * plf, TEXTMETRIC * ptm, <br>INT nFontType, LPARAM lParam) <br>{ <br>LRESULT lr; <br>DWORDdw; <br> <br>lr = SendMessage((HWND) lParam, CB_ADDSTRING, 0, (LPARAM) plf-&gt;lfFaceName); <br>if (!(lr == CB_ERR || lr == CB_ERRSPACE)) <br>{ <br>Assert (!(plf-&gt;lfCharSet &amp; 0xFFFFFF00)); <br>Assert (!(plf-&gt;lfPitchAndFamily &amp; 0xFFFFFF00)); <br>Assert (!(nFontType &amp; 0xFFFF0000)); <br>dw = plf-&gt;lfCharSet &amp; 0xFF; <br>dw &lt;&lt;= 8; <br>dw |= plf-&gt;lfPitchAndFamily &amp; 0xFF; <br>dw &lt;&lt;= 16; <br>dw |= nFontType &amp; 0xFFFF; <br>SendMessage((HWND) lParam, CB_SETITEMDATA, LOWORD(lr), (LPARAM) dw); <br>} <br>return !(lr == CB_ERR || lr == CB_ERRSPACE); <br>} <br> <br> <br>/* <br> *FillNames <br> * <br> *Purpose: <br> *Fills the font name combobox with the names of the available fonts <br> * <br> *Arguments: <br> *hwndHandle of the names combobox <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL void FillNames(HWND hwnd) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>HDChdc = pfbs-&gt;hdc; <br>HWNDhwndName = pfbs-&gt;hwndName; <br> <br>// Empty the current list <br>SendMessage(hwndName, CB_RESETCONTENT, 0, 0); <br> <br>// Ask for all the font families <br>EnumFontFamilies((HDC) hdc, (LPTSTR) NULL, <br> (FONTENUMPROC) NEnumFontNameProc, <br> (LPARAM) (LPTSTR) hwndName); <br>} <br> <br> <br> <br>/* <br> *FInsertSize <br> * <br> *Purpose: <br> *Inserts a font size entry into the array. Takes care of the necessary <br> *conversion from logical units to points size. The array is kept in <br> *ascending order. <br> * <br> *Arguments: <br> *lSizeThe font size in logical units <br> *pfbsThe current format bar state <br> *fPointsFlag whether the size is in points or not <br> * <br> *Returns: <br> *TRUE if the font size was successfully added to the array, or was <br> *present. <br> */ <br>BOOL FInsertSize(LONG lSize, FormatBarState * pfbs, BOOL fPoints) <br>{ <br>LONGclLeft = pfbs-&gt;clSize; <br>LONG *plSize = pfbs-&gt;rglSize; <br> <br>if (clLeft &gt;= sizeof(pfbs-&gt;rglSize) / sizeof(LONG)) <br>return FALSE; <br> <br>// Convert to point sizes <br>if (!fPoints) <br>lSize = MulDiv((INT) lSize, 72, pfbs-&gt;cyPerInch); <br> <br>while (clLeft &gt; 0 &amp;&amp; *plSize &lt; lSize) <br>{ <br>++plSize; <br>--clLeft; <br>} <br>if (clLeft &amp;&amp; *plSize == lSize) <br>; <br>else <br>{ <br>if (clLeft) <br>{ <br>MoveMemory(plSize + 1, plSize, clLeft * sizeof(LONG)); <br>} <br>*plSize = lSize; <br>++pfbs-&gt;clSize; <br>} <br>return TRUE; <br>} <br> <br> <br>/* <br> *NEnumFontSizeProc <br> * <br> *Purpose: <br> *The callback for EnumFontFamilies which fills the font names combobox <br> *with the available fonts <br> * <br> *Arguments: <br> * <br> *Returns: <br> *Non-zero as long a font name can be inserted into the combobox <br> */ <br>INT CALLBACK NEnumFontSizeProc(LOGFONT * plf, TEXTMETRIC * ptm, <br>INT nFontType, LPARAM lParam) <br>{ <br>FormatBarState *pfbs = (FormatBarState *) lParam; <br> <br>if (ptm-&gt;tmPitchAndFamily &amp; TMPF_TRUETYPE) <br>pfbs-&gt;fTrueType |= TRUE; <br>return FInsertSize(ptm-&gt;tmHeight - ptm-&gt;tmInternalLeading, pfbs, FALSE); <br>} <br> <br> <br>/* <br> *FFillSizes <br> * <br> *Purpose: <br> *Fills the font name combobox with the names of the available fonts <br> * <br> *Arguments: <br> *hwndHandle of the names combobox <br> * <br> *Returns: <br> *TRUE if successful <br> */ <br>LOCAL BOOL FFillSizes(HWND hwnd) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>HDChdc = pfbs-&gt;hdc; <br>HWNDhwndSize = pfbs-&gt;hwndSize; <br>TCHAR *pszFaceName = pfbs-&gt;cf.szFaceName; <br>LONGilSize; <br>LONGlCurrSize; <br>LONGilMatch; <br>LONG *plSize  = pfbs-&gt;rglSize; <br>TCHARszT[10]; <br>LRESULTlr; <br>BOOLfSuccess = FALSE; <br> <br>// Empty the current list <br>SendMessage(hwndSize, CB_RESETCONTENT, 0, 0); <br>pfbs-&gt;clSize = 0; <br>pfbs-&gt;fTrueType = FALSE; <br> <br>// Ask for all the font sizes for the given font <br>EnumFontFamilies((HDC) hdc, pszFaceName, <br> (FONTENUMPROC) NEnumFontSizeProc, (LPARAM) pfbs); <br> <br>// If we got a TrueType font, just fill in the array with our sizes <br>if (pfbs-&gt;fTrueType) <br>{ <br>ilSize = lTrueTypeSizeMin; <br>while (ilSize &lt; lTrueTypeSizeMac) <br>*plSize++ = ilSize++; <br>*plSize = ilSize; <br>pfbs-&gt;clSize = lTrueTypeSizeMac - lTrueTypeSizeMin + 1; <br>} <br>// Save ourselves some dereferencing and covert to points <br>lCurrSize = MulDiv((INT) pfbs-&gt;cf.yHeight, 72, 1440); <br> <br>// Now go through our entries and put them into our listbox <br>plSize  = pfbs-&gt;rglSize; <br>ilMatch = -1; <br>for (ilSize = 0; ilSize &lt; pfbs-&gt;clSize; ++ilSize, ++plSize) <br>{ <br>wsprintf(szT, "%ld", *plSize); <br>lr = SendMessage(hwndSize, CB_ADDSTRING, 0, (LPARAM) szT); <br>AssertSz(!(lr == CB_ERR || lr == CB_ERRSPACE), "Can't add more sizes"); <br>if (lr == CB_ERR || lr == CB_ERRSPACE) <br>goto CleanUp; <br> <br>// Try to find out which element will become our current selection <br>if (*plSize == lCurrSize) <br>ilMatch = ilSize; <br>} <br> <br>// Set our current selection <br>if (ilMatch &gt;= 0) <br>SendMessage(hwndSize, CB_SETCURSEL, (WPARAM) ilMatch, 0); <br>else <br>{ <br>if (lCurrSize) <br>wsprintf(szT, "%ld", lCurrSize); <br>else <br>szT[0] = 0; <br>SetWindowText(hwndSize, szT); <br>} <br>fSuccess = TRUE; <br> <br>CleanUp: <br>return fSuccess; <br>} <br> <br> <br>/* <br> *FillColors <br> * <br> *Purpose: <br> *Fills the font colors combobox with samples of the available colors <br> * <br> *Arguments: <br> *hwndHandle of the names combobox <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL void FillColors(HWND hwnd) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>HWNDhwndColor = pfbs-&gt;hwndColor; <br>INTilMatch = -1; <br>LRESULTlr; <br>INTicr; <br>DWORD *pdw; <br> <br>// Empty the current list <br>SendMessage(hwndColor, CB_RESETCONTENT, 0, 0); <br> <br>for (icr = 0, pdw = rgrgbColors; icr &lt; crgbColorsMax; ++icr, ++pdw) <br>{ <br>lr = SendMessage(hwndColor, CB_ADDSTRING, 0, (LPARAM) *pdw); <br>if (lr == CB_ERR || lr == CB_ERRSPACE) <br>{ <br>TraceError("FillColors: No more room for colors", -1); <br>break; <br>} <br> <br>if (*pdw == pfbs-&gt;cf.crTextColor) <br>ilMatch = icr; <br>} <br> <br>SendMessage(hwndColor, CB_SETCURSEL, (WPARAM) ilMatch &gt; 0 ? ilMatch : 0, 0); <br>} <br> <br> <br>/* <br> *FB_OnNcCreate <br> * <br> *Purpose: <br> *We want to draw our own colors for the colors combobox <br> * <br> *Arguments: <br> *hwndThe window <br> *pmisPointer to a MEASUREITEMSTRUCT to be filled out <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL BOOL FB_OnNcCreate(HWND hwnd, CREATESTRUCT * pcs) <br>{ <br>RECTrc; <br>INTcyButton; <br>INTcyList; <br>INTyPos; <br>INTxPos; <br>HFONThfont; <br>FormatBarState *pfbs = NULL; <br>HINSTANCEhinst = pcs-&gt;hInstance; <br>WNDPROC pfnWndProcT; <br>POINTpt = { 1, 1 }; <br>HWNDhwndT; <br> <br>// Tell format bar where to find it's state information <br>pfbs = (FormatBarState *) GlobalAllocPtr(GHND, sizeof(FormatBarState)); <br>if (!pfbs) <br>goto ErrorNoState; <br>SetWindowPtr(hwnd, pfbs); <br>AssertSz(PfbsGetWindowPtr(hwnd) == pfbs, "We didn't write it!"); <br> <br>// Get a few brushes that we'll be using all the time <br>UpdateBrushes(hwnd); <br> <br>// Create the toolbar <br>pfbs-&gt;hwndToolbar = CreateToolbarEx(hwnd, CCS_TOP | WS_CHILD, <br>0, tbFormatBarMax, hinst, <br>BMP_FormatBar, rgtbbutton, ctbbutton, <br>16, 16, 16, 16, sizeof(TBBUTTON)); <br> <br>if (!pfbs-&gt;hwndToolbar) <br>goto ErrorNoToolbar; <br> <br>// Subclass the toolbar <br>pfnWndProcT = (WNDPROC) SetWindowLong(pfbs-&gt;hwndToolbar, GWL_WNDPROC, <br>(LONG) LFBToolbarWndProc); <br> <br>// If we don't know what the global ToolbarWndProc is, save it <br>if (!pfnToolbarWndProc) <br>pfnToolbarWndProc = pfnWndProcT; <br> <br>// Determine how tall the buttons are so we can size our other controls <br>// accordingly <br>SendMessage(pfbs-&gt;hwndToolbar, TB_GETITEMRECT, 1, (LPARAM) &amp;rc); <br>cyButton = rc.bottom - rc.top + 1; <br> <br>// Determine how tall the toolbar is so that we can center the comboboxes <br>GetClientRect(pfbs-&gt;hwndToolbar, &amp;rc); <br>yPos = (rc.bottom - rc.top + 1 - cyButton) / 2 + 1; <br> <br>// Let's make the comboboxes dropdown about 5 times the height <br>cyList = 5 * cyButton; <br> <br>// Get the font to use for the comboboxes <br>hfont = (HFONT) SendMessage(pfbs-&gt;hwndToolbar, WM_GETFONT, 0, 0); <br> <br>// Now create the other format bar controls <br> <br>// The name <br>xPos = 8; <br>pfbs-&gt;hwndName = CreateWindow(szComboBox, NULL, <br>WS_CHILD | WS_VSCROLL | CBS_DROPDOWN | <br>CBS_SORT | CBS_HASSTRINGS | WS_VISIBLE, <br>xPos, yPos, cxName, cyList, <br>pfbs-&gt;hwndToolbar, (HMENU) TBI_Name, <br>hinst, NULL); <br>if (!pfbs-&gt;hwndName) <br>goto ErrorNoName; <br>SetWindowFont(pfbs-&gt;hwndName, hfont, TRUE); <br>xPos += cxName + 8; <br> <br> <br>// The Size <br>pfbs-&gt;hwndSize = CreateWindow(szComboBox, NULL, <br>WS_CHILD | WS_VSCROLL | CBS_DROPDOWN | <br>WS_VISIBLE, <br>xPos, yPos, cxSize, cyList, <br>pfbs-&gt;hwndToolbar, (HMENU) TBI_Size, <br>hinst, NULL); <br>if (!pfbs-&gt;hwndSize) <br>goto ErrorNoSize; <br>SetWindowFont(pfbs-&gt;hwndSize, hfont, TRUE); <br> <br>// The color <br>//$ REVIEW: Magic number <br>SendMessage(pfbs-&gt;hwndToolbar, TB_GETITEMRECT, 3, (LPARAM) &amp;rc); <br>pfbs-&gt;hwndColor = CreateWindow(szComboBox, NULL, <br>WS_CHILD | WS_VSCROLL | CBS_DROPDOWNLIST | <br>CBS_OWNERDRAWFIXED | WS_VISIBLE, <br>rc.right, yPos - 1, cxColor, cyList, <br>pfbs-&gt;hwndToolbar, (HMENU) TBI_Color, <br>hinst, NULL); <br>if (!pfbs-&gt;hwndColor) <br>goto ErrorNoColor; <br>SetWindowFont(pfbs-&gt;hwndColor, hfont, TRUE); <br> <br>// Set the initial color to black so it won't be redrawn. <br>pfbs-&gt;cf.dwMask |= INITIAL_COLOR; <br> <br>// Subclass the comboboxes' edit controls <br> <br>// Do the name first <br>hwndT = ChildWindowFromPoint(pfbs-&gt;hwndName, pt); <br>pfnWndProcT = (WNDPROC) SetWindowLong(hwndT, GWL_WNDPROC, <br>(LONG) LFBEditWndProc); <br> <br>// If we don't know what the global EditWndProc is, save it <br>if (!pfnEditWndProc) <br>pfnEditWndProc = pfnWndProcT; <br> <br>// Next the size <br>hwndT = ChildWindowFromPoint(pfbs-&gt;hwndSize, pt); <br>(WNDPROC) SetWindowLong(hwndT, GWL_WNDPROC, (LONG) LFBEditWndProc); <br> <br>// Lastly the color <br>pfnWndProcT = (WNDPROC) SetWindowLong(pfbs-&gt;hwndColor, GWL_WNDPROC, <br>(LONG) LFBComboBoxWndProc); <br> <br>// If we don't know what the global ComboBoxWndProc is, save it <br>if (!pfnComboBoxWndProc) <br>pfnComboBoxWndProc = pfnWndProcT; <br> <br>// Create a copy of the DC that the user gave up to play with <br>if(pcs-&gt;lpCreateParams) <br>{ <br>HDC *phdc = (HDC *) pcs-&gt;lpCreateParams; <br> <br>pfbs-&gt;hdc = CreateCompatibleDC(*phdc); <br>} <br>else <br>{ <br>HDC hdc = GetDC(pcs-&gt;hwndParent); <br> <br>pfbs-&gt;hdc = CreateCompatibleDC(hdc); <br>ReleaseDC(pcs-&gt;hwndParent, hdc); <br>} <br> <br>if (!pfbs-&gt;hdc) <br>goto ErrorNoColor; <br> <br>// Get the number of pixels per inch vertically so we can do point sizes <br>pfbs-&gt;cyPerInch = GetDeviceCaps(pfbs-&gt;hdc, LOGPIXELSY); <br> <br>// Load up the names of the fonts and colors <br>FillNames(hwnd); <br>FillColors(hwnd); <br>// Continue creating <br>return TRUE; <br> <br>ErrorNoColor: <br>DestroyWindow(pfbs-&gt;hwndSize); <br>pfbs-&gt;hwndSize = NULL; <br> <br>ErrorNoSize: <br>DestroyWindow(pfbs-&gt;hwndName); <br>pfbs-&gt;hwndName = NULL; <br> <br>ErrorNoName: <br>DestroyWindow(pfbs-&gt;hwndToolbar); <br>pfbs-&gt;hwndToolbar = NULL; <br> <br>ErrorNoToolbar: <br>if (pfbs) <br>GlobalFreePtr(pfbs); <br> <br>ErrorNoState: <br>return FALSE; <br>} <br> <br> <br>/* <br> *FB_OnMeasureItem <br> * <br> *Purpose: <br> *We want to draw our own colors for the colors combobox <br> * <br> *Arguments: <br> *hwndThe window <br> *pmisPointer to a MEASUREITEMSTRUCT to be filled out <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL void FB_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * pmis) <br>{ <br>switch (pmis-&gt;CtlID) <br>{ <br>case TBI_Color: <br>pmis-&gt;itemWidth = 128; <br>pmis-&gt;itemHeight = 16; <br>break; <br>default: <br>TraceError("Don't know anything about CtlID", -1); <br>break; <br>} <br>} <br> <br> <br>/* <br> *FB_OnDrawItem <br> * <br> *Purpose: <br> *We want to drawn our own colors for our color combobox <br> * <br> *Arguments: <br> *hwndThe window <br> *pdisPointer to a DRAWITEMSTRUCT to be filled out <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL void FB_OnDrawItem(HWND hwnd, DRAWITEMSTRUCT * pdis) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>HDChdc = pdis-&gt;hDC; <br>RECTrc; <br>HBRUSHhbrush; <br>COLORREFcr = (COLORREF) pdis-&gt;itemData; <br>INTnIter = 2; <br> <br>// As far as we know we have only one owner drawn control <br>AssertSz(pdis-&gt;CtlType == ODT_COMBOBOX, "Know only comboboxes"); <br>if (pdis-&gt;CtlID != TBI_Color) <br>return; <br> <br>// NULL object wanted ? <br>if (pdis-&gt;itemData == -1) <br>goto HandleFocus; <br> <br>switch (pdis-&gt;itemAction) <br>{ <br>case ODA_DRAWENTIRE: <br>rc = pdis-&gt;rcItem; <br>InflateRect(&amp;rc, -3, -3); <br>hbrush = CreateSolidBrush((COLORREF)cr); <br>FillRect(hdc, &amp;rc, hbrush); <br>DeleteObject(hbrush); <br>FrameRect(hdc, &amp;rc, GetStockObject(BLACK_BRUSH)); <br> <br>// *** FALL THROUGH *** <br> <br>case ODA_SELECT: <br>rc = pdis-&gt;rcItem; <br>if (pdis-&gt;itemState &amp; ODS_SELECTED) <br>hbrush = pfbs-&gt;hbrushHighlight; <br>else <br>hbrush = pfbs-&gt;hbrushWindow; <br>while (nIter--) <br>{ <br>InflateRect(&amp;rc, -1, -1); <br>FrameRect(hdc, &amp;rc, hbrush); <br>} <br> <br>if (pdis-&gt;itemAction != ODA_DRAWENTIRE) <br>break; <br> <br>// *** FALL THROUGH *** <br> <br>HandleFocus: <br>case ODA_FOCUS: <br>if (pdis-&gt;itemState &amp; ODS_FOCUS) <br>hbrush = pfbs-&gt;hbrushHighlight; <br>else <br>hbrush = pdis-&gt;itemData == -1 ? pfbs-&gt;hbrushButtonFace : <br>pfbs-&gt;hbrushWindow; <br>FrameRect(hdc, &amp;pdis-&gt;rcItem, hbrush); <br>break; <br>} <br> <br>} <br> <br> <br>/* <br> *PaintName <br> * <br> *Purpose: <br> *Paint the current name <br> * <br> *Arguments: <br> *pfbsThe current format bar state <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID PaintName(FormatBarState * pfbs) <br>{ <br>LONGilFound; <br> <br>TraceCharFormat("PaintName", &amp;pfbs-&gt;cf); <br>if (pfbs-&gt;cf.dwMask &amp; CFM_FACE) <br>{ <br>ilFound = SendMessage(pfbs-&gt;hwndName, CB_FINDSTRING, 0, <br>(LPARAM) pfbs-&gt;cf.szFaceName); <br>SendMessage(pfbs-&gt;hwndName, CB_SETCURSEL, (WPARAM) ilFound, 0); <br>if (ilFound == CB_ERR) <br>SetWindowText(pfbs-&gt;hwndName, pfbs-&gt;cf.szFaceName); <br>} <br>else <br>SetWindowText(pfbs-&gt;hwndName, TEXT("")); <br> <br>} <br> <br> <br>/* <br> *PaintSize <br> * <br> *Purpose: <br> *Paint the current size <br> * <br> *Arguments: <br> *pfbsThe current format bar state <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID PaintSize(FormatBarState * pfbs) <br>{ <br>LONGlSize = MulDiv((INT) pfbs-&gt;cf.yHeight, 72, 1440); <br>LONGilFound; <br>TCHARszT[10]; <br> <br>TraceCharFormat("PaintSize", &amp;pfbs-&gt;cf); <br>szT[0] = 0; <br>if (lSize &gt; 0 &amp;&amp; (pfbs-&gt;cf.dwMask &amp; CFM_SIZE)) <br>wsprintf(szT, "%ld", lSize); <br>ilFound = SendMessage(pfbs-&gt;hwndSize, CB_FINDSTRINGEXACT, 0, <br>(LPARAM) szT); <br>SendMessage(pfbs-&gt;hwndSize, CB_SETCURSEL, (WPARAM) ilFound, 0); <br>SetWindowText(pfbs-&gt;hwndSize, szT); <br>} <br> <br> <br>/* <br> *PaintColor <br> * <br> *Purpose: <br> *Paint the current color <br> * <br> *Arguments: <br> *pfbsThe current format bar state <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID PaintColor(FormatBarState * pfbs) <br>{ <br>LONGilFound = -1; <br>COLORREFcrTextColor = pfbs-&gt;cf.crTextColor; <br> <br>//$ FUTURE: Handle autocolor <br> <br>// If color isn't known, choose white <br>TraceCharFormat("PaintColor", &amp;pfbs-&gt;cf); <br>if (pfbs-&gt;cf.dwMask &amp; CFM_COLOR) <br>{ <br>ilFound = SendMessage(pfbs-&gt;hwndColor, CB_FINDSTRINGEXACT, 0, <br>(LPARAM) crTextColor); <br>if (ilFound &lt; 0) <br>{ <br>// Not found, add a new color <br>ilFound = SendMessage(pfbs-&gt;hwndColor, CB_ADDSTRING, 0, <br>(LPARAM) crTextColor); <br>} <br>} <br>SendMessage(pfbs-&gt;hwndColor, CB_SETCURSEL, (WPARAM) ilFound, 0); <br>} <br> <br> <br>/* <br> *PaintEffects <br> * <br> *Purpose: <br> *Paint the current effects <br> * <br> *Arguments: <br> *pfbsThe current format bar state <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID PaintEffects(FormatBarState * pfbs) <br>{ <br>HWNDhwndToolbar = pfbs-&gt;hwndToolbar; <br>DWORDdwMask = pfbs-&gt;cf.dwMask; <br>DWORDdwEffects = pfbs-&gt;cf.dwEffects; <br>BOOLfEffect; <br>BOOLfMask; <br>INTnID; <br> <br>TraceCharFormat("PaintEffects", &amp;pfbs-&gt;cf); <br>for (nID = TBI_Bold; nID &lt;= TBI_Underline; nID++) <br>{ <br>fMask = dwMask &amp; rgdwCFEffect[nID - TBI_Bold] ? TRUE : FALSE; <br>fEffect = dwEffects &amp; rgdwCFEffect[nID - TBI_Bold] ? TRUE : FALSE; <br>#ifdef LIKE_WORD2 <br>// Act like Word <br>SendMessage(hwndToolbar, TB_CHECKBUTTON, nID, MAKELONG(fEffect, 0)); <br>SendMessage(hwndToolbar, TB_INDETERMINATE, nID, MAKELONG(!fMask, 0)); <br>#elif defined(LIKE_T3) <br>// Act like T3 <br>SendMessage(hwndToolbar, TB_CHECKBUTTON, nID, <br>MAKELONG(fEffect &amp;&amp; fMask, 0)); <br>#else <br>//$ Raid 2375: Show the user what is actually going to happen <br>SendMessage(hwndToolbar, TB_CHECKBUTTON, nID, MAKELONG(fEffect, 0)); <br>#endif <br>} <br> <br>} <br> <br> <br>/* <br> *PaintAlignment <br> * <br> *Purpose: <br> *Paint the current alignment <br> * <br> *Arguments: <br> *pfbsThe current format bar state <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID PaintAlignment(FormatBarState * pfbs) <br>{ <br>HWNDhwndToolbar = pfbs-&gt;hwndToolbar; <br>DWORDwAlignment = pfbs-&gt;pf.wAlignment; <br>INTnID; <br> <br>if (pfbs-&gt;pf.dwMask &amp; PFM_ALIGNMENT) <br>{ <br>#ifdef LIKE_WORD <br>// Make all the buttons active <br>for (nID = TBI_Left; nID &lt;= TBI_Right; nID++) <br>SendMessage(hwndToolbar, TB_INDETERMINATE, nID, <br>MAKELONG(FALSE, 0)); <br>#endif <br>// And press down one of them <br>switch (wAlignment) <br>{ <br>case PFA_CENTER: <br>nID = TBI_Center; <br>break; <br> <br>case PFA_RIGHT: <br>nID = TBI_Right; <br>break; <br> <br>case PFA_LEFT: <br>default: <br>nID = TBI_Left; <br>break; <br>} <br>SendMessage(hwndToolbar, TB_CHECKBUTTON, nID, MAKELONG(TRUE, 0)); <br>} <br>else <br>{ <br>#ifdef LIKE_WORD <br>// Make all the buttons indeterminate <br>for (nID = TBI_Left; nID &lt;= TBI_Right; nID++) <br>SendMessage(hwndToolbar, TB_INDETERMINATE, nID, MAKELONG(TRUE, 0)); <br>#else <br>// Pop all the buttons <br>for (nID = TBI_Left; nID &lt;= TBI_Right; nID++) <br>SendMessage(hwndToolbar, TB_CHECKBUTTON, nID, MAKELONG(FALSE, 0)); <br>#endif <br>} <br>} <br> <br> <br>/* <br> *FB_OnCommand <br> * <br> *Purpose: <br> *Handle some of the notifications <br> * <br> *Arguments: <br> *hwndThe window <br> *pdisPointer to a DRAWITEMSTRUCT to be filled out <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL void FB_OnCommand(HWND hwnd, INT nID, HWND hwndCtl, INT nNotify) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>LONGiSel; <br>if (nNotify == CBN_ERRSPACE) <br>{ <br>//$ FUTURE: Handle error out of space <br>return; <br>} <br> <br>switch (nNotify) <br>{ <br>case CBN_SELENDOK: <br>// Flag the next combobox message as somethng we want <br>pfbs-&gt;fExpectChoice = TRUE; <br>pfbs-&gt;fGiveUpFocus = TRUE; <br>return; <br> <br>case 0: <br>// This is a button from the toolbar if hwndCtl == pfbs-&gt;hwndToolbar <br>if (hwndCtl != pfbs-&gt;hwndToolbar) <br>return; <br>break; <br> <br>case CBN_KILLFOCUS: <br>switch (nID) <br>{ <br>case TBI_Name: <br>PaintName(pfbs); <br>break; <br> <br>case TBI_Size: <br>PaintSize(pfbs); <br>break; <br> <br>case TBI_Color: <br>PaintColor(pfbs); <br>break; <br>} <br>return; <br> <br>case CBN_SELCHANGE: <br>// The user is making up his mind so ignore the sel change <br>if (!pfbs-&gt;fExpectChoice) <br>return; <br>break; <br> <br>case CBN_DROPDOWN: <br>if (nID == TBI_Size) <br>FFillSizes(hwnd); <br>return; <br> <br>//$ REVIEW: Just check for fExpectChoice to shorten this switch ? <br> <br>// Throw away these notifications from the toolbar <br>case TBN_BEGINDRAG: <br>case TBN_ENDDRAG: <br> <br>// Throw away these notifications from the comboboxes <br>case CBN_SETFOCUS: <br>case CBN_CLOSEUP: <br>case CBN_SELENDCANCEL: <br>case CBN_EDITCHANGE: <br>case CBN_EDITUPDATE: <br>case CBN_DBLCLK: <br> <br>default: <br>return; <br>} <br> <br>switch (nID) </code></pre>
<p>
</p>
<pre><code>{ <br>case TBI_Name: <br>if (pfbs-&gt;fExpectChoice) <br>{ <br>DWORDdw; <br> <br>// Get the new font name <br>pfbs-&gt;cf.dwMask |= CFM_FACE | CFM_CHARSET; <br>pfbs-&gt;dwCFMaskChange = CFM_FACE | CFM_CHARSET; <br> <br>// Get the new selection <br>iSel = SendMessage(pfbs-&gt;hwndName, CB_GETCURSEL, 0, 0); <br>if (iSel &lt; 0) <br>{ <br>//DebugStr("\pBefore GetWindowText in Frmtbar.c"); <br>GetWindowText(pfbs-&gt;hwndName, pfbs-&gt;cf.szFaceName, <br>sizeof(pfbs-&gt;cf.szFaceName) / sizeof(TCHAR)); <br>pfbs-&gt;cf.bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE; <br>pfbs-&gt;cf.bCharSet = DEFAULT_CHARSET; <br>} <br>else <br>{ <br>SendMessage(pfbs-&gt;hwndName, CB_GETLBTEXT, (WPARAM) iSel, <br>(LPARAM) pfbs-&gt;cf.szFaceName); <br> <br>// Pull the other bits of data we had packed away. <br>dw = ComboBox_GetItemData(pfbs-&gt;hwndName, iSel); <br>dw &gt;&gt;= 16; <br>pfbs-&gt;cf.bPitchAndFamily = (BYTE) dw &amp; 0xFF; <br>dw &gt;&gt;= 8; <br>pfbs-&gt;cf.bCharSet = (BYTE) dw &amp; 0xFF; <br>} <br> <br>// Update the list of font sizes <br>FFillSizes(hwnd); <br>pfbs-&gt;fExpectChoice = FALSE; <br>} <br>break; <br> <br>case TBI_Size: <br>if (pfbs-&gt;fExpectChoice) <br>{ <br>TCHARszT[10]; <br>TCHAR *pch = szT; <br>LONGlSize = 0; <br> <br>// Get the new font size <br>pfbs-&gt;cf.dwMask |= CFM_SIZE; <br>pfbs-&gt;dwCFMaskChange = CFM_SIZE; <br>szT[0] = 0; <br> <br>// Get the new selection <br>iSel = SendMessage(pfbs-&gt;hwndSize, CB_GETCURSEL, 0, 0); <br>if (iSel &lt; 0) <br>{ <br>//DebugStr("\pBefore GetWindowText in Format.c2"); <br>GetWindowText(pfbs-&gt;hwndSize, szT, sizeof(szT) / sizeof(TCHAR)); <br>} <br>else <br>SendMessage(pfbs-&gt;hwndSize, CB_GETLBTEXT, (WPARAM) iSel, <br>(LPARAM) szT); <br> <br>while (*pch) <br>{ <br>if (TEXT('0') &lt;= *pch &amp;&amp; *pch &lt;= TEXT('9')) <br>{ <br>lSize *= 10; <br>lSize += *pch - '0'; <br>} <br>else <br>{ <br>// Got a bad character, reject the user's input <br>lSize = 0; <br>break; <br>} <br>*pch++; <br>} <br> <br>if (lSize &gt; 0 &amp;&amp; lSize &lt;= yHeightCharPtsMost) <br>pfbs-&gt;cf.yHeight = lSize * 20;// Make twips <br>else <br>MessageBox(hwnd, "Size must be between 1 and 1638", "Font", <br>MB_ICONINFORMATION | MB_OK); <br>pfbs-&gt;fExpectChoice = FALSE; <br>} <br>break; <br> <br>case TBI_Color: <br>if (pfbs-&gt;fExpectChoice) <br>{ <br>LONG ilSel = SendMessage(pfbs-&gt;hwndColor, CB_GETCURSEL, 0, 0); <br> <br>// Remember that we are picking a color <br>pfbs-&gt;cf.dwMask |= CFM_COLOR; <br>pfbs-&gt;dwCFMaskChange = CFM_COLOR; <br> <br>//$ FUTURE: For now always turn-off autocolor, but later we'll <br>//have to handle picking autocolor <br>pfbs-&gt;cf.dwEffects &amp;= ~CFE_AUTOCOLOR; <br> <br>if (ilSel &lt; 0) <br>pfbs-&gt;cf.crTextColor = 0; <br>else <br>pfbs-&gt;cf.crTextColor = (COLORREF) SendMessage(pfbs-&gt;hwndColor, <br>CB_GETITEMDATA, (WPARAM) ilSel, 0); <br>pfbs-&gt;fExpectChoice = FALSE; <br>} <br>break; <br> <br>case TBI_Bold: <br>case TBI_Italic: <br>case TBI_Underline: <br> <br>// NOTE: We reverse the if condition because by the time we get the <br>// notification, the button has already been pressed. <br>pfbs-&gt;dwCFMaskChange = rgdwCFEffect[nID - TBI_Bold]; <br>pfbs-&gt;cf.dwMask |= rgdwCFEffect[nID - TBI_Bold]; <br>#ifdef NEVER <br>if (!SendMessage(pfbs-&gt;hwndToolbar, TB_ISBUTTONCHECKED, nID, 0)) <br>pfbs-&gt;cf.dwEffects &amp;= ~rgdwCFEffect[nID - TBI_Bold]; <br>else <br>pfbs-&gt;cf.dwEffects |= rgdwCFEffect[nID - TBI_Bold]; <br>#else <br>pfbs-&gt;cf.dwEffects ^= rgdwCFEffect[nID - TBI_Bold]; <br>#endif <br>pfbs-&gt;fGiveUpFocus = TRUE; <br>break; <br> <br>case TBI_Bullet: <br>// NOTE: The button has already been pushed, <br>// so the checked state is accurate <br>pfbs-&gt;pf.dwMask |= PFM_NUMBERING | PFM_OFFSET; <br>if (SendMessage(pfbs-&gt;hwndToolbar, TB_ISBUTTONCHECKED, nID, 0)) <br>{ <br>pfbs-&gt;pf.wNumbering = PFN_BULLET; <br>pfbs-&gt;pf.dxOffset = cxBulletIndent; <br>} <br>else <br>{ <br>pfbs-&gt;pf.wNumbering = 0; <br>pfbs-&gt;pf.dxOffset = 0; <br>} <br>pfbs-&gt;fGiveUpFocus = TRUE; <br>break; <br> <br>case TBI_IncreaseIndent: <br>case TBI_DecreaseIndent: <br>pfbs-&gt;fGiveUpFocus = TRUE; <br>break; <br> <br>case TBI_Left: <br>case TBI_Center: <br>case TBI_Right: <br>pfbs-&gt;pf.dwMask |= PFM_ALIGNMENT; <br>pfbs-&gt;pf.wAlignment = rgwPFAlignment[nID - TBI_Left]; <br>pfbs-&gt;fGiveUpFocus = TRUE; <br>PaintAlignment(pfbs); <br>break; <br> <br> <br> <br>} <br> <br> <br> <br>// Give up the focus ? <br>if (pfbs-&gt;fGiveUpFocus) <br>{ <br>pfbs-&gt;fGiveUpFocus = FALSE; <br>SetFocus(hwnd); <br>} <br> <br>// Go tell our parent <br>SendMessage(GetParent(hwnd), WM_COMMAND, <br>GET_WM_COMMAND_MPS(nID, hwndCtl, nNotify)); <br>} <br> <br> <br>/* <br> *FB_OnPaint <br> * <br> *Purpose: <br> *Update our screen <br> * <br> *Arguments: <br> *hwndThe window <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL void FB_OnPaint(HWND hwnd) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>PAINTSTRUCTps; <br> <br>// Repaint the toolbar as needed <br>BeginPaint(hwnd, &amp;ps); <br>//PaintName(pfbs); <br>//PaintSize(pfbs); <br>//PaintColor(pfbs); <br>//PaintEffects(pfbs); <br>//PaintAlignment(pfbs); <br>SendMessage(pfbs-&gt;hwndToolbar, WM_PAINT, 0, 0); <br>EndPaint(hwnd, &amp;ps); <br>} <br> <br> <br>/* <br> *SetCharFormat <br> * <br> *Purpose: <br> *Set the current char format <br> * <br> *Arguments: <br> *hwndThe format bar window <br> *pcfNewThe new formatting <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID SetCharFormat(HWND hwnd, CHARFORMAT *pcfNew) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>CHARFORMAT *pcf = &amp;pfbs-&gt;cf; <br>DWORDdwMask; <br>DWORDdwEffects; <br> <br>TraceCharFormat("EM_SETCHARFORMAT", pcfNew); <br> <br>if(pcfNew-&gt;cbSize != sizeof(CHARFORMAT)) <br>return; <br> <br>// Change in font name ? <br>if (lstrcmpi(pcf-&gt;szFaceName, pcfNew-&gt;szFaceName) || <br>(pcf-&gt;bPitchAndFamily != pcfNew-&gt;bPitchAndFamily) || <br>(pcf-&gt;dwMask &amp; CFM_FACE) != (pcfNew-&gt;dwMask &amp; CFM_FACE)) <br>{ <br>pcf-&gt;dwMask &amp;= ~CFM_FACE; <br>pcf-&gt;dwMask |= pcfNew-&gt;dwMask &amp; CFM_FACE; <br>lstrcpy(pcf-&gt;szFaceName, pcfNew-&gt;szFaceName); <br>pcf-&gt;bPitchAndFamily = pcfNew-&gt;bPitchAndFamily; <br>PaintName(pfbs); <br>} <br> <br>// Change in charset ? <br>if (pcf-&gt;bCharSet != pcfNew-&gt;bCharSet || <br>(pcf-&gt;dwMask &amp; CFM_CHARSET) != (pcfNew-&gt;dwMask &amp; CFM_CHARSET)) <br>{ <br>pcf-&gt;dwMask &amp;= ~CFM_CHARSET; <br>pcf-&gt;dwMask |= pcfNew-&gt;dwMask &amp; CFM_CHARSET; <br>pcf-&gt;bCharSet = pcfNew-&gt;bCharSet; <br>PaintSize(pfbs); <br>} <br> <br>// Change in font size ? <br>if (pcf-&gt;yHeight != pcfNew-&gt;yHeight || <br>(pcf-&gt;dwMask &amp; CFM_SIZE) != (pcfNew-&gt;dwMask &amp; CFM_SIZE)) <br>{ <br>pcf-&gt;dwMask &amp;= ~CFM_SIZE; <br>pcf-&gt;dwMask |= pcfNew-&gt;dwMask &amp; CFM_SIZE; <br>pcf-&gt;yHeight = pcfNew-&gt;yHeight; <br>PaintSize(pfbs); <br>} <br> <br>// Change in font color ? <br>if (pcf-&gt;crTextColor != pcfNew-&gt;crTextColor || <br>(pcf-&gt;dwMask &amp; CFM_COLOR) != (pcfNew-&gt;dwMask &amp; CFM_COLOR)) <br>{ <br>pcf-&gt;dwMask &amp;= ~CFM_COLOR; <br>pcf-&gt;dwMask |= pcfNew-&gt;dwMask &amp; CFM_COLOR; <br>pcf-&gt;crTextColor = pcfNew-&gt;crTextColor; <br>PaintColor(pfbs); <br>} <br> <br>// Change in effects ? <br>dwMask = pcf-&gt;dwMask &amp; CFM_MASKS; <br>dwEffects = pcf-&gt;dwEffects &amp; CFE_EFFECTS; <br>if (((pcfNew-&gt;dwMask &amp; CFM_MASKS) != dwMask) || <br>((pcfNew-&gt;dwEffects &amp; CFE_EFFECTS) != dwEffects)) <br>{ <br>pcf-&gt;dwMask &amp;= ~CFM_MASKS; <br>pcf-&gt;dwMask |= pcfNew-&gt;dwMask &amp; CFM_MASKS; <br>pcf-&gt;dwEffects = pcfNew-&gt;dwEffects &amp; CFE_EFFECTS; <br>PaintEffects(pfbs); <br>} <br>} <br> <br> <br>/* <br> *SetParaFormat <br> * <br> *Purpose: <br> *Set the current char format <br> * <br> *Arguments: <br> *hwndThe format bar window <br> *ppfNewThe new formatting <br> * <br> *Returns: <br> *None. <br> */ <br>LOCAL VOID SetParaFormat(HWND hwnd, PARAFORMAT *ppfNew) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>PARAFORMAT *ppf = &amp;pfbs-&gt;pf; <br>DWORDdwMaskOld = ppf-&gt;dwMask; <br>BOOLfChanged = FALSE; <br> <br>// update the mask for tri-state sake <br>ppf-&gt;dwMask = (ppf-&gt;dwMask &amp; ~(PFM_NUMBERING | PFM_ALIGNMENT)) | <br>(ppfNew-&gt;dwMask &amp; (PFM_NUMBERING | PFM_ALIGNMENT)); <br> <br>// Change in numbering ? <br>if (ppf-&gt;wNumbering != ppfNew-&gt;wNumbering) <br>{ <br>const BOOL fBulleted = ppfNew-&gt;wNumbering == PFN_BULLET; <br> <br>ppf-&gt;wNumbering = ppfNew-&gt;wNumbering; <br>SendMessage(pfbs-&gt;hwndToolbar, TB_CHECKBUTTON, TBI_Bullet, MAKELONG(fBulleted, 0)); <br>} <br> <br>// Change in alignment ? <br>if (ppf-&gt;wAlignment != ppfNew-&gt;wAlignment) <br>{ <br>ppf-&gt;wAlignment = ppfNew-&gt;wAlignment; <br>fChanged |= TRUE; <br>} <br> <br>if (fChanged || dwMaskOld != ppf-&gt;dwMask) <br>PaintAlignment(pfbs); <br>} <br> <br> <br>/* <br> *LFormatBarWndProc <br> * <br> *Purpose: <br> *Take care of handling the notifications from the combobox controls we <br> *get from the format bar <br> * <br> *Arguments: <br> *hwnd <br> *wMsg <br> *wParam <br> *lParam <br> * <br> *Returns: <br> *LRESULT <br> */ <br>LRESULT CALLBACK LFormatBarWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, <br>LPARAM lParam) <br>{ <br>FormatBarState *pfbs = PfbsGetWindowPtr(hwnd); <br>BOOL fShift; <br> <br>switch(wMsg) <br>{ <br>HANDLE_MSG(hwnd, WM_MEASUREITEM, FB_OnMeasureItem); <br> <br>case WM_COMMAND: <br>FB_OnCommand(hwnd, GET_WM_COMMAND_ID(wParam, lParam), <br> GET_WM_COMMAND_HWND(wParam, lParam), <br> GET_WM_COMMAND_CMD(wParam, lParam)); <br>return 0; <br> <br>case WM_NCCREATE: <br>return FB_OnNcCreate(hwnd, (CREATESTRUCT *) lParam); <br> <br> <br>case WM_DRAWITEM: <br>FB_OnDrawItem(hwnd, (DRAWITEMSTRUCT *) lParam); <br>return TRUE; <br> <br>case WM_PAINT: <br>FB_OnPaint(hwnd); <br>break; <br> <br>case WM_DESTROY: <br>if (pfbs) <br>{ <br>if (pfbs-&gt;hwndName) <br>DestroyWindow(pfbs-&gt;hwndName); <br>if (pfbs-&gt;hwndSize) <br>DestroyWindow(pfbs-&gt;hwndSize); <br>if (pfbs-&gt;hwndColor) <br>DestroyWindow(pfbs-&gt;hwndColor); <br>if (pfbs-&gt;hwndToolbar) <br>DestroyWindow(pfbs-&gt;hwndToolbar); <br>if (pfbs-&gt;hbrushWindow) <br>DeleteObject(pfbs-&gt;hbrushWindow); <br>if (pfbs-&gt;hbrushHighlight) <br>DeleteObject(pfbs-&gt;hbrushHighlight); <br>if (pfbs-&gt;hbrushButtonFace) <br>DeleteObject(pfbs-&gt;hbrushButtonFace); <br>if (pfbs-&gt;hdc) <br>DeleteDC(pfbs-&gt;hdc); <br>GlobalFreePtr(pfbs); <br>SetWindowPtr(hwnd, NULL); <br>} <br>break; <br> <br>case WM_SHOWWINDOW: <br>if (pfbs) <br>{ <br>INTnCmd =wParam ? SW_SHOW : SW_HIDE; <br> <br>ShowWindow(pfbs-&gt;hwndToolbar, nCmd); <br>SendMessage(pfbs-&gt;hwndToolbar, WM_SIZE, 0, 0); <br>ShowWindow(pfbs-&gt;hwndName, nCmd); <br>ShowWindow(pfbs-&gt;hwndSize, nCmd); <br>ShowWindow(pfbs-&gt;hwndColor, nCmd); <br>} <br>return 0; <br> <br>case WM_SIZE: <br>if (pfbs) <br>{ <br>RECTrcMe; <br>RECTrcParent; <br> <br>// Get our current dimensions <br>GetClientRect(pfbs-&gt;hwndToolbar, &amp;rcMe); <br>rcMe.bottom += 3; <br> <br>// We want to fit our parent's width <br>GetClientRect(GetParent(hwnd), &amp;rcParent); <br> <br>// Make it so <br>SetWindowPos(hwnd, HWND_TOP, 0, 0, rcParent.right - rcParent.left, <br>rcMe.bottom - rcMe.top, SWP_NOMOVE | SWP_NOZORDER); <br>} <br>return 0; <br> <br>case WM_ENABLE: <br>if (pfbs) <br>{ <br>INTnID; <br> <br>EnableWindow(pfbs-&gt;hwndToolbar, wParam); <br>EnableWindow(pfbs-&gt;hwndName, wParam); <br>EnableWindow(pfbs-&gt;hwndSize, wParam); <br>EnableWindow(pfbs-&gt;hwndColor, wParam); <br>for (nID = TBI_Bold; nID &lt;= TBI_Right; nID++) <br>SendMessage(pfbs-&gt;hwndToolbar, TB_ENABLEBUTTON, nID, <br>MAKELONG(wParam, 0)); <br>} <br>break; <br> <br>case WM_SYSCOLORCHANGE: <br>// Update our concept of the brushes <br>if (pfbs) <br>UpdateBrushes(hwnd); <br>break; <br> <br>case EM_GETPARAFORMAT: <br>Assert(lParam); <br>if (lParam) <br>{ <br>PARAFORMAT * const ppf = (PARAFORMAT *) lParam; <br> <br>if(ppf-&gt;cbSize == sizeof(PARAFORMAT)) <br>{ <br>CopyMemory(((LPBYTE) ppf) + sizeof(ppf-&gt;cbSize), <br>((LPBYTE) &amp;pfbs-&gt;pf) + sizeof(ppf-&gt;cbSize), <br>sizeof(PARAFORMAT) - sizeof(ppf-&gt;cbSize)); <br>} <br>} <br>return 0; <br> <br>case EM_SETPARAFORMAT: <br>Assert(lParam); <br>if (lParam) <br>SetParaFormat(hwnd, (PARAFORMAT *) lParam); <br>return TRUE; <br> <br>case EM_GETCHARFORMAT: <br>Assert(lParam); <br>if (lParam) <br>{ <br>CHARFORMAT * const pcf = (CHARFORMAT *) lParam; <br> <br>if(pcf-&gt;cbSize == sizeof(CHARFORMAT)) <br>{ <br>CopyMemory(((LPBYTE) pcf) + sizeof(pcf-&gt;cbSize), <br>((LPBYTE) &amp;pfbs-&gt;cf) + sizeof(pcf-&gt;cbSize), <br>sizeof(CHARFORMAT) - sizeof(pcf-&gt;cbSize)); <br>pcf-&gt;dwMask &amp;= pfbs-&gt;dwCFMaskChange; <br>TraceCharFormat("EM_GETCHARFORMAT", pcf); <br>} <br>} <br>return 0; <br> <br>case EM_SETCHARFORMAT: <br>Assert(lParam); <br>if (lParam) <br>SetCharFormat(hwnd, (CHARFORMAT *) lParam); <br>return TRUE; <br> <br>case WM_RETURN: <br>// The user made a choice <br>pfbs-&gt;fExpectChoice = TRUE; <br>pfbs-&gt;fGiveUpFocus = TRUE; <br>FB_OnCommand(hwnd, wParam, (HWND) lParam, CBN_SELCHANGE); <br>return 0; <br> <br>case WM_TAB: <br>// Only change the choice if TAB was pressed on a closed dropdown <br>pfbs-&gt;fExpectChoice = !SendMessage((HWND) lParam, CB_GETDROPPEDSTATE, <br>0, 0); <br>FB_OnCommand(hwnd, wParam, (HWND) lParam, CBN_SELCHANGE); <br> <br>// Change focus, FB_OnCommand will take care of copying changed data <br>fShift = GetKeyState(VK_SHIFT) &amp; 0x8000 ? TRUE : FALSE; <br>switch (wParam) <br>{ <br>case TBI_Name: <br>SetFocus(fShift ? pfbs-&gt;hwndColor : pfbs-&gt;hwndSize); <br>break; <br> <br>case TBI_Size: <br>SetFocus(fShift ? pfbs-&gt;hwndName : pfbs-&gt;hwndColor); <br>break; <br> <br>case TBI_Color: <br>SetFocus(fShift ? pfbs-&gt;hwndSize : pfbs-&gt;hwndName); <br>break; <br>} <br>return 0; <br> <br>case WM_ESCAPE: <br>SetFocus(hwnd); <br>FB_OnPaint(hwnd); <br>return 0; <br>} <br> <br>return DefWindowProc(hwnd, wMsg, wParam, lParam); <br>} <br> <br> <br>/* <br> *FInitFormatBarClass() <br> * <br> *Purpose: <br> *Superclasses the toolbar so that we get support for a format bar <br> * <br> *Arguments: <br> *hinstThis instance <br> * <br> *Returns: <br> *TRUE if class is successfully initialized. <br> */ <br>BOOL FInitFormatBarClass(HINSTANCE hinst) <br>{ <br>WNDCLASS wc; <br> <br>// Are format bars registered yet ? <br>if (!GetClassInfo(hinst, szFormatBar, &amp;wc)) <br>{ <br>wc.style = CS_HREDRAW | CS_VREDRAW; <br>wc.lpfnWndProc = LFormatBarWndProc; <br>wc.cbClsExtra = 0; <br>wc.cbWndExtra = sizeof(FormatBarState *); <br>wc.hInstance = hinst; <br>wc.hIcon = NULL; <br>wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1); <br>wc.lpszMenuName = NULL; <br>wc.lpszClassName = szFormatBar; <br> <br>if (!RegisterClass(&amp;wc)) <br>{ <br>TraceError("FInitFormatBarClass: Couldn't register", -1); <br>return FALSE; <br>} <br>} <br>return TRUE; <br>} <br> <br> <br>/* <br> *FCreateFormatBar <br> * <br> *Purpose: <br> *Creates a format bar <br> * <br> *Arguments: <br> *hwndParentThe parent of this format bar <br> *wIDThe control ID to be associated with this format bar <br> *hdcA device context that we can copy so we can do various <br> *font information functions <br> * <br> *Returns: <br> *The window handle of the format bar <br> */ <br>HWND HwndCreateFormatBar(HWND hwndParent, WORD wID, HDC hdc) <br>{ <br>HWNDhwndFormatBar = NULL; <br>HINSTANCEhinst = (HINSTANCE) GetWindowLong(hwndParent, GWL_HINSTANCE); <br>RECTrc; <br> <br>// Initialize the format bar class <br>//$ REVIEW: Move into WinMain or LibMain <br>if (!FInitFormatBarClass(hinst)) <br>{ <br>TraceError("HwndCreateFormatBar: Not registered", -1); <br>return NULL; <br>} <br> <br>// Create the main toolbar <br>GetClientRect(hwndParent, &amp;rc); <br>hwndFormatBar = CreateWindow(szFormatBar, NULL, WS_CHILD | WS_VISIBLE, <br>0, 0, rc.right - rc.left, 29, <br>hwndParent, (HMENU) wID, hinst, <br>(LPVOID) (hdc ? &amp;hdc : NULL)); <br>if (!hwndFormatBar) <br>{ <br>TraceError("HwndCreateFormatBar: Can't create", -1); <br>goto Error; <br>} <br> <br>// Return a pointer to our state information <br>return hwndFormatBar; <br> <br>Error: <br>return NULL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
