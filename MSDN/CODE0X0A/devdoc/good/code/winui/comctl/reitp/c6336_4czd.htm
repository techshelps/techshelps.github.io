<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REITP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6349"></a>REITP.C</h2>
<pre><code>/* <br> *reitp.c <br> * <br> *Purpose: <br> *Test program for RichEdit.  Excercises main RichEdit <br> *functionality while providing a good replacement for notepad. <br> * <br> *Owner: <br> * <br> *  Copyright 1997 - 1998 Microsoft Coporation <br> */ <br> <br>#include "preinc.h" <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include &lt;commdlg.h&gt; <br>#include &lt;cderr.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>// for the benefit of the outside world, <br>// richedit.h uses cpMax instead of cpMost <br>// I highly prefer cpMost <br>#ifdef cpMax <br>#error "cpMax hack won't work" <br>#endif// cpMax <br>#define cpMax cpMost <br>#include &lt;richedit.h&gt; <br>#undef cpMax <br> <br>#include "olestd.h" <br>#include "reguid.h" <br>#include "dbugit.h" <br>#include &lt;richole.h&gt; <br> <br>#include "reitp.h" <br>#include "reitp.rh" <br>#include "frmtbar.h" <br>#include &lt;oledlg.h&gt; <br> <br> <br>ASSERTDATA <br> <br> <br>#define SUNKENRICHEDIT <br> <br>// define to use LiFormatRange() directly instead of via blitting <br>//#define NOBLIT <br> <br>// used to make life simpler while testing, should not normally be defined <br>//#define NO_SAVE_PROMPT <br> <br> <br>struct _itpcall; <br> <br>typedef struct _pp <br>{ <br>BOOL fDone; <br>HWND hwndDlg; <br>REDOC *predoc; <br>LONG cchText; <br>LONG dxPage; <br>LONG dyPage; <br>RECT rc; <br>FORMATRANGE fr; <br>#ifndef NOBLIT <br>HBITMAP hbmp; <br>HBITMAP hbmpOld; <br>INT dxBmp; <br>INT dyBmp; <br>#endif// !NOBLIT <br>INT ipage; <br>INT cpage; <br>INT cpageMost; <br>LONG *rgcpPages; <br>} PRINTPREVIEW; <br> <br>// number of pages to allocate at once in PRINTPREVIEW.rgcpPages <br>#define cpageChunk 4 <br> <br>#define szFmtPrintPreview TEXT("Print Preview - Page %d") <br> <br>typedef struct _assensz <br>{ <br>WORD wNotification; <br>LPCSTR szDescription; <br>} ASSENSZ; <br> <br>// added to the client rect to get the RichEdit size <br>#ifdef SUNKENRICHEDIT <br>#define dxRESize -GetSystemMetrics(SM_CXBORDER) <br>#define dyRESize -GetSystemMetrics(SM_CYBORDER) <br>#else// SUNKENRICHEDIT <br>#define dxRESize 0 <br>#define dyRESize 0 <br>#endif// SUNKENRICHEDIT, else <br> <br>// Control ID for the format bar <br>#defineFBR_FormatBar217 <br> <br>#define HinstFromHwnd(_hwnd) ((HINSTANCE) GetWindowLong(_hwnd, GWL_HINSTANCE)) <br> <br>#define uiMFDisabled MF_DISABLED | MF_GRAYED <br>#define uiMFEnabled MF_ENABLED <br> <br>// Maximum text to be corrected under PenWin <br>#define cchMaxCorrectText4096 <br> <br>#define szClosedName szAppName <br> <br>static TCHAR szAppName[] = TEXT("REITP"); <br>static const TCHAR szClassRE[] = TEXT(RICHEDIT_CLASS); <br> <br>static const TCHAR szFmtTitle[] = TEXT("REITP - %s"); <br>static const TCHAR szUntitled[] = TEXT("[Untitled]"); <br>static const TCHAR szRTFSig[] = TEXT("{\\rtf"); <br>#define cchRTFSig 5 <br>static TCHAR szRegKey[] = TEXT("software\\microsoft\\reitp"); <br>static TCHAR szRegValue[] = TEXT("placement"); <br>static const POINT ptMinTrackSize = {300, 90}; <br>// Make sure that these strings match the order of SF_* <br>static TCHAR szFilterLoad[] = TEXT("Text and Rich Text\0*.TXT;*.RTF\0Text Files (*.TXT)\0*.TXT\0Rich Text Format (*.RTF)\0*.RTF\0All Files\0*.*\0\0"); <br>static TCHAR szFilterSave[] = TEXT("Text Files (*.TXT)\0*.TXT\0Rich Text Format (*.RTF)\0*.RTF\0RTF w/o Objects (*.RTF)\0*.RTF\0Textized\0*.TXT\0\0"); <br> <br>static HMODULE hmod = 0;// Flag for FreeLibrary() <br>HWND hwndMain = 0; <br>static HMENU hmenuLoaded = 0; <br>HMENU hmenuFull = 0; <br>static PRINTDLG pdDef = {0}; <br>static BOOL fPrint = fFalse; <br>static BOOL fWysiwygDefault = fFalse; <br>static BOOL fWrapDefault = fTrue; <br>static UINT msgFindReplace = 0; <br>static HWND hwndFR = 0;// find/replace dialog <br>HINSTANCE hinst = 0; <br> <br>static LONG cchTextMost = 0; <br>static CLIPFORMAT cfTxtObj = 0; <br>static BOOL fErrSpace = fFalse; <br> <br> <br> <br> <br>static CHARFORMAT cfDefault = <br>{ <br>sizeof(CHARFORMAT), <br>CFM_EFFECTS | CFM_PROTECTED | CFM_SIZE | CFM_OFFSET | CFM_COLOR | CFM_CHARSET | CFM_FACE, <br>CFE_AUTOCOLOR,// effects <br>200,// height, 200 twips == 10 points <br>0,// offset <br>0,// color (not used since CFE_AUTOCOLOR is specified) <br>ANSI_CHARSET, <br>FF_ROMAN,// pitch and family <br>"Arial"// face name <br>}; <br> <br>static ASSENSZ rgassenszErrors[] = <br>{ <br>{EN_ERRSPACE, "Out of memory. Exit some other applications and try again."}, <br>{EN_MAXTEXT, "The maximum text length has been reached."}, <br>{0, NULL} <br>}; <br> <br>/* <br> *ITPOLEINPLACEFRAME <br> * <br> *Purpose: <br> *Frame window support for in place editing <br> */ <br>typedef struct _itpoleinplaceframe <br>{ <br>IOleInPlaceFrameVtbl * lpVtbl;// Virtual table <br>ULONG cRef;// Reference count <br>REDOC * predoc;// Document <br>LPOLEINPLACEACTIVEOBJECT pipaobj;// Current active object <br>} <br>ITPOLEINPLACEFRAME; <br> <br>#define PipframeFromPunk(_p) ((ITPOLEINPLACEFRAME *) (_p)) <br> <br>// Functions for ITP in place frame <br>ITPOLEINPLACEFRAME * ITPOLEINPLACEFRAME_New(REDOC * predoc); <br>STDMETHODIMP ITPOLEINPLACEFRAME_QueryInterface(LPUNKNOWN punk, REFIID riid, <br>   LPUNKNOWN * ppvObj); <br>STDMETHODIMP_(ULONG) ITPOLEINPLACEFRAME_AddRef(LPUNKNOWN punk); <br>STDMETHODIMP_(ULONG) ITPOLEINPLACEFRAME_Release(LPUNKNOWN punk); <br>STDMETHODIMP ITPOLEINPLACEFRAME_GetWindow(ITPOLEINPLACEFRAME * pipframe, <br>  HWND * phwnd); <br>STDMETHODIMP ITPOLEINPLACEFRAME_ContextSensitiveHelp(ITPOLEINPLACEFRAME *pipframe, <br> BOOL fEnterMode); <br>STDMETHODIMP ITPOLEINPLACEFRAME_GetBorder(ITPOLEINPLACEFRAME * pipframe, <br>  LPRECT prcBorder); <br>STDMETHODIMP ITPOLEINPLACEFRAME_RequestBorderSpace(ITPOLEINPLACEFRAME * pipframe, <br>   LPCBORDERWIDTHS pbw); <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetBorderSpace(ITPOLEINPLACEFRAME * pipframe, <br>   LPCBORDERWIDTHS pbw); <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetActiveObject(ITPOLEINPLACEFRAME * pipframe, <br>    LPOLEINPLACEACTIVEOBJECT pipaobj, <br>    LPCSTR szObjName);  <br>STDMETHODIMP ITPOLEINPLACEFRAME_InsertMenus(ITPOLEINPLACEFRAME * pipframe, <br>    HMENU hmenuShared,  <br>    LPOLEMENUGROUPWIDTHS pmgw); <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetMenu(ITPOLEINPLACEFRAME * pipframe,  <br>    HMENU hmenuShared, HOLEMENU holemenu,  <br>    HWND hwndActiveObject); <br>STDMETHODIMP ITPOLEINPLACEFRAME_RemoveMenus(ITPOLEINPLACEFRAME * pipframe,  <br>    HMENU hmenuShared); <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetStatusText(ITPOLEINPLACEFRAME * pipframe,  <br>  LPCSTR szStatusText);     <br>STDMETHODIMP ITPOLEINPLACEFRAME_EnableModeless(ITPOLEINPLACEFRAME * pipframe,  <br>   BOOL fEnable); <br>STDMETHODIMP ITPOLEINPLACEFRAME_TranslateAccelerator(ITPOLEINPLACEFRAME *pipframe, <br> LPMSG pmsg, WORD wID); <br> <br>// Virtual table for ole in place frame interface <br>IOleInPlaceFrameVtbl ITPOLEINPLACEFRAME_Vtbl = <br>{ <br>(LPVOID) ITPOLEINPLACEFRAME_QueryInterface, <br>(LPVOID) ITPOLEINPLACEFRAME_AddRef, <br>(LPVOID) ITPOLEINPLACEFRAME_Release, <br>(LPVOID) ITPOLEINPLACEFRAME_GetWindow, <br>(LPVOID) ITPOLEINPLACEFRAME_ContextSensitiveHelp, <br>(LPVOID) ITPOLEINPLACEFRAME_GetBorder, <br>(LPVOID) ITPOLEINPLACEFRAME_RequestBorderSpace, <br>(LPVOID) ITPOLEINPLACEFRAME_SetBorderSpace, <br>(LPVOID) ITPOLEINPLACEFRAME_SetActiveObject, <br>(LPVOID) ITPOLEINPLACEFRAME_InsertMenus, <br>(LPVOID) ITPOLEINPLACEFRAME_SetMenu, <br>(LPVOID) ITPOLEINPLACEFRAME_RemoveMenus, <br>(LPVOID) ITPOLEINPLACEFRAME_SetStatusText, <br>(LPVOID) ITPOLEINPLACEFRAME_EnableModeless, <br>(LPVOID) ITPOLEINPLACEFRAME_TranslateAccelerator <br>}; <br> <br> <br>/* <br> *ITPCALL <br> * <br> *Purpose: <br> *Callbacks from the Rich Edit OLE support <br> */ <br> <br>typedef struct _itpcall <br>{ <br>IRichEditOleCallbackVtbl * lpVtbl;// Virtual table <br>ULONG cRef;    // Reference count <br>REDOC * predoc;// Document <br>ITPOLEINPLACEFRAME * pipframe;// In place frame object <br>} <br>ITPCALL; <br> <br> <br>#define PitpcallFromPunk(_p) ((ITPCALL *) (_p)) <br> <br>// Functions for ITP callbacks <br>ITPCALL * ITPCALL_New(REDOC * predoc); <br>STDMETHODIMP ITPCALL_QueryInterface(LPUNKNOWN punk, REFIID riid, <br>    LPUNKNOWN * ppvObj); <br>STDMETHODIMP_(ULONG) ITPCALL_AddRef(LPUNKNOWN punk); <br>STDMETHODIMP_(ULONG) ITPCALL_Release(LPUNKNOWN punk); <br>STDMETHODIMP ITPCALL_GetNewStorage(ITPCALL * pitpcall, LPSTORAGE FAR * ppstg); <br>STDMETHODIMP ITPCALL_GetInPlaceContext(ITPCALL * pitpcall,  <br>   LPOLEINPLACEFRAME FAR * ppipframe, <br>   LPOLEINPLACEUIWINDOW FAR* ppipuiDoc, <br>   LPOLEINPLACEFRAMEINFO pipfinfo); <br>STDMETHODIMP ITPCALL_ShowContainerUI(ITPCALL * pitpcall, BOOL fShow); <br>STDMETHODIMP ITPCALL_QueryInsertObject(ITPCALL * pitpcall, LPCLSID pclsid, <br>LPSTORAGE pstg, LONG cp); <br>STDMETHODIMP ITPCALL_DeleteObject(ITPCALL * pitpcall, LPOLEOBJECT poleobj); <br>STDMETHODIMP ITPCALL_QueryAcceptData(ITPCALL * pitpcall, LPDATAOBJECT pdataobj, <br>CLIPFORMAT *pcfFormat, DWORD reco, BOOL fReally, <br>HGLOBAL hMetaPict); <br>STDMETHODIMP ITPCALL_ContextSensitiveHelp(ITPCALL * pitpcall, BOOL fEnterMode); <br>STDMETHODIMP ITPCALL_GetClipboardData(ITPCALL *pitpcall, CHARRANGE *pchrg, <br>DWORD reco, LPDATAOBJECT *ppdataobj); <br>STDMETHODIMP ITPCALL_GetDragDropEffect(ITPCALL *pitpcall, BOOL fDrag, <br>DWORD grfKeyState, LPDWORD pdwEffect); <br>STDMETHODIMP ITPCALL_GetContextMenu(ITPCALL *pitpcall, WORD seltype, <br>LPOLEOBJECT poleobj, CHARRANGE * pchrg, HMENU * phmenu); <br> <br>// Virtual table for ITP callbacks <br>IRichEditOleCallbackVtbl ITPCALL_Vtbl = <br>{ <br>(LPVOID) ITPCALL_QueryInterface, <br>(LPVOID) ITPCALL_AddRef, <br>(LPVOID) ITPCALL_Release, <br>(LPVOID) ITPCALL_GetNewStorage, <br>(LPVOID) ITPCALL_GetInPlaceContext, <br>(LPVOID) ITPCALL_ShowContainerUI, <br>(LPVOID) ITPCALL_QueryInsertObject, <br>(LPVOID) ITPCALL_DeleteObject, <br>(LPVOID) ITPCALL_QueryAcceptData, <br>(LPVOID) ITPCALL_ContextSensitiveHelp, <br>(LPVOID) ITPCALL_GetClipboardData, <br>(LPVOID) ITPCALL_GetDragDropEffect, <br>(LPVOID) ITPCALL_GetContextMenu <br>}; <br> <br> <br>LOCAL VOID ParseArguments(LPSTR *pszDoc, LPCSTR szCmdLine); <br>LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam); <br>LOCAL LRESULT HandleCreate(REDOC *predoc, LPCSTR szCmdLine); <br>LOCAL VOID ResizeRedoc(REDOC *predoc, RECT rc); <br>LOCAL VOID SetupMenu(REDOC *predoc, int iMenu, HMENU hmenu); <br>LOCAL LRESULT HandleCommand(REDOC *predoc, HWND hwnd, WPARAM wparam, <br>LPARAM lparam); <br>LOCAL BOOL ToggleCheck(REDOC *predoc, UINT uiMenuid); <br>LOCAL BOOL QueryCheck(REDOC *predoc, UINT uiMenuid); <br>LOCAL LRESULT NewREDoc(REDOC *predoc, BOOL fPrompt, BOOL fUpdateUI); <br>LOCAL LONG CheckSave(REDOC *predoc); <br>LOCAL INT CheckRevert(REDOC *predoc); <br>LOCAL LRESULT CloseREDoc(REDOC *predoc, BOOL fPrompt, BOOL fUpdateUI); <br>DWORD CALLBACK MyRead(DWORD dwCookie, LPBYTE pbBuffer, LONG cb, LONG *pcb); <br>LOCAL LRESULT OpenREDoc(REDOC *predoc, BOOL fInsert); <br>LOCAL LRESULT RevertREDoc(REDOC *predoc); <br>LOCAL DWORD ReadREDoc(REDOC *predoc, LPCSTR szFile, LPCSTR szTitle, <br>DWORD dwFormat, BOOL fInsert); <br>DWORD CALLBACK MyWrite(DWORD dwCookie, LPBYTE pbBuffer, LONG cb, LONG *pcb); <br>LOCAL LRESULT SaveREDoc(REDOC *predoc); <br>LOCAL LRESULT SaveREDocAs(REDOC *predoc, BOOL fSelect); <br>LOCAL LRESULT InsertObject(REDOC *predoc); <br>LOCAL VOID SelectCharFormat(REDOC *predoc); <br>LOCAL VOID SaveWindowPos(HWND hwnd); <br>LOCAL BOOL FRestoreWindowPos(WINDOWPLACEMENT *pwndpl); <br>LOCAL VOID SetAlignment(REDOC *predoc, WORD wAlignment); <br>LOCAL VOID IndentFirst(REDOC *predoc, BOOL fIndent); <br>LOCAL VOID ProtectSelection(REDOC *predoc); <br>LOCAL VOID SetWordWrap(REDOC *predoc, BOOL fWysiwyg, BOOL fWrap); <br>LOCAL VOID SetupWordWrapMenu(REDOC *predoc); <br>LOCAL VOID SetOffset(REDOC *predoc, BOOL fSuperscript); <br>LRESULT CALLBACK PPDlgProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam); <br>LOCAL BOOL FPPInit(PRINTPREVIEW *ppp); <br>LOCAL VOID PPInitDialogSize(PRINTPREVIEW *ppp); <br>LOCAL VOID PPChangePage(PRINTPREVIEW *ppp, BOOL fPrev); <br>LOCAL VOID PPPaint(PRINTPREVIEW *ppp); <br>VOID DoVerb(REDOC * predoc, INT ioleverb); <br>LOCAL VOID FindReplace(REDOC *predoc, BOOL fReplace); <br>LOCAL VOID ProcessFindReplace(REDOC *predoc, FINDREPLACE *pfr); <br>LOCAL BOOL FEnablePaste(VOID); <br>LOCAL VOID UpdateFormatBar(REDOC *predoc); <br>LOCAL VOID ShowMargins(REDOC *predoc); <br> <br> <br>int PASCAL <br>WinMain(HINSTANCE hinstCurr, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>SCODE sc; <br>MSG msg; <br>WNDCLASS wndclass; <br>WINDOWPLACEMENT wndpl; <br>TCHAR *szDoc = NULL; <br>REDOC *predoc = NULL; <br>HACCEL hAccels; <br>#ifndef NO_OLE <br>LPOLEINPLACEACTIVEOBJECT pipaobj; <br>#endif// NO_OLE <br> <br>    LoadLibrary("RichEd32.Dll"); // Load the RichEdit DLL to activate the <br> // RichEdit classes <br> <br>    wndclass.style         = CS_HREDRAW | CS_VREDRAW; <br>    wndclass.lpfnWndProc   = WndProc; <br>    wndclass.cbClsExtra    = 0; <br>    wndclass.cbWndExtra    = sizeof(REDOC *); <br>    wndclass.hInstance     = hinstCurr; <br>    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wndclass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1); <br>    wndclass.hIcon       = LoadIcon(hinstCurr, TEXT("IconApp")); <br>    wndclass.lpszMenuName  = NULL; <br>    wndclass.lpszClassName = szAppName; <br> <br>RegisterClass(&amp;wndclass); <br>hinst = hinstCurr; <br> <br>#ifdef TEST_OLE_INITIALIZE <br>OleInitialize(NULL); <br>OleUninitialize(); <br>OleInitialize(NULL); <br>OleUninitialize(); <br>#endif// TEST_OLE_INITIALIZE <br> <br>OleInitialize(NULL); <br>sc = OleInitialize(NULL); <br>if (FAILED(sc)) <br>{ <br>TraceError("OleInitialize failed", sc); <br>goto done;// If OLE can't be initialized abort. <br>} <br>// OleStdInitialize(); <br> <br>// Initialize the format bar class <br>if(!FInitFormatBarClass(hinst)) <br>{ <br>MessageBoxA(NULL, "Unable to register format bar", NULL, <br>MB_ICONSTOP | MB_OK); <br>goto done; <br>} <br> <br>hmenuLoaded = LoadMenu(hinstCurr, TEXT("LoadedMenu")); <br>hmenuFull = LoadMenu(hinstCurr, TEXT("FullMenu")); <br> <br>msgFindReplace = RegisterWindowMessage(TEXT("commdlg_FindReplace")); <br> <br>cfTxtObj = RegisterClipboardFormat(TEXT(CF_RETEXTOBJ)); <br> <br>ParseArguments(&amp;szDoc, szCmdLine); <br> <br>if(fPrint &amp;&amp; !szDoc) <br>goto done; <br> <br>hwndMain = CreateWindow(szAppName, szAppName, <br>            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,  <br>            0, 0, 750, 500, NULL, NULL, hinstCurr, szDoc); <br>if(!hwndMain) <br>{ <br>MessageBoxA(NULL, "Unable to create main window", NULL, MB_ICONSTOP | MB_OK); <br>goto done; <br>} <br>SideAssert(predoc = (REDOC *) GetWindowLong(hwndMain, 0)); <br> <br>if(!fPrint) <br>{ <br>if(FRestoreWindowPos(&amp;wndpl)) <br>SetWindowPlacement(hwndMain, &amp;wndpl); <br>ShowWindow(hwndMain, nCmdShow); <br>} <br> <br>hAccels = LoadAccelerators(hinstCurr, "WARPKEYS"); <br>Assert(hAccels); <br>while(GetMessage(&amp;msg, NULL, 0, 0)) <br>{ <br># ifndef NO_OLE <br>// Translate accelerators for possible in place objects <br>if(predoc-&gt;pitpcall &amp;&amp; (pipaobj = predoc-&gt;pitpcall-&gt;pipframe-&gt;pipaobj)) <br>pipaobj-&gt;lpVtbl-&gt;TranslateAccelerator(pipaobj, &amp;msg); <br># endif// NO_OLE <br> <br>if(predoc-&gt;hwndRE &amp;&amp; TranslateAccelerator(hwndMain, hAccels, &amp;msg)) <br>continue; <br> <br>if(!hwndFR || !IsDialogMessage(hwndFR, &amp;msg)) <br>{ <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>} <br>} <br> <br> <br> <br>done: <br>if(szDoc) <br>GlobalFreePtr(szDoc); <br>if(hwndMain) <br>DestroyWindow(hwndMain); <br>if(hmenuLoaded) <br>DestroyMenu(hmenuLoaded); <br>if(hmenuFull) <br>DestroyMenu(hmenuFull); <br> <br>// OleStdUninitialize(); <br> <br>return msg.wParam; <br>} <br> <br> <br>LOCAL VOID ParseArguments(LPSTR *pszDoc, LPCSTR szCmdLine) <br>{ <br>const TCHAR *pch; <br> <br>*pszDoc = NULL; <br>pch = szCmdLine - 1; <br>while(pch) <br>{ <br>pch++; <br>if(*pch == TEXT('/') || *pch == '-') <br>{ <br>pch++; <br>switch(*pch) <br>{ <br>case TEXT('p'): <br>case TEXT('P'): <br>fPrint = fTrue; <br>break; <br> <br>case TEXT('w'): <br>case TEXT('W'): <br>pch++; <br>if(*pch == 'p' || *pch == 'P') <br>{ <br>pch++; <br>fWrapDefault = fTrue; <br>fWysiwygDefault = fTrue; <br>} <br>else if(*pch == 'n' || *pch == 'N') <br>{ <br>pch++; <br>fWrapDefault = fFalse; <br>fWysiwygDefault = fFalse; <br>} <br>else <br>{ <br>fWrapDefault = fTrue; <br>fWysiwygDefault = fFalse; <br>} <br>break; <br> <br>default: <br>if(*pch &gt;= TEXT('0') &amp;&amp; *pch &lt;= TEXT('9') &amp;&amp; !cchTextMost) <br>{ <br>while(*pch &gt;= TEXT('0') &amp;&amp; *pch &lt;= TEXT('9')) <br>{ <br>cchTextMost *= 10; <br>cchTextMost += *pch++ - TEXT('0'); <br>} <br>} <br>break; <br>} <br>} <br>else if(!*pszDoc) <br>{ <br>while(*pch == TEXT(' ')) <br>pch++; <br>if(*pch) <br>{ <br>INT cch; <br>const TCHAR *pchT; <br> <br>pchT = _tcschr(pch, TEXT(' ')); <br>if(pchT) <br>cch = pchT - pch; <br>else <br>cch = lstrlen(pch); <br>*pszDoc = GlobalAllocPtr(GHND, cch + 1); <br>if(!*pszDoc) <br>break; <br>lstrcpyn(*pszDoc, (LPCSTR) pch, cch + 1); <br>(*pszDoc)[cch] = '\0'; <br>} <br>} <br>pch = _tcschr(pch, TEXT(' ')); <br>} <br>} <br> <br> <br>LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) <br>{ <br>REDOC *predoc = (REDOC *) GetWindowLong(hwnd, 0); <br>#ifndef NO_OLE <br>LPOLEINPLACEACTIVEOBJECT pipaobj; <br>#endif// !NO_OLE <br> <br>    switch(msg) <br>    { <br>case WM_NCCREATE: <br>predoc = (REDOC *) GlobalAllocPtr(GHND, sizeof(REDOC)); <br>if(!predoc) <br>return 0; <br>SetWindowLong(hwnd, 0, (LONG) predoc); <br>predoc-&gt;hwndParent = hwnd; <br>#ifndef MAC <br>predoc-&gt;pd.lStructSize = sizeof(PRINTDLG); <br>predoc-&gt;pd.hwndOwner = hwnd; <br>predoc-&gt;pd.Flags = PD_RETURNDEFAULT; <br> <br>if(!PrintDlg(&amp;predoc-&gt;pd) &amp;&amp; CommDlgExtendedError()) <br>memset(&amp;predoc-&gt;pd, 0, sizeof(PRINTDLG)); <br>#endif <br>break; <br> <br>case WM_NCDESTROY: <br>if(predoc) <br>{ <br>if(predoc-&gt;pfr) <br>GlobalFreePtr(predoc-&gt;pfr); <br>GlobalFreePtr(predoc); <br>predoc = NULL; <br>SetWindowLong(hwnd, 0, 0); <br>} <br>break; <br> <br>case WM_CREATE: <br>hwndMain = hwnd;// a bit of a cheat... <br> <br>return HandleCreate(predoc, <br>(LPCSTR) ((CREATESTRUCT *) lparam)-&gt;lpCreateParams); <br>    case WM_DESTROY: <br>PostQuitMessage(0); <br>        return 0l; <br> <br>case WM_ACTIVATEAPP: <br>#ifndef NO_OLE <br>// Notify in place active object of frame activation <br>if(predoc-&gt;pitpcall &amp;&amp; (pipaobj = predoc-&gt;pitpcall-&gt;pipframe-&gt;pipaobj)) <br>{ <br>TraceTag(tagInPlace, "OnFrameWindowActivate(%d)", !!wparam); <br>pipaobj-&gt;lpVtbl-&gt;OnFrameWindowActivate(pipaobj, !!wparam); <br>} <br>#endif// !NO_OLE <br>break; <br> <br>case WM_INITMENU: <br>if(predoc-&gt;hwndRE) <br>predoc-&gt;fUpdateEditMenu = TRUE; <br>break; <br> <br>case WM_INITMENUPOPUP: <br>if(predoc-&gt;hwndRE) <br>SetupMenu(predoc, (int) lparam, (HMENU) wparam); <br>return 0; <br> <br>case WM_GETMINMAXINFO: <br>((MINMAXINFO *) lparam)-&gt;ptMinTrackSize = ptMinTrackSize; <br>return 0; <br> <br>case WM_COMMAND: <br>return HandleCommand(predoc, hwnd, wparam, lparam); <br> <br>case WM_CLOSE: <br>if(predoc &amp;&amp; predoc-&gt;hwndRE &amp;&amp; CloseREDoc(predoc, fTrue, fFalse) &lt; 0) <br>return 0; <br>if(!fPrint) <br>SaveWindowPos(hwnd); <br>DestroyWindow(hwnd); <br>return 0; <br> <br>case WM_ACTIVATE: <br>if(predoc-&gt;hwndRE &amp;&amp; LOWORD(wparam)) <br>{ <br>SetFocus(predoc-&gt;hwndRE); <br>return 0; <br>} <br>break; <br> <br>case WM_SIZE: <br>if(predoc-&gt;hwndFormatBar) <br>SendMessage(predoc-&gt;hwndFormatBar, WM_SIZE, 0, 0); <br>if(predoc-&gt;hwndRE) <br>{ <br>RECT rc; <br> <br>GetClientRect(hwnd, &amp;rc); <br>ResizeRedoc(predoc, rc); <br>#ifdef DEBUG <br>SendMessage(predoc-&gt;hwndRE, EM_REQUESTRESIZE, 0, 0); <br>#endif// DEBUG <br>} <br>break; <br> <br> <br>case WM_NOTIFY: <br>switch(((NMHDR *) lparam)-&gt;code) <br>{ <br>case EN_SELCHANGE: <br>if(predoc-&gt;hwndFormatBar) <br>UpdateFormatBar(predoc); <br>return 0; <br> <br>case EN_PROTECTED: <br>{ <br>ENPROTECTED *penprotected = (ENPROTECTED *) lparam; <br> <br>// allow change of protected attribute <br>if(penprotected-&gt;msg == EM_SETCHARFORMAT &amp;&amp; <br>((CHARFORMAT *) penprotected-&gt;lParam)-&gt;dwMask &amp; CFM_PROTECTED) <br>{ <br>return 0; <br>} <br>} <br>MessageBeep(0); <br>return 1; <br> <br>case EN_CORRECTTEXT: <br>{ <br>ENCORRECTTEXT *pct = (ENCORRECTTEXT *) lparam; <br> <br>if(pct-&gt;chrg.cpMost - pct-&gt;chrg.cpMin &gt; cchMaxCorrectText) <br>{ <br>MessageBox(hwndMain, <br>"You are trying to correct too much text. " <br>"Decrease the size of your selection.", <br>"REITP: Correct Text", MB_OK); <br>return 0; <br>} <br>} <br>return 1; <br> <br>#ifndef NO_OLE <br>case EN_DROPFILES: <br># ifdef DEBUG <br>if(!QueryCheck(predoc, IDM_IGNOREDROPS)) <br>return fFalse; <br>TraceTag(tagGeneral, "Ignoring drop of %d file(s) at position %d", <br>DragQueryFile(((ENDROPFILES *) lparam)-&gt;hDrop, (UINT) -1, <br>NULL, 0), <br>((ENDROPFILES *) lparam)-&gt;cp); <br>// ignore file drops <br>return fTrue; <br># else// DEBUG <br>return ((ENDROPFILES *) lparam)-&gt;fProtected; <br># endif// DEBUG, else <br>#endif// !NO_OLE <br> <br> <br>#ifdef DEBUG <br>case EN_MSGFILTER: <br>{ <br>MSGFILTER *pmsgfilter = (MSGFILTER *) lparam; <br> <br>// eat left button downs and 'e's <br>return (pmsgfilter-&gt;msg == WM_LBUTTONDOWN) || <br>((pmsgfilter-&gt;msg == WM_CHAR) &amp;&amp; <br>(pmsgfilter-&gt;wParam == 'e')); <br>} <br> <br>case EN_REQUESTRESIZE: <br>ResizeRedoc(predoc, ((REQRESIZE *) lparam)-&gt;rc); <br>return 0; <br>#endif// DEBUG <br>} <br>break; <br> <br>default: <br>if(msg != msgFindReplace) <br>break; <br> <br>if(((FINDREPLACE *) lparam)-&gt;Flags &amp; FR_DIALOGTERM) <br>{ <br>hwndFR = 0; <br>SendMessage(predoc-&gt;hwndRE, EM_HIDESELECTION, fTrue, fTrue); <br>return 0; <br>} <br>ProcessFindReplace(predoc, (FINDREPLACE *) lparam); <br>return 0; <br>    } <br> <br>return DefWindowProc(hwnd, msg, wparam, lparam); <br>} <br> <br> <br>LOCAL LRESULT HandleCreate(REDOC *predoc, LPCSTR szFile) <br>{ <br>DWORD dwError; <br> <br>if(!szFile || !*szFile) <br>goto no_file; <br> <br>if((dwError = ReadREDoc(predoc, szFile, NULL, 0, FALSE))) <br>{ <br>TCHAR szErr[300]; <br> <br>wsprintf(szErr, TEXT("Error opening %s [%ld]"), szFile, dwError); <br>MessageBoxA(hwndMain, szErr, NULL, MB_OK); <br>goto no_file; <br>} <br> <br>if(fPrint) <br>{ <br>PrintREDoc(predoc); <br>PostQuitMessage(0); <br>} <br>else <br>{ <br>TCHAR szT[256]; <br> <br>wsprintf(szT, szFmtTitle, predoc-&gt;szTitle); <br>SetWindowText(predoc-&gt;hwndParent, szT); <br> <br>SetMenu(hwndMain, hmenuFull); <br>SetupWordWrapMenu(predoc); <br>DrawMenuBar(hwndMain); <br>} <br> <br>#ifdef TIME_OPEN <br>PostMessage(hwndMain, WM_CLOSE, 0, 0); <br>#endif// TIME_OPEN <br> <br>return 0; <br> <br>no_file: <br>if(NewREDoc(predoc, fFalse, fTrue) &lt; 0) <br>{ <br>SetMenu(hwndMain, hmenuLoaded); <br>} <br>else <br>{ <br>SetMenu(hwndMain, hmenuFull); <br>SetupWordWrapMenu(predoc); <br>} <br>DrawMenuBar(hwndMain); <br> <br>return 0; <br>} <br> <br> <br>LOCAL VOID ResizeRedoc(REDOC *predoc, RECT rc) <br>{ <br>RECT rcParent; <br>#ifndef NO_OLE <br>LPOLEINPLACEACTIVEOBJECT pipaobj = NULL; <br>#endif// NO_OLE <br> <br>GetClientRect(predoc-&gt;hwndParent, &amp;rcParent); <br>InflateRect(&amp;rcParent, dxRESize, dyRESize); <br> <br>// If we have a format bar, take it into account <br>if(predoc-&gt;hwndFormatBar) <br>{ <br>RECT rcFmtBar; <br> <br>GetClientRect(predoc-&gt;hwndFormatBar, &amp;rcFmtBar); <br>rcParent.top += rcFmtBar.bottom; <br>} <br>rc.top = max(rcParent.top, rc.top); <br>rc.left = max(rcParent.left, rc.left); <br>rc.right = min(rcParent.right, rc.right); <br>rc.bottom = max(rc.bottom, rc.top + ptMinTrackSize.y); <br>rc.bottom = min(rcParent.bottom, rc.bottom); <br> <br>MoveWindow(predoc-&gt;hwndRE, rc.left, rc.top, rc.right - rc.left, <br>rc.bottom - rc.top, fTrue); <br> <br>if(GetMenuState(hmenuFull, IDM_SHOWMARGINS, MF_BYCOMMAND) &amp; MF_CHECKED) <br>{ <br>rc.bottom -= rc.top; <br>rc.right -= rc.left; <br> <br>rc.top = 20; <br>rc.bottom -= 30; <br>if(rc.bottom &lt; rc.top) <br>rc.bottom = rc.top; <br>rc.left = 30; <br>rc.right -= 30; <br>if(rc.right &lt; rc.left) <br>rc.right = rc.left; <br>SendMessage(predoc-&gt;hwndRE, EM_SETRECT, 0, (LPARAM) &amp;rc); <br>} <br> <br>// Notify in place active object of resize <br>// <br>// NOTE : Do not change the following line so that it uses an &amp;&amp; <br>// operation, this causes the Mac to lock up since the compiler <br>// apparently checks the second half of an AND regardless of the <br>// initial half's value. <br> <br>#ifndef NO_OLE <br>if(predoc-&gt;pitpcall &amp;&amp; (pipaobj = predoc-&gt;pitpcall-&gt;pipframe-&gt;pipaobj)) <br>{ <br>TraceTag(tagInPlace, "ResizeBorder"); <br>GetClientRect(hwndMain, &amp;rc); <br># ifdef MAC <br>pipaobj-&gt;lpVtbl-&gt;ResizeBorder(pipaobj, (RectPtr) &amp;rc, <br>  (LPOLEINPLACEUIWINDOW) predoc-&gt;pitpcall-&gt;pipframe, TRUE); <br>// Throw out the mem <br># else// MAC <br>pipaobj-&gt;lpVtbl-&gt;ResizeBorder(pipaobj, &amp;rc,  <br>   (LPOLEINPLACEUIWINDOW) predoc-&gt;pitpcall-&gt;pipframe, TRUE); <br># endif// MAC, else <br>} <br>#endif // !NO_OLE <br>} <br> <br> <br>LOCAL VOID SetupMenu(REDOC *predoc, int iMenu, HMENU hmenu) <br>{ <br>DWORD dw; <br>LPOLEOBJECT poleobj = NULL; <br> <br>switch(iMenu) <br>{ <br>case 0:// file <br>if(!predoc-&gt;szFile[0]) <br>dw = 0; <br>else <br>dw = (DWORD) SendMessage(predoc-&gt;hwndRE, EM_GETMODIFY, 0, 0); <br>EnableMenuItem(hmenu, IDM_REVERT, dw ? uiMFEnabled : uiMFDisabled); <br>EnableMenuItem(hmenu, IDM_SAVE, predoc-&gt;fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>break; <br> <br>case 1:// edit <br> <br>dw = uiMFDisabled; <br>// see if something can be pasted <br>// let RichEdit figure out if it's read-only <br>if(SendMessage(predoc-&gt;hwndRE, EM_CANPASTE, 0, 0)) <br>dw = uiMFEnabled; <br>EnableMenuItem(hmenu, IDM_PASTE, (UINT) dw); <br> <br>dw = 0; <br>if(!predoc-&gt;fReadOnly) <br>dw = (DWORD) SendMessage(predoc-&gt;hwndRE, EM_CANUNDO, 0, 0); <br>EnableMenuItem(hmenu, IDM_UNDO, dw ? uiMFEnabled : uiMFDisabled); <br> <br>//$ REVIEW: use EN_SELCHANGE? <br>dw = (DWORD) SendMessage(predoc-&gt;hwndRE, EM_SELECTIONTYPE, 0, 0); <br>EnableMenuItem(hmenu, IDM_COPY, dw ? uiMFEnabled : uiMFDisabled); <br>#ifdef DEBUG <br>if(predoc-&gt;fReadOnly &amp;&amp; !QueryCheck(predoc, IDM_ENABLECUTREADONLY)) <br>dw = 0; <br>EnableMenuItem(hmenu, IDM_CUT, dw ? uiMFEnabled : uiMFDisabled); <br>if(predoc-&gt;fReadOnly) <br>dw = 0; <br>#else// DEBUG <br>if(predoc-&gt;fReadOnly) <br>dw = 0; <br>EnableMenuItem(hmenu, IDM_CUT, dw ? uiMFEnabled : uiMFDisabled); <br>#endif// DEBUG, else <br>EnableMenuItem(hmenu, IDM_DELETE, dw ? uiMFEnabled : uiMFDisabled); <br> <br>EnableMenuItem(hmenu, IDM_INSOBJ, predoc-&gt;fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>EnableMenuItem(hmenu, IDM_REPLACE, predoc-&gt;fReadOnly ? <br>uiMFDisabled : uiMFEnabled); <br> <br> <br>// That's all we need to do <br>if(!predoc-&gt;fUpdateEditMenu) <br>break; <br> <br>#ifndef NO_OLE <br>// Find out if we have a single object to deal with <br>if(!(dw ^ SEL_OBJECT)) <br>{ <br>REOBJECT reobj = { 0 }; <br> <br>reobj.cbStruct = sizeof(REOBJECT); <br>reobj.cp = REO_CP_SELECTION; <br> <br>if(!predoc-&gt;preole-&gt;lpVtbl-&gt;GetObject(predoc-&gt;preole, <br>REO_IOB_USE_CP, &amp;reobj, <br>REO_GETOBJ_POLEOBJ)) <br>{ <br>poleobj = reobj.poleobj; <br>} <br>} <br>// Ask OLE to build the menu for us <br> <br># ifdef MAC <br>//$ FUTURE MAC <br>dw = IDM_OBJECTCONVERT; <br>#  ifdef NEVER <br>macMenu1 = CheckoutMenu(hmenu, 2); <br>if(!macMenu1) <br>DebugStr("\pCheckoutMenu(macMenu1) failed"); <br>macMenu2 = CheckoutMenu(predoc-&gt;hmenuVerbs, 2); <br>if(!macMenu2) <br>DebugStr("\pCheckoutMenu(macMenu2) failed"); <br> <br>if(!OleUIAddVerbMenu(poleobj, <br>NULL,// Ask OLE to look up the name for us <br>macMenu1, predoc-&gt;hmenuVerbs, ipos_Object, <br>TRUE, (short *) &amp;dw)) <br>{ <br>DebugStr("\pOleUIAddVerbMenu failed!"); <br>} <br>CheckinMenu(hmenu, 2); <br>CheckinMenu(predoc-&gt;hmenuVerbs, 2); <br>#  endif// NEVER <br># else// MAC <br>OleUIAddVerbMenu(poleobj, <br>NULL,// Ask OLE to look up the name for us <br>hmenu, ipos_Object, IDM_OBJECTMIN,  <br>0, TRUE, IDM_OBJECTCONVERT, &amp;predoc-&gt;hmenuVerbs); <br># endif// MAC, else <br> <br>if(poleobj) <br>poleobj-&gt;lpVtbl-&gt;Release(poleobj); <br>#endif // !NO_OLE <br>// We don't have to do all this hard work again unless the user leaves the <br>// menu <br>predoc-&gt;fUpdateEditMenu = FALSE; <br>break; <br> <br>case 2:// format <br>{ <br>BOOL fReadOnly = !!predoc-&gt;fReadOnly; <br>UINT uiSuperscript = MF_UNCHECKED; <br>UINT uiSubscript = MF_UNCHECKED; <br>UINT uiProtected = MF_UNCHECKED; <br>UINT uiLeft = MF_UNCHECKED; <br>UINT uiCenter = MF_UNCHECKED; <br>UINT uiRight = MF_UNCHECKED; <br>UINT uiFirstIndent = MF_UNCHECKED; <br>UINT uiFirstOutdent = MF_UNCHECKED; <br>CHARFORMAT cf; <br>PARAFORMAT pf; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br>pf.cbSize = sizeof(PARAFORMAT); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_GETCHARFORMAT, fTrue, (LPARAM) &amp;cf); <br>if(cf.yOffset &gt; 0) <br>uiSuperscript = MF_CHECKED; <br>else if(cf.yOffset &lt; 0) <br>uiSubscript = MF_CHECKED; <br>if(cf.dwEffects &amp; CFE_PROTECTED) <br>uiProtected = MF_CHECKED; <br> <br>SendMessage(predoc-&gt;hwndRE, EM_GETPARAFORMAT, 0, (LPARAM) &amp;pf); <br>if(!pf.wAlignment || pf.wAlignment == PFA_LEFT) <br>uiLeft = MF_CHECKED; <br>else if(pf.wAlignment == PFA_CENTER) <br>uiCenter = MF_CHECKED; <br>else <br>uiRight = MF_CHECKED; <br>if(pf.dxOffset &lt; 0) <br>uiFirstIndent = MF_CHECKED; <br>else if(pf.dxOffset &gt; 0) <br>uiFirstOutdent = MF_CHECKED; <br> <br>CheckMenuItem(hmenu, IDM_SUPERSCRIPT, uiSuperscript); <br>CheckMenuItem(hmenu, IDM_SUBSCRIPT, uiSubscript); <br>CheckMenuItem(hmenu, IDM_PROTECTED, uiProtected); <br>CheckMenuItem(hmenu, IDM_ALIGNLEFT, uiLeft); <br>CheckMenuItem(hmenu, IDM_ALIGNCENTER, uiCenter); <br>CheckMenuItem(hmenu, IDM_ALIGNRIGHT, uiRight); <br>CheckMenuItem(hmenu, IDM_INDENTFIRST, uiFirstIndent); <br>CheckMenuItem(hmenu, IDM_OUTDENTFIRST, uiFirstOutdent); <br> <br>EnableMenuItem(hmenu, IDM_CHARFORMAT, fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>EnableMenuItem(hmenu, IDM_SUPERSCRIPT, fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>EnableMenuItem(hmenu, IDM_SUBSCRIPT, fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>EnableMenuItem(hmenu, IDM_ALIGNLEFT, fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>EnableMenuItem(hmenu, IDM_ALIGNCENTER, fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>EnableMenuItem(hmenu, IDM_ALIGNRIGHT, fReadOnly <br>? uiMFDisabled : uiMFEnabled); </code></pre>
<p>
</p>
<pre><code>EnableMenuItem(hmenu, IDM_INDENTFIRST, fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>EnableMenuItem(hmenu, IDM_OUTDENTFIRST, fReadOnly <br>? uiMFDisabled : uiMFEnabled); <br>} <br>break; <br> <br>case 3:// options <br>{ <br>const DWORD eco = SendMessage(predoc-&gt;hwndRE, EM_GETOPTIONS, 0, 0); <br>UINT uiSelBar = MF_UNCHECKED; <br>UINT uiAutoWordSel = MF_UNCHECKED; <br>#ifdef DEBUG <br>UINT uiReadOnly = MF_UNCHECKED; <br>UINT uiAutoHScroll = MF_UNCHECKED; <br>UINT uiAutoVScroll = MF_UNCHECKED; <br>UINT uiAutoHideSel = MF_UNCHECKED; <br>#endif// DEBUG <br> <br>if(eco &amp; ECO_SELECTIONBAR) <br>uiSelBar = MF_CHECKED; <br>if(eco &amp; ECO_AUTOWORDSELECTION) <br>uiAutoWordSel = MF_CHECKED; <br>#ifdef DEBUG <br>if(eco &amp; ECO_READONLY) <br>uiReadOnly = MF_CHECKED; <br>if(eco &amp; ECO_AUTOHSCROLL) <br>uiAutoHScroll = MF_CHECKED; <br>if(eco &amp; ECO_AUTOVSCROLL) <br>uiAutoVScroll = MF_CHECKED; <br>if(!(eco &amp; ECO_NOHIDESEL)) <br>uiAutoHideSel = MF_CHECKED; <br>#endif// DEBUG <br> <br>CheckMenuItem(hmenu, IDM_SELBAR, uiSelBar); <br>CheckMenuItem(hmenu, IDM_AUTOWORDSEL, uiAutoWordSel); <br>#ifdef DEBUG <br>CheckMenuItem(hmenu, IDM_READONLY, uiReadOnly); <br>CheckMenuItem(hmenu, IDM_AUTOHSCROLL, uiAutoHScroll); <br>CheckMenuItem(hmenu, IDM_AUTOVSCROLL, uiAutoVScroll); <br>CheckMenuItem(hmenu, IDM_AUTOHIDESEL, uiAutoHideSel); <br>#endif// DEBUG <br>} <br>break; <br> <br>} <br>} <br> <br> <br>LOCAL LRESULT HandleCommand(REDOC *predoc, HWND hwnd, WPARAM wparam, <br>LPARAM lparam) <br>{ <br>LRESULT lres = 0; <br>INTnID; <br> <br>if(GET_WM_COMMAND_HWND(wparam, lparam) == predoc-&gt;hwndRE &amp;&amp; predoc-&gt;hwndRE) <br>{ <br>WORD wNotification = GET_WM_COMMAND_CMD(wparam, lparam); <br>ASSENSZ *passensz; <br> <br>switch(wNotification) <br>{ <br>case EN_CHANGE: <br>if(predoc-&gt;hwndFormatBar) <br>UpdateFormatBar(predoc); <br>break; <br> <br>case EN_ERRSPACE: <br>if(fErrSpace) <br>break; <br>fErrSpace = fTrue; <br>// fall through to default <br> <br>default: <br>for(passensz = rgassenszErrors; passensz-&gt;szDescription; passensz++) <br>{ <br>if(passensz-&gt;wNotification == wNotification) <br>{ <br>MessageBeep(0); <br>MessageBoxA(hwndMain, passensz-&gt;szDescription, NULL, <br>MB_ICONSTOP | MB_OK); <br>return 0; <br>} <br>} <br>break; <br>} <br>return 0; <br>} <br> <br>fErrSpace = fFalse; <br> <br>nID = GET_WM_COMMAND_ID(wparam, lparam); <br>switch(nID) <br>{ <br>#ifdef DEBUG <br>case IDM_CLSDBG: <br>ClearDebugScreen(); <br>break; <br> <br>case IDM_TRACEDLG: <br>DoTagsDialog(); <br>break; <br>#endif// DEBUG <br> <br>case IDM_NEW: <br>lres = NewREDoc(predoc, fTrue, fTrue); <br>#ifdef DEBUG <br>if(predoc-&gt;hwndRE) <br>SendMessage(predoc-&gt;hwndRE, EM_REQUESTRESIZE, 0, 0); <br>#endif// DEBUG <br>break; <br> <br>case IDM_OPEN: <br>lres = OpenREDoc(predoc, FALSE); <br>break; <br> <br>case IDM_REVERT: <br>lres = RevertREDoc(predoc); <br>break; <br> <br>case IDM_PRINT: <br>PrintREDoc(predoc); <br>break; <br> <br>case IDM_PRINTPREVIEW: <br>DialogBoxParam(HinstFromHwnd(hwndMain), TEXT("PRINTPREVIEW"), hwndMain, <br>(DLGPROC) PPDlgProc, (LPARAM) predoc); <br>break; <br> <br>case IDM_PRINTSETUP: <br>predoc-&gt;pd.lStructSize = sizeof(PRINTDLG); <br>predoc-&gt;pd.Flags = PD_PRINTSETUP; <br>if(PrintDlg(&amp;predoc-&gt;pd) &amp;&amp; predoc-&gt;fWysiwyg) <br>{ <br>// illegal values to force SetWordWrap() to do something <br>predoc-&gt;fWrap = fFalse; <br>predoc-&gt;fWysiwyg = fTrue; <br>SetWordWrap(predoc, fTrue, fTrue); <br>} <br>break; <br> <br>case IDM_EXIT: <br>PostMessage(hwndMain, WM_CLOSE, 0, 0); <br>return 0; <br> <br>case IDM_CLOSE: <br>return CloseREDoc(predoc, fTrue, fTrue); <br> <br>case IDM_SAVE: <br>lres = SaveREDoc(predoc); <br>break; <br> <br>case IDM_SAVEAS: <br>lres = SaveREDocAs(predoc, FALSE); <br>break; <br> <br>case IDM_UNDO: <br>lres = SendMessage(predoc-&gt;hwndRE, EM_UNDO, 0, 0); <br>break; <br> <br>case IDM_CUT: <br>lres = SendMessage(predoc-&gt;hwndRE, WM_CUT, 0, 0); <br>break; <br> <br>case IDM_COPY: <br>lres = SendMessage(predoc-&gt;hwndRE, WM_COPY, 0, 0); <br>break; <br> <br>case IDM_PASTE: <br>lres = SendMessage(predoc-&gt;hwndRE, WM_PASTE, 0, 0); <br>break; <br> <br>case IDM_PASTESPECIAL: <br>NYI("Paste special"); <br>break; <br> <br>case IDM_DELETE: <br>lres = SendMessage(predoc-&gt;hwndRE, WM_KEYDOWN, <br>(WPARAM) VK_DELETE, 0); <br>break; <br> <br>case IDM_SELECTALL: <br>lres = SendMessage(predoc-&gt;hwndRE, EM_SETSEL, 0, (LPARAM) -1); <br>break; <br> <br>case IDM_FIND: <br>FindReplace(predoc, fFalse); <br>break; <br> <br>case IDM_REPLACE: <br>FindReplace(predoc, fTrue); <br>break; <br> <br>case IDM_OBJECT: <br>NYI("Object"); <br>break; <br> <br>case IDM_OBJECTCONVERT: <br>NYI("Object Convert"); <br>break; <br> <br>case IDM_INSOBJ: <br>return InsertObject(predoc); <br> <br>case IDM_INSFILE: <br>lres = OpenREDoc(predoc, TRUE); <br>break; <br> <br>case IDM_SAVESEL: <br>lres = SaveREDocAs(predoc, TRUE); <br>break; <br> <br>case IDM_CHARFORMAT: <br>SelectCharFormat(predoc); <br>break; <br> <br>case IDM_APPLYTOWORD: <br>predoc-&gt;scf = SCF_SELECTION; <br>if(ToggleCheck(predoc, IDM_APPLYTOWORD)) <br>predoc-&gt;scf |= SCF_WORD; <br>break; <br> <br>case IDM_SUPERSCRIPT: <br>SetOffset(predoc, fTrue); <br>break; <br> <br>case IDM_SUBSCRIPT: <br>SetOffset(predoc, fFalse); <br>break; <br> <br>case IDM_ALIGNLEFT: <br>SetAlignment(predoc, PFA_LEFT); <br>break; <br> <br>case IDM_ALIGNCENTER: <br>SetAlignment(predoc, PFA_CENTER); <br>break; <br> <br>case IDM_ALIGNRIGHT: <br>SetAlignment(predoc, PFA_RIGHT); <br>break; <br> <br>case IDM_INDENTFIRST: <br>IndentFirst(predoc, fTrue); <br>break; <br> <br>case IDM_OUTDENTFIRST: <br>IndentFirst(predoc, fFalse); <br>break; <br> <br>case IDM_MARGINS: <br>NYI("set margins"); <br>break; <br> <br>case IDM_TABS: <br>NYI("set tabs"); <br>break; <br> <br>case IDM_PROTECTED: <br>ProtectSelection(predoc); <br>break; <br> <br>case IDM_NOWRAP: <br>SetWordWrap(predoc, fFalse, fFalse); <br>break; <br> <br>case IDM_WRAP: <br>SetWordWrap(predoc, fFalse, fTrue); <br>break; <br> <br>case IDM_WYSIWYG: <br>SetWordWrap(predoc, fTrue, fTrue); <br>break; <br> <br>case IDM_SELBAR: <br>SendMessage(predoc-&gt;hwndRE, EM_SETOPTIONS, ECOOP_XOR, ECO_SELECTIONBAR); <br>ToggleCheck(predoc, IDM_SELBAR); <br>break; <br> <br>case IDM_AUTOWORDSEL: <br>SendMessage(predoc-&gt;hwndRE, EM_SETOPTIONS, ECOOP_XOR, ECO_AUTOWORDSELECTION); <br>ToggleCheck(predoc, IDM_AUTOWORDSEL); <br>break; <br> <br>case IDM_SHOWMARGINS: <br>ShowMargins(predoc); <br>break; <br> <br>#ifdef DEBUG <br>case IDM_READONLY: <br>SendMessage(predoc-&gt;hwndRE, EM_SETOPTIONS, ECOOP_XOR, ECO_READONLY); <br>predoc-&gt;fReadOnly = !!ToggleCheck(predoc, IDM_READONLY); <br>EnableWindow(predoc-&gt;hwndFormatBar, !predoc-&gt;fReadOnly); <br>break; <br> <br>case IDM_AUTOHSCROLL: <br>SendMessage(predoc-&gt;hwndRE, EM_SETOPTIONS, ECOOP_XOR, ECO_AUTOHSCROLL); <br>ToggleCheck(predoc, IDM_AUTOHSCROLL); <br>break; <br> <br>case IDM_AUTOVSCROLL: <br>SendMessage(predoc-&gt;hwndRE, EM_SETOPTIONS, ECOOP_XOR, ECO_AUTOVSCROLL); <br>ToggleCheck(predoc, IDM_AUTOVSCROLL); <br>break; <br> <br>case IDM_AUTOHIDESEL: <br>SendMessage(predoc-&gt;hwndRE, EM_SETOPTIONS, ECOOP_XOR, ECO_NOHIDESEL); <br>ToggleCheck(predoc, IDM_AUTOHIDESEL); <br>break; <br>#endif// DEBUG <br> <br>case IDM_GOTOCURSOR: <br>{ <br>CHARRANGE cr; <br>POINT pt; <br> <br>GetCursorPos(&amp;pt); <br>ScreenToClient(predoc-&gt;hwndRE, &amp;pt); <br>cr.cpMin = SendMessage(predoc-&gt;hwndRE, EM_CHARFROMPOS, 0, <br>(LPARAM) &amp;pt); <br>cr.cpMost = cr.cpMin; <br>SendMessage(predoc-&gt;hwndRE, EM_EXSETSEL, 0, (LPARAM) &amp;cr); <br>} <br>break; <br> <br>case IDM_MOVECURSOR: <br>{ <br>CHARRANGE cr; <br>POINT pt; <br> <br>SendMessage(predoc-&gt;hwndRE, EM_EXGETSEL, 0, (LPARAM) &amp;cr); <br>SendMessage(predoc-&gt;hwndRE, EM_POSFROMCHAR, (WPARAM) &amp;pt, cr.cpMin); <br>ClientToScreen(predoc-&gt;hwndRE, &amp;pt); <br>SetCursorPos(pt.x, pt.y); <br>} <br>break; <br> <br>case TBI_IncreaseIndent: <br>case TBI_DecreaseIndent: <br>if(predoc-&gt;fReadOnly) <br>{ <br>MessageBeep(0); <br>} <br>else <br>{ <br>PARAFORMAT pf; <br> <br>pf.cbSize = sizeof(PARAFORMAT); <br> <br>if(GetFocus() == predoc-&gt;hwndFormatBar) <br>SetFocus(predoc-&gt;hwndRE); <br>pf.dwMask = PFM_OFFSETINDENT; <br>pf.dxStartIndent = (nID == TBI_IncreaseIndent) <br>? cxBulletIndent <br>: -cxBulletIndent; <br>if(!SendMessage(predoc-&gt;hwndRE, EM_SETPARAFORMAT, FALSE, <br>(LPARAM) &amp;pf)) <br>{ <br>MessageBeep(0); <br>} <br>} <br>break; <br> <br>case TBI_Name: <br>case TBI_Size: <br>case TBI_Bold: <br>case TBI_Italic: <br>case TBI_Underline: <br>case TBI_Color: <br>{ <br>CHARFORMAT cf; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br>if(GetFocus() == predoc-&gt;hwndFormatBar) <br>SetFocus(predoc-&gt;hwndRE); <br>SendMessage(predoc-&gt;hwndFormatBar, EM_GETCHARFORMAT, 0, <br>(LPARAM) &amp;cf); <br>SendMessage(predoc-&gt;hwndRE, EM_SETCHARFORMAT, predoc-&gt;scf, <br>(LPARAM) &amp;cf); <br>} <br>break; <br> <br>case TBI_AccelBold: <br>case TBI_AccelItalic: <br>case TBI_AccelUnderline: <br>{ <br>CHARFORMAT cf; <br>DWORD dwEffects; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br>SendMessage(predoc-&gt;hwndFormatBar, EM_GETCHARFORMAT, 0, <br>(LPARAM) &amp;cf); <br>switch (nID) <br>{ <br>case TBI_AccelBold: <br>dwEffects = CFE_BOLD; <br>break; <br>case TBI_AccelItalic: <br>dwEffects = CFE_ITALIC; <br>break; <br>case TBI_AccelUnderline: <br>dwEffects = CFE_UNDERLINE; <br>break; <br>} <br> <br>cf.dwMask |= dwEffects; <br>cf.dwEffects ^= dwEffects; <br> <br>if(GetFocus() == predoc-&gt;hwndFormatBar) <br>SetFocus(predoc-&gt;hwndRE); <br>SendMessage(predoc-&gt;hwndFormatBar, EM_SETCHARFORMAT, predoc-&gt;scf, <br>(LPARAM) &amp;cf); <br>SendMessage(predoc-&gt;hwndRE, EM_SETCHARFORMAT, predoc-&gt;scf, <br>(LPARAM) &amp;cf); <br>} <br>break; <br> <br>case TBI_Bullet: <br>case TBI_Left: <br>case TBI_Center: <br>case TBI_Right: <br>{ <br>PARAFORMAT pf; <br> <br>pf.cbSize = sizeof(PARAFORMAT); <br> <br>if(GetFocus() == predoc-&gt;hwndFormatBar) <br>SetFocus(predoc-&gt;hwndRE); <br>SendMessage(predoc-&gt;hwndFormatBar, EM_GETPARAFORMAT, 0, <br>(LPARAM) &amp;pf); <br>SendMessage(predoc-&gt;hwndRE, EM_SETPARAFORMAT, FALSE, (LPARAM) &amp;pf); <br>} <br>break; <br> <br> <br>#ifdef DEBUG <br>case IDM_DBGPED: <br>SendMessage(predoc-&gt;hwndRE, EM_DBGPED, 0, 0); <br>break; <br> <br>case IDM_GETTEXT: <br>return GetText(predoc); <br> <br>case IDM_IGNORELEFTCLICK: <br>IgnoreLeftClick(predoc); <br>break; <br> <br>case IDM_EATES: <br>EatEs(predoc); <br>break; <br> <br>case IDM_BOTTOMLESS: <br>Bottomless(predoc); <br>break; <br> <br>case IDM_IGNOREDROPS: <br>case IDM_TEXTONLY: <br>case IDM_REFUSEGRAPH: <br>case IDM_PPMETA: <br>case IDM_ENABLECUTREADONLY: <br>case IDM_ENABLEPASTEREADONLY: <br>case IDM_ENABLEDRAGREADONLY: <br>case IDM_SWAPDRAGEFFECT: <br>ToggleCheck(predoc, nID); <br>break; <br> <br>case IDM_HIDE: <br>ShowWindow(predoc-&gt;hwndRE, ToggleCheck(predoc, IDM_HIDE) ? SW_HIDE : SW_SHOW); <br>break; <br> <br>case IDM_PASTEPLAINTEXT: <br>lres = SendMessage(predoc-&gt;hwndRE, EM_PASTESPECIAL, CF_TEXT, 0); <br>break; <br> <br>case IDM_PASTETXTOBJ: <br>lres = SendMessage(predoc-&gt;hwndRE, EM_PASTESPECIAL, cfTxtObj, 0); <br>break; <br> <br>case IDM_PASTERTFASTEXT: <br>lres = SendMessage(predoc-&gt;hwndRE, EM_PASTESPECIAL, cfRTFAsText, 0); <br>break; <br> <br>case IDM_BIGLIMIT: <br>SetLimit(predoc); <br>break; <br> <br>case IDM_FILLERUP: <br>FillerUp(predoc); <br>break; <br>#endif// DEBUG <br> <br>default: <br>// Pass through OLE verbs <br>if(nID &gt;= IDM_OBJECTMIN) <br>{ <br>DoVerb(predoc, nID - IDM_OBJECTMIN); <br>} <br>return DefWindowProc(hwnd, WM_COMMAND, wparam, lparam); <br>} <br> <br>return lres; <br>} <br> <br> <br>VOID DoVerb(REDOC * predoc, INT ioleverb) <br>{ <br>REOBJECT reobj = { 0 }; <br>POINT pt; <br>RECT rc = { 0 }; <br> <br>reobj.cbStruct = sizeof(REOBJECT); <br>if(predoc-&gt;preole-&gt;lpVtbl-&gt;GetObject(predoc-&gt;preole, REO_IOB_SELECTION, <br>&amp;reobj, <br>REO_GETOBJ_POLESITE | <br>REO_GETOBJ_POLEOBJ)) <br>{ <br>AssertSz(FALSE, "DoVerb without object"); <br>} <br> <br>SendMessage(predoc-&gt;hwndRE, EM_POSFROMCHAR, (WPARAM) &amp;pt, reobj.cp); <br> <br>XformSizeInHimetricToPixels(NULL, &amp;reobj.sizel, &amp;reobj.sizel); <br>rc.right = (INT) reobj.sizel.cx; <br>rc.bottom = (INT) reobj.sizel.cy; <br>OffsetRect(&amp;rc, pt.x, pt.y); <br> <br>reobj.poleobj-&gt;lpVtbl-&gt;DoVerb(reobj.poleobj, ioleverb, NULL, <br>reobj.polesite, 0, predoc-&gt;hwndRE, &amp;rc); <br>reobj.poleobj-&gt;lpVtbl-&gt;Release(reobj.poleobj); <br>reobj.polesite-&gt;lpVtbl-&gt;Release(reobj.polesite); <br> <br>} <br> <br> <br>#ifdef DEBUG <br> <br>LOCAL VOID IgnoreLeftClick(REDOC *predoc) <br>{ <br>HMENU hmenu = GetMenu(hwndMain); <br>UINT uiMenuFlags; <br>DWORD dwMask; <br> <br>Assert(predoc-&gt;hwndRE); <br> <br>dwMask = SendMessage(predoc-&gt;hwndRE, EM_GETEVENTMASK, 0, 0); <br>uiMenuFlags = GetMenuState(hmenu, IDM_IGNORELEFTCLICK, MF_BYCOMMAND); <br>if(uiMenuFlags &amp; MF_CHECKED) <br>dwMask &amp;= ~ENM_MOUSEEVENTS; <br>else <br>dwMask |= ENM_MOUSEEVENTS; <br>uiMenuFlags ^= MF_CHECKED; <br>CheckMenuItem(hmenu, IDM_IGNORELEFTCLICK, MF_BYCOMMAND | <br>(uiMenuFlags &amp; MF_CHECKED)); <br>SendMessage(predoc-&gt;hwndRE, EM_SETEVENTMASK, 0, dwMask); <br>} <br> <br> <br>LOCAL VOID EatEs(REDOC *predoc) <br>{ <br>HMENU hmenu = GetMenu(hwndMain); <br>UINT uiMenuFlags; <br>DWORD dwMask; <br> <br>Assert(predoc-&gt;hwndRE); <br> <br>dwMask = SendMessage(predoc-&gt;hwndRE, EM_GETEVENTMASK, 0, 0); <br>uiMenuFlags = GetMenuState(hmenu, IDM_EATES, MF_BYCOMMAND); <br>if(uiMenuFlags &amp; MF_CHECKED) <br>dwMask &amp;= ~ENM_KEYEVENTS; <br>else <br>dwMask |= ENM_KEYEVENTS; <br>uiMenuFlags ^= MF_CHECKED; <br>CheckMenuItem(hmenu, IDM_EATES, MF_BYCOMMAND | (uiMenuFlags &amp; MF_CHECKED)); <br>SendMessage(predoc-&gt;hwndRE, EM_SETEVENTMASK, 0, dwMask); <br>} <br> <br> <br>LOCAL VOID Bottomless(REDOC *predoc) <br>{ <br>HMENU hmenu = GetMenu(hwndMain); <br>UINT uiMenuFlags; <br>DWORD dwMask; <br> <br>Assert(predoc-&gt;hwndRE); <br> <br>dwMask = SendMessage(predoc-&gt;hwndRE, EM_GETEVENTMASK, 0, 0); <br>uiMenuFlags = GetMenuState(hmenu, IDM_BOTTOMLESS, MF_BYCOMMAND); <br>if(uiMenuFlags &amp; MF_CHECKED) <br>dwMask &amp;= ~ENM_REQUESTRESIZE; <br>else <br>dwMask |= ENM_REQUESTRESIZE; <br>uiMenuFlags ^= MF_CHECKED; <br>CheckMenuItem(hmenu, IDM_BOTTOMLESS, <br>MF_BYCOMMAND | (uiMenuFlags &amp; MF_CHECKED)); <br>SendMessage(predoc-&gt;hwndRE, EM_SETEVENTMASK, 0, dwMask); <br>if(dwMask &amp; ENM_REQUESTRESIZE) <br>{ <br>SendMessage(predoc-&gt;hwndRE, EM_REQUESTRESIZE, 0, 0); <br>} <br>else <br>{ <br>RECT rc; <br> <br>GetClientRect(predoc-&gt;hwndParent, &amp;rc); <br>ResizeRedoc(predoc, rc); <br>} <br>} <br> <br>#endif// DEBUG <br> <br> <br>LOCAL BOOL ToggleCheck(REDOC *predoc, UINT uiMenuid) <br>{ <br>HMENU hmenu = GetMenu(hwndMain); <br>UINT uiMenuFlags; <br> <br>Assert(predoc-&gt;hwndRE); <br> <br>uiMenuFlags = GetMenuState(hmenu, uiMenuid, MF_BYCOMMAND); <br>uiMenuFlags ^= MF_CHECKED; <br>CheckMenuItem(hmenu, uiMenuid, MF_BYCOMMAND | (uiMenuFlags &amp; MF_CHECKED)); <br> <br>return !!(uiMenuFlags &amp; MF_CHECKED); <br>} <br> <br> <br>LOCAL BOOL QueryCheck(REDOC *predoc, UINT uiMenuid) <br>{ <br>HMENU hmenu = GetMenu(hwndMain); <br>UINT uiMenuFlags; <br> <br>Assert(predoc-&gt;hwndRE); <br>if(!hmenu) <br>return fFalse; <br> <br>uiMenuFlags = GetMenuState(hmenu, uiMenuid, MF_BYCOMMAND); <br> <br>return !!(uiMenuFlags &amp; MF_CHECKED); <br>} <br> <br> <br>LOCAL LRESULT NewREDoc(REDOC *predoc, BOOL fPrompt, BOOL fUpdateUI) <br>{ <br>RECT rc; <br>DWORD dwStyle; <br>if(predoc-&gt;hwndRE) <br>{ <br>PARAFORMAT pf = {0}; <br> <br>pf.cbSize = sizeof(PARAFORMAT); <br> <br>if(fPrompt &amp;&amp; CheckSave(predoc) &lt; 0) <br>return -1; <br>predoc-&gt;szFile[0] = TEXT('\0'); <br>lstrcpy(predoc-&gt;szTitle, szUntitled); <br>SetWindowText(predoc-&gt;hwndRE, TEXT("")); <br>pf.wAlignment = PFA_LEFT; <br>pf.cTabCount = 1; <br>pf.rgxTabs[0] = lDefaultTab; <br>pf.dwMask = PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET | <br>PFM_ALIGNMENT | PFM_TABSTOPS | PFM_NUMBERING; <br>SendMessage(predoc-&gt;hwndRE, EM_SETPARAFORMAT, 0, (LPARAM) &amp;pf); <br>SendMessage(predoc-&gt;hwndRE, EM_SETCHARFORMAT, 0, <br>(LPARAM) (LPVOID) &amp;cfDefault); <br>goto done; <br>} <br>else <br>{ <br>predoc-&gt;szFile[0] = TEXT('\0'); <br>lstrcpy(predoc-&gt;szTitle, szUntitled); <br>} <br>GetClientRect(predoc-&gt;hwndParent, &amp;rc); <br>InflateRect(&amp;rc, dxRESize, dyRESize); <br> <br>// Create and display the format bar <br>if(predoc-&gt;hwndFormatBar = HwndCreateFormatBar(predoc-&gt;hwndParent, <br>FBR_FormatBar, NULL)) <br>{ <br>RECT rcFormatBar; <br> <br>ShowWindow(predoc-&gt;hwndFormatBar, SW_SHOW); <br>GetClientRect(predoc-&gt;hwndFormatBar, &amp;rcFormatBar); <br>rc.top += rcFormatBar.bottom; <br>} <br> <br>#ifdef SUNKENRICHEDIT <br>dwStyle =  <br>ES_AUTOHSCROLL | <br>ES_AUTOVSCROLL | <br>//ES_DISABLENOSCROLL | <br>ES_MULTILINE | <br>//ES_NOHIDESEL | <br>ES_SAVESEL | <br>ES_SELECTIONBAR | <br>ES_SUNKEN | <br>//WS_BORDER | <br>WS_CHILD | <br>WS_CLIPCHILDREN | <br>WS_HSCROLL | <br>WS_VISIBLE | <br>WS_VSCROLL | <br>0;// zero gets or'd with above <br>predoc-&gt;hwndRE = CreateWindow(szClassRE, TEXT(""), <br>dwStyle, <br>rc.left, rc.top, <br>rc.right - rc.left,rc.bottom - rc.top, predoc-&gt;hwndParent, <br>NULL, HinstFromHwnd(predoc-&gt;hwndParent), NULL); <br> <br>#else// SUNKENRICHEDIT <br>ES_AUTOHSCROLL | <br>ES_AUTOVSCROLL | <br>//ES_DISABLENOSCROLL | <br>ES_MULTILINE | <br>//ES_NOHIDESEL | <br>ES_SAVESEL | <br>ES_SELECTIONBAR | <br>//ES_SUNKEN | <br>//WS_BORDER | <br>WS_CHILD | <br>WS_CLIPCHILDREN | <br>WS_HSCROLL | <br>WS_VISIBLE | <br>WS_VSCROLL | <br>0;// zero gets or'd with above <br>predoc-&gt;hwndRE = CreateWindow(szClassRE, TEXT(""), <br>dwStyle, <br>rc.left, rc.top, <br>rc.right - rc.left,rc.bottom - rc.top, predoc-&gt;hwndParent, <br>NULL, HinstFromHwnd(predoc-&gt;hwndParent), NULL); <br>#endif// SUNKENRICHEDIT, else <br>if(!predoc-&gt;hwndRE) <br>{ <br>MessageBoxA(hwndMain, "Unable to create a new document", NULL, MB_ICONSTOP | MB_OK); <br>return -1; <br>} <br>if(cchTextMost) <br>SendMessage(predoc-&gt;hwndRE, EM_EXLIMITTEXT, 0, cchTextMost); <br>#ifndef NO_OLE <br>DragAcceptFiles(predoc-&gt;hwndRE, TRUE); <br>#endif// !NO_OLE <br> <br> <br>// request EN_SELCHANGE, EN_CHANGE, EN_PROTECTED, and EN_DROPFILES <br>SendMessage(predoc-&gt;hwndRE, EM_SETEVENTMASK, 0, <br>ENM_SELCHANGE | ENM_CHANGE | ENM_PROTECTED | EN_DROPFILES | <br>ENM_CORRECTTEXT); <br> <br>SetFocus(predoc-&gt;hwndRE); <br> <br>predoc-&gt;scf = SCF_SELECTION; <br>if(GetMenu(hwndMain) &amp;&amp; QueryCheck(predoc, IDM_APPLYTOWORD)) <br>predoc-&gt;scf |= SCF_WORD; <br> <br>#ifndef NO_OLE <br>if(!SendMessage(predoc-&gt;hwndRE, EM_GETOLEINTERFACE, 0, (LPARAM) &amp;predoc-&gt;preole)) <br>{ <br>MessageBoxA(hwndMain, "No OLE interface!", NULL, MB_OK); <br>DestroyWindow(predoc-&gt;hwndRE); <br>predoc-&gt;hwndRE = 0; <br>return -1; <br>} <br> <br>if(!(predoc-&gt;pstg = OleStdCreateRootStorage(NULL, STGM_SHARE_EXCLUSIVE))) <br>{ <br>MessageBoxA(hwndMain, "No Storage!", NULL, MB_OK); <br>DestroyWindow(predoc-&gt;hwndRE); <br>predoc-&gt;hwndRE = 0; <br>return -1; <br>} <br> <br>if(!(predoc-&gt;pitpcall = ITPCALL_New(predoc))) <br>{ <br>MessageBoxA(hwndMain, "No callback object!", NULL, MB_OK); <br>DestroyWindow(predoc-&gt;hwndRE); <br>predoc-&gt;hwndRE = 0; <br>return -1; <br>} <br>SendMessage(predoc-&gt;hwndRE, EM_SETOLECALLBACK, 0, (LPARAM) predoc-&gt;pitpcall); <br>#endif// !NO_OLE <br> <br>done: <br>if(fUpdateUI) <br>{ <br>TCHAR szT[64]; <br> <br>wsprintf(szT, szFmtTitle, predoc-&gt;szTitle); <br>SetWindowText(predoc-&gt;hwndParent, szT); <br>SetMenu(hwndMain, hmenuFull); <br>DrawMenuBar(hwndMain); <br>} <br> <br>predoc-&gt;fReadOnly = fFalse; <br>EnableWindow(predoc-&gt;hwndFormatBar, TRUE); <br> <br>// illegal values to force SetWordWrap() to do something <br>predoc-&gt;fWrap = fFalse; <br>predoc-&gt;fWysiwyg = fTrue; <br>SetWordWrap(predoc, fWysiwygDefault, fWrapDefault); <br>// if we don't have a default font, use the windows variable width font <br>// otherwise, use the default font <br>if(cfDefault.dwMask == 0) <br>{ <br>SendMessage(predoc-&gt;hwndRE, WM_SETFONT, <br>(WPARAM) GetStockObject(ANSI_VAR_FONT), 0); <br>SendMessage(predoc-&gt;hwndRE, EM_GETCHARFORMAT, FALSE, <br>(LPARAM) (LPVOID) &amp;cfDefault); <br>} <br>else <br>{ <br>SendMessage(predoc-&gt;hwndRE, EM_SETCHARFORMAT, 0, <br>(LPARAM) (LPVOID) &amp;cfDefault); <br>} <br>SendMessage(predoc-&gt;hwndRE, EM_SETMODIFY, (WPARAM) fFalse, 0); <br>SendMessage(predoc-&gt;hwndRE, EM_SETREADONLY, (WPARAM) fFalse, 0); <br>UpdateFormatBar(predoc); <br> <br>return 0; <br>} <br> <br> <br>LOCAL LONG CheckSave(REDOC *predoc) <br>{ <br>int iMbid; <br>TCHAR szT[128]; <br> <br>#ifdef NO_SAVE_PROMPT <br>return 0; <br>#endif// NO_SAVE_PROMPT <br> <br>if(!SendMessage(predoc-&gt;hwndRE, EM_GETMODIFY, 0, 0)) <br>return 0; <br> <br>wsprintf(szT, TEXT("Save changes to %s?"), predoc-&gt;szTitle); <br>iMbid = MessageBox(hwndMain, szT, szAppName, MB_APPLMODAL | <br>MB_ICONQUESTION | MB_YESNOCANCEL); <br>switch(iMbid) <br>{ <br>case IDYES: <br>if(SaveREDoc(predoc) &lt; 0) <br>return -1; <br>break; <br> <br>case IDCANCEL: <br>return -1; <br>} <br>return 0; <br>} <br> <br> <br>// returns 0 if no changes have been made <br>// returns &gt; 0 if revert should continue <br>// returns &lt; 0 if revert should be aborted <br>LOCAL INT CheckRevert(REDOC *predoc) <br>{ <br>int iMbid; <br>TCHAR szT[128]; <br> <br>if(!SendMessage(predoc-&gt;hwndRE, EM_GETMODIFY, 0, 0)) <br>return 0; <br> <br>#ifdef NO_SAVE_PROMPT <br>return 1; <br>#endif// NO_SAVE_PROMPT <br> <br>wsprintf(szT, TEXT("Revert %s to last saved changes?"), predoc-&gt;szTitle); <br>iMbid = MessageBox(hwndMain, szT, szAppName, MB_APPLMODAL | <br>MB_ICONQUESTION | MB_YESNO); <br> <br>return iMbid == IDYES ? 1 : -1; <br>} <br> <br> <br>LOCAL LRESULT CloseREDoc(REDOC *predoc, BOOL fPrompt, BOOL fUpdateUI) <br>{ <br>if(fPrompt &amp;&amp; CheckSave(predoc) &lt; 0) <br>return -1; <br> <br>if(predoc-&gt;hdcTarget) <br>{ <br>DeleteDC(predoc-&gt;hdcTarget); <br>predoc-&gt;hdcTarget = 0; <br>} <br>#ifndef NO_OLE <br>// Deactivate any existing in place object <br>//$ FUTURE: This might be some generic I'm gonna close you call <br>predoc-&gt;preole-&gt;lpVtbl-&gt;InPlaceDeactivate(predoc-&gt;preole); <br>ITPCALL_Release((LPUNKNOWN) predoc-&gt;pitpcall); <br>predoc-&gt;pitpcall = NULL; <br>predoc-&gt;pstg-&gt;lpVtbl-&gt;Release(predoc-&gt;pstg); <br>predoc-&gt;pstg = NULL; <br>predoc-&gt;preole-&gt;lpVtbl-&gt;Release(predoc-&gt;preole); <br>predoc-&gt;preole = NULL; <br>predoc-&gt;cItem = 0; <br>#endif// !NO_OLE <br>DestroyWindow(predoc-&gt;hwndRE); <br>DestroyWindow(predoc-&gt;hwndFormatBar); <br> <br>predoc-&gt;hwndRE = 0; <br>predoc-&gt;szFile[0] = TEXT('\0'); <br>lstrcpy(predoc-&gt;szTitle, szUntitled); <br>predoc-&gt;dwFormat = SF_TEXT; <br>predoc-&gt;fReadOnly = fFalse; <br>EnableWindow(predoc-&gt;hwndFormatBar, TRUE); <br>#ifdef DEBUG <br>CheckMenuItem(hmenuFull, IDM_IGNORELEFTCLICK, MF_BYCOMMAND | MF_UNCHECKED); <br>CheckMenuItem(hmenuFull, IDM_EATES, MF_BYCOMMAND | MF_UNCHECKED); <br>CheckMenuItem(hmenuFull, IDM_IGNOREDROPS, MF_BYCOMMAND | MF_UNCHECKED); <br>CheckMenuItem(hmenuFull, IDM_BOTTOMLESS, MF_BYCOMMAND | MF_UNCHECKED); <br>CheckMenuItem(hmenuFull, IDM_TEXTONLY, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>if(hwndGT) <br>{ <br>DestroyWindow(hwndGT); <br>hwndGT = 0; <br>} <br>#endif// DEBUG <br> <br>if(fUpdateUI) <br>{ <br>SetWindowText(predoc-&gt;hwndParent, szClosedName); <br>SetMenu(hwndMain, hmenuLoaded); <br>DrawMenuBar(hwndMain); <br>} <br> <br>return 1; <br>} <br> <br> <br>DWORD CALLBACK MyRead(DWORD dwCookie, LPBYTE pbBuffer, LONG cb, LONG *pcb) <br>{ <br>HFILEhf = (HFILE) dwCookie; <br> <br>if(hf == HFILE_ERROR) <br>return (DWORD) E_FAIL; <br>*pcb = _lread(hf, pbBuffer, cb); <br>return (DWORD) (*pcb &gt;= 0 ? NOERROR : (*pcb = 0, E_FAIL)); <br>} <br> <br> <br>// This function gives the Mac version the ability to open and print <br>// files via Apple Events. <br>LRESULT DoOpen(predoc, szT, szTitle, fInsert) <br>REDOC *predoc; <br>LPSTR szT, szTitle; <br>BOOL fInsert; <br>{ <br>DWORD dwError; <br> <br>if((dwError = ReadREDoc(predoc, szT, szTitle, 0, fInsert))) <br>goto err; <br>wsprintf(szT, szFmtTitle, szTitle); <br>SetWindowText(predoc-&gt;hwndParent, szT); <br> <br>EnableWindow(predoc-&gt;hwndFormatBar, !predoc-&gt;fReadOnly); <br>SendMessage(predoc-&gt;hwndRE, EM_SETREADONLY, (WPARAM) predoc-&gt;fReadOnly, 0); <br>SetMenu(hwndMain, hmenuFull); <br> <br>SetupWordWrapMenu(predoc); <br>DrawMenuBar(hwndMain); <br>return 0; <br> <br>err: <br>wsprintf(szT, TEXT("Error opening document. [%ld]"), dwError); <br>MessageBox(hwndMain, szT, NULL, MB_OK); <br>return -1; <br>} <br> <br> <br>LOCAL LRESULT OpenREDoc(REDOC *predoc, BOOL fInsert) <br>{ <br>DWORD dwError; <br>OPENFILENAME ofn; <br>TCHAR szTitle[64]; <br>TCHAR szT[256]; <br> <br>if(predoc-&gt;hwndRE &amp;&amp; !fInsert &amp;&amp; CheckSave(predoc) &lt; 0) <br>return -1; <br> <br>if(fInsert &amp;&amp; predoc-&gt;fReadOnly) <br>return -1; <br> <br>ofn.lStructSize= sizeof(ofn); <br>ofn.hInstance= 0; <br>ofn.lpstrFilter= szFilterLoad; <br>ofn.lpstrCustomFilter= NULL; <br>ofn.nMaxCustFilter= 0; <br>ofn.nFilterIndex= 0; <br>ofn.lpstrFileTitle= szTitle; <br>ofn.nMaxFileTitle= sizeof(szTitle); <br>ofn.lpstrInitialDir= NULL; <br>ofn.lpstrTitle= fInsert ? "Insert from File" : NULL; <br>ofn.nFileOffset= 0; <br>ofn.nFileExtension= 0; <br>ofn.lpstrDefExt= NULL; <br>ofn.lCustData= 0L; <br>ofn.lpfnHook= NULL; <br>ofn.lpTemplateName= NULL; <br>ofn.hwndOwner= hwndMain; <br>ofn.lpstrFile= szT; <br>ofn.nMaxFile= sizeof(szT); <br>ofn.Flags= OFN_FILEMUSTEXIST; <br> <br>szTitle[0] = TEXT('\0'); <br>szT[0] = TEXT('\0'); <br> <br>// Query user for filename for input <br>    if(!GetOpenFileName(&amp;ofn)) <br>{ <br>if((dwError = CommDlgExtendedError()) != 0) <br>{ <br>wsprintf(szT, TEXT("Error opening document. [%ld]"), dwError); <br>MessageBox(hwndMain, szT, NULL, MB_OK); <br>return -1; <br>} <br>return 0; <br>} <br>predoc-&gt;fReadOnly = (ofn.Flags &amp; OFN_READONLY) ? fTrue : fFalse; <br>EnableWindow(predoc-&gt;hwndFormatBar, !predoc-&gt;fReadOnly); <br>return(DoOpen(predoc, szT, szTitle, fInsert)); <br>} <br> <br> <br>LOCAL LRESULT RevertREDoc(REDOC *predoc) <br>{ <br>DWORD dwError; <br>TCHAR szT[256]; <br> <br>if(CheckRevert(predoc) &lt;= 0) <br>return 0; <br> <br>lstrcpy(szT, predoc-&gt;szFile); <br>dwError = ReadREDoc(predoc, szT, NULL, predoc-&gt;dwFormat, FALSE); <br>if(!dwError) <br>return 0; <br> <br>wsprintf(szT, TEXT("Error reading document. [%ld]"), dwError); <br>MessageBox(hwndMain, szT, NULL, MB_OK); <br> <br>return -1; <br>} <br> <br> <br>LOCAL DWORD ReadREDoc(REDOC *predoc, LPCSTR szFile, LPCSTR szTitle, <br>DWORD dwFormat, BOOL fInsert) <br>{ <br>LONG cch; <br>HCURSOR hcur; <br>EDITSTREAM es; <br>TCHAR szType[cchRTFSig + 1]; <br> <br> hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>es.dwCookie = (DWORD) _lopen(szFile, OF_READ); <br>if(es.dwCookie == (DWORD) HFILE_ERROR) <br>{ <br>return GetLastError(); <br>} <br> <br>if(!fInsert) <br>{ <br>// save read-only flag across NewREDoc() <br>const BOOL fReadOnlySave = predoc-&gt;fReadOnly; <br> <br>if(NewREDoc(predoc, fFalse, fFalse) &lt; 0) <br>{ <br>_lclose((HFILE) es.dwCookie); <br>return (DWORD) -1; <br>} <br>predoc-&gt;fReadOnly = fReadOnlySave; <br>} <br>if(dwFormat == 0)// unknown format, figure out what it is <br>{ <br>UINT cb = cchRTFSig * sizeof(TCHAR); <br> <br>cb = _lread((HFILE) es.dwCookie, szType, cb); <br>szType[cb / sizeof(TCHAR)] = TEXT('\0'); <br>if(cb == cchRTFSig * sizeof(TCHAR)) <br>dwFormat = lstrcmpi(szRTFSig, szType) ? SF_TEXT : SF_RTF; <br>else <br>dwFormat = SF_TEXT;// not big enough to be RTF, assume text <br> <br>// move back to the beginning of the file <br>_llseek((HFILE) es.dwCookie, 0, 0); <br>} <br> <br>SendMessage(predoc-&gt;hwndRE, WM_SETREDRAW, (WPARAM) fFalse, 0); <br> <br>es.dwError = 0; <br>es.pfnCallback = MyRead; <br> <br>cch = SendMessage(predoc-&gt;hwndRE, EM_STREAMIN, <br>(WPARAM) (fInsert ? dwFormat | SFF_SELECTION : dwFormat), <br>(LPARAM) &amp;es); <br>_lclose((HFILE) es.dwCookie); <br>#ifdef DEBUG <br>if(predoc-&gt;hwndRE) <br>SendMessage(predoc-&gt;hwndRE, EM_REQUESTRESIZE, 0, 0); <br>#endif// DEBUG <br> <br>SendMessage(predoc-&gt;hwndRE, EM_SETMODIFY, (WPARAM) fFalse, 0); <br> <br>predoc-&gt;dwFormat = dwFormat; <br>lstrcpy(predoc-&gt;szFile, szFile); <br>if(szTitle) <br>lstrcpy(predoc-&gt;szTitle, szTitle); <br>else <br>GetFileTitle(szFile, predoc-&gt;szTitle, sizeof(predoc-&gt;szTitle)); <br> <br>SendMessage(predoc-&gt;hwndRE, WM_SETREDRAW, (WPARAM) fTrue, 0); <br>InvalidateRect(predoc-&gt;hwndRE, NULL, fTrue); <br>UpdateWindow(predoc-&gt;hwndRE); <br> <br>SetCursor(hcur); <br> <br>UpdateFormatBar(predoc); <br>return 0; <br>} <br> <br> <br>DWORD CALLBACK MyWrite(DWORD dwCookie, LPBYTE pbBuffer, LONG cb, LONG *pcb) <br>{ <br>HFILEhf = (HFILE) dwCookie; <br> <br>if(hf == HFILE_ERROR) <br>return (DWORD) E_FAIL; <br> <br>*pcb = _lwrite(hf, pbBuffer, cb); <br>return (DWORD) (*pcb == cb ? NOERROR : E_FAIL); <br>} <br> <br> <br>LOCAL LRESULT SaveREDoc(REDOC *predoc) <br>{ <br>HCURSOR hcur; <br>LONG cch; <br>DWORD dwError; <br>EDITSTREAM es; <br> <br>if(!predoc-&gt;szFile[0]) <br>return SaveREDocAs(predoc, FALSE); <br> <br>hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>es.dwCookie = _lcreat(predoc-&gt;szFile, 0); <br>if(es.dwCookie == (DWORD) HFILE_ERROR) <br>{ <br>dwError = GetLastError(); <br>goto err; <br>} <br>es.dwError = 0; <br>es.pfnCallback = MyWrite; <br>cch = SendMessage(predoc-&gt;hwndRE, EM_STREAMOUT,(WPARAM) predoc-&gt;dwFormat, <br>(LPARAM) &amp;es); <br>_lclose((HFILE) es.dwCookie); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_SETMODIFY, (WPARAM) fFalse, 0); <br>SendMessage(predoc-&gt;hwndRE, EM_SETREADONLY, (WPARAM) fFalse, 0); <br>predoc-&gt;fReadOnly = fFalse; <br>EnableWindow(predoc-&gt;hwndFormatBar, TRUE); <br> <br>SetCursor(hcur); <br> <br>return 0; <br> <br>err: <br>{ <br>TCHAR szT[64]; <br> <br>wsprintf(szT, TEXT("Error saving document. [%ld]"), dwError); <br>MessageBox(hwndMain, szT, NULL, MB_OK); <br>} <br> <br>return -1; <br>} <br> <br> <br>LOCAL LRESULT SaveREDocAs(REDOC *predoc, BOOL fSelect) <br>{ <br>HCURSOR hcur; <br>LONG cch; <br>DWORD dwError; <br>EDITSTREAM es; <br>OPENFILENAME ofn; <br>TCHAR szTitle[64]; <br>TCHAR szT[256]; <br> <br>ofn.lStructSize= sizeof(ofn); <br>ofn.hInstance= 0; <br>ofn.lpstrFilter= szFilterSave; <br>ofn.lpstrCustomFilter= NULL; <br>ofn.nMaxCustFilter= 0; <br>ofn.nFilterIndex= 0; <br>ofn.lpstrFileTitle= szTitle; <br>ofn.nMaxFileTitle= sizeof(szTitle); <br>ofn.lpstrInitialDir= NULL; <br>ofn.lpstrTitle= fSelect ? "Save Selection As": NULL; <br>ofn.nFileOffset= 0; <br>ofn.nFileExtension= 0; <br> ofn.lpstrDefExt= NULL; <br>ofn.lCustData= 0L; <br>ofn.lpfnHook= NULL; <br>ofn.lpTemplateName= NULL; <br>ofn.hwndOwner= hwndMain; <br>ofn.lpstrFile= szT; </code></pre>
<p>
</p>
<pre><code>ofn.nMaxFile= sizeof(szT); <br>ofn.Flags= OFN_CREATEPROMPT | OFN_HIDEREADONLY | <br>OFN_OVERWRITEPROMPT; <br> <br>szT[0] = TEXT('\0'); <br>szTitle[0] = TEXT('\0'); <br>// Query user for filename for input <br>    if(!GetSaveFileName(&amp;ofn)) <br>{ <br>if((dwError = CommDlgExtendedError()) != 0) <br>goto err; <br>return -1; <br>} <br> <br>hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>es.dwCookie = _lcreat(szT, 0); <br>if(es.dwCookie == (DWORD) HFILE_ERROR) <br>{ <br>dwError = GetLastError(); <br>goto err; <br>} <br>es.dwError = 0; <br>es.pfnCallback = MyWrite; <br>cch = SendMessage(predoc-&gt;hwndRE, EM_STREAMOUT, <br>(WPARAM) (fSelect ? ofn.nFilterIndex | SFF_SELECTION <br>  : ofn.nFilterIndex), <br>(LPARAM) &amp;es); <br>_lclose((HFILE) es.dwCookie); <br> <br>// Don't mark the doc as clean, nor remember format if only selection <br>if(fSelect) <br>goto Quit; <br> <br>SendMessage(predoc-&gt;hwndRE, EM_SETMODIFY, (WPARAM) fFalse, 0); <br> <br>predoc-&gt;dwFormat = (DWORD) ofn.nFilterIndex; <br>predoc-&gt;fReadOnly = fFalse; <br>EnableWindow(predoc-&gt;hwndFormatBar, TRUE); <br> <br>lstrcpy(predoc-&gt;szFile, szT); <br>lstrcpy(predoc-&gt;szTitle, szTitle); <br> <br>wsprintf(szT, szFmtTitle, szTitle); <br>SetWindowText(predoc-&gt;hwndParent, szT); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_SETMODIFY, (WPARAM) fFalse, 0); <br>SendMessage(predoc-&gt;hwndRE, EM_SETREADONLY, (WPARAM) fFalse, 0); <br> <br>Quit: <br>SetCursor(hcur); <br> <br>return 0; <br> <br>err: <br>wsprintf(szT, TEXT("Error saving document. [%ld]"), dwError); <br>MessageBox(hwndMain, szT, NULL, MB_OK); <br> <br>return -1; <br>} <br> <br> <br>LOCAL LRESULT InsertObject(REDOC *predoc) <br>{ <br>#ifdef NO_OLE <br>MessageBox(NULL, "Not yet implemented", NULL, MB_OK); <br>return 0; <br>#else// NO_OLE <br>const LPRICHEDITOLE preole = predoc-&gt;preole; <br>LPOLECLIENTSITE polesite = NULL; <br>LPSTORAGE pstgItem = NULL; <br>OLEUIINSERTOBJECT ouio = { 0 }; <br>REOBJECT reobj = { 0 }; <br>LPOLEOBJECT poleobj = NULL; <br>CHAR szFileA[OLEUI_CCHPATHMAX]; <br>WCHAR szItemW[OLEUI_CCHPATHMAX]; <br>DWORD dwRet; <br>RECT rect; <br> <br>if(!preole) <br>return 0; <br> <br>if(preole-&gt;lpVtbl-&gt;SetHostNames(preole, "REITP", predoc-&gt;szTitle)) <br>{ <br>MessageBoxA(hwndMain, "Can't set host name", NULL, MB_OK); <br>goto error; <br>} <br> <br>if(preole-&gt;lpVtbl-&gt;GetClientSite(preole, (LPOLECLIENTSITE FAR *) &amp;polesite)) <br>{ <br>MessageBoxA(hwndMain, "No client site!", NULL, MB_OK); <br>goto error; <br>} <br> <br>wsprintfW(szItemW, L"REOBJ%ld", ++predoc-&gt;cItem); <br>if(!(pstgItem = OleStdCreateChildStorage(predoc-&gt;pstg, szItemW))) <br>{ <br>MessageBoxW(hwndMain, szItemW, L"No item storage!", MB_OK); <br>goto error; <br>} <br> <br>szFileA[0] = '\0'; <br>ouio.cbStruct = sizeof(ouio); <br>ouio.dwFlags = IOF_SHOWHELP | IOF_CREATENEWOBJECT | IOF_CREATEFILEOBJECT | <br>   IOF_CREATELINKOBJECT | IOF_SELECTCREATENEW; <br>//   IOF_VERIFYSERVERSEXIST; <br># ifdef MAC// Mac version doesn't have the same members <br>ouio.pszFile = szFileA; <br># else// MAC <br>ouio.hWndOwner = hwndMain; <br>ouio.lpszFile = szFileA; <br># endif// MAC, else <br>ouio.lpszCaption = "Insert Object (REITP)"; <br>ouio.cchFile = OLEUI_CCHPATHMAX; <br>ouio.iid = IID_IOleObject; <br>ouio.oleRender = OLERENDER_DRAW; <br>ouio.lpIOleClientSite = polesite; <br>ouio.lpIStorage = pstgItem; <br>ouio.ppvObj = (LPVOID FAR *) &amp;poleobj; <br>ouio.clsid = CLSID_NULL; <br> <br>if((dwRet = OleUIInsertObject(&amp;ouio)) != OLEUI_SUCCESS) <br>{ <br>if(dwRet == OLEUI_CANCEL) <br>goto error; <br>if(dwRet == OLEUI_IOERR_SCODEHASERROR) <br>wsprintfA(szFileA, "OleUIInsertObject scode is %lx", ouio.sc); <br>else <br>wsprintfA(szFileA, "OleUIInsertObject returned %ld", dwRet); <br>MessageBoxA(hwndMain, szFileA, NULL, MB_OK); <br>goto error; <br>} <br> <br>AssertSz(ouio.sc == S_OK, "Object wasn't created properly"); <br> <br>reobj.cbStruct = sizeof(REOBJECT); <br>reobj.clsid = ouio.clsid; <br>reobj.cp = REO_CP_SELECTION; <br>reobj.poleobj = poleobj; <br>reobj.pstg = pstgItem; <br>reobj.polesite = polesite; <br>reobj.dvaspect = DVASPECT_CONTENT; <br>reobj.dwFlags = REO_RESIZABLE; <br>reobj.dwUser = 0; <br> <br>if(ouio.dwFlags &amp; IOF_SELECTCREATENEW) <br>reobj.dwFlags |= REO_BLANK; <br> <br>//$ Raid 101: RichEdit doesn't setup advises if reobj.clsid == CLSID_NULL <br>// Try our darnest to get a CLSID <br> <br>if(IsEqualCLSID(&amp;reobj.clsid, &amp;CLSID_NULL) &amp;&amp; <br>HrGetClassFileA(szFileA, &amp;reobj.clsid)) <br>{ <br>MessageBoxA(hwndMain, "No CLSID, but forging on", "Insert Object", <br>MB_OK); <br>} <br> <br> <br>// Do we want an iconized version ? <br>if(ouio.dwFlags &amp; IOF_CHECKDISPLAYASICON) <br>{ <br>BOOLfUpdate;// Can't pass in NULL instead of &amp;this <br> <br>// OLE call will update dvaspect on success <br># ifdef MAC <br>// NOTE : There presently is no Mac equivalent of the &lt;.hMetaPict&gt; <br>// member of the tagOleUIInsertObject structure. This is certainly <br>// a problem. For now just pass in NULL since the Mac routines will <br>// not try to use this member. <br>DebugStr("\pBefore OleStdSwitchDisplayAspect() call"); <br>if(OleStdSwitchDisplayAspect(poleobj, &amp;reobj.dvaspect,  <br>  DVASPECT_ICON, (Handle) NULL,  <br>  TRUE, FALSE, NULL, &amp;fUpdate)) <br># else// MAC <br>if(OleStdSwitchDisplayAspect(poleobj, &amp;reobj.dvaspect,  <br>  DVASPECT_ICON, ouio.hMetaPict,  <br>  TRUE, FALSE, NULL, &amp;fUpdate)) <br># endif// MAC, else <br>{ <br>// How much do we care about reporting errors?  Alot!! {Mac will have more} <br>MessageBoxA(hwndMain, "Object couldn't be displayed as an icon.", <br>"Insert Object", MB_OK); <br>} <br>AssertSz(!fUpdate, "We gave it an hMetaPict, should not need updating"); <br>} <br> <br>// Put the thing in the edit control <br>if(preole-&gt;lpVtbl-&gt;InsertObject(preole, &amp;reobj)) <br>{ <br>MessageBoxA(hwndMain, "Object couldn't be inserted", <br>"Insert object", MB_OK); <br>goto error; <br>} <br> <br>// Do show verb only on new objects <br>if(ouio.dwFlags &amp; IOF_SELECTCREATENEW) <br>{ <br>rect.top = rect.left = 0; <br>rect.bottom = rect.right = 50; <br>dwRet = (ULONG) poleobj-&gt;lpVtbl-&gt;DoVerb(poleobj, OLEIVERB_SHOW, NULL, <br>polesite, 0, hwndMain,  <br>(LPCRECT) &amp;rect); <br>} <br> <br>error: <br># ifndef MAC <br>if(ouio.hMetaPict) <br>OleUIMetafilePictIconFree(ouio.hMetaPict); <br># endif// !MAC <br>if(polesite) <br>polesite-&gt;lpVtbl-&gt;Release(polesite); <br>if(pstgItem) <br>pstgItem-&gt;lpVtbl-&gt;Release(pstgItem); <br>if(poleobj) <br>poleobj-&gt;lpVtbl-&gt;Release(poleobj); <br> <br>return 0; <br>#endif// NO_OLE, else <br>} <br> <br> <br>#ifdef DEBUG <br> <br>LOCAL LRESULT GetText(REDOC *predoc) <br>{ <br>HWND hwndEdit; <br>LONG cch; <br>TCHAR *pch; <br> <br>if(!hwndGT) <br>{ <br>hwndGT = CreateDialog(HinstFromHwnd(hwndMain), TEXT("GETTEXT"), <br>hwndMain, (DLGPROC) GTDlgProc); <br>if(!hwndGT) <br>{ <br>MessageBoxA(hwndMain, "Unable to create dialog", NULL, MB_ICONSTOP | MB_OK); <br>return 0; <br>} <br>} <br>hwndEdit = GetDlgItem(hwndGT, GTCTRL); <br>cch = SendMessage(predoc-&gt;hwndRE, WM_GETTEXTLENGTH, 0, 0); <br># ifdef WIN16 <br>if(cch &gt; 65000) <br>{ <br>MessageBoxA(hwndMain, "Text too big, truncating", NULL, <br>MB_ICONSTOP | MB_OK); <br>cch = 65000; <br>} <br># endif// WIN16 <br>pch = GlobalAllocPtr(GHND, cch + 1); <br>if(!pch) <br>{ <br>MessageBoxA(hwndMain, "Not enough memory to hold text", NULL, <br>MB_ICONSTOP | MB_OK); <br>return 0; <br>} <br>GetWindowText(predoc-&gt;hwndRE, pch, (int) cch + 1); <br>*pch = toupper(*pch); <br>SetWindowText(hwndEdit, pch); <br>GlobalFreePtr(pch); <br> <br>return 0; <br>} <br> <br> <br>LRESULT CALLBACK GTDlgProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam) <br>{ <br>switch(msg) <br>{ <br>case WM_INITDIALOG: <br>return 1; <br> <br>case WM_SIZE: <br>MoveWindow(GetDlgItem(hdlg, GTCTRL), 5, 5, LOWORD(lparam)-10, <br>   HIWORD(lparam)-10, TRUE); <br>return 0; <br> <br>case WM_CLOSE: <br>EndDialog(hdlg, 0); <br>hwndGT = NULL; <br>return 1; <br>} <br> <br>return 0; <br>} <br> <br> <br>LOCAL VOID ClearDebugScreen(void) <br>{ <br>HFILE hf; <br> <br>hf = _lopen("COM1", OF_WRITE); <br>if(hf) <br>{ <br>_lwrite(hf, "\x1B[H\x1B[J", 6); <br>_lclose(hf); <br>} <br>} <br> <br>#endif// DEBUG <br> <br> <br>LOCAL VOID SelectCharFormat(REDOC *predoc) <br>{ <br>LOGFONT lf; <br>CHOOSEFONT csf = {0}; <br>CHARFORMAT cf; <br>LONG yPerInch; <br>HDC hdc; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br> <br>hdc = GetDC(hwndMain); <br>yPerInch = GetDeviceCaps(hdc, LOGPIXELSY); <br>ReleaseDC(hwndMain, hdc); <br> <br>(void) SendMessage(predoc-&gt;hwndRE, EM_GETCHARFORMAT, (WPARAM) fTrue, <br>(LPARAM) &amp;cf); <br> <br>csf.lStructSize = sizeof(csf); <br>csf.hwndOwner = hwndMain; <br>csf.hDC = 0; <br>csf.lpLogFont = &amp;lf; <br>csf.Flags = CF_EFFECTS | CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | <br>CF_LIMITSIZE; <br>csf.nSizeMin = 1; <br>csf.nSizeMax = yHeightCharPtsMost; <br>csf.rgbColors = cf.crTextColor; <br>csf.lpszStyle = NULL; <br>csf.nFontType = REGULAR_FONTTYPE | SCREEN_FONTTYPE; <br>lf.lfHeight = -(INT) ((cf.yHeight * yPerInch) / 1440); <br>lf.lfWidth = 0; <br>lf.lfEscapement = 0; <br>lf.lfOrientation = 0; <br>lf.lfWeight = (cf.dwEffects &amp; CFE_BOLD) ? FW_BOLD : FW_NORMAL; <br>lf.lfItalic = (cf.dwEffects &amp; CFE_ITALIC) ? fTrue : fFalse; <br>lf.lfUnderline = (cf.dwEffects &amp; CFE_UNDERLINE) ? fTrue : fFalse; <br>lf.lfStrikeOut = (cf.dwEffects &amp; CFE_STRIKEOUT) ? fTrue : fFalse; <br>lf.lfOutPrecision = OUT_DEFAULT_PRECIS; <br>lf.lfClipPrecision = CLIP_DEFAULT_PRECIS; <br>lf.lfQuality = DRAFT_QUALITY; <br>lf.lfCharSet = cf.bCharSet; <br>lf.lfPitchAndFamily = cf.bPitchAndFamily; <br>_tcscpy(lf.lfFaceName, cf.szFaceName); <br> <br>if(!ChooseFont(&amp;csf)) <br>return; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br> <br>// don't change read-only bit <br>cf.dwMask = CFM_SIZE | CFM_EFFECTS | CFM_COLOR | CFM_FACE | CFM_CHARSET; <br>cf.yHeight = (LONG) csf.iPointSize * 2; <br>cf.dwEffects = CFM_EFFECTS; <br>if(lf.lfWeight &lt; FW_BOLD) <br>cf.dwEffects &amp;= ~CFE_BOLD; <br>if(!lf.lfItalic) <br>cf.dwEffects &amp;= ~CFE_ITALIC; <br>if(!lf.lfUnderline) <br>cf.dwEffects &amp;= ~CFE_UNDERLINE; <br>if(!lf.lfStrikeOut) <br>cf.dwEffects &amp;= ~CFE_STRIKEOUT; <br>cf.crTextColor = csf.rgbColors; <br>cf.bCharSet = lf.lfCharSet; <br>cf.bPitchAndFamily = lf.lfPitchAndFamily; <br>_tcscpy(cf.szFaceName, lf.lfFaceName); <br> <br>if(!SendMessage(predoc-&gt;hwndRE, EM_SETCHARFORMAT, predoc-&gt;scf, <br>(LPARAM) &amp;cf)) <br>{ <br>MessageBoxA(hwndMain, "Error setting character format", NULL, <br>MB_ICONSTOP | MB_OK); <br>} <br>} <br> <br> <br>LOCAL VOID SaveWindowPos(HWND hwnd) <br>{ <br>WINDOWPLACEMENTwndpl; <br>HKEY hkey; <br> <br>    wndpl.length = sizeof(wndpl); <br>    GetWindowPlacement(hwnd, &amp;wndpl); <br>    if(RegCreateKeyEx(HKEY_CURRENT_USER, szRegKey, 0, szAppName, 0, <br>KEY_ALL_ACCESS, NULL, &amp;hkey, NULL) == ERROR_SUCCESS) <br>    { <br>        RegSetValueEx(hkey, szRegValue, 0, REG_BINARY, (LPBYTE) &amp;wndpl, <br>sizeof(wndpl)); <br>        RegCloseKey(hkey); <br>    } <br>} <br> <br> <br>LOCAL BOOL FRestoreWindowPos(WINDOWPLACEMENT *pwndpl) <br>{ <br>BOOL fReturn = fFalse; <br>DWORD cb; <br>HKEY hkey = 0; <br> <br>    if(RegOpenKeyEx(HKEY_CURRENT_USER, szRegKey, 0, KEY_READ, &amp;hkey) <br>== ERROR_SUCCESS) <br>{ <br>cb = sizeof(*pwndpl); <br>if(RegQueryValueEx(hkey, szRegValue, 0, 0, (LPBYTE) pwndpl, <br>&amp;cb) == ERROR_SUCCESS) <br>{ <br>fReturn = (cb == sizeof(*pwndpl)); <br>} <br>RegCloseKey(hkey); <br>} <br> <br>return fReturn; <br>} <br> <br> <br>LOCAL VOID SetAlignment(REDOC *predoc, WORD wAlignment) <br>{ <br>PARAFORMAT pf; <br> <br>pf.cbSize = sizeof(PARAFORMAT); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_GETPARAFORMAT, 0, (LPARAM) &amp;pf); <br> <br>if(!(pf.dwMask &amp; PFM_ALIGNMENT) || pf.wAlignment != wAlignment) <br>{ <br>pf.dwMask = PFM_ALIGNMENT;// only change the alignment <br>pf.wAlignment = wAlignment; <br>SendMessage(predoc-&gt;hwndRE, EM_SETPARAFORMAT, 0, (LPARAM) &amp;pf); <br>} <br>} <br> <br> <br>LOCAL VOID IndentFirst(REDOC *predoc, BOOL fIndent) <br>{ <br>PARAFORMAT pf; <br> <br>pf.cbSize = sizeof(PARAFORMAT); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_GETPARAFORMAT, 0, (LPARAM) &amp;pf); <br> <br>pf.dwMask = PFM_OFFSET | PFM_OFFSETINDENT; <br>if(fIndent) <br>{ <br>if(pf.dxOffset &lt; 0) <br>{ <br>pf.dxStartIndent = pf.dxOffset; <br>pf.dxOffset = 0; <br>} <br>else <br>{ <br>pf.dxOffset = pf.dxOffset ? -pf.dxOffset : -lDefaultTab; <br>pf.dxStartIndent = -pf.dxOffset; <br>} <br>} <br>else <br>{ <br>if(pf.dxOffset &lt; 0) <br>{ <br>pf.dxStartIndent = pf.dxOffset; <br>pf.dxOffset = -pf.dxOffset; <br>} <br>else <br>{ <br>pf.dxStartIndent = 0; <br>pf.dxOffset = pf.dxOffset ? 0 : lDefaultTab; <br>} <br>} <br> <br>SendMessage(predoc-&gt;hwndRE, EM_SETPARAFORMAT, 0, (LPARAM) &amp;pf); <br>} <br> <br> <br>LOCAL VOID ProtectSelection(REDOC *predoc) <br>{ <br>CHARFORMAT cf; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br> <br>(void) SendMessage(predoc-&gt;hwndRE, EM_GETCHARFORMAT, fTrue, (LPARAM) &amp;cf); <br>cf.dwMask = CFM_PROTECTED; <br>cf.dwEffects = cf.dwEffects ^ CFE_PROTECTED; <br>(void) SendMessage(predoc-&gt;hwndRE, EM_SETCHARFORMAT, predoc-&gt;scf, <br>(LPARAM) &amp;cf); <br>} <br> <br> <br>LOCAL VOID SetWordWrap(REDOC *predoc, BOOL fWysiwyg, BOOL fWrap) <br>{ <br>HCURSOR hcur; <br>HDC hdcDel = predoc-&gt;hdcTarget; <br>LONG xWidth; <br> <br>if(!fWysiwyg == !predoc-&gt;fWysiwyg &amp;&amp; !fWrap == !predoc-&gt;fWrap) <br>return; <br> <br>hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>if(fWysiwyg) <br>{ <br>POINT pt; <br>LPDEVMODE pDevMode; <br>LPDEVNAMES pDevNames; <br> <br>if(predoc-&gt;pd.lStructSize != sizeof(PRINTDLG)) <br>goto done;// error occured getting default printer <br> <br>pDevMode = (LPDEVMODE) GlobalLock(predoc-&gt;pd.hDevMode); <br>pDevNames = (LPDEVNAMES) GlobalLock(predoc-&gt;pd.hDevNames); <br>predoc-&gt;hdcTarget = CreateIC((LPTSTR) pDevNames + <br>pDevNames-&gt;wDriverOffset, <br>(LPTSTR) pDevNames + pDevNames-&gt;wDeviceOffset, <br>(LPTSTR) pDevNames + pDevNames-&gt;wOutputOffset, <br>pDevMode); <br>GlobalUnlock(predoc-&gt;pd.hDevNames); <br>GlobalUnlock(predoc-&gt;pd.hDevMode); <br>if(!predoc-&gt;hdcTarget) <br>goto done; <br>SetMapMode(predoc-&gt;hdcTarget, MM_TEXT); <br>if(Escape(predoc-&gt;hdcTarget, GETPHYSPAGESIZE, 0, NULL, &amp;pt) &gt; 0) <br>{ <br>const LONG xPerInch = GetDeviceCaps(predoc-&gt;hdcTarget, LOGPIXELSX); <br> <br>xWidth = (pt.x * 1440l) / xPerInch; <br>// leave 1.25" (1800 twips) margins if that will leave &gt;= 1" <br>if(xWidth &gt;= 1800 + 1440 + 1800) <br>xWidth -= 1800 + 1800; <br>} <br>else <br>{ <br>const LONG xPerInch = GetDeviceCaps(predoc-&gt;hdcTarget, LOGPIXELSX); <br> <br>xWidth = (GetDeviceCaps(predoc-&gt;hdcTarget, HORZRES) * 1440l) / <br>xPerInch; <br>} <br>} <br>else <br>{ <br>predoc-&gt;hdcTarget = 0; <br>xWidth = (LONG) !fWrap; <br>} <br>predoc-&gt;fWysiwyg = fWysiwyg; <br>predoc-&gt;fWrap = fWrap; <br> <br>SetupWordWrapMenu(predoc); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_SETTARGETDEVICE, <br>(WPARAM) predoc-&gt;hdcTarget, (LPARAM) xWidth); <br>if(hdcDel) <br>DeleteDC(hdcDel); <br> <br>done: <br>SetCursor(hcur); <br>} <br> <br> <br>LOCAL VOID SetupWordWrapMenu(REDOC *predoc) <br>{ <br>HMENU hmenu = GetMenu(hwndMain); <br> <br>CheckMenuItem(hmenu, IDM_NOWRAP, <br>(!predoc-&gt;fWysiwyg &amp;&amp; !predoc-&gt;fWrap) ? MF_CHECKED : MF_UNCHECKED); <br>CheckMenuItem(hmenu, IDM_WRAP, <br>(!predoc-&gt;fWysiwyg &amp;&amp; predoc-&gt;fWrap) ? MF_CHECKED : MF_UNCHECKED); <br>CheckMenuItem(hmenu, IDM_WYSIWYG, <br>predoc-&gt;fWysiwyg ? MF_CHECKED :MF_UNCHECKED); <br>} <br> <br> <br>LOCAL VOID SetOffset(REDOC *predoc, BOOL fSuperscript) <br>{ <br>CHARFORMAT cf; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_GETCHARFORMAT, fTrue, (LPARAM) &amp;cf); <br> <br>cf.dwMask = CFM_OFFSET;// only change the yOffset <br>if(fSuperscript) <br>{ <br>if(cf.yOffset &gt; 0) <br>cf.yOffset = 0; <br>else <br>cf.yOffset = 50; <br>} <br>else <br>{ <br>if(cf.yOffset &lt; 0) <br>cf.yOffset = 0; <br>else <br>cf.yOffset = -50; <br>} <br> <br>SendMessage(predoc-&gt;hwndRE, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM) &amp;cf); <br>} <br> <br> <br>VOID PrintREDoc(REDOC *predoc) <br>{ <br>LONG cchText; <br>HCURSOR hcur; <br>POINT pt; <br>DOCINFO di; <br>FORMATRANGE fr; <br>RECT rc; <br> <br>cchText = SendMessage(predoc-&gt;hwndRE, WM_GETTEXTLENGTH, 0, 0); <br> <br>predoc-&gt;pd.nFromPage = 0; <br>predoc-&gt;pd.nToPage = 0; <br>predoc-&gt;pd.nMinPage = 0; <br>predoc-&gt;pd.nMaxPage = 0; <br>predoc-&gt;pd.nCopies = 1; <br>predoc-&gt;pd.Flags =  <br>PD_NOPAGENUMS | PD_NOSELECTION | <br>PD_USEDEVMODECOPIES | PD_COLLATE | PD_RETURNDC; <br> <br>if(!PrintDlg(&amp;predoc-&gt;pd)) <br>return; <br> <br>hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>di.cbSize = sizeof(DOCINFO); <br>di.lpszDocName = predoc-&gt;szTitle; <br>di.lpszOutput = NULL; <br> <br>fr.hdc = predoc-&gt;pd.hDC; <br>fr.hdcTarget = 0; <br> <br>if(Escape(fr.hdc, GETPHYSPAGESIZE, 0, NULL, &amp;pt) &gt; 0) <br>{ <br>const LONG xPerInch = GetDeviceCaps(fr.hdc, LOGPIXELSX); <br>const LONG yPerInch = GetDeviceCaps(fr.hdc, LOGPIXELSY); <br> <br>rc.left = rc.top = 0; <br>fr.rcPage.left = fr.rcPage.top = 0; <br>rc.right = (INT) ((pt.x * 1440l) / xPerInch); <br>fr.rcPage.right = rc.right; <br>// leave 1.25" (1800 twips) margins if that will leave &gt;= 1" <br>if(rc.right &gt;= 1800 + 1440 + 1800) <br>rc.right -= (rc.left = 1800); <br>rc.bottom = (INT) ((pt.y * 1440l) / yPerInch); <br>fr.rcPage.bottom = rc.bottom; <br>// leave 1" (1440 twips) margins if that will leave &gt;= 1" <br>if(rc.bottom &gt;= 1440 + 1440 + 1440) <br>rc.bottom -= (rc.top = 1440); <br>} <br>else <br>{ <br>const LONG xPerInch = GetDeviceCaps(fr.hdc, LOGPIXELSX); <br>const LONG yPerInch = GetDeviceCaps(fr.hdc, LOGPIXELSY); <br> <br>rc.left = rc.top = 0; <br>rc.right = (INT) ((GetDeviceCaps(fr.hdc, HORZRES) * 1440l) / <br>xPerInch); <br>rc.bottom = (INT) ((GetDeviceCaps(fr.hdc, VERTRES) * 1440l) / <br>yPerInch); <br>fr.rcPage = rc; <br>} <br> <br>if(StartDoc(fr.hdc, &amp;di) &lt;= 0) <br>goto err; <br> <br>// tell RichEdit not to erase before rendering text <br>SetBkMode(fr.hdc, TRANSPARENT); <br> <br>fr.chrg.cpMin = 0; <br>fr.chrg.cpMost = cchText; <br>do <br>{ <br>if(StartPage(fr.hdc) &lt;= 0) <br>goto abort; <br>fr.rc = rc; <br>fr.chrg.cpMin = SendMessage(predoc-&gt;hwndRE, EM_FORMATRANGE, <br>(WPARAM) fTrue, (LPARAM) &amp;fr); <br>if(EndPage(fr.hdc) &lt;= 0) <br>goto abort; <br>} while(fr.chrg.cpMin &gt; 0 &amp;&amp; fr.chrg.cpMin &lt; fr.chrg.cpMost); <br> <br>if(fr.chrg.cpMin &gt;= 0 &amp;&amp; EndDoc(fr.hdc) &gt; 0) <br>{ <br>fr.chrg.cpMin = fr.chrg.cpMost = cchText; <br>// free up RichEdit's format range info <br>SendMessage(predoc-&gt;hwndRE, EM_FORMATRANGE, 0, 0); <br>(void) SetCursor(hcur); <br>return; <br>} <br> <br>abort: <br>(void) AbortDoc(fr.hdc); <br> <br>err: <br>fr.chrg.cpMin = fr.chrg.cpMost = cchText; <br>// free up RichEdit's format range info <br>SendMessage(predoc-&gt;hwndRE, EM_FORMATRANGE, 0, 0); <br>(void) SetCursor(hcur); <br>MessageBoxA(hwndMain, "An error occurred while printing", NULL, <br>MB_ICONSTOP | MB_OK); <br>} <br> <br> <br>LRESULT CALLBACK PPDlgProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam) <br>{ <br>PRINTPREVIEW * ppp = (PRINTPREVIEW *) GetWindowLong(hdlg, DWL_USER); <br> <br>switch(msg) <br>{ <br>case WM_INITDIALOG: <br>// hide the button we use to tell us where the top left is <br>ShowWindow(GetDlgItem(hdlg, PSB_TopLeft), SW_HIDE); <br> <br>ppp = (PRINTPREVIEW *) GlobalAllocPtr(GHND, sizeof(PRINTPREVIEW)); <br>SetWindowLong(hdlg, DWL_USER, (LONG) ppp); <br>if(!ppp) <br>{ <br>MessageBoxA(hwndMain, <br>"Not enough memory for Print Preview window.", <br>NULL, MB_ICONSTOP | MB_OK); <br>EndDialog(hdlg, 0); <br>return 0; <br>} <br>ppp-&gt;hwndDlg = hdlg; <br>ppp-&gt;predoc = (REDOC *) lparam; <br>AssertSz(ppp-&gt;predoc, "print preview: no redoc"); <br>ppp-&gt;cchText = -1; <br>ppp-&gt;ipage = -1; <br>PPChangePage(ppp, fFalse); <br>if(ppp-&gt;ipage &lt; 0) <br>{ <br>ppp-&gt;fDone = fTrue;// prevent any movement <br>// bail <br>PostMessage(hdlg, WM_CLOSE, 0, 0); <br>return 0; <br>} <br>return 1; <br> <br>case WM_PAINT: <br>PPPaint(ppp); <br>break; <br> <br>case WM_SIZE: <br>// cause complete redraw <br>InvalidateRect(hdlg, NULL, fTrue); <br>break; <br> <br>#if defined(DEBUG) &amp;&amp; defined(CLIPMETA) <br>case WM_LBUTTONDBLCLK: <br>if(ppp-&gt;hmf) <br>{ <br>HMETAFILE hmf = 0; <br>HANDLE hMfp = 0; <br>METAFILEPICT *pmfp; <br> <br>if(!OpenClipboard(hwndMain)) <br>break; <br>EmptyClipboard(); <br>hmf = CopyMetaFile(ppp-&gt;hmf, NULL); <br>if(!hmf) <br>{ <br>MessageBeep(0); <br>break; <br>} <br>hMfp = GlobalAlloc(GHND | GMEM_DDESHARE, sizeof(METAFILEPICT)); <br>if(!hMfp) <br>goto err; <br>pmfp = (METAFILEPICT *) GlobalLock(hMfp); <br>pmfp-&gt;mm = MM_ANISOTROPIC; <br>pmfp-&gt;xExt = (INT) ppp-&gt;dxPage; <br>pmfp-&gt;yExt = (INT) ppp-&gt;dyPage; <br>pmfp-&gt;hMF = hmf; <br>GlobalUnlock(hMfp); <br>SetClipboardData(CF_METAFILEPICT, hMfp); <br>CloseClipboard(); <br>TraceTag(tagNull, "clipped"); <br>break; <br>err: <br>if(hmf) <br>DeleteMetaFile(hmf); <br>if(hMfp) <br>GlobalFree(hMfp); <br>CloseClipboard(); <br>} <br>break; <br>#endif// DEBUG &amp;&amp; CLIPMETA <br> <br>case WM_COMMAND: <br>switch(GET_WM_COMMAND_ID(wparam, lparam)) <br>{ <br>case PSB_NextPage: <br>PPChangePage(ppp, fFalse); <br>break; <br>case PSB_PrevPage: <br>PPChangePage(ppp, fTrue); <br>break; <br>case PSB_Close: <br>PostMessage(hdlg, WM_CLOSE, 0, 0); <br>break; <br>} <br>break; <br> <br>case WM_CLOSE: <br>if(ppp) <br>{ <br>// free up RichEdit's format range info <br>SendMessage(ppp-&gt;predoc-&gt;hwndRE, EM_FORMATRANGE, 0, 0); <br>#ifdef DEBUG <br>if(ppp-&gt;hmf) <br>DeleteMetaFile(ppp-&gt;hmf); <br>#endif// DEBUG <br>if(ppp-&gt;fr.hdc) <br>{ <br>#ifndef NOBLIT <br>SelectObject(ppp-&gt;fr.hdc, ppp-&gt;hbmpOld); <br>#endif// !NOBLIT <br>DeleteDC(ppp-&gt;fr.hdc); <br>} <br>#ifndef NOBLIT <br>if(ppp-&gt;hbmp) <br>DeleteObject(ppp-&gt;hbmp); <br>#endif// !NOBLIT <br>if(ppp-&gt;fr.hdcTarget) <br>DeleteDC(ppp-&gt;fr.hdcTarget); <br>GlobalFreePtr(ppp); <br>} <br>SetWindowLong(hdlg, DWL_USER, 0); <br>EndDialog(hdlg, 0); <br>return 1; <br>} <br> <br>return 0; <br>} <br> <br> <br>LOCAL BOOL FPPInit(PRINTPREVIEW *ppp) <br>{ <br>LPDEVMODE pDevMode; <br>LPDEVNAMES pDevNames; <br>POINT pt; <br> <br>#ifndef NOBLIT <br>ppp-&gt;hbmp = ppp-&gt;hbmpOld = 0; <br>#endif// !NOBLIT <br>ppp-&gt;fr.hdc = 0; <br>ppp-&gt;cchText = SendMessage(ppp-&gt;predoc-&gt;hwndRE, WM_GETTEXTLENGTH, 0, 0); <br> <br>if(ppp-&gt;predoc-&gt;pd.lStructSize != sizeof(PRINTDLG)) <br>{ <br>MessageBoxA(hwndMain, "No printer selected.", NULL, <br>MB_ICONSTOP | MB_OK); <br>return fFalse; <br>} <br> <br>ppp-&gt;cpage = 0; <br>ppp-&gt;ipage = -1;// first increment will display page 0 <br>ppp-&gt;cpageMost = cpageChunk; <br>ppp-&gt;rgcpPages = (LONG *) GlobalAllocPtr(GHND, cpageChunk * sizeof(LONG)); <br>if(!ppp-&gt;rgcpPages) <br>ppp-&gt;cpageMost = 0; <br> <br>pDevMode = (LPDEVMODE) GlobalLock(ppp-&gt;predoc-&gt;pd.hDevMode); <br>pDevNames = (LPDEVNAMES) GlobalLock(ppp-&gt;predoc-&gt;pd.hDevNames); <br>ppp-&gt;fr.hdcTarget = CreateIC((LPTSTR) pDevNames + pDevNames-&gt;wDriverOffset, <br>(LPTSTR) pDevNames + pDevNames-&gt;wDeviceOffset, <br>(LPTSTR) pDevNames + pDevNames-&gt;wOutputOffset, <br>pDevMode); <br>GlobalUnlock(ppp-&gt;predoc-&gt;pd.hDevNames); <br>GlobalUnlock(ppp-&gt;predoc-&gt;pd.hDevMode); <br>if(!ppp-&gt;fr.hdcTarget) <br>goto err; <br> <br>// does this matter? <br>SetMapMode(ppp-&gt;fr.hdcTarget, MM_TEXT); <br> <br>if(Escape(ppp-&gt;fr.hdcTarget, GETPHYSPAGESIZE, 0, NULL, &amp;pt) &gt; 0) <br>{ <br>const LONG xPerInch = GetDeviceCaps(ppp-&gt;fr.hdcTarget, LOGPIXELSX); <br>const LONG yPerInch = GetDeviceCaps(ppp-&gt;fr.hdcTarget, LOGPIXELSY); <br> <br>ppp-&gt;rc.left = ppp-&gt;rc.top = 0; <br>ppp-&gt;dxPage = (pt.x * 1440l) / xPerInch; <br>ppp-&gt;rc.right = (INT) ppp-&gt;dxPage; <br>ppp-&gt;fr.rcPage.left = 0; <br>ppp-&gt;fr.rcPage.right = ppp-&gt;rc.right; <br>// leave 1.25" (1800 twips) margins if that will leave &gt;= 1" <br>if(ppp-&gt;rc.right &gt;= 1800 + 1440 + 1800) <br>ppp-&gt;rc.right -= (ppp-&gt;rc.left = 1800); <br>ppp-&gt;dyPage = (pt.y * 1440l) / yPerInch; <br>ppp-&gt;rc.bottom = (INT) ppp-&gt;dyPage; <br>ppp-&gt;fr.rcPage.top = 0; <br>ppp-&gt;fr.rcPage.bottom = ppp-&gt;rc.bottom; <br>// leave 1" (1440 twips) margins if that will leave &gt;= 1" <br>if(ppp-&gt;rc.bottom &gt;= 1440 + 1440 + 1440) <br>ppp-&gt;rc.bottom -= (ppp-&gt;rc.top = 1440); <br>} <br>else <br>{ <br>const LONG xPerInch = GetDeviceCaps(ppp-&gt;fr.hdcTarget, LOGPIXELSX); <br>const LONG yPerInch = GetDeviceCaps(ppp-&gt;fr.hdcTarget, LOGPIXELSY); <br>const LONG dxRes = GetDeviceCaps(ppp-&gt;fr.hdcTarget, HORZRES); <br>const LONG dyRes = GetDeviceCaps(ppp-&gt;fr.hdcTarget, VERTRES); <br> <br>ppp-&gt;rc.left = ppp-&gt;rc.top = 0; <br>ppp-&gt;dxPage = (dxRes * 1440l) / xPerInch; <br>ppp-&gt;rc.right = (INT) ppp-&gt;dxPage; <br>ppp-&gt;dyPage = (dyRes * 1440l) / yPerInch; <br>ppp-&gt;rc.bottom = (INT) ppp-&gt;dyPage; <br>ppp-&gt;fr.rcPage = ppp-&gt;rc; <br>} <br> <br>PPInitDialogSize(ppp); <br> <br>#ifdef DEBUG <br>if(!QueryCheck(ppp-&gt;predoc, IDM_PPMETA)) <br>#endif// DEBUG <br>{ <br>HDC hdcT; <br>#ifdef NOBLIT <br> <br>hdcT = GetDC(ppp-&gt;hwndDlg); <br>ppp-&gt;fr.hdc = CreateCompatibleDC(hdcT); <br>ReleaseDC(ppp-&gt;hwndDlg, hdcT); <br>if(!ppp-&gt;fr.hdc) <br>goto err; <br>#else// NOBLIT <br>LONG xPerInch; <br>LONG yPerInch; <br> <br>hdcT = GetDC(ppp-&gt;hwndDlg); <br>SaveDC(hdcT); <br>SetMapMode(hdcT, MM_TEXT); <br>xPerInch = GetDeviceCaps(hdcT, LOGPIXELSX); <br>yPerInch = GetDeviceCaps(hdcT, LOGPIXELSY); <br>ppp-&gt;dxBmp = (INT) ((ppp-&gt;dxPage * xPerInch) / 1440l); <br>ppp-&gt;dyBmp = (INT) ((ppp-&gt;dyPage * yPerInch) / 1440l); <br>ppp-&gt;fr.hdc = CreateCompatibleDC(hdcT); <br>ppp-&gt;hbmp = CreateCompatibleBitmap(hdcT, ppp-&gt;dxBmp, ppp-&gt;dyBmp); <br>RestoreDC(hdcT, -1); <br>ReleaseDC(ppp-&gt;hwndDlg, hdcT); <br>if(!ppp-&gt;fr.hdc) <br>{ <br>if(ppp-&gt;hbmp) <br>DeleteObject(ppp-&gt;hbmp); <br>ppp-&gt;hbmp = 0; <br>goto err; <br>} <br>if(!ppp-&gt;hbmp) <br>goto err; <br>ppp-&gt;hbmpOld = SelectObject(ppp-&gt;fr.hdc, ppp-&gt;hbmp); <br>#endif// NOBLIT, else <br>SetMapMode(ppp-&gt;fr.hdc, MM_TEXT); <br>} <br> <br>ppp-&gt;fr.chrg.cpMin = 0; <br>ppp-&gt;fr.chrg.cpMost = ppp-&gt;cchText; <br> <br>return fTrue; <br> <br>err: <br>if(ppp-&gt;fr.hdcTarget) <br>{ <br>DeleteDC(ppp-&gt;fr.hdcTarget); <br>ppp-&gt;fr.hdcTarget = 0; <br>} <br>if(ppp-&gt;fr.hdc) <br>{ <br>DeleteDC(ppp-&gt;fr.hdc); <br>ppp-&gt;fr.hdc = 0; <br>} <br>#ifndef NOBLIT <br>Assert(!ppp-&gt;hbmp); <br>Assert(!ppp-&gt;hbmpOld); <br>#endif// !NOBLIT <br> <br>MessageBoxA(hwndMain, <br>"An error occurred while processing the print preview", <br>NULL, MB_ICONSTOP | MB_OK); <br> <br>return fFalse; <br>} <br> <br> <br>LOCAL VOID PPInitDialogSize(PRINTPREVIEW *ppp) <br>{ <br>LONG dx; <br>LONG dy; <br>LONG numer; <br>LONG denom; <br>RECT rc; <br> <br>dx = GetSystemMetrics(SM_CXFULLSCREEN) - 2 * GetSystemMetrics(SM_CXBORDER); <br>dy = GetSystemMetrics(SM_CYFULLSCREEN) - 2 * GetSystemMetrics(SM_CYBORDER); <br> <br>// select initial scale <br>if(dy * ppp-&gt;dxPage &gt; dx * ppp-&gt;dyPage) <br>{ <br>numer = dx; <br>denom = ppp-&gt;dxPage; <br>} <br>else <br>{ <br>numer = dy; <br>denom = ppp-&gt;dyPage; <br>} <br>rc.top = 0; <br>rc.left = 0; <br>rc.bottom = (INT) ((numer * ppp-&gt;dyPage) / denom); <br>rc.right = (INT) ((numer * ppp-&gt;dxPage) / denom); <br> <br>rc.right += 2 * GetSystemMetrics(SM_CXFRAME); <br>rc.bottom += GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYFRAME); <br> <br>MoveWindow(ppp-&gt;hwndDlg, rc.left, rc.top, rc.right, rc.bottom, fTrue); <br>ShowWindow(ppp-&gt;hwndDlg, SW_SHOW); <br>} <br> <br> <br>LOCAL VOID PPChangePage(PRINTPREVIEW *ppp, BOOL fPrev) <br>{ <br>HCURSOR hcur; <br>TCHAR szCaption[40]; <br> <br>if(ppp-&gt;cchText &lt; 0 &amp;&amp; !FPPInit(ppp)) <br>return; <br> <br>if(fPrev) <br>{ <br>// no page before page zero or no page array so we can't go back <br>if(ppp-&gt;ipage &lt;= 0 || !ppp-&gt;rgcpPages) <br>{ <br>MessageBeep(0); <br>return; <br>} <br>Assert(ppp-&gt;ipage - 1 &lt; ppp-&gt;cpage); <br>// backup a page <br>ppp-&gt;fr.chrg.cpMin = ppp-&gt;rgcpPages[ppp-&gt;ipage - 1]; <br>} <br>else if(ppp-&gt;ipage + 1 &gt;= ppp-&gt;cpage) <br>{ <br>if(ppp-&gt;fDone) <br>{ <br>MessageBeep(0); <br>return; <br>} <br>if(!ppp-&gt;rgcpPages) <br>goto doit; <br>if(ppp-&gt;ipage + 1 &gt;= ppp-&gt;cpageMost) <br>{ <br>LONG *pcp; <br> <br>pcp = (LONG *) GlobalReAllocPtr(ppp-&gt;rgcpPages, <br>(ppp-&gt;cpageMost + cpageChunk) * sizeof(LONG), GHND); <br>if(!pcp) <br>{ <br>GlobalFreePtr(ppp-&gt;rgcpPages); <br>ppp-&gt;rgcpPages = NULL; <br>ppp-&gt;cpage = ppp-&gt;cpageMost = 0; <br>goto doit; <br>} <br>ppp-&gt;rgcpPages = pcp; <br>ppp-&gt;cpageMost += cpageChunk; <br>} <br>ppp-&gt;cpage++; <br>ppp-&gt;rgcpPages[ppp-&gt;ipage + 1] = ppp-&gt;fr.chrg.cpMin; <br>} <br> <br>doit: <br>hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>#ifndef NOBLIT <br>if(ppp-&gt;fr.hdc) <br>{ <br>RECT rc; <br> <br>rc.top = rc.left = 0; <br>rc.bottom = ppp-&gt;dyBmp; <br>rc.right = ppp-&gt;dxBmp; <br>// erase the background <br>SetBkColor(ppp-&gt;fr.hdc, GetSysColor(COLOR_WINDOW)); <br>ExtTextOut(ppp-&gt;fr.hdc, 0, 0, ETO_OPAQUE, &amp;rc, "", 0, NULL); <br>// tell RichEdit not to bother erasing the background <br>SetBkMode(ppp-&gt;fr.hdc, TRANSPARENT); <br>} <br>#endif// !NOBLIT <br> <br>#ifdef DEBUG <br>if(ppp-&gt;hmf) <br>{ <br>// delete any metafile left around from the last page <br>DeleteMetaFile(ppp-&gt;hmf); <br>ppp-&gt;hmf = NULL; <br>} <br>if(QueryCheck(ppp-&gt;predoc, IDM_PPMETA)) <br>{ <br>AssertSz(!ppp-&gt;fr.hdc, "How'd that get there?"); <br>ppp-&gt;fr.hdc = CreateMetaFile(NULL); <br>if(!ppp-&gt;fr.hdc) <br>goto err; <br>TraceTag(tagEnumMF, "Window Ext = %d, %d", ppp-&gt;dxPage, ppp-&gt;dyPage); <br>} <br>#endif// DEBUG <br> <br>ppp-&gt;fr.rc = ppp-&gt;rc; <br>ppp-&gt;fr.chrg.cpMin = SendMessage(ppp-&gt;predoc-&gt;hwndRE, EM_FORMATRANGE, <br>(WPARAM) fTrue, (LPARAM) &amp;ppp-&gt;fr); <br> <br>if(!fPrev &amp;&amp; ppp-&gt;fr.chrg.cpMin &gt;= ppp-&gt;fr.chrg.cpMost) <br>{ <br>// free up RichEdit's format range info <br>ppp-&gt;fr.chrg.cpMin = ppp-&gt;fr.chrg.cpMost = ppp-&gt;cchText; <br>SendMessage(ppp-&gt;predoc-&gt;hwndRE, EM_FORMATRANGE, 0, 0); <br>// setup for a prev <br>ppp-&gt;fr.chrg.cpMost = ppp-&gt;cchText; <br>// done with all pages, ppp-&gt;cpage is the max # of pages <br>ppp-&gt;fDone = fTrue; <br>} <br> <br>#ifdef DEBUG <br>if(QueryCheck(ppp-&gt;predoc, IDM_PPMETA)) <br>{ <br>//$ REVIEW: what happens to ppp-&gt;fr.hdc if this fails? <br>ppp-&gt;hmf = CloseMetaFile(ppp-&gt;fr.hdc); <br>ppp-&gt;fr.hdc = 0; <br>if(!ppp-&gt;hmf) <br>goto err; <br>} <br>#endif// DEBUG <br> <br>// update the current page number <br>ppp-&gt;ipage += fPrev ? -1 : 1; <br> <br>EnableWindow(GetDlgItem(ppp-&gt;hwndDlg, PSB_PrevPage), ppp-&gt;ipage &gt; 0); <br>EnableWindow(GetDlgItem(ppp-&gt;hwndDlg, PSB_NextPage), <br>!ppp-&gt;fDone || ppp-&gt;ipage + 1 &lt; ppp-&gt;cpage); <br> <br>wsprintf(szCaption, szFmtPrintPreview, ppp-&gt;ipage + 1); <br>SetWindowText(ppp-&gt;hwndDlg, szCaption); <br> <br>// cause redraw <br>InvalidateRect(ppp-&gt;hwndDlg, NULL, fTrue); <br> <br>(void) SetCursor(hcur); </code></pre>
<p>
</p>
<pre><code><br>return; <br> <br>#ifdef DEBUG <br>err: <br>ppp-&gt;fDone = fTrue; <br> <br>// free up RichEdit's format range info <br>ppp-&gt;fr.chrg.cpMin = ppp-&gt;fr.chrg.cpMost = ppp-&gt;cchText; <br>SendMessage(ppp-&gt;predoc-&gt;hwndRE, EM_FORMATRANGE, 0, 0); <br>// setup for a prev <br>ppp-&gt;fr.chrg.cpMost = ppp-&gt;cchText; <br>(void) SetCursor(hcur); <br>MessageBoxA(hwndMain, <br>"An error occurred while processing the print preview", <br>NULL, MB_ICONSTOP | MB_OK); <br>#endif// DEBUG <br>} <br> <br> <br>LOCAL VOID PPPaint(PRINTPREVIEW *ppp) <br>{ <br>HDC hdc; <br>RECT rc; <br>RECT rcClient; <br>PAINTSTRUCT ps; <br> <br>// if we're iconic, don't bother <br>if(IsIconic(ppp-&gt;hwndDlg)) <br>return; <br> <br>hdc = BeginPaint(ppp-&gt;hwndDlg, &amp;ps); <br>SaveDC(hdc); <br>GetClientRect(ppp-&gt;hwndDlg, &amp;rcClient); <br>GetWindowRect(GetDlgItem(ppp-&gt;hwndDlg, PSB_TopLeft), &amp;rc); <br>MapWindowPoints(GetDesktopWindow(), ppp-&gt;hwndDlg, (LPPOINT) &amp;rc, 2); <br>rc.bottom = rc.top + GetSystemMetrics(SM_CYBORDER); <br>rc.right = rcClient.right; <br>SetBkColor(hdc, GetSysColor(COLOR_WINDOWFRAME)); <br>ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, &amp;rc, "", 0, NULL); <br>rc.top = rc.bottom; <br>rc.bottom = rcClient.bottom; <br>#ifdef DEBUG <br>if(ppp-&gt;hmf) <br>{ <br>// erase the background <br>SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, &amp;rc, "", 0, NULL); <br>// make the window the same logical size as the page <br>SetMapMode(hdc, MM_ANISOTROPIC); <br>SetViewportOrgEx(hdc, rc.left, rc.top, NULL); <br>TraceTag(tagEnumMF, "Viewport Org = %d, %d", rc.left, rc.top); <br>SetViewportExtEx(hdc, rc.right - rc.left, rc.bottom - rc.top, NULL); <br>TraceTag(tagEnumMF, "Viewport Ext = %d, %d", rc.right - rc.left, rc.bottom - rc.top); <br>if(FFromTag(tagEnumMF)) <br>EnumMetaFile(hdc, ppp-&gt;hmf, MFEnumCallback, 0); <br>PlayMetaFile(hdc, ppp-&gt;hmf); <br>} <br>else <br>#endif// DEBUG <br>if(ppp-&gt;ipage &gt;= 0) <br>{ <br>#ifdef NOBLIT <br>HDC hdcSave = ppp-&gt;fr.hdc; <br>LONG xPerInch = GetDeviceCaps(hdc, LOGPIXELSX); <br>LONG yPerInch = GetDeviceCaps(hdc, LOGPIXELSY); <br> <br>// make the window the same logical size as the page <br>SetMapMode(hdc, MM_ANISOTROPIC); <br>SetWindowExtEx(hdc, (ppp-&gt;dxPage * xPerInch) / 1440, <br>(ppp-&gt;dyPage * yPerInch) / 1440, NULL); <br>SetViewportExtEx(hdc, rc.right - rc.left, rc.bottom - rc.top, NULL); <br> <br>// erase the background <br>SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, &amp;rc, "", 0, NULL); <br> <br>// tell RichEdit not to bother erasing the background <br>SetBkMode(hdc, TRANSPARENT); <br> <br>ppp-&gt;fr.hdc = hdc; <br>ppp-&gt;fr.rc = ppp-&gt;rc; <br>ppp-&gt;fr.chrg.cpMin = ppp-&gt;rgcpPages[ppp-&gt;ipage]; <br>ppp-&gt;fr.chrg.cpMin = SendMessage(ppp-&gt;predoc-&gt;hwndRE, EM_FORMATRANGE, <br>(WPARAM) fTrue, (LPARAM) &amp;ppp-&gt;fr); <br>ppp-&gt;fr.hdc = hdcSave; <br>#else// NOBLIT <br>// convert RECT to x,y,dx,dy <br>rc.right -= rc.left; <br>rc.bottom -= rc.top; <br> <br>StretchBlt(hdc, rc.left, rc.top, rc.right, rc.bottom, <br>ppp-&gt;fr.hdc, 0, 0, ppp-&gt;dxBmp, ppp-&gt;dyBmp, SRCCOPY); <br>#endif// NOBLIT, else <br>} <br>RestoreDC(hdc, -1); <br>EndPaint(ppp-&gt;hwndDlg, &amp;ps); <br>} <br> <br>#ifdef DEBUG <br> <br>int CALLBACK MFEnumCallback(HDC hdc, HANDLETABLE *lpHTable, METARECORD *pmfr, <br>int nObj, LPARAM lparam) <br>{ <br>switch(pmfr-&gt;rdFunction) <br>{ <br>case META_SETWINDOWORG: <br>TraceTag(tagEnumMF, "SetWindowOrg(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_SETVIEWPORTORG: <br>TraceTag(tagEnumMF, "SetViewportOrg(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_OFFSETWINDOWORG: <br>TraceTag(tagEnumMF, "OffsetWindowOrg(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_OFFSETVIEWPORTORG: <br>TraceTag(tagEnumMF, "OffsetViewportOrg(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_SETWINDOWEXT: <br>TraceTag(tagEnumMF, "SetWindowExt(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_SETVIEWPORTEXT: <br>TraceTag(tagEnumMF, "SetViewportExt(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_SCALEWINDOWEXT: <br>TraceTag(tagEnumMF, "ScaleWindowExt(): %d, %d, %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[3], (INT) (SHORT) pmfr-&gt;rdParm[2], (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_SCALEVIEWPORTEXT: <br>TraceTag(tagEnumMF, "ScaleViewportExt(): %d, %d, %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[3], (INT) (SHORT) pmfr-&gt;rdParm[2], (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_SAVEDC: <br>TraceTag(tagEnumMF, "SaveDC()"); <br>break; <br> <br>case META_RESTOREDC: <br>TraceTag(tagEnumMF, "RestoreDC()"); <br>break; <br> <br>case META_SELECTPALETTE: <br>TraceTag(tagEnumMF, "Select Palette"); <br>break; <br> <br>case META_SETMAPMODE: <br>TraceTag(tagEnumMF, "SetMapMode(): %d", (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_EXTTEXTOUT: <br>TraceTag(tagEnumMF, "ExtTextOut(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_TEXTOUT: <br>TraceTag(tagEnumMF, "TextOut(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[3], (INT) (SHORT) pmfr-&gt;rdParm[2]); <br>break; <br> <br>case META_LINETO: <br>TraceTag(tagEnumMF, "LineTo(): %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br> <br>case META_RECTANGLE: <br>TraceTag(tagEnumMF, "Rectangle(): %d, %d, %d, %d", (INT) (SHORT) pmfr-&gt;rdParm[3], (INT) (SHORT) pmfr-&gt;rdParm[2], (INT) (SHORT) pmfr-&gt;rdParm[1], (INT) (SHORT) pmfr-&gt;rdParm[0]); <br>break; <br>} <br> <br>return fTrue; <br>} <br> <br>#endif// DEBUG <br> <br> <br>/* <br> *I T P C A L L   I m p l e m e n t a t i o n <br> */ <br> <br> <br>/*  <br> *ITPCALL_New <br> * <br> *Purpose: <br> *Creates a new ITPCALL. <br> * <br> *Arguments: <br> *REDOC *Pointer to the document information. <br> * <br> *Returns: <br> *ITPCALL *The newly created ITPCALL. <br> */ <br>ITPCALL * ITPCALL_New(REDOC * predoc) <br>{ <br>#ifndef NO_OLE <br>ITPCALL * pitpcall; <br> <br>if(!(pitpcall = (ITPCALL *) GlobalAllocPtr(GHND, sizeof(ITPCALL)))) <br>goto Error; <br>pitpcall-&gt;lpVtbl = &amp;ITPCALL_Vtbl; <br>pitpcall-&gt;cRef = 1;// Start with one reference <br>pitpcall-&gt;predoc = predoc; <br>if(!(pitpcall-&gt;pipframe = ITPOLEINPLACEFRAME_New(predoc))) <br>GlobalFreePtr(pitpcall); <br>else <br>return pitpcall; <br>Error: <br>#endif// !NO_OLE <br> <br>return NULL; <br>} <br> <br> <br>/* <br> *ITPCALL_QueryInterface <br> * <br> *Purpose: <br> *Returns a pointer to the specified site. <br> * <br> *Arguments: <br> *LPUNKNOWN *Object from which we want an interface. <br> *REFIIDInterface we want. <br> *LPUNKNOWN *Interface we return. <br> * <br> *Returns: <br> *HRESULT Error status. <br> */ <br>STDMETHODIMP ITPCALL_QueryInterface(LPUNKNOWN punk, REFIID riid,  <br>   LPUNKNOWN * ppvObj) <br>{ <br>SCODE sc = S_OK; <br> <br>if(IsEqualIID(riid, &amp;IID_IUnknown)) <br>ITPCALL_AddRef(*ppvObj = punk); <br>else if(IsEqualIID(riid, &amp;IID_IRichEditOleCallback)) <br>ITPCALL_AddRef(*ppvObj = punk); <br>else <br>sc = E_NOINTERFACE, *ppvObj = NULL; <br> <br>return sc; <br>} <br> <br> <br>/* <br> *ITPCALL_AddRef <br> * <br> *Purpose: <br> *Increments reference count on the specified site. <br> * <br> *Arguments: <br> *LPUNKNOWN *Object whose count we want to increment. <br> * <br> *Returns: <br> *ULONGNew value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) ITPCALL_AddRef(LPUNKNOWN punk) <br>{ <br>return ++PitpcallFromPunk(punk)-&gt;cRef; <br>} <br> <br> <br>/* <br> *ITPCALL_Release <br> * <br> *Purpose: <br> *Decrements reference count on the specified site.  If count is <br> *decremented to zero, the object is freed. <br> * <br> *Arguments: <br> *LPUNKNOWN *Object whose count we want to decrement. <br> * <br> *Returns: <br> *ULONGNew value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) ITPCALL_Release(LPUNKNOWN punk) <br>{ <br>#ifndef NO_OLE <br>ITPCALL * pitpcall = PitpcallFromPunk(punk); <br>ULONG cRef = --pitpcall-&gt;cRef; <br> <br>if(!cRef) <br>{ <br>// Free stuff we own <br>if(pitpcall-&gt;pipframe) <br>{ <br>pitpcall-&gt;pipframe-&gt;lpVtbl-&gt;Release((LPOLEINPLACEFRAME)  <br> pitpcall-&gt;pipframe); <br>} <br> <br>// Free memory allocated for us <br>GlobalFreePtr(pitpcall); <br>TraceTag(tagITPCALL, "ITPCALL_Release: freeing the itpcall"); <br>} <br> <br>AssertSz(cRef &gt;= 0, "ITPCALL_Release: negative cRef"); <br>return cRef; <br>#endif// !NO_OLE <br> <br>return (ULONG) NULL; <br>} <br> <br> <br>/* <br> *ITPCALL_GetNewStorage <br> * <br> *Purpose: <br> *Gets storage for a new object. <br> * <br> *Arguments: <br> *ITPCALL *Callback object. <br> *LPSTORAGE FAR *Where to return storage. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPCALL_GetNewStorage(ITPCALL * pitpcall, LPSTORAGE FAR * ppstg) <br>{ <br>SCODE sc = S_OK; <br>WCHAR szItemW[OLEUI_CCHPATHMAX]; <br> <br>wsprintfW(szItemW, L"REOBJ%ld", ++pitpcall-&gt;predoc-&gt;cItem); <br>if(!(*ppstg = OleStdCreateChildStorage(pitpcall-&gt;predoc-&gt;pstg, szItemW))) <br>{ <br>MessageBoxW(hwndMain, szItemW, L"No item storage!", MB_OK); <br>sc = E_FAIL; <br>} <br> <br>return sc; <br>} <br> <br> <br>/* <br> *ITPCALL_GetInPlaceContext <br> * <br> *Purpose: <br> *Gets context information for an in place object. <br> * <br> *Arguments: <br> *ITPCALL *Callback object. <br> *LPOLEINPLACEFRAME *Frame window object. <br> *LPOLEINPLACEUIWINDOW *Document window object. <br> *LPOLEINPLACEFRAMEINFOFrame window information. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPCALL_GetInPlaceContext(ITPCALL * pitpcall,  <br>   LPOLEINPLACEFRAME FAR * ppipframe, <br>   LPOLEINPLACEUIWINDOW FAR* ppipuiDoc, <br>   LPOLEINPLACEFRAMEINFO pipfinfo) <br>{ <br>#ifndef NO_OLE <br>// Return window pointers <br>*ppipframe = (LPOLEINPLACEFRAME) pitpcall-&gt;pipframe; <br>(VOID) (*ppipframe)-&gt;lpVtbl-&gt;AddRef(*ppipframe); <br>*ppipuiDoc = NULL; <br> <br>// Fill in frame window information <br>pipfinfo-&gt;cb = sizeof(OLEINPLACEFRAMEINFO); <br>pipfinfo-&gt;fMDIApp = FALSE; <br>pipfinfo-&gt;hwndFrame = pitpcall-&gt;predoc-&gt;hwndParent; <br>pipfinfo-&gt;haccel = (long) NULL; <br>pipfinfo-&gt;cAccelEntries = 0; <br>#endif// !NO_OLE <br> <br>return S_OK; <br>} <br> <br> <br>/* <br> *ITPCALL_ShowContainerUI <br> * <br> *Purpose: <br> *Displays or hides REITP's container UI. <br> * <br> *Arguments: <br> *ITPCALL *Callback object. <br> *BOOL <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPCALL_ShowContainerUI(ITPCALL * pitpcall, BOOL fShow) <br>{ <br>TraceTag(tagITPCALL, "ITPCALL_ShowContainerUI(%d)", fShow); <br> <br>// If we're displaying our UI, show our menus <br>if(fShow) <br>ITPOLEINPLACEFRAME_SetMenu(pitpcall-&gt;pipframe, NULL, NULL, NULL); <br> <br>return S_OK; <br>} <br> <br> <br>STDMETHODIMP ITPCALL_QueryInsertObject(ITPCALL * pitpcall, LPCLSID pclsid, <br>LPSTORAGE pstg, LONG cp) <br>{ <br>#if !defined(NO_OLE) &amp;&amp; defined(DEBUG) <br>LPTSTR szProgID; <br> <br>if(HrProgIDFromCLSIDA(pclsid, &amp;szProgID)) <br>{ <br>TraceTag(tagITPCALL, "QueryInsertObject(): unknown class id"); <br>} <br>else <br>{ <br>SCODE sc = S_OK; <br> <br>TraceTag(tagITPCALL, "QueryInsertObject(): %s object", szProgID); <br>if(QueryCheck(pitpcall-&gt;predoc, IDM_REFUSEGRAPH) &amp;&amp; <br>!lstrcmpi(szProgID, "MSGraph")) <br>{ <br>TraceTag(tagITPCALL, "Refusing object"); <br>sc = S_FALSE; <br>} <br>OleStdFreeString((LPSTR) szProgID, NULL); <br>return sc; <br>} <br>#endif// !NO_OLE &amp;&amp; DEBUG <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP ITPCALL_DeleteObject(ITPCALL * pitpcall, LPOLEOBJECT poleobj) <br>{ <br>TraceTag(tagITPCALL, "DeleteObject()"); <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP ITPCALL_QueryAcceptData(ITPCALL * pitpcall, LPDATAOBJECT pdataobj, <br>CLIPFORMAT *pcfFormat, DWORD reco, BOOL fReally, <br>HGLOBAL hMetaPict) <br>{ <br>#if !defined(NO_OLE) &amp;&amp; defined(DEBUG) <br>TraceTag(tagITPCALL, "QueryAcceptData(%s) for %s", fReally ? "really" : "test", (reco == RECO_DROP ? "drop" : (reco == RECO_PASTE ? "paste" : "unknown op"))); <br>if(pitpcall-&gt;predoc-&gt;fReadOnly) <br>{ <br>BOOL fDoIt = fFalse; <br>HRESULT hr; <br> <br>switch(reco) <br>{ <br>case RECO_DROP: <br>fDoIt = QueryCheck(pitpcall-&gt;predoc, IDM_ENABLEDRAGREADONLY); <br>break; <br> <br>case RECO_PASTE: <br>fDoIt = QueryCheck(pitpcall-&gt;predoc, IDM_ENABLEPASTEREADONLY); <br>break; <br> <br>default: <br>TraceTag(tagNull, "QAD: invalid RECO %lx", reco); <br>AssertSz(fFalse, "QAD: invalid RECO"); <br>break; <br>} <br>if(fDoIt) <br>{ <br>if(fReally) <br>{ <br>LPRICHEDITOLE const preole = pitpcall-&gt;predoc-&gt;preole; <br> <br>// import that sucker <br> <br>hr = preole-&gt;lpVtbl-&gt;ImportDataObject(preole, pdataobj, <br>*pcfFormat, hMetaPict); <br>TraceError("IRichEditOle::ImportDataObject", hr); <br>if(SUCCEEDED(hr)) <br>hr = S_FALSE;// we did it ourselves <br>} <br>else <br>{ <br>// return that we'll import it ourselves <br>hr = S_FALSE; <br>} <br>} <br>else <br>{ <br>hr = E_FAIL; <br>} <br>TraceError("IPCALL_QueryAcceptData", hr); <br>return hr; <br>} <br>if(QueryCheck(pitpcall-&gt;predoc, IDM_TEXTONLY)) <br>{ <br>TraceTag(tagITPCALL, "QueryAcceptData(): asking for text only"); <br>*pcfFormat = CF_TEXT;// accept only text <br>} <br>else <br>{ <br>TraceTag(tagITPCALL, "QueryAcceptData(): delegating back to RichEdit"); <br>} <br>#endif// !NO_OLE &amp;&amp; DEBUG <br> <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP ITPCALL_ContextSensitiveHelp(ITPCALL * pitpcall, BOOL fEnterMode) <br>{ <br>return NOERROR; <br>} <br> <br> <br>STDMETHODIMP ITPCALL_GetClipboardData(ITPCALL *pitpcall, CHARRANGE *pchrg, <br>DWORD reco, LPDATAOBJECT *ppdataobj) <br>{ <br>#if !defined(NO_OLE) &amp;&amp; defined(DEBUG) <br>TraceTag(tagITPCALL, "GetClipboardData(%d-%d) for %s", pchrg-&gt;cpMin, pchrg-&gt;cpMost, reco == RECO_COPY ? "copy" : (reco == RECO_CUT ? "cut" : (reco == RECO_DRAG ? "drag" : "unknown op"))); <br> <br>if(pitpcall-&gt;predoc-&gt;fReadOnly) <br>{ <br>BOOL fDoIt = fFalse; <br> <br>switch(reco) <br>{ <br>case RECO_COPY: <br>// prevent assert in default case <br>break; <br> <br>case RECO_CUT: <br>fDoIt = QueryCheck(pitpcall-&gt;predoc, IDM_ENABLECUTREADONLY); <br>break; <br> <br>case RECO_DRAG: <br>fDoIt = QueryCheck(pitpcall-&gt;predoc, IDM_ENABLEDRAGREADONLY); <br>break; <br> <br>default: <br>TraceTag(tagNull, "GCD: invalid RECO %lx", reco); <br>AssertSz(fFalse, "GCD: invalid RECO"); <br>break; <br>} <br>if(fDoIt) <br>{ <br>LPRICHEDITOLE const preole = pitpcall-&gt;predoc-&gt;preole; <br>HRESULT hr; <br> <br>// delegate to IRichEditOle::GetClipboardData() <br> <br>*ppdataobj = NULL; <br>hr = preole-&gt;lpVtbl-&gt;GetClipboardData(preole, pchrg, reco, <br>ppdataobj); <br>TraceError("IRichEditOle::GetClipboardData", hr); <br>if(SUCCEEDED(hr) &amp;&amp; *ppdataobj) <br>hr = S_FALSE;// we did it ourselves <br>TraceError("IPCALL_GetClipboardData", hr); <br>return hr; <br>} <br>// go return E_NOTIMPL &amp; let RichEdit deal with it itself <br>} <br>#endif// !NO_OLE &amp;&amp; DEBUG <br> <br>// *ppdataobj isn't used if E_NOTIMPL is returned <br>// so we don't need to set it <br> <br>// tell RichEdit to do it itself <br>TraceTag(tagITPCALL, "GetClipboardData(): delegating back to RichEdit"); <br>return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP ITPCALL_GetDragDropEffect(ITPCALL *pitpcall, BOOL fDrag, <br>DWORD grfKeyState, LPDWORD pdwEffect) <br>{ <br>TraceTag(tagITPCALL, "GetDragDropEffect(%s)", fDrag ? "drag" : "drop"); <br> <br>#ifdef DEBUG <br>if(QueryCheck(pitpcall-&gt;predoc, IDM_SWAPDRAGEFFECT)) <br>{ <br>DWORD dwT; <br> <br>// strip off move, copy, and link <br>dwT = *pdwEffect &amp; <br>~(DWORD) (DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK); <br> <br>if(!pitpcall-&gt;predoc-&gt;fReadOnly || <br>QueryCheck(pitpcall-&gt;predoc, IDM_ENABLEDRAGREADONLY)) <br>{ <br>if(fDrag) <br>dwT = DROPEFFECT_MOVE | DROPEFFECT_COPY; <br>else if(grfKeyState &amp; MK_CONTROL) <br>dwT = DROPEFFECT_MOVE; <br>else <br>dwT = DROPEFFECT_COPY; <br>} <br> <br>*pdwEffect = dwT; <br> <br>return NOERROR; <br>} <br>#endif// DEBUG <br> <br>// delegate back to RichEdit <br>return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP ITPCALL_GetContextMenu(ITPCALL *pitpcall, WORD seltype, <br>LPOLEOBJECT poleobj, CHARRANGE * pchrg, HMENU * phmenu) <br>{ <br>HMENU hmenu; <br>HMENU hmenuParent = NULL; <br>HMENU hmenuVerbs = NULL; <br>UINT uiT; <br> <br>TraceTag(tagITPCALL, "GetContextMenu"); <br> <br>hmenuParent = CreatePopupMenu(); <br>if(!hmenuParent) <br>goto Cleanup; <br> <br>// Put the verbs on the menu <br>if(poleobj) <br>{ <br>OleUIAddVerbMenu(poleobj, NULL, hmenuParent, 0, IDM_OBJECTMIN,  <br>0, TRUE, IDM_OBJECTCONVERT, &amp;hmenuVerbs); <br>} <br> <br>// Determine which menu to pass back to RichEdit <br>*phmenu = hmenu = hmenuVerbs ? hmenuVerbs : hmenuParent; <br> <br>if(poleobj) <br>AppendMenu(hmenu, MF_SEPARATOR, 0, NULL); <br> <br>// Add the cut, copy, paste verbs <br> <br>uiT = MF_STRING | MF_BYCOMMAND; <br>uiT |= pchrg-&gt;cpMin == pchrg-&gt;cpMost ? uiMFDisabled : uiMFEnabled; <br>AppendMenu(hmenu, uiT, IDM_CUT, "Cut"); <br>AppendMenu(hmenu, uiT, IDM_COPY, "Copy"); <br> <br> <br>uiT = MF_STRING | MF_BYCOMMAND; <br>uiT |= SendMessage(pitpcall-&gt;predoc-&gt;hwndRE, EM_CANPASTE, 0, 0) <br>? uiMFEnabled : uiMFDisabled; <br>AppendMenu(hmenu, uiT, IDM_PASTE, "Paste"); <br> <br>Cleanup: <br>if(hmenu == hmenuVerbs &amp;&amp; hmenuParent) <br>DestroyMenu(hmenuParent); <br>else if(hmenu == hmenuParent &amp;&amp; hmenuVerbs) <br>DestroyMenu(hmenuVerbs); <br> <br>return S_OK; <br>} <br> <br> <br>/* <br> *I T P O L E I N P L A C E F R A M E  I m p l e m e n t a t i o n <br> */ <br> <br> <br>/*  <br> *ITPOLEINPLACEFRAME_New <br> * <br> *Purpose: <br> *Creates a new ITPOLEINPLACEFRAME. <br> * <br> *Arguments: <br> *REDOC *Pointer to the document information. <br> * <br> *Returns: <br> *ITPOLEINPLACEFRAME *The newly created ITPOLEINPLACEFRAME. <br> */ <br>ITPOLEINPLACEFRAME * ITPOLEINPLACEFRAME_New(REDOC * predoc) <br>{ <br>#ifndef NO_OLE <br>ITPOLEINPLACEFRAME * pipframe; <br> <br>if(!(pipframe = (ITPOLEINPLACEFRAME *) GlobalAllocPtr(GHND, sizeof(ITPOLEINPLACEFRAME)))) <br>return NULL; <br>pipframe-&gt;lpVtbl = &amp;ITPOLEINPLACEFRAME_Vtbl; <br>pipframe-&gt;cRef = 1;// Start with one reference <br>pipframe-&gt;predoc = predoc; <br>return pipframe; <br>#endif// !NO_OLE <br> <br>return NULL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_QueryInterface <br> * <br> *Purpose: <br> *Returns a pointer to the specified site. <br> * <br> *Arguments: <br> *LPUNKNOWN *Object from which we want an interface. <br> *REFIIDInterface we want. <br> *LPUNKNOWN *Interface we return. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_QueryInterface(LPUNKNOWN punk, REFIID riid,  <br>   LPUNKNOWN * ppvObj) <br>{ <br>SCODE sc = S_OK; <br> <br>if(IsEqualIID(riid, &amp;IID_IUnknown) || <br>IsEqualIID(riid, &amp;IID_IOleWindow) || <br>IsEqualIID(riid, &amp;IID_IOleInPlaceUIWindow) || <br>IsEqualIID(riid, &amp;IID_IOleInPlaceFrame)) <br>{ <br>ITPOLEINPLACEFRAME_AddRef(*ppvObj = punk); <br>} <br>else <br>{ <br>sc = E_NOINTERFACE, *ppvObj = NULL; <br>} <br> <br>return sc; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_AddRef <br> * <br> *Purpose: <br> *Increments reference count on the specified site. <br> * <br> *Arguments: <br> *LPUNKNOWN *Object whose count we want to increment. <br> * <br> *Returns: <br> *ULONGNew value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) ITPOLEINPLACEFRAME_AddRef(LPUNKNOWN punk) <br>{ <br>return ++PipframeFromPunk(punk)-&gt;cRef; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_Release <br> * <br> *Purpose: <br> *Decrements reference count on the specified site.  If count is <br> *decremented to zero, the object is freed. <br> * <br> *Arguments: <br> *LPUNKNOWN *Object whose count we want to decrement. <br> * <br> *Returns: <br> *ULONGNew value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) ITPOLEINPLACEFRAME_Release(LPUNKNOWN punk) <br>{ <br>ITPOLEINPLACEFRAME * pipframe = PipframeFromPunk(punk); <br>ULONG cRef = --pipframe-&gt;cRef; <br> <br>if(!cRef) <br>{ <br>// Free memory allocated for us <br>GlobalFreePtr(pipframe); <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_Release: freeing the ipframe"); <br>} <br> <br>AssertSz(cRef &gt;= 0, "ITPOLEINPLACEFRAME_Release: negative cRef"); <br> <br>return cRef; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_GetWindow <br> * <br> *Purpose: <br> *Return the window handle of the app-level window for in place use. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_GetWindow(ITPOLEINPLACEFRAME * pipframe, <br>  HWND * phwnd) <br>{ <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_GetWindow: NYI"); <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_ContextSensitiveHelp <br> * <br> *Purpose: <br> *Notifies the frame that the object has entered Context Help mode. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_ContextSensitiveHelp(ITPOLEINPLACEFRAME *pipframe, <br> BOOL fEnterMode) <br>{ <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_ContextSensitiveHelp: NYI"); <br>TraceError("ITPOLEINPLACEFRAME_ContextSensitiveHelp()", E_NOTIMPL); <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_GetBorder <br> * <br> *Purpose: <br> *Returns a RECT structure in which the object can put toolbars and  <br> *similar controls while an object is active in place. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_GetBorder(ITPOLEINPLACEFRAME * pipframe, <br>  LPRECT prcBorder) <br>{ <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_GetBorder: NYI"); <br>TraceError("ITPOLEINPLACEFRAME_GetBorder()", E_NOTIMPL); <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_RequestBorderSpace <br> * <br> *Purpose: <br> *Determines whether tools can be installed around the objects  <br> *window frame while the object is active in place. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_RequestBorderSpace(ITPOLEINPLACEFRAME * pipframe, <br>   LPCBORDERWIDTHS pbw) <br>{ <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_RequestBorderSpace: NYI"); <br>TraceError("ITPOLEINPLACEFRAME_RequestBorderSpace()", E_NOTIMPL); <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_SetBorderSpace <br> * <br> *Purpose: <br> *Allocates space for the border requested in the call to the  <br> *RequestBorderSpace member function. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetBorderSpace(ITPOLEINPLACEFRAME * pipframe, <br>   LPCBORDERWIDTHS pbw) <br>{ <br>//$ FUTURE: If NULL, then put our tools back <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_SetBorderSpace: NYI"); <br>TraceError("ITPOLEINPLACEFRAME_SetBorderSpace()", E_NOTIMPL); <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_SetActiveObject <br> * <br> *Purpose: <br> *Called by the object to provide the frame window a direct channel  <br> *of communication with the active in-place object. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetActiveObject(ITPOLEINPLACEFRAME * pipframe, <br>    LPOLEINPLACEACTIVEOBJECT pipaobj, <br>    LPCSTR szObjName) <br>{ <br>#ifndef NO_OLE <br>// Free any existing active object <br>if(pipframe-&gt;pipaobj) <br>pipframe-&gt;pipaobj-&gt;lpVtbl-&gt;Release(pipframe-&gt;pipaobj); <br> <br>// If we're given an object, AddRef it; update our remembered ipaobj <br>if(pipaobj) <br>pipaobj-&gt;lpVtbl-&gt;AddRef(pipaobj); <br>pipframe-&gt;pipaobj = pipaobj; <br> <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_SetActiveObject: %s", szObjName ? szObjName : "NULL"); <br>#endif// !NO_OLE <br> <br>return S_OK; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_InsertMenus <br> * <br> *Purpose: <br> *Called by the object server to allow the container to insert  <br> *its menu groups in the composite menu that will be used during <br> *the in-place session. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_InsertMenus(ITPOLEINPLACEFRAME * pipframe, <br>    HMENU hmenuShared,  <br>    LPOLEMENUGROUPWIDTHS pmgw) <br>{ <br>//$ FUTURE: Do something interesting here <br>// Don't actually put any menus on right now <br>pmgw-&gt;width[0] = pmgw-&gt;width[2] = pmgw-&gt;width[4] = 0; <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_InsertMenus: S_OK"); <br> <br>return S_OK; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_SetMenu <br> * <br> *Purpose: <br> *Installs the composite menu into the window frame containing <br> *the object that is being activated in place. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetMenu(ITPOLEINPLACEFRAME * pipframe,  <br>    HMENU hmenuShared, HOLEMENU holemenu,  <br>    HWND hwndActiveObject) <br>{ <br>#ifndef NO_OLE <br>HWND hwnd = pipframe-&gt;predoc-&gt;hwndParent; <br> <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_SetMenu: hMenuShared=%08lx holemenu=%08lx", (DWORD) (LPVOID) hmenuShared, (DWORD) (LPVOID) holemenu); <br> <br>// Did OLE give us a menu, or leave us to ourselves? <br>if(hmenuShared &amp;&amp; holemenu) <br>{ <br>// Put the merged menu OLE gave us on our menu bar <br>SetMenu(hwnd, hmenuShared); <br>} <br>else <br>{ <br>// Put our regular menu on the menu bar <br>SetMenu(hwnd, hmenuFull); <br>SetupWordWrapMenu(pipframe-&gt;predoc); <br>} <br>DrawMenuBar(hwnd); <br># ifdef MAC <br>DebugStr("\pTry calling OleSetMenuDescriptor()"); <br># else// MAC <br>// Pass the menu descriptor to OLE <br>return OleSetMenuDescriptor(holemenu, pipframe-&gt;predoc-&gt;hwndParent,  <br>hwndActiveObject, (LPOLEINPLACEFRAME) pipframe, <br>pipframe-&gt;pipaobj); <br># endif// MAC, else <br>#endif// !NO_OLE <br> <br>return S_OK; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_RemoveMenus <br> * <br> *Purpose: <br> *Called by the object server to give the container a chance to  <br> *remove its menu elements from the in-place composite menu. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_RemoveMenus(ITPOLEINPLACEFRAME * pipframe,  <br>    HMENU hmenuShared) <br>{ <br>// We didn't put any menus on! <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_RemoveMenus: S_OK"); <br> <br>return S_OK; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_SetStatusText <br> * <br> *Purpose: <br> *Sets and displays status text about the in-place object in the <br> *containers frame window status line. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_SetStatusText(ITPOLEINPLACEFRAME * pipframe,  <br>  LPCSTR szStatusText) <br>{ <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_SetStatusText: NYI"); <br>TraceError("ITPOLEINPLACEFRAME_SetStatusText()", E_NOTIMPL); <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_EnableModeless <br> * <br> *Purpose: <br> *Enables or disables modeless dialogs of the frame. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_EnableModeless(ITPOLEINPLACEFRAME * pipframe,  <br>   BOOL fEnable) <br>{ <br>TraceTag(tagInPlace, "ITPOLEINPLACEFRAME_EnableModeless: NYI"); <br>TraceError("ITPOLEINPLACEFRAME_EnableModeless()", E_NOTIMPL); <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/* <br> *ITPOLEINPLACEFRAME_TranslateAccelerator <br> * <br> *Purpose: <br> *Translates keystrokes intended for the container frame while <br> *an object is active in place. <br> * <br> *Arguments: <br> *ITPOLEINPLACESITE *Client site. <br> * <br> *Returns: <br> *HRESULTError status. <br> */ <br>STDMETHODIMP ITPOLEINPLACEFRAME_TranslateAccelerator(ITPOLEINPLACEFRAME *pipframe, <br> LPMSG pmsg, WORD wID) <br>{ <br>// REITP doesn't have any accelerators! <br>return S_FALSE; <br>} <br> <br> <br>LOCAL VOID FindReplace(REDOC *predoc, BOOL fReplace) <br>{ <br>FINDREPLACE *pfr; <br> <br>if(hwndFR) <br>return; <br> <br>if(!(pfr = predoc-&gt;pfr)) <br>{ <br>pfr = predoc-&gt;pfr = (FINDREPLACE * ) GlobalAllocPtr(GHND, <br>sizeof(FINDREPLACE) + 2 * 80 * sizeof(TCHAR)); <br>if(!predoc-&gt;pfr) <br>return; <br>} <br>else <br>{ <br>memset(pfr, 0, sizeof(FINDREPLACE)); <br>} <br> <br>SendMessage(predoc-&gt;hwndRE, EM_HIDESELECTION, fFalse, fTrue); <br> <br>pfr-&gt;lStructSize = sizeof(FINDREPLACE); <br>pfr-&gt;hwndOwner = predoc-&gt;hwndParent; <br>pfr-&gt;Flags = FR_HIDEUPDOWN; <br>pfr-&gt;lpstrFindWhat = (LPSTR) (((BYTE *) pfr) + sizeof(FINDREPLACE)); <br>pfr-&gt;lpstrReplaceWith = pfr-&gt;lpstrFindWhat + 80; <br>pfr-&gt;wFindWhatLen = 80 * sizeof(TCHAR); <br>pfr-&gt;wReplaceWithLen = 80 * sizeof(TCHAR); <br> <br>hwndFR = fReplace ? ReplaceText(pfr) : FindText(pfr); <br>} <br> <br> <br>LOCAL VOID ProcessFindReplace(REDOC *predoc, FINDREPLACE *pfr) <br>{ <br>HCURSOR hcur; <br>LONG cszReplaced = 0; <br>LONG cpMatch; <br>CHARRANGE chrgSave; <br>FINDTEXTEX ft; <br> <br>SendMessage(predoc-&gt;hwndRE, EM_EXGETSEL, 0, (LPARAM) &amp;chrgSave); <br>ft.chrg.cpMost = -1;// search through end of the text <br>ft.chrg.cpMin = chrgSave.cpMin; <br>if(!(pfr-&gt;Flags &amp; (FR_REPLACE | FR_REPLACEALL))) <br>ft.chrg.cpMin = chrgSave.cpMost; <br>ft.lpstrText = pfr-&gt;lpstrFindWhat; <br> <br>if(pfr-&gt;Flags &amp; FR_REPLACEALL) <br>{ <br>hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>SendMessage(predoc-&gt;hwndRE, EM_HIDESELECTION, fTrue, fFalse); <br>} <br> <br>next: <br>cpMatch = SendMessage(predoc-&gt;hwndRE, EM_FINDTEXTEX, <br>(WPARAM) (pfr-&gt;Flags), <br>(LPARAM) &amp;ft); <br>if(cpMatch &lt; 0) <br>{ <br>if(cszReplaced == 0) <br>{ <br>MessageBoxA(hwndFR, <br>"The search text is not found.", szAppName, MB_OK); <br>} </code></pre>
<p>
</p>
<pre><code>else <br>{ <br>char rgch[80]; <br> <br>wsprintfA(rgch, "Replaced %ld occurances.", cszReplaced); <br>MessageBoxA(hwndFR, rgch, szAppName, MB_OK); <br>} <br>SetFocus(hwndFR); <br>goto done; <br>} <br>//ft.chrg.cpMin = cpMatch; <br>//ft.chrg.cpMost = cpMatch + lstrlen(ft.lpstrText); <br>ft.chrg.cpMin = ft.chrgText.cpMin; <br>ft.chrg.cpMost = ft.chrgText.cpMost; <br>SendMessage(predoc-&gt;hwndRE, EM_EXSETSEL, 0, (LPARAM) &amp;ft.chrg); <br>if(((pfr-&gt;Flags &amp; FR_REPLACE) &amp;&amp; cszReplaced == 0) || <br>(pfr-&gt;Flags &amp; FR_REPLACEALL)) <br>{ <br>SendMessage(predoc-&gt;hwndRE, EM_REPLACESEL, 0, <br>(LPARAM) pfr-&gt;lpstrReplaceWith); <br>ft.chrg.cpMin = cpMatch + lstrlen(pfr-&gt;lpstrReplaceWith); <br>ft.chrg.cpMost = -1;// search through end of the text <br>cszReplaced++; <br>goto next; <br>} <br> <br>done: <br>if(pfr-&gt;Flags &amp; FR_REPLACEALL) <br>{ <br>SetCursor(hcur); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_HIDESELECTION, fFalse, fFalse); <br>} <br>} <br> <br> <br>VOID UpdateFormatBar(REDOC * predoc) <br>{ <br>CHARFORMAT cf; <br>PARAFORMAT pf; <br> <br>cf.cbSize = sizeof(CHARFORMAT); <br>pf.cbSize = sizeof(PARAFORMAT); <br> <br>SendMessage(predoc-&gt;hwndRE, EM_GETCHARFORMAT, TRUE, (LPARAM) &amp;cf); <br>SendMessage(predoc-&gt;hwndFormatBar, EM_SETCHARFORMAT, 0, (LPARAM) &amp;cf); <br>SendMessage(predoc-&gt;hwndRE, EM_GETPARAFORMAT, FALSE, (LPARAM) &amp;pf); <br>SendMessage(predoc-&gt;hwndFormatBar, EM_SETPARAFORMAT, 0, (LPARAM) &amp;pf); <br>} <br> <br> <br> <br>LOCAL VOID ShowMargins(REDOC *predoc) <br>{ <br>if(ToggleCheck(predoc, IDM_SHOWMARGINS)) <br>{ <br>RECT rc; <br> <br>GetClientRect(predoc-&gt;hwndParent, &amp;rc); <br>ResizeRedoc(predoc, rc); <br>} <br>else <br>{ <br>SendMessage(predoc-&gt;hwndRE, EM_SETRECT, 0, 0); <br>} <br>} <br> <br> <br># ifdef DEBUG <br> <br>LOCAL VOID SetLimit(REDOC *predoc) <br>{ <br>LONG cchLimit = 32767; <br> <br>if(ToggleCheck(predoc, IDM_BIGLIMIT)) <br>cchLimit = 1024 * (LONG) 1024 - 1; <br> <br>SendMessage(predoc-&gt;hwndRE, EM_EXLIMITTEXT, 0, cchLimit); <br>} <br> <br> <br>static TCHAR szText[] = "Once upon a time there was an edit control.  " <br>"This was a happy edit control until some mean evil tester " <br>"(who shall remain nameless) came along and started beating on " <br>"the poor little helpless edit control.  The edit control bravely " <br>"faced it's unprovoked attacker, but an edit control can only take " <br>"so much.  One day when it was being ferociously tortured it thought " <br>"to itself \"What have I ever done to this poor homely creature to " <br>"deserve this type of punishment?\".  It stirred up it's self esteem " <br>"and stood up and said to the nasty creature \"I am an edit control, " <br>"hear me roar!  I deserve to be treated with dignity and respect!\".  " <br>"The evil little tester was taken aback by the edit control's sudden " <br>"show of courage, but being the spawn of hell, he dismissed the edit " <br>"control's declaration and continued his ghastly attacks.  The edit " <br>"control decided that nothing would ever reform this hideous beast " <br>"imparting terror upon it so he decided to do something about it.  " <br>"The next day when the heathen was preparing to nuke the edit control " <br>"the edit control jumped out at the beast and ripped it's heart out.  " <br>"The tester stood shocked for a millisecond and then dropped over dead.  " <br>"The end.\r\n\r\n"; <br> <br>LOCAL VOID FillerUp(REDOC *predoc) <br>{ <br>const LONG cch = lstrlen(szText); <br>LONG cchAdded; <br>LONG cchText; <br>DWORD dwTicks; <br> <br>SetWindowText(predoc-&gt;hwndRE, TEXT("")); <br>cchText = 0; <br> <br>(void) GetAsyncKeyState(VK_ESCAPE);// reset key state <br>dwTicks = GetTickCount(); <br>do <br>{ <br>LONG cchT; <br> <br>SendMessage(predoc-&gt;hwndRE, EM_REPLACESEL, 0, (LPARAM) (LPSTR) szText); <br>cchT = SendMessage(predoc-&gt;hwndRE, WM_GETTEXTLENGTH, 0, 0); <br>cchAdded = cchT - cchText; <br>if(cchText % 8192 &gt; cchT % 8192) <br>{ <br>const DWORD dwT = GetTickCount(); <br> <br>TraceTag(tagGeneral, "%ld characters, %ld ticks", cchT, dwT - dwTicks); <br>dwTicks = dwT; <br>} <br>cchText = cchT; <br>if(GetAsyncKeyState(VK_ESCAPE) &amp; 0x8001) <br>{ <br>TraceTag(tagGeneral, "stopping for escape"); <br>break; <br>} <br>} while(cchAdded &gt; 0 &amp;&amp; !fErrSpace); <br> <br>TraceTag(tagGeneral, "Stopped at %ld character", cchText); <br>} <br> <br>#endif// DEBUG <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
