<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMDLG32.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6334"></a>COMDLG32.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//PROGRAM:Comdlg32.c <br>// <br>//PURPOSE:Demonstrates how to manipulate the file open common dialog. <br>// <br>//PLATFORMS:Windows 95 <br>// <br>//FUNCTIONS: <br>//WinMain() - calls initialization function, processes message loop <br>//InitApplication() - Initializes window data nd registers window <br>//InitInstance() -saves instance handle and creates main window <br>//MainWindProc() Processes messages <br>//About() - Process menssages for "About" dialog box <br>//      OpenTheFile() - Processes the File Open common dialog box <br>//      ComDlg32DlgProc() - Hook procedure for GetOpenFileName() common dialog <br>//TestNotify() - Processes the WM_NOTIFY function for ComDlg32DlgProc <br>//ProcessCDError() - uses CommonDialogExtendedError() to output useful error  <br>//      messages <br>// <br>//SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>#include &lt;windows.h&gt;    // includes basic windows functionality <br>#include &lt;commdlg.h&gt;    // includes common dialog functionality <br>#include &lt;dlgs.h&gt;       // includes common dialog template defines <br>#include &lt;cderr.h&gt;      // includes the common dialog error codes <br>#include "COMDLG32.h"   // includes application-specific information <br> <br>const char szmsgSHAREVIOLATION[] = SHAREVISTRING;  // string for sharing violation <br>const char szmsgFILEOK[]         = FILEOKSTRING;   // string for OK button <br>const char szCommdlgHelp[]       = HELPMSGSTRING;  // string for Help button <br> <br>UINT cdmsgShareViolation = 0;  // identifier from RegisterWindowMessage <br>UINT cdmsgFileOK         = 0;  // identifier from RegisterWindowMessage <br>UINT cdmsgHelp           = 0;  // identifier from RegisterWindowMessage <br> <br>typedef struct _MYDATA <br>{ <br>char szTest1[80];// a test buffer containing the file selected <br>char szTest2[80];       // a test buffer containing the file path <br>} MYDATA, FAR * LPMYDATA; <br> <br>HINSTANCE g_hInst;// the current instance <br>MYDATA sMyData;// an instance of a MYDATA <br>  <br>// <br>//  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>// <br>//  PURPOSE: Entry point for the application. <br>// <br>//  COMMENTS: <br>// <br>//This function initializes the application and processes the <br>//message loop. <br>// <br>int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, int nCmdShow ) <br>{ <br> <br>    MSG msg;                          <br> <br>    if (!InitApplication(hInstance)) <br>            return (FALSE);               <br> <br>    // Create the main window. <br>    if (!InitInstance(hInstance, nCmdShow)) <br>        return (FALSE); <br> <br>    // Acquire and dispatch messages until a WM_QUIT message is received. <br>    while (GetMessage(&amp;msg,NULL,0,0)) <br>        { <br>            TranslateMessage(&amp;msg);    // Translates virtual key codes. <br>            DispatchMessage(&amp;msg);     // Dispatches message to window. <br>        } <br>    return (msg.wParam);           // Returns the value from PostQuitMessage. <br> <br>} <br> <br>// <br>//  FUNCTION: InitApplication(HANDLE) <br>// <br>//  PURPOSE: Initializes window data and registers window class  <br>// <br>//  COMMENTS: <br>// <br>//       In this function, we initialize a window class by filling out a data <br>//       structure of type WNDCLASS and calling the Windows RegisterClass() <br>//       function. <br>// <br>BOOL InitApplication(HANDLE hInstance)        <br>{ <br>    WNDCLASS  wc; <br> <br>    // Register the window class for my window.                                                           */ <br>    wc.style = 0;                       // Class style. <br>    wc.lpfnWndProc = (WNDPROC)MainWndProc; // Window procedure for this class. <br>    wc.cbClsExtra = 0;                  // No per-class extra data. <br>    wc.cbWndExtra = 0;                  // No per-window extra data. <br>    wc.hInstance = hInstance;           // Application that owns the class. <br>    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject(WHITE_BRUSH);  <br>    wc.lpszMenuName =  "Comdlg32Menu";   // Name of menu resource in .RC file.  <br>    wc.lpszClassName = "Comdlg32WClass"; // Name used in call to CreateWindow. <br> <br>    return (RegisterClass(&amp;wc)); <br>} <br> <br>// <br>//   FUNCTION: InitInstance(HANDLE, int) <br>// <br>//   PURPOSE: Saves instance handle and creates main window  <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>BOOL InitInstance( HANDLE hInstance, int nCmdShow)            <br>{ <br>    HWND            hWnd;               <br> <br>// Save off the handle to the current instance. <br>    g_hInst = hInstance; <br> <br>    // Create a main window for this application instance.  <br>    hWnd = CreateWindow( <br>        "Comdlg32WClass", <br>        "Common Dialog Sample Application", <br>        WS_OVERLAPPEDWINDOW,            // Window style. <br>        CW_USEDEFAULT,                  // Default horizontal position. <br>        CW_USEDEFAULT,                  // Default vertical position. <br>        CW_USEDEFAULT,                  // Default width. <br>        CW_USEDEFAULT,                  // Default height. <br>        NULL,                           // Overlapped windows have no parent. <br>        NULL,                           // Use the window class menu. <br>        g_hInst,                        // This instance owns this window. <br>        NULL                            // Pointer not needed. <br>    ); <br> <br>    // If window could not be created, return "failure". <br>    if (!hWnd) <br>        return (FALSE); <br> <br>    // Register the window messages to receive. <br>    cdmsgShareViolation = RegisterWindowMessage(szmsgSHAREVIOLATION); <br>    cdmsgFileOK         = RegisterWindowMessage(szmsgFILEOK); <br>    cdmsgHelp           = RegisterWindowMessage(szCommdlgHelp); <br> <br>    // Make the window visible; update its client area; and return "success". <br>    ShowWindow(hWnd, nCmdShow);   <br>    UpdateWindow(hWnd);           <br>    return (TRUE);                <br> <br>} <br> <br>// <br>//  FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  MESSAGES: <br>// <br>//WM_CREATE - initialize window and create the MLE <br>//WM_COMMAND - process the application menu <br>//WM_SIZE - size the MLE in the main window <br>//WM_DESTROY - post a quit message and return <br>// <br>// <br>LONG APIENTRY MainWndProc( HWND hWnd, UINT message, UINT wParam, LONG lParam) <br>{ <br>static HWND hwndEdit; <br>    CHAR lpszHello[] = "Choose File Open from the Options menu for a demo."; <br> <br>    switch (message) { <br> <br>        case WM_CREATE: <br>// Create an MLE for the file contents. <br>hwndEdit = CreateWindow( <br>                "EDIT",      <br>NULL,        <br>                WS_CHILD | WS_VISIBLE | WS_VSCROLL | <br>                    ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL, <br>                0, 0, 0, 0,  <br>                hWnd,        <br>                (HMENU) ID_EDITCHILD,  <br>                (HINSTANCE) GetWindowLong(hWnd, GWL_HINSTANCE), <br>                NULL);                <br> <br>            // Update the MLE.  <br>            SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM) lpszHello); <br>            return 0; <br>  <br>        case WM_SIZE: <br>            // Make the edit control the size of the window's client area.  <br>            MoveWindow(hwndEdit, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);           <br>            return 0; <br> <br>        case WM_COMMAND:           // message: command from application menu  <br>            switch( LOWORD( wParam )) <br>            { <br>                case IDM_FILEOPEN: <br>// Call the FileOpen common dialog to open the file. <br>                    OpenTheFile( hWnd, hwndEdit ); <br>                    break; <br> <br>                case IDM_EXIT: <br>                    PostQuitMessage(0); <br>                    break; <br> <br>                case IDM_ABOUT: <br>                    DialogBox(g_hInst, <br>                        MAKEINTRESOURCE(IDD_ABOUT), <br>                        hWnd,            <br>                        (DLGPROC)About); <br>                    break; <br> <br>                default: <br>                    return (DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>            } <br>            break; <br> <br>        case WM_DESTROY:                  // message: window being destroyed <br>            PostQuitMessage(0); <br>            break; <br> <br> <br>        default: <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return (0); <br>} <br> <br> <br>// <br>//   FUNCTION: OpenTheFile(HWND hwnd, HWND hwndEdit) <br>// <br>//   PURPOSE: Invokes common dialog function to open a file and opens it. <br>// <br>//   COMMENTS: <br>// <br>//This function initializes the OPENFILENAME structure and calls <br>//            the GetOpenFileName() common dialog function.   <br>// <br>//    RETURN VALUES: <br>//        TRUE - The file was opened successfully and read into the buffer. <br>//        FALSE - No files were opened. <br>// <br>// <br>BOOL OpenTheFile( HWND hWnd, HWND hWndEdit ) <br>{ <br>    HANDLE hFile; <br>    DWORD dwBytesRead; <br>DWORD dwFileSize; <br>OPENFILENAME OpenFileName; <br>TCHAR         szFile[MAX_PATH]      = "\0"; <br>char *lpBufPtr; <br> <br>    strcpy( szFile, ""); <br> <br> <br>// Fill in the OPENFILENAME structure to support a template and hook. <br>OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner         = hWnd; <br>    OpenFileName.hInstance         = g_hInst; <br>    OpenFileName.lpstrFilter       = NULL; <br>    OpenFileName.lpstrCustomFilter = NULL; <br>    OpenFileName.nMaxCustFilter    = 0; <br>    OpenFileName.nFilterIndex      = 0; <br>    OpenFileName.lpstrFile         = szFile; <br>    OpenFileName.nMaxFile          = sizeof(szFile); <br>    OpenFileName.lpstrFileTitle    = NULL; <br>    OpenFileName.nMaxFileTitle     = 0; <br>    OpenFileName.lpstrInitialDir   = NULL; <br>    OpenFileName.lpstrTitle        = "Open a File"; <br>    OpenFileName.nFileOffset       = 0; <br>    OpenFileName.nFileExtension    = 0; <br>    OpenFileName.lpstrDefExt       = NULL; <br>    OpenFileName.lCustData         = (LPARAM)&amp;sMyData; <br>OpenFileName.lpfnHook    = ComDlg32DlgProc; <br>OpenFileName.lpTemplateName    = MAKEINTRESOURCE(IDD_COMDLG32); <br>    OpenFileName.Flags             = OFN_SHOWHELP | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE; <br> <br>// Call the common dialog function. <br>    if (GetOpenFileName(&amp;OpenFileName)) <br>    { <br>// Open the file. <br>if ((hFile = CreateFile((LPCTSTR)OpenFileName.lpstrFile, <br>GENERIC_READ, <br>FILE_SHARE_READ, <br>NULL, <br>OPEN_EXISTING, <br>FILE_ATTRIBUTE_NORMAL, <br>(HANDLE)NULL)) == (HANDLE)-1) <br>{ <br>    MessageBox( hWnd, "File open failed.", NULL, MB_OK ); <br>    return FALSE; <br>} <br> <br>// Get the size of the file. <br>dwFileSize = GetFileSize(hFile, NULL); <br>if (dwFileSize == 0xFFFFFFFF) <br>{ <br>    MessageBox( NULL, "GetFileSize failed!", NULL, MB_OK); <br>    return FALSE; <br>} <br> <br>// Allocate a buffer for the file to be read into. <br>lpBufPtr = (char *)GlobalAlloc( GMEM_FIXED, dwFileSize ); <br>if (lpBufPtr == NULL) <br>{ <br>    MessageBox( NULL, "GlobalAlloc failed!", NULL, MB_OK); <br>    CloseHandle( hFile ); <br>    return FALSE; <br>} <br> <br>// Read it's contents into a buffer. <br>ReadFile(hFile,(LPVOID)lpBufPtr, dwFileSize, &amp;dwBytesRead, NULL); <br> <br>if (dwBytesRead == 0) <br>{ <br>    MessageBox( hWnd, "Zero bytes read.", NULL, MB_OK ); <br>    return FALSE; <br>} <br> <br>        // Update the MLE with the file contents. <br>        SendMessage(hWndEdit, WM_SETTEXT, 0, (LPARAM) lpBufPtr); <br> <br>// Close the file. <br>CloseHandle(hFile); <br> <br>return TRUE; <br>    } <br>    else <br>   { <br>ProcessCDError(CommDlgExtendedError(), hWnd ); <br>return FALSE; <br>    } <br> <br>} <br> <br>// <br>//   FUNCTION: TestNotify( HWND hDlg, LPOFNOTIFY pofn) <br>// <br>//  PURPOSE:  Processes the WM_NOTIFY message notifications that is sent <br>//    to the hook dialog procedure for the File Open common dialog. <br>// <br>// <br>BOOL NEAR PASCAL TestNotify(HWND hDlg, LPOFNOTIFY pofn) <br>{ <br>switch (pofn-&gt;hdr.code) <br>{ <br>// The selection has changed.  <br>case CDN_SELCHANGE: <br>{ <br>char szFile[MAX_PATH]; <br> <br>// Get the file specification from the common dialog. <br>if (CommDlg_OpenSave_GetSpec(GetParent(hDlg), <br>szFile, sizeof(szFile)) &lt;= sizeof(szFile)) <br>{ <br>// Set the dialog item to reflect this. <br>SetDlgItemText(hDlg, IDE_SELECTED, szFile); <br>} <br> <br>// Get the path of the selected file. <br>if (CommDlg_OpenSave_GetFilePath(GetParent(hDlg), <br>szFile, sizeof(szFile)) &lt;= sizeof(szFile)) <br>{ <br>// Display this path in the appropriate box. <br>SetDlgItemText(hDlg, IDE_PATH, szFile); <br>} <br>} <br>break; <br> <br>// A new folder has been opened. <br>case CDN_FOLDERCHANGE: <br>{ <br>char szFile[MAX_PATH]; <br> <br>if (CommDlg_OpenSave_GetFolderPath(GetParent(hDlg), <br>szFile, sizeof(szFile)) &lt;= sizeof(szFile)) <br>{ <br>// Display this new path in the appropriate box. <br>SetDlgItemText(hDlg, IDE_SELECTED, szFile); <br>} <br>} <br>break; <br> <br>// The "Help" pushbutton has been pressed. <br>case CDN_HELP: <br>MessageBox(hDlg, "Got the Help button notify.", "ComDlg32 Test", MB_OK); <br>break; <br> <br>// The 'OK' pushbutton has been pressed. <br>case CDN_FILEOK: <br>// Update the appropriate box. <br>SetDlgItemText(hDlg,IDE_SELECTED, pofn-&gt;lpOFN-&gt;lpstrFile); <br>SetWindowLong(hDlg, DWL_MSGRESULT, 1L); <br>break; <br> <br>// Received a sharing violation. <br>case CDN_SHAREVIOLATION: <br>// Update the appropriate box. <br>SetDlgItemText(hDlg, IDE_SELECTED, pofn-&gt;pszFile); <br>MessageBox(hDlg, "Got a sharing violation notify.", "ComDlg32 Test", MB_OK); <br>break; <br>} <br> <br>return(TRUE); <br>} <br> <br>// <br>//   FUNCTION: ComDlg32DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>// <br>//  PURPOSE:  Processes messages for the File Open common dialog box. <br>// <br>//    MESSAGES: <br>// <br>//WM_INITDIALOG - save pointer to the OPENFILENAME structure in User data <br>//WM_DESTROY - get the text entered and fill in the MyData structure <br>//WM_NOTIFY - pass this message onto the TestNotify function <br>//default - check for a sharing violation or the OK button and <br>//    display a message box. <br>// <br>// <br>BOOL CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>// Save off the long pointer to the OPENFILENAME structure. <br>SetWindowLong(hDlg, DWL_USER, lParam); <br>break; <br> <br>case WM_DESTROY: <br>{ <br>LPOPENFILENAME lpOFN = (LPOPENFILENAME)GetWindowLong(hDlg, DWL_USER); <br>LPMYDATA psMyData = (LPMYDATA)lpOFN-&gt;lCustData; <br> <br>GetDlgItemText(hDlg, IDE_PATH, psMyData-&gt;szTest1, sizeof(psMyData-&gt;szTest1)); <br>GetDlgItemText(hDlg, IDE_SELECTED, psMyData-&gt;szTest2, sizeof(psMyData-&gt;szTest2)); <br>} <br>break; <br> <br>case WM_NOTIFY: <br>TestNotify(hDlg, (LPOFNOTIFY)lParam); <br> <br>default: <br>if (uMsg == cdmsgFileOK) <br>{ <br>SetDlgItemText(hDlg, IDE_SELECTED, ((LPOPENFILENAME)lParam)-&gt;lpstrFile); <br>if (MessageBox(hDlg, "Got the OK button message.\n\nShould I open it?", "ComDlg32 Test", MB_YESNO) <br>== IDNO) <br>{ <br>SetWindowLong(hDlg, DWL_MSGRESULT, 1L); <br>} <br>break; <br>} <br>else if (uMsg == cdmsgShareViolation) <br>{ <br>SetDlgItemText(hDlg, IDE_SELECTED, (LPSTR)lParam); <br>MessageBox(hDlg, "Got a sharing violation message.", "ComDlg32 Test", MB_OK); <br>break; <br>} <br>return FALSE; <br>} <br>return TRUE; <br>} <br> <br>// <br>//  FUNCTION: About(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for "About" dialog box <br>// <br>//  MESSAGES: <br>// <br>//WM_INITDIALOG - initialize dialog box <br>//WM_COMMAND    - Input received <br>// <br>// <br>BOOL APIENTRY About( HWND hDlg, UINT message, UINT wParam, LONG lParam) <br>{ <br>    switch (message) <br>    { <br>        case WM_INITDIALOG:                 <br>            return (TRUE); <br> <br>        case WM_COMMAND:                       <br>            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)  <br>            {         <br>                EndDialog(hDlg, TRUE);         <br>                return TRUE; <br>            } <br>            break; <br>    } <br>    return FALSE;                            <br> <br>} <br> <br>// <br>//  FUNCTION: ProcessCDError(DWORD)  <br>// <br>//  PURPOSE: Processes errors from the common dialog functions. <br>// <br>//  COMMENTS: <br>// <br>//        This function is called whenever a common dialog function <br>//        fails.  The CommonDialogExtendedError() value is passed to <br>//        the function which maps the error value to a string table. <br>//        The string is loaded and displayed for the user.  <br>// <br>// <br>void ProcessCDError(DWORD dwErrorCode, HWND hWnd) <br>{ <br>   WORD  wStringID; <br>   TCHAR  buf[MAX_PATH]; <br> <br>   switch(dwErrorCode) <br>      { <br> case CDERR_DIALOGFAILURE:   wStringID=IDS_DIALOGFAILURE;   break; <br> case CDERR_STRUCTSIZE:      wStringID=IDS_STRUCTSIZE;      break; <br> case CDERR_INITIALIZATION:  wStringID=IDS_INITIALIZATION;  break; <br> case CDERR_NOTEMPLATE:      wStringID=IDS_NOTEMPLATE;      break; <br> case CDERR_NOHINSTANCE:     wStringID=IDS_NOHINSTANCE;     break; <br> case CDERR_LOADSTRFAILURE:  wStringID=IDS_LOADSTRFAILURE;  break; <br> case CDERR_FINDRESFAILURE:  wStringID=IDS_FINDRESFAILURE;  break; <br> case CDERR_LOADRESFAILURE:  wStringID=IDS_LOADRESFAILURE;  break; <br> case CDERR_LOCKRESFAILURE:  wStringID=IDS_LOCKRESFAILURE;  break; <br> case CDERR_MEMALLOCFAILURE: wStringID=IDS_MEMALLOCFAILURE; break; <br> case CDERR_MEMLOCKFAILURE:  wStringID=IDS_MEMLOCKFAILURE;  break; <br> case CDERR_NOHOOK:          wStringID=IDS_NOHOOK;          break; <br> case PDERR_SETUPFAILURE:    wStringID=IDS_SETUPFAILURE;    break; <br> case PDERR_PARSEFAILURE:    wStringID=IDS_PARSEFAILURE;    break; <br> case PDERR_RETDEFFAILURE:   wStringID=IDS_RETDEFFAILURE;   break; <br> case PDERR_LOADDRVFAILURE:  wStringID=IDS_LOADDRVFAILURE;  break; <br> case PDERR_GETDEVMODEFAIL:  wStringID=IDS_GETDEVMODEFAIL;  break; <br> case PDERR_INITFAILURE:     wStringID=IDS_INITFAILURE;     break; <br> case PDERR_NODEVICES:       wStringID=IDS_NODEVICES;       break; <br> case PDERR_NODEFAULTPRN:    wStringID=IDS_NODEFAULTPRN;    break; <br> case PDERR_DNDMMISMATCH:    wStringID=IDS_DNDMMISMATCH;    break; <br> case PDERR_CREATEICFAILURE: wStringID=IDS_CREATEICFAILURE; break; <br> case PDERR_PRINTERNOTFOUND: wStringID=IDS_PRINTERNOTFOUND; break; <br> case CFERR_NOFONTS:         wStringID=IDS_NOFONTS;         break; <br> case FNERR_SUBCLASSFAILURE: wStringID=IDS_SUBCLASSFAILURE; break; <br> case FNERR_INVALIDFILENAME: wStringID=IDS_INVALIDFILENAME; break; <br> case FNERR_BUFFERTOOSMALL:  wStringID=IDS_BUFFERTOOSMALL;  break; <br> <br> case 0:   //User may have hit CANCEL or we got a *very* random error <br>    return; <br> <br> default: <br>    wStringID=IDS_UNKNOWNERROR; <br>      } <br> <br>   LoadString(NULL, wStringID, buf, sizeof(buf)); <br>   MessageBox(hWnd, buf, NULL, MB_OK); <br>   return; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
