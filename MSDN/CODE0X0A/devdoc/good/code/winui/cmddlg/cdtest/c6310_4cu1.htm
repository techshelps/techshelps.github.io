<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6319"></a>FONT.C</h2>
<pre><code>/************************************************************************ <br> <br>  File: font.c <br> <br>  Purpose: <br> <br>    Contains all functions pertinent to CDTEST's Font dialog. <br> <br>  Functions: <br> <br>     DoFontDlg()          -- Creates CDTEST's font dialog. <br> <br>     FontProc()           -- Callback for CDTEST's font dialog. <br> <br>     InitFontStruct()     -- Fills a CHOOSEFONT structure with some defaults. <br> <br>     FillFontDlg()        -- Fills CDTEST's font dialog with the contents <br>                             of a CHOOSEFONT structure. <br> <br>     GetFontDlg()         -- Retrieves the contents of CDTEST's font dialog <br>                             and fills a CHOOSEFONT structure with them. <br> <br>     GetHdc()             -- Creates and returns an HDC <br> <br>     LogFontProc()        -- Callback function for the logfont dlg. <br> <br>     InitLogFontStruct()  -- Fills a LOGFONT structure with some defaults. <br> <br>     FillLogFontDlg()     -- Fills the LOGFONT dlg with the values in <br>                             a LOGFONT structure. <br> <br>     GetLogFontDlg()      -- Retrieves the user's edits in the LogFont dlg <br>                             and puts them in a LOGFONT structure. <br> <br>     FontHookProc()       -- Callback function for CHOOSEFONT-&gt;lpfnHook <br> <br>     GetFontDlgHandle()   -- Creates a handle to the custom template and <br>                             returns a handle to it. <br> <br>     EnumFontsProc()      -- Callback function for EnumFontFamilies() <br> <br>     FillFontsBox()       -- Fills CDTEST's font list box with requested fonts <br> <br>     ResetCheckBoxes()    -- handles the font choices check box manipulations <br> <br>     HandleFontCheckBox() -- Handles the WM_COMMAND messages from the font <br>                             choices check boxes. <br> <br>     DoChooseFontStuff()  -- Calls the ChooseFont() function. <br> <br>     FontThreadProc1()    -- Starting address for the first thread. <br> <br>     FontThreadProc2()    -- Starting address for the second thread. <br> <br>     MultiThreadFontDlg() -- Creates two threads which each create a <br>                             ChooseFont() dialog. <br> <br>     FontEnableButtons()  -- Enables or disables CDTEST's font dialog buttons. <br>                             Necessary for multithreading part of this app. <br> <br>************************************************************************/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;winnls.h&gt; <br>#include "cdtest.h" <br>#include "font.h" <br>#include "logfont.h" <br> <br> <br> <br>/* some definitions that will help us tell the difference between <br>   screen and printer fonts */ <br> <br>#define FONT_TYPE_WYSIWYG 1 <br>BOOL bScreen ; <br> <br> <br> <br>/* function prototypes and general variables */ <br> <br>void InitFontStruct(HWND, LPCHOOSEFONT) ; <br>void FillFontDlg(HWND, LPCHOOSEFONT) ; <br>void GetFontDlg(HWND, LPCHOOSEFONT) ; <br>HDC  GetHdc(HWND, int) ; <br>void InitLogFontStruct(HWND, LPLOGFONT) ; <br>void FillLogFontDlg(HWND, LPLOGFONT) ; <br>void GetLogFontDlg(HWND, LPLOGFONT) ; <br>BOOL APIENTRY LogFontProc(HWND, UINT, UINT, LONG) ; <br>UINT APIENTRY FontHookProc(HWND, UINT, UINT, LONG) ; <br>int  CALLBACK EnumFontsProc(LPLOGFONT, LPTEXTMETRIC, DWORD, LONG) ; <br>void FillFontsBox(HWND, DWORD) ; <br>void ResetCheckBoxes(HWND) ; <br>void HandleFontCheckBox(HWND, int) ; <br>void DoChooseFontStuff(HWND, LPCHOOSEFONT) ; <br> <br> <br> <br>/* Global variables and some external variables and functions */ <br> <br>DWORD dwFontFlag ; <br>PRINTDLG pfd ; <br>BOOL bLogFontParam ; <br>LOGFONT lfWM_CF_LF ;                 //for the WM_CHOOSEFONT_GETLOGFONT message <br>extern UINT uMode ; <br>extern LONG MyAtol(LPTSTR, BOOL, LPBOOL) ; <br>HANDLE hResFont, hDialogFont ; <br>HANDLE GetFontDlgHandle(void) ; <br>CHOOSEFONT cf ; <br>LOGFONT lf ; <br>HDC hdc ; <br>TCHAR szFaceName[50] ; <br>TCHAR szFontTemplate[50] ; <br>TCHAR szFontStyle[50] ; <br>#define HDCSCREEN 1 <br>#define HDCPRINTER 2 <br>#define HDCNULL 3 <br>#define HDCINVALID 4 <br>INT nHdcType ; <br> <br> <br> <br>/* Multithreading stuff */ <br> <br>HANDLE hFontThread1 ; <br>HANDLE hFontThread2 ; <br>DWORD  dwFontThreadID1 ; <br>DWORD  dwFontThreadID2 ; <br>DWORD  dwFontThreadParm1 ; <br>DWORD  dwFontThreadParm2 ; <br>DWORD  FontThreadProc1(LPDWORD) ; <br>DWORD  FontThreadProc2(LPDWORD) ; <br>HANDLE hwndMainFont ; <br>int    nOpenFontDialogCount ; <br>CHOOSEFONT cfThread1 ; <br>CHOOSEFONT cfThread2 ; <br>void MultiThreadFontDlg(void) ; <br>void EnableFontButtons(HWND, BOOL) ; <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: DoFontDlg(HWND) <br> <br>  Purpose: <br> <br>    To create the CDTEST's font dialog <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br>void DoFontDialog(HWND hwnd) <br>{ <br> <br> <br>  DialogBox(hInst, MAKEINTRESOURCE(ID_FONTDIALOG), <br>            hwnd, FontProc) ; <br> <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: FontProc(HWND, UINT, UINT, LONG) <br> <br>  Purpose: <br> <br>    Callback function for CDTEST's font dialog. <br> <br>  Returns: TRUE or FALSE depending on the situation. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br> <br>BOOL APIENTRY FontProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  BOOL b ; <br>  TCHAR szNum[30] ; <br> <br>  switch (msg) <br>  { <br>    case WM_INITDIALOG: <br> <br>        InitLogFontStruct(hwnd, &amp;lf) ;   //fill (struct lf) so the choosefont <br>        InitFontStruct(hwnd, &amp;cf) ;      //struct can use it <br>        FillFontDlg(hwnd, &amp;cf) ; <br> <br>        CheckRadioButton(hwnd, ID_HDCSCREEN, ID_HDCPRINTER, ID_HDCSCREEN) ; <br>        nHdcType = HDCSCREEN ; <br> <br>        dwFontFlag = cf.Flags ; <br> <br>        FillFontsBox(hwnd, dwFontFlag) ; <br> <br>        ResetCheckBoxes(hwnd) ; <br> <br>        *(&amp;cfThread1) = *(&amp;cfThread2) = *(&amp;cf) ; <br> <br>        hwndMainFont = hwnd ; <br>        nOpenFontDialogCount = 0 ; <br> <br>        SetFocus(GetDlgItem(hwnd, ID_STRUCTSIZEF)) ; <br> <br>        break ; <br> <br> <br>    case UMSG_DECREMENTDLGCOUNT:  // user defined message.  This is send by <br>                                  // the functions that are executing when <br>                                  // a new thread is created.  When these <br>                                  // Thread functions end, they should send <br>                                  // this message. <br> <br>      nOpenFontDialogCount-- ; <br> <br>      if (nOpenFontDialogCount == 0) <br>        EnableFontButtons(hwnd, TRUE) ; <br> <br>      break ; <br> <br> <br>    case WM_CF_LF: <br> <br>       /* If this message comes in, we know that the user clicked the <br>          button that tells the ChooseFont() dialog to tell the parent <br>          to send the WM_CHOOSEFONT_GETLOGFONT message.  So what we will <br>          do is send the message and then show the user what was in the <br>          logfont by calling creating the Logfont dialog box */ <br> <br> <br>       SendMessage((HWND) lParam, WM_CHOOSEFONT_GETLOGFONT, <br>                   0, (LPARAM) &amp;lfWM_CF_LF) ; <br> <br>       bLogFontParam = TRUE ; //tells us if we are doing normal logfont <br>                              //processing or answering the WM_CF_LF message. <br> <br>       DialogBoxParam(hInst, MAKEINTRESOURCE(ID_LOGFONTDIALOG), <br>                      (HWND) lParam, LogFontProc, (LPARAM) &amp;lf) ; <br> <br>       bLogFontParam = FALSE ; <br> <br>       break ; <br> <br> <br>    case WM_COMMAND: <br>    { <br>        switch (LOWORD(wParam)) <br>        { <br>          case IDOK: <br>            DoChooseFontStuff(hwnd, &amp;cf) ;  //create the dialog. <br>            break ; <br> <br>          case IDCANCEL: <br>            EndDialog(hwnd, FALSE) ; <br>            break ; <br> <br>          case ID_RESETFONT: <br> <br>            InitLogFontStruct(hwnd, &amp;lf) ;  //reset all the structures. <br>            InitFontStruct(hwnd, &amp;cf) ; <br>            FillFontDlg(hwnd, &amp;cf) ;        //refill the dialog. <br> <br>            CheckRadioButton(hwnd, ID_HDCSCREEN, ID_HDCPRINTER, ID_HDCSCREEN) ; <br>            nHdcType = HDCSCREEN ; <br> <br>            SendDlgItemMessage(hwnd, ID_NULLSTRUCTFONT, BM_SETCHECK, (WPARAM) 0, (LPARAM)0) ; <br>            SendDlgItemMessage(hwnd, ID_PRELOADEDFONT,  BM_SETCHECK, (WPARAM) 0, (LPARAM)0) ; <br> <br>            dwFontFlag = cf.Flags ; <br>            FillFontsBox(hwnd, dwFontFlag) ; <br>            ResetCheckBoxes(hwnd) ; <br> <br>            SetFocus(GetDlgItem(hwnd, ID_STRUCTSIZEF)) ; <br> <br>            break ; <br> <br> <br>          case ID_HDCSCREEN: <br>            nHdcType = HDCSCREEN ; <br>            break ; <br> <br>          case ID_HDCPRINTER: <br>            nHdcType = HDCPRINTER ; <br>            break ; <br> <br>          case ID_HDCNULL: <br>            nHdcType = HDCNULL ; <br>            break ; <br> <br>          case ID_HDCINVALID: <br>            nHdcType = HDCINVALID ; <br>            break ; <br> <br>          case ID_EDITLOGFONT: <br> <br>            /* Get the address of the logfont and then show the user what <br>               is in it with the Logfont dialog box */ <br> <br>            GetDlgItemText(hwnd, ID_LOGFONTF, szNum, 30) ; <br>            cf.lpLogFont = (LPLOGFONT) MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>            DialogBox(hInst, MAKEINTRESOURCE(ID_LOGFONTDIALOG), <br>                      hwnd, LogFontProc) ; <br>            break ; <br> <br> <br>          case F_TTONLY: <br>          case F_ANSIONLY: <br>          case F_PRINTERFONTS: <br>          case F_SCREENFONTS: <br>          case F_FIXEDPITCHONLY: <br>          case F_NOOEMFONTS: <br>          case F_NOVECTORFONTS: <br>          case F_SCALABLEONLY: <br>          case F_WYSIWYG: <br>            HandleFontCheckBox(hwnd, LOWORD(wParam)) ; <br>            break ; <br> <br> <br>          case ID_MULTITHREADFONT: <br> <br>            /* Set the dialog count to 2, disable the buttons in CDTEST's font <br>               dialog so the user can't do anything until last dialog has <br>               been terminated */ <br> <br>            nOpenFontDialogCount = 2 ; <br> <br>            EnableFontButtons(hwndMainFont, FALSE) ; <br> <br>            /* And then do the multithreading */ <br> <br>            MultiThreadFontDlg() ; <br> <br>            break ; <br> <br> <br>          default: break ; <br>        } <br>    } <br> <br>    default: <br> <br>      /* <br>         If the help button is pressed in the ChooseFont() <br>         dialog, it will send a message Registered with RegisterWindowMessage() <br>         to the parent window.  The message nHelpMessage was registered <br>         at application startup <br> <br>         It must be detected with an IF statement because the value <br>         returned by RegisterWindowMessage() is not a constant <br>      */ <br> <br>      if (msg == nHelpMessage) <br>        MessageBox(GetForegroundWindow(), TEXT("Hello from the help button"), <br>                   TEXT("Font Help Button"), MB_OK | MB_APPLMODAL) ; <br>      break ; <br>  } <br> <br>  return FALSE ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: InitFontStruct(HWND, LPCHOOSEFONT) <br> <br>  Purpose: <br> <br>    Fill the CHOOSEFONT structure passed as the second parameter with <br>    some default values. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br>void InitFontStruct(HWND hwnd, LPCHOOSEFONT pcf) <br>{ <br>  pcf-&gt;lStructSize = sizeof(CHOOSEFONT) ; <br>  pcf-&gt;hwndOwner = hwnd ; <br>  pcf-&gt;hDC = (HDC) 0 ; <br>  pcf-&gt;lpLogFont = &amp;lf ; <br>  pcf-&gt;iPointSize = 24 ; <br>  pcf-&gt;Flags = CF_EFFECTS | CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_SHOWHELP | CF_APPLY ; <br>  pcf-&gt;rgbColors = RGB(0, 255, 0) ; <br>  pcf-&gt;lCustData = 0L ; <br>  pcf-&gt;lpfnHook = FontHookProc ; <br> <br>  lstrcpy(szFontTemplate, TEXT("fonttemp")) ; <br>  pcf-&gt;lpTemplateName = szFontTemplate ; <br> <br>  pcf-&gt;hInstance = (HANDLE) hInst ; <br> <br>  lstrcpy(szFontStyle, TEXT("Bold")) ; <br>  pcf-&gt;lpszStyle = szFontStyle ; <br> <br>  pcf-&gt;nFontType = SCREEN_FONTTYPE ; <br> <br>  pcf-&gt;nSizeMin = 8 ; <br>  pcf-&gt;nSizeMax = 50 ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: FillFontDlg(HWND, LPCHOOSEFONT) <br> <br>  Purpose: <br> <br>    Fill CDTEST's font dialog with the values in the CHOOSEFONT structure <br>    passed via the second parameter. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br>void FillFontDlg(HWND hwnd, LPCHOOSEFONT pcf) <br>{ <br>  wsprintf(szTemp, szLongFilter, pcf-&gt;lStructSize) ; <br>  SetDlgItemText(hwnd, ID_STRUCTSIZEF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (DWORD) pcf-&gt;hwndOwner) ; <br>  SetDlgItemText(hwnd, ID_HWNDOWNERF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (DWORD) pcf-&gt;hDC) ; <br>  SetDlgItemText(hwnd, ID_HDCF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (DWORD) pcf-&gt;hDC) ; <br>  SetDlgItemText(hwnd, ID_HDCF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (DWORD) pcf-&gt;lpLogFont) ; <br>  SetDlgItemText(hwnd, ID_LOGFONTF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (DWORD) pcf-&gt;iPointSize) ; <br>  SetDlgItemText(hwnd, ID_POINTSIZEF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, pcf-&gt;Flags) ; <br>  SetDlgItemText(hwnd, ID_FLAGSF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, pcf-&gt;rgbColors) ; <br>  SetDlgItemText(hwnd, ID_RGBCOLORSF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, pcf-&gt;lCustData) ; <br>  SetDlgItemText(hwnd, ID_CUSTDATAF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (DWORD) pcf-&gt;lpfnHook) ; <br>  SetDlgItemText(hwnd, ID_HOOKF, szTemp) ; <br> <br>  SetDlgItemText(hwnd, ID_TEMPLATEF, pcf-&gt;lpTemplateName) ; <br> <br>  wsprintf(szTemp, szLongFilter, (DWORD) pcf-&gt;hInstance) ; <br>  SetDlgItemText(hwnd, ID_HINSTANCEF, szTemp) ; <br> <br>  SetDlgItemText(hwnd, ID_STYLEF, pcf-&gt;lpszStyle) ; <br> <br>  wsprintf(szTemp, szLongFilter, (int) pcf-&gt;nFontType) ; <br>  SetDlgItemText(hwnd, ID_FONTTYPEF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (int) pcf-&gt;nSizeMin) ; <br>  SetDlgItemText(hwnd, ID_SIZEMINF, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, (int) pcf-&gt;nSizeMax) ; <br>  SetDlgItemText(hwnd, ID_SIZEMAXF, szTemp) ; <br> <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: GetFontDlg(HWND, LPCHOOSEFONT) <br> <br>  Purpose: <br> <br>    Retrieve the users edits from CDTEST's font dialog and put them <br>    in the CHOOSEFONT structure passed in as the second parameter <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br>void GetFontDlg(HWND hwnd, LPCHOOSEFONT pcf) <br>{ <br>  BOOL b ; <br>  TCHAR szNum[30] ; <br> <br>#define WSIZEFO 30 <br> <br>  GetDlgItemText(hwnd, ID_STRUCTSIZEF, szNum, WSIZEFO) ; <br>  pcf-&gt;lStructSize = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_HWNDOWNERF, szNum, WSIZEFO) ; <br>  pcf-&gt;hwndOwner = (HWND) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LOGFONTF, szNum, WSIZEFO) ; <br>  pcf-&gt;lpLogFont = (LPLOGFONT) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_POINTSIZEF, szNum, WSIZEFO) ; <br>  pcf-&gt;iPointSize = (int) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_FLAGSF, szNum, WSIZEFO) ; <br>  pcf-&gt;Flags = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_RGBCOLORSF, szNum, WSIZEFO) ; <br>  pcf-&gt;rgbColors = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_CUSTDATAF, szNum, WSIZEFO) ; <br>  pcf-&gt;lCustData = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_HOOKF, szNum, WSIZEFO) ; <br>  pcf-&gt;lpfnHook = (LPCFHOOKPROC) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_TEMPLATEF, szFontTemplate, 50) ; <br> <br>  GetDlgItemText(hwnd, ID_HINSTANCEF, szNum, WSIZEFO) ; <br>  pcf-&gt;hInstance = (HANDLE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_STYLEF, szFontStyle, 50) ; <br> <br>  GetDlgItemText(hwnd, ID_FONTTYPEF, szNum, WSIZEFO) ; <br>  pcf-&gt;nFontType = (int) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_SIZEMINF, szNum, WSIZEFO) ; <br>  pcf-&gt;nSizeMin = (int) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_SIZEMAXF, szNum, WSIZEFO) ; <br>  pcf-&gt;nSizeMax = (int) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: GetHdc(HWND, int) <br> <br>  Purpose: <br> <br>    Creates and returns an HDC of the type specified. <br> <br> <br>  Returns: The HDC that it creates. <br> <br> <br>  Comments: <br> <br>    The NULL and INVALID HDCs are only useful to test if the common dialogs <br>    handle an HDC that is not useful, but this function is also necessary <br>    in that the HDC must be a printer HDC if ChooseFont() is called <br>    with the CF_PRINTERFONTS flag bit set. <br> <br>    To tell ChooseFont() to list only printer fonts: <br> <br>    1.  Set the HDC in CDTEST's font dialog to "Printer" <br> <br>    2.  Set the "Flags" edit box CF_PRINTERFONTS <br> <br> <br>************************************************************************/ <br> <br> <br> <br>HDC GetHdc(HWND hwnd, int nType) <br>{ <br>  switch (nType) <br>  { <br>    case HDCSCREEN: <br>        return GetDC(hwnd) ; <br>        break ; <br> <br>    case HDCNULL: <br>        return (HDC) 0 ; <br>        break ; <br> <br>    case HDCINVALID: <br>        return (HDC) 999 ; <br>        break ; <br> <br>    case HDCPRINTER: <br> <br>        /* To get the HDC of the current printer, fill out a PRINTDLG <br>           structure, and set it's flags to (PD_RETURNDC | PD_RETURNDEFAULT). <br>           This will tell PrintDlg() to create you an HDC but not show <br>           the Print dialog box. */ <br> <br>        pfd.lStructSize = sizeof(PRINTDLG) ; <br>        pfd.hwndOwner = hwnd ; <br>        pfd.hDevMode = (HANDLE) 0 ; <br>        pfd.hDevNames = (HANDLE) 0 ; <br>        pfd.Flags = PD_RETURNDC | PD_RETURNDEFAULT ;   //just get default printer <br>        pfd.nFromPage = 0 ; <br>        pfd.nToPage = 0 ; <br>        pfd.nMinPage = 0 ; <br>        pfd.nMaxPage = 0 ; <br>        pfd.nCopies = 0 ; <br>        pfd.hInstance = (HANDLE) hInst ; <br> <br>        if (PrintDlg(&amp;pfd) == 0) <br>            MessageBox(hwnd, TEXT("Error: Could not create a printer DC!"), <br>                       (LPTSTR) NULL, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL) ; <br>        else <br>           return pfd.hDC ; <br> <br>        break ; <br> <br>    default: <br>        break ; <br>  } <br>  return (HDC) 0 ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: LogFontProc(HWND, int) <br> <br>  Purpose: <br> <br>    The callback proc for the LogFont dialog box <br> <br> <br>  Returns: BOOL -- depending on the situation. <br> <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br> <br>BOOL APIENTRY LogFontProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_INITDIALOG: <br>        FillLogFontDlg(hwnd, cf.lpLogFont) ;  //start off with the one that <br>                                              //is returned from ChooseFont() <br>        break ; <br> <br>    case WM_COMMAND: <br>        switch(LOWORD(wParam)) <br>        { <br>          case IDOK: <br> <br>            GetLogFontDlg(hwnd, &amp;lf) ; <br> <br>            cf.lpLogFont = &amp;lf ; <br> <br>            EndDialog(hwnd, TRUE) ; <br> <br>            break ; <br> <br> <br> <br>          case ID_RESETLF: <br> <br>            SetFocus(GetDlgItem(hwnd, ID_LFHEIGHT)) ; <br> <br>            InitLogFontStruct(hwnd, &amp;lf) ; <br> <br>            FillLogFontDlg(hwnd, &amp;lf) ; <br> <br>            break ; <br> <br> <br>          case IDCANCEL: <br> <br>            EndDialog(hwnd, FALSE) ; <br> <br>            break ; <br> <br> <br>          default: <br>            break ; <br>        } <br> <br>    default: break ; <br>  } <br> <br> <br>  return FALSE ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: InitLogFontStruct(HWND, LPLOGFONT) <br> <br>  Purpose: <br> <br>    Fills the LOGFONT structure passed in as the second parameter with <br>    some default values. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>void InitLogFontStruct(HWND hwnd, LPLOGFONT plf) <br>{ <br>  plf-&gt;lfHeight = 24 ; <br>  plf-&gt;lfWidth  = 20 ; <br>  plf-&gt;lfEscapement = 0 ; <br>  plf-&gt;lfOrientation = 10 ; <br>  plf-&gt;lfWeight = 400 ; <br>  plf-&gt;lfItalic = FALSE ; <br>  plf-&gt;lfUnderline = FALSE ; <br>  plf-&gt;lfStrikeOut = FALSE ; <br>  plf-&gt;lfCharSet = ANSI_CHARSET ; <br>  plf-&gt;lfOutPrecision = OUT_DEFAULT_PRECIS ; <br>  plf-&gt;lfClipPrecision = CLIP_DEFAULT_PRECIS ; <br>  plf-&gt;lfQuality = DEFAULT_QUALITY ; <br>  plf-&gt;lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE ; <br> <br>  szFaceName[0] = (TCHAR) 0 ; <br>  lstrcpy(plf-&gt;lfFaceName, szFaceName) ; <br>} <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: FillLogFontDlg(HWND, LPLOGFONT) <br> <br>  Purpose: <br> <br>    Fills CDTEST's logfont dialog with the values in the logfont that <br>    is passed in as the second parameter. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>void FillLogFontDlg(HWND hwnd, LPLOGFONT plf) <br>{ <br>  TCHAR szTemp[50] ; <br> <br>  LPLOGFONT pl = plf ; <br> <br>  if (bLogFontParam)    //Are creating this dialog in response to the <br>    pl = &amp;lfWM_CF_LF ;  //WM_CHOOSEFONT_GETLOGFONT message ? <br> <br>  if (!pl)              //Avert a ghastly exception error <br>    return ; <br> <br>  wsprintf(szTemp, szLongFilter, pl-&gt;lfHeight) ; <br>  SetDlgItemText(hwnd, ID_LFHEIGHT, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, pl-&gt;lfWidth) ; <br>  SetDlgItemText(hwnd, ID_LFWIDTH, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, pl-&gt;lfEscapement) ; <br>  SetDlgItemText(hwnd, ID_LFESCAPEMENT, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, pl-&gt;lfOrientation) ; <br>  SetDlgItemText(hwnd, ID_LFORIENTATION, szTemp) ; <br> <br>  wsprintf(szTemp, szLongFilter, pl-&gt;lfWeight) ; <br>  SetDlgItemText(hwnd, ID_LFWEIGHT, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfItalic) ; <br>  SetDlgItemText(hwnd, ID_LFITALIC, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfUnderline) ; <br>  SetDlgItemText(hwnd, ID_LFUNDERLINE, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfStrikeOut) ; <br>  SetDlgItemText(hwnd, ID_LFSTRIKEOUT, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfCharSet) ; <br>  SetDlgItemText(hwnd, ID_LFCHARSET, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfOutPrecision) ; <br>  SetDlgItemText(hwnd, ID_LFOUTP, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfClipPrecision) ; <br>  SetDlgItemText(hwnd, ID_LFCLIPP, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfQuality) ; <br>  SetDlgItemText(hwnd, ID_LFQUALITY, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, pl-&gt;lfPitchAndFamily) ; <br>  SetDlgItemText(hwnd, ID_LFPITCHANDFAM, szTemp) ; <br> <br>  SetDlgItemText(hwnd, ID_LFFACENAME, (LPTSTR) pl-&gt;lfFaceName) ; <br>} <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: GetLogFontDlg(HWND, LPLOGFONT) <br> <br>  Purpose: <br> <br>    Retrieves the users edits in CDTEST's Logfont dialog and puts them <br>    into the LOGFONT struct that is passed as the second parameter. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>void GetLogFontDlg(HWND hwnd, LPLOGFONT plf) <br>{ <br>  BOOL b ; <br>  TCHAR szNum[30] ; <br> <br>  if (bLogFontParam)  //if we are just viewing the logfont because we sent a <br>    return ;          //WM_CHOOSEFONT_GETLOGFONT message, don't change the Logfont Struct <br>                      //that ChooseFont() gives us... <br> <br>  #define LFSIZE 30 <br> <br>  GetDlgItemText(hwnd, ID_LFHEIGHT, szNum, LFSIZE) ; <br>  plf-&gt;lfHeight = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFWIDTH, szNum, LFSIZE) ; <br>  plf-&gt;lfWidth = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFESCAPEMENT, szNum, LFSIZE) ; <br>  plf-&gt;lfEscapement = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFORIENTATION, szNum, LFSIZE) ; <br>  plf-&gt;lfOrientation = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFWEIGHT, szNum, LFSIZE) ; <br>  plf-&gt;lfWeight = MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFITALIC, szNum, LFSIZE) ; <br>  plf-&gt;lfItalic = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFUNDERLINE, szNum, LFSIZE) ; <br>  plf-&gt;lfUnderline = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFSTRIKEOUT, szNum, LFSIZE) ; <br>  plf-&gt;lfStrikeOut = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFCHARSET, szNum, LFSIZE) ; <br>  plf-&gt;lfCharSet = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFOUTP, szNum, LFSIZE) ; <br>  plf-&gt;lfOutPrecision = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFCLIPP, szNum, LFSIZE) ; <br>  plf-&gt;lfClipPrecision = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFQUALITY, szNum, LFSIZE) ; <br>  plf-&gt;lfQuality = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFPITCHANDFAM, szNum, LFSIZE) ; <br>  plf-&gt;lfPitchAndFamily = (BYTE) MyAtol(szNum, uMode == IDM_HEXMODE, &amp;b) ; <br> <br>  GetDlgItemText(hwnd, ID_LFFACENAME, (LPTSTR) plf-&gt;lfFaceName, 32) ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: FontHookProc(HWND, UINT, UINT, LONG) <br> <br>  Purpose: The callback function that acts as the hook proc for <br>           the ChooseFont() dialog. <br> <br> <br>  Returns: TRUE to discard the message.  FALSE to send the message on <br>           to the normal dialog processing done by the ChooseFont() <br>           function. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>UINT APIENTRY FontHookProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  LPCHOOSEFONT pCf ; <br>  TCHAR szMsg[50] ; <br> <br>  switch(msg) <br>  { <br>    case WM_INITDIALOG: <br> <br>      pCf = (LPCHOOSEFONT) lParam ; <br> <br>      if (pCf-&gt;lCustData != 0L) <br>      { <br>        wsprintf(szMsg, TEXT("CHOOSEFONT-&gt;lCustData is: %ld"), pCf-&gt;lCustData) ; <br>        MessageBox(hwnd, szMsg, TEXT("lCustData Sent!"), MB_OK) ; <br>      } <br> <br>      SetWindowText(hwnd, TEXT("Font Hook Proc Dialog")) ; <br> <br>      break ; <br> <br>    case WM_COMMAND: <br> <br>        /* NOTE: This button will only be available if the user creates the <br>           ChooseFont() dialog with the CF_ENABLETEMPLATE or CF_ENABLETEMPLATEHANDLE <br>           flag. <br> <br>           This button will only work if the ChooseFont() dialog is created <br>           with the CF_ENABLEHOOK flag.  So, to get full functionality from <br>           this button: <br> <br>           1.  Enter (CF_ENABLEHOOK | CF_ENABLETEMPLATE | CF_SCREENFONTS) <br>               in the "Flags" edit box of CDTEST'S Font dialog. <br> <br>           2.  Click OK <br>        */ <br> <br> <br> <br>        /* The parent will send the WM_CHOOSEFONT_GETLOGFONT message and <br>           display it's findings in a LogFont dialog if it gets this message */ <br> <br>        if (LOWORD(wParam) == ID_SEND_WM_CF_LF_MSG) <br>          SendMessage(GetParent(hwnd), WM_CF_LF, 0, (LPARAM) hwnd) ; <br> <br>        break ; <br> <br> <br>    default: <br>      break ; <br>  } <br> <br>  return FALSE ;   //send msg to the common dialog code <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: GetFontDlgHandle(void) <br> <br>  Purpose:  Finds and loads the custom template resource and returns a <br>            handle to it. <br> <br> <br>  Returns: A handle to the custom template resource. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>HANDLE GetFontDlgHandle(void) <br>{ <br> <br>  hResFont = FindResource(hInst, TEXT("fonttemp"), RT_DIALOG) ; <br> <br>  hDialogFont = LoadResource(hInst, hResFont) ; <br> <br> <br>  return hDialogFont ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: EnumFontsProc(LPLOGFONT, LPTEXTMETRIC, DWORD, LONG) <br> <br>  Purpose: Acts as a callback function for the EnumFontFamilies() <br>           function. <br> <br>  Returns: 0 if the font enumeration should stop.  1 to ask for the <br>           next font. <br> <br>  Comments: <br> <br>    EnumFontFamilies will find the fonts on the system and call this <br>    function each time it finds a font.  Pointers to the LOGFONT and <br>    TEXTMETRIC structures the describe the font are passed as the first <br>    and second arguments, so we can determine if the fonts we get <br>    meet the specs we want.  If they do, we can add them to the font <br>    list box in CDTEST's Font dialog. <br> <br>    NOTE: <br> <br>    None of this affects the performance of ChooseFont().  This serves <br>    only to illustrate how ChooseFont() finds the fonts you request based <br>    on the flags you pass to the ChooseFont() function. <br> <br>    The fonts found with this function should be the same as the ones <br>    found by ChooseFont() for any flag combination. <br> <br> <br>************************************************************************/ <br> <br> <br>int CALLBACK EnumFontsProc(LPLOGFONT lplf, LPTEXTMETRIC lptm, <br>                           DWORD dwStyle, LONG lParam) <br>{ <br>  UINT i ; <br> <br>  /* check to see if the font is already there right off the bat <br>     and just continue the enumeration if it is...        */ <br> <br> <br>  i = SendDlgItemMessage((HWND) lParam, ID_FONTLIST, LB_FINDSTRINGEXACT, (WPARAM) 0, <br>                         (LONG) (LPTSTR) lplf-&gt;lfFaceName) ; <br> <br>  if (i != LB_ERR) <br>  { <br>    if (bScreen)     //if we are adding it for the first time <br>      return 1 ; <br> <br>    //else, we are adding printer fonts, so if we find one that is already there </code></pre>
<p>
</p>
<pre><code>//it must be available for both the printer and the screen... <br> <br>    else <br>    { <br>      SendDlgItemMessage((HWND) lParam, ID_FONTLIST, LB_SETITEMDATA, i, <br>                          FONT_TYPE_WYSIWYG) ; <br>      return 1 ; <br>    } <br>  } <br> <br> <br>  //Get rid of any fonts that we don't want... <br> <br>  if ((dwFontFlag &amp; CF_TTONLY) &amp;&amp; (!(dwStyle &amp; TRUETYPE_FONTTYPE))) <br>    return 1 ; <br> <br>  if ((dwFontFlag &amp; CF_SCALABLEONLY) &amp;&amp; (dwStyle &amp; RASTER_FONTTYPE)) <br>    return 1 ; <br> <br>  if ((dwFontFlag &amp; CF_ANSIONLY) &amp;&amp; (lplf-&gt;lfCharSet != ANSI_CHARSET)) <br>    return 1 ; <br> <br>  if ((dwFontFlag &amp; CF_FIXEDPITCHONLY) &amp;&amp; (lplf-&gt;lfPitchAndFamily &amp; VARIABLE_PITCH)) <br>    return 1 ; <br> <br>  if ((dwFontFlag &amp; CF_NOVECTORFONTS) &amp;&amp; (lplf-&gt;lfCharSet == OEM_CHARSET)) <br>    return 1 ; <br> <br> <br>  //if there is a font to be added, add it. <br> <br>  if (*(lplf-&gt;lfFaceName)) <br>    SendDlgItemMessage((HWND) lParam, ID_FONTLIST, LB_ADDSTRING, <br>                     (WPARAM) 0, (LONG) (LPTSTR) lplf-&gt;lfFaceName) ; <br> <br>  return 1 ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: FillFontsBox(HWND, DWORD) <br> <br>  Purpose: Enumerates all fonts on the system and sends the ones that <br>           meet the criteria of the dwFlags parameter (CF_SCREENFONTS, <br>           CF_SCALABLEONLY, etc). <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br>void FillFontsBox(HWND hwnd, DWORD dwFlags) <br>{ <br>  HDC hdc ; <br>  HWND hwndControl ; <br>  DWORD dwData ; <br>  int nItemCount ; <br> <br> <br>  /* Empty the list box, and turn of the redraw because we may need <br>     to remove some fonts after they are added if the user calls this <br>     function with the CF_WYSIWYG flag bit set. */ <br> <br>  SendDlgItemMessage(hwnd, ID_FONTLIST, LB_RESETCONTENT, (WPARAM)0, (LPARAM) 0) ; <br> <br>  hwndControl = GetDlgItem(hwnd, ID_FONTLIST) ; <br> <br>  SendMessage(hwndControl, WM_SETREDRAW, FALSE, 0L) ; <br> <br> <br>  /* Now call EnumFontFamilies() for each type of HDC requested */ <br> <br>  if (dwFlags &amp; CF_SCREENFONTS) <br>  { <br>    bScreen = TRUE ; <br>    hdc = GetHdc(hwnd, HDCSCREEN) ; <br>    EnumFontFamilies(hdc, (LPTSTR) NULL, (FONTENUMPROC) EnumFontsProc, (LONG) hwnd) ; <br>    ReleaseDC(hwnd, hdc) ; <br>  } <br> <br>  if (dwFlags &amp; CF_PRINTERFONTS) <br>  { <br>    bScreen = FALSE ; <br>    hdc = GetHdc(hwnd, HDCPRINTER) ; <br>    EnumFontFamilies(hdc, (LPTSTR) NULL, (FONTENUMPROC) EnumFontsProc, (LONG) hwnd) ; <br>    ReleaseDC(hwnd, hdc) ; <br>  } <br> <br> <br>  /* Special case:  If the CF_WYSIWYG flag is used, we have to enumerate <br>     the fonts in both HDCs and then remove all the ones that are not <br>     both printer fonts and screen fonts. */ <br> <br>  if (dwFontFlag &amp; CF_WYSIWYG) <br>  { <br>    nItemCount = SendDlgItemMessage(hwnd, ID_FONTLIST, LB_GETCOUNT, 0, 0L) ; <br> <br>    nItemCount-- ;   //the list is zero based <br> <br>    while (nItemCount &gt;= 0) <br>    { <br>      dwData = SendDlgItemMessage(hwnd, ID_FONTLIST, LB_GETITEMDATA, nItemCount, 0L) ; <br> <br>      if (dwData != FONT_TYPE_WYSIWYG) <br>      { <br>        SendDlgItemMessage(hwnd, ID_FONTLIST, LB_DELETESTRING, nItemCount, 0L) ; <br>      } <br> <br>      nItemCount-- ; <br>    } <br>  } <br> <br> <br>  /* Now redraw the font list */ <br> <br>  SendMessage(hwndControl, WM_SETREDRAW, TRUE, 0L) ; <br>  InvalidateRect(hwndControl, NULL, FALSE) ; <br> <br>  return ; <br>} <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: ResetCheckBoxes(HWND) <br> <br>  Purpose: Checks the checkboxes that control what fonts are listed in <br>           CDTEST's font list box. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br>void ResetCheckBoxes(HWND hwnd) <br>{ <br> <br>  SendDlgItemMessage(hwnd, F_TTONLY,          BM_SETCHECK, dwFontFlag &amp; CF_TTONLY         ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_ANSIONLY,        BM_SETCHECK, dwFontFlag &amp; CF_ANSIONLY       ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_SCREENFONTS,     BM_SETCHECK, dwFontFlag &amp; CF_SCREENFONTS    ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_PRINTERFONTS,    BM_SETCHECK, dwFontFlag &amp; CF_PRINTERFONTS   ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_NOOEMFONTS,      BM_SETCHECK, dwFontFlag &amp; CF_NOOEMFONTS     ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_NOVECTORFONTS,   BM_SETCHECK, dwFontFlag &amp; CF_NOVECTORFONTS  ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_SCALABLEONLY,    BM_SETCHECK, dwFontFlag &amp; CF_SCALABLEONLY   ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_WYSIWYG,         BM_SETCHECK, dwFontFlag &amp; CF_WYSIWYG        ? 1 : 0, (LPARAM)0) ; <br>  SendDlgItemMessage(hwnd, F_FIXEDPITCHONLY,  BM_SETCHECK, dwFontFlag &amp; CF_FIXEDPITCHONLY ? 1 : 0, (LPARAM)0) ; <br> <br>} <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: HandleFontCheckBox(HWND) <br> <br>  Purpose: If the user clicks one of the fonts in the CDTEST's list of <br>           valid font types, this function will check the correct boxes <br>           and set the correct values in the flag which keeps track of <br>           which fonts are to be enumerated and added to CDTEST's font <br>           list box. <br> <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    CF_NOOEMFONTS and CF_NOVECTORFONTS are identical. <br> <br> <br>************************************************************************/ <br> <br>void HandleFontCheckBox(HWND hwnd, int nID) <br>{ <br>  DWORD dwTemp ; <br> <br>  dwTemp = dwFontFlag ; <br> <br>  switch (nID) <br>  { <br>    case F_TTONLY: <br> <br>      /* TTONLY is a special case.  If we only want Truetype fonts, <br>         turn off irrelevant flags */ <br> <br>      if (!(dwFontFlag &amp; CF_TTONLY)) //if we're turning this flag on... <br>      { <br>        dwFontFlag = 0L ;  //turn everyone off but the following: <br> <br>        dwFontFlag |= CF_TTONLY ; <br> <br>        if (dwTemp &amp; CF_ANSIONLY) <br>          dwFontFlag |= CF_ANSIONLY ; <br> <br>        if (dwTemp &amp; CF_FIXEDPITCHONLY) <br>          dwFontFlag |= CF_FIXEDPITCHONLY ; <br> <br>        if (dwTemp &amp; CF_SCREENFONTS) <br>          dwFontFlag |= CF_SCREENFONTS ; <br> <br>        if (dwTemp &amp; CF_PRINTERFONTS) <br>          dwFontFlag |= CF_PRINTERFONTS ; <br>      } <br>      else <br>      { <br>        dwFontFlag ^= CF_TTONLY ; <br>      } <br> <br> <br>      break ; <br> <br>    case F_ANSIONLY: <br>      dwFontFlag ^= CF_ANSIONLY ;        //otherwise toggle the bit. <br>      dwFontFlag &amp;= ~CF_WYSIWYG ; <br> <br>      break ; <br> <br>    case F_PRINTERFONTS: <br>      dwFontFlag ^= CF_PRINTERFONTS ; <br> <br>      break ; <br> <br>    case F_SCREENFONTS: <br>      dwFontFlag ^= CF_SCREENFONTS ; <br> <br>      break ; <br> <br>    case F_FIXEDPITCHONLY: <br>      dwFontFlag ^= CF_FIXEDPITCHONLY ; <br> <br>      break ; <br> <br>    case F_NOOEMFONTS: <br>      dwFontFlag ^= CF_NOOEMFONTS ; <br> <br>      break ; <br> <br>    case F_NOVECTORFONTS: <br>      dwFontFlag ^= CF_NOVECTORFONTS ; <br> <br>      break ; <br> <br>    case F_SCALABLEONLY: <br>      dwFontFlag ^= CF_SCALABLEONLY ; <br> <br>      break ; <br> <br>    case F_WYSIWYG:                        //We want fonts for both the <br>                                           //screen and the printer... <br>      dwFontFlag ^= CF_WYSIWYG ; <br> <br>      if (dwFontFlag &amp; CF_WYSIWYG) <br>        dwFontFlag |= (CF_SCREENFONTS | CF_PRINTERFONTS | CF_SCALABLEONLY) ; <br> <br>      break ; <br> <br>    default: break ; <br>  } <br> <br>  ResetCheckBoxes(hwnd) ; <br>  FillFontsBox(hwnd, dwFontFlag) ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: DoChooseFontStuff(HWND, LPCHOOSEFONT) <br> <br>  Purpose: <br> <br>    Calls the ChooseFont() function. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br> <br>void DoChooseFontStuff(HWND hwnd, LPCHOOSEFONT pcf) <br>{ <br>  BOOL bRet = FALSE ; <br> <br>  if (IsDlgButtonChecked(hwnd, ID_PRELOADEDFONT) == 1) <br>  { <br>    pcf-&gt;hInstance = GetFontDlgHandle() ; <br>    wsprintf(szTemp, szLongFilter, pcf-&gt;hInstance) ; <br>    SetDlgItemText(hwnd, ID_HINSTANCEF, szTemp) ; <br>  } <br> <br>  pcf-&gt;hDC = GetHdc(hwnd, nHdcType) ; <br> <br>  wsprintf(szTemp, szLongFilter, pcf-&gt;hDC) ; <br>  SetDlgItemText(hwnd, ID_HDCF, szTemp) ; <br> <br> <br>  GetFontDlg(hwnd, pcf) ; <br> <br> <br>  if (IsDlgButtonChecked(hwnd, ID_NULLSTRUCTFONT) == 1) <br>    bRet = ChooseFont((LPCHOOSEFONT)NULL) ; <br>  else <br>    bRet = ChooseFont(pcf) ; <br> <br>  wsprintf(szTemp, szLongFilter, CommDlgExtendedError()) ; <br>  SetDlgItemText(hwnd, ID_ERRORF, szTemp) ; <br> <br>  if (pcf-&gt;hDC) <br>  { <br>    ReleaseDC(hwnd, pcf-&gt;hDC) ;   //free the HDC that we used if we called <br>    pcf-&gt;hDC = (HDC) 0 ;          //the function with a valid HDC. <br>  } <br> <br>  if (hDialogFont) <br>  { <br>    FreeResource(hDialogFont) ; <br>    hDialogFont = (HANDLE) 0 ; <br>    hResFont = (HANDLE) 0 ; <br>  } <br> <br>  wsprintf(szTemp, szShortFilter, bRet) ;     //fill results into the Font dlg <br>  SetDlgItemText(hwnd, ID_RETURNF, szTemp) ; <br> <br>  FillFontDlg(hwnd, pcf) ; <br>} <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: FontThreadProc1(LPDWORD) <br> <br>  Purpose: <br> <br>    Acts as the starting address for thread 1 <br> <br>  Returns: Any DWORD value. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br>DWORD FontThreadProc1(LPDWORD pdw) <br>{ <br>  DoChooseFontStuff(hwndMainFont, &amp;cfThread1) ; <br> <br>  PostMessage(hwndMainFont, UMSG_DECREMENTDLGCOUNT, 0, 0L ) ; <br> <br>  return 0L ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: FontThreadProc2(LPDWORD) <br> <br>  Purpose: <br> <br>    Acts as the starting address for thread 2 <br> <br>  Returns: Any DWORD value. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br> <br>DWORD FontThreadProc2(LPDWORD pdw) <br>{ <br>  DoChooseFontStuff(hwndMainFont, &amp;cfThread2) ; <br> <br>  PostMessage(hwndMainFont, UMSG_DECREMENTDLGCOUNT, 0, 0L ) ; <br> <br>  return 0L ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: MultiThreadFontDlg(void) <br> <br>  Purpose: <br> <br>    Create the two threads that will in turn create two ChooseFont() <br>    dialogs. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    Multithreading note: <br> <br>    This function will return before the common dialog functions return. <br>    Therefore, do not pass any parameters to this function that will be <br>    referenced by the common dialogs because as soon as this function <br>    ends those parameters will be gone. <br> <br>************************************************************************/ <br> <br>void MultiThreadFontDlg(void) <br>{ <br> <br>  dwFontThreadParm1 = dwFontThreadParm2 = 0L ; <br> <br>  if (!(hFontThread1 = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0, <br>                                     (LPTHREAD_START_ROUTINE) FontThreadProc1, <br>                                     &amp;dwFontThreadParm1, CREATE_SUSPENDED, &amp;dwFontThreadID1))) <br> <br>  { <br>    MessageBox(GetForegroundWindow(), TEXT("Error creating thread 1"), NULL, <br>               MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL) ; <br> <br>    nOpenFontDialogCount = 0 ; <br> <br>    EnableFontButtons(hwndMainFont, TRUE) ; <br> <br>    return ; <br>  } <br> <br> <br>  if (!(hFontThread2 = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0, <br>                                     (LPTHREAD_START_ROUTINE) FontThreadProc2, <br>                                     &amp;dwFontThreadParm2, CREATE_SUSPENDED, &amp;dwFontThreadID2))) <br>  { <br>    MessageBox(GetForegroundWindow(), TEXT("Error creating thread 2"), NULL, <br>               MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL) ; <br> <br>    nOpenFontDialogCount = 0 ; <br> <br>    EnableFontButtons(hwndMainFont, TRUE) ; <br> <br>    return ; <br>  } <br> <br>  ResumeThread(hFontThread1) ; <br>  ResumeThread(hFontThread2) ; <br> <br>  return ; <br>} <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: EnableFontButtons(HWND, BOOL) <br> <br>  Purpose: <br> <br>    Enables or disables CDTEST's font dialogs buttons based on the <br>    status of the second parameter. <br> <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    This is necessary when multithreading in the case of this application. <br> <br>************************************************************************/ <br> <br>void EnableFontButtons(HWND hwnd, BOOL bEnable) <br>{ <br>  EnableWindow(GetDlgItem(hwnd, IDOK), bEnable) ; <br>  EnableWindow(GetDlgItem(hwnd, IDCANCEL), bEnable) ; <br>  EnableWindow(GetDlgItem(hwnd, ID_RESETFONT), bEnable) ; <br>  EnableWindow(GetDlgItem(hwnd, ID_MULTITHREADFONT), bEnable) ; <br>  EnableWindow(GetDlgItem(hwnd, ID_EDITLOGFONT), bEnable) ; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
