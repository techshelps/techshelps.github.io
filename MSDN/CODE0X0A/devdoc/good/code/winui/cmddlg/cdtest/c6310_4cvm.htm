<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OPEN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6322"></a>OPEN.C</h2>
<pre><code>/************************************************************************ <br> <br>  File: open.c <br> <br>  Purpose: <br> <br>    This file contains the routines to control the CDTEST.EXE "Open" dialog <br>    box.  The "Open" dialog box allows the user to enter values into an <br>    OPENFILENAME structure and then create GetOpenFileName() dialog boxes <br>    on the fly. <br> <br>  Functions: <br> <br>    DoOpenDialog()                   -- starts off the main dialog for "open" <br> <br>    OpenFunc()                       -- Callback function for main dialog <br> <br>    InitOpenStruct()                 -- Fills initial OPENFILENAME structure. <br> <br>    FillOpenDlg()                    -- Fills the dialog with the values from <br>                                        the OPENFILENAME structure. <br> <br>    GetOpenDlg()                     -- Retrieves the users entries from the <br>                                        main dialog and puts them in the <br>                                        OPENFILENAME structure. <br> <br>    InitFilterString()               -- Creates filter string <br> <br>    InitCustFiltString()             -- Creates custom filter string <br> <br>    InterpretCustomFilterString()    -- Parses custom filter string returned <br>                                        from GetOpenFileName() <br> <br>    GetCorrectResourceHandle()       -- Loads custom templates from file <br>                                        as resource handles <br> <br>    OpenSaveHookProc()               -- The hook function that will be <br>                                        called if GetOpen/Save is called <br>                                        with the OFN_ENABLEHOOK flag set. <br> <br>    MultiThreadOpenSave()            -- Creates two Open/Save dialogs that <br>                                        the user can simultaneously access <br> <br>    OpenSaveThread1Proc()            -- The starting address of thread 1 <br> <br>    OpenSaveThread2Proc()            -- The starting address of thread 2 <br> <br>    DoOpenSaveStuff()                -- Does the actuall calling of <br>                                        GetOpen/SaveFileName() <br> <br>    OpenMultiThreadEnableButtons()   -- Enables and disables buttons in <br>                                        main dialog.  Needed when multi- <br>                                        threading. <br> <br>************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;winnls.h&gt; <br>#include "cdtest.h" <br>#include "open.h" <br>#include "save.h" <br>#include "dlgs.h"     //include file that contains all #defines for the <br>                      //commdlg dialog templates. <br> <br> <br>/* All functions defined in this file + 1 external function <br>   and one external variable */ <br> <br>extern UINT uMode ;                               //see cdtest.c <br>extern LONG MyAtol(LPTSTR, BOOL, LPBOOL) ; <br>void InterpretCustomFilterString(void) ; <br>HANDLE GetCorrectResourceHandle(void) ; <br>void DoOpenSaveStuff(LPOPENFILENAME) ; <br>UINT APIENTRY OpenSaveHookProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) ; <br>DWORD OpenSaveThread1Proc(LPDWORD) ; <br>DWORD OpenSaveThread2Proc(LPDWORD) ; <br>void MultiThreadOpenSave(void) ; <br>void OpenMultiThreadEnableButtons(BOOL, HWND) ; <br> <br> <br>/* All global variables defined in this file */ <br> <br>HWND hwndMainDialog ;   //global handle for open dialog. <br> <br>HANDLE hRes ;           //handles to the resource and dialog for <br>HANDLE hDialog ;        //ofn_enabletemplatehandle <br> <br>HBRUSH hBrushDlg ; <br>HBRUSH hBrushEdit ;     //brush handles for new colors done with hook proc <br>HBRUSH hBrushButton ; <br> <br>HANDLE hOpenSaveThread1, hOpenSaveThread2 ;   //variables for the <br>DWORD dwThreadID1, dwThreadID2 ;              //multithreading part <br>DWORD dwThreadParm1, dwThreadParm2 ; <br>OPENFILENAME ofnThread1, ofnThread2 ; <br>int nOpenDialogCount ; <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: DoOpenDialog(HWND) <br> <br>  Purpose: To create the GetOpenFileName() and GetSaveFileName() <br>           creation dialog. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    GetOpenFileName() and GetSaveFileName() are similiar enough so that <br>    the same dialog can be used to edit their creation structure elements, <br>    so a global variable "bDoOpenDlg" keeps track of which one to create <br>    when the user clicks the OK or Multithread buttons... <br> <br>************************************************************************/ <br> <br> <br>void DoOpenDialog(HWND hwnd) <br>{ <br> <br>  bDoOpenDlg = TRUE ; <br> <br> <br>  DialogBox(hInst, MAKEINTRESOURCE(ID_OPENDIALOG), hwnd, OpenFunc) ; <br> <br>} <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br> <br>  Function: OpenFunc(HWND, UINT, UINT, LONG) <br> <br>  Purpose: <br> <br>    This is the callback function for the dialog box containing the <br>    GetOpenFileName() and the GetSaveFileName() creation options. <br> <br>    This function will handle the messages for this dialog and create <br>    either a GetOpenFileName() dialog or a GetSaveFileName() dialog <br>    depending on the state of the bDoOpenDlg variable. <br> <br>  Returns: TRUE or FALSE depending on the situation. <br> <br>  Comments: <br> <br> <br>************************************************************************/ <br> <br> <br>BOOL APIENTRY OpenFunc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  switch (msg) <br>  { <br> <br>    case WM_INITDIALOG: <br> <br>      if (bDoOpenDlg) <br>        SetWindowText(hwnd, TEXT("GetOpenFileName()")) ; <br>      else <br>        SetWindowText(hwnd, TEXT("GetSaveFileName()")) ; <br> <br> <br>      /* initialize the OPENFILENAME structure members */ <br> <br>      InitOpenStruct(hwnd, &amp;ofn) ; <br> <br> <br>      /* Fill these values into the creation dialog */ <br> <br>      FillOpenDlg(hwnd, &amp;ofn) ; <br> <br> <br>      /* There are three separate OPENFILENAME structures.  One for <br>         the main Open/Save dialog and one for each multithreaded dialog. <br>         Set them equal to begin with */ <br> <br>      *(&amp;ofnThread1) = *(&amp;ofnThread2) = *(&amp;ofn) ; <br> <br>      hwndMainDialog = hwnd ; <br> <br>      SetFocus(GetDlgItem(hwnd, ID_STRUCTSIZEO)) ; <br> <br>      break ; <br> <br> <br> <br>    case UMSG_DECREMENTDLGCOUNT:  //user defined message indicating <br>                                  //the closure of a multithreaded dialog <br> <br>      /* When we are multithreading, there is nothing to prevent the <br>         user from interacting with the creation dialog once the first <br>         GetOpen(Save) file name dialog has returned.  So, in order <br>         to prevent the Multithread" button from being pressed again <br>         before the previous two multithreaded dialogs have been canceled, <br>         disable the controls until we get a message from each thread <br>         that the dialog has ended */ <br> <br> <br>      nOpenDialogCount-- ; <br> <br>      if (nOpenDialogCount == 0) <br>        OpenMultiThreadEnableButtons(TRUE, hwnd) ; <br> <br>      break ; <br> <br> <br>    case WM_COMMAND: <br>    { <br>      switch (LOWORD(wParam)) <br>      { <br> <br>        case IDOK: <br>          GetOpenDlg(hwnd, &amp;ofn) ;          //get the user's input <br>          DoOpenSaveStuff(&amp;ofn) ;           //do the dialog <br>          break ; <br> <br> <br>        case IDCANCEL: <br>          EndDialog(hwnd, FALSE) ; <br>          break ; <br> <br> <br>        case ID_RESETOPEN: <br> <br>          SendDlgItemMessage(hwnd, ID_FILTERO, CB_RESETCONTENT, <br>            (WPARAM) 0, (LPARAM) 0) ; <br> <br>          InitOpenStruct(hwnd, &amp;ofn) ; <br> <br>          FillOpenDlg(hwnd, &amp;ofn) ; <br> <br>          SendDlgItemMessage(hwnd, ID_NULLSTRUCTO, BM_SETCHECK, (WPARAM)0, (LPARAM)0) ; <br>          SendDlgItemMessage(hwnd, ID_USEHINSTO, BM_SETCHECK, (WPARAM)0, (LPARAM)0) ; <br> <br>          *(&amp;ofnThread1) = *(&amp;ofnThread2) = *(&amp;ofn) ; <br> <br>          SetFocus(GetDlgItem(hwnd, ID_STRUCTSIZEO)) ; <br> <br>          break ; <br> <br> <br>        case ID_ADD1O: <br> <br>          GetDlgItemText(hwnd, ID_FILTERO, szTemp, 100) ; <br> <br>          if (*szTemp) <br>          { <br>            SendDlgItemMessage(hwnd, ID_FILTERO, CB_ADDSTRING, (WPARAM) 0, <br>                              (LPARAM) (LPTSTR) szTemp) ; <br>            SetWindowText(GetDlgItem(hwnd, ID_FILTERO), TEXT("")) ; <br>          } <br>          break ; <br> <br> <br>        case ID_ADD2O: <br> <br>          GetDlgItemText(hwnd, ID_CUSTFILTO, szTemp, 100) ; <br> <br>          if (*szTemp) <br>          { <br>            SendDlgItemMessage(hwnd, ID_CUSTFILTO, CB_ADDSTRING, (WPARAM) 0, <br>                              (LPARAM) (LPTSTR) szTemp) ; <br>            SetWindowText(GetDlgItem(hwnd, ID_CUSTFILTO), TEXT("")) ; <br>          } <br>          break ; <br> <br> <br>        case ID_CLEAR1O: <br>          SendDlgItemMessage(hwnd, ID_FILTERO, CB_RESETCONTENT, <br>                             (WPARAM) 0, (LPARAM) 0) ; <br>          break ; <br> <br>        case ID_CLEAR2O: <br>          SendDlgItemMessage(hwnd, ID_CUSTFILTO, CB_RESETCONTENT, <br>                             (WPARAM) 0, (LPARAM) 0) ; <br>          break ; <br> <br>        case ID_MULTIOPEN: <br> <br>        /* First, disable the OK, Cancel, and MultiThread buttons */ <br> <br>          OpenMultiThreadEnableButtons(FALSE, hwnd) ; <br> <br> <br>        /* Then multithread the dialogs */ <br> <br>          nOpenDialogCount = 2 ; <br> <br>          MultiThreadOpenSave() ; <br> <br>          break ; <br> <br> <br>        default:   //end WM_COMMAND case <br>          break ; <br>      } <br>    } <br> <br>    default: <br> <br>      /* If the help button is pressed in the GetOpen/SaveFileName() <br>         dialogs, it will send a message Registered with RegisterWindowMessage() <br>         to the parent window.  The message nHelpMessage was registered <br>         at application startup */ <br> <br>      if (msg == nHelpMessage) <br>        MessageBox(GetForegroundWindow(), <br>                   TEXT("Hello from the help button"), <br>                   TEXT("Open Help Button"), MB_OK | MB_APPLMODAL) ; <br> <br>      break ; <br> <br>  } <br> <br>  return FALSE ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br> <br>  Function: InitOpenStruct(HWND, LPOPENFILENAME) <br> <br>  Purpose: <br> <br>    Initializes the OPENFILENAME structure.  The structure is referenced <br>    via a pointer passed in as the second parameter so that we can pass <br>    any of the three OPENFILENAME structures into this function and <br>    Initialize them. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    The szFilterInits and szCustFiltInits arrays are initialized to <br>    contain some default strings.  Eventually the strings in <br>    these arrays must be arranged one after the other with a null <br>    character between them and two null characters at the end: <br> <br>    "Text files\0*.txt\0All files\0*.*\0\0" <br> <br>************************************************************************/ <br> <br> <br>void InitOpenStruct(HWND hwnd, LPOPENFILENAME po) <br>{ <br>   int i = 0 ; <br>   szFileName[0] = 0 ; <br>   szFileTitle[0] = 0 ; <br> <br>   dwFlags = OFN_READONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_SHOWHELP  ; <br> <br>   if (bDoOpenDlg) <br>     lstrcpy(szDlgTitle, TEXT("Open Dialog Title")) ; <br>   else <br>     lstrcpy(szDlgTitle, TEXT("Save Dialog Title")) ; <br> <br>   lstrcpy(szDefExt, TEXT("rat")) ; <br>   lstrcpy(szInitialDir, TEXT("c:\\")) ; <br>   lstrcpy(szTempName, TEXT("opentemp1")) ; <br> <br>   lstrcpy(&amp;szFilterInits[0][0], TEXT("All Files (*.*)")) ; <br>   lstrcpy(&amp;szFilterInits[1][0], TEXT("*.*")) ; <br>   lstrcpy(&amp;szFilterInits[2][0], TEXT("Fat Files (*.fat)")) ; <br>   lstrcpy(&amp;szFilterInits[3][0], TEXT("*.fat")) ; <br>   szFilterInits[4][0] = (TCHAR) 0 ; <br> <br>   lstrcpy(&amp;szCustFiltInits[0][0], TEXT("Last Filter Used")) ; <br>   lstrcpy(&amp;szCustFiltInits[1][0], TEXT("*.lst")) ; <br>   szCustFiltInits[2][0] = (TCHAR) 0 ; <br> <br> <br>   /* <br> <br>      These two functions will create "strings" in the applications <br>      data area that are in the form <br> <br>      "Filter Description"\0 <br>      "Filter"\0 <br>      "Filter Description"\0 <br>      "Filter"\0 <br>      .. <br>      .. <br>      \0\0 <br> <br>      The filters must be in this form in order that the common dialogs <br>      interpret it correctly... <br>   */ <br> <br>   InitFilterString() ; <br> <br>   InitCustFilterString() ; <br> <br>   po-&gt;lStructSize          = sizeof(OPENFILENAME) ; <br>   po-&gt;hwndOwner            = hwnd ; <br>   po-&gt;hInstance            = hInst ; <br>   (LPTSTR) po-&gt;lpstrFilter = lpszFilterString ; <br>   po-&gt;lpstrCustomFilter    = lpszCustFilterString ; <br>   po-&gt;nMaxCustFilter       = MAXCUSTFILTER ; <br>   po-&gt;nFilterIndex         = 1L ; <br>   po-&gt;lpstrFile            = szFileName ; <br>   po-&gt;nMaxFile             = FILENAMESIZE ; <br>   po-&gt;lpstrFileTitle       = szFileTitle ; <br>   po-&gt;nMaxFileTitle        = FILETITLESIZE ; <br>   po-&gt;lpstrInitialDir      = szInitialDir ; <br>   (LPTSTR) po-&gt;lpstrTitle  = szDlgTitle ; <br>   po-&gt;Flags                = dwFlags ; <br>   po-&gt;nFileOffset          = 0 ; <br>   po-&gt;nFileExtension       = 0 ; <br>   (LPTSTR) po-&gt;lpstrDefExt = szDefExt; <br>   po-&gt;lCustData            = 0L ; <br>   po-&gt;lpfnHook             = OpenSaveHookProc ; <br>   (LPTSTR) po-&gt;lpTemplateName  = szTempName ; <br> <br>   return ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br> <br>  Function: FillOpenDlg(HWND, LPOPENFILENAME) <br> <br>  Purpose: <br> <br>    - This function will fill in the edit boxes that correspond to each <br>      of the fields in the OPENFILENAME structure.  The user can accept <br>      these values to create the common dialog or edit them. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>      The contents of the strings "szShortFilter" and "szLongFilter" <br>      determine how a WORD or a DWORD value is represented in the edit boxes <br> <br>************************************************************************/ <br> <br>void FillOpenDlg(HWND hwnd, LPOPENFILENAME po) <br>{ <br>   int i = 0 ; <br> <br>   wsprintf(szTemp, szShortFilter, (int) po-&gt;lStructSize) ; <br>   SetDlgItemText(hwnd, ID_STRUCTSIZEO, szTemp) ; <br> <br>   wsprintf(szTemp, szLongFilter, (LONG) po-&gt;hwndOwner) ; <br>   SetDlgItemText(hwnd, ID_HWNDOWNERO, szTemp) ; <br> <br>   wsprintf(szTemp, szLongFilter, (LONG) po-&gt;hInstance) ; <br>   SetDlgItemText(hwnd, ID_HINSTANCEO, szTemp) ; <br> <br> <br>   SendDlgItemMessage(hwnd, ID_FILTERO, CB_RESETCONTENT, <br>                      (WPARAM) 0, (LPARAM) 0) ; <br> <br>   while (szFilterInits[i][0] != (TCHAR) 0) <br>   { <br>      SendDlgItemMessage(hwnd, ID_FILTERO, CB_ADDSTRING, (WPARAM) 0, <br>                        (LPARAM) (LPTSTR) &amp;szFilterInits[i][0]) ; <br>      i++ ; <br>   } <br> <br>   SendDlgItemMessage(hwnd, ID_FILTERO, CB_SETCURSEL, <br>                     (WPARAM) 0, (LPARAM) 0 ) ; <br> <br> <br> <br>   SendDlgItemMessage(hwnd, ID_CUSTFILTO, CB_RESETCONTENT, <br>                      (WPARAM) 0, (LPARAM) 0) ; <br> <br>   for (i=0; i&lt;2; i++) <br>     SendDlgItemMessage(hwnd, ID_CUSTFILTO, CB_ADDSTRING, (WPARAM) 0, <br>                        (LPARAM) (LPTSTR) &amp;szCustFiltInits[i][0]) ; <br> <br>   SendDlgItemMessage(hwnd, ID_CUSTFILTO, CB_SETCURSEL, <br>                     (WPARAM) 0, (LPARAM) 0) ; <br> <br> <br>   wsprintf(szTemp, szShortFilter, (int) po-&gt;nMaxCustFilter) ; <br>   SetDlgItemText(hwnd, ID_MAXCUSTFILTO, szTemp) ; <br> <br>   wsprintf(szTemp, szShortFilter, (int) po-&gt;nFilterIndex) ; <br>   SetDlgItemText(hwnd, ID_FILTINDEXO, szTemp) ; <br> <br>   SetDlgItemText(hwnd, ID_SZFILEO, po-&gt;lpstrFile) ; <br> <br>   wsprintf(szTemp, szShortFilter, (int) po-&gt;nMaxFile) ; <br>   SetDlgItemText(hwnd, ID_MAXSZFILEO, szTemp) ; <br> <br>   SetDlgItemText(hwnd, ID_SZFILETITLEO, po-&gt;lpstrFileTitle) ; <br> <br>   wsprintf(szTemp, szShortFilter, (int) po-&gt;nMaxFileTitle) ; <br>   SetDlgItemText(hwnd, ID_MAXSZFILETITLEO, szTemp) ; <br> <br>   SetDlgItemText(hwnd, ID_SZINITDIRO, po-&gt;lpstrInitialDir) ; <br> <br>   SetDlgItemText(hwnd, ID_SZTITLEO, po-&gt;lpstrTitle) ; <br> <br>   wsprintf(szTemp, szLongFilter, po-&gt;Flags) ; <br>   SetDlgItemText(hwnd, ID_FLAGSO, szTemp) ; <br> <br>   wsprintf(szTemp, szShortFilter, po-&gt;nFileOffset) ; <br>   SetDlgItemText(hwnd, ID_FILEOFFO, szTemp) ; <br> <br>   wsprintf(szTemp, szShortFilter, po-&gt;nFileExtension) ; <br>   SetDlgItemText(hwnd, ID_FILEEXTO, szTemp) ; <br> <br>   SetDlgItemText(hwnd, ID_SZDEFEXTO, po-&gt;lpstrDefExt) ; <br> <br>   wsprintf(szTemp, szLongFilter, po-&gt;lCustData) ; <br>   SetDlgItemText(hwnd, ID_CUSTDATAO, szTemp) ; <br> <br>   wsprintf(szTemp, szLongFilter, po-&gt;lpfnHook) ; <br>   SetDlgItemText(hwnd, ID_HOOKO, szTemp) ; <br> <br>   SetDlgItemText(hwnd, ID_TEMPLATEO, po-&gt;lpTemplateName) ; <br> <br>   return ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br> <br>  Function: GetOpenDlg(HWND, LPOPENFILENAME) <br> <br> <br>  Purpose: <br> <br>      This function will retrieve the contents of each edit box corresponding <br>      with each field in the OPENFILENAME structure, and fill in the <br>      OPENFILENAME structure with these values. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    if (uMode == IDM_HEXMODE), then the numbers should be interpreted as <br>    hexidecimal and the MyAtol() function is called with its "bHex" <br>    parameter set to true. <br> <br>************************************************************************/ <br> <br>void GetOpenDlg(HWND hwnd, LPOPENFILENAME po) <br>{ <br>   int i ; <br>   BOOL b ; <br>   TCHAR szNum[20] ; <br> <br>   GetDlgItemText(hwnd, ID_STRUCTSIZEO, szNum, 20) ; <br>   po-&gt;lStructSize = MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_HWNDOWNERO, szNum, 20) ; <br>   po-&gt;hwndOwner = (HWND) MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_HINSTANCEO, szNum, 20) ; <br>   po-&gt;hInstance = (HANDLE) MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br> <br>   /* these are just strings, no conversion necessary */ <br> <br>   i = 0 ; <br>   while (SendDlgItemMessage(hwnd, ID_FILTERO, CB_GETLBTEXT, (WPARAM) i, <br>                          (LPARAM) (LPTSTR) szFilterInits[i]) != CB_ERR) <br>   { i++ ; } <br> <br> <br>   /* create the filter string */ <br> <br>   InitFilterString() ; <br> <br> <br>   i = 0 ; <br> <br>   while (SendDlgItemMessage(hwnd, ID_CUSTFILTO, CB_GETLBTEXT, (WPARAM) i, <br>                        (LPARAM) (LPTSTR) szCustFiltInits[i]) != CB_ERR) <br>   { i++ ; } <br> <br> <br>   InitCustFilterString() ; <br> <br> <br>   GetDlgItemText(hwnd, ID_MAXCUSTFILTO, szNum, 20) ; <br>   po-&gt;nMaxCustFilter = MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_FILTINDEXO, szNum, 20) ; <br>   po-&gt;nFilterIndex = MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_SZFILEO, po-&gt;lpstrFile, MAXBUF) ; <br> <br>   GetDlgItemText(hwnd, ID_MAXSZFILEO, szNum, 20) ; <br>   po-&gt;nMaxFile = MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_SZFILETITLEO, po-&gt;lpstrFileTitle, MAXBUF) ; <br> <br>   GetDlgItemText(hwnd, ID_MAXSZFILETITLEO, szNum, MAXBUF) ; <br>   po-&gt;nMaxFileTitle = MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_SZINITDIRO, (LPTSTR) po-&gt;lpstrInitialDir, MAXBUF) ; <br> <br>   GetDlgItemText(hwnd, ID_SZTITLEO, (LPTSTR) po-&gt;lpstrTitle, MAXBUF) ; <br> <br>   GetDlgItemText(hwnd, ID_FLAGSO, szNum, 20) ; <br>   po-&gt;Flags = MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_FILEOFFO, szNum, 20) ; <br>   po-&gt;nFileOffset = (WORD) MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_FILEEXTO, szNum, 20) ; <br>   po-&gt;nFileExtension = (WORD) MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_SZDEFEXTO, (LPTSTR) po-&gt;lpstrDefExt, DEFEXTSIZE) ; <br> <br>   GetDlgItemText(hwnd, ID_CUSTDATAO, szNum, 20) ; <br>   po-&gt;lCustData = MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_HOOKO, szNum, 20) ; <br>   po-&gt;lpfnHook = (LPOFNHOOKPROC) MyAtol(szNum, uMode==IDM_HEXMODE, &amp;b) ; <br> <br>   GetDlgItemText(hwnd, ID_TEMPLATEO, (LPTSTR) po-&gt;lpTemplateName, TEMPNAMESIZE) ; <br> <br> <br>   /*  if we are supposed to use a preloaded resource handle, load it and put it in <br>       OPENFILENAME.hInstance... */ <br> <br>   if (IsDlgButtonChecked(hwnd, ID_USEHINSTO) == 1) <br>     po-&gt;hInstance = GetCorrectResourceHandle() ; <br> <br>   return ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br> <br>  Function: InitFilterString(void) <br> <br> <br>  Purpose: <br> <br>    This function will create a "string" in memory in the form that the <br>    GetOpenFileName() function will expect for the filters it fills into <br>    the "List Files of Type" combo box. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    The szFilterInits and szCustFiltInits arrays are initialized to <br>    contain some default strings.  Eventually the strings in <br>    these arrays must be arranged one after the other with a null <br>    character between them and two null characters at the end: <br> <br>    "Text files\0*.txt\0All files\0*.*\0\0" <br> <br>************************************************************************/ <br> <br> <br>void InitFilterString(void) <br>{ <br>  int i ; <br>  int nInc = 0 ; <br>  LPTSTR lpStr = szFilterString ; <br> <br> <br>  /* First, zero out this memory just for the sake of sanity */ <br> <br>  for (i=0; i&lt;MAXBUF; i++) <br>    szFilterString[i] = 0 ; <br> <br> <br>  /* Now, for each string in the szFilterInits array, concatenate it to <br>     the last one right after the last one's null terminator */ <br> <br>  i = 0 ; <br> <br>  while (szFilterInits[i][0] != (TCHAR) 0) <br>  { <br>    lstrcpy(lpStr, &amp;szFilterInits[i][0]) ; <br>    nInc+=lstrlen(&amp;szFilterInits[i][0]) + 1 ;   //1 past null term... <br>    lpStr = &amp;szFilterString[nInc] ; <br>    i++ ; <br>  } <br> <br>  szFilterString[nInc] = (TCHAR) 0 ;  //double terminator <br> <br> <br>  /* Set the lpszFilterString to point to the memory we just filled in <br>     with the filters because lpszFilterString is what is in <br>     OPENFILENAME-&gt;lpstrFilter */ <br> <br>  lpszFilterString = szFilterString ; <br> <br>  return ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br> <br>  Function: InitCustFiltString(void) <br> <br> <br>  Purpose: <br> <br>    This function will create a "string" in memory in the form that the <br>    GetOpenFileName() function will expect for a custom filter. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    The szFilterInits and szCustFiltInits arrays are initialized to <br>    contain some default strings.  Eventually the strings in <br>    these arrays must be arranged one after the other with a null <br>    character between them and two null characters at the end: <br> <br>    "Text files\0*.txt\0All files\0*.*\0\0" <br> <br>    This program initializes these strings, but they do not need to be <br>    initialized.  The GetOpenFileName() functiion will write a filter <br>    into this memory area if the user types a new filter into the <br>    "FileName" box and returns by clicking the OK button (indicating that <br>    a file matching that filter was found). <br> <br>************************************************************************/ <br> <br> <br>void InitCustFilterString(void) <br>{ <br>  int i ; <br>  LPTSTR lpStr = szCustFilterString ; <br>  int nInc = 0 ; <br> <br>  for (i=0; i&lt;MAXBUF; i++) <br>    szCustFilterString[i] = 0 ; <br> <br>  i = 0 ; <br> <br>  for(i=0; i&lt;2; i++)  //only two for the custom filter <br>  { <br>    lstrcpy(lpStr, &amp;szCustFiltInits[i][0]) ; <br>    nInc+=lstrlen(&amp;szCustFiltInits[i][0]) + 1 ; <br>    lpStr = &amp;szCustFilterString[nInc] ; <br>  } <br> <br>  szCustFilterString[nInc] = (TCHAR) 0 ; <br> <br>  lpszCustFilterString = szCustFilterString ; <br> <br>  return ; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: InterpretCustomFilterString(void) <br> <br> <br>  Purpose: <br> <br>    This function will parse the memory that is being used for the <br>    custom filter string.  If the user returned TRUE after entering <br>    their own filter, the new filter will be here and so we need to <br>    add it to our custom filter init array... <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>void InterpretCustomFilterString(void) <br>{ <br>  LPTSTR pNext ; <br> <br>  int nCount = lstrlen(ofn.lpstrCustomFilter) ; <br> <br>  pNext = ofn.lpstrCustomFilter + nCount + 1 ;  //one past the NULL <br> <br> <br>  /* add it to the filter inits array */ <br> <br>  lstrcpy(&amp;szCustFiltInits[0][0], ofn.lpstrCustomFilter) ; <br>  lstrcpy(&amp;szCustFiltInits[1][0], pNext) ; <br> <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: GetCorrectResourceHandle(void) <br> <br>  Purpose: <br> <br>    This function will use FindResource() to find the correct custom <br>    template resource, use LoadResource() to get a handle to it. <br> <br>  Returns: A handle to a custom template resource. <br> <br>  Comments: <br> <br>    The names for the custom template for GetOpenFileName() are <br> <br>      "opentemp1" -- normal <br>      "opentemp2" -- contains a multi-select list box for the file names <br> <br>    If the user has marked the "Preloaded Template" box and specified <br>    OFN_ENABLETEMPLATEHANDLE in the "Flags" edit box, this handle <br>    will be used to create the GetOpenFileName() dialog box. <br> <br>************************************************************************/ <br> <br> <br>HANDLE GetCorrectResourceHandle(void) <br>{ <br>  if (ofn.Flags &amp; OFN_ALLOWMULTISELECT) <br>  { <br>     hRes = FindResource(hInst, TEXT("opentemp2"), RT_DIALOG) ; <br>     hDialog = LoadResource(hInst, hRes) ; <br>  } <br> <br>  else <br>  { <br>     hRes = FindResource(hInst, TEXT("opentemp1"), RT_DIALOG) ; <br>     hDialog = LoadResource(hInst, hRes) ; <br>  } <br> <br>  return hDialog ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: OpenSaveHookProc(HWND, UINT, UINT, LONG) ; <br> <br>  Purpose: <br> <br>    This function is the hook function for the GetOpenFileName() function. <br>    If GetOpenFileName() is called with the OFN_ENABLEHOOK flag, this <br>    function will be called before the normal GetOpenFileName() dialog <br>    function is called. <br> <br>  Returns: FALSE to pass the message on to the normal GetOpenFileName() <br>           logic, TRUE to discard the message. <br> <br>  Comments: <br> <br>    To enable this function in this program, enter the value for <br>    OFN_ENABLEHOOK in the "Flags" edit box. <br> <br>************************************************************************/ <br> <br> <br>UINT APIENTRY OpenSaveHookProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  LPOPENFILENAME pOfn ; <br>  TCHAR szMsg[50] ; <br> <br>  switch(msg) <br>  { <br>    case WM_INITDIALOG: <br> <br>      pOfn = (LPOPENFILENAME) lParam ; <br> <br> <br>      /* During initialization, if there is a hook proc, the getopen() <br>         code will send pointer to the OPENFILENAME strucure in the <br>         lParam.  To demonstrate this, pop up a message box if this <br>         structure has a non zero value in the lCustData structure member */ <br> <br> <br>      if (pOfn-&gt;lCustData != 0L) <br>      { <br>        wsprintf(szMsg, TEXT("OPENFILENAME-&gt;lCustData is: %ld"), pOfn-&gt;lCustData) ; <br> <br>        MessageBox(hwnd, szMsg, TEXT("lCustData Sent!"), MB_OK) ; <br>      } <br> <br>      SetWindowText(hwnd, TEXT("Open Hook Proc Dialog")) ; <br> <br>      break ; <br> <br> <br>    /* use the WM_CTLCOLOR* messages to change the color of the Open <br>       dialog */ <br> <br>    case WM_CTLCOLORDLG: <br> <br>        if (!hBrushDlg) <br>            hBrushDlg = GetStockObject(LTGRAY_BRUSH) ; <br> <br>        return (UINT) hBrushDlg ; <br> <br>        break ; <br> <br> <br>    case WM_CTLCOLORBTN: <br> <br>        SetBkMode((HDC) wParam, TRANSPARENT) ;   //sets background color <br>                                                 //for push and check box <br>                                                 //buttons... <br> <br>        if (!hBrushButton) <br>            hBrushButton = GetStockObject(LTGRAY_BRUSH) ; <br> <br>        return (UINT) hBrushButton ; <br> <br>        break ; <br> <br> <br>    case WM_CTLCOLORSTATIC: <br> <br>        SetTextColor((HDC) wParam, RGB(0x00, 0xff, 0x00)) ;  //green <br>        SetBkMode((HDC) wParam, TRANSPARENT) ;               //transparent text <br> <br>        if (!hBrushDlg) <br>            hBrushDlg = GetStockObject(LTGRAY_BRUSH) ; <br> <br>        return (UINT) hBrushDlg ; <br> <br>        break ; <br> <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) <br>        { <br>          case chx1: <br>            MessageBox(hwnd, TEXT("Read-Only button clicked..."), <br>                       TEXT("Open"), MB_OK | MB_APPLMODAL) ; <br>            break ; <br> <br>          case ID_FILEPREVIEW: <br>            MessageBox(hwnd, TEXT("File Preview Button Clicked"), <br>                       TEXT("Open"), MB_OK | MB_APPLMODAL) ; <br>            break ; <br> <br>          default: break ; <br>        } <br>        break ; <br> <br>    default: <br> <br>      if (msg == nOpenShareVMsg) <br>      { <br>        MessageBox(hwnd, TEXT("The SHAREVSTRING message is here!"), <br>                         TEXT("Open"), <br>                         MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL) ; <br> <br>        return OFN_SHAREWARN ; <br>      } <br>      break ; <br>  } <br> <br>  return FALSE ;   //send msg to the common dialog code <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: MultiThreadOpenSave(void) <br> <br>  Purpose: <br> <br>    This function will start two threads and then return.  The two <br>    threads will create GetOpenFileName() dialogs, and the user <br>    can interact with two Open dialogs at once. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>    This will create two Open dialogs, but they will be created in the <br>    same location on the screen.  The only way to change that would be <br>    to call the function with a hookproc and move one of the windows. <br> <br>    But that would mean that if the user did not enter OFN_ENABLEHOOK <br>    in the "Flags" edit box, we would be no better off than before.  So, <br>    in order to see both dialogs, you just have to move the top one out <br>    of the way a little. <br> <br>    Multithreading note: <br> <br>    This function will return before the common dialog functions return. </code></pre>
<p>
</p>
<pre><code>Therefore, do not pass any parameters to this function that will be <br>    referenced by the common dialogs because as soon as this function <br>    ends those parameters will be gone. <br> <br>************************************************************************/ <br> <br>void MultiThreadOpenSave(void) <br>{ <br> <br>  if (!(hOpenSaveThread1 = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0, <br>                                        (LPTHREAD_START_ROUTINE) OpenSaveThread1Proc, <br>                                        &amp;dwThreadParm1, CREATE_SUSPENDED, &amp;dwThreadID1))) <br> <br>  { <br>    MessageBox(GetForegroundWindow(), TEXT("Cannot create thread 1"), NULL, MB_OK | MB_ICONEXCLAMATION) ; <br>    OpenMultiThreadEnableButtons(TRUE, hwndMainDialog) ; <br>    nOpenDialogCount = 0 ; <br>    return ; <br>  } <br> <br> <br> <br>  if (!(hOpenSaveThread2 = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0, <br>                                        (LPTHREAD_START_ROUTINE) OpenSaveThread2Proc, <br>                                        &amp;dwThreadParm2, CREATE_SUSPENDED, &amp;dwThreadID2))) <br>  { <br>    MessageBox(GetForegroundWindow(), TEXT("Cannot create thread 2"), NULL, MB_OK | MB_ICONEXCLAMATION) ; <br>    OpenMultiThreadEnableButtons(TRUE, hwndMainDialog) ; <br>    nOpenDialogCount = 0 ; <br>    return ; <br>  } <br> <br> <br>  ResumeThread(hOpenSaveThread1) ; <br>  ResumeThread(hOpenSaveThread2) ; <br> <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: OpenSaveThreadProc1(LPDWORD) <br> <br>  Purpose: <br> <br>    This is the address where the first thread starts executing. <br> <br>  Returns: Any DWORD value. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br> <br>DWORD OpenSaveThread1Proc(LPDWORD pDw) <br>{ <br> <br>  /* Get the user's input */ <br> <br>  GetOpenDlg(hwndMainDialog, &amp;ofnThread1) ; <br> <br> <br>  /* Do the dialog */ <br> <br>  DoOpenSaveStuff(&amp;ofnThread1) ; <br> <br> <br>  /* send a message to the parent telling it to decrement the dialog count. <br>     When the dialog count reaches zero, all the buttons are enabled again. */ <br> <br>  SendMessage(hwndMainDialog, UMSG_DECREMENTDLGCOUNT, 0, 0L) ; <br> <br>  return 0L ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: OpenSaveThreadProc2(LPDWORD) <br> <br>  Purpose: <br> <br>    This is the address where the second thread starts executing. <br> <br>  Returns: Any DWORD value. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>DWORD OpenSaveThread2Proc(LPDWORD pDw) <br>{ <br>  GetOpenDlg(hwndMainDialog, &amp;ofnThread2) ; <br> <br>  DoOpenSaveStuff(&amp;ofnThread2) ; <br> <br>  SendMessage(hwndMainDialog, UMSG_DECREMENTDLGCOUNT, 0, 0L) ; <br> <br>  return 0L ; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: DoOpenSaveStuff(LPOPENFILENAME) <br> <br>  Purpose: <br> <br>    This is the function that actually calls GetOpenFileName() or <br>    GetSaveFileName().  It receives a pointer to the structure to <br>    use as its only parameter. <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>void DoOpenSaveStuff(LPOPENFILENAME po) <br>{ <br>  BOOL bRet = TRUE ; <br> <br> <br>  /* If bOpenDlg is TRUE, do GetOpenFileName(), else do GetSave(). <br>     If the "NULL Structure" button is checked, send in a NULL pointer <br>     to the function */ <br> <br>  if (bDoOpenDlg) <br>  { <br>    if (IsDlgButtonChecked(hwndMainDialog, ID_NULLSTRUCTO) == 1) <br>      bRet = GetOpenFileName((LPOPENFILENAME) NULL) ; <br>    else <br>      bRet = GetOpenFileName(po) ; <br>  } <br> <br>  else <br>  { <br>    if (IsDlgButtonChecked(hwndMainDialog, ID_NULLSTRUCTO)) <br>      bRet = GetSaveFileName((LPOPENFILENAME) NULL) ; <br>    else <br>      bRet = GetSaveFileName(po) ; <br>  } <br> <br> <br>  /* Record the results */ <br> <br>  wsprintf(szTemp, szLongFilter, CommDlgExtendedError()) ; <br>  SetDlgItemText(hwndMainDialog, ID_ERRORO, szTemp) ; <br> <br>  wsprintf(szTemp, szShortFilter, (int) bRet) ; <br>  SetDlgItemText(hwndMainDialog, ID_RETURNO, szTemp) ; <br> <br>  InterpretCustomFilterString() ; <br> <br>  FillOpenDlg(hwndMainDialog, po) ; <br> <br>  if (hDialog) <br>  { <br>    FreeResource(hDialog) ;    //free ofn.hInstance <br>    hDialog = (HANDLE) 0 ; <br>    hRes = (HANDLE) 0 ; <br>  } <br>} <br> <br> <br> <br> <br> <br> <br> <br>/************************************************************************ <br> <br>  Function: OpenMultiThreadEnableButtons(BOOL, HWND) <br> <br>  Purpose: <br> <br>    Enable or disable the buttons that might affect the state of the <br>    OPENFILENAME structures.  This is necessary because during a <br>    multithreading session, these buttons may be accessible even though <br>    there are Open dialogs still working and we don't want to change <br>    the OPENFILENAME structure out from under them. <br> <br> <br>  Returns: Nothing. <br> <br>  Comments: <br> <br>************************************************************************/ <br> <br>void OpenMultiThreadEnableButtons(BOOL bEnable, HWND hwnd) <br>{ <br>  EnableWindow(GetDlgItem(hwnd, IDOK), bEnable) ; <br>  EnableWindow(GetDlgItem(hwnd, IDCANCEL), bEnable) ; <br>  EnableWindow(GetDlgItem(hwnd, ID_RESETOPEN), bEnable) ; <br>  EnableWindow(GetDlgItem(hwnd, ID_MULTIOPEN), bEnable) ; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
