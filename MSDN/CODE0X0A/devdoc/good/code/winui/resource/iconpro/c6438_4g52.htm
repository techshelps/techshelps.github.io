<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6446"></a>DIB.C</h2>
<pre><code>/****************************************************************************\ <br>*             <br>*     FILE:     DIB.C <br>* <br>*     PURPOSE:  DIB functions for IconPro Project <br>* <br>*     COMMENTS: Icons are stored in a format almost identical to DIBs. For <br>*               this reason, it is easiest to deal with the individual <br>*               icon images as DIBs (or DIBSections). This has the added <br>*               advantage of retaining color depth even on low-end displays. <br>* <br>*     FUNCTIONS: <br>*      EXPORTS:  <br>*               FindDIBBits()      - Locate the image bits in a DIB <br>*               DIBNumColors()     - Calculate number of color table entries <br>*               PaletteSize()      - Calculate number of color table bytes <br>*               BytesPerLine()     - Calculate number of bytes per scan line <br>*               ConvertDIBFormat() - Converts DIBs between formats <br>*               SetMonoDIBPixel()  - Sets/Clears a pixel in a 1bpp DIB <br>*               ReadBMPFile()      - Reads a BMP file into CF_DIB memory <br>*               WriteBMPFile()     - Write a BMP file from CF_DIB memory <br>*      LOCALS: <br>*               CopyColorTable()   - Copies color table from DIB to DIB <br>* <br>*     Copyright 1995 - 1998 Microsoft Corp. <br>* <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>#include &lt;Windows.h&gt; <br>#include "Dib.H" <br> <br> <br>/****************************************************************************/ <br>/* Local Function Prototypes */ <br>BOOL CopyColorTable( LPBITMAPINFO lpTarget, LPBITMAPINFO lpSource ); <br>/****************************************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: FindDIBits <br>* <br>*     PURPOSE:  Locate the image bits in a CF_DIB format DIB. <br>* <br>*     PARAMS:   LPSTR lpbi - pointer to the CF_DIB memory block <br>* <br>*     RETURNS:  LPSTR - pointer to the image bits <br>* <br>* History: <br>*                July '95 - Copied &lt;g&gt; <br>* <br>\****************************************************************************/ <br>LPSTR FindDIBBits( LPSTR lpbi ) <br>{ <br>   return ( lpbi + *(LPDWORD)lpbi + PaletteSize( lpbi ) ); <br>} <br>/* End FindDIBits() *********************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: DIBNumColors <br>* <br>*     PURPOSE:  Calculates the number of entries in the color table. <br>* <br>*     PARAMS:   LPSTR lpbi - pointer to the CF_DIB memory block <br>* <br>*     RETURNS:  WORD - Number of entries in the color table. <br>* <br>* History: <br>*                July '95 - Copied &lt;g&gt; <br>* <br>\****************************************************************************/ <br>WORD DIBNumColors( LPSTR lpbi ) <br>{ <br>    WORD wBitCount; <br>    DWORD dwClrUsed; <br> <br>    dwClrUsed = ((LPBITMAPINFOHEADER) lpbi)-&gt;biClrUsed; <br> <br>    if (dwClrUsed) <br>        return (WORD) dwClrUsed; <br> <br>    wBitCount = ((LPBITMAPINFOHEADER) lpbi)-&gt;biBitCount; <br> <br>    switch (wBitCount) <br>    { <br>        case 1: return 2; <br>        case 4: return 16; <br>        case 8:return 256; <br>        default:return 0; <br>    } <br>    return 0; <br>} <br>/* End DIBNumColors() ******************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: PaletteSize <br>* <br>*     PURPOSE:  Calculates the number of bytes in the color table. <br>* <br>*     PARAMS:   LPSTR lpbi - pointer to the CF_DIB memory block <br>* <br>*     RETURNS:  WORD - number of bytes in the color table <br>* <br>* <br>* History: <br>*                July '95 - Copied &lt;g&gt; <br>* <br>\****************************************************************************/ <br>WORD PaletteSize( LPSTR lpbi ) <br>{ <br>    return ( DIBNumColors( lpbi ) * sizeof( RGBQUAD ) ); <br>} <br>/* End PaletteSize() ********************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: BytesPerLine <br>* <br>*     PURPOSE:  Calculates the number of bytes in one scan line. <br>* <br>*     PARAMS:   LPBITMAPINFOHEADER lpBMIH - pointer to the BITMAPINFOHEADER <br>*                                           that begins the CF_DIB block <br>* <br>*     RETURNS:  DWORD - number of bytes in one scan line (DWORD aligned) <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>DWORD BytesPerLine( LPBITMAPINFOHEADER lpBMIH ) <br>{ <br>    return WIDTHBYTES(lpBMIH-&gt;biWidth * lpBMIH-&gt;biPlanes * lpBMIH-&gt;biBitCount); <br>} <br>/* End BytesPerLine() ********************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ConvertDIBFormat <br>* <br>*     PURPOSE:  Creates a new DIB of the requested format, copies the source <br>*               image to the new DIB. <br>* <br>*     PARAMS:   LPBITMAPINFO lpSrcDIB - the source CF_DIB <br>*               UINT         nWidth   - width for new DIB <br>*               UINT         nHeight  - height for new DIB <br>*               UINT         nbpp     - bpp for new DIB <br>*               BOOL         bStretch - TRUE to stretch source to dest <br>*                                       FALSE to take upper left of image <br>* <br>*     RETURNS:  LPBYTE - pointer to new CF_DIB memory block with new image <br>*               NULL on failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>LPBYTE ConvertDIBFormat( LPBITMAPINFO lpSrcDIB, UINT nWidth, UINT nHeight, UINT nbpp, BOOL bStretch ) <br>{ <br>    LPBITMAPINFO    lpbmi = NULL; <br>    LPBYTE        lpSourceBits, lpTargetBits, lpResult; <br>    HDC            hDC = NULL, hSourceDC, hTargetDC; <br>    HBITMAP        hSourceBitmap, hTargetBitmap, hOldTargetBitmap, hOldSourceBitmap; <br>    DWORD        dwSourceBitsSize, dwTargetBitsSize, dwTargetHeaderSize; <br> <br>    // Allocate and fill out a BITMAPINFO struct for the new DIB <br>    // Allow enough room for a 256-entry color table, just in case <br>    dwTargetHeaderSize = sizeof( BITMAPINFO ) + ( 256 * sizeof( RGBQUAD ) ); <br>    lpbmi = malloc( dwTargetHeaderSize ); <br>    lpbmi-&gt;bmiHeader.biSize = sizeof( BITMAPINFOHEADER ); <br>    lpbmi-&gt;bmiHeader.biWidth = nWidth; <br>    lpbmi-&gt;bmiHeader.biHeight = nHeight; <br>    lpbmi-&gt;bmiHeader.biPlanes = 1; <br>    lpbmi-&gt;bmiHeader.biBitCount = nbpp; <br>    lpbmi-&gt;bmiHeader.biCompression = BI_RGB; <br>    lpbmi-&gt;bmiHeader.biSizeImage = 0; <br>    lpbmi-&gt;bmiHeader.biXPelsPerMeter = 0; <br>    lpbmi-&gt;bmiHeader.biYPelsPerMeter = 0; <br>    lpbmi-&gt;bmiHeader.biClrUsed = 0; <br>    lpbmi-&gt;bmiHeader.biClrImportant = 0; <br>    // Fill in the color table <br>    if( ! CopyColorTable( lpbmi, (LPBITMAPINFO)lpSrcDIB ) ) <br>    { <br>        free( lpbmi ); <br>        return NULL; <br>    } <br> <br>    // Gonna use DIBSections and BitBlt() to do the conversion, so make 'em <br>    hDC = GetDC( NULL ); <br>    hTargetBitmap = CreateDIBSection( hDC, lpbmi, DIB_RGB_COLORS, &amp;lpTargetBits, NULL, 0 ); <br>    hSourceBitmap = CreateDIBSection( hDC, lpSrcDIB, DIB_RGB_COLORS, &amp;lpSourceBits, NULL, 0 ); <br>    hSourceDC = CreateCompatibleDC( hDC ); <br>    hTargetDC = CreateCompatibleDC( hDC ); <br> <br>    // Flip the bits on the source DIBSection to match the source DIB <br>    dwSourceBitsSize = lpSrcDIB-&gt;bmiHeader.biHeight * BytesPerLine(&amp;(lpSrcDIB-&gt;bmiHeader)); <br>    dwTargetBitsSize = lpbmi-&gt;bmiHeader.biHeight * BytesPerLine(&amp;(lpbmi-&gt;bmiHeader)); <br>    memcpy( lpSourceBits, FindDIBBits((LPSTR)lpSrcDIB), dwSourceBitsSize ); <br> <br>    // Select DIBSections into DCs <br>    hOldSourceBitmap = SelectObject( hSourceDC, hSourceBitmap ); <br>    hOldTargetBitmap = SelectObject( hTargetDC, hTargetBitmap ); <br> <br>    // Set the color tables for the DIBSections <br>    if( lpSrcDIB-&gt;bmiHeader.biBitCount &lt;= 8 ) <br>        SetDIBColorTable( hSourceDC, 0, 1 &lt;&lt; lpSrcDIB-&gt;bmiHeader.biBitCount, lpSrcDIB-&gt;bmiColors ); <br>    if( lpbmi-&gt;bmiHeader.biBitCount &lt;= 8 ) <br>        SetDIBColorTable( hTargetDC, 0, 1 &lt;&lt; lpbmi-&gt;bmiHeader.biBitCount, lpbmi-&gt;bmiColors ); <br> <br>    // If we are asking for a straight copy, do it <br>    if( (lpSrcDIB-&gt;bmiHeader.biWidth==lpbmi-&gt;bmiHeader.biWidth) &amp;&amp; (lpSrcDIB-&gt;bmiHeader.biHeight==lpbmi-&gt;bmiHeader.biHeight) ) <br>    { <br>        BitBlt( hTargetDC, 0, 0, lpbmi-&gt;bmiHeader.biWidth, lpbmi-&gt;bmiHeader.biHeight, hSourceDC, 0, 0, SRCCOPY ); <br>    } <br>    else <br>    { <br>        // else, should we stretch it? <br>        if( bStretch ) <br>        { <br>            SetStretchBltMode( hTargetDC, COLORONCOLOR ); <br>            StretchBlt( hTargetDC, 0, 0, lpbmi-&gt;bmiHeader.biWidth, lpbmi-&gt;bmiHeader.biHeight, hSourceDC, 0, 0, lpSrcDIB-&gt;bmiHeader.biWidth, lpSrcDIB-&gt;bmiHeader.biHeight, SRCCOPY ); <br>        } <br>        else <br>        { <br>            // or just take the upper left corner of the source <br>            BitBlt( hTargetDC, 0, 0, lpbmi-&gt;bmiHeader.biWidth, lpbmi-&gt;bmiHeader.biHeight, hSourceDC, 0, 0, SRCCOPY ); <br>        } <br>    } <br> <br>    // Clean up and delete the DCs <br>    SelectObject( hSourceDC, hOldSourceBitmap ); <br>    SelectObject( hSourceDC, hOldTargetBitmap ); <br>    DeleteDC( hSourceDC ); <br>    DeleteDC( hTargetDC ); <br>    ReleaseDC( NULL, hDC ); <br> <br>    // Flush the GDI batch, so we can play with the bits <br>    GdiFlush(); <br> <br>    // Allocate enough memory for the new CF_DIB, and copy bits <br>    lpResult = malloc( dwTargetHeaderSize + dwTargetBitsSize ); <br>    memcpy( lpResult, lpbmi, dwTargetHeaderSize ); <br>    memcpy( FindDIBBits( lpResult ), lpTargetBits, dwTargetBitsSize ); <br> <br>    // final cleanup <br>    DeleteObject( hTargetBitmap ); <br>    DeleteObject( hSourceBitmap ); <br>    free( lpbmi ); <br> <br>    return lpResult; <br>} <br>/* End ConvertDIBFormat() ***************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: CopyColorTable <br>* <br>*     PURPOSE:  Copies the color table from one CF_DIB to another. <br>* <br>*     PARAMS:   LPBITMAPINFO lpTarget - pointer to target DIB <br>*               LPBITMAPINFO lpSource - pointer to source DIB <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL CopyColorTable( LPBITMAPINFO lpTarget, LPBITMAPINFO lpSource ) <br>{ <br>    // What we do depends on the target's color depth <br>    switch( lpTarget-&gt;bmiHeader.biBitCount ) <br>    { <br>        // 8bpp - need 256 entry color table <br>        case 8: <br>            if( lpSource-&gt;bmiHeader.biBitCount == 8 ) <br>            { // Source is 8bpp too, copy color table <br>                memcpy( lpTarget-&gt;bmiColors, lpSource-&gt;bmiColors, 256*sizeof(RGBQUAD) ); <br>                return TRUE; <br>            } <br>            else <br>            { // Source is != 8bpp, use halftone palette                 <br>                HPALETTE        hPal; <br>                HDC            hDC = GetDC( NULL ); <br>                PALETTEENTRY    pe[256]; <br>                UINT            i; <br> <br>                hPal = CreateHalftonePalette( hDC ); <br>                ReleaseDC( NULL, hDC ); <br>                GetPaletteEntries( hPal, 0, 256, pe ); <br>                DeleteObject( hPal ); <br>                for(i=0;i&lt;256;i++) <br>                { <br>                    lpTarget-&gt;bmiColors[i].rgbRed = pe[i].peRed; <br>                    lpTarget-&gt;bmiColors[i].rgbGreen = pe[i].peGreen; <br>                    lpTarget-&gt;bmiColors[i].rgbBlue = pe[i].peBlue; <br>                    lpTarget-&gt;bmiColors[i].rgbReserved = pe[i].peFlags; <br>                } <br>                return TRUE; <br>            } <br>        break; // end 8bpp <br> <br>        // 4bpp - need 16 entry color table <br>        case 4: <br>            if( lpSource-&gt;bmiHeader.biBitCount == 4 ) <br>            { // Source is 4bpp too, copy color table <br>                memcpy( lpTarget-&gt;bmiColors, lpSource-&gt;bmiColors, 16*sizeof(RGBQUAD) ); <br>                return TRUE; <br>            } <br>            else <br>            { // Source is != 4bpp, use system palette <br>                HPALETTE        hPal; <br>                PALETTEENTRY    pe[256]; <br>                UINT            i; <br> <br>                hPal = GetStockObject( DEFAULT_PALETTE ); <br>                GetPaletteEntries( hPal, 0, 16, pe ); <br>                for(i=0;i&lt;16;i++) <br>                { <br>                    lpTarget-&gt;bmiColors[i].rgbRed = pe[i].peRed; <br>                    lpTarget-&gt;bmiColors[i].rgbGreen = pe[i].peGreen; <br>                    lpTarget-&gt;bmiColors[i].rgbBlue = pe[i].peBlue; <br>                    lpTarget-&gt;bmiColors[i].rgbReserved = pe[i].peFlags; <br>                } <br>                return TRUE; <br>            } <br>        break; // end 4bpp <br> <br>        // 1bpp - need 2 entry mono color table <br>        case 1: <br>            lpTarget-&gt;bmiColors[0].rgbRed = 0; <br>            lpTarget-&gt;bmiColors[0].rgbGreen = 0; <br>            lpTarget-&gt;bmiColors[0].rgbBlue = 0; <br>            lpTarget-&gt;bmiColors[0].rgbReserved = 0; <br>            lpTarget-&gt;bmiColors[1].rgbRed = 255; <br>            lpTarget-&gt;bmiColors[1].rgbGreen = 255; <br>            lpTarget-&gt;bmiColors[1].rgbBlue = 255; <br>            lpTarget-&gt;bmiColors[1].rgbReserved = 0; <br>        break; // end 1bpp <br> <br>        // no color table for the &gt; 8bpp modes <br>        case 32: <br>        case 24: <br>        case 16: <br>        default: <br>            return TRUE; <br>        break; <br>    } <br>    return TRUE; <br>} <br>/* End CopyColorTable() *****************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: SetMonoDIBPixel <br>* <br>*     PURPOSE:  Sets/Clears a pixel in a 1bpp DIB by directly poking the bits. <br>* <br>*     PARAMS:   LPBYTE pANDBits - pointer to the 1bpp image bits <br>*               DWORD  dwWidth- width of the DIB <br>*               DWORD  dwHeight- height of the DIB <br>*               DWORD  x        - x location of pixel to set/clear <br>*               DWORD  y        - y location of pixel to set/clear <br>*               BOOL   bWhite- TRUE to set pixel, FALSE to clear it <br>* <br>*     RETURNS:  void <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>void SetMonoDIBPixel( LPBYTE pANDBits, DWORD dwWidth, DWORD dwHeight, DWORD x, DWORD y, BOOL bWhite ) <br>{ <br>    DWORDByteIndex; <br>    BYTE    BitNumber; <br> <br>    // Find the byte on which this scanline begins <br>    ByteIndex = (dwHeight - y - 1) * WIDTHBYTES(dwWidth); <br>    // Find the byte containing this pixel <br>    ByteIndex += (x &gt;&gt; 3); <br>    // Which bit is it? <br>    BitNumber = (BYTE)( 7 - (x % 8) ); <br> <br>    if( bWhite ) <br>        // Turn it on <br>        pANDBits[ByteIndex] |= (1&lt;&lt;BitNumber); <br>    else <br>        // Turn it off <br>        pANDBits[ByteIndex] &amp;= ~(1&lt;&lt;BitNumber); <br>} <br>/* End SetMonoDIBPixel() *****************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ReadBMPFile <br>* <br>*     PURPOSE:  Reads a BMP file into CF_DIB format <br>* <br>*     PARAMS:   LPCTSTR szFileName - the name of the file to read <br>* <br>*     RETURNS:  LPBYTE - pointer to the CF_DIB, NULL for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>LPBYTE ReadBMPFile( LPCTSTR szFileName ) <br>{ <br>    HANDLE            hFile; <br>    BITMAPFILEHEADER    bfh; <br>    DWORD            dwBytes; <br>    LPBYTE            lpDIB = NULL, lpTemp = NULL; <br>    WORD                wPaletteSize = 0; <br>    DWORD            dwBitsSize = 0; <br> <br>    // Open the file <br>    if( (hFile=CreateFile( szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE ) <br>    { <br>        MessageBox( NULL, "Error opening file", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // Read the header <br>    if( ( ! ReadFile( hFile, &amp;bfh, sizeof(BITMAPFILEHEADER), &amp;dwBytes, NULL ) ) || ( dwBytes != sizeof( BITMAPFILEHEADER ) ) ) <br>    { <br>        CloseHandle( hFile ); <br>        MessageBox( NULL, "Error reading file", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // Does it look like a BMP file? <br>    if( ( bfh.bfType != 0x4d42 ) || (bfh.bfReserved1!=0) || (bfh.bfReserved2!=0) ) <br>    { <br>        CloseHandle( hFile ); <br>        MessageBox( NULL, "Not a recognised BMP format file", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // Allocate some memory <br>    if( (lpDIB = malloc( sizeof( BITMAPINFO ) )) == NULL ) <br>    { <br>        CloseHandle( hFile ); <br>        MessageBox( NULL, "Failed to allocate memory for DIB", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // Read in the BITMAPINFOHEADER <br>    if( (!ReadFile( hFile, lpDIB, sizeof(BITMAPINFOHEADER), &amp;dwBytes, NULL )) || (dwBytes!=sizeof(BITMAPINFOHEADER)) ) <br>    { <br>        CloseHandle( hFile ); <br>        free( lpDIB ); <br>        MessageBox( NULL, "Error reading file", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    if( ((LPBITMAPINFOHEADER)lpDIB)-&gt;biSize != sizeof( BITMAPINFOHEADER ) ) <br>    { <br>        CloseHandle( hFile ); <br>        free( lpDIB ); <br>        MessageBox( NULL, "OS/2 style BMPs Not Supported", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // How big are the elements? <br>    wPaletteSize = PaletteSize((LPSTR)lpDIB); <br>    dwBitsSize = ((LPBITMAPINFOHEADER)lpDIB)-&gt;biHeight * BytesPerLine((LPBITMAPINFOHEADER)lpDIB); <br>    // realloc to account for the total size of the DIB <br>    if( (lpTemp = realloc( lpDIB, sizeof( BITMAPINFOHEADER ) + wPaletteSize + dwBitsSize )) == NULL ) <br>    { <br>        CloseHandle( hFile ); <br>        MessageBox( NULL, "Failed to allocate memory for DIB", szFileName, MB_OK ); <br>        free( lpDIB ); <br>        return NULL; <br>    } <br>    lpDIB = lpTemp; <br>    // If there is a color table, read it <br>    if( wPaletteSize != 0 ) <br>    { <br>        if( (!ReadFile( hFile, ((LPBITMAPINFO)lpDIB)-&gt;bmiColors, wPaletteSize, &amp;dwBytes, NULL )) || (dwBytes!=wPaletteSize) ) <br>        { <br>            CloseHandle( hFile ); <br>            free( lpDIB ); <br>            MessageBox( NULL, "Error reading file", szFileName, MB_OK ); <br>            return NULL; <br>        } <br>    } <br>    // Seek to the bits <br>    // checking against 0 in case some bogus app didn't set this element <br>    if( bfh.bfOffBits != 0 ) <br>    { <br>        if( SetFilePointer( hFile, bfh.bfOffBits, NULL, FILE_BEGIN ) == 0xffffffff ) <br>        { <br>            CloseHandle( hFile ); <br>            free( lpDIB ); <br>            MessageBox( NULL, "Error reading file", szFileName, MB_OK ); <br>            return NULL; <br>        } <br>    } <br>    // Read the image bits <br>    if( (!ReadFile( hFile, FindDIBBits(lpDIB), dwBitsSize, &amp;dwBytes, NULL )) || (dwBytes!=dwBitsSize) ) <br>    { <br>        CloseHandle( hFile ); <br>        free( lpDIB ); <br>        MessageBox( NULL, "Error reading file", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // clean up <br>    CloseHandle( hFile ); <br>    return lpDIB; <br>} <br>/* End ReadBMPFile() ********************************************************/ <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: WriteBMPFile <br>* <br>*     PURPOSE:  Writes a BMP file from CF_DIB format <br>* <br>*     PARAMS:   LPCTSTR szFileName - the name of the file to read <br>*               LPBYTE - pointer to the CF_DIB, NULL for failure <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for Failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL WriteBMPFile( LPCTSTR szFileName, LPBYTE lpDIB ) <br>{ <br>    HANDLE            hFile; <br>    BITMAPFILEHEADER    bfh; <br>    DWORD            dwBytes, dwBytesToWrite; <br>    LPBITMAPINFOHEADERlpbmih; <br> <br>    // Open the file <br>    if( (hFile=CreateFile( szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE ) <br>    { <br>        MessageBox( NULL, "Error opening file", szFileName, MB_OK ); <br>        return FALSE; <br>    } <br>    bfh.bfType = 0x4d42; <br>    bfh.bfReserved1 = 0; <br>    bfh.bfReserved2 = 0; <br>    bfh.bfOffBits = sizeof( BITMAPFILEHEADER ) + sizeof( BITMAPINFOHEADER ) + PaletteSize( lpDIB ); <br>    bfh.bfSize = (bfh.bfOffBits + ((LPBITMAPINFOHEADER)lpDIB)-&gt;biHeight * BytesPerLine((LPBITMAPINFOHEADER)lpDIB))/4; <br>    // Write the header <br>    if( ( ! WriteFile( hFile, &amp;bfh, sizeof(BITMAPFILEHEADER), &amp;dwBytes, NULL ) ) || ( dwBytes != sizeof( BITMAPFILEHEADER ) ) ) <br>    { <br>        CloseHandle( hFile ); <br>        MessageBox( NULL, "Error Writing file", szFileName, MB_OK ); <br>        return FALSE; <br>    } <br>    lpbmih = (LPBITMAPINFOHEADER)lpDIB; <br>    lpbmih-&gt;biHeight /= 2; <br>    dwBytesToWrite = bfh.bfOffBits + (lpbmih-&gt;biHeight * BytesPerLine(lpbmih)); <br>    if( ( ! WriteFile( hFile, lpDIB, dwBytesToWrite, &amp;dwBytes, NULL ) ) || ( dwBytes != dwBytesToWrite ) ) <br>    { <br>        CloseHandle( hFile ); <br>        MessageBox( NULL, "Error Writing file", szFileName, MB_OK ); <br>        return FALSE; <br>    } <br>    lpbmih-&gt;biHeight *= 2; <br>    CloseHandle( hFile ); <br>    return TRUE; <br>} <br>/* End WriteBMPFile() *******************************************************/ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
