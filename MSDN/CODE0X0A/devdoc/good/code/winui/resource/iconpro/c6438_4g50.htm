<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MDICHILD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6444"></a>MDICHILD.C</h2>
<pre><code>/****************************************************************************\ <br>*             <br>*     FILE:     MDIChild.C <br>* <br>*     PURPOSE:  IconPro Project MDI Child Window handling c file <br>* <br>*     COMMENTS: This file contains the MDI Child Window handling code <br>* <br>*     FUNCTIONS: <br>*      EXPORTS:  <br>*               IconChildWndProc   - Window Procedure for the MDI children <br>*      LOCALS: <br>*               Draw3DRect         - Draws a rectangle using 3D colors <br>*               EraseBackground    - Draws the MDI child's background <br>*               CreateChildren     - Creates MDI child's child windows <br>*               CreateChildListBox - Creates and shows a list box <br>*               AddFormatDlgProc   - Dialog Proc for AddFormat dialog <br>* <br>*     Copyright 1995 - 1998 Microsoft Corp. <br>* <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include "Icons.h" <br>#include "IconPro.h" <br>#include "Resource.h" <br>#include "MDIChild.H" <br> <br> <br>/****************************************************************************/ <br>// External Globals <br>extern HINSTANCE    hInst; <br>extern HWND        hWndMain, hMDIClientWnd; <br>/****************************************************************************/ <br> <br> <br>/****************************************************************************/ <br>// Prototypes for local functions <br>BOOL Draw3DRect( HDC hDC, RECT Rect, BOOL bSunken ); <br>void EraseBackground( HWND hWnd, HDC hDC ); <br>BOOL CreateChildren( HWND hWnd ); <br>HWND CreateChildListBox( HWND hWndParent, UINT ID, LPRECT lpRect ); <br>BOOL CALLBACK AddFormatDlgProc( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam ); <br>/****************************************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: IconChildWndProc <br>* <br>*     PURPOSE:  Window Procedure for MDI child window <br>* <br>*     PARAMS:   HWND hWnd     - This window handle <br>*               UINT Msg      - Which Message? <br>*               WPARAM wParam - message parameter <br>*               LPARAM lParam - message parameter <br>* <br>*     RETURNS:  LRESULT - depends on message <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>LRESULT CALLBACK IconChildWndProc( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>    // Which message is it? <br>    switch( Msg ) <br>    { <br>        // User pressed left mouse button <br>        // Should be re-generate the AND mask? <br>        case WM_LBUTTONDOWN: <br>        { <br>            LPCHILDWINDOWDATAlpcwd; <br> <br>            // Get the icon resource data aassociated with this window <br>            if( (lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA )) == NULL ) <br>                break; <br> <br>            // Do something only if the CNTRL key is pressed too <br>            if( MK_CONTROL &amp; wParam ) <br>            { <br>                POINTSpts = MAKEPOINTS(lParam); <br>                POINTpt; <br>                RECT    ImageRect; <br>                DWORDnIndex; <br> <br>                pt.x = pts.x; pt.y = pts.y; <br>                // Do we have some icon resource data? <br>                if( lpcwd-&gt;lpIR != NULL ) <br>                { <br>                    // Which image is selected right now? <br>                    if( (nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>                    { <br>                        // Where is it drawn <br>                        ImageRect = GetXORImageRect( lpcwd-&gt;XORRect, &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]) ); <br>                        // Is the mouse click in the image? <br>                        if( PtInRect( &amp;ImageRect, pt ) ) <br>                        { <br>                            HCURSORhOldCursor; <br> <br>                            // This might take a while :( <br>                            hOldCursor = SetCursor( LoadCursor(NULL,IDC_WAIT) ); <br>                            pt.x -= ImageRect.left; <br>                            pt.y -= ImageRect.top; <br>                            // generate the new AND mask <br>                            MakeNewANDMaskBasedOnPoint( &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]), pt ); <br>                            // force a redraw <br>                            InvalidateRect( hWnd, NULL, TRUE ); <br>                            //  Set changed flag <br>                            lpcwd-&gt;lpIR-&gt;bHasChanged = TRUE; <br>                            // finally, its over, put the cursor back <br>                            SetCursor( hOldCursor ); <br>                        } <br>                    } <br>                } <br>            } <br>        } <br>        break; // End WM_LBUTTONDOWN <br> <br>        // Time to say "Goodbye" <br>        case WM_CLOSE: <br>        { <br>            LPCHILDWINDOWDATAlpcwd; <br>            TCHARszWindowTitle[MAX_PATH]; <br> <br>            // Get the data associated with this window <br>            lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>            // Is there data associated with this window? <br>            if( lpcwd != NULL ) <br>            { <br>                // Does the data include an icon resource <br>                if( lpcwd-&gt;lpIR != NULL ) <br>                { <br>                    // Has the resource changed? <br>                    if( lpcwd-&gt;lpIR-&gt;bHasChanged ) <br>                    { <br>                        // Get the title for the message box <br>                        GetWindowText( hWnd, szWindowTitle, MAX_PATH ); <br>                        if( lstrlen( szWindowTitle ) &lt; 1 ) <br>                            lstrcpy( szWindowTitle, "UnKnown" ); <br>                        // User want to save changes? <br>                        switch( MessageBox( hWnd, "Icon has Changed, Save Changes?", szWindowTitle, MB_ICONSTOP | MB_YESNOCANCEL ) ) <br>                        { <br>                            case IDYES: <br>                                SendMessage( hWnd, WM_COMMAND, ID_FILE_SAVE, 0 ); <br>                                // Fall through to IDNO and kill window <br>                            case IDNO: <br>                                DefMDIChildProc( hWnd, Msg, wParam, lParam ); <br>                                return 0; <br>                            break; <br>                            case IDCANCEL: <br>                                return 1; <br>                            break; <br>                        } <br>                    } <br>                } <br>            } <br>            DefMDIChildProc( hWnd, Msg, wParam, lParam ); <br>            return 0; <br>        } <br>        break; // End WM_CLOSE <br> <br>        // We are being created <br>        case WM_CREATE: <br>        { <br>            LPCHILDWINDOWDATAlpcwd; <br> <br>            // Need new data for this new window <br>            lpcwd = malloc( sizeof( CHILDWINDOWDATA ) ); <br>            SetWindowLong( hWnd, GWL_USERDATA, (LONG)lpcwd ); <br>            lpcwd-&gt;lpIR = NULL; <br>            // If a resource was passed in, use it <br>            if( (LPVOID)lParam != NULL ) <br>                lpcwd-&gt;lpIR = (LPICONRESOURCE)(((MDICREATESTRUCT *)(((CREATESTRUCT *)lParam)-&gt;lpCreateParams))-&gt;lParam); <br>            // If no resource was passed in, do minimal initialization <br>            if( lpcwd-&gt;lpIR == NULL ) <br>            { <br>                lpcwd-&gt;lpIR = malloc(sizeof(ICONRESOURCE)); <br>                lstrcpy( lpcwd-&gt;lpIR-&gt;szOriginalICOFileName, "Untitled" ); <br>                lstrcpy( lpcwd-&gt;lpIR-&gt;szOriginalDLLFileName, "" ); <br>                lpcwd-&gt;lpIR-&gt;nNumImages = 0; <br>            } <br>            // Nothing has changed <br>            lpcwd-&gt;lpIR-&gt;bHasChanged = FALSE; <br>            // Create the list box, etc <br>            CreateChildren( hWnd ); <br>            return DefMDIChildProc( hWnd, Msg, wParam, lParam ); <br>        } <br>        break; // End WM_CREATE <br> <br>        // Won't let window get too small to show our main area <br>        case WM_GETMINMAXINFO: <br>        { <br>            LPMINMAXINFO    lpmmi = (LPMINMAXINFO)lParam; <br> <br>            lpmmi-&gt;ptMinTrackSize.x = WINDOW_WIDTH; <br>            lpmmi-&gt;ptMinTrackSize.y = WINDOW_HEIGHT; <br>            return 0; <br>        } <br>        break; // End WM_GETMINMAXINFO <br> <br>        // Yikes! We're being destroyed! <br>        case WM_DESTROY: <br>        { <br>            LPCHILDWINDOWDATAlpcwd; <br> <br>            // Get the data associated with this window  <br>            lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>            // Is there some? <br>            if( lpcwd != NULL ) <br>            { <br>                // Is there a resource? <br>                if( lpcwd-&gt;lpIR != NULL ) <br>                { <br>                    UINT i; <br> <br>                    // Free all the bits <br>                    for( i=0; i&lt; lpcwd-&gt;lpIR-&gt;nNumImages; i++ ) <br>                    { <br>                        if( lpcwd-&gt;lpIR-&gt;IconImages[i].lpBits != NULL ) <br>                            free( lpcwd-&gt;lpIR-&gt;IconImages[i].lpBits ); <br>                    } <br>                    free( lpcwd-&gt;lpIR ); <br>                } <br>                free( lpcwd ); <br>            } <br>            SetWindowLong( hWnd, GWL_USERDATA, 0 ); <br>        } <br>        break; // End WM_DESTROY <br> <br>        // Draw our background (white and black squares, etc) <br>        case WM_ERASEBKGND: <br>            EraseBackground( hWnd, (HDC)wParam ); <br>            return 1; <br>        break; // End WM_ERASEBKGND <br> <br>        // Ok, time to paint <br>        case WM_PAINT: <br>        { <br>            LPCHILDWINDOWDATAlpcwd; <br>            HDC                hDC; <br>            PAINTSTRUCT        ps; <br>            DWORD            nIndex; <br>            HICON            hIcon = NULL; <br> <br>            // Obligatory BeginPaint() <br>            hDC = BeginPaint( hWnd, &amp;ps ); <br>            // Get the data associated with this window <br>            lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>            // Is there some? <br>            if( lpcwd != NULL ) <br>            { <br>                // Is there a resource? <br>                if( lpcwd-&gt;lpIR != NULL ) <br>                { <br>                    // Which image is selected? <br>                    if( (nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>                    { <br>                        int        Width, Height; <br> <br>                        // Get an HICON for the currently selected image <br>                        hIcon = MakeIconFromResource( &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]) ); <br>                        // How big is the icon? <br>                        Width = lpcwd-&gt;lpIR-&gt;IconImages[nIndex].Width; <br>                        Height = lpcwd-&gt;lpIR-&gt;IconImages[nIndex].Height; <br>                        // Check to see if the icon is NULL <br>                        // If it is, consider it "unsupported" <br>                        // In the future, maybe we should look into MakeIconFromResource() and <br>                        // see why it is null - it may be for another reason than "unsupported" <br>                        if( hIcon == NULL ) <br>                        { <br>                            SIZE    Size, Position; <br> <br>                            // Draw some text in the black rect <br>                            SetTextColor( hDC, RGB(255,255,255) ); <br>                            GetTextExtentPoint32( hDC, "Unsupported", 11, &amp;Size ); <br>                            Position.cx = lpcwd-&gt;BlackRect.left + ((RectWidth(lpcwd-&gt;BlackRect)-Size.cx)/2); <br>                            Position.cy = lpcwd-&gt;BlackRect.top + (RectHeight(lpcwd-&gt;BlackRect)/2) - Size.cy; <br>                            TextOut( hDC, Position.cx, Position.cy, "Unsupported", 11 ); <br>                            GetTextExtentPoint32( hDC, "Format", 6, &amp;Size ); <br>                            Position.cx = lpcwd-&gt;BlackRect.left + ((RectWidth(lpcwd-&gt;BlackRect)-Size.cx)/2); <br>                            Position.cy = lpcwd-&gt;BlackRect.top + (RectHeight(lpcwd-&gt;BlackRect)/2) + 1; <br>                            TextOut( hDC, Position.cx, Position.cy, "Format", 6 ); <br> <br>                            // Draw some text in the white rect <br>                            SetTextColor( hDC, RGB(0,0,0) ); <br>                            GetTextExtentPoint32( hDC, "Unsupported", 11, &amp;Size ); <br>                            Position.cx = lpcwd-&gt;WhiteRect.left + ((RectWidth(lpcwd-&gt;WhiteRect)-Size.cx)/2); <br>                            Position.cy = lpcwd-&gt;WhiteRect.top + (RectHeight(lpcwd-&gt;WhiteRect)/2) - Size.cy; <br>                            TextOut( hDC, Position.cx, Position.cy, "Unsupported", 11 ); <br>                            GetTextExtentPoint32( hDC, "Format", 6, &amp;Size ); <br>                            Position.cx = lpcwd-&gt;WhiteRect.left + ((RectWidth(lpcwd-&gt;WhiteRect)-Size.cx)/2); <br>                            Position.cy = lpcwd-&gt;WhiteRect.top + (RectHeight(lpcwd-&gt;WhiteRect)/2) + 1; <br>                            TextOut( hDC, Position.cx, Position.cy, "Format", 6 ); <br>                        } <br>                        else <br>                        { <br>                            // Draw it on the black background <br>                            DrawIconEx( hDC, lpcwd-&gt;BlackRect.left + ((RectWidth(lpcwd-&gt;BlackRect)-Width)/2), <br>                                            lpcwd-&gt;BlackRect.top + ((RectHeight(lpcwd-&gt;BlackRect)-Height)/2),  <br>                                            hIcon, Width, Height, 0, NULL, DI_NORMAL ); <br>                            // Draw it on the white background <br>                            DrawIconEx( hDC, lpcwd-&gt;WhiteRect.left + ((RectWidth(lpcwd-&gt;WhiteRect)-Width)/2), <br>                                            lpcwd-&gt;WhiteRect.top + ((RectHeight(lpcwd-&gt;WhiteRect)-Height)/2),  <br>                                            hIcon, Width, Height, 0, NULL, DI_NORMAL ); <br>                        } <br>                        // Draw just the XOR mask <br>                        DrawXORMask( hDC, lpcwd-&gt;XORRect, &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]) ); <br>                        // Draw just the AND mask <br>                        DrawANDMask( hDC, lpcwd-&gt;ANDRect, &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]) ); <br>                        // Kill the icon, we're one with it <br>                        if( hIcon != NULL ) <br>                            DestroyIcon( hIcon ); <br>                    } <br>                } <br>            } <br>            // Obligtory EndPaint() <br>            EndPaint( hWnd, &amp;ps ); <br>        } <br>        break; // End WM_PAINT <br> <br>        // WM_COMMAND - menu options, etc <br>        case WM_COMMAND: <br>            // which one is it? <br>            switch( LOWORD(wParam) ) <br>            { <br>                // Edit-&gt;Export BMP - write icon image as BMP file <br>                case ID_EDIT_EXPORTBMP: <br>                { <br>                    LPCHILDWINDOWDATAlpcwd; <br>                    DWORD            nIndex; <br>                    TCHAR            szFileName[MAX_PATH]; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data, including an icon resource <br>                    if( (lpcwd != NULL ) &amp;&amp; (lpcwd-&gt;lpIR != NULL) &amp;&amp; (lpcwd-&gt;hWndFormatListBox!= NULL) ) <br>                    { <br>                        // Which image is currently selected? <br>                        if( (nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>                        { <br>                            // Get the name of the file from which to import the image <br>                            if( GetSaveIconFileName( szFileName, IDS_BMPFILTERSTRING, "Export to BMP File" ) ) <br>                            { <br>                                HCURSORhOldCursor; <br> <br>                                // This might take a while :( <br>                                hOldCursor = SetCursor( LoadCursor(NULL,IDC_WAIT) ); <br>                                IconImageToBMPFile( szFileName, &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]) ); <br>                                SetCursor( hOldCursor ); <br>                            } <br>                        } <br>                    } <br>                } <br>                break; // End ID_EDIT_EXPORTBMP <br> <br>                // Edit-&gt;Import BMP and Edit-&gt;Stretch-Import BMP - convert BMP file to icon <br>                case ID_EDIT_IMPORTBMP: <br>                case ID_EDIT_STRETCHIMPORTBMP: <br>                { <br>                    LPCHILDWINDOWDATAlpcwd; <br>                    DWORD            nIndex; <br>                    TCHAR            szFileName[MAX_PATH]; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data, including an icon resource <br>                    if( (lpcwd != NULL ) &amp;&amp; (lpcwd-&gt;lpIR != NULL) &amp;&amp; (lpcwd-&gt;hWndFormatListBox!= NULL) ) <br>                    { <br>                        // Which image is currently selected? <br>                        if( (nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>                        { <br>                            // Get the name of the file from which to import the image <br>                            if( GetOpenIconFileName( szFileName, IDS_BMPFILTERSTRING, "Import from BMP File" ) ) <br>                            { <br>                                HCURSORhOldCursor; <br> <br>                                // This might take a while :( <br>                                hOldCursor = SetCursor( LoadCursor(NULL,IDC_WAIT) ); <br>                                // Import the BMP image data <br>                                if( IconImageFromBMPFile( szFileName, &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]), (LOWORD(wParam)==ID_EDIT_STRETCHIMPORTBMP)?TRUE:FALSE ) ) <br>                                { <br>                                    // which, of course, changes things <br>                                    lpcwd-&gt;lpIR-&gt;bHasChanged = TRUE; <br>                                    // Force a repaint <br>                                    InvalidateRect( hWnd, NULL, TRUE ); <br>                                } <br>                                SetCursor( hOldCursor ); <br>                            } <br>                        } <br>                    } <br>                } <br>                break; // End ID_EDIT_IMPORTBMP/ID_EDIT_STRETCHIMPORTBMP <br> <br>                // User wants to add an image format <br>                case ID_EDIT_ADDFORMAT: <br>                { <br>                    LPICONIMAGElpii; <br>                    TCHARszBuffer[256]; <br>                     <br>                    // Launch the dialog to ask which size and color depth <br>                    if( DialogBoxParam( hInst, MAKEINTRESOURCE(IDD_ADDFORMATDLG), hWndMain, AddFormatDlgProc, (LPARAM)(&amp;lpii) ) ) <br>                    { <br>                        LPCHILDWINDOWDATAlpcwd; <br>                        LPICONRESOURCE    lpNewIR; <br>                        DWORD            nIndex, i; <br> <br>                        // Get the data associated this window  <br>                        lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                        // If we have some data, including an icon resource <br>                        if( (lpcwd != NULL ) &amp;&amp; (lpcwd-&gt;lpIR != NULL) &amp;&amp; (lpcwd-&gt;hWndFormatListBox!= NULL) ) <br>                        { <br>                            // Need to see if the new format already exists in the resource <br>                            // We don't want dupes, so check each image for dupe <br>                            for(i=0;i&lt;lpcwd-&gt;lpIR-&gt;nNumImages;i++) <br>                            { <br>                                // Is it the same as the new one? <br>                                if( (lpcwd-&gt;lpIR-&gt;IconImages[i].Width==lpii-&gt;Width) &amp;&amp; <br>                                    (lpcwd-&gt;lpIR-&gt;IconImages[i].Height==lpii-&gt;Height) &amp;&amp;  <br>                                    (lpcwd-&gt;lpIR-&gt;IconImages[i].Colors==lpii-&gt;Colors) ) <br>                                { <br>                                    // Yikes! It is - bail and select the old one <br>                                    MessageBox( hWnd, "That format already exists - format not added", "Error", MB_OK ); <br>                                    SendMessage( lpcwd-&gt;hWndFormatListBox, CB_SETCURSEL, (WPARAM)i, (LPARAM)0 ); <br>                                    break; <br>                                } <br>                            } <br>                            // Need bigger block of memory to hold an extra image format <br>                            lpNewIR = malloc( sizeof( ICONRESOURCE ) + ( ( lpcwd-&gt;lpIR-&gt;nNumImages + 1) * sizeof(ICONIMAGE) ) ); <br>                            // Of course this changes things <br>                            lpNewIR-&gt;bHasChanged = TRUE; <br>                            // Copy old to new <br>                            lstrcpy( lpNewIR-&gt;szOriginalICOFileName, lpcwd-&gt;lpIR-&gt;szOriginalICOFileName ); <br>                            lstrcpy( lpNewIR-&gt;szOriginalDLLFileName, lpcwd-&gt;lpIR-&gt;szOriginalDLLFileName ); <br>                            lpNewIR-&gt;nNumImages = lpcwd-&gt;lpIR-&gt;nNumImages + 1; <br>                            for(i=0;i&lt;lpcwd-&gt;lpIR-&gt;nNumImages;i++) <br>                            { <br>                                memcpy( &amp;(lpNewIR-&gt;IconImages[i]), &amp;(lpcwd-&gt;lpIR-&gt;IconImages[i]), sizeof( ICONIMAGE ) ); <br>                            } <br>                            // Add in the new one <br>                            memcpy( &amp;(lpNewIR-&gt;IconImages[i]), lpii, sizeof( ICONIMAGE ) ); <br>                            // Add this new one to the list box <br>                            wsprintf( szBuffer, "%dx%d, %d Bit Color", lpii-&gt;Width, lpii-&gt;Height, lpii-&gt;Colors ); <br>                            nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_ADDSTRING, 0, (LPARAM)szBuffer ); <br>                            // Select the new one <br>                            SendMessage( lpcwd-&gt;hWndFormatListBox, CB_SETCURSEL, (WPARAM)i, (LPARAM)0 ); <br>                            // clean up <br>                            free( lpii ); <br>                            free( lpcwd-&gt;lpIR ); <br>                            lpcwd-&gt;lpIR = lpNewIR; <br>                            // Create a nice new blank image for this format <br>                            CreateBlankNewFormatIcon( &amp;(lpcwd-&gt;lpIR-&gt;IconImages[i]) ); <br>                            // force a repaint <br>                            InvalidateRect( hWnd, NULL, TRUE ); <br>                        } <br>                    } <br>                } <br>                break; // End WM_COMMAND -&gt; ID_EDIT_ADDFORMAT <br>                 <br>                // User wants to remove an image format <br>                case ID_EDIT_REMOVEFORMAT: <br>                { <br>                    LPCHILDWINDOWDATAlpcwd; <br>                    DWORD            nIndex, i; <br>                    LPICONRESOURCE    lpNewIR; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data, including an icon resource <br>                    if( (lpcwd != NULL ) &amp;&amp; (lpcwd-&gt;lpIR != NULL) &amp;&amp; (lpcwd-&gt;hWndFormatListBox!= NULL) ) <br>                    { <br>                        // Which image is currently selected? <br>                        if( (nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>                        { <br>                            // Remove the entry from the list box <br>                            SendMessage( lpcwd-&gt;hWndFormatListBox, CB_DELETESTRING, nIndex, 0 ); <br>                            // Need less memory now <br>                            lpNewIR = malloc( sizeof( ICONRESOURCE ) + ( ( lpcwd-&gt;lpIR-&gt;nNumImages - 1) * sizeof(ICONIMAGE) ) ); <br>                            // Of course this changes things <br>                            lpNewIR-&gt;bHasChanged = TRUE; <br>                            // Copy old to new <br>                            lstrcpy( lpNewIR-&gt;szOriginalICOFileName, lpcwd-&gt;lpIR-&gt;szOriginalICOFileName ); <br>                            lstrcpy( lpNewIR-&gt;szOriginalDLLFileName, lpcwd-&gt;lpIR-&gt;szOriginalDLLFileName ); <br>                            lpNewIR-&gt;nNumImages = lpcwd-&gt;lpIR-&gt;nNumImages - 1; <br>                            // Copy the rest of the images from old to new <br>                            for(i=0;i&lt;nIndex;i++) <br>                            { <br>                                memcpy( &amp;(lpNewIR-&gt;IconImages[i]), &amp;(lpcwd-&gt;lpIR-&gt;IconImages[i]), sizeof( ICONIMAGE ) ); <br>                            } <br>                            for(;i&lt;lpcwd-&gt;lpIR-&gt;nNumImages-1;i++) <br>                            { <br>                                memcpy( &amp;(lpNewIR-&gt;IconImages[i]), &amp;(lpcwd-&gt;lpIR-&gt;IconImages[i+1]), sizeof( ICONIMAGE ) ); <br>                            } <br>                            // Clean up <br>                            free( lpcwd-&gt;lpIR ); <br>                            lpcwd-&gt;lpIR = lpNewIR; <br>                            // Select a different image <br>                            if( --nIndex &lt; 0 ) nIndex = 0; <br>                            SendMessage( lpcwd-&gt;hWndFormatListBox, CB_SETCURSEL, (WPARAM)nIndex, 0 ); <br>                            // Force a repaint <br>                            InvalidateRect( hWnd, NULL, TRUE ); <br>                        } <br>                    } <br>                } <br>                break; // End WM_COMMAND -&gt; ID_EDIT_REMOVEFORMAT <br> <br>                // User wants to paste CF_DIB from clipboard into current image <br>                case ID_EDIT_STRETCHPASTE: <br>                case ID_EDIT_PASTE: <br>                { <br>                    LPCHILDWINDOWDATAlpcwd; <br>                    DWORD            nIndex; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data, including an icon resource <br>                    if( (lpcwd != NULL ) &amp;&amp; (lpcwd-&gt;lpIR != NULL) &amp;&amp; (lpcwd-&gt;hWndFormatListBox!= NULL) ) <br>                    { <br>                        // Which image is currently selected? <br>                        if( (nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>                        { <br>                            HCURSORhOldCursor; <br> <br>                            // This might take a while :( <br>                            hOldCursor = SetCursor( LoadCursor(NULL,IDC_WAIT) ); <br> <br>                            // Paste over it from the clipboard <br>                            if( IconImageFromClipBoard( &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]), LOWORD(wParam)!=ID_EDIT_PASTE ) ) <br>                                // which, of course, changes things <br>                                lpcwd-&gt;lpIR-&gt;bHasChanged = TRUE; <br>                            // Force a repaint <br>                            InvalidateRect( hWnd, NULL, TRUE ); <br>                            SetCursor( hOldCursor ); <br>                        } <br>                    } <br>                } <br>                break; // End WM_COMMAND -&gt; ID_EDIT_STRETCHPASTE/ID_EDIT_PASTE <br> <br>                // Put current image on the clipboard in CF_DIB format <br>                case ID_EDIT_COPY: <br>                { <br>                    LPCHILDWINDOWDATAlpcwd; <br>                    DWORD            nIndex; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data, including an icon resource <br>                    if( (lpcwd != NULL ) &amp;&amp; (lpcwd-&gt;lpIR != NULL) &amp;&amp; (lpcwd-&gt;hWndFormatListBox!= NULL) ) <br>                    { <br>                        // Which image is currently selected? <br>                        if( (nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>                        { <br>                            // Send this image to the clipboard <br>                            IconImageToClipBoard( &amp;(lpcwd-&gt;lpIR-&gt;IconImages[nIndex]) ); <br>                        } <br>                    } <br>                } <br>                break; // End WM_COMMAND -&gt; ID_EDIT_COPY <br> <br>                // The filename has changed, update the window title <br>                case ID_UPDATETITLE: <br>                { <br>                    TCHARszFileTitle[MAX_PATH]; <br>                    LPCHILDWINDOWDATAlpcwd; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data <br>                    if( lpcwd != NULL ) <br>                    { <br>                        // including an icon resource <br>                        if( lpcwd-&gt;lpIR != NULL ) <br>                        { <br>                            // The calculate and set the new title <br>                            if( GetFileTitle( lpcwd-&gt;lpIR-&gt;szOriginalICOFileName, szFileTitle, MAX_PATH ) == 0 ) <br>                            { <br>                                SetWindowText( hWnd, szFileTitle ); <br>                            } <br>                        } <br>                    } <br>                } <br>                break; // End WM_COMMAND -&gt; ID_UPDATETITLE <br> <br>                // How many image formats in the icon resource? (return that number) <br>                case ID_GETNUMFORMATS: <br>                { <br>                    LPCHILDWINDOWDATAlpcwd; <br>                    UINT nNum = 0; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data <br>                    if( lpcwd != NULL ) <br>                    { <br>                        // If we have a listbox, get its count, else 0 <br>                        if( lpcwd-&gt;hWndFormatListBox != NULL ) <br>                            nNum = (UINT)SendMessage( lpcwd-&gt;hWndFormatListBox, CB_GETCOUNT, 0, 0 ); <br>                        else <br>                            nNum = 0; <br>                        // If an error occurred, default to 0 <br>                        if( nNum == (UINT)CB_ERR ) <br>                            nNum = 0; <br>                    } <br>                    // Send it back <br>                    return nNum; <br>                } <br>                break; // End WM_COMMAND -&gt; ID_GETNUMFORMATS </code></pre>
<p>
</p>
<pre><code><br>                // Has this icon resource changed? return TRUE=yes, FALSE=no <br>                case ID_HASFILECHANGED: <br>                { <br>                    LPCHILDWINDOWDATAlpcwd; <br>                    UINT nRet = 0; <br> <br>                    // Get the data associated this window  <br>                    lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ); <br>                    // If we have some data <br>                    if( lpcwd != NULL ) <br>                        // And it includes an icon resource <br>                        if( lpcwd-&gt;lpIR != NULL ) <br>                            // then check whether it has changed <br>                            return lpcwd-&gt;lpIR-&gt;bHasChanged == TRUE; <br>                    // Otherwise, return FALSE <br>                    return nRet; <br>                } <br>                break; // End WM_COMMAND -&gt; ID_HASFILECHANGED <br> <br>                // Handle selection changes, etc from listbox <br>                case ID_FORMAT_BOX: <br>                    switch( HIWORD(wParam) ) <br>                    { <br>                        // If a selection is made, or changes, repaint <br>                        case CBN_SELCHANGE: <br>                        case CBN_SELENDOK: <br>                            InvalidateRect( hWnd, NULL, TRUE ); <br>                        break; <br>                    } <br>                break; // End WM_COMMAND -&gt; ID_FORMAT_BOX <br>             <br>                // User wants to save the ICO file <br>                case ID_FILE_SAVEAS: <br>                case ID_FILE_SAVE: <br>                { <br>                    TCHARszFileName[MAX_PATH]; <br>                    LPCHILDWINDOWDATAlpcwd; <br> <br>                    // Get the data associated this window  <br>                    if( ( lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ) ) != NULL ) <br>                    { <br>                        // See if it includes an icon resource <br>                        if( lpcwd-&gt;lpIR != NULL ) <br>                        { <br>                            HCURSORhOldCursor; <br> <br>                            // This might take a while :( <br>                            hOldCursor = SetCursor( LoadCursor(NULL,IDC_WAIT) ); <br> <br>                            // If we have an original filename, and user did *NOT* 'Save As' <br>                            if( ( lstrlen(lpcwd-&gt;lpIR-&gt;szOriginalICOFileName) &gt; 0 ) &amp;&amp; (LOWORD(wParam)!=ID_FILE_SAVEAS) ) <br>                            { <br>                                // The just write it out <br>                                WriteIconToICOFile( lpcwd-&gt;lpIR, lpcwd-&gt;lpIR-&gt;szOriginalICOFileName ); <br>                                // which, of course, brings it up to date <br>                                lpcwd-&gt;lpIR-&gt;bHasChanged = FALSE; <br>                            } <br>                            else <br>                            { <br>                                // Either we have no name, or user hit 'Save As' <br>                                if( GetSaveIconFileName( szFileName, IDS_FILTERSTRING, LOWORD(wParam)==ID_FILE_SAVE?"Save Icon File":"Save Icon File As" ) ) <br>                                { <br>                                    // So, write it out <br>                                    WriteIconToICOFile( lpcwd-&gt;lpIR, szFileName ); <br>                                    // Update the name associated with the resource <br>                                    lstrcpy( lpcwd-&gt;lpIR-&gt;szOriginalICOFileName, szFileName ); <br>                                    // Inform window to update title <br>                                    SendMessage( hWnd, WM_COMMAND, ID_UPDATETITLE, 0 ); <br>                                    // and, of course, it is now up to date <br>                                    lpcwd-&gt;lpIR-&gt;bHasChanged = FALSE; <br>                                } <br>                            } <br>                            SetCursor( hOldCursor ); <br>                        } <br>                        else <br>                            MessageBox( hWnd, "Error Getting Icon Info - File Not Saved", "Error", MB_OK ); <br>                    } <br>                } <br>                break; // End WM_COMMAND -&gt; ID_FILE_SAVE/ID_FILE_SAVEAS <br>            } <br>        break; // End WM_COMMAND <br>    } <br>    return DefMDIChildProc( hWnd, Msg, wParam, lParam ); <br>} <br>/* End IconChildWndProc() **************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: Draw3DRect <br>* <br>*     PURPOSE:  draws a rectangle in 3d colors <br>* <br>*     PARAMS:   HDC hDC      - The DC on which to draw <br>*               RECT Rect    - The rectangle itself <br>*               BOOL bSunken - TRUE  = rect should look sunken <br>*                              FALSE = rect should look raised <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL Draw3DRect( HDC hDC, RECT Rect, BOOL bSunken ) <br>{ <br>    HBRUSHhBrush; <br>    HPEN    hPen, hOldPen; <br> <br>    // Get the color for the main foreground <br>    hBrush = CreateSolidBrush( GetSysColor(COLOR_3DFACE) ); <br>    // paint it <br>    FillRect( hDC, &amp;Rect, hBrush ); <br>    DeleteObject( hBrush ); <br>    // Get the pen for the top and left sides <br>    if( bSunken ) <br>        hPen = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW) ); <br>    else <br>        hPen = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT) ); <br>    hOldPen = SelectObject( hDC, hPen); <br>    // Draw the top and left sides <br>    MoveToEx( hDC, Rect.right, Rect.top, NULL ); <br>    LineTo( hDC, Rect.left, Rect.top ); <br>    LineTo( hDC, Rect.left, Rect.bottom ); <br>    SelectObject( hDC, hOldPen); <br>    DeleteObject( hPen ); <br>    // Get the pen for the bottom and right sides <br>    if( bSunken ) <br>        hPen = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT) ); <br>    else <br>        hPen = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW) ); <br>    hOldPen = SelectObject( hDC, hPen); <br>    // Draw the bottom and right sides <br>    LineTo( hDC, Rect.right, Rect.bottom ); <br>    LineTo( hDC, Rect.right, Rect.top ); <br>    SelectObject( hDC, hOldPen); <br>    DeleteObject( hPen ); <br>    return TRUE; <br>} <br>/* End Draw3DRect() *******************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: EraseBackground <br>* <br>*     PURPOSE:  Draws the background for the MDI child <br>* <br>*     PARAMS:   HWND hWnd - The MDI window of interest <br>*               HDC  hDC  - The DC on which to draw <br>* <br>*     RETURNS:  void <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>void EraseBackground( HWND hWnd, HDC hDC ) <br>{ <br>    RECT                Rect; <br>    LPCHILDWINDOWDATAlpcwd; <br>    HBRUSH            hBrush; <br>    SIZE                TextSize; <br> <br>    // Just how big is this window? <br>    GetClientRect( hWnd, &amp;Rect ); <br>    // Paint the background <br>    Draw3DRect( hDC, Rect, FALSE ); <br> <br>    // If there is no icon resource yet, bail out <br>    if( ( lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA ) ) == NULL ) <br>        return; <br>    // Draw 3d rectangles around areas of interest <br>    Draw3DRect( hDC, lpcwd-&gt;WhiteRect, TRUE ); <br>    Draw3DRect( hDC, lpcwd-&gt;WhiteTextRect, TRUE ); <br>    Draw3DRect( hDC, lpcwd-&gt;BlackRect, TRUE ); <br>    Draw3DRect( hDC, lpcwd-&gt;BlackTextRect, TRUE ); <br>    Draw3DRect( hDC, lpcwd-&gt;XORRect, TRUE ); <br>    Draw3DRect( hDC, lpcwd-&gt;XORTextRect, TRUE ); <br>    Draw3DRect( hDC, lpcwd-&gt;ANDRect, TRUE ); <br>    Draw3DRect( hDC, lpcwd-&gt;ANDTextRect, TRUE ); <br>    // Fill in the white area <br>    hBrush = GetStockObject( WHITE_BRUSH ); <br>    SelectObject( hDC, hBrush ); <br>    Rectangle( hDC, lpcwd-&gt;WhiteRect.left, lpcwd-&gt;WhiteRect.top, lpcwd-&gt;WhiteRect.right, lpcwd-&gt;WhiteRect.bottom ); <br>    // Fill in the black area <br>    hBrush = GetStockObject( BLACK_BRUSH ); <br>    SelectObject( hDC, hBrush ); <br>    Rectangle( hDC, lpcwd-&gt;BlackRect.left, lpcwd-&gt;BlackRect.top, lpcwd-&gt;BlackRect.right, lpcwd-&gt;BlackRect.bottom ); <br> <br>    // Set texts for the various sections <br>    SetBkMode( hDC, TRANSPARENT ); <br>    GetTextExtentPoint32( hDC, "Icon On Black", 13, &amp;TextSize ); <br>    TextOut( hDC, lpcwd-&gt;BlackTextRect.left + ((RectWidth(lpcwd-&gt;BlackTextRect)-TextSize.cx)/2), <br>                    lpcwd-&gt;BlackTextRect.top + ((RectHeight(lpcwd-&gt;BlackTextRect)-TextSize.cy)/2), "Icon On Black", 13 ); <br>    GetTextExtentPoint32( hDC, "Icon On White", 13, &amp;TextSize ); <br>    TextOut( hDC, lpcwd-&gt;WhiteTextRect.left + ((RectWidth(lpcwd-&gt;WhiteTextRect)-TextSize.cx)/2), <br>                    lpcwd-&gt;WhiteTextRect.top + ((RectHeight(lpcwd-&gt;WhiteTextRect)-TextSize.cy)/2), "Icon On White", 13 ); <br>    GetTextExtentPoint32( hDC, "XOR Mask", 8, &amp;TextSize ); <br>    TextOut( hDC, lpcwd-&gt;XORTextRect.left + ((RectWidth(lpcwd-&gt;XORTextRect)-TextSize.cx)/2), <br>                    lpcwd-&gt;XORTextRect.top + ((RectHeight(lpcwd-&gt;XORTextRect)-TextSize.cy)/2), "XOR Mask", 8 ); <br>    GetTextExtentPoint32( hDC, "AND Mask", 8, &amp;TextSize ); <br>    TextOut( hDC, lpcwd-&gt;ANDTextRect.left + ((RectWidth(lpcwd-&gt;ANDTextRect)-TextSize.cx)/2), <br>                    lpcwd-&gt;ANDTextRect.top + ((RectHeight(lpcwd-&gt;ANDTextRect)-TextSize.cy)/2), "AND Mask", 8 ); <br>} <br>/* End EraseBackground() ***************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: CreateChildren <br>* <br>*     PURPOSE:  Create the listbox, fills it with entries <br>* <br>*     PARAMS:   HWND hWnd - The MDI window of interest <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL CreateChildren( HWND hWnd ) <br>{ <br>    RECT                ClientRect, TempRect; <br>    LPCHILDWINDOWDATAlpcwd; <br>    HDC                hDC; <br>    SIZE                size; <br> <br>    // Get the data associated with this window <br>    if( (lpcwd = (LPCHILDWINDOWDATA)GetWindowLong( hWnd, GWL_USERDATA )) == NULL ) <br>        return FALSE; <br>    // Just how big is this window? <br>    GetClientRect( hWnd, &amp;ClientRect ); <br>    // Calculate listbox size and position <br>    SetRect( &amp;(lpcwd-&gt;BoxRect), 10, ClientRect.bottom-30, (MAX_ICON_WIDTH*2)+14, ClientRect.bottom+50 ); <br>    // Create the listbox <br>    if((lpcwd-&gt;hWndFormatListBox=CreateChildListBox( hWnd, ID_FORMAT_BOX, &amp;(lpcwd-&gt;BoxRect) )) == NULL ) <br>        return FALSE; <br>    // If we have an icon resource <br>    if( lpcwd-&gt;lpIR != NULL ) <br>    { <br>        UINT    i, nIndex; <br>        TCHARszBuffer[256]; <br> <br>        // For each image in the resoure <br>        for(i=0;i&lt;lpcwd-&gt;lpIR-&gt;nNumImages;i++) <br>        { <br>            // Add the type of the image to the listbox <br>            wsprintf( szBuffer, "%dx%d, %d Bit Color", lpcwd-&gt;lpIR-&gt;IconImages[i].Width,  <br>                        lpcwd-&gt;lpIR-&gt;IconImages[i].Height, lpcwd-&gt;lpIR-&gt;IconImages[i].Colors ); <br>            nIndex = SendMessage( lpcwd-&gt;hWndFormatListBox, CB_ADDSTRING, 0, (LPARAM)szBuffer ); <br>        } <br>        // Select the first entry <br>        SendMessage( lpcwd-&gt;hWndFormatListBox, CB_SETCURSEL, (WPARAM)0, (LPARAM)0 ); <br>    } <br>    // Adjust the box size based on the listbox's real size <br>    GetClientRect( lpcwd-&gt;hWndFormatListBox, &amp;TempRect ); <br>    lpcwd-&gt;BoxRect.bottom = lpcwd-&gt;BoxRect.top + TempRect.bottom; <br> <br>    // How big is text these days? <br>    hDC = GetDC( hWnd ); <br>    GetTextExtentPoint32( hDC, "Icon on Black", 13, &amp;size ); <br>    ReleaseDC( hWnd, hDC ); <br> <br>    // Set the rectangles for the various squares to be drawn later <br>#define DIVIDER 5 <br>    SetRect( &amp;(lpcwd-&gt;DrawingRect), 10, 10, (MAX_ICON_WIDTH*2)+14, 20 + (MAX_ICON_HEIGHT*2) + (TempRect.bottom*2) ); <br>    SetRect( &amp;(lpcwd-&gt;BlackRect), lpcwd-&gt;DrawingRect.left, lpcwd-&gt;DrawingRect.top, lpcwd-&gt;DrawingRect.left + MAX_ICON_WIDTH + 1, lpcwd-&gt;DrawingRect.top + MAX_ICON_HEIGHT + 1 ); <br>    SetRect( &amp;(lpcwd-&gt;BlackTextRect), lpcwd-&gt;BlackRect.left, lpcwd-&gt;BlackRect.bottom+1, lpcwd-&gt;BlackRect.right, lpcwd-&gt;BlackRect.bottom + TempRect.bottom + 1 ); <br>    SetRect( &amp;(lpcwd-&gt;WhiteRect), lpcwd-&gt;BlackRect.right+1, lpcwd-&gt;BlackRect.top, lpcwd-&gt;DrawingRect.right, lpcwd-&gt;BlackRect.bottom ); <br>    SetRect( &amp;(lpcwd-&gt;WhiteTextRect), lpcwd-&gt;WhiteRect.left, lpcwd-&gt;WhiteRect.bottom+1, lpcwd-&gt;WhiteRect.right, lpcwd-&gt;WhiteRect.bottom + TempRect.bottom + 1 ); <br>    SetRect( &amp;(lpcwd-&gt;XORRect),lpcwd-&gt;BlackTextRect.left, lpcwd-&gt;BlackTextRect.bottom + 1 + DIVIDER, lpcwd-&gt;BlackRect.right, lpcwd-&gt;BlackTextRect.bottom + 2 + DIVIDER + MAX_ICON_HEIGHT );  <br>    SetRect( &amp;(lpcwd-&gt;XORTextRect),lpcwd-&gt;XORRect.left, lpcwd-&gt;XORRect.bottom + 1, lpcwd-&gt;XORRect.right, lpcwd-&gt;DrawingRect.bottom );  <br>    SetRect( &amp;(lpcwd-&gt;ANDRect),lpcwd-&gt;WhiteTextRect.left, lpcwd-&gt;WhiteTextRect.bottom + 1 + DIVIDER, lpcwd-&gt;WhiteRect.right, lpcwd-&gt;WhiteTextRect.bottom + 2 + DIVIDER + MAX_ICON_HEIGHT );  <br>    SetRect( &amp;(lpcwd-&gt;ANDTextRect),lpcwd-&gt;ANDRect.left, lpcwd-&gt;ANDRect.bottom + 1, lpcwd-&gt;ANDRect.right, lpcwd-&gt;DrawingRect.bottom );  <br>#undef DIVIDER <br> <br>    return TRUE; <br>} <br>/* End CreateChildren() ****************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: CreateChildListBox <br>* <br>*     PURPOSE:  Creates a listbox and shows it <br>* <br>*     PARAMS:   HWND   hWndParent - The MDI window to be a parent <br>*               UINT   ID         - the ID of the new listbox <br>*               LPRECT lpRect     - the RECT for the listbox <br>* <br>*     RETURNS:  HWND - handle to listbox window, NULL for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>HWND CreateChildListBox( HWND hWndParent, UINT ID, LPRECT lpRect ) <br>{ <br>    HWND hWnd; <br> <br>    hWnd = CreateWindow( "COMBOBOX", "", CBS_DROPDOWNLIST | CBS_DISABLENOSCROLL | WS_CHILD | WS_VSCROLL, <br>                        lpRect-&gt;left, lpRect-&gt;top,  <br>                        lpRect-&gt;right - lpRect-&gt;left + 1, lpRect-&gt;bottom - lpRect-&gt;top + 1, <br>                        hWndParent, (HMENU)ID, hInst, 0 ); <br>    if( hWnd != NULL ) <br>        ShowWindow( hWnd, SW_SHOW ); <br>    return hWnd; <br>} <br>/* End CreateChildListBox() ************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: AddFormatDlgProc <br>* <br>*     PURPOSE:  Dialog Procedure for "Add Format" dialog <br>* <br>*     PARAMS:   HWND hWnd     - This dialog's window handle <br>*               UINT Msg      - Which Message? <br>*               WPARAM wParam - message parameter <br>*               LPARAM lParam - message parameter <br>* <br>*     RETURNS:  BOOL - TRUE for OK, FALSE for Cancel <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL CALLBACK AddFormatDlgProc( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>    // Support all DIB color formats known at this time <br>    #define MAX_COLOR_FORMAT    5 <br>    TCHARColorFormats[MAX_COLOR_FORMAT+1][20] = { "Monochrome (1bpp)", "16 Color (4bpp)", "256 Color (8bpp)", <br>                                    "16 Bit Color", "24 Bit Color", "32 Bit Color" }; <br>    UINT    Bits[MAX_COLOR_FORMAT+1] = { 1, 4, 8, 16, 24, 32 }; <br>    staticbSquareOnly = TRUE; <br>    staticLPARAM lInitParam; <br> <br> <br>    switch( Msg ) <br>    { <br>        // Dialog is being initialized <br>        case WM_INITDIALOG: <br>        { <br>            TCHARszBuffer[100]; <br> <br>            // We are passed a pointer to a LPICONIMAGE in lParam, save it <br>            lInitParam = lParam; <br>            // Set the range and position of the sliders <br>            SendDlgItemMessage( hWnd, ID_WIDTHSLIDER, TBM_SETRANGE, (WPARAM)TRUE, (LPARAM)MAKELONG(MIN_ICON_WIDTH,MAX_ICON_WIDTH) ); <br>            SendDlgItemMessage( hWnd, ID_WIDTHSLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)MIN_ICON_WIDTH ); <br>            wsprintf( szBuffer, "%d Width", MIN_ICON_WIDTH ); <br>            SetDlgItemText( hWnd, ID_WIDTHTEXT, szBuffer ); <br>            SendDlgItemMessage( hWnd, ID_HEIGHTSLIDER, TBM_SETRANGE, (WPARAM)TRUE, (LPARAM)MAKELONG(MIN_ICON_HEIGHT,MAX_ICON_HEIGHT) ); <br>            SendDlgItemMessage( hWnd, ID_HEIGHTSLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)MIN_ICON_HEIGHT ); <br>            wsprintf( szBuffer, "%d Height", MIN_ICON_HEIGHT ); <br>            SetDlgItemText( hWnd, ID_HEIGHTTEXT, szBuffer ); <br>            SendDlgItemMessage( hWnd, ID_COLORSLIDER, TBM_SETRANGE, (WPARAM)TRUE, (LPARAM)MAKELONG(0,MAX_COLOR_FORMAT) ); <br>            SendDlgItemMessage( hWnd, ID_COLORSLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)2); <br>            SetDlgItemText( hWnd, ID_COLORTEXT, ColorFormats[2] ); <br>            CheckDlgButton( hWnd, IDC_SQUAREONLY, bSquareOnly ); <br>        } <br>        break; // End WM_INITDIALOG <br> <br>        // Scroll message from the sliders <br>        case WM_HSCROLL: <br>        { <br>            intnPos; <br>            TCHARszBuffer[100]; <br> <br>            // Get the current position <br>            if( ( LOWORD(wParam) == TB_THUMBPOSITION ) || ( LOWORD(wParam) == TB_THUMBTRACK ) ) <br>                nPos = HIWORD( wParam ); <br>            else <br>                nPos = SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0 ); <br>            // Was it the width slider? <br>            if( (HWND)lParam == GetDlgItem( hWnd, ID_WIDTHSLIDER) ) <br>            { <br>                // Update the text <br>                wsprintf( szBuffer, "%d Width", nPos ); <br>                SetDlgItemText( hWnd, ID_WIDTHTEXT, szBuffer ); <br>                // If dealing with width=height, adjust height too <br>                if( bSquareOnly ) <br>                { <br>                    SendDlgItemMessage( hWnd, ID_HEIGHTSLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)nPos ); <br>                    wsprintf( szBuffer, "%d Height", nPos ); <br>                    SetDlgItemText( hWnd, ID_HEIGHTTEXT, szBuffer ); <br>                } <br>            } <br>            else <br>            { <br>                // Was it the height slider? <br>                if( (HWND)lParam == GetDlgItem( hWnd, ID_HEIGHTSLIDER) ) <br>                { <br>                    // Update the text <br>                    wsprintf( szBuffer, "%d Height", nPos ); <br>                    SetDlgItemText( hWnd, ID_HEIGHTTEXT, szBuffer ); <br>                    // If dealing with width=height, adjust width too <br>                    if( bSquareOnly ) <br>                    { <br>                        SendDlgItemMessage( hWnd, ID_WIDTHSLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)nPos ); <br>                        wsprintf( szBuffer, "%d Width", nPos ); <br>                        SetDlgItemText( hWnd, ID_WIDTHTEXT, szBuffer ); <br>                    } <br>                } <br>                else <br>                { <br>                    // Was it the color slider? <br>                    if( (HWND)lParam == GetDlgItem( hWnd, ID_COLORSLIDER) ) <br>                    { <br>                        // Update the text <br>                        SetDlgItemText( hWnd, ID_COLORTEXT, ColorFormats[nPos] ); <br>                    } <br>                } <br>            } <br>        } <br>        break; // End WM_HSCROLL <br> <br>        // Time to say 'goodbye' <br>        case WM_CLOSE: <br>            PostMessage( hWnd, WM_COMMAND, IDCANCEL, 0l ); <br>        break; // End WM_CLOSE <br> <br> <br>        // Messages from user items - checkboxes etc <br>        case WM_COMMAND: <br>            switch( LOWORD(wParam) ) <br>            { <br>                // Checkbox for width=height restriction <br>                case IDC_SQUAREONLY: <br>                    // Is it checked now? <br>                    bSquareOnly = IsDlgButtonChecked( hWnd, IDC_SQUAREONLY ); <br>                    // If it is, set height equal to width <br>                    if( bSquareOnly ) <br>                    { <br>                        int nPos; <br>                        TCHARszBuffer[100]; <br> <br>                        nPos = SendDlgItemMessage( hWnd, ID_WIDTHSLIDER, TBM_GETPOS, 0, 0 ); <br>                        SendDlgItemMessage( hWnd, ID_HEIGHTSLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)nPos ); <br>                        wsprintf( szBuffer, "%d Height", nPos ); <br>                        SetDlgItemText( hWnd, ID_HEIGHTTEXT, szBuffer ); <br>                    } <br>                break; // End IDC_SQUAREONLY <br> <br>                // Add Format button has been pressed <br>                case IDOK: <br>                { <br>                    LPICONIMAGElpii; <br> <br>                    // Were we passed a valid LPICONIMAGE pointer? <br>                    if( ((LPICONIMAGE)lInitParam) != NULL ) <br>                    { <br>                        // allocate the new ICONIMAGE <br>                        if( (lpii = malloc( sizeof( ICONIMAGE ) )) == FALSE ) <br>                            EndDialog( hWnd, FALSE ); <br>                        else <br>                        { <br>                            // initialize it <br>                            ZeroMemory( lpii, sizeof( ICONIMAGE ) ); <br>                            lpii-&gt;Width = SendDlgItemMessage( hWnd, ID_WIDTHSLIDER, TBM_GETPOS, 0, 0 ); <br>                            lpii-&gt;Height = SendDlgItemMessage( hWnd, ID_HEIGHTSLIDER, TBM_GETPOS, 0, 0 ); <br>                            lpii-&gt;Colors = Bits[SendDlgItemMessage( hWnd, ID_COLORSLIDER, TBM_GETPOS, 0, 0 )]; <br>                            // update the pointer that we were passed <br>                            *(LPICONIMAGE *)lInitParam = lpii; <br>                            // bail <br>                            EndDialog( hWnd, TRUE ); <br>                        } <br>                    } <br>                    else <br>                    { <br>                        // bail <br>                        EndDialog( hWnd, FALSE ); <br>                    } <br>                } <br>                break; // End IDOK <br> <br>                // Time to cancel <br>                case IDCANCEL: <br>                    EndDialog( hWnd, FALSE ); <br>                break; // End IDCANCEL <br> <br>            } <br>        break; <br>        default: <br>            return FALSE; <br>        break; <br>    } <br>    return TRUE; <br>    #undef MAX_COLOR_FORMAT <br>} <br>/* End AddFormatDlgProc() ************************************************/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
