<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICONS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6442"></a>ICONS.C</h2>
<pre><code>/****************************************************************************\ <br>*             <br>*     FILE:     ICONS.C <br>* <br>*     PURPOSE:  IconPro Project Icon handing Code C file <br>* <br>*     COMMENTS: This file contains the icon handling code <br>* <br>*     FUNCTIONS: <br>*      EXPORTS:  <br>*               ReadIconFromICOFile        - Reads Icon from ICO file <br>*               WriteIconToICOFile         - Writes Icon to ICO file <br>*               MakeIconFromResource       - Makes HICON from a resource <br>*               ReadIconFromEXEFile        - Reads Icon from a EXE or DLL file <br>*               IconImageToClipBoard       - Puts icon image on clipboard <br>*               IconImageFromClipBoard     - Gets icon image from clipboard <br>*               CreateBlankNewFormatIcon   - Makes a new, blank icon image <br>*               DrawXORMask                - Draws XOR mask using DIBs <br>*               DrawANDMask                - Draws AND mask using DIBs <br>*               GetXORImageRect            - Calculates XOR image position <br>*               MakeNewANDMaskBasedOnPoint - Calculates new AND mask <br>*               ConvertBMPFileToIcon       - Converts BMP to Icon <br>*               IconImageToBMPFile         - Writes an icon image to BMP file <br>*      LOCALS: <br>*               ReadICOHeader              - Reads ICO file header <br>*               AdjustIconImagePointers    - Adjusts internal pointers <br>*               ExtractDlgProc             - Dlg Proc for extract dialog <br>*               MyEnumProcedure            - For EnumResourceNames() <br>*               GetIconFromInstance        - Extracts Icon from Instance <br>*               ChooseIconFromEXEFile      - Gets a user's choice icon from file <br>*               WriteICOHeader             - Writes ICO file header <br>*               CalculateImageOffset       - Calcs offset in file of image <br>*               DIBToIconImage             - Converts DIB to icon image <br>* <br>*     Copyright 1995 - 1998 Microsoft Corp. <br>* <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>#include &lt;Windows.h&gt; <br>#include "Resource.h" <br>#include "IconPro.h" <br>#include "Icons.H" <br>#include "Dib.H" <br> <br> <br>/****************************************************************************/ <br>// Structs used locally (file scope) <br>// Resource Position info - size and offset of a resource in a file <br>typedef struct <br>{ <br>    DWORDdwBytes; <br>    DWORDdwOffset; <br>} RESOURCEPOSINFO, *LPRESOURCEPOSINFO; <br>// EXE/DLL icon information - filename, instance handle and ID <br>typedef struct <br>{ <br>    LPCTSTR    szFileName; <br>    HINSTANCEhInstance; <br>    LPTSTR    lpID; <br>} EXEDLLICONINFO, *LPEXEDLLICONINFO; <br>/****************************************************************************/ <br> <br> <br>/****************************************************************************/ <br>// External Globals <br>extern HINSTANCE    hInst; <br>extern HWND        hWndMain; <br>/****************************************************************************/ <br> <br>/****************************************************************************/ <br>// Prototypes for local functions <br>UINT ReadICOHeader( HANDLE hFile ); <br>BOOL AdjustIconImagePointers( LPICONIMAGE lpImage ); <br>BOOL CALLBACK ExtractDlgProc( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam ); <br>BOOL CALLBACK MyEnumProcedure( HANDLE  hModule, LPCTSTR  lpszType, LPTSTR  lpszName, LONG  lParam ); <br>HICON GetIconFromInstance( HINSTANCE hInstance, LPTSTR nIndex ); <br>LPTSTR ChooseIconFromEXEFile( LPEXEDLLICONINFO lpEDII ); <br>BOOL WriteICOHeader( HANDLE hFile, UINT nNumEntries ); <br>DWORD CalculateImageOffset( LPICONRESOURCE lpIR, UINT nIndex ); <br>BOOL DIBToIconImage( LPICONIMAGE lpii, LPBYTE lpDIB, BOOL bStretch ); <br>/****************************************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: MakeIconFromResource <br>* <br>*     PURPOSE:  Makes an HICON from an icon resource <br>* <br>*     PARAMS:   LPICONIMAGElpIcon - pointer to the icon resource <br>* <br>*     RETURNS:  HICON - handle to the new icon, NULL for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>HICON MakeIconFromResource( LPICONIMAGE lpIcon ) <br>{ <br>    HICON        hIcon = NULL; <br> <br>    // Sanity Check <br>    if( lpIcon == NULL ) <br>        return NULL; <br>    if( lpIcon-&gt;lpBits == NULL ) <br>        return NULL; <br>    // Let the OS do the real work :) <br>    hIcon = CreateIconFromResourceEx( lpIcon-&gt;lpBits, lpIcon-&gt;dwNumBytes, TRUE, 0x00030000,  <br>            (*(LPBITMAPINFOHEADER)(lpIcon-&gt;lpBits)).biWidth, (*(LPBITMAPINFOHEADER)(lpIcon-&gt;lpBits)).biHeight/2, 0 ); <br>     <br>    // It failed, odds are good we're on NT so try the non-Ex way <br>    if( hIcon == NULL ) <br>    { <br>        // We would break on NT if we try with a 16bpp image <br>        if(lpIcon-&gt;lpbi-&gt;bmiHeader.biBitCount != 16) <br>        { <br>            hIcon = CreateIconFromResource( lpIcon-&gt;lpBits, lpIcon-&gt;dwNumBytes, TRUE, 0x00030000 ); <br>        } <br>    } <br>    return hIcon; <br>} <br>/* End MakeIconFromResource() **********************************************/ <br> <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ReadIconFromICOFile <br>* <br>*     PURPOSE:  Reads an Icon Resource from an ICO file <br>* <br>*     PARAMS:   LPCTSTR szFileName - Name of the ICO file <br>* <br>*     RETURNS:  LPICONRESOURCE - pointer to the resource, NULL for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>LPICONRESOURCE ReadIconFromICOFile( LPCTSTR szFileName ) <br>{ <br>    LPICONRESOURCE    lpIR = NULL, lpNew = NULL; <br>    HANDLE            hFile = NULL; <br>    LPRESOURCEPOSINFOlpRPI = NULL; <br>    UINT                i; <br>    DWORD            dwBytesRead; <br>    LPICONDIRENTRY    lpIDE = NULL; <br> <br> <br>    // Open the file <br>    if( (hFile = CreateFile( szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE ) <br>    { <br>        MessageBox( hWndMain, "Error Opening File for Reading", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // Allocate memory for the resource structure <br>    if( (lpIR = malloc( sizeof(ICONRESOURCE) )) == NULL ) <br>    { <br>        MessageBox( hWndMain, "Error Allocating Memory", szFileName, MB_OK ); <br>        CloseHandle( hFile ); <br>        return NULL; <br>    } <br>    // Read in the header <br>    if( (lpIR-&gt;nNumImages = ReadICOHeader( hFile )) == (UINT)-1 ) <br>    { <br>        MessageBox( hWndMain, "Error Reading File Header", szFileName, MB_OK ); <br>        CloseHandle( hFile ); <br>        free( lpIR ); <br>        return NULL; <br>    } <br>    // Adjust the size of the struct to account for the images <br>    if( (lpNew = realloc( lpIR, sizeof(ICONRESOURCE) + ((lpIR-&gt;nNumImages-1) * sizeof(ICONIMAGE)) )) == NULL ) <br>    { <br>        MessageBox( hWndMain, "Error Allocating Memory", szFileName, MB_OK ); <br>        CloseHandle( hFile ); <br>        free( lpIR ); <br>        return NULL; <br>    } <br>    lpIR = lpNew; <br>    // Store the original name <br>    lstrcpy( lpIR-&gt;szOriginalICOFileName, szFileName ); <br>    lstrcpy( lpIR-&gt;szOriginalDLLFileName, "" ); <br>    // Allocate enough memory for the icon directory entries <br>    if( (lpIDE = malloc( lpIR-&gt;nNumImages * sizeof( ICONDIRENTRY ) ) ) == NULL ) <br>    { <br>        MessageBox( hWndMain, "Error Allocating Memory", szFileName, MB_OK ); <br>        CloseHandle( hFile ); <br>        free( lpIR ); <br>        return NULL; <br>    } <br>    // Read in the icon directory entries <br>    if( ! ReadFile( hFile, lpIDE, lpIR-&gt;nNumImages * sizeof( ICONDIRENTRY ), &amp;dwBytesRead, NULL ) ) <br>    { <br>        MessageBox( hWndMain, "Error Reading File", szFileName, MB_OK ); <br>        CloseHandle( hFile ); <br>        free( lpIR ); <br>        return NULL; <br>    } <br>    if( dwBytesRead != lpIR-&gt;nNumImages * sizeof( ICONDIRENTRY ) ) <br>    { <br>        MessageBox( hWndMain, "Error Reading File", szFileName, MB_OK ); <br>        CloseHandle( hFile ); <br>        free( lpIR ); <br>        return NULL; <br>    } <br>    // Loop through and read in each image <br>    for( i = 0; i &lt; lpIR-&gt;nNumImages; i++ ) <br>    { <br>        // Allocate memory for the resource <br>        if( (lpIR-&gt;IconImages[i].lpBits = malloc(lpIDE[i].dwBytesInRes)) == NULL ) <br>        { <br>            MessageBox( hWndMain, "Error Allocating Memory", szFileName, MB_OK ); <br>            CloseHandle( hFile ); <br>            free( lpIR ); <br>            free( lpIDE ); <br>            return NULL; <br>        } <br>        lpIR-&gt;IconImages[i].dwNumBytes = lpIDE[i].dwBytesInRes; <br>        // Seek to beginning of this image <br>        if( SetFilePointer( hFile, lpIDE[i].dwImageOffset, NULL, FILE_BEGIN ) == 0xFFFFFFFF ) <br>        { <br>            MessageBox( hWndMain, "Error Seeking in File", szFileName, MB_OK ); <br>            CloseHandle( hFile ); <br>            free( lpIR ); <br>            free( lpIDE ); <br>            return NULL; <br>        } <br>        // Read it in <br>        if( ! ReadFile( hFile, lpIR-&gt;IconImages[i].lpBits, lpIDE[i].dwBytesInRes, &amp;dwBytesRead, NULL ) ) <br>        { <br>            MessageBox( hWndMain, "Error Reading File", szFileName, MB_OK ); <br>            CloseHandle( hFile ); <br>            free( lpIR ); <br>            free( lpIDE ); <br>            return NULL; <br>        } <br>        if( dwBytesRead != lpIDE[i].dwBytesInRes ) <br>        { <br>            MessageBox( hWndMain, "Error Reading File", szFileName, MB_OK ); <br>            CloseHandle( hFile ); <br>            free( lpIDE ); <br>            free( lpIR ); <br>            return NULL; <br>        } <br>        // Set the internal pointers appropriately <br>        if( ! AdjustIconImagePointers( &amp;(lpIR-&gt;IconImages[i]) ) ) <br>        { <br>            MessageBox( hWndMain, "Error Converting to Internal Format", szFileName, MB_OK ); <br>            CloseHandle( hFile ); <br>            free( lpIDE ); <br>            free( lpIR ); <br>            return NULL; <br>        } <br>    } <br>    // Clean up <br>    free( lpIDE ); <br>    free( lpRPI ); <br>    CloseHandle( hFile ); <br>    return lpIR; <br>} <br>/* End ReadIconFromICOFile() **********************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: AdjustIconImagePointers <br>* <br>*     PURPOSE:  Adjusts internal pointers in icon resource struct <br>* <br>*     PARAMS:   LPICONIMAGE lpImage - the resource to handle <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL AdjustIconImagePointers( LPICONIMAGE lpImage ) <br>{ <br>    // Sanity check <br>    if( lpImage==NULL ) <br>        return FALSE; <br>    // BITMAPINFO is at beginning of bits <br>    lpImage-&gt;lpbi = (LPBITMAPINFO)lpImage-&gt;lpBits; <br>    // Width - simple enough <br>    lpImage-&gt;Width = lpImage-&gt;lpbi-&gt;bmiHeader.biWidth; <br>    // Icons are stored in funky format where height is doubled - account for it <br>    lpImage-&gt;Height = (lpImage-&gt;lpbi-&gt;bmiHeader.biHeight)/2; <br>    // How many colors? <br>    lpImage-&gt;Colors = lpImage-&gt;lpbi-&gt;bmiHeader.biPlanes * lpImage-&gt;lpbi-&gt;bmiHeader.biBitCount; <br>    // XOR bits follow the header and color table <br>    lpImage-&gt;lpXOR = FindDIBBits((LPSTR)lpImage-&gt;lpbi); <br>    // AND bits follow the XOR bits <br>    lpImage-&gt;lpAND = lpImage-&gt;lpXOR + (lpImage-&gt;Height*BytesPerLine((LPBITMAPINFOHEADER)(lpImage-&gt;lpbi))); <br>    return TRUE; <br>} <br>/* End AdjustIconImagePointers() *******************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ReadICOHeader <br>* <br>*     PURPOSE:  Reads the header from an ICO file <br>* <br>*     PARAMS:   HANDLE hFile - handle to the file <br>* <br>*     RETURNS:  UINT - Number of images in file, -1 for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>UINT ReadICOHeader( HANDLE hFile ) <br>{ <br>    WORD    Input; <br>    DWORDdwBytesRead; <br> <br>    // Read the 'reserved' WORD <br>    if( ! ReadFile( hFile, &amp;Input, sizeof( WORD ), &amp;dwBytesRead, NULL ) ) <br>        return (UINT)-1; <br>    // Did we get a WORD? <br>    if( dwBytesRead != sizeof( WORD ) ) <br>        return (UINT)-1; <br>    // Was it 'reserved' ?   (ie 0) <br>    if( Input != 0 ) <br>        return (UINT)-1; <br>    // Read the type WORD <br>    if( ! ReadFile( hFile, &amp;Input, sizeof( WORD ), &amp;dwBytesRead, NULL ) ) <br>        return (UINT)-1; <br>    // Did we get a WORD? <br>    if( dwBytesRead != sizeof( WORD ) ) <br>        return (UINT)-1; <br>    // Was it type 1? <br>    if( Input != 1 ) <br>        return (UINT)-1; <br>    // Get the count of images <br>    if( ! ReadFile( hFile, &amp;Input, sizeof( WORD ), &amp;dwBytesRead, NULL ) ) <br>        return (UINT)-1; <br>    // Did we get a WORD? <br>    if( dwBytesRead != sizeof( WORD ) ) <br>        return (UINT)-1; <br>    // Return the count <br>    return Input; <br>} <br>/* End ReadICOHeader() ****************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: MyEnumProcedure <br>* <br>*     PURPOSE:  Callback for enumerating resources in a DLL/EXE <br>* <br>*     PARAMS:   HANDLE  hModule  - Handle of the module <br>*               LPCTSTR lpszType - Resource Type <br>*               LPTSTR  lpszName - Resource Name <br>*               LONG    lParam   - Handle of ListBox to add name to <br>* <br>*     RETURNS:  BOOL - TRUE to continue, FALSE to stop <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL CALLBACK MyEnumProcedure( HANDLE  hModule, LPCTSTR  lpszType, LPTSTR  lpszName, LONG  lParam ) <br>{ <br>    TCHARszBuffer[256]; <br>    LONG    nIndex = LB_ERR; <br>    LPTSTRlpID = NULL; <br> <br>    // Name is from MAKEINTRESOURCE() <br>    if( HIWORD(lpszName) == 0 ) <br>    { <br>        wsprintf( szBuffer, "Icon [%d]", (DWORD)lpszName ); <br>        lpID = lpszName; <br>    } <br>    else <br>    { <br>        // Name is string <br>        lpID = strdup( lpszName ); <br>        wsprintf( szBuffer, "Icon [%s]", lpID ); <br>    } <br>    // Add it to the listbox <br>    nIndex = SendDlgItemMessage( (HWND)lParam, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)(szBuffer) ); <br>    // Set the item data to be the name of the resource so we can get it later <br>    SendDlgItemMessage( (HWND)lParam, IDC_LIST1, LB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)lpID ); <br>    return TRUE; <br>} <br>/* End MyEnumProcedure() ***************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: GetIconFromInstance <br>* <br>*     PURPOSE:  Callback for enumerating resources in a DLL/EXE <br>* <br>*     PARAMS:   HINSTANCE hInstance - Instance handle for this module <br>*               LPTSTR    nIndex    - Resource index <br>* <br>*     RETURNS:  HICON - Handle to the icon, NULL for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>HICON GetIconFromInstance( HINSTANCE hInstance, LPTSTR nIndex ) <br>{ <br>    HICONhIcon = NULL; <br>    HRSRChRsrc = NULL; <br>    HGLOBALhGlobal = NULL; <br>    LPVOIDlpRes = NULL; <br>    int    nID; <br> <br>    // Find the group icon <br>    if( (hRsrc = FindResource( hInstance, nIndex, RT_GROUP_ICON )) == NULL ) <br>        return NULL; <br>    if( (hGlobal = LoadResource( hInstance, hRsrc )) == NULL ) <br>        return NULL; <br>    if( (lpRes = LockResource(hGlobal)) == NULL ) <br>        return NULL; <br> <br>    // Find this particular image <br>    nID = LookupIconIdFromDirectory( lpRes, TRUE ); <br>    if( (hRsrc = FindResource( hInstance, MAKEINTRESOURCE(nID), RT_ICON )) == NULL ) <br>        return NULL; <br>    if( (hGlobal = LoadResource( hInstance, hRsrc )) == NULL ) <br>        return NULL; <br>    if( (lpRes = LockResource(hGlobal)) == NULL ) <br>        return NULL; <br>    // Let the OS make us an icon <br>    hIcon = CreateIconFromResource( lpRes, SizeofResource(hInstance,hRsrc), TRUE, 0x00030000 ); <br>    return hIcon; <br>} <br>/* End GetIconFromInstance() ***********************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ExtractDlgProc <br>* <br>*     PURPOSE:  Window Procedure for the Extract Dialog <br>* <br>*     PARAMS:   HWND hWnd     - This window handle <br>*               UINT Msg      - Which Message? <br>*               WPARAM wParam - message parameter <br>*               LPARAM lParam - message parameter <br>* <br>*     RETURNS:  BOOL - FALSE for cancel, TRUE for ok <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL CALLBACK ExtractDlgProc( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>    // Variable that holds info on this EXE/DLL <br>    static LPEXEDLLICONINFO lpEDII; <br> <br>    switch( Msg ) <br>    { <br>        // During Paint, we will draw the currently selected icon <br>        case WM_PAINT: <br>        { <br>            HDC                hDC; <br>            PAINTSTRUCT        ps; <br>            DWORD            nIndex; <br>            LPTSTR            lpIconID; <br> <br>            hDC = BeginPaint( hWnd, &amp;ps ); <br>            // Get the current selection <br>            if( (nIndex = SendDlgItemMessage( hWnd, IDC_LIST1, LB_GETCURSEL, 0, 0 )) != CB_ERR ) <br>            { <br>                // Get the data associated with the current selection - its the icon name <br>                if( (lpIconID = (LPTSTR)SendDlgItemMessage( hWnd, IDC_LIST1, LB_GETITEMDATA, nIndex, 0 )) != (LPTSTR)CB_ERR ) <br>                { <br>                    RECT        Rect, ButtonRect, DlgRect; <br>                    HWND        hWndButton; <br>                    HICON    hIcon; <br>                    ICONINFO    IconInfo; <br>                    BITMAP    bm; <br>                    POINT    UpperLeft, LowerRight; <br> <br>                    // Make an Icon <br>                    hIcon = GetIconFromInstance( lpEDII-&gt;hInstance, lpIconID ); <br>                    // Locate the icon <br>                    GetIconInfo( hIcon, &amp;IconInfo ); <br>                    GetObject( IconInfo.hbmColor, sizeof(BITMAP), &amp;bm ); <br>                    hWndButton = GetDlgItem( hWnd, IDCANCEL ); <br>                    GetWindowRect( hWndButton, &amp;ButtonRect ); <br>                    GetWindowRect( hWnd, &amp;DlgRect ); <br>                    UpperLeft.x = ButtonRect.left; <br>                    UpperLeft.y = ButtonRect.bottom; <br>                    LowerRight.x = ButtonRect.right; <br>                    LowerRight.y = DlgRect.bottom; <br>                    ScreenToClient( hWnd, &amp;UpperLeft ); <br>                    ScreenToClient( hWnd, &amp;LowerRight ); <br>                    SetRect( &amp;Rect, UpperLeft.x, UpperLeft.y, LowerRight.x, LowerRight.y ); <br>                    // Draw it <br>                    DrawIcon( hDC, Rect.left + ((Rect.right - Rect.left - bm.bmWidth)/2),  <br>                            Rect.top + ((Rect.bottom - Rect.top - bm.bmHeight)/2), hIcon ); <br>                    // Kill it <br>                    DestroyIcon( hIcon ); <br>                } <br>            } <br>            EndPaint( hWnd, &amp;ps ); <br>        } <br>        break; // End WM_PAINT <br> <br>        // Dialog is being initialized <br>        case WM_INITDIALOG: <br>        { <br>            UINT    nCount; <br>            TCHARszBuffer[MAX_PATH], szFileTitle[MAX_PATH]; <br> <br>            // Are we being sent data about an EXE/DLL? <br>            if( (lpEDII = (LPEXEDLLICONINFO)lParam) != NULL ) <br>            { <br>                // Set the title of the dialog to reflect the EXE/DLL filename <br>                GetFileTitle( lpEDII-&gt;szFileName, szFileTitle, MAX_PATH ); <br>                wsprintf( szBuffer, "Extract Icon [%s]", szFileTitle ); <br>                SetWindowText( hWnd, szBuffer ); <br>                // Fill in the listbox with the icons available <br>                if( ! EnumResourceNames( lpEDII-&gt;hInstance, RT_GROUP_ICON, MyEnumProcedure, (LPARAM)hWnd ) ) <br>                { <br>                    MessageBox( hWnd, "Error Enumerating Icons", "Error", MB_OK ); <br>                    PostMessage( hWnd, WM_CLOSE, 0, 0 ); <br>                } <br>                SendDlgItemMessage( hWnd, IDC_LIST1, LB_SETCURSEL, 0, 0 ); <br>                // If we have &lt;= 1, post an OK message <br>                if( (nCount = SendDlgItemMessage(hWnd, IDC_LIST1, LB_GETCOUNT, 0, 0)) == 1 ) <br>                { <br>                    PostMessage( hWnd, WM_COMMAND, IDOK, 0 ); <br>                } <br>                // If there were no icons, let the user know <br>                if( nCount == 0 ) <br>                { <br>                    MessageBox( hWnd, "No Icons in this File", "Error", MB_OK ); <br>                    PostMessage( hWnd, WM_CLOSE, 0, 0 ); <br>                } <br>            } <br>            return FALSE; <br>        } <br>        break; // End WM_INITDIALOG <br> <br>        // Shut 'er down <br>        case WM_CLOSE: <br>            PostMessage( hWnd, WM_COMMAND, IDCANCEL, 0l ); <br>        break; // End WM_CLOSE <br> <br>        // Children are sending messages <br>        case WM_COMMAND: <br>            switch( LOWORD(wParam) ) <br>            { <br>                // Its the listbox, just redraw the icon <br>                case IDC_LIST1: <br>                    switch( HIWORD(wParam) ) <br>                    { <br>                        case CBN_SELCHANGE: <br>                        case CBN_SELENDOK: <br>                            InvalidateRect( hWnd, NULL, TRUE ); <br>                        break; <br>                    } <br>                break; // End IDC_LIST1 <br> <br>                // User has chosen an icon, shut it down <br>                case IDOK: <br>                { <br>                    LONG nIndex; <br> <br>                    lpEDII-&gt;lpID = NULL; <br>                    if( (nIndex = SendDlgItemMessage( hWnd, IDC_LIST1, LB_GETCURSEL, 0, 0 )) != LB_ERR ) <br>                        lpEDII-&gt;lpID = (LPTSTR)SendDlgItemMessage( hWnd, IDC_LIST1, LB_GETITEMDATA, nIndex, 0 ); <br>                    EndDialog( hWnd, TRUE ); <br>                } <br>                break; // End IDOK <br> <br>                // BAIL! <br>                case IDCANCEL: <br>                    EndDialog( hWnd, FALSE ); <br>                break; // End IDCANCEL <br> <br>            } <br>        break; <br>        default: <br>            return FALSE; <br>        break; <br>    } <br>    return TRUE; <br>} <br>/* End ExtractDlgProc() ****************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ChooseIconFromEXEFile <br>* <br>*     PURPOSE:  Ask the user which icon he/she wants from the DLL/EXE <br>* <br>*     PARAMS:   LPEXEDLLICONINFO lpEDII - info on this DLL/EXE <br>* <br>*     RETURNS:  LPTSTR - pointer to the resource name <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>LPTSTR ChooseIconFromEXEFile( LPEXEDLLICONINFO lpEDII ) <br>{ <br>    // Just launch the dialog box and let it handle it <br>    if( DialogBoxParam( hInst, MAKEINTRESOURCE(IDD_EXTRACTDLG), hWndMain, ExtractDlgProc, (LPARAM)(lpEDII) ) ) <br>    { <br>        // User chose 'Ok' <br>        return lpEDII-&gt;lpID; <br>    } <br>    // User chose 'Cancel', or an error occurred, fail the call <br>    return NULL; <br>} <br>/* End ChooseIconFromEXEFile() **********************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ReadIconFromEXEFile <br>* <br>*     PURPOSE:  Load an Icon Resource from a DLL/EXE file <br>* <br>*     PARAMS:   LPCTSTR szFileName - name of DLL/EXE file <br>* <br>*     RETURNS:  LPICONRESOURCE - pointer to icon resource <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>LPICONRESOURCE ReadIconFromEXEFile( LPCTSTR szFileName ) <br>{ <br>    LPICONRESOURCE    lpIR = NULL, lpNew = NULL; <br>    HINSTANCE        hLibrary; <br>    LPTSTR            lpID; <br>    EXEDLLICONINFO    EDII; <br> <br>    // Load the DLL/EXE - NOTE: must be a 32bit EXE/DLL for this to work <br>    if( (hLibrary = LoadLibraryEx( szFileName, NULL, LOAD_LIBRARY_AS_DATAFILE )) == NULL ) <br>    { <br>        // Failed to load - abort <br>        MessageBox( hWndMain, "Error Loading File - Choose a 32bit DLL or EXE", szFileName, MB_OK ); <br>        return NULL; <br>    } <br>    // Store the info <br>    EDII.szFileName = szFileName; <br>    EDII.hInstance = hLibrary; <br>    // Ask the user, "Which Icon?" <br>    if( (lpID = ChooseIconFromEXEFile( &amp;EDII )) != NULL ) <br>    { <br>        HRSRC        hRsrc = NULL; <br>        HGLOBAL        hGlobal = NULL; <br>        LPMEMICONDIR    lpIcon = NULL; <br>        UINT            i; <br> <br>        // Find the group icon resource <br>        if( (hRsrc = FindResource( hLibrary, lpID, RT_GROUP_ICON )) == NULL ) <br>        { <br>            FreeLibrary( hLibrary ); <br>            return NULL; <br>        } <br>        if( (hGlobal = LoadResource( hLibrary, hRsrc )) == NULL ) <br>        { <br>            FreeLibrary( hLibrary ); <br>            return NULL; <br>        } <br>        if( (lpIcon = LockResource(hGlobal)) == NULL ) <br>        { <br>            FreeLibrary( hLibrary ); <br>            return NULL; <br>        } <br>        // Allocate enough memory for the images <br>        if( (lpIR = malloc( sizeof(ICONRESOURCE) + ((lpIcon-&gt;idCount-1) * sizeof(ICONIMAGE)) )) == NULL ) <br>        { <br>            MessageBox( hWndMain, "Error Allocating Memory", szFileName, MB_OK ); <br>            FreeLibrary( hLibrary ); <br>            return NULL; <br>        } <br>        // Fill in local struct members <br>        lpIR-&gt;nNumImages = lpIcon-&gt;idCount; <br>        lstrcpy( lpIR-&gt;szOriginalDLLFileName, szFileName ); <br>        lstrcpy( lpIR-&gt;szOriginalICOFileName, "" ); <br>        // Loop through the images <br>        for( i = 0; i &lt; lpIR-&gt;nNumImages; i++ ) <br>        { <br>            // Get the individual image <br>            if( (hRsrc = FindResource( hLibrary, MAKEINTRESOURCE(lpIcon-&gt;idEntries[i].nID), RT_ICON )) == NULL ) <br>            { <br>                free( lpIR ); <br>                FreeLibrary( hLibrary ); <br>                return NULL; <br>            } <br>            if( (hGlobal = LoadResource( hLibrary, hRsrc )) == NULL ) <br>            { <br>                free( lpIR ); <br>                FreeLibrary( hLibrary ); <br>                return NULL; <br>            } <br>            // Store a copy of the resource locally <br>            lpIR-&gt;IconImages[i].dwNumBytes = SizeofResource( hLibrary, hRsrc ); <br>            lpIR-&gt;IconImages[i].lpBits = malloc( lpIR-&gt;IconImages[i].dwNumBytes ); <br>            memcpy( lpIR-&gt;IconImages[i].lpBits, LockResource( hGlobal ), lpIR-&gt;IconImages[i].dwNumBytes ); <br>            // Adjust internal pointers <br>            if( ! AdjustIconImagePointers( &amp;(lpIR-&gt;IconImages[i]) ) ) <br>            { <br>                MessageBox( hWndMain, "Error Converting to Internal Format", szFileName, MB_OK ); <br>                free( lpIR ); <br>                FreeLibrary( hLibrary ); <br>                return NULL; <br>            } <br>        } <br>    } <br>    FreeLibrary( hLibrary ); <br>    return lpIR; <br>} <br>/* End ReadIconFromEXEFile() ************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: WriteICOHeader <br>* <br>*     PURPOSE:  Writes the header to an ICO file <br>* <br>*     PARAMS:   HANDLE hFile       - handle to the file <br>*               UINT   nNumEntries - Number of images in file <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL WriteICOHeader( HANDLE hFile, UINT nNumEntries ) <br>{ <br>    WORD    Output; <br>    DWORDdwBytesWritten; <br> <br>    // Write 'reserved' WORD <br>    Output = 0; <br>    if( ! WriteFile( hFile, &amp;Output, sizeof( WORD ), &amp;dwBytesWritten, NULL ) ) <br>        return FALSE; <br>    // Did we write a WORD? <br>    if( dwBytesWritten != sizeof( WORD ) ) <br>        return FALSE; <br>    // Write 'type' WORD (1) <br>    Output = 1; <br>    if( ! WriteFile( hFile, &amp;Output, sizeof( WORD ), &amp;dwBytesWritten, NULL ) ) <br>        return FALSE; <br>    // Did we write a WORD? <br>    if( dwBytesWritten != sizeof( WORD ) ) <br>        return FALSE; <br>    // Write Number of Entries <br>    Output = (WORD)nNumEntries; <br>    if( ! WriteFile( hFile, &amp;Output, sizeof( WORD ), &amp;dwBytesWritten, NULL ) ) <br>        return FALSE; <br>    // Did we write a WORD? <br>    if( dwBytesWritten != sizeof( WORD ) ) <br>        return FALSE; <br>    return TRUE; <br>} <br>/* End WriteICOHeader() ****************************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: CalculateImageOffset <br>* <br>*     PURPOSE:  Calculates the file offset for an icon image <br>* <br>*     PARAMS:   LPICONRESOURCE lpIR   - pointer to icon resource <br>*               UINT           nIndex - which image? <br>* <br>*     RETURNS:  DWORD - the file offset for that image <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>DWORD CalculateImageOffset( LPICONRESOURCE lpIR, UINT nIndex ) <br>{ <br>    DWORDdwSize; <br>    UINT    i; <br> <br>    // Calculate the ICO header size <br>    dwSize = 3 * sizeof(WORD); <br>    // Add the ICONDIRENTRY's <br>    dwSize += lpIR-&gt;nNumImages * sizeof(ICONDIRENTRY); <br>    // Add the sizes of the previous images <br>    for(i=0;i&lt;nIndex;i++) <br>        dwSize += lpIR-&gt;IconImages[i].dwNumBytes; <br>    // we're there - return the number <br>    return dwSize; <br>} <br>/* End CalculateImageOffset() ***********************************************/ </code></pre>
<p>
</p>
<pre><code><br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: WriteIconToICOFile <br>* <br>*     PURPOSE:  Writes the icon resource data to an ICO file <br>* <br>*     PARAMS:   LPICONRESOURCE lpIR       - pointer to icon resource <br>*               LPCTSTR        szFileName - name for the ICO file <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL WriteIconToICOFile( LPICONRESOURCE lpIR, LPCTSTR szFileName ) <br>{ <br>    HANDLE    hFile; <br>    UINT        i; <br>    DWORD    dwBytesWritten; <br> <br>    // open the file <br>    if( (hFile = CreateFile( szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE ) <br>    { <br>        MessageBox( hWndMain, "Error Opening File for Writing", szFileName, MB_OK ); <br>        return FALSE; <br>    } <br>    // Write the header <br>    if( ! WriteICOHeader( hFile, lpIR-&gt;nNumImages ) ) <br>    { <br>        MessageBox( hWndMain, "Error Writing ICO File", szFileName, MB_OK ); <br>        CloseHandle( hFile ); <br>        return FALSE; <br>    } <br>    // Write the ICONDIRENTRY's <br>    for( i=0; i&lt;lpIR-&gt;nNumImages; i++ ) <br>    { <br>        ICONDIRENTRY    ide; <br> <br>        // Convert internal format to ICONDIRENTRY <br>        ide.bWidth = lpIR-&gt;IconImages[i].Width; <br>        ide.bHeight = lpIR-&gt;IconImages[i].Height; <br>        ide.bReserved = 0; <br>        ide.wPlanes = lpIR-&gt;IconImages[i].lpbi-&gt;bmiHeader.biPlanes; <br>        ide.wBitCount = lpIR-&gt;IconImages[i].lpbi-&gt;bmiHeader.biBitCount; <br>        if( (ide.wPlanes * ide.wBitCount) &gt;= 8 ) <br>            ide.bColorCount = 0; <br>        else <br>            ide.bColorCount = 1 &lt;&lt; (ide.wPlanes * ide.wBitCount); <br>        ide.dwBytesInRes = lpIR-&gt;IconImages[i].dwNumBytes; <br>        ide.dwImageOffset = CalculateImageOffset( lpIR, i ); <br>        // Write the ICONDIRENTRY out to disk <br>        if( ! WriteFile( hFile, &amp;ide, sizeof( ICONDIRENTRY ), &amp;dwBytesWritten, NULL ) ) <br>            return FALSE; <br>        // Did we write a full ICONDIRENTRY ? <br>        if( dwBytesWritten != sizeof( ICONDIRENTRY ) ) <br>            return FALSE; <br>    } <br>    // Write the image bits for each image <br>    for( i=0; i&lt;lpIR-&gt;nNumImages; i++ ) <br>    { <br>        DWORD dwTemp = lpIR-&gt;IconImages[i].lpbi-&gt;bmiHeader.biSizeImage; <br> <br>        // Set the sizeimage member to zero <br>        lpIR-&gt;IconImages[i].lpbi-&gt;bmiHeader.biSizeImage = 0; <br>        // Write the image bits to file <br>        if( ! WriteFile( hFile, lpIR-&gt;IconImages[i].lpBits, lpIR-&gt;IconImages[i].dwNumBytes, &amp;dwBytesWritten, NULL ) ) <br>            return FALSE; <br>        if( dwBytesWritten != lpIR-&gt;IconImages[i].dwNumBytes ) <br>            return FALSE; <br>        // set it back <br>        lpIR-&gt;IconImages[i].lpbi-&gt;bmiHeader.biSizeImage = dwTemp; <br>    } <br>    CloseHandle( hFile ); <br>    return FALSE; <br>} <br>/* End WriteIconToICOFile() **************************************************/ <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: IconImageToClipBoard <br>* <br>*     PURPOSE:  Copies an icon image to the clipboard in CF_DIB format <br>* <br>*     PARAMS:   LPICONIMAGE lpii - pointer to icon image data <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL IconImageToClipBoard( LPICONIMAGE lpii ) <br>{ <br>    HANDLEhGlobal; <br>    LPSTRlpBits; <br> <br>    // Open the clipboard <br>    if( OpenClipboard( hWndMain ) ) <br>    { <br>        // empty it <br>        if( EmptyClipboard() ) <br>        { <br>            // Make a buffer to send to clipboard <br>            hGlobal = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE, lpii-&gt;dwNumBytes ); <br>            lpBits = GlobalLock( hGlobal ); <br>            // Copy the bits to the buffer <br>            memcpy( lpBits, lpii-&gt;lpBits, lpii-&gt;dwNumBytes ); <br>            // Adjust for funky height*2 thing <br>            ((LPBITMAPINFOHEADER)lpBits)-&gt;biHeight /= 2; <br>            GlobalUnlock( hGlobal ); <br>            // Send it to the clipboard <br>            SetClipboardData( CF_DIB, hGlobal ); <br>            CloseClipboard(); <br>            return TRUE; <br>        } <br>    } <br>    return FALSE; <br>} <br>/* End IconImageToClipBoard() ***********************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: IconImageFromClipBoard <br>* <br>*     PURPOSE:  Creates an icon image from the CF_DIB clipboard entry <br>* <br>*     PARAMS:   LPICONIMAGE lpii          - pointer to icon image data <br>*               BOOL        bStretchToFit - TRUE to stretch, FALSE to take <br>*                                           the upper left corner of the DIB <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL IconImageFromClipBoard( LPICONIMAGE lpii, BOOL bStretchToFit ) <br>{ <br>    LPBITMAPINFO    lpbi; <br>    HANDLE        hClipGlobal; <br>    BOOL            bRet = FALSE; <br> <br>    // Open the clipboard <br>    if( OpenClipboard( hWndMain ) ) <br>    { <br>        // Get the CF_DIB data from it <br>        if( (hClipGlobal = GetClipboardData( CF_DIB )) != NULL ) <br>        { <br>            // Lock it down <br>            if( (lpbi=GlobalLock(hClipGlobal)) != NULL ) <br>            { <br>                // Convert it to an icon image <br>                bRet = DIBToIconImage( lpii, (LPBYTE)lpbi, bStretchToFit ); <br>                GlobalUnlock( hClipGlobal ); <br>            } <br>        } <br>        CloseClipboard(); <br>    } <br>    return bRet; <br>} <br>/* End IconImageFromClipBoard() ********************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: DIBToIconImage <br>* <br>*     PURPOSE:  Converts a CF_DIB memory block to an icon image <br>* <br>*     PARAMS:   LPICONIMAGE lpii          - pointer to icon image data <br>*               LPBYTE      lpDIB         - a pointer to the CF_DIB block <br>*               BOOL        bStretchToFit - TRUE to stretch, FALSE to take <br>*                                           the upper left corner of the DIB <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL DIBToIconImage( LPICONIMAGE lpii, LPBYTE lpDIB, BOOL bStretch ) <br>{ <br>    LPBYTE    lpNewDIB; <br> <br>    // Sanity check <br>    if( lpDIB == NULL ) <br>        return FALSE; <br> <br>    // Let the DIB engine convert color depths if need be <br>    lpNewDIB = ConvertDIBFormat( (LPBITMAPINFO)lpDIB, lpii-&gt;Width, lpii-&gt;Height, lpii-&gt;Colors, bStretch ); <br> <br>    // Now we have a cool new DIB of the proper size/color depth <br>    // Lets poke it into our data structures and be done with it <br> <br>    // How big is it? <br>    lpii-&gt;dwNumBytes = sizeof( BITMAPINFOHEADER )                    // Header <br>                    + PaletteSize( (LPSTR)lpNewDIB )                    // Palette <br>                    + lpii-&gt;Height * BytesPerLine( (LPBITMAPINFOHEADER)lpNewDIB )// XOR mask <br>                    + lpii-&gt;Height * WIDTHBYTES( lpii-&gt;Width );        // AND mask <br> <br>    // If there was already an image here, free it <br>    if( lpii-&gt;lpBits != NULL ) <br>        free( lpii-&gt;lpBits ); <br>    // Allocate enough room for the new image <br>    if( (lpii-&gt;lpBits = malloc( lpii-&gt;dwNumBytes )) == NULL ) <br>    { <br>        free( lpii ); <br>        return FALSE; <br>    } <br>    // Copy the bits <br>    memcpy( lpii-&gt;lpBits, lpNewDIB, sizeof( BITMAPINFOHEADER ) + PaletteSize( (LPSTR)lpNewDIB ) ); <br>    // Adjust internal pointers/variables for new image <br>    lpii-&gt;lpbi = (LPBITMAPINFO)(lpii-&gt;lpBits); <br>    lpii-&gt;lpbi-&gt;bmiHeader.biHeight *= 2; <br>    lpii-&gt;lpXOR = FindDIBBits( (LPSTR)(lpii-&gt;lpBits) ); <br>    memcpy( lpii-&gt;lpXOR, FindDIBBits((LPSTR)lpNewDIB), lpii-&gt;Height * BytesPerLine( (LPBITMAPINFOHEADER)lpNewDIB ) ); <br>    lpii-&gt;lpAND = lpii-&gt;lpXOR + lpii-&gt;Height * BytesPerLine( (LPBITMAPINFOHEADER)lpNewDIB ); <br>    memset( lpii-&gt;lpAND, 0, lpii-&gt;Height * WIDTHBYTES( lpii-&gt;Width ) ); <br>    // Free the source <br>    free( lpNewDIB ); <br>    return TRUE; <br>} <br>/* End DIBToIconImage() ***************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: CreateBlankNewFormatIcon <br>* <br>*     PURPOSE:  Creates a blank icon image for a new format <br>* <br>*     PARAMS:   LPICONIMAGE lpii          - pointer to icon image data <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL CreateBlankNewFormatIcon( LPICONIMAGE lpii ) <br>{ <br>    DWORD            dwFinalSize; <br>    BITMAPINFOHEADER    bmih; <br> <br>    // Fill in the bitmap header <br>    ZeroMemory( &amp;bmih, sizeof( BITMAPINFOHEADER ) ); <br>    bmih.biSize = sizeof( BITMAPINFOHEADER ); <br>    bmih.biBitCount = lpii-&gt;Colors; <br>    bmih.biClrUsed = 0; <br>     <br>    // How big will the final thing be? <br>    // Well, it'll have a header <br>    dwFinalSize = sizeof( BITMAPINFOHEADER ); <br>    // and a color table (even if it's zero length) <br>    dwFinalSize += PaletteSize( (LPSTR)&amp;bmih ); <br>    // and XOR bits <br>    dwFinalSize += lpii-&gt;Height * WIDTHBYTES( lpii-&gt;Width * lpii-&gt;Colors ); <br>    // and AND bits. That's about it :) <br>    dwFinalSize += lpii-&gt;Height * WIDTHBYTES( lpii-&gt;Width ); <br> <br>    // Allocate some memory for it <br>    lpii-&gt;lpBits = malloc( dwFinalSize ); <br>    ZeroMemory( lpii-&gt;lpBits, dwFinalSize ); <br>    lpii-&gt;dwNumBytes = dwFinalSize; <br>    lpii-&gt;lpbi = (LPBITMAPINFO)(lpii-&gt;lpBits); <br>    lpii-&gt;lpXOR = (LPSTR)(lpii-&gt;lpbi) + sizeof(BITMAPINFOHEADER) + PaletteSize( (LPSTR)&amp;bmih ); <br>    lpii-&gt;lpAND = lpii-&gt;lpXOR + (lpii-&gt;Height * WIDTHBYTES( lpii-&gt;Width * lpii-&gt;Colors )); <br> <br>    // The bitmap header is zeros, fill it out <br>    lpii-&gt;lpbi-&gt;bmiHeader.biSize = sizeof( BITMAPINFOHEADER );  <br>    lpii-&gt;lpbi-&gt;bmiHeader.biWidth = lpii-&gt;Width; <br>    // Don't forget the funky height*2 icon resource thing <br>    lpii-&gt;lpbi-&gt;bmiHeader.biHeight = lpii-&gt;Height * 2;  <br>    lpii-&gt;lpbi-&gt;bmiHeader.biPlanes = 1;  <br>    lpii-&gt;lpbi-&gt;bmiHeader.biBitCount = lpii-&gt;Colors;  <br>    lpii-&gt;lpbi-&gt;bmiHeader.biCompression = BI_RGB;  <br>                    <br>    return TRUE; <br>} <br>/* End CreateBlankNewFormatIcon() ******************************************/ <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: GetXORImageRect <br>* <br>*     PURPOSE:  Given a bounding Rect, calculates the XOR mask display Rect  <br>* <br>*     PARAMS:   RECT        Rect   - Bounding rect for drawing area <br>*               LPICONIMAGE lpIcon - pointer to icon image data <br>* <br>*     RETURNS:  RECT - the rect where the XOR image will be drawn <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>RECT GetXORImageRect( RECT Rect, LPICONIMAGE lpIcon ) <br>{ <br>    RECT    NewRect; <br> <br>    // Just center the thing in the bounding display rect <br>    NewRect.left = Rect.left + ((RectWidth(Rect)-lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth)/2); <br>    NewRect.top = Rect.top + ((RectHeight(Rect)-(lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight/2))/2); <br>    NewRect.bottom = NewRect.top + (lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight/2); <br>    NewRect.right = NewRect.left + lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth; <br>    return NewRect; <br>} <br>/* End GetXORImageRect() ***************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: DrawXORMask <br>* <br>*     PURPOSE:  Using DIB functions, draw XOR mask on hDC in Rect <br>* <br>*     PARAMS:   HDC         hDC    - The DC on which to draw <br>*               RECT        Rect   - Bounding rect for drawing area <br>*               LPICONIMAGE lpIcon - pointer to icon image data <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>*     COMMENTS: Does not use any palette information since the <br>*               OS won't when it draws the icon anyway. <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL DrawXORMask( HDC hDC, RECT Rect, LPICONIMAGE lpIcon ) <br>{ <br>    int            x, y; <br> <br>    // Sanity checks <br>    if( lpIcon == NULL ) <br>        return FALSE; <br>    if( lpIcon-&gt;lpBits == NULL ) <br>        return FALSE; <br> <br>    // Account for height*2 thing <br>    lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight /= 2; <br> <br>    // Locate it <br>    x = Rect.left + ((RectWidth(Rect)-lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth)/2); <br>    y = Rect.top + ((RectHeight(Rect)-lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight)/2); <br> <br>    // Blast it to the screen <br>    SetDIBitsToDevice( hDC, x, y, lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth, lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight, 0, 0, 0, lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight, lpIcon-&gt;lpXOR, lpIcon-&gt;lpbi, DIB_RGB_COLORS ); <br> <br>    // UnAccount for height*2 thing <br>    lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight *= 2; <br> <br>    return TRUE; <br>} <br>/* End DrawXORMask() *******************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: DrawANDMask <br>* <br>*     PURPOSE:  Using DIB functions, draw AND mask on hDC in Rect <br>* <br>*     PARAMS:   HDC         hDC    - The DC on which to draw <br>*               RECT        Rect   - Bounding rect for drawing area <br>*               LPICONIMAGE lpIcon - pointer to icon image data <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL DrawANDMask( HDC hDC, RECT Rect, LPICONIMAGE lpIcon ) <br>{ <br>    LPBITMAPINFO    lpbi; <br>    int            x, y; <br> <br>    // Sanity checks <br>    if( lpIcon == NULL ) <br>        return FALSE; <br>    if( lpIcon-&gt;lpBits == NULL ) <br>        return FALSE; <br> <br>    // Need a bitmap header for the mono mask <br>    lpbi = malloc( sizeof(BITMAPINFO) + (2 * sizeof( RGBQUAD )) ); <br>    lpbi-&gt;bmiHeader.biSize = sizeof( BITMAPINFOHEADER ); <br>    lpbi-&gt;bmiHeader.biWidth = lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth; <br>    lpbi-&gt;bmiHeader.biHeight = lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight/2; <br>    lpbi-&gt;bmiHeader.biPlanes = 1; <br>    lpbi-&gt;bmiHeader.biBitCount = 1; <br>    lpbi-&gt;bmiHeader.biCompression = BI_RGB; <br>    lpbi-&gt;bmiHeader.biSizeImage = 0; <br>    lpbi-&gt;bmiHeader.biXPelsPerMeter = 0; <br>    lpbi-&gt;bmiHeader.biYPelsPerMeter = 0; <br>    lpbi-&gt;bmiHeader.biClrUsed = 0; <br>    lpbi-&gt;bmiHeader.biClrImportant = 0; <br>    lpbi-&gt;bmiColors[0].rgbRed = 0; <br>    lpbi-&gt;bmiColors[0].rgbGreen = 0; <br>    lpbi-&gt;bmiColors[0].rgbBlue = 0; <br>    lpbi-&gt;bmiColors[0].rgbReserved = 0; <br>    lpbi-&gt;bmiColors[1].rgbRed = 255; <br>    lpbi-&gt;bmiColors[1].rgbGreen = 255; <br>    lpbi-&gt;bmiColors[1].rgbBlue = 255; <br>    lpbi-&gt;bmiColors[1].rgbReserved = 0; <br> <br>    // Locate it <br>    x = Rect.left + ((RectWidth(Rect)-lpbi-&gt;bmiHeader.biWidth)/2); <br>    y = Rect.top + ((RectHeight(Rect)-lpbi-&gt;bmiHeader.biHeight)/2); <br> <br>    // Blast it to the screen <br>    SetDIBitsToDevice( hDC, x, y, lpbi-&gt;bmiHeader.biWidth, lpbi-&gt;bmiHeader.biHeight, 0, 0, 0, lpbi-&gt;bmiHeader.biHeight, lpIcon-&gt;lpAND, lpbi, DIB_RGB_COLORS ); <br> <br>    // clean up <br>    free( lpbi ); <br> <br>    return TRUE; <br>} <br>/* End DrawANDMask() *******************************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: MakeNewANDMaskBasedOnPoint <br>* <br>*     PURPOSE:  Creates a new AND mask for the icon image <br>* <br>*     PARAMS:   LPICONIMAGE lpIcon - pointer to icon image data <br>*               POINT       pt     - coords of transparent pixel <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>*     COMMENTS: Creates the AND mask using the color of the pixel at pt <br>*               as a transparent color. The XOR mask is changed as well. <br>*               This is because the OS expects the XOR mask to have the <br>*               AND mask already applied (ie black in transparent areas) <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL MakeNewANDMaskBasedOnPoint( LPICONIMAGE lpIcon, POINT pt ) <br>{ <br>    HBITMAP        hXORBitmap, hOldXORBitmap; <br>    HDC            hDC, hMemDC1; <br>    LPBYTE        pXORBits; <br>    COLORREF        crTransparentColor; <br>    LONG            i,j; <br> <br> <br>    // Account for height*2 thing <br>    lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight /= 2; <br> <br>    // Need a DC <br>    hDC = GetDC( NULL ); <br> <br>    // Use DIBSection for source <br>    hXORBitmap = CreateDIBSection( hDC, lpIcon-&gt;lpbi, DIB_RGB_COLORS, &amp;pXORBits, NULL, 0  ); <br>    memcpy( pXORBits, lpIcon-&gt;lpXOR, (lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight) * BytesPerLine((LPBITMAPINFOHEADER)(lpIcon-&gt;lpbi)) ); <br>    hMemDC1 = CreateCompatibleDC( hDC ); <br>    hOldXORBitmap = SelectObject( hMemDC1, hXORBitmap ); <br> <br>    // Set the color table if need be <br>    if( lpIcon-&gt;lpbi-&gt;bmiHeader.biBitCount &lt;= 8 ) <br>        SetDIBColorTable( hMemDC1, 0, DIBNumColors((LPSTR)(lpIcon-&gt;lpbi)), lpIcon-&gt;lpbi-&gt;bmiColors); <br>     <br>    // What's the transparent color? <br>    crTransparentColor = GetPixel( hMemDC1, pt.x, pt.y ); <br> <br>    // Loop through the pixels <br>    for(i=0;i&lt;lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth;i++) <br>    { <br>        for(j=0;j&lt;lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight;j++) <br>        { <br>            // Is the source transparent at this point? <br>            if( GetPixel( hMemDC1, i, j ) == crTransparentColor ) <br>            { <br>                // Yes, so set the pixel in AND mask, and clear it in XOR mask <br>                SetMonoDIBPixel( lpIcon-&gt;lpAND, lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth, lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight, i, j, TRUE );      <br>                if( lpIcon-&gt;lpbi-&gt;bmiHeader.biBitCount == 1 ) <br>                    SetMonoDIBPixel( pXORBits, lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth, lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight, i, j, FALSE );      <br>                else <br>                    SetPixelV( hMemDC1, i, j, RGB(0,0,0) ); <br>            } <br>            else <br>            { <br>                // No, so clear pixel in AND mask <br>                SetMonoDIBPixel( lpIcon-&gt;lpAND, lpIcon-&gt;lpbi-&gt;bmiHeader.biWidth, lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight, i, j, FALSE );     <br>            } <br>        } <br>    } <br>    // Flush the SetPixelV() calls <br>    GdiFlush(); <br> <br>    SelectObject( hMemDC1, hOldXORBitmap ); <br> <br>    // Copy the new XOR bits back to our storage <br>    memcpy( lpIcon-&gt;lpXOR, pXORBits, (lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight) * BytesPerLine((LPBITMAPINFOHEADER)(lpIcon-&gt;lpbi)) ); <br> <br>    // Clean up <br>    DeleteObject( hXORBitmap ); <br>    DeleteDC( hMemDC1 ); <br>    ReleaseDC( NULL, hDC ); <br> <br> <br>    // UnAccount for height*2 thing <br>    lpIcon-&gt;lpbi-&gt;bmiHeader.biHeight *= 2; <br>    return TRUE; <br>} <br>/* End MakeNewANDMaskBasedOnPoint() *****************************************/ <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: IconImageFromBMPFile <br>* <br>*     PURPOSE:  Creates an icon image from a BMP file <br>* <br>*     PARAMS:   LPCTSTR     szFileName    - Filename for BMP file <br>*               LPICONIMAGE lpii          - pointer to icon image data <br>*               BOOL        bStretchToFit - TRUE to stretch, FALSE to take <br>*                                           the upper left corner of the DIB <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL IconImageFromBMPFile( LPCTSTR szFileName, LPICONIMAGE lpii, BOOL bStretchToFit ) <br>{ <br>    LPBYTE        lpDIB = NULL; <br>    BOOL            bRet = FALSE; <br> <br>    if( (lpDIB=ReadBMPFile(szFileName)) == NULL ) <br>        return FALSE; <br>    // Convert it to an icon image <br>    bRet = DIBToIconImage( lpii, lpDIB, bStretchToFit ); <br>    free( lpDIB ); <br>    return bRet; <br>} <br>/* End IconImageFromBMPFile() ********************************************/ <br> <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: IconImageToBMPFile <br>* <br>*     PURPOSE:  Creates BMP file from an icon image <br>* <br>*     PARAMS:   LPCTSTR     szFileName    - Filename for BMP file <br>*               LPICONIMAGE lpii          - pointer to icon image data <br>* <br>*     RETURNS:  BOOL - TRUE for success, FALSE for failure <br>* <br>* History: <br>*                July '95 - Created <br>* <br>\****************************************************************************/ <br>BOOL IconImageToBMPFile( LPCTSTR szFileName, LPICONIMAGE lpii ) <br>{ <br>    return WriteBMPFile( szFileName, (LPBYTE)lpii-&gt;lpbi ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
