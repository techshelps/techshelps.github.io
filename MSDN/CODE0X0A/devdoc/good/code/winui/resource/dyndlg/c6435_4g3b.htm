<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DYNDLG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6437"></a>DYNDLG.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "dyndlg.h" <br> <br>LRESULT APIENTRY MainWndProc(HWND, UINT, UINT, LONG); <br>LRESULT APIENTRY About(HWND, UINT, WPARAM, LPARAM ); <br> <br>int Create1(HWND); <br>int Create2(HWND); <br> <br>LPWORD lpwAlign (LPWORD); <br>int nCopyAnsiToWideChar (LPWORD, LPSTR); <br> <br>HINSTANCE ghInst; <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  WinMain() <br>* <br>*  input parameters:  c.f. generic sample <br>* <br>\**************************************************************************/ <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                     LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    HWND   hwnd; <br>    MSG    msg; <br>    HANDLE hLibrary; <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br>    ghInst = hInstance; <br> <br>    /* Check for previous instance.  If none, then register class. */ <br>    if (!hPrevInstance) { <br>        WNDCLASS  wc; <br> <br>        wc.style = 0; <br>        wc.lpfnWndProc = (WNDPROC)MainWndProc; <br> <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = hInstance; <br>        wc.hIcon = LoadIcon(hInstance, TEXT("dyndlgIcon")); <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(LTGRAY_BRUSH); <br>        wc.lpszMenuName = TEXT("dyndlgMenu"); <br>        wc.lpszClassName = TEXT("dyndlg"); <br> <br>        if (!RegisterClass(&amp;wc)) return (FALSE); <br>    }  /* class registered o.k. */ <br> <br> <br>    /* Create the main window.  Return false if CreateWindow() fails */ <br>    hwnd = CreateWindow( <br>        TEXT("dyndlg"), <br>        TEXT("DynDlg"), <br>        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_VISIBLE, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL); <br> <br>    if (!hwnd) return (FALSE); <br> <br> <br>    /***** CUSTOM CONTROL <br>    * Load the DLL containing the custom control. <br>    *****/ <br>    hLibrary = LoadLibrary (TEXT("..\\spincube\\SPINCUBE.DLL")); <br>    if (hLibrary == NULL) <br>      if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) <br>        MessageBox (hwnd, TEXT("LoadLibrary (..\\spincube\\SPINCUBE.DLL)      s         B"), <br>                  TEXT(" G   [,      A v   P [ V       spincube    K v    "), MB_OK | MB_ICONEXCLAMATION); <br>      else <br>        MessageBox (hwnd, TEXT("LoadLibrary (..\\spincube\\SPINCUBE.DLL) failed"), <br>                  TEXT("Error, this app requires spincube."), MB_OK | MB_ICONEXCLAMATION); <br> <br>    /***** CUSTOM CONTROL *****/ <br> <br> <br>    /* Demo: Just for fun, start out with one of the dialogs created. */ <br>    PostMessage (hwnd, WM_COMMAND, IDM_DIALOG2, 0); <br> <br>    /* Loop getting messages and dispatching them. */ <br>    while (GetMessage(&amp;msg,NULL, 0, 0)) { <br>      TranslateMessage(&amp;msg); <br>      DispatchMessage(&amp;msg); <br>    } <br> <br>    if (hLibrary != NULL) FreeLibrary (hLibrary); <br> <br>    return (msg.wParam); <br>} <br> <br> <br>/***************************************************************************\ <br>*    FUNCTION: MainWndProc <br>\***************************************************************************/ <br>LRESULT APIENTRY MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>  switch (message) { <br> <br>    /**********************************************************************\ <br>    *  Menu item support. <br>    * <br>    \**********************************************************************/ <br>    case WM_COMMAND: <br>      switch (LOWORD(wParam)) { <br> <br>        case IDM_DIALOG1: <br>          Create1 (hwnd); <br>        break; <br> <br>        case IDM_DIALOG2: <br>          Create2 (hwnd); <br>        break; <br> <br>        case IDM_HELP: <br>          WinHelp( hwnd, TEXT("dyndlg.hlp"), HELP_INDEX, (DWORD) NULL ); <br>        break; <br> <br>        case IDM_ABOUT: <br>          DialogBox (GetModuleHandle(NULL), TEXT("aboutBox"), hwnd, (DLGPROC)About); <br>        return 0; <br> <br>      }  /* end switch */ <br>    break;  /* end wm_command */ <br> <br> <br> <br>    case WM_DESTROY: <br>      WinHelp( hwnd,  TEXT("dyndlg.hlp"), (UINT) HELP_QUIT, (DWORD) NULL ); <br>      PostQuitMessage(0); <br>    break; <br> <br>    } /* end switch */ <br>    return (DefWindowProc(hwnd, message, wParam, lParam)); <br>} <br> <br> <br>/**************************************************************************** <br>    FUNCTION: About <br>****************************************************************************/ <br>LRESULT CALLBACK About(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>  if (message == WM_INITDIALOG) <br>    return TRUE; <br>  if ((message == WM_COMMAND) &amp;&amp; (LOWORD(wParam) == IDOK)) { <br>    EndDialog (hwnd, TRUE); <br>    return TRUE; <br>  } <br>  if ((message == WM_SYSCOMMAND) &amp;&amp; (wParam == SC_CLOSE)) { <br>    EndDialog (hwnd, TRUE); <br>    return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br> <br> <br> <br>/*+++ <br> <br>    Create the first dialog dynamically.  Notice that we are NOT using <br>    structures here because too many of the fields are of variable length. <br>    Instead, just allocate some memory to play with, and start filling in <br>    the data at that pointer. <br> <br>    p - pointer which is moved down through the DLGTEMPLATE information. <br>    pdlgtemplate - pointer to the TOP of the DLGTEMPLATE information. <br> <br>    Here we create a simple dialog with one item.  The dialog has a title, <br>    the item has text, and the item class is specified by ordinal.  There <br>    is no font information. <br> <br>---*/ <br>Create1(HWND hwnd) <br>{ <br>  WORD  *p, *pdlgtemplate; <br>  int   nchar; <br>  DWORD lStyle; <br> <br> <br>  /* allocate some memory to play with  */ <br>  pdlgtemplate = p = (PWORD) LocalAlloc (LPTR, 1000); <br> <br> <br>  /* start to fill in the dlgtemplate information.  addressing by WORDs */ <br>  lStyle = DS_MODALFRAME | WS_CAPTION | WS_SYSMENU | WS_VISIBLE; <br> <br>  *p++ = LOWORD (lStyle); <br>  *p++ = HIWORD (lStyle); <br>  *p++ = 0;          // LOWORD (lExtendedStyle) <br>  *p++ = 0;          // HIWORD (lExtendedStyle) <br>  *p++ = 1;          // NumberOfItems <br>  *p++ = 10;         // x <br>  *p++ = 10;         // y <br>  *p++ = 100;        // cx <br>  *p++ = 100;        // cy <br>  *p++ = 0;          // Menu <br>  *p++ = 0;          // Class <br> <br>  /* copy the title of the dialog */ <br>  if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) <br>    nchar = nCopyAnsiToWideChar (p, TEXT(" ^ C g   1")); <br>  else <br>    nchar = nCopyAnsiToWideChar (p, TEXT("Title 1")); <br>  p += nchar; <br> <br>  /* add in the wPointSize and szFontName here iff the DS_SETFONT bit on */ <br> <br>  /* make sure the first item starts on a DWORD boundary */ <br>  p = lpwAlign (p); <br> <br> <br>  /* now start with the first item */ <br>  lStyle = BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD; <br> <br>  *p++ = LOWORD (lStyle); <br>  *p++ = HIWORD (lStyle); <br>  *p++ = 0;          // LOWORD (lExtendedStyle) <br>  *p++ = 0;          // HIWORD (lExtendedStyle) <br>  *p++ = 10;         // x <br>  *p++ = 70;         // y <br>  *p++ = 80;         // cx <br>  *p++ = 20;         // cy <br>  *p++ = IDOK;       // ID <br> <br>  /* fill in class i.d. Button in this case */ <br>  *p++ = (WORD)0xffff; <br>  *p++ = (WORD)0x0080; <br> <br>  /* copy the text of the first item */ <br>  nchar = nCopyAnsiToWideChar (p, TEXT("OK")); <br>  p += nchar; <br> <br>  *p++ = 0;  // advance pointer over nExtraStuff WORD <br> <br>  CreateDialogIndirect (ghInst, (LPDLGTEMPLATE) pdlgtemplate, hwnd, (DLGPROC) About); <br> <br>  LocalFree (LocalHandle (pdlgtemplate)); <br> <br>  return 0; <br>} <br> <br> <br> <br> <br>/*+++ <br> <br>    Create the second dialog dynamically. <br> <br>    Here we create a dialog which has font information (DS_SETFONT), <br>    and which has two items with the item class specified by name. <br> <br>---*/ <br>Create2(HWND hwnd) <br>{ <br>  WORD  *p, *pdlgtemplate; <br>  int   nchar; <br>  DWORD lStyle; <br> <br>  /* allocate some memory to play with  */ <br>  pdlgtemplate = p = (PWORD) LocalAlloc (LPTR, 1000); <br> <br> <br>  /* start to fill in the dlgtemplate information.  addressing by WORDs */ <br>  lStyle = WS_CAPTION | WS_SYSMENU | WS_VISIBLE | DS_SETFONT; <br>  *p++ = LOWORD (lStyle); <br>  *p++ = HIWORD (lStyle); <br>  *p++ = 0;          // LOWORD (lExtendedStyle) <br>  *p++ = 0;          // HIWORD (lExtendedStyle) <br>  *p++ = 2;          // NumberOfItems <br>  *p++ = 210;        // x <br>  *p++ = 10;         // y <br>  *p++ = 100;        // cx <br>  *p++ = 100;        // cy <br>  *p++ = 0;          // Menu <br>  *p++ = 0;          // Class <br> <br> <br>  /* copy the title of the dialog */ <br>  if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) <br>    nchar = nCopyAnsiToWideChar (p, TEXT(" ^ C g   2")); <br>  else <br>    nchar = nCopyAnsiToWideChar (p, TEXT("Title 2")); <br>  p += nchar; <br> <br>  /* Font information because of DS_SETFONT */ <br>  *p++ = 18;     // point size <br>  nchar = nCopyAnsiToWideChar (p, TEXT("Times New Roman"));  // Face name <br>  p += nchar; <br> <br> <br>  /* make sure the first item starts on a DWORD boundary */ <br>  p = lpwAlign (p); <br> <br>  /* now start with the first item */ <br>  lStyle = BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_TABSTOP; <br>  *p++ = LOWORD (lStyle); <br>  *p++ = HIWORD (lStyle); <br>  *p++ = 0;          // LOWORD (lExtendedStyle) <br>  *p++ = 0;          // HIWORD (lExtendedStyle) <br>  *p++ = 10;         // x <br>  *p++ = 60;         // y <br>  *p++ = 80;         // cx <br>  *p++ = 20;         // cy <br>  *p++ = IDOK;       // ID <br> <br> <br>  /* fill in class i.d., this time by name */ <br>  nchar = nCopyAnsiToWideChar (p, TEXT("BUTTON")); <br>  p += nchar; <br> <br> <br>  /* copy the text of the first item */ <br>  nchar = nCopyAnsiToWideChar (p, TEXT("OK")); <br>  p += nchar; <br> <br>  *p++ = 0;  // advance pointer over nExtraStuff WORD <br> <br>  /* make sure the second item starts on a DWORD boundary */ <br>  p = lpwAlign (p); <br> <br>#define SS_INMOTION 0x0002  /* from spincube.h */ <br>  lStyle = WS_VISIBLE | WS_CHILD | SS_INMOTION; <br>  *p++ = LOWORD (lStyle); <br>  *p++ = HIWORD (lStyle); <br>  *p++ = 0;          // LOWORD (lExtendedStyle) <br>  *p++ = 0;          // HIWORD (lExtendedStyle) <br>  *p++ = 20;         // x <br>  *p++ = 5;          // y <br>  *p++ = 65;         // cx <br>  *p++ = 45;         // cy <br>  *p++ = 57;         // ID <br> <br> <br>  /* fill in class i.d., this time by name */ <br> <br>  /***** CUSTOM CONTROL <br>  * Fill in the class name that is specified in the DLL <br>  *  See the \q_a\samples\spincube sample for the source to this. <br>  *****/ <br>  nchar = nCopyAnsiToWideChar (p, TEXT("Spincube")); <br>  p += nchar; <br> <br>  /* copy the text of the second item, null terminate the string. */ <br>  nchar = nCopyAnsiToWideChar (p, TEXT("")); <br>  p += nchar; <br> <br>  *p++ = 0;  // advance pointer over nExtraStuff WORD <br> <br>  CreateDialogIndirect (ghInst, (LPDLGTEMPLATE) pdlgtemplate, hwnd, (DLGPROC) About); <br> <br>  LocalFree (LocalHandle (pdlgtemplate)); <br> <br>  return 0; <br>} <br> <br> <br> <br> <br>/*+++ <br> <br>    Helper routine.  Take an input pointer, return closest <br>     pointer that is aligned on a DWORD (4 byte) boundary. <br> <br>---*/ <br>LPWORD lpwAlign ( LPWORD lpIn) <br>{ <br>  ULONG ul; <br> <br>  ul = (ULONG) lpIn; <br>  ul +=3; <br>  ul &gt;&gt;=2; <br>  ul &lt;&lt;=2; <br>  return (LPWORD) ul; <br>} <br> <br> <br> <br>/*+++ <br> <br>    Helper routine.  Takes second parameter as Ansi string, copies <br>     it to first parameter as wide character (16-bits / char) string, <br>     and returns integer number of wide characters (words) in string <br>     (including the trailing wide char NULL). <br> <br>---*/ <br>int nCopyAnsiToWideChar (LPWORD lpWCStr, LPSTR lpAnsiIn) <br>{ <br>  int cchAnsi = lstrlen(lpAnsiIn); <br> <br>  return MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, lpAnsiIn, cchAnsi, lpWCStr, cchAnsi) + 1; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
