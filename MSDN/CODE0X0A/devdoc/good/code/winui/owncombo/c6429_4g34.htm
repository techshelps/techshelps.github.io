<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OWNCOMBO.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6430"></a>OWNCOMBO.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corp. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************** <br> *                                                                         * <br> *  PROGRAM     : OwnCombo.c                                               * <br> *                                                                         * <br> *  PURPOSE     : Illustrates the use of functions and messages for        * <br> *                combo boxes and owner-draw control styles.               * <br> *                                                                         * <br> *  FUNCTIONS   : WinMain                - Creates the app. window and     * <br> *                                         enters the message loop.        * <br> *                                                                         * <br> *                OwnComboInit           - Registers the main window class * <br> *                                                                         * <br> *                About                  - Dialog function for the About   * <br> *                                         dialog.                         * <br> *                                                                         * <br> *                OwnComboWndProc        - Window function for app. It     * <br> *                                         handles the menu selections     * <br> *                                         and processes the other window  * <br> *                                         messages.                       * <br> *                                                                         * <br> *                DrawEntireItem         - Handles the drawing of a list   * <br> *                                         list box or combo box item.     * <br> *                                                                         * <br> *                HandleSelectionState   - Handles the selecting/deselect- * <br> *                                         ing of a list box or combo box  * <br> *                                         item.                           * <br> *                                                                         * <br> *                HandleFocusState       - Handles the getting/losing of   * <br> *                                         the input focus by a list box   * <br> *                                                                         * <br> *                ListBoxExample         - Dialog function for the         * <br> *                                         owner-draw list box example.    * <br> *                                                                         * <br> *                ComboBoxExample        - Dialog function for the text    * <br> *                                         combo dialog.                   * <br> *                                                                         * <br> *                OwnerComboBoxExample   - Dialog fubction for the drop-   * <br> *                                         down-list combobox with         * <br> *                                         ownerdraw.                      * <br> *                                                                         * <br> ***************************************************************************/ <br>#include "windows.h" <br>#include "owncombo.h" <br> <br>HANDLE  hInst; <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WinMain(HANDLE, HANDLE, LPSTR, int)                        * <br> *                                                                          * <br> *  PURPOSE    : Creates the app. window and enters the message loop.       * <br> *                                                                          * <br> ****************************************************************************/ <br> <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br> <br>    HWND  hWnd; <br>    MSG   msg; <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br>    if (!hPrevInstance) <br>        if (!OwnComboInit (hInstance)) <br>            return (0); <br> <br>    hInst = hInstance; <br> <br>    /* Create the app. window */ <br>    hWnd = CreateWindow ("owncombo", <br>                         "Owner-draw &amp; Combo Box Example", <br>                         WS_OVERLAPPEDWINDOW, <br>                         CW_USEDEFAULT, <br>                         CW_USEDEFAULT, <br>                         CW_USEDEFAULT, <br>                         CW_USEDEFAULT, <br>                         (HWND) NULL, <br>                         NULL, <br>                         hInstance, <br>                         (LPSTR) NULL); <br> <br>    if (!hWnd) <br>        return (0); <br> <br>    ShowWindow (hWnd, nCmdShow); <br> <br>    while (GetMessage (&amp;msg, NULL, 0, 0)){ <br>        TranslateMessage (&amp;msg); <br>        DispatchMessage (&amp;msg); <br>    } <br> <br>    return(msg.wParam); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : OwnComboInit (hInstance)                                   * <br> *                                                                          * <br> *  PURPOSE    : Registers the main window class.                           * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if RegisterClass () succeeds.                      * <br> *               FALSE - if RegisterClass () fails.                         * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL NEAR PASCAL OwnComboInit (HANDLE hInstance) <br>{ <br>    HANDLE     hMemory; <br>    PWNDCLASS  pWndClass; <br>    BOOL       bSuccess; <br> <br>    /* Allocate for and fill class structure. */ <br>    hMemory = LocalAlloc (LPTR, sizeof (WNDCLASS)); <br>    if(!hMemory){ <br>        MessageBox(NULL, "&lt;OwnComboInit&gt; Not enough memory.", NULL, MB_OK | MB_ICONHAND); <br>        return(FALSE); <br>    } <br> <br>    pWndClass = (PWNDCLASS) LocalLock (hMemory); <br> <br>    pWndClass-&gt;style         = 0; <br>    pWndClass-&gt;lpfnWndProc   = (WNDPROC) OwnComboWndProc; <br>    pWndClass-&gt;hInstance    = hInstance; <br>    pWndClass-&gt;hIcon         = LoadIcon (hInstance, "owncombo"); <br>    pWndClass-&gt;hCursor       = LoadCursor (NULL, IDC_ARROW); <br>    pWndClass-&gt;hbrBackground = GetStockObject (WHITE_BRUSH); <br>    pWndClass-&gt;lpszMenuName  = (LPSTR) "OwnComboMenu", <br>    pWndClass-&gt;lpszClassName = (LPSTR) "owncombo"; <br> <br>    bSuccess = RegisterClass (pWndClass); <br>    LocalUnlock (hMemory); <br>    LocalFree (hMemory); <br> <br>    return (bSuccess); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : About (hDlg,message, wParam, lParam)                       * <br> *                                                                          * <br> *  PURPOSE    : Dialog function for the About... dialog.                   * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL APIENTRY About ( <br>    HWND         hDlg, <br>    UINT     message, <br>    UINT         wParam, <br>    LONG         lParam) <br>{ <br> <br>        UNREFERENCED_PARAMETER(lParam); <br>    switch (message){ <br>        case WM_INITDIALOG: <br>            return(TRUE); <br> <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK){ <br>                EndDialog (hDlg,0); <br>                return(FALSE); <br>            } <br>            break; <br> <br>        default: <br>            break; <br>    } <br>  return(FALSE); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : OwnComboWndProc(hWnd, message, wParam, lParam)             * <br> *                                                                          * <br> *  PURPOSE    : Window function for the app. It handles menu selections    * <br> *               and processes window WM_ messages.                         * <br> *                                                                          * <br> ****************************************************************************/ <br>LONG APIENTRY OwnComboWndProc ( <br>    HWND         hWnd, <br>    UINT     message, <br>    UINT         wParam, <br>    LONG         lParam) <br>{ <br>    switch (message){ <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)){ <br>                case IDM_EXIT: <br>                    DestroyWindow (hWnd); <br>                    break; <br> <br>                case IDM_ABOUT: <br>                    /* Bring up the about box */ <br>                    DialogBox (hInst, <br>                               "AboutBox", <br>                               hWnd, <br>                               About); <br> <br>                    break; <br> <br>                case IDM_LISTBOX: <br>                    /* Bring up the list box example */ <br>                    DialogBox (hInst, <br>                               "ListBoxDialog", <br>                               hWnd, <br>                               About); <br>                    break; <br> <br>                case IDM_MULTILISTBOX: <br>                    /* Bring up the multiple selection list box example */ <br>                    DialogBox (hInst, <br>                               "MultiListBoxDialog", <br>                               hWnd, <br>                               About); <br>                    break; <br> <br>                case IDM_COMBOBOX: <br>                    /* Bring up the combo box example */ <br>                    DialogBox (hInst, <br>                               "ComboBoxDialog", <br>                               hWnd, <br>                               About); <br>                    break; <br> <br>                case IDM_OWNERCOMBOBOX: <br>                    /* Bring up the owner-draw dropdown list box example */ <br>                    DialogBox (hInst, <br>                               "OwnerComboBoxDialog", <br>                               hWnd, <br>                               About); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage (0); <br>            break; <br> <br>        default: <br>            return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return(0); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandleSelectionState(LPDRAWITEMSTRUCT, int)                * <br> *                                                                          * <br> *  PURPOSE    : Handles a change in an item selection state. If an item is * <br> *               selected, a black rectangular frame is drawn around that   * <br> *               item; if an item is de-selected, the frame is removed.     * <br> *                                                                          * <br> *  COMMENT    : The black selection frame is slightly larger than the gray * <br> *               focus frame so they won't paint over each other.           * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY HandleSelectionState( <br>        LPDRAWITEMSTRUCT        lpdis, <br>        INT                     inflate) <br>{ <br>        RECT    rc; <br>        HBRUSH  hbr; <br> <br>        /* Resize rectangle to place selection frame outside of the focus <br>         * frame and the item. <br>         */ <br>        CopyRect ((LPRECT)&amp;rc, (LPRECT)&amp;lpdis-&gt;rcItem); <br>        InflateRect ((LPRECT)&amp;rc, inflate, inflate); <br> <br>        if (lpdis-&gt;itemState &amp; ODS_SELECTED) <br>        { <br>                /* selecting item -- paint a black frame */ <br>                hbr = GetStockObject(BLACK_BRUSH); <br>        } <br>        else <br>        { <br>                /* de-selecting item -- remove frame */ <br>                hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        } <br>        FrameRect(lpdis-&gt;hDC, (LPRECT)&amp;rc, hbr); <br>        DeleteObject (hbr); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandleFocusState(LPDRAWITEMSTRUCT, int)                    * <br> *                                                                          * <br> *  PURPOSE    : Handle a change in item focus state. If an item gains the  * <br> *               input focus, a gray rectangular frame is drawn around that * <br> *               item; if an item loses the input focus, the gray frame is  * <br> *               removed.                                                   * <br> *                                                                          * <br> *  COMMENT    : The gray focus frame is slightly smaller than the black    * <br> *               selection frame so they won't paint over each other.       * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY HandleFocusState( <br>        LPDRAWITEMSTRUCT        lpdis, <br>        INT                     inflate) <br>{ <br>        RECT    rc; <br>        HBRUSH  hbr; <br> <br>        /* Resize rectangle to place focus frame between the selection <br>         * frame and the item. <br>         */ <br>        CopyRect ((LPRECT)&amp;rc, (LPRECT)&amp;lpdis-&gt;rcItem); <br>        InflateRect ((LPRECT)&amp;rc, inflate, inflate); <br> <br>        if (lpdis-&gt;itemState &amp; ODS_FOCUS) <br>        { <br>                /* gaining input focus -- paint a gray frame */ <br>                hbr = GetStockObject(GRAY_BRUSH); <br>        } <br>        else <br>        { <br>                /* losing input focus -- remove (paint over) frame */ <br>                hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        } <br>        FrameRect(lpdis-&gt;hDC, (LPRECT)&amp;rc, hbr); <br>        DeleteObject (hbr); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DrawEntireItem(LPDRAWITEMSTRUCT, int)                      * <br> *                                                                          * <br> *  PURPOSE    : Draws an item and frames it with a selection frame and/or  * <br> *               a focus frame when appropriate.                            * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY DrawEntireItem( <br>        LPDRAWITEMSTRUCT        lpdis, <br>        INT                     inflate) <br>{ <br>        RECT    rc; <br>        HBRUSH  hbr; <br> <br>        /* Resize rectangle to leave space for frames */ <br>        CopyRect ((LPRECT)&amp;rc, (LPRECT)&amp;lpdis-&gt;rcItem); <br>        InflateRect ((LPRECT)&amp;rc, inflate, inflate); <br> <br>        /* Create a brush using the value in the item data field (this value <br>         * was initialized when we added the item to the list/combo box using <br>         * LB_ADDSTRING/CB_ADDSTRING) and draw the color in the list/combo box. <br>         */ <br>        hbr = CreateSolidBrush (lpdis-&gt;itemData); <br>        FillRect (lpdis-&gt;hDC, (LPRECT)&amp;rc, hbr); <br>        DeleteObject (hbr); <br> <br>        /* Draw or erase appropriate frames */ <br>        HandleSelectionState(lpdis, inflate + 4); <br>        HandleFocusState(lpdis, inflate + 2); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ListBoxExample (hDlg, message, wParam, lParam)             * <br> *                                                                          * <br> *  PURPOSE    : Dialog function for the owner-draw list box example.       * <br> *               It sets up the example dialog with the owner-draw list box,* <br> *               adds the colors to the list box, and handles setting the   * <br> *               selection and focus for the items.                         * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL APIENTRY ListBoxExample ( <br>    HWND hDlg, <br>    UINT message, <br>    UINT wParam, <br>    LONG lParam) <br>{ <br>    LPDRAWITEMSTRUCT    lpdis; <br>    LPMEASUREITEMSTRUCT lpmis; <br> <br>    /* Vars for WM_DRAWITEM */ <br> <br>    switch (message){ <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)){ <br>                case IDOK: <br>                   EndDialog (hDlg, 0); <br>                   return (TRUE); <br>                   break; <br> <br>                /* Clicking any of these buttons adds the corresponding color <br>                 * to the list box. The application-supplied data is the RGB <br>                 * value for the color to be drawn in the listbox. <br>                 */ <br>                case ID_BLACK: <br>                    SendMessage (GetDlgItem (hDlg, ID_LISTBOX), <br>                                 LB_ADDSTRING, <br>                                 0, <br>                                 RGB (0,0,0)); <br>                    return(TRUE); <br>                    break; <br>                case ID_RED: <br>                    SendMessage (GetDlgItem (hDlg, ID_LISTBOX), <br>                                 LB_ADDSTRING, <br>                                 0, <br>                                 RGB (255,0,0)); <br>                    return(TRUE); <br>                    break; <br> <br>                case ID_BLUE: <br>                    SendMessage (GetDlgItem (hDlg, ID_LISTBOX), <br>                                 LB_ADDSTRING, <br>                                 0, <br>                                 RGB (0,0,255)); <br>                    return(TRUE); <br>                    break; <br> <br>                case ID_GREEN: <br>                    SendMessage (GetDlgItem (hDlg, ID_LISTBOX), <br>                                 LB_ADDSTRING, <br>                                 0, <br>                                 RGB (0,255,0)); <br>                    return(TRUE); <br>                    break; <br> <br>                default: <br>                    return(FALSE); <br>                    break; <br>            } <br> <br>        case WM_DRAWITEM: <br>            /* Get pointer to the DRAWITEMSTRUCT */ <br>            lpdis = (LPDRAWITEMSTRUCT)lParam; <br> <br>            if (lpdis-&gt;itemID == -1) <br>            { <br>                /* We have a request to draw an item in the list box, yet there <br>                 * are no list box items. This is sent when the user TABS into <br>                 * an empty list box or an empty list box gets the focus. We <br>                 * have to indicate (somehow) that this owner-draw list box has <br>                 * the focus. We do it in response to this message. Note that <br>                 * lpdis-&gt;itemData field would be invalid in this instance so <br>                 * we can't allow it to fall into our standard routines. <br>                 */ <br>                HandleFocusState(lpdis, -5); <br>            } <br>            else <br>            { <br>                switch (lpdis-&gt;itemAction) <br>                { <br>                        case ODA_DRAWENTIRE: <br>                                DrawEntireItem(lpdis, -7); <br>                                break; <br> <br>                        case ODA_SELECT: <br>                                HandleSelectionState(lpdis, -3); <br>                                break; <br> <br>                        case ODA_FOCUS: <br>                                HandleFocusState(lpdis, -5); <br>                                break; <br>                } <br>            } <br> <br>            /* Return TRUE meaning that we processed this message. */ <br>            return(TRUE); <br>            break; <br> <br>        case WM_MEASUREITEM: <br>            lpmis = (LPMEASUREITEMSTRUCT)lParam; <br> <br>            /* All the items are the same height since the list box style is <br>             * LBS_OWNERDRAWFIXED <br>             */ <br>            lpmis-&gt;itemHeight = 30; <br>            break; <br> <br>        case WM_CLOSE: <br>            EndDialog(hDlg, 0); <br>            return(TRUE); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>    } <br> <br>    return(TRUE); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ComboBoxExample(hWnd, message, wParam, lParam)             * <br> *                                                                          * <br> *  PURPOSE    : Dialog function for the text combo dialog. The push buttons* <br> *               send various messages to the combo box and the edit control* <br> *               when selected. They allow the user to vary data sent with  * <br> *               each message.                                              * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL APIENTRY ComboBoxExample( <br>    HWND hDlg, <br>    UINT message, <br>    UINT wParam, <br>    LONG lParam) <br>{ <br> <br>    HWND hWndCombo;                  /* Handle to the combo box control */ <br>                                     /* in the dialog box window        */ <br>    HWND hWndCheckBox;               /* Handle to the Auto Check Box    */ <br>    CHAR strSingleEditLine[255];     /* Single line edit control input  */ <br>    INT  wIndex, wCount; <br> <br>    /* Get handles to the Combo box and the Check box */ <br>    hWndCombo     = GetDlgItem(hDlg, ID_COMBOBOX); <br>    hWndCheckBox  = GetDlgItem(hDlg, ID_STEPSBOX); <br> <br>    switch (message){ <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)){ <br>                case IDOK: <br>                    EndDialog (hDlg,0); <br>                    return(TRUE); <br> <br>                case ID_UNSLBUTTON: <br>                    /* Selecting this button unselects any selection in the <br>                     * combo box. <br>                     */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    wIndex = (WORD) SendMessage( hWndCombo, CB_GETCURSEL, 0, 0L); <br>                    if (wIndex == CB_ERR) <br>                        MessageBox (hDlg, (LPSTR)"No Selection", NULL, MB_OK); <br>                    else <br>                        SendMessage (hWndCombo, CB_SETCURSEL, (WPARAM)-1, 0L); <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br>                case ID_NUMSELBUTTON: <br>                    /* An integer value is taken from the edit control and an <br>                     * attempt is made to select a combo box entry having this <br>                     * index. <br>                     */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    wCount = (WORD) SendMessage (hWndCombo, CB_GETCOUNT, 0, 0L); <br>                    wIndex = (INT) GetDlgItemInt (hDlg, ID_SINGLEEDIT, NULL, TRUE); <br>                    if (wIndex &gt;= wCount) <br>                        MessageBox (hDlg, (LPSTR)"Bad Selection", NULL, MB_OK); <br>                    else <br>                        SendMessage(hWndCombo, CB_SETCURSEL, wIndex, 0L); <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br>                case ID_TXTSELBUTTON: <br>                    /* A text string is taken from the edit control and an <br>                     * attempt is made to select a combo box entry having the <br>                     * string as a prefix. <br>                     */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    GetDlgItemText (hDlg, ID_SINGLEEDIT, <br>                                 (LPSTR)strSingleEditLine, 255); <br>                    wIndex = (WORD) SendMessage (hWndCombo, <br>                                                CB_SELECTSTRING, <br>                                                (WPARAM)-1, <br>                                                (LONG)(LPSTR)strSingleEditLine); <br>                    if (wIndex == CB_ERR) <br>                      MessageBox (hDlg, (LPSTR)"Bad Selection", NULL, MB_OK); <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br>                case ID_FNDSELBUTTON: <br>                    /* Searches for the text specified in the list of combo <br>                     * entries and returns the index (in combo box) of the <br>                     * first match. The index is displayed in the "Text1" <br>                     * field of the dialog. <br>                     */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    GetDlgItemText (hDlg, <br>                                    ID_SINGLEEDIT, <br>                                    (LPSTR)strSingleEditLine, <br>                                    255); <br>                    wIndex = (WORD)SendMessage (hWndCombo, <br>                                               CB_FINDSTRING,(WPARAM)-1, <br>                                               (LONG)(LPSTR)strSingleEditLine); <br>                    if (wIndex == CB_ERR) <br>                        MessageBox (hDlg, (LPSTR)"Bad Selection", NULL, MB_OK); <br>                    else <br>                        SetDlgItemInt (hDlg, ID_TEXT1, wIndex, FALSE); <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br>                case ID_CLRBUTTON: <br>                    /* Clears the combo box of all it's entries */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    wCount = (WORD) SendMessage (hWndCombo, CB_GETCOUNT, 0, 0L); <br>                    if (!wCount) <br>                        MessageBox (hDlg, (LPSTR)"Already clear", NULL, MB_OK); <br>                    else{ <br>                        SetDlgItemInt (hDlg, ID_TEXT1, wCount, TRUE); <br>                        SetDlgItemText (hDlg, ID_TEXT2, "Items cleared"); <br>                        SendMessage (hWndCombo,CB_RESETCONTENT, 0, 0L); <br>                    } <br>                    SetFocus (GetDlgItem (hDlg,ID_SINGLEEDIT)); <br>                    break; <br> <br>                case ID_ADDBUTTON: <br>                    /* Takes the string specified in the edit control and <br>                     * adds it to the combo box. <br>                     */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    GetDlgItemText (hDlg, ID_SINGLEEDIT, strSingleEditLine, 255); <br>                    SendMessage (hWndCombo, <br>                                 CB_ADDSTRING, <br>                                 0, <br>                                 (LONG)(LPSTR) strSingleEditLine); <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br>                case ID_DELETEBUTTON: <br>                    /* Delete the currently selected item from the combo box. */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    wIndex = (WORD) SendMessage (hWndCombo, CB_GETCURSEL, 0, 0L); <br>                    if (SendMessage (hWndCombo, CB_DELETESTRING, wIndex, 0L) == CB_ERR) <br>                        MessageBox (hDlg, (LPSTR)"No Selection", NULL, MB_OK); <br>                    else{ <br>                        SetDlgItemText (hDlg, ID_TEXT1, "deleted index #"); <br>                        SetDlgItemInt  (hDlg, ID_TEXT2, wIndex, TRUE); <br>                    } <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br>                case ID_CBDIRBUTTON: <br>                    /* Appends a directory listing of the current directory <br>                     * to the combo box entries. <br>                     */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    wIndex = (WORD)SendMessage (hWndCombo, <br>                                               CB_DIR, <br>                                               0x10|0x4000, <br>                                               (LONG)(LPSTR)"*.*"); <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br> <br>                case ID_CPYBUTTON: <br>                    /* Copies the currently selected item in the combo box to <br>                     * the edit control. <br>                     */ <br>                    SetDlgItemText (hDlg, ID_TEXT1, ""); <br>                    SetDlgItemText (hDlg, ID_TEXT2, ""); <br>                    wIndex = (WORD) SendMessage (hWndCombo, CB_GETCURSEL, 0, 0L); <br>                    if (wIndex == CB_ERR) <br>                        MessageBox(hDlg, (LPSTR)"No Selection", NULL, MB_OK); <br>                    else{ <br>                        wCount = SendMessage (hWndCombo, CB_GETLBTEXTLEN, wIndex, 0L); <br>                        SendMessage (hWndCombo, <br>                                     CB_GETLBTEXT, <br>                                     wIndex, <br>                                     (LONG)(LPSTR)strSingleEditLine); <br>                        SetDlgItemText(hDlg, ID_SINGLEEDIT, <br>                                       (LPSTR)strSingleEditLine); </code></pre>
<p>
</p>
<pre><code>SetDlgItemText(hDlg, ID_TEXT1, "copied index #"); <br>                        SetDlgItemInt(hDlg, ID_TEXT2, wIndex, TRUE); <br>                    } <br>                    SetFocus (GetDlgItem (hDlg, ID_SINGLEEDIT)); <br>                    break; <br> <br>                /* When the combo notification box is checked, a message box <br>                 * is flashed showing what notification codes the combo box is <br>                 * returning to the app. in response to the messages sent by <br>                 * the buttons. <br>                 */ <br>                case ID_COMBOBOX: <br>                    if (SendMessage (hWndCheckBox, BM_GETCHECK, 0, 0L)){ <br>                        switch (HIWORD(lParam)){ <br>                            case (WORD)CBN_ERRSPACE: <br>                              MessageBox (hDlg, (LPSTR)"CB Out of Space", <br>                                         "CB MSG", MB_OK); <br>                              break; <br> <br>                            case CBN_SELCHANGE: <br>                              MessageBox (hDlg, (LPSTR)"CB Sel Change", <br>                                         "CB MSG", MB_OK); <br>                              break; <br> <br>                            case CBN_DBLCLK: <br>                              MessageBox(hDlg, (LPSTR)"CB Double Click", <br>                                         "CB MSG", MB_OK); <br>                              break; <br> <br>                            case CBN_SETFOCUS: <br>                              SetDlgItemText(hDlg, ID_TEXT1, "CB SetFocus"); <br>                              break; <br> <br>                            case CBN_KILLFOCUS: <br>                              SetDlgItemText(hDlg, ID_TEXT1, "CB KillFocus"); <br>                              break; <br>                        } <br>                    } <br>                    break; <br> <br>                default: <br>                    return(FALSE); <br>            } <br>            break; <br> <br>        case WM_CLOSE: <br>            EndDialog(hDlg, 0); <br>            return(TRUE); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>    } <br>    return(TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : OwnerComboBoxExample(hWnd, message, wParam, lParam)        * <br> *                                                                          * <br> *  PURPOSE    : Dialog function for the dropdown list combo box with       * <br> *               owner-draw.                                                * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL APIENTRY OwnerComboBoxExample ( <br>    HWND hDlg, <br>    UINT message, <br>    UINT wParam, <br>    LONG lParam) <br>{ <br>    LPDRAWITEMSTRUCT    lpdis; <br>    LPMEASUREITEMSTRUCT lpmis; <br> <br>    switch (message){ <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)){ <br>                case IDOK: <br>                   EndDialog (hDlg, 0); <br>                   return(TRUE); <br>                   break; <br> <br>                /* Clicking any of these buttons adds the corresponding color <br>                 * to the combo box. The application-supplied data is the RGB <br>                 * value for the color to be drawn in the listbox. <br>                 */ <br>                case ID_BLACK: <br>                   SendMessage (GetDlgItem(hDlg, ID_LISTBOX), <br>                                CB_ADDSTRING, <br>                                0, <br>                                RGB (0,0,0)); <br>                   return(TRUE); <br>                   break; <br> <br>                case ID_RED: <br>                   SendMessage (GetDlgItem (hDlg, ID_LISTBOX), <br>                                CB_ADDSTRING, <br>                                0, <br>                                RGB (255,0,0)); <br>                   return(TRUE); <br>                   break; <br> <br>                case ID_BLUE: <br>                   SendMessage (GetDlgItem(hDlg, ID_LISTBOX), <br>                                CB_ADDSTRING, <br>                                0, <br>                                RGB (0,0,255)); <br>                   return(TRUE); <br>                   break; <br> <br>                case ID_GREEN: <br>                   SendMessage (GetDlgItem(hDlg, ID_LISTBOX), <br>                                CB_ADDSTRING, <br>                                0, <br>                                RGB (0,255,0)); <br>                   return(TRUE); <br>                   break; <br> <br>                default: <br>                   return(TRUE); <br>                   break; <br>            } <br> <br>        case WM_DRAWITEM: <br>            /* Get pointer to the DRAWITEMSTRUCT */ <br>            lpdis = (LPDRAWITEMSTRUCT)lParam; <br> <br>            if (lpdis-&gt;itemID == -1){ <br>                /* We have a request to draw an item in the combo box, yet there <br>                 * are no combo box items. This is sent when the user TABS into <br>                 * an empty combo box or an empty combo box gets the focus. We <br>                 * have to indicate (somehow) that this owner-draw combo box has <br>                 * the focus. We do it in response to this message. Note that <br>                 * lpdis-&gt;itemData field would be invalid in this instance so <br>                 * we can't allow it to fall into our standard routines. <br>                 */ <br>                HandleFocusState(lpdis, -2); <br>            } <br>            else <br>            { <br>                switch (lpdis-&gt;itemAction) <br>                { <br>                        case ODA_DRAWENTIRE: <br>                                DrawEntireItem(lpdis, -4); <br>                                break; <br> <br>                        case ODA_SELECT: <br>                                HandleSelectionState(lpdis, 0); <br>                                break; <br> <br>                        case ODA_FOCUS: <br>                                HandleFocusState(lpdis, -2); <br>                                break; <br>                } <br>            } <br> <br>            /* Return TRUE meaning that we processed this message. */ <br>            return(TRUE); <br>            break; <br> <br>        case WM_MEASUREITEM: <br>            lpmis = (LPMEASUREITEMSTRUCT)lParam; <br> <br>            /* All the items are the same height since the combo box is <br>             * CBS_OWNERDRAWFIXED <br>             */ <br>            if (lpmis-&gt;itemID == -1){ <br>                /* If -1 for item, then we are setting the height of the <br>                 * always visible static item part of the dropdown combo box. <br>                 */ <br>                lpmis-&gt;itemHeight = 25; <br>                return(TRUE); <br>            } <br>            lpmis-&gt;itemHeight = 30; <br>            break; <br> <br>        case WM_CLOSE: <br>            EndDialog(hDlg, 0); <br>            return(TRUE); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>    } <br>    return(TRUE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
