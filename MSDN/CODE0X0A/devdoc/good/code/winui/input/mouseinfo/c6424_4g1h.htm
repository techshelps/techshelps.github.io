<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MOUSINFO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6425"></a>MOUSINFO.C</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////// <br>//  <br>// MODULE:      MOUSINFO.C <br>// <br>// DESCRIPTION: SDK sample for handling the new WM_MOUSEWHEEL message and  <br>//              the new TrackMouseEvent() API. <br>// <br>//              Applet displays MouseButton, MouseWheel, MouseMovement, and <br>//              any mouse messages in the title bar. <br>// <br>// PLATFORMS:   WinNT 4.0 <br>// <br>//              Copyright 1995 - 1998 Microsoft Corporation.  <br>//                          All rights reserved <br>//  <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>#include &lt;windows.h&gt; <br>#include "mousinfo.h" <br> <br>// Globals <br>HINSTANCE ghInst; <br> <br>// <br>// Array of Mouse Message Strings <br>// <br>char garMsgStrings[][20] = { <br>    "                   ", <br>    "WM_LBUTTONUP       ", <br>    "WM_RBUTTONUP       ", <br>    "WM_MBUTTONUP       ", <br>    "WM_LBUTTONDOWN     ", <br>    "WM_RBUTTONDOWN     ", <br>    "WM_MBUTTONDOWN     ", <br>    "WM_LBUTTONDBLCLK   ", <br>    "WM_MBUTTONDBLCLK   ", <br>    "WM_RBUTTONDBLCLK   ", <br>    "WM_MOUSEWHEEL      ", <br>    "WM_MOUSEHOVER      ", <br>    "WM_MOUSELEAVE      " <br>    }; <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// <br>// FUNCTION:int WINAPI WinMain(HANDLE,HANDLE,LPSTR,int) <br>// <br>// DESCRIPTION:Your basic WinMain() <br>// <br>///////////////////////////////////////////////////////////////////////// <br>int WINAPI WinMain( HINSTANCE hInstance,  <br>                    HINSTANCE hPrevInstance,  <br>                    LPSTR  lpCmdLine,  <br>                    int    nCmdShow) <br>{ <br>    MSG msg; <br>    WNDCLASS  wc; <br>    HWND hwndMain; <br> <br>    ghInst = hInstance; <br> <br>    // <br>    // Register our main window, only if first instance <br>    // <br> <br>    if( !hPrevInstance ) <br>    { <br>        wc.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS; <br>        wc.lpfnWndProc = (WNDPROC)MainWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst;        <br>        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(MOUSINFO_ICON)); <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>        wc.lpszMenuName =  MAKEINTRESOURCE(IDM_MENU); <br>        wc.lpszClassName = szClassName; <br> <br>        if (!RegisterClass(&amp;wc))  <br>            return FALSE; <br>    } <br> <br>  // <br>  // Create the main window... <br>  //  with an initial size of 0 <br>  // <br> <br>  hwndMain = CreateWindow( <br>      szClassName, <br>      szAppName, <br>      WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_THICKFRAME, <br>      0,0,0,0, <br>      NULL, NULL, ghInst, NULL ); <br> <br> <br>  // <br>  // Show the window <br>  // <br>  ShowWindow(hwndMain,SW_SHOW); <br>  UpdateWindow(hwndMain); <br>   <br>  // <br>  // Message pump <br>  // <br>  while (GetMessage(&amp;msg, NULL,0,0))  <br>  { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>  } <br>  <br>  return (msg.wParam); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////////////// <br>// <br>// FUNCTION:LRESULT WINAPI MainWndProc (HWND,UINT,WPARAM,LPARAM) <br>// <br>// DESCRIPTION:Your standard Window Procedure. <br>// <br>// MESSAGE:Handles the following Windows messages: <br>// <br>//WM_CREATE <br>//WM_DESTROY <br>//WM_SYSCOMMAND <br>//WM_LBUTTONUP    <br>//WM_RBUTTONUP      <br>//WM_MBUTTONUP      <br>//WM_LBUTTONDOWN <br>//WM_RBUTTONDOWN    <br>//WM_MBUTTONDOWN <br>//WM_LBUTTONDBLCLK  <br>//WM_MBUTTONDBLCLK  <br>//WM_RBUTTONDBLCLK  <br>//WM_MOUSEMOVE <br>// <br>//And the new mouse message <br>// <br>//WM_MOUSEWHEEL <br>//                   <br>//              And the new TrackMouseEvent() Messages <br>// <br>//              WM_MOUSEHOVER       // mouse hovered specified delay over client area <br>//              WM_MOUSELEAVE       // mouse has left the client area <br>// <br>// <br>////////////////////////////////////////////////////////////////////////////////// <br>LRESULT WINAPI MainWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    TEXTMETRIC tm; <br>    HDC hDC; <br> <br>    int MsgIndex = NO_MESSAGE;          // Index into garMsgStrings[] array <br>  char szBuff[128];                   // String buffer <br>    static int LB=0,RB=0,MB=0;          // State of the mouse buttons <br>    static int X=0,Y=0;                 // Mouse position   <br>    static char Roller=' ';             // State of the mouse wheel. '+' or '-' <br>    static int fHasWheel=FALSE;         // Mouse has a wheel?? TRUE if yes, FALSE if no <br> <br>    switch (message) <br>    { <br> <br>        case WM_CREATE: <br>    // <br>            // See if we have a mouse with a wheel attached to the system. <br>// Note that SM_MOUSEWHEELPRESENT is a new flag for GetSystemMetrics <br>//  and returns TRUE if a mouse with a wheel is present, FALSE if not. <br>// <br>            fHasWheel = GetSystemMetrics( SM_MOUSEWHEELPRESENT ); <br> <br>            // <br>            // Size the window so that it will display all the text <br>            // <br>            hDC = GetDC(hwnd); <br>            GetTextMetrics(hDC,&amp;tm); <br>            SetWindowPos(hwnd,HWND_BOTTOM,0,0,tm.tmMaxCharWidth * MAX_TITLE_LEN,100,SWP_SHOWWINDOW); <br>            ReleaseDC(hwnd, hDC); <br> <br>return 0; <br> <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            return 0; <br> <br>  // <br>        // Handle WM_MOUSE messages. <br>        // First we setup up some variables and then let <br>        //  control fall through to the end of the switch <br>        //  construct, where we then update the title bar. <br>        //  <br>        case WM_LBUTTONUP:    LB=0; MsgIndex = LBU; break; <br>case WM_RBUTTONUP:      RB=0; MsgIndex = RBU; break; <br>case WM_MBUTTONUP:      MB=0; MsgIndex = MBU; break; <br>case WM_LBUTTONDOWN:LB=1; MsgIndex = LBD; break; <br>case WM_RBUTTONDOWN:    RB=1; MsgIndex = RBD; break; <br>case WM_MBUTTONDOWN:MB=1; MsgIndex = MBD; break;  <br>case WM_LBUTTONDBLCLK:  LB=0; MsgIndex = LB2; break;  <br>case WM_MBUTTONDBLCLK:  MB=0; MsgIndex = MB2; break;  <br>case WM_RBUTTONDBLCLK:  RB=0; MsgIndex = RB2; break;  <br>        case WM_MOUSEHOVER:           MsgIndex = MH;  break; <br>        case WM_MOUSELEAVE:           MsgIndex = ML;  break; <br> <br>        case WM_MOUSEMOVE:MsgIndex=NO_MESSAGE; Roller = ' ';  break;  <br>        // <br>        // Handle WM_MOUSEWHEEL message. <br>        // We handle this message a little differently since the <br>        //  roller movement info is in the HIWORD of wParam. <br>        // <br>        // The MouseWheel has 18 'detents'. As the wheel is rolled <br>        //  and a detent is encountered, the OS will send a WM_MOUSEWHEEL <br>        //  message with the HIWORD of wParam set to a value of +/- 120. <br>        //  '+' if the wheel is being rolled forward (away from the user), <br>        //  '-' if the wheel is being rolled backwards (towards the user).  <br>        case WM_MOUSEWHEEL:      <br>            // <br>            // Mouse Wheel is being rolled forward <br>            // <br>            if( (short)HIWORD(wParam) &gt; 0 )                     <br>                Roller = '+'; <br> <br>            // <br>            // Mouse Wheel is being rolled backward <br>            // <br>            if( (short)HIWORD(wParam) &lt; 0 ) <br>                Roller = '-'; <br> <br>            MsgIndex = MW;       <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(wParam) <br>            { <br>                // <br>                // Call the TrackMouseEvent() API, and set up a WM_MOUSEHOVER <br>                //  "one-shot" event. Exactly one and only one  WM_MOUSEHOVER <br>                //  message will be sent to the window specified in the hwndTrack <br>                //  member of the TRACKMOUSEEVENT structure, when the mouse has <br>                //  'hovered' over the client area an amount of time equal to that <br>                //  specified in the dwHoverTime member of TRACKMOUSEEVENT. <br>                // <br>                // NOTE that this message will be generated only once. The application <br>                //  must call the TrackMouseEvent() API again in order for the system <br>                //  to generate another WM_MOUSEHOVER message. <br>                // <br>                case IDM_HOVER: <br>                { <br>                    TRACKMOUSEEVENT tme; <br> <br>                    tme.cbSize      = sizeof(TRACKMOUSEEVENT); <br>                    tme.dwFlags     = TME_HOVER; <br>                    tme.hwndTrack   = hwnd; <br>                    tme.dwHoverTime = HOVER_DEFAULT; <br> <br>                    TrackMouseEvent(&amp;tme); <br> <br>                    return 0; <br>                } <br> <br>                // <br>                // Call the TrackMouseEvent() API, and set up a WM_MOUSELEAVE <br>                //  "one-shot" event. Exactly one and only one  WM_MOUSELEAVE <br>                //  message will be sent to the window specified in the hwndTrack <br>                //  member of the TRACKMOUSEEVENT structure, when the mouse has <br>                //  left the client area.  <br>                // <br>                // NOTE that this message will be generated only once. The application <br>                //  must call the TrackMouseEvent() API again in order for the system <br>                //  to generate another WM_MOUSELEAVE message. Also note that if the <br>                //  mouse pointer is not over the application, a call to TrackMouseEvent()  <br>                //  will result in the immediate posting of a WM_MOUSELEAVE <br>                //  message. <br>                // <br>                case IDM_LEAVE: <br>                { <br>                    TRACKMOUSEEVENT tme; <br> <br>                    tme.cbSize      = sizeof(TRACKMOUSEEVENT); <br>                    tme.dwFlags     = TME_LEAVE; <br>                    tme.hwndTrack   = hwnd; <br> <br>                    TrackMouseEvent(&amp;tme); <br> <br>                    return 0; <br>                } <br> <br>                case IDM_ABOUT: <br>                { <br>                    char buff[128]; <br>                     <br>                    wsprintf(buff,"MousInfo.Exe\r\n" <br>                                  "Copyright 1995-96, Microsoft Corp.\r\n" <br>                                  "All rights reserved\r\n\r\n" ); <br> <br>                    MessageBox(hwnd,buff,szAppName,MB_OK); <br>                    return 0; <br>                } <br>             <br>            } <br>            break; <br>             <br>        default: <br>            return (DefWindowProc(hwnd, message, wParam, lParam)); <br> <br>    }  // end switch (message) <br>   <br> <br>// <br>    // If the mouse has a wheel, display the state of the mouse buttons,  <br>    //   wheel and position in the title bar. <br>    // <br>    if( fHasWheel ) <br>        wsprintf(szBuff,"L:%d M:%d R:%d W:%c x:%04d y:%04d %s", <br>      LB,MB,RB,Roller, <br>                  LOWORD(lParam),HIWORD(lParam),  <br>                  garMsgStrings[MsgIndex] ); <br>    // <br>    // Else if mouse does not have a wheel, do not display the state <br>    //  of the wheel (but do display everything else!). <br>    // <br>    else <br>        wsprintf(szBuff,"L:%d M:%d R:%d x:%04d y:%04d %s", <br>      LB,MB,RB,LOWORD(lParam),HIWORD(lParam),  <br>                  garMsgStrings[MsgIndex] ); <br> <br>    SetWindowText(hwnd,szBuff); <br> <br>    return (DefWindowProc(hwnd, message, wParam, lParam)); <br> <br>} <br> <br> <br> <br>  </code></pre>
<p>&nbsp;</p></body>
</HTML>
