<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMEUI.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6398"></a>IMEUI.C</h2>
<pre><code>#include &lt;assert.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;imm.h&gt; <br>#include "fullime.h" <br> <br>static DWORD CompColor[ 4 ] = { RGB( 255, 0, 0 ), <br>                                RGB( 255, 0 , 255 ), <br>                                RGB( 0, 0, 255 ), <br>                                RGB( 0, 255, 0 ) }; <br> <br>//********************************************************************** <br>// <br>// void ImeUIStartComposition() <br>// <br>// This handles WM_IME_STARTCOMPOSITION message.  <br>// <br>//********************************************************************** <br> <br>void ImeUIStartComposition( HWND hwnd ) <br>{ <br>         <br>    // <br>    // Change caption title to DBCS composition mode. <br>    // <br> <br>    SetWindowText( hwnd, (LPSTR)szSteCompTitle );     <br> <br>    // <br>    // Reset global variables. <br>    //  <br> <br>    gImeUIData.uCompLen = 0;             // length of composition string. <br> <br>    gImeUIData.ImeState |= IME_IN_COMPOSITION; <br>} <br> <br>//********************************************************************** <br>// <br>// void ImeUIComposition() <br>// <br>// This handles WM_IME_COMPOSITION message. It here just handles  <br>// composition string and result string. For normal case, it should  <br>// examine all posibile flags indicated by CompFlag, then do some <br>// actitions to reflect what kinds of composition info. IME conversion <br>// engine informs. <br>// <br>//********************************************************************** <br> <br>void ImeUIComposition( HWND hwnd, WPARAM wParam, LPARAM CompFlag ) <br>{ <br> <br>    if ( CompFlag &amp; GCS_RESULTSTR ) <br>         GetResultStr( hwnd ); <br>    else <br>    if ( CompFlag &amp; GCS_COMPSTR ) <br>         GetCompositionStr( hwnd, CompFlag ); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// void GetCompositionStr() <br>// <br>// This handles WM_IME_COMPOSITION message with GCS_COMPSTR flag on. <br>// <br>//********************************************************************** <br> <br>void GetCompositionStr( HWND hwnd, LPARAM CompFlag ) <br>{ <br>     DWORD      dwBufLen;               // Stogare for len. of composition str <br>     LPSTR      lpCompStr;              // Pointer to composition str. <br>     HIMC       hIMC;                   // Input context handle. <br>     HLOCAL     hMem;                   // Memory handle. <br>     LPSTR      lpCompStrAttr;          // Pointer to composition str array. <br>     HLOCAL     hMemAttr;               // Memory handle for comp. str. array. <br>     DWORD      dwBufLenAttr; <br>     <br>     // <br>     // If fail to get input context handle then do nothing. <br>     // Applications should call ImmGetContext API to get <br>     // input context handle. <br>     // <br> <br>     if ( !( hIMC = ImmGetContext( hwnd ) ) ) <br>         return; <br> <br>     // <br>     // Determines how much memory space to store the composition string. <br>     // Applications should call ImmGetCompositionString with <br>     // GCS_COMPSTR flag on, buffer length zero, to get the bullfer <br>     // length. <br>     // <br> <br>     if ( ( dwBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR,  <br>                                         (void FAR*)NULL, 0l ) ) &lt; 0 ) <br>         goto exit2; <br> <br>     // <br>     // Allocates memory with dwBufLen+1 bytes to store the composition <br>     // string. Here we allocale on more byte to put null character. <br>     // <br> <br>     if ( !( hMem = LocalAlloc( LPTR, (int)dwBufLen + 1 ) ) ) <br>         goto exit2; <br> <br>     if ( !( lpCompStr = (LPSTR) LocalLock( hMem ) ) ) <br>         goto exit1; <br> <br>     // <br>     // Reads in the composition string. <br>     // <br> <br>     ImmGetCompositionString( hIMC, GCS_COMPSTR, lpCompStr, dwBufLen ); <br> <br>     // <br>     // Null terminated. <br>     // <br> <br>     lpCompStr[ dwBufLen ] = 0; <br> <br>     // <br>     // If GCS_COMPATTR flag is on, then we need to take care of it. <br>     // <br> <br>     if ( CompFlag &amp; GCS_COMPATTR ) <br>     { <br> <br>         if ( ( dwBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR, <br>                               ( void FAR *)NULL, 0l ) ) &lt; 0 ) <br>             goto nothing; <br> <br>         // <br>         // Allocate memory to store attributes of composition strings. <br>         // <br> <br>         if ( !( hMemAttr = LocalAlloc( LPTR, (int)dwBufLenAttr + 1 ) ) ) <br>             goto nothing; <br> <br>         if ( !( lpCompStrAttr = (LPSTR) LocalLock( hMemAttr ) ) ) <br>         { <br>             LocalFree( hMemAttr ); <br>             goto nothing; <br>         } <br> <br>         // <br>         // Reads in the attribute array. <br>         // <br> <br>         ImmGetCompositionString( hIMC, GCS_COMPATTR, lpCompStrAttr, <br>                                  dwBufLenAttr ); <br> <br>         lpCompStrAttr[ dwBufLenAttr ] = 0; <br> <br>     } else <br>     { <br> <br>nothing: <br>         lpCompStrAttr = NULL; <br>     } <br> <br> <br>     // <br>     // Display new composition chars. <br>     // <br> <br>     DisplayCompString( hwnd, lpCompStr, lpCompStrAttr ); <br> <br>     // <br>     // Keep the length of the composition string for using later. <br>     // <br> <br>     gImeUIData.uCompLen = (UINT)dwBufLen; <br> <br>     LocalUnlock( hMem ); <br> <br>     if ( lpCompStrAttr ) <br>     { <br>         LocalUnlock( hMemAttr ); <br>         LocalFree( hMemAttr ); <br>     } <br> <br>exit1: <br> <br>     LocalFree( hMem ); <br> <br>exit2: <br> <br>     ImmReleaseContext( hwnd, hIMC ); <br> <br>} <br> <br> <br>//*********************************************************************** <br>// <br>// void GetResultStr() <br>// <br>// This handles WM_IME_COMPOSITION with GCS_RESULTSTR flag on. <br>// <br>//*********************************************************************** <br> <br>void GetResultStr( HWND hwnd ) <br>{ <br>    DWORD       dwBufLen;               // Storage for length of result str. <br>    LPSTR       lpResultStr;            // Pointer to result string. <br>    HIMC        hIMC;                   // Input context handle. <br>    HLOCAL      hMem;                   // Memory handle. <br> <br>    // <br>    // If fail to get input context handle then do nothing. <br>    // <br> <br>    if ( !( hIMC = ImmGetContext( hwnd ) ) ) <br>        return; <br> <br>    // <br>    // Determines how much memory space to store the result string. <br>    // Applications should call ImmGetCompositionString with <br>    // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer <br>    // length. <br>    // <br> <br>    if ( ( dwBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, <br>                                  (void FAR *)NULL, (DWORD) 0 ) ) &lt;= 0 ) <br>        goto exit2; <br> <br>    // <br>    // Allocates memory with dwBufLen+1 bytes to store the result <br>    // string. Here we allocale on more byte to put null character. <br>    // <br> <br>    if ( !( hMem = LocalAlloc( LPTR, (int)dwBufLen + 1 ) ) ) <br>        goto exit2; <br> <br>    if ( !( lpResultStr = (LPSTR) LocalLock( hMem ) ) ) <br>        goto exit1; <br> <br>    // <br>    // Reads in the result string. <br>    // <br> <br>    ImmGetCompositionString( hIMC, GCS_RESULTSTR, lpResultStr, dwBufLen ); <br> <br>    // <br>    // Displays the result string. <br>    // <br> <br>    DisplayResultString( hwnd, lpResultStr ); <br> <br>    LocalUnlock( hMem ); <br> <br>exit1: <br>     <br>    LocalFree( hMem ); <br> <br>exit2: <br> <br>    ImmReleaseContext( hwnd, hIMC ); <br> <br>} <br> <br> <br>//********************************************************************** <br>// <br>// void ImeUIEndComposition <br>// <br>// This handles WM_IME_ENDCOMPOSITION message. <br>// <br>//********************************************************************** <br> <br>void ImeUIEndComposition( HWND hwnd ) <br>{ <br>         <br>    RECT       rect; <br> <br>    // <br>    // Change caption title to normal <br>    // <br> <br>    SetWindowText( hwnd, (LPSTR)szSteTitle ); <br> <br>    // <br>    // Update client area. <br>    // <br> <br>    GetClientRect( hwnd, (LPRECT)&amp;rect ); <br> <br>    InvalidateRect( hwnd, (LPRECT)&amp;rect, FALSE ); <br> <br>    // <br>    // Reset the length of composition string to zero. <br>    // <br> <br>    gImeUIData.uCompLen = 0; <br> <br>    gImeUIData.ImeState &amp;= ~IME_IN_COMPOSITION; <br> <br>} <br> <br>//********************************************************************** <br>// <br>// BOOL ImeUINotify() <br>// <br>// This handles WM_IME_NOTIFY message. <br>// <br>//********************************************************************** <br> <br>BOOL ImeUINotify( HWND hwnd, WPARAM wParam, LPARAM lParam ) <br>{ <br>    switch (wParam ) <br>    { <br>        case IMN_OPENCANDIDATE: <br> <br>            ImeUIOpenCandidate( hwnd, lParam ); <br>            break; <br> <br>        case IMN_CLOSECANDIDATE: <br> <br>            ImeUICloseCandidate( hwnd, lParam ); <br>            break; <br> <br>        case IMN_CHANGECANDIDATE: <br> <br>            ImeUIChangeCandidate( hwnd, lParam ); <br>            break; <br> <br>        case IMN_SETOPENSTATUS: <br> <br>            ImeUISetOpenStatus( hwnd ); <br>            break; <br> <br>default: <br>    return FALSE; <br> <br>    } <br>     <br>    return TRUE; <br>} <br> <br>//********************************************************************** <br>// <br>// void ImeUIOpenCandidate() <br>// <br>// This handles WM_IME_NOTIFY message with wParam = IMN_OPENCANDIDATE. <br>// <br>//********************************************************************** <br> <br>void ImeUIOpenCandidate( HWND hwnd, LPARAM CandList ) <br>{ <br>    HIMC        hIMC;                   // Input context handle. <br>    LPCANDIDATELIST lpCandList;         // Storage for LP to candidate list. <br>    DWORD       dwBufLen;               // Storage for candidate strings. <br>    LPSTR       lpStr;                  // Storage for LP to a string. <br>    DWORD       dwIndex;                // Storage for index of ListCand array <br>    DWORD       i;                      // Loop count. <br>    int         width = 0;              // Storage for width of listCand <br>    int         CurNumCandList = 0;     // Storage for number of cand. lists. <br>    DWORD       dwPreferNumPerPage;     // Storage for PreferNumPerPage <br>    POINT       point;                  // Storage for caret position. <br> <br>    // <br>    // If fail to get input context handle, do nothing. <br>    // <br> <br>    if ( ! (hIMC = ImmGetContext( hwnd ) ) ) <br>        return; <br> <br>    // <br>    // Change caption title to DBCS candidate mode. <br>    // <br> <br>    SetWindowText( hwnd, (LPSTR)szSteCandTitle ); <br> <br>    // <br>    // Find out how many candidate windows have already been opened. <br>    // <br> <br>    for( i = 0; i &lt; MAX_LISTCAND; i++ ) <br>    { <br>        if ( gImeUIData.hListCand[ i ] ) <br>            CurNumCandList++; <br>    } <br> <br>    // <br>    // Check which candidate lists should be displayed by loopping <br>    // through all possible candidate lists. <br>    // <br> <br>    for( dwIndex = 0; dwIndex &lt; MAX_LISTCAND ; dwIndex ++ ) <br>    { <br> <br>        if ( CandList &amp; ( 1 &lt;&lt; dwIndex ) ) <br>        {    <br>            // <br>            // The dwIndex-th candidate list contains candidate strings. <br>            // So here we want to display them. <br>            // <br> <br>            // <br>            // Determines how musch memory space should be allocated to <br>            // read in the corresponding candidate list . <br>            // <br> <br>            if ( ! ( dwBufLen = ImmGetCandidateList( hIMC, dwIndex,  <br>                       lpCandList, 0 ) ) )                       <br>                goto exit2; <br>                        <br>             <br>            // <br>            // Allocate memory space. <br>            // <br> <br>            if( !( gImeUIData.hListCandMem[ dwIndex ]  =  <br>                   GlobalAlloc( LPTR, (int)dwBufLen ) ) ) <br>                goto exit2; <br> <br>            if( !( lpStr = <br>                 (LPSTR)GlobalLock( gImeUIData.hListCandMem[ dwIndex ] ) ) ) <br>            {    <br>                GlobalFree( gImeUIData.hListCandMem[ dwIndex ] ); <br>                gImeUIData.hListCandMem[ dwIndex ] = NULL; <br>                goto exit2; <br>            } <br>                     <br>            lpCandList = (LPCANDIDATELIST) lpStr; <br> <br>            // <br>            // Reads in the corresponding candidate list. <br>            // <br> <br>            ImmGetCandidateList( hIMC, dwIndex, lpCandList, dwBufLen ); <br> <br>            // <br>            // Get current caret position. <br>            // <br> <br>            GetCaretPos( (POINT FAR*)&amp;point ); <br>            ClientToScreen( hwnd, (LPPOINT)&amp;point ); <br> <br>            // <br>            // Determines how many candidate strings per page. <br>            // <br> <br>            dwPreferNumPerPage = ( !lpCandList-&gt;dwPageSize ) ? <br>                                 DEFAULT_CAND_NUM_PER_PAGE : <br>                                 lpCandList-&gt;dwPageSize; <br>            // <br>            // Determining maximum character length the list box <br>            // will display by loopping through all candidate strings. <br>            // <br> <br>            for( i = 0; i &lt; lpCandList-&gt;dwCount; i++ ) <br>            { <br>                // <br>                // Get the pointer to i-th candidate string. <br>                // <br> <br>                lpStr = (LPSTR)lpCandList +  <br>                        lpCandList-&gt;dwOffset[ i ]; <br> <br>                width = ( width &lt; lstrlen( lpStr ) ) ? lstrlen( lpStr ) : <br>                          width; <br> <br>            } <br> <br>            // <br>            // Create a candidate window for the candidate list. <br>            // <br> <br> <br>            gImeUIData.hListCand[ dwIndex ] = CreateWindow(           <br>                                 (LPCTSTR)szCandClass, <br>                                 NULL, <br>                                 WS_BORDER | WS_POPUP | WS_DISABLED, <br>                                 CurNumCandList * X_INDENT + point.x, <br>                                 CurNumCandList * Y_INDENT +  <br>                                 point.y + cyMetrics, <br>                                 ( width ) * cxMetrics + 10, <br>                                 (int)(dwPreferNumPerPage) * cyMetrics + 5,, <br>                                 hwnd, <br>                                 (HMENU)NULL, <br>                                 (HANDLE)GetWindowLong( hwnd, GWL_HINSTANCE ), <br>                                 (LPVOID)NULL <br>                                 ); <br>            // <br>            // If fail to create the candidate window then do nothing. <br>            // <br> <br>            if ( gImeUIData.hListCand[ dwIndex ] &lt; 0 ) <br>            { <br>                GlobalUnlock( gImeUIData.hListCandMem[ dwIndex ] ); <br>                GlobalFree( gImeUIData.hListCandMem[ dwIndex ] ); <br>                goto exit2; <br>            } <br> <br>  <br>            // <br>            // Show candidate window. <br>            // <br> <br>            ShowWindow( gImeUIData.hListCand[ dwIndex ], SW_SHOWNOACTIVATE ); <br> <br>            // <br>            // Display candidate strings. <br>            // <br> <br>            DisplayCandStrings( gImeUIData.hListCand[ dwIndex ], lpCandList ); <br> <br>            GlobalUnlock( gImeUIData.hListCandMem[ dwIndex ] ); <br> <br>            CurNumCandList++; <br>        } <br>    } <br> <br>    // <br>    // Reset IME state. <br>    // <br> <br>    gImeUIData.ImeState |= IME_IN_CHOSECAND; <br> <br>exit2: <br> <br>    ImmReleaseContext( hwnd, hIMC ); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// void ImeUICloseCandidate() <br>// <br>// This handles WM_IME_NOTIFY message with <br>// wParam = IMN_CLOSECANDIDATE. <br>// <br>//********************************************************************** <br> <br>void ImeUICloseCandidate( HWND hwnd, LPARAM CandList ) <br>{ <br>    int         index; <br> <br>    // <br>    // Change window's caption title to normal. <br>    // <br> <br>    SetWindowText( hwnd, (LPSTR)szSteCompTitle ); <br> <br>    // <br>    // If the i-th bit on of CandList that means the i-th <br>    // candidate list should be closed. <br>    // <br> <br>    for( index = 0; index &lt; MAX_LISTCAND; index ++ ) <br>    { <br>        if (( CandList &amp; ( 1 &lt;&lt; index ) ) &amp;&amp; gImeUIData.hListCand[ index ]) <br>        { <br> <br>            // <br>            // Destroy the candidate window. <br>            // <br> <br>            DestroyWindow( gImeUIData.hListCand[ index ] ); <br> <br>            gImeUIData.hListCand[ index ] = NULL; <br> <br>            // <br>            // Free memory. <br>            // <br> <br>            GlobalFree( gImeUIData.hListCandMem[ index ] ); <br> <br>            gImeUIData.hListCandMem[ index ] = NULL; <br> <br>        } <br>    } <br> <br>    gImeUIData.ImeState &amp;= ~IME_IN_CHOSECAND; <br> <br>} <br> <br>//********************************************************************** <br>// <br>// void ImeUIChangeCandidate() <br>// <br>// This handles WM_IME_NOTIFY message with wParam = IMN_CHANGECANDIDATE. <br>// <br>//********************************************************************** <br> <br>void ImeUIChangeCandidate( HWND hwnd, LPARAM CandList ) <br>{ <br>    HIMC            hIMC; <br>    LPCANDIDATELIST lpCandList = NULL;          <br>    DWORD           dwIndex; <br>    DWORD     dwBufLen; <br>    LPSTR    lpStr; <br>    DWORD    i; <br>    RECT    rect; <br>    int    width = 0; <br>    DWORD    dwPreferNumPerPage; <br> <br> <br>    // <br>    // If fail to get input context, do nothing. <br>    // <br> <br>    if ( !( hIMC = ImmGetContext( hwnd ) ) ) <br>        return; <br> <br>    // <br>    // Determine which candidate list should be updated. <br>    // <br> <br>    for ( dwIndex = 0; dwIndex &lt; MAX_LISTCAND; dwIndex++ ) <br>        if ( CandList &amp; ( 1 &lt;&lt; dwIndex ) ) <br>            break; <br> <br>    // <br>    // If dwIndex == MAX_LISTCAND, then something wrong, do nothing. <br>    // <br> <br>    if ( dwIndex == MAX_LISTCAND ) <br>        return; <br> <br>    // <br>    // Determines how much memory space should be allocated to read in the <br>    // corresponding candidate list. <br>    // <br> <br>    if ( !( dwBufLen = ImmGetCandidateList( hIMC, dwIndex, lpCandList, 0 ) ) ) <br>goto exit2; <br> <br>    // <br>    // Relocate memory space. <br>    // <br> <br>    if ( !( gImeUIData.hListCandMem[ dwIndex ] = GlobalReAlloc( <br>    gImeUIData.hListCandMem[ dwIndex ], (int)dwBufLen, LPTR ) ) ) <br>goto exit2; <br> <br>    if ( !( lpStr =  <br>(LPSTR)GlobalLock( gImeUIData.hListCandMem[ dwIndex ] ) ) ) <br>    { <br>GlobalFree( gImeUIData.hListCandMem[ dwIndex ] ); <br>        gImeUIData.hListCandMem[ dwIndex ] = NULL; <br>goto exit2; <br>    } <br> <br>    lpCandList = (LPCANDIDATELIST) lpStr; <br> <br>    // <br>    // Reads in the corresponding candidate list. <br>    // <br> <br>    ImmGetCandidateList( hIMC, dwIndex, lpCandList, dwBufLen ); <br> <br>    // <br>    // Determines how many candidate strings per page. <br>    // <br> <br>    dwPreferNumPerPage = ( !lpCandList-&gt;dwPageSize ) ? <br>                         DEFAULT_CAND_NUM_PER_PAGE : <br>                         lpCandList-&gt;dwPageSize; <br>    //  <br>    // Determining maximum character length  the list box <br>    // will display by loopping through all candidate strings. <br>    // <br> <br>    for( i = 0; i &lt; lpCandList-&gt;dwCount; i++ ) <br>    { <br>        // <br>        // Get the pointer to i-th candidate string. <br>        // <br> <br>        lpStr = (LPSTR)lpCandList +  <br>                lpCandList-&gt;dwOffset[ i ]; <br> <br>        width = ( width &lt; lstrlen( lpStr ) ) ? lstrlen( lpStr ) : <br>                  width; <br> <br>    } <br> <br>    GetWindowRect( gImeUIData.hListCand[ dwIndex ] , (LPRECT) &amp;rect); <br> <br>    SetWindowPos( gImeUIData.hListCand[ dwIndex ], <br>  hwnd, <br>  rect.left, <br>  rect.top, <br>  ( width ) * cxMetrics + 10, <br>  (int)(dwPreferNumPerPage) * cyMetrics + 5, <br>  SWP_NOZORDER | SWP_NOACTIVATE ); <br>   <br> <br>    DisplayCandStrings( gImeUIData.hListCand[ dwIndex ], lpCandList ); <br> <br>    GlobalUnlock( gImeUIData.hListCandMem[ dwIndex ] ); <br> <br>exit2: <br> <br>    return; <br> <br>} <br> <br> <br>//*********************************************************************** <br>// <br>// void ImeUISetOpenStatus() <br>// <br>// This handles WM_IME_REPORT message with wParam = IR_NOTIFY &amp; <br>// lParam = IMC_SETOPENSTATUS. <br>// <br>//********************************************************************** <br> <br>void ImeUISetOpenStatus( HWND hwnd ) <br>{ <br>    int         i;       // Lopp counter <br>    HIMC        hIMC;    // Storage for input context handle. <br> <br>    // <br>    // If fail to get input context handle then do nothing <br>    // <br> <br>    if ( !( hIMC = ImmGetContext( hwnd ) ) ) <br>        return; <br> <br>    if ( ImmGetOpenStatus( hIMC ) ) <br>    { <br> <br>        // <br>        // If the IME conversion engine is open, here we change <br>        // window's caption title to DBCS composition mode. <br>        //  <br> <br>        SetWindowText( hwnd, (LPSTR)szSteCompTitle ); <br> <br>    } else <br>    { <br>        RECT    rect;         <br>         <br>        // <br>        // If the IME conversion engine is closed, here we <br>        // erase all already displayed composition chars if any, <br>        // change the window's caption title to normal. <br>        // <br> <br>        GetClientRect( hwnd, (LPRECT)&amp;rect ); <br>        InvalidateRect( hwnd, (LPRECT)&amp;rect, FALSE ); <br> <br>        SetWindowText( hwnd, (LPSTR)szSteTitle ); <br> <br>        // <br>        // Here we close and destroy all of candidate windows <br>        // if IME conversion engine is closed. <br>        // <br> <br>        for( i = 0; i &lt;= MAX_LISTCAND; i++ ) <br>        { <br>            if ( gImeUIData.hListCand[ i ] )  <br>            { <br>                DestroyWindow( gImeUIData.hListCand[ i ] ); <br>                gImeUIData.hListCand[ i ] = NULL; <br>                GlobalFree( gImeUIData.hListCandMem[ i ] ); <br>                gImeUIData.hListCandMem[ i ] = NULL; <br>            } <br>        } <br> <br>        // <br>        // Reset IMEUI's global data.  <br>        // <br> <br>        gImeUIData.uCompLen = 0; <br>        gImeUIData.ImeState = 0; <br> <br>        ResetCaret( hwnd ); <br> <br>    } <br> <br>    ImmReleaseContext( hwnd, hIMC ); <br>} <br> <br>//********************************************************************* <br>// <br>// void DisplayCompString() <br>// <br>// This displays composition string. <br>// <br>// This function supports only fixed pitch font. <br>// <br>//********************************************************************* <br> <br>void DisplayCompString( HWND hwnd, LPSTR lpStr, LPSTR lpStrAttr ) <br>{ <br>    HDC         hdc;                             <br>    int         StrLen = lstrlen( lpStr ); <br>    RECT        rect; <br>    DWORD       dwColor; <br>    int         i; <br>    BOOL        fDBCSTrailByte = FALSE; <br> <br> <br>    hdc = GetDC( hwnd ); <br> <br>    HideCaret( hwnd ); <br> <br>    // <br>    // Determine OPAQUE rect. <br>    // <br> <br>    rect.left = xPos * cxMetrics; <br>    rect.top  = yPos * cyMetrics; <br>    rect.bottom = rect.top + cyMetrics; <br>    rect.right = ( (int)gImeUIData.uCompLen &gt; StrLen ) ? <br>                 ( xPos + gImeUIData.uCompLen ) * cxMetrics: <br>                 ( xPos + StrLen ) * cxMetrics; <br>    <br>    // <br>    // This example we use red to display composition chars <br>    // with attribute 000, pink for attribute 001, <br>    // blue for attribute 010, green for attribute 011. <br>    // <br> <br>    // <br>    // Each composition character has different attribute. <br>    // We here use different kinds of color to represent attributes. <br>    // Red, pink, blue and green are for attribute 000, 001, 010 and 011, <br>    // respectively. <br>    // <br>   <br> <br>    dwColor = GetTextColor( hdc ); <br> <br>    if ( ( StrLen % 2 ) ) <br>    { <br>        if ( IsDBCSLeadByte( textbuf[ yPos ][ xPos + StrLen - 1 ] ) ) <br>        { <br>            textbuf[ yPos ][ xPos + StrLen ] = ' '; <br>            fDBCSTrailByte = TRUE; <br>        } <br>    } else <br>    { <br>        if ( !IsDBCSLeadByte( textbuf[ yPos ][ xPos + StrLen - 2 ] ) ) <br>        { <br>            if ( IsDBCSLeadByte( textbuf[ yPos ][ xPos + StrLen - 1 ] ) ) <br>    { <br>                textbuf[ yPos ][ xPos + StrLen ] = ' '; <br>                fDBCSTrailByte = TRUE; <br>            } <br>        } <br>    } <br> <br>    if ( !lpStrAttr ) <br>    { <br>        // <br>        // If there are not attribute array, here we use default color, RED, <br>        // to display all of composition characters. <br>        // <br> <br>        SetTextColor( hdc, CompColor[ 0 ] ); // default color <br> <br>        ExtTextOut( hdc, xPos * cxMetrics, yPos * cyMetrics, <br>                ETO_OPAQUE, &amp;rect, lpStr, StrLen, 0 ); <br> <br>    } else <br>    { <br> <br>        int  ColorIndex; <br> <br>        ExtTextOut( hdc, xPos * cxMetrics, yPos * cyMetrics, ETO_OPAQUE, <br>                    &amp;rect, NULL, 0, 0 ); <br> <br>        for( i = 0; *lpStr;) <br>        { <br>            int cnt = IsDBCSLeadByte(*lpStr) ? 2 : 1; <br> <br>            ColorIndex = ( ((int)*lpStrAttr) &lt; 0 ) ? 0 : (int)*lpStrAttr; <br>            ColorIndex = ( ColorIndex &gt; 3 ) ? 3 : ColorIndex; <br> <br>            SetTextColor( hdc, CompColor[ ColorIndex ] ); <br>             <br>            TextOut( hdc, ( i + xPos ) * cxMetrics, yPos * cyMetrics, <br>                     lpStr, cnt ); <br>            lpStr += cnt; <br>            lpStrAttr += cnt; <br>            i += cnt; <br>        } <br>    } <br> <br> <br>    SetTextColor( hdc, dwColor ); <br> <br>    if ( fDBCSTrailByte ) <br>    { <br>        TextOut( hdc, ( xPos + StrLen ) * cxMetrics, yPos * cyMetrics, <br>         " ", 1 ); <br>    } <br> <br>    SetCaretPos( ( xPos + StrLen ) * cxMetrics, yPos * cyMetrics ); <br> <br>    ShowCaret( hwnd ); <br> <br>    ReleaseDC( hwnd, hdc ); <br> <br>} <br> <br>//********************************************************************* <br>// <br>// void DisplayResultString() <br>// <br>// This displays result string. <br>// <br>// This function supports only fixed pitch font. <br>// <br>//********************************************************************* <br> <br>void DisplayResultString( HWND hwnd, LPSTR lpStr ) <br>{ <br> <br>    int         StrLen;         // Storage for string length. <br>    int         i;              // Loop counter. <br>    HDC         hdc;            // Display context handle. <br> <br>    StrLen = lstrlen( lpStr ); <br> <br>    // <br>    // If there is no room for compsoition string, discard it <br>    // <br> <br>    if ( xPos == ( LASTCOL - StrLen - 1 ) ) <br>        return; <br> <br>    // <br>    // if insert mode or during composition session, <br>    // move rest of line to the right by StrLen bytes. <br>    // <br> <br>    if ( fInsertMode ) <br>    { <br> <br>        for( i = LASTCOL; i &gt; xPos; i-- ) <br>            textbuf[ yPos ][ i ] = textbuf[ yPos ][ i - StrLen ]; <br> <br>        // <br>        // If the row ends on a lead byte, blank it out, <br>        // To do this we must first traverse the string starting <br>        // from a know character boundry until we reach the last column. <br>        // If the last column is a character boundry then the last  <br>        // character is either a string byte or a lead byte. <br>        // <br> <br>        for( i = xPos + StrLen; i &lt; LASTCOL; ) <br>        { <br>            if ( IsDBCSLeadByte( textbuf[ yPos ][ i ] ) ) <br>                i++; <br>            i++; <br>        } <br> <br>        if ( i == LASTCOL &amp;&amp; IsDBCSLeadByte( textbuf[ yPos ][ i ] ) ) <br>            textbuf[ yPos ][ LASTCOL ] = ' '; <br> <br>    } else <br>    { <br>        // <br>        // overtype mode <br>        // <br> <br>        if ( ( StrLen % 2 ) ) <br>        { <br>            if ( IsDBCSLeadByte( textbuf[ yPos ][ xPos + StrLen - 1 ] ) ) <br>                textbuf[ yPos ][ xPos + StrLen ] = ' '; <br>        } else <br>        { <br>            if ( !IsDBCSLeadByte( textbuf[ yPos ][ xPos + StrLen - 2 ] ) ) <br>            { <br>                // <br>                // Overtyping the current byte, plus the following byte <br>                // which could be a lead byte. <br>                // <br> <br>                if ( IsDBCSLeadByte( textbuf[ yPos ][ xPos + StrLen - 1 ] ) ) <br>                    textbuf[ yPos ][ xPos + StrLen ] = ' '; <br>            } <br>        } <br>    } <br> <br>    // <br>    // Store input character at current caret position. <br>    // <br> <br>    for( i = 0; i &lt;= LASTCOL &amp;&amp; *lpStr; i++ ) <br>        textbuf[ yPos ][ xPos + i ] = *lpStr++; <br> <br>    // <br>    // Display input character <br>    // <br> <br> <br>    hdc = GetDC( hwnd ); <br> <br>    HideCaret( hwnd ); <br> <br>    // <br>    // Displays result string with normal color. <br>    // <br> <br>    TextOut( hdc, xPos *cxMetrics, yPos * cyMetrics, <br>             &amp;( textbuf[ yPos][xPos] ), MAXCOL - xPos ); <br> <br> <br>    ShowCaret( hwnd ); <br> <br>    ReleaseDC( hwnd, hdc ); <br> <br>    // <br>    // Reset Caret position <br>    // <br> <br>    xPos += StrLen; <br> <br>    if ( xPos &gt; LASTCOL ) <br>        xPos = LASTCOL; <br> <br>    ResetCaret( hwnd ); <br> <br>    gImeUIData.uCompLen = 0; <br> <br>} <br> <br>//********************************************************************** <br>// <br>// void RestoreImeUI() <br>// <br>// This repaints all displayed composition string if need. <br>// Main window procedure will call this upon receiving <br>// WM_PAINT message. <br>// <br>//********************************************************************** <br> <br>void RestoreImeUI( HWND hwnd ) <br>{ <br>    HIMC        hIMC;           // Storage for input context handle. <br>    DWORD       dwBufLen;       //  <br> <br>     <br>    // <br>    // If fail to get input context handle then do nothing. <br>    // <br> <br>    if ( !( hIMC = ImmGetContext( hwnd ) ) ) <br>        return; <br> <br>    // <br>    // If IME conversion engine is open and there are any composition <br>    // string in the context then we redisplay them. <br>    // <br> <br>    if ( ImmGetOpenStatus( hIMC ) &amp;&amp; gImeUIData.ImeState &amp;&amp; <br>         ( dwBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, <br>                      (void FAR*)NULL, 0l ) ) &gt; 0 ) <br>    { <br>        LPSTR       lpCompStr;     // Pointer to composition string <br>        HLOCAL      hMem;          // Storage for memory handle. <br>        LPSTR       lpCompStrAttr; // Pointer to composition string's attribute <br>        DWORD       dwBufLenAttr;  //  <br>        HLOCAL      hMemAttr;      // Memory handle for composition string's <br>                                   // attributes. <br> <br>        // <br>        // If fail to allocate and lock memory space for reading in <br>        // the composition string then do nothing. <br>        // <br> <br>        if ( !( hMem = LocalAlloc( LPTR, (int)dwBufLen + 1 ) ) ) <br>            goto exit2; <br> <br>        if( !( lpCompStr = (LPSTR) LocalLock( hMem ) ) ) <br>        { <br>            LocalFree( hMem ); <br>            goto exit2; <br>        } </code></pre>
<p>
</p>
<pre><code><br>        // <br>        // Get composition string and redisplay them. <br>        // <br> <br>        if ( ImmGetCompositionString( hIMC, GCS_COMPSTR, lpCompStr, <br>                                      dwBufLen ) &gt; 0 ) <br>        { <br> <br>            // <br>            // MAke sure whether we need to handle composition string's <br>            // attributes. <br>            // <br> <br>            if ( ( dwBufLenAttr = ( ImmGetCompositionString( hIMC, <br>                       GCS_COMPATTR, (void FAR*)NULL, 0l ) ) ) &gt; 0 ) <br>            { <br>                // <br>                // If fail to allocate and lock memory space for reading in <br>                // the composition string's attribute then we assume <br>                // no attribute array. <br>                // <br> <br>                if ( !( hMemAttr = LocalAlloc(LPTR, (int)dwBufLenAttr + 1 ))) <br>                    goto nothing; <br> <br>                if ( !( lpCompStrAttr = (LPSTR) LocalLock( hMemAttr ) ) ) <br>                { <br>                    LocalFree( hMemAttr ); <br>                    goto nothing; <br>                } <br> <br>                ImmGetCompositionString( hIMC, GCS_COMPATTR, lpCompStrAttr, <br>                                         dwBufLenAttr ); <br> <br>                lpCompStrAttr[ dwBufLenAttr ] = 0; <br>            } else <br>            { <br>nothing: <br>                lpCompStrAttr = NULL; <br>            } <br> <br> <br>            lpCompStr[ dwBufLen ] = 0; <br> <br>            DisplayCompString( hwnd, lpCompStr, lpCompStrAttr ); <br>      <br>        } <br> <br>        LocalUnlock( hMem ); <br>        LocalFree( hMem ); <br>         <br>        if ( lpCompStrAttr ) <br>        { <br>            LocalUnlock( hMemAttr ); <br>            LocalFree( hMemAttr ); <br>        } <br> <br> <br>    } <br> <br>exit2: <br> <br>    ImmReleaseContext( hwnd, hIMC ); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// void ImeUIMove() <br>// <br>// Handler routine of WM_MOVE message. <br>// <br>//********************************************************************* <br> <br>void ImeUIMoveCandWin( HWND hwnd ) <br>{ <br> <br>    if ( gImeUIData.ImeState &amp; IME_IN_CHOSECAND ) <br>    { <br>        POINT           point;          // Storage for caret position. <br>        int             i;              // loop counter. <br>        int             NumCandWin;     // Storage for num of cand win. <br>        RECT            rect;           // Storage for client rect. <br> <br>        // <br>        // If current IME state is in chosing candidate, here we <br>        // move all candidate windows, if any, to the appropriate <br>        // position based on the parent window's position. <br>        // <br> <br>        NumCandWin = 0; <br> <br>        GetCaretPos( (LPPOINT)&amp;point ); <br>        ClientToScreen( hwnd, (LPPOINT)&amp;point ); <br> <br>        for ( i = 0; i &lt; MAX_LISTCAND ; i++ ) <br>        { <br>            if ( gImeUIData.hListCand[ i ] ) <br>            { <br>                GetClientRect( gImeUIData.hListCand[ i ], &amp;rect );                 <br>                 <br>                MoveWindow( gImeUIData.hListCand[ i ],  <br>                            point.x + X_INDENT * NumCandWin, <br>                            point.y + Y_INDENT * NumCandWin + cyMetrics, <br>                            ( rect.right - rect.left + 1 ), <br>                            ( rect.bottom - rect.top + 1 ), TRUE ); <br> <br>                NumCandWin++; <br>            } <br>        } <br>    } <br>} <br> <br>//********************************************************************** <br>// <br>// void ImeUIClearData() <br>// <br>// Handler routine of WM_IME_SELECT message. <br>// <br>//********************************************************************** <br> <br>void ImeUIClearData( HWND hwnd ) <br>{ <br> <br>    RECT            rect;            <br>    int             i; <br>    <br>    SetWindowText( hwnd, (LPSTR)szSteTitle ); <br> <br>    // <br>    // If user switches to other IME, here we destroy all candidate <br>    // windows which has been opened and erase all composition <br>    // chars if any. <br>    // <br> <br>    for( i = 0; i &lt; MAX_LISTCAND; i++ ) <br>    { <br>        if ( gImeUIData.hListCand[ i ] ) <br>        { <br>            // <br>            // The i-th candidate list has already been displayed, <br>            // destroy it and free memory which stores candidate <br>            // strings. <br>            // <br> <br>            DestroyWindow( gImeUIData.hListCand[ i] ); <br>            GlobalFree( gImeUIData.hListCandMem[ i ] ); <br> <br>            gImeUIData.hListCand[ i ] = <br>            gImeUIData.hListCandMem[ i ] = NULL; <br> <br>        } <br>    } <br> <br>    // <br>    // Update client area. <br>    // <br> <br>    GetClientRect( hwnd, (LPRECT)&amp;rect ); <br> <br>    InvalidateRect( hwnd, (LPRECT)&amp;rect, FALSE ); <br> <br> <br>    // <br>    // Reset IMEUI's global data. <br>    // <br> <br>    gImeUIData.uCompLen = gImeUIData.ImeState = 0; <br> <br>    // <br>    // Reset caret to the original position. <br>    // <br> <br>    HideCaret( hwnd ); <br>    ResetCaret( hwnd ); <br>    ShowCaret( hwnd ); <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
