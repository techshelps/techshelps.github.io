<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6399"></a>MAIN.C</h2>
<pre><code>/************************************************************************ <br>* <br>* Title: <br>* <br>*   STED.C - IME Full-aware Simple Text Editor (DBCS version) <br>* <br>* Purpose: <br>* <br>*   Sample program for DBCS programming and IME full-aware aappliction. <br>* <br>* Synopsis: <br>* <br>*   This program is designed as a bare-bone example to demonstrate the <br>*   basic elements of DBCS-enabling, and how to design an IME full-aware <br>*   application. <br>* <br>*   The data structure is a fixed-size 2-dimensional byte array.  The <br>*   font is the fixed-pitch system font.  Rudimentary text editing <br>*   functions, such as the basic cursor movements, insertion, deletion, <br>*   have been implemented. <br>* <br>*   When you run this program in a Far East Windows environment, it <br>*   should be apparent that it doesn't handle DBCS character very well. <br>*   It is your job to locate and modify the pieces inside this program <br>*   that need to be DBCS-enabled. <br>* <br>* DBCS-enabling notes: <br>* <br>*   This version of STE is DBCS-enabled with respect to character input, <br>*   caret shape and movement, and mouse clicking.  It should work on <br>*   any version of Far East Windows since 3.0. <br>* <br>*   As far as source code maintenance goes, there are generally two <br>*   approaches. <br>* <br>*   The first is to add DBCS enabling code under '#ifdef DBCS'.  The <br>*   advantage of this approach is that it keeps the DBCS enabling code <br>*   distinct from the SBCS, so it's easier to add them in, and also to <br>*   remove them later.  (For example, when you want to replace DBCS <br>*   enabling with Unicode enabling.)  The drawback is that because the <br>*   DBCS and the SBCS logic are not integrated, they can easily get out <br>*   of sync (as the SBCS code evolves.) <br>* <br>*   The second approach, which is adopted by this sample app, is to <br>*   integrate DBCS enabling with SBCS.  It takes longer to do, but <br>*   the resulting source is easier to maintain.  Since IsDBCSLeadByte <br>*   is at the heart of any DBCS-enabling logic, an additional speed up <br>*   for generating an SBCS-only version is to define that function as <br>*   FALSE, and let the compiler optimize the DBCS logic away. <br>* <br>* IME Full-Aware notes: <br>* <br>*   This version of STE is an IME full-aware application with most of <br>*   IME UI capiabilities to display IME UI by itself. It should work <br>*   on any version of Far Windows since 4.0. <br>* <br>*   This kind of application typically wants to be fully responsible to <br>*   display any information given by IME. Ii will handle the input context <br>*   by itself and duisplay any necessary information given by the <br>*   input context not using IME UI. <br>* <br>* History: <br>* <br>*   17-Aug-1992  created <br>*   28-Sep-1992  added DBCS-enabling <br>*   30-Sep-1992  bug fixes <br>*   25-Mar-1994  added IME full-aware logics <br>* <br>************************************************************************/ <br> <br>#include &lt;assert.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;imm.h&gt; <br>#include "fullime.h" <br> <br>// <br>// Function prototype <br>// <br> <br>/************************************************************************ <br>* <br>*   SteRegister - standard class registration routine <br>* <br>************************************************************************/ <br> <br>int SteRegister( HANDLE hInstance ) <br>{ <br>    long WINAPI SteWndProc( HWND, UINT, UINT, LONG ); <br> <br>    PWNDCLASS pWndClass; <br> <br>    pWndClass=(PWNDCLASS)LocalAlloc(LPTR, sizeof(WNDCLASS)); <br> <br>    pWndClass-&gt;hCursor       = LoadCursor( NULL, IDC_IBEAM ); <br>    pWndClass-&gt;hIcon         = LoadIcon( hInstance, MAKEINTRESOURCE(ID_ICON)); <br>    pWndClass-&gt;lpszMenuName  = MAKEINTRESOURCE(ID_MENU); <br>    pWndClass-&gt;hInstance     = hInstance; <br>    pWndClass-&gt;lpszClassName = (LPSTR)szSteClass; <br>    pWndClass-&gt;lpfnWndProc   = SteWndProc; <br>    pWndClass-&gt;hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    pWndClass-&gt;style         = CS_BYTEALIGNCLIENT | CS_CLASSDC; <br> <br>    if ( !RegisterClass( (LPWNDCLASS)pWndClass ) ) <br>return FALSE; <br> <br>    pWndClass-&gt;hCursor       = LoadCursor( NULL,IDC_ARROW ); <br>    pWndClass-&gt;hIcon         = NULL; <br>    pWndClass-&gt;lpszMenuName  = NULL; <br>    pWndClass-&gt;hInstance     = hInstance; <br>    pWndClass-&gt;lpszClassName = (LPSTR)szCandClass; <br>    pWndClass-&gt;lpfnWndProc   = CandWndProc; <br>    pWndClass-&gt;hbrBackground = GetStockObject( LTGRAY_BRUSH ); <br>    pWndClass-&gt;style         = CS_HREDRAW | CS_VREDRAW; <br> <br>    if ( !RegisterClass( (LPWNDCLASS)pWndClass ) ) <br>return FALSE; <br> <br>    LocalFree( (HANDLE)pWndClass ); <br> <br>    return TRUE; <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   WinMain <br>* <br>************************************************************************/ <br> <br>int PASCAL WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpszCmdLine, <br>    int nCmdShow ) <br>{ <br>    MSG msg; <br>    HWND hWnd; <br> <br>    LoadString( hInstance, IDS_CLASS, szSteClass, 14 ); <br>    LoadString( hInstance, IDS_TITLE, szSteTitle, 55 ); <br>    LoadString( hInstance, IDS_CANDUI, szSteCandUIClass, 12 ); <br>    LoadString( hInstance, IDS_COMPTITLE, szSteCompTitle, 55 ); <br>    LoadString( hInstance, IDS_CANDTITLE, szSteCandTitle, 55 ); <br>    LoadString( hInstance, IDS_CANDCLASS, szCandClass, 20 ); <br> <br>    if ( !hPrevInstance ) <br>if ( !SteRegister( hInstance ) ) <br>    return FALSE; <br> <br>    if ( !(hWnd = CreateWindow( szSteClass, szSteTitle, <br>  WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, <br>  CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, (HWND)NULL, <br>  (HMENU)NULL, hInstance, NULL)) ) <br>return FALSE; <br> <br>    // <br>    // Create window with just enough client space for the text buffer <br>    // <br> <br>    SetWindowPos( hWnd, 0, 0, 0, <br>MAXCOL*cxMetrics + GetSystemMetrics(SM_CXBORDER)*2, <br>MAXROW*cyMetrics + GetSystemMetrics(SM_CYBORDER)*2 <br> + GetSystemMetrics(SM_CYCAPTION) <br> + GetSystemMetrics(SM_CYMENU), <br>SWP_NOZORDER ); <br>    ShowWindow( hWnd, nCmdShow ); <br> <br>    // <br>    // IME initial state. <br>    // <br> <br>    gImeUIData.ImeState = 0; <br> <br>    while ( GetMessage( &amp;msg, NULL, 0, 0 ) ) { <br>TranslateMessage( &amp;msg ); <br>DispatchMessage( &amp;msg ); <br>    } <br> <br>    return msg.wParam; <br>} <br> <br>//********************************************************************** <br>// <br>// SteIMEOpenClose() <br>// <br>// This routines calls IMM API to open or close IME. <br>// <br>//********************************************************************** <br> <br>void SteImeOpenClose( HWND hWnd, BOOL fFlag ) <br>{ <br>HIMC            hIMC; <br> <br>// <br>// If fFlag is true then open IME; otherwise close it. <br>// <br> <br>        if ( !( hIMC = ImmGetContext( hWnd ) ) ) <br>return; <br> <br>        ImmSetOpenStatus( hIMC, fFlag ); <br> <br>        ImmReleaseContext( hWnd, hIMC ); <br> <br>} <br> <br> <br>//********************************************************************* <br>// <br>// WM_CREATE message handler <br>// <br>//********************************************************************* <br> <br> <br>void SteCreate( HWND hWnd ) <br>{ <br>    HDC hdc; <br>    TEXTMETRIC tm; <br>    int        i; <br>    WORD       patern = 0xA4A4; <br>    SIZE       size; <br>    HFONT      hFont; <br>    LOGFONT    lFont; <br> <br>    // <br>    // Note that this window has a class DC <br>    // <br> <br>    hdc = GetDC( hWnd ); <br> <br>    // <br>    // Select fixed pitch system font and get its text metrics <br>    // <br> <br>    hfntFixed = GetStockObject( SYSTEM_FIXED_FONT ); <br>    hfntOld = SelectObject( hdc, hfntFixed ); <br>    GetTextMetrics( hdc, &amp;tm ); <br>    ReleaseDC( hWnd, hdc ); <br> <br>    GetTextExtentPoint( hdc, (LPSTR)&amp;patern, sizeof( WORD), <br>(LPSIZE) &amp;size ); <br> <br>//    cxMetrics = tm.tmAveCharWidth; <br>//    cyMetrics = tm.tmHeight; <br> <br>    cxMetrics = (UINT) size.cx / 2; <br>    cyMetrics = (UINT) size.cy; <br> <br>    // <br>    // Determine the version of DBCS Windows from system font charset ID. <br>    // Then hardcode a DBCS character value for the 'Pattern/DBCS' command. <br>    // The value is the Han character for 'door' or 'gate', which is <br>    // left-right symmetrical. <br>    // <br> <br>    switch( tm.tmCharSet ) <br>    { <br>    case SHIFTJIS_CHARSET: <br>DBCSFillChar = 0x96e5; <br>break; <br> <br>    case HANGEUL_CHARSET: <br>DBCSFillChar = 0xdaa6; <br>break; <br> <br>    case CHINESEBIG5_CHARSET: <br>DBCSFillChar = 0xaaf9; <br>break; <br> <br>    default: <br>DBCSFillChar = 0x7071;  // 'pq' <br>break; <br>    } <br> <br>    //                    <br>    // Initialize caret width.  Fat in INSERT mode, skinny in OVERTYPE mode. <br>    // <br> <br>    fInsertMode = FALSE; <br>    CaretWidth = cxOverTypeCaret = GetSystemMetrics( SM_CXBORDER ); <br> <br>    // <br>    // Sets the logical font to be used to display characters in the  <br>    // composition window. Especially for at caret or near caret operation,  <br>    // application should set composition font. <br>    // <br>    // If Application provides user to dynamicly change font, each time after <br>    // user change font, application should set composition font again. <br>    // <br> <br>    if ( ( hFont = (HFONT)SendMessage( hWnd, WM_GETFONT, 0, 0L ) ) != NULL ) <br>    { <br>        if ( GetObject( hFont, sizeof(LOGFONT), (LPVOID)&amp;lFont ) ) <br>        { <br>            HIMChImc; <br> <br>            if ( (  hImc = ImmGetContext( hWnd ) ) ) <br>    { <br>        ImmSetCompositionFont( hImc, &amp;lFont ); <br>ImmReleaseContext( hWnd, hImc ); <br>    } <br>} <br>    } <br> <br>    // <br>    // Get the property and apiabilities of current keyboard layout(IME). <br>    // If the keyboard layout is US, the return value will be zero. <br>    // <br> <br>    gImeUIData.fdwProperty = ImmGetProperty( GetKeyboardLayout(0), <br>     IGP_PROPERTY ); <br> <br>    // <br>    // Initialize candidate list window array. <br>    // <br> <br>    for( i = 0; i &lt; MAX_LISTCAND; i++ ) <br>    { <br>         gImeUIData.hListCand[ i ] = NULL; <br>         gImeUIData.hListCandMem[ i ] = NULL; <br>    } <br> <br> <br>    PostMessage( hWnd, WM_COMMAND, IDC_CLEAR, 0L ); <br> <br> <br>    // <br>    // Initialise the current keyboard layout. <br>    // <br>    hCurKL = GetKeyboardLayout(0L); <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   ResetCaret - Reset caret shape to match input mode (overtype/insert) <br>* <br>************************************************************************/ <br> <br>void ResetCaret( HWND hWnd ) <br>{ <br> <br>    HideCaret( hWnd ); <br>    DestroyCaret(); <br>    CreateCaret( hWnd, <br> NULL, <br> (fInsertMode &amp;&amp; IsDBCSLeadByte( textbuf[yPos][xPos] )) ? <br>   CaretWidth*2 : CaretWidth, <br> cyMetrics ); <br>    SetCaretPos( xPos * cxMetrics, yPos * cyMetrics ); <br> <br>    if ( !( gImeUIData.fdwProperty &amp; IME_PROP_AT_CARET ) &amp;&amp; <br>         !( gImeUIData.fdwProperty &amp; IME_PROP_SPECIAL_UI ) ) <br>    { <br>// near caret. <br>        SetIMECompFormPos( hWnd ); <br>    } <br>  <br>    ShowCaret( hWnd ); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// SetIMECompFormPos() <br>// <br>//********************************************************************** <br> <br>void SetIMECompFormPos( HWND hWnd ) <br>{ <br> <br>    HIMC hIMC = ImmGetContext(hWnd); <br>    POINT   point; <br>    COMPOSITIONFORM CompForm; <br> <br>    GetCaretPos( &amp;point ); <br> <br>    CompForm.dwStyle = CFS_POINT; <br> <br>    CompForm.ptCurrentPos.x = (long) point.x; <br>    CompForm.ptCurrentPos.y = (long) point.y; <br> <br>    if ( hIMC ) <br>ImmSetCompositionWindow(hIMC,&amp;CompForm); <br>    ImmReleaseContext( hWnd , hIMC); <br> <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   SteCommand - WM_COMMAND handler <br>* <br>************************************************************************/ <br> <br> <br>void SteCommand( HWND hWnd, UINT cmd, LPARAM lParam ) <br>{ <br>    switch( cmd ) <br>    { <br>    case IDC_CLEAR: <br> <br> <br>// <br>// Blank out text buffer.  Return caret to home position <br>// <br> <br>for ( yPos = FIRSTROW; yPos &lt;= LASTROW; yPos++ ) <br>    for ( xPos = FIRSTCOL; xPos &lt;= LASTCOL; xPos++ ) <br>textbuf[yPos][xPos] = ' '; <br>break; <br> <br>    case IDC_ANSIFILL: <br>    case IDC_DBCSFILL: <br> <br>// <br>// Fill text buffer with ANSI or DBCS pattern <br>// <br> <br>for ( yPos = FIRSTROW; yPos &lt;= LASTROW; yPos++ ) <br>    for ( xPos = FIRSTCOL; xPos &lt;= LASTCOL; xPos++ ) <br>if ( cmd == IDC_ANSIFILL ) <br>    textbuf[yPos][xPos] = 'a'; <br>else { <br>    textbuf[yPos][xPos]   = HIBYTE(DBCSFillChar); <br>    textbuf[yPos][++xPos] = LOBYTE(DBCSFillChar); <br>} <br>break; <br>     <br>    // <br>    // The following messages are to control IME. <br>    // <br> <br>    case IDC_OPENIME: <br> <br>SteImeOpenClose( hWnd, TRUE ); <br>goto RETURN; <br> <br>    case IDC_CLOSEIME: <br> <br>SteImeOpenClose( hWnd, FALSE ); <br>goto RETURN; <br> <br>    } <br> <br>    yPos = FIRSTROW; <br>    xPos = FIRSTCOL; <br> <br>    InvalidateRect( hWnd, (LPRECT)NULL, TRUE ); <br>    ResetCaret(hWnd); <br> <br>RETURN: <br>  <br>    return; <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   IsDBCSTrailByte - returns TRUE if the given byte is a DBCS trail byte <br>* <br>*                     The algorithm searchs backward in the string, to some <br>*                     known character boundary, counting consecutive bytes <br>*                     in the lead byte range. An odd number indicates the <br>*                     current byte is part of a two byte character code. <br>* <br>*   INPUT: PCHAR  - pointer to a preceding known character boundary. <br>*          PCHAR  - pointer to the character to test. <br>* <br>*   OUTPUT:BOOL   - indicating truth of p==trailbyte. <br>* <br>************************************************************************/ <br> <br>BOOL IsDBCSTrailByte( char *base, char *p ) <br>{ <br>    int lbc = 0;    // lead byte count <br> <br>    assert(base &lt;= p); <br> <br>    while ( p &gt; base ) { <br>if ( !IsDBCSLeadByte(*(--p)) ) <br>    break; <br>lbc++; <br>    } <br> <br>    return (lbc &amp; 1); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// BOOL MoveCaret() <br>// <br>//********************************************************************** <br> <br>BOOL MoveCaret( HWND hwnd ) <br>{ <br>    HIMC        hIMC; <br>    BOOL        retVal = TRUE; <br> <br>    if ( !( hIMC = ImmGetContext( hwnd ) ) ) <br>return retVal;                 <br> <br>    if ( ImmGetCompositionString( hIMC, GCS_CURSORPOS, <br>  (void FAR *)NULL, 0 ) ) <br>retVal = FALSE;                                     <br> <br>    ImmReleaseContext( hwnd, hIMC ); <br> <br>    return retVal; <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   VirtualKeyHandler - WM_KEYDOWN handler <br>* <br>* <br>*   INPUT:  HWND - handle to the window for repainting output. <br>*           UINT - virtual key code. <br>* <br>************************************************************************/ <br> <br>void VirtualKeyHandler( HWND hWnd, UINT wParam ) <br>{ <br>    int i; <br>    HDC hdc; <br>    static int delta = 1; <br> <br>    if ( ( gImeUIData.ImeState &amp; IME_IN_CHOSECAND ) || <br>         ( gImeUIData.ImeState &amp; IME_IN_COMPOSITION &amp;&amp; !MoveCaret( hWnd ) ) ) <br>return; <br> <br>    switch( wParam ) <br>    { <br>    case VK_HOME:   // beginning of line <br>xPos = FIRSTCOL; <br>break; <br> <br>    case VK_END:    // end of line <br>xPos = LASTCOL; <br>goto check_for_trailbyte; <br> <br>    case VK_RIGHT: <br> <br>if ( IsDBCSLeadByte( textbuf[yPos][xPos] ) ){ <br>    if (xPos==LASTCOL - 1) break;  //last character don't move <br>    xPos += 2;                     //skip 2 for DB Character <br>} <br>else <br>    xPos = min( xPos+1, LASTCOL ); <br>break; <br> <br>    case VK_LEFT: <br> <br>xPos = max( xPos-1, FIRSTCOL ); <br> <br>check_for_trailbyte: <br> <br>if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ) <br>    xPos--; <br>break; <br> <br>    case VK_UP: <br> <br>yPos = max( yPos-1, FIRSTROW ); <br>goto Virtical_Check_Trail; <br> <br>    case VK_DOWN: <br> <br>yPos = min( yPos+1, LASTROW ); <br> <br>Virtical_Check_Trail: <br> <br>if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ){ <br>   if (xPos&lt;LASTCOL){ <br>      xPos+=delta; <br>      delta *= -1; <br>   } <br>   else <br>      xPos--; <br>} <br>break; <br> <br> <br>    case VK_INSERT: <br> <br> <br>// <br>// Change caret shape to indicate insert/overtype mode <br>// <br> <br>fInsertMode = !fInsertMode; <br>CaretWidth = fInsertMode ? cxMetrics : cxOverTypeCaret; <br>break; <br> <br>     case VK_BACK:   // backspace <br> <br>if ( xPos &gt; FIRSTCOL ) { <br>    xPos--; <br> <br>    // <br>    // DB Character so backup one more to allign on boundary <br>    // <br>    if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ) <br>xPos--; <br>// <br>// Fall Through to VK_DELETE to adjust row <br>// <br>} <br>else     //FIRST COLUMN  don't backup -- this would change for wrapping <br>   break; <br> <br>    case VK_DELETE: <br> <br> <br>if ( !IsDBCSLeadByte( textbuf[yPos][xPos] ) ) { <br> <br>    // <br>    // Move rest of line left by one, then blank out last character <br>    // <br> <br>    for ( i = xPos; i &lt; LASTCOL; i++ ) <br>textbuf[yPos][i] = textbuf[yPos][i+1]; <br>    textbuf[yPos][LASTCOL] = ' '; <br> <br>} else { <br> <br>    // <br>    // Move line left by two bytes, blank out last two bytes <br>    // <br> <br>    for ( i = xPos; i &lt; LASTCOL-1; i++ ) <br>textbuf[yPos][i] = textbuf[yPos][i+2]; <br>    textbuf[yPos][LASTCOL-1] = ' '; <br>    textbuf[yPos][LASTCOL]   = ' '; <br>} <br> <br>// <br>// Repaint the entire line <br>// <br> <br>hdc = GetDC( hWnd ); <br>HideCaret( hWnd ); <br>TextOut( hdc, 0, yPos*cyMetrics, textbuf[yPos], MAXCOL ); <br>ReleaseDC( hWnd, hdc ); <br>break; <br> <br>    case VK_TAB:    // tab  -- tabs are column allignment not character <br>{ <br> int xTabMax = xPos + TABSTOP; <br> int xPosPrev; <br> <br> do { <br>     xPosPrev = xPos; <br>     SendMessage( hWnd, WM_KEYDOWN, VK_RIGHT, 1L ); <br> } while ( (xPos % TABSTOP) &amp;&amp; <br>   (xPos &lt; xTabMax) &amp;&amp; <br>   (xPos != xPosPrev)); <br> <br>} <br>break; <br> <br>    case VK_RETURN: // linefeed <br>yPos = min( yPos+1, LASTROW ); <br>xPos = FIRSTCOL; <br>break; <br>    } <br> <br>    ResetCaret( hWnd ); <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   StoreChar - Stores one SBCS character into text buffer and advances <br>*               cursor <br>* <br>************************************************************************/ <br> <br>void StoreChar( HWND hWnd, UCHAR ch ) <br>{ <br>    int i; <br>    HDC hdc; <br> <br>    // <br>    // If insert mode, move rest of line to the right by one <br>    // <br> <br>    if ( fInsertMode ) { <br>for ( i = LASTCOL; i &gt; xPos; i-- ) <br>    textbuf[yPos][i] = textbuf[yPos][i-1]; <br> <br>// <br>// If the row ends on a lead byte, blank it out <br>// To do this we must first traverse the string <br>// starting from a known character boundry until <br>// we reach the last column. If the last column <br>// is a character boundry then the last character <br>// is either a single byte or a lead byte <br>// <br> <br>for ( i = xPos+1; i &lt; LASTCOL; ) { <br>    if ( IsDBCSLeadByte( textbuf[yPos][i] ) ) <br>i++; <br>    i++; <br>} <br>if (i==LASTCOL) <br>   if ( IsDBCSLeadByte( textbuf[yPos][LASTCOL] ) ) <br>       textbuf[yPos][LASTCOL] = ' '; <br> <br>    } else {  // overtype mode <br> <br>if ( IsDBCSLeadByte( textbuf[yPos][xPos] ) ) <br> <br>    // <br>    // Blank out trail byte <br>    // <br> <br>    textbuf[yPos][xPos+1] = ' '; <br> <br>    // <br>    // or shift line left on character and blank last column <br>    // <br>    // for ( i = xPos+1; i &lt; LASTCOL; i++ ) <br>    //     textbuf[yPos][i] = textbuf[yPos][i+1]; <br>    // textbuf[yPos][LASTCOL] = ' '; <br> <br>    } <br> <br>    // <br>    // Store input character at current caret position <br>    // <br> <br>    textbuf[yPos][xPos] = ch; <br> <br> <br>    // <br>    // Display input character. <br>    // <br> <br>    hdc = GetDC( hWnd ); <br>    HideCaret( hWnd ); <br>    TextOut( hdc, xPos*cxMetrics, yPos*cyMetrics, <br>     &amp;(textbuf[yPos][xPos]), MAXCOL-xPos ); <br>    ShowCaret( hWnd ); <br>    ReleaseDC( hWnd, hdc ); <br> <br>    SendMessage( hWnd, WM_KEYDOWN, VK_RIGHT, 1L ); <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   StoreDBCSChar - Stores one DBCS character into text buffer and <br>*                   advances cursor <br>* <br>************************************************************************/ <br> <br>void StoreDBCSChar( HWND hWnd, WORD ch ) <br>{ <br>    int i; <br>    HDC hdc; <br> <br>    // <br>    // If there is no room for a DBCS character, discard it <br>    // <br> <br>    if ( xPos == LASTCOL ) <br>return; <br> <br>    // <br>    // If insert mode, move rest of line to the right by two <br>    // <br> <br>    if ( fInsertMode ) { <br>for ( i = LASTCOL; i &gt; xPos+1; i-- ) <br>    textbuf[yPos][i] = textbuf[yPos][i-2]; <br> <br>// <br>// If the row ends on a lead byte, blank it out <br>// To do this we must first traverse the string <br>// starting from a known charcter boundry until <br>// we reach the last column. If the last column <br>// is not a trail byte then it is a single byte <br>// or a lead byte <br>// <br> <br>for ( i = xPos+2; i &lt; LASTCOL; ) { <br>    if ( IsDBCSLeadByte( textbuf[yPos][i] ) ) <br>i++; <br>    i++; <br>} <br>if (i==LASTCOL) <br>   if (IsDBCSLeadByte( textbuf[yPos][LASTCOL] ) ) <br>textbuf[yPos][LASTCOL] = ' '; <br> <br>    } else {  // overtype mode <br> <br>if ( !IsDBCSLeadByte( textbuf[yPos][xPos] ) ) <br> <br>    // <br>    // Overtyping the current byte, plus the following byte, <br>    // which could be a lead byte. <br>    // <br> <br>    if ( IsDBCSLeadByte( textbuf[yPos][xPos+1] ) ) <br>textbuf[yPos][xPos+2] = ' '; <br>    } <br> <br>    // <br>    // Store input character at current caret position <br>    // <br> <br>    textbuf[yPos][xPos]   = LOBYTE(ch);     // lead byte <br>    textbuf[yPos][xPos+1] = HIBYTE(ch);     // trail byte <br> <br>    // <br>    // Display input character. <br>    // <br> <br>    hdc = GetDC( hWnd ); <br>    HideCaret( hWnd ); <br>    TextOut( hdc, xPos*cxMetrics, yPos*cyMetrics, <br>     &amp;(textbuf[yPos][xPos]), MAXCOL-xPos ); <br>    ShowCaret( hWnd ); <br>    ReleaseDC( hWnd, hdc ); <br> <br>    SendMessage( hWnd, WM_KEYDOWN, VK_RIGHT, 1L ); <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   CharHandler - WM_CHAR handler <br>* <br>************************************************************************/ <br> <br>void CharHandler( HWND hWnd, WORD wParam ) <br>{ <br>    unsigned char ch = (unsigned char)wParam; <br> <br>    // <br>    // Because DBCS characters are usually generated by IMEs (as two <br>    // PostMessages), if a lead byte comes in, the trail byte should <br>    // arrive very soon after.  We wait here for the trail byte and <br>    // store them into the text buffer together. <br> <br>    if ( IsDBCSLeadByte( ch ) ) { <br> <br>// <br>// Wait an arbitrary amount of time for the trail byte to <br>// arrive.  If it doesn't, then discard the lead byte. <br>// <br>// This could happen if the IME screwed up.  Or, more likely, <br>// the user generated the lead byte through ALT-numpad. <br>// <br> <br>MSG msg; <br>int i = 10; <br> <br>while (!PeekMessage((LPMSG)&amp;msg, hWnd, WM_CHAR, WM_CHAR, PM_REMOVE)) { <br>    if ( --i == 0 ) <br>return; <br>    Yield(); <br>} <br> <br>StoreDBCSChar( hWnd,  (WORD)(((unsigned)(msg.wParam)&lt;&lt;8) | (unsigned)ch )); <br> <br>    } else { <br> <br>switch( ch ) <br>{ <br>case '\r': <br>case '\t': <br>case '\b': <br> <br>    // <br>    // Throw away.  Already handled at WM_KEYDOWN time. <br>    // <br> <br>    break; <br> <br>default: <br>    StoreChar( hWnd, ch ); <br>    break; <br>} <br>    } <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   MouseHandler - WM_BUTTONDOWN handler <br>* <br>************************************************************************/ <br> <br>void MouseHandler( HWND hWnd, LONG lParam ) <br>{ <br> <br>    if ( ( gImeUIData.ImeState &amp; IME_IN_CHOSECAND ) || <br>         ( gImeUIData.ImeState &amp; IME_IN_COMPOSITION &amp;&amp; !MoveCaret( hWnd ) ) ) <br>return; <br> <br>    HideCaret( hWnd ); <br> <br>    // <br>    // Calculate caret position based on fixed pitched font <br>    // <br> <br>    yPos = MAKEPOINTS(lParam).y / cyMetrics; <br>    xPos = MAKEPOINTS(lParam).x / cxMetrics; <br> <br>    // <br>    // Adjust caret position if click landed on a trail byte <br>    // <br> <br>    if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ) <br> <br>// <br>// If click landed on the last quarter of the DBCS character, <br>// assume the user was aiming at the next character. <br>// <br> <br>if ( (MAKEPOINTS(lParam).x - xPos * cxMetrics) &gt; (cxMetrics / 2) ) <br>    xPos++; <br>else <br>    xPos--; <br> <br>    DestroyCaret(); <br>    CreateCaret( hWnd, <br> NULL, <br> (fInsertMode &amp;&amp; IsDBCSLeadByte( textbuf[yPos][xPos] )) ? <br>   CaretWidth*2 : CaretWidth, <br> cyMetrics ); <br>    SetCaretPos( xPos * cxMetrics, yPos * cyMetrics ); <br>    ShowCaret( hWnd ); <br> <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   InputChangeHandler - WM_INPUTLANGCHANGE handler <br>* <br>************************************************************************/ <br> <br>void InputChangeHandler( HWND hWnd ) <br>{ <br>    HIMC hIMC; <br> <br>    //  <br>    // If the old keyboard layout is IME, the ime ui data have to be free. <br>    //  <br>        <br>    if (ImmIsIME(hCurKL)) <br>    { <br>        // <br>        // If application prefers to use near caret provded by IME, or <br>        // IME provides special UI, then no need to clean UD data. <br>        //  <br>        if ( gImeUIData.fdwProperty &amp; IME_PROP_SPECIAL_UI ) <br>            ; <br>        else if ( gImeUIData.fdwProperty &amp; IME_PROP_AT_CARET ) <br>            ImeUIClearData(hWnd); <br>        else <br>            ; <br>    } <br> <br>    // <br>    // Set new keyboard layout. <br>    // <br>    hCurKL = GetKeyboardLayout(0L); <br> <br>    // <br>    // Get new property. <br>    // <br> <br>    gImeUIData.fdwProperty = ImmGetProperty( hCurKL, IGP_PROPERTY ); <br> <br>    // if this application set the candidate position, it need to set <br>    // it to default for the near caret IME <br> <br>    if ( hIMC = ImmGetContext( hWnd ) ) { <br>        UINT i; <br> <br>        for (i = 0; i &lt; 4; i++) { <br>            CANDIDATEFORM CandForm; <br> <br>            if ( gImeUIData.fdwProperty &amp; IME_PROP_AT_CARET ) { <br>                CandForm.dwIndex = i; <br>                CandForm.dwStyle = CFS_CANDIDATEPOS; <br> <br>#if 0           // This application do not want to set candidate window to <br>                // any position. Anyway, if an application need to set the <br>                // candiadet position, it should remove the if 0 code <br> <br>                // the position you want to set <br>                CandForm.ptCurrentPos.x = ptAppWantPosition[i].x; <br>                CandForm.ptCurrentPos.y = ptAppWantPosition[i].y; <br> <br>                ImmSetCandidateWindow( hIMC, &amp;CandForm ); <br>#endif <br>            } else { <br>                if ( !ImmGetCandidateWindow( hIMC, i, &amp;CandForm ) ) { <br>                    continue; <br>                } <br> <br>                if ( CandForm.dwStyle == CFS_DEFAULT ) { <br>                    continue; <br>                } <br> <br>                CandForm.dwStyle = CFS_DEFAULT; <br> <br>                ImmSetCandidateWindow( hIMC, &amp;CandForm ); <br>            } <br>        } <br> <br>        ImmReleaseContext( hWnd, hIMC ); <br>    } <br> <br>    return; <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   SteWndProc - STE class window procedure <br>* <br>************************************************************************/ <br> <br>long WINAPI SteWndProc( HWND hWnd, UINT msg, UINT wParam, LONG lParam ) <br>{ <br>    int i; <br>    HDC hdc; <br>    PAINTSTRUCT ps; <br> <br>    switch( msg ) { <br> <br>    case WM_CREATE: <br>SteCreate( hWnd ); <br>break; <br> <br>    case WM_DESTROY: <br>PostQuitMessage(0); <br>break; <br> <br>    case WM_CLOSE: <br>DestroyWindow( hWnd ); <br>break; <br> <br>    case WM_SETFOCUS: <br>CreateCaret( hWnd, <br>     NULL, <br>     (fInsertMode &amp;&amp; IsDBCSLeadByte( textbuf[yPos][xPos] )) ? <br>       CaretWidth*2 : CaretWidth, <br>     cyMetrics ); <br>SetCaretPos( xPos * cxMetrics, yPos * cyMetrics ); <br>ShowCaret( hWnd ); <br>break; <br> <br>    case WM_KILLFOCUS: <br>HideCaret( hWnd ); <br>DestroyCaret(); <br>break; <br> <br>    case WM_IME_KEYDOWN: <br>    case WM_KEYDOWN: <br>VirtualKeyHandler( hWnd, wParam ); <br>break; <br> <br>    case WM_KEYUP: <br>break; <br> <br>    case WM_CHAR: <br>CharHandler( hWnd, (WORD)wParam ); <br>break; <br> <br>    case WM_LBUTTONDOWN: <br>MouseHandler( hWnd, lParam ); <br>break; <br> <br>    case WM_MOVE: <br> <br>ImeUIMoveCandWin( hWnd ); <br>break; <br> <br>    case WM_COMMAND: <br>SteCommand( hWnd, wParam, lParam ); <br>break; <br> <br>    case WM_PAINT: <br>InvalidateRect(hWnd,NULL,FALSE);  //for repaint allignment problem?? <br>  // WinChi3.0 <br>hdc = BeginPaint( hWnd, &amp;ps ); <br> <br>// <br>// Refresh display from text buffer <br>// <br> <br>for ( i = FIRSTROW; i &lt;= LASTROW; i++ ) <br>    TextOut( hdc, 0, i*cyMetrics, textbuf[i], MAXCOL ); <br> <br>EndPaint( hWnd, &amp;ps ); <br> <br>RestoreImeUI( hWnd ); <br> <br>break; <br> <br>    case WM_INPUTLANGCHANGE: <br> <br>        InputChangeHandler( hWnd ); <br> <br>        goto call_defwinproc; <br> <br>break; <br> <br>    case WM_IME_SETCONTEXT: <br> <br>        // <br>        // The application have to pass WM_IME_SETCONTEXT to DefWindowProc. <br>// When the application want to handle the IME at the timing of <br>        // focus changing, the application should use WM_SETFOCUS or <br>        // WM_KILLFOCUS. <br>        // <br>      <br>        if ( gImeUIData.fdwProperty &amp; IME_PROP_SPECIAL_UI ) <br>            goto call_defwinproc; <br>        else if ( gImeUIData.fdwProperty &amp; IME_PROP_AT_CARET ) <br>        { <br>    // <br>    // application wants to draw UI ny itself. <br>    // <br>            lParam &amp;= ~(ISC_SHOWUICOMPOSITIONWINDOW | ISC_SHOWUIALLCANDIDATEWINDOW); <br>} <br>return DefWindowProc( hWnd, msg, wParam, lParam ); <br> <br>    case WM_IME_STARTCOMPOSITION: <br> <br>// <br>        // CheckProperty is a macro, if IME already provides near caret or <br>// special UI then let IME handle this message. <br>        // <br>CheckProperty; <br>        ImeUIStartComposition( hWnd ); </code></pre>
<p>
</p>
<pre><code>break; <br> <br>    case WM_IME_COMPOSITION: <br> <br>CheckProperty; <br>        ImeUIComposition( hWnd, wParam, lParam ); <br>        break; <br> <br>    case WM_IME_ENDCOMPOSITION: <br> <br>CheckProperty; <br>        ImeUIEndComposition( hWnd ); <br>        break; <br> <br>    case WM_IME_COMPOSITIONFULL: <br> <br>        // <br>        // Make sure the size for drawing the composition string. <br>        // Application should draw the composition string correctly. <br>        //  <br>        break; <br> <br>    case WM_IME_NOTIFY: <br>           <br>CheckProperty; <br>        if ( !ImeUINotify( hWnd, wParam, lParam ) ) <br>        // This application does not handle all notification message. <br>        // So we pass those notification messages which are not hanlded <br>        // by this application to the DefWindowProc. <br>            goto call_defwinproc; <br>        break; <br>         <br> <br>    case WM_IME_CONTROL: <br> <br>        // <br>        // This message is not received by the application window. <br>        // But don't pass it to DefWindowProc(). <br>        // <br>        break; <br> <br> <br>    default: <br>call_defwinproc: <br> <br>return DefWindowProc( hWnd, msg, wParam, lParam ); <br>    } <br> <br>    return 0; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
