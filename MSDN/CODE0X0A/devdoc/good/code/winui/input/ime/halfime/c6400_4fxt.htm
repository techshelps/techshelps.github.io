<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6401"></a>MAIN.C</h2>
<pre><code>/************************************************************************ <br>* <br>* Title: <br>* <br>*   STED.C - IME Half-aware Simple Text Editor (DBCS version) <br>* <br>* Purpose: <br>* <br>*   Sample program for DBCS programming and IME half-aware application. <br>* <br>* Synopsis: <br>* <br>*   This program is designed as a bare-bone example to demonstrate the <br>*   basic elements of DBCS-enabling, and how to design an IME half-aware <br>*   application. <br>* <br>*   The data structure is a fixed-size 2-dimensional byte array.  The <br>*   font is the fixed-pitch system font.  Rudimentary text editing <br>*   functions, such as the basic cursor movements, insertion, deletion, <br>*   have been implemented. <br>* <br>* DBCS-enabling notes: <br>* <br>*   This version of STE is DBCS-enabled with respect to character input, <br>*   caret shape and movement, and mouse clicking.  It should work on <br>*   any version of Far East Windows since 4.0. <br>* <br>*   As far as source code maintenance goes, there are generally two <br>*   approaches. <br>* <br>*   The first is to add DBCS enabling code under '#ifdef DBCS'.  The <br>*   advantage of this approach is that it keeps the DBCS enabling code <br>*   distinct from the SBCS, so it's easier to add them in, and also to <br>*   remove them later.  (For example, when you want to replace DBCS <br>*   enabling with Unicode enabling.)  The drawback is that because the <br>*   DBCS and the SBCS logic are not integrated, they can easily get out <br>*   of sync (as the SBCS code evolves.) <br>* <br>*   The second approach, which is adopted by this sample app, is to <br>*   integrate DBCS enabling with SBCS.  It takes longer to do, but <br>*   the resulting source is easier to maintain.  Since IsDBCSLeadByte <br>*   is at the heart of any DBCS-enabling logic, an additional speed up <br>*   for generating an SBCS-only version is to define that function as <br>*   FALSE, and let the compiler optimize the DBCS logic away. <br>* <br>* IME Half-Aware notes: <br>* <br>*   This version of STE is an IME half-aware application with the  <br>*   capiabilities to open/close IME conversion engine and control <br>*   where the IME composition window will be located in. It should <br>*   work on any version of Far East Windows since 4.0. <br>* <br>*   This kind of application typically wants to control the behavior <br>*   of IME like opening/closing IME, setting where to show composition <br>*   window, setting where to show candidate lists and so on. It does <br>*   not display any user interface for IME.  <br>* <br>* History: <br>* <br>*   17-Aug-1992     created <br>*   28-Sep-1992     added DBCS-enabling <br>*   30-Sep-1992     bug fixes <br>*   25-Mar-1994     added IME half-aware logics <br>* <br>************************************************************************/ <br> <br>#include &lt;assert.h&gt; <br>#include &lt;windows.h&gt; <br>#include "halfime.h" <br>#include &lt;imm.h&gt; <br> <br>// <br>// Function prototype <br>// <br> <br>void    ResetCaret( HWND ); <br>void    SetIMECompFormPos(); <br> <br> <br>/************************************************************************ <br>* <br>* Global data <br>* <br>************************************************************************/ <br> <br>char szSteClass[10];                // window class name <br>char szSteTitle[40];                // window frame title <br>UINT  cxMetrics,                    // aver. character width <br>      cxOverTypeCaret,              // caret width for overtype mode <br>      cyMetrics;                    // character height <br>int xPos, yPos;                     // caret position <br>HFONT hfntFixed;                    // fixed-pitch font <br>HFONT hfntOld;                      // default font holder <br>BOOL fInsertMode;                   // insert/overtype mode flag <br>int CaretWidth;                     // insert/overtype mode caret width <br>BYTE textbuf[MAXROW][MAXCOL];       // text buffer <br>int DBCSFillChar;                   // 'Pattern/DBCS' fill character <br> <br>UINT    CompWindowMode;             // Composition window mode. <br>COMPOSITIONFORM CompForm;           // Storage for composition window <br>    // structure. <br>DWORD fdwProperty;                  // the property of current active IME <br> <br>/************************************************************************ <br>* <br>*   SteRegister - standard class registration routine <br>* <br>************************************************************************/ <br> <br>int SteRegister( HANDLE hInstance ) <br>{ <br>    long WINAPI SteWndProc( HWND, UINT, UINT, LONG ); <br> <br>    PWNDCLASS pWndClass; <br> <br>    pWndClass=(PWNDCLASS)LocalAlloc(LPTR, sizeof(WNDCLASS)); <br> <br>    pWndClass-&gt;hCursor       = LoadCursor( NULL, IDC_IBEAM ); <br>    pWndClass-&gt;hIcon         = LoadIcon( hInstance, MAKEINTRESOURCE(ID_ICON)); <br>    pWndClass-&gt;lpszMenuName  = MAKEINTRESOURCE(ID_MENU); <br>    pWndClass-&gt;hInstance     = hInstance; <br>    pWndClass-&gt;lpszClassName = (LPSTR)szSteClass; <br>    pWndClass-&gt;lpfnWndProc   = SteWndProc; <br>    pWndClass-&gt;hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    pWndClass-&gt;style         = CS_BYTEALIGNCLIENT | CS_CLASSDC; <br> <br>    if ( !RegisterClass( (LPWNDCLASS)pWndClass ) ) <br>return FALSE; <br> <br>    LocalFree( (HANDLE)pWndClass ); <br> <br>    return TRUE; <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   WinMain <br>* <br>************************************************************************/ <br> <br>int PASCAL WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpszCmdLine, <br>    int nCmdShow ) <br>{ <br>    MSG msg; <br>    HWND hWnd; <br> <br>    LoadString( hInstance, IDS_CLASS, szSteClass, 10 ); <br>    LoadString( hInstance, IDS_TITLE, szSteTitle, 40 ); <br> <br>    if ( !hPrevInstance ) <br>if ( !SteRegister( hInstance ) ) <br>    return FALSE; <br> <br>    if ( !(hWnd = CreateWindow( szSteClass, szSteTitle, <br>  WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, <br>  CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, (HWND)NULL, <br>  (HMENU)NULL, hInstance, NULL)) ) <br>return FALSE; <br> <br>    // <br>    // Create window with just enough client space for the text buffer <br>    // <br> <br>    SetWindowPos( hWnd, 0, 0, 0, <br>MAXCOL*cxMetrics + GetSystemMetrics(SM_CXBORDER)*2, <br>MAXROW*cyMetrics + GetSystemMetrics(SM_CYBORDER)*2 <br> + GetSystemMetrics(SM_CYCAPTION) <br> + GetSystemMetrics(SM_CYMENU), <br>SWP_NOZORDER ); <br> <br>    ShowWindow( hWnd, nCmdShow ); <br> <br>    // <br>    // Any IME half-aware application should call TranslateMessage API to <br>    // translate messages. This is because Windows95 IME architecture  <br>    // will call ImmToAsciiEx API, if necessary, to make IME conversion <br>    // engine work, and generate some IME messages during TranslateMessage <br>    // session. Otherwise, IME will not work. <br>    // <br> <br>    while ( GetMessage( &amp;msg, NULL, 0, 0 ) ) { <br>TranslateMessage( &amp;msg ); <br>DispatchMessage( &amp;msg ); <br>    } <br> <br>    return msg.wParam; <br>} <br> <br>//********************************************************************** <br>// <br>// SteIMEOpenClose() <br>// <br>// This routines calls IMM API to open or close IME. <br>// <br>//********************************************************************** <br> <br>void SteImeOpenClose( HWND hWnd, BOOL fFlag ) <br>{ <br>HIMC            hIMC;           // Input context handle. <br> <br>// <br>// If fFlag is true then open IME; otherwise close it. <br>// <br> <br> <br>        if ( !( hIMC = ImmGetContext( hWnd ) ) ) <br>return; <br> <br>// <br>// When an application wants to open/close IME for some <br>// reasons, it should call TMMSetOpenStatus() to do that. <br>// <br> <br>        ImmSetOpenStatus( hIMC, fFlag ); <br> <br>        ImmReleaseContext( hWnd, hIMC ); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// SteIMECompWindowPos() <br>// <br>// This routines inform IME where to display composition window. <br>// Here we control IME composition window with the following cases: <br>// 1: DEFAULT:   Display composition window in IME default position. <br>// 2: NEARCARET: Display composition window in near caret position. <br>// 3: PreFer:    Display composition window in application prefer position. <br>// <br>//********************************************************************** <br> <br>void SteIMECompWindowPos( HWND hWnd, UINT cmd ) <br>{ <br>RECT            rect;           // Storage for client rect. <br>        HIMChImc; <br> <br> <br>// <br>// Set current composition mode. <br>// <br> <br>CompWindowMode = cmd; <br> <br>switch( cmd ) <br>{ <br>case IDC_DEFAULT_POS: <br> <br>// <br>// Put composition window in default position <br>// being deterimined by IME UI. Applications  <br>// have to set composition form style with  <br>// CFS_DEFAULT to imform IME UI. <br>//  <br> <br>CompForm.dwStyle = CFS_DEFAULT; <br>break; <br> <br>case IDC_NEARCARET_POS: <br> <br>// <br>// Put composition window in near caret  <br>// position. If IME UI receives this control <br>// message, it will put the composition window <br>                        // near to the position deesignated by ptCurrentPos. <br>// So for this operation, applications have to set <br>// composition form style with CFS_POINT and store <br>                        // caret position in ptCurrentPos. <br>// <br> <br>CompForm.dwStyle = CFS_POINT; <br> <br>                        GetCaretPos( (LPPOINT) &amp;CompForm.ptCurrentPos ); <br> <br>break; <br> <br>case IDC_PREFER_POS: <br> <br>// Put composition window in application <br>// prefer position. Applications have to set <br>// composition form sytle with  CFS_POINT | <br>// CFS_FORCE_POSITION and store the prefer <br>                        // position in ptCurrentPos. <br>// <br>// The difference between CFS_POINT and CFS_POINT <br>// with CFS_FORCE_POSITION is if setting <br>// CFS_FORCE_POSITION style, IME will actually <br>// display its composition window in the position <br>// specified by ptCurrent without any adjustment;   <br>                        // otherwise IME will shPosow its composition window  <br>// by adjusting the position specified by  <br>                        // ptCurrentPos. <br>// <br> <br>CompForm.dwStyle = CFS_POINT | CFS_FORCE_POSITION; <br> <br>GetClientRect( hWnd, (LPRECT) &amp;rect); <br> <br>                        CompForm.ptCurrentPos.x = 0; <br>                        CompForm.ptCurrentPos.y = rect.bottom; <br> <br> <br>break; <br>} <br> <br>        hImc = ImmGetContext( hWnd ); <br>        ImmSetCompositionWindow( hImc, (COMPOSITIONFORM FAR*)&amp;CompForm ); <br>        ImmReleaseContext( hWnd, hImc ); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// ResetIMECompWin() <br>// <br>// This routine informs IME the fact that caret position has been changed. <br>// <br>//********************************************************************** <br> <br>void ResetIMECompWin( HWND hWnd ) <br>{ <br>if ( CompWindowMode == IDC_NEARCARET_POS || <br>     CompWindowMode == IDC_PREFER_POS ) <br>{ <br>HIMC hIMC = ImmGetContext(hWnd); <br>if ( hIMC ) <br>ImmSetCompositionWindow(hIMC,&amp;CompForm); <br>ImmReleaseContext( hWnd , hIMC); <br>} <br>} <br> <br>//********************************************************************** <br>// <br>// SetIMECompFormPos() <br>// <br>//********************************************************************** <br> <br>void SetIMECompFormPos( HWND hWnd ) <br>{ <br> <br>    //  <br>    // If current composition form mode is near caret operation,  <br>    // application should inform IME UI the caret position has been <br>    // changed. IME UI will make decision whether it has to adjust <br>    // composition window position. <br>    //  <br>    // <br> <br>    if ( CompWindowMode == IDC_NEARCARET_POS ) <br>    { <br>HIMC hIMC = ImmGetContext(hWnd); <br>POINT   point; <br> <br>GetCaretPos( &amp;point ); <br> <br>CompForm.dwStyle = CFS_POINT; <br> <br>        CompForm.ptCurrentPos.x = (long) point.x; <br>        CompForm.ptCurrentPos.y = (long) point.y; <br> <br>if ( hIMC ) <br>ImmSetCompositionWindow(hIMC,&amp;CompForm); <br>ImmReleaseContext( hWnd , hIMC); <br>    } <br> <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   SteCreate - WM_CREATE message handler <br>* <br>************************************************************************/ <br> <br>void SteCreate( HWND hWnd ) <br>{ <br>    HDC hdc; <br>    TEXTMETRIC tm; <br>    LOGFONT    lFont; <br>    HFONT      hFont; <br> <br>    // <br>    // Note that this window has a class DC <br>    // <br> <br>    hdc = GetDC( hWnd ); <br> <br>    // <br>    // Select fixed pitch system font and get its text metrics <br>    // <br> <br>    hfntFixed = GetStockObject( SYSTEM_FIXED_FONT ); <br>    hfntOld = SelectObject( hdc, hfntFixed ); <br>    GetTextMetrics( hdc, &amp;tm ); <br>    ReleaseDC( hWnd, hdc ); <br>    cxMetrics = tm.tmAveCharWidth; <br>    cyMetrics = tm.tmHeight; <br> <br>    // <br>    // Determine the version of DBCS Windows from system font charset ID. <br>    // Then hardcode a DBCS character value for the 'Pattern/DBCS' command. <br>    // The value is the Han character for 'door' or 'gate', which is <br>    // left-right symmetrical. <br>    // <br> <br>    switch( tm.tmCharSet ) <br>    { <br>    case SHIFTJIS_CHARSET: <br>DBCSFillChar = 0x96e5; <br>break; <br> <br>    case HANGEUL_CHARSET: <br>DBCSFillChar = 0xdaa6; <br>break; <br> <br>    case CHINESEBIG5_CHARSET: <br>DBCSFillChar = 0xaaf9; <br>break; <br> <br>    default: <br>DBCSFillChar = 0x7071;  // 'pq' <br>break; <br>    } <br> <br>    //                    <br>    // Initialize caret width.  Fat in INSERT mode, skinny in OVERTYPE mode. <br>    // <br> <br>    fInsertMode = FALSE; <br>    CaretWidth = cxOverTypeCaret = GetSystemMetrics( SM_CXBORDER ); <br> <br>    // <br>    // Sets the logical font to be used to display characters in the  <br>    // composition window. Especially for at caret or near caret operation,  <br>    // application should set composition font. <br>    // <br> <br>    if ( ( hFont = (HFONT)SendMessage( hWnd, WM_GETFONT, 0, 0L ) ) != NULL ) <br>    { <br>        if ( GetObject( hFont, sizeof(LOGFONT), (LPVOID)&amp;lFont ) ) <br>        { <br>            HIMChImc; <br> <br>            if ( (  hImc = ImmGetContext( hWnd ) ) ) <br>    { <br>        ImmSetCompositionFont( hImc, &amp;lFont ); <br>ImmReleaseContext( hWnd, hImc ); <br>    } <br>} <br>    } <br> <br>    PostMessage( hWnd, WM_COMMAND, IDC_CLEAR, 0L ); <br> <br>    fdwProperty = ImmGetProperty( GetKeyboardLayout(0), IGP_PROPERTY ); <br> <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   ResetCaret - Reset caret shape to match input mode (overtype/insert) <br>* <br>************************************************************************/ <br> <br>void ResetCaret( HWND hWnd ) <br>{ <br> <br>    HideCaret( hWnd ); <br>    DestroyCaret(); <br>    CreateCaret( hWnd, <br> NULL, <br> (fInsertMode &amp;&amp; IsDBCSLeadByte( textbuf[yPos][xPos] )) ? <br>   CaretWidth*2 : CaretWidth, <br> cyMetrics ); <br>    SetCaretPos( xPos * cxMetrics, yPos * cyMetrics ); <br>    ShowCaret( hWnd ); <br> <br>    SetIMECompFormPos( hWnd ); <br> <br>} <br> <br> <br> <br> <br> <br>/************************************************************************ <br>* <br>*   SteCommand - WM_COMMAND handler <br>* <br>************************************************************************/ <br> <br> <br>void SteCommand( HWND hWnd, UINT cmd ) <br>{ <br>    switch( cmd ) <br>    { <br>    case IDC_CLEAR: <br> <br> <br>// <br>// Blank out text buffer.  Return caret to home position <br>// <br> <br>for ( yPos = FIRSTROW; yPos &lt;= LASTROW; yPos++ ) <br>    for ( xPos = FIRSTCOL; xPos &lt;= LASTCOL; xPos++ ) <br>textbuf[yPos][xPos] = ' '; <br>break; <br> <br>    case IDC_ANSIFILL: <br>    case IDC_DBCSFILL: <br> <br>// <br>// Fill text buffer with ANSI or DBCS pattern <br>// <br> <br>for ( yPos = FIRSTROW; yPos &lt;= LASTROW; yPos++ ) <br>    for ( xPos = FIRSTCOL; xPos &lt;= LASTCOL; xPos++ ) <br>if ( cmd == IDC_ANSIFILL ) <br>    textbuf[yPos][xPos] = 'a'; <br>else { <br>    textbuf[yPos][xPos]   = HIBYTE(DBCSFillChar); <br>    textbuf[yPos][++xPos] = LOBYTE(DBCSFillChar); <br>} <br>break; <br>     <br>    // <br>    // The following messages are to control IME. <br>    // <br> <br>    case IDC_OPENIME: <br> <br>SteImeOpenClose( hWnd, TRUE ); <br>goto RETURN; <br> <br>    case IDC_CLOSEIME: <br> <br>SteImeOpenClose( hWnd, FALSE ); <br>goto RETURN; <br> <br>    case IDC_DEFAULT_POS:     <br>    case IDC_NEARCARET_POS: <br>    case IDC_PREFER_POS: <br> <br>SteIMECompWindowPos( hWnd, cmd ); <br>goto RETURN; <br> <br>    } <br> <br>    yPos = FIRSTROW; <br>    xPos = FIRSTCOL; <br> <br>    InvalidateRect( hWnd, (LPRECT)NULL, TRUE ); <br>    ResetCaret(hWnd); <br> <br>RETURN: <br> <br>    return;     <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   IsDBCSTrailByte - returns TRUE if the given byte is a DBCS trail byte <br>* <br>*                     The algorithm searchs backward in the string, to some <br>*                     known character boundary, counting consecutive bytes <br>*                     in the lead byte range. An odd number indicates the <br>*                     current byte is part of a two byte character code. <br>* <br>*   INPUT: PCHAR  - pointer to a preceding known character boundary. <br>*          PCHAR  - pointer to the character to test. <br>* <br>*   OUTPUT:BOOL   - indicating truth of p==trailbyte. <br>* <br>************************************************************************/ <br> <br>BOOL IsDBCSTrailByte( char *base, char *p ) <br>{ <br>    int lbc = 0;    // lead byte count <br> <br>    assert(base &lt;= p); <br> <br>    while ( p &gt; base ) { <br>if ( !IsDBCSLeadByte(*(--p)) ) <br>    break; <br>lbc++; <br>    } <br> <br>    return (lbc &amp; 1); <br>} <br> <br> <br> <br> <br>/************************************************************************ <br>* <br>*   VirtualKeyHandler - WM_KEYDOWN handler <br>* <br>* <br>*   INPUT:  HWND - handle to the window for repainting output. <br>*           UINT - virtual key code. <br>* <br>************************************************************************/ <br> <br>void VirtualKeyHandler( HWND hWnd, UINT wParam ) <br>{ <br>    int i; <br>    HDC hdc; <br>    static int delta = 1; <br> <br>    switch( wParam ) <br>    { <br>    case VK_HOME:   // beginning of line <br>xPos = FIRSTCOL; <br>break; <br> <br>    case VK_END:    // end of line <br>xPos = LASTCOL; <br>goto check_for_trailbyte; <br> <br>    case VK_RIGHT: <br>if ( IsDBCSLeadByte( textbuf[yPos][xPos] ) ){ <br>    if (xPos==LASTCOL - 1) break;  //last character don't move <br>    xPos += 2;                     //skip 2 for DB Character <br>} <br>else <br>    xPos = min( xPos+1, LASTCOL ); <br>break; <br> <br>    case VK_LEFT: <br>xPos = max( xPos-1, FIRSTCOL ); <br> <br>check_for_trailbyte: <br> <br>if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ) <br>    xPos--; <br>break; <br> <br>    case VK_UP: <br>yPos = max( yPos-1, FIRSTROW ); <br>goto Virtical_Check_Trail; <br> <br>    case VK_DOWN: <br>yPos = min( yPos+1, LASTROW ); <br> <br>Virtical_Check_Trail: <br> <br>if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ){ <br>   if (xPos&lt;LASTCOL){ <br>      xPos+=delta; <br>      delta *= -1; <br>   } <br>   else <br>      xPos--; <br>} <br>break; <br> <br> <br>    case VK_INSERT: <br> <br>// <br>// Change caret shape to indicate insert/overtype mode <br>// <br> <br>fInsertMode = !fInsertMode; <br>CaretWidth = fInsertMode ? cxMetrics : cxOverTypeCaret; <br>break; <br> <br>    case VK_BACK:   // backspace <br>if ( xPos &gt; FIRSTCOL ) { <br>    xPos--; <br> <br>    // <br>    // DB Character so backup one more to allign on boundary <br>    // <br>    if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ) <br>xPos--; <br>// <br>// Fall Through to VK_DELETE to adjust row <br>// <br>} <br>else     //FIRST COLUMN  don't backup -- this would change for wrapping <br>   break; <br> <br>    case VK_DELETE: <br> <br>if ( !IsDBCSLeadByte( textbuf[yPos][xPos] ) ) { <br> <br>    // <br>    // Move rest of line left by one, then blank out last character <br>    // <br> <br>    for ( i = xPos; i &lt; LASTCOL; i++ ) <br>textbuf[yPos][i] = textbuf[yPos][i+1]; <br>    textbuf[yPos][LASTCOL] = ' '; <br> <br>} else { <br> <br>    // <br>    // Move line left by two bytes, blank out last two bytes <br>    // <br> <br>    for ( i = xPos; i &lt; LASTCOL-1; i++ ) <br>textbuf[yPos][i] = textbuf[yPos][i+2]; <br>    textbuf[yPos][LASTCOL-1] = ' '; <br>    textbuf[yPos][LASTCOL]   = ' '; <br>} <br> <br>// <br>// Repaint the entire line <br>// <br> <br>hdc = GetDC( hWnd ); <br>HideCaret( hWnd ); <br>TextOut( hdc, 0, yPos*cyMetrics, textbuf[yPos], MAXCOL ); <br>ReleaseDC( hWnd, hdc ); <br>break; <br> <br>    case VK_TAB:    // tab  -- tabs are column allignment not character <br>{ <br> int xTabMax = xPos + TABSTOP; <br> int xPosPrev; <br> <br> do { <br>     xPosPrev = xPos; <br>     SendMessage( hWnd, WM_KEYDOWN, VK_RIGHT, 1L ); <br> } while ( (xPos % TABSTOP) &amp;&amp; <br>   (xPos &lt; xTabMax) &amp;&amp; <br>   (xPos != xPosPrev)); <br> <br>} <br>break; <br> <br>    case VK_RETURN: // linefeed <br>yPos = min( yPos+1, LASTROW ); <br>xPos = FIRSTCOL; <br>break; <br>    } <br> <br>    ResetCaret( hWnd ); <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   StoreChar - Stores one SBCS character into text buffer and advances <br>*               cursor <br>* <br>************************************************************************/ <br> <br>void StoreChar( HWND hWnd, BYTE ch ) <br>{ <br>    int i; <br>    HDC hdc; <br> <br>    // <br>    // If insert mode, move rest of line to the right by one <br>    // <br> <br>    if ( fInsertMode ) { <br>for ( i = LASTCOL; i &gt; xPos; i-- ) <br>    textbuf[yPos][i] = textbuf[yPos][i-1]; <br> <br>// <br>// If the row ends on a lead byte, blank it out <br>// To do this we must first traverse the string <br>// starting from a known character boundry until <br>// we reach the last column. If the last column <br>// is a character boundry then the last character <br>// is either a single byte or a lead byte <br>// <br> <br>for ( i = xPos+1; i &lt; LASTCOL; ) { <br>    if ( IsDBCSLeadByte( textbuf[yPos][i] ) ) <br>i++; <br>    i++; <br>} <br>if (i==LASTCOL) <br>   if ( IsDBCSLeadByte( textbuf[yPos][LASTCOL] ) ) <br>       textbuf[yPos][LASTCOL] = ' '; <br> <br>    } else {  // overtype mode <br> <br>if ( IsDBCSLeadByte( textbuf[yPos][xPos] ) ) <br> <br>    // <br>    // Blank out trail byte <br>    // <br> <br>    textbuf[yPos][xPos+1] = ' '; <br> <br>    // <br>    // or shift line left on character and blank last column <br>    // <br>    // for ( i = xPos+1; i &lt; LASTCOL; i++ ) <br>    //     textbuf[yPos][i] = textbuf[yPos][i+1]; <br>    // textbuf[yPos][LASTCOL] = ' '; <br> <br>    } <br> <br>    // <br>    // Store input character at current caret position <br>    // <br> <br>    textbuf[yPos][xPos] = ch; <br> <br> <br>    // <br>    // Display input character. <br>    // <br> <br>    hdc = GetDC( hWnd ); <br>    HideCaret( hWnd ); <br>    TextOut( hdc, xPos*cxMetrics, yPos*cyMetrics, <br>     &amp;(textbuf[yPos][xPos]), MAXCOL-xPos ); <br>    ShowCaret( hWnd ); <br>    ReleaseDC( hWnd, hdc ); <br> <br>    SendMessage( hWnd, WM_KEYDOWN, VK_RIGHT, 1L ); <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   StoreDBCSChar - Stores one DBCS character into text buffer and <br>*                   advances cursor <br>* <br>************************************************************************/ <br> <br>void StoreDBCSChar( HWND hWnd, WORD ch ) <br>{ <br>    int i; <br>    HDC hdc; <br> <br>    // <br>    // If there is no room for a DBCS character, discard it <br>    // <br> <br>    if ( xPos == LASTCOL ) <br>return; <br> <br>    // <br>    // If insert mode, move rest of line to the right by two <br>    // <br> <br>    if ( fInsertMode ) { <br>for ( i = LASTCOL; i &gt; xPos+1; i-- ) <br>    textbuf[yPos][i] = textbuf[yPos][i-2]; <br> <br>// <br>// If the row ends on a lead byte, blank it out <br>// To do this we must first traverse the string <br>// starting from a known charcter boundry until <br>// we reach the last column. If the last column <br>// is not a trail byte then it is a single byte <br>// or a lead byte <br>// <br> <br>for ( i = xPos+2; i &lt; LASTCOL; ) { <br>    if ( IsDBCSLeadByte( textbuf[yPos][i] ) ) <br>i++; <br>    i++; <br>} <br>if (i==LASTCOL) <br>   if (IsDBCSLeadByte( textbuf[yPos][LASTCOL] ) ) <br>textbuf[yPos][LASTCOL] = ' '; <br> <br>    } else {  // overtype mode <br> <br>if ( !IsDBCSLeadByte( textbuf[yPos][xPos] ) ) <br> <br>    // <br>    // Overtyping the current byte, plus the following byte, <br>    // which could be a lead byte. <br>    // <br> <br>    if ( IsDBCSLeadByte( textbuf[yPos][xPos+1] ) ) <br>textbuf[yPos][xPos+2] = ' '; <br>    } <br> <br>    // <br>    // Store input character at current caret position <br>    // <br> <br>    textbuf[yPos][xPos]   = LOBYTE(ch);     // lead byte <br>    textbuf[yPos][xPos+1] = HIBYTE(ch);     // trail byte <br> <br>    // <br>    // Display input character. <br>    // <br> <br>    hdc = GetDC( hWnd ); <br>    HideCaret( hWnd ); <br>    TextOut( hdc, xPos*cxMetrics, yPos*cyMetrics, <br>     &amp;(textbuf[yPos][xPos]), MAXCOL-xPos ); <br>    ShowCaret( hWnd ); <br>    ReleaseDC( hWnd, hdc ); <br> <br>    SendMessage( hWnd, WM_KEYDOWN, VK_RIGHT, 1L ); <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   CharHandler - WM_CHAR handler <br>* <br>************************************************************************/ <br> <br>void CharHandler( HWND hWnd, UINT wParam ) <br>{ <br>    unsigned char ch = (unsigned char)wParam; <br> <br>    // <br>    // Because DBCS characters are usually generated by IMEs (as two <br>    // PostMessages), if a lead byte comes in, the trail byte should <br>    // arrive very soon after.  We wait here for the trail byte and <br>    // store them into the text buffer together. <br> <br>    if ( IsDBCSLeadByte( ch ) ) { <br> <br>// <br>// Wait an arbitrary amount of time for the trail byte to <br>// arrive.  If it doesn't, then discard the lead byte. <br>// <br>// This could happen if the IME screwed up.  Or, more likely, <br>// the user generated the lead byte through ALT-numpad. <br>// <br> <br>MSG msg; <br>int i = 10; <br> <br>while (!PeekMessage((LPMSG)&amp;msg, hWnd, WM_CHAR, WM_CHAR, PM_REMOVE)) { <br>    if ( --i == 0 ) <br>return; <br>    Yield(); <br>} <br> <br>StoreDBCSChar( hWnd, (WORD)(((unsigned)(msg.wParam)&lt;&lt;8) | (unsigned)ch )); <br> <br>    } else { <br> <br>switch( ch ) <br>{ <br>case '\r': <br>case '\t': <br>case '\b': <br> <br>    // <br>    // Throw away.  Already handled at WM_KEYDOWN time. <br>    // <br> <br>    break; <br> <br>default: <br>    StoreChar( hWnd, ch ); <br>    break; <br>} <br>    } <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   MouseHandler - WM_BUTTONDOWN handler <br>* <br>************************************************************************/ <br> <br>void MouseHandler( HWND hWnd, LONG lParam ) <br>{ <br>    HideCaret( hWnd ); <br> <br>    // <br>    // Calculate caret position based on fixed pitched font <br>    // <br> <br>    yPos = MAKEPOINTS(lParam).y / cyMetrics; <br>    xPos = MAKEPOINTS(lParam).x / cxMetrics; <br> <br>    // <br>    // Adjust caret position if click landed on a trail byte <br>    // <br> <br>    if ( IsDBCSTrailByte( textbuf[yPos], &amp;(textbuf[yPos][xPos]) ) ) <br> <br>// <br>// If click landed on the last quarter of the DBCS character, <br>// assume the user was aiming at the next character. <br>// <br> <br>if ( (MAKEPOINTS(lParam).x - xPos * cxMetrics) &gt; (cxMetrics / 2) ) <br>    xPos++; <br>else <br>    xPos--; <br> <br>    DestroyCaret(); <br>    CreateCaret( hWnd, <br> NULL, <br> (fInsertMode &amp;&amp; IsDBCSLeadByte( textbuf[yPos][xPos] )) ? <br>   CaretWidth*2 : CaretWidth, <br> cyMetrics ); <br>    SetCaretPos( xPos * cxMetrics, yPos * cyMetrics ); <br>    ShowCaret( hWnd ); <br> <br>    SetIMECompFormPos( hWnd ); <br> <br>} <br> <br> <br>/************************************************************************ <br>* <br>*   InputChangeHandler - WM_INPUTLANGCHANGE handler <br>* <br>************************************************************************/ <br> <br>void InputChangeHandler( HWND hWnd ) <br>{ <br>    HIMC hIMC; <br> <br>    fdwProperty = ImmGetProperty( GetKeyboardLayout(0), IGP_PROPERTY ); <br> <br>    // if this application set the candidate position, it need to set <br>    // it to default for the near caret IME <br> <br>    if ( hIMC = ImmGetContext( hWnd ) ) { <br>        UINT i; <br> <br>        for (i = 0; i &lt; 4; i++) { <br>            CANDIDATEFORM CandForm; <br> <br>            if ( fdwProperty &amp; IME_PROP_AT_CARET ) { <br>                CandForm.dwIndex = i; <br>                CandForm.dwStyle = CFS_CANDIDATEPOS; <br> <br>#if 0           // This application do not want to set candidate window to <br>                // any position. Anyway, if an application need to set the <br>                // candiadet position, it should remove the if 0 code <br> <br>                // the position you want to set <br>                CandForm.ptCurrentPos.x = ptAppWantPosition[i].x; <br>                CandForm.ptCurrentPos.y = ptAppWantPosition[i].y; <br> <br>                ImmSetCandidateWindow( hIMC, &amp;CandForm ); <br>#endif <br>            } else { <br>                if ( !ImmGetCandidateWindow( hIMC, i, &amp;CandForm ) ) { <br>                    continue; <br>                } <br> <br>                if ( CandForm.dwStyle == CFS_DEFAULT ) { <br>                    continue; <br>                } <br> <br>                CandForm.dwStyle = CFS_DEFAULT; <br> <br>                ImmSetCandidateWindow( hIMC, &amp;CandForm ); <br>            } <br>        } <br> <br>        ImmReleaseContext( hWnd, hIMC ); <br>    } <br> <br>    return; <br>} <br> <br>/************************************************************************ <br>* <br>*   SteWndProc - STE class window procedure <br>* <br>************************************************************************/ <br> <br>long WINAPI SteWndProc( HWND hWnd, UINT msg, UINT wParam, LONG lParam ) <br>{ <br>    int i; <br>    HDC hdc; <br>    PAINTSTRUCT ps; <br> <br>    switch( msg ) { <br> <br>    case WM_CREATE: <br>SteCreate( hWnd ); <br>break; <br> <br>    case WM_MOVE: <br> <br>ResetIMECompWin( hWnd ); <br>break; <br>    case WM_DESTROY: <br>PostQuitMessage(0); <br>break; <br> <br>    case WM_CLOSE: <br>DestroyWindow( hWnd ); <br>break; <br> <br>    case WM_SETFOCUS: <br>CreateCaret( hWnd, <br>     NULL, <br>     (fInsertMode &amp;&amp; IsDBCSLeadByte( textbuf[yPos][xPos] )) ? <br>       CaretWidth*2 : CaretWidth, <br>     cyMetrics ); <br>SetCaretPos( xPos * cxMetrics, yPos * cyMetrics ); <br>ShowCaret( hWnd ); <br>break; </code></pre>
<p>
</p>
<pre><code><br>    case WM_KILLFOCUS: <br>HideCaret( hWnd ); <br>DestroyCaret(); <br>break; <br> <br>    case WM_KEYDOWN: <br>VirtualKeyHandler( hWnd, wParam ); <br>break; <br> <br>    case WM_CHAR: <br>CharHandler( hWnd, wParam ); <br>break; <br> <br>    case WM_LBUTTONDOWN: <br>MouseHandler( hWnd, lParam ); <br>break; <br> <br>    case WM_COMMAND: <br>SteCommand( hWnd, wParam ); <br>break; <br> <br>    case WM_PAINT: <br>InvalidateRect(hWnd,NULL,FALSE);  //for repaint allignment problem?? <br>  // WinChi3.0 <br>hdc = BeginPaint( hWnd, &amp;ps ); <br> <br>// <br>// Refresh display from text buffer <br>// <br> <br>for ( i = FIRSTROW; i &lt;= LASTROW; i++ ) <br>    TextOut( hdc, 0, i*cyMetrics, textbuf[i], MAXCOL ); <br> <br>EndPaint( hWnd, &amp;ps ); <br>break; <br> <br>    case WM_INPUTLANGCHANGE: <br>        InputChangeHandler( hWnd ); <br>return DefWindowProc( hWnd, msg, wParam, lParam ); <br> <br>    default: <br> <br>return DefWindowProc( hWnd, msg, wParam, lParam ); <br>    } <br> <br>    return 0; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
