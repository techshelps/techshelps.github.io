<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CANDUI.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6395"></a>CANDUI.C</h2>
<pre><code>#include &lt;assert.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;imm.h&gt; <br>#include "fullime.h" <br> <br>//******************************************************************** <br>// <br>// long WINAPI CandWndProc() <br>// <br>// Window procedure of candidate window. <br>// <br>//******************************************************************** <br> <br>long WINAPI CandWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) <br>{ <br> <br>    switch( msg ) <br>    { <br> <br>        case WM_PAINT: <br> <br>            CandUIPaint( hwnd ); <br>            break; <br> <br>        default: <br>             <br>            return DefWindowProc( hwnd, msg, wParam, lParam ); <br>    } <br> <br>    return 0; <br>} <br> <br>//******************************************************************** <br>// <br>// void DislpayCandStrings() <br>// <br>// Displays candidate strings. <br>// <br>//******************************************************************** <br> <br>void DisplayCandStrings( HWND hwnd, LPCANDIDATELIST lpCandList ) <br>{ <br> <br>    HDC         hdc;            // Storage for device context handle. <br>    LPSTR       lpStr;          // Storage for LP to a string. <br>    DWORD       dwNumPerPage;   // Storage for num per page <br>    DWORD       dwStartIndex;   // Storage for candidate index <br>    DWORD       dwEndIndex;     // Storage for candidate index <br>    RECT        rect;           // Storage for client rect. <br>    int         y = 0;          //  <br>    DWORD       dwBackColor;    // Storage for background color value <br>    DWORD       dwTextColor; <br> <br>    // <br>    // Determine how many candidate strings per page. <br>    // <br> <br>    dwNumPerPage = ( !lpCandList-&gt;dwPageSize ) ? <br>                     DEFAULT_CAND_NUM_PER_PAGE : <br>                     lpCandList-&gt;dwPageSize; <br> <br>    // <br>    // Determine the dwStartIndex from which the candidate string will <br>    // start displaying. <br>    // <br> <br>    dwStartIndex = lpCandList-&gt;dwPageStart; <br> <br>    // <br>    // Determine the dwEndIndex which indicate the last candidate string <br>    // will be displayed. <br>    // <br> <br>    dwEndIndex = dwStartIndex + dwNumPerPage; <br> <br>    dwEndIndex = ( dwEndIndex &gt;= lpCandList-&gt;dwCount ) ? <br>                 lpCandList-&gt;dwCount : dwEndIndex; <br>                  <br>     <br>    // <br>    // Dissplay candidate strings. <br>    // First paint background color. <br>    // <br> <br>    hdc = GetDC( hwnd ); <br> <br>    dwBackColor = SetBkColor( hdc, RGB( 0xbf, 0xbf, 0xbf ) ); <br> <br>    GetClientRect( hwnd, &amp;rect ); <br> <br>    ExtTextOut( hdc, 0, 0, ETO_OPAQUE, &amp;rect, NULL, 0, 0 ); <br> <br> <br>    // <br>    // Set background color of selected candidate string to be blue. <br>    // <br> <br>    rect.top = rect.top + ( lpCandList-&gt;dwSelection - dwStartIndex ) * <br>               cyMetrics; <br> <br>    rect.bottom = rect.top + cyMetrics; <br> <br>    SetBkColor( hdc,RGB( 0x00, 0x00, 0xff ) ); <br> <br>    ExtTextOut( hdc, 0, rect.top, ETO_OPAQUE, &amp;rect, NULL, 0, 0 ); <br> <br>    // <br>    // Display candidate strings.  <br>    // <br> <br>    SetBkMode( hdc, TRANSPARENT ); <br> <br>    dwTextColor = GetTextColor( hdc ); <br> <br>    for ( ; dwStartIndex &lt; dwEndIndex; dwStartIndex++, y++ ) <br>    { <br> <br>        lpStr = (LPSTR) lpCandList + <br>                lpCandList-&gt;dwOffset[ dwStartIndex ]; <br> <br>        if ( dwStartIndex == lpCandList-&gt;dwSelection ) <br>            SetTextColor( hdc, RGB( 255, 255, 255 ) ); <br>        else <br>            SetTextColor( hdc, dwTextColor ); <br> <br>        TextOut( hdc, 3, y * cyMetrics, lpStr, lstrlen( lpStr ) ); <br>    } <br> <br> <br>    SetTextColor( hdc, dwTextColor ); <br>     <br>    SetBkColor( hdc, dwBackColor ); <br> <br>    ReleaseDC( hwnd, hdc ); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// void CandUIPaint() <br>// <br>// Handler routine of WM_PAINT message. <br>// <br>//********************************************************************** <br> <br>void CandUIPaint( HWND hwnd ) <br>{ <br>    int         index; <br>    LPCANDIDATELIST lpCandList; <br>    HDC         hdc; <br>    PAINTSTRUCT ps; <br> <br> <br>    hdc = BeginPaint( hwnd, (LPPAINTSTRUCT)&amp;ps ); <br>     <br>    // <br>    // Determine which candidate window needs to repaint. <br>    // <br> <br>    for ( index = 0; index &lt; MAX_LISTCAND; index ++ ) <br>        if ( gImeUIData.hListCand[ index ] == hwnd ) <br>            break; <br> <br>    // <br>    // If index == MAX_LISTCAND, then something wrong, do nothing. <br>    // <br> <br>    if ( index == MAX_LISTCAND ) <br>        goto exit; <br> <br>    if ( !gImeUIData.hListCandMem[ index ] || <br>         (lpCandList = (LPCANDIDATELIST) <br>              GlobalLock( gImeUIData.hListCandMem[ index ] ) ) == NULL ) <br>        goto exit; <br> <br>    DisplayCandStrings( hwnd, lpCandList ); <br> <br>    GlobalUnlock( gImeUIData.hListCandMem[ index ] ); <br> <br>exit: <br> <br>    EndPaint( hwnd, (LPPAINTSTRUCT)&amp;ps ); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
