<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6402"></a>COMP.C</h2>
<pre><code>/**********************************************************************/ <br>/*                                                                    */ <br>/*      COMP.C                                                        */ <br>/*                                                                    */ <br>/*      Copyright (c) 1995-1997  Microsoft Corporation                */ <br>/*                                                                    */ <br>/**********************************************************************/ <br> <br>#include "windows.h" <br>#include "imm.h" <br>#include "resource.h" <br>#include "imeapps.h" <br> <br>#define DEBUG 1 <br> <br>LRESULT HandleStartComposition(HWND hWnd,WPARAM wParam,LPARAM lParam) <br>{ <br>    COMPOSITIONFORM cpf; <br>    HIMC hIMC; <br>  <br>#ifdef DEBUG <br>    OutputDebugString("WM_STARTCOMPOSITIONSTRING!!!\r\n"); <br>#endif <br> <br>    if (fdwProperty &amp; IME_PROP_SPECIAL_UI) <br>    { <br>        // Normally, we need to set the composition window <br>        // position to caret position for a special UI IME <br>    } <br>    else if (fdwProperty &amp; IME_PROP_AT_CARET) <br>    { <br>        // If an application show composition string by itself, we do not <br>        // need to set the position of composition window for an at caret <br>        // IME. <br> <br>        return 1; <br>    } <br>    else <br>    { <br>        // Normally, we need to set the composition window <br>        // position to caret position for a near caret IME <br>    } <br> <br>    hIMC = ImmGetContext(hWnd); <br> <br>    if (!hIMC) <br>    { <br>        return 1; <br>    } <br> <br>    cpf.dwStyle = CFS_POINT; <br>    cpf.ptCurrentPos.x = ptImeUIPos.x; <br>    cpf.ptCurrentPos.y = ptImeUIPos.y; <br> <br>    ImmSetCompositionWindow(hIMC,&amp;cpf); <br> <br>    ImmReleaseContext(hWnd,hIMC); <br> <br>    return 1; <br>} <br> <br>LRESULT HandleEndComposition(HWND hWnd,WPARAM wParam,LPARAM lParam) <br>{ <br>#ifdef DEBUG <br>    OutputDebugString("WM_ENDCOMPOSITIONSTRING!!!\r\n"); <br>#endif <br>    dwCompStrLen      = 0; <br>    dwCompAttrLen     = 0; <br>    dwCompClsLen      = 0; <br>    dwCompReadStrLen  = 0; <br>    dwCompReadAttrLen = 0; <br>    dwCompReadClsLen  = 0; <br>    dwResultStrLen      = 0; <br>    dwResultClsLen      = 0; <br>    dwResultReadStrLen  = 0; <br>    dwResultReadClsLen  = 0; <br>    InvalidateRect(hWnd,NULL,TRUE); <br> <br>    return 1; <br>} <br> <br>void MakePaintString(HWND hWnd, LPMYSTR lpStr,DWORD dwStrLen,LPDWORD lpCls,DWORD dwClsLen,LPMYSTR lpPaintStr) <br>{ <br>    LPMYSTR lpPaintStart = lpPaintStr; <br> <br>    lpPaintStr += Mylstrlen(lpPaintStr); <br> <br>    if (dwStrLen) <br>    { <br>        if (dwClsLen) <br>        { <br>            lpCls[127] = 0; <br> <br>            while (*(lpCls+1) &amp;&amp; *lpCls &lt; dwStrLen) <br>            { <br>                DWORD dwTextLen = *(lpCls+1) - *lpCls; <br>                LPMYSTR lpT = lpStr + *lpCls; <br> <br>                memcpy(lpPaintStr,lpT,dwTextLen * sizeof(MYCHAR)); <br>                lpPaintStr += dwTextLen; <br>                *lpPaintStr = MYTEXT(','); <br>                lpPaintStr++; <br>                lpCls++; <br>            } <br>            *lpPaintStr = MYTEXT('\0'); <br>        } <br>        else <br>        { <br>            Mylstrcpy(lpPaintStr,lpStr); <br>            Mylstrcat(lpPaintStr,MYTEXT(",")); <br>        } <br>    } <br> <br>} <br> <br>LRESULT HandleComposition(HWND hWnd,WPARAM wParam,LPARAM lParam) <br>{ <br>    HIMC hIMC; <br>    BOOL fRedraw = FALSE; <br> <br>    hIMC = ImmGetContext(hWnd); <br> <br>    if (lParam &amp; GCS_COMPSTR) <br>    { <br>        dwCompStrLen = MyImmGetCompositionString(hIMC,GCS_COMPSTR,szCompStr,sizeof(szCompStr)); <br>        dwCompStrLen /= sizeof(MYCHAR); <br>        szCompStr[dwCompStrLen] = MYTEXT('\0'); <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwCompStrLen = 0; <br>        szCompStr[0] = MYTEXT('\0'); <br>    } <br> <br>    if (lParam &amp; GCS_COMPATTR) <br>    { <br>        dwCompAttrLen = MyImmGetCompositionString(hIMC,GCS_COMPATTR,bCompAttr,sizeof(bCompAttr)); <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwCompAttrLen = 0; <br>        bCompAttr[0] = 0; <br>    } <br> <br>    if (lParam &amp; GCS_COMPCLAUSE) <br>    { <br>        dwCompClsLen = MyImmGetCompositionString(hIMC,GCS_COMPCLAUSE,dwCompCls,sizeof(dwCompCls)); <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwCompClsLen = 0; <br>        dwCompCls[0] = 0; <br>        dwCompCls[1] = 0; <br>    } <br> <br> <br>    if (lParam &amp; GCS_COMPREADSTR) <br>    { <br>        dwCompReadStrLen = MyImmGetCompositionString(hIMC,GCS_COMPREADSTR,szCompReadStr,sizeof(szCompReadStr)); <br>        dwCompReadStrLen /= sizeof(MYCHAR); <br>        szCompReadStr[dwCompReadStrLen] = MYTEXT('\0'); <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwCompReadStrLen = 0; <br>        szCompReadStr[0] = MYTEXT('\0'); <br>    } <br> <br>    if (lParam &amp; GCS_COMPREADATTR) <br>    { <br>        dwCompReadAttrLen = MyImmGetCompositionString(hIMC,GCS_COMPREADATTR,bCompReadAttr,sizeof(bCompReadAttr)); <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwCompReadAttrLen = 0; <br>        bCompReadAttr[0] = 0; <br>    } <br> <br>    if (lParam &amp; GCS_COMPREADCLAUSE) <br>    { <br>        dwCompReadClsLen = MyImmGetCompositionString(hIMC,GCS_COMPREADCLAUSE,dwCompReadCls,sizeof(dwCompReadCls)); <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwCompReadClsLen = 0; <br>        dwCompReadCls[0] = 0; <br>        dwCompReadCls[1] = 0; <br>    } <br> <br> <br>    if (lParam &amp; GCS_RESULTSTR) <br>    { <br>        RECT rc; <br>        HDC hIC; <br>        SIZE sz0,sz1; <br>        HFONT hOldFont; <br> <br>        if (lParam &amp; GCS_RESULTCLAUSE) <br>        { <br>            dwResultClsLen = MyImmGetCompositionString(hIMC,GCS_RESULTCLAUSE,dwResultCls,sizeof(dwResultCls)); <br>        } <br>        else <br>        { <br>            dwResultClsLen = 0; <br>            dwResultCls[0] = 0; <br>            dwResultCls[1] = 0; <br>        } <br> <br>        dwResultStrLen = MyImmGetCompositionString(hIMC,GCS_RESULTSTR,szResultStr,sizeof(szResultStr)); <br>        dwResultStrLen /= sizeof(MYCHAR); <br>        szResultStr[dwResultStrLen] = MYTEXT('\0'); <br> <br> <br>        // szPaintResult may overflow.. <br>        GetClientRect(hWnd,&amp;rc); <br>        hIC = CreateIC("DISPLAY", NULL, NULL, NULL); <br>        hOldFont = SelectObject(hIC,hFont); <br>#ifdef USEWAPI <br>        GetTextExtentPointW(hIC,szPaintResult,Mylstrlen(szPaintResult),&amp;sz0); <br>        GetTextExtentPointW(hIC,szResultStr,Mylstrlen(szResultStr),&amp;sz1); <br>#else <br>        GetTextExtentPoint(hIC,szPaintResult,Mylstrlen(szPaintResult),&amp;sz0); <br>        GetTextExtentPoint(hIC,szResultStr,Mylstrlen(szResultStr),&amp;sz1); <br>#endif <br>        if (sz0.cx + sz1.cx &gt;= rc.right) <br>        { <br>            szPaintResult[0] = MYTEXT('\0'); <br>            szPaintResultRead[0] = MYTEXT('\0'); <br>        } <br>        SelectObject(hIC,hOldFont); <br>        DeleteDC(hIC); <br> <br>        MakePaintString(hWnd,szResultStr,dwResultStrLen,dwResultCls,dwResultClsLen,szPaintResult); <br> <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwResultStrLen = 0; <br>        szResultStr[0] = MYTEXT('\0'); <br>        dwResultClsLen = 0; <br>        dwResultCls[0] = 0; <br>        dwResultCls[1] = 0; <br>    } <br> <br> <br> <br>    if (lParam &amp; GCS_RESULTREADSTR) <br>    { <br>        if (lParam &amp; GCS_RESULTREADCLAUSE) <br>        { <br>            dwResultReadClsLen = MyImmGetCompositionString(hIMC,GCS_RESULTREADCLAUSE,dwResultReadCls,sizeof(dwResultReadCls)); <br>            fRedraw = TRUE; <br>        } <br>        else <br>        { <br>            dwResultReadClsLen = 0; <br>            dwResultReadCls[0] = 0; <br>            dwResultReadCls[1] = 0; <br>        } <br>        dwResultReadStrLen = MyImmGetCompositionString(hIMC,GCS_RESULTREADSTR,szResultReadStr,sizeof(szResultReadStr)); <br>        dwResultReadStrLen /= sizeof(MYCHAR); <br>        szResultReadStr[dwResultReadStrLen] = MYTEXT('\0'); <br>        MakePaintString(hWnd,szResultReadStr,dwResultReadStrLen,dwResultReadCls,dwResultReadClsLen,szPaintResultRead); <br>        fRedraw = TRUE; <br>    } <br>    else <br>    { <br>        dwResultReadStrLen = 0; <br>        szResultReadStr[0] = MYTEXT('\0'); <br>        dwResultReadClsLen = 0; <br>        dwResultReadCls[0] = 0; <br>        dwResultReadCls[1] = 0; <br>    } <br> <br> <br> <br>    if (fRedraw) <br>    { <br>        InvalidateRect(hWnd,NULL,TRUE); <br>        UpdateWindow(hWnd); <br>    } <br>    return 1; <br>} <br> <br> <br>LRESULT HandleChar(HWND hWnd,WPARAM wParam,LPARAM lParam) <br>{ <br>    RECT rc; <br>    HDC hIC; <br>    SIZE sz0,sz1; <br>    HFONT hOldFont; <br>    LPMYSTR lp; <br>    // is the previous received char is a DBCS lead byte char ? <br>    static BOOL fIsPrevLeadByte = FALSE; <br> <br>    GetClientRect(hWnd,&amp;rc); <br>    hIC = CreateIC("DISPLAY", NULL, NULL, NULL); <br>    hOldFont = SelectObject(hIC,hFont); <br>#ifdef USEWAPI <br>    GetTextExtentPointW(hIC,szPaintResult,Mylstrlen(szPaintResult),&amp;sz0); <br>    GetTextExtentPointW(hIC,szResultStr,Mylstrlen(szResultStr),&amp;sz1); <br>#else <br>    GetTextExtentPoint(hIC,szPaintResult,Mylstrlen(szPaintResult),&amp;sz0); <br>    GetTextExtentPoint(hIC,szResultStr,Mylstrlen(szResultStr),&amp;sz1); <br>#endif <br>    if (sz0.cx + sz1.cx &gt;= rc.right) <br>    { <br>        szPaintResult[0] = MYTEXT('\0'); <br>        szPaintResultRead[0] = MYTEXT('\0'); <br>    } <br>    SelectObject(hIC,hOldFont); <br>    DeleteDC(hIC); <br> <br>    lp = szPaintResult + Mylstrlen(szPaintResult); <br> <br>#ifndef USEWAPI <br>    if (fIsPrevLeadByte) { <br>        // remove , and append second byte for showing DBCS char <br>        if (*(lp - 1) == ',') { <br>            lp--; <br>        } <br>    } <br>#endif <br> <br>    // append second byte <br>    *lp++ = (MYCHAR)(BYTE)wParam; <br>    *lp++ = MYTEXT(','); <br>    *lp++ = MYTEXT('\0'); <br> <br>    lp = szPaintResultRead + Mylstrlen(szPaintResultRead); <br> <br>#ifndef USEWAPI <br>    if (fIsPrevLeadByte) { <br>        // remove , and append second byte for showing DBCS char <br>        if (*(lp - 1) == ',') { <br>            lp--; <br>        } <br> <br>        fIsPrevLeadByte = FALSE; <br>    } else { <br>        fIsPrevLeadByte = IsDBCSLeadByte((BYTE)wParam); <br>    } <br>#endif <br> <br>    *lp++ = (BYTE)wParam; <br>    *lp++ = MYTEXT(','); <br>    *lp++ = MYTEXT('\0'); <br> <br>    InvalidateRect(hWnd,NULL,TRUE); <br>    UpdateWindow(hWnd); <br> <br>    return 1; <br>} <br> <br> <br>LRESULT HandleNotify(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>{ <br>    HIMC hIMC; <br>    BOOL fOpen; <br>    DWORD dwConvMode,dwSentMode; <br> <br> <br>    switch (wParam) <br>    { <br>        case IMN_OPENSTATUSWINDOW: <br>        case IMN_CLOSESTATUSWINDOW: <br>            break; <br> <br>        case IMN_SETOPENSTATUS: <br>            SetStatusItems(hWnd); <br> <br>            hIMC = ImmGetContext(hWnd); <br>            fOpen = ImmGetOpenStatus(hIMC); <br>            UpdateShowOpenStatusButton(fOpen); <br> <br>            ImmReleaseContext(hWnd,hIMC); <br>            break; <br> <br>        case IMN_SETCONVERSIONMODE: <br>            hIMC = ImmGetContext(hWnd); <br>            fOpen = ImmGetOpenStatus(hIMC); <br>            ImmGetConversionStatus(hIMC,&amp;dwConvMode,&amp;dwSentMode); <br>            if (fOpen) <br>            { <br>                SetConvModeParts(dwConvMode); <br>                UpdateModeButton(dwConvMode); <br>            } <br>            else <br>                ClearConvModeParts(); <br>            ImmReleaseContext(hWnd,hIMC); <br>            break; <br> <br>        case IMN_OPENCANDIDATE: <br>            if (!fShowCand || (lParam != 0x01)) <br>            { <br>                if (fdwProperty &amp; IME_PROP_SPECIAL_UI) <br>                { <br>                    // Normally, we only need to set the composition window <br>                    // position for a special UI IME <br>                } <br>                else if (fdwProperty &amp; IME_PROP_AT_CARET) <br>                { <br>                    CANDIDATEFORM cdf; <br>                    HIMC          hIMC; <br>  <br>                    hIMC = ImmGetContext(hWnd); <br> <br>                    cdf.dwIndex = 0; <br>                    cdf.dwStyle = CFS_CANDIDATEPOS; <br>                    cdf.ptCurrentPos.x = ptImeUIPos.x; <br>                    cdf.ptCurrentPos.y = ptImeUIPos.y; <br>                    ImmSetCandidateWindow(hIMC,&amp;cdf); <br> <br>                    ImmReleaseContext(hWnd,hIMC); <br>                } <br>                else <br>                { <br>                    // Normally, we only need to set the composition window <br>                    // position for a near caret IME <br>                } <br> <br>                return (DefWindowProc(hWnd, message, wParam, lParam)); <br>            } <br> <br>        case IMN_CHANGECANDIDATE: <br> <br>#ifdef _DEBUG <br>{ <br>char szDev[80]; <br>DWORD dwSize; <br>LPCANDIDATELIST lpC; <br> <br>hIMC = ImmGetContext(hWnd); <br>if (dwSize = ImmGetCandidateList(hIMC,0x0,NULL,0)) <br>{ <br>    lpC = (LPCANDIDATELIST)GlobalAlloc(GPTR,dwSize); <br>    <br>    ImmGetCandidateList(hIMC,0x0,lpC,dwSize); <br> <br>    OutputDebugString("DumpCandList!!!\r\n"); <br>    wsprintf((LPSTR)szDev,"dwCount %d\r\n",lpC-&gt;dwCount); <br>    OutputDebugString((LPSTR)szDev); <br>    wsprintf((LPSTR)szDev,"dwSelection %d\r\n",lpC-&gt;dwSelection); <br>    OutputDebugString((LPSTR)szDev); <br>    wsprintf((LPSTR)szDev,"dwPageStart %d\r\n",lpC-&gt;dwPageStart); <br>    OutputDebugString((LPSTR)szDev); <br>    wsprintf((LPSTR)szDev,"dwPageSize %d\r\n",lpC-&gt;dwPageSize); <br>    OutputDebugString((LPSTR)szDev); <br>    GlobalFree((HANDLE)lpC); <br>} <br>} <br>#endif <br>            if (fShowCand &amp;&amp; (lParam == 0x01)) <br>            { <br>                DWORD dwSize; <br> <br>                if (!lpCandList) <br>                    lpCandList = (LPCANDIDATELIST)GlobalAlloc(GPTR,sizeof(CANDIDATELIST)); <br> <br>                hIMC = ImmGetContext(hWnd); <br>                if (dwSize = ImmGetCandidateList(hIMC,0x0,NULL,0)) <br>                { <br>                    GlobalFree((HANDLE)lpCandList); <br>                    lpCandList = (LPCANDIDATELIST)GlobalAlloc(GPTR,dwSize); <br>                    <br>                    ImmGetCandidateList(hIMC,0x0,lpCandList,dwSize); <br> <br>                } <br>                else <br>                { <br>                    memset(lpCandList, 0, sizeof(CANDIDATELIST)); <br>                } <br> <br>                InvalidateRect(hWndCandList,NULL,TRUE); <br>                UpdateWindow(hWndCandList); <br>                     <br> <br>                ImmReleaseContext(hWnd,hIMC); <br>            } <br>            else <br>            { <br>                return (DefWindowProc(hWnd, message, wParam, lParam)); <br>            } <br>            break; <br> <br>        case IMN_CLOSECANDIDATE: <br>            if (fShowCand &amp;&amp; (lParam == 0x01)) <br>            { <br>                if (!lpCandList) <br>                    lpCandList = (LPCANDIDATELIST)GlobalAlloc(GPTR,sizeof(CANDIDATELIST)); <br> <br>                memset(lpCandList, 0, sizeof(CANDIDATELIST)); <br>                InvalidateRect(hWndCandList,NULL,TRUE); <br>                UpdateWindow(hWndCandList); <br>            } <br>            else <br>            { <br>                return (DefWindowProc(hWnd, message, wParam, lParam)); <br>            } <br>            break; <br> <br> <br>       default: <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br> <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
