<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CURSOR.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6393"></a>CURSOR.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corp. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************** <br> <br>    PROGRAM: Cursor.c <br> <br>    PURPOSE: Demonstrates how to manipulate a cursor and select a region <br> <br>    FUNCTIONS: <br> <br>        WinMain() - calls initialization function, processes message loop <br>        InitApplication() - initializes window data and registers window <br>        InitInstance() - saves instance handle and creates main window <br>        MainWndProc() - processes messages <br>        About() - processes messages for "About" dialog box <br>        sieve() - time consuming function, generates primes <br> <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "cursor.h" <br> <br>HANDLE hInst; <br> <br>CHAR str[255];                              /* general-purpose string buffer */ <br> <br>HCURSOR hSaveCursor;                        /* handle to current cursor      */ <br>HCURSOR hHourGlass;                         /* handle to hourglass cursor    */ <br> <br>BOOL bTrack = FALSE;                        /* TRUE if left button clicked   */ <br>INT OrgX = 0, OrgY = 0;                     /* original cursor position      */ <br>INT PrevX = 0, PrevY = 0;                   /* current cursor position       */ <br>INT X = 0, Y = 0;                           /* last cursor position          */ <br>RECT Rect;                                  /* selection rectangle           */ <br> <br>MPOINT ptCursor;                            /* x and y coordinates of cursor */ <br>INT repeat = 1;                             /* repeat count of keystroke     */ <br> <br>/**************************************************************************** <br> <br>    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br> <br>    PURPOSE: calls initialization function, processes message loop <br> <br>****************************************************************************/ <br> <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br>    MSG msg;                                 /* message                      */ <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br>    if (!hPrevInstance) <br>        if (!InitApplication(hInstance)) <br>            return (FALSE); <br> <br>    if (!InitInstance(hInstance, nCmdShow)) <br>        return (FALSE); <br> <br>    MessageBox ( <br>          GetFocus () <br>        , "Use the mouse button in this program for an example of graphics " <br>                        "selection, or the &lt;Enter&gt; key for an example of " <br>                        "using a special cursor to reflect a program state." <br>        , "Cursor Sample Application" <br>        , MB_ICONASTERISK | MB_OK <br>    ); <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br>    return (msg.wParam); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: InitApplication(HANDLE) <br> <br>    PURPOSE: Initializes window data and registers window class <br> <br>****************************************************************************/ <br> <br>BOOL InitApplication(HANDLE hInstance) <br>{ <br>    WNDCLASS  wc; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = (WNDPROC) MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); <br>    wc.hCursor = LoadCursor(hInstance, "bullseye"); <br>    wc.hbrBackground = GetStockObject(WHITE_BRUSH);  <br>    wc.lpszMenuName =  "CursorMenu"; <br>    wc.lpszClassName = "CursorWClass"; <br> <br>    return (RegisterClass(&amp;wc)); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION:  InitInstance(HANDLE, int) <br> <br>    PURPOSE:  Saves instance handle and creates main window <br> <br>****************************************************************************/ <br> <br>BOOL InitInstance( <br>    HANDLE          hInstance, <br>    INT             nCmdShow) <br>{ <br>    HWND            hWnd; <br> <br>    hInst = hInstance; <br> <br>    strcpy(str,""); <br> <br>    hHourGlass = LoadCursor(NULL, IDC_WAIT);   <br> <br>    hWnd = CreateWindow( <br>        "CursorWClass", <br>        "Cursor Sample Application", <br>        WS_OVERLAPPEDWINDOW, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL <br>    ); <br> <br>    if (!hWnd) <br>        return (FALSE); <br> <br>    ShowWindow(hWnd, nCmdShow); <br>    UpdateWindow(hWnd); <br>    return (TRUE); <br> <br>} <br> <br>/**************************************************************************** <br> <br>    FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages <br> <br>    MESSAGES: <br> <br>        WM_COMMAND     - application menu (About dialog box) <br>        WM_CHAR        - ASCII key value received <br>        WM_LBUTTONDOWN - left mouse button <br>        WM_MOUSEMOVE   - mouse movement <br>        WM_LBUTTONUP   - left button released <br>        WM_KEYDOWN     - key pressed <br>        WM_KEYUPS      - key released <br>        WM_PAINT       - update window <br>        WM_DESTROY     - destroy window <br> <br>    COMMENTS: <br> <br>        When the left mouse button is pressed, btrack is set to TRUE so that <br>        the code for WM_MOUSEMOVE will keep track of the mouse and update <br>        the box accordingly.  Once the button is released, btrack is set to <br>        FALSE, and the current position is saved.  Holding the SHIFT key <br>        while pressing the left button will extend the current box rather <br>        then erasing it and starting a new one. <br> <br>        When an arrow key is pressed, the cursor is repositioned in the <br>        direction of the arrow key.  A repeat count is kept so that the <br>        longer the user holds down the arrow key, the faster it will move. <br>        As soon as the key is released, the repeat count is set to 1 for <br>        normal cursor movement. <br> <br>****************************************************************************/ <br> <br>LONG APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam) <br>{ <br>    POINT pt; <br>    HDC hDC; <br> <br>    switch (message) { <br>        case WM_COMMAND: <br>            // LOWORD added for portability <br>            if (LOWORD(wParam) == IDM_ABOUT) { <br> <br>                DialogBox(hInst, <br>                    "AboutBox", <br>                    hWnd, <br>    About); <br> <br>                break; <br>            } <br>            else <br>                return (DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>        case WM_CHAR: <br>            if (wParam == '\r') { <br>                SetCapture(hWnd); <br> <br>                /* Set the cursor to an hourglass */ <br> <br>                hSaveCursor = SetCursor(hHourGlass); <br> <br>                strcpy (str, "Calculating prime numbers..."); <br>                InvalidateRect (hWnd, NULL, TRUE); <br>                UpdateWindow (hWnd); <br>                wsprintf(str, "Calculated %d primes.       ", sieve()); <br>                InvalidateRect (hWnd, NULL, TRUE); <br>                UpdateWindow (hWnd); <br> <br>                SetCursor(hSaveCursor);          /* Restores previous cursor */ <br>                ReleaseCapture(); <br>            } <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            bTrack = TRUE; <br>            strcpy (str, ""); <br>            PrevX = LOWORD(lParam); <br>            PrevY = HIWORD(lParam); <br>            if (!(wParam &amp; MK_SHIFT)) {       /* If shift key is not pressed */ <br>                OrgX = LOWORD(lParam); <br>                OrgY = HIWORD(lParam); <br>            } <br>            InvalidateRect (hWnd, NULL, TRUE); <br>            UpdateWindow (hWnd); <br> <br>            /* Capture all input even if the mouse goes outside of window */ <br> <br>            SetCapture(hWnd); <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            { <br>                RECT        rectClient; <br>                INT         NextX; <br>                INT         NextY; <br> <br>                if (bTrack) { <br>                    NextX = (SHORT)LOWORD(lParam); <br>                    NextY = (SHORT)HIWORD(lParam); <br> <br>                    /* Do not draw outside the window's client area */ <br> <br>                    GetClientRect (hWnd, &amp;rectClient); <br>                    if (NextX &lt; rectClient.left) { <br>                        NextX = rectClient.left; <br>                    } else if (NextX &gt;= rectClient.right) { <br>                        NextX = rectClient.right - 1; <br>                    } <br>                    if (NextY &lt; rectClient.top) { <br>                        NextY = rectClient.top; <br>                    } else if (NextY &gt;= rectClient.bottom) { <br>                        NextY = rectClient.bottom - 1; <br>                    } <br> <br>                    /* If the mouse position has changed, then clear the */ <br>                    /* previous rectangle and draw the new one.          */ <br> <br>                    if ((NextX != PrevX) || (NextY != PrevY)) { <br>                        hDC = GetDC(hWnd); <br>                        SetROP2(hDC, R2_NOT);          /* Erases the previous box */ <br>                        MoveToEx(hDC, OrgX, OrgY, NULL); <br>                        LineTo(hDC, OrgX, PrevY); <br>                        LineTo(hDC, PrevX, PrevY); <br>                        LineTo(hDC, PrevX, OrgY); <br>                        LineTo(hDC, OrgX, OrgY); <br> <br>                        /* Get the current mouse position */ <br> <br>                        PrevX = NextX; <br>                        PrevY = NextY; <br>                        MoveToEx(hDC, OrgX, OrgY, NULL); /* Draws the new box */ <br>                        LineTo(hDC, OrgX, PrevY); <br>                        LineTo(hDC, PrevX, PrevY); <br>                        LineTo(hDC, PrevX, OrgY); <br>                        LineTo(hDC, OrgX, OrgY); <br>                        ReleaseDC(hWnd, hDC); <br>                    } <br>                } <br>            } <br>            break; <br> <br>        case WM_LBUTTONUP: <br>            bTrack = FALSE;                 /* No longer creating a selection */ <br>            ReleaseCapture();               /* Releases hold on mouse input */ <br> <br>            X = LOWORD(lParam);             /* Saves the current value      */ <br>            Y = HIWORD(lParam); <br>            break; <br> <br>        case WM_KEYDOWN: <br>            if (wParam != VK_LEFT &amp;&amp; wParam != VK_RIGHT <br>                    &amp;&amp; wParam != VK_UP &amp;&amp; wParam != VK_DOWN) <br>                break; <br> <br>            MPOINT2POINT(ptCursor, pt); <br>            GetCursorPos(&amp;pt); <br> <br>            /* Convert screen coordinates to client coordinates */ <br> <br>            ScreenToClient(hWnd, &amp;pt); <br>            POINT2MPOINT(pt, ptCursor); <br>            repeat++;                           /* Increases the repeat rate */ <br> <br>            switch (wParam) { <br> <br>            /* Adjust cursor position according to which key was pressed. */ <br> <br>                case VK_LEFT: <br>                    ptCursor.x -= repeat; <br>                    break; <br> <br>                case VK_RIGHT: <br>                    ptCursor.x += repeat; <br>                    break; <br> <br>                case VK_UP: <br>                    ptCursor.y -= repeat; <br>                    break; <br> <br>                case VK_DOWN: <br>                    ptCursor.y += repeat; <br>                    break; <br> <br>            } <br> <br>            /* Get the client boundaries */ <br> <br>            GetClientRect(hWnd, &amp;Rect); <br> <br>            /* Do not draw outside the window's client area */ <br> <br>            MPOINT2POINT(ptCursor, pt); <br>            if (pt.x &gt;= Rect.right) <br>                pt.x = Rect.right - 1; <br>            else if (pt.x &lt; Rect.left) <br>                pt.x = Rect.left; <br>            if (pt.y &gt;= Rect.bottom) <br>                pt.y = Rect.bottom - 1; <br>            else if (pt.y &lt; Rect.top) <br>                pt.y = Rect.top; <br> <br>            /* Convert the coordinates to screen coordinates */ <br> <br>            ClientToScreen(hWnd, &amp;pt); <br>            SetCursorPos(pt.x, pt.y); <br>            break; <br> <br>        case WM_KEYUP: <br>            repeat = 1;                          /* Clears the repeat count. */ <br>            break; <br> <br>        case WM_ACTIVATE: <br>            if (!GetSystemMetrics(SM_MOUSEPRESENT)) { <br>                if (!HIWORD(wParam)) { <br>                    // LOWORD added for portability <br>                    if (LOWORD(wParam)) { <br>                        SetCursor(LoadCursor(hInst, "bullseye")); <br>                        pt.x = X; <br>                        pt.y = Y; <br>                        ClientToScreen(hWnd, &amp;pt); <br>                        SetCursorPos(pt.x, pt.y); <br>                    } <br>                    ShowCursor(wParam); <br>                } <br>            } <br>            break; <br> <br>        case WM_PAINT: <br>            { <br>                PAINTSTRUCT     ps; <br> <br>                hDC = BeginPaint (hWnd, &amp;ps); <br>                if (OrgX != PrevX || OrgY != PrevY) { <br>                    MoveToEx(hDC, OrgX, OrgY, NULL); <br>                    LineTo(hDC, OrgX, PrevY); <br>                    LineTo(hDC, PrevX, PrevY); <br>                    LineTo(hDC, PrevX, OrgY); <br>                    LineTo(hDC, OrgX, OrgY); <br>                } <br>                TextOut (hDC, 1, 1, str, strlen (str)); <br>                EndPaint (hWnd, &amp;ps); <br>            } <br>            break; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return (0); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: About(HWND, unsigned, WORD, LONG) <br> <br>    PURPOSE:  Processes messages for "About" dialog box <br> <br>    MESSAGES: <br> <br>        WM_INITDIALOG - initialize dialog box <br>        WM_COMMAND    - Input received <br> <br>****************************************************************************/ <br> <br>BOOL APIENTRY About(HWND hDlg, UINT message, UINT wParam, LONG lParam) <br>{ <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            // LOWORD added for portability <br>            if (LOWORD(wParam) == IDOK <br>                || LOWORD(wParam) == IDCANCEL) { <br>                EndDialog(hDlg, TRUE); <br>                return (TRUE); <br>            } <br>            break; <br>    } <br>    return (FALSE); <br>        UNREFERENCED_PARAMETER(lParam); <br>} <br> <br> <br>/**************************************************************************** <br> <br>    FUNCTION: Sieve() <br> <br>    PURPOSE:  Example of time consuming process <br> <br>    COMMENTS: <br> <br>        Sieve of Eratosthenes, BYTE, Volume 8, Number 1, by Jim Gilbreath <br>        and Gary Gilbreath.  Code changed to give correct results. <br> <br>        One could return the count, and after restoring the cursor, use <br>        sprintf() to copy the information to a string which could then be <br>        put up in a MessageBox(). <br> <br>****************************************************************************/ <br> <br>#define NITER   20                                 /* number of iterations */ <br>#define SIZE    8190 <br> <br>CHAR flags[SIZE+1]={ 0}; <br> <br>INT sieve() { <br>    INT i,k; <br>    INT iter, count; <br> <br>    for (iter = 1; iter &lt;= NITER; iter++) {      /* Does sieve NITER times */ <br>        count = 0; <br>        for (i = 0; i &lt;= SIZE; i++)              /* Sets all flags TRUE    */ <br>            flags[i] = TRUE; <br> <br>        for (i = 2; i &lt;= SIZE; i++) { <br>            if (flags[i] ) {                        /* Found a prime?       */ <br>                for (k = i + i; k &lt;= SIZE; k += i) <br>                    flags[k] = FALSE;              /* Cancelsits multiples */ <br>                count++; <br>            } <br>        } <br>    } <br>    return (count); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
