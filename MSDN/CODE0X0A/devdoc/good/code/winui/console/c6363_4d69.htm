<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>READOUT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6381"></a>READOUT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include "console.h" <br> <br>/******************************************************************** <br>* FUNCTION: invertRectangle(HANDLE hConOut, COORD coordStart,       * <br>*                           COORD coordCur)                         * <br>*                                                                   * <br>* PURPOSE: invert the attributes of the rectangle defined as the    * <br>*          area between two input COORD parameters                  * <br>*                                                                   * <br>* INPUT: the output handle of the console to make the changes to,   * <br>*        and two sets of COORD structures defining the rectangle to * <br>*        invert                                                     * <br>********************************************************************/ <br> <br>void invertRectangle(HANDLE hConOut, COORD coordStart, COORD coordCur) <br>{ <br>  WORD *awLineAttr; <br>  unsigned i; <br>  DWORD dwBoxWidth; <br>  WORD top, left, right, bottom; <br>  BOOL bSuccess; <br>  DWORD dwNumAttrsRead; <br> <br>  /* convert coordSart to upper left &amp; coordCur to lower right */ <br>  top = min(coordStart.Y, coordCur.Y); <br>  bottom = max(coordStart.Y, coordCur.Y); <br>  left = min(coordStart.X, coordCur.X); <br>  right = max(coordStart.X, coordCur.X); <br>  coordStart.X = left; <br>  coordStart.Y = top; <br>  coordCur.X = right; <br>  coordCur.Y = bottom; <br>  /* get the width of the selected area */ <br>  dwBoxWidth = right - left + 1; <br>  /* allocate a buffer for the attributes read from the console */ <br>  awLineAttr = (PWORD) malloc(getConX(hConOut) * sizeof(DWORD)); <br>  PERR(awLineAttr, "malloc"); <br>  /* for each line in the selected area */ <br>  while (coordStart.Y &lt;= coordCur.Y) <br>    { <br>    /* read the attributes on that line */ <br>    bSuccess = ReadConsoleOutputAttribute(hConOut, awLineAttr, <br>        dwBoxWidth, coordStart, &amp;dwNumAttrsRead); <br>    PERR(bSuccess, "ReadConsoleOutputAttribute"); <br>    /* for each attribute in the line, invert the color */ <br>    for (i = 0; i &lt; dwBoxWidth; i++) <br>      awLineAttr[i] = ~awLineAttr[i]; <br>    /* put the inverted color back on the line */ <br>    bSuccess = WriteConsoleOutputAttribute(hConOut, awLineAttr, dwBoxWidth, <br>        coordStart, &amp;dwNumAttrsRead); <br>    PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>    coordStart.Y++; /* go to the next line */ <br>    } <br>  free(awLineAttr); /* free allocated attribute buffer */ <br>  return; <br>} <br> <br> <br>/******************************************************************** <br>* FUNCTION: demoReadConOut(HANDLE hConOut)                          * <br>*                                                                   * <br>* PURPOSE: demonstrate ReadConsoleOutput, WriteConsoleOutput,       * <br>*          ReadConsoleOutputAttribute, and                          * <br>*          WriteConsoleOutputAttribute. Implement a cut and past    * <br>*          function; as the user clicks and drags the mouse, invert * <br>*          the selection rectangle to show the area selected. When  * <br>*          the mouse button is released, copy the selected area and * <br>*          paste it to the console                                  * <br>*                                                                   * <br>* INPUT: the output handle to read from and write to                * <br>********************************************************************/ <br> <br>void demoReadConOut(HANDLE hConOut) <br>{ <br>  BOOL bSuccess; <br>  INPUT_RECORD inputBuffer; <br>  DWORD dwStdInMode; <br>  HANDLE hStdIn; <br>  DWORD dwInputEvents; <br>  COORD coordStart, coordEnd, coordDest = {0, 0}; <br>  BOOL bDragMode = FALSE; /* mode flag - selecting (dragging) or not? */ <br>  COORD coordPrev; /* coordinates of the start of the selected area */ <br>  CHAR_INFO *pCharInfo; /* buffer to store info from ReadConsoleOutput */ <br>  COORD coordBufSize; /* the size of the buffer to read into */ <br>  SMALL_RECT srReadRegion; /* source rectangle to read from */ <br>  WORD top, left, right, bottom; /* sides of the source rectangle */ <br>  CONSOLE_SCREEN_BUFFER_INFO csbi; /* used to get cursor position */ <br> <br>  setConTitle(__FILE__); <br>  myPuts(hConOut, "Let's implement a simple cut &amp; paste with the left mouse\n" <br>                  "button. Click and drag to select an area of the screen\n" <br>                  "to copy. We will read, invert, then write the screen attributes\n" <br>                  "of the area you are dragging over to show the current\n" <br>                  "selection. Release the mouse button and I will read the\n" <br>                  "screen contained in the output area and print the contents\n" <br>                  "of the buffer to the screen at the current cursor location.\n" <br>                  "Hit ESC to return.\n\n"); <br>  hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br>  PERR(hStdIn != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  /* save the console mode */ <br>  bSuccess = GetConsoleMode(hStdIn, &amp;dwStdInMode); <br>  PERR(bSuccess, "GetConsoleMode"); <br>  /* enable mouse input */ <br>  bSuccess = SetConsoleMode(hStdIn, dwStdInMode | ENABLE_MOUSE_INPUT); <br>  PERR(bSuccess, "SetConsoleMode"); <br>  for(;;) <br>    { <br>    /* get an input event */ <br>    bSuccess = ReadConsoleInput(hStdIn, &amp;inputBuffer, 1, &amp;dwInputEvents); <br>    PERR(bSuccess, "ReadConsoleInput"); <br>    switch (inputBuffer.EventType) <br>      { <br>      case KEY_EVENT: <br>        /* is it an ESC character? */ <br>        if (inputBuffer.Event.KeyEvent.bKeyDown &amp;&amp; <br>            inputBuffer.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) <br>          { <br>          /* set input mode back to what it was originally and return */ <br>          bSuccess = SetConsoleMode(hStdIn, dwStdInMode); <br>          PERR(bSuccess, "SetConsoleMode"); <br>          return; <br>          } <br>        break; <br>      case MOUSE_EVENT: <br>        /* was this was a click event? */ <br>        if (inputBuffer.Event.MouseEvent.dwEventFlags != MOUSE_MOVED) <br>          /* is only leftmost button down? */ <br>          { <br>          if(inputBuffer.Event.MouseEvent.dwButtonState == <br>              FROM_LEFT_1ST_BUTTON_PRESSED) <br>            { <br>            /* save the starting coordinates of the selected area */ <br>            coordStart = coordPrev = <br>                inputBuffer.Event.MouseEvent.dwMousePosition; <br>            /* invert the single char attribute the cursor is on */ <br>            invertRectangle(hConOut, coordStart, coordStart); <br>            bDragMode = TRUE; /* we are now in 'drag' mode */ <br>            } <br>          else /* button #1 has just been released */ <br>            { <br>            /* if we're not in drag mode, break; we might get a mouse */ <br>            /* button release when gaining the focus */ <br>            if (!bDragMode) <br>              break; <br>            /* save the coordinates of the mouse release */ <br>            coordEnd = inputBuffer.Event.MouseEvent.dwMousePosition; <br>            bDragMode = FALSE; /* we're not in 'drag' mode anymore */ <br>            /* invert the rectangle back to normal */ <br>            invertRectangle(hConOut, coordStart, coordEnd); <br>            /* copy the buffer in the rectangle and output it. First convert */ <br>            /* coordSart to upper left &amp; coordCur to lower right */ <br>            top = min(coordStart.Y, coordEnd.Y); <br>            left = min(coordStart.X, coordEnd.X); <br>            bottom = max(coordStart.Y, coordEnd.Y); <br>            right = max(coordStart.X, coordEnd.X); <br>            coordStart.X = srReadRegion.Left = left; <br>            coordStart.Y = srReadRegion.Top = top; <br>            coordEnd.X = srReadRegion.Right = right; <br>            coordEnd.Y = srReadRegion.Bottom = bottom; <br>            /* get the size of the selected rectangle */ <br>            coordBufSize.X = coordEnd.X - coordStart.X + (SHORT) 1; <br>            coordBufSize.Y = coordEnd.Y - coordStart.Y + (SHORT) 1; <br>            /* allocate a buffer for the screen rectangle */ <br>            pCharInfo = malloc(coordBufSize.X * coordBufSize.Y * <br>                sizeof(CHAR_INFO)); <br>            PERR(pCharInfo, "malloc"); <br>            /* read the screen rectangle into the buffer */ <br>            bSuccess = ReadConsoleOutput(hConOut, /* output buffer */ <br>                pCharInfo, /* buffer that receives data */ <br>                coordBufSize, /* col/row size of destination buffer */ <br>                coordDest, /* upper-left cell to write data to in dest */ <br>                &amp;srReadRegion); /* screen buffer rectangle to read from */ <br>            PERR(bSuccess, "ReadConsoleOutput"); <br>            /* get current cursor position */ <br>            bSuccess = GetConsoleScreenBufferInfo(hConOut, &amp;csbi); <br>            PERR(bSuccess, "GetConsoleScreenBufferInfo"); <br>            /* set up an output destination rectangle for the buffer. */ <br>            /* Put it just below the current cursor position. */ <br>            srReadRegion.Top = csbi.dwCursorPosition.Y; <br>            srReadRegion.Bottom = csbi.dwCursorPosition.Y + (bottom - top); <br>            srReadRegion.Left = 0; <br>            srReadRegion.Right = right - left; <br>            bSuccess = WriteConsoleOutput(hConOut, /* output buffer */ <br>                pCharInfo, /* buffer with data to write */ <br>                coordBufSize, /* col/row size of source buffer */ <br>                coordDest, /* upper-left cell to write data from in src */ <br>                &amp;srReadRegion); /* screen buffer rect to write data to */ <br>            PERR(bSuccess, "WriteConsoleOutput"); <br>            free(pCharInfo); <br>            } <br>          } <br>        /* is it a mouse movement while we are in drag mode? */ <br>        if (inputBuffer.Event.MouseEvent.dwEventFlags == MOUSE_MOVED &amp;&amp; <br>            bDragMode) <br>          { <br>          /* if the cursor moves from the rectangle it was previously in, */ <br>          /* invert the old rectangle then invert the new rectangle. */ <br>          /* Compare the current coordinates with the previous coordinates */ <br>          if (memcmp(&amp;inputBuffer.Event.MouseEvent.dwMousePosition, <br>              &amp;coordPrev, sizeof(COORD))) <br>            { <br>            /* You could be clever and only invert what needs to be */ <br>            /* inverted rather than the entire two rectangles... */ <br>            /* Invert the old rectangle */ <br>            invertRectangle(hConOut, coordStart, coordPrev); <br>            /* and invert the new rectangle */ <br>            invertRectangle(hConOut, coordStart, <br>                inputBuffer.Event.MouseEvent.dwMousePosition); <br>            /* save the current mouse position to the previous position */ <br>            memcpy(&amp;coordPrev, <br>                &amp;inputBuffer.Event.MouseEvent.dwMousePosition, <br>                sizeof(COORD)); <br>            } <br>          } <br>        break; <br>      } /* switch */ <br>    } /* while */ <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
