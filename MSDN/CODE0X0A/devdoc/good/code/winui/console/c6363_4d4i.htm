<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILLATT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6372"></a>FILLATT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include "console.h" <br> <br>#pragma setlocale(".1252") <br> <br>/* number of colors in the color bar */ <br>#define MAXCOLORS 16 <br>/* horizontal size in characters of the sample text area */ <br>#define SAMPTEXTX 33 <br>/* veritcal size in characters of the sample text area */ <br>#define SAMPTEXTY 5 <br> <br>/******************************************************************** <br>* FUNCTION: demoFillAtt(HANDLE hConOut)                             * <br>*                                                                   * <br>* PURPOSE: demonstrate FillConsoleOutputAttribute and               * <br>*          WriteConsoleOutputCharacter. Create a console version of * <br>*          the "ScreenSize..." menu item from the console system    * <br>*          menu. Allow the user to select a foreground and          * <br>*          background color, which will be immediately displayed in * <br>*          the sample text box                                      * <br>*                                                                   * <br>* INPUT: the console output handle to write to                      * <br>********************************************************************/ <br> <br>void demoFillAtt(HANDLE hConOut) <br>{ <br>  COORD foregLoc = {5, 5}; /* foreground 'button' location */ <br>  COORD backgLoc = {5, 7}; /* background 'button' location */ <br>  COORD okLoc = {20, 5}; /* ok 'button' location */ <br>  COORD colorbarLoc = {6, 10};  /* loc of first color in colorbar */ <br>  COORD sampleLoc = {5, 13}; /* sample text location */ <br>  COORD dwBufCoord; /* temp COORD structure */ <br>  BOOL bSuccess; <br>  PCHAR szForeg = "  Screen Text"; /* foreground 'button' and text */ <br>  PCHAR szBackg = "  Screen Background"; /* background 'button' */ <br>  PCHAR szOk = "  OK"; /* OK 'button' */ <br>  /* these strings are the box around the color bar */ <br>  PCHAR szColors1 = "                                  "; <br>  PCHAR szColors2 = "                                  "; <br>  PCHAR szColors3 = "                                  "; <br>  WORD wButtonColor; /* holds the button 'color' */ <br>  DWORD dwCharsWritten; <br>  WORD i; <br>  INPUT_RECORD inputBuf; <br>  DWORD cInputEvents; <br>  BOOL bForeground; /* state flag: foreground button active? */ <br>  COORD wCurPos; <br>  HANDLE hStdIn; <br>  /* arraw of attributes to put in the colorbar, each attribute in 2 spaces */ <br>  WORD szAttr[MAXCOLORS * 2]; <br>  PCHAR szSampText = "A console consists of a keyboard and mouse input buffer" <br>                  " and one or more screen buffers.  \"CONIN$\" refers to the" <br>                  " input buffer. Stdin is a handle to \"CONIN$\".  \"CONOUT$\"" <br>                  " refers to a screen buffer."; <br>  PCHAR p; <br>  WORD wCurSampAttr; /* current attribute of the sample text area */ <br> <br>  setConTitle(__FILE__); <br>  /* place our "buttons" and text on the screen. First the 'foreground' */ <br>  /* button... */ <br>  bSuccess = WriteConsoleOutputCharacter(hConOut, szForeg, strlen(szForeg), <br>      foregLoc, &amp;dwCharsWritten); <br>  /* now the 'background' button */ <br>  PERR(bSuccess, "WriteConsoleOutputCharacter"); <br>  bSuccess = WriteConsoleOutputCharacter(hConOut, szBackg, strlen(szBackg), <br>      backgLoc, &amp;dwCharsWritten); <br>  /* place the 'OK' button */ <br>  PERR(bSuccess, "WriteConsoleOutputCharacter"); <br>  bSuccess = WriteConsoleOutputCharacter(hConOut, szOk, strlen(szOk), <br>      okLoc, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputCharacter"); <br>  /* now let's draw a boxed colorbar */ <br>  dwBufCoord = colorbarLoc; <br>  /* move up and left one to draw a box around the colorbar */ <br>  dwBufCoord.X--; <br>  dwBufCoord.Y--; <br>  /* the top of the box */ <br>  bSuccess = WriteConsoleOutputCharacter(hConOut, szColors1, strlen(szColors1), <br>      dwBufCoord, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputCharacter"); <br>  dwBufCoord.Y++; <br>  /* the middle of the box */ <br>  bSuccess = WriteConsoleOutputCharacter(hConOut, szColors2, strlen(szColors2), <br>      dwBufCoord, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputCharacter"); <br>  dwBufCoord.Y++; <br>  /* the bottom of the box */ <br>  bSuccess = WriteConsoleOutputCharacter(hConOut, szColors3, strlen(szColors3), <br>      dwBufCoord, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputCharacter"); <br> <br>  /* color the "buttons" a different color */ <br>  wButtonColor = FOREGROUND_WHITE | BACKGROUND_WHITE; <br>  /* color the 'backgroud' button */ <br>  bSuccess = WriteConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>      1, backgLoc, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>  /* color the 'OK' button */ <br>  bSuccess = WriteConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>      1, okLoc, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>  /* color the 'foreground' button, but with a different color */ <br>  wButtonColor = BACKGROUND_WHITE; <br>  bSuccess = WriteConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>      1, foregLoc, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>  bForeground = TRUE; /* the 'foreground' button is 'highlighted' */ <br> <br>  /* construct the attribute string */ <br>  for (i = 0; i &lt; MAXCOLORS; i++) <br>    /* for each set of two, the color attributes are in the high byte */ <br>    /* of the word - shift them into the high byte */ <br>    szAttr[i * 2] = szAttr[(i * 2) + 1] = i &lt;&lt; 4; <br>  /* write out the attributes at the colorbar location */ <br>  dwBufCoord = colorbarLoc; <br>  bSuccess = WriteConsoleOutputAttribute(hConOut, szAttr, MAXCOLORS * 2, <br>      dwBufCoord, &amp;dwCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutputAttribute"); <br> <br>  /* put up a sample text area */ <br>  p = szSampText; <br>  wCurPos = sampleLoc; <br>  wCurSampAttr = BACKGROUND_WHITE; <br>  for (i = 0; i &lt; SAMPTEXTY; i++) <br>    { <br>    bSuccess = WriteConsoleOutputCharacter(hConOut, p, <br>        min(strlen(p), SAMPTEXTX), wCurPos, &amp;dwCharsWritten); <br>    PERR(bSuccess, "WriteConsoleOutputCharacter"); <br>    /* color the text with the current sample attribute */ <br>    bSuccess = FillConsoleOutputAttribute(hConOut, wCurSampAttr, SAMPTEXTX, <br>        wCurPos, &amp;dwCharsWritten); <br>    PERR(bSuccess, "FillConsoleOutputAttribute"); <br>    wCurPos.Y++; <br>    /* advance pointer to the next row of characters in the sample string */ <br>    p += min(strlen(p), SAMPTEXTX); <br>    } <br> <br>  hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br>  PERR(hStdIn != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  for(;;) <br>    { <br>    /* get an input event */ <br>    bSuccess = ReadConsoleInput(hStdIn, &amp;inputBuf, 1, &amp;cInputEvents); <br>    /* if it's a mouse event but not a mouse move, it's a click */ <br>    PERR(bSuccess, "ReadConsoleInput"); <br>    if (inputBuf.EventType == MOUSE_EVENT &amp;&amp; <br>        inputBuf.Event.MouseEvent.dwEventFlags != MOUSE_MOVED) <br>      { <br>      wCurPos = inputBuf.Event.MouseEvent.dwMousePosition; <br>      /* is the mouse on the 'foreground' button? */ <br>      if (wCurPos.X == foregLoc.X &amp;&amp; wCurPos.Y == foregLoc.Y) <br>        { <br>        bForeground = TRUE; <br>        /* recolor the background color and foreground color */ <br>        /* of the foreground to show the foreground button active */ <br>        wButtonColor = BACKGROUND_WHITE; <br>        bSuccess = WriteConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>            1, foregLoc, &amp;dwCharsWritten); <br>        PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>        /* recolor the background color to show as inactive */ <br>        wButtonColor = FOREGROUND_WHITE | BACKGROUND_WHITE; <br>        bSuccess = WriteConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>            1, backgLoc, &amp;dwCharsWritten); <br>        PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>        } <br>      /* is the mouse on the 'background' button? */ <br>      if (wCurPos.X == backgLoc.X &amp;&amp; wCurPos.Y == backgLoc.Y) <br>        { <br>        bForeground = FALSE; <br>        /* recolor the background button to show as active */ <br>        wButtonColor = BACKGROUND_WHITE; <br>        bSuccess = WriteConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>            1, backgLoc, &amp;dwCharsWritten); <br>        PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>        /* recolor the foreground button to show as inactive */ <br>        wButtonColor = FOREGROUND_WHITE | BACKGROUND_WHITE; <br>        bSuccess = WriteConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>            1, foregLoc, &amp;dwCharsWritten); <br>        PERR(bSuccess, "WriteConsoleOutputAttribute"); <br>        } <br>      /* is the mouse on the 'OK' button? */ <br>      if (wCurPos.X == okLoc.X &amp;&amp; wCurPos.Y == okLoc.Y) <br>        break; <br>      /* is the mouse in the colorbar? */ <br>      if (wCurPos.Y == colorbarLoc.Y &amp;&amp; wCurPos.X &gt;= colorbarLoc.X &amp;&amp; <br>          wCurPos.X &lt; colorbarLoc.X + (SHORT) (MAXCOLORS * 2)) <br>        { <br>        /* get the screen attribute at the mouse position */ <br>        bSuccess = ReadConsoleOutputAttribute(hConOut, &amp;wButtonColor, <br>            sizeof(wButtonColor), wCurPos, &amp;dwCharsWritten); <br>        PERR(bSuccess, "ReadConsoleOutputAttribute"); <br>        /* if the foreground button is active, set the foreground */ <br>        /* attribute for the sample text */ <br>        if (bForeground) <br>          /* mask off the foreground color and 'or' it with the color */ <br>          /* we just got from the screen, shifted up to make it a */ <br>          /* foreground color (it's actually a background attribute when */ <br>          /* read from the console buffer). */ <br>          wCurSampAttr = (wCurSampAttr &amp; (WORD) 0xF0) | (wButtonColor &gt;&gt; 4); <br>        /* otherwise set the background attribute for the sample text */ <br>        else <br>          /* mask off the background color and 'or'  it with the background */ <br>          /* color we just read from the console. */ <br>          wCurSampAttr = (wCurSampAttr &amp; (WORD) 0x0F) | wButtonColor; <br>        /* now set the attribute of the sample text to the new attribute */ <br>        wCurPos = sampleLoc; <br>        for (i = 0; i &lt; SAMPTEXTY; i++) <br>          { <br>          bSuccess = FillConsoleOutputAttribute(hConOut, wCurSampAttr, <br>              SAMPTEXTX, wCurPos, &amp;dwCharsWritten); <br>          PERR(bSuccess, "FillConsoleOutputAttribute"); <br>          wCurPos.Y++; <br>          } <br>        }  /* if */ <br>      }  /* if */ <br>    }  /* while */ <br>  return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
