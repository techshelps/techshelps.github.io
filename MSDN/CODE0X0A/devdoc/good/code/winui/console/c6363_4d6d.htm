<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WRITEIN.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6385"></a>WRITEIN.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;ctype.h&gt; <br>#include "console.h" <br> <br>#define MAX_MACRO_EVENTS 256 <br>#define ALT_PRESSED (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED) <br>#define CONTROL_KEY (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED | \ <br>                     RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED | ENHANCED_KEY) <br> <br>/************************************************************************ <br>* FUNCTION: demoWriteIn(HANDLE hConOut)                                 * <br>*                                                                       * <br>* PURPOSE: demonstrate WriteConsoleInput by implementing a macro        * <br>*          recording facility that writes the recorded keystrokes to    * <br>*          the input queue for playback.                                * <br>*                                                                       * <br>* INPUT: the console buffer to record from and playback to              * <br>*                                                                       * <br>* RETURNS: none                                                         * <br>*************************************************************************/ <br> <br> <br>void demoWriteIn(HANDLE hConOut) <br>{ <br>  BOOL bSuccess; <br>  HANDLE hStdIn; /* standard input handle */ <br>  INPUT_RECORD inputBuffer; /* buffer to hold a single console input record */ <br>  INPUT_RECORD irMacroBuf[MAX_MACRO_EVENTS]; /* array of input events */ <br>  DWORD dwInputEvents; <br>  DWORD dwBytesWritten, dwRecordsWritten; <br>  CHAR bOutBuf[256]; /* buffer to format event information into */ <br>  BOOL bRecording = FALSE; /* TRUE if recording a macro */ <br>  int iir = 0; /* index into macro input buffer */ <br>  CHAR c; <br> <br>  setConTitle(__FILE__); <br>  myPuts(hConOut, "\n\nLet's implement a simple macro record/playback facility.\n" <br>                  "Hit Alt+R to record, and Alt+P to playback. After turning\n" <br>                  "on Record mode, enter some keystrokes or mouse clicks.\n" <br>                  "Hit Alt+R to turn Record mode off, and Alt+P to playback\n" <br>                  "your keystrokes. I'll use the WriteConsoleInput API to\n" <br>                  "insert the recorded events into the input buffer.\n" <br>                  "Hit ESC at any time to return."); <br>  hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br>  PERR(hStdIn != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  for(;;) <br>    { <br>    /* if our macro event buffer is full, leave Record mode */ <br>    if (iir == MAX_MACRO_EVENTS &amp;&amp; bRecording) <br>      { <br>      bRecording = FALSE; <br>      putStatusLine(hConOut, ""); <br>      } <br>    /* read an input event from the input event queue */ <br>    bSuccess = ReadConsoleInput(hStdIn, &amp;inputBuffer, 1, &amp;dwInputEvents); <br>    PERR(bSuccess, "ReadConsoleInput"); <br>    switch (inputBuffer.EventType) <br>      { <br>      case KEY_EVENT: <br>        if (inputBuffer.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) <br>          return; <br>        /* get the character that we read */ <br>        c = inputBuffer.Event.KeyEvent.uChar.AsciiChar; <br>        if (!bRecording) <br>          { <br>          /* ignore key releases */ <br>          if (!inputBuffer.Event.KeyEvent.bKeyDown) <br>            break; <br>          /* display the key event info on the status line */ <br>          sprintf(bOutBuf, "key: virtual=%d ascii=%c", <br>              inputBuffer.Event.KeyEvent.wVirtualKeyCode, c); <br>          putStatusLine(hConOut, bOutBuf); <br>          /* if it's printable, and no control keys are down, show it */ <br>          if (isprint(c) &amp;&amp; !(inputBuffer.Event.KeyEvent.dwControlKeyState &amp; <br>                CONTROL_KEY)) <br>            { <br>            bSuccess = WriteFile(hConOut, &amp;c, sizeof(c), &amp;dwBytesWritten, <br>                NULL); <br>            PERR(bSuccess, "WriteFile"); <br>            } <br>          /* is it an 'r' key? Is either the left or right ALT key down? */ <br>          if (c == 'r' &amp;&amp; (inputBuffer.Event.KeyEvent.dwControlKeyState &amp; <br>              (ALT_PRESSED))) <br>            { <br>            bRecording = TRUE; <br>            iir = 0; /* reset macro buffer pointer to beginning */ <br>            putStatusLine(hConOut, "RECORDING..."); <br>            } <br>          /* is it a 'p' key? Is either the left of right ALT key down? */ <br>          if (c == 'p' &amp;&amp; (inputBuffer.Event.KeyEvent.dwControlKeyState &amp; <br>              (ALT_PRESSED))) <br>            { <br>            /* stuff all the input events into the input buffer */ <br>            bSuccess = WriteConsoleInput(hStdIn, /* console input buffer */ <br>                irMacroBuf, /* address of the buffer for write data */ <br>                iir, /* number of records to write */ <br>                &amp;dwRecordsWritten); /* returns number of records written */ <br>            PERR(bSuccess, "WriteConsoleInput"); <br>            } <br>          } <br>        else /* we're recording */ <br>          { <br>          if (inputBuffer.Event.KeyEvent.bKeyDown) <br>            { <br>            /* is it an 'r' key? Is either the left or right ALT key down? */ <br>            if (c == 'r' &amp;&amp; (inputBuffer.Event.KeyEvent.dwControlKeyState &amp; <br>                (ALT_PRESSED))) <br>              { <br>              bRecording = FALSE; <br>              putStatusLine(hConOut, ""); <br>              break; <br>              } <br>            /* we need to ignore the 'playback' keystroke or we'll */ <br>            /* automatically start playing back during playback! */ <br>            if (c == 'p' &amp;&amp; (inputBuffer.Event.KeyEvent.dwControlKeyState &amp; <br>                (ALT_PRESSED))) <br>              break; <br>            /* if it's printable, and no control keys are down, show it */ <br>            if (isprint(c) &amp;&amp; !(inputBuffer.Event.KeyEvent.dwControlKeyState &amp; <br>                CONTROL_KEY)) <br>              { <br>              bSuccess = WriteFile(hConOut, &amp;c, sizeof(c), &amp;dwBytesWritten, <br>                  NULL); <br>              PERR(bSuccess, "WriteFile"); <br>              } <br>            } <br>          /* store the key event in the macro buffer */ <br>          memcpy(&amp;irMacroBuf[iir++], &amp;inputBuffer, sizeof(inputBuffer)); <br>          } /* else */ <br>        break; <br>      case MOUSE_EVENT: <br>        if (!bRecording) <br>          { <br>          sprintf(bOutBuf, "mouse: %s at %d, %d", <br>              (inputBuffer.Event.MouseEvent.dwEventFlags == MOUSE_MOVED ? <br>              "moved" : "clicked"), inputBuffer.Event.MouseEvent.dwMousePosition.X, <br>              inputBuffer.Event.MouseEvent.dwMousePosition.Y); <br>          putStatusLine(hConOut, bOutBuf); <br>          } <br>        else /* copy the mouse event into the macro buffer */ <br>          memcpy(&amp;irMacroBuf[iir++], &amp;inputBuffer, sizeof(inputBuffer)); <br>        break; <br>      case WINDOW_BUFFER_SIZE_EVENT: <br>        if (!bRecording) <br>          { <br>          sprintf(bOutBuf, "window: %d, %d", <br>              inputBuffer.Event.WindowBufferSizeEvent.dwSize.X, <br>              inputBuffer.Event.WindowBufferSizeEvent.dwSize.Y); <br>          putStatusLine(hConOut, bOutBuf); <br>          Sleep(1000); <br>          } <br>        break; <br>      } /* switch */ <br>    } /* while */ <br>  return; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
