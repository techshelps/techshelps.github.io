<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GETNUMEV.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6376"></a>GETNUMEV.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include "console.h" <br> <br>/* maximum number of input queue events to peek at */ <br>#define INPUT_RECS 256 <br> <br>/* array of records to store peeked events from the input queue */ <br>INPUT_RECORD aInputBuffer[INPUT_RECS]; <br> <br>/********************************************************************* <br>* FUNCTION: demoGetNumEvents(HANDLE hConOut)                         * <br>*                                                                    * <br>* PURPOSE: demonstrate GetNumberOfConsoleInputEvents,                * <br>*          PeekConsoleInput, and ReadConsoleInput. Delay the         * <br>*          processing of console input to start filling the input    * <br>*          queue. The number of console events in the input queue    * <br>*          will be updated in the status line at the top of the      * <br>*          console. Peek the unread characters for an ESC and return * <br>*          when one is found                                         * <br>*                                                                    * <br>* INPUT: console output handle to write to                           * <br>*********************************************************************/ <br> <br>void demoGetNumEvents(HANDLE hConOut) <br>{ <br>  BOOL bSuccess; <br>  DWORD dwNumEvents; /* number of events in the input queue */ <br>  DWORD dwStdInMode; /* save the input mode here */ <br>  HANDLE hStdIn; <br>  DWORD dwInputEvents; /* number of events read from the queue */ <br>  CHAR bOutBuf[256], szTemp[256]; <br>  /* indexes to latest unread event checked for ESC char */ <br>  DWORD iEvent, iPrevEvent; <br>  DWORD dwEventsPeeked; /* number of events peeked at */ <br>  unsigned i; <br>  DWORD dwCharsWritten; <br> <br>  setConTitle(__FILE__); <br>  hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br>  PERR(hStdIn != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  myPuts(hConOut, "\nLet's display a running count of events waiting in the\n" <br>                  "console input queue by using the GetNumberOfConsoleInputEvents\n" <br>                  "API. I will enable mouse input in this console; try\n" <br>                  "generating a lot of mouse and keyboard events. I will\n" <br>                  "read them from the input queue using ReadConsoleInput\n" <br>                  "with .5 second delays between reads. Note the event\n" <br>                  "count and event information on the top line.\n\n" <br>                  "Hit ESC at any time to return. We will use\n" <br>                  "PeekConsoleInput to monitor the unread input queue\n" <br>                  "contents for an ESC character. When this character\n" <br>                  "is detected, we will flush the input queue and return\n" <br>                  "immediately. Note that for simplification of this\n" <br>                  "demo only the first 256 unread events will be scanned\n" <br>                  "to find an ESC keystroke.\n\n"); <br> <br>  bSuccess = GetConsoleMode(hStdIn, &amp;dwStdInMode); <br>  PERR(bSuccess, "GetConsoleMode"); <br>  /* when turning off ENABLE_LINE_INPUT, you MUST also turn off */ <br>  /* ENABLE_ECHO_INPUT. */ <br>  bSuccess = SetConsoleMode(hStdIn, (dwStdInMode &amp; ~(ENABLE_LINE_INPUT | <br>      ENABLE_ECHO_INPUT)) | ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT); <br>  PERR(bSuccess, "SetConsoleMode"); <br>  iEvent = 0; /* index to last event peeked in the input queue */ <br>  for(;;) <br>    { <br>    Sleep(500); <br>    bSuccess = GetNumberOfConsoleInputEvents(hStdIn, &amp;dwNumEvents); <br>    PERR(bSuccess, "GetNumberOfConsoleInputEvents"); <br>    sprintf(bOutBuf, "input queue events: %d", dwNumEvents); <br>    if (!dwNumEvents) <br>      /* put a status line on the first line */ <br>      putStatusLine(hConOut, bOutBuf); <br>    else <br>      { <br>      /* save the previous index we've peeked at */ <br>      iPrevEvent = iEvent; <br>      /* peek at the console input queue. Don't peek more than what will */ <br>      /* fit in the buffer */ <br>      bSuccess = PeekConsoleInput(hStdIn, aInputBuffer, min(dwNumEvents, <br>          INPUT_RECS), &amp;dwEventsPeeked); <br>      PERR(bSuccess, "PeekConsoleInput"); <br>      /* set current index to the highest number event peeked at */ <br>      iEvent = dwEventsPeeked; <br>      /* scan unread events for an ESC key */ <br>      for (i = iPrevEvent; i &lt; iEvent; i++) <br>        { <br>        if (aInputBuffer[i].EventType == KEY_EVENT &amp;&amp; <br>            aInputBuffer[i].Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) <br>          { <br>          /* set input mode back to what it was originally */ <br>          bSuccess = SetConsoleMode(hStdIn, dwStdInMode); <br>          PERR(bSuccess, "SetConsoleMode"); <br>          /* flush the input buffer and return */ <br>          bSuccess = FlushConsoleInputBuffer(hStdIn); <br>          PERR(bSuccess, "FlushConsoleInputBuffer"); <br>          return; <br>          } <br>        } /* for */ <br>      } /* else */ <br>    bSuccess = ReadConsoleInput(hStdIn, &amp;aInputBuffer[0], 1, &amp;dwInputEvents); <br>    PERR(bSuccess, "ReadConsoleInput"); <br>    /* decrement "last peeked at" index by number of records we just read */ <br>    iEvent -= dwInputEvents; <br>    switch (aInputBuffer[0].EventType) <br>      { <br>      case KEY_EVENT: <br>        if (aInputBuffer[0].Event.KeyEvent.bKeyDown) <br>          { <br>          if (aInputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) <br>            { <br>            /* set input mode back to what it was originally */ <br>            bSuccess = SetConsoleMode(hStdIn, dwStdInMode); <br>            PERR(bSuccess, "SetConsoleMode"); <br>            return; <br>            } <br>          /* put the keystroke information on the status line */ <br>          sprintf(szTemp, " keystroke: %c", <br>              aInputBuffer[0].Event.KeyEvent.uChar.AsciiChar); <br>          strcat(bOutBuf, szTemp); <br>          /* put the status line on the screen */ <br>          putStatusLine(hConOut, bOutBuf); <br>          /* output the character read from the input queue */ <br>          bSuccess = WriteFile(hConOut, <br>              &amp;aInputBuffer[0].Event.KeyEvent.uChar.AsciiChar, 1, <br>              &amp;dwCharsWritten, NULL); <br>          PERR(bSuccess, "WriteFile"); <br>          } <br>        break; <br>      case MOUSE_EVENT: <br>        sprintf(szTemp, " mouse: %s at %d, %d", <br>            (aInputBuffer[0].Event.MouseEvent.dwEventFlags == MOUSE_MOVED ? <br>            "moved" : "clicked"), aInputBuffer[0].Event.MouseEvent.dwMousePosition.X, <br>            aInputBuffer[0].Event.MouseEvent.dwMousePosition.Y); <br>        strcat(bOutBuf, szTemp); <br>        putStatusLine(hConOut, bOutBuf); <br>        break; <br>      case WINDOW_BUFFER_SIZE_EVENT: <br>        sprintf(szTemp, " window: %d, %d", <br>            aInputBuffer[0].Event.WindowBufferSizeEvent.dwSize.X, <br>            aInputBuffer[0].Event.WindowBufferSizeEvent.dwSize.Y); <br>        strcat(bOutBuf, szTemp); <br>        putStatusLine(hConOut, bOutBuf); <br>        break; <br>      } /* switch */ <br>    } /* while */ <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
