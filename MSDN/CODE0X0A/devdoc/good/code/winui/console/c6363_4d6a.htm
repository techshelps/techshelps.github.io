<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCROLL.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6382"></a>SCROLL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "console.h" <br> <br>/* The following is the sample text that we will place on the lower <br>half of the screen to scroll: */ <br> <br>static PCHAR szSampTxt = <br>  "BOOL ScrollConsoleScreenBuffer( hConsoleOutput, lpScrollRectangle,\n" <br>  "                               lpClipRectangle, dwDestinationOrigin,\n" <br>  "                               lpFill)\n" <br>  "HANDLE hConsoleOutput;\n" <br>  "PSMALL_RECT lpScrollRectangle;\n" <br>  "PSMALL_RECT lpClipRectangle;\n" <br>  "COORD dwDestinationOrigin;\n" <br>  "PCHAR_INFO lpFill;\n" <br>  "\n" <br>  "This function may be used to scroll the data in the screen buffer.\n" <br>  "\n" <br>  "Parameter            Description\n" <br>  "                                                                            \n" <br>  "hConsoleOutput       Supplies an open handle to console output.\n" <br>  "lpScrollRectangle    Pointer to region within screen buffer to move.\n" <br>  "lpClipRectangle      Pointer to region within screen buffer that may be\n" <br>  "                     affected by this scroll. This pointer may be NULL.\n" <br>  "dwDestinationOrigin  Upper left corner of new location of ScrollRectangle\n" <br>  "                     contents.\n" <br>  "lpFill               Pointer to structure containing new contents of\n" <br>  "                     ScrollRectangle region.\n" <br>  "\n" <br>  "Return Value\n" <br>  "The return value is TRUE if the function was successful, otherwise it is\n" <br>  "FALSE in which case extended error information can be retrieved by calling\n" <br>  "the GetLastError function.\n" <br>  "\n" <br>  "Comments\n" <br>  "This function copies the contents of a rectangular region of the screen\n" <br>  "buffer, the scroll region, to another area of the screen buffer, the target\n" <br>  "region. The target region is defined as a rectangle the same dimensions as\n" <br>  "the scroll region with the upper left corner at dwDestinationOrigin. Each\n" <br>  "cell in the scroll region is then filled with the contents of Fill. Any\n" <br>  "overlap between the scroll region and the target region is not filled. The\n" <br>  "clip rectangle applies to changes made in both the ScrollRectangle and the\n" <br>  "destination rectangle, i.e. if the clip rectangle does not include the\n" <br>  "scroll rectangle, the scroll rectangle will not be updated with the contents"; <br> <br> <br>/******************************************************************* <br>* FUNCTION: demoScrollCon(HANDLE hConOut)                          * <br>*                                                                  * <br>* PURPOSE: demonstrate ScrollConsoleScreenBuffer. Scroll the lower * <br>*          half of the console with each mouse click               * <br>*                                                                  * <br>* INPUT: the console output handle to scroll                       * <br>********************************************************************/ <br> <br>void demoScrollCon(HANDLE hConOut) <br>{ <br>  BOOL bSuccess; <br>  INPUT_RECORD inputBuffer; <br>  DWORD dwStdInMode; <br>  HANDLE hStdIn; <br>  DWORD dwInputEvents; <br>  COORD coordDest; /* destination of scroll movement */ <br>  BOOL bDragMode = FALSE; <br>  CHAR_INFO chiFill; /* char and attributes to fill empty space with */ <br>  CONSOLE_SCREEN_BUFFER_INFO csbi; /* used to get current attribute */ <br>  SMALL_RECT srctScrollRect; /* area of the screen to scroll */ <br> <br>  setConTitle(__FILE__); <br>  myPuts(hConOut, "Let's use ScrollConsoleScreenBuffer to scroll the lower"); <br>  myPuts(hConOut, "half of the screen up with each mouse click. I'll fill the"); <br>  myPuts(hConOut, "screen with some sample text so you can see the effect."); <br>  myPuts(hConOut, "Hit return to continue, and hit ESC at any time to return.\n"); <br>  myGetchar(); <br>  myPuts(hConOut, szSampTxt); <br>  hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br>  PERR(hStdIn != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  bSuccess = GetConsoleMode(hStdIn, &amp;dwStdInMode); <br>  PERR(bSuccess, "GetConsoleMode"); <br>  bSuccess = SetConsoleMode(hStdIn, dwStdInMode | ENABLE_MOUSE_INPUT); <br>  PERR(bSuccess, "SetConsoleMode"); <br>  /* define region we want to move */ <br>  srctScrollRect.Top = getConY(hConOut) / 2; <br>  srctScrollRect.Bottom = getConY(hConOut) - 1; <br>  srctScrollRect.Left = 0; <br>  srctScrollRect.Right = getConX(hConOut) - 1; <br>  /* define origin where we want to move the scrolled region */ <br>  coordDest.X = 0; <br>  coordDest.Y = (getConY(hConOut) / 2) - 1; <br>  /* get current attributes and fill out CHAR_INFO structure for fill char */ <br>  bSuccess = GetConsoleScreenBufferInfo(hConOut, &amp;csbi); <br>  PERR(bSuccess, "GetConsoleScreenBufferInfo"); <br>  chiFill.Char.AsciiChar = ' '; <br>  chiFill.Attributes = csbi.wAttributes; <br>  for(;;) <br>    { <br>    bSuccess = ReadConsoleInput(hStdIn, &amp;inputBuffer, 1, &amp;dwInputEvents); <br>    PERR(bSuccess, "ReadConsoleInput"); <br>    switch (inputBuffer.EventType) <br>      { <br>      case KEY_EVENT: <br>        if (inputBuffer.Event.KeyEvent.bKeyDown &amp;&amp; <br>            inputBuffer.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) <br>          { <br>          /* set input mode back to what it was originally */ <br>          bSuccess = SetConsoleMode(hStdIn, dwStdInMode); <br>          PERR(bSuccess, "SetConsoleMode"); <br>          return; <br>          } <br>        break; <br>      case MOUSE_EVENT: <br>        /* was this was a click or double click event? Is any button down? */ <br>        if (inputBuffer.Event.MouseEvent.dwEventFlags != MOUSE_MOVED &amp;&amp; <br>            inputBuffer.Event.MouseEvent.dwButtonState) <br>          { <br>          bSuccess = ScrollConsoleScreenBuffer(hConOut, <br>              &amp;srctScrollRect, <br>              NULL, /* no clipping rectangle */ <br>              coordDest, /* coordinates of destination */ <br>              &amp;chiFill); /* attribute to fill empty space with */ <br>          PERR(bSuccess, "ScrollConsoleScreenBuffer"); <br>          } <br>        break; <br>      } /* switch */ <br>    } /* while */ <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
