<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONSOLE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6367"></a>CONSOLE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br>version 1.0 (initial release) <br>version 1.1 (March beta release) <br>  - now using MessageBox to display errors rather than the console <br>  - handler/demo for new CTRL_CLOSE_EVENT added to handler.c <br>  - demo for GenerateConsoleCtrlEvent added to SetConsoleCtrlHandler demo <br>  - larger screen/buffer sizes for buffer/console window sizing demos <br>  - fixed resizeConBufAndWindow bug in size.c <br>version 1.2 <br>  - fixed bug in readout.c - dragging large areas caused trap d <br>version 1.3 <br>  - make cls() more generic - now clears attributes as well <br>version 1.4 <br>  - added Get/SetConsoleOutputCP demos <br> <br>Notes: <br>This sample needs some minor work to make it Unicode-capable; some <br>variable types need to be tweaked to Unicode-friendly types ('TCHAR' rather <br>than 'char', etc.) <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "console.h" <br>#include "size.h"  /* for resizeConBufAndWindow() */ <br>           <br> <br>/* used to set our initial console screen buffer size */ <br>#define CONX 80 <br>#define CONY 43 <br> <br>/* prototypes of externally defined demo functions */ <br>extern void demoAllocFree(HANDLE hConOld, HANDLE *hConsole); <br>extern void demoCreate(HANDLE hConOld); <br>extern void demoFillAtt(HANDLE hConOut); <br>extern void demoFillChar(HANDLE hConOut); <br>extern void demoFlush(HANDLE hConOut); <br>extern void demoCursor(HANDLE hConOut); <br>extern void demoConMode(HANDLE hConOut); <br>extern void demoConInfo(HANDLE hConOut); <br>extern void demoGetTitle(HANDLE hConOut); <br>extern void demoGetLargest(HANDLE hConOut); <br>extern void demoGetNumEvents(HANDLE hConOut); <br>extern void demoGetNumBut(HANDLE hConOut); <br>extern void demoReadConOut(HANDLE hConOut); <br>extern void demoReadConChar(HANDLE hConOut); <br>extern void demoScrollCon(HANDLE hConOut); <br>extern void demoSizeInfo(HANDLE hConOut); <br>extern void demoSetCtrlHandler(HANDLE hConOut); <br>extern void demoWriteIn(HANDLE hConOut); <br>extern void demoOutputCodePage(HANDLE hConOut); <br>extern void demoInputCodePage(HANDLE hConOut); <br> <br>/* information to display on the screen for user to click on */ <br>PCHAR conAPIs[] = { <br>  "AllocConsole                    Creates a console for the current process", <br>  "CreateConsoleScreenBuffer       Returns a handle to a new screen buffer", <br>  "FillConsoleOutputAttribute      Writes attributes to the screen buffer", <br>  "FillConsoleOutputCharacter      Writes characters to the screen buffer", <br>  "FlushConsoleInputBuffer         Clears the console input buffer", <br>  "FreeConsole                     Frees the current console", <br>  "GenerateConsoleCtrlEvent        Generates a console control event", <br>  "GetConsoleCP                    Get current console input codepage", <br>  "GetConsoleOutputCP              Get current console output codepage", <br>  "GetConsoleCursorInfo            Returns console size and visibility", <br>  "GetConsoleMode                  Returns console input or output mode", <br>  "GetConsoleScreenBufferInfo      Returns screen-buffer information", <br>  "GetConsoleTitle                 Returns console-window title", <br>  "GetLargestConsoleWindowSize     Returns largest possible window size", <br>  "GetNumberOfConsoleInputEvents   Retrieves number of console-queue events", <br>  "GetNumberOfConsoleMouseButtons  Retrieves number of mouse buttons", <br>  "PeekConsoleInput                Previews console input data", <br>  "ReadConsoleInput                Reads console input data", <br>  "ReadConsoleOutput               Reads screen-buffer data", <br>  "ReadConsoleOutputAttribute      Reads a console attribute string", <br>  "ReadConsoleOutputCharacter      Reads a screen-buffer string", <br>  "ScrollConsoleScreenBuffer       Scrolls data in the screen buffer", <br>  "SetConsoleActiveScreenBuffer    Changes displayed screen buffer", <br>  "SetConsoleCP                    Sets console input codepage", <br>  "SetConsoleOutputCP              Sets console output codepage", <br>  "SetConsoleCursorInfo            Sets cursor size and visibility", <br>  "SetConsoleCursorPosition        Sets cursor position", <br>  "SetConsoleMode                  Sets console input or output mode", <br>  "SetConsoleScreenBufferSize      Changes screen-buffer size", <br>  "SetConsoleTextAttribute         Sets attributes for screen text", <br>  "SetConsoleTitle                 Sets console-window title string", <br>  "SetConsoleWindowInfo            Sets console window size", <br>  "SetConsoleCtrlHandler           Sets console ctrl-c handler", <br>  "WriteConsoleInput               Writes to console input buffer", <br>  "WriteConsoleOutput              Writes to screen buffer", <br>  "WriteConsoleOutputAttribute     Writes an attribute string to console", <br>  "WriteConsoleOutputCharacter     Writes a character string to console" <br>}; <br> <br>/* this variable holds the number next to the API on the screen that */ <br>/* the user clicks on */ <br>enum cAPIs { ALLOC = 1, CREATE, FILLATT, FILLCHAR, FLUSH, FREE, <br>  GENCTRL, GETCP, GETOUTCP, GETCUR, GETMODE, GETCONINFO, GETTITLE, <br>  GETLARGEST, GETNUMEV, GETNUMBUT, PEEK, READCONIN, READCONOUT, <br>  READCONATT, READCONCHAR, SCROLL, SETACTIVE, SETCP, SETOUTCP, <br>  SETCURINF, SETCURPOS, SETMODE, SETSIZE, SETATT, SETTITLE, SETINFO, <br>  SETHAND, WRITEIN, WRITEOUT, WRITEATT, WRITECHAR }; <br> <br> <br>/***************************************************************** <br>* FUNCTION: myGetchar(void)                                      * <br>*                                                                * <br>* PURPOSE: get a single character from the standard input handle * <br>*                                                                * <br>* INPUT: none                                                    * <br>*                                                                * <br>* RETURNS: the char received from the console                    * <br>*****************************************************************/ <br> <br>CHAR myGetchar(void) <br>{ <br>  HANDLE hStdIn; /* standard input */ <br>  DWORD dwInputMode; /* to save the input mode */ <br>  BOOL bSuccess; <br>  CHAR chBuf; /* buffer to read into */ <br>  DWORD dwRead; <br> <br>  /* get the standard input handle to read from. There is only one */ <br>  /* instance of standard input per process at any given time */ <br>  hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br>  PERR(hStdIn != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  /* save the console mode */ <br>  bSuccess = GetConsoleMode(hStdIn, &amp;dwInputMode); <br>  PERR(bSuccess, "GetconsoleMode"); <br>  /* disable line input. Echo input must be disabled when disabling */ <br>  /* line input */ <br>  bSuccess = SetConsoleMode(hStdIn, dwInputMode &amp; ~ENABLE_LINE_INPUT &amp; <br>      ~ENABLE_ECHO_INPUT); <br>  PERR(bSuccess, "SetConsoleMode"); <br>  /* read a character from the console input */ <br>  bSuccess = ReadFile(hStdIn, &amp;chBuf, sizeof(chBuf), &amp;dwRead, NULL); <br>  PERR(bSuccess, "ReadFile"); <br>  /* restore the original console input mode */ <br>  bSuccess = SetConsoleMode(hStdIn, dwInputMode); <br>  PERR(bSuccess, "SetConsoleMode"); <br>  return(chBuf); <br>} <br> <br>/********************************************************************* <br>* FUNCTION: perr(PCHAR szFileName, int line, PCHAR szApiName,        * <br>*                DWORD dwError)                                      * <br>*                                                                    * <br>* PURPOSE: report API errors. Allocate a new console buffer, display * <br>*          error number and error text, restore previous console     * <br>*          buffer                                                    * <br>*                                                                    * <br>* INPUT: current source file name, current line number, name of the  * <br>*        API that failed, and the error number                       * <br>*                                                                    * <br>* RETURNS: none                                                      * <br>*********************************************************************/ <br> <br>/* maximum size of the buffer to be returned from FormatMessage */ <br>#define MAX_MSG_BUF_SIZE 512 <br> <br>void perr(PCHAR szFileName, int line, PCHAR szApiName, DWORD dwError) <br>{ <br>  CHAR szTemp[1024]; <br>  DWORD cMsgLen; <br>  CHAR *msgBuf; /* buffer for message text from system */ <br>  int iButtonPressed; /* receives button pressed in the error box */ <br> <br>  /* format our error message */ <br>  sprintf(szTemp, "%s: Error %d from %s on line %d:\n", szFileName, <br>      dwError, szApiName, line); <br>  /* get the text description for that error number from the system */ <br>  cMsgLen = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | <br>      FORMAT_MESSAGE_ALLOCATE_BUFFER | 40, NULL, dwError, <br>      MAKELANGID(0, SUBLANG_ENGLISH_US), (LPTSTR) &amp;msgBuf, MAX_MSG_BUF_SIZE, <br>      NULL); <br>  if (!cMsgLen) <br>    sprintf(szTemp + strlen(szTemp), "Unable to obtain error message text! \n" <br>        "%s: Error %d from %s on line %d", __FILE__, <br>        GetLastError(), "FormatMessage", __LINE__); <br>  else <br>    strcat(szTemp, msgBuf); <br>  strcat(szTemp, "\n\nContinue execution?"); <br>  MessageBeep(MB_ICONEXCLAMATION); <br>  iButtonPressed = MessageBox(NULL, szTemp, "Console API Error", <br>      MB_ICONEXCLAMATION | MB_YESNO | MB_SETFOREGROUND); <br>  /* free the message buffer returned to us by the system */ <br>  if (cMsgLen) <br>    LocalFree((HLOCAL) msgBuf); <br>  if (iButtonPressed == IDNO) <br>    exit(1); <br>  return; <br>} <br> <br>/************************************************************************* <br>* FUNCTION: myPuts(HANDLE hConsole, PCHAR s)                             * <br>*                                                                        * <br>* PURPOSE: write a string to the given console buffer, appending a cr/lf * <br>*                                                                        * <br>* INPUT: the console to write to, and the string to write                * <br>*                                                                        * <br>* RETURNS: TRUE if success, FALSE if an error occured                    * <br>*************************************************************************/ <br> <br>BOOL myPuts(HANDLE hConsole, PCHAR s) <br>{ <br>  BOOL bSuccess; <br>  DWORD cCharsWritten; <br>  const PCHAR crlf = "\n"; <br>  BOOL retflag = TRUE; <br> <br>  /* write the string to the console */ <br>  bSuccess = WriteConsole(hConsole, s, strlen(s), &amp;cCharsWritten, NULL); <br>  PERR(bSuccess, "WriteConsole"); <br>  retflag = bSuccess; <br>  /* put a carriage return &amp; line feed after the string */ <br>  bSuccess = WriteConsole(hConsole, crlf, strlen(crlf), &amp;cCharsWritten, NULL); <br>  PERR(bSuccess, "WriteConsole"); <br>  if (!bSuccess) <br>    retflag = FALSE; <br>  return(retflag); <br>} <br> <br> <br>/******************************************************************** <br>* FUNCTION: getConX(HANDLE hCon)                                    * <br>*                                                                   * <br>* PURPROSE: to get the current width of the console output buffer   * <br>*                                                                   * <br>* INPUT: the handle to get the information for                      * <br>*                                                                   * <br>* RETURNS: the width of the current console output buffer, in chars * <br>********************************************************************/ <br> <br>SHORT getConX(HANDLE hCon) <br>{ <br>  CONSOLE_SCREEN_BUFFER_INFO csbi; <br>  BOOL bSuccess; <br> <br>  bSuccess = GetConsoleScreenBufferInfo(hCon, &amp;csbi); <br>  PERR(bSuccess, "GetConsoleScreenBufferInfo"); <br>  return(csbi.dwSize.X); <br>} <br> <br> <br>/********************************************************************* <br>* FUNCTION: getConY(HANDLE hCon)                                     * <br>*                                                                    * <br>* PURPROSE: to get the current height of the console output buffer   * <br>*                                                                    * <br>* INPUT: the handle to get the information for                       * <br>*                                                                    * <br>* RETURNS: the height of the current console output buffer, in chars * <br>*********************************************************************/ <br> <br> <br>SHORT getConY(HANDLE hCon) <br>{ <br>  CONSOLE_SCREEN_BUFFER_INFO csbi; <br>  BOOL bSuccess; <br> <br>  bSuccess = GetConsoleScreenBufferInfo(hCon, &amp;csbi); <br>  PERR(bSuccess, "GetConsoleScreenBufferInfo"); <br>  return(csbi.dwSize.Y); <br>} <br> <br> <br>/************************************************************************* <br>* FUNCTION: showConAPIs(HANDLE hConsole)                                 * <br>*                                                                        * <br>* PURPOSE: to display a list of console APIs on the given console buffer * <br>*                                                                        * <br>* INPUT: the console to display the APIs on                              * <br>*                                                                        * <br>* RETURNS: none                                                          * <br>*************************************************************************/ <br> <br>void showConAPIs(HANDLE hConsole) <br>{ <br>  COORD coordScreen; <br>  int i; <br>  BOOL bSuccess; <br>  DWORD cCharsWritten; <br>  CHAR szTemps[128]; <br> <br>  resizeConBufAndWindow(hConsole, CONX, CONY); /* defined in size.c */ <br>  /* set attributes for new writes to the console */ <br>  bSuccess = SetConsoleTextAttribute(hConsole, BACKGROUND_BLUE | <br>      FOREGROUND_WHITE); <br>  PERR(bSuccess, "SetConsoleTextAttribute"); <br>  cls(hConsole); /* will clear screen to newly set color attribute */ <br>  /* fill screen with API list */ <br>  for (i = 0; i &lt; sizeof(conAPIs) / sizeof(conAPIs[0]); i++) <br>    { <br>    coordScreen.X = 0; <br>    coordScreen.Y = (SHORT) (i + 2);  /* start on third line (zero based) */ <br>    /* position the cursor to start the API list */ <br>    bSuccess = SetConsoleCursorPosition(hConsole, coordScreen); <br>    PERR(bSuccess, "SetConsoleCursorPosition"); <br>    /* format a line and write it to the screen */ <br>    sprintf(szTemps, "%-3d%s", i + 1, conAPIs[i]); <br>    myPuts(hConsole, szTemps); <br>    /* color the number yellow on blue */ <br>    bSuccess = FillConsoleOutputAttribute(hConsole, FOREGROUND_YELLOW | <br>        FOREGROUND_INTENSITY | BACKGROUND_BLUE, 3, coordScreen, <br>        &amp;cCharsWritten); <br>    PERR(bSuccess, "FillConsoleOutputAttribute"); <br>    coordScreen.X = 3; <br>    /* color text light cyan on blue */ <br>    bSuccess = FillConsoleOutputAttribute(hConsole, FOREGROUND_CYAN | <br>        FOREGROUND_INTENSITY | BACKGROUND_BLUE, strlen(conAPIs[i]), <br>        coordScreen, &amp;cCharsWritten); <br>    PERR(bSuccess, "FillConsoleOutputAttribute"); <br>    } <br>  myPuts(hConsole, "\nClick on an API to see a demonstration of that API.\n" <br>                   "Hit ESC to exit the program."); <br>  return; <br>} <br> <br> <br>/************************************************************************* <br>* FUNCTION: putStatusLine(HANDLE hOut, PCHAR buf)                        * <br>*                                                                        * <br>* PURPOSE: display a string on the top line of the console output buffer * <br>*                                                                        * <br>* INPUT: the output handle, the string to display                        * <br>*                                                                        * <br>* RETURNS: none                                                          * <br>*************************************************************************/ <br> <br>void putStatusLine(HANDLE hOut, PCHAR buf) <br>{ <br>  BOOL bSuccess; <br>  /* position the status line at (0, 0) */ <br>  const COORD dwWriteCoord = {0, 0}; <br>  DWORD cCharsWritten; <br>  int len; /* the length of the input string parameter */ <br>  CHAR szTemp[256]; <br>  SHORT sWidth; /* console width */ <br> <br>  sWidth = getConX(hOut); <br>  strcpy(szTemp, buf); <br>  len = strlen(szTemp); <br>  memset(szTemp + len, ' ', sWidth - len);  /* blank out rest of line */ <br>  /* write the string to the console at the correct position */ <br>  bSuccess = WriteConsoleOutputCharacter(hOut, szTemp, sWidth, <br>      dwWriteCoord, &amp;cCharsWritten); <br>  PERR(bSuccess, "WriteConsoleOutput"); <br>  /* color the status line so it stands out */ <br>  bSuccess = FillConsoleOutputAttribute(hOut, FOREGROUND_RED | <br>      BACKGROUND_WHITE, sWidth, dwWriteCoord, &amp;cCharsWritten); <br>  PERR(bSuccess, "FillConsoleOutputAttribute"); <br>  return; <br>} <br> <br> <br>/******************************************************************** <br>* FUNCTION: demoAPI(HANDLE *hConsole, enum cAPIs apiNumber)         * <br>*                                                                   * <br>* PURPOSE: call the correct demo function based on the input index  * <br>*                                                                   * <br>* INPUT: current console output buffer, and screen index of the API * <br>*        to demonstrate                                             * <br>*                                                                   * <br>* RETURNS: none                                                     * <br>********************************************************************/ <br> <br>static void demoAPI(HANDLE *phConsole, enum cAPIs apiNumber) <br>{ <br>  BOOL bSuccess; <br>  HANDLE hConTemp; <br>  CHAR szConsoleTitle[128]; /* to store the console title */ <br>  DWORD dwCharsRead; <br> <br>  /* create a temp screen buffer to write to */ <br>  hConTemp = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE, <br>      FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CONSOLE_TEXTMODE_BUFFER, <br>      NULL); <br>  PERR(hConTemp != INVALID_HANDLE_VALUE, <br>      "CreateConsoleScreenBuffer"); <br>  /* make it the active buffer */ <br>  bSuccess = SetConsoleActiveScreenBuffer(hConTemp); <br>  PERR(bSuccess, "SetConsoleActiveScreenBuffer"); <br>  /* clear screen &amp; save the console title */ <br>  bSuccess = SetConsoleTextAttribute(hConTemp, BACKGROUND_CYAN); <br>  PERR(bSuccess, "SetConsoleTextAttribute"); <br>  cls(hConTemp); /* will clear with new color attribute */ <br>  dwCharsRead = GetConsoleTitle(szConsoleTitle, sizeof(szConsoleTitle)); <br>  PERR(dwCharsRead, "GetConsoleTitle"); <br> <br>  /* flush the input buffer and call the correct demo function */ <br>  bSuccess = FlushConsoleInputBuffer(GetStdHandle(STD_INPUT_HANDLE)); <br>  PERR(bSuccess, "FlushConsoleInputBuffer"); <br>  switch(apiNumber) <br>    { <br>    case ALLOC: <br>    case FREE:  <br>      demoAllocFree(hConTemp, phConsole); <br>      return; <br>      break;   <br>    case CREATE: <br>    case SETACTIVE: <br>    case SETATT: <br>      demoCreate(hConTemp); <br>      break; <br>    case FILLATT: <br>    case WRITECHAR: <br>      demoFillAtt(hConTemp); <br>      break; <br>    case FILLCHAR: <br>      demoFillChar(hConTemp); <br>      break; <br>    case FLUSH: <br>      demoFlush(hConTemp); <br>      break; <br>    case GETCUR: <br>    case SETCURINF: <br>    case SETCURPOS: <br>      demoCursor(hConTemp); <br>      break; <br>    case GETMODE: <br>    case SETMODE: <br>      demoConMode(hConTemp); <br>      break; <br>    case GETCONINFO: <br>      demoConInfo(hConTemp); <br>      break; <br>    case GETTITLE: <br>    case SETTITLE: <br>      demoGetTitle(hConTemp); <br>      break; <br>    case GETLARGEST: <br>      demoGetLargest(hConTemp); <br>      break; <br>    case GETNUMEV: <br>    case PEEK: <br>    case READCONIN: <br>      demoGetNumEvents(hConTemp); <br>      break; <br>    case GETNUMBUT: <br>      demoGetNumBut(hConTemp); <br>      break; <br>    case READCONOUT: <br>    case WRITEOUT: <br>    case READCONATT: <br>    case WRITEATT: <br>      demoReadConOut(hConTemp); <br>      break; <br>    case READCONCHAR: <br>      demoReadConChar(hConTemp); <br>      break; <br>    case SCROLL: <br>      demoScrollCon(hConTemp); <br>      break; <br>    case SETSIZE: <br>    case SETINFO: <br>      demoSizeInfo(hConTemp); <br>      break; <br>    case SETHAND: <br>    case GENCTRL: <br>      demoSetCtrlHandler(hConTemp); <br>      break; <br>    case WRITEIN: <br>      demoWriteIn(hConTemp); <br>      break; <br>    case GETCP: <br>    case SETCP: <br>      demoInputCodePage(hConTemp); <br>      break; <br>    case GETOUTCP: <br>    case SETOUTCP: <br>      demoOutputCodePage(hConTemp); <br>      break; <br>    default: <br>      break; <br>    } <br>  CloseHandle(hConTemp);  /* free temporary console buffer */ <br>  /* reset active buffer to original buffer. If the temp buffer has been */ <br>  /* resized, the console window will automatically be sized correctly */ <br>  /* when the current console is set back to the old one */ <br>  bSuccess = SetConsoleActiveScreenBuffer(*phConsole); <br>  PERR(bSuccess, "SetConsoleActiveScreenBuffer"); <br>  /* restore the original console title */ <br>  bSuccess = SetConsoleTitle(szConsoleTitle); <br>  PERR(bSuccess, "SetConsoleTitle"); <br>  /* flush the input buffer to remove any 'leftover' clicks or key events */ <br>  bSuccess = FlushConsoleInputBuffer(GetStdHandle(STD_INPUT_HANDLE)); <br>  PERR(bSuccess, "FlushConsoleInputBuffer"); <br>  return; <br>} <br> <br> <br>/************************************************************************ <br>* FUNCTION: cls(HANDLE hConsole)                                        * <br>*                                                                       * <br>* PURPOSE: clear the screen by filling it with blanks, then home cursor * <br>*                                                                       * <br>* INPUT: the console buffer to clear                                    * <br>*                                                                       * <br>* RETURNS: none                                                         * <br>*************************************************************************/ <br> <br>void cls(HANDLE hConsole) <br>{ <br>  COORD coordScreen = { 0, 0 }; /* here's where we'll home the cursor */ <br>  BOOL bSuccess; <br>  DWORD cCharsWritten; <br>  CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */ <br>  DWORD dwConSize; /* number of character cells in the current buffer */ <br> <br>  /* get the number of character cells in the current buffer */ <br>  bSuccess = GetConsoleScreenBufferInfo(hConsole, &amp;csbi); <br>  PERR(bSuccess, "GetConsoleScreenBufferInfo"); <br>  dwConSize = csbi.dwSize.X * csbi.dwSize.Y; <br>  /* fill the entire screen with blanks */ <br>  bSuccess = FillConsoleOutputCharacter(hConsole, (TCHAR) ' ', <br>      dwConSize, coordScreen, &amp;cCharsWritten); <br>  PERR(bSuccess, "FillConsoleOutputCharacter"); <br>  /* get the current text attribute */ <br>  bSuccess = GetConsoleScreenBufferInfo(hConsole, &amp;csbi); <br>  PERR(bSuccess, "ConsoleScreenBufferInfo"); <br>  /* now set the buffer's attributes accordingly */ <br>  bSuccess = FillConsoleOutputAttribute(hConsole, csbi.wAttributes, <br>      dwConSize, coordScreen, &amp;cCharsWritten); <br>  PERR(bSuccess, "FillConsoleOutputAttribute"); <br>  /* put the cursor at (0, 0) */ <br>  bSuccess = SetConsoleCursorPosition(hConsole, coordScreen); <br>  PERR(bSuccess, "SetConsoleCursorPosition"); <br>  return; <br>} <br> <br> <br>/********************************************************************* <br>* FUNCTION: setConTitle                                              * <br>*                                                                    * <br>* PURPOSE: simply set the current console title. Called by each demo * <br>*          function to specify the name of the source file that      * <br>*          contains the demo function.                               * <br>*                                                                    * <br>* INPUT: null terminated string                                      * <br>*********************************************************************/ <br> <br>void setConTitle(PCHAR szTitle) <br>{ <br>  BOOL bSuccess; <br> <br>  /* set the console title to the input string parameter */ <br>  bSuccess = SetConsoleTitle(szTitle); <br>  PERR(bSuccess, "SetConsoleTitle"); <br>  return; <br>} <br> <br>/********************************************************************* <br>* FUNCTION: main                                                     * <br>*                                                                    * <br>* PURPOSE: main input loop. Set up console input and output          * <br>*          attributes, then read the input queue and process input   * <br>*          events. If ESC is hit, end the process. If the mouse is   * <br>*          clicked, read the line from the output console where the  * <br>*          mouse was clicked. If an index number can be found at the * <br>*          beginning of the line, call the appropriate demo function * <br>*          to demonstrate that API. All input event information is   * <br>*          displayed on the status line on the top line.             * <br>*                                                                    * <br>* INPUT: none                                                        * <br>*                                                                    * <br>* RETURNS: 1 if running on non-supported Win32 platform, 0 for a     * <br>* normal exit                                                        * <br>*                                                                    * <br>*********************************************************************/ <br> <br>int main(void) <br>{ <br>  BOOL bSuccess; <br>  HANDLE hStdIn, hStdOut; /* standard input, output handles */ <br>  DWORD dwMode; <br>  /* array of console input event records */ <br>  INPUT_RECORD inputBuffer; <br>  DWORD dwInputEvents; /* number of events actually read */ <br>  CHAR bOutBuf[256]; /* buffer to format event information into */ <br>  /* used to get the new console screen buffer size if it is changed */ <br>  COORD coordScreen; /* used when reading the index number from the screen */ <br>  CHAR *szLineBuf; /* buffer to read the index number into */ <br>  DWORD cCharsRead; <br>  enum cAPIs apiNumber; /* the index number of the API read from the screen */ <br>  CONSOLE_CURSOR_INFO cci; /* used when turning off the cursor */ <br>  CONSOLE_SCREEN_BUFFER_INFO csbi; /* used to get cursor position */ <br>  OSVERSIONINFO osVer; /* for GetVersionEx() */ <br> <br>  /* check if Win32s, if so, display notice and terminate */ <br>  osVer.dwOSVersionInfoSize = sizeof(osVer); <br>  bSuccess = GetVersionEx(&amp;osVer); <br>  PERR(bSuccess, "GetVersionEx"); <br>  if (osVer.dwPlatformId == VER_PLATFORM_WIN32s) <br>    { <br>    MessageBox(NULL,  <br>        "This application cannot run on Windows 3.1.\n" <br>        "This application will now terminate.", <br>        "Error: Windows NT or Windows 95 Required to Run",  MB_OK ); <br>    return(1); <br>    } <br> <br>  /* Free the console and immediately allocate a new one. This is done so */ <br>  /* that when debugging under ntsd, the application output will not be */ <br>  /* intermingled with the debugger output. This also makes cleanup */ <br>  /* much easier; we won't need to restore the cursor, buffer/console */ <br>  /* sizes, screen colors, etc. since we'll have our own console window */ <br>  /* that will go away when we terminate. */ <br> <br>  /* Here's a trick we'll use to guess whether we're starting from a */ <br>  /* console or GUI app: if the cursor is at 0,0, we'll assume that we've */ <br>  /* started from a GUI app and not bother freeing/allocing a new console. */ <br>  /* This will also avoid cases where the new console is not in the */ <br>  /* foreground (AllocConsole does not guarantee a foreground window). */ <br>  bSuccess = GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), <br>             &amp;csbi); <br>  PERR(bSuccess, "GetConsoleScreenBufferInfo"); <br>  if (csbi.dwCursorPosition.X | csbi.dwCursorPosition.Y) /* either non-zero? */ <br>    { <br>    bSuccess = FreeConsole(); <br>    PERR(bSuccess, "FreeConsole"); <br>    /* C run-time standard-handle I/O will not work from now on unless we */ <br>    /* "fix" the C standard handles to reference the console standard */ <br>    /* handles which will be created by the AllocConsole call below. */ <br>    /* In this sample, we won't be using C run-time I/O, so it's not an */ <br>    /* issue. */ <br>    bSuccess = AllocConsole(); <br>    PERR(bSuccess, "AllocConsole"); <br>    } <br>  /* let's put up a meaningful console title */ <br>  bSuccess = SetConsoleTitle("Win32 Console API Demo"); <br>  PERR(bSuccess, "SetConsoleTitle"); <br>  /* get the standard handles */ <br>  hStdOut = GetStdHandle(STD_OUTPUT_HANDLE); <br>  PERR(hStdOut != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  hStdIn = GetStdHandle(STD_INPUT_HANDLE); <br>  PERR(hStdIn != INVALID_HANDLE_VALUE, "GetStdHandle"); <br>  /* set up mouse and window input */ <br>  bSuccess = GetConsoleMode(hStdIn, &amp;dwMode); <br>  PERR(bSuccess, "GetConsoleMode"); <br>  /* when turning off ENABLE_LINE_INPUT, you MUST also turn off */ <br>  /* ENABLE_ECHO_INPUT. */ <br>  bSuccess = SetConsoleMode(hStdIn, (dwMode &amp; ~(ENABLE_LINE_INPUT | <br>      ENABLE_ECHO_INPUT)) | ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT); <br>  PERR(bSuccess, "SetConsoleMode"); <br>  /* save then hide the cursor */ <br>  cci.dwSize = 100; <br>  cci.bVisible = FALSE; <br>  bSuccess = SetConsoleCursorInfo(hStdOut, &amp;cci); <br>  PERR(bSuccess, "SetConsoleCursorInfo"); <br>  /* resize console to CONX * CONY and put list of console APIs up */ <br>  showConAPIs(hStdOut); <br>  /* This is the main input loop. Read from the input queue and process */ <br>  /* the events read */ <br>  szLineBuf = (char *) malloc(getConX(hStdOut)); <br>  PERR(szLineBuf, "malloc"); <br> <br>  do <br>    { <br>    /* read an input events from the input event queue */ <br>    bSuccess = ReadConsoleInput(hStdIn, &amp;inputBuffer, 1, &amp;dwInputEvents); <br>    PERR(bSuccess, "ReadConsoleInput"); <br>    switch (inputBuffer.EventType) <br>      { <br>      case KEY_EVENT: <br>        if (inputBuffer.Event.KeyEvent.bKeyDown) <br>          { <br>          /* display the key event info on the status line */ <br>          sprintf(bOutBuf, "key: virtual=%d ascii=%c", <br>              inputBuffer.Event.KeyEvent.wVirtualKeyCode, <br>              inputBuffer.Event.KeyEvent.uChar.AsciiChar); <br>          putStatusLine(hStdOut, bOutBuf); <br>          } <br>        break; <br>      case MOUSE_EVENT: <br>        sprintf(bOutBuf, "mouse: %s at %d, %d", <br>            (inputBuffer.Event.MouseEvent.dwEventFlags == MOUSE_MOVED ? <br>            "moved" : "clicked"), inputBuffer.Event.MouseEvent.dwMousePosition.X, </code></pre>
<p>
</p>
<pre><code>inputBuffer.Event.MouseEvent.dwMousePosition.Y); <br>        putStatusLine(hStdOut, bOutBuf); <br>        /* was this a mouse click? If so dwEventFlags contains 0 */ <br>        /* are any mouse buttons down? If so dwButtonState is not 0 */ <br>        if (inputBuffer.Event.MouseEvent.dwEventFlags == 0 &amp;&amp; <br>            inputBuffer.Event.MouseEvent.dwButtonState) <br>          { <br>          coordScreen.X = 0; <br>          coordScreen.Y = inputBuffer.Event.MouseEvent.dwMousePosition.Y; <br>          /* read the line where the mouse clicked */ <br>          bSuccess = ReadConsoleOutputCharacter(hStdOut, szLineBuf, <br>              sizeof(szLineBuf), coordScreen, &amp;cCharsRead); <br>          PERR(bSuccess, "ReadConsoleOutputCharacter"); <br>          /* scan for an index number at the beginning of that line. */ <br>          /* if there was one read, call the correct demo function */ <br>          if (sscanf(szLineBuf, "%d", &amp;apiNumber)) <br>            demoAPI(&amp;hStdOut, apiNumber); <br>          } <br>        break; <br>      case WINDOW_BUFFER_SIZE_EVENT: <br>        sprintf(bOutBuf, "window: %d, %d", <br>            inputBuffer.Event.WindowBufferSizeEvent.dwSize.X, <br>            inputBuffer.Event.WindowBufferSizeEvent.dwSize.Y); <br>        putStatusLine(hStdOut, bOutBuf); <br>        Sleep(1000); <br>        break; <br>      } /* switch */ <br>    /* when we receive an esc down key, drop out of do loop */ <br>    } while (!(inputBuffer.EventType == KEY_EVENT &amp;&amp; <br>            inputBuffer.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE &amp;&amp; <br>            inputBuffer.Event.KeyEvent.bKeyDown)); <br>  free(szLineBuf); /* free allocated line buffer */ <br>  return(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
