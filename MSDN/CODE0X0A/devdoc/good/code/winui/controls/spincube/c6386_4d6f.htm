<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAINT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6387"></a>PAINT.C</h2>
<pre><code>/******************************************************************************\ <br>* <br>*  MODULE:      PAINT.C <br>* <br>*  PURPOSE:     This is the module responsible for painting the SPINCUBE <br>*               custom control. When Paint() is called we retrieve a <br>*               pointer to a SPINCUBEINFO structure, and then use it's <br>*               current rotation &amp; translation values to transform the <br>*               polyhedron described by gNormalizedVertices &amp; gaiFacets. <br>*               Once we've transformed the vertices, we draw the <br>*               background, which consists of a grey rectangle and a few <br>*               black lines (a crass attempt to render a perspective <br>*               view into a "room"), on the offscreen bitmap associated <br>*               with the control (i.e. pSCI-&gt;hbmCompat). Then we walk the <br>*               facet list of the transformed polyhedron (gXformedVertices <br>*               &amp; gaiFacets), drawing only those facets whose outward <br>*               normal faces us (again, drawing on pSCI-&gt;hbmCompat). <br>*               Finally, we BitBlt the appropriate rectangle from our <br>*               offscreen bitmap to the screen itself. <br>* <br>*               Drawing to the offscreen bitmap has two advantages over <br>*               drawing straight to the screen: <br>* <br>*                 1. The actual drawing the user sees consists of only <br>*                    a single BitBlt. Otherwise, the user would see us <br>*                    both erase the polyhedron in it's old position and <br>*                    draw it in it's new position (alot of flashing- not <br>*                    very smooth animation). <br>* <br>*                 2. When a spincube control with the SS_ERASE style <br>*                    is brought to the foreground, all it's contents <br>*                    i.e. the cube trails) are saved &amp; can be re-Blted <br>*                    to the screen. Otherwise, all this info would be <br>*                    lost &amp; there'd be a big blank spot in the middle <br>*                    of the control! <br>* <br>*               Interested persons should consult a text on 3 dimensional <br>*               graphics for more information (i.e. "Computer Graphics: <br>*               Principles and Practice", by Foley &amp; van Dam). <br>* <br>*               Notes: <br>* <br>*               - A 3x2 tranformation matrix  is used instead of a  3x3 <br>*                 matrix, since the transformed z-values aren't needed. <br>*                 (Normally these would be required for use in depth <br>*                 sorting  [for hidden surface removal], but  since we <br>*                 draw  only  a single convex polyhedron this  is not <br>*                 necessary.) <br>* <br>*               - A simplified perspective viewing transformation <br>*                 (which also  precludes the need for the transformed z <br>*                 coordinates). In a nutshell, the perspective  scale <br>*                 is as follows: <br>* <br>*                                    p' = S    x  p <br>*                                          per <br>* <br>*                 where: <br>*                        S    = WindowDepth / <br>*                         per      (WindowDepth + fCurrentZTranslation) <br>* <br>*                 (WindowDepth is  the greater of the  control's window <br>*                 height or window width.) <br>* <br>* <br>*  FUNCTIONS:   Paint()                         - the paint routine <br>*               TransformVertices()             - transforms vertices <br>*               ComputeRotationTransformation() - computes xformation <br>*                                                 based on current x, y <br>*                                                 and z rotation angles <br>* <br>* <br>*                           Microsoft Developer Support <br>*                  Copyright 1992 - 1998 Microsoft Corporation <br>* <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "spincube.h" <br>#include "paint.h" <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:     Paint <br>* <br>*  INPUTS:       hwnd - Handle of the window to draw into. <br>* <br>*  COMMENTS:     Draws window background &amp; a polyhedron in the window. <br>* <br>\******************************************************************************/ <br> <br>void Paint (HWND hwnd) <br>{ <br>  PSPINCUBEINFO  pSCI; <br>  RECT           rect; <br>  int            i; <br>  LONG           lScaleFactor; <br>  PAINTSTRUCT    ps; <br>  HRGN           hrgnClip; <br>  HBRUSH         hBrush, hBrushSave; <br>  int            iX, iY, iCX, iCY; <br>  int            facetIndex, numPoints; <br>  POINT          polygn[MAX_POINTS_PER_FACET]; <br>  POINT          vector1, vector2; <br>  COLORREF       acrColor[6] = { 0x0000ff, 0x00ff00, 0xff0000, <br>                                 0x00ffff, 0xff00ff, 0xffff00 }; <br> <br>  pSCI = (PSPINCUBEINFO) GetWindowLong (hwnd, GWL_SPINCUBEDATA); <br> <br>  BeginPaint (hwnd, &amp;ps); <br> <br>  if (memcmp((void *)&amp;ps.rcPaint, (void *)&amp;pSCI-&gt;rcCubeBoundary, sizeof(RECT)) <br>      &amp; !REPAINT_BKGND(pSCI)) <br> <br>  { <br>    // <br>    // We're not here because it's time to animate (i.e. this paint isn't <br>    //   the result of a WM_TIMER), so just do the Blt &amp; blow out of here... <br>    // <br> <br>    BitBlt (ps.hdc, <br>            ps.rcPaint.left, <br>            ps.rcPaint.top, <br>            ps.rcPaint.right - ps.rcPaint.left, <br>            ps.rcPaint.bottom - ps.rcPaint.top, <br>            pSCI-&gt;hdcCompat, ps.rcPaint.left, <br>            ps.rcPaint.top, SRCCOPY); <br> <br>    EndPaint (hwnd, &amp;ps); <br>    return; <br>  } <br> <br> <br>  // <br>  // The rectangle we get back is in Desktop coordinates, so we need to <br>  //   modify it to reflect coordinates relative to this window. <br>  // <br> <br>  GetWindowRect (hwnd, &amp;rect); <br> <br>  rect.right  -= rect.left; <br>  rect.bottom -= rect.top; <br>  rect.left = rect.top = 0; <br> <br> <br>  // <br>  // Determine a "best fit" scale factor for our polyhedron <br>  // <br> <br>  if (!(lScaleFactor = rect.right &gt; rect.bottom ? <br>                       rect.bottom/12 : rect.right/12)) <br> <br>    lScaleFactor = 1; <br> <br> <br>  TransformVertices (hwnd, &amp;rect, pSCI, lScaleFactor); <br> <br> <br>  // <br>  // Draw the window frame &amp; background <br>  // <br>  // Note: The chances are that we are coming through here because we <br>  //   got a WM_TIMER message &amp; it's time to redraw the cube to simulate <br>  //   animation. In that case all we want to erase/redraw is that small <br>  //   rectangle which bounded the polyhedron the last time. The less <br>  //   drawing that actually gets done the better, since we wnat to <br>  //   minimize the flicker on the screen. __BeginPaint__ is perfect for <br>  //   this because it causes all drawing outside of the invalid region <br>  //   to be "clipped" (no drawing is performed outside of the invalid <br>  //   region), and it also validates the invalid region. <br>  // <br> <br>  if (DO_ERASE(hwnd) || REPAINT_BKGND(pSCI)) <br>  { <br>    hrgnClip = CreateRectRgnIndirect (&amp;ps.rcPaint); <br>    SelectClipRgn (pSCI-&gt;hdcCompat, hrgnClip); <br>    DeleteObject (hrgnClip); <br> <br>    SelectObject (pSCI-&gt;hdcCompat, GetStockObject (GRAY_BRUSH)); <br>    Rectangle    (pSCI-&gt;hdcCompat, (int)rect.left, (int)rect.top, <br>                  (int)rect.right, (int)rect.bottom); <br> <br>    iX = (rect.right  - rect.left) / 4; <br>    iY = (rect.bottom - rect.top ) / 4; <br> <br>    MoveToEx (pSCI-&gt;hdcCompat, (int)rect.left, (int)rect.top, NULL); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.left + iX, (int)rect.top + iY); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.left + iX, (int)rect.bottom - iY); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.left,      (int)rect.bottom); <br> <br>    MoveToEx (pSCI-&gt;hdcCompat, (int)rect.right, (int)rect.top, NULL); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.right - iX, (int)rect.top + iY); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.right - iX, (int)rect.bottom- iY); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.right,      (int)rect.bottom); <br> <br>    MoveToEx (pSCI-&gt;hdcCompat, (int)rect.left + iX,  (int)rect.top + iY, NULL); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.right - iX, (int)rect.top + iY); <br> <br>    MoveToEx (pSCI-&gt;hdcCompat, (int)rect.left + iX,  (int)rect.bottom - iY, NULL); <br>    LineTo   (pSCI-&gt;hdcCompat, (int)rect.right - iX, (int)rect.bottom - iY); <br> <br>    SelectClipRgn (pSCI-&gt;hdcCompat, NULL); <br> <br>    pSCI-&gt;iOptions &amp;= ~SPINCUBE_REPAINT_BKGND; <br>  } <br> <br> <br>  // <br>  // Draw the polyhedron. We'll walk through the facets list and compute <br>  //   the normal for each facet- if the normal has z &gt; 0, then the facet <br>  //   faces us and we'll draw it. Note that this algorithim is ONLY valid <br>  //   for scenes with a single, convex polyhedron. <br>  // <br>  // Note: Use GetDC here because the above call to BeginPaint will <br>  //   probably not give us a DC with access to as much real estate as <br>  //   we'd like (we wouldn't be able to draw outside of the invalid <br>  //   region). We can party on the entire control window with the DC <br>  //   returned by GetDC. <br>  // <br> <br>  for (i = 0, facetIndex = 0; i &lt; NUMFACETS; i++) <br>  { <br>    vector1.x = gXformedVertices[gaiFacets[facetIndex + 1]].x - <br>                gXformedVertices[gaiFacets[facetIndex]].x; <br>    vector1.y = gXformedVertices[gaiFacets[facetIndex + 1]].y - <br>                gXformedVertices[gaiFacets[facetIndex]].y; <br>    vector2.x = gXformedVertices[gaiFacets[facetIndex + 2]].x - <br>                gXformedVertices[gaiFacets[facetIndex + 1]].x; <br>    vector2.y = gXformedVertices[gaiFacets[facetIndex + 2]].y - <br>                gXformedVertices[gaiFacets[facetIndex + 1]].y; <br> <br>    for (numPoints = 0; gaiFacets[facetIndex] != -1; numPoints++, facetIndex++) <br>    { <br>      polygn[numPoints].x = gXformedVertices[gaiFacets[facetIndex]].x; <br>      polygn[numPoints].y = gXformedVertices[gaiFacets[facetIndex]].y; <br>    } <br> <br>    facetIndex++; /* skip over the -1's in the facets list */ <br>    if ((vector1.x*vector2.y - vector1.y*vector2.x) &gt; 0) <br>    { <br>      hBrush     = CreateSolidBrush (acrColor[i]); <br>      hBrushSave = (HBRUSH) SelectObject (pSCI-&gt;hdcCompat, hBrush); <br> <br>      Polygon (pSCI-&gt;hdcCompat, &amp;polygn[0], numPoints); <br> <br>      SelectObject (pSCI-&gt;hdcCompat, hBrushSave); <br>      DeleteObject (hBrush); <br>    } <br>  } <br> <br>  iX  = pSCI-&gt;rcCubeBoundary.left &lt; ps.rcPaint.left ? <br>        pSCI-&gt;rcCubeBoundary.left : ps.rcPaint.left; <br>  iY  = pSCI-&gt;rcCubeBoundary.top  &lt; ps.rcPaint.top  ? <br>        pSCI-&gt;rcCubeBoundary.top  : ps.rcPaint.top; <br> <br>  iCX = (pSCI-&gt;rcCubeBoundary.right &gt; ps.rcPaint.right ? <br>         pSCI-&gt;rcCubeBoundary.right : ps.rcPaint.right) - iX; <br> <br>  iCY = (pSCI-&gt;rcCubeBoundary.bottom &gt; ps.rcPaint.bottom ? <br>         pSCI-&gt;rcCubeBoundary.bottom : ps.rcPaint.bottom) - iY; <br> <br>  EndPaint (hwnd, &amp;ps); <br> <br>  ps.hdc = GetDC (hwnd); <br> <br>  BitBlt (ps.hdc, iX, iY, iCX, iCY, pSCI-&gt;hdcCompat, iX, iY, SRCCOPY); <br> <br>  ReleaseDC (hwnd, ps.hdc); <br> <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:     TransformVertices <br>* <br>*  INPUTS:       hwnd         - control window handle <br>*                pWindowRect  - pointer to RECT describing control's dimensions <br>*                pSCI         - pointer to control's SPINCUBEINFO structure <br>*                fScaleFactor - scale factor for use in this window <br>* <br>\******************************************************************************/ <br> <br>void TransformVertices (HWND hwnd,          RECT  *pWindowRect, <br>                        PSPINCUBEINFO pSCI, LONG  lScaleFactor) <br>{ <br>  int    i; <br>  int    iWindowDepth = pWindowRect-&gt;right &gt; pWindowRect-&gt;bottom ? <br>                        pWindowRect-&gt;right : pWindowRect-&gt;bottom; <br>  RECT   WindowRect; <br>  float  fDepthScale; <br>  int    iNewTranslationInc = (rand() % 10) + 2; <br>  float  fNewRotationInc    = (float) 0.01 * ((rand() % 30) + 2); <br> <br>  WindowRect.left = - (WindowRect.right  = pWindowRect-&gt;right  &gt;&gt; 1); <br>  WindowRect.top  = - (WindowRect.bottom = pWindowRect-&gt;bottom &gt;&gt; 1); <br> <br>  // <br>  // Initiailize the bounding rectangle with max/min vals <br>  // <br> <br>  pSCI-&gt;rcCubeBoundary.left   = <br>  pSCI-&gt;rcCubeBoundary.top    = 100000; // big positive value <br>  pSCI-&gt;rcCubeBoundary.right  = <br>  pSCI-&gt;rcCubeBoundary.bottom = -100000; // small negative value <br> <br> <br>  // <br>  // First scale, then rotate, then translate each vertex. <br>  //   Keep track of the maximum &amp; minimum values bounding the <br>  //   vertices in the x,y plane for use later in bounds checking. <br>  // <br>  // Note: we don't bother computing z values after the scale, <br>  //   as they are only really necessary for the rotation. If we <br>  //   were doing real bounds checking we'd need it, but this code <br>  //   simply uses the pSCI-&gt;iCurrentZTranslation to determine <br>  //   the z-boundaries. <br>  // <br> <br>  for (i = 0; i &lt; NUMVERTICES; i++) <br>  { <br>    LONG tempX; <br> <br>    // <br>    // Copy the static vertices into a temp array <br>    // <br> <br>    gXformedVertices[i] = gNormalizedVertices[i]; <br> <br>    // <br>    // The scale... <br>    // <br> <br>    gXformedVertices[i].x *= lScaleFactor; <br>    gXformedVertices[i].y *= lScaleFactor; <br>    gXformedVertices[i].z *= lScaleFactor; <br> <br>    // <br>    // The rotation... <br>    // <br> <br>    ComputeRotationTransformation (pSCI-&gt;fCurrentXRotation, <br>                                   pSCI-&gt;fCurrentYRotation, <br>                                   pSCI-&gt;fCurrentZRotation); <br> <br>    tempX   =               (LONG) (gM[0][0] * gXformedVertices[i].x + <br>                                    gM[0][1] * gXformedVertices[i].y + <br>                                    gM[0][2] * gXformedVertices[i].z); <br> <br>    gXformedVertices[i].y = (LONG) (gM[1][0] * gXformedVertices[i].x + <br>                                    gM[1][1] * gXformedVertices[i].y + <br>                                    gM[1][2] * gXformedVertices[i].z); <br>    gXformedVertices[i].x = tempX; <br> <br>    // <br>    // The translation... <br>    // <br> <br>    gXformedVertices[i].x += pSCI-&gt;iCurrentXTranslation; <br>    gXformedVertices[i].y += pSCI-&gt;iCurrentYTranslation; <br> <br>    // <br>    // Check if we have new max or min vals <br>    // <br> <br>    if (pSCI-&gt;rcCubeBoundary.left &gt; gXformedVertices[i].x) <br> <br>      pSCI-&gt;rcCubeBoundary.left = gXformedVertices[i].x; <br> <br>    if (pSCI-&gt;rcCubeBoundary.right &lt; gXformedVertices[i].x) <br> <br>      pSCI-&gt;rcCubeBoundary.right = gXformedVertices[i].x; <br> <br>    if (pSCI-&gt;rcCubeBoundary.top &gt; gXformedVertices[i].y) <br> <br>      pSCI-&gt;rcCubeBoundary.top = gXformedVertices[i].y; <br> <br>    if (pSCI-&gt;rcCubeBoundary.bottom &lt; gXformedVertices[i].y) <br> <br>      pSCI-&gt;rcCubeBoundary.bottom = gXformedVertices[i].y; <br>  } <br> <br> <br>  // <br>  // Now for some bounds checking, change translation &amp; rotation increments <br>  //   if we hit a "wall". Also so the gbHitBoundary flag so we remember <br>  //   to flash the cube when we draw it. <br>  // <br> <br>  if (pSCI-&gt;rcCubeBoundary.left &lt; WindowRect.left) <br>  { <br>    pSCI-&gt;iCurrentXTranslationInc = iNewTranslationInc; <br>    pSCI-&gt;fCurrentZRotationInc    = fNewRotationInc; <br>  } <br> <br>  else if (pSCI-&gt;rcCubeBoundary.right &gt; WindowRect.right) <br>  { <br>    pSCI-&gt;iCurrentXTranslationInc = -iNewTranslationInc; <br>    pSCI-&gt;fCurrentZRotationInc    = -fNewRotationInc; <br>  } <br> <br>  if (pSCI-&gt;rcCubeBoundary.top &lt; WindowRect.top) <br>   { <br>    pSCI-&gt;iCurrentYTranslationInc = iNewTranslationInc; <br>    pSCI-&gt;fCurrentXRotationInc    = fNewRotationInc; <br>  } <br> <br>  else if (pSCI-&gt;rcCubeBoundary.bottom &gt; WindowRect.bottom) <br>  { <br>    pSCI-&gt;iCurrentYTranslationInc = -iNewTranslationInc; <br>    pSCI-&gt;fCurrentXRotationInc    = -fNewRotationInc; <br>  } <br> <br>  if (pSCI-&gt;iCurrentZTranslation &lt; (int) lScaleFactor&lt;&lt;1) <br>  { <br>    pSCI-&gt;iCurrentZTranslationInc = iNewTranslationInc; <br>    pSCI-&gt;fCurrentYRotationInc    = fNewRotationInc; <br>  } <br> <br>  else if (pSCI-&gt;iCurrentZTranslation &gt; (iWindowDepth - (int) lScaleFactor)) <br>  { <br>    pSCI-&gt;iCurrentZTranslationInc = -iNewTranslationInc; <br>    pSCI-&gt;fCurrentYRotationInc    = -fNewRotationInc; <br>  } <br> <br> <br>  // <br>  // Now a kludgy scale based on depth (iCurrentZTranslation) of the center <br>  //   point of the polyhedron <br>  // <br> <br>  fDepthScale =  ((float) iWindowDepth) / <br>                 ((float) (iWindowDepth + pSCI-&gt;iCurrentZTranslation)); <br> <br>  pSCI-&gt;rcCubeBoundary.left  = (LONG)(fDepthScale* pSCI-&gt;rcCubeBoundary.left  ); <br>  pSCI-&gt;rcCubeBoundary.right = (LONG)(fDepthScale* pSCI-&gt;rcCubeBoundary.right ); <br>  pSCI-&gt;rcCubeBoundary.top   = (LONG)(fDepthScale* pSCI-&gt;rcCubeBoundary.top   ); <br>  pSCI-&gt;rcCubeBoundary.bottom= (LONG)(fDepthScale* pSCI-&gt;rcCubeBoundary.bottom); <br> <br>  for (i = 0; i &lt; NUMVERTICES; i++) <br>  { <br>    gXformedVertices[i].x = (LONG) (fDepthScale * gXformedVertices[i].x); <br>    gXformedVertices[i].y = (LONG) (fDepthScale * gXformedVertices[i].y); <br>  } <br> <br> <br>  // <br>  // If currently in motion then increment the current rotation &amp; tranlation <br>  // <br> <br>  if (IN_MOTION(hwnd)) <br>  { <br>    pSCI-&gt;fCurrentXRotation += pSCI-&gt;fCurrentXRotationInc; <br>    pSCI-&gt;fCurrentYRotation += pSCI-&gt;fCurrentYRotationInc; <br>    pSCI-&gt;fCurrentZRotation += pSCI-&gt;fCurrentZRotationInc; <br> <br>    pSCI-&gt;iCurrentXTranslation += pSCI-&gt;iCurrentXTranslationInc; <br>    pSCI-&gt;iCurrentYTranslation += pSCI-&gt;iCurrentYTranslationInc; <br>    pSCI-&gt;iCurrentZTranslation += pSCI-&gt;iCurrentZTranslationInc; <br>  } <br> <br> <br>  // <br>  // Up to this point all coordinates are relative to a window whose <br>  //   center is at (0,0). Now we'll translate appropriately... <br>  // <br> <br>  pSCI-&gt;rcCubeBoundary.left   += pWindowRect-&gt;right  &gt;&gt; 1; <br>  pSCI-&gt;rcCubeBoundary.right  += pWindowRect-&gt;right  &gt;&gt; 1; <br>  pSCI-&gt;rcCubeBoundary.top    += pWindowRect-&gt;bottom &gt;&gt; 1; <br>  pSCI-&gt;rcCubeBoundary.bottom += pWindowRect-&gt;bottom &gt;&gt; 1; <br> <br>  for (i = 0; i &lt; NUMVERTICES; i++) <br>  { <br>    gXformedVertices[i].x += pWindowRect-&gt;right  &gt;&gt; 1; <br>    gXformedVertices[i].y += pWindowRect-&gt;bottom &gt;&gt; 1; <br>  } <br> <br> <br>  // <br>  // Since FillRect's are inclusive-exclusive (there'll be leftovers <br>  //   from the last cube we drew otherwise)... <br>  // <br> <br>  pSCI-&gt;rcCubeBoundary.right++; <br>  pSCI-&gt;rcCubeBoundary.bottom++; <br> <br> <br>  // <br>  // Finally, adjust the rcCubeBoundary such that it fits entirely within <br>  //   the acutal control window. The reason for this is that when calling <br>  //   InvalidateRect from SpincubeWndProc\case_WM_TIMER we may get <br>  //   a different PAINSTRUCT.rcPaint (since InvalidateRect clips the passed <br>  //   in rect to the window bounds) and our abouve test to memcmp() will <br>  //   fail. <br>  // <br> <br>  if (pSCI-&gt;rcCubeBoundary.left &lt; 0) <br> <br>    pSCI-&gt;rcCubeBoundary.left = 0; <br> <br>  if (pSCI-&gt;rcCubeBoundary.top &lt; 0) <br> <br>    pSCI-&gt;rcCubeBoundary.top = 0; <br> <br>  if (pSCI-&gt;rcCubeBoundary.right &gt; pWindowRect-&gt;right) <br> <br>    pSCI-&gt;rcCubeBoundary.right = pWindowRect-&gt;right; <br> <br>  if (pSCI-&gt;rcCubeBoundary.bottom &gt; pWindowRect-&gt;bottom) <br> <br>    pSCI-&gt;rcCubeBoundary.bottom = pWindowRect-&gt;bottom; <br>} <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    ComputeRotationTransformation <br>* <br>*  INPUTS:      fRotationX - Angle to rotate about X axis. <br>*               fRotationY - Angle to rotate about Y axis. <br>*               fRotationZ - Angle to rotate about Z axis. <br>* <br>*  COMMENTS:    Computes a 3x2 tranformation matrix which rotates about <br>*               the Z axis, the Y axis, and the X axis, respectively. <br>* <br>\******************************************************************************/ <br> <br>void ComputeRotationTransformation (float fRotationX, <br>                                    float fRotationY, <br>                                    float fRotationZ) <br>{ <br>  float sinX, cosX, sinY, cosY, sinZ, cosZ; <br> <br>  sinX = (float) sin ((double) fRotationX); <br>  cosX = (float) cos ((double) fRotationX); <br>  sinY = (float) sin ((double) fRotationY); <br>  cosY = (float) cos ((double) fRotationY); <br>  sinZ = (float) sin ((double) fRotationZ); <br>  cosZ = (float) cos ((double) fRotationZ); <br> <br>  gM[0][0] =  cosY*cosZ; <br>  gM[0][1] = -cosY*sinZ; <br>  gM[0][2] =  sinY; <br>  gM[1][0] =  sinX*sinY*cosZ + cosX*sinZ; <br>  gM[1][1] = -sinX*sinY*sinZ + cosX*cosZ; <br>  gM[1][2] = -sinX*cosY; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
