<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPINCUBE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6389"></a>SPINCUBE.C</h2>
<pre><code>/******************************************************************************\ <br>* <br>*  MODULE:      SPINCUBE.C <br>* <br>* <br>*  PURPOSE:     To provide a generic Windows NT dynamic link library <br>*               sample demonstrating the use of DLL entry points, exported <br>*               variables, using C runtime in a DLL, etc... <br>* <br>*               This module also provides a functional example of how <br>*               to create a custom control library which may be used by <br>*               applications (i.e. SPINTEST.EXE) and the Dialog Editor. <br>* <br>* <br>*  FUNCTIONS:   DllMain()      - Registers spincube class when a <br>*                                      process loads this DLL. <br>*               CustomControlInfoA() - Called by DLGEDIT to initialize <br>*                                      a CCINFO structure(s). <br>*               SpincubeStyle()      - Brings up dialog box which allows <br>*                                      user to modify control style. <br>*               SpincubeSizeToText() - Called by DLGEDIT if user requests <br>*                                      that control be sized to fit text. <br>*               SpincubeWndProc()    - Window procedure for spincube <br>*                                      control. <br>*               SpincubeDlgProc()    - Procedure for control style dialog. <br>* <br>* <br>*  COMMMENTS:   The dialog editor interface has changed since Win 3.0. <br>*               Recommend browsing the NT CUSTCNTL.H file to get an <br>*               idea of the new interface. <br>* <br>* <br>*                           Microsoft Developer Support <br>*                  Copyright 1992 - 1998 Microsoft Corporation <br>* <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "spincube.h" <br> <br> <br>// <br>// function prototype for C runtime initialization routine <br>// <br> <br>BOOL WINAPI _CRT_INIT (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved); <br> <br> <br>// <br>// function prototype for Paint() in PAINT.C <br>// <br> <br>void Paint (HWND); <br> <br>// <br>// function prototype for looking up string resources <br>// <br> <br>LPTSTR GetStringRes (int); <br> <br> <br>// <br>// Declared below are the module's 2 exported variables. <br>// <br>//   giNumSpincubesThisProcess is an instance variable that contains <br>//   the number of (existing) Spincube controls created by the <br>//   current process. <br>// <br>//   giNumSpincubesAllProcesses is a shared (between processes) variable <br>//   which contains the total number of (existing) Spincube controls <br>//   created by all processes in the system. <br>// <br>// <br> <br>int giNumSpincubesThisProcess = 0; <br> <br>#pragma data_seg(".MYSEG") <br> <br>  int giNumSpincubesAllProcesses = 0; <br> <br>#pragma data_seg() <br> <br> <br>// <br>// Some global vars for this module <br>// <br> <br>HANDLE    ghMod;   // DLL's module handle <br>LPCCSTYLE gpccs;   // global pointer to a CCSTYLE structure <br> <br>CCSTYLEFLAGA aSpincubeStyleFlags[] = { { SS_ERASE,    0, "SS_ERASE"    }, <br>                                       { SS_INMOTION, 0, "SS_INMOTION" } }; <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    DllMain <br>* <br>*  INPUTS:      hDLL       - DLL module handle <br>*               dwReason   - reason being called (e.g. process attaching) <br>*               lpReserved - reserved <br>* <br>*  RETURNS:     TRUE if initialization passed, or <br>*               FALSE if initialization failed. <br>* <br>*  COMMENTS:    On DLL_PROCESS_ATTACH registers the SPINCUBECLASS <br>* <br>*               DLL initialization serialization is guaranteed within a <br>*               process (if multiple threads then DLL entry points are <br>*               serialized), but is not guaranteed across processes. <br>* <br>*               When synchronization objects are created, it is necesaary <br>*               to check the return code of GetLastError even if the create <br>*               call succeeded. If the object existed, ERROR_ALREADY_EXISTED <br>*               will be returned. <br>* <br>*               If your DLL uses any C runtime functions then you should <br>*               always call _CRT_INIT so that the C runtime can initialize <br>*               itself appropriately. Failure to do this may result in <br>*               indeterminate behavior. When the DLL entry point is called <br>*               for DLL_PROCESS_ATTACH &amp; DLL_THREAD_ATTACH circumstances, <br>*               _CRT_INIT should be called before any other initilization <br>*               is performed. When the DLL entry point is called for <br>*               DLL_PROCESS_DETACH &amp; DLL_THREAD_DETACH circumstances, <br>*               _CRT_INIT should be called after all cleanup has been <br>*               performed, i.e. right before the function returns. <br>* <br>\******************************************************************************/ <br> <br>BOOL WINAPI DllMain (HANDLE hDLL, DWORD dwReason, LPVOID lpReserved) <br>{ <br>  ghMod = hDLL; <br>  switch (dwReason) <br>  { <br>    case DLL_PROCESS_ATTACH: <br>    { <br>      WNDCLASS wc; <br> <br>      if (!_CRT_INIT (hDLL, dwReason, lpReserved)) <br> <br>        return FALSE; <br> <br>      wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_OWNDC | <br>                         CS_GLOBALCLASS ; <br>      wc.lpfnWndProc   = (WNDPROC) SpincubeWndProc; <br>      wc.cbClsExtra    = 0; <br>      wc.cbWndExtra    = SPINCUBE_EXTRA; <br>      wc.hInstance     = hDLL; <br>      wc.hIcon         = NULL; <br>      wc.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>      wc.hbrBackground = NULL; <br>      wc.lpszMenuName  = (LPSTR) NULL; <br>      wc.lpszClassName = (LPSTR) SPINCUBECLASS; <br> <br>      if (!RegisterClass (&amp;wc)) <br>      { <br>        MessageBox (NULL, <br>                    GetStringRes (IDS_REGCLASSFAIL), <br>                    (LPCTSTR) "SPINCUBE.DLL", <br>                    MB_OK | MB_ICONEXCLAMATION); <br> <br>        return FALSE; <br>      } <br> <br>      break; <br>    } <br> <br> <br>    case DLL_PROCESS_DETACH: <br>    { <br> <br>      if (!_CRT_INIT (hDLL, dwReason, lpReserved)) <br> <br>        return FALSE; <br> <br>      if (!UnregisterClass ((LPSTR) SPINCUBECLASS, hDLL )) <br>      { <br>        MessageBox (NULL, <br>                    GetStringRes (IDS_UNREGFAIL), <br>                    (LPCTSTR) "SPINCUBE.DLL", <br>                    MB_OK | MB_ICONEXCLAMATION); <br> <br>        return FALSE; <br>      } <br> <br>      break; <br>    } <br> <br> <br>    default: <br> <br>      if (!_CRT_INIT (hDLL, dwReason, lpReserved)) <br> <br>        return FALSE; <br> <br>      break; <br>  } <br>  return TRUE; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    CustomControlInfoA <br>* <br>*  INPUTS:      acci - pointer to an array od CCINFOA structures <br>* <br>*  RETURNS:     Number of controls supported by this DLL <br>* <br>*  COMMENTS:    See CUSTCNTL.H for more info <br>* <br>\******************************************************************************/ <br> <br>UINT CALLBACK CustomControlInfoA (LPCCINFOA acci) <br>{ <br>  // <br>  // Dlgedit is querying the number of controls this DLL supports, so return 1. <br>  //   Then we'll get called again with a valid "acci" <br>  // <br> <br>  if (!acci) <br> <br>    return 1; <br> <br> <br>  // <br>  // Fill in the constant calues. <br>  // <br> <br>  acci[0].flOptions         = 0; <br>  acci[0].cxDefault         = 40;      // default width  (dialog units) <br>  acci[0].cyDefault         = 40;      // default height (dialog units) <br>  acci[0].flStyleDefault    = WS_CHILD | <br>                              WS_VISIBLE | <br>                              SS_INMOTION; <br>  acci[0].flExtStyleDefault = 0; <br>  acci[0].flCtrlTypeMask    = 0; <br>  acci[0].cStyleFlags       = NUM_SPINCUBE_STYLES; <br>  acci[0].aStyleFlags       = aSpincubeStyleFlags; <br>  acci[0].lpfnStyle         = SpincubeStyle; <br>  acci[0].lpfnSizeToText    = SpincubeSizeToText; <br>  acci[0].dwReserved1       = 0; <br>  acci[0].dwReserved2       = 0; <br> <br> <br>  // <br>  // Copy the strings <br>  // <br>  // NOTE: MAKE SURE THE STRINGS COPIED DO NOT EXCEED THE LENGTH OF <br>  //       THE BUFFERS IN THE CCINFO STRUCTURE! <br>  // <br> <br>  lstrcpy (acci[0].szClass, SPINCUBECLASS); <br>  lstrcpy (acci[0].szDesc,  SPINCUBEDESCRIPTION); <br>  lstrcpy (acci[0].szTextDefault, SPINCUBEDEFAULTTEXT); <br> <br> <br>  // <br>  // Return the number of controls that the DLL supports <br>  // <br> <br>  return 1; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    SpincubeStyle <br>* <br>*  INPUTS:      hWndParent - handle of parent window (dialog editor) <br>*               pccs       - pointer to a CCSTYLE structure <br>* <br>*  RETURNS:     TRUE  if success, <br>*               FALSE if error occured <br>* <br>*  LOCAL VARS:  rc - return code from DialogBox <br>* <br>\******************************************************************************/ <br> <br>BOOL CALLBACK SpincubeStyle (HWND hWndParent, LPCCSTYLE pccs) <br>{ <br>  int rc; <br> <br>  gpccs = pccs; <br> <br>  if ((rc = DialogBox (ghMod, "SpincubeStyle", hWndParent, <br>                       (DLGPROC)SpincubeDlgProc)) == -1) <br>  { <br>    MessageBox (hWndParent, <br>                GetStringRes (IDS_DLGBOXFAIL), <br>                (LPCTSTR) "Spincube.dll", <br>                MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL); <br>    rc = 0; <br>  } <br> <br>  return (BOOL) rc; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    SpincubeSizeToText <br>* <br>*  INPUTS:      flStyle    - control style <br>*               flExtStyle - control extended style <br>*               hFont      - handle of font used to draw text <br>*               pszText    - control text <br>* <br>*  RETURNS:     Width (in pixels) control must be to accomodate text, or <br>*               -1 if an error occurs. <br>* <br>*  COMMENTS:    Just no-op here (since we never actually display text in <br>*               the control it doesn't need to be resized). <br>* <br>\******************************************************************************/ <br> <br>INT CALLBACK SpincubeSizeToText (DWORD flStyle, DWORD flExtStyle, <br>                                 HFONT hFont,   LPSTR pszText) <br>{ <br>  return -1; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    SpincubeWndProc (standard window procedure INPUTS/RETURNS) <br>* <br>*  COMMENTS:    This is the window procedure for our custom control. At <br>*               creation we alloc a SPINCUBEINFO struct, initialize it, <br>*               and associate it with this particular control. We also <br>*               start a timer which will invalidate the window every so <br>*               often; this causes a repaint, and the cube gets drawn in <br>*               a new position. Left button clicks will turn toggle the <br>*               erase option, causing a "trail" of cubes to be left when <br>*               off. Right button clicks will toggle the motion state of <br>*               the control (and turn the timer on/off). <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK SpincubeWndProc (HWND hwnd, UINT msg, WPARAM wParam, <br>                                  LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_CREATE: <br>    { <br>      // <br>      // Alloc &amp; init a SPINCUBEINFO struct for this particular control <br>      // <br> <br>      HDC            hdc; <br>      LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam; <br>      PSPINCUBEINFO  pSCI = (PSPINCUBEINFO) LocalAlloc (LPTR, <br>                                                        sizeof(SPINCUBEINFO)); <br>      if (!pSCI) <br>      { <br>        MessageBox (NULL, <br>                    GetStringRes (IDS_ALLOCFAIL), <br>                    (LPCTSTR) "SPINCUBE.DLL", <br>                    MB_OK | MB_ICONEXCLAMATION); <br>        return -1; <br>      } <br> <br> <br>      // <br>      // Alloc the compatible DC for this control. <br>      // <br> <br>      hdc = GetDC (hwnd); <br> <br>      if ((pSCI-&gt;hdcCompat = CreateCompatibleDC (hdc)) == NULL) <br>      { <br>        MessageBox (NULL, <br>                    GetStringRes (IDS_CREATEDCFAIL), <br>                    (LPCTSTR) "SPINCUBE.DLL", <br>                    MB_OK | MB_ICONEXCLAMATION); <br>        return -1; <br>      } <br> <br>      ReleaseDC (hwnd, hdc); <br> <br> <br>      // <br>      // Initialize this instance structure <br>      // <br> <br>      pSCI-&gt;fCurrentXRotation = <br>      pSCI-&gt;fCurrentYRotation = <br>      pSCI-&gt;fCurrentZRotation = (float) 0.0; <br> <br>      pSCI-&gt;fCurrentXRotationInc = <br>      pSCI-&gt;fCurrentYRotationInc = <br>      pSCI-&gt;fCurrentZRotationInc = (float) 0.2617; // a random # (15 degrees) <br> <br>      pSCI-&gt;iCurrentXTranslation = <br>      pSCI-&gt;iCurrentYTranslation = <br>      pSCI-&gt;iCurrentZTranslation = 0; <br> <br>      // <br>      // All these calculations so the cubes start out with random movements. <br>      // <br> <br>      if ((pSCI-&gt;iCurrentXTranslationInc = (rand() % 10) + 2) &gt; 7) <br> <br>        pSCI-&gt;iCurrentXTranslationInc = -pSCI-&gt;iCurrentXTranslationInc; <br> <br>      if ((pSCI-&gt;iCurrentYTranslationInc = (rand() % 10) + 2) &lt;= 7) <br> <br>        pSCI-&gt;iCurrentYTranslationInc = -pSCI-&gt;iCurrentYTranslationInc; <br> <br>      if ((pSCI-&gt;iCurrentZTranslationInc = (rand() % 10) + 2) &gt; 7) <br> <br>        pSCI-&gt;iCurrentZTranslationInc = -pSCI-&gt;iCurrentZTranslationInc; <br> <br>      pSCI-&gt;rcCubeBoundary.left   = <br>      pSCI-&gt;rcCubeBoundary.top    = 0; <br>      pSCI-&gt;rcCubeBoundary.right  = lpcs-&gt;cx; <br>      pSCI-&gt;rcCubeBoundary.bottom = lpcs-&gt;cy; <br> <br>      pSCI-&gt;iOptions  = SPINCUBE_REPAINT_BKGND; <br>      pSCI-&gt;hbmCompat = NULL; <br> <br>      SetWindowLong (hwnd, GWL_SPINCUBEDATA, (LONG) pSCI); <br> <br>      SetTimer (hwnd, SPIN_EVENT, SPIN_INTERVAL, NULL); <br> <br>      // <br>      // Increment the count vars <br>      // <br> <br>      giNumSpincubesThisProcess++; <br>      giNumSpincubesAllProcesses++; <br> <br>      break; <br>    } <br> <br>    case WM_PAINT: <br> <br>      Paint (hwnd); <br>      break; <br> <br>    case WM_TIMER: <br> <br>      switch (wParam) <br>      { <br>        case SPIN_EVENT: <br>        { <br>          PSPINCUBEINFO pSCI = (PSPINCUBEINFO) GetWindowLong (hwnd, <br>                                                              GWL_SPINCUBEDATA); <br> <br>          InvalidateRect (hwnd, &amp;pSCI-&gt;rcCubeBoundary, FALSE); <br> <br>          break; <br>        } <br>      } <br> <br>      break; <br> <br>    case WM_LBUTTONDBLCLK: <br>    { <br>      // <br>      // Toggle the erase state of the control <br>      // <br> <br>      if (DO_ERASE(hwnd)) <br> <br>        SetWindowLong (hwnd, GWL_STYLE, <br>                       GetWindowLong (hwnd, GWL_STYLE) &amp; ~SS_ERASE); <br> <br> <br>      else <br>      { <br>        // <br>        // Repaint the entire control to get rid of the (cube trails) mess <br>        // <br> <br>        PSPINCUBEINFO pSCI = (PSPINCUBEINFO) GetWindowLong (hwnd, <br>                                                            GWL_SPINCUBEDATA); <br> <br>        SetWindowLong (hwnd, GWL_STYLE, <br>                       GetWindowLong (hwnd, GWL_STYLE) | SS_ERASE); <br>        pSCI-&gt;iOptions |= SPINCUBE_REPAINT_BKGND; <br>        InvalidateRect (hwnd, NULL, FALSE); <br>        SendMessage (hwnd, WM_PAINT, 0, 0); <br>      } <br>      break; <br>    } <br> <br>    case WM_RBUTTONDBLCLK: <br>    { <br>      // <br>      // Toggle the motion state of the control <br>      // <br> <br>      if (IN_MOTION(hwnd)) <br>      { <br>        KillTimer (hwnd, SPIN_EVENT); <br>        SetWindowLong (hwnd, GWL_STYLE, <br>                       GetWindowLong (hwnd, GWL_STYLE) &amp; ~SS_INMOTION); <br>      } <br>      else <br>      { <br>        SetTimer (hwnd, SPIN_EVENT, SPIN_INTERVAL, NULL); <br>        SetWindowLong (hwnd, GWL_STYLE, <br>                       GetWindowLong (hwnd, GWL_STYLE) | SS_INMOTION); <br>      } <br> <br>      break; <br>    } <br> <br>    case WM_SIZE: <br> <br>      if (wParam == SIZE_MAXIMIZED || wParam == SIZE_RESTORED) <br>      { <br>        PSPINCUBEINFO pSCI = (PSPINCUBEINFO) GetWindowLong (hwnd, <br>                                                            GWL_SPINCUBEDATA); <br>        // <br>        // Get a new bitmap which is the new size of our window <br>        // <br> <br>        HDC hdc = GetDC (hwnd); <br>        HBITMAP hbmTemp = CreateCompatibleBitmap (hdc, <br>                                                  (int) LOWORD (lParam), <br>                                                  (int) HIWORD (lParam)); <br>        if (!hbmTemp) <br>        { <br>          // <br>          // Scream, yell, &amp; committ an untimely demise... <br>          // <br> <br>          MessageBox (NULL, <br>                      GetStringRes (IDS_CREATEBITMAPFAIL), <br>                      (LPCTSTR) "SPINCUBE.DLL", <br>                      MB_OK | MB_ICONEXCLAMATION); <br>          DestroyWindow (hwnd); <br>        } <br> <br>        pSCI-&gt;hbmSave = SelectObject (pSCI-&gt;hdcCompat, hbmTemp); <br>        if (pSCI-&gt;hbmCompat) <br>        DeleteObject (pSCI-&gt;hbmCompat); <br>        ReleaseDC    (hwnd, hdc); <br>        pSCI-&gt;hbmCompat = hbmTemp; <br> <br> <br>        // <br>        // Reset the translation so the cube doesn't go spinning off into <br>        //   space somewhere- we'd never see it again! <br>        // <br> <br>        pSCI-&gt;iCurrentXTranslation = <br>        pSCI-&gt;iCurrentYTranslation = <br>        pSCI-&gt;iCurrentZTranslation = 0; <br> <br>        // <br>        // All these calculations so the cube starts out with random movements, <br>        // <br> <br>        if ((pSCI-&gt;iCurrentXTranslationInc = (rand() % 10) + 2) &gt; 7) <br> <br>          pSCI-&gt;iCurrentXTranslationInc = -pSCI-&gt;iCurrentXTranslationInc; <br> <br>        if ((pSCI-&gt;iCurrentYTranslationInc = (rand() % 10) + 2) &lt;= 7) <br> <br>          pSCI-&gt;iCurrentYTranslationInc = -pSCI-&gt;iCurrentYTranslationInc; <br> <br>        if ((pSCI-&gt;iCurrentZTranslationInc = (rand() % 10) + 2) &gt; 7) <br> <br>          pSCI-&gt;iCurrentZTranslationInc = -pSCI-&gt;iCurrentZTranslationInc; <br> <br>        pSCI-&gt;rcCubeBoundary.left   = <br>        pSCI-&gt;rcCubeBoundary.top    = 0; <br>        pSCI-&gt;rcCubeBoundary.right  = (int) LOWORD (lParam); <br>        pSCI-&gt;rcCubeBoundary.bottom = (int) HIWORD (lParam); <br> <br>        pSCI-&gt;iOptions |= SPINCUBE_REPAINT_BKGND; <br> <br>        InvalidateRect (hwnd, NULL, FALSE); <br>      } <br> <br>      break; <br> <br>    case WM_DESTROY: <br>    { <br>      PSPINCUBEINFO pSCI = (PSPINCUBEINFO) GetWindowLong (hwnd, <br>                                                          GWL_SPINCUBEDATA); <br>      // <br>      // Clean up all the resources used for this control <br>      // <br> <br>      if (IN_MOTION(hwnd)) <br> <br>        KillTimer (hwnd, SPIN_EVENT); <br> <br>      SelectObject (pSCI-&gt;hdcCompat, pSCI-&gt;hbmSave); <br>      DeleteObject (pSCI-&gt;hbmCompat); <br>      DeleteDC     (pSCI-&gt;hdcCompat); <br> <br>      LocalFree (LocalHandle ((LPVOID) pSCI)); <br> <br> <br>      // <br>      // Decrement the global count vars <br>      // <br> <br>      giNumSpincubesThisProcess--; <br>      giNumSpincubesAllProcesses--; <br> <br>      break; <br>    } <br> <br>    default: <br> <br>      return (DefWindowProc(hwnd, msg, wParam, lParam)); <br>  } <br> <br>  return ((LONG) TRUE); <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    SpincubeDlgProc (standard dialog procedure INPUTS/RETURNS) <br>* <br>*  COMMENTS:    This dialog comes up in response to a user requesting to <br>*               modify the control style. This sample allows for changing <br>*               the control's text, and this is done by modifying the <br>*               CCSTYLE structure pointed at by "gpccs" (a pointer <br>*               that was passed to us by dlgedit). <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK SpincubeDlgProc (HWND hDlg, UINT msg, WPARAM wParam, <br>                                  LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_INITDIALOG : <br>    { <br>      if (gpccs-&gt;flStyle &amp; SS_ERASE) <br> <br>        CheckDlgButton (hDlg, DID_ERASE, 1); <br> <br>      if (gpccs-&gt;flStyle &amp; SS_INMOTION) <br> <br>        CheckDlgButton (hDlg, DID_INMOTION, 1); <br> <br>      break; <br>    } <br> <br>    case WM_COMMAND: <br> <br>      switch (LOWORD(wParam)) <br>      { <br>        case DID_ERASE: <br> <br>          if (IsDlgButtonChecked (hDlg, DID_ERASE)) <br> <br>            gpccs-&gt;flStyle |= SS_ERASE; <br> <br>          else <br> <br>            gpccs-&gt;flStyle &amp;= ~SS_ERASE; <br> <br>          break; <br> <br>        case DID_INMOTION: <br> <br>          if (IsDlgButtonChecked (hDlg, DID_INMOTION)) <br> <br>            gpccs-&gt;flStyle |= SS_INMOTION; <br> <br>          else <br> <br>            gpccs-&gt;flStyle &amp;= ~SS_INMOTION; <br> <br>          break; <br> <br>        case DID_OK: <br> <br>          EndDialog  (hDlg, 1); <br>          break; <br>      } <br>      break; <br>  } <br>  return FALSE; <br>} <br> <br> <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Load the resource string with the ID given, and return a <br>*               pointer to it.  Notice that the buffer is common memory so <br>*               the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
