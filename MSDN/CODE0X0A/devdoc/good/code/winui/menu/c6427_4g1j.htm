<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MENU.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6427"></a>MENU.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corp. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************** <br> *                                                                         * <br> *  PROGRAM     : Menu.c                                                   * <br> *                                                                         * <br> *  PURPOSE     : To give a demonstration of the use of popup menus, user  * <br> *                defined menus and menu functions.                        * <br> *                                                                         * <br> *  FUNCTIONS   : WinMain()           - Calls the initialization function  * <br> *                                      and enters the message loop.       * <br> *                                                                         * <br> *                MenuInit()          - Registers the app. window class.   * <br> *                                                                         * <br> *                About()             - Dialog function for the About..    * <br> *                                      dialog.                            * <br> *                                                                         * <br> *                ShrinkBitmap()      - Shrinks a 64x64 bitmap to a size   * <br> *                                      useable for a user-defined menu    * <br> *                                      checkmark.                         * <br> *                                                                         * <br> *                HandleCreate()      - Creates a new menu and appends it  * <br> *                                      to the main menu                   * <br> *                                                                         * <br> *                HandlePaint()       - Handles repainting the app's client* <br> *                                      area                               * <br> *                                                                         * <br> *                HandleChangeColors()- Changes the state of the "colors"  * <br> *                                      menu item.                         * <br> *                                                                         * <br> *                HandleDrawItem()    - Redraws the menu items in the      * <br> *                                      "colors" menu                      * <br> *                                                                         * <br> *                HandlePopupMenu()   - handles display of the "floating"  * <br> *                                      popup.                             * <br> *                                                                         * <br> *                MenuWndProc()       - Window function for the app.       * <br> *                                                                         * <br> *                                                                         * <br> ***************************************************************************/ <br>#include "windows.h" <br>#include "menu.h" <br> <br> <br>HANDLE   hInst; <br>HMENU    hBigMenu; <br>HBITMAP  hbmCheckOn; <br>HBITMAP  hbmCheckOff; <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WinMain(HANDLE, HANDLE, LPSTR, int)                        * <br> *                                                                          * <br> *  PURPOSE    : Creates the main app. window, calls an initialization      * <br> *               function and enters the message loop.                      * <br> *                                                                          * <br> ****************************************************************************/ <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br> <br>    HWND  hWnd; <br>    MSG msg;                                 /* message                      */ <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br>    /* Register main window class if this is the first instance of the app. */ <br>    if (!hPrevInstance) <br>        if (!MenuInit (hInstance)) <br>            return 0; <br> <br>    hInst = hInstance; <br> <br>    /* Create the app. window */ <br>    hWnd = CreateWindow ("menu", <br>                         "Menu Example", <br>                         WS_OVERLAPPEDWINDOW, <br>                         CW_USEDEFAULT, <br>                         CW_USEDEFAULT, <br>                         CW_USEDEFAULT, <br>                         CW_USEDEFAULT, <br>                         (HWND) NULL, <br>                         NULL, <br>                         hInstance, <br>                         (LPSTR) NULL); <br> <br>    if (!hWnd) <br>        return 0; <br> <br>    ShowWindow (hWnd, nCmdShow); <br>    UpdateWindow (hWnd); <br> <br>    while (GetMessage (&amp;msg, NULL, 0, 0)){ <br>        /* Since we have no accelerators, no need to call <br>         * TranslateAccelerator here. <br>         */ <br>        TranslateMessage (&amp;msg); <br>        DispatchMessage (&amp;msg); <br>    } <br>    return(msg.wParam); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MenuInit (hInstance)                                       * <br> *                                                                          * <br> *  PURPOSE    : Registers the main window class.                           * <br> *                                                                          * <br> *  RETURNS    : TRUE   -  if RegisterClass() went off ok                   * <br> *               FALSE  -  otherwise.                                       * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL NEAR PASCAL MenuInit (HANDLE hInstance) <br>{ <br>    HANDLE    hMemory; <br>    PWNDCLASS pWndClass; <br>    BOOL      bSuccess; <br> <br>    /* Initialize the menu window class */ <br>    hMemory   = LocalAlloc(LPTR, sizeof(WNDCLASS)); <br>    if(!hMemory){ <br>        MessageBox(NULL, "&lt;MenuInit&gt; Not enough memory.", NULL, MB_OK | MB_ICONHAND); <br>        return(FALSE); <br>    } <br> <br>    pWndClass = (PWNDCLASS) LocalLock(hMemory); <br> <br>    pWndClass-&gt;style         = 0; <br>    pWndClass-&gt;lpfnWndProc   = (WNDPROC) MenuWndProc; <br>    pWndClass-&gt;hInstance     = hInstance; <br>    pWndClass-&gt;hIcon         = LoadIcon (hInstance, "menu"); <br>    pWndClass-&gt;hCursor       = LoadCursor (NULL, IDC_ARROW); <br>    pWndClass-&gt;hbrBackground = GetStockObject (WHITE_BRUSH); <br>    pWndClass-&gt;lpszMenuName  = (LPSTR) "MenuMenu", <br>    pWndClass-&gt;lpszClassName = (LPSTR) "menu"; <br> <br>    bSuccess = RegisterClass (pWndClass); <br>    LocalUnlock (hMemory); <br>    LocalFree (hMemory); <br> <br>    return bSuccess; <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : About (hDlg, message, wParam, lParam)                      * <br> *                                                                          * <br> *  PURPOSE    : Dialog function for the About menu... dialog.              * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL APIENTRY About( <br>        HWND hDlg, <br>        UINT message, <br>        UINT wParam, <br>        LONG lParam) <br> <br>{ <br>    switch (message){ <br>        case WM_INITDIALOG: <br>            return(TRUE); <br> <br>        case WM_COMMAND: <br>            // LOWORD added for portability <br>            if (LOWORD(wParam) == IDOK){ <br>                EndDialog(hDlg,0); <br>                return(TRUE); <br>            } <br>            break; <br>    } <br>    return(FALSE); <br>        UNREFERENCED_PARAMETER(lParam); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ShrinkBitmap(hwnd, hbm)                                    * <br> *                                                                          * <br> *  PURPOSE    : This function shrinks a 64x64 bitmap into a bitmap useable * <br> *               for the user-defined checkmark for menu items. This can be * <br> *               easily generalized to shrink bitmaps of any size.          * <br> *                                                                          * <br> *  RETURNS    : HBITMAP - A handle to the new bitmap.                      * <br> *                                                                          * <br> ****************************************************************************/ <br>HBITMAP APIENTRY ShrinkBitmap ( <br>        HWND hwnd, <br>        HBITMAP hbm) <br>{ <br>    HDC     hdc; <br>    HDC     hmemorydcNew; <br>    HDC     hmemorydcOld; <br>    LONG    checkMarkSize; <br>    HBITMAP hCheckBitmap; <br>    HBITMAP hOldBitmapSave; <br>    HBITMAP hNewBitmapSave; <br> <br>    hdc = GetDC (hwnd); <br> <br>    /* Create DCs for the source (old) and target (new) bitmaps */ <br>    hmemorydcNew = CreateCompatibleDC (hdc); <br>    hmemorydcOld = CreateCompatibleDC (hdc); <br> <br>    /* Determine the dimensions of the default menu checkmark and <br>     * create a target bitmap of the same dimensions <br>     */ <br>    checkMarkSize = GetMenuCheckMarkDimensions (); <br>    hCheckBitmap  = CreateCompatibleBitmap (hdc, <br>                                            LOWORD (checkMarkSize), <br>                                            HIWORD (checkMarkSize)); <br> <br>    /* Select the source bitmap and the target bitmap into their <br>     * respective DCs. <br>     */ <br>    hOldBitmapSave = SelectObject (hmemorydcNew, hCheckBitmap); <br>    hNewBitmapSave = SelectObject (hmemorydcOld, hbm); <br> <br>    /* Shrink the source bitmap into the target DC */ <br>    StretchBlt (hmemorydcNew, <br>                0, <br>                0, <br>                LOWORD(checkMarkSize), <br>                HIWORD(checkMarkSize), <br>                hmemorydcOld, <br>                0, <br>                0, <br>                64, <br>                64, <br>                SRCCOPY); <br> <br>    /* De-select the bitmaps and clean up .. */ <br>    SelectObject (hmemorydcNew, hOldBitmapSave); <br>    SelectObject (hmemorydcOld, hNewBitmapSave); <br>    DeleteDC (hmemorydcNew); <br>    DeleteDC (hmemorydcOld); <br>    ReleaseDC (hwnd, hdc); <br> <br>    /* .. and return a handle to the target bitmap */ <br>    return hCheckBitmap; <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandleCreate ( hwnd )                                      * <br> *                                                                          * <br> *  PURPOSE    : Creates a new (empty) menu and appends to it the "State"   * <br> *               menu items. It sets up the user-defined checkmarks for the * <br> *               menu. It then inserts this menu into the main menu bar.    * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY HandleCreate (HWND hwnd) <br>{ <br>    HMENU   hMenu; <br>    HMENU   hWndMenu; <br> <br>    /* Create a new menu into the menubar on the fly */ <br>    hMenu = CreateMenu (); <br>    if (!hMenu) <br>        return; <br> <br>    /* Append the state menu items to it */ <br>    AppendMenu (hMenu, MF_STRING, IDM_STATE1, "South Dakota"); <br>    AppendMenu (hMenu, MF_STRING, IDM_STATE2, "Washington"); <br>    AppendMenu (hMenu, MF_STRING, IDM_STATE3, "California"); <br>    if (!AppendMenu (hMenu, MF_STRING, IDM_STATE4, "Oregon")){ <br>        /* It is unlikely the other appends will fail and this will succeed. <br>         * So just check this one. And if it fails, Destroy the menu for <br>         * good measure and return. <br>         */ <br>        DestroyMenu(hMenu); <br>        return; <br>    } <br>    hbmCheckOn  = ShrinkBitmap (hwnd, LoadBitmap (hInst, "checkon")); <br>    hbmCheckOff = ShrinkBitmap (hwnd, LoadBitmap (hInst, "checkoff")); <br> <br>    /* Set up the user-defined check marks */ <br>    SetMenuItemBitmaps (hMenu, 0, MF_BYPOSITION, hbmCheckOff, hbmCheckOn); <br>    SetMenuItemBitmaps (hMenu, 1, MF_BYPOSITION, hbmCheckOff, hbmCheckOn); <br>    SetMenuItemBitmaps (hMenu, 2, MF_BYPOSITION, hbmCheckOff, hbmCheckOn); <br>    SetMenuItemBitmaps (hMenu, 3, MF_BYPOSITION, hbmCheckOff, hbmCheckOn); <br> <br>    /* Now insert the menu into the main menu bar. */ <br>    hWndMenu = GetMenu (hwnd); <br>    InsertMenu (hWndMenu, 2, MF_POPUP|MF_BYPOSITION, (DWORD)hMenu, "States"); <br> <br>    return; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandlePaint ( hwnd )                                       * <br> *                                                                          * <br> *  PURPOSE    : Handles the repainting of the main app's client area.      * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY HandlePaint (HWND hwnd) <br>{ <br>    HDC         hdc; <br>    PAINTSTRUCT ps; <br>    RECT        rc; <br> <br>    hdc = BeginPaint (hwnd, (LPPAINTSTRUCT)&amp;ps); <br> <br>    /* Center the text in the client area */ <br>    GetClientRect (hwnd, (LPRECT)&amp;rc); <br>    DrawText (hdc, <br>              "Down click in the window for a popup menu", <br>               41, <br>               (LPRECT)&amp;rc, <br>               DT_CENTER | DT_WORDBREAK); <br>    EndPaint(hwnd, (LPPAINTSTRUCT)&amp;ps); <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandleChangeColors (hwnd)                                  * <br> *                                                                          * <br> *  PURPOSE    : Toggles the state of the Owner Draw item in the Colors     * <br> *               menu. If it is on, the "Black", "Blue", "Red", and "Green" * <br> *               individual menu text items are modified so that they will  * <br> *               contain bands of color. Otherwise, the colors are replaced * <br> *               by the text.                                               * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY HandleChangeColors(HWND hwnd) <br>{ <br>    HMENU hMenu; <br>    BOOL  fOwnerDraw; <br> <br>    /* Get a handle to the Colors menu. This is at position 1. */ <br>    hMenu = GetSubMenu (GetMenu (hwnd), IDCOLORS_POS); <br> <br>    /* Get the current state of the item */ <br>    fOwnerDraw = GetMenuState ( hMenu, <br>                                IDM_COLOROWNERDR, MF_BYCOMMAND) &amp; MF_CHECKED; <br> <br>    /* Toggle the state of the item. */ <br>    CheckMenuItem ( hMenu, <br>                    IDM_COLOROWNERDR, <br>                    MF_BYCOMMAND | (fOwnerDraw ? MF_UNCHECKED : MF_CHECKED)); <br> <br>    if (!fOwnerDraw){ <br>        /* Change the items to owner-draw items. Pass the RGB value for the <br>         * color as the application-supplied data. This makes it easier for <br>         * us to draw the items. <br>         */ <br>        ModifyMenu(hMenu, <br>                   IDM_BLACK, <br>                   MF_OWNERDRAW | MF_BYCOMMAND, <br>                   IDM_BLACK, <br>                   (LPSTR)RGB (0,0,0)); <br> <br>        ModifyMenu(hMenu, <br>                   IDM_BLUE, <br>                   MF_OWNERDRAW | MF_BYCOMMAND, <br>                   IDM_BLUE, <br>                   (LPSTR)RGB (0,0,255)); <br> <br>        ModifyMenu(hMenu, <br>                   IDM_RED, <br>                   MF_OWNERDRAW | MF_BYCOMMAND, <br>                   IDM_RED, <br>                   (LPSTR)RGB (255,0,0)); <br> <br>        ModifyMenu(hMenu, <br>                   IDM_GREEN, <br>                   MF_OWNERDRAW | MF_BYCOMMAND, <br>                   IDM_GREEN, <br>                   (LPSTR)RGB (0,255,0)); <br>    } <br>    else { <br>        /* Change the items to normal text items. */ <br>        ModifyMenu(hMenu, IDM_BLACK, MF_BYCOMMAND, IDM_BLACK, "Black"); <br> <br>        ModifyMenu(hMenu, IDM_BLUE, MF_BYCOMMAND, IDM_BLUE, "Blue"); <br> <br>        ModifyMenu(hMenu, IDM_RED, MF_BYCOMMAND, IDM_RED, "Red"); <br> <br>        ModifyMenu(hMenu, IDM_GREEN, MF_BYCOMMAND, IDM_GREEN, "Green"); <br>    } <br>} <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandleDrawItem ( hwnd, lpdis)                              * <br> *                                                                          * <br> *  PURPOSE    : Called in response to a WM_DRAWITEM message, i.e. when the * <br> *               colors menu is being modified to an owner-draw menu, or    * <br> *               one of the items is selected. It sizes the checkmark bitmap* <br> *               to fit next to a color band and draws the color bands and  * <br> *               the checkmark on the popup menu.                           * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY HandleDrawItem( <br>        HWND             hwnd, <br>        LPDRAWITEMSTRUCT lpdis) <br> <br>{ <br>    HDC     hdcBitmap; <br>    HBITMAP hbmSave; <br>    HBRUSH  hbr; <br>    RECT    rc; <br>    LONG    checkMarkSize; <br>    DWORD   textColorSave; <br>    DWORD   bkColorSave; <br> <br>    /* Get the size of the checkmark so we can leave room for it since we <br>     * want to be able to check the selected color. <br>     */ <br>    checkMarkSize = GetMenuCheckMarkDimensions (); <br> <br>    if (lpdis-&gt;itemAction == ODA_SELECT || <br>        lpdis-&gt;itemAction == ODA_DRAWENTIRE){ <br> <br>        CopyRect ((LPRECT)&amp;rc, (LPRECT)&amp;lpdis-&gt;rcItem); <br>        InflateRect ((LPRECT)&amp;rc, (-2 - LOWORD(checkMarkSize)), -2); <br> <br>        if (lpdis-&gt;itemState &amp; ODS_SELECTED) <br>        { <br>            /* Item has been selected -- hilite with a gray frame */ <br>            hbr = GetStockObject (GRAY_BRUSH); <br>            FrameRect (lpdis-&gt;hDC, (LPRECT)&amp;rc, hbr); <br>        } <br>        else if (lpdis-&gt;itemAction == ODA_SELECT) <br>        { <br>            /* Item has been de-selected -- remove gray frame */ <br>            hbr = CreateSolidBrush (GetSysColor (COLOR_MENU)); <br>            FrameRect (lpdis-&gt;hDC, (LPRECT)&amp;rc, hbr); <br>            DeleteObject (hbr); <br>        } <br>    } <br> <br>    if (lpdis-&gt;itemAction == ODA_DRAWENTIRE){ <br> <br>        /* Paint the color item in the color requested. */ <br>        hbr = CreateSolidBrush (lpdis-&gt;itemData); <br>        CopyRect ((LPRECT)&amp;rc, (LPRECT)&amp;lpdis-&gt;rcItem); <br>        InflateRect ((LPRECT)&amp;rc, -10-LOWORD(checkMarkSize), -10); <br>        FillRect (lpdis-&gt;hDC, (LPRECT)&amp;rc, hbr); <br>        DeleteObject (hbr); <br> <br>        if (lpdis-&gt;itemState &amp; ODS_CHECKED){ <br>            /* Draw the check mark if the item is checked. */ <br>            hdcBitmap = CreateCompatibleDC (lpdis-&gt;hDC); <br>            hbmSave = SelectObject (hdcBitmap, hbmCheckOn); <br> <br>            textColorSave = SetTextColor (lpdis-&gt;hDC, 0x00000000L); <br>            bkColorSave   = SetBkColor (lpdis-&gt;hDC, 0x00FFFFFFL); <br> <br>            /* Use Magic bitblt op so that monochrome bitmaps preserve <br>               background and foreground colors. */ <br>            BitBlt (lpdis-&gt;hDC, <br>                    lpdis-&gt;rcItem.left, <br>                    lpdis-&gt;rcItem.top+ <br>                           (MEASUREITEMHEIGHT - HIWORD (checkMarkSize)) / 2, <br>                    LOWORD (checkMarkSize), <br>                    HIWORD (checkMarkSize), <br>                    hdcBitmap, <br>                    0, <br>                    0, <br>                    ROP_PSDPxax); <br> <br>            /* Restore colors and bitmap and clean up */ <br>            SetTextColor (lpdis-&gt;hDC, textColorSave); <br>            SetBkColor (lpdis-&gt;hDC, bkColorSave); <br>            SelectObject (hdcBitmap, hbmSave); <br>            DeleteDC (hdcBitmap); <br> <br>        } <br>    } <br>        UNREFERENCED_PARAMETER(hwnd); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandlePopupMenu (hwnd, point)                              * <br> *                                                                          * <br> *  PURPOSE    : Handles the display of the "floating" popup that appears   *                                                           * <br> *               on a mouse click in the app's client area.                 * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID APIENTRY HandlePopupMenu ( <br>        HWND   hwnd, <br>        POINT point) <br> <br>{ <br>    HMENU hMenu; <br>    HMENU hMenuTrackPopup; <br> <br>    /* Get the menu for the popup from the resource file. */ <br>    hMenu = LoadMenu (hInst, "PopupMenu"); <br>    if (!hMenu) <br>        return; <br> <br>    /* Get the first menu in it which we will use for the call to <br>     * TrackPopup(). This could also have been created on the fly using <br>     * CreatePopupMenu and then we could have used InsertMenu() or <br>     * AppendMenu. <br>     */ <br>    hMenuTrackPopup = GetSubMenu (hMenu, 0); <br> <br>    /* Convert the mouse point to screen coordinates since that is what <br>     * TrackPopup expects. <br>     */ <br>    ClientToScreen (hwnd, (LPPOINT)&amp;point); <br> <br>    /* Draw and track the "floating" popup */ <br>    TrackPopupMenu (hMenuTrackPopup, 0, point.x, point.y, 0, hwnd, NULL); <br> <br>    /* Destroy the menu since were are done with it. */ <br>    DestroyMenu (hMenu); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MenuWndProc (hWnd, message, wParam, lParam)                * <br> *                                                                          * <br> *  PURPOSE    : Window function for the main app. window. Processes all the* <br> *               menu selections and oter messages.                         * <br> *                                                                          * <br> ****************************************************************************/ <br>LONG APIENTRY MenuWndProc ( <br>        HWND hWnd, <br>        UINT message, <br>        UINT wParam, <br>        LONG lParam) <br> <br>{ <br>    HMENU hMenu; <br>    RECT rc; <br>    POINT pt; <br> <br> <br>    switch (message){ <br>        case WM_SYSCOMMAND: <br>            /* Show the About ... dialog */ <br>            if (wParam == ID_ABOUT){ <br>                DialogBox (hInst, <br>                           "AboutBox", <br>                           hWnd, <br>                           About); <br> <br>                break; <br>            } <br>            else <br>              return DefWindowProc (hWnd, message, wParam, lParam); <br> <br>        case WM_COMMAND: <br>            // LOWORD added for portability <br>            switch (LOWORD(wParam)){ <br>                 case IDM_EXIT: <br>                   DestroyWindow (hWnd); <br>                   break; <br> <br>                 case IDM_ABOUT: <br>                   /* Bring up the About.. dialog box */ <br>                   DialogBox (hInst, <br>                              "AboutBox", <br>                              hWnd, <br>                              About); <br> <br>                   break; <br> <br>                 case IDM_COLOROWNERDR: <br>                     /* Change colors in color menu depending on state of this <br>                        menu item. */ <br>                     HandleChangeColors (hWnd); <br>                     break; <br> <br>                 case IDM_STATE1: <br>                 case IDM_STATE2: <br>                 case IDM_STATE3: <br>                 case IDM_STATE4: <br>                      /* Get a handle to the states menu... */ <br>                      hMenu = GetSubMenu (GetMenu (hWnd), IDSTATES_POS); <br> <br>                      /* Uncheck all the items. */ <br>                      CheckMenuItem (hMenu, IDM_STATE1, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br>                      CheckMenuItem (hMenu, IDM_STATE2, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br>                      CheckMenuItem (hMenu, IDM_STATE3, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br>                      CheckMenuItem (hMenu, IDM_STATE4, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br> <br>                      /* ...and just check the selected one.*/ <br>                      CheckMenuItem (hMenu, (WORD)wParam, <br>                                     MF_BYCOMMAND | MF_CHECKED); <br>                     break; <br> <br>                 case IDM_BLACK: <br>                 case IDM_RED: <br>                 case IDM_BLUE: <br>                 case IDM_GREEN: <br>                      /* Get a handle to the Colors menu. */ <br>                      hMenu = GetSubMenu (GetMenu (hWnd),IDCOLORS_POS); <br> <br>                      /* Uncheck all the items. */ <br>                      CheckMenuItem (hMenu, IDM_BLACK, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br>                      CheckMenuItem (hMenu, IDM_RED, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br>                      CheckMenuItem (hMenu, IDM_BLUE, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br>                      CheckMenuItem (hMenu, IDM_GREEN, <br>                                     MF_BYCOMMAND | MF_UNCHECKED); <br> <br>                      /* ...and just check the selected one.*/ <br>                      CheckMenuItem (hMenu, (WORD)wParam, <br>                                     MF_BYCOMMAND | MF_CHECKED); <br>                      break; <br> <br>                 case IDM_FONT: <br>                      /* Messages sent to us from TrackPopupMenu when <br>                       * items are selected from the "floating" popups <br>                       */ <br>                      MessageBox (hWnd, <br>                                  "A font was selected", <br>                                  "Popup Menu Alert", <br>                                  MB_APPLMODAL|MB_OK); <br>                      break; <br> <br>                 case IDM_SIZE: <br>                      MessageBox (hWnd, <br>                                  "A size was selected", <br>                                  "Popup Menu Alert", <br>                                  MB_APPLMODAL|MB_OK); <br>                      break; <br> <br>                 case IDM_STYLE: <br>                      MessageBox (hWnd, <br>                                  "A style was selected", <br>                                  "Popup Menu Alert", <br>                                  MB_APPLMODAL|MB_OK); <br>                      break; <br>            } <br>            break; <br> <br>        case WM_SIZE: <br>            if (lParam){ <br>                /* If window is being sized to a non zero value... <br>                 * invalidate it's client area. <br>                 */ <br>                InvalidateRect (hWnd, NULL, TRUE); <br>            } <br>            break; <br> <br>        case WM_PAINT: <br>            HandlePaint (hWnd); <br>            break; <br> <br>        case WM_MEASUREITEM: <br>            /* Use the same width for all items. We could examine the item id <br>               and use different widths/heights for each item. */ <br>            ((LPMEASUREITEMSTRUCT)lParam)-&gt;itemWidth  = MEASUREITEMWIDTH; <br>            ((LPMEASUREITEMSTRUCT)lParam)-&gt;itemHeight = MEASUREITEMHEIGHT; <br>            return TRUE; <br> <br>        case WM_DRAWITEM: <br>            /* Redraw the "colors" menu in normal/ownerdrawmode */ <br>            HandleDrawItem (hWnd,(LPDRAWITEMSTRUCT)lParam); <br>            return TRUE; <br>            break; <br> <br>        case WM_CREATE: <br>            /* Create the menu */ <br>            HandleCreate (hWnd); <br>            break; <br> <br>        case WM_DESTROY: <br>            /* Delete the on/off bitmaps so that they don't waste memory. */ <br>            DeleteObject (hbmCheckOn); <br>            DeleteObject (hbmCheckOff); <br> <br>            PostQuitMessage (0); <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            /* Draw the "floating" popup in the app's client area */ <br>            GetClientRect (hWnd, (LPRECT)&amp;rc); <br> <br>            // Temporary porting macro <br>            LONG2POINT(lParam, pt); <br>            if (PtInRect ((LPRECT)&amp;rc, pt)) <br>                HandlePopupMenu (hWnd, pt); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>    } <br>    return(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
