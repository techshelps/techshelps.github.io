<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPSHET.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6566"></a>PROPSHET.CPP</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  MODULE:   propshet.cpp <br>// <br>//  PURPOSE:   Implements the IShellPropSheetExt member functions necessary to  <br>//             support the property sheet page of this shell extension.  This <br>//             page is displayed when the user selects "Properties..." after <br>//             right clicking on a .GAK file <br>// <br> <br>#include "priv.h" <br>#include "shellext.h" <br>#include "resource.h" <br> <br>extern UINT g_cRefThisDll;         // Reference count of this DLL. <br>extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself. <br> <br>// <br>//  FUNCTION: GAKPageCallback(HWND, UINT, LPPROPSHEETPAGE) <br>// <br>//  PURPOSE: Callback  procedure for the property page <br>// <br>//  PARAMETERS: <br>//    hWnd      - Reserved (will always be NULL) <br>//    uMessage  - Action flag: Are we being created or released <br>//    ppsp      - The page that is being created or destroyed <br>// <br>//  RETURN VALUE: <br>// <br>//    Depends on message.  <br>// <br>//    For PSPCB_CREATE it's TRUE to let the page be created <br>//    or false to prevent it from being created.   <br>//    For PSPCB_RELEASE the return value is ignored. <br>// <br>//  COMMENTS: <br>// <br>UINT CALLBACK <br>GAKPageCallback(HWND hWnd, <br>                UINT uMessage, <br>                LPPROPSHEETPAGE  ppsp) <br>{ <br>    switch(uMessage) <br>    { <br>        case PSPCB_CREATE: <br>            return TRUE; <br> <br>        case PSPCB_RELEASE: <br>            if (ppsp-&gt;lParam)  <br>            { <br>               ((LPCSHELLEXT)(ppsp-&gt;lParam))-&gt;Release(); <br>            } <br>            return TRUE;  <br>    } <br>    return TRUE; <br>} <br> <br>// <br>//  FUNCTION: GAKPageDlgProc(HWND, UINT, WPARAM, LPARAM) <br>// <br>//  PURPOSE: Callback dialog procedure for the property page <br>// <br>//  PARAMETERS: <br>//    hDlg      - Dialog box window handle <br>//    uMessage  - current message <br>//    wParam    - depends on message <br>//    lParam    - depends on message <br>// <br>//  RETURN VALUE: <br>// <br>//    Depends on message.  In general, return TRUE if we process it. <br>// <br>//  COMMENTS: <br>// <br> <br>BOOL CALLBACK GAKPageDlgProc(HWND hDlg,  <br>                             UINT uMessage,  <br>                             WPARAM wParam,  <br>                             LPARAM lParam) <br>{ <br>    LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)GetWindowLong(hDlg, DWL_USER); <br>    UINT iIndex=0; <br>    int  iID; <br>    LPCSHELLEXT lpcs; <br> char szTemp[4]; <br> <br>    switch (uMessage) <br>    { <br>        // <br>        // When the shell creates a dialog box for a property sheet page, <br>        // it passes the pointer to the PROPSHEETPAGE data structure as <br>        // lParam. The dialog procedures of extensions typically store it <br>        // in the DWL_USER of the dialog box window. <br>        // <br>        case WM_INITDIALOG: <br>            SetWindowLong(hDlg, DWL_USER, lParam); <br> <br>            psp = (LPPROPSHEETPAGE)lParam; <br> <br>            lpcs = (LPCSHELLEXT)psp-&gt;lParam; <br> <br>if (*(lpcs-&gt;m_szPropSheetFileUserClickedOn)) <br>            iIndex = (UINT)GetPrivateProfileInt("IconImage",  <br>                                            "Index",  <br>                                            0,  <br>                                            lpcs-&gt;m_szPropSheetFileUserClickedOn); <br> <br>            //Note that the following line assumes that IDC_RED, IDC_GREEN, <br>            //and IDC_BLUE are in sequential order, with IDC_RED having the <br>            //smallest value. <br>            SendDlgItemMessage(hDlg, iIndex + IDC_RED, BM_SETCHECK, TRUE, 0L); <br> <br>            break; <br> <br>        case WM_DESTROY: <br>            RemoveProp(hDlg, "ID"); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_RED: <br>                case IDC_GREEN: <br>                case IDC_BLUE: <br>                    SetProp(hDlg, "ID", (HANDLE)lParam); <br>                    break; <br> <br>                default: <br>                    break; <br>            } <br>            break; <br> <br>        case WM_NOTIFY: <br>            switch (((NMHDR FAR *)lParam)-&gt;code) <br>            { <br>                case PSN_SETACTIVE: <br>                    break; <br> <br>                case PSN_APPLY: <br>                    //User has clicked the OK or Apply button so we'll <br>                    //update the icon information in the .GAK file <br>                    lpcs = (LPCSHELLEXT)psp-&gt;lParam; <br>                    iID  = GetDlgCtrlID((HWND)GetProp(hDlg, "ID")); <br>                    iID -= IDC_RED; <br>                    wsprintf(szTemp, "%i", iID); <br>    WritePrivateProfileString("IconImage", <br>                                              "Index", <br>                                               szTemp, <br>                                               lpcs-&gt;m_szPropSheetFileUserClickedOn); <br>                    //Ask the shell to refresh the icon list... <br>                    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_FLUSHNOWAIT, 0, 0); <br>                    break; <br>             <br>                default: <br>                    break; <br>            } <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>// <br>//  FUNCTION: CShellExt::AddPages(LPFNADDPROPSHEETPAGE, LPARAM) <br>// <br>//  PURPOSE: Called by the shell just before the property sheet is displayed. <br>// <br>//  PARAMETERS: <br>//    lpfnAddPage -  Pointer to the Shell's AddPage function <br>//    lParam      -  Passed as second parameter to lpfnAddPage <br>// <br>//  RETURN VALUE: <br>// <br>//    NOERROR in all cases.  If for some reason our pages don't get added, <br>//    the Shell still needs to bring up the Properties... sheet. <br>// <br>//  COMMENTS: <br>// <br> <br>STDMETHODIMP CShellExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam) <br>{ <br>    PROPSHEETPAGE psp; <br>    HPROPSHEETPAGE hpage; <br> <br>    ODS("CShellExt::AddPages()\r\n"); <br> <br>    FORMATETC fmte = {CF_HDROP, <br>                  (DVTARGETDEVICE FAR *)NULL, <br>                  DVASPECT_CONTENT, <br>                  -1, <br>                  TYMED_HGLOBAL  <br>                 }; <br>    STGMEDIUM medium; <br>HRESULT hres = 0; <br> <br>    if (m_pDataObj)  //Paranoid check, m_pDataObj should have something by now... <br>       hres = m_pDataObj-&gt;GetData(&amp;fmte, &amp;medium); <br> <br>    if (SUCCEEDED(hres)) <br>    { <br>        //Find out how many files the user has selected... <br>        UINT cbFiles = 0; <br>        LPCSHELLEXT lpcsext = this; <br> <br>        if (medium.hGlobal) <br>            cbFiles = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, 0, 0); <br> <br>        if (cbFiles &lt; 2) <br>        { <br>            //OK, the user has only selected a single file, so lets go ahead <br>            //and add the property sheet.  Note that it doesn't HAVE to be this <br>            //way, but for simplicity and educational reasons, I'll only add <br>            //the property sheet if a single .GAK file is selected. <br> <br>            //Get the name of the file the user has clicked on <br>if (cbFiles) <br>               DragQueryFile((HDROP)medium.hGlobal,  <br>                             0,  <br>                             m_szPropSheetFileUserClickedOn, <br>                             sizeof(m_szPropSheetFileUserClickedOn)); <br> <br>// <br>// Create a property sheet page object from a dialog box. <br>// <br>// We store a pointer to our class in the psp.lParam, so we <br>            // can access our class members from within the GAKPageDlgProc <br>// <br>// If the page needs more instance data, you can append <br>// arbitrary size of data at the end of this structure, <br>// and pass it to the CreatePropSheetPage. In such a case, <br>// the size of entire data structure (including page specific <br>// data) must be stored in the dwSize field.   Note that in <br>            // general you should NOT need to do this, as you can simply <br>            // store a pointer to date in the lParam member. <br>// <br>         <br>            psp.dwSize      = sizeof(psp);// no extra data. <br>            psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE | PSP_USECALLBACK; <br>            psp.hInstance   = g_hmodThisDll; <br>            psp.pszTemplate = MAKEINTRESOURCE(IDD_GAKPAGE); <br>            psp.hIcon       = 0; <br>            psp.pszTitle    = "GAK Color"; <br>            psp.pfnDlgProc  = GAKPageDlgProc; <br>            psp.pcRefParent = &amp;g_cRefThisDll; <br>            psp.pfnCallback = GAKPageCallback; <br>            psp.lParam      = (LPARAM)lpcsext; <br>             <br>            AddRef(); <br>            hpage = CreatePropertySheetPage(&amp;psp); <br>             <br>            if (hpage)  <br>            { <br>                if (!lpfnAddPage(hpage, lParam))  <br>                { <br>                    DestroyPropertySheetPage(hpage); <br>                    Release(); <br>                } <br>            } <br>        } <br>    } <br> <br>    return NOERROR; <br>} <br> <br>// <br>//  FUNCTION: CShellExt::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM) <br>// <br>//  PURPOSE: Called by the shell only for Control Panel property sheet  <br>//           extensions <br>// <br>//  PARAMETERS: <br>//    uPageID         -  ID of page to be replaced <br>//    lpfnReplaceWith -  Pointer to the Shell's Replace function <br>//    lParam          -  Passed as second parameter to lpfnReplaceWith <br>// <br>//  RETURN VALUE: <br>// <br>//    E_FAIL, since we don't support this function.  It should never be <br>//    called. <br> <br>//  COMMENTS: <br>// <br> <br>STDMETHODIMP CShellExt::ReplacePage(UINT uPageID,  <br>                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith,  <br>                                    LPARAM lParam) <br>{ <br>    ODS("CShellExt::ReplacePage()\r\n"); <br> <br>    return E_FAIL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
