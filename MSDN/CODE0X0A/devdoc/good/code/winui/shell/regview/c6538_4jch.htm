<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PIDLMGR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6551"></a>PIDLMGR.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          PidlMgr.cpp <br>    <br>   Description:   Implements CPidlMgr. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "PidlMgr.h" <br>#include "ShlFldr.h" <br>#include "resource.h" <br> <br>/************************************************************************** <br> <br>   CPidlMgr::CPidlMgr <br> <br>**************************************************************************/ <br> <br>CPidlMgr::CPidlMgr() <br>{ <br>//get the shell's IMalloc pointer <br>//we'll keep this until we get destroyed <br>if(FAILED(SHGetMalloc(&amp;m_pMalloc))) <br>   { <br>   delete this; <br>   } <br> <br>g_DllRefCount++; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::~CPidlMgr <br> <br>**************************************************************************/ <br> <br>CPidlMgr::~CPidlMgr() <br>{ <br>if(m_pMalloc) <br>   m_pMalloc-&gt;Release(); <br> <br>g_DllRefCount--; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::Create(DWORD, LPVOID, DWORD) <br> <br>   Creates a new PIDL <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::Create(PIDLTYPE type, LPVOID pIn, USHORT uInSize) <br>{ <br>LPITEMIDLIST   pidlOut; <br>USHORT         uSize; <br> <br>pidlOut = NULL; <br> <br>/* <br>Calculate the size. This consists of the ITEMIDLIST, the PIDL structure plus  <br>the size of the data. We subtract the size of an HKEY because that is included  <br>in uInSize. <br>*/ <br>uSize = sizeof(ITEMIDLIST) + (sizeof(PIDLDATA) - sizeof(HKEY)) + uInSize; <br> <br>/* <br>Allocate the memory, adding an additional ITEMIDLIST for the NULL terminating  <br>ID List. <br>*/ <br>pidlOut = (LPITEMIDLIST)m_pMalloc-&gt;Alloc(uSize + sizeof(ITEMIDLIST)); <br> <br>if(pidlOut) <br>   { <br>   LPITEMIDLIST   pidlTemp = pidlOut; <br>   LPPIDLDATA     pData; <br> <br>   //set the size of this item <br>   pidlTemp-&gt;mkid.cb = uSize; <br> <br>   //set the data for this item <br>   pData = GetDataPointer(pidlTemp); <br>   pData-&gt;type = type; <br>   switch(type) <br>      { <br>      case PT_ROOTKEY: <br>         pData-&gt;hRootKey = *(HKEY*)pIn; <br>         break; <br> <br>      case PT_SUBKEY: <br>      case PT_VALUE: <br>         CopyMemory(pData-&gt;szText, pIn, uInSize); <br>         break; <br>      } <br>    <br>   //set the NULL terminator to 0 <br>   pidlTemp = GetNextItem(pidlTemp); <br>   pidlTemp-&gt;mkid.cb = 0; <br>   pidlTemp-&gt;mkid.abID[0] = 0; <br>   } <br> <br>return pidlOut; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::Delete(HKEY) <br> <br>   Deletes a PIDL <br>    <br>**************************************************************************/ <br> <br>void CPidlMgr::Delete(LPITEMIDLIST pidl) <br>{ <br>m_pMalloc-&gt;Free(pidl); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::CreateRootKey() <br> <br>   Creates a root key PIDL <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::CreateRootKey(HKEY hKeyRoot) <br>{ <br>return Create(PT_ROOTKEY, (LPVOID)&amp;hKeyRoot, sizeof(hKeyRoot)); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::CreateSubKey() <br> <br>   Creates a sub key PIDL <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::CreateSubKey(LPCTSTR lpszNew) <br>{ <br>return Create(PT_SUBKEY, (LPVOID)lpszNew, (lstrlen(lpszNew) + 1) * sizeof(TCHAR)); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::CreateValue() <br> <br>   Creates a value PIDL <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::CreateValue(LPCTSTR lpszNew) <br>{ <br>return Create(PT_VALUE, (LPVOID)lpszNew, (lstrlen(lpszNew) + 1) * sizeof(TCHAR)); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetNextItem() <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::GetNextItem(LPCITEMIDLIST pidl) <br>{ <br>if(pidl) <br>   return (LPITEMIDLIST)(LPBYTE)(((LPBYTE)pidl) + pidl-&gt;mkid.cb); <br>else <br>   return (NULL); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetSize() <br>    <br>**************************************************************************/ <br> <br>UINT CPidlMgr::GetSize(LPCITEMIDLIST pidl) <br>{ <br>UINT cbTotal = 0; <br>LPITEMIDLIST pidlTemp = (LPITEMIDLIST) pidl; <br> <br>if(pidlTemp) <br>   { <br>   while(pidlTemp-&gt;mkid.cb) <br>      { <br>      cbTotal += pidlTemp-&gt;mkid.cb; <br>      pidlTemp = GetNextItem(pidlTemp); <br>      }   <br> <br>   //add the size of the NULL terminating ITEMIDLIST <br>   cbTotal += sizeof(ITEMIDLIST); <br>   } <br> <br>return (cbTotal); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetData(PIDLTYPE, LPCITEMIDLIST, LPVOID, USHORT) <br>    <br>**************************************************************************/ <br> <br>DWORD CPidlMgr::GetData(PIDLTYPE type, LPCITEMIDLIST pidl, LPVOID pOut, USHORT uOutSize) <br>{ <br>if(!pidl) <br>   return 0; <br> <br>LPPIDLDATA  pData = GetDataPointer(pidl); <br>DWORD       dwReturn = 0; <br> <br>//copy the data <br>switch(type) <br>   { <br>   case PT_ROOTKEY: <br>      if(uOutSize &lt; sizeof(HKEY)) <br>         return 0; <br>       <br>      if(PT_ROOTKEY != pData-&gt;type) <br>         return 0; <br>       <br>      *(HKEY*)pOut = pData-&gt;hRootKey; <br>      dwReturn = sizeof(pData-&gt;hRootKey); <br>      break; <br> <br>   case PT_SUBKEY: <br>   case PT_VALUE: <br>   case PT_TEXT: <br>      *(LPTSTR)pOut = 0; <br>      lstrcpyn((LPTSTR)pOut, pData-&gt;szText, uOutSize); <br>      dwReturn = lstrlen((LPTSTR)pOut); <br>      break; <br>   } <br> <br>return dwReturn; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetRootKey() <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::GetRootKey(LPCITEMIDLIST pidl, HKEY *phKeyRoot) <br>{ <br>return (BOOL)GetData(PT_ROOTKEY, pidl, (LPVOID)phKeyRoot, sizeof(HKEY)); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetLastItem() <br> <br>   Gets the last item in the list <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::GetLastItem(LPCITEMIDLIST pidl) <br>{ <br>LPITEMIDLIST   pidlLast = NULL; <br> <br>//get the PIDL of the last item in the list <br>if(pidl) <br>   { <br>   while(pidl-&gt;mkid.cb) <br>      { <br>      pidlLast = (LPITEMIDLIST)pidl; <br>      pidl = GetNextItem(pidl); <br>      }   <br>   } <br> <br>return pidlLast; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetItemText() <br> <br>   Gets the text for only this item <br>    <br>**************************************************************************/ <br> <br>DWORD CPidlMgr::GetItemText(LPCITEMIDLIST pidl, LPTSTR lpszText, USHORT uSize) <br>{ <br>//if this is a root key, it needs to be handled specially <br>if(IsRootKey(pidl)) <br>   { <br>   HKEY  hKey; <br> <br>   if(!GetRootKey(pidl, &amp;hKey)) <br>      return 0; <br> <br>   return GetRootKeyText(hKey, lpszText, uSize); <br>   } <br> <br>return GetData(PT_TEXT, pidl, (LPVOID)lpszText, uSize); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetSubKeyText() <br> <br>   Creates a sub key string from a PIDL, filtering out the root key and  <br>   value, if either is present. <br>    <br>**************************************************************************/ <br> <br>DWORD CPidlMgr::GetSubKeyText(LPCITEMIDLIST pidl, LPTSTR lpszSubKey, DWORD dwSize) <br>{ <br>if(!pidl) <br>   return 0; <br> <br>LPITEMIDLIST   pidlTemp; <br>DWORD          dwCopied = 0; <br> <br>/* <br>This may be a list of items, so if the first item is a key rather than a  <br>string, skip the first item because it contains the root key. <br>*/ <br>if(IsRootKey(pidl)) <br>   pidlTemp = GetNextItem(pidl); <br>else <br>   pidlTemp = (LPITEMIDLIST)pidl; <br> <br>//if this is NULL, return the required size of the buffer <br>if(!lpszSubKey) <br>   { <br>   while(pidlTemp-&gt;mkid.cb) <br>      { <br>      LPPIDLDATA  pData = GetDataPointer(pidlTemp); <br>       <br>      //add the length of this item plus one for the backslash <br>      dwCopied += lstrlen(pData-&gt;szText) + 1; <br> <br>      pidlTemp = GetNextItem(pidlTemp); <br>      } <br> <br>   //add one for the NULL terminator <br>   return dwCopied + 1; <br>   } <br> <br>*lpszSubKey = 0; <br> <br>while(pidlTemp-&gt;mkid.cb &amp;&amp; (dwCopied &lt; dwSize)) <br>   { <br>   LPPIDLDATA  pData = GetDataPointer(pidlTemp); <br> <br>   //if this item is a value, then skip it and finish <br>   if(PT_VALUE == pData-&gt;type) <br>      break; <br>    <br>   lstrcat(lpszSubKey, pData-&gt;szText); <br>   lstrcat(lpszSubKey, TEXT("\\")); <br> <br>   dwCopied += lstrlen(pData-&gt;szText) + 1; <br> <br>   pidlTemp = GetNextItem(pidlTemp); <br>   } <br> <br>//remove the last backslash if necessary <br>if(dwCopied) <br>   { <br>   if(*(lpszSubKey + lstrlen(lpszSubKey) - 1) == '\\') <br>      { <br>      *(lpszSubKey + lstrlen(lpszSubKey) - 1) = 0; <br>      dwCopied--; <br>      } <br>   } <br> <br>return dwCopied; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetValueText() <br> <br>   Gets the text for the last item in the list <br>    <br>**************************************************************************/ <br> <br>DWORD CPidlMgr::GetValueText(LPCITEMIDLIST pidl, LPTSTR lpszValue, DWORD dwSize) <br>{ <br>if(!pidl) <br>   return 0; <br> <br>LPCITEMIDLIST  pidlTemp = pidl; <br>TCHAR          szText[MAX_PATH]; <br> <br>/* <br>This may be a list of items, so search through the list looking for an item  <br>that is a value. There should be only one, and it should be the last one, but  <br>we will assume it can be anywhere and only copy the first one. <br>*/ <br>while(pidlTemp-&gt;mkid.cb &amp;&amp; !IsValue(pidlTemp)) <br>   { <br>   pidlTemp = GetNextItem(pidlTemp); <br>   } <br> <br>//we didn't find a value pidl <br>if(!pidlTemp-&gt;mkid.cb) <br>   return 0; <br> <br>//get the item's text <br>GetItemText(pidlTemp, szText, sizeof(szText)); <br> <br>//if this is NULL, return the required size of the buffer <br>if(!lpszValue) <br>   { <br>   return lstrlen(szText) + 1; <br>   } <br> <br>lstrcpy(lpszValue, szText); <br> <br>return lstrlen(lpszValue); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::Copy() <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::Copy(LPCITEMIDLIST pidlSource) <br>{ <br>LPITEMIDLIST pidlTarget = NULL; <br>UINT cbSource = 0; <br> <br>if(NULL == pidlSource) <br>   return (NULL); <br> <br>// Allocate the new pidl <br>cbSource = GetSize(pidlSource); <br>pidlTarget = (LPITEMIDLIST)m_pMalloc-&gt;Alloc(cbSource); <br>if(!pidlTarget) <br>   return (NULL); <br> <br>// Copy the source to the target <br>CopyMemory(pidlTarget, pidlSource, cbSource); <br> <br>return pidlTarget; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::IsRootKey() <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::IsRootKey(LPCITEMIDLIST pidl) <br>{ <br>LPPIDLDATA  pData = GetDataPointer(pidl); <br> <br>return (PT_ROOTKEY == pData-&gt;type); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::IsSubKey() <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::IsSubKey(LPCITEMIDLIST pidl) <br>{ <br>LPPIDLDATA  pData = GetDataPointer(pidl); <br> <br>return (PT_SUBKEY == pData-&gt;type); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::IsValue() <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::IsValue(LPCITEMIDLIST pidl) <br>{ <br>LPPIDLDATA  pData = GetDataPointer(pidl); <br> <br>return (PT_VALUE == pData-&gt;type); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::HasSubKeys() <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::HasSubKeys(HKEY hKeyRoot, LPCTSTR pszSubKey, LPCITEMIDLIST pidl) <br>{ <br>HKEY     hKey; <br>LONG     lResult = !ERROR_SUCCESS; <br>FILETIME ft; <br>LPTSTR   lpszTemp; <br> <br>if(!pszSubKey) <br>   pszSubKey = TEXT(""); <br> <br>if(!hKeyRoot) <br>   GetRootKey(pidl, &amp;hKeyRoot); <br> <br>DWORD dwSize = GetSubKeyText(pidl, NULL, 0) + lstrlen(pszSubKey) + 2; <br> <br>lpszTemp = new TCHAR[dwSize]; <br>if(!lpszTemp) <br>   return FALSE; <br> <br>lstrcpy(lpszTemp, pszSubKey); <br>if(*lpszTemp) <br>   lstrcat(lpszTemp, TEXT("\\")); <br>GetSubKeyText(pidl, lpszTemp + lstrlen(lpszTemp), dwSize - lstrlen(lpszTemp)); <br> <br>//open the specified key <br>lResult = RegOpenKeyEx( hKeyRoot, <br>                        lpszTemp, <br>                        0, <br>                        KEY_ENUMERATE_SUB_KEYS, <br>                        &amp;hKey); <br> <br>if(ERROR_SUCCESS == lResult) <br>   { <br>   TCHAR szTemp[MAX_PATH]; <br>   DWORD dwSize = sizeof(szTemp); <br> <br>   //try to get the specified subkey <br>   lResult = RegEnumKeyEx( hKey, <br>                           0, <br>                           szTemp, <br>                           &amp;dwSize, <br>                           NULL, <br>                           NULL, <br>                           NULL, <br>                           &amp;ft); <br> <br>   RegCloseKey(hKey); <br>   } <br> <br>delete lpszTemp; <br> <br>return (BOOL)(ERROR_SUCCESS == lResult); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetDataPointer() <br>    <br>**************************************************************************/ <br> <br>LPPIDLDATA CPidlMgr::GetDataPointer(LPCITEMIDLIST pidl) <br>{ <br>if(!pidl) <br>   return NULL; <br> <br>return (LPPIDLDATA)(pidl-&gt;mkid.abID); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetValueType() <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::GetValueType(  LPCITEMIDLIST pidlFQ,  <br>                              LPDWORD pdwType) <br>{ <br>BOOL  bReturn; <br>LPITEMIDLIST   pidlKey; <br>LPITEMIDLIST   pidlValue; <br> <br>if(!SeparateKeyAndValue(pidlFQ, &amp;pidlKey, &amp;pidlValue)) <br>   return 0; <br> <br>bReturn = GetValueType(pidlKey, pidlValue, pdwType); <br> <br>Delete(pidlKey); <br>Delete(pidlValue); <br> <br>return bReturn; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetValueType() <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::GetValueType(  LPCITEMIDLIST pidlKey,  <br>                              LPCITEMIDLIST pidlValue,  <br>                              LPDWORD pdwType) <br>{ <br>if(!pidlKey) <br>   return FALSE; <br> <br>if(!pidlValue) <br>   return FALSE; <br> <br>if(!pdwType) <br>   return FALSE; <br> <br>HKEY     hKey, <br>         hRootKey; <br>LPTSTR   lpszSubKey, <br>         lpszValueName; <br>DWORD    dwNameSize; <br>LONG     lResult; <br> <br>//get the root key <br>GetRootKey(pidlKey, &amp;hRootKey); <br> <br>//assemble the key string <br>dwNameSize = GetSubKeyText(pidlKey, NULL, 0); <br>lpszSubKey = new TCHAR[dwNameSize]; <br>if(!lpszSubKey) <br>   return FALSE; <br>GetSubKeyText(pidlKey, lpszSubKey, dwNameSize); <br> <br>//assemble the value name <br>dwNameSize = GetValueText(pidlValue, NULL, 0); <br>lpszValueName = new TCHAR[dwNameSize]; <br>if(!lpszValueName) <br>   { <br>   delete lpszSubKey; <br>   return FALSE; <br>   } <br>GetValueText(pidlValue, lpszValueName, dwNameSize); <br> <br>//open the key <br>lResult = RegOpenKeyEx( hRootKey, <br>                        lpszSubKey, <br>                        0, <br>                        KEY_QUERY_VALUE, <br>                        &amp;hKey); <br> <br>if(ERROR_SUCCESS != lResult) <br>   return FALSE; <br> <br>//get the value type <br>lResult = RegQueryValueEx( hKey, <br>                           lpszValueName, <br>                           NULL, <br>                           pdwType, <br>                           NULL, <br>                           NULL); <br> <br>RegCloseKey(hKey); <br> <br>delete lpszSubKey; <br> <br>delete lpszValueName; <br> <br>return TRUE; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetDataText() <br>    <br>**************************************************************************/ <br> <br>DWORD CPidlMgr::GetDataText(  LPCITEMIDLIST pidlFQ,  <br>                              LPTSTR lpszOut,  <br>                              DWORD dwOutSize) <br>{ <br>DWORD dwReturn; <br>LPITEMIDLIST   pidlKey; <br>LPITEMIDLIST   pidlValue; <br> <br>if(!SeparateKeyAndValue(pidlFQ, &amp;pidlKey, &amp;pidlValue)) <br>   return 0; <br> <br>dwReturn = GetDataText(pidlKey, pidlValue, lpszOut, dwOutSize); <br> <br>Delete(pidlKey); <br>Delete(pidlValue); <br> <br>return dwReturn; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetDataText() <br>    <br>**************************************************************************/ <br> <br>DWORD CPidlMgr::GetDataText(  LPCITEMIDLIST pidlKey,  <br>                              LPCITEMIDLIST pidlValue,  <br>                              LPTSTR lpszOut,  <br>                              DWORD dwOutSize) <br>{ <br>HKEY     hKey, <br>         hRootKey; <br>LPTSTR   lpszSubKey, <br>         lpszValueName; <br>DWORD    dwNameSize, <br>         dwType, <br>         dwSize, <br>         dwReturn = 0; <br>LONG     lResult; <br>TCHAR    szData[MAX_PATH]; <br> <br>if(!lpszOut) <br>   return dwReturn; <br> <br>if(!pidlKey) <br>   return dwReturn; <br> <br>if(!pidlValue) <br>   return dwReturn; <br> <br>//get the root key <br>GetRootKey(pidlKey, &amp;hRootKey); <br> <br>//assemble the key string <br>dwNameSize = GetSubKeyText(pidlKey, NULL, 0); <br>lpszSubKey = new TCHAR[dwNameSize]; <br>if(!lpszSubKey) <br>   return dwReturn; <br>GetSubKeyText(pidlKey, lpszSubKey, dwNameSize); <br> <br>//assemble the value name <br>dwNameSize = GetValueText(pidlValue, NULL, 0); <br>lpszValueName = new TCHAR[dwNameSize]; <br>if(!lpszValueName) <br>   { <br>   delete lpszSubKey; <br>   return dwReturn; <br>   } <br>GetValueText(pidlValue, lpszValueName, dwNameSize); <br> <br>//open the key <br>lResult = RegOpenKeyEx( hRootKey, <br>                        lpszSubKey, <br>                        0, <br>                        KEY_QUERY_VALUE, <br>                        &amp;hKey); <br> <br>if(ERROR_SUCCESS != lResult) <br>   return 0; <br> <br>//get the value <br>dwSize = sizeof(szData); <br>lResult = RegQueryValueEx( hKey, <br>                           lpszValueName, <br>                           NULL, <br>                           &amp;dwType, <br>                           (LPBYTE)szData, <br>                           &amp;dwSize); <br> <br>/* <br>If this fails, then there is no default value set, so go ahead and add the  <br>empty default value. <br>*/ <br>if(ERROR_SUCCESS == lResult) <br>   { <br>   //format the data <br>   switch(dwType) <br>      { <br>      case REG_BINARY: <br>      case REG_DWORD: <br>      case REG_DWORD_BIG_ENDIAN: <br>         { <br>         LPTSTR   lpszBuffer, <br>                  lpszTemp; <br>         LPBYTE   pData = (LPBYTE)szData; <br>                   <br>         lpszBuffer = lpszTemp = new TCHAR[dwSize * sizeof(TCHAR) * 3 + sizeof(TCHAR)]; <br> <br>         if(lpszTemp) <br>            { <br>            DWORD dwTemp; <br> <br>            for(dwTemp = 0; dwTemp &lt; dwSize; dwTemp++) <br>               { <br>               wsprintf(lpszTemp, TEXT("%02x"), *(pData + dwTemp)); <br>               lstrcat(lpszTemp, TEXT(" ")); <br>               lpszTemp = lpszBuffer + lstrlen(lpszBuffer); <br>               } <br> <br>            lstrcpyn(lpszOut, lpszBuffer, dwOutSize); <br>             <br>            delete lpszBuffer; <br>            } <br>         } <br>         break; <br> <br>      default: <br>         lstrcpyn(lpszOut, szData, dwOutSize); <br>         break; <br>      } <br>   dwReturn = lstrlen(lpszOut); <br>   } <br> <br>RegCloseKey(hKey); <br> <br>delete lpszSubKey; <br> <br>delete lpszValueName; <br> <br>return dwReturn; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::GetPidlPath() <br> <br>   Create a string that includes the root key name, the sub key text and  <br>   the value text. <br>    <br>**************************************************************************/ <br> <br>DWORD CPidlMgr::GetPidlPath(LPCITEMIDLIST pidl, LPTSTR lpszOut, DWORD dwOutSize) <br>{ <br>LPTSTR   lpszTemp; <br> <br>if(!lpszOut) <br>   return 0; <br> <br>*lpszOut = 0; <br>lpszTemp = lpszOut; <br> <br>//add the root key text if necessary <br>if(IsRootKey(pidl)) <br>   { <br>   HKEY  hKey; <br> <br>   GetRootKey(pidl, &amp;hKey); <br>   dwOutSize -= GetRootKeyText(hKey, lpszOut, dwOutSize); <br>   } <br> <br>//add a backslash if necessary <br>if(*lpszOut &amp;&amp; (*(lpszOut + lstrlen(lpszOut) - 1) != '\\')) <br>   lstrcat(lpszOut, TEXT("\\")); <br> <br>lpszTemp = lpszOut + lstrlen(lpszOut); <br> <br>//add the subkey string <br>dwOutSize -= GetSubKeyText(pidl, lpszTemp, dwOutSize); <br> <br>//add a backslash if necessary <br>if(*lpszOut &amp;&amp; (*(lpszOut + lstrlen(lpszOut) - 1) != '\\')) <br>   lstrcat(lpszOut, TEXT("\\")); <br> <br>lpszTemp = lpszOut + lstrlen(lpszOut); <br> <br>//add the value string <br>GetValueText(pidl, lpszTemp, dwOutSize); <br> <br>//remove the last backslash if necessary <br>if(*(lpszOut + lstrlen(lpszOut) - 1) == '\\') <br>   { <br>   *(lpszOut + lstrlen(lpszOut) - 1) = 0; <br>   } <br> <br>return lstrlen(lpszOut); <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::Concatenate() <br> <br>   Create a new PIDL by combining two existing PIDLs. <br>    <br>**************************************************************************/ <br> <br>LPITEMIDLIST CPidlMgr::Concatenate(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) <br>{ <br>LPITEMIDLIST   pidlNew; <br>UINT           cb1 = 0,  <br>               cb2 = 0; <br> <br>//are both of these NULL? <br>if(!pidl1 &amp;&amp; !pidl2) <br>   return NULL; <br> <br>//if pidl1 is NULL, just return a copy of pidl2 <br>if(!pidl1) <br>   { <br>   pidlNew = Copy(pidl2); <br> <br>   return pidlNew; <br>   } <br> <br>//if pidl2 is NULL, just return a copy of pidl1 <br>if(!pidl2) <br>   { <br>   pidlNew = Copy(pidl1); <br> <br>   return pidlNew; <br>   } <br> <br>cb1 = GetSize(pidl1) - sizeof(ITEMIDLIST); <br> <br>cb2 = GetSize(pidl2); <br> <br>//create the new PIDL <br>pidlNew = (LPITEMIDLIST)m_pMalloc-&gt;Alloc(cb1 + cb2); <br> <br>if(pidlNew) <br>   { <br>   //copy the first PIDL <br>   CopyMemory(pidlNew, pidl1, cb1); <br>    <br>   //copy the second PIDL <br>   CopyMemory(((LPBYTE)pidlNew) + cb1, pidl2, cb2); <br>   } <br> <br>return pidlNew; <br>} <br> <br>/************************************************************************** <br> <br>   CPidlMgr::SeparateKeyAndValue() <br> <br>   Creates a separate key and value PIDL from a fully qualified PIDL. <br>    <br>**************************************************************************/ <br> <br>BOOL CPidlMgr::SeparateKeyAndValue( LPCITEMIDLIST pidlFQ,  <br>                                    LPITEMIDLIST *ppidlKey,  <br>                                    LPITEMIDLIST*ppidlValue) <br>{ <br>if(!pidlFQ) <br>   return FALSE; <br> <br>*ppidlValue = GetLastItem(pidlFQ); <br>if(!IsValue(*ppidlValue)) <br>   return FALSE; <br> <br>//make a copy of the value pidl <br>*ppidlValue = Copy(*ppidlValue); <br> <br>//make a copy of the fully qualified PIDL <br>*ppidlKey = Copy(pidlFQ); <br> <br>//truncate the last item of the key PIDL <br>LPITEMIDLIST   pidlTemp = GetLastItem(*ppidlKey); <br>pidlTemp-&gt;mkid.cb = 0; <br>pidlTemp-&gt;mkid.abID[0] = 0; <br> <br>return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
