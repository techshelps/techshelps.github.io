<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMIDL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6544"></a>ENUMIDL.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          EnumIDL.cpp <br>    <br>   Description:   Implements IEnumIDList. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "EnumIDL.h" <br>#include "ShlFldr.h" <br> <br>/************************************************************************** <br> <br>   CEnumIDList::CEnumIDList <br> <br>**************************************************************************/ <br> <br>CEnumIDList::CEnumIDList(HKEY hKeyRoot, LPCTSTR lpszSubKey, DWORD dwFlags, HRESULT *pResult) <br>{ <br>if(pResult) <br>   *pResult = S_OK; <br> <br>m_pFirst = m_pLast = m_pCurrent = NULL; <br> <br>m_pPidlMgr = new CPidlMgr(); <br>if(!m_pPidlMgr) <br>   { <br>   if(pResult) <br>      *pResult = E_OUTOFMEMORY; <br> <br>   delete this; <br>   return; <br>   } <br> <br>//get the shell's IMalloc pointer <br>//we'll keep this until we get destroyed <br>if(FAILED(SHGetMalloc(&amp;m_pMalloc))) <br>   { <br>   if(pResult) <br>      *pResult = E_OUTOFMEMORY; <br> <br>   delete this; <br>   return; <br>   } <br> <br>if(!CreateEnumList(hKeyRoot, lpszSubKey, dwFlags)) <br>   { <br>   if(pResult) <br>      *pResult = E_OUTOFMEMORY; <br> <br>   delete this; <br>   return; <br>   } <br> <br>m_ObjRefCount = 1; <br> <br>g_DllRefCount++; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::~CEnumIDList <br> <br>**************************************************************************/ <br> <br>CEnumIDList::~CEnumIDList() <br>{ <br>DeleteList(); <br> <br>if(m_pMalloc) <br>   m_pMalloc-&gt;Release(); <br> <br>if(m_pPidlMgr) <br>   delete m_pPidlMgr; <br> <br>g_DllRefCount--; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::QueryInterface <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP CEnumIDList::QueryInterface(REFIID riid, LPVOID *ppReturn) <br>{ <br>*ppReturn = NULL; <br> <br>//IUnknown <br>if(IsEqualIID(riid, IID_IUnknown)) <br>   { <br>   *ppReturn = this; <br>   } <br>    <br>//IEnumIDList <br>else if(IsEqualIID(riid, IID_IEnumIDList)) <br>   { <br>   *ppReturn = (IEnumIDList*)this; <br>   }    <br> <br>if(*ppReturn) <br>   { <br>   (*(LPUNKNOWN*)ppReturn)-&gt;AddRef(); <br>   return S_OK; <br>   } <br> <br>return E_NOINTERFACE; <br>}                                              <br> <br>/************************************************************************** <br> <br>   CEnumIDList::AddRef <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CEnumIDList::AddRef() <br>{ <br>return ++m_ObjRefCount; <br>} <br> <br> <br>/************************************************************************** <br> <br>   CEnumIDList::Release <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CEnumIDList::Release() <br>{ <br>if(--m_ObjRefCount == 0) <br>   { <br>   delete this; <br>   return 0; <br>   } <br>    <br>return m_ObjRefCount; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::Next() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CEnumIDList::Next(DWORD dwElements, LPITEMIDLIST apidl[], LPDWORD pdwFetched) <br>{ <br>DWORD    dwIndex; <br>HRESULT  hr = S_OK; <br> <br>if(dwElements &gt; 1 &amp;&amp; !pdwFetched) <br>   return E_INVALIDARG; <br> <br>for(dwIndex = 0; dwIndex &lt; dwElements; dwIndex++) <br>   { <br>   //is this the last item in the list? <br>   if(!m_pCurrent) <br>      { <br>      hr =  S_FALSE; <br>      break; <br>      } <br> <br>   apidl[dwIndex] = m_pPidlMgr-&gt;Copy(m_pCurrent-&gt;pidl); <br> <br>   m_pCurrent = m_pCurrent-&gt;pNext; <br>   } <br> <br>if(pdwFetched) <br>   *pdwFetched = dwIndex; <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::Skip() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CEnumIDList::Skip(DWORD dwSkip) <br>{ <br>DWORD    dwIndex; <br>HRESULT  hr = S_OK; <br> <br>for(dwIndex = 0; dwIndex &lt; dwSkip; dwIndex++) <br>   { <br>   //is this the last item in the list? <br>   if(!m_pCurrent) <br>      { <br>      hr = S_FALSE; <br>      break; <br>      } <br> <br>   m_pCurrent = m_pCurrent-&gt;pNext; <br>   } <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::Reset() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CEnumIDList::Reset(void) <br>{ <br>m_pCurrent = m_pFirst; <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::Clone() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CEnumIDList::Clone(LPENUMIDLIST *ppEnum) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::CreateEnumList() <br>    <br>**************************************************************************/ <br> <br>BOOL CEnumIDList::CreateEnumList(HKEY hKeyRoot, LPCTSTR lpszSubKey, DWORD dwFlags) <br>{ <br>LPITEMIDLIST   pidl; <br>DWORD          dwIndex; <br> <br>//enumerate the folders (keys) <br>if(dwFlags &amp; SHCONTF_FOLDERS) <br>   { <br>   /* <br>   special case - we can't enumerate the root level keys (HKEY_CLASSES_ROOT, etc.),  <br>   so if both of these are NULL, then we need to fake an enumeration of those. <br>   */ <br>   if((!hKeyRoot) &amp;&amp; (!lpszSubKey)) <br>      { <br>      HKEY  ahKey[] = { HKEY_CLASSES_ROOT, <br>                        HKEY_CURRENT_USER, <br>                        HKEY_LOCAL_MACHINE, <br>                        HKEY_USERS, <br>                        HKEY_PERFORMANCE_DATA, <br>                        HKEY_CURRENT_CONFIG, <br>                        HKEY_DYN_DATA, <br>                        (HKEY)-1}; <br>       <br>      for(dwIndex = 0; ahKey[dwIndex] != (HKEY)-1; dwIndex++) <br>         { <br>         //only add the root keys that actually exists on this system <br>         if(RootKeyExists(ahKey[dwIndex])) <br>            { <br>            //create the pidl for this item <br>            pidl = m_pPidlMgr-&gt;CreateRootKey(ahKey[dwIndex]); <br>            if(pidl) <br>               { <br>               if(!AddToEnumList(pidl)) <br>                  return FALSE; <br>               } <br>            else <br>               { <br>               return FALSE; <br>               } <br>            }    <br>         } <br>      } <br>   else <br>      { <br>      TCHAR    szKey[REGSTR_MAX_VALUE_LENGTH]; <br> <br>      dwIndex = 0; <br> <br>      //get the next item <br>      while(GetKeyName(hKeyRoot, lpszSubKey, dwIndex++, szKey, sizeof(szKey))) <br>         { <br>         //create the pidl for this item <br>         pidl = m_pPidlMgr-&gt;CreateSubKey(szKey); <br>         if(pidl) <br>            { <br>            if(!AddToEnumList(pidl)) <br>               return FALSE; <br>            } <br>         else <br>            { <br>            return FALSE; <br>            }    <br>         } <br>      } <br>   }    <br> <br>//enumerate the non-folder items (values) <br>if(dwFlags &amp; SHCONTF_NONFOLDERS) <br>   { <br>   TCHAR    szValue[REGSTR_MAX_VALUE_LENGTH]; <br> <br>   dwIndex = 0; <br> <br>   /* <br>   There is a special case here. All keys have a default value, but if the  <br>   default value is empty, then it won't be enumerated. If it has data, then  <br>   it will be enumerated but the name will be NULL.  <br>    <br>   To work around this, we will add a default item here and then not add it  <br>   if it shows up in the enumeration in the loop below. <br>   */ <br>   //create the default item <br>   pidl = m_pPidlMgr-&gt;CreateValue(TEXT("")); <br>   if(pidl) <br>      { <br>      if(!AddToEnumList(pidl)) <br>         return FALSE; <br>      } <br>   else <br>      { <br>      return FALSE; <br>      }    <br>    <br>   //get the items <br>   while(GetValueName(hKeyRoot, lpszSubKey, dwIndex++, szValue, sizeof(szValue))) <br>      { <br>      //don't add a default value that may have shown up in the enumeration <br>      if(!szValue[0]) <br>         continue; <br> <br>      //create the pidl for this item <br>      pidl = m_pPidlMgr-&gt;CreateValue(szValue); <br> <br>      if(pidl) <br>         { <br>         if(!AddToEnumList(pidl)) <br>            return FALSE; <br>         } <br>      else <br>         { <br>         return FALSE; <br>         }    <br>      } <br>   } <br>    <br>return TRUE; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::AddToEnumList() <br>    <br>**************************************************************************/ <br> <br>BOOL CEnumIDList::AddToEnumList(LPITEMIDLIST pidl) <br>{ <br>LPENUMLIST  pNew; <br> <br>pNew = (LPENUMLIST)m_pMalloc-&gt;Alloc(sizeof(ENUMLIST)); <br> <br>if(pNew) <br>   { <br>   //set the next pointer <br>   pNew-&gt;pNext = NULL; <br>   pNew-&gt;pidl = pidl; <br> <br>   //is this the first item in the list? <br>   if(!m_pFirst) <br>      { <br>      m_pFirst = pNew; <br>      m_pCurrent = m_pFirst; <br>      } <br>    <br>   if(m_pLast) <br>      { <br>      //add the new item to the end of the list <br>      m_pLast-&gt;pNext = pNew; <br>      } <br>    <br>   //update the last item pointer <br>   m_pLast = pNew; <br> <br>   return TRUE; <br>   } <br> <br>return FALSE; <br>} <br> <br>/************************************************************************** <br> <br>   CEnumIDList::DeleteList() <br>    <br>**************************************************************************/ <br> <br>BOOL CEnumIDList::DeleteList(void) <br>{ <br>LPENUMLIST  pDelete; <br> <br>while(m_pFirst) <br>   { <br>   pDelete = m_pFirst; <br>   m_pFirst = pDelete-&gt;pNext; <br> <br>   //free the pidl <br>   //m_pMalloc-&gt;Free(pDelete-&gt;pidl); <br>   m_pPidlMgr-&gt;Delete(pDelete-&gt;pidl); <br>    <br>   //free the list item <br>   m_pMalloc-&gt;Free(pDelete); <br>   } <br> <br>m_pFirst = m_pLast = m_pCurrent = NULL; <br> <br>return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
