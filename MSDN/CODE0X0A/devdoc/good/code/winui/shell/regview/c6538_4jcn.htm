<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SHLVIEW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6557"></a>SHLVIEW.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          ShlView.cpp <br>    <br>   Description:   Implements IShellView. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "ShlView.h" <br>#include "Guid.h" <br>#include "resource.h" <br>#include "tools.h" <br> <br>#define TOOLBAR_ID   (L"RegView") <br> <br>MYTOOLINFO g_Tools[] =  <br>   { <br>   IDM_VIEW_KEYS, 0, IDS_TB_VIEW_KEYS, IDS_MI_VIEW_KEYS, 0, TBSTATE_ENABLED,  TBSTYLE_BUTTON, <br>   IDM_VIEW_IDW,  0, IDS_TB_VIEW_IDW,  IDS_MI_VIEW_IDW,  0, TBSTATE_ENABLED,  TBSTYLE_BUTTON, <br>   -1, 0, 0, 0, 0, <br>   }; <br> <br>/************************************************************************** <br> <br>   CShellView::CShellView() <br> <br>**************************************************************************/ <br> <br>CShellView::CShellView(CShellFolder *pFolder, LPCITEMIDLIST pidl) <br>{ <br>#ifdef INITCOMMONCONTROLSEX <br> <br>INITCOMMONCONTROLSEX iccex; <br>iccex.dwSize = sizeof(INITCOMMONCONTROLSEX); <br>iccex.dwICC = ICC_LISTVIEW_CLASSES; <br>InitCommonControlsEx(&amp;iccex); <br> <br>#else <br> <br>InitCommonControls(); <br> <br>#endif   //INITCOMMONCONTROLSEX <br> <br>m_hMenu = NULL; <br>m_pDockingWindow = NULL; <br> <br>m_pPidlMgr = new CPidlMgr(); <br>if(!m_pPidlMgr) <br>   { <br>   delete this; <br>   return; <br>   } <br> <br>m_pSFParent = pFolder; <br>if(m_pSFParent) <br>   m_pSFParent-&gt;AddRef(); <br> <br>//get the shell's IMalloc pointer <br>//we'll keep this until we get destroyed <br>if(FAILED(SHGetMalloc(&amp;m_pMalloc))) <br>   { <br>   delete this; <br>   return; <br>   } <br> <br>m_pidl = m_pPidlMgr-&gt;Copy(pidl); <br> <br>m_uState = SVUIA_DEACTIVATE; <br> <br>m_ObjRefCount = 1; <br>g_DllRefCount++; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::~CShellView() <br> <br>**************************************************************************/ <br> <br>CShellView::~CShellView() <br>{ <br>if(m_pidl) <br>   { <br>   m_pPidlMgr-&gt;Delete(m_pidl); <br>   m_pidl = NULL; <br>   } <br> <br>if(m_pSFParent) <br>   m_pSFParent-&gt;Release(); <br> <br>if(m_pMalloc) <br>   { <br>   m_pMalloc-&gt;Release(); <br>   } <br> <br>if(m_pPidlMgr) <br>   { <br>   delete m_pPidlMgr; <br>   } <br> <br>g_DllRefCount--; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IUnknown Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellView::QueryInterface <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::QueryInterface(REFIID riid, LPVOID *ppReturn) <br>{ <br>*ppReturn = NULL; <br> <br>//IUnknown <br>if(IsEqualIID(riid, IID_IUnknown)) <br>   { <br>   *ppReturn = this; <br>   } <br> <br>//IOleWindow <br>else if(IsEqualIID(riid, IID_IOleWindow)) <br>   { <br>   *ppReturn = (IOleWindow*)this; <br>   } <br> <br>//IShellView <br>else if(IsEqualIID(riid, IID_IShellView)) <br>   { <br>   *ppReturn = (IShellView*)this; <br>   }    <br> <br>//IOleCommandTarget <br>else if(IsEqualIID(riid, IID_IOleCommandTarget)) <br>   { <br>   *ppReturn = (IOleCommandTarget*)this; <br>   }    <br> <br>if(*ppReturn) <br>   { <br>   (*(LPUNKNOWN*)ppReturn)-&gt;AddRef(); <br>   return S_OK; <br>   } <br> <br>return E_NOINTERFACE; <br>}                                              <br> <br>/************************************************************************** <br> <br>   CShellView::AddRef <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CShellView::AddRef() <br>{ <br>return ++m_ObjRefCount; <br>} <br> <br> <br>/************************************************************************** <br> <br>   CShellView::Release <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CShellView::Release() <br>{ <br>if(--m_ObjRefCount == 0) <br>   { <br>   delete this; <br>   return 0; <br>   } <br>    <br>return m_ObjRefCount; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IOleWindow Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellView::GetWindow() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::GetWindow(HWND *phWnd) <br>{ <br>*phWnd = m_hWnd; <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::ContextSensitiveHelp() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::ContextSensitiveHelp(BOOL fEnterMode) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IOleCommandTarget Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellView::QueryStatus() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::QueryStatus(  const GUID *pguidCmdGroup,  <br>                                       ULONG cCmds,  <br>                                       OLECMD prgCmds[],  <br>                                       OLECMDTEXT *pCmdText) <br>{ <br>ULONG i; <br> <br>//only process the commands for our command group <br>if(pguidCmdGroup &amp;&amp; (*pguidCmdGroup != CLSID_CmdGrp)) <br>   return OLECMDERR_E_UNKNOWNGROUP; <br> <br>//make sure prgCmds is not NULL <br>if(!prgCmds) <br>   return E_POINTER; <br> <br>//run through all of the commands and supply the correct information <br>for(i = 0; i &lt; cCmds;i++) <br>   { <br>   switch(prgCmds[i].cmdID) <br>      { <br>      case IDM_VIEW_KEYS: <br>         prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED; <br>         break; <br>      } <br>   } <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::Exec() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::Exec(   const GUID *pguidCmdGroup,  <br>                                 DWORD nCmdID,  <br>                                 DWORD nCmdExecOpt,  <br>                                 VARIANTARG *pvaIn,  <br>                                 VARIANTARG *pvaOut) <br>{ <br>//only process the commands for our command group <br>if(pguidCmdGroup &amp;&amp; (*pguidCmdGroup == CLSID_CmdGrp)) <br>   { <br>   OnCommand(nCmdID, 0, NULL); <br>   return S_OK; <br>   } <br> <br>return OLECMDERR_E_UNKNOWNGROUP; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IShellView Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellView::TranslateAccelerator() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::TranslateAccelerator(LPMSG pMsg) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::EnableModeless() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::EnableModeless(BOOL fEnable) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnActivate() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::OnActivate(UINT uState) <br>{ <br>//don't do anything if the state isn't really changing <br>if(m_uState == uState) <br>   return S_OK; <br> <br>OnDeactivate(); <br> <br>//only do this if we are active <br>if(uState != SVUIA_DEACTIVATE) <br>   { <br>   //merge the menus <br>   m_hMenu = CreateMenu(); <br>    <br>   if(m_hMenu) <br>      { <br>   OLEMENUGROUPWIDTHS   omw = {0, 0, 0, 0, 0, 0}; <br>      MENUITEMINFO         mii; <br>      TCHAR                szText[MAX_PATH]; <br> <br>      m_pShellBrowser-&gt;InsertMenusSB(m_hMenu, &amp;omw); <br> <br>      //build the top level menu <br>      //get the menu item's text <br>      LoadString(g_hInst, IDS_MI_REGISTRY, szText, sizeof(szText)); <br>       <br>      ZeroMemory(&amp;mii, sizeof(mii)); <br>      mii.cbSize = sizeof(mii); <br>      mii.fMask = MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE; <br>      mii.fType = MFT_STRING; <br>      mii.fState = MFS_ENABLED; <br>      mii.dwTypeData = szText; <br>      mii.hSubMenu = BuildRegistryMenu(); <br> <br>      //insert our menu into the menu bar <br>      if(mii.hSubMenu) <br>         { <br>         InsertMenuItem(m_hMenu, FCIDM_MENU_HELP, FALSE, &amp;mii); <br>         } <br> <br>      //get the view menu so we can merge with it <br>      ZeroMemory(&amp;mii, sizeof(mii)); <br>      mii.cbSize = sizeof(mii); <br>      mii.fMask = MIIM_SUBMENU; <br>       <br>      if(GetMenuItemInfo(m_hMenu, FCIDM_MENU_VIEW, FALSE, &amp;mii)) <br>         { <br>         MergeViewMenu(mii.hSubMenu); <br>         } <br> <br>      //add the items that should only be added if we have the focus <br>      if(SVUIA_ACTIVATE_FOCUS == uState) <br>         { <br>         //get the file menu so we can merge with it <br>         ZeroMemory(&amp;mii, sizeof(mii)); <br>         mii.cbSize = sizeof(mii); <br>         mii.fMask = MIIM_SUBMENU; <br>       <br>         if(GetMenuItemInfo(m_hMenu, FCIDM_MENU_FILE, FALSE, &amp;mii)) <br>            { <br>            MergeFileMenu(mii.hSubMenu); <br>            } <br>         } <br> <br>      m_pShellBrowser-&gt;SetMenuSB(m_hMenu, NULL, m_hWnd); <br>      } <br>   } <br> <br>m_uState = uState; <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnDeactivate() <br>    <br>**************************************************************************/ <br> <br>void CShellView::OnDeactivate(void) <br>{ <br>if(m_uState != SVUIA_DEACTIVATE) <br>   { <br>   if(m_hMenu) <br>      { <br>      m_pShellBrowser-&gt;SetMenuSB(NULL, NULL, NULL); <br> <br>      m_pShellBrowser-&gt;RemoveMenusSB(m_hMenu); <br> <br>      DestroyMenu(m_hMenu); <br> <br>      m_hMenu = NULL; <br>      } <br> <br>   m_uState = SVUIA_DEACTIVATE; <br>   } <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::UIActivate() <br> <br>   This function activates the view window. Note that activating it  <br>   will not change the focus, while setting the focus will activate it. <br> <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::UIActivate(UINT uState) <br>{ <br>//don't do anything if the state isn't really changing <br>if(m_uState == uState) <br>   return S_OK; <br> <br>//OnActivate handles the menu merging and internal state <br>OnActivate(uState); <br> <br>//remove the docking window <br>if(g_bShowIDW) <br>   AddRemoveDockingWindow(FALSE); <br> <br>//only do this if we are active <br>if(uState != SVUIA_DEACTIVATE) <br>   { <br>   TCHAR szName[MAX_PATH]; <br>   LRESULT  lResult; <br>   int      nPartArray[1] = {-1}; <br>    <br>   //update the status bar <br>   LoadString(g_hInst, IDS_REGISTRY_TITLE, szName, sizeof(szName)); <br>    <br>   m_pSFParent-&gt;GetFolderPath(szName + lstrlen(szName), sizeof(szName) - lstrlen(szName)); <br> <br>   //set the number of parts <br>   m_pShellBrowser-&gt;SendControlMsg(FCW_STATUS, SB_SETPARTS, 1, (LPARAM)nPartArray, &amp;lResult); <br> <br>   //set the text for the parts <br>   m_pShellBrowser-&gt;SendControlMsg(FCW_STATUS, SB_SETTEXT, 0, (LPARAM)szName, &amp;lResult); <br> <br>   //add the docking window if necessary <br>   if(g_bShowIDW) <br>      AddRemoveDockingWindow(TRUE); <br>   } <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::BuildRegistryMenu() <br>    <br>**************************************************************************/ <br> <br>HMENU CShellView::BuildRegistryMenu(void) <br>{ <br>HMENU hSubMenu = CreatePopupMenu(); <br> <br>if(hSubMenu) <br>   { <br>   TCHAR          szText[MAX_PATH]; <br>   MENUITEMINFO   mii; <br>   int            nTools, <br>                  i; <br>   //get the number of items in our global array <br>   for(nTools = 0; g_Tools[nTools].idCommand != -1; nTools++) <br>      { <br>      } <br> <br>   //add the menu items <br>   for(i = 0; i &lt; nTools; i++) <br>      { <br>      LoadString(g_hInst, g_Tools[i].idMenuString, szText, sizeof(szText)); <br>       <br>      ZeroMemory(&amp;mii, sizeof(mii)); <br>      mii.cbSize = sizeof(mii); <br>      mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE; <br> <br>      if(TBSTYLE_SEP != g_Tools[i].bStyle) <br>         { <br>         mii.fType = MFT_STRING; <br>         mii.fState = MFS_ENABLED; <br>         mii.dwTypeData = szText; <br>         mii.wID = g_Tools[i].idCommand; <br>         } <br>      else <br>         { <br>         mii.fType = MFT_SEPARATOR; <br>         } <br>       <br>      //tack this item onto the end of the menu <br>      InsertMenuItem(hSubMenu, (UINT)-1, TRUE, &amp;mii); <br>      } <br>   } <br> <br>return hSubMenu; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::MergeFileMenu() <br>    <br>**************************************************************************/ <br> <br>void CShellView::MergeFileMenu(HMENU hSubMenu) <br>{ <br>if(hSubMenu) <br>   { <br>   MENUITEMINFO   mii; <br>   TCHAR          szText[MAX_PATH]; <br> <br>   ZeroMemory(&amp;mii, sizeof(mii)); <br> <br>   //add a separator <br>   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE; <br>   mii.fType = MFT_SEPARATOR; <br>   mii.fState = MFS_ENABLED; <br> <br>   //insert this item at the beginning of the menu <br>   InsertMenuItem(hSubMenu, 0, TRUE, &amp;mii); <br> <br>   //add the file menu items <br>   LoadString(g_hInst, IDS_MI_FILEITEM, szText, sizeof(szText)); <br>   mii.cbSize = sizeof(mii); <br>   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE; <br>   mii.fType = MFT_STRING; <br>   mii.fState = MFS_ENABLED; <br>   mii.dwTypeData = szText; <br>   mii.wID = IDM_MYFILEITEM; <br> <br>   //insert this item at the beginning of the menu <br>   InsertMenuItem(hSubMenu, 0, TRUE, &amp;mii); <br>   } <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::MergeViewMenu() <br>    <br>**************************************************************************/ <br> <br>void CShellView::MergeViewMenu(HMENU hSubMenu) <br>{ <br>if(hSubMenu) <br>   { <br>   MENUITEMINFO   mii; <br>   TCHAR          szText[MAX_PATH]; <br> <br>   ZeroMemory(&amp;mii, sizeof(mii)); <br> <br>   //add a separator at the correct position in the menu <br>   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE; <br>   mii.fType = MFT_SEPARATOR; <br>   mii.fState = MFS_ENABLED; <br>   InsertMenuItem(hSubMenu, FCIDM_MENU_VIEW_SEP_OPTIONS, FALSE, &amp;mii); <br> <br>   //add the view menu items at the correct position in the menu <br>   LoadString(g_hInst, IDS_MI_VIEW_KEYS, szText, sizeof(szText)); <br>   mii.cbSize = sizeof(mii); <br>   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE; <br>   mii.fType = MFT_STRING; <br>   mii.fState = MFS_ENABLED; <br>   mii.dwTypeData = szText; <br>   mii.wID = IDM_VIEW_KEYS; <br>   InsertMenuItem(hSubMenu, FCIDM_MENU_VIEW_SEP_OPTIONS, FALSE, &amp;mii); <br>   } <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::Refresh() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::Refresh(void) <br>{ <br>//empty the list <br>ListView_DeleteAllItems(m_hwndList); <br> <br>//refill the list <br>FillList(); <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::CreateViewWindow() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::CreateViewWindow(   LPSHELLVIEW pPrevView,  <br>                                             LPCFOLDERSETTINGS lpfs,  <br>                                             LPSHELLBROWSER psb,  <br>                                             LPRECT prcView,  <br>                                             HWND *phWnd) <br>{ <br>WNDCLASS wc; <br> <br>*phWnd = NULL; <br> <br>//if our window class has not been registered, then do so <br>if(!GetClassInfo(g_hInst, NS_CLASS_NAME, &amp;wc)) <br>   { <br>   ZeroMemory(&amp;wc, sizeof(wc)); <br>   wc.style          = CS_HREDRAW | CS_VREDRAW; <br>   wc.lpfnWndProc    = (WNDPROC)WndProc; <br>   wc.cbClsExtra     = 0; <br>   wc.cbWndExtra     = 0; <br>   wc.hInstance      = g_hInst; <br>   wc.hIcon          = NULL; <br>   wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>   wc.lpszMenuName   = NULL; <br>   wc.lpszClassName  = NS_CLASS_NAME; <br>    <br>   if(!RegisterClass(&amp;wc)) <br>      return E_FAIL; <br>   } <br> <br>//set up the member variables <br>m_pShellBrowser = psb; <br>m_FolderSettings = *lpfs; <br> <br>//get our parent window <br>m_pShellBrowser-&gt;GetWindow(&amp;m_hwndParent); <br> <br>*phWnd = CreateWindowEx(   0, <br>                           NS_CLASS_NAME, <br>                           NULL, <br>                           WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, <br>                           prcView-&gt;left, <br>                           prcView-&gt;top, <br>                           prcView-&gt;right - prcView-&gt;left, <br>                           prcView-&gt;bottom - prcView-&gt;top, <br>                           m_hwndParent, <br>                           NULL, <br>                           g_hInst, <br>                           (LPVOID)this); <br>                            <br>if(!*phWnd) <br>   return E_FAIL; <br> <br>m_pShellBrowser-&gt;AddRef(); <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::DestroyViewWindow() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::DestroyViewWindow(void) <br>{ <br>//Make absolutely sure all our UI is cleaned up. <br>UIActivate(SVUIA_DEACTIVATE); <br> <br>if(m_hMenu) <br>   DestroyMenu(m_hMenu); <br> <br>DestroyWindow(m_hWnd); <br> <br>//release the shell browser object <br>m_pShellBrowser-&gt;Release(); <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::GetCurrentInfo() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::GetCurrentInfo(LPFOLDERSETTINGS lpfs) <br>{ <br>*lpfs = m_FolderSettings; <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::AddPropertySheetPages() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::AddPropertySheetPages( DWORD dwReserved,  <br>                                                LPFNADDPROPSHEETPAGE lpfn,  <br>                                                LPARAM lParam) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::SaveViewState() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::SaveViewState(void) <br>{ <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::SelectItem() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::GetItemObject() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellView::GetItemObject(UINT uItem, REFIID riid, LPVOID *ppvOut) <br>{ <br>*ppvOut = NULL; <br> <br>return E_NOTIMPL; <br>} <br> <br> <br>/************************************************************************** <br> <br>   CShellView::WndProc() <br>    <br>**************************************************************************/ <br> <br>LRESULT CALLBACK CShellView::WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) <br>{ <br>CShellView  *pThis = (CShellView*)GetWindowLong(hWnd, GWL_USERDATA); <br> <br>switch (uMessage) <br>   { <br>   case WM_NCCREATE: <br>      { <br>      LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam; <br>      pThis = (CShellView*)(lpcs-&gt;lpCreateParams); <br>      SetWindowLong(hWnd, GWL_USERDATA, (LONG)pThis); <br> <br>      //set the window handle <br>      pThis-&gt;m_hWnd = hWnd; <br>      } <br>      break; <br>    <br>   case WM_SIZE: <br>      return pThis-&gt;OnSize(LOWORD(lParam), HIWORD(lParam)); <br>    <br>   case WM_CREATE: <br>      return pThis-&gt;OnCreate(); <br>    <br>   case WM_SETFOCUS: <br>      return pThis-&gt;OnSetFocus(); <br>    <br>   case WM_KILLFOCUS: <br>      return pThis-&gt;OnKillFocus(); <br> <br>   case WM_ACTIVATE: <br>      return pThis-&gt;OnActivate(SVUIA_ACTIVATE_FOCUS); <br>    <br>   case WM_COMMAND: <br>      return pThis-&gt;OnCommand(   GET_WM_COMMAND_ID(wParam, lParam),  <br>                                 GET_WM_COMMAND_CMD(wParam, lParam),  <br>                                 GET_WM_COMMAND_HWND(wParam, lParam)); <br>    <br>   case WM_INITMENUPOPUP: <br>      return pThis-&gt;UpdateMenu((HMENU)wParam); <br>    <br>   case WM_NOTIFY: <br>      return pThis-&gt;OnNotify((UINT)wParam, (LPNMHDR)lParam); <br>    <br>   case WM_SETTINGCHANGE: <br>      return pThis-&gt;OnSettingChange((LPCTSTR)lParam); <br>   } <br> <br>return DefWindowProc(hWnd, uMessage, wParam, lParam); <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnSetFocus() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::OnSetFocus(void) <br>{ <br>/* <br>Tell the browser one of our windows has received the focus. This should always  <br>be done before merging menus (OnActivate merges the menus) if one of our  <br>windows has the focus. <br>*/ <br>m_pShellBrowser-&gt;OnViewWindowActive(this); <br> <br>OnActivate(SVUIA_ACTIVATE_FOCUS); <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnKillFocus() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::OnKillFocus(void) <br>{ <br>OnActivate(SVUIA_ACTIVATE_NOFOCUS); <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnCommand() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::OnCommand(DWORD dwCmdID, DWORD dwCmd, HWND hwndCmd) <br>{ <br>switch(dwCmdID) <br>   { <br>   case IDM_VIEW_KEYS: <br>      g_bViewKeys = ! g_bViewKeys; <br>      Refresh(); <br>      break; <br> <br>   case IDM_VIEW_IDW: <br>      g_bShowIDW = ! g_bShowIDW; <br>      AddRemoveDockingWindow(g_bShowIDW); <br>      break; <br>    <br>   case IDM_MYFILEITEM: <br>      MessageBeep(MB_OK); <br>      break; <br>   } <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::UpdateMenu() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::UpdateMenu(HMENU hMenu) <br>{ <br>CheckMenuItem(hMenu, IDM_VIEW_KEYS, MF_BYCOMMAND | (g_bViewKeys ? MF_CHECKED: MF_UNCHECKED)); <br> <br>if(CanDoIDockingWindow()) <br>   { <br>   EnableMenuItem(hMenu, IDM_VIEW_IDW, MF_BYCOMMAND | MF_ENABLED); <br>   CheckMenuItem(hMenu, IDM_VIEW_IDW, MF_BYCOMMAND | (g_bShowIDW ? MF_CHECKED: MF_UNCHECKED)); <br>   } <br>else <br>   { <br>   EnableMenuItem(hMenu, IDM_VIEW_IDW, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED); <br>   CheckMenuItem(hMenu, IDM_VIEW_IDW, MF_BYCOMMAND | MF_UNCHECKED); <br>   } <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnNotify() <br>    <br>**************************************************************************/ <br> <br>#define MENU_OFFSET  1 <br>#define MENU_MAX     100 <br> <br>LRESULT CShellView::OnNotify(UINT CtlID, LPNMHDR lpnmh) <br>{ <br>switch(lpnmh-&gt;code) <br>   { <br>   case NM_SETFOCUS: <br>      OnSetFocus(); <br>      break; <br> <br>   case NM_KILLFOCUS: <br>      OnDeactivate(); <br>      break; <br> <br>   case HDN_ENDTRACK: <br>      { <br>      g_nColumn1 = ListView_GetColumnWidth(m_hwndList, 0); <br>      g_nColumn2 = ListView_GetColumnWidth(m_hwndList, 1); <br>      } <br>      return 0; <br>    <br>   case LVN_DELETEITEM: <br>      { <br>      NM_LISTVIEW *lpnmlv = (NM_LISTVIEW*)lpnmh; <br>       <br>      //delete the pidl because we made a copy of it <br>      m_pPidlMgr-&gt;Delete((LPITEMIDLIST)lpnmlv-&gt;lParam); <br>      } <br>      break; <br>    <br>#ifdef LVN_ITEMACTIVATE <br>    <br>   case LVN_ITEMACTIVATE: <br> <br>#else    //LVN_ITEMACTIVATE <br> <br>   case NM_DBLCLK: <br>   case NM_RETURN: <br> <br>#endif   //LVN_ITEMACTIVATE <br> <br>      DoContextMenu(0, 0, TRUE); <br>      return 0; <br>    <br>   case LVN_GETDISPINFO: <br>      { <br>      LV_DISPINFO    *lpdi = (LV_DISPINFO *)lpnmh; <br>      LPITEMIDLIST   pidl = (LPITEMIDLIST)lpdi-&gt;item.lParam; <br> <br>      //is the sub-item information being requested? <br>      if(lpdi-&gt;item.iSubItem) <br>         { <br>         //is the text being requested? <br>         if(lpdi-&gt;item.mask &amp; LVIF_TEXT) <br>            { <br>            //is this a value or a key? <br>            if(m_pPidlMgr-&gt;IsValue(pidl)) <br>               { <br>               //get the item's value text <br>               m_pPidlMgr-&gt;GetDataText(m_pidl, pidl, lpdi-&gt;item.pszText, lpdi-&gt;item.cchTextMax); <br> <br>               //if the data text is NULL, get the no value string <br>               if(!*lpdi-&gt;item.pszText) <br>                  LoadString(g_hInst, IDS_NODATA, lpdi-&gt;item.pszText, lpdi-&gt;item.cchTextMax); <br>               } <br>            //its a key <br>            else <br>               { <br>               LoadString(g_hInst, IDS_KEY, lpdi-&gt;item.pszText, lpdi-&gt;item.cchTextMax); <br>               } <br>            } <br>         } <br>      //the item text is being requested <br>      else <br>         { <br>         //is the text being requested? <br>         if(lpdi-&gt;item.mask &amp; LVIF_TEXT) <br>            { <br>            STRRET   str; <br> <br>            if(SUCCEEDED(m_pSFParent-&gt;GetDisplayNameOf(pidl, SHGDN_NORMAL | SHGDN_INFOLDER, &amp;str))) <br>               { <br>               if(STRRET_WSTR == str.uType) <br>                  { <br>                  WideCharToLocal(lpdi-&gt;item.pszText, str.pOleStr, lpdi-&gt;item.cchTextMax); <br> <br>                  //delete the string buffer <br>                  m_pMalloc-&gt;Free(str.pOleStr); <br>                  } <br>               } <br>            } <br> <br>         //is the image being requested? <br>         if(lpdi-&gt;item.mask &amp; LVIF_IMAGE) <br>            { <br>            IExtractIcon   *pei; <br> <br>            if(SUCCEEDED(m_pSFParent-&gt;GetUIObjectOf(m_hWnd, 1, (LPCITEMIDLIST*)&amp;pidl, IID_IExtractIcon, NULL, (LPVOID*)&amp;pei))) <br>               { <br>               UINT  uFlags; <br> <br>               //GetIconLoaction will give us the index into our image list <br>               pei-&gt;GetIconLocation(GIL_FORSHELL, NULL, 0, &amp;lpdi-&gt;item.iImage, &amp;uFlags); <br> <br>               pei-&gt;Release(); <br>               } <br>            } <br>         } <br>      } <br>      return 0; <br>    <br>   case NM_RCLICK: <br>      { <br>      DWORD dwCursor = GetMessagePos(); <br>      DoContextMenu(LOWORD(dwCursor), HIWORD(dwCursor), FALSE); <br>      } <br>      return 0; <br>   } <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnSize() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::OnSize(WORD wWidth, WORD wHeight) <br>{ <br>//resize the ListView to fit our window <br>if(m_hwndList) <br>   { <br>   MoveWindow(m_hwndList, 0, 0, wWidth, wHeight, TRUE); <br>   } <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnCreate() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::OnCreate(void) <br>{ <br>//create the ListView <br>if(CreateList()) <br>   { <br>   if(InitList()) <br>      { <br>      FillList(); <br>      } <br>   } <br> <br>return 0; <br>} <br> <br> <br>/************************************************************************** <br> <br>   CShellView::CreateList() <br>    <br>**************************************************************************/ <br> <br>BOOL CShellView::CreateList(void) <br>{ <br>DWORD dwStyle; <br> <br>dwStyle =   WS_TABSTOP |  <br>            WS_VISIBLE | <br>            WS_CHILD |  <br>            WS_BORDER |  <br>            LVS_REPORT |  <br>            LVS_NOSORTHEADER | <br>            LVS_SHAREIMAGELISTS; <br> <br>m_hwndList = CreateWindowEx(     WS_EX_CLIENTEDGE, <br>                                 WC_LISTVIEW, <br>                                 NULL, <br>                                 dwStyle, <br>                                 0, <br>                                 0, <br>                                 0, <br>                                 0, <br>                                 m_hWnd, <br>                                 (HMENU)ID_LISTVIEW, <br>                                 g_hInst, <br>                                 NULL); <br> <br>if(!m_hwndList) <br>   return FALSE; <br> <br>UpdateShellSettings(); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::InitList() <br>    <br>**************************************************************************/ <br> <br>BOOL CShellView::InitList(void) <br>{ <br>LV_COLUMN   lvColumn; <br>RECT        rc; <br>TCHAR       szString[MAX_PATH]; <br> <br>//empty the list <br>ListView_DeleteAllItems(m_hwndList); <br> <br>//initialize the columns </code></pre>
<p>
</p>
<pre><code>lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; <br>lvColumn.fmt = LVCFMT_LEFT; <br>lvColumn.pszText = szString; <br> <br>lvColumn.cx = g_nColumn1; <br>LoadString(g_hInst, IDS_COLUMN1, szString, sizeof(szString)); <br>ListView_InsertColumn(m_hwndList, 0, &amp;lvColumn); <br> <br>GetClientRect(m_hWnd, &amp;rc); <br> <br>lvColumn.cx = g_nColumn2; <br>LoadString(g_hInst, IDS_COLUMN2, szString, sizeof(szString)); <br>ListView_InsertColumn(m_hwndList, 1, &amp;lvColumn); <br> <br>ListView_SetImageList(m_hwndList, g_himlSmall, LVSIL_SMALL); <br> <br>return TRUE; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::FillList() <br>    <br>**************************************************************************/ <br> <br>void CShellView::FillList(void) <br>{ <br>LPENUMIDLIST   pEnumIDList; <br> <br>if(SUCCEEDED(m_pSFParent-&gt;EnumObjects(m_hWnd, SHCONTF_NONFOLDERS | (g_bViewKeys ? SHCONTF_FOLDERS : 0), &amp;pEnumIDList))) <br>   { <br>   LPITEMIDLIST   pidl; <br>   DWORD          dwFetched; <br> <br>   //turn the listview's redrawing off <br>   SendMessage(m_hwndList, WM_SETREDRAW, FALSE, 0); <br> <br>   while((S_OK == pEnumIDList-&gt;Next(1, &amp;pidl, &amp;dwFetched)) &amp;&amp; dwFetched) <br>      { <br>      LV_ITEM  lvItem; <br> <br>      ZeroMemory(&amp;lvItem, sizeof(lvItem)); <br> <br>      //set the mask <br>      lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br> <br>      //add the item to the end of the list <br>      lvItem.iItem = ListView_GetItemCount(m_hwndList); <br> <br>      //set the item's data <br>      lvItem.lParam = (LPARAM)m_pPidlMgr-&gt;Copy(pidl); <br> <br>      //get text on a callback basis <br>      lvItem.pszText = LPSTR_TEXTCALLBACK; <br> <br>      //get the image on a callback basis <br>      lvItem.iImage = I_IMAGECALLBACK; <br> <br>      //add the item <br>      ListView_InsertItem(m_hwndList, &amp;lvItem); <br>      } <br> <br>   //sort the items <br>   ListView_SortItems(m_hwndList, CompareItems, (LPARAM)m_pSFParent); <br>    <br>   //turn the listview's redrawing back on and force it to draw <br>   SendMessage(m_hwndList, WM_SETREDRAW, TRUE, 0); <br>   InvalidateRect(m_hwndList, NULL, TRUE); <br>   UpdateWindow(m_hwndList); <br> <br>   pEnumIDList-&gt;Release(); <br>   } <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::CanDoIDockingWindow() <br>    <br>**************************************************************************/ <br> <br>BOOL CShellView::CanDoIDockingWindow(void) <br>{ <br>#if (_WIN32_IE &lt; 0x0400) <br> <br>return FALSE; <br> <br>#else //(_WIN32_IE &gt;= 0x0400) <br> <br>BOOL              bReturn = FALSE; <br>HRESULT           hr; <br>IServiceProvider  *pSP; <br> <br>//get the browser's IServiceProvider <br>hr = m_pShellBrowser-&gt;QueryInterface((REFIID)IID_IServiceProvider, (LPVOID*)&amp;pSP); <br>if(SUCCEEDED(hr)) <br>   { <br>   IDockingWindowFrame *pFrame; <br> <br>   //get the IDockingWindowFrame <br>   hr = pSP-&gt;QueryService(SID_SShellBrowser, IID_IDockingWindowFrame, (LPVOID*)&amp;pFrame); <br>   if(SUCCEEDED(hr)) <br>      { <br>      bReturn = TRUE; <br> <br>      pFrame-&gt;Release(); <br>      } <br> <br>   pSP-&gt;Release(); <br>   } <br> <br>return bReturn; <br>#endif   //(_WIN32_IE &gt;= 0x0400) <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::AddRemoveDockingWindow() <br>    <br>**************************************************************************/ <br> <br>BOOL CShellView::AddRemoveDockingWindow(BOOL bAdd) <br>{ <br>#if (_WIN32_IE &lt; 0x0400) <br> <br>return FALSE; <br> <br>#else //(_WIN32_IE &lt; 0x0400) <br> <br>BOOL              bReturn = FALSE; <br>HRESULT           hr; <br>IServiceProvider  *pSP; <br> <br>//get the browser's IServiceProvider <br>hr = m_pShellBrowser-&gt;QueryInterface((REFIID)IID_IServiceProvider, (LPVOID*)&amp;pSP); <br>if(SUCCEEDED(hr)) <br>   { <br>   IDockingWindowFrame *pFrame; <br> <br>   //get the IDockingWindowFrame pointer <br>   hr = pSP-&gt;QueryService(SID_SShellBrowser, IID_IDockingWindowFrame, (LPVOID*)&amp;pFrame); <br>   if(SUCCEEDED(hr)) <br>      { <br>      if(bAdd) <br>         { <br>         hr = S_OK; <br>         if(!m_pDockingWindow) <br>            { <br>            //create the toolbar object <br>            m_pDockingWindow = new CDockingWindow(this, m_hWnd); <br>            } <br> <br>         if(m_pDockingWindow) <br>            { <br>            //add the toolbar object <br>            hr = pFrame-&gt;AddToolbar((IDockingWindow*)m_pDockingWindow, TOOLBAR_ID, 0); <br> <br>            if(SUCCEEDED(hr)) <br>               { <br>               bReturn = TRUE; <br>               } <br>            } <br>         } <br>      else <br>         { <br>         if(m_pDockingWindow) <br>            { <br>            hr = pFrame-&gt;RemoveToolbar((IDockingWindow*)m_pDockingWindow, DWFRF_NORMAL); <br> <br>            if(SUCCEEDED(hr)) <br>               { <br>               /* <br>               RemoveToolbar should release the toolbar object which will cause  <br>               it to destroy itself. Our toolbar object is no longer valid at  <br>               this point. <br>               */ <br>               m_pDockingWindow = NULL; <br>               bReturn = TRUE; <br>               } <br>            } <br>         } <br>      pFrame-&gt;Release(); <br>      } <br>   pSP-&gt;Release(); <br>   } <br> <br>return bReturn; <br>#endif   //(_WIN32_IE &lt; 0x0400) <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::UpdateShellSettings() <br>    <br>**************************************************************************/ <br> <br>typedef void (WINAPI *PFNSHGETSETTINGSPROC)(LPSHELLFLAGSTATE lpsfs, DWORD dwMask); <br> <br>void CShellView::UpdateShellSettings(void) <br>{ <br>#if (_WIN32_IE &gt;= 0x0400) <br>SHELLFLAGSTATE       sfs; <br>HINSTANCE            hinstShell32; <br> <br>/* <br>Since SHGetSettings is not implemented in all versions of the shell, get the  <br>function address manually at run time. This allows the extension to run on all  <br>platforms. <br>*/ <br> <br>ZeroMemory(&amp;sfs, sizeof(sfs)); <br> <br>/* <br>The default, in case any of the following steps fails, is classic Windows 95  <br>style. <br>*/ <br>sfs.fWin95Classic = TRUE; <br> <br>hinstShell32 = LoadLibrary(TEXT("shell32.dll")); <br>if(hinstShell32) <br>   { <br>   PFNSHGETSETTINGSPROC pfnSHGetSettings; <br> <br>   pfnSHGetSettings = (PFNSHGETSETTINGSPROC)GetProcAddress(hinstShell32, TEXT("SHGetSettings")); <br>   if(pfnSHGetSettings) <br>      { <br>      (*pfnSHGetSettings)(&amp;sfs, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC); <br>      } <br>   FreeLibrary(hinstShell32); <br>   } <br> <br>DWORD dwExStyles = 0; <br> <br>if(!sfs.fWin95Classic &amp;&amp; !sfs.fDoubleClickInWebView) <br>   dwExStyles |= LVS_EX_ONECLICKACTIVATE |  <br>                  LVS_EX_TRACKSELECT |  <br>                  LVS_EX_UNDERLINEHOT; <br> <br>ListView_SetExtendedListViewStyle(m_hwndList, dwExStyles); <br> <br>#endif   //(_WIN32_IE &gt;= 0x0400) <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::OnSettingChange() <br>    <br>**************************************************************************/ <br> <br>LRESULT CShellView::OnSettingChange(LPCTSTR lpszSection) <br>{ <br>//if(0 == lstrcmpi(lpszSection, TEXT("ShellState"))) <br>   { <br>   UpdateShellSettings(); <br>   return 0; <br>   } <br> <br>return 0; <br>} <br> <br>/************************************************************************** <br> <br>   CShellView::DoContextMenu() <br>    <br>**************************************************************************/ <br> <br>void CShellView::DoContextMenu(WORD x, WORD y, BOOL fDefault) <br>{ <br>UINT           uSelected = ListView_GetSelectedCount(m_hwndList); <br>LPITEMIDLIST   *aSelectedItems; <br> <br>aSelectedItems = (LPITEMIDLIST*)m_pMalloc-&gt;Alloc(uSelected * sizeof(LPITEMIDLIST)); <br> <br>if(aSelectedItems) <br>   { <br>   UINT           i; <br>   LPCONTEXTMENU  pContextMenu = NULL; <br>   LVITEM         lvItem; <br> <br>   ZeroMemory(&amp;lvItem, sizeof(lvItem)); <br>   lvItem.mask = LVIF_STATE | LVIF_PARAM; <br>   lvItem.stateMask = LVIS_SELECTED; <br>   lvItem.iItem = 0; <br> <br>   i = 0; <br>    <br>   while(ListView_GetItem(m_hwndList, &amp;lvItem) &amp;&amp; (i &lt; uSelected)) <br>      { <br>      if(lvItem.state &amp; LVIS_SELECTED) <br>         { <br>         aSelectedItems[i] = (LPITEMIDLIST)lvItem.lParam; <br>         i++; <br>         } <br>      lvItem.iItem++; <br>      } <br> <br>   m_pSFParent-&gt;GetUIObjectOf(   m_hwndParent, <br>                                 uSelected, <br>                                 (LPCITEMIDLIST*)aSelectedItems, <br>                                 IID_IContextMenu, <br>                                 NULL, <br>                                 (LPVOID*)&amp;pContextMenu); <br>    <br>   if(pContextMenu) <br>      { <br>      HMENU hMenu = CreatePopupMenu(); <br> <br>      if(hMenu &amp;&amp; SUCCEEDED(pContextMenu-&gt;QueryContextMenu( hMenu, <br>                                                            0, <br>                                                            MENU_OFFSET, <br>                                                            MENU_MAX, <br>                                                            CMF_NORMAL))) <br>         { <br>         UINT  uCommand; <br> <br>         if(fDefault) <br>            { <br>            MENUITEMINFO   mii; <br>            int            nMenuIndex; <br> <br>            uCommand = 0; <br>             <br>            ZeroMemory(&amp;mii, sizeof(mii)); <br>            mii.cbSize = sizeof(mii); <br>            mii.fMask = MIIM_STATE | MIIM_ID; <br> <br>            nMenuIndex = 0; <br> <br>            //find the default item in the menu <br>            while(GetMenuItemInfo(hMenu, nMenuIndex, TRUE, &amp;mii)) <br>               { <br>               if(mii.fState &amp; MFS_DEFAULT) <br>                  { <br>                  uCommand = mii.wID; <br>                  } <br> <br>               nMenuIndex++; <br>               } <br>            } <br>         else <br>            { <br>            uCommand = TrackPopupMenu( hMenu, <br>                                       TPM_LEFTALIGN | TPM_RETURNCMD, <br>                                       x, <br>                                       y, <br>                                       0, <br>                                       m_hWnd, <br>                                       NULL); <br>            } <br>          <br>         if(uCommand &gt; 0) <br>            { <br>            CMINVOKECOMMANDINFO  cmi; <br> <br>            ZeroMemory(&amp;cmi, sizeof(cmi)); <br>            cmi.cbSize = sizeof(cmi); <br>            cmi.hwnd = m_hwndParent; <br>            cmi.lpVerb = MAKEINTRESOURCE(uCommand - MENU_OFFSET); <br> <br>            pContextMenu-&gt;InvokeCommand(&amp;cmi); <br>            } <br> <br>         DestroyMenu(hMenu); <br>         } <br>      } <br> <br>   m_pMalloc-&gt;Free(aSelectedItems); <br>   } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
