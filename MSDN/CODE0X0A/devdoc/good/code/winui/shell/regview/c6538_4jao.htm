<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONTMENU.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6540"></a>CONTMENU.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          ContMenu.cpp <br>    <br>   Description:   CContextMenu implementation. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "ContMenu.h" <br> <br>/************************************************************************** <br>   global variables <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   CContextMenu::CContextMenu() <br> <br>**************************************************************************/ <br> <br>CContextMenu::CContextMenu(CShellFolder *pSFParent, LPCITEMIDLIST *aPidls, UINT uItemCount) <br>{ <br>m_pSFParent = pSFParent; <br>if(m_pSFParent) <br>   m_pSFParent-&gt;AddRef(); <br> <br>m_ObjRefCount = 1; <br>g_DllRefCount++; <br> <br>m_aPidls = NULL; <br>SHGetMalloc(&amp;m_pMalloc); <br>if(!m_pMalloc) <br>   { <br>   delete this; <br>   return; <br>   } <br> <br>m_pPidlMgr = new CPidlMgr(); <br> <br>AllocPidlTable(uItemCount); <br>if(m_aPidls) <br>   { <br>   FillPidlTable(aPidls, uItemCount); <br>   } <br> <br>m_fAllValues = 1; <br>UINT  u; <br>for(u = 0; u &lt; uItemCount; u++) <br>   { <br>   m_fAllValues &amp;= (m_pPidlMgr-&gt;IsValue(aPidls[u]) ? 1 : 0); <br>   } <br>} <br> <br>/************************************************************************** <br> <br>   CContextMenu::~CContextMenu() <br> <br>**************************************************************************/ <br> <br>CContextMenu::~CContextMenu() <br>{ <br>if(m_pSFParent) <br>   m_pSFParent-&gt;Release(); <br> <br>g_DllRefCount--; <br> <br>//make sure the pidl is freed <br>if(m_aPidls &amp;&amp; m_pMalloc) <br>   { <br>   FreePidlTable(); <br>   } <br> <br>if(m_pPidlMgr) <br>   delete m_pPidlMgr; <br> <br>if(m_pMalloc) <br>   m_pMalloc-&gt;Release(); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IUnknown Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CContextMenu::QueryInterface <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP CContextMenu::QueryInterface(   REFIID riid,  <br>                                                   LPVOID FAR * ppReturn) <br>{ <br>if(IsEqualIID(riid, IID_IUnknown)) <br>   { <br>   *ppReturn = (LPUNKNOWN)(LPCONTEXTMENU)this; <br>   m_ObjRefCount++; <br>   return ResultFromScode(S_OK); <br>   } <br>    <br>if(IsEqualIID(riid, IID_IContextMenu)) <br>   { <br>   *ppReturn = (LPCONTEXTMENU)this; <br>   m_ObjRefCount++; <br>   return ResultFromScode(S_OK); <br>   }    <br> <br>if(IsEqualIID(riid, IID_IShellExtInit)) <br>   { <br>   *ppReturn = (LPSHELLEXTINIT)this; <br>   m_ObjRefCount++; <br>   return ResultFromScode(S_OK); <br>   }    <br> <br>*ppReturn = NULL; <br>return ResultFromScode(E_NOINTERFACE); <br>}                                              <br> <br>/************************************************************************** <br> <br>   CContextMenu::AddRef <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CContextMenu::AddRef() <br>{ <br>return ++m_ObjRefCount; <br>} <br> <br> <br>/************************************************************************** <br> <br>   CContextMenu::Release <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CContextMenu::Release() <br>{ <br>if(--m_ObjRefCount == 0) <br>   delete this; <br>    <br>return m_ObjRefCount; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IContextMenu Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CContextMenu::QueryContextMenu() <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP CContextMenu::QueryContextMenu( HMENU hMenu, <br>                                                   UINT indexMenu, <br>                                                   UINT idCmdFirst, <br>                                                   UINT idCmdLast, <br>                                                   UINT uFlags) <br>{ <br>if(!(CMF_DEFAULTONLY &amp; uFlags)) <br>   { <br>   MENUITEMINFO   mii; <br> <br>   if(!m_fAllValues) <br>      { <br>      ZeroMemory(&amp;mii, sizeof(mii)); <br>      mii.cbSize = sizeof(mii); <br>      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE; <br>      mii.wID = idCmdFirst + IDM_EXPLORE; <br>      mii.fType = MFT_STRING; <br>      mii.dwTypeData = TEXT("&amp;Explore"); <br>      mii.fState = MFS_ENABLED | MFS_DEFAULT; <br>      InsertMenuItem(   hMenu,  <br>                        indexMenu++,  <br>                        TRUE,  <br>                        &amp;mii); <br> <br>      ZeroMemory(&amp;mii, sizeof(mii)); <br>      mii.cbSize = sizeof(mii); <br>      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE; <br>      mii.wID = idCmdFirst + IDM_OPEN; <br>      mii.fType = MFT_STRING; <br>      mii.dwTypeData = TEXT("&amp;Open"); <br>      mii.fState = MFS_ENABLED; <br>      InsertMenuItem(   hMenu,  <br>                        indexMenu++,  <br>                        TRUE,  <br>                        &amp;mii); <br>      } <br>   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_LAST + 1)); <br>   } <br> <br>return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0)); <br>} <br> <br>/************************************************************************** <br> <br>   CContextMenu::InvokeCommand() <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP CContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi) <br>{ <br>if(HIWORD(lpcmi-&gt;lpVerb)) <br>   { <br>   //the command is being sent via a verb <br>   return NOERROR; <br>   } <br> <br>if(LOWORD(lpcmi-&gt;lpVerb) &gt; IDM_LAST) <br>   return ResultFromScode(E_INVALIDARG); <br> <br>switch(LOWORD(lpcmi-&gt;lpVerb)) <br>   { <br>   case IDM_EXPLORE: <br>   case IDM_OPEN: <br>      { <br>      LPITEMIDLIST      pidlFQ; <br>      SHELLEXECUTEINFO  sei; <br> <br>      /* <br>      Find the first item in the list that is not a value. These commands  <br>      should never be invoked if there isn't at least one key item in the list. <br>      */ <br>      int   i; <br>      for(i = 0; m_aPidls[i]; i++) <br>         { <br>         if(!m_pPidlMgr-&gt;IsValue(m_aPidls[i])) <br>            break; <br>         } <br>       <br>      pidlFQ = m_pPidlMgr-&gt;Concatenate(m_pSFParent-&gt;m_pidlFQ, m_aPidls[i]); <br>       <br>      ZeroMemory(&amp;sei, sizeof(sei)); <br>      sei.cbSize = sizeof(sei); <br>      sei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME; <br>      sei.lpIDList = pidlFQ; <br>      sei.lpClass = TEXT("folder"); <br>      sei.hwnd = lpcmi-&gt;hwnd; <br>       <br>      if(LOWORD(lpcmi-&gt;lpVerb) == IDM_EXPLORE) <br>         sei.lpVerb = TEXT("explore"); <br>      else <br>         sei.lpVerb = TEXT("open"); <br>       <br>      ShellExecuteEx(&amp;sei); <br> <br>      m_pPidlMgr-&gt;Delete(pidlFQ); <br>      } <br>      break; <br> <br>   } <br> <br>return NOERROR; <br>} <br> <br>/************************************************************************** <br> <br>   CContextMenu::GetCommandString() <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP CContextMenu::GetCommandString( UINT idCommand, <br>                                                   UINT uFlags, <br>                                                   LPUINT lpReserved, <br>                                                   LPSTR lpszName, <br>                                                   UINT uMaxNameLen) <br>{ <br>HRESULT  hr = E_INVALIDARG; <br> <br>switch(uFlags) <br>   { <br>   case GCS_HELPTEXT: <br>      switch(idCommand) <br>         { <br>         case 0: <br>            lstrcpy(lpszName, "Display the file name."); <br>            hr = NOERROR; <br>            break; <br>         } <br>      break; <br>    <br>   case GCS_VERB: <br>      switch(idCommand) <br>         { <br>         case 0: <br>            lstrcpy(lpszName, "display"); <br>            hr = NOERROR; <br>            break; <br>         } <br>      break; <br>    <br>   case GCS_VALIDATE: <br>      hr = NOERROR; <br>      break; <br>   } <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CContextMenu::AllocPidlTable() <br> <br>**************************************************************************/ <br> <br>BOOL CContextMenu::AllocPidlTable(DWORD dwEntries) <br>{ <br>//add one for NULL terminator <br>dwEntries++; <br> <br>m_aPidls = (LPITEMIDLIST*)m_pMalloc-&gt;Alloc(dwEntries * sizeof(LPITEMIDLIST)); <br> <br>if(m_aPidls) <br>   { <br>   //set all of the entries to NULL <br>   ZeroMemory(m_aPidls, dwEntries * sizeof(LPITEMIDLIST)); <br>   } <br> <br>return (m_aPidls != NULL); <br>} <br> <br>/************************************************************************** <br> <br>   CContextMenu::FreePidlTable() <br> <br>**************************************************************************/ <br> <br>void CContextMenu::FreePidlTable(void) <br>{ <br>if(m_aPidls &amp;&amp; m_pPidlMgr) <br>   { <br>   int   i; <br>   for(i = 0; m_aPidls[i]; i++) <br>      m_pPidlMgr-&gt;Delete(m_aPidls[i]); <br>    <br>   m_pMalloc-&gt;Free(m_aPidls); <br> <br>   m_aPidls = NULL; <br>   } <br>} <br> <br>/************************************************************************** <br> <br>   CContextMenu::FillPidlTable() <br> <br>**************************************************************************/ <br> <br>BOOL CContextMenu::FillPidlTable(LPCITEMIDLIST *aPidls, UINT uItemCount) <br>{ <br>if(m_aPidls) <br>   { <br>   if(m_pPidlMgr) <br>      { <br>      UINT  i; <br>      for(i = 0; i &lt; uItemCount; i++) <br>         { <br>         m_aPidls[i] = m_pPidlMgr-&gt;Copy(aPidls[i]); <br>         } <br>      return TRUE; <br>      } <br>   } <br> <br>return FALSE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
