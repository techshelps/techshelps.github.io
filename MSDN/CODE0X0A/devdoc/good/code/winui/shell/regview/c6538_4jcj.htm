<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REGVIEW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6553"></a>REGVIEW.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          RegView.cpp <br>    <br>   Description:   Contains DLLMain and standard OLE COM object creation stuff. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "ShlView.h" <br>#include "ClsFact.h" <br>#include "Utility.h" <br>#include &lt;olectl.h&gt; <br> <br>/************************************************************************** <br>   GUID stuff <br>**************************************************************************/ <br> <br>//this part is only done once <br>//if you need to use the GUID in another file, just include Guid.h <br>#pragma data_seg(".text") <br>#define INITGUID <br>#include &lt;initguid.h&gt; <br>#include &lt;shlguid.h&gt; <br>#include "Guid.h" <br>#pragma data_seg() <br> <br>/************************************************************************** <br>   private function prototypes <br>**************************************************************************/ <br> <br>extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID); <br> <br>/************************************************************************** <br>   global variables <br>**************************************************************************/ <br> <br>HINSTANCE   g_hInst; <br>UINT        g_DllRefCount; <br>int         g_nColumn1; <br>int         g_nColumn2; <br>BOOL        g_bViewKeys; <br>BOOL        g_bShowIDW; <br>HIMAGELIST  g_himlLarge; <br>HIMAGELIST  g_himlSmall; <br> <br>/************************************************************************** <br> <br>   DllMain <br> <br>**************************************************************************/ <br> <br>extern "C" BOOL WINAPI DllMain(  HINSTANCE hInstance,  <br>                                 DWORD dwReason,  <br>                                 LPVOID lpReserved) <br>{ <br>switch(dwReason) <br>   { <br>   case DLL_PROCESS_ATTACH: <br>      g_hInst = hInstance; <br> <br>      GetGlobalSettings(); <br> <br>      //create the global image lists <br>      CreateImageLists(); <br>      break; <br> <br>   case DLL_PROCESS_DETACH: <br>      SaveGlobalSettings(); <br> <br>      //destroy the global image lists <br>      DestroyImageLists(); <br>      break; <br>   } <br>    <br>return TRUE; <br>}                                  <br> <br>/************************************************************************** <br> <br>   DllCanUnloadNow <br> <br>**************************************************************************/ <br> <br>STDAPI DllCanUnloadNow(void) <br>{ <br>return (g_DllRefCount ? S_FALSE : S_OK); <br>} <br> <br>/************************************************************************** <br> <br>   DllGetClassObject <br> <br>**************************************************************************/ <br> <br>STDAPI DllGetClassObject(  REFCLSID rclsid,  <br>                           REFIID riid,  <br>                           LPVOID *ppReturn) <br>{ <br>*ppReturn = NULL; <br> <br>//if we don't support this classid, return the proper error code <br>if(!IsEqualCLSID(rclsid, CLSID_RegViewNameSpace)) <br>   return CLASS_E_CLASSNOTAVAILABLE; <br>    <br>//create a CClassFactory object and check it for validity <br>CClassFactory *pClassFactory = new CClassFactory(); <br>if(NULL == pClassFactory) <br>   return E_OUTOFMEMORY; <br>    <br>//get the QueryInterface return for our return value <br>HRESULT hResult = pClassFactory-&gt;QueryInterface(riid, ppReturn); <br> <br>//call Release to decement the ref count - creating the object set it to one  <br>//and QueryInterface incremented it - since its being used externally (not by  <br>//us), we only want the ref count to be 1 <br>pClassFactory-&gt;Release(); <br> <br>//return the result from QueryInterface <br>return hResult; <br>} <br> <br>/************************************************************************** <br> <br>   DllRegisterServer <br> <br>**************************************************************************/ <br> <br>typedef struct{ <br>   HKEY  hRootKey; <br>   LPTSTR lpszSubKey; <br>   LPTSTR lpszValueName; <br>   LPTSTR lpszData; <br>}REGSTRUCT, *LPREGSTRUCT; <br> <br>STDAPI DllRegisterServer(void) <br>{ <br>int      i; <br>HKEY     hKey; <br>LRESULT  lResult; <br>DWORD    dwDisp; <br>TCHAR    szSubKey[MAX_PATH]; <br>TCHAR    szCLSID[MAX_PATH]; <br>TCHAR    szModule[MAX_PATH]; <br>LPWSTR   pwsz; <br> <br>//get the CLSID in string form <br>StringFromIID(CLSID_RegViewNameSpace, &amp;pwsz); <br> <br>if(pwsz) <br>   { <br>   WideCharToLocal(szCLSID, pwsz, ARRAYSIZE(szCLSID)); <br> <br>   //free the string <br>   LPMALLOC pMalloc; <br>   CoGetMalloc(1, &amp;pMalloc); <br>   if(pMalloc) <br>      { <br>      pMalloc-&gt;Free(pwsz); <br>      pMalloc-&gt;Release(); <br>      } <br>   } <br> <br>//get this DLL's path and file name <br>GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule)); <br> <br>//register the CLSID entries <br>REGSTRUCT ClsidEntries[] = {  HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s"),                  NULL,                   TEXT("Registry View"), <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"),  NULL,                   TEXT("%s"), <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"),  TEXT("ThreadingModel"), TEXT("Apartment"), <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\DefaultIcon"),     NULL,                   TEXT("%s,0"), <br>                              NULL,                NULL,                               NULL,                   NULL}; <br> <br>for(i = 0; ClsidEntries[i].hRootKey; i++) <br>   { <br>   //Create the sub key string. <br>   wsprintf(szSubKey, ClsidEntries[i].lpszSubKey, szCLSID); <br> <br>   lResult = RegCreateKeyEx(  ClsidEntries[i].hRootKey, <br>                              szSubKey, <br>                              0, <br>                              NULL, <br>                              REG_OPTION_NON_VOLATILE, <br>                              KEY_WRITE, <br>                              NULL, <br>                              &amp;hKey, <br>                              &amp;dwDisp); <br>    <br>   if(NOERROR == lResult) <br>      { <br>      TCHAR szData[MAX_PATH]; <br> <br>      //if necessary, create the value string <br>      wsprintf(szData, ClsidEntries[i].lpszData, szModule); <br>    <br>      lResult = RegSetValueEx(   hKey, <br>                                 ClsidEntries[i].lpszValueName, <br>                                 0, <br>                                 REG_SZ, <br>                                 (LPBYTE)szData, <br>                                 lstrlen(szData) + 1); <br>       <br>      RegCloseKey(hKey); <br>      } <br>   else <br>      return SELFREG_E_CLASS; <br>   } <br> <br>//Register the default flags for the folder. <br> <br>wsprintf(   szSubKey,  <br>            TEXT("CLSID\\%s\\ShellFolder"),  <br>            szCLSID); <br> <br>lResult = RegCreateKeyEx(  HKEY_CLASSES_ROOT, <br>                           szSubKey, <br>                           0, <br>                           NULL, <br>                           REG_OPTION_NON_VOLATILE, <br>                           KEY_WRITE, <br>                           NULL, <br>                           &amp;hKey, <br>                           &amp;dwDisp); <br> <br>if(NOERROR == lResult) <br>   { <br>   DWORD dwData = SFGAO_FOLDER | SFGAO_HASSUBFOLDER; <br> <br>   lResult = RegSetValueEx(   hKey, <br>                              TEXT("Attributes"), <br>                              0, <br>                              REG_BINARY, <br>                              (LPBYTE)&amp;dwData, <br>                              sizeof(dwData)); <br>    <br>   RegCloseKey(hKey); <br>   } <br>else <br>   return SELFREG_E_CLASS; <br> <br>//Register the name space extension <br> <br>/* <br>Create the sub key string. Change this from "...Desktop..." to  <br>"...MyComputer..." if desired. <br>*/ <br>wsprintf(   szSubKey,  <br>            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\%s"),  <br>            szCLSID); <br> <br>lResult = RegCreateKeyEx(  HKEY_LOCAL_MACHINE, <br>                           szSubKey, <br>                           0, <br>                           NULL, <br>                           REG_OPTION_NON_VOLATILE, <br>                           KEY_WRITE, <br>                           NULL, <br>                           &amp;hKey, <br>                           &amp;dwDisp); <br> <br>if(NOERROR == lResult) <br>   { <br>   TCHAR szData[MAX_PATH]; <br> <br>   //Create the value string. <br>   lstrcpy(szData, TEXT("Registry View")); <br> <br>   lResult = RegSetValueEx(   hKey, <br>                              NULL, <br>                              0, <br>                              REG_SZ, <br>                              (LPBYTE)szData, <br>                              lstrlen(szData) + 1); <br>    <br>   RegCloseKey(hKey); <br>   } <br>else <br>   return SELFREG_E_CLASS; <br> <br>//If running on NT, register the extension as approved. <br>OSVERSIONINFO  osvi; <br> <br>osvi.dwOSVersionInfoSize = sizeof(osvi); <br>GetVersionEx(&amp;osvi); <br> <br>if(VER_PLATFORM_WIN32_NT == osvi.dwPlatformId) <br>   { <br>   lstrcpy( szSubKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")); <br> <br>   lResult = RegCreateKeyEx(  HKEY_LOCAL_MACHINE, <br>                              szSubKey, <br>                              0, <br>                              NULL, <br>                              REG_OPTION_NON_VOLATILE, <br>                              KEY_WRITE, <br>                              NULL, <br>                              &amp;hKey, <br>                              &amp;dwDisp); <br> <br>   if(NOERROR == lResult) <br>      { <br>      TCHAR szData[MAX_PATH]; <br> <br>      //Create the value string. <br>      lstrcpy(szData, TEXT("Registry View")); <br> <br>      lResult = RegSetValueEx(   hKey, <br>                                 szCLSID, <br>                                 0, <br>                                 REG_SZ, <br>                                 (LPBYTE)szData, <br>                                 lstrlen(szData) + 1); <br>       <br>      RegCloseKey(hKey); <br>      } <br>   else <br>      return SELFREG_E_CLASS; <br>   } <br> <br>return S_OK; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
