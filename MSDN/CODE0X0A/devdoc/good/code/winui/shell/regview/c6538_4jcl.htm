<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SHLFLDR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6555"></a>SHLFLDR.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          ShlFldr.cpp <br>    <br>   Description:   Implements CShellFolder. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "ShlFldr.h" <br>#include "ShlView.h" <br>#include "InfoTip.h" <br>#include "ExtrIcon.h" <br>#include "ContMenu.h" <br>#include "Guid.h" <br>#include "resource.h" <br> <br>/************************************************************************** <br>   global variables <br>**************************************************************************/ <br> <br>HKEY  g_ahKey[] = {  HKEY_CLASSES_ROOT, <br>                     HKEY_CURRENT_USER, <br>                     HKEY_LOCAL_MACHINE, <br>                     HKEY_USERS, <br>                     HKEY_PERFORMANCE_DATA, <br>                     HKEY_CURRENT_CONFIG, <br>                     HKEY_DYN_DATA, <br>                     (HKEY)-1}; <br>       <br>/************************************************************************** <br> <br>   CShellFolder::CShellFolder() <br> <br>**************************************************************************/ <br> <br>CShellFolder::CShellFolder(CShellFolder *pParent, LPCITEMIDLIST pidl) <br>{ <br>m_hKeyRoot = NULL; <br>m_lpszSubKey = NULL; <br> <br>m_pSFParent = pParent; <br>if(m_pSFParent) <br>   m_pSFParent-&gt;AddRef(); <br> <br>m_pPidlMgr = new CPidlMgr(); <br>if(!m_pPidlMgr) <br>   { <br>   delete this; <br>   return; <br>   } <br> <br>//get the shell's IMalloc pointer <br>//we'll keep this until we get destroyed <br>if(FAILED(SHGetMalloc(&amp;m_pMalloc))) <br>   { <br>   delete this; <br>   return; <br>   } <br> <br>m_pidlRel = m_pPidlMgr-&gt;Copy(pidl); <br>m_pidlFQ = NULL; <br> <br>if(m_pidlRel) <br>   { <br>   //determine if this PIDL has an HKEY or a sub key string <br>   if(m_pPidlMgr-&gt;IsRootKey(m_pidlRel)) <br>      { <br>      //this is a root key <br>      m_pPidlMgr-&gt;GetRootKey(m_pidlRel, &amp;m_hKeyRoot); <br>      } <br> <br>   DWORD dwSize = m_pPidlMgr-&gt;GetSubKeyText(m_pidlRel, NULL, 0); <br>   m_lpszSubKey = new TCHAR[dwSize]; <br>   if(m_lpszSubKey) <br>      { <br>      m_pPidlMgr-&gt;GetSubKeyText(m_pidlRel, m_lpszSubKey, dwSize); <br>      } <br>   } <br> <br>m_ObjRefCount = 1; <br> <br>g_DllRefCount++; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::~CShellFolder() <br> <br>**************************************************************************/ <br> <br>CShellFolder::~CShellFolder() <br>{ <br>if(m_pidlRel) <br>   { <br>   m_pPidlMgr-&gt;Delete(m_pidlRel); <br>   m_pidlRel = NULL; <br>   } <br> <br>if(m_pidlFQ) <br>   { <br>   m_pPidlMgr-&gt;Delete(m_pidlFQ); <br>   m_pidlFQ = NULL; <br>   } <br> <br>if(m_lpszSubKey) <br>   delete m_lpszSubKey; <br> <br>if(m_pSFParent) <br>   m_pSFParent-&gt;Release(); <br> <br>if(m_pMalloc) <br>   { <br>   m_pMalloc-&gt;Release(); <br>   } <br> <br>if(m_pPidlMgr) <br>   { <br>   delete m_pPidlMgr; <br>   } <br> <br>g_DllRefCount--; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IUnknown Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellFolder::QueryInterface <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::QueryInterface(REFIID riid, LPVOID *ppReturn) <br>{ <br>*ppReturn = NULL; <br> <br>//IUnknown <br>if(IsEqualIID(riid, IID_IUnknown)) <br>   { <br>   *ppReturn = this; <br>   } <br> <br>//IPersistFolder <br>else if(IsEqualIID(riid, IID_IPersistFolder)) <br>   { <br>   *ppReturn = (IPersistFolder*)this; <br>   } <br> <br>//IShellFolder <br>else if(IsEqualIID(riid, IID_IShellFolder)) <br>   { <br>   *ppReturn = (IShellFolder*)this; <br>   } <br> <br>if(*ppReturn) <br>   { <br>   (*(LPUNKNOWN*)ppReturn)-&gt;AddRef(); <br>   return S_OK; <br>   } <br> <br>return E_NOINTERFACE; <br>}                                              <br> <br>/************************************************************************** <br> <br>   CShellFolder::AddRef <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CShellFolder::AddRef() <br>{ <br>return ++m_ObjRefCount; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::Release <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) CShellFolder::Release() <br>{ <br>if(--m_ObjRefCount == 0) <br>   { <br>   delete this; <br>   return 0; <br>   } <br>    <br>return m_ObjRefCount; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IPersist Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellView::GetClassID() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::GetClassID(LPCLSID lpClassID) <br>{ <br>*lpClassID = CLSID_RegViewNameSpace; <br> <br>return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IPersistFolder Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellView::Initialize() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::Initialize(LPCITEMIDLIST pidl) <br>{ <br>if(m_pidlFQ) <br>   { <br>   m_pPidlMgr-&gt;Delete(m_pidlFQ); <br>   m_pidlFQ = NULL; <br>   } <br> <br>m_pidlFQ = m_pPidlMgr-&gt;Copy(pidl); <br> <br>return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IShellFolder Implementation <br>// <br> <br>/************************************************************************** <br> <br>   CShellFolder::BindToObject() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::BindToObject(  LPCITEMIDLIST pidl,  <br>                                          LPBC pbcReserved,  <br>                                          REFIID riid,  <br>                                          LPVOID *ppvOut) <br>{ <br>*ppvOut = NULL; <br> <br>CShellFolder   *pShellFolder = new CShellFolder(this, pidl); <br>if(!pShellFolder) <br>   return E_OUTOFMEMORY; <br> <br>LPITEMIDLIST   pidlFQ; <br> <br>pidlFQ = m_pPidlMgr-&gt;Concatenate(m_pidlFQ, pidl); <br>pShellFolder-&gt;Initialize(pidlFQ); <br>m_pPidlMgr-&gt;Delete(pidlFQ); <br> <br>HRESULT  hr = pShellFolder-&gt;QueryInterface(riid, ppvOut); <br> <br>pShellFolder-&gt;Release(); <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::BindToStorage() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::BindToStorage( LPCITEMIDLIST pidl,  <br>                                          LPBC pbcReserved,  <br>                                          REFIID riid,  <br>                                          LPVOID *ppvOut) <br>{ <br>*ppvOut = NULL; <br> <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::CompareIDs() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::CompareIDs( LPARAM lParam,  <br>                                       LPCITEMIDLIST pidl1,  <br>                                       LPCITEMIDLIST pidl2) <br>{ <br>TCHAR szString1[MAX_PATH] = TEXT(""); <br>TCHAR szString2[MAX_PATH] = TEXT(""); <br>HKEY  hkey1 = NULL, <br>      hkey2 = NULL; <br>int   nReturn; <br> <br>/* <br>Special case - If one of the items is a key and the other is a value, always  <br>make the key come before the value. <br>*/ <br>LPCITEMIDLIST  pidlTemp1 = pidl1, <br>               pidlTemp2 = pidl2; <br> <br>//get the last item in each list <br>while((m_pPidlMgr-&gt;GetNextItem(pidlTemp1))-&gt;mkid.cb) <br>   pidlTemp1 = m_pPidlMgr-&gt;GetNextItem(pidlTemp1); <br>while((m_pPidlMgr-&gt;GetNextItem(pidlTemp2))-&gt;mkid.cb) <br>   pidlTemp2 = m_pPidlMgr-&gt;GetNextItem(pidlTemp2); <br> <br>//at this point, both pidlTemp1 and pidlTemp2 point to the last item in the list <br>if(m_pPidlMgr-&gt;IsValue(pidlTemp1) != m_pPidlMgr-&gt;IsValue(pidlTemp2)) <br>   { <br>   if(m_pPidlMgr-&gt;IsValue(pidlTemp1)) <br>      return 1; <br> <br>   return -1; <br>   } <br> <br>//get the numeric value of the root key <br>m_pPidlMgr-&gt;GetRootKey(pidl1, &amp;hkey1); <br>m_pPidlMgr-&gt;GetRootKey(pidl2, &amp;hkey2); <br> <br>//compare the root keys <br>if(hkey1 != hkey2) <br>   { <br>   return (int)((DWORD)hkey1 - (DWORD)hkey2); <br>   } <br> <br>//now compare the subkey strings <br>m_pPidlMgr-&gt;GetSubKeyText( pidl1,  <br>                           szString1,  <br>                           sizeof(szString1)); <br>m_pPidlMgr-&gt;GetSubKeyText( pidl2,  <br>                           szString2,  <br>                           sizeof(szString2)); <br>nReturn = lstrcmpi(szString1, szString2); <br>if(nReturn) <br>   return nReturn; <br> <br>//now compare the value strings <br>m_pPidlMgr-&gt;GetValueText(  pidl1,  <br>                           szString1,  <br>                           sizeof(szString1)); <br>m_pPidlMgr-&gt;GetValueText(  pidl2,  <br>                           szString2,  <br>                           sizeof(szString2)); <br>return lstrcmpi(szString1, szString2); <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::CreateViewObject() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::CreateViewObject( HWND hwndOwner,  <br>                                             REFIID riid,  <br>                                             LPVOID *ppvOut) <br>{ <br>HRESULT     hr; <br>CShellView  *pShellView; <br> <br>*ppvOut = NULL; <br> <br>pShellView = new CShellView(this, m_pidlRel); <br>if(!pShellView) <br>   return E_OUTOFMEMORY; <br> <br>hr = pShellView-&gt;QueryInterface(riid, ppvOut); <br> <br>pShellView-&gt;Release(); <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::EnumObjects() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::EnumObjects(   HWND hwndOwner,  <br>                                          DWORD dwFlags,  <br>                                          LPENUMIDLIST *ppEnumIDList) <br>{ <br>HRESULT  hr; <br> <br>*ppEnumIDList = NULL; <br> <br>*ppEnumIDList = new CEnumIDList(GetRootKey(), m_lpszSubKey, dwFlags, &amp;hr); <br>if(!*ppEnumIDList) <br>   return hr; <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::GetAttributesOf() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::GetAttributesOf(  UINT uCount,  <br>                                             LPCITEMIDLIST aPidls[],  <br>                                             LPDWORD pdwAttribs) <br>{ <br>UINT  i; <br> <br>*pdwAttribs = (DWORD)-1; <br> <br>for(i = 0; i &lt; uCount; i++) <br>   { <br>   DWORD dwAttribs = 0; <br> <br>   //flags common to all items <br>   dwAttribs |= 0; <br> <br>   //is this item a key? <br>   if(!m_pPidlMgr-&gt;IsValue(m_pPidlMgr-&gt;GetLastItem(aPidls[i]))) <br>      { <br>      dwAttribs |= SFGAO_FOLDER; <br> <br>      //does this item have a sub folder? <br>      if(m_pPidlMgr-&gt;HasSubKeys(GetRootKey(), m_lpszSubKey, aPidls[i])) <br>         dwAttribs |= SFGAO_HASSUBFOLDER; <br>      } <br>    <br>   *pdwAttribs &amp;= dwAttribs; <br>   } <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::GetUIObjectOf() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::GetUIObjectOf( HWND hwndOwner,  <br>                                          UINT uCount,  <br>                                          LPCITEMIDLIST *pPidl,  <br>                                          REFIID riid,  <br>                                          LPUINT puReserved,  <br>                                          LPVOID *ppvReturn) <br>{ <br>*ppvReturn = NULL; <br> <br>if(IsEqualIID(riid, IID_IContextMenu)) <br>   { <br>   CContextMenu   *pcm = new CContextMenu(this, pPidl, uCount); <br> <br>   if(pcm) <br>      { <br>      *ppvReturn = pcm; <br>      return S_OK; <br>      } <br>   } <br> <br>if(uCount != 1) <br>   return E_FAIL; <br> <br>if(IsEqualIID(riid, IID_IExtractIcon)) <br>   { <br>   CExtractIcon   *pei; <br>   LPITEMIDLIST   pidl; <br> <br>   pidl = m_pPidlMgr-&gt;Concatenate(m_pidlRel, pPidl[0]); <br> <br>   pei = new CExtractIcon(pidl); <br> <br>   /* <br>   The temp PIDL can be deleted because the new CExtractIcon either failed or  <br>   made its own copy of it. <br>   */ <br>   m_pPidlMgr-&gt;Delete(pidl); <br> <br>   if(pei) <br>      { <br>      *ppvReturn = pei; <br>      return S_OK; <br>      } <br>    <br>   return E_OUTOFMEMORY; <br>   } <br> <br>#if (_WIN32_IE &gt;= 0x0400) <br>if(IsEqualIID(riid, IID_IQueryInfo)) <br>   { <br>   CQueryInfo     *pqit; <br>   LPITEMIDLIST   pidl; <br> <br>   pidl = m_pPidlMgr-&gt;Concatenate(m_pidlRel, pPidl[0]); <br> <br>   pqit = new CQueryInfo(pidl); <br> <br>   /* <br>   The temp PIDL can be deleted because the new CQueryInfo either failed or  <br>   made its own copy of it. <br>   */ <br>   m_pPidlMgr-&gt;Delete(pidl); <br> <br>   if(pqit) <br>      { <br>      *ppvReturn = pqit; <br>      return S_OK; <br>      } <br>    <br>   return E_OUTOFMEMORY; <br>   } <br>#endif   //#if (_WIN32_IE &gt;= 0x0400) <br> <br>return E_NOINTERFACE; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::GetDisplayNameOf() <br>    <br>**************************************************************************/ <br> <br>#define GET_SHGDN_FOR(dwFlags)         ((DWORD)dwFlags &amp; (DWORD)0x0000FF00) <br>#define GET_SHGDN_RELATION(dwFlags)    ((DWORD)dwFlags &amp; (DWORD)0x000000FF) <br> <br>STDMETHODIMP CShellFolder::GetDisplayNameOf( LPCITEMIDLIST pidl,  <br>                                             DWORD dwFlags,  <br>                                             LPSTRRET lpName) <br>{ <br>TCHAR szText[MAX_PATH]; <br>int   cchOleStr; <br> <br>switch(GET_SHGDN_RELATION(dwFlags)) <br>   { <br>   case SHGDN_NORMAL: <br>      //get the full name <br>      m_pPidlMgr-&gt;GetPidlPath(pidl, szText, sizeof(szText)); <br> <br>      //If the text is NULL and this is a value, get the default item name. <br>      if(!*szText &amp;&amp; m_pPidlMgr-&gt;IsValue(m_pPidlMgr-&gt;GetLastItem(pidl))) <br>         { <br>         LoadString(g_hInst, IDS_DEFAULT, szText, sizeof(szText)); <br>         } <br>      break; <br> <br>   case SHGDN_INFOLDER: <br>      { <br>      LPITEMIDLIST   pidlTemp = m_pPidlMgr-&gt;GetLastItem(pidl); <br> <br>      //get the relative name <br>      m_pPidlMgr-&gt;GetItemText(pidlTemp, szText, sizeof(szText)); <br> <br>      //If the text is NULL and this is a value, get the default item name. <br>      if(!*szText &amp;&amp; m_pPidlMgr-&gt;IsValue(pidlTemp)) <br>         { <br>         LoadString(g_hInst, IDS_DEFAULT, szText, sizeof(szText)); <br>         } <br>      } <br>      break; <br> <br>   default: <br>      return E_INVALIDARG; <br>   } <br> <br>//get the number of characters required <br>cchOleStr = lstrlen(szText) + 1; <br> <br>//allocate the wide character string <br>lpName-&gt;pOleStr = (LPWSTR)m_pMalloc-&gt;Alloc(cchOleStr * sizeof(WCHAR)); <br>if(!lpName-&gt;pOleStr) <br>   return E_OUTOFMEMORY; <br> <br>lpName-&gt;uType = STRRET_WSTR; <br> <br>LocalToWideChar(lpName-&gt;pOleStr, szText, cchOleStr); <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::ParseDisplayName() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::ParseDisplayName( HWND hwndOwner,  <br>                                             LPBC pbcReserved,  <br>                                             LPOLESTR lpDisplayName,  <br>                                             LPDWORD pdwEaten,  <br>                                             LPITEMIDLIST *pPidlNew,  <br>                                             LPDWORD pdwAttributes) <br>{ <br>HRESULT        hr = E_OUTOFMEMORY; <br>LPITEMIDLIST   pidlFull = NULL; <br>DWORD          dwChars = lstrlenW(lpDisplayName) + 1; <br>LPTSTR         pszTemp = (LPTSTR)GlobalAlloc(GPTR, dwChars * sizeof(TCHAR)); <br> <br>if(pszTemp) <br>   { <br>   hr = E_FAIL; <br> <br>   WideCharToLocal(pszTemp, lpDisplayName, dwChars); <br> <br>   if(*pszTemp) <br>      { <br>      LPTSTR         pszNext; <br>      TCHAR          szElement[MAX_PATH]; <br>      int            i; <br>      BOOL           fValue; <br> <br>      //get the root key <br> <br>      pszNext = GetNextRegElement(pszTemp, szElement, ARRAYSIZE(szElement)); <br> <br>      for(i = 0; (-1 != (int)g_ahKey[i]) &amp;&amp; !pidlFull; i++) <br>         { <br>         TCHAR szKeyText[MAX_PATH]; <br> <br>         GetRootKeyText(g_ahKey[i], szKeyText, ARRAYSIZE(szKeyText)); <br> <br>         if(0 == lstrcmpi(szElement, szKeyText)) <br>            { <br>            pidlFull = m_pPidlMgr-&gt;CreateRootKey(g_ahKey[i]); <br>            } <br>         } <br>       <br>      if(pidlFull) <br>         { <br>         LPITEMIDLIST   pidlTemp = NULL; <br>         LPITEMIDLIST   pidlOld = NULL; <br>         HKEY           hKey; <br> <br>         //check to see if the last item is a value or a key <br>         if(NOERROR == RegOpenKeyEx(   g_ahKey[i], <br>                                       pszNext, <br>                                       0, <br>                                       KEY_READ, <br>                                       &amp;hKey)) <br>            { <br>            fValue = FALSE; <br>            RegCloseKey(hKey); <br>            } <br>         else <br>            fValue = TRUE; <br>          <br>         //get the remaining keys <br>         while(pszNext = GetNextRegElement(pszNext, szElement, ARRAYSIZE(szElement))) <br>            { <br>            //if this is the last element, check to see if it is a value or a key <br>            if(!*pszNext &amp;&amp; fValue) <br>               pidlTemp = m_pPidlMgr-&gt;CreateValue(szElement); <br>            else <br>               pidlTemp = m_pPidlMgr-&gt;CreateSubKey(szElement); <br>             <br>            pidlOld = pidlFull; <br>            pidlFull = m_pPidlMgr-&gt;Concatenate(pidlFull, pidlTemp); <br>            m_pPidlMgr-&gt;Delete(pidlOld); <br>            } <br>          <br>         hr = S_OK; <br>         } <br>      } <br>    <br>   GlobalFree((HGLOBAL)pszTemp); <br>   } <br> <br>*pPidlNew = pidlFull; <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::SetNameOf() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CShellFolder::SetNameOf(  HWND hwndOwner,  <br>                                       LPCITEMIDLIST pidl,  <br>                                       LPCOLESTR lpName,  <br>                                       DWORD dw,  <br>                                       LPITEMIDLIST *pPidlOut) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::GetFolderPath() <br>    <br>**************************************************************************/ <br> <br>BOOL CShellFolder::GetFolderPath(LPTSTR lpszOut, DWORD dwOutSize) <br>{ <br>TCHAR    szTemp[MAX_PATH] = TEXT(""); <br>DWORD    dwSize; <br> <br>if(!lpszOut) <br>   return FALSE; <br> <br>*lpszOut = 0; <br> <br>//get the text for the root key <br>GetRootKeyText(m_hKeyRoot, szTemp, sizeof(szTemp)); <br> <br>dwSize = lstrlen(szTemp); <br>if(m_lpszSubKey) <br>   dwSize += lstrlen(m_lpszSubKey) + 1; <br> <br>//is the output buffer big enough? <br>if(dwSize &gt; dwOutSize) <br>   return FALSE; <br> <br>//add the text we already have <br>lstrcpy(lpszOut, szTemp); <br> <br>//add this folder's text if present <br>if(m_lpszSubKey &amp;&amp; *m_lpszSubKey) <br>   { <br>   lstrcat(lpszOut, TEXT("\\")); <br>   lstrcat(lpszOut, m_lpszSubKey); <br>   } <br> <br>return TRUE; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::GetFolderText() <br>    <br>**************************************************************************/ <br> <br>BOOL CShellFolder::GetFolderText(LPTSTR lpszOut, DWORD dwOutSize) <br>{ <br>if(!lpszOut) <br>   return FALSE; <br> <br>*lpszOut = 0; <br> <br>//add this folder's text if present <br>if(m_lpszSubKey &amp;&amp; *m_lpszSubKey) <br>   { <br>   lstrcpyn(lpszOut, m_lpszSubKey, dwOutSize); <br>   } <br> <br>return TRUE; <br>} <br> <br>/************************************************************************** <br> <br>   CShellFolder::GetRootKey() <br>    <br>**************************************************************************/ <br> <br>HKEY CShellFolder::GetRootKey(void) <br>{ <br>HKEY  hkReturn = NULL; <br>CShellFolder   *pTemp = this; <br> <br>while(pTemp) <br>   { <br>   if(pTemp-&gt;m_hKeyRoot) <br>      { <br>      hkReturn = pTemp-&gt;m_hKeyRoot; <br>      break; <br>      } <br>    <br>   pTemp = pTemp-&gt;m_pSFParent; <br>   } <br> <br>return hkReturn; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
