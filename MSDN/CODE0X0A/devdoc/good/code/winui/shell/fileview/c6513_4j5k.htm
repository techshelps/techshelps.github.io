<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILEVIEW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6518"></a>FILEVIEW.CPP</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//    PROGRAM: FILEVIEW.CPP     <br>// <br>//    PURPOSE:   File Viewer Component Object to work with Windows 95 Explorer. <br>// This file contains functions not specific to the nature of <br>// the data to view but contains the non-file-specific DLL <br>// and component object structure.  This can be used for a <br>// custom viewer by making modifications marked with //MODIFY <br>// comments. <br>// <br>//    PLATFORMS:    Windows 95 <br>// <br>//    SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>//Define INITGUIDS once in entire module build <br>#define INITGUIDS <br>#include "fileview.h" <br> <br>#include &lt;initguid.h&gt; <br>#include &lt;shlguid.h&gt; <br>#include "fvtext.h"     //FileViewer specifics <br> <br>//Count number of objects and number of locks. <br>ULONG       g_cObj=0; <br>ULONG       g_cLock=0; <br> <br>//Save this from LibMain <br>HINSTANCE   g_hInst; <br> <br> <br>// <br>//   FUNCTION:     LibMain <br>// <br>//   PURPOSE:   Entry point for a Win32 DLL <br>// <br>extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason <br>    , PVOID pvReserved) <br>    { <br>    if (DLL_PROCESS_DETACH==ulReason) <br>        { <br>        return TRUE; <br>        } <br>    else <br>        { <br>        if (DLL_PROCESS_ATTACH!=ulReason) <br>            return TRUE; <br>        } <br> <br>    g_hInst=hInstance; <br>    return TRUE; <br>    } <br>// <br>//   FUNCTION:     DllGetClassObject <br>// <br>//   PURPOSE:  Provides an IClassFactory for a given CLSID that this DLL is <br>//  registered to support.  This DLL is placed under the CLSID <br>//  in the registration database as the InProcServer.   <br>// <br>//   PARAMETERS:  <br>//       clsID           REFCLSID that identifies the class factory <br>//                  desired.  Since this parameter is passed this <br>//                  DLL can handle any number of objects simply <br>//                 by returning different class factories here <br>//                  for different CLSIDs. <br>// <br>//  riid            REFIID specifying the interface the caller wants <br>//                  on the class object, usually IID_ClassFactory. <br>// <br>//  ppv             PPVOID in which to return the interface pointer. <br>// <br>//   RETURN VALUE: <br>//        HRESULT         NOERROR on success, otherwise an error code. <br>// <br>HRESULT PASCAL DllGetClassObject(REFCLSID rclsid, REFIID riid <br>    , PPVOID ppv) <br>    { <br>    // Warning:: The shell may not have initialized OLE so <br>    // do it here to be sure... <br>    OleInitialize(NULL); <br> <br>    //MODIFY:  Change CLSID_FileViewerText to your own CLSID <br>    if (!IsEqualCLSID(rclsid, CLSID_FileViewerText)) <br>        return ResultFromScode(E_FAIL); <br> <br>    //Check that we can provide the interface <br>    if (!IsEqualIID(riid, IID_IUnknown) <br>        &amp;&amp; !IsEqualIID(riid, IID_IClassFactory)) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    //Return our IClassFactory for our viewer objects <br>    *ppv=(LPVOID)new CFVClassFactory(); <br> <br>    if (NULL==*ppv) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    //AddRef the object through any interface we return <br>    ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br> <br>    return NOERROR; <br>    } <br>// <br>//   FUNCTION: DllCanUnloadNow     <br>// <br>//   PURPOSE:  Answers if the DLL can be freed, that is, if there are no <br>//    references to anything this DLL provides.   <br>// <br>//   RETURN VALUE: <br>//       BOOL            TRUE if nothing is using us, FALSE otherwise. <br>// <br>STDAPI DllCanUnloadNow(void) <br>    { <br>    SCODE   sc; <br> <br>    //Our answer is whether there are any object or locks <br>    sc=(0L==g_cObj &amp;&amp; 0L==g_cLock) ? S_OK : S_FALSE; <br>    return ResultFromScode(sc); <br>    } <br>// <br>//   FUNCTION:     ObjectDestroyed <br>// <br>//   PURPOSE:  Function for the FileViewer object to call when it gets <br>//  destroyed. Since we're in a DLL we only track the number of <br>//  objects here, letting DllCanUnloadNow take care of the rest.  <br>// <br>void PASCAL ObjectDestroyed(void) <br>    { <br>    g_cObj--; <br>    return; <br>    } <br>// <br>//   FUNCTION: CFVClassFactory::CFVClassFactory     <br>// <br>//   PURPOSE:  Constructor <br>// <br>CFVClassFactory::CFVClassFactory(void) <br>    { <br>    m_cRef=0L; <br>    return; <br>    } <br> <br>// <br>//   FUNCTION: CFVClassFactory::~CFVClassFactory     <br>// <br>//   PURPOSE:   Destructor <br>// <br>CFVClassFactory::~CFVClassFactory(void) <br>    { <br>    return; <br>    } <br> <br>// <br>//   FUNCTION:     CFVClassFactory::QueryInterface <br>// <br>STDMETHODIMP CFVClassFactory::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    //Any interface on this object is the object pointer. <br>    if (IsEqualIID(riid, IID_IUnknown) <br>        || IsEqualIID(riid, IID_IClassFactory)) <br>        *ppv=(LPVOID)this; <br> <br>     // If we actually assign an interface to ppv we need to AddRef <br>     // it since we're returning a new pointer. <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br>// <br>//   FUNCTION:     CFVClassFactory::AddRef <br>// <br>STDMETHODIMP_(ULONG) CFVClassFactory::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>// <br>//   FUNCTION:     CFVClassFactory::Release <br>// <br>STDMETHODIMP_(ULONG) CFVClassFactory::Release(void) <br>    { <br>    ULONG           cRefT; <br> <br>    cRefT=--m_cRef; <br> <br>    if (0L==m_cRef) <br>        delete this; <br> <br>    return cRefT; <br>    } <br> <br>// <br>//   FUNCTION:     CFVClassFactory::CreateInstance <br>// <br>//   PURPOSE:    Instantiates a CFileViewer object that will provide the <br>//  IPersistFile and IFileViewer interfaces for use with the Windows 95 Explorer. <br>// <br>//   PARAMETERS:  <br>//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are being used in an aggregation. <br>//  riid            REFIID identifying the interface the caller desires to have for the new object. <br>//  ppvObj          PPVOID in which to store the desired interface pointer for the new object. <br>// <br>//   RETURN VALUE: <br>//   HRESULT         NOERROR if successful, otherwise E_NOINTERFACE <br>//                  if we cannot support the requested interface. <br>// <br>STDMETHODIMP CFVClassFactory::CreateInstance(LPUNKNOWN pUnkOuter <br>    , REFIID riid, PPVOID ppvObj) <br>    { <br>    PCFileViewer        pObj; <br>    HRESULT             hr; <br> <br>    *ppvObj=NULL; <br>    hr=ResultFromScode(E_OUTOFMEMORY); <br> <br>    //Verify that a controlling unknown asks for IUnknown <br>    if (NULL!=pUnkOuter &amp;&amp; !IsEqualIID(riid, IID_IUnknown)) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>     // MODIFY:  If you use a different object than CFileViewer <br>    // be sure to change the name and parameters here.  I do <br>    // recommend that you continue to follow this model, however, <br>    // and just modify CFileViewer as necessary. <br>    //Create the object passing function to notify on destruction. <br>    pObj=new CFileViewer(pUnkOuter, g_hInst, ObjectDestroyed); <br> <br>    if (NULL==pObj) <br>        return hr; <br> <br>    //MODIFY:  Add other parameters to Init as necessary. <br>    hr=pObj-&gt;Init(); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        //Return the requested interface <br>        hr=pObj-&gt;QueryInterface(riid, ppvObj); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //Everything worked:  count the object <br>            g_cObj++; <br>            return NOERROR; <br>            } <br>        } <br> <br>    //Kill the object if anything failed after creation. <br>    delete pObj; <br> <br>    return hr; <br>    } <br>// <br>//   FUNCTION: CFVClassFactory::LockServer     <br>// <br>//   PURPOSE:  Increments or decrements the lock count of the DLL.  If the <br>//  lock count goes to zero and there are no objects, the DLL <br>//  is allowed to unload.  See DllCanUnloadNow. <br>// <br>//   PARAMETERS:  <br>//    fLock           BOOL specifying whether to increment or decrement the lock count. <br>// <br>//   RETURN VALUE: <br>//     HRESULT         NOERROR always <br>// <br>STDMETHODIMP CFVClassFactory::LockServer(BOOL fLock) <br>    { <br>    if (fLock) <br>        g_cLock++; <br>    else <br>        g_cLock--; <br> <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
