<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPERFILE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6525"></a>IPERFILE.CPP</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//PROGRAM: IPERFILE.CPP <br>// <br>//PURPOSE:   IPersistFile interface implementation for a FileViewer. <br>// This interface is written to not generally require modifications <br>// for a custom FileViewer but is written to interact with the <br>// definition for CFileViewer in FVTEXT.H. <br>// <br>//PLATFORMS:Windows 95 <br>// <br>//SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>#include "fileview.h" <br> <br>// <br>//   FUNCTION:CImpIPersistFile::CImpIPersistFile  <br>// <br>//   PURPOSE:  Constructor  <br>// <br>//   PARAMETERS:  <br>//pObj            PCFileViewer of the object we're in. <br>//  pUnkOuter       LPUNKNOWN to which we delegate. <br>// <br>CImpIPersistFile::CImpIPersistFile(PCFileViewer pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br>// <br>//   FUNCTION:  CImpIPersistFile::~CImpIPersistFile <br>// <br>//   PURPOSE:   Destructor <br>// <br>CImpIPersistFile::~CImpIPersistFile(void) <br>    { <br>    return; <br>    } <br>// <br>//   FUNCTIONS: CImpIPersistFile::QueryInterface <br>//  CImpIPersistFile::AddRef <br>//  CImpIPersistFile::Release <br>// <br>//   PURPOSE:    <br>//    IUnknown members for CImpIPersistFile object that only delegate. <br>// <br>STDMETHODIMP CImpIPersistFile::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistFile::AddRef(void) <br>    { <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistFile::Release(void) <br>    { <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br>// <br>//   FUNCTION:  CImpIPersistFile::GetClassID <br>// <br>//   PURPOSE:   Returns the Class ID of this object. <br>// <br>//   PARAMETERS:  <br>// pClsID          LPCLSID in which to store our class ID. <br>// <br>//   RETURN VALUE: <br>// HRESULT         NOERROR always. <br>// <br>STDMETHODIMP CImpIPersistFile::GetClassID(LPCLSID pClsID) <br>    { <br>    *pClsID=m_pObj-&gt;m_clsID; <br>    return NOERROR; <br>    } <br>// <br>//   FUNCTION: CImpIPersistFile::IsDirty <br>// <br>//   PURPOSE:  Always returns ResultFromScode(S_FALSE) for a FileViewer which <br>//   never makes any changes to the file.  <br>// <br>//   RETURN VALUE: <br>//   HRESULT         S_FALSE always <br>// <br>STDMETHODIMP CImpIPersistFile::IsDirty(void) <br>    { <br>    return ResultFromScode(S_FALSE); <br>    } <br>// <br>//   FUNCTION: CImpIPersistFile::Load <br>// <br>//   PURPOSE:  Receives the filename of the path to show in this FileViewer. <br>//  The object need do nothing more than store this path for later <br>//  use in IFileViewer::Show.  <br>// <br>//   PARAMETERS:  <br>//   pszFile         LPCOLESTR of the filename to load. <br>//     grfMode         DWORD flags to use when opening the file. <br>// <br>//   RETURN VALUE: <br>//   HRESULT         NOERROR or a general error value. <br>// <br>STDMETHODIMP CImpIPersistFile::Load(LPCOLESTR pszFile, DWORD grfMode) <br>    { <br>    char        szFile[MAX_PATH]; <br>    LPSTR       psz; <br> <br>     // No modifications are necessary to this code:  it simply <br>     // copies the parameters into the CFileViewer::m_pszPath and <br>     // m_grfMode members for use in IFileViewer::ShowInitialize <br>     // and IFileViewer::Show later on. <br> <br>    //We should never be called twice <br>    if (NULL!=m_pObj-&gt;m_pszPath) <br>    { <br>        // Review:: Make sure everything else is handled correctly <br>        m_pObj-&gt;m_fLoadCalled = FALSE;  // handle error case <br>        m_pObj-&gt;MemFree(m_pObj-&gt;m_pszPath); <br>        m_pObj-&gt;m_pszPath = NULL; <br> <br>    } <br> <br>    if (NULL==pszFile) <br>        { <br>        ODS("IPersistFile::Load called with NULL pointer"); <br>        return ResultFromScode(E_INVALIDARG); <br>        } <br> <br>    //Convert Unicode filename to ANSI <br>    wcstombs(szFile, pszFile, sizeof(szFile)); <br> <br>    psz=(LPSTR)m_pObj-&gt;MemAlloc(lstrlen(szFile)+1); <br> <br>    if (NULL==psz) <br>        { <br>        ODS("IPersistFile::Load failed to allocate duplicate pathname"); <br>        return ResultFromScode(E_OUTOFMEMORY); <br>        } <br> <br>    //Copy the ANSI filename and the mode to use in opening it. <br>    lstrcpy(psz, szFile); <br>    m_pObj-&gt;m_pszPath=psz; <br>    m_pObj-&gt;m_grfMode=grfMode; <br> <br>    //Remember that this function has been called. <br>    m_pObj-&gt;m_fLoadCalled=TRUE; <br>    return NOERROR; <br>    } <br>// <br>//   FUNCTION: CImpIPersistFile::Save <br>// <br>//   PURPOSE:  Not implemented in a FileViewer: since FileViewer objects never <br>//  make changes to a file there is nothing to save.  Parameters <br>//  are irrelevant.  <br>// <br>//   RETURN VALUE: <br>//  HRESULT         Always contains E_NOTIMPL. <br>// <br>STDMETHODIMP CImpIPersistFile::Save(LPCOLESTR pszFile, BOOL fRemember) <br>    { <br>    ODS("IPersistFile::Save called...unexpected"); <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br>// <br>//   FUNCTION:  CImpIPersistFile::SaveCompleted <br>// <br>//   PURPOSE:  Not implemented in a FileViewer.  Parameters are irrelevant.  <br>// <br>//   RETURN VALUE: <br>//   HRESULT         Always contains E_NOTIMPL. <br>// <br>STDMETHODIMP CImpIPersistFile::SaveCompleted(LPCOLESTR pszFile) <br>    { <br>    ODS("IPersistFile::SaveCompleted called...unexpected"); <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br>// <br>//   FUNCTION: CImpIPersistFile::GetCurFile <br>// <br>//   PURPOSE:   Not implemented in a FileViewer.  Normally this function <br>//  would return a copy of the pathname from IPersistFile::Load <br>//  in a piece of memory allocated with the shared allocator <br>//  and stored in *ppszFile.  However, this function will not <br>//  be called in a FileViewer and can be left unimplemented. <br>// <br>//   PARAMETERS:  <br>//  ppszFile        LPOLESTR * into which we store a pointer to <br>//                  the filename that should be allocated with the shared IMalloc. <br>// <br>//   RETURN VALUE: <br>//  HRESULT         NOERROR or a general error value. <br>// <br>STDMETHODIMP CImpIPersistFile::GetCurFile(LPOLESTR *ppszFile) <br>    { <br>    LPOLESTR    psz; <br>    ULONG       cb; <br> <br>     // No modifications are necessary to this code:  it simply <br>     // copies the CFileViewer::m_pszPath string into a piece <br>     // of memory and stores the pointer at *ppszFile. <br>    //Load must be called, of course. <br>    if (m_pObj-&gt;m_fLoadCalled) <br>        { <br>        ODS("IPersistFile::GetCurFile called without IPersistFile::Load"); <br>        return ResultFromScode(E_UNEXPECTED); <br>        } <br> <br>    if (NULL==ppszFile) <br>        { <br>        ODS("IPersistFile::GetCurFile called with NULL pointer"); <br>        return ResultFromScode(E_INVALIDARG); <br>        } <br> <br>    cb=(lstrlen(m_pObj-&gt;m_pszPath)+1)*sizeof(OLECHAR); <br>    psz=(LPOLESTR)m_pObj-&gt;MemAlloc(cb); <br> <br>    if (NULL==psz) <br>        { <br>        ODS("IPersistFile::GetCurFile failed to allocate duplicate pathname"); <br>        return ResultFromScode(E_OUTOFMEMORY); <br>        } <br> <br>    //Copy the ANSI filename to the new memory, converting to Unicode <br>    mbstowcs(psz, m_pObj-&gt;m_pszPath, cb); <br> <br>    //Save the pointer which is not caller's responsibility <br>    *ppszFile=psz; <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
