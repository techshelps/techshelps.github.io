<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FVPROC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6521"></a>FVPROC.CPP</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//PROGRAM:FVPROC.CPP <br>// <br>//PURPOSE:  Window procedures for main window and About box of the <br>// sample FileViewer for text files. <br>// <br>//PLATFORMS:Windows 95 <br>// <br>//SPECIAL INSTRUCTIONS: N/A <br>// <br>//Always include the master FileViewer source include file here. <br>#include "fileview.h" <br> <br>// <br>//   FUNCTION:  FileViewerFrameProc <br>// <br>//   PURPOSE:  Standard window procedure for the text file viewer frame window. <br>//  Processes menu commands, acclerators, and handles resizing of <br>//  the window   <br>// <br>long WINAPI FileViewerFrameProc(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    LONG            lRet; <br>    PCFileViewer    pObj; <br>    LPTOOLTIPTEXT   pTTT; <br> <br>    //This is invalid until WM_NCCREATE is called. <br>    pObj=(PCFileViewer)GetWindowLong(hWnd, FVWL_OBJECTPOINTER); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            //Save the the CFileViewer object pointer we're passed <br>            lRet=(LONG)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, FVWL_OBJECTPOINTER, lRet); <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br>        case WM_COMMAND: <br>            pObj-&gt;OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND)lParam); <br>            break; <br> <br>        case WM_NOTIFY: <br>             // The toolbar, created with TBSTYLE_TOOLTIPS, will <br>             // send notifications for each button.  lParam will <br>             // be an LPTOOLTIPTEXT in such a case, but even when <br>             // the structure is something different it will always <br>             // have a hdr field of type NMHDR as the first field <br>             // which we use to see if it comes from the toolbar. <br>             // The notification we want is TTN_NEEDTEXT. <br>            pTTT=(LPTOOLTIPTEXT)lParam; <br> <br>            if (NULL==pTTT) <br>                return 0L; <br> <br>            if (TTN_NEEDTEXT==pTTT-&gt;hdr.code) <br>                pTTT-&gt;lpszText=pObj-&gt;PszToolTip(pTTT-&gt;hdr.idFrom); <br> <br>            return 0L; <br> <br> <br>        case WM_CLOSE: <br>            DestroyWindow(hWnd); <br>            break; <br> <br>    case WM_DESTROY: <br>            if (NULL != pObj) <br>            { <br>                ODSu("FileViewerFrameProc Quit? ", pObj-&gt;m_fPostQuitMsg); <br>                if (pObj-&gt;m_fPostQuitMsg) <br>                    PostQuitMessage(0); <br>                pObj-&gt;m_fPostQuitMsg = TRUE;    // One shot that it did not... <br> <br>                if (pObj-&gt;m_hWnd == hWnd) <br>                    pObj-&gt;m_hWnd = NULL;        // Don't try to destory this again... <br>            } <br>            break; <br> <br>        case WM_SIZE: <br>            //Resize frame tools and viewport <br>            pObj-&gt;ChildrenResize(); <br>            break; <br> <br>        case WM_MENUSELECT: <br>            //Win32 Parameters are wItem, wFlags, and hMenu <br>            pObj-&gt;m_pSH-&gt;MenuSelect(LOWORD(wParam) <br>                , HIWORD(wParam), (HMENU)lParam); <br>            break; <br> <br>        case WM_DROPFILES: <br>            // We have a new file dropped on us so we need to pass this <br>            // information back to the caller of the viewer... <br>            pObj-&gt;DropFiles((HDROP)wParam); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br>// <br>//   FUNCTION:  ViewportWndProc <br>// <br>//   PURPOSE: Window procedure for the viewport window.  The viewport in <br>//  this example just does draws the text into itself using an <br>//  edit control.   <br>// <br>//   COMMENTS: <br>//   This will need to be modified for your file viewer. <br>// <br>long WINAPI ViewportWndProc(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    LONG            lRet; <br>    PCFileViewer    pObj; <br>    PAINTSTRUCT     ps; <br> <br>    //This is invalid until WM_NCCREATE is called. <br>    pObj=(PCFileViewer)GetWindowLong(hWnd, VPWL_OBJECTPOINTER); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            //Save the the CFileViewer object pointer we're passed <br>            lRet=(LONG)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, VPWL_OBJECTPOINTER, lRet); <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br>        case WM_PAINT: <br>            BeginPaint(hWnd, &amp;ps); <br> <br>            if (NULL!=pObj-&gt;m_hMemText) <br>                { <br>                LPSTR       psz; <br>                RECT        rc; <br>                HFONT       hFont; <br> <br>                GetClientRect(hWnd, &amp;rc); <br> <br>                SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT)); <br>                SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW)); <br>                hFont=(HFONT)SelectObject(ps.hdc, pObj-&gt;m_hFont); <br> <br>                psz=(LPSTR)GlobalLock(pObj-&gt;m_hMemText); <br> <br>                 // We can use the client area rectangle here for <br>                 // drawing since we also use DT_NOCLIP, so we'll <br>                 // always draw all over the client area. <br>                OffsetRect(&amp;rc, -pObj-&gt;m_xPos, -pObj-&gt;m_yPos); <br>                DrawText(ps.hdc, psz, -1, &amp;rc, DT_LEFT <br>                    | DT_NOCLIP| DT_EXPANDTABS); <br> <br>                GlobalUnlock(pObj-&gt;m_hMemText); <br>                SelectObject(ps.hdc, hFont); <br>                } <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>             // If this message is already displayed, CStatusHelper <br>             // will just ignore this call and return very fast. <br>            pObj-&gt;m_pSH-&gt;MessageDisplay(ID_MSGCHOOSEOPEN); <br>            break; <br> <br>        case WM_RBUTTONDOWN: <br>            { <br>            HMENU           hMenu, hMenuRes; <br>            POINT           pt; <br>            UINT            i, cItems; <br> <br>            //Load our context menu. <br>            hMenuRes=LoadMenu(pObj-&gt;m_hInst <br>                , MAKEINTRESOURCE(IDR_MENUVIEWPORT)); <br> <br>            if (NULL==hMenuRes) <br>                break; <br> <br>             // Make a copy popup menu because you cannot <br>             // use a resource-loaded menu with TrackPopupMenu. <br>            cItems=GetMenuItemCount(hMenuRes); <br>            hMenu=CreatePopupMenu(); <br> <br>            for (i=0; i &lt; cItems; i++) <br>                { <br>                char    szItem[80]; <br>                int     id, uFlags; <br> <br>                GetMenuString(hMenuRes, i, szItem, sizeof(szItem) <br>                    , MF_BYPOSITION); <br>                id=GetMenuItemID(hMenuRes, i); <br> <br>                uFlags=(0==id) ? MF_SEPARATOR : MF_STRING | MF_ENABLED; <br>                AppendMenu(hMenu, uFlags, id, szItem); <br>                } <br> <br>            DestroyMenu(hMenuRes); <br> <br>            pt.x=LOWORD(lParam); <br>            pt.y=HIWORD(lParam); <br>            ClientToScreen(hWnd, &amp;pt); <br> <br>            //Messages sent to frame window from this menu. <br>            TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON <br>                , pt.x, pt.y, 0, pObj-&gt;m_hWnd, NULL); <br> <br>            DestroyMenu(hMenu); <br>            } <br>            break; <br> <br>        case WM_HSCROLL: <br>        case WM_VSCROLL: <br>            { <br>            int             iTmp; <br>            UINT            idScroll; <br>            SCROLLINFO      si; <br> <br>            idScroll=(WM_HSCROLL==iMsg) ? SB_HORZ : SB_VERT; <br> <br>            si.cbSize = sizeof(SCROLLINFO); <br>            si.fMask = SIF_PAGE | SIF_POS | SIF_RANGE; <br>            GetScrollInfo(hWnd, idScroll, &amp;si); <br> <br>            iTmp=si.nPos; <br> <br>            switch (LOWORD(wParam)) <br>                { <br>                case SB_LINEUP:     si.nPos -= 20;  break; <br>                case SB_PAGEUP:     si.nPos -=si.nPage;  break; <br>                case SB_LINEDOWN:   si.nPos += 20;  break; <br>                case SB_PAGEDOWN:   si.nPos +=si.nPage;  break; <br> <br>                case SB_THUMBPOSITION: <br>                case SB_THUMBTRACK: <br>                    si.nPos=HIWORD(wParam); <br>                    break; <br>                } <br> <br>            si.nPos=max(si.nMin, min(si.nPos, si.nMax)); <br> <br>            if (si.nPos!=iTmp) <br>                { <br>                //Set the new position and scroll the window <br>                SetScrollPos(hWnd, idScroll, si.nPos, TRUE); <br> <br>                if (SB_HORZ==idScroll) <br>                    { <br>                    pObj-&gt;m_xPos=si.nPos; <br>                    ScrollWindow(hWnd, iTmp-si.nPos, 0, NULL, NULL); <br>                    } <br>                else <br>                    { <br>                    pObj-&gt;m_yPos=si.nPos; <br>                    ScrollWindow(hWnd, 0, iTmp-si.nPos, NULL, NULL); <br>                    } <br> <br>                UpdateWindow(hWnd); <br>                } <br>            } <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br>// <br>//   FUNCTION: AboutProc <br>// <br>//   PURPOSE:  Dialog procedure for the omnipresent About box.  <br>// <br>BOOL APIENTRY AboutProc(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>                { <br>                case IDOK: <br>                    EndDialog(hDlg, TRUE); <br>                    break; <br>                } <br>            break; <br> <br>        case WM_CLOSE: <br>            EndDialog(hDlg, FALSE); <br>            break; <br>        } <br>    return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
