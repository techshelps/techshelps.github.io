<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FVTEXT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6522"></a>FVTEXT.CPP</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//    PROGRAM: FVTEXT.CPP         <br>// <br>//    PURPOSE:  Sample FileViewer for text files to integrate with the Explorer.  This sample serves as a  <br>//    framework for custom viewers.  Initialization and other low-use functions are in FVMISC.CPP. <br>// <br>//    PLATFORMS:    Windows 95 <br>// <br>//    FUNCTIONS:     <br>//    <br>// <br>//    SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>#include "fileview.h" <br> <br>// <br>//   FUNCTION: CFileViewer::CFileViewer     <br>// <br>//   PURPOSE: Constructor for the CFileViewer class.  Initializes all variables. <br>// <br>//   PARAMETERS:  <br>//    pUnkOuter - LPUNKNOWN of a controlling unknown. <br>//    hInst - HINSTANCE of the module we're in <br>//    pfnDestroy - LPFNDESTROYED to call when an object is destroyed. <br>// <br>CFileViewer::CFileViewer(LPUNKNOWN pUnkOuter, HINSTANCE hInst, PFNDESTROYED pfnDestroy) <br>{ <br>    m_cRef=0; <br>    m_pUnkOuter=pUnkOuter; <br>    m_hInst=hInst; <br>    m_pfnDestroy=pfnDestroy; <br>    m_lpfsi = NULL; <br> <br>    //MODIFY:  Change this CLSID to your own <br>    m_clsID=CLSID_FileViewerText; <br> <br>    m_pszPath=NULL; <br>    m_grfMode=0L; <br>    m_fLoadCalled=FALSE; <br>    m_fShowInit=FALSE; <br>    m_fPostQuitMsg=TRUE; <br> <br>    //NULL any contained interfaces initially. <br>    m_pIPersistFile=NULL; <br>    m_pIFileViewer=NULL; <br>    m_pvsi = NULL; <br> <br>    m_pST=NULL; <br>    m_pSH=NULL; <br>    m_fClassReg=FALSE; <br> <br>    m_hWnd=NULL; <br>    m_hWndOld = NULL; <br>    m_hWndToolbar=NULL; <br>    m_hWndStatus=NULL; <br>    m_hWndViewport=NULL; <br> <br>    //MODIFY:  Initalize viewer-specific values <br>    m_hMemText=NULL; <br>    m_hFont=NULL; <br>    m_xPos=0; <br>    m_yPos=0; <br>    return; <br>} <br> <br>// <br>//   FUNCTION:  CFileViewer::~CFileViewer <br>// <br>//   PURPOSE:   Destructor:deletes all the windows, all allocations, cleans up objects, and <br>//   frees the filename copied in IPersistFile::Load. <br>// <br>CFileViewer::~CFileViewer(void) <br>{ <br>    //MODIFY:  m_hMemText and m_hFont are viewer-specific. <br>    if (NULL!=m_hMemText) <br>        GlobalFree(m_hMemText); <br> <br>    if (NULL!=m_hFont) <br>        DeleteObject(m_hFont); <br> <br>    //MODIFY:  Do any other viewer-specific cleanup <br>    //Destroying the parent destroys the children as well <br>    if (NULL!=m_hWnd) <br>    { <br>        m_fPostQuitMsg = FALSE;    // Destroy from here implies not from our loop <br>        DestroyWindow(m_hWnd); <br>    } <br> <br>     // Unregistering the classes is important for DLL's because we <br>     // should not assume that whoever loaded us (the task) is going <br>     // to quit anytime soon and unregister the class.  Normally <br>     // QVStub is going to quit, but a test app like TestFV does not <br>     // which can cause some development headaches. <br>    if (m_fClassReg) <br>        { <br>        UnregisterClass(String(IDS_CLASSFRAME),    m_hInst); <br>        UnregisterClass(String(IDS_CLASSVIEWPORT), m_hInst); <br>        } <br> <br>    if (NULL!=m_pSH) <br>        delete m_pSH; <br> <br>    if (NULL!=m_pST) <br>        delete m_pST; <br> <br>    //Free the pathname string from IPersistFile::Load if we got one <br>    MemFree(m_pszPath); <br> <br>    //Free contained interfaces. <br>    if (NULL!=m_pIPersistFile) <br>        delete m_pIPersistFile; <br> <br>    if (NULL!=m_pIFileViewer) <br>        delete m_pIFileViewer; <br>    if (NULL!=m_lpfsi) <br>        m_lpfsi-&gt;Release(); <br> <br>    return; <br>} <br> <br>// <br>//   FUNCTION: CFileViewer::FileShowInit     <br>// <br>//   PURPOSE:Provides the implementation of IFileViewer::ShowInitialize that performs  <br>//   anything subject to failure. This function creates the main window, initializes the toolbar, <br>//   initializes the status bar controls, sets the initial menu state, creates the viewport window, and <br>//   loads the accelerators. <br>// <br>//   RETURN VALUE: <br>// <br>//   HRESULT         NOERROR or an appropriate error code. <br>// <br>STDMETHODIMP CFileViewer::FileShowInit(LPFILEVIEWERSITE lpfsi) <br>{ <br>    HRESULT         hr; <br>    HMENU           hMenu; <br> <br>    //MODIFY:  Do pre-show initialization here. <br>    if (m_lpfsi != lpfsi) <br>    { <br>        if (NULL!=m_lpfsi) <br>            m_lpfsi-&gt;Release(); <br> <br>        m_lpfsi = lpfsi; <br>        lpfsi-&gt;AddRef(); <br>    } <br> <br>    //Default error code <br>    hr=ResultFromScode(E_OUTOFMEMORY); <br> <br>    //Create the main window passing "this" to it <br>    m_hWndOld = m_hWnd; <br>    m_hWnd=CreateWindow(String(IDS_CLASSFRAME) <br>        , String(IDS_CAPTION), WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW <br>        | WS_CLIPCHILDREN, CW_USEDEFAULT , CW_USEDEFAULT, 350, 450 <br>        , NULL, NULL, m_hInst, (LPVOID)this); <br> <br>    if (NULL==m_hWnd) <br>        { <br>        ODS("CFileViewer::FileShow failed to create main window."); <br>        return hr; <br>        } <br> <br>    // Let us accept files. <br>    DragAcceptFiles(m_hWnd, TRUE); <br> <br>    if (!FInitFrameControls()) <br>        { <br>        ODS("CFileViewer::FileShow failed to create frame tools."); <br>        return hr; <br>        } <br> <br>    //Set initial view menu item checks <br>    hMenu=GetMenu(m_hWnd); <br>    CheckMenuItem(hMenu, IDM_VIEWTOOLBAR, MF_BYCOMMAND | MF_CHECKED); <br>    CheckMenuItem(hMenu, IDM_VIEWSTATUSBAR, MF_BYCOMMAND | MF_CHECKED); <br> <br>    m_fToolsVisible=TRUE; <br>    m_fStatusVisible=TRUE; <br> <br>    m_pSH-&gt;MessageDisplay(ID_MSGREADY); <br> <br>     // ViewportResize puts the viewport window created here <br>     // in the right location, so we don't have to worry <br>     // about initial position. <br>    //BUGBUG:  Not getting proportional thumbs here. <br> <br>    m_hWndViewport=CreateWindowEx(WS_EX_CLIENTEDGE <br>        , String(IDS_CLASSVIEWPORT), "Viewport" <br>        , WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL <br>        , 0, 0, 100, 100, m_hWnd, (HMENU)ID_VIEWPORT <br>        , m_hInst, (LPVOID)this); <br> <br>    if (NULL==m_hWndViewport) <br>        { <br>        ODS("CFileViewer::FileShow failed to create viewport."); <br>        return hr; <br>        } <br> <br>    ViewportResize(); <br> <br>     // Go load the file.  This means pulling into memory whatever <br>     // is necessary for the initial display. <br>    hr=FileLoad(); <br> <br>    if (FAILED(hr)) <br>        { <br>        ODS("CFileViewer::FileShow failed to load file."); <br>        return hr; <br>        } <br> <br>    m_hAccel=LoadAccelerators(m_hInst <br>        , MAKEINTRESOURCE(IDR_ACCELERATORS)); <br> <br>    //Tell IFileViewer::Show it's OK to call it <br>    m_fShowInit=TRUE; <br>    return NOERROR; <br>} <br> <br>// <br>//   FUNCTION:      CFileViewer::FileShow <br>// <br>//   PURPOSE: Displays the viewing window and enters a message loop.  This function must not fail.   <br>// <br>//   PARAMETERS:  <br>//   pvsi - LPFVSHOWINFO indicates how to initially show the FileViewer window. <br>// <br>//   RETURN VALUE: <br>//    HRESULT  - NOERROR always <br>// <br>STDMETHODIMP CFileViewer::FileShow(LPFVSHOWINFO pvsi) <br>{ <br>    MSG             msg; <br> <br>    // We need to handle the case where the ShowInitialize may have <br>    // failed and we set the hwnd to NULL and the hwndOld is not NULL. <br>    // and the FVSIF_NEWFAILED is set.  In this case set the hwnd Back <br>    // to the old hwnd... <br>    if ((pvsi-&gt;dwFlags &amp; FVSIF_NEWFAILED) &amp;&amp; (m_hWnd == NULL)) <br>    { <br>        m_hWnd = m_hWndOld; <br>    } <br> <br>    if (!IsWindow (m_hWnd)) <br>            return ResultFromScode(E_UNEXPECTED); <br> <br>    m_pvsi = pvsi; <br> <br>    // If the new failed flag was passed to us we know that we got here <br>    // because we tried to view a file and it failed, so simply go back <br>    // to message loop... <br>    if ((pvsi-&gt;dwFlags &amp; FVSIF_NEWFAILED) == 0) <br>    { <br>        if (pvsi-&gt;dwFlags &amp; FVSIF_RECT) <br>            SetWindowPos(m_hWnd, NULL, pvsi-&gt;rect.left, pvsi-&gt;rect.top, <br>                    pvsi-&gt;rect.right - pvsi-&gt;rect.left, pvsi-&gt;rect.bottom - pvsi-&gt;rect.top, <br>                    SWP_NOZORDER | SWP_NOACTIVATE); <br>        ShowWindow(m_hWnd, pvsi-&gt;iShow); <br> <br>        if (SW_HIDE!=pvsi-&gt;iShow) <br>        { <br>            SetForegroundWindow(m_hWnd); <br>            UpdateWindow(m_hWnd); <br>        } <br> <br>        // If there is an Old window destroy it now <br>        // It would be nicer to reuse the window! <br>        if (pvsi-&gt;dwFlags &amp; FVSIF_PINNED) <br>        { <br>            m_lpfsi-&gt;SetPinnedWindow(NULL); <br>            m_lpfsi-&gt;SetPinnedWindow(m_hWnd); <br> <br>            HMENU hMenu=GetMenu(m_hWnd); <br>            CheckMenuItem(hMenu, IDM_VIEWREPLACE, MF_BYCOMMAND|MF_CHECKED); <br>        } <br> <br>        if (SW_HIDE!=pvsi-&gt;iShow) <br>            UpdateWindow(m_hWnd); <br> <br>        if ((NULL!=m_hWndOld) &amp;&amp; IsWindow(m_hWndOld)) <br>        { <br>            ODS("CFileViewer::FileShow Destroy Previous hwnd"); <br>            m_fPostQuitMsg = FALSE; // Don't destroy the queue for this one. <br>            DestroyWindow(m_hWndOld); <br>            m_hWndOld = NULL; <br>        } <br> <br>        if (NULL!=pvsi-&gt;punkRel) <br>        { <br>            ODSlu("CFileViewer::FileShow Release of previous viewers punkRel(%x)", pvsi-&gt;punkRel); <br>            pvsi-&gt;punkRel-&gt;Release(); <br>            pvsi-&gt;punkRel = NULL; <br>        } <br>    } <br> <br>    while (GetMessage(&amp;msg, NULL, 0,0 )) <br>        { <br>        if (!TranslateAccelerator(m_hWnd, m_hAccel, &amp;msg)) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        // If there is a new file bail out now. <br>        if (m_pvsi-&gt;dwFlags &amp; FVSIF_NEWFILE) <br>            break; <br>        } <br> <br>    //MODIFY:  Perform cleanup here. <br>    return NOERROR; <br>} <br> <br>// <br>//   FUNCTION:     CFileViewer::PrintTo <br>// <br>//   PURPOSE:  Provides the implementation of IFileViewer::PrintTo that <br>//  prints the file to a given printer driver, suppressing UI <br>//  if necessary.  This function currently does nothing. <br>// <br>//   PARAMETERS:  <br>//    pszDriver - LPSTR with the path of the driver to use.  If NULL, use the default driver. <br>//    fSuppressUI - BOOL indicating if this function is to show any  UI or not. <br>// <br>//   RETURN VALUE: <br>//   HRESULT - NOERROR on success, error code otherwise. <br>// <br>STDMETHODIMP CFileViewer::PrintTo(LPSTR pszDriver, BOOL fSuppressUI) <br>    { <br>    //Printing not implemented in this sample <br>    //MODIFY:  Add your printing code here. <br>    return ResultFromScode(E_NOTIMPL); <br>} <br> <br>// <br>//   FUNCTION:      CFileViewer::FileLoad <br>// <br>//   PURPOSE: Loads the file with the path in m_pszPath and places the <br>//   contents into the m_hWndViewport window.  This function can load <br>//   a compound file with a "Text" stream or text from a .TXT file. <br>// <br>HRESULT CFileViewer::FileLoad(void) <br>{ <br>    HRESULT     hr; <br>    HGLOBAL     hMem=NULL; <br>    LPSTR       psz; <br>    OLECHAR     szwFile[512]; <br> <br>    //MODIFY: Load your own file type here. <br>    if (NULL==m_pszPath) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>     // This FileViewer is registered for a .TXT extension that <br>     // is either in a compound file (single stream called "Text" <br>     // or in a flat text file.  This sample is meant to show <br>     // how to open and work with both types of files. <br>    //Make Unicode copy of filename <br>    mbstowcs(szwFile, m_pszPath, sizeof(szwFile)); <br> <br>     // CAREFUL:  StgIsStorageFile returns S_FALSE if not-- <br>     //           don't use SUCCEEDED to test the return value! <br>    if (NOERROR==StgIsStorageFile(szwFile)) <br>        { <br>        LPSTORAGE   pIStorage=NULL; <br>        LPSTREAM    pIStream=NULL; <br>        STATSTG     stat; <br> <br>        //Case for a compound file, open it and the text stream <br>        hr=StgOpenStorage(szwFile, NULL, m_grfMode, NULL, 0 <br>            , &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            { <br>            ODS("CFileViewer::FileLoad failed StgOpenStorage"); <br>            return hr; <br>            } <br> <br>        mbstowcs(szwFile, "Text", sizeof(szwFile)); <br> <br>        hr=pIStorage-&gt;OpenStream(szwFile, 0, STGM_DIRECT | STGM_READ <br>            | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //Determine the amount of text and allocate memory <br>            hr=pIStream-&gt;Stat(&amp;stat, STATFLAG_NONAME); <br> <br>            if (SUCCEEDED(hr)) <br>                { <br>                hMem=GlobalAlloc(GHND, stat.cbSize.LowPart+1); <br> <br>                if (NULL!=hMem) <br>                    { <br>                     // Now load the text into the controls. <br>                     // GlobalLock will always work because we <br>                     // allocated at least 1 byte. <br>                    psz=(LPSTR)GlobalLock(hMem); <br>                    hr=pIStream-&gt;Read((LPVOID)psz <br>                        , stat.cbSize.LowPart, NULL); <br>                    GlobalUnlock(hMem); <br>                    } <br>                else <br>                    { <br>                    ODS("CFileViewer::FileLoad failed to allocate memory"); <br>                    hr=ResultFromScode(E_OUTOFMEMORY); <br>                    } <br>                } <br> <br>            pIStream-&gt;Release(); <br>            } <br>        else <br>            { <br>            ODS("CFileViewer::FileLoad failed StgOpenStorage"); <br>            } <br> <br>        pIStorage-&gt;Release(); <br>        } <br>    else <br>        { <br>        int         hFile=NULL; <br>        OFSTRUCT    of; <br>        DWORD       cb, cbRead; <br> <br>         // Case for straight text file, open and read.  In opening <br>         // the file, mask off the upper word or m_grfMode which <br>         // contains the compound file specific flags.  The lower <br>         // word has OpenFile flags (consistent between <br>         // StgOpenStorage and OpenFile). <br>        hFile=OpenFile(m_pszPath, &amp;of <br>            , (UINT)(m_grfMode &amp; 0x0000FFFF)); <br> <br>        if (HFILE_ERROR==hFile) <br>            { <br>            ODS("CFileViewer::FileLoad failed OpenFile"); <br>            return ResultFromScode(STG_E_FILENOTFOUND); <br>            } <br> <br>        //Scan to end and then back to determine file size. <br>        cb=_llseek(hFile, 0L, 2); <br>        _llseek(hFile, 0L, 0); <br> <br>        hMem=GlobalAlloc(GHND, cb+1); <br> <br>        if (NULL!=hMem) <br>            { <br>             // Now load the text into the controls.  GlobalLock will <br>             // always work because we allocated at least 1 byte <br>            psz=(LPSTR)GlobalLock(hMem); <br>            cbRead=_lread(hFile, psz, (UINT)cb); <br>            GlobalUnlock(hMem); <br> <br>            hr=ResultFromScode((cb==cbRead) ? S_OK : STG_E_READFAULT); <br>            } <br>        else <br>            { <br>            ODS("CFileViewer::FileLoad failed to allocate memory"); <br>            hr=ResultFromScode(E_OUTOFMEMORY); <br>            } <br> <br>        _lclose(hFile); <br>        } <br> <br>    //Set edit control to read-only:  no modifications allowed! <br>    if (SUCCEEDED(hr) &amp;&amp; NULL!=hMem) <br>        { <br>        if (NULL!=m_hMemText) <br>            GlobalFree(m_hMemText); <br> <br>        //Make the text current and repaint. <br>        m_hMemText=hMem; <br>        InvalidateRect(m_hWndViewport, NULL, TRUE); <br>        UpdateWindow(m_hWndViewport); <br>        } <br> <br>    return hr; <br>} <br> <br>// <br>//   FUNCTION:     CFileViewer::OnCommand <br>// <br>//   PURPOSE: WM_COMMAND message handler for a FileViewer window.   <br>// <br>//   PARAMETERS:  <br>//       wID             WORD ID of the command. <br>//  wCode           WORD notification code with the command <br>//  hWndCtl         HWND sending the message (if a control) <br>// <br>void CFileViewer::OnCommand(WORD wID, WORD wCode, HWND hWndCtl) <br>{ <br>    //MODIFY:  Do your command processing here. <br>    switch (wID) <br>        { <br>        case IDM_FILEOPENAS: <br>            if (FOpenAs()) <br>                PostMessage(m_hWnd, WM_CLOSE, 0, 0L); <br>            break; <br> <br>        case IDM_FILEPAGESETUP: <br>            //Not implemented in this sample <br>            break; <br> <br>        case IDM_FILEPRINT: <br>            //Not implemented in this sample <br>            break; <br> <br>        case IDM_FILEEXIT: <br>            PostMessage(m_hWnd, WM_CLOSE, 0, 0L); <br>            break; <br> <br>        case IDM_VIEWTOOLBAR: <br>            m_fToolsVisible=!m_fToolsVisible; <br> <br>            CheckMenuItem(GetMenu(m_hWnd), IDM_VIEWTOOLBAR <br>                , MF_BYCOMMAND | (m_fToolsVisible <br>                ? MF_CHECKED : MF_UNCHECKED)); <br> <br>            ShowWindow(m_hWndToolbar, m_fToolsVisible <br>                ? SW_SHOW : SW_HIDE); <br> <br>            //Resize the viewport window <br>            ViewportResize(); <br>            break; <br> <br>        case IDM_VIEWSTATUSBAR: <br>            m_fStatusVisible=!m_fStatusVisible; <br> <br>            CheckMenuItem(GetMenu(m_hWnd), IDM_VIEWSTATUSBAR <br>                , MF_BYCOMMAND | (m_fStatusVisible <br>                ? MF_CHECKED : MF_UNCHECKED)); <br> <br>            ShowWindow(m_hWndStatus, m_fStatusVisible <br>                ? SW_SHOW : SW_HIDE); <br> <br>            //Resize the viewport window <br>            ViewportResize(); <br>            break; <br>        case IDM_VIEWREPLACE: <br>            // Switch the Replace mode <br>            ReplaceWindowModeChange(); <br>            break; <br>        case IDM_VIEWFONT: <br>            FontChange(VIEWFONT_SELECT); <br>            break; <br> <br>        case IDM_VIEWFONTINCREASE: <br>            FontChange(VIEWFONT_INCREASESIZE); <br>            break; <br> <br>        case IDM_VIEWFONTDECREASE: <br>            FontChange(VIEWFONT_DECREASESIZE); <br>            break; <br> <br>        case IDM_HELPCONTENTS: <br>            MessageBox(m_hWnd, String(IDS_NOHELP) <br>                , String(IDS_CAPTION), MB_OK); <br>            break; <br> <br>        case IDM_HELPABOUT: <br>            DialogBox(m_hInst, MAKEINTRESOURCE(IDD_ABOUT), m_hWnd <br>                , (DLGPROC)AboutProc); <br>            break; <br>        } <br> <br>    return; <br>} <br> <br>// <br>//   FUNCTION:  CFileViewer::ChildrenResize     <br>// <br>//   PURPOSE:    Handles the situation when the FileViewer frame window was <br>//   resized. The toolbar, status bar and viewport are resized via a call to the  <br>//   the ViewportResize function. <br>// <br>//   COMMENTS: <br>//   Note that the toolbar and status bar are resized even when <br>//   they are not visible so we can just reshow them again when <br>//   necessary. <br>// <br>void CFileViewer::ChildrenResize(void) <br>{ <br>    RECT        rc; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    //We resize toolbar and status bar regardless of visibility <br>    SetWindowPos(m_hWndToolbar, NULL, 0, 0 <br>        , rc.right-rc.left, m_cyTools <br>        , SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    SetWindowPos(m_hWndStatus, NULL, 0, rc.bottom-m_cyStatus <br>        , rc.right-rc.left, m_cyStatus <br>        , SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    ViewportResize(); <br>    return; <br>} <br> <br>// <br>//   FUNCTION: CFileViewer::ViewportResize     <br>// <br>//   PURPOSE: Updates the size and position of the viewport window <br>//   depending on visibility of the toolbar and status bar.   <br>// <br>void CFileViewer::ViewportResize(void) <br>{ <br>    RECT        rc; <br>    UINT        dy1, dy2; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    dy1=m_fToolsVisible  ? m_cyTools  : 0; <br>    dy2=m_fStatusVisible ? m_cyStatus : 0; <br> <br>    //We resize toolbar and status bar regardless of visibility <br>    SetWindowPos(m_hWndViewport, NULL, 0, dy1 <br>        , rc.right-rc.left, rc.bottom-rc.top-dy1-dy2 <br>        , SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    ViewportScrollSet(); <br>    return; <br>} <br> <br>// <br>//   FUNCTION:     CFileViewer::ViewportScrollSet <br>// <br>//   PURPOSE:  Updates the scrollbar ranges in the viewport depending on <br>//   the current font in use and the size of the window.   <br>// <br>void CFileViewer::ViewportScrollSet(void) <br>{ <br>    RECT        rc, rcFmt; <br>    LPSTR       psz; <br>    HDC         hDC; <br>    HFONT       hFont; <br>    SCROLLINFO  si; <br> <br>    if (NULL==m_hMemText) <br>        return; <br> <br>    psz=(LPSTR)GlobalLock(m_hMemText); <br>    hDC=GetDC(m_hWndViewport); <br>    hFont=(HFONT)SelectObject(hDC, m_hFont); <br> <br>     // Set initially large formatting rectangle, and let <br>     // DrawText walk all over it. <br>    SetRect(&amp;rcFmt, 0, 0, 32767, 32767); <br>    DrawText(hDC, psz, -1, &amp;rcFmt, DT_LEFT | DT_CALCRECT <br>        | DT_EXPANDTABS); <br> <br>    SelectObject(hDC, hFont); <br>    ReleaseDC(m_hWndViewport, hDC); <br> <br>    GetClientRect(m_hWndViewport, &amp;rc); <br> <br>    //Scroll ranges are draw rect minus visible rect, +1 for buffer <br>    // First set the horizontal scrollbars information... <br>    si.cbSize = sizeof(si); <br>    si.fMask = SIF_RANGE | SIF_POS | SIF_PAGE; <br>    si.nMin = 0; <br>    si.nMax = (rcFmt.right-rcFmt.left)+1; <br>    si.nPage = rc.right; <br>    si.nPos = 0; <br>    SetScrollInfo(m_hWndViewport, SB_HORZ, &amp;si, TRUE); <br>    m_xPos=0; <br> <br>    // Now Set the vertical scrollbar <br>    si.nMax = (rcFmt.bottom-rcFmt.top)+1; <br>    si.nPage = rc.bottom; <br>    SetScrollInfo(m_hWndViewport, SB_VERT, &amp;si, TRUE); <br>    m_yPos=0; <br> <br>    GlobalUnlock(m_hMemText); <br>    return; <br>} <br> <br>// <br>//   FUNCTION: CFileViewer::FOpenAs     <br>// <br>//   PURPOSE:  Attempts to launch an application to open the file for editing.   <br>// <br>//   RETURN VALUE: <br>//   BOOL -  TRUE if the application is opened in which case <br>//                  the FileViewer can shut down.  Otherwise FALSE <br>//                  meaning launching failed. <br>// <br>BOOL CFileViewer::FOpenAs(void) <br>{ <br>    SHELLEXECUTEINFO sei = {sizeof(sei), 0, m_hWnd, "open", <br>            m_pszPath, NULL, NULL, SW_SHOWNORMAL, m_hInst}; <br> <br>    return ShellExecuteEx(&amp;sei); <br>} <br> <br>// <br>//   FUNCTION:     CFileViewer::FontChange <br>// <br>//   PURPOSE:  Either allows the user to choose a font or increments or <br>//  decrements the font size depending on uOpt.  This is all <br>//  handled in one function here because each operation <br>//  involves obtaining the current viewport font, messing with <br>//  it in some way, and setting a new font again. <br>// <br>//   PARAMETERS:  <br>//     uOpt          VIEWFONTOPTION of the way to change the font: <br>//                      VIEWFONT_SELECT     Display dialog <br>//                      VIEWFONT_INCREASE   Increase size by 2pt <br>//                      VIEWFONT_DECREASE   Decreate size by 2pt <br>// <br>void CFileViewer::FontChange(VIEWFONTOPTION uOpt) <br>{ <br>    HFONT       hFont; <br>    LOGFONT     lf; <br>    CHOOSEFONT  cf; <br>    BOOL        fChange=TRUE; <br>    int         z; <br> <br>     // We have a system font from the constructor, so m_hFont <br>     // will never be NULL, but assert it anyway. <br>    D(if (NULL==m_hFont) ODS("Assertion Failed:  m_hFont is NULL");); <br> <br>    GetObject(m_hFont, sizeof(lf), &amp;lf); <br>     // Each option is responsible for manipulating <br>     // the LOGFONT structure in some way.  If there <br>     // is nothing to do, they set fChange to FALSE <br>    switch (uOpt) <br>        { <br>        case VIEWFONT_SELECT: <br>            memset(&amp;cf, 0, sizeof(CHOOSECOLOR)); <br>            cf.lStructSize=sizeof(CHOOSECOLOR); <br>            cf.hwndOwner  =m_hWnd; <br>            cf.lpLogFont  =&amp;lf; <br>            cf.nSizeMin   =FONTSIZETHRESHOLDMIN; <br>            cf.nSizeMax   =FONTSIZETHRESHOLDMAX; <br> <br>            cf.Flags=CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT <br>                | CF_FORCEFONTEXIST; <br> <br>            if (!ChooseFont(&amp;cf)) <br>                { <br>                D(DWORD dwErr=CommDlgExtendedError(); <br>                ODSlu("FVTEXT.DLL:  ChooseFont failed with %lu", dwErr);); <br> <br>                fChange=FALSE; <br>                } <br> <br>            break; <br> <br> <br>        case VIEWFONT_INCREASESIZE: <br>            //Convert logical size to point size. <br>            z=MulDiv(-lf.lfHeight, 72, m_cyPPI); <br> <br>            //Vary the size increase depending on point size. <br>            if (z &lt; FONTSIZETHRESHOLDMAX) <br>                { <br>                if (z &lt; FONTSIZETHRESHOLDLOW) <br>                    z+=FONTSIZEDELTASMALL; <br>                else <br>                    { <br>                    if (z &lt; FONTSIZETHRESHOLDMID) <br>                        z+=FONTSIZEDELTAMEDIUM; <br>                    else <br>                        z+=FONTSIZEDELTALARGE; <br>                    } <br> <br>                //Convert point size to logical size. <br>                lf.lfHeight=MulDiv(-z, m_cyPPI, 72); <br>                } <br>            else <br>                fChange=FALSE; <br> <br>            break; <br> <br>        case VIEWFONT_DECREASESIZE: <br>            //Convert logical size to point size. <br>            z=MulDiv(-lf.lfHeight, 72, m_cyPPI); <br> <br>            //Vary the size decrease depending on point size. <br>            if (z &gt; FONTSIZETHRESHOLDMIN) <br>                { <br>                if (z &gt; FONTSIZETHRESHOLDMID) <br>                    z-=FONTSIZEDELTALARGE; <br>                else <br>                    { <br>                    if (z &gt; FONTSIZETHRESHOLDLOW) <br>                        z-=FONTSIZEDELTAMEDIUM; <br>                    else <br>                        z-=FONTSIZEDELTASMALL; <br>                    } <br> <br>                //Convert point size to logical size. <br>                lf.lfHeight=MulDiv(-z, m_cyPPI, 72); <br>                } <br>            else <br>                fChange=FALSE; <br> <br>            break; <br> <br>        default: <br>            fChange=FALSE; <br>        } <br> <br>    //Return now if we didn't change anything. <br>    if (!fChange) <br>        return; <br> <br>    //Now switch fonts and update the viewport. <br>    hFont=CreateFontIndirect(&amp;lf); <br> <br>    if (NULL!=hFont) <br>        { <br>        if (NULL!=m_hFont) <br>            DeleteObject(m_hFont); <br> <br>        m_hFont=hFont; <br> <br>        ViewportScrollSet(); <br> <br>        //Repaint the viewport <br>        InvalidateRect(m_hWndViewport, NULL, TRUE); <br>        UpdateWindow(m_hWndViewport); <br>        } <br> <br>    return; <br>} <br> <br>// <br>//   FUNCTION:     CFileViewer::ReplaceWindowModeChange <br>// <br>//   PURPOSE: Sets the window to be pinned or not to be pinned.  When the <br>//   window is pinned, the caller of the viewers will attempt <br>//   to replace the contents of the window instead of creating <br>//   new windows.   <br>// <br>void CFileViewer::ReplaceWindowModeChange(void) <br>{ <br>    HWND hwnd; <br>    UINT  uCheck = MF_BYCOMMAND; <br> <br>    if (m_lpfsi) <br>    { <br>        m_lpfsi-&gt;GetPinnedWindow(&amp;hwnd); <br>        if ((HWND)NULL==hwnd) <br>        { <br>            m_lpfsi-&gt;SetPinnedWindow(m_hWnd); <br>            uCheck = MF_BYCOMMAND | MF_CHECKED; <br>        } <br>        else <br>        { <br>            if (hwnd==m_hWnd) <br>                m_lpfsi-&gt;SetPinnedWindow(NULL); <br>        } <br> <br>    } <br> <br>    HMENU hMenu=GetMenu(m_hWnd); <br>    CheckMenuItem(hMenu, IDM_VIEWREPLACE, uCheck); <br>} <br> <br>// <br>//   FUNCTION: CFileViewer::DropFiles     <br>// <br>//   PURPOSE:   Processes a drop  <br>// <br>BOOL    CFileViewer::DropFiles (HDROP hdrop) <br>{ <br>    // We should now proces the files that were dropped on us <br>    char    szPath[MAX_PATH]; <br>    int     cb; <br> <br>    // For now only process the first file. <br>    if (DragQueryFile(hdrop, 0, szPath, sizeof(szPath)) &gt; 0) <br>    { <br>        ODSsz("CFileViewer::DropFiles filename=%s", szPath); <br> <br>        // Need to convert the string to ole string... <br>        cb = (lstrlen(szPath)+1) * sizeof(OLECHAR); <br>        mbstowcs(m_pvsi-&gt;strNewFile, szPath, cb); <br> <br>        // Now get the window rectangle to use to display this in... <br>        GetWindowRect(m_hWnd, &amp;m_pvsi-&gt;rect); <br>        m_pvsi-&gt;dwFlags |= (FVSIF_RECT | FVSIF_NEWFILE); <br> <br>        // Should check for failure but now sure what to do with it anyway <br>        QueryInterface(IID_IUnknown, (LPVOID *)&amp;m_pvsi-&gt;punkRel); <br>        ODSlu("CFileViewer::DropFiles Query Interface(%x)", m_pvsi-&gt;punkRel); <br>    } <br> <br>    DragFinish(hdrop); <br>    return TRUE; <br>} <br> <br>// <br>//   FUNCTION: CFileViewer::PszToolTip     <br>// <br>//   PURPOSE: Returns a string pointer to a tool tip for the given command <br>//   ID value.  When asked for a string we also display a similar <br>//   one in the status bar.   <br>// <br>//   PARAMETERS:  <br>//   uID - UINT of the toolbar button command. <br>// <br>//   RETURN VALUE: <br>//   LPSTR - Pointer to the string to display. <br>// <br>LPSTR CFileViewer::PszToolTip(UINT uID) <br>{ <br>    UINT        iString, iStatusMsg; <br> <br>    switch (uID) <br>        { <br>        case IDM_FILEOPENAS: <br>            iString=IDS_TOOLTIPOPENAS; <br>            iStatusMsg=IDM_FILEOPENAS; <br>            break; <br> <br>        case IDM_VIEWFONTINCREASE: <br>            iString=IDS_TOOLTIPFONTINC; <br>            iStatusMsg=ID_TIPFONTINC; <br>            break; <br> <br>        case IDM_VIEWFONTDECREASE: <br>            iString=IDS_TOOLTIPFONTDEC; <br>            iStatusMsg=ID_TIPFONTDEC; <br>            break; <br> <br>        default: <br>            return NULL; <br>        } <br> <br>    m_pSH-&gt;MessageDisplay(iStatusMsg); <br>    return String(iString); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
