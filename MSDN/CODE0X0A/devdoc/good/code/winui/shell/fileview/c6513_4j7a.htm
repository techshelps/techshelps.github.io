<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CSTATHLP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6526"></a>CSTATHLP.CPP</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//    PROGRAM:        CSTATHLP.CPP <br>// <br>//    PURPOSE:  Implements the  CStatusHelper class to assist managing the strings for the <br>//           status bar.  Here we provide menu ID to string ID mapping  services using a mapping  <br>//           structure in the module's resources.  This code assumes that the status bar is a standard Windows <br>//           status bar control. <br>// <br>//    PLATFORMS:    Windows 95 <br>// <br>//    SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>#include "fileview.h" <br> <br>// <br>//   FUNCTION:     CStatusHelper::CStatusHelper <br>// <br>//   PURPOSE:  Constructor for the CStatusHelper class <br>// <br>//   PARAMETERS: <br>//  hWnd            HWND of the Status Bar control to work with. <br>//  hInst           HINSTANCE of the module we're in. <br>// <br>CStatusHelper::CStatusHelper(HWND hWnd, HINSTANCE hInst) <br>    { <br>    m_hWnd=hWnd; <br>    m_hInst=hInst; <br> <br>    m_uIDCur=0xFFFFFFFF;    //Nothing shown yet. <br> <br>    m_pST=NULL; <br>    m_pPMM=NULL; <br>    m_pSMM=NULL; <br>    m_hMemSMM=NULL; <br> <br>    //With this FALSE, many other members are ignored. <br>    m_fMapped=FALSE; <br>    return; <br>    } <br>// <br>//   FUNCTION:  CStatusHelper::~CStatusHelper <br>// <br>//   PURPOSE: Destructor for the CStatusHelper class.  <br>// <br>CStatusHelper::~CStatusHelper(void) <br>    { <br>    //Free up anything from MessageMap <br>    if (NULL!=m_pPMM) <br>        { <br>        LocalFree((HLOCAL)m_pPMM); <br>        m_pPMM=NULL; <br>        } <br> <br>    if (NULL!=m_pST) <br>        { <br>        delete m_pST; <br>        m_pST=NULL; <br>        } <br> <br>    if (NULL!=m_pSMM) <br>        { <br>        LocalFree((HLOCAL)m_pSMM); <br>        UnlockResource(m_hMemSMM); <br>        m_pSMM=NULL; <br>        } <br> <br>    if (NULL!=m_hMemSMM) <br>        { <br>        FreeResource(m_hMemSMM); <br>        m_hMemSMM=NULL; <br>        } <br> <br>    return; <br>    } <br>// <br>//   FUNCTION: CStatusHelper::MessageMap <br>// <br>//   PURPOSE:    Initializes a CStatusHelper for automated processing of <br>//  WM_MENUSELECT messages as well as setting up a list of messages <br>//  that we can display using identifiers instead of string <br>//  pointers.  See MenuSelect and MessageDisplay members. <br>// <br>//  PARAMETERS: <br>//  hWndOwner - HWND of the window owning menus we're interested in serving <br>//  uIDRMap - UINT identifying a resource mapping ID values to string ID values <br>//  idsMin - UINT specifying the lowest string ID to load <br>//  idsMax - UINT specifying the hightest string ID to load <br>//  cchMax - UINT maximum string length <br>//  uIDPopupMin - UINT of the lowest ID to assign to popup menus <br>//  uIDPopupMax - UINT of the highest ID to assign to popup menus <br>//  uIDStatic- UINT of the ID for the quiescent state message <br>//  uIDBlank - UINT of the ID for a blank message <br>//  uIDSysMenu - UINT of the ID for the system menu <br>// <br>//  RETURN VALUE: <br>//  BOOL     TRUE if the function was successful, <br>//                  FALSE otherwise. <br>// <br>//   COMMENTS:  This function is the initializer for the CStatusHelper class. <br>//  If it fails, then the caller should delete the object. <br>//  <br>BOOL CStatusHelper::MessageMap(HWND hWndOwner, UINT uIDRMap <br>    , UINT idsMin, UINT idsMax, UINT cchMax, UINT uIDPopupMin <br>    , UINT uIDPopupMax, UINT uIDStatic, UINT uIDBlank, UINT uIDSysMenu) <br>    { <br>    HMENU           hMenu; <br>    HRSRC           hRes; <br>    UINT            i; <br>    USHORT          uID; <br>    DWORD           dwSize; <br>    PSTATMESSAGEMAP pSMM; <br> <br>    // Check if we even got a valid window in the constructor <br>    // or if we've already been called. <br>    if (!IsWindow(m_hWnd) || m_fMapped) <br>        return FALSE; <br> <br>    //Parameter validation <br>    if (idsMax &lt; idsMin || uIDPopupMax &lt; uIDPopupMin) <br>        return FALSE; <br> <br>    //Cache away all this vital information <br>    m_hWndOwner  =hWndOwner; <br>    m_idsMin     =idsMin; <br>    m_idsMax     =idsMax; <br>    m_cMessages  =(USHORT)(idsMax-idsMin+1); <br> <br>    m_uIDPopupMin=uIDPopupMin; <br>    m_uIDPopupMax=uIDPopupMax; <br>    m_cPopups    =(USHORT)(uIDPopupMax-uIDPopupMin+1); <br>    m_uIDStatic  =uIDStatic; <br>    m_uIDBlank   =uIDBlank; <br>    m_uIDSysMenu =uIDSysMenu; <br> <br>    //Get a stringtable with all the messages <br>    m_pST=new CStringTable(m_hInst); <br> <br>    if (NULL==m_pST) <br>        return FALSE; <br> <br>    if (!m_pST-&gt;FInit(idsMin, idsMax, CCHSTATUSMSGMAX)) <br>        return FALSE; <br> <br>    //Load the STATMESSAGEMAP array from resources <br>    hRes=FindResource(m_hInst, MAKEINTRESOURCE(uIDRMap), RT_RCDATA); <br> <br>    if (NULL==hRes) <br>        return FALSE; <br> <br>    m_hMemSMM=LoadResource(m_hInst, hRes); <br> <br>    if (NULL==m_hMemSMM) <br>        return FALSE; <br> <br>    pSMM=(PSTATMESSAGEMAP)LockResource(m_hMemSMM); <br> <br>    if (NULL==pSMM) <br>        return FALSE; <br> <br>    // Now get the size of the resource <br>    dwSize = SizeofResource(m_hInst, hRes); <br> <br>    // Resources are ReadOnly data so copy it to memory that can <br>    // be used <br>    m_pSMM = (PSTATMESSAGEMAP)LocalAlloc(LPTR, dwSize); <br>    if (NULL==m_pSMM) <br>        return FALSE; <br>    CopyMemory(m_pSMM, pSMM, dwSize); <br> <br>    //Sort these for binary search lookup. <br>    Sort(); <br> <br>    //Allocate an array of POPUPMENUMAP structures <br>    m_pPMM=(PPOPUPMENUMAP)LocalAlloc(LPTR <br>        , sizeof(POPUPMENUMAP)*m_cPopups); <br> <br>    if (NULL==m_pPMM) <br>        return FALSE; <br> <br>    //Initialize the array mapping popup menus to specific IDs. <br>    uID=uIDPopupMin; <br>    hMenu=GetMenu(m_hWndOwner); <br> <br>    for (i=0; i &lt; m_cPopups; i++) <br>        { <br>        m_pPMM[i].hMenu=GetSubMenu(hMenu, i); <br>        m_pPMM[i].uID  =uID++; <br>        } <br> <br>    //All done! <br>    m_fMapped=TRUE; <br>    return TRUE; <br>    } <br>// <br>//   FUNCTION: CStatusHelper::MenuSelect <br>// <br>//   PURPOSE:  Displays the appropriate message for whatever is in the <br>//  parameters of a WM_MENUSELECT message.  This can only be called <br>//  if StatStripMessageMap has already been called and must be used <br>//  with the same menu the owner window had at the time of that call. <br>//  <br>//   PARAMETERS: <br>//  wItem           WORD identifying the selected item <br>//  wFlags          WORD specifying the type of menu item <br>//  hMenu           HMENU of the menu selected. <br>// <br>void CStatusHelper::MenuSelect(WORD wItem, WORD wFlags, HMENU hMenu) <br>    { <br>    USHORT          uID; <br> <br>    if (!m_fMapped) <br>        return; <br> <br>    //Case 1:  Menu was cancelled, display static string <br>    if (0==wItem &amp;&amp; (WORD)0xFFFF==wFlags) <br>        uID=m_uIDStatic; <br>    else <br>        { <br>        //Case 2:  System menu selected by itself. <br>        if ((MF_POPUP &amp; wFlags) &amp;&amp; (MF_SYSMENU &amp; wFlags)) <br>            uID=m_uIDSysMenu; <br>        else <br>            { <br>             //  Case 3:  A popup menu was chosen: <br>             //  Find the ID for the popup menu index in wItem <br>            if (MF_POPUP &amp; wFlags) <br>                uID=IDFromHMenu((HMENU)wItem); <br>            else <br>                //Case 4:  A menu item is selected <br>                if (0!=wItem) <br>                    uID=(UINT)wItem; <br>                else <br>                    //Case 5:  Nothing is selected (e.g. separator) <br>                    uID=m_uIDBlank; <br>           } <br>        } <br> <br>    //Display the message <br>    MessageDisplay(uID); <br>    return; <br>    } <br>// <br>//   FUNCTION:       CStatusHelper::MessageDisplay <br>// <br>//   PURPOSE:  Displays the appropriate message for a given ID value.  This <br>//  can only be called if MessageMap has already been called. <br>// <br>//   PARAMETERS:  <br>//     uID             UINT of the message to display.  This is not a string ID but an ID  <br>//                       in the STATMESSAGEMAP structure that maps to a string ID. <br>// <br>void CStatusHelper::MessageDisplay(UINT uID) <br>    { <br>    UINT        idsMsg; <br> <br>    if (!m_fMapped) <br>        return; <br> <br>    //If we're already displaying this ID, nothing we need to do <br>    if (m_uIDCur==uID) <br>        return; <br> <br>    //Go look up the string ID to display. <br>    idsMsg=IStringFromID(uID); <br> <br>    //Display it. <br>    SetWindowText(m_hWnd, (*m_pST)[idsMsg]); <br>    return; <br>    } <br>// <br>//   FUNCTION:       CStatusHelper::Sort          (Private) <br>// <br>//   PURPOSE:   Performs a selection sort on the STATMESSAGEMAP array that we <br>//  load from resources.  Since we expect that the data is partially <br>//  sorted (we tend to place things in resources in groups of <br>//  seqential values), since the number of messages is usually <br>//  less than 200, and since we're usually doing this stuff on startup <br>//  (which takes a long time anyway), a cimple selection sort is a <br>//  better choice than a more complex qsort. <br>// <br>void CStatusHelper::Sort(void) <br>    { <br>    UINT            i, j, k; <br>    STATMESSAGEMAP  smm; <br> <br>    for (j=0; j &lt; (UINT)(m_cMessages-1); j++) <br>        { <br>        k=j; <br>        smm.uID   =m_pSMM[j].uID; <br>        smm.idsMsg=m_pSMM[j].idsMsg; <br> <br>        for (i=j+1; i &lt; (UINT)m_cMessages; i++) <br>            { <br>            if (m_pSMM[i].uID &lt; smm.uID) <br>                { <br>                smm.uID   =m_pSMM[i].uID; <br>                smm.idsMsg=m_pSMM[i].idsMsg; <br>                k=i; <br>                } <br>            } <br> <br>        smm.uID         =m_pSMM[j].uID; <br>        smm.idsMsg      =m_pSMM[j].idsMsg; <br>        m_pSMM[j].uID   =m_pSMM[k].uID;   ; <br>        m_pSMM[j].idsMsg=m_pSMM[k].idsMsg;; <br>        m_pSMM[k].uID   =smm.uID; <br>        m_pSMM[k].idsMsg=smm.idsMsg; <br>        } <br> <br>    return; <br>    } <br>// <br>//   FUNCTION:       CStatusHelper::IDFromHMenu (Private) <br>// <br>//   PURPOSE:   Given a specific popup menu index, searches through m_pPMM for <br>//  a match and returns the ID associated with that menu. <br>// <br>//   PARAMETERS: <br>//       hMenu           HMENU to of he popup menu. <br>// <br>//   RETURN VALUE: <br>//       USHORT          ID associated with the menu handle. <br>//  <br>USHORT CStatusHelper::IDFromHMenu(HMENU hMenu) <br>    { <br>    USHORT      uID=m_uIDBlank;      //Default is empty <br>    UINT        i; <br> <br>    for (i=0; i &lt; m_cPopups; i++) <br>        { <br>        if (m_pPMM[i].hMenu==hMenu) <br>            { <br>            uID=m_pPMM[i].uID; <br>            break; <br>            } <br>        } <br> <br>    return uID; <br>    } <br>// <br>//   FUNCTION:     CStatusHelper::IStringFromID (Private) <br>// <br>//   PURPOSE:  Performs a binary search in a STATMESSAGEMAP array looking for <br>//  a specific item ID returning the string ID for that item. <br>// <br>//   PARAMETERS:  <br>//        uID             USHORT item ID to locate. <br>// <br>//   RETURN VALUE: <br>//       UINT            String ID associated with wItem. <br>//  <br>UINT CStatusHelper::IStringFromID(USHORT uID) <br>    { <br>    UINT        iLow =0; <br>    UINT        iHigh=m_cMessages-1; <br>    UINT        iMid; <br> <br>    while (TRUE) <br>        { <br>        iMid=(iLow+iHigh) &gt;&gt; 1; <br> <br>        if (uID &lt; m_pSMM[iMid].uID) <br>            iHigh=iMid-1; <br>        else <br>            { <br>            if (uID &gt; m_pSMM[iMid].uID) <br>                iLow=iMid+1; <br>            else <br>                break;    //Equality <br>            } <br> <br>        if (iHigh &lt; iLow) <br>            break; <br>        } <br> <br>    return m_pSMM[iMid].idsMsg; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
