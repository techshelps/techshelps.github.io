<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FVINIT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6520"></a>FVINIT.CPP</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//      PROGRAM: FVINIT.CPP              <br>// <br>//      PURPOSE:  All initialization functions and some miscellany for the CFileViewer implementation. <br>// <br>//      PLATFORMS:      Windows 95 <br>// <br>//      FUNCTIONS:       <br>//    <br>// <br>//      SPECIAL INSTRUCTIONS: N/A <br>// <br>#include "fileview.h" <br> <br>// <br>//   FUNCTION: CFileViewer::Init         <br>// <br>//   PURPOSE: Performs any intiailization of a CFileViewer that's prone to <br>//  failure that we also use internally before exposing the object <br>//  outside.   <br>// <br>//   RETURN VALUE: <br>//   HRESULT         NOERROR if successful, error code otherwise. <br>// <br>HRESULT CFileViewer::Init(void) <br>    { <br>    LPUNKNOWN       pIUnknown=(LPUNKNOWN)this; <br>    WNDCLASS        wc; <br>    HRESULT         hr; <br>    HDC             hDC; <br> <br>    //Default error code <br>    hr=ResultFromScode(E_OUTOFMEMORY); <br> <br>    // Make pIUnknown point to outer unknown if we get one. <br>    // The interfaces allocated below are always given an IUnknown <br>    // to which they delegate at all times.  This will be either <br>    // the CFileViewer object's IUnknown itself or the outer <br>    // unknown if this object is aggregated.  The interfaces <br>    // need not know which case is being used. <br>    if (NULL!=m_pUnkOuter) <br>pIUnknown=m_pUnkOuter; <br> <br>    //Allocate contained interfaces. <br>    m_pIPersistFile=new CImpIPersistFile(this, pIUnknown); <br> <br>    if (NULL==m_pIPersistFile) <br>return hr; <br> <br>    m_pIFileViewer=new CImpIFileViewer(this, pIUnknown); <br> <br>    if (NULL==m_pIFileViewer) <br>return hr; <br> <br>    m_pST=new CStringTable(m_hInst); <br> <br>    if (NULL==m_pST) <br>return hr; <br> <br>    // Go load the strings we need in CFileViewer::String.   <br>    if (!m_pST-&gt;FInit(IDS_MIN, IDS_MAX, CCHSTRINGMAX)) <br>return hr; <br> <br>    //Register window classes that we'll need to display the file <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc   = FileViewerFrameProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = CBWNDEXTRAFRAME; <br>    wc.hInstance     = m_hInst; <br>    wc.hIcon         = LoadIcon(m_hInst, "Icon"); <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE+1); <br>    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = String(IDS_CLASSFRAME); <br> <br>    if (!RegisterClass(&amp;wc)) <br>return hr; <br> <br>    // MODIFY:  This is the viewport window that does the work <br>    // of displaying the data.  Modify it to your needs. <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc   = ViewportWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = CBWNDEXTRAVIEWPORT; <br>    wc.hInstance     = m_hInst; <br>    wc.hIcon         = NULL; <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = String(IDS_CLASSVIEWPORT); <br> <br>    if (!RegisterClass(&amp;wc)) <br>return hr; <br> <br>    m_fClassReg=TRUE; <br> <br>    // Create a default fixed pitch font for the Viewport.  We <br>    // use Courier New here instead of say, SYSTEM_FIXED_FONT <br>    // because we want the font sizing buttons to work normally <br>     // when this window appears, and the system fonts do not <br>     // scale, but Courier New does.  Default is 10 point calculated <br>     // from 10*PIXELSPERINCH/72. <br>    hDC=GetDC(NULL); <br>    m_cyPPI=GetDeviceCaps(hDC, LOGPIXELSY); <br>    ReleaseDC(NULL, hDC); <br> <br>    m_hFont=CreateFont(MulDiv(-10, m_cyPPI, 72) <br>, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE <br>, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS <br>, DEFAULT_QUALITY, FIXED_PITCH | FF_MODERN, "Courier New"); <br> <br>    return NOERROR; <br>    } <br>// <br>//   FUNCTION: CFileViewer::FInitFrameControls   <br>// <br>//   PURPOSE:  Creates and initializes the toolbar and status bar for the frame window. <br>// <br>//   PARAMETERS:  <br>// <br>//   RETURN VALUE: <br>//  BOOL            TRUE if the function worked, FALSE otherwise. <br>// <br>BOOL CFileViewer::FInitFrameControls(void) <br>    { <br>    BOOL        fRet; <br>    RECT        rc; <br>    TBBUTTON    rgtb[CTBBUTTONS]; <br> <br>     // Initialize the toolbar button array.  This uses the TOOLS.BMP <br>     // resource which has three buttons and one separator.  The <br>     // buttons are tied to File/Open As and Increase/Decrease Font <br>     // size. <br>    rgtb[0].iBitmap=IDBT_OPENAS; <br>    rgtb[0].idCommand=IDM_FILEOPENAS; <br>    rgtb[0].fsState=TBSTATE_ENABLED; <br>    rgtb[0].fsStyle=TBSTYLE_BUTTON; <br>    rgtb[0].dwData=0L; <br>    rgtb[0].iString=0; <br> <br>    rgtb[1].iBitmap=0; <br>    rgtb[1].idCommand=0; <br>    rgtb[1].fsState=TBSTATE_ENABLED; <br>    rgtb[1].fsStyle=TBSTYLE_SEP; <br>    rgtb[1].dwData=0L; <br>    rgtb[1].iString=0; <br> <br>    rgtb[2].iBitmap=IDBT_FONTSIZEINCREASE; <br>    rgtb[2].idCommand=IDM_VIEWFONTINCREASE; <br>    rgtb[2].fsState=TBSTATE_ENABLED; <br>    rgtb[2].fsStyle=TBSTYLE_BUTTON; <br>    rgtb[2].dwData=0L; <br>    rgtb[2].iString=0; <br> <br>    rgtb[3].iBitmap=IDBT_FONTSIZEDECREASE; <br>    rgtb[3].idCommand=IDM_VIEWFONTDECREASE; <br>    rgtb[3].fsState=TBSTATE_ENABLED; <br>    rgtb[3].fsStyle=TBSTYLE_BUTTON; <br>    rgtb[3].dwData=0L; <br>    rgtb[3].iString=0; <br> <br>     // BUGBUG:  Open as button:  call SHGetIconOfFile to retrieve <br>     // the image, then overwrite it in the toolbar bitmap we send <br>     // to CreateToolbarEx.  If SHGetIconOfFile fails, then just <br>     // use the one in the toolbar bitmap already. <br>     // <br>    m_hWndToolbar=CreateToolbarEx(m_hWnd, TBSTYLE_TOOLTIPS <br>| WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS, ID_TOOLBAR <br>, CTBBITMAPS, m_hInst, IDB_TOOLS, rgtb, CTBBUTTONS <br>, 0, 0, 0, 0, sizeof(TBBUTTON)); <br> <br>    if (NULL==m_hWndToolbar) <br>{ <br>ODS("CFileViewer::FInitFrameTools failed to create toolbar"); <br>return FALSE; <br>} <br> <br>     // Remember the height for resizing this and the viewport. <br>     // Use window rectangles for toolbars. <br>    GetWindowRect(m_hWndToolbar, &amp;rc); <br>    m_cyTools=rc.bottom-rc.top; <br> <br>     // Status line <br>    m_hWndStatus=CreateStatusWindow(WS_CHILD | WS_VISIBLE <br>, String(IDS_MSGREADY), m_hWnd, ID_STATUSBAR); <br> <br>    if (NULL==m_hWndStatus) <br>{ <br>ODS("CFileViewer::FInitFrameTools failed to create status bar"); <br>return FALSE; <br>} <br> <br>     // Remember the height for resizing this and the viewport. <br>     // Use client rectangle for status lines. <br>    GetClientRect(m_hWndStatus, &amp;rc); <br>    m_cyStatus=rc.bottom-rc.top; <br> <br>     // Create a status bar helper and tell it what messages <br>     // to use.  This object will be called from WM_MENUSELECT <br>     // in FileViewerFrameProc in FVPROC.CPP. <br>    m_pSH=new CStatusHelper(m_hWndStatus, m_hInst); <br> <br>    if (NULL==m_pSH) <br>return FALSE; <br> <br>    fRet=m_pSH-&gt;MessageMap(m_hWnd, IDR_STATMESSAGEMAP, IDS_STATUSMSGMIN <br>, IDS_STATUSMSGMAX, CCHSTATUSMSGMAX, ID_MENUFILE, ID_MENUHELP <br>, ID_MSGREADY, ID_MSGEMPTY, ID_MENUSYS); <br> <br>    return fRet; <br>    } <br> <br>// <br>//   FUNCTION:  CFileViewer::String <br>// <br>//   PURPOSE:    string lookup function for access to stringtable.  <br>// <br>LPSTR CFileViewer::String(UINT uID) <br>    { <br>    return (*m_pST)[uID]; <br>    } <br> <br>// <br>//   FUNCTION:  CFileViewer::MemAlloc <br>// <br>//   PURPOSE:Central allocation function using IMalloc.    <br>// <br>LPVOID CFileViewer::MemAlloc(ULONG cb) <br>    { <br>    LPMALLOC    pIMalloc; <br>    LPVOID      pv; <br>    HRESULT     hr; <br> <br>    if (FAILED(hr = CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>{ <br>ODSu("CFileViewer::MemAlloc CoGetMalloc failed %ld", hr); <br> <br>if (hr == CO_E_NOTINITIALIZED) <br>    { <br>    if ((FAILED(hr=CoInitialize(NULL))) || <br>FAILED(hr=CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>{ <br>ODSu("CFileViewer::MemAlloc CoInitialize/CoGetMalloc failed %x", hr); <br>return NULL; <br>} <br> <br>    } <br>else <br>    return NULL; <br>} <br> <br>    pv=pIMalloc-&gt;Alloc(cb); <br>    pIMalloc-&gt;Release(); <br>    return pv; <br>    } <br>// <br>//   FUNCTION:CFileViewer::MemFree       <br>// <br>//   PURPOSE:  Central free function using IMalloc.  <br>// <br>void CFileViewer::MemFree(LPVOID pv) <br>    { <br>    LPMALLOC    pIMalloc; <br> <br>    if (NULL==pv) <br>{ <br>ODS("CFileViewer::MemFree passed NULL pointer"); <br>return; <br>} <br> <br>    if (FAILED(CoGetMalloc(MEMCTX_SHARED, &amp;pIMalloc))) <br>{ <br>ODS("CFileViewer::MemFree CoGetMalloc failed"); <br>return; <br>} <br> <br>    pIMalloc-&gt;Free(pv); <br>    pIMalloc-&gt;Release(); <br>    return; <br>    } <br>// <br>//   FUNCTION: CFileViewer::QueryInterface       <br>// <br>STDMETHODIMP CFileViewer::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>     //The only calls for IUnknown are either in a nonaggregated <br>     // case or when created in an aggregation, so in either case <br>     // always return our IUnknown for IID_IUnknown. <br>    if (IsEqualIID(riid, IID_IUnknown)) <br>*ppv=(LPVOID)this; <br> <br>    //IPersist is base of IPersistFile <br>    if (IsEqualIID(riid, IID_IPersist) <br>|| IsEqualIID(riid, IID_IPersistFile)) <br>*ppv=(LPVOID)m_pIPersistFile; <br> <br>    if (IsEqualIID(riid, IID_IFileViewer)) <br>*ppv=(LPVOID)m_pIFileViewer; <br> <br>    //AddRef any interface we'll return. <br>    if (NULL!=*ppv) <br>{ <br>((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>return NOERROR; <br>} <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>// <br>//   FUNCTION:  CFileViewer::AddRef <br>// <br>STDMETHODIMP_(ULONG) CFileViewer::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>// <br>//   FUNCTION: CFileViewer::Release <br>// <br>STDMETHODIMP_(ULONG) CFileViewer::Release(void) <br>    { <br>    ULONG       cRefT; <br> <br>    cRefT=--m_cRef; <br> <br>    ODSu("CFileViewer::Release Count=%d", cRefT); <br> <br>    if (0L==m_cRef) <br>{ <br> // Tell the server that an object is going away <br> // so it can shut down if appropriate.  (See FILEVIEW.CPP <br> // for the ObjectDestroyed function). <br>if (NULL!=m_pfnDestroy) <br>    (*m_pfnDestroy)(); <br> <br>delete this; <br>} <br> <br>    return cRefT; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
