<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DROPEXT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6509"></a>DROPEXT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1994 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>//--------------------------------------------------------------------------- <br>// <br>// File: dropext.c <br>// <br>//  This file contains a sample source code of context menu extension handler. <br>// <br>//--------------------------------------------------------------------------- <br> <br>#include "priv.h" <br> <br>// <br>// Initialize GUIDs (should be done only and at-least once per DLL/EXE) <br>// <br>#pragma data_seg(".text") <br>#define INITGUID <br>#include &lt;initguid.h&gt; <br>#include "dropext.h" <br>#pragma data_seg() <br> <br>// <br>// Function prototypes <br>// <br>HRESULT CALLBACK DropExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR*); <br> <br>// <br>// Global variables <br>// <br>UINT g_cRefThisDll = 0;// Reference count of this DLL. <br>UINT g_cfNetResource = 0;// Clipboard format <br> <br>//--------------------------------------------------------------------------- <br>// LibMain <br>//--------------------------------------------------------------------------- <br>BOOL APIENTRY LibMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved) <br>{ <br>    switch(dwReason) <br>    { <br>    case DLL_PROCESS_ATTACH: <br>    break; <br>    case DLL_PROCESS_DETACH: <br>    break; <br> <br>    case DLL_THREAD_DETACH: <br>        break; <br> <br>    case DLL_THREAD_ATTACH: <br>    default: <br>    break; <br>    } // end switch() <br> <br>    return TRUE; <br>} <br> <br>//--------------------------------------------------------------------------- <br>// DllCanUnloadNow <br>//--------------------------------------------------------------------------- <br> <br>STDAPI DllCanUnloadNow(void) <br>{ <br>    return ResultFromScode((g_cRefThisDll==0) ? S_OK : S_FALSE); <br>} <br> <br>//--------------------------------------------------------------------------- <br>// <br>// DllGetClassObject <br>// <br>//  This is the entry of this DLL, which all the In-Proc server DLLs should <br>// export. See the description of "DllGetClassObject" of OLE 2.0 reference <br>// manual for detail. <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvOut) <br>{ <br>    // <br>    //  This DLL has only one class (CLSID_SampleDropExt). If a DLL supports <br>    // multiple classes, it should have either multiple if-statements or <br>    // efficient table lookup code. <br>    // <br>    if (IsEqualIID(rclsid, &amp;CLSID_SampleDropExt)) <br>    { <br>// <br>//  We are supposed return the class object for this class. Instead <br>// of fully implementing it in this DLL, we just call a helper <br>// function in the shell DLL which creates a default class factory <br>// object for us. When its CreateInstance member is called, it <br>// will call back our create instance function (DropExt_CreateInstance). <br>// <br>return SHCreateDefClassObject( <br>    riid,    // <br>    ppvOut,    // <br>    DropExt_CreateInstance, // callback function <br>    &amp;g_cRefThisDll,    // reference count of this DLL <br>    &amp;IID_IShellExtInit    // init interface <br>    ); <br>    } <br> <br>    return ResultFromScode(E_FAIL); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// CSampleDropExt class <br>// <br>// In C++: <br>//  class CSampleDropExt : protected IContextMenu, protected IShellExtInit <br>//  { <br>//  protected: <br>//      UINT         _cRef; <br>//      LPDATAOBJECT _pdtobj; <br>//HKEY     _hkeyProgID; <br>//  public: <br>//      CSampleDropExt() _cRef(1), _pdtobj(NULL), _hkeyProgID(NULL) {}; <br>//      ... <br>//  }; <br>// <br>//--------------------------------------------------------------------------- <br>typedef struct _CSampleDropExt// smx <br>{ <br>    IContextMenu    _ctm;           // 1st base class <br>    IShellExtInit   _sxi;    // 2nd base class <br>    UINT            _cRef;          // reference count <br>    LPDATAOBJECT    _pdtobj;    // data object <br>    HKEY    _hkeyProgID;    // reg. database key to ProgID <br>    char    _szTargetFolder[MAX_PATH]; <br>} CSampleDropExt, * PSAMPLEDROPEXT; <br> <br>#define SMX_OFFSETOF(x)        ((UINT)(&amp;((PSAMPLEDROPEXT)0)-&gt;x)) <br>#define PVOID2PSMX(pv,offset)   ((PSAMPLEDROPEXT)(((LPBYTE)pv)-offset)) <br>#define PCTM2PSMX(pctm)        PVOID2PSMX(pctm, SMX_OFFSETOF(_ctm)) <br>#define PSXI2PSMX(psxi)        PVOID2PSMX(psxi, SMX_OFFSETOF(_sxi)) <br> <br>// <br>// Vtable prototype <br>// <br>extern IContextMenuVtbl     c_SampleDropExt_CTMVtbl; <br>extern IShellExtInitVtbl    c_SampleDropExt_SXIVtbl; <br> <br>//--------------------------------------------------------------------------- <br>// <br>// DropExt_CreateInstance <br>// <br>//  This function is called back from within IClassFactory::CreateInstance() <br>// of the default class factory object, which is created by SHCreateClassObject. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT CALLBACK DropExt_CreateInstance(LPUNKNOWN punkOuter, <br>        REFIID riid, LPVOID FAR* ppvOut) <br>{ <br>    HRESULT hres; <br>    PSAMPLEDROPEXT psmx; <br> <br>    // <br>    // Shell extentions typically does not support aggregation. <br>    // <br>    if (punkOuter) { <br>return ResultFromScode(CLASS_E_NOAGGREGATION); <br>    } <br> <br>    // <br>    // in C++: <br>    //  psmx = new CSampleDropExt(); <br>    // <br>    psmx = LocalAlloc(LPTR, sizeof(CSampleDropExt)); <br>    if (!psmx) { <br>return ResultFromScode(E_OUTOFMEMORY); <br>    } <br>    psmx-&gt;_ctm.lpVtbl = &amp;c_SampleDropExt_CTMVtbl; <br>    psmx-&gt;_sxi.lpVtbl = &amp;c_SampleDropExt_SXIVtbl; <br>    psmx-&gt;_cRef = 1; <br>    psmx-&gt;_pdtobj = NULL; <br>    psmx-&gt;_hkeyProgID = NULL; <br>    g_cRefThisDll++; <br> <br>    // <br>    // in C++: <br>    //  hres = psmx-&gt;QueryInterface(riid, ppvOut); <br>    //  psmx-&gt;Release(); <br>    // <br>    // Note that the Release member will free the object, if QueryInterface <br>    // failed. <br>    // <br>    hres = c_SampleDropExt_CTMVtbl.QueryInterface(&amp;psmx-&gt;_ctm, riid, ppvOut); <br>    c_SampleDropExt_CTMVtbl.Release(&amp;psmx-&gt;_ctm); <br> <br>    return hres;// S_OK or E_NOINTERFACE <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt::Initialize (IShellExtInit override) <br>//--------------------------------------------------------------------------- <br>STDMETHODIMP DropExt_Initialize(LPSHELLEXTINIT psxi, <br>LPCITEMIDLIST pidlFolder, <br>LPDATAOBJECT pdtobj, <br>HKEY hkeyProgID) <br>{ <br>    PSAMPLEDROPEXT this = PSXI2PSMX(psxi); <br> <br>    // Initialize can be called more than once. <br>    if (this-&gt;_pdtobj) { <br>this-&gt;_pdtobj-&gt;lpVtbl-&gt;Release(this-&gt;_pdtobj); <br>    } <br> <br>    if (this-&gt;_hkeyProgID) { <br>RegCloseKey(this-&gt;_hkeyProgID); <br>    } <br> <br>    // Duplicate the pdtobj pointer <br>    if (pdtobj) { <br>this-&gt;_pdtobj = pdtobj; <br>pdtobj-&gt;lpVtbl-&gt;AddRef(pdtobj); <br>    } <br> <br>    // Duplicate the handle <br>    if (hkeyProgID) { <br>RegOpenKeyEx(hkeyProgID, NULL, 0L, MAXIMUM_ALLOWED, &amp;this-&gt;_hkeyProgID); <br>    } <br> <br>    // Get the path to the drop target folder <br>    if (pidlFolder) { <br>SHGetPathFromIDList(pidlFolder, this-&gt;_szTargetFolder); <br>    } <br> <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP DropExt_QueryContextMenu(LPCONTEXTMENU pctm, <br>                                               HMENU hmenu, <br>                                               UINT indexMenu, <br>                                               UINT idCmdFirst, <br>                                               UINT idCmdLast, <br>       UINT uFlags) <br>{ <br>    UINT idCmd = idCmdFirst; <br>    InsertMenu(hmenu, indexMenu++, MF_STRING|MF_BYPOSITION, idCmd++, "Check H&amp;DROP (dropext)"); <br>    InsertMenu(hmenu, indexMenu++, MF_STRING|MF_BYPOSITION, idCmd++, "Check H&amp;NRES (dropext)"); <br>    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, (USHORT)2)); <br>} <br> <br>// <br>// Converts an offset to a string to a string pointer. <br>// <br>LPCSTR _Offset2Ptr(LPSTR pszBase, UINT offset, UINT * pcb) <br>{ <br>    LPSTR pszRet; <br>    if (offset==0) { <br>pszRet = NULL; <br>*pcb = 0; <br>    } else { <br>pszRet = pszBase + offset; <br>*pcb = lstrlen(pszRet) + 1; <br>    } <br>    return pszRet; <br>} <br> <br>// <br>// This is a helper routine which extracts a specified NETRESOURCE from hnres. <br>// <br>UINT DropExt_GetNetResource(HGLOBAL hnres, UINT iItem, LPNETRESOURCE pnresOut, UINT cbMax) <br>{ <br>    LPNRESARRAY panr = GlobalLock(hnres); <br>    UINT iRet = 0;// assume error <br>    if (hnres) <br>    { <br>if (iItem==(UINT)-1) <br>{ <br>    iRet = panr-&gt;cItems; <br>} <br>else if (iItem &lt; panr-&gt;cItems) <br>{ <br>    UINT cbProvider, cbRemoteName; <br>    LPCSTR pszProvider = _Offset2Ptr((LPSTR)panr, (UINT)panr-&gt;nr[iItem].lpProvider, &amp;cbProvider); <br>    LPCSTR pszRemoteName = _Offset2Ptr((LPSTR)panr, (UINT)panr-&gt;nr[iItem].lpRemoteName, &amp;cbRemoteName); <br>    iRet = sizeof(NETRESOURCE) + cbProvider + cbRemoteName; <br>    if (iRet &lt;= cbMax) <br>    { <br>LPSTR psz = (LPSTR)(pnresOut+1); <br>*pnresOut = panr-&gt;nr[iItem]; <br>if (pnresOut-&gt;lpProvider) { <br>    pnresOut-&gt;lpProvider = psz; <br>    lstrcpy(psz, pszProvider); <br>    psz += cbProvider; <br>} <br>if (pnresOut-&gt;lpRemoteName) { <br>    pnresOut-&gt;lpRemoteName = psz; <br>    lstrcpy(psz, pszRemoteName); <br>} <br>    } <br>} <br>GlobalUnlock(hnres); <br>    } <br>    return iRet; <br>} <br> <br>HRESULT DropExt_CheckForHDROP(PSAMPLEDROPEXT this, HWND hwnd) <br>{ <br>    FORMATETC fmte = { <br>        CF_HDROP, <br>        (DVTARGETDEVICE FAR *)NULL, <br>        DVASPECT_CONTENT, <br>        -1, <br>        TYMED_HGLOBAL }; <br>    STGMEDIUM medium; <br>    HRESULT hres = this-&gt;_pdtobj-&gt;lpVtbl-&gt;GetData(this-&gt;_pdtobj, &amp;fmte, &amp;medium); <br> <br>    if (SUCCEEDED(hres)) <br>    { <br>HDROP hdrop = medium.hGlobal; <br>UINT cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0); <br>char szFile[MAX_PATH]; <br>char szBuf[MAX_PATH*2+64]; <br> <br>DragQueryFile(hdrop, 0, szFile, sizeof(szFile)); <br>wsprintf(szBuf, <br> "The drop target is %s.\n" <br>  "%d files/directories in HDROP\n" <br> "The path to the first object is\n" <br>    "\t%s.", <br> this-&gt;_szTargetFolder, <br> cFiles, <br> szFile); <br> <br>MessageBox(hwnd, szBuf, "DropExt", MB_OK); <br> <br>// <br>// HACK: We are supposed to call ReleaseStgMedium. This is a temporary <br>//  hack until OLE 2.01 for Windows 95 is released. <br>// <br>if (medium.pUnkForRelease) <br>{ <br>    medium.pUnkForRelease-&gt;lpVtbl-&gt;Release(medium.pUnkForRelease); <br>} <br>else <br>{ <br>    GlobalFree(medium.hGlobal); <br>} <br>    } <br>    else <br>    { <br>MessageBox(hwnd, "No file system object in the selection", "DropExt", MB_OK); <br>    } <br> <br>    return hres; <br>} <br> <br>HRESULT DropExt_CheckForHNRES(PSAMPLEDROPEXT this, HWND hwnd) <br>{ <br>    FORMATETC fmte = { <br>        g_cfNetResource ? g_cfNetResource <br>    : (g_cfNetResource=RegisterClipboardFormat("Net Resource")), <br>        (DVTARGETDEVICE FAR *)NULL, <br>        DVASPECT_CONTENT, <br>        -1, <br>        TYMED_HGLOBAL }; <br>    STGMEDIUM medium; <br>    HRESULT hres = this-&gt;_pdtobj-&gt;lpVtbl-&gt;GetData(this-&gt;_pdtobj, &amp;fmte, &amp;medium); <br>    if (SUCCEEDED(hres)) <br>    { <br>HGLOBAL hnres = medium.hGlobal; <br>LPNETRESOURCE pnr = (LPNETRESOURCE)LocalAlloc(LPTR, 1024); <br> <br>if (pnr) <br>{ <br>    char szBuf[512]; <br>    UINT cItems = DropExt_GetNetResource(hnres, (UINT)-1, NULL, 0); <br> <br>    // Get the NETRESOURCE of the first item <br>    DropExt_GetNetResource(hnres, 0, pnr, 1024); <br> <br>    wsprintf(szBuf, <br>     "%d network resource objects in HNRES\n" <br>     "The attributes of the first object are\n" <br>     "\tProvider      = %s\n" <br>     "\tRemoteName    = %s\n" <br>     "\tdwDisplayType = %x\n" <br>     "\tdwType        = %x\n" <br>     "\tdwUsage       = %x\n", <br>     cItems, <br>     pnr-&gt;lpProvider, <br>     pnr-&gt;lpRemoteName ? pnr-&gt;lpRemoteName : "N/A", <br>     pnr-&gt;dwDisplayType, <br>     pnr-&gt;dwType, <br>     pnr-&gt;dwUsage); <br> <br>    MessageBox(hwnd, szBuf, "DropExt", MB_OK); <br> <br>    LocalFree(pnr); <br>} <br>else <br>{ <br>    hres = ResultFromScode(E_OUTOFMEMORY); <br>} <br> <br>// <br>// HACK: We are supposed to call ReleaseStgMedium. This is a temporary <br>//  hack until OLE 2.01 for Windows 95 is released. <br>// <br>if (medium.pUnkForRelease) <br>{ <br>    medium.pUnkForRelease-&gt;lpVtbl-&gt;Release(medium.pUnkForRelease); <br>} <br>else <br>{ <br>    GlobalFree(medium.hGlobal); <br>} <br>    } <br>    else <br>    { <br>MessageBox(hwnd, "No network objects in the selection", "DropExt", MB_OK); <br>    } <br>    return hres; <br>} <br> <br>STDMETHODIMP DropExt_InvokeCommand(LPCONTEXTMENU pctm, <br>   LPCMINVOKECOMMANDINFO lpici) <br>{ <br>    PSAMPLEDROPEXT this = PCTM2PSMX(pctm); <br>    HRESULT hres = ResultFromScode(E_INVALIDARG);// assume error <br>    // <br>    // No need to support string based command. <br>    // <br>    if (!HIWORD(lpici-&gt;lpVerb)) <br>    { <br>UINT idCmd = LOWORD(lpici-&gt;lpVerb); <br> <br>switch(idCmd) <br>{ <br>case 0: <br>    hres = DropExt_CheckForHDROP(this, lpici-&gt;hwnd); <br>    break; <br> <br>case 1: <br>    hres = DropExt_CheckForHNRES(this, lpici-&gt;hwnd); <br>    break; <br>} <br>    } <br>    return hres; <br>} <br> <br>STDMETHODIMP DropExt_GetCommandString( <br>                                        LPCONTEXTMENU pctm, <br>                                        UINT        idCmd, <br>                                        UINT        wReserved, <br>                                        UINT FAR *  pwReserved, <br>                                        LPSTR       pszName, <br>                                        UINT        cchMax) <br>{ <br>    return NOERROR; <br>} <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt::AddRef (IContextMenu override) <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(UINT) DropExt_CTM_AddRef(LPCONTEXTMENU pctm) <br>{ <br>    PSAMPLEDROPEXT this = PCTM2PSMX(pctm); <br>    return ++this-&gt;_cRef; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt::AddRef (IShellExtInit override) <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(UINT) DropExt_SXI_AddRef(LPSHELLEXTINIT psxi) <br>{ <br>    PSAMPLEDROPEXT this = PSXI2PSMX(psxi); <br>    return ++this-&gt;_cRef; <br>} <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt::Release (IContextMenu override) <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(UINT) DropExt_CTM_Release(LPCONTEXTMENU pctm) <br>{ <br>    PSAMPLEDROPEXT this = PCTM2PSMX(pctm); <br>    if (--this-&gt;_cRef) { <br>return this-&gt;_cRef; <br>    } <br> <br>    if (this-&gt;_pdtobj) { <br>this-&gt;_pdtobj-&gt;lpVtbl-&gt;Release(this-&gt;_pdtobj); <br>    } <br> <br>    if (this-&gt;_hkeyProgID) { <br>RegCloseKey(this-&gt;_hkeyProgID); <br>    } <br> <br>    LocalFree((HLOCAL)this); <br>    g_cRefThisDll--; <br> <br>    return 0; <br>} <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt::Release (IShellExtInit thunk) <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(UINT) DropExt_SXI_Release(LPSHELLEXTINIT psxi) <br>{ <br>    PSAMPLEDROPEXT this = PSXI2PSMX(psxi); <br>    return DropExt_CTM_Release(&amp;this-&gt;_ctm); <br>} <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt::QueryInterface (IContextMenu override) <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP DropExt_CTM_QueryInterface(LPCONTEXTMENU pctm, REFIID riid, LPVOID FAR* ppvOut) <br>{ <br>    PSAMPLEDROPEXT this = PCTM2PSMX(pctm); <br>    if (IsEqualIID(riid, &amp;IID_IContextMenu) || IsEqualIID(riid, &amp;IID_IUnknown)) <br>    { <br>        (LPCONTEXTMENU)*ppvOut=pctm; <br>        this-&gt;_cRef++; <br>        return NOERROR; <br>    } <br>    if (IsEqualIID(riid, &amp;IID_IShellExtInit)) <br>    { <br>        (LPSHELLEXTINIT)*ppvOut=&amp;this-&gt;_sxi; <br>        this-&gt;_cRef++; <br>        return NOERROR; <br>    } <br>    return ResultFromScode(E_NOINTERFACE); <br>} <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt::QueryInterface (IShellExtInit thunk) <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP DropExt_SXI_QueryInterface(LPSHELLEXTINIT psxi, REFIID riid, LPVOID FAR* ppv) <br>{ <br>    PSAMPLEDROPEXT this = PSXI2PSMX(psxi); <br>    return DropExt_CTM_QueryInterface(&amp;this-&gt;_ctm, riid, ppv); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// CSampleDropExt class : Vtables <br>//--------------------------------------------------------------------------- <br> <br>#pragma data_seg(".text") <br>IContextMenuVtbl c_SampleDropExt_CTMVtbl = { <br>    DropExt_CTM_QueryInterface, <br>    DropExt_CTM_AddRef, <br>    DropExt_CTM_Release, <br>    DropExt_QueryContextMenu, <br>    DropExt_InvokeCommand, <br>    DropExt_GetCommandString, <br>}; <br> <br>IShellExtInitVtbl c_SampleDropExt_SXIVtbl = { <br>    DropExt_SXI_QueryInterface, <br>    DropExt_SXI_AddRef, <br>    DropExt_SXI_Release, <br>    DropExt_Initialize <br>}; <br>#pragma data_seg() </code></pre>
<p>&nbsp;</p></body>
</HTML>
