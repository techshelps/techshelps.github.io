<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APP32.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6572"></a>APP32.C</h2>
<pre><code>//--------------------------------------------------------------------------- <br>//--------------------------------------------------------------------------- <br>#include "app32.h" <br>#include &lt;windowsx.h&gt; <br> <br>#include "resource.h" <br> <br>#define MYWM_NOTIFYICON(WM_APP+100) <br> <br>//--------------------------------------------------------------------------- <br>// Global to everybody... <br>HINSTANCE g_hinst; <br> <br>#ifndef ARRAYSIZE <br>#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0])) <br>#endif <br> <br>struct _DLGITEMS <br>{ <br>DWORD dwStart; <br>UINT uNotify; <br>UINT uDelayID; <br>UINT uState1; <br>UINT uTip1; <br>UINT uState2; <br>UINT uTip2; <br>} g_sDlgItems [] = <br>{ <br>{ <br>0, IDC_NOTIFY1, IDC_DELAY1, IDC_STATE11, IDC_TIP11, IDC_STATE12, IDC_TIP12, <br>}, <br>{ <br>0, IDC_NOTIFY2, IDC_DELAY2, IDC_STATE21, IDC_TIP21, IDC_STATE22, IDC_TIP22, <br>}, <br>{ <br>0, IDC_NOTIFY3, IDC_DELAY3, IDC_STATE31, IDC_TIP31, IDC_STATE32, IDC_TIP32, <br>}, <br>} ; <br> <br> <br>BOOL TrayMessage(HWND hDlg, DWORD dwMessage, UINT uID, HICON hIcon, PSTR pszTip) <br>{ <br>        BOOL res; <br> <br>NOTIFYICONDATA tnd; <br> <br>tnd.cbSize= sizeof(NOTIFYICONDATA); <br>tnd.hWnd= hDlg; <br>tnd.uID= uID; <br> <br>tnd.uFlags= NIF_MESSAGE|NIF_ICON|NIF_TIP; <br>tnd.uCallbackMessage= MYWM_NOTIFYICON; <br>tnd.hIcon= hIcon; <br>if (pszTip) <br>{ <br>lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip)); <br>} <br>else <br>{ <br>tnd.szTip[0] = '\0'; <br>} <br> <br>res = Shell_NotifyIcon(dwMessage, &amp;tnd); <br> <br>if (hIcon) <br>    DestroyIcon(hIcon); <br> <br>return res; <br>} <br> <br> <br>LRESULT IconDrawItem(LPDRAWITEMSTRUCT lpdi) <br>{ <br>HICON hIcon; <br> <br>hIcon = (HICON)LoadImage(g_hinst, MAKEINTRESOURCE(lpdi-&gt;CtlID), IMAGE_ICON, <br>16, 16, 0); <br>if (!hIcon) <br>{ <br>return(FALSE); <br>} <br> <br>DrawIconEx(lpdi-&gt;hDC, lpdi-&gt;rcItem.left, lpdi-&gt;rcItem.top, hIcon, <br>16, 16, 0, NULL, DI_NORMAL); <br> <br>return(TRUE); <br>} <br> <br> <br>void StateChange(HWND hDlg, UINT uIndex, UINT uSelect) <br>{ <br>UINT uState1, uState2; <br>HWND hwndIcon; <br>LPCSTR pszIDIcon; <br>UINT uTip; <br>char szTip[64]; <br> <br>uState1 = g_sDlgItems[uIndex].uState1; <br>uState2 = g_sDlgItems[uIndex].uState2; <br> <br>// if !uSelect, find out which button is selected <br>if (!uSelect) <br>{ <br>uSelect = IsDlgButtonChecked(hDlg, uState2) ? uState2 : uState1; <br>} <br>// if uSelect&lt;0, find out shich button is NOT selected <br>else if ((int)uSelect &lt; 0) <br>{ <br>uSelect = IsDlgButtonChecked(hDlg, uState2) ? uState1 : uState2; <br>} <br> <br>CheckRadioButton(hDlg, uState1, uState2, uSelect); <br> <br>// If there is a tip specified, use it, otherwise use the default <br>uTip = uSelect==uState1 <br>? g_sDlgItems[uIndex].uTip1 : g_sDlgItems[uIndex].uTip2; <br>if (!GetDlgItemText(hDlg, uTip, szTip, sizeof(szTip)) <br>&amp;&amp; !LoadString(g_hinst, uSelect, szTip, sizeof(szTip))) <br>{ <br>*szTip = '\0'; <br>} <br> <br>// HACK: The ID of window after the radio button is the ID of the icon <br>hwndIcon = GetWindow(GetDlgItem(hDlg, uSelect), GW_HWNDNEXT); <br>pszIDIcon = MAKEINTRESOURCE(GetDlgCtrlID(hwndIcon)); <br> <br>TrayMessage(hDlg, NIM_MODIFY, g_sDlgItems[uIndex].uNotify, <br>LoadImage(g_hinst, pszIDIcon, IMAGE_ICON, 16, 16, 0), szTip); <br>} <br> <br> <br>void NotifyDelete(HWND hDlg, UINT uIndex) <br>{ <br>TrayMessage(hDlg, NIM_DELETE, g_sDlgItems[uIndex].uNotify, NULL, NULL); <br>} <br> <br> <br>void NotifyAdd(HWND hDlg, UINT uIndex) <br>{ <br>TrayMessage(hDlg, NIM_ADD, g_sDlgItems[uIndex].uNotify, NULL, NULL); <br> <br>StateChange(hDlg, uIndex, 0); <br>} <br> <br> <br>void NotifyChange(HWND hDlg, UINT uIndex) <br>{ <br>UINT uDelay; <br>BOOL bTranslated; <br>BOOL bEnable; <br> <br>if (IsDlgButtonChecked(hDlg, g_sDlgItems[uIndex].uNotify)) <br>{ <br>uDelay = GetDlgItemInt(hDlg, g_sDlgItems[uIndex].uDelayID, <br>&amp;bTranslated, FALSE); <br>if (uDelay) <br>{ <br>g_sDlgItems[uIndex].dwStart = GetTickCount() + uDelay*60000; <br>SetTimer(hDlg, uIndex, 60000, NULL); <br>} <br>else <br>{ <br>NotifyAdd(hDlg, uIndex); <br>} <br>} <br>else <br>{ <br>NotifyDelete(hDlg, uIndex); <br>} <br> <br>for (uIndex=0, bEnable=FALSE; uIndex&lt;ARRAYSIZE(g_sDlgItems); ++uIndex) <br>{ <br>if (IsDlgButtonChecked(hDlg, g_sDlgItems[uIndex].uNotify)) <br>{ <br>bEnable = TRUE; <br>} <br>} <br>EnableWindow(GetDlgItem(hDlg, IDABORT), bEnable); <br>} <br> <br> <br>BOOL CALLBACK TestAppDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>break; <br> <br>case WM_DRAWITEM: <br>return(IconDrawItem((LPDRAWITEMSTRUCT)lParam)); <br>break; <br> <br>case WM_DESTROY: <br>NotifyDelete(hDlg, 0); <br>NotifyDelete(hDlg, 1); <br>NotifyDelete(hDlg, 2); <br>break; <br> <br>case WM_TIMER: <br>if (wParam &gt;= ARRAYSIZE(g_sDlgItems)) <br>{ <br>break; <br>} <br> <br>if ((int)(GetTickCount() - g_sDlgItems[wParam].dwStart) &lt; 0) <br>{ <br>break; <br>} <br> <br>KillTimer(hDlg, wParam); <br>NotifyAdd(hDlg, wParam); <br>break; <br> <br>case WM_COMMAND: <br>switch (GET_WM_COMMAND_ID(wParam, lParam)) <br>{ <br>case IDCANCEL: <br>EndDialog(hDlg, TRUE); <br>break; <br> <br>case IDABORT: <br>ShowWindow(hDlg, SW_HIDE); <br>break; <br> <br>case IDC_NOTIFY1: <br>NotifyChange(hDlg, 0); <br>break; <br> <br>case IDC_NOTIFY2: <br>NotifyChange(hDlg, 1); <br>break; <br> <br>case IDC_NOTIFY3: <br>NotifyChange(hDlg, 2); <br>break; <br> <br>case IDC_STATE11: <br>case IDC_STATE12: <br>StateChange(hDlg, 0, GET_WM_COMMAND_ID(wParam, lParam)); <br>break; <br> <br>case IDC_STATE21: <br>case IDC_STATE22: <br>StateChange(hDlg, 1, GET_WM_COMMAND_ID(wParam, lParam)); <br>break; <br> <br>case IDC_STATE31: <br>case IDC_STATE32: <br>StateChange(hDlg, 2, GET_WM_COMMAND_ID(wParam, lParam)); <br>break; <br>} <br>break; <br> <br>case MYWM_NOTIFYICON: <br>switch (lParam) <br>{ <br>case WM_LBUTTONDOWN: <br>switch (wParam) <br>{ <br>case IDC_NOTIFY1: <br>StateChange(hDlg, 0, (UINT)-1); <br>break; <br> <br>case IDC_NOTIFY2: <br>StateChange(hDlg, 1, (UINT)-1); <br>break; <br> <br>case IDC_NOTIFY3: <br>StateChange(hDlg, 2, (UINT)-1); <br>break; <br> <br>default: <br>break; <br>} <br>break; <br> <br>case WM_RBUTTONDOWN: <br>ShowWindow(hDlg, SW_SHOW); <br>SetForegroundWindow(hDlg);// make us come to the front <br>break; <br> <br>default: <br>break; <br>} <br>break; <br> <br>default: <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>g_hinst = hInstance; <br>DialogBox(hInstance, MAKEINTRESOURCE(IDD_APP32), NULL, TestAppDlgProc); <br>return(FALSE); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
