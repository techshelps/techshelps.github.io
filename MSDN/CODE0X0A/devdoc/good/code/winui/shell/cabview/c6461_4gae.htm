<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FDI.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6476"></a>FDI.H</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : Fdi.h <br>// <br>//Common defines for FCI/FDI stuff  <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br> <br>#ifndef INCLUDED_TYPES_FCI_FDI <br>#define INCLUDED_TYPES_FCI_FDI 1 <br> <br>#ifdef __cplusplus <br>extern "C" {            /* Assume C declarations for C++ */ <br>#endif  /* __cplusplus */ <br> <br>//** Define away for 32-bit (NT/Windows95) build <br>#ifndef HUGE <br>#define HUGE <br>#endif <br> <br>#ifndef FAR <br>#define FAR <br>#endif <br> <br> <br> <br>#ifndef DIAMONDAPI <br>#define DIAMONDAPI __cdecl <br>#endif <br> <br> <br>//** Specify structure packing explicitly for clients of FDI <br>#pragma pack(4) <br> <br>//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS) <br>//   or Win32 WINDOWS.H (_WINDOWS_) <br>// <br>#if !defined(_INC_WINDOWS) &amp;&amp; !defined(_WINDOWS_) <br>typedef int            BOOL;     /* f */ <br>typedef unsigned char  BYTE;     /* b */ <br>typedef unsigned int   UINT;     /* ui */ <br>typedef unsigned short USHORT;   /* us */ <br>typedef unsigned long  ULONG;    /* ul */ <br>#endif   // _INC_WINDOWS <br> <br>typedef unsigned long  CHECKSUM; /* csum */ <br> <br>typedef unsigned long  UOFF;     /* uoff - uncompressed offset */ <br>typedef unsigned long  COFF;     /* coff - cabinet file offset */ <br> <br> <br>#ifndef TRUE <br>#define TRUE    1 <br>#endif <br> <br>#ifndef FALSE <br>#define FALSE   0 <br>#endif <br> <br>#ifndef NULL <br>#define NULL    0 <br>#endif <br> <br> <br>/***    ERF - Error structure <br> * <br> *  This structure returns error information from FCI/FDI.  The caller should <br> *  not modify this structure. <br> */ <br>typedef struct { <br>    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX <br>                                //  and FCIERR_XXX equates for details. <br> <br>    int     erfType;            // Optional error value filled in by FCI/FDI. <br>                                // For FCI, this is usually the C run-time <br>                                // *errno* value. <br> <br>    BOOL    fError;             // TRUE =&gt; error present <br>} ERF;      /* erf */ <br>typedef ERF FAR *PERF;  /* perf */ <br> <br>#ifdef _DEBUG <br>// don't hide statics from map during debugging <br>#define STATIC       <br>#else // !DEBUG <br>#define STATIC static <br>#endif // !DEBUG <br> <br>#define CB_MAX_CHUNK            32768U <br>#define CB_MAX_DISK         0x7ffffffL <br>#define CB_MAX_FILENAME            256 <br>#define CB_MAX_CABINET_NAME        256 <br>#define CB_MAX_CAB_PATH            256 <br>#define CB_MAX_DISK_NAME           256 <br> <br> <br>/***    FNALLOC - Memory Allocation <br> *      FNFREE  - Memory Free <br> * <br> *  These are modeled after the C run-time routines malloc() and free() <br> *  (16-bit clients please note -- the size is a ULONG, so you may need <br> *  to write a wrapper routine for halloc!).  FDI expects error <br> *  handling to be identical to these C run-time routines. <br> * <br> *  As long as you faithfully copy the semantics of malloc() and free(), <br> *  you can supply any functions you like! <br> * <br> *  WARNING: You should never assume anything about the sequence of <br> *           PFNALLOC and PFNFREE calls -- incremental releases of <br> *           Diamond/FDI may have radically different numbers of <br> *           PFNALLOC calls and allocation sizes! <br> */ <br>typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */ <br>#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb) <br> <br>typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */ <br>#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv) <br> <br> <br>/***    tcompXXX - Diamond compression types <br> * <br> *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER <br> *  structures in cabinet files. <br> * <br> *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM <br> *        to provide room for future expansion.  Since this value is stored <br> *        in the CFDATA records in the cabinet file, we don't want to <br> *        have to change the format for existing compression configurations <br> *        if we add new ones in the future.  This will allows us to read <br> *        old cabinet files in the future. <br> */ <br> <br>typedef unsigned short TCOMP; /* tcomp */ <br> <br>#define tcompMASK_TYPE          0x000F  // Mask for compression type <br>#define tcompTYPE_NONE          0x0000  // No compression <br>#define tcompTYPE_MSZIP         0x0001  // MSZIP <br>#define tcompTYPE_QUANTUM       0x0002  // Quantum <br>#define tcompBAD                0x000F  // Unspecified compression type <br> <br>#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level <br>#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1) <br>#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7) <br>#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int <br> <br>#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory <br>#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10) <br>#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21) <br>#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int <br> <br>#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits) <br> <br> <br> <br>#define CompressionTypeFromTCOMP(tc) \ <br>            ((tc) &amp; tcompMASK_TYPE) <br> <br>#define CompressionLevelFromTCOMP(tc) \ <br>            (((tc) &amp; tcompMASK_QUANTUM_LEVEL) &gt;&gt; tcompSHIFT_QUANTUM_LEVEL) <br> <br>#define CompressionMemoryFromTCOMP(tc) \ <br>            (((tc) &amp; tcompMASK_QUANTUM_MEM) &gt;&gt; tcompSHIFT_QUANTUM_MEM) <br> <br>#define TCOMPfromTypeLevelMemory(t,l,m)           \ <br>            (((m) &lt;&lt; tcompSHIFT_QUANTUM_MEM  ) |  \ <br>             ((l) &lt;&lt; tcompSHIFT_QUANTUM_LEVEL) |  \ <br>             ( t                             )) <br> <br> <br>//** Revert to default structure packing <br>#pragma pack() <br> <br>#endif // !INCLUDED_TYPES_FCI_FDI <br>/***     - Diamond File Decompression Interface definitions <br> *                       <br> *       <br> *  ATTENTION: <br> *      This is the only documentation on the Diamond File Decompression <br> *      Interface (FDI).  Please read it carefully, as there are some subtle <br> *      points in FDI that are carefully explained below. <br> * <br> *  Concepts: <br> *      A *cabinet* file contains one or more *folders*.  A folder contains <br> *      one or more (pieces of) *files*.  A folder is by definition a <br> *      decompression unit, i.e., to extract a file from a folder, all of <br> *      the data from the start of the folder up through and including the <br> *      desired file must be read and decompressed. <br> * <br> *      A folder can span one (or more) cabinet boundaries, and by implication <br> *      a file can also span one (or more) cabinet boundaries.  Indeed, more <br> *      than one file can span a cabinet boundary, since Diamond concatenates <br> *      files together into a single data stream before compressing (actually, <br> *      at most one file will span any one cabinet boundary, but Diamond does <br> *      not know which file this is, since the mapping from uncompressed bytes <br> *      to compressed bytes is pretty obscure.  Also, since Diamond compresses <br> *      in blocks of 32K (at present), any files with data in a 32K block that <br> *      spans a cabinet boundary require Diamond to read both cabinet files <br> *      to get the two halves of the compressed block). <br> * <br> *  Overview: <br> *      The File Decompression Interface is used to simplify the reading of <br> *      Diamond cabinet files.  A setup program will proceed in a manner very <br> *      similar to the pseudo code below.  An FDI context is created, the <br> *      setup program calls FDICopy() for each cabinet to be processed.  For <br> *      each file in the cabinet, FDICopy() calls a notification callback <br> *      routine, asking the setup program if the file should be copied. <br> *      This call-back approach is great because it allows the cabinet file <br> *      to be read and decompressed in an optimal manner, and also makes FDI <br> *      independent of the run-time environment -- FDI makes *no* C run-time <br> *      calls whatsoever.  All memory allocation and file I/O functions are <br> *      passed into FDI by the client. <br> * <br> *      main(...) <br> *      { <br> *          // Read INF file to construct list of desired files.    <br> *          //  Ideally, these would be sorted in the same order as the <br> *          //  files appear in the cabinets, so that you can just walk <br> *          //  down the list in response to fdintCOPY_FILE notifications. <br> * <br> *          // Construct list of required cabinets.  <br> * <br> *          hfdi = FDICreate(...);          // Create FDI context <br> *          For (cabinet in List of Cabinets) { <br> *              FDICopy(hfdi,cabinet,fdiNotify,...);  // Process each cabinet <br> *          } <br> *          FDIDestroy(hfdi); <br> *          ... <br> *      } <br> * <br> *      // Notification callback function  <br> *      fdiNotify(fdint,...) <br> *      { <br> *          If (User Aborted)               // Permit cancellation <br> *              if (fdint == fdintCLOSE_FILE_INFO) <br> *                  close open file <br> *              return -1; <br> *          switch (fdint) { <br> *              case fdintCOPY_FILE:        // File to copy, maybe <br> *                  // Check file against list of desired files  <br> *                  if want to copy file <br> *                      open destination file and return handle <br> *                  else <br> *                      return NULL;        // Skip file <br> *              case fdintCLOSE_FILE_INFO: <br> *                  close file <br> *                  set date, time, and attributes <br> * <br> *              case fdintNEXT_CABINET: <br> *                  if not an error callback <br> *                      Tell FDI to use suggested directory name <br> *                  else <br> *                      Tell user what the problem was, and prompt <br> *                          for a new disk and/or path. <br> *                      if user aborts <br> *                          Tell FDI to abort <br> *                      else <br> *                          return to FDI to try another cabinet <br> *                  //NOTE: Be sure to see the (sample) code in EXTRACT.C <br> *                  //      for an example of how to do this! <br> *              ... <br> *      } <br> * <br> *  Error Handling Suggestions: <br> *      Since you the client have passed in *all* of the functions that <br> *      FDI uses to interact with the "outside" world, you are in prime <br> *      position to understand and deal with errors. <br> * <br> *      The general philosophy of FDI is to pass all errors back up to <br> *      the client.  FDI returns fairly generic error codes in the case <br> *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail, <br> *      since it assumes that the callback function will save enough <br> *      information in a static/global so that when FDICopy() returns <br> *      fail, the client can examine this information and report enough <br> *      detail about the problem that the user can take corrective action. <br> * <br> *      For very specific errors (CORRUPT_CABINET, for example), FDI returns <br> *      very specific error codes. <br> * <br> *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING <br> *      ERRORS TO FDI! <br> * <br> *      Examples: <br> *          (1) If the disk is getting full, instead of returning an error <br> *              from your PFNWRITE function, you should -- inside your <br> *              PFNWRITE function -- put up a dialog telling the user to free <br> *              some disk space. <br> *          (2) When you get the fdintNEXT_CABINET notification, you should <br> *              verify that the cabinet you return is the correct one (call <br> *              FDIIsCabinet(), and make sure the setID matches the one for <br> *              the current cabinet specified in the fdintCABINET_INFO, and <br> *              that the disk number is one greater. <br> * <br> *              NOTE: FDI will continue to call fdintNEXT_CABINET until it <br> *                    gets the cabinet it wants, or until you return -1 <br> *                    to abort the FDICopy() call. <br> * <br> *      The documentation below on the FDI error codes provides explicit <br> *      guidance on how to avoid each error. <br> * <br> *      If you find you must return a failure to FDI from one of your <br> *      callback functions, then FDICopy() frees all resources it allocated <br> *      and closes all files.  If you can figure out how to overcome the <br> *      problem, you can call FDICopy() again on the last cabinet, and <br> *      skip any files that you already copied.  But, note that FDI does <br> *      *not* maintain any state between FDICopy() calls, other than possibly <br> *      memory allocated for the decompressor. <br> * <br> *      See FDIERROR for details on FDI error codes and recommended actions. <br> * <br> * <br> *  Progress Indicator Suggestions: <br> *      As above, all of the file I/O functions are supplied by you.  So, <br> *      updating a progress indicator is very simple.  You keep track of <br> *      the target files handles you have opened, along with the uncompressed <br> *      size of the target file.  When you see writes to the handle of a <br> *      target file, you use the write count to update your status! <br> *      Since this method is available, there is no separate callback from <br> *      FDI just for progess indication. <br> */ <br> <br>#ifndef INCLUDED_FDI <br>#define INCLUDED_FDI    1 <br> <br>//** Specify structure packing explicitly for clients of FDI <br>#pragma pack(4) <br> <br> <br>/***    FDIERROR - Error codes returned in erf.erfOper field <br> * <br> *  In general, FDI will only fail if one of the passed in memory or <br> *  file I/O functions fails.  Other errors are pretty unlikely, and are <br> *  caused by corrupted cabinet files, passing in a file which is not a <br> *  cabinet file, or cabinet files out of order. <br> * <br> *  Description:    Summary of error. <br> *  Cause:          List of possible causes of this error. <br> *  Response:       How client might respond to this error, or avoid it in <br> *                  the first place. <br> */ <br>typedef enum { <br>    FDIERROR_NONE, <br>        // Description: No error <br>        // Cause:       Function was successfull. <br>        // Response:    Keep going! <br> <br>    FDIERROR_CABINET_NOT_FOUND, <br>        // Description: Cabinet not found <br>        // Cause:       Bad file name or path passed to FDICopy(), or returned <br>        //              to fdintNEXT_CABINET. <br>        // Response:    To prevent this error, validate the existence of the <br>        //              the cabinet *before* passing the path to FDI. <br> <br>    FDIERROR_NOT_A_CABINET, <br>        // Description: Cabinet file does not have the correct format <br>        // Cause:       File passed to to FDICopy(), or returned to <br>        //              fdintNEXT_CABINET, is too small to be a cabinet file, <br>        //              or does not have the cabinet signature in its first <br>        //              four bytes. <br>        // Response:    To prevent this error, call FDIIsCabinet() to check a <br>        //              cabinet before calling FDICopy() or returning the <br>        //              cabinet path to fdintNEXT_CABINET. <br> <br>    FDIERROR_UNKNOWN_CABINET_VERSION, <br>        // Description: Cabinet file has an unknown version number. <br>        // Cause:       File passed to to FDICopy(), or returned to <br>        //              fdintNEXT_CABINET, has what looks like a cabinet file <br>        //              header, but the version of the cabinet file format <br>        //              is not one understood by this version of FDI.  The <br>        //              erf.erfType field is filled in with the version number <br>        //              found in the cabinet file. <br>        // Response:    To prevent this error, call FDIIsCabinet() to check a <br>        //              cabinet before calling FDICopy() or returning the <br>        //              cabinet path to fdintNEXT_CABINET. <br> <br>    FDIERROR_CORRUPT_CABINET, <br>        // Description: Cabinet file is corrupt <br>        // Cause:       FDI returns this error any time it finds a problem <br>        //              with the logical format of a cabinet file, and any <br>        //              time one of the passed-in file I/O calls fails when <br>        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD, <br>        //              or PFNCLOSE).  The client can distinguish these two <br>        //              cases based upon whether the last file I/O call <br>        //              failed or not. <br>        // Response:    Assuming this is not a real corruption problem in <br>        //              a cabinet file, the file I/O functions could attempt <br>        //              to do retries on failure (for example, if there is a <br>        //              temporary network connection problem).  If this does <br>        //              not work, and the file I/O call has to fail, then the <br>        //              FDI client will have to clean up and call the <br>        //              FDICopy() function again. <br> <br>    FDIERROR_ALLOC_FAIL, <br>        // Description: Could not allocate enough memory <br>        // Cause:       FDI tried to allocate memory with the PFNALLOC <br>        //              function, but it failed. <br>        // Response:    If possible, PFNALLOC should take whatever steps <br>        //              are possible to allocate the memory requested.  If <br>        //              memory is not immediately available, it might post a <br>        //              dialog asking the user to free memory, for example. <br>        //              Note that the bulk of FDI's memory allocations are <br>        //              made at FDICreate() time and when the first cabinet <br>        //              file is opened during FDICopy(). <br> <br>    FDIERROR_BAD_COMPR_TYPE, <br>        // Description: Unknown compression type in a cabinet folder <br>        // Cause:       [Should never happen.]  A folder in a cabinet has an <br>        //              unknown compression type.  This is probably caused by <br>        //              a mismatch between the version of Diamond used to <br>        //              create the cabinet and the FDI. LIB used to read the <br>        //              cabinet. <br>        // Response:    Abort. <br> <br>    FDIERROR_MDI_FAIL, <br>        // Description: Failure decompressing data from a cabinet file <br>        // Cause:       The decompressor found an error in the data coming <br>        //              from the file cabinet.  The cabinet file was corrupted. <br>        //              [11-Apr-1994 bens When checksuming is turned on, this <br>        //              error should never occur.] <br>        // Response:    Probably should abort; only other choice is to cleanup <br>        //              and call FDICopy() again, and hope there was some <br>        //              intermittent data error that will not reoccur. <br> <br>    FDIERROR_TARGET_FILE, <br>        // Description: Failure writing to target file <br>        // Cause:       FDI returns this error any time it gets an error back <br>        //              from one of the passed-in file I/O calls fails when <br>        //              writing to a file being extracted from a cabinet. <br>        // Response:    To avoid or minimize this error, the file I/O functions <br>        //              could attempt to avoid failing.  A common cause might <br>        //              be disk full -- in this case, the PFNWRITE function <br>        //              could have a check for free space, and put up a dialog <br>        //              asking the user to free some disk space. <br> <br>    FDIERROR_RESERVE_MISMATCH, <br>        // Description: Cabinets in a set do not have the same RESERVE sizes <br>        // Cause:       [Should never happen]. FDI requires that the sizes of <br>        //              the per-cabinet, per-folder, and per-data block <br>        //              RESERVE sections be consistent across all the cabinet <br>        //              in a set.  Diamond will only generate cabinet sets <br>        //              with these properties. <br>        // Response:    Abort. <br> <br>    FDIERROR_WRONG_CABINET, <br>        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect <br>        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()! <br>        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET <br>        //              callback until either the correct cabinet is specified, <br>        //              or you return ABORT. <br>        //              When FDICopy() is extracting a file that crosses a <br>        //              cabinet boundary, it calls fdintNEXT_CABINET to ask <br>        //              for the path to the next cabinet.  Not being very <br>        //              trusting, FDI then checks to make sure that the <br>        //              correct continuation cabinet was supplied!  It does <br>        //              this by checking the "setID" and "iCabinet" fields <br>        //              in the cabinet.  When DIAMOND.EXE creates a set of <br>        //              cabinets, it constructs the "setID" using the sum <br>        //              of the bytes of all the destination file names in <br>        //              the cabinet set.  FDI makes sure that the 16-bit <br>        //              setID of the continuation cabinet matches the <br>        //              cabinet file just processed.  FDI then checks that <br>        //              the cabinet number (iCabinet) is one more than the <br>        //              cabinet number for the cabinet just processed. <br>        // Response:    You need code in your fdintNEXT_CABINET (see below) <br>        //              handler to do retries if you get recalled with this <br>        //              error.  See the sample code (EXTRACT.C) to see how <br>        //              this should be handled. <br> <br>    FDIERROR_USER_ABORT, <br>        // Description: FDI aborted. <br>        // Cause:       An FDI callback returnd -1 (usually). <br>        // Response:    Up to client. <br> <br>} FDIERROR; <br> <br> <br>/***    HFDI - Handle to an FDI context <br> * <br> *  FDICreate() creates this, and it must be passed to all other FDI <br> *  functions. <br> */ <br>typedef void FAR *HFDI; /* hfdi */ <br> <br> <br>/***    FDICABINETINFO - Information about a cabinet <br> * <br> */ <br>typedef struct { <br>    long        cbCabinet;              // Total length of cabinet file <br>    USHORT      cFolders;               // Count of folders in cabinet <br>    USHORT      cFiles;                 // Count of files in cabinet <br>    USHORT      setID;                  // Cabinet set ID <br>    USHORT      iCabinet;               // Cabinet number in set (0 based) <br>    BOOL        fReserve;               // TRUE =&gt; RESERVE present in cabinet <br>    BOOL        hasprev;                // TRUE =&gt; Cabinet is chained prev <br>    BOOL        hasnext;                // TRUE =&gt; Cabinet is chained next <br>} FDICABINETINFO; /* fdici */ <br>typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */ <br> <br> <br>/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types <br> * <br> */ <br>typedef enum { <br>    fdidtNEW_CABINET,                   // New cabinet <br>    fdidtNEW_FOLDER,                    // New folder <br>    fdidtDECRYPT,                       // Decrypt a data block <br>} FDIDECRYPTTYPE; /* fdidt */ <br> <br> <br>/***    FDIDECRYPT - Data for PFNFDIDECRYPT function <br> * <br> */ <br>typedef struct { <br>    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below) <br>    void FAR         *pvUser;           // Decryption context <br>    union { <br>        struct {                        // fdidtNEW_CABINET <br>            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER <br>            USHORT    cbHeaderReserve;  // Size of pHeaderReserve <br>            USHORT    setID;            // Cabinet set ID <br>            int       iCabinet;         // Cabinet number in set (0 based) <br>        } cabinet; <br> <br>        struct {                        // fdidtNEW_FOLDER <br>            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER <br>            USHORT    cbFolderReserve;  // Size of pFolderReserve <br>            USHORT    iFolder;          // Folder number in cabinet (0 based) <br>        } folder; <br> <br>        struct {                        // fdidtDECRYPT <br>            void FAR *pDataReserve;     // RESERVE section from CFDATA <br>            USHORT    cbDataReserve;    // Size of pDataReserve <br>            void FAR *pbData;           // Data buffer <br>            USHORT    cbData;           // Size of data buffer <br>            BOOL      fSplit;           // TRUE if this is a split data block <br>            USHORT    cbPartial;        // 0 if this is not a split block, or <br>                                        //  the first piece of a split block; <br>                                        // Greater than 0 if this is the <br>                                        //  second piece of a split block. <br>        } decrypt; <br>    }; <br>} FDIDECRYPT; /* fdid */ <br>typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */ <br> <br> <br>/***    PFNFDIDECRYPT - FDI Decryption callback <br> * <br> *  If this function is passed on the FDICopy() call, then FDI calls it <br> *  at various times to update the decryption state and to decrypt FCDATA <br> *  blocks. <br> * <br> *  Common Entry Conditions: <br> *      pfdid-&gt;fdidt  - Command type <br> *      pfdid-&gt;pvUser - pvUser value from FDICopy() call <br> * <br> *  fdidtNEW_CABINET:   //** Notification of a new cabinet <br> *      Entry: <br> *        pfdid-&gt;cabinet. <br> *          pHeaderReserve  - RESERVE section from CFHEADER <br> *          cbHeaderReserve - Size of pHeaderReserve <br> *          setID           - Cabinet set ID <br> *          iCabinet        - Cabinet number in set (0 based) <br> *      Exit-Success: <br> *          returns anything but -1; <br> *      Exit-Failure: <br> *          returns -1; FDICopy() is aborted. <br> *      Notes: <br> *      (1) This call allows the decryption code to pick out any information <br> *          from the cabinet header reserved area (placed there by DIACRYPT) <br> *          needed to perform decryption.  If there is no such information, <br> *          this call would presumably be ignored. <br> *      (2) This call is made very soon after fdintCABINET_INFO. <br> * <br> *  fdidtNEW_FOLDER:    //** Notification of a new folder <br> *      Entry: <br> *        pfdid-&gt;folder. <br> *          pFolderReserve  - RESERVE section from CFFOLDER <br> *          cbFolderReserve - Size of pFolderReserve <br> *          iFolder         - Folder number in cabinet (0 based) <br> *      Exit-Success: <br> *          returns anything but -1; <br> *      Exit-Failure: <br> *          returns -1; FDICopy() is aborted. <br> *      Notes: <br> *          This call allows the decryption code to pick out any information <br> *          from the folder reserved area (placed there by DIACRYPT) needed <br> *          to perform decryption.  If there is no such information, this <br> *          call would presumably be ignored. <br> * <br> *  fdidtDECRYPT:       //** Decrypt a data buffer <br> *      Entry: <br> *        pfdid-&gt;folder. <br> *          pDataReserve  - RESERVE section for this CFDATA block <br> *          cbDataReserve - Size of pDataReserve <br> *          pbData        - Data buffer <br> *          cbData        - Size of data buffer <br> *          fSplit        - TRUE if this is a split data block <br> *          cbPartial     - 0 if this is not a split block, or the first <br> *                              piece of a split block; Greater than 0 if <br> *                              this is the second piece of a split block. <br> *      Exit-Success: <br> *          returns TRUE; <br> *      Exit-Failure: <br> *          returns FALSE; error during decrypt <br> *          returns -1; FDICopy() is aborted. <br> *      Notes: <br> *          Diamond will split CFDATA blocks across cabinet boundaries if <br> *          necessary.  To provide maximum flexibility, FDI will call the <br> *          fdidtDECRYPT function twice on such split blocks, once when <br> *          the first portion is read, and again when the second portion <br> *          is read.  And, of course, most data blocks will not be split. <br> *          So, there are three cases: <br> * <br> *           1) fSplit == FALSE <br> *              You have the entire data block, so decrypt it. <br> * <br> *           2) fSplit == TRUE, cbPartial == 0 <br> *              This is the first portion of a split data block, so cbData <br> *              is the size of this portion.  You can either choose to decrypt <br> *              this piece, or ignore this call and decrypt the full CFDATA <br> *              block on the next (second) fdidtDECRYPT call. <br> * <br> *           3) fSplit == TRUE, cbPartial &gt; 0 <br> *              This is the second portion of a split data block (indeed, <br> *              cbPartial will have the same value as cbData did on the <br> *              immediately preceeding fdidtDECRYPT call!).  If you decrypted <br> *              the first portion on the first call, then you can decrypt the <br> *              second portion now.  If you ignored the first call, then you <br> *              can decrypt the entire buffer. <br> *              NOTE: pbData points to the second portion of the split data <br> *                    block in this case, *not* the entire data block.  If <br> *                    you want to wait until the second piece to decrypt the <br> *                    *entire* block, pbData-cbPartial is the address of the <br> *                    start of the whole block, and cbData+cbPartial is its <br> *                    size. <br> */ <br>typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */ <br>#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid) <br> <br> <br>/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY <br> * <br> *  See the FDINOTIFICATIONTYPE definition for information on usage and <br> *  meaning of these fields. <br> */ <br>typedef struct { <br>// long fields <br>    long      cb; <br>    char FAR *psz1; <br>    char FAR *psz2; <br>    char FAR *psz3;                     // Points to a 256 character buffer <br>    void FAR *pv;                       // Value for client <br> <br>// int fields <br>    int       hf; <br> <br>// short fields <br>    USHORT    date; <br>    USHORT    time; <br>    USHORT    attribs; <br> <br>    USHORT    setID;                    // Cabinet set ID <br>    USHORT    iCabinet;                 // Cabinet number (0-based) <br> <br>    FDIERROR  fdie; <br>} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */ </code></pre>
<p>
</p>
<pre><code><br> <br>/***    FDINOTIFICATIONTYPE - FDICopy notification types <br> * <br> *  The notification function for FDICopy can be called with the following <br> *  values for the fdint parameter.  In all cases, the pfdin-&gt;pv field is <br> *  filled in with the value of the pvUser argument passed in to FDICopy(). <br> * <br> *  A typical sequence of calls will be something like this: <br> *      fdintCABINET_INFO     // Info about the cabinet <br> *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and <br> *                            // one or more files were continued from the <br> *                            // previous cabinet. <br> *      ... <br> *      fdintPARTIAL_FILE <br> *      fdintCOPY_FILE        // The first file that starts in this cabinet <br> *      ... <br> *      fdintCOPY_FILE        // Now let's assume you want this file... <br> *      // PFNWRITE called multiple times to write to this file. <br> *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes <br> * <br> *      fdintCOPY_FILE        // Now let's assume you want this file... <br> *      // PFNWRITE called multiple times to write to this file. <br> *      fdintNEXT_CABINET     // File was continued to next cabinet! <br> *      fdintCABINET_INFO     // Info about the new cabinet <br> *      // PFNWRITE called multiple times to write to this file. <br> *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes <br> *      ... <br> * <br> *  fdintCABINET_INFO: <br> *        Called exactly once for each cabinet opened by FDICopy(), including <br> *        continuation cabinets opened due to file(s) spanning cabinet <br> *        boundaries. Primarily intended to permit EXTRACT.EXE to <br> *        automatically select the next cabinet in a cabinet sequence even if <br> *        not copying files that span cabinet boundaries. <br> *      Entry: <br> *          pfdin-&gt;psz1     = name of next cabinet <br> *          pfdin-&gt;psz2     = name of next disk <br> *          pfdin-&gt;psz3     = cabinet path name <br> *          pfdin-&gt;setID    = cabinet set ID (a random 16-bit number) <br> *          pfdin-&gt;iCabinet = Cabinet number within cabinet set (0-based) <br> *      Exit-Success: <br> *          Return anything but -1 <br> *      Exit-Failure: <br> *          Returns -1 =&gt; Abort FDICopy() call <br> *      Notes: <br> *          This call is made *every* time a new cabinet is examined by <br> *          FDICopy().  So if "foo2.cab" is examined because a file is <br> *          continued from "foo1.cab", and then you call FDICopy() again <br> *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all <br> *          told. <br> * <br> *  fdintCOPY_FILE: <br> *        Called for each file that *starts* in the current cabinet, giving <br> *        the client the opportunity to request that the file be copied or <br> *        skipped. <br> *      Entry: <br> *          pfdin-&gt;psz1    = file name in cabinet <br> *          pfdin-&gt;cb      = uncompressed size of file <br> *          pfdin-&gt;date    = file date <br> *          pfdin-&gt;time    = file time <br> *          pfdin-&gt;attribs = file attributes <br> *      Exit-Success: <br> *          Return non-zero file handle for destination file; FDI writes <br> *          data to this file use the PFNWRITE function supplied to FDICreate, <br> *          and then calls fdintCLOSE_FILE_INFO to close the file and set <br> *          the date, time, and attributes.  NOTE: This file handle returned <br> *          must also be closeable by the PFNCLOSE function supplied to <br> *          FDICreate, since if an error occurs while writing to this handle, <br> *          FDI will use the PFNCLOSE function to close the file so that the <br> *          client may delete it. <br> *      Exit-Failure: <br> *          Returns 0  =&gt; Skip file, do not copy <br> *          Returns -1 =&gt; Abort FDICopy() call <br> * <br> *  fdintCLOSE_FILE_INFO: <br> *        Called after all of the data has been written to a target file. <br> *        This function must close the file and set the file date, time, <br> *        and attributes. <br> *      Entry: <br> *          pfdin-&gt;psz1    = file name in cabinet <br> *          pfdin-&gt;hf      = file handle <br> *          pfdin-&gt;date    = file date <br> *          pfdin-&gt;time    = file time <br> *          pfdin-&gt;attribs = file attributes <br> *      Exit-Success: <br> *          Returns TRUE <br> *      Exit-Failure: <br> *          Returns FALSE, or -1 to abort; <br> *              IMPORTANT NOTE: <br> *                  FDI assumes that the target file was closed, even if this <br> *                  callback returns failure.  FDI will NOT attempt to use <br> *                  the PFNCLOSE function supplied on FDICreate() to close <br> *                  the file! <br> * <br> *  fdintPARTIAL_FILE: <br> *        Called for files at the front of the cabinet that are CONTINUED <br> *        from a previous cabinet.  This callback occurs only when FDICopy is <br> *        started on second or subsequent cabinet in a series that has files <br> *        continued from a previous cabinet. <br> *      Entry: <br> *          pfdin-&gt;psz1 = file name of file CONTINUED from a PREVIOUS cabinet <br> *          pfdin-&gt;psz2 = name of cabinet where file starts <br> *          pfdin-&gt;psz3 = name of disk where file starts <br> *      Exit-Success: <br> *          Return anything other than -1; enumeration continues <br> *      Exit-Failure: <br> *          Returns -1 =&gt; Abort FDICopy() call <br> * <br> *  fdintNEXT_CABINET: <br> *        This function is *only* called when fdintCOPY_FILE was told to copy <br> *        a file in the current cabinet that is continued to a subsequent <br> *        cabinet file.  It is important that the cabinet path name (psz3) <br> *        be validated before returning!  This function should ensure that <br> *        the cabinet exists and is readable before returning.  So, this <br> *        is the function that should, for example, issue a disk change <br> *        prompt and make sure the cabinet file exists. <br> * <br> *        When this function returns to FDI, FDI will check that the setID <br> *        and iCabinet match the expected values for the next cabinet. <br> *        If not, FDI will continue to call this function until the correct <br> *        cabinet file is specified, or until this function returns -1 to <br> *        abort the FDICopy() function.  pfdin-&gt;fdie is set to <br> *        FDIERROR_WRONG_CABINET to indicate this case. <br> * <br> *        If you *haven't* ensured that the cabinet file is present and <br> *        readable, or the cabinet file has been damaged, pfdin-&gt;fdie will <br> *        receive other appropriate error codes: <br> * <br> *              FDIERROR_CABINET_NOT_FOUND <br> *              FDIERROR_NOT_A_CABINET <br> *              FDIERROR_UNKNOWN_CABINET_VERSION <br> *              FDIERROR_CORRUPT_CABINET <br> *              FDIERROR_BAD_COMPR_TYPE <br> *              FDIERROR_RESERVE_MISMATCH <br> *              FDIERROR_WRONG_CABINET <br> * <br> *      Entry: <br> *          pfdin-&gt;psz1 = name of next cabinet where current file is continued <br> *          pfdin-&gt;psz2 = name of next disk where current file is continued <br> *          pfdin-&gt;psz3 = cabinet path name; FDI concatenates psz3 with psz1 <br> *                          to produce the fully-qualified path for the cabinet <br> *                          file.  The 256-byte buffer pointed at by psz3 may <br> *                          be modified, but psz1 may not! <br> *          pfdin-&gt;fdie = FDIERROR_WRONG_CABINET if the previous call to <br> *                        fdintNEXT_CABINET specified a cabinet file that <br> *                        did not match the setID/iCabinet that was expected. <br> *      Exit-Success: <br> *          Return anything but -1 <br> *      Exit-Failure: <br> *          Returns -1 =&gt; Abort FDICopy() call <br> *      Notes: <br> *          This call is almost always made when a target file is open and <br> *          being written to, and the next cabinet is needed to get more <br> *          data for the file. <br> */ <br>typedef enum { <br>    fdintCABINET_INFO,              // General information about cabinet <br>    fdintPARTIAL_FILE,              // First file in cabinet is continuation <br>    fdintCOPY_FILE,                 // File to be copied <br>    fdintCLOSE_FILE_INFO,           // close the file, set relevant info <br>    fdintNEXT_CABINET,              // File continued to next cabinet <br>} FDINOTIFICATIONTYPE; /* fdint */ <br> <br>typedef int (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint, <br>                                           PFDINOTIFICATION    pfdin); /* pfnfdin */ <br> <br>#define FNFDINOTIFY(fn) int FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \ <br>                                              PFDINOTIFICATION    pfdin) <br> <br> <br>/***    PFNOPEN  - File I/O callbacks for FDI <br> *      PFNREAD <br> *      PFNWRITE <br> *      PFNCLOSE <br> *      PFNSEEK <br> * <br> *  These are modeled after the C run-time routines _open, _read, <br> *  _write, _close, and _lseek.  The values for the PFNOPEN oflag <br> *  and pmode calls are those defined for _open.  FDI expects error <br> *  handling to be identical to these C run-time routines. <br> * <br> *  As long as you faithfully copy these aspects, you can supply <br> *  any functions you like! <br> * <br> * <br> *  SPECIAL NOTE FOR QUANTUM DECOMPRESSION: <br> *      When using Quantum compression, at compress time (with Diamond) <br> *      you specify how much memory Quantum requires at *decompress* time <br> *      to store the decompression history buffer.  This can be as large <br> *      as *2Mb*, and in an MS-DOS environment, for example, this much <br> *      memory may not be available (certainly not under 640K!).  To permit <br> *      large CompressionMemory settings on any machine, the Quantum <br> *      decompressor will attempt to create a "spill file" if there is not <br> *      sufficient memory available. <br> * <br> *      For PFNOPEN, a special pszFile parameter is passed to indicate that <br> *      a temporary "spill file" is requested.  The name passed is "*", and <br> *      you should cast the pszFile parameter to an FDISPILLFILE pointer, <br> *      and get the requested file size.  You then need to create a file <br> *      of the specified size with read/write access, save the file name and <br> *      handle for later use by PFNCLOSE, and then return the handle.  If <br> *      you cannot create the file of the specified size, you should return <br> *      an error (-1).  This file should be placed on a fast local hard disk, <br> *      to maximize the speed of decompression. <br> * <br> *      For PFNCLOSE, you should check the handle to see if it the spill file <br> *      created previously by PFNOPEN (FDI will create at most one spill file <br> *      per FDICreate() call).  If it is the spill file handle, you should <br> *      close the handle and then delete the file, using the file name you <br> *      saved when you created the spill file in PFNOPEN. <br> * <br> *  WARNING: You should never assume you know what file is being <br> *           opened at any one point in time!  FDI will usually <br> *           stick to opening cabinet files, but it is possible <br> *           that in a future implementation it may open temporary <br> *           files or open cabinet files in a different order. <br> * <br> *  Notes for Memory Mapped File fans: <br> *      You can write wrapper routines to allow FDI to work on memory <br> *      mapped files.  You'll have to create your own "handle" type so that <br> *      you can store the base memory address of the file and the current <br> *      seek position, and then you'll allocate and fill in one of these <br> *      structures and return a pointer to it in response to the PFNOPEN <br> *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE <br> *      functions will do memcopy(), and update the seek position in your <br> *      "handle" structure.  PFNSEEK will just change the seek position <br> *      in your "handle" structure. <br> */ <br>typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile, int oflag, int pmode); <br>typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb); <br>typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb); <br>typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf); <br>typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype); <br> <br> <br>#pragma pack (1) <br> <br>/** FDISPILLFILE - Pass as pszFile on PFNOPEN to create spill file <br> * <br> *  ach    - A two byte string to signal to PFNOPEN that a spill file is <br> *           requested.  Value is '*','\0'. <br> *  cbFile - Required spill file size, in bytes. <br> */ <br>typedef struct { <br>    char    ach[2];                 // Set to { '*', '\0' } <br>    long    cbFile;                 // Required spill file size <br>} FDISPILLFILE; /* fdisf */ <br>typedef FDISPILLFILE *PFDISPILLFILE; /* pfdisf */ <br> <br>#pragma pack () <br> <br> <br>/*** cpuType values for FDICreate() <br> * <br> *  WARNING: For 16-bit Windows applications, the CPU detection may not <br> *           correctly detect 286 CPUs.  Instead, use the following code: <br> * <br> *              DWORD   flags; <br> *              int     cpuType; <br> * <br> *              flags = GetWinFlags(); <br> *              if (flags &amp; WF_CPU286) <br> *                  cpuType = cpu80286; <br> *              else <br> *                  cpuType = cpu80386; <br> * <br> *              hfdi = FDICreate(....,cpuType,...); <br> */ <br>#define     cpuUNKNOWN         (-1)    /* FDI does detection */ <br>#define     cpu80286           (0)     /* '286 opcodes only */ <br>#define     cpu80386           (1)     /* '386 opcodes used */ <br> <br> <br>/***    FDICreate - Create an FDI context <br> * <br> *  Entry: <br> *      pfnalloc <br> *      pfnfree <br> *      pfnopen <br> *      pfnread <br> *      pfnwrite <br> *      pfnclose <br> *      pfnlseek <br> *      cpuType  - Select CPU type (auto-detect, 286, or 386+) <br> *                 WARNING: Don't use auto-detect from a 16-bit Windows <br> *                          application!  Use GetWinFlags()! <br> *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored! <br> *      perf <br> * <br> *  Exit-Success: <br> *      Returns non-NULL FDI context handle. <br> * <br> *  Exit-Failure: <br> *      Returns NULL; perf filled in with error code <br> * <br> *  Special notes for Quantum Decompression: <br> *      If you have used a high setting for CompressionMemory in creating <br> *      the cabinet file(s), then FDI will attempt to allocate a lot of <br> *      memory (as much as 2Mb, if you specified 21 for CompressionMemory). <br> *      Therefore, if you plan to allocate additional memory *after* the <br> *      FDICreate() call, you should reserve some memory *prior* to calling <br> *      FDICreate(), and then free it up afterwards (or do all your allocation <br> *      before calling FDICreate(). <br> */ <br>HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc, <br>                              PFNFREE  pfnfree, <br>                              PFNOPEN  pfnopen, <br>                              PFNREAD  pfnread, <br>                              PFNWRITE pfnwrite, <br>                              PFNCLOSE pfnclose, <br>                              PFNSEEK  pfnseek, <br>                              int      cpuType, <br>                              PERF     perf); <br> <br> <br>/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is <br> * <br> *  Entry: <br> *      hfdi   - Handle to FDI context (created by FDICreate()) <br> *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned <br> *               at offset 0 in the file to test. <br> *      pfdici - Buffer to receive info about cabinet if it is one. <br> * <br> *  Exit-Success: <br> *      Returns TRUE; file is a cabinet, pfdici filled in. <br> * <br> *  Exit-Failure: <br> *      Returns FALSE, file is not a cabinet;  If an error occurred, <br> *          perf (passed on FDICreate call!) filled in with error. <br> */ <br>BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi, <br>                                 int             hf, <br>                                 PFDICABINETINFO pfdici); <br> <br> <br>/***    FDICopy - extracts files from a cabinet <br> * <br> *  Entry: <br> *      hfdi        - handle to FDI context (created by FDICreate()) <br> *      pszCabinet  - main name of cabinet file <br> *      pszCabPath  - Path to cabinet file(s) <br> *      flags       - Flags to modify behavior <br> *      pfnfdin     - Notification function <br> *      pfnfdid     - Decryption function (pass NULL if not used) <br> *      pvUser      - User specified value to pass to notification function <br> * <br> *  Exit-Success: <br> *      Returns TRUE; <br> * <br> *  Exit-Failure: <br> *      Returns FALSE, perf (passed on FDICreate call!) filled in with <br> *          error. <br> * <br> *  Notes: <br> *  (1) If FDICopy() fails while a target file is being written out, then <br> *      FDI will use the PFNCLOSE function to close the file handle for that <br> *      target file that was returned from the fdintCOPY_FILE notification. <br> *      The client application is then free to delete the target file, since <br> *      it will not be in a valid state (since there was an error while <br> *      writing it out). <br> */ <br>BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi, <br>                            char FAR     *pszCabinet, <br>                            char FAR     *pszCabPath, <br>                            int           flags, <br>                            PFNFDINOTIFY  pfnfdin, <br>                            PFNFDIDECRYPT pfnfdid, <br>                            void FAR     *pvUser); <br> <br> <br>/***    FDIDestroy - Destroy an FDI context <br> * <br> *  Entry: <br> *      hfdi - handle to FDI context (created by FDICreate()) <br> * <br> *  Exit-Success: <br> *      Returns TRUE; <br> * <br> *  Exit-Failure: <br> *      Returns FALSE; <br> */ <br>BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi); <br> <br> <br>//** Revert to default structure packing <br>#pragma pack() <br> <br>#ifdef __cplusplus <br>} <br>#endif  /* __cplusplus */ <br> <br>#endif //!INCLUDED_FDI </code></pre>
<p>&nbsp;</p></body>
</HTML>
