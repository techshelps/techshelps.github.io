<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CABITMS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6490"></a>CABITMS.CPP</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : CabItms.cpp <br>// <br>//Implementation file for CMemFile, CCabEnum and CCabExtract <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br>#include "pch.h" <br> <br>#include "thisdll.h" <br> <br>#include "resource.h" <br> <br>#include "path.h" <br>#include "fdi.h" <br>#include "cabitms.h" <br> <br>class CMemFile <br>{ <br>public: <br>CMemFile(HGLOBAL *phMem, DWORD dwSize); <br>~CMemFile() {} <br> <br>BOOL Create(LPCSTR pszFile, int fnAttribute); <br>BOOL Open(LPCSTR pszFile, int oflag); <br>LONG Seek(LONG dist, int seektype); <br>UINT Read(LPVOID pv, UINT cb); <br>UINT Write(LPVOID pv, UINT cb); <br>HFILE Close(); <br> <br>private: <br>HFILE m_hf; <br> <br>HGLOBAL *m_phMem; <br>DWORD m_dwSize; <br>LONG m_lLoc; <br>} ; <br> <br> <br>CMemFile::CMemFile(HGLOBAL *phMem, DWORD dwSize) : m_hf(HFILE_ERROR), m_lLoc(0) <br>{ <br>m_phMem = phMem; <br>m_dwSize = dwSize; <br> <br>if (phMem) <br>{ <br>*phMem = NULL; <br>} <br>} <br> <br> <br>BOOL CMemFile::Create(LPCSTR pszFile, int fnAttribute) <br>{ <br>if (m_phMem) <br>{ <br>if (*m_phMem) <br>{ <br>return(FALSE); <br>} <br> <br>*m_phMem = GlobalAlloc(LMEM_FIXED, m_dwSize); <br>return(*m_phMem != NULL); <br>} <br>else <br>{ <br>if (m_hf != HFILE_ERROR) <br>{ <br>return(FALSE); <br>} <br> <br>m_hf = _lcreat(pszFile, fnAttribute); <br>return(m_hf != HFILE_ERROR); <br>} <br>} <br> <br> <br>BOOL CMemFile::Open(LPCSTR pszFile, int oflag) <br>{ <br>if (m_phMem) <br>{ <br>return(FALSE); <br>} <br>else <br>{ <br>if (m_hf != HFILE_ERROR) <br>{ <br>return(FALSE); <br>} <br> <br>m_hf = _lopen(pszFile, oflag); <br>return(m_hf != HFILE_ERROR); <br>} <br>} <br> <br> <br>LONG CMemFile::Seek(LONG dist, int seektype) <br>{ <br>if (m_phMem) <br>{ <br>if (!*m_phMem) <br>{ <br>return(HFILE_ERROR); <br>} <br> <br>switch (seektype) <br>{ <br>case FILE_BEGIN: <br>break; <br> <br>case FILE_CURRENT: <br>dist += m_lLoc; <br>break; <br> <br>case FILE_END: <br>dist = m_dwSize - dist; <br>break; <br> <br>default: <br>return(HFILE_ERROR); <br>} <br> <br>if (dist&lt;0 || dist&gt;(LONG)m_dwSize) <br>{ <br>return(HFILE_ERROR); <br>} <br> <br>m_lLoc = dist; <br>return(dist); <br>} <br>else <br>{ <br>return(_llseek(m_hf, dist, seektype)); <br>} <br>} <br> <br> <br>UINT CMemFile::Read(LPVOID pv, UINT cb) <br>{ <br>if (m_phMem) <br>{ <br>if (!*m_phMem) <br>{ <br>return((UINT)HFILE_ERROR); <br>} <br> <br>if (cb &gt; m_dwSize - m_lLoc) <br>{ <br>cb = m_dwSize - m_lLoc; <br>} <br> <br>hmemcpy(pv, (LPSTR)(*m_phMem)+m_lLoc, cb); <br>m_lLoc += cb; <br>return(cb); <br>} <br>else <br>{ <br>return(_lread(m_hf, pv, cb)); <br>} <br>} <br> <br> <br>UINT CMemFile::Write(LPVOID pv, UINT cb) <br>{ <br>if (m_phMem) <br>{ <br>if (!*m_phMem) <br>{ <br>return((UINT)HFILE_ERROR); <br>} <br> <br>if (cb &gt; m_dwSize - m_lLoc) <br>{ <br>cb = m_dwSize - m_lLoc; <br>} <br> <br>hmemcpy((LPSTR)(*m_phMem)+m_lLoc, pv, cb); <br>m_lLoc += cb; <br>return(cb); <br>} <br>else <br>{ <br>return(_lwrite(m_hf, (LPCSTR)pv, cb)); <br>} <br>} <br> <br> <br>HFILE CMemFile::Close() <br>{ <br>HFILE hRet; <br> <br>if (m_phMem) <br>{ <br>hRet = *m_phMem ? 0 : HFILE_ERROR; <br>} <br>else <br>{ <br>hRet = _lclose(m_hf); <br>} <br> <br>delete this; <br> <br>return(hRet); <br>} <br> <br>//***************************************************************************** <br>// <br>// CCabEnum <br>// <br>// Purpose: <br>// <br>//        Class encapsulating all the FDI operations <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br>class CCabEnum <br>{ <br>public: <br>CCabEnum() : m_hfdi(0) {} <br>~CCabEnum() {} <br> <br>protected: <br>static void HUGE * FAR DIAMONDAPI CabAlloc(ULONG cb); <br>static void FAR DIAMONDAPI CabFree(void HUGE *pv); <br>static int  FAR DIAMONDAPI CabOpen(char FAR *pszFile, int oflag, int pmode); <br>static UINT FAR DIAMONDAPI CabRead(int hf, void FAR *pv, UINT cb); <br>static UINT FAR DIAMONDAPI CabWrite(int hf, void FAR *pv, UINT cb); <br>static int  FAR DIAMONDAPI CabClose(int hf); <br>static long FAR DIAMONDAPI CabSeek(int hf, long dist, int seektype); <br> <br>BOOL StartEnum(); <br>BOOL SimpleEnum(LPCSTR szCabFile, PFNFDINOTIFY pfnCallBack, LPVOID pv); <br>void EndEnum(); <br> <br>HFDI m_hfdi; <br> <br>private: <br>static CMemFile * s_hSpill; <br>} ; <br> <br> <br>CMemFile * CCabEnum::s_hSpill = NULL; <br> <br>void HUGE * FAR DIAMONDAPI CCabEnum::CabAlloc(ULONG cb) <br>{ <br>    return(GlobalAllocPtr(GHND, cb)); <br>} <br> <br>void FAR DIAMONDAPI CCabEnum::CabFree(void HUGE *pv) <br>{ <br>    GlobalFreePtr(pv); <br>} <br> <br>int  FAR DIAMONDAPI CCabEnum::CabOpen(char FAR *pszFile, int oflag, int pmode) <br>{ <br>    if(!pszFile) <br>    { <br>      return -1; <br>    } <br> <br>    // See if we are opening the spill file. <br>    if( *pszFile=='*' ) <br>    { <br>char szSpillFile[MAX_PATH]; <br>char szTempPath[MAX_PATH]; <br> <br>        if(s_hSpill != NULL) <br>            return -1; <br> <br>GetTempPath(sizeof(szTempPath), szTempPath); <br>GetTempFileName(szTempPath, "fdi", 0, szSpillFile); <br> <br>        s_hSpill = new CMemFile(NULL, 0); <br>if (!s_hSpill) <br>{ <br>return(-1); <br>} <br>        if (!s_hSpill-&gt;Create(szSpillFile, 0)) <br>{ <br>delete s_hSpill; <br>s_hSpill = NULL; <br>return(-1); <br>} <br>            <br>        // Set its extent. <br>        if( s_hSpill-&gt;Seek( ((FDISPILLFILE FAR *)pszFile)-&gt;cbFile-1, 0) == HFILE_ERROR) <br>        { <br>s_hSpill-&gt;Close(); <br>s_hSpill = NULL; <br>return -1; <br>        } <br>        s_hSpill-&gt;Write(szSpillFile, 1); <br> <br>        return (int)s_hSpill; <br>    } <br> <br>    CMemFile *hFile = new CMemFile(NULL, 0); <br>if (!hFile) <br>{ <br>return(-1); <br>} <br> <br>    while (!hFile-&gt;Open(pszFile, oflag)) <br>    { <br>#if 1// TODO: No UI for inserting a disk at this point <br>delete hFile; <br>return(-1); <br>#else <br>       // Failed to open the source. <br>       if (!LoadString (g_hInst, IDS_DISKPROMPT, szText, MAX_STRTABLE_LEN)) <br>           return -1; <br>            <br>   char szText[MAX_PATH]; <br> <br>       wsprintf (g_pErrorBuffer, (LPSTR)szText, (LPSTR)g_pCabName); <br> <br>       // Use hwndIniting to have a parent window  <br>       if ( MyMessageBox(g_hwndIniting, g_pErrorBuffer, <br>                    MAKEINTRESOURCE(IDS_DISKPROMPT_TIT), <br>                    MB_OKCANCEL|MB_ICONSTOP, 0) == IDOK ) <br>          continue; <br>       else <br>          return -1; <br>#endif <br>    } <br>    <br>    return((int)hFile); <br>} <br> <br> <br>UINT FAR DIAMONDAPI CCabEnum::CabRead(int hf, void FAR *pv, UINT cb) <br>{ <br>CMemFile *hFile = (CMemFile *)hf; <br> <br>    if (hFile-&gt;Read(pv, cb) != cb) <br>    {     <br>        cb = (UINT)-1; <br>} <br> <br>    return(cb);     <br>} <br> <br> <br>UINT FAR DIAMONDAPI CCabEnum::CabWrite(int hf, void FAR *pv, UINT cb) <br>{ <br>CMemFile *hFile = (CMemFile *)hf; <br> <br>    if (hFile-&gt;Write(pv, cb) != cb) <br>{ <br>cb = (UINT)-1; <br>} <br>   <br>return(cb); <br>} <br> <br> <br>int  FAR DIAMONDAPI CCabEnum::CabClose(int hf) <br>{ <br>CMemFile *hFile = (CMemFile *)hf; <br> <br>    // Special case for the deletion of the spill file. <br>    if(hFile == s_hSpill) <br>{ <br>        s_hSpill = NULL; <br>} <br> <br>    return (hFile-&gt;Close()); <br>} <br> <br> <br>long FAR DIAMONDAPI CCabEnum::CabSeek(int hf, long dist, int seektype) <br>{ <br>CMemFile *hFile = (CMemFile *)hf; <br> <br>    return(hFile-&gt;Seek(dist, seektype)); <br>} <br> <br> <br>BOOL CCabEnum::StartEnum() <br>{ <br>if (m_hfdi) <br>{ <br>// We seem to already be enumerating <br>return(FALSE); <br>} <br> <br>ERF erf; <br> <br>m_hfdi = FDICreate( <br>CabAlloc, <br>        CabFree, <br>        CabOpen, <br>        CabRead, <br>        CabWrite, <br>        CabClose, <br>        CabSeek, <br>        cpu80386, <br>        &amp;erf); <br> <br>return(m_hfdi != NULL); <br>} <br> <br> <br>BOOL CCabEnum::SimpleEnum(LPCSTR szCabFile, PFNFDINOTIFY pfnCallBack, LPVOID pv) <br>{ <br>char szCabPath[MAX_PATH]; <br>char szCabName[MAX_PATH]; <br> <br>// Path should be fully qualified <br>lstrcpyn(szCabPath, szCabFile, sizeof(szCabPath)); <br>LPSTR pszName = PathFindFileName(szCabPath); <br>if (!pszName) <br>{ <br>return(FALSE); <br>} <br> <br>lstrcpy(szCabName, pszName); <br>*pszName = '\0'; <br> <br>if (!StartEnum()) <br>{ <br>return(FALSE); <br>} <br> <br>BOOL bRet = FDICopy( <br>m_hfdi, <br>szCabName, <br>szCabPath,// path to cabinet files <br>0,// flags <br>pfnCallBack, <br>NULL, <br>pv); <br> <br>EndEnum(); <br> <br>return(bRet); <br>} <br> <br> <br>void CCabEnum::EndEnum() <br>{ <br>if (!m_hfdi) <br>{ <br>return; <br>} <br> <br>FDIDestroy(m_hfdi); <br>m_hfdi = NULL; <br>} <br> <br> <br>class CCabItemsCB : private CCabEnum <br>{ <br>public: <br>CCabItemsCB(CCabItems::PFNCABITEM pfnCallBack, LPARAM lParam) <br>{ <br>m_pfnCallBack = pfnCallBack; <br>m_lParam = lParam; <br>} <br>~CCabItemsCB() {} <br> <br>BOOL DoEnum(LPCSTR szCabFile) <br>{ <br>return(SimpleEnum(szCabFile, CabItemsNotify, this)); <br>} <br> <br>private: <br>static int  FAR DIAMONDAPI CabItemsNotify(FDINOTIFICATIONTYPE fdint, <br>PFDINOTIFICATION pfdin); <br> <br>CCabItems::PFNCABITEM m_pfnCallBack; <br>LPARAM m_lParam; <br>} ; <br> <br> <br>int FAR DIAMONDAPI CCabItemsCB::CabItemsNotify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin) <br>{ <br>CCabItemsCB *pThis = (CCabItemsCB *)pfdin-&gt;pv; <br> <br>    // uiYield( g_hwndSetup ); <br>     <br>    switch (fdint) <br>    { <br>    case fdintCOPY_FILE: <br>pThis-&gt;m_pfnCallBack(pfdin-&gt;psz1, pfdin-&gt;cb, pfdin-&gt;date, pfdin-&gt;time, pfdin-&gt;attribs, <br>pThis-&gt;m_lParam); <br>break; <br> <br>default: <br>break; <br>    } // end switch <br> <br>    return 0; <br>} <br> <br>//***************************************************************************** <br>// <br>// CCabItems::EnumItems <br>// <br>// Purpose: <br>// <br>//        Enumerate the items in the cab file <br>// <br>// <br>// Comments: <br>// <br>//         lParam contains pointer to CCabFolder <br>// <br>//***************************************************************************** <br> <br>BOOL CCabItems::EnumItems(PFNCABITEM pfnCallBack, LPARAM lParam) <br>{ <br>CCabItemsCB cItems(pfnCallBack, lParam); <br> <br>return(cItems.DoEnum(m_szCabFile)); <br>} <br> <br>//***************************************************************************** <br>// <br>// CCabExtractCB <br>// <br>// Purpose: <br>// <br>//        handles the call back while extracting Cab files <br>// <br>// <br>//***************************************************************************** <br> <br>class CCabExtractCB : private CCabEnum <br>{ <br>public: <br>CCabExtractCB(LPCSTR szDir, HWND hwndOwner, CCabExtract::PFNCABEXTRACT pfnCallBack, <br>LPARAM lParam) <br>{ <br>m_szDir = szDir; <br>m_hwndOwner = hwndOwner; <br>m_pfnCallBack = pfnCallBack; <br>m_lParam = lParam; <br>m_bTryNextCab = FALSE; <br>} <br>~CCabExtractCB() {} <br> <br>BOOL DoEnum(LPCSTR szCabFile) <br>{ <br>return(SimpleEnum(szCabFile, CabExtractNotify, this)); <br>} <br> <br>private: <br>static int  FAR DIAMONDAPI CabExtractNotify(FDINOTIFICATIONTYPE fdint, <br>PFDINOTIFICATION pfdin); <br>static int CALLBACK CCabExtractCB::BrowseNotify(HWND hwnd, UINT uMsg, LPARAM lParam, <br>LPARAM lpData); <br> <br>LPCSTR m_szDir; <br>HWND m_hwndOwner; <br>CCabExtract::PFNCABEXTRACT m_pfnCallBack; <br>LPARAM m_lParam; <br>BOOL m_bTryNextCab; <br>PFDINOTIFICATION m_pfdin; <br>} ; <br> <br> <br>int CALLBACK CCabExtractCB::BrowseNotify(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData) <br>{ <br>CCabExtractCB *pThis = (CCabExtractCB *)lpData; <br> <br>switch (uMsg) <br>{ <br>case BFFM_INITIALIZED: <br>{ <br>// Set initial folder <br>LPSTR pszEnd = PathAddBackslash(pThis-&gt;m_pfdin-&gt;psz3); <br>if (pszEnd - pThis-&gt;m_pfdin-&gt;psz3 &gt; 3) <br>{ <br>// No problems if not drive root <br>*(pszEnd - 1) = '\0'; <br>} <br>SendMessage(hwnd, BFFM_SETSELECTION, 1, (LPARAM)pThis-&gt;m_pfdin-&gt;psz3); <br>break; <br>} <br> <br>default: <br>return(0); <br>} <br> <br>return(1); <br>} <br> <br> <br>int FAR DIAMONDAPI CCabExtractCB::CabExtractNotify(FDINOTIFICATIONTYPE fdint, <br>PFDINOTIFICATION pfdin) <br>{ <br>CCabExtractCB *pThis = (CCabExtractCB *)pfdin-&gt;pv; <br> <br>    // uiYield( g_hwndSetup ); <br>     <br>    switch (fdint) <br>    { <br>case fdintCABINET_INFO: <br>pThis-&gt;m_bTryNextCab = TRUE; <br>break; <br> <br>case fdintNEXT_CABINET: <br>{ <br>if (pThis-&gt;m_bTryNextCab) <br>{ <br>// Automatically open next cab if already in default dir <br>pThis-&gt;m_bTryNextCab = FALSE; <br>return(1); <br>} <br> <br>pThis-&gt;m_pfdin = pfdin; <br> <br>char szTitle[80]; <br>LoadString(g_ThisDll.GetInstance(), IDS_NEXTCABBROWSE, szTitle, sizeof(szTitle)); <br> <br>BROWSEINFO bi; <br>bi.hwndOwner = pThis-&gt;m_hwndOwner; <br>bi.pidlRoot = NULL; <br>bi.pszDisplayName = NULL; <br>bi.lpszTitle = szTitle; <br>bi.ulFlags = BIF_RETURNONLYFSDIRS; <br>bi.lpfn = BrowseNotify; <br>bi.lParam = (LPARAM)pThis; <br> <br>LPITEMIDLIST pidl = SHBrowseForFolder(&amp;bi); <br> <br>if (bi.pidlRoot) <br>{ <br>ILFree((LPITEMIDLIST)bi.pidlRoot); <br>} <br> <br>if (!pidl) <br>{ <br>return(-1); <br>} <br> <br>BOOL bSuccess = SHGetPathFromIDList(pidl, pfdin-&gt;psz3); <br>ILFree(pidl); <br> <br>if (bSuccess) <br>{ <br>PathAddBackslash(pfdin-&gt;psz3); <br>return(1); <br>} <br> <br>return(-1); <br>} <br> <br>    case fdintCOPY_FILE: <br>{ <br>HGLOBAL *phMem = pThis-&gt;m_pfnCallBack(pfdin-&gt;psz1, pfdin-&gt;cb, pfdin-&gt;date, <br>pfdin-&gt;time, pfdin-&gt;attribs, pThis-&gt;m_lParam); <br>if (!phMem) <br>{ <br>break; <br>} <br> <br>char szTemp[MAX_PATH]; <br> <br>CMemFile *hFile; <br> <br>if (pThis-&gt;m_szDir == DIR_MEM) <br>{ <br>*szTemp = '\0'; <br>hFile = new CMemFile(phMem, pfdin-&gt;cb); <br>} <br>else <br>{ <br>PathCombine(szTemp, pThis-&gt;m_szDir, pfdin-&gt;psz1); <br>hFile = new CMemFile(NULL, 0); <br>} <br> <br>if (!hFile) <br>{ <br>return(-1); <br>} <br> <br>if (hFile-&gt;Create(szTemp, OF_WRITE)) <br>{ <br>return((int)hFile); <br>} <br> <br>delete hFile; <br>return(-1); <br>} <br> <br>    case fdintCLOSE_FILE_INFO: <br>{ <br>CMemFile *hFile = (CMemFile *)pfdin-&gt;hf; <br> <br>return(hFile-&gt;Close() == 0); <br>} <br> <br>default: <br>break; <br>    } // end switch <br> <br>    return 0; <br>} <br> <br> <br>BOOL CCabExtract::ExtractItems(HWND hwndOwner, LPCSTR szDir, PFNCABEXTRACT pfnCallBack, LPARAM lParam) <br>{ <br>char szTempDir[MAX_PATH]; <br> <br>if (!szDir) <br>{ <br>szDir = szTempDir; <br> <br>char szTitle[80]; <br>LoadString(g_ThisDll.GetInstance(), IDS_EXTRACTBROWSE, szTitle, sizeof(szTitle)); <br> <br>BROWSEINFO bi; <br>bi.hwndOwner = hwndOwner; <br>bi.pidlRoot = NULL; <br>bi.pszDisplayName = NULL; <br>bi.lpszTitle = szTitle; <br>bi.ulFlags = BIF_RETURNONLYFSDIRS; <br>bi.lpfn = NULL; <br> <br>LPITEMIDLIST pidl = SHBrowseForFolder(&amp;bi); <br>if (!pidl) <br>{ <br>return(FALSE); <br>} <br> <br>BOOL bSuccess = SHGetPathFromIDList(pidl, szTempDir); <br> <br>ILFree(pidl); <br>if (!bSuccess) <br>{ <br>return(FALSE); <br>} <br>} <br> <br>CCabExtractCB cExtract(szDir, hwndOwner, pfnCallBack, lParam); <br> <br>// Display Wait cursor until done copying <br>CWaitCursor cWait; <br> <br>return(cExtract.DoEnum(m_szCabFile)); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
