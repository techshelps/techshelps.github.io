<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MENU.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6483"></a>MENU.CPP</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : Menu.cpp <br>// <br>//Implementations for CCabItemMenu methods <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br>#include "pch.h" <br> <br>#include "thisdll.h" <br> <br>#include "resource.h" <br> <br>#include "folder.h" <br>#include "menu.h" <br> <br>#include "cabitms.h" <br> <br>CCabItemMenu::CCabItemMenu(HWND hwndOwner, CCabFolder*pcf, LPCABITEM *apit, UINT cpit) <br>: m_lSel(8) <br>{ <br>m_hwndOwner = hwndOwner; <br>m_pcfHere = pcf; <br>pcf-&gt;AddRef(); <br> <br>// No need to check return value here; check in QueryInterface <br>m_lSel.AddItems(apit, cpit); <br>} <br> <br>CCabItemMenu::~CCabItemMenu() <br>{ <br>m_pcfHere-&gt;Release(); <br>} <br> <br>// *** IUnknown methods *** <br>STDMETHODIMP CCabItemMenu::QueryInterface( <br>   REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>*ppvObj = NULL; <br> <br>if (m_lSel.GetState() == CCabItemList::State_OutOfMem) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>LPUNKNOWN pObj; <br>  <br>if (riid == IID_IUnknown) <br>{ <br>pObj = (LPUNKNOWN)(IUnknown*)((IContextMenu*)this);  <br>// The (IShellFolder*) ^^^ up there is to disambiguate :) the reference <br>} <br>else if (riid == IID_IContextMenu) <br>{ <br>pObj = (LPUNKNOWN)(IContextMenu*)this; <br>} <br>else <br>{ <br>   return(E_NOINTERFACE); <br>} <br> <br>pObj-&gt;AddRef(); <br>*ppvObj = pObj; <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CCabItemMenu::AddRef(void) <br>{ <br>return(m_cRef.AddRef()); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CCabItemMenu::Release(void) <br>{ <br>if (!m_cRef.Release()) <br>{ <br>   delete this; <br>return(0); <br>} <br> <br>return(m_cRef.GetRef()); <br>} <br> <br> <br>// *** IContextMenu methods *** <br>STDMETHODIMP CCabItemMenu::QueryContextMenu( <br>                                HMENU hmenu, <br>                                UINT indexMenu, <br>                                UINT idCmdFirst, <br>                                UINT idCmdLast, <br>                                UINT uFlags) <br>{ <br>    HMENU hmMerge = LoadPopupMenu(MENU_ITEMCONTEXT, 0); <br> <br>if (!hmMerge) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>UINT idMax = Cab_MergeMenus(hmenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, <br>MM_ADDSEPARATOR); <br> <br>DestroyMenu(hmMerge); <br> <br>SetMenuDefaultItem(hmenu, IDC_ITEM_EXTRACT+idCmdFirst, FALSE); <br> <br>return(ResultFromShort(idMax - idCmdFirst)); <br>} <br> <br>STDMETHODIMP CCabItemMenu::InvokeCommand( <br>                             LPCMINVOKECOMMANDINFO lpici) <br>{ <br>if (HIWORD(lpici-&gt;lpVerb)) <br>{ <br>// Deal with string commands <br>return(E_INVALIDARG); <br>} <br> <br>switch ((UINT)LOWORD((DWORD)lpici-&gt;lpVerb)) <br>{ <br>case IDC_ITEM_EXTRACT: <br>{ <br>char szHere[MAX_PATH]; <br>if (!m_pcfHere-&gt;GetPath(szHere)) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>CCabExtract ceHere(szHere); <br> <br>ceHere.ExtractItems(m_hwndOwner, NULL, ShouldExtract, (LPARAM)this); <br> <br>break; <br>} <br> <br>default: <br>return(E_INVALIDARG); <br>} <br> <br>return(NOERROR); <br>} <br> <br>STDMETHODIMP CCabItemMenu::GetCommandString( <br>                                UINT        idCmd, <br>                                UINT        uType, <br>                                UINT      * pwReserved, <br>                                LPSTR       pszName, <br>                                UINT        cchMax) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>HGLOBAL * CALLBACK CCabItemMenu::ShouldExtract(LPCSTR pszFile, DWORD dwSize, UINT date, <br>UINT time, UINT attribs, LPARAM lParam) <br>{ <br>CCabItemMenu *pThis = (CCabItemMenu*)lParam; <br> <br>if (pThis-&gt;m_lSel.IsInList(pszFile, dwSize, date, time, attribs)) <br>{ <br>return(EXTRACT_TRUE); <br>} <br> <br>// Copy nothing for now <br>return(EXTRACT_FALSE); <br>} <br> <br> <br>HMENU CCabItemMenu::LoadPopupMenu(UINT id, UINT uSubMenu) <br>{ <br>    HMENU hmParent = LoadMenu(g_ThisDll.GetInstance(), MAKEINTRESOURCE(id)); <br>    if (!hmParent) <br>    { <br>return(NULL); <br>} <br> <br>    HMENU hmPopup = GetSubMenu(hmParent, 0); <br>    RemoveMenu(hmParent, uSubMenu, MF_BYPOSITION); <br>    DestroyMenu(hmParent); <br> <br>    return(hmPopup); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
