<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>THISDLL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6499"></a>THISDLL.CPP</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : ThisDll.cpp <br>// <br>//Generic OLE DLL routines <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br> <br>#include "pch.h" <br> <br>// ******************************************************** <br>// Initialize GUIDs <br>// <br>#pragma data_seg(".text") <br>#define INITGUID <br>#include &lt;initguid.h&gt; <br>#include &lt;cguid.h&gt; <br>#include "thisguid.h" <br>//#undef INITGUID <br>#pragma data_seg() <br> <br>#include "thisdll.h" <br> <br>#include "resource.h" <br> <br>CThisDll g_ThisDll; <br> <br>// ****************************************************************** <br>// ****************************************************************** <br>// DllMain <br>STDAPI_(BOOL) APIENTRY DllMain( <br>   HINSTANCE hDll,  <br>   DWORD dwReason,  <br>   LPVOID lpReserved) <br>{ <br>   switch(dwReason) <br>   { <br>      case DLL_PROCESS_ATTACH: <br>         g_ThisDll.SetInstance(hDll); <br> <br>         // Initialize the various modules. <br>         // <br> <br>         // <br>         // Tell system to fix up alignment faults at runtime <br>         // <br> <br>         SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT); <br> <br>         break; <br>    <br>      case DLL_PROCESS_DETACH: <br>         break; <br>      <br>      case DLL_THREAD_ATTACH: <br>         break; <br> <br>      case DLL_THREAD_DETACH: <br>         break; <br> <br>      default: <br>         break; <br>      <br>   } // switch <br> <br>   return(TRUE); <br>} <br> <br>  <br>// ****************************************************************** <br>// DllCanUnloadNow <br>STDAPI DllCanUnloadNow() <br>{ <br>HRESULT retval = (HRESULT)((g_ThisDll.m_cRef.GetRef() == 0) <br>&amp;&amp; (g_ThisDll.m_cLock.GetRef() == 0) ? S_OK : S_FALSE); <br>return(retval); <br>} <br> <br> <br>// Procedure for uninstalling this DLL (given an INF file) <br>void CALLBACK Uninstall(HWND hwndStub, HINSTANCE hInstance, LPSTR lpszCmdLine, <br>int nCmdShow) <br>{ <br>RUNDLLPROC pfnCheckAPI = Uninstall; <br> <br>static char szFmt[] = "rundll.exe setupx.dll,InstallHinfSection DefaultUninstall 132 %s"; <br> <br>if (!lpszCmdLine || lstrlen(lpszCmdLine)&gt;=MAX_PATH) <br>{ <br>return; <br>} <br>if (MessageBox(hwndStub, MAKEINTRESOURCE(IDS_SUREUNINST), <br>MAKEINTRESOURCE(IDS_THISDLL), MB_YESNO|MB_ICONSTOP) != IDYES) <br>{ <br>return; <br>} <br>    <br> <br>char szCmd[sizeof(szFmt)+MAX_PATH]; <br>wsprintf(szCmd, szFmt, lpszCmdLine); <br> <br>// Note that I use START.EXE, to minimize the chance that this DLL will still be loaded <br>// when SETUPX tries to delete it <br>ShellExecute(hwndStub, NULL, "start.exe", szCmd, NULL, SW_SHOWMINIMIZED); <br>} <br> <br> <br>// CThisDll::CThisDll()  <br> <br>// ******************************************************************** <br>class CThisDllClassFactory : public IClassFactory <br>{ <br>public: <br>// *** IUnknown methods *** <br>STDMETHODIMP QueryInterface(REFIID riid, <br>LPVOID FAR* ppvObj); <br>STDMETHODIMP_(ULONG) AddRef(void); <br>STDMETHODIMP_(ULONG) Release(void); <br>  <br>// *** IClassFactory methods *** <br>STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, <br>REFIID riid, <br>LPVOID FAR* ppvObject); <br>STDMETHODIMP LockServer(BOOL fLock); <br> <br>private: <br>CRefDll m_cRefDll; <br> <br>CRefCount m_cRef; <br>}; <br> <br>// ****************************************************************** <br>// ****************************************************************** <br>// DllGetClassObject <br>STDAPI DllGetClassObject( <br>   REFCLSID rclsid,  <br>   REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>*ppvObj = NULL; <br> <br>if(! (rclsid == CLSID_ThisDll)) <br>{ <br>return(E_FAIL); <br>} <br> <br>CThisDllClassFactory *pcf = new CThisDllClassFactory; <br>if (!pcf) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>// Note if the QueryInterface fails, the Release will delete the object <br>pcf-&gt;AddRef(); <br>HRESULT hRes = pcf-&gt;QueryInterface(riid, ppvObj); <br>pcf-&gt;Release();  <br>  <br>return(hRes); <br>} <br> <br> <br>// *********************************************************************** <br>// *********************************************************************** <br>// CImpIClassFactory member functions <br> <br>// *** IUnknown methods *** <br>STDMETHODIMP CThisDllClassFactory::QueryInterface(REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>*ppvObj = NULL; <br>  <br>// Any interface on this object is the object pointer <br>if((riid == IID_IUnknown) || (riid == IID_IClassFactory)) <br>{ <br>*ppvObj = (LPVOID)(IClassFactory *)this; <br>} <br> <br>if(*ppvObj) <br>{ <br>((LPUNKNOWN)*ppvObj)-&gt;AddRef(); <br>return NOERROR; <br>} <br> <br>return(E_NOINTERFACE); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CThisDllClassFactory::AddRef(void) <br>{ <br>return(m_cRef.AddRef()); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CThisDllClassFactory::Release(void) <br>{ <br>if (!m_cRef.Release()) <br>{ <br>   delete this; <br>return(0); <br>} <br> <br>return(m_cRef.GetRef()); <br>} <br>  <br> <br>// *** IClassFactory methods *** <br>STDMETHODIMP CThisDllClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, <br>        REFIID riid, <br>        LPVOID FAR* ppvObj) <br>{ <br>// we do not support aggregation <br>if(pUnkOuter) <br>{ <br>return(CLASS_E_NOAGGREGATION); <br>} <br> <br>return(::CreateInstance(riid, ppvObj)); <br>} <br> <br> <br>STDMETHODIMP CThisDllClassFactory::LockServer(BOOL fLock) <br>{ <br>if(fLock) <br>{ <br>g_ThisDll.m_cLock.AddRef(); <br>} <br>else <br>{ <br>g_ThisDll.m_cLock.Release(); <br>} <br> <br>return(NOERROR); <br>} <br> <br> <br>void *  __cdecl operator new(unsigned int nSize) <br>{ <br>return((LPVOID)LocalAlloc(LMEM_FIXED, nSize)); <br>} <br> <br> <br>void  __cdecl operator delete(void *pv) <br>{ <br>LocalFree((HLOCAL)pv); <br>} <br> <br> <br>extern "C" int __cdecl _purecall() <br>{ <br>return(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
