<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STRINGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6497"></a>STRINGS.C</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : strings.c <br>// <br>//DBCS aware string routines... <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br>#include "pch.h" <br>#include "strings.h" <br> <br>#ifdef UNICODE <br>#define _StrEndN    _StrEndNW <br>#define ChrCmp      ChrCmpW <br>#define ChrCmpI     ChrCmpIW <br>#else <br>#define _StrEndN    _StrEndNA <br>#define ChrCmp      ChrCmpA <br>#define ChrCmpI     ChrCmpIA <br>#endif <br> <br> <br>/* <br> * StrEndN - Find the end of a string, but no more than n bytes <br> * Assumes   pStart points to start of null terminated string <br> *           nBufSize is the maximum length <br> * returns ptr to just after the last byte to be included <br> */ <br>LPSTR _StrEndNA(LPCSTR pStart, int nBufSize) <br>{ <br>  LPCSTR pEnd; <br> <br>  for (pEnd = pStart + nBufSize; *pStart &amp;&amp; pStart &lt; pEnd; pStart = AnsiNext(pStart)) <br>    continue;   /* just getting to the end of the string */ <br>  if (pStart &gt; pEnd) <br>    { <br>      /* We can only get here if the last byte before pEnd was a lead byte <br>       */ <br>      pStart -= 2; <br>    } <br>  return (LPSTR)pStart; <br>} <br> <br>LPWSTR _StrEndNW(LPCWSTR pStart, int nBufSize) <br>{ <br>#ifdef UNICODE <br>  LPCWSTR pEnd; <br> <br>  for (pEnd = pStart + nBufSize; *pStart &amp;&amp; (pStart &lt; pEnd); <br>pStart++) <br>    continue;   /* just getting to the end of the string */ <br> <br>  return((LPWSTR)pStart); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} <br> <br> <br>/* <br> * ChrCmp -  Case sensitive character comparison for DBCS <br> * Assumes   w1, wMatch are characters to be compared <br> * Return    FALSE if they match, TRUE if no match <br> */ <br>BOOL ChrCmpA(WORD w1, WORD wMatch) <br>{ <br>  /* Most of the time this won't match, so test it first for speed. <br>   */ <br>  if (LOBYTE(w1) == LOBYTE(wMatch)) <br>    { <br>      if (IsDBCSLeadByte(LOBYTE(w1))) <br>{ <br>  return(w1 != wMatch); <br>} <br>      return FALSE; <br>    } <br>  return TRUE; <br>} <br> <br>BOOL ChrCmpW(WORD w1, WORD wMatch) <br>{ <br>#ifdef UNICODE <br>   return(!(w1 == wMatch)); <br>#else <br>    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>    return FALSE; <br>#endif <br>} <br> <br> <br> <br>/* <br> * ChrCmpI - Case insensitive character comparison for DBCS <br> * Assumes   w1, wMatch are characters to be compared; <br> *           HIBYTE of wMatch is 0 if not a DBC <br> * Return    FALSE if match, TRUE if not <br> */ <br>BOOL ChrCmpIA(WORD w1, WORD wMatch) <br>{ <br>  char sz1[3], sz2[3]; <br> <br>  if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1))) <br>    { <br>      sz1[1] = HIBYTE(w1); <br>      sz1[2] = '\0'; <br>    } <br>  else <br>      sz1[1] = '\0'; <br> <br>  *(WORD *)sz2 = wMatch; <br>  sz2[2] = '\0'; <br>  return lstrcmpiA(sz1, sz2); <br>} <br> <br> <br>BOOL ChrCmpIW(WORD w1, WORD wMatch) <br>{ <br>#ifdef UNICODE <br>  TCHAR sz1[2], sz2[2]; <br> <br>  sz1[0] = w1; <br>  sz1[1] = TEXT('\0'); <br>  sz2[0] = wMatch; <br>  sz2[1] = TEXT('\0'); <br> <br>  return lstrcmpiW(sz1, sz2); <br> <br>#else <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return FALSE; <br> <br>#endif <br>} <br> <br> <br> <br>/* <br> * StrChr - Find first occurrence of character in string <br> * Assumes   pStart points to start of null terminated string <br> *           wMatch  is the character to match <br> * returns ptr to the first occurrence of ch in str, NULL if not found. <br> */ <br>LPSTR StrChrA(LPCSTR pStart, WORD wMatch) <br>{ <br>  for ( ; *pStart; pStart = AnsiNext(pStart)) <br>    { <br>      if (!ChrCmpA(*(UNALIGNED WORD *)pStart, wMatch)) <br>      { <br>  return((LPSTR)pStart); <br>      } <br>   } <br>   return (NULL); <br>} <br> <br>LPWSTR StrChrW(LPCWSTR pStart, WORD wMatch) <br>{ <br>#ifdef UNICODE <br> <br>  for ( ; *pStart; pStart = AnsiNext(pStart)) <br>  { <br>      // Need a tmp word since casting ptr to WORD * will <br>      // fault on MIPS, ALPHA <br> <br>      WORD wTmp; <br>      memcpy(&amp;wTmp, pStart, sizeof(WORD)); <br> <br>      if (!ChrCmpW(wTmp, wMatch)) <br>      { <br>  return((LPWSTR)pStart); <br>      } <br>  } <br>  return (NULL); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} <br> <br>/* <br> * StrRChr - Find last occurrence of character in string <br> * Assumes   pStart points to start of string <br> *           pEnd   points to end of string (NOT included in search) <br> *           wMatch  is the character to match <br> * returns ptr to the last occurrence of ch in str, NULL if not found. <br> */ <br>LPSTR StrRChrA(LPCSTR pStart, LPCSTR pEnd, WORD wMatch) <br>{ <br>  LPCSTR lpFound = NULL; <br> <br>  if (!pEnd) <br>      pEnd = pStart + lstrlenA(pStart); <br> <br>  for ( ; pStart &lt; pEnd; pStart = AnsiNext(pStart)) <br>    { <br>      if (!ChrCmpA(*(UNALIGNED WORD *)pStart, wMatch)) <br>  lpFound = pStart; <br>    } <br>  return ((LPSTR)lpFound); <br>} <br> <br>LPWSTR StrRChrW(LPCWSTR pStart, LPCWSTR pEnd, WORD wMatch) <br>{ <br>#ifdef UNICODE <br> <br>  LPCWSTR lpFound = NULL; <br> <br>  if (!pEnd) <br>      pEnd = pStart + lstrlenW(pStart); <br> <br>  for ( ; pStart &lt; pEnd; pStart++) <br>    { <br>      if (!ChrCmpW(*(UNALIGNED WORD *)pStart, wMatch)) <br>  lpFound = pStart; <br>    } <br>  return ((LPWSTR)lpFound); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} <br> <br>/* <br> * StrChrI - Find first occurrence of character in string, case insensitive <br> * Assumes   pStart points to start of null terminated string <br> *           wMatch  is the character to match <br> * returns ptr to the first occurrence of ch in str, NULL if not found. <br> */ <br>LPSTR StrChrIA(LPCSTR pStart, WORD wMatch) <br>{ <br>  wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch)); <br> <br>  for ( ; *pStart; pStart = AnsiNext(pStart)) <br>    { <br>      if (!ChrCmpIA(*(UNALIGNED WORD *)pStart, wMatch)) <br>  return((LPSTR)pStart); <br>    } <br>  return (NULL); <br>} <br> <br>LPWSTR StrChrIW(LPCWSTR pStart, WORD wMatch) <br>{ <br>#ifdef UNICODE <br> <br>  for ( ; *pStart; pStart++) <br>    { <br>      if (!ChrCmpIW(*(WORD *)pStart, wMatch)) <br>  return((LPWSTR)pStart); <br>    } <br>  return (NULL); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} <br> <br>/* <br> * StrRChrI - Find last occurrence of character in string, case insensitive <br> * Assumes   pStart points to start of string <br> *           pEnd   points to end of string (NOT included in search) <br> *           wMatch  is the character to match <br> * returns ptr to the last occurrence of ch in str, NULL if not found. <br> */ <br>LPSTR StrRChrIA(LPCSTR pStart, LPCSTR pEnd, WORD wMatch) <br>{ <br>  LPCSTR lpFound = NULL; <br> <br>  if (!pEnd) <br>      pEnd = pStart + lstrlenA(pStart); <br> <br>  wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch)); <br> <br>  for ( ; pStart &lt; pEnd; pStart = AnsiNext(pStart)) <br>    { <br>      if (!ChrCmpIA(*(UNALIGNED WORD *)pStart, wMatch)) <br>  lpFound = pStart; <br>    } <br>  return ((LPSTR)lpFound); <br>} <br> <br>LPWSTR StrRChrIW(LPCWSTR pStart, LPCWSTR pEnd, WORD wMatch) <br>{ <br>#ifdef UNICODE <br> <br>  LPCWSTR lpFound = NULL; <br> <br>  if (!pEnd) <br>      pEnd = pStart + lstrlenW(pStart); <br> <br>  for ( ; pStart &lt; pEnd; pStart++) <br>    { <br>      if (!ChrCmpIW(*(WORD *)pStart, wMatch)) <br>  lpFound = pStart; <br>    } <br>  return ((LPWSTR)lpFound); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} <br> <br> <br>// StrCSpn: return index to first char of lpStr that is present in lpSet. <br>// Includes the NUL in the comparison; if no lpSet chars are found, returns <br>// the index to the NUL in lpStr. <br>// Just like CRT strcspn. <br>// <br>int StrCSpnA(LPCSTR lpStr, LPCSTR lpSet) <br>{ <br>// nature of the beast: O(lpStr*lpSet) work <br>LPCSTR lp = lpStr; <br>if (!lpStr || !lpSet) <br>return 0; <br> <br>while (*lp) <br>{ <br> if (StrChrA(lpSet, *(UNALIGNED WORD *)lp)) <br>return (int)(lp-lpStr); <br>lp = AnsiNext(lp); <br>} <br> <br>return (int)(lp-lpStr); // ==lstrlen(lpStr) <br>} <br> <br>int StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet) <br>{ <br>#ifdef UNICODE <br> <br>// nature of the beast: O(lpStr*lpSet) work <br>LPCWSTR lp = lpStr; <br>if (!lpStr || !lpSet) <br>return 0; <br> <br>while (*lp) <br>{ <br>if (StrChrW(lpSet, *(WORD *)lp)) <br>return (int)(lp-lpStr); <br>lp++; <br>} <br> <br>return (int)(lp-lpStr); // ==lstrlen(lpStr) <br> <br>#else <br> <br>        SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>return -1; <br> <br>#endif <br>} <br> <br>// StrCSpnI: case-insensitive version of StrCSpn. <br>// <br>int StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet) <br>{ <br>// nature of the beast: O(lpStr*lpSet) work <br>LPCSTR lp = lpStr; <br>if (!lpStr || !lpSet) <br>return 0; <br> <br>while (*lp) <br>{ <br>if (StrChrIA(lpSet, *(UNALIGNED WORD *)lp)) <br>return (int)(lp-lpStr); <br>lp = AnsiNext(lp); <br>} <br> <br>return (int)(lp-lpStr); // ==lstrlen(lpStr) <br>} <br> <br>int StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet) <br>{ <br>#ifdef UNICODE <br>// nature of the beast: O(lpStr*lpSet) work <br>LPCWSTR lp = lpStr; <br>if (!lpStr || !lpSet) <br>return 0; <br> <br>while (*lp) <br>{ <br>if (StrChrIW(lpSet, *(WORD *)lp)) <br>return (int)(lp-lpStr); <br>lp++; <br>} <br> <br>return (int)(lp-lpStr); // ==lstrlen(lpStr) <br> <br>#else <br> <br>        SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>return -1; <br> <br>#endif <br>} <br> <br> <br>/* <br> * StrCmpN      - Compare n bytes <br> * <br> * returns   See lstrcmp return values. <br> * won't work if source strings are in ROM <br> */ <br>int StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar) <br>{ <br>    char sz1[4]; <br>    char sz2[4]; <br>    int i; <br>    LPCSTR lpszEnd = lpStr1 + nChar; <br> <br>    //DebugMsg(DM_TRACE, "StrCmpN: %s %s %d returns:", lpStr1, lpStr2, nChar); <br> <br>    for ( ; (lpszEnd &gt; lpStr1) &amp;&amp; (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) { <br>        WORD wMatch; <br> <br>        if (IsDBCSLeadByte(*lpStr2)) <br>            lpStr2++; <br> <br>        wMatch = (WORD) *lpStr2; <br> <br>        i = ChrCmpA(*(UNALIGNED WORD *)lpStr1, wMatch); <br>        if (i) { <br>            int iRet; <br> <br>            (*(WORD *)sz1) = *(UNALIGNED WORD *)lpStr1; <br>            (*(WORD *)sz2) = *(UNALIGNED WORD *)lpStr2; <br>            *AnsiNext(sz1) = 0; <br>            *AnsiNext(sz2) = 0; <br>            iRet = lstrcmpA(sz1, sz2); <br>            //DebugMsg(DM_TRACE, ".................... %d", iRet); <br>            return iRet; <br>        } <br>    } <br> <br>    //DebugMsg(DM_TRACE, ".................... 0"); <br>    return 0; <br>} <br> <br>int StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar) <br>{ <br>#ifdef UNICODE <br> <br>    WCHAR sz1[2]; <br>    WCHAR sz2[2]; <br>    int i; <br>    LPCWSTR lpszEnd = lpStr1 + nChar; <br> <br>    //DebugMsg(DM_TRACE, "StrCmpN: %s %s %d returns:", lpStr1, lpStr2, nChar); <br> <br>    for ( ; (lpszEnd &gt; lpStr1) &amp;&amp; (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) { <br>        i = ChrCmpW(*lpStr1, *lpStr2); <br>        if (i) { <br>            int iRet; <br> <br>            sz1[0] = *lpStr1; <br>            sz2[0] = *lpStr2; <br>            sz1[1] = TEXT('\0'); <br>            sz2[1] = TEXT('\0'); <br>            iRet = lstrcmpW(sz1, sz2); <br>            //DebugMsg(DM_TRACE, ".................... %d", iRet); <br>            return iRet; <br>        } <br>    } <br> <br>    //DebugMsg(DM_TRACE, ".................... 0"); <br>    return 0; <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return -1; <br> <br>#endif <br>} <br> <br>/* <br> * StrCmpNI     - Compare n bytes, case insensitive <br> * <br> * returns   See lstrcmpi return values. <br> */ <br>int StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar) <br>{ <br>    int i; <br>    LPCSTR lpszEnd = lpStr1 + nChar; <br> <br>    //DebugMsg(DM_TRACE, "StrCmpNI: %s %s %d returns:", lpStr1, lpStr2, nChar); <br> <br>    for ( ; (lpszEnd &gt; lpStr1) &amp;&amp; (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) { <br>        WORD wMatch; <br> <br>        wMatch = (UINT)(IsDBCSLeadByte(*lpStr2)) ? *(WORD *)lpStr2 : (WORD)(BYTE)(*lpStr2); <br> <br>        i = ChrCmpIA(*(UNALIGNED WORD *)lpStr1, wMatch); <br>        if (i) { <br>            //DebugMsg(DM_TRACE, ".................... %d", i); <br>            return i; <br>        } <br>    } <br>    //DebugMsg(DM_TRACE, ".................... 0"); <br>    return 0; <br>} <br> <br>int StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar) <br>{ <br>#ifdef UNICODE <br> <br>    int i; <br>    LPCWSTR lpszEnd = lpStr1 + nChar; <br> <br>    //DebugMsg(DM_TRACE, "StrCmpNI: %s %s %d returns:", lpStr1, lpStr2, nChar); <br> <br>    for ( ; (lpszEnd &gt; lpStr1) &amp;&amp; (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) { <br>        i = ChrCmpIW(*lpStr1, *lpStr2); <br>        if (i) { <br>            //DebugMsg(DM_TRACE, ".................... %d", i); <br>            return i; <br>        } <br>    } <br>    //DebugMsg(DM_TRACE, ".................... 0"); <br>    return 0; <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return -1; <br> <br>#endif <br>} <br> <br> <br>/* <br> * StrRStrI      - Search for last occurrence of a substring <br> * <br> * Assumes   lpSource points to the null terminated source string <br> *           lpLast points to where to search from in the source string <br> *           lpLast is not included in the search <br> *           lpSrch points to string to search for <br> * returns   last occurrence of string if successful; NULL otherwise <br> */ <br>LPSTR StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch) <br>{ <br>    LPCSTR lpFound = NULL; <br>    LPSTR pEnd; <br>    char cHold; <br> <br>    if (!lpLast) <br>lpLast = lpSource + lstrlenA(lpSource); <br> <br>    if (lpSource &gt;= lpLast || *lpSrch == 0) <br>return NULL; <br> <br>    pEnd = _StrEndNA(lpLast, (UINT)(lstrlenA(lpSrch)-1)); <br>    cHold = *pEnd; <br>    *pEnd = 0; <br> <br>    while ((lpSource = StrStrIA(lpSource, lpSrch)) != 0 &amp;&amp; lpSource &lt; lpLast) <br>    { <br>lpFound = lpSource; <br>lpSource = AnsiNext(lpSource); <br>    } <br>    *pEnd = cHold; <br>    return((LPSTR)lpFound); <br>} <br> <br>LPWSTR StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch) <br>{ <br>#ifdef UNICODE <br>    LPCWSTR lpFound = NULL; <br>    LPWSTR pEnd; <br>    WCHAR cHold; <br> <br>    if (!lpLast) <br>lpLast = lpSource + lstrlenW(lpSource); <br> <br>    if (lpSource &gt;= lpLast || *lpSrch == 0) <br>return NULL; <br> <br>    pEnd = _StrEndNW(lpLast, (UINT)(lstrlenW(lpSrch)-1)); <br>    cHold = *pEnd; <br>    *pEnd = 0; <br> <br>    while ((lpSource = StrStrIW(lpSource, lpSrch))!=0 &amp;&amp; <br>  lpSource &lt; lpLast) <br>    { <br>lpFound = lpSource; <br>lpSource++; <br>    } <br>    *pEnd = cHold; <br>    return((LPWSTR)lpFound); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} <br> <br>/* <br> * StrStr      - Search for first occurrence of a substring <br> * <br> * Assumes   lpSource points to source string <br> *           lpSrch points to string to search for <br> * returns   first occurrence of string if successful; NULL otherwise <br> */ <br>LPSTR StrStrA(LPCSTR lpFirst, LPCSTR lpSrch) <br>{ <br>  UINT uLen; <br>  WORD wMatch; <br> <br>  uLen = (UINT)lstrlenA(lpSrch); <br>  wMatch = *(UNALIGNED WORD *)lpSrch; <br> <br>  for ( ; (lpFirst=StrChrA(lpFirst, wMatch))!=0 &amp;&amp; StrCmpNA(lpFirst, lpSrch, uLen); <br>lpFirst=AnsiNext(lpFirst)) <br>    continue; /* continue until we hit the end of the string or get a match */ <br> <br>  return((LPSTR)lpFirst); <br>} <br> <br>LPWSTR StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch) <br>{ <br>#ifdef UNICODE <br> <br>  UINT uLen; <br>  WORD wMatch; <br> <br>  uLen = (UINT)lstrlenW(lpSrch); <br>  wMatch = *(WORD *)lpSrch; <br> <br>  for ( ; (lpFirst=StrChrW(lpFirst, wMatch))!=0 &amp;&amp; StrCmpNW(lpFirst, lpSrch, uLen); <br>lpFirst++) <br>    continue; /* continue until we hit the end of the string or get a match */ <br> <br>  return((LPWSTR)lpFirst); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} <br> <br>/* <br> * StrStrI   - Search for first occurrence of a substring, case insensitive <br> * <br> * Assumes   lpFirst points to source string <br> *           lpSrch points to string to search for <br> * returns   first occurrence of string if successful; NULL otherwise <br> */ <br>LPSTR StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch) <br>{ <br>  UINT uLen; <br>  WORD wMatch; <br> <br>  uLen = (UINT)lstrlenA(lpSrch); <br>  wMatch = *(UNALIGNED WORD *)lpSrch; <br> <br>  for ( ; (lpFirst = StrChrIA(lpFirst, wMatch)) != 0 &amp;&amp; StrCmpNIA(lpFirst, lpSrch, uLen); <br>lpFirst=AnsiNext(lpFirst)) <br>      continue; /* continue until we hit the end of the string or get a match */ <br> <br>  return((LPSTR)lpFirst); <br>} <br> <br>LPWSTR StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch) <br>{ <br>#ifdef UNICODE <br> <br>  UINT uLen; <br>  WORD wMatch; <br> <br>  uLen = (UINT)lstrlenW(lpSrch); <br>  wMatch = *(WORD *)lpSrch; <br> <br>  for ( ; (lpFirst = StrChrIW(lpFirst, wMatch)) != 0 &amp;&amp; StrCmpNIW(lpFirst, lpSrch, uLen); <br>lpFirst++) <br>      continue; /* continue until we hit the end of the string or get a match */ <br> <br>  return((LPWSTR)lpFirst); <br> <br>#else <br> <br>  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING); <br>  return NULL; <br> <br>#endif <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
