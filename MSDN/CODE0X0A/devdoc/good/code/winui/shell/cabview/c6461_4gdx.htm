<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SFVWND.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6495"></a>SFVWND.CPP</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : SFVWnd.cpp <br>// <br>//Implementation file for CSFVDropSource and CSFViewDlg <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br>#include "Pch.H" <br> <br>#include "SFVWnd.H" <br> <br>#include "ThisDll.h" <br> <br>#include "Resource.H" <br> <br>class CSFVDropSource : public CUnknown, public IDropSource <br>{ <br>public: <br>CSFVDropSource() : m_grfInitialKeyState(0) {} <br>virtual ~CSFVDropSource(); <br> <br>STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj); <br>STDMETHODIMP_(ULONG) AddRef(); <br>STDMETHODIMP_(ULONG) Release(); <br> <br>STDMETHODIMP QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState); <br>STDMETHODIMP GiveFeedback(DWORD dwEffect); <br> <br>private: <br>DWORD m_grfInitialKeyState; <br>} ; <br> <br> <br>CSFVDropSource::~CSFVDropSource() <br>{ <br>} <br> <br>STDMETHODIMP CSFVDropSource::QueryInterface(REFIID riid, LPVOID * ppvObj) <br>{ <br>static const IID *apiid[] = { &amp;IID_IDropSource, NULL }; <br>LPUNKNOWN aobj[] = { (IDropSource *)this }; <br> <br>return(QIHelper(riid, ppvObj, apiid, aobj)); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CSFVDropSource::AddRef() <br>{ <br>return(AddRefHelper()); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CSFVDropSource::Release() <br>{ <br>return(ReleaseHelper()); <br>} <br> <br> <br>STDMETHODIMP CSFVDropSource::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState) <br>{ <br>if (fEscapePressed) <br>{ <br>return(DRAGDROP_S_CANCEL); <br>} <br> <br>// initialize ourself with the drag begin button <br>if (m_grfInitialKeyState == 0) <br>{ <br>m_grfInitialKeyState = (grfKeyState &amp; (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)); <br>} <br> <br>if (!(grfKeyState &amp; m_grfInitialKeyState)) <br>{ <br>return(DRAGDROP_S_DROP); <br>} <br> <br>return(S_OK); <br>} <br> <br> <br>STDMETHODIMP CSFVDropSource::GiveFeedback(DWORD dwEffect) <br>{ <br>return(DRAGDROP_S_USEDEFAULTCURSORS); <br>} <br> <br> <br>// Note that the OLESTR gets freed, so don't try to use it later <br>BOOL StrRetToStr(LPSTR szOut, UINT uszOut, LPSTRRET pStrRet, LPCITEMIDLIST pidl) <br>{ <br>    switch (pStrRet-&gt;uType) <br>    { <br>    case STRRET_OLESTR: <br>    { <br>        CSafeMalloc sm; <br> <br>    OleStrToStrN(szOut, uszOut, pStrRet-&gt;pOleStr, -1); <br>sm.Free(pStrRet-&gt;pOleStr); <br> <br>    break; <br>    } <br> <br>    case STRRET_CSTR: <br>    lstrcpyn(szOut, pStrRet-&gt;cStr, uszOut); <br>    break; <br> <br>    case STRRET_OFFSET: <br>    if (pidl) <br>    { <br>        lstrcpyn(szOut, ((LPCSTR)&amp;pidl-&gt;mkid)+pStrRet-&gt;uOffset, uszOut); <br>        break; <br>    } <br> <br>    // Fall through <br>    default: <br>    if (uszOut) <br>    { <br>        *szOut = '\0'; <br>    } <br>    return(FALSE); <br>    } <br> <br>    return(TRUE); <br>} <br> <br> <br>static void _PrettyMenu(HMENU hm) <br>{ <br>BOOL bSeparated = TRUE; <br>int i; <br> <br>for (i=GetMenuItemCount(hm)-1; i&gt;0; --i) <br>{ <br>if (CSFViewDlg::IsMenuSeparator(hm, i)) <br>{ <br>if (bSeparated) <br>{ <br>DeleteMenu(hm, i, MF_BYPOSITION); <br>} <br> <br>bSeparated = TRUE; <br>} <br>else <br>{ <br>bSeparated = FALSE; <br>} <br>} <br> <br>// The above loop does not handle the case of many separators at <br>// the beginning of the menu <br>while (CSFViewDlg::IsMenuSeparator(hm, 0)) <br>{ <br>DeleteMenu(hm, 0, MF_BYPOSITION); <br>} <br>} <br> <br> <br>static HMENU _LoadPopupMenu(UINT id, UINT uSubMenu) <br>{ <br>    HMENU hmParent = LoadMenu(g_ThisDll.GetInstance(), MAKEINTRESOURCE(id)); <br>    if (!hmParent) <br>    { <br>return(NULL); <br>} <br> <br>    HMENU hmPopup = GetSubMenu(hmParent, 0); <br>    RemoveMenu(hmParent, uSubMenu, MF_BYPOSITION); <br>    DestroyMenu(hmParent); <br> <br>    return(hmPopup); <br>} <br> <br> <br>void CSFViewDlg::InitDialog() <br>{ <br>m_cList.Init(GetDlgItem(m_hDlg, IDC_LISTVIEW), GetDlgItem(m_hDlg, IDC_LISTBOX), <br>IDI_GENERIC); <br> <br>SetWindowLong(m_cList, GWL_EXSTYLE, <br>GetWindowLong(m_cList, GWL_EXSTYLE) | WS_EX_CLIENTEDGE); <br> <br>m_hrOLE = OleInitialize(NULL); <br>} <br> <br> <br>LRESULT CSFViewDlg::BeginDrag() <br>{ <br>if (!OleInited()) <br>{ <br>return(0); <br>} <br> <br>// Get the dwEffect from the selection. <br>ULONG dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY; <br>GetAttributesFromItem(&amp;dwEffect, SVGIO_SELECTION); <br> <br>// Just in case <br>dwEffect &amp;= DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY; <br>if (!dwEffect) <br>{ <br>return(0); <br>} <br> <br>LPDATAOBJECT pdtobj; <br>if (FAILED(GetUIObjectFromItem(IID_IDataObject, (LPVOID*)&amp;pdtobj, SVGIO_SELECTION))) <br>{ <br>return(0); <br>} <br>CEnsureRelease erData(pdtobj); <br> <br>CSFVDropSource *pcsrc = new CSFVDropSource; <br>if (!pcsrc) <br>{ <br>return(0); <br>} <br>pcsrc-&gt;AddRef(); <br>CEnsureRelease erCDSrc((IDropSource*)pcsrc); <br> <br>IDropSource *pdsrc; <br>HRESULT hres = pcsrc-&gt;QueryInterface(IID_IDropSource, (LPVOID*)&amp;pdsrc); <br>if (FAILED(hres)) <br>{ <br>return(0); <br>} <br>CEnsureRelease erPDSrc(pdsrc); <br> <br>DoDragDrop(pdtobj, pdsrc, dwEffect, &amp;dwEffect); <br> <br>return(0); <br>} <br> <br> <br>BOOL CSFViewDlg::Notify(LPNMHDR pNotify) <br>{ <br>LPNM_LISTVIEW pNotifyLV = (LPNM_LISTVIEW)pNotify; <br>LV_DISPINFO *pNotifyDI = (LV_DISPINFO *)pNotify; <br>LPTBNOTIFY pNotifyTB = (LPTBNOTIFY)pNotify; <br>LPTOOLTIPTEXT pNotifyTT = (LPTOOLTIPTEXT)pNotify; <br> <br>switch(pNotify-&gt;code) <br>{ <br>case TTN_NEEDTEXT: <br>m_psfv-&gt;GetCommandHelpText(pNotifyTT-&gt;hdr.idFrom, pNotifyTT-&gt;szText, <br>sizeof(pNotifyTT-&gt;szText), TRUE); <br>break; <br> <br>case TBN_BEGINDRAG: <br>m_psfv-&gt;OnMenuSelect(pNotifyTB-&gt;iItem, 0, 0); <br>break; <br> <br>case LVN_DELETEITEM: <br>m_psfv-&gt;m_cMalloc.Free((LPITEMIDLIST)pNotifyLV-&gt;lParam); <br>break; <br> <br>case LVN_GETDISPINFO: <br>if (pNotifyDI-&gt;item.iSubItem == 0) <br>{ <br>LPCITEMIDLIST pidl = (LPCITEMIDLIST)pNotifyDI-&gt;item.lParam; <br>if (pNotifyDI-&gt;item.mask &amp; LVIF_TEXT) <br>{ <br>STRRET strret; <br> <br>if (FAILED(m_psfv-&gt;m_psf-&gt;GetDisplayNameOf(pidl, 0, &amp;strret))) <br>{ <br>lstrcpyn(pNotifyDI-&gt;item.pszText, "", pNotifyDI-&gt;item.cchTextMax); <br>} <br>else <br>{ <br>StrRetToStr(pNotifyDI-&gt;item.pszText, pNotifyDI-&gt;item.cchTextMax, <br>&amp;strret, pidl); <br>} <br>} <br> <br>if (pNotifyDI-&gt;item.mask &amp; LVIF_IMAGE) <br>{ <br>// Get the image <br>pNotifyDI-&gt;item.iImage = m_cList.GetIcon(m_psfv-&gt;m_psf, pidl); <br>} <br> <br>pNotifyDI-&gt;item.mask |= LVIF_DI_SETITEM; <br>} <br>else if (pNotifyDI-&gt;item.mask &amp; LVIF_TEXT) <br>{ <br>SFVCB_GETDETAILSOF_DATA gdo; <br>gdo.pidl = (LPCITEMIDLIST)pNotifyDI-&gt;item.lParam; <br> <br>if (m_psfv-&gt;CallCB(SFVCB_GETDETAILSOF, pNotifyDI-&gt;item.iSubItem, (LPARAM)&amp;gdo) <br>== S_OK) <br>{ <br>StrRetToStr(pNotifyDI-&gt;item.pszText, pNotifyDI-&gt;item.cchTextMax, <br>&amp;gdo.str, gdo.pidl); <br>} <br>} <br>break; <br> <br>case LVN_COLUMNCLICK: <br>m_psfv-&gt;ColumnClick(pNotifyLV-&gt;iSubItem); <br>break; <br> <br>case LVN_ITEMCHANGED: <br>// We only care about STATECHANGE messages <br>if (!(pNotifyLV-&gt;uChanged &amp; LVIF_STATE)) <br>{ <br>// If the text is changed, we need to flush the cached <br>// context menu. <br>if (pNotifyLV-&gt;uChanged &amp; LVIF_TEXT) <br>{ <br>m_psfv-&gt;ReleaseSelContextMenu(); <br>} <br>break; <br>} <br> <br>// tell commdlg that selection may have changed <br>m_psfv-&gt;OnStateChange(CDBOSC_SELCHANGE); <br> <br>// The rest only cares about SELCHANGE messages <br>if ((pNotifyLV-&gt;uNewState^pNotifyLV-&gt;uOldState) &amp; LVIS_SELECTED) <br>{ <br>m_psfv-&gt;ReleaseSelContextMenu(); <br>} <br> <br>break; <br> <br>case LVN_BEGINDRAG: <br>case LVN_BEGINRDRAG: <br>return(BeginDrag()); <br> <br>    case NM_RETURN: <br>    case NM_DBLCLK: <br>        ContextMenu((DWORD)-1, TRUE); <br>        break; <br> <br>default: <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br> <br>void CSFViewDlg::ContextMenu(DWORD dwPos, BOOL bDoDefault) <br>{ <br>int idDefault = -1; <br>int nInsert; <br>UINT fFlags = 0; <br>POINT pt; <br> <br>// Find the selected item <br>int iItem = ListView_GetNextItem(m_cList, -1, LVNI_SELECTED); <br> <br>if (dwPos == (DWORD) -1) <br>{ <br>if (iItem != -1) <br>{ <br>RECT rc; <br>int iItemFocus = ListView_GetNextItem(m_cList, -1, LVNI_FOCUSED|LVNI_SELECTED); <br>if (iItemFocus == -1) <br>{ <br>iItemFocus = iItem; <br>} <br> <br>// Note that ListView_GetItemRect returns client coordinates <br>ListView_GetItemRect(m_cList, iItemFocus, &amp;rc, LVIR_ICON); <br>pt.x = (rc.left+rc.right)/2; <br>pt.y = (rc.top+rc.bottom)/2; <br>} <br>else <br>{ <br>pt.x = pt.y = 0; <br>} <br> <br>MapWindowPoints(m_cList, HWND_DESKTOP, &amp;pt, 1); <br>} <br>else <br>{ <br>pt.x = LOWORD(dwPos); <br>pt.y = HIWORD(dwPos); <br>} <br> <br>CMenuTemp cmContext(CreatePopupMenu()); <br>if (!(HMENU)cmContext) <br>{ <br>// There should be an error message here <br>return; <br>} <br> <br>LPCONTEXTMENU pcm = NULL; <br> <br>if (iItem == -1) <br>{ <br>// No selected item; use the background context menu <br>nInsert = -1; <br> <br>CMenuTemp cmMerge(_LoadPopupMenu(MENU_SFV, 0)); <br>if (!(HMENU)cmMerge) <br>{ <br>//  There should be an error message here <br>return; <br>} <br> <br>Cab_MergeMenus(cmContext, cmMerge, 0, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST, 0); <br>m_psfv-&gt;MergeArrangeMenu(cmContext); <br>m_psfv-&gt;InitViewMenu(cmContext); <br> <br>if (FAILED(m_psfv-&gt;m_psf-&gt;CreateViewObject(m_psfv-&gt;m_hwndMain, IID_IContextMenu, <br>(LPVOID *)&amp;pcm))) <br>{ <br>pcm = NULL; <br>} <br>} <br>else <br>{ <br>nInsert = 0; <br> <br>pcm = m_psfv-&gt;GetSelContextMenu(); <br>} <br>CEnsureRelease erPCM(pcm); <br> <br>if (pcm) <br>{ <br>if (m_psfv-&gt;m_psb) <br>{ <br>// Determine whether we are in Explorer mode <br>HWND hwnd = NULL; <br>m_psfv-&gt;m_psb-&gt;GetControlWindow(FCW_TREE, &amp;hwnd); <br>if (hwnd) <br>{ <br>fFlags |= CMF_EXPLORE; <br>} <br>} <br> <br>pcm-&gt;QueryContextMenu(cmContext, nInsert, <br>SFV_CONTEXT_FIRST, SFV_CONTEXT_LAST, fFlags); <br> <br>// If this is the common dialog browser, we need to make the <br>// default command "Select" so that double-clicking (which is <br>// open in common dialog) makes sense. <br>if (m_psfv-&gt;IsInCommDlg() &amp;&amp; iItem!=-1) <br>{ <br>// make sure this is an item <br>CMenuTemp cmSelect(_LoadPopupMenu(MENU_SFV, 1)); <br> <br>Cab_MergeMenus(cmContext, cmSelect, 0, 0, (UINT)-1, MM_ADDSEPARATOR); <br> <br>SetMenuDefaultItem(cmContext, 0, MF_BYPOSITION); <br>} <br> <br>idDefault = GetMenuDefaultItem(cmContext, MF_BYCOMMAND, 0); <br>} <br> <br>_PrettyMenu(cmContext); <br> <br>    int idCmd; <br>    if (bDoDefault) <br>    { <br>        if (idDefault &lt; 0) <br>        { <br>            return; <br>        } <br> <br>        idCmd = idDefault; <br>    } <br>    else <br>    { <br>    idCmd = TrackPopupMenu(cmContext, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN, <br>    pt.x, pt.y, 0, m_psfv-&gt;m_cView, NULL); <br>    } <br> <br>if ((idCmd==idDefault) &amp;&amp; m_psfv-&gt;OnDefaultCommand()==S_OK) <br>{ <br>// commdlg browser ate the default command <br>} <br>else if (idCmd == 0) <br>{ <br>// No item selected <br>} <br>else <br>{ <br>m_psfv-&gt;OnCommand(pcm, GET_WM_COMMAND_MPS(idCmd, 0, 0)); <br>} <br>} <br> <br> <br>BOOL CSFViewDlg::RealDlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch(uMsg) <br>{ <br>case WM_INITDIALOG: <br>InitDialog(); <br>break; <br> <br>case WM_DESTROY: <br>m_cList.DeleteAllItems(); <br>if (OleInited()) <br>{ <br>OleUninitialize(); <br>m_hrOLE = E_UNEXPECTED; <br>} <br>break; <br> <br>case WM_NOTIFY: <br>SetWindowLong(m_hDlg, DWL_MSGRESULT, Notify((LPNMHDR)lParam)); <br>break; <br> <br>case WM_INITMENUPOPUP: <br>        m_psfv-&gt;OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam)); <br>break; <br> <br>case WM_COMMAND: <br>m_psfv-&gt;OnCommand(NULL, wParam, lParam); <br>break; <br> <br>case WM_CONTEXTMENU: <br>ContextMenu(lParam); <br>break; <br> <br>case WM_SIZE: <br>SetWindowPos(m_cList, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), <br>SWP_NOZORDER|SWP_SHOWWINDOW); <br>break; <br> <br>case WM_MENUSELECT: <br>    m_psfv-&gt;OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam), <br>    GET_WM_MENUSELECT_FLAGS(wParam, lParam), <br>    GET_WM_MENUSELECT_HMENU(wParam, lParam)); <br>    break; <br> <br>default: <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br> <br>UINT CSFViewDlg::CharWidth() <br>{ <br>HDC hdc = GetDC(m_cList); <br>SelectFont(hdc, FORWARD_WM_GETFONT(m_cList, SendMessage)); <br> <br>SIZE siz; <br>GetTextExtentPoint(hdc, "0", 1, &amp;siz); <br>ReleaseDC(m_cList, hdc); <br> <br>return(siz.cx); <br>} <br> <br> <br>int CSFViewDlg::AddObject(LPCITEMIDLIST pidl) <br>{ <br>LV_ITEM item; <br> <br>item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br>item.iItem = 0x7fff;     // add at end <br>item.iSubItem = 0; <br> <br>item.iImage = I_IMAGECALLBACK; <br>item.pszText = LPSTR_TEXTCALLBACK; <br>item.lParam = (LPARAM)pidl; <br> <br>return(m_cList.InsertItem(&amp;item)); <br>} <br> <br> <br>LPCITEMIDLIST CSFViewDlg::GetPIDL(int iItem) <br>{ <br>LV_ITEM item; <br> <br>item.mask = LVIF_PARAM; <br>item.iItem = iItem; <br>item.iSubItem = 0; <br>item.lParam = 0; <br>if (iItem != -1) <br>{ <br>ListView_GetItem(m_cList, &amp;item); <br>} <br> <br>return((LPCITEMIDLIST)item.lParam); <br>} <br> <br> <br>UINT CSFViewDlg::GetItemPIDLS(LPCITEMIDLIST apidl[], UINT cItemMax, UINT uItem) <br>{ <br>// We should put the focused one at the top of the list. <br>int iItem = -1; <br>int iItemFocus = -1; <br>UINT cItem = 0; <br>UINT uType; <br> <br>switch (uItem) <br>{ <br>case SVGIO_SELECTION: <br>// special case for faster search <br>if (!cItemMax) <br>{ <br>return ListView_GetSelectedCount(m_cList); <br>} <br>iItemFocus = ListView_GetNextItem(m_cList, -1, LVNI_FOCUSED); <br>uType = LVNI_SELECTED; <br>break; <br> <br>case SVGIO_ALLVIEW: <br>// special case for faster search <br>if (!cItemMax) <br>{ <br>return ListView_GetItemCount(m_cList); <br>} <br>uType = LVNI_ALL; <br>break; <br> <br>default: <br>return(0); <br>} <br> <br>while((iItem=ListView_GetNextItem(m_cList, iItem, uType)) != -1) <br>{ <br>if (cItem &lt; cItemMax) <br>{ <br>// Check if the item is the focused one or not. <br>if (iItem == iItemFocus) <br>{ <br>// Yes, put it at the top. <br>apidl[cItem] = apidl[0]; <br>apidl[0] = GetPIDL(iItem); <br>} <br>else <br>{ <br>// No, put it at the end of the list. <br>apidl[cItem] = GetPIDL(iItem); <br>} <br>} <br> <br>cItem++; <br>} <br> <br>return cItem; <br>} <br> <br> <br>HRESULT CSFViewDlg::GetItemObjects(LPCITEMIDLIST **ppidl, UINT uItem) <br>{ <br>UINT cItems = GetItemPIDLS(NULL, 0, uItem); <br>LPCITEMIDLIST * apidl; <br> <br>if (ppidl != NULL) <br>{ <br>*ppidl = NULL; <br> <br>if (cItems == 0) <br>{ <br>return(ResultFromShort(0));  // nothing allocated... <br>} <br> <br>apidl = new LPCITEMIDLIST[cItems]; <br>if (!apidl) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>*ppidl = apidl; <br>cItems = GetItemPIDLS(apidl, cItems, uItem); <br>} <br> <br>return(ResultFromShort(cItems)); <br>} <br> <br> <br>HRESULT CSFViewDlg::GetUIObjectFromItem(REFIID riid, LPVOID * ppv, UINT uItem) <br>{ <br>LPCITEMIDLIST * apidl; <br>HRESULT hres = GetItemObjects(&amp;apidl, uItem); <br>UINT cItems = ShortFromResult(hres); <br> <br>if (FAILED(hres)) <br>{ <br>return(hres); <br>} <br> <br>if (!cItems) <br>{ <br>return(E_INVALIDARG); <br>} <br> <br>hres = m_psfv-&gt;m_psf-&gt;GetUIObjectOf(m_psfv-&gt;m_hwndMain, cItems, apidl, riid, 0, ppv); <br> <br>delete apidl; <br> <br>return hres; <br>} <br> <br> <br>HRESULT CSFViewDlg::GetAttributesFromItem(ULONG *pdwAttr, UINT uItem) <br>{ <br>LPCITEMIDLIST * apidl; <br>HRESULT hres = GetItemObjects(&amp;apidl, uItem); <br>UINT cItems = ShortFromResult(hres); <br> <br>if (FAILED(hres)) <br>{ <br>return(hres); <br>} <br> <br>if (!cItems) <br>{ <br>return(E_INVALIDARG); <br>} <br> <br>hres = m_psfv-&gt;m_psf-&gt;GetAttributesOf(cItems, apidl, pdwAttr); <br> <br>delete apidl; <br> <br>return hres; <br>} <br> <br> <br>BOOL CSFViewDlg::IsMenuSeparator(HMENU hm, int i) <br>{ <br>MENUITEMINFO mii; <br> <br>mii.cbSize = sizeof(MENUITEMINFO); <br>mii.fMask = MIIM_TYPE; <br>mii.cch = 0;    // WARNING: We MUST initialize it to 0!!! <br>if (!GetMenuItemInfo(hm, i, TRUE, &amp;mii)) <br>{ <br>return(FALSE); <br>} <br> <br>if (mii.fType &amp; MFT_SEPARATOR) <br>{ <br>return(TRUE); <br>} <br> <br>return(FALSE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
