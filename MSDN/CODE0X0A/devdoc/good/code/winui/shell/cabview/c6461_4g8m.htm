<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DA.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6466"></a>DA.C</h2>
<pre><code>// Dynamic Array APIs <br>//******************************************************************************************* <br>// <br>// Filename : Da.c <br>// <br>//Implementation of DPAs <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br> <br>#include "pch.h" <br>#include "dpda.h" <br>#include &lt;assert.h&gt; <br> <br>#ifdef DEBUG <br>#define DPA_MAGIC   ('P' | ('A' &lt;&lt; 256)) <br>#define IsDPA(pdpa) ((pdpa) &amp;&amp; (pdpa)-&gt;magic == DPA_MAGIC) <br>#else <br>#define IsDPA(pdsa) <br>#endif <br> <br> <br>#define ControlAlloc(hheap, cb)       HeapAlloc((hheap), HEAP_ZERO_MEMORY, (cb)) <br>#define ControlReAlloc(hheap, pb, cb) HeapReAlloc((hheap), HEAP_ZERO_MEMORY, (pb),(cb)) <br>#define ControlFree(hheap, pb)        HeapFree((hheap), 0, (pb)) <br>#define ControlSize(hheap, pb)        HeapSize((hheap), 0, (LPCVOID)(pb)) <br> <br>typedef struct { <br>    void **pp; <br>    PFNDPACOMPARE pfnCmp; <br>    LPARAM lParam; <br>    int cp; <br>    void **ppT; <br>} SORTPARAMS; <br> <br>BOOL DPA_MergeSort(SORTPARAMS * psp); <br>void DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems); <br> <br> <br> <br>//================== Dynamic pointer array implementation =========== <br> <br>typedef struct _DPA { <br>// NOTE: The following two fields MUST be defined in this order, at <br>// the beginning of the structure in order for the macro APIs to work. <br>// <br>    int cp; <br>    void **pp; <br> <br>    HANDLE hheap;        // Heap to allocate from if NULL use shared <br> <br>    int cpAlloc; <br>    int cpGrow; <br>#ifdef DEBUG <br>  UINT magic; <br>#endif <br>} DPA; <br> <br>HANDLE g_hSharedHeap = NULL; <br> <br>void * Alloc(long cb) <br>{ <br>    // I will assume that this is the only one that needs the checks to <br>    // see if the heap has been previously created or not <br> <br>    if (g_hSharedHeap == NULL) <br>    { <br>        g_hSharedHeap = HeapCreate(0, 1, 0); <br> <br>        // If still NULL we have problems! <br>        if (g_hSharedHeap == NULL) <br>            return(NULL); <br>    } <br> <br>    return HeapAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, cb); <br>} <br> <br>void * ReAlloc(void * pb, long cb) <br>{ <br>    if (pb == NULL) <br>        return Alloc(cb); <br>    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pb, cb); <br>} <br> <br>BOOL Free(void * pb) <br>{ <br>    return HeapFree(g_hSharedHeap, 0, pb); <br>} <br> <br>DWORD GetSize(void * pb) <br>{ <br>    return HeapSize(g_hSharedHeap, 0, pb); <br>} <br> <br> <br>HDPA DPA_Create(int cpGrow) <br>{ <br>    HDPA pdpa = Alloc(sizeof(DPA)); <br>    if (pdpa) <br>    { <br>        pdpa-&gt;cp = 0; <br>        pdpa-&gt;cpAlloc = 0; <br>        pdpa-&gt;cpGrow = (cpGrow &lt; 8 ? 8 : cpGrow); <br>        pdpa-&gt;pp = NULL; <br>        pdpa-&gt;hheap = g_hSharedHeap;   // Defaults to use shared one (for now...) <br>#ifdef DEBUG <br>        pdpa-&gt;magic = DPA_MAGIC; <br>#endif <br>    } <br>    return pdpa; <br>} <br> <br>// Should nuke the standard DPA above... <br>HDPA DPA_CreateEx(int cpGrow, HANDLE hheap) <br>{ <br>    HDPA pdpa; <br>    if (hheap == NULL) <br>    { <br>        pdpa = Alloc(sizeof(DPA)); <br>        hheap = g_hSharedHeap; <br>    } <br>    else <br>        pdpa = ControlAlloc(hheap, sizeof(DPA)); <br>    if (pdpa) <br>    { <br>        pdpa-&gt;cp = 0; <br>        pdpa-&gt;cpAlloc = 0; <br>        pdpa-&gt;cpGrow = (cpGrow &lt; 8 ? 8 : cpGrow); <br>        pdpa-&gt;pp = NULL; <br>        pdpa-&gt;hheap = hheap; <br>#ifdef DEBUG <br>        pdpa-&gt;magic = DPA_MAGIC; <br>#endif <br>    } <br>    return pdpa; <br>} <br> <br>BOOL DPA_Destroy(HDPA pdpa) <br>{ <br>    //assert(IsDPA(pdpa)); <br> <br>    if (pdpa == NULL)       // allow NULL for low memory cases, still assert <br>        return TRUE; <br> <br>    assert (pdpa-&gt;hheap); <br> <br>#ifdef DEBUG <br>    pdpa-&gt;cp = 0; <br>    pdpa-&gt;cpAlloc = 0; <br>    pdpa-&gt;magic = 0; <br>#endif <br>    if (pdpa-&gt;pp &amp;&amp; !ControlFree(pdpa-&gt;hheap, pdpa-&gt;pp)) <br>        return FALSE; <br> <br>    return ControlFree(pdpa-&gt;hheap, pdpa); <br>} <br> <br>HDPA DPA_Clone(HDPA pdpa, HDPA pdpaNew) <br>{ <br>    BOOL fAlloc = FALSE; <br> <br>    if (!pdpaNew) <br>    { <br>        pdpaNew = DPA_CreateEx(pdpa-&gt;cpGrow, pdpa-&gt;hheap); <br>        if (!pdpaNew) <br>            return NULL; <br> <br>        fAlloc = TRUE; <br>    } <br> <br>    if (!DPA_Grow(pdpaNew, pdpa-&gt;cpAlloc)) { <br>if (!fAlloc) <br>    DPA_Destroy(pdpaNew); <br>return NULL; <br>    } <br> <br>    pdpaNew-&gt;cp = pdpa-&gt;cp; <br>    hmemcpy(pdpaNew-&gt;pp, pdpa-&gt;pp, pdpa-&gt;cp * sizeof(void *)); <br> <br>    return pdpaNew; <br>} <br> <br>void * DPA_GetPtr(HDPA pdpa, int index) <br>{ <br>//    assert(IsDPA(pdpa)); <br> <br>    if (index &lt; 0 || index &gt;= pdpa-&gt;cp) <br>        return NULL; <br> <br>    return pdpa-&gt;pp[index]; <br>} <br> <br>int DPA_GetPtrIndex(HDPA pdpa, void * p) <br>{ <br>    void **pp; <br>    void **ppMax; <br> <br>    if (pdpa-&gt;pp) <br>    { <br>        pp = pdpa-&gt;pp; <br>        ppMax = pp + pdpa-&gt;cp; <br>        for ( ; pp &lt; ppMax; pp++) <br>        { <br>            if (*pp == p) <br>                return (pp - pdpa-&gt;pp); <br>        } <br>    } <br>    return -1; <br>} <br> <br>BOOL DPA_Grow(HDPA pdpa, int cpAlloc) <br>{ <br>    if (cpAlloc &gt; pdpa-&gt;cpAlloc) <br>    { <br>        void **ppNew; <br> <br>        cpAlloc = ((cpAlloc + pdpa-&gt;cpGrow - 1) / pdpa-&gt;cpGrow) * pdpa-&gt;cpGrow; <br> <br>        if (pdpa-&gt;pp) <br>            ppNew = (void * *)ControlReAlloc(pdpa-&gt;hheap, pdpa-&gt;pp, cpAlloc * sizeof(void *)); <br>        else <br>            ppNew = (void * *)ControlAlloc(pdpa-&gt;hheap, cpAlloc * sizeof(void *)); <br>        if (!ppNew) <br>            return FALSE; <br> <br>        pdpa-&gt;pp = ppNew; <br>        pdpa-&gt;cpAlloc = cpAlloc; <br>    } <br>    return TRUE; <br>} <br> <br>BOOL DPA_SetPtr(HDPA pdpa, int index, void * p) <br>{ <br>    if (index &lt; 0) <br>    { <br>        // DebugMsg(DM_ERROR, "DPA: Invalid index: %d", index); <br>        return FALSE; <br>    } <br> <br>    if (index &gt;= pdpa-&gt;cp) <br>    { <br>        if (!DPA_Grow(pdpa, index + 1)) <br>            return FALSE; <br>        pdpa-&gt;cp = index + 1; <br>    } <br> <br>    pdpa-&gt;pp[index] = p; <br> <br>    return TRUE; <br>} <br> <br>int DPA_InsertPtr(HDPA pdpa, int index, void * p) <br>{ <br>    if (index &lt; 0) <br>    { <br>        return -1; <br>    } <br>    if (index &gt; pdpa-&gt;cp) <br>        index = pdpa-&gt;cp; <br> <br>    // Make sure we have room for one more item <br>    // <br>    if (pdpa-&gt;cp + 1 &gt; pdpa-&gt;cpAlloc) <br>    { <br>        if (!DPA_Grow(pdpa, pdpa-&gt;cp + 1)) <br>            return -1; <br>    } <br> <br>    // If we are inserting, we need to slide everybody up <br>    // <br>    if (index &lt; pdpa-&gt;cp) <br>    { <br>        hmemcpy(&amp;pdpa-&gt;pp[index + 1], &amp;pdpa-&gt;pp[index], <br>            (pdpa-&gt;cp - index) * sizeof(void *)); <br>    } <br> <br>    pdpa-&gt;pp[index] = p; <br>    pdpa-&gt;cp++; <br> <br>    return index; <br>} <br> <br>void * DPA_DeletePtr(HDPA pdpa, int index) <br>{ <br>    void * p; <br> <br>//    assert(IsDPA(pdpa)); <br> <br>    if (index &lt; 0 || index &gt;= pdpa-&gt;cp) <br>    { <br>     //   DebugMsg(DM_ERROR, "DPA: Invalid index: %d", index); <br>        return NULL; <br>    } <br> <br>    p = pdpa-&gt;pp[index]; <br> <br>    if (index &lt; pdpa-&gt;cp - 1) <br>    { <br>        hmemcpy(&amp;pdpa-&gt;pp[index], &amp;pdpa-&gt;pp[index + 1], <br>            (pdpa-&gt;cp - (index + 1)) * sizeof(void *)); <br>    } <br>    pdpa-&gt;cp--; <br> <br>    if (pdpa-&gt;cpAlloc - pdpa-&gt;cp &gt; pdpa-&gt;cpGrow) <br>    { <br>        void **ppNew; <br>        ppNew = ControlReAlloc(pdpa-&gt;hheap, pdpa-&gt;pp, (pdpa-&gt;cpAlloc - pdpa-&gt;cpGrow) * sizeof(void *)); <br> <br>        assert(ppNew); <br>        pdpa-&gt;pp = ppNew; <br>        pdpa-&gt;cpAlloc -= pdpa-&gt;cpGrow; <br>    } <br>    return p; <br>} <br> <br>BOOL DPA_DeleteAllPtrs(HDPA pdpa) <br>{ <br>    if (pdpa-&gt;pp &amp;&amp; !ControlFree(pdpa-&gt;hheap, pdpa-&gt;pp)) <br>        return FALSE; <br>    pdpa-&gt;pp = NULL; <br>    pdpa-&gt;cp = pdpa-&gt;cpAlloc = 0; <br>    return TRUE; <br>} <br> <br>BOOL DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam) <br>{ <br>    SORTPARAMS sp; <br> <br>    sp.cp = pdpa-&gt;cp; <br>    sp.pp = pdpa-&gt;pp; <br>    sp.pfnCmp = pfnCmp; <br>    sp.lParam = lParam; <br> <br>    return DPA_MergeSort(&amp;sp); <br>} <br> <br>#define SortCompare(psp, pp1, i1, pp2, i2) \ <br>(psp-&gt;pfnCmp(pp1[i1], pp2[i2], psp-&gt;lParam)) <br> <br>// <br>//  This function merges two sorted lists and makes one sorted list. <br>//   psp-&gt;pp[iFirst, iFirst+cItes/2-1], psp-&gt;pp[iFirst+cItems/2, iFirst+cItems-1] <br>// <br>void DPA_MergeThem(SORTPARAMS * psp, int iFirst, int cItems) <br>{ <br>    // <br>    // Notes: <br>    //  This function is separated from DPA_MergeSort2() to avoid comsuming <br>    // stack variables. Never inline this. <br>    // <br>    int cHalf = cItems/2; <br>    int iIn1, iIn2, iOut; <br>    LPVOID * ppvSrc = &amp;psp-&gt;pp[iFirst]; <br> <br>    // Copy the first part to temp storage so we can write directly into <br>    // the final buffer.  Note that this takes at most psp-&gt;cp/2 DWORD's <br>    hmemcpy(psp-&gt;ppT, ppvSrc, cHalf*sizeof(LPVOID)); <br> <br>    for (iIn1=0, iIn2=cHalf, iOut=0;;) <br>    { <br>if (SortCompare(psp, psp-&gt;ppT, iIn1, ppvSrc, iIn2) &lt;= 0) { <br>    ppvSrc[iOut++] = psp-&gt;ppT[iIn1++]; <br> <br>    if (iIn1==cHalf) { <br>// We used up the first half; the rest of the second half <br>// should already be in place <br>break; <br>    } <br>} else { <br>    ppvSrc[iOut++] = ppvSrc[iIn2++]; <br>    if (iIn2==cItems) { <br>// We used up the second half; copy the rest of the first half <br>// into place <br>hmemcpy(&amp;ppvSrc[iOut], &amp;psp-&gt;ppT[iIn1], (cItems-iOut)*sizeof(LPVOID)); <br>break; <br>    } <br>} <br>    } <br>} <br> <br>// <br>//  This function sorts a give list (psp-&gt;pp[iFirst,iFirst-cItems-1]). <br>// <br>void DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems) <br>{ <br>    // <br>    // Notes: <br>    //   This function is recursively called. Therefore, we should minimize <br>    //  the number of local variables and parameters. At this point, we <br>    //  use one local variable and three parameters. <br>    // <br>    int cHalf; <br> <br>    switch(cItems) <br>    { <br>    case 1: <br>return; <br> <br>    case 2: <br>// Swap them, if they are out of order. <br>if (SortCompare(psp, psp-&gt;pp, iFirst, psp-&gt;pp, iFirst+1) &gt; 0) <br>{ <br>    psp-&gt;ppT[0] = psp-&gt;pp[iFirst]; <br>    psp-&gt;pp[iFirst] = psp-&gt;pp[iFirst+1]; <br>    psp-&gt;pp[iFirst+1] = psp-&gt;ppT[0]; <br>} <br>break; <br> <br>    default: <br>    cHalf = cItems/2; <br>// Sort each half <br>DPA_MergeSort2(psp, iFirst, cHalf); <br>DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf); <br>// Then, merge them. <br>DPA_MergeThem(psp, iFirst, cItems); <br>break; <br>    } <br>} <br> <br>BOOL DPA_MergeSort(SORTPARAMS * psp) <br>{ <br>    if (psp-&gt;cp==0) <br>return TRUE; <br> <br>    // Note that we divide by 2 below; we want to round down <br>    psp-&gt;ppT = LocalAlloc(LPTR, psp-&gt;cp/2 * sizeof(LPVOID)); <br>    if (!psp-&gt;ppT) <br>return FALSE; <br> <br>    DPA_MergeSort2(psp, 0, psp-&gt;cp); <br>    LocalFree(psp-&gt;ppT); <br>    return TRUE; <br>} <br> <br>// Search function <br>// <br>int DPA_Search(HDPA pdpa, void * pFind, int iStart, <br>            PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options) <br>{ <br>    int cp = DPA_GetPtrCount(pdpa); <br> <br>    assert(pfnCompare); <br>    assert(0 &lt;= iStart); <br> <br>    // Only allow these wierd flags if the list is sorted <br>    assert((options &amp; DPAS_SORTED) || !(options &amp; (DPAS_INSERTBEFORE | DPAS_INSERTAFTER))); <br> <br>    if (!(options &amp; DPAS_SORTED)) <br>    { <br>        // Not sorted: do lisearch. <br>        int i; <br> <br>        for (i = iStart; i &lt; cp; i++) <br>        { <br>            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam)) <br>                return i; <br>        } <br>        return -1; <br>    } <br>    else <br>    { <br>        // Search the array using binary search.  If several adjacent  <br>        // elements match the target element, the index of the first <br>        // matching element is returned. <br> <br>        int iRet = -1;      // assume no match <br>        BOOL bFound = FALSE; <br>        int nCmp = 0; <br>        int iLow = 0;       // Don't bother using iStart for binary search <br>        int iMid = 0; <br>        int iHigh = cp - 1; <br> <br>        // (OK for cp == 0) <br>        while (iLow &lt;= iHigh) <br>        { <br>            iMid = (iLow + iHigh) / 2; <br> <br>            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam); <br> <br>            if (0 &gt; nCmp) <br>                iHigh = iMid - 1;       // First is smaller <br>            else if (0 &lt; nCmp) <br>                iLow = iMid + 1;        // First is larger <br>            else <br>            { <br>                // Match; search back for first match <br>                bFound = TRUE; <br>                while (0 &lt; iMid) <br>                { <br>                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam)) <br>                        break; <br>                    else <br>                        iMid--; <br>                } <br>                break; <br>            } <br>        } <br> <br>        if (bFound) <br>        { <br>            assert(0 &lt;= iMid); <br>            iRet = iMid; <br>        } <br> <br>        // Did the search fail AND <br>        // is one of the strange search flags set? <br>        if (!bFound &amp;&amp; (options &amp; (DPAS_INSERTAFTER | DPAS_INSERTBEFORE))) <br>        { <br>            // Yes; return the index where the target should be inserted <br>            // if not found <br>            if (0 &lt; nCmp)       // First is larger <br>                iRet = iLow; <br>            else <br>                iRet = iMid; <br>            // (We don't distinguish between the two flags anymore) <br>        } <br>        else if ( !(options &amp; (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) ) <br>        { <br>            // Sanity check with lisearch <br>            assert(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options &amp; ~DPAS_SORTED) == iRet); <br>        } <br>        return iRet; <br>    } <br>} <br> <br>//=========================================================================== <br>// <br>// String ptr management routines <br>// <br>// Copy as much of *psz to *pszBuf as will fit <br>// <br>int Str_GetPtr(LPCSTR psz, LPSTR pszBuf, int cchBuf) <br>{ <br>    int cch = 0; <br> <br>    // if pszBuf is NULL, just return length of string. <br>    // <br>    if (!pszBuf &amp;&amp; psz) <br>        return lstrlen(psz); <br> <br>    if (cchBuf) <br>    { <br>        if (psz) <br>        { <br>            cch = lstrlen(psz); <br> <br>            if (cch &gt; cchBuf - 1) <br>                cch = cchBuf - 1; <br> <br>            hmemcpy(pszBuf, psz, cch); <br>        } <br>        pszBuf[cch] = 0; <br>    } <br>    return cch; <br>} <br> <br>BOOL Str_Set(LPSTR *ppsz, LPCSTR psz) <br>{ <br>    if (!psz) <br>    { <br>        if (*ppsz) <br>        { <br>            LocalFree(*ppsz); <br>            *ppsz = NULL; <br>        } <br>    } <br>    else <br>    { <br>LPSTR pszNew; <br>        UINT cbSize = lstrlen(psz) + 1; <br>if (*ppsz) <br>    pszNew = LocalReAlloc(*ppsz, cbSize, LMEM_MOVEABLE | LMEM_ZEROINIT); <br>else <br>    pszNew = LocalAlloc(LPTR, cbSize); <br> <br>        if (!pszNew) <br>            return FALSE; <br> <br>        lstrcpy(pszNew, psz); <br>        *ppsz = pszNew; <br>    } <br>    return TRUE; <br>} <br> <br>// Set *ppsz to a copy of psz, reallocing as needed <br>// <br>BOOL Str_SetPtr(LPSTR * ppsz, LPCSTR psz) <br>{ <br>    if (!psz) <br>    { <br>        if (*ppsz) <br>        { <br>            Free(*ppsz); <br>            *ppsz = NULL; <br>        } <br>    } <br>    else <br>    { <br>        LPSTR pszNew = (LPSTR)ReAlloc(*ppsz, lstrlen(psz) + 1); <br>        if (!pszNew) <br>            return FALSE; <br> <br>        lstrcpy(pszNew, psz); <br>        *ppsz = pszNew; <br>    } <br>    return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
