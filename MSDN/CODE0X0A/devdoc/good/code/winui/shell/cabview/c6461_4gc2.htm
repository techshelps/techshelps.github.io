<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6482"></a>IUTIL.C</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : IUtil.c <br>// <br>//Implementation of Cab_MergeMenus and some other useful <br>//              routines <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br> <br>#include "pch.h" <br>#include "Cabvw2.h" <br> <br>// Copy a menu onto the beginning or end of another menu <br>// Adds uIDAdjust to each menu ID (pass in 0 for no adjustment) <br>// Will not add any item whose adjusted ID is greater than uMaxIDAdjust <br>// (pass in 0xffff to allow everything) <br>// Returns one more than the maximum adjusted ID that is used <br>// <br> <br>BOOL _SHIsMenuSeparator(HMENU hm, int i) <br>{ <br>        MENUITEMINFO mii; <br> <br>        mii.cbSize = sizeof(MENUITEMINFO); <br>        mii.fMask = MIIM_TYPE; <br>        mii.cch = 0;    // WARNING: We MUST initialize it to 0!!! <br>        if (!GetMenuItemInfo(hm, i, TRUE, &amp;mii)) <br>        { <br>                return(FALSE); <br>        } <br> <br>        if (mii.fType &amp; MFT_SEPARATOR) <br>        { <br>                return(TRUE); <br>        } <br> <br>        return(FALSE); <br>} <br> <br>UINT Cab_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags) <br>{ <br>        int nItem; <br>        HMENU hmSubMenu; <br>        BOOL bAlreadySeparated; <br>        MENUITEMINFO miiSrc; <br>        char szName[256]; <br>        UINT uTemp, uIDMax = uIDAdjust; <br> <br>        if (!hmDst || !hmSrc) <br>        { <br>                goto MM_Exit; <br>        } <br> <br>        nItem = GetMenuItemCount(hmDst); <br>        if (uInsert &gt;= (UINT)nItem) <br>        { <br>                uInsert = (UINT)nItem; <br>                bAlreadySeparated = TRUE; <br>        } <br>        else <br>        { <br>                bAlreadySeparated = _SHIsMenuSeparator(hmDst, uInsert);; <br>        } <br> <br>        if ((uFlags &amp; MM_ADDSEPARATOR) &amp;&amp; !bAlreadySeparated) <br>        { <br>                // Add a separator between the menus <br>                InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL); <br>                bAlreadySeparated = TRUE; <br>        } <br> <br> <br>        // Go through the menu items and clone them <br>        for (nItem = GetMenuItemCount(hmSrc) - 1; nItem &gt;= 0; nItem--) <br>        { <br>        miiSrc.cbSize = sizeof(MENUITEMINFO); <br>        miiSrc.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA; <br>                // We need to reset this every time through the loop in case <br>                // menus DON'T have IDs <br>                miiSrc.fType = MFT_STRING; <br>                miiSrc.dwTypeData = szName; <br>                miiSrc.dwItemData = 0; <br>                miiSrc.cch        = sizeof(szName); <br> <br>                if (!GetMenuItemInfo(hmSrc, nItem, TRUE, &amp;miiSrc)) <br>                { <br>                        continue; <br>                } <br> <br>                if (miiSrc.fType &amp; MFT_SEPARATOR) <br>                { <br>                        // This is a separator; don't put two of them in a row <br>                        if (bAlreadySeparated) <br>                        { <br>                                continue; <br>                        } <br> <br>                        bAlreadySeparated = TRUE; <br>                } <br>                else if (miiSrc.hSubMenu) <br>                { <br>                        if (uFlags &amp; MM_SUBMENUSHAVEIDS) <br>                        { <br>                                // Adjust the ID and check it <br>                                miiSrc.wID += uIDAdjust; <br>                                if (miiSrc.wID &gt; uIDAdjustMax) <br>                                { <br>                                        continue; <br>                                } <br> <br>                                if (uIDMax &lt;= miiSrc.wID) <br>                                { <br>                                        uIDMax = miiSrc.wID + 1; <br>                                } <br>                        } <br>                        else <br>                        { <br>                                // Don't set IDs for submenus that didn't have <br>                                // them already <br>                                miiSrc.fMask &amp;= ~MIIM_ID; <br>                        } <br> <br>                        hmSubMenu = miiSrc.hSubMenu; <br>                        miiSrc.hSubMenu = CreatePopupMenu(); <br>                        if (!miiSrc.hSubMenu) <br>                        { <br>                                goto MM_Exit; <br>                        } <br> <br>                        uTemp = Cab_MergeMenus(miiSrc.hSubMenu, hmSubMenu, 0, uIDAdjust, <br>                                uIDAdjustMax, uFlags&amp;MM_SUBMENUSHAVEIDS); <br>                        if (uIDMax &lt;= uTemp) <br>                        { <br>                                uIDMax = uTemp; <br>                        } <br> <br>                        bAlreadySeparated = FALSE; <br>                } <br>                else <br>                { <br>                        // Adjust the ID and check it <br>                        miiSrc.wID += uIDAdjust; <br>                        if (miiSrc.wID &gt; uIDAdjustMax) <br>                        { <br>                                continue; <br>                        } <br> <br>                        if (uIDMax &lt;= miiSrc.wID) <br>                        { <br>                                uIDMax = miiSrc.wID + 1; <br>                        } <br> <br>                        bAlreadySeparated = FALSE; <br>                } <br> <br>                if (!InsertMenuItem(hmDst, uInsert, TRUE, &amp;miiSrc)) <br>                { <br>                        goto MM_Exit; <br>                } <br>        } <br> <br>        // Ensure the correct number of separators at the beginning of the <br>        // inserted menu items <br>        if (uInsert == 0) <br>        { <br>                if (bAlreadySeparated) <br>                { <br>                        DeleteMenu(hmDst, uInsert, MF_BYPOSITION); <br>                } <br>        } <br>        else <br>        { <br>                if (_SHIsMenuSeparator(hmDst, uInsert-1)) <br>                { <br>                        if (bAlreadySeparated) <br>                        { <br>                                DeleteMenu(hmDst, uInsert, MF_BYPOSITION); <br>                        } <br>                } <br>                else <br>                { <br>                        if ((uFlags &amp; MM_ADDSEPARATOR) &amp;&amp; !bAlreadySeparated) <br>                        { <br>                                // Add a separator between the menus <br>                                InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL); <br>                        } <br>                } <br>        } <br> <br>MM_Exit: <br>        return(uIDMax); <br>} <br> <br> <br> <br>int OleStrToStrN(LPSTR psz, int cchMultiByte, LPCOLESTR pwsz, int cchWideChar) <br>{ <br>    return WideCharToMultiByte(CP_ACP, 0, pwsz, cchWideChar, psz, cchMultiByte, NULL, NULL); <br>} <br> <br>int OleStrToStr(LPSTR psz, LPCOLESTR pwsz) <br>{ <br>    return WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, MAX_PATH, NULL, NULL); <br>} <br> <br>int StrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCSTR psz, int cchMultiByte) <br>{ <br>    return MultiByteToWideChar(CP_ACP, 0, psz, cchMultiByte, pwsz, cchWideChar); <br>} <br> <br>int StrToOleStr(LPOLESTR pwsz, LPCSTR psz) <br>{ <br>    return MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, MAX_PATH); <br>} <br> <br>/* <br> *  <br> */ <br> <br> <br>UINT ILGetSize(LPCITEMIDLIST pidl) <br>{ <br>    UINT cbTotal = 0; <br>    if (pidl) <br>    { <br>        VALIDATE_PIDL(pidl); <br>cbTotal += sizeof(pidl-&gt;mkid.cb);// Null terminator <br>while (pidl-&gt;mkid.cb) <br>{ <br>    cbTotal += pidl-&gt;mkid.cb; <br>    pidl = _ILNext(pidl); <br>} <br>    } <br> <br>    return cbTotal; <br>} <br> <br> <br>LPITEMIDLIST ILClone(LPCITEMIDLIST pidl) <br>{ <br>    UINT cb = ILGetSize(pidl); <br>    LPMALLOC pMalloc; <br>LPITEMIDLIST pidlRet; <br> <br>SHGetMalloc(&amp;pMalloc);  <br>pidlRet = (LPITEMIDLIST)pMalloc-&gt;lpVtbl-&gt;Alloc(pMalloc, cb); <br>pMalloc-&gt;lpVtbl-&gt;Release(pMalloc); <br> <br>    if (pidlRet) <br>    { <br>// Notes: no need to zero-init. <br>hmemcpy(pidlRet, pidl, cb); <br>    } <br>    return pidlRet; <br>} <br> <br> <br>void ILFree(LPITEMIDLIST pidl) <br>{ <br>LPMALLOC pMalloc; <br> <br>    if (pidl) <br>    { <br>#ifdef DEBUG <br>        UINT cbSize = ILGetSize(pidl); <br>        VALIDATE_PIDL(pidl); <br> <br>        // Fill the memory with some bad value... <br>        _fmemset(pidl, 0xE5, cbSize); <br> <br>        // If large enough try to save the call return address of who <br>        // freed us in the 3-6 byte of the structure. <br>        if (cbSize &gt;= 6) <br>            *((UINT*)((LPSTR)pidl + 2)) =  *(((UINT*)&amp;pidl) - 1); <br> <br>#endif <br>SHGetMalloc(&amp;pMalloc); <br>pMalloc-&gt;lpVtbl-&gt;Free(pMalloc, pidl); <br>pMalloc-&gt;lpVtbl-&gt;Release(pMalloc); <br> <br>    } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
