<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SFVIEW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6492"></a>SFVIEW.CPP</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : Sfview.cpp <br>// <br>//Implementation file for CSFView <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br>#include "Pch.H" <br> <br>#include "SFView.H" <br>#include "SFVWnd.H" <br> <br>#include "Resource.H" <br> <br>#include "ThisGuid.H" <br> <br>// Define the ShellFolderView IID's <br>#pragma data_seg(".text") <br>#define INITGUID <br>#include &lt;initguid.h&gt; <br>#include "SFView.H" <br>//#undef INITGUID <br>#pragma data_seg() <br> <br>struct SFSTATE_HDR <br>{ <br>CLSID clsThis; <br>SFSTATE sfState; <br>UINT nCols; <br>} ; <br> <br> <br>CSFView::CSFView(LPSHELLFOLDER psf, IShellFolderViewCallback *psfvcb) : <br>m_psf(psf), m_erFolder(psf), m_erCB(psfvcb), m_pCDB(NULL), m_cView(NULL), <br>m_uState(SVUIA_DEACTIVATE), m_pcmSel(NULL), m_cAccel(IDA_MAIN) <br>{ <br>m_psfvcb = psfvcb; <br>if (psfvcb) <br>{ <br>psfvcb-&gt;AddRef(); <br>} <br> <br>psf-&gt;AddRef(); <br> <br>m_aParamSort = DPA_Create(4); <br>m_sfState.lParamSort = 0; <br>} <br> <br> <br>CSFView::~CSFView() <br>{ <br>ReleaseSelContextMenu(); <br>} <br> <br> <br>STDMETHODIMP CSFView::QueryInterface(REFIID riid, LPVOID * ppvObj) <br>{ <br>static const IID *apiid[] = { &amp;IID_IShellView, NULL }; <br>LPUNKNOWN aobj[] = { (IShellView *)this }; <br> <br>return(QIHelper(riid, ppvObj, apiid, aobj)); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CSFView::AddRef() <br>{ <br>return(AddRefHelper()); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CSFView::Release() <br>{ <br>return(ReleaseHelper()); <br>} <br> <br> <br>STDMETHODIMP CSFView::GetWindow(HWND * lphwnd) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CSFView::ContextSensitiveHelp(BOOL fEnterMode) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>//***************************************************************************** <br>// <br>// CSFView::TranslateAccelerator <br>// <br>// Purpose: <br>//         Handle the accelerator keystrokes <br>// <br>// <br>// Parameters: <br>//        LPMSG lpmsg    -    message structure <br>// <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br>STDMETHODIMP CSFView::TranslateAccelerator(LPMSG lpmsg) <br>{ <br>return(m_cAccel.TranslateAccelerator(m_cView, lpmsg) ? S_OK : S_FALSE); <br>} <br> <br> <br>STDMETHODIMP CSFView::EnableModeless(BOOL fEnable) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>//***************************************************************************** <br>// <br>// CSFView:UIActivate <br>// <br>// Purpose: <br>//        The explorer calls this member function whenever the activation          <br>//  state of the view window is changed by a certain event that is            <br>//  NOT caused by the shell view itself. <br>// <br>// <br>// Parameters: <br>// <br>//        UINT uState    -    UI activate flag <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br>STDMETHODIMP CSFView::UIActivate(UINT uState) <br>{ <br>if (uState) <br>{ <br>OnActivate(uState); <br>} <br>else <br>{ <br>OnDeactivate(); <br>} <br> <br>return S_OK; <br>} <br> <br> <br>STDMETHODIMP CSFView::Refresh() <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>//***************************************************************************** <br>// <br>// CSFView::CreateViewWindow <br>// <br>// Purpose: <br>// <br>//        called by IShellBrowser to create a contents pane window <br>// <br>// Parameters: <br>//     <br>//    IShellView  *lpPrevView    -    previous view <br>//    LPCFOLDERSETTINGS lpfs     -    folder settings for the view <br>//    IShellBrowser *psb         -    pointer to the shell browser <br>//    RECT * prcView             -    view Rectangle <br>//    HWND * phWnd               -    pointer to Window handle <br>// <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br>STDMETHODIMP CSFView::CreateViewWindow(IShellView  *lpPrevView, <br>                LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb, <br>                RECT * prcView, HWND  *phWnd) <br>{ <br>*phWnd = NULL; <br> <br>if ((HWND)m_cView) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>m_fs = *lpfs; <br>m_psb = psb; <br> <br>// get the main window handle from shell browser <br> <br>psb-&gt;GetWindow(&amp;m_hwndMain); <br> <br>// bring up the contents pane <br> <br>if (!m_cView.DoModeless(IDD_VIEW, m_hwndMain)) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>*phWnd = m_cView; <br> <br>// map the current view mode into menu id and set the contents pane <br>// view mode accordingly <br> <br>OnCommand(NULL, GET_WM_COMMAND_MPS(GetMenuIDFromViewMode(), 0, 0)); <br> <br>AddColumns(); <br> <br>RestoreViewState(); <br> <br>// size the contents pane <br>SetWindowPos(m_cView, NULL, prcView-&gt;left, prcView-&gt;top, <br>prcView-&gt;right-prcView-&gt;left, prcView-&gt;bottom-prcView-&gt;top, <br>SWP_NOZORDER|SWP_SHOWWINDOW); <br> <br>FillList(TRUE); <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP CSFView::DestroyViewWindow() <br>{ <br>if (!(HWND)m_cView) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>m_cView.DestroyWindow(); <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP CSFView::GetCurrentInfo(LPFOLDERSETTINGS lpfs) <br>{ <br>*lpfs = m_fs; <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP CSFView::AddPropertySheetPages(DWORD dwReserved, <br>                LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CSFView::SaveViewState() <br>{ <br>SFSTATE_HDR hdr; <br>LPSTREAM pstm; <br> <br>HRESULT hres = m_psb-&gt;GetViewStateStream(STGM_WRITE, &amp;pstm); <br>if (FAILED(hres)) <br>{ <br>return(hres); <br>} <br>CEnsureRelease erStr(pstm); <br> <br>pstm-&gt;Write(&amp;hdr, sizeof(hdr), NULL); <br> <br>hdr.clsThis = CLSID_ThisDll; <br>hdr.sfState = m_sfState; <br>hdr.nCols = SaveColumns(pstm); <br> <br>ULARGE_INTEGER libCurPosition; <br>LARGE_INTEGER dlibMove; <br>dlibMove.HighPart = 0; <br>dlibMove.LowPart = 0; <br>pstm-&gt;Seek(dlibMove, STREAM_SEEK_SET, &amp;libCurPosition); <br> <br>hres = pstm-&gt;Write(&amp;hdr, sizeof(hdr), NULL); <br> <br>return(hres); <br>} <br> <br> <br>STDMETHODIMP CSFView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CSFView::GetItemObject(UINT uItem, REFIID riid, <br>                LPVOID *ppv) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>int CSFView::AddObject(LPCITEMIDLIST pidl) <br>{ <br>// Check the commdlg hook to see if we should include this <br>// object. <br>if (IncludeObject(pidl) != S_OK) <br>{ <br>return(-1); <br>} <br> <br>return(m_cView.AddObject(pidl)); <br>} <br> <br> <br>int CALLBACK CSFView::CompareIDs(LPVOID p1, LPVOID p2, LPARAM lParam) <br>{ <br>PFNDPACOMPARE pfnCheckAPI = CompareIDs; <br> <br>CSFView *pThis = (CSFView *)lParam; <br> <br>HRESULT hres = pThis-&gt;m_psf-&gt;CompareIDs(pThis-&gt;m_sfState.lParamSort, <br>(LPITEMIDLIST)p1, (LPITEMIDLIST)p2); <br> <br> <br>return (hres); <br>} <br> <br>//***************************************************************************** <br>// <br>// CSFView::FillList <br>// <br>// Purpose: <br>// <br>//        Enumerates the objects in the namespace and fills up the <br>//        data structures <br>// <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br>HRESULT CSFView::FillList(BOOL bInteractive) <br>{ <br>m_cView.DeleteAllItems(); <br> <br>// Setup the enum flags. <br>DWORD dwEnumFlags = SHCONTF_NONFOLDERS; <br>if (ShowAllObjects()) <br>{ <br>dwEnumFlags |= SHCONTF_INCLUDEHIDDEN ; <br>} <br> <br>if (!(m_fs.fFlags &amp; FWF_NOSUBFOLDERS)) <br>{ <br>dwEnumFlags |= SHCONTF_FOLDERS; <br>} <br> <br>// Create an enum object and get the IEnumIDList ptr <br>LPENUMIDLIST peIDL; <br>HRESULT hres = m_psf-&gt;EnumObjects(bInteractive ? m_hwndMain : NULL, <br>dwEnumFlags, &amp;peIDL); <br> <br>// Note the return may be S_FALSE which indicates no enumerator. <br>// That's why we shouldn't use if (FAILED(hres)) <br>if (hres != S_OK) <br>{ <br>if (hres == S_FALSE) <br>{ <br>return(NOERROR); <br>} <br> <br>return(hres); <br>} <br>CEnsureRelease erEnum(peIDL); <br> <br>HDPA hdpaNew = DPA_Create(16); <br>if (!hdpaNew) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>LPITEMIDLIST pidl; <br>ULONG celt; <br> <br>// Enumerate the idlist and insert into the DPA <br> <br>while (peIDL-&gt;Next(1, &amp;pidl, &amp;celt) == S_OK) <br>{ <br>if (DPA_InsertPtr(hdpaNew, 0x7fff, pidl) == -1) <br>{ <br>m_cMalloc.Free(pidl); <br>} <br>} <br> <br>DPA_Sort(hdpaNew, CompareIDs, (LPARAM)this); <br> <br>int cNew = DPA_GetPtrCount(hdpaNew); <br>for (int i=0; i&lt;cNew; ++i) <br>{ <br>LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(hdpaNew, i); <br>if (AddObject(pidl) &lt; 0) <br>{ <br>m_cMalloc.Free(pidl); <br>} <br>} <br> <br>return(NOERROR); <br>} <br> <br> <br>//***************************************************************************** <br>// <br>// CSFView::AddColumns <br>// <br>// Purpose: <br>// <br>//        Adds columns to the contents pane listview <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br>void CSFView::AddColumns() <br>{ <br>UINT cxChar = m_cView.CharWidth(); <br> <br>// add columns to the listview in the contents pane <br>for (int i=0; ; ++i) <br>{ <br>SFVCB_GETDETAILSOF_DATA gdo; <br>gdo.pidl = NULL; <br> <br>// get the first column <br> <br>HRESULT hres = CallCB(SFVCB_GETDETAILSOF, i, (LPARAM)&amp;gdo); <br>if (hres != S_OK) <br>{ <br>if (i != 0) <br>{ <br>break; <br>} <br> <br>// If there is no first column, fake one up <br>gdo.fmt = LVCFMT_LEFT; <br>gdo.cChar = 40; <br>gdo.lParamSort = 0; <br>gdo.str.uType = STRRET_CSTR; <br>LoadString(g_ThisDll.GetInstance(), IDS_NAME, gdo.str.cStr, sizeof(gdo.str.cStr)); <br>} <br> <br>char szText[MAX_PATH]; <br>// init the column info for the details view ... <br>LV_COLUMN col; <br>col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; <br>col.fmt = gdo.fmt; <br>col.cx = gdo.cChar * cxChar; <br>col.pszText = szText; <br>col.cchTextMax = sizeof(szText); <br>col.iSubItem = i; <br> <br>StrRetToStr(szText, sizeof(szText), &amp;gdo.str, NULL); <br> <br>// insert the column into the list view <br>if (m_cView.InsertColumn(i, &amp;col)&gt;=0 &amp;&amp; m_aParamSort) <br>{ <br>DPA_InsertPtr(m_aParamSort, 0x7fff, (LPVOID)gdo.lParamSort); <br>} <br> <br>if (hres != S_OK) <br>{ <br>break; <br>} <br>} <br>} <br> <br> <br>// <br>// Save (and check) column header information <br>// Returns TRUE if the columns are the default width, FALSE otherwise <br>// Side effect: the stream pointer is left right after the last column <br>// <br>BOOL CSFView::SaveColumns(LPSTREAM pstm) <br>{ <br>UINT cxChar = m_cView.CharWidth(); <br>BOOL bDefaultCols = TRUE; <br> <br>for (int i=0; ; ++i) <br>{ <br>SFVCB_GETDETAILSOF_DATA gdo; <br>gdo.pidl = NULL; <br> <br>if (CallCB(SFVCB_GETDETAILSOF, i, (LPARAM)&amp;gdo) != S_OK) <br>{ <br>break; <br>} <br> <br>LV_COLUMN col; <br>col.mask = LVCF_WIDTH; <br> <br>if (!m_cView.GetColumn(i, &amp;col)) <br>{ <br>// There is some problem, so just assume <br>// default column widths <br>bDefaultCols = TRUE; <br>break; <br>} <br> <br>if (col.cx != (int)(gdo.cChar * cxChar)) <br>{ <br>bDefaultCols = FALSE; <br>} <br> <br>// HACK: I don't really care about column widths larger <br>// than 64K <br>if (FAILED(pstm-&gt;Write(&amp;col.cx, sizeof(USHORT), NULL))) <br>{ <br>// There is some problem, so just assume <br>// default column widths <br>bDefaultCols = TRUE; <br>break; <br>} <br>} <br> <br>return(bDefaultCols ? 0 : i); <br>} <br> <br> <br>void CSFView::RestoreColumns(LPSTREAM pstm, int nCols) <br>{ <br>for (int i=0; i&lt;nCols; ++i) <br>{ <br>LV_COLUMN col; <br>col.mask = LVCF_WIDTH; <br> <br>if (FAILED(pstm-&gt;Read(&amp;col.cx, sizeof(USHORT), NULL))) <br>{ <br>break; <br>} <br> <br>m_cView.SetColumn(i, &amp;col); <br>} <br>} <br> <br> <br>void CSFView::RestoreViewState() <br>{ <br>SFSTATE_HDR hdr; <br> <br>LPSTREAM pstm; <br>// get the stream for storing view specific info <br>if (FAILED(m_psb-&gt;GetViewStateStream(STGM_READ, &amp;pstm))) <br>{ <br>return; <br>} <br>CEnsureRelease erStr(pstm); <br> <br>if (FAILED(pstm-&gt;Read(&amp;hdr, sizeof(hdr), NULL))) <br>{ <br>return; <br>} <br> <br>// Validate the header <br>if (hdr.clsThis != CLSID_ThisDll) <br>{ <br>return; <br>} <br> <br> m_sfState = hdr.sfState; <br>RestoreColumns(pstm, hdr.nCols); <br> <br>MergeToolBar(); <br>} <br> <br> <br>void CSFView::CheckToolbar() <br>{ <br>UINT idCmdCurView = GetMenuIDFromViewMode(); <br> <br>for (UINT idCmd=IDC_VIEW_ICON; idCmd&lt;=IDC_VIEW_DETAILS; ++idCmd) <br>{ <br>m_psb-&gt;SendControlMsg(FCW_TOOLBAR, TB_CHECKBUTTON, idCmd, <br>(LPARAM)(idCmd == idCmdCurView), NULL); <br>} <br>} <br> <br> <br>void CSFView::MergeToolBar() <br>{ <br>enum <br>{ <br>IN_STD_BMP = 0x4000, <br>IN_VIEW_BMP = 0x8000, <br>} ; <br>static const TBBUTTON c_tbDefault[] = <br>{ <br>{ STD_COPY | IN_STD_BMP, IDC_EDIT_COPY, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, -1}, <br>{ 0,    0,    TBSTATE_ENABLED, TBSTYLE_SEP, {0,0}, 0, -1 }, <br>// the bitmap indexes here are relative to the view bitmap <br>{ VIEW_LARGEICONS | IN_VIEW_BMP, IDC_VIEW_ICON,        TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 }, <br>{ VIEW_SMALLICONS | IN_VIEW_BMP, IDC_VIEW_SMALLICON, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 }, <br>{ VIEW_LIST       | IN_VIEW_BMP, IDC_VIEW_LIST,         TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 }, <br>{ VIEW_DETAILS    | IN_VIEW_BMP, IDC_VIEW_DETAILS,      TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 }, <br>} ; <br> <br>LRESULT iStdBMOffset; <br>LRESULT iViewBMOffset; <br>TBADDBITMAP ab; <br>ab.hInst = HINST_COMMCTRL;// hinstCommctrl <br>ab.nID   = IDB_STD_SMALL_COLOR;// std bitmaps <br>m_psb-&gt;SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 8, (LPARAM)&amp;ab, &amp;iStdBMOffset); <br> <br>ab.nID   = IDB_VIEW_SMALL_COLOR;// std view bitmaps <br>m_psb-&gt;SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 8, (LPARAM)&amp;ab, &amp;iViewBMOffset); <br> <br>TBBUTTON tbActual[ARRAYSIZE(c_tbDefault)]; <br> <br>for (int i=0; i&lt;ARRAYSIZE(c_tbDefault); ++i) <br>{ <br>tbActual[i] = c_tbDefault[i]; <br>if (!(tbActual[i].fsStyle &amp; TBSTYLE_SEP)) <br>{ <br>if (tbActual[i].iBitmap &amp; IN_VIEW_BMP) <br>{ <br>tbActual[i].iBitmap = (tbActual[i].iBitmap &amp; ~IN_VIEW_BMP) + iViewBMOffset; <br>} <br>else if (tbActual[i].iBitmap &amp; IN_STD_BMP) <br>{ <br>tbActual[i].iBitmap = (tbActual[i].iBitmap &amp; ~IN_STD_BMP) + iStdBMOffset; <br>} <br>} <br>} <br> <br>m_psb-&gt;SetToolbarItems(tbActual, ARRAYSIZE(c_tbDefault), FCT_MERGE); <br> <br>CheckToolbar(); <br>} <br> <br> <br>HRESULT CreateShellFolderView(LPSHELLFOLDER psf, IShellFolderViewCallback *psfvcb, <br>LPSHELLVIEW * ppsv) <br>{ <br>CSFView *pSFView = new CSFView(psf, psfvcb); <br>if (!pSFView) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>pSFView-&gt;AddRef(); <br>HRESULT hRes = pSFView-&gt;QueryInterface(IID_IShellView, (LPVOID *)ppsv); <br>pSFView-&gt;Release(); <br> <br>return(hRes); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
