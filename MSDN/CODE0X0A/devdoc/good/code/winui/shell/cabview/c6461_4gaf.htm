<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FOLDER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6477"></a>FOLDER.CPP</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : folder.cpp <br>// <br>//CAB Files Shell Extension <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br> <br>#include "pch.h" <br> <br>#include "thisdll.h" <br>#include "thisguid.h" <br> <br>#include "SFView.H" <br>#include "folder.h" <br>#include "enum.h" <br>#include "view.h" <br>#include "icon.h" <br>#include "menu.h" <br>#include "dataobj.h" <br> <br>#include "cabitms.h" <br> <br>// *** IUnknown methods *** <br>STDMETHODIMP CCabFolder::QueryInterface( <br>   REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>*ppvObj = NULL; <br> <br>LPVOID pObj; <br>  <br>if (riid == IID_IUnknown) <br>{ <br>pObj = (IUnknown*)((IShellFolder*)this);  <br>// The (IShellFolder*) ^^^ up there is to disambiguate :) the reference <br>} <br>else if (riid == IID_IShellFolder) <br>{ <br>pObj = (IShellFolder*)this; <br>} <br>else if (riid == IID_IPersistFolder) <br>{ <br>pObj = (IPersistFolder*)this; <br>} <br>else <br>{ <br>   return(E_NOINTERFACE); <br>} <br> <br>((LPUNKNOWN)pObj)-&gt;AddRef(); <br>*ppvObj = pObj; <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CCabFolder::AddRef(void) <br>{ <br>return(m_cRef.AddRef()); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CCabFolder::Release(void) <br>{ <br>if (!m_cRef.Release()) <br>{ <br>   delete this; <br>return(0); <br>} <br> <br>return(m_cRef.GetRef()); <br>} <br> <br>// *** IParseDisplayName method *** <br>STDMETHODIMP CCabFolder::ParseDisplayName( <br>   HWND hwndOwner, <br>   LPBC pbc,  <br>   LPOLESTR lpszDisplayName, <br>   ULONG FAR* pchEaten,  <br>   LPITEMIDLIST * ppidl, <br>   ULONG *pdwAttributes) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>// *** IOleContainer methods *** <br>//********************************************************************** <br>// <br>// CCabFolder::EnumObjects <br>// <br>// Purpose: <br>// <br>//      Creates an item enumeration object  <br>//      (an IEnumIDList interface) that can be used to  <br>//      enumerate the contents of a folder. <br>// <br>// Parameters: <br>// <br>//       HWND hwndOwner       -    handle to the owner window <br>//       DWORD grFlags        -    flags about which items to include <br>//       LPENUMIDLIST *ppenumIDList - address that receives IEnumIDList <br>//                                    interface pointer  <br>// <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CCabFolder::EnumObjects( <br>   HWND hwndOwner,  <br>   DWORD grfFlags, <br>   LPENUMIDLIST * ppenumIDList) // LPENUMUNKNOWN FAR* ppenumUnknown) <br>{ <br>CEnumCabObjs *pce = new CEnumCabObjs(this, grfFlags); <br>if (!pce) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>pce-&gt;AddRef(); <br>HRESULT hRes = pce-&gt;QueryInterface(IID_IEnumIDList, (LPVOID*)ppenumIDList); <br>pce-&gt;Release(); <br> <br>return(hRes); <br>} <br> <br>// *** IShellFolder methods *** <br>// subfolders not implemented <br>STDMETHODIMP CCabFolder::BindToObject( <br>   LPCITEMIDLIST pidl,  <br>   LPBC pbc, <br>   REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabFolder::BindToStorage( <br>   LPCITEMIDLIST pidl,  <br>   LPBC pbc, <br>   REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CCabFolder::CompareIDs <br>// <br>// Purpose: <br>// <br>//      Determines the relative ordering of two file <br>//      objects or folders, given their item identifier lists <br>// <br>// Parameters: <br>// <br>//      LPARAM lParam         -    type of comparison <br>//      LPCITEMIDLIST pidl1   -    address to ITEMIDLIST <br>//      LPCITEMIDLIST pidl2   -    address to ITEMIDLIST <br>// <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CCabFolder::CompareIDs( <br>   LPARAM lParam,  <br>   LPCITEMIDLIST pidl1, <br>   LPCITEMIDLIST pidl2) <br>{ <br>LPCABITEM pit1 = (LPCABITEM)pidl1; <br>LPCABITEM pit2 = (LPCABITEM)pidl2; <br> <br>short nCmp = 0; <br> <br>switch (lParam) <br>{ <br>case CV_COL_NAME: <br>break; <br> <br>case CV_COL_SIZE: <br>if (pit1-&gt;dwFileSize &lt; pit2-&gt;dwFileSize) <br>{ <br>nCmp = -1; <br>} <br>else if (pit1-&gt;dwFileSize &gt; pit2-&gt;dwFileSize) <br>{ <br>nCmp = 1; <br>} <br>break; <br> <br>case CV_COL_TYPE: <br>{ <br>STRRET srName1, srName2; <br> <br>GetTypeOf(pit1, &amp;srName1); <br>GetTypeOf(pit2, &amp;srName2); <br> <br>nCmp = (SHORT)lstrcmp(srName1.cStr, srName2.cStr); <br>break; <br>} <br> <br>case CV_COL_MODIFIED: <br>FILETIME ft1, ft2; <br> <br>DosDateTimeToFileTime(pit1-&gt;uFileDate, pit1-&gt;uFileTime, &amp;ft1); <br>DosDateTimeToFileTime(pit2-&gt;uFileDate, pit2-&gt;uFileTime, &amp;ft2); <br> <br>nCmp = (SHORT)CompareFileTime(&amp;ft1, &amp;ft2); <br>break; <br> <br>default: <br>break; <br>} <br> <br>if (nCmp != 0) <br>{ <br>return(ResultFromShort(nCmp)); <br>} <br> <br>return(ResultFromShort(lstrcmpi(pit1-&gt;szName, pit2-&gt;szName))); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CCabFolder::CreateViewObject <br>// <br>// Purpose: <br>// <br>//      IShellbrowser calls this to create a ShellView   <br>//      object <br>// <br>// Parameters: <br>// <br>//      HWND   hwndOwner     - <br>//    <br>//      REFIID riid          -  interface ID <br>// <br>//      LPVOID * ppvObj      -  pointer to the Shellview object <br>// <br>// Return Value: <br>// <br>//      NOERROR <br>//      E_OUTOFMEMORY <br>//      E_NOINTERFACE <br>// <br>// <br>// Comments: <br>// <br>//      ShellBrowser interface calls this to request the ShellFolder <br>//      to create a ShellView object <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CCabFolder::CreateViewObject( <br>   HWND hwndOwner,  <br>   REFIID riid, <br>   LPVOID FAR* ppvObj) <br>{ <br>IUnknown *pObj = NULL; <br> <br>if (riid == IID_IShellView) <br>{ <br> <br>// Create a call back for the ShellView <br> <br>IShellFolderViewCallback *pcb; <br>HRESULT hRes = CabView_CreateCallback(&amp;pcb); <br> <br>hRes = CreateShellFolderView(this, pcb, (LPSHELLVIEW FAR*)&amp;pObj); <br>if (pcb) <br>{ <br>// The ShellFolderView should have AddRef'ed if it needed it. <br>pcb-&gt;Release(); <br>} <br> <br>if (FAILED(hRes)) <br>{ <br>return(hRes); <br>} <br>} <br>else <br>{ <br>return(E_NOINTERFACE); <br>} <br> <br>if (!pObj) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>// The ref count is already 1 <br>HRESULT hRes = pObj-&gt;QueryInterface(riid, ppvObj); <br>pObj-&gt;Release(); <br> <br>return(NOERROR); <br>} <br> <br> <br>// ************************************************************************************** <br>// <br>// CCabFolder::GetAttributesOf <br>// <br>// Purpose <br>// <br>//Retrieves attributes of one of more file objects <br>// <br>// Parameters: <br>// <br>//    UINT cidl                -    number of file objects <br>//    LPCITEMIDLIST  *apidl    -    pointer to array of ITEMIDLIST <br>//    ULONG *rgfInOut          -    array of values that specify file object <br>//                                  attributes <br>// <br>// <br>// Return Value: <br>//     <br>//     NOERROR <br>// <br>//Comments <br>// <br>// *************************************************************************************** <br> <br>STDMETHODIMP CCabFolder::GetAttributesOf( <br>   UINT cidl,  <br>   LPCITEMIDLIST FAR* apidl, <br>   ULONG FAR* rgfInOut) <br>{ <br>*rgfInOut &amp;= SFGAO_CANCOPY; <br> <br>return(NOERROR); <br>} <br> <br>// ************************************************************************************** <br>// <br>// CCabFolder::GetUIObjectOf <br>// <br>// Purpose <br>// <br>//Returns an interface that can be used to carry out actions on  <br>//          the specified file objects or folders <br>// <br>// Parameters: <br>//         <br>//        HWND hwndOwner        -    handle of the Owner window <br>// <br>//        UINT cidl             -    Number of file objects <br>//         <br>//        LPCITEMIDLIST *apidl  -    array of file object pidls <br>// <br>//        REFIID                -    Identifier of interface to return <br>//         <br>//        UINT * prgfInOut      -    reserved <br>// <br>//        LPVOID *ppvObj        -    address that receives interface pointer <br>// <br>// Return Value: <br>//         <br>//         E_INVALIDARG <br>//         E_NOINTERFACE <br>//         E_OUTOFMEMORY <br>// <br>//Comments <br>// *************************************************************************************** <br> <br>STDMETHODIMP CCabFolder::GetUIObjectOf( <br>   HWND hwndOwner,  <br>   UINT cidl,  <br>   LPCITEMIDLIST FAR* apidl,  <br>   REFIID riid,  <br>   UINT FAR* prgfInOut,  <br>   LPVOID FAR* ppvObj) <br>{ <br>LPUNKNOWN pObj = NULL; <br> <br>if (riid == IID_IExtractIcon) <br>{ <br>if (cidl != 1) <br>{ <br>return(E_INVALIDARG); <br>} <br> <br>LPCABITEM pci = (LPCABITEM)*apidl; <br>pObj = (LPUNKNOWN)(IExtractIcon *)(new CCabItemIcon(pci-&gt;szName)); <br>} <br>else if (riid == IID_IContextMenu) <br>{ <br>if (cidl &lt; 1) <br>{ <br>return(E_INVALIDARG); <br>} <br> <br>pObj = (LPUNKNOWN)(IContextMenu *)(new CCabItemMenu(hwndOwner, this, <br>(LPCABITEM *)apidl, cidl)); <br>} <br>else if (riid == IID_IDataObject) <br>{ <br>if (cidl &lt; 1) <br>{ <br>return(E_INVALIDARG); <br>} <br> <br>pObj = (LPUNKNOWN)(IDataObject *)(new CCabObj(hwndOwner, this, <br>(LPCABITEM *)apidl, cidl)); <br>} <br>else <br>{ <br>return(E_NOINTERFACE); <br>} <br> <br>if (!pObj) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>pObj-&gt;AddRef(); <br>HRESULT hRes = pObj-&gt;QueryInterface(riid, ppvObj); <br>pObj-&gt;Release(); <br> <br>return(hRes); <br>} <br> <br>//***************************************************************************** <br>// <br>// CCabFolder::GetDisplayNameOf <br>// <br>// Purpose: <br>//        Retrieves the display name for the specified file object or  <br>//        subfolder. <br>// <br>// <br>// Parameters: <br>// <br>//        LPCITEMIDLIST    pidl    -    pidl of the file object <br>//        DWORD  dwReserved        -    Value of the type of display name to  <br>//                                      return <br>//        LPSTRRET  lpName         -    address holding the name returned         <br>// <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br> <br>STDMETHODIMP CCabFolder::GetDisplayNameOf( <br>   LPCITEMIDLIST pidl,  <br>   DWORD dwReserved,  <br>   LPSTRRET lpName) <br>{ <br>LPCABITEM pit = (LPCABITEM)pidl; <br> <br>GetNameOf(pit, lpName); <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP CCabFolder::SetNameOf( <br>   HWND hwndOwner,  <br>   LPCITEMIDLIST pidl, <br>   LPCOLESTR lpszName,  <br>   DWORD dwReserved, <br>   LPITEMIDLIST FAR* ppidlOut) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br>  // *** IPersist methods *** <br>//********************************************************************** <br>// <br>// CCabFolder::GetClassID <br>// <br>// Purpose: <br>// <br>//      Return the class id <br>// <br>// Parameters: <br>// <br>//      LPCLSID lpClassID       -   pointer to the ClassID member <br>// <br>// Return Value: <br>// <br>//      NOERROR <br>// <br>// <br>// Comments: <br>// <br>//      This routine returns the Class ID for the DLL <br>// <br>//******************************************************************** <br> <br> <br>STDMETHODIMP CCabFolder::GetClassID( <br>   LPCLSID lpClassID) <br>{ <br>*lpClassID = CLSID_ThisDll; <br>return NOERROR; <br>} <br> <br> <br>// *** IPersistFolder methods *** <br>//********************************************************************** <br>// <br>// CCabFolder::Initialize folder <br>// <br>// Purpose: <br>// <br>//      Explorer calls this while initializing the ShellFolder  <br>//      object <br>// <br>// Parameters: <br>// <br>//      LPCITEMIDLIST pidl-   pidl passed by IShellBrowser <br>// <br>// Return Value: <br>// <br>//      S_OK <br>// <br>// <br>// Comments: <br>// <br>//      This routine is called by Explorer during initialization <br>// <br>//******************************************************************** <br> <br> <br>STDMETHODIMP CCabFolder::Initialize( <br>   LPCITEMIDLIST pidl) <br>{ <br>if (m_pidlHere) <br>{ <br>ILFree(m_pidlHere); <br>} <br> <br>// Clone the pidl passed by the explorer <br> <br>m_pidlHere = ILClone(pidl); <br>if (!m_pidlHere) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>return(S_OK); <br>} <br> <br>//***************************************************************************** <br>// <br>// CCabFolder::CreateIDList <br>// <br>// Purpose: <br>// <br>//    Creates an item identifier list for the objects in the namespace <br>// <br>// <br>//***************************************************************************** <br> <br>LPITEMIDLIST CCabFolder::CreateIDList(LPCSTR pszName, DWORD dwFileSize, <br>UINT uFileDate, UINT uFileTime, UINT uFileAttribs) <br>{ <br>// We'll assume no name is longer than MAX_PATH <br>// Note the terminating NULL is already in the sizeof(CABITEM) <br>BYTE bBuf[sizeof(CABITEM) + MAX_PATH + sizeof(WORD)]; <br>LPCABITEM pci = (LPCABITEM)bBuf; <br> <br>UINT uNameLen = lstrlen(pszName); <br>if (uNameLen &gt;= MAX_PATH) <br>{ <br>uNameLen = MAX_PATH; <br>} <br> <br>pci-&gt;wSize = (WORD)(sizeof(CABITEM) + uNameLen); <br>pci-&gt;dwFileSize = dwFileSize; <br>pci-&gt;uFileDate = (USHORT)uFileDate; <br>pci-&gt;uFileTime = (USHORT)uFileTime; <br>pci-&gt;uFileAttribs = (USHORT)uFileAttribs; <br>lstrcpyn(pci-&gt;szName, pszName, uNameLen+1); <br> <br>// Terminate the IDList <br>*(WORD *)(((LPSTR)pci)+pci-&gt;wSize) = 0; <br> <br>return(ILClone((LPCITEMIDLIST)pci)); <br>} <br> <br>//***************************************************************************** <br>// <br>// CCabFolder::GetPath <br>// <br>// Purpose: <br>//     <br>//        Get the Path for the current pidl <br>// <br>// Parameters: <br>//    <br>//        LPSTR szPath        -    return pointer for path string <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br>BOOL CCabFolder::GetPath(LPSTR szPath) <br>{ <br>if (!m_pidlHere || !SHGetPathFromIDList(m_pidlHere, szPath)) <br>{ <br>*szPath = '\0'; <br>return(FALSE); <br>} <br> <br>return(TRUE); <br>} <br> <br> <br>void CCabFolder::GetNameOf(LPCABITEM pit, LPSTRRET lpName) <br>{ <br>lpName-&gt;uType = STRRET_OFFSET; <br>lpName-&gt;uOffset = FIELDOFFSET(CABITEM, szName); <br> <br>SHFILEINFO sfi; <br> <br>if (SHGetFileInfo(pit-&gt;szName, 0, &amp;sfi, sizeof(sfi), <br>SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME) <br>&amp;&amp; lstrcmp(sfi.szDisplayName, pit-&gt;szName) != 0) <br>{ <br>lpName-&gt;uType = STRRET_CSTR; <br>lstrcpy(lpName-&gt;cStr, sfi.szDisplayName); <br>} <br>} <br> <br> <br>void CCabFolder::GetTypeOf(LPCABITEM pit, LPSTRRET lpName) <br>{ <br>lpName-&gt;uType = STRRET_CSTR; <br>lpName-&gt;cStr[0] = '\0'; <br> <br>SHFILEINFO sfi; <br> <br>if (SHGetFileInfo(pit-&gt;szName, 0, &amp;sfi, sizeof(sfi), <br>SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME)) <br>{ <br>lstrcpy(lpName-&gt;cStr, sfi.szTypeName); <br>} <br>} <br>//***************************************************************************** <br>// <br>// CCabFolder::EnumToList <br>// <br>// Purpose: <br>// <br>//       This notify callback is called by the FDI routines. It adds the <br>//       file object from the cab file to the list.   <br>// <br>// Parameters: <br>// <br>// <br>// <br>// Comments: <br>// <br>//***************************************************************************** <br> <br> <br>void CALLBACK CCabFolder::EnumToList(LPCSTR pszFile, DWORD dwSize, UINT date, <br>UINT time, UINT attribs, LPARAM lParam) <br>{ <br>CCabFolder *pThis = (CCabFolder *)lParam; <br> <br>pThis-&gt;m_lItems.AddItem(pszFile, dwSize, date, time, attribs); <br>} <br> <br> <br>HRESULT CCabFolder::InitItems() <br>{ <br>switch (m_lItems.GetState()) <br>{ <br>case CCabItemList::State_Init: <br>return(NOERROR); <br> <br>case CCabItemList::State_OutOfMem: <br>return(E_OUTOFMEMORY); <br> <br>case CCabItemList::State_UnInit: <br>default: <br>break; <br>} <br> <br>// Force the list to initialize <br>m_lItems.InitList(); <br> <br>char szHere[MAX_PATH]; <br> <br>// the m_pidl has been set to current dir <br>// get the path to the current directory <br>if (!GetPath(szHere)) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>CCabItems ciHere(szHere); <br> <br>if (!ciHere.EnumItems(EnumToList, (LPARAM)this)) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>return(NOERROR); <br>} <br> <br>//******************************************************************************************* <br>// <br>// CreateInstance <br>// <br>// Purpose: <br>// <br>//Create a CCabFolder object and returns it <br>// <br>// Parameters: <br>//REFIID riid-a reference to the interface that is <br>//being queried <br>// <br>//LPVOID *ppvObj-an out parameter to return a pointer to <br>//interface being queried <br>// <br>//******************************************************************************************* <br> <br>HRESULT CreateInstance(REFIID riid, LPVOID *ppvObj) <br>{ <br>IUnknown *pObj = NULL; <br>*ppvObj = NULL; <br> <br>if(riid == IID_IPersistFolder) <br>{ <br>pObj = (IUnknown *)(IPersistFolder *)(new CCabFolder); <br>} <br>else if(riid == IID_IShellFolder) <br>{ <br>pObj = (IUnknown *)(IShellFolder *)(new CCabFolder); <br>} <br>else <br>{ <br>return(E_NOINTERFACE); <br>} <br> <br>if (!pObj) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>pObj-&gt;AddRef(); <br>HRESULT hRes = pObj-&gt;QueryInterface(riid, ppvObj); <br>pObj-&gt;Release(); <br> <br>return(hRes); <br>} <br> <br> <br>UINT CCabItemList::GetState() <br>{ <br>if (m_uStep == 0) <br>{ <br>if (m_dpaList) <br>{ <br>return(State_Init); <br>} <br> <br>return(State_OutOfMem); <br>} <br> <br>return(State_UnInit); <br>} <br> <br> <br>BOOL CCabItemList::StoreItem(LPITEMIDLIST pidl) <br>{ <br>if (pidl) <br>{ <br>if (InitList() &amp;&amp; DPA_InsertPtr(m_dpaList, 0x7fff, (LPSTR)pidl)&gt;=0) <br>{ <br>return(TRUE); <br>} <br> <br>ILFree(pidl); <br>} <br> <br>CleanList(); <br>return(FALSE); <br>} <br> <br> <br>BOOL CCabItemList::AddItems(LPCABITEM *apit, UINT cpit) <br>{ <br>for (UINT i=0; i&lt;cpit; ++i) <br>{ <br>if (!StoreItem(ILClone((LPCITEMIDLIST)apit[i]))) <br>{ <br>return(FALSE); <br>} <br>} <br> <br>return(TRUE); <br>} <br> <br> <br>BOOL CCabItemList::AddItem(LPCSTR pszName, DWORD dwFileSize, <br>UINT uFileDate, UINT uFileTime, UINT uFileAttribs) <br>{ <br>return(StoreItem(CCabFolder::CreateIDList(pszName, dwFileSize, uFileDate, uFileTime, <br>uFileAttribs))); <br>} <br> <br> <br>int CCabItemList::FindInList(LPCSTR pszName, DWORD dwFileSize, <br>UINT uFileDate, UINT uFileTime, UINT uFileAttribs) <br>{ <br>// TODO: Linear search for now; binary later <br>for (int i=DPA_GetPtrCount(m_dpaList)-1; i&gt;=0; --i) <br>{ <br>if (lstrcmpi(pszName, (*this)[i]-&gt;szName) == 0) <br>{ <br>break; <br>} <br>} <br> <br>return(i); <br>} <br> <br> <br>BOOL CCabItemList::InitList() <br>{ <br>switch (GetState()) <br>{ <br>case State_Init: <br>return(TRUE); <br> <br>case State_OutOfMem: <br>return(FALSE); <br> <br>case State_UnInit: <br>default: <br>m_dpaList = DPA_Create(m_uStep); <br>m_uStep = 0; <br> <br>return(InitList()); <br>} <br>} <br> <br> <br>void CCabItemList::CleanList() <br>{ <br>if (m_uStep != 0) <br>{ <br>m_dpaList = NULL; <br>m_uStep = 0; <br>return; <br>} <br> <br>if (!m_dpaList) <br>{ <br>return; <br>} <br> <br>for (int i=DPA_GetPtrCount(m_dpaList)-1; i&gt;=0; --i) <br>{ <br>ILFree((LPITEMIDLIST)((*this)[i])); <br>} <br> <br>DPA_Destroy(m_dpaList); <br>m_dpaList = NULL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
