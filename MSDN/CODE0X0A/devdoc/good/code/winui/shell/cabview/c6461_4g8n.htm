<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DATAOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6467"></a>DATAOBJ.CPP</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : DataObj.cpp <br>// <br>//Implementation file for CObjFormats and CCabObj <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br>#include "pch.h" <br> <br>#include "thisdll.h" <br> <br>#include "folder.h" <br>#include "dataobj.h" <br> <br>#include "cabitms.h" <br> <br>UINT CCabObj::s_uFileGroupDesc = 0; <br>UINT CCabObj::s_uFileContents = 0; <br> <br> <br>class CObjFormats : public IEnumFORMATETC <br>{ <br>public: <br>CObjFormats(UINT cfmt, const FORMATETC afmt[]); <br>~CObjFormats(); <br> <br>    // *** IUnknown methods *** <br>    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj); <br>    STDMETHODIMP_(ULONG) AddRef(); <br>    STDMETHODIMP_(ULONG) Release(); <br> <br>    // *** IEnumFORMATETC methods *** <br>    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed); <br>    STDMETHODIMP Skip(ULONG celt); <br>    STDMETHODIMP Reset(); <br>    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum); <br> <br>private: <br>CRefCount m_cRef; <br> <br>CRefDll m_cRefDll; <br> <br>UINT m_iFmt; <br>UINT m_cFmt; <br>FORMATETC *m_aFmt; <br>} ; <br> <br> <br>CObjFormats::CObjFormats(UINT cfmt, const FORMATETC afmt[]) <br>{ <br>m_iFmt = 0; <br>m_cFmt = cfmt; <br>m_aFmt = new FORMATETC[cfmt]; <br> <br>if (m_aFmt) <br>{ <br>CopyMemory(m_aFmt, afmt, cfmt*sizeof(afmt[0])); <br>} <br>} <br> <br> <br>CObjFormats::~CObjFormats() <br>{ <br>if (m_aFmt) <br>{ <br>delete m_aFmt; <br>} <br>} <br> <br> <br>// *** IUnknown methods *** <br>STDMETHODIMP CObjFormats::QueryInterface( <br>   REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>*ppvObj = NULL; <br> <br>if (!m_aFmt) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>LPUNKNOWN pObj; <br>  <br>if (riid == IID_IUnknown) <br>{ <br>pObj = (IUnknown*)((IEnumFORMATETC*)this);  <br>} <br>else if (riid == IID_IEnumFORMATETC) <br>{ <br>pObj = (IUnknown*)((IEnumFORMATETC*)this);  <br>} <br>else <br>{ <br>   return(E_NOINTERFACE); <br>} <br> <br>pObj-&gt;AddRef(); <br>*ppvObj = pObj; <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CObjFormats::AddRef(void) <br>{ <br>return(m_cRef.AddRef()); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CObjFormats::Release(void) <br>{ <br>if (!m_cRef.Release()) <br>{ <br>   delete this; <br>return(0); <br>} <br> <br>return(m_cRef.GetRef()); <br>} <br> <br> <br>STDMETHODIMP CObjFormats::Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed) <br>{ <br>UINT cfetch; <br>HRESULT hres = S_FALSE;// assume less numbers <br> <br>if (m_iFmt &lt; m_cFmt) <br>{ <br>cfetch = m_cFmt - m_iFmt; <br>if (cfetch &gt;= celt) <br>{ <br>cfetch = celt; <br>hres = S_OK; <br>} <br> <br>CopyMemory(rgelt, &amp;m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC)); <br>m_iFmt += cfetch; <br>} <br>else <br>{ <br>cfetch = 0; <br>} <br> <br>if (pceltFethed) <br>{ <br>*pceltFethed = cfetch; <br>} <br> <br>return hres; <br>} <br> <br>STDMETHODIMP CObjFormats::Skip(ULONG celt) <br>{ <br>m_iFmt += celt; <br>if (m_iFmt &gt; m_cFmt) <br>{ <br>m_iFmt = m_cFmt; <br>return S_FALSE; <br>} <br>return S_OK; <br>} <br> <br>STDMETHODIMP CObjFormats::Reset() <br>{ <br>m_iFmt = 0; <br>return S_OK; <br>} <br> <br>STDMETHODIMP CObjFormats::Clone(IEnumFORMATETC ** ppenum) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br>CCabObj::CCabObj(HWND hwndOwner, CCabFolder *pcf, LPCABITEM *apit, UINT cpit) <br>: m_lSel(8), m_lContents(NULL) <br>{ <br>m_pcfHere = pcf; <br>pcf-&gt;AddRef(); <br> <br>m_hwndOwner = hwndOwner; <br>m_lSel.AddItems(apit, cpit); <br>} <br> <br> <br>CCabObj::~CCabObj() <br>{ <br>m_pcfHere-&gt;Release(); <br>} <br> <br> <br>// *** IUnknown methods *** <br>STDMETHODIMP CCabObj::QueryInterface( <br>   REFIID riid,  <br>   LPVOID FAR* ppvObj) <br>{ <br>*ppvObj = NULL; <br> <br>if (m_lSel.GetState() == CCabItemList::State_OutOfMem) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>LPUNKNOWN pObj; <br>  <br>if (riid == IID_IUnknown) <br>{ <br>pObj = (IUnknown*)((IDataObject*)this);  <br>} <br>else if (riid == IID_IDataObject) <br>{ <br>pObj = (IUnknown*)((IDataObject*)this);  <br>} <br>else <br>{ <br>   return(E_NOINTERFACE); <br>} <br> <br>pObj-&gt;AddRef(); <br>*ppvObj = pObj; <br> <br>return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CCabObj::AddRef(void) <br>{ <br>return(m_cRef.AddRef()); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CCabObj::Release(void) <br>{ <br>if (!m_cRef.Release()) <br>{ <br>   delete this; <br>return(0); <br>} <br> <br>return(m_cRef.GetRef()); <br>} <br> <br> <br>STDMETHODIMP CCabObj::GetData(FORMATETC *pfmt, STGMEDIUM *pmedium) <br>{ <br>if (!InitFileGroupDesc()) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>if (pfmt-&gt;cfFormat == s_uFileGroupDesc) <br>{ <br>if (pfmt-&gt;ptd==NULL &amp;&amp; (pfmt-&gt;dwAspect&amp;DVASPECT_CONTENT) &amp;&amp; pfmt-&gt;lindex==-1 <br>&amp;&amp; (pfmt-&gt;tymed&amp;TYMED_HGLOBAL)) <br>{ <br>int cItems = m_lSel.GetCount(); <br>if (cItems &lt; 1) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalAlloc(GMEM_FIXED, <br>sizeof(FILEGROUPDESCRIPTOR) + (cItems-1)*sizeof(FILEDESCRIPTOR)); <br>if (!pfgd) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>pfgd-&gt;cItems = cItems; <br>for (--cItems; cItems&gt;=0; --cItems) <br>{ <br>LPCABITEM pItem = m_lSel[cItems]; <br> <br>pfgd-&gt;fgd[cItems].dwFlags = FD_ATTRIBUTES|FD_WRITESTIME|FD_FILESIZE; <br>pfgd-&gt;fgd[cItems].dwFileAttributes = pItem-&gt;uFileAttribs; <br>DosDateTimeToFileTime(pItem-&gt;uFileDate, pItem-&gt;uFileTime, <br>&amp;pfgd-&gt;fgd[cItems].ftLastWriteTime); <br>pfgd-&gt;fgd[cItems].nFileSizeHigh = 0; <br>pfgd-&gt;fgd[cItems].nFileSizeLow  = pItem-&gt;dwFileSize; <br>lstrcpyn(pfgd-&gt;fgd[cItems].cFileName, pItem-&gt;szName, <br>sizeof(pfgd-&gt;fgd[cItems].cFileName)); <br>} <br> <br>pmedium-&gt;tymed = TYMED_HGLOBAL; <br>pmedium-&gt;hGlobal = (HGLOBAL)pfgd; <br>pmedium-&gt;pUnkForRelease = NULL; <br> <br>return(NOERROR); <br>} <br> <br>return(E_INVALIDARG); <br>} <br> <br>if (!InitFileContents()) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>if (pfmt-&gt;cfFormat == s_uFileContents) <br>{ <br>if (pfmt-&gt;ptd==NULL &amp;&amp; (pfmt-&gt;dwAspect&amp;DVASPECT_CONTENT) <br>&amp;&amp; (pfmt-&gt;tymed&amp;TYMED_HGLOBAL)) <br>{ <br>int cItems = m_lSel.GetCount(); <br>if (pfmt-&gt;lindex &gt;= cItems) <br>{ <br>return(E_INVALIDARG); <br>} <br> <br>HRESULT hRes = InitContents(); <br>if (FAILED(hRes)) <br>{ <br>return(hRes); <br>} <br> <br>if (!m_lContents[pfmt-&gt;lindex]) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>// TODO: Maybe if we run out of memory I will just return an IStream for each <br>// file and take the time hit to extract each one separately <br>pmedium-&gt;tymed = TYMED_HGLOBAL; <br>pmedium-&gt;hGlobal = m_lContents[pfmt-&gt;lindex]; <br>// We will delete these globals when we go away <br>pmedium-&gt;pUnkForRelease = (IDataObject*)this; <br>AddRef(); <br> <br>return(NOERROR); <br>} <br> <br>return(E_INVALIDARG); <br>} <br> <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabObj::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabObj::QueryGetData(FORMATETC *pfmt) <br>{ <br>if (!InitFileGroupDesc()) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>if (pfmt-&gt;cfFormat == s_uFileGroupDesc) <br>{ <br>if (pfmt-&gt;ptd==NULL &amp;&amp; (pfmt-&gt;dwAspect&amp;DVASPECT_CONTENT) &amp;&amp; pfmt-&gt;lindex==-1 <br>&amp;&amp; (pfmt-&gt;tymed&amp;TYMED_HGLOBAL)) <br>{ <br>return(S_OK); <br>} <br> <br>return(E_INVALIDARG); <br>} <br> <br>if (!InitFileContents()) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>if (pfmt-&gt;cfFormat == s_uFileContents) <br>{ <br>if (pfmt-&gt;ptd==NULL &amp;&amp; (pfmt-&gt;dwAspect&amp;DVASPECT_CONTENT) <br>&amp;&amp; (pfmt-&gt;tymed&amp;TYMED_HGLOBAL)) <br>{ <br>return(S_OK); <br>} <br> <br>return(E_INVALIDARG); <br>} <br> <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabObj::GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabObj::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabObj::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc) <br>{ <br>if (!InitFileGroupDesc() || !InitFileContents()) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>    FORMATETC fmte[] = { <br>        {(USHORT)s_uFileContents,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }, <br>        {(USHORT)s_uFileGroupDesc, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }, <br>    }; <br> <br>CObjFormats *pFmts = new CObjFormats(2, fmte); <br>if (!pFmts) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>pFmts-&gt;AddRef(); <br>HRESULT hRes = pFmts-&gt;QueryInterface(IID_IEnumFORMATETC, (LPVOID *)ppenumFormatEtc); <br>pFmts-&gt;Release(); <br> <br>return(hRes); <br>} <br> <br> <br>STDMETHODIMP CCabObj::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, <br>DWORD *pdwConnection) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabObj::DUnadvise(DWORD dwConnection) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP CCabObj::EnumDAdvise(IEnumSTATDATA **ppenumAdvise) <br>{ <br>return(E_NOTIMPL); <br>} <br> <br> <br>BOOL CCabObj::InitFileGroupDesc() <br>{ <br>if (s_uFileGroupDesc) <br>{ <br>return(TRUE); <br>} <br> <br>s_uFileGroupDesc = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR); <br>return(s_uFileGroupDesc != 0); <br>} <br> <br> <br>BOOL CCabObj::InitFileContents() <br>{ <br>if (s_uFileContents) <br>{ <br>return(TRUE); <br>} <br> <br>s_uFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS); <br>return(s_uFileContents != 0); <br>} <br> <br> <br>HGLOBAL * CALLBACK CCabObj::ShouldExtract(LPCSTR pszFile, DWORD dwSize, UINT date, <br>UINT time, UINT attribs, LPARAM lParam) <br>{ <br>CCabObj *pThis = (CCabObj*)lParam; <br> <br>int iItem = pThis-&gt;m_lSel.FindInList(pszFile, dwSize, date, time, attribs); <br>if (iItem &lt; 0) <br>{ <br>return(EXTRACT_FALSE); <br>} <br> <br>// Copy nothing for now <br>return(&amp;(pThis-&gt;m_lContents[iItem])); <br>} <br> <br> <br>HRESULT CCabObj::InitContents() <br>{ <br>if (m_lContents) <br>{ <br>return(NOERROR); <br>} <br> <br>int iCount = m_lSel.GetCount(); <br>if (iCount &lt; 1) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>m_lContents = (HGLOBAL *)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, <br>sizeof(HGLOBAL)*m_lSel.GetCount()); <br>if (!m_lContents) <br>{ <br>return(E_OUTOFMEMORY); <br>} <br> <br>char szHere[MAX_PATH]; <br>if (!m_pcfHere-&gt;GetPath(szHere)) <br>{ <br>return(E_UNEXPECTED); <br>} <br> <br>CCabExtract ceHere(szHere); <br> <br>ceHere.ExtractItems(m_hwndOwner, DIR_MEM, ShouldExtract, (LPARAM)this); <br> <br>return(TRUE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
