<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PATH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context6487"></a>PATH.C</h2>
<pre><code>//******************************************************************************************* <br>// <br>// Filename : Path.c <br>// <br>//Useful Path manipulation routines <br>// <br>// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved <br>// <br>//******************************************************************************************* <br> <br>#include "pch.h" <br>#include "path.h" <br>#include "debug.h" <br>#include "strings.h" <br> <br>// <br>// Inline function to check for a double-backslash at the <br>// beginning of a string <br>// <br> <br>__inline BOOL DBL_BSLASH(LPCTSTR psz) <br>{ <br>    return (psz[0] == TEXT('\\') &amp;&amp; psz[1] == TEXT('\\')); <br>} <br> <br>// returns a pointer to the extension of a file. <br>// <br>// in: <br>//      qualified or unqualfied file name <br>// <br>// returns: <br>//      pointer to the extension of this file.  if there is no extension <br>//      as in "foo" we return a pointer to the NULL at the end <br>//      of the file <br>// <br>//      foo.txt     ==&gt; ".txt" <br>//      foo         ==&gt; "" <br>//      foo.        ==&gt; "." <br>// <br> <br>LPTSTR PathFindExtension(LPCTSTR pszPath) <br>{ <br>    LPCTSTR pszDot; <br> <br>    for (pszDot = NULL; *pszPath; pszPath = CharNext(pszPath)) <br>    { <br>        switch (*pszPath) { <br>        case TEXT('.'): <br>            pszDot = pszPath;         // remember the last dot <br>            break; <br>        case TEXT('\\'): <br>        case TEXT(' '):         // extensions can't have spaces <br>            pszDot = NULL;       // forget last dot, it was in a directory <br>            break; <br>        } <br>    } <br> <br>    // if we found the extension, return ptr to the dot, else <br>    // ptr to end of the string (NULL extension) (cast-&gt;non const) <br>    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath; <br>} <br> <br>//-------------------------------------------------------------------------- <br>// Return a pointer to the end of the next path componenent in the string. <br>// ie return a pointer to the next backslash or terminating NULL. <br>LPCTSTR GetPCEnd(LPCTSTR lpszStart) <br>{ <br>        LPCTSTR lpszEnd; <br> <br>        lpszEnd = StrChr(lpszStart, TEXT('\\')); <br>        if (!lpszEnd) <br>        { <br>                lpszEnd = lpszStart + lstrlen(lpszStart); <br>        } <br> <br>        return lpszEnd; <br>} <br>//-------------------------------------------------------------------------- <br>// Given a pointer to the end of a path component, return a pointer to <br>// its begining. <br>// ie return a pointer to the previous backslash (or start of the string). <br>LPCTSTR PCStart(LPCTSTR lpszStart, LPCTSTR lpszEnd) <br>{ <br>    LPCTSTR lpszBegin = StrRChr(lpszStart, lpszEnd, TEXT('\\')); <br>    if (!lpszBegin) <br>    { <br>            lpszBegin = lpszStart; <br>    } <br>    return lpszBegin; <br>} <br> <br>//-------------------------------------------------------------------------- <br>// Fix up a few special cases so that things roughly make sense. <br>void NearRootFixups(LPTSTR lpszPath, BOOL fUNC) <br>    { <br>    // Check for empty path. <br>    if (lpszPath[0] == TEXT('\0')) <br>        { <br>        // Fix up. <br>        lpszPath[0] = TEXT('\\'); <br>        lpszPath[1] = TEXT('\0'); <br>        } <br>    // Check for missing slash. <br>    if (!IsDBCSLeadByte(lpszPath[0]) &amp;&amp; lpszPath[1] == TEXT(':') &amp;&amp; lpszPath[2] == TEXT('\0')) <br>        { <br>        // Fix up. <br>        lpszPath[2] = TEXT('\\'); <br>        lpszPath[3] = TEXT('\0'); <br>        } <br>    // Check for UNC root. <br>    if (fUNC &amp;&amp; lpszPath[0] == TEXT('\\') &amp;&amp; lpszPath[1] == TEXT('\0')) <br>        { <br>        // Fix up. <br>        lpszPath[0] = TEXT('\\'); <br>        lpszPath[1] = TEXT('\\'); <br>        lpszPath[2] = TEXT('\0'); <br>        } <br>    } <br> <br>//-------------------------------------------------------------------------- <br>// Canonicalizes a path. <br>BOOL PathCanonicalize(LPTSTR lpszDst, LPCTSTR lpszSrc) <br>    { <br>    LPCTSTR lpchSrc; <br>    LPCTSTR lpchPCEnd;           // Pointer to end of path component. <br>    LPTSTR lpchDst; <br>    BOOL fUNC; <br>    int cbPC; <br> <br>    fUNC = PathIsUNC(lpszSrc);    // Check for UNCness. <br> <br>    // Init. <br>    lpchSrc = lpszSrc; <br>    lpchDst = lpszDst; <br> <br>    while (*lpchSrc) <br>        { <br>        // this should just return the count <br>        lpchPCEnd = GetPCEnd(lpchSrc); <br>        cbPC = (lpchPCEnd - lpchSrc)+1; <br> <br>        // Check for slashes. <br>        if (cbPC == 1 &amp;&amp; *lpchSrc == TEXT('\\')) <br>            { <br>            // Just copy them. <br>            *lpchDst = TEXT('\\'); <br>            lpchDst++; <br>            lpchSrc++; <br>            } <br>        // Check for dots. <br>        else if (cbPC == 2 &amp;&amp; *lpchSrc == TEXT('.')) <br>            { <br>            // Skip it... <br>            // Are we at the end? <br>            if (*(lpchSrc+1) == TEXT('\0')) <br>                { <br>                lpchDst--; <br>                lpchSrc++; <br>                } <br>            else <br>                lpchSrc += 2; <br>            } <br>        // Check for dot dot. <br>        else if (cbPC == 3 &amp;&amp; *lpchSrc == TEXT('.') &amp;&amp; *(lpchSrc + 1) == TEXT('.')) <br>            { <br>            // make sure we aren't already at the root <br>            if (!PathIsRoot(lpszDst)) <br>                { <br>                // Go up... Remove the previous path component. <br>                lpchDst = (LPTSTR)PCStart(lpszDst, lpchDst - 1); <br>                } <br>            else <br>                { <br>                // When we can't back up, remove the trailing backslash <br>                // so we don't copy one again. (C:\..\FOO would otherwise <br>                // turn into C:\\FOO). <br>                if (*(lpchSrc + 2) == TEXT('\\')) <br>                    { <br>                    lpchSrc++; <br>                    } <br>                } <br>            lpchSrc += 2;       // skip ".." <br>            } <br>        // Everything else <br>        else <br>            { <br>            // Just copy it. <br>            lstrcpyn(lpchDst, lpchSrc, cbPC); <br>            lpchDst += cbPC - 1; <br>            lpchSrc += cbPC - 1; <br>            } <br>        // Keep everything nice and tidy. <br>        *lpchDst = TEXT('\0'); <br>        } <br> <br>    // Check for weirdo root directory stuff. <br>    NearRootFixups(lpszDst, fUNC); <br> <br>    return TRUE; <br>    } <br> <br> <br>// Modifies: <br>//      szRoot <br>// <br>// Returns: <br>//      TRUE if a drive root was found <br>//      FALSE otherwise <br>// <br>BOOL PathStripToRoot(LPTSTR pszRoot) <br>{ <br>    while(!PathIsRoot(pszRoot)) <br>    { <br>        if (!PathRemoveFileSpec(pszRoot)) <br>        { <br>            // If we didn't strip anything off, <br>            // must be current drive <br>            return(FALSE); <br>        } <br>    } <br> <br>    return(TRUE); <br>} <br> <br> <br>// concatinate lpszDir and lpszFile into a properly formed path <br>// and canonicalizes any relative path pieces <br>// <br>// returns: <br>//  pointer to destination buffer <br>// <br>// lpszDest and lpszFile can be the same buffer <br>// lpszDest and lpszDir can be the same buffer <br>// <br>// assumes: <br>//      lpszDest is MAX_PATH bytes <br>// <br>// <br> <br>LPTSTR PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPCTSTR lpszFile) <br>{ <br>    TCHAR szTemp[MAX_PATH]; <br>    LPTSTR pszT; <br> <br>    if (!lpszFile || *lpszFile==TEXT('\0')) { <br> <br>        lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));       // lpszFile is empty <br> <br>    } else if (lpszDir &amp;&amp; *lpszDir &amp;&amp; PathIsRelative(lpszFile)) { <br> <br>        lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp)); <br>        pszT = PathAddBackslash(szTemp); <br>        if (pszT) { <br>            int iLen = lstrlen(szTemp); <br>            if ((iLen + lstrlen(lpszFile)) &lt; ARRAYSIZE(szTemp)) { <br>                lstrcpy(pszT, lpszFile); <br>            } else <br>                return NULL; <br>        } else <br>            return NULL; <br> <br>    } else if (lpszDir &amp;&amp; *lpszDir &amp;&amp; <br>        *lpszFile == TEXT('\\') &amp;&amp; !PathIsUNC(lpszFile)) { <br> <br>        lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp)); <br>        // Note that we do not check that an actual root is returned; <br>        // it is assumed that we are given valid parameters <br>        PathStripToRoot(szTemp); <br> <br>        pszT = PathAddBackslash(szTemp); <br>        if (pszT) <br>        { <br>            // Skip the backslash when copying <br>            lstrcpyn(pszT, lpszFile+1, ARRAYSIZE(szTemp) - 1 - (pszT-szTemp)); <br>        } else <br>            return NULL; <br> <br>    } else { <br> <br>        lstrcpyn(szTemp, lpszFile, ARRAYSIZE(szTemp));     // already fully qualified file part <br> <br>    } <br> <br>    PathCanonicalize(lpszDest, szTemp); // this deals with .. and . stuff <br> <br>    return lpszDest; <br>} <br> <br>// rips the last part of the path off including the backslash <br>//      C:\foo      -&gt; C:\      ; <br>//      C:\foo\bar  -&gt; C:\foo <br>//      C:\foo\     -&gt; C:\foo <br>//      \\x\y\x     -&gt; \\x\y <br>//      \\x\y       -&gt; \\x <br>//      \\x         -&gt; ?? (test this) <br>//      \foo        -&gt; \  (Just the slash!) <br>// <br>// in/out: <br>//      pFile   fully qualified path name <br>// returns: <br>//      TRUE    we stripped something <br>//      FALSE   didn't strip anything (root directory case) <br>// <br> <br>BOOL PathRemoveFileSpec(LPTSTR pFile) <br>{ <br>    LPTSTR pT; <br>    LPTSTR pT2 = pFile; <br> <br>    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) { <br>        if (*pT2 == TEXT('\\')) <br>            pT = pT2;             // last "\" found, (we will strip here) <br>        else if (*pT2 == TEXT(':')) {   // skip ":\" so we don't <br>            if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\" <br>                pT2++; <br>            pT = pT2 + 1; <br>        } <br>    } <br>    if (*pT == 0) <br>        return FALSE;   // didn't strip anything <br> <br>    // <br>    // handle the \foo case <br>    // <br>    else if ((pT == pFile) &amp;&amp; (*pT == TEXT('\\'))) { <br>        // Is it just a '\'? <br>        if (*(pT+1) != TEXT('\0')) { <br>            // Nope. <br>            *(pT+1) = TEXT('\0'); <br>            return TRUE;        // stripped something <br>        } <br>        else        { <br>            // Yep. <br>            return FALSE; <br>        } <br>    } <br>    else { <br>        *pT = 0; <br>        return TRUE;    // stripped something <br>    } <br>} <br> <br>// add a backslash to a qualified path <br>// <br>// in: <br>//  lpszPath    path (A:, C:\foo, etc) <br>// <br>// out: <br>//  lpszPath    A:\, C:\foo\    ; <br>// <br>// returns: <br>//  pointer to the NULL that terminates the path <br> <br> <br>LPTSTR PathAddBackslash(LPTSTR lpszPath) <br>{ <br>    LPTSTR lpszEnd; <br> <br>    // try to keep us from tromping over MAX_PATH in size. <br>    // if we find these cases, return NULL.  Note: We need to <br>    // check those places that call us to handle their GP fault <br>    // if they try to use the NULL! <br>    int ichPath = lstrlen(lpszPath); <br>    if (ichPath &gt;= (MAX_PATH - 1)) <br>    { <br>        Assert(FALSE);      // Let the caller know! <br>        return(NULL); <br>    } <br> <br>    lpszEnd = lpszPath + ichPath; <br> <br>    // this is really an error, caller shouldn't pass <br>    // an empty string <br>    if (!*lpszPath) <br>        return lpszEnd; <br> <br>    /* Get the end of the source directory <br>    */ <br>    switch(*CharPrev(lpszPath, lpszEnd)) { <br>    case TEXT('\\'): <br>        break; <br> <br>    default: <br>        *lpszEnd++ = TEXT('\\'); <br>        *lpszEnd = TEXT('\0'); <br>    } <br>    return lpszEnd; <br>} <br> <br> <br>// Returns a pointer to the last component of a path string. <br>// <br>// in: <br>//      path name, either fully qualified or not <br>// <br>// returns: <br>//      pointer into the path where the path is.  if none is found <br>//      returns a poiter to the start of the path <br>// <br>//  c:\foo\bar  -&gt; bar <br>//  c:\foo      -&gt; foo <br>//  c:\foo\     -&gt; c:\foo\      ( is this case busted?) <br>//  c:\         -&gt; c:\          ( this case is strange) <br>//  c:          -&gt; c: <br>//  foo         -&gt; foo <br> <br> <br>LPTSTR PathFindFileName(LPCTSTR pPath) <br>{ <br>    LPCTSTR pT; <br> <br>    for (pT = pPath; *pPath; pPath = CharNext(pPath)) { <br>        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) &amp;&amp; pPath[1] &amp;&amp; (pPath[1] != TEXT('\\'))) <br>            pT = pPath + 1; <br>    } <br> <br>    return (LPTSTR)pT;   // const -&gt; non const <br>} <br> <br>//--------------------------------------------------------------------------- <br>// Returns TRUE if the given string is a UNC path. <br>// <br>// TRUE <br>//      "\\foo\bar" <br>//      "\\foo"         &lt;- careful <br>//      "\\" <br>// FALSE <br>//      "\foo" <br>//      "foo" <br>//      "c:\foo" <br> <br>BOOL PathIsUNC(LPCTSTR pszPath) <br>{ <br>    return DBL_BSLASH(pszPath); <br>} <br> <br>//--------------------------------------------------------------------------- <br>// Return TRUE if the path isn't absoulte. <br>// <br>// TRUE <br>//      "foo.exe" <br>//      ".\foo.exe" <br>//      "..\boo\foo.exe" <br>// <br>// FALSE <br>//      "\foo" <br>//      "c:bar"     &lt;- be careful <br>//      "c:\bar" <br>//      "\\foo\bar" <br> <br>BOOL PathIsRelative(LPCTSTR lpszPath) <br>{ <br>    // The NULL path is assumed relative <br>    if (*lpszPath == 0) <br>        return TRUE; <br> <br>    // Does it begin with a slash ? <br>    if (lpszPath[0] == TEXT('\\')) <br>        return FALSE; <br>    // Does it begin with a drive and a colon ? <br>    else if (!IsDBCSLeadByte(lpszPath[0]) &amp;&amp; lpszPath[1] == TEXT(':')) <br>        return FALSE; <br>    // Probably relative. <br>    else <br>        return TRUE; <br>} <br> <br>#pragma data_seg(".text", "CODE") <br> <br>const TCHAR c_szColonSlash[] = TEXT(":\\"); <br> <br>#pragma data_seg() <br> <br>// check if a path is a root <br>// <br>// returns: <br>//  TRUE for "\" "X:\" "\\foo\asdf" "\\foo\" <br>//  FALSE for others <br> <br>BOOL  PathIsRoot(LPCTSTR pPath) <br>{ <br>    if (!IsDBCSLeadByte(*pPath)) <br>    { <br>        if (!lstrcmpi(pPath + 1, c_szColonSlash))                  // "X:\" case <br>            return TRUE; <br>    } <br> <br>    if ((*pPath == TEXT('\\')) &amp;&amp; (*(pPath + 1) == 0))        // "\" case <br>        return TRUE; <br> <br>    if (DBL_BSLASH(pPath))      // smells like UNC name <br>    { <br>        LPCTSTR p; <br>        int cBackslashes = 0; <br> <br>        for (p = pPath + 2; *p; p = CharNext(p)) { <br>            if (*p == TEXT('\\') &amp;&amp; (++cBackslashes &gt; 1)) <br>               return FALSE;   /* not a bare UNC name, therefore not a root dir */ <br>        } <br>        return TRUE;    /* end of string with only 1 more backslash */ <br>                        /* must be a bare UNC, which looks like a root dir */ <br>    } <br>    return FALSE; <br>} <br> <br>BOOL OnExtList(LPCTSTR pszExtList, LPCTSTR pszExt) <br>{ <br>    for (; *pszExtList; pszExtList += lstrlen(pszExtList) + 1) <br>    { <br>        if (!lstrcmpi(pszExt, pszExtList)) <br>        { <br>            return TRUE;        // yes <br>        } <br>    } <br> <br>    return FALSE; <br>} <br> <br>#pragma data_seg(".text", "CODE") <br>// what about .cmd? <br>const TCHAR achExes[] = TEXT(".bat\0.pif\0.exe\0.com\0"); <br>#pragma data_seg() <br> <br>// determine if a path is a program by looking at the extension <br>// <br>BOOL PathIsExe(LPCTSTR szFile) <br>{ <br>    LPCTSTR temp = PathFindExtension(szFile); <br>    return OnExtList((LPCTSTR) achExes, temp); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
