<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating, Enumerating, and Sizing Child Windows</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_creating_enumerating_and_sizing_child_windows"></a>Creating, Enumerating, and Sizing Child Windows</h2>
<p>
You can divide a window's client area into different functional areas by using child windows. Creating a child window is like creating a main window — you use the <a href="windows_1w6w.htm"><b>CreateWindowEx</b></a> function. To create a window of an application-defined window class, you must register the window class and provide a window procedure before creating the child window. You must give the child window the WS_CHILD style and specify a parent window for the child window when you create it. </p>
<p>
The following example divides the client area of an application's main window into three functional areas by creating three child windows of equal size. Each child window is the same height as the main window's client area, but each is one-third its width. The main window creates the child windows in response to the <a href="windows_41d1.htm">WM_CREATE</a> message, which the main window receives during its own window-creation process. Because each child window has the WS_BORDER style, each has a thin line border. Also, because the WS_VISIBLE style is not specified, each child window is initially hidden. Notice also that each child window is assigned a child-window identifier. </p>
<p>
The main window sizes and positions the child windows in response to the <a href="windows_2pk5.htm">WM_SIZE</a> message, which the main window receives when its size changes. In response to WM_SIZE, the main window retrieves the dimensions of its client area by using the <a href="windows_471w.htm"><b>GetWindowRect</b></a> function and then passes the dimensions to the <a href="windows_46cz.htm"><b>EnumChildWindows</b></a> function. <b>EnumChildWindows</b> passes the handle to each child window, in turn, to the application-defined <a href="windows_6tr7.htm"><b>EnumChildProc</b></a> callback function. This function sizes and positions each child window by calling the <a href="windows_92nr.htm"><b>MoveWindow</b></a> function; the size and position are based on the dimensions of the main window's client area and the identifier of the child window. Afterward, <b>EnumChildProc</b> calls the <a href="windows_2tdj.htm"><b>ShowWindow</b></a> function to make the window visible. </p>
<pre><code>#define ID_FIRSTCHILD  100 
#define ID_SECONDCHILD 101 
#define ID_THIRDCHILD  102 
 
LONG APIENTRY MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{ 
    RECT rcClient; 
    int i; 
 
    switch(uMsg) 
    { 
        case WM_CREATE: // creating main window  
 
            // Create three invisible child windows. 
 
            for (i = 0; i &lt; 3; i++) 
            { 
                CreateWindowEx( 
                    0, 
                    "ChildWClass", 
                    (LPCTSTR) NULL, 
                    WS_CHILD | WS_BORDER, 
                    0,0,0,0, 
                    hwnd, 
                    (HMENU) (int) (ID_FIRSTCHILD + i), 
                    hinst, 
                    NULL); 
            }
 
            return 0; 
 
        case WM_SIZE:   // main window changed size 
 
            // Get the dimensions of the main window's client 
            // area, and enumerate the child windows. Pass the 
            // dimensions to the child windows during enumeration. 
 
            GetClientRect(hwnd, &amp;rcClient); 
            EnumChildWindows(hwnd, EnumChildProc, 
                (LPARAM) &amp;rcClient); 
            return 0; 
        // Process other messages. 
 
    } 
    return DefWindowProc(hwnd, uMsg, wParam, lParam); 
} 
 
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam) 
{ 
    LPRECT rcParent; 
    int i, idChild; 
 
    // Retrieve the child-window identifier. Use it to set the 
    // position of the child window. 
 
    idChild = GetWindowLong(hwndChild, GWL_ID); 
 
    if (idChild == ID_FIRSTCHILD) 
        i = 0; 
    else if (idChild == ID_SECONDCHILD) 
        i = 1; 
    else 
        i = 2; 
 
    // Size and position the child window.  
 
    rcParent = (LPRECT) lParam; 
    MoveWindow(hwndChild, 
        (rcParent-&gt;right / 3) * i, 
        0, 
        rcParent-&gt;right / 3, 
        rcParent-&gt;bottom, 
        TRUE); 
 
    // Make sure the child window is visible. 
 
    ShowWindow(hwndChild, SW_SHOW); 
 
    return TRUE; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
