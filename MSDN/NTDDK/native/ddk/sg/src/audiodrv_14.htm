<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Transferring MIDI Input Data</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Transferring_MIDI_Input_Data"></A>Transferring MIDI Input Data</H4>
<P>
For MIDI input operations, clients call the user-mode driver’s <B><A HREF="audiodrv_45.htm">midMessage</A></B>
function. The user-mode driver should expect the client to first send a <A HREF="audiodrv_59.htm">MIDM_OPEN</A>
message to open a driver instance. Next, the client allocates memory for one
or more data buffers and sends <A HREF="audiodrv_60.htm">MIDM_PREPARE</A>
messages to prepare the buffers for use. The client then sends a <A HREF="audiodrv_55.htm">MIDM_ADDBUFFER</A>
message for each buffer, which passes the address of the empty buffer to the
user-mode driver. The user-mode driver keeps a queue of available empty
buffers.
<P>
To start the read operation, the client sends <A HREF="audiodrv_62.htm">MIDM_START</A>.
The user-mode driver then uses a separate thread to begin requesting data from
the kernel-mode driver, typically by calling <B>ReadFileEx</B>. The user-mode
driver receives a buffer of MIDI data that can consist of a combination of
short MIDI messages, or single <I>events</I>, and long MIDI messages, or <I>system-exclusive
events</I>. (For descriptions of MIDI events, see the <I>Standard MIDI Files
1.0</I>&nbsp;specification.) The user-mode driver must parse the bytes received and
do the following:
<UL>
<LI>
Create a time stamp (see <I>Adding Time Stamps</I>, below).
<P>
<LI>
If the received event is system-exclusive, place the event’s bytes in the next
available buffer from the queue of client buffers. If the buffer becomes full,
notify the client with a <A HREF="audiodrv_68.htm">MIM_LONGDATA</A>&nbsp;callback
message. The client can read the buffer and re-use it by sending another <A HREF="audiodrv_55.htm">MIDM_ADDBUFFER</A>
message.
<P>
<LI>
If the received event is not system-exclusive, check the message to see if
running status (see <I>Running Status</I>, below) is in effect and if so, add
the previous status byte to the event. (All events passed to clients must
include a status byte.) Then pass the event’s bytes to the client with a <A HREF="audiodrv_66.htm">MIM_DATA</A>
callback message.
</UL>
<P>
When the client has finished the input operation, it sends <A HREF="audiodrv_63.htm">MIDM_STOP</A>.
It can also send <A HREF="audiodrv_61.htm">MIDM_RESET</A>, which indicates to the
user-mode driver that it should not fill any remaining data buffers. The
client can then send a <A HREF="audiodrv_64.htm">MIDM_UNPREPARE</A>&nbsp;message for
each buffer and deallocate the buffers. Finally, the driver should expect the
client to close the instance by sending <A HREF="audiodrv_56.htm">MIDM_CLOSE</A>.
<H5><A NAME="DDK_Adding_Time_Stamps"></A>Adding Time Stamps</H5>
<P>
All MIDI events that are returned to a client must include a time stamp. The
time stamp represents the number of milliseconds that have passed since input
began. When a client sends the MIDM_START message, the kernel-mode driver
saves the current system time to use as a reference time. Then each time the
kernel-mode driver reads an event, it saves a time stamp value equal to the
difference between the current time and the reference time.
<H5><A NAME="DDK_Running_Status"></A>Running Status</H5>
<P>
MIDI events might or might not include a status byte. If the status byte is
not included, then the client is employing <I>running status</I>. This means
that the last status byte sent is still in effect and need not be re-sent.
When a user-mode driver receives a <A HREF="audiodrv_77.htm">MODM_DATA</A>&nbsp;message
it checks the status byte and if no value is present, it does not pass the
byte to the kernel-mode driver.
<H5><A NAME="DDK_Handling_MIDI_Thru"></A>Handling MIDI Thru</H5>
<P>
Code within <I>winmm.dll </I>supports MIDI thru-ing to the extent that it will
connect one MIDI input driver to one MIDI output driver. You can write a
thru-ing driver by responding to DRVM_ADD_THRU and DRVM_REMOVE_THRU messages
within <B><A HREF="audiodrv_45.htm">midMessage</A></B>&nbsp;and <B><A HREF="audiodrv_46.htm">modMessage</A></B>.
For more information, see the discussion of managing MIDI thru-ing and the
description of <B>midiConnect</B>&nbsp;in the Win32 SDK.
<P></FONT>
</BODY>
</HTML>
