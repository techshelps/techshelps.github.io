<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Single Buffer DMA Transfer</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Single_Buffer_DMA_Transfer"></A>Single Buffer DMA Transfer</H4>
<P>
In the single-buffer strategy, the VDD again determines a DMA request is
pending by receiving a command from the application. To avoid copying the data
to its own memory space, the VDD calls <B>VDDQueryDMA</B>&nbsp;to determine the
source, destination, and other DMA parameters. It then sends the DMA
information to the kernel-mode device driver and allows that driver to
transfer the data directly from the application’s buffer to the device, as
shown in the following illustration. The kernel-mode device driver can program
the DMA controller through the platform-specific HAL to carry out the transfer
or it can use some other means to transfer the data. In the other direction,
the VDD can request that the driver transfer data directly from the device to
the application’s buffer. In either direction, VDDs using this second strategy
must call <B>VDDSetDMA</B>&nbsp;to update the DMA state after the transfer is
complete.
<P>
<B><IMG SRC="../art/401-05.gif" BORDER=0></B>
<P>
<B>Direct virtual DMA transfer</B>
<P>
Because DMA registers contain physical addresses, a VDD that uses <B>VDDQueryDMA</B>
must correctly convert these addresses to Win32 linear addresses in the VDM
process address space.
<P>
The following illustration shows how the virtual DOS machine can be laid out
in memory relative to the VDM process. On an <I>x</I>86 machine, linear zero
of the VDM process is the same as 0:0 for DOS. On a non<I>x</I>86 machine
these addresses might be different. The addresses returned by <B>VDDQueryDMA</B>
are relative to the DOS 0:0.
<P>
<B><IMG SRC="../art/401-06.gif" BORDER=0></B>
<P>
<B>Memory Layout for DMA addresses</B>
<P>
On an <I>x</I>86 machine, there is no difference between a DMA address, as
programmed by the MS-DOS application to the DMA chip, and a Win32 address. On
a non<I>x</I>86 machine, you must add the offset from VDM 0 to DOS 0:0 to
convert a DMA address to a Win32 address. To get the offset from VDM to DOS,
call <B>GetVDMPointer(0,0,0)</B>. On an <I>x</I>86 machine, this call returns
zero. On a RISC machine, it returns the difference between VDM 0 and DOS 0:0.
Thus, adding <B>GetVDMPointer(0,0,0) </B>to a DMA address always gives the
correct Win32 linear pointer, regardless of machine type.
<P></FONT>
</BODY>
</HTML>
