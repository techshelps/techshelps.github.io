<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interrupt Simulation</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Interrupt_Simulation"></A>Interrupt Simulation</H3>
<P>
The <B>VDDSimulateInterrupt</B>&nbsp;function allows a VDD to simulate a hardware
interrupt to the VDM. Call this function if the application depends on an
interrupt to tell it that some particular operation has been completed. For
example, the application using a fax board might expect to get a particular
interrupt when the board is done sending a fax. Because the VDD is notified
when the fax board is done, the VDD can simulate the interrupt to the
application.
<P>
When the VDD calls <B>VDDSimulateInterrupt,</B>&nbsp;the address pointed to by the
interrupt vector starts running in 16-bit mode. For an asynchronous interrupt,
the VDD should create another thread and call <B>VDDSimulateInterrupt</B>&nbsp;from
that thread.
<P>
The<B>&nbsp;VDDSimulate16</B>&nbsp;function is similar to <B>VDDSimulateInterrupt</B>,
except it does not require a hardware interrupt to be supported by the 16-bit
stub driver. <B>VDDSimulate16</B>&nbsp;allows the VDD to execute a routine in its
16-bit driver and return when it has finished. Before calling <B>VDDSimulate16</B>,
a VDD should preserve all the 16-bit registers its routine might destroy;
minimally, it should preserve CS and IP. Then, set the CS and IP for the
16-bit routine. A VDD can also use registers such as AX or BX to pass
parameters to its 16-bit routines. At the end of the 16-bit routine, <B>VDDUnSimulate16</B>
sends control back to the VDD. Because this simulation is synchronous, the VDD
is blocked in <B>VDDSimulate16</B>&nbsp;and returns only when the stub driver calls
<B>VDDUnSimulate16</B>. The following code shows an example of how these calls
are used:
<DL>
<DT>
vdd (Win32 Code):
<DD>
<PRE><FONT FACE="Courier" SIZE="2">SaveCS = getCS( );
SaveIP = getIP( );
SaveAX = getAX( );
setCS (16BitRoutineCS);
setIP (16BitRoutineIP);
setAX (DO_X_OPERATION);
VDDSimulate16( );
setCS (SaveCS);
setIP (SaveIP);
setAX (SaveAX);
. .
. .
Stub Driver (Initialization):
RegisterModule&#09;&#09;&#09;&#09;;Loads VDD
push cs
pop ax
mov bx,offset Simulate16
DispatchCall&#09;&#09;&#09;&#09;;passes the address of worker
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;routine to VDD in ax:bx
Stub Driver (Run Time)

Simulate16:
. .
. .&#09;&#09;&#09;&#09;&#09;&#09;&#09;;do the operation index passed in ax
VDDUnSimulate16
</FONT></PRE>
</DL>
<P></FONT>
</BODY>
</HTML>
