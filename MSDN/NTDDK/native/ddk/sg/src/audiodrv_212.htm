<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MIDI_INFO</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_MIDI_INFO"></A>MIDI_INFO</H2>
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _MIDI_INFO 
{
&nbsp; &nbsp; ULONG           Key;
#define MIDI_INFO_KEY       (*(ULONG *)&quot;Midi&quot;)
&nbsp; &nbsp; &nbsp; &nbsp; KSPIN_LOCK      DeviceSpinLock;
&nbsp; &nbsp; #if DBG
&nbsp; &nbsp; &nbsp; &nbsp; BOOLEAN         LockHeld;
&nbsp; &nbsp; #endif
&nbsp; &nbsp; &nbsp; &nbsp; LARGE_INTEGER   RefTime;
&nbsp; &nbsp; &nbsp; &nbsp; LIST_ENTRY      QueueHead;
&nbsp; &nbsp; &nbsp; &nbsp; PVOID           HwContext;
&nbsp; &nbsp; &nbsp; &nbsp; PMIDI_INTERFACE_ROUTINE HwStartMidiIn, HwStopMidiIn;
&nbsp; &nbsp; &nbsp; &nbsp; BOOLEAN      (* HwMidiRead)(struct _MIDI_INFO *, PUCHAR);
&nbsp; &nbsp; &nbsp; &nbsp; VOID         (* HwMidiOut)(struct _MIDI_INFO *, PUCHAR, int);
&nbsp; &nbsp; &nbsp; &nbsp; BOOLEAN         fMidiInStarted;
&nbsp; &nbsp; &nbsp; &nbsp; UCHAR           InputPosition;
&nbsp; &nbsp; &nbsp; &nbsp; UCHAR           InputBytes;
&nbsp; &nbsp; &nbsp; &nbsp; UCHAR           MidiInputByte[64];
} MIDI_INFO, *PMIDI_INFO;
&nbsp;</FONT></PRE>
<P>
The MIDI_INFO structure contains context information for an external MIDI
device.
<H5>Members</H5>
<DL>
<DT>
<B>Key</B>
<DD>
Internal only, for debugging. Should be “Midi”.
<BR>
<DT>
<B>DeviceSpinLock</B>
<DD>
Internal only. Used for DPC synchronization.
<BR>
<DT>
<B>LockHeld</B>
<DD>
Internal only. Used for debugging.
<BR>
<DT>
<B>RefTime</B>
<DD>
Used by <I>soundlib.lib</I>&nbsp;to store the start time of an I/O operation, as
reference for time stamps.
<BR>
<DT>
<B>QueueHead</B>
<DD>
Internal only. Points to a buffer queue for MIDI input requests.
<BR>
<DT>
<B>HwContext</B>
<DD>
Pointer to a driver-defined structure containing device-specific hardware
information. Typically used by functions pointed to by the <B>HwStartMidiIn</B>,
<B>HwStopMidiIn</B>, <B>HwMidiRead</B>, and <B>HwMidiOut</B>&nbsp;members.
<BR>
<DT>
<B>HwStartMidiIn</B>
<DD>
Pointer to a driver-supplied function that programs the MIDI hardware to start
recording. The function type is <A HREF="audiodrv_213.htm">MIDI_INTERFACE_ROUTINE</A>.
<P>
The function is called when <B><A HREF="audiodrv_185.htm">SoundMIDIDispatch</A></B>
receives a IOCTL_MIDI_SET_STATE command. See <I>\src\mmedia\soundlib\midi.c</I>.
<BR>
<DT>
<B>HwStopMidiIn</B>
<DD>
Pointer to a driver-supplied function that programs the MIDI hardware to stop
recording. The function type is <A HREF="audiodrv_213.htm">MIDI_INTERFACE_ROUTINE</A>.
<P>
The function is called when <B><A HREF="audiodrv_185.htm">SoundMIDIDispatch</A></B>
receives a IRP_MJ_CLEANUP command. For more information, see <I>\src\mmedia\soundlib\midi.c</I>.
<BR>
<DT>
<B>HwMidiRead</B>
<DD>
Pointer to a driver-supplied function that reads one input byte. This
operation might only consist of fetching the next byte from a buffer that was
filled by an ISR. (An example is MPU401 support in <I>sndblst.sys</I>.) The
function type is:
<PRE><FONT FACE="Courier" SIZE="2">BOOLEAN (* HwMidiRead)(struct _MIDI_INFO *, PUCHAR)
</FONT></PRE>
<P>
The _MIDI_INFO* parameter points to a MIDI_INFO structure and the PUCHAR
parameter receives the read byte. The function returns TRUE if a byte was
read, and FALSE otherwise.
<P>
The function is called when <B><A HREF="audiodrv_185.htm">SoundMIDIDispatch</A></B>
receives a IRP_MJ_READ command. For more information, see <I>\src\mmedia\soundlib\midi.c</I>.
<P>
This function executes at an IRQL of DISPATCH_LEVEL, so it cannot be pageable
and it cannot reference pageable code or data. Also, the only synchronization
method it can use is calling <B><A HREF="../../kr/src/k105_52.htm">KeStallExecutionProcessor</A></B>.
<BR>
<DT>
<B>HwMidiOut</B>
<DD>
Pointer to a driver-supplied function that commands the MIDI hardware to write
a string of bytes. Function type is:
<PRE><FONT FACE="Courier" SIZE="2">VOID (* HwMidiOut)(struct _MIDI_INFO *, PUCHAR, int)
</FONT></PRE>
<P>
The first parameter points to a MIDI_INFO structure, the second parameter
points to a mapped buffer of bytes, and the third parameter contains the
buffer size.
<P>
The function is called when <B><A HREF="audiodrv_185.htm">SoundMIDIDispatch</A></B>
receives a IOCTL_MIDI_PLAY command. For more information, see <I>\src\mmedia\soundlib\midi.c</I>.
<BR>
<DT>
<B>fMidiInStarted</B>
<DD>
Internal only. Indicates a MIDI input operation is in progress.
<BR>
<DT>
<B>InputPosition</B>
<DD>
Internal only. Pointer to an internal input buffer.
<BR>
<DT>
<B>InputBytes</B>
<DD>
Internal only. Count of bytes in internal input buffer.
<BR>
<DT>
<B>MidiInputByte</B>
<DD>
Internal only. Pointer to internal input buffer.
</DL>
<H5>Comments</H5>
<P>
A single MIDI_INFO structure can be used to support simultaneous MIDI input
and output. MIDI_INFO is defined in <I>midi.h</I>.
<P>
Allocate a MIDI_INFO structure from the nonpaged memory pool by calling <B><A HREF="../../kr/src/k102_11.htm">ExAllocatePool</A></B>,
then zero it by calling <B><A HREF="../../kr/src/k109_80.htm">RtlZeroMemory</A></B>.
To initialize a MIDI_INFO structure, call <B><A HREF="audiodrv_182.htm">SoundInitMidiIn</A></B>.
<P>
To create a MIDI device object, call <B><A HREF="audiodrv_166.htm">SoundCreateDevice</A></B>
and specify a MIDI_INFO structure pointer for the <I>DeviceSpecificData</I>
parameter.
<P></FONT>
</BODY>
</HTML>
