<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Double-Buffer DMA Transfer</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Double_Buffer_DMA_Transfer"></A>Double-Buffer DMA Transfer</H4>
<P>
In the double-buffer strategy, the VDD calls <B>VDDRequestDMA</B>&nbsp;to move the
data as described by the last DMA request. The <B>VDDRequestDMA</B>&nbsp;function
looks at the last DMA command trapped by the VDM and executes a data transfer
that matches those DMA parameters, although the transfer does not actually use
DMA. When the DMA transfer request specifies that data be moved from an
application buffer to the device, the data actually goes from the application
buffer to a block of memory the VDD has mapped to the virtual address space
occupied by the board. When the data has been transferred to the VDD’s buffer,
the VDD can then transfer it to the device by passing the data to the
kernel-mode device driver. Likewise, when the DMA transfer is requesting data
be moved from the device to an application buffer, the VDD first calls the
kernel-mode driver to copy the data from the device to the VDD’s buffer. The
VDD can then transfer the data from its buffer to the application’s buffer by
calling <B>VDDRequestDMA</B>, as shown in the following illustration.
<P>
<B><IMG SRC="../art/401-04.gif" BORDER=0></B>
<P>
<B>Two-stage virtual DMA transfer</B>
<P></FONT>
</BODY>
</HTML>
