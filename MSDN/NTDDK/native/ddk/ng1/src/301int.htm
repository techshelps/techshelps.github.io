<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chapter 1  NDIS Intermediate Drivers</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H1><A NAME="DDK_NDIS_Intermediate_Drivers_NG"></A>Chapter 1  NDIS Intermediate Drivers</H1>
<P>
An NDIS intermediate driver usually exports Miniport<I>Xxx</I>&nbsp;functions at
its upper edge and Protocol<I>Xxx</I>&nbsp;functions at its lower edge. Less
commonly, an intermediate driver can export Miniport<I>Xxx</I>&nbsp;functions at
its upper edge and a private interface to an underlying non-NDIS driver at its
lower edge.
<P>
An intermediate driver is typically layered over one or more NDIS NIC drivers
and under a transport driver (possibly multilayered) that supports TDI at its
upper edge. Theoretically, an intermediate driver could be layered above or
below another intermediate driver, although such an arrangement is unlikely to
exhibit good performance.
<P>
Two examples of intermediate drivers are:
<UL>
<LI>
A LAN-emulator intermediate driver layered below a legacy transport driver and
above a miniport NIC driver for a non-LAN medium 
<P>
Such a driver receives packets in a LAN format at its upper edge, translates
them to another NIC-native medium format and sends them on to an NDIS miniport
for that NIC. On receives, this intermediate driver translates packets
indicated up from the underlying NIC driver to a LAN-compatible format and
indicates these converted packets to the upper level transport driver. 
<P>
For example, NDISWAN has many of these properties. NDISWAN translates packets
from the overlying transports&#39; LAN format to WAN packet format and packets
from the underlying NIC drivers&#39; WAN packet format to LAN packet format.
NDISWAN also optionally performs compression, encryption and PPP formatting if
this is not supported by the underlying NIC hardware. NDISWAN contains a
private interface for communication between NDISTAPI and the NIC driver. It
also maps protocol bindings to active call connections.
<P>
<LI>
An intermediate driver layered below NDIS that depends on an underlying driver
of a device other than a NIC
<P>
For example, an intermediate driver might handle network I/O requests for a
device connected to a serial port. Such an intermediate driver would export a
set of Miniport<I>Xxx</I>&nbsp;functions to communicate with NDIS at its upper edge
and use standard Windows NT IRPs to communicate with the underlying serial
device driver at its lower edge. 
</UL>
<P>
Figure 1.1 shows these two types of intermediate drivers.
<P>
<IMG SRC="../art/id_1.gif" BORDER=0>
<P>
<B>Figure 1.1    Supported Intermediate Driver Configurations</B>
<P>
An NDIS intermediate driver interfaces to NDIS to forward packets sent by a
driver above and to pass them to a driver below. When an intermediate driver
receives packets from an underlying driver, it indicates them to the driver
above either by calling a filter-specific <B>NdisM</B><I>Xxx</I><B>IndicateReceive</B>
function or <B><A HREF="../../nr/src/103ndisx_107.htm">NdisMIndicateReceivePacket</A></B>.
<P>
An intermediate driver calls NDIS to open and establish a binding to an
underlying NIC driver or intermediate NDIS driver that exports a set of
Miniport<I>Xxx</I>&nbsp;functions at its upper edge. An intermediate driver
provides MiniportSetInformation and MiniportQueryInformation functions to
process set and query requests from higher level driver(s) and, perhaps, to
pass them through to a lower level NDIS driver by calling <B><A HREF="../../nr/src/103ndisx_188.htm">NdisRequest</A></B>.
<P>
An intermediate driver calls NDIS-provided functions to send packets on to
still lower level NDIS drivers to the net. For instance, an intermediate
driver must call <B><A HREF="../../nr/src/103ndisx_193.htm">NdisSend</A></B>&nbsp;or <B><A HREF="../../nr/src/103ndisx_194.htm">NdisSendPackets</A></B>
to send a packet or array of packets. If the intermediate driver is layered
over a nonNDIS NIC driver, the send interface is opaque to NDIS after it calls
the MiniportSend or MiniportSendPackets function of the intermediate driver. 
<P>
NDIS provides a set of <B>Ndis</B><I>Xxx</I>&nbsp;functions and macros that hides
the details of the underlying operating system. For instance, an intermediate
driver can call <B><A HREF="../../nr/src/103ndisx_110.htm">NdisMInitializeTimer</A></B>
to create a timer for synchronization purposes and <B><A HREF="../../nr/src/103ndisx_78.htm">NdisInitializeListHead</A></B>
to create a linked list. Intermediate drivers use NDIS functions in order to
be more portable across Microsoft operating systems that support the Win32
interface. 
<H5>Pageable and Discardable Code </H5>
<P>
As explained in Part 1, every Miniport<I>Xxx</I>&nbsp;or Protocol<I>Xxx</I>
function runs at a particular IRQL. The possible IRQLs for these functions
range between PASSIVE_LEVEL up to and including DISPATCH_LEVEL in intermediate
drivers. 
<P>
Intermediate driver functions that always run at IRQL PASSIVE_LEVEL can be
marked as pageable using the NDIS_PAGABLE_FUNCTION macro. Driver developers
are encouraged to designate code as pageable whenever possible, freeing system
space for code that must be memory-resident. A driver function that runs at
IRQL PASSIVE_LEVEL can be made pageable as long as it neither calls nor is
called by any function that runs at IRQL &gt;= DISPATCH_LEVEL, for instance a
function that acquires a spin lock. Acquiring a spin lock causes the IRQL of
the acquiring thread to be raised to IRQL DISPATCH_LEVEL. A function, such as
ProtocolBindAdapter, that runs at IRQL PASSIVE_LEVEL, must not call NDIS
functions that run at IRQL &gt;= DISPATCH_LEVEL if ProtocolBindAdapter is
marked as pageable code. For more information about NDIS functions that run at
raised IRQL, see the <I>Network Driver Reference</I>, which specifies the IRQL
for each of the <B>Ndis</B><I>Xxx</I>&nbsp;functions. 
<P>
The <B>DriverEntry</B>&nbsp;function of an intermediate driver should be specified
as initialization-only code, using the NDIS_INIT_FUNCTION macro. Code
identified with this macro is assumed to only run once at system
initialization time, and as a result, is only mapped during that time. After <B>DriverEntry</B>
returns, code marked with the NDIS_INIT_FUNCTION macro is discarded. 
<H5>Synchronizing Access to Shared Resources</H5>
<P>
Access to any driver-allocated shared resource must be synchronized if the
resource can be simultaneously shared by two driver functions or if the
intermediate driver can run on an SMP machine such that the same driver
function can be attempting to simultaneously access the resource from more
than one processor. For instance, if a driver maintains a shared queue, a spin
lock can be used to serialize access to that queue. The spin lock should be
initialized when the queue is created by calling <B><A HREF="../../nr/src/103ndisx_13.htm">NdisAllocateSpinLock</A></B>.
<P>
However, care should be taken not to overprotect a shared resource, such as a
queue. For example, some read operations can be done without serialization.
Any operation that manipulates the queue links however, must be serialized.
Spin locks always should be used sparingly and held for as short a time as
possible. See the <I>Kernel-Mode Driver Design Guide</I>&nbsp;for an in-depth
discussion of spin locks.
<P></FONT>
</BODY>
</HTML>
