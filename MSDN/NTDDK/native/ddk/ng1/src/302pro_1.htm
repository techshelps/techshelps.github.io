<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chapter 2  NDIS Protocol Drivers</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<DL>
<H1><A NAME="DDK_NDIS_Protocol_Drivers_NG"></A>Chapter 2  NDIS Protocol Drivers</H1>
<P>
This describes the features of an NDIS driver that exports a set of Protocol<I>Xxx</I>
functions at its lower edge. Such a protocol driver communicates with NDIS to
send and receive network packets and to bind to and use an underlying miniport
NIC driver or intermediate NDIS driver that exports a Miniport<I>Xxx</I>
interface at its upper edge. 
<P>
Such an NDIS protocol driver might support TDI at its upper edge, or it might
export a private interface to a higher level kernel-mode driver, possibly
through a transport stack of drivers, including one that supports TDI at the
top of the stack. For instance, an NDIS protocol driver can be the lowest
module of a multimodule transport implementation of a standard protocol such
as TCP/IP with TDI support in the highest module. 
<P>
Protocol drivers that communicate with lower level NDIS drivers to send and
receive packets always use NDIS-provided functions to communicate with the
lower level NDIS drivers. For instance, a protocol driver must call <B>NdisSend</B>
or <B>NdisSendPackets</B>&nbsp;to send a packet or packets to a lower level NDIS
driver and must call <B>NdisRequest</B>&nbsp;to make or pass through query- or
set-information requests with network related OID_<I>XXX</I>s that are
supported by underlying drivers. 
<P>
NDIS also provides a set of <B>Ndis</B><I>Xxx</I>&nbsp;functions that hide the
details of the underlying operating system. For instance, a protocol driver
can call <B>NdisInitializeEvent</B>&nbsp;to create an event for synchronization
purposes and <B>NdisInitializeListHead</B>&nbsp;to create a linked list. Protocol
drivers that use the NDIS versions of such functions are more portable across
Microsoft operating systems that support the Win32 interface. However,
protocol drivers also can call OS-specific kernel-mode support routines, such
as <B>KeInitializeEvent</B>&nbsp;to create an event or <B>KeWaitForSingleObject</B>
to synchronize two threads of execution. The Windows NT kernel-mode support
routines are documented in the <I>Kernel-Mode Drivers Reference.</I>
</DL>
<H4>Pageable and Discardable Code</H4>
<P>
Every Protocol<I>Xxx</I>&nbsp;function runs at an IRQL in the range from
PASSIVE_LEVEL to DISPATCH_LEVEL. 
<P>
Functions that run exclusively at IRQL PASSIVE_LEVEL should be marked as
pageable using the NDIS_PAGABLE_FUNCTION macro. Driver developers should
designate code as pageable whenever possible, freeing system space for code
that must be memory-resident. A driver function that runs at IRQL
PASSIVE_LEVEL can be made pageable as long as it neither calls nor is called
by any function that runs at IRQL &gt;= DISPATCH_LEVEL, for instance a
function that acquires a spin lock. Acquiring a spin lock causes the IRQL of
the acquiring thread to be raised to IRQL DISPATCH_LEVEL. A driver function,
such as ProtocolBindAdapter, that runs at IRQL PASSIVE_LEVEL must not call any
<B>Ndis</B><I>Xxx</I>&nbsp;functions that run at IRQL &gt;= DISPATCH_LEVEL if that
driver function is marked as pageable code. See the <I>Network Driver
Reference,</I>&nbsp;which specifies the IRQL for each <B>Ndis</B><I>Xxx</I>
function. 
<P>
The <B>DriverEntry</B>&nbsp;function of a protocol driver should be specified as
initialization-only code, using the NDIS_INIT_FUNCTION macro. Code identified
with this macro is assumed to only run once at system initialization time, and
as a result, is only mapped during that time. After a function marked as
initialization-only returns, it is discarded.
<P>
Access to any driver-allocated shared resource must be synchronized if the
resource can be simultaneously shared by two driver functions or if the
protocol driver can run on an SMP machine such that the same protocol driver
function can be attempting to simultaneously access a resource from more than
one processor. For instance, if a driver maintains a shared queue, a spin lock
can be used to serialize access to that queue. The spin lock should be
initialized when such a queue is created.
<P>
However, care should be taken not to overprotect a shared resource, such as an
internal driver queue. Some read-only operations can be done without
serializing access to a queue, but any operation that manipulates the queue
links must be serialized. Spin locks always should be used sparingly and held
as short a time as possible. See the <I>Kernel-Mode Drivers Design Guide</I>
for an in-depth discussion of spin locks.
<P></FONT>
</BODY>
</HTML>
