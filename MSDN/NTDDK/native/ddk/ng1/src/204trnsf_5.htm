<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.4.1  Steps in Sending</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Steps_in_Sending_NG"></A>4.4.1  Steps in Sending </H3>
<P>
The sequence of calls made by any miniport NIC driver to send a packet or
packets is dependent to some degree on the type of NIC the miniport manages.
However, there are certain steps that miniports for all types of devices have
in common. All miniports do the following:
<UL>
<LI>
Call <B><A HREF="../../nr/src/103ndisx_160.htm">NdisQueryPacket</A></B>&nbsp;to get a pointer
to the first buffer descriptor in the packet.
<P>
<LI>
Call <B><A HREF="../../nr/src/103ndisx_157.htm">NdisQueryBuffer</A></B>&nbsp;to get the base
virtual address for the buffer whose buffer descriptor was returned from <B>NdisQueryPacket</B>.
<P>
<LI>
Call <B><A HREF="../../nr/src/103ndisx_49.htm">NdisGetNextBuffer</A></B>&nbsp;to get the
next buffer descriptor in a chain of descriptors in a packet.
<P>
<LI>
Call <B>NdisRawWritePort</B><I>Xxx</I>&nbsp;to at least program the NIC and
possibly to move the data.
</UL>
<P>
A miniport is not required to check the packet size; rather the miniport
should assume that a protocol driver will never send a packet that is too
large. The protocol driver queries the miniport during initialization to
determine the maximum packet size it supports and is responsible for passing
only packets of a size supported by the miniport. 
<P>
Whether a miniport exports MiniportSendPackets or MiniportSend, a miniport can
be passed a packet for which it has no send resources. The miniport can:
<OL>
<LI>
Return the packet with a status of NDIS_STATUS_RESOURCES in which case NDIS
internally queues the packet and all subsequent packets in a packet array.
Later if the miniport completes a send for which it previously returned a
pending status, it must call <B><A HREF="../../nr/src/103ndisx_127.htm">NdisMSendComplete</A></B>,
or, before it completes the send, call <B><A HREF="../../nr/src/103ndisx_128.htm">NdisMSendResourcesAvailable</A></B>
when the miniport has available send resources. <B>NdisMSendResourcesAvailable</B>
can be called <I>only</I>&nbsp;in the window between the return of
NDIS_STATUS_PENDING and a call to <B>NdisMSendComplete</B>. 
<P>
If a miniport supports full-duplex operation, neither <B>NdisMSendComplete</B>
nor <B>NdisMSendResourcesAvailable</B>&nbsp;can be called from MiniportSend or
MiniportSendPackets. They may, for instance, be called from
MiniportHandleInterrupt when an interrupt is processed. When the miniport
indicates that it has available send resources, NDIS will send the the first
packet on its send queue to MiniportSend or an array of queued packets to
MiniportSendPackets.
<P>
<LI>
The miniport can queue the send request internally. A miniport can use the
miniport-reserved fields in the packet header to link queued packets, perhaps
linked to its adapter-specific context structure. If the miniport queues a
packet, it must return NDIS_STATUS_PENDING as the status for the queued
packet. A miniport might implement packet queuing to avoid the latency
incurred when the packet is returned to NDIS and later resubmitted to the
miniport, resulting in increased throughput. WAN miniport NIC drivers always
queue packets, internally. It is an error for a WAN miniport to return
NDIS_STATUS_RESOURCES. 
</OL>
<P>
In the case of MiniportSend, if the sending protocol driver and the miniport
have agreed upon a set of flags that affect how a packet is sent, the miniport
should use the <I>Flags</I>&nbsp;passed to MiniportSend to handle the send
appropriately. NDIS does not define the meaning or actions associated with the
flags
<P>
In the case of MiniportSendPackets, the miniport is responsible for sending
packets in the priority order if specified by the protocol driver. NDIS does
not order packets it receives from a protocol driver but simply passes them on
to the miniport in the order they were received.
<H4>Sending a Packet on a Busmaster DMA Device</H4>
<P>
Generally, a miniport that manages a busmaster DMA device exports
MiniportSendPackets to get the best performance from its NIC.
<P>
A busmaster DMA miniport calls <B><A HREF="../../nr/src/103ndisx_160.htm">NdisQueryPacket</A></B>
to read the packet length and to obtain a pointer to the first buffer
descriptor, as well as the number of buffer descriptors and the physical
segment count. 
<P>
The miniport may need to see if it has available transmit buffers and
available transmit buffer descriptors mapping buffers in the ring.  If either
is unavailable, the miniport either fails the call with NDIS_STATUS_RESOURCES,
returning the packet to NDIS or queues the packet internally and returns
NDIS_STATUS_PENDING. 
<P>
A DMA device can have an upper limit on the number of physical segments that
it can map for a single DMA operation. If a miniport is given a packet to send
that is too fragmented, it must copy the buffers chained to the packet into a
single transmit buffer. A miniport should allocate such a staging buffer and a
buffer descriptor to map it in MiniportInitialize. A miniport calls <B><A HREF="../../nr/src/103ndisx_115.htm">NdisMoveMemory</A></B>
to move data from each protocol-supplied buffer into this transmit staging
buffer. A miniport must only copy send data when the packet is too fragmented,
since copying to a staging buffer is an expensive operation and would
adversely affect performance if done too frequently. 
<P>
As a general guideline, if the buffer to be sent is &lt; 256 bytes, the
miniport can get improved performance by copying the data into a staging
buffer and passing a miniport-allocated descriptor for the buffer to <B>NdisMStartBufferPhysicalMapping</B>.
<P>
A miniport performs the following steps to send a packet using DMA.
<OL>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_136.htm">NdisMStartBufferPhysicalMapping</A></B>
to map the previously allocated shared memory buffer whose contents will be
sent. This call takes a Boolean argument, <I>WriteToDevice</I>, that indicates
whether data is being moved from host memory to the NIC or from the NIC to
host memory. For a send, <I>WriteToDevice</I>&nbsp;is set to TRUE. The miniport
must also supply the index of the map register it is using to map the buffer
and this index must be one of the registers returned from calling <B><A HREF="../../nr/src/103ndisx_85.htm">NdisMAllocateMapRegisters</A></B>
at miniport-initialization time. 
<P>
<LI>
If the miniport allocated cached memory for its transmit buffers, it calls <B><A HREF="../../nr/src/103ndisx_36.htm">NdisFlushBuffer</A></B>,
supplying the address of the buffer being sent. <B>NdisFlushBuffer</B>&nbsp;flushes
the processor cache line, ensuring that the memory contents seen by the NIC
and the miniport are the same. To ensure cache-coherency on all platforms, the
miniport should also call <B><A HREF="../../nr/src/103ndisx_142.htm">NdisMUpdateSharedMemory</A></B>.
<P>
<LI>
Programs the NIC for the transmission, for instance, by writing to the control
registers.
<P>
<LI>
When the send completes, the miniport calls <B><A HREF="../../nr/src/103ndisx_94.htm">NdisMCompleteDmaTransfer</A></B>
to release the map register. If the NIC interrupts at the completion of the
send, this call is made from MiniportHandleInterrupt. If the NIC is polled,
this call is made from the MiniportTimer function supplied to <B><A HREF="../../nr/src/103ndisx_132.htm">NdisMSetPeriodicTimer</A></B>
or <B><A HREF="../../nr/src/103ndisx_133.htm">NdisMSetTimer</A></B>&nbsp;(if the miniport does
not use a periodic timer), when the timer expires and the send is complete.
</OL>
<H4>Sending a Single Packet on a PIO Device</H4>
<P>
MiniportSend or MiniportSendPackets is called with a pointer to a packet
descriptor or to an array of pointers to packet descriptors specifying the
data to be sent. A miniport that controls a NIC that sends data using
programmed I/O performs the following steps in its send function:
<OL>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_160.htm">NdisQueryPacket</A></B>&nbsp;to get the
length of the packet. Checks that there are transmit resources available to
send the packet now. If not, returns NDIS_STATUS_RESOURCES or queues the
packet internally and returns from its send handler. If a packet is queued in
the miniport, the miniport must return NDIS_STATUS_PENDING for that packet.
The miniport should assume that it will always receive a packet of the proper
size, that is, the protocol driver will not attempt to send a packet that is
larger than the miniport supports. The protocol driver determines this size
during system initialization. If the miniport supports OOB data, it reads any
relevant data from the OOB block using NDIS macros. If send resources are
available, the NIC driver continues.
<P>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_160.htm">NdisQueryPacket</A></B>&nbsp;to get a pointer
to the first buffer descriptor in the packet.
<P>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_157.htm">NdisQueryBuffer</A></B>&nbsp;to obtain the
virtual address of the buffer containing the data to be sent and the length in
bytes of that buffer.
<P>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_173.htm">NdisRawWritePortUlong</A></B>&nbsp;to
write the length of the buffer to the port.
<P>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_170.htm">NdisRawWritePortBufferUlong</A></B>
to write the buffer whose address was returned from <B>NdisQueryBuffer</B>. 
<P>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_49.htm">NdisGetNextBuffer</A></B>&nbsp;to get the
next buffer in the packet.
<P>
<LI>
Repeats steps three through six until all the buffers in the packet have been
successfully sent.
<P>
<LI>
When MiniportSend is done with a packet, it returns the status as the status
of MiniportSend. If the status is not NDIS_STATUS_PENDING, the miniport
relinquishes the packet descriptor and the resources it specifies back to the
caller. MiniportSendPackets returns the status of the send in the <B>Send</B>
member of the OOB block for the packet descriptor. If the miniport returned a
pending status for any packet, it must call <B>NdisMSendComplete</B>&nbsp;when it
is done with the packet resources and is ready to relinquish it to the caller.
If the miniport calls <B>NdisMSendResourcesAvailable</B>&nbsp;to indicate it has
resources to accept a new send request; it must make this call before making a
call to <B>NdisMSendComplete</B>. 
</OL>
<H4>Sending a Packet Using On-Board Memory</H4>
<P>
A miniport that supports such a device calls <B><A HREF="../../nr/src/103ndisx_112.htm">NdisMMapIoSpace</A></B>
in MiniportInitialize to map the adapter’s on-board memory onto host memory
and to give the miniport a virtual address with which to refer to the memory.
A miniport sends data on this type of device by moving the buffers to be sent
into the mapped-memory and then writing to the port (or registers) it claimed
by calling <B><A HREF="../../nr/src/103ndisx_124.htm">NdisMRegisterIoPortRange</A></B>
in a device-specific way to cause the NIC to put the data on the medium. If
the miniport does not have any send resources available, it either queues the
packet(s) or returns the packet(s) to NDIS as described earlier.
<P>
If the miniport has send resources available, the sequence of calls it makes
is:
<UL>
<LI>
<B><A HREF="../../nr/src/103ndisx_160.htm">NdisQueryPacket</A></B>&nbsp;to get the start and
length of the packet containing the buffers to be sent.
<P>
<LI>
<B><A HREF="../../nr/src/103ndisx_157.htm">NdisQueryBuffer</A></B>&nbsp;to get the buffer
descriptor.
<P>
<LI>
<B><A HREF="../../nr/src/103ndisx_116.htm">NdisMoveToMappedMemory</A></B>&nbsp;to move
a buffer at a time to the mapped adapter memory buffer.
<P>
<LI>
<B><A HREF="../../nr/src/103ndisx_49.htm">NdisGetNextBuffer</A></B>&nbsp;to retrieve the
next buffer from the packet and again, call <B>NdisMoveToMappedMemory</B>.
Repeat these two calls until all the buffers have been transferred.
<P>
<LI>
<B>NdisMRawWritePort</B><I>Xxx</I>&nbsp;or possibly <B>NdisWriteRegister</B><I>Xxx</I>
to cause the send to occur in a device-specific manner.
</UL>
<P>
The miniport should use the length returned from <B>NdisQueryPacket</B>&nbsp;to
make sure that there is enough room in the on-board memory to contain all the
buffers in the packet before starting the copy. If the adapter memory does not
have enough free space for the current packet, the miniport can return a
status of NDIS_STATUS_RESOURCES if there is not enough free on-board memory,
in which case, NDIS will queue the packet and resend it later when the
miniport indicates that it has available resources. Alternatively, the
miniport can return NDIS_STATUS_PENDING, queueing the packet internally. 
<H4>Sending a Packet on a Slave DMA Device</H4>
<P>
A slave DMA NIC uses the system DMA controller to transfer data from a packet
supplied to its send handler, typically MiniportSend, to the NIC for
transmission on the network. 
<P>
For any packet for which the miniport has send resources, a miniport for a
slave DMA NIC does the following:
<UL>
<LI>
Calls <B><A HREF="../../nr/src/103ndisx_134.htm">NdisMSetupDmaTransfer</A></B>&nbsp;to
set up the system DMA controller for the send. The miniport passes the handle
to a DMA channel it allocated during miniport initialization by calling <B><A HREF="../../nr/src/103ndisx_122.htm">NdisMRegisterDmaChannel</A></B>,
a pointer to the host memory buffer containing the data to be sent, an offset
into the buffer, the length of data, and a Boolean that indicates the
direction of the transfer; in this case, from host memory to the device. On
return from <B>NdisMSetupDmaTransfer</B>, the controller is programmed to
transfer the data including ensuring that the buffer is cache-coherent.
<P>
<LI>
Performs device-dependent steps to cause the transfer, for instance by calling
<B>NdisRawWritePort</B><I>Xxx</I>.
<P>
<LI>
When the transfer is complete, the miniport calls <B><A HREF="../../nr/src/103ndisx_94.htm">NdisMCompleteDmaTransfer</A></B>.
</UL>
<P>
Generally, the miniport will set up the complete buffer for transfer. However,
if the size of the buffer is greater than the DMA constraints of the device,
the miniport uses the length and offset parameters to send a subrange of the
buffer. If the buffer to be sent is &lt; 256 bytes, the miniport can get
improved performance by copying the data into a staging buffer and passing a
miniport-allocated descriptor for the buffer to <B>NdisMSetupDmaTransfer</B>.
<P></FONT>
</BODY>
</HTML>
