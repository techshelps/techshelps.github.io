<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.13  Shutdown</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Shutdown_NG"></A>6.13  Shutdown</H2>
<P>
A session begins when a miniport successfully completes an
OID_TAPI_PROVIDER_INITIALIZE request. Within a session, one or more lines can
be opened with an OID_TAPI_OPEN request, and on a line, one or more calls can
be established by OID_TAPI_MAKE_CALL, OID_TAPI_DIAL, or OID_TAPI_ANSWER
requests. During the time a line is up, many calls can be established and then
closed or dropped. During a session, one or more lines can go through
transitions from open to closed many times. How a miniport handles such
transitions is described here.
<H4>Closing a Call</H4>
<P>
An in-process call can be closed either by the local node or by the remote
node. The call can be closed on the local node, either because the last
application with a handle to the call has closed the handle, or perhaps
because the miniport driver’s MiniportHalt or MiniportReset has been called.
If the remote node hangs up an in-process call, the miniport must indicate
this status change to upper layers.
<P>
If an application on the local node closes the call, MiniportSetInformation
will be called either with an OID_TAPI_DROP request followed by an
OID_TAPI_CLOSE_CALL, or it will simply be called with an OID_TAPI_CLOSE_CALL.
<P>
If the miniport receives an OID_TAPI_DROP request, it must do the following:
<OL>
<LI>
Drop the call.
<P>
<LI>
Change the status of the call to LINECALLSTATE_IDLE and report the state
change by calling <B><A HREF="../../nr/src/103ndisx_108.htm">NdisMIndicateStatus</A></B>.
</OL>
<P>
The handles for the dropped call, <B>htCall</B>&nbsp;and <B>hdCall</B>&nbsp;remain
valid. The miniport must not deallocate, reuse, or otherwise modify the state
associated with the <B>hdCall</B>&nbsp;that it created for the call instance, since
the miniport can receive queries related to the call, for instance a request
for statistics related to the call. If MiniportHalt or MiniportReset is
called, the miniport should disconnect the call but retain the state
maintained for the call instance until the miniport receives an
OID_TAPI_CLOSE_CALL request.
<P>
MiniportSetInformation can also receive an OID_TAPI_CLOSE_CALL request when
the last application with an open handle to the call instance closes the
handle. The miniport <I>cannot</I>&nbsp;fail this close call request. After
MiniportSetInformation returns after processing this request, <B>htCall</B>&nbsp;is
no longer valid.
<P>
A miniport must be prepared to handle timing issues involving such occurrences
as getting an OID_TAPI_CLOSE_CALL before getting an OID_TAPI_DROP. If the
miniport gets an OID_TAPI_CLOSE_CALL without a preceding OID_TAPI_DROP, it
should behave as if it had received both a drop and a close call request. If
the miniport receives a drop after a close call request has already closed the
referenced call, the call handle is no longer valid and the miniport should
return an appropriate error message. 
<P>
If the miniport detects that the remote node has dropped the call, the
miniport should change the call state to LINECALLSTATE_DISCONNECTED and
indicate the change by calling <B>NdisMIndicateStatus</B>&nbsp;passing the <B>htCall</B>
for this call instance. After the state change is propagated to the connected
application on the local node, the miniport will receive an OID_TAPI_DROP
followed by an OID_TAPI_CLOSE_CALL, or perhaps just the OID_TAPI_CLOSE_CALL
request. The miniport should handle the drop and close call requests as
described earlier. 
<H4>Closing a Line</H4>
<P>
A line is closed when the last application with an open handle to the line has
closed the handle. When the miniport subsequently receives an OID_TAPI_CLOSE,
it should tear down the line instance, that is, any state related to the line
maintained by the miniport can be reused or deallocated because the
information is no longer valid. 
<P>
An OID_TAPI_CLOSE call <I>must</I>&nbsp;succeed if the line handle, <B>htLine</B>,
passed in the call exists and is still valid. A miniport will never receive an
OID_TAPI_CLOSE request for a line if there are calls on the line. All existing
calls on a line will be closed with an OID_TAPI_CLOSE_CALL request before the
line-close request is made. 
<P>
Existing calls must be closed when a line is closed; the miniport should drop
those calls and clean up their state. The miniport should also change the
state of the line to idle. Any handle the miniport has for the line is no
longer valid. If the miniport receives any requests which pass the <B>htLine</B>
handle or any <B>htCall</B>&nbsp;after the close request is received, such
request(s) must be failed with an appropriate status.
<H4>Closing a Session</H4>
<P>
Session termination can be initiated by either the upper layers or a WAN
miniport NIC driver. When the last client process has detached from the
higher-level Telephony module, the NDISTAPI driver will be informed that it
needs to terminate its session with each of the registered adapters. The
NDISTAPI driver does this by calling <B>NdisRequest</B>&nbsp;specifying
OID_TAPI_PROVIDER_SHUTDOWN. Upon receiving this request, NDISWAN will call the
miniport NIC driver’s MiniportSetInformation function, which should terminate
any related activities it has in progress on the specified adapter and release
any relevant resources.
<P>
Driver-initiated session termination can occur when the miniport NIC driver is
being unloaded in its MiniportHalt function. Typically, the miniport NIC
driver would complete any outstanding NDISTAPI driver requests and notify the
NDISWAN that its line devices are going off-line by calling <B>NdisMIndicateStatus</B>.
NDISWAN would, in turn, call the NDISTAPI driver to deregister the adapter. If
the miniport NIC driver were reloaded again later, it would go through the
same initialization process described previously.
<P>
The miniport NIC driver might also initiate session termination if it
underwent some dynamic reconfiguration that necessitated a complete
reinitialization of all clients and drivers. For example, if an adapter’s
line-device modeling (for example, the number of line devices supported) was
changed on the fly, the miniport would call <B>NdisMIndicateStatus</B>&nbsp;with a
LINE_LINEDEVSTATE event and the LINEDEVSTATE_REINIT flag set.
<P></FONT>
</BODY>
</HTML>
