<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.5  Setting Up Handles</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Setting_Up_Handles_NG"></A>6.5  Setting Up Handles</H2>
<P>
After the NDISTAPI driver has initialized a miniport as a provider, the
miniport can expect a request to open a line device at its
MiniportQueryInformation function specifying OID_TAPI_OPEN and the appropriate
parameters. Upon receiving an open request the miniport would typically do the
following: 
<UL>
<LI>
Mark the line device as open in the miniport’s internal data structures.
<P>
<LI>
Save the NDISTAPI driver’s handle to the line device (passed in the <B>htLine</B>
member), which is to be used in subsequent event notifications.
<P>
<LI>
Return its own handle to the line device (passed back in the <B>hdLine</B>
member). 
</UL>
<P>
Once again, the impetus for this request would be a client process calling <B>lineOpen</B>.
<P>
After a client process has successfully opened a line, it can place a call on
that line by calling <B>lineMakeCall</B>. This will result in the NDISTAPI
driver’s calling <B><A HREF="../../nr/src/103ndisx_188.htm">NdisRequest</A></B>&nbsp;with an
OID_TAPI_MAKE_CALL, specifying the NDISTAPI-supplied handle to the line in the
<B>htLine</B>&nbsp;member, and the NDISTAPI-supplied handle to the call in the <B>htCall</B>
member. This request is passed to the miniport’s MiniportQueryInformation
function, specifying OID_LINE_MAKE_CALL. If the NIC driver can successfully
create the call, it passes back its own handle to the call in the <B>hdCall</B>
member.
<P>
The two-stage <B>ht</B><I>Xxx</I>/<B>hd</B><I>Xxx</I>&nbsp;(“handle of TAPI object
Xxx/handle of Driver object Xxx”) handle scheme provides both the NDISTAPI
driver and the WAN miniport NIC driver the flexibility of defining their own
means of reference for the same logical object. Requests made to NIC drivers
specify driver handles (<B>hdLine</B>s and <B>hdCall</B>s), while
notifications made to the NDISTAPI driver contain TAPI handles (<B>htLine</B>s
and <B>htCall</B>s). In the already mentioned cases where the miniport NIC
driver is defining its driver handle to some object (for example, <B>hdLine</B>,
<B>hdCall</B>), it is typically to the advantage of the NIC driver to specify
a pointer to the appropriate driver-internal data structure that represents
the object. 
<P>
When the client process has finished with the call it will call <B>lineDrop</B>
to drop the call, and then <B>lineDeallocateCall</B>&nbsp;to free the call
instance. This will result in the NDISTAPI driver sending two more requests,
OID_TAPI_DROP and OID_TAPI_CLOSE_CALL, respectively, through NDISWAN to the
miniport NIC driver to drop the call and deallocate the call instance. It is
also possible that the miniport will get an OID_TAPI_CLOSE_CALL request
without a preceding OID_TAPI_DROP, in which case the miniport should drop the
call and deallocate the call instance as if it had received both OIDs.
<P>
Finally, when the last TAPI client has called <B>lineClose</B>, the NDISTAPI
driver will call <B>NdisRequest</B>&nbsp;to send the miniport an OID_TAPI_CLOSE
request at its MiniportSetInformation function. An OID_TAPI_CLOSE can also be
received on an active line. In this case, the miniport must complete or abort
all outstanding calls and asynchronous requests on the device and close the
line. An OID_TAPI_CLOSE request with a valid <B>hdLine</B>&nbsp;<I>cannot</I>&nbsp;be
failed.
<P></FONT>
</BODY>
</HTML>
