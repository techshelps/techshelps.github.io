<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.2  DPC Handler</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_DPC_Handler_NG"></A>4.2  DPC Handler</H2>
<P>
Every miniport that manages a device that interrupts must have a
MiniportHandleInterrupt function. Even if NDIS completely handles the
interrupt, it will always queue a DPC for the miniport, causing the miniport’s
MiniportHandleInterrupt handler to run. If MiniportISR processes an interrupt,
it controls whether MiniportHandleInterrupt is queued by the value it returns
in the <I>InterruptRecognized</I>&nbsp;and <I>QueueMiniportHandleInterrupt</I>
arguments. If MiniportISR sets both to TRUE, MiniportHandleInterrupt is queued
for execution at IRQL DISPATCH_LEVEL; if it sets <I>InterruptRecognized</I>&nbsp;to
FALSE, MiniportHandleInterrupt will not be queued.
<P>
When MiniportHandleInterrupt is called, interrupts have been disabled on the
NIC. MiniportHandleInterrupt should read whatever data it needs to finish
processing the interrupt-driven I/O operation, and then reenable interrupts on
the NIC, either by letting NDIS call the miniport’s MiniportEnableInterrupt
function after it returns control or by enabling the interrupt from within the
MiniportHandleInterrupt function, which is faster. Until the interrupts are
reenabled, no further interrupts can occur on the NIC. So that no receive data
is missed, MiniportHandleInterrupt should attempt to reenable interrupts as
quickly as possible.
<P>
Assuming it uses interrupts, a miniport handles data receives and send
completes in the context of MiniportHandleInterrupt. For instance, if
MiniportHandleInterrupt determines that the reason for the interrupt is a
receive, it will indicate the data up by calling NDIS in the context of the
DPC.  <A HREF="204trnsf_10.htm">Section 4.6</A>&nbsp;describes how a miniport
processes receives.
<P>
If the miniport determines that the reason for the interrupt is a send
completion, the miniport calls <B><A HREF="../../nr/src/103ndisx_127.htm">NdisMSendComplete</A></B>
to signify the completion of a packet previously sent to MiniportSend or
MiniportSendPackets which returned NDIS_STATUS_PENDING. The send operations of
a miniport are described in <A HREF="204trnsf_4.htm">Section 4.4</A>.
<P>
When a miniport is processing a receive, it must not reenable interrupts until
MiniportTransferData either has transferred the incoming data to a protocol
driver-supplied packet if any protocol driver wants the data or has passed up
an entire miniport-allocated packet or array of packets containing the
received data. If a miniport-allocated packet is passed up to a protocol
driver, and the protocol keeps the packet, the miniport must supply a new
empty packet for the next receive. After it has completely processed the
receive and is prepared for the next receive, the miniport can reenable
interrupts.
<P></FONT>
</BODY>
</HTML>
