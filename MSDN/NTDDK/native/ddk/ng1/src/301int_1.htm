<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>1.1  Intermediate Driver DriverEntry Function</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Intermediate_Driver_DriverEntry_Function_NG"></A>1.1  Intermediate Driver DriverEntry Function</H2>
<P>
An intermediate driver’s initial required entry point must be explicitly named
<B>DriverEntry</B>&nbsp;so that the loader can properly identify it. All other
exported driver functions, described here as Miniport<I>Xxx</I>&nbsp;and Protocol<I>Xxx</I>
can have any developer-specified name since they are passed as addresses to
NDIS. The definition of <B>DriverEntry</B>&nbsp;is that of any Windows NT
kernel-mode driver. 
<P>
<B>NTSTATUS</B><BR>
&nbsp; &nbsp; <B>DriverEntry</B>(<BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PDRIVER_OBJECT  </B><I>DriverObject</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PUNICODE_STRING</B>&nbsp; <I>RegistryPath</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
If the driver exports a set of standard kernel-mode driver functions in
addition to the Protocol<I>Xxx</I>&nbsp;functions, it must write the addresses of
those standard functions in the driver object passed to <B>DriverEntry</B>. 
<P>
In an intermediate driver, <B>DriverEntry</B>&nbsp;must at a minimum:
<OL>
<LI>
Call <B><A HREF="../../nr/src/103ndisx_111.htm">NdisMInitializeWrapper</A></B>&nbsp;and
save the handle returned at <I>NdisWrapperHandle</I>. 
<P>
<LI>
Call either <B><A HREF="../../nr/src/103ndisx_72.htm">NdisIMRegisterLayeredMiniport</A></B>
or <B><A HREF="../../nr/src/103ndisx_125.htm">NdisMRegisterMiniport</A></B>&nbsp;to
register the driver’s Miniport<I>Xxx</I>&nbsp;functions, passing the handle
obtained in Step 1. 
<P>
<LI>
Call <B><A HREF="../../nr/src/103ndisx_185.htm">NdisRegisterProtocol</A></B>&nbsp;to
register the driver’s Protocol<I>Xxx</I>&nbsp;functions if the driver subsequently
binds itself to an underlying NDIS driver. 
</OL>
<P>
<B>DriverEntry</B>&nbsp;can initialize spin locks for any globally shared resources
the intermediate driver allocates, such as structures and memory areas the
driver uses to track connections and to track sends in progress. 
<P>
If <B>DriverEntry</B>&nbsp;fails to allocate any resources the driver needs to
carry out network I/O operations, it should release any previously allocated
resources and return an appropriate error status. For example, if <B>DriverEntry</B>
has called <B>NdisMInitializeWrapper</B>, it must call <B><A HREF="../../nr/src/103ndisx_209.htm">NdisTerminateWrapper</A></B>.
<P>
An intermediate driver’s <B>DriverEntry</B>&nbsp;function can perform some global
initialization steps. However, if an intermediate driver provides a
ProtocolBindAdapter function, which opens and binds to an underlying device as
described in <A HREF="301int_5.htm">Section
1.2</A>, such a driver can defer allocating binding-related system resources to
ProtocolBindAdapter. ProtocolBindAdapter performs the bind and allocates
resources as needed for the device passed at <I>DeviceName</I>. <B>DriverEntry</B>
must <I>always</I>&nbsp;initialize the wrapper and register as a miniport driver.
It also must register as a protocol driver if the intermediate driver also
exports a set of Protocol<I>Xxx</I>&nbsp;functions. 
<P>
If the intermediate driver only exports a set of Miniport<I>Xxx</I>&nbsp;functions,
it registers only those functions with the NDIS library, as described next. 
<P></FONT>
</BODY>
</HTML>
