<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.1.3.1  Providing Interrupt Support</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Providing_Interrupt_Support_NG"></A>3.1.3.1  Providing Interrupt Support </H4>
<P>
A miniport can, but is not always required to, provide an interrupt handler.
For instance, a miniport that manages a non-interrupting device and polls its
device with a MiniportTimer function cannot depend on interrupts and thus does
not have an interrupt handler. A miniport for a NIC with a shared interrupt
must always provide an interrupt handler. The definition of the interrupt
function follows.
<P>
<B>VOID<BR>
</B>&nbsp; &nbsp; <B>MiniportISR(<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>OUT PBOOLEAN</B>&nbsp; <I>InterruptRecognized</I><B>,</B><I><BR>
</I>&nbsp; &nbsp; &nbsp; &nbsp; <B>OUT PBOOLEAN</B>&nbsp; <I>QueueMiniportHandleInterrupt</I><B>,</B><I><BR>
</I>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN NDIS_HANDLE</B><I>&nbsp; MiniportAdapterContext<BR>
</I>&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
When any network device interrupts, NDIS fields the interrupt; that is, NDIS
is always called first when a NIC interrupts. NDIS determines which miniport
the interrupt belongs to. Then NDIS either calls the appropriate miniport’s
MiniportISR function, or handles the interrupt for the miniport if the
miniport has specified in its call to <B><A HREF="../../nr/src/103ndisx_123.htm">NdisMRegisterInterrupt</A></B>
that it does not want to have its ISR called. If NDIS does not call a
miniport’s ISR function, NDIS disables further interrupts by calling the
miniport’s MiniportDisableInterrupt function and then queues the miniport’s
MiniportHandleInterrupt DPC function. 
<P>
If a miniport must or chooses to handle its device interrupts, it registers
its ISR handler in NDIS_MINIPORT_CHARACTERISTICS and indicates that it wants
its ISR handler called by setting the <I>RequestIsr</I>&nbsp;argument of <B>NdisMRegisterInterrupt</B>
to TRUE. 
<P>
A miniport for a NIC that interrupts must provide an ISR handler if any of the
following is true.
<UL>
<LI>
If the interrupt is shared, a miniport must have an ISR and must set <I>RequestIsr</I>
to TRUE when it calls <B>NdisMRegisterInterrupt</B>. In this case, when the
device interrupts, the ISR of the driver for each device on the bus is called.
Each ISR must determine if the interrupt was generated by its device. A
miniport’s ISR returns TRUE in the <I>InterruptRecognized</I>&nbsp;argument to
MiniportISR if its NIC generated the interrupt and, in addition, if the
miniport wants its DPC queued, it returns TRUE in the <I>QueueMiniportHandleInterrupt</I>
argument. If the miniport does not recognize the interrupt, its ISR returns
FALSE as soon as possible in the <I>InterruptRecognized</I>&nbsp;argument, and
FALSE in <I>QueueMiniportHandleInterrupt</I>. For some types of interrupts, a
miniport can return <I>InterruptRecognized</I>&nbsp;equal to TRUE and <I>QueueMiniportHandleInterrupt
</I>equal to FALSE, for instance if it can quickly and completely process the
interrupt in the ISR.
<P>
<LI>
If there is state in the device registers that must be captured at DIRQL, a
miniport must have an ISR. When NDIS handles an interrupt, it does not save
any NIC state on behalf of the miniport. Therefore, state that disappears when
the ISR returns control can be captured only if the miniport registers and
uses an <B>ISRHandler</B>. 
</UL>
<P>
If a device interrupts but the interrupt is not shared, the miniport can
request that NDIS completely process the interrupt by specifying <I>RequestIsr</I>
to FALSE in the miniport’s <B>NdisMRegisterInterrupt</B>&nbsp;call. When NDIS gets
the interrupt, NDIS calls the miniport’s MiniportDisableInterrupt function, to
disable further interrupts, queues the miniport’s MiniportHandleInterrupt
function and returns TRUE to notify the I/O system that it recognizes the
interrupt. MiniportHandleInterrupt must re-enable interrupts as soon as
practical, otherwise, NDIS reenables interrupts by calling the miniport’s
MiniportEnableInterrupt function if one exists.
<P>
Even if a miniport of a device that interrupts sets <I>RequestIsr</I>&nbsp;to
FALSE, the miniport sometimes must provide an <B>ISRHandler</B>. If a NIC can
generate an interrupt during the miniport’s initialization or when it is
halting, such an interrupt will not be handled by NDIS but will be passed to
the miniport. Therefore such a miniport must provide a MiniportISR function. 
<P>
In summary, a miniport must provide an ISR handler if it manages a device that
can interrupt during initialization or during a halt operation, if its NIC
shares an IRQ, or if, when its device interrupts, it must capture
interrupt-specific data at DIRQL. A miniport can specify that NDIS handle its
interrupts if  interrupts are not shared,  if there is no device state that
must be captured in the ISR at DIRQL, and if it can guarantee its NIC will not
interrupt during initialization or halting. The miniport requests that NDIS
handle interrupts by calling <B>NdisMRegisterInterrupt</B>&nbsp;with <I>RequestIsr</I>
set to FALSE and <I>SharedInterrupt</I>&nbsp;set to FALSE.
<P>
If a driver manages a device that does not interrupt, it typically polls its
device using a timer. This type of driver must initialize any timers it
requires for its operation in MiniportInitialize. See <A HREF="203entry_22.htm">Section
3.2.5</A>&nbsp;for more information.
<H5>Enabling and Disabling Interrupts</H5>
<P>
If the NIC does not generate an interrupt, the miniport does not need to
provide a MiniportEnableInterrupt or MiniportDisableInterrupt function. If a
miniport always handles its interrupts in a MiniportISR function, and
schedules a MiniportHandleInterrupt function, it might not provide specific
MiniportEnableInterrupt or MiniportDisableInterrupt functions. Instead, such a
miniport can choose to disable interrupts within its ISR and enable them
within its DPC, without providing specific functions for this purpose. If a
miniport specifies that NDIS handle its interrupts, it must supply a
MiniportDisableInterrupt function and if it does not reenable interrupts in
its<B>&nbsp;</B>MiniportHandleInterrupt function, it must have a
MiniportEnableInterrupt function.
<H5>Combining Interrupts and Polling</H5>
<P>
Sometimes a driver developer can improve the performance of a driver by
combining polling a NIC with the use of interrupts. For instance, a driver can
be designed to enable interrupts for receive indications but disable them for
send-complete indications. A miniport might set a timer and, at timer
expiration, check for send completions. In addition, when an interrupt on a
receive occurs, the miniport also checks for send-completes. This is a
reasonable strategy when network traffic is high: the number of interrupts
handled is minimized, and no packets are missed. 
<P>
A driver that implements this strategy can also sample the traffic on the
network and, if traffic is high, it uses the strategy just described. If
traffic on the network is low, the driver should enable both send-complete and
receive interrupts because the number of interrupts is expected to be lower
than in a high traffic environment and the possibility of adversely affecting
the driver’s send performance exists.
<P>
A driver that uses both polling and interrupts disables interrupts when it is
using polling to manage its device and enables interrupts when using
interrupts to manage its device. The driver also can have NDIS process its
device’s interrupts when they are enabled, subject to the same restrictions as
already described. That is, that the interrupt is not shared, that any
information needed by the miniport can be captured in its
MiniportHandleInterrupt function, and that its NIC will never interrupt during
initialization or halting.
<P></FONT>
</BODY>
</HTML>
