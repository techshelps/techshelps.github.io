<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.1  Handling an Interrupt</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Handling_an_Interrupt_NG"></A>4.1  Handling an Interrupt</H2>
<P>
MiniportISR is passed two arguments, <I>InterruptRecognized</I>&nbsp;and <I>QueueMiniportHandleInterrupt</I>,
that must be set before returning. MiniportISR must set <I>InterruptRecognized</I>
to TRUE if it recognizes the interrupt or FALSE if it does not. If the
interrupt is shared, and the miniport does not recognize the interrupt, it
returns FALSE and the interrupt will be passed to the next possible ISR
function for this interrupt until a function recognizes the interrupt, or all
possible functions have been called. If MiniportISR recognizes the interrupt
and wants its MiniportHandleInterrupt queued, it must set <I>QueueMiniportHandleInterrupt</I>
to TRUE. NDIS does the actual queuing of the MiniportHandleInterrupt function
when MiniportISR returns. If the miniport sets <I>InterruptRecognized</I>&nbsp;to
FALSE, the value of <I>QueueMiniportHandleInterrupt</I>&nbsp;is assumed to be
FALSE.
<P>
While an ISR is executing, all other interrupts on the processor at the same
or lower IRQL are masked off. Therefore, it is important for a miniport to
minimize the time spent in MiniportISR. Otherwise, the overall performance of
the system degrades, as well as I/O throughput for the miniport.
<P>
It is important for a miniport that manages a NIC that shares an interrupt
with other devices on the same bus to quickly determine if the interrupt
belongs to it. If it does not, the miniport should set <I>InterruptRecognized</I>
to FALSE and return immediately. 
<P>
If the interrupt is shared and belongs to the miniport, or if the interrupt is
not shared but is recognized by the miniport (it is not spurious), the
miniport should disable interrupts on its NIC, and then capture the
interrupt-specific information it needs from the NIC registers, either
immediately in MiniportISR if absolutely necessary, or preferably in the
MiniportHandleInterrupt function, which runs at a lower IRQL. 
<P>
Interrupts must be disabled by MiniportISR to ensure that when
MiniportHandleInterrupt runs, no information in the device has been
overwritten by a subsequent interrupt. MiniportISR should read and save only
that information which cannot be accessed after it returns. Having done this,
MiniportISR should return.
<P>
If the miniport does not want its MiniportHandleInterrupt function queued, and
it disabled interrupts previously in MiniportISR, it must reenable the
interrupt on the NIC before returning from MiniportISR. 
<P>
Generally, MiniportISR determines and records the reason for the interrupt,
copies any volatile interrupt-specific information it needs to handle the
interrupt into a permanent structure, usually somewhere in the <I>MiniportAdapterContext</I>
passed to MiniportISR, and clears the interrupt on the NIC. 
<H4>Synchronizing with an ISR Function</H4>
<P>
A miniport’s MiniportISR function and its MiniportDisableInterrupt function
run at DIRQL. Other miniport code runs at IRQL &lt;= DISPATCH_LEVEL. To
prevent race conditions, any miniport function that shares resources with the
MiniportISR or MiniportDisableInterrupt function must synchronize access to
the shared resources. A function synchronizes with MiniportISR and
MiniportDisableInterrupt by calling <B><A HREF="../../nr/src/103ndisx_137.htm">NdisMSynchronizeWithInterrupt</A></B>,
supplying a MiniportSynchronizeISR function. MiniportSynchronizeISR runs at
DIRQL and can safely access the shared resource. 
<P>
For example, MiniportHandleInterrupt calls <B>NdisMSynchronizeWithInterrupt</B>
before clearing an interrupt status register. This NDIS call takes a <I>SynchronizeFunction</I>
argument. Within <B>NdisMSynchronizeWithInterrupt</B>, NDIS calls the
miniport’s <I>SynchronizeFunction</I>&nbsp;at DIRQL, so that this function can
safely clear the interrupt status register and be sure that MiniportISR or
MiniportDisableInterrupt are not modifying the same register at the same time.
<I>SynchronizeFunction</I>&nbsp;should execute as quickly as possible like the
MiniportISR and MiniportDisableInterrupt functions. 
<P>
The execution of MiniportISR and MiniportDisableInterrupt, both of which run
at DIRQL, is synchronized with a spin lock associated with the interrupt
object.
<P></FONT>
</BODY>
</HTML>
