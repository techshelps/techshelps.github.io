<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HwVidQueryDeviceCallback</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_HwVidQueryDeviceCallback_GG"></A>HwVidQueryDeviceCallback</H2>
<P>
<B>VP_STATUS HwVidQueryDeviceCallback(</B>
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>PVOID</B>&nbsp; <I>HwDeviceExtension</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>PVOID</B>&nbsp; <I>Context</I>,
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>VIDEO_DEVICE_DATA_TYPE</B>&nbsp; <I>DeviceDataType</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>PVOID</B>&nbsp; <I>Identifier</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>ULONG</B>&nbsp; <I>IdentifierLength</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>PVOID</B>&nbsp; <I>ConfigurationData</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>ULONG</B>&nbsp; <I>ConfigurationDataLength</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>PVOID</B>&nbsp; <I>ComponentInformation</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp; <B>ULONG</B>&nbsp; <I>ComponentInformationLength</I>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
&nbsp; &nbsp;);
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT></TABLE>
<P>
<B>HwVidQueryDeviceCallback</B>&nbsp;is passed in a call to <B>VideoPortGetDeviceData</B>
from the miniport’s <B>HwVidFindAdapter</B>&nbsp;function. <B>VideoPortGetDeviceData</B>
calls <B>HwVidQueryDeviceCallback</B>&nbsp;after collecting available configuration
information under the <B>\Registry\Machine\Hardware\Description</B>&nbsp;node of
the registry.
<H3>Parameters</H3>
<DL>
<DT>
<I>HwDeviceExtension</I>
<DD>
Points to the miniport driver’s per-adapter storage area.
<BR>
<DT>
<I>Context</I>
<DD>
Points to the context value set up by <B>HwVidFindAdapter</B>. Usually, it
points to the VIDEO_PORT_CONFIG_INFO buffer or to an offset in that buffer.
<BR>
<DT>
<I>DeviceDataType</I>
<DD>
Specifies the type of configuration information that was requested, which is
usually one of the following:
<P>
<B>VpBusData</B><BR>
<B>VpControllerData</B><BR>
<B>VpMonitorData</B>
<P>
The <B>VpControllerData</B>&nbsp;and <B>VpMonitorData</B>&nbsp;values have meaning only
on ARC-compliant (RISC) platforms. Miniport drivers of x86-type video adapters
usually specify <B>VpBusData</B>, particularly for adapters on EISA or MCA
buses. The <B>VpMachineData</B>&nbsp;value is defined for future versions of
Windows NT&reg;.
<BR>
<DT>
<I>Identifier</I>
<DD>
Points to the name of the device as determined by the ARC firmware. This
parameter should be used only on ARC-compliant platforms. Otherwise, this
pointer should be NULL.
<BR>
<DT>
<I>IdentifierLength</I>
<DD>
Specifies the size in bytes of the buffered <I>Identifier</I>&nbsp;string<I>.</I>
The value should be zero if the machine is not ARC-compliant.
<BR>
<DT>
<I>ConfigurationData</I>
<DD>
Points to hardware configuration data. The format of this data is determined
by the specified <I>DeviceDataType</I>&nbsp;and by the <B>AdapterInterfaceType</B>
value in the VIDEO_PORT_CONFIG_INFO.
<BR>
<DT>
<I>ConfigurationDataLength</I>
<DD>
Specifies the size in bytes of the <I>ConfigurationData</I>&nbsp;buffer. In effect,
this indicates how much information was collected from the registry and stored
in the <I>ConfigurationData</I>&nbsp;buffer allocated by <B>VideoPortGetDeviceBase</B>.
<BR>
<DT>
<I>ComponentInformation</I>
<DD>
Is reserved for system use.
<BR>
<DT>
<I>ComponentInformationLength</I>
<DD>
Is reserved for system use.
</DL>
<H3>Return Value</H3>
<P>
<B>HwVidQueryDeviceCallback</B>&nbsp;returns the status of the operation.
<H3>Comments</H3>
<P>
<B>HwVidQueryDeviceCallback</B>&nbsp;examines the <I>ConfigurationData</I>,
collected from the registry by <B>VideoPortGetDeviceData</B>. It uses this
information to locate an adapter it can support, to configure its adapter,
and, possibly, to fill in missing configuration information in the
VIDEO_PORT_CONFIG_INFO structure.
<P>
<B>HwVidQueryDeviceCallback</B>&nbsp;cannot pass access range values found in the <I>ConfigurationData</I>
to any <B>VideoPortRead</B><I>Xxx</I>&nbsp;or <B>VideoPortWrite</B><I>Xxx</I>
directly; such addresses first must be mapped by calling <B>VideoPortGetDeviceBase</B>.
<P>
If the <I>ConfigurationData</I>&nbsp;buffer has no access range information and the
miniport’s <B>HwVidFindAdapter</B>&nbsp;function has not already called <B>VideoPortGetBusData</B>
(or <B>VideoPortGetAccessRanges</B>), its <B>HwVidQueryDeviceCallback</B>
function can call <B>VideoPortGetBusData</B>. Access range information
returned by <B>VideoPortGetBusData</B>&nbsp;also must be passed to <B>VideoPortVerifyAccessRanges</B>.
<P>
If <B>VideoPortVerifyAccessRanges</B>&nbsp;returns NO_ERROR, the miniport driver
can call <B>VideoPortGetDeviceBase</B>&nbsp;to obtain mapped logical addresses that
it can use to communicate with the adapter by calling the <B>VideoPortRead</B><I>Xxx</I>
and/or <B>VideoPortWrite</B><I>Xxx</I>&nbsp;functions.
<P>
If it cannot get bus-relative access ranges values by calling <B>VideoPortGetDeviceData</B>,
<B>VideoPortGetBusData</B>, or <B>VideoPortGetAccessRanges</B>, a miniport
driver can use a set of driver-supplied default access-range values to find
its adapter. In these circumstances, the miniport must call <B>VideoPortVerifyAccessRanges</B>
with the miniport-supplied access ranges, and, then call <B>VideoPortGetDeviceBase</B>
only if <B>VideoPortVerifyAccessRanges</B>&nbsp;returned NO_ERROR. If a call to <B>VideoPortVerifyAccessRanges</B>
is unsuccessful, a given bus-relative range is already in use by the driver of
another device.
<H3>See Also</H3>
<P>
<B><A HREF="vpfncs_6.htm">VideoPortGetAccessRanges</A></B>, <B><A HREF="vpfncs_7.htm">VideoPortGetBusData</A></B>,
<B><A HREF="vpfncs_9.htm">VideoPortGetDeviceBase</A></B>, <B><A HREF="vpfncs_10.htm">VideoPortGetDeviceData</A></B>,
<B><A HREF="vpfncs_39.htm">VideoPortVerifyAccessRanges</A></B>
<P></FONT>
</BODY>
</HTML>
