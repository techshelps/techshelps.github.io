<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Printing a Print Job</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Printing_a_Print_Job_GG"></A>Printing a Print Job</H3>
<P>
When the spooler determines that a particular spooled job can be printed, it
calls the monitor’s implementations of <B><A HREF="pmonfncs_18.htm">StartDocPort</A></B>,
<B><A HREF="pmonfncs_19.htm">WritePort</A></B>, and <B><A HREF="pmonfncs_6.htm">EndDocPort</A></B>
to print the job.
<P>
On Windows NT, a printer is actually a printer queue, or logical printer, that
can dispatch print jobs to one of several ports associated with it. The
spooler can use a printer queue of several associated ports to optimize
printing. It can do this by making efficient use of the physical printers
connected to the logical printer’s ports.
<P>
For example, the ports LPT1, LPT2, and LPT3 could all be associated with a
single logical printer in one call to the Win32 <B>AddPrinter</B>&nbsp;routine.
Then, when the spooler has a job that needs printing, it might attempt to
dispatch the job to the physical printer connected to LPT1 by calling through
the associated language monitor’s <B><A HREF="pmonfncs_18.htm">StartDocPort</A></B>
routine. Note that the language monitors associated with these three ports
could all be different.
<P>
If the physical printer is busy with another job, or if it has problems such
as an empty paper tray, it can return an error condition to the monitor. The
language monitor’s <B>StartDocPort</B>&nbsp;function should then call the Win32 <B>SetPort</B>
routine with the appropriate error code to notify the spooler of the problem.
The spooler can then try sending the job to the next physical printer,
attached to LPT2, in the queue. If this fails, the spooler can finally try
printing to LPT3. The spooler will not send any more print jobs to a port that
signals a failure until the error condition is cleared on it.
<P>
Language monitors might call <B><A HREF="pmonfncs_19.htm">WritePort</A></B>
(and/or <B><A HREF="pmonfncs_16.htm">ReadPort</A></B>) on a port monitor outside
of a <B><A HREF="pmonfncs_18.htm">StartDocPort</A></B>/<B><A HREF="pmonfncs_6.htm">EndDocPort</A></B>
pair, for example, to check status on a printer. Port monitors that do not
allow this can fail the call, and language monitors should be written to
handle such a failure.
<H4>StartDocPort</H4>
<P>
The <B><A HREF="pmonfncs_18.htm">StartDocPort</A></B>&nbsp;routine performs
whatever tasks are necessary to start a print job on the specified port. A
port monitor’s implementation might include tasks such as:
<UL>
<LI>
Obtaining a handle to the printer to be used by calling the Win32 <B>OpenPrinter</B>
function.
<P>
<LI>
Opening the port and performing any port setup required, such as initializing
its end-of-file position for writing, by calling the Win32 <B>CreateFile</B>
and <B>SetEndOfFile</B>&nbsp;functions.
<P>
<LI>
Allocating any resources required on a per print-job basis.
</UL>
<P>
The language monitor’s <B><A HREF="pmonfncs_18.htm">StartDocPort</A></B>
routine might perform tasks such as:
<UL>
<LI>
Validating the port monitor and printer with which the language monitor will
communicate.
<P>
<LI>
Calling the port monitor’s <B>StartDocPort</B>&nbsp;function to perform any generic
per print-job initializations.
<P>
<LI>
Allocating any resources required by the language monitor on a per print-job
basis.
<P>
<LI>
Determining whether the printer understands the language monitor’s supported
language and, if so, starting a thread in which to listen for unsolicited
status information from the printer.
</UL>
<P>
If a monitor’s <B><A HREF="pmonfncs_18.htm">StartDocPort</A></B>&nbsp;routine
cannot perform the setup required, it should clean up as necessary and return
FALSE. The spooler retries <B>StartDocPort</B>&nbsp;as often as the application
retries.
<H4>WritePort</H4>
<P>
The <B><A HREF="pmonfncs_19.htm">WritePort</A></B>&nbsp;routine sends a block of print
data to the printer. A <B>WritePort</B>&nbsp;implementation could send the data by
calling the Win32 <B>WriteFile</B>&nbsp;function. The spooler calls <B>WritePort</B>
as often as is necessary to complete sending the entire print job. The spooler
determines the size of the data block sent in each <B>WritePort</B>&nbsp;call, so a
monitor should make no assumptions about the block size.
<P>
A language monitor’s <B><A HREF="pmonfncs_19.htm">WritePort</A></B>&nbsp;routine can
add printer job control data to print data before sending it to the port
monitor. When the language monitor returns to the spooler after adding bytes,
such as printer control information, to the print data stream, it must not
increment the byte count of data sent to the printer. For example, if your
language monitor adds .25K of information to a 1K data stream before sending
it to the port monitor, it must report sending only the original 1K of data
when it returns.
<H4>EndDocPort</H4>
<P>
The <B><A HREF="pmonfncs_6.htm">EndDocPort</A></B>&nbsp;function performs
end-of-print-job tasks on the port. The spooler calls <B>EndDocPort</B>&nbsp;when
there is no more data to send for the current print job.
<P>
A port monitor’s <B>EndDocPort</B>&nbsp;implementation should call the Win32 <B>SetJob</B>
routine with <I>dwCommand</I>&nbsp;set to JOB_CONTROL_SENT_TO_PRINTER to notify the
spooler that the entire print job has been sent to the printer. Note that a
pure port monitor cannot guarantee that a job has actually been printed; it
can only guarantee that it has sent the entire job to the printer.
<P>
If a print job has been sent to a bidirectional printer, a language monitor’s <B><A HREF="pmonfncs_6.htm">EndDocPort</A></B>
can start a thread that listens for true end-of-job notification; that is,
notification from a bidirectional printer that it has printed the entire job.
When the language monitor receives this notification, it should call the Win32
<B>SetJob</B>&nbsp;routine with <I>dwCommand</I>&nbsp;set to
JOB_CONTROL_LAST_PAGE_EJECTED to provide the spooler with true end-of-job
notification.
<P>
Other tasks that a port monitor’s <B>EndDocPort</B>&nbsp;implementation might
perform include:
<UL>
<LI>
Clearing any data that the port has cached by calling, for example, the Win32 <B>FlushFileBuffers</B>
routine.
<P>
<LI>
Closing the printer by calling the Win32 <B>ClosePrinter</B>&nbsp;function.
<P>
<LI>
Freeing any per print-job resources allocated by <B><A HREF="pmonfncs_18.htm">StartDocPort</A></B>.
</UL>
<P></FONT>
</BODY>
</HTML>
