<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Copying Bitmaps</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Copying_Bitmaps_GG"></A>Copying Bitmaps</H3>
<P>
Bit block transfer (bitblt) functions implemented by drivers must copy blocks
of bits from one surface to another. These functions include:
<P>
<FONT FACE="Symbol">&#183;</FONT><B>&nbsp; &nbsp; <A HREF="grfncs_7.htm">DrvBitBlt</A></B>
<P>
<FONT FACE="Symbol">&#183;</FONT><B>&nbsp; &nbsp; <A HREF="grfncs_54.htm">DrvStretchBlt</A></B>
<P>
<FONT FACE="Symbol">&#183;</FONT><B>&nbsp; &nbsp; <A HREF="grfncs_9.htm">DrvCopyBits</A></B>
<P>
&nbsp;
<P>
There is also a display-driver-specific bitblt function called <B><A HREF="grfncs_46.htm">DrvSaveScreenBits</A></B>.
<P>
If the surface being drawn on is a device-managed surface or bitmap, the
driver must support a minimum level of bit block transfer functions. If the
surface is a GDI-managed standard format bitmap, GDI handles all of these
operations unless the driver hooks out any of the calls in <B><A HREF="grfncs_64.htm">EngAssociateSurface</A></B>.
<P>
<B>DrvBitBlt</B>&nbsp;provides general bit block transfer capabilities. If a driver
supports a device-managed surface or bitmap, the driver must implement <B>DrvCopyBits</B>.
At a minimum, the driver must do the following when <B>DrvCopyBits</B>&nbsp;is
called:
<UL>
<LI>
Block transfer to and from a bitmap, in the device’s preferred format, and the
device surface.
<P>
<LI>
Perform the transfer with the SRCCOPY (0xCCCC) ROP.
<P>
<LI>
Allow arbitrary clipping.
</UL>
<P>
&nbsp;
<P>
The driver can use the GDI <A HREF="grstrcts_4.htm">CLIPOBJ</A>&nbsp;enumeration
services to reduce the clipping to a series of clip rectangles. GDI passes
down a translation vector, <A HREF="grstrcts_35.htm">XLATEOBJ</A>, to assist in
color index translation between source and destination surfaces.
<P>
If the surface of a device is organized as a standard-format DIB, the driver
can support only simple transfers. If a call comes in with a complicated ROP,
the driver can punt the block transfer request back to GDI with a call to <B><A HREF="grfncs_68.htm">EngCopyBits</A></B>.
This allows GDI to break up the call into simpler functions the driver can
perform.
<P>
If a source is used, <B>DrvBitBlt</B>&nbsp;maps a geometric source rectangle
exactly onto a geometric destination rectangle. If there is no source, the <I>pptlSrc</I>
parameter is ignored. The destination rectangle is the surface to be modified
and it is defined by two integer points, upper left and lower right. The
rectangle is <I>lower right exclusive</I>; the lower and right edges of the
rectangle are not part of the block transfer. <B>DrvBitBlt</B>&nbsp;cannot be
called with an empty destination rectangle. The two points of the rectangle
are always well ordered.
<P>
<B>DrvBitBlt</B>&nbsp;deals with different ROPs and can perform some optimizations,
depending on the device. In some cases, if the ROP is a solid color, a fill
rather than a bitblt can be done. For devices that do not support all ROPs,
true WYSIWYG is not always possible. The PostScript driver, for example,
supports no ROPs.
<P>
Optionally, a block transfer handled by <B>DrvBitBlt</B>&nbsp;can be masked and
involve color index translation. A translation vector assists in color index
translation for palettes. The transfer might need to be arbitrarily clipped by
a display driver, using a series of clip rectangles. The required region and
information are furnished by GDI.
<P>
Implementing<I>&nbsp;</I><B>DrvBitBlt</B>&nbsp;represents a significant portion of the
work involved in writing a driver for a raster display driver that does not
have a standard-format frame buffer. The Microsoft VGA driver furnished with
the DDK provides example code that completely supports the basic function for
a planar device. Implementing <B>DrvBitBlt</B>&nbsp;for other devices may be less
complex.
<P>
<B><A HREF="grfncs_54.htm">DrvStretchBlt</A></B>&nbsp;can be optionally
provided, even for drivers that support device-managed surfaces. This function
provides capabilities for stretching block transfers between device-managed
and GDI-managed surfaces. <B>DrvStretchBlt </B>supports only certain types of
stretching, such as stretching by integer multiples.
<P>
<B>DrvStretchBlt</B>&nbsp;also allows a driver to write on GDI bitmaps, especially
when the driver can do halftoning. The function also permits the same
halftoning algorithm to be applied to GDI bitmaps and device surfaces.
<P>
<B>DrvStretchBlt</B>&nbsp;maps a geometric source rectangle exactly onto a
geometric destination rectangle. The source is a rectangle with corners
displaced by (-0.5,-0.5) from the given integer coordinates. The points
specified in the function parameters lie on integer coordinates that
correspond to pixel centers. A rectangle defined by two such points is
considered to be geometric, with two vertices whose coordinates are the given
points, but with 0.5 subtracted from each coordinate. (GDI POINTL structures
use a shorthand notation for specifying these fractional coordinate vertices.)
Note that the edges of any such rectangle never intersect a pixel, but go
around a set of pixels. The pixels inside the rectangle are normal pixels for
a “bottom right-exclusive” rectangle.
<P>
The points of the source rectangle are well ordered. <B>DrvStretchBlt</B>
cannot be given an empty source rectangle. Unlike <B>DrvBitBlt</B>, <B>DrvStretchBlt</B>
can be called with a single clipping rectangle to prevent round-off errors in
clipping the output.
<P>
The destination rectangle is defined by two integer points. These points are
not well ordered and the coordinates of the second point are not necessarily
larger than those of the first. The source rectangle these points describe
does not include the lower and right edges. Because the rectangle is not well
ordered, <B>DrvStretchBlt</B>&nbsp;must sometimes perform inversions in both x and
y. (The driver must not attempt to read pixels that do not lie on the source
surface). <B>DrvStretchBlt</B>&nbsp;cannot be called with an empty destination
rectangle.
<P>
For color translation, <B>DrvStretchBlt</B>&nbsp;provides a pointer, <I>pxlo</I>,
to XLATEOBJ that is used to translate between the source and destination
surfaces. XLATEOBJ can be queried to find the destination index for any source
index. For a high-quality stretching block transfer, <B>DrvStretchBlt</B>&nbsp;is
required to interpolate colors in some cases. <B>DrvStretchBlt</B>&nbsp;also uses
the COLORADJUSTMENT structure to define the color adjustment values that are
to be applied to the source bitmap before the bits are stretched.
<P>
<B>DrvStretchBlt</B>&nbsp;uses the <I>iMode</I>&nbsp;parameter to define how the source
pixels are to be combined for output. In particular, <I>iMode</I>&nbsp;provides the
HALFTONE option that permits the driver to use groups of pixels in the output
surface to best approximate the color or grey level of the output. Changes to
the COLORADJUSTMENT structure are passed to the driver after the next <B>DrvStretchBlt</B>
call with an <I>iMode</I>&nbsp;of HALFTONE. In addition, if the driver wants GDI to
handle halftoning for GDI bitmaps, the driver can hook out <B>DrvStretchBlt</B>,
set the <I>iMode</I>&nbsp;parameter to HALFTONE, and return it in <B>EngStretchBlt</B>.
<P>
If <B>DrvStretchBlt</B>&nbsp;has hooked a call to <B>EngStretchBlt</B>&nbsp;and is asked
to do something it does not support, it returns the request to GDI so that the
appropriate function can handle it.
<P>
<B>DrvCopyBits</B>&nbsp;is called by GDI from its simulation operations to
translate between a device-managed raster surface and a GDI standard-format
bitmap. <B>DrvCopyBits</B>&nbsp;provides a fast path for SRCCOPY (0xCCCC) ROP
bit-block transfers.
<P>
Required for a graphics driver with device-managed bitmaps or raster surfaces,
this function must translate driver surfaces to and from any standard-format
bitmap. <B>DrvCopyBits</B>&nbsp;is never called with an empty destination
rectangle, and the two points of the destination rectangle are always well
ordered. This call has the same requirements as <B><A HREF="grfncs_7.htm">DrvBitBlt</A></B>.
<P>
<B>DrvCopyBits</B>&nbsp;is also called with RLE bitmaps (see the Win32 SDK) and
DDBs. The bitmaps are provided to this function as a result of application
program calls to several Win32 GDI routines. The optional DDB is supported
only by a few specialized drivers.
<P></FONT>
</BODY>
</HTML>
