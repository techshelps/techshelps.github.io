<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DrvEnablePDEV</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_DrvEnablePDEV_GG"></A>DrvEnablePDEV</H2>
<P>
<B>DHPDEV DrvEnablePDEV(</B>
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN DEVMODEW  </B><I>*pdm</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN LPWSTR  </B><I>pwszLogAddress</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN ULONG  </B><I>cPat</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; OUT HSURF  </B><I>*phsurfPatterns</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN ULONG  </B><I>cjCaps</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; OUT ULONG  </B><I>*pdevcaps</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN ULONG  </B><I>cjDevInfo</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; OUT DEVINFO  </B><I>*pdi</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN HDEV  </B><I>hdev</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN LPWSTR  </B><I>pwszDeviceName</I><B>,</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp; IN HANDLE  </B><I>hDriver</I>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>&nbsp; &nbsp;);</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
</FONT></TABLE>
<P>
<B>DrvEnablePDEV</B>&nbsp;creates a logical representation of a physical device
upon which the driver can associate a drawing surface.
<H3>Parameters</H3>
<DL>
<DT>
<I>pdm</I>
<DD>
Points to a <A HREF="grstrcts_7.htm">DEVMODEW</A>&nbsp;structure that contains driver
data.
<BR>
<DT>
<I>pwszLogAddress</I>
<DD>
Points to the logical address string that is the user’s name for the location
to which the driver is writing. Examples include “LPT1” or “My Printer.”
<BR>
<DT>
<I>cPat</I>
<DD>
Specifies the number of standard patterns, equal to the number of HSURF
structures in the buffer pointed to by <I>phsurfPatterns</I>. The driver
cannot access memory beyond the end of the buffer.
<BR>
<DT>
<I>phsurfPatterns</I>
<DD>
Points to a buffer that the driver will fill with surfaces representing the
standard fill patterns. The following patterns must be defined in order:
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>Pattern</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>Description</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
HS_HORIZONTAL
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Horizontal hatch.
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
HS_VERTICAL
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Vertical hatch.
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
HS_FDIAGONAL
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
45-degree upward hatch (left to right).
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
HS_BDIAGONAL
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
45-degree downward hatch (left to right).
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
HS_CROSS
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Horizontal and vertical cross hatch.
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
HS_DIAGCROSS
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
45-degree crosshatch.
</FONT></TABLE>
<P>
<B>Note</B>&nbsp; &nbsp; &nbsp; The number of default hatch patterns that require driver
support was reduced in a previous version of the DDK. Consequently,
HS_DDI_MAX, typically used by drivers to declare the size of the pattern
array, was reduced.
<P>
GDI calls <B><A HREF="grfncs_44.htm">DrvRealizeBrush</A></B>&nbsp;with one of
these surfaces to realize a brush with a standard pattern.
<P>
Each of these surfaces must be a monochrome (1 bit per pixel) GDI bitmap for
raster devices. The device driver should choose patterns that will look most
like standard patterns when written on the device surface.
<P>
GDI is never required to use these brushes in support routines for a vector
device. Therefore, surfaces can be device-supported surfaces that <B>DrvRealizeBrush</B>
recognizes as standard patterns.
<BR>
<DT>
<I>cjCaps</I>
<DD>
Specifies the size of the buffer pointed to by <I>pdevcaps</I>. The driver
must not access memory beyond the end of the buffer.
<BR>
<DT>
<I>pdevcaps</I>
<DD>
Points to a <A HREF="grstrcts_20.htm">GDIINFO</A>&nbsp;structure that will be used to
describe device capabilities. GDI zero-initializes this structure before the
application calls <B>DrvEnablePDEV</B>.
<BR>
<DT>
<I>cjDevInfo</I>
<DD>
Specifies the number of bytes in the DEVINFO structure pointed to by <I>pdi</I>.
The driver should modify no more than this number of bytes in the DEVINFO.
<BR>
<DT>
<I>pdi</I>
<DD>
Points to the <A HREF="grstrcts_6.htm">DEVINFO</A>&nbsp;structure, which describes the
driver and the physical device. The driver should only alter the members it
understands. GDI fills this structure with zeros before a call to <B>DrvEnablePDEV</B>.
<BR>
<DT>
<I>hdev</I>
<DD>
Points to a fully-qualified path name of a data file that the driver examines
to determine rendering methods for the device. This parameter is ignored for
display drivers.
<BR>
<DT>
<I>pwszDeviceName</I>
<DD>
Points to a zero-terminated string that is the user-readable name of the
device.
<BR>
<DT>
<I>hDriver</I>
<DD>
Identifies the kernel-mode driver that supports the device. For a printer
driver this parameter should be used as a handle to the printer when calling
the spooler.
</DL>
<H3>Return Value</H3>
<P>
The return value is a handle to the <A HREF="glossary.htm#DDK_PDEV_GG">PDEV</A>&nbsp;that identifies
the enabled device if the function is successful. Otherwise, it is zero, and
an error code is logged.
<H3>Comments</H3>
<P>
The device driver represents a logical device, called a PDEV. The PDEV is
managed by GDI. A single logical device can manage several PDEVs that can be
differentiated by the following:
<OL>
<LI>
Type of hardware. A single device driver might support “LaserWhiz,” “LaserWhiz
II,” and “LaserWhiz Super.”
<P>
<LI>
Logical address. A single device driver can support printers attached to
“LPT1,” “COM2,” “\SERVER1\PSLAZER,” and so forth. A display driver that can
support more than one VGA display simultaneously might differentiate them
according to port numbers; for example, 0x3CE or 0x2CE.
<P>
<LI>
Surfaces. A printer driver can process two print jobs simultaneously. The two
surfaces represent two pages that will be printed. Similarly, a display device
driver might support two desktops on the same device.
</OL>
<P>
Each call to <B>DrvEnablePDEV</B>&nbsp;creates another device that is used with a
distinct surface. The DEVMODEW structure indicates the type of hardware
requested. GDI manages the logical address for printers and other hard copy
output devices. The spooler service <B>WritePrinter</B>&nbsp;(a Win32 function)
directs output to the proper destination. Displays and input devices either
know their logical address implicitly or get it from the private section of
the DEVMODEW structure. For more information, see the <I>Win32 SDK</I>.
<P>
When receiving a call to this function, the driver must allocate the memory to
support the PDEV. However, the actual surface need not be supported until GDI
calls <B><A HREF="grfncs_21.htm">DrvEnableSurface</A></B>.
<P>
If a device surface requires a bitmap to be allocated, these allocations need
not be made until needed. Although applications often request device
information long before actually writing to the device, waiting to allocate
resources, such as large bitmaps, can conserve memory.
<P>
GDI zero-initializes the buffer pointed to by <I>phsurfPatterns</I>&nbsp;before
calling this function.
<P>
<B>DrvEnablePDEV</B>&nbsp;is required for graphics drivers.
<H3>See Also</H3>
<P>
<A HREF="grstrcts_6.htm">DEVINFO</A>, <A HREF="grstrcts_7.htm">DEVMODEW</A>, <B><A HREF="grfncs_21.htm">DrvEnableSurface</A></B>,
<B><A HREF="grfncs_44.htm">DrvRealizeBrush</A></B>, <B><A HREF="grfncs_74.htm">EngCreatePalette</A></B>,
<A HREF="grstrcts_20.htm">GDIINFO</A>&nbsp;
<P></FONT>
</BODY>
</HTML>
