<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Porting Steps for Graphics Drivers</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Porting_Steps_for_Graphics_Drivers_GG"></A>Porting Steps for Graphics Drivers</H2>
<P>
This section provides step-by-step porting details that pertain to both
display and print drivers.
<P>
Most functions that were originally exported by <I>winsrv.dll </I>are now
exported by <I>win32k.sys</I>, so a simple relink of the driver resolves
references to these functions. However, all other functions imported by your
driver (from <I>kernel32.dll</I>, <I>advapi32.dll</I>, or any other DLL) must
be replaced or eliminated because they are no longer available. <I>If your
driver directly references functions from any image other than win32k.sys, the
system will not load your image. </I>Therefore, the basic requirement for
enabling a graphics driver to run under Windows NT 4.0 is to remove any calls
to Win32 functions, and replace them with the calls exported by <I>win32k.sys</I>.
<DL>
<DT>
An easy way to determine exactly which functions your driver calls is to dump
the list of <I>imports</I>, or external references, in your driver. One way to
obtain this list is to run the following command:
<DD>
<PRE><FONT FACE="Courier" SIZE="2">link -dump -imports your_driver.dll
&nbsp;</FONT></PRE>
</DL>
<P>
Here are some common changes to make to your graphics drivers to port them
from Windows NT 3.51 to 4.0.
<H4>Step 1. Clean out the files used to compile your driver.</H4>
<UL>
<LI>
Delete the <I>.def </I>file that described the exports from your graphics
driver in 3.51; it is no longer necessary.
<P>
<LI>
Modify the <I>sources </I>files, which contain the list of files compiled to
generate your driver. Update the file list from your 3.51 <I>sources</I>&nbsp;file,
if necessary, and then use this list to define SOURCES in one of the <I>sources
</I>files shipped with the sample Windows NT 4.0 drivers. This ensures that
you pick up the new TARGETTYPE and other fields, enables warnings as errors,
and so forth.
<P>
<LI>
Change your main header file so that it does <I>not </I>include <I>windows.h</I>.
This will help you track down the now obsolete Win32 function calls in your
3.51 source code. Your main header file should look something like the
following:
<P>
<PRE><FONT FACE="Courier" SIZE="2">#include &lt;stddef.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;limits.h&gt;
#include &lt;windef.h&gt;
#include &lt;wingdi.h&gt;
#include &lt;winddi.h&gt;
//These include files are for display drivers only.
#include &lt;devioctl.h&gt;
#include &lt;ntddvdeo.h&gt;
#include &lt;ioaccess.h&gt;
//These include files are for print drivers only.
#include &lt;gdispool.h&gt;
//Private defines
#include &lt;my_headers&gt;
&nbsp;</FONT></PRE>
<P>
<B>Note</B>&nbsp; Due to problems with the spooler API header file, you might
encounter compiler warnings in the pre-beta Windows NT 4.0 release. These
problems will be fixed by the official Windows 4.0 release.
</UL>
<H4>Step 2. Replace Win32 calls with new kernel-mode counterparts.</H4>
<UL>
<LI>
Critical sections have been replaced with semaphores: 
<P>
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>CRITICAL_SECTION</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>HSEMAPHORE</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>InitializeCriticalSection</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_76.htm">EngCreateSemaphore</A></B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>EnterCriticalSection</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_61.htm">EngAcquireSemaphore</A></B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>LeaveCriticalSection</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_123.htm">EngReleaseSemaphore</A></B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>DeleteCriticalSection</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_84.htm">EngDeleteSemaphore</A></B>
</FONT></TABLE>
<P>
Note that where storage for a critical section was provided by the caller (the
functions took a pointer to the critical section), the semaphore routines
always use a handle (storage is allocated and destroyed within the semaphore
routines).
<P>
<LI>
Calls to Win32 debugging functions must be replaced with their new GDI
equivalents:
<P>
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>Win32 Debug Function</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>GDI Debug Function</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>DebugBreak</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_78.htm">EngDebugBreak</A></B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>OutputDebugString</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_79.htm">EngDebugPrint</A></B>
</FONT></TABLE>
<P>
<DL>
<DT>
The debug output routine can be copied from the sample drivers. This routine
supports debug levels, and automatically appends the driver name to the debug
message. The following is the code sample for the debug output routine:
<DD>
<PRE><FONT FACE="Courier" SIZE="2">VOID DebugPrint(LONG DebugPrintLevel, PCHAR DebugMessage, ...)
{
&nbsp; &nbsp; #define STANDARD_DEBUG_PREFIX &quot;MyDisplay:&quot;
&nbsp; &nbsp; va_list ap;
&nbsp; &nbsp; 
&nbsp; &nbsp; va_start(ap, Debugmessage);
&nbsp; &nbsp; if (DebugPrintLevel &lt;= DebugLevel)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
&nbsp; &nbsp; &nbsp; &nbsp; // The following line appends the newline
&nbsp; &nbsp; &nbsp; &nbsp; // automatically.
&nbsp; &nbsp; &nbsp; &nbsp; // EngDebugPrint(&quot;&quot;, &quot;\n&quot;, ap);
&nbsp; &nbsp; }
&nbsp; &nbsp; va_end(ap);
}
&nbsp;</FONT></PRE>
</DL>
<P>
<LI>
Memory allocators must be replaced with the newly provided kernel-mode GDI
equivalents. The following are mappings for the most common memory functions:
<P>
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>Win32 Memory Function</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>KM GDI Memory Function</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>LocalAlloc</B>, <B>GlobalAlloc</B>, <B>VirtualAlloc</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_62.htm">EngAllocMem</A></B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>VirtualFree</B>, <B>GlobalFree</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><A HREF="grfncs_92.htm">EngFreeMem</A></B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>LocalLock</B>, <B>GlobalLock</B>, <B>LocalUnlock</B>, <B>GlobalUnlock</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
none (not used)
</FONT></TABLE>
<P>
<DL>
<DT>
There are some enhancements to <B>EngAllocMem</B>. It supports only the zero
memory option (FL_ZERO_MEMORY) because the other options are not useful. Also,
a third parameter, <I>tag</I>, was added to <B>EngAllocMem</B>. This tag is
used by the system to provide information about resources. Both the kernel
debugger <I>!pool</I>&nbsp;command and the user-mode <I>poolmon</I>&nbsp;utility can be
used to track the amount of memory associated with each tag. The tag should be
specified in reverse order, with single quotes. It is 4 bytes in size, and is
stored in the pool header as 1 DWORD. The following is a sample call:
<DD>
<PRE><FONT FACE="Courier" SIZE="2">ppdef = (PPDEF) EngAllocMem(FL_ZERO_MEMORY,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(PDEV),&#39;agxD&#39;);
&nbsp;</FONT></PRE>
</DL>
<P>
<B>Note</B>&nbsp; Memory is often referred to as <I>pool </I>in the kernel. The
kernel memory functions are actually called <B>ExAllocatePool</B>&nbsp;and <B>ExFreePool</B>.
<P>
<B>Note</B>&nbsp; Heaps are not supported in kernel mode, so you cannot destroy the
heap to clean up memory.
<P>
<LI>
There are no process/thread creation routines available to your driver. Your
driver must be redesigned to work without them.
<P>
<LI>
There is no support for registry functions that pass data to kernel-mode
drivers. Your driver must be redesigned to work without them.
</UL>
<P>
Any remaining Win32 functions in the original Windows NT 3.51 driver must be
removed. If your driver absolutely requires a function that is not currently
exposed, then Microsoft should be made aware of this requirement so the
function can be exposed or an appropriate alternative can be found.
<H4>Step 3. Clean out calls to C-runtime routines where necessary.</H4>
<P>
String routines, such as <B>strcmp</B>, are <I>not</I>&nbsp;exported from <I>win32k.sys</I>.
Calls to these routines should be removed if possible. Limited C-runtime
functionality is available in <I>libcntpr.lib</I>, which statically links to
the driver.
<H4>Step 4. Replace floating point operations with FLOATOBJs.</H4>
<P>
Don’t use native floating point operations. Windows NT does not support
kernel-mode floating point operations on some systems. Specifically, the
Windows NT kernel does not preserve floating point registers on kernel-mode
stack switches, so using floating point registers in the driver corrupts an
application’s floating point registers.
<P>
GDI has introduced a new set of services that allows graphics drivers to
emulate floating point arithmetic. See the reference pages for the <B><A HREF="grstrcts_16.htm">FLOATOBJ</A>_</B><I>Xxx
</I>services for more information.
<H4>Step 5. Be frugal with the stack.</H4>
<P>
Each thread is allocated a limited amount of stack space for all function
calls and interrupts. The Windows NT kernel allocates an initial 12K on <I>x</I>86
and MIPS platforms, and 16K on ALPHA and PowerPC platforms. The stack can grow
to accommodate callbacks from the kernel to user mode and back; the maximum
stack size is 60K/64K in the kernel. Only 12K/16K of the stack is visible at
any point in time. The only exception to these policies is OpenGL, which is
allocated the entire 60K/64K stack at once.
<P>
In Microsoft’s driver design, a guideline of 1K of stack space per function is
used. This heuristic was arrived at by studying the stack needs of a typical
graphics driver. The first few kilobytes on the stack contain the functions
called to get from the application to the driver, such as the system service
functions. The last 2-3 kilobytes are reserved for page faults and interrupts.
The fact that some driver calls spawn several nested function calls is also
accounted for. For example, the S3’s implementation of <B><A HREF="grfncs_54.htm">DrvStretchBlt</A></B>
calls <B><A HREF="grfncs_128.htm">EngStretchBlt</A></B>, which calls <B><A HREF="grfncs_7.htm">DrvBitBlt</A></B>,
which calls another internal S3 fill function. Using the 1K per function
guideline means that only up to 4K of the stack is used for these four
functions.
<P>
You should also look at the size of your functions’ parameters. Only small
structures and very small arrays of data should be stored on the stack. Arrays
of 1024 or 512 elements and arrays the size of the screen’s width should not
be passed. Consider the following: if each array element is a DWORD, 1024
elements uses 4K of stack space.
<P>
Memory beyond the stack pointer should not be touched in assembly routines
because interrupts can occur at any time.
<P>
A routine is guaranteed to be using too much stack space if you get an
undefined external for something such as <B>_chkstk</B>.
<H4>Step 6. Update your driver with other Windows NT 4.0 driver changes.</H4>
<P>
Because all Windows NT 3.51 drivers are incompatible in Windows NT 4.0, a few
things have been cleaned up in the drivers:
<UL>
<LI>
In <B><A HREF="grfncs_20.htm">DrvEnablePDEV</A></B>, the second <I>PWSTR</I>
parameter was converted to an <I>HDEV</I>.
<P>
<LI>
The <B><A HREF="grfncs_6.htm">DrvAssertMode</A></B>&nbsp;function now returns a
BOOL. The status of the operation should be reported.
</UL>
<H4>Step 7. Examine the “Special Features” section of this appendix.</H4>
<P>
The section entitled <I><A HREF="port_3.htm#DDK_Special_Features_of_a_User_Mode_Process_GG">Special
Features of a User-Mode Process</A></I>, described earlier in this document,
should be examined. Drivers depending on any of these features must be changed
to avoid these problems.
<H4>Step 8. Read the porting section of this appendix specific to your graphics driver type.</H4>
<P>
The sections that follow this one are <I><A HREF="port_5.htm">Porting
Steps for Display Drivers</A></I>&nbsp;and <I><A HREF="port_6.htm">Porting
Steps for Printer Drivers</A></I>. Read the section that pertains to your driver
type for additional type-specific porting hints.
<H4>Step 9. Install your new driver.</H4>
<P>
Install your new driver, and test. Use the kernel-mode <I>kd</I>&nbsp;debugger or <I>windbg</I>
to debug your driver. NTSD can no longer be used for debugging graphics
drivers.
<P></FONT>
</BODY>
</HTML>
