<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Display Driver Initialization</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Display_Driver_Initialization_GG"></A>Display Driver Initialization</H2>
<P>
Although most of display driver initialization is generally the same as that
for graphics drivers, there are a few details specific to display drivers.
This section presents a brief synopsis of the process. See the <I>Programmer’s
Guide</I>&nbsp;for more information about the boot process.
<P>
Video miniport and display driver initialization occur after the Windows NT
executive and the Win32 subsystem are loaded and initialized. It is USER who
opens video miniport driver(s) enabled in the registry and then determines
which video miniport driver and display driver pair to use. During this
determination, GDI opens all necessary display drivers, based on the
information provided by Window Manager. Figure 5.1 shows the basic display
driver initialization procedure.
<P>
<IMG SRC="../art/202-01.gif" BORDER=0>
<P>
<B>Figure 5.1    Display Driver Initialization</B>
<UL>
<LI>
When GDI is called to create the first DC for the video hardware, GDI calls
the display driver function <B><A HREF="grfncs_19.htm">DrvEnableDriver</A></B>.
Upon return, <B>DrvEnableDriver</B>&nbsp;furnishes GDI with a <A HREF="grstrcts_9.htm">DRVENABLEDATA</A>
structure that holds both the driver version number and the entry points of
all functions the driver chooses to support that GDI can call (other than <B>DrvEnableDriver</B>
and <B><A HREF="grfncs_14.htm">DrvDisableDriver</A></B>).
<P>
<LI>
GDI then typically asks for a physical device to be created by a call to the
display driver function <B><A HREF="grfncs_20.htm">DrvEnablePDEV</A></B>.
The call uses the GDI <A HREF="grstrcts_7.htm">DEVMODEW</A>&nbsp;structure to identify
the exact device and mode that GDI wants to access. The display driver
initializes the hardware to a known state by sending requests to the video
port-miniport driver pair. If GDI requests a mode that the display or
underlying miniport driver does not support, the display driver must fail this
call. 
<P>
<LI>
The display driver represents a logical device controlled by GDI. A single
logical device can manage several physical devices, each characterized by type
of hardware, logical address, and surfaces supported. The display driver
allocates the memory to support the device it creates. A display driver can
manage more than a single display defined as a <A HREF="glossary.htm#DDK_PDEV_GG">PDEV</A>. The
display driver copies device information to a PDEV structure representing the
display and its current operating state. <B>DrvEnablePDEV</B>&nbsp;can be called
more than once by GDI, with each call creating another PDEV that is used with
a different surface. However, an actual surface is not supported until the GDI
calls <B><A HREF="grfncs_21.htm">DrvEnableSurface</A></B>.
<P>
If a driver is to support more than one PDEV, it must not use global
variables.
<P>
<LI>
When installation of the physical device is complete, GDI calls the display
driver <B><A HREF="grfncs_8.htm">DrvCompletePDEV</A></B>&nbsp;function. This
function provides the driver with a physical device handle to be used when
requesting GDI functions for the device.
<P>
<LI>
As the final stage of initialization, a surface is created for the video
hardware by a GDI call to <B>DrvEnableSurface</B>&nbsp;which enables graphics
output to the hardware. Depending on the device and the environment, the
display driver enables a surface in one of two ways:
<P>
<UL>
<LI>
The driver manages its own surface by calling the GDI function <B><A HREF="grfncs_72.htm">EngCreateDeviceSurface</A></B>
to obtain a handle for the surface. The device-managed surface method is
required for hardware that does not support a standard-format bitmap and is
optional for hardware that does.
<P>
<LI>
GDI can manage the surface completely as an engine-managed surface if the
hardware device has a surface organized as a standard-format bitmap. Even in
this case, when it calls <B><A HREF="grfncs_64.htm">EngAssociateSurface</A></B>,
the driver can still hook any drawing functions that it can more efficiently
handle.
</UL>
</UL>
<P>
The display driver can obtain a bitmap handle for a surface by calling <B><A HREF="grfncs_69.htm">EngCreateBitmap</A></B>
with a pointer to the device pixels. GDI collects the graphics directly in a
bitmap. The display driver calls <B>EngCreateBitmap</B>, allowing the GDI to
allocate space for the pixels.
<P>
Any existing GDI bitmap handle is a valid surface handle. Before returning a
surface, the display driver must associate it with the PDEV, using a call to <B>EngAssociateSurface</B>,
specifying which functions it wishes to hook for drawing to the surface. If
the surface is engine-managed, GDI can handle any or all drawing operations.
If the surface is device-managed, at a minimum, the driver must handle <B><A HREF="grfncs_59.htm">DrvTextOut</A></B>,
<B><A HREF="grfncs_56.htm">DrvStrokePath</A></B>, and <B><A HREF="grfncs_9.htm">DrvCopyBits</A></B>.
<P></FONT>
</BODY>
</HTML>
