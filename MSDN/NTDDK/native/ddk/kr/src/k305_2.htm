<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HW_INITIALIZATION_DATA</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_HW_INITIALIZATION_DATA_KR"></A>HW_INITIALIZATION_DATA</H2>
<PRE><FONT FACE="Courier" SIZE="2">typedef struct HW_INITIALIZATION_DATA { 
&nbsp; &nbsp; ULONG HwInitializationDataSize; 
&nbsp; &nbsp; INTERFACE_TYPE AdapterInterfaceType; 
&nbsp; &nbsp; PHW_INITIALIZE HwInitialize; 
&nbsp; &nbsp; PHW_STARTIO HwStartIo; 
&nbsp; &nbsp; PHW_INTERRUPT HwInterrupt; 
&nbsp; &nbsp; PHW_FIND_ADAPTER HwFindAdapter; 
&nbsp; &nbsp; PHW_RESET_BUS_BUS HwResetBus; 
&nbsp; &nbsp; PHW_DMA_STARTED HwDmaStarted; 
&nbsp; &nbsp; PHW_ADAPTER_STATE HwAdapterState; 
&nbsp; &nbsp; ULONG DeviceExtensionSize; 
&nbsp; &nbsp; ULONG SpecificLuExtensionSize; 
&nbsp; &nbsp; ULONG SrbExtensionSize; 
&nbsp; &nbsp; ULONG NumberOfAccessRanges; 
&nbsp; &nbsp; PVOID Reserved; 
&nbsp; &nbsp; BOOLEAN MapBuffers; 
&nbsp; &nbsp; BOOLEAN NeedPhysicalAddresses; 
&nbsp; &nbsp; BOOLEAN TaggedQueuing; 
&nbsp; &nbsp; BOOLEAN AutoRequestSense; 
&nbsp; &nbsp; BOOLEAN MultipleRequestPerLu; 
&nbsp; &nbsp; BOOLEAN ReceiveEvent; 
&nbsp; &nbsp; USHORT VendorIdLength; 
&nbsp; &nbsp; PVOID VendorId; 
&nbsp; &nbsp; USHORT ReservedUshort; 
&nbsp; &nbsp; USHORT DeviceIdLength; 
&nbsp; &nbsp; PVOID DeviceId; 
} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA; 
&nbsp;</FONT></PRE>
<P>
Each SCSI miniport’s <B>DriverEntry</B>&nbsp;routine must initialize with zeros
and, then, fill in the relevant HW_INITIALIZATION_DATA information for the
OS-specific port driver.
<H3>Members</H3>
<DL>
<DT>
<B>HwInitializationDataSize</B>
<DD>
Specifies the size of this structure in bytes, as returned by <B>sizeof</B>().
In effect, this member indicates the version of this structure being used by
the miniport driver. A miniport’s <B>DriverEntry</B>&nbsp;routine should set this
member’s value for the port driver.
<BR>
<DT>
<B>AdapterInterfaceType</B>
<DD>
Specifies the type of I/O bus to which the HBA is connected, which can be one
of the following: <B>Internal</B>, <B>Isa</B>, <B>Eisa</B>, <B>MicroChannel</B>,
<B>TurboChannel</B>, or <B>PCIBus</B>. However, additional types of buses will
be supported in future. The upper bound on the types of buses supported is
always <B>MaximumInterfaceType</B>.
<P>
If this is set to <B>PCIBus</B>, the miniport driver must supply values for
the <B>VendorIdLength</B>, <B>VendorId</B>, <B>DeviceIdLength</B>, and <B>DeviceId</B>
members, described later.
<BR>
<DT>
<B>HwInitialize</B>
<DD>
Points to the miniport’s HwScsiInitialize routine, which is a required entry
point for all miniport drivers.
<BR>
<DT>
<B>HwStartIo</B>
<DD>
Points to the miniport’s HwScsiStartIo routine, which is a required entry
point for all miniport drivers.
<BR>
<DT>
<B>HwInterrupt</B>
<DD>
Points to the miniport’s HwScsiInterrupt routine, which is a required entry
point for any miniport driver of an HBA that generates interrupts. Set this to
NULL if the miniport needs no ISR.
<BR>
<DT>
<B>HwFindAdapter</B>
<DD>
Points to the miniport’s HwScsiFindAdapter routine, which is a required entry
point for all miniport drivers.
<BR>
<DT>
<B>HwResetBus</B>
<DD>
Points to the miniport’s HwScsiResetBus routine, which is a required entry
point for all miniport drivers.
<BR>
<DT>
<B>HwDmaStarted</B>
<DD>
Points to the miniport’s HwScsiDmaStarted routine if its HBA uses system DMA,
that is, a system DMA controller. Set this to NULL if the HBA is a busmaster
or uses PIO.
<BR>
<DT>
<B>HwAdapterState</B>
<DD>
Points to the miniport’s HwScsiAdapterState routine, which is a required entry
point for miniport drivers of HBAs with BIOSes that are linked with an
OS-dependent, x86-platform-only port driver that must switch between x86
protected and real processor modes. If the miniport needs no
HwScsiAdapterState routine, set this member to NULL. A miniport without this
routine for an HBA that has a BIOS is incompatible with the x86-only port
driver and unportable to an x86-only OS environment.
<BR>
<DT>
<B>DeviceExtensionSize</B>
<DD>
Specifies the size in bytes required by the miniport driver for its per-HBA
device extension. A miniport uses its device extension as storage for
driver-determined HBA information. The OS-specific port driver initializes
each device extension it allocates with zeros, and passes a pointer to the
HBA-specific device extension in every call to a miniport driver except to its
<B>DriverEntry</B>&nbsp;routine. The given size does not include any
miniport-requested per-logical-unit storage, described next.
<BR>
<DT>
<B>SpecificLuExtensionSize</B>
<DD>
Specifies the size in bytes required by the miniport driver for its
per-logical-unit storage, if any. A miniport can use its LU extensions as
storage for driver-determined logical-unit information about SCSI peripherals
on the bus. The OS-specific port driver initializes each LU extension it
allocates with zeros. Leave this member set to zero if the miniport does not
maintain per-LU information for which it requires storage.
<BR>
<DT>
<B>SrbExtensionSize</B>
<DD>
Specifies the size in bytes required by the miniport driver for its
per-request storage, if any. A miniport can use SRB extensions as storage for
driver-determined, request-specific information, such as data necessary to
process a particular request. The OS-specific port driver does not initialize
SRB extensions, but sets a pointer to this storage in each SRB it sends to the
miniport driver. An SRB extension can be safely accessed by the HBA hardware.
Leave this member set to zero if the miniport driver does not maintain per-SRB
information for which it requires storage.
<BR>
<DT>
<B>NumberOfAccessRanges</B>
<DD>
Specifies how many access ranges the adapter uses. Each is a range either of
memory addresses or I/O port addresses. A typical HBA uses two ranges, one for
its I/O ports and another for its device memory range.
<BR>
<DT>
<B>Reserved</B>
<DD>
This member is reserved for system use and not available for use by miniport
drivers.
<BR>
<DT>
<B>MapBuffers</B>
<DD>
TRUE indicates that all data buffer addresses must be mapped to virtual
addresses for access by the miniport driver.
<BR>
<DT>
<B>NeedPhysicalAddresses</B>
<DD>
TRUE indicates that the miniport driver needs to translate its device, any
per-LU, and any per-SRB extension addresses, as well as SRB buffer addresses,
to physical addresses, as required by the HBA.
<BR>
<DT>
<B>TaggedQueuing</B>
<DD>
TRUE indicates that miniport driver can support SCSI-II tagged queueing.
<BR>
<DT>
<B>AutoRequestSense</B>
<DD>
TRUE indicates that the HBA can perform a request-sense operation without
requiring an explicit request to do so. Only miniports driving HBAs with
built-in firmware to perform request-sense operations should set this member
to TRUE.
<BR>
<DT>
<B>MultipleRequestPerLu</B>
<DD>
TRUE indicates that the miniport driver can queue multiple requests per
logical unit, in particular, within the HBA. Note that an HBA must support
auto request sense for its miniport to enable this functionality. If a
miniport driver sets this member to TRUE, it must use each SRB <B>QueueTag</B>
member for requests of this type, but the SRB_FLAGS_QUEUE_ACTION_ENABLE is not
set in the <B>SrbFlags</B>&nbsp;member of the SCSI_REQUEST_BLOCK structure.
<BR>
<DT>
<B>ReceiveEvent</B>
<DD>
TRUE indicates the miniport drives an HBA that can support the receive-event
SRB for SCSI-II asynchronous events.
<BR>
<DT>
<B>VendorIdLength</B>
<DD>
Specifies the size in bytes of the <B>VendorId</B>&nbsp;string, described next.
<BR>
<DT>
<B>VendorId</B>
<DD>
Points to an ASCII byte string identifying the manufacturer of the HBA.
<P>
If the given <B>AdapterInterfaceType</B>&nbsp;is <B>PCIBus</B>, the vendor ID is a
USHORT value allocated by the PCI SIG, which must be converted into a byte
string by the miniport driver. For example, if the assigned PCI vendor ID
value is 1001, the miniport-supplied <B>VendorId</B>&nbsp;string would be (‘1’,
‘0’, ‘0’, ‘1’).
<BR>
<DT>
<B>ReservedUshort</B>
<DD>
This member is reserved for system use and is not available for use by
miniport drivers.
<BR>
<DT>
<B>DeviceIdLength</B>
<DD>
Specifies the size in bytes of the <B>DeviceId</B>&nbsp;string, described next.
<BR>
<DT>
<B>DeviceId</B>
<DD>
Points to an ASCII byte string identifying the HBA model(s) supported by the
miniport driver.
<P>
If the given <B>AdapterInterfaceType</B>&nbsp;is <B>PCIBus</B>, a device ID is a
USHORT value assigned by the manufacturer of the HBA. The miniport must
convert any PCI device ID value(s) for the HBA(s) it can support into <B>DeviceId</B>
byte string(s), as for the <B>VendorId</B>&nbsp;member. For example, if a miniport
can support HBAs with the PCI device IDs 8040 and 8050, it might set <B>DeviceId</B>
with a pointer to the byte string (‘8’, ‘0’).
</DL>
<H3>Comments</H3>
<P>
Each miniport driver must initialize the HW_INITIALIZATION_DATA structure with
zeros before it sets the values of relevant members in this structure and
calls <B>ScsiPortInitialize</B>.
<H3>See Also</H3>
<P>
<B><A HREF="k302_1.htm">DriverEntry</A></B>, <A HREF="k302_7.htm">HwScsiInitialize</A><B>,</B>
<A HREF="k305_4.htm">SCSI_REQUEST_BLOCK</A>, <B><A HREF="k301_13.htm">ScsiPortInitialize</A></B>
<P>
&nbsp;
<P>
&nbsp;
<P></FONT>
</BODY>
</HTML>
