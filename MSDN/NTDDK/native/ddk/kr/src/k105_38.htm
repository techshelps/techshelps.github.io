<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>KeReleaseMutex</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_KeReleaseMutex_KR"></A>KeReleaseMutex</H2>
<P>
<B>LONG <BR>
&nbsp; &nbsp; KeReleaseMutex(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PKMUTEX</B>&nbsp; <I>Mutex</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN BOOLEAN</B>&nbsp; <I>Wait</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>KeReleaseMutex</B>&nbsp;releases a given mutex object, specifying whether the
caller is to call one of <B>KeWait</B><I>Xxx</I>&nbsp;as soon as <B>KeReleaseMutex</B>
returns control.
<H3>Parameters</H3>
<DL>
<DT>
<I>Mutex</I>
<DD>
Points to an initialized mutex object for which the caller provides the
storage.
<BR>
<DT>
<I>Wait</I>
<DD>
Specifies whether or not the call to <B>KeReleaseMutex</B>&nbsp;is to be
immediately followed by a call to one of <B>KeWait</B><I>Xxx</I>.
</DL>
<H3>Return Value</H3>
<P>
If the return value is zero, the mutex object was released and attained a
state of Signaled.
<H3>Comments</H3>
<P>
For better performance, use the <B>Ex..FastMutex</B>&nbsp;routines instead of the <B>Ke..Mutex</B>.
However, a fast mutex cannot be acquired recursively, as a kernel mutex can. 
<P>
If the mutex object attains a Signaled state, an attempt is made to satisfy a
wait for the mutex object.
<P>
A mutex object can only be released by the thread currently holding the mutex.
If an attempt is made to release a mutex not held by the thread, a bug check
occurs. An attempt to release a mutex object whose current state is Signaled
also causes a bug check to occur.
<P>
When a mutex object attains a Signaled state, it is removed from the list of
mutexes held by that thread. If the thread’s owned mutex list does not contain
any more entries, the thread’s original priority is restored.
<P>
If the value of the <I>Wait</I>&nbsp;parameter is TRUE, the return to the caller is
executed without lowering IRQL or releasing the dispatcher database spin lock.
Therefore, the call to <B>KeReleaseMutex</B>&nbsp;must be followed immediately by a
call to one of <B>KeWait</B><I>Xxx</I>.
<P>
This allows the caller to release a mutex and wait as one atomic operation,
preventing a possibly superfluous context switch. However, a caller cannot
wait at raised IRQL nor in an arbitrary thread context for a nonzero interval
on a mutex object.
<P>
If a mutex is acquired recursively, the holding thread must call <B>KeReleaseMutex</B>
as many times as it acquired the mutex to set it to the Signaled state.
<P>
Callers of <B>KeReleaseMutex</B>&nbsp;must be running at IRQL PASSIVE_LEVEL.
<H3>See Also</H3>
<P>
<B><A HREF="k102_60.htm">ExReleaseFastMutex</A></B>, <B><A HREF="k102_61.htm">ExReleaseFastMutexUnsafe</A></B>,
<B><A HREF="k105_18.htm">KeInitializeMutex</A></B>, <B><A HREF="k105_34.htm">KeReadStateMutex</A></B>,
<B><A HREF="k105_54.htm">KeWaitForMultipleObjects</A></B>, <B><A HREF="k105_55.htm">KeWaitForMutexObject</A></B>,
<B><A HREF="k105_56.htm">KeWaitForSingleObject</A></B>&nbsp;
<P></FONT>
</BODY>
</HTML>
