<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IoAssignResources</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_IoAssignResources_KR"></A>IoAssignResources</H2>
<P>
<B>NTSTATUS <BR>
&nbsp; &nbsp; IoAssignResources(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PUNICODE_STRING</B>&nbsp; <I>RegistryPath</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PUNICODE_STRING</B>&nbsp; <I>DriverClassName</I><B>,</B>&nbsp; &nbsp; &nbsp; &nbsp; /* optional */<BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PDRIVER_OBJECT</B>&nbsp; <I>DriverObject</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PDEVICE_OBJECT</B>&nbsp; <I>DeviceObject</I><B>,</B><I>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </I>/* optional */<BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PIO_RESOURCE_REQUIREMENTS_LIST</B>&nbsp; <I>RequestedResources</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN OUT PCM_RESOURCE_LIST</B>&nbsp; <I>*AllocatedResources</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>IoAssignResources </B>takes an input list of requested hardware resources
for a driver or device, claims an available set of hardware resources, such as
an interrupt vector, device memory range and/or I/O port range, and possibly a
particular DMA controller channel, in the <B>\Registry\Hardware\Machine\ResourceMap</B>
tree, and returns a list of allocated hardware resources for the driver or
device. As an alternative, drivers of PCI-type devices can call <B>HalAssignSlotResources</B>.
<H3>Parameters</H3>
<DL>
<DT>
<I>RegistryPath</I>
<DD>
Points to the <B>\Registry\Machine\System\CurrentControlSet\Services\</B><I>DriverName</I>
key or one of its subkeys, depending on whether the input <I>DeviceObject</I>
pointer is NULL. If a driver uses resources in common for all its devices, <I>RegistryPath</I>
is the pointer input to its DriverEntry routine and the <I>DeviceObject</I>
pointer must be NULL. A driver that needs device-specific hardware resources,
rather than driver-specific resources in common for all its devices, must pass
a <I>RegistryPath</I>&nbsp;pointer to an updated, device-specific string naming a
subkey of <I>DriverName</I>, at each call to <B>IoAssignResources</B>&nbsp;with a
nonNULL pointer to a unique <I>DeviceObject</I>.
<BR>
<DT>
<I>DriverClassName</I>
<DD>
Points to a buffered Unicode string that describes the class of driver under
which the driver’s configuration information should be stored. A default type <B>Other</B>
is used if none is given, and a new key is created in the registry if a unique
name is supplied.
<BR>
<DT>
<I>DriverObject</I>
<DD>
Points to the driver object that was input to the DriverEntry routine.
<BR>
<DT>
<I>DeviceObject</I>
<DD>
This pointer is optional. If it is NULL, the caller-supplied <I>RequestedResources</I>
list specifies resources that the driver itself needs, possibly to control
several devices that it supports. Otherwise, <I>DeviceObject</I>&nbsp;points to the
driver-created device object representing a physical device for which the
driver is attempting to claim device-specific hardware resources.
<BR>
<DT>
<I>RequestedResources</I>
<DD>
Points to a caller-supplied list of hardware resources needed to control its
device(s), which the driver has found by calling <B>HalGetBusData</B>, <B>HalGetBusDataByOffset</B>,
by interrogating its device, or by some other means. The caller must allocate
a buffer, which can be paged memory, for its IO_RESOURCE_REQUIREMENTS_LIST(s),
defined by the following structures:
</DL>
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
&nbsp; &nbsp; //
&nbsp; &nbsp; // This structure identifies the location on the I/O bus of the device
&nbsp; &nbsp; // or multifunction adapter for which the driver is supplying
&nbsp; &nbsp; // a variable-sized IO_RESOURCE_LIST requesting specific hardware resources.
&nbsp; &nbsp; //
&nbsp; &nbsp; ULONG ListSize;                  // in bytes
&nbsp; &nbsp; INTERFACE_TYPE InterfaceType;    // system-defined enum for the bus, one of
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Internal, Isa, Eisa, MicroChannel, TurboChannel
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// or PCIBus
&nbsp; &nbsp; ULONG BusNumber;                 // system-assigned and zero-based number of this bus
&nbsp; &nbsp; ULONG SlotNumber;                // logical slot or location on the bus of the device
&nbsp; &nbsp; ULONG Reserved[3];               // for system use
&nbsp; &nbsp; ULONG AlternativeLists;          // count of alternative IO_RESOURCE_LIST
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// elements with IO_RESOURCE_DESCRIPTORs
&nbsp; &nbsp; IO_RESOURCE_LIST List[1];        // contains a variable-sized array of descriptors
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST
</FONT></PRE>
<P>
A driver can supply any number of IO_RESOURCE_LIST elements, each containing
IO_RESOURCE_DESCRIPTORs specifying both preferred and alternative hardware
resources the driver can use, if the device or I/O bus does not constrain that
driver to using a fixed range of I/O ports or device memory, a fixed
bus-specific interrupt vector, and/or a particular DMA channel or port number.
In particular, drivers of devices that can be configured to use alternate sets
of hardware resources are expected to take advantage of this capability,
although drivers of PCI-type devices can call <B>HalAssignSlotResources</B>
instead. If <B>IoAssignResources </B>cannot claim a preferred set of
resources, it tries an alternative set and returns the set of resources
claimed as soon as it can satisfy the request with a given alternate resource
list. The IO_RESOURCE_LIST structure is defined as follows:
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _IO_RESOURCE_LIST {
&nbsp; &nbsp; USHORT Version;                  // of this structure, currently 1
&nbsp; &nbsp; USHORT Revision;                 // of this structure, currently 1
&nbsp; &nbsp; ULONG Count;                     // of IO_RESOURCE_DESCRIPTORs in array
&nbsp; &nbsp; IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST
</FONT></PRE>
<P>
Each descriptor in the IO_RESOURCE_LIST’s array specifies a single hardware
resource that the driver needs, prefers, or can use as an alternative to that
specified in another array element. Members of the IO_RESOURCE_DESCRIPTOR
structure are described separately, following this definition of the structure
itself:
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _IO_RESOURCE_DESCRIPTOR {
&nbsp; &nbsp; UCHAR Option;
&nbsp; &nbsp; UCHAR Type;
&nbsp; &nbsp; UCHAR ShareDisposition;
&nbsp; &nbsp; UCHAR Spare1;                               // reserved for system use
&nbsp; &nbsp; USHORT Flags;
&nbsp; &nbsp; USHORT Spare2;                              // reserved for system use

&nbsp; &nbsp; union{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG Length;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG Alignment;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PHYSICAL_ADDRESS MinimumAddress;  // 8-byte, bus-relative physical address
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PHYSICAL_ADDRESS MaximumAddress;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} Port;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG Length;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG Alignment;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PHYSICAL_ADDRESS MinimumAddress;  // 8-byte, bus-relative physical address
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PHYSICAL_ADDRESS MaximumAddress;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} Memory;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG MinimumVector;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG MaximumVector;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} Interrupt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG MinumumChannel;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ULONG MaximumChannel;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} Dma;
&nbsp; &nbsp; &nbsp;} u;
} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR
</FONT></PRE>
<H3>Members</H3>
<DL>
<DT>
Members of the IO_RESOURCE_DESCRIPTOR structure include the following:
<DD>
<B>Option</B>
<P>
Is set to IO_RESOURCE_PREFERRED to indicate the caller’s preferred setting for
the described resource if other descriptors in the list for the same type of
resource have this member set to IO_RESOURCE_ALTERNATIVE. This member should
be set to zero if the resource described is fixed: that is, the caller cannot
use an alternative. 
<DL>
<DT>
<B>Type</B>
<DD>
Specifies which of the following is contained in this descriptor: <B>CmResourceTypePort</B>,
<B>CmResourceTypeMemory</B>, <B>CmResourceTypeInterrupt</B>, or <B>CmResourceTypeDma</B>.
<BR>
<DT>
<B>ShareDisposition</B>
<DD>
Specifies whether or how this resource can be shared as one of the following: <B>CmResourceShareDeviceExclusive</B>,
<B>CmResourceShareDriverExclusive</B>, or <B>CmResourceShareShared</B>.
<BR>
<DT>
<B>Flags</B>
<DD>
Specifies type-dependent information about this descriptor:
<P>
<FONT FACE="Symbol">&#183;</FONT>&#09;When <B>Type</B>&nbsp;is set with <B>CmResourceTypePort</B>,
can be either of the following: CM_RESOURCE_PORT_MEMORY or
CM_RESOURCE_PORT_IO.
<P>
<FONT FACE="Symbol">&#183;</FONT>&#09;When <B>Type</B>&nbsp;is set with <B>CmResourceTypeMemory,</B>
can be one of the following: CM_RESOURCE_MEMORY_READ_WRITE,
CM_RESOURCE_MEMORY_READ_ONLY, or CM_RESOURCE_MEMORY_WRITE_ONLY.
<P>
<FONT FACE="Symbol">&#183;</FONT>&#09;When <B>Type</B>&nbsp;is set with <B>CmResourceTypeInterrupt,</B>
can be either of the following: CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE or
CM_RESOURCE_INTERRUPT_LATCHED<B>.</B>
<BR>
<DT>
<B>u.Port</B>
<DD>
Describes a bus-relative range of device ports in I/O space, including the <B>Length</B>
in bytes of the port range, the required byte <B>Alignment</B>&nbsp;boundary for
the range, its lowest possible <B>MinimumAddress</B>&nbsp;and its highest possible <B>MaximumAddress</B>
in the bus-relative physical address range of I/O port space. <B>Type</B>&nbsp;must
be <B>CmResourceTypePort</B>.
<BR>
<DT>
<B>u.Memory</B>
<DD>
Describes a bus-relative range of device memory in memory space, including the
<B>Length</B>&nbsp;in bytes of the range, the required byte <B>Alignment</B>
boundary for the range, its lowest possible <B>MinimumAddress</B>&nbsp;and its
highest possible <B>MaximumAddress</B>&nbsp;in the bus-relative physical address
range of device-memory space. <B>Type</B>&nbsp;must be <B>CmResourceTypeMemory</B>.
<BR>
<DT>
<B>u.Interrupt</B>
<DD>
Describes a range of one or more bus-relative interrupt vectors at which the
device can interrupt. <B>Type</B>&nbsp;must be <B>CmResourceTypeInterrupt</B>.
<BR>
<DT>
<B>u.Dma</B>
<DD>
Describes a range of one or more DMA channel numbers or MCA-type DMA port
numbers that the device can use. <B>Type</B>&nbsp;must be <B>CmResourceTypeDma</B>.
</DL>
<DT>
<I>AllocatedResources</I>
<DD>
Points to the address of an uninitialized pointer. If successful, <B>IoAssignResources</B>
resets this uninitialized pointer to a buffer it allocates for a returned
CM_RESOURCE_LIST, which describes the hardware resources it allocated for the
caller. The caller is responsible for freeing the buffer. 
</DL>
<H3>Return Value</H3>
<P>
<B>IoAssignResources </B>returns STATUS_SUCCESS if it claimed a set of the
specified hardware resources for the caller and returned information in the <I>AllocatedResources</I>
buffer. Otherwise, it returns an error status, resets the pointer at <I>AllocatedResources</I>
to NULL, and logs an error if it finds a resource conflict.
<H3>Comments</H3>
<P>
For most device drivers, calling <B>IoAssignResources</B>&nbsp;after locating the
device and getting whatever configuration information <B>HalGetBusData</B>&nbsp;or <B>HalGetBusDataByOffset</B>
can supply is preferable to making paired calls to <B>IoQueryDeviceDescription</B>
and <B>IoReportResourceUsage</B>.
<P>
Note that <B>IoAssignResources</B>&nbsp;does not handle IO_RESOURCE_DESCRIPTOR
entries with the <B>Type</B>&nbsp;member set to <B>CmResourceTypeDeviceSpecific</B>.
Drivers that have hardware resources of this type can call <B>IoReportResourceUsage</B>
to store this configuration information in the <B>\\Registry\..\ResourceMap</B>
tree. Otherwise, a successful call to <B>IoAssignResources</B>&nbsp;writes the
caller’s claims on every other type of hardware resource into the registry <B>\ResourceMap</B>
tree.
<P>
<B>IoAssignResources</B>&nbsp;automatically searches the registry for resource
conflicts between resources requested and resources claimed by previously
installed drivers. It first matches the preferred entries in the <I>RequestedResources</I>
descriptor array against all other resource lists stored in the registry to
determine whether a conflict exists. If it finds a conflict, it then matches
any supplied alternative descriptors for the already claimed resource again,
attempting to allocate a set of resources the caller can use.
<P>
The caller is responsible for releasing the <I>AllocatedResources</I>&nbsp;buffer,
which is pageable, with <B>ExFreePool</B>&nbsp;after it has consumed the returned
information and before the DriverEntry routine returns control.
<P>
If a driver claims resources on a device-specific basis for more than one
device, the driver must call this routine at least once for each such device,
and must update the <I>RegistryPath</I>&nbsp;string to supply a unique subkey name
for each call with a unique <I>DeviceObject</I>&nbsp;pointer.
<P>
This routine can be called more than once for a given device or driver. If a
new list of <I>RequestedResources</I>&nbsp;is supplied, it will overwrite or,
possibly, be appended to the previous resource list in the registry. However,
making a single call for each set of device-specific resources makes a driver
load much faster than if it calls <B>IoAssignResources</B>&nbsp;many times to amend
or incrementally construct the input <I>RequestedResources</I>&nbsp;for each of its
devices. Note that subsequent calls to <B>IoAssignResources</B>&nbsp;can reassign
the caller’s previously claimed resources if that caller does not adjust the
input <I>RequestedReources</I>&nbsp;to “fix” its claim on the resources to be kept.
<P>
A driver must call <B>IoAssignResources </B>with a value of NULL for the <I>RequestedResources</I>
parameter to erase its claim on resources in the registry if the driver is
unloaded.
<P>
Callers of <B>IoAssignResources</B>&nbsp;must be running at IRQL PASSIVE_LEVEL.
<H3>See Also</H3>
<P>
<A HREF="k112_11.htm">CM_RESOURCE_LIST</A>, <B><A HREF="k102_11.htm">ExAllocatePool</A></B>,
<B><A HREF="k102_14.htm">ExAllocatePoolWithTag</A></B>, <B><A HREF="k102_21.htm">ExFreePool</A></B>,
<B><A HREF="k103_2.htm">HalAssignSlotResources</A></B>, <B><A HREF="k103_6.htm">HalGetBusData</A></B>,
<B><A HREF="k103_7.htm">HalGetBusDataByOffse</B>t</A>, <B><A HREF="k104_65.htm">IoReportResourceUsage</A></B>,
<B><A HREF="k104_57.htm">IoQueryDeviceDescription</A></B>&nbsp;
<P></FONT>
</BODY>
</HTML>
