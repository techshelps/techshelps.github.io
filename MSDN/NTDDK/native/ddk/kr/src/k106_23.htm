<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MmLockPagableCodeSection</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_MmLockPagableCodeSection_KR"></A>MmLockPagableCodeSection</H2>
<P>
<B>PVOID <BR>
&nbsp; &nbsp; MmLockPagableCodeSection(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PVOID</B>&nbsp; <I>AddressWithinSection</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>MmLockPagableCodeSection </B>locks a section of driver code, containing a
set of driver routines marked with a special compiler directive, into system
space.
<H3>Parameters</H3>
<DL>
<DT>
<I>AddressWithinSection</I>
<DD>
Is a symbolic address, usually the entry point of a driver routine, within the
pageable section of driver code.
</DL>
<H3>Return Value</H3>
<P>
<B>MmLockPagableCodeSection</B>&nbsp;returns a handle for the locked-down section
of driver code. The handle must be passed subsequently to <B>MmLockPagableSectionByHandle</B>
or to <B>MmUnlockPagableImageSection</B>.
<H3>Comments</H3>
<P>
This routine and its reciprocal, <B>MmUnlockPagableImageSection</B>, support
drivers that can do the following:
<UL>
<LI>
Defer loading a subset of driver routines into resident memory until incoming
I/O requests for the driver’s device(s) make it necessary for these routines
to process IRPs
<P>
<LI>
Make the same subset of driver routines available for paging out when they
have completed the processing of I/O requests and no additional requests for
the driver’s device(s) are currently expected
</UL>
<P>
<B>MmLockPagableCodeSection</B>, <B>MmLockPagableSectionByHandle</B>&nbsp;and <B>MmUnlockPagableImageSection</B>
are intended for use by device and intermediate drivers that have the
following characteristics:
<UL>
<LI>
The driver has code paths that might not be needed while the system is
running, but, if they are needed, the driver’s code must be resident because
it runs in an arbitrary thread context and/or at raised IRQL.
<P>
<LI>
The driver can determine exactly when the pageable-routines should be loaded
and when they can be paged out again. 
</UL>
<P>
For example, the system-supplied fault-tolerant disk driver supports the
creation of mirror sets, stripe sets, and volume sets. Yet, a particular
machine can be configured only with a mirror set, only with a stripe set, only
with a volume set, or with any combination of these three possible options. In
these circumstances, the system ftdisk driver reduces the size of its loaded
image by marking routines that explictly support mirror, stripe, and volume
sets as belonging to pageable-code sections. During driver initialization,
pageable-code section(s) are made resident only if the user has configured the
disks to have mirror, stripe, and/or volume sets. If the user repartitions the
disks dynamically, the ftdisk driver loads any additional pageable-code
sections necessary to support any mirror, stripe, and/or volume sets that the
user requests.
<P>
As other examples, the system-supplied serial and parallel drivers have
DispatchCreate and DispatchClose routines that are called when a particular
port is opened for exclusive I/O and when the handle for an opened port is
released, respectively. Yet, serial and parallel I/O requests are sporadic,
determined by which applications the end user is currently running and which
application options the end user is currently exercising. In these
circumstances, the system serial and parallel drivers reduce the sizes of
their loaded images by marking many routines as belonging to a pageable-code
section that the DispatchCreate routine makes resident only when the first
port is opened for I/O. 
<P>
Note that each of the preceding system drivers satisfies both criteria for
having pageable sections: the driver has code paths that might not be needed
while the system is running and the driver can determine exactly when its
pageable section should be loaded and can be paged out again.
<P>
Note also that calling <B>MmLockPagableCodeSection</B>&nbsp;and <B>MmUnlockPagableImageSection</B>
reduce the size of each driver’s loaded image at a cost to the driver’s and
system’s performance. Drivers of performance-critical devices, such as
keyboard and mouse drivers, and drivers of devices that are constantly in use,
such as disk drivers, generally should not have pageable sections: the loss in
performance is simply not worth the temporary reduction in driver image size.
<P>
Because it is an expensive operation to lock down a section, if a
pageable-code section is locked down in more than place by a driver, use <B>MmLockPagableCodeSection</B>
for the first request. Make subsequent lock requests by calling <B>MmLockPagableSectionByHandle</B>
passing the handle returned by <B>MmLockPagableCodeSection</B>. Locking by
handle significantly improves driver performance because the memory manager
uses the handle to find the section rather than searching a loaded module
list. A locked down section is unlocked by calling <B>MmUnlockPagableImageSection</B>.
<P>
Each driver routine within a pageable code section must be marked with the
following compiler directive, supported by all Windows NT-compatible
compilers:
<P>
<B>#pragma alloc_text(PAGE</B><I>xxxx</I>, <I>DriverRoutine</I>), where <I>xxxx</I>
is an optional four-character, unique identifier for the caller’s pageable
section and <I>DriverRoutine</I>&nbsp;is an entry point to be included within the
pageable-code section. For Windows NT-compatible compilers, the keyword <B>PAGE</B>
and the driver-determined suffix, which can be up to four characters, are
case-sensitive, that is, <B>PAGE</B>&nbsp;must be capitalized.
<P>
A single call to <B>MmLockPagableCodeSection</B>&nbsp;in, for example, a driver’s
DispatchCreate routine causes the entire section, containing every driver
routine marked with the same <B>PAGE</B><I>xxxx</I>&nbsp;identifier to be locked in
system space.
<P>
Certain types of driver routines cannot be made part of any driver’s pageable
section, including the following:
<UL>
<LI>
Never make an ISR pageable. It is possible for a device driver to receive a
spurious interrupt even if its device is not in use, particularly if the
interrupt vector could be shared. In general, even if a driver can explictly
disable interrupts on its device, an ISR should not be made pageable.
<P>
<LI>
Never make a DPC routine pageable if the driver cannot control when the DPC is
queued, such as any DpcForIsr or CustomDpc routine that might be queued from
an ISR. In general, driver routines that run at raised IRQL and that can be
called in an arbitrary thread context or in response to a random external
event should not be made pageable.
<P>
<LI>
Never make the DispatchRead or DispatchWrite routine pageable in any driver
that might be part of the system paging I/O path. The driver of a disk that
might contain the system page file must have DispatchRead and DispatchWrite
routines that are resident while the system is running, as must all drivers
layered above such a disk driver.
</UL>
<P>
Note that routines in a pageable section marked with the compiler directive <B>#pragma
alloc_text(PAGExxxx, ...)</B>differ from routines marked with the compiler
directive <B>#pragma alloc_text(INIT, ...)</B>. The routines in the <B>INIT </B>section
are not pageable and are discarded as soon as the driver returns from its
DriverEntry or its Reinitialize routine, if it has one.
<P>
The Memory Manager maintains an internal lock count on any driver’s
pageable-section. Calls to <B>MmLockPagableCodeSection</B>&nbsp;increment this
count and the reciprocal <B>MmUnlockPagableImageSection</B>&nbsp;decrements the
count. A driver’s pageable section is not available to be paged out unless
this count is zero.
<P>
Callers of <B>MmLockPagableCodeSection </B>and <B>MmLockPagableDataSection</B>
must take care to use the former for code sections and the latter for data
sections. If the incorrect form of <B>MmLockPagableXxxxSection</B>&nbsp;is used, a
fatal error will occur on some platforms.
<P>
For more information on creating pageable code sections, see <I>The
Programmer’s Guide</I>.
<P>
Callers of <B>MmLockPagableCodeSection </B>run at IRQL PASSIVE_LEVEL.
<H3>See Also</H3>
<P>
<B><A HREF="k106_35.htm">MmUnlockPagableImageSection</A></B>,
<B><A HREF="k106_28.htm">MmPageEntireDriver</A></B>, <B><A HREF="k106_29.htm">MmResetDriverPaging</A></B>,
<B><A HREF="k106_24.htm">MmLockPagableDataSection</A></B>, <B><A HREF="k106_25.htm">MmLockPagableSectionByHandle</A></B>
<P></FONT>
</BODY>
</HTML>
