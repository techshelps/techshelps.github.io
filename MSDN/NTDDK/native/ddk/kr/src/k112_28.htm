<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRP</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_IRP_KR"></A>IRP</H2>
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _IRP {
&nbsp; &nbsp; .
&nbsp; &nbsp; .
&nbsp; &nbsp; PMDL MdlAddress;
&nbsp; &nbsp; ULONG Flags;
&nbsp; &nbsp; union {
&nbsp; &nbsp; &nbsp; &nbsp; struct _IRP *MasterIrp;
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; PVOID SystemBuffer;
&nbsp; &nbsp; } AssociatedIrp;
&nbsp; &nbsp; .
&nbsp; &nbsp; .
&nbsp; &nbsp; IO_STATUS_BLOCK IoStatus;
&nbsp; &nbsp; KPROCESSOR_MODE RequestorMode;
&nbsp; &nbsp; .
&nbsp; &nbsp; .
&nbsp; &nbsp; BOOLEAN Cancel;
&nbsp; &nbsp; KIRQL CancelIrql;
&nbsp; &nbsp; .
&nbsp; &nbsp; .
&nbsp; &nbsp; PDRIVER_CANCEL CancelRoutine;
&nbsp; &nbsp; PVOID UserBuffer;
&nbsp; &nbsp; union {
&nbsp; &nbsp; &nbsp; &nbsp; struct {
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; union {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVOID DriverContext[4];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };
&nbsp; &nbsp; &nbsp; &nbsp; };
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; PETHREAD Thread;
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; LIST_ENTRY ListEntry;
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; } Overlay;
&nbsp; &nbsp; .
&nbsp; &nbsp; .
&nbsp; &nbsp; } Tail;
} IRP, *PIRP;
</FONT></PRE>
<P>
In addition to the request-specific parameters in each driver’s I/O stack
location in an IRP, drivers also can use the following members of the IRP
structure for various purposes.
<H3>Members</H3>
<DL>
<DT>
<B>MdlAddress</B>
<DD>
Points to an MDL describing a user buffer for an IRP_MJ_READ or IRP_MJ_WRITE
request if the driver set up its device object(s) for direct I/O. Drivers that
handle IRP_MJ_INTERNAL_DEVICE_CONTROL requests also use this field if the I/O
control code was defined with METHOD_DIRECT. For more information about
IOCTLs, see <A HREF="k201.htm">Part II</A>&nbsp;of this
manual.
<BR>
<DT>
<B>Flags</B>
<DD>
File system drivers use this field, which is read-only for all drivers.
Network and, possibly, highest-level device drivers also might read this
field, which can be set with one or more of the following system-defined
masks:
<P>
IRP_NOCACHE<BR>
IRP_PAGING_IO<BR>
IRP_MOUNT_COMPLETION<BR>
IRP_SYNCHRONOUS_API<BR>
IRP_ASSOCIATED_IRP<BR>
IRP_BUFFERED_IO<BR>
IRP_DEALLOCATE_BUFFER<BR>
IRP_INPUT_OPERATION<BR>
IRP_SYNCHRONOUS_PAGING_IO<BR>
IRP_CREATE_OPERATION<BR>
IRP_READ_OPERATION<BR>
IRP_WRITE_OPERATION<BR>
IRP_CLOSE_OPERATION<BR>
IRP_DEFER_IO_COMPLETION
<BR>
<DT>
<B>AssociatedIrp.MasterIrp</B>
<DD>
Points to the master IRP in an IRP that was created by a highest-level
driver’s call to <B>IoMakeAssociatedIrp</B>.
<BR>
<DT>
<B>AssociatedIrp.SystemBuffer</B>
<DD>
Points to a system-space buffer for one of the following: (1) a transfer
request to a driver that set up its device object(s) requesting buffered I/O;
(2) an IRP_MJ_DEVICE_CONTROL request, (3) an IRP_MJ_INTERNAL_DEVICE_CONTROL
request with an I/O control code that was defined with METHOD_BUFFERED. In any
case, the underlying device driver usually transfers data to or from this
buffer.
<BR>
<DT>
<B>IoStatus</B>
<DD>
Is the I/O status block in which a driver stores status and information before
calling <B>IoCompleteRequest</B>.
<BR>
<DT>
<B>RequestorMode</B>
<DD>
Indicates the execution mode of the original requestor of the operation, one
of <B>UserMode</B>&nbsp;or <B>KernelMode</B>.
<BR>
<DT>
<B>Cancel</B>
<DD>
If set to TRUE, the IRP either is or should be cancelled.
<BR>
<DT>
<B>CancelIrql</B>
<DD>
Is the IRQL at which a driver is running when <B>IoAcquireCancelSpinLock</B>
is called. 
<BR>
<DT>
<B>CancelRoutine</B>
<DD>
Is the entry point for a driver-supplied Cancel routine to be called if the
IRP is cancelled. NULL indicates that the IRP is not currently cancelable.
<BR>
<DT>
<B>UserBuffer</B>
<DD>
Contains the address of an output buffer if the major function code in the I/O
stack location is IRP_MJ_INTERNAL_DEVICE_CONTROL and the I/O control code was
defined with METHOD_NEITHER.
<BR>
<DT>
<B>Tail.Overlay.DeviceQueueEntry</B>
<DD>
If IRPs are queued in the device queue associated with the driver’s device
object, this field links IRPs in the device queue. These links can be used
only while the driver is processing the IRP.
<BR>
<DT>
<B>Tail.Overlay.DriverContext</B>
<DD>
If IRPs are not queued in the device queue associated with the driver’s device
object, this field can be used by the driver to store up to four pointers.
This field can be used only while the driver owns the IRP.
<BR>
<DT>
<B>Tail.Overlay.Thread</B>
<DD>
Is a pointer to the caller’s thread control block. Higher-level drivers that
allocate IRPs for lower-level removable-media drivers must set this field in
the IRPs they allocate. Otherwise, the FSD cannot determine which thread to
notify if the underlying device driver indicates that the media requires
verification.
<BR>
<DT>
<B>Tail.Overlay.ListEntry</B>
<DD>
If a driver manages its own internal queue(s) of IRPs, it uses this field to
link one IRP to the next. These links can be used only while the driver is
holding the IRP in its queue or is processing the IRP.
</DL>
<H3>Comments</H3>
<P>
Undocumented members of the IRP are reserved, used only by the I/O Manager or,
in some cases, by FSDs.
<P>
Each IRP also has one or more I/O stack locations for the driver(s) that
process the request. A driver must call <B>IoGetCurrentIrpStackLocation</B>&nbsp;to
get a pointer to its own stack location in each IRP. Higher-level drivers must
call <B>IoGetNextIrpStackLocation</B>&nbsp;to get a pointer to the next-lower
driver’s stack location so the higher-level driver can set it up before
calling <B>IoCallDriver</B>&nbsp;with the IRP.
<P>
While a higher-level driver might check the value of the <B>Cancel</B>&nbsp;Boolean
in an IRP, that driver cannot assume the IRP will be completed with
STATUS_CANCELLED by a lower-level driver even if the value is TRUE.
<H3>See Also</H3>
<P>
<B><A HREF="k104_22.htm">IoCreateDevice</A></B>, <B><A HREF="k104_40.htm">IoGetCurrentIrpStackLocation</A></B>,
<B><A HREF="k104_47.htm">IoGetNextIrpStackLocation</A></B>, <B><A HREF="k104_67.htm">IoSetCancelRoutine</A></B>,
<B><A HREF="k104_70.htm">IoSetNextIrpStackLocation</A></B>, <A HREF="k112_26.htm">IO_STACK_LOCATION</A>,
<A HREF="k112_27.htm">IO_STATUS_BLOCK</A>&nbsp;
<P></FONT>
</BODY>
</HTML>
