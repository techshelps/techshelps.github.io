<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IoReadPartitionTable</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_IoReadPartitionTable_KR"></A>IoReadPartitionTable</H2>
<P>
<B>NTSTATUS <BR>
&nbsp; &nbsp; IoReadPartitionTable(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PDEVICE_OBJECT</B>&nbsp; <I>DeviceObject</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN ULONG</B>&nbsp; <I>SectorSize</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN BOOLEAN</B>&nbsp; <I>ReturnRecognizedPartitions</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>OUT struct _DRIVE_LAYOUT_INFORMATION</B>&nbsp; <I>**PartitionBuffer</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>IoReadPartitionTable</B>&nbsp;reads a list of partitions on a disk having a
specified sector size and creates an entry in the partition list for each
recognized partition.
<H3>Parameters</H3>
<DL>
<DT>
<I>DeviceObject</I>
<DD>
Points to the device object for the disk whose partitions are to be read.
<BR>
<DT>
<I>SectorSize</I>
<DD>
Specifies the size of the sectors on the disk.
<BR>
<DT>
<I>ReturnRecognizedPartitions</I>
<DD>
Indicates whether only recognized partitions or all partition entries should
be returned.
<BR>
<DT>
<I>PartitionBuffer</I>
<DD>
Is a pointer to an uninitialized address. If successful, <B>IoReadPartitionTable</B>
allocates the memory for this buffer from nonpaged pool and returns the drive
layout information in it.
</DL>
<H3>Return Value</H3>
<P>
This routine returns a value of STATUS_SUCCESS if at least one sector table
was read. Otherwise, it returns an error status and sets the pointer at <I>PartitionBuffer</I>
to NULL.
<H3>Comments</H3>
<P>
Disk device drivers call this routine during driver initialization.
<P>
It is the responsibility of the caller to deallocate the <I>PartitionBuffer</I>
that was allocated by this routine with <B>ExFreePool</B>.
<P>
The algorithm used by this routine is determined by the Boolean value <I>ReturnRecognizedPartitions</I>:
<UL>
<LI>
Read each partition table and, for each valid and recognized partition found,
fill in a partition information entry. Extended partitions are located in
order to find other partition tables, but no entries are built for them.
<P>
<LI>
Read each partition table and, for each and every entry, fill in a partition
information entry. Extended partitions are located to find each partition on
the disk, and entries are built for these as well.
</UL>
<P>
The drive layout structure contains a variable-sized array of partition
information elements, defined as follows:
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _DRIVE_LAYOUT_INFORMATION {
&nbsp; &nbsp; ULONG PartitionCount;
&nbsp; &nbsp; ULONG Signature;                // of disk
&nbsp; &nbsp; PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;
&nbsp;
typedef strtuct _PARTITION_INFORMATION {
&nbsp; &nbsp; LARGE_INTEGER StartingOffset;
&nbsp; &nbsp; LARGE_INTEGER PartitionLength;
&nbsp; &nbsp; ULONG HiddenSectors;
&nbsp; &nbsp; ULONG PartitionNumber;
&nbsp; &nbsp; UCHAR PartitionType;            // 12-bit FAT etc.
&nbsp; &nbsp; BOOLEAN BootIndicator;
&nbsp; &nbsp; BOOLEAN RecognizedPartition;
&nbsp; &nbsp; BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;
&nbsp;</FONT></PRE>
<P>
For the currently defined <I>PartitionType</I>&nbsp;values, see the Win32 SDK.
<P>
Note that disk drivers also use the DRIVE_LAYOUT_INFORMATION structure to
return and set partition information in response to IRP_MJ_DEVICE_CONTROL
requests with the following I/O control codes:
<P>
IOCTL_DISK_GET_PARTITION_INFO<BR>
IOCTL_DISK_GET_DRIVE_LAYOUT<BR>
IOCTL_DISK_SET_DRIVE_LAYOUT
<P>
Callers of <B>IoReadPartitionTable</B>&nbsp;must be running at IRQL PASSIVE_LEVEL.
<H3>See Also</H3>
<P>
IOCTL_DISK_GET_PARTITION_INFO, IOCTL_DISK_GET_DRIVE_LAYOUT,
IOCTL_DISK_SET_DRIVE_LAYOUT, <B><A HREF="k104_71.htm">IoSetPartitionInformation</A></B>,
<B><A HREF="k104_82.htm">IoWritePartitionTable</A></B>&nbsp;
<P></FONT>
</BODY>
</HTML>
