<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MmLockPagableSectionByHandle</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_MmLockPagableSectionByHandle_KR"></A>MmLockPagableSectionByHandle</H2>
<P>
<B>VOID <BR>
&nbsp; &nbsp; MmLockPagableSectionByHandle</B>(<I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; </I><B>IN PVOID  </B><I>ImageSectionHandle</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>MmLockPagableSectionByHandle</B>&nbsp;takes a handle returned by <B>MmLockPagableDataSection
</B>or <B>MmLockPagableCodeSection</B>. This routine checks to see if the
referenced section is resident in the caller’s address space and if so, simply
increments a reference count on the section. If the section is not resident, <B>MmLockPagableImage</B>
pages in the section, locks it in system space and sets the reference count to
one.
<H3>Parameters</H3>
<DL>
<DT>
<I>ImageSectionHandle</I>
<DD>
Supplies the handle returned by a call to <B>MmLockPagableCodeSection</B>&nbsp;or <B>MmLockPagableDataSection</B>.
</DL>
<H3>Return Value</H3>
<P>
None.
<H3>Comments</H3>
<P>
If a pageable section is locked down in more than one place by a driver, use <B>MmLockPagableXxxxSection</B>
for the first request. Make subsequent lock requests by calling <B>MmLockPagableSectionByHandle</B>
passing the handle returned by <B>MmLockPagableXxxxSection</B>. A locked down
section is unlocked by calling <B>MmUnlockPagableImageSection</B>.
<P>
A handle returned from an <B>MmLockPagableXxxxSection</B>&nbsp;is valid until a
driver is unloaded.
<P>
Locking by handle significantly improves driver performance. When <B>MmLockPagableCodeSection</B>
or <B>MmLockPagableDataSection</B>&nbsp;is called, the memory manager walks the
entire loaded module list to find the module containing the specified address.
This is an expensive operation. Calling <B>MmLockPagableImageSectionByHandle</B>
reduces this burden because if the caller supplies a handle to the section,
the memory manager no longer has to search.
<P>
The memory manager maintains a reference count on the handle to the section. A
pageable section is only available to be paged out when the reference count is
zero. Every lock request increments the count; every unlock request decrements
the count. A driver must take care to unlock a section as many times as it
locks a section to insure that such a section will be eligible to be paged out
when the section is not needed. Once a handle is obtained, it is always valid,
no matter what the count until the driver is unloaded. If the count on a
handle is zero and a call is made to <B>MmLockPagableSectionByHandle</B>, the
count is set to one, and if the section has been paged out, it will be paged
in.
<P>
A driver cannot call <B>MmLockPagableSectionByHandle</B>&nbsp;to lock down user
buffers passed in IRPs. Use <B>MmProbeAndLockPages</B>&nbsp;instead.
<P>
For more information about paging code and data, see <I>The Programmer’s Guide</I>.
<P>
Callers of <B>MmLockPagableSectionByHandle</B>&nbsp;runs at IRQL PASSIVE_Level.
<H3>See Also</H3>
<P>
<B><A HREF="k106_24.htm">MmLockPagableDataSection</A></B>, <B><A HREF="k106_23.htm">MmLockPagableCodeSection</A></B>,
<B><A HREF="k106_31.htm">MmProbeAndLockPages</A></B>, <B><A HREF="k106_28.htm">MmPageEntireDriver</A></B>,
<B><A HREF="k106_29.htm">MmResetDriverPaging</A></B>, <B><A HREF="k106_35.htm">MmUnlockPagableImageSection</A></B>
<P></FONT>
</BODY>
</HTML>
