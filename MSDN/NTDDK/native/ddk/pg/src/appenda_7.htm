<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A.3.1.1  Shell Sections</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Shell_Sections_PG"></A>A.3.1.1  Shell Sections</H4>
<P>
A shell section is similar to a function in other programming languages. You
can pass multiple parameters to a shell section and receive multiple return
values. Each shell section has a separate symbol table for storing its
variables and their values. 
<P>
The entrypoint sections used by the Setup program ([Identify],
[ReturnOptions], [InstallOption]) are shell sections. The other types of
sections ([Install] and [Detect]) are called by a command line in a shell
section. 
<H5>Shell Syntax</H5>
<P>
The following is the syntax for calling a shell section: 
<PRE><FONT FACE="Courier" SIZE="2"><B>shell</B>&nbsp;inf_file_path section_name [Args]*
&nbsp;</FONT></PRE>
<DL>
<DT>
<I>inf_file_path</I>
<DD>
Specifies the full or partial path of the INF file in which the section is
located. An empty string (““) indicates the current file.
<BR>
<DT>
<I>section_name</I>
<DD>
Identifies the section (name in square brackets).
<BR>
<DT>
<I>Args</I>
<DD>
Zero or more comma-separated or whitespace-separated arguments.
</DL>
<P>
You can use the shell command from within a shell section to call another
shell section (in the same file or in a different INF file). 
<H5>$Shell Code</H5>
<P>
For a shell operation, Setup sets the value of the variable $ShellCode to one
of the following:
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
!SHELL_CODE_OK
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Shelling operation was successful
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
!SHELL_CODE_NO_SUCH_INF
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Named INF file could not be located
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
!SHELL_CODE_NO_SUCH_SECTION
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
The INF  file did not contain named section
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
!SHELL_CODE_ERROR
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Parsing error in INF section
</FONT></TABLE>
<P>
Programmers must check the value of $ShellCode before assuming that the return
values and side-effects of the shelling operation actually apply.
<H5>Symbol Table Levels</H5>
<P>
Setup stores all its variable names and their values in its internal memory in
an area called the symbol table. The shell statement has a special and very
important effect on the symbol table.
<P>
When a shell statement is processed, <I>a completely new symbol table is
created</I>. The original symbol table values are no longer directly
accessible, and new variables and values are stored in this new, separate
table. When the shelled section returns, this new symbol table is discarded.
This behavior is similar to the “block scoping” rules common in procedural
programming languages such as C.
<P>
The reason for such behavior is to avoid duplication or “collision” of
variable names. The writer of an INF subroutine which is the target of a shell
statement can be sure that variables he creates will not accidentally override
global values.
<P>
This multi-level symbol table mechanism creates a new problem: how does a
shelled section change or reference the value of a variable outside of its
private, temporary symbol table? The answer is that Setup has special syntax
for referencing variables which are nonlocal. The possibilities are:
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
local
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
$(MyVar)
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
reference to local variable MyVar
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
global
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
$(!MyVar)
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
reference to global variable MyVar
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
global
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
$(!G:MyVar)
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
reference to global variable MyVar
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
parent
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
$(!P:MyVar)
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
reference to caller’s variable MyVar
</FONT></TABLE>
<P>
The outermost (or base) Setup symbol table is called the global symbol table.
Variables created by Setup itself during initialization and the top-level INF
file reside in the global symbol table. Setup allows access to three possibly
distinct symbol tables: the local one, the one belonging to the shelling INF
section, and the global one.
<H5>Passing Arguments to a Shell Section</H5>
<P>
The Setup program stores a shell’s input parameters in the shell’s symbol
table using variables of the form $<I>N</I>, where <I>N</I>&nbsp;refers to the
zero-based position of the parameter in the argument list. The shell can then
use the $(<I>var</I>) notation to retrieve the argument’s value, that is,
$($0) retrieves the value of <I>Arg0</I>, $($1) is the value of <I>Arg1</I>,
and so on. Using the <B>Return</B>&nbsp;command, a shell section can return zero or
more values to the section that called it. The following example shows a shell
section that retrieves its arguments and returns two values:
<PRE><FONT FACE="Courier" SIZE="2">[SampleShellSection]
&nbsp;
; retrieve the input parameters
&nbsp;
<B>set</B>&nbsp;Arg0 = $($0)
<B>set</B>&nbsp;Arg1 = $($1)
&nbsp; &nbsp;.
&nbsp; &nbsp;.
&nbsp; &nbsp;.
; return two values
&nbsp;
<B>set Option</B>&nbsp;= &quot;OptionString&quot;
<B>Return</B>&nbsp;STATUS_SUCCESSFUL $(Option)
&nbsp;</FONT></PRE>
<H5>Return Values From a Shell Section</H5>
<P>
The Setup program stores a shell section’s return values in the symbol table
of its parent shell section (that is, the shell that called it), using
variables of the form $R<I>N</I>, where <I>N</I>&nbsp;refers to the zero-based
position of value in the list of return values. The parent shell can then use
the $(<I>var</I>) notation to retrieve the return values (that is, $($R0)
retrieves the first return value, $($R1)the second return value, and so on).
The Setup program uses the $R<I>N</I>&nbsp;variable to store the number of return
values. In addition to the values returned by a shell section, the Setup
program sets the <B>ShellCode</B>&nbsp;global variable to indicate whether errors
occurred during its interpretation of the section. The following example shows
the command lines that call a shell section, then retrieve the results:
<PRE><FONT FACE="Courier" SIZE="2">; pass two parameters to AShellSection
&nbsp;
<B>set</B>&nbsp;Arg0 = &quot;argument 0&quot;
<B>set</B>&nbsp;Arg1 = argument1
&nbsp;
; invoke section named AShellSection in the current inf file
&nbsp;
<B>shell</B>&nbsp;&quot;&quot; AShellSection $(Arg0) $(Arg1)
&nbsp;
; check ShellCode for internal errors during AShellSection execution
&nbsp;
<B>ifint</B>&nbsp;$($ShellCode) != $(!SHELL_CODE_OK)
<B>exit</B>
<B>endif</B>
&nbsp;
; get the return values
&nbsp;
<B>set Status</B>&nbsp;= $($R0)
<B>set Option</B>&nbsp;= $($R1)
<B>ifint</B>&nbsp;$($R#) &gt; 2
<B>set OptionText</B>&nbsp;= $($R2)
<B>endif</B>
&nbsp;</FONT></PRE>
<P></FONT>
</BODY>
</HTML>
