<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NdisMRegisterInterrupt</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_NdisMRegisterInterrupt_NR"></A>NdisMRegisterInterrupt</H2>
<P>
<B>NDIS_STATUS <BR>
&nbsp; &nbsp; NdisMRegisterInterrupt(<BR>
&nbsp; &nbsp; &nbsp; &nbsp; OUT PNDIS_MINIPORT_INTERRUPT</B>&nbsp;<I>Interrupt</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN NDIS_HANDLE</B>&nbsp;<I>MiniportAdapterHandle</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN UINT</B>&nbsp;<I>InterruptVector</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN UINT</B>&nbsp;<I>InterruptLevel</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN BOOLEAN</B>&nbsp;<I>RequestIsr</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN BOOLEAN</B>&nbsp;<I>SharedInterrupt</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN NDIS_INTERRUPT_MODE</B>&nbsp;<I>InterruptMode<BR>
</I>&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>NdisMRegisterInterrupt</B>&nbsp;sets up a mapping between a NIC driver’s
MiniportISR and MiniportHandleInterrupt functions, already registered with <B>NdisMRegisterMiniport</B>,
and the bus-relative vector and level on which its NIC interrupts.
<H3>Parameters</H3>
<DL>
<DT>
<I>Interrupt</I>
<DD>
Points to caller-allocated resident memory containing an opaque interrupt
object, which <B>NdisMRegisterInterrupt</B>&nbsp;initializes and for which it
returns a handle the miniport uses in subsequent calls to <B>NdisMSynchronizeWithInterrupt</B>.
<BR>
<DT>
<I>MiniportAdapterHandle</I>
<DD>
Specifies the handle input to MiniportInitialize.
<BR>
<DT>
<I>InterruptVector</I>
<DD>
Specifies the bus-relative vector number used by the NIC. 
<BR>
<DT>
<I>InterruptLevel</I>
<DD>
Specifies the bus-relative DIRQL for the interrupt. This value is almost
always the same as that of <I>InterruptVector</I>.
<BR>
<DT>
<I>RequestIsr</I>
<DD>
Specifies TRUE if the MiniportISR function should be called each time the NIC
interrupts. If the NIC can share an interrupt with other devices on the I/O
bus, this parameter must be set to TRUE. 
<BR>
<DT>
<I>SharedInterrupt</I>
<DD>
Specifies TRUE if other devices on the I/O bus can use this interrupt line. If
this parameter is set to FALSE and another device already claimed the given
interrupt vector in the registry, <B>NdisMRegisterInterrupt</B>&nbsp;will fail.
<BR>
<DT>
<I>InterruptMode</I>
<DD>
Specifies the type of interrupt that the NIC generates as one of the following
values:
<DL>
<DT>
<B>NdisInterruptLatched</B>
<DD>
Interrupts are triggered by a transition from low to high on the interrupt
line.
<BR>
<DT>
<B>NdisInterruptLevelSensitive</B>
<DD>
Interrupts are active as long as the interrupt line is asserted.
</DL>
</DL>
<H3>Return Value</H3>
<P>
<B>NdisMRegisterInterrupt</B>&nbsp;can return one of the following:
<DL>
<DT>
NDIS_STATUS_SUCCESS
<DD>
NDIS initialized the interrupt object and returned a valid <I>Interrupt</I>
handle, claimed hardware resources in the registry for the NIC, such as the
given vector if the NIC does not share an IRQ, and set up the MiniportISR (or
MiniportDisableInterrupt) and associated MiniportHandleInterrupt functions to
be called when an interrupt occurs as requested in the call to <B>NdisMRegisterInterrupt</B>.
<BR>
<DT>
NDIS_STATUS_RESOURCE_CONFLICT
<DD>
An attempt to claim the vector or level in the registry has failed, possibly
because another driver already claimed the interrupt for its device. <B>NdisMRegisterInterrupt</B>
logs an error if this occurs. 
<BR>
<DT>
NDIS_STATUS_RESOURCES
<DD>
NDIS could not allocate sufficient memory to claim resources in the registry
for the NIC. 
<BR>
<DT>
NDIS_STATUS_FAILURE
<DD>
The attempt to initialize the interrupt object failed, possibly due to another
driver’s prior claim on the <I>InterruptVector</I>&nbsp;or <I>InterruptLevel</I>&nbsp;in
the registry. 
</DL>
<H3>Comments</H3>
<P>
A NIC driver must call <B>NdisMRegisterInterrupt</B>&nbsp;from its
MiniportInitialize function if its NIC generates interrupts. The driver of a
NIC that does not generate interrupts calls <B>NdisMInitializeTimer</B>&nbsp;and <B>NdisMSetPeriodicTimer</B>
instead of <B>NdisMRegisterInterrupt</B>. 
<P>
MiniportInitialize must call <B>NdisMSetAttributes</B>&nbsp;or <B>NdisMSetAttributesEx</B>
before calling <B>NdisMRegisterInterrupt</B>. 
<P>
MiniportInitialize obtained the bus-relative values passed to <B>NdisMRegisterInterrupt</B>
either from the registry or by calling a bus-type-specific <B>Ndis</B><I>Xxx</I>
configuration function. 
<P>
If its call to <B>NdisMRegisterInterrupt</B>&nbsp;fails, MiniportInitialize should
release all resources it already allocated for its NIC and, then, fail
initialization for that NIC. 
<P>
<B>NdisMRegisterInterrupt</B>&nbsp;distinguishes between the <I>InterruptVector</I>
(the interrupt line that the card asserts to interrupt the system) and the <I>InterruptLevel</I>
(the hardware priority, that is, the DIRQL, of that interrupt assigned by the
system). Usually, these values can be assumed to be equal, unless the driver
writer knows that they are different for a particular NIC or unless the
miniport controls more than one NIC that share resources in the current
platform. 
<P>
If its NIC can share an IRQ with other devices on the I/O bus, the caller of <B>NdisMRegisterInterrupt</B>
must set both the <I>SharedInterrupt</I>&nbsp;and <I>RequestIsr</I>&nbsp;parameters to
TRUE. Such a NIC driver’s MiniportISR can be called when no interrupt for the
NIC is outstanding. In these circumstances, MiniportISR should return FALSE as
soon as possible, indicating that the interrupt was not recognized and should
leave interrupts enabled on its NIC.
<P>
When interrupts are enabled on the NIC, a driver’s MiniportISR can be called
at any time following a successful call to <B>NdisMRegisterInterrupt</B>, even
during initialization. Such a driver’s MiniportInitialize function should not
call <B>NdisMRegisterInterrupt</B>&nbsp;until it has set up all state the driver
needs to handle an interrupt. The MiniportHandleInterrupt function is not
queued for subsequent execution if the driver’s MiniportInitialize function is
currently executing and an interrupt occurs.
<P>
For most drivers of NICs that do not share an IRQ, the MiniportISR function
seldom runs except, possibly, during driver initialization. Such a miniport
sets <I>RequestIsr</I>&nbsp;to FALSE when MiniportInitialize calls <B>NdisMRegisterInterrupt</B>,
and such a driver has a MiniportDisableInterrupt function and, possibly, a
MiniportEnableInterrupt function. The NDIS library then calls the driver’s
MiniportDisableInterrupt function when an interrupt occurs on the NIC and the
driver’s MiniportHandleInterrupt function does most of the I/O processing for
the interrupt. Before MiniportHandleInterrupt returns control, either NDIS
calls MiniportEnableInterrupt or MiniportHandleInterrupt re-enables interrupts
on the NIC itself. 
<P>
Whether a miniport with an ISR sets <I>RequestIsr</I>&nbsp;to TRUE when it calls <B>NdisMRegisterInterrupt</B>
or not, NDIS acknowledges the interrupt to the operating system so that
interrupts from other devices are not blocked. 
<P>
If a miniport sets <I>RequestIsr</I>&nbsp;to TRUE when it calls <B>NdisMRegisterInterrupt</B>,
it must dismiss the interrupt on its NIC by setting the state of the network
interface card so that the NIC no longer asserts the interrupt. Interrupts can
remain enabled on the NIC following the dismissal of the interrupt, or they
can be disabled, depending on the design of the driver. The timing of such a
dismissal depends on the <I>InterruptMode</I>&nbsp;specified when the driver called
<B>NdisMRegisterInterrupt</B>, as follows:
<UL>
<LI>
For <B>NdisInterruptLevelSensitive</B>&nbsp;interrupts, MiniportISR must dismiss
each interrupt as its NIC generates that interrupt. Otherwise, the interrupt
is reasserted on the NIC as soon as MiniportISR returns control. If
MiniportISR determines that the NIC did not generate a particular interrupt,
it should return control with FALSE as soon as possible so that the ISRs for
other devices on the same bus can be called promptly to dismiss the interrupt
on the device that actually generated that interrupt. 
<P>
<LI>
For <B>NdisInterruptLatched</B>&nbsp;interrupts, dismissing an interrupt on the NIC
is not as time-critical as it is for shared interrupts. If the miniport is
designed such that each call to MiniportISR causes a subsequent call to the
associated MiniportHandleInterrupt function, MiniportHandleInterrupt can
dismiss the interrupt on the NIC. As an alternative, such a driver can set <I>RequestIsr</I>
to FALSE when it calls <B>NdisMRegisterInterrupt</B>&nbsp;and supply a
MiniportDisableInterrupt function, which will be called instead of MiniportISR
unless MiniportHalt or MiniportInitialize is currently executing. 
</UL>
<P>
When a miniport supports full-duplex sends and receives, NDIS serializes calls
to its MiniportISR or MiniportDisableInterrupt function for sends. NDIS
separately serializes calls to its MiniportISR or MiniportDisableInterrupt
function for all other operations that can cause an interrupt. Calls to the
MiniportReset function are both synchronized and synchronous; NDIS prevents
all other code paths in a full-duplex miniport from being entered while a
device-reset operation is occurring. 
<P>
If a miniport does not support full-duplex sends and receives, NDIS serializes
all calls to the MiniportISR or MiniportDisableInterrupt function for any NIC
the miniport controls. While such a driver’s MiniportISR or
MiniportDisableInterrupt function is processing a particular NIC interrupt, it
will not be called to handle a second interrupt from the same NIC on another
processor in an SMP machine. 
<P>
However, the ISR (or MiniportDisableInterrupt function) of any driver that
controls more than one device can run concurrently in SMP platforms if two of
that driver’s devices happen to generate interrupts almost simultaneously and
interrupts are enabled on the NIC. 
<P>
If it is possible that an interrupt can occur while another driver function is
accessing resources that also can be accessed from MiniportISR or
MiniportDisableInterrupt, the other function must call <B>NdisMSynchronizeWithInterrupt</B>
to have the driver-supplied MiniportSynchronizeISR function access the shared
resources at DIRQL.
<P>
Callers of <B>NdisMRegisterInterrupt</B>&nbsp;run at IRQL PASSIVE_LEVEL. 
<H3>See Also</H3>
<P>
<B><A HREF="101mini_4.htm">MiniportDisableInterrupt</A></B>, <B><A HREF="101mini_5.htm">MiniportEnableInterrupt</A></B>,
<B><A HREF="101mini_7.htm">MiniportHandleInterrupt</A></B>, <B><A HREF="101mini_8.htm">MiniportInitialize</A></B>,
<B><A HREF="101mini_9.htm">MiniportISR</A></B>, <B><A HREF="101mini_12.htm">MiniportReset</A></B>,
<B><A HREF="101mini_18.htm">MiniportSynchronizeISR</A></B>, <B><A HREF="101mini_19.htm">MiniportTimer</A></B>,
<B><A HREF="103ndisx_98.htm">NdisMDeregisterInterrupt</A></B>, <B><A HREF="103ndisx_110.htm">NdisMInitializeTimer</A></B>,
<B><A HREF="103ndisx_117.htm">NdisMPciAssignResources</A></B>, <B><A HREF="103ndisx_129.htm">NdisMSetAttributes</A></B>,
<B><A HREF="103ndisx_130.htm">NdisMSetAttributesEx</A></B>, <B><A HREF="103ndisx_132.htm">NdisMSetPeriodicTimer</A></B>,
<B><A HREF="103ndisx_137.htm">NdisMSynchronizeWithInterrupt</A></B>,
<B><A HREF="103ndisx_149.htm">NdisOpenConfiguration</A></B>, <B><A HREF="103ndisx_176.htm">NdisReadEisaSlotInformation</A></B>,
<B><A HREF="103ndisx_178.htm">NdisReadMcaPosInformation</A></B>, <B><A HREF="103ndisx_180.htm">NdisReadPciSlotInformation</A></B>
<P></FONT>
</BODY>
</HTML>
