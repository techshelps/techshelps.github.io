<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NdisIMQueueMiniportCallback</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_NdisIMQueueMiniportCallback_NR"></A>NdisIMQueueMiniportCallback</H2>
<P>
<B>NDIS_STATUS</B><BR>
&nbsp; &nbsp; <B>NdisIMQueueMiniportCallback(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN NDIS_HANDLE</B>&nbsp; <I>MiniportAdapterHandle</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN W_MINIPORT_CALLBACK</B>&nbsp; <I>CallbackRoutine</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PVOID</B>&nbsp; <I>CallbackContext</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>NdisIMQueueMiniportCallback</B>&nbsp;calls an intermediate driver’s callback
function when it can execute in a Miniport<I>Xxx</I>&nbsp;context, as, for example,
to forward an indication to higher level protocols. 
<H3>Parameters</H3>
<DL>
<DT>
<I>MiniportAdapterHandle</I>
<DD>
Specifies the handle input to MiniportInitialize.
<BR>
<DT>
<I>CallbackRoutine</I>
<DD>
Specifies the entry point of a driver-supplied function, declared as follows:
<P>
<B>VOID</B><BR>
&nbsp; &nbsp; MiniportCallback<B>(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<B>IN NDIS_HANDLE</B>&nbsp; <I>MiniportAdapterContext</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<B>IN PVOID</B>&nbsp; <I>CallbackContext</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<B>);</B>&nbsp;
<P>
Parameters to the MiniportCallback function include the following:
<DL>
<DT>
<I>MiniportAdapterContext</I>
<DD>
Specifies the handle to a miniport-allocated per-NIC context area, set up by
MiniportInitialize. 
<BR>
<DT>
<I>CallbackContext</I>
<DD>
Specifies the driver-supplied pointer passed to <B>NdisIMQueueMiniportCallback</B>.
</DL>
<DT>
<I>CallbackContext</I>
<DD>
Points to a caller-determined context. This pointer will be passed as an input
parameter to the driver’s callback function when it is run. 
<P>
For example, this parameter might point to a caller-allocated area containing
an array of pointers to packets to be indicated to higher-level protocols. 
</DL>
<H3>Return Value</H3>
<P>
<B>NdisIMQueueMiniportCallback</B>&nbsp;can return one of the following:
<DL>
<DT>
NDIS_STATUS_SUCCESS
<DD>
The function at <I>CallbackRoutine</I>&nbsp;has been run. 
<BR>
<DT>
NDIS_STATUS_PENDING
<DD>
The function at <I>CallbackRoutine</I>&nbsp;will be run asynchronously. 
<BR>
<DT>
NDIS_STATUS_FAILURE
<DD>
NDIS could not run the function at <I>CallbackRoutine</I>&nbsp;at this time,
possibly due to resource constraints. This return does not necessarily mean
that a subsequent call to <B>NdisIMQueueMiniportCallback</B>&nbsp;will fail. 
</DL>
<H3>Comments</H3>
<P>
An NDIS intermediate driver must be executing as if it were a NIC miniport
when it indicates up to bound protocols. 
<P>
For example, packet arrays indicated up to an NDIS intermediate driver’s
ProtocolReceivePackets function cannot be forwarded directly to higher-level
bound protocols with a call to <B>NdisMIndicateReceivePacket</B>. 
<P>
When an intermediate driver’s call to <B>NdisIMSwitchToMiniport</B>&nbsp;returns
FALSE, the driver calls <B>NdisIMQueueMiniportCallback</B>. 
<P>
First, such a driver’s Protocol<I>Xxx</I>&nbsp;function should call <B>NdisIMSwitchToMiniport</B>.
If this call succeeds, it is safe for the Protocol<I>Xxx</I>&nbsp;function to call
miniport-only <B>NdisM</B><I>Xxx</I>&nbsp;functions and to call the reciprocal <B>NdisIMRevertBack</B>
as soon as Protocol<I>Xxx</I>&nbsp;no longer has any more miniport-only processing
to be done. If its call to <B>NdisIMSwitchToMiniport</B>&nbsp;returns FALSE,
Protocol<I>Xxx</I>&nbsp;must call <B>NdisIMQueueMiniportCallback</B>&nbsp;with a driver
function that essentially does exactly what Protocol<I>Xxx</I>&nbsp;would have done
if its call to <B>NdisIMSwitchToMiniport</B>&nbsp;succeeded. However, the supplied
MiniportCallback function also might return status to the caller in the <I>CallbackContext</I>
or <I>MiniportAdapterContext</I>&nbsp;area. 
<P>
If <B>NdisIMQueueMiniportCallback</B>&nbsp;returns NDIS_STATUS_SUCCESS, the
Protocol<I>Xxx</I>&nbsp;function resumes execution with all necessary miniport-only
work already done by the supplied function at <I>CallbackRoutine</I>. 
<P>
The MiniportCallback function passed to <B>NdisIMQueueMiniportCallback</B>
runs, by default, at IRQL DISPATCH_LEVEL. 
<P>
Callers of <B>NdisIMQueueMiniportCallback</B>&nbsp;run at IRQL DISPATCH_LEVEL. 
<H3>See Also</H3>
<P>
<B><A HREF="103ndisx_73.htm">NdisIMRevertBack</A></B>, <B><A HREF="103ndisx_74.htm">NdisIMSwitchToMiniport</A></B>,
<B><A HREF="103ndisx_89.htm">NdisMArcIndicateReceive</A></B>, <B><A HREF="103ndisx_100.htm">NdisMEthIndicateReceive</A></B>,
<B><A HREF="103ndisx_102.htm">NdisMFddiIndicateReceive</A></B>, <B><A HREF="103ndisx_107.htm">NdisMIndicateReceivePacket</A></B>,
<B><A HREF="103ndisx_108.htm">NdisMIndicateStatus</A></B>, <B><A HREF="103ndisx_139.htm">NdisMTrIndicateReceive</A></B>,
<B><A HREF="103ndisx_143.htm">NdisMWanIndicateReceive</A></B>, <B><A HREF="104tdlow_5.htm">ProtocolReceive</A></B>,
<B><A HREF="104tdlow_7.htm">ProtocolReceivePacket</A></B>, <B><A HREF="104tdlow_11.htm">ProtocolStatus</A></B>
<P></FONT>
</BODY>
</HTML>
