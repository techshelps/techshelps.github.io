<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ProtocolSendComplete</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_ProtocolSendComplete_NR"></A>ProtocolSendComplete</H2>
<P>
<B>VOID<BR>
&nbsp; &nbsp; ProtocolSendComplete(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN NDIS_HANDLE</B>&nbsp; <I>ProtocolBindingContext</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PNDIS_PACKET</B>&nbsp; <I>Packet</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN NDIS_STATUS</B>&nbsp;<I>Status</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
ProtocolSendComplete is a required driver function that completes the
processing of a protocol-initiated send previously passed to <B>NdisSendPackets</B>
or <B>NdisSend</B>, which returned NDIS_STATUS_PENDING.  
<H3>Parameters</H3>
<DL>
<DT>
<I>ProtocolBindingContext</I>
<DD>
Specifies the handle to a protocol-allocated context area in which the
protocol driver maintains per-binding runtime state. The driver supplied this
handle when it called <B>NdisOpenAdapter</B>.  
<BR>
<DT>
<I>Packet</I>
<DD>
Points to the protocol-supplied packet descriptor for the completed send. 
<BR>
<DT>
<I>Status</I>
<DD>
Specifies the final status of the send operation. 
</DL>
<H3>Comments</H3>
<P>
ProtocolSendComplete performs whatever postprocessing is necessary for a
completed transmit operation, such as notifying the client that originally
requested the protocol to send data over the network. 
<P>
Completion of a send operation usually implies that the underlying NIC driver
actually has transmitted the given packet over the network. However, the
driver of a so-called intelligent NIC can consider a send complete as soon as
it downloads the net packet to its NIC. The underlying driver’s call to <B>NdisMSendComplete</B>
or <B>NdisMWanSendComplete</B>&nbsp;causes NDIS to call the ProtocolSendComplete
function. 
<P>
When ProtocolSendComplete is called, the driver regains ownership of the
following protocol-allocated resources:
<UL>
<LI>
The packet descriptor at <I>Packet</I>&nbsp;
<P>
<LI>
All buffer descriptors chained to the packet descriptor that map buffers
containing the net packet data and any protocol-allocated buffers mapped by
these descriptors
<P>
<LI>
Any out-of-band block associated with the packet descriptor
<P>
<LI>
Any protocol-allocated buffer specified in the out-of-band block at <B>MediaSpecificInformation</B>
</UL>
<P>
Consequently, ProtocolSendComplete can either release these resources or
prepare them for reuse in a subsequent call to <B>NdisSendPackets</B>&nbsp;or <B>NdisSend</B>.
As a general rule, reusing such resources yields better performance than
releasing them except, possibly, in periods of low network traffic if the
protocol previously allocated a surplus of these resources to handle a period
of heavy I/O demand. 
<P>
To prepare the buffer and packet descriptors for reuse, ProtocolSendComplete
should follow these guidelines:
<UL>
<LI>
<I>Always</I>&nbsp;call an <B>NdisUnchainBufferAt</B><I>Xxx</I>&nbsp;function as many
times as necessary to save the buffer descriptor pointers before
ProtocolSendComplete calls <B>NdisReinitializePacket</B>&nbsp;with the descriptor
at <I>Packet</I>. 
<P>
Otherwise, <B>NdisReinitializePacket</B>&nbsp;sets the head of the buffer chain to
NULL so the protocol cannot recover pointers to the buffer descriptors chained
to the packet descriptor. Either the protocol loses MDL(s) mapping
client-supplied buffer(s) or it loses a set of buffer descriptors the protocol
allocated with <B>NdisAllocateBuffer</B>. 
<P>
<LI>
<I>Always</I>&nbsp;pass the pointer returned by NDIS_OOB_DATA_FROM_PACKET to <B>NdisZeroMemory</B>
to clear an associated out-of-band data block, <I>never</I>&nbsp;the <I>Packet</I>
pointer. 
<P>
Otherwise, <B>NdisZeroMemory</B>&nbsp;destroys the packet descriptor the protocol
allocated with <B>NdisAllocatePacket</B>, rendering it unusable for specifying
subsequent sends. 
<P>
As an alternative to clearing the out-of-band block, the protocol can
reinitialize only those members that the protocol normally sets up for sends
with the appropriate NDIS_SET_PACKET_<I>XXX</I>&nbsp;macros. 
</UL>
<P>
Until ProtocolSendComplete is called, the current status of a
protocol-initiated send is volatile. A protocol temporarily releases ownership
of all resources it allocated for a send when it calls <B>NdisSendPackets</B>
or <B>NdisSend</B>, even if the protocol supplies out-of-band information with
the packet descriptors it allocates for sends. In particular, a protocol
should <I>never</I>&nbsp;attempt to examine the <B>Status</B>&nbsp;member of the
associated out-of-band data block when <B>NdisSendPackets</B>&nbsp;or <B>NdisSend</B>
returns control. 
<P>
Although NDIS always submits protocol-supplied packet arrays to the underlying
miniport in the protocol-determined order passed in calls to <B>NdisSendPackets</B>,
the underlying driver can complete the given packets in random order. That is,
every bound protocol can rely on NDIS to submit the packets the protocol
passes to <B>NdisSendPackets</B>&nbsp;or <B>NdisSend</B>&nbsp;in FIFO order to the
underlying driver, but no protocol can rely on that underlying driver to call <B>NdisMSendComplete</B>
with those packets in the same order.  
<P>
The ProtocolSendComplete function of an NDIS intermediate driver cannot simply
forward completion indications to still higher-level protocols. Such an
attempt can cause a deadlock. Instead, such a driver must call <B>NdisIMSwitchToMiniport</B>
to forward the indication from the appropriate context. If <B>NdisIMSwitchToMiniport</B>
returns FALSE, the driver must call <B>NdisIMQueueMiniportCallback</B>&nbsp;and
forward the indication from the protocol-supplied MiniportCallback function. 
<P>
By default, ProtocolSendComplete runs at IRQL DISPATCH_LEVEL in an arbitrary
thread context. 
<H3>See Also</H3>
<P>
<B><A HREF="101mini_14.htm">MiniportSend</A></B>, <B><A HREF="101mini_15.htm">MiniportSendPackets</A></B>,
<B><A HREF="101mini_21.htm">MiniportWanSend</A></B>, <B><A HREF="103ndisx_8.htm">NdisAllocateBuffer</A></B>,
<B><A HREF="103ndisx_11.htm">NdisAllocatePacket</A></B>, <B><A HREF="103ndisx_37.htm">NdisFreeBuffer</A></B>,
<B><A HREF="103ndisx_40.htm">NdisFreePacket</A></B>, <B><A HREF="103ndisx_71.htm">NdisIMQueueMiniportCallback</A></B>,
<B><A HREF="103ndisx_74.htm">NdisIMSwitchToMiniport</A></B>, <B><A HREF="103ndisx_127.htm">NdisMSendComplete</A></B>,
<B><A HREF="103ndisx_147.htm">NDIS_OOB_DATA_FROM_PACKET</A></B>, <B><A HREF="106nstru_5.htm">NDIS_PACKET_OOB_DATA</A></B>,
<B><A HREF="103ndisx_186.htm">NdisReinitializePacket</A></B>, <B><A HREF="103ndisx_198.htm">NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO</A></B>,
<B><A HREF="103ndisx_202.htm">NDIS_SET_PACKET_TIME_TO_SEND</A></B>,
<B><A HREF="103ndisx_211.htm">NdisUnchainBufferAtBack</A></B>, <B><A HREF="103ndisx_212.htm">NdisUnchainBufferAtFront</A></B>,
<B><A HREF="103ndisx_223.htm">NdisZeroMemory</A></B>&nbsp; 
<P></FONT>
</BODY>
</HTML>
