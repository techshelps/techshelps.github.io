<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TdiBuildSend</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_TdiBuildSend_NR"></A>TdiBuildSend</H2>
<P>
<B>VOID <BR>
&nbsp; &nbsp; TdiBuildSend (<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PIRP</B>&nbsp; <I>Irp</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PDEVICE_OBJECT</B>&nbsp; <I>DevObj</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PFILE_OBJECT</B>&nbsp; <I>FileObj</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PVOID</B>&nbsp; <I>CompRoutine</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PVOID</B>&nbsp; <I>Contxt</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PMDL</B>&nbsp; <I>MdlAddr</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN ULONG</B>&nbsp; <I>InFlags</I><B>,<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN ULONG</B>&nbsp; <I>SendLen<BR>
</I>&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>TdiBuildSend</B>&nbsp;sets up an internal device control IRP for a TDI_SEND
request to the underlying transport in which the local-node client has already
opened a file object representing a connection endpoint and established an
endpoint-to-endpoint connection with a remote-node peer. 
<H3>Parameters</H3>
<DL>
<DT>
<I>Irp</I>
<DD>
Points to a client-supplied IRP, either originating in a higher level network
component or allocated with <B>TdiBuildInternalDeviceControlIrp</B>. 
<BR>
<DT>
<I>DevObj</I>
<DD>
Points to the device object created by the next lower TDI transport driver.
<BR>
<DT>
<I>FileObj</I>
<DD>
Points to a file object representing a connection endpoint. 
<P>
The caller previously made a successful request, set up with <B>TdiBuildAssociateAddress</B>,
to the transport to set up an association between this connection endpoint and
a local-node address. When the association was established, the caller also
established an endpoint-to-endpoint connection with a remote-node peer by
issuing a successful request set up with <B>TdiBuildConnect</B>&nbsp;or <B>TdiBuildListen</B>,
the latter possibly followed by a successful request set up with <B>TdiBuildAccept</B>.
<BR>
<DT>
<I>CompRoutine</I>
<DD>
Specifies the entry point of a client-supplied IoCompletion routine or NULL.
The I/O Manager calls this routine when the given IRP is completed, unless the
client sets this parameter to NULL. 
<BR>
<DT>
<I>Contxt</I>
<DD>
Points to a client-determined context. This client-supplied pointer is passed
in to the IoCompletion routine when it is called with the completed IRP. <I>Contxt</I>
should be NULL if <I>CompRoutine</I>&nbsp;is NULL.
<BR>
<DT>
<I>MdlAddr</I>
<DD>
Points to an MDL, possibly the initial MDL in a chain of MDLs, mapping a
client-supplied buffer from which the transport is to transfer the data to be
sent. 
<BR>
<DT>
<I>InFlags</I>
<DD>
Specifies how the data should be transmitted. If this parameter is zero, the
transport should send the given data as a normal TSDU. Otherwise, this
parameter can be one or a combination (Ored) of the following flags:
<DL>
<DT>
TDI_SEND_EXPEDITED
<DD>
The given data should be sent ahead of any normal send requests the transport
is currently holding queued for transmission on this endpoint-to-endpoint
connection, assuming the underlying transport supports expedited transfers. 
<BR>
<DT>
TDI_SEND_PARTIAL
<DD>
The given data is terminated by an end-of-record but is not a complete
message-mode TSDU. The client will send the additional data later. This flag
is irrelevant to clients of stream-mode transports. 
<BR>
<DT>
TDI_SEND_NO_RESPONSE_EXPECTED
<DD>
The caller is giving a hint to the underlying transport that it does not
expect a response to this send from its remote-node peer. A client uses this
flag to disable piggybacking of the TSDU acknowledgment by the remote-node
transport, assuming both transports support this optimization. Otherwise, its
underlying transport might time out, waiting for a piggybacked acknowledgment
of the send from the remote node.
<BR>
<DT>
TDI_SEND_NON_BLOCKING
<DD>
If the underlying transport currently has no internal buffer space available
for the given data, it should fail this send request with
STATUS_DEVICE_NOT_READY, rather than blocking until it can buffer the given
data internally. The transport should call the ClientEventSendPossible handler
when it again has internal buffer space available for sends. This flag is
irrelevant to clients of transports that do no internal buffering.
</DL>
<DT>
<I>SendLen</I>
<DD>
Specifies the size in bytes of the buffer mapped at <I>MdlAddr</I>. The
maximum for this parameter depends on the underlying transport. Whether zero
is valid also depends on the underlying transport. (See Comments.)
</DL>
<H3>Comments</H3>
<P>
<B>TdiBuildSend</B>&nbsp;sets IRP_MJ_INTERNAL_DEVICE_CONTROL as the <B>MajorFunction</B>
and TDI_SEND as the <B>MinorFunction</B>&nbsp;codes in the transport&#39;s I/O
stack location of the given IRP.
<P>
In each send request set up with <B>TdiBuildSend</B>, the caller provides a
buffer containing the TSDU to be sent to its remote-node peer, or part of a
TSDU if the underlying transports support message-mode transfers. A client can
send any amount of data up to the maximum size the TDI driver allows. To
obtain the transport-specific maximum size for sends, the client can make a
TDI_QUERY_PROVIDER_INFO request, set up with <B>TdiBuildQueryInformation</B>. 
<P>
After the caller of <B>TdiBuildSend</B>&nbsp;passes the send IRP to the underlying
transport with <B>IoCallDriver</B>, the client-supplied buffer at <I>MdlAddress</I>
is inaccessible to that client until the send operation is completed. The
client must not attempt to modify or use its send buffer until the IRP is
returned to the client&#39;s IoCompletion routine or the client is certain
(through protocol semantics) that its underlying transport has completed send
operations for the data in that buffer. 
<P>
The local-node transport can queue several send requests internally, but it
always transmits them in FIFO order. If the transport supports expedited
sends, it queues incoming expedited-send requests in FIFO order ahead of any
normal sends it is currently holding. The transport is responsible for
completing incoming sends in a timely manner, with either a success or error
status. The transport can complete a send with a time-out error based on a
driver-determined estimate of a reasonable time-out interval for current
network conditions. 
<P>
Each local-node client&#39;s send request on an endpoint-to-endpoint
connection corresponds to one of the following:
<UL>
<LI>
One receive request issued by the remote-node client to its underlying TDI
transport 
<P>
<LI>
One call to the remote-node client&#39;s registered ClientEventReceive,
ClientEventReceiveExpedited, ClientEventChainedReceive, or
ClientEventChainedReceiveExpedited handler by its underlying TDI transport 
</UL>
<P>
If the underlying transport supports message-mode sends, its client can send a
TSDU in pieces as a sequence of send requests, each except the last specifying
the TDI_SEND_PARTIAL flag. When this flag is clear, a message-mode transport
considers such a sequence of partial sends to be at an end. In this transfer
scenario, the transport on the remote node notifies the receiving client of
partial TSDUs by leaving the TDI_RECEIVE_ENTIRE_MESSAGE flag clear in the
corresponding receive indications until it indicates the last receive in such
a sequence.
<P>
The caller of <B>TdiBuildSend</B>&nbsp;can request a nonblocking send by setting
the TDI_SEND_NON_BLOCKING flag if the underlying transport has internal
buffers into which it copies its clients&#39; send data. Depending on the
amount of internal buffer space available, the underlying transport handles
such a send request as follows:
<UL>
<LI>
If it currently has sufficient internal buffer space, the transport copies the
data from the client-supplied buffer and completes the send IRP with
STATUS_SUCCESS.
<P>
<LI>
If it currently has insufficient buffer space for the given <I>SendLength</I>,
the transport copies as much data as possible from the client&#39;s buffer and
returns STATUS_SUCCESS. 
<P>
<LI>
If the driver currently has no internal buffer space, the transport completes
the send IRP with STATUS_DEVICE_NOT_READY. 
<P>
The client of such a transport registers a ClientEventSendPossible handler,
which the transport will call when it again has internal buffer space
available for the rejected send. 
</UL>
<P>
When its send is completed with STATUS_SUCCESS, the client of such a transport
can determine how much data the transport has buffered for transmission by
checking the <B>IoStatus.Information</B>&nbsp;member of the completed IRP. If
necessary, the client&#39;s IoCompletion routine can resubmit another send
request for the remaining data to be sent. 
<P>
Some transports allow their clients to issue zero-length send requests. For
such a transport, a zero-length send actually forces protocol flow, as long as
the TDI_SEND_PARTIAL flag is clear. The client of such a transport can issue
such a zero-length send as a message that satisfies a receive request.
Transports that do not support this feature return an error when a client
issues a zero-length send request. 
<P>
A TDI client also can send a normal TSDU on an endpoint-to-endpoint connection
with a call to <B>ZwWriteFile</B>. Because this routine does not allow the
specification of TDI_SEND_<I>XXX</I>&nbsp;flags, client-supplied data given to <B>ZwWriteFile</B>
is transmitted by the underlying transport as if it were packaged as a <B>TdiBuildSend</B>
request with both TDI_SEND_PARTIAL and TDI_SEND_EXPEDITED clear in the <I>SendFlags</I>.
The transport assumes that all the data in the buffer at <I>MdlAddr</I>&nbsp;should
be sent, and the caller&#39;s <I>ByteOffset</I>&nbsp;and <I>Key</I>&nbsp;arguments to <B>ZwWriteFile</B>
are ignored. 
<H3>See Also</H3>
<P>
<B><A HREF="25tdicli_2.htm">ClientEventChainedReceive</A></B>, <B><A HREF="25tdicli_4.htm">ClientEventChainedReceiveExpedited</A></B>,
<B><A HREF="25tdicli_7.htm">ClientEventReceive</A></B>, <B><A HREF="25tdicli_9.htm">ClientEventReceiveExpedited</A></B>,
<B><A HREF="25tdicli_10.htm">ClientEventSendPossible</A></B>, <B><A HREF="24bldmac_1.htm">TdiBuildAccept</A></B>,
<B><A HREF="24bldmac_3.htm">TdiBuildAssociateAddress</A></B>, <B><A HREF="24bldmac_4.htm">TdiBuildConnect</A></B>,
<B><A HREF="24bldmac_7.htm">TdiBuildInternalDeviceControlIrp</A></B>,
<B><A HREF="24bldmac_8.htm">TdiBuildListen</A></B>, <B><A HREF="24bldmac_12.htm">TdiBuildReceive</A></B>,
<B><A HREF="24bldmac_16.htm">TdiBuildSetEventHandler</A></B>, <B><A HREF="22ioctl_11.htm">TDI_SEND</A></B>
<P></FONT>
</BODY>
</HTML>
