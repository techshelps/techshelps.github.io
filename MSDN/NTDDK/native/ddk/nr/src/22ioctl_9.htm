<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDI_RECEIVE</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_TDI_RECEIVE_NR"></A>TDI_RECEIVE</H2>
<P>
When a kernel-mode client makes a TDI_RECEIVE request, it asks the underlying
TDI transport driver to indicate a normal or expedited TSDU on an established
endpoint-to-endpoint connection. 
<H3>IRP</H3>
<P>
The transport calls <B>IoGetCurrentIrpStackLocation</B>&nbsp;with the given <I>Irp</I>
to get a pointer to its own I/O stack location in the IRP, shown in the
following list as <B>IrpSp</B>. IRP members relevant to this request include
the following:
<DL>
<DT>
<B>IoStatus.Status</B>
<DD>
Specifies the final status of the receive request. The transport sets this
member before it completes the IRP, possibly to one of the following:
<P>
STATUS_PENDING<BR>
STATUS_INSUFFICIENT_RESOURCES<BR>
STATUS_INVALID_CONNECTION<BR>
STATUS_BUFFER_OVERFLOW
<BR>
<DT>
<B>IoStatus.Information</B>
<DD>
Specifies the number of bytes of received data the transport is returning in
the client-supplied buffer. 
<BR>
<DT>
<B>IrpSp-&gt;MajorFunction</B>
<DD>
Specifies IRP_MJ_INTERNAL_DEVICE_CONTROL. The transport can ignore this member
if it exports a TdiDispatchInternalDeviceControl routine that handles only
TDI_<I>XXX</I>&nbsp;requests. 
<BR>
<DT>
<B>IrpSp-&gt;MinorFunction</B>
<DD>
Specifies TDI_RECEIVE.
<BR>
<DT>
<B>IrpSp-&gt;FileObject</B>
<DD>
Points to an open file object representing the connection endpoint. The
transport uses the <B>FsContext</B>&nbsp;and, possibly, <B>FsContext2</B>&nbsp;fields to
access the state it maintains about this connection. 
<P>
This client already established an endpoint-to-endpoint connection with a
remote-node peer on this connection endpoint. 
<BR>
<DT>
<B>IrpSp-&gt;Parameters</B>
<DD>
Points to a TDI_REQUEST_KERNEL_RECEIVE structure, defined as follows:
<PRE><FONT FACE="Courier" SIZE="2">struct _TDI_REQUEST_KERNEL_RECEIVE {<B>&nbsp;</B>
&nbsp; &nbsp; ULONG ReceiveLength;<B>&nbsp;</B>
&nbsp; &nbsp; ULONG ReceiveFlags;<B>&nbsp;</B>
} TDI_REQUEST_KERNEL_RECEIVE, *PTDI_REQUEST_KERNEL_RECEIVE;<B>&nbsp;</B>
<B>&nbsp;</B></FONT></PRE>
<P>
The transport uses the members of this structure as follows:
<DL>
<DT>
<B>ReceiveLength</B>
<DD>
Specifies the size in bytes of the client-supplied buffer mapped at <B>Irp-&gt;MdlAddress</B>.
<BR>
<DT>
<B>ReceiveFlags</B>
<DD>
Specifies the type of receive this client is requesting, as described later
(see Comments). 
</DL>
<DT>
<B>MdlAddress</B>
<DD>
Points to an MDL, possibly the initial MDL in a chain, mapping a
client-supplied buffer in which the transport returns the received data. 
</DL>
<H3>Comments</H3>
<P>
When a client calls <B>TdiBuildReceive</B>&nbsp;to set up this IRP, it can specify
the type of receive it wants. The transport finds this information at <B>IrpSp-&gt;Parameters</B>
in the <B>ReceiveFlags</B>&nbsp;member. On input, <B>ReceiveFlags</B>&nbsp;can be zero
or set with any combination (ORed) of the following flags: 
<DL>
<DT>
TDI_RECEIVE_NORMAL
<DD>
The transport should return a normal TSDU to this client.
<BR>
<DT>
TDI_RECEIVE_EXPEDITED
<DD>
The transport should return an expedited TSDU to this client. 
<BR>
<DT>
TDI_RECEIVE_PEEK
<DD>
The transport should return any available received data that it has buffered
internally at once, even if it is only a partial TSDU, to this client. 
</DL>
<P>
If <B>ReceiveFlags</B>&nbsp;is zero or set with both (ORed) TDI_RECEIVE_NORMAL and
TDI_RECEIVE_EXPEDITED on input, either normal or expedited data is acceptable
to the client. If only one of these flags is set, the transport should return
only the type of TSDU requested. If TDI_RECEIVE_PEEK is set, the transport
should return any received data it has buffered internally and retain the data
in its internal buffer awaiting a subsequent receive request for the remainder
of the TSDU from this client. 
<P>
Typically, a transport receives normal data until it fills the receive buffer
or it receives an end-of-record indication from the remote node. However, if
the transport is receiving normal data and expedited data arrives, the
transport must pre-empt its normal receive operation, completing the IRP for
the normal receive immediately with any normal data it has already transferred
into the client&#39;s buffer. Then, the transport must satisfy the
client&#39;s receive request(s) for the expedited data. When the transport has
indicated all the expedited data to the client, the transport resumes
indicating normal receives when the next receive request is submitted by that
client.
<P>
If the client has registered any ClientEventReceive,
ClientEventReceiveExpedited, ClientEventChainedReceive, and/or
ClientEventChainedReceiveExpedited handler(s) for receives on the given
connection endpoint, the transport stops indicating receives to the
ClientEvent(Chained)Receive(Expedited) routine(s) until the transport has
satisfied the receive IRP. 
<P>
When it calls ClientEventReceive or ClientEventReceiveExpedited, the transport
supplies information about the type of receive event it is indicating, which
the client can use to set up the <B>ReceiveFlags</B>&nbsp;for a subsequent
TDI_RECEIVE request if it is not given the full TSDU. The transport supplies
this information to its client by setting the <I>ReceiveFlags</I>&nbsp;parameter to
ClientEventReceive(Expedited) with one or more (ORed) of the following flags:
<DL>
<DT>
TDI_RECEIVE_NORMAL
<DD>
The transport is receiving a normal TSDU from the remote node.
<BR>
<DT>
TDI_RECEIVE_EXPEDITED
<DD>
The transport is receiving an expedited TSDU from the remote node.
<BR>
<DT>
TDI_RECEIVE_ENTIRE_MESSAGE
<DD>
If this flag is set, the transport already has a full TSDU available for
receipt by the client. When this flag is set, ClientEventReceive is expected
to copy the full net packet into an internal buffer and return control without
postprocessing the received data, deferring any necessary postprocessing until
later.
<P>
If this flag remains clear, it is equivalent to setting the (obsolete, but
possibly still set by legacy transports) TDI_RECEIVE_PARTIAL flag to indicate
that only the initial part of a TSDU is currently available from the
transport. 
<BR>
<DT>
TDI_RECEIVE_COPY_LOOKAHEAD
<DD>
The transport has received only the lookahead buffer for an indication from
the underlying NIC driver, so it sets <I>BytesAvailable</I>&nbsp;to something less
than <I>BytesIndicated</I>&nbsp;when the transport calls
ClientEventReceive(Expedited) with these parameters. The client should copy
the <I>BytesAvailable</I>&nbsp;into an internal buffer (see <B>TdiCopyLookaheadData</B>)
and, then, submit one or more receive requests to obtain the remaining data in
the TSDU. 
<BR>
<DT>
TDI_RECEIVE_PEEK
<DD>
The transport has buffered some receive data internally, but not yet the full
TSDU. The client handles such an indication in a similar manner to one in
which TDI_RECEIVE_COPY_LOOKAHEAD is set. 
<BR>
<DT>
TDI_RECEIVE_TRUNCATED
<DD>
The transport received a TSDU that was truncated.
<BR>
<DT>
TDI_RECEIVE_FRAGMENT
<DD>
The transport received a TSDU that is fragmented.
<BR>
<DT>
TDI_RECEIVE_AT_DISPATCH_LEVEL
<DD>
The transport received the TSDU at IRQL DISPATCH_LEVEL. This flag restricts
the set of support routines that the client can call in processing the receive
indication. For example, the client cannot call <B>TdiBuildInternalDeviceControlIrp</B>,
which can be called only at IRQL PASSIVE_LEVEL, in the context of this receive
indication. 
</DL>
<P>
When the transport ORs TDI_RECEIVE_ENTIRE_MESSAGE with TDI_RECEIVE_NORMAL and
calls the ClientEventChainedReceive handler, the client is given direct
read-only access to a full TSDU in the underlying NIC&#39;s receive buffer(s)
until that client calls <B>TdiReturnChainedReceives</B>&nbsp;with the input <I>TsduDescriptor</I>.
For such an indication, the client has no need to issue a TDI_RECEIVE request.
In effect, such a transport forwards receive indications from the underlying
NDIS driver directly to its client with only the minimal overhead of setting
up the parameters to ClientEventChainedReceive, as follows:
<UL>
<LI>
The transport uses the NDIS_PACKET-type descriptor input to its
ProtocolReceivePacket function as the <I>TsduDescriptor</I>&nbsp;passed to
ClientEventChainedReceive. For each client to which the transport forwards the
receive indication, the transport augments the value to be returned by
ProtocolReceivePacket by one. 
<P>
<LI>
The transport retrieves the buffer containing the indicated data from the
packet descriptor supplied by the underlying NDIS driver, possibly by calling <B>NdisGetFirstBufferFromPacket</B>.
The transport uses the pointer to this NDIS_BUFFER-type (equivalent to the MDL
type) chain as the <I>Tsdu</I>&nbsp;for ClientEventChainedReceive. 
<P>
<LI>
From the full range of receive data indicated by the underlying NDIS driver,
the transport selects the subrange of interest to its client. The driver uses
this subrange as the <I>StartingOffset</I>&nbsp;and <I>ReceiveLength</I>&nbsp;for
ClientEventChainedReceive. 
</UL>
<P>
In a similar manner, such a transport gives ClientEventChainedReceiveExpedited
direct read-only access to a full TSDU when TDI_RECEIVE_ENTIRE_MESSAGE is ORed
with TDI_RECEIVE_EXPEDITED in the input <I>RequestFlags</I>. 
<P>
For a TSDU indicated to a ClientEventChainedReceive(Expedited) handler, the
client retains control of all resources for the receive indication until it
calls <B>TdiReturnChainedReceives</B>&nbsp;with the <I>TsduDescriptor</I>. As each
client that received the indication calls TdiReturnChainedReceives, the NDIS
library decrements the counter it maintains for the packet descriptor, which
was set originally to the value returned by the transport&#39;s
ProtocolReceivePacket function. When all clients that received the indication
have called <B>TdiReturnChainedReceives</B>, NDIS returns control of all
resources specified by that packet descriptor to the NDIS driver that
allocated these resources. 
<P>
When such a transport is called at its ProtocolReceive function with a
full-packet indication made by the underlying NDIS driver, the transport must <I>not</I>
call a registered ClientEventChainedReceive or
ClientEventChainedReceiveExpedited handler with the indication. Instead, it
should copy the indicated data for its client into a transport-allocated
buffer and call the ClientEventReceive(Expedited) handler. An NDIS call to the
transport&#39;s ProtocolReceive function implies that the underlying driver
expects all higher level drivers to copy the receive data it is indicating and
to return its packet descriptor (and all the lower driver&#39;s resources that
it describes) as quickly as possible because the lowest level NDIS driver is
short on NIC receive buffer space. 
<H3>See Also</H3>
<P>
<B><A HREF="25tdicli_2.htm">ClientEventChainedReceive</A></B>, <B><A HREF="25tdicli_4.htm">ClientEventChainedReceiveExpedited</A></B>,
<B><A HREF="25tdicli_7.htm">ClientEventReceive</A></B>, <B><A HREF="25tdicli_9.htm">ClientEventReceiveExpedited</A></B>,
<B><A HREF="103ndisx_48.htm">NdisGetFirstBufferFromPacket</A></B>,
<B><A HREF="106nstru_4.htm">NDIS_PACKET</A></B>, <B><A HREF="104tdlow_5.htm">ProtocolReceive</A></B>,
<B><A HREF="104tdlow_7.htm">ProtocolReceivePacket</A></B>, <B><A HREF="24bldmac_12.htm">TdiBuildReceive</A></B>,
<B><A HREF="23tdifun_3.htm">TdiCopyLookaheadData</A></B>, <B><A HREF="21tddisp_6.htm">TdiDispatchInternalDeviceControl</A></B>,
<B><A HREF="23tdifun_7.htm">TdiReturnChainedReceives</A></B>&nbsp;
<P></FONT>
</BODY>
</HTML>
