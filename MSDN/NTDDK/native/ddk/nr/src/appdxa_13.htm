<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MacInterruptServiceRoutine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_MacInterruptServiceRoutine_NR"></A>MacInterruptServiceRoutine</H2>
<P>
<B>BOOLEAN<BR>
</B>&nbsp; &nbsp; <B>MacInterruptServiceRoutine(<BR>
</B>&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PVOID</B>&nbsp; <I>InterruptContext</I><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
MacInterruptServiceRoutine is a full-NIC driver’s ISR, called when the NIC
generates an interrupt. 
<H3>Parameters</H3>
<DL>
<DT>
<I>InterruptContext</I>
<DD>
Points to the context that the NIC driver associates with the interrupt. The
NIC driver provided this context area (<I>MacAdapterContext</I>) when it
called <B>NdisInitializeInterrupt</B>&nbsp;during initialization. 
</DL>
<H3>Return Value</H3>
<P>
MacInterruptServiceRoutine returns TRUE if its NIC generated the interrupt.
TRUE also tells NDIS to queue a call to MacDeferredProcessingRoutine, so
drivers of NICs that do not share IRQs always return TRUE from their ISRs. 
<H3>Comments</H3>
<P>
If the driver called <B>NdisInitializeInterrupt</B>&nbsp;with the <I>InterruptMode</I>
set to <B>NdisInterruptLevelSensitive</B>, its MacInterruptServiceRoutine must
dismiss the interrupt on the NIC before it returns control. Otherwise, the
interrupt remains active, and NDIS calls MacInterruptServiceRoutine repeatedly
until the interrupt is dismissed on the NIC. 
<P>
If the NIC shares an IRQ with other devices, MacInterruptServiceRoutine first
determines whether its NIC generated the interrupt and returns FALSE
immediately if another device generated the interrupt. Otherwise,
MacInterruptServiceRoutine preserves enough state about the operation that
caused the interrupt for the driver’s MacDeferredProcessingRoutine to complete
the operation. 
<DL>
<DT>
In other words, a NIC driver does the absolute minimum amount of work in its
ISR. When this function returns control, NDIS calls the driver’s
MacDeferredProcessingRoutine as soon as possible to complete interrupt
processing at a lower hardware priority. 
<DD>
MacInterruptServiceRoutine runs at the DIRQL assigned by the system when the
driver called <B>NdisInitializeInterrupt</B>. Consequently,
MacInterruptServiceRoutine can call only a small subset of NDIS library
functions, while the driver’s MacDeferredProcessingRoutine can call any
system-supplied function that is safe to call from IRQL &lt;= DISPATCH_LEVEL. 
</DL>
<P>
Because it runs at DIRQL, MacInterruptServiceRoutine can preempt any code that
runs at lower IRQL, including most functions in the NDIS library and in the
NIC driver itself. If a NIC interrupt can occur while a nonISR NIC driver
function is accessing resources that MacInterruptServiceRoutine also could
access if an interrupt occurs, the nonISR function must call <B>NdisSynchronizeWithInterrupt</B>
to synchronize its access with the ISR. 
<P>
MacInterruptServiceRoutine runs at DIRQL, which is &gt; DISPATCH_LEVEL. 
<H3>See Also</H3>
<P>
<B><A HREF="appdxa_4.htm">MacAddAdapter</A></B>, <B><A HREF="appdxa_12.htm">MacDeferredProcessingRoutine</A></B>,
<B><A HREF="appdxa_21.htm">MacSynchronizeFunction</A></B>, <B><A HREF="101mini_9.htm">MiniportISR</A></B>,
<B><A HREF="103ndisx_6.htm">NdisAcquireSpinLock</A></B>, <B><A HREF="appdxa_83.htm">NdisInitializeInterrupt</A></B>,
<B><A HREF="103ndisx_187.htm">NdisReleaseSpinLock</A></B>, <B><A HREF="appdxa_104.htm">NdisSynchronizeWithInterrupt</A></B>
<P></FONT>
</BODY>
</HTML>
