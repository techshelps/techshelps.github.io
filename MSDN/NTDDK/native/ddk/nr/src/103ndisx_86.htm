<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NdisMAllocateSharedMemory</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_NdisMAllocateSharedMemory_NR"></A>NdisMAllocateSharedMemory</H2>
<P>
<B>VOID <BR>
&nbsp; &nbsp; NdisMAllocateSharedMemory(</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN</B>&nbsp;<B>NDIS_HANDLE</B>&nbsp; <I>MiniportAdapterHandle</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN</B>&nbsp;<B>ULONG</B>&nbsp; <I>Length</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN</B>&nbsp;<B>BOOLEAN</B>&nbsp; <I>Cached</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>OUT</B>&nbsp;<B>PVOID</B>&nbsp; <B>*</B><I>VirtualAddress</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>OUT</B>&nbsp;<B>PNDIS_PHYSICAL_ADDRESS</B>&nbsp; <I>PhysicalAddress<BR>
</I>&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>NdisMAllocateSharedMemory</B>&nbsp;allocates and maps a host memory range so it
is simultaneously accessible from both the system and a busmaster DMA NIC.
<H3>Parameters</H3>
<DL>
<DT>
<I>MiniportAdapterHandle</I>
<DD>
Specifies the handle input to MiniportInitialize.
<BR>
<DT>
<I>Length</I>
<DD>
Specifies the number of bytes to allocate.
<BR>
<DT>
<I>Cached</I>
<DD>
Specifies TRUE if the range can be allocated from cached memory. 
<BR>
<DT>
<I>VirtualAddress</I>
<DD>
Points to a caller-supplied variable in which this function returns the base
virtual address of the allocation for use by the miniport. If <B>NdisMAllocateSharedMemory</B>
cannot satisfy its caller, it returns NULL to indicate that no memory was
allocated. 
<BR>
<DT>
<I>PhysicalAddress</I>
<DD>
Points to a caller-supplied variable in which this function returns a physical
address, suitable for use by the NIC, that corresponds to that returned at <I>VirtualAddress</I>,
or it returns NULL. 
</DL>
<H3>Comments</H3>
<P>
<B>NdisMAllocateSharedMemory</B>&nbsp;provides both the mapped virtual address
range that the driver uses to access the shared memory block and the
NDIS_PHYSICAL_ADDRESS-type range that the NIC uses. A value returned at <I>PhysicalAddress</I>
can be doubly mapped by the system. That is, a “physical” address range
described by the value at <I>PhysicalAddress</I>&nbsp;and <I>Length</I>&nbsp;can be a
range of mapped logical addresses that do not match the host physical
addresses for the allocation in every possible platform.  
<P>
<B>NdisMAllocateSharedMemory</B>&nbsp;can be called only from MiniportInitialize.
How large an allocation to request depends on how the driver writer, knowing
the capabilities and features of the NIC, decides to make the tradeoff between
the following performance versus size dilemma:
<UL>
<LI>
In periods of high network traffic, a miniport cannot maintain high I/O
throughput if it runs low on shared memory space for device-accessible data
buffers. 
<P>
For example, the miniport could be indicating receive buffers in shared memory
faster than such buffers are being returned from bound protocols when a flood
of receives come in to its NIC. If all its shared memory space is consumed by
outstanding receive buffers, the miniport might have to disable receive
interrupts on its NIC until it has some shared memory space available for
receive buffers.
<P>
<LI>
On the other hand, calling <B>NdisMAllocateSharedMemory</B>&nbsp;with a <I>Length</I>
chosen to anticipate some maximum transfer demand makes the driver’s image
larger and its resource usage quite uneconomical, except for rare periods of
very high I/O demand. Moreover, <B>NdisMAllocateSharedMemory</B>&nbsp;might not
give the driver such a large block if insufficient system memory is available,
forcing the driver to fail initialization. 
</UL>
<P>
A NIC driver that supplies a MiniportAllocateComplete function has
considerably more flexibility in resolving the preceding performance versus
size dilemma. MiniportInitialize should allocate only enough shared memory
with <B>NdisMAllocateSharedMemory</B>&nbsp;for a moderate demand for network
transfer operations through the NIC if the driver has a
MiniportAllocateComplete function. Such a miniport can call <B>NdisMAllocateSharedMemoryAsync</B>
dynamically to allocate more shared memory in periods of heavier transfer
demand on its NIC. When the high demand for transfers subsides, such a driver
calls <B>NdisMFreeSharedMemory</B>&nbsp;to release the additional memory it
allocated. 
<P>
<B>NdisMAllocateSharedMemory</B>&nbsp;and <B>NdisMAllocateSharedMemoryAsync</B>&nbsp;are
the only <B>Ndis</B><I>Xxx</I>&nbsp;functions that can be called to allocate host
memory that is shared between the driver, which uses virtual addresses, and a
busmaster NIC, which uses the corresponding logical addresses. 
<P>
Whenever possible, a NIC driver calls <B>NdisMAllocateSharedMemory</B>&nbsp;with <I>Cached</I>
set to TRUE because its request is more likely to succeed. In any platform,
noncached memory is always a scarce system resource. Usually, drivers can get
larger allocations from cached memory as well. A NIC driver must allocate its
shared memory space from noncached memory if either of the following is true:
<UL>
<LI>
The NIC or miniport writes directly into receive buffers before the miniport
indicates the newly received data. 
<P>
For example, a NIC that sets flags in each received frame after it has been
transferred must have access to receive buffers in noncached memory.
Otherwise, the miniport could not determine when it should issue a flush to
maintain cache coherency: either the miniport would take a performance hit by
waiting for a fail-safe interval to flush the cached receive buffer, or the
miniport would make indications in which the frame flags were randomly set.
<P>
<LI>
The NIC transfers some number of received frames sequentially into contiguous
physical memory within the shared memory space. 
<P>
If such a NIC transferred incoming frames into contiguous cached memory, its
driver cannot maintain data integrity for all such frames when any frame might
straddle a cache-line boundary. When the miniport flushed the range for such a
frame, it also might flush the cache space containing some of the next frame
if it was already transferred, thereby making that next frame incoherent. 
</UL>
<P>
A miniport should align the buffers it allocates from shared cached memory on
an integral of the host data-cache-line boundary to prevent cache-line tearing
during DMA. Cache-line tearing can cause data-integrity problems in the driver
or degrade the driver’s (and the system’s) I/O performance by requiring
excessive data-cache flushing to maintain data integrity. MiniportInitialize
can call <B>NdisGetCacheFillSize</B>&nbsp;to determine the alignment boundary in
the current platform for device-accessible buffers that the driver will set up
within an allocated range of shared memory. 
<P>
MiniportInitialize also might call <B>NdisSystemProcessorCount</B>&nbsp;before it
calls <B>NdisMAllocateSharedMemory</B>&nbsp;if the driver writer decides to
allocate a larger shared memory block in multiprocessor machines on the
assumption that any SMP machine is likely to be a network server with higher
network-transfer demands on the NIC than a workstation.
<P>
MiniportInitialize must call <B>NdisMAllocateMapRegisters</B>&nbsp;before it calls <B>NdisMAllocateSharedMemory</B>;
otherwise, no memory can be allocated. NDIS allocates an additional map
register internally for the shared memory range when it is allocated.
<P>
If MiniportInitialize did not specify that the NIC is a busmaster when it
called <B>NdisMSetAttributes</B>&nbsp;or <B>NdisMSetAttributesEx</B>, <B>NdisMAllocateSharedMemory</B>
simply returns control without attempting to make an allocation. 
<P>
If its call to <B>NdisMAllocateSharedMemory</B>&nbsp;fails, MiniportInitialize can
call again requesting a smaller allocation. However, if MiniportInitialize
cannot allocate sufficient shared memory for the NIC, it must release all
resources it has already allocated and fail initialization. 
<P>
If the NIC driver subsequently indicates receives with
NdisMIndicateReceivePacket, it must allocate some number of buffer descriptors
from buffer pool that map the NIC’s receive buffers in the shared memory
block.
<P>
If the allocated memory is cached and, therefore, needs to be flushed on
transfers, the miniport must call <B>NdisAllocateBuffer</B>&nbsp;to allocate an
NDIS_BUFFER-type descriptor for the shared memory range. The NIC driver must
call <B>NdisFlushBuffer</B>&nbsp;with this buffer descriptor to perform such a
flush. In addition, such a miniport should call <B>NdisMUpdateSharedMemory</B>
to ensure data integrity on all possible platforms. 
<P>
Any miniport that calls <B>NdisMAllocateSharedMemoryAsync</B>&nbsp;or <B>NdisMAllocateSharedMemory</B>
must release all outstanding allocations with one or more calls to <B>NdisMFreeSharedMemory</B>
when its NIC is removed, that is, when its MiniportHalt function is called. 
<P>
Callers of <B>NdisMAllocateSharedMemory</B>&nbsp;run at IRQL PASSIVE_LEVEL. 
<H3>See Also</H3>
<P>
<B><A HREF="101mini_2.htm">MiniportAllocateComplete</A></B>, <B><A HREF="101mini_6.htm">MiniportHalt</A></B>,
<B><A HREF="101mini_8.htm">MiniportInitialize</A></B>, <B><A HREF="103ndisx_8.htm">NdisAllocateBuffer</A></B>,
<B><A HREF="103ndisx_9.htm">NdisAllocateBufferPool</A></B>, <B><A HREF="103ndisx_26.htm">NdisCreateLookaheadBufferFromSharedMemory</A></B>,
<B><A HREF="103ndisx_28.htm">NdisDestroyLookaheadBufferFromSharedMemory</A></B>,
<B><A HREF="103ndisx_36.htm">NdisFlushBuffer</A></B>, <B><A HREF="103ndisx_45.htm">NdisGetCacheFillSize</A></B>,
<B><A HREF="103ndisx_85.htm">NdisMAllocateMapRegisters</A></B>, <B><A HREF="103ndisx_87.htm">NdisMAllocateSharedMemoryAsync</A></B>,
<B><A HREF="103ndisx_106.htm">NdisMFreeSharedMemory</A></B>, <B><A HREF="103ndisx_107.htm">NdisMIndicateReceivePacket</A></B>,
<B><A HREF="103ndisx_129.htm">NdisMSetAttributes</A></B>, <B><A HREF="103ndisx_130.htm">NdisMSetAttributesEx</A></B>,
<B><A HREF="103ndisx_136.htm">NdisMStartBufferPhysicalMapping</A></B>,
<B><A HREF="103ndisx_142.htm">NdisMUpdateSharedMemory</A></B>, <B><A HREF="103ndisx_208.htm">NdisSystemProcessorCount</A></B>
<P></FONT>
</BODY>
</HTML>
