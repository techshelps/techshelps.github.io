<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MiniportISR</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_MiniportISR_NR"></A>MiniportISR</H2>
<P>
<B>VOID <BR>
&nbsp; &nbsp; MiniportISR(<BR>
&nbsp; &nbsp; &nbsp; &nbsp; OUT PBOOLEAN</B>&nbsp;<I>InterruptRecognized</I><B>,</B><BR>
<B>&nbsp; &nbsp; &nbsp; &nbsp; OUT PBOOLEAN</B>&nbsp;<I>QueueMiniportHandleInterrupt</I><B>,</B><BR>
<B>&nbsp; &nbsp; &nbsp; &nbsp; IN NDIS_HANDLE</B>&nbsp;<I>MiniportAdapterContext<BR>
</I><B>&nbsp; &nbsp; &nbsp; &nbsp; );</B>
<P>
MiniportISR is a required function if the driver’s NIC generates interrupts. 
<H3>Parameters</H3>
<DL>
<DT>
<I>InterruptRecognized</I>
<DD>
Points to a variable in which MiniportISR returns whether the NIC actually
generated the interrupt. MiniportISR sets this to TRUE if it detects that the
interrupt came from the NIC designated at <I>MiniportAdapterContext</I>. 
<P>
If its NIC shares an IRQ with other devices on the same bus, MiniportISR
should return FALSE as quickly as possible whenever it determines that the NIC
did not interrupt. 
<BR>
<DT>
<I>QueueMiniportHandleInterrupt</I>
<DD>
Points to a variable that MiniportISR sets to TRUE if the
MiniportHandleInterrupt function should be called to complete the
interrupt-driven I/O operation. 
<P>
If the variable at <I>InterruptRecognized</I>&nbsp;is set to FALSE, the value of
this variable is irrelevant because MiniportHandleInterrupt will not be
called. 
<BR>
<DT>
<I>MiniportAdapterContext</I>
<DD>
Specifies the handle to a miniport-allocated context area in which the driver
maintains per-NIC state, set up by MiniportInitialize. 
</DL>
<H3>Comments</H3>
<P>
Any NIC driver should do as little work as possible in its MiniportISR
function, deferring I/O operations for each interrupt the NIC generates to the
MiniportHandleInterrupt function. A NIC driver’s ISR is not re-entrant,
although two instantiations of a MiniportISR function can execute concurrently
in SMP machines, particularly if the miniport supports full-duplex sends and
receives. 
<P>
Miniport ISR is called under the following conditions:
<UL>
<LI>
An interrupt occurs on the NIC while the driver’s MiniportInitialize or
MiniportHalt function is running.
<P>
<LI>
An interrupt occurs on the I/O bus and the NIC shares an IRQ with other
devices on that bus. 
<P>
If the NIC shares an IRQ with other devices, that miniport’s ISR must be
called on every interrupt to determine whether its NIC actually generated the
interrupt. If not, MiniportISR should return FALSE immediately so the driver
of the device that actually generated the interrupt is called quickly. This
strategy maximizes I/O throughput for every device on the same bus. 
<P>
<LI>
An interrupt occurs and the NIC driver specified that its ISR should be called
to handle every interrupt when its MiniportInitialize function called <B>NdisMRegisterInterrupt</B>.
<P>
Miniports that do not provide MiniportDisable/EnableInterrupt<B>&nbsp;</B>functionality
must have their ISRs called on every interrupt. 
</UL>
<P>
MiniportISR dismisses the interrupt on the NIC, saves whatever state it must
about the interrupt, and defers as much of the I/O processing for each
interrupt as possible to the MiniportHandleInterrupt function. 
<P>
After MiniportISR returns control with the variables at <I>InterruptRecognized</I>
and <I>QueueMiniportHandleInterrupt</I>&nbsp;set to TRUE, the corresponding
MiniportHandleInterrupt function runs at a lower hardware priority (IRQL
DISPATCH_LEVEL) than that of the ISR (DIRQL). As a general rule,
MiniportHandleInterrupt should do all the work for interrupt-driven I/O
operations except for determining whether the NIC actually generated the
interrupt, and, if necessary, preserving the type (receive, send, reset...) of
interrupt. 
<P>
However, a driver writer should not rely on a one-to-one correspondence
between the execution of MiniportISR and MiniportHandleInterrupt. A
MiniportHandleInterrupt function should be written to handle the I/O
processing for more than one NIC interrupt. Its MiniportISR and
MiniportHandleInterrupt functions can run concurrently in SMP machines.
Moreover, as soon as MiniportISR acknowledges a NIC interrupt, the NIC can
generate another interrupt, while the MiniportHandleInterrupt DPC can be
queued for execution once for such a sequence of interrupts. 
<P>
The MiniportHandleInterrupt function is not queued if the driver’s
MiniportHalt or MiniportInitialize function is currently executing.
<P>
If MiniportISR shares resources, such as NIC registers or state variables,
with another Miniport<I>Xxx</I>&nbsp;that runs at lower IRQL, that Miniport<I>Xxx</I>
must call <B>NdisMSychronizeWithInterrupt</B>&nbsp;so the driver’s
MiniportSynchronizeISR function will access those shared resources in a
synchronized and multiprocessor-safe manner. Otherwise, while it is accessing
the shared resources, that Miniport<I>Xxx</I>&nbsp;function can be pre-empted by
MiniportISR, possibly undoing the work just done by Miniport<I>Xxx</I>. 
<P>
By default, MiniportISR runs at DIRQL, in particular at the DIRQL assigned
when the driver initialized the interrupt object with <B>NdisMRegisterInterrupt</B>.
Therefore, MiniportIsr can call only a subset of the NDIS library functions,
such as the <B>NdisRaw</B><I>Xxx</I>&nbsp;or <B>NdisRead/WriteRegister</B><I>Xxx</I>
functions that are safe to call at any IRQL. 
<H3>See Also</H3>
<P>
<B><A HREF="101mini_4.htm">MiniportDisableInterrupt</A></B>,<B>&nbsp;<A HREF="101mini_5.htm">MiniportEnableInterrupt</A></B>,<B>
<A HREF="101mini_6.htm">MiniportHalt</A></B>,<B>&nbsp;<A HREF="101mini_7.htm">MiniportHandleInterrupt</A></B>,<B>
<A HREF="101mini_8.htm">MiniportInitialize</A></B>,<B>&nbsp;<A HREF="101mini_18.htm">MiniportSynchronizeISR</A></B>,<B>
<A HREF="103ndisx_123.htm">NdisMRegisterInterrupt</A></B>, <B><A HREF="103ndisx_137.htm">NdisMSynchronizeWithInterrupt</A></B>,
<B><A HREF="103ndisx_163.htm">NdisRawReadPortBufferUchar</A></B>,
<B><A HREF="103ndisx_164.htm">NdisRawReadPortBufferUlong</A></B>,
<B><A HREF="103ndisx_165.htm">NdisRawReadPortBufferUshort</A></B>,
<B><A HREF="103ndisx_166.htm">NdisRawReadPortUchar</A></B>, <B><A HREF="103ndisx_167.htm">NdisRawReadPortUlong</A></B>,
<B><A HREF="103ndisx_168.htm">NdisRawReadPortUshort</A></B>, <B><A HREF="103ndisx_169.htm">NdisRawWritePortBufferUchar</A></B>,
<B><A HREF="103ndisx_170.htm">NdisRawWritePortBufferUlong</A></B>,
<B><A HREF="103ndisx_171.htm">NdisRawWritePortBufferUshort</A></B>,
<B><A HREF="103ndisx_172.htm">NdisRawWritePortUchar</A></B>, <B><A HREF="103ndisx_173.htm">NdisRawWritePortUlong</A></B>,
<B><A HREF="103ndisx_174.htm">NdisRawWritePortUshort</A></B>, <B><A HREF="103ndisx_181.htm">NdisReadRegisterUchar</A></B>,
<B><A HREF="103ndisx_182.htm">NdisReadRegisterUlong</A></B>, <B><A HREF="103ndisx_183.htm">NdisReadRegisterUshort</A></B>,
<B><A HREF="103ndisx_219.htm">NdisWriteRegisterUchar</A></B>, <B><A HREF="103ndisx_220.htm">NdisWriteRegisterUlong</A></B>,
<B><A HREF="103ndisx_221.htm">NdisWriteRegisterUshort</A></B>&nbsp; 
<P></FONT>
</BODY>
</HTML>
