<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TDI_SEND</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_TDI_SEND_NR"></A>TDI_SEND</H2>
<P>
When a kernel-mode client makes a TDI_SEND request, it asks the underlying TDI
transport driver to transmit a normal or expedited TSDU on a specified
connection endpoint to its remote-node peer. 
<H3>IRP</H3>
<P>
The transport calls <B>IoGetCurrentIrpStackLocation</B>&nbsp;with the given <I>Irp</I>
to get a pointer to its own I/O stack location in the IRP, shown in the
following list as <B>IrpSp</B>. IRP members relevant to this request include
the following:
<DL>
<DT>
<B>IoStatus.Status</B>
<DD>
Specifies the final status of the send request. The transport sets this member
before it completes the IRP, possibly to one of the following:
<P>
STATUS_SUCCESS<BR>
STATUS_PENDING<BR>
STATUS_INVALID_CONNECTION<BR>
STATUS_INVALID_PARAMETER<BR>
STATUS_DEVICE_NOT_READY
<BR>
<DT>
<B>IoStatus.Information</B>
<DD>
Specifies the number of bytes of client-supplied data the driver transferred
from the client-supplied buffer mapped at <B>Irp-&gt;MdlAddress</B>. 
<BR>
<DT>
<B>IrpSp-&gt;MajorFunction</B>
<DD>
Specifies IRP_MJ_INTERNAL_DEVICE_CONTROL. The transport can ignore this member
if it exports a TdiDispatchInternalDeviceControl routine that handles only
TDI_<I>XXX</I>&nbsp;requests. 
<BR>
<DT>
<B>IrpSp-&gt;MinorFunction</B>
<DD>
Specifies TDI_SEND.
<BR>
<DT>
<B>IrpSp-&gt;FileObject</B>
<DD>
Points to an open file object representing the connection endpoint. The
transport uses the <B>FsContext</B>&nbsp;and, possibly, <B>FsContext2</B>&nbsp;fields to
access the state it maintains about this connection. 
<P>
The client already established an endpoint-to-endpoint connection with a
remote-node peer on this connection endpoint. 
<BR>
<DT>
<B>IrpSp-&gt;Parameters</B>
<DD>
Points to a TDI_REQUEST_KERNEL_SEND structure, defined as follows:
<PRE><FONT FACE="Courier" SIZE="2">struct _TDI_REQUEST_KERNEL_SEND {<B>&nbsp;</B>
&nbsp; &nbsp; ULONG SendLength;<B>&nbsp;</B>
&nbsp; &nbsp; ULONG SendFlags;<B>&nbsp;</B>
} TDI_REQUEST_KERNEL_SEND, *PTDI_REQUEST_KERNEL_SEND;<B>&nbsp;</B>
<B>&nbsp;</B></FONT></PRE>
<P>
The transport uses the members of this structure as follows:
<DL>
<DT>
<B>SendLength</B>
<DD>
Specifies the number of bytes of data to be sent in the buffer mapped at <B>Irp-&gt;MdlAddress</B>.
<BR>
<DT>
<B>SendFlags</B>
<DD>
Specifies the type of TSDU the client expects to be sent as none (zero), one,
or a combination (ORed) of TDI_SEND_<I>XXX</I>&nbsp;flags (see Comments).
</DL>
<DT>
<B>MdlAddress</B>
<DD>
Points to an MDL, possibly the initial MDL in a chain, mapping a
client-supplied buffer containing the data to be sent. 
</DL>
<H3>Comments</H3>
<P>
When a client calls <B>TdiBuildSend</B>&nbsp;to set up this IRP, it can specify the
type of send it wants. The transport finds this information at <B>IrpSp-&gt;Parameters</B>
in the <B>SendFlags</B>&nbsp;member. On input, <B>SendFlags</B>&nbsp;can be zero or set
with any combination (ORed) of the following flags: 
<DL>
<DT>
TDI_SEND_EXPEDITED
<DD>
The given data should be sent ahead of any normal send requests the transport
is currently holding queued for transmission on this endpoint-to-endpoint
connection. If the transport does not support expedited transfers, it can
ignore this flag. 
<BR>
<DT>
TDI_SEND_PARTIAL
<DD>
The given data is not a complete message-mode TSDU. The client will send the
remaining data for the TSDU later. This flag is irrelevant to stream-mode
transports. 
<P>
If this flag is clear in a send submitted to a message-mode transport, the
driver inserts an end-of-record mark in the line flow after sending all data
supplied in the client&#39;s buffer. 
<BR>
<DT>
TDI_SEND_NO_RESPONSE_EXPECTED
<DD>
The caller is giving a hint to the underlying transport that it does not
expect a response to this send from its remote-node peer. This flag should
disable piggybacking of the TSDU acknowledgment by the remote-node transport.
<BR>
<DT>
TDI_SEND_NON_BLOCKING
<DD>
If the underlying transport currently has no internal buffer space available
for the given data, it should just complete the IRP with
STATUS_DEVICE_NOT_READY. If the transport has some buffer space available, it
should copy as much data as it can from the client-supplied buffer, set the <B>IoStatus.Information</B>
member to the number of bytes it copied, and complete the IRP with
STATUS_SUCCESS.
<P>
This flag is irrelevant to transports that do not buffer sends internally.
</DL>
<P>
Each local-node client send request is associated with exactly one of the
following:
<UL>
<LI>
A receive request issued by the remote-node client to its underlying transport
<P>
<LI>
A remote-node transport&#39;s call to its client&#39;s registered
ClientEventReceive, ClientEventReceiveExpedited, ClientEventChainedReceive, or
ClientEventChainedReceiveExpedited handler 
</UL>
<P>
The local-node TDI transport driver can queue any number of send requests on a
particular connection, but it must process them in FIFO order, unless the
client issues an expedited send. Each expedited send request must be queued
and transmitted ahead of any normal send requests the transport is holding
queued, and each expedited send also must be transmitted in FIFO order for the
client. 
<P>
The transport must complete each send IRP in a timely manner, whether with a
success or error status. The driver should determine a reasonable time-out
based on its knowledge of underlying network conditions.
<P>
Depending on the underlying transport, clients can send stream-mode or
message-mode TSDUs, the latter with one or more send requests. For stream-mode
transports, the client does not delimit messages and the TDI_SEND_PARTIAL flag
is irrelevant. For message-mode transports, the client can send a TSDU as a
sequence of send requests, each specifying the TDI_SEND_PARTIAL flag. If this
flag is clear in a submitted send request, a message-mode transport considers
the data to be the end of such a sequence or a complete TSDU. The remote-node
TDI transport notifies the receiving client of partial TSDUs through receive
indicators passed in the corresponding receive indication(s).
<P>
In its send request, the sending client provides a buffer containing the TSDU.
The client can provide a buffer of any size up to the transport-determined
limit. The transport is given ownership of this client-supplied buffer until
it completes the send. The transport fails any send request for which a client
specifies a <B>SendLength</B>&nbsp;larger than the transport supports. 
<P>
Clients can determine their underlying transports&#39; send-size limits by
submitting TDI_QUERY_PROVIDER_INFO-type queries. 
<P>
If the transport buffers client-supplied send data internally, the client can
request a nonblocking send by setting the TDI_SEND_NON_BLOCKING flag. When
such a transport is given a send request with this flag set, it completes the
IRP with STATUS_DEVICE_NOT_READY if it cannot copy the given data into its
internal buffer space. Such a transport returns STATUS_SUCCESS if it buffers
only a part of the given TSDU internally, but it must set <B>IoStatus.Information</B>
in such an IRP to the number of bytes it buffered internally so its client can
submit a subsequent send for the remaining data in the original send request.
<P>
Any client that submits nonblocking send requests usually registers a
ClientEventSendPossible handler. The underlying transport calls this handler
after it has rejected a send request with STATUS_DEVICE_NOT_READY as soon as
that transport has internal buffer space available for holding send data. 
<P>
A transport also can support zero-length send requests. A zero-length send in
which the TDI_SEND_PARTIAL flag is clear actually forces protocol flow. The
client of such a transport can issue zero-length send to satisfy a receive
request. If the driver does not support zero-length sends, it should return an
error when its clients submit zero-length send requests.
<P>
<B>TdiBuildSend</B>&nbsp;is the macro a client uses to fill in the IRP.
<H3>See Also</H3>
<P>
<B><A HREF="25tdicli_2.htm">ClientEventChainedReceive</A></B>, <B><A HREF="25tdicli_4.htm">ClientEventChainedReceiveExpedited</A></B>,
<B><A HREF="25tdicli_7.htm">ClientEventReceive</A></B>, <B><A HREF="25tdicli_9.htm">ClientEventReceiveExpedited</A></B>,
<B><A HREF="25tdicli_10.htm">ClientEventSendPossible</A></B>, <B><A HREF="24bldmac_14.htm">TdiBuildSend</A></B>,
<B><A HREF="21tddisp_6.htm">TdiDispatchInternalDeviceControl</A></B>,
<B><A HREF="22ioctl_8.htm">TDI_QUERY_INFORMATION</A></B>, <B><A HREF="22ioctl_9.htm">TDI_RECEIVE</A></B>
<P></FONT>
</BODY>
</HTML>
