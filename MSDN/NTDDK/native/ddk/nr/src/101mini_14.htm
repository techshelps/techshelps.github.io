<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MiniportSend</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_MiniportSend_NR"></A>MiniportSend</H2>
<P>
<B>NDIS_STATUS <BR>
&nbsp; &nbsp; MiniportSend(<BR>
&nbsp; &nbsp; &nbsp; &nbsp; IN NDIS_HANDLE</B>&nbsp;<I>MiniportAdapterContext</I><B>,</B><BR>
<B>&nbsp; &nbsp; &nbsp; &nbsp; IN PNDIS_PACKET</B>&nbsp;<I>Packet</I><B>,</B><BR>
<B>&nbsp; &nbsp; &nbsp; &nbsp; IN UINT</B>&nbsp;<I>Flags<BR>
</I><B>&nbsp; &nbsp; &nbsp; &nbsp; );</B>
<P>
MiniportSend is a required function if the driver has neither a
MiniportSendPackets nor MiniportWanSend function. MiniportSend transfers a
protocol-supplied packet over the network.
<H3>Parameters</H3>
<DL>
<DT>
<I>MiniportAdapterContext</I>
<DD>
Specifies the handle to a miniport-allocated context area in which the driver
maintains per-NIC state, set up by MiniportInitialize. 
<BR>
<DT>
<I>Packet</I>
<DD>
Points to a packet descriptor specifying the data to be transmitted.
<BR>
<DT>
<I>Flags</I>
<DD>
Specifies the packet flags, if any, set by the protocol.
</DL>
<H3>Return Value</H3>
<P>
MiniportSend can return one of the following values:
<DL>
<DT>
NDIS_STATUS_SUCCESS
<DD>
The driver (or its NIC) has accepted the packet data for transmission, so
MiniportSend is returning the packet, which NDIS will return to the protocol. 
<BR>
<DT>
NDIS_STATUS_PENDING
<DD>
The driver will complete the packet asynchronously with a call to <B>NdisMSendComplete</B>.
<BR>
<DT>
NDIS_STATUS_RESOURCES
<DD>
The driver (or NIC) currently has insufficient resources available to process
the given packet so NDIS should queue the send packet for a resubmission when
the driver next calls <B>NdisMSendResourcesAvailable</B>&nbsp;or <B>NdisMSendComplete</B>.
&nbsp;
<BR>
<DT>
NDIS_STATUS_FAILURE
<DD>
The given packet was invalid or unacceptable to the NIC. 
</DL>
<H3>Comments</H3>
<P>
If a driver registers both MiniportSend and MiniportSendPackets functions when
it initializes, its MiniportSend function is never called by NDIS.
<P>
MiniportSend can safely access the packet and all buffer descriptors chained
to the packet until the given packet is complete. If MiniportSend returns a
status other than NDIS_STATUS_PENDING or NDIS_STATUS_RESOURCES, the request is
considered complete and ownership of the packet descriptor and all memory
associated with the packet reverts to the allocating protocol. 
<P>
If MiniportSend returns NDIS_STATUS_PENDING, the driver subsequently must
signal completion of the request by calling <B>NdisMSendComplete</B>. When
MiniportSend returns NDIS_STATUS_RESOURCES, the NDIS library reflects this
status to the protocol as NDIS_STATUS_PENDING. 
<P>
When this function returns a packet with NDIS_STATUS_RESOURCES, the next
packet submitted to MiniportSend is the same packet it just returned to NDIS.
Consequently, MiniportSend can optimize by retaining information about such a
returned packet if the driver currently has sufficient resources to store the
information. NDIS assumes MiniportSend is ready to accept that packet as soon
as the driver calls <B>NdisMSendResourcesAvailable</B>&nbsp;or <B>NdisMSendComplete</B>,
whichever occurs first. 
<P>
Each protocol driver must pass packet descriptors to <B>NdisSend</B>&nbsp;that are
fully set up to be passed by the underlying driver’s MiniportSend function to
its NIC. That is, the protocol is responsible for determining what is
required, based on the medium type selected by the miniport to which the
protocol bound itself. However, a protocol can supply net packets mapped by
the chained buffer descriptors that are shorter than the minimum for the
selected medium, which MiniportSend must pad if its medium imposes a
minimum-length requirement on transmits.
<P>
Any NDIS intermediate driver that layers itself betwen a higher-level protocol
and an underlying NIC driver has the same responsibility as any protocol
driver to set up packets according to the requirements of the underlying
miniport and its selected medium. Such an intermediate driver must repackage
each incoming send packet in a fresh packet descriptor that was allocated by
the intermediate driver. 
<P>
MiniportSend can use only the eight-byte area at <B>MiniportReserved</B>
within the NDIS_PACKET structure for its own purposes. Consequently, an NDIS
intermediate driver that forwards send requests to an underlying NIC driver
must repackage the packets input to its MiniportSend function in fresh packet
descriptors, which the intermediate driver allocates from packet pool, so that
the underlying miniport has a <B>MiniportReserved</B>&nbsp;area it can use. 
<P>
MiniportSend can call <B>NdisQueryPacket</B>&nbsp;to extract information, such as
the number of buffer descriptors chained to the packet and the total size in
bytes of the requested transfer. It can call <B>NdisGetFirstBufferFromPacket</B>,
<B>NdisQueryBuffer</B>, or <B>NdisQueryBufferOffset</B>&nbsp;to extract information
about individual buffers containing the data to be transmitted. 
<P>
The <I>Flags</I>&nbsp;parameter can provide information about a send that is not
contained in the packet data itself. Currently, there are no system-defined
flags, but a pair of closely coupled protocol and miniport drivers can pass
information in this parameter, which MiniportSend can retrieve with <B>NdisGetPacketFlags</B>.
However, such a pair of drivers can communicate more information, such as
timestamps and packet priority, in the NDIS_PACKET_OOB_DATA block associated
with each packet descriptor. 
<P>
If the underlying driver’s MiniportQueryInformation function set the
NDIS_MAC_OPTION_NO_LOOPBACK flag when the NDIS library queried the
OID_GEN_MAC_OPTIONS, the miniport must not attempt to loop back any packets.
The NDIS library provides software loopback support for such a driver. 
<P>
MiniportSend can be pre-empted by an interrupt.
<P>
By default, MiniportSend runs at IRQL DISPATCH_LEVEL. 
<H3>See Also</H3>
<P>
<B><A HREF="101mini_8.htm">MiniportInitialize</A></B>, <B><A HREF="101mini_10.htm">MiniportQueryInformation</A></B>,
<B><A HREF="101mini_15.htm">MiniportSendPackets</A></B>, <B><A HREF="101mini_21.htm">MiniportWanSend</A></B>,
<B><A HREF="103ndisx_11.htm">NdisAllocatePacket</A></B>, <B><A HREF="103ndisx_44.htm">NdisGetBufferPhysicalArraySize</A></B>,
<B><A HREF="103ndisx_48.htm">NdisGetFirstBufferFromPacket</A></B>,
<B><A HREF="103ndisx_49.htm">NdisGetNextBuffer</A></B>, <B><A HREF="103ndisx_50.htm">NdisGetPacketFlags</A></B>,
<B><A HREF="103ndisx_52.htm">NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO</A></B>,
<B><A HREF="103ndisx_56.htm">NDIS_GET_PACKET_TIME_TO_SEND</A></B>,
<B><A HREF="103ndisx_115.htm">NdisMoveMemory</A></B>, <B><A HREF="103ndisx_116.htm">NdisMoveToMappedMemory</A></B>,
<B><A HREF="103ndisx_127.htm">NdisMSendComplete</A></B>, <B><A HREF="103ndisx_128.htm">NdisMSendResourcesAvailable</A></B>,
<B><A HREF="103ndisx_134.htm">NdisMSetupDmaTransfer</A></B>, <B><A HREF="103ndisx_136.htm">NdisMStartBufferPhysicalMapping</A></B>,
<B><A HREF="106nstru_4.htm">NDIS_PACKET</A></B>, <B><A HREF="106nstru_5.htm">NDIS_PACKET_OOB_DATA</A></B>,
<B><A HREF="103ndisx_157.htm">NdisQueryBuffer</A></B>, <B><A HREF="103ndisx_158.htm">NdisQueryBufferOffset</A></B>,
<B><A HREF="103ndisx_160.htm">NdisQueryPacket</A></B>, <B><A HREF="103ndisx_193.htm">NdisSend</A></B>,
<B><A HREF="103ndisx_223.htm">NdisZeroMemory</A></B>&nbsp;
<P></FONT>
</BODY>
</HTML>
