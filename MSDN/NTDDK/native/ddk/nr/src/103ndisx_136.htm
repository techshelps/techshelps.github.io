<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NdisMStartBufferPhysicalMapping</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_NdisMStartBufferPhysicalMapping_NR"></A>NdisMStartBufferPhysicalMapping</H2>
<P>
<B>VOID <BR>
&nbsp; &nbsp; NdisMStartBufferPhysicalMapping(<BR>
&nbsp; &nbsp; &nbsp; &nbsp; IN NDIS_HANDLE</B>&nbsp;<I>MiniportAdapterHandle</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN PNDIS_BUFFER</B>&nbsp;<I>Buffer</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN ULONG</B>&nbsp;<I>PhysicalMapRegister</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>IN BOOLEAN</B>&nbsp;<I>WriteToDevice</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>OUT PNDIS_PHYSICAL_ADDRESS_UNIT</B>&nbsp;<I>PhysicalAddressArray</I><B>,</B><BR>
&nbsp; &nbsp; &nbsp; &nbsp; <B>OUT</B>&nbsp;<B>PUINT</B>&nbsp;<I>ArraySize<BR>
</I>&nbsp; &nbsp; &nbsp; &nbsp; <B>);</B>
<P>
<B>NdisMStartBufferPhysicalMapping</B>&nbsp;sets up a mapping for a busmaster DMA
transfer operation. 
<H3>Parameters</H3>
<DL>
<DT>
<I>MiniportAdapterHandle</I>
<DD>
Specifies the handle originally input to MiniportInitialize.
<BR>
<DT>
<I>Buffer</I>
<DD>
Points to a buffer descriptor mapping the virtual range for the transfer. This
buffer contains the data to be transferred.
<BR>
<DT>
<I>PhysicalMapRegister</I>
<DD>
Specifies the zero-based index of the map register to be used for the
transfer. This value must be no greater than one less than the number of map
registers that the driver allocated during initialization with <B>NdisMAllocateMapRegisters</B>.
<BR>
<DT>
<I>WriteToDevice</I>
<DD>
Specifies TRUE when the mapping is used for an outbound transfer from the
system through the NIC.
<BR>
<DT>
<I>PhysicalAddressArray</I>
<DD>
Points to a caller-supplied array of NDIS_PHYSICAL_UNIT structures, in which
each element is defined as follows: 
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _NDIS_PHYSICAL_ADDRESS_UNIT {
&nbsp; &nbsp; NDIS_PHYSICAL_ADDRESS PhysicalAddress;
&nbsp; &nbsp; UINT Length;
} NDIS_PHYSICAL_ADDRESS_UNIT, *PNDIS_PHYSICAL_ADDRESS_UNIT;
&nbsp;</FONT></PRE>
<P>
On return from a successful call to <B>NdisMStartBufferPhysicalMapping</B>,
elements in this array specify the mapped logical ranges suitable for
downloading to the NIC, with the following members in each element: 
<DL>
<DT>
<B>PhysicalAddress</B>
<DD>
Specifies the base physical address for the start of a discrete contiguous
range of data to be transferred. 
<BR>
<DT>
<B>Length</B>
<DD>
Specifies the number of bytes in the mapped range. 
</DL>
<DT>
<I>ArraySize</I>
<DD>
Points to a caller-supplied variable in which <B>NdisMStartBufferPhysicalMapping</B>
returns the number of ranges it mapped in the buffer at <I>PhysicalAddressArray</I>.
This value is a count of the elements that contain mappings, so the caller can
use this count as a bound on the number of physical address ranges it
downloads to the NIC subsequently. 
</DL>
<H3>Comments</H3>
<P>
Busmaster NIC drivers call <B>NdisMStartBufferPhysicalMapping</B>&nbsp;in response
to send requests originating in protocols bound to the NIC. That is, the
buffer descriptor at <I>Buffer</I>&nbsp;usually was chained to a packet input to
the NIC driver’s MiniportSend or MiniportSendPackets function. 
<P>
Every protocol driver is responsible for setting up send packets to suit the
limits of the underlying NIC. The NIC driver’s MiniportQueryInformation
function already returned these limits in response to certain OID_GEN_<I>XXX</I>
requests. Consequently, a miniport need not test incoming send packets for
oversized frames or transmit blocks, nor for transmit buffer overflows. For
more information about OIDs, see <A HREF="105ndoid.htm">Chapter
5</A>. 
<P>
A caller of <B>NdisMStartBufferPhysicalMapping</B>&nbsp;must ensure that the array
at <I>PhysicalAddressArray</I>&nbsp;is large enough to map the given buffer. A
miniport can call <B>NdisGetBufferPhysicalArraySize</B>&nbsp;to determine how many
elements are required to map the virtual range specified in the descriptor at <I>Buffer</I>.
<P>
For small transfer requests, such as those up to 256K in length, a miniport
can achieve higher performance by copying the data to be transmitted into a
staging buffer in the shared memory space already allocated with <B>NdisMAllocateSharedMemory</B>
or <B>NdisMAllocateSharedMemoryAsync</B>. Because the NIC driver already has
mapped virtual and physical addresses for such a shared memory range, it need
not call <B>NdisM..BufferPhysicalMapping</B>&nbsp;functions for such small DMA
transfers. 
<P>
Data received by a busmaster NIC is transferred directly into
device-accessible buffers within a shared memory block allocated by the
miniport. Miniports perform explicit busmaster DMA operations only for
transmits. 
<P>
To transfer packet data for a send request, any miniport basically does the
following:
<OL>
<LI>
Maps the virtual range containing the data with <B>NdisMStartBufferPhysicalMapping</B>
to get mapped device-accessible range addresses for use by its NIC
<P>
<LI>
Downloads the returned physical addresses to the NIC
<P>
<LI>
Calls <B>NdisFlushBuffer</B>&nbsp;and <B>NdisMUpdateSharedMemory</B>&nbsp;if the driver
allocated cached memory
<P>
<LI>
Programs the NIC for the transfer operation
<P>
<LI>
Calls <B>NdisMCompleteBufferPhysicalMapping</B>, usually from the
MiniportHandleInterrupt function, when the NIC has completed the transfer,
which the NIC indicates by a transmit interrupt or, possibly, by a state
change discovered by the NIC driver’s polling MiniportTimer function 
</OL>
<P>
Any mapping returned by <B>NdisMStartBufferPhysicalMapping</B>&nbsp;is valid only
until the miniport calls <B>NdisMCompleteBufferPhysicalMapping</B>. When <B>NdisMCompleteBufferPhysicalMapping</B>
returns control, the <I>PhysicalMapRegister</I>&nbsp;specified in the preceding
call to <B>NdisMStartBufferPhysicalMapping</B>&nbsp;can be reused in a subsequent
DMA operation. 
<P>
Callers of <B>NdisMStartBufferPhysicalMapping</B>&nbsp;run at IRQL &lt;=
DISPATCH_LEVEL. 
<H3>See Also</H3>
<P>
<B><A HREF="101mini_7.htm">MiniportHandleInterrupt</A></B>, <B><A HREF="101mini_8.htm">MiniportInitialize</A></B>,
<B><A HREF="101mini_10.htm">MiniportQueryInformation</A></B>, <B><A HREF="101mini_14.htm">MiniportSend</A></B>,
<B><A HREF="101mini_15.htm">MiniportSendPackets</A></B>, <B><A HREF="101mini_19.htm">MiniportTimer</A></B>,
<B><A HREF="103ndisx_36.htm">NdisFlushBuffer</A></B>, <B><A HREF="103ndisx_44.htm">NdisGetBufferPhysicalArraySize</A></B>,
<B><A HREF="103ndisx_85.htm">NdisMAllocateMapRegisters</A></B>, <B><A HREF="103ndisx_86.htm">NdisMAllocateSharedMemory</A></B>,
<B><A HREF="103ndisx_87.htm">NdisMAllocateSharedMemoryAsync</A></B>,
<B><A HREF="103ndisx_93.htm">NdisMCompleteBufferPhysicalMapping</A></B>,
<B><A HREF="103ndisx_142.htm">NdisMUpdateSharedMemory</A></B>&nbsp;
<P></FONT>
</BODY>
</HTML>
