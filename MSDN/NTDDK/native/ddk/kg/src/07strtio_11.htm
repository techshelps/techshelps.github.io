<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>7.3  Requirements for Using Interlocked Queues or Device Queues</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Requirements_for_Using_Interlocked_Queues_or_Device_Queues_KG"></A>7.3  Requirements for Using Interlocked Queues or Device Queues</H2>
<P>
A lowest-level NT driver either must have a StartIo routine or must set up and
manage its own internal queue(s) of IRPs. A higher-level NT driver can have
its own internal queues of IRPs at the discretion of the driver designer. 
<P>
Depending on the functionality required and the nature of the underlying
device, an NT driver writer might implement a StartIo routine and set up one
or more driver-managed supplemental queues for IRPs. 
<P>
The system provides support for the following kinds of internal queues of IRPs
that NT drivers can use:
<UL>
<LI>
A doubly-linked interlocked queue into which the driver inserts IRPs by
calling <B>ExInterlockedInsertTailList</B>&nbsp;or <B>ExInterlockedInsertHeadList</B>,
and from which a device-dedicated thread, worker-thread callback, or another
driver routine removes IRPs by calling <B>ExInterlockedRemoveHeadList</B>
<P>
<LI>
A device queue associated with a device object into which the driver can
insert IRPs by calling <B>KeInsertDeviceQueue</B>&nbsp;or <B>KeInsertByKeyDeviceQueue</B>,
and from which it can remove IRPs by calling <B>KeRemoveDeviceQueue</B>, <B>KeRemoveByKeyDeviceQueue</B>,
or <B>KeRemoveEntryDeviceQueue</B>
<P>
If the driver has a StartIo routine, it can queue and dequeue IRPs from the
device queue associated with its device object(s) by calling <B>IoStartNextPacket</B>
or <B>IoStartNextPacketByKey</B>, as mentioned in <A HREF="07strtio_3.htm">Section
7.2.1</A>. 
</UL>
<P>
An interlocked queue is simpler to manage, particularly for drivers with
device-dedicated threads or worker-thread callbacks. On the other hand,
supplemental device queues give an NT driver more control over whether a given
IRP is placed in the queue and over the ordering of entries in the queue. 
<P>
An NT driver should not use a singly-linked interlocked queue for IRPs. 
<P></FONT>
</BODY>
</HTML>
