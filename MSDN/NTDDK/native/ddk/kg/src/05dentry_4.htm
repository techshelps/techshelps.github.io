<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.2  DriverEntry Routine Functionality</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_DriverEntry_Routine_Functionality_KG"></A>5.2  DriverEntry Routine Functionality</H2>
<P>
This section summarizes how a representative NT device driver’s DriverEntry
routine works.
<P>
The particulars of how any NT device driver uses the registry and initializes
its device(s) are device-dependent, as well as dependent on the driver’s
designer. The particulars of how any higher-level NT driver uses the registry
are somewhat device-type-dependent, as well as dependent on the driver’s
designer.
<P>
Every DriverEntry routine is called with two input pointers, as shown in the
declaration. The input <I>DriverObject</I>&nbsp;pointer allows the DriverEntry
routine to set appropriate entry points for its Dispatch, StartIo, and/or
Unload routines in the driver object.
<H5>Using the Configuration Registry</H5>
<P>
The input <I>DriverObject</I>&nbsp;pointer also gives the driver access to <I>DriverObject</I><B>-&gt;HardwareDatabase</B>,
which points to a counted Unicode string that specified a path to the registry
<B>\Registry\Machine\Hardware</B>&nbsp;tree. The <I>RegistryPath</I>&nbsp;input to the
DriverEntry routine points to a counted Unicode string that specifies a path
to the driver’s registry key <B>\Registry\Machine\System\CurrentControlSet\Services\</B><I>DriverName</I>.
<P>
Every NT driver can get information from the registry in order to initialize
successfully. For example, higher-level NT drivers that layer themselves over
drivers for a particular kind of underlying device can get information about
how many devices of that type are present in any particular Windows NT
machine.
<P>
The DriverEntry routines of NT device drivers must successfully claim the
hardware resources they need to support I/O on their devices in the registry <I>before</I>
they attempt to initialize any physical device. If an NT device driver cannot
establish a claim in the registry on the I/O ports, device memory ranges,
interrupt, and/or DMA channel/port it needs to perform device I/O, that driver
cannot remain loaded.
<P>
In general, an NT device driver whose support is necessary for the system to
boot is likely to use the registry in a slightly different manner than a
driver that can be loaded and unloaded on demand. The driver of a device that
must be accessible for the system itself to load is more likely to get support
from what the system’s hardware-detection code stored in the <B>\Registry\Machine\Hardware\Description</B>
tree. The DriverEntry routine of a load-on-demand driver is likely to depend
more on user-supplied value entries in the driver’s registry key <B>\Registry\Machine\System\CurrentControlSet\Services\</B><I>DriverName</I>
and/or in its <B>Parameters</B>&nbsp;subkey(s) that were set up when the driver was
installed in the system.
<P>
For more information about how NT drivers use the registry, see Chapter 16.
For more information about the installation of NT drivers, see the <I>Programmer’s
Guide</I>.
<P></FONT>
</BODY>
</HTML>
