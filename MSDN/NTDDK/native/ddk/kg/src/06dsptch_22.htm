<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.4.1  DispatchDeviceControl in Lowest-Level Drivers</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_DispatchDeviceControl_in_Lowest_Level_Drivers_KG"></A>6.3.4.1  DispatchDeviceControl in Lowest-Level Drivers</H4>
<DL>
<DT>
An IRP_MJ_DEVICE_CONTROL request for a lowest-level NT driver either requires
the driver to change the state of its device or to provide information about
the state of its device. Because most kinds of NT drivers are required to
handle a number of I/O control codes, their DispatchDeviceControl routines
usually contain a <B>switch</B>&nbsp;statement somewhat like the following:
<DD>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; &nbsp;:      : 
switch(irpSp-&gt;Parameters.DeviceIoControl.IoControlCode) { 
&nbsp; &nbsp; case IOCTL_DeviceType_XXX: 
&nbsp; &nbsp; case IOCTL_DeviceType_YYY: 
&nbsp; &nbsp; &nbsp; &nbsp; if (irpSp-&gt;Parameters.DeviceIoControl.InputBufferLength &lt; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(sizeof(IOCTL_XXXYYY_STRUCTURE))) { 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;status = STATUS_BUFFER_TOO_SMALL; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; 
&nbsp; &nbsp; &nbsp; &nbsp; } else { 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IoMarkIrpPending(Irp); 
&nbsp; &nbsp; &nbsp; :       : // pass IRP on for further processing 
&nbsp; &nbsp; case ... 
&nbsp; &nbsp; &nbsp; :      : 
&nbsp;</FONT></PRE>
</DL>
<P>
As this code fragment shows, a DispatchDeviceControl routine also checks
parameters, sometimes on each I/O control code that the driver must support,
sometimes on groups of these IOCTL_<I>XXX</I>. 
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>Consider these
implementation guidelines for device drivers’ DispatchDeviceControl routines:<B>
</B>
<UL>
<LI>
As for any IRP and driver Dispatch routine, DispatchDeviceControl must check
the parameters for validity and complete IRPs with parameter errors
immediately, as described in <A HREF="06dsptch_7.htm">Section
6.2.3</A>. 
<P>
<LI>
Switching first on any I/O control codes for which the DispatchDeviceControl
routine can satisfy and complete the IRP improves performance because the
driver can return control faster. 
<P>
For better performance, every NT device driver should satisfy any device
control request that it can, without queueing the IRP to other driver
routines, in its DispatchDeviceControl routine. 
<P>
<LI>
Switching later on I/O control codes that specify infrequently requested
operations also can improve the driver’s performance in processing
IRP_MJ_DEVICE_CONTROL_REQUESTS. 
<P>
<LI>
Grouping <B>case</B>s of I/O control codes as possible when testing for valid
parameters is economical both in term of driver performance/size and in code
maintenance. As the preceding code fragment suggests, I/O control codes that
use a common structure are natural candidates for such a <B>case</B>&nbsp;group. 
</UL>
<P>
For those IRPs that the DispatchDeviceControl routine can complete, it should
call <B>IoCompleteRequest</B>&nbsp;with a <I>PriorityBoost</I>&nbsp;of IO_NO_INCREMENT.
The DispatchDeviceControl routine must call <B>IoMarkIrpPending</B>&nbsp;with each
request that it queues for further processing on the device and it must return
STATUS_PENDING. 
<P></FONT>
</BODY>
</HTML>
