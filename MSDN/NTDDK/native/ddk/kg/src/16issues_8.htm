<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.3  Polling a Device</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Polling_a_Device_KG"></A>16.3  Polling a Device</H2>
<P>
An NT device driver should avoid polling its device unless it is absolutely
necessary and should never use a whole timeslice polling. Polling a device is
an expensive operation that makes any operating system compute-bound within
the polling driver. If a device driver does much polling, it interferes with
I/O operations on other devices and can make the system slow and unresponsive
to users. 
<P>
Recently developed devices, which are as technologically advanced as the
processors on which Windows NT is designed to run, seldom require a driver
that polls its device to be sure the device is ready to start an I/O operation
or that an operation has been completed. 
<P>
Nevertheless, some devices still in use were designed to work with old
processors, which had narrow data buses, slow clock rates, and single-user,
single-tasking operating systems that did synchronous I/O. Such devices might
require polling or some other means of waiting for the device to update its
registers, particularly for Windows NT, which is designed to do asynchronous
I/O on new processors with wide data buses and fast clock rates. 
<P>
An inexperienced driver programmer might think that an NT driver could solve
such a slow-device problem by coding a simple loop that increments a counter,
thereby “wasting” a minimum interval while its device updates registers.
However, such an NT driver is unlikely to be portable across Windows NT
platforms. The loop counter maximum would require customization for each
Windows NT platform. Furthermore, when such a driver is recompiled with a good
optimizing compiler, the compiler could remove the driver’s counter variable
and the loop(s) where it is incremented. 
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Follow this implementation guideline if the device is such that its driver must stall while the hardware updates state: </H5>
<P>
An NT driver can call <B>KeStallExecutionProcessor</B>&nbsp;before it reads the
device register(s). Such a driver should minimize the interval it stalls and
should, in general, specify a stall interval no longer than 50 microseconds. 
<P>
The granularity of a <B>KeStallExecutionProcessor</B>&nbsp;interval is 1
microsecond. 
<P>
The designer of an NT driver for a device that frequently requires more than
50 microseconds to update state should consider setting up a device-dedicated
thread. 
<H5>Driver Threads</H5>
<P>
The driver of a slow device or a device that is seldom used like the floppy
controller, can solve many “waiting” problems by creating a device-dedicated
system thread or, for a file system driver, by using system worker threads and
supplying worker-thread callback routines, as most NT FSDs do. A thread can
call <B>KeDelayExecutionThread</B>&nbsp;to wait for an interval that could be a
full timeslice or longer. 
<P>
The granularity of a <B>KeDelayExecutionThread</B>&nbsp;interval is around 10
milliseconds. Because<B>&nbsp;KeDelayExecutionThread</B>&nbsp;is a timer-driven routine,
the granularity of its interval is slightly faster or slower than 10
milliseconds, depending on the platform. However, such a call is portable
because the delta time specified is constant. 
<P>
If such an NT device driver has its own thread context or is running in a
system-thread context, the device-dedicated thread or highest-level driver’s
worker-thread callback routine can synchronize operations on a Kernel-defined
dispatcher object such as an event or semaphore in a shared communication
region of the driver’s device extension. While its device is not in use, a
device-dedicated thread can wait on a shared dispatcher object, for example,
by calling <B>KeWaitForSingleObject</B>&nbsp;with a semaphore. Until such a device
driver is called to carry out an I/O operation and sets the semaphore to the
Signaled state, its waiting thread uses no CPU time. 
<H5>Setting the Base Priority of a Driver-Created Thread</H5>
<P>
An NT driver should set the base priority of any driver- or device-dedicated
thread that it creates with <B>PsCreateSystemThread</B>&nbsp;to the lowest
real-time priority level in order to give its thread(s) a relatively high
priority while avoiding runtime priority inversions in SMP machines. 
<P></FONT>
</BODY>
</HTML>
