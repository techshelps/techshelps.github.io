<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.9  Kernel Dispatcher Objects</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Kernel_Dispatcher_Objects_KG"></A>3.9  Kernel Dispatcher Objects</H2>
<P>
As mentioned in <A HREF="03ntobj_29.htm">Section
3.7</A>, the NT Kernel defines the object type for timer objects, which can be
associated with driver-supplied CustomTimerDpc routines. A timer object is one
of a set of Kernel-defined object types called <I>dispatcher objects</I>.
<P>
The NT Kernel also defines the types for other dispatcher objects, such as
events, semaphores, and mutexes. The Kernel-defined thread object,
representing a thread of execution within the system, is also a dispatcher
object.
<P>
Dispatcher objects can be used as synchronization mechanisms within a
nonarbitrary thread context while running at IRQL PASSIVE_LEVEL.
<H5>Dispatcher Objects State and Thread Priorities</H5>
<P>
Every Kernel-defined dispatcher object type has a state that is either set to
Signaled or set to Not-Signaled.
<P>
A group of threads can synchronize their operations by having one or more
threads call <B>KeWaitForSingleObject, KeWaitForMutexObject,</B>&nbsp;or <B>KeWaitForMultipleObjects</B>
with dispatcher object(s) and waiting until another routine or thread sets the
dispatcher object(s) to the Signaled state.
<P>
When a thread calls the <B>KeWaitForSingleObject</B>&nbsp;with a dispatcher object
or <B>KeWaitForMutexObject</B>&nbsp;with a mutex, the thread is put into a wait
state until the dispatcher object is set to the Signaled state. When a thread
calls <B>KeWaitForMultipleObjects</B>&nbsp;with one or more dispatcher objects, the
thread is put into a wait state until one or all of the dispatcher objects are
set to the Signaled state.
<P>
Whenever a dispatcher object is set to the Signaled state, the Kernel changes
the state of any thread waiting on that object to <I>ready</I>: the thread
will be scheduled to run according to its current runtime priority and the
current availability of processor(s) for any thread with that priority.
Synchronization events and synchronization timers are exceptions to this rule;
when a synchronization event or timer is signaled, only one waiting thread is
set to the ready state.
<P>
Some NT drivers create their own driver- or device-dedicated system threads
and set their thread’s base priority to the lowest real-time priority value.
Other highest-level drivers, particularly NT file system drivers, use system
worker threads with a base priority that is usually set to the highest
variable priority value. The Kernel schedules a thread with the lowest
real-time priority to run ahead of every thread with a variable priority,
which includes almost every user-mode thread in the system.
<P>
Most standard NT driver routines are run in an arbitrary thread context, ahead
of all threads that are currently in the ready state.
<P>
Threads, whatever their respective runtime priorities, are run at IRQL
PASSIVE_LEVEL. Many standard NT driver routines are run at <I>raised IRQL</I>:
that is, at a hardware priority greater than PASSIVE_LEVEL, such as IRQL
DISPATCH_LEVEL or DIRQL.
<H5>Waiting on Dispatcher Objects in NT Drivers</H5>
<P>
For most NT device and intermediate drivers, the Kernel’s dispatcher objects
can be used for synchronization only in the following circumstances:
<UL>
<LI>
The <B>DriverEntry</B>, Reinitialize, Unload, or certain Dispatch routines are
run in the context of a system thread, so an NT driver can wait on a
dispatcher object within these routines.
<P>
<LI>
The Dispatch routines of a highest-level NT driver also are run in a
nonarbitrary thread context, usually that of a user-mode thread requesting an
I/O operation.
<P>
<LI>
Lower-level drivers’ Dispatch routines that initiate inherently synchronous
I/O operations, such as create, flush, shutdown, close, and some device I/O
control operations, also can wait on a dispatcher object for the completion of
the requested operation.
</UL>
<P>
However, lower-level drivers’ Dispatch routines cannot wait on a
Kernel-defined dispatcher object for the completion of an inherently
asynchronous I/O operation.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; NT miniport driver writers should consider the following a design guideline: </H5>
<P>
For portability, miniport drivers should not use kernel dispatcher objects.
Miniport drivers should call only <B>ScsiPort</B><I>Xxx</I>&nbsp;routines.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; NT driver writers should consider the following a design guideline: </H5>
<P>
An NT driver cannot and must not attempt to wait on a dispatcher object for
the completion of a transfer operation to or from a paging device.
<P>
In other words, NT driver Dispatch routines for read/write requests generally
cannot wait on a dispatcher object. A Dispatch routine for any device I/O
control request with an I/O control code whose transfer-type value is other
than METHOD_BUFFERED also cannot wait on a dispatcher object. For more
information about device-type-specific requests that NT drivers must support
and I/O control codes, see the <I>Kernel-Mode Driver Reference</I>.
<P>
Every other standard NT driver routine is run in an arbitrary thread context:
that of whatever thread happens to be current when the driver routine is
called to process an IRP or to handle a device interrupt. Moreover, most
standard driver routines are run at raised IRQL, either at DISPATCH_LEVEL, or
for device drivers, at DIRQL.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; NT driver designers should always keep in mind the following fact: </H5>
<P>
It is a <I>fatal </I>error to wait on a Kernel dispatcher object for a nonzero
interval at raised IRQL.
<P>
Driver Dispatch routines that initiate asynchronous I/O operations to a device
and all driver routines that run at raised IRQL cannot use dispatcher objects
to synchronize their processing of IRPs.
<P>
For a summary of the IRQLs at which standard NT driver routines run, see
Chapter 16.
<P>
Few NT device and intermediate drivers set up driver-created system threads.
Few highest-level NT device drivers use system worker threads, as NT FSDs
usually do. Consequently, most NT device and intermediate drivers can use a
dispatcher object only while the driver is initializing, unloading, or in a
Dispatch routine for a synchronous I/O request.
<P>
For example, the <B>DriverEntry</B>&nbsp;routines of the system’s NT SCSI class
drivers set up an event object so they can do the following:
<OL>
<LI>
Call <B>IoBuildSynchronousFsdRequest</B>&nbsp;with the pointer to the
driver-supplied storage for an initialized event object.
<P>
<LI>
Set up the IRP that this routine creates and send it with <B>IoCallDriver</B>
down to the NT SCSI port driver to request configuration information.
<P>
<LI>
Call <B>KeWaitForSingleObject</B>&nbsp;to wait on the event until the port driver
returns the IRP with <B>IoCompleteRequest</B>, which sets the associated event
to the Signaled state indicating that the requested configuration information
or an error status is available for the class driver.
</OL>
<P>
The following subsections describe the timer, event, semaphore, and mutex
dispatcher objects for driver writers who either design drivers with
device-dedicated threads and/or worker-thread callback routines, or who design
drivers that must wait on one or more dispatcher objects in their <B>DriverEntry</B>,
Reinitialize, Unload, or Dispatch routines for synchronous I/O operations.
<P>
Any driver that waits on a dispatcher object in its <B>DriverEntry</B>,
Reinitialize, or Unload routine runs in a system thread context. In effect,
any driver that waits on a dispatcher object in its Dispatch routine for a
synchronous I/O operation steals cycles from an arbitrary thread’s quantum.
<P>
For simplicity, the following subsections illustrate calls to <B>KeWaitForSingleObject</B>.
For more information about <B>KeWaitForMutexObject</B>&nbsp;and <B>KeWaitForMultipleObjects</B>,
see the <I>Kernel-Mode Driver Reference</I>.
<P></FONT>
</BODY>
</HTML>
