<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.4.1  Naming Device Objects</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Naming_Device_Objects_KG"></A>4.4.1  Naming Device Objects</H3>
<P>
NT drivers’ device objects have names for two basic reasons:
<UL>
<LI>
So that higher-level NT drivers can layer themselves over lower-level NT
drivers
<P>
The DriverEntry routine of each higher-level NT driver must pass a pointer to
the name of the next-lower-level driver’s device object when it calls <B>IoGetDeviceObjectPointer</B>
or <B>IoAttachDevice</B>. NT drivers at every level should name their device
objects to support the addition of value-added, higher-level NT drivers. 
<P>
<LI>
So that user-mode applications can carry out I/O operations
<P>
Any driver of a physical, logical, or virtual device to which user-mode code
can direct I/O requests must name the device object it creates. For example,
when an application or end user calls a Win32&reg; function to connect to a
printer port, such as LPT1, the Win32 subsystem translates the application I/O
request into a call to one of the NT I/O Manager’s system services with the
name of a file object that represents the printer port. 
<P>
Such a named file object has an associated symbolic link object in the Win32
namespace, <B>\??</B>, that aliases the Win32 name to the name of the
appropriate device object in the NT namespace for device objects. The NT
Object Manager and I/O Manager parse the input file object name and chase the
symbolic link to identify the target device for the I/O operation. Then, the
I/O Manager sets up an IRP for the system parallel class driver. 
</UL>
<P>
The system uses a simple naming scheme to identify the NT devices in every
machine. In general, each device object that can be the target of an I/O
request or can be connected to by a higher-level NT driver has a name of the
form: 
<DL>
<DT>
<B>\Device\</B><I>GenericDeviceTypeDigit</I>
<DD>
where
<P>
<I>GenericDeviceType</I>&nbsp;indicates the kind of device, such as Harddisk,
Serial, Tape, etc.
<DL>
<DT>
and
<DD>
The <I>Digit</I>&nbsp;suffix indicates the zero-based number of this device,
depending on how many other devices of the same type have already been named.
</DL>
</DL>
<P>
Every NT driver must follow these naming conventions for device objects. 
<P>
Note that each <I>GenericDeviceType</I>&nbsp;guarantees that all device objects
representing a particular type of device have the same name, so NT
higher-level drivers can readily find device objects representing the set of
underlying physical devices over which such a higher-level driver can layer
itself. Note also that the <I>Digit</I>&nbsp;suffix guarantees that each device
object of that type has a unique name in every Windows NT machine. For more
information about how to assign an appropriate <I>Digit</I>&nbsp;suffix to a named
device object, see also the section on using the registry in Chapter 16. 
<P>
The DriverEntry routine is responsible for setting up a unique-to-the-machine
Unicode string to name each device object that an NT driver creates, except
for any device object that cannot be a target for an I/O request or that
cannot be connected to by a higher-level driver. 
<P></FONT>
</BODY>
</HTML>
