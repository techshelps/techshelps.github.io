<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.7  Handling Removable Media</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Handling_Removable_Media_KG"></A>16.7  Handling Removable Media</H2>
<P>
NT file systems and removable-media device drivers share the responsibility
for ensuring that the correct media is mounted when a file is opened on a
removable-media device and that the correct media remains mounted during
operations that access the media. Any NT intermediate driver layered between
such a file system and removable-media device driver also shares this
responsiblity. 
<H5>Responding to FS-Initiated Check-Verify Requests</H5>
<P>
At its discretion, the file system can send an IRP to the device driver’s
Dispatch entry point for IRP_MJ_DEVICE_CONTROL requests with <B>Parameters.DeviceIoControl.IoControlCode</B>
in the I/O stack location set to the following: 
<DL>
<DT>
IOCTL_<I>XXX</I>_CHECK_VERIFY
<DD>
where<I>&nbsp;XXX</I>&nbsp; is the type of device, such as DISK, TAPE, or CDROM. 
<P>
The type DISK includes both unpartitionable (floppy) and partitionable
removable-media devices. 
</DL>
<P>
If the underlying device driver determines that the media has not changed, the
driver should complete the IRP, returning the <B>IoStatus</B>&nbsp;block with the
following values: 
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>Status</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
set to STATUS_SUCCESS 
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>Information</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
set to zero 
</FONT></TABLE>
<P>
In addition, if the device type is DISK or CDROM and the caller specified an output buffer, the driver returns the media change count in the buffer at <BR>
<B>Irp-&gt;AssociatedSystemBuffer</B>&nbsp;and sets <B>IoStatus.Information</B>&nbsp;to <B>sizeof</B>(ULONG).
By returning this count the driver gives the caller an opportunity to
determine whether the media has changed from its perspective.
<P>
If the underlying device driver determines that the media has changed, it
should do the following:
<UL>
<LI>
If the volume is mounted (the VPB_MOUNTED flag is set in the VPB):
<P>
<OL>
<LI>
Set the <B>Flags</B>&nbsp;in the <B>DeviceObject</B>&nbsp;by ORing <B>Flags</B>&nbsp;with
DO_VERIFY_VOLUME.
<P>
<LI>
Set the IoStatus block in the IRP to the following:
<P>
<B>Status</B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATUS_VERIFY_REQUIRED
<P>
<B>Information</B>&nbsp; &nbsp; &nbsp; &nbsp; zero
</OL>
<P>
&nbsp; &nbsp; 3.&#09;Call <B>IoCompleteRequest</B>&nbsp;with the input IRP.
<P>
<LI>
If the volume is not mounted, the driver must not set the DO_VERIFY_VOLUME
bit. The driver should set <B>IoStatus.Status</B>&nbsp;to STATUS_IO_DEVICE_ERROR,
set <B>IoStatus.Information</B>&nbsp;to zero, and call <B>IoCompleteRequest</B>
with the IRP.
</UL>
<H5>Notifying the File System of Possible Media Changes</H5>
<P>
An NT removable-media device driver must ensure that the media is not changed
for the device represented by the <B>DeviceObject</B>&nbsp;(input to every driver
routine that is sent an IRP) whenever the driver processes an IRP that
requests a transfer to/from the media or a device I/O control operation that
affects the media. The best possible time to check for changed media is just
after the transition from a no-media-present state to a media-present state if
the physical device always notifies the driver about these state changes. 
<P>
If its physical device indicates that the state of the media might have
changed before the driver begins an I/O operation or during an operation, the
driver must do the following: 
<OL>
<LI>
Ensure that the volume is mounted by checking the VPB_MOUNTED flag in the VPB.
(If the volume is not mounted, the driver must not set the DO_VERIFY_VOLUME
bit. The driver should set <B>IoStatus.Status</B>&nbsp;to STATUS_VERIFY_REQUIRED,
set <B>IoStatus.Information</B>&nbsp;to zero, and call <B>IoCompleteRequest</B>
with the IRP.)
<P>
<LI>
Set the <B>Flags</B>&nbsp;in the <B>DeviceObject</B>&nbsp;by ORing <B>Flags</B>&nbsp;with
DO_VERIFY_VOLUME. 
<P>
<LI>
Set the <B>IoStatus</B>&nbsp;block in the IRP to the following: 
<P>
<B>Status</B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATUS_VERIFY_REQUIRED 
<P>
<B>Information</B>&nbsp; &nbsp; &nbsp; &nbsp; zero 
<P>
<LI>
Before completing any IRP with an <B>IoStatus</B>&nbsp;block in which the <B>Status</B>
field is not set to STATUS_SUCCESS, the driver must call <B>IoIsErrorUserInduced</B>,
which returns a Boolean TRUE for any of the following <B>Status</B>&nbsp;values: 
<P>
STATUS_VERIFY_REQUIRED <BR>
STATUS_NO_MEDIA_IN_DEVICE <BR>
STATUS_WRONG_VOLUME <BR>
STATUS_UNRECOGNIZED_MEDIA<BR>
STATUS_MEDIA_WRITE_PROTECTED <BR>
STATUS_IO_TIMEOUT <BR>
STATUS_DEVICE_NOT_READY 
<P>
If <B>IoIsErrorUserInduced</B>&nbsp;returns TRUE, the driver must call <B>IoSetHardErrorOrVerifyDevice</B>
so the FSD can send a popup to the user, who can then supply the correct
media, decide to retry the original request, or decide to cancel the requested
operation. 
</OL>
<H5>Checking the DeviceObject-&gt;Flags</H5>
<P>
For each IRP requesting an I/O operation to/from removable media, a
removable-media device driver must determine whether DO_VERIFY_VOLUME is
already set in its <B>DeviceObject-&gt;Flags</B>. If this value is set, the
driver must do the following:
<UL>
<LI>
For IRP_MJ_READ, IRP_MJ_WRITE, and certain IRP_MJ_DEVICE_CONTROL requests,
check whether the I/O stack location <B>Flags</B>&nbsp;is set with
SL_OVERRIDE_VERIFY_VOLUME. If it is, continue the requested operation.
<P>
Device control request that return information about the logical structure of
the underlying media have SL_OVERRIDE_VERIFY_VOLUME set in the I/O stack
location <B>Flags</B>&nbsp;when an IFS mounts or remounts a removable-media volume.
<P>
<LI>
Otherwise, the driver must refuse to carry out I/O requests for the
corresponding drive, device, or partition while DO_VERIFY_VOLUME is set in its
<B>DeviceObject-&gt;Flags</B>. A removable media driver must fail IRPs sent to
the corresponding device as described in the preceding subsection, repeating
both Steps 2 and 3 for each IRP until the FSD clears DO_VERIFY_VOLUME in the
removable-media driver’s <B>DeviceObject-&gt;Flags</B>. 
</UL>
<P>
Otherwise, if a removable-media device driver neglects to fail IRPs when
DO_VERIFY_VOLUME is set and SL_OVERRIDE_VERIFY_VOLUME is not set for the
preceding transfer requests, the file system can neither maintain the
integrity of cached file data nor cause the user to be prompted to remount the
media that holds an open file. 
<H5>Setting up IRPs in Intermediate Drivers</H5>
<P>
Any intermediate driver layered between an NT file system driver and a
removable-media device driver must set up the next-lower-level driver’s I/O
stack location in IRPs. From incoming IRP_MJ_READ, IRP_MJ_WRITE, and
IRP_MJ_DEVICE_CONTROL requests, such an intermediate driver must copy its own
I/O stack location <B>Flags</B>&nbsp;into the next-lower-level driver’s I/O stack
location when it sets up the I/O stack location for the lower driver. 
<P>
If such an intermediate driver allocates new IRPs for lower-level
removable-media drivers, it must set up the IRPs it allocates as follows:
<UL>
<LI>
For transfer requests, it must set up the thread context in each
driver-allocated IRP from the value at <B>Tail.Overlay.Thread</B>&nbsp;in the
original IRP.
<P>
<LI>
For IRP_MJ_READ, IRP_MJ_WRITE, and IRP_MJ_DEVICE_CONTROL requests, it must
copy the I/O stack location <B>Flags</B>&nbsp;from the original IRP to each
driver-allocated IRP.
</UL>
<P>
Otherwise, the file system can neither maintain the integrity of cached file
data nor cause the user to be prompted to remount the media that holds an open
file.
<P></FONT>
</BODY>
</HTML>
