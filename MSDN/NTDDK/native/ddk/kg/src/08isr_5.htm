<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>8.2  Basic ISR Functionality</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Basic_ISR_Functionality_KG"></A>8.2  Basic ISR Functionality</H2>
<P>
On entry, an ISR is given pointers to the driver’s interrupt object and a <I>ServiceContext</I>
pointer to whatever area the DriverEntry routine set up when it called <B>IoConnectInterrupt</B>.
Most NT device drivers set the <I>ServiceContext</I>&nbsp;pointer to their device
objects that represent physical devices that generate interrupts or to such a
device object’s device extension. Such a driver uses the device extension to
set up state information for the driver’s DpcForIsr routine, which usually
does almost all of the I/O processing to satisfy each request that caused the
device to interrupt. 
<P>
In NT device drivers that do not overlap device I/O operations, the ISR is
responsible for the following:
<OL>
<LI>
Determine whether the interrupt is spurious. If so, return FALSE immediately
so the ISR of the device that interrupted will be called promptly. Otherwise,
continue interrupt processing. 
<P>
<LI>
Stop the device from interrupting.
<P>
<LI>
Gather whatever context information the DpcForIsr (or CustomDpc) routine will
need to complete I/O processing for the current operation.
<P>
<LI>
Store this context in an area accessible to the DpcForIsr or CustomDpc
routine, usually in the device extension of the target device object for which
processing the current I/O request caused the interrupt. 
<P>
<LI>
If the driver has a DpcForIsr routine, call <B>IoRequestDpc</B>&nbsp;with pointers
to the current IRP, the target device object, and the saved context. <B>IoRequestDpc</B>
queues the DpcForIsr routine to be run as soon as IRQL falls below
DISPATCH_LEVEL on a processor.
<P>
If the driver has a CustomDpc routine, call <B>KeInsertQueueDpc</B>&nbsp;with a
pointer to the DPC object (associated with the CustomDpc routine) and
pointer(s) to any saved context the CustomDpc routine will need to complete
the operation. Usually, the ISR also passes pointers to the current IRP and
target device object. The CustomDpc routine is run as soon as IRQL falls below
DISPATCH_LEVEL on a processor. 
<P>
<LI>
Return TRUE to indicate that its device generated the interrupt. 
</OL>
<P>
In general, an ISR does no actual I/O processing to satisfy an IRP. Instead,
it stops its device from interrupting, sets up necessary state information,
and queues the driver’s DpcForIsr or CustomDpc to do whatever I/O processing
is necessary to satisfy the current request that caused the device to
interrupt. 
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>NT device driver writers
should consider the following an implementation guideline:<B>&nbsp;</B>
<P>
An ISR must run at DIRQL for the shortest possible interval. 
<P>
Following the preceding guideline increases I/O throughput for every device in
the machine because running at DIRQL masks off all interrupts to which the
system has assigned a lesser or equal IRQL value.
<P>
The <I>SynchronizeIrql</I>&nbsp;of the driver’s interrupt object(s), specified when
the driver called <B>IoConnectInterrupt</B>, determines the DIRQL at which a
device driver’s ISR and SynchCritSection routines are run. 
<P>
When an NT device driver’s StartIo (or other) routine calls <B>KeSynchronizeExecution</B>
with the driver’s SynchCritSection routine, the caller also passes the pointer
to the interrupt object(s) associated with the ISR. Consequently, interrupts
from the device are masked off on the processor running the SynchCritSection
routine. Meanwhile, <B>KeSynchronizeExecution</B>&nbsp;holds the spin lock
associated with the interrupt object(s) so that the ISR cannot access the
device registers or shared state in the device extension from another
processor until the driver’s SynchCritSection routine returns control. 
<P>
For more information about StartIo and SynchCritSection routines, see Chapters
7 and 10, respectively. For more information about how the caller of <B>KeSynchronizeExecution</B>
uses an interrupt spin lock, see also Chapter 16. 
<P></FONT>
</BODY>
</HTML>
