<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.5.2  Registering an ISR</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Registering_an_ISR_KG"></A>3.5.2  Registering an ISR</H3>
<P>
<A NAME="DDK_Figure_3.16_KG"></A>An NT device driver must call <B>IoConnectInterrupt</B>
when it initializes in order to register its ISR. Figure 3.16 illustrates this
call.
<P>
<B><IMG SRC="../art/3intobj.gif" BORDER=0></B>
<P>
<B>Figure 3.16    Setting Up Interrupt Objects</B>
<P>
As Figure 3.16 shows, when a device driver calls <B>IoConnectInterrupt</B>,
the I/O Manager calls the Kernel to set up the driver’s interrupt object(s):
<OL>
<LI>
Unless the ISR handles more than one interrupt vector for different devices,
the <B>DriverEntry</B>&nbsp;routine registers the ISR with the following
parameters:
<P>
<UL>
<LI>
A pointer to the driver’s storage area for the interrupt object pointer
returned by <B>IoConnectInterrupt</B>
<P>
<LI>
A NULL spin lock pointer, unless the driver itself has allocated storage for
and already initialized an InterruptSpinLock with <B>KeInitializeSpinLock</B>
<P>
<LI>
A pointer to the ServiceContext area the ISR will use when it is called and
the entry point for the ISR
<P>
<LI>
The (mapped) DeviceSystemVector obtained from <B>HalGetInterruptVector</B>
<P>
<LI>
The SystemDirql assigned to that vector for this machine, also obtained from <B>HalGetInterruptVector</B>
<P>
<LI>
The same IRQL value for the SynchronizeIrql parameter
<P>
<LI>
The ProcessorMask, indicating the set of processors on which the device can
interrupt in this machine, also obtained from <B>HalGetInterruptVector</B>
<P>
<LI>
Whether the interrupt mode is <B>LevelSensitive</B>&nbsp;or <B>Latched</B>
<P>
<LI>
Whether the device can share the vector
<P>
<LI>
Whether to save the floating-point registers when the device interrupts
</UL>
<P>
<LI>
The I/O Manager allocates sufficient resident memory for as many interrupt
objects as the input ProcessorMask indicates, which could be as many interrupt
objects as processors in SMP machines or could be a lesser number, depending
on the ProcessorMask. The I/O Manager also provides storage for an interrupt
spin lock and initializes it if the driver passes a NULL pointer to <B>IoConnectInterrupt</B>
(see Step 1).
<P>
<LI>
The I/O Manager calls <B>KeInitializeInterrupt</B>&nbsp;for each interrupt object.
<P>
<LI>
The I/O Manager also calls <B>KeConnectInterrupt</B>&nbsp;for each initialized
interrupt object to connect it to a particular processor on which the device
can interrupt in the machine. This call actually sets the given
DeviceSystemVector in the Kernel’s IDT for a particular processor, as hinted
in Figure 3.16.
<P>
<LI>
When all necessary interrupt object(s) have been initialized and connected on
the processor(s), <B>IoConnectInterrupt</B>&nbsp;returns a pointer to the set of
interrupt objects. NT driver routines must pass the returned
PointerToInterruptObject(s) in their calls to <B>KeSynchronizeExecution</B>.
<P>
<LI>
As Figure 3.16 shows, when a device interrupt occurs on a given processor, the
driver’s ISR is run on that processor at DIRQL and given a pointer to the
ServiceContext that was set up when the driver called <B>IoConnectInterrupt</B>.
</OL>
<P>
If an NT driver must handle interrupts from more than one device, each with a
different interrupt vector, it can have a single multivector ISR for all its
devices, or it can have more than one ISR, up to one for each vector. Such a
driver’s <B>DriverEntry</B>&nbsp;routine must register the ISR as follows:
<OL>
<LI>
The <B>DriverEntry</B>&nbsp;routine must call <B>KeInitializeSpinLock</B>&nbsp;with a
pointer to driver-provided storage for an InterruptSpinLock that must be in
resident memory (in a device extension, controller extension, or nonpaged pool
allocated by the driver).
<P>
<LI>
For each vector an ISR handles, the <B>DriverEntry</B>&nbsp;routine must call <B>HalGetInterruptVector</B>
and <B>IoConnectInterrupt</B>&nbsp;as described in Step 1, except for the following
parameters:
<P>
<UL>
<LI>
Such a driver must pass a pointer to its storage for an initialized
InterruptSpinLock, rather than a NULL spin lock pointer.
<P>
<LI>
Such a driver must specify a SynchronizeIrql value that is the highest
SystemDirql assigned to any device for which its ISR(s) handle interrupts.
</UL>
</OL>
<P>
The ISR(s) of such a driver must run at the highest DIRQL assigned to the
DeviceSystemVectors the driver handles, as must any driver-supplied
SynchCritSection routine that accesses device registers (or data) shared with
an ISR.
<P>
Because an ISR runs at a relatively high IRQL, it must return control as
quickly as possible. Consequently, an NT driver’s ISR should do as little I/O
processing as it can, usually the following:
<OL>
<LI>
Determine whether its device actually generated the interrupt and return FALSE
as soon as possible if it did not.
<P>
<LI>
Otherwise, stop the device from generating interrupts, save whatever context
is necessary about the operation that caused the interrupt, and queue a DPC to
complete the interrupt-driven I/O operation at a lower IRQL.
<P>
For more information about DPC objects, see <A HREF="03ntobj_26.htm">Section
3.6</A>, next.
</OL>
<P>
For more information about using an interrupt spin lock, <B>KeInitializeSpinLock</B>,
and <B>KeSynchronizeExecution</B>, see the section on spin locks in Chapter
16. For more information about ISRs and SynchCritSection routines, see also
Chapters 4, 8, and 10.
<P></FONT>
</BODY>
</HTML>
