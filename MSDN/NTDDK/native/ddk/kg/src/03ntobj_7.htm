<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.2.4.1  Using Buffered I/O</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Using_Buffered_I_O_KG"></A>3.2.4.1  Using Buffered I/O</H4>
<P>
<A NAME="DDK_Figure_3.3_KG"></A>Figure 3.3 illustrates how the I/O Manager sets up
an IRP requesting a transfer operation for drivers that OR their device
object(s)’<B>&nbsp;Flags</B>&nbsp;with DO_BUFFERED_IO.
<P>
<B><IMG SRC="../art/3mdlbffr.gif" BORDER=0></B>
<P>
<B>Figure 3.3    Buffered I/O for User Buffers</B>
<P>
As Figure 3.3 shows, some range of user-space virtual addresses represents the
current thread’s buffer, and that buffer’s contents might be stored somewhere
within a range of page-based physical addresses.
<P>
Figure 3.3 also shows an overview of how drivers can use the <B>SystemBuffer</B>
pointer in the IRP to transfer data for a read request, when a driver has ORed
the device object’s <B>Flags</B>&nbsp;with DO_BUFFERED_IO:
<OL>
<LI>
The I/O Manager services the current thread’s read request, for which the
thread passes a range of user-space virtual addresses representing a buffer.
<P>
<LI>
The I/O Manager checks the user-supplied buffer for accessibility and calls <B>ExAllocatePool</B>
to create a resident system-space buffer the size of the user-supplied buffer.
It provides access to the newly allocated <B>SystemBuffer</B>&nbsp;in the IRP it
sends to the driver.
<P>
If Figure 3.3 showed a write request, the I/O Manager would copy data from the
user buffer into the system buffer before it sent the IRP to the driver.
<P>
<LI>
For the read request shown in Figure 3.3, the driver reads data from the
device into the system-space buffer.
<P>
<LI>
When the driver has called <B>IoCompleteRequest</B>&nbsp;with the IRP and the
original thread is again current, the I/O Manager copies the read-in data from
the system buffer into the user buffer. It also calls <B>ExFreePool</B>&nbsp;to
release the system buffer and disposes of the IRP.
</OL>
<P>
After the I/O Manager has created a system-space buffer for the driver, the
requesting user-mode thread can be swapped out and its physical memory can be
reused by another thread, possibly by a thread belonging to another process.
However, the system-space virtual address range supplied in the IRP remains
valid until the driver calls <B>IoCompleteRequest</B>&nbsp;with the IRP.
<P>
NT drivers for devices that do not transfer large amounts of data at a time,
such as interactive devices, can use buffered I/O.
<P>
NT drivers that transfer large amounts of data at a time, in particular,
drivers that do multipage transfers, should not attempt to use buffered I/O.
As the system runs, nonpaged pool can become fragmented so that the I/O
Manager cannot allocate large, contiguous system-space buffers to send in IRPs
for such a driver.
<P>
Note that all NT drivers use buffered I/O for certain IRP_MJ_<I>XXX</I>. Even
NT drivers that set up their device objects for direct I/O use buffered I/O
for most requests except IRP_MJ_READ, IRP_MJ_WRITE, and, possibly,
driver-defined IRP_MJ_INTERNAL_DEVICE_CONTROL requests that require large data
transfers.
<P></FONT>
</BODY>
</HTML>
