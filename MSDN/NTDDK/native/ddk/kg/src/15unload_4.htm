<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.2  Unload Routine Functionality</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Unload_Routine_Functionality_KG"></A>15.2  Unload Routine Functionality</H2>
<P>
The input parameter to an Unload routine is a <I>DriverObject</I>&nbsp;pointer, as
shown by the declaration, to the driver object that the NT I/O Manager uses to
represent that driver’s load image.
<P>
Every NT driver’s calls to <B>IoCreateDevice</B>&nbsp;require the <I>DriverObject</I>
pointer that was input to its DriverEntry routine. Each successful call to <B>IoCreateDevice</B>
associates the newly created device object with the given driver object.
<P>
Consequently, an NT driver’s Unload routine can walk the chain of device
objects associated with the input <I>DriverObject</I>&nbsp;to release the resources
and objects that driver was using.
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>Consider the following
implementation guidelines for the Unload routines of NT drivers<B>&nbsp;</B>
<UL>
<LI>
An NT device driver <I>must</I>&nbsp;disable interrupts from its device if it is
possible to do so <I>before</I>&nbsp;its Unload routine releases the system objects
and resources the DriverEntry routine set up for processing I/O requests and
before its Unload routine frees any hardware resources that the DriverEntry
routine claimed for its physical device in the registry.
<P>
<LI>
Any NT driver’s Unload routine must ensure that no other driver routine is
currently using or might shortly be using a particular resource <I>before</I>
it releases that resource.
</UL>
<P>
While the NT I/O Manager does not continue to send IRPs to any driver after
its Unload routine has been called, disabling interrupts from the device
should be the first thing done by any device driver’s Unload routine if
possible. Otherwise, its ISR might be called to handle a device interrupt
while the Unload routine is executing and releasing resources in the device
extension that the ISR needs to handle the interrupt. Note that even if its
ISR runs successfully in these circumstances, the DpcForIsr or CustomDpc
routine that the ISR queues, and possibly other driver routines that run at
IRQL &gt;= DISPATCH_LEVEL, will execute before the Unload routine regains
control, thereby increasing the likelihood that the Unload routine has deleted
a resource that another driver routine references. For more information about
managing IRQLs in NT drivers, see Chapter 16.
<P>
Any Unload routine must release the resources an NT driver is using in stages.
However, the specifics of how any particular NT driver uses the registry, sets
up system objects and resources in its device extension(s), in any controller
extension, or in driver-allocated nonpaged pool varies from driver to driver.
<P>
A DriverEntry and Unload routine can sometimes share internal driver routines
that set up necessary parameters to allocate and release resources. For
example, a driver that sets up symbolic links between Win32&reg;-visible names
and the corresponding NT device object names for its devices might have a
common routine to construct Unicode string paths to the registry keys in the <B>\Registry..\DeviceMap</B>
tree where it stores configuration information about these aliases.
<P>
In general, an NT driver’s Unload routine releases all driver-allocated
resources in the following stages:
<OL>
<LI>
First, disable interrupts on any physical device(s), if possible, and then
call <B>IoDisconnectInterrupt</B>&nbsp;as soon as interrupts are disabled.
<P>
<LI>
Ensure that no other driver routine can reference the resources that the
Unload routine intends to release, such as calling <B>IoStopTimer</B>&nbsp;one or
more times to disable the driver’s IoTimer routine(s) for all associated
device objects, and so forth.
<P>
<LI>
Release certain system objects and resources that the DriverEntry routine set
up in the device extension of the device object(s) or in the controller
extension of the controller object, if any.
<P>
<UL>
<LI>
In particular, a device driver’s Unload routine <I>must</I>&nbsp;call <B>IoDisconnectInterrupt</B>
<I>before</I>&nbsp;it calls <B>IoDeleteDevice</B>&nbsp;or <B>IoDeleteController</B>&nbsp;to
free the interrupt object(s) pointer stored in the corresponding
device/controller extension by its DriverEntry routine.
<P>
<LI>
In particular, a higher-level driver’s Unload routine must call <B>ObDereferenceObject</B>
with the pointer to the next-lower driver’s file object if it called <B>IoGetDeviceObjectPointer</B>
and stored this pointer in a device or controller extension <I>before</I>&nbsp;it
calls <B>IoDeleteDevice</B>&nbsp;or <B>IoDeleteController</B>&nbsp;with its own device
or controller object.
<P>
<LI>
In particular, a higher-level driver’s Unload routine must call <B>IoDetachDevice</B>
with the pointer to the lower driver’s device object if it called <B>IoAttachDevice</B>
and stored this pointer in a device or controller extension <I>before</I>&nbsp;it
calls <B>IoDeleteDevice</B>&nbsp;or <B>IoDeleteController</B>&nbsp;with its own device
or controller object.
</UL>
<P>
<LI>
Free any hardware resources that the DriverEntry routine claimed for the
driver’s physical device(s), if any, in the registry under the <B>\Registry\Machine\Hardware\ResourceMap</B>
tree.
<P>
For more information about releasing hardware resource claims in the registry,
see Chapter 16. For specific information about <B>IoAssignResources</B>&nbsp;and <B>IoReportResourceUsage</B>,
see the <I>Kernel-Mode Driver Reference</I>.
<P>
<LI>
Deassign any symbolic links that the driver created, such as links between the
NT name for its device objects and the Win32-visible names for the same
devices and any other symbolic links set up with <B>IoCreateSymbolicLink</B>, <B>IoCreateUnprotectedSymbolicLink</B>
and/or <B>IoAssignArcName</B>&nbsp;in the DriverEntry routine.
<P>
The Unload routine should remove any names for its devices that the
DriverEntry routine stored in the registry under the <B>\Registry..\DeviceMap</B>
tree, as well.
<P>
<LI>
Delete each device object with <B>IoDeleteDevice</B>&nbsp;and any controller object
with <B>IoDeleteController</B>&nbsp;<I>after</I>&nbsp;freeing, as necessary, any
pointers to external objects or other resources that were stored in the device
and controller extensions.
<P>
If the DriverEntry routine called <B>IoGetConfigurationInformation</B>&nbsp;to
increment the count for a particular type of device, the Unload routine also
must call <B>IoGetConfigurationInformation</B>&nbsp;and decrements the count for
its devices in the I/O Manager’s global configuration information structure as
it deletes the corresponding device objects.
</OL>
<P>
In effect, an Unload routine must undo whatever the corresponding DriverEntry
and Reinitialize, if any, routine(s) did to initialize its physical device(s),
if any. An Unload routine must undo whatever the corresponding DriverEntry and
Reinitialize, if any, routine(s) did to allocate the resources the driver
needed to remain loaded and process IRPs.
<P>
Before it returns control, an Unload routine also is responsible for freeing
any other driver-allocated resources that have not yet been freed by other
driver routines.
<P>
&nbsp;
<P></FONT>
</BODY>
</HTML>
