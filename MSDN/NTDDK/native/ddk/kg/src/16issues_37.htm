<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.8.3.1  Calling IoReportResourceUsage</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Calling_IoReportResourceUsage_KG"></A>16.8.3.1  Calling IoReportResourceUsage</H4>
<P>
<A NAME="DDK_Figure_16..9_KG"></A>Figure 16.9 illustrates a device driver’s call
to <B>IoReportResourceUsage</B>.
<P>
<B><IMG SRC="../art/16rscnfg.gif" BORDER=0></B>
<P>
<B>Figure 16.9    Claiming Hardware Resources with IoReportResourceUsage</B>
<P>
As Figure 16.9 shows, each resource list that an NT driver writes into the
registry under <B>\Registry\Machine\Hardware\ResourceMap</B>&nbsp;is a
variable-sized array of CM_RESOURCE_DESCRIPTOR elements, containing the same
information in the same form as shown in <A HREF="16issues_34.htm#DDK_Figure_16..7_NG">Figure
16.7</A>.
<P>
In other words, values supplied for the driver or for each of its devices when
it calls <B>IoReportResourceUsage</B>&nbsp;must specify the same
CM_PARTIAL_RESOURCE_DESCRIPTOR <B>Port</B>, <B>Interrupt</B>, <B>Memory</B>,
and <B>Dma</B>&nbsp;“hardware” values obtained from the driver’s call(s) to <B>IoQueryDeviceDescription</B>
or by some other means.
<P>
A device driver frequently must supplement the information returned by <B>IoQueryDeviceDescription</B>,
particularly with <B>DeviceSpecificData</B>, for each of its devices. For
example, a floppy controller driver would fill in <B>DeviceSpecificData</B>
information about the maximum density and mount density for each of the floppy
drives it controlled, while a serial device driver would fill in information
about the maximum baud clock for each of its serial ports. The system defines <B>DeviceSpecificData</B>
structures for many kinds of peripheral devices, but an NT driver writer can
define a new structure for any new device driver.
<H5>Making Calls to IoReportResourceUsage</H5>
<P>
When it calls <B>IoReportResourceUsage</B>, an NT device driver must supply
the <I>OverrideConflict</I>&nbsp;and <I>ConflictDetected</I>&nbsp;parameters shown in <A HREF="#DDK_Figure_16..9_KG">Figure
16.9</A>. The driver also must supply nonNULL and nonzero values for at least one
of the following sets of parameters:
<UL>
<LI>
<I>DriverObject</I>, <I>DriverList</I>, and <I>DriverListSize</I>
<P>
<LI>
<I>DeviceObject</I>, <I>DeviceList</I>, and <I>DeviceListSize</I>
</UL>
<P>
In general, the resource descriptors at <I>DriverList</I>&nbsp;specify those
hardware resources that the driver uses in common for all its devices. The
resource descriptors at <I>DeviceList</I>&nbsp;specify those used for a particular
device. An NT driver must call <B>IoReportResourceUsage</B>&nbsp;more than once if
the physical devices it controls each use device-dedicated hardware resources
or if these physical devices do not have identical values for <B>DeviceSpecificData</B>.
<P>
While the <I>DriverClassName</I>&nbsp;parameter to <B>IoReportResourceUsage</B>&nbsp;can
be NULL, such a Unicode string determines whether the driver’s resource lists
are written under a registry key that is named according to the type of
device, such as <B>\Registry\Machine\Hardware\ResourceMap\Video</B>, or under
the default key (...<B>\Other</B>). If a named key already exists for a new
driver’s type of device, the driver writer should supply the appropriate
Unicode string at <I>DriverClassName</I>&nbsp;when that driver calls <B>IoReportResourceUsage</B>.
In addition, the driver writer should have the driver store its <B>\Registry\Machine\Hardware\DeviceMap</B>
information, if any, under the key with the same name.
<P>
The <I>DriverClassName</I>&nbsp;parameter is also passed in calls to <B>IoAssignResources</B>
and <B>HalAssignSlotResources</B>.
<P>
When an NT driver for an entirely new kind of peripheral device supplies a
unique string at <I>DriverClassName</I>, <B>IoReportResourceUsage</B>&nbsp;(as well
as <B>IoAssignResources</B>&nbsp;or <B>HalAssignSlotResources</B>) creates a new
key with that name in the registry. The designer of such a driver should
create a generic device-type name, and should use the same name for the
driver’s key, if it creates one, under <B>\Registry\Machine\Hardware\DeviceMap</B>.
<H5>Handling Resource Conflicts</H5>
<P>
The Boolean value returned to the driver at <I>ConflictDetected</I>&nbsp;indicates
whether it has attempted to claim a hardware resource that another device
driver already claimed. When such a hardware resource conflict occurs, the
driver that “found” the conflict should log an error, as described in <A HREF="16issues_20.htm">Section
16.6</A>.
<P>
If its device can be reconfigured dynamically, the driver that finds a
resource conflict can rebuild the offending resource list and call <B>IoReportResourceUsage</B>
again to overwrite its “conflicted” value entries under <B>\Registry\Machine\Hardware\ResourceMap</B>.
However, for the driver of such a device, calling <B>HalAssignSlotResources</B>
or <B>IoAssignResources</B>, as described in <A HREF="16issues_38.htm">Section
16.8.3.2</A>, is more efficient that calling <B>IoReportResourceUsage</B>
repeatedly to loop through a set of alternative resource lists.
<P>
The <I>OverrideConflict</I>&nbsp;parameter to <B>IoReportResourceUsage</B>&nbsp;is a
value of type BOOLEAN, which should be set to FALSE. If <B>IoReportResourceUsage</B>
detects a conflict and <I>OverrideConflict</I>&nbsp;was set to FALSE, this support
routine logs an error showing the exact cause of the conflict (memory
locations or interrupt) and which driver was not loaded due to the resource
conflict. <B>IoReportResourceUsage</B>&nbsp;does not write such a caller’s
resources into the registry, but a system administrator or user then can
determine why a particular device is not working by using the Win32 event
viewer to examine the entries in the NT error log file.
<P>
When <I>OverrideConflict</I>&nbsp;is set to TRUE in a call to <B>IoReportResourceUsage</B>,
the driver’s resource lists are written into the registry under the <B>\Registry\Machine\Hardware\ResourceMap</B>
key even if another driver has already claimed a resource in this driver’s
resource lists. If such a conflict exists, the driver that loads later does <I>not</I>
override the other driver’s claim on the hardware resource itself, nor does <B>IoReportResourceUsage</B>
log a resource-conflict error.
<H5>Releasing Resources</H5>
<P>
If <B>IoReportResourceUsage</B>&nbsp;returns TRUE at <I>ConflictDetected</I>&nbsp;and a
driver cannot carry out I/O operations without the specified hardware
resources, the DriverEntry routine must release every system resource it has
set up (free memory it has allocated, disconnect its interrupt objects, delete
its device objects, and so forth), because that driver will be unloaded when
its DriverEntry routine returns control, before the driver’s Reinitialize
routine, if any, is called.
<P>
When an NT driver’s Unload routine is called, it must call <B>IoReportResourceUsage</B>
one or more times with the <I>DriverList</I>&nbsp;and/or <I>DeviceList</I>
CM_RESOURCE_LIST in which the <B>Count</B>&nbsp;is set to zero or call <B>IoAssignResources</B>
with appropriate parameters, as described in <A HREF="16issues_38.htm">Section
16.8.3.2</A>. Such a call removes the driver’s resource list from the registry,
releasing the resource(s) it claimed in its DriverEntry routine. For more
information about the Unload routine, see Chapters 4 and 15.
<P></FONT>
</BODY>
</HTML>
