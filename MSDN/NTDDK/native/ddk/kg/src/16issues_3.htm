<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.2.1  Providing Storage for Spin Locks and Protected Data</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Providing_Storage_for_Spin_Locks_and_Protected_Data_KG"></A>16.2.1  Providing Storage for Spin Locks and Protected Data</H3>
<P>
When an NT driver is loaded, its DriverEntry routine must allocate resident
storage for any spin-lock-protected data or resources and for corresponding
spin locks in one of the following places: 
<UL>
<LI>
The device extension of a device object that the driver sets up by calling <B>IoCreateDevice
</B>
<P>
<LI>
The controller extension of a controller object that the driver sets up by
calling <B>IoCreateController </B>
<P>
<LI>
Nonpaged, system-space memory that the driver obtains by calling <B>ExAllocatePool
</B>
</UL>
<P>
Attempting to access pageable data while holding a spin lock causes a fatal
page fault if that page is not present. Referencing a spin lock that is
invalid (because it was stored in pageable memory and is currently paged-out)
also causes a fatal page fault. 
<P>
An NT driver must provide the storage for each of the following kinds of
executive spin lock it might use: 
<UL>
<LI>
Any spin lock used to synchronize access to driver-defined data by nonISR
driver routines that call <B>KeAcquireSpinLock</B>&nbsp;and <B>KeReleaseSpinLock</B>
or <B>KeAcquireSpinLockAtDpcLevel</B>&nbsp;and <B>KeReleaseSpinLockFromDpcLevel </B>
<P>
<LI>
Any spin lock used to synchronize access to a driver-allocated resource by
calling a resource-specific set of <B>ExInterlocked</B><I>Xxx</I>&nbsp;routines 
</UL>
<P>
While a driver can make calls to the <B>ExInterlocked..List</B>&nbsp;and/or <B>ExInterlocked..Zone</B>
routines from its ISR or SynchCritSection routines, it cannot call <B>KeAcquireSpinLock</B>
and <B>KeReleaseSpinLock</B>&nbsp;or <B>KeAcquireSpinLockAtDpcLevel</B>&nbsp;and <B>KeReleaseSpinLockFromDpcLevel</B>
while running at IRQL greater than DISPATCH_LEVEL. Consequently, any driver
that reuses a spin lock in calls to the <B>Ke..SpinLock</B>&nbsp;and <B>ExInterlocked</B><I>Xxx</I>
routines must make every call while running at IRQL &lt;= DISPATCH_LEVEL. 
<P>
Note that a driver can pass the same spin lock to <B>ExInterlockedInsertHeadList</B>
as it does to <B>ExInterlockedAllocateFromZone</B>. For more information about
how spin lock usage affects performance, see <A HREF="16issues_6.htm">Section
16.2.4</A>. For more information about using zone buffers, see <A HREF="16issues_16.htm">Section
16.4.3</A>. 
<P>
In addition to the storage for its executive spin locks, an NT device driver
must provide the storage for another spin lock to be associated with its
interrupt object(s) if it has a multivector ISR or more than one ISR. 
<P></FONT>
</BODY>
</HTML>
