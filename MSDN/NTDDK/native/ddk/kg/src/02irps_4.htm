<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>2.2.1  Points to Consider about Processing IRPs</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Points_to_Consider_about_Processing_IRPs_KG"></A>2.2.1  Points to Consider about Processing IRPs</H3>
<P>
Keep the following points in mind when designing an NT driver:
<UL>
<LI>
A new NT driver must handle the same set of IRP_MJ_<I>XXX</I>&nbsp;as any
system-supplied driver it replaces. The I/O Manager returns
STATUS_INVALID_DEVICE_REQUEST for a given I/O request to a target device if
its driver does not define an entry point for that IRP_MJ_<I>XXX</I>. A device
driver also must handle the same I/O control codes for IRP_MJ_DEVICE_CONTROL
requests as any system-supplied driver it replaces. In other words, a new NT
device driver must not “break applications” by implementing less functionality
than an existing driver for the same type of device.
<P>
<LI>
A new NT intermediate driver inserted into a chain of existing drivers should
recognize the same set of IRP_MJ_<I>XXX</I>&nbsp;as the driver it displaces. Such a
driver can simply pass on IRPs for those requests that it does not process to
the next-lower-level driver. However, a new NT intermediate driver must not
“break the chain” for drivers above and below it by neglecting to define an
entry point for an IRP_MJ_<I>XXX</I>&nbsp;request that the newly displaced,
next-lower-level driver does handle.
<P>
<LI>
A lowest-level device driver can access only its own I/O stack location in any
IRP that it is sent. A higher-level driver can access only its own and the
next-lower-level driver’s I/O stack locations in any IRP that it is sent.
<P>
<LI>
Every NT driver communicates information to higher-level drivers (and
ultimately, to user-mode applications via the I/O Manager) <I>only</I>&nbsp;in the
I/O status blocks of IRPs because the I/O Manager zeros the corresponding I/O
stack location as each driver in a chain completes an IRP. Any new NT driver
that attempts to implement back-door communication with a particular higher
(or lower) driver compromises its portability and its interoperability with
other NT drivers from one Windows NT platform or version to the next.
<P>
<LI>
A pair of NT drivers can define a set of device-specific (also called <I>private</I>)
I/O control codes for IRP_MJ_INTERNAL_DEVICE_CONTROL requests that the higher
of the pair can send down to the lower of the pair. However, such a pair of
drivers must follow all of the preceding guidelines if they are to remain
portable and interoperable with other NT drivers from one Windows NT platform
or version to another. If you design a pair of NT drivers with such a private
interface, consider the set of I/O control codes to be defined carefully. Make
them as generally useful as possible and design your paired drivers to follow
the preceding guidelines, so that you (or someone else) can reuse, replace, or
displace either or both of your new drivers easily as they migrate from one
Windows NT platform or version to another.
</UL>
<P></FONT>
</BODY>
</HTML>
