<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.4.1.2  Setting up MDLs for Partial Transfer Requests</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Setting_up_MDLs_for_Partial_Transfer_Requests_KG"></A>16.4.1.2  Setting up MDLs for Partial Transfer Requests</H4>
<P>
If a transfer request is too large for the underlying device driver to handle,
a higher-level driver can call <B>IoBuildPartialMdl</B>&nbsp;and set up a sequence
of partial-transfer IRPs for the underlying device driver(s). 
<P>
If a highest-level driver cannot lock down the entire user buffer with <B>MmProbeAndLockPages</B>
in a machine with limited memory, the original request also must be split into
partial transfers. For such a large transfer request, a highest-level driver
can do the following: 
<OL>
<LI>
Call <B>IoBuildSynchronousFsdRequest</B>&nbsp;to allocate a partial-transfer IRP
and lock down a portion, which is usually a multiple of PAGE_SIZE or sized to
suit the underlying device’s transfer capacity, of the user buffer. 
<P>
<LI>
Call <B>IoCallDriver</B>&nbsp;with the partial-transfer IRP and <B>KeWaitForSingleObject</B>
to wait on the event object that the driver set up to be associated with its
partial-transfer IRP if lower driver(s) return STATUS_PENDING. 
<P>
<LI>
When it regains control, repeat Steps 1 and 2 until all the data has been
transferred, and, then, complete the original IRP. 
</OL>
<P>
A highest-level device driver that must handle very large transfer requests
can use the preceding technique and simply call itself with the
partial-transfer IRPs it allocates. As an alternative, such a highest-level
device driver can do the following: 
<OL>
<LI>
Call <B>IoAllocateMdl</B>&nbsp;to allocate an MDL describing a portion of the user
buffer. 
<P>
<LI>
Call <B>MmProbeAndLockPages</B>&nbsp;to lock down that portion of the user buffer. 
<P>
<LI>
Transfer the data for that portion of the buffer. 
<P>
<LI>
Call <B>MmUnlockPages</B>&nbsp;and do either of the following: 
<P>
<UL>
<LI>
If the MDL that the driver allocated in Step 1 is large enough for the next
piece of the transfer, call <B>MmPrepareMdlForReuse</B>&nbsp;and, then, repeat
Steps 2 through 4.
<P>
<LI>
Otherwise, call <B>IoFreeMdl</B>&nbsp;and repeat Steps 1 through 4. 
</UL>
<P>
<LI>
Call <B>MmUnlockPages</B>&nbsp;and <B>IoFreeMdl</B>&nbsp;when all the data has been
transferred. 
</OL>
<P></FONT>
</BODY>
</HTML>
