<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.4.1.3  Allocating System-Space Memory</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Allocating_System_Space_Memory_KG"></A>16.4.1.3  Allocating System-Space Memory</H4>
<P>
The system-space virtual memory shown in <A HREF="16issues_10.htm#DDK_Figure_16..3_NG">Figure
16.3</A>&nbsp;consists of a limited amount of <I>paged pool</I>&nbsp;and an even more
limited amount of <I>nonpaged pool</I>. 
<P>
Nonpaged pool is guaranteed to be resident at all times. Consequently, it can
be accessed safely while running at any IRQL. 
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; For NT drivers, paged pool can be allocated and accessed only under the following condition: </H5>
<P>
The routine using the corresponding paged-pool virtual addresses <I>must</I>
be running at IRQL &lt;= APC_LEVEL. As mentioned in <A HREF="16issues_1.htm">Section
16.1</A>, if a page fault occurs while running at IRQL &gt; APC_LEVEL, it is a
fatal error. 
<P>
Except during their initialization or, possibly, while unloading, NT device
and intermediate drivers seldom allocate memory from paged pool because these
types of drivers so frequently run at IRQL greater than APC_LEVEL. Any
pageable storage that such a driver allocates cannot be accessed safely except
by driver-created threads or by the DriverEntry, Reinitialize (if any), and
Unload (if any) routines, which can use paged pool allocations to contain
data, objects, and resources needed only during initialization or while
unloading. 
<P>
Since several standard NT driver routines run at an IRQL higher than
APC_LEVEL, memory allocated from paged pool is inaccessible to most of an NT
intermediate or device driver’s routines. For example, higher-level drivers’
IoCompletion routines execute in an arbitrary thread context, usually at
DISPATCH_LEVEL IRQL. Such a driver should never allocate pageable storage for
data to be accessed from an IoCompletion routine. For more information about
the IRQLs at which standard driver routines execute, see <A HREF="16issues_1.htm">Section
16.1</A>. 
<P>
For specific information about any of the support routines mentioned in this
section, see also the <I>Kernel-Mode Driver Reference</I>.
<H5>Allocating Driver Buffer Space</H5>
<P>
For an I/O buffer space, an NT driver can call <B>MmAllocateNonCachedMemory</B>,<B>
MmAllocateContiguousMemory</B>,<B>&nbsp;HalAllocateCommonBuffer</B>&nbsp;if the driver’s
device uses busmaster DMA or a system DMA controller’s autoinitialize mode, or
<B>ExAllocatePool</B>. 
<P>
Nonpaged pool tends to become fragmented as the system runs, so an NT driver’s
DriverEntry routine should call these routines to set up any long-term I/O
buffers the driver needs. Each of these routines, except possibly <B>ExAllocatePool</B>,
allocates memory that is aligned on a processor-specific boundary (determined
by the processor’s data-cache-line size) to prevent cache and coherency
problems. 
<P>
NT drivers should allocate their internal I/O buffers, if any, as economically
as possible because nonpaged pool memory is a limited system resource. In
general, a DriverEntry routine should avoid calling these support routines
repeatedly to request allocations of less than PAGE_SIZE. 
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; In particular, driver writers should consider the following facts in order to allocate I/O buffer memory economically: </H5>
<UL>
<LI>
Each call to <B>MmAllocateNonCachedMemory</B>&nbsp;ties up at least a full page of
nonpaged system-space memory, whatever the size of the requested allocation.
For requests less than a page, any remainder bytes on the page are wasted:
inaccessible by the driver that called <B>MmAllocateNonCachedMemory</B>&nbsp;and
unusable by other kernel-mode code. 
<P>
<LI>
Each call to <B>MmAllocateContiguousMemory</B>&nbsp;allocates up to a page if the
specified number of bytes is less than or equal to a page. For requests
greater than a page, any remainder bytes on the last-allocated page are
wasted: inaccessible to the driver that called <B>MmAllocateContiguousMemory</B>
and unusable by other kernel-mode code. 
<P>
<LI>
Each call to <B>HalAllocateCommonBuffer</B>&nbsp;uses at least one adapter object
map register, which maps at least one byte and at most one page. For more
information about map registers and using common buffers, see the section on
adapter objects in Chapter 3. 
</UL>
<H5>Allocating Memory with ExAllocatePool or ExAllocatePoolWithTag</H5>
<P>
NT drivers also can call <B>ExAllocatePool</B>&nbsp;or <B>ExAllocatePoolWithTag</B>,
specifying one of the following system-defined values for the <I>PoolType</I>
parameter: 
<UL>
<LI>
<B>NonPagedPoolCacheAligned</B>&nbsp;for a permanent I/O buffer the driver uses,
such as a SCSI class driver’s buffer for request-sense data 
<P>
Note that such a driver could call <B>MmAllocateNonCachedMemory</B>&nbsp;or <B>MmAllocateContiguousMemory</B>
instead. 
<P>
<LI>
<B>NonPagedPoolCacheAlignedMustS</B>&nbsp;for a temporary, but critically
important, I/O buffer, such as a buffer containing initialization data for a
physical device that must be present for the system to boot 
<P>
<LI>
<B>NonPagedPool</B>&nbsp;for any objects or resources not stored in a device
extension or controller extension that the driver might access while running
at IRQL &gt; APC_LEVEL 
<P>
For this <I>PoolType</I>&nbsp;value, <B>ExAllocatePool</B>&nbsp;or <B>ExAllocatePoolWithTag</B>
allocates exactly the amount of memory requested if the specified <I>NumberOfBytes</I>
is less than or equal to PAGE_SIZE. Otherwise, any remainder bytes on the
last-allocated page are wasted: inaccessible to the caller and unusable by
other kernel-mode code.
<P>
For example, on an x86, an allocation request of 5K returns two 4K pages. The
last 3K of the second page is unavailable to the caller or another caller. To
avoid wasting nonpaged pool, a driver writer should design the driver to use a
multipage allocation efficiently, such as making two allocations,, one for
PAGE_SIZE and the other for 1K to allocate a total of 5K.
<P>
<LI>
<B>NonPagedPoolMustSucceed</B>&nbsp;for a temporary, but critically important,
storage area, that the driver will release as soon as possible, such as memory
that a driver needs to correct an error condition because it would corrupt the
system otherwise 
<P>
<LI>
<B>PagedPoolCacheAligned</B>&nbsp;for a file system driver’s I/O buffer that it
locks down and passes in an IRP requesting a DMA transfer by an underlying
mass-storage device driver 
<P>
<LI>
<B>PagedPool</B>&nbsp;for a temporary buffer, used by the DriverEntry or
Reinitialize routine to contain objects, data, or resources necessary for
initialization, if the buffer will be released before the caller returns, or
for a storage area that will be accessed only by one or more driver-created
threads 
<P>
An NT driver’s Unload routine also can allocate memory from paged pool if the
buffer will be released before the Unload routine returns control. 
</UL>
<P>
Because the must-succeed pool is a very limited system resource, allocations
must be released by calling <B>ExFreePool</B>&nbsp;as soon as possible. Most NT
drivers should <I>not</I>&nbsp;call <B>ExAllocatePool</B>&nbsp;or <B>ExAllocatePoolWithTag</B>
with the <I>PoolType</I>&nbsp;values <B>NonPagedPoolMustSucceed</B>&nbsp;or <B>NonPagedPoolCacheAlignedMustS</B>,
unless the system cannot continue to run if the driver’s allocation request
does not succeed. For these <I>PoolType</I>&nbsp;specifications, <B>ExAllocatePool</B>
brings down the system if it cannot allocate the requested memory. 
<P>
For all other <I>PoolType</I>&nbsp;specifications, <B>ExAllocatePool</B>&nbsp;or <B>ExAllocatePoolWithTag</B>
returns a NULL pointer if it cannot allocate the requested <I>NumberOfBytes</I>.
NT drivers should always check the pointer returned by <B>ExAllocatePool</B>
or <B>ExAllocatePoolWithTag</B>. If its value is NULL, the DriverEntry routine
(or any other driver routine that returns NTSTATUS) should return
STATUS_INSUFFICIENT_RESOURCES or handle the error condition if possible. For
more information about handling I/O errors, see <A HREF="16issues_20.htm">Section
16.6</A>. 
<P>
For the <B>CacheAligned</B>&nbsp;<I>PoolType</I>&nbsp;specifications, <B>ExAllocatePool</B>
or <B>ExAllocatePoolWithTag</B>&nbsp;allocates memory that is aligned on a
processor-specific boundary (determined by the processor’s data-cache-line
size) to prevent cache and coherency problems. 
<P></FONT>
</BODY>
</HTML>
