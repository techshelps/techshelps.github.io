<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>9.2  DpcForIsr and CustomDpc Functionality</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_DpcForIsr_and_CustomDpc_Functionality_KG"></A>9.2  DpcForIsr and CustomDpc Functionality</H2>
<P>
In addition to the basic responsibilities of these routines, already mentioned
in <A HREF="09dpc_3.htm">Sections 9.1.2</A>&nbsp;and <A HREF="09dpc_4.htm">9.1.3</A>,
every DpcForIsr or CustomDpc routine is responsible for using ISR-provided
context to complete one or more interrupt-driven I/O operations. 
<P>
In other words, besides ensuring that the next device I/O operation is started
promptly and completing the current IRP, the work done by any DpcForIsr or
CustomDpc routine depends on the driver’s design and/or on the nature of its
device. 
<P>
For example, the DpcForIsr or CustomDpc routine also can do any of the
following in order to complete an interrupt-driven I/O operation:
<UL>
<LI>
Retry an operation that has timed out or failed. 
<P>
<LI>
Call <B>IoAllocateErrorLogEntry</B>, set up an error log packet to report a
device I/O error, and call <B>IoWriteErrorLogEntry</B>. 
<P>
For more information about handling I/O errors, see Chapter 16.
<P>
<LI>
If the driver uses buffered I/O or the current IRP requests a device control
operation, transfer data read in from the device to the system buffer at <B>Irp-&gt;AssociatedIrp.SystemBuffer</B>
before completing the current IRP. 
<P>
<LI>
If the driver uses direct I/O, save state about a just completed
partial-transfer operation, calculate the next partial-transfer range, and use
a driver-supplied SynchCritSection routine to program the device for the next
partial-transfer operation. 
<P>
Even a driver that uses buffered I/O might have to split up a transfer request
if its device has very limited transfer capabilities.
<P>
<LI>
If the driver uses packet-based DMA, call <B>IoFlushAdapterBuffers</B>&nbsp;after
each device transfer operation, and call <B>IoFreeAdapterChannel</B>&nbsp;or <B>IoFreeMapRegisters</B>
when a sequence of partial transfers is done and the full transfer request is
satisfied. 
<P>
If a requested transfer is only partly satisfied by a single DMA operation,
the DpcForIsr is usually responsible for setting up one or more DMA operations
until the current IRP’s requested <B>Length</B>&nbsp;(number of bytes) has been
fully transferred. 
<P>
For more information about using DMA, see Chapter 3. See also Chapter 11 for
more information about AdapterControl routines and Chapter 16 for more
information about maintaining cache coherency during DMA. 
<P>
<LI>
If the driver uses PIO, call <B>KeFlushIoBuffers</B>&nbsp;at the end of each device
transfer operation if the current IRP requests a read. 
<P>
If a requested transfer is only partly satisfied by a single PIO operation,
the DpcForIsr (or CustomDpc) is usually responsible for setting up one or more
transfer operations until the current IRP’s requested <B>Length</B>&nbsp;(number of
bytes) has been fully transferred. 
<P>
For more information about using PIO, see Chapter 3. See also Chapter 16 for
more information about maintaining processor cache coherency during PIO reads.
<P>
<LI>
If the driver has a ControllerControl routine, call <B>IoFreeController</B>
when a requested operation is complete. 
<P>
For more information about controller objects, see Chapter 3. For more
information about ControllerControl routines, see Chapter 11. 
</UL>
<P>
Note that an NT device driver’s DpcForIsr (or CustomDpc) routine usually does
most of the driver’s device I/O processing to satisfy IRPs. This routine also
shares some of the responsibility for queueing IRPs to the device with the
driver’s Dispatch routines. 
<H4><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; NT device driver writers should consider the following a general design guideline </H4>
<P>
Any DpcForIsr or CustomDpc routine should call <B>IoStartNextPacket</B>&nbsp;as
soon as it can safely make this call: that is, without possibly causing a
resource conflict or race condition with the driver’s StartIo routine or with
any other routine the StartIo routine causes to run. 
<P>
If a driver manages its own queueing of IRPs, its DpcForIsr or CustomDpc
routine should notify the driver as soon as it is safe to dequeue the next IRP
and to set up the device for the next request. 
<P>
A DpcForIsr or CustomDpc routine must call <B>IoStartNextPacket</B>, or
otherwise notify the appropriate driver routine when device I/O processing for
the next request can be started, before the DpcForIsr or CustomDpc returns
control. Depending on the driver and its device, this can occur well before
the DpcForIsr or CustomDpc routine completes the current IRP with <B>IoCompleteRequest</B>,
or it can occur immediately before this routine completes the current IRP and
returns control. 
<P></FONT>
</BODY>
</HTML>
