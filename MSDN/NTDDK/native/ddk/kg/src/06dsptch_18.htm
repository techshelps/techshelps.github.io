<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.3.2  DispatchReadWrite Using Direct I/O</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_DispatchReadWrite_Using_Direct_I_O_KG"></A>6.3.3.2  DispatchReadWrite Using Direct I/O</H4>
<P>
Any NT device driver that sets up its device objects for direct I/O satisfies
a read request by returning data transferred from its device to system
physical memory, which is described by the MDL at <B>Irp-&gt;MdlAddress</B>.
It satisfies a write request by transferring data from system physical memory
out to its device. 
<P>
As already mentioned in <A HREF="06dsptch_10.htm">Section
6.2.6</A>, lower-level NT drivers must handle read/write requests asynchronously.
Every NT device driver’s DispatchReadWrite routine <I>must</I>&nbsp;pass
IRP_MJ_READ and IRP_MJ_WRITE IRPs with valid parameters on to other driver
routines, as already described in <A HREF="06dsptch_8.htm">Section
6.2.4</A>. 
<P>
For all read/write IRPs sent to lower-level NT drivers, the paged physical
memory described by the MDL at <B>Irp-&gt;MdlAddress</B>&nbsp;has already been
probed for the correct access rights to carry out the requested transfer and
has already been locked down by the highest-level NT driver in the chain or by
the I/O Manager. Any intermediate or lowest-level NT driver that sets up its
device objects for direct I/O <I>should not</I>&nbsp; call <B>MmProbeAndLockPages</B>
because this has already been done.  Such a lowest-level driver calls <B>MmGetSystemAddressForMdl</B>
to get mapped system virtual addresses if its device uses PIO to transfer
data. 
<P>
Any intermediate or lowest-level device driver’s DispatchReadWrite routine
should perform sanity checks on the parameters in its I/O stack location of
read/write IRPs if it cannot trust a higher-level driver to pass down only
IRPs with valid parameters. If such a driver’s DispatchReadWrite routine finds
a parameter error in an incoming transfer IRP, it should complete the IRP with
an appropriate error STATUS_<I>XXX</I>&nbsp;value as already described in <A HREF="06dsptch_6.htm">Section
6.2.2</A>. Otherwise, such an intermediate driver’s DispatchReadWrite routine must
pass the request on for further processing, according to the guidelines in <A HREF="06dsptch_19.htm">Section
6.3.3.3</A>.
<P>
Any device driver’s DispatchReadWrite routine must call <B>IoMarkIrpPending</B>
with the transfer request, pass the IRP on for further processing by other
driver routines, and return STATUS_PENDING, as described in <A HREF="06dsptch_8.htm">Section
6.2.4</A>. Note that a device driver’s DispatchReadWrite routine can control the
order in which IRPs are queued to its device for faster I/O throughput by
calling <B>IoStartPacket</B>&nbsp;with a driver-determined <I>Key</I>&nbsp;value.
Another routine in the driver dequeues the IRP later, determines whether the
requested length must be split into partial-transfer operations, and programs
the device to transfer data. 
<P>
In general, an NT device driver that must split up large transfer requests to
suit the limitations of its device should postpone these operations until just
before setting up the device for a given transfer request. Such a device
driver’s DispatchReadWrite routine should not check the I/O stack location of
incoming IRPs for any device-specific transfer constraints, nor attempt to
calculate partial-transfer ranges, when the driver can postpone these checks
until just before its StartIo (or other driver routine) programs the device
for a transfer operation. 
<P></FONT>
</BODY>
</HTML>
