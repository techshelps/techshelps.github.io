<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>2.3.2  Driver Object Entry Points</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Driver_Object_Entry_Points_KG"></A>2.3.2  Driver Object Entry Points</H3>
<P>
Except for video and SCSI miniport drivers, as explained later in <A HREF="02irps_10.htm">Section
2.4</A>, each NT driver must define the following entry points in its driver
object:
<UL>
<LI>
At least one Dispatch entry point in order to get IRPs requesting I/O
operations
<P>
<LI>
If the driver can be loaded and/or replaced dynamically, an Unload entry point
in order to free any resources that the driver has allocated before the driver
is unloaded
<P>
NT drivers that cannot be replaced while the system is running, such as a
keyboard driver, need not supply an Unload routine.
</UL>
<P>
While an NT device driver is not required to define a StartIo entry point if
it is designed to set up and manage its own queue(s) of IRPs, most NT device
drivers define a StartIo entry point in their driver objects and rely on the
I/O Manager to queue IRPs bound for their StartIo routines. In fact, few
lowest-level system-supplied drivers are designed without a StartIo routine,
even when they set up and maintain their own supplemental queues for IRPs.
<P>
Higher-level NT drivers can have a StartIo routine but, for better
performance, seldom do. Instead, most NT file system drivers set up and
maintain internal queues of IRPs. Other higher-level NT drivers either have
internal queues for IRPs or simply pass IRPs on to lower drivers from their
Dispatch routines after setting up the I/O stack location for the next-lower
driver in each IRP, and, possibly, setting up the higher-level driver’s
IoCompletion routine for a given IRP.
<DL>
<DT>
When an NT driver’s DriverEntry routine is called, it sets Dispatch, StartIo
(if any), and Unload (if any) entry points directly in the driver object as
follows:
<DD>
<PRE><FONT FACE="Courier" SIZE="2">DriverObject-&gt;MajorFunction[IRP_MJ_xxx] = DDDispatchXxx; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :    : 
DriverObject-&gt;MajorFunction[IRP_MJ_yyy] = DDDispatchYyy; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :    : 
DriverObject-&gt;DriverStartIo = DDStartIo; 
DriverObject-&gt;DriverUnload = DDUnload; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :    : 
&nbsp;</FONT></PRE>
</DL>
<P>
An NT driver can define several Dispatch entry points, but it can define only
one StartIo entry point and one Unload entry point in its driver object. At
the driver writer’s discretion, an NT driver writer can implement one or more
Dispatch routines and define corresponding entry points in the driver object
as any one of the following:
<UL>
<LI>
A single Dispatch entry point for all IRP_MJ_<I>XXX</I>&nbsp;the driver handles
<P>
<LI>
A set of Dispatch entry points for nonintersecting subsets of all IRP_MJ_<I>XXX</I>
the driver handles
<P>
<LI>
A separate Dispatch entry point for each IRP_MJ_<I>XXX</I>&nbsp;the driver handles
</UL>
<P></FONT>
</BODY>
</HTML>
