<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.4.2  Allocating the Controller Object for I/O Operations</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Allocating_the_Controller_Object_for_I_O_Operations_KG"></A>3.4.2  Allocating the Controller Object for I/O Operations</H3>
<P>
<A NAME="DDK_Figure_3.14_KG"></A>After a driver that uses a controller object has
initialized, it is ready to process IRPs sent to its target device objects.
Whenever the current IRP requires the driver to program the physical device
represented by the controller object for an I/O operation, the driver calls <B>IoAllocateController</B>.
Figure 3.14 illustrates such a call.
<P>
<B><IMG SRC="../art/3ctlaloc.gif" BORDER=0></B>
<P>
<B>Figure 3.14    Allocating a Controller Object for I/O</B>
<P>
As Figure 3.14 shows, a driver must supply more than the <I>ControllerObject</I>
pointer that was returned by <B>IoCreateController</B>&nbsp;when it calls <B>IoAllocateController</B>.
Along with this pointer, it must pass pointers to the device object
representing the target of the current I/O request, to a driver-supplied
ControllerControl routine, and to whatever <I>Context</I>&nbsp;its
ControllerControl routine will need to set up the device for the requested I/O
operation.
<P>
<B>IoAllocateController</B>&nbsp;queues the driver-supplied ControllerControl
routine if the device represented by the controller object is already busy
doing I/O for a target device object. Otherwise, the ControllerControl routine
is called immediately with the input parameters shown in Figure 3.14. The
input <I>Context</I>&nbsp;pointer to <B>IoAllocateController</B>&nbsp;is passed to the
driver’s ControllerControl routine when it is run.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Consider the following design guidelines to determine the location of such a context area: </H5>
<UL>
<LI>
The driver-supplied context area should <I>not</I>&nbsp;be in the controller
extension unless the driver processes each IRP to completion before starting
another operation on the physical controller. Otherwise, a context area in the
controller extension could be overwritten by other driver routines or on
receipt of a new IRP.
<P>
<LI>
Even if the driver overlaps a device I/O operation for another device object,
a context area in the device extension of the target device object cannot be
overwritten.
<P>
<LI>
If another I/O request is made for a particular device object and the driver
has a StartIo routine, a context area in its device extension also cannot be
overwritten because the incoming IRP will be queued when the driver calls <B>IoStartPacket</B>
and the same IRP will remain in the device queue until the driver calls <B>IoStartNextPacket</B>
just before it completes the current IRP for that device object.
</UL>
<P>
The I/O Manager passes a pointer to the <I>DeviceObject</I><B>-&gt;CurrentIrp</B>
to a ControllerControl routine if the driver has a StartIo routine. If, like
the system-supplied floppy driver described in Chapter 2, a driver manages its
own queuing of IRPs instead of having a StartIo routine, the I/O Manager
cannot give the ControllerControl routine a pointer to the current IRP. When
it calls <B>IoAllocateController</B>, such a driver should include the current
IRP as part of the <I>Context</I>-accessible data it passes.
<P>
The driver routine that calls <B>IoAllocateController</B>&nbsp;must be executing at
IRQL DISPATCH_LEVEL when the call occurs. A driver that makes this call from
its StartIo routine is already running at DISPATCH_LEVEL. For more information
about the IRQLs at which NT drivers’ standard routines execute, see Chapters 5
through 15 or the section on managing IRQLs in Chapter 16. For more
information about support-routine-specific IRQL requirements, see the <I>Kernel-Mode
Driver Reference</I>.
<P>
The ControllerControl routine sets up the physical controller for the IRP’s
requested operation.
<P>
As shown in Figure 3.14, the ControllerControl routine returns a value of type
IO_ALLOCATION_ACTION, which can be either of the following system-defined
values:
<UL>
<LI>
If the ControllerControl routine can start another operation on the physical
controller, it should return <B>DeallocateObject</B>&nbsp;so the driver can overlap
the next requested I/O operation.
<P>
For example, if the ControllerControl routine can program a disk controller
for a seek operation on one disk, complete that IRP, and return <B>DeallocateObject</B>,
the ControllerControl routine can be called again to program the disk
controller for a transfer operation on the other disk if any transfer requests
currently are queued to the other disk.
<P>
<LI>
If the current IRP requires further processing by other driver routines, the
ControllerControl routine must return <B>KeepObject</B>.
<P>
For example, if the driver programs a disk controller for a transfer operation
but cannot complete the IRP until the transfer is complete, the
ControllerControl routine must return <B>KeepObject</B>.
</UL>
<P>
When a ControllerControl routine returns <B>KeepObject</B>, usually the
driver’s ISR runs when the device interrupts, and its DpcForIsr routine
completes the I/O operation and the current IRP for the target device object.
<P>
Whenever the ControllerControl routine returns <B>KeepObject</B>, the routine
that completes the IRP must call <B>IoFreeController</B>. Such a driver
routine should call <B>IoFreeController</B>&nbsp;as soon as possible so that its
next device I/O operation can be set up promptly.
<P></FONT>
</BODY>
</HTML>
