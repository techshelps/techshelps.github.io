<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>1.2.6  Packet-driven I/O with Reusable IRPs</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Packet_driven_I_O_with_Reusable_IRPs_KG"></A>1.2.6  Packet-driven I/O with Reusable IRPs</H3>
<P>
The I/O Manager’s chief job is to accept I/O requests (usually from user-mode
applications), to create IRPs to represent them, to route the IRPs to the
appropriate NT drivers, to track them until they are completed, and to return
status to the original requestor of each I/O operation. The I/O Manager uses
IRPs to communicate with NT drivers and to allow NT drivers to communicate
with each other.
<P>
Note that some IRPs might be routed to more than one NT driver. For example, a
request to open a file on a disk might go first to a file system driver,
through an intermediate mirror driver, and ultimately to a physical disk
driver, as implied in <A HREF="01intro_1.htm">Sections
1.1</A>&nbsp;and <A HREF="01intro_4.htm">1.2.2</A>.
<P>
Therefore, each IRP has a <I>fixed part</I>&nbsp;and one or more driver-specific <I>I/O</I>
<I>stack locations</I>:
<UL>
<LI>
In the fixed part (or <I>header</I>), the I/O Manager maintains information
about the original request, such as the caller’s parameters, the address of
the device object on which a file is open, etc. The fixed part also contains
an <I>I/O status block</I>, in which drivers set information about the status
of the requested operation.
<P>
<LI>
In the highest-level driver’s I/O stack location, the I/O Manager sets
driver-specific parameters, such as the particular operation requested
(represented as function codes) and context used by the corresponding driver
to determine what it is supposed to be doing. In turn, each higher-level NT
driver sets up the I/O stack location of the next-lower-level driver, if any.
</UL>
<P>
As a given IRP is processed through each NT driver’s set of standard routines,
each routine can access that driver’s I/O stack location in the IRP, thereby
reusing the IRP at each stage of the driver’s operations. In addition,
higher-level NT drivers can create (or reuse) IRPs to send requests down to
lower-level drivers.
<P>
For an overview of the processing of IRPs through layered drivers, see <A HREF="02irps.htm">Chapter
2</A>. For device-type-specific information about IRPs, see the <I>Kernel-mode
Driver Reference</I>.
<P></FONT>
</BODY>
</HTML>
