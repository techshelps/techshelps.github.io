<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.1.2  DriverEntry’s Additional Responsibilites</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_DriverEntrys_Additional_Responsibilites_KG"></A>5.1.2  DriverEntry’s Additional Responsibilites</H3>
<P>
Depending on the position of a particular driver in a chain of layered NT
drivers, on the nature of the underlying device, and on the design of the
driver, its DriverEntry routine also can be responsible for doing following: 
<UL>
<LI>
In a lowest-level NT driver, the DriverEntry routine initializes the physical
device.
<P>
<LI>
In a higher-level NT driver, the DriverEntry routine layers the driver over
the next-lower-level driver(s), using one of the following techniques:
<P>
<UL>
<LI>
To establish a connection between paired class/port drivers, the class driver
calls <B>IoGetDeviceObjectPointer</B>&nbsp;with the name of the port driver’s
(primary) device object(s).
<P>
For example, a SCSI class driver calls <B>IoGetDeviceObjectPointer</B>
repeatedly, passing an updated Unicode name string <B>\Device\ScsiPort</B><I>Digit</I>
where<I>&nbsp;Digit</I>&nbsp;is a count enumerating the SCSI HBAs in the machine. Then,
the class driver uses the returned device object pointers to send
get-configuration requests to the NT SCSI port driver, in order to determine
which HBAs control a bus with attached devices of the class driver’s type.
(For more information about initializing SCSI drivers, see also <A HREF="appascsi.htm">Appendix
A</A>.) 
<P>
A successful call to <B>IoGetDeviceObjectPointer</B>&nbsp;returns pointers to both
the lower driver’s device object and the file object associated with that
device object. A higher-level driver must save the returned device object
pointer so it can pass this device object pointer to <B>IoCallDriver</B>&nbsp;when
it passes IRPs on for processing by lower drivers.
<P>
Few higher-level NT drivers except FSDs have any use for the returned pointer
to the file object. However, a higher-level NT driver should save this
returned pointer to the file object if it might break its connection to the
lower driver later, for example when being unloaded. To break such a
connection, higher-level drivers call <B>ObDereferenceObject</B>&nbsp;to release
the file object pointer returned by <B>IoGetDeviceObjectPointer</B>.
<P>
For more information about driver Unload routines, see Chapter 15.
<P>
<LI>
To establish a connection between an NT intermediate or highest-level driver
and a lower-level driver, the DriverEntry routine creates a device object and
calls <B>IoAttachDevice</B>&nbsp;with a pointer to its newly created device object
and a pointer to the name of the lower driver’s device object.
<P>
Calling <B>IoAttachDevice</B>&nbsp;successfully allows a higher-level NT driver to
intercept requests bound for the lower driver’s device by aliasing the target
device object to its own device object. Note that the device object created by
the higher-level driver is not required to have a name, because the lower
driver’s device object is still the named target for I/O requests.
</UL>
<P>
<LI>
Since the system itself can boot from an NT driver’s floppy or CD-ROM device,
the DriverEntry routine of such a driver must create a symbolic link between
each possible boot device (the driver’s named device object that represents a
floppy or CD-ROM drive) and the corresponding ARC device by calling <B>IoAssignArcName</B>.
For more information about the ARC firmware and the corresponding
functionality in x86-based Windows NT platforms, see Chapter 16. For disk
device drivers, the system sets up these symbolic links automatically.
<P>
<LI>
If an NT device or intermediate driver has a device-dedicated thread, its
DriverEntry routine can call <B>PsCreateSystemThread</B>&nbsp;with the entry point
for the driver’s thread.
<P>
If a highest-level NT driver uses executive worker threads, as many NT file
system drivers do, it must have a callback routine of type
WORKER_THREAD_ROUTINE, which takes a single input PVOID <I>Parameter</I>.
<P>
<LI>
If a driver has an optional Reinitialize routine, its DriverEntry routine
calls <B>IoRegisterDriverReinitialization</B>&nbsp;once if and only if the
DriverEntry routine will return STATUS_SUCCESS. The driver can call <B>IoRegisterDriverReinitialization</B>
as many times as the Reinitialize routine should be run. Usually, a driver
with a Reinitialize routine is a higher-level NT driver. For more information
about Reinitialize routines, see <A HREF="05dentry_7.htm">Section
5.3</A>.
</UL>
<H5>Providing Storage for System Resources</H5>
<P>
An NT driver must provide storage, usually in the device extension of a device
object, for any Kernel-defined objects and executive spin locks it uses. NT
drivers also must provide storage for pointers to certain objects obtained
from the HAL or I/O Manager, as explained in Chapter 3.
<P>
Most device and intermediate drivers provide storage in their device or
controller extensions for every NT object and system resource they use to
process I/O requests. Their DriverEntry routines initialize certain resources,
such as any Kernel-defined object stored in the device (or controller)
extension, that the driver uses thereafter.
<P>
However, an NT driver designer might decide to allocate additional
system-space memory for the driver’s needs, such as for long-term I/O buffers
or a zone buffer. If so, the DriverEntry routine can call one (or more) of the
following routines:
<UL>
<LI>
<B>ExAllocatePool</B>&nbsp;for paged or nonpaged system-space memory
<P>
<LI>
<B>MmAllocateNonCachedMemory</B>&nbsp;or <B>MmAllocateContiguousMemory</B>&nbsp;for
cache-aligned nonpaged system-space memory (used for I/O buffers)
<P>
<LI>
<B>HalAllocateCommonBuffer</B>&nbsp;for drivers of devices that use continuous DMA
</UL>
<P>
For more information about using memory, see Chapter 16. For more information
about using common buffers for DMA, see the section on adapter objects in
Chapter 3.
<P></FONT>
</BODY>
</HTML>
