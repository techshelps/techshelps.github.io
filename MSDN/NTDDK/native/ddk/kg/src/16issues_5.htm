<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.2.3  Calling Support Routines That Use Spin Locks</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Calling_Support_Routines_That_Use_Spin_Locks_KG"></A>16.2.3  Calling Support Routines That Use Spin Locks</H3>
<P>
Calling <B>KeAcquireSpinLock</B>&nbsp;sets the IRQL on the current processor to
DISPATCH_LEVEL until a corresponding <B>KeReleaseSpinLock</B>&nbsp;call restores
the previous IRQL. Consequently, drivers must be executing at IRQL &lt;=
DISPATCH_LEVEL when they call the <B>KeAcquireSpinLock</B>. 
<P>
Callers of <B>KeAcquireSpinLockAtDpcLevel</B>&nbsp;and <B>KeReleaseSpinLockFromDpcLevel</B>
run faster because they are already running at IRQL DISPATCH_LEVEL so these
support routines need not reset IRQL on the current processor. Consequently,
it is a fatal error on most Windows NT platforms to call <B>KeAcquireSpinLockAtDpcLevel</B>
while running at IRQL less than DISPATCH_LEVEL. It is also an error to release
a spin lock that was acquired with <B>KeAcquireSpinLock</B>&nbsp;by calling <B>KeReleaseSpinLockFromDpcLevel</B>
because the caller’s original IRQL is not restored. 
<P>
Routines that hold an executive spin lock, such as the <B>ExInterlocked</B><I>Xxx</I>,
usually execute at IRQL DISPATCH_LEVEL until they release the spin lock and
return control to the caller. However, it is possible for an NT driver’s ISR
and SynchCritSection routines to call certain <B>ExInterlocked</B><I>Xxx</I>,
such as the <B>ExInterlocked..List</B>&nbsp;routines, as long as the spin lock
passed to this set of <B>ExInterlocked</B><I>Xxx</I>&nbsp;is used exclusively by
the ISR and SynchCritSection routines. 
<P>
Each routine that holds an interrupt spin lock executes at the DIRQL of an
associated set of interrupt objects. Therefore, a driver must not call <B>KeAcquireSpinLock</B>
and <B>KeReleaseSpinLock</B>&nbsp;nor any other routine that uses an executive spin
lock from its ISR or SynchCritSection routine(s). Such a call is an error that
can cause a system deadlock, requiring the user to reboot his or her machine.
Note that if a driver’s ISR or SynchCritSection routine calls an <B>ExInterlocked..List</B>
routine, such a driver cannot reuse the spin lock it passes to the <B>ExInterlocked..List</B>
routines in calls to the <B>Ke..SpinLock</B>&nbsp;or <B>Ke..SpinLock..DpcLevel</B>
support routines. 
<P>
If a driver has a multivector ISR or more than one ISR, its routines can call <B>KeSynchronizeExecution</B>
while executing at any IRQL up to the <I>SynchronizeIrql</I>&nbsp;value specified
for the associated interrupt objects when they were connected. For more
information about interrupt objects, see Chapter 3. 
<P>
For more information about device drivers’ SynchCritSection routines passed to
<B>KeSynchronizeExecution</B>, see Chapters 4 and 10, and <A HREF="16issues_6.htm">Section
16.2.4</A>. For more information about managing hardware priorities in drivers,
see <A HREF="16issues_1.htm">Section 16.1</A>, and see the <I>Kernel-Mode
Driver</I>&nbsp;<I>Reference</I>&nbsp;for support-routine-specific IRQL requirements. 
<P></FONT>
</BODY>
</HTML>
