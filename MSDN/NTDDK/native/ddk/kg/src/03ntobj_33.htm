<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.8.1  Setting up a Device Queue Object and Queueing IRPs</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Setting_up_a_Device_Queue_Object_and_Queueing_IRPs_KG"></A>3.8.1  Setting up a Device Queue Object and Queueing IRPs</H3>
<P>
<A NAME="DDK_Figure_3.21_KG"></A>An NT driver can set up a device queue object by
calling <B>KeInitializeDeviceQueue</B>&nbsp;when the driver initializes. After the
driver is loaded, it inserts IRPs into this queue by calling <B>KeInsertDeviceQueue</B>
or <B>KeInsertByKeyDeviceQueue</B>. Figure 3.21 illustrates these calls.
<P>
<B><IMG SRC="../art/3devqobj.gif" BORDER=0></B>
<P>
<B>Figure 3.21    Using a Device Queue Object</B>
<P>
As Figure 3.21 shows, the driver must provide the storage for a device queue
object, which must be resident. Drivers that set up a device queue object
usually provide the necessary storage in the device extension of a
driver-created device object (see <A HREF="03ntobj_2.htm">Section
3.2</A>), but it can be in a controller extension if the driver uses a controller
object (see <A HREF="03ntobj_20.htm">Section 3.4</A>) or in nonpaged
pool allocated by the driver.
<P>
The <B>DriverEntry</B>&nbsp;routine of such a driver must call <B>KeInitializeDeviceQueue</B>,
passing a pointer to the driver-provided storage for the device queue object.
<P>
After the driver is loaded, it can insert an IRP into its device queue by
calling <B>KeInsertDeviceQueue</B>, which places the IRP at the tail of the
queue, or <B>KeInsertByKeyDeviceQueue</B>, which places the IRP into the queue
according to a driver-determined <I>SortKey</I>&nbsp;value, as shown in Figure
3.21.
<P>
Each of these support routines returns a Boolean value indicating whether the
IRP was inserted into the queue. Each of these calls also sets the state of
the device queue object to Busy if the queue is currently empty. However, an
IRP passed to a <B>KeInsert..DeviceQueue</B>&nbsp;routine is <I>not</I>&nbsp;inserted
into the queue on the state transition from Not-Busy to Busy: that is, each of
these support routines returns FALSE when it sets the state of an empty device
queue object to Busy.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Consequently, NT driver writers who set up supplemental device queues should follow this implementation guideline: </H5>
<P>
When an IRP is sent to the driver and a call to <B>KeInsert..DeviceQueue</B>
returns FALSE, the caller <I>must</I>&nbsp;pass the IRP on for further processing
to another driver routine.
<P>
However, the call to <B>KeInsert..DeviceQueue</B>&nbsp;with such an IRP changes the
state of the device queue object to Busy, so the next IRP to come in is
inserted in the queue unless the driver calls <B>KeRemove..DeviceQueue</B>
first.
<P>
When the device queue object’s state is set to Busy, the driver can dequeue an
IRP for further processing or reset the state to Not-Busy by calling one of
the following support routines:
<UL>
<LI>
<B>KeRemoveDeviceQueue</B>&nbsp;to remove the IRP at the head of the queue
<P>
<LI>
<B>KeRemoveByKeyDeviceQueue</B>&nbsp;to remove an IRP chosen according to a
driver-determined <I>SortKey</I>&nbsp;value
<P>
<LI>
<B>KeRemoveEntryDeviceQueue</B>&nbsp;to remove a particular IRP in the queue or to
determine whether a particular IRP is in the queue
<P>
<B>KeRemoveEntryDeviceQueue</B>&nbsp;returns a Boolean indicating whether the given
IRP was in the device queue.
</UL>
<P>
An attempt to remove an entry from a device queue that is empty but whose
state is set to Busy causes the state transition to Not-Busy.
<P>
A device queue object is protected by a built-in executive spin lock (not
shown in Figure 3.21), so a driver that uses a device queue object can insert
IRPs into the queue and remove them in a multiprocessor-safe manner from any
driver routine running at less than or equal to IRQL DISPATCH_LEVEL. This IRQL
restriction precludes calling any <B>Ke..DeviceQueue</B>&nbsp;routine from an NT
device driver’s ISR and SynchCritSection routines, which run at DIRQL.
<P>
For more information about managing IRQLs and using executive spin locks, see
Chapter 16. For support-routine-specific IRQL requirements, see the <I>Kernel-Mode
Driver Reference</I>.
<P></FONT>
</BODY>
</HTML>
