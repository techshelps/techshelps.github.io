<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.2  Using Spin Locks</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Using_Spin_Locks_KG"></A>16.2  Using Spin Locks</H2>
<P>
Spin locks are Kernel-defined, kernel-mode-only synchronization mechanisms,
exported as an opaque type: KSPIN_LOCK. A spin lock can be used to protect
shared data or resources from simultaneous access by routines that can execute
concurrently and at raised IRQL in Windows NT SMP machines. 
<P>
Many NT components use spin locks, including NT drivers. Any kind of NT driver
might use one or more <I>executive spin locks</I>. For example, most NT file
systems use an interlocked work queue in the FSD’s device extension to store
IRPs that are processed both by the file system’s worker-thread callback
routines and by the FSD. An interlocked work queue is protected by an
executive spin lock, used to resolve contention among the FSD trying to insert
IRPs into the queue and any threads simultaneously trying to remove IRPs. As
another example, the system floppy controller driver uses two executive spin
locks. One executive spin lock protects an interlocked work queue shared with
this driver’s device-dedicated thread; the other protects a timer object
shared by three driver routines. 
<P>
Every NT driver that has an ISR uses an <I>interrupt spin lock</I>&nbsp;to protect
any data or hardware shared between its ISR and its SynchCritSection
routine(s) that are usually called from a driver’s StartIo and DpcForIsr
routines. An interrupt spin lock is associated with the set of interrupt
objects created when such a driver calls <B>IoConnectInterrupt</B>, as
described in Chapter 3. 
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; All designers of NT drivers that use a spin lock should follow these guidelines: </H5>
<UL>
<LI>
Provide the storage for any data or resource protected by a spin lock and for
the corresponding spin lock in resident system-space memory (nonpaged pool, as
shown in <A HREF="16issues_10.htm#DDK_Figure_16..3_NG">Figure 16.3</A>). A driver must provide the
storage for any executive spin locks it uses. However, a device driver need
not provide the storage for an interrupt spin lock unless it has a multivector
ISR or has more than one ISR, as described in Chapter 3. 
<P>
<LI>
Call <B>KeInitializeSpinLock</B>&nbsp;to initialize each spin lock for which the
driver provides storage before using it to synchronize access to the shared
data or resource it protects. 
<P>
<LI>
Call every support routine that uses a spin lock at an appropriate IRQL,
generally at &lt;= DISPATCH_LEVEL for executive spin locks or at &lt;= DIRQL
for an interrupt spin lock associated with the driver’s interrupt object(s). 
<P>
<LI>
Implement routines to execute as quickly as possible while they hold a spin
lock. No routine should hold a spin lock for longer than 25 microseconds. 
<P>
<LI>
<I>Never</I>&nbsp;implement routines that do any of the following while holding a
spin lock: 
<P>
<UL>
<LI>
Cause hardware exceptions or raise software exceptions 
<P>
<LI>
Attempt to access pageable memory 
<P>
<LI>
Make a recursive call that would cause a deadlock or could cause a spin lock
to be held for longer than 25 microseconds 
<P>
<LI>
Attempt to acquire another spin lock if doing so might cause a deadlock 
<P>
<LI>
Call an external routine that violates any of the preceding rules 
</UL>
</UL>
<P>
The following subsections explain these guidelines in more detail. 
<P></FONT>
</BODY>
</HTML>
