<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>7.3.4  Managing Interlocked Queues with a Driver-Created Thread</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Managing_Interlocked_Queues_with_a_Driver_Created_Thread_KG"></A>7.3.4  Managing Interlocked Queues with a Driver-Created Thread</H3>
<P>
Like the system floppy controller driver mentioned in Chapter 2, an NT driver
with a device-dedicated thread, rather than a StartIo routine, usually manages
its own queueing of IRPs in an interlocked queue. Such a driver’s thread pulls
IRPs from its interlocked queue when there is work to be done on the device. 
<P>
In general, such a driver must manage synchronization with its thread to any
resources shared between the thread and other driver routines. Such a driver
also must have some way to notify its driver-created thread that IRPs are
queued. Usually, such a thread waits on a dispatcher object, stored in the
device extension, until the driver’s Dispatch routines set the dispatcher
object to the Signaled state after inserting an IRP into the interlocked
queue. 
<P>
When such a device driver’s Dispatch routines are called, each checks the
parameters in the I/O stack location of the input IRP and, if they are valid,
queues the request for further processing. For each IRP queued to a
driver-dedicated thread, the Dispatch routine should set up whatever context
its thread needs to process that IRP before it calls <B>ExInterlockedInsert..List</B>.
The driver’s I/O stack location in each IRP gives the driver’s thread access
to the device extension of the target device object, where the driver can
share context information with its thread, as the thread removes each IRP from
the queue. 
<P>
Any driver-created thread runs at IRQL PASSIVE_LEVEL and at a base runtime
priority previously set when the driver called <B>PsCreateSystemThread</B>.
Such a thread’s call to <B>ExInterlockedRemoveHeadList</B>&nbsp;temporarily raises
the IRQL to DISPATCH_LEVEL on the current processor while the IRP is being
removed from the driver’s internal queue, and the original IRQL is restored to
PASSIVE_LEVEL on return from this call.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Any driver thread (or driver-supplied worker-thread callback) must manage the IRQLs at which it runs carefully. For example, consider the following: </H5>
<UL>
<LI>
Because system threads generally run at IRQL PASSIVE_LEVEL, it is possible for
a driver thread to wait on Kernel-defined dispatcher objects. 
<P>
For example, a device-dedicated thread might wait on an event for other driver
routines to satisfy and complete some number of partial-transfer IRPs that the
thread sets up with <B>IoBuildSynchronousFsdRequest</B>. 
<P>
<LI>
On the other hand, such a device-dedicated thread must raise IRQL on the
current processor before it calls certain support routines. 
<P>
For example, if a driver uses DMA, its device-dedicated thread must nest its
calls to <B>IoAllocateAdapterChannel</B>&nbsp;and <B>IoFreeAdapterChannel</B>
between calls to <B>KeRaiseIrql</B>&nbsp;and <B>KeLowerIrql</B>&nbsp;because the <B>Io..Adapter</B><I>Xxx</I>
routines and other support routines for DMA operations must be called at IRQL
DISPATCH_LEVEL. 
<P>
Note that, as mentioned in <A HREF="07strtio_2.htm">Section
7.2</A>, StartIo routines are run at DISPATCH_LEVEL, so NT drivers that use DMA
need not make calls to the the <B>Ke..Irql</B>&nbsp;routines from their StartIo
routines. 
<P>
<LI>
A driver-created thread can access pageable memory because it runs in a
nonarbitrary thread context (its own) at IRQL PASSIVE_LEVEL, but many other
standard NT driver routines run at raised IRQL. 
<P>
Consequently, if a driver-created thread allocates memory that can be accessed
by other driver routines, it must allocate the memory from nonpaged pool. For
example, if a device-dedicated thread allocates any buffer that will be
accessed later by the driver’s ISR or SynchCritSection, AdapterControl,
ControllerControl, DpcForIsr, CustomDpc, IoTimer, CustomTimerDpc, or, in a
higher-level driver, IoCompletion routine, the thread-allocated memory <I>cannot</I>
be pageable<I>.</I>&nbsp;
<P>
<LI>
Like a StartIo routine, a driver thread must synchronize its access to a
physical device and to any shared state information or resources that the
driver maintains in the device extension with the driver’s other routines that
access the same device, memory location, or resources. 
<P>
If the thread shares the device or state with the ISR, it must call <B>KeSynchronizeExecution</B>
with a driver-supplied SynchCritSection routine to program the device or to
access the shared state. For more information about SynchCritSection routines,
see Chapter 10.
<P>
If the thread shares state or resources with routines other than the ISR, the
driver must protect the shared state or resources with a driver-initialized
executive spin lock for which the driver provides the storage. For more
information about using spin locks, see Chapter 16.
</UL>
<P>
For more information about managing IRQLs, and about the design tradeoffs of a
using a driver thread for a slow device, see Chapter 16. For specific
information about the required IRQL(s) for calling any particular support
routine, see the <I>Kernel-mode Driver Reference</I>. 
<P></FONT>
</BODY>
</HTML>
