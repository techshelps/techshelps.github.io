<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.2.3  Initializing Driver-specific Device Objects and Device Extensions</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Initializing_Driver_specific_Device_Objects_and_Device_Extensions_KG"></A>3.2.3  Initializing Driver-specific Device Objects and Device Extensions</H3>
<P>
After <B>IoCreateDevice</B>&nbsp;returns, giving the caller a pointer to a <I>DeviceObject</I>
that contains a pointer to the <B>DeviceExtension</B>, the driver can
initialize any Kernel-defined objects and other system-defined data structures
for which it has provided storage in the device extension.
<P>
For example, a lowest-level driver would call <B>IoConnectInterrupt</B>&nbsp;with
the address of the PtrToInterruptObject(s) shown in <A HREF="03ntobj_2.htm#DDK_Figure_3..2_KG">Figure
3.2</A>&nbsp;to register its ISR, as well as Kernel-supplied support routines to
initialize the DpcObject and TimerObject in order to set up a CustomTimerDpc
routine. Such a driver would also call <B>KeInitializeSpinLock</B>, passing a
pointer to the ExecutiveSpinLock, so the driver could call <B>ExInterlockedInsertTailList</B>
and<B>&nbsp;ExInterlockedRemoveHeadList</B>&nbsp;to manage the queueing of IRPs in the
interlocked work queue shown in Figure 3.2.
<P>
For general guidelines on initializing and using spin locks, see Chapter 16.
For more information about interrupt, DPC, and timer objects, see <A HREF="03ntobj_23.htm">Sections
3.5</A>&nbsp;and <A HREF="03ntobj_29.htm">3.7</A>&nbsp;later in this
chapter. See also <A HREF="03ntobj_26.htm">Sections 3.6</A>&nbsp;and <A HREF="03ntobj_35.htm">3.9</A>
for other ways to use DPC and timer objects.
<P>
NT drivers also must set up certain fields in the device object(s) for their
respective physical, logical, and/or virtual devices.
<P>
<B>IoCreateDevice</B>&nbsp;sets the <B>StackSize</B>&nbsp;field of a newly created
device object to one. A lowest-level NT driver can ignore this field. After
any higher-level driver has chained itself over another driver by successfully
calling <B>IoGetDeviceObjectPointer</B>, the higher-level driver must set the <B>StackSize</B>
field to that of the next-lower-level driver’s device object plus one. This
ensures that IRPs sent to the higher-level driver will contain a
driver-specific I/O stack location, plus the correct number of I/O stack
locations for all lower-level drivers in the chain. If a higher-level driver
calls <B>IoAttachDevice</B>&nbsp;or <B>IoAttachDeviceToDeviceStack</B>, those
routines automatically set the <B>StackSize</B>&nbsp;field in the device object to
the appropriate value.
<P>
<B>IoCreateDevice</B>&nbsp;sets the <B>AlignmentRequirement</B>&nbsp;field of a newly
created device object to the processor’s data cache line size minus one. To
ensure that I/O buffers are aligned correctly, lowest-level physical device
drivers must do the following:
<OL>
<LI>
Subtract one from the alignment requirement of the device.
<P>
<LI>
Compare the result of Step 1 with the current value of the device object’s <B>AlignmentRequirement</B>.
<P>
<LI>
If the device’s alignment requirement is greater, set <B>AlignmentRequirement</B>
to the result of Step 1. Otherwise, leave the <B>AlignmentRequirement</B>
value as set by <B>IoCreateDevice</B>.
</OL>
<P>
After any higher-level driver has chained itself over another driver by
calling <B>IoGetDeviceObjectPointer</B>, the higher-level driver must set the <B>AlignmentRequirement</B>
field of its newly created device object to that of the next-lower-level
driver’s device object. If a higher-level driver calls <B>IoAttachDevice</B>
or <B>IoAttachDeviceToDeviceStack</B>, those routines automatically set the <B>AlignmentRequirement</B>
field in the device object to that of the lower-driver’s device object.
<P>
<B>IoGetDeviceObjectPointer</B>&nbsp;returns pointers both to the lower driver’s
device object and to the associated file object. Only an FSDs (or, possibly,
other highest-level drivers) can use the returned file object pointer. An
intermediate driver that calls <B>IoGetDeviceObjectPointer</B>&nbsp;should save
this file object pointer so it can be dereferenced by calling <B>ObDereferenceObject</B>
when the driver is unloaded.
<P>
After an FSD mounts the volume containing the file object that represents a
lower driver’s device object, an NT intermediate driver cannot chain itself
between the file system and the lower driver by calling <B>IoAttachDevice</B>.
<P>
If the caller creates more than one device object, the I/O Manager links its
subsequently created device objects to the input <I>DriverObject</I>&nbsp;by
maintaining<B>&nbsp;NextDevice</B>&nbsp;pointers in the device objects.
<P>
An intermediate or lowest-level NT driver also sets a bit in the device
object’s <B>Flags</B>&nbsp;by ORing it either with DO_DIRECT_IO or with
DO_BUFFERED_IO, as shown in <A HREF="03ntobj_2.htm#DDK_Figure_3..2_KG">Figure 3.2</A>, in every
device object it creates. Highest-level drivers of logical or virtual devices
can avoid setting <B>Flags</B>&nbsp;for either buffered or direct I/O if the driver
writer decides the additional work involved will pay off in better driver
performance. An NT intermediate driver must set up the <B>Flags</B>&nbsp;field of
its device object to match that of the next-lower driver’s device object.
<P>
Setting up a device object<B>&nbsp;Flags</B>&nbsp;field with DO_DIRECT_IO or
DO_BUFFERED_IO determines how the I/O Manager passes access to user buffers in
all data transfer requests subsequently sent to the driver.
<P></FONT>
</BODY>
</HTML>
