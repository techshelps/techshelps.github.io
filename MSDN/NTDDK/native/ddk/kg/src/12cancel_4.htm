<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.2  Handling Cancelable IRPs</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Handling_Cancelable_IRPs_KG"></A>12.2  Handling Cancelable IRPs</H2>
<P>
If an NT driver handles cancelable IRPs, it is responsible for setting the
appropriate Cancel routine in each IRP that will be put into a cancelable
state as it is processed in stages by the driver’s routines.
<P>
The following summarizes guidelines for driver routines that handle cancelable
IRPs.
<H5>Handling Cancelable IRPs in Driver Routines That Pass IRPs On</H5>
<P>
If a device driver has a StartIo routine, its Dispatch routines must specify a
driver-supplied Cancel routine’s entry point when they call <B>IoStartPacket</B>.
<P>
Otherwise, any driver’s Dispatch routine(s) must do the following <I>before</I>
queueing an IRP for further processing by other driver routines:
<P>
&nbsp; &nbsp; 1.&#09;Call <B>IoAcquireCancelSpinLock</B>.
<OL>
<LI>
Call <B>IoSetCancelRoutine</B>&nbsp;with the input IRP and the entry point for a
driver-supplied Cancel routine.
<P>
<LI>
Call <B>IoReleaseCancelSpinLock</B>.
</OL>
<P>
In a similar manner, any routine in such a driver that passes an IRP on for
further processing by other routines in the same driver should set up a Cancel
routine if that request could be held in a cancelable state before another
driver routine begins processing it.
<P>
Drivers that manage their own queue(s) of IRPs, rather than using the
I/O-manager-supplied device queue, do not need to acquire the cancel spin lock
when calling <B>IoSetCancelRoutine</B>. 
<H5>Handling Cancelable IRPs In Driver Routines That Process Requests</H5>
<P>
A driver’s StartIo routine, if any, and/or any other routine that dequeues or
is called with an IRP that was held in a cancelable state must do the
following:
<OL>
<LI>
Call <B>IoAcquireCancelSpinLock</B>.
<P>
<LI>
Check the <B>Irp-&gt;Cancel</B>&nbsp;field to determine whether to cancel the IRP
or to begin processing for the request.
<P>
<UL>
<LI>
If <B>Irp-&gt;Cancel</B>&nbsp;is set to TRUE, call <B>IoReleaseCancelSpinLock</B>
and return control.
<P>
<LI>
Otherwise, do the following:
<P>
&nbsp; &nbsp; 1.&#09;Call <B>IoSetCancelRoutine</B>&nbsp;with a NULL <I>CancelRoutine</I>
pointer to remove the IRP from the cancelable state.
<P>
&nbsp; &nbsp; 2.&#09;Call <B>IoReleaseCancelSpinLock</B>.
<P>
&nbsp; &nbsp; 3.&#09;Start the requested device I/O operation for the target device
object or, from a higher-level driver, pass the request on to lower drivers.
</UL>
</OL>
<P>
Any other driver routine that dequeues an IRP or is called with an IRP that
might have been held pending for an indefinite interval should do likewise.
That is, such a routine must test whether the IRP should be cancelled or
remove the IRP from the cancelable state before it begins I/O processing for
that IRP.
<P>
Drivers that manage their own queue(s) of IRPs, rather than using the
I/O-manager-supplied device queue, do not need to acquire the cancel spin lock
when calling <B>IoSetCancelRoutine</B>. 
<P>
In any driver that handles cancelable IRPs, every driver routine that
processes an IRP before the underlying device has been programmed for the
requested I/O operation should check the cancelable state of all incoming
IRPs. That is, a highest-level NT device driver with both StartIo and
ControllerControl routines should process incoming IRPs in both these driver
routines as already described.
<H5>Using the System Cancel Spin Lock</H5>
<H4><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Consider the following implementation guidelines for driver routines that change the state of cancelable IRPs, including all routines that might complete an IRP with STATUS_CANCELLED:</H4>
<UL>
<LI>
In drivers that use the I/O-manager-supplied device queue, any driver routine
besides the Cancel routine that changes the cancelable state of an IRP must
first call <B>IoAcquireCancelSpinLock</B>&nbsp;to acquire the system cancel spin
lock.
<P>
This ensures that only the caller can change the cancelable state of that IRP
for the following reasons:
<P>
<UL>
<LI>
It prevents the I/O Manager from calling the driver’s Cancel routine with that
IRP.
<P>
<LI>
It prevents any other driver routine, such as its DispatchCleanup routine,
from simultaneously attempting to change the cancelable state of that IRP.
</UL>
<P>
<LI>
In drivers that manage their own queue(s) of IRPs and synchronize queue access
using driver-supplied spin locks, the driver routines do not need to acquire
the cancel spin lock when calling <B>IoSetCancelRoutine</B>. 
<P>
<LI>
Any driver routine that calls <B>IoAcquireCancelSpinLock</B>&nbsp;must call <B>IoReleaseCancelSpinLock</B>
as quickly as possible.
<P>
<LI>
<I>Never</I>&nbsp;call <B>IoCompleteRequest</B>&nbsp;with an IRP while holding a spin
lock.
<P>
Attempting to complete an IRP while holding a spin lock can cause deadlocks.
</UL>
<P></FONT>
</BODY>
</HTML>
