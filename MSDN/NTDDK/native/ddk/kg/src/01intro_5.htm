<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>1.2.3  Always Preemptible and Always Interruptible</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Always_Preemptible_and_Always_Interruptible_KG"></A>1.2.3  Always Preemptible and Always Interruptible</H3>
<P>
The NT Kernel component determines when a particular sequence of code is run
according to one of the following prioritizing criteria:
<UL>
<LI>
The Kernel-defined runtime priority scheme for threads
<P>
Every thread in the system has an associated priority attribute. In general,
most threads in the system have <I>variable</I>&nbsp;priority attributes: they are
always preemptible and are scheduled to run round-robin with all other threads
currently at the same priority level. Some threads in the system have <I>real-time</I>
priority attributes: these time-critical threads are preemptible by any thread
with a higher real-time priority attribute, but otherwise run until they
relinquish control.
<P>
Whatever its priority attribute, any thread in the system can be preempted
when hardware and certain kinds of software interrupts occur.
<P>
<LI>
The Kernel-defined <I>interrupt request level</I>&nbsp;(IRQL) to which a particular
interrupt vector is assigned on a given platform
<P>
The NT Kernel also prioritizes hardware and software interrupts so that some
kernel-mode code runs at higher IRQLs, thereby making it, including most NT
drivers, have a higher scheduling priority than all threads in the system.
<P>
The particular IRQL at which a piece of kernel-mode code executes determines
its <I>hardware priority</I>. Such a piece of code is always <I>interruptible</I>:
an interrupt with a higher IRQL value can occur at any time, thereby causing
another piece of kernel-mode code with the system-assigned, higher IRQL to be
run immediately on that processor. In other words, when a piece of code runs
at a given IRQL, the Kernel masks off all interrupt vectors with a lesser or
equal IRQL value on the processor.
</UL>
<P>
In general, threads run at PASSIVE_LEVEL IRQL: no interrupt vectors are
masked. Software interrupts are assigned relatively low IRQL values
(APC_LEVEL, DISPATCH_LEVEL, or, for kernel debugging, WAKE_LEVEL). Device
interrupts have higher IRQL values, and the Kernel reserves the highest IRQL
values for system-critical interrupts such as the system clock or bus-error
interrupts.
<P>
Some kernel-mode support routines also run at IRQL PASSIVE_LEVEL both because
kernel-mode components can set up their own threads and because some
kernel-mode support routines are implemented as pageable code.
<P>
Certain standard driver routines usually run at IRQL PASSIVE_LEVEL, as well.
However, most NT driver routines run either at IRQL DISPATCH_LEVEL or, for a
device driver, at device IRQL (also called <I>DIRQL</I>).
<P>
For performance reasons (avoiding context switches), very few NT drivers
actually set up their own threads. Consequently, NT driver routines usually
execute in the context of whatever thread happens to be current when the
driver is called to get some work done: that is, in an <I>arbitrary thread
context</I>.
<P>
In general, only a highest-level NT driver, such as a file system driver, is
called in the context of a thread that is requesting the current I/O
operation. An intermediate or lowest-level device driver can <I>never</I>
assume that it is executing in the context of the thread that requested its
current I/O operation.
<P>
While any kernel-mode routine that is run at higher than PASSIVE_LEVEL IRQL
has a higher priority than all threads in the system, <I>every routine in an
NT driver is interruptible</I>: any kernel-mode routine running at a
particular IRQL retains control of the processor only if no interrupt with a
higher IRQL value occurs while that routine is running.
<P>
Even an NT device driver’s <I>interrupt service routine</I>&nbsp;(ISR) can be
interrupted by another routine (for example, by another driver’s ISR) that
runs at higher IRQL. Unlike the drivers in some PC operating systems, an NT
driver’s ISR is <I>not</I>&nbsp;the workhorse routine that does almost all I/O
processing because an NT driver’s ISR does not necessarily retain control of
the CPU it is currently running on until it returns.
<P>
Instead, an NT device driver must carry out most of its I/O operations at a
lower IRQL than the DIRQL of its ISR. For good overall system performance, all
kernel-mode routines that run at high IRQLs must relinquish control of the CPU
very quickly. Such routines do only what must be done at high IRQL and
generally queue a <I>deferred procedure call</I>&nbsp;(DPC) to complete any
operations that can be done at a lower IRQL (DISPATCH_LEVEL).
<P>
For an introduction to the system-defined standard routines for NT drivers,
see <A HREF="02irps.htm">Chapter 2</A>. For an
overview of these routines, see <A HREF="04drvovr.htm">Chapter
4</A>.
<P></FONT>
</BODY>
</HTML>
