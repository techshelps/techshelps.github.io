<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.2.2  Higher-Level Driver’s Initialization</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Higher_Level_Drivers_Initialization_KG"></A>5.2.2  Higher-Level Driver’s Initialization</H3>
<P>
The DriverEntry routine of a higher-level NT driver should initialize itself
in the following stages:
<OL>
<LI>
Allocate memory for and gather whatever configuration information it needs
from the registry.
<P>
For example, a higher-level driver might search the registry for the named
device objects created by already loaded device drivers that represent a
particular type of device so the higher-level driver can layer itself over
appropriate device drivers or the drivers layered above them.
<P>
<LI>
Set the driver’s Dispatch, StartIo (if any), and Unload (if any) entry points
in the given driver object.
<P>
<LI>
Set up the NT objects and any other system resources, such as spin locks, that
the driver will use to process I/O requests, and connect or attach its own
device object(s) to the next-lower driver’s device object(s) with <B>IoGetDeviceObjectPointer</B>
or <B>IoAttachDevice</B>.
<P>
<LI>
Set up value entries in its own keys in the registry, such as the named device
object(s) this driver created, so that still higher-level drivers can layer
themselves over this driver.
<P>
<LI>
If the driver successfully layered itself over one or more underlying device
drivers, free the memory it allocated to hold configuration information from
the registry, or possibly call <B>IoRegisterDriverReinitialization</B>&nbsp;passing
a <I>Context</I>&nbsp;pointer to the configuration information, and return
STATUS_SUCCESS.
<P>
Otherwise, free any objects and system resources it allocated, including the
memory it used to hold configuration information, and return an appropriate
NTSTATUS error.
</OL>
<H4><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Every writer of a higher-level NT driver should consider the following guidelines when implementing a DriverEntry routine: </H4>
<UL>
<LI>
If the driver calls <B>IoGetDeviceObjectPointer</B>&nbsp;successfully, it must save
the returned pointer to the next-lower driver’s device object; this pointer is
a required parameter to <B>IoCallDriver</B>.
<P>
<LI>
A higher-level NT driver should save the file object pointer returned by <B>IoGetDeviceObjectPointer</B>.
Such a higher-level driver <I>must</I>&nbsp;call <B>ObDereferenceObject</B>&nbsp;if the
underlying driver has an Unload routine, described in Chapter 15, and is later
unloaded.
<P>
<LI>
If the driver calls <B>IoAttachDevice</B>&nbsp;successfully, it must save the
pointer to the next-lower driver’s device object; this pointer is a required
parameter to <B>IoCallDriver</B>.
<P>
<LI>
To call <B>IoAttachDevice</B>, the driver must create a device object of its
own first. If subsequent call(s) to <B>IoAttachDevice</B>&nbsp;do not succeed, the
driver must call <B>IoDeleteDevice</B>&nbsp;with the device object(s) that it
created.
<P>
<LI>
Because the DriverEntry routine runs in a system thread context at IRQL
PASSIVE_LEVEL, any memory allocated with <B>ExAllocatePool</B>&nbsp;for use
exclusively during initialization can be from paged pool, provided that the
underlying device driver does not control the device that holds the system
page file. Such a memory allocation must be freed with <B>ExFreePool</B>
before DriverEntry returns control unless the driver passes a pointer to this
memory in a call to <B>IoRegisterDriverReinitialization</B>, making the
driver’s Reinitialize routine responsible for freeing the memory allocation.
<P>
<LI>
If the driver has a Reinitialize routine, its DriverEntry routine must not
call <B>IoRegisterDriverReinitialization</B>&nbsp;unless it will return
STATUS_SUCCESS.
</UL>
<P></FONT>
</BODY>
</HTML>
