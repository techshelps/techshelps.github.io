<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>11.3  ControllerControl Routine Requirements</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_ControllerControl_Routine_Requirements_KG"></A>11.3  ControllerControl Routine Requirements</H2>
<P>
As its name implies, a ControllerControl routine is associated with an NT
controller object. When the ControllerControl routine executes, the hardware
represented by the controller object is free and the controller extension
generally is not being accessed by another driver routine unless the
controller extension contains context that is shared with the driver’s ISR.
<P>
Usually, a ControllerControl routine does at least the following:
<OL>
<LI>
Updates or initializes whatever context the driver maintains in the device
extension of the target device object and in the controller extension
<P>
If the driver uses DMA, its ControllerControl routine usually is responsible
for determining whether a given transfer request must be split up into partial
transfers due to any system- or device-imposed limitations on the size of each
DMA transfer. In these circumstances, the ControllerControl routine also is
responsible for calling <B>IoAllocateAdapterChannel</B>&nbsp;if the driver has an
AdapterControl routine.
<P>
If the driver uses PIO, its ControllerControl routine also is responsible for
splitting large transfer requests, if its hardware requires it, into
partial-transfer ranges and for calling <B>MmGetSystemAddressForMdl</B>&nbsp;with
the MDL at <B>Irp-&gt;MdlAddress</B>.
<P>
<LI>
Programs its hardware for the requested I/O operation
<P>
If the device or controller extension can be accessed from the ISR, the
ControllerControl routine must call <B>KeSynchronizeExecution</B>&nbsp;with a
SynchCritSection routine, described in Chapter 10, to program the hardware or
to set up context shared with the ISR.
</OL>
<P>
If the driver has a Cancel routine, its ControllerControl routine also must
check the <B>Irp-&gt;Cancel</B>&nbsp;field to determine whether the current IRP
should be cancelled, and do either of the following:
<UL>
<LI>
If <B>Irp-&gt;Cancel</B>&nbsp;is set to TRUE, the ControllerControl routine must do
the following:
<P>
<OL>
<LI>
Set STATUS_CANCELLED for <B>Status</B>&nbsp;and zero for <B>Information</B>&nbsp;in the
I/O status block of the IRP.
<P>
<LI>
Call <B>IoFreeController</B>&nbsp;to release the controller object so the next
device operation can be started promptly.
<P>
<LI>
Call <B>IoStartNextPacket</B>&nbsp;or dequeue the next IRP if the driver manages
its own queueing.
<P>
<LI>
Complete the cancelled IRP with <B>IoCompleteRequest</B>&nbsp;and return control.
</OL>
<P>
<LI>
Otherwise, the ControllerControl routine must do the following:
<P>
<OL>
<LI>
Call <B>IoSetCancelRoutine</B>&nbsp;to reset the Cancel routine entry point for the
IRP to NULL. Acquire the cancel spin lock for this call if the driver uses the
I/O-manager-supplied device queue in the device object.
<P>
<LI>
Call <B>KeSynchronizeExecution</B>&nbsp;with a driver-supplied SynchCritSection
routine to program the hardware for the requested I/O operation.
</OL>
</UL>
<P>
For more information about Cancel routines and handling cancelable IRPs, see
Chapter 12.
<P>
For most interrupt-driven I/O operations except overlapped operations on
different devices attached to the physical controller/adapter, a
ControllerControl routine should return <B>KeepObject</B>&nbsp;because the
DpcForIsr or CustomDpc routine completes the operation and the IRP.
<P>
As soon as the I/O operation(s) to satisfy the current request are done, the
routine that will complete the IRP should call <B>IoFreeController</B>&nbsp;and <B>IoStartNextPacket</B>
so that the next request can be processed as quickly as possible.
<P>
If the ControllerControl routine itself completes an IRP or if it can set up
an operation, such as a disk seek, for one target device object (disk) that
could be overlapped with an operation for another device object, the
ControllerControl routine should return <B>DeallocateObject</B>.
<P>
&nbsp;
<P></FONT>
</BODY>
</HTML>
