<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.9.1  Timer Objects</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Timer_Objects_KG"></A>3.9.1  Timer Objects</H3>
<P>
Any NT driver can set up a timer object with <B>KeInitializeTimer</B>&nbsp;or <B>KeInitializeTimerEx</B>
that it can use within a nonarbitrary thread context to time out operations
within the driver’s other routines or perform a periodic operation.
<P>
A timer can be a notification timer or a synchronization timer. When a
notification timer is signaled, all waiting threads have their wait satisfied
and the state of the timer remains signaled until it is explicitly reset. When
a synchronization timer expires, its state is set to Signaled until a single
waiting thread is released and then the timer is reset to the Not-Signaled
state. <B>KeInitializeTimer</B>&nbsp;always creates notification timers. <B>KeInitializeTimerEx</B>
accepts a <I>Type</I>&nbsp;parameter which can be <B>NotificationTimer</B>&nbsp;or <B>SynchronizationTimer</B>.
Both notification and synchronization timers can optionally have an associated
CustomTimerDpc routine.
<P>
A timer can expire just once or it can be set to expire repeatedly at a given
interval. <B>KeSetTimer</B>&nbsp;always sets a timer that will expire just once. <B>KeSetTimerEx</B>
accepts an optional <I>Period</I>&nbsp;parameter for specifying a recurring
interval for the timer.
<P>
<A NAME="DDK_Figure_3.23_KG"></A>Figure 3.23 illustrates using a notification
timer to set up a time-out interval for an operation and then wait while other
driver routines process an I/O request.
<P>
<B><IMG SRC="../art/3ketimer.gif" BORDER=0></B>
<P>
<B>Figure 3.23    Waiting on a Timer Object</B>
<P>
As Figure 3.23 shows, a driver must provide storage for the timer object,
which must be initialized in the <B>DriverEntry</B>&nbsp;or Reinitialize routine by
calling <B>KeInitializeTimer</B>&nbsp;with a pointer to this storage.
<P>
Within the context of a particular thread, such as a driver-created thread or
a thread requesting a synchronous I/O operation, the driver can wait on its
timer object as shown in Figure 3.23:
<OL>
<LI>
The thread calls <B>KeSetTimer</B>&nbsp;with a pointer to the timer object and a
given <I>DueTime</I>, expressed in units of 100 nanoseconds. A positive value
for <I>DueTime</I>&nbsp;specifies an absolute time at which the timer object should
be removed from the Kernel’s timer queue and set to the Signaled state. A
negative value for <I>DueTime</I>&nbsp;specifies an interval relative to the
current system time.
<P>
Note that the thread (or driver routine running in a system thread) passes a
NULL pointer for the DPC object previously shown in <A HREF="03ntobj_31.htm#DDK_Figure_3..20_KG">Figure
3.20</A>&nbsp;when it calls <B>KeSetTimer</B>&nbsp;if it waits on the timer object instead
of queueing a CustomTimerDpc routine.
<P>
<LI>
The thread calls <B>KeWaitForSingleObject</B>&nbsp;with a pointer to the timer
object, which puts the thread into a wait state while the timer object is in
the Kernel’s timer queue.
<P>
<LI>
The given <I>DueTime</I>&nbsp;expires.
<P>
<LI>
The Kernel dequeues the timer object, sets it to the Signaled state, and
changes the thread’s state from waiting to ready.
<P>
<LI>
The Kernel dispatches the thread for execution as soon as a processor is
available: that is, no other thread with a higher priority is currently in the
ready state and there are no kernel-mode routines to be run at raised IRQL
(greater than PASSIVE_LEVEL).
</OL>
<P>
NT driver routines that run at raised IRQL can time out requests by using a
timer object with an associated DPC object, as already described in <A HREF="03ntobj_26.htm">Section
3.6</A>, to queue a driver-supplied CustomTimerDpc routine. Only driver routines
that run within a nonarbitrary thread context can wait for a nonzero interval
on a timer object, as shown in Figure 3.23.
<P>
Like every other thread, a driver-created thread is represented by a Kernel
thread object, which is also a dispatcher object. Consequently, a driver need
not have its driver-created thread use a timer object to voluntarily put
itself into a wait state for a given interval. Instead, the thread can call <B>KeDelayExecutionThread</B>
with a caller-supplied interval. For more information about this technique,
see the section on polling a device in Chapter 16. See also the <I>Kernel-Mode
Driver Reference</I>&nbsp;for the specifics of calling <B>KeDelayExecutionThread</B>.
<P>
NT drivers’ <B>DriverEntry</B>, Reinitialize, and Unload routines also run in
a system thread context, so NT drivers can call <B>KeWaitForSingleObject</B>
with a driver-initialized timer object or <B>KeDelayExecutionThread</B>&nbsp;while
they are initializing or unloading. A device driver can call <B>KeStallExecutionProcessor</B>
for a very short interval (preferably something less than 50 microseconds) if
it must wait for the device to update state during its initialization.
<P>
However, higher-level NT drivers generally use another synchronization
mechanism in their <B>DriverEntry</B>&nbsp;and/or Reinitialize routines instead of
using a timer object. Higher-level NT drivers should always be designed to
layer themselves over any lower-level driver of a particular type or types of
device. Therefore, a higher-level driver tends to become slow-to-load if it
waits on a timer object or calls <B>KeDelayExecutionThread</B>&nbsp;because such a
driver must wait for an interval long enough to accommodate the slowest
possible device supporting it. Note also that a “safe” but minimum interval
for such a wait is very difficult to determine.
<P>
For more information about the FILE_DEVICE_<I>XXX</I>&nbsp;that NT drivers set in
their device objects, see <A HREF="03ntobj_2.htm">Section
3.2</A>, and see also the <I>Kernel-Mode Driver Reference</I>.
<P>
If the system time changes before a timer expires, relative timers are not
affected but the system adjusts absolute timers. A relative timer always
expires after the specified number of time units elapse, regardless of the
absolute system time. An absolute timer expires at a specific system time, so
a change in the system time changes the wait duration of an absolute timer.
<P></FONT>
</BODY>
</HTML>
