<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>P</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_P_KG"></A>P</H2>
<H3><A NAME="DDK_page_frame_KG"></A>page frame</H3>
<P>
A block of contiguous physical memory used to store the contents of a virtual
page. Note that the virtual page size and page frame size are usually
identical, but that a page frame size is actually microprocessor-dependent.
<H3><A NAME="DDK_paged_pool_KG"></A>paged pool</H3>
<P>
See <I>pool memory</I>.
<H3><A NAME="DDK_paging_file_KG"></A>paging file</H3>
<P>
A system file containing the contents of virtual pages that have been paged
out of memory. See also <I>backing store</I>&nbsp;and<I>&nbsp;system paging file</I>.
<H3><A NAME="DDK_PCI_KG"></A>PCI</H3>
<P>
Peripheral component interconnect
<P>
A dynamically configurable I/O bus, described by the <I>PCI Local Bus
Specification</I>&nbsp;published by the PCI SIG.
<H3><A NAME="DDK_PCMCIA_KG"></A>PCMCIA</H3>
<P>
Personal computer memory card international association
<H3><A NAME="DDK_PCR_KG"></A>PCR</H3>
<P>
Processor control registers
<P>
An internal data structure in which the Kernel stores per-processor
information.
<H3><A NAME="DDK_PEB_KG"></A>PEB</H3>
<P>
Process environment block
<H3><A NAME="DDK_PFN_KG"></A>PFN</H3>
<P>
Page frame number
<P>
Also, the database in which the NT Memory Manager maintains information about
every physical page in the system. Each PFN is an index for a physical page in
the array of records that makes up the PFN database. See also <I>PTE</I>.
<H3><A NAME="DDK_PIO_KG"></A>PIO</H3>
<P>
Programmed I/O (a.k.a. abbreviation for “parallel input/output”)
<P>
A technique of making data transfers between a device and system memory using
remapped system-space virtual addresses, rather than DMA.
<H3><A NAME="DDK_polling_KG"></A>polling</H3>
<P>
A pernicious, but sometimes necessary, coding technique that wastes CPU cycles
in a driver until the physical device updates its registers. NT device drivers
should never implement polling loops and should minimize the interval they
specify in calls to <B>KeStallExecutionProcessor</B>&nbsp;(no longer than 50
microseconds) if they must poll their devices.
<H3><A NAME="DDK_pool_memory_KG"></A>pool memory</H3>
<P>
Regions located in kernel space from which memory blocks can be allocated and
deallocated dynamically. (Some other systems call this “heap memory.”) The NT
Memory Manager creates two kinds of pools for system use and for use by
drivers via <B>Ex</B>(ecutive) Support routine calls:
<P>
<FONT FACE="Symbol">&#183;</FONT>&#09;<I>Paged pool</I>&nbsp;is a based region that
can be paged in and out of a process’s working set. Each process has its own
set of PTEs that map paged pool into its address space. Touching a page in
this pool can cause a page fault at any time, so NT drivers should allocate
only those data structures accessed exclusively at IRQL PASSIVE_LEVEL or
APC_LEVEL (see <I>IDT</I>) from paged pool.
<P>
<FONT FACE="Symbol">&#183;</FONT>&#09;<I>Nonpaged pool</I>&nbsp;is a based region
for which all processes share a set of PTEs. The NT Memory Manager guarantees
that nonpaged pool is resident in physical memory at all times; therefore,
this region can be accessed from any process’s address space without causing a
page fault. However, nonpaged pool is a limited system resource.
<P>
NT drivers should allocate from paged pool for entities that are accessed
exclusively at or below IRQL APC_LEVEL and in a nonarbitrary thread context.
They should minimize their usage of nonpaged pool by “saving” it for data that
must be accessed at or above IRQL DISPATCH_LEVEL. Allocations of contiguous or
noncached memory come from nonpaged pool.
<P>
The Memory Manager allocates entities from both pools using a buddy scheme.
See also <I>kernel space</I>.
<H3><A NAME="DDK_port_object_KG"></A>port object</H3>
<P>
An instance of an object type representing a conduit for messages between
local (server/client) processes. It is used in the LPC (<U>L</U>ocal <U>P</U>rocedure
<U>C</U>all) model of NT as an object accessible to user-mode processes
through system services. The server (callee) process defines a named
connection port object and sets up two (unnamed) communication port objects
when a client (caller) process connects to the named port.
<H3><A NAME="DDK_port_driver_KG"></A>port driver</H3>
<P>
A lowest-level NT driver that responds to a set of system-defined device
control requests and, possibly, to an additional set of driver-defined
(private) device control requests, sent down by a corresponding class driver.
A port driver insulates class drivers from the specifics of HBAs and
synchronizes operations for all its class drivers. Some examples of
system-supplied port drivers include the following:
<P>
(1) The NT SCSI port driver that supports a set of device-type-specific class
drivers, and possibly SFDs, above it and one or more HBA-specific miniport
drivers, and possibly nonSCSI mass-storage device drivers, which link
themselves to this OS-dependent port driver (implemented as a dynamic-link
library) and call its <B>ScsiPort</B><I>Xxx</I>&nbsp;routines.
<P>
(2) The NT video port driver that supports display drivers and
adapter-specific, kernel-mode miniport drivers, which link themselves to the
NT-dependent port driver (implemented as a dynamic-link library) and call its <B>VideoPort</B><I>Xxx</I>
routines.
<P>
(3) The NT parallel port driver.
<P>
In general, any driver of a device that is a so-called “intelligent
controller” or a bus adapter can be a port driver if it communicates with one
or more class drivers according to an established protocol and synchronizes
access to the controller or bus.
<P>
See also <I>class driver</I>, <I>miniport driver</I>, <B><I>ScsiPort</B>
routines</I>, and <B><I>VideoPort</I></B>&nbsp;<I>routines</I>.
<H3><A NAME="DDK_POSIX_KG"></A>POSIX</H3>
<P>
Portable operating system for (UN)IX
<P>
A Windows NT protected subsystem that supports the POSIX standard.
<H3><A NAME="DDK_PRCB_KG"></A>PRCB</H3>
<P>
<U>Pr</U>ocessor <U>c</U>ontrol <U>b</U>lock
<P>
An extension of the PCR.
<H3><A NAME="DDK_priority_KG"></A>priority</H3>
<P>
An attribute of a thread that determines when and how often it is scheduled to
run. For a running thread, its priority falls into either of two classes, each
class with sixteen levels:
<P>
<FONT FACE="Symbol">&#183;</FONT>&#09;<I>Variable priority class</I>&nbsp;has
values in the range 0 to 15. This class is used by most threads.
<P>
Threads with variable priority are always preemptible; that is, they are
scheduled to run round-robin with other threads at the same level. In general,
the Kernel manages a variable-priority thread as follows: when the thread is
interactive with a user, its priority is high (given a boost); otherwise, its
priority decays by one level per quantum the thread runs until it reaches its
original programmer-defined base priority level.
<P>
<FONT FACE="Symbol">&#183;</FONT>&#09;<I>Real-time priority class</I>&nbsp;has
values in the range 16 to 31. This class is used by time-critical threads,
making such a thread preemptible only by a thread with higher priority.
<P>
Note that any thread, whatever its priority attribute, is always preemptible
by a software or hardware interrupt.
<H3><A NAME="DDK_priority_boosts_KG"></A>priority boosts</H3>
<P>
A set of system-defined constant values, supplied when NT drivers complete an
IRP. For example, drivers for interactive devices usually call <B>IoCompleteRequest</B>
with a device-type-specific priority boost value. The boost is added to the
priority of the user-mode thread that originally requested the I/O operation
to compensate for that thread’s wait on the I/O.
<H3><A NAME="DDK_probe_KG"></A>probe</H3>
<P>
To check whether a memory access of a particular kind (such as read) to a data
entity, such as a handle for an object or a buffer, is allowed without causing
an access violation. Note that user-supplied parameter values are always
probed and captured on the kernel stack before an NT system service gets
control in kernel mode. The system service is responsible for probing whatever
a captured pointer accesses.
<H3><A NAME="DDK_process_object_KG"></A>process object</H3>
<P>
A Kernel-defined control object type, representing the virtual address space
and control information necessary for the execution of a set of thread
objects. A user-mode process object defines the base priority, default
affinity, and directory table base value for its threads and for any child
processes it creates. Every user-visible process object is implemented through
the use of an embedded kernel-mode process object.
<P>
A kernel-mode-only process object must be initialized before any thread
objects that belong to the process.
<H3><A NAME="DDK_protected_subsystem_KG"></A>protected subsystem</H3>
<P>
A server that appears to perform operating system functions for its native
applications and subsystem-specific drivers by calling system services. A
protected subsystem runs in user mode and its interface to end users emulates
another operating system, such as Windows or POSIX, on top of NT. See also <I>integral
subsystem</I>.
<H3><A NAME="DDK_PTE_KG"></A>PTE</H3>
<P>
Page table entry
<P>
The Memory Manager uses a PTE to represent the state of a virtual page.
<H3><A NAME="DDK_pulse_KG"></A>pulse</H3>
<P>
To set an event to the Signaled state, satisfy as many waiters on the event as
possible, and to reset the event to the Not-Signaled state.
<P></FONT>
</BODY>
</HTML>
