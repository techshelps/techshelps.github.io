<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.2.4  How to Pass IRPs with Valid Parameters on from a Dispatch Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_How_to_Pass_IRPs_with_Valid_Parameters_on_from_a_Dispatch_Routine_KG"></A>6.2.4  How to Pass IRPs with Valid Parameters on from a Dispatch Routine</H3>
<P>
When a Dispatch routine has checked its own I/O stack location in an input IRP
and determined that any parameters are valid, it must pass the IRP on for
further processing by lower-level drivers or by other device driver routines
if it cannot satisfy and complete the given request in the Dispatch routine
itself. 
<UL>
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>A higher-level NT driver
should pass such a request on to a next-lower driver as follows:<B>&nbsp;</B>
<P>
&nbsp; &nbsp; 1.&#09;Call <B>IoGetCurrentIrpStackLocation</B>&nbsp;with the input IRP, if
the Dispatch routine has not already done so, to get a pointer for its own I/O
stack location in the IRP. 
<P>
In most circumstances, a higher-level driver’s Dispatch routine has already
made this call. However, a Dispatch routine devoted exclusively to handling a
particular IRP_MJ_<I>XXX</I>&nbsp; with parameters that the driver cannot validate
or with no parameters might call <B>IoGetCurrentIrpStackLocation</B>. 
<P>
&nbsp; &nbsp; 2.&#09;Call <B>IoGetNextIrpStackLocation</B>&nbsp;if the driver will pass the
input IRP on to the next lower-level driver. If it allocates additional IRP(s)
for one or more lower drivers, the Dispatch routine makes either of the
following sets of calls with each of the IRPs it allocates:
<P>
<UL>
<LI>
<B>IoGetNextIrpStackLocation</B>&nbsp;to get a pointer to the next-lower driver’s
I/O stack location if the driver allocated no stack location of its own in the
new IRP 
<P>
<LI>
<B>IoSetNextIrpStackLocation</B>, followed by <B>IoGetCurrentIrpStackLocation</B>,
to get a pointer to its own stack location in a new IRP, where it can set up
whatever context its IoCompletion routine needs; then, <B>IoGetNextIrpStackLocation</B>
to get a pointer to the next-lower driver’s I/O stack location 
</UL>
<P>
&nbsp; &nbsp; 3.&#09;Set up the next-lower driver(s)’ I/O stack location, usually by
copying the contents of its own I/O stack location in the original IRP to the
next-lower driver’s. However, the Dispatch routine can modify some of the
parameters in the next-lower driver’s I/O stack location for certain requests.
<P>
For example, a higher-level driver might modify the parameters for a large
transfer request when the underlying device has a known limit in transfer
capacity, and reuse the IRP to send partial-transfer requests to the
underlying device driver. 
<P>
&nbsp; &nbsp; 4.&#09;Call <B>IoSetCompletionRoutine</B>&nbsp;with each IRP that the Dispatch
routine allocated so the driver’s IoCompletion routine releases each such IRP
when lower drivers have completed it. 
<P>
The Dispatch routine also can call <B>IoSetCompletionRoutine</B>&nbsp;with an input
IRP in which it has set up the next-lower driver’s I/O stack location. Then,
its IoCompletion routine can check on how lower drivers completed the request,
reuse the IRP for partial transfers, update whatever state the driver
maintains if it tracks IRPs, possibly retry a request returned with an error,
and so forth. 
<P>
For more information about IoCompletion routines, see Chapter 13. 
<P>
&nbsp; &nbsp; 5.&#09;Call <B>IoCallDriver</B>&nbsp;with each IRP to be processed by lower
driver(s). 
<P>
&nbsp; &nbsp; 6.&#09;Return an appropriate NTSTATUS value, such as:
<P>
<UL>
<LI>
Usually, STATUS_PENDING if the input IRP is an asynchronous request, such as
IRP_MJ_READ or IRP_MJ_WRITE 
<P>
<LI>
Frequently, the result of the call to <B>IoCallDriver</B>&nbsp;if the input IRP is
a synchronous request, such as IRP_MJ_CREATE or IRP_MJ_DEVICE_CONTROL 
</UL>
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>An NT device driver passes
any IRP that it cannot complete in its Dispatch routine on to other driver
routines as follows:<B>&nbsp;</B>
<P>
&nbsp; &nbsp; 1.&#09;Call <B>IoMarkIrpPending</B>&nbsp;with the input IRP.
<P>
&nbsp; &nbsp; 2.&#09;Call <B>IoStartPacket</B>&nbsp;to pass on or queue the IRP to the
driver’s StartIo routine, unless the driver manages its own internal IRP
queueing. See Chapter 7 for more information about driver-managed queues. 
<P>
If the driver does not have a StartIo routine but handles cancelable IRPs, it
must call <B>IoSetCancelRoutine</B>&nbsp;with the entry point for a Cancel routine
and the IRP before queueing the IRP for further processing. See Chapter 12 for
more information about Cancel routines. 
<P>
&nbsp; &nbsp; 3.&#09;Return STATUS_PENDING.
</UL>
<P></FONT>
</BODY>
</HTML>
