<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.4.2  DispatchDeviceControl in Higher-Level Drivers</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_DispatchDeviceControl_in_Higher_Level_Drivers_KG"></A>6.3.4.2  DispatchDeviceControl in Higher-Level Drivers</H4>
<P>
Usually, the DispatchDeviceControl routine of a higher-level NT driver simply
sets up the I/O stack location in the IRP for the next-lower-level driver and
passes it on with <B>IoCallDriver</B>. Such a DispatchDeviceControl routine
seldom checks the validity of parameters in the input IRP because the
underlying device driver is assumed to have better information about how to
handle each device-type-specific I/O control request on its own device.
<P>
A possible exception to this general rule is the DispatchDeviceControl routine
in the class driver of a class/port driver pair. For more information about
handling device control requests in paired class/port drivers, see <A HREF="06dsptch_24.htm">Section
6.3.4.3</A>. 
<P>
Any new higher-level NT driver that is not closely associated with a
particular device driver should simply set up the I/O stack location for the
next-lower-level driver and pass the IRP_MJ_DEVICE_CONTROL request on for
further processing. 
<P>
A device control request is usually handled synchronously. That is, a
higher-level driver’s DispatchDeviceControl routine can frequently return
control to the system as follows:
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; &nbsp; &nbsp; :     : 
&nbsp; &nbsp; return IoCallDriver(DeviceObject-&gt;NextDeviceObject, Irp); 
&nbsp;</FONT></PRE>
<P>
However, a higher-level driver cannot use the preceding technique if a lower
driver might return STATUS_PENDING for such a request. In these circumstances,
the higher-level driver should set its IoCompletion routine in the IRP. When
its IoCompletion routine is called with the IRP, it can check the I/O status
block to determine whether the IRP is still pending. If so, the IoCompletion
routine might retry the request or, possibly, call <B>IoMarkIrpPending</B>
with the IRP before it calls <B>IoCompleteRequest</B>&nbsp;and returns
STATUS_PENDING. A higher-level driver must not complete an IRP with
STATUS_PENDING unless it has called <B>IoMarkIrpPending</B>&nbsp;with that IRP
first. 
<P>
If the underlying device driver must process much data transferred from the
device before it completes the request, then a higher-level driver might
handle such a device control request asynchronously. That is, the higher-level
driver might set its IoCompletion routine in the IRP, pass the IRP on to lower
drivers, and return control from its own DispatchDeviceControl routine. 
<P>
Almost all system-defined I/O control codes require the underlying device
driver to transfer very modest amounts of data, usually far less than a
PAGE_SIZE amount. As a general rule, higher-level NT drivers should handle
these requests synchronously, as shown in the preceding code fragment, because
the lower drivers return control so quickly. That is, the overhead of calling
the higher-level driver’s IoCompletion routine does not compensate for
whatever additional IRP processing that driver can get done in such a short
interval. 
<P>
A higher-level NT driver that allocates IRPs with <B>IoBuildDeviceIoControlRequest</B>
for an underlying device driver can handle these device control requests
synchronously. Such a higher-level driver can wait on an optional <I>Event</I>,
passed to <B>IoBuildDeviceIoControlRequest</B>&nbsp;and associated with the
driver-allocated IRP. Such a driver must supply storage for the event object
and must initialize its <I>Event</I>&nbsp;with <B>KeInitializeEvent</B>&nbsp;before
calling <B>IoBuildDeviceIoControlRequest</B>&nbsp;with that <I>Event</I>&nbsp;pointer. 
<P></FONT>
</BODY>
</HTML>
