<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.1.2  Calling IoSetCompletionRoutine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Calling_IoSetCompletionRoutine_KG"></A>13.1.2  Calling IoSetCompletionRoutine</H3>
<P>
The most common uses for higher-level drivers’ IoCompletion routines are the
following: 
<UL>
<LI>
To dispose of IRPs that a higher-level driver has allocated with <B>IoAllocateIrp</B>
or <B>IoBuildAsynchronousFsdRequest</B>&nbsp;to send requests to lower drivers
<P>
Any higher-level driver that allocates an IRP with either of these support
routines <I>must</I>&nbsp;set its IoCompletion routine in such an IRP. The
IoCompletion routine <I>must</I>&nbsp;call <B>IoFreeIrp</B>&nbsp;to dispose of these
driver-allocated IRPs. 
<P>
<LI>
To reuse an incoming IRP to request that lower drivers complete some number of
operations, such as partial transfers, until the original request can be
satisfied and completed by the IoCompletion routine
<P>
<LI>
To retry a request that a lower driver completed with an error
<P>
Highest-level NT drivers, such as file systems, are more likely to have
IoCompletion routines that attempt to retry requests for which lower-level
drivers have returned an error status than are intermediate drivers, except
possibly class drivers layered above a closely coupled port driver.
Nevertheless, any NT intermediate driver can retry requests from its
IoCompletion routine(s) at the discretion of the driver designer. 
</UL>
<P>
In other words, an NT highest-level or intermediate driver’s DispatchReadWrite
routine usually determines whether a given IRP requires the driver to set up
an IoCompletion routine. At the discretion of the driver designer, such a
driver’s DispatchDeviceControl or other Dispatch routine(s) also can set up an
IoCompletion routine for any given IRP that is passed on to lower drivers.
<P>
For driver-allocated and reused IRPs, the Dispatch routine <I>must</I>&nbsp;call <B>IoSetCompletionRoutine</B>
with the following Boolean parameters:
<UL>
<LI>
<I>InvokeOnSuccess</I>&nbsp;set to TRUE
<P>
<LI>
<I>InvokeOnError</I>&nbsp;set to TRUE
<P>
<LI>
<I>InvokeOnCancel</I>&nbsp;set to TRUE if any lower driver in the chain might
handle cancelable IRPs 
<P>
Usually, <I>InvokeOnCancel</I>&nbsp;is set to TRUE, whether an IRP might be
returned with STATUS_CANCELLED or not, to ensure that the IoCompletion routine
frees each driver-allocated IRP or checks the completion status of each reuse
of an IRP. 
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>Consider the following
implementation guidelines for calling <B>IoSetCompletionRoutine</B>&nbsp;in
higher-level drivers’ Dispatch routines<B>&nbsp;</B>
<P>
<LI>
Any Dispatch routine that allocates IRPs for lower drivers with <B>IoAllocateIrp</B>
or <B>IoBuildAsynchronousFsdRequest</B>&nbsp;<I>must</I>&nbsp;set an IoCompletion
routine in each driver-allocated IRP. 
<P>
<UL>
<LI>
The Dispatch routine must set up state about the original IRP and the IRP(s)
it allocated for the IoCompletion routine to use. At a minimum, the
IoCompletion routine needs access to the original IRP and a count of how many
additional IRPs were allocated. 
<P>
<LI>
The Dispatch routine should call <B>IoSetCompletion Routine</B>&nbsp;with all <I>InvokeOnXxx</I>
parameters set to TRUE for the IRP(s) it allocates. 
<P>
<LI>
If it allocates an I/O stack location of its own in an IRP, the Dispatch
routine must call <B>IoSetNextIrpStackLocation</B>&nbsp;before it calls <B>IoGetCurrentIrpStackLocation</B>
to set up context in its own I/O stack location for the IoCompletion routine,
as mentioned in Chapter 6. 
<P>
<LI>
The Dispatch routine must call <B>IoMarkIrpPending</B>&nbsp;with the original IRP,
but not with any driver-allocated IRPs because the IoCompletion routine will
free them. 
<P>
<LI>
If the Dispatch routine is allocating IRPs for partial transfers and the
underlying device driver might control a removable-media device, the Dispatch
routine must set up the thread context in its newly allocated IRPs from the
value at <B>Tail.Overlay.Thread</B>&nbsp;in the original IRP. 
<P>
Such an underlying removable-media device driver might call <B>IoSetHardErrorOrVerifyDevice</B>,
which references the pointer at <B>Irp-&gt;Tail.Overlay.Thread</B>, with a
driver-allocated IRP. If the underlying device driver calls this support
routine, the file system driver can send a popup to the appropriate user
thread that prompts the user to cancel, retry, or fail the operation that the
device driver could not satisfy. 
<P>
For more information about handling removable media, see Chapter 16. 
<P>
<LI>
The Dispatch routine must return STATUS_PENDING after it has sent all
driver-allocated IRPs on to lower drivers. 
</UL>
<P>
The driver’s IoCompletion routine should free all driver-allocated IRPs with <B>IoFreeIrp</B>
before it calls <B>IoCompleteRequest</B>&nbsp;with the original IRP. When it
completes the original IRP, the IoCompletion routine must free all
driver-allocated IRPs before it returns control. 
<P>
<LI>
Any Dispatch routine must call <B>IoSetCompletionRoutine</B>&nbsp;with an IRP to be
reused for a sequence of operations or if the IoCompletion routine can retry
requests. 
<P>
<UL>
<LI>
The Dispatch routine must set up state about the original IRP for the
IoCompletion routine to use. 
<P>
For example, a DispatchReadWrite routine must save the relevant transfer
parameters of an input IRP for the IoCompletion routine before the
DispatchReadWrite routine sets up a partial tranfer for the next-lower driver
in that IRP, particularly if the DispatchReadWrite routine modifies any
parameters that the IoCompletion routine needs to determine when the original
request has been satisfied. 
<P>
If the IoCompletion routine can retry the request, the Dispatch routine must
set up a driver-determined upper limit on how many retries its IoCompletion
routine should attempt before it completes the original IRP with an error. 
<P>
<LI>
For a to-be-reused IRP, the Dispatch routine should call <B>IoSetCompletion
Routine</B>&nbsp;with all <I>InvokeOnXxx</I>&nbsp;parameters set to TRUE. 
<P>
<LI>
For an asynchronous request, the Dispatch routine of any intermediate driver
must call <B>IoMarkIrpPending</B>&nbsp;with the original IRP. 
<P>
<LI>
For an asynchronous request, the Dispatch routine of any intermediate driver
must return STATUS_PENDING after it has sent the IRP on to lower drivers. 
</UL>
<P>
The driver’s IoCompletion routine must maintain state about each reuse of an
IRP until the original request is satisfied (or failed) and then call <B>IoCompleteRequest</B>
with the IRP. The IoCompletion routine also might be responsible for
reinitializing the common state area, or notifying another driver routine to
dequeue the next IRP to be processed. 
<P>
An IoCompletion routine that retries IRPs must maintain the retry count to it
can determine when to fail an IRP if the requested operation cannot be
completed successfully. 
<P>
<LI>
Any Dispatch routine that allocates per-IRP resources for a type of request
that it passes on to lower drivers must call <B>IoSetCompletionRoutine</B>
with any IRP of that type. 
<P>
For example, if the Dispatch routine allocates an MDL with <B>IoAllocateMdl</B>
and calls <B>IoBuildPartialMdl</B>&nbsp;for a partial-transfer IRP it allocates,
the IoCompletion routine must release the MDL with <B>IoFreeMdl</B>. If it
allocates resources to maintain state about the original IRP, it must free
those resources, preferably before it calls <B>IoCompleteRequest</B>&nbsp;with the
original IRP and definitely before it returns control. 
<P>
In general, an IoCompletion routine should free any per-IRP resources such a
Dispatch routine allocated before the corresponding IRP is freed or completed.
Otherwise, the driver must maintain state about the resources to be freed
before its IoCompletion routine returns control from completing the original
request. 
<P>
<LI>
At the discretion of the driver writer, a Dispatch routine can call <B>IoSetCompletionRoutine</B>
with any other IRP that it passes on to lower drivers. 
</UL>
<P></FONT>
</BODY>
</HTML>
