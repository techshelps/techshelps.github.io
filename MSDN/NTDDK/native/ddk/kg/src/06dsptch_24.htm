<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.4.3  Dispatch(Internal)DeviceControl in Class/Port Drivers</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Dispatch_Internal_DeviceControl_in_Class_Port_Drivers_KG"></A>6.3.4.3  Dispatch(Internal)DeviceControl in Class/Port Drivers</H4>
<P>
The higher-level driver of a class/port pair can sometimes complete IRPs in
its DispatchDeviceControl routine. For example, if a class driver gathers and
stores information about the features of the underlying device during
initialization, which might be sought in a subsequent IRP_MJ_DEVICE_CONTROL
request, that class driver might satisfy such a request without passing it on
to the underlying device driver to save processing time. Depending on the
designer, a class driver also might check the IRP’s parameters for its paired
port driver so that it could send down only requests with valid parameters.
<P>
Closely coupled class/port drivers also can define a set of driver- and/or
device-specific I/O control codes that the class driver uses to set up IRPs
for IRP_MJ_INTERNAL_DEVICE_CONTROL requests to the port driver. 
<P>
For example, the system keyboard and mouse class drivers send system-defined
internal device control requests to enable/disable keyboard/mouse interrupts
to the underlying port driver(s) from each class driver’s DispatchCreateClose
routine. These system class drivers handle IRP_MJ_DEVICE_CONTROL requests by
setting up IRP_MJ_INTERNAL_DEVICE_CONTROL requests for an underlying port
driver. Any new keyboard or mouse port driver that interoperates with these
system class drivers also must support these public internal device control
requests.
<P>
The system parallel class/port driver model has similar features. New parallel
class drivers can get support from the system parallel port driver by setting
up IRPs for IRP_MJ_INTERNAL_DEVICE_CONTROL requests with public
IOCTL_PARALLEL_PORT_<I>XXX</I>&nbsp; control codes. NT driver writers can replace
the system parallel port driver, but such a new driver also <I>must</I>
support this set of public internal device control requests. 
<P>
For more information about these public internal device control requests and
about how to define private I/O control codes for new class/port drivers, see
the <I>Kernel-mode Driver Reference</I>. 
<P>
For a closely coupled pair of port/class drivers, the class driver might
handle the processing of certain device control requests without passing them
on to the port driver. The designer of a new class/port driver pair can
implement the class driver’s DispatchDeviceControl routine to do either of the
following:
<UL>
<LI>
Check the validity of the parameters in its own I/O stack location in the IRP,
set the I/O status block if it finds any parameter errors, and call <B>IoCompleteRequest</B>
with the IRP and a <I>PriorityBoost</I>&nbsp;of IO_NO_INCREMENT; otherwise, call <B>IoGetNextIrpStackLocation</B>,
copy its own I/O stack location into the port driver’s, and pass the IRP on
with <B>IoCallDriver</B>.
<P>
<LI>
Or, do nothing more than set up the port driver’s I/O stack location in the
IRP without checking parameters and pass it on to the port driver for
processing.
</UL>
<P>
NT SCSI class drivers have special requirements for handling device control
requests. For more information about these requirements, see <A HREF="appascsi.htm">Appendix
A</A>.
<P></FONT>
</BODY>
</HTML>
