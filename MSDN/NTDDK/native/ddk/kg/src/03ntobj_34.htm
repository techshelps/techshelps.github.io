<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.8.2  Setting up an Interlocked Queue and Queueing IRPs</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Setting_up_an_Interlocked_Queue_and_Queueing_IRPs_KG"></A>3.8.2  Setting up an Interlocked Queue and Queueing IRPs</H3>
<P>
NT drivers with device-dedicated threads or drivers that use executive worker
threads, such as most system FSDs, are the most likely types of NT drivers to
manage their own internal queueing of IRPs in an interlocked queue. Usually,
these drivers set up a doubly linked interlocked queue because the driver can
requeue IRPs for retry operations in a doubly linked interlocked queue. An NT
driver cannot requeue IRPs for retries if it sets up a singly linked
interlocked queue.
<P>
<A NAME="DDK_Figure_3.22_KG"></A>Such a driver must set up its interlocked queue
when it initializes. Figure 3.22 illustrates a doubly linked interlocked
queue, the support routines the <B>DriverEntry</B>&nbsp;routine must call to set up
such a queue, and a set of <B>ExInterlocked</B><I>Xxx</I>&nbsp;routines an NT
driver can call to insert IRPs into and remove IRPs from the queue.
<P>
<B><IMG SRC="../art/3intlokq.gif" BORDER=0></B>
<P>
<B>Figure 3.22    Using an Interlocked Queue</B>
<P>
As Figure 3.22 shows, a driver must provide the storage for the queue itself
and for the following in order to set up a doubly linked interlocked queue:
<UL>
<LI>
An ExecutiveSpinLock that the <B>DriverEntry</B>&nbsp;routine must initialize by
calling <B>KeInitializeSpinLock</B>
<P>
<LI>
The ListHead for the queue that the <B>DriverEntry</B>&nbsp;routine must initialize
by calling <B>InitializeListHead</B>, which is one of the NT kernel-mode
runtime library routines, even though this routine does not have the <B>Rtl</B>
prefix
</UL>
<P>
Most NT drivers that use interlocked queues provide the necessary storage in
the device extension of a driver-created device object, but such a queue and
executive spin lock can be in a controller extension if the driver uses a
controller object (see <A HREF="03ntobj_20.htm">Section 3.4</A>) or in
nonpaged pool allocated by the driver.
<P>
A queue with a ListHead of type LIST_ENTRY, as shown in Figure 3.22, is a
doubly linked list. One with a ListHead of type SINGLE_LIST_ENTRY is a singly
linked list. The <B>DriverEntry</B>&nbsp;routine initializes the ListHead for a
singly linked interlocked queue by setting it to NULL.
<P>
After such a driver is loaded, it can insert an IRP into its queue by calling
either of the following support routines if the <I>ListHead</I>&nbsp;is of type
LIST_ENTRY, as shown in Figure 3.22:
<UL>
<LI>
<B>ExInterlockedInsertTailList</B>&nbsp;to place the IRP at the end of the queue
<P>
<LI>
<B>ExInterlockedInsertHeadList</B>&nbsp;to place the IRP at the front of the queue,
which drivers usually call only when they must retry a particular request
</UL>
<P>
The driver must pass pointers to the IRP (<I>ListEntry</I>), as well the <I>ListHead</I>
and ExecutiveSpinLock (<I>Lock</I>) pointers that were initialized by the <B>DriverEntry</B>
routine, to each of these <B>ExInterlockedInsert..List</B>&nbsp;routines. It must
pass pointers only to the <I>ListHead</I>&nbsp;and <I>Lock</I>&nbsp;when the driver
dequeues an IRP by calling <B>ExInterlockedRemoveHeadList</B>.
<P>
A driver that never retries operations can use <B>ExInterlockedPushEntryList</B>
and <B>ExInterlockedPopEntryList</B>&nbsp;to manage its queueing of IRPs internally
in a singly linked interlocked queue. Any driver that uses such an interlocked
queue also must provide resident storage for the queue, for a ListHead of type
SINGLE_LIST_ENTRY, and for an ExecutiveSpinLock, as shown in Figure 3.22, and
must set up its queue in a similar manner when the driver initializes.
<P>
Because its interlocked queue is protected by the executive spin lock, the
driver can insert IRPs into its queue and remove them in a multiprocessor-safe
manner from any driver routine running at less than or equal to IRQL
DISPATCH_LEVEL.
<P>
For more information about managing IRQLs and using spin locks, see Chapter
16. For support-routine-specific IRQL requirements, see the <I>Kernel-Mode</I><B>
</B><I>Driver Reference</I>.
<P></FONT>
</BODY>
</HTML>
