<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.9.3  Semaphore Objects</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Semaphore_Objects_KG"></A>3.9.3  Semaphore Objects</H3>
<P>
Any NT driver can use a semaphore object to synchronize operations between its
driver-created thread(s) and other driver routines. For example, a
driver-dedicated thread might put itself into a wait state when there are no
outstanding I/O requests for the driver, and the driver’s Dispatch routines
might set the semaphore to the Signaled state just after they queue an IRP.
<P>
The Dispatch routines of highest-level NT drivers, which are run in the
context of the thread requesting an I/O operation, might use a semaphore to
protect a resource shared among the Dispatch routines. Lower-level driver
Dispatch routines for synchronous I/O operations also might use a semaphore to
protect a resource shared among that subset of Dispatch routines or with a
driver-created thread.
<P>
<A NAME="DDK_Figure_3.25_KG"></A>Any NT driver that uses a semaphore object must
call <B>KeInitializeSemaphore</B>&nbsp;before it waits on or releases the
semaphore. Figure 3.25 illustrates how a driver with a thread can use a
semaphore object.
<P>
<B><IMG SRC="../art/3semobj.gif" BORDER=0></B>
<P>
<B>Figure 3.25    Waiting on a Semaphore Object</B>
<P>
As Figure 3.25 shows, such a driver must provide the storage for the semaphore
object, which should be resident. The driver can use the device extension of a
driver-created device object (see <A HREF="03ntobj_2.htm">Section
3.2</A>), the controller extension if it uses a controller object (see <A HREF="03ntobj_20.htm">Section
3.4</A>), or nonpaged pool allocated by the driver.
<P>
When the <B>DriverEntry</B>&nbsp;or Reinitialize routine calls <B>KeInitializeSemaphore</B>,
it must pass a pointer to the driver’s resident storage for the semaphore
object. In addition, the caller must specify a <I>Count</I>&nbsp;for the semaphore
object, as shown in Figure 3.25, that determines its initial state (nonzero
for Signaled).
<P>
The caller also must specify a <I>Limit</I>&nbsp;for the semaphore, which can be
either of the following:
<UL>
<LI>
<B><I>Limit</I>&nbsp;= 1</B>
<P>
When such a semaphore is set to the Signaled state, a single thread waiting on
the semaphore becomes eligible for execution and can access whatever resource
is protected by the semaphore.
<P>
This type of semaphore is also called a <I>binary semaphore</I>&nbsp;because a
thread either does or does not have exclusive access to the
semaphore-protected resource.
<P>
<LI>
<B><I>Limit</I>&nbsp;&gt; 1</B>
<P>
When such a semaphore is set to the Signaled state, some number of threads
waiting on the semaphore object become eligible for execution and can access
whatever resource is protected by the semaphore.
<P>
This type of semaphore is called a <I>counting semaphore</I>&nbsp;because the
routine that sets the semaphore to the Signaled state also specifies how many
waiting threads can have their states changed from waiting to ready, which can
be the <I>Limit</I>&nbsp;set when the semaphore was initialized or some number less
than this preset <I>Limit</I>.
</UL>
<P>
Very few NT device or intermediate drivers have a single driver-created
thread, let alone a set of threads that might wait on a semaphore. Few
system-supplied drivers use semaphore objects, and, of those that do, even
fewer use a binary semaphore. A binary semaphore, while seeming to have
similar functionality to a mutex object, does not provide the built-in
protection agains deadlocks that a mutex object has for system threads running
in SMP machines. For more information about mutex objects, see <A HREF="03ntobj_39.htm">Section
3.9.4</A>, next.
<P>
After a driver with an initialized semaphore is loaded, it can synchronize
operations on the semaphore that protects a shared resource. For example, a
driver with a device-dedicated thread that manages the queueing of IRPs, such
as the system floppy controller driver, might synchronize IRP queueing on a
semaphore, as shown in Figure 3.25:
<OL>
<LI>
The thread calls <B>KeWaitForSingleObject</B>&nbsp;with a pointer to the the
driver-supplied storage for the initialized semaphore object to put itself
into a wait state.
<P>
<LI>
IRPs begin to come in that require device I/O operations. The driver’s
Dispatch routines insert each such IRP into an interlocked queue (see <A HREF="03ntobj_34.htm">Section
3.8.2</A>) under spin-lock control and call <B>KeReleaseSemaphore</B>&nbsp;with a
pointer to the semaphore object, a driver-determined priority boost for the
thread (<I>Increment</I>, as shown in Figure 3.25), an <I>Adjustment</I>&nbsp;of
one that is added to the semaphore’s Count as each IRP is queued, and a
Boolean <I>Wait</I>&nbsp;set to FALSE. A nonzero semaphore Count sets the semaphore
object to the Signaled state, thereby changing the waiting thread’s state to
ready.
<P>
<LI>
The Kernel dispatches the thread for execution as soon as a processor is
available: that is, no other thread with a higher priority is currently in the
ready state and there are no kernel-mode routines to be run at raised IRQL
(greater than PASSIVE_LEVEL).
<P>
The thread removes an IRP from the interlocked queue under spin-lock control,
passes it on to other driver routines for further processing, and calls <B>KeWaitForSingleObject</B>
again. If the semaphore is still set to the Signaled state (that is, its Count
remains nonzero, indicating that more IRPs are in the driver’s interlocked
queue), the Kernel again changes the thread’s state from waiting to ready.
<P>
By using a counting semaphore in this manner, such a driver thread “knows”
there is an IRP to be removed from the interlocked queue whenever that thread
is run.
</OL>
<P>
Calling <B>KeReleaseSemaphore</B>&nbsp;with the <I>Wait</I>&nbsp;parameter set to TRUE
indicates the caller’s intention to immediately call a <B>KeWait..Object(s)</B>
support routine on return from <B>KeReleaseSemaphore</B>.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; NT driver writers should consider the following guidelines for setting the <I>Wait</I>&nbsp;parameter to KeReleaseSemaphore: </H5>
<P>
A pageable thread or pageable driver routine that runs at IRQL PASSIVE_LEVEL
should <I>never</I>&nbsp;call <B>KeReleaseSemaphore</B>&nbsp;with the <I>Wait</I>
parameter set to TRUE. Such a call causes a fatal page fault if the caller
happens to be paged out between the calls to <B>KeReleaseSemaphore</B>&nbsp;and <B>KeWait..Object(s)</B>.
<P>
Any standard driver routine that runs at an IRQL greater than PASSIVE_LEVEL <I>cannot</I>
wait for a nonzero interval on any dispatcher object(s) without bringing down
the system (see <A HREF="03ntobj_35.htm">Section 3.9</A>).
However, such a routine can call <B>KeReleaseSemaphore</B>&nbsp;while running at an
IRQL less than or equal to DISPATCH_LEVEL.
<P>
For a summary of the IRQLs at which standard NT driver routines run, see
Chapter 16. For support-routine-specific IRQL requirements, see the <I>Kernel-Mode
Driver Reference</I>.
<P></FONT>
</BODY>
</HTML>
