<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>9.2.3  Points to Consider in Implementing a DpcForIsr or CustomDpc Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Points_to_Consider_in_Implementing_a_DpcForIsr_or_CustomDpc_Routine_KG"></A>9.2.3  Points to Consider in Implementing a DpcForIsr or CustomDpc Routine</H3>
<P>
Keep the following points in mind when implementing a DpcForIsr or CustomDpc
routine:
<UL>
<LI>
A DpcForIsr or CustomDpc routine must synchronize its access to a physical
device and to any shared state information or resources that the driver
maintains in the device extension with the driver’s other routines that access
the same device or memory location. 
<P>
If the DpcForIsr or CustomDpc shares the device or state with the ISR, it must
call <B>KeSynchronizeExecution</B>&nbsp;with a driver-supplied SynchCritSection
routine to program the device or to access the shared state. 
<P>
If the DpcForIsr or CustomDpc shares state or resources, such as an
interlocked queue or a timer object, with routines other than the ISR, it must
protect the shared state or resources with a driver-initialized executive spin
lock for which the driver provides resident storage.
<P>
<LI>
DpcForIsr or CustomDpc routines run at IRQL DISPATCH_LEVEL, which restricts
the set of support routines they can call. 
<P>
For example, a DpcForIsr or CustomDpc routine can neither access nor allocate
pageable memory, and it cannot wait on a dispatcher object. On the other hand,
a DpcForIsr or CustomDpc routine can acquire and release a driver’s executive
spin lock with <B>KeAcquireSpinLockAtDpcLevel</B>&nbsp;and <B>KeReleaseSpinLockFromDpcLevel</B>,
which run faster than <B>KeAcquireSpinLock</B>&nbsp;and <B>KeReleaseSpinLock</B>.
<P>
<LI>
A DpcForIsr or CustomDpc routine is responsible for starting the next I/O
operation on the device.
<P>
For device drivers that use direct I/O, this responsibility can include using
a SynchCritSection routine to program the device to transfer more data in
order to satisfy the current IRP <I>before</I>&nbsp; the driver calls <B>IoStartNextPacket</B>.
<P>
<LI>
If a device driver sets up a controller object in its DriverEntry routine to
synchronize I/O operations through the controller to attached devices, its
DpcForIsr or CustomDpc routine is responsible for releasing the controller
object with <B>IoFreeController</B>&nbsp;before it completes the current IRP and
returns control.
<P>
<LI>
If the driver uses DMA and its AdapterControl routine returns <B>KeepObject</B>
or <B>DeallocateObjectKeepRegisters</B>&nbsp;(thereby retaining the system DMA
controller channel or busmaster adapter for additional transfer operations),
the driver’s DpcForIsr or CustomDpc routine is responsible for releasing the
adapter object or map registers with <B>IoFreeAdapterChannel</B>&nbsp;or <B>IoFreeMapRegisters</B>
<I>before</I>&nbsp; it completes the current IRP and returns control.
<P>
<LI>
A DpcForIsr or CustomDpc routine is generally responsible for logging any
device errors that occurred during the processing of a given request, retrying
the current request if necessary (and also possible), and for setting the I/O
status block and calling <B>IoCompleteRequest</B>&nbsp;with the current IRP.
<P>
<LI>
The DpcForIsr or CustomDpc of a driver that overlaps operations on its device
cannot rely on a one-to-one correspondence between requests input to the
StartIo routine and the ISR’s calls to <B>IoRequestDpc</B>&nbsp;or<B>
KeInsertQueueDpc</B>. In other words, such a driver’s DpcForIsr or CustomDpc
cannot necessarily use the input pointers to the IRP and ISR-supplied context,
nor the <B>CurrentIrp</B>&nbsp;pointer in the target device object, to complete
only that IRP.
<P>
At any given moment, the same DPC object cannot be queued twice. If the ISR of
such a driver calls <B>IoRequestDpc</B>&nbsp;or <B>KeInsertQueueDpc</B>&nbsp;more than
once before the corresponding DpcForIsr or CustomDpc executes, only one
instantiation of that DPC routine is run as soon as the IRQL on a processor
falls below DISPATCH_LEVEL. On the other hand, if the ISR calls <B>IoRequestDpc</B>
or <B>KeInsertQueueDpc</B>&nbsp;while the corresponding DpcForIsr or CustomDpc is
running on another processor, two instantiations of that DPC routine can run
concurrently. 
<P>
Therefore, any NT driver that overlaps interrupt-driven I/O operations on its
device must have the following functionality:
<P>
<UL>
<LI>
A DpcForIsr or CustomDpc that can complete some driver-maintained count of
outstanding requests when it is called
<P>
<LI>
An ISR that never overwrites its saved context for an interrupt-driven I/O
operation until the DpcForIsr or CustomDpc has consumed that context
information and completed the IRP for which the context was saved
<P>
<LI>
A SynchCritSection routine that accesses the ISR’s context area on behalf of
the DpcForIsr or CustomDpc routine
</UL>
</UL>
<P>
For more information about SynchCritSection routines, see Chapter 10. For more
information about ControllerControl and AdapterControl routines, see Chapter
11. For more information about any particular support routine mentioned in
this section, see the <I>Kernel-mode Driver Reference</I>.
<P>
&nbsp;
<P></FONT>
</BODY>
</HTML>
