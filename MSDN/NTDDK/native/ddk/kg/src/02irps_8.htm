<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>2.3.3  Other Standard NT Driver Routines</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Other_Standard_NT_Driver_Routines_KG"></A>2.3.3  Other Standard NT Driver Routines</H3>
<P>
As Figure 2.4 shows, NT drivers have other standard routines along with those
for which they set entry points in their respective driver objects. Most
standard driver routines and some of the configuration-dependent objects they
use are defined by the I/O Manager. The ISR, SynchCritSection routine, and
those shown in <A HREF="02irps_5.htm#DDK_Figure_2..4_KG">Figure 2.4</A>&nbsp;with names containing
the word “custom” are defined by the NT Kernel.
<P>
With few exceptions (SCSI and video miniport drivers), each NT driver’s
DriverEntry routine must also create one or more device objects representing
the physical, logical, or virtual device(s) for which it carries out I/O
requests. As Figure 2.4 shows, the I/O Manager maintains information about
driver-created device objects in the corresponding driver object.
<P>
Most NT drivers use the device extension of each device object they create to
maintain device-specific state about their I/O operations and to store
pointers to any system resources that they must allocate in order to have
other standard routines. For example, the DDCustomTimerDpc routine shown in <A HREF="02irps_5.htm#DDK_Figure_2..4_KG">Figure
2.4</A>&nbsp;requires the driver to supply storage for Kernel-defined timer and DPC
objects.
<P>
As mentioned in <A HREF="02irps_3.htm">Section
2.2</A>, the set of standard driver routines for lowest-level drivers shown on the
left in Figure 2.4 is necessarily different from the set for higher-level
drivers. Some of the routines shown in <A HREF="02irps_5.htm#DDK_Figure_2..4_KG">Figure 2.4</A>
are device-dependent or configuration-dependent requirements. Others are
optional: a driver writer may choose to implement such a routine depending on
the nature or configuration of the driver’s device(s), on the driver’s design,
and on the driver’s position in a chain of layered NT drivers.
<P>
In addition to the Dispatch, StartIo, and Unload routines for which NT drivers
set entry points in their respective driver objects, the system-defined
standard NT driver routines include the following:
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>Standard Routine</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>NT Driver Level</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
InterruptService
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
lowest-level only
</FONT></TABLE>
<P>
Drivers for physical devices that generate interrupts must have an ISR. The
ISR must stop the device from interrupting. Then, it should do only what is
necessary to save state and queue a DPC to complete interrupt-driven I/O
operations at a lower hardware priority (IRQL) than that at which the ISR
executes.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
DpcForIsr
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
lowest-level only
</FONT></TABLE>
<P>
Drivers that have an ISR also should have a DPC, either a DpcForIsr or one or
more CustomDpc routines, to complete interrupt-driven I/O operations.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
SynchCritSection
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
lowest-level only
</FONT></TABLE>
<P>
Any device driver whose routines share data or device registers with its ISR
must have one or more SynchCritSection routines to access the shared data or
registers in a multiprocessor-safe manner.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Cancel
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
any level (highest driver in any chain)
</FONT></TABLE>
<P>
Drivers in which IRPs might remain queued for an indefinite interval (so a
user could cancel a previously submitted I/O request) must have one or more
Cancel routines to complete user-cancelled I/O requests. Examples of NT
drivers that should have Cancel routines are keyboard, mouse, parallel,
serial, and sound device drivers (or drivers layered over them), and file
system drivers.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
AdapterControl
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
lowest-level only
</FONT></TABLE>
<P>
Any driver whose device uses system DMA must have an AdapterControl routine in
order to carry out transfer operations through a system DMA controller between
its device and system physical memory. Any driver whose DMA device is a
nonSCSI busmaster usually must have an AdapterControl routine.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
ControllerControl
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
lowest-level only
</FONT></TABLE>
<P>
A device driver that must synchronize operations through a physical
controller, such as an “AT” disk controller, to similar devices can have a
ControllerControl routine.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
IoCompletion
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
intermediate or highest-level
</FONT></TABLE>
<P>
Higher-level drivers that monitor on an IRP-specific basis how lower-level
drivers carried out particular requests can have one or more IoCompletion
routines. Higher-level drivers that allocate IRPs to send requests to lower
drivers must have an IoCompletion routine. See <A HREF="02irps_3.htm">Section
2.2</A>&nbsp;for a description of how higher-level drivers can use an IoCompletion
routine.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
IoTimer
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
any level
</FONT></TABLE>
<P>
Drivers that need to be called periodically to determine if a device operation
has timed out, to update some driver-defined variable (such as a counter), or
for some other reason can have an IoTimer routine. An IoTimer routine is
actually a DPC routine, associated with a device object, that the I/O Manager
calls once per second. An NT driver can have an IoTimer routine for each
device object that it creates.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
CustomTimerDpc
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
any level
</FONT></TABLE>
<P>
Drivers that need to be called periodically at finer-grained intervals than
once per second or at variable intervals can have a CustomTimerDpc routine,
rather than an IoTimer routine. NT drivers also can have one or more
CustomTimerDpc routines in addition to their IoTimer routines.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
CustomDpc
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
lowest-level only
</FONT></TABLE>
<P>
Any driver that needs to finish an interrupt-driven I/O operation later at a
lower hardware priority (IRQL) can have a CustomDpc routine. Few lowest-level
drivers have CustomDpc routines to be queued from their ISRs unless their
devices require more than one DpcForIsr routine to complete a varied set of
interrupt-driven I/O operations.
<P>
Note that the CustomTimerDpc and IoTimer routines shown in <A HREF="02irps_5.htm#DDK_Figure_2..4_KG">Figure
2.4</A>&nbsp;are actually system-defined CustomDpc routines that execute after a system
clock interrupt occurs.
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
Reinitialize
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
any level
</FONT></TABLE>
<P>
Any driver that needs to intialize itself in stages can have a Reinitialize
routine. A Reinitialize routine is called after the DriverEntry routine has
returned control and other NT drivers have initialized themselves.
<P>
By convention, the system-supplied NT drivers prepend an identifying, driver-
or device-specific prefix to the name of every standard routine except
DriverEntry, shown in <A HREF="02irps_5.htm#DDK_Figure_2..4_KG">Figure 2.4</A>&nbsp;as “DD.”
Following this convention makes it easier to debug and maintain NT drivers.
<P></FONT>
</BODY>
</HTML>
