<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>12.4  Points to Consider In Handling Cancelable IRPs</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Points_to_Consider_In_Handling_Cancelable_IRPs_KG"></A>12.4  Points to Consider In Handling Cancelable IRPs</H2>
<P>
Keep the following points in mind when implementing a Cancel routine and
handling cancelable IRPs:
<UL>
<LI>
A Cancel routine is called with the cancel spin lock already held, so it must
call <B>IoReleaseCancelSpinLock</B>&nbsp;before it returns control. It must not
call <B>IoAcquireCancelSpinLock</B>&nbsp;unless it calls <B>IoReleaseCancelSpinLock</B>
first, and it must make a reciprocal call to <B>IoReleaseCancelSpinLock</B>
for each call it makes to <B>IoAcquireCancelSpinLock</B>.
<P>
<LI>
Unless a driver manages its own internal queue(s) of IRPs, its Cancel routine
is called with an incoming IRP that could be either of the following:
<P>
<UL>
<LI>
The <B>CurrentIrp</B>&nbsp;in the input target device object
<P>
<LI>
An entry in the device queue associated with the target device object
</UL>
<P>
<LI>
Unless a driver manages its own internal queues of IRPs, its Cancel routine
should call <B>KeRemoveEntryDeviceQueue</B>&nbsp;with the input IRP to test whether
it is an entry in the device queue associated with the target device object.
Such a driver’s Cancel routine <I>cannot</I>&nbsp;call <B>KeRemoveDeviceQueue</B>
or <B>KeRemoveByKeyDeviceQueue</B>&nbsp;because it cannot assume that the given IRP
is at any particular position in the device queue.
<P>
<LI>
If a driver does manage its own internal queue of IRPs and has a Cancel
routine, the queue must be protected by an executive spin lock. Such a queue
should be an interlocked queue so the driver can use the <B>ExInterlocked..List</B>
routines.
<P>
<LI>
If a Cancel routine is called with an IRP for which the driver has already
started I/O processing and the request will be completed soon, the Cancel
routine should release the system cancel spin lock and return control.
<P>
<LI>
Provided that the current state of the input IRP is pending, a Cancel routine
must do the following:
<P>
<OL>
<LI>
Set the input IRP’s I/O status block with STATUS_CANCELLED for <B>Status</B>
and zero for <B>Information</B>.
<P>
<LI>
Release any spin locks it is holding, including the system cancel spin lock.
<P>
<LI>
Call <B>IoCompleteRequest</B>&nbsp;with the given IRP.
</OL>
<P>
<LI>
Any driver routine that passes IRPs on for further processing by other driver
routines when an IRP might be held in a cancelable state must call <B>IoSetCancelRoutine</B>
to set its entry point for the Cancel routine in the IRP. Only then can that
driver routine call any support routine that causes the IRP to be held in a
cancelable state, such as <B>IoStartPacket</B>, <B>IoAllocateController</B>,
or an <B>ExInterlockedInsert..List</B>&nbsp;routine.
<P>
<LI>
Any driver routine that subsequently processes cancelable IRPs must check
whether an IRP has already been cancelled before it begins operations to
satisfy the request. Such a routine must call <B>IoSetCancelRoutine</B>&nbsp;to
reset its entry point for the Cancel routine to NULL in the . Only then can
that routine begin its I/O processing for the input IRP.
<P>
Note that such a routine might have to reset the entry point for a Cancel
routine in an IRP if it, too, passes IRPs on for further processing by other
driver routines and those IRPs might be held in a cancelable state.
<P>
<LI>
Any higher-level driver that holds IRPs in a cancelable state must reset its
Cancel entry point to NULL before it passes an IRP on to the next-lower driver
with <B>IoCallDriver</B>.
<P>
<LI>
Any higher-level driver can call <B>IoCancelIrp</B>&nbsp;with an IRP that it has
allocated and passed on for further processing by lower-level driver(s).
However, such a driver cannot assume that the given IRP will be completed with
STATUS_CANCELLED by lower driver(s).
<P>
<LI>
A driver can (or must, depending on its design) maintain additional state
information in its device extension to track the cancelable status of IRPs. If
this state is shared by driver routines running at IRQL &lt;= DISPATCH_LEVEL,
the shared data can be protected with a driver-allocated and initialized
executive spin lock.
<P>
Such a driver should manage its acquisitions and releases of the system cancel
spin lock and its own executive spin lock(s) carefully, and it should be
designed to hold the system cancel spin lock for the shortest possible
interval(s).
<P>
<LI>
If a device driver maintains state information about cancelable IRPs that
various driver routines share with its ISR, these other routines must
synchronize access to the shared state with the ISR. Only a driver-supplied
SynchCritSection routine can access such shared-with-the-ISR state in a
multiprocessor-safe way.
</UL>
<P>
For more information about using spin locks, see Chapter 16. See Chapters 8
and 10, respectively, for more information about ISRs and SynchCritSection
routines.
<P>
&nbsp;
<P></FONT>
</BODY>
</HTML>
