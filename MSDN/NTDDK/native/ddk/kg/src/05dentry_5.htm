<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.2.1  Device Driver’s Initialization</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Device_Drivers_Initialization_KG"></A>5.2.1  Device Driver’s Initialization</H3>
<P>
The DriverEntry routine of an NT device driver should initialize in the
following stages:
<OL>
<LI>
Allocate memory to hold the hardware configuration information necessary to
communicate with its device(s).
<P>
<LI>
Gather hardware configuration information for the physical device(s) from the
registry, from the I/O bus(es) in the machine, and/or by interrogating the
device on the bus; otherwise, the driver must supply a set of default hardware
configuration values for its device(s).
<P>
<LI>
Set the driver’s Dispatch, StartIo (if any), and Unload (if any) entry points
in the given driver object.
<P>
<LI>
Attempt to claim the hardware resources that the driver uses to carry out
device I/O operations, such as device memory, bus-relative interrupt vector,
and so forth, in the registry.
<P>
<LI>
If the driver can claim the hardware resources it needs in the registry,
initialize the physical device(s) and set up the NT objects and any other
resources, such as spin locks, that the driver will use to process device I/O
requests.
<P>
<LI>
If the driver succeeds in initializing its device(s) and setting up all the
resources it needs to process IRPs to its device(s), free the memory it
allocated to hold configuration information, or possibly call <B>IoRegisterDriverReinitialization</B>
passing a <I>Context</I>&nbsp;pointer to the configuration information, and return
STATUS_SUCCESS.
<P>
Otherwise, free any objects and system resources it allocated, including the
memory it used to hold configuration information, and return an appropriate
NTSTATUS error.
</OL>
<H4><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Every NT device driver writer should consider the following guidelines when implementing a DriverEntry routine: </H4>
<UL>
<LI>
<I>Never</I>&nbsp;attempt to initialize a physical device without claiming the
necessary bus-relative I/O ports, memory ranges, interrupt, and/or DMA
channel/port hardware resources in the registry first.
<P>
Every NT device driver must call <B>IoAssignResources</B>, <B>IoReportResourceUsage,</B>
or<B>&nbsp;HalAssignSlotResources</B>&nbsp;and attempt to claim the bus-relative
hardware resources for a device <I>before</I>&nbsp;the driver attempts to
initialize that device. If there is no conflicting claim on the given hardware
resources, the driver’s claims are written in the <B>\Registry\Machine\Hardware\ResourceMap</B>
tree.
<P>
Claiming hardware resources in the registry prevents resource conflicts
between NT drivers and between devices in the machine. In other words, a
successful claim on a set of hardware resources prevents a subsequently loaded
driver from “stealing” an already loaded driver’s hardware resources and from
resetting that driver’s already initialized device.
<P>
<LI>
Hardware resource specifications written under the registry <B>\ResourceMap</B>
tree are the bus-relative “physical” range, interrupt, and/or DMA values
returned by <B>IoQueryDeviceDescription</B>, <B>HalGetBusData</B>, <B>HalGetBusDataByOffset</B>,
or similar driver-supplied bus-relative values. They are <I>not</I>&nbsp;the mapped
system values returned by <B>HalTranslateBusAddress</B>&nbsp;and/or <B>MmMapIoSpace</B>
that a driver can use to communicate with its device, nor the mapped
vector/IRQL returned by <B>HalGetInterruptVector</B>&nbsp;that the driver uses to
register its ISR with <B>IoConnectInterrupt</B>.
<P>
<LI>
An NT device driver’s ISR should be capable of determining whether it has been
called with a spurious interrupt <I>even during the driver’s initialization</I>.
On return from the DriverEntry’s call to <B>IoConnectInterrupt</B>, the ISR
can be called immediately if interrupts are enabled on the device or if the
driver shares a vector or IRQL with other devices.
<P>
<LI>
Because the DriverEntry routine runs in a system thread context at IRQL
PASSIVE_LEVEL, any memory allocated with <B>ExAllocatePool</B>&nbsp;for use
exclusively during initialization can be from paged pool, as long as the
driver does not control the device that holds the system page file. Such a
memory allocation must be released with <B>ExFreePool</B>&nbsp;before DriverEntry
returns control unless the driver passes a pointer to this memory in a call to
<B>IoRegisterDriverReinitialization</B>, making the driver’s Reinitialize
routine responsible for freeing the memory allocation.
<P>
<LI>
If the driver has a Reinitialize routine, its DriverEntry routine must not
call <B>IoRegisterDriverReinitialization</B>&nbsp;unless it will return
STATUS_SUCCESS.
</UL>
<P></FONT>
</BODY>
</HTML>
