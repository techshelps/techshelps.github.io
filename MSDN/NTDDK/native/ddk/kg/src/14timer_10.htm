<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>14.2.2  Using CustomTimerDpc Routines</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Using_CustomTimerDpc_Routines_KG"></A>14.2.2  Using CustomTimerDpc Routines</H3>
<P>
As already mentioned in <A HREF="14timer_5.htm">Section
14.1.2</A>, an NT driver must call <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>&nbsp;with
pointers to its timer and DPC objects and with an expiration time to have the
driver’s CustomTimerDpc routine queued for execution when the given <I>DueTime</I>
arrives.
<P>
The expiration time is specified in units of 100 nanoseconds, with negative
values indicating an interval relative to the current system time. When <I>DueTime</I>
arrives, the CustomTimerDpc routine can be called.
<P>
The elapsed time until a driver’s CustomTimerDpc routine begins execution can
be somewhat longer than the <I>DueTime</I>&nbsp;interval specified when the driver
called <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>. The NT Kernel queues the
given <I>Dpc</I>&nbsp;at the expiration of the timer interval.
<P>
If the system time changes before a timer expires, relative timers are not
affected but the system adjusts absolute timers. A relative timer always
expires after the specified number of time units elapses, regardless of the
absolute system time. An absolute timer expires at a specific system time, so
a change in the system time changes the wait duration of an absolute timer.
<P>
A driver can associate a CustomTimerDpc routine with a timer in the call to <B>KeSetTimer</B>
and the routine will be called after the timer expires. To set a recurring
timer use <B>KeSetTimerEx</B>&nbsp;which accepts the same parameters as <B>KeSetTimer</B>
plus an additional <I>Period</I>&nbsp;parameter.
<P>
If a driver routine calls <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>&nbsp;with a <I>Dpc</I>
pointer for its CustomTimerDpc routine, a subsequent call to <B>KeCancelTimer</B>
with the same <I>Timer</I>&nbsp;pointer has one of the following effects:
<UL>
<LI>
If the most recently specified interval passed to <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>
has not yet expired, the timer object and the DPC object representing the
CustomTimerDpc routine are dequeued and disabled. In other words, the call to <B>KeCancelTimer</B>
cancels the call to the driver’s CustomTimerDpc routine.
<P>
<LI>
If the most recently specified interval passed to <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>
is just about to expire when <B>KeCancelTimer</B>&nbsp;is called, the
CustomTimerDpc might or might not be called, depending on whether a system
clock interrupt causes the timer object to be removed from the timer queue
before <B>KeCancelTimer</B>&nbsp;executes.
</UL>
<P>
Calling <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>&nbsp;with the same <I>Timer</I>
and <I>Dpc</I>&nbsp;pointers before the previously specified interval expires has
all of the following effects:
<UL>
<LI>
The new call to <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>&nbsp;implicitly cancels
the previously specified <I>DueTime</I>&nbsp;for the already queued timer object.
<P>
<LI>
The new <I>DueTime</I>&nbsp;is set in the timer object.
<P>
<LI>
For <B>KeSetTimer</B>, the CustomTimerDpc routine is called <I>only once</I>,
after the most recently specified <I>DueTime</I>&nbsp;has expired. For a periodic
timer set with <B>KeSetTimerEx</B>, one instance of the timer (and thus one
execution of the CustomTimerDpc routine) is deleted.
</UL>
<P>
Note that using the same timer object for different purposes can cause race
conditions or serious driver errors. For example, if the same <I>Timer</I>
pointer is used both to set up a call to a CustomTimerDpc routine and to set
up waits in a driver-dedicated thread, such a thread would cancel calls to the
CustomTimerDpc routine at random whenever that thread called <B>KeSetTimer</B>
(or <B>KeSetTimerEx</B>&nbsp;or <B>KeCancelTimer</B>) with the common <I>Timer</I>
pointer and the timer object was already queued for a CustomTimerDpc call.
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>For drivers that have
CustomTimerDpc routines and wait on timer objects in a nonarbitrary thread
context:
<UL>
<LI>
<I>Never</I>&nbsp;use a thread-context-sensitive timer object in a nonarbitrary
thread context and vice versa.
<P>
<LI>
Each CustomTimerDpc should have its own associated timer object. Each set of
driver threads and/or driver routines that are called in a nonarbitrary thread
context should have its own set of “waitable” timer objects.
</UL>
<P>
A driver writer who uses a CustomTimerDpc routine should exercise care in
choosing the interval(s) the driver passes in calls to <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>.
In addition, the driver writer must consider all possible effects of a call to
<B>KeCancelTimer</B>&nbsp;with the same timer object from any driver routine that
makes this call, particularly in Windows NT&reg; SMP platforms.
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>NT driver writers should <I>always</I>
keep in mind the following fact about their CustomTimerDpc and/or CustomDpc
routines<B>&nbsp;</B>
<P>
Only <I>one</I>&nbsp;instantiation of a DPC object representing a particular DPC
routine can be queued for execution at any given moment.
<P>
If two driver routines call <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>&nbsp;to run
the same CustomTimerDpc routine and the interval specified by the first caller
has not expired, that CustomTimerDpc routine is run <I>only after the interval
specified by the second caller expires</I>. In these circumstances, the
CustomTimerDpc does none of the work for which the first routine called <B>KeSetTimer</B>
or <B>KeSetTimerEx</B>.
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>For drivers that have
CustomTimerDpc routines<B>&nbsp;</B>and use periodic timers:
<P>
A driver cannot deallocate a periodic timer from a DPC routine. Drivers can
deallocate nonperiodic timers from a DPC routine.
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>Consider the following a
design guideline for NT drivers that have both CustomDpc and CustomTimerDpc
routines<B>&nbsp;</B>
<P>
To prevent race conditions, <I>never</I>&nbsp;pass the same <I>Dpc</I>&nbsp;pointer to <B>KeSetTimer</B>
or <B>KeSetTimerEx</B>&nbsp;and <B>KeInsertQueueDpc</B>.
<P>
In other words, if the StartIo routine calls <B>KeSetTimer</B>&nbsp;or <B>KeSetTimerEx</B>
to run a CustomTimerDpc and the ISR calls <B>KeInsertQueueDpc</B>
simultaneously from another processor with the same <I>Dpc</I>&nbsp;pointer, that
DPC routine will be run when IRQL on a processor falls below DISPATCH_LEVEL or
the timer interval expires, whichever comes first. Whichever does come first,
some essential work for the StartIo or ISR would simply be dropped by such a
for-common-use DPC routine.
<P>
In addition, such a DPC used by two standard driver routines with very
different functionality would necessarily have poorer performance
characteristics than separate CustomTimerDpc and CustomDpc routines. Such a
DPC would have to determine which operations to carry out to suit the
reason(s) it was queued from the StartIo routine or ISR, and testing
conditions in the DPC would use additional CPU cycles.
<P>
&nbsp;
<P></FONT>
</BODY>
</HTML>
