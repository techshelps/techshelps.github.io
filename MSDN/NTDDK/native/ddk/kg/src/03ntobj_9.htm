<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.2.4.3  Using Neither Direct Nor Buffered I/O</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Using_Neither_Direct_Nor_Buffered_I_O_KG"></A>3.2.4.3  Using Neither Direct Nor Buffered I/O</H4>
<P>
Setting up device objects for neither direct nor buffered I/O causes the I/O
Manager to pass the original user-space virtual addresses in IRPs sent to the
driver. Because such a driver must be executing in the context of the calling
thread to access its buffer(s) safely, only highest-level NT drivers, such as
FSDs, can set up their device objects without setting a bit in each device
object’s<B>&nbsp;Flags</B>&nbsp;by ORing it with DO_DIRECT_IO or DO_BUFFERED_IO.
<P>
Note that an NT intermediate or lowest-level driver cannot always meet this
condition. For example, if a requesting thread waits on the completion of an
I/O request or if a higher-level driver (particularly a file system) is
layered over the intermediate or lowest-level driver, such a lower-level
driver’s routines are unlikely to be called in the context of the requesting
thread.
<P>
When the I/O Manager sends an IRP with the current thread’s user-space virtual
addresses for a buffer, a driver that did <I>not</I>&nbsp;OR its device object(s)’ <B>Flags</B>
with DO_BUFFERED_IO or DO_DIRECT_IO must do the following:
<OL>
<LI>
Check the validity of the user buffer’s address range and check whether the
appropriate read or write access is permitted to the buffer. Such a driver
must wrap its accesses to the buffer’s address range within a driver-supplied
exception handler in case a user thread attempts to change the access rights
for the buffer while the driver is accessing memory.
<P>
<LI>
Do one of the following:
<P>
<UL>
<LI>
Carry out its own double-buffering operations, as the I/O Manager does for
drivers that use buffered I/O.
<P>
<LI>
Create its own MDLs and lock down the buffer by calling the Memory Manager’s
support routines, as the I/O Manager does for drivers that use direct I/O.
<P>
<LI>
Perform all necessary operations on the user buffer directly in the context of
the calling thread. Such a driver must wrap its access to the buffer within a
driver-supplied exception handler in case a user thread changes either the
access rights for the buffer or the data in the buffer while the driver is
accessing memory.
</UL>
</OL>
<P>
In effect, such a driver must choose on a per-IRP basis whether to do buffered
I/O, direct I/O, or I/O in the context of the calling thread, and it must
handle any exceptions that might occur in a user-mode thread context. Such a
driver must manage its own user buffer accesses, double-buffering operations,
and memory mappings, as necessary, instead of letting the I/O Manager handle
these operations for the driver.
<P></FONT>
</BODY>
</HTML>
