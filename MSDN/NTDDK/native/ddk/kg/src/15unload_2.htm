<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>15.1.1  Releasing Driver-Allocated Resources</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Releasing_Driver_Allocated_Resources_KG"></A>15.1.1  Releasing Driver-Allocated Resources</H3>
<P>
An Unload routine is responsible for freeing all the system objects and
resources the driver is using before the driver itself is unloaded.
<P>
In other words, the Unload routine must call the following support routines:
<UL>
<LI>
<B>IoDisconnectInterrupt</B>&nbsp;if the driver has registered an ISR with <B>IoConnectInterrupt</B>
<P>
<LI>
<B>IoDeleteSymbolicLink</B>&nbsp;if the DriverEntry or Reinitialize routine called <B>IoCreateSymbolicLink</B>,
and <B>IoDeassignArcName</B>&nbsp;if the driver called <B>IoAssignArcName</B>
<P>
<LI>
<B>ExFreePool</B>&nbsp;if the DriverEntry or any other driver routine called <B>ExAllocatePool</B>
and the memory has not yet been released
<P>
<LI>
<B>MmUnmapIoSpace</B>&nbsp;if the DriverEntry routine called <B>MmMapIoSpace</B>
<P>
<LI>
<B>MmFreeNonCachedMemory</B>&nbsp;if the DriverEntry routine called <B>MmAllocateNonCachedMemory</B>
<P>
<LI>
<B>MmFreeContiguousMemory</B>&nbsp;if the DriverEntry routine called <B>MmAllocateContiguousMemory</B>
<P>
<LI>
<B>HalFreeCommonBuffer</B>&nbsp;if the DriverEntry routine called <B>HalAllocateCommonBuffer</B>
<P>
<LI>
<B>IoAssignResources</B>&nbsp;or <B>IoReportResourceUsage</B>&nbsp;if the DriverEntry
routine called one of these support routines or <B>HalAssignSlotResources</B>
to claim hardware resources in the configuration registry for itself and/or
for its physical devices individually
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>Consider the following a
general design guideline for Unload routines<B>&nbsp;</B>
<P>
Every Unload routine must ensure that no other driver routine is currently
using or might shortly be using any driver-allocated resource <I>before</I>
the Unload routine frees that resource.
</UL>
<P>
For example, an Unload routine must call <B>IoStopTimer</B>&nbsp;if the driver’s
IoTimer routine is currently enabled for a particular device object. It must
ensure that no thread is waiting on any of the driver’s dispatcher objects
and/or that its timer object(s) are not queued for calls to its CustomTimerDpc
routine(s) before it frees the storage for its dispatcher objects. It must
call <B>KeRemoveQueueDpc</B>&nbsp;if it has a CustomDpc routine that the ISR might
have queued, and so on.
<P>
Any device driver must call <B>IoDisconnectInterrupt</B>&nbsp;with the interrupt
object(s) pointer if it called <B>IoConnectInterrupt</B>&nbsp;in its DriverEntry
routine. Its Unload routine must call <B>IoDisconnectInterrupt</B>&nbsp;before it
deletes the storage for this pointer.
<P>
Any higher-level driver that called <B>IoGetDeviceObjectPointer</B>&nbsp;in its
DriverEntry or Reinitialize routine must call <B>ObDereferenceObject</B>&nbsp;with
the pointer to the file object associated with the lower driver’s device
object. Its Unload routine must call <B>ObDereferenceObject</B>&nbsp;before it
deletes the storage for this pointer.
<P>
Any higher-level driver that called <B>IoAttachDevice</B>&nbsp;in its DriverEntry
or Reinitialize routine must call <B>IoDetachDevice</B>&nbsp;with the pointer to
the lower driver’s device object. Its Unload routine must call <B>IoDetachDevice</B>
before it deletes the storage for this pointer.
<P>
If the driver allocated nonpaged pool as storage for any Kernel-defined
object(s) it uses, the Unload routine must explicitly call <B>ExFreePool</B>
to free the storage and the object(s).
<P>
If the driver called <B>PsCreateSystemThread</B>, the Unload routine also must
cause the driver-created thread to be run so that the thread itself can call <B>PsTerminateSystemThread</B>
before the driver is unloaded from the system. A driver-created system thread <I>cannot</I>
be released by calling <B>ZwClose</B>&nbsp;with the <I>ThreadHandle</I>&nbsp;returned by
<B>PsCreateSystemThread</B>.
<P>
For more information about symbolic links, about claiming resources in the
registry, about releasing registry resources, and about allocating memory, see
also Chapter 16. For specific information about any particular support
routine, see the <I>Kernel-Mode Driver Reference</I>.
<P></FONT>
</BODY>
</HTML>
