<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A.1.4.5  SCSI Class Driver’s SplitTransferRequest Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_SCSI_Class_Drivers_SplitTransferRequest_Routine_KG"></A>A.1.4.5  SCSI Class Driver’s SplitTransferRequest Routine</H4>
<P>
The IO_SCSI_CAPABILITIES-type data returned to the DriverEntry routine
indicates the transfer capabilities of a given HBA to the class driver. In
particular, this data indicates the HBA’s <B>MaximumTransferLength</B>&nbsp;in
bytes and the HBA’s <B>MaximumPhysicalPages</B>: that is, how many
discontiguites in the physical memory backing a system buffer the HBA can
manage. 
<P>
Most class drivers store a pointer to this configuration data in the device
extension of each device object because SCSI class drivers are responsible for
splitting up all transfer requests that exceed the HBA’s capability to
transfer data. In other words, a class driver’s DispatchReadWrite routine must
determine whether each IRP requests a transfer that is more than the HBA can
handle in a single transfer operation. 
<P>
For example, such a DispatchReadWrite routine could have code similar to the
following: 
<PRE><FONT FACE="Courier" SIZE="2">maxTransferLength = 
&nbsp; &nbsp; deviceExtension-&gt;PortCapabilities-&gt;MaximumTransferLength; 
maxPhysicalPages = 
&nbsp; &nbsp; deviceExtension-&gt;PortCapabilities-&gt;MaximumPhysicalPages; 
currentIrpStack = IoGetCurrentIrpStackLocation(Irp); 
transferLengthRequested = currentIrpStack-&gt;Parameters.Read.Length; 
&nbsp; &nbsp; :        : 
// 
// Calculate number of pages in this transfer 
// 
transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES( 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MmGetMdlVirtualAddress(Irp-&gt;MdlAddress), 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transferLengthRequested); 
// 
// Check whether requested length is greater than maximum  
// HBA can transfer in a single operation 
// 
if (transferLengthRequested &gt; maxTransferLength || 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transferPages &gt; maxPhysicalPages) { 
&nbsp; &nbsp; transferPages = maxPhysicalPages - 1; 
&nbsp; &nbsp; if (maxTransferLength &gt; transferPages &lt;&lt; PAGE_SHIFT) { 
&nbsp; &nbsp; &nbsp; &nbsp; maxTransferLength = transferPages &lt;&lt; PAGE_SHIFT; 
&nbsp; &nbsp; } 
&nbsp; &nbsp; IoMarkIrpPending(Irp); 
&nbsp; &nbsp; SplitTransferRequest(DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Irp, 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxTransferLength); 
&nbsp; &nbsp; return STATUS_PENDING; 
} 
&nbsp; &nbsp; :        : 
&nbsp;</FONT></PRE>
<P>
Note that such a driver’s DispatchReadWrite routine calls <B>IoMarkIrpPending</B>
and returns STATUS_PENDING immediately after a call to its
SplitTransferRequest routine with the original IRP. 
<P>
To carry out the original transfer request, the driver’s SplitTransferRequest
routine creates one or more IRPs to handle sub-buffers that are sized to suit
the HBA’s capabilities. For each such IRP, the SplitTransferRequest routine
sets up an SRB, usually by calling a BuildSrb routine (see <A HREF="appascsi_13.htm">Section
A.1.4.4</A>), and sets up its IoCompletion routine before sending the IRP on to
the port driver with <B>IoCallDriver</B>. 
<P>
To track each piece of the transfer, SplitTransferRequest registers an
IoCompletion routine for each driver-allocated IRP it sends down to the port
driver. The IoCompletion routine maintains a count of completed partial
transfer requests in the original IRP and protects the count with a spin lock,
as already mentioned in <A HREF="appascsi_8.htm">Section
A.1.3.4</A>. 
<P>
Such an IoCompletion routine must free any IRPs and/or SRBs the driver has
allocated and must complete the original IRP when all requested data has been
transferred or when the class driver has exhausted retries of the IRP and must
fail it due device transfer errors. 
<P></FONT>
</BODY>
</HTML>
