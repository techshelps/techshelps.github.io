<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.3.1  DispatchReadWrite Using Buffered I/O</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_DispatchReadWrite_Using_Buffered_I_O_KG"></A>6.3.3.1  DispatchReadWrite Using Buffered I/O</H4>
<P>
Any NT device driver that sets up its device objects for buffered I/O
satisfies a read request by returning data transferred from its device into a
locked down system-space buffer at <B>Irp-&gt;AssociatedIrp.SystemBuffer</B>.
It satisfies a write request by transferring data from the same buffer out to
its device. 
<P>
Consequently, the DispatchReadWrite routine of such a device driver usually
does the following on receipt of a transfer request:
<OL>
<LI>
Calls <B>IoGetCurrentIrpStackLocation</B>&nbsp;and determines the direction of the
transfer request if necessary. 
<P>
<LI>
Checks the the validity of the parameters for the request. 
<P>
<UL>
<LI>
For a read request, such a driver usually checks the driver’s <I>IoStackLocation</I><B>-&gt;Parameters.Read.Length</B>
value to determine whether the buffer is large enough to contain some discrete
amount of data transferred from its device. 
<P>
For example, the system keyboard class driver processes read requests that
come only from the Win32&reg; user input thread. This driver defines a
structure, KEYBOARD_INPUT_DATA, in which to store keystrokes from the device
and, at any given moment, holds some number of these structures in an internal
ring buffer in order to satisfy read requests as they come in. 
<P>
<LI>
For a write request, such a driver usually checks the value at <B>Parameters.Write.Length</B>,
and checks the data at <B>Irp-&gt;AssociatedIrp.SystemBuffer</B>&nbsp;for validity
if necessary: that is, if its device accepts only structured data packets
containing members with defined value ranges. 
</UL>
<P>
<LI>
If any parameters are invalid, the DispatchReadWrite routine completes the IRP
immediately, as already described in <A HREF="06dsptch_6.htm">Section
6.2.2</A>. Otherwise, the DispatchReadWrite passes the IRP on for further
processing by other driver routines, as described in <A HREF="06dsptch_8.htm">Section
6.2.4</A>. 
</OL>
<P>
NT device drivers that use buffered I/O usually must satisfy a transfer
request with some discrete amount of data that the originator of the request
can use or set up. Such a driver is likely to define a structure for data
coming in from or being sent to its device and is likely to buffer structured
data internally as the system keyboard class driver does.
<P>
Drivers that buffer data internally should support IRP_MJ_FLUSH_BUFFERS
requests, and can also support IRP_MJ_SHUTDOWN requests (see <A HREF="06dsptch_3.htm">Section
6.1.2</A>).
<P>
It is usually the responsibility of the highest-level driver in a chain to
check the input IRP’s parameters before passing a read/write request on to
lower drivers. Consequently, many lower-level NT drivers can assume that their
I/O stack locations in a read/write IRP have valid parameters. The
lowest-level driver in a chain is required to check the validity of the
parameters in its I/O stack location if its device places constraints on data
transfers known only to that device driver. 
<P></FONT>
</BODY>
</HTML>
