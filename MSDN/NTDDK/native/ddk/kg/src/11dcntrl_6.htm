<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>11.2  AdapterControl Routine Requirements</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_AdapterControl_Routine_Requirements_KG"></A>11.2  AdapterControl Routine Requirements</H2>
<P>
At a minimum, an AdapterControl routine must do the following:
<OL>
<LI>
Save the input <I>MapRegisterBase</I>&nbsp;value, which the driver must pass to <B>IoFlushAdapterBuffers</B>
when each DMA transfer operation is complete, and any other context
information that the driver needs to carry out one or more DMA transfer
operations for the current IRP.
<P>
<LI>
Return the appropriate IO_ALLOCATION_ACTION value:
<P>
<UL>
<LI>
<B>KeepObject</B>&nbsp;if the device is a slave so the driver uses system DMA.
<P>
<LI>
<B>DeallocateObjectKeepRegisters</B>&nbsp;if the device is a busmaster so the
driver uses packet-based busmaster DMA.
</UL>
</OL>
<P>
Depending on the driver’s design, its AdapterControl routine also can do the
following before it returns control:
<OL>
<LI>
Determine the starting location for the transfer on its device.
<P>
<LI>
Calculate the size of the transfer possible, given any limitations of its
device due to the starting location of the transfer.
<P>
In general, it is the responsibility of the routine that calls <B>IoAllocateAdapterChannel</B>
to determine whether a given transfer request must be split up into partial
transfers due to any platform-specific limitations on the <I>NumberOfMapRegisters</I>
available for each DMA transfer operation, as mentioned in <A HREF="11dcntrl_5.htm">Section
11.1.4</A>.
<P>
<LI>
Set up any driver-maintained state about each tranfer request in the device
(or controller) extension.
<P>
For example, an AdapterControl routine might call <B>KeSetTimer</B>&nbsp;with the
entry point for a CustomTimerDpc routine that times out DMA transfer
operations for the driver. For more information about CustomTimerDpc routines,
see Chapter 14.
<P>
<LI>
Call <B>MmGetMdlVirtualAddress</B>&nbsp;with the MDL at <B>Irp-&gt;MdlAddress</B>
to get an index for the start of the transfer, suitable for passing to <B>IoMapTransfer</B>.
<P>
<LI>
Call <B>IoMapTransfer</B>&nbsp;to set up the system DMA controller or to obtain a
physical-to-logical address mapping for a busmaster device.
<P>
<LI>
Program the driver’s device for a transfer operation by calling <B>KeSynchronizeExecution</B>
with a SynchCritSection routine, described in Chapter 10.
</OL>
<P>
If a given transfer request requires the driver to perform a sequence of
partial-transfer operations to satisfy the current IRP, usually the driver’s
DpcForIsr routine is responsible for reprogramming the device for subsequent
transfer operations. An AdapterControl routine is called only once for each
incoming transfer IRP.
<P>
The driver routine that completes the current transfer IRP, usually the
DpcForIsr, also is responsible for releasing the system DMA controller or
busmaster adapter by calling <B>IoFreeAdapterChannel</B>&nbsp;or <B>IoFreeMapRegisters</B>,
respectively. This driver routine should make the appropriate call as soon as
possible when its last partial-transfer operation is done so that NT drivers
of slave DMA devices can allocate the system DMA controller or a busmaster
driver can begin processing the next transfer IRP promptly.
<P></FONT>
</BODY>
</HTML>
