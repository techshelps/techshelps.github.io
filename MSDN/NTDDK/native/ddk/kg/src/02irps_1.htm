<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>2.1  End-user I/O Requests and NT File Objects</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_End_user_I_O_Requests_and_NT_File_Objects_KG"></A>2.1  End-user I/O Requests and NT File Objects</H2>
<P>
NT drivers are hidden from end users by a Windows NT protected subsystem that
implements an already familiar programming interface, such as Windows&reg; or
POSIX. Devices are visible to user-mode code, which includes protected
subsystems, only as named file objects controlled by the NT I/O Manager.
<P>
<A NAME="DDK_Figure_2..1_KG"></A>Figure 2.1 illustrates this relationship between
an end user, a subsystem, and the NT I/O Manager.
<P>
<B><IMG SRC="../art/2grsover.gif" BORDER=0></B>
<P>
<B>Figure 2.1    NT File Objects Represent Files, Volumes, and Devices</B>
<P>
A Windows NT protected subsystem, such as the Win32&reg; subsystem, passes I/O
requests to the appropriate kernel-mode driver through the I/O system
services. The subsystem shown in <A HREF="#DDK_Figure_2..1_KG">Figure 2.1</A>
depends on support from the NT display, video adapter, keyboard, and mouse
device drivers.
<P>
A protected subsystem insulates its end users and applications from having to
know anything about kernel-mode components, including NT drivers. In turn, the
NT I/O Manager insulates protected subsystems from having to know anything
about machine-specific device configurations or about NT drivers’
implementations.
<P>
The NT I/O Manager’s layered approach also insulates most NT drivers from
having to know anything about:
<UL>
<LI>
Whether an I/O request originated in any particular protected subsystem, such
as Win32 or POSIX
<P>
<LI>
Whether a given protected subsystem has particular kinds of user-mode drivers
<P>
<LI>
What any protected subsystem’s I/O model and interface to drivers is
</UL>
<P>
The I/O Manager supplies NT drivers with a single I/O model, a set of
kernel-mode support routines these drivers can use to carry out I/O
operations, and a consistent interface between the originator of an I/O
request and the NT drivers that must respond to it.
<P>
As shown in <A HREF="#DDK_Figure_2..1_KG">Figure 2.1</A>, a subsystem and its
native applications can access an NT driver’s device or a file on a
mass-storage device only through file object handles supplied by the NT I/O
Manager. A subsystem’s request to open such a file object and to obtain a
handle for I/O to a device or a data file is made by calling the NT I/O system
services to open a named file, which can have a subsystem-specific alias
(symbolic link) to the kernel-mode name for the file object.
<P>
<A NAME="DDK_Figure_2..2_KG"></A>The NT I/O Manager, which exports these system
services, is then responsible for locating or creating the file object that
represents the device or data file and for locating the appropriate NT
driver(s). Figure 2.2 shows an overview of what happens when a subsystem opens
a file object representing a data file on behalf of an application.
<P>
<B><IMG SRC="../art/2opendev.gif" BORDER=0></B>
<P>
<B>Figure 2.2    Opening an NT File Object</B>
<OL>
<LI>
The subsystem calls an NT I/O system service to open a named file.
<P>
<LI>
The NT I/O Manager calls the Object Manager to look up the named file and to
help it resolve any symbolic links for the file object. It also calls the
Security Reference Monitor to check that the subsystem has the correct access
rights to open that file object.
<P>
<LI>
If the volume is not yet mounted, the I/O Manager suspends the open request,
calling one or more NT file systems until one of them recognizes the file
object as something it has stored on one of the mass-storage devices the file
system uses. When the file system has mounted the volume, the I/O Manager
resumes the request.
<P>
<LI>
The I/O Manager allocates memory for and initializes an IRP for the open
request. To NT drivers, an open is equivalent to a “create” request.
<P>
<LI>
The I/O Manager calls the file system driver, passing it the IRP. The file
system driver accesses its I/O stack location in the IRP to determine what
operation it must carry out, checks parameters, determines if the requested
file is in cache, and, if not, sets up the next-lower driver’s I/O stack
location in the IRP.
<P>
<LI>
Both drivers process the IRP and complete the requested I/O operation, calling
kernel-mode support routines supplied by the I/O Manager and by other NT
components (not shown in <A HREF="#DDK_Figure_2..2_KG">Figure 2.2</A>).
<P>
<LI>
The drivers return the IRP to the I/O Manager with the I/O status block set in
the IRP to indicate whether the requested operation succeeded or why it
failed.
<P>
<LI>
The I/O Manager gets the I/O status from the IRP, so it can return status
information through the protected subsystem to the original caller.
<P>
<LI>
The I/O Manager frees the completed IRP.
<P>
<LI>
The I/O Manager returns a handle for the file object to the subsystem if the
open operation was successful. If there was an error, it returns appropriate
status to the subsystem.
</OL>
<P>
After a subsystem successfully opens a file object that represents a data
file, a device, or a volume, the subsystem uses the returned file object
handle to request that device I/O operations (usually read, write, or device
I/O control requests) be carried out by calling the I/O system services. The
I/O Manager routes these requests as IRPs sent to appropriate NT drivers.
<P></FONT>
</BODY>
</HTML>
