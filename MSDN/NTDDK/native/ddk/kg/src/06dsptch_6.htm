<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.2.2  How to Complete an IRP in a Dispatch Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_How_to_Complete_an_IRP_in_a_Dispatch_Routine_KG"></A>6.2.2  How to Complete an IRP in a Dispatch Routine</H3>
<P>
If an input IRP can be completed immediately, a Dispatch routine does the
following:
<OL>
<LI>
Sets the <B>Status</B>&nbsp;and <B>Information</B>&nbsp;members of the IRP’s I/O status
block with appropriate values, in general: 
<P>
<UL>
<LI>
The Dispatch routine sets <B>Status</B>&nbsp;either to STATUS_SUCCESS or to an
appropriate error STATUS_<I>XXX</I>,  which can be the value returned by a
call to a support routine or, for certain synchronous requests, by a lower
driver. 
<P>
If a lower-level driver returns STATUS_PENDING, a higher-level driver should
not call <B>IoCompleteRequest</B>&nbsp;with an IRP unless it calls <B>IoMarkIrpPending</B>
with that IRP first. However, a higher-level driver’s Dispatch routine is
unlikely to complete any IRP for which lower driver(s) return STATUS_PENDING. 
<P>
<LI>
It sets <B>Information</B>&nbsp;to the number of bytes successfully transferred if
a request to transfer data, such as a read or write request, was satisfied. 
<P>
<LI>
It sets <B>Information</B>&nbsp;to a value that varies according to the specific
request for other IRPs that it completes with STATUS_SUCCESS. 
<P>
<LI>
It sets <B>Information</B>&nbsp;to a value that varies according to the specific
request for IRPs that it completes with a warning STATUS_<I>XXX</I>. For
example, it would set <B>Information</B>&nbsp;to the number of bytes transferred
for such a warning as STATUS_BUFFER_OVERFLOW. 
<P>
<LI>
Usually, it sets <B>Information</B>&nbsp;to zero for requests that it completes
with an error STATUS_<I>XXX</I>. 
</UL>
<P>
<LI>
Calls <B>IoCompleteRequest</B>&nbsp;with the IRP and the <I>PriorityBoost</I>
IO_NO_INCREMENT.
<P>
<LI>
Returns the appropriate STATUS_<I>XXX</I>&nbsp; that it already set in the I/O
status block. Note that a call to <B>IoCompleteRequest</B>&nbsp;makes the given IRP
inaccessible by the caller, so the return value from a Dispatch routine <I>cannot</I>
be set from the I/O status block of an already completed IRP. 
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>NT driver writers should
follow this implementation guideline for calling <B>IoCompleteRequest</B>&nbsp;with
an IRP:<B>&nbsp;</B>
<P>
<I>Always</I>&nbsp;release any spin lock(s) the driver is holding <I>before</I>
calling <B>IoCompleteRequest</B>. 
</OL>
<P>
It takes an indeterminate amount of time to complete an IRP, particularly in a
chain of layered NT drivers. Moreover, a deadlock can occur if a higher-level
driver’s IoCompletion routine sends an IRP back down to a lower driver that is
holding a spin lock. 
<P></FONT>
</BODY>
</HTML>
