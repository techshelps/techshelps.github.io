<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>7.2.2.2  Device Driver’s StartIo Routine Using Direct I/O</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Device_Drivers_StartIo_Routine_Using_Direct_I_O_KG"></A>7.2.2.2  Device Driver’s StartIo Routine Using Direct I/O</H4>
<P>
Assuming its DispatchRead, DispatchWrite, or DispatchDeviceControl routine
determined that a request was valid and called <B>IoStartPacket</B>, a device
driver’s StartIo routine is called to process the packet next. If the packet
is queued by <B>IoStartPacket</B>, eventually a call to <B>IoStartNextPacket</B>
from the driver’s DpcForIsr or CustomDpc routine causes the StartIo routine to
be called with the dequeued IRP. 
<P>
The StartIo routine calls <B>IoGetCurrentIrpStackLocation</B>&nbsp;and determines
which operation must be performed to satisfy the request. It preprocesses the
IRP in any way necessary, such as splitting up a large DMA transfer request
into partial-transfer ranges and saving state about the <B>Length</B>&nbsp;of an
incoming transfer request that must be split, before programming the physical
device to carry out the I/O request. 
<P>
The StartIo routine must use a driver-supplied SynchCritSection routine to
perform the necessary programming if access to the physical device (and/or the
device extension) must be synchronized with the driver’s ISR. For more
information, see <A HREF="07strtio_8.htm">Section
7.2.3</A>.
<P>
Any NT device driver that uses direct I/O either reads data into or writes
data from a locked-down buffer, described by a memory descriptor list (MDL),
that the driver finds in the IRP at <B>Irp-&gt;MdlAddress</B>. Such a driver
commonly uses buffered I/O for device control requests. For more information,
see <A HREF="07strtio_7.htm">Section
7.2.2.3</A>. 
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; As a type defined by, used exclusively by, and changeable by the NT Memory Manager, all MDLs are opaque to NT drivers. NT driver writers should consider the following an implementation guideline: </H5>
<P>
NT drivers <I>cannot</I>&nbsp;use the address mappings contained in <I>any</I>&nbsp;MDL,
including an MDL at <B>Irp-&gt;MdlAddress</B>, directly. 
<P>
Instead, NT device drivers that use PIO remap user-space buffers by calling <B>MmGetSystemAddressForMdl</B>
with the <B>Irp-&gt;MdlAddress</B>. NT device drivers that use DMA also pass <B>Irp-&gt;MdlAddress</B>
to support routines during their transfer operations to have the buffer
addresses remapped to logical ranges for their devices.
<P>
Unless a closely coupled higher-level driver pre-splits large DMA transfer
requests for the underlying device driver, an NT device driver’s StartIo
routine must split up each transfer request that is larger than its device can
manage in a single transfer operation. NT device drivers that use system DMA
are required to split transfer requests that are too large for the system DMA
controller or for their device(s) to handle in a single transfer operation. 
<P>
If the device is a slave DMA device, its driver must synchronize transfers
through a system DMA controller with a driver-allocated adapter object,
representing the DMA channel, and a driver-supplied AdapterControl routine.
The driver of a busmaster DMA device also must use a driver-allocated adapter
object to synchronize its transfers and must supply an AdapterControl routine
if it uses the system’s packet-based DMA support. 
<P>
Depending on an NT device driver’s design, it might synchronize transfer and
device control operations on a physical device with a controller object and
supply a ControllerControl routine. 
<P>
For more information about DMA transfers, adapter objects, and controller
objects, see Chapter 3. For more information about driver-supplied
AdapterControl and ControllerControl routines, see also Chapter 11. 
<P></FONT>
</BODY>
</HTML>
