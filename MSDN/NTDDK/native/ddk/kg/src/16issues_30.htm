<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.8.1.1  RegistryPath, DriverName, and Device Object Names</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_RegistryPath_DriverName_and_Device_Object_Names_KG"></A>16.8.1.1  RegistryPath, DriverName, and Device Object Names</H4>
<P>
As shown in <A HREF="16issues_29.htm#DDK_Figure_16..6_NG">Figure 16.6</A>, <I>RegistryPath</I>
points to the driver-specific key <B>\Registry\Machine\System\CurrentControlSet\Services\</B><I>DriverName</I>.
The value entry of the key <I>DriverName</I>&nbsp;is a Unicode string that
identifies the driver, such as “Serial.”
<H5>\<I>DriverName</I>\Parameters</H5>
<P>
One or more subkeys under each <I>DriverName</I>&nbsp;key include the
driver-specific <B>Parameters</B>&nbsp;with value entries needed to load the
driver, and can also include one or more subkeys for device-specific <B>Parameters</B>
needed to initialize each device a particular NT driver controls.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; If an NT device driver needs hardware configuration information that the ARC or NtDetect component cannot “find,” that the driver cannot get from its device, or that the HAL cannot get from the bus, this information should be supplied under the ..\<I>DriverName</I>&nbsp;registry key, so that the driver can get this hardware configuration information from its Parameters key(s) when it is loaded. </H5>
<P>
An NT driver loses its <I>RegistryPath</I>&nbsp;pointer when its DriverEntry
routine returns. If a driver-supplied Reinitialize routine uses this path, an
NT driver should save the <I>RegistryPath</I>&nbsp;pointer that is input to its
DriverEntry routine.
<P>
Note that the <I>DriverName</I>&nbsp;value along the <I>RegistryPath</I>&nbsp;string is
not necessarily the generic name for a type of physical device like “Serial.”
NT drivers generally cannot use this string to create names for their device
object(s).
<H5>Calling IoGetConfigurationInformation to Determine Device Object Names</H5>
<P>
Names for device objects are also Unicode strings but have the form <B>\Device\</B><I>GenericDeviceTypeDigit</I>,
such as \Device\Harddisk1\Partition2, as also discussed in Chapters 4 and 5.
However, NT drivers for certain kinds of devices can call <B>IoGetConfigurationInformation</B>
to determine the <I>Digit</I>&nbsp;value each driver should append to the name of
each device object that it creates to represent a physical device.
<P>
Some higher-level NT drivers also might call <B>IoGetConfigurationInformation</B>
to determine how many device objects for a particular kind of physical device
have been created by lowest-level drivers.
<P>
<B>IoGetConfigurationInformation</B>&nbsp;returns a CONFIGURATION_INFORMATION-type
pointer to the I/O Manager’s structure. NT device drivers set the following
about certain types of physical devices in this structure as these drivers are
being loaded:
<PRE><FONT FACE="Courier" SIZE="2">ULONG DiskCount;                       // Harddisks already named 
ULONG FloppyCount;                     // Floppy drives already named 
ULONG CdRomCount;                      // CdRom drives already named 
ULONG TapeCount;                       // Tape drives already named 
ULONG ScsiPortCount;                   // ScsiPort (HBAs) already named 
ULONG SerialCount;                     // Serial ports already named 
ULONG ParallelCount;                   // Parallel ports already named 
BOOLEAN AtDiskPrimaryAddressClaimed;   // 0x1f0 - 0x1ff 
BOOLEAN AtDiskSecondaryAddressClaimed; // 0x170 - 0x17f 
&nbsp;</FONT></PRE>
<P>
Drivers of the preceding kinds of physical devices can use the current value
in this global system structure to name their device objects with the correct <I>Digit</I>
suffix. For example, if the current value of <B>DiskCount</B>&nbsp;is one, a disk
device driver would name its driver-created device objects for two physical
disks \Device\Harddisk1 and \Device\Harddisk2. Note that the configuration
information counts are one-based while device object <I>Digit</I>&nbsp; suffixes
are zero-based values. Such a driver must increment the <B>DiskCount</B>&nbsp;value
in the configuration information structure for each device object that it
creates to represent a physical disk.
<P>
The last two members of the configuration information structure indicate
whether either of the bus-relative I/O address spaces used by “AT” disk
(WD1003-compatible) controllers is being claimed by the driver. A subsequently
loaded disk driver for a device with an “AT-compatible” mode might use this
information.
<P>
A higher-level NT SCSI class driver can call <B>IoGetConfigurationInformation</B>
to determine how many HBAs are present in a particular machine, as well as how
many <B>Harddisk</B>, <B>Floppy</B>, <B>CdRom</B>, <B>Tape</B>, <B>Serial</B>,
or <B>Parallel</B>&nbsp;devices have already been named. Since SCSI class and
filter drivers are loaded after the NT SCSI port and HBA-specific miniport
drivers, <B>ScsiPortCount</B>&nbsp;indicates the total number of HBAs in the
machine. A SCSI class driver can use the value of <B>ScsiPortCount</B>&nbsp;as a
loop-control variable to determine which HBAs drive buses with attached
peripheral devices of the class driver’s type. For more information about
initializing SCSI drivers, see also <A HREF="appascsi.htm">Appendix A</A>.
<P></FONT>
</BODY>
</HTML>
