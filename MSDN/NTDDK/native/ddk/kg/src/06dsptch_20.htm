<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.3.4  Points to Consider in Implementing DispatchReadWrite</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Points_to_Consider_in_Implementing_DispatchReadWrite_KG"></A>6.3.3.4  Points to Consider in Implementing DispatchReadWrite</H4>
<P>
Keep the following points in mind when implementing a DispatchRead,
DispatchWrite, or DispatchReadWrite routine:
<UL>
<LI>
It is the responsiblity of the highest-level driver in a chain of layered
drivers to check the parameters of incoming read/write IRPs for validity
before setting up the next-lower-level driver’s I/O stack location in an IRP.
<P>
<LI>
Intermediate and lowest-level drivers generally can rely on the highest-level
driver in their chain to pass down transfer requests with valid parameters.
However, any driver can perform sanity checks on the parameters in its I/O
stack location of an IRP, and each device driver should check the parameters
for conditions that might violate any restrictions imposed by its device.
<P>
<LI>
If a DispatchReadWrite routine completes an IRP with an error, it should set
the I/O stack location <B>Status</B>&nbsp;member with an appropriate NTSTATUS-type
value, set the <B>Information</B>&nbsp;member to zero, and call <B>IoCompleteRequest</B>
with the IRP and a <I>PriorityBoost</I>&nbsp;of IO_NO_INCREMENT.
<P>
<LI>
If a driver uses buffered I/O, it might need to define a structure to contain
data to be transferred and might need to buffer some number of these
structures internally.
<P>
<LI>
If a driver uses direct I/O, it might need to check whether the MDL at <B>Irp-&gt;MdlAddress</B>
describes a buffer containing too much data (or too many page breaks) for the
underlying device to handle in a single transfer operation. If so, the driver
must split up the original transfer request into a sequence of smaller
transfer operations. 
<P>
A closely coupled class driver might split up such a request in its
DispatchReadWrite routine for its underlying port driver. NT SCSI class
drivers, particularly for mass-storage devices, are required to do this. For
more information about requirements for SCSI drivers, see <A HREF="appascsi.htm">Appendix
A</A>. 
<P>
<LI>
A device driver’s DispatchReadWrite routine should postpone splitting a large
transfer request into partial transfers until another driver routine dequeues
the IRP to set up the device for the transfer. 
<P>
<LI>
If a device driver queues a read/write IRP for further processing by its own
routines, it must call <B>IoMarkIrpPending</B>&nbsp;before it queues the IRP. The
DispatchReadWrite routine also must return control with STATUS_PENDING in
these circumstances. 
<P>
<LI>
If the DispatchReadWrite routine passes an IRP on to lower drivers, it must
set up the I/O stack location for the next-lower driver in the IRP. Whether
the higher-level driver also sets an IoCompletion routine in the IRP before
passing it on with <B>IoCallDriver</B>&nbsp;depends on the design of the driver and
of those layered under it. 
<P>
However, a higher-level driver must call <B>IoSetCompletionRoutine</B>&nbsp;before
it calls <B>IoCallDriver</B>&nbsp;if it allocates any resources, such as IRPs or
memory. Its IoCompletion routine must free any driver-allocated resources when
lower drivers have completed the request but before the IoCompletion routine
calls <B>IoCompleteRequest</B>&nbsp;with the original IRP. 
<P>
<LI>
If a higher-level driver allocates IRPs for lower drivers that might include
an underlying removable-media device driver, the allocating driver must
establish the thread context in each IRP it allocates. 
</UL>
<P></FONT>
</BODY>
</HTML>
