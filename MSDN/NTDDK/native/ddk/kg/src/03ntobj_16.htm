<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.3.4.2  Common-Buffer System DMA</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Common_Buffer_System_DMA_KG"></A>3.3.4.2  Common-Buffer System DMA</H4>
<P>
<A NAME="DDK_Figure_3.9_KG"></A>A driver that uses a system DMA controller’s
autoinitialize mode must allocate memory for a buffer into which or from which
DMA transfers can be carried out. Such a driver must call <B>HalAllocateCommonBuffer</B>
when it initializes in order to provide this buffer. Figure 3.9 illustrates
such a driver’s call to <B>HalAllocateCommonBuffer</B>.
<P>
<B><IMG SRC="../art/3hlsysbf.gif" BORDER=0></B>
<P>
<B>Figure 3.9    Allocating a Common Buffer for System DMA</B>
<P>
As Figure 3.9 shows, the driver must pass a pointer to the adapter object that
was returned by <B>HalGetAdapter</B>, along with the length in bytes requested
for its buffer. To use memory economically, the input <I>Length</I>&nbsp;value for
such a buffer either should be less than or equal to PAGE_SIZE or should be an
integral multiple of PAGE_SIZE.
<P>
If the call succeeds, <B>HalAllocateCommonBuffer</B>&nbsp;returns two different
types of pointers to the buffer:
<UL>
<LI>
The <I>LogicalAddress</I>&nbsp;of the buffer (BuffLogicalAddress in Figure 3.9),
for which the driver must provide storage but which it should ignore
thereafter
<P>
<LI>
The virtual address of the buffer (BuffVirtualAddress in Figure 3.9), which
the driver also must store so that it can build an MDL describing its buffer
for DMA operations
</UL>
<P>
If <B>HalAllocateCommonBuffer</B>&nbsp;returns a NULL pointer, the driver should
free any system resources it has already claimed, call <B>IoDeleteDevice</B>
to release any device objects it has already created, and so forth. The <B>DriverEntry</B>
routine also should return STATUS_INSUFFICIENT_RESOURCES, because the driver
must not be loaded when it cannot respond to data transfer requests.
<P>
Otherwise, the driver must call <B>IoAllocateMdl</B>&nbsp;with the <I>VirtualAddress</I>
of the buffer returned by <B>HalAllocateCommonBuffer</B>&nbsp;and the <I>Length</I>
of its buffer to allocate an MDL. It should then call <B>MmBuildMdlForNonPagedPool</B>
with the pointer returned by <B>IoAllocateMdl</B>&nbsp;to map the virtual address
range for its resident buffer to system physical memory.
<P>
NT drivers of slave devices that use a common buffer for DMA call the
following general sequence of support routines as they process an IRP
requesting a DMA transfer:
<OL>
<LI>
At the driver writer’s discretion, <B>RtlMoveMemory</B>&nbsp;to copy data from a
locked-down user buffer into the driver-allocated common buffer for a transfer
to the device
<P>
<LI>
<B>IoAllocateAdapterChannel</B>&nbsp;when the driver is ready to program its device
for DMA and needs the system DMA controller
<P>
<LI>
<B>IoMapTransfer</B>&nbsp;with the MDL, describing the driver-allocated common
buffer, to set up the system DMA controller for the transfer operation
<P>
Note that such a driver calls <B>IoMapTransfer</B>&nbsp;only once to set up the
system DMA controller to use its common buffer. During a transfer, the driver
can call <B>HalReadDmaCounter</B>&nbsp;to determine how many bytes remain to be
transferred, and if necessary, call <B>RtlMoveMemory</B>&nbsp;to copy more data to
or from a user buffer.
<P>
<LI>
<B>IoFlushAdapterBuffers</B>&nbsp;when the driver has completed its DMA transfer
to/from the slave device
<P>
<LI>
<B>IoFreeAdapterChannel</B>&nbsp;as soon as all the requested data has been
transferred or the driver fails the IRP because of a device I/O error
</OL>
<P>
The <I>AdapterObject</I>&nbsp;pointer returned by <B>HalGetAdapter</B>&nbsp;is a
required parameter to each of these support routines except <B>RtlMoveMemory</B>.
<P>
Individual NT drivers call this sequence of support routines at different
points, depending on how each driver is implemented to service its device. For
example, one driver’s StartIo routine might make the call to <B>IoAllocateAdapterChannel</B>,
another driver might make this call from a routine that removes IRPs from a
driver-created interlocked queue, and still another driver might make this
call when its slave DMA device indicates it is ready to transfer data.
<H5><A NAME="DDK_Allocating_an_Adapter_Channel_for_Common_Buffer_System_DMA_KG"></A>3.3.4.2.1  Allocating an Adapter Channel for Common-Buffer System DMA</H5>
<P>
A driver calls <B>IoAllocateAdapterChannel</B>&nbsp;after its Dispatch routine for
IRP_MJ_READ and/or IRP_MJ_WRITE requests, or for any other request that
requires a DMA transfer, has already checked the validity of the IRP’s
parameters (if necessary), queued one or more IRPs to another driver routine
for further processing, and possibly loaded its common buffer with data to be
transferred. See <A HREF="03ntobj_15.htm#DDK_Figure_3..7_KG">Figure 3.7</A>&nbsp;for an illustration
of a call to <B>IoAllocateAdapterChannel</B>.
<P>
The driver routine that calls <B>IoAllocateAdapterChannel</B>&nbsp;must be
executing at IRQL DISPATCH_LEVEL when this call occurs. For more information
about the IRQLs at which NT drivers’ standard routines execute, see Chapters 5
through 15. For more information about support-routine-specific IRQL
requirements, see the <I>Kernel-Mode Driver Reference.</I>
<P>
<B>IoAllocateAdapterChannel</B>&nbsp;queues the driver’s AdapterControl routine,
which executes when the system DMA controller is assigned to this driver and a
set of map registers (described in <A HREF="03ntobj_11.htm">Section
3.3.1</A>) has been allocated for the driver’s DMA operation.
<P>
On entry, an AdapterControl routine is given pointers to the device object and
context passed in the call to <B>IoAllocateAdapterChannel</B>, as well as a
handle for the allocated map register(s). The AdapterControl routine also is
given a pointer to the <B>DeviceObject-&gt;CurrentIrp</B>&nbsp;if the driver has a
StartIo routine. If the driver manages its own queueing of IRPs instead of
having a StartIo routine, the driver should include a pointer to the current
IRP as part of the context data it passes when it calls <B>IoAllocateAdapterChannel</B>.
<P>
The AdapterControl routine usually does the following:
<OL>
<LI>
Saves or initializes whatever context the driver maintains about DMA
operations, such as saving the <I>MapRegisterBase</I>&nbsp;handle the driver must
pass to <B>IoMapTransfer</B>&nbsp;and <B>IoFlushAdapterBuffers</B>&nbsp;and, possibly,
the <B>Length</B>&nbsp;of transfer requested from its I/O stack location in the IRP
<P>
<LI>
Sets up the slave device to start the transfer operation
<P>
<LI>
Returns the value <B>KeepObject</B>
</OL>
<P>
For NT drivers that use a system DMA controller’s autoinitialize mode, the
AdapterControl routine must return the value <B>KeepObject</B>. This allows
the driver to retain “ownership” of the system DMA controller and allocated
map register(s) until it has transferred all the data.
<P>
Note that an AdapterControl routine cannot wait for the slave device to carry
out the DMA operation, so an AdapterControl routine must at least do the
following:
<OL>
<LI>
Save context information, particularly the <I>MapRegisterBase</I>&nbsp;handle, in
the driver’s device extension, controller extension, or other
driver-accessible resident storage area (nonpaged pool allocated by the
driver).
<P>
<LI>
Return <B>KeepObject</B>.
</OL>
<P>
Another driver routine (probably the DpcForIsr) must call <B>IoFlushAdapterBuffers</B>
and <B>IoFreeAdapterChannel</B>&nbsp;when the DMA transfer operation is complete.
<H5><A NAME="DDK_Setting_Up_the_System_DMA_Controller_for_Common_Buffer_DMA_KG"></A>3.3.4.2.2  Setting Up the System DMA Controller for Common-Buffer DMA</H5>
<P>
When <B>IoAllocateAdapterChannel</B>&nbsp;transfers control to a driver’s
AdapterControl routine, the driver “owns” the system DMA controller and a set
of map registers. Then, the driver must call <B>IoMapTransfer</B>&nbsp;to set up
the system DMA controller to use the driver-allocated common buffer before the
driver sets up its device for the transfer operation. See <A HREF="03ntobj_15.htm#DDK_Figure_3..8_KG">Figure
3.8</A>&nbsp;for an illustration of calls to <B>IoMapTransfer</B>.
<P>
The driver supplies the following parameters to <B>IoMapTransfer</B>:
<UL>
<LI>
The <I>AdapterObject</I>&nbsp;pointer returned by <B>HalGetAdapter</B>&nbsp;(see <A HREF="03ntobj_12.htm">Section
3.3.2</A>)
<P>
<LI>
A pointer to the MDL describing the driver-allocated common buffer (see <A HREF="#DDK_Common_Buffer_System_DMA_KG">Section
3.3.4.2</A>)
<P>
<LI>
The <I>MapRegisterBase</I>&nbsp;handle passed to the driver’s AdapterControl
routine by <B>IoAllocateAdapterChannel</B>
<P>
<LI>
A pointer to a variable (<I>Length</I>) indicating the size in bytes of the
driver-allocated common buffer
<P>
<LI>
A Boolean value, indicating the direction of the transfer operation (TRUE for
a requested transfer from system memory to the device)
</UL>
<P>
<B>IoMapTransfer</B>&nbsp;returns a logical address, which drivers that use system
DMA must ignore. When <B>IoMapTransfer</B>&nbsp;returns control, the driver should
set up its device for the DMA operation. Note that such a driver calls <B>IoMapTransfer</B>
only once but continues to copy data between its common buffer and a
locked-down user buffer until the requested transfer is done.
<P>
The driver can call <B>HalReadDmaCounter</B>&nbsp;to determine how many bytes
currently remain to be transferred in the common buffer, so such a driver can
continue to fill its common buffer with user data or copy data from its common
buffer to the user buffer.
<P>
When all the requested transfer is complete or the driver must return an error
status for the IRP, the driver calls <B>IoFlushAdapterBuffers</B>&nbsp;to ensure
that any data cached in the system DMA controller is read into system memory
or written out to the device. Then, the driver should call <B>IoFreeAdapterChannel</B>
promptly to release the system DMA controller for other drivers and this
driver to use.
<P></FONT>
</BODY>
</HTML>
