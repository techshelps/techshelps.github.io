<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.4.1  Creating a Controller Object with a Controller Extension</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Creating_a_Controller_Object_with_a_Controller_Extension_KG"></A>3.4.1  Creating a Controller Object with a Controller Extension</H3>
<P>
<A NAME="DDK_Figure_3.13_KG"></A>If an NT driver uses a controller object, it must
call <B>IoCreateController</B>&nbsp;when the driver initializes. Figure 3.13
illustrates such a call from the <B>DriverEntry</B>&nbsp;routine.
<P>
<B><IMG SRC="../art/3ctlrobj.gif" BORDER=0></B>
<P>
<B>Figure 3.13    Controller Object</B>
<P>
Like a driver-created device object, every controller object has an associated
controller extension. As Figure 3.13 show, the caller of <B>IoCreateController</B>
determines the <I>Size</I>&nbsp;of the controller extension. Its structure and
contents are driver-defined.
<P>
In addition to whatever device-specific state information the driver maintains
about the physical controller (or device with channels), Figure 3.13 shows a
representative set of driver-defined data for a controller extension.
<P>
The PtrToControllerObject returned by <B>IoCreateController</B>&nbsp;must be passed
in the driver’s calls to <B>IoAllocateController</B>&nbsp;and <B>IoFreeController</B>,
described in <A HREF="03ntobj_22.htm">Section
3.4.2</A>, next. The <B>DriverEntry</B>&nbsp;routine must store the returned controller
object pointer in the device extension(s) of its driver-created device
object(s) or in another driver-accessible resident storage area (nonpaged
pool, allocated by the driver). If such a driver is unloaded, it also must
pass the controller object pointer to <B>IoDeleteController</B>.
<P>
Most drivers that set up controller objects find it convenient to store a
pointer to the current target device object or device extension in the
controller extension. Usually, such a driver stores the controller object
pointer in every one of its device extensions so that it can use the <I>ControllerObject</I><B>-&gt;ControllerExtension</B>
pointer to access driver-maintained, controller-specific state about I/O
operations for every target device object.
<P>
If the physical controller represented by a controller object generates
interrupts, a driver also can use the controller extension as storage for the
PtrToInterruptObject(s) returned by <B>IoConnectInterrupt</B>. For more
information about interrupt objects, see <A HREF="03ntobj_23.htm">Section
3.5</A>, later in this chapter.
<P>
<B>IoCreateController</B>&nbsp;allocates resident storage for the controller object
and extension, which it initializes with zeros. If it cannot allocate the
memory, <B>IoCreateController</B>&nbsp;returns a NULL pointer. If this occurs, the <B>DriverEntry</B>
routine must fail the inititialization and should return
STATUS_INSUFFICIENT_RESOURCES.
<P></FONT>
</BODY>
</HTML>
