<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A.2.3  SCSI Filter Driver’s DriverEntry Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_SCSI_Filter_Drivers_DriverEntry_Routine_KG"></A>A.2.3  SCSI Filter Driver’s DriverEntry Routine</H3>
<P>
Like any other kernel-mode driver, the DriverEntry routine of an SFD must
define its Dispatch (and Unload, if any) entry points in the input driver
object. Then, the SFD must create one or more device objects with <B>IoCreateDevice</B>,
layer itself over the appropriate SCSI class driver with <B>IoAttachDevice</B>,
and set up one or more requests to find its device(s), if any, on a SCSI bus
in the machine. 
<P>
SFDs for certain kinds of devices might call <B>IoGetConfigurationInformation</B>
to determine how many devices of their respective types are already
represented by named device objects. The count of named device objects in the
I/O Manager’s CONFIGURATION_INFORMATION-type structure places an upper bound
on the number of device objects such an SFD might need to create. 
<P>
If this system-defined structure does not have a count for the driver’s type
of device, an SFD can examine the registry for devices of its type. For more
information about using the I/O Manager’s global configuration information
structure and/or the registry, see Chapter 16. 
<P>
Note that a configuration information count or the registry keys for a given
type of device also could include device objects for nonSCSI devices and/or
other hardware vendors’ SCSI devices of the filter driver’s type. 
<P>
An SFD’s DriverEntry routine must determine whether any particular device
object(s) created by another driver actually represent a SCSI device that the
driver supports. 
<P>
After the SFD has layered itself over the SCSI class driver (or over another
driver for its type of device), the DriverEntry routine must allocate a buffer
and set up a request for SCSI-II inquiry data about the underlying device(s).
On a successful return from this request, the SFD must inspect the buffered
inquiry data for the vendor name and, possibly, model designation to determine
whether the device is one the driver supports. If so, the SFD should set up
the device extension in its device object. For more information about
GetInquiryData routines, see <A HREF="appascsi_5.htm">Section
A.1.3.1</A>. 
<P>
Note that every driver must call <B>IoAttachDevice</B>&nbsp;with a driver-created
device object. Therefore, an SFD must create a device object <I>before</I>&nbsp;it
can determine whether the underlying device is one that it supports. Its
DriverEntry routine must call <B>IoDetachDevice</B>&nbsp;and, then, <B>IoDeleteDevice</B>
to release any device objects it creates for unsupported devices. The
DriverEntry routine also must free the memory it allocated for SCSI-II inquiry
data before it returns control. 
<P>
Assuming it finds a device it supports, the SFD must save the pointer,
returned from <B>IoAttachDevice,</B>&nbsp;to the SCSI class driver’s device object
in its own device extension so the SFD can send IRPs on to the class driver.
If the SFD sends device-specific requests through the class driver, it might
need to set up SCSI-specific data in the device extension of its device
object(s). In other words, such an SFD’s device extension should include any
SCSI-specific data necessary to manage its device-specific requests. 
<P>
For more information about setting up a higher-level driver’s device extension
with SCSI-specific data, see <A HREF="appascsi_8.htm">Section
A.1.3.4</A>. For more information about the general requirements for DriverEntry
routines, see Chapter 5. 
<P></FONT>
</BODY>
</HTML>
