<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>13.2  IoCompletion Routine Required Functionality</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_IoCompletion_Routine_Required_Functionality_KG"></A>13.2  IoCompletion Routine Required Functionality</H2>
<P>
On entry, an IoCompletion routine is called with <I>DeviceObject</I>, <I>Irp</I>,
and <I>Context</I>&nbsp;pointers, as shown by the declaration. The Dispatch routine
that called <B>IoSetCompletionRoutine</B>&nbsp;can pass a <I>Context</I>&nbsp;pointer to
whatever driver-determined context it set up for the IoCompletion routine to
use in processing the given IRP. Note that such a context area cannot be
pageable because the IoCompletion routine can be called at IRQL
DISPATCH_LEVEL. 
<P>
When it is called, an IoCompletion routine is responsible for doing whatever
additional IRP processing the driver writer chooses and any necessary cleanup
operations for the request, as determined by how the Dispatch routine set up
the request. 
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>Consider the following
implementation guidelines for IoCompletion routines<B>&nbsp;</B>
<UL>
<LI>
If the input IRP was allocated by the Dispatch routine with <B>IoAllocateIrp</B>
or <B>IoBuildAsynchronousFsdRequest</B>, the IoCompletion routine must call <B>IoFreeIrp</B>
to release that IRP, preferably before it completes the original IRP. 
<P>
<UL>
<LI>
The IoCompletion routine must release any per-IRP resources the Dispatch
routine allocated for such a driver-allocated IRP, preferably before it frees
the corresponding IRP.
<P>
For example, if the Dispatch routine allocated an MDL for a partial-transfer
IRP that the IoCompletion routine is processing, the IoCompletion routine must
call <B>IoFreeMdl</B>&nbsp;to free that MDL before it returns control from
completing the original request. 
<P>
<LI>
If the IoCompletion routine cannot complete the original IRP with
STATUS_SUCCESS, it must set the I/O status block in the original IRP to the
value returned in the driver-allocated IRP that caused the IoCompletion
routine to fail the original request. 
<P>
<LI>
If the IoCompletion routine will complete the original request with
STATUS_PENDING, it must call <B>IoMarkIrpPending</B>&nbsp;with the original IRP
before it calls <B>IoCompleteRequest</B>. 
<P>
<LI>
If the IoCompletion routine must fail the original IRP with an error STATUS_<I>XXX</I>,
it can log an error. However, it is the responsibility of the underlying
device driver to log any device I/O errors that occur, so IoCompletion
routines usually do not log errors. 
<P>
For more information about logging I/O errors, see Chapter 16. 
<P>
<LI>
When it has processed such a driver-allocated IRP and freed it, the
IoCompletion routine must return control with STATUS_MORE_PROCESSING_REQUIRED.
<P>
Returning STATUS_MORE_PROCESSING_REQUIRED from the IoCompletion routine
forestalls the I/O Manager’s completion processing for a driver-allocated and
freed IRP. 
</UL>
<P>
<LI>
If the IoCompletion routine reuses an incoming IRP to send one or more
requests to lower drivers, it should update whatever context the IoCompletion
routine maintains about each reuse (or retry) of the IRP before it sets up the
next-lower driver’s I/O stack location again, calls <B>IoSetCompletionRoutine</B>
with its own entry point, and calls <B>IoCallDriver</B>&nbsp;with the IRP. 
<P>
<UL>
<LI>
The IoCompletion routine should <I>not</I>&nbsp;call <B>IoMarkIrpPending</B>&nbsp;at
each reuse or retry of the IRP. 
<P>
The Dispatch routine already marked the original IRP as pending. Until all
drivers in the chain complete the original IRP with <B>IoCompleteRequest</B>,
it remains pending. 
<P>
<LI>
Before it retries a request, the IoCompletion routine should reset the I/O
status block with STATUS_SUCCESS for <B>Status</B>&nbsp;and zero for <B>Information</B>,
possibly after saving the returned error information. 
<P>
For each retry, the IoCompletion routine usually decrements a count set up by
the Dispatch routine because the IoCompletion routine must fail such an IRP
with <B>IoCompleteRequest</B>&nbsp;when some limited number of retries have failed.
<P>
<LI>
The IoCompletion routine must return STATUS_MORE_PROCESSING_REQUIRED after it
calls <B>IoSetCompletionRoutine</B>&nbsp;and <B>IoCallDriver</B>&nbsp;with an IRP that
is being reused or retried. 
<P>
Returning STATUS_MORE_PROCESSING_REQUIRED from the IoCompletion routine
forestalls the I/O Manager’s completion processing of a reused or retried IRP.
<P>
<LI>
If the IoCompletion routine cannot complete the original IRP with
STATUS_SUCCESS, it must leave the I/O status block as returned by lower
drivers for the reuse or retry operation that causes the IoCompletion routine
to fail the IRP. 
<P>
<LI>
If the IoCompletion routine will complete the original request with
STATUS_PENDING, it must call <B>IoMarkIrpPending</B>&nbsp;with the original IRP
before it calls <B>IoCompleteRequest</B>. 
<P>
<LI>
If the IoCompletion routine must fail the original IRP with an error STATUS_<I>XXX</I>,
it can log an error. However, it is the responsibility of the underlying
device driver to log any device I/O errors that occur, so IoCompletion
routines usually do not log errors. 
<P>
For more information about logging I/O errors, see Chapter 16. 
</UL>
<P>
<LI>
The IoCompletion routine must release any resources the Dispatch routine
allocated for processing the original IRP, preferably before the IoCompletion
routine calls <B>IoCompleteRequest</B>&nbsp;with the original IRP and definitely
before the IoCompletion routine returns control from completing the original
IRP. 
</UL>
<P>
If any still-higher-level driver has set its IoCompletion routine in the
original IRP, that driver’s IoCompletion routine is not called until all
lower-level drivers have called <B>IoCompleteRequest</B>&nbsp;with the original
IRP. 
<P>
&nbsp;
<P></FONT>
</BODY>
</HTML>
