<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A.4.5.3  Handling SRB_FUNCTION_ABORT_COMMAND</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Handling_SRB_FUNCTION_ABORT_COMMAND_KG"></A>A.4.5.3  Handling SRB_FUNCTION_ABORT_COMMAND</H4>
<P>
A HwScsiStartIo routine is also responsible for handling incoming SRBs with
the <B>Function</B>&nbsp;member set to SRB_FUNCTION_ABORT_COMMAND. 
<P>
For an abort request, the miniport’s HwScsiStartIo routine should verify that
the given SRB has not been aborted already by calling <B>ScsiPortGetSrb</B>
for the target logical unit and comparing the returned pointer to the current
SRB’s <B>NextSrb</B>&nbsp;value. If they are unequal, the current SRB has already
been aborted, and the miniport’s HwScsiStartIo routine should do the
following: 
<OL>
<LI>
Set the input SRB’s <B>ScsiStatus</B>&nbsp;to SRB_STATUS_ABORT_FAILED. 
<P>
<LI>
Call <B>ScsiPortNotification</B>&nbsp;with the <I>NotificationType</I>&nbsp;<B>RequestComplete</B>
and with the input SRB. 
<P>
<LI>
Call <B>ScsiPortNotification</B>&nbsp;again with the <I>NotificationType</I>&nbsp;<B>NextRequest</B>,
or with <B>NextLuRequest</B>&nbsp;if the HBA supports tagged queueing or multiple
requests per logical unit. 
</OL>
<P>
Otherwise, the HwScsiStartIo routine does the following:
<OL>
<LI>
Sets up context for the request in its device, logical unit, and/or SRB
extensions 
<P>
<LI>
Programs the HBA to abort the given <B>NextSrb</B>&nbsp;request 
</OL>
<P></FONT>
</BODY>
</HTML>
