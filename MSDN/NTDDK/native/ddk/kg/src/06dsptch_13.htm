<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>6.3.1.1  Basic DispatchCreateClose Routines</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Basic_DispatchCreateClose_Routines_KG"></A>6.3.1.1  Basic DispatchCreateClose Routines</H4>
<P>
Many NT drivers merely need to establish their existence on receipt of a
create request and merely need to acknowledge the receipt of a close request,
particularly lower-level drivers in a chain of layered NT drivers.
<DL>
<DT>
For example, a port driver of a device controller with one or more closely
coupled class drivers that call <B>IoGetDeviceObjectPointer</B>&nbsp;might have a
minimalist DispatchCreateClose routine. Such a port driver’s
DispatchCreateClose routine might do nothing more than complete the IRP as
follows:
<DD>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; :&#09;: 
{ 
&nbsp; &nbsp; Irp-&gt;IoStatus.Status = STATUS_SUCCESS; 
&nbsp; &nbsp; Irp-&gt;IoStatus.Information = 0; 
&nbsp; &nbsp; IoCompleteRequest(Irp, IO_NO_INCREMENT); 
&nbsp; &nbsp; return STATUS_SUCCESS; 
} 
&nbsp;</FONT></PRE>
</DL>
<P>
This minimalist DispatchCreateClose routine sets the <B>Information</B>&nbsp;member
of the I/O status block to zero indicating the file object is opened for a
create request; <B>Information</B>&nbsp;has no meaning for a close request. It sets
the <B>Status</B>&nbsp;member with and returns STATUS_SUCCESS, which indicates that
it is ready to accept I/O requests for the target device object from the
higher-level class driver that caused the create IRP to be sent to the port
driver’s DispatchCreateClose routine when that class driver called <B>IoGetDeviceObjectPointer</B>.
<P>
This minimalist DispatchCreateClose routine completes the create IRP without
boosting the priority of the originator of the IRP (IO_NO_INCREMENT) because
the originator of the request is assumed to wait for an indeterminate but very
small interval on the completion of this request.
<P>
How much work a DispatchCreateClose routine does depends partly on the nature
of the driver’s device or the underlying device and partly on the design of
the driver(s). At the discretion of the driver designer, an NT driver can
handle these requests in separate DispatchCreate and DispatchClose routines,
particularly when the driver performs quite different operations for each
request.
<P>
For a create request to open a file object that represents a logical or
physical device, a highest-level NT driver should do the following:
<OL>
<LI>
Call <B>IoGetCurrentIrpStackLocation</B>&nbsp;to get a pointer to its I/O stack
location in the IRP.
<P>
<LI>
Check the <B>FileObject.FileName</B>&nbsp;in the I/O stack location and complete
the IRP with STATUS_SUCCESS if the Unicode string at <B>FileName</B>&nbsp;has a
zero length; otherwise, complete the IRP with STATUS_INVALID_PARAMETER. 
</OL>
<P>
Following the preceding steps ensures that no attempt to open a pseudofile on
a device can cause problems later. For example, this prevents attempts to open
a nonexistent \\device\parallel0\temp.dat.
<P></FONT>
</BODY>
</HTML>
