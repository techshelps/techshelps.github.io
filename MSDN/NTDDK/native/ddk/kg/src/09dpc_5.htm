<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>9.1.4  Additional Required Driver Routines</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Additional_Required_Driver_Routines_KG9"></A>9.1.4  Additional Required Driver Routines</H3>
<P>
An NT device driver’s ISR saves context information for its DpcForIsr and/or
CustomDpc routines. Sometimes the DpcForIsr or CustomDpc routine is
responsible for retrying operations, setting up another DMA transfer operation
to satisfy a given request, or otherwise accessing the same device registers
or context area as the ISR does. 
<P>
When any NT driver routine shares context information or device registers with
an ISR, that routine must call <B>KeSynchronizeExecution</B>&nbsp;with a
driver-supplied SynchCritSection routine in order to access the shared context
safely. 
<P>
Unless an NT device driver serializes its IRP processing by completing each
request before it starts device I/O operations for the next IRP, the driver
must have at least one SynchCritSection routine. While it is almost impossible
for the ISR and another routine, such as its DpcForIsr or CustomDpc, to access
shared state concurrently if a driver serializes IRP processing, handling IRPs
in this manner prevents such a driver from achieving the best possible I/O
throughput for its device. 
<P>
Note that an NT driver that serializes its IRP processing can run no faster in
Windows NT&reg; SMP machines than in uniprocessor machines. 
<P></FONT>
</BODY>
</HTML>
