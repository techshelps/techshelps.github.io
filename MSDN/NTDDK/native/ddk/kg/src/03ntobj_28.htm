<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.6.2  Registering and Queueing a CustomDpc Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Registering_and_Queueing_a_CustomDpc_Routine_KG"></A>3.6.2  Registering and Queueing a CustomDpc Routine</H3>
<P>
<A NAME="DDK_Figure_3.18_KG"></A>An NT device driver can register a CustomDpc
routine by calling <B>KeInitializeDpc</B>&nbsp;when the driver initializes. Just
before it returns control, the ISR can call <B>KeInsertQueueDpc</B>&nbsp;to have
the CustomDpc routine queued for execution. Figure 3.18 illustrates calls to
these routines.
<P>
<B><IMG SRC="../art/3cstmdpc.gif" BORDER=0></B>
<P>
<B>Figure 3.18    Using a DPC Object for a CustomDpc Routine</B>
<P>
As Figure 3.18 shows, a driver that has a CustomDpc routine must provide the
storage for a DPC object. Because the driver must pass a pointer to the DPC
object from its ISR, the storage must be in resident system-space memory. Most
NT device drivers with CustomDpc routines provide storage for their DPC
objects in the device extension of a driver-created device object (see <A HREF="03ntobj_2.htm">Section
3.2</A>), but the storage can be in a controller extension if the driver uses a
controller object (see <A HREF="03ntobj_20.htm">Section 3.4</A>) or in
nonpaged pool allocated by the driver.
<P>
When the <B>DriverEntry</B>&nbsp;routine calls <B>KeInitializeDpc</B>, it must pass
the entry point for its CustomDpc routine and pointers to the driver-allocated
storage for the DPC object and to the driver-defined DeferredContext area,
which is passed to the CustomDpc routine when it is called. Because it must be
accessible at raised IRQL, the <I>DeferredContext</I>-accessible area also
must be in resident memory.
<P>
Note that a CustomDpc routine is not associated with a given device object as
the DpcForIsr routine is when the driver calls <B>IoInitializeDpcRequest,</B>
as described in <A HREF="03ntobj_27.htm">Section
3.6.1</A>. Nevertheless, the DeferredContext area for a CustomDpc routine almost
always includes pointers to the target device object and current IRP, because
a CustomDpc routine has the same functional requirements as a DpcForIsr
routine: to complete an interrupt-driven I/O operation at a lower IRQL than
the ISR.
<P>
As Figure 3.18 shows, the ISR passes pointers to the DPC object and to two
additional parameters, which are caller-determined, to <B>KeInsertQueueDpc</B>.
If all processors in the machine currently have code running at IRQL greater
than or equal to DISPATCH_LEVEL, the DPC object is queued until the IRQL falls
below DISPATCH_LEVEL on a processor. Then, the Kernel dequeues the DPC object
and the driver’s CustomDpc routine is run on the processor at IRQL
DISPATCH_LEVEL.
<P>
Only a single instantiation of a given DPC object can be queued at any given
moment. That is, if an ISR calls <B>KeInsertQueueDpc</B>&nbsp;more than once with
the same <I>Dpc</I>&nbsp;pointer before the driver’s CustomDpc routine is run, the
CustomDpc routine runs only once after IRQL falls below DISPATCH_LEVEL on a
processor.
<P>
A CustomDpc routine is responsible for doing whatever is necessary to complete
the I/O operation(s) that caused the interrupt(s). For more information about
the functionality required of a CustomDpc routine, see Chapter 9.
<P>
Note that the ISR and CustomDpc can be run concurrently in a symmetric
multiprocessor machine, so NT driver writers who implement CustomDpc routines
should follow the guidelines set out in <A HREF="03ntobj_27.htm">Section
3.6.1</A>.
<P></FONT>
</BODY>
</HTML>
