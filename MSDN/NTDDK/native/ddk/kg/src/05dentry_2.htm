<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>5.1.1  Every DriverEntry Routine’s Responsibilites</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Every_DriverEntry_Routines_Responsibilites_KG"></A>5.1.1  Every DriverEntry Routine’s Responsibilites</H3>
<P>
Every DriverEntry routine is run in the context of a system thread at IRQL
PASSIVE_LEVEL.
<P>
In general, a DriverEntry routine is responsible for exporting the driver’s
other entry points, for initializing the NT objects the driver uses, and for
setting up any other system resources that the driver uses. For more
information about NT objects, see Chapter 3.
<P>
A DriverEntry routine can use the Windows NT&reg; registry to get some of the
information it needs to initialize the driver or its device(s). The
DriverEntry routine must set information in the registry for other NT drivers
and/or protected subsystems to use. For more information about using the
registry, see Chapter 16.
<H4><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; In particular, every DriverEntry routine must do the following: </H4>
<UL>
<LI>
Fill in the driver object entry points for the driver’s Dispatch, StartIo (if
any), and Unload (if any) routines.
<P>
See Chapter 2 for how to do this. For more information about Dispatch,
StartIo, and Unload routines, see Chapters 6, 7, and 15, respectively.
<P>
<LI>
Create a named device object to represent each physical, logical, or virtual
device for which the driver handles I/O requests.
<P>
See Chapter 3 for how to set up a device object.
<P>
<LI>
Claim any necessary hardware resources or find appropriate lower-level drivers
in the registry, and set up any necessary symbolic links between the names of
the driver’s device objects and the Win32&reg; subsystem names for the same
devices. The I/O Manager provides support for setting up these symbolic links.
<P>
See Chapter 16 for more information about using the registry and setting up
symbolic links.
<P>
<LI>
Register the driver’s other entry points and set up the NT objects necessary
for any other standard routines the driver has.
<P>
For routine-specific requirements, see Chapters 7-9, 11, and 14.
<P>
<LI>
Create and/or initialize any other NT objects, types, or resources the driver
uses, such as the following:
<P>
<UL>
<LI>
If the driver has a device-dedicated thread or waits on any Kernel-defined
dispatcher objects, the DriverEntry routine must initialize the dispatcher
object(s) that its thread or the driver waits on by calling the appropriate <B>KeInitialize</B><I>Xxx</I>
support routine with a pointer to the event, semaphore, mutex, and/or timer
object(s) for which the driver provides the storage.
<P>
Because it executes in a system-thread context, the DriverEntry routine itself
can wait for a nonzero interval on a dispatcher object, which must be
initialized before the wait begins. For example, class drivers that call down
to a corresponding port driver during initialization usually wait on an event
object they associate with an IRP, which they allocate with <B>IoBuildSynchronousFsdRequest</B>
and pass with <B>IoCallDriver</B>&nbsp;to the port driver for the physical device.
<P>
See Chapter 3 for more information about waiting on dispatcher objects.
<P>
<LI>
If the driver uses any executive spin lock(s) or provides the storage for an
interrupt spin lock, the DriverEntry routine must call <B>KeInitializeSpinLock</B>
with each such spin lock before passing it to any other support routine.
<P>
See Chapter 16 for guidelines on how to use spin locks, and Chapter 8 for more
information about whether a device driver must supply storage for an interrupt
spin lock.
</UL>
<P>
<LI>
Return NTSTATUS indicating whether the driver can accept and successfully
process I/O requests for at least one named device object that the driver
created.
</UL>
<H5>Return from DriverEntry</H5>
<P>
As shown by its declaration, a DriverEntry routine returns an NTSTATUS-type
value. The DriverEntry routine should postpone any call to <B>IoRegisterDriverReinitialization</B>
until just before it returns STATUS_SUCCESS. It must not make this call unless
it will return STATUS_SUCCESS.
<P>
If a DriverEntry routine returns something other than STATUS_SUCCESS to
indicate that it can successfully process I/O requests for at least one named
device object that it created, that driver does not remain loaded.
<P>
A DriverEntry routine that will fail initialization must free any NT objects,
system resources, and registry resources it has already set up before it
returns control. It should reset the driver’s Dispatch entry points in the
driver object for IRP_MJ_FLUSH_BUFFERS and/or IRP_MJ_SHUTDOWN to NULL if the
driver supports these requests. If it already called <B>IoRegisterShutdownNotification</B>,
the DriverEntry routine must call <B>IoUnregisterShutdownNotification</B>
before it fails initialization.
<P>
If a driver will fail initialization, the DriverEntry routine also should log
an error or have <B>IoReportResourceUsage</B>&nbsp;log a hardware resource conflict
error on a device driver’s behalf <I>before</I>&nbsp;DriverEntry returns control.
For more information about logging I/O and resource-conflict errors, see
Chapter 16.
<P></FONT>
</BODY>
</HTML>
