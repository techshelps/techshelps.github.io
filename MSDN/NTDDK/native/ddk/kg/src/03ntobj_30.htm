<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.7.1  Registering and Enabling an IoTimer Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Registering_and_Enabling_an_IoTimer_Routine_KG"></A>3.7.1  Registering and Enabling an IoTimer Routine</H3>
<P>
<A NAME="DDK_Figure_3.19_KG"></A>Any NT driver can register an IoTimer routine
after it creates one or more device objects by calling <B>IoInitializeTimer</B>
when the driver initializes. After the driver has initialized, it can enable
the timer by calling <B>IoStartTimer</B>. Figure 3.19 illustrates these calls.
<P>
<B><IMG SRC="../art/3iotimr.gif" BORDER=0></B>
<P>
<B>Figure 3.19    Using a Timer Object for an IoTimer Routine</B>
<P>
As Figure 3.19 shows, the driver calls <B>IoInitializeTimer</B>&nbsp;with the entry
point of its IoTimer routine and pointers to a driver-created device object
and TimerContext area in which the driver maintains whatever context its
IoTimer routine uses. The I/O Manager associates the device object with a
Kernel timer object, which the I/O Manager sets up to time out every second.
<P>
After the driver calls <B>IoStartTimer</B>, its IoTimer routine is called once
per second until the driver calls <B>IoStopTimer</B>. An NT driver can
re-enable calls to its IoTimer routine with <B>IoStartTimer</B>.
<P>
On entry, the IoTimer routine is given <I>DeviceObject</I>&nbsp;and <I>Context</I>
pointers to the associated device object and TimerContext area that was set up
when the driver called <B>IoInitializeTimer</B>.
<P>
Because an IoTimer routine is run at IRQL DISPATCH_LEVEL, its TimerContext
area must be in resident, system-space memory. Most NT drivers that have
IoTimer routines use the <I>DeviceObject</I>-&gt;<B>DeviceExtension</B>&nbsp;of the
associated device object as such a <I>Context</I>-accessible area, but it can
be in a controller extension if the driver uses a controller object (see <A HREF="03ntobj_20.htm">Section
3.4</A>) or in nonpaged pool allocated by the driver.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; Driver writers who implement an IoTimer routine should follow these guidelines concerning the TimerContext area: </H5>
<UL>
<LI>
If the IoTimer routine shares its TimerContext area with the driver’s ISR, it
must call <B>KeSynchronizeExecution</B>&nbsp;with a SynchCritSection routine in
order to access the TimerContext area in a multiprocessor-safe manner.
<P>
For more information about SynchCritSection routines, see Chapter 10. See also
the section about using spin locks in Chapter 16 for more information about <B>KeSynchronizeExecution</B>.
<P>
<LI>
If the IoTimer routine does not share its TimerContext area with an ISR but
does share it with another driver routine, the driver must protect this
context area with an initialized executive spin lock in order to access the
TimerContext in a multiprocessor-safe manner.
<P>
For more information about initializing and using executive spin locks, see
Chapter 16.
</UL>
<P>
For more information about the functionality required of an IoTimer routine,
see Chapter 14.
<P></FONT>
</BODY>
</HTML>
