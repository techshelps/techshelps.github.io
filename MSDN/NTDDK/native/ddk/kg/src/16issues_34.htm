<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.8.2.1  Calling IoQueryDeviceDescription</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Calling_IoQueryDeviceDescription_KG"></A>16.8.2.1  Calling IoQueryDeviceDescription</H4>
<P>
NT device drivers can call <B>IoQueryDeviceDescription</B>&nbsp;to obtain the
system-detected and system-supplied hardware configuration information about
their devices from the registry.
<H5>Supplying a ConfigCallback Routine</H5>
<P>
A device driver that calls <B>IoQueryDeviceDescription</B>&nbsp;must provide a
ConfigCallback routine, defined as follows:
<PRE><FONT FACE="Courier" SIZE="2">NTSTATUS 
&nbsp; &nbsp; (*PIO_QUERY_DEVICE_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID Context,                     //driver-determined 
&nbsp; &nbsp; &nbsp; &nbsp; IN PUNICODE_STRING PathName, 
&nbsp; &nbsp; &nbsp; &nbsp; IN INTERFACE_TYPE BusType,            //system-defined enum 
&nbsp; &nbsp; &nbsp; &nbsp; IN ULONG BusNumber,                   //system-assigned count 
&nbsp; &nbsp; &nbsp; &nbsp; IN PKEY_VALUE_FULL_INFORMATION *BusInformation, 
&nbsp; &nbsp; &nbsp; &nbsp; IN CONFIGURATION_TYPE ControllerType, //system-defined enum 
&nbsp; &nbsp; &nbsp; &nbsp; IN ULONG ControllerNumber, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation, 
&nbsp; &nbsp; &nbsp; &nbsp; IN CONFIGURATION_TYPE PeripheralType, //system-defined enum 
&nbsp; &nbsp; &nbsp; &nbsp; IN ULONG PeripheralNumber, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<P>
The <I>Context</I>&nbsp;pointer passed to a ConfigCallback routine accesses a
driver-determined storage area. However, the kernel-mode stack is limited in
size: somewhat less than two pages are available for data storage by the
DriverEntry and ConfigCallback routines and the amount of information returned
cannot be predetermined. NT drivers usually call <B>ExAllocatePool</B>&nbsp;or <B>ExAllocatePoolWithTag</B>
to allocate a paged pool buffer for the configuration information passed
between their DriverEntry and ConfigCallback routines. The DriverEntry routine
can free such a buffer when it has consumed and processed (as described in <A HREF="16issues_36.htm">Section
16.8.3</A>) the information supplied by its ConfigCallback routine.
<P>
Note the order of the bus, controller, and peripheral parameters to a
ConfigCallback routine. The corresponding parameters to <B>IoQueryDeviceDescription</B>
are declared to be optional, but the DriverEntry routine must supply
appropriate values for at least one of the following sets of parameters when
it calls <B>IoQueryDeviceDescription</B>:
<UL>
<LI>
<I>BusType</I>&nbsp;and <I>BusNumber</I>
<P>
<LI>
<I>ControllerType</I>&nbsp;and <I>ControllerNumber</I>
<P>
<LI>
<I>PeripheralType</I>&nbsp;and <I>PeripheralNumber</I>
</UL>
<P>
Depending on the information requested when the DriverEntry routine calls <B>IoQueryDeviceDescription</B>,
the <I>PathName</I>&nbsp;passed to the ConfigCallback routine points to a registry
key that contains successively more device-specific and detailed information.
For example, if a driver requests information only about a particular I/O bus
in the machine, the <I>PathName</I>&nbsp;passed to the ConfigCallback routine would
point to the key containing bus information. If the driver also requests
information about both a <I>ControllerType</I>&nbsp;and a <I>PeripheralType</I>,
the <I>PathName</I>&nbsp;parameter to the ConfigCallback routine would point to the
registry key containing peripheral information.
<H5>Making Calls to IoQueryDeviceDescription</H5>
<P>
<A NAME="DDK_Figure_16..7_NG"></A>Figure 16.7 illustrates a device driver’s call
to <B>IoQueryDeviceDescription</B>.
<P>
<B><IMG SRC="../art/16qrcnfg.gif" BORDER=0></B>
<P>
<B>Figure 16.7    Getting Hardware Configuration Information from the Registry</B>
<P>
Driver-supplied pointers for <I>Context</I>&nbsp;and the ConfigCallback routine are
required parameters to <B>IoQueryDeviceDescription</B>. All other parameters
are optional, so the caller can specify one or more of the bus, controller,
and peripheral parameter sets, possibly in separate calls to <B>IoQueryDeviceDescription</B>
with separate ConfigCallback routines. NT drivers usually need
device-type-specific hardware information about a given <I>ControllerType</I>
and/or <I>PeripheralType</I>.
<P>
System-defined enumerated values for the <I>BusType</I>&nbsp;parameter indicate the
types of interfaces that I/O buses in Windows NT machines provide. The driver
for a device that must be connected on an ISA bus would set <I>BusType</I>&nbsp;to
the system-defined INTERFACE_TYPE value <B>Isa</B>&nbsp;when it called <B>IoQueryDeviceDescription</B>.
<P>
A device driver could also search for its devices on every I/O bus in the
machine. Any driver can set <I>BusType</I>&nbsp;to successive values by using the
system-defined value <B>MaximumInterfaceType</B>&nbsp;as a loop-control variable
for calling <B>IoQueryDeviceDescription</B>, particularly if a driver
constrains its query by specifying values for the <I>ControllerType</I>&nbsp;and/or
<I>PeripheralType</I>&nbsp;parameters.
<P>
<B>IoQueryDeviceDescription</B>&nbsp;returns STATUS_OBJECT_NAME_NOT_FOUND if a
particular type of bus is not available in the machine.
<P>
NT device drivers can use the following system-defined CONFIGURATION_TYPE
values for the <I>ControllerType</I>&nbsp;and <I>PeripheralType</I>&nbsp;parameters to <B>IoQueryDeviceDescription</B>:
<TABLE>
<TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><I>ControllerType </I>Values:</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B><I>PeripheralType </I>Values:</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>DiskController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>DiskPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>TapeController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>FloppyDiskPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>CdromController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>TapePeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>WormController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>ModemPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>SerialController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>MonitorPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>NetworkController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>PrinterPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>DisplayController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>PointerPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>ParallelController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>KeyboardPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>PointerController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>TerminalPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>KeyboardController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>OtherPeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>AudioController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>LinePeripheral</B>
</FONT><TR VALIGN=top>
<TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>OtherController</B>
</FONT><TD><FONT FACE="ARIAL,HELVETICA" SIZE="2">
<P>
<B>NetworkPeripheral</B>
</FONT></TABLE>
<P>
Most of these defined type names are self-explanatory. However, the <I>PeripheralType</I>
value <B>MonitorPeripheral</B>&nbsp;indicates a video monitor for which there is a
corresponding video adapter. The value <B>TerminalPeripheral</B>&nbsp;indicates a
so-called “dumb terminal” that displays data usually sent through a serial
port. The value <B>LinePeripheral</B>&nbsp;indicates a peripheral device connected
to the machine by a controller line.
<P>
Depending on which optional parameters the DriverEntry routine passes to <B>IoQueryDeviceDescription</B>,
its ConfigCallback routine is given values for the corresponding parameters
when it is called. A ConfigCallback routine can save these values (such as
system-assigned bus numbers) in a temporary buffer, usually allocated from
paged pool as described in <A HREF="16issues_13.htm">Section
16.4.1.3</A>&nbsp;and released from the DriverEntry routine, or on the stack for
subsequent calls to HAL routines.
<H5>IoQueryDevice<I>Xxx</I>&nbsp;Pointers Input to ConfigCallback</H5>
<P>
Depending on which optional parameters the DriverEntry routine passes to <B>IoQueryDeviceDescription</B>,
a ConfigCallback routine is also given one or more nonNULL pointers to <B>BusInformation</B>,
<B>ControllerInformation</B>, and <B>PeripheralInformation</B>, as shown in <A HREF="#DDK_Figure_16..7_NG">Figure
16.7</A>. Each of these parameters is actually an array of pointers whose elements
select ARC- or NtDetect-supplied information in the <B>\Registry\Machine\Hardware\Description</B>
tree.
<P>
NT device drivers can use any of the following system-defined values to get to
the kind(s) of bus, controller, or peripheral information they need from the
registry:
<UL>
<LI>
<B>IoQueryDeviceIdentifier</B>&nbsp;points to any “hardware” name that the ARC
component found for the device or that the x86-based OS loader created for the
device, which the system translates into a Unicode string when this name is
written into the registry.
<P>
<LI>
<B>IoQueryDeviceConfigurationData</B>&nbsp;points to any bus-relative hardware
configuration information that the ARC or NtDetect component found about the
driver’s device.
<P>
<LI>
<B>IoQueryDeviceComponentInformation</B>&nbsp;points to any information that the
ARC or NtDetect component found about a device’s subcomponents.
</UL>
<P>
As shown in Figure 16.7, NT device drivers usually get information from the
registry of type CM_FULL_RESOURCE_DESCRIPTOR, for which they use the <B>ControllerInformation[IoQueryDeviceConfigurationData]</B>
and/or <B>PeripheralInformation[IoQueryDeviceConfigurationData]</B>&nbsp;pointers.
<H5>Processing Configuration Information in ConfigCallback</H5>
<P>
As Figure 16.7 also shows, the <B>IoQueryDevice</B><I>Xxx</I>&nbsp;pointers are
valid only within the ConfigCallback routine. Moreover, NT drivers can read
the value entries of subkeys under the key <B>\Registry\Machine\Hardware\Description</B>
but cannot modify them. It is a ConfigCallback routine’s responsibility to
copy pertinent system-supplied data it finds to a driver-allocated buffer (or
driver-structured area on the stack) so the DriverEntry routine can use and,
if necessary, supplement this information when the ConfigCallback routine
returns control.
<P>
The CM_FULL_RESOURCE_DESCRIPTOR-type information shown in <A HREF="#DDK_Figure_16..7_NG">Figure
16.7</A>&nbsp;includes all controller- or peripheral-specific information that can be
detected about one or more of the following:
<UL>
<LI>
An inclusive, but bus-relative, range of physical <B>Port</B>&nbsp;addresses
<P>
The DriverEntry (or ConfigCallback) routine calls <B>HalTranslateBusAddress</B>
to get a mapped system value that the driver uses (or remaps by calling <B>MmMapIoSpace</B>
if <B>HalTranslateBusAddress</B>&nbsp;indicates that the <B>Port</B>&nbsp;range is in
memory, rather than I/O space) to access its device ports thereafter.
<P>
<LI>
An inclusive range of physical <B>Memory</B>&nbsp;addresses used by the device
<P>
The DriverEntry (or ConfigCallback) routine calls <B>HalTranslateBusAddress</B>
to get a mapped range, which it passes to <B>MmMapIoSpace</B>&nbsp;to get a
remapped system range that the driver uses to access its device-dedicated
memory thereafter.
<P>
<LI>
The bus-relative <B>Interrupt</B>&nbsp;vector for its device and the IRQL for that
vector
<P>
The DriverEntry or ConfigCallback routine calls <B>HalGetInterruptVector</B>
to get a mapped system vector, DIRQL, and processor affinity mask that the
DriverEntry routine can pass to <B>IoConnectInterrupt</B>&nbsp;when it registers
the driver’s ISR.
<P>
<LI>
The bus-relative physical <B>Dma</B>&nbsp;channel or port (on <B>MicroChannel</B>-type
buses) to which its device is connected
<P>
The DriverEntry or ConfigCallback routine fills in a DEVICE_DESCRIPTION
structure using this information, and calls <B>HalGetAdapter</B>&nbsp;so its device
can do DMA transfer operations thereafter. For more information about devices
that use DMA, see the section on adapter objects in Chapter 3.
</UL>
<P>
Note that it is possible for a ConfigCallback routine to call <B>HalTranslateBusAddress</B>,
<B>HalGetInterruptVector</B>, or <B>HalGetAdapter</B>, as long as it passes
the values returned by these HAL routines to the DriverEntry routine. Note
also that an NT device driver is required to call <B>IoReportResourceUsage</B>
with the same values returned by <B>IoGetDeviceDescription</B>&nbsp;before it
accesses the device, as explained in <A HREF="16issues_36.htm">Section
16.8.3</A>, so a ConfigCallback routine must not return control before it saves
the information, if any, that it obtained from the registry for the
DriverEntry routine.
<P>
The <B>DeviceSpecificData</B>, shown in <A HREF="#DDK_Figure_16..7_NG">Figure
16.7</A>&nbsp;at the tail of each partial resource descriptor in a partial resource
list, is generally a device-type-specific structure. The system defines <B>DeviceSpecificData</B>
structures for many kinds of peripheral devices. See <I>ntddk.h</I>&nbsp;for
details.
<H5>On Return from ConfigCallback</H5>
<P>
Depending on the platform and/or type of bus, an NT driver might get only some
of the machine-specific hardware information that it needs by calling <B>IoQueryDeviceDescription</B>.
Depending on the device, some NT drivers also interrogate their devices to
supplement system-supplied hardware configuration information.
<P>
While it supplies as much hardware configuration information as possible to
each device driver, the system also requires each device driver to supply
hardware configuration information about itself (and/or each of its devices)
in the registry, as one of the following:
<UL>
<LI>
A CM_RESOURCE_LIST, containing one or more CM_RESOURCE_DESCRIPTORs, which can
include <B>DeviceSpecificData</B>&nbsp;entries, that <B>IoReportResourceUsage</B>
successfully claimed in the registry for the caller
<P>
<LI>
An IO_RESOURCE_REQUIREMENTS_LIST of preferred and alternative (or fixed)
hardware resources, from which <B>IoAssignResources</B>&nbsp;returns a
CM_RESOURCE_LIST describing those it claimed in the registry for the caller
<P>
<LI>
A pointer to a variable, at which <B>HalAssignSlotResources</B>&nbsp;returns the
address of a buffered CM_RESOURCE_LIST, describing the hardware resources it
claimed in the registry for a device on a dynamically configurable I/O bus
with a published standard interface, such as PCI
</UL>
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; NT device driver writers should consider the following an implementation guideline: </H5>
<P>
Every NT device driver must claim all the hardware resources in the machine
that the driver and its device(s) need to carry out I/O operations <I>before</I>
the driver actually initializes its device(s).
<P>
For more information about claiming these resources in the registry, see <A HREF="16issues_36.htm">Section
16.8.3</A>.
<P></FONT>
</BODY>
</HTML>
