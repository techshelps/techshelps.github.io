<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.6.1  Registering and Queueing a DpcForIsr Routine</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Registering_and_Queueing_a_DpcForIsr_Routine_KG"></A>3.6.1  Registering and Queueing a DpcForIsr Routine</H3>
<P>
<A NAME="DDK_Figure_3.17_KG"></A>An NT device driver can register its DpcForIsr by
calling <B>IoInitializeDpcRequest</B>&nbsp;when the driver initializes. After the
driver is loaded and handling interrupt-driven I/O requests, the ISR calls <B>IoRequestDpc</B>
just before it returns control to have the DpcForIsr routine queued for
execution. Figure 3.17 illustrates calls to these routines.
<P>
<B><IMG SRC="../art/3dpcisr.gif" BORDER=0></B>
<P>
<B>Figure 3.17    Using a DPC Object for a DpcForIsr Routine</B>
<P>
As Figure 3.17 shows, calling <B>IoInitializeDpcRequest</B>&nbsp;associates a
Kernel DPC object with a driver-supplied DpcForIsr routine and a
driver-created device object. The I/O Manager allocates memory for the DPC
object and calls <B>KeInitializeDpc</B>&nbsp;on the driver’s behalf.
<P>
When the ISR is called to handle a device interrupt at DIRQL, it should return
control to the system as soon as possible for better overall system and driver
performance. Usually, an ISR merely stops the device from generating more
interrupts, gathers whatever context information the DpcForIsr routine needs
to complete the operation that caused the interrupt, calls <B>IoRequestDpc</B>,
and returns.
<P>
As Figure 3.17 shows, the ISR passes a pointer to the device object,
representing the target device for which the operation was carried out, a
pointer to the <I>DeviceObject</I><B>-&gt;CurrentIrp</B>, and a pointer to a
driver-determined Context for the operation to <B>IoRequestDpc</B>. The I/O
Manager calls <B>KeInsertQueueDpc</B>&nbsp;on the driver’s behalf, and the
corresponding DPC object is queued until IRQL falls below DISPATCH_LEVEL on a
processor. Then, the Kernel dequeues the DPC object and the driver’s DpcForIsr
is run on the processor at IRQL DISPATCH_LEVEL.
<P>
On entry, the DpcForIsr is given a pointer to the DPC object and the <I>DeviceObjec</I>t,
current <I>Irp</I>, and <I>Context</I>&nbsp;pointers passed in the ISR’s call to <B>IoRequestDpc</B>.
The <I>Context</I>-accessible area must be in resident memory. Unless the
driver overlaps I/O for the target device, such a context area is usually in
the <I>DeviceObject</I>-&gt;<B>DeviceExtension</B>, but it can be in a
controller extension if the driver uses a controller object (see <A HREF="03ntobj_20.htm">Section
3.4</A>) or in nonpaged pool allocated by the driver. The DpcForIsr is responsible
for doing whatever is necessary to complete the I/O requested in the current
IRP.
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; The ISR and DpcForIsr can be run concurrently in symmetric multiprocessor machines, so NT device driver writers should follow these guidelines: </H5>
<UL>
<LI>
The ISR must call <B>IoRequestDpc</B>&nbsp;just before it returns control.
Otherwise, the DpcForIsr might be run on another processor before the ISR has
finished setting up the <I>Context</I>-accessible area for the DpcForIsr.
<P>
<LI>
The ISR could be called again if the device interrupts while or before the
DpcForIsr is run. When a driver uses the device extension (see <A HREF="03ntobj_2.htm">Section
3.2</A>) to maintain context about its device I/O operations, the DpcForIsr should
<I>never</I>&nbsp;call <B>IoStartNextPacket</B>&nbsp;for the input <I>DeviceObject</I>
(nor dequeue an IRP for the input <I>DeviceObject</I>, if the driver manages
its own IRP queueing) until just before it calls <B>IoCompleteRequest</B>&nbsp;with
the current <I>Irp</I>. Otherwise, the driver’s StartIo or queue-management
routine(s) might start a device I/O operation that overwrote the shared
context area before the DpcForIsr could complete the current operation.
<P>
<LI>
The DpcForIsr and any other driver routine that shares a context area with the
ISR must call <B>KeSynchronizeExecution</B>&nbsp;with a driver-supplied
SynchCritSection routine in order to access any context area shared with the
ISR in a multiprocessor-safe manner.
</UL>
<P>
Even in a uniprocessor machine, the ISR could be called again if the device
interrupts while or before the DpcForIsr is run. If this occurs, the DpcForIsr
routine is run only once. In other words, there is no one-to-one
correspondence between an ISR’s calls to <B>IoRequestDpc</B>&nbsp;and
instantiations of the DpcForIsr routine if an NT driver overlaps I/O
operations for its target device objects.
<P>
For more information about the functionality required of a DpcForIsr routine,
see Chapter 9.
<P></FONT>
</BODY>
</HTML>
