<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.2.4.2  Using Direct I/O</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H4><A NAME="DDK_Using_Direct_I_O_KG"></A>3.2.4.2  Using Direct I/O</H4>
<P>
<A NAME="DDK_Figure_3..4_KG"></A>Figure 3.4 illustrates how the I/O Manager sets
up an IRP, requesting a transfer operation, for drivers that OR their device
object(s)’<B>&nbsp;Flags</B>&nbsp;with DO_DIRECT_IO.
<P>
<B><IMG SRC="../art/3mdldrct.gif" BORDER=0></B>
<P>
<B>Figure 3.4    Direct I/O on User Buffers</B>
<P>
As Figure 3.4 shows, some range of user-space virtual addresses represents the
current thread’s buffer, and that buffer’s contents might actually be stored
on some number of physically discontiguous pages. An MDL is created to
describe this buffer. As already mentioned in <A HREF="03ntobj_1.htm">Section
3.1</A>, an MDL is an opaque Memory-Manager-defined data structure that maps a
particular virtual address range to one or more paged-based physical address
ranges.
<P>
Figure 3.4 also shows an overview of how drivers can use the IRP’s<B>
MdlAddress</B>&nbsp;to transfer data for a read request, when a driver has ORed the
device object’s <B>Flags</B>&nbsp;with DO_DIRECT_IO:
<OL>
<LI>
The I/O Manager services the current thread’s read request, for which the
thread passes a range of user-space virtual addresses representing a buffer.
<P>
<LI>
The I/O Manager or FSD checks the user-supplied buffer for accessibility and
calls <B>MmProbeAndLockPages</B>&nbsp;with an MDL, which specifies the range of
virtual addresses for the user buffer. <B>MmProbeAndLockPages</B>&nbsp;also fills
in the corresponding physical address range(s) in the MDL. As Figure 3.4
shows, an MDL for a virtual range can have several corresponding page-based
physical address entries, and the virtual range for a buffer might begin and
end at some byte offset from the start of the first and last pages described
by an MDL. Note that an MDL is opaque to drivers.
<P>
As Figure 3.4 also shows, the I/O Manager provides a pointer to this MDL (<B>MdlAddress</B>)
in an IRP that requests a transfer operation. Until the I/O Manager or file
system calls <B>MmUnlockPages</B>&nbsp;after the driver completes the IRP, the
physical pages described in the MDL remain locked down and assigned to the
buffer. However, the virtual addresses in such an MDL can become invisible
(and invalid), even before the IRP is sent to the device driver or to any
intermediate driver that might be layered above the device driver.
<P>
<LI>
If the device driver uses system or packet-based busmaster DMA, it calls <B>MmGetMdlVirtualAddress</B>
with the IRP’s <B>MdlAddress</B>&nbsp;pointer to get an index for the MDL’s
page-based entries. If the device uses PIO and the driver requires system
(virtual) addresses, the driver calls <B>MmGetSystemAddressForMdl</B>&nbsp;with the
IRP’s <B>MdlAddress</B>&nbsp;pointer to doubly map the user-space virtual addresses
in the MDL to a system-space address range (AliasBuff in <A HREF="#DDK_Figure_3..4_KG">Figure
3.4</A>).
<P>
<LI>
If the device driver uses system or packet-based busmaster DMA, it calls <B>IoMapTransfer</B>
with the index returned by <B>MmGetMdlVirtualAddress</B>&nbsp;in order to read data
from the device directly into physical memory when the driver’s AdapterControl
routine has access to a DMA channel and/or map registers. If the device uses
PIO, the driver uses the doubly mapped MDL’s system-space virtual address
range to read data into memory.
</OL>
<P>
When the driver completes the IRP by calling <B>IoCompleteRequest</B>, the I/O
Manager or file system releases the MDL’s doubly mapped system-space range if
the driver called <B>MmGetSystemAddressForMdl</B>. The I/O manager or file
system unlocks the pages described in the MDL, and disposes of the MDL and IRP
on the driver’s behalf. For better performance, NT drivers should avoid doubly
mapping MDL physical addresses to system space, as described in Step 3, unless
they must use virtual addresses. Releasing a doubly mapped system-space
address range causes every processor in the machine to have its data cache
flushed.
<P>
The current user thread’s buffer(s) and the thread itself are guaranteed to be
resident in physical memory only while that thread is current. For the thread
shown in <A HREF="#DDK_Figure_3..4_KG">Figure 3.4</A>, its user buffer’s contents
could be paged out to secondary storage while another process’s threads are
run. When another process’s thread is run, the system physical memory for the
requesting thread’s buffer can be overwritten unless the NT Memory Manager has
locked down and preserved the corresponding physical pages that contain the
original thread’s buffer.
<P>
However, the original thread’s virtual addresses for its buffer <I>do not
remain visible</I>&nbsp;while another thread is current, even if the Memory Manager
does preserve the buffer’s physical pages. Consequently, NT drivers cannot use
a virtual address returned by <B>MmGetMdlVirtualAddress</B>&nbsp;to access memory.
Callers of this routine must pass its results to <B>IoMapTransfer</B>&nbsp;(along
with the IRP’s <B>MdlAddress</B>&nbsp;pointer) in order to transfer data using
system or packet-based DMA.
<P>
NT drivers that use DMA also must use an adapter object, described later in <A HREF="03ntobj_10.htm">Section
3.3</A>. For more information on maintaining cache coherency during DMA and PIO
transfers, see also Chapter 16.
<P></FONT>
</BODY>
</HTML>
