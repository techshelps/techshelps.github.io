<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>10.2.1  Programming the Device for an I/O Operation</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Programming_the_Device_for_an_I_O_Operation_KG"></A>10.2.1  Programming the Device for an I/O Operation</H3>
<P>
For any incoming IRP, NT device drivers do as much I/O processing as possible
at IRQL PASSIVE_LEVEL in their Dispatch routines (or, possibly driver threads)
or at IRQL DISPATCH_LEVEL, as in their StartIo routines, before they program
their devices for an I/O operation.
<P>
In addition, a device driver’s StartIo routine must postpone its call to <B>KeSynchronizeExecution</B>
with a SynchCritSection routine that programs the device to the following
standard driver routines:
<UL>
<LI>
If an NT driver sets up a controller object to represent a device controller
with attached devices, its StartIo routine cannot program the device
controller, which might already be in use for an I/O operation on another
attached device, until the physical controller is not busy.
<P>
<OL>
<LI>
Such a driver’s StartIo routine must call <B>IoAllocateController</B>&nbsp;with its
ControllerControl routine to synchronize operations through the physical
controller.
<P>
<LI>
Only then can its ControllerControl routine call <B>KeSynchronizeExecution</B>
with a SynchCritSection routine that programs the physical controller for the
requested operation to/from the target device.
</OL>
<P>
If a transfer operation through such a driver’s controller does not fully
satisfy a particular IRP, the driver’s DpcForIsr routine also must call <B>KeSynchronizeExecution</B>
with the same SynchCritSection routine to reprogram the physical controller
for each additional transfer necessary to satisfy the current IRP.
<P>
For more information about controller objects, see Chapter 3. For more
information about ControllerControl routines, see also Chapter 11.
<P>
<LI>
If an NT driver sets up an adapter object for system or packet-based busmaster
DMA, its StartIo routine (or possibly, driver-created thread or
ControllerControl routine) cannot program a slave device until the system DMA
controller, which might be busy transferring data for another slave device, is
available or until the system has allocated the DMA map registers for such a
driver’s busmaster adapter.
<P>
<OL>
<LI>
Such a driver’s StartIo routine must call <B>IoAllocateAdapterChannel</B>&nbsp;with
its AdapterControl routine in order to synchronize operations through the
system DMA controller or the driver’s busmaster DMA adapter.
<P>
<LI>
Only then can its AdapterControl routine call <B>KeSynchronizeExecution</B>
with a SynchCritSection routine that programs the driver’s device for a DMA
transfer.
</OL>
<P>
If a DMA transfer operation on such a driver’s device/adapter does not fully
satisfy a particular IRP, the driver’s DpcForIsr routine also must call <B>KeSynchronizeExecution</B>
with the same SynchCritSection routine to reprogram the device/adapter for
each additional DMA transfer necessary to satisfy the current IRP.
<P>
For more information about adapter objects and how to stage DMA processing,
see Chapter 3. For more information about AdapterControl routines, see also
Chapter 11.
<P>
<B><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; </B>NT device driver writers
should consider the following general guidelines for designing, implementing,
and calling SynchCritSection routines that program the device for I/O
operations<B>&nbsp;</B>
<P>
<LI>
A device driver should do all preprocessing for an IRP, set up any necessary
state for other driver routines that also process device I/O requests, and
acquire all necessary resources, such as a access to a device controller,
system DMA channel, or set of DMA map registers, before it calls <B>KeSynchronizeExecution</B>
to have a driver-supplied SynchCritSection routine program the device for an
I/O operation.
<P>
<LI>
A SynchCritSection routine that programs the device for I/O operations must
return control as quickly as possible. For this reason, such a
SynchCritSection routine should do only what is necessary to set up the device
for I/O.
<P>
<LI>
A device driver can have a set of SynchCritSection routines to program the
device, if necessary. That is, the driver of a device for which setting up a
read request differs markedly from setting up certain device control requests
might have separate SynchCritSection routines to program its device for each
type of request.
<P>
<LI>
An NT device driver should not have a single, large, general-purpose
SynchCritSection routine with a <B>switch</B>&nbsp;statement or many nested <B>if..then..else</B>
statements to determine what operations it will carry out to program the
device for an I/O operation and/or what state information to update. On the
other hand, a driver also should avoid having a set of many SynchCritSection
routines, each responsible for programming only a single device register.
</UL>
<P>
Every SynchCritSection routine must return control as quickly as possible,
because running any SynchCritSection routine prevents the driver’s ISR from
getting any work done if it is running concurrently.
<P></FONT>
</BODY>
</HTML>
