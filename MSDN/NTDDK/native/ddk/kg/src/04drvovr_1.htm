<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>4.1  Standard NT Driver Routines</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="DDK_Standard_NT_Driver_Routines_KG"></A>4.1  Standard NT Driver Routines</H2>
<P>
All NT driver writers must implement certain system-defined standard routines
and can implement others, along with any internal routines that the driver
designer chooses, as mentioned in Chapter 2. 
<P>
Figure 4.1 shows the NT driver object, representing a driver’s load image, and
the set of standard routines for NT drivers. 
<P>
<B><IMG SRC="../art/24drvobj.gif" BORDER=0></B>
<P>
<B>Figure 4.1    Standard NT Driver Routines</B>
<P>
As Figure 4.1 shows, all NT drivers must have a basic set of standard routines
in order to process IRPs. Otherwise, the set of standard routines that can or
must be implemented depends on whether the driver controls a physical device
or is layered over such a device driver, as well as on the nature of the
underlying physical device. 
<P>
Every NT driver must have the following types of routines, which are defined
by the NT I/O Manager:
<H4>DriverEntry</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; NTSTATUS 
&nbsp; &nbsp; (*PDRIVER_INITIALIZE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDRIVER_OBJECT DriverObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PUNICODE_STRING RegistryPath 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Every NT driver must have an initialization routine, which the I/O Manager
calls automatically if this routine is explicitly named <B>DriverEntry</B>.
For more information about a DriverEntry routine’s functional requirements,
see Chapter 5. 
</DL>
<H4>Dispatch</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; NTSTATUS 
&nbsp; &nbsp; (*PDRIVER_DISPATCH) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDEVICE_OBJECT DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PIRP Irp 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Every NT driver must have at least one Dispatch routine, but any driver can
have a separate Dispatch routine for each IRP major function code (IRP_MJ<I>_XXX</I>)
it handles. For more information about Dispatch routines’ functional
requirements, see Chapter 6. For device-type-specific information about which
major function codes NT drivers must handle, see the <I>Kernel-mode Driver
Reference</I>. 
</DL>
<H4>StartIo (or Queue-management)</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PDRIVER_STARTIO) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDEVICE_OBJECT DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PIRP Irp 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
If an NT device driver cannot complete all possible I/O requests in its
Dispatch routines, it either must have a StartIo routine or must set up one or
more driver-created internal queues and manage its own queueing of IRPs. A
higher-level NT driver might have a StartIo routine, and it can have
driver-created internal queues of IRPs. For more information about the StartIo
routine’s functional requirements and about managing queues of IRPs, see
Chapter 7. 
</DL>
<P>
Depending on an NT driver’s level in a chain of layered drivers, if any, and
on the nature of the underlying physical device, an NT driver can (or must)
have the following types of routines, which are defined by the NT I/O Manager
or Kernel: 
<H4>Reinitialize</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PDRIVER_REINITIALIZE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDRIVER_OBJECT DriverObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID Context, 
&nbsp; &nbsp; &nbsp; &nbsp; IN ULONG Count 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
In addition to its DriverEntry routine, an NT driver can have a Reinitialize
routine to be called one or more times later in the system boot process after
its DriverEntry routine returns control. For more information about an
optional Reinitialize routine’s functionality, see Chapter 5. 
</DL>
<H4>InterruptService (ISR)</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; BOOLEAN 
&nbsp; &nbsp; (*PKSERVICE_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PKINTERRUPT Interrupt, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID ServiceContext // usually points to device object 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Any driver of a physical device that generates interrupts must have an ISR.
Such a driver is always the lowest-level driver in any chain of layered NT
drivers. For more information about an ISR’s functional requirements, see
Chapter 8. 
</DL>
<H4>DpcForIsr or CustomDpc</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PIO_DPC_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PKDPC Dpc, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDEVICE_OBJECT DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PIRP Irp, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID Context 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;
&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PKDEFERRED_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PKDPC Dpc, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID DeferredContext, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID SystemArgument1, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID SystemArgument2 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Any driver that has an ISR must have a DpcForIsr or CustomDpc routine, and can
have additional CustomDpc routines. For more information about the DpcForIsr
routine’s functional requirements and about CustomDpc routines, see Chapter 9.
</DL>
<H4>SynchCritSection</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; BOOLEAN 
&nbsp; &nbsp; (*PKSYNCHRONIZE_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID SynchronizeContext 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Any lowest-level device driver with data or device registers shared between
its ISR and other driver routines must have one or more SynchCritSection
routines. For more information about a SynchCritSection routine’s functional
requirements, see Chapter 10. 
</DL>
<H4>AdapterControl and/or ControllerControl</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; IO_ALLOCATION_ACTION 
&nbsp; &nbsp; (*PDRIVER_CONTROL) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDEVICE_OBJECT DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PIRP Irp, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID MapRegisterBase, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID Context 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Any driver of a device that uses system DMA or packet-based busmaster DMA must
have an AdapterControl routine. Any device driver that must synchronize
operations through a physical controller to similar devices (or device
channels) can have a ControllerControl routine. For more information about
these routines’ functional requirements, see Chapter 11. 
</DL>
<H4>Cancel</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PDRIVER_CANCEL) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDEVICE_OBJECT DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PIRP Irp 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Keyboard, mouse, serial, parallel, and sound device drivers, as well as file
system drivers, have Cancel routines. Any driver in which IRPs might remain
queued for an indefinite interval (so that a user could cause a previously
submitted I/O request to be cancelled) must have one or more Cancel routines.
Usually, the highest NT driver in a chain has a Cancel routine. For more
information about a Cancel routine’s functional requirements, see Chapter 12. 
</DL>
<H4>IoCompletion</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; NTSTATUS 
&nbsp; &nbsp; (*PIO_COMPLETION_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDEVICE_OBJECT DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PIRP Irp, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID Context 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
Any higher-level NT driver that allocates IRPs to send to lower drivers must
have at least one IoCompletion routine to free all IRPs that the driver
allocates. However, any higher-level driver can have one or more IoCompletion
routines. Other driver routines can set up an IoCompletion routine to be
called when all lower-level drivers have finished processing a given IRP. For
a general discussion of how higher-level drivers can use IoCompletion
routines, see Chapter 2. See also <A HREF="04drvovr_3.htm">Section
4.3</A>&nbsp;for an overview of how a representative NT intermediate driver’s
IoCompletion routine processes IRPs. For more information about an
IoCompletion routine’s functional requirements, see Chapter 13. 
</DL>
<H4>IoTimer and/or CustomTimerDpc</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PIO_TIMER_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDEVICE_OBJECT DeviceObject, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID Context 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;
&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PKDEFERRED_ROUTINE) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PKDPC Dpc, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID DeferredContext, 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID SystemArgument1,        // reserved for system use 
&nbsp; &nbsp; &nbsp; &nbsp; IN PVOID SystemArgument2            // reserved for system use 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
To monitor whether an I/O operation has timed out or for some other purpose
determined by the driver designer, any driver can have IoTimer and/or
CustomTimerDpc routines. An IoTimer routine is called once per second when the
driver has enabled the timer. A CustomTimerDpc routine can be called at
finer-grained intervals or at variable intervals. For more information about
timer routines’ functional requirements, see Chapter 14. 
</DL>
<H4>Unload</H4>
<PRE><FONT FACE="Courier" SIZE="2">&nbsp; &nbsp; VOID 
&nbsp; &nbsp; (*PDRIVER_UNLOAD) ( 
&nbsp; &nbsp; &nbsp; &nbsp; IN PDRIVER_OBJECT DriverObject 
&nbsp; &nbsp; &nbsp; &nbsp; ); 
&nbsp;</FONT></PRE>
<DL>
<P>
An NT driver must have an Unload routine if it can be unloaded while the
system continues to run. For more information about an Unload routine’s
functional requirements, see Chapter 15. 
</DL>
<P>
As the preceding declarations for standard NT driver routines show, the
current IRP and target device object are input parameters to many standard
routines defined by the I/O Manager. Every NT driver processes each IRP in
stages through its set of standard routines. <A HREF="04drvovr_2.htm">Sections
4.2</A>&nbsp;and <A HREF="04drvovr_3.htm">4.3</A>
describe the general path for an IRP through a representative lowest-level
physical device driver and a representative intermediate driver, respectively.
<P></FONT>
</BODY>
</HTML>
