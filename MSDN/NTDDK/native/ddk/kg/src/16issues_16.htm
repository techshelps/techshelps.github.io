<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16.4.3  Using Zone Buffers</TITLE>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">

<FONT FACE="ARIAL,HELVETICA" SIZE="2">
<H3><A NAME="DDK_Using_Zone_Buffers_KG"></A>16.4.3  Using Zone Buffers</H3>
<P>
NT drivers that set up zone buffers for fast allocation of fixed-size blocks
(also called <I>entries</I>) should use that memory economically. 
<H5><IMG SRC="../../../wedge.gif" BORDER=0>&nbsp; &nbsp; NT driver writers who use the Ex..Zone routines should follow these design guidelines: </H5>
<UL>
<LI>
Set up a modestly sized zone buffer. That is, make the zone buffer large
enough for the driver to handle an average I/O demand for its device in a
typical Windows NT machine, rather than setting up a fixed-size zone buffer
large enough to handle a worst-case I/O-demand scenario on a high-end Windows
NT platform. 
<P>
When it initializes, the driver can call <B>MmQuerySystemSize</B>&nbsp;and <B>MmIsThisAnNtAsSystem</B>
to get an estimate for sizing a zone buffer. <B>MmQuerySystemSize</B>&nbsp;returns
a system-defined enumerated type, indicating whether the machine has a small,
medium, or large amount of available memory. <B>MmIsThisAnNtAsSystem</B>
returns TRUE if the current machine is a Windows NT server, which is likely
both to have more memory available and to require a larger zone buffer to
handle the I/O demand on the underlying driver(s)’ device(s). 
<P>
<LI>
If the driver allocates and frees zone buffer entries using the <B>ExInterlocked..Zone</B>
routines, it must provide storage for an excutive spin lock and initialize the
spin lock in its DriverEntry routine, as mentioned in <A HREF="16issues_2.htm">Section
16.2</A>. 
<P>
<LI>
The driver should <I>always</I>&nbsp;call <B>ExIsFullZone</B>&nbsp;immediately preceding
a call to <B>ExInterlockedAllocateFromZone</B>. Otherwise, the driver might
tie up a processor for an extended interval by trying to acquire the spin lock
that protects a zone with no free blocks. 
<P>
<LI>
If the driver’s call to <B>ExAllocateFromZone</B>&nbsp;returns a NULL pointer or
its call to <B>ExIsFullZone</B>&nbsp;returns TRUE, the driver should call <B>ExAllocatePool</B>
or <B>ExAllocatePoolWithTag</B>&nbsp;to obtain additional memory to use as zone
entries. The driver can use this memory temporarily until some zone entries
have been released by calls to <B>ExFreeToZone</B>&nbsp;or <B>ExInterlockedFreeToZone</B>.
Then, the driver can call <B>ExFreePool</B>&nbsp;to release its temporary pool
allocation since its zone buffer has free blocks again. 
<P>
<LI>
The driver <I>should not</I>&nbsp;call <B>ExExtendZone</B>&nbsp;or <B>ExInterlockedExtendZone</B>,
except possibly under the following circumstances: 
<P>
<UL>
<LI>
Its originally allocated zone buffer has no free blocks. 
<P>
<LI>
It has already called <B>ExAllocatePool</B>&nbsp;or <B>ExAllocatePoolWithTag</B>
more than once, but the driver is still using all the additional memory it has
allocated from pool for zone entries. 
</UL>
<P>
Such a condition indicates a very heavy I/O demand for the driver’s device, so
extending its zone buffer might be worthwhile. That is, the performance gain
from allocating additional zone blocks might allow the driver to process
requests fast enough to compensate for its additional “permanent” demand on
nonpaged pool, especially if extending the zone allows the driver to release
some of the temporary memory it allocated with <B>ExAllocatePool</B>&nbsp;or <B>ExAllocatePoolWithTag</B>.
</UL>
<P>
Note that an NT driver’s successful call to <B>ExExtendZone</B>&nbsp;or <B>ExInterlockedExtendZone
</B>allocates nonpaged pool that remains allocated to the driver until the
system is rebooted. Consequently, any NT driver that calls <B>ExExtendZone</B>
or <B>ExInterlockedExtendZone</B>&nbsp;whenever its zone buffer becomes full (that
is, all entries are currently allocated), can eventually run out of nonpaged
pool. Such a driver also can put the system into a low-memory state such that
all I/O throughput becomes very slow, including the “memory-hogging” driver’s.
<P>
For routine-specific information about the <B>Ex..Zone</B>&nbsp;routines, see the <I>Kernel-Mode
Driver Reference</I>. 
<P></FONT>
</BODY>
</HTML>
