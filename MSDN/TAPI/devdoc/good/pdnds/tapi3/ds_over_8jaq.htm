<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Silence Suppression Filter</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_tapi3_silence_suppression_filter"></a>Silence Suppression Filter</h3>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
This filter is used to detect when silence is being captured by the audio capture filter. When detected, this filter pauses a graph. This allows the SPH filter to be able to properly indicate talk spurts when packetizing audio samples.</p>
<p>
The filter will accept PCM audio at any sampling frequency, with either 8 or 16 bits per sample. Although the filter will accept stereo data, it is implemented such that it would only consider the left channel for silence detection. The filter also needs to signal downstream filters of the beginning of a talk spurt so that they can set bits in the RTP header correctly.</p>
<p>
The filter determines the peak and average over the sample buffers passed to it. Then, based on the <i>EnergyFunction</i> property, it will test one of these values against the <i>EchoThreshold</i> plus a "running average" to determine if it is silent. If the buffer energy is greater than this sum for <i>RunningAverageTime</i> then the running average is increased by <i>AverageIncrementor</i>. If the buffer energy falls below the running average (without adding the <i>EchoThreshold</i>), the running average is set to the energy of that buffer. In this way the filter will gradually adapt to background noise.</p>
<p>
To prevent clipping, the filter will play a user-defined number of samples before and after the nonsilent data. That is, if the filter has been processing silent buffers and a nonsilent buffer is detected, the filter will deliver buffers processed prior to delivering the nonsilent buffer totaling an elapsed time of <i>PreplayBufferTime</i> . If the filter has been processing nonsilent buffers and it detects a silent buffer, it will deliver a silence of length <i>PostplayBufferTime</i> before it stops delivering silent buffers.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
