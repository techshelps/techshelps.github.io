<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CardMapWindow</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<h2><a name="_wceddk_cardmapwindow"></a>CardMapWindow</h2>
<p>
The <b>CardMapWindow</b> function maps an area in PC Card memory or I/O space to system memory, and returns a pointer used to access the mapped region. Accessing a PC Card through a mapped memory window is faster than accessing the card through other PC Card Services functions; since the access is direct there is no time taken by an additional function call.</p>
<h4>Syntax</h4>
<p>
<b>PVOID CardMapWindow( </b>    <b>CARD_WINDOW_HANDLE</b> <i>hCardWindow </i>    <b>UINT32 </b><i>uCardAddress </i>    <b>UINT32 </b><i>uSize </i>   <b> PUINT32</b> <i>pGranularity </i><b>    );</b></p>
<h4>Parameters</h4>
<dl>
<dt>
<i>hCardWindow</i></dt>
<dd>
Specifies a handle to a memory window returned by a call to <a href="ddkref_70.htm"><b>CardRequestWindow</b></a>.</dd>
<dt>
<i>uCardAddress</i></dt>
<dd>
Specifies a PC Card offset address.</dd>
<dt>
<i>uSize</i></dt>
<dd>
Specifies the number of bytes to map.</dd>
<dt>
<i>pGranularity</i></dt>
<dd>
Pointer to memory granularity of the mapped region. If the granularity is not one, then contiguous bytes on the PC Card cannot be accessed by contiguous memory addresses. If, for example, the granularity is four, then the bytes in the PC Card's memory is accessed as follows, where byte_number is the byte you wish to access:
<pre><code>pMemoryPointer[byte_number * pGranularity]
</code></pre>
</dd>
</dl>
<h4>Return Values</h4>
<p>
If successful, <b>CardMapWindow</b> returns a <b>PVOID</b> pointer mapped to the requested region; otherwise the return value is NULL. If the return value is NULL, <b>GetLastError</b> returns one of the following values.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=37%>Value</th>
<th align=left width=63%>Description</th>
</tr>
<tr valign=top>
<td width=37%>CERR_BAD_ARGS</td>
<td width=63%>Indicates an invalid <i>uCardAddress</i> specification or <i>pGranularity</i> pointer.</td>
</tr>
<tr valign=top>
<td width=37%>CERR_BAD_HANDLE</td>
<td width=63%>Indicates an invalid <i>hCardWindow</i> driver handle.</td>
</tr>
<tr valign=top>
<td width=37%>CERR_BAD_SIZE</td>
<td width=63%>Indicates the value specified for <i>uSize</i> is invalid.</td>
</tr>
<tr valign=top>
<td width=37%>CERR_OUT_OF_RESOURCE</td>
<td width=63%>Indicates Card Services is unable to set up a memory window to read the CIS.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
If this function fails, a previous mapping of the window might be invalid.</p>
<p>
The offset from the returned mapped virtual address must be multiplied by the value pointed to by <i>pGranularity</i>. </p>
<p>
The address returned by <b>CardMapWindow</b> can be used to directly access the PC Card. Drivers should access the memory in a try/except routine to avoid faulting the system on card removal.</p>
<p>
The returned pointer to the mapped PC Card memory is marked as non-cached shared memory. This guarantees that a PC Card device and its driver detect the same information when they access the same memory location. </p>
<p>
To provide reliable access to the mapped PC Card memory, driver code should declare the pointer to the PC Card memory with the <b>volatile</b> type qualifier.</p>
<p>
Most Windows CE plstforms uses three fixed memory mapped ranges to access the PC Card address spaces (attribute memory, I/O and common memory). The address returned from <b>CardMapWindow</b> is a virtual address mapped to the physical address that corresponds to the caller's request. Multiple drivers are prevented from allocating overlapping ranges within each address space, though multiple allocations are allowed within each space. A single driver is allowed to map a range that overlaps its own previously allocated ranges.</p>
<p>
On Windows CE platforms that support programmable windows via a standard PC Card socket controller, a combination of fixed memory mapped ranges and programmable ranges is used. If the requested range cannot be mapped within one of the fixed regions, then one of the programmable regions might be used.  To avoid memory contention, Windows CE ensures that only one mapped range exists within a programmable range. The programmable ranges are not large (about 32K), but they can access anywhere within the 64M PC Card address space.</p>
<h4>See Also</h4>
<p>
<a href="ddkref_84.htm"><b>CARD_WINDOW_HANDLE</b></a>, <a href="ddkref_70.htm"><b>CardRequestWindow</b></a></p>
<p>&nbsp;</p></body>
</HTML>
