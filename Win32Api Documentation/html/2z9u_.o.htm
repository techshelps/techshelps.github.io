<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>DCB</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="2z9u_.o"></A><B>DCB  <A HREF="amm36p.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="5jpun8.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="1ock5rm.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>DCB</B> structure defines the control setting for a serial communications device. </P>

<P>typedef struct _DCB { // dcb  </P>

<P>DWORD DCBlength;           // sizeof(DCB) </P>

<P>DWORD BaudRate;            // current baud rate </P>

<P>DWORD fBinary: 1;          // binary mode, no EOF check </P>

<P>DWORD fParity: 1;          // enable parity checking </P>

<P>DWORD fOutxCtsFlow:1;      // CTS output flow control </P>

<P>DWORD fOutxDsrFlow:1;      // DSR output flow control </P>

<P>DWORD fDtrControl:2;       // DTR flow control type </P>

<P>DWORD fDsrSensitivity:1;   // DSR sensitivity </P>

<P>DWORD fTXContinueOnXoff:1; // XOFF continues Tx </P>

<P>DWORD fOutX: 1;            // XON/XOFF out flow control </P>

<P>DWORD fInX: 1;             // XON/XOFF in flow control </P>

<P>DWORD fErrorChar: 1;       // enable error replacement </P>

<P>DWORD fNull: 1;            // enable null stripping </P>

<P>DWORD fRtsControl:2;       // RTS flow control </P>

<P>DWORD fAbortOnError:1;     // abort reads/writes on error </P>

<P>DWORD fDummy2:17;          // reserved </P>

<P>WORD wReserved;            // not currently used </P>

<P>WORD XonLim;               // transmit XON threshold </P>

<P>WORD XoffLim;              // transmit XOFF threshold </P>

<P>BYTE ByteSize;             // number of bits/byte, 4-8 </P>

<P>BYTE Parity;               // 0-4=no,odd,even,mark,space </P>

<P>BYTE StopBits;             // 0,1,2 = 1, 1.5, 2 </P>

<P>char XonChar;              // Tx and Rx XON character </P>

<P>char XoffChar;             // Tx and Rx XOFF character </P>

<P>char ErrorChar;            // error replacement character </P>

<P>char EofChar;              // end of input character </P>

<P>char EvtChar;              // received event character </P>

<P>WORD wReserved1;           // reserved; do not use </P>

<P>} DCB; </P>

<P></P>

<P><B>Members</B></P>

<P><B>DCBlength</B></P>

<P>Specifies the length, in bytes, of the <B>DCB</B> structure. </P>

<P><B>BaudRate</B></P>

<P>Specifies the baud rate at which the communications device operates. This member can be an actual baud rate value, or one of the following baud rate indexes:</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=29%>CBR_110 </TD>
<TD width=71%>CBR_19200</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>CBR_300 </TD>
<TD width=71%>CBR_38400</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>CBR_600 </TD>
<TD width=71%>CBR_56000</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>CBR_1200</TD>
<TD width=71%>CBR_57600</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>CBR_2400</TD>
<TD width=71%>CBR_115200</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>CBR_4800</TD>
<TD width=71%>CBR_128000</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>CBR_9600</TD>
<TD width=71%>CBR_256000</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>CBR_14400</TD>
<TD width=71%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>fBinary</B></P>

<P>Specifies whether binary mode is enabled. The Win32 API does not support nonbinary mode transfers, so this member should be TRUE. Trying to use FALSE will not work. </P>

<P>Under Windows 3.1, if this member is FALSE, nonbinary mode is enabled, and the character specified by the <B>EofChar</B> member is recognized on input and remembered as the end of data. </P>

<P><B>fParity</B></P>

<P>Specifies whether parity checking is enabled. If this member is TRUE, parity checking is performed and errors are reported. </P>

<P><B>fOutxCtsFlow</B></P>

<P>Specifies whether the CTS (clear-to-send) signal is monitored for output flow control. If this member is TRUE and CTS is turned off, output is suspended until CTS is sent again. </P>

<P><B>fOutxDsrFlow</B></P>

<P>Specifies whether the DSR (data-set-ready) signal is monitored for output flow control. If this member is TRUE and DSR is turned off, output is suspended until DSR is sent again. </P>

<P><B>fDtrControl</B></P>

<P>Specifies the DTR (data-terminal-ready) flow control. This member can be one of the following values: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=50%><B>Value</B></TD>
<TD width=50%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=50%>DTR_CONTROL_DISABLE</TD>
<TD width=50%>Disables the DTR line when the device is opened and leaves it disabled.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>DTR_CONTROL_ENABLE</TD>
<TD width=50%>Enables the DTR line when the device is opened and leaves it on.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>DTR_CONTROL_HANDSHAKE</TD>
<TD width=50%>Enables DTR handshaking. If handshaking is enabled, it is an error for the application to adjust the line by using the <A HREF="2mlddxo.htm"><B>EscapeCommFunction</B></A> function.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>fDsrSensitivity</B></P>

<P>Specifies whether the communications driver is sensitive to the state of the DSR signal. If this member is TRUE, the driver ignores any bytes received, unless the DSR modem input line is high. </P>

<P><B>fTXContinueOnXoff</B></P>

<P>Specifies whether transmission stops when the input buffer is full and the driver has transmitted the <B>XoffChar</B> character. If this member is TRUE, transmission continues after the input buffer has come within <B>XoffLim</B> bytes of being full and the driver has transmitted the <B>XoffChar</B> character to stop receiving bytes. If this member is FALSE, transmission does not continue until the input buffer is within <B>XonLim</B> bytes of being empty and the driver has transmitted the <B>XonChar</B> character to resume reception. </P>

<P><B>fOutX</B></P>

<P>Specifies whether XON/XOFF flow control is used during transmission. If this member is TRUE, transmission stops when the <B>XoffChar</B> character is received and starts again when the <B>XonChar</B> character is received. </P>

<P><B>fInX</B></P>

<P>Specifies whether XON/XOFF flow control is used during reception. If this member is TRUE, the <B>XoffChar</B> character is sent when the input buffer comes within <B>XoffLim</B> bytes of being full, and the <B>XonChar</B> character is sent when the input buffer comes within <B>XonLim</B> bytes of being empty. </P>

<P><B>fErrorChar</B></P>

<P>Specifies whether bytes received with parity errors are replaced with the character specified by the <B>ErrorChar</B> member. If this member is TRUE and the <B>fParity</B> member is TRUE, replacement occurs. </P>

<P><B>fNull</B></P>

<P>Specifies whether null bytes are discarded. If this member is TRUE, null bytes are discarded when received. </P>

<P><B>fRtsControl</B></P>

<P>Specifies the RTS (request-to-send) flow control. If this value is zero, the default is RTS_CONTROL_HANDSHAKE. This member can be one of the following values: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=47%><B>Value</B></TD>
<TD width=53%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=47%>RTS_CONTROL_DISABLE</TD>
<TD width=53%>Disables the RTS line when the device is opened and leaves it disabled.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>RTS_CONTROL_ENABLE</TD>
<TD width=53%>Enables the RTS line when the device is opened and leaves it on.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>RTS_CONTROL_HANDSHAKE</TD>
<TD width=53%>Enables RTS handshaking. The driver raises the RTS line when the "type-ahead" (input) buffer is less than one-half full and lowers the RTS line when the buffer is more than three-quarters full. If handshaking is enabled, it is an error for the application to adjust the line by using the <B>EscapeCommFunction</B> function.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>RTS_CONTROL_TOGGLE</TD>
<TD width=53%>Specifies that the RTS line will be high if bytes are available for transmission. After all buffered bytes have been sent, the RTS line will be low.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>fAbortOnError</B></P>

<P>Specifies whether read and write operations are terminated if an error occurs. If this member is TRUE, the driver terminates all read and write operations with an error status if an error occurs. The driver will not accept any further communications operations until the application has acknowledged the error by calling the <A HREF="j1cecx.htm"><B>ClearCommError</B></A> function. </P>

<P><B>fDummy2</B></P>

<P>Reserved; do not use. </P>

<P><B>wReserved</B></P>

<P>Not used; must be set to zero. </P>

<P><B>XonLim</B></P>

<P>Specifies the minimum number of bytes allowed in the input buffer before the XON character is sent. </P>

<P><B>XoffLim</B></P>

<P>Specifies the maximum number of bytes allowed in the input buffer before the XOFF character is sent. The maximum number of bytes allowed is calculated by subtracting this value from the size, in bytes, of the input buffer. </P>

<P><B>ByteSize</B></P>

<P>Specifies the number of bits in the bytes transmitted and received. </P>

<P><B>Parity</B></P>

<P>Specifies the parity scheme to be used. This member can be one of the following values: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=28%><B>Value</B></TD>
<TD width=72%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=28%>EVENPARITY</TD>
<TD width=72%>Even</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MARKPARITY</TD>
<TD width=72%>Mark</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>NOPARITY</TD>
<TD width=72%>No parity</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>ODDPARITY</TD>
<TD width=72%>Odd</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>StopBits</B></P>

<P>Specifies the number of stop bits to be used. This member can be one of the following values: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=29%><B>Value</B></TD>
<TD width=71%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=29%>ONESTOPBIT</TD>
<TD width=71%>1 stop bit</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>ONE5STOPBITS</TD>
<TD width=71%>1.5 stop bits</TD>
</TR>

<TR VALIGN="top">
<TD width=29%>TWOSTOPBITS</TD>
<TD width=71%>2 stop bits</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>XonChar</B></P>

<P>Specifies the value of the XON character for both transmission and reception. </P>

<P><B>XoffChar</B></P>

<P>Specifies the value of the XOFF character for both transmission and reception. </P>

<P><B>ErrorChar</B></P>

<P>Specifies the value of the character used to replace bytes received with a parity error. </P>

<P><B>EofChar</B></P>

<P>Specifies the value of the character used to signal the end of data. </P>

<P><B>EvtChar</B></P>

<P>Specifies the value of the character used to signal an event. </P>

<P><B>wReserved1</B></P>

<P>Reserved; do not use. </P>

<P></P>

<P><B>Remarks</B></P>

<P>When a <B>DCB</B> structure is used to configure the 8250, the following restrictions apply to the values specified for the <B>ByteSize</B> and <B>StopBits</B> members: </P>

<P>·The number of data bits must be 5 to 8 bits. </P>

<P>·The use of 5 data bits with 2 stop bits is an invalid combination, as is 6, 7, or 8 data bits with 1.5 stop bits. </P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="42awo3t.htm"><B>BuildCommDCB</B></A>, <A HREF="j1cecx.htm"><B>ClearCommError</B></A>, <A HREF="2mlddxo.htm"><B>EscapeCommFunction</B></A>, <A HREF="qhesgt.htm"><B>GetCommState</B></A>, <A HREF="2tsk0g9.htm"><B>SetCommState</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
