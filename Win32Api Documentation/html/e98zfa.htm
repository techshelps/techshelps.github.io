<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Guard Pages</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="e98zfa"></A><B>Guard Pages</B></P>

<P>An application establishes a <I>guard page</I> by setting a memory page's PAGE_GUARD page protection modifier flag. This flag can be specified, along with other page protection flags, in the functions <A HREF="1m7v8go.htm"><B>VirtualAlloc</B></A>, <A HREF="aruejx.htm"><B>VirtualProtect</B></A>, and <A HREF="sflvdy.htm"><B>VirtualProtectEx</B></A>. The PAGE_GUARD flag can be used with any other page protection flag, except for the NO_ACCESS flag. </P>

<P>If a program attempts to access an address within a guard page, the operating system raises a STATUS_GUARD_PAGE (0x80000001) exception. The operating system also clears the PAGE_GUARD flag, removing the memory page's guard page status. The system will not stop the next attempt to access the memory page with a STATUS_GUARD_PAGE exception.</P>

<P>If a guard page exception occurs during a system service, the service fails and typically returns some failure status indicator. Since the system also removes the relevant memory page's guard page status, the next invocation of the same system service won't fail due to a STATUS_GUARD_PAGE exception (unless, of course, someone reestablishes the guard page).</P>

<P>A guard page thus provides a one-shot alarm for memory page access. This can be useful for an application that needs to monitor the growth of large dynamic data structures. For example, there are operating systems that use guard pages to implement automatic stack checking.</P>

<P>The following short program illustrates the one-shot behavior of guard page protection, and how it can cause a system service to fail:</P>

<P>#include &lt;windows.h&gt;  </P>

<P>#include &lt;stdio.h&gt; </P>

<P>#include &lt;stdlib.h&gt; </P>

<P></P>

<P>int main() </P>

<P>{ </P>

<P></P>

<P>// local variables </P>

<P>LPVOID lpvAddr; </P>

<P>DWORD cbSize; </P>

<P>BOOL vLock; </P>

<P>LPVOID commit; </P>

<P></P>

<P>// amount of memory we'll allocate </P>

<P>cbSize = 512; </P>

<P></P>

<P>// try to allocate some memory </P>

<P>lpvAddr = VirtualAlloc(NULL,cbSize,MEM_RESERVE,PAGE_NOACCESS); </P>

<P></P>

<P>// if we failed ... </P>

<P>if(lpvAddr == NULL) </P>

<P>fprintf(stdout,"VirtualAlloc failed on RESERVE with %ld\n", </P>

<P>GetLastError()); </P>

<P></P>

<P>// try to commit the allocated memory </P>

<P>commit = VirtualAlloc(NULL,cbSize,MEM_COMMIT,PAGE_READONLY|PAGE_GUARD); </P>

<P></P>

<P>// if we failed ... </P>

<P>if(commit == NULL) </P>

<P>fprintf(stderr,"VirtualAlloc failed on COMMIT with %ld\n", </P>

<P>GetLastError()); </P>

<P></P>

<P>else  // we succeeded </P>

<P>fprintf(stderr,"Committed %lu bytes at address %lp\n", </P>

<P>cbSize,commit); </P>

<P></P>

<P>// try to lock the committed memory </P>

<P>vLock = VirtualLock(commit,cbSize); </P>

<P></P>

<P>// if we failed ... </P>

<P>if(!vLock) </P>

<P>fprintf(stderr,"Cannot lock at %lp, error = %lu\n", </P>

<P>commit,GetLastError()); </P>

<P>else  // we succeeded </P>

<P>fprintf(stderr,"Lock Achieved at %lp\n",commit); </P>

<P></P>

<P>// try to lock the committed memory again </P>

<P>vLock = VirtualLock(commit,cbSize); </P>

<P></P>

<P>// if we failed ... </P>

<P>if(!vLock) </P>

<P>fprintf(stderr,"Cannot get 2nd lock at %lp, error = %lu\n", </P>

<P>commit,GetLastError()); </P>

<P>else  // we succeeded </P>

<P>fprintf(stderr,"2nd Lock Achieved at %lp\n",commit); </P>

<P></P>

<P>} // endof function </P>

<P></P>

<P>The output of this program looks like this:</P>

<P>Committed 512 bytes at address 003F0000  </P>

<P>Cannot lock at 003F0000, error = 0x80000001 </P>

<P>2nd Lock Achieved at 003F0000 </P>

<P></P>

<P>Note that the first attempt to lock the memory block fails, raising a STATUS_GUARD_PAGE exception. The second attempt succeeds, because the memory block's guard page protection has been toggled off by the first attempt.</P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
