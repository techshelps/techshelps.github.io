<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Installing Handlers on Windows NT</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="og1e5n"></A><B>Installing Handlers on Windows NT</B></P>

<P>Because shell extensions handlers run in a system process, namely the shell process, Windows NT administrators require control over which shell handlers are allowed to run. Administrators will have control over which shell handlers can run in much the same way they can now control which device drivers can run.</P>

<P>For the Windows NT shell to recognize and run a shell-extension handler, you must follow the instructions in <A HREF="2_5k_9g.htm">Registering Shell Extensions</A>, then the handler's CLSID must also be listed under another new registry key. This registry key contains a list of the handlers that are approved for the shell to run. By default, this key's access control permissions allow only someone with administrator privileges to modify the list. </P>

<P>The CLSID for the extension must be registered at the following location:</P>

<P>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved</P>

<P></P>

<P>To register the extension, a "named value" should be added to the "Approved" key. The name of the value must be the string form of the CLSID as obtained from the StringFromCLSID() function, which is used elsewhere in the registry. The value itself should be the ProgID. The ProgID is stored here simply to make inspection of the registry easier, as it is easier to decipher than a CLSID. The Windows NT shell does not look at this value, however, only at the presence or absence of the CLSID.</P>

<P>Your setup application may or may not be able to write to this key, depending on the privileges of the person installing the application. The setup application should attempt to open the key described above, requesting the KEY_SET_VALUE permission. If it succeeds, the new CLSID can be added to fully register the corresponding shell extension. If the request fails with a security violation, then the person installing the application does not have permission to register new shell extensions. In this case, the setup application might warn the user that some application features will not be available unless an administrator turns them on (by installing the application, or by writing the registry keys directly). Or, if the shell extension is crucial to the application's functioning, the setup application might cause the installation to fail completely, notifying the user that the program must be installed by an administrator.</P>

<P>When setting up on Windows 95, it is not necessary to write the CLSID to this key, although writing it is harmless. Note, however, that the key may not exist in a Windows 95 installation, so that if your setup application does attempt to open the key, it may fail.</P>

<P>The following sample code details this process. Full error handling has been omitted.</P>

<P>#include &lt;windows.h&gt;  </P>

<P>#include &lt;string.h&gt; </P>

<P></P>

<P>void main(void) </P>

<P>{ </P>

<P>// </P>

<P>// First, attempt to open the registry key where approved extensions are </P>

<P>// listed. Note the extra slashes within the second parameter (the </P>

<P>// registry path string). </P>

<P>// </P>

<P></P>

<P>long err; </P>

<P>HKEY hkApproved; </P>

<P></P>

<P>err = RegOpenKeyEx( </P>

<P>HKEY_LOCAL_MACHINE, </P>

<P></P>

<P>"Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", </P>

<P>0, </P>

<P>KEY_SET_VALUE, </P>

<P>&amp;hkApproved); </P>

<P></P>

<P></P>

<P>if (err == ERROR_ACCESS_DENIED) </P>

<P>{ </P>

<P>// </P>

<P>// The user does not have permissions to add a new value to this key. In this </P>

<P>// case, a reasonable action would be to warn the user that some </P>

<P>// application features will not be available unless an administrator </P>

<P>// installs the application. If the shell extension is central to the </P>

<P>// functioning of the application, tell the user that the install </P>

<P>// can only be performed by an administrator, and stop the install. </P>

<P>// </P>

<P>} </P>

<P></P>

<P>else if (err == ERROR_FILE_NOT_FOUND) </P>

<P>{ </P>

<P>// </P>

<P>// The key does not exist. This should only happen if setup is running </P>

<P>// on Windows 95 instead of Windows NT, or if you are installing on an older </P>

<P>// version of either operating system that does not have the new shell. </P>

<P>// </P>

<P>} </P>

<P></P>

<P>else if (err != ERROR_SUCCESS) </P>

<P>{ </P>

<P>// </P>

<P>// some other problem... </P>

<P>// </P>

<P>} </P>

<P></P>

<P>else </P>

<P>{ </P>

<P>// </P>

<P>// The open of the key succeeded. Now register the new shell extension </P>

<P>// under this key. This requires having the ProgID and string form of the </P>

<P>// CLSID handy. </P>

<P>// </P>

<P></P>

<P>// </P>

<P>// Assume that lpstrProgID contains our ProgID string. </P>

<P>// </P>

<P></P>

<P>LPSTR lpstrProgID = "My Bogus Class"; </P>

<P></P>

<P>// </P>

<P>// Assume that clsidExtension contains the CLSID struct. The code below </P>

<P>// creates a string form this CLSID. If  a string version of </P>

<P>// the CLSID is already handy, skip this code. </P>

<P>// </P>

<P></P>

<P>CLSID clsidExtension = {0x11111111, 0x1111, 0x1111, 0x11, 0x11, </P>

<P>0x11, 0x11, 0x11, 0x11, 0x11, 0x11}; </P>

<P></P>

<P>HRESULT hr; </P>

<P>LPOLESTR lpolestrCLSID; </P>

<P>CHAR rgchCLSID[40]; </P>

<P></P>

<P>CoInitialize(NULL); </P>

<P></P>

<P>hr = StringFromCLSID(clsidExtension, &amp;lpolestrCLSID); </P>

<P></P>

<P>// </P>

<P>// StringFromCLSID returns a Unicode string, so convert to ANSI for </P>

<P>// calling the registry. Note that on Windows NT you can call the Unicode </P>

<P>// version of the registry API instead. </P>

<P>// </P>

<P></P>

<P>WideCharToMultiByte(CP_ACP,     0, lpolestrCLSID, -1, rgchCLSID, 40, </P>

<P>NULL, NULL); </P>

<P></P>

<P>CoTaskMemFree(lpolestrCLSID); </P>

<P></P>

<P>CoUninitialize(); </P>

<P></P>

<P></P>

<P>// </P>

<P>// Now add the new value to the registry. </P>

<P>// Note that each new shell extension CLSID must be registered here. </P>

<P>// </P>

<P></P>

<P>err = RegSetValueEx( </P>

<P>hkApproved, </P>

<P>rgchCLSID, </P>

<P>0, </P>

<P>REG_SZ, </P>

<P>(const BYTE *)lpstrProgID, </P>

<P>strlen(lpstrProgID)); </P>

<P></P>

<P></P>

<P>// </P>

<P>// Finally, close the key. </P>

<P>// </P>

<P></P>

<P>err = RegCloseKey(hkApproved); </P>

<P></P>

<P>} </P>

<P>} </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
