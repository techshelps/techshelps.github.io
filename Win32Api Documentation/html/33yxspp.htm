<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using Generic Data Types</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="33yxspp"></A><B>Using Generic Data Types</B></P>

<P>If you use generic data types in your code, it can be compiled for Unicode simply by defining UNICODE before the include statements for the header files. To compile the code for ANSI, omit the UNICODE definition. </P>

<P>To convert code that processes strings so it can be compiled for either ANSI or Unicode, follow these steps. </P>

<P>1.Change all character and string types used for text to <B>TCHAR</B>, <B>LPTSTR</B>, or <B>LPTCH</B>. </P>

<P>2.Be sure that pointers to nontext data buffers or binary byte arrays are coded with the <B>LPBYTE</B> type and not mistakenly with the <B>LPTSTR</B> or <B>LPTCH</B> type. Declare pointers of indeterminate type explicitly as void pointers by using <B>LPVOID</B>, as appropriate. </P>

<P>3.Make pointer arithmetic type-independent. Using units of <B>TCHAR</B> size yields variables that are two bytes if UNICODE is defined, and one byte if UNICODE is not defined. Using pointer arithmetic always returns the number of elements pointed to by the pointer, whether the elements are one or two bytes in size. The following expression always returns the number of elements, regardless of whether UNICODE is defined:</P>

<P>cCount = lpEnd - lpStart;  </P>

<P></P>

<P>The following expression determines the number of bytes used:</P>

<P>cByteCount = (lpEnd - lpStart) * sizeof(TCHAR);  </P>

<P></P>

<P>There is no need to change a statement like the following one, because the pointer increment points to the next character element. </P>

<P>chNext = *++lpText;  </P>

<P></P>

<P>4.Replace literal strings and manifest character constants with macros. Change expressions like the following one. </P>

<P>while(*lpFileName++ != '\\') {  </P>

<P>/* . </P>

<P>/* . </P>

<P>/* . </P>

<P>} </P>

<P></P>

<P>Use the <B>TEXT</B> macro as follows in this expression. </P>

<P>while(*lpFileName++ != TEXT('\\')) {  </P>

<P>./* </P>

<P>./* </P>

<P>./* </P>

<P>} </P>

<P></P>

<P>Precede a literal string in the Unicode form of a function by the letter <I>L</I>. The <B>TEXT</B> macro causes strings to be evaluated as <B>L"</B><I>string</I><B>"</B> when UNICODE is defined, and to <B>"</B><I>string</I><B>"</B> otherwise. The following call to the Unicode version of <B>lstrlen</B> demonstrates the use of the L identifier. </P>

<P>cch == lstrlenW(L"hello world");  </P>

<P></P>

<P>For easier management, move literal strings into resources, especially if they contain characters outside the ASCII range (that is, 0x00 through 0x7F). </P>

<P>5.Call only the Unicode versions of the standard C library string functions, as listed in <A HREF="3wjg0_.htm">Standard C Functions</A>. </P>

<P>6.Change any code that relies on 255 as the largest value for a character. </P>

<P></P>

<P>When you compile code that you have changed as outlined above, the compiler creates the same binary file as it did before you made the changes. When you compile the code using the UNICODE option, however, it is compiled as a Unicode application. </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
