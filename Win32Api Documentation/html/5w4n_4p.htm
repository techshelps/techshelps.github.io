<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Named Pipe Client Process</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="5w4n_4p"></A><B>Named Pipe Client Process</B></P>

<P>A client process uses the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function to open a handle to a named pipe. If the pipe exists but all of its instances are busy, <B>CreateFile</B> returns FALSE and the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function returns ERROR_PIPE_BUSY. When this happens, the client process uses the <A HREF="1xsezn8.htm"><B>WaitNamedPipe</B></A> function to wait for an instance of the pipe to be available. </P>

<P><B>CreateFile</B> fails if the access specified is incompatible with the access specified (duplex, outbound, or inbound) when the server created the pipe. For a duplex pipe (read/write), the client can specify read, write, or read/write access; for an outbound pipe (server write only), the client must specify read only; and for an inbound pipe (server read only), the client must specify write only. </P>

<P>The handle returned by <B>CreateFile</B> defaults to byte-read mode, blocking-wait mode, overlapped mode disabled, and write-through mode disabled. The client process can use <B>CreateFile</B> to enable overlapped mode by specifying FILE_FLAG_OVERLAPPED or to enable write-through mode by specifying FILE_FLAG_WRITE_THROUGH. The client can use the <A HREF="ap5lb1.htm"><B>SetNamedPipeHandleState</B></A> function to enable nonblocking mode by specifying PIPE_WAIT or to enable message-read mode by specifying PIPE_READMODE_MESSAGE. </P>

<P>The following example shows a client process that opens a named pipe, sets the pipe handle to message-read mode, uses <A HREF="g0sox_.htm"><B>WriteFile</B></A> to send a request to the server, and uses <A HREF="cjnd8p.htm"><B>ReadFile</B></A> to read the server's reply. This client process can be used with any of the message-type servers shown in the previous sections. With a byte-type server, however, this client process fails when it calls <B>SetNamedPipeHandleState</B> to change to message-read mode. Because the client is reading from the pipe in message-read mode, it is possible for the <B>ReadFile</B> operation to return FALSE after reading a partial message. This happens when the message is larger than the read buffer. In this situation, <B>GetLastError</B> returns ERROR_MORE_DATA, and the remainder of the message is read by additional calls to <B>ReadFile</B>. </P>

<P>#include &lt;windows.h&gt;  </P>

<P></P>

<P>DWORD main(int argc, char *argv[]) </P>

<P>{ </P>

<P>HANDLE hPipe; </P>

<P>LPVOID lpvMessage; </P>

<P>CHAR chBuf[512]; </P>

<P>BOOL fSuccess; </P>

<P>DWORD cbRead, cbWritten, dwMode; </P>

<P>LPTSTR lpszPipename = "\\\\.\\pipe\\mynamedpipe"; </P>

<P></P>

<P>// Try to open a named pipe; wait for it, if necessary. </P>

<P></P>

<P>while (1) </P>

<P>{ </P>

<P>hPipe = CreateFile( </P>

<P>lpszPipename,   // pipe name </P>

<P>GENERIC_READ |  // read and write access </P>

<P>GENERIC_WRITE, </P>

<P>0,              // no sharing </P>

<P>NULL,           // no security attributes</P>

<P>OPEN_EXISTING,  // opens existing pipe </P>

<P>0,              // default attributes </P>

<P>NULL);          // no template file </P>

<P></P>

<P>// Break if the pipe handle is valid. </P>

<P></P>

<P>if (hPipe != INVALID_HANDLE_VALUE) </P>

<P>break; </P>

<P></P>

<P>// Exit if an error other than ERROR_PIPE_BUSY occurs. </P>

<P></P>

<P>if (GetLastError() != ERROR_PIPE_BUSY) </P>

<P>MyErrExit("Could not open pipe"); </P>

<P></P>

<P>// All pipe instances are busy, so wait for 20 seconds. </P>

<P></P>

<P>if (! WaitNamedPipe(lpszPipename, 20000) ) </P>

<P>MyErrExit("Could not open pipe"); </P>

<P>} </P>

<P></P>

<P>// The pipe connected; change to message-read mode. </P>

<P></P>

<P>dwMode = PIPE_READMODE_MESSAGE; </P>

<P>fSuccess = SetNamedPipeHandleState( </P>

<P>hPipe,    // pipe handle </P>

<P>&amp;dwMode,  // new pipe mode </P>

<P>NULL,     // don't set max. bytes </P>

<P>NULL);    // don't set max. time </P>

<P>if (!fSuccess) </P>

<P>MyErrExit("SetNamedPipeHandleState"); </P>

<P></P>

<P>// Send a message to the pipe server. </P>

<P></P>

<P>lpvMessage = (argc &gt; 1) ? argv[1] : "default message"; </P>

<P></P>

<P>fSuccess = WriteFile( </P>

<P>hPipe,                  // pipe handle </P>

<P>lpvMessage,             // message </P>

<P>strlen(lpvMessage) + 1, // message length </P>

<P>&amp;cbWritten,             // bytes written </P>

<P>NULL);                  // not overlapped </P>

<P>if (! fSuccess) </P>

<P>MyErrExit("WriteFile"); </P>

<P></P>

<P>do </P>

<P>{ </P>

<P>// Read from the pipe. </P>

<P></P>

<P>fSuccess = ReadFile( </P>

<P>hPipe,    // pipe handle </P>

<P>chBuf,    // buffer to receive reply </P>

<P>512,      // size of buffer </P>

<P>&amp;cbRead,  // number of bytes read </P>

<P>NULL);    // not overlapped </P>

<P></P>

<P>if (! fSuccess &amp;&amp; GetLastError() != ERROR_MORE_DATA) </P>

<P>break; </P>

<P></P>

<P>// Reply from the pipe is written to STDOUT. </P>

<P></P>

<P>if (! WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), </P>

<P>chBuf, cbRead, &amp;cbWritten, NULL)) </P>

<P>break; </P>

<P></P>

<P>} while (! fSuccess);  // repeat loop if ERROR_MORE_DATA </P>

<P></P>

<P>CloseHandle(hPipe); </P>

<P></P>

<P>return 0; </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
