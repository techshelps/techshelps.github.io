<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Selecting a Line of Text</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="334909"></A><B>Selecting a Line of Text</B></P>

<P>The example in this section is taken from a simple word-processing application. It includes code that enables the user to set the position of the caret by clicking anywhere on a line of text, and to select (highlight) a line of text by double-clicking anywhere on the line. </P>

<P>LRESULT APIENTRY MainWndProc(hwndMain, uMsg, wParam, lParam)  </P>

<P>HWND hwndMain; </P>

<P>UINT uMsg; </P>

<P>WPARAM wParam; </P>

<P>LPARAM lParam; </P>

<P>{ </P>

<P>HDC hdc;                     /* handle of device context     */ </P>

<P>TEXTMETRIC tm;               /* font size data               */ </P>

<P>int i, j;                    /* loop counters                */ </P>

<P>int cCR = 0;                 /* count of carriage returns    */ </P>

<P>char ch;                     /* character from input buffer  */ </P>

<P>static int nBegLine;         /* beginning of selected line   */ </P>

<P>static int nCurrentLine = 0; /* currently selected line      */ </P>

<P>static int nLastLine = 0;    /* last text line               */ </P>

<P>static int nCaretPosX = 0;   /* x-coordinate of caret        */ </P>

<P>static int cch = 0;          /* number of characters entered */ </P>

<P>static int nCharWidth = 0;   /* exact width of a character   */ </P>

<P>static char szHilite[128];   /* text string to highlight     */ </P>

<P>static DWORD dwCharX;        /* average width of characters  */ </P>

<P>static DWORD dwLineHeight;   /* line height                  */ </P>

<P>static POINTS ptsCursor;     /* coordinates of mouse cursor  */ </P>

<P>static COLORREF crPrevText;  /* previous text color          */ </P>

<P>static COLORREF crPrevBk;    /* previous background color    */ </P>

<P>static PTCHAR pchInputBuf;   /* address of input buffer      */ </P>

<P>static BOOL fTextSelected = FALSE; /* text-selection flag    */ </P>

<P></P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_CREATE: </P>

<P></P>

<P>/* Get the metrics of the current font. */ </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>GetTextMetrics(hdc, &amp;tm); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P></P>

<P>/* Save the average character width and height. */ </P>

<P></P>

<P>dwCharX = tm.tmAveCharWidth; </P>

<P>dwLineHeight = tm.tmHeight; </P>

<P></P>

<P>/* Allocate a buffer to store keyboard input. */ </P>

<P></P>

<P>pchInputBuf = (LPSTR) GlobalAlloc(GPTR, </P>

<P>BUFSIZE * sizeof(TCHAR)); </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>case WM_CHAR: </P>

<P>switch (wParam) { </P>

<P>case 0x08:  /* backspace */ </P>

<P>case 0x0A:  /* linefeed */ </P>

<P>case 0x1B:  /* escape */ </P>

<P>MessageBeep(0xFFFFFFFF); </P>

<P>return 0; </P>

<P></P>

<P>case 0x09:  /* tab */ </P>

<P></P>

<P>/* Convert tabs to four consecutive spaces. */ </P>

<P></P>

<P>for (i = 0; i &lt; 4; i++) </P>

<P>SendMessage(hwndMain, WM_CHAR, 0x20, 0); </P>

<P>return 0; </P>

<P></P>

<P>case 0x0D:  /* carriage return */ </P>

<P></P>

<P>/* </P>

<P>* Record the carriage return, and position the </P>

<P>* caret at the beginning of the new line. </P>

<P>*/ </P>

<P></P>

<P>pchInputBuf[cch++] = 0x0D; </P>

<P>nCaretPosX = 0; </P>

<P>nCurrentLine += 1; </P>

<P>break; </P>

<P></P>

<P>default:    /* displayable character */ </P>

<P></P>

<P>ch = (char) wParam; </P>

<P>HideCaret(hwndMain); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the character's width, and display the </P>

<P>* character. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>GetCharWidth32(hdc, (UINT) wParam, (UINT) wParam, </P>

<P>&amp;nCharWidth); </P>

<P>TextOut(hdc, nCaretPosX, </P>

<P>nCurrentLine * dwLineHeight, &amp;ch, 1); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P></P>

<P>/* Store the character in the buffer. */ </P>

<P></P>

<P>pchInputBuf[cch++] = ch; </P>

<P></P>

<P>/* </P>

<P>* Calculate the new horizontal position of </P>

<P>* the caret. If the new position exceeds the </P>

<P>* maximum, insert a carriage return and </P>

<P>* reposition the caret at the beginning of </P>

<P>* the next line. </P>

<P>*/ </P>

<P></P>

<P>nCaretPosX += nCharWidth; </P>

<P>if ((DWORD) nCaretPosX &gt; dwMaxCharX) { </P>

<P>nCaretPosX = 0; </P>

<P>pchInputBuf[cch++] = 0x0D; </P>

<P>++nCurrentLine; </P>

<P>} </P>

<P></P>

<P>ShowCaret(hwndMain); </P>

<P></P>

<P>break; </P>

<P>} </P>

<P>SetCaretPos(nCaretPosX, nCurrentLine * dwLineHeight); </P>

<P>nLastLine = max(nLastLine, nCurrentLine); </P>

<P>break; </P>

<P></P>

<P>. </P>

<P>. /* Process other messages. */ </P>

<P>. </P>

<P></P>

<P>case WM_LBUTTONDOWN: </P>

<P></P>

<P>/* </P>

<P>* If a line of text is currently highlighted, redraw </P>

<P>* the text to remove the highlighting. </P>

<P>*/ </P>

<P></P>

<P>if (fTextSelected) { </P>

<P>hdc = GetDC(hwndMain); </P>

<P>SetTextColor(hdc, crPrevText); </P>

<P>SetBkColor(hdc, crPrevBk); </P>

<P>TextOut(hdc, 0, nCurrentLine * dwLineHeight, </P>

<P>szHilite, lstrlen(szHilite)); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>ShowCaret(hwndMain); </P>

<P>fTextSelected = FALSE; </P>

<P>} </P>

<P></P>

<P>/* Save the current mouse-cursor coordinates. */ </P>

<P></P>

<P>ptsCursor = MAKEPOINTS(lParam); </P>

<P></P>

<P>/* </P>

<P>* Determine which line the cursor is on, and save </P>

<P>* the line number. Do not allow line numbers greater </P>

<P>* than the number of the last line of text. The </P>

<P>* line number is later multiplied by the average height </P>

<P>* of the current font. The result is used to set the </P>

<P>* y-coordinate of the caret. </P>

<P>*/ </P>

<P></P>

<P>nCurrentLine = min((int)(ptsCursor.y / dwLineHeight), </P>

<P>nLastLine); </P>

<P></P>

<P>/* </P>

<P>* Parse the text input buffer to find the first </P>

<P>* character in the selected line of text. Each </P>

<P>* line ends with a carriage return, so it is possible </P>

<P>* to count the carriage returns to find the selected </P>

<P>* line. </P>

<P>*/ </P>

<P></P>

<P>cCR = 0; </P>

<P>nBegLine = 0; </P>

<P>if (nCurrentLine != 0) { </P>

<P>for (i = 0; (i &lt; cch) &amp;&amp; </P>

<P>(cCR &lt; nCurrentLine); i++) { </P>

<P>if (pchInputBuf[i] == 0x0D) </P>

<P>++cCR; </P>

<P>} </P>

<P>nBegLine = i; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Starting at the beginning of the selected line, </P>

<P>* measure  the width of each character, summing the </P>

<P>* width with each character measured. Stop when the </P>

<P>* sum is greater than the x-coordinate of the cursor. </P>

<P>* The sum is used to set the x-coordinate of the caret. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>nCaretPosX = 0; </P>

<P>for (i = nBegLine; </P>

<P>(pchInputBuf[i] != 0x0D) &amp;&amp; (i &lt; cch); i++) { </P>

<P>ch = pchInputBuf[i]; </P>

<P>GetCharWidth32(hdc, (int) ch, (int) ch, &amp;nCharWidth); </P>

<P>if ((nCaretPosX + nCharWidth) &gt; ptsCursor.x) </P>

<P>break; </P>

<P>else </P>

<P>nCaretPosX += nCharWidth; </P>

<P>} </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P></P>

<P>/* Set the caret to the user-selected position. */ </P>

<P></P>

<P>SetCaretPos(nCaretPosX, nCurrentLine * dwLineHeight); </P>

<P>break; </P>

<P></P>

<P>case WM_LBUTTONDBLCLK: </P>

<P></P>

<P>/* Copy the selected line of text to a buffer. */ </P>

<P></P>

<P>for (i = nBegLine, j = 0; (pchInputBuf[i] != 0x0D) &amp;&amp; </P>

<P>(i &lt; cch); i++) </P>

<P>szHilite[j++] = pchInputBuf[i]; </P>

<P>szHilite[j] = '\0'; </P>

<P></P>

<P>/* </P>

<P>* Hide the caret, invert the background and foreground </P>

<P>* colors, and then redraw the selected line. </P>

<P>*/ </P>

<P></P>

<P>HideCaret(hwndMain); </P>

<P>hdc = GetDC(hwndMain); </P>

<P>crPrevText = SetTextColor(hdc, RGB(255, 255, 255)); </P>

<P>crPrevBk = SetBkColor(hdc, RGB(0, 0, 0)); </P>

<P>TextOut(hdc, 0, nCurrentLine * dwLineHeight, szHilite, </P>

<P>lstrlen(szHilite)); </P>

<P>SetTextColor(hdc, crPrevText); </P>

<P>SetBkColor(hdc, crPrevBk); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P></P>

<P>fTextSelected = TRUE; </P>

<P>break; </P>

<P>. </P>

<P>. /* Process other messages. */ </P>

<P>. </P>

<P>default: </P>

<P>return DefWindowProc(hwndMain, uMsg, wParam, lParam); </P>

<P>} </P>

<P>return NULL; </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
