<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>How the Shell Accesses Shell Extension Handlers</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="e8m778"></A><B>How the Shell Accesses Shell Extension Handlers</B></P>

<P>The shell uses two interfaces to initialize instances (objects created by <B>IClassFactory::CreateInstance</B>) of shell extensions: <A HREF="ehqr2a.htm"><B>IShellExtInit</B></A> and <B>IPersistFile</B>. The shell uses the <B>IShellExtInit</B> interface to initialize instances of context menu handlers, drag and drop handlers, and property sheet handlers. The shell uses <B>IPersistFile</B> to initialize instances of icon handlers, data handlers, and drop handlers. This interface is defined by OLE. </P>

<P>The <B>IShellExtInit</B> interface adds an additional member function, <B>Initialize</B>, to the standard <B>IUnknown</B> interface. A handler's <B>Initialize</B> function should keep a copy of the parameters that the shell passes to the function for later use. An example showing how to initialize instances follows.</P>

<P>STDMETHODIMP CShellExt::Initialize(LPCITEMIDLIST pIDFolder, <BR>
    LPDATAOBJECT pDataObj, HKEY hRegKey)  </P>

<P>{ </P>

<P>// Initialize can be called more than once. </P>

<P>if (m_pDataObj) </P>

<P>m_pDataObj-&gt;Release(); </P>

<P></P>

<P>// Save the object pointer. </P>

<P>if (pDataObj) { </P>

<P>m_pDataObj = pDataObj; </P>

<P>pDataObj-&gt;AddRef(); </P>

<P>} </P>

<P></P>

<P>// Duplicate the registry handle. </P>

<P>if (hRegKey) </P>

<P>RegOpenKeyEx(hRegKey, NULL, 0L, MAXIMUM_ALLOWED, </P>

<P>&amp;this-&gt;hRegKey); </P>

<P></P>

<P>return NOERROR; </P>

<P>} </P>

<P></P>

<P>A shell extension handler must implement three functions: an entrypoint function (often called DllMain or LibMain), <B>DllCanUnloadNow</B>, and <B>DllGetClassObject</B>. </P>

<P><B>DllCanUnloadNow</B> and <B>DllGetClassObject</B> are essentially the same as they would be for any OLE in-process server DLL. The use of <B>DllCanUnloadNow</B> is shown in the following example.</P>

<P>STDAPI DllCanUnloadNow(void)  </P>

<P>{ </P>

<P>// g_cRefThisDll must be placed in the instance-specifc <BR>
    // data section. </P>

<P>return ResultFromScode((g_cRefThisDll==0) ? S_OK : S_FALSE); </P>

<P>} </P>

<P></P>

<P><B>DllGetClassObject</B> needs to expose the class factory for the object in the DLL. For more information about exposing the class factory, see the OLE documentation included in the Microsoft® Win32® Software Development Kit (SDK). The following example shows how to expose the class factory.</P>

<P>// DllGetClassObject - a DLL entrypoint function used by <BR>
// most in-process server DLLs.  </P>

<P></P>

<P>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut) </P>

<P>{ </P>

<P>*ppvOut = NULL; // assume failure </P>

<P></P>

<P>if (IsEqualIID(rclsid, CLSID_ShellExtension)) { </P>

<P>return CShellExtSample_Create(riid, ppvOut); </P>

<P>} else { </P>

<P>return CLASS_E_CLASSNOTAVAILABLE; </P>

<P>} </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
