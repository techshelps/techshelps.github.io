<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Example of Scrolling a Bitmap</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="b5eaz2"></A><B>Example of Scrolling a Bitmap</B></P>

<P>The following example enables the user to capture the screen content into a bitmap and scroll the bitmap in the client area. </P>

<P>HDC hdc;  </P>

<P>PAINTSTRUCT ps; </P>

<P>SCROLLINFO si; </P>

<P></P>

<P>/* These variables are required by BitBlt.                      */ </P>

<P></P>

<P>static HDC hdcWin;           /* window DC                       */ </P>

<P>static HDC hdcScreen;        /* DC for entire screen            */ </P>

<P>static HDC hdcScreenCompat;  /* memory DC for screen            */ </P>

<P>static HBITMAP hbmpCompat;   /* bitmap handle for old DC        */ </P>

<P>static BITMAP bmp;           /* bitmap data structure           */ </P>

<P>static BOOL fBlt;            /* TRUE if BitBlt occurred         */ </P>

<P>static BOOL fScroll;         /* TRUE if scrolling occurred      */ </P>

<P>static BOOL fSize;           /* TRUE if fBlt &amp; WM_SIZE          */ </P>

<P></P>

<P>/* These variables are required for horizontal scrolling.       */ </P>

<P></P>

<P>static int xMinScroll;       /* minimum horizontal scroll value */ </P>

<P>static int xCurrentScroll;   /* current horizontal scroll value */ </P>

<P>static int xMaxScroll;       /* maximum horizontal scroll value */ </P>

<P></P>

<P>/* These variables are required for vertical scrolling.         */ </P>

<P></P>

<P>static int yMinScroll;       /* minimum vertical scroll value   */ </P>

<P>static int yCurrentScroll;   /* current vertical scroll value   */ </P>

<P>static int yMaxScroll;       /* maximum vertical scroll value   */ </P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_CREATE: </P>

<P></P>

<P>/* </P>

<P>* Create a normal DC and a memory DC for the entire </P>

<P>* screen. The normal DC provides a snapshot of the </P>

<P>* screen contents. The memory DC keeps a copy of this </P>

<P>* snapshot in the associated bitmap. </P>

<P>*/ </P>

<P></P>

<P>hdcScreen = CreateDC("DISPLAY", (LPCSTR) NULL, </P>

<P>(LPCSTR) NULL, (CONST DEVMODE *) NULL); </P>

<P>hdcScreenCompat = CreateCompatibleDC(hdcScreen); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the metrics for the bitmap associated with the </P>

<P>* regular device context. </P>

<P>*/ </P>

<P></P>

<P>bmp.bmBitsPixel = </P>

<P>(BYTE) GetDeviceCaps(hdcScreen, BITSPIXEL); </P>

<P>bmp.bmPlanes = (BYTE) GetDeviceCaps(hdcScreen, PLANES); </P>

<P>bmp.bmWidth = GetDeviceCaps(hdcScreen, HORZRES); </P>

<P>bmp.bmHeight = GetDeviceCaps(hdcScreen, VERTRES); </P>

<P></P>

<P>/* The width must be byte-aligned. */ </P>

<P></P>

<P>bmp.bmWidthBytes = ((bmp.bmWidth + 15) &amp;~15)/8; </P>

<P></P>

<P>/* Create a bitmap for the compatible DC. */ </P>

<P></P>

<P>hbmpCompat = CreateBitmap(bmp.bmWidth, bmp.bmHeight, </P>

<P>bmp.bmPlanes, bmp.bmBitsPixel, (CONST VOID *) NULL); </P>

<P></P>

<P>/* Select the bitmap for the compatible DC. */ </P>

<P></P>

<P>SelectObject(hdcScreenCompat, hbmpCompat); </P>

<P></P>

<P>/* Initialize the flags. */ </P>

<P></P>

<P>fBlt = FALSE; </P>

<P>fScroll = FALSE; </P>

<P>fSize = FALSE; </P>

<P></P>

<P>/* Initialize the horizontal scrolling variables. */ </P>

<P></P>

<P>xMinScroll = 0; </P>

<P>xCurrentScroll = 0; </P>

<P>xMaxScroll = 0; </P>

<P></P>

<P>/* Initialize the vertical scrolling variables. */ </P>

<P></P>

<P>yMinScroll = 0; </P>

<P>yCurrentScroll = 0; </P>

<P>yMaxScroll = 0; </P>

<P></P>

<P>break; </P>

<P></P>

<P>case WM_SIZE: { </P>

<P></P>

<P>int xNewSize; </P>

<P>int yNewSize; </P>

<P></P>

<P>xNewSize = LOWORD(lParam); </P>

<P>yNewSize = HIWORD(lParam); </P>

<P></P>

<P>if (fBlt) </P>

<P>fSize = TRUE; </P>

<P></P>

<P>/* </P>

<P>* The horizontal scrolling range is defined by </P>

<P>* (bitmap_width) - (client_width). The current horizontal </P>

<P>* scroll value remains within the horizontal scrolling range. </P>

<P>*/ </P>

<P></P>

<P>xMaxScroll = max(bmp.bmWidth-xNewSize, 0); </P>

<P>xCurrentScroll = min(xCurrentScroll, xMaxScroll); </P>

<P>si.cbSize = sizeof(si); </P>

<P>si.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS; </P>

<P>si.nMin   = xMinScroll; </P>

<P>si.nMax   = xMaxScroll; </P>

<P>si.nPage  = xNewSize; </P>

<P>si.nPos   = xCurrentScroll; </P>

<P>SetScrollInfo(hwnd, SB_HORZ, &amp;si, TRUE); </P>

<P></P>

<P>/* </P>

<P>* The vertical scrolling range is defined by </P>

<P>* (bitmap_height) - (client_height). The current vertical </P>

<P>* scroll value remains within the vertical scrolling range. </P>

<P>*/ </P>

<P></P>

<P>yMaxScroll = max(bmp.bmHeight - yNewSize, 0); </P>

<P>yCurrentScroll = min(yCurrentScroll, yMaxScroll); </P>

<P>si.cbSize = sizeof(si); </P>

<P>si.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS; </P>

<P>si.nMin   = yMinScroll; </P>

<P>si.nMax   = yMaxScroll; </P>

<P>si.nPage  = yNewSize; </P>

<P>si.nPos   = yCurrentScroll; </P>

<P>SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE); </P>

<P></P>

<P>} </P>

<P>break; </P>

<P></P>

<P>case WM_PAINT: { </P>

<P></P>

<P>PRECT prect; </P>

<P></P>

<P>hdc = BeginPaint(hwnd, &amp;ps); </P>

<P></P>

<P>/* </P>

<P>* If the window has been resized and the user has </P>

<P>* captured the screen, use the following call to </P>

<P>* BitBlt to paint the window's client area. </P>

<P>*/ </P>

<P></P>

<P>if (fSize) { </P>

<P>BitBlt(ps.hdc, </P>

<P>0, 0, </P>

<P>bmp.bmWidth, bmp.bmHeight, </P>

<P>hdcScreenCompat, </P>

<P>xCurrentScroll, yCurrentScroll, </P>

<P>SRCCOPY); </P>

<P></P>

<P>fSize = FALSE; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* If scrolling has occurred, use the following call to </P>

<P>* BitBlt to paint the invalid rectangle. </P>

<P>* </P>

<P>* The coordinates of this rectangle are specified in the </P>

<P>* RECT structure to which prect points. </P>

<P>* </P>

<P>* Note that it is necessary to increment the seventh </P>

<P>* argument (prect-&gt;left) by xCurrentScroll and the </P>

<P>* eighth argument (prect-&gt;top) by yCurrentScroll in </P>

<P>* order to map the correct pixels from the source bitmap. </P>

<P>*/ </P>

<P></P>

<P>if (fScroll) { </P>

<P>prect = &amp;ps.rcPaint; </P>

<P></P>

<P>BitBlt(ps.hdc, </P>

<P>prect-&gt;left, prect-&gt;top, </P>

<P>(prect-&gt;right - prect-&gt;left), </P>

<P>(prect-&gt;bottom - prect-&gt;top), </P>

<P>hdcScreenCompat, </P>

<P>prect-&gt;left + xCurrentScroll, </P>

<P>prect-&gt;top + yCurrentScroll, </P>

<P>SRCCOPY); </P>

<P></P>

<P>fScroll = FALSE; </P>

<P>} </P>

<P></P>

<P>EndPaint(hwnd, &amp;ps); </P>

<P>} </P>

<P>break; </P>

<P></P>

<P>case WM_HSCROLL: { </P>

<P></P>

<P>int xDelta;     /* xDelta = new_pos - current_pos */ </P>

<P>int xNewPos;    /* new position */ </P>

<P>int yDelta = 0; </P>

<P></P>

<P>switch (LOWORD(wParam)) { </P>

<P></P>

<P>/* User clicked the shaft left of the scroll box. */ </P>

<P></P>

<P>case SB_PAGEUP: </P>

<P>xNewPos = xCurrentScroll - 50; </P>

<P>break; </P>

<P></P>

<P>/* User clicked the shaft right of the scroll box. */ </P>

<P></P>

<P>case SB_PAGEDOWN: </P>

<P>xNewPos = xCurrentScroll + 50; </P>

<P>break; </P>

<P></P>

<P>/* User clicked the left arrow. */ </P>

<P></P>

<P>case SB_LINEUP: </P>

<P>xNewPos = xCurrentScroll - 5; </P>

<P>break; </P>

<P></P>

<P>/* User clicked the right arrow. */ </P>

<P></P>

<P>case SB_LINEDOWN: </P>

<P>xNewPos = xCurrentScroll + 5; </P>

<P>break; </P>

<P></P>

<P>/* User dragged the scroll box. */ </P>

<P></P>

<P>case SB_THUMBPOSITION: </P>

<P>xNewPos = HIWORD(wParam); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>xNewPos = xCurrentScroll; </P>

<P>} </P>

<P></P>

<P>/* New position must be between 0 and the screen width. */ </P>

<P></P>

<P>xNewPos = max(0, xNewPos); </P>

<P>xNewPos = min(xMaxScroll, xNewPos); </P>

<P></P>

<P>/* If the current position does not change, do not scroll.*/ </P>

<P></P>

<P>if (xNewPos == xCurrentScroll) </P>

<P>break; </P>

<P></P>

<P>/* Set the scroll flag to TRUE. */ </P>

<P></P>

<P>fScroll = TRUE; </P>

<P></P>

<P>/* Determine the amount scrolled (in pixels). */ </P>

<P></P>

<P>xDelta = xNewPos - xCurrentScroll; </P>

<P></P>

<P>/* Reset the current scroll position. */ </P>

<P></P>

<P>xCurrentScroll = xNewPos; </P>

<P></P>

<P>/* </P>

<P>* Scroll the window. (The system repaints most of the </P>

<P>* client area when ScrollWindowEx is called; however, it is </P>

<P>* necessary to call UpdateWindow in order to repaint the </P>

<P>* rectangle of pixels that were invalidated.) </P>

<P>*/ </P>

<P></P>

<P>ScrollWindowEx(hwnd, -xDelta, -yDelta, (CONST RECT *) NULL, </P>

<P>(CONST RECT *) NULL, (HRGN) NULL, (LPRECT) NULL, </P>

<P>SW_INVALIDATE); </P>

<P>UpdateWindow(hwnd); </P>

<P></P>

<P>/* Reset the scroll bar. */ </P>

<P></P>

<P>si.cbSize = sizeof(si); </P>

<P>si.fMask  = SIF_POS; </P>

<P>si.nPos   = xCurrentScroll; </P>

<P>SetScrollInfo(hwnd, SB_HORZ, &amp;si, TRUE); </P>

<P></P>

<P>} </P>

<P>break; </P>

<P></P>

<P>case WM_VSCROLL: { </P>

<P></P>

<P>int xDelta = 0; </P>

<P>int yDelta;     /* yDelta = new_pos - current_pos */ </P>

<P>int yNewPos;    /* new position */ </P>

<P></P>

<P>switch (LOWORD(wParam)) { </P>

<P></P>

<P>/* User clicked the shaft above the scroll box. */ </P>

<P></P>

<P>case SB_PAGEUP: </P>

<P>yNewPos = yCurrentScroll - 50; </P>

<P>break; </P>

<P></P>

<P>/* User clicked the shaft below the scroll box. */ </P>

<P></P>

<P>case SB_PAGEDOWN: </P>

<P>yNewPos = yCurrentScroll + 50; </P>

<P>break; </P>

<P></P>

<P>/* User clicked the top arrow. */ </P>

<P></P>

<P>case SB_LINEUP: </P>

<P>yNewPos = yCurrentScroll - 5; </P>

<P>break; </P>

<P></P>

<P>/* User clicked the bottom arrow. */ </P>

<P></P>

<P>case SB_LINEDOWN: </P>

<P>yNewPos = yCurrentScroll + 5; </P>

<P>break; </P>

<P></P>

<P>/* User dragged the scroll box. */ </P>

<P></P>

<P>case SB_THUMBPOSITION: </P>

<P>yNewPos = HIWORD(wParam); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>yNewPos = yCurrentScroll; </P>

<P>} </P>

<P></P>

<P>/* New position must be between 0 and the screen height. */ </P>

<P></P>

<P>yNewPos = max(0, yNewPos); </P>

<P>yNewPos = min(yMaxScroll, yNewPos); </P>

<P></P>

<P>/* If the current position does not change, do not scroll.*/ </P>

<P></P>

<P>if (yNewPos == yCurrentScroll) </P>

<P>break; </P>

<P></P>

<P>/* Set the scroll flag to TRUE. */ </P>

<P></P>

<P>fScroll = TRUE; </P>

<P></P>

<P>/* Determine the amount scrolled (in pixels). */ </P>

<P></P>

<P>yDelta = yNewPos - yCurrentScroll; </P>

<P></P>

<P>/* Reset the current scroll position. */ </P>

<P></P>

<P>yCurrentScroll = yNewPos; </P>

<P></P>

<P>/* </P>

<P>* Scroll the window. (The system repaints most of the </P>

<P>* client area when ScrollWindowEx is called; however, it is </P>

<P>* necessary to call UpdateWindow in order to repaint the </P>

<P>* rectangle of pixels that were invalidated.) </P>

<P>*/ </P>

<P></P>

<P>ScrollWindowEx(hwnd, -xDelta, -yDelta, (CONST RECT *) NULL, </P>

<P>(CONST RECT *) NULL, (HRGN) NULL, (LPRECT) NULL, </P>

<P>SW_INVALIDATE); </P>

<P>UpdateWindow(hwnd); </P>

<P></P>

<P>/* Reset the scroll bar. */ </P>

<P></P>

<P>si.cbSize = sizeof(si); </P>

<P>si.fMask  = SIF_POS; </P>

<P>si.nPos   = yCurrentScroll; </P>

<P>SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE); </P>

<P></P>

<P>} </P>

<P>break; </P>

<P></P>

<P>case WM_COMMAND:        /* uMsg: command from app. menu */ </P>

<P>switch(wParam) { </P>

<P>case IDM_STC: </P>

<P></P>

<P>/* </P>

<P>* Copy the contents of the current screen </P>

<P>* into the compatible DC. </P>

<P>*/ </P>

<P></P>

<P>BitBlt(hdcScreenCompat, 0, 0, bmp.bmWidth, </P>

<P>bmp.bmHeight, hdcScreen, 0, 0, SRCCOPY); </P>

<P></P>

<P>/* </P>

<P>* Copy the compatible DC to the client area. </P>

<P>*/ </P>

<P></P>

<P>hdcWin = GetDC(hwnd); </P>

<P></P>

<P>BitBlt(hdcWin, 0, 0, bmp.bmWidth, bmp.bmHeight, </P>

<P>hdcScreenCompat, 0, 0, SRCCOPY); </P>

<P></P>

<P>ReleaseDC(hwnd, hdcWin); </P>

<P></P>

<P>fBlt = TRUE; </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>return (DefWindowProc(hwnd, uMsg, </P>

<P>wParam, lParam)); </P>

<P>} </P>

<P>break; </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
