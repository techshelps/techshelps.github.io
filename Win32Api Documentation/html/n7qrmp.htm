<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>FormatMessage</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="n7qrmp"></A><B>FormatMessage  <A HREF="lzisyj.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="1r0c_vq.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="21act6p.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>FormatMessage</B> function formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested. </P>

<P><B>DWORD FormatMessage(</B></P>

<TABLE cols=2 width=489>

<TR VALIGN="top">
<TD width=39%><B>DWORD</B> <I>dwFlags</I><B>,</B></TD>
<TD width=61%>// source and processing options </TD>
</TR>

<TR VALIGN="top">
<TD width=39%><B>    LPCVOID</B> <I>lpSource</I><B>,</B></TD>
<TD width=61%>// pointer to  message source </TD>
</TR>

<TR VALIGN="top">
<TD width=39%><B>    DWORD</B> <I>dwMessageId</I><B>,</B></TD>
<TD width=61%>// requested message identifier </TD>
</TR>

<TR VALIGN="top">
<TD width=39%><B>    DWORD</B> <I>dwLanguageId</I><B>,</B></TD>
<TD width=61%>// language identifier for requested message </TD>
</TR>

<TR VALIGN="top">
<TD width=39%><B>    LPTSTR</B> <I>lpBuffer</I><B>,</B></TD>
<TD width=61%>// pointer to message buffer </TD>
</TR>

<TR VALIGN="top">
<TD width=39%><B>    DWORD</B> <I>nSize</I><B>,</B></TD>
<TD width=61%>// maximum size of message buffer </TD>
</TR>

<TR VALIGN="top">
<TD width=39%><B>    va_list</B> <I>*Arguments</I> </TD>
<TD width=61%>// address of array of message inserts </TD>
</TR>

<TR VALIGN="top">
<TD width=39%><B>   );</B></TD>
<TD width=61%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>dwFlags</I></P>

<P>Contains a set of bit flags that specify aspects of the formatting process and how to interpret the <I>lpSource</I> parameter. The low-order byte of <I>dwFlags</I> specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.</P>

<P>You can specify a combination of the following bit flags:</P>

<TABLE cols=6>

<TR VALIGN="top">
<TD colspan=2 width=14%><B>Value</B></TD>
<TD colspan=3 width=73%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>FORMAT_MESSAGE_ALLOCATE_BUFFER</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>Specifies that the <I>lpBuffer</I> parameter is a pointer to a <B>PVOID</B> pointer, and that the <I>nSize</I> parameter specifies the minimum number of bytes (ANSI version) or characters (Unicode version) to allocate for an output message buffer. The function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated buffer at the address specified by <I>lpBuffer</I>. The caller should use the <A HREF="0wv2ny.htm"><B>LocalFree</B></A> function to free the buffer when it is no longer needed.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>FORMAT_MESSAGE_IGNORE_INSERTS</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>Specifies that insert sequences in the message definition are to be ignored and passed through to the output buffer unchanged. This flag is useful for fetching a message for later formatting. If this flag is set, the <I>Arguments</I> parameter is ignored.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>FORMAT_MESSAGE_FROM_STRING</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>Specifies that <I>lpSource</I> is a pointer to a null-terminated message definition. The message definition may contain insert sequences, just as the message text in a message table resource may. Cannot be used with FORMAT_MESSAGE_FROM_HMODULE or FORMAT_MESSAGE_FROM_SYSTEM. </TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>FORMAT_MESSAGE_FROM_HMODULE</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>Specifies that <I>lpSource</I> is a module handle containing the message-table resource(s) to search. If this <I>lpSource</I> handle is NULL, the current process's application image file will be searched. Cannot be used with FORMAT_MESSAGE_FROM_STRING.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>FORMAT_MESSAGE_FROM_SYSTEM</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>Specifies that the function should search the system message-table resource(s) for the requested message. If this flag is specified with FORMAT_MESSAGE_FROM_HMODULE, the function searches the system message table if the message is not found in the module specified by <I>lpSource</I>. Cannot be used with FORMAT_MESSAGE_FROM_STRING.
<P>If this flag is specified, an application can pass the result of the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function to retrieve the message text for a system-defined error.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>FORMAT_MESSAGE_ARGUMENT_ARRAY</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>Specifies that the <I>Arguments</I> parameter is <I>not</I> a <B>va_list</B> structure, but instead is just a pointer to an array of 32-bit values that represent the arguments.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>The low-order byte of <I>dwFlags</I> can specify the maximum width of a formatted output line. Use the FORMAT_MESSAGE_MAX_WIDTH_MASK constant and bitwise Boolean operations to set and retrieve this maximum width value.</P>

<P>The following table shows how <B>FormatMessage</B> interprets the value of the low-order byte.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=62%><B>Value</B></TD>
<TD width=38%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=62%>0</TD>
<TD width=38%>There are no output line width restrictions. The function stores line breaks that are in the message definition text into the output buffer.</TD>
</TR>

<TR VALIGN="top">
<TD width=62%>A nonzero value other than FORMAT_MESSAGE_MAX_WIDTH_MASK</TD>
<TD width=38%>The nonzero value is the maximum number of characters in an output line. The function ignores regular line breaks in the message definition text. The function never splits a string delimited by white space across a line break. The function stores hard-coded line breaks in the message definition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.</TD>
</TR>

<TR VALIGN="top">
<TD width=62%>FORMAT_MESSAGE_MAX_WIDTH_MASK</TD>
<TD width=38%>The function ignores regular line breaks in the message definition text. The function stores hard-coded line breaks in the message definition text into the output buffer. The function generates no new line breaks. </TD>
</TR>
</TABLE><BR>

<P></P>

<P><I>lpSource</I></P>

<P>Specifies the location of the message definition. The type of this parameter depends upon the settings in the <I>dwFlags</I> parameter. </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=60%><B><I>dwFlags</I> Setting</B></TD>
<TD width=40%><B>Parameter Type</B></TD>
</TR>

<TR VALIGN="top">
<TD width=60%>FORMAT_MESSAGE_FROM_HMODULE</TD>
<TD width=40%><I>lpSource</I> is an hModule of the module that contains the message table to search.</TD>
</TR>

<TR VALIGN="top">
<TD width=60%>FORMAT_MESSAGE_FROM_STRING</TD>
<TD width=40%><I>lpSource</I> is an <B>LPTSTR</B> that points to unformatted message text. It will be scanned for inserts and formatted accordingly.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>If neither of these flags is set in <I>dwFlags</I>, then <I>lpSource</I> is ignored. </P>

<P><I>dwMessageId</I></P>

<P>Specifies the 32-bit message identifier for the requested message. This parameter is ignored if <I>dwFlags</I> includes FORMAT_MESSAGE_FROM_STRING. </P>

<P><I>dwLanguageId</I></P>

<P>Specifies the 32-bit language identifier for the requested message. This parameter is ignored if <I>dwFlags</I> includes FORMAT_MESSAGE_FROM_STRING. </P>

<P>If you pass a specific LANGID in this parameter, <B>FormatMessage</B> will return a message for that LANGID only. If the function cannot find a message for that LANGID, it returns ERROR_RESOURCE_LANG_NOT_FOUND. If you pass in zero, <B>FormatMessage</B> looks for a message for LANGIDs in the following order:</P>

<P>1.Language neutral</P>

<P>2.Thread LANGID, based on the thread's locale value</P>

<P>3.User default LANGID, based on the user's default locale value</P>

<P>4.System default LANGID, based on the system default locale value</P>

<P>5.US English</P>

<P></P>

<P>If <B>FormatMessage</B> doesn't find a message for any of the above LANGIDs, it returns any language message string that is present. If even that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.</P>

<P><I>lpBuffer</I></P>

<P>Points to a buffer for the formatted (and null-terminated) message. If <I>dwFlags</I> includes FORMAT_MESSAGE_ALLOCATE_BUFFER, the function allocates a buffer using the <A HREF="2_d2ee.htm"><B>LocalAlloc</B></A> function, and places the address of the buffer at the address specified in <I>lpBuffer</I>. </P>

<P><I>nSize</I></P>

<P>If the FORMAT_MESSAGE_ALLOCATE_BUFFER flag is not set, this parameter specifies the maximum number of bytes (ANSI version) or characters (Unicode version) that can be stored in the output buffer. If FORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter specifies the minimum number of bytes or characters to allocate for an output buffer. </P>

<P><I>Arguments</I></P>

<P>Points to an array of 32-bit values that are used as insert values in the formatted message. %1 in the format string indicates the first value in the <I>Arguments</I> array; %2 indicates the second argument; and so on. </P>

<P>The interpretation of each 32-bit value depends on the formatting information associated with the insert in the message definition. The default is to treat each value as a pointer to a null-terminated string. </P>

<P>By default, the <I>Arguments</I> parameter is of type <B>va_list*</B>, which is a language- and implementation-specific data type for describing a variable number of arguments. If you do not have a pointer of type <B>va_list*</B>, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of 32-bit values; those values are input to the message formatted as the insert values. Each insert must have a corresponding element in the array. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is the number of bytes (ANSI version) or characters (Unicode version) stored in the output buffer, excluding the terminating null character. </P>

<P>If the function fails, the return value is zero. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Remarks</B></P>

<P>The <B>FormatMessage</B> function can be used to obtain error message strings for the system error codes returned by <B>GetLastError</B>, as shown in the following sample code. </P>

<P>LPVOID lpMsgBuf;</P>

<P></P>

<P>FormatMessage( </P>

<P>FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,</P>

<P>NULL,</P>

<P>GetLastError(),</P>

<P>MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language</P>

<P>(LPTSTR) &amp;lpMsgBuf,</P>

<P>0,</P>

<P>NULL </P>

<P>);</P>

<P>// Display the string.</P>

<P>MessageBox( NULL, lpMsgBuf, "GetLastError", MB_OK|MB_ICONINFORMATION );</P>

<P>// Free the buffer.</P>

<P>LocalFree( lpMsgBuf );</P>

<P></P>

<P>Within the message text, several escape sequences are supported for dynamically formatting the message. These escape sequences and their meanings are shown in the following table. All escape sequences start with the percent character (%). </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=33%><B>Escape Sequence</B></TD>
<TD width=67%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>%0</B></TD>
<TD width=67%>Terminates a message text line without a trailing newline character. This escape sequence can be used to build up long lines or to terminate the message itself without a trailing newline character. It is useful for prompt messages.</TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>%</B><I>n</I><B>!</B><I>printf format string</I><B>!</B></TD>
<TD width=67%>Identifies an insert. The value of <I>n</I> can be in the range 1 through 99. The <B>printf</B> format string (which must be bracketed by exclamation marks) is optional and defaults to <B>!s!</B> if not specified.</TD>
</TR>

<TR VALIGN="top">
<TD width=33%>&nbsp;</TD>
<TD width=67%>The <B>printf</B> format string can contain the * specifier for either the precision or the width component. If * is specified for one component, the <B>FormatMessage</B> function uses insert %<I>n</I>+1; it uses %<I>n</I>+2 if * is specified for both components.</TD>
</TR>

<TR VALIGN="top">
<TD width=33%>&nbsp;</TD>
<TD width=67%>Floating-point <B>printf</B> format specifiers  ¾  e, E, f, and g  ¾  are not supported. The workaround is to to use the <B>sprintf</B> function to format the floating-point number into a temporary buffer, then use that buffer as the insert string.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>Any other nondigit character following a percent character is formatted in the output message without the percent character. Following are some examples: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=22%><B>Format string</B></TD>
<TD width=78%><B>Resulting output</B></TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>%%</B></TD>
<TD width=78%>A single percent sign in the formatted message text.</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>%n</B></TD>
<TD width=78%>A hard line break when the format string occurs at the end of a line. This format string is useful when <B>FormatMessage</B> is supplying regular line breaks so the message fits in a certain width.</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>%</B><I>space</I></TD>
<TD width=78%>A space in the formatted message text. This format string can be used to ensure the appropriate number of trailing spaces in a message text line.</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>%.</B></TD>
<TD width=78%>A single period in the formatted message text. This format string can be used to include a single period at the beginning of a line without terminating the message text definition.</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>%!</B></TD>
<TD width=78%>A single exclamation point in the formatted message text. This format string can be used to include an exclamation point immediately after an insert without its being mistaken for the beginning of a <B>printf</B> format string.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="53jmqz.htm"><B>LoadString</B></A>, <A HREF="0wv2ny.htm"><B>LocalFree</B></A> </P>

</BODY>
</HTML>
