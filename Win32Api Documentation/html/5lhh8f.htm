<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Simulating Check Boxes in a Menu</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="5lhh8f"></A><B>Simulating Check Boxes in a Menu</B></P>

<P>This topic contains an example that shows how to simulate check boxes in a menu. The example contains a Character menu whose items allow the user to set the bold, italic, and underline attributes of the current font. When a font attribute is in effect, a check mark is displayed in the check box next to the corresponding menu item; otherwise, an empty check box is displayed next to the item.</P>

<P>The example replaces the default check-mark bitmap with two bitmaps: a bitmap with a checked box and the bitmap with an empty box. The checked check box bitmap is displayed next to the Bold, Italic, or Underline menu item when the item's check-mark attribute is set to MF_CHECKED. The unchecked or empty check box bitmap is displayed when the check-mark attribute is set to MF_UNCHECKED. </P>

<P>Windows provides a predefined bitmap that contains the images used for check boxes and radio buttons. The example isolates the checked and empty check boxes, copies them to two separate bitmaps, and then uses them as the checked and unchecked bitmaps for items in the Character menu.</P>

<P>To retrieve the handle of the system-defined check box bitmap, the example calls the <A HREF="a1xq1h.htm"><B>LoadBitmap</B></A> function, specifying NULL as the <I>hInstance</I> parameter and OBM_CHECKBOXES as the <I>lpBitmapName</I> parameter. Because the images in the bitmap are all the same size, the example can isolate them by dividing the bitmap's width and height by the number of images in its rows and columns. </P>

<P>The following portion of a resource-definition file shows how the menu items in the Character menu are defined. Note that no font attributes are in effect initially, so the check-mark attribute for the Regular item is set to checked and, by default, the check-mark attribute of the remaining items is set to unchecked. </P>

<P>#include "men3.h"  </P>

<P></P>

<P>MainMenu MENU </P>

<P>BEGIN </P>

<P>POPUP   "&amp;Character" </P>

<P>BEGIN </P>

<P>MENUITEM    "&amp;Regular",     IDM_REGULAR, CHECKED </P>

<P>MENUITEM SEPARATOR </P>

<P>MENUITEM    "&amp;Bold",        IDM_BOLD </P>

<P>MENUITEM    "&amp;Italic",      IDM_ITALIC </P>

<P>MENUITEM    "&amp;Underline",   IDM_ULINE </P>

<P>END </P>

<P>END </P>

<P></P>

<P>Here are the relevant contents of the application's header file. </P>

<P>// Menu-item identifiers   </P>

<P></P>

<P>#define IDM_REGULAR 0x1 </P>

<P>#define IDM_BOLD    0x2 </P>

<P>#define IDM_ITALIC  0x4 </P>

<P>#define IDM_ULINE   0x8 </P>

<P></P>

<P>// Check-mark flags  </P>

<P></P>

<P>#define CHECK   1 </P>

<P>#define UNCHECK 2 </P>

<P></P>

<P>// Font-attribute mask  </P>

<P></P>

<P>#define ATTRIBMASK 0xe </P>

<P></P>

<P>// Function prototypes  </P>

<P></P>

<P>LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM); </P>

<P>HBITMAP GetMyCheckBitmaps(UINT); </P>

<P>BYTE CheckOrUncheckMenuItem(BYTE, HMENU); </P>

<P></P>

<P>The following example shows the portions of the window procedure that create the check-mark bitmaps; set the check-mark attribute of the Bold, Italic, and Underline menu items; and destroy check-mark bitmaps. </P>

<P>LRESULT APIENTRY MainWndProc(hwndMain, uMsg, wParam, lParam)  </P>

<P>HWND hwndMain; </P>

<P>UINT uMsg; </P>

<P>WPARAM wParam; </P>

<P>LPARAM lParam; </P>

<P>{ </P>

<P></P>

<P>static HBITMAP hbmpCheck;   // handle of checked bitmap    </P>

<P>static HBITMAP hbmpUncheck; // handle of unchecked bitmap  </P>

<P>static HMENU hmenu;         // handle of main menu         </P>

<P>BYTE fbFontAttrib;          // font-attribute flags        </P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_CREATE: </P>

<P></P>

<P>// Call the application-defined GetMyCheckBitmaps </P>

<P>// function to get the predefined checked and </P>

<P>// unchecked check box bitmaps. </P>

<P></P>

<P>hbmpCheck = GetMyCheckBitmaps(CHECK); </P>

<P>hbmpUncheck = GetMyCheckBitmaps(UNCHECK); </P>

<P></P>

<P>// Set the checked and unchecked bitmaps for the menu </P>

<P>// items. </P>

<P></P>

<P>hmenu = GetMenu(hwndMain); </P>

<P>SetMenuItemBitmaps(hmenu, IDM_BOLD, MF_BYCOMMAND, </P>

<P>hbmpUncheck, hbmpCheck); </P>

<P>SetMenuItemBitmaps(hmenu, IDM_ITALIC, MF_BYCOMMAND, </P>

<P>hbmpUncheck, hbmpCheck); </P>

<P>SetMenuItemBitmaps(hmenu, IDM_ULINE, MF_BYCOMMAND, </P>

<P>hbmpUncheck, hbmpCheck); </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>case WM_COMMAND: </P>

<P>switch (LOWORD(wParam)) { </P>

<P></P>

<P>// Process the menu commands.  </P>

<P></P>

<P>case IDM_REGULAR: </P>

<P>case IDM_BOLD: </P>

<P>case IDM_ITALIC: </P>

<P>case IDM_ULINE: </P>

<P></P>

<P>// CheckOrUncheckMenuItem is an application- </P>

<P>// defined function that sets the menu item </P>

<P>// check marks and returns the user-selected </P>

<P>// font attributes. </P>

<P></P>

<P>fbFontAttrib = CheckOrUncheckMenuItem( </P>

<P>(BYTE) LOWORD(wParam), hmenu); </P>

<P></P>

<P>. </P>

<P>. // Set the font attributes.  </P>

<P>. </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>. </P>

<P>. // Process other command messages.  </P>

<P>. </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>break; </P>

<P></P>

<P>. </P>

<P>. // Process other window messages.  </P>

<P>. </P>

<P></P>

<P>case WM_DESTROY: </P>

<P></P>

<P>// Destroy the checked and unchecked bitmaps.  </P>

<P></P>

<P>DeleteObject(hbmpCheck); </P>

<P>DeleteObject(hbmpUncheck); </P>

<P></P>

<P>PostQuitMessage(0); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>return DefWindowProc(hwndMain, uMsg, wParam, lParam); </P>

<P>} </P>

<P>return NULL; </P>

<P>} </P>

<P></P>

<P>HBITMAP GetMyCheckBitmaps(fuCheck) </P>

<P>UINT fuCheck;               // CHECK or UNCHECK flag             </P>

<P>{ </P>

<P>COLORREF crBackground;  // background color                  </P>

<P>HBRUSH hbrBackground;   // background brush                  </P>

<P>HBRUSH hbrTargetOld;    // original background brush         </P>

<P>HDC hdcSource;          // source device context             </P>

<P>HDC hdcTarget;          // target device context             </P>

<P>HBITMAP hbmpCheckboxes; // handle of check-box bitmap        </P>

<P>BITMAP bmCheckbox;      // structure for bitmap data         </P>

<P>HBITMAP hbmpSourceOld;  // handle of original source bitmap  </P>

<P>HBITMAP hbmpTargetOld;  // handle of original target bitmap  </P>

<P>HBITMAP hbmpCheck;      // handle of check-mark bitmap       </P>

<P>RECT rc;                // rectangle for check-box bitmap    </P>

<P>DWORD dwCheckXY;        // dimensions of check-mark bitmap   </P>

<P>WORD wBitmapX;          // width of check-mark bitmap        </P>

<P>WORD wBitmapY;          // height of check-mark bitmap       </P>

<P></P>

<P>// Get the menu background color and create a solid brush </P>

<P>// with that color. </P>

<P></P>

<P>crBackground = GetSysColor(COLOR_MENU); </P>

<P>hbrBackground = CreateSolidBrush(crBackground); </P>

<P></P>

<P>// Create memory device contexts for the source and </P>

<P>// destination bitmaps. </P>

<P></P>

<P>hdcSource = CreateCompatibleDC((HDC) NULL); </P>

<P>hdcTarget = CreateCompatibleDC(hdcSource); </P>

<P></P>

<P>// Get the size of the Windows default check-mark bitmap and </P>

<P>// create a compatible bitmap of the same size. </P>

<P></P>

<P>dwCheckXY = GetMenuCheckMarkDimensions(); </P>

<P>wBitmapX = LOWORD(dwCheckXY); </P>

<P>wBitmapY = LOWORD(dwCheckXY); </P>

<P></P>

<P>hbmpCheck = CreateCompatibleBitmap(hdcSource, wBitmapX, </P>

<P>wBitmapY); </P>

<P></P>

<P>// Select the background brush and bitmap into the target DC. </P>

<P></P>

<P>hbrTargetOld = SelectObject(hdcTarget, hbrBackground); </P>

<P>hbmpTargetOld = SelectObject(hdcTarget, hbmpCheck); </P>

<P></P>

<P>// Use the selected brush to initialize the background color </P>

<P>// of the bitmap in the target device context. </P>

<P></P>

<P>PatBlt(hdcTarget, 0, 0, wBitmapX, wBitmapY, PATCOPY); </P>

<P></P>

<P>// Load the predefined check box bitmaps and select it </P>

<P>// into the source DC. </P>

<P></P>

<P>hbmpCheckboxes = LoadBitmap((HINSTANCE) NULL, </P>

<P>(LPTSTR) OBM_CHECKBOXES); </P>

<P></P>

<P>hbmpSourceOld = SelectObject(hdcSource, hbmpCheckboxes); </P>

<P></P>

<P>// Fill a BITMAP structure with information about the </P>

<P>// check box bitmaps, and then find the upper-left corner of </P>

<P>// the unchecked check box or the checked check box. </P>

<P></P>

<P>GetObject(hbmpCheckboxes, sizeof(BITMAP), &amp;bmCheckbox); </P>

<P></P>

<P>if (fuCheck == UNCHECK) { </P>

<P>rc.left = 0; </P>

<P>rc.right = (bmCheckbox.bmWidth / 4); </P>

<P>} </P>

<P>else { </P>

<P>rc.left = (bmCheckbox.bmWidth / 4); </P>

<P>rc.right = (bmCheckbox.bmWidth / 4) * 2; </P>

<P>} </P>

<P></P>

<P>rc.top = 0; </P>

<P>rc.bottom = (bmCheckbox.bmHeight / 3); </P>

<P></P>

<P>// Copy the appropriate bitmap into the target DC. If the </P>

<P>// check-box bitmap is larger than the default check-mark </P>

<P>// bitmap, use StretchBlt to make it fit; otherwise, just </P>

<P>// copy it. </P>

<P></P>

<P>if (((rc.right - rc.left) &gt; (int) wBitmapX) || </P>

<P>((rc.bottom - rc.top) &gt; (int) wBitmapY)) </P>

<P>StretchBlt(hdcTarget, 0, 0, wBitmapX, wBitmapY, </P>

<P>hdcSource, rc.left, rc.top, rc.right - rc.left, </P>

<P>rc.bottom - rc.top, SRCCOPY); </P>

<P></P>

<P>else </P>

<P>BitBlt(hdcTarget, 0, 0, rc.right - rc.left, </P>

<P>rc.bottom - rc.top, </P>

<P>hdcSource, rc.left, rc.top, SRCCOPY); </P>

<P></P>

<P>// Select the old source and destination bitmaps into the </P>

<P>// source and destination DCs, and then delete the DCs and </P>

<P>// the background brush. </P>

<P></P>

<P>SelectObject(hdcSource, hbmpSourceOld); </P>

<P>SelectObject(hdcTarget, hbrTargetOld); </P>

<P>hbmpCheck = SelectObject(hdcTarget, hbmpTargetOld); </P>

<P></P>

<P>DeleteObject(hbrBackground); </P>

<P>DeleteObject(hdcSource); </P>

<P>DeleteObject(hdcTarget); </P>

<P></P>

<P>// Return the handle of the new check-mark bitmap.  </P>

<P></P>

<P>return hbmpCheck; </P>

<P>} </P>

<P></P>

<P></P>

<P>BYTE CheckOrUncheckMenuItem(bMenuItemID, hmenu) </P>

<P>BYTE bMenuItemID; </P>

<P>HMENU hmenu; </P>

<P>{ </P>

<P>DWORD fdwMenu; </P>

<P>static BYTE fbAttributes; </P>

<P></P>

<P>switch (bMenuItemID) { </P>

<P>case IDM_REGULAR: </P>

<P></P>

<P>// Whenever the Regular menu item is selected, add a </P>

<P>// check mark to it and then remove check marks from </P>

<P>// any font-attribute menu items. </P>

<P></P>

<P>CheckMenuItem(hmenu, IDM_REGULAR, MF_BYCOMMAND | </P>

<P>MF_CHECKED); </P>

<P></P>

<P>if (fbAttributes &amp; ATTRIBMASK) { </P>

<P>CheckMenuItem(hmenu, IDM_BOLD, MF_BYCOMMAND | </P>

<P>MF_UNCHECKED); </P>

<P>CheckMenuItem(hmenu, IDM_ITALIC, MF_BYCOMMAND | </P>

<P>MF_UNCHECKED); </P>

<P>CheckMenuItem(hmenu, IDM_ULINE, MF_BYCOMMAND | </P>

<P>MF_UNCHECKED); </P>

<P>} </P>

<P>fbAttributes = IDM_REGULAR; </P>

<P>return fbAttributes; </P>

<P></P>

<P>case IDM_BOLD: </P>

<P>case IDM_ITALIC: </P>

<P>case IDM_ULINE: </P>

<P></P>

<P>// Toggle the check mark for the selected menu item and </P>

<P>// set the font attribute flags appropriately. </P>

<P></P>

<P>fdwMenu = GetMenuState(hmenu, (UINT) bMenuItemID, </P>

<P>MF_BYCOMMAND); </P>

<P>if (!(fdwMenu &amp; MF_CHECKED)) { </P>

<P>CheckMenuItem(hmenu, (UINT) bMenuItemID, </P>

<P>MF_BYCOMMAND | MF_CHECKED); </P>

<P>fbAttributes |= bMenuItemID; </P>

<P></P>

<P>} else { </P>

<P>CheckMenuItem(hmenu, (UINT) bMenuItemID, </P>

<P>MF_BYCOMMAND | MF_UNCHECKED); </P>

<P>fbAttributes ^= bMenuItemID; </P>

<P>} </P>

<P></P>

<P>// If any font attributes are currently selected, </P>

<P>// remove the check mark from the Regular menu item; </P>

<P>// if no attributes are selected, add a check mark </P>

<P>// to the Regular menu item. </P>

<P></P>

<P>if (fbAttributes &amp; ATTRIBMASK) { </P>

<P>CheckMenuItem(hmenu, IDM_REGULAR, </P>

<P>MF_BYCOMMAND | MF_UNCHECKED); </P>

<P>fbAttributes &amp;= (BYTE) ~IDM_REGULAR; </P>

<P></P>

<P>} else { </P>

<P>CheckMenuItem(hmenu, IDM_REGULAR, </P>

<P>MF_BYCOMMAND | MF_CHECKED); </P>

<P>fbAttributes = IDM_REGULAR; </P>

<P>} </P>

<P></P>

<P>return fbAttributes; </P>

<P>} </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
