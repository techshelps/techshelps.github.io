<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>WriteFile</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="g0sox_"></A><B>WriteFile  <A HREF="4mfn_2z.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="qnj9so.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="1f83g2.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>WriteFile</B> function writes data to a file and is designed for both synchronous and asynchronous operation. The function starts writing data to the file at the position indicated by the file pointer. After the write operation has been completed, the file pointer is adjusted by the number of bytes actually written, except when the file is opened with FILE_FLAG_OVERLAPPED. If the file handle was created for overlapped input and output (I/O), the application must adjust the position of the file pointer after the write operation is finished. </P>

<P><B>BOOL WriteFile(</B></P>

<TABLE cols=2 width=589>

<TR VALIGN="top">
<TD width=47%><B>HANDLE</B> <I>hFile</I><B>,</B></TD>
<TD width=53%>// handle to file to write to </TD>
</TR>

<TR VALIGN="top">
<TD width=47%><B>    LPCVOID</B> <I>lpBuffer</I><B>,</B></TD>
<TD width=53%>// pointer to data to write to file </TD>
</TR>

<TR VALIGN="top">
<TD width=47%><B>    DWORD</B> <I>nNumberOfBytesToWrite</I><B>,</B></TD>
<TD width=53%>// number of bytes to write </TD>
</TR>

<TR VALIGN="top">
<TD width=47%><B>    LPDWORD</B> <I>lpNumberOfBytesWritten</I><B>,</B></TD>
<TD width=53%>// pointer to number of bytes written </TD>
</TR>

<TR VALIGN="top">
<TD width=47%><B>    LPOVERLAPPED</B> <I>lpOverlapped</I> </TD>
<TD width=53%>// pointer to structure needed for overlapped I/O</TD>
</TR>

<TR VALIGN="top">
<TD width=47%><B>   );</B></TD>
<TD width=53%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hFile</I></P>

<P>Identifies the file to be written to. The file handle must have been created with GENERIC_WRITE access to the file. </P>

<P><B>Windows NT</B></P>

<P>For asynchronous write operations, <I>hFile</I> can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function, or a socket handle returned by the <B>socket</B> or <B>accept</B> functions.</P>

<P><B>Windows 95</B></P>

<P>For asynchronous write operations, <I>hFile</I> can be a communications resource, mailslot, or named pipe handle opened with the FILE_FLAG_OVERLAPPED flag by <B>CreateFile</B>, or a socket handle returned by the <B>socket</B> or <B>accept</B> functions. Windows 95 does not support asynchronous write operations on disk files.</P>

<P><I>lpBuffer</I></P>

<P>Points to the buffer containing the data to be written to the file. </P>

<P><I>nNumberOfBytesToWrite</I></P>

<P>Specifies the number of bytes to write to the file. </P>

<P>Unlike the MS-DOS operating system, Windows NT interprets a value of zero as specifying a null write operation. A null write operation does not write any bytes but does cause the time stamp to change. </P>

<P>Named pipe write operations across a network are limited to 65535 bytes.</P>

<P><I>lpNumberOfBytesWritten</I></P>

<P>Points to the number of bytes written by this function call. <B>WriteFile</B> sets this value to zero before doing any work or error checking. </P>

<P>If <I>lpOverlapped</I> is NULL, <I>lpNumberOfBytesWritten</I> cannot be NULL.</P>

<P>If <I>lpOverlapped</I> is not NULL, <I>lpNumberOfBytesWritten</I> can be NULL. If this is an overlapped write operation, you can get the number of bytes written by calling <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A>. If <I>hFile</I> is associated with an I/O completion port, you can get the number of bytes written by calling <A HREF="h734vj.htm"><B>GetQueuedCompletionStatus</B></A>.</P>

<P><I>lpOverlapped</I></P>

<P>Points to an <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure. This structure is required if <I>hFile</I> was opened with FILE_FLAG_OVERLAPPED.</P>

<P>If <I>hFile</I> was opened with FILE_FLAG_OVERLAPPED, the <I>lpOverlapped</I> parameter must not be NULL. It must point to a valid <B>OVERLAPPED</B> structure. If <I>hFile</I> was opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is NULL, the function can incorrectly report that the write operation is complete.</P>

<P>If <I>hFile</I> was opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is not NULL, the write operation starts at the offset specified in the <B>OVERLAPPED</B> structure and <B>WriteFile</B> may return before the write operation has been completed. In this case, <B>WriteFile</B> returns FALSE and the <B>GetLastError</B> function returns ERROR_IO_PENDING. This allows the calling process to continue processing while the write operation is being completed. The event specified in the <B>OVERLAPPED</B> structure is set to the signaled state upon completion of the write operation. </P>

<P>If <I>hFile</I> was not opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is NULL, the write operation starts at the current file position and <B>WriteFile</B> does not return until the operation has been completed. </P>

<P>If <I>hFile</I> was not opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is not NULL, the write operation starts at the offset specified in the <B>OVERLAPPED</B> structure and <B>WriteFile</B> does not return until the write operation has been completed. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Remarks</B></P>

<P>If part of the file is locked by another process and the write operation overlaps the locked portion, this function fails. </P>

<P>Applications must not read from nor write to the output buffer that a write operation is using until the write operation completes. Premature access of the output buffer may lead to corruption of the data written from that buffer.</P>

<P>Characters can be written to the screen buffer using <B>WriteFile</B> with a handle to console output. The exact behavior of the function is determined by the console mode. The data is written to the current cursor position. The cursor position is updated after the write operation. </P>

<P>Unlike the MS-DOS operating system, Windows NT interprets zero bytes to write as specifying a null write operation and <B>WriteFile</B> does not truncate or extend the file. To truncate or extend a file, use the <B>SetEndOfFile</B> function. </P>

<P>When writing to a nonblocking, byte-mode pipe handle with insufficient buffer space, <B>WriteFile</B> returns TRUE with <I>*lpNumberOfBytesWritten</I> &lt; <I>nNumberOfBytesToWrite</I>. </P>

<P>When an application uses the <B>WriteFile</B> function to write to a pipe, the write operation may not finish if the pipe buffer is full. The write operation is completed when a read operation (using the <B>ReadFile</B> function) makes more buffer space available. </P>

<P>If the anonymous read pipe handle has been closed and <B>WriteFile</B> attempts to write using the corresponding anonymous write pipe handle, the function returns FALSE and <A HREF="11c2vs7.htm"><B>GetLastError</B></A> returns ERROR_BROKEN_PIPE. </P>

<P>The <B>WriteFile</B> function may fail with ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY whenever there are too many outstanding asynchronous I/O requests. </P>

<P>To cancel all pending asynchronous I/O operations, use the <A HREF="62a8_h_.htm"><B>CancelIO</B></A> function. This function only cancels operations issued by the calling thread for the specified file handle. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. </P>

<P>If <I>hFile</I> is a handle to a named pipe, the <B>Offset</B> and <B>OffsetHigh</B> members of the <B>OVERLAPPED</B> structure pointed to by <I>lpOverlapped</I> must be zero, or the function will fail. </P>

<P><B>See Also</B></P>

<P><A HREF="62a8_h_.htm"><B>CancelIo</B></A>, <A HREF="xn35yd.htm"><B>CreateFile</B></A>, <A HREF="11c2vs7.htm"><B>GetLastError</B></A>, <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A>, <A HREF="h734vj.htm"><B>GetQueuedCompletionStatus</B></A>, <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A>, <A HREF="cjnd8p.htm"><B>ReadFile</B></A>, <A HREF="_p1bh3.htm"><B>SetEndOfFile</B></A>, <A HREF="12g2wey.htm"><B>WriteFileEx</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
