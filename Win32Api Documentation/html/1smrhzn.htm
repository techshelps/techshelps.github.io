<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>CryptSetKeyParam [New - Windows NT] [New - Windows 95, OEM Service Release 2]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="1smrhzn"></A><B>CryptSetKeyParam  <A HREF="99apgq.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="2jdzwvi.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="sx1q_k.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>[New - Windows 95, OEM Service Release 2]</P>

<P>The <B>CryptSetKeyParam</B> function lets applications customize various aspects of a key's operations.</P>

<P>Generally, this function is used to set session-specific parameters on symmetric keys. Note that the base keying material is not accessible by this function.</P>

<P>The Microsoft RSA Base Provider has no settable parameters on key exchange or signature keys. However, custom providers may define parameters that can be set on these keys.</P>

<P><B>BOOL CRYPTFUNC CryptSetKeyParam(</B></P>

<TABLE cols=2 width=201>

<TR VALIGN="top">
<TD width=83%><B>HCRYPTKEY </B><I>hKey</I><B>,</B></TD>
<TD width=17%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=83%><B>    DWORD </B><I>dwParam</I><B>,</B></TD>
<TD width=17%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=83%><B>    BYTE *</B><I>pbData</I><B>,</B></TD>
<TD width=17%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=83%><B>    DWORD </B><I>dwFlags</I></TD>
<TD width=17%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=83%><B>   );</B></TD>
<TD width=17%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hKey</I></P>

<P>[in] A handle to the key on which to set parameters.</P>

<P><I>dwParam</I></P>

<P>[in] The parameter number. See the "Remarks" section for a list of valid parameters.</P>

<P><I>pbData</I></P>

<P>[in] The parameter data buffer. Place the parameter data in this buffer before calling <B>CryptSetKeyParam</B>. The form of this data will vary, depending on the parameter number.</P>

<P><I>dwFlags</I></P>

<P>[in] The flag values. This parameter is reserved for future use and should always be zero.</P>

<P></P>

<P><B>Remarks</B></P>

<P>For all session key types, the <I>dwParam</I> value can be set to one of the following key parameter types;</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=31%><B>Parameter</B></TD>
<TD width=69%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=31%>KP_SALT</TD>
<TD width=69%>The salt value. The <I>pbData</I> buffer should contain a <B>BYTE</B> array specifying a new salt value. This value is made part of the session key. The size of the salt value will vary depending on the CSP being used so, before setting this parameter, it should be read using <B>CryptGetKeyParam</B> in order to determine its size.
<P>When it is suspected that the base data used for derived keys is less than ideal, salt values are often used to make the session keys more unique. This makes dictionary attacks more difficult.</P>

<P>When using the Microsoft RSA Base Provider, this parameter defaults to zero.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>KP_PERMISSIONS</TD>
<TD width=69%>The key permissions flags. The <I>pbData</I> buffer should contain a <B>DWORD</B> value specifying zero or more permission flags. Refer to the <A HREF="bu8pdf.htm"><B>CryptGetKeyParam</B></A> function for a description of these flags.
<P>When using the Microsoft RSA Base Provider, this parameter defaults to 0xFFFFFFFF.</P>
</TD>
</TR>
</TABLE><BR>

<P></P>

<P>If a block cipher session key is specified by <I>hKey</I>, the <I>dwParam</I> value can also be set to one of the following parameter types.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=31%><B>Parameter</B></TD>
<TD width=69%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=31%>KP_IV</TD>
<TD width=69%>The initialization vector. The <I>pbData</I> buffer should contain a <B>BYTE</B> array specifying the initialization vector. This array should contain &lt;<I>block length</I>&gt;/8 elements. For example, if the block length is 64 bits, the initialization vector will consist of 8 bytes.
<P>When using the Microsoft RSA Base Provider, this parameter defaults to zero.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>KP_PADDING</TD>
<TD width=69%>The padding mode. The <I>pbData</I> buffer should contain a <B>DWORD</B> value specifying the padding method to be used by the cipher. Following are the padding modes currently defined:
<P>PKCS5_PADDING ¾ PKCS 5 (sec 6.2) padding method.</P>

<P>When using the Microsoft RSA Base Provider, this parameter defaults to PKCS5_PADDING.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>KP_MODE</TD>
<TD width=69%>The cipher mode. The <I>pbData</I> buffer should contain a <B>DWORD</B> value specifying the cipher mode to be used. Refer to the <A HREF="bu8pdf.htm"><B>CryptGetKeyParam</B></A> function for a list
<P>of the defined cipher modes.</P>

<P>When using the Microsoft RSA Base Provider, this parameter defaults to CRYPT_MODE_CBC.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>KP_MODE_BITS</TD>
<TD width=69%>The number of bits to feed back. The <I>pbData</I> buffer contains a <B>DWORD</B> value indicating the number of bits that are processed per cycle when the OFB or CFB cipher modes are used.
<P>When using the Microsoft RSA Base Provider, this parameter defaults to 8.</P>
</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To retrieve extended error information, use the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function.</P>

<P>The following table lists the error codes most commonly returned by the <B>GetLastError</B> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=47%><B>Error</B></TD>
<TD width=53%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_HANDLE</TD>
<TD width=53%>One of the parameters specifies an invalid handle. </TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_BUSY</TD>
<TD width=53%>The CSP context is currently being used by another process.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_PARAMETER</TD>
<TD width=53%>One of the parameters contains an invalid value. This is most often an illegal pointer.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_FLAGS</TD>
<TD width=53%>The <I>dwFlags</I> parameter is nonzero or the <I>pbData</I> buffer contains an invalid value.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_TYPE</TD>
<TD width=53%>The <I>dwParam</I> parameter specifies an unknown parameter.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_UID</TD>
<TD width=53%>The CSP context that was specified when the <I>hKey</I> key was created cannot be found.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_FAIL</TD>
<TD width=53%>The function failed in some unexpected way.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Example</B></P>

<P>#include &lt;wincrypt.h&gt;</P>

<P></P>

<P>HCRYPTPROV hProv = 0;</P>

<P>HCRYPTKEY hKey = 0;</P>

<P>DWORD dwMode;</P>

<P>BYTE pbData[16];</P>

<P>DWORD dwCount;</P>

<P>DWORD i;</P>

<P>// Get handle to user default provider.</P>

<P>if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {</P>

<P>printf("Error %x during CryptAcquireContext!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Create random block cipher session key.</P>

<P>if(!CryptGenKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &amp;hKey)) {</P>

<P>printf("Error %x during CryptGenKey!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Set the cipher mode.</P>

<P>dwMode = CRYPT_MODE_ECB;</P>

<P>if(!CryptSetKeyParam(hKey, KP_MODE, &amp;dwMode, 0)) {</P>

<P>printf("Error %x during CryptSetKeyParam!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Generate random initialization vector.</P>

<P>if(!CryptGenRandom(hProv, 8, pbData)) {</P>

<P>printf("Error %x during CryptGenRandom!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Set initialization vector.</P>

<P>if(!CryptSetKeyParam(hKey, KP_IV, pbData, 0)) {</P>

<P>printf("Error %x during CryptGetKeyParam!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Do something with 'hKey'.</P>

<P>...</P>

<P>done:</P>

<P>// Destroy session key.</P>

<P>if(hKey != 0) CryptDestroyKey(hKey);</P>

<P>// Release provider handle.</P>

<P>if(hProv != 0) CryptReleaseContext(hProv, 0);</P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="dnbayj.htm"><B>CryptGenKey</B></A>, <A HREF="bu8pdf.htm"><B>CryptGetKeyParam</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
