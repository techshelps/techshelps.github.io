<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Cipher Modes</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="ydyzp1"></A><B>Cipher Modes</B></P>

<P>When a block cipher is used, any one of the following cipher modes can be specified via the <A HREF="1smrhzn.htm"><B>CryptSetKeyParam</B></A> function. If the application does not explicitly specify one of these modes, then the cipher block chaining (CBC) cipher mode is used.</P>

<P><A NAME="1d6n_iu"></A><B>Electronic Codebook (ECB)</B></P>

<P>When this cipher mode is used, each block is encrypted individually. No feedback is used. This means any blocks of plaintext that are identical and are either in the same message, or in a different message that is encrypted with the same key, will be transformed into identical ciphertext blocks.</P>

<P>If the plaintext to be encrypted contains substantial repetition, then it is feasible for the ciphertext to be broken one block at a time. Furthermore, it is possible for an unscrupulous person to substitute and exchange individual blocks without detection. </P>

<P>Initialization vectors cannot be used with this cipher mode.</P>

<P>If a single bit of the ciphertext block is garbled, then the entire corresponding plaintext block will also be garbled.</P>

<P><A NAME="dobc_s"></A><B>Cipher Block Chaining (CBC)</B></P>

<P>This cipher mode introduces feedback. Before each plaintext block is encrypted, it is XOR'ed with the ciphertext of the previous block. This ensures that even if the plaintext contains many identical blocks, they will each encrypt to a different ciphertext block.</P>

<P>The initialization vector is XOR'ed with the first plaintext block before the block is encrypted.</P>

<P>As with the Codebook cipher mode, if a single bit of the ciphertext block is garbled, then the corresponding plaintext block will also be garbled. In addition, a bit in the subsequent plaintext block (in the same position as the original garbled bit) will be garbled. Synchronization errors are fatal. If there are extra or missing bytes in the ciphertext, the plaintext will be garbled from that point on.</P>

<P>When the Microsoft RSA Base Provider is used, this is the default cipher mode.</P>

<P><A NAME="au7x3y"></A><B>Cipher Feedback Mode (CFB)</B></P>

<P>The cipher feedback mode lets you process small increments of plaintext into ciphertext, instead of processing an entire block at a time. This can be is useful, for example, when encrypting a stream of data that originates at a keyboard. Each keystroke can be encrypted and transmitted without the need to wait for an entire block to be typed.</P>

<P>This mode uses a shift register which is one block size in length and divided up into sections. For example, if the block size is 64 bits with 8 bits processed at a time, then the shift register would be divided up into 8 sections.</P>

<P>This is the procedure for each encryption cycle:</P>

<P>1.The block in the shift register is encrypted normally.</P>

<P>2.The leftmost 8 bits in the encrypted shift register are XOR'ed with the next 8 bits of plaintext and sent off as 8 bits of ciphertext.</P>

<P>3.The shift register is shifted 8 bits to the left.</P>

<P>4.The 8 bits of ciphertext generated in step 2 is placed in the rightmost 8 bits of the shift register.</P>

<P></P>

<P>In CryptoAPI, the number of bits processed at one time is specified by setting the encryption key's KP_MODE_BITS parameter using the <A HREF="1smrhzn.htm"><B>CryptSetKeyParam</B></A> function. This parameter typically defaults to 8.</P>

<P>Depending on the value of the KP_MODE_BITS parameter, this cipher mode is substantially slower than the Cipher Block Chaining mode. For example, if the block size is 64 bits with 8 bits are processed at a time, this cipher mode is 64/8 or 8 times slower.</P>

<P>Before the encryption process begins, the shift register is filled with the initialization vector.</P>

<P>If a bit in the cipher text is garbled, one plaintext bit is garbled and the shift register is corrupted. This results in the next several plaintext blocks being garbled until the bad bit is shifted out of the shift register. In the preceding example, 9 bytes of plaintext would be garbled. This is the same amount of error propagation as with the Cipher Block Chaining mode. Synchronization errors are not fatal, provided that the slip is a multiple of KP_MODE_BITS. Thus, if KP_MODE_BITS is 8 and there are extra or missing bytes from the ciphertext, then 9 bytes of plaintext are garbled and the plaintext will have the same number of extra or missing bytes.</P>

<P><A NAME="hjrhvk"></A><B>Output Feedback Mode (OFB)</B></P>

<P>This mode is similar to the cipher feedback mode. The only difference between the two modes is how the shift register is filled.</P>

<P>The output feedback (OFB) cipher mode uses the following encryption cycle:</P>

<P>1.The block in the shift register is encrypted normally.</P>

<P>2.The leftmost 8 bits in the encrypted shift register are XOR'ed with the next 8 bits of plaintext and sent off as 8 bits of ciphertext.</P>

<P>3.The shift register is shifted 8 bits to the left.</P>

<P>4.The leftmost 8 bits of the encrypted shift register used in step 2 is placed in the rightmost 8 bits of the shift register.</P>

<P></P>

<P>As with the Cipher Feedback mode, the shift register is filled with the initialization vector before the encryption process starts.</P>

<P>If a bit in the cipher text is garbled, the corresponding bit of plaintext will also be garbled. This is much better than the Cipher Feedback mode. However, synchronization errors are fatal. If there are extra or missing bits from the ciphertext, then the plaintext will be garbled from that point on.</P>

<P></P>

<P><B>Note</B>  According to Gait (see reference below), the OFB block cipher mode has a weakness when the number of bits fed back is different than the block size. It is thus recommended that the KP_MODE_BITS parameter be set to the block size when this cipher mode is used.</P>

<P>*J. Gait, "A New Nonlinear Pseudorandom Number Generator," <I>IEEE Transactions on Software Engineering</I>, v. SE-3, n. 5, Sep 1977, pp. 359-363.</P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
