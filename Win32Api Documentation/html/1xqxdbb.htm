<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Synchronous and Overlapped Input and Output</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="1xqxdbb"></A><B>Synchronous and Overlapped Input and Output</B></P>

<P>The <A HREF="cjnd8p.htm"><B>ReadFile</B></A>, <A HREF="g0sox_.htm"><B>WriteFile</B></A>, <A HREF="1nuxhmk.htm"><B>TransactNamedPipe</B></A>, and <A HREF="ksa3sm.htm"><B>ConnectNamedPipe</B></A> functions can run either synchronously or asynchronously. The <A HREF="fm7wz7.htm"><B>ReadFileEx</B></A> and <A HREF="12g2wey.htm"><B>WriteFileEx</B></A> functions can run only asynchronously. When functions run synchronously, they do not return until the operation is finished. This means that the execution of the calling thread can be blocked for an indefinite period while it waits for a time-consuming operation to finish. When functions run asynchronously, they return immediately even before their operations are finished. This enables a time-consuming operation to be executed in the background while the calling thread is free to perform other tasks. </P>

<P>Overlapped operations make it possible for one pipe to read and write data simultaneously and for a single thread to perform simultaneous I/O operations on multiple pipe handles. This enables a single-threaded server process to handle communications with multiple client processes efficiently. For examples that illustrate overlapped operations by a server process, see <A HREF="14dmkd8.htm">Server Using Overlapped Input and Output</A> and <A HREF="ii73px.htm">Server Using Completion Routines</A>. </P>

<P>For a server process to use synchronous operations to communicate with more than one client, it must create a separate thread for each client process so that one or more threads can run while other threads are waiting. For an example of a multithreaded server process that uses synchronous operations, see <A HREF="bvxy8p.htm">Multithreaded Server</A>. </P>

<P>Overlapped operations on a named pipe are enabled by specifying the FILE_FLAG_OVERLAPPED flag when the handle is created (by the <A HREF="21dzyt.htm"><B>CreateNamedPipe</B></A> function for a server process or the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function for a client process). If this flag is not specified, overlapped mode is disabled. The overlapped mode of a pipe handle cannot be changed after the pipe handle has been created. The overlapped mode can be different for server and client handles to the same pipe instance. </P>

<P>The <A HREF="cjnd8p.htm"><B>ReadFile</B></A>, <A HREF="g0sox_.htm"><B>WriteFile</B></A>, <A HREF="1nuxhmk.htm"><B>TransactNamedPipe</B></A>, and <A HREF="ksa3sm.htm"><B>ConnectNamedPipe</B></A> functions can be performed asynchronously only if overlapped mode is enabled for the specified pipe handle and a valid pointer to an <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure is specified. If the <B>OVERLAPPED</B> pointer is NULL, the function return value may incorrectly indicate that the operation completed. Therefore, it is strongly recommended that if you create a handle with FILE_FLAG_OVERLAPPED and want asynchronous behavior, you should always specify a valid OVERLAPPED structure or use the functions intended for asynchronous operations such as <A HREF="fm7wz7.htm"><B>ReadFileEx</B></A> and <A HREF="12g2wey.htm"><B>WriteFileEx</B></A>. </P>

<P>When <B>ReadFile</B>, <B>WriteFile</B>, <B>TransactNamedPipe</B>, and <B>ConnectNamedPipe</B> are performed asynchronously, one of the following outcomes occurs: </P>

<P>·If the operation is complete when the function returns, the return value indicates the success or failure of the operation. If an error occurs, the return value is FALSE and the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function returns something other than ERROR_IO_PENDING. </P>

<P>·If the operation has not finished when the function returns, the return value is FALSE and <B>GetLastError</B> returns ERROR_IO_PENDING. In this case, the calling thread must wait until the operation has finished. The calling thread must then call the <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A> function to determine the results. </P>

<P></P>

<P>The <I>hEvent</I> member of the specified <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure must contain a handle to a manual-reset ¾ not an auto-reset ¾ event object. This is a synchronization object created by the <A HREF="j_zbjv.htm"><B>CreateEvent</B></A> function. The thread that initiates the overlapped operation uses the event object to determine when the operation is finished. For more information about event objects, see <A HREF="36dp5f5.htm">Synchronization</A>. </P>

<P>An event object is either in a signaled or nonsignaled state. If an overlapped function returns before its operation has finished, the system sets the state of the event object to nonsignaled. When the operation is finished, the system sets the state to signaled. The thread can detect the object's state by specifying a handle to the event object in a call to one of the <A HREF="y2tc_3.htm">wait functions</A>. These functions do not return until the state of a specified object is signaled or until a time-out interval has elapsed. For the wait functions that wait for multiple objects, the function's return value indicates which of the objects is signaled. Doing this enables a server process to use a loop that performs the following steps: </P>

<P>1.Specify multiple event objects in a call to the wait function, then wait for one of the objects to be in a signaled state. </P>

<P>2.Use the wait function's return value to determine which overlapped operation is finished. </P>

<P>3.Perform the tasks necessary to clean up the completed operation and initiate the next operation for that pipe handle. This may involve starting another overlapped operation for the same pipe handle. </P>

<P></P>

<P>If the <I>hEvent</I> member of the <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure is a NULL pointer instead of a handle to an event object, the calling thread can use the pipe handle to determine when an overlapped operation has finished. In this case, the system sets the state of the pipe handle to signaled or nonsignaled, as described previously for the state of an event object. It is strongly recommended that you always use an event object when performing overlapped operations rather than relying on the pipe handle. In particular, you should not use the pipe handle for this purpose when performing simultaneous operations on the same handle because there is no way of knowing which operation's completion caused the pipe handle to be signaled. The only safe technique for performing simultaneous operations on the same pipe handle is to use a separate <B>OVERLAPPED</B> structure with its own event object for each operation. </P>

<P>The <A HREF="fm7wz7.htm"><B>ReadFileEx</B></A> and <A HREF="12g2wey.htm"><B>WriteFileEx</B></A> functions provide another form of overlapped I/O. Unlike the overlapped <A HREF="cjnd8p.htm"><B>ReadFile</B></A> and <A HREF="g0sox_.htm"><B>WriteFile</B></A> functions, which use an event object to signal completion, the extended functions specify a <I>completion routine</I>. A completion routine is a function that is queued for execution when the read or write operation is finished. The completion routine is not executed until the thread that called <B>ReadFileEx</B> and <B>WriteFileEx</B> enters an <I>alertable wait</I> by calling one of the alertable wait functions: <A HREF="14gl8uz.htm"><B>MsgWaitForMultipleObjectsEx</B></A>. <A HREF="14gl8uz.htm"><B>SignalObjectAndWait</B></A>, <A HREF="aqe6qk.htm"><B>WaitForSingleObjectEx</B></A>, or <A HREF="1xsv84l.htm"><B>WaitForMultipleObjectsEx</B></A>. These functions are like the normal wait functions in that they return when a specified object is in the signaled state or when a time-out interval has elapsed. However, these functions can also perform an alertable wait that occurs when their <I>fAlertable</I> parameter is set to TRUE. In an alertable wait, the functions also return when a <B>ReadFileEx</B> or <B>WriteFileEx</B> completion routine is queued for execution. A server process can use the extended functions to perform a sequence of read and write operations for each client that connects to it. Each read or write operation in the sequence specifies a completion routine, and each completion routine initiates the next step in the sequence. </P>

</BODY>
</HTML>
