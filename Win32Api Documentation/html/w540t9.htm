<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>EnumDependentServices</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="w540t9"></A><B>EnumDependentServices  <A HREF="zgo1xf.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="12c8zrk.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="we4jtq.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>EnumDependentServices</B> function enumerates services that depend on another specified service; that is, the specified service must be running before the enumerated services can run. The name and status of each dependent service are provided. </P>

<P><B>BOOL EnumDependentServices(</B></P>

<TABLE cols=2 width=573>

<TR VALIGN="top">
<TD width=52%><B>SC_HANDLE</B> <I>hService</I><B>,</B></TD>
<TD width=48%>// handle to service </TD>
</TR>

<TR VALIGN="top">
<TD width=52%><B>    DWORD</B> <I>dwServiceState</I><B>,</B></TD>
<TD width=48%>// state of services to enumerate </TD>
</TR>

<TR VALIGN="top">
<TD width=52%><B>    LPENUM_SERVICE_STATUS</B> <I>lpServices</I><B>,</B></TD>
<TD width=48%>// pointer to service status buffer </TD>
</TR>

<TR VALIGN="top">
<TD width=52%><B>    DWORD</B> <I>cbBufSize</I><B>,</B></TD>
<TD width=48%>// size of service status buffer </TD>
</TR>

<TR VALIGN="top">
<TD width=52%><B>    LPDWORD</B> <I>pcbBytesNeeded</I><B>,</B></TD>
<TD width=48%>// pointer to variable for bytes needed </TD>
</TR>

<TR VALIGN="top">
<TD width=52%><B>    LPDWORD</B> <I>lpServicesReturned</I> </TD>
<TD width=48%>// pointer to variable for number returned </TD>
</TR>

<TR VALIGN="top">
<TD width=52%><B>   );</B></TD>
<TD width=48%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hService</I></P>

<P>Handle that identifies the service. This handle is returned by the <A HREF="20gsky6.htm"><B>OpenService</B></A> or <A HREF="2wng26.htm"><B>CreateService</B></A> function, and it must have SERVICE_ENUMERATE_DEPENDENTS access. </P>

<P><I>dwServiceState</I></P>

<P>Specifies the services to enumerate based on their running state. It must be one or both of the following values: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=34%><B>Value</B></TD>
<TD width=66%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=34%>SERVICE_ACTIVE</TD>
<TD width=66%>Enumerates services that are in the following states: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING, SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.</TD>
</TR>

<TR VALIGN="top">
<TD width=34%>SERVICE_INACTIVE</TD>
<TD width=66%>Enumerates services that are in the SERVICE_STOPPED state.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><I>lpServices</I></P>

<P>Pointer to an array of <A HREF="a9asqv.htm"><B>ENUM_SERVICE_STATUS</B></A> structures. Each structure receives name and service status information for a dependent service. The order of the services in this array is the reverse of the start order of the services. In other words, the first dependent service in the array is the one that would be started last, and the last service in the array is the one that would be started first. </P>

<P><I>cbBufSize</I></P>

<P>Specifies the size, in bytes, of the buffer pointed to by the <I>lpServices</I> parameter. </P>

<P><I>pcbBytesNeeded</I></P>

<P>Pointer to a variable that receives the number of bytes needed to store the array of service entries. The variable only receives this value if the buffer pointed to by <I>lpServices</I> is too small, indicated by function failure and the ERROR_MORE_DATA error; otherwise, the contents of *<I>pcbBytesNeeded</I> are undefined.</P>

<P><I>lpServicesReturned</I></P>

<P>Pointer to a variable that receives the number of service entries returned. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Errors</B></P>

<P>The following error codes may be set by the service control manager. Other error codes may be set by the registry functions that are called by the service control manager. </P>

<TABLE cols=6>

<TR VALIGN="top">
<TD colspan=2 width=11%><B>Value</B></TD>
<TD colspan=3 width=76%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=12%>ERROR_ACCESS_DENIED</TD>
<TD colspan=3 width=88%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>&nbsp;</TD>
<TD colspan=3 width=66%>The specified handle was not opened with SERVICE_ENUMERATE_DEPENDENTS access.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=12%>ERROR_INVALID_HANDLE</TD>
<TD colspan=3 width=88%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>&nbsp;</TD>
<TD colspan=3 width=66%>The specified handle is invalid.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=12%>ERROR_INVALID_PARAMETER</TD>
<TD colspan=3 width=88%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>&nbsp;</TD>
<TD colspan=3 width=66%>A parameter that was specified is invalid.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=12%>ERROR_MORE_DATA</TD>
<TD colspan=3 width=88%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>&nbsp;</TD>
<TD colspan=3 width=66%>The buffer pointed to by <I>lpServices</I> is not large enough. The function sets the variable pointed to by <I>lpServicesReturned</I> to the actual number of service entries stored into the buffer. The function sets the variable pointed to by <I>pcbBytesNeeded</I> to the number of bytes required to store all of the service entries.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Remarks</B></P>

<P>The returned services entries are ordered in the reverse order of the start order, with group order taken into account. If you need to stop the dependent services, you can use the order of entries written to the <I>lpServices</I> buffer to stop the dependent services in the proper order. </P>

<P><B>See Also</B></P>

<P><A HREF="2wng26.htm"><B>CreateService</B></A>, <A HREF="a9asqv.htm"><B>ENUM_SERVICE_STATUS</B></A>, <A HREF="y21_8w.htm"><B>EnumServicesStatus</B></A>, <A HREF="20gsky6.htm"><B>OpenService</B></A> </P>

<P></P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
