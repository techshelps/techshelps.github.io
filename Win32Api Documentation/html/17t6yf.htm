<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Monitoring System Events</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="17t6yf"></A><B>Monitoring System Events</B></P>

<P>The following example uses a variety of thread-specific hook procedures to monitor the system for events affecting a thread. It demonstrates how to process events for the following types of hook procedures: </P>

<P>WH_CALLWNDPROC<BR>
WH_CBT<BR>
WH_DEBUG<BR>
WH_GETMESSAGE<BR>
WH_KEYBOARD<BR>
WH_MOUSE<BR>
WH_MSGFILTER</P>

<P>The user can install and remove a hook procedure by using the menu. When a hook procedure is installed and an event that is monitored by the procedure occurs, the procedure writes information about the event to the client area of the application's main window. </P>

<P>#define NUMHOOKS 7  </P>

<P></P>

<P>// Global variables </P>

<P></P>

<P>typedef struct _MYHOOKDATA </P>

<P>{ </P>

<P>int nType; </P>

<P>HOOKPROC hkprc; </P>

<P>HHOOK hhook; </P>

<P>} MYHOOKDATA; </P>

<P></P>

<P>MYHOOKDATA myhookdata[NUMHOOKS]; </P>

<P></P>

<P>LRESULT WINAPI MainWndProc(HWND hwndMain, UINT uMsg, WPARAM wParam, </P>

<P>LPARAM lParam) </P>

<P>{ </P>

<P>static BOOL afHooks[NUMHOOKS]; </P>

<P>int index; </P>

<P>static HMENU hmenu; </P>

<P></P>

<P>switch (uMsg) </P>

<P>{ </P>

<P>case WM_CREATE: </P>

<P></P>

<P>// Save the menu handle. </P>

<P></P>

<P>hmenu = GetMenu(hwndMain); </P>

<P></P>

<P>// Initialize structures with hook data. The menu-item </P>

<P>// identifiers are defined as 0 through 6 in the </P>

<P>// header file. They can be used to identify array </P>

<P>// elements both here and during the WM_COMMAND </P>

<P>// message. </P>

<P></P>

<P>myhookdata[IDM_CALLWNDPROC].nType = WH_CALLWNDPROC; </P>

<P>myhookdata[IDM_CALLWNDPROC].hkprc = CallWndProc; </P>

<P>myhookdata[IDM_CBT].nType = WH_CBT; </P>

<P>myhookdata[IDM_CBT].hkprc = CBTProc; </P>

<P>myhookdata[IDM_DEBUG].nType = WH_DEBUG; </P>

<P>myhookdata[IDM_DEBUG].hkprc = DebugProc; </P>

<P>myhookdata[IDM_GETMESSAGE].nType = WH_GETMESSAGE; </P>

<P>myhookdata[IDM_GETMESSAGE].hkprc = GetMsgProc; </P>

<P>myhookdata[IDM_KEYBOARD].nType = WH_KEYBOARD; </P>

<P>myhookdata[IDM_KEYBOARD].hkprc = KeyboardProc; </P>

<P>myhookdata[IDM_MOUSE].nType = WH_MOUSE; </P>

<P>myhookdata[IDM_MOUSE].hkprc = MouseProc; </P>

<P>myhookdata[IDM_MSGFILTER].nType = WH_MSGFILTER; </P>

<P>myhookdata[IDM_MSGFILTER].hkprc = MessageProc; </P>

<P></P>

<P>// Initialize all flags in the array to FALSE. </P>

<P></P>

<P>memset(afHooks, FALSE, sizeof(afHooks)); </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>case WM_COMMAND: </P>

<P>switch (LOWORD(wParam)) </P>

<P>{ </P>

<P>// The user selected a hook command from the menu. </P>

<P></P>

<P>case IDM_CALLWNDPROC: </P>

<P>case IDM_CBT: </P>

<P>case IDM_DEBUG: </P>

<P>case IDM_GETMESSAGE: </P>

<P>case IDM_KEYBOARD: </P>

<P>case IDM_MOUSE: </P>

<P>case IDM_MSGFILTER: </P>

<P></P>

<P>// Use the menu-item identifier as an index </P>

<P>// into the array of structures with hook data. </P>

<P></P>

<P>index = LOWORD(wParam); </P>

<P></P>

<P>// If the selected type of hook procedure isn't </P>

<P>// installed yet, install it and check the </P>

<P>// associated menu item. </P>

<P></P>

<P>if (!afHooks[index]) </P>

<P>{ </P>

<P>myhookdata[index].hhook = SetWindowsHookEx( </P>

<P>myhookdata[index].nType, </P>

<P>myhookdata[index].hkprc, </P>

<P>(HINSTANCE) NULL, GetCurrentThreadId()); </P>

<P>CheckMenuItem(hmenu, index, </P>

<P>MF_BYCOMMAND | MF_CHECKED); </P>

<P>afHooks[index] = TRUE; </P>

<P>} </P>

<P></P>

<P>// If the selected type of hook procedure is </P>

<P>// already installed, remove it and remove the </P>

<P>// check mark from the associated menu item. </P>

<P></P>

<P>else </P>

<P>{ </P>

<P>UnhookWindowsHookEx(myhookdata[index].hhook); </P>

<P>CheckMenuItem(hmenu, index, </P>

<P>MF_BYCOMMAND | MF_UNCHECKED); </P>

<P>afHooks[index] = FALSE; </P>

<P>} </P>

<P></P>

<P>default: </P>

<P>return (DefWindowProc(hwndMain, uMsg, wParam, </P>

<P>lParam)); </P>

<P>} </P>

<P>break; </P>

<P></P>

<P>//</P>

<P>// Process other messages. </P>

<P>//</P>

<P></P>

<P>default: </P>

<P>return DefWindowProc(hwndMain, uMsg, wParam, lParam); </P>

<P>} </P>

<P>return NULL; </P>

<P>} </P>

<P></P>

<P>/**************************************************************** </P>

<P>WH_CALLWNDPROC hook procedure </P>

<P>****************************************************************/ </P>

<P></P>

<P>LRESULT WINAPI CallWndProc(int nCode, WPARAM wParam, LPARAM lParam) </P>

<P>{ </P>

<P>CHAR szCWPBuf[256]; </P>

<P>CHAR szMsg[16]; </P>

<P>HDC hdc; </P>

<P>static int c = 0; </P>

<P>int cch; </P>

<P></P>

<P>if (nCode &lt; 0)  // do not process message </P>

<P>return CallNextHookEx(myhookdata[CALLWNDPROC].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P></P>

<P>// Call an application-defined function that converts a message </P>

<P>// constant to a string and copies it to a buffer. </P>

<P></P>

<P>LookUpTheMessage((PMSG) lParam, szMsg); </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P></P>

<P>switch (nCode) </P>

<P>{ </P>

<P>case HC_ACTION: </P>

<P>cch = wsprintf(szCWPBuf, </P>

<P>"CALLWNDPROC - tsk: %ld, msg: %s, %d times   ", </P>

<P>wParam, szMsg, c++); </P>

<P>TextOut(hdc, 2, 15, szCWPBuf, cch); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>return CallNextHookEx(myhookdata[CALLWNDPROC].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P>} </P>

<P></P>

<P>/**************************************************************** </P>

<P>WH_GETMESSAGE hook procedure </P>

<P>****************************************************************/ </P>

<P></P>

<P>LRESULT CALLBACK GetMsgProc(int nCode, WPARAM wParam, LPARAM lParam) </P>

<P>{ </P>

<P>CHAR szMSGBuf[256]; </P>

<P>CHAR szRem[16]; </P>

<P>CHAR szMsg[16]; </P>

<P>HDC hdc; </P>

<P>static int c = 0; </P>

<P>int cch; </P>

<P></P>

<P>if (nCode &lt; 0) // do not process message </P>

<P>return CallNextHookEx(myhookdata[GETMESSAGE].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P></P>

<P>switch (nCode) </P>

<P>{ </P>

<P>case HC_ACTION: </P>

<P>switch (wParam) </P>

<P>{ </P>

<P>case PM_REMOVE: </P>

<P>lstrcpy(szRem, "PM_REMOVE"); </P>

<P>break; </P>

<P></P>

<P>case PM_NOREMOVE: </P>

<P>lstrcpy(szRem, "PM_NOREMOVE"); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>lstrcpy(szRem, "Unknown"); </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>// Call an application-defined function that converts a </P>

<P>// message constant to a string and copies it to a </P>

<P>// buffer. </P>

<P></P>

<P>LookUpTheMessage((PMSG) lParam, szMsg); </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>cch = wsprintf(szMSGBuf, </P>

<P>"GETMESSAGE - wParam: %s, msg: %s, %d times   ", </P>

<P>szRem, szMsg, c++); </P>

<P>TextOut(hdc, 2, 35, szMSGBuf, cch); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>return CallNextHookEx(myhookdata[GETMESSAGE].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P>} </P>

<P></P>

<P>/**************************************************************** </P>

<P>WH_DEBUG hook procedure </P>

<P>****************************************************************/ </P>

<P></P>

<P>LRESULT CALLBACK DebugProc(int nCode, WPARAM wParam, LPARAM lParam) </P>

<P>{ </P>

<P>CHAR szBuf[128]; </P>

<P>HDC hdc; </P>

<P>static int c = 0; </P>

<P>int cch; </P>

<P></P>

<P>if (nCode &lt; 0)  // do not process message </P>

<P>return CallNextHookEx(myhookdata[DEBUG].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P></P>

<P>switch (nCode) </P>

<P>{ </P>

<P>case HC_ACTION: </P>

<P>cch = wsprintf(szBuf, </P>

<P>"DEBUG - nCode: %d, tsk: %ld, %d times   ", </P>

<P>nCode,wParam, c++); </P>

<P>TextOut(hdc, 2, 55, szBuf, cch); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>return CallNextHookEx(myhookdata[DEBUG].hhook, nCode, wParam, </P>

<P>lParam); </P>

<P>} </P>

<P></P>

<P>/**************************************************************** </P>

<P>WH_CBT hook procedure </P>

<P>****************************************************************/ </P>

<P></P>

<P>LRESULT CALLBACK CBTProc(int nCode, WPARAM wParam, LPARAM lParam) </P>

<P>{ </P>

<P>CHAR szBuf[128]; </P>

<P>CHAR szCode[128]; </P>

<P>HDC hdc; </P>

<P>static int c = 0; </P>

<P>int cch; </P>

<P></P>

<P>if (nCode &lt; 0)  // do not process message </P>

<P>return CallNextHookEx(myhookdata[CBT].hhook, nCode, wParam, </P>

<P>lParam); </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P></P>

<P>switch (nCode) </P>

<P>{ </P>

<P>case HCBT_ACTIVATE: </P>

<P>lstrcpy(szCode, "HCBT_ACTIVATE"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_CLICKSKIPPED: </P>

<P>lstrcpy(szCode, "HCBT_CLICKSKIPPED"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_CREATEWND: </P>

<P>lstrcpy(szCode, "HCBT_CREATEWND"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_DESTROYWND: </P>

<P>lstrcpy(szCode, "HCBT_DESTROYWND"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_KEYSKIPPED: </P>

<P>lstrcpy(szCode, "HCBT_KEYSKIPPED"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_MINMAX: </P>

<P>lstrcpy(szCode, "HCBT_MINMAX"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_MOVESIZE: </P>

<P>lstrcpy(szCode, "HCBT_MOVESIZE"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_QS: </P>

<P>lstrcpy(szCode, "HCBT_QS"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_SETFOCUS: </P>

<P>lstrcpy(szCode, "HCBT_SETFOCUS"); </P>

<P>break; </P>

<P></P>

<P>case HCBT_SYSCOMMAND: </P>

<P>lstrcpy(szCode, "HCBT_SYSCOMMAND"); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>lstrcpy(szCode, "Unknown"); </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>cch = wsprintf(szBuf, "CBT - nCode: %s, tsk: %ld, %d times   ", </P>

<P>szCode, wParam, c++); </P>

<P>TextOut(hdc, 2, 75, szBuf, cch); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>return CallNextHookEx(myhookdata[CBT].hhook, nCode, wParam, </P>

<P>lParam); </P>

<P>} </P>

<P></P>

<P>/**************************************************************** </P>

<P>WH_MOUSE hook procedure </P>

<P>****************************************************************/ </P>

<P></P>

<P>LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam) </P>

<P>{ </P>

<P>CHAR szBuf[128]; </P>

<P>CHAR szMsg[16]; </P>

<P>HDC hdc; </P>

<P>static int c = 0; </P>

<P>int cch; </P>

<P></P>

<P>if (nCode &lt; 0)  // do not process the message </P>

<P>return CallNextHookEx(myhookdata[MOUSE].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P></P>

<P>// Call an application-defined function that converts a message </P>

<P>// constant to a string and copies it to a buffer. </P>

<P></P>

<P>LookUpTheMessage((PMSG) lParam, szMsg); </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>cch = wsprintf(szBuf, </P>

<P>"MOUSE - nCode: %d, msg: %s, x: %d, y: %d, %d times   ", </P>

<P>nCode, szMsg, LOWORD(lParam), HIWORD(lParam), c++); </P>

<P>TextOut(hdc, 2, 95, szBuf, cch); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>return CallNextHookEx(myhookdata[MOUSE].hhook, nCode, wParam, </P>

<P>lParam); </P>

<P>} </P>

<P></P>

<P>/**************************************************************** </P>

<P>WH_KEYBOARD hook procedure </P>

<P>****************************************************************/ </P>

<P></P>

<P>LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) </P>

<P>{ </P>

<P>CHAR szBuf[128]; </P>

<P>HDC hdc; </P>

<P>static int c = 0; </P>

<P>int cch; </P>

<P></P>

<P>if (nCode &lt; 0)  // do not process message </P>

<P>return CallNextHookEx(myhookdata[KEYBOARD].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>cch = wsprintf(szBuf, "KEYBOARD - nCode: %d, vk: %d, %d times ", </P>

<P>nCode, wParam, c++); </P>

<P>TextOut(hdc, 2, 115, szBuf, cch); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>return CallNextHookEx(myhookdata[KEYBOARD].hhook, nCode, wParam, </P>

<P>lParam); </P>

<P>} </P>

<P></P>

<P>/**************************************************************** </P>

<P>WH_MSGFILTER hook procedure </P>

<P>****************************************************************/ </P>

<P></P>

<P>LRESULT CALLBACK MessageProc(int nCode, WPARAM wParam, LPARAM lParam) </P>

<P>{ </P>

<P>CHAR szBuf[128]; </P>

<P>CHAR szMsg[16]; </P>

<P>CHAR szCode[32]; </P>

<P>HDC hdc; </P>

<P>static int c = 0; </P>

<P>int cch; </P>

<P></P>

<P>if (nCode &lt; 0)  // do not process message </P>

<P>return CallNextHookEx(myhookdata[MSGFILTER].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P></P>

<P>switch (nCode) </P>

<P>{ </P>

<P>case MSGF_DIALOGBOX: </P>

<P>lstrcpy(szCode, "MSGF_DIALOGBOX"); </P>

<P>break; </P>

<P></P>

<P>case MSGF_MENU: </P>

<P>lstrcpy(szCode, "MSGF_MENU"); </P>

<P>break; </P>

<P></P>

<P>case MSGF_SCROLLBAR: </P>

<P>lstrcpy(szCode, "MSGF_SCROLLBAR"); </P>

<P>break; </P>

<P></P>

<P>case MSGF_NEXTWINDOW: </P>

<P>lstrcpy(szCode, "MSGF_NEXTWINDOW"); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>wsprintf(szCode, "Unknown: %d", nCode); </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>// Call an application-defined function that converts a message </P>

<P>// constant to a string and copies it to a buffer. </P>

<P></P>

<P>LookUpTheMessage((PMSG) lParam, szMsg); </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>cch = wsprintf(szBuf, </P>

<P>"MSGFILTER  nCode: %s, msg: %s, %d times    ", </P>

<P>szCode, szMsg, c++); </P>

<P>TextOut(hdc, 2, 135, szBuf, cch); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>return CallNextHookEx(myhookdata[MSGFILTER].hhook, nCode, </P>

<P>wParam, lParam); </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
