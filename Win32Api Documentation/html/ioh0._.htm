<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>CryptDeriveKey [New - Windows NT] [New - Windows 95, OEM Service Release 2]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="ioh0._"></A><B>CryptDeriveKey  <A HREF="a3anhz.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="ea82_u.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="2say87.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>[New - Windows 95, OEM Service Release 2]</P>

<P>The <B>CryptDeriveKey</B> function generates cryptographic keys derived from base data. This function guarantees that all keys generated from the same base data will be identical, provided the same CSP and algorithms are used. The base data can be a password or any other user data.</P>

<P>This function is the same as <A HREF="dnbayj.htm"><B>CryptGenKey</B></A>, except that the generated session keys are derived from base data instead of being random. Another difference is that the <B>CryptDeriveKey</B> function cannot be used to generate public/private key pairs.</P>

<P>A handle to the session key is returned in <I>phKey</I>. This handle can then be used as needed with any of the other CryptoAPI functions that require key handles.</P>

<P><B>BOOL CRYPTFUNC CryptDeriveKey(</B></P>

<TABLE cols=2 width=247>

<TR VALIGN="top">
<TD width=86%><B>HCRYPTPROV </B><I>hProv</I><B>,</B></TD>
<TD width=14%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=86%><B>    ALG_ID </B><I>Algid</I><B>,</B></TD>
<TD width=14%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=86%><B>    HCRYPTHASH </B><I>hBaseData</I><B>,</B></TD>
<TD width=14%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=86%><B>    DWORD </B><I>dwFlags</I><B>,</B></TD>
<TD width=14%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=86%><B>    HCRYPTKEY *</B><I>phKey</I></TD>
<TD width=14%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=86%><B>   );</B></TD>
<TD width=14%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hProv</I></P>

<P>[in] A handle to the application's CSP. An application obtains this handle using the <A HREF="b4q7j2.htm"><B>CryptAcquireContext</B></A> function.</P>

<P><I>Algid</I></P>

<P>[in] The identifier for the algorithm for which the key is to be generated.</P>

<P>The valid values for this parameter will vary, depending on the CSP that is used. See the "Remarks" section for a list of possible algorithm identifiers.</P>

<P><I>hBaseData</I></P>

<P>[in] A handle to a hash object that has been fed exactly the base data.</P>

<P>To obtain this handle, an application must first create a hash object with <A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A> and then add the base data to the hash object with <A HREF="46c7fgj.htm"><B>CryptHashData</B></A>. This process is described in detail in the section <A HREF="41b3l2.htm">Hashes and Digital Signatures</A>.</P>

<P><I>dwFlags</I></P>

<P>[in] The flags specifying the type of key generated. This parameter can be zero, or you can specify one or more of the following flags, using the binary OR operator to combine them.</P>

<P>CRYPT_EXPORTABLE</P>

<P>If this flag is set, then the session key can be transferred out of the CSP into a key blob through the <A HREF="2n8dsnc.htm"><B>CryptExportKey</B></A> function. Because keys generally must  be exportable, this flag should usually be set.</P>

<P>If this flag is not set, then the session key will <I>not</I> be exportable. This means the key will only be available within the current session and only the application that created it will be able to use it.</P>

<P>This flag does not apply to public/private key pairs.</P>

<P>CRYPT_CREATE_SALT</P>

<P>Typically, when a session key is made from a hash value, there are a number of leftover bits. For example, if the hash value is 128 bits and the session key is 40 bits, there will be 88 bits leftover.</P>

<P>If this flag is set, then the key will be assigned a salt value based on the unused hash value bits. You can retrieve this salt value using the <A HREF="bu8pdf.htm"><B>CryptGetKeyParam</B></A> function with the <I>dwParam</I> parameter set to KP_SALT.</P>

<P>If this flag is not set, then the key will be given a salt value of zero.</P>

<P>When keys with nonzero salt values are exported (using <A HREF="2n8dsnc.htm"><B>CryptExportKey</B></A>), the salt value must also be obtained  and kept with the key blob.</P>

<P>CRYPT_USER_PROTECTED</P>

<P>If this flag is set, then the user will be notified through a dialog box or another method when certain actions are attempted using this key. The precise behavior is specified by the CSP being used. </P>

<P>The Microsoft RSA Base Provider ignores this flag.</P>

<P>CRYPT_UPDATE_KEY</P>

<P>Some CSPs use session keys that are derived from multiple hash values. When this is the case, <B>CryptDeriveKey</B> must be called multiple times.</P>

<P>If this flag is set, a new session key is not generated. Instead, the key specified by <I>phKey</I> is modified. The precise behavior of this flag is dependent on the type of key being generated and on the particular CSP being used.</P>

<P>The Microsoft RSA Base Provider ignores this flag.</P>

<P><I>phKey</I></P>

<P>[in/out] The address to which the function copies the handle of the newly generated key.</P>

<P></P>

<P><B>Remarks</B></P>

<P>To generate a key for a symmetric encryption algorithm, use the <I>Algid</I> parameter to specify the algorithm. The algorithms available will most likely be different for each CSP. If you are using the Microsoft RSA Base Provider, use one of the following values to specify the algorithm:</P>

<P>·CALG_RC2 ¾ RC2 block cipher</P>

<P>·CALG_RC4 ¾ RC4 stream cipher</P>

<P></P>

<P>When keys are generated for symmetric block ciphers, the key by default will be set up in cipher block chaining (CBC) mode with an initialization vector of zero. This cipher mode provides a good default method for bulk encrypting data. To change these parameters, use the <A HREF="1smrhzn.htm"><B>CryptSetKeyParam</B></A> function.</P>

<P>Once the <B>CryptDeriveKey</B> function has been called, no more data can be added to the hash object. The <A HREF="1rbk0dy.htm"><B>CryptDestroyHash</B></A> function should be called at this point to destroy the hash object.</P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To retrieve extended error information, use the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function.</P>

<P>The following table lists the error codes most commonly returned by the <B>GetLastError</B> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=43%><B>Error</B></TD>
<TD width=57%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=43%>ERROR_INVALID_HANDLE</TD>
<TD width=57%>One of the parameters specifies an invalid handle. </TD>
</TR>

<TR VALIGN="top">
<TD width=43%>ERROR_INVALID_PARAMETER</TD>
<TD width=57%>One of the parameters contains an invalid value. This is most often an illegal pointer.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_ALGID</TD>
<TD width=57%>The <I>Algid</I> parameter specifies an algorithm that this CSP does not support.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_FLAGS</TD>
<TD width=57%>The <I>dwFlags</I> parameter contains an invalid value.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_HASH</TD>
<TD width=57%>The <I>hBaseData</I> parameter does not contain a valid handle to a hash object.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_UID</TD>
<TD width=57%>The <I>hProv</I> parameter does not contain a valid context handle.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_FAIL</TD>
<TD width=57%>The function failed in some unexpected way.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Example</B></P>

<P>#include &lt;wincrypt.h&gt;</P>

<P></P>

<P>HCRYPTPROV hProv = 0;</P>

<P>HCRYPTKEY hKey = 0;</P>

<P>HCRYPTHASH hHash = 0;</P>

<P>CHAR szPassword[ ] = "apple-camshaft";</P>

<P>DWORD dwLength;</P>

<P>// Get handle to user default provider.</P>

<P>if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {</P>

<P>printf("Error %x during CryptAcquireContext!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Create hash object.</P>

<P>if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) {</P>

<P>printf("Error %x during CryptCreateHash!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Hash password string.</P>

<P>dwLength = strlen(szPassword);</P>

<P>if(!CryptHashData(hHash, (BYTE *)szPassword, dwLength, 0)) {</P>

<P>printf("Error %x during CryptHashData!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Create block cipher session key based on hash of the password.</P>

<P>if(!CryptDeriveKey(hProv, CALG_RC2, hHash, CRYPT_EXPORTABLE, &amp;hKey)) {</P>

<P>printf("Error %x during CryptDeriveKey!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Use 'hKey' to do something.</P>

<P>...</P>

<P></P>

<P>done:</P>

<P>// Destroy hash object.</P>

<P>if(hHash != 0) CryptDestroyHash(hHash);</P>

<P>// Destroy session key.</P>

<P>if(hKey != 0) CryptDestroyKey(hKey);</P>

<P>// Release provider handle.</P>

<P>if(hProv != 0) CryptReleaseContext(hProv, 0);</P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="b4q7j2.htm"><B>CryptAcquireContext</B></A>, <A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A>, <A HREF="1rbk0dy.htm"><B>CryptDestroyHash</B></A>, <A HREF="sq9krr.htm"><B>CryptDestroyKey</B></A>, <A HREF="2n8dsnc.htm"><B>CryptExportKey</B></A>, <A HREF="dnbayj.htm"><B>CryptGenKey</B></A>, <A HREF="bu8pdf.htm"><B>CryptGetKeyParam</B></A>, <A HREF="46c7fgj.htm"><B>CryptHashData</B></A>, <A HREF="1smrhzn.htm"><B>CryptSetKeyParam</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
