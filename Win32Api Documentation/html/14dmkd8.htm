<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Server Using Overlapped Input and Output</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="14dmkd8"></A><B>Server Using Overlapped Input and Output</B></P>

<P>This example is a single-threaded server process that uses overlapped operations to service simultaneous connections to multiple client processes. The server process creates a fixed number of pipe instances, each of which can be connected to a separate client process. When a client process has finished using its pipe instance, the server disconnects from the client and reuses the pipe instance to connect to a new client. </P>

<P>Associated with each pipe instance is an <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure containing an event object. This structure is specified as a parameter in each <A HREF="cjnd8p.htm"><B>ReadFile</B></A>, <A HREF="g0sox_.htm"><B>WriteFile</B></A>, and <A HREF="ksa3sm.htm"><B>ConnectNamedPipe</B></A> operation on the pipe instance. Although the example shows simultaneous operations on different pipe instances, it avoids simultaneous operations on a single pipe instance. Because the same event object is used for read, write, and connect operations for each instance, there is no way to know which operation's completion caused the event to be set to the signaled state for simultaneous operations using the same pipe instance. </P>

<P>The event handles for each pipe instance are also stored in an array used by the <A HREF="ux0.eo.htm"><B>WaitForMultipleObjects</B></A> function. This function waits for one of the events to be signaled, and its return value is the array index of the event that satisfied the wait. The example uses this index to retrieve a structure containing information for the pipe instance. The server uses the <B>fPendingIO</B> member of the structure to keep track of whether the most recent I/O operation on the instance was pending, necessitating a call to the <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A> function. It uses the <B>dwState</B> member of the structure to determine the next operation that must be performed for the instance. </P>

<P>Overlapped <B>ReadFile</B>, <B>WriteFile</B>, and <B>ConnectNamedPipe</B> operations may have finished when the function returns, or they may still be pending when the function returns. If the operation is pending, the event object in the specified <B>OVERLAPPED</B> structure is set to the nonsignaled state before the function returns. When the pending operation has finished, the system sets the state of the event object to signaled. The state of the event object is not changed if the operation finishes before the function returns. </P>

<P>Because the example uses manual reset event objects, the state of the event objects is not changed to nonsignaled by the <B>WaitForMultipleObjects</B> function. This is important, because the example relies on the event objects remaining in the signaled state except when there is a pending operation. </P>

<P>If the operation is already finished when <A HREF="cjnd8p.htm"><B>ReadFile</B></A>, <A HREF="g0sox_.htm"><B>WriteFile</B></A>, or <A HREF="ksa3sm.htm"><B>ConnectNamedPipe</B></A> returns, the function's return value indicates the result. For read and write operations, the number of bytes transferred is also returned. If the operation is still pending, the <B>ReadFile</B>, <B>WriteFile</B>, or <B>ConnectNamedPipe</B> function returns FALSE and the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function returns ERROR_IO_PENDING. In this case, the results are retrieved using the <B>GetOverlappedResult</B> function after the operation has finished. <B>GetOverlappedResult</B> returns only the results of operations that were pending, and does not report the results of operations that were completed before the overlapped <B>ReadFile</B>, <B>WriteFile</B>, or <B>ConnectNamedPipe</B> function returned. </P>

<P>Before disconnecting from a client, the multithreaded server example in the previous section used <A HREF="3oca9w0.htm"><B>FlushFileBuffers</B></A> to ensure that the client had read everything written to the pipe. This would defeat the purpose of overlapped I/O, because the flush operation would block the execution of the server thread while it waits for the client to empty the pipe. Consequently, it is necessary to wait for a signal from the client that it has finished before disconnecting. In this example, the signal is the error generated by trying to read from the pipe after the client process closes its handle. </P>

<P>#include &lt;windows.h&gt;  </P>

<P></P>

<P>#define CONNECTING_STATE 0 </P>

<P>#define READING_STATE 1 </P>

<P>#define WRITING_STATE 2 </P>

<P>#define INSTANCES 4 </P>

<P></P>

<P>typedef struct </P>

<P>{ </P>

<P>OVERLAPPED oOverlap; </P>

<P>HANDLE hPipeInst; </P>

<P>CHAR chBuf[BUFSIZE]; </P>

<P>DWORD cbToWrite; </P>

<P>DWORD dwState; </P>

<P>BOOL fPendingIO; </P>

<P>} PIPEINST, *LPPIPEINST; </P>

<P></P>

<P></P>

<P>VOID DisconnectAndReconnect(DWORD); </P>

<P>BOOL ConnectToNewClient(HANDLE, LPOVERLAPPED); </P>

<P>VOID GetDataToWriteToClient(LPPIPEINST); </P>

<P></P>

<P>PIPEINST Pipe[INSTANCES]; </P>

<P>HANDLE hEvents[INSTANCES]; </P>

<P></P>

<P>DWORD main(VOID) </P>

<P>{ </P>

<P>DWORD i, dwWait, cbBytes, dwErr; </P>

<P>BOOL fSuccess; </P>

<P>LPTSTR lpszPipename = "\\\\.\\pipe\\mynamedpipe"; </P>

<P></P>

<P>// The initial loop creates several instances of a named pipe </P>

<P>// along with an event object for each instance.  An </P>

<P>// overlapped ConnectNamedPipe operation is started for </P>

<P>// each instance. </P>

<P></P>

<P>for (i = 0; i &lt; INSTANCES; i++) </P>

<P>{ </P>

<P></P>

<P>// Create an event object for this instance. </P>

<P></P>

<P>hEvents[i] = CreateEvent( </P>

<P>NULL,    // no security attribute </P>

<P>TRUE,    // manual-reset event </P>

<P>TRUE,    // initial state = signaled </P>

<P>NULL);   // unnamed event object </P>

<P>if (hEvents[i] == NULL) </P>

<P>MyErrExit("CreateEvent"); </P>

<P></P>

<P>Pipe[i].oOverlap.hEvent = hEvents[i]; </P>

<P></P>

<P>Pipe[i].hPipeInst = CreateNamedPipe( </P>

<P>lpszPipename,            // pipe name </P>

<P>PIPE_ACCESS_DUPLEX |     // read/write access </P>

<P>FILE_FLAG_OVERLAPPED,    // overlapped mode </P>

<P>PIPE_TYPE_MESSAGE |      // message-type pipe </P>

<P>PIPE_READMODE_MESSAGE |  // message-read mode </P>

<P>PIPE_WAIT,               // blocking mode </P>

<P>INSTANCES,               // number of instances </P>

<P>BUFSIZE,                 // output buffer size </P>

<P>BUFSIZE,                 // input buffer size </P>

<P>PIPE_TIMEOUT,            // client time-out </P>

<P>NULL);                   // no security attributes </P>

<P>if (Pipe[i].hPipeInst == INVALID_HANDLE_VALUE) </P>

<P>MyErrExit("CreatePipe"); </P>

<P></P>

<P>// Call the subroutine to connect to the new client</P>

<P></P>

<P>Pipe[i].fPendingIO = ConnectToNewClient( </P>

<P>Pipe[i].hPipeInst, </P>

<P>&amp;Pipe[i].oOverlap); </P>

<P></P>

<P>Pipe[i].dwState = Pipe[i].fPendingIO ? </P>

<P>CONNECTING_STATE : // still connecting </P>

<P>READING_STATE;     // ready to read </P>

<P>} </P>

<P></P>

<P>while (1) </P>

<P>{ </P>

<P>// Wait for the event object to be signaled, indicating </P>

<P>// completion of an overlapped read, write, or </P>

<P>// connect operation. </P>

<P></P>

<P>dwWait = WaitForMultipleObjects( </P>

<P>INSTANCES,    // number of event objects </P>

<P>hEvents,      // array of event objects </P>

<P>FALSE,        // does not wait for all </P>

<P>INFINITE);    // waits indefinitely </P>

<P></P>

<P>// dwWait shows which pipe completed the operation. </P>

<P></P>

<P>i = dwWait - WAIT_OBJECT_0;  // determines which pipe </P>

<P>if (i &lt; 0 || i &gt; (INSTANCES - 1)) </P>

<P>MyErrExit("index out of range"); </P>

<P></P>

<P>// Get the result if the operation was pending. </P>

<P></P>

<P>if (Pipe[i].fPendingIO) </P>

<P>{ </P>

<P>fSuccess = GetOverlappedResult( </P>

<P>Pipe[i].hPipeInst, // handle to pipe </P>

<P>&amp;Pipe[i].oOverlap, // OVERLAPPED structure </P>

<P>&amp;cbBytes,          // bytes transferred </P>

<P>FALSE);            // do not wait </P>

<P></P>

<P>switch (Pipe[i].dwState) </P>

<P>{ </P>

<P>// Pending connect operation </P>

<P>case CONNECTING_STATE: </P>

<P>if (! fSuccess) </P>

<P>MyErrExit("ConnectNamedPipe"); </P>

<P>Pipe[i].dwState = READING_STATE; </P>

<P>break; </P>

<P></P>

<P>// Pending read operation </P>

<P>case READING_STATE: </P>

<P>if (! fSuccess || cbBytes == 0) </P>

<P>{ </P>

<P>DisconnectAndReconnect(i); </P>

<P>continue; </P>

<P>} </P>

<P>Pipe[i].dwState = WRITING_STATE; </P>

<P>break; </P>

<P></P>

<P>// Pending write operation </P>

<P>case WRITING_STATE: </P>

<P>if (! fSuccess || cbBytes != Pipe[i].cbToWrite) </P>

<P>{ </P>

<P>DisconnectAndReconnect(i); </P>

<P>continue; </P>

<P>} </P>

<P>Pipe[i].dwState = READING_STATE; </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>MyErrExit("invalid pipe state"); </P>

<P>}  </P>

<P>} </P>

<P></P>

<P>// The pipe state determines which operation to do next. </P>

<P></P>

<P>switch (Pipe[i].dwState) </P>

<P>{ </P>

<P>// READING_STATE: </P>

<P>// The pipe instance is connected to the client </P>

<P>// and is ready to read a request from the client. </P>

<P></P>

<P>case READING_STATE: </P>

<P>fSuccess = ReadFile( </P>

<P>Pipe[i].hPipeInst, </P>

<P>Pipe[i].chBuf, </P>

<P>BUFSIZE, </P>

<P>&amp;cbBytes, </P>

<P>&amp;Pipe[i].oOverlap); </P>

<P></P>

<P>// The read operation completed successfully. </P>

<P></P>

<P>if (fSuccess &amp;&amp; cbBytes != 0) </P>

<P>{ </P>

<P>Pipe[i].fPendingIO = FALSE; </P>

<P>Pipe[i].dwState = WRITING_STATE; </P>

<P>continue; </P>

<P>} </P>

<P></P>

<P>// The read operation is still pending </P>

<P></P>

<P>dwErr = GetLastError(); </P>

<P>if (! fSuccess &amp;&amp; (dwErr == ERROR_IO_PENDING)) </P>

<P>{ </P>

<P>Pipe[i].fPendingIO = TRUE; </P>

<P>continue; </P>

<P>} </P>

<P></P>

<P>// An error occurred; disconnect from the client. </P>

<P></P>

<P>DisconnectAndReconnect(i); </P>

<P>break; </P>

<P></P>

<P>// WRITING_STATE: </P>

<P>// The request was successfully read from the client. </P>

<P>// Get the reply data and write it to the client. </P>

<P></P>

<P>case WRITING_STATE: </P>

<P>GetDataToWriteToClient(&amp;Pipe[i]); </P>

<P></P>

<P>fSuccess = WriteFile( </P>

<P>Pipe[i].hPipeInst, </P>

<P>Pipe[i].chBuf, </P>

<P>Pipe[i].cbToWrite, </P>

<P>&amp;cbBytes, </P>

<P>&amp;Pipe[i].oOverlap); </P>

<P></P>

<P>// The write operation completed successfully. </P>

<P></P>

<P>if (fSuccess &amp;&amp; cbBytes == Pipe[i].cbToWrite) </P>

<P>{ </P>

<P>Pipe[i].fPendingIO = FALSE; </P>

<P>Pipe[i].dwState = READING_STATE; </P>

<P>continue; </P>

<P>} </P>

<P></P>

<P>// The write operation is still pending. </P>

<P></P>

<P>dwErr = GetLastError(); </P>

<P>if (! fSuccess &amp;&amp; (dwErr == ERROR_IO_PENDING)) </P>

<P>{ </P>

<P>Pipe[i].fPendingIO = TRUE; </P>

<P>continue; </P>

<P>} </P>

<P></P>

<P>// An error occurred; disconnect from the client. </P>

<P></P>

<P>DisconnectAndReconnect(i); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>MyErrExit("invalid pipe state"); </P>

<P>} </P>

<P>} </P>

<P></P>

<P>return 0; </P>

<P>} </P>

<P></P>

<P></P>

<P>// DisconnectAndReconnect(DWORD) </P>

<P>// This function is called when an error occurs or when the client </P>

<P>// closes its handle to the pipe. Disconnect from this client, then </P>

<P>// call ConnectNamedPipe to wait for another client to connect. </P>

<P></P>

<P>VOID DisconnectAndReconnect(DWORD i) </P>

<P>{ </P>

<P>// Disconnect the pipe instance. </P>

<P></P>

<P>if (! DisconnectNamedPipe(Pipe[i].hPipeInst) ) </P>

<P>MyErrExit("DisconnectNamedPipe"); </P>

<P></P>

<P>// Call a subroutine to connect to the new client. </P>

<P></P>

<P>Pipe[i].fPendingIO = ConnectToNewClient( </P>

<P>Pipe[i].hPipeInst, </P>

<P>&amp;Pipe[i].oOverlap); </P>

<P></P>

<P>Pipe[i].dwState = Pipe[i].fPendingIO ? </P>

<P>CONNECTING_STATE : // still connecting </P>

<P>READING_STATE;     // ready to read </P>

<P>} </P>

<P></P>

<P>// ConnectToNewClient(HANDLE, LPOVERLAPPED) </P>

<P>// This function is called to start an overlapped connect operation. </P>

<P>// It returns TRUE if an operation is pending or FALSE if the </P>

<P>// connection has been completed. </P>

<P></P>

<P>BOOL ConnectToNewClient(HANDLE hPipe, LPOVERLAPPED lpo) </P>

<P>{ </P>

<P>BOOL fConnected, fPendingIO = FALSE; </P>

<P></P>

<P>// Start an overlapped connection for this pipe instance. </P>

<P>fConnected = ConnectNamedPipe(hPipe, lpo); </P>

<P></P>

<P>// Overlapped ConnectNamedPipe should return FALSE. </P>

<P>if (fConnected) </P>

<P>MyErrExit("ConnectNamedPipe"); </P>

<P></P>

<P>switch (GetLastError()) </P>

<P>{ </P>

<P>// The overlapped connection in progress. </P>

<P>case ERROR_IO_PENDING: </P>

<P>fPendingIO = TRUE; </P>

<P>break; </P>

<P></P>

<P>// Client is already connected, so signal an event. </P>

<P></P>

<P>case ERROR_PIPE_CONNECTED: </P>

<P>if (SetEvent(lpo-&gt;hEvent)) </P>

<P>break; </P>

<P></P>

<P>// If an error occurs during the connect operation... </P>

<P>default: </P>

<P>MyErrExit("ConnectNamedPipe"); </P>

<P>} </P>

<P></P>

<P>return fPendingIO; </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
