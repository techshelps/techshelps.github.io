<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>CryptSignHash [New - Windows NT] [New - Windows 95, OEM Service Release 2]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="bod3zd"></A><B>CryptSignHash  <A HREF=".mee56.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="41b3l2.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="rkgz3o.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>[New - Windows 95, OEM Service Release 2]</P>

<P>The <B>CryptSignHash</B> function is used to sign a piece of data. Because all signature algorithms are asymmetric and thus incredibly slow, CryptoAPI will not let data be signed directly. Instead, you must first hash the data and then use <B>CryptSignHash</B> to sign the hash value.</P>

<P><B>BOOL CRYPTFUNC CryptSignHash(</B></P>

<TABLE cols=2 width=227>

<TR VALIGN="top">
<TD width=85%><B>HCRYPTHASH </B><I>hHash</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwKeySpec</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    LPCTSTR </B><I>sDescription</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwFlags</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    BYTE *</B><I>pbSignature</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD *</B><I>pdwSigLen</I></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>   );</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hHash</I></P>

<P>[in] A handle to the hash object to be signed.</P>

<P><I>dwKeySpec</I></P>

<P>[in] The key pair to use to sign the hash. The following keys can be specified:</P>

<P>·AT_KEYEXCHANGE ¾ Exchange private key</P>

<P>·AT_SIGNATURE ¾ Signature private key</P>

<P>The signature algorithm used is specified when the key pair was originally created.</P>

<P>The only signature algorithm that the Microsoft RSA Base Provider supports is the RSA Public-Key algorithm.</P>

<P><I>sDescription</I></P>

<P>[in] The string describing the data to sign. This description text is added to the hash object before the signature is generated. Whenever the signature is authenticated (with <A HREF="dgovgy.htm"><B>CryptVerifySignature</B></A>), the exact same description string must be supplied. This ensures that both the signer and the authenticator agree on what is being signed or authenticated.</P>

<P>Some CSPs (not the Microsoft RSA Base Provider) will display this description string to the user. This lets the user confirm what he or she is signing. This protects the user from unscrupulous applications and also reduces misunderstandings.</P>

<P>This parameter can be NULL if no description string is to included in the signature. Usually, this is only the case when the signature is performed using a signature key that is not legally bound to the user. For example, when a signature operation is performed with the key exchange private key as part of a key exchange protocol, no description string is typically specified.</P>

<P><I>dwFlags</I></P>

<P>[in] The flag values. This parameter is reserved for future use and should always be zero.</P>

<P><I>pbSignature</I></P>

<P>[out] The buffer in which the function places the signature data.</P>

<P>This parameter can be NULL if all you are doing is determining the number of bytes required for the returned signature data.</P>

<P><I>pdwSigLen</I></P>

<P>[in/out] The address of the signature data length. Before calling this function, the caller should set this parameter to the length, in bytes, of the <I>pbSignature</I> buffer. Upon return, this address will contain the number of bytes in the signature data.</P>

<P>If the buffer specified by <I>pbSignature</I> is not large enough to hold the data, the function returns the ERROR_MORE_DATA error code (through <A HREF="11c2vs7.htm"><B>GetLastError</B></A>) and stores the required buffer size, in bytes, into the variable pointed to by <I>pdwSigLen</I>.</P>

<P>If <I>pbSignature</I> is NULL, then no error is returned and the function stores the size of the data, in bytes, in the variable pointed to by <I>pdwSigLen</I>. </P>

<P></P>

<P><B>Remarks</B></P>

<P>Before calling this function, the <A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A> function must be called to get a handle to a hash object. The <A HREF="46c7fgj.htm"><B>CryptHashData</B></A> or <A HREF="21hhdd_.htm"><B>CryptHashSessionKey</B></A> function is then used to add the data or session keys to the hash object.</P>

<P>Once this function has been completed, the only hash function that can be called using the <I>hHash</I> handle is the <A HREF="1rbk0dy.htm"><B>CryptDestroyHash</B></A> function.</P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To retrieve extended error information, use the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function.</P>

<P>The following table lists the error codes most commonly returned by the <B>GetLastError</B> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=47%><B>Error</B></TD>
<TD width=53%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_HANDLE</TD>
<TD width=53%>One of the parameters specifies an invalid handle.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_PARAMETER</TD>
<TD width=53%>One of the parameters contains an invalid value. This is most often an illegal pointer.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_ALGID</TD>
<TD width=53%>The <I>hHash</I> handle specifies an algorithm that this CSP does not support.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_FLAGS</TD>
<TD width=53%>The <I>dwFlags</I> parameter is nonzero.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_HASH</TD>
<TD width=53%>The hash object specified by the <I>hHash</I> parameter is invalid.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_UID</TD>
<TD width=53%>The CSP context that was specified when the hash object was created cannot be found.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_NO_KEY</TD>
<TD width=53%>The private key specified by <I>dwKeySpec</I> does not exist.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_NO_MEMORY</TD>
<TD width=53%>The CSP ran out of memory during the operation.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Example</B></P>

<P>#include &lt;wincrypt.h&gt;</P>

<P></P>

<P>HCRYPTPROV hProv = 0;</P>

<P>#define BUFFER_SIZE 256</P>

<P>BYTE pbBuffer[BUFFER_SIZE];</P>

<P>HCRYPTHASH hHash = 0;</P>

<P>BYTE *pbSignature = NULL;</P>

<P>DWORD dwSigLen;</P>

<P>LPTSTR szDescription = TEXT("Test Data");</P>

<P>DWORD i;</P>

<P></P>

<P>// Get handle to the default provider.</P>

<P>if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {</P>

<P>printf("Error %x during CryptAcquireContext!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Fill buffer with test data.</P>

<P>for(i = 0 ; i &lt; BUFFER_SIZE ; i++) {</P>

<P>pbBuffer[i] = (BYTE)i;</P>

<P>}</P>

<P>// Create hash object.</P>

<P>if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) {</P>

<P>printf("Error %x during CryptCreateHash!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Hash buffer.</P>

<P>if(!CryptHashData(hHash, pbBuffer, BUFFER_SIZE, 0)) {</P>

<P>printf("Error %x during CryptHashData!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Determine size of signature and allocate memory.</P>

<P>dwSigLen = 0;</P>

<P>if(!CryptSignHash(hHash, AT_SIGNATURE, TEXT(""), 0, NULL, &amp;dwSigLen)) {</P>

<P>printf("Error %x during CryptSignHash!\n", GetLastError());</P>

<P>if(GetLastError()!=NTE_BAD_LEN) goto done;</P>

<P>}</P>

<P>if((pbSignature = malloc(dwSigLen)) == NULL) {</P>

<P>printf("Out of memory!\n");</P>

<P>goto done;</P>

<P>}</P>

<P></P>

<P>// Sign hash object.</P>

<P>if(!CryptSignHash(hHash, AT_SIGNATURE, szDescription, 0, pbSignature, &amp;dwSigLen)) {</P>

<P>printf("Error %x during CryptSignHash!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P></P>

<P>// Store or transmit the signature, test buffer, and description string.</P>

<P>...</P>

<P></P>

<P>done:</P>

<P>// Free memory used to store signature.</P>

<P>if(pbSignature != NULL) free(pbSignature);</P>

<P>// Destroy hash object.</P>

<P>if(hHash != 0) CryptDestroyHash(hHash);</P>

<P>// Release provider handle.</P>

<P>if(hProv != 0) CryptReleaseContext(hProv, 0);</P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A>, <A HREF="1rbk0dy.htm"><B>CryptDestroyHash</B></A>, <A HREF="46c7fgj.htm"><B>CryptHashData</B></A>, <A HREF="21hhdd_.htm"><B>CryptHashSessionKey</B></A>, <A HREF="dgovgy.htm"><B>CryptVerifySignature</B></A> </P>

<P></P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
