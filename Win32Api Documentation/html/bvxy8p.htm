<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Multithreaded Server</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="bvxy8p"></A><B>Multithreaded Server</B></P>

<P>This example of a multithreaded server process has a main thread that loops continuously, creating a pipe instance and waiting for a client process to connect. When a client process connects, the server process creates a thread to service that client and the loop starts over. It is possible for a client process to connect successfully to the pipe instance in the interval between calls to the <A HREF="21dzyt.htm"><B>CreateNamedPipe</B></A> and <A HREF="ksa3sm.htm"><B>ConnectNamedPipe</B></A> functions. If this happens, <B>ConnectNamedPipe</B> returns FALSE, and <A HREF="11c2vs7.htm"><B>GetLastError</B></A> returns ERROR_PIPE_CONNECTED. </P>

<P>The thread created to service each pipe instance reads requests from the pipe and writes replies to the pipe until the client process closes its handle. When this happens, the thread flushes the pipe, disconnects, closes its pipe handle, and terminates. </P>

<P>#include &lt;stdio.h&gt;  </P>

<P>#include &lt;stdlib.h&gt; </P>

<P>#include &lt;string.h&gt; </P>

<P>#include &lt;windows.h&gt; </P>

<P></P>

<P>VOID InstanceThread(LPVOID); </P>

<P>VOID GetAnswerToRequest(LPTSTR, LPTSTR, LPDWORD); </P>

<P></P>

<P>int xx = 0; </P>

<P></P>

<P>DWORD main(VOID) </P>

<P>{ </P>

<P>BOOL fConnected; </P>

<P>DWORD dwThreadId; </P>

<P>HANDLE hPipe, hThread; </P>

<P>LPTSTR lpszPipename = "\\\\.\\pipe\\mynamedpipe"; </P>

<P></P>

<P>// The main loop creates an instance of the named pipe and </P>

<P>// then waits for a client to connect to it. When the client </P>

<P>// connects, a thread is created to handle communications </P>

<P>// with that client, and the loop is repeated. </P>

<P></P>

<P>for (;;) </P>

<P>{ </P>

<P>hPipe = CreateNamedPipe( </P>

<P>lpszPipename,             // pipe name </P>

<P>PIPE_ACCESS_DUPLEX,       // read/write access </P>

<P>PIPE_TYPE_MESSAGE |       // message type pipe </P>

<P>PIPE_READMODE_MESSAGE |   // message-read mode </P>

<P>PIPE_WAIT,                // blocking mode </P>

<P>PIPE_UNLIMITED_INSTANCES, // max. instances  </P>

<P>BUFSIZE,                  // output buffer size </P>

<P>BUFSIZE,                  // input buffer size </P>

<P>PIPE_TIMEOUT,             // client time-out </P>

<P>NULL);                    // no security attribute </P>

<P>if (hPipe == INVALID_HANDLE_VALUE) </P>

<P>MyErrExit("CreatePipe"); </P>

<P></P>

<P>// Wait for the client to connect; if it succeeds, </P>

<P>// the function returns TRUE. If the function returns FALSE, </P>

<P>// GetLastError returns ERROR_PIPE_CONNECTED. </P>

<P></P>

<P>fConnected = ConnectNamedPipe(hPipe, NULL) ? </P>

<P>TRUE : </P>

<P>(GetLastError() == ERROR_PIPE_CONNECTED); </P>

<P></P>

<P>if (fConnected) </P>

<P>{ </P>

<P>// Create a thread for this client. </P>

<P>hThread = CreateThread( </P>

<P>NULL,              // No security attribute </P>

<P>0,                 // Default stack size </P>

<P>(LPTHREAD_START_ROUTINE) InstanceThread, </P>

<P>(LPVOID) hPipe,    // Thread parameter </P>

<P>0,                 // Not suspended </P>

<P>&amp;dwThreadId);      // Returns thread ID </P>

<P>if (hThread == INVALID_HANDLE_VALUE) </P>

<P>MyErrExit("CreateThread"); </P>

<P></P>

<P>} </P>

<P>else </P>

<P>// The client could not connect, so close the pipe. </P>

<P>CloseHandle(hPipe); </P>

<P>} </P>

<P>return 1; </P>

<P>} </P>

<P></P>

<P>VOID InstanceThread(LPVOID lpvParam) </P>

<P>{ </P>

<P>CHAR chRequest[BUFSIZE]; </P>

<P>CHAR chReply[BUFSIZE]; </P>

<P>DWORD cbBytesRead, cbReplyBytes, cbWritten; </P>

<P>BOOL fSuccess; </P>

<P>HANDLE hPipe; </P>

<P></P>

<P>// The thread's parameter is a handle to a pipe instance. </P>

<P></P>

<P>hPipe = (HANDLE) lpvParam; </P>

<P></P>

<P>while (1) </P>

<P>{ </P>

<P>// Read client requests from the pipe. </P>

<P>fSuccess = ReadFile( </P>

<P>hPipe,        // handle to pipe </P>

<P>chRequest,    // buffer to receive data </P>

<P>BUFSIZE,      // size of buffer </P>

<P>&amp;cbBytesRead, // number of bytes read </P>

<P>NULL);        // not overlapped I/O </P>

<P>if (! fSuccess || cbBytesRead == 0) </P>

<P>break; </P>

<P>GetAnswerToRequest(chRequest, chReply, &amp;cbReplyBytes); </P>

<P></P>

<P>// Write the reply to the pipe. </P>

<P>fSuccess = WriteFile( </P>

<P>hPipe,        // handle to pipe </P>

<P>chReply,      // buffer to write from </P>

<P>cbReplyBytes, // number of bytes to write </P>

<P>&amp;cbWritten,   // number of bytes written </P>

<P>NULL);        // not overlapped I/O </P>

<P>if (! fSuccess || cbReplyBytes != cbWritten) break; </P>

<P>} </P>

<P></P>

<P>// Flush the pipe to allow the client to read the pipe's contents </P>

<P>// before disconnecting. Then disconnect the pipe, and close the </P>

<P>// handle to this pipe instance. </P>

<P></P>

<P>FlushFileBuffers(hPipe); </P>

<P>DisconnectNamedPipe(hPipe); </P>

<P>CloseHandle(hPipe); </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
