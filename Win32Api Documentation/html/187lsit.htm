<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Displaying Keyboard Input</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="187lsit"></A><B>Displaying Keyboard Input</B></P>

<P>The example in this section shows how an application can receive characters from the keyboard, display them in the client area of a window, and update the position of the caret with each character typed. It also demonstrates how to move the caret in response to the LEFT ARROW, RIGHT ARROW, HOME and END keystrokes, and shows how to highlight selected text in response to the SHIFT+RIGHT ARROW key combination. </P>

<P>During processing of the <A HREF="2re1yt3.htm">WM_CREATE</A> message, the window procedure shown in the example allocates a 64K buffer for storing keyboard input. It also retrieves the metrics of the currently loaded font, saving the height and average width of characters in the font. The height and width are used in processing the <A HREF="d9cb1f.htm">WM_SIZE</A> message to calculate the line length and maximum number of lines, based on the size of the client area. </P>

<P>The window procedure creates and displays the caret when processing the <A HREF="1ml4f9e.htm">WM_SETFOCUS</A> message. It hides and deletes the caret when processing the <A HREF="558y_gq.htm">WM_KILLFOCUS</A> message. </P>

<P>When processing the <A HREF="4gep_o2.htm">WM_CHAR</A> message, the window procedure displays characters, stores them in the input buffer, and updates the caret position. The window procedure also converts tab characters to four consecutive space characters. Backspace, linefeed, and escape characters generate a beep, but are not otherwise processed. </P>

<P>The window procedure performs the left, right, end, and home caret movements when processing the <A HREF="cxjo_p.htm">WM_KEYDOWN</A> message. While processing the action of the RIGHT ARROW key, the window procedure checks the state of the SHIFT key and, if it is down, selects the character to the right of the caret as the caret is moved. </P>

<P>Note that the following code is written so that it can be compiled either as Unicode™ or as ANSI. If the source code defines Unicode, strings are handled as Unicode characters; otherwise, they are handled as ANSI characters. </P>

<P>#define BUFSIZE 65535  </P>

<P>#define SHIFTED 0x8000 </P>

<P></P>

<P>LONG APIENTRY MainWndProc(hwndMain, uMsg, wParam, lParam) </P>

<P>HWND hwndMain; </P>

<P>UINT uMsg; </P>

<P>UINT wParam; </P>

<P>LONG lParam; </P>

<P>{ </P>

<P>HDC hdc;                   /* handle of device context      */ </P>

<P>TEXTMETRIC tm;             /* structure for text metrics    */ </P>

<P>static DWORD dwCharX;      /* average width of characters   */ </P>

<P>static DWORD dwCharY;      /* height of characters          */ </P>

<P>static DWORD dwClientX;    /* width of client area          */ </P>

<P>static DWORD dwClientY;    /* height of client area         */ </P>

<P>static DWORD dwLineLen;    /* line length                   */ </P>

<P>static DWORD dwLines;      /* text lines in client area     */ </P>

<P>static int nCaretPosX = 0; /* horizontal position of caret  */ </P>

<P>static int nCaretPosY = 0; /* vertical position of caret    */ </P>

<P>static int nCharWidth = 0; /* width of a character          */ </P>

<P>static int cch = 0;        /* characters in buffer          */ </P>

<P>static int nCurChar = 0;   /* index of current character    */ </P>

<P>static PTCHAR pchInputBuf; /* address of input buffer       */ </P>

<P>int i, j;                  /* loop counters                 */ </P>

<P>int cCR = 0;               /* count of carriage returns     */ </P>

<P>int nCRIndex = 0;          /* index of last carriage return */ </P>

<P>int nVirtKey;              /* virtual-key code              */ </P>

<P>TCHAR szBuf[128];          /* temporary buffer              */ </P>

<P>TCHAR ch;                  /* current character             */ </P>

<P>PAINTSTRUCT ps;            /* required by BeginPaint        */ </P>

<P>RECT rc;                   /* output rectangle for DrawText */ </P>

<P>SIZE sz;                   /* string dimensions             */ </P>

<P>COLORREF crPrevText;       /* previous text color           */ </P>

<P>COLORREF crPrevBk;         /* previous background color     */ </P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_CREATE: </P>

<P></P>

<P>/* Get the metrics of the current font. */ </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>GetTextMetrics(hdc, &amp;tm); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P></P>

<P>/* Save the average character width and height. */ </P>

<P></P>

<P>dwCharX = tm.tmAveCharWidth; </P>

<P>dwCharY = tm.tmHeight; </P>

<P></P>

<P>/* Allocate a buffer to store keyboard input. */ </P>

<P></P>

<P>pchInputBuf = (LPTSTR) GlobalAlloc(GPTR, </P>

<P>BUFSIZE * sizeof(TCHAR)); </P>

<P>return 0; </P>

<P></P>

<P>case WM_SIZE: </P>

<P></P>

<P>/* Save the new width and height of the client area. */ </P>

<P></P>

<P>dwClientX = LOWORD(lParam); </P>

<P>dwClientY = HIWORD(lParam); </P>

<P></P>

<P>/* </P>

<P>* Calculate the maximum width of a line and the </P>

<P>* maximum number of lines in the client area. </P>

<P>*/ </P>

<P></P>

<P>dwLineLen = dwClientX - dwCharX; </P>

<P>dwLines = dwClientY / dwCharY; </P>

<P>break; </P>

<P></P>

<P></P>

<P>case WM_SETFOCUS: </P>

<P></P>

<P>/* </P>

<P>* Create, position, and display the caret when the </P>

<P>* window receives the keyboard focus. </P>

<P>*/ </P>

<P></P>

<P>CreateCaret(hwndMain, (HBITMAP) 1, 0, dwCharY); </P>

<P>SetCaretPos(nCaretPosX, nCaretPosY * dwCharY); </P>

<P>ShowCaret(hwndMain); </P>

<P>break; </P>

<P></P>

<P>case WM_KILLFOCUS: </P>

<P></P>

<P>/* </P>

<P>* Hide and destroy the caret when the window loses the </P>

<P>* keyboard focus. </P>

<P>*/ </P>

<P></P>

<P>HideCaret(hwndMain); </P>

<P>DestroyCaret(); </P>

<P>break; </P>

<P></P>

<P>case WM_CHAR: </P>

<P>switch (wParam) { </P>

<P>case 0x08:  /* backspace */ </P>

<P>case 0x0A:  /* linefeed */ </P>

<P>case 0x1B:  /* escape */ </P>

<P>MessageBeep(0xFFFFFFFF); </P>

<P>return 0; </P>

<P></P>

<P>case 0x09:  /* tab */ </P>

<P></P>

<P>/* Convert tabs to four consecutive spaces. */ </P>

<P></P>

<P>for (i = 0; i &lt; 4; i++) </P>

<P>SendMessage(hwndMain, WM_CHAR, 0x20, 0); </P>

<P>return 0; </P>

<P></P>

<P>case 0x0D:  /* carriage return */ </P>

<P></P>

<P>/* </P>

<P>* Record the carriage return and position the </P>

<P>* caret at the beginning of the new line. </P>

<P>*/ </P>

<P></P>

<P>pchInputBuf[cch++] = 0x0D; </P>

<P>nCaretPosX = 0; </P>

<P>nCaretPosY += 1; </P>

<P>break; </P>

<P></P>

<P>default:    /* displayable character */ </P>

<P></P>

<P>ch = (TCHAR) wParam; </P>

<P>HideCaret(hwndMain); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the character's width and output </P>

<P>* the character. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>GetCharWidth32(hdc, (UINT) wParam, (UINT) wParam, </P>

<P>&amp;nCharWidth); </P>

<P>TextOut(hdc, nCaretPosX, nCaretPosY * dwCharY, </P>

<P>&amp;ch, 1); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P></P>

<P>/* Store the character in the buffer. */ </P>

<P></P>

<P>pchInputBuf[cch++] = ch; </P>

<P></P>

<P>/* </P>

<P>* Calculate the new horizontal position of the </P>

<P>* caret. If the position exceeds the maximum, </P>

<P>* insert a carriage return and move the caret </P>

<P>* to the beginning of the next line. </P>

<P>*/ </P>

<P></P>

<P>nCaretPosX += nCharWidth; </P>

<P>if ((DWORD) nCaretPosX &gt; dwLineLen) { </P>

<P>nCaretPosX = 0; </P>

<P>pchInputBuf[cch++] = 0x0D; </P>

<P>++nCaretPosY; </P>

<P>} </P>

<P>nCurChar = cch; </P>

<P>ShowCaret(hwndMain); </P>

<P>break; </P>

<P>} </P>

<P>SetCaretPos(nCaretPosX, nCaretPosY * dwCharY); </P>

<P>break; </P>

<P></P>

<P>case WM_KEYDOWN: </P>

<P>switch (wParam) { </P>

<P>case VK_LEFT:   /* LEFT ARROW */ </P>

<P></P>

<P>/* </P>

<P>* The caret can move only to the beginning of </P>

<P>* the current line. </P>

<P>*/ </P>

<P></P>

<P>if (nCaretPosX &gt; 0) { </P>

<P>HideCaret(hwndMain); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the character to the left of </P>

<P>* the caret, calculate the character's </P>

<P>* width, then subtract the width from the </P>

<P>* current horizontal position of the caret </P>

<P>* to obtain the new position. </P>

<P>*/ </P>

<P></P>

<P>ch = pchInputBuf[--nCurChar]; </P>

<P>hdc = GetDC(hwndMain); </P>

<P>GetCharWidth32(hdc, ch, ch, &amp;nCharWidth); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>nCaretPosX = max(nCaretPosX - nCharWidth, </P>

<P>0); </P>

<P>ShowCaret(hwndMain); </P>

<P>} </P>

<P>break; </P>

<P></P>

<P>case VK_RIGHT:  /* RIGHT ARROW */ </P>

<P></P>

<P>/* </P>

<P>* Caret moves to the right or, when a carriage </P>

<P>* return is encountered, to the beginning of </P>

<P>* the next line. </P>

<P>*/ </P>

<P></P>

<P>if (nCurChar &lt; cch) { </P>

<P>HideCaret(hwndMain); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the character to the right of </P>

<P>* the caret. If it's a carriage return, </P>

<P>* position the caret at the beginning of </P>

<P>* the next line. </P>

<P>*/ </P>

<P></P>

<P>ch = pchInputBuf[nCurChar]; </P>

<P>if (ch == 0x0D) { </P>

<P>nCaretPosX = 0; </P>

<P>nCaretPosY++; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* If the character isn't a carriage </P>

<P>* return, check to see whether the SHIFT </P>

<P>* key is down. If it is, invert the text </P>

<P>* colors and output the character. </P>

<P>*/ </P>

<P></P>

<P>else { </P>

<P>hdc = GetDC(hwndMain); </P>

<P>nVirtKey = GetKeyState(VK_SHIFT); </P>

<P>if (nVirtKey &amp; SHIFTED) { </P>

<P>crPrevText = SetTextColor(hdc, </P>

<P>RGB(255, 255, 255)); </P>

<P>crPrevBk = SetBkColor(hdc, </P>

<P>RGB(0,0,0)); </P>

<P>TextOut(hdc, nCaretPosX, </P>

<P>nCaretPosY * dwCharY, </P>

<P>&amp;ch, 1); </P>

<P>SetTextColor(hdc, crPrevText); </P>

<P>SetBkColor(hdc, crPrevBk); </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Get the width of the character and </P>

<P>* calculate the new horizontal </P>

<P>* position of the caret. </P>

<P>*/ </P>

<P></P>

<P>GetCharWidth32(hdc, ch, ch, &amp;nCharWidth); </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>nCaretPosX = nCaretPosX + nCharWidth; </P>

<P>} </P>

<P>nCurChar++; </P>

<P>ShowCaret(hwndMain); </P>

<P>break; </P>

<P>} </P>

<P>break; </P>

<P></P>

<P>case VK_UP:     /* UP ARROW   */ </P>

<P>case VK_DOWN:   /* DOWN ARROW */ </P>

<P>MessageBeep(0xFFFFFFFF); </P>

<P>return 0; </P>

<P></P>

<P>case VK_HOME:   /* HOME */ </P>

<P></P>

<P>/* </P>

<P>* Set the caret's position to the upper left </P>

<P>* corner of the client area. </P>

<P>*/ </P>

<P></P>

<P>nCaretPosX = nCaretPosY = 0; </P>

<P>nCurChar = 0; </P>

<P>break; </P>

<P></P>

<P>case VK_END:    /* END */ </P>

<P></P>

<P>/* Move the caret to the end of the text. */ </P>

<P></P>

<P>for (i=0; i &lt; cch; i++) { </P>

<P></P>

<P>/* </P>

<P>* Count the carriage returns and save the </P>

<P>* index of the last one. </P>

<P>*/ </P>

<P></P>

<P>if (pchInputBuf[i] == 0x0D) { </P>

<P>cCR++; </P>

<P>nCRIndex = i + 1; </P>

<P>} </P>

<P>} </P>

<P>nCaretPosY = cCR; </P>

<P></P>

<P>/* </P>

<P>* Copy all text between the last carriage </P>

<P>* return and the end of the keyboard input </P>

<P>* buffer to a temporary buffer. </P>

<P>*/ </P>

<P></P>

<P>for (i = nCRIndex, j = 0; i &lt; cch; i++, j++) </P>

<P>szBuf[j] = pchInputBuf[i]; </P>

<P>szBuf[j] = TEXT('\0'); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the text extent and use it </P>

<P>* to set the horizontal position of the </P>

<P>* caret. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P>GetTextExtentPoint32(hdc, szBuf, lstrlen(szBuf), </P>

<P>&amp;sz); </P>

<P>nCaretPosX = sz.cx; </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>nCurChar = cch; </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P>SetCaretPos(nCaretPosX, nCaretPosY * dwCharY); </P>

<P>break; </P>

<P></P>

<P>case WM_PAINT: </P>

<P>if (cch == 0)       /* nothing in input buffer */ </P>

<P>break; </P>

<P></P>

<P>hdc = BeginPaint(hwndMain, &amp;ps); </P>

<P>HideCaret(hwndMain); </P>

<P></P>

<P>/* </P>

<P>* Set the clipping rectangle, and then draw the text </P>

<P>* into it. </P>

<P>*/ </P>

<P></P>

<P>SetRect(&amp;rc, 0, 0, dwLineLen, dwClientY); </P>

<P>DrawText(hdc, pchInputBuf, -1, &amp;rc, DT_LEFT); </P>

<P></P>

<P>ShowCaret(hwndMain); </P>

<P>EndPaint(hwndMain, &amp;ps); </P>

<P>break; </P>

<P>. </P>

<P>. /* Process other messages. */ </P>

<P>. </P>

<P>case WM_DESTROY: </P>

<P>PostQuitMessage(0); </P>

<P></P>

<P>/* Free the input buffer. */ </P>

<P></P>

<P>GlobalFree((HGLOBAL) pchInputBuf); </P>

<P>UnregisterHotKey(hwndMain, 0xAAAA); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>return DefWindowProc(hwndMain, uMsg, wParam, lParam); </P>

<P>} </P>

<P>return NULL; </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
