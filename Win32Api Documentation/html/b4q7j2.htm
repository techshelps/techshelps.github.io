<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>CryptAcquireContext [New - Windows NT] [New - Windows 95, OEM Service Release 2]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="b4q7j2"></A><B>CryptAcquireContext  <A HREF="31rs0ns.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="1u2hyy.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="5khgnl.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>[New - Windows 95, OEM Service Release 2]</P>

<P>The <B>CryptAcquireContext</B> function is used to acquire a handle to a particular key container within a particular CSP. This returned handle can then be used to make calls to the selected CSP.</P>

<P>This function performs two operations. It first attempts to find a CSP with the characteristics described in the <I>dwProvType</I> and <I>pszProvider</I> parameters. If the CSP is found, then the function attempts to find a key container within the CSP matching the name specified by the <I>pszContainer</I> parameter.</P>

<P>This function can also be used to create and destroy key containers, depending on the value of the <I>dwFlags</I> parameter.</P>

<P><B>BOOL CRYPTFUNC CryptAcquireContext(</B></P>

<TABLE cols=2 width=230>

<TR VALIGN="top">
<TD width=85%><B>HCRYPTPROV *</B><I>phProv</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    LPCTSTR </B><I>pszContainer</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    LPCTSTR </B><I>pszProvider</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwProvType</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwFlags</I></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>   );</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>phProv</I></P>

<P>[out] The address to which the function copies a handle to the CSP.</P>

<P><I>pszContainer</I></P>

<P>[in] The key container name. This is a zero-terminated string that identifies the key container to the CSP. This name is independent of the method used to store the keys. Some CSPs will store their key containers internally (in hardware), some will use the system Registry, and others will use the file system.</P>

<P>If this parameter is NULL, then a default key container name will be used. For example, if the Microsoft RSA Base Provider is being used, then the current user's logon name will be used as the name of the key container. Other CSPs may also have default key containers that can be acquired in this way.</P>

<P>An application can obtain the name of the acquired key container at a later time by reading the PP_CONTAINER parameter from the <A HREF="i6j7dw.htm"><B>CryptGetProvParam</B></A> function.</P>

<P><I>pszProvider</I></P>

<P>[in] The provider name. This is a zero-terminated string that specifies the CSP to be used.</P>

<P>If this parameter is NULL then the user default provider is used. This situation is discussed in detail in the section <A HREF="1u2hyy.htm">Interfacing with a Cryptographic Service Provider (CSP)</A>.</P>

<P>An application can obtain the name of the acquired CSP at a later time by reading the PP_NAME parameter from the <A HREF="i6j7dw.htm"><B>CryptGetProvParam</B></A> function.</P>

<P><I>dwProvType</I></P>

<P>[in] The type of provider to acquire. The following provider types are predefined. These are discussed in detail in the section <A HREF="1u2hyy.htm">Interfacing with a Cryptographic Service Provider (CSP)</A>.</P>

<P>感ROV_RSA_FULL</P>

<P>感ROV_RSA_SIG</P>

<P>感ROV_DSS</P>

<P>感ROV_FORTEZZA</P>

<P>感ROV_MS_MAIL</P>

<P><I>dwFlags</I></P>

<P>[in] The flag values. This parameter is normally set to zero, but some applications will set one (and only one) of the following flags:</P>

<P>CRYPT_VERIFYCONTEXT</P>

<P>If this flag is set, then the application will have no access to the key container's private keys. In fact, if <I>pszContainer</I> is NULL and no default key container is present, the application will have no access to a key container at all.</P>

<P>This option is intended to be used by applications whose only cryptographic need is to verify digital signatures. The only operations normally needed in this case are public key import, hashing, and signature verification.</P>

<P>When <B>CryptAcquireContext</B> is called, many CSPs will require input from the owning user before granting access to the private keys in the key container. For example, the private keys may be encrypted, requiring a password from the user before they can be used. However, if the CRYPT_VERIFYCONTEXT flag is specified, access to the private keys is not required and the user interface can be bypassed.</P>

<P>CRYPT_NEWKEYSET</P>

<P>If this flag is set, then a new key container will be created with the name specified by <I>pszContainer</I>. If <I>pszContainer</I> is NULL, then a key container with the default name will be created.</P>

<P></P>

<P><B>Note</B> That when key containers are created, most CSPs will <I>not</I> automatically create any public/private key pairs. These keys must be created as a separate step with the <A HREF="dnbayj.htm"><B>CryptGenKey</B></A> function.</P>

<P></P>

<P><B>Important</B> This flag should only be set by administrative applications. Normal applications should not create key containers.</P>

<P></P>

<P>CRYPT_DELETEKEYSET</P>

<P>If this flag is set, then the key container specified by <I>pszContainer</I> is deleted. If <I>pszContainer</I> is NULL, then the key container with the default name is deleted. All key pairs in the key container are also destroyed.</P>

<P>When the CRYPT_DELETEKEYSET flag is set, the value returned in <I>phProv</I> is undefined and, thus, the <A HREF="5xih_c7.htm"><B>CryptReleaseContext</B></A> function need not be called afterwards.</P>

<P></P>

<P><B>Important</B> This flag should only be set by administrative applications. Normal applications should not destroy key containers.</P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To retrieve extended error information, use the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function.</P>

<P>The following table lists the error codes most commonly returned by the <B>GetLastError</B> function.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=46%><B>Error</B></TD>
<TD width=54%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=46%>ERROR_INVALID_PARAMETER</TD>
<TD width=54%>One of the parameters contains an invalid value. This is most often an illegal pointer.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>ERROR_NOT_ENOUGH_MEMORY</TD>
<TD width=54%>The operating system ran out of memory during the operation.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_BAD_FLAGS</TD>
<TD width=54%>The <I>dwFlags</I> parameter has an illegal value.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_BAD_KEYSET</TD>
<TD width=54%>The Registry entry for the key container could not be opened and may not exist.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_BAD_KEYSET_PARAM</TD>
<TD width=54%>The <I>pszContainer</I> or <I>pszProvider</I> parameter is set to an illegal value.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_BAD_PROV_TYPE</TD>
<TD width=54%>The value of the <I>dwProvType</I> parameter is out of range. All provider types must be from 1 to 999, inclusive.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_BAD_SIGNATURE</TD>
<TD width=54%>The provider DLL signature did not verify correctly. Either the DLL or the digital signature has been tampered with.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_EXISTS</TD>
<TD width=54%>The <I>dwFlags</I> parameter is CRYPT_NEWKEYSET, but the key container already exists.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_KEYSET_ENTRY_BAD</TD>
<TD width=54%>The Registry entry for the <I>pszContainer</I> key container was found (in the HKEY_CURRENT_USER window), but is corrupt. See the section <A HREF="1bs_hvr.htm">System Administration</A> for details about CryptoAPI's Registry usage.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_KEYSET_NOT_DEF</TD>
<TD width=54%>No Registry entry exists in the HKEY_CURRENT_USER window for the key container specified by <I>pszContainer</I>.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_NO_MEMORY</TD>
<TD width=54%>The CSP ran out of memory during the operation.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_PROV_DLL_NOT_FOUND</TD>
<TD width=54%>The provider DLL file does not exist or is not on the current path.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_PROV_TYPE_ENTRY_BAD</TD>
<TD width=54%>The Registry entry for the provider type specified by <I>dwProvType</I> is corrupt. This error may relate to either the user default CSP list or the machine default CSP list. See the section <A HREF="1bs_hvr.htm">System Administration</A> for details about CryptoAPI's Registry usage.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_PROV_TYPE_NO_MATCH</TD>
<TD width=54%>The provider type specified by <I>dwProvType</I> does not match the provider type found in the Registry. Note that this error can only occur when <I>pszProvider</I> specifies an actual CSP name.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_PROV_TYPE_NOT_DEF</TD>
<TD width=54%>No Registry entry exists for the provider type specified by <I>dwProvType</I>.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_PROVIDER_DLL_FAIL</TD>
<TD width=54%>The provider DLL file could not be loaded, and may not exist. If it exists, then the file is not a valid DLL.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>NTE_SIGNATURE_FILE_BAD</TD>
<TD width=54%>An error occurred while loading the DLL file image, prior to verifying its signature.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Example</B></P>

<P>#include &lt;wincrypt.h&gt;</P>

<P></P>

<P>HCRYPTPROV hProv = 0;</P>

<P>BYTE pbData[1000];</P>

<P>DWORD dwDataLen;</P>

<P>// Get handle to the default PROV_RSA_FULL provider.</P>

<P>if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {</P>

<P>printf("Error %x during CryptAcquireContext!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>// Read the name of the default CSP.</P>

<P>dwDataLen = 1000;</P>

<P>if(!CryptGetProvParam(hProv, PP_NAME, pbData, &amp;dwDataLen, 0)) {</P>

<P>printf("Error %x reading CSP name!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>printf("Provider name:%s\n", pbData);</P>

<P>// Read the name of the default key container.</P>

<P>dwDataLen = 1000;</P>

<P>if(!CryptGetProvParam(hProv, PP_CONTAINER, pbData, &amp;dwDataLen, 0)) {</P>

<P>printf("Error %x reading key container name!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>printf("Key Container name:%s\n", pbData);</P>

<P>// Perform cryptographic operations.</P>

<P>...</P>

<P>// Release provider handle.</P>

<P>if(!CryptReleaseContext(hProv, 0)) {</P>

<P>printf("Error %x during CryptReleaseContext!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>// ****************************************************************</P>

<P>// Get handle to the Microsoft RSA Base Provider and the </P>

<P>// "Foo" key container.</P>

<P>if(!CryptAcquireContext(&amp;hProv, TEXT("Foo"), MS_DEF_PROV, </P>

<P>PROV_RSA_FULL, 0)) {</P>

<P>printf("Error %x during CryptAcquireContext!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>// Perform cryptographic operations.</P>

<P>...</P>

<P>// Release provider handle.</P>

<P>if(!CryptReleaseContext(hProv, 0)) {</P>

<P>printf("Error %x during CryptReleaseContext!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>// ****************************************************************</P>

<P>// Get handle to the default provider. Create a new key container </P>

<P>// named "Bar". Note that this key container will be empty until keys</P>

<P>// are explicitly created with the CryptGenKey function.</P>

<P>lstrcpy(szProv, );</P>

<P>lstrcpy(szContainer, );</P>

<P>if(!CryptAcquireContext(&amp;hProv, TEXT("Bar"), NULL, PROV_RSA_FULL,</P>

<P>CRYPT_NEWKEYSET)) {</P>

<P>printf("Error %x during CryptAcquireContext!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>// Perform cryptographic operations.</P>

<P>...</P>

<P>// Release provider handle.</P>

<P>if(!CryptReleaseContext(hProv, 0)) {</P>

<P>printf("Error %x during CryptReleaseContext!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="dnbayj.htm"><B>CryptGenKey</B></A>, <A HREF="i6j7dw.htm"><B>CryptGetProvParam</B></A>, <A HREF="5xih_c7.htm"><B>CryptReleaseContext</B></A> </P>

</BODY>
</HTML>
