<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Writing a ServiceMain Function</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="rrg2r0"></A><B>Writing a ServiceMain Function</B></P>

<P>The MyServiceStart function in the following example is the entry point for the service. MyServiceStart has access to the command-line arguments, in the way that the main function of a console application does. The first parameter contains the number of arguments being passed to the service. There will always be at least one argument. The second parameter is a pointer to an array of string pointers. The first item in the array always points to the service name. </P>

<P>The MyServiceStart function first fills in the <A HREF="25uoeu.htm"><B>SERVICE_STATUS</B></A> structure including the control codes that it accepts. Although this service accepts SERVICE_CONTROL_PAUSE and SERVICE_CONTROL_CONTINUE, it does nothing significant when told to pause. The flags SERVICE_ACCEPT_PAUSE_CONTINUE was included for illustration purposes only; if pausing does not add value to your service, do not support it. </P>

<P>The MyServiceStart function then calls the <A HREF="hbd0d..htm"><B>RegisterServiceCtrlHandler</B></A> function to register MyService as the service's <A HREF="1eqr9ip.htm"><B>Handler</B></A> function and begin initialization. The following sample initialization function, MyServiceInitialization, is included for illustration purposes; it does not perform any initialization tasks such as creating additional threads. If your service's initialization performs tasks that are expected to take longer than one second, your code must call the <A HREF="u71xdk.htm"><B>SetServiceStatus</B></A> function periodically to send out wait hints and check points indicating that progress is being made. </P>

<P>When initialization has completed successfully, the example calls <B>SetServiceStatus</B> with a status of SERVICE_RUNNING and the service continues with its work. If an error has occurred in initialization, MyServiceStart reports SERVICE_STOPPED with the <B>SetServiceStatus</B> function and returns.</P>

<P>Because this sample service does not complete any real tasks, MyServiceStart simply returns control to the caller. However, your service should use this thread to complete whatever tasks it was designed to do. If a service does not need a thread to do its work (such as a service that only processes RPC requests), its <A HREF="y7r.4o.htm"><B>ServiceMain</B></A> function should return control to the caller. It is important for the function to return, rather than call the <A HREF="c.xq03.htm"><B>ExitThread</B></A> function, because returning allows for cleanup of the memory allocated for the arguments.</P>

<P>To output debugging information, MyServiceStart calls SvcDebugOut. The source code for SvcDebugOut is given in <A HREF="bx1i8w.htm">Writing a Service Program's main Function</A>.</P>

<P>void MyServiceStart (DWORD argc, LPTSTR *argv)  </P>

<P>{ </P>

<P>DWORD status; </P>

<P>DWORD specificError; </P>

<P></P>

<P>MyServiceStatus.dwServiceType        = SERVICE_WIN32; </P>

<P>MyServiceStatus.dwCurrentState       = SERVICE_START_PENDING; </P>

<P>MyServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | </P>

<P>SERVICE_ACCEPT_PAUSE_CONTINUE; </P>

<P>MyServiceStatus.dwWin32ExitCode      = 0; </P>

<P>MyServiceStatus.dwServiceSpecificExitCode = 0; </P>

<P>MyServiceStatus.dwCheckPoint         = 0; </P>

<P>MyServiceStatus.dwWaitHint           = 0; </P>

<P></P>

<P>MyServiceStatusHandle = RegisterServiceCtrlHandler( </P>

<P>TEXT("MyService"), </P>

<P>MyServiceCtrlHandler); </P>

<P></P>

<P>if (MyServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) </P>

<P>{ </P>

<P>SvcDebugOut(" [MY_SERVICE] RegisterServiceCtrlHandler </P>

<P>failed %d\n", GetLastError()); </P>

<P>return; </P>

<P>} </P>

<P></P>

<P>// Initialization code goes here. </P>

<P>status = MyServiceInitialization(argc,argv, &amp;specificError); </P>

<P></P>

<P>// Handle error condition </P>

<P>if (status != NO_ERROR) </P>

<P>{ </P>

<P>MyServiceStatus.dwCurrentState       = SERVICE_STOPPED; </P>

<P>MyServiceStatus.dwCheckPoint         = 0; </P>

<P>MyServiceStatus.dwWaitHint           = 0; </P>

<P>MyServiceStatus.dwWin32ExitCode      = status; </P>

<P>MyServiceStatus.dwServiceSpecificExitCode = specificError; </P>

<P></P>

<P>SetServiceStatus (MyServiceStatusHandle, &amp;MyServiceStatus); </P>

<P>return; </P>

<P>} </P>

<P></P>

<P>// Initialization complete - report running status. </P>

<P>MyServiceStatus.dwCurrentState       = SERVICE_RUNNING; </P>

<P>MyServiceStatus.dwCheckPoint         = 0; </P>

<P>MyServiceStatus.dwWaitHint           = 0; </P>

<P></P>

<P>if (!SetServiceStatus (MyServiceStatusHandle, &amp;MyServiceStatus)) </P>

<P>{ </P>

<P>status = GetLastError(); </P>

<P>SvcDebugOut(" [MY_SERVICE] SetServiceStatus error</P>

<P>%ld\n",status); </P>

<P>} </P>

<P></P>

<P>// This is where the service does its work. </P>

<P>SvcDebugOut(" [MY_SERVICE] Returning the Main Thread \n",0); </P>

<P></P>

<P>return; </P>

<P>} </P>

<P></P>

<P>// Stub initialization function. </P>

<P>DWORD MyServiceInitialization(DWORD   argc, LPTSTR  *argv, </P>

<P>DWORD *specificError) </P>

<P>{ </P>

<P>argv; </P>

<P>argc; </P>

<P>specificError; </P>

<P>return(0); </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
