<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Creating a Child Process with Redirected Input and Output</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="qm9qh9"></A><B>Creating a Child Process with Redirected Input and Output</B></P>

<P>The example in this topic demonstrates how to create a child process from a console process. It also demonstrates a technique for using anonymous pipes to redirect the child process's standard input and output handles. </P>

<P>The <A HREF="xn_62d.htm"><B>CreatePipe</B></A> function uses the <A HREF="be53kg.htm"><B>SECURITY_ATTRIBUTES</B></A> structure to create inheritable handles to the read and write ends of two pipes. The read end of one pipe serves as standard input for the child process, and the write end of the other pipe is the standard output for the child process. These pipe handles are specified in the <A HREF="1crxpv2.htm"><B>SetStdHandle</B></A> function, which makes them the standard handles inherited by the child process. After the child process is created, <B>SetStdHandle</B> is used again to restore the original standard handles for the parent process. </P>

<P>The parent process uses the other ends of the pipes to write to the child process's input and read the child process's output. The handles to these ends of the pipe are also inheritable. However, the handle must not be inherited. Before creating the child process, the parent process must use <A HREF="1ojqkwy.htm"><B>DuplicateHandle</B></A> to create a duplicate of the application-defined hChildStdinWr global variable that cannot be inherited. It then uses <A HREF="ngwwie.htm"><B>CloseHandle</B></A> to close the inheritable handle. For more information, see <A HREF="qxj_so.htm">Pipes</A>. </P>

<P>The following is the parent process. </P>

<P>#include &lt;stdio.h&gt;  </P>

<P>#include &lt;windows.h&gt; </P>

<P></P>

<P>#define BUFSIZE 4096 </P>

<P></P>

<P>HANDLE hChildStdinRd, hChildStdinWr, hChildStdinWrDup, </P>

<P>hChildStdoutRd, hChildStdoutWr, hChildStdoutRdDup, </P>

<P>hInputFile, hSaveStdin, hSaveStdout; </P>

<P></P>

<P>BOOL CreateChildProcess(VOID); </P>

<P>VOID WriteToPipe(VOID); </P>

<P>VOID ReadFromPipe(VOID); </P>

<P>VOID ErrorExit(LPTSTR); </P>

<P>VOID ErrMsg(LPTSTR, BOOL); </P>

<P></P>

<P>DWORD main(int argc, char *argv[]) </P>

<P>{ </P>

<P>SECURITY_ATTRIBUTES saAttr; </P>

<P>BOOL fSuccess; </P>

<P></P>

<P>// Set the bInheritHandle flag so pipe handles are inherited. </P>

<P></P>

<P>saAttr.nLength = sizeof(SECURITY_ATTRIBUTES); </P>

<P>saAttr.bInheritHandle = TRUE; </P>

<P>saAttr.lpSecurityDescriptor = NULL; </P>

<P></P>

<P>// The steps for redirecting child process's STDOUT: </P>

<P>//     1. Save current STDOUT, to be restored later. </P>

<P>//     2. Create anonymous pipe to be STDOUT for child process. </P>

<P>//     3. Set STDOUT of the parent process to be write handle of </P>

<P>//        the pipe, so it is inherited by the child process. </P>

<P>//     4. Create a noninheritable duplicate of the read handle and</P>

<P>//        close the inheritable read handle. </P>

<P></P>

<P>// Save the handle to the current STDOUT. </P>

<P></P>

<P>hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE); </P>

<P></P>

<P>// Create a pipe for the child process's STDOUT. </P>

<P></P>

<P>if (! CreatePipe(&amp;hChildStdoutRd, &amp;hChildStdoutWr, &amp;saAttr, 0)) </P>

<P>ErrorExit("Stdout pipe creation failed\n"); </P>

<P></P>

<P>// Set a write handle to the pipe to be STDOUT. </P>

<P></P>

<P>if (! SetStdHandle(STD_OUTPUT_HANDLE, hChildStdoutWr)) </P>

<P>ErrorExit("Redirecting STDOUT failed"); </P>

<P></P>

<P>// Create noninheritable read handle and close the inheritable read </P>

<P>// handle. </P>

<P>fSuccess = DuplicateHandle(GetCurrentProcess(), hChildStdoutRd,</P>

<P>GetCurrentProcess(), &amp;hChildStdoutRdDup , 0,</P>

<P>FALSE,</P>

<P>DUPLICATE_SAME_ACCESS);</P>

<P>if( !fSuccess )</P>

<P>ErrorExit("DuplicateHandle failed");</P>

<P>CloseHandle(hChildStdoutRd);</P>

<P>// The steps for redirecting child process's STDIN: </P>

<P>//     1.  Save current STDIN, to be restored later. </P>

<P>//     2.  Create anonymous pipe to be STDIN for child process. </P>

<P>//     3.  Set STDIN of the parent to be the read handle of the </P>

<P>//         pipe, so it is inherited by the child process. </P>

<P>//     4.  Create a noninheritable duplicate of the write handle, </P>

<P>//         and close the inheritable write handle. </P>

<P></P>

<P>// Save the handle to the current STDIN. </P>

<P></P>

<P>hSaveStdin = GetStdHandle(STD_INPUT_HANDLE); </P>

<P></P>

<P>// Create a pipe for the child process's STDIN. </P>

<P></P>

<P>if (! CreatePipe(&amp;hChildStdinRd, &amp;hChildStdinWr, &amp;saAttr, 0)) </P>

<P>ErrorExit("Stdin pipe creation failed\n"); </P>

<P></P>

<P>// Set a read handle to the pipe to be STDIN. </P>

<P></P>

<P>if (! SetStdHandle(STD_INPUT_HANDLE, hChildStdinRd)) </P>

<P>ErrorExit("Redirecting Stdin failed"); </P>

<P></P>

<P>// Duplicate the write handle to the pipe so it is not inherited. </P>

<P></P>

<P>fSuccess = DuplicateHandle(GetCurrentProcess(), hChildStdinWr, </P>

<P>GetCurrentProcess(), &amp;hChildStdinWrDup, 0, </P>

<P>FALSE,                  // not inherited </P>

<P>DUPLICATE_SAME_ACCESS); </P>

<P>if (! fSuccess) </P>

<P>ErrorExit("DuplicateHandle failed"); </P>

<P></P>

<P>CloseHandle(hChildStdinWr); </P>

<P></P>

<P>// Now create the child process. </P>

<P></P>

<P>if (! CreateChildProcess()) </P>

<P>ErrorExit("Create process failed"); </P>

<P></P>

<P>// After process creation, restore the saved STDIN and STDOUT. </P>

<P></P>

<P>if (! SetStdHandle(STD_INPUT_HANDLE, hSaveStdin)) </P>

<P>ErrorExit("Re-redirecting Stdin failed\n"); </P>

<P></P>

<P>if (! SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout)) </P>

<P>ErrorExit("Re-redirecting Stdout failed\n"); </P>

<P></P>

<P>// Get a handle to the parent's input file. </P>

<P></P>

<P>if (argc &gt; 1) </P>

<P>hInputFile = CreateFile(argv[1], GENERIC_READ, 0, NULL, </P>

<P>OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL); </P>

<P>else </P>

<P>hInputFile = hSaveStdin; </P>

<P></P>

<P>if (hInputFile == INVALID_HANDLE_VALUE) </P>

<P>ErrorExit("no input file\n"); </P>

<P></P>

<P>// Write to pipe that is the standard input for a child process. </P>

<P></P>

<P>WriteToPipe(); </P>

<P></P>

<P>// Read from pipe that is the standard output for child process. </P>

<P></P>

<P>ReadFromPipe(); </P>

<P></P>

<P>return 0; </P>

<P>} </P>

<P></P>

<P>BOOL CreateChildProcess() </P>

<P>{ </P>

<P>PROCESS_INFORMATION piProcInfo; </P>

<P>STARTUPINFO siStartInfo; </P>

<P></P>

<P>// Set up members of STARTUPINFO structure. </P>

<P></P>

<P>ZeroMemory( &amp;siStartInfo, sizeof(STARTUPINFO) );</P>

<P>siStartInfo.cb = sizeof(STARTUPINFO); </P>

<P></P>

<P>// Create the child process. </P>

<P></P>

<P>return CreateProcess(NULL, </P>

<P>"child",       // command line </P>

<P>NULL,          // process security attributes </P>

<P>NULL,          // primary thread security attributes </P>

<P>TRUE,          // handles are inherited </P>

<P>0,             // creation flags </P>

<P>NULL,          // use parent's environment </P>

<P>NULL,          // use parent's current directory </P>

<P>&amp;siStartInfo,  // STARTUPINFO pointer </P>

<P>&amp;piProcInfo);  // receives PROCESS_INFORMATION </P>

<P>}</P>

<P></P>

<P>VOID WriteToPipe(VOID) </P>

<P>{ </P>

<P>DWORD dwRead, dwWritten; </P>

<P>CHAR chBuf[BUFSIZE]; </P>

<P></P>

<P>// Read from a file and write its contents to a pipe. </P>

<P></P>

<P>for (;;) </P>

<P>{ </P>

<P>if (! ReadFile(hInputFile, chBuf, BUFSIZE, &amp;dwRead, NULL) || </P>

<P>dwRead == 0) break; </P>

<P>if (! WriteFile(hChildStdinWrDup, chBuf, dwRead, </P>

<P>&amp;dwWritten, NULL)) break; </P>

<P>} </P>

<P></P>

<P>// Close the pipe handle so the child process stops reading. </P>

<P></P>

<P>if (! CloseHandle(hChildStdinWrDup)) </P>

<P>ErrorExit("Close pipe failed\n"); </P>

<P>} </P>

<P></P>

<P>VOID ReadFromPipe(VOID) </P>

<P>{ </P>

<P>DWORD dwRead, dwWritten; </P>

<P>CHAR chBuf[BUFSIZE]; </P>

<P>HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); </P>

<P>// Close the write end of the pipe before reading from the </P>

<P>// read end of the pipe. </P>

<P></P>

<P>if (!CloseHandle(hChildStdoutWr)) </P>

<P>ErrorExit("Closing handle failed"); </P>

<P></P>

<P>// Read output from the child process, and write to parent's STDOUT. </P>

<P></P>

<P>for (;;) </P>

<P>{ </P>

<P>if( !ReadFile( hChildStdoutRdDup, chBuf, BUFSIZE, &amp;dwRead, </P>

<P>NULL) || dwRead == 0) break; </P>

<P>if (! WriteFile(hSaveStdout, chBuf, dwRead, &amp;dwWritten, NULL)) </P>

<P>break; </P>

<P>} </P>

<P>} </P>

<P></P>

<P>VOID ErrorExit (LPTSTR lpszMessage) </P>

<P>{ </P>

<P>fprintf(stderr, "%s\n", lpszMessage); </P>

<P>ExitProcess(0); </P>

<P>} </P>

<P></P>

<P>// The code for the child process. </P>

<P>#include &lt;windows.h&gt; </P>

<P>#define BUFSIZE 4096 </P>

<P></P>

<P>VOID main(VOID) </P>

<P>{ </P>

<P>CHAR chBuf[BUFSIZE]; </P>

<P>DWORD dwRead, dwWritten; </P>

<P>HANDLE hStdin, hStdout; </P>

<P>BOOL fSuccess; </P>

<P></P>

<P>hStdout = GetStdHandle(STD_OUTPUT_HANDLE); </P>

<P>hStdin = GetStdHandle(STD_INPUT_HANDLE); </P>

<P>if ((hStdout == INVALID_HANDLE_VALUE) || </P>

<P>(hStdin == INVALID_HANDLE_VALUE)) </P>

<P>ExitProcess(1); </P>

<P></P>

<P>for (;;) </P>

<P>{ </P>

<P>// Read from standard input. </P>

<P>fSuccess = ReadFile(hStdin, chBuf, BUFSIZE, &amp;dwRead, NULL); </P>

<P>if (! fSuccess || dwRead == 0) </P>

<P>break; </P>

<P></P>

<P>// Write to standard output. </P>

<P>fSuccess = WriteFile(hStdout, chBuf, dwRead, &amp;dwWritten, NULL); </P>

<P>if (! fSuccess) </P>

<P>break; </P>

<P>} </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
