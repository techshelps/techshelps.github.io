<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Reading from and Writing to a File</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME=".ljxka"></A><B>Reading from and Writing to a File</B></P>

<P>Every open file has a <I>file pointer</I> that specifies the next byte to be read or the location to receive the next byte written. When a file is opened for the first time, Windows places the file pointer at the beginning of the file. As each byte is read or written, Windows advances the file pointer. An application can also move the file pointer by using the <A HREF="1o4.z9c.htm"><B>SetFilePointer</B></A> function. </P>

<P>An application reads from and writes to a file by using the <A HREF="cjnd8p.htm"><B>ReadFile</B></A> and <A HREF="g0sox_.htm"><B>WriteFile</B></A> functions. These functions require a handle of a file to be opened for reading and writing, respectively. <B>ReadFile</B> and <B>WriteFile</B> read and write a specified number of bytes at the location indicated by the file pointer. The data is read and written exactly as given; the functions do not format the data. </P>

<P>When the file pointer reaches the end of a file and the application attempts to read from the file, no error occurs, but no bytes are read. Therefore, reading zero bytes without an error means the program has reached the end of the file. Writing zero bytes does nothing. </P>

<P>An application can truncate or extend a file by using the <A HREF="_p1bh3.htm"><B>SetEndOfFile</B></A> function. This function sets the end of file to the current position of the file pointer. </P>

<P>When an application writes to a file, Windows usually collects the data being written in an internal buffer and writes the data to the disk on a regular basis. </P>

<P>An application can force the operating system to write the contents of the buffer to the disk by using the <A HREF="3oca9w0.htm"><B>FlushFileBuffers</B></A> function. Alternatively, an application can specify that write operations are to bypass the internal buffer and write directly to the disk by setting a flag when the file is created or opened by using the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function. </P>

<P>If there is data in the internal buffer when the file is closed, Windows does not automatically write the contents of the buffer to the disk before closing the file. If the application does not force the operating system to write the buffer to disk before closing the file, the caching algorithm determines when the buffer is written. </P>

<P>Applications must not read from nor write to the input buffer that a read operation is using until the read operation completes. A premature access to the input buffer may lead to corruption of the data read into that buffer.</P>

<P><B>Locking and Unlocking Files</B></P>

<P>Although Windows allows more than one application to open a file and write to it, applications must not write over each other's work. An application can prevent this problem by temporarily locking a region in a file. The <A HREF="egdiih.htm"><B>LockFile</B></A> and <A HREF="adh1lq.htm"><B>LockFileEx</B></A> functions lock a specified range of bytes in a file. The range may extend beyond the current end of the file. Locking part of a file prevents all other processes from reading or writing anywhere in the specified area. Attempts to read from or write to a region locked by another process always fail. </P>

<P>The <B>LockFileEx</B> function allows an application to specify either a <I>shared lock</I> or an <I>exclusive lock</I>. An exclusive lock denies all other processes both read and write access to the specified region of the file. A shared lock denies all processes write access to the specified region of the file, including the process that first locks the region. This can be used to create a read-only region in a file.</P>

<P>The application unlocks the region by using the <A HREF="2v.n6yp.htm"><B>UnlockFile</B></A> or <A HREF="1j9_05r.htm"><B>UnlockFileEx</B></A> function. An application should unlock all locked areas before closing a file. </P>

<P><B>Asynchronous Input and Output</B></P>

<P><I>Asynchronous input and output</I> (asynchronous I/O) allows some I/O functions to return immediately, even though an I/O request is still pending. Asynchronous I/O enables an application to continue with other processing and wait for the I/O to be completed at a later time. Asynchronous I/O is also called overlapped I/O. </P>

<P>The <A HREF="cjnd8p.htm"><B>ReadFile</B></A> and <A HREF="g0sox_.htm"><B>WriteFile</B></A> functions enable an application to specify an <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure that indicates where to position the file pointer before the read or write operation. The handle of the file being read from or written to must have been opened with the FILE_FLAG_OVERLAPPED flag. You can also create an event and put the handle in the <B>OVERLAPPED</B> structure; the <A HREF="y2tc_3.htm">wait functions</A> can then be used to wait for the I/O operation to complete by waiting on the event handle. </P>

<P>An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution. Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state. Each time an I/O operation is completed, the operating system sets the file handle to the signaled state. Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state. If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the <B>OVERLAPPED</B> structure for each I/O operation, rather than on the file handle. </P>

<P>To cancel all pending asynchronous I/O operations, use the <A HREF="62a8_h_.htm"><B>CancelIO</B></A> function. This function only cancels operations issued by the calling thread for the specified file handle. </P>

<P>The <A HREF="fm7wz7.htm"><B>ReadFileEx</B></A> and <A HREF="12g2wey.htm"><B>WriteFileEx</B></A> functions enable an application to specify a routine to execute (see <A HREF="axvori.htm"><B>FileIOCompletionRoutine</B></A>) when the asynchronous I/O request is completed. </P>

<P>For more information, see <A HREF="l05c8e.htm">Synchronization and Overlapped Input and Output</A>. </P>

<P><B>I/O Completion Ports</B></P>

<P>I/O completion ports are used with asynchronous I/O. The <A HREF="ka3.1p.htm"><B>CreateIoCompletionPort</B></A> function associates an I/O completion port with one or more file handles. When an asynchronous I/O operation started on a file handle associated with an I/O completion port is completed, an I/O completion packet is queued to the port. This can be used to combine the synchronization point for multiple file handles into a single object.</P>

<P>A thread uses the <A HREF="h734vj.htm"><B>GetQueuedCompletionStatus</B></A> function to wait for an I/O completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete. Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order. This means that when an I/O completion packet is queued to the I/O completion port, the system releases the last thread to block its execution on the port.</P>

<P>The most important property of an I/O completion port is the concurrency value. The concurrency value of an I/O completion port is specified when the I/O completion port is created. This value limits the number of runnable threads associated with the I/O completion port. When the total number of runnable threads associated with the I/O completion port reaches the concurrency value, the system blocks the execution of the threads until the number of runnable threads associated with the I/O completion port drops below the concurrency value. The most efficient scenario occurs when there are I/O completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit. In this case, when a running thread calls <B>GetQueuedCompletionStatus</B>, it will immediately pick up the queued I/O completion packet. No context switches will occur, because the running thread is continually picking up I/O completion packets and the other threads are unable to run.</P>

<P>The best value to pick for the concurrency value is the number of CPUs on the machine. If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run. Each transaction will take longer to complete, but more transactions will be processed at the same time. It is easy to experiment with the concurrency value to achieve the best effect for your application.</P>

<P>The <A HREF="8vixw6.htm"><B>PostQueuedCompletionStatus</B></A> function allows an application to queue its own special-purpose I/O completion packets to the I/O completion port without starting an asynchronous I/O operation. This is useful for notifying worker threads of external events.</P>

<P>The I/O completion port is freed when there are no more references to it. The port handle and every file handle associated with the I/O completion port reference the I/O completion port. All the handles must be closed to free the I/O completion port. To close the port handle, call the <A HREF="ngwwie.htm"><B>CloseHandle</B></A> function. </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
