<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using Shared Memory in a Dynamic-Link Library</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="wzrpsp"></A><B>Using Shared Memory in a Dynamic-Link Library</B></P>

<P>This section shows how the DLL entry-point function can use a file-mapping object to set up memory that can be shared by processes that load the DLL. The shared DLL memory persists only as long as the DLL is loaded. </P>

<P>The example uses file mapping to map a block of named shared memory into the virtual address space of each process that loads the DLL. To do this, the entry-point function must:</P>

<P>1.Call the <A HREF="3lck_3.htm"><B>CreateFileMapping</B></A> function to get a handle to a file-mapping object. The first process that loads the DLL creates the file-mapping object. Subsequent processes open a handle of the existing object. For more information, see <A HREF="euqw_y.htm">Creating a File-Mapping Object</A>.</P>

<P>2.Call the <A HREF="2a9rvat.htm"><B>MapViewOfFile</B></A> function to map a view into the virtual address space. This enables the process to access the shared memory. For more information, see <A HREF="1.9vee9.htm">Creating a File View</A>.</P>

<P></P>

<P>// File:  DLLSHMEM.C.  </P>

<P>// The DLL entry-point function sets up shared memory using  </P>

<P>// a named file-mapping object. </P>

<P>#include &lt;windows.h&gt; </P>

<P>#include &lt;memory.h&gt; </P>

<P></P>

<P>#define SHMEMSIZE 4096 </P>

<P></P>

<P>static LPVOID lpvMem = NULL; // pointer to shared memory</P>

<P></P>

<P>BOOL DllEntryPoint(HINSTANCE hinstDLL,  // DLL module handle</P>

<P>DWORD fdwReason,                    // reason called </P>

<P>LPVOID lpvReserved)                 // reserved </P>

<P>{ </P>

<P>HANDLE hMapObject = NULL;  // handle to file mapping</P>

<P>BOOL fInit, fIgnore; </P>

<P></P>

<P>switch (fdwReason) </P>

<P>{ </P>

<P>// The DLL is loading due to process </P>

<P>// initialization or a call to LoadLibrary. </P>

<P></P>

<P>case DLL<U>_</U>PROCESS<U>_</U>ATTACH: </P>

<P></P>

<P>// Create a named file mapping object.</P>

<P></P>

<P>hMapObject = CreateFileMapping( </P>

<P>(HANDLE) 0xFFFFFFFF, // use paging file</P>

<P>NULL,                // no security attributes</P>

<P>PAGE_READWRITE,      // read/write access</P>

<P>0,                   // size: high 32-bits</P>

<P>SHMEMSIZE,           // size: low 32-bits</P>

<P>"dllmemfilemap");    // name of map object</P>

<P>if (hMapObject == NULL) </P>

<P>return FALSE; </P>

<P></P>

<P>// The first process to attach initializes memory.</P>

<P></P>

<P>fInit = (GetLastError() != ERROR_ALREADY_EXISTS); </P>

<P></P>

<P>// Get a pointer to the file-mapped shared memory.</P>

<P></P>

<P>lpvMem = MapViewOfFile( </P>

<P>hMapObject,     // object to map view of</P>

<P>FILE_MAP_WRITE, // read/write access</P>

<P>0,              // high offset:  map from</P>

<P>0,              // low offset:   beginning</P>

<P>0);             // default: map entire file</P>

<P>if (lpvMem == NULL) </P>

<P>return FALSE; </P>

<P></P>

<P>// Initialize memory if this is the first process.</P>

<P></P>

<P>if (fInit) </P>

<P>memset(lpvMem, '\0', SHMEMSIZE); </P>

<P></P>

<P>break; </P>

<P></P>

<P>// The attached process creates a new thread. </P>

<P></P>

<P>case DLL<U>_</U>THREAD<U>_</U>ATTACH: </P>

<P>break; </P>

<P></P>

<P>// The thread of the attached process terminates.</P>

<P></P>

<P>case DLL<U>_</U>THREAD<U>_</U>DETACH: </P>

<P>break; </P>

<P></P>

<P>// The DLL is unloading from a process due to </P>

<P>// process termination or a call to FreeLibrary. </P>

<P></P>

<P>case DLL<U>_</U>PROCESS<U>_</U>DETACH: </P>

<P></P>

<P>// Unmap shared memory from the process's address space.</P>

<P></P>

<P>fIgnore = UnmapViewOfFile(lpvMem); </P>

<P></P>

<P>// Close the process's handle to the file-mapping object.</P>

<P></P>

<P>fIgnore = CloseHandle(hMapObject); </P>

<P></P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>return TRUE; </P>

<P>UNREFERENCED_PARAMETER(hinstDLL); </P>

<P>UNREFERENCED_PARAMETER(lpvReserved); </P>

<P>} </P>

<P></P>

<P>// SetSharedMem sets the contents of shared memory. </P>

<P></P>

<P>VOID SetSharedMem(LPTSTR lpszBuf) </P>

<P>{ </P>

<P>LPTSTR lpszTmp; </P>

<P></P>

<P>// Get the address of the shared memory block.</P>

<P></P>

<P>lpszTmp = (LPTSTR) lpvMem; </P>

<P></P>

<P>// Copy the null-terminated string into shared memory.</P>

<P></P>

<P>while (*lpszBuf) </P>

<P>*lpszTmp++ = *lpszBuf++; </P>

<P>*lpszTmp = '\0'; </P>

<P>} </P>

<P></P>

<P>// GetSharedMem gets the contents of shared memory. </P>

<P></P>

<P>VOID GetSharedMem(LPTSTR lpszBuf, DWORD cchSize) </P>

<P>{ </P>

<P>LPTSTR lpszTmp; </P>

<P></P>

<P>// Get the address of the shared memory block.</P>

<P></P>

<P>lpszTmp = (LPTSTR) lpvMem; </P>

<P></P>

<P>// Copy from shared memory into the caller's buffer.</P>

<P></P>

<P>while (*lpszTmp &amp;&amp; --cchSize) </P>

<P>*lpszBuf++ = *lpszTmp++; </P>

<P>*lpszBuf = '\0'; </P>

<P>} </P>

<P></P>

<P>Note that the shared memory can be mapped to a different address in each process. For this reason, each process has its own instance of the <I>lpvMem </I>parameter, which is declared as a global variable so that it is available to all DLL functions. The example assumes that the DLL global data is not shared, so each process that loads the DLL has its own instance of <I>lpvMem</I>. </P>

<P>In this example, the shared memory is released when the last handle of the file-mapping object is closed. To create persistent shared memory, a DLL can create a detached process (see <A HREF="5fbj_xx.htm"><B>CreateProcess</B></A>) when the DLL is first loaded. If this detached process uses the DLL and does not terminate, it has a handle of the file-mapping object that prevents the shared memory from being released. </P>

</BODY>
</HTML>
