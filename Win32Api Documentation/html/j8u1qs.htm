<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Transactions on Named Pipes</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="j8u1qs"></A><B>Transactions on Named Pipes</B></P>

<P>A named pipe transaction is a client-server communication that combines a write operation and a read operation into a single network operation. A transaction can be used only on a duplex, message-type pipe. Transactions improve the performance of network communications between a client and a remote server. Processes can use the <A HREF="1nuxhmk.htm"><B>TransactNamedPipe</B></A> and <A HREF="6xlg_2.htm"><B>CallNamedPipe</B></A> functions to perform named pipe transactions. </P>

<P><B>TransactNamedPipe</B> is typically used by a client process to write a request message to the named pipe server and read the server's response message. The client process must specify GENERIC_READ | GENERIC_WRITE access when it opens its pipe handle by calling the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function. Then, the client process sets the pipe handle to message-read mode by calling the <A HREF="ap5lb1.htm"><B>SetNamedPipeHandleState</B></A> function. If the read buffer specified in the call to <B>TransactNamedPipe</B> is not large enough to hold the entire message written by the server, the function returns FALSE and <A HREF="11c2vs7.htm"><B>GetLastError</B></A> returns ERROR_MORE_DATA. The client can read the remainder of the message by calling either the <A HREF="cjnd8p.htm"><B>ReadFile</B></A>, <A HREF="fm7wz7.htm"><B>ReadFileEx</B></A>, or <A HREF="3ie31.htm"><B>PeekNamedPipe</B></A><B> </B>function. </P>

<P><B>TransactNamedPipe</B> is typically called by client processes, but can also be used by a server process. </P>

<P>The following example shows a client process using <B>TransactNamedPipe</B>. The example assumes that the client process has used <B>CreateFile</B> to connect to the pipe and <B>SetNamedPipeHandleState</B> to set the pipe handle's read mode, as shown in the client process example in the preceding section. </P>

<P>fSuccess = TransactNamedPipe(  </P>

<P>hPipe,               // pipe handle </P>

<P>lpszWrite,           // message to server </P>

<P>strlen(lpszWrite)+1, // message length </P>

<P>chReadBuf,           // buffer to receive reply </P>

<P>512,                 // size of read buffer </P>

<P>&amp;cbRead,             // number of bytes read </P>

<P>NULL);               // not overlapped </P>

<P></P>

<P>// Exit if an error occurs, unless the error indicates there is more </P>

<P>// data in the message. </P>

<P></P>

<P>if (!fSuccess &amp;&amp; (GetLastError() != ERROR_MORE_DATA)) </P>

<P>MyErrExit("TransactNamedPipe"); </P>

<P></P>

<P>while(1) </P>

<P>{ </P>

<P>// Data from the pipe is written to STDOUT. </P>

<P></P>

<P>if (! WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), </P>

<P>chReadBuf, cbRead, &amp;cbWritten, NULL) ) </P>

<P>break; </P>

<P></P>

<P>// Break if TransactNamedPipe or ReadFile is successful. </P>

<P></P>

<P>if (fSuccess) </P>

<P>break; </P>

<P></P>

<P>// Read from the pipe if there is more data in the message.</P>

<P></P>

<P>fSuccess = ReadFile( </P>

<P>hPipe,      // pipe handle </P>

<P>chReadBuf,  // buffer to receive reply </P>

<P>512,        // size of buffer </P>

<P>&amp;cbRead,    // number of bytes read </P>

<P>NULL);      // not overlapped </P>

<P></P>

<P>// Exit if an error other than ERROR_MORE_DATA occurs. </P>

<P></P>

<P>if (! fSuccess &amp;&amp; (GetLastError() != ERROR_MORE_DATA)) </P>

<P>break; </P>

<P>} </P>

<P></P>

<P>A client process uses <A HREF="6xlg_2.htm"><B>CallNamedPipe</B></A> to combine calling the <A HREF="xn35yd.htm"><B>CreateFile</B></A>, <A HREF="1xsezn8.htm"><B>WaitNamedPipe</B></A> (if necessary), <A HREF="1nuxhmk.htm"><B>TransactNamedPipe</B></A>, and <A HREF="ngwwie.htm"><B>CloseHandle</B></A> function into a single call. Because the pipe handle is closed before the function returns, any additional bytes in the message are lost if the message is larger than the specified size of the read buffer. The following example shows the use of <B>CallNamedPipe</B>. </P>

<P>// Combines connect, wait, write, read, and close operations.  </P>

<P></P>

<P>fSuccess = CallNamedPipe( </P>

<P>lpszPipename,        // pipe name </P>

<P>lpszWrite,           // message to server </P>

<P>strlen(lpszWrite)+1, // message length </P>

<P>chReadBuf,           // buffer to receive reply </P>

<P>512,                 // size of read buffer </P>

<P>&amp;cbRead,             // number of bytes read </P>

<P>20000);              // waits for 20 seconds </P>

<P></P>

<P>if (fSuccess || GetLastError() == ERROR_MORE_DATA) </P>

<P>{ </P>

<P></P>

<P>// Data from the pipe is written to STDOUT. </P>

<P></P>

<P>WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), </P>

<P>chReadBuf, cbRead, &amp;cbWritten, NULL); </P>

<P></P>

<P>// The pipe is closed, so no more bytes can be read from the </P>

<P>// message. </P>

<P></P>

<P>if (! fSuccess) </P>

<P>printf("\n...extra data in message was lost\n"); </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
