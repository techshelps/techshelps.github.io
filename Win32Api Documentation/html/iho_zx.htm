<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Sender Code Example</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="iho_zx"></A><B>Sender Code Example</B></P>

<P>This section shows the code needed on the sending user side to implement the three-phase key exchange protocol. The details of the communication between the sending user and the destination user are not shown, because these will be different for each implementation.</P>

<P>For purposes of readability, this example and the following one blatantly avoid good programming practice in two major ways:</P>

<P>·No error checking is shown. A working program should always check the returned error codes and perform some appropriate action when an error is encountered.</P>

<P>·Fixed-length buffers are used to store key blobs and hash values. In practice, these buffers should be allocated dynamically, because this data will vary in size depending on the CSP used.</P>

<P></P>

<P>#include &lt;wincrypt.h&gt;</P>

<P></P>

<P>HCRYPTPROV hProv = 0;</P>

<P>#define NAME_SIZE 256</P>

<P>BYTE pbDestName[NAME_SIZE];</P>

<P>DWORD dwDestNameLen;</P>

<P>BYTE pbSendName[NAME_SIZE];</P>

<P>DWORD dwSendNameLen;</P>

<P>HCRYPTKEY hDestPubKey = 0;</P>

<P>HCRYPTKEY hKeyA = 0;</P>

<P>HCRYPTKEY hKeyB = 0;</P>

<P>#define BLOB_SIZE 256</P>

<P>BYTE pbKeyBlob[BLOB_SIZE];</P>

<P>DWORD dwBlobLen;</P>

<P>#define HASH_SIZE 256</P>

<P>BYTE pbHash[HASH_SIZE];</P>

<P>DWORD dwHashLen;</P>

<P>BYTE pbDestHash[HASH_SIZE];</P>

<P>DWORD dwDestHashLen;</P>

<P>HCRYPTHASH hHash = 0;</P>

<P>// Get handle to the default provider.</P>

<P>CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0);</P>

<P>// Obtain the destination user's exchange public key. Import it into</P>

<P>// the CSP and place a handle to it in 'hDestPubKey'.</P>

<P>...</P>

<P>CryptGetUserKey(hProv, AT_KEYEXCHANGE, &amp;hDestPubKey);</P>

<P>// Obtain the destination user's name. This is usually done at the</P>

<P>// same time as the public key was obtained. Place this in </P>

<P>// 'pbDestName' and set 'dwDestNameLen' to the number of bytes in </P>

<P>// the name.</P>

<P>...</P>

<P>// Place the sending user's name in 'pbSendName' and set </P>

<P>// 'dwSendNameLen' to the number of bytes in it.</P>

<P>...</P>

<P>// Create a random session key (session key A). Because this key will</P>

<P>// be used solely for key exchange and not encryption, it </P>

<P>// does not matter which algorithm you specify here.</P>

<P>CryptGenKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &amp;hKeyA);</P>

<P>// Export session key A into a simple key blob.</P>

<P>dwBlobLen = BLOB_SIZE;</P>

<P>CryptExportKey(hKeyA, hDestPubKey, SIMPLEBLOB, 0, pbKeyBlob, &amp;dwBlobLen);</P>

<P>// Send key blob containing session key A to the destination user.</P>

<P>...</P>

<P>// Wait for the destination user to respond.</P>

<P>...</P>

<P>// Receive a key blob containing session key B from the destination </P>

<P>// user and place it in 'pbKeyBlob'. Set 'dwBlobLen' to the number </P>

<P>// of bytes in the key blob.</P>

<P>...</P>

<P>// Receive a hash value from the destination user and place it in</P>

<P>// 'pbHashValue'. Set 'dwHashLen' to the number of bytes in the hash </P>

<P>// value.</P>

<P>...</P>

<P>// Import the key blob into the CSP.</P>

<P>CryptImportKey(hProv, pbKeyBlob, dwBlobLen, 0, 0, &amp;hKeyB);</P>

<P>//</P>

<P>// Verify hash value received from the destination user.</P>

<P>//</P>

<P>// Create hash object.</P>

<P>CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash);</P>

<P>// Add session key A to hash.</P>

<P>CryptHashSessionKey(hHash, hKeyA, 0);</P>

<P>// Add destination user's name to hash.</P>

<P>CryptHashData(hHash, pbDestName, dwDestNameLen, 0);</P>

<P>// Add session key B to hash.</P>

<P>CryptHashSessionKey(hHash, hKeyB, 0);</P>

<P>// Add sending user's name to hash.</P>

<P>CryptHashData(hHash, pbSendName, dwSendNameLen, 0);</P>

<P>// Add "phase 2" text to hash.</P>

<P>CryptHashData(hHash, "phase 3", 7, 0);</P>

<P>// Complete the hash computation and retrieve the hash value.</P>

<P>dwHashLen = HASH_SIZE;</P>

<P>CryptGetHashParam(hHash, HP_HASHVALUE, pbHash, &amp;dwHashLen, 0);</P>

<P>// Destroy the hash object.</P>

<P>CryptDestroyHash(hHash);</P>

<P>//</P>

<P>// Compare the hash value received from the destination user with </P>

<P>// the hash value that we just computed. If they do not match, then </P>

<P>// terminate the protocol.</P>

<P>//</P>

<P>if(dwHashLen!=dwDestHashLen || memcmp(pbHash, pbDestHash, dwHashLen)) {</P>

<P>printf("Key exchange protocol failed in phase 2!\n");</P>

<P>printf("Aborting protocol!\n");</P>

<P>return;</P>

<P>}</P>

<P>//</P>

<P>// Compute hash to be sent to the destination user.</P>

<P>//</P>

<P>// Create hash object.</P>

<P>CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash);</P>

<P>// Add session key B to hash.</P>

<P>CryptHashSessionKey(hHash, hKeyB, 0);</P>

<P>// Add sending user's name to hash.</P>

<P>CryptHashData(hHash, pbSendName, dwSendNameLen, 0);</P>

<P>// Add destination user's name to hash.</P>

<P>CryptHashData(hHash, pbDestName, dwDestNameLen, 0);</P>

<P>// Add "phase 3" text to hash.</P>

<P>CryptHashData(hHash, "phase 3", 7, 0);</P>

<P>// Complete the hash computation and retrieve the hash value.</P>

<P>dwHashLen = HASH_SIZE;</P>

<P>CryptGetHashParam(hHash, HP_HASHVALUE, pbHash, &amp;dwHashLen, 0);</P>

<P>// Destroy the hash object.</P>

<P>CryptDestroyHash(hHash);</P>

<P>// Send the hash value to the destination user.</P>

<P>...</P>

<P>//</P>

<P>// Use session key A to encrypt messages sent to the receiver.</P>

<P>// Use session key B to decrypt messages received from the receiver.</P>

<P>//</P>

<P>...</P>

<P>// Destroy session keys.</P>

<P>CryptDestroyKey(hKeyA);</P>

<P>CryptDestroyKey(hKeyB);</P>

<P>// Release provider handle.</P>

<P>CryptReleaseContext(hProv, 0);</P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
