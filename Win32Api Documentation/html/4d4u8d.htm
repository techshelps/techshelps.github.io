<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using Filled Shapes</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="4d4u8d"></A><B>Using Filled Shapes</B></P>

<P>This section illustrates how to use filled shape functions. The example uses the main window procedure from an application that enables the user to draw ellipses, rectangles, and rectangles with rounded corners. </P>

<P>The user draws a filled shape by selecting a particular shape from the menu, positioning the cursor at the upper left corner of the shape (or the shape's bounding rectangle in the case of an ellipse), and then dragging the mouse until the desired dimensions are obtained. </P>

<P>The following illustration shows three filled shapes drawn using the sample code in this section. </P>

<P><IMG SRC="../images/bm76.gif" ALT="" BORDER=0></P>

<P>To enable the user to draw filled shapes, include the following code in your application. </P>

<P>LRESULT APIENTRY MainWndProc(hwnd, uMsg, wParam, lParam)  </P>

<P>HWND hwnd;      /* handle of window         */ </P>

<P>UINT uMsg;      /* message                  */ </P>

<P>WPARAM wParam;  /* first message parameter  */ </P>

<P>LPARAM lParam;  /* second message parameter */ </P>

<P>{ </P>

<P>HDC hdc;         /* handle of device context (DC)   */ </P>

<P>PAINTSTRUCT ps;  /* paint data for Begin/EndPaint   */ </P>

<P>POINT ptClientUL; /* client area upper left corner  */ </P>

<P>POINT ptClientLR; /* client area lower right corner */ </P>

<P>static HDC hdcCompat;/* handle of DC for bitmap     */ </P>

<P>static POINT pt;     /* x- and y-coordinates of cursor    */ </P>

<P>static RECT rcTarget; /* rect to receive filled shape     */ </P>

<P>static RECT rcClient; /* client area rectangle            */ </P>

<P>static BOOL fSizeEllipse; /* TRUE if ellipse is sized     */ </P>

<P>static BOOL fDrawEllipse;   /* TRUE if ellipse is drawn   */ </P>

<P>static BOOL fDrawRectangle; /* TRUE if rectangle is drawn */ </P>

<P>static BOOL fSizeRectangle; /* TRUE if rectangle is sized */ </P>

<P>static BOOL fSizeRoundRect; /* TRUE if rounded rect is sized */ </P>

<P>static BOOL fDrawRoundRect; /* TRUE if rounded rect is drawn */ </P>

<P>static int nEllipseWidth;   /* width for round corners       */ </P>

<P>static int nEllipseHeight;  /* height for round corners      */ </P>

<P></P>

<P>switch (uMsg) { </P>

<P></P>

<P>case WM_COMMAND: </P>

<P>switch (wParam) { </P>

<P></P>

<P>/* </P>

<P>* Set the appropriate flag to indicate which </P>

<P>* filled shape the user is drawing. </P>

<P>*/ </P>

<P></P>

<P>case IDM_ELLIPSE: </P>

<P>fSizeEllipse = TRUE; </P>

<P>break; </P>

<P></P>

<P>case IDM_RECTANGLE: </P>

<P>fSizeRectangle = TRUE; </P>

<P>break; </P>

<P></P>

<P>case IDM_ROUNDRECT: </P>

<P>fSizeRoundRect = TRUE; </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>return DefWindowProc(hwnd, uMsg, wParam, </P>

<P>lParam); </P>

<P>} </P>

<P>break; </P>

<P></P>

<P></P>

<P>case WM_CREATE: </P>

<P></P>

<P>nEllipseWidth = 20; </P>

<P>nEllipseHeight = 20; </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>case WM_PAINT: </P>

<P></P>

<P></P>

<P>BeginPaint(hwnd, &amp;ps); </P>

<P></P>

<P>/* </P>

<P>* Because the default brush is white, select </P>

<P>* a different brush into the device context </P>

<P>* to demonstrate the painting of filled shapes. </P>

<P>*/ </P>

<P></P>

<P>SelectObject(ps.hdc, GetStockObject(GRAY_BRUSH)); </P>

<P></P>

<P>/* </P>

<P>* If one of the filled shape "draw" flags is TRUE, </P>

<P>* draw the corresponding shape. </P>

<P>*/ </P>

<P></P>

<P>if (fDrawEllipse) { /* draws ellipse */ </P>

<P>Ellipse(ps.hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom); </P>

<P>fDrawEllipse = FALSE; </P>

<P>rcTarget.left = rcTarget.right = 0; </P>

<P>rcTarget.top = rcTarget.bottom = 0; </P>

<P>} </P>

<P></P>

<P>if (fDrawRectangle) { /* Draws rectangle */ </P>

<P>Rectangle(ps.hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom); </P>

<P>fDrawRectangle = FALSE; </P>

<P>rcTarget.left = rcTarget.right = 0; </P>

<P>rcTarget.top = rcTarget.bottom = 0; </P>

<P>} </P>

<P></P>

<P>if (fDrawRoundRect) { /* Draws rounded rectangle */ </P>

<P>RoundRect(ps.hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom, </P>

<P>nEllipseWidth, nEllipseHeight); </P>

<P>fDrawRectangle = FALSE; </P>

<P>rcTarget.left = rcTarget.right = 0; </P>

<P>rcTarget.top = rcTarget.bottom = 0; </P>

<P>} </P>

<P></P>

<P>EndPaint(hwnd, &amp;ps); </P>

<P>break; </P>

<P></P>

<P>case WM_SIZE: </P>

<P></P>

<P>/* </P>

<P>* Convert the client coordinates of the client area </P>

<P>* rectangle to screen coordinates and save them in a </P>

<P>* rectangle. The rectangle is passed to the ClipCursor </P>

<P>* function during WM_LBUTTONDOWN processing. </P>

<P>*/ </P>

<P></P>

<P>GetClientRect(hwnd, &amp;rcClient); </P>

<P>ptClientUL.x = rcClient.left; </P>

<P>ptClientUL.y = rcClient.top; </P>

<P>ptClientLR.x = rcClient.right; </P>

<P>ptClientLR.y = rcClient.bottom; </P>

<P>ClientToScreen(hwnd, &amp;ptClientUL); </P>

<P>ClientToScreen(hwnd, &amp;ptClientLR); </P>

<P>SetRect(&amp;rcClient, ptClientUL.x, ptClientUL.y, </P>

<P>ptClientLR.x, ptClientLR.y); </P>

<P>return 0; </P>

<P></P>

<P>case WM_LBUTTONDOWN: </P>

<P></P>

<P>/* </P>

<P>* Restrict the cursor to the client area. </P>

<P>* This ensures that the window receives a matching </P>

<P>* WM_LBUTTONUP message. </P>

<P>*/ </P>

<P></P>

<P>ClipCursor(&amp;rcClient); </P>

<P></P>

<P>/* Save the coordinates of the cursor. */ </P>

<P></P>

<P>pt.x = (LONG) LOWORD(lParam); </P>

<P>pt.y = (LONG) HIWORD(lParam); </P>

<P></P>

<P>/* </P>

<P>* If the user chooses one of the filled shapes, </P>

<P>* set the appropriate flag to indicate that the </P>

<P>* shape is being sized. </P>

<P>*/ </P>

<P></P>

<P>if (fDrawEllipse) </P>

<P>fSizeEllipse = TRUE; </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>case WM_MOUSEMOVE: </P>

<P></P>

<P>/* </P>

<P>* If one of the "size" flags is set, draw </P>

<P>* the target rectangle as the user drags </P>

<P>* the mouse. </P>

<P>*/ </P>

<P></P>

<P>if ((wParam &amp;&amp; MK_LBUTTON) </P>

<P>&amp;&amp; (fSizeEllipse || fSizeRectangle </P>

<P>|| fSizeRoundRect)) {  /* draws target rect. */ </P>

<P></P>

<P>/* </P>

<P>* Set the mixing mode so that the pen color is the </P>

<P>* inverse of the background color. The previous </P>

<P>* rectangle can then be erased by drawing </P>

<P>* another rectangle on top of it. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P>SetROP2(hdc, R2_NOTXORPEN); </P>

<P></P>

<P>/* </P>

<P>* If a previous target rectangle exists, erase </P>

<P>* it by drawing another rectangle on top. </P>

<P>*/ </P>

<P></P>

<P>if (!IsRectEmpty(&amp;rcTarget)) </P>

<P>Rectangle(hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom); </P>

<P></P>

<P>/* </P>

<P>* Save the coordinates of the target rectangle. </P>

<P>* Avoid invalid rectangles by ensuring that the </P>

<P>* value of the left coordinate is greater than </P>

<P>* that of the right, and that the value of the </P>

<P>* bottom coordinate is greater than that of </P>

<P>* the top. </P>

<P>*/ </P>

<P></P>

<P>if ((pt.x &lt; (LONG) LOWORD(lParam)) &amp;&amp; </P>

<P>(pt.y &gt; (LONG) HIWORD(lParam))) </P>

<P>SetRect(&amp;rcTarget, pt.x, HIWORD(lParam), </P>

<P>LOWORD(lParam), pt.y); </P>

<P></P>

<P>else if ((pt.x &gt; (LONG) LOWORD(lParam)) &amp;&amp; </P>

<P>(pt.y &gt; (LONG) HIWORD(lParam))) </P>

<P>SetRect(&amp;rcTarget, LOWORD(lParam), </P>

<P>HIWORD(lParam), pt.x, pt.y); </P>

<P></P>

<P>else if ((pt.x &gt; (LONG) LOWORD(lParam)) &amp;&amp; </P>

<P>(pt.y &lt; (LONG) HIWORD(lParam))) </P>

<P>SetRect(&amp;rcTarget, LOWORD(lParam), pt.y, </P>

<P>pt.x, HIWORD(lParam)); </P>

<P>else </P>

<P>SetRect(&amp;rcTarget, pt.x, pt.y, LOWORD(lParam), </P>

<P>HIWORD(lParam)); </P>

<P></P>

<P>/* Draw the new target rectangle. */ </P>

<P></P>

<P>Rectangle(hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P>} </P>

<P>return 0; </P>

<P></P>

<P>case WM_LBUTTONUP: </P>

<P></P>

<P>/* </P>

<P>* If one of the "size" flags is TRUE, reset </P>

<P>* it to FALSE, and then set the corresponding </P>

<P>* "draw" flag. </P>

<P>* Invalidate the appropriate rectangle and issue </P>

<P>* a WM_PAINT message. </P>

<P>*/ </P>

<P></P>

<P>if (fSizeEllipse) { </P>

<P>fSizeEllipse = FALSE; </P>

<P>fDrawEllipse = TRUE; </P>

<P>} </P>

<P></P>

<P>if (fSizeRectangle) { </P>

<P>fSizeRectangle = FALSE; </P>

<P>fDrawRectangle = TRUE; </P>

<P>} </P>

<P></P>

<P>if (fSizeRoundRect) { </P>

<P>fSizeRoundRect = FALSE; </P>

<P>fDrawRoundRect = TRUE; </P>

<P>} </P>

<P></P>

<P>if (fDrawEllipse || fDrawRectangle || fDrawRoundRect) </P>

<P>{ </P>

<P>InvalidateRect(hwnd, &amp;rcTarget, TRUE); </P>

<P>UpdateWindow(hwnd); </P>

<P>} </P>

<P></P>

<P>/* Release the cursor. */ </P>

<P></P>

<P>ClipCursor((LPRECT) NULL); </P>

<P>return 0; </P>

<P></P>

<P>case WM_DESTROY: </P>

<P></P>

<P>/* </P>

<P>* Destroy the background brush, compatible bitmap, </P>

<P>* and bitmap. </P>

<P>*/ </P>

<P></P>

<P>DeleteDC(hdcCompat); </P>

<P>PostQuitMessage(0); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>return DefWindowProc(hwnd, uMsg, wParam, lParam); </P>

<P>} </P>

<P>return (LRESULT) NULL; </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
