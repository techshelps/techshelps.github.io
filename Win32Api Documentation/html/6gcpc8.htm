<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>SetConsoleCtrlHandler</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="6gcpc8"></A><B>SetConsoleCtrlHandler  <A HREF="1ns3lvz.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="7re1xz.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF=".hu4wz.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>SetConsoleCtrlHandler</B> function adds or removes an application-defined <A HREF="22s.avo.htm"><B>HandlerRoutine</B></A> function from the list of handler functions for the calling process. If no handler function is specified, the function sets an inheritable attribute that determines whether the calling process ignores CTRL+C signals. </P>

<P><B>BOOL SetConsoleCtrlHandler(</B></P>

<TABLE cols=2 width=501>

<TR VALIGN="top">
<TD width=57%><B>PHANDLER_ROUTINE</B> <I>HandlerRoutine</I><B>,</B></TD>
<TD width=43%>// address of handler function  </TD>
</TR>

<TR VALIGN="top">
<TD width=57%><B>    BOOL</B> <I>Add</I> </TD>
<TD width=43%>// handler to add or remove </TD>
</TR>

<TR VALIGN="top">
<TD width=57%><B>   );</B></TD>
<TD width=43%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>HandlerRoutine</I></P>

<P>Points to the application-defined <A HREF="22s.avo.htm"><B>HandlerRoutine</B></A> function to add or remove. This parameter can be NULL. </P>

<P><I>Add</I></P>

<P>Specifies whether to add or remove the function pointed to by the <I>HandlerRoutine</I> parameter from the handler list. If this parameter is TRUE, the handler is added; if it is FALSE, the handler is removed. </P>

<P>If the <I>HandlerRoutine</I> parameter is NULL, a TRUE value causes the calling process to ignore CTRL+C input, and a FALSE value restores normal processing of CTRL+C input. This attribute of ignoring or processing CTRL+C is inherited by child processes. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Remarks</B></P>

<P>Each console process has its own list of application-defined <A HREF="22s.avo.htm"><B>HandlerRoutine</B></A> functions that handle CTRL+C and CTRL+BREAK signals. The handler functions also handle signals generated by the system when the user closes the console, logs off, or shuts down the system. Initially, the handler list for each process contains only a default handler function that calls the <A HREF="i5ihdk.htm"><B>ExitProcess</B></A> function. A console process adds or removes additional handler functions by calling the <B>SetConsoleCtrlHandler</B> function, which does not affect the list of handler functions for other processes. When a console process receives any of the control signals, its handler functions are called on a last-registered, first-called basis until one of the handlers returns TRUE. If none of the handlers returns TRUE, the default handler is called. </P>

<P>For console processes, the CTRL+C and CTRL+BREAK key combinations are typically treated as signals (CTRL_C_EVENT and CTRL_C_BREAK_EVENT). When a console window with the keyboard focus receives CTRL+C or CTRL+BREAK, the signal is typically passed to all processes sharing that console. </P>

<P>CTRL+BREAK is always treated as a signal, but typical CTRL+C behavior can be changed in three ways that prevent the handler functions from being called:</P>

<P>·The <A HREF="3210qe3.htm"><B>SetConsoleMode</B></A> function can disable the <B>ENABLE_PROCESSED_INPUT</B> mode for a console's input buffer, so CTRL+C is reported as keyboard input rather than as a signal. </P>

<P>·Calling <B>SetConsoleCtrlHandler</B> with the NULL and TRUE arguments causes the calling process to ignore CTRL+C signals. This attribute is inherited by child processes, but it can be enabled or disabled by any process without affecting existing processes. </P>

<P>·If a console process is being debugged and CTRL+C signals have not been disabled, the kernel generates a DBG_CONTROL_C exception. This exception is raised only for the benefit of the debugger, and an application should never use an exception handler to deal with it. If the debugger handles the exception, an application will not notice the CTRL+C, with one exception: alertable waits will terminate. If the debugger passes the exception on unhandled, CTRL+C is passed to the console process and treated as a signal, as previously discussed. </P>

<P></P>

<P>A console process can use the <B>GenerateConsoleCtrlEvent</B> function to send a CTRL+C or CTRL+BREAK signal to a console process group. </P>

<P>The system generates CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, and CTRL_SHUTDOWN_EVENT signals when the user closes the console, logs off, or shuts down the system so that the process has an opportunity to clean up before termination. Console functions, or any C run-time functions that call console functions, may not work reliably during processing of any of the three signals mentioned previously. The reason is that some or all of the internal console cleanup routines may have been called before executing the process signal handler. </P>

<P><B>See Also</B></P>

<P><A HREF="i5ihdk.htm"><B>ExitProcess</B></A>, <A HREF="19h8n57.htm"><B>GenerateConsoleCtrlEvent</B></A>, <A HREF="1n6qct..htm"><B>GetConsoleMode</B></A>, <A HREF="22s.avo.htm"><B>HandlerRoutine</B></A>, <A HREF="3210qe3.htm"><B>SetConsoleMode</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
