<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Creating User-Editable Accelerators</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="dwcty5"></A><B>Creating User-Editable Accelerators</B></P>

<P>This example shows how to construct a dialog box that allows the user to change the accelerator associated with a menu item. The dialog box consists of a combo box containing menu items, a combo box containing the names of keys, and check boxes for selecting the CTRL, ALT, and SHIFT keys. The following illustration shows the dialog box. </P>

<P><IMG SRC="../images/bm20.gif" ALT="" BORDER=0></P>

<P>The following example shows how the dialog box is defined in the resource-definition file. </P>

<P>EdAccelBox DIALOG 5, 17, 193, 114  </P>

<P>STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION </P>

<P>CAPTION "Edit Accelerators" </P>

<P>BEGIN </P>

<P>COMBOBOX        IDD_MENUITEMS, 10, 22, 52, 53, </P>

<P>CBS_SIMPLE | CBS_SORT | WS_VSCROLL | </P>

<P>WS_TABSTOP </P>

<P>CONTROL         "Control", IDD_CNTRL, "Button", </P>

<P>BS_AUTOCHECKBOX | WS_TABSTOP, </P>

<P>76, 35, 40, 10 </P>

<P>CONTROL         "Alt", IDD_ALT, "Button", </P>

<P>BS_AUTOCHECKBOX | WS_TABSTOP, </P>

<P>76, 48, 40, 10 </P>

<P>CONTROL         "Shift", IDD_SHIFT, "Button", </P>

<P>BS_AUTOCHECKBOX | WS_TABSTOP, </P>

<P>76, 61, 40, 10 </P>

<P>COMBOBOX        IDD_KEYSTROKES, 124, 22, 58, 58, </P>

<P>CBS_SIMPLE | CBS_SORT | WS_VSCROLL | </P>

<P>WS_TABSTOP </P>

<P>PUSHBUTTON      "Ok", IDOK, 43, 92, 40, 14 </P>

<P>PUSHBUTTON      "Cancel", IDCANCEL, 103, 92, 40, 14 </P>

<P>LTEXT           "Select Item:", 101, 10, 12, 43, 8 </P>

<P>LTEXT           "Select Keystroke:", 102, 123, 12, 60, 8 </P>

<P>END </P>

<P></P>

<P>The dialog box uses an array of application-defined VKEY structures, each containing a keystroke-text string and an accelerator-text string. When the dialog box is created, it parses the array and adds each keystroke-text string to the Select Keystroke combo box. When the user clicks the Ok button, the dialog box looks up the selected keystroke-text string and retrieves the corresponding accelerator-text string. The dialog box appends the accelerator-text string to the text of the menu item that the user selected. The following example shows the array of VKEY structures: </P>

<P>/* VKey Lookup Support */  </P>

<P></P>

<P>#define MAXKEYS 26 </P>

<P></P>

<P>typedef struct _VKEYS { </P>

<P>char *pKeyName; </P>

<P>char *pKeyString; </P>

<P>} VKEYS; </P>

<P></P>

<P>VKEYS vkeys[MAXKEYS] = { </P>

<P>"BkSp",     "Back Space", </P>

<P>"PgUp",     "Page Up", </P>

<P>"PgDn",     "Page Down", </P>

<P>"End",      "End", </P>

<P>"Home",     "Home", </P>

<P>"Lft",      "Left", </P>

<P>"Up",       "Up", </P>

<P>"Rgt",      "Right", </P>

<P>"Dn",       "Down", </P>

<P>"Ins",      "Insert", </P>

<P>"Del",      "Delete", </P>

<P>"Mult",     "Multiply", </P>

<P>"Add",      "Add", </P>

<P>"Sub",      "Subtract", </P>

<P>"DecPt",    "Decimal Point", </P>

<P>"Div",      "Divide", </P>

<P>"F2",       "F2", </P>

<P>"F3",       "F3", </P>

<P>"F5",       "F5", </P>

<P>"F6",       "F6", </P>

<P>"F7",       "F7", </P>

<P>"F8",       "F8", </P>

<P>"F9",       "F9", </P>

<P>"F11",      "F11", </P>

<P>"F12",      "F12" </P>

<P>}; </P>

<P></P>

<P>The dialog box's initialization procedure fills the Select Item and Select Keystroke combo boxes. After the user selects a menu item and associated accelerator, the dialog box examines the controls in the dialog box to get the user's selection, updates the text of the menu item, and then creates a new accelerator table that contains the user-defined new accelerator. The following example shows the dialog-box procedure. </P>

<P>/* Global variables */  </P>

<P></P>

<P>HWND hwndMain;      /* handle of main window          */ </P>

<P>HANDLE hinstAcc;    /* handle of application instance */ </P>

<P>HACCEL haccel;      /* handle of accelerator table    */ </P>

<P></P>

<P>. </P>

<P>. </P>

<P>. </P>

<P></P>

<P>/* Dialog-box procedure */ </P>

<P></P>

<P>LRESULT CALLBACK EdAccelProc(hwndDlg, uMsg, wParam, lParam) </P>

<P>HWND hwndDlg; </P>

<P>UINT uMsg; </P>

<P>WPARAM wParam; </P>

<P>LPARAM lParam; </P>

<P>{ </P>

<P>int nCurSel;            /* index of list box item          */ </P>

<P>UINT idItem;            /* menu-item identifier            */ </P>

<P>UINT uItemPos;          /* menu-item position              */ </P>

<P>UINT i, j = 0;          /* loop counters                   */ </P>

<P>static UINT cItems;     /* count of items in menu          */ </P>

<P>char szTemp[32];        /* temporary buffer                */ </P>

<P>char szAccelText[32];   /* buffer for accelerator text     */ </P>

<P>char szKeyStroke[16];   /* buffer for keystroke text       */ </P>

<P>static char szItem[32]; /* buffer for menu-item text       */ </P>

<P>HWND hwndCtl;           /* handle of control window        */ </P>

<P>static HMENU hmenu;     /* handle of "Character" menu      */ </P>

<P>PCHAR pch, pch2;        /* pointers for string copying     */ </P>

<P>WORD wVKCode;           /* accelerator virtual-key code    */ </P>

<P>BYTE fAccelFlags;       /* fVirt flags for ACCEL structure */ </P>

<P>LPACCEL lpaccelNew;     /* address of new accel. table     */ </P>

<P>HACCEL haccelOld;       /* handle of old accel. table      */ </P>

<P>int cAccelerators;      /* number of accelerators in table */ </P>

<P>static BOOL fItemSelected = FALSE; /* item selection flag  */ </P>

<P>static BOOL fKeySelected = FALSE;  /* key selection flag   */ </P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_INITDIALOG: </P>

<P></P>

<P>/* Get the handle of the menu-item combo box. */ </P>

<P></P>

<P>hwndCtl = GetDlgItem(hwndDlg, IDD_MENUITEMS); </P>

<P></P>

<P>/* </P>

<P>* The application's menu bar contains a "Character" </P>

<P>* submenu whose items have accelerators associated </P>

<P>* with them. Get the handle of the "Character" </P>

<P>* submenu (its position within the main menu is 2), </P>

<P>* and count the number of items it has. </P>

<P>*/ </P>

<P></P>

<P>hmenu = GetSubMenu(GetMenu(hwndMain), 2); </P>

<P>cItems = GetMenuItemCount(hmenu); </P>

<P></P>

<P>/* </P>

<P>* Get the text of each item, strip out the '&amp;' and </P>

<P>* the accelerator text, and add the text to the </P>

<P>* menu-item combo box. </P>

<P>*/ </P>

<P></P>

<P>for (i = 0; i &lt; cItems; i++) { </P>

<P>if (!(GetMenuString(hmenu, i, szTemp, </P>

<P>sizeof(szTemp), MF_BYPOSITION))) </P>

<P>continue; </P>

<P>for (pch = szTemp, pch2 = szItem; </P>

<P>*pch != '\0'; ) { </P>

<P></P>

<P>if (*pch != '&amp;') { </P>

<P>if (*pch == '\t') { </P>

<P>*pch = '\0'; </P>

<P>*pch2 = '\0'; </P>

<P>} </P>

<P>else </P>

<P>*pch2++ = *pch++; </P>

<P>} </P>

<P>else </P>

<P>pch++; </P>

<P>} </P>

<P>SendMessage(hwndCtl, CB_ADDSTRING, 0, </P>

<P>(LONG) (LPSTR) szItem); </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Now fill the keystroke combo box with the list of </P>

<P>* keystrokes that will be allowed for accelerators. </P>

<P>* The list of keystrokes is in the application-defined </P>

<P>* structure called "vkeys". </P>

<P>*/ </P>

<P></P>

<P>hwndCtl = GetDlgItem(hwndDlg, IDD_KEYSTROKES); </P>

<P>for (i = 0; i &lt; MAXKEYS; i++) </P>

<P>SendMessage(hwndCtl, CB_ADDSTRING, 0, </P>

<P>(LONG) (LPSTR) vkeys[i].pKeyString); </P>

<P></P>

<P>return TRUE; </P>

<P></P>

<P>case WM_COMMAND: </P>

<P>switch (LOWORD(wParam)) { </P>

<P>case IDD_MENUITEMS: </P>

<P></P>

<P>/* </P>

<P>* The user must select an item from the menu- </P>

<P>* item combo box. This flag is checked during </P>

<P>* IDOK processing to be sure a selection was made. </P>

<P>*/ </P>

<P></P>

<P>fItemSelected = TRUE; </P>

<P>return 0; </P>

<P></P>

<P>case IDD_KEYSTROKES: </P>

<P></P>

<P>/* </P>

<P>* The user must select an item from the menu- </P>

<P>* item combo box. This flag is checked during </P>

<P>* IDOK processing to be sure a selection was made. </P>

<P>*/ </P>

<P></P>

<P>fKeySelected = TRUE; </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>case IDOK: </P>

<P></P>

<P>/* </P>

<P>* If the user has not selected a menu item </P>

<P>* and a keystroke, display a reminder in a </P>

<P>* message box. </P>

<P>*/ </P>

<P></P>

<P>if (!fItemSelected || !fKeySelected) { </P>

<P>MessageBox(hwndDlg, </P>

<P>"Item or key not selected.", NULL, </P>

<P>MB_OK); </P>

<P>return 0; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Determine whether the CTRL, ALT, and SHIFT </P>

<P>* keys are selected. Concatenate the </P>

<P>* appropriate strings to the accelerator- </P>

<P>* text buffer, and set the appropriate </P>

<P>* accelerator flags. </P>

<P>*/ </P>

<P></P>

<P>szAccelText[0] = '\0'; </P>

<P>hwndCtl = GetDlgItem(hwndDlg, IDD_CNTRL); </P>

<P>if (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) </P>

<P>== 1) { </P>

<P>lstrcat(szAccelText, "Ctl+"); </P>

<P>fAccelFlags |= FCONTROL; </P>

<P>} </P>

<P>hwndCtl = GetDlgItem(hwndDlg, IDD_ALT); </P>

<P>if (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) </P>

<P>== 1) { </P>

<P>lstrcat(szAccelText, "Alt+"); </P>

<P>fAccelFlags |= FALT; </P>

<P>} </P>

<P>hwndCtl = GetDlgItem(hwndDlg, IDD_SHIFT); </P>

<P>if (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) </P>

<P>== 1) { </P>

<P>lstrcat(szAccelText, "Shft+"); </P>

<P>fAccelFlags |= FSHIFT; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Get the selected keystroke, and look up the </P>

<P>* accelerator text and the virtual-key code </P>

<P>* for the keystroke in the vkeys structure. </P>

<P>*/ </P>

<P></P>

<P>hwndCtl = GetDlgItem(hwndDlg, IDD_KEYSTROKES); </P>

<P>nCurSel = (int) SendMessage(hwndCtl, </P>

<P>CB_GETCURSEL, 0, 0); </P>

<P>SendMessage(hwndCtl, CB_GETLBTEXT, </P>

<P>nCurSel, (LONG) (LPSTR) szKeyStroke); </P>

<P>for (i = 0; i &lt; MAXKEYS; i++) { </P>

<P>if(lstrcmp(vkeys[i].pKeyString, </P>

<P>szKeyStroke) == 0) { </P>

<P>lstrcpy(szKeyStroke, </P>

<P>vkeys[i].pKeyName); </P>

<P>break; </P>

<P>} </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Concatenate the keystroke text to the </P>

<P>* "Ctl+","Alt+", or "Shft+" string. </P>

<P>*/ </P>

<P></P>

<P>lstrcat(szAccelText, szKeyStroke); </P>

<P></P>

<P>/* </P>

<P>* Determine the position in the menu of the </P>

<P>* selected menu item. Menu items in the </P>

<P>* "Character" menu have positions 0,2,3, and 4. </P>

<P>*/ </P>

<P></P>

<P>if (lstrcmp(szItem, "Regular") == 0) </P>

<P>uItemPos = 0; </P>

<P>else if (lstrcmp(szItem, "Bold") == 0) </P>

<P>uItemPos = 2; </P>

<P>else if (lstrcmp(szItem, "Italic") == 0) </P>

<P>uItemPos = 3; </P>

<P>else if (lstrcmp(szItem, "Underline") == 0) </P>

<P>uItemPos = 4; </P>

<P></P>

<P>/* </P>

<P>* Get the string that corresponds to the </P>

<P>* selected item. </P>

<P>*/ </P>

<P></P>

<P>GetMenuString(hmenu, uItemPos, szItem, </P>

<P>sizeof(szItem), MF_BYPOSITION); </P>

<P></P>

<P>/* </P>

<P>* Append the new accelerator text to the </P>

<P>* menu-item text. </P>

<P>*/ </P>

<P></P>

<P>for (pch = szItem; *pch != '\t'; pch++); </P>

<P>++pch; </P>

<P></P>

<P>for (pch2 = szAccelText; *pch2 != '\0'; </P>

<P>pch2++) </P>

<P>*pch++ = *pch2; </P>

<P>*pch = '\0'; </P>

<P></P>

<P>/* </P>

<P>* Modify the menu item to reflect the new </P>

<P>* accelerator text. </P>

<P>*/ </P>

<P></P>

<P>idItem = GetMenuItemID(hmenu, uItemPos); </P>

<P>ModifyMenu(hmenu, idItem, MF_BYCOMMAND | </P>

<P>MF_STRING, idItem, szItem); </P>

<P></P>

<P>/* Reset the selection flags. */ </P>

<P></P>

<P>fItemSelected = FALSE; </P>

<P>fKeySelected = FALSE; </P>

<P></P>

<P>/* Save the current accelerator table. */ </P>

<P></P>

<P>haccelOld = haccel; </P>

<P></P>

<P>/* </P>

<P>* Count the number of entries in the current </P>

<P>* table, allocate a buffer for the table, and </P>

<P>* then copy the table into the buffer. </P>

<P>*/ </P>

<P></P>

<P>cAccelerators = CopyAcceleratorTable( </P>

<P>haccelOld, NULL, 0); </P>

<P>lpaccelNew = (LPACCEL) LocalAlloc(LPTR, </P>

<P>cAccelerators * sizeof(ACCEL)); </P>

<P></P>

<P>if (lpaccelNew != NULL) </P>

<P>CopyAcceleratorTable(haccel, lpaccelNew, </P>

<P>cAccelerators); </P>

<P></P>

<P>/* </P>

<P>* Find the accelerator that the user modified </P>

<P>* and change its flags and virtual-key code </P>

<P>* as appropriate. </P>

<P>*/ </P>

<P></P>

<P>for (i = 0; (lpaccelNew[i].cmd == </P>

<P>(WORD) idItem) </P>

<P>&amp;&amp; (i &lt; (UINT) cAccelerators); i++) { </P>

<P>lpaccelNew[i].fVirt = fAccelFlags; </P>

<P>lpaccelNew[i].key = wVKCode; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Create the new accelerator table, and </P>

<P>* destroy the old one. </P>

<P>*/ </P>

<P></P>

<P>DestroyAcceleratorTable(haccelOld); </P>

<P>haccel = CreateAcceleratorTable(lpaccelNew, </P>

<P>cAccelerators); </P>

<P></P>

<P>/* Destroy the dialog box. */ </P>

<P></P>

<P>EndDialog(hwndDlg, TRUE); </P>

<P>return 0; </P>

<P></P>

<P>case IDCANCEL: </P>

<P>EndDialog(hwndDlg, TRUE); </P>

<P>return TRUE; </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P>return FALSE; </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
