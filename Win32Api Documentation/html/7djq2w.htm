<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Storing an Image</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="7djq2w"></A><B>Storing an Image</B></P>

<P>Many applications store images permanently as files. For example, drawing applications store pictures, spreadsheet applications store charts, CAD applications store drawings, and so on. </P>

<P>If you are writing an application that will store a bitmapped image in a file, you should use the Windows file format described in <A HREF="19h8fmc.htm">Bitmap Storage</A>. In order to store a bitmap in this format, you must initialize a <A HREF=".2pxnh.htm"><B>BITMAPINFO</B></A> structure (consisting of a <A HREF="3p99xxp.htm"><B>BITMAPFILEHEADER</B></A> structure and an array of <A HREF="654who.htm"><B>RGBQUAD</B></A> structures), as well as an array of palette indices. </P>

<P>The following example code defines a function that allocates memory for and initializes members within a <A HREF="05za4g.htm"><B>BITMAPINFOHEADER</B></A> structure. </P>

<P>PBITMAPINFO CreateBitmapInfoStruct(HWND hwnd, HBITMAP hBmp) {  </P>

<P>BITMAP bmp; </P>

<P>PBITMAPINFO pbmi; </P>

<P>WORD    cClrBits; </P>

<P></P>

<P>/* Retrieve the bitmap's color format, width, and height. */ </P>

<P></P>

<P>if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&amp;bmp)) </P>

<P>errhandler("GetObject", hwnd); </P>

<P></P>

<P></P>

<P>/* Convert the color format to a count of bits. */ </P>

<P></P>

<P>cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel); </P>

<P></P>

<P>if (cClrBits == 1) </P>

<P>cClrBits = 1; </P>

<P>else if (cClrBits &lt;= 4) </P>

<P>cClrBits = 4; </P>

<P>else if (cClrBits &lt;= 8) </P>

<P>cClrBits = 8; </P>

<P>else if (cClrBits &lt;= 16) </P>

<P>cClrBits = 16; </P>

<P>else if (cClrBits &lt;= 24) </P>

<P>cClrBits = 24; </P>

<P>else </P>

<P>cClrBits = 32; </P>

<P></P>

<P>/* </P>

<P>* Allocate memory for the BITMAPINFO structure. (This structure </P>

<P>* contains a BITMAPINFOHEADER structure and an array of RGBQUAD data </P>

<P>* structures.) </P>

<P>*/ </P>

<P></P>

<P>if (cClrBits != 24) </P>

<P>pbmi = (PBITMAPINFO) LocalAlloc(LPTR, </P>

<P>sizeof(BITMAPINFOHEADER) + </P>

<P>sizeof(RGBQUAD) * (2^cClrBits)); </P>

<P></P>

<P>/* </P>

<P>* There is no RGBQUAD array for the 24-bit-per-pixel format. </P>

<P>*/ </P>

<P></P>

<P>else </P>

<P>pbmi = (PBITMAPINFO) LocalAlloc(LPTR, </P>

<P>sizeof(BITMAPINFOHEADER)); </P>

<P></P>

<P></P>

<P></P>

<P>/* Initialize the fields in the BITMAPINFO structure. */ </P>

<P></P>

<P>pbmi-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER); </P>

<P>pbmi-&gt;bmiHeader.biWidth = bmp.bmWidth; </P>

<P>pbmi-&gt;bmiHeader.biHeight = bmp.bmHeight; </P>

<P>pbmi-&gt;bmiHeader.biPlanes = bmp.bmPlanes; </P>

<P>pbmi-&gt;bmiHeader.biBitCount = bmp.bmBitsPixel; </P>

<P>if (cClrBits &lt; 24) </P>

<P>pbmi-&gt;bmiHeader.biClrUsed = 2^cClrBits; </P>

<P></P>

<P></P>

<P>/* If the bitmap is not compressed, set the BI_RGB flag. */ </P>

<P></P>

<P>pbmi-&gt;bmiHeader.biCompression = BI_RGB; </P>

<P></P>

<P>/* </P>

<P>* Compute the number of bytes in the array of color </P>

<P>* indices and store the result in biSizeImage. </P>

<P>*/ </P>

<P></P>

<P>pbmi-&gt;bmiHeader.biSizeImage = (pbmi-&gt;bmiHeader.biWidth + 7) /8 </P>

<P>* pbmi-&gt;bmiHeader.biHeight </P>

<P>* cClrBits; </P>

<P></P>

<P>/* </P>

<P>* Set biClrImportant to 0, indicating that all of the </P>

<P>* device colors are important. </P>

<P>*/ </P>

<P></P>

<P>pbmi-&gt;bmiHeader.biClrImportant = 0; </P>

<P></P>

<P>return pbmi; </P>

<P></P>

<P>} </P>

<P></P>

<P>The following example code defines a function that initializes the remaining structures, retrieves the array of palette indices, opens the file, copies the data, and closes the file. </P>

<P>void CreateBMPFile(HWND hwnd, LPTSTR pszFile, PBITMAPINFO pbi,  </P>

<P>HBITMAP hBMP, HDC hDC) </P>

<P>{ </P>

<P></P>

<P>HANDLE hf;                  /* file handle */ </P>

<P>BITMAPFILEHEADER hdr;       /* bitmap file-header */ </P>

<P>PBITMAPINFOHEADER pbih;     /* bitmap info-header */ </P>

<P>LPBYTE lpBits;              /* memory pointer */ </P>

<P>DWORD dwTotal;              /* total count of bytes */ </P>

<P>DWORD cb;                   /* incremental count of bytes */ </P>

<P>BYTE *hp;                   /* byte pointer */ </P>

<P>DWORD dwTmp; </P>

<P></P>

<P></P>

<P>pbih = (PBITMAPINFOHEADER) pbi; </P>

<P>lpBits = (LPBYTE) GlobalAlloc(GMEM_FIXED, pbih-&gt;biSizeImage);<BR>
    if (!lpBits) </P>

<P>errhandler("GlobalAlloc", hwnd); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the color table (RGBQUAD array) and the bits </P>

<P>* (array of palette indices) from the DIB. </P>

<P>*/ </P>

<P></P>

<P>if (!GetDIBits(hDC, hBMP, 0, (WORD) pbih-&gt;biHeight, </P>

<P>lpBits, pbi, DIB_RGB_COLORS)) </P>

<P>errhandler("GetDIBits", hwnd); </P>

<P></P>

<P>/* Create the .BMP file. */ </P>

<P></P>

<P>hf = CreateFile(pszFile, </P>

<P>GENERIC_READ | GENERIC_WRITE, </P>

<P>(DWORD) 0, </P>

<P>(LPSECURITY_ATTRIBUTES) NULL, </P>

<P>CREATE_ALWAYS, </P>

<P>FILE_ATTRIBUTE_NORMAL, </P>

<P>(HANDLE) NULL); </P>

<P></P>

<P>if (hf == INVALID_HANDLE_VALUE) </P>

<P>errhandler("CreateFile", hwnd); </P>

<P></P>

<P>hdr.bfType = 0x4d42;        /* 0x42 = "B" 0x4d = "M" */ </P>

<P></P>

<P>/* Compute the size of the entire file. */ </P>

<P></P>

<P>hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + </P>

<P>pbih-&gt;biSize + pbih-&gt;biClrUsed </P>

<P>* sizeof(RGBQUAD) + pbih-&gt;biSizeImage); </P>

<P></P>

<P>hdr.bfReserved1 = 0; </P>

<P>hdr.bfReserved2 = 0; </P>

<P></P>

<P>/* Compute the offset to the array of color indices. */ </P>

<P></P>

<P>hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + </P>

<P>pbih-&gt;biSize + pbih-&gt;biClrUsed </P>

<P>* sizeof (RGBQUAD); </P>

<P></P>

<P>/* Copy the BITMAPFILEHEADER into the .BMP file. */ </P>

<P></P>

<P>if (!WriteFile(hf, (LPVOID) &amp;hdr, sizeof(BITMAPFILEHEADER), </P>

<P>(LPDWORD) &amp;dwTmp, (LPOVERLAPPED) NULL)) </P>

<P>errhandler("WriteFile", hwnd); </P>

<P></P>

<P>/* Copy the BITMAPINFOHEADER and RGBQUAD array into the file. */ </P>

<P></P>

<P>if (!WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER) </P>

<P>+ pbih-&gt;biClrUsed * sizeof (RGBQUAD), </P>

<P>(LPDWORD) &amp;dwTmp, (LPOVERLAPPED) NULL)) </P>

<P>errhandler("WriteFile", hwnd); </P>

<P></P>

<P>/* Copy the array of color indices into the .BMP file. */ </P>

<P></P>

<P>dwTotal = cb = pbih-&gt;biSizeImage; </P>

<P>hp = lpBits; </P>

<P>while (cb &gt; MAXWRITE)  { </P>

<P>if (!WriteFile(hf, (LPSTR) hp, (int) MAXWRITE, </P>

<P>(LPDWORD) &amp;dwTmp, (LPOVERLAPPED) NULL)) </P>

<P>errhandler("WriteFile", hwnd); </P>

<P>cb-= MAXWRITE; </P>

<P>hp += MAXWRITE; </P>

<P>} </P>

<P>if (!WriteFile(hf, (LPSTR) hp, (int) cb, </P>

<P>(LPDWORD) &amp;dwTmp, (LPOVERLAPPED) NULL)) </P>

<P>errhandler("WriteFile", hwnd); </P>

<P></P>

<P>/* Close the .BMP file. */ </P>

<P></P>

<P>if (!CloseHandle(hf)) </P>

<P>errhandler("CloseHandle", hwnd); </P>

<P></P>

<P>/* Free memory. */<BR>
<BR>
    GlobalFree((HGLOBAL)lpBits);<BR>
} </P>

<P></P>

</BODY>
</HTML>
