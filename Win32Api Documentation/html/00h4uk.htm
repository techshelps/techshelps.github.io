<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Drawing Lines with the Mouse</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="00h4uk"></A><B>Drawing Lines with the Mouse</B></P>

<P>The example in this section demonstrates how to track the mouse cursor. It contains portions of a window procedure that enables the user to draw lines in a window's client area by dragging the mouse. </P>

<P>When the window procedure receives a <A HREF="065j6u.htm">WM_LBUTTONDOWN</A> message, it captures the mouse and saves the coordinates of the cursor, using the coordinates as the starting point of the line. It also uses the <A HREF="h4.ybz.htm"><B>ClipCursor</B></A> function to confine the cursor to the client area during the line drawing operation. </P>

<P>During the first <A HREF="1mq_iq2.htm">WM_MOUSEMOVE</A> message, the window procedure draws a line from the starting point to the current position of the cursor. During subsequent WM_MOUSEMOVE messages, the window procedure erases the previous line by drawing over it with an inverted pen color. Then it draws a new line from the starting point to the new position of the cursor. </P>

<P>The <A HREF="yl9yek.htm">WM_LBUTTONUP</A> message signals the end of the drawing operation. The window procedure releases the mouse capture and frees the mouse from the client area. </P>

<P>LRESULT APIENTRY MainWndProc(hwndMain, uMsg, wParam, lParam)  </P>

<P>HWND hwndMain; </P>

<P>UINT uMsg; </P>

<P>WPARAM wParam; </P>

<P>LPARAM lParam; </P>

<P>{ </P>

<P>HDC hdc;                       /* handle of device context  */ </P>

<P>RECT rcClient;                 /* client area rectangle     */ </P>

<P>POINT ptClientUL;              /* client upper left corner  */ </P>

<P>POINT ptClientLR;              /* client lower right corner */ </P>

<P>static POINTS ptsBegin;        /* beginning point           */ </P>

<P>static POINTS ptsEnd;          /* new endpoint              */ </P>

<P>static POINTS ptsPrevEnd;      /* previous endpoint         */ </P>

<P>static BOOL fPrevLine = FALSE; /* previous line flag        */ </P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_LBUTTONDOWN: </P>

<P></P>

<P>/* Capture mouse input. */ </P>

<P></P>

<P>SetCapture(hwndMain); </P>

<P></P>

<P>/* </P>

<P>* Retrieve the screen coordinates of the client area, </P>

<P>* and convert them into client coordinates. </P>

<P>/* </P>

<P></P>

<P>GetClientRect(hwndMain, &amp;rcClient); </P>

<P>ptClientUL.x = rcClient.left; </P>

<P>ptClientUL.y = rcClient.top; </P>

<P></P>

<P>/* </P>

<P>* Add one to the right and bottom sides, because the </P>

<P>* coordinates retrieved by GetClientRect do not </P>

<P>* include the far left and lowermost pixels. </P>

<P>*/ </P>

<P></P>

<P>ptClientLR.x = rcClient.right + 1; </P>

<P>ptClientLR.y = rcClient.bottom + 1; </P>

<P>ClientToScreen(hwndMain, &amp;ptClientUL); </P>

<P>ClientToScreen(hwndMain, &amp;ptClientLR); </P>

<P></P>

<P>/* </P>

<P>* Copy the client coordinates of the client area </P>

<P>* to the rcClient structure. Confine the mouse cursor </P>

<P>* to the client area by passing the rcClient structure </P>

<P>* to the ClipCursor function. </P>

<P>*/ </P>

<P></P>

<P>SetRect(&amp;rcClient, ptClientUL.x, ptClientUL.y, </P>

<P>ptClientLR.x, ptClientLR.y); </P>

<P>ClipCursor(&amp;rcClient); </P>

<P></P>

<P>/* </P>

<P>* Convert the cursor coordinates into a POINTS </P>

<P>* structure, which defines the beginning point of the </P>

<P>* line drawn during a WM_MOUSEMOVE message. </P>

<P>*/ </P>

<P></P>

<P>ptsBegin = MAKEPOINTS(lParam); </P>

<P>return 0; </P>

<P></P>

<P>case WM_MOUSEMOVE: </P>

<P></P>

<P>/* </P>

<P>* When moving the mouse, the user must hold down </P>

<P>* the left mouse button to draw lines. </P>

<P>*/ </P>

<P></P>

<P>if (wParam &amp; MK_LBUTTON) { </P>

<P></P>

<P>/* </P>

<P>* Retrieve a device context (DC) for the client </P>

<P>* area. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwndMain); </P>

<P></P>

<P>/* </P>

<P>* The following function ensures that pixels of </P>

<P>* the previously drawn line are set to white and </P>

<P>* those of the new line are set to black. </P>

<P>*/ </P>

<P></P>

<P>SetROP2(hdc, R2_NOTXORPEN); </P>

<P></P>

<P>/* </P>

<P>* If a line was drawn during an earlier </P>

<P>* WM_MOUSEMOVE message, draw over it. This erases </P>

<P>* the line by setting the color of its pixels to </P>

<P>* white. </P>

<P>*/ </P>

<P></P>

<P>if (fPrevLine) { </P>

<P>MoveToEx(hdc, ptsBegin.x, ptsBegin.y, </P>

<P>(LPPOINT) NULL); </P>

<P>LineTo(hdc, ptsPrevEnd.x, ptsPrevEnd.y); </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Convert the current cursor coordinates to a </P>

<P>* POINTS structure, and then draw a new line. </P>

<P>*/ </P>

<P></P>

<P>ptsEnd = MAKEPOINTS(lParam); </P>

<P>MoveToEx(hdc, ptsBegin.x, ptsBegin.y, </P>

<P>(LPPOINT) NULL); </P>

<P>LineTo(hdc, ptsEnd.x, ptsEnd.y); </P>

<P></P>

<P>/* </P>

<P>* Set the previous line flag, save the ending </P>

<P>* point of the new line, and then release the DC. </P>

<P>*/ </P>

<P></P>

<P>fPrevLine = TRUE; </P>

<P>ptsPrevEnd = ptsEnd; </P>

<P>ReleaseDC(hwndMain, hdc); </P>

<P>} </P>

<P>break; </P>

<P></P>

<P>case WM_LBUTTONUP: </P>

<P></P>

<P>/* </P>

<P>* The user has finished drawing the line. Reset the </P>

<P>* previous line flag, release the mouse cursor, and </P>

<P>* release the mouse capture. </P>

<P>*/ </P>

<P></P>

<P>fPrevLine = FALSE; </P>

<P>ClipCursor(NULL); </P>

<P>ReleaseCapture(); </P>

<P>return 0; </P>

<P></P>

<P>case WM_DESTROY: </P>

<P>PostQuitMessage(0); </P>

<P>break; </P>

<P></P>

<P>. </P>

<P>. /* Process other messages. */ </P>

<P>. </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
