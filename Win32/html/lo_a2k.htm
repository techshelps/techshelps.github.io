<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using Rectangles</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="lo_a2k"></A><B>Using Rectangles</B></P>

<P>The example in this section illustrates how to use the rectangle functions. It consists of the main window procedure from an application that enables the user to move and size a bitmap. </P>

<P>When the application starts, it draws a 32-pixel by 32-pixel bitmap in the upper left corner of the screen. The user can move the bitmap by dragging it. To size the bitmap, the user creates a target rectangle by dragging the mouse, then drags the bitmap and "drops" it on the target rectangle. The application responds by copying the bitmap into the target rectangle. </P>

<P>The window procedure that allows the user to move and size the bitmap is given in the following example. </P>

<P>LRESULT CALLBACK MainWndProc(hwnd, uMsg, wParam, lParam)  </P>

<P>HWND hwnd;      /* handle of window         */  </P>

<P>UINT uMsg;      /* message                  */ </P>

<P>WPARAM wParam;  /* first message parameter  */ </P>

<P>LPARAM lParam;  /* second message parameter */ </P>

<P>{ </P>

<P>HDC hdc;                 /* device context (DC) for window   */ </P>

<P>RECT rcTmp;              /* temporary rectangle              */ </P>

<P>PAINTSTRUCT ps;          /* paint data for Begin/EndPaint    */ </P>

<P>POINT ptClientUL;        /* client area upper left corner    */ </P>

<P>POINT ptClientLR;        /* client area lower right corner   */ </P>

<P>static HDC hdcCompat;    /* DC for copying bitmap            */ </P>

<P>static POINT pt;         /* x and y coordinates of cursor    */ </P>

<P>static RECT rcBmp;       /* rectangle that encloses bitmap   */ </P>

<P>static RECT rcTarget;    /* rectangle to receive bitmap      */ </P>

<P>static RECT rcClient;    /* client-area rectangle            */ </P>

<P>static BOOL fDragRect;   /* TRUE if bitmap rect. is dragged  */ </P>

<P>static HBITMAP hbmp;     /* handle of bitmap to display      */ </P>

<P>static HBRUSH hbrBkgnd;  /* handle of background-color brush */ </P>

<P>static COLORREF crBkgnd; /* color of client-area background  */ </P>

<P>static HPEN hpenDot;     /* handle of dotted pen             */ </P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_CREATE: </P>

<P></P>

<P>/* Load the bitmap resource. */ </P>

<P></P>

<P>hbmp = LoadBitmap(hinst, MAKEINTRESOURCE(1)); </P>

<P></P>

<P>/* </P>

<P>* Create a device context (DC) to hold the bitmap. </P>

<P>* The bitmap is copied from this DC to the window's DC </P>

<P>* whenever it must be drawn. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P>hdcCompat = CreateCompatibleDC(hdc); </P>

<P>SelectObject(hdcCompat, hbmp); </P>

<P></P>

<P>/* </P>

<P>* Create a brush of the same color as the background </P>

<P>* of the client area. The brush is used later to erase </P>

<P>* the old bitmap before copying the bitmap into the </P>

<P>* target rectangle. </P>

<P>*/ </P>

<P></P>

<P>crBkgnd = GetBkColor(hdc); </P>

<P>hbrBkgnd = CreateSolidBrush(crBkgnd); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P></P>

<P>/* </P>

<P>* Create a dotted pen. The pen is used to draw the </P>

<P>* bitmap rectangle as the user drags it. </P>

<P>*/ </P>

<P></P>

<P>hpenDot = CreatePen(PS_DOT, 1, RGB(0, 0, 0)); </P>

<P></P>

<P>/* </P>

<P>* Set the initial rectangle for the bitmap. Note that </P>

<P>* this application supports only a 32- by 32-pixel </P>

<P>* bitmap. The rectangle is slightly larger than the </P>

<P>* bitmap. </P>

<P>*/ </P>

<P></P>

<P>SetRect(&amp;rcBmp, 1, 1, 34, 34); </P>

<P>return 0; </P>

<P></P>

<P>case WM_PAINT: </P>

<P></P>

<P>/* </P>

<P>* Draw the bitmap rectangle and copy the bitmap into </P>

<P>* it. The 32-pixel by 32-pixel bitmap is centered </P>

<P>* in the rectangle by adding 1 to the left and top </P>

<P>* coordinates of the bitmap rectangle, and subtracting </P>

<P>* 2 from the right and bottom coordinates. </P>

<P>*/ </P>

<P></P>

<P>BeginPaint(hwnd, &amp;ps); </P>

<P>Rectangle(ps.hdc, rcBmp.left, rcBmp.top, </P>

<P>rcBmp.right, rcBmp.bottom); </P>

<P>StretchBlt(ps.hdc, rcBmp.left + 1, rcBmp.top + 1, </P>

<P>(rcBmp.right - rcBmp.left) - 2, </P>

<P>(rcBmp.bottom - rcBmp.top) - 2, hdcCompat, </P>

<P>0, 0, 32, 32, SRCCOPY); </P>

<P>EndPaint(hwnd, &amp;ps); </P>

<P>break; </P>

<P></P>

<P>case WM_MOVE: </P>

<P>case WM_SIZE: </P>

<P></P>

<P>/* </P>

<P>* Convert the client coordinates of the client-area </P>

<P>* rectangle to screen coordinates and save them in a </P>

<P>* rectangle. The rectangle is passed to the ClipCursor </P>

<P>* function during WM_LBUTTONDOWN processing. </P>

<P>*/ </P>

<P></P>

<P>GetClientRect(hwnd, &amp;rcClient); </P>

<P>ptClientUL.x = rcClient.left; </P>

<P>ptClientUL.y = rcClient.top; </P>

<P>ptClientLR.x = rcClient.right; </P>

<P>ptClientLR.y = rcClient.bottom; </P>

<P>ClientToScreen(hwnd, &amp;ptClientUL); </P>

<P>ClientToScreen(hwnd, &amp;ptClientLR); </P>

<P>SetRect(&amp;rcClient, ptClientUL.x, ptClientUL.y, </P>

<P>ptClientLR.x, ptClientLR.y); </P>

<P>return 0; </P>

<P></P>

<P>case WM_LBUTTONDOWN: </P>

<P></P>

<P>/* </P>

<P>* Restrict the mouse cursor to the client area. This </P>

<P>* ensures that the window receives a matching </P>

<P>* WM_LBUTTONUP message. </P>

<P>*/ </P>

<P></P>

<P>ClipCursor(&amp;rcClient); </P>

<P></P>

<P>/* Save the coordinates of the mouse cursor. */ </P>

<P></P>

<P>pt.x = (LONG) LOWORD(lParam); </P>

<P>pt.y = (LONG) HIWORD(lParam); </P>

<P></P>

<P>/* </P>

<P>* If the user has clicked the bitmap rectangle, redraw </P>

<P>* it using the dotted pen. Set the fDragRect flag to </P>

<P>* indicate that the user is about to drag the </P>

<P>* rectangle. </P>

<P>*/ </P>

<P></P>

<P>if (PtInRect(&amp;rcBmp, pt)) { </P>

<P>hdc = GetDC(hwnd); </P>

<P>SelectObject(hdc, hpenDot); </P>

<P>Rectangle(hdc, rcBmp.left, rcBmp.top, rcBmp.right, </P>

<P>rcBmp.bottom); </P>

<P>fDragRect = TRUE; </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P>} </P>

<P>return 0; </P>

<P></P>

<P>case WM_MOUSEMOVE: </P>

<P></P>

<P>/* </P>

<P>* Draw a target rectangle or drag the bitmap </P>

<P>* rectangle, depending on the status of the fDragRect </P>

<P>* flag. </P>

<P>*/ </P>

<P></P>

<P>if ((wParam &amp;&amp; MK_LBUTTON) </P>

<P>&amp;&amp; !fDragRect) {  /* draw a target rectangle */ </P>

<P></P>

<P>/* </P>

<P>* Set the mix mode so that the pen color is the </P>

<P>* inverse of the background color. The previous </P>

<P>* rectangle can then be erased by drawing </P>

<P>* another rectangle on top of it. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P>SetROP2(hdc, R2_NOTXORPEN); </P>

<P></P>

<P>/* </P>

<P>* If a previous target rectangle exists, erase </P>

<P>* it by drawing another rectangle on top of it. </P>

<P>*/ </P>

<P></P>

<P>if (!IsRectEmpty(&amp;rcTarget)) </P>

<P>Rectangle(hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom); </P>

<P></P>

<P>/* </P>

<P>* Save the coordinates of the target rectangle. </P>

<P>* Avoid invalid rectangles by ensuring that the </P>

<P>* value of the left coordinate is greater than </P>

<P>* that of the right coordinate, and that the </P>

<P>* value of the bottom coordinate is greater than </P>

<P>* that of the top. </P>

<P>*/ </P>

<P></P>

<P>if ((pt.x &lt; (LONG) LOWORD(lParam)) &amp;&amp; </P>

<P>(pt.y &gt; (LONG) HIWORD(lParam))) </P>

<P>SetRect(&amp;rcTarget, pt.x, HIWORD(lParam), </P>

<P>LOWORD(lParam), pt.y); </P>

<P></P>

<P>else if ((pt.x &gt; (LONG) LOWORD(lParam)) &amp;&amp; </P>

<P>(pt.y &gt; (LONG) HIWORD(lParam))) </P>

<P>SetRect(&amp;rcTarget, LOWORD(lParam), </P>

<P>HIWORD(lParam), pt.x, pt.y); </P>

<P></P>

<P>else if ((pt.x &gt; (LONG) LOWORD(lParam)) &amp;&amp; </P>

<P>(pt.y &lt; (LONG) HIWORD(lParam))) </P>

<P>SetRect(&amp;rcTarget, LOWORD(lParam), pt.y, </P>

<P>pt.x, HIWORD(lParam)); </P>

<P>else </P>

<P>SetRect(&amp;rcTarget, pt.x, pt.y, LOWORD(lParam), </P>

<P>HIWORD(lParam)); </P>

<P></P>

<P>/* Draw the new target rectangle. */ </P>

<P></P>

<P>Rectangle(hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P>} </P>

<P>else if ((wParam &amp;&amp; MK_LBUTTON) </P>

<P>&amp;&amp; fDragRect) { /* drag the bitmap rectangle */ </P>

<P></P>

<P>/* </P>

<P>* Set the mix mode so that the pen color is the </P>

<P>* inverse of the background color. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P>SetROP2(hdc, R2_NOTXORPEN); </P>

<P></P>

<P>/* </P>

<P>* Select the dotted pen into the DC and erase </P>

<P>* the previous bitmap rectangle by drawing </P>

<P>* another rectangle on top of it. </P>

<P>*/ </P>

<P></P>

<P>SelectObject(hdc, hpenDot); </P>

<P>Rectangle(hdc, rcBmp.left, rcBmp.top, </P>

<P>rcBmp.right, rcBmp.bottom); </P>

<P></P>

<P>/* </P>

<P>* Set the new coordinates of the bitmap </P>

<P>* rectangle, then redraw it. </P>

<P>*/ </P>

<P></P>

<P>OffsetRect(&amp;rcBmp, LOWORD(lParam) - pt.x, </P>

<P>HIWORD(lParam) - pt.y); </P>

<P>Rectangle(hdc, rcBmp.left, rcBmp.top, </P>

<P>rcBmp.right, rcBmp.bottom); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P></P>

<P>/* Save the coordinates of the mouse cursor. */ </P>

<P></P>

<P>pt.x = (LONG) LOWORD(lParam); </P>

<P>pt.y = (LONG) HIWORD(lParam); </P>

<P>} </P>

<P>return 0; </P>

<P></P>

<P>case WM_LBUTTONUP: </P>

<P></P>

<P>/* </P>

<P>* If the bitmap rectangle and target rectangle </P>

<P>* intersect, copy the bitmap into the target </P>

<P>* rectangle. Otherwise, copy the bitmap into the </P>

<P>* rectangle bitmap at its new location. </P>

<P>*/ </P>

<P></P>

<P>if (IntersectRect(&amp;rcTmp, &amp;rcBmp, &amp;rcTarget)) { </P>

<P></P>

<P>/* </P>

<P>* Erase the bitmap rectangle by filling it with </P>

<P>* the background color. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P>FillRect(hdc, &amp;rcBmp, hbrBkgnd); </P>

<P></P>

<P>/* </P>

<P>* Redraw the target rectangle because the part </P>

<P>* that intersected with the bitmap rectangle was </P>

<P>* erased by the call to FillRect. </P>

<P>*/ </P>

<P></P>

<P>Rectangle(hdc, rcTarget.left, rcTarget.top, </P>

<P>rcTarget.right, rcTarget.bottom); </P>

<P></P>

<P>/* Copy the bitmap into the target rectangle. */ </P>

<P></P>

<P>StretchBlt(hdc, rcTarget.left + 1, rcTarget.top + 1, </P>

<P>(rcTarget.right - rcTarget.left) - 2, </P>

<P>(rcTarget.bottom - rcTarget.top) - 2, hdcCompat, </P>

<P>0, 0, 32, 32, SRCCOPY); </P>

<P></P>

<P>/* </P>

<P>* Copy the target rectangle to the bitmap </P>

<P>* rectangle, set the coordinates of the target </P>

<P>* rectangle to 0, then reset the fDragRect flag. </P>

<P>*/ </P>

<P></P>

<P>CopyRect(&amp;rcBmp, &amp;rcTarget); </P>

<P>SetRectEmpty(&amp;rcTarget); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P>fDragRect = FALSE; </P>

<P>} </P>

<P></P>

<P>else if (fDragRect) { </P>

<P></P>

<P>/* </P>

<P>* Draw the bitmap rectangle, copy the bitmap into </P>

<P>* it, and reset the fDragRect flag. </P>

<P>*/ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P>Rectangle(hdc, rcBmp.left, rcBmp.top, </P>

<P>rcBmp.right, rcBmp.bottom); </P>

<P>StretchBlt(hdc, rcBmp.left + 1, rcBmp.top + 1, </P>

<P>(rcBmp.right - rcBmp.left) - 2, </P>

<P>(rcBmp.bottom - rcBmp.top) - 2, hdcCompat, </P>

<P>0, 0, 32, 32, SRCCOPY); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P>fDragRect = FALSE; </P>

<P>} </P>

<P></P>

<P>/* Release the mouse cursor. */ </P>

<P></P>

<P>ClipCursor((LPRECT) NULL); </P>

<P>return 0; </P>

<P></P>

<P>case WM_DESTROY: </P>

<P></P>

<P>/* </P>

<P>* Destroy the background brush, compatible bitmap, </P>

<P>* and the bitmap. </P>

<P>*/ </P>

<P></P>

<P>DeleteObject(hbrBkgnd); </P>

<P>DeleteDC(hdcCompat); </P>

<P>DeleteObject(hbmp); </P>

<P>PostQuitMessage(0); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>return DefWindowProc(hwnd, uMsg, wParam, lParam); </P>

<P>} </P>

<P>return (LRESULT) NULL; </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
