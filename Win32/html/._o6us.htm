<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Adding Tree-View Items</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="._o6us"></A><B>Adding Tree-View Items</B></P>

<P>You add an item to a tree-view control by sending the <A HREF="1nhhe.9.htm">TVM_INSERTITEM</A> message to the control. The message includes a pointer to a <A HREF="zhf5da.htm"><B>TV_INSERTSTRUCT</B></A> structure, specifying the parent item, the item after which the new item is inserted, and a <A HREF="2ihaq35.htm"><B>TV_ITEM</B></A> structure that defines the attributes of the item. The attributes include the item's label, its selected and nonselected images, and a 32-bit application-defined value. </P>

<P>The example in this section creates a table of contents based on the information in a text file. The example includes two functions. The first function searches a file for headings. When it finds one, it extracts the text of the heading and the value that indicates the level of the heading and then passes them to the second function. Headings are assumed to be in the following form, .[<I>heading</I>].<I>n</I>, where <I>heading</I> is the text of the heading and <I>n</I> indicates the heading level. The example ignores heading levels greater than level four. </P>

<P>The second function adds an item to a tree-view control, using the heading text as the item's label and the heading level to determine the parent item for the new item. A level one heading is added to the root of the tree-view control, a level two heading is added as a child item of the previous level one item, and so on. The function assigns an image to an item based on whether it has any child items. If an item has child items, it gets an image representing a closed folder. Otherwise, it gets an image representing a document. An item uses the same image for both the selected and nonselected states.</P>

<P>// InitTreeViewItems - extracts headings from the specified file and  </P>

<P>//     passes them to a function that adds them to a tree-view control. </P>

<P>// Returns TRUE if successful or FALSE otherwise. </P>

<P>// hwndTV - handle of the tree-view control </P>

<P>// lpszFileName - name of file with headings </P>

<P>BOOL InitTreeViewItems(HWND hwndTV, LPSTR lpszFileName) </P>

<P>{ </P>

<P>HANDLE hf;            // handle of file </P>

<P>DWORD cbRead;         // number of bytes read </P>

<P>char szItemText[128]; // label text of tree-view item </P>

<P>int nLevel;           // heading level </P>

<P>LPCH pch;             // pointer to data read from file </P>

<P>LPCH pchTmp;          // temporary pointer </P>

<P>DWORD i, j;           // counters </P>

<P></P>

<P>// Open the file to parse. </P>

<P>if ((hf = CreateFile(lpszFileName, GENERIC_READ, </P>

<P>FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES) NULL, </P>

<P>OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, </P>

<P>(HANDLE) NULL)) == (HANDLE) INVALID_HANDLE_VALUE) </P>

<P>return FALSE; </P>

<P></P>

<P>// Parse the file looking for headings. </P>

<P>pch = (LPCH) LocalAlloc(LPTR, sizeof(char) * 2048); </P>

<P>pchTmp = pch; </P>

<P>do { </P>

<P>// Read a chunk of the file. </P>

<P>ReadFile(hf, pchTmp, sizeof(char) * 2048, &amp;cbRead, </P>

<P>(LPOVERLAPPED) NULL); </P>

<P>// Parse the chunk looking for ".[". </P>

<P>for (i = 0, j = 0; i &lt; cbRead; i++) { </P>

<P>if ((i + 2) &gt; cbRead)    // break if end of chunk </P>

<P>break; </P>

<P></P>

<P>// Extract the heading text from between the brackets. </P>

<P>if ((*pchTmp == '.') &amp;&amp; (*(pchTmp+1) == '[')) { </P>

<P>pchTmp = pchTmp + 2; </P>

<P>i += 2; </P>

<P>while (*pchTmp != ']' &amp;&amp; ((i++) &lt;= cbRead) ) </P>

<P>szItemText[j++] = *pchTmp++; </P>

<P>szItemText[j] = '\0'; </P>

<P>j = 0; </P>

<P>nLevel = atoi(pchTmp + 2); </P>

<P></P>

<P>// Add the item to the tree-view control. </P>

<P>AddItemToTree(hwndTV, (LPSTR) &amp;szItemText, nLevel); </P>

<P>} else </P>

<P>++pchTmp; </P>

<P>} </P>

<P>pchTmp = pch; </P>

<P>} while (cbRead != 0); </P>

<P>CloseHandle((HANDLE) hf); </P>

<P></P>

<P>return TRUE; </P>

<P>} </P>

<P></P>

<P>// AddItemToTree - adds items to a tree-view control. </P>

<P>// Returns the handle of the newly added item. </P>

<P>// hwndTV - handle of the tree-view control </P>

<P>// lpszItem - text of the item to add </P>

<P>// nLevel - level at which to add the item </P>

<P>HTREEITEM AddItemToTree(HWND hwndTV, LPSTR lpszItem, int nLevel) </P>

<P>{ </P>

<P>TV_ITEM tvi; </P>

<P>TV_INSERTSTRUCT tvins; </P>

<P>static HTREEITEM hPrev = (HTREEITEM) TVI_FIRST; </P>

<P>static HTREEITEM hPrevRootItem = NULL; </P>

<P>static HTREEITEM hPrevLev2Item = NULL; </P>

<P>HTREEITEM hti; </P>

<P></P>

<P>tvi.mask = TVIF_TEXT | TVIF_IMAGE </P>

<P>| TVIF_SELECTEDIMAGE | TVIF_PARAM; </P>

<P></P>

<P>// Set the text of the item. </P>

<P>tvi.pszText = lpszItem; </P>

<P>tvi.cchTextMax = lstrlen(lpszItem); </P>

<P></P>

<P>// Assume the item is not a parent item, so give it a </P>

<P>// document image. </P>

<P>tvi.iImage = g_nDocument; </P>

<P>tvi.iSelectedImage = g_nDocument; </P>

<P></P>

<P>// Save the heading level in the item's application-defined </P>

<P>// data area. </P>

<P>tvi.lParam = (LPARAM) nLevel; </P>

<P></P>

<P>tvins.item = tvi; </P>

<P>tvins.hInsertAfter = hPrev; </P>

<P></P>

<P>// Set the parent item based on the specified level. </P>

<P>if (nLevel == 1) </P>

<P>tvins.hParent = TVI_ROOT; </P>

<P>else if (nLevel == 2) </P>

<P>tvins.hParent = hPrevRootItem; </P>

<P>else </P>

<P>tvins.hParent = hPrevLev2Item; </P>

<P></P>

<P>// Add the item to the tree-view control. </P>

<P>hPrev = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEM, 0, </P>

<P>(LPARAM) (LPTV_INSERTSTRUCT) &amp;tvins); </P>

<P></P>

<P>// Save the handle of the item. </P>

<P>if (nLevel == 1) </P>

<P>hPrevRootItem = hPrev; </P>

<P>else if (nLevel == 2) </P>

<P>hPrevLev2Item = hPrev; </P>

<P></P>

<P>// The new item is a child item. Give the parent item a </P>

<P>// closed folder bitmap to indicate it now has child items. </P>

<P>if (nLevel &gt; 1) { </P>

<P>hti = TreeView_GetParent(hwndTV, hPrev); </P>

<P>tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE; </P>

<P>tvi.hItem = hti; </P>

<P>tvi.iImage = g_nClosed; </P>

<P>tvi.iSelectedImage = g_nClosed; </P>

<P>TreeView_SetItem(hwndTV, &amp;tvi); </P>

<P>} </P>

<P></P>

<P>return hPrev; </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
