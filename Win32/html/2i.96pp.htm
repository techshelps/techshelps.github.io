<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Single Conversations</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="2i.96pp"></A><B>Single Conversations</B></P>

<P>A client application requests a single conversation with a server by calling the <A HREF="1_izsoe.htm"><B>DdeConnect</B></A> function and specifying string handles that identify the strings containing the service name of the server application and the topic name for the conversation. The DDEML responds by sending the <A HREF="a65c1_.htm">XTYP_CONNECT</A> transaction to the DDE callback function of each server application that either has registered a service name that matches the one specified in <B>DdeConnect</B> or has turned service name filtering off by calling <A HREF="189edyl.htm"><B>DdeNameService</B></A>. A server can also filter XTYP_CONNECT transactions by specifying the CBF_FAIL_CONNECTIONS filter flag in the <A HREF="1_pfuxk.htm"><B>DdeInitialize</B></A> function. During the XTYP_CONNECT transaction, the DDEML passes the service name and the topic name to the server. The server must examine the names and return TRUE if it supports the service name and topic name pair or FALSE if it does not. </P>

<P>If no server responds positively to the client's request to connect, the client receives NULL from <B>DdeConnect</B> and no conversation is established. If a server returns TRUE, a conversation is established and the client receives a conversation handle ¾ a doubleword value that identifies the conversation. The client uses the handle in subsequent DDEML calls to obtain data from the server. The server receives the <A HREF="15nkap6.htm">XTYP_CONNECT_CONFIRM</A> transaction (unless the server specified the CBF_SKIP_CONNECT_CONFIRMS filter flag). This transaction passes the conversation handle to the server. </P>

<P>The following example requests a conversation on the System topic with a server that recognizes the service name MyServer. The <I>hszServName</I> and <I>hszSysTopic</I> parameters are previously created string handles. </P>

<P>HCONV hConv;         /* conversation handle            */  </P>

<P>HWND hwndParent;     /* parent window handle           */  </P>

<P>HSZ hszServName;     /* service name string handle     */ </P>

<P>HSZ hszSysTopic;     /* System topic string handle     */ </P>

<P>. </P>

<P>. </P>

<P></P>

<P>hConv = DdeConnect( </P>

<P>idInst,               /* instance identifier        */ </P>

<P>hszServName,          /* service name string handle */ </P>

<P>hszSysTopic,          /* System topic string handle */ </P>

<P>(PCONVCONTEXT) NULL); /* use default context        */ </P>

<P></P>

<P>if (hConv == NULL) { </P>

<P>MessageBox(hwndParent, "MyServer is unavailable.", </P>

<P>(LPSTR) NULL, MB_OK); </P>

<P>return FALSE; </P>

<P>} </P>

<P>. </P>

<P>. </P>

<P>. </P>

<P></P>

<P>In the preceding example, <A HREF="1_izsoe.htm"><B>DdeConnect</B></A> causes the DDE callback function of the MyServer application to receive an <A HREF="a65c1_.htm">XTYP_CONNECT</A> transaction. </P>

<P>In the following example, the server responds to the XTYP_CONNECT transaction by comparing the topic name string handle the DDEML passed to the server with each element in the array of topic name string handles the server supports. If the server finds a match, it establishes the conversation. </P>

<P>#define CTOPICS 5  </P>

<P></P>

<P>HSZ hsz1;                  /* string handle passed by DDEML  */ </P>

<P>HSZ ahszTopics[CTOPICS];   /* array of supported topics      */ </P>

<P>int i;                     /* loop counter                   */ </P>

<P></P>

<P>. </P>

<P>. /* Use a switch statement to examine transaction types. */ </P>

<P>. </P>

<P></P>

<P>case XTYP_CONNECT: </P>

<P>for (i = 0; i &lt; CTOPICS; i++) { </P>

<P>if (hsz1 == ahszTopics[i]) </P>

<P>return TRUE;   /* establish a conversation       */ </P>

<P>} </P>

<P></P>

<P>return FALSE; /* topic not supported; deny conversation  */ </P>

<P></P>

<P>. </P>

<P>. /* Process other transaction types. */ </P>

<P>. </P>

<P></P>

<P>If the server returns TRUE in response to the <A HREF="a65c1_.htm">XTYP_CONNECT</A> transaction, the DDEML sends an <A HREF="15nkap6.htm">XTYP_CONNECT_CONFIRM</A> transaction to the server's DDE callback function. The server can obtain the handle for the conversation by processing this transaction. </P>

<P>A client can establish a wildcard conversation by specifying NULL for the service name string handle, the topic name string handle, or both in a call to <A HREF="1_izsoe.htm"><B>DdeConnect</B></A>. If at least one of the string handles is NULL, the DDEML sends the <A HREF="hf4ju2.htm">XTYP_WILDCONNECT</A> transaction to the callback functions of all DDE applications (except those that filter the XTYP_WILDCONNECT transaction). Each server application should respond by returning a data handle that identifies a null-terminated array of <A HREF="hitezb.htm"><B>HSZPAIR</B></A> structures. If the server application has not called <A HREF="189edyl.htm"><B>DdeNameService</B></A> to register its service names and if filtering is on, the server does not receive XTYP_WILDCONNECT transactions. For more information about data handles, see <A HREF="esl8nk.htm">Data Management</A>. </P>

<P>The array must contain one structure for each service name and topic name pair that matches the pair specified by the client. The DDEML selects one of the pairs to establish a conversation and returns to the client a handle that identifies the conversation. The DDEML sends the XTYP_CONNECT_CONFIRM transaction to the server (unless the server filters this transaction). The following example shows a typical server response to the XTYP_WILDCONNECT transaction. </P>

<P>#define CTOPICS 2  </P>

<P></P>

<P>UINT uType; </P>

<P>HSZPAIR ahszp[(CTOPICS + 1)]; </P>

<P>HSZ ahszTopicList[CTOPICS]; </P>

<P>HSZ hszServ, hszTopic; </P>

<P>WORD i, j; </P>

<P></P>

<P>if (uType == XTYP_WILDCONNECT) { </P>

<P></P>

<P>/* </P>

<P>* Scan the topic list and create an array of HSZPAIR </P>

<P>* structures. </P>

<P>*/ </P>

<P></P>

<P>j = 0; </P>

<P>for (i = 0; i &lt; CTOPICS; i++) { </P>

<P>if (hszTopic == (HSZ) NULL || </P>

<P>hszTopic == ahszTopicList[i]) { </P>

<P>ahszp[j].hszSvc = hszServ; </P>

<P>ahszp[j++].hszTopic = ahszTopicList[i]; </P>

<P>} </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* End the list with an HSZPAIR structure that contains NULL </P>

<P>* string handles as its members. </P>

<P>*/ </P>

<P></P>

<P>ahszp[j].hszSvc = NULL; </P>

<P>ahszp[j++].hszTopic = NULL; </P>

<P></P>

<P>/* </P>

<P>* Return a handle to a global memory object containing the </P>

<P>* HSZPAIR structures. </P>

<P>*/ </P>

<P></P>

<P>return DdeCreateDataHandle( </P>

<P>idInst,          /* instance identifier     */ </P>

<P>(LPBYTE) &amp;ahszp, /* points to HSZPAIR array */ </P>

<P>sizeof(HSZ) * j, /* length of the array     */ </P>

<P>0,               /* start at the beginning  */ </P>

<P>(HSZ) NULL,      /* no item name string     */ </P>

<P>0,               /* return the same format  */ </P>

<P>0);              /* let the system own it   */ </P>

<P>} </P>

<P></P>

<P>Either the client or the server can terminate a conversation at any time by calling the <A HREF="0._qht.htm"><B>DdeDisconnect</B></A> function. This function causes the callback function of the partner in the conversation to receive the <A HREF="1jgppl1.htm">XTYP_DISCONNECT</A> transaction (unless the partner specified the CBF_SKIP_DISCONNECTS filter flag). Typically, an application responds to the XTYP_DISCONNECT transaction by using the <A HREF="14336h1.htm"><B>DdeQueryConvInfo</B></A> function to obtain information about the conversation that terminated. After the callback function returns from processing the XTYP_DISCONNECT transaction, the conversation handle is no longer valid. </P>

<P>A client application that receives an XTYP_DISCONNECT transaction in its DDE callback function can attempt to reestablish the conversation by calling the <A HREF="jokj3l.htm"><B>DdeReconnect</B></A> function. The client must call <B>DdeReconnect</B> from within its DDE callback function. </P>

</BODY>
</HTML>
