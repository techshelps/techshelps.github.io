<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Monitoring Applications</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="5il.ns"></A><B>Monitoring Applications</B></P>

<P>The application programming interface (API) elements of the DDEML can be used to create an application that monitors DDE activity in the system. Like any DDEML application, a DDE monitoring application contains a DDE callback function. The DDEML notifies a monitoring application's DDE callback function whenever a DDE event occurs, passing information about the event to the callback function. The application typically displays the information in a window or writes it to a file. </P>

<P>To receive notifications from the DDEML, an application must have registered as a DDE monitor by specifying the APPCLASS_MONITOR flag in a call to the <A HREF="1_pfuxk.htm"><B>DdeInitialize</B></A> function. In this same call, the application can specify one or more monitor flags to indicate the types of events for which the DDEML is to notify the application's callback function. The following monitor flags can be specified by an application: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=28%><B>Flag</B></TD>
<TD width=72%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MF_CALLBACKS</TD>
<TD width=72%>Notifies the callback function whenever a transaction is sent to any DDE callback function in the system.</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MF_CONV</TD>
<TD width=72%>Notifies the callback function whenever a conversation is established or terminated.</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MF_ERRORS</TD>
<TD width=72%>Notifies the callback function whenever a DDEML error occurs.</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MF_HSZ_INFO</TD>
<TD width=72%>Notifies the callback function whenever a DDEML application creates, frees, or increments the usage count of a string handle or whenever a string handle is freed as a result of a call to the <A HREF="cod.6m.htm"><B>DdeUninitialize</B></A> function.</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MF_LINKS</TD>
<TD width=72%>Notifies the callback function whenever an advise loop is started or ended.</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MF_POSTMSGS</TD>
<TD width=72%>Notifies the callback function whenever the system or an application posts a DDE message.</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>MF_SENDMSGS</TD>
<TD width=72%>Notifies the callback function whenever the system or an application sends a DDE message.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>The following example shows how to register a DDE monitoring application so that its DDE callback function receives notifications of all DDE events.</P>

<P>DWORD idInst;  </P>

<P>PFNCALLBACK lpDdeProc;  </P>

<P>hInst = hInstance; </P>

<P></P>

<P>if (DdeInitialize( </P>

<P>(LPDWORD) &amp;idInst,  /* instance identifier              */ </P>

<P>DDECallback,        /* points to callback function      */ </P>

<P>APPCLASS_MONITOR |  /* this is a monitoring application */ </P>

<P>MF_CALLBACKS     |  /* monitor callback functions       */ </P>

<P>MF_CONV          |  /* monitor conversation data        */ </P>

<P>MF_ERRORS        |  /* monitor DDEML errors             */ </P>

<P>MF_HSZ_INFO      |  /* monitor data handle activity     */ </P>

<P>MF_LINKS         |  /* monitor advise loops             */ </P>

<P>MF_POSTMSGS      |  /* monitor posted DDE messages      */ </P>

<P>MF_SENDMSGS,        /* monitor sent DDE messages        */ </P>

<P>0))                 /* reserved                         */ </P>

<P>return FALSE; </P>

<P></P>

<P>The DDEML informs a monitoring application of a DDE event by sending an <A HREF="8vsy6m.htm">XTYP_MONITOR</A> transaction to the application's DDE callback function. During this transaction, the DDEML passes a monitor flag that specifies the type of DDE event that has occurred and a handle of a DDE object that contains detailed information about the event. The DDEML provides a set of structures that the application can use to extract the information from the DDE object. There is a corresponding structure for each type of DDE event.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=32%><B>Structure</B></TD>
<TD width=68%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=32%><A HREF="1.dcpkf.htm"><B>MONCBSTRUCT</B></A></TD>
<TD width=68%>Contains information about a transaction.</TD>
</TR>

<TR VALIGN="top">
<TD width=32%><A HREF="ejx7jp.htm"><B>MONCONVSTRUCT</B></A></TD>
<TD width=68%>Contains information about a conversation.</TD>
</TR>

<TR VALIGN="top">
<TD width=32%><A HREF="14grrrk.htm"><B>MONERRSTRUCT</B></A></TD>
<TD width=68%>Contains information about the latest DDE error.</TD>
</TR>

<TR VALIGN="top">
<TD width=32%><A HREF="h0696y.htm"><B>MONLINKSTRUCT</B></A></TD>
<TD width=68%>Contains information about an advise loop.</TD>
</TR>

<TR VALIGN="top">
<TD width=32%><A HREF="jzbpun.htm"><B>MONHSZSTRUCT</B></A></TD>
<TD width=68%>Contains information about a string handle.</TD>
</TR>

<TR VALIGN="top">
<TD width=32%><A HREF="m.vztj.htm"><B>MONMSGSTRUCT</B></A></TD>
<TD width=68%>Contains information about a DDE message that was sent or posted.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>The following example shows the DDE callback function of a DDE monitoring application that formats information about each string handle event and then displays the information in a window. The function uses the <A HREF="jzbpun.htm"><B>MONHSZSTRUCT</B></A> structure to extract the information from the DDE object. </P>

<P>HDDEDATA CALLBACK DDECallback(uType, uFmt, hconv, hsz1, hsz2,  </P>

<P>hdata, dwData1, dwData2)  </P>

<P>UINT uType; </P>

<P>UINT uFmt; </P>

<P>HCONV hconv; </P>

<P>HSZ hsz1; </P>

<P>HSZ hsz2; </P>

<P>HDDEDATA hdata; </P>

<P>DWORD dwData1; </P>

<P>DWORD dwData2; </P>

<P>{ </P>

<P>LPVOID lpData; </P>

<P>CHAR *szAction; </P>

<P>CHAR szBuf[256]; </P>

<P>DWORD cb; </P>

<P></P>

<P>switch (uType) { </P>

<P>case XTYP_MONITOR: </P>

<P></P>

<P>/* Obtain a pointer to the global memory object. */ </P>

<P></P>

<P>if (lpData = DdeAccessData(hdata, &amp;cb)) { </P>

<P></P>

<P>/* Examine the monitor flag. */ </P>

<P></P>

<P>switch (dwData2) { </P>

<P>case MF_HSZ_INFO: </P>

<P></P>

<P>#define PHSZS ((MONHSZSTRUCT FAR *)lpData) </P>

<P></P>

<P>/* </P>

<P>* The global memory object contains </P>

<P>* string handle data. Use the MONHSZSTRUCT </P>

<P>* structure to access the data. </P>

<P>*/ </P>

<P></P>

<P>switch (PHSZS-&gt;fsAction) { </P>

<P></P>

<P>/* </P>

<P>* Examine the action flags to </P>

<P>* determine the action performed on </P>

<P>* the handle. </P>

<P>*/ </P>

<P></P>

<P>case MH_CREATE: </P>

<P>szAction = "Created"; </P>

<P>break; </P>

<P></P>

<P>case MH_KEEP: </P>

<P>szAction = "Incremented"; </P>

<P>break; </P>

<P></P>

<P>case MH_DELETE: </P>

<P>szAction = "Deleted"; </P>

<P>break; </P>

<P></P>

<P>case MH_CLEANUP: </P>

<P>szAction = "Cleaned up"; </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>DdeUnaccessData(hdata); </P>

<P>return (HDDEDATA) 0; </P>

<P>} </P>

<P></P>

<P>/* Write formatted output to a buffer. */ </P>

<P></P>

<P>wsprintf(szBuf, </P>

<P>"Handle %s, Task: %x, Hsz: %lx(%s)", </P>

<P>(LPSTR) szAction, PHSZS-&gt;hTask, </P>

<P>PHSZS-&gt;hsz, (LPSTR) PHSZS-&gt;str); </P>

<P>. </P>

<P>. /* Display text or write to a file. */ </P>

<P>. </P>

<P></P>

<P>break; </P>

<P></P>

<P>#undef PHSZS </P>

<P></P>

<P>. </P>

<P>. /* Process other MF_* flags. */ </P>

<P>. </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P>} </P>

<P></P>

<P>/* Free the global memory object. */ </P>

<P></P>

<P>DdeUnaccessData(hdata); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>break; </P>

<P>} </P>

<P>return (HDDEDATA) 0; </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
