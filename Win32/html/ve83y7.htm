<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Embedded Objects</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="ve83y7"></A><B>Embedded Objects</B></P>

<P>When reconciling a document, the briefcase reconciler itself may become an initiator if it discovers an embedded object of a type that it cannot reconcile. In this case, the reconciler needs to recursively reconcile each of the embedded objects and assume all the responsibilities of an initiator. </P>

<P>To carry out the recursion, the briefcase reconciler loads the object and queries for the appropriate interface. The handler for the object must support the interface. If any member function of the interface returns the OLE_E_NOTRUNNING value, the reconciler must run the object in order to carry out the operation. Because code for embedded objects is not always available, a reconciler must provide a solution for this condition. For example, the reconciler might include both old and new versions of the embedded object in the reconciled version. The reconciler must not attempt to reconcile across links. </P>

<P>The initiator stores the document versions being merged. In many cases, the initiator has access to the storage of each version and saves the result of reconciliation using similar storage. Sometimes, however, the initiator may have an in-memory object for which no persistent version is available. This situation can occur when a document containing open embedded objects must be reconciled before being saved. In such cases, the initiator saves the result of the reconciliation in the version found in memory. </P>

<P>The initiator uses the <B>IPersistStorage</B> interface to bind (load) the merged version. The initiator uses the <B>IPersistStorage::Load</B> member function if an initial version has already been created and uses the <B>IPersistStorage::InitNew</B> member function for the initial version. Once the merged version is loaded, the initiator uses <B>QueryInterface</B> to retrieve the address of the <A HREF="32s446h.htm"><B>IReconcilableObject</B></A> interface. This interface gives the initiator access to the storage of the existing residues and gives it a way to create storage for any new residues. Then the initiator directs the interface to carry out the reconciliation. The initiator actually queries for the <B>IPersistFile</B> interface before <B>IPersistStorage</B>. If the reconciler supports <B>IPersistFile</B>, the initiator manipulates the replica through the <B>IPersistFile</B> rather than <B>IPersistStorage</B> member functions. This permits reconciliation of files that are not stored as compound documents.</P>

<P>Once the reconciliation is complete, the initiator can save the merged version by using the <B>IPersistStorage</B> or <B>IPersistFile</B> interface. During reconciliation, the briefcase reconciler creates residues as needed and writes their persistent bits to storage. If the merged version is a stream, the <B>IStorage</B> interface passed to <B>IPersistStorage::Load</B> contains a stream named "Contents" with its storage state set to STATEBITS_FLAT. (You can set the state bits by using the <B>IStorage::Stat</B> member function.) After the merge, the initiator saves the merged version by writing the data in an appropriate manner. It should ensure that STATEBITS_FLAT is set as appropriate for the storage.</P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
