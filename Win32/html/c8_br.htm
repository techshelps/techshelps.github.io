<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Creating a Resource List</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="c8_br"></A><B>Creating a Resource List</B></P>

<P>The following example creates a list of every resource in the HAND.EXE file. The list is written to the RESINFO.TXT file. </P>

<P>The code demonstrates how to load the executable file, create a file in which to write resource information, and call the <A HREF="22lzzlc.htm"><B>EnumResourceTypes</B></A> function to send each resource type found in the module to the application-defined callback function <B>EnumTypesFunc</B>. See <A HREF="hjj9pc.htm"><B>EnumResTypeProc</B></A> for information on callback functions of this type. This callback function uses the <A HREF="n3uxhn.htm"><B>EnumResourceNames</B></A> function to pass the name of every resource within the specified type to another application-defined callback function, <B>EnumNamesFunc</B>. See <A HREF="d7_s_u.htm"><B>EnumResNameProc</B></A> for information on callback functions of this type. <B>EnumNamesFunc</B> uses the <A HREF="251g2p4.htm"><B>EnumResourceLanguages</B></A> function to pass the language of every resource of the specified type and name to a third callback function, <B>EnumLangsFunc</B>. See <A HREF="4acdrp.htm"><B>EnumResLangProc</B></A> for information on callback functions of this type. <B>EnumLangsFunc</B> writes information about the resource of the specified type, name, and language to the RESINFO.TXT file. </P>

<P>char szBuffer[80]; // print buffer for EnumResourceTypes  </P>

<P>DWORD cbWritten;   // number of bytes written to res. info. file </P>

<P>int cbString;      // length of string in sprintf </P>

<P></P>

<P>// Declare callback functions. </P>

<P>BOOL EnumTypesFunc( </P>

<P>HANDLE hModule, </P>

<P>LPTSTR lpType, </P>

<P>LONG lParam); </P>

<P></P>

<P>BOOL EnumNamesFunc( </P>

<P>HANDLE hModule, </P>

<P>LPCTSTR lpType, </P>

<P>LPTSTR lpName, </P>

<P>LONG lParam); </P>

<P></P>

<P>BOOL EnumLangsFunc( </P>

<P>HANDLE hModule, </P>

<P>LPCTSTR lpType, </P>

<P>LPCTSTR lpName, </P>

<P>WORD wLang, </P>

<P>LONG lParam); </P>

<P></P>

<P>// Load the .EXE whose resources you want to list. </P>

<P>hExe = LoadLibrary("hand.exe"); </P>

<P></P>

<P>if (hExe == NULL) { </P>

<P>ErrorHandler("Could not load .EXE."); </P>

<P>} </P>

<P></P>

<P>// Create a file to contain the resource info. </P>

<P>hFile = CreateFile("resinfo.txt",      // name of file </P>

<P>GENERIC_READ | GENERIC_WRITE,      // access mode </P>

<P>0,                                 // share mode </P>

<P>(LPSECURITY_ATTRIBUTES) NULL,      // no security </P>

<P>CREATE_ALWAYS,                     // create flags </P>

<P>FILE_ATTRIBUTE_NORMAL,             // file attributes </P>

<P>(HANDLE) NULL);                    // no template </P>

<P>if (hFile == INVALID_HANDLE_VALUE) { </P>

<P>ErrorHandler("Could not open file."); </P>

<P>} </P>

<P></P>

<P>// Find all of the loaded file's resources. </P>

<P>cbString = sprintf(szBuffer, </P>

<P>"The file contains the following resources:\n\n"); </P>

<P></P>

<P>WriteFile(hFile,           // file to hold resource info. </P>

<P>szBuffer,              // what to write to the file </P>

<P>(DWORD) cbString,      // number of bytes in szBuffer </P>

<P>&amp;cbWritten,            // number of bytes written </P>

<P>NULL);                 // no overlapped I/O </P>

<P></P>

<P>EnumResourceTypes(hExe,              // module handle </P>

<P>(ENUMRESTYPEPROC)EnumTypesFunc,  // callback function </P>

<P>0);                              // extra parameter </P>

<P></P>

<P>// Unload the executable file whose resources were </P>

<P>// enumerated and close the file created to contain </P>

<P>// the resource information. </P>

<P></P>

<P>FreeLibrary(hExe); </P>

<P>CloseHandle(hFile); </P>

<P></P>

<P>//    FUNCTION: EnumTypesFunc(HANDLE, LPSTR, LONG) </P>

<P>// </P>

<P>//    PURPOSE:  Resource type callback </P>

<P></P>

<P>BOOL EnumTypesFunc( </P>

<P>HANDLE hModule,   // module handle </P>

<P>LPTSTR lpType,    // address of resource type </P>

<P>LONG lParam)      // extra parameter, could be </P>

<P>// used for error checking </P>

<P>{ </P>

<P>int cbString; </P>

<P></P>

<P>// Write the resource type to a resource information file. </P>

<P>// The type may be a string or an unsigned decimal </P>

<P>// integer, so test before printing. </P>

<P></P>

<P>if ((ULONG)lpType &amp; 0xFFFF0000) { </P>

<P>cbString = sprintf(szBuffer, "Type: %s\n", lpType); </P>

<P>} </P>

<P>else { </P>

<P>cbString = sprintf(szBuffer, "Type: %u\n", (USHORT)lpType); </P>

<P>} </P>

<P></P>

<P>WriteFile(hFile, szBuffer, (DWORD) cbString, </P>

<P>&amp;cbWritten, NULL); </P>

<P></P>

<P>// Find the names of all resources of type lpType. </P>

<P>EnumResourceNames(hModule, </P>

<P>lpType, </P>

<P>(ENUMRESNAMEPROC)EnumNamesFunc, </P>

<P>0); </P>

<P></P>

<P>return TRUE; </P>

<P>} </P>

<P></P>

<P>//    FUNCTION: EnumNamesFunc(HANDLE, LPSTR, LPSTR, LONG) </P>

<P>// </P>

<P>//    PURPOSE:  Resource name callback </P>

<P></P>

<P>BOOL EnumNamesFunc( </P>

<P>HANDLE hModule,   // module handle </P>

<P>LPCTSTR lpType,   // address of resource type </P>

<P>LPTSTR lpName,    // address of resource name </P>

<P>LONG lParam)      // extra parameter, could be </P>

<P>// used for error checking </P>

<P>{ </P>

<P>int cbString; </P>

<P></P>

<P>// Write the resource name to a resource information file. </P>

<P>// The name may be a string or an unsigned decimal </P>

<P>// integer, so test before printing. </P>

<P></P>

<P>if ((ULONG)lpName &amp; 0xFFFF0000) { </P>

<P>cbString = sprintf(szBuffer, "\tName: %s\n", lpName); </P>

<P>} </P>

<P>else { </P>

<P>cbString = sprintf(szBuffer, "\tName: %u\n", </P>

<P>(USHORT)lpName); </P>

<P>} </P>

<P></P>

<P>WriteFile(hFile, szBuffer, (DWORD) cbString, </P>

<P>&amp;cbWritten, NULL); </P>

<P></P>

<P>// Find the languages of all resources of type </P>

<P>// lpType and name lpName. </P>

<P></P>

<P>EnumResourceLanguages(hModule, </P>

<P>lpType, </P>

<P>lpName, </P>

<P>(ENUMRESLANGPROC)EnumLangsFunc, </P>

<P>0); </P>

<P></P>

<P>return TRUE; </P>

<P>} </P>

<P></P>

<P>//    FUNCTION: EnumLangsFunc(HANDLE, LPSTR, LPSTR, WORD, LONG) </P>

<P>// </P>

<P>//    PURPOSE:  Resource language callback </P>

<P></P>

<P>BOOL EnumLangsFunc( </P>

<P>HANDLE hModule,  // module handle </P>

<P>LPCTSTR lpType,  // address of resource type </P>

<P>LPCTSTR lpName,  // address of resource name </P>

<P>WORD wLang,      // resource language </P>

<P>LONG lParam)     // extra parameter, could be </P>

<P>used for error checking </P>

<P>{ </P>

<P>HANDLE hResInfo; </P>

<P>char szBuffer[80]; </P>

<P>int cbString = 0; </P>

<P></P>

<P>hResInfo = FindResourceEx(hModule, lpType, lpName, wLang); </P>

<P></P>

<P>// Write the resource language to the resource information file. </P>

<P>cbString = sprintf(szBuffer, "\t\tLanguage: %u\n", </P>

<P>(USHORT)wLang); </P>

<P></P>

<P>WriteFile(hFile, szBuffer, (DWORD) cbString, </P>

<P>&amp;cbWritten, NULL); </P>

<P></P>

<P>// Write the resource handle and size to buffer. </P>

<P>cbString = sprintf(szBuffer, </P>

<P>"\t\thResInfo == %lx,  Size == %lu\n\n", </P>

<P>hResInfo, </P>

<P>SizeofResource(hModule, hResInfo)); </P>

<P></P>

<P>WriteFile(hFile, szBuffer, (DWORD) cbString, </P>

<P>&amp;cbWritten, NULL); </P>

<P></P>

<P>return TRUE; </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
